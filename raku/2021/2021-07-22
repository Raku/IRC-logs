[00:27] *** MasterDuke left
[01:02] *** Util_ left
[01:05] *** yewscion joined
[01:17] *** Doc_Holliwood left
[01:21] *** Doc_Holliwood joined
[01:22] *** xinming_ left
[01:24] *** xinming_ joined
[02:16] *** frost joined
[03:03] *** Eddward__ joined
[03:05] *** Eddward_ left
[03:59] *** Util joined
[04:17] *** cornett joined
[04:32] *** yewscion left
[05:00] *** Doc_Holliwood left
[05:37] *** frost left
[05:40] <mykhal> oh, this btw addresses my .^methods>>.gist problem

[05:41] *** xinming_ is now known as xinming

[05:41] <mykhal> oh not, "" is not "".HOW, good morning, where is my coffee

[05:52] <mykhal> u: coffee

[05:52] <unicodable6> mykhal, Found nothing!

[05:53] <mykhal> u: beverage

[05:53] <unicodable6> mykhal, U+2615 HOT BEVERAGE [So] (☕)

[05:53] <unicodable6> mykhal, U+1F9C3 BEVERAGE BOX [So] (🧃)

[06:04] *** reportable6 joined
[06:07] <mykhal> u: tea.*cup

[06:07] <unicodable6> mykhal, U+0074 LATIN SMALL LETTER T [Ll] (t)

[06:07] <unicodable6> mykhal, U+0065 LATIN SMALL LETTER E [Ll] (e)

[06:07] <unicodable6> mykhal, 8 characters in total (tea.*cup): https://gist.github.com/6345a7f17c2aef91628f5bd61bbfa966

[06:08] <mykhal> u: tea cup

[06:08] <unicodable6> mykhal, U+1F375 TEACUP WITHOUT HANDLE [So] (🍵)

[06:38] *** frost joined
[06:47] *** ufobat__ joined
[06:50] *** Eddward__ left
[06:52] *** patrickb joined
[06:53] *** squashable6 left
[06:55] *** squashable6 joined
[07:00] *** MasterDuke joined
[07:03] *** ufobat_ joined
[07:07] *** ufobat__ left
[07:09] *** Sgeo left
[07:45] *** frost left
[07:56] *** abraxxa left
[08:03] *** yewscion joined
[08:11] *** yewscion left
[08:14] *** abraxxa joined
[08:16] *** Doc_Holliwood joined
[09:05] <Altreus> kebab case :D

[09:06] <Altreus> forgot that term

[09:06] *** pony left
[09:10] *** Kaipi left
[09:12] *** Kaiepi joined
[09:22] *** linkable6 joined
[09:23] *** linkable6 left
[09:37] *** frost joined
[10:37] *** evalable6 left
[10:40] *** evalable6 joined
[10:54] <Geth> ¦ doc: mykhal++ created pull request #3920: Uniname examples fix/update

[10:54] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3920

[10:59] *** sono left
[11:03] <Geth> ¦ doc: 01f5970c1e | (Michal Bozon)++ (committed by Juan Julián Merelo Guervós) | doc/Type/Cool.pod6

[11:03] <Geth> ¦ doc: Uniname examples fix/update

[11:03] <Geth> ¦ doc: 

[11:03] <Geth> ¦ doc: This fixes routine examples' excessive nested quoting;

[11:03] <Geth> ¦ doc: longest uniname probably from older data, current one is 6 chars longer.

[11:03] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/01f5970c1e

[11:37] *** patrickb left
[11:37] *** patrickb joined
[11:39] *** patrickb left
[11:39] *** patrickb joined
[11:41] *** patrickb left
[11:41] *** patrickb joined
[11:43] *** patrickb left
[11:43] *** patrickb joined
[11:45] *** patrickb left
[11:45] *** patrickb joined
[11:49] *** patrickb left
[11:49] *** patrickb joined
[11:51] *** patrickb left
[11:52] *** patrickb joined
[11:53] *** patrickb left
[11:54] *** patrickb joined
[11:55] *** patrickb left
[11:56] *** patrickb joined
[11:57] *** patrickb left
[11:58] *** patrickb joined
[11:58] *** patrickb left
[12:02] *** reportable6 left
[12:39] *** Altai-man left
[12:39] *** Altai-man joined
[12:47] *** linkable6 joined
[12:57] *** perryprog left
[12:58] *** avuserow left
[12:58] *** perryprog joined
[13:15] *** leedo_ joined
[13:18] *** m_athias joined
[13:18] *** discord-raku-bot left
[13:18] *** leedo left
[13:18] *** m_athias1 left
[13:18] *** synthmeat left
[13:18] *** Maylay left
[13:19] *** Maylay joined
[13:20] *** synthmeat joined
[13:25] *** avuserow joined
[13:41] *** Eddward__ joined
[14:05] *** Doc_Holliwood left
[14:25] *** Doc_Holliwood joined
[14:39] *** Sgeo joined
[14:48] *** frost left
[15:15] *** MoC joined
[15:40] *** melezhik joined
[15:41] <melezhik> if someone needs an html to pdf converter, I have it on Raku - https://sparrowhub.io/plugin/weasyprint/0.000001

[15:42] <melezhik> a full example form markdown to pdf would be  - https://github.com/melezhik/cv/blob/master/.tom/markdown-to-pdf.pl6

[16:20] <melezhik> weekly: https://www.reddit.com/r/rakulang/comments/oph7r2/sparrow_plugin_to_convert_markdown_to_pdf/

[16:20] <notable6> melezhik, Noted! (weekly)

[16:23] *** melezhik left
[16:25] <mykhal> m: say (1/2, "1/2", ½, "½")>>.&{ try $_.Rat }

[16:25] <camelia> rakudo-moar b4d33982a: OUTPUT: «(0.5 0.5 0.5 Nil)␤»

[16:36] *** justsomeguy joined
[16:39] <mykhal> I think "½".Rat should work as well, can't se related open issue, but often miss something

[16:41] *** justsomeguy left
[16:45] *** ufobat_ left
[17:22] *** sono joined
[17:29] <Altreus> I concur fwiw

[17:29] <Altreus> It seems more astonishing that it doesn't

[17:38] <mykhal> so I've made new https://github.com/rakudo/rakudo/issues/4475 : Unicode fraction strings .Rat, like "½".Rat, fail

[17:41] <mykhal> (sorry for just complaining, not sufficient Perl/Raku/nqp hacker to fix it)

[17:41] <Geth> ¦ doc: mustafaaydn++ created pull request #3921: using chaining operators in comparison

[17:41] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3921

[17:43] <Geth> ¦ doc: 1cc78fdbb0 | (Mustafa Aydın)++ (committed by Juan Julián Merelo Guervós) | doc/Language/functions.pod6

[17:43] <Geth> ¦ doc: using chaining operators in comparison

[17:43] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/1cc78fdbb0

[17:43] <linkable6> Link: https://docs.raku.org/language/functions

[17:43] <tbrowder> howdy, i need help with a sorting sub for Raku's sort routine. i need to sort a list of id strings which look like decimal numbers but don't sort like them. for example, in desired sorted order <1 1.1 1.10  2 2.1 2.3 2.30>

[17:44] <tbrowder> i have tried defining a sub that compares the pieces before and after the decimal point, if any, but how do i return the correct pair as a seq?

[17:46] <tbrowder> just list the two values as a list in the correct order? or ?

[17:49] <Altreus> m: sort(~*, <1 1.1 1.10  2 2.1 2.3 2.30>)

[17:49] <camelia> rakudo-moar b4d33982a: ( no output )

[17:49] <Altreus> oh duh

[17:49] <Altreus> m: <1 1.1 1.10  2 2.1 2.3 2.30>.sort(~*)

[17:49] <camelia> rakudo-moar b4d33982a: ( no output )

[17:49] <Altreus> oh it's not sort-by is it

[17:50] <Altreus> m: <1 1.1 1.10  2 2.1 2.3 2.30>.sort({ $^a cmp $^b })

[17:50] <camelia> rakudo-moar b4d33982a: ( no output )

[17:50] <Altreus> m: say <1 1.1 1.10  2 2.1 2.3 2.30>.sort({ $^a cmp $^b })

[17:50] <camelia> rakudo-moar b4d33982a: OUTPUT: «(1 1.1 1.10 2 2.1 2.3 2.30)␤»

[17:50] <Altreus> ok thanks brain

[17:50] <Altreus> tbrowder: I got there in the end but that appears to be just string sort

[17:52] <tbrowder> duh, i didn't try cmp!! thnx

[17:53] <Altreus> :) fresh eyes

[17:59] <tbrowder> nope, i didn't give a good example (unless my eyes are bad)

[18:00] <tbrowder> m: say <1.10 1.1>.sort({$^a cmp ^$b}))

[18:00] <camelia> rakudo-moar b4d33982a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$b' is not declared␤at <tmp>:1␤------> 3say <1.10 1.1>.sort({$^a cmp ^7⏏5$b}))␤»

[18:01] <tbrowder> m: say <1.10 1.1>.sort({$^a cmp $^b})

[18:01] <camelia> rakudo-moar b4d33982a: OUTPUT: «(1.1 1.10)␤»

[18:02] <tbrowder> hm?

[18:03] <tbrowder> ok, once more...

[18:04] *** reportable6 joined
[18:04] <tbrowder> m: say <4.3 4.10>.sort({$^a cmp $^b})

[18:04] <camelia> rakudo-moar b4d33982a: OUTPUT: «(4.10 4.3)␤»

[18:05] <tbrowder> i want 4.3, 4.10 as the order

[18:05] <Altreus> ah, because 3 < 10

[18:06] <tbrowder> yes, so i need a sort sub to first compare the integer, then the decimal, if any

[18:06] <tbrowder> so how should i arrange the result to return after the parts are considered?

[18:07] <Altreus> say <4.3 4.10>.sort({$^a.Int <=> $^b.Int || ($^a - $^a.Int) <=> ($^b - $^b.Int) })

[18:07] <evalable6> Altreus, rakudo-moar b4d33982a: OUTPUT: «(4.10 4.3)␤»

[18:07] <Altreus> er

[18:07] <Altreus> I fully expected that to work

[18:07] <tbrowder> i think yr close

[18:08] <Altreus> m: say { $^a - $^a.Int }(4.3)

[18:08] <camelia> rakudo-moar b4d33982a: OUTPUT: «0.3␤»

[18:08] <Altreus> m: say { ($^a - $^a.Int) <=> ($^b - $^b.Int) }(4.10, 4.3)

[18:08] <camelia> rakudo-moar b4d33982a: OUTPUT: «Less␤»

[18:08] <Altreus> oh

[18:08] <Altreus> it's not -1, 0, 1

[18:08] <Altreus> m say so 4 <=> 4

[18:08] <Altreus> m: say so 4 <=> 4

[18:08] <camelia> rakudo-moar b4d33982a: OUTPUT: «False␤»

[18:09] <Altreus> m: say so 4 <=> 5

[18:09] <camelia> rakudo-moar b4d33982a: OUTPUT: «True␤»

[18:09] <Altreus> m: say so 4 <=> 3

[18:09] <camelia> rakudo-moar b4d33982a: OUTPUT: «True␤»

[18:09] <tbrowder> use cmp?

[18:09] <tbrowder> on the pieces

[18:09] <Altreus> say <4.3 4.10>.sort({ ($^a.Int <=> $^b.Int) || ($^a - $^a.Int) <=> ($^b - $^b.Int) })

[18:09] <evalable6> Altreus, rakudo-moar b4d33982a: OUTPUT: «(4.10 4.3)␤»

[18:09] <Altreus> hein, it should be equivalent at this point

[18:09] <Altreus> m: say { ($^a.Int <=> $^b.Int) || ($^a - $^a.Int) <=> ($^b - $^b.Int) }(4.3, 4.10)

[18:09] <camelia> rakudo-moar b4d33982a: OUTPUT: «More␤»

[18:10] <Altreus> that's correct :/

[18:10] <Altreus> 4.10 is more

[18:10] <Altreus> m: say { ($^a.Int <=> $^b.Int) || ($^a - $^a.Int) <=> ($^b - $^b.Int) }(<4.3 4.10>)

[18:10] <camelia> rakudo-moar b4d33982a: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»

[18:10] <Altreus> heh

[18:10] <tbrowder> use ternary operator?

[18:10] <Altreus> m: say { ($^a.Int <=> $^b.Int) || ($^a - $^a.Int) <=> ($^b - $^b.Int) }(|<4.3 4.10>)

[18:10] <camelia> rakudo-moar b4d33982a: OUTPUT: «More␤»

[18:11] <Altreus> but the sub is correct :\

[18:11] <Altreus> that's the right answer!

[18:11] <Altreus> but sort is doing it backwards

[18:11] <Altreus> m: say { ($^a.Int <=> $^b.Int) || ($^a - $^a.Int) <=> ($^b - $^b.Int) }(|<4.10 4.3>)

[18:11] <camelia> rakudo-moar b4d33982a: OUTPUT: «Less␤»

[18:11] <MasterDuke> just stick a .reverse on the end

[18:12] <MasterDuke> or put the $^b first

[18:12] <Altreus> but the sub is correct

[18:12] <Altreus> Why is sort reversing it in the first place?

[18:13] <Altreus> m: sub weirdsort {  ($^a.Int <=> $^b.Int) || ($^a - $^a.Int) <=> ($^b - $^b.Int) }; say <1 1.10 1.1 1.2 1.3 1.30>.sort(&weirdsort)

[18:13] <camelia> rakudo-moar b4d33982a: OUTPUT: «(1 1.10 1.1 1.2 1.3 1.30)␤»

[18:14] <Altreus> m: sub weirdsort {  $^a.Int == $^b.Int ?? ($^a - $^a.Int) <=> ($^b - $^b.Int) !! $^a.Int <=> $^b.Int }; say <1 1.10 1.1 1.2 1.3 1.30>.sort(&weirdsort)

[18:14] <camelia> rakudo-moar b4d33982a: OUTPUT: «(1 1.10 1.1 1.2 1.3 1.30)␤»

[18:14] <Altreus> ok I'm hooked, time to debug offline

[18:15] <Altreus> ohhh

[18:15] <Altreus> idiot

[18:15] <Altreus> $^a - $^a.Int is not remotely useful :D

[18:15] <tbrowder> ;-D that's why i need a complex example in the docs!

[18:16] <tbrowder> util helped, but still not complex enough

[18:16] <Altreus> m: sub weirdsort {  ($^a.Int <=> $^b.Int) || (S/ .+ '.' // given $^a) <=> (S/ .+ '.' // given $^b) }; say <1 1.10 1.1 1.2 1.3 1.30>.sort(&weirdsort)

[18:16] <camelia> rakudo-moar b4d33982a: OUTPUT: «(1 1.1 1.2 1.3 1.10 1.30)␤»

[18:16] <Altreus> I was still comparing 0.3 and 0.10

[18:17] <Altreus> instead of 3 and 10

[18:17] <Altreus> so yeah you do have to cut it up cos there's no sensible mathematical thing that means "turn the part after the radix point into an integer of arbitrary magnitude" :D

[18:19] <tbrowder> ok, so if i do that in my own simple way, how do i, in the sub, delare that one of the two is greater than the other for the return value?

[18:19] <tbrowder> *declare

[18:20] <Altreus> I suppose you just do return More; return Less; return Same;

[18:20] <Altreus> m: say 4 <=> 4

[18:20] <camelia> rakudo-moar b4d33982a: OUTPUT: «Same␤»

[18:20] <Altreus> Referring to $^b

[18:21] <Altreus> so you'd say More if $^b is bigger

[18:21] <tbrowder> i'll try that, thnx!

[18:22] <tbrowder> this is all bringing back old c++ memory, i should have looked more closely at the cmp operator in docs

[18:23] <tbrowder> (or perl memory)

[18:32] <Altreus> yeah mostly perl tricks here

[18:32] <Altreus> the || trick in a sort is very useful

[18:32] <Altreus> to stack up sub-groups

[18:48] <mykhal> tbrowder , Altreus : weird, but looks like version numbers

[18:48] <mykhal> m: say <1 1.10 1.1 1.2 1.3 1.30>>>.Version.sort

[18:48] <camelia> rakudo-moar b4d33982a: OUTPUT: «(v1 v1.1 v1.2 v1.3 v1.10 v1.30)␤»

[18:49] <tbrowder> mykhal: thnx

[18:50] <MasterDuke> m: say <1 1.10 1.1 1.2 1.3 1.30>.sort(*.Version)

[18:50] <camelia> rakudo-moar b4d33982a: OUTPUT: «(1 1.1 1.2 1.3 1.10 1.30)␤»

[18:55] <mykhal> nice. btw, also GNU sort can do this, with -V

[19:04] *** linkable6 left
[19:04] *** evalable6 left
[19:04] *** evalable6 joined
[19:07] *** linkable6 joined
[19:20] *** MoC left
[20:10] *** RandalSchwartz joined
[20:11] *** RandalSchwartz left
[20:13] *** RandalSchwartz joined
[20:15] *** thundergnat joined
[20:16] <thundergnat> m: use lib ‘data/all-modules/github/thundergnat/Sort-Naturally’; use Sort::Naturally; say <1 1.1 1.10 2 2.1 2.3 2.30 4.3 4.10>.sort(&naturally);

[20:16] <camelia> rakudo-moar b4d33982a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not find Sort::Naturally in:␤    file#/home/camelia/data/all-modules/github/thundergnat/Sort-Naturally␤    inst#/home/camelia/.raku␤    inst#/home/camelia/rakudo-m-inst-2/share/perl6/site␤…»

[20:16] <thundergnat> bummer

[20:17] <thundergnat> locally: (1 1.1 1.10 2 2.1 2.3 2.30 4.3 4.10)

[20:18] <Geth> ¦ doc: 0429a0b0fe | Coke++ | xt/pws/code.pws

[20:18] <Geth> ¦ doc: new word

[20:18] <Geth> ¦ doc: 

[20:18] <Geth> ¦ doc: from unicode char name

[20:18] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/0429a0b0fe

[20:26] *** Manifest0 joined
[20:41] <tbrowder> mykhal: excellent observation!

[20:41] <tbrowder> enabling MasterDuke to win the golfing prize me thinks

[20:48] <tbrowder> i did manage to get a fairly small sub using split, defined, <=>, and the ternary operator, but you folks (esp. mykhal and MasterDuke) really know Raku. THANKS

[20:57] *** Kaiepi left
[20:59] *** melezhik joined
[21:00] *** Kaiepi joined
[21:00] <melezhik> how can I create a class with a following constructor: `my $a = Foo.new(1)` ?

[21:01] <melezhik> m: class Node {  submethod BUILD (Int $data) }; Node.new(1)

[21:01] <camelia> rakudo-moar b4d33982a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3ass Node {  submethod BUILD (Int $data) 7⏏5}; Node.new(1)␤»

[21:01] <moon-child> that's an unfortunate truncation

[21:01] <melezhik> m: class Node {  submethod BUILD (Int $data) { ... } }; Node.new(1)

[21:01] <camelia> rakudo-moar b4d33982a: OUTPUT: «Default constructor for 'Node' only takes named arguments␤  in block <unit> at <tmp> line 1␤␤»

[21:02] <melezhik> `«Default constructor for 'Node' only takes named arguments` basically I need to change this ...

[21:02] <MasterDuke> create your own new?

[21:03] <melezhik> m: class Node {  submethod new (Int $data) { ... } }; Node.new(1)

[21:03] <camelia> rakudo-moar b4d33982a: OUTPUT: «Stub code executed␤  in submethod new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:03] <melezhik> m: class Node { has $.data;  submethod new (Int $data) { $!.data = data } }; Node.new(1)

[21:03] <camelia> rakudo-moar b4d33982a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    data used at line 1␤␤»

[21:04] <melezhik> m: class Node { has $.data;  submethod new (Int $data) { $!.data = $data } }; Node.new(1)

[21:04] <camelia> rakudo-moar b4d33982a: OUTPUT: «Cannot modify an immutable Str (Nil)␤  in submethod new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:04] <melezhik> m: class Node { has Int $.data;  submethod new (Int $data) { $!.data = $data } }; Node.new(1)

[21:04] <camelia> rakudo-moar b4d33982a: OUTPUT: «Cannot modify an immutable Str (Nil)␤  in submethod new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:05] <melezhik> now I stuck with that ...

[21:05] <moon-child> m: class Node { has Int $.data;  submethod new (Int $data) { self.bless(:$data) } }; say Node.new(1)

[21:05] <camelia> rakudo-moar b4d33982a: OUTPUT: «Node.new(data => 1)␤»

[21:07] <melezhik> m: class Node { has Int $.data;  submethod new (Int $d) { $!.data = $d } }; Node.new(1)

[21:07] <camelia> rakudo-moar b4d33982a: OUTPUT: «Cannot modify an immutable Str (Nil)␤  in submethod new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:07] <melezhik> why can't I change $.data?

[21:10] <moon-child> I guess you need to make both your own new and BLESS

[21:10] <moon-child> m: class Node { has Int $.data;  submethod new (Int $data) { self.bless(:$data) }; submethod BUILD(Int :$data) { $!data = $data } }; say Node.new(1)

[21:10] <camelia> rakudo-moar b4d33982a: OUTPUT: «Node.new(data => 1)␤»

[21:11] <melezhik> sigh ... seems not intuitive to me ... what the difference between redefining new and BUILD and why should redefine both?

[21:12] <melezhik> brb

[21:12] <moon-child> my understanding is, new is called with a type object self, BUILD is called with an actual newly instantiated object

[21:12] *** Kaiepi left
[21:13] <moon-child> and bless is what creates the new object and then calls BUILD

[21:20] *** thundergnat left
[21:24] <melezhik> moon-child thanks for clarification 

[21:25] * mykhal is somewhat shy to accept some tbrowder's compliments.. what looks like really knowing Raku might just be recently read certain doc chapters

[21:27] <melezhik> m: class Node { has Int $.data; has Str $.foo;  submethod new (Int $data) { self.bless(:$data) } }; Node.new(1)

[21:27] <camelia> rakudo-moar b4d33982a: ( no output )

[21:27] <melezhik> m: class Node { has Int $.data; has Str $.foo;  submethod new (Int $data) { self.bless(:$data) } };  say Node.new(1)

[21:27] <camelia> rakudo-moar b4d33982a: OUTPUT: «Node.new(data => 1, foo => Str)␤»

[21:28] <melezhik> moon-child looks like we don't even need to redefine BUILD. the only magic is that new's parameter should be named after class data

[21:29] <melezhik> so it should be `submethod new (Int $data) { self.bless(:$data) } `

[21:29] <melezhik> not something `submethod new (Int $d) { self.bless(:$d) }`

[21:31] <melezhik> m: class Node { has Int $.data; has Str $.foo;  submethod new (Int $data) { self.bless(:$data) } };  Node.new(1).foo = "OK"

[21:31] <camelia> rakudo-moar b4d33982a: OUTPUT: «Cannot modify an immutable 'Str' type object␤  in block <unit> at <tmp> line 1␤␤»

[21:31] <melezhik> I also stuck here

[21:31] <melezhik> why can't I modify foo?

[21:33] <raydiak> attributes default to read-only. you need 'is rw' after 'has Str $.foo'

[21:33] <melezhik> oh, thanks

[21:33] <raydiak> yw

[21:33] <melezhik> I even at some point remember that )))

[21:34] <melezhik> have not touched Raku classed in awhile ...

[21:34] <melezhik> classes

[21:35] <raydiak> it's a very broad language, there's a lot to remember/forget :)

[21:40] <melezhik> raydiak absolutely, I always feel like that!  

[21:41] *** Kaiepi joined
[21:43] <raydiak> it's not entirely unintentional. aspects of the design were modeled after natural human languages, including the idea that there is a lot of vocabulary and most people don't know and retain all of it, just the parts they frequently read/write/hear/say. one of the reasons we have several ways of doing most things

[21:45] <raydiak> I can't even remember all of just the operators and I started with raku in 2013 :D

[21:46] <melezhik> yeah, makes a sense 

[22:13] <mykhal> m: say <a b>.map(* => *.succ)  # wanted (a => b, b => c), if can be done better way, still wanna know if currying asterisk can be reused

[22:13] <camelia> rakudo-moar b4d33982a: OUTPUT: «(a => c)␤»

[22:15] <japhb> mykhal: Two asterisks are going to make map pull two args per iteration.  In this case, it's equal length to use $_:

[22:15] <japhb> m: say <a b>.map($_ => .succ)

[22:15] <camelia> rakudo-moar b4d33982a: OUTPUT: «No such method 'succ' for invocant of type 'Any'.  Did you mean 'sum'?␤  in block <unit> at <tmp> line 1␤␤»

[22:15] <japhb> m: say <a b>.map({$_ => .succ})

[22:15] <camelia> rakudo-moar b4d33982a: OUTPUT: «(a => b b => c)␤»

[22:15] <japhb> Sorry, forgot that I'd have to add {}

[22:18] <mykhal> yeah, i hoped for block-less. and, have to do additional .Hash to get {a => b, b => c}, which I in fact wanted rather :)

[22:21] <moon-child> my @x = <a b>; my %x; %x{@x} = @x».succ; say %x

[22:21] <evalable6> moon-child, rakudo-moar b4d33982a: OUTPUT: «{a => b, b => c}␤»

[22:22] <japhb> Do we have any other tree structure serialization format codecs in the ecosystem other than JSON, BSON, CBOR, YAML, and .raku?  I'm not including CSV because it's for tabular instead of tree-structured data, and I didn't see any XML libraries that looked like they could take an arbitrary tree of Raku data and encode into XML with a single call.

[22:22] <japhb> (Though of course I could have missed one.)

[22:22] <moon-child> toml?

[22:22] <moon-child> (though I would not use toml for nested data)

[22:24] <japhb> moon-child: Hmmm, I've never used toml.  Why do you say it would *work* for nested data but you wouldn't use it for that?

[22:25] <moon-child> just, the format is not really suited to that

[22:25] <moon-child> toml is essentially a formalization of ini; it's intended for simple config files

[22:41] <japhb> Ah, gotcha

[22:41] *** evalable6 left
[22:41] *** linkable6 left
[22:43] <japhb> I'm discovering that our various serialization modules have *wildly* different performance profiles.  To a frustrating degree when doing performance tests, actually, because I can't reasonably use the same test data for some of them, let alone the same iteration count.

[22:47] <japhb> Also it seems to be too easy to make grammars with really poor performance behavior, likely quadratic or worse.

[22:50] *** Doc_Holliwood left
[23:10] <mykhal> m: say (<a b>.map({:$_}), <a b>.map({:$^a}))  # :-o

[23:10] <camelia> rakudo-moar b4d33982a: OUTPUT: «((_ => a _ => b) (a => a a => b))␤»

[23:13] <moon-child> yeah, :$x  means  x => $x

[23:13] <mykhal> m: say (<a b>.map({:$^xxx})

[23:13] <camelia> rakudo-moar b4d33982a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in parenthesized expression; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 3say (<a b>.map({:$^xxx})7⏏5<EOL>␤    expecting any o…»

[23:13] <moon-child> where the lhs of the => ignores any symbols and twigils

[23:14] <mykhal> interesting

[23:14] <moon-child> err, sigils and twigils

[23:19] <mykhal> well, still might not get it, is it related to e.g. ... ?

[23:19] <mykhal> m: say :3days

[23:19] <camelia> rakudo-moar b4d33982a: OUTPUT: «Unexpected named argument 'days' passed␤  in block <unit> at <tmp> line 1␤␤»

[23:19] <mykhal> m: say ( :3days )

[23:19] <camelia> rakudo-moar b4d33982a: OUTPUT: «days => 3␤»

[23:19] <mykhal> or is it mentioned in https://docs.raku.org/type/Pair ?

[23:20] <mykhal> maybe sleep and morning helps

[23:21] <mykhal> seems related but

[23:22] <mykhal> oooh. ok. night

[23:23] <mykhal> btw, it does not feel right, if _ in $_ is supposed to mean nothing

[23:26] *** Doc_Holliwood joined
[23:30] *** squashable6 left
[23:31] *** squashable6 joined
