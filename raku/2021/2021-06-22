[00:00] <codesections> https://github.com/rakudo/rakudo/issues/4423

[00:00] <codesections> (I already mentioned your other find in the Grammar)

[00:00] <codesections> thanks for all your help, btw

[00:01] <raydiak> from that line, it looks intentional. the fact that it's being called from a rule called "variable" kinda suggests otherwise, though. *shrug* it'll be interesting to see what the experts say. codesections++ good find either way

[00:02] <raydiak> of course, always glad to share what I know. thanks for taking me on a little adventure :D

[00:02] *** reportable6 left
[00:03] *** reportable6 joined
[00:05] <raydiak> I can't very easily trace it down just from reading the source either. too many dynamic vars and code mixed into the pattern matching for me to keep track of. I do some cheating with --target=parse

[00:30] *** bd3i joined
[00:35] *** dpk left
[00:35] *** dpk joined
[00:37] *** nine left
[00:37] *** nine joined
[01:37] *** quotable6 left
[01:37] *** benchable6 left
[01:37] *** linkable6 left
[01:37] *** committable6 left
[01:37] *** notable6 left
[01:37] *** squashable6 left
[01:37] *** nativecallable6 left
[01:37] *** unicodable6 left
[01:37] *** reportable6 left
[01:37] *** coverable6 left
[01:37] *** bloatable6 left
[01:37] *** shareable6 left
[01:37] *** releasable6 left
[01:37] *** tellable6 left
[01:37] *** sourceable6 left
[01:37] *** greppable6 left
[01:37] *** statisfiable6 left
[01:37] *** bisectable6 left
[01:37] *** evalable6 left
[01:38] *** sourceable6 joined
[01:38] *** committable6 joined
[01:38] *** unicodable6 joined
[01:38] *** evalable6 joined
[01:38] *** notable6 joined
[01:39] *** quotable6 joined
[01:39] *** reportable6 joined
[01:39] *** tellable6 joined
[01:39] *** nativecallable6 joined
[01:39] *** benchable6 joined
[01:40] *** bisectable6 joined
[01:40] *** statisfiable6 joined
[01:40] *** linkable6 joined
[01:40] *** shareable6 joined
[01:40] *** bloatable6 joined
[01:40] *** squashable6 joined
[01:41] *** releasable6 joined
[01:41] *** coverable6 joined
[01:41] *** greppable6 joined
[01:48] <lucs> Any special reason why the bots keep getting reset?

[02:11] *** nine left
[02:11] *** camelia left
[02:12] *** camelia joined
[02:12] *** nine joined
[02:15] *** Doc_Holliwood left
[02:23] *** _ed joined
[02:24] <_ed> is this an OK place for Raku beginners to ask questions?

[02:24] <lucs> Yes

[02:24] <lucs> And welcome :)

[02:25] <_ed> thank you!

[02:26] <_ed> playing around with some Raku examples

[02:26] <_ed> why does this work:

[02:26] <_ed> my @x = '.'.IO

[02:26] <_ed> @x.pop.dir.WHAT

[02:26] <_ed> but not

[02:26] <_ed> '.'.IO.pop.dir.WHAT

[02:27] <_ed> (tested those in my repl)

[02:28] <lucs> (on the phone, back in a few minutes, if no one else answers)

[02:29] <codesections> m: say '.'.IO.WHAT; my @a = '.'.IO; say @a.WHAT

[02:29] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(Path)␤(Array)␤»

[02:30] <codesections> _ed: the @ sigil indicates that you want to store a Positional thing, so it coerces the Path to an Array.  Arrays have a .pop method, but Paths don't

[02:33] *** _ed left
[02:33] <lucs> Hmm... My understanding is different: The assignment to @a places the Path instance as the first array element.

[02:34] <codesections> (also, this is the right place for questions, but it's not the perfect time - many of the channel regulars are in Europe, where its ~4:30am.  That's not (at all!) to discourage questions, but just to say that you might not get as many responses as at a different time)

[02:35] <lucs> Uh, _ed left, just saying :/

[02:35] <codesections> lucs: yeah, that's a better way of putting it

[02:35] <codesections> Oh, thanks -- I have join/part notifications turned off

[02:36] *** _ed joined
[02:36] <lucs> _ed is back!

[02:36] <_ed> sorry, my internet's been kinda flaky today

[02:36] <lucs> codesections: Please repeat your comment?

[02:37] <_ed> interesting. --didn't realize `@a = something` wraps somethings in an array.

[02:37] <codesections> _ed: the @ sigil indicates that you want to store a Positional thing, so it stores the Path in an Array.  Arrays have a .pop method, but Paths don't

[02:37] <lucs> Not that one, the other one :)

[02:37] <codesections> Oh, this?  (also, this is the right place for questions, but it's not the perfect time - many of the channel regulars are in Europe, where its ~4:30am.  That's not (at all!) to discourage questions, but just to say that you might not get as many responses as at a different time)

[02:38] <lucs> I guess both are OK :)

[02:38] <lucs> _ed: That was for you.

[02:38] <_ed> oh dang. wake 'em up. this is important. lol

[02:39] <codesections> But as lucs pointed out, I shouldn't have said that @ 'coerces' the Path -- it stores it in an Array

[02:39] <_ed> ah. i see

[02:40] <_ed> I can't tell for certain from the topic -- this channel is logged, but those logs aren't publicly available?

[02:40] <codesections> no, they are: https://colabti.org/irclogger/irclogger_log/raku?date=2021-06-22

[02:40] <moon-child> logs should be publicly available

[02:41] <lucs> They are, the link used to be in the topic (I think).

[02:41] <codesections> (We might be moving where we keep them soon, but they'll still be public)

[02:41] <moon-child> most channels are at least privately logged.  Many people keep logs

[02:41] <lucs> codesections: Is that right? Why the move?

[02:43] <lucs> I'm asking because another channel here (#marpa) uses the same logger, wondering if we should worry.

[02:43] <_ed> thanks all! my raku playtime is over for this evening. l8r

[02:43] *** _ed left
[02:43] <codesections> I haven't followed it all that closely.  I know Liz is working on a new log site, and but I don't recall exactly why

[02:44] <moon-child> used to be logs.liz.nl, seems to be down right now?

[02:44] <lucs> codesections: Okay, thanks.

[02:44] <moon-child> codesections: could just be generally wanting to have control over the logging.  I think that's reasonable (though not reason to be concerned about the existing logger)

[02:45] <lucs> Fair enough.

[02:45] <codesections> oh, there was this r/rakulang post: https://www.reddit.com/r/rakulang/comments/msyxn5/raku_development_process_irc_logging_where_how/

[02:46] <codesections> and here's the problem-solving issue: https://github.com/Raku/problem-solving/issues/280

[02:46] <lucs> Nice

[02:48] <moon-child> (aside: marpa looks very interesting)

[02:49] <lucs> Yep, certainly worth a look.

[03:43] *** linkable6 left
[03:43] *** evalable6 left
[03:44] *** evalable6 joined
[03:45] *** linkable6 joined
[03:48] *** Sisyphus joined
[04:00] *** frost joined
[04:06] *** lucerne joined
[04:26] <Sisyphus> Hi there, I'm trying to understand why '.say'...:EVAL prints "(LoweredAwayLexical)". I'd expect it to either print ".say" or "(Any)"

[04:28] *** jmcgnh left
[04:30] *** jmcgnh joined
[04:32] *** jmcgnh left
[04:33] *** jmcgnh joined
[04:42] *** jmcgnh left
[04:45] *** bd3i left
[04:45] *** jmcgnh joined
[04:50] *** Doc_Holliwood joined
[04:54] *** jmcgnh left
[05:00] *** jmcgnh joined
[05:00] *** jmcgnh left
[05:03] *** jmcgnh joined
[05:07] *** jmcgnh left
[05:10] *** jmcgnh joined
[05:10] <moritz> m: $_ = 42; EVAL '.say'

[05:10] <camelia> rakudo-moar 37dd25f68: OUTPUT: «42␤»

[05:12] *** lucerne left
[05:13] *** lucerne joined
[05:17] <moon-child> m: say infix:<...>('.say', :EVAL)

[05:17] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(.say)␤»

[05:17] <moon-child> m: say infix:<...>('.say')

[05:17] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(.say)␤»

[05:18] <moon-child> Sisyphus: ^^^

[05:18] <moon-child> it just ignores the :EVAL

[05:20] <moon-child> loweredawaylexical I think is an optimizer artefact?  Not sure

[05:24] <moon-child> m: my $x = ('.say' ... :EVAL)

[05:24] <camelia> rakudo-moar 37dd25f68: ( no output )

[05:25] <Sisyphus> I see. tricky

[05:26] <moon-child> m: my $x = ('.say' ^... :EVAL)

[05:26] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(LoweredAwayLexical)␤»

[06:03] *** reportable6 left
[06:04] *** reportable6 joined
[06:23] *** ufobat_ joined
[06:24] *** holyghost joined
[06:32] *** abraxxa joined
[06:36] *** abraxxa left
[06:37] *** abraxxa joined
[06:42] *** lucerne left
[07:05] *** Sgeo left
[07:29] *** xinming_ joined
[07:32] *** xinming left
[07:37] *** lucerne joined
[07:45] *** lucerne left
[07:45] *** lucerne joined
[08:03] *** lucerne left
[08:05] *** dakkar joined
[08:13] *** Sisyphus left
[08:23] <demostanis[m]> Is there an easy way of doing `(1, 2) magic (2, 3) => (3, 5)`?

[08:25] <moritz> m: say (1, 2) Z+ (2, 3)

[08:25] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(3 5)␤»

[08:25] <moritz> m: say (1, 2) X+ (2, 3)

[08:25] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(3 4 4 5)␤»

[08:25] <demostanis[m]> I almost found myself, thanks

[08:26] <moon-child> m: say (1,2) »+« (2,3)

[08:26] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(3 5)␤»

[08:26] <moon-child> hyperoperators for the win!

[08:26] <demostanis[m]> How does it work?

[08:27] <moon-child> m: say (1,2) >>+>> 2 #texas variants; also more flexible

[08:27] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(3 4)␤»

[08:27] <moon-child> demostanis[m]: docs https://docs.raku.org/language/operators#index-entry-hyper_%3C%3C-hyper_%3E%3E-hyper_%C2%AB-hyper_%C2%BB-Hyper_operators

[08:37] <demostanis[m]> $c = (2,3)

[08:37] <demostanis[m]> (2 3)

[08:37] <demostanis[m]> > $c Z+ (1,3)

[08:37] <demostanis[m]> What does that mean?

[08:38] * demostanis[m]  < https://libera.ems.host/_matrix/media/r0/download/libera.chat/d8867bf1feb6e781834d0bed5ba858a339d462e6/message.txt >

[08:38] <holyghost> m: (2,3) Z+ (1,3)

[08:38] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Potential difficulties:␤    Useless use of Z+ in sink context␤    at <tmp>:1␤    ------> 3(2,3) 7⏏5Z+ (1,3)␤»

[08:38] <demostanis[m]> I get that same result, but not when I use a variable

[08:38] <demostanis[m]> m: my $c = (2,3); $c Z+ (1,3)

[08:38] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Potential difficulties:␤    Useless use of Z+ in sink context␤    at <tmp>:1␤    ------> 3my $c = (2,3); $c 7⏏5Z+ (1,3)␤»

[08:39] <moon-child> https://docs.raku.org/language/operators#Zip_metaoperator

[08:39] <demostanis[m]> m: my $c = (2,3); say $c Z+ (1,3)

[08:39] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(3)␤»

[08:39] <holyghost> Z links 2 lists

[08:39] <moon-child> demostanis[m]: you want to use @ for arrays

[08:39] <moon-child> m: my @c = (2,3); say @c Z+ (1,3)

[08:39] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(3 6)␤»

[08:39] <holyghost> and + is the operator

[08:40] <demostanis[m]> I really suck in Raku lol

[08:40] <moon-child> you don't suck, you're learning

[08:40] <dakkar> m: my $c = (2,3); say @$c Z+ (1,3)

[08:40] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(3 6)␤»

[08:40] <dakkar> demostanis[m]: also that

[08:40] <demostanis[m]> What does @$ mean?

[08:40] <dakkar> short version: a `$` variable is "a single thing"

[08:41] <holyghost> $c in list context

[08:41] <moon-child> @$x means 'use the variable named $x, but pretend it was declared as @x'

[08:41] <dakkar> m: my $c = (2,3); say $c.raku; say (@$c).raku

[08:41] <camelia> rakudo-moar 37dd25f68: OUTPUT: «$(2, 3)␤(2, 3)␤»

[08:41] <dakkar> notice that `$` in front of the first line of output, which means "consider the following to be a single thing"

[08:42] <dakkar> (I'm not good at explaining this…)

[08:42] <demostanis[m]> Don't worry I understoood

[08:42] <moon-child> demostanis[m]: more on sigils here  https://docs.raku.org/language/variables#Sigils

[08:43] <moon-child> ($ and @ are sigils)

[09:13] *** evalable6 left
[09:13] *** linkable6 left
[09:13] *** holyghost left
[09:14] *** lucerne joined
[09:14] *** evalable6 joined
[09:14] *** linkable6 joined
[09:36] *** lucerne left
[10:36] *** evalable6 left
[10:36] *** linkable6 left
[10:38] *** linkable6 joined
[10:39] *** evalable6 joined
[11:32] *** sono left
[11:56] <demostanis[m]> https://pastebin.com/raw/PzuDf1wy I don't understand why my code doesn't work. It looks like it's not seeing that 'cid' is in the gathered list.

[11:57] <lizmat> and yet another Rakudo Weekly News hits the Net: https://rakudoweekly.blog/2021/06/22/2021-25-small-steps/

[11:58] <lizmat> with apologies for being 1 day late

[12:02] *** reportable6 left
[12:04] *** RandalSchwartz left
[12:04] <moritz> lizmat++

[12:05] *** reportable6 joined
[12:07] *** holyghost joined
[12:10] *** frost left
[12:41] *** holyghost left
[13:16] <dakkar> demostanis[m]: those `.say` are confusinc your code, sorry

[13:16] <dakkar> m: 1 ∈ gather { take 1; take 2 }

[13:16] <camelia> rakudo-moar 37dd25f68: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "∈" in expression "1 ∈ gather { take 1; take 2 }" in sink context (line 1)␤»

[13:16] <dakkar> m: say 1 ∈ gather { take 1; take 2 }

[13:16] <camelia> rakudo-moar 37dd25f68: OUTPUT: «True␤»

[13:16] <dakkar> m: say 1 ∈ gather { take 1; take 2 }.say

[13:16] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(1 2)␤False␤»

[13:17] <dakkar> demostanis[m]: that's because you're checking if 'cid' is in *the return value of `say`*

[13:17] <dakkar> and that's not what you mean

[13:17] <dakkar> remove the inner `.say`, and it should work

[13:28] *** holyghost joined
[13:29] <holyghost> I'm a bit more afk the following approx. 2 weeks as of RL etc. There's Game::Decision which now has 3-4 API methods and AI::NLP will be on hold now. HAND.

[13:29] *** holyghost left
[13:41] <demostanis[m]> <dakkar "demostanis: that's because you'r"> I already tried, it does the same

[13:43] <dakkar> demostanis[m]: ok, you *also* miss a loop

[13:44] <demostanis[m]> Where?

[13:45] <dakkar> inside the inner gather

[13:45] <dakkar> that `if` runs only once

[13:45] <demostanis[m]> That's what it's supposed to do?

[13:45] <dakkar> sorry, yes, sort of, I had mis-read the regex

[13:47] <demostanis[m]> It's saying 'cid' is not in the gathered list

[13:48] <dakkar> https://pastebin.com/Q5cR03A7

[13:49] <dakkar> you were taking the stringification of a match containing multiple sub-matches

[13:49] <dakkar> so instead of <<hcl eyr pid>>, you were taking 'hcl eyr pid'

[13:50] <dakkar> so the ∈ failed

[13:50] <demostanis[m]> Oh rightt.

[13:50] <dakkar> `take $_ for $0.list>>.Str` works (there may well be a prettier way to do that)

[13:54] *** frost joined
[13:54] <demostanis[m]> What does ~$0 exactly do? Why does it convert a match to all matches?

[13:55] <demostanis[m]> It seems like it does

[13:57] <moritz> the ~ just converts the $0 to a string

[13:57] <moritz> and $0 is the same as $/[0], so the first positional capture of a match object

[14:00] <dakkar> m: say '123' ~~ /(\d)+/

[14:00] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢123｣␤ 0 => ｢1｣␤ 0 => ｢2｣␤ 0 => ｢3｣␤»

[14:00] <dakkar> if a match is repeated, it will contain a list of sub-matches

[14:07] <tbrowder> raydiak: pls let us know when you can access docs.raku.org (i just tried and still no joy)

[14:11] <MasterDuke> coincidentally, just a couple minutes ago i got an email from sky saying they don't have docs.raku.org on their block list, so i removed my account exception and yeah, i can get there now (couldn't yesterday without the exception)

[14:17] *** Sgeo joined
[14:20] *** frost left
[14:30] <demostanis[m]> https://pastebin.com/4JgyStVW

[14:30] <demostanis[m]> What does `The iterator of this Seq is already in use/consumed by another Seq

[14:30] <demostanis[m]> (you might solve this by adding .cache on usages of the Seq, or

[14:30] <demostanis[m]> by assigning the Seq into an array)

[14:30] <demostanis[m]> ` mean?

[14:41] *** pragma- left
[14:54] <moritz> demostanis[m]: you can only iterate (or index into, or count the elements of) a sequence once

[14:55] <moritz> if you try to to it twice, you'll get that error message

[14:55] <moritz> m: my \seq = gather { take 1; take 2; take 3 }; .say for seq; .say for seq

[14:55] <camelia> rakudo-moar 37dd25f68: OUTPUT: «1␤The iterator of this Seq is already in use/consumed by another Seq␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤2␤3␤»

[14:55] <moritz> m: my \seq = gather { take 1; take 2; take 3 }; .say for seq.cache; .say for seq

[14:55] <camelia> rakudo-moar 37dd25f68: OUTPUT: «1␤2␤3␤1␤2␤3␤»

[14:59] *** morte_ joined
[15:01] *** morte_` joined
[15:01] *** morte_` left
[15:01] *** morte_` joined
[15:04] *** morte_ left
[15:06] *** morte_` is now known as morte_

[15:09] <demostanis[m]> Thanks, I didn't know. Why those restrictions?

[15:10] <dakkar> demostanis[m]: because, in principle, Seq are lazy and infinitely long

[15:11] <dakkar> also because, if they were generated with a gather/take, to scan them again would require running the code again (with all its side-effects &c, which is usually a bad idea)

[15:12] <dakkar> if you want to treat a Seq like a list or an array, you can (as the error message says) call `.cache` on it, or assign it to an array

[15:13] *** Doc_Holliwood left
[15:13] <dakkar> demostanis[m]: additional confusing detail„

[15:14] <dakkar> the bit of your code that triggers that error is the `all`

[15:14] *** Doc_Holliwood joined
[15:14] <dakkar> `all(<1 2 3>) ∈ @something` is the same as `all( 1 ∈ @something, 2 ∈ @something, 3 ∈ @something )`

[15:14] <dakkar> (roughly)

[15:15] <dakkar> so your code is  trying to go through the result of the inner `gather` more than once

[15:15] <dakkar> which produces the error message

[15:15] <demostanis[m]> Ah I get it now. Could the error message be improved?

[15:15] <dakkar> maybe? I'm pretty sure suggestions are always welcome

[15:16] <dakkar> to solve your problem, I think the simplest way is to do `my @keys = gather { ... }; take $i if all(...) ∈ @keys;`

[15:16] <demostanis[m]> At least to say the subroutine that throws the error, not just the line

[15:16] <dakkar> (or not use the inner `gather` at all)

[15:16] *** morte_` joined
[15:17] <dakkar> demostanis[m]: you have no subroutines

[15:17] <demostanis[m]> the all?

[15:18] <dakkar> ah, ok… I *think* that's very complicated to do, but feel free to open an issue on github about it

[15:19] <dakkar> but generally, sequences and gather/take are used when you don't know the size of the input, like when reading files or sockets

[15:19] <dakkar> in your case, you have fixed input sizes, just use `for` loops

[15:20] <dakkar> (yes, I know this is not generally applicable, and that understanding the various concept is valuable in itself)

[15:21] *** morte_ left
[15:39] <Altreus> m: sub xp-for-lvl($lvl) { 5 * ($lvl ^ 2) + (50 * $lvl) + 100 }; xp-for-lvl(1)

[15:39] <camelia> rakudo-moar 37dd25f68: ( no output )

[15:39] <Altreus> m: sub xp-for-lvl($lvl) { 5 * ($lvl ^ 2) + (50 * $lvl) + 100 }; xp-for-lvl(1).say

[15:39] <camelia> rakudo-moar 37dd25f68: OUTPUT: «one(155, 160)␤»

[15:39] <Altreus> why does this return a one()?

[15:40] <dakkar> because ^ is not the power operator

[15:40] <Altreus> oh :D

[15:40] <Altreus> thanks

[15:42] <dakkar> (it's the infix version of `one`; it's spelled like that because it's semantically similar to the xor operator, which is historically written as ^, blame C, or maybe BCPL)

[15:44] * dakkar learns a lot by looking at other people's code and mistakes

[15:45] * Altreus learns a lot by making them

[16:10] *** _________ is now known as noodly

[16:10] *** noodly is now known as __________

[16:11] *** __________ is now known as _________

[16:13] * ptc wonders what the new libera "two week two hour rule" will mean for lurkers...

[16:14] <dakkar> ptc: it says "accounts that are older than two weeks but were last used within two hours of registration<

[16:15] <dakkar> so as I registered more than two weeks ago, but I used my account today (by logging in), I'm not going to get expired

[16:15] <ptc> yeah, but also if one is going to be offline for a longer period of time, then one has to contact the staff...

[16:15] <jast> yeah, everyone who used their account beyond the first two hours after registering is not affected by the new rule

[16:15] <ptc> does that mean that one can't go on holiday for e.g. 4 weeks?

[16:15] <dakkar> ptc: no, it does not mean that

[16:15] <jast> the normal expire time (if you're not affected by the new rule) is 10 weeks

[16:15] <ptc> jast: ah, ok.  I'd read that differently

[16:16] <ptc> jast: cool, thanks for the explanation :-)

[16:16] <ptc> so...  I'm guessing I'm ok now?

[16:16] <jast> new rule is designed specifically to get rid of squatters

[16:16] <Altreus> You have to contact staff if you register a nick, log in within 2 hours, and then immediately leave on holiday :P

[16:16] <ptc> yeah, that's what it looks like.

[16:17] <ptc> Altreus: :-D

[16:17] <Altreus> of course if you're back within 2 weeks that's fine too

[16:17] <Altreus> I wonder what "used" means, cos if they hadn't had network issues I doubt I would have logged in since I registered

[16:18] <jast> it's all in the explanation

[16:18] <jast> "used" basically means you're signed in with it

[16:18] <Altreus> It defines used but it also fails to define it

[16:19] <jast> I only know a single IRC network that ever got this wrong

[16:19] <jast> there, if someone from the auto-op list didn't rejoin a channel every two weeks, the channel would get dropped

[16:19] <ptc> I only read the diff mentioned in the github.io link and hence lacked the rest of the context.  I've just read the rest and it makes much more sense now.

[16:19] <ptc> thanks for everyone's help!

[16:22] <Altreus> ah, here's me thinking the link would be relevant in isolation

[16:28] <jast> you can expand the view to get the rest of the info, but it's not shown fully by default

[16:28] <Altreus> It's a me-problem, not bothering to see if my question is answered in the things I'm not seeing

[16:35] *** dakkar left
[16:44] *** Eddward joined
[17:05] *** morte_``` joined
[17:09] *** morte_` left
[17:12] *** jess left
[17:14] *** bd3i joined
[17:21] *** melezhik joined
[17:28] *** tadzik is now known as ts

[17:29] *** ts is now known as t

[17:29] *** t is now known as Guest1648

[17:29] *** Guest1648 is now known as tadzik

[17:54] *** bd3i left
[18:01] *** ufobat__ joined
[18:03] *** reportable6 left
[18:04] *** reportable6 joined
[18:04] *** ufobat_ left
[18:11] *** xinming_ is now known as xinming

[18:15] <sjn> heya folks.

[18:15] <sjn> Do we have a short name for modules.raku.org? "MRO" seems kinda confusing to me. :-)

[18:24] <lizmat> raku.land ?

[18:24] <tellable6> hey lizmat, you have a message: https://gist.github.com/156ec6da6b5d710af586f575ba3ae57d

[18:27] <SmokeMachine> Hi you all! How can I do a regex that accepts and opening "stuff" and its closing pair?

[18:28] <ugexe> '<' ~ '>' ?

[18:29] <SmokeMachine> I mean any opening

[18:30] <ugexe> im not sure there is any concept of what the opposite pair is in unicode

[18:31] <codesections> There is, actually, for a number of pair

[18:31] <codesections> S/pair/pairs/

[18:32] <SmokeMachine> something like: my %pairs = "<" => ">", "[" => "]", "(" => ")", "{" => "}"; /{ %pairs.keys } ~ { %pairs{ $0 } } [ something ]/; but better (I don't know if that works)

[18:32] <ugexe> i dont think you can get around creating your own mapping

[18:34] <codesections> hold on, I'm pretty sure you can.  I went down a rabbit hole about this a while back…

[18:36] <SmokeMachine> I feel like that should be native... shouldn't it?

[18:36] <SmokeMachine> (and easy)

[18:36] <ugexe> depends, what is the opposite of L?

[18:37] *** abraxxa-home joined
[18:37] <ugexe> any solution would certainly be specific to a certain type of character

[18:37] <SmokeMachine> I mean, it should exist a list of openings and closings (and a closing for each opening)

[18:38] <SmokeMachine> I mean, like #`<...>, #`(...), #`{{{...}}}, etc... we already have it on our source code...

[18:42] <ugexe> those arent three things are not the same so it wouldnt surprise me to find there is no mechanism used to determine the closing character from the opening character

[18:42] <ugexe> well for a comment they might be the same, but generally not

[18:43] <SmokeMachine> I feel like doing that on a regex should be easy... shouldn't it?

[18:43] <codesections> got it!

[18:43] <ugexe> probably

[18:44] <SmokeMachine> codesections: how?

[18:44] <codesections> no, I mean I figured out how to do it

[18:44] <codesections> m: my regex R { :my $mirror; . {$mirror = $/.uniprop('Bidi_Mirroring_Glyph')} .* (.) <?{$mirror eq $0 }> }; say '()' ~~ /<R>/;

[18:44] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢()｣␤ R => ｢()｣␤  0 => ｢)｣␤»

[18:44] <codesections> m: my regex R { :my $mirror; . {$mirror = $/.uniprop('Bidi_Mirroring_Glyph')} .* (.) <?{$mirror eq $0 }> }; say '(>' ~~ /<R>/;

[18:44] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Nil␤»

[18:46] <SmokeMachine> m: my regex R { :my $mirror; . {$mirror = $/.uniprop('Bidi_Mirroring_Glyph')} .* (.) <?{$mirror eq $0 }> }; say '<>' ~~ /<R>/; say '[]'~~/<R>/

[18:46] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢<>｣␤ R => ｢<>｣␤  0 => ｢>｣␤｢[]｣␤ R => ｢[]｣␤  0 => ｢]｣␤»

[18:46] <ugexe> does it work with ~ ?

[18:48] <SmokeMachine> it seems to:

[18:48] <SmokeMachine> m: m: my regex R { :my $mirror; . {$mirror = $/.uniprop("Bidi_Mirroring_Glyph")} ~ [(.) <?{$mirror eq $0 }>] .*? }; say "<>" ~~ /<R>/; say "[]"~~/<R>/

[18:48] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢<>｣␤ R => ｢<>｣␤  0 => ｢>｣␤｢[]｣␤ R => ｢[]｣␤  0 => ｢]｣␤»

[18:49] <ugexe> it feels like `$mirror = $/.uniprop("Bidi_Mirroring_Glyph")` shouldnt be needed if the first character was captured

[18:49] <SmokeMachine> don't you feel that should be easier?

[18:50] <ugexe> SmokeMachine: that captures the brackets along with the text

[18:50] <codesections> ugexe: yeah, that seems right.  That was just a proof of concept/me remembering how it went

[18:51] <SmokeMachine> m: my regex R { :my $mirror; . {$mirror = $/.uniprop("Bidi_Mirroring_Glyph")} ~ $mirror .*? }; say "<>" ~~ /<R>/; say "[]"~~/<R>/

[18:51] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢<>｣␤ R => ｢<>｣␤｢[]｣␤ R => ｢[]｣␤»

[18:52] <ugexe> m: my regex R { :my $mirror; . {$mirror = $/.uniprop("Bidi_Mirroring_Glyph")} ~ $mirror .*? }; say "[foo]"~~/<R>/

[18:52] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢[foo]｣␤ R => ｢[foo]｣␤»

[18:52] <ugexe> there is no 'foo' match

[18:52] <ugexe> just [foo]

[18:53] <SmokeMachine> m: my regex R { :my $mirror; . {$mirror = $/.uniprop("Bidi_Mirroring_Glyph")} ~ $mirror $<content>=.*? };  say $<content> if "[foo]"~~/<R>/

[18:53] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Nil␤»

[18:54] <SmokeMachine> m: my regex R { :my $mirror; [. {$mirror = $/.uniprop("Bidi_Mirroring_Glyph")}] ~ $mirror $<content>=.*? };  say "[foo]"~~/<R>/

[18:54] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢[foo]｣␤ R => ｢[foo]｣␤  content => ｢foo｣␤»

[18:54] <ugexe> oh yeah

[18:54] <ugexe> the big problem with this is handling escaped characters

[18:55] <ugexe> https://github.com/ugexe/zef/blob/602c54f1069631fd527473f4028451e5c47bc42c/lib/Zef/Identity.rakumod#L18 this attempts to handle escaped characters

[18:56] <SmokeMachine> m: my regex R { :my $mirror; [. {$mirror = $/.uniprop("Bidi_Mirroring_Glyph")}] ~ [<!after \\>$mirror] $<content>=.*? };  say "[foo]" ~~ /<R>/; say "[foo\[bar\]]" ~~ /<R>/

[18:56] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢[foo]｣␤ R => ｢[foo]｣␤  content => ｢foo｣␤｢[foo[bar]｣␤ R => ｢[foo[bar]｣␤  content => ｢foo[bar｣␤»

[18:56] <ugexe> use an unbalanced closing brakcet

[18:57] <ugexe> m: my regex R { :my $mirror; [. {$mirror = $/.uniprop("Bidi_Mirroring_Glyph")}] ~ [<!after \\>$mirror] $<content>=.*? };  say "[foo]" ~~ /<R>/; say "[f\]oo]" ~~ /<R>/

[18:57] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｢[foo]｣␤ R => ｢[foo]｣␤  content => ｢foo｣␤｢[f]｣␤ R => ｢[f]｣␤  content => ｢f｣␤»

[18:57] <ugexe> that should be f\]oo

[18:57] <ugexe> s/should/what you probably want/

[18:59] <codesections> you could always keep a count of nesting depth

[18:59] <codesections> (and maybe use <~~> instead of ~)

[18:59] <ugexe> '<' ~ '>' [<( [[ <!before \>|\<|\\> . ]+?]* %% ['\\' . ]+ )>] 

[18:59] <ugexe> without the auto-closing-bracket stuff its possible like this

[19:03] *** MoC joined
[19:09] *** MoC left
[19:27] <guifa> Note that a Bidi mirroring glyph is separate/distinct to the idea of the opening and closing .  Bidi only says "you can use this glyph when in RTL mode".  „ for instance, is used as an opening quotation mark (whose closing pair is ” ), but has no Bidi mirror glyph (AFAICT) because there's only a single reversed comma

[19:28] <guifa> ⹁⹁ doesn't exist as a single character

[19:28] *** morte_``` left
[19:28] <codesections> guifa, maybe you know: why doesn't this work:

[19:29] <codesections> m: say unimatch '[', 'Bidi_Mirroring_Glyph', ']'

[19:29] <camelia> rakudo-moar 37dd25f68: OUTPUT: «False␤»

[19:29] <codesections> m: say uniprop '[', 'Bidi_Mirroring_Glyph' # even though

[19:29] <camelia> rakudo-moar 37dd25f68: OUTPUT: «]␤»

[19:31] <codesections> m: say '[' ~~ / <:Bidi_Mirroring_Glyph<]>> / # what I really want

[19:31] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Nil␤»

[19:31] <guifa> hmm

[19:31] <guifa> lemme do some tests

[19:33] <codesections> guifa++ don't spend long on it – it's not something I have a use for atm; just something that's been bugging me for the paste few months

[19:33] <codesections> S/paste/past/

[19:34] *** MoC joined
[19:35] <codesections> er, I guess I wrote that blog post in September.  So for the past ~9 months…

[19:35] <guifa> codesections: it's simple, the order's not what you expected ;-)

[19:35] <guifa> say unimatch '[', ']', 'Bidi_Mirroring_Glyph';

[19:35] <evalable6> guifa, rakudo-moar 37dd25f68: OUTPUT: «False␤»

[19:36] <guifa> say unimatch '[', 'x', 'Bidi_Mirroring_Glyph';

[19:36] <evalable6> guifa, rakudo-moar 37dd25f68: OUTPUT: «False␤»

[19:36] <codesections> I was about to say that I thought I'd tried that :)

[19:37] *** _ed joined
[19:37] <guifa> remember though, verticality is not mirrored — the bidi mirror glyph is really just for display engines to use as a fallback for a poorly encoded font

[19:38] <guifa> so

[19:38] <guifa> m: say unimatch '｢', '｣', 'Bidi_Mirroring_Glyph'

[19:38] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Error encoding ASCII string: could not encode codepoint 65379␤  in block <unit> at <tmp> line 1␤␤»

[19:38] * guifa raises eyebrow

[19:38] *** ufobat__ left
[19:39] <guifa> and huh, they did make that the mirrored form, weird.  That feels weird to me

[19:42] *** sono joined
[19:43] <codesections>    m: say unimatch ['{'], '}', 'Bidi_Mirroring_Glyph' # aha! ...but odd

[19:43] <camelia> rakudo-moar 37dd25f68: OUTPUT: «True␤»

[19:43] *** sono left
[19:43] <codesections> er

[19:43] <codesections>    m: say unimatch ['{'], 'X', 'Bidi_Mirroring_Glyph' # aha! ...but odd

[19:43] <camelia> rakudo-moar 37dd25f68: OUTPUT: «True␤»

[19:43] <codesections> nvmd..

[19:46] <guifa> m: (uniprop $_, 'Bidi_Mirroring_Glyph' for <｢ ｣ ⸢ ¿ ? „ , “ ⁅ ‹ ⁈〖 〗 ”> ).join.say

[19:46] <camelia> rakudo-moar 37dd25f68: OUTPUT: «｣｢⸣⁆›〖␤»

[19:47] <guifa> ^^don't trust it to much, I guess is what I'm saying ;-)

[19:47] <codesections> fair

[19:48] <codesections> m: say 'Ⅴ'.unimatch('5', 'Numeric_Value');

[19:48] <camelia> rakudo-moar 37dd25f68: OUTPUT: «False␤»

[19:48] <codesections> bisectable6: 'Ⅴ'.unimatch('5', 'Numeric_Value');

[19:48] <bisectable6> codesections, Will bisect the whole range automagically because no endpoints were provided, hang tight

[19:48] <bisectable6> codesections, ¦6c (55 commits): «»

[19:48] <bisectable6> codesections, Nothing to bisect!

[19:48] <codesections> I thought that used to work…

[19:50] <guifa> weird, I get True for that

[19:51] <guifa> https://tio.run/##K0gtyjH7/784sVJB/VHrEnW90rzM3MSS5AwNdVN1HXW/0tzUoszk@LDEnNJUdU3r//8B

[19:51] * guifa is at office so using TIO

[19:51] <MasterDuke> i get false

[19:51] <MasterDuke> committable6: releases say 'Ⅴ'.unimatch('5', 'Numeric_Value')

[19:52] <committable6> MasterDuke, https://gist.github.com/9e942e5046db1d3a7c75175b38e5bd16

[19:52] * guifa wonders if unicode made adjustments ?

[19:53] <codesections> those are non-continuous ranges…

[19:53] <MasterDuke> bisectable6: old=2020.12 new=2021.02.1 say 'Ⅴ'.unimatch('5', 'Numeric_Value')

[19:53] <bisectable6> MasterDuke, Bisecting by output (old=2020.12 new=2021.02.1) because on both starting points the exit code is 0

[19:53] <bisectable6> MasterDuke, bisect log: https://gist.github.com/88f4e219f585581d01ceaa103ea52b72

[19:53] <bisectable6> MasterDuke, (2021-01-18) https://github.com/rakudo/rakudo/commit/6306f1e0b754c51799380700cd9c23de03a25ce7

[19:54] <MasterDuke> hm, yeah, i thought it was supposed to show contiguous ranges

[19:54] <guifa> codesections: it's three distinct ranges, two false with a true in between.  Likely the 2015-2016 period was before that property was accessible and/or before it was added to UCD 

[19:54] <codesections> makes sense

[19:55] <MasterDuke> yeah, but i thought it should show a false range, true range, false range

[19:55] <codesections> yeah, which must be a regression from the commit it returned

[19:56] <AlexDaniel> Committable doesn't, but bisectable does

[19:56] <AlexDaniel> bisectable6: say 'Ⅴ'.unimatch('5', 'Numeric_Value')

[19:56] <bisectable6> AlexDaniel, Will bisect the whole range automagically because no endpoints were provided, hang tight

[19:56] <AlexDaniel> Let's try

[19:56] <guifa> Yeah, false (not coded into Raku), true (made available in Raku), and false (some interesting reason)

[19:56] <bisectable6> AlexDaniel, Output on all releases: https://gist.github.com/b821ff40a5053f46dfdfe65f1cb7848d

[19:56] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/a81b4d6fa42e37af0f0b5b37807d6520

[19:56] <bisectable6> AlexDaniel, Output on all releases and bisected commits: https://gist.github.com/d1e15a891c0dcf618d07a9589252c983

[19:57] <MasterDuke> ah, nice

[19:57] <AlexDaniel> Ok, not nice... Didn't exactly work

[19:57] <guifa> And of course, Unicode's website is currently down for some reason so I can't go peaking at what may have changed

[19:57] <AlexDaniel> But good effort, thank you, bisectable

[19:58] <guifa> (Properties are subject to change between releases)

[19:58] *** _ed left
[19:59] <codesections> guifa: but if that's the explanation, then there's a bug with uniprop, since it still shows the same values

[20:03] <guifa> https://github.com/rakudo/rakudo/blob/10c3dbb940290c67af33dfc617b2f8ce6a21df28/docs/announce/2021.02.md

[20:05] <vrurg> Am I the only one for whom t/spec/S26-documentation/02-paragraph.t fails to pass? Weirdly enough, the test last changed in 2020 and somehow it currently fails on 2021.06 too.

[20:05] *** MoC left
[20:07] *** morte_``` joined
[20:07] <MasterDuke> complaining about Pod::To::Text?

[20:07] <vrurg> Aha

[20:08] <vrurg> Same on 2021.05. I give up...

[20:08] <MasterDuke> # expected out: "ababc\n"

[20:08] <MasterDuke> #      got err: "\x[1B]===\x[1B]SORRY!\x[1B]===\x[1B] Error while compiling /tmp/getout-2137719-640515.code\nCould not find Pod::To::Text in: <.........>

[20:09] <vrurg> Exactly.

[20:10] <MasterDuke> i had a bunch of deserialization segfaults and such recently, which i fixed by nuking my ~/.raku/precomp directory. i thought it would also fix that, but sadly not

[20:11] <vrurg> Since it fails for past rakudo releases I think it's something in moar/nqp since they remain at the latest version.

[20:11] *** _ed joined
[20:13] <Doc_Holliwood> is there another way to enforce eagerness but the keyword?

[20:14] <Doc_Holliwood> context: https://twitter.com/HrBollermann/status/1407431762368778246

[20:15] <guifa> Okay, the best I can come up with the unimatch issue is this commit

[20:15] <guifa> https://github.com/rakudo/rakudo/commit/6306f1e0b754c51799380700cd9c23de03a25ce7#diff-4dee0b6147afde0a43baaa5c51babb0913b97bc63641ef90612b186f3d0b30e8

[20:15] <guifa> That lines up timewise with there being a problem.  It notes a bug fix in MoarVM, so maybe there's a mismatch between MVM and Rakudo versions that are causing the issue

[20:16] <codesections> guifa: isn't that the one commitable returned earlier?

[20:17] <guifa> Nope.  In order you get 2020.11 = OK, 2020.12 = OK, 2021.02 = NOK

[20:18] <codesections> hmm, well I was looking at that commit by following *some* link from ^^^

[20:18] <guifa> unless I'm misreading the output from MasterDuke 's query

[20:20] <MasterDuke> bisectable6 found that commit

[20:20] <MasterDuke> "MasterDuke, (2021-01-18) https://github.com/rakudo/rakudo/commit/6306f1e0b754c51799380700cd9c23de03a25ce7"

[20:20] <AlexDaniel> easy test I like to do

[20:21] * guifa totally missed that link.  There were so many haha

[20:21] <AlexDaniel> c: 6306f1e0^,6306f1e0 say 'Ⅴ'.unimatch('5', 'Numeric_Value')

[20:21] <committable6> AlexDaniel, ¦6306f1e0^: «True␤» ¦6306f1e: «False␤»

[20:25] *** _ed left
[20:44] *** _ed joined
[20:54] <moon-child> m: sub f { say $x; my $x = 5 }; f()

[20:54] <camelia> rakudo-moar 37dd25f68: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$x' is not declared␤at <tmp>:1␤------> 3sub f { say 7⏏5$x; my $x = 5 }; f()␤»

[20:54] *** jdporter joined
[20:54] <moon-child> m: sub f { EVAL 'say $x'; my $x = 5 }; f()

[20:54] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(Any)␤»

[20:54] <moon-child> ^^ bug?

[20:56] <jdporter> what were you expecting?

[20:57] <moon-child> an error

[21:01] *** jdporter left
[21:02] *** hazeleiez joined
[21:02] *** hazeleiez left
[21:02] *** hazeleiez joined
[21:05] *** hazeleiez left
[21:18] *** sono joined
[21:21] <ugexe> m: say $::("x"); my Int $x = 5;

[21:21] <camelia> rakudo-moar 37dd25f68: OUTPUT: «(Int)␤»

[21:21] <ugexe> m: say $::("x"); BEGIN my Int $x = 5;

[21:21] <camelia> rakudo-moar 37dd25f68: OUTPUT: «5␤»

[21:28] *** abraxxa-home left
[21:40] *** morte_``` left
[21:41] *** morte_` joined
[21:49] *** _ed left
[21:50] *** morte_` left
[21:50] *** morte_``` joined
[21:56] *** _ed joined
[21:58] *** morte_``` left
[22:10] *** _ed left
[22:18] *** _ed joined
[22:19] <JRaspass> What's a good way to get errno via Nativecall under musl and glibc, cglobal ("c", v6), "errno", int32 only works for glibc, I was hoping I could leave out the library name like you can for the native trait but so far no joy.

[22:22] <moon-child> I'm actually surprised that worked at all

[22:23] <JRaspass> Oh? How are you meant to check what the error is after a syscall then?

[22:23] <moon-child> sub __errno_location returns Pointer[int32] is native { ... }

[22:24] <moon-child> (should work for glibc and musl, not for other platforms)

[22:24] * JRaspass googles what that is, fwiw the errno example is in the docs

[22:24] <JRaspass> here https://docs.raku.org/language/nativecall#Exported_variables

[22:24] <moon-child> because errno is tls, and tls wasn't historically in spec.  So non-gnu compilers couldn't handle a header with something like __thread int errno.  So instead it was implemented as a function

[22:27] <moon-child> that example should probably be changed, because it is not at all portable

[22:28] <JRaspass> Huzzah, your native sub with this calling convention seems to work: strerror(__errno_location.deref)

[22:30] <JRaspass> many thanks

[22:31] *** _ed left
[22:35] *** _ed joined
[22:39] *** _ed left
[22:41] *** melezhik left
[22:43] *** rassoc joined
[22:45] <rassoc> say, do we have something like ruby's swapcase in the stdlib? "AbCd".swapcase => "aBcD"

[22:46] <guifa> rassoc: I actually was just looking at that a few days ago and … no

[22:46] <rassoc> ah, a shame, but thanks for the quick response!

[22:47] <codesections> not as a method, but you can do it with a regex of the same length as .swapcase

[22:48] <rassoc> let me check the docs

[22:50] <[Coke]> first time building? what's the error?

[22:51] *** _ed joined
[22:51] <codesections> hmm, actually, maybe that's not quite as nice as I was thinking...

[22:55] *** _ed left
[22:56] <rassoc> not really finding anything in the docs that does what i want. will just juggle some .ords since i only have to support ascii, i think

[22:56] <rassoc> alright, have a good one!

[22:57] <codesections> rassoc: oh, I see it

[22:58] <codesections> m: say 'AbCd'.trans: /<:Lu>/ => $/.lc, /<:!Lu>/ => $/.uc, :g

[22:58] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Use of Nil.lc coerced to empty string␤␤  in block <unit> at <tmp> line 1␤Use of Nil.uc coerced to empty string␤  in block <unit> at <tmp> line 1␤»

[22:59] <codesections> m: say 'AbCd'.trans: [/<:Lu>/, /<:!Lu>/] => [$/.uc, $/.lc], :g

[22:59] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Use of Nil.uc coerced to empty string␤␤  in block <unit> at <tmp> line 1␤Use of Nil.lc coerced to empty string␤  in block <unit> at <tmp> line 1␤»

[22:59] <codesections> hmm?

[22:59] <codesections> m: say 'AbCd'.trans: /<:Lu>/ => $/.lc, :g

[22:59] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Use of Nil.lc coerced to empty string␤bd␤  in block <unit> at <tmp> line 1␤»

[23:00] <codesections> m: say 'AbCd'.trans: /<:Lu>/ => $/.lc

[23:00] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Use of Nil.lc coerced to empty string␤bd␤  in block <unit> at <tmp> line 1␤»

[23:00] *** slu left
[23:01] <codesections> hm, that's working locally.  Odd!

[23:01] <moon-child> codesections: for me,   'AbCd'.trans: /<:Lu>/ => $/.lc, /<:!Lu>/ => $/.uc, :g  evaluates to   aAaA

[23:02] <codesections> ? hmmm

[23:02] <moon-child> but, hmm, only at the repl.  In a file it doesn't

[23:02] <moon-child> nor raku -e

[23:03] <codesections> oh!  I think .trans doesn't set $/, so we're both getting incorrect results based on what we have as our prior match

[23:03] <codesections> in the REPL

[23:04] <moon-child> oh, I see

[23:04] <moon-child> (also, raku has strict evaluation, so arguments are evaluated ahead of time, so they wouldn't get the new $/ even if trans did set it)

[23:04] <guifa> Yeah, and trans wasn't designed to work with callable.  

[23:05] <moon-child> would be cool if trans could take functions, so you could say 'AbCd'.trans: /<:Lu>/ => &lc

[23:05] <codesections> moon-child: oh, that's what it is. .trans is setting it, but for the _next_ call (in the REPL)

[23:08] *** _ed joined
[23:08] <codesections> so is something like this ugly beast really the best we can do? vvvv

[23:08] <codesections> m: say 'AbCd'.comb».&{/<:Lu>/ ?? .lc !! .uc}.join

[23:08] <camelia> rakudo-moar 37dd25f68: OUTPUT: «aBcD␤»

[23:09] <guifa> I mean, I had

[23:09] <guifa> m: my &swapcase = {.comb.map({my \c=.uniprop;c eq'Ll'??.uc!!c eq'Lu'??.lc!!$_ }).join}; say "aBcdÈfGhî".&swapcase

[23:09] <camelia> rakudo-moar 37dd25f68: OUTPUT: «AbCDèFgHÎ␤»

[23:12] <rassoc> there is this also: 

[23:12] *** _ed left
[23:12] <rassoc> m: say 'AbCd'.trans: [['a'..'z'], ['A'..'Z']] => [['A'..'Z'], ['a'..'z']]

[23:12] <camelia> rakudo-moar 37dd25f68: OUTPUT: «aBcD␤»

[23:12] <rassoc> any golfing ideas?

[23:12] <guifa> rassoc: that won't work for all alphabetic input though

[23:13] <guifa> codesections's is probably the most golfed we can get, if you take out the spaces

[23:13] <moon-child> 'AbCd'.trans: .trans: (my @x = [['a'..'z'], ['A'..'Z']]) => @x.reverse

[23:13] <moon-child> s/.trans: //

[23:16] <guifa> m: my &swapcase = {.comb.map({/<:Lu>/??.lc!!.uc}).join}; say "aBcdÈfGhî".&swapcase

[23:16] <camelia> rakudo-moar 37dd25f68: OUTPUT: «AbCDèFgHÎ␤»

[23:16] <guifa> Then you can just use $your-string.&swapcase

[23:17] <moon-child> or just  swapcase $your-string

[23:18] <rassoc> m: my &swapcase = {.comb.map({/<:Lu>/??.lc!!.uc}).join}; say "aB!".&swapcase

[23:18] <camelia> rakudo-moar 37dd25f68: OUTPUT: «Ab!␤»

[23:18] <rassoc> sweet! might use that when dealing with non-ascii stuff. thanks!

[23:19] <rassoc> m: my &swapcase = {.comb.map({/<:Lu>/??.lc!!.uc}).join}; say "aBß".&swapcase

[23:19] <camelia> rakudo-moar 37dd25f68: OUTPUT: «AbSS␤»

[23:19] <rassoc> slick!

[23:19] <guifa> Note that it's based on Unicode's mapping, so case isn't per se reversible

[23:20] *** sono left
[23:21] <rassoc> that's alright, behaves just like ruby's swapcase as far as i can tell

[23:25] *** m6502 joined
[23:50] *** _ed joined
[23:52] <codesections> guifa: it just occurred to me that the way Raku could solve ^^^^ is to add a '#' flag to .subst, following `date`s clean design 

[23:52] <tonyo> m: say S:g/ $<lc> = <:Lu> || $<uc> = <:!Lu> /{$<lc>??$<lc>.lc!!$/.uc}/ given "AbCd"

[23:52] <camelia> rakudo-moar 772711ad3: OUTPUT: «aBcD␤»

[23:53] <codesections> the fact that you save the char into a $<lc> capture if it's upper case really bugs me :D

