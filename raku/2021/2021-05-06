[00:02] *** reportable6 left
[00:05] *** reportable6 joined
[01:05] *** benchable6 left
[01:05] *** nativecallable6 left
[01:05] *** linkable6 left
[01:05] *** sourceable6 left
[01:05] *** evalable6 left
[01:05] *** quotable6 left
[01:05] *** coverable6 left
[01:05] *** greppable6 left
[01:05] *** notable6 left
[01:05] *** unicodable6 left
[01:05] *** statisfiable6 left
[01:05] *** committable6 left
[01:05] *** bisectable6 left
[01:05] *** squashable6 left
[01:05] *** tellable6 left
[01:05] *** releasable6 left
[01:05] *** bloatable6 left
[01:05] *** shareable6 left
[01:05] *** statisfiable6 joined
[01:05] *** coverable6 joined
[01:05] *** bisectable6 joined
[01:06] *** notable6 joined
[01:06] *** linkable6 joined
[01:06] *** nativecallable6 joined
[01:06] *** evalable6 joined
[01:06] *** tellable6 joined
[01:06] *** unicodable6 joined
[01:07] *** releasable6 joined
[01:07] *** shareable6 joined
[01:07] *** benchable6 joined
[01:07] *** committable6 joined
[01:07] *** quotable6 joined
[01:08] *** squashable6 joined
[01:08] *** bloatable6 joined
[01:08] *** sourceable6 joined
[01:08] *** greppable6 joined
[01:16] *** dotdotdot left
[01:17] *** dotdotdot joined
[01:18] *** gfldex left
[01:18] *** gfldex joined
[01:19] *** oddp left
[01:43] *** rindolf left
[01:44] *** kvw_5_ joined
[01:47] *** kvw_5 left
[01:51] *** ecocode_ joined
[01:52] *** pounce_ joined
[01:52] *** aindilis left
[01:52] *** doconthe2ocks left
[01:52] *** ecocode left
[01:52] *** telex left
[01:52] *** silug left
[01:52] *** cgfbee left
[01:52] *** ribasushi left
[01:52] *** sxmx1 left
[01:52] *** El_Che left
[01:52] *** Voldenet left
[01:52] *** donaldh left
[01:53] *** aindilis joined
[01:53] *** doconthe2ocks joined
[01:53] *** telex joined
[01:53] *** silug joined
[01:53] *** cgfbee joined
[01:53] *** ribasushi joined
[01:53] *** sxmx1 joined
[01:53] *** El_Che joined
[01:53] *** Voldenet joined
[01:53] *** donaldh joined
[01:53] *** afresh1 joined
[01:53] *** markmarkmark joined
[01:53] *** tobs joined
[01:53] *** hvxgr joined
[01:53] *** jraspass joined
[01:53] *** tailgate joined
[01:53] *** BinGOs joined
[01:53] *** lucs joined
[01:54] *** cgfbee left
[01:57] *** cgfbee joined
[02:00] *** jmcgnh left
[02:03] <kybr> m: class Foo { proto foo($this, :$that) { } ; method bar { &foo.signature } } ; Foo.new.bar.say

[02:03] <camelia> rakudo-moar 877fdd775: OUTPUT: «($this, :$that)␤»

[02:04] <kybr> m: class Foo { proto foo($this, :$that) { } ; method bar { &foo.signature } } ; Foo.bar.say

[02:04] <camelia> rakudo-moar 877fdd775: OUTPUT: «($this, :$that)␤»

[02:08] *** jmcgnh joined
[02:09] *** rindolf joined
[02:15] *** rindolf left
[02:16] *** rindolf joined
[02:21] *** rindolf left
[02:22] *** rindolf joined
[02:40] *** rindolf left
[02:41] *** rindolf joined
[03:02] *** rindolf left
[03:04] *** rindolf joined
[03:05] *** webstrand left
[03:05] *** lucasb left
[03:13] <kybr> m: class Foo { method foo($this, :$that) { } ; method bar { &foo.signature } } ; Foo.bar.say

[03:13] <camelia> rakudo-moar 877fdd775: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    foo used at line 1␤␤»

[03:13] *** rindolf left
[03:14] *** rindolf joined
[03:30] *** rindolf left
[03:31] *** rindolf joined
[03:37] *** rindolf left
[03:38] *** rindolf joined
[03:43] *** rindolf left
[03:44] *** rindolf joined
[03:47] *** rindolf left
[03:48] *** rindolf joined
[03:57] *** frost-lab joined
[03:59] *** rindolf left
[04:00] *** rindolf joined
[04:02] *** rindolf left
[04:16] *** rindolf joined
[04:21] *** kurahaupo left
[04:25] *** kurahaupo joined
[04:31] *** rindolf left
[04:31] *** rindolf joined
[04:36] *** rindolf left
[04:39] *** neshpion left
[04:40] *** neshpion joined
[04:40] *** rindolf joined
[04:41] *** neshpion left
[04:48] *** parabolize left
[04:57] *** rindolf left
[04:58] *** rindolf joined
[05:02] *** jmerelo joined
[05:12] *** rindolf left
[05:13] *** rindolf joined
[05:31] *** rindolf left
[05:32] *** rindolf joined
[05:32] *** rindolf left
[05:32] *** b2gills left
[05:33] *** b2gills joined
[05:38] *** rindolf joined
[05:53] *** wamba joined
[05:54] *** geth_ joined
[05:57] *** Geth left
[06:02] *** reportable6 left
[06:03] *** reportable6 joined
[06:04] *** cxreg left
[06:04] *** cxreg joined
[06:29] *** _________ left
[06:37] *** aukkras joined
[06:51] *** domidumont joined
[07:14] *** pecastro joined
[07:48] *** brtastic joined
[07:57] *** dogbert17 left
[08:01] *** pierce joined
[08:03] *** dogbert17 joined
[08:06] *** rindolf left
[08:12] *** Sgeo left
[08:15] *** kurahaupo left
[08:17] *** sena_kun left
[08:17] *** kurahaupo joined
[08:18] *** sena_kun joined
[08:22] *** pierce left
[08:35] *** wl20 left
[08:43] *** geth_ left
[08:43] *** Geth joined
[08:48] *** marcusr left
[08:48] *** marcusr joined
[08:52] *** wl20 joined
[09:03] *** ab5tract joined
[09:03] *** Nahita joined
[09:08] *** Nahita left
[09:28] *** Xliff joined
[09:34] *** ab5tract left
[10:34] *** evalable6 left
[10:34] *** asymptotically joined
[10:36] *** evalable6 joined
[10:40] *** kurahaupo left
[10:40] *** kurahaupo_ joined
[10:42] *** kurahaupo_ left
[10:55] *** Black_Ribbon left
[11:26] *** MasterDuke left
[11:44] *** PimDaniel joined
[11:44] <PimDaniel> Hi!

[11:44] <PimDaniel> \o

[11:44] <PimDaniel> What is or vs || or | ?

[11:45] <PimDaniel> m: say False | True;

[11:45] <camelia> rakudo-moar 877fdd775: OUTPUT: «any(False, True)␤»

[11:45] <PimDaniel> m: say False || True;

[11:45] <camelia> rakudo-moar 877fdd775: OUTPUT: «True␤»

[11:45] <PimDaniel> m: say False or True;

[11:45] <camelia> rakudo-moar 877fdd775: OUTPUT: «WARNINGS for <tmp>:␤False␤Useless use of constant integer True in sink context (line 1)␤»

[11:46] <PimDaniel> I do not understand any more.

[11:51] <parv> m: say ( False || True ) ; ( say False ) || True ; say ( False or True )

[11:51] <camelia> rakudo-moar 877fdd775: OUTPUT: «WARNINGS for <tmp>:␤True␤False␤True␤Useless use of constant integer True in sink context (line 1)␤»

[11:54] <parv> m: x = say False ; x.WHAT

[11:54] <camelia> rakudo-moar 877fdd775: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix = instead.␤Did you make a mistake in Pod syntax?␤at <tmp>:1␤------> 3x =7⏏5 say False ; x.WHAT␤»

[11:54] <parv> m: $x = say False ; x.WHAT

[11:54] <camelia> rakudo-moar 877fdd775: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$x' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5$x = say False ; x.WHAT␤»

[11:54] <parv> m: $x = say False ; $x.WHAT

[11:54] <camelia> rakudo-moar 877fdd775: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$x' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5$x = say False ; $x.WHAT␤»

[11:54] <parv> m: my $x = say False ; $x.WHAT

[11:54] <camelia> rakudo-moar 877fdd775: OUTPUT: «False␤»

[11:54] <parv> m: my $x = say False ; say  $x

[11:54] <camelia> rakudo-moar 877fdd775: OUTPUT: «False␤True␤»

[11:55] <parv> m: my $x = say False ; say  $x.WHAT

[11:55] <camelia> rakudo-moar 877fdd775: OUTPUT: «False␤(Bool)␤»

[11:56] <parv> m: my $x; my $y = False; say $y == False | True 

[11:56] <camelia> rakudo-moar 877fdd775: OUTPUT: «any(True, False)␤»

[11:57] <parv> m: my $x; my $y = False; say $y == (False | True)

[11:57] <camelia> rakudo-moar 877fdd775: OUTPUT: «any(True, False)␤»

[11:57] <parv> m: my $x; my $y = False; $x = $y == (False | True)

[11:57] <camelia> rakudo-moar 877fdd775: ( no output )

[11:57] <parv> m: my $x; my $y = False; $x = $y == (False | True) ; say $x

[11:57] <camelia> rakudo-moar 877fdd775: OUTPUT: «any(True, False)␤»

[11:59] <PimDaniel> parv thank you to give a try for me: I think the documentation is for me umbiguous because i do not well understand english language. According to https://docs.raku.org/routine/or or should behave almost like || but i struggle to understand terms :"looser precedence" and "it short-circuit".

[12:02] *** reportable6 left
[12:02] <parv> PimDaniel, regarding short circuit: in case of ||, if the first condition is true, then second is not evaluated. In case of &&, if the first condition is false, second condition will not be evaluated.

[12:04] <PimDaniel> What i need to achieve is simple : i get 2 expressions that when avaluated are each True or False if only one is True i need to return True so i made : return <expr1> || <expr2> and it works as expected  but not <expr1> or <expr2>.

[12:04] *** reportable6 joined
[12:05] <parv> PimDaniel, on precedence: https://docs.raku.org/language/operators#Operator_precedence

[12:06] <PimDaniel> parv Yess what mease looser precedence? This is actually what i do not understand.

[12:06] <PimDaniel> *means

[12:10] <frost-lab> m: say (True || False); say True or False;

[12:10] <camelia> rakudo-moar 877fdd775: OUTPUT: «WARNINGS for <tmp>:␤True␤True␤Useless use of constant integer False in sink context (line 1)␤»

[12:11] <frost-lab> m: say (False || False); say False or False;

[12:11] <camelia> rakudo-moar 877fdd775: OUTPUT: «WARNINGS for <tmp>:␤False␤False␤Useless use of constant integer False in sink context (line 1)␤»

[12:12] <parv> m: 5

[12:12] <camelia> rakudo-moar 877fdd775: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 5 in sink context (line 1)␤»

[12:12] *** ggoebel joined
[12:13] <ggoebel> PimDaniel: looser precedence is the same thing as multiplication coming before addition

[12:14] <frost-lab> m: (say False) or False

[12:14] <camelia> rakudo-moar 877fdd775: OUTPUT: «WARNINGS for <tmp>:␤False␤Useless use of constant integer False in sink context (line 1)␤»

[12:15] <frost-lab> say (False or False)

[12:15] <evalable6> frost-lab, rakudo-moar 877fdd775: OUTPUT: «False␤»

[12:16] <frost-lab> m: say ((say False) or False)

[12:16] <camelia> rakudo-moar 877fdd775: OUTPUT: «False␤True␤»

[12:16] *** PimDaniel left
[12:17] *** PimDaniel joined
[12:17] <PimDaniel> ggoebel ok i see.

[12:18] <parv> why is return value of say is True but not integer?

[12:19] <PimDaniel> parv you do you mean || converts to Integer and brings to a different result?

[12:19] <ggoebel> so addition is looser than multiplication

[12:21] <parv> PimDaniel, No. My question is why "$x" in "my $x = say ..." has the value of "True"?

[12:22] *** thundergnat joined
[12:22] *** ggoebel left
[12:22] <PimDaniel> parv : Sorry: I do not know what code or example you refer to.

[12:22] <thundergnat> say() returns whether it succeeds (True) or fails (Failure)

[12:23] <frost-lab> the definition of say is 'multi method say(IO::Handle:D: **@text --> True)'

[12:23] <thundergnat> As long as you are say()ing to $*STDOUT, it almost can't help but succeed, so always returns True.

[12:24] <parv> Ah. Thank you, thundergnat & frost-lab.

[12:24] <PimDaniel> okay i think i can see: this is an important point too.

[12:25] <PimDaniel> Thank you to all of you. I'll be back later. Good afternoon!

[12:26] <thundergnat> say 0 and say 'loose precedence'; # and is looser (lower precedence) than say

[12:26] <thundergnat> m: say 0 and say 'loose precedence'; # and is looser (lower precedence) than say

[12:26] <camelia> rakudo-moar 877fdd775: OUTPUT: «0␤loose precedence␤»

[12:27] <thundergnat> m: say 0 && say 'tight precedence';  # && is tighter (higher precedence) than say

[12:27] <camelia> rakudo-moar 877fdd775: OUTPUT: «0␤»

[12:27] *** PimDaniel left
[12:35] *** wl20 left
[12:36] *** parv left
[12:37] *** jmerelo left
[12:37] *** wl20 joined
[12:38] *** titsuki joined
[12:57] *** thundergnat left
[13:32] *** dogbert11 joined
[13:34] *** nicholatian left
[13:34] *** wamba left
[13:35] *** dogbert17 left
[13:35] *** wamba joined
[13:35] *** wl20 left
[13:36] *** frost-lab left
[13:36] *** wl20 joined
[13:38] *** sftp left
[13:40] *** sftp joined
[13:44] *** Nahita joined
[13:45] *** nicholatian joined
[13:47] *** Nahita left
[13:48] *** PimDaniel joined
[13:48] <PimDaniel> \)

[13:48] <PimDaniel> \O

[13:48] <PimDaniel> Hi.

[13:49] <PimDaniel> How to check if an instance is created? or NOT?

[13:49] <PimDaniel> A Class instance, i mean.

[13:50] <PimDaniel> Created or container attached to a new Class.

[13:53] <PimDaniel> Has an example class A{ has A $!next; } but further in the code $!next is supposed to be assigned to the next A object, but not allways assigned in some circumstances. how to i check if it is not, thank you.

[13:53] <PimDaniel> *As an example

[13:57] <tadzik> you can check if it's `defined $!next`, maybe

[13:59] <PimDaniel> Ok i try that...

[14:03] <PimDaniel> tadzik : ok it works, i forgetted .defined; Lack of memory, i mean into my head.

[14:03] <PimDaniel> tadzik: thank you!

[14:04] <tadzik> :)

[14:04] <tadzik> you're welcome

[14:04] <PimDaniel> back later.

[14:04] *** PimDaniel left
[14:08] *** parabolize joined
[14:15] *** Sgeo joined
[14:29] *** dogbert17 joined
[14:32] *** dogbert12 joined
[14:33] *** dogbert11 left
[14:34] *** dogbert17 left
[14:37] *** whatnext joined
[14:38] <whatnext> hello all:)  - can anyone help me out with a really basic question? Posted here: https://perlmonks.org/?node_id=11132158

[14:41] <El_Che> whatnext: it expects an array

[14:41] <tonyo> whatnext: you're right it expects only self.

[14:41] <tonyo> m: class A { has @.scales is rw; }; my $a = A.new; $a.scales = qw<green blue yello>; $a.scales.say;

[14:41] <camelia> rakudo-moar 2776d6962: OUTPUT: «[green blue yello]␤»

[14:41] <tonyo> use that for assignment ^

[14:43] <tonyo> even if you call .scales([1,2,3]) you'll get that error except it'll say `but got 2` rather than `but got 4`

[14:44] <lizmat> weekly: https://perlmonks.org/?node_id=11132158

[14:44] <notable6> lizmat, Noted! (weekly)

[14:45] *** dogbert17 joined
[14:47] <whatnext> tonyo - ah thanks! I was being a dimwit. Pythonic style accessors - that didn't occur to me:/

[14:48] *** dogbert12 left
[14:52] *** dogbert11 joined
[14:53] *** mowcat joined
[14:55] *** dogbert17 left
[14:56] *** wl20 left
[15:03] *** oddp joined
[15:12] <oddp> Oi! Say i have an array via: `my @arr = [False xx 5] xx 5`. Any idea how i could toggle a rect slice? Tried `@arr[2..4, 2..4] xor= True`, but that doesn't work

[15:13] *** b2gills left
[15:13] *** b2gills joined
[15:15] <oddp> Setting it to either True, for example, via `@arr[2..4, 2..4] = True xx *` works, but i'm looking for a way to toggle them since i have many overlapping rects

[15:15] <oddp> to True*

[15:16] <oddp> No other elegant way than the good-old nested looping?

[15:16] <Altreus> m: my @arr = [False xx 5] xx 5; $_ xor= True for @arr[2..4, 2..4]; say @arr

[15:16] <camelia> rakudo-moar 2776d6962: OUTPUT: «Cannot assign to an immutable value␤  in block <unit> at <tmp> line 1␤␤»

[15:16] <Altreus> o

[15:17] <Altreus> I feel like the principal difference is that your xor= attempt doesn't apply a True to each member but to the slice itself

[15:17] <Altreus> but i don't know how to spell that in Raku

[15:19] <tonyo> i don't think @arr[2..4, 2..4] = True xx * works, it seems like that just confirms it's applying your rhs to the slice itself..

[15:19] *** whatnext left
[15:25] *** Sgeo_ joined
[15:25] *** Sgeo left
[15:26] <oddp> `xor=` seems to be problematic, getting `(Any)` values. But this not so sexy approach seems to be good enough for now: `for @arr[2..4; 2..4] <-> $v { $v = !$v }`

[15:26] <oddp> Thanks for your input!

[15:28] <Altreus> ah forgot about <->

[15:32] *** gordonfish left
[15:43] *** gordonfish joined
[15:46] *** brtastic left
[16:12] *** neshpion joined
[16:15] *** Kaiepi left
[16:17] *** Kaiepi joined
[16:17] *** Kaiepi left
[16:18] *** Kaiepi joined
[16:25] *** domidumont left
[16:39] *** Kaiepi left
[16:47] *** stoned75 left
[16:49] *** kybr_ joined
[16:49] *** kybr_ is now known as metacookie

[17:00] *** DiffieHellman left
[17:01] *** DiffieHellman joined
[17:04] <metacookie> are captures immutable? i wish to build one incrementally.

[17:06] <metacookie> and call a function using that capture. or, can i make a capture from a hash?

[17:11] <lizmat> m: my $c = Capture.new(list => (42,666)); sub a(|c) { dd c }; a |$c

[17:11] <camelia> rakudo-moar 2776d6962: OUTPUT: «\(42, 666)␤»

[17:11] <lizmat> metacookie ^^ 

[17:11] <lizmat> something like that ?

[17:11] *** brtastic joined
[17:12] <lizmat> m: my $c = Capture.new(list => (42,666), hash => { a => "foo", b => "bar" }); sub a(|c) { dd c }; a |$c    # also with nameds

[17:12] <camelia> rakudo-moar 2776d6962: OUTPUT: «\(42, 666, :a("foo"), :b("bar"))␤»

[17:13] <metacookie> yay! thank you

[17:29] *** thundergnat joined
[17:29] <thundergnat> m: my @arr = [False xx 5] xx 5; @arr[2..4; 2..4] »xor=» True; say @arr

[17:29] <camelia> rakudo-moar 2776d6962: OUTPUT: «[[False False False False False] [False False False False False] [False False True True True] [False False True True True] [False False True True True]]␤»

[17:30] <thundergnat> oddp ^^^

[17:31] <oddp> damn, looking slick, thundergnat!

[17:33] <thundergnat> Hmm. That may not actually do what you want. It seems to ignore the xor part.

[17:34] <oddp> Yeah, and >>=>> True/False doesn't seem to be working either for when i want to set a rect. Might have to look that up in the docs

[17:35] <Xliff> I see true values. xor= has to be working. Right?

[17:36] <Xliff> m: my @arr = [False xx 5] xx 5; @arr[2..4; 2..4] «xor=« True; say @arr

[17:36] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «Lists on either side of non-dwimmy hyperop of infix:<xor> + {assigning} are not of the same length while recursing␤left: 9 elements, right: 1 elements␤  in block <unit> at <tmp> line 1␤␤»

[17:36] <tonyo> m: my @arr = [True xx 5] xx 5; @arr[2..4; 2..4] »xor=» True; say @arr

[17:36] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[True True True True True] [True True True True True] [True True (Any) (Any) (Any)] [True True (Any) (Any) (Any)] [True True (Any) (Any) (Any)]]␤»

[17:36] <oddp> Yeah, that's the problematic part i talked about above

[17:36] <Xliff> m: my @arr = [False xx 5] xx 5; @arr[2..4; 2..4] »xor=» True; say @arr

[17:36] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[False False False False False] [False False False False False] [False False True True True] [False False True True True] [False False True True True]]␤»

[17:36] <oddp> that's why i went with $v = !$v

[17:36] <thundergnat> I was just going to type that exact line...

[17:37] <oddp> m: my @arr = [False xx 5] xx 5; @arr[2..4; 2..4] »^^=» True; say @arr

[17:37] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[False False False False False] [False False False False False] [False False True True True] [False False True True True] [False False True True True]]␤»

[17:37] <oddp> m: my @arr = [True xx 5] xx 5; @arr[2..4; 2..4] »^^=» True; say @arr

[17:37] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[True True True True True] [True True True True True] [True True (Any) (Any) (Any)] [True True (Any) (Any) (Any)] [True True (Any) (Any) (Any)]]␤»

[17:39] <tonyo> m: my @arr = [True xx 5] xx 5; @arr[2..4; 2..4] »=» (* xor True).so; say @arr

[17:39] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[True True True True True] [True True True True True] [True True False False False] [True True False False False] [True True False False False]]␤»

[17:40] <tonyo> m: my @arr = [False xx 5] xx 5; @arr[2..4; 2..4] »=» (* xor True).so; say @arr

[17:40] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[False False False False False] [False False False False False] [False False False False False] [False False False False False] [False False False False False]]␤»

[17:41] <tonyo> hm

[17:45] *** patrickb joined
[17:47] <Altreus> badger badger badger badger

[17:51] <thundergnat> Interestingly it seems to work correctly for bitwise xor

[17:51] <thundergnat> m: my @arr = [0 xx 5] xx 5; @arr[2..4; 2..4] »+^=» 1; say @arr; @arr[2..4; 1..3] »+^=» 1; say @arr;

[17:51] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[0 0 0 0 0] [0 0 0 0 0] [0 0 1 1 1] [0 0 1 1 1] [0 0 1 1 1]]␤[[0 0 0 0 0] [0 0 0 0 0] [0 1 0 0 1] [0 1 0 0 1] [0 1 0 0 1]]␤»

[17:51] <lizmat> .oO( snake! )

[17:56] <oddp> Interesting! Even `@arr[2..4; 2..4] »=» 1` in that case

[17:56] <oddp> strange that >>=>> 1 is exploding

[17:56] <oddp> m: my @arr = [0 xx 5] xx 5; @arr[2..4; 2..4] »=» 1; say @arr;

[17:56] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[[0 0 0 0 0] [0 0 0 0 0] [0 0 1 1 1] [0 0 1 1 1] [0 0 1 1 1]]␤»

[17:56] <oddp> m: my @arr = [0 xx 5] xx 5; @arr[2..4; 2..4] >>=>> 1; say @arr;

[17:56] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing << or >>␤at <tmp>:1␤------> 3r = [0 xx 5] xx 5; @arr[2..4; 2..4] >>=>7⏏5> 1; say @arr;␤    expecting any of:␤        infix␤        infix stopper␤»

[17:57] <lizmat> m: my @arr = [0 xx 5] xx 5; @arr[2..4; 2..4] >> = >> 1; say @arr;

[17:57] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of >> to do right shift.  In Raku please use: +> or ~>.␤at <tmp>:1␤------> 3arr = [0 xx 5] xx 5; @arr[2..4; 2..4] >>7⏏5 = >> 1; say @arr;␤»

[17:57] <lizmat> m: my @arr = [0 xx 5] xx 5; @arr[2..4; 2..4] >>=>> 1; say @arr;

[17:57] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing << or >>␤at <tmp>:1␤------> 3r = [0 xx 5] xx 5; @arr[2..4; 2..4] >>=>7⏏5> 1; say @arr;␤    expecting any of:␤        infix␤        infix stopper␤»

[17:57] <lizmat> yeah, I guess that's a parsing ambiguity with => being interpreted as a Pair constructor

[17:58] <lizmat> unicode ops FTW

[17:59] <oddp> jesus, just figured out why the rest of program wasn't working; today is full of surprises ;)

[17:59] <oddp> m: say ['12'..'24']

[17:59] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[12 13 14 22 23 24]␤»

[17:59] <oddp> not what i expected

[18:00] <oddp> but a .map(*.Int) finally fixes the whole thing

[18:00] <lizmat> don't use quotes then  :-)

[18:00] <oddp> range is coming straight out of $line.comb(

[18:00] <oddp> range is coming straight out of $line.comb(/\d+/)

[18:01] <lizmat> perhaps make a sub that intifies the endpoints?

[18:01] <lizmat> that would make it much more efficient

[18:01] <oddp> went with: my ($x1, $y1, $x2, $y2) = $line.comb(/\d+/).map(*.Int);

[18:01] *** reportable6 left
[18:01] <lizmat> ah, yes, that works  :-)

[18:02] <lizmat> as long as you don't do the .map(*.Int) on the Range with Str endpoints

[18:02] <lizmat> ah, and that wouldn't do what you want anyways...

[18:02] <lizmat> duh

[18:04] *** reportable6 joined
[18:06] <tonyo> m: say [12..24]

[18:06] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «[12 13 14 15 16 17 18 19 20 21 22 23 24]␤»

[18:08] *** Nahita joined
[18:14] *** wamba left
[18:18] *** Nahita left
[18:18] *** stoned75 joined
[18:31] *** wamba joined
[18:33] *** mowcat left
[18:37] *** xelxebar joined
[18:37] *** xelxebar_ left
[18:40] *** titsuki left
[18:40] *** thundergnat left
[18:53] *** Nahita joined
[18:57] *** Manifest0 left
[18:59] *** Manifest0 joined
[19:03] *** tejr left
[19:05] *** tejr joined
[19:12] *** aborazmeh joined
[19:13] <gfldex> m: my (Int() $i, Int() $j) = '22', '33'; .WHAT.say for $i, $j;

[19:13] <camelia> rakudo-moar e6a7bfe7b: OUTPUT: «(Int)␤(Int)␤»

[19:20] *** MasterDuke joined
[19:24] *** Black_Ribbon joined
[19:24] *** Nahita left
[19:38] *** dogbert17 joined
[19:42] *** dogbert11 left
[19:46] *** dogbert17 left
[19:49] *** metacookie left
[19:54] *** wamba left
[20:00] *** parv joined
[20:00] *** aborazmeh left
[20:08] *** Xliff left
[20:09] *** dogbert17 joined
[20:09] *** dogbert11 joined
[20:13] *** dogbert17 left
[20:19] *** dogbert11 left
[20:20] *** dogbert11 joined
[20:29] *** dogbert11 left
[20:29] *** MasterDuke left
[20:32] *** dogbert11 joined
[20:32] *** patrickb left
[20:53] <oddp> is qqx{raku script.raku}.chomp the most canonical way to use the result of another raku script?

[20:54] *** brtastic left
[20:56] *** asymptotically left
[21:00] <moon-child> EVAL slurp 'script.raku'!

[21:03] <ugexe> https://docs.raku.org/routine/EVALFILE

[21:04] <oddp> slick, even better than EVAL; thanks both of you!

[21:04] <ugexe> depends though if you want it to be isolated to its own process or not though

[21:05] <ugexe> i.e. using EVAL could change the state of the program running it, whereas e.g. `say run($*EXECUTABLE, $filename, :out).out.slurp(:close)` will be isolated to its own process

[21:05] <oddp> nah, all good, not doing anything serious. just some advent of code, where part2 depends on the answer from part1

[21:14] <oddp> ah, i see what you mean. EVALFILE gives me ambiguous call errors when i have the same subs in part1 and part2. Sticking to qqx then.

[21:24] *** Kaiepi joined
[22:04] *** parv left
[22:04] *** lnx left
[22:04] *** synthmeat left
[22:05] *** robinsmidsrod left
[22:07] *** lnx joined
[22:08] *** robinsmidsrod joined
[22:08] *** synthmeat joined
[22:25] *** mowcat joined
[22:26] *** aluaces left
[22:39] *** dogbert17 joined
[22:42] *** dogbert11 left
[23:02] *** neshpion left
[23:02] *** neshpion joined
[23:05] *** neshpion left
[23:06] *** neshpion joined
[23:17] *** webstrand joined
[23:22] *** pecastro left
[23:23] *** Xliff joined
[23:37] *** mowcat left
[23:50] *** stoned75 left
