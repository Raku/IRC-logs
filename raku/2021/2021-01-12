[00:00] *** stoned75 joined
[00:06] <melezhik> .tell tony-o please take a look at this - https://github.com/tony-o/raku-fez/pull/15 , thanks

[00:06] <tellable6> melezhik, I'll pass your message to tony-o

[00:11] *** lucasb left
[00:12] *** benjif left
[00:12] <notagoodidea> using JSON::Fast, the to-json function is particurly slow (even with :!pretty).

[00:13] <notagoodidea> Is there a alternative to manage large JSON files?

[00:14] <moon-child> notagoodidea: wrt libclang, not writing a native c parser with a raku grammar seems like a missed opportunity

[00:15] <moon-child> (though maybe that needs more perf work yet; as I recall, somebody was trying to express a c++ grammar in raku and it took several minutes to parse a simple function declaration)

[00:15] <notagoodidea> And following the various #include to parse too can be hell.

[00:16] <notagoodidea> I will first try to port this https://github.com/floooh/sokol/tree/bindgen/bindgen to Raku

[00:16] <elcaro> notagoodidea: There is JsonC... but if I recall comments about it, perf still leaves a little to be desired

[00:17] <notagoodidea> From json spit by clang, filtering it and producing NativeCall from the cleaned json like floooh did for zyg.

[00:17] <moon-child> yeah preprocessor is a pain

[00:17] <elcaro> the parsing is faster, but the conversion from C to Raku data structure is a tad slow 

[00:17] <moon-child> notagoodidea: but, in raku you can already modify the parser over the course of a running program.  Idk how that works but presumably you could do the c preprocessor in the same way

[00:17] <notagoodidea> Will see because to-json is running on my computer for the last 10 minutes :)

[00:18] <notagoodidea> (the JSON provided is big)

[00:19] <moon-child> notagoodidea: afaik the sokol bindgen stuff relies on specific annotations in the sokol headers.  So you wouldn't be able to use it for any other library

[00:19] <notagoodidea> 165302 lines.

[00:21] <notagoodidea> ah.

[00:22] <notagoodidea> will try at least for the simplified json output from the clang dump.

[00:26] <notagoodidea> moon-child: Leveraging grammer will be nice but I am not sure that will happen soon, performance wise.

[00:26] <notagoodidea> I am not sure that even parsing JSON with grammar will be that performand (JSON::Fast goes straight for nqp)

[00:27] <moon-child> :/

[00:28] <notagoodidea> And it will be a pain to use because it convert the JSON to a Str :/

[00:29] <notagoodidea> JsonC converts to a hash, that would be easier.

[00:30] <melezhik> .tell tony-o I've added integration test for `fez meta`

[00:30] <tellable6> melezhik, I'll pass your message to tony-o

[00:30] <melezhik> http://161.35.142.50/report/fez-test/276

[00:31] <melezhik> .tell tony-o maybe I should push all the tests to fez repo? i don't know ...

[00:31] <tellable6> melezhik, I'll pass your message to tony-o

[00:32] <notagoodidea> Forget it, JsonC does not pass his test and zef refuse to install :/ 

[00:32] *** stoned75 left
[00:41] *** benjif joined
[00:46] *** pecastro left
[00:53] *** oddp left
[00:56] *** notagoodidea left
[01:06] *** stoned75 joined
[01:20] *** squashable6 left
[01:21] *** jmchael left
[01:23] *** squashable6 joined
[01:35] *** mowcat left
[01:41] *** melezhik left
[01:42] *** stoned75 left
[02:19] *** Ben_Goldberg joined
[02:19] *** BenGoldberg left
[02:20] *** Ben_Goldberg is now known as BenGoldberg

[02:41] *** kvw_5 joined
[02:45] *** kvw_5_ left
[03:05] *** Sgeo_ joined
[03:08] *** Sgeo left
[03:22] *** benjif left
[03:25] *** melezhik joined
[03:25] <melezhik> .

[03:26] <melezhik> .tell tony-o I put fez-test sparky configuration - https://github.com/melezhik/sparky-playground/tree/main/fez-test so far ... cc tib

[03:26] <tellable6> melezhik, I'll pass your message to tony-o

[03:41] *** melezhik left
[04:41] *** sourceable6 left
[04:41] *** greppable6 left
[04:41] *** evalable6 left
[04:41] *** unicodable6 left
[04:41] *** committable6 left
[04:41] *** bloatable6 left
[04:41] *** linkable6 left
[04:41] *** coverable6 left
[04:41] *** benchable6 left
[04:41] *** squashable6 left
[04:41] *** nativecallable6 left
[04:41] *** tellable6 left
[04:41] *** bisectable6 left
[04:41] *** shareable6 left
[04:41] *** statisfiable6 left
[04:41] *** quotable6 left
[04:41] *** notable6 left
[04:41] *** releasable6 left
[04:41] *** sourceable6 joined
[04:42] *** greppable6 joined
[04:42] *** nativecallable6 joined
[04:42] *** statisfiable6 joined
[04:42] *** bloatable6 joined
[04:42] *** quotable6 joined
[04:42] *** evalable6 joined
[04:42] *** unicodable6 joined
[04:42] *** tellable6 joined
[04:42] *** benchable6 joined
[04:43] *** shareable6 joined
[04:43] *** coverable6 joined
[04:43] *** committable6 joined
[04:43] *** notable6 joined
[04:44] *** linkable6 joined
[04:44] *** releasable6 joined
[04:44] *** squashable6 joined
[04:44] *** bisectable6 joined
[05:19] *** BenGoldberg left
[05:26] *** hippo_ joined
[05:26] *** epony left
[05:27] *** epony joined
[05:31] <lucs> Just saw about raku.land

[05:31] <lucs> Nice

[05:31] <lucs> Not sure why they're called "distributions" though.

[05:32] <lucs> Not "modules"?

[05:37] *** brtastic joined
[05:54] *** kst joined
[05:54] *** kst left
[05:55] *** kst joined
[06:02] *** melezhik joined
[06:04] <melezhik> lucs not a big difference on my view.  distribution is a certain version of a module ... something ...

[06:05] <melezhik> I really like this page - https://raku.land/recent - a kind a trend of what's going on ...

[06:08] *** melezhik left
[06:11] *** jmerelo joined
[06:12] <lucs> jmerelo: Good morning.

[06:13] <lucs> Having fun in the snow?

[06:14] <lucs> melezhik: Yeah, makes sense. Just not used to that term I guess.

[06:14] <tellable6> lucs, I'll pass your message to melezhik

[06:30] <jmerelo> lucs: not down here, in Granada... 

[06:31] <jmerelo> Not too far away, anyway.

[06:33] <lucs> Aw, too bad, snow is nice (sometimes) ;)

[06:33] *** rindolf joined
[06:33] <lucs> Actually, I didn

[06:34] <lucs> 't read up much on what happened. 

[06:34] <lucs> I guess it must be pretty hard when you're not prepared for it.

[06:35] *** wamba joined
[06:42] *** parabolize left
[06:44] *** jmcgnh joined
[06:55] *** aluaces joined
[06:58] <jmerelo> lucs: it's nice if you're warm and chill... I'm telecommuting these days, so...

[07:01] <lucs> jmerelo: I grew up playing in the snow (winters, that is), which was nice.

[07:01] <lucs> As an adult, not so much :)

[07:01] <lucs> Warm++

[07:02] <jmerelo> lucs: not so usual where I lived. Just the cold and the chilblains. Even in Granada, it's an once every five years event.

[07:03] <jmerelo> not so usual in Madrid, either. Some people are having the time of their lives. Some are just having the most miserable time of their lives.

[07:03] <jmerelo> I lived in Úbeda, north of Granada, a small town which is 700 meters high. But Jaén and Granada are too dry, so rain is unusual

[07:03] <Xliff> m: multi sub trait_mod:<is> (Method $m, :$query!) { my $r = $m; $m.wrap(-> |c { say 'Hi!'; nextsame; }); }; class A::B { method b is query { say 'B'; }; };

[07:03] <camelia> rakudo-moar d53a92733: ( no output )

[07:03] <jmerelo> lucs: where did you live?

[07:04] <Xliff> m: multi sub trait_mod:<is> (Method $m, :$query!) { my $r = $m; $m.wrap(-> |c { say 'Hi!'; nextsame; }); }; class A::B { method b is query { say 'B'; }; }; A::B.new.b

[07:04] <camelia> rakudo-moar d53a92733: OUTPUT: «Hi!␤Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤B␤»

[07:04] <lucs> jmerelo: In Montréal

[07:04] <Xliff> m: multi sub trait_mod:<is> (Method $m, :$query!) { my $r = $m; $m.wrap(method (|c) { say 'Hi!'; nextsame; }); }; class A::B { method b is query { say 'B'; }; }; A::B.new.b

[07:04] <camelia> rakudo-moar d53a92733: OUTPUT: «Hi!␤B␤»

[07:04] <lucs> (Still there)

[07:04] <Xliff> Wow. That doesn't work on my version of Raku.

[07:04] <Xliff> m: $*PERL.compiler.version.say

[07:04] <camelia> rakudo-moar d53a92733: OUTPUT: «v2020.12.42.gd.53.a.92733␤»

[07:05] <jmerelo> lucs: makes sense, then.

[07:06] <jmerelo> Xliff: what didn't work?

[07:10] <Xliff> m: multi sub trait_mod:<is> (Method $m, :$query!) { my $r = $m; $m.wrap(method (|c) { say 'Hi!'; nextsame; }); }; class A::B { method b is query { say 'B'; }; }; A::B.new.b

[07:10] <camelia> rakudo-moar d53a92733: OUTPUT: «Hi!␤B␤»

[07:10] <Xliff> ^^

[07:10] <Xliff> I get a 'Cannot invoke this object' error, locally.

[07:11] <Xliff> I'm on the same version as Camelia.

[07:12] <jmerelo> Xliff: from the REPL?

[07:12] <Xliff> rak?

[07:12] <Xliff> What REPL?

[07:12] <Xliff> No, I'm running that from the command line.

[07:13] <Xliff> I thought I had found a bug, and now it's looking to be environmental. Which is .... ODD

[07:13] <jmerelo> Xliff: Ah, OK. The REPL might behave in a different way. Maybe it's just a new goodie in HEAD

[07:13] <jmerelo> Xliff: give committable a try

[07:13] <Xliff> No. It's not a problem here. 

[07:13] <Xliff> I was hoping I could replicate it HERE.

[07:14] <Xliff> I cannot.

[07:14] <Xliff> It even works on repl.it 

[07:20] *** aborazmeh joined
[07:20] *** aborazmeh left
[07:20] *** aborazmeh joined
[07:24] *** sjm_uk joined
[07:24] <Xliff> jmerelo: FINALLY!

[07:24] <Xliff> See https://repl.it/@Xliff/SorrowfulFlawedMicrobsd#main.raku

[07:25] <Xliff> The compunit is the problem. Somehow the compunit is corrupting things. What I'm attempting works just fine when it's in MAIN::

[07:25] <Xliff> And with that, I must crash and ZZZZZ

[07:27] *** ufobat__ joined
[07:29] <jmerelo> Xliff: have a good night sleep :-)

[07:32] <Xliff> tanks! ;)

[07:32] *** Xliff left
[07:40] *** aborazmeh left
[07:40] *** aluaces left
[07:59] *** sena_kun joined
[08:05] *** domidumont joined
[08:09] *** MasterDuke joined
[08:10] *** BenGoldberg joined
[08:10] *** aluaces joined
[08:14] *** stoned75 joined
[08:16] <stoned75> nef

[08:27] *** notagoodidea joined
[08:27] *** Manifest0 left
[08:30] *** Manifest0 joined
[08:33] *** cgfbee left
[08:34] *** Sgeo_ left
[08:35] *** notagoodidea left
[08:38] *** cgfbee joined
[08:38] <xinming_> SmokeMachine: is it possible to completely delete the optimizer in Red?

[08:39] <SmokeMachine> Not currently, but that’s easy to change... why? Is it giving you problems?

[08:41] <SmokeMachine> xinming_: just need to not run this: https://github.com/FCO/Red/blob/master/lib/Red.pm6#L36

[08:44] *** notagoodidea joined
[08:54] <notagoodidea> moon-child: I found this "old" perl6 module by azawawi (https://github.com/azawawi/p6-libclang) that wrap libclang. And after a deep look at the sokol bindgen, there is nothing that specific.

[08:55] <notagoodidea> the main problem is for now the JSON parsing. I have to try different modules available and worst case scenario use jq for that part.

[08:57] <notagoodidea> or accept the JSON as string and try to parse with a grammar or whatnot.

[09:02] <MasterDuke> notagoodidea: timotimo works on json::fast, he might have a suggestion

[09:03] *** pecastro joined
[09:06] *** dakkar joined
[09:07] *** notagoodidea left
[09:15] *** ufobat joined
[09:17] *** aborazmeh joined
[09:17] *** aborazmeh left
[09:17] *** aborazmeh joined
[09:17] *** ufobat__ left
[09:21] *** JRaspass joined
[09:23] *** tejr left
[09:32] *** notagoodidea joined
[09:36] *** sno left
[09:39] *** Xliff joined
[09:42] *** aborazmeh left
[10:25] *** jmchael joined
[10:33] * lizmat clickbaits https://rakudoweekly.blog/2021/01/11/2021-01-02-so-much-new-stuff/

[10:34] *** cono joined
[10:34] <cono> p6: class { has %!h = a => 42; submethod BUILD() { %!h.say } }.new

[10:34] <camelia> rakudo-moar d53a92733: OUTPUT: «{}␤»

[10:35] <tadzik> BUILD is funny like that

[10:35] <tadzik> p6: class { has %!h = a => 42; submethod TWEAK() { %!h.say } }.new

[10:35] <camelia> rakudo-moar d53a92733: OUTPUT: «{a => 42}␤»

[10:35] <cono> p6: class { has %!h = a => 42; submethod BUILD() { %!h.say }; method g { %!h.say } }.new.g

[10:35] <camelia> rakudo-moar d53a92733: OUTPUT: «{}␤{}␤»

[10:36] <cono> why I don't see it in method g?

[10:37] <tadzik> becuase your BUILD breaks attribute initialization

[10:38] <tadzik> it's not like Moose's BUILD, if you're familiar with that one, it does a bit more and it's often confusing, that's why TWEAK came to be

[10:38] <tadzik> I wish I could tell you exactly what BUILD does and how to make it do what you need, but I just hate it, not understand it and never use it :P

[10:39] <tadzik> but generally BUILD is the bit responsible for setting attribute values, so if you define your own BUILD then it's up to you to set them

[10:43] <cono> oh

[10:43] <cono> I thought BUILD's responsibility is only to set values passed by the arguments. But looks like assigning them in class, also done in BUILD

[10:44] <cono> complex

[10:44] <cono> thanks for explanation! tadzik++

[10:45] <tadzik> you're welcome, I hope I got it right :P

[10:45] <notagoodidea> I don't understand something. Using only JSON::Fast from-json and to-json, the to-json function is super slow. Same json file but using JSON::simd to load and to-json again from JSON::Fast to dump is super fast.

[10:46] <notagoodidea> is due to the fact that JSON::simd create a raku hash instead of a string for the load?

[10:48] <lizmat> notagoodidea: which version of JSON::Fast do you have ?

[10:51] <notagoodidea> I just installed yesterday with zef, let me check.

[10:51] <notagoodidea> 0.15

[10:54] <notagoodidea> the JSON provided is ~160K lines (it is a dump from clang ast of curl.h)

[10:56] <lizmat> ok, then I don't think I have any suggestions to make things faster in the short term

[10:58] <notagoodidea> With JSON::simd for loading and JSON::Fast for dumping, it is fast enough.

[10:58] <notagoodidea> Using only JSON::Fast, loading is fast but dumping is really slow. 

[10:59] <notagoodidea> my guess is the from-json from Fast output a Str instead of a Hash and to-json have a bad time with it.

[11:08] *** abraxxa1 left
[11:08] *** abraxxa1 joined
[11:12] *** PimDaniel joined
[11:13] <PimDaniel> Hi! everybody's waked up?

[11:13] <PimDaniel> Ok, i'll start with a simple question:

[11:15] <PimDaniel> what's the difference between : my @l = <1, 2, 3>; and my @l = 1, 2, 3; ? thank's!

[11:15] <MasterDuke> `<> ` in this case is a quoting construct

[11:16] <MasterDuke> that automatically splits on whitespace

[11:16] <PimDaniel> so my syntax is wrong : i do not have the ,

[11:17] <PimDaniel> my @l = <1 2 3>;

[11:17] *** thdrmz left
[11:18] *** thdrmz joined
[11:18] <MasterDuke> that'll create an array of strings (which in this case will actually be IntStrs, since they "look" like numbers)

[11:18] *** sno joined
[11:19] <MasterDuke> m: dd <1 2 3>; dd 1, 2, 3

[11:19] <camelia> rakudo-moar a13ea269a: OUTPUT: «(IntStr.new(1, "1"), IntStr.new(2, "2"), IntStr.new(3, "3"))␤1␤2␤3␤»

[11:20] *** asymptotically left
[11:20] <PimDaniel> MasterDuke : thank you , i'm looking at  https://docs.raku.org/language/quoting

[11:22] *** PimDaniel left
[11:26] <notagoodidea> ok thinks are getting weirder

[11:28] * MasterDuke pages Dr. Freud

[11:28] <notagoodidea> `use JSON::Fast; my \x = slurp("curl-test.json") ==> from-json; my \xo = to-json x;` runs in 

[11:29] <notagoodidea> 605sec

[11:30] <notagoodidea> idem if you swap `use JSON::Fast` by `use JSON::simd :subs;`

[11:30] *** Altai-man joined
[11:32] *** sena_kun left
[11:36] <tadzik> I guess it's the to-json that's slow, not the from-json, and JSON::simd just uses JSON::Fast's to-json()?

[11:37] <tadzik> from JSON::simd's docs: As an added bonus, this also imports to-json from JSON::Fast, which works exactly as usual

[11:38] <notagoodidea> yes but

[11:38] <notagoodidea> 'use JSON::simd; use JSON::Fast; my $json = JSON::simd.new; my \x = $json.load: "curl-test.json"; my \xo = to-json x;'

[11:38] <notagoodidea> runs in 

[11:39] <notagoodidea> 4.6s

[11:39] *** aluaces left
[11:41] <notagoodidea> I think that the from-json imported with :subs respects the interface of JSON::Fast by providing a Str

[11:42] *** Toilie is now known as dudz

[11:43] *** dudz left
[11:43] *** dudz joined
[11:45] *** Black_Ribbon left
[11:48] <notagoodidea> tadzik: yep it returns a Str and when used the OO way it returns a Hash. to-json is fast with a hash and slow with a Str.

[11:49] <notagoodidea> or I messed something with the feed operator in the declaration?

[11:51] <notagoodidea> yep it is on me.

[11:52] <notagoodidea> with the feed operator, the subs from JSON::simd runs in the time that the OO approach.

[11:53] <notagoodidea> is there a precedence with assignement vs feed operator?

[11:59] <notagoodidea> m: my $x = "foo" ==> map *.uc; say $x;

[11:59] <camelia> rakudo-moar 9e13ace80: OUTPUT: «foo␤»

[12:01] <MasterDuke> m: my $x = do "foo" ==> map *.uc; say $x;

[12:01] <camelia> rakudo-moar 9e13ace80: OUTPUT: «(FOO)␤»

[12:03] <tadzik> wait, what

[12:04] <tadzik> if something returns a Str from JSON parsing, is it even parsing it at all?

[12:04] <dakkar> sure, `"foo"` is a valid JSON-encoded string value

[12:05] <dakkar> (but I think that's not the issue here)

[12:05] <notagoodidea> tadzik: I will test without my mistake to check what JSON::Fast returns

[12:06] <tadzik> dakkar: it's valid, yeah, but if I think if one parsing method returns a Hash and another returns a Str then at least one of them is wrong :P

[12:06] <notagoodidea> tadzik: it returns an Hash

[12:06] <tadzik> for some value of wrong anyway... https://github.com/qntm/fastjson

[12:07] <notagoodidea> The mistake is on me by using the feed operator in the assignement 

[12:09] <MasterDuke> would it be too snarky to say it seems to me that much of npm would belong in the Acme:: namepace in CPAN?

[12:09] <notagoodidea> and Fast is the fastest

[12:10] <notagoodidea> lizmat: in case of, the problem was pebak not JSON::Fast

[12:12] <lizmat> *phew*  :-)

[12:12] *** aborazmeh joined
[12:12] *** aborazmeh left
[12:12] *** aborazmeh joined
[12:15] <tadzik> MasterDuke: I just assume everything on npm is sarcastic :P

[12:20] *** PimDaniel joined
[12:20] <PimDaniel> Hi!

[12:21] <PimDaniel> Modify array by ref with a sub:

[12:21] <PimDaniel> look a my piece of code : https://pastebin.com/8Tc463py

[12:22] <PimDaniel> In Perl5 it was bad to use $_ unless we declared it local.

[12:23] <PimDaniel> Is it safe tu use $_ in a for loop in raku like i did with sub b(@r) {...} in my paste_bin given example?

[12:24] <PimDaniel> if no : could we declare loop variable -> $e as rw?

[12:29] *** aborazmeh left
[12:30] *** BenGoldberg left
[12:30] *** Ben_Goldberg joined
[12:30] *** Ben_Goldberg is now known as BenGoldberg

[12:33] <PimDaniel> Thank's in advance!

[12:35] <moritz> you can use   for @a <-> $n { $n = 42 }

[12:35] <moritz> or

[12:35] <moritz> for @a -> $n is rw { $n = 42 }

[12:37] *** codesect` joined
[12:39] *** codesections left
[12:39] <PimDaniel> moritz : thank your very mutch!

[12:45] *** PimDaniel left
[12:47] *** aborazmeh joined
[12:47] *** aborazmeh left
[12:47] *** aborazmeh joined
[12:59] *** aluaces joined
[13:07] *** k-man left
[13:18] *** k-man joined
[13:29] *** notagoodidea left
[13:51] *** dakkar left
[13:51] *** aborazmeh left
[13:55] *** dakkar joined
[13:57] *** domidumont left
[14:03] *** thdrmz left
[14:15] *** vrurg joined
[14:20] *** thdrmz joined
[14:21] *** aborazmeh joined
[14:21] *** aborazmeh left
[14:21] *** aborazmeh joined
[14:27] *** notagoodidea joined
[14:38] *** MasterDuke left
[14:39] *** parabolize joined
[14:58] *** rindolf left
[15:03] *** wamba left
[15:05] *** codesect` left
[15:06] *** MasterDuke joined
[15:06] *** codesections joined
[15:13] *** rindolf joined
[15:14] <Xliff> OK, how is this for weirdness?

[15:15] <Xliff> https://repl.it/@Xliff/SorrowfulFlawedMicrobsd#main.raku

[15:15] <Xliff> This REPL illustrates a problem that's been driving me batty.

[15:15] <Xliff> The same piece of code is executed. One via MAIN:: the other via a class in another compunit.

[15:16] <Xliff> The MAIN:: code runs fine. It craps out when it's in a compunit.

[15:16] <Xliff> "Help!" he says!

[15:16] *** cpan-raku left
[15:17] *** cpan-raku joined
[15:17] *** cpan-raku left
[15:17] *** cpan-raku joined
[15:20] *** Sgeo joined
[15:30] *** sena_kun joined
[15:32] *** aborazmeh left
[15:32] *** Altai-man left
[15:36] *** aborazmeh joined
[15:36] *** aborazmeh left
[15:36] *** aborazmeh joined
[15:41] *** aborazmeh left
[15:53] *** aborazmeh joined
[15:53] *** aborazmeh left
[15:53] *** aborazmeh joined
[16:03] *** aborazmeh left
[16:08] *** domidumont joined
[16:11] <Xliff> Can you get the instance of an object from one of its Methods?

[16:12] *** atroxaper joined
[16:12] <atroxaper> Hi, #raku

[16:13] <moritz> Xliff: no, methods are generally not bound to instances (unlike in, say, python)

[16:13] <atroxaper> Am I right that wrap method do not change the Signature? What if I want to change it any way? Is it possible?

[16:14] <Xliff> moritz: Ah, thanks.

[16:15] <Xliff> moritz: OK, how about this. Can an inner-sub gain access to class attributes somehow?

[16:15] <Xliff> m: class A { has $!a; sub b { say $!a }; method c { b } }; A.new(a => 42).c

[16:15] <camelia> rakudo-moar 12b49b834: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $!a used where no 'self' is available␤at <tmp>:1␤------> 3class A { has $!a; sub b { say $!a7⏏5 }; method c { b } }; A.new(a => 42).c␤»

[16:15] *** thdrmz left
[16:15] <Xliff> Yeah. Figured that.

[16:16] <Xliff> Barring that... class defined traits. :/

[16:16] <moritz> well, you could put sub b inside method c

[16:17] <moritz> then it gets self as an outer lexical

[16:17] <moritz> or you could pass in `self` explicitly

[16:17] <moritz> m: class A { has $!a; sub b(self) { say $!a }; method c { b } }; A.new(a => 42).c

[16:17] <camelia> rakudo-moar 12b49b834: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Invalid typename 'self' in parameter declaration.␤at <tmp>:1␤------> 3class A { has $!a; sub b(self7⏏5) { say $!a }; method c { b } }; A.new(a␤»

[16:17] <Xliff> Yeah, but I am trying to apply trait mods to methods, but the trait would need access to the object.

[16:18] <moritz> m: class A { has $!a; sub b(\self) { say $!a }; method c { b } }; A.new(a => 42).c

[16:18] <camelia> rakudo-moar 12b49b834: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $!a used where no 'self' is available␤at <tmp>:1␤------> 3lass A { has $!a; sub b(\self) { say $!a7⏏5 }; method c { b } }; A.new(a => 42).c␤»

[16:18] <Xliff> So... more like: class A { method b is blah { ... } };

[16:18] <moritz> Xliff: well, then `self` is the first argument passed to that method

[16:18] <moritz> and you trait then needs to go through that

[16:18] <moritz> and possibly the MOP

[16:19] <Xliff> So....

[16:20] <Xliff> If I wrap a method, I could maybe do...

[16:20] <Xliff> $m.wrap(sub (|c) { c.list[0] # instance? })

[16:21] <moritz> or just $m.wrap(sub (\SELF, |c) { SELF is invocant here })

[16:21] *** _jrjsmrtn joined
[16:21] <Xliff> Cool!

[16:23] *** __jrjsmrtn__ left
[16:28] <notagoodidea> how to I test a type of a variable?

[16:29] <MasterDuke> $foo ~~ Str

[16:29] <notagoodidea> m: my $foo = Any; say $foo.^name =:= Any;

[16:29] <camelia> rakudo-moar 12b49b834: OUTPUT: «False␤»

[16:29] <notagoodidea> m: my $foo = Any; say $foo.^name ~~ Any;

[16:29] <camelia> rakudo-moar 12b49b834: OUTPUT: «True␤»

[16:30] <notagoodidea> thanks!

[16:40] <Xliff> Perl guru help here, pls.

[16:40] <Xliff> https://repl.it/@Xliff/SorrowfulFlawedMicrobsd#main.raku

[16:41] <Xliff> Why does the code in MAIN:: work, but the code from the compunit bomb?

[17:08] <jdv79> notagoodidea: there's a module for the fastest, or it was, json lib somewhere

[17:08] <jdv79> its limitting factor is the c/raku marshalling iirc

[17:08] *** asymptotically joined
[17:09] <jdv79> but it has some opti for certain cases to ameliorate that

[17:09] <notagoodidea> Json::Fast is good in enough for now, crunching load and dump under 

[17:09] <notagoodidea> 2s

[17:10] <notagoodidea> I think my filter and extract methods will take more time.

[17:10] *** tejr joined
[17:10] <jdv79> ah, you found it - JSON::simd

[17:11] <jdv79> backlogging and skipped a bit:(

[17:11] <jdv79> cool

[17:12] <notagoodidea> no trouble. I don't think that I may leverage the delay args from simd so Fast is faster due to the C/raku marshalling on a big json, afaik

[17:14] <notagoodidea> m:say  Hash ~~ Any

[17:14] <evalable6> notagoodidea, rakudo-moar 12b49b834: OUTPUT: «True␤»

[17:16] <notagoodidea> m: say Any ~~Hash;

[17:16] <camelia> rakudo-moar 12b49b834: OUTPUT: «False␤»

[17:16] <notagoodidea> That was confusing.

[17:16] *** b2gills left
[17:16] *** Kaiepi left
[17:23] <atroxaper> Xliff: I have fixed your code. But I don't know how to share it in relp.it ^^

[17:23] <[Coke]> can always post in gist.github.com - what was the fix?

[17:23] <tellable6> 2021-01-11T06:12:48Z #raku <jmerelo> [Coke] thanks!

[17:27] <atroxaper> [Coke]: Oh, sure. Thanks.

[17:27] <atroxaper> Xliff: https://gist.github.com/atroxaper/5b450550bea5eb4915c617f74e3af844 see my comments

[17:32] *** guifa joined
[17:32] *** wamba joined
[17:34] *** MasterDuke left
[17:37] *** dakkar left
[17:38] *** b2gills joined
[17:38] *** notagoodidea left
[17:45] *** lucasb joined
[17:46] *** Kaiepi joined
[17:47] <Xliff> atroxaper: Thanks! What was the problem?

[17:49] <Xliff> OK, I see. Still... isn't it LTA to have to create a sub and "use soft"?

[17:49] <atroxaper> Xliff: actually, I don't know. They said, that wrap is mostly untested part of Rakudo... Probably, GC clears the anon sub.

[17:50] <Xliff> OK. Thanks. Now to see if your solution works in the larger piece of code. Thanks!

[17:51] <atroxaper> Xliff: you do not have to use 'use soft'. It was my mistake.

[17:51] <atroxaper> Xliff: You're welcome :)

[17:51] <Xliff> One other thing... using it in a sub like this means I lose access to the Method object. 

[17:51] <Xliff> Any ideas on how to get that into the sub?

[17:51] <Xliff> So I need access to \m in foo

[17:52] <Xliff> Hummm.... maybe...

[17:53] <Xliff> nextcallee?!?

[17:53] <Xliff> I finally found a use for that! LOL!

[17:55] <atroxaper> Xliff: Oh! Great find :)

[17:59] <guifa> lucs: the reason for calling them distributions is that a distribution can (and often does) contain multiple modules

[18:00] <Xliff> *sigh* -- still breaks in orignial code with "Cannot invoke object with invocation handler in this context"

[18:09] *** natrys joined
[18:35] <[Coke]> .seen codesections 

[18:35] <tellable6> [Coke], I saw codesections 2021-01-10T19:50:55Z in #raku: <codesections> will do :)

[18:37] *** dazage joined
[18:39] *** dazage left
[18:40] <atroxaper> Xliff: Probably this will lead to the right thoughts. Maybe you do not need an access to the method in foo. https://gist.github.com/gfldex/22f9133dbdb83c21c8e4

[18:40] <atroxaper> Xliff: https://perl6advent.wordpress.com/2015/12/13/a-new-trait-for-old-methods/

[18:42] <lucs> guifa: Aha, makese sense. Thanks.

[18:42] <tony-o> 2.

[18:42] <tellable6> 2021-01-12T00:06:19Z #raku <melezhik> tony-o please take a look at this - https://github.com/tony-o/raku-fez/pull/15 , thanks

[18:42] <tellable6> 2021-01-12T00:30:15Z #raku <melezhik> tony-o I've added integration test for `fez meta`

[18:42] <tellable6> 2021-01-12T00:31:24Z #raku <melezhik> tony-o maybe I should push all the tests to fez repo? i don't know ...

[18:42] <tellable6> 2021-01-12T03:26:40Z #raku <melezhik> tony-o I put fez-test sparky configuration - https://github.com/melezhik/sparky-playground/tree/main/fez-test so far ... cc tib

[18:43] <tony-o> .tell melezhik you're welcome to push tests. #15 is merged

[18:43] <tellable6> tony-o, I'll pass your message to melezhik

[18:44] *** cpan-raku left
[18:46] <[Coke]> did the behavior of chdir in rakudo change in the past few months?

[18:47] <[Coke]> based on behavior of a raku/doc xt/ test, it looks like it might have previously been lexically scoped?

[18:49] <Geth> ¦ doc: coke self-assigned xt/check-signatures.t skips all tests https://github.com/Raku/doc/issues/3765

[18:50] <Geth> ¦ doc: 7e96ae04e5 | Coke++ | xt/check-signatures.t

[18:50] <Geth> ¦ doc: Look for doc files in doc folder

[18:50] <Geth> ¦ doc: 

[18:50] <Geth> ¦ doc: Without this fix, recent rakudos were looking in the RAKUDO_SRC dir (post chdir)

[18:50] <Geth> ¦ doc: 

[18:50] <Geth> ¦ doc: Fixes #3765

[18:50] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/7e96ae04e5

[18:50] <linkable6> DOC#3765 [closed]: https://github.com/Raku/doc/issues/3765 [docs] xt/check-signatures.t skips all tests

[18:51] *** jmerelo left
[18:52] <atroxaper> Am I right that wrap method do not change the Signature? What if I want to change it any way? Is it possible?

[18:55] <[Coke]> codesections: fixed #3765; now left with a single failure running the signature test.

[18:56] *** domidumont left
[18:56] *** natrys left
[18:57] *** notagoodidea joined
[18:59] <guifa> atroxaper: yes and no.   wrap can wrap with any new signature, but it’s possible the compiler will be overly strict at compile time and think it impossible

[19:00] <guifa> So if the original sub has both slurpies on it, you can do anything you want.  If the original only takes a single positional,  you’ll probably be unfortunately stuck with the single positional (but named arguments should genreally work)

[19:00] <atroxaper> guifa: It fails in runtime, actually.

[19:00] <guifa> odd, when I get issuse with it, it’s always compile time

[19:01] <Geth> ¦ doc: coke assigned to codesections Issue check-signature test cannot find some method definitions. https://github.com/Raku/doc/issues/3780

[19:01] <guifa> m: sub foo($a) { say $a }; &foo.wrap: -> $a, $b { samewith $a }; foo 1, 2;

[19:01] <camelia> rakudo-moar 12b49b834: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Calling foo(Int, Int) will never work with declared signature ($a)␤at <tmp>:1␤------> 3; &foo.wrap: -> $a, $b { samewith $a }; 7⏏5foo 1, 2;␤»

[19:02] *** sortiz joined
[19:02] <atroxaper> guifa: Oh... Apparently, I was wrong.

[19:07] <atroxaper> guifa: I just thinking for fun... Could I implement something similar as Python's decorators. They take a sub and return a 'wrapped' sub to original name.

[19:07] *** cpan-raku joined
[19:07] *** cpan-raku left
[19:07] *** cpan-raku joined
[19:10] *** natrys joined
[19:15] <guifa> I’m not familiar enough with Python to know the difference between that and wrapping.  Wrapping has global effect, so you could write a sub that takes another one as an argument, and in turn wraps it.

[19:15] <guifa> m: sub foo { say "hi" }; sub wrap-me(&f) { &f.wrap: sub { callsame; say "bye" } }; foo; say "---"; wrap-me &foo; foo;

[19:15] <camelia> rakudo-moar 12b49b834: OUTPUT: «hi␤---␤hi␤bye␤»

[19:18] <guifa> If you want to return a sub while preserving the original, you don’t need to use wrap, just return a code block of some sort: 

[19:18] <guifa> sub foo { say "hi" }; sub wrap-me(&f) { sub {f; say "bye"} }; foo; say "---"; my &bar = wrap-me &foo; bar

[19:18] <evalable6> guifa, rakudo-moar 12b49b834: OUTPUT: «hi␤---␤hi␤bye␤»

[19:20] <atroxaper> guifa: Yes, I know that. Thank you for examples :)

[19:22] <notagoodidea> is it a sane way to loop around elements of hash containing arrays containg hashes etc for which I don't know the depth?

[19:22] <notagoodidea> it's coming from a JSON. The keys of the hash are the same at differents depth.

[19:30] *** Altai-man joined
[19:31] <Geth> ¦ ecosystem: 4de08385a4 | (David Warring)++ | META.list

[19:31] <Geth> ¦ ecosystem: move remaining modules from the pdf-raku project to CPAN

[19:31] <Geth> ¦ ecosystem: review: https://github.com/Raku/ecosystem/commit/4de08385a4

[19:32] *** sena_kun left
[19:34] <guifa> notagoodidea: sure, depending on the exact structure you can go about it different ways

[19:35] <guifa> my @a = 1, 2, [1,2,3]; for @a -> $b { .say for $b<> }

[19:35] <evalable6> guifa, rakudo-moar 12b49b834: OUTPUT: «1␤2␤1␤2␤3␤»

[19:36] <notagoodidea> the structure could be now at runtime by testing a bit.

[19:38] <notagoodidea> The two elements that I know : I need to follow the key `inner` to go deeper in the structure, and at the last level of depth I will find a key `name`. 

[19:39] <notagoodidea> Each time the `inner` key contains an array that contains the next hash.

[19:39] <notagoodidea> mm I could use loop or until ..

[19:39] *** BenGoldberg left
[19:39] *** Ben_Goldberg joined
[19:39] *** Ben_Goldberg is now known as BenGoldberg

[19:43] *** atroxaper left
[19:48] *** ufobat left
[19:48] *** b2gills1 joined
[19:48] *** b2gills left
[19:53] *** PimDaniel joined
[19:54] <PimDaniel> hi, this is me again.

[19:56] <PimDaniel> I'm reading https://docs.raku.org/language/packages and https://docs.raku.org/language/modules and https://docs.raku.org/language/modules-packages.

[19:57] *** wamba left
[19:57] <PimDaniel> and i do not understand the relationship between package and modules. Probably the language does not bind my brain!

[19:58] <PimDaniel> I mean "English language".

[19:58] <guifa> A package is just a way to collect variables/subroutines/etc.  Classes are also packages, for instance.  

[19:59] *** tejr left
[20:00] <PimDaniel> @guifa thank you! So what is a module?

[20:01] <guifa> A module is type of package specially designed for importing symbols (variables, subroutines, settings, etc) into code

[20:04] <PimDaniel> @guifa : Merci! Physically, suppose i want to write a Module... is it the same than in perl5?

[20:04] <PimDaniel> What is the file extension i should use?

[20:05] <PimDaniel> I do not see this in the documentation.

[20:05] <PimDaniel> hooo : Chapter "Modules on disk" : Sorry! :(

[20:09] *** tejr joined
[20:09] * guifa is afk for a bit

[20:10] *** Black_Ribbon joined
[20:11] <PimDaniel> Does unit means namespace?

[20:13] <PimDaniel> No No : sorry! 

[20:21] <PimDaniel> @guifa : Ok : i see clearly now: thank you very mutch!

[20:26] *** JRaspass left
[20:26] *** JRaspass joined
[20:26] *** PimDaniel left
[20:27] *** JRaspass left
[20:27] *** JRaspass joined
[20:32] *** sjm_uk left
[20:42] <[Coke]> "unit" is how you declare the thing. so "unit module blah;" is the first line of a file, the entire file is the module blah. otherwise you need to use {} for scoping with the module/class/whatever.

[20:43] <[Coke]> file extensions: .raku for programs, .rakumod for modules

[20:43] <[Coke]> Hope this helps.

[20:44] <[Coke]> that feeling of ... not-quite-dread about an upcoming meeting... that is suddenly pushed out a day. ahhhh.

[20:48] *** natrys left
[20:48] *** mowcat joined
[21:01] *** Ben_Goldberg joined
[21:01] *** BenGoldberg left
[21:01] *** Ben_Goldberg is now known as BenGoldberg

[21:02] *** rindolf left
[21:02] *** Ben_Goldberg joined
[21:02] *** BenGoldberg left
[21:02] *** Ben_Goldberg is now known as BenGoldberg

[21:07] *** Ben_Goldberg joined
[21:07] *** BenGoldberg left
[21:07] *** Ben_Goldberg is now known as BenGoldberg

[21:20] *** BenGoldberg left
[21:20] *** Ben_Goldberg joined
[21:20] *** Ben_Goldberg is now known as BenGoldberg

[21:33] *** BenGoldberg left
[21:33] *** Ben_Goldberg joined
[21:33] *** Ben_Goldberg is now known as BenGoldberg

[21:35] <no-n> does unit just mean the rest of this file belongs to this package?

[21:36] <timotimo> less "the rest", more "the entirity" IMO

[21:36] <no-n> ahh

[21:40] *** Altai-man left
[21:42] *** MasterDuke joined
[21:42] *** sena_kun joined
[21:43] <[Coke]> m: say "hi"; unit package bar;

[21:43] <camelia> rakudo-moar 12b49b834: OUTPUT: «hi␤»

[21:43] <[Coke]> ... I'm surprised that doesnt' error. :)

[21:44] *** PimDaniel joined
[21:44] *** PimDaniel left
[21:48] *** sena_kun left
[21:50] *** benjif joined
[21:53] *** BenGoldberg left
[21:53] *** Ben_Goldberg joined
[21:54] *** Ben_Goldberg is now known as BenGoldberg

[21:55] <jdv79> BenGoldberg: everything alright?

[21:58] *** BenGoldberg left
[21:58] *** Ben_Goldberg joined
[21:59] *** Ben_Goldberg is now known as BenGoldberg

[22:00] *** stoned75 left
[22:02] <timotimo> stuff that doesn't define anything should in general be fine i'd imagine

[22:07] *** simcop2387 joined
[22:15] <guifa> [Coke]: you need to put stuff above the unit declaration in case you have to, e.g. parameterize a class or pass something into a trait, so it makes sense to allow code above the declaration

[22:16] *** BenGoldberg left
[22:16] *** Ben_Goldberg joined
[22:17] *** Ben_Goldberg is now known as BenGoldberg

[22:21] <[Coke]> guifa++

[22:24] *** notagoodidea left
[22:25] <[Coke]> m: say Mixy.^methods

[22:25] <camelia> rakudo-moar 12b49b834: OUTPUT: «(of new-from-pairs)␤»

[22:25] <[Coke]> docs say that Mixy provides total & roll, but it doesn't.

[22:26] *** BenGoldberg left
[22:26] *** Ben_Goldberg joined
[22:26] *** Ben_Goldberg is now known as BenGoldberg

[22:26] <[Coke]> (doesn't provide *total*)

[22:26] <guifa> [Coke]: it definitely does though: https://github.com/rakudo/rakudo/blob/master/src/core.c/Mixy.pm6

[22:27] <guifa> at least, roll is there

[22:29] <[Coke]> wasn't clear: docs say both, but total isn't there.

[22:30] <[Coke]> total appears to be in Mix, not Mixy.

[22:32] *** brtastic left
[22:33] <[Coke]> (wow, that method was docced back when the doc files were in lib/)

[22:38] <Geth> ¦ doc: 7bac622b20 | Coke++ | 2 files

[22:38] <Geth> ¦ doc: Move total method to Mix from Mixy

[22:38] <Geth> ¦ doc: 

[22:38] <Geth> ¦ doc: xt/check-signatures.t found this, presented as a SKIP'd test.

[22:38] <Geth> ¦ doc: 

[22:38] <Geth> ¦ doc: Investigation showed the method was defined in the wrong spot,

[22:38] <Geth> ¦ doc: and when moved, that the signature needed a slight update.

[22:38] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/7bac622b20

[22:40] *** benjif left
[22:41] *** aluaces left
[22:54] *** melezhik joined
[22:58] <kawaii> Is there any module or operator I can use to compare strings and return which ones 'kinda' match? Like how spellcheck presumably works in word processing applications?

[23:00] <guifa> kawaii: there are a few different algorithms for calculating the difference between strings

[23:00] <moon-child> kawaii: try one of these maybe https://modules.raku.org/search/?q=levenshtein

[23:00] <guifa> There are a few different modules for that 

[23:00] <guifa> I’d then make an operator for it

[23:00] <kawaii> Ah, nice, thanks very much guys :)

[23:02] <guifa> sub infix:<kinda-eq> ($a, $b, :$similarity-factor) { my $distance = distance-function-of-your-choice $a, $b;  {formula to convert distance to similarity} > $similarity-factor }

[23:03] <guifa> If you need it in a regex …

[23:03] <guifa> https://github.com/alabamenhu/RegexFuzzyToken

[23:13] *** bdju left
[23:14] *** bdju joined
[23:15] <MasterDuke> https://github.com/MasterDuke17/Text-Diff-Sift4 another alternative. i haven't benchmarked it against the levenshtein modules recently, but it used to be quite a bit faster, although not giving identical results

[23:15] *** bdju left
[23:16] <kawaii> MasterDuke: thank you! I will evaluate its fitness for my project also :)

[23:19] *** bdju joined
[23:23] <JRaspass> if you write your own, feel free to compete on https://code.golf/levenshtein-distance#raku ;-)

[23:33] <kawaii> MasterDuke; am I perhaps going about this the wrong way? I'm basically writing a bot where a user will enter a command like `!team <name>` and it will return some info on that member, but of course users shouldn't be expected to know the exact string and capitalisation required so I wanted to do something like this to try and help them out. https://www.irccloud.com/pastebin/F2l2F7lw/

[23:34] <kawaii> But it seems as though some of my keys are too similar to make an informed decision based on the results.

[23:34] <kawaii> Perhaps there is a better way?

[23:37] <guifa> hmm, let’s see how it would work with Joccard Index

[23:38] *** melezhik left
[23:42] <guifa> kawaii: try this one: https://bit.ly/39rUJuP 

[23:43] <guifa> It’s not as fast, but it sounds like speed isn’t your concern here — when I ignore case, the two Toms are tied for top place.

[23:44] <kawaii> Aha this is more or less exactly what I wanted

[23:45] <kawaii> guifa: thank you for your help this evening, I really appreciate it

[23:46] <kawaii> You're right, searching for 'tom' does indeed tie both of them, and 'tomm' correctly prefers Tomm M

[23:47] <kawaii> Luckily, @results is an ordered array, so I can simply choose the first in my edge case and present the user with Tom K

[23:49] <guifa> Yup.  Or do other things like evaluate based on the scores — I think anything over .33 is a reasonable enough match, and so you could present them with an option for those matches, and possible average values over running it with and without matching marks, whitespace, or capitalization (that’s what those &i, &m, &ws functions were for)

[23:49] *** pecastro left
[23:49] <Xliff> .tell jnthn Is there any way to introspect the symbol table of a template during render()?

[23:50] <tellable6> Xliff, I'll pass your message to jnthn

[23:50] <kawaii> guifa: many thanks again for your help :)

