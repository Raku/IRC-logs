[00:01] *** JRaspass left
[00:03] *** sena_kun joined
[00:05] *** Altai-man_ left
[00:14] *** guifa2 left
[00:16] *** hungrydonkey joined
[00:19] *** Voldenet left
[00:20] *** Voldenet joined
[00:20] *** Voldenet left
[00:20] *** Voldenet joined
[00:20] *** stoned75 left
[00:22] *** stoned75 joined
[00:29] *** xinming left
[00:30] *** xinming joined
[00:44] *** hungrydonkey left
[00:56] *** dataangel left
[01:00] *** aborazmeh joined
[01:00] *** aborazmeh left
[01:00] *** aborazmeh joined
[01:22] *** a3r0_ is now known as a3r0

[01:23] *** JRaspass joined
[01:32] <codesections> is this the correct/preferred way to create a list from two lists?

[01:32] <codesections> m: |(1, 2), |(3, 4)

[01:32] <camelia> rakudo-moar a74550507: ( no output )

[01:32] <codesections> or is there a better way?  That looks off to me, somehow

[01:33] <codesections> m: say |(1, 2), |(3, 4)

[01:33] <camelia> rakudo-moar a74550507: OUTPUT: ¬´1234‚ê§¬ª

[01:41] <timotimo> m: say (flat (1, 2), (3, 4)).raku

[01:41] <camelia> rakudo-moar a74550507: OUTPUT: ¬´(1, 2, 3, 4).Seq‚ê§¬ª

[01:41] <timotimo> when there's two lists inside of an array, the array will be holding the lists in scalar containers, which means "don't flatten me"

[01:41] <timotimo> gnite!

[01:42] <codesections> thanks! I was about to ask if that's better.  It's fewer terms but more characters.

[01:54] *** molaf left
[01:56] *** guifa2 joined
[02:02] *** Altai-man_ joined
[02:03] *** guifa2 left
[02:04] *** sena_kun left
[02:05] *** Manifest0 left
[02:05] *** Manifest0 joined
[02:06] *** molaf joined
[02:08] *** aborazmeh left
[02:18] *** wamba joined
[02:19] <cpan-raku> New module released to CPAN! LibXML (0.5.5) by 03WARRINGD

[02:36] *** guifa2 joined
[02:43] *** wamba left
[02:43] *** AlexDaniel left
[02:44] *** AlexDaniel joined
[02:45] *** xinming left
[02:45] *** AlexDaniel left
[02:45] *** AlexDaniel joined
[02:46] *** xinming joined
[02:55] *** MasterDuke left
[03:03] *** El_Che left
[03:04] *** El_Che joined
[03:07] *** guifa2 left
[03:11] *** guifa2 joined
[03:15] *** epony left
[03:16] *** eponym joined
[03:26] *** vike1 joined
[03:27] *** vike left
[03:29] *** Kaiepi joined
[03:34] *** vike1 left
[03:37] *** rbt left
[03:37] *** rbt joined
[03:49] *** eponym left
[03:50] *** epony joined
[03:57] <holyghost> I just started my evolutionary computation, introductory book, I'll make a genetic algorithm package (on github) with it

[03:57] <holyghost> I extended one in C++ in 2001

[03:58] <holyghost> it needs to be useful for optimization and constraint problems

[03:59] <holyghost> Also, I have to watch out for polynomial time, so I have to very clear that the code is somewhat auto-optimezed in surplus

[03:59] <holyghost> *optimized

[04:00] *** guifa2 left
[04:00] <holyghost> I am going to do all that during summer vacation

[04:01] <holyghost> I can write one out of the top of my head, but reading an extra book should'nt hurt

[04:01] <holyghost> I did genetic algorithms for my Master CS thesis

[04:03] *** sena_kun joined
[04:05] *** Altai-man_ left
[04:13] *** melezhik joined
[04:15] *** xinming left
[04:16] *** xinming joined
[04:18] *** melezhik left
[04:38] *** aluaces joined
[04:40] *** JRaspass left
[04:59] *** rindolf joined
[05:01] *** nebuchadnezzar joined
[05:07] *** molaf left
[05:10] *** OpenZen left
[05:16] *** sarna joined
[05:24] *** vike1 joined
[05:26] *** bocaneri joined
[05:36] *** antoniogamiz joined
[05:37] <antoniogamiz> timotimo, have you seen https://github.com/timo/json_fast/pull/68?

[05:45] *** antoniogamiz left
[05:45] *** antoniogamiz joined
[06:02] *** Altai-man_ joined
[06:04] *** sena_kun left
[06:42] *** epony left
[06:43] *** epony joined
[06:46] <antoniogamiz> which test statement do you use to compare (equality) of two objects of the same class?

[07:01] *** antoniogamiz left
[07:02] *** dolmen joined
[07:06] <timotimo> usually eqv does what you want

[07:12] *** pecastro joined
[07:13] *** sarna left
[07:32] <Altai-man_> releasable6, status

[07:32] <releasable6> Altai-man_, Next release in ‚âà11 days and ‚âà11 hours. There are no known blockers. Changelog for this release was not started yet

[07:32] <releasable6> Altai-man_, Details: https://gist.github.com/b3cb8c7c340fda4e22ba4cdf38353e55

[07:35] *** dakkar joined
[07:42] *** JJMerelo joined
[07:43] <JJMerelo> Hi, here's the search report for raku.org the past June https://drive.google.com/file/d/1cKWIVe8B7c6Da6owT9K9nmnux-iCaDJB/view?usp=sharing

[07:44] <JJMerelo> I really have no idea what's the deal with https://raku.org/archive/rfc/102.html

[07:45] <JJMerelo> There's a link to www.perl6.org, which is redirected, but maybe that link should be included in the red-background note.

[07:45] *** squashable6 left
[07:45] *** squashable6 joined
[07:46] <JJMerelo> BTW, this RFC https://raku.org/archive/rfc/1.html will be 20 years old in 3 weeks.

[07:46] <JJMerelo> Are we planning any celebration?

[07:50] <JJMerelo> Equivalent for docs.raku.org https://drive.google.com/file/d/1s8J447eHl_YOqbs4giR9c6z_M7IyJu1g/view?usp=sharing Arrays are popular! (and findable)

[07:50] <JJMerelo> releasable6: status

[07:50] <releasable6> JJMerelo, Next release in ‚âà11 days and ‚âà11 hours. There are no known blockers. Changelog for this release was not started yet

[07:50] <releasable6> JJMerelo, Details: https://gist.github.com/cbd6c71b3efb2c658320ed6822f707c2

[08:03] *** sena_kun joined
[08:04] *** telex left
[08:05] *** Altai-man_ left
[08:06] *** telex joined
[08:09] *** eseyman left
[08:10] *** eseyman joined
[08:25] *** leont joined
[08:42] *** xinming left
[08:43] *** xinming joined
[08:58] *** antoniogamiz joined
[09:02] * lizmat clickbaits https://rakudoweekly.blog/2020/07/06/2020-27-advanced-beginning/

[09:03] *** oddp joined
[09:05] *** Black_Ribbon left
[09:07] *** Manifest0 left
[09:08] *** Manifest0 joined
[09:09] *** cpan-raku left
[09:10] *** cpan-raku joined
[09:10] *** cpan-raku left
[09:10] *** cpan-raku joined
[09:14] *** AlexDaniel left
[09:14] *** AlexDaniel joined
[09:16] *** AlexDani` joined
[09:19] *** AlexDaniel left
[09:19] *** hungrydonkey joined
[09:21] <moritz> lizmat++

[09:22] <moritz> awesome weekly, and I appreicate how much work it must have been to assemble all that stuff

[09:22] <lizmat> thank you

[09:23] *** JJMerelo left
[09:27] *** Xliff joined
[09:29] <lizmat> AlexDaniel` https://gist.github.com/lizmat/ab20653dfb09856707a45b1575768d31   # minimal attempt

[09:30] <lizmat> and it turns out that even something like this:

[09:30] <lizmat> my $l = ^10 .map: * * 2; say $l.AT-POS(1); say $l.AT-POS(0); say $l.^name

[09:30] <evalable6> lizmat, rakudo-moar a74550507: OUTPUT: ¬´2‚ê§0‚ê§Seq‚ê§¬ª

[09:30] *** aborazmeh joined
[09:30] *** aborazmeh left
[09:30] *** aborazmeh joined
[09:31] <lizmat> does *not* die.  I have no idea why the new AT-POS isn't being called, suspect something deep in the bowels

[09:31] <lizmat> and thus stops my attempt

[09:38] <[ptc]> lizmat++ re: weekly

[09:43] *** JJMerelo joined
[09:45] <AlexDani`> lizmat: O_O

[09:45] *** AlexDani` is now known as AlexDaniel

[09:45] *** AlexDaniel left
[09:45] *** AlexDaniel joined
[09:47] *** xinming left
[09:48] <AlexDaniel> lizmat: ah, because of this I guess? https://github.com/rakudo/rakudo/blob/a745505071749f59df23b87c28bcdf232502a995/src/core.c/Sequence.pm6#L60-L66

[09:49] *** xinming joined
[09:49] <lizmat> no, because the AT-POS in Seq should shadow that ?

[09:50] <AlexDaniel> should it? You provided just the `int` candidate. Also, what's ::?CLASS:D: ?

[09:51] <lizmat> the proto should mask all other candidates

[09:51] <AlexDaniel> protos can mask candidates?

[09:51] <AlexDaniel> I didn't know that

[09:53] <lizmat> m: role A { multi method a(Int:D $a) { "Int" } }; class B does A { }; say B.a(42)

[09:53] <camelia> rakudo-moar a74550507: OUTPUT: ¬´Int‚ê§¬ª

[09:53] <lizmat> m: role A { multi method a(Int:D $a) { "Int" } }; class B does A { proto method a(|) { } }; say B.a(42)

[09:53] <camelia> rakudo-moar a74550507: OUTPUT: ¬´Nil‚ê§¬ª

[09:54] <AlexDaniel> lizmat: okay, but it's not that

[09:54] <AlexDaniel> m: role Bar { multi method blah(::?CLASS:D: Int:D $idx) is raw { note ‚ÄúBar Int $idx‚Äù }; multi method blah(::?CLASS:D: int $idx) is raw { note ‚ÄúBar int $idx‚Äù }; }; class Foo does Bar { proto method blah(|) {*} }; Foo.new.blah(42)

[09:54] <camelia> rakudo-moar a74550507: OUTPUT: ¬´Bar Int 42‚ê§¬ª

[09:54] <AlexDaniel> lizmat: ‚Üë

[09:54] <AlexDaniel> so ::?CLASS:D: thing will make it end up in the class, or something?

[09:54] <AlexDaniel> that is, where the proto is

[09:55] <AlexDaniel> hmm no‚Ä¶

[09:55] <AlexDaniel> m: role Bar { multi method blah(Int:D $idx) is raw { note ‚ÄúBar Int $idx‚Äù }; multi method blah(int $idx) is raw { note ‚ÄúBar int $idx‚Äù }; }; class Foo does Bar { proto method blah(|) {*} }; Foo.new.blah(42)

[09:55] <camelia> rakudo-moar a74550507: OUTPUT: ¬´Bar Int 42‚ê§¬ª

[09:56] <AlexDaniel> m: role Bar { multi method blah(Int:D $idx) { note ‚ÄúBar Int $idx‚Äù }; multi method blah(int $idx) { note ‚ÄúBar int $idx‚Äù }; }; class Foo does Bar { proto method blah(|) {*} }; Foo.new.blah(42)

[09:56] <camelia> rakudo-moar a74550507: OUTPUT: ¬´Bar Int 42‚ê§¬ª

[09:56] <AlexDaniel> am I doing something completely wrong?

[09:56] <lizmat> you mean it not selecting the int candidate ?

[09:57] <AlexDaniel> AH

[09:57] <AlexDaniel> I see

[09:57] <AlexDaniel> m: role A { multi method a(Int:D $a) { "Int" } }; class B does A { proto method a(|) {*} }; say B.a(42)

[09:57] <camelia> rakudo-moar a74550507: OUTPUT: ¬´Int‚ê§¬ª

[09:57] <AlexDaniel> lizmat: this is your example

[09:57] <AlexDaniel> all I did is changed {} to {*}

[09:58] <AlexDaniel> so a proto with {*} doesn't shadow but the one with {} does?

[09:58] *** guifa2 joined
[09:58] <dakkar> AFIK `{*}` means "delegate to the matching multi candidate"

[09:59] <lizmat> hmmm....  either should shadow 

[09:59] <dakkar> m: role A { multi method a(Int:D $a) { "Int" } }; class B does A { proto method a(|) { say "in B";{*}; say "leaving B" }; say B.a(42)

[09:59] <camelia> rakudo-moar a74550507: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> 3n B";{*}; say "leaving B" }; say B.a(42)7‚èè5<EOL>‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        stat‚Ä¶¬ª

[09:59] <dakkar> m: role A { multi method a(Int:D $a) { "Int" } }; class B does A { proto method a(|) { say "in B";{*}; say "leaving B" }}; say B.a(42)

[09:59] <camelia> rakudo-moar a74550507: OUTPUT: ¬´in B‚ê§leaving B‚ê§True‚ê§¬ª

[09:59] <AlexDaniel> lizmat: either way it's {*} in Sequence.pm6 so that's why

[10:01] <AlexDaniel> dakkar: oooooh

[10:01] <AlexDaniel> so protos can have bodies

[10:01] <dakkar> yes

[10:01] <dakkar> nice way to factor out behaviours

[10:01] <AlexDaniel> dakkar: I wouldn't necessarily call it nice but it is potentially useful indeed

[10:02] <dakkar> I think there can be at most 1 proto for each multi, though; you need `.wrap` for more complicated cases

[10:02] *** Altai-man_ joined
[10:02] <AlexDaniel> lizmat: ah, it's other way around, in your patch it should be {} if you want it to shadow

[10:03] <lizmat> yeah, but then it won't dispatch

[10:03] <AlexDaniel> it is documented beautifully btw https://docs.raku.org/syntax/proto

[10:03] <lizmat> and if I make the Seq.AT-POS an only method, it won't even build

[10:04] <AlexDaniel> lizmat: you can put the code right into the proto x)

[10:05] *** sena_kun left
[10:06] <AlexDaniel> lizmat: or, actually, just add the right candidate

[10:06] <AlexDaniel> the candidate itself will shadow the existing one

[10:06] <AlexDaniel> it's just that `int` one doesn't do much for `Int`

[10:07] <lizmat> go ahead!

[10:16] *** markoong joined
[10:19] *** markoong is now known as kongmar

[10:19] *** kongmar is now known as margeas

[10:20] *** margeas is now known as markoong

[10:20] *** markoong left
[10:21] *** markoong joined
[10:21] *** markoong left
[10:22] *** markoong joined
[10:28] *** aborazmeh left
[10:33] *** xinming left
[10:34] *** xinming joined
[10:39] *** antoniogamiz left
[10:40] *** guifa2 left
[10:42] *** guifa2 joined
[10:50] <AlexDaniel> lizmat: now things behave in the weirdest way possible

[10:50] <AlexDaniel> c: remove-Seq-nonsense my $s = <a b c>.words; say $s[0]; say $s[0]; say $s[0]

[10:50] <committable6> AlexDaniel, ¬¶remove-Seq-nonsense: ¬´Cannot find this revision (did you mean ‚Äúcar-grant-unreduce‚Äù?)¬ª

[10:51] <AlexDaniel> hmmmm

[10:51] <lizmat> AlexDaniel: what I said, the caching behaviour is *deeply* ingrained in the system

[10:51] <AlexDaniel> it's not the caching, hold on‚Ä¶

[10:51] <lizmat> well, expect weird erroring :-)

[10:51] <AlexDaniel> c: remove-Seq-nonsense my $s = <a b c>.words; say $s[0]; say $s[0]; say $s[0]

[10:51] <committable6> AlexDaniel, ¬¶remove-Seq-nonsense: ¬´Cannot test this commit (Commit exists, but an executable could not be built for it)¬ª

[10:52] <AlexDaniel> c: c9a4f07de2dbe7 my $s = <a b c>.words; say $s[0]; say $s[0]; say $s[0]

[10:52] <committable6> AlexDaniel, ¬¶c9a4f07: ¬´Cannot test this commit (Commit exists, but an executable could not be built for it)¬ª

[10:52] <AlexDaniel> no no it builds

[10:52] <AlexDaniel> anyway the output of that is a‚ê§b‚ê§c‚ê§

[10:52] *** xinming left
[10:53] <lizmat> if you're not caching, it should have died on the second $s[0]

[10:53] <AlexDaniel> and if you print [1] then that's Nil

[10:54] *** xinming joined
[11:00] <AlexDaniel> ooooh

[11:01] <AlexDaniel> it can build but it cannot install!

[11:01] <AlexDaniel> that's why committable6 is confused

[11:01] <lizmat> welcome to the nightmare  :-)

[11:02] <AlexDaniel> lizmat: it actually looks pretty easy

[11:02] <AlexDaniel> No such method 'skip' for invocant of type 'Rakudo::Iterator::OneValue'.  Did you mean any of these: 'Slip',

[11:02] <AlexDaniel> so OneValue doesn't have .skip, which AT-POS is currently using

[11:02] <lizmat> [00:02:46]  <lizmat>	I sorta half expect it will build, but that installing the core modules *will* fail

[11:02] <AlexDaniel> it's not so much about the change but about calling .skip on iterators

[11:03] <lizmat> OneValue does Iterator, which has a .skip method

[11:03] <lizmat> it's even a PredictiveIterator

[11:04] <lizmat> m: dd Rakudo::Iterator.OneValue(42).skip

[11:04] <camelia> rakudo-moar a74550507: OUTPUT: ¬´No such method 'skip' for invocant of type‚ê§'Rakudo::Iterator::OneValue'.  Did you mean any of these: 'Slip',‚ê§'skip'?‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[11:04] <lizmat> this is weird

[11:04] <lizmat> ah, the method is called "skip-one"

[11:04] <lizmat> it's confusing the Seq with the underlying iterator

[11:05] <lizmat> m: dd Rakudo::Iterator.OneValue(42).skip-one

[11:05] <camelia> rakudo-moar a74550507: OUTPUT: ¬´0‚ê§¬ª

[11:05] <AlexDaniel> that's ok, I'll tweak it real quick

[11:23] <cpan-raku> New module released to CPAN! XML::Actions (0.4.6.1) by 03MARTIMM

[11:26] *** guifa2 left
[11:27] *** guifa2 joined
[11:29] <AlexDaniel> lizmat: ok. Now it builds, installs and works

[11:29] <AlexDaniel> will wait a bit for committable to catch up to show it

[11:35] *** sarna joined
[11:41] *** rbt left
[11:42] *** rbt joined
[11:42] <AlexDaniel> c: remove-Seq-nonsense my $s = <a b c>.words; say $s[0]; say $s[0]; say $s[0]

[11:42] <committable6> AlexDaniel, ¬¶remove-Seq-nonsense: ¬´a‚ê§asked 0, which was already produced‚ê§‚ê§ ¬´exit code = 1¬ª¬ª

[11:42] <AlexDaniel> c: remove-Seq-nonsense my $s = <a b c>.words; say $s[0]; say $s[1]; say $s[2]

[11:42] <committable6> AlexDaniel, ¬¶remove-Seq-nonsense: ¬´a‚ê§b‚ê§c‚ê§¬ª

[11:42] <AlexDaniel> c: remove-Seq-nonsense my $s = <a b c>.words; say $s[0]; say $s[1]; dd $s

[11:42] <committable6> AlexDaniel, ¬¶remove-Seq-nonsense: ¬´a‚ê§Seq $s = $(("c",).Seq)‚ê§b‚ê§¬ª

[11:42] <AlexDaniel> c: remove-Seq-nonsense my $s = <a b c>.words; say $s[0]; say $s[1]; say $s

[11:42] <committable6> AlexDaniel, ¬¶remove-Seq-nonsense: ¬´a‚ê§b‚ê§(c)‚ê§¬ª

[11:42] <AlexDaniel> so that works

[11:53] <masak> ahoy, #raku

[11:54] <AlexDaniel> hey

[11:54] *** xinming left
[11:55] *** xinming joined
[12:03] *** sena_kun joined
[12:05] *** rindolf left
[12:05] *** Altai-man_ left
[12:07] *** JJMerelo left
[12:08] <moritz> \o masak, long time no see!

[12:12] *** xinming left
[12:13] *** xinming joined
[12:22] *** rindolf joined
[12:23] *** xinming left
[12:29] *** vike1 left
[12:30] *** xinming joined
[12:37] *** vike joined
[12:40] *** xinming left
[12:41] *** xinming joined
[12:47] <tadzik> masak: \o/

[12:50] <masak> \o/

[12:51] <masak> moritz: indeed. I'll try to appear more often

[12:52] <masak> I'm a bit time-zone-challenged, but that's not really an excuse

[12:52] *** xinming left
[12:53] *** xinming joined
[13:21] *** sarna left
[13:22] *** RaycatWhoDat joined
[13:34] <tadzik> everything can be a morning when you're on IRC :)

[13:35] *** stoned75 left
[13:36] *** stoned75 joined
[13:38] <RaycatWhoDat> put that on a mug

[13:38] <RaycatWhoDat> I'd buy it

[13:39] <[Coke]> guten tag, masak!

[14:00] *** titsuki joined
[14:02] *** Altai-man_ joined
[14:05] *** sena_kun left
[14:16] <codesections> From the docs for the `==>` operator: "Note: In the future, this operator will see some change as it gains the ability to run list operations in parallel."  Based on the way my code is behaving, it appears that `==>` is currently running operations in parallel.  Is that right?

[14:17] <tadzik> congratulations, you're in the future :)

[14:18] <oddp> Example code?

[14:18] <codesections>  The future is now, as they say :D

[14:22] <moritz> our usual line is that on IRC, we leave in the "UGT" time zone ("universal greeting time"), and "It's always morning in UGT!" :-)

[14:28] <codesections> "example code?" ‚Ä¶ actually, now I'm confused.  From the docs, I previously thought these two expressions meant the same thing (with alternate syntax):

[14:28] <codesections> m:  (^1000000).map({~$_ })  

[14:28] <camelia> rakudo-moar 98c7e512a: ( no output )

[14:29] <codesections>  (^1000000) ==> map({~$_ })  

[14:29] <codesections> but, from my code, I thought they were different, in that the second was parallel (and thus would be faster)

[14:30] <codesections> but when I ran `time raku -e ` with both expressions, the first was 3√ó faster

[14:32] <codesections> "It's always morning in UGT!" I'm also a fan of "time appropriate greetings!", as they say on Linux Unplugged 

[14:35] <AlexDaniel> codesections: it's unlikely that it will ever run stuff in parallel just like that

[14:35] <codesections> Ok, good to know, thanks.  

[14:35] <codesections> So why the speed difference?

[14:36] <AlexDaniel> codesections: that's my personal opinion, official position may differ :)

[14:36] <Voldenet> m: (^20) ==> map(*.say)

[14:36] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´0‚ê§1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§11‚ê§12‚ê§13‚ê§14‚ê§15‚ê§16‚ê§17‚ê§18‚ê§19‚ê§¬ª

[14:36] *** softmoth joined
[14:37] <AlexDaniel> codesections: well, ‚Äúwhy the speed difference?‚Äù can be asked about everything. Should a method form of some operation be the same as the sub performance-wise? (e.g. .substr vs substr, stuff like that)

[14:37] <AlexDaniel> codesections: the answer is always yes, but the reality is different

[14:38] <AlexDaniel> see, rakudo was built with an idea that later the compiler will do magic and everything will become fast

[14:39] <AlexDaniel> so the result is expected, you cannot have any performance expectations besides ‚Äúpoor‚Äù :P

[14:39] <jnthn> I think Raku as a language was designed on the premise that there'd eventually be a sufficiently smart compiler :)

[14:40] <codesections> hmm, yeah, I get that.  But there's a difference between two different expressions that "should" have the same performance and two different *syntaxes* that create the same expression 

[14:41] <AlexDaniel> codesections: it's very likely you can do a bit of hackety hacking on rakudo and improve the performance of that specific case

[14:41] <codesections> and (from the docs), I thought that the feed operator and method chaining were literally two ways of writing the same thing

[14:41] <codesections> am I wrong about that?

[14:42] <jnthn> Yes.

[14:42] <jnthn> For one, the feed operator is about using subs

[14:42] *** xinming left
[14:43] <codesections> (The example in the docs says: `@array ==> sum() ==> say();   # OUTPUT: ¬´15‚ê§¬ª` is the equivalent of writing: @array.sum.say;   # OUTPUT: ¬´15‚ê§¬ª`

[14:43] *** xinming joined
[14:43] <codesections> )

[14:44] <jnthn> At least in the standard language, if you didn't redefine any of the subs involved, they'll get the same thing, but they get there by different ways.

[14:44] <tobs> equi*val*ent but not equi*how*ent

[14:44] <codesections> Interesting.

[14:48] *** softmoth left
[14:49] <AlexDaniel> jnthn: yeah, that too, and in the end the language itself is wasting resources left and right. Wanna know the number of elements in a seq? Great, it will make sure *all of the elements* are stored at the same time. If the compiler was smart enough to optimize that away it'd also be smart enough not to be a Raku compiler.

[14:53] <AlexDaniel> jnthn: speaking of the language design, do you think there's an implied contract that iterating a Seq will give all elements of that Seq?

[14:55] <AlexDaniel> that is, that you won't ever get leftovers of the SEq

[14:55] <AlexDaniel> Seq*

[14:56] <jnthn> Surely not, you could lose interest after N elements (such as .head($n)). Infinite lazy sequences will always have something unused.

[14:56] <AlexDaniel> jnthn: I'm talking about the first elements actually

[14:57] <AlexDaniel> though judging by your answer it sounds like this wasn't intentional and just happens to be that way

[14:57] <jnthn> Example?

[14:59] <AlexDaniel> c: HEAD sub here-we-get-a-seq($seq) { say ‚Äòall elements of the seq:‚Äô; .say for $seq }; my $s = <a b c>.words; say $s.head; here-we-get-a-seq $s

[14:59] <committable6> AlexDaniel, https://gist.github.com/a004045f988ba7acbe595f7aa77b8f89

[14:59] <AlexDaniel> jnthn: this behavior

[15:00] <jnthn> That output looks disordered?

[15:00] <AlexDaniel> yeah, that's ok, that's just how stderr/stdout is

[15:01] <jnthn> yeah, it is

[15:01] <AlexDaniel> c: HEAD sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; .note for $seq }; my $s = <a b c>.words; note $s.head; here-we-get-a-seq $s

[15:01] <committable6> AlexDaniel, https://gist.github.com/d4c0e4bdcb972b383efab9da9372268f

[15:01] <jnthn> Yes, it's the correct output; you've already consumed the Seq by .head obtaining the iterator from it.

[15:01] <jnthn> So the second attempt to obtain the iterator throws

[15:01] <AlexDaniel> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; .note for $seq }; my $s = <a b c>.words; note $s.head; here-we-get-a-seq $s

[15:01] <committable6> AlexDaniel, ¬¶95cadc8: ¬´a‚ê§all elements of the seq:‚ê§The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§‚ê§ ¬´exit code = 1¬ª¬ª

[15:02] <AlexDaniel> huh.

[15:03] <AlexDaniel> okay not sure I understand why that doesn't work

[15:03] <AlexDaniel> but it's good to know that it can be that way too‚Ä¶

[15:03] <AlexDaniel> okay, nevermind‚Ä¶ hmm

[15:03] <AlexDaniel> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; note $seq }; my $s = <a b c>.words; note $s.head; here-we-get-a-seq $s

[15:03] <committable6> AlexDaniel, ¬¶95cadc8: ¬´a‚ê§all elements of the seq:‚ê§The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§‚ê§ ¬´exit code = 1¬ª¬ª

[15:04] <AlexDaniel> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; note $seq[1..*] }; my $s = <a b c>.words; note $s.head; here-we-get-a-seq $s

[15:04] <committable6> AlexDaniel, ¬¶95cadc8: ¬´a‚ê§all elements of the seq:‚ê§The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§‚ê§ ¬´exit code = 1¬ª¬ª

[15:04] <AlexDaniel> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; note $seq[1] }; my $s = <a b c>.words; note $s.head; here-we-get-a-seq $s

[15:04] <committable6> AlexDaniel, ¬¶95cadc8: ¬´a‚ê§all elements of the seq:‚ê§Method 'pull-one' must be implemented by Iterator because it is required by roles: Iterator.‚ê§‚ê§ ¬´exit code = 1¬ª¬ª

[15:05] <AlexDaniel> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; note $seq[1] }; my $s = <a b c>.words; note $s[0]; here-we-get-a-seq $s

[15:05] <committable6> AlexDaniel, ¬¶95cadc8: ¬´a‚ê§all elements of the seq:‚ê§b‚ê§¬ª

[15:05] <AlexDaniel> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; .say for $seq }; my $s = <a b c>.words; note $s[0]; here-we-get-a-seq $s

[15:05] <committable6> AlexDaniel, ¬¶95cadc8: ¬´a‚ê§(b c)‚ê§all elements of the seq:‚ê§¬ª

[15:05] <AlexDaniel> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; .note for $seq }; my $s = <a b c>.words; note $s[0]; here-we-get-a-seq $s

[15:05] <committable6> AlexDaniel, ¬¶95cadc8: ¬´a‚ê§all elements of the seq:‚ê§(b c)‚ê§¬ª

[15:05] <AlexDaniel> jnthn: so you'd say this is illegal and I should call the police? :)

[15:06] <AlexDaniel> or that [] should be smart enough to mark the Seq as consumed so that nobody is able to iterate it that way later?

[15:06] <jnthn> Yes. And I'm confused how that happens, given that .cache should surely just call .iterator and find the iterator already gone...

[15:07] <Voldenet> I do wonder what‚Ä¶

[15:07] <Voldenet> m: sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; .note for $seq }; my $s = <a b c>.words; note $s[1]; here-we-get-a-seq $s

[15:07] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´b‚ê§all elements of the seq:‚ê§(a b c)‚ê§¬ª

[15:07] <Voldenet> m: sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; .note for $seq }; my $s = <a b c>.words; note $s[0]; here-we-get-a-seq $s

[15:07] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´a‚ê§all elements of the seq:‚ê§(a b c)‚ê§¬ª

[15:07] <Voldenet> c: 95cadc8916 sub here-we-get-a-seq($seq) { note ‚Äòall elements of the seq:‚Äô; .note for $seq }; my $s = <a b c>.words; note $s[1]; here-we-get-a-seq $s

[15:07] <committable6> Voldenet, ¬¶95cadc8: ¬´b‚ê§all elements of the seq:‚ê§(c)‚ê§¬ª

[15:08] <jnthn> AlexDaniel: oh wait, I misread...

[15:08] <jnthn> AlexDaniel: I thought you had left in the call to .head before indexing...

[15:08] <jnthn> Thus my confusion.

[15:09] <jnthn> m: my $s = <a b c>.words; note $s.head; note $s[0];

[15:09] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´a‚ê§The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[15:09] <jnthn> That's what I was expecting

[15:09] <jnthn> Or rather, that's what I was expecting from the eval I thought you did, but you didn't

[15:09] <AlexDaniel> Voldenet: yep, so currently if you try to index a Seq with [] it turns it into a list pretty much. If you're not careful, you can get very large Seqs cached without your explicit consent :P

[15:10] <jnthn> Well, largely because .[...] in all of its forms depends on an indexable list

[15:10] <AlexDaniel> which wouldn't've been a problem if you were able to name all operations that do that from the top of your head :)

[15:10] <cpan-raku> New module released to CPAN! Gnome::Cairo (0.1.1.1) by 03MARTIMM

[15:10] <AlexDaniel> jnthn: ok, name all operations that make Seqs cached

[15:10] <AlexDaniel> [] is one, fine, what else?

[15:11] <AlexDaniel> I learned about some by looking at the source code

[15:11] *** dataangel joined
[15:11] *** tecxxx joined
[15:11] <jnthn> Everything that [] depends on, thus I'd expect .elems, .AT-POS, and .EXISTS-POS

[15:12] <AlexDaniel> what else?

[15:12] <Voldenet> AlexDaniel: it's not really a big problem, `(^1e100).elems.say` would probably OOM

[15:12] <jnthn> Binding to an @-sigil'd parameter

[15:12] <AlexDaniel> more?

[15:12] <Voldenet> so the weird caching behaviour seems to be already there

[15:12] <jnthn> Note that numerous things *do* bind to an @ sigi'd parameter, so that is quite sweeping.

[15:13] <AlexDaniel> there are more specific ones. But regarding the @ sigil, as a user how can I know if something does or does not do that?

[15:14] *** melezhik joined
[15:14] <jnthn> I believe .gist and .perl do too, "naughtily", to prevent debugging insertions breaking your code. That's a pragmatic rather than a pure one.

[15:14] <tecxxx> Can anybody help me with building executsble?

[15:14] <jnthn> (Presumably .Str too)

[15:14] <AlexDaniel> yes, and also .Str

[15:14] <AlexDaniel> jnthn: I'm actually very impressed

[15:15] <melezhik> Next RakuOps issue is going to be about "How to manage multiple hosts using Sparrowdo", here is the draft - https://github.com/melezhik/sparrowdo/wiki/Dynamic-hosts 

[15:15] <AlexDaniel> I had no idea about all that before

[15:15] <melezhik> based on u/bobthecimmerian  comment in reddit

[15:16] <jnthn> How do *I* know when there's an @-sigil? Honestly, often parameter info in the IDE :P I suspect if we went through various of the sub forms of the list operations we'd find some questionable inconsistencies between +foo and +@foo taking things...

[15:16] <melezhik> feedback is welcome on this stage ... so I could clarify knowing questions ahead of time

[15:17] <tecxxx> Can i create executable with rakudo?fg

[15:17] <AlexDaniel> jnthn: maybe the IDE should even underline methods/subs that will cache a Seq, if it knows that it's dealing with a Seq that is

[15:17] *** titsuki left
[15:18] <jnthn> AlexDaniel: I was pretty much "at the table" when .cache came to be...and the main motiviation was array indexing and not making everyone write .list on the callee side when doing things like foo(@bar.grep(/baz/)

[15:20] <jnthn> There was also discussion of a method like .slice that enforced ascending order on the indices, so it could discard as it went

[15:21] <jnthn> (And if the indices were not ordered, it would be an exception)

[15:21] <jnthn> That never actually happened.

[15:22] <jnthn> tecxxx: No, there's not a means to do that yet

[15:26] <tecxxx> Can i run raku on Android?

[15:26] <dakkar> tecxxx: sort-of

[15:27] <dakkar> tecxxx: https://twitter.com/dakkar/status/1134191160979808256

[15:30] <jnthn> AlexDaniel: I'm not so sure about caching going away entirely (yet...), though I do wonder if making the various array indexing overloads have candidates for Sequence, which call .list and delegate, could have been better. In that the single element case doesn't especially need caching all the elements.

[15:30] <jnthn> AlexDaniel: .elems is only really doing it for .[*-1], so far as I recall

[15:31] <jnthn> My gut feeling is that if we did Sequence candidates for indexing that .list and delegate, and then we make positional bind failover call .list and bind that, getting rid of the caching might maybe kinda just squeak through but that doesn't yet answer .gist/.elems and friends.

[15:32] *** tecxxx left
[15:32] <jnthn> oops, sorry, .gist/.Str

[15:32] <jnthn> I'm designing the RakuAST nodes for the regex langauge, so my brain is only half on this :)

[15:34] *** petrtexx joined
[15:36] *** petrtexx left
[15:44] *** rbt left
[15:45] *** rbt joined
[15:59] *** MilkmanDan left
[15:59] *** reach_satori_ joined
[16:01] <AlexDaniel> m: my $s = (1, { $_ + 5 } ‚Ä¶ ‚àû); say $s; say $s.head

[16:01] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´(...)‚ê§1‚ê§¬ª

[16:01] *** MilkmanDan joined
[16:01] *** Tirifto joined
[16:01] *** xinming left
[16:02] *** xinming joined
[16:02] <AlexDaniel> jnthn: ‚Üë in this case .gist doesn't do much, and that's OK. I understand that non-lazy seqs are much more common, but I don't know if it's actually going to be a problem

[16:02] *** reach_satori left
[16:03] *** sena_kun joined
[16:04] <AlexDaniel> jnthn: for example, maybe dd can learn to do something crazy like consume the seq and replace the variable with another one. That sounds very bad, but it's a debugging aid, it's arguably not worse than having .gist doing the same

[16:05] *** Altai-man_ left
[16:24] <jnthn> AlexDaniel: I think .gist needs to give useful output for the non-lazy case, if that's what you're asking.

[16:25] <jnthn> Though yeah, there is the trick I mentioned before of .list it and then bind a list iterator, which actually restores the one-shot-ness

[16:26] *** suman joined
[16:27] <suman> m: my %hash = "a" => "zz" , "c" => "yz"; say "abcd".trans: %hash

[16:27] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´zbyd‚ê§¬ª

[16:28] <suman> I was expecting zzbyzd ! 

[16:28] <suman> But got zbyd !

[16:28] <suman> How to get zzbyzd instead?

[16:29] *** dakkar left
[16:34] *** squashable6 left
[16:36] *** squashable6 joined
[16:39] <AlexDaniel> m: say "abcd".trans: <a c> => <zz yz>

[16:39] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´zzbyzd‚ê§¬ª

[16:39] <AlexDaniel> suman: like this

[16:40] <AlexDaniel> and yeah it's kinda weird, but then things like `'a'..'z' => 'A'..'Z'` work fine

[16:40] <suman> AlexDaniel Is there a way to feed a hash table to trans?

[16:41] <suman> I have 40 keys and 40 values to make substitution

[16:42] <jnthn> m: my %hash = "a" => "zz" , "c" => "yz"; say "abcd".trans: %hash.keys => %hash.values

[16:42] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´zzbyzd‚ê§¬ª

[16:43] <AlexDaniel> jnthn: is it guaranteed that they will be in the same order?

[16:43] <suman> jnthn Exactly what I wanted. Thanks 

[16:43] <AlexDaniel> 6c: my %hash = "a" => "zz" , "c" => "yz"; say %hash.keys => %hash.values

[16:43] *** melezhik left
[16:43] <committable6> AlexDaniel, https://gist.github.com/3a8bab072beea390ac856b9771d3f628

[16:44] <AlexDaniel> by same I mean that keys and values will be matched correctly

[16:46] <codesections> AlexDaniel: the docs make that guarantee: 

[16:46] <codesections> > Note that the order in which keys, values and pairs are retrieved is generally arbitrary, but the keys, values and pairs methods return them always in the same order when called on the same object.

[16:46] <[Coke]> If you put the keys in a hash, I wouldn't expect the order to necessarily be preserved, no

[16:46] <[Coke]> you'll get them back in the same order each time you ask, but it isn't necessarily the order you put them in there.

[16:46] *** dolmen left
[16:47] <codesections> agreed

[16:47] <AlexDaniel> cool

[16:48] <AlexDaniel> I was about to come up with a cool trick with .rotor, but it's good that there's a simpler way :)

[16:56] *** skids joined
[17:06] <suman> I have a long string with ascii only more than million letters. How can I check if its length is multiple of  3? I want to proceed further only if its multiple of 3. 

[17:06] <suman> m: say "abcdefg".chars %% 3

[17:06] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´False‚ê§¬ª

[17:06] <suman> m: say "abcdefgh".chars %% 3

[17:06] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´False‚ê§¬ª

[17:07] <suman> Are there other ways for very long strings?

[17:07] <suman> m: say "abcdefghi".chars %% 3

[17:07] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´True‚ê§¬ª

[17:09] <jnthn> suman: .chars is O(1); strings are stored along with their length in Raku

[17:09] <AlexDaniel> jnthn: as I understand the issue is with rakudo being slow with just reading a very long string

[17:10] <AlexDaniel> suman: is that right?

[17:10] <AlexDaniel> suman: if so, where are you getting this string from?

[17:11] *** Woodi left
[17:11] <suman> AlexDaniel https://raw.githubusercontent.com/sumanstats/Coding-Biology-in-Raku/master/data/GCF_000006945.2_ASM694v2_genomic.fna

[17:12] <suman> Reading this sequence line by line and storing in a string 

[17:12] <AlexDaniel> suman: are newlines part of the string?

[17:12] <AlexDaniel> I see

[17:12] <suman> AlexDaniel No. Needs to be trimmed.

[17:12] <AlexDaniel> lemme play with it a bit

[17:14] <jnthn> Probably faster to loop over the lines and add up the .chars. Also, open it with :enc<ascii> if not already doing so.

[17:14] <AlexDaniel> suman: how fast do you need it to be?

[17:15] <jnthn> bbl o/

[17:15] <AlexDaniel> reading lines and joining takes around 0.130s

[17:15] <AlexDaniel> which isn't really slow

[17:16] <AlexDaniel> jnthn: summing the numbers of characters in each line is actually a bit slower

[17:16] <AlexDaniel> but roughly the same

[17:16] <suman> AlexDaniel Cam I see your code?

[17:16] <suman> *Can

[17:17] <AlexDaniel> suman: say ‚Äòfile.fna‚Äô.IO.lines.skip(1).join.chars

[17:17] <jdv79> random data point - looping over a file listing and matching 1 regex on each line - perl takes 5s, raku takes 128s

[17:18] <jdv79> still quite a ways to go:(

[17:18] <AlexDaniel> jdv79: give me the code I'll tell you how to make it faster :P

[17:18] <jdv79> i don't want to contort - i just want to loop nad match

[17:18] <jdv79> that's a very common "scripting" pattern/use case for my scripting needs

[17:19] <AlexDaniel> I'm not really trying to take the blame away from rakudo :)

[17:19] <AlexDaniel> jdv79: can you still show it? :)

[17:19] <jdv79> its boring

[17:19] <AlexDaniel> well, let me judge :)

[17:19] <jdv79> i wanted to use raku's concurrency to reduce the cost of the sink of this datastream but i'm not sure it'll go fast enough to beat just perl

[17:20] <AlexDaniel> WHERE IS THE RAKU SAAAAUCE

[17:23] <AlexDaniel> (https://youtu.be/-rLtbtvR9lg?t=120)

[17:23] <jdv79> https://nopaste.linux-dev.org/?1321452

[17:24] <jdv79> those over a ~5M line file of aws s3 ls output

[17:26] <AlexDaniel> jdv79: can you give me one line of that output?

[17:26] <jdv79> 2020-07-07 11:38:27        594 s3/2020-07-07-15-38-26-9E52F44628D62037

[17:31] <suman> AlexDaniel This is the code https://pastebin.com/uuTfrvPS

[17:31] <suman> This is much slow. Any faster alternative?

[17:32] *** bocaneri left
[17:33] *** skids left
[17:33] <jdv79> i guess i haven't tried "scripting" in raku lately - i thought it'd be slower but not that slower;)

[17:35] <suman> It takes 9 sec to look for the keys

[17:35] <jdv79> ah, it appears to be almost completely regex.  makes sense.

[17:35] <AlexDaniel> jdv79: yeah, the hash part is also playing a role in the slowness

[17:36] <jdv79> a hash build competes with a regex match?  i find that hard to believe

[17:37] <AlexDaniel> well it's like 10% or so

[17:38] <jdv79> was larry really "depressed" about the state of the regex/parser stuff?

[17:38] <jdv79> one of the recent media posts or comments or something claimed such

[17:38] *** skids joined
[17:39] <jdv79> i thought he just didn't get around to trying to implement fixes

[17:40] *** AlexDaniel left
[17:40] *** AlexDaniel joined
[17:40] *** AlexDaniel left
[17:40] *** AlexDaniel joined
[17:41] <AlexDaniel> oof I just ran out of mem

[17:43] <AlexDaniel> aaaah I see

[17:43] <AlexDaniel> suman: ok, can you replace @lines with $lines?

[17:44] <AlexDaniel> suman: and tell me what it for performance on your computer

[17:44] <AlexDaniel> what id does*

[17:44] <AlexDaniel> suman: that is: my $lines = $filepath.IO.lines;

[17:44] <AlexDaniel> and for $lines {

[17:44] <AlexDaniel> ah no

[17:45] <AlexDaniel> for $lines.list {

[17:45] <AlexDaniel> hmmm probably nothing

[17:46] <suman> AlexDaniel Its 7.4 sec now

[17:46] <suman> Better

[17:46] <jdv79> any ideas why .hyper.map wouldn't parallelize?

[17:48] <suman> AlexDaniel It consistently now runs in 6.5 secs 

[17:48] <suman> Pretty good

[17:49] <AlexDaniel> no no not enough

[17:50] <suman> So putting in scalar is better than array? Because changing @lines to $lines and for @lines to for $lines.list brings the speedup 

[17:50] <AlexDaniel> suman: can you try this: https://gist.github.com/AlexDaniel/de2ea5b684e3d630b803028940c80bf0

[17:52] <suman> AlexDaniel Amazing speedup. Runs in only 0.5 sec 

[17:52] <suman> (y) 

[17:52] <AlexDaniel> suman: the only important change, I think, is that now it collects the strings in an array

[17:53] <AlexDaniel> suman: and then joins them all at once

[17:53] <AlexDaniel> everything else doesn't matter much, I think

[17:54] <AlexDaniel> jdv79: unfortunately cannot come up with any clever idea for your case

[17:54] <AlexDaniel> jdv79: I already tried () instead of nameds and it's actually slower

[17:55] *** xinming left
[17:55] *** xinming joined
[17:57] <jdv79> its fine. thanks.

[18:02] *** Altai-man_ joined
[18:05] *** sena_kun left
[18:12] <codesections> for the code jdv79: posted, would changing `lines().map:` to `lines().hyper.map` help?

[18:12] <codesections> (that feels too easy)

[18:16] *** xinming left
[18:17] *** xinming joined
[18:18] <AlexDaniel> jdv79: I know how to make it like 50% faster: https://gist.github.com/AlexDaniel/e679cd69d99b7824a7f44ec837c0dcdf

[18:19] <AlexDaniel> you don't even need ^^ and $$ there

[18:19] <AlexDaniel> but they don't really affect performance

[18:21] <AlexDaniel> ahhhhhhh wait

[18:21] <AlexDaniel> I totally forgot!

[18:22] <AlexDaniel> well, ok, that doesn't help

[18:22] <AlexDaniel> jdv79: but just note that you can have .contains($pat) there

[18:22] <AlexDaniel> which won't create any match objects

[18:22] <AlexDaniel> and that's like more than twice as fast

[18:23] <AlexDaniel> the downside, however, is‚Ä¶ that it doesn't create match objects :P :P

[18:25] <jdv79> yeah.  kinda hard to use non-existent stuff.

[18:25] <jdv79> anyway, if i cheat by sticking a 'next unless .contains($str)' where i know i only care about things with $str used usable

[18:26] <jdv79> s/usable/its usable/

[18:27] <jdv79> also seem to need a "my $/;" in the hyper map - forget if i logged that bug

[18:28] <jdv79> random segfaulting and impossible $/ values pop up sans that

[18:29] <AlexDaniel> ah ye ye ye I remember that

[18:29] <AlexDaniel> I think I reported it at some point too

[18:30] *** Black_Ribbon joined
[18:32] <jdv79> pity the noob that hits that:(

[18:32] <jdv79> def LTA type stuff for beginners

[18:34] *** MasterDuke joined
[18:41] *** suman left
[18:54] *** rindolf left
[18:55] *** xinming left
[18:55] *** xinming joined
[19:07] *** rindolf joined
[19:09] *** DraakUSA joined
[19:21] *** dolmen joined
[19:22] *** vrurg left
[19:23] *** xinming left
[19:24] *** xinming joined
[19:30] *** __jrjsmrtn__ joined
[19:34] *** DraakUSA left
[19:36] *** xinming left
[19:36] *** xinming joined
[19:42] *** vrurg joined
[19:45] <AlexDaniel> m: my $s = (1, { $_ + 1 } ‚Ä¶ ‚àû); say $s[5]; say $s[1]; say $s

[19:45] <camelia> rakudo-moar 98c7e512a: OUTPUT: ¬´6‚ê§2‚ê§(...)‚ê§¬ª

[19:45] <AlexDaniel> so is-lazy seqs, even when cached, are gisted as (...)

[19:46] <SmokeMachine> I've added more doc on Red architecture tutorial, would some one like to take a look at it, please? https://github.com/FCO/Red/blob/master/docs/tutorials/architecture.md

[19:47] *** rbt left
[19:48] *** rbt joined
[19:59] <vrurg> SmokeMachine: is it for Red contributors or for users?

[20:04] *** ca53 joined
[20:04] *** sena_kun joined
[20:04] *** Altai-man_ left
[20:06] <ca53> Hello,

[20:07] <lizmat> ca53 o./

[20:08] <ca53> I'm just trying to get Spreadsheet::XLSX installed by zef (on Rakudo 2020.06, Fedora 32) and after all dependencies are installed a get failde test 

[20:08] <ca53> [Spreadsheet::XLSX] # Failed test 'Can serialize it into a blob'[Spreadsheet::XLSX] # at t/new-basic.t line 99[Spreadsheet::XLSX] # You cannot create an instance of this type (List)[Spreadsheet::XLSX] # Failed test 'Can reload the serialized sheet'[Spreadsheet::XLSX] # at t/new-basic.t line 103[Spreadsheet::XLSX] # Required [Content_Types].xml is

[20:08] <ca53> missing

[20:09] * lizmat tries

[20:09] <ca53> I'm not sure where the problem may be. I'd appreciate any idea. Thanks.

[20:13] <lizmat> which version of Rakudo are you using?

[20:14] <ca53> 2020.06, compiled from source, MoarVM

[20:16] <ca53> Didn't try to compile bleeding edge one from master branch. Should I try this first maybe?

[20:16] <lizmat> no, 2020.06 is pretty recent  :-)

[20:16] <lizmat> my attempt stalled at LibArchive

[20:16] <lizmat> perhaps jnthn can shine a light

[20:19] <Xliff> This issue has already been raised. See: https://github.com/jnthn/spreadsheet-xlsx/issues/2

[20:19] <tellable6> 2020-07-06T21:32:20Z #raku-dev <gfldex> Xliff you might be looking for http://www.enlightenment.org/about-terminology

[20:19] <tellable6> 2020-07-06T21:32:38Z #raku-dev <gfldex> Xliff the got a showoff video at https://www.youtube.com/watch?v=ibPziLRGvkg&feature=youtu.be

[20:19] <tellable6> hey Xliff, you have a message: https://gist.github.com/f7d2b273de77383a0ffb765320f930db

[20:20] <Xliff> ca53: Your version of rakudo is probably not recent enough.

[20:20] <Xliff> You'd have to install rakudo from source to get the fix, until a new release is cut.

[20:23] <timotimo> yo Xliff did you know about the escape sequence that lets you put URLs on cells in the terminal? which is supported by VTE, but has to be explicitly allowed with a little function call?

[20:24] <lizmat> Xliff: looks to me that got into 2020.06, which is what ca53 is using?

[20:24] <SmokeMachine> vrurg: contributors, I think

[20:24] <lizmat> Xliff or is that the one that got reverted because of performance issues ?

[20:25] <ca53> xliff: I see. I somehow forgot to search the closed issues.

[20:25] <SmokeMachine> some times when I try to run Red code I get this error: https://www.irccloud.com/pastebin/g6BU5WOX/

[20:26] <SmokeMachine> does any one ever seen this? ^^

[20:26] <vrurg> SmokeMachine: raise your ulimit.

[20:27] <SmokeMachine> ok, but why is it opening so many files?

[20:27] <vrurg> SmokeMachine: I'll try to look at the doc.

[20:27] <SmokeMachine> vrurg: thanks

[20:27] <vrurg> SmokeMachine: depends on what you consider "so many". If you have ulimit 250 (macos default) then it's not really many.

[20:28] *** discoD joined
[20:37] <ca53> Xliff: the commit with fix seems to be included in MoarVM 2020.06, although Rakudo 2020.06 release notes https://github.com/rakudo/rakudo/releases don't mention the commit... will try to compile Rakudo from master to be sure.

[20:37] <ca53> Thank you

[20:39] <SmokeMachine> does that keep the files open some how?! It's giving that error again

[20:40] <SmokeMachine> sorry, wrong terminal

[20:40] *** kensanata joined
[20:43] <codesections> I just realized that it's impossible to pass formal parameters into a conditional block because conditional blocks have a type signature that constrains them to a single Bool parameter.  

[20:44] <codesections> That's kind of frustrating, but also makes a lot of sense, once I saw how all the pieces fit together 

[21:01] *** aborazmeh joined
[21:01] *** aborazmeh left
[21:01] *** aborazmeh joined
[21:14] *** cpan-raku left
[21:14] *** rindolf left
[21:15] <discoD> Hello, I could use some words of wisdom. incoming text

[21:15] <discoD> I dislike python, so I wrote a python beautifier that emits readable raku code. 

[21:15] <discoD> It correctly infers the majority of sigils and lifts declarations into the correct scopes. 

[21:15] <discoD> It handles classes, their attributes and methods, enums, and all control flow without major issues.

[21:15] *** cpan-raku joined
[21:15] *** cpan-raku left
[21:15] *** cpan-raku joined
[21:15] <discoD> It's very useful as is, but it's limited by going straight from python ast to raku source without an IR. 

[21:15] <discoD> Going from QAST back to raku source sounds like a lot of work, but I could be wrong. 

[21:15] <discoD> I'm wondering if an slang for QAST would be a good option.

[21:15] <discoD> That would let me go from pyAST -> QAST and still emit some raku source without having to translate every QAST node. 

[21:15] *** stoned75 left
[21:16] <discoD> Any thoughts? I've been winging the whole thing, so any advice is appreciated.

[21:18] *** MilkmanDan left
[21:20] <lizmat> discoD: are you aware of jnthn's RakuAST project / branch ?

[21:20] <discoD> nope

[21:21] <lizmat> https://news.perlfoundation.org/post/rakuast-2020-06

[21:21] <lizmat> https://news.perlfoundation.org/post/gp_rakuast    # the grant proposal description

[21:23] <[Coke]> ooh, one of my last posts!

[21:23] <discoD> thanks! reading up on it

[21:23] *** finsternis joined
[21:29] *** molaf joined
[21:31] *** kensanata left
[21:32] <timotimo> codesections: i have good news for you

[21:32] <codesections> Oh?

[21:32] <timotimo> the parameters are not actually restricted to Bool-derived things

[21:33] <timotimo> it just evaluates the truthiness of the thing, and passes the thing to the block

[21:33] <timotimo> m: if <a b c> -> $mylist { say "my list is $mylist" }

[21:33] <camelia> rakudo-moar 16d24a212: OUTPUT: ¬´my list is a b c‚ê§¬ª

[21:34] <codesections> Oh, that is cool :)

[21:34] <timotimo> and since it's very common to be interested in the definedness of a thing, not the truthfulness, there's also "with" to match "if" and "without" to match "unless"

[21:34] <timotimo> and "orwith" to match "elsif"

[21:34] <tobs> m: if <a b c> -> Num $mylist { dd $mylist }

[21:34] <camelia> rakudo-moar 16d24a212: OUTPUT: ¬´Type check failed in binding to parameter '$mylist'; expected Num but got List ($("a", "b", "c"))‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[21:34] <timotimo> m: if <a b c>.defined -> $mylist { say "sadness, mylist is just $mylist" }

[21:34] <camelia> rakudo-moar 16d24a212: OUTPUT: ¬´sadness, mylist is just True‚ê§¬ª

[21:35] <timotimo> m: with <a b c> -> $mylist { say "sadness, mylist is just $mylist" }

[21:35] <camelia> rakudo-moar 16d24a212: OUTPUT: ¬´sadness, mylist is just a b c‚ê§¬ª

[21:35] <timotimo> ^- actually happyness

[21:35] *** tutu joined
[21:35] <eery> oh nice, so if does pass the result of the evaluation to the block?

[21:36] <tobs> huh, that works. Never would have occured to me to write it, probably because I would be reasonably sure of the type in the condition, or because failing the signature errors instead of going to an else branch?

[21:36] <codesections> oh, cool, I hadn't made that connection ‚Äì I thought `with` was clarity/concision.  And it *is*, but it has other powers too :)

[21:36] <timotimo> m: given <a b c> { when Num { say "its a num" }; default { say "its actually $_" } }

[21:36] <camelia> rakudo-moar 16d24a212: OUTPUT: ¬´its actually a b c‚ê§¬ª

[21:37] <tutu> Hi there. I was trying to update my version of raku to a more recent one.  I was wondering if this link still works:  https://rakudo.org/latest/star/src

[21:37] <tobs> m: given <a b c> { when Num | * <= 3 { say "its a num or small" }; default { say "its actually $_" } }

[21:37] <camelia> rakudo-moar 16d24a212: OUTPUT: ¬´Invocant of method 'Bridge' must be an object instance of type 'Num',‚ê§not a type object of type 'Num'.  Did you forget a '.new'?‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[21:38] <tobs> uhh, currying precedence

[21:38] <tobs> anyway

[21:38] <codesections> Yeah, that I knew about.  Speaking of given statements, there's not a way destructure the topic variable in the `when` statement, is there?

[21:39] <codesections> as in, consider this:

[21:39] <tutu> I'm following the instructions from the rakudo star source installation page (https://rakudo.org/star/source), but seem not working.

[21:40] <codesections> m: given 42, "hi" { when (42, *) { say .tail } }

[21:40] <camelia> rakudo-moar 16d24a212: OUTPUT: ¬´hi‚ê§¬ª

[21:40] <codesections> Is there a way to destructure the (42, "hi") list?

[21:40] <codesections> to be able to test against it / use it more easily than with calls to .head/.tail ?

[21:41] *** OpenZen joined
[21:41] <cpan-raku> New module released to CPAN! Red (0.1.14) by 03FCO

[21:42] <tutu> Should i just get the source code from github instead?

[21:42] <tutu> Does anyone know the branch name from the latest version?

[21:44] <tobs> tutu: the rakudo.org page seems outdated

[21:44] <tobs> I seem to recall a conversation about this recently but I cannot find it in the mountains of mails

[21:45] <tobs> if I'm not mistaken, tyil maintains rakudo star now and has a repository with packaged source tars here: https://home.tyil.nl/git/rakudo-star-2.0/

[21:45] <[Coke]> you should still go against rakudo.org, I think, but the front page is missing a few updates.

[21:46] *** dolmen left
[21:46] <[Coke]> do you *want* star source? or just trying to get something recent?

[21:47] <[Coke]> https://rakudo.org/downloads/star has 2020.05...

[21:48] <tutu> Thank @tobs and [Coke]. I'm looking for the sources to build on my system.

[21:48] <cpan-raku> New module released to CPAN! Test::Diehard (0.0.2) by 03LYX

[21:50] <tutu> cloning right now.

[21:54] *** aluaces left
[22:02] <ca53> Tried Spreadsheet::XLSX installation on Rakudo compiled from current master branch sources: commit  3bc4fa90ad3aaba19330a544c48949c258d5c20a, raku -v output: "This is Rakudo version 2020.06-57-g3bc4fa90a built on MoarVM version 2020.06-14-g5832b2628"

[22:02] <ca53> The same test error: https://glot.io/snippets/fp2yiplcak/raw/main.txt

[22:02] *** Altai-man_ joined
[22:04] <tutu> okay so rstar is a tool to build rakudo star packages. 

[22:05] *** sena_kun left
[22:08] <Xliff> ca53: OK. One second. Let me see if I can reproduce.

[22:15] <Xliff> Oh. I forgot. What am I missing, here: 

[22:15] <Xliff> https://repl.it/@Xliff/PointlessSecretHexagon#main.raku

[22:15] <Xliff> Oh, FFS.

[22:17] *** OpenZen left
[22:21] <ca53> When I force the test and try loading an XLSX file from REPL, this the result (error on loading): https://glot.io/snippets/fp2z6m7hk7/raw

[22:24] <Xliff> :(

[22:24] <Xliff> Looks like its another error.

[22:24] <Xliff> ca53: Sorry. I conflated your error with the one raised, which was a segfault issue.

[22:25] <ca53> (the output is the same when running from classic script file)

[22:25] <Xliff> ca53: You should probably create an issue in Spreadsheet::XLSX

[22:26] *** aborazmeh left
[22:26] <ca53> Xliff: It seems so. Thanks for your help.

[22:35] *** Tirifto left
[22:36] *** AlexDaniel left
[22:43] *** timeless left
[22:46] *** timeless joined
[22:47] *** PotatoGim left
[22:48] *** cooper left
[22:48] *** isacl___ left
[22:48] *** tbrowder left
[22:50] *** kawaii left
[22:50] *** peteretep left
[22:50] *** BuildTheRobots left
[22:50] *** mithaldu_ left
[22:51] *** spycrab0 left
[22:51] *** skaji_ left
[22:51] *** Grinnz left
[22:51] *** jhill left
[22:51] *** dylanwh left
[22:52] *** SmokeMachine left
[22:52] *** pnu__ left
[22:52] *** ChoppedBacon left
[22:52] *** Hotbees left
[22:52] *** zostay left
[22:53] *** timeless left
[22:53] *** caasih left
[22:53] *** mrsolo left
[23:04] *** ca53 left
[23:08] *** tutu left
[23:18] *** hungryd19 joined
[23:20] *** hungrydonkey left
[23:27] *** lizmat left
[23:31] *** pecastro left
[23:41] *** Xliff left
[23:43] *** Geth left
[23:44] *** Geth joined
[23:46] *** Geth left
[23:47] *** Geth joined
[23:55] *** guifa2 left
