[00:01] <jnthn> Ah, the macro bit I didn't play with, alas

[00:08] <stu002> I posted a mailing list question on custom roles, built-in types and monkey typing: https://www.mail-archive.com/perl6-users@perl.org/msg09037.html I'd appreciate any feedback on how to approach this issue in idiomatic Raku.

[00:10] <tbrowder> jnthn, as long as i can get one host working that can be macroized pretty easily.

[00:11] <guifa> codesections: hmm, good question.  The problem is since expensive-calculation might have sideeffects that effect the next line of code.  Maybe there‚Äôs a way to toss everything in a sub that does it delayed

[00:12] <guifa> like sub delayed(Callable foo) {¬†sub slow() {¬†foo() }; return lazy gather { take slow }¬†or something ?

[00:12] <guifa> might be missing some brackets and haven‚Äôt tested

[00:13] <guifa> rypervenche: the methods should always be acting on a single instance

[00:16] <guifa> jnthn: I‚Äôm revisiting my DateTime format code because Timezones.  Is there any particular way i can structure things that will leave me better equipped for adopting RAST ?

[00:18] *** zacts left
[00:23] <rypervenche> guifa: Wouldn't I need to use >>.made instead of .made on some of my $/ though in my actions? This is what I'm working on right now: https://gist.github.com/rypervenche/7738357403817b8f61324161df79e21d

[00:24] <guifa> m: my $a = 5; say $a>>.Str 

[00:24] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(5)‚ê§¬ª

[00:24] <guifa> The joy of scalars is that they listify into single items lists :-)

[00:24] <guifa> so when in doubt, just treat everything as a list

[00:25] <rypervenche> Huh...do you do that in your code as well?

[00:25] <timotimo> guifa: there's a module for your "delayed", i think it's got "lazy" and "catchup"?

[00:26] <timotimo> https://modules.raku.org/dist/Object::Delayed:cpan:ELIZABETH

[00:26] *** zacts joined
[00:26] <timotimo> slack and catchup actually

[00:28] <guifa> rypervenche: I don‚Äôt think I‚Äôve had many where it‚Äôs not really clear but I keep my tokens extremely tiny.  

[00:28] <guifa> The general rule (actually, the only rule) is if there‚Äôs a quantifier of any type, or a named capture appears twice anywhere, it automatically becomes a list match and you can‚Äôt work on it as a scalar

[00:32] <rypervenche> Hmmm, ok. I'll look at some code that others have written to try to get some ideas. Thanks.

[00:37] <rypervenche> Ahhhh, I must have been doing it wrong previously. I can add .WHAT to the level that I want and it will tell me if it's an Array. Perfect.

[00:39] *** aborazmeh left
[00:39] <guifa> cleaner than using WHAT would be

[00:39] <guifa> $foo ~~ Array

[00:39] <guifa> but .WHAT works too

[00:40] <rypervenche> Ahh, I'm just going through each level manually.

[00:46] <cpan-raku> New module released to CPAN! App::Mi6 (1.0.2) by 03SKAJI

[00:57] <rypervenche> It looks like I was overthinking everything. The solution was just to loop through the array. Is there a cleaner way that I might do what I did in method TOP? https://gist.github.com/rypervenche/7738357403817b8f61324161df79e21d

[00:57] <guifa> what‚Äôs the best way to ignore an argument in a ^ twigiled subroutine? sink?

[00:58] <guifa> rypervenche: ah okay, I see probably the issue

[00:58] <guifa> Don‚Äôt try to do too much on any given level

[01:00] <guifa> method query-string { my %queries; for $<query> {¬†‚Ä¶¬†}; make %queries; }

[01:00] <guifa> and then

[01:00] <guifa> method TOP {¬†make $query-string.made }

[01:00] <rypervenche> Ooooh

[01:00] <guifa> Trust me when I say your life will be much easier if you never try to jump a level :-)

[01:01] <guifa> and the ‚Äòmake $<foo>.made‚Äô is very common

[01:01] <rypervenche> So I'll essentially need to add actions for each/most level/s then.

[01:01] <rypervenche> I thought I'd be saving code/space by skipping them, but I see how much easier that is to read.

[01:01] <guifa> It‚Äôs much cleaner.  When you break them down small enough, most of them are one lines, are easy to immediately grok

[01:02] <guifa> If you‚Äôre looking for places to save‚Ä¶ ‚Äúmake ~$/‚Äú is definitely one of them

[01:03] <guifa> you can replace $<type>.made with $<type>,Str or ~$<type> and then avoid having a type method (ditto for value)

[01:04] <rypervenche> Ah, do the stringification in one place (at least in this case). Very nice. Thanks so much for the help.

[01:07] <rypervenche> Much cleaner now.

[01:09] <guifa> of course, I love how I said ‚Äúyou can avoid the make $/.Str‚Äù stuff and then I looked over an old actions class

[01:09] <guifa> https://github.com/alabamenhu/Intl-CLDR/blob/master/resources/parse-plurals.p6

[01:09] <guifa> lol

[01:09] <guifa> sure enough, there‚Äôs one for <value>

[01:14] *** zacts left
[01:15] *** sena_kun joined
[01:16] *** Altai-man left
[01:54] *** melezhik joined
[01:55] <melezhik> .tell demostanis: "Also security doesn't seem to be that important as it's supposed to be running locally." I am not sure what you mean locally, sparrowdo could run over ssh as well

[01:55] <tellable6> melezhik, I'll pass your message to demostanis

[01:58] *** melezhik left
[02:06] *** Manifest0 left
[02:06] *** Manifest0 joined
[02:35] *** stu002 left
[02:49] <codesections> fun

[02:53] <codesections> rw

[03:03] *** defaultxr joined
[03:10] *** cpan-raku left
[03:14] *** Altai-man joined
[03:16] *** sena_kun left
[03:17] *** cpan-raku joined
[03:17] *** cpan-raku left
[03:17] *** cpan-raku joined
[04:03] *** gordonfish- is now known as gordonfish

[04:26] <guifa2> whoa

[04:27] <guifa2> class A {¬†method morph($self is rw:) {¬†$self = A.new } }; my $a = A.new; say $a.WHICH; $a.morph; say $a.WHICH;

[04:27] <evalable6> guifa2, rakudo-moar 798614cb7: OUTPUT: ¬´A|94104662207584‚ê§A|94104662207904‚ê§¬ª

[04:28] <guifa2> apparently you *can* replace an object during a method call

[04:31] <guifa2> I don't know who had the insane idea to allow that but‚Ä¶ bless you

[04:49] <guifa2> Whoa, and if you make morph a multi, you can even determine if the $self is writable or not 

[04:50] <guifa2> m: class A { multi method a ($self is rw:) { say "Read/write" }; multi method a ($self:) { say "Read-only" } }; A.new.a; my $a = A.new; $a.a

[04:50] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´Read-only‚ê§Read/write‚ê§¬ª

[05:03] *** evalable6 left
[05:03] *** linkable6 left
[05:06] *** linkable6 joined
[05:06] *** evalable6 joined
[05:15] *** sena_kun joined
[05:17] *** Altai-man left
[05:40] *** rindolf joined
[05:59] <xinming> Yesterday, I'm thinking, wether raku would allow to replace a function definition directly in another module

[06:00] <xinming> Let's say, module A has function base-function, and it exports an api which is do-sth, where do-sth will call the base-function. in our code, Is it possible that we replace the base-function to a new one, when we call do-sth, the do-sth function will pick up the new function?

[06:00] <xinming> It's a bit like    temp $var = "sdfsdfsf"

[06:01] <xinming> After we go out of the scope, the base-function is restored to old one.

[06:01] *** sno left
[06:07] <guifa2> xinming: eh....almost

[06:08] <guifa2> If you can reference the sub/method, you can wrap and unwrap it

[06:09] <guifa2> That effect is global, though and not lexically scoped.  The trick I've used is to use a dynamic variable as a flag to decide whether I want to call the original or do something else.  

[06:11] *** bocaneri left
[06:13] <guifa2> ModuleA::<&basefunction>.wrap( method (|c) { if $*REPLACEMENT {¬†‚Ä¶‚Ä¶ }¬†else {¬†callsame } )

[06:14] <guifa2> in the lexical scope you want to use the method, my $*REPLACEMENT = True; 

[06:17] *** stu002 joined
[06:20] <guifa2> xinming: I hope that gives you a good starting point.  I'm about to go to bed now, it's quite late here 

[06:21] *** bocaneri joined
[06:22] *** bocaneri left
[06:23] *** bocaneri joined
[06:46] *** xinming left
[06:47] *** xinming joined
[06:49] *** Sgeo left
[06:53] *** satori__ left
[06:54] *** stoned75 joined
[06:56] *** wamba joined
[07:27] *** reach_satori joined
[07:31] *** silug7 joined
[07:31] *** silug left
[07:31] *** silug7 is now known as silug

[07:31] *** vrurg_ joined
[07:32] <Geth_> ¬¶ doc/supply-split: 3757cf86dc | (Stoned Elipot)++ | doc/Type/Supply.pod6

[07:32] <Geth_> ¬¶ doc/supply-split: Add Supply.split #3187

[07:32] <Geth_> ¬¶ doc/supply-split: review: https://github.com/Raku/doc/commit/3757cf86dc

[07:32] *** vrurg left
[07:32] <Geth_> ¬¶ doc: stoned++ created pull request #3552: Add Supply.split #3187

[07:32] <Geth_> ¬¶ doc: review: https://github.com/Raku/doc/pull/3552

[07:32] <linkable6> DOC#3187 [open]: https://github.com/Raku/doc/issues/3187 [big][docs][help wanted][versions] Checklist for version 2020.01

[07:45] *** JJMerelo joined
[07:50] *** sjm_uk joined
[07:55] <JJMerelo> New 20th anniversary calendar entry https://raku-advent.blog/2020/08/09/rfc-5-by-michael-j-mathews-multiline-comments/

[07:56] *** molaf joined
[08:05] <Geth_> ¬¶ advent: 3be31cb6f8 | (JJ Merelo)++ | 20th/articles/rfc54.md

[08:05] <Geth_> ¬¶ advent: Adds links, eliminates whitespace, gets ready to upload @p6steve

[08:05] <Geth_> ¬¶ advent: review: https://github.com/Raku/advent/commit/3be31cb6f8

[08:09] *** stu002 left
[08:14] *** Altai-man joined
[08:14] <JJMerelo> .tell p6steve I've made some small changes and scheduled your post for tomorrow AM. I would need you to send me your email so that I can invite you to the site and assign authorship of the article to you

[08:14] <tellable6> JJMerelo, I'll pass your message to p6steve

[08:14] <JJMerelo> .seen p6steve

[08:14] <tellable6> JJMerelo, I saw p6steve 2017-10-29T08:02:09Z in #perl6: <p6steve> thanks!

[08:14] <JJMerelo> uh-oh

[08:16] <Geth_> ¬¶ advent: 0157b09847 | (JJ Merelo)++ | 20th/articles/rfc54.md

[08:16] <Geth_> ¬¶ advent: Some small corrections to publish

[08:16] <Geth_> ¬¶ advent: 

[08:16] <Geth_> ¬¶ advent: Please @p6steve send me your email address so that I can invite you to the WordPress blog and assign authorship of the article once you've accepted.

[08:16] <Geth_> ¬¶ advent: review: https://github.com/Raku/advent/commit/0157b09847

[08:16] *** sena_kun left
[08:23] *** stu002 joined
[08:24] <Geth_> ¬¶ doc: a4d4b2263c | stoned++ (committed using GitHub Web editor) | doc/Type/Supply.pod6

[08:24] <linkable6> Link: https://docs.raku.org/type/Supply

[08:24] <Geth_> ¬¶ doc: Add Supply.split #3187 (#3552)

[08:24] <Geth_> ¬¶ doc: review: https://github.com/Raku/doc/commit/a4d4b2263c

[08:24] <linkable6> DOC#3187 [open]: https://github.com/Raku/doc/issues/3187 [big][docs][help wanted][versions] Checklist for version 2020.01

[08:24] <linkable6> DOC#3552 [closed]: https://github.com/Raku/doc/pull/3552 Add Supply.split

[08:42] *** Kaiepi left
[08:45] *** defaultxr left
[09:00] <xinming> guifa2: Thanks, But I'd say, wrap is globally, I mean, if we can restore it automatically when we go out of scope will be best.

[09:03] *** Kaiepi joined
[09:08] *** JJMerelo left
[09:21] *** sjm_uk left
[09:26] *** xinming left
[09:27] *** Kaiepi left
[09:27] *** xinming joined
[09:31] *** JJMerelo joined
[09:34] *** Kaiepi joined
[10:01] *** sjm_uk joined
[10:15] *** sena_kun joined
[10:16] *** ensamvarg3 joined
[10:16] *** Altai-man left
[10:31] *** stu002 left
[11:27] *** JJMerelo left
[11:44] <Geth_> ¬¶ problem-solving: CIAvash assigned to jnthn Issue Destructuring infinite ranges and sequences https://github.com/Raku/problem-solving/issues/218

[11:58] <Geth_> ¬¶ advent: ab5tract++ created pull request #58: RFC 43

[11:58] <Geth_> ¬¶ advent: review: https://github.com/Raku/advent/pull/58

[12:00] *** mscha joined
[12:02] *** sno joined
[12:03] <mscha> Quick Q: what's the equivalent of this Perl 5 construct?  my ($y, $m, $d) = '20200809' =~ /(\d{4})(\d{2})(\d{2})/

[12:04] <mscha> m: my ($y, $m, $d) = ('20200809' ~~ /(\d**4)(\d**2)(\d**2)/)[*]; say "$d-$m-$y";

[12:04] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´09-08-2020‚ê§¬ª

[12:05] <mscha> That does the trick, but it won't work without the `[*]`

[12:13] *** ab5tract joined
[12:15] <ab5tract> .tell JJMerelo can you ping me in private when you get online? In the end I could use a new advent invite to a different email address

[12:15] <tellable6> ab5tract, I'll pass your message to JJMerelo

[12:16] *** gnufr33dom left
[12:17] <CIAvash> m: my ($y, $m, $d) := '20200809' ~~ /(\d**4)(\d**2)(\d**2)/; say "$d-$m-$y";

[12:17] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´09-08-2020‚ê§¬ª

[12:19] <CIAvash> mscha: ‚Üë

[12:19] <mscha> Thanks, CIAvash!

[12:25] *** sno left
[12:27] *** sno joined
[12:32] *** wamba left
[12:35] *** lichtkind joined
[12:46] *** xinming left
[12:47] *** xinming joined
[13:12] *** oddp joined
[13:14] *** Altai-man joined
[13:16] *** sena_kun left
[13:25] *** mscha left
[13:32] <guifa> xinming: You can unwrap when out of scope.  my $wrapper = ModuleA::<&baseFunction>.wrap( ‚Ä¶ ); ‚Ä¶‚Ä¶; ModueA::<&baseFuncion>.unwrap($wrapper)

[13:32] *** wamba joined
[13:33] <guifa> However, if your code is asychronous at all, you can‚Äôt guarantee that outside of the scope the wrapped version won‚Äôt be called.  

[13:48] *** ab5tract left
[14:07] *** MilkmanDan left
[14:08] *** stoned75 left
[14:08] *** MilkmanDan joined
[14:32] *** domidumont left
[14:56] *** Kaiepi left
[15:00] *** Kaiepi joined
[15:02] *** Kaiepi left
[15:03] *** Kaiepi joined
[15:03] *** Kaiepi left
[15:14] *** sena_kun joined
[15:16] *** Altai-man left
[15:35] *** Sgeo joined
[15:39] *** Kaiepi joined
[15:40] *** stoned75 joined
[15:41] <codesections> Is this idiomatic code for flattening a nested Hash?  It feels clunky/like I'm missing a better way:

[15:42] <codesections> m:  my %h = a => [1,2,3], b => [7,8,9]; dd %h.values.map(*.flat).flat

[15:42] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(7, 8, 9, 1, 2, 3).Seq‚ê§¬ª

[15:44] <codesections> Oh, the Array docs suggest the following, which still isn't *great*, but is much better

[15:44] <codesections> m:  my %h = a => [1,2,3], b => [7,8,9]; dd %h.values¬ª.List.flat 

[15:44] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(7, 8, 9, 1, 2, 3).Seq‚ê§¬ª

[15:44] <codesections> never mind, then :) 

[15:45] *** [Sno] joined
[15:46] *** sno left
[15:48] <Geth_> ¬¶ advent/master: 4 commits pushed by ab5tract++, (Juan Juli√°n Merelo Guerv√≥s)++

[15:48] <Geth_> ¬¶ advent/master: 226207cbcb | Initial draft of RFC 43

[15:48] <Geth_> ¬¶ advent/master: 6c193076df | 90%

[15:48] <Geth_> ¬¶ advent/master: 384153ee9a | 100%

[15:48] <Geth_> ¬¶ advent/master: d3aa975246 | Merge pull request #58 from ab5tract/master

[15:48] <Geth_> ¬¶ advent/master: review: https://github.com/Raku/advent/compare/0157b0984722...d3aa9752464b

[15:49] <stoned75> q

[15:50] *** [Sno] left
[15:58] *** wamba left
[16:16] *** demostanis joined
[16:17] <demostanis> Hello people, is there a way to (like in JavaScript) give a default value to a variable defined with my (...) in case it's Nil?

[16:17] <tellable6> 2020-08-09T01:55:05Z #raku <melezhik> demostanis: "Also security doesn't seem to be that important as it's supposed to be running locally." I am not sure what you mean locally, sparrowdo could run over ssh as well

[16:18] <demostanis> Example: my ($a, $b = "default value) = (1) # $a = 1, $b = Nil

[16:18] <rypervenche> m: my $var = Nil // "blah"; say $var;

[16:18] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´blah‚ê§¬ª

[16:18] <demostanis> Yeah, but what if I define it with my (...)?

[16:19] <rypervenche> Oh sorry, I misunderstood.

[16:19] <demostanis> melezhik: What I meant is that the sparrowfile is executed locally, and isn't being fetched from an untrusted somewhere else? Am I right?

[16:19] <tellable6> demostanis, I'll pass your message to melezhik

[16:20] <demostanis> I'm doing this in a proto subroutine

[16:20] <demostanis> my ($thing1, $thing2 = "might not exist so should give a default value") = {*}

[16:21] <codesections> demostanis: interesting, I'm surprised that this vvvv doesn't work

[16:21] <codesections> m: my ($a, $b = 42) = (1,)

[16:21] <camelia> rakudo-moar 798614cb7: ( no output )

[16:21] <codesections> m: say my ($a, $b = 42) = (1,)

[16:21] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(1 (Any))‚ê§¬ª

[16:21] <demostanis> Do I have to do $b = "default value" if !$b.defined

[16:22] <demostanis> Isn't there a cleaner way? And why won't Rakudo throw any error if my ($a, $b = "...") isn't correct?

[16:22] <guifa> You can use the default trait

[16:22] <demostanis> What is it?

[16:23] <guifa> m: my $a is default(‚Äòdefault‚Äô); my $a = ‚Äúset‚Äù; say $a; $a = Nil, say $a;

[16:23] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´Potential difficulties:‚ê§    Redeclaration of symbol '$a'.‚ê§    at <tmp>:1‚ê§    ------> 3my $a is default(‚Äòdefault‚Äô); my $a7‚èè5 = ‚Äúset‚Äù; say $a; $a = Nil, say $a;‚ê§set‚ê§default‚ê§¬ª

[16:23] <guifa> err

[16:23] <guifa> m: my $a is default(‚Äòdefault‚Äô); $a = ‚Äúset‚Äù; say $a; $a = Nil, say $a;

[16:23] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´set‚ê§default‚ê§¬ª

[16:24] <demostanis> m: my ($hello, $world is default("John")) = ("hello ")

[16:24] <camelia> rakudo-moar 798614cb7: ( no output )

[16:24] <demostanis> m: say my ($hello, $world is default("John")) = ("hello ")

[16:24] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(hello  (Any))‚ê§¬ª

[16:24] <demostanis> Nope?

[16:24] <guifa> m: say my ($hello, $world is default("John")) = ("hello ‚Äú, Nil)

[16:24] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Unable to parse expression in double quotes; couldn't find final '"' (corresponding starter was at line 1)‚ê§at <tmp>:1‚ê§------> 3ld is default("John")) = ("hello ‚Äú, Nil)7‚èè5<EOL>‚ê§    expectin‚Ä¶¬ª

[16:24] <guifa> er stupid quote replacement on Colloquy

[16:25] <codesections> I was trying that too.  Doesn't work

[16:25] <codesections> m: say my ($hello, $world is default("John")) = ("hello ", Nil)

[16:25] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(hello  (Any))‚ê§¬ª

[16:25] <demostanis> Okay, thanks, I didn't know about it!

[16:27] <guifa> Oh duh.  Trait needs to go with declarator.  Compare 

[16:27] <guifa> m: (my $hello, my $world is default("John")) = (Nil, Nil)

[16:27] <camelia> rakudo-moar 798614cb7: ( no output )

[16:27] <guifa> m: say (my $hello, my $world is default("John")) = ("hello ", Nil)

[16:27] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(hello  John)‚ê§¬ª

[16:27] <codesections> demostanis: one note that doesn't help solve your problem but that you might want to know (it's tripped me up before): in Raku `("Hello")` doesn't create a 1-element List.  You need `("Hello", )` or just `"Hello",`

[16:27] <guifa> m: say my ($hello, $world) is default('John') = (Nil, Nil)

[16:27] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(John John)‚ê§¬ª

[16:28] <guifa> You‚Äôll just have to content yourself with repeating my once or twice :-)

[16:31] <demostanis> codesections: Oh yeah, sorry, I often do this mistake

[16:31] <codesections> Me too :)

[16:35] <guifa> The nice thing about the commas making the lists is that you can remove sooo many parentheses

[16:38] *** poohman joined
[16:39] *** leah2 left
[16:40] <poohman> hello all, I was searching for using grammars in Binary streams - as far as I could find there were a few searches for this earlier and it seems like Raku does not support this as of now

[16:41] <poohman> I have seem some excellent work by dwarring in the pdf grammar module - he has done something like that

[16:42] <poohman> should I go for something like Katai Structs or can I try in Raku

[16:42] <poohman> we have Perl bindings for Katai Structs

[16:43] <poohman> any suggestions or ideas?

[16:43] <guifa> poohman: I‚Äôm working on binary grammars but I don‚Äôt have them ready yet, but you can check out the project here

[16:43] <guifa> https://github.com/alabamenhu/BinexObjex

[16:44] <poohman> hi guifa, thanks, Ill have a look

[16:44] <poohman> guifa, just curious - have you looked at Katai Structs?

[16:44] <guifa> Be warned there‚Äôs probably lots of bugs, I haven‚Äôt touched it in a bit as I‚Äôm waiting for RakuAST to be released

[16:45] <poohman> sure thanks for the heads up

[16:45] <guifa> Yeah, Binex is designed to be similar, except run more like Raku grammars with mostly the same syntax.  

[16:45] <guifa> If you‚Äôre familiar with Katai already

[16:46] <guifa> I‚Äôd look into just using the Perl module in Raku

[16:47] <poohman> ok thanks

[16:47] <codesections> m: my ($hello, $world) =  ([Z] ("hello", Nil), ((), 'John')).map({.head // .tail})

[16:47] <camelia> rakudo-moar 798614cb7: ( no output )

[16:47] <codesections> m: say my ($hello, $world) =  ([Z] ("hello", Nil), ((), 'John')).map({.head // .tail})

[16:47] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´(hello John)‚ê§¬ª

[16:47] <guifa> o.O

[16:47] <guifa> That  is one of the ugliest lines of code I‚Äôve seen in a while ;-)

[16:48] <codesections> demostanis: ^^^ alternate syntax that's probably less useful than `in default` but might be better in some cases

[16:48] <codesections> :D

[16:49] *** leah2 joined
[16:49] <codesections> well, it lets you do something like `my ($a, $b) = ([Z] get-values, $defaults).map({.head // .tail})` if you already have defaults defined

[16:50] <codesections> (and I just like zipping lists, what can I say?)

[16:52] <codesections> I know `when` and using a literal regex will automatically smartmatch against the topic if no other smartmatch is provided.  Is there any other case where Raku does that auto-aginst-the-topic behavior?

[16:53] <rypervenche> In a sink context.

[16:54] <rypervenche> From the regexes doc: In case a Regex object is used in sink context, or in a context in which it is coerced to Bool, the topic variable $_ is automatically matched against it:

[16:55] <codesections> Right, that's a better/more technical way to say what I meant.  I know regex will auto-match against the topic (in sink contexts).  And I know `when` will too.  Are there any other catigories besides those two?

[16:56] <guifa> I can‚Äôt think of any off the top of my head

[16:56] <codesections> Thanks

[16:56] <guifa> It‚Äôs sort of a very Perl-esque way to do things

[16:56] <guifa> (and one of the few that Raku moved slightly away from)

[16:57] <codesections> Oh?  How so?  I don't know Perl

[16:57] <guifa> So in perl, the topic was reset with each operation

[16:57] <demostanis> codesections: I think I'm too new to Raku to understand your piece of code

[16:57] <guifa> my $a = 5; # now $_ = 5

[16:57] <guifa> my @b = 1,2,3; # now $_ is 1,2,3

[16:58] *** domidumont joined
[16:58] <guifa> pop

[16:58] *** domidumont left
[16:58] <guifa> # now b is 1,2; and $_ is 3

[16:58] <codesections> Ah, interesting

[16:58] <guifa> I don‚Äôt think either way is per se better, but it‚Äôs important to be consistent with either one 

[16:59] <guifa> That said

[16:59] <guifa> I wonder if I can catch the topic variable 

[16:59] <guifa> in a sub, I mean

[17:00] *** zacts joined
[17:00] <guifa> Yup 

[17:00] <guifa> sub foo { say CALLER::<$_> }; for ^3 {¬†foo }

[17:00] <guifa> m: sub foo { say CALLER::<$_> }; for ^3 {¬†foo }

[17:00] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´Cannot access '$_' through CALLER, because it is not declared as dynamic‚ê§  in sub foo at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:00] <guifa> hmmmm

[17:01] <codesections> Raku lets you do chained assignment, so you could do $_ = my $a = 5

[17:01] * guifa thinks this is a (relatively) recent change.  It‚Äôs working on TIO

[17:01] <guifa> But it makes sense for $_ to not be dynamic

[17:02] *** stoned75 left
[17:02] <guifa> That said, $/ is dynamic.  So you can totally much with it if you want

[17:04] *** demostanis left
[17:14] *** Altai-man joined
[17:16] *** sena_kun left
[17:18] *** wamba joined
[17:20] *** melezhik joined
[17:21] <melezhik> .tell demostanis: "sparrowfile ...  isn't being fetched from an untrusted somewhere else" - correct 

[17:21] <tellable6> melezhik, I'll pass your message to demostanis

[17:29] *** natrys joined
[17:30] *** melezhik left
[17:43] *** lichtkind left
[17:45] <guifa> I wish it using the $^args were a bit more forgiving on number of arguments ‚Äî¬†basically, ignoring additional ones

[17:49] *** poohman left
[17:52] *** aluaces left
[17:53] *** mowcat joined
[18:08] *** ensamvarg3 left
[18:08] *** zacts left
[18:09] *** zacts joined
[18:13] *** lichtkind joined
[18:13] *** xinming_ joined
[18:14] *** mowcat left
[18:14] *** mowcat joined
[18:16] *** xinming left
[18:21] <codesections> you mean so that you could do something like `my &f = { say $^a }; f(1, 2)` without getting an error?

[18:21] <guifa2> yeah

[18:22] <guifa2> I have a giant hash of callables and all of them need $a, most need $b, and a small handful need $c

[18:22] <guifa2> I was using {sink $^b; $^a.foo } for those that didn't need $b

[18:23] <guifa2> but once I realized I needed $c‚Ä¶ it just feels wasteful

[18:24] <guifa2> using @^foo defeats the naming advantage.  ah well

[18:24] <guifa2> I'll just give them all a signature.  It's just already a huuuuuuuuge hash with long lines because I'm trying to do one line  per entry

[18:25] <codesections> is there a way to do named formal args?  something like `%^:a`?  

[18:25] *** cpan-raku left
[18:26] <codesections> Probably not, "named formal arguments" sounds like a contradiction 

[18:27] <Altai-man> codesections, yeah.

[18:27] <Altai-man> m: { say $:hehe }(hehe => 42)

[18:27] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´42‚ê§¬ª

[18:27] <Altai-man> codesections, ^

[18:27] <Altai-man> m: { say $^foo }(42)

[18:27] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´42‚ê§¬ª

[18:27] <Altai-man> ^ positional formal one

[18:28] <codesections> guifa: Would the named variant ^^^ solve your use case

[18:28] <codesections> ?

[18:29] <guifa2> WHOA

[18:29] <guifa2> I had no idea you could twiggle with colons

[18:30] <guifa2> although it is clearly documented so I s'pose I should have

[18:31] <guifa2> That's perfect for me, actually since it helps for self documenting on the calling side

[18:32] <codesections> m: my &f = {say $:a }; f(a=>0, b=>2) 

[18:32] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´Unexpected named argument 'b' passed‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[18:32] <codesections> Do you run into that error ^^^ ?

[18:32] <guifa2> ouch

[18:33] * guifa2 hadn't tried it yet 

[18:33] *** domidumont joined
[18:35] <guifa2> formal signature it is then

[18:35] <codesections> This is a bit sloppy/less safe, but you could use dynamic formal variables:

[18:35] <codesections> m: my &f = {say $:a }; f(a=>0, b=>2) 

[18:35] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´Unexpected named argument 'b' passed‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[18:36] <codesections> m:  my &f = {say $*a }; { my $*a = 0; f}

[18:36] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´0‚ê§¬ª

[18:36] <codesections> (sorry, wrong paste the fist time)

[18:36] *** domidumont left
[18:36] <xinming_> my $c = \(1, 2, 3, :a<b>, "a" => 1); [$c.list, $c.hash].raku.say;

[18:36] <evalable6> xinming_, rakudo-moar 798614cb7: OUTPUT: ¬´[(1, 2, 3, :a(1)), Map.new((:a("b")))]‚ê§¬ª

[18:37] <CIAvash> guifa2: If understood you correctly, you can use `@_ ` inside your sub to refer to parameters

[18:37] <xinming_> Inthis example, what if both :a<b>, and "a" => 1  are in a scalar, How can we let raku DWIM?

[18:39] <xinming_> the quoted "a" => 1 will be put into list, while :a<b> will be in hash. What if we use slip, and they are all in an array, where the array contains list of pairs?

[18:39] <guifa2> CIAvash: indeed, but using @_ means you lose the semantic connection to the variables.  (%_ is a possibility, but this is a hot enough loop that hash access is a major slowdown).  I'll try with the dynamics

[18:39] <codesections> CIAvash: ooh, I knew about @_, but you saying that made me realize that there's also `%_` 

[18:39] <xinming_> That makes me quite curious, wether this is handled in syntax level

[18:41] <codesections> Wow, that's a pretty hot loop ‚Äì *Hash access* is too slow?  Does Raku do something weird where Hash access isn't O(1), or is it just the time of dereferencing the pointers that's too slow?

[18:41] <guifa2> m: my $c = \(1, 2, 3, "a" => 1, :a<b>, ); [$c.list, $c.hash].raku.say;

[18:41] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´[(1, 2, 3, :a(1)), Map.new((:a("b")))]‚ê§¬ª

[18:41] <timotimo> where can i see the code? :)

[18:43] <guifa2> codesections: it's O(1), but hash access compared to attribute access is hugely different.  I can't imagine hash access being faster than access bound arguments

[18:43] <guifa2> When you have %hash<a><b><c><d><e><f><g><h><i><j> over and over again haha

[18:44] <codesections> Yeah, that *is* a lot of indirection :)

[18:44] *** bocaneri left
[18:45] <guifa2> When I mentioned needing a $c, it's because I've been passing in something around, say, level E up there to avoid a few levels of calls, but suddenly I needed a sister element of E that I can only access from C level.  

[18:46] <guifa2> timotimo: you can see the old monstrosity code here: https://github.com/alabamenhu/Intl-CLDR/blob/master/lib/Intl/Format/DateTime.pm6 

[18:46] *** raku-bridge1 joined
[18:46] *** cpan-raku joined
[18:46] *** cpan-raku left
[18:46] *** cpan-raku joined
[18:46] <guifa2> I'm converting the giant given/when into a single hash whose keys are <a aa aaa aaaa aaaaa A AA AAA AAAA AAAAA>, etc, which should be a good bit faster

[18:47] <guifa2> but then have to deal with passing vars into the callable values

[18:48] <timotimo> the "for @pattern" loop?

[18:50] <codesections> Makes sense.  Dynamic variables enclosed in a lexical block to limit their scope otherwise seem like a good fit for that usecase

[18:50] <guifa2> Yeah.  What I was thinking about doing is in the pattern parsing action, just return a list of callables.

[18:50] <codesections> Even though I don't love dynamic variables for many use cases

[18:51] <guifa2> @pattern¬ª.(args‚Ä¶).join

[18:51] <guifa2> (the current version can only generate a handful of patterns a second which is‚Ä¶ awful lol)

[18:52] <guifa2> s/generate/format

[18:56] *** Geth joined
[18:58] *** raku-bridge1 left
[18:58] *** raku-bridge2 joined
[19:00] *** wamba left
[19:01] *** raku-bridge2 left
[19:02] *** [Sno] joined
[19:02] *** Geth_ left
[19:02] *** raku-bridge3 joined
[19:03] *** raku-bridge3 left
[19:03] *** raku-bridge4 joined
[19:06] *** raku-bridge4 left
[19:07] *** raku-bridge5 joined
[19:08] *** raku-bridge5 left
[19:09] *** raku-bridge6 joined
[19:11] <timotimo> oof

[19:11] <timotimo> did you try to --profile it, or run any other kind of profiler at it?

[19:14] <guifa2> timotimo: the html profiler can't locate a file for me.  Is there a way to cleanly view the SQL file generated?  I couldn't find info on that but I probably just missed them

[19:14] <timotimo> moarperf will display all the info from the sql for you

[19:15] *** sena_kun joined
[19:16] *** molaf left
[19:16] *** Altai-man left
[19:17] *** raku-bridge6 left
[19:18] <timotimo> https://github.com/Raku/nqp/pull/354#issuecomment-296382898 - also check this out; it will need a rename or two of the variables, though

[19:18] *** raku-bridge7 joined
[19:18] *** raku-bridge7 left
[19:18] *** raku-bridge7 joined
[19:19] <guifa2> timotimo++

[19:19] <guifa2> There's a LOT of perf tuning I need to do for Intl

[19:26] *** raku-bridge7 left
[19:26] *** raku-bridge8 joined
[19:26] *** raku-bridge8 left
[19:27] *** Geth_ joined
[19:27] *** Geth left
[19:27] *** cpan-raku left
[19:28] *** raku-bridge1 joined
[19:35] *** raku-bridge left
[19:35] *** raku-bridge1 is now known as raku-bridge

[19:35] *** sjm_uk left
[19:44] *** cpan-raku joined
[19:44] *** cpan-raku left
[19:44] *** cpan-raku joined
[19:47] *** raku-bridge left
[19:48] *** Geth_ left
[19:48] *** cpan-raku left
[19:49] *** Geth joined
[19:50] *** raku-bridge joined
[19:50] *** raku-bridge left
[19:50] *** raku-bridge joined
[20:06] *** ab5tract joined
[20:07] *** raku-bridge left
[20:07] *** raku-bridge joined
[20:08] *** cpan-raku joined
[20:08] *** cpan-raku left
[20:08] *** cpan-raku joined
[20:10] <guifa> codesections timotimo here‚Äôs a quick mockup of the speed difference between arguments and dynamics

[20:10] <guifa> https://bit.ly/2XKD38D

[20:11] <guifa> dynamics are ~5x slower

[20:11] <timotimo> even with our dynamic variable cache, they aren't extremely fast

[20:12] <timotimo> arguments, on the other hand, tend to be extremely well optimized

[20:12] <guifa> Yeah, so that definitely pushes me to making all of my little code blocks get a signature

[20:16] <guifa> Actually interesting

[20:17] *** Kaiepi left
[20:17] <guifa> It‚Äôs FASTER to pass containers

[20:18] <guifa> I would have thought binding everything and passing in contextless/sigiless vars would have been faster

[20:19] <timotimo> optimizer performance can be a bit "bumpy"

[20:19] <guifa> But consistently it‚Äôs about a 1 : 2.5 : 5 performance ration between $args, \args and $*args

[20:20] <guifa> yeah, I know stuff isn‚Äôt crazy optimized yet, so I swear I‚Äôm not trying to prematurely optimize

[20:20] *** rir joined
[20:20] <timotimo> unexpected things can prevent some optimizations, is what i mean

[20:20] <timotimo> so the impact can be surprising

[20:21] *** Geth left
[20:22] *** aluaces joined
[20:22] <guifa> indeed

[20:22] *** aluaces is now known as alberto

[20:22] <guifa> More testing actually shows that‚Ä¶ it‚Äôs having an explicit signature

[20:22] <ab5tract> .tell JJMerelo if you could send the invite to my email in CONTRIBUTORS that would be awesome. if not, no worries -- the post will be live and pre-published for Tuesday mid-morning tomorrow no matter what

[20:22] <tellable6> ab5tract, I'll pass your message to JJMerelo

[20:23] *** Geth joined
[20:23] *** raku-bridge left
[20:23] *** alberto is now known as Guest2056

[20:23] <guifa> -> $a, $b, $c {¬†$a + $b + $c }   vs { $^a + $^b + $^c }

[20:23] <guifa> I would have thought that they were functinoal identical but that‚Äôs not the case, it turns out

[20:23] <guifa> err s/functionally identical/compile identically

[20:23] *** raku-bridge joined
[20:23] *** raku-bridge left
[20:23] *** raku-bridge joined
[20:26] <timotimo> that's the speed difference?

[20:27] <guifa> yeah

[20:27] *** raku-bridge left
[20:27] *** raku-bridge joined
[20:27] *** raku-bridge left
[20:27] *** raku-bridge joined
[20:27] <guifa> Granted, I‚Äôm testing this on TIO, so I should probably go and do it on a newer version; one sec

[20:28] <guifa> same results on 2020.01

[20:29] <guifa> Although the ratio is now more like 1 : 2 : 3

[20:30] <codesections> very interesting

[20:32] *** Kaiepi joined
[20:33] <codesections> Here's the output I get from your Tio script on 2020.06:

[20:33] <codesections> arg in 0.04354408

[20:33] <codesections> dyn in 0.06789509

[20:33] <codesections> arg in 0.0064172

[20:33] <codesections> dyn in 0.0642456

[20:33] <codesections> arg in 0.0064169

[20:33] <codesections> dyn in 0.0639006

[20:34] <codesections> It looks like they're not *that* different to start with, but the dynamic variable prevents optimization in later calls (I bet it prevents the function inlined, though that doesn't entierly make sense) over time

[20:39] *** Geth left
[20:39] *** cpan-raku left
[20:39] *** raku-bridge left
[20:41] *** Geth joined
[20:41] <sena_kun> sourceable6, 1+2

[20:41] <sourceable6> sena_kun, No idea, boss. Can you give me a Code object?

[20:42] *** cpan-raku joined
[20:42] *** cpan-raku left
[20:42] *** cpan-raku joined
[20:42] *** raku-bridge joined
[20:42] *** raku-bridge left
[20:42] *** raku-bridge joined
[20:42] <sena_kun> sourceable6, &infix:<+>;

[20:42] <sourceable6> sena_kun, https://github.com/rakudo/rakudo/blob/798614c/src/core.c/Numeric.pm6#L208

[20:42] <AlexDaniel`> sourcable6: 1 + 2

[20:42] <sourceable6> AlexDaniel`, https://github.com/rakudo/rakudo/blob/798614c/src/core.c/Int.pm6#L335

[20:42] <coverable6> AlexDaniel`, and I oop! Backtrace: https://gist.github.com/10ebb3922e67f2a5afc44f2bc74e004d

[20:43] *** rindolf left
[20:43] <AlexDaniel`> sena_kun: seems like it wants spaces

[20:43] <sena_kun> So be it, could trigger it anway. ;)

[20:44] *** ab5tract left
[20:47] *** Black_Ribbon joined
[20:49] <AlexDaniel> sena_kun: yes but that particular candidate is in a different file :)

[20:50] <sena_kun> Oh, you are right. To be honest, I was expecting to find where `is assoc` is set, but I suspect it is somewhere deeper in the guts, really, and I don't want to increase size of my article which is already pretty big.

[20:54] <guifa2> codesections: the first run is the slowest, but once they heat up, you can see it's an order of magnitude.  Although when I got the 1:2:3 I upped the repetition count by an order of magnitude too

[20:54] <AlexDaniel> sena_kun: https://github.com/rakudo/rakudo/blob/798614cb788ff80cea6dd92cb05d61af95ae8304/src/Perl6/Grammar.nqp#L3666

[20:55] <AlexDaniel> sena_kun: and also: https://github.com/rakudo/rakudo/blob/798614cb788ff80cea6dd92cb05d61af95ae8304/src/Perl6/Grammar.nqp#L4106

[20:56] <rir> Could not @Demostanis have just used  `my $v = something() // default;` in his proto  function.  (I'm late for reading the docs and interruptions.)

[20:56] <sena_kun> AlexDaniel, what a nice low-levelness.

[20:57] <AlexDaniel> sena_kun: I don't know why it's there

[20:57] <AlexDaniel> maybe jnthn has a long explanation

[20:57] <codesections> Well, I guess I'm curious about the "once they heat up" part.  I assume a lot of that is from warming the cache or giving the JIT more info to work with.  Which is what I mean by saying that the dyn variable seems not to prevent inlining or something

[20:58] <codesections> guifa ^^

[20:58] <sena_kun> Well, it's no wonder fundamental operators to run things are implemented using low-level bits.

[20:58] <AlexDaniel> sena_kun: it's not fundamental operators, it's all operators

[20:58] <AlexDaniel> sena_kun: maybe it has something to do with the penalty involved when defining new operators

[20:58] <codesections> rir: If I remember that conversation correctly, no, that's what they wanted to be able to do but that isn't valid syntax (though I'd love to be wrong if you have a working example!)

[20:59] <sena_kun> AlexDaniel, fair enough.

[20:59] <guifa2> codesections: Replace the dynamic would with a &explicity = -> $a, $b, $c, $d, $e, $f, $g {¬†$a+$b+$c+$d+$e+$f+$g }; there shouldn't be a problem inlining that one though, which is weird

[21:01] *** molaf joined
[21:02] <AlexDaniel> m: sub foo{ multi infix:<+>(42, 42) { ‚Äòyes‚Äô } }; say 42 + 42

[21:02] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´84‚ê§¬ª

[21:02] <AlexDaniel> hmmmm

[21:02] <AlexDaniel> cool

[21:03] <guifa2> AlexDaniel: meh, kind of.  But it also means defining operators for new classes sucks :-(

[21:03] <AlexDaniel> guifa2: why?

[21:04] <guifa2> Lemme put together an example of when it can go awry

[21:05] <AlexDaniel> I always thought that it is actually as good as it can be because someone's custom operators can never affect my code

[21:05] <AlexDaniel> some may be surprised to hear that but it's part of Raku that I truly like :)

[21:06] <sena_kun> guifa2, you are very welcome to provide an example. :)

[21:09] <AlexDaniel> sena_kun: why tho, lemme have something I like xD

[21:09] <guifa2> https://tio.run/##K0gtyjH7/78gMTk7MT1VwS0/X6GaS0EhOSexuFjBUaFaITe1JCM/RcGvNDe1KDNZofrQAgOFWoVaoBogyi3NKclUKC5NUsjMS8ussLLRttNwVFDJ1AFqVcnSBKk2MQIrLk6sBIppKzhac9VygThAm6ysQCIQxv//AA

[21:09] <rir>  p6: proto p(Any $x |) { my $v = $x // 'Default' } ; sub nil { return Nil } ; sub one { return 1 } ;  p( nil()).say;  p( one()).say;

[21:09] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Malformed parameter‚ê§at <tmp>:1‚ê§------> 3proto p(Any $x7‚èè5 |) { my $v = $x // 'Default' } ; sub ni‚ê§    expecting any of:‚ê§        constraint‚ê§¬ª

[21:10] <rir>  p6: proto p(Any $x, |) { my $v = $x // 'Default' } ; sub nil { return Nil } ; sub one { return 1 } ;  p( nil()).say;  p( one()).say;

[21:10] <camelia> rakudo-moar 798614cb7: OUTPUT: ¬´Default‚ê§1‚ê§¬ª

[21:10] <sena_kun> AlexDaniel, I am writing an article about operators applied to objects right now and that'll suck to suggest it to get people tell me "Bah, this is just wrong and bad".

[21:11] <AlexDaniel> right

[21:12] <codesections> rir: oooh, I see what you mean!  That *is* a nice solution, even compared to the `is Default` idea guifa had ‚Äì and *especially* compared to the ugly zipping code I produced :D

[21:12] <sena_kun> So input on the topic is very helpful, I guess.

[21:13] <guifa2> Compare the difference to making something Associative by just defining AT-KEY, etc, and viol√† any object handles the built in post circumfixes as they feel is correct

[21:13] <AlexDaniel> guifa2: isn't it a bug? I'm not sure

[21:13] <guifa2> No, that's how it's supposed to work

[21:14] <AlexDaniel> guifa2: not exactly

[21:14] <guifa2> The infix sub isn't in the scope, so the object's math isn't handled correctly

[21:14] <AlexDaniel> guifa2: put it into two different files, slap `is export` on your custom operator

[21:14] <AlexDaniel> and it will work

[21:14] <guifa2> AlexDaniel: right, but now imagine I pass those to *another* module that I don't have control over its imports

[21:14] <guifa2> math goes bad, even though I'm not expecting it to

[21:15] <AlexDaniel> hm‚Ä¶ actually good point, it's hard to tell if it's imported or not‚Ä¶

[21:15] <guifa2> I don't really know if there's a great solution, TBH

[21:15] <AlexDaniel> so it's better to create a new op instead of using a multi on +

[21:16] <guifa2> Actually

[21:16] <guifa2> I wonder

[21:16] <guifa2> Is it possible to wrap an infix? 

[21:16] * guifa2 has evil thoughts in his head 

[21:17] <AlexDaniel> guifa2: well, there are plenty of tools for evil thoughts, operator wrappers is just one of them

[21:17] <AlexDaniel> so yeah, every included module is a potential security issue for your data

[21:18] <AlexDaniel> but I guess that's true in most languages, so ü§∑

[21:18] <codesections>  I'm kind of surprised more operators aren't implemented as methods (instead of subs) the way `{}` is

[21:19] <codesections> Before looking, I expected `1 + 2` to desuggar into `1.ADD(2)` instead of (effectively) `add(1, 2)`

[21:19] <guifa2> AlexDaniel: I may have just gotten done doing some massive (but cool) hacking into DateTime to add TZ support

[21:20] <guifa2> It's actually quite hard to do things with guaranteed global effect, I've found, which is sometimes what we want

[21:20] <AlexDaniel> guifa2: ‚Ä¶ how do I export a custom operator?

[21:21] <codesections> (I know it's really `infix:<1>(1, 2)`, but that's still calling a sub with arguments)

[21:21] *** natrys left
[21:22] <codesections> If 1 + 2 *was* 1.ADD(2), then the owner of a class would never have to worry about operators not working the way they want ‚Äì if they're concerned, they could overwrite any method they'd inherited 

[21:23] <AlexDaniel> codesections: unless the object of their class is on the right hand side

[21:23] <AlexDaniel> :)

[21:23] <codesections> haha, fair point!

[21:23] <guifa2> This is actually getting close to the issue of coercions

[21:24] <guifa2> Which is one we almost had solved but it never got implemented for some reason

[21:25] <guifa2> let's say I have a custom class Foo.  I can write its coercer to Str by just doing method Str {¬†‚Ä¶¬†}, so if someone's elses signature is (Str() $bar), my class can be used

[21:25] <guifa2> But I can't write a signature like (Foo() $bar) and have someone pass in a Str to be coerced, even if it's possible

[21:26] <guifa2> I mean, there's augmenting, but that requires monkey typing, breaks precompilation, etc

[21:27] *** bocaneri joined
[21:27] <guifa2> https://github.com/Raku/problem-solving/issues/137

[21:27] <AlexDaniel> guifa2: how do you solve that without monkey typing?

[21:28] <AlexDaniel> ah, okay, I see the discussion

[21:29] <guifa2> Without monkey tying ‚Ä¶¬†Str.^add_fallback( -> $a, $b {¬†$b eq 'MyClass' }, -> $a, $b {¬†anon method (-->MyClass) {¬†‚Ä¶¬†}¬†} )

[21:29] <guifa2> lol

[21:30] <guifa2> where ‚Ä¶¬†is the actual coercion method

[21:30] <guifa2> Like I said, I've been digging deep to pull off DateTime without monkey type haha

[21:34] <rir> It seems like it might be possible to augment early once.   Somthing like a special case for `use X; augment X { ... }`. 

[21:34] <rir> This is to conflate the two statements into one.

[21:39] <rir> I mean as a language enhancement.  So no joy to guifa2 today.

[21:43] <guifa2> rir: theoretically, I suppose, one could do that in a BEGIN statement

[21:44] <guifa2> But again, it would require a recompile of any module that uses that class

[21:45] <guifa2> AlexDaniel: as to the rest of my solutions, I'm saving it for a giant advent day post in December ;-)

[21:49] *** vike left
[21:53] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2020/08/09/whereceptions/

[21:56] <guifa2> gfldex++

[21:57] *** mowcat left
[22:01] <Geth> ¬¶ advent: 6f001c633f | Altai-man++ (committed using GitHub Web editor) | 20th/README.md

[22:01] <Geth> ¬¶ advent: Resign an article

[22:01] <Geth> ¬¶ advent: 

[22:01] <Geth> ¬¶ advent: One's will to live was clearly overestimated with this.

[22:01] <Geth> ¬¶ advent: review: https://github.com/Raku/advent/commit/6f001c633f

[22:02] *** rir left
[22:04] *** stu002 joined
[22:14] *** Altai-man joined
[22:16] *** sena_kun left
[22:17] <raku-bridge> <stu002> I'm looking for examples of custom numeric types implemented in Raku, especially the idiomatic ways of coercing built-in ints, nums, rats etc into the custom numeric type.

[22:19] *** zacts left
[22:19] <raku-bridge> <stu002> This is to avoid monkey typing the built-in numeric types as described in https://www.nntp.perl.org/group/perl.perl6.users/2020/08/msg9054.html

[22:37] *** zacts joined
[22:37] *** zacts left
[22:37] *** zacts joined
[22:43] <guifa> stu002: let me type up a soution for you

[22:46] <raku-bridge> <stu002> guifa: that would be wonderful

[22:46] <guifa> It‚Äôs semi-hacky

[22:47] <raku-bridge> <stu002> At the moment I'm using custom classes "class MyInt is Int does AddMagma ...". But it made me wonder about support for wrapping or delegating to a class in a standard way.

[22:52] <raku-bridge> <stu002> And FWIW I've been using infix operators like this: sub infix:<‚äô>(Magma:D \x, Magma:D \y) of Magma:D is export {   x.op(y) }

[22:52] *** leont left
[22:52] <raku-bridge> <stu002> But when I (wrongly) made that multi sub infix:<‚äô>(Magma:D \x, Magma:D \y) of Magma:D is export {   x.op(y) } the raku compiler segfaults

[22:58] <raku-bridge> <stu002> SO I

[22:58] <guifa> stu002: https://gist.github.com/alabamenhu/1b60015fbaabc819aeabff4d112678e1

[23:00] <raku-bridge> <stu002> guifa: that's very insightful, many thanks

[23:02] <raku-bridge> <stu002> I need to stop thinking in Haskell and Rust where implementing a trait for a built-in type is not the same as in Raku.

[23:06] <guifa> stu002: in theory, there shouldn‚Äôt be a problem with augmenting so long as you don‚Äôt have any overlapping methods, etc.

[23:07] <guifa> so you could feel free to just say augment Int {¬†method Percent {¬†‚Ä¶¬†}¬†}

[23:09] <raku-bridge> <stu002> guifa: is augmenting "global" in scope -- i.e. would someone use-ing a module that has augments get a surprise when their built-in numeric types have methods and attributes not in the standard docs?

[23:09] <guifa> Yes

[23:10] <guifa> Whether that‚Äôs a good thing or not depends on how badly you‚Äôre messing with their built ins ;-)

[23:10] <raku-bridge> <stu002> That alone is probably good reason not to augment the built-in types I guess. If I could augment just in some example or test modules and not globally I would do it.

[23:11] <guifa> So you can use that fallback method I just sent you

[23:11] <guifa> It‚Äôs also global BUT notice the condition method

[23:11] <raku-bridge> <stu002> guifa: I'll try and come up with a minimal working example of the compiler segfault issue

[23:11] <guifa> You can always insert a dynamic variable check

[23:12] <raku-bridge> <stu002> guifa: yes, that example is very neat.  I feel like I'm not even scratching the surface of what Raku can do.

[23:12] <guifa> $*ALLOW-PERCENT-COERCION && $method-name eq ‚ÄòPercent‚Äô

[23:16] <guifa> https://tio.run/##hY7NCoJAFIX3PsWBREtMbFELo0XtAqFFQbtidMayxpkax4WEz26mItSmu7hw@e75eTDFF3W9Fdo7EUrPCeE8IvE9gIFmiJACeREhloKmOm0ujJtnmDK6sVi72GsFM2P6KulUkIxN8ILprMNwd4RlfSGwJ@xNerFRuT/uhMcFJ1qq/@6tElBMF0qgY60q@ET3dOA54wkczHzf71FldNsYZeXQdIWDKtjSyEmJudd0rOs3

[23:16] <guifa> You could do similar with the augment method approach, btu this way it will appear as if the method isn‚Äôt there if you‚Äôve not enabled it

[23:18] <raku-bridge> <stu002> guifa: very neat.

[23:18] <guifa> (otoh, it also won‚Äôt appear if they do .^methods, but you win some, you lose some)

[23:19] *** lichtkind left
[23:25] <rypervenche> Oh, I was going to submit a PR to have the .perl changed to .raku in the examples on raku.org, but it seems there's already one there from May.

