[00:06] *** Success joined
[00:06] *** Success left
[00:06] *** Success joined
[00:10] *** Aliv3 left
[00:11] *** Aliv3 joined
[00:13] *** Success left
[00:19] *** Aliv3 left
[00:22] *** Success joined
[00:30] *** Success left
[00:31] *** Success joined
[00:31] *** Success left
[00:31] *** Success joined
[00:35] *** Black_Ribbon left
[00:42] *** aborazmeh joined
[00:42] *** aborazmeh left
[00:42] *** aborazmeh joined
[00:46] *** xinming left
[00:46] *** xinming joined
[00:54] *** szqdsegrhrdgdrg joined
[00:55] <szqdsegrhrdgdrg> hi

[00:55] <szqdsegrhrdgdrg> Perl7 is out !

[00:55] <szqdsegrhrdgdrg> Python is dead

[00:55] <szqdsegrhrdgdrg> Ruby is dead

[00:55] <szqdsegrhrdgdrg> Raku is dead

[00:55] <szqdsegrhrdgdrg> Perl7 is out !

[00:57] *** leont left
[00:59] *** xinming left
[00:59] *** Success left
[00:59] *** xinming joined
[01:06] *** lizmat left
[01:19] *** molaf left
[01:25] *** Doc_Holliwood left
[01:27] *** szqdsegrhrdgdrg left
[01:28] <cpan-raku> New module released to CPAN! Tomty (0.0.12) by 03MELEZHIK

[01:29] *** xinming left
[01:29] *** xinming joined
[01:31] *** molaf joined
[01:46] *** aborazmeh left
[01:53] *** xinming left
[01:55] *** xinming joined
[02:03] *** Manifest0 left
[02:05] *** Manifest0 joined
[02:08] *** BenGoldberg left
[02:08] *** Ben_Goldberg joined
[02:08] *** Ben_Goldberg is now known as BenGoldberg

[02:15] *** MasterDuke left
[02:45] *** xinming left
[02:47] *** xinming joined
[02:49] *** sena_kun joined
[02:54] *** sena_kun left
[02:56] *** sena_kun joined
[03:05] *** sena_kun left
[03:08] *** rir joined
[03:10] *** rir left
[03:21] *** xinming left
[03:21] *** xinming joined
[03:28] *** gnufr33dom left
[03:40] *** Guest82400 is now known as aluaces

[04:13] *** Success joined
[04:17] *** Success left
[04:37] *** BenGoldberg left
[04:38] *** xinming left
[04:39] *** xinming joined
[04:54] *** skids left
[05:03] *** jmerelo joined
[05:19] *** Doc_Holliwood joined
[05:40] *** bocaneri joined
[05:53] *** maettu joined
[05:55] *** molaf left
[05:58] *** xinming left
[05:59] *** xinming joined
[05:59] *** ufobat_ joined
[06:27] *** xinming left
[06:27] *** xinming joined
[06:45] *** xinming left
[06:46] *** xinming joined
[06:55] *** MasterDuke joined
[07:11] *** Manifest0 left
[07:12] *** xinming left
[07:12] *** xinming joined
[07:16] *** Manifest0 joined
[07:28] *** BenGoldberg joined
[07:30] *** xinming left
[07:30] *** xinming joined
[07:38] *** Sgeo left
[07:47] *** dakkar joined
[07:53] *** xinming left
[07:53] *** xinming joined
[07:57] *** frost-lab joined
[08:02] *** BenGoldberg left
[08:24] *** pecastro joined
[08:45] *** qqwe joined
[08:46] *** jmerelo left
[08:47] *** qqwe left
[08:51] *** maettu left
[08:51] *** rindolf joined
[09:07] <El_Che> szqdsegrhrdgdrg eloquence convinced me

[09:11] *** lizmat joined
[09:13] *** MasterDuke left
[09:14] *** xinming left
[09:14] *** xinming joined
[09:28] *** MasterDuke joined
[09:28] *** pecastro left
[09:30] *** lizmat_ joined
[09:33] *** lizmat left
[09:39] *** xinming left
[09:40] *** xinming joined
[09:53] *** frost-lab left
[09:54] *** frost-lab joined
[09:54] *** lizmat_ is now known as lizmat

[09:54] * lizmat clickbaits https://rakudoweekly.blog/2020/10/12/2020-41-a-first-year/

[09:57] *** wamba joined
[10:12] * Altreus clicks

[10:12] <Altreus> Damn! Baited

[10:16] <lizmat> :-)

[10:22] *** Doc_Holliwould joined
[10:25] *** xinming left
[10:26] *** Doc_Holliwood left
[10:27] *** xinming joined
[10:45] *** xinming left
[10:45] *** xinming joined
[10:53] *** BenGoldberg joined
[10:55] *** _jrjsmrtn joined
[10:55] *** __jrjsmrtn__ left
[11:02] *** xelxebar left
[11:02] *** xelxebar joined
[11:09] *** Doc_Holliwould left
[11:09] *** aborazmeh joined
[11:09] *** aborazmeh left
[11:09] *** aborazmeh joined
[11:12] <Altreus> liz is a master ... never mind

[11:13] <lizmat> master elipsis ?

[11:13] <lizmat> :-(

[11:13] <lizmat> :-)  rather  :-)

[11:15] <cpan-raku> New module released to CPAN! Date::Names (2.1.1) by 03TBROWDER

[11:18] <tbrowder> note Date::Names now has eleven languages including a second Norwegian one

[11:22] <Altreus> a bit dotty perhaps

[11:28] *** xinming left
[11:28] *** xinming joined
[11:29] *** BenGoldberg left
[11:39] *** leont joined
[11:48] *** Geth joined
[11:52] *** xinming left
[11:52] *** xinming joined
[12:01] *** Geth_ joined
[12:02] *** Geth left
[12:07] *** aborazmeh left
[12:08] *** xinming left
[12:09] *** domidumont joined
[12:09] *** xinming joined
[12:18] *** maettu joined
[12:26] <kawaii> Do subroutines have any awareness of _where_ they were called from? I.e. if my application has a frontend UI, but also an API - is there a smart way of knowing which module called my routine so that I can adjust the log output accordingly? 

[12:35] *** stux|RC left
[12:37] *** stux|RC joined
[12:40] *** stux|RC left
[12:40] *** stux|RC joined
[12:42] <moritz> kawaii: the caller() function can provide such information

[12:42] <moritz> though I don't know how expensive it is

[12:43] <moritz> might be better design to do that through some other mechanism

[12:44] <tadzik> a dynamic $*LOGGER or something along those lines may be a bit more controllable and predictable

[12:44] <kawaii> moritz: yes I was thinking of just setting a bool in the signature like $api and using that to determine where it came from :)

[12:44] <tadzik> if your routine needs to be aware of its surroundings to log sensibly then it's likely doing a bit too much :)

[12:44] *** aborazmeh joined
[12:44] *** aborazmeh left
[12:44] *** aborazmeh joined
[12:45] *** frost-lab left
[12:47] <Geth_> ¦ problem-solving: lizmat self-assigned Aleks-Daniel Jakimenko-Aleksejev (aka AlexDaniel) is a toxic influence and should be banned from Rakudo https://github.com/Raku/problem-solving/issues/238

[12:55] *** jmerelo joined
[13:09] <Altreus> Is there a Log4Raku or something like that?

[13:15] <lizmat> https://modules.raku.org/search/?q=Log

[13:15] <timotimo> there's a logging framework that seemed pretty sophisticated but i only looked at the readme so far

[13:20] <[Coke]> IWBNI cpan-raku gave me a URL to *something* on cpan.

[13:25] <timotimo> agreed; what would you like?

[13:25] <timotimo> i think cpan-raku may react faster than most places update? certainly modules.raku.org

[13:26] *** Doc_Holliwould joined
[13:29] <moritz> kawaii: also, if your API is a class, you could add an "origin" attribute or so

[13:29] *** jmerelo left
[13:30] <[Coke]> timotimo: if we can't link to the actual module, maybe to the author?

[13:30] <Altreus> likewise, I found LogP6 which looks too complex to grasp at a glance

[13:30] <[Coke]> if we can construct a link that *will* work, use that, even if it takes a minute for it to show up live. Most people are seeing the links in review, after all

[13:31] <timotimo> mh

[13:32] <kawaii> `Log::Timeline` looks good, and I'm already using Cro in my project so I think I'll investigate that option 

[13:34] *** domidumont left
[13:34] <timotimo> it's a bit more special-cased to handle "nested" blocks that are timed, and events that are just points in time, and you can add a datastructure to them

[13:38] <Altreus> I have a feeling that's always the case for logs but we've never noticed before

[13:38] <Altreus> i'm interested in the concept

[13:39] <lizmat> it's the module that powers one of the paid features of Comma  :-)

[13:39] <timotimo> it's very fun to look at

[13:51] *** Sgeo joined
[14:04] *** aborazmeh left
[14:07] *** Doc_Holliwould left
[14:11] *** ggoebel joined
[14:14] <[Coke]> how do we look at CPAN releases of Raku modules?

[14:15] <[Coke]> is https://metacpan.org/author/TBROWDER/releases sufficient to also see Raku? (those look like Raku in that particular folder)

[14:16] <[Coke]> in ../COKE/... they are definitely p5, though

[14:18] <[Coke]> why do I see things in https://metacpan.org/author/COKE/releases that I don't see in https://pause.perl.org/pause/authenquery?ACTION=delete_files ??

[14:19] <[Coke]> (was going to delete some very old things from CPAN, but pause doesn't have them.)

[14:20] *** BenGoldberg joined
[14:20] *** BenGoldberg left
[14:21] *** BenGoldberg joined
[14:27] *** silug joined
[14:30] <ggoebel> zef appears to use the json files here: https://github.com/ugexe/Perl6-ecosystems/

[14:30] <ggoebel> which are generated by https://github.com/ugexe/Perl6-App--ecogen

[14:37] *** guifa joined
[14:37] <guifa> o/

[14:38] <guifa> The libarchive module is giving me some install problems and I’m tryignt o trouble shoot it so I can submit a PR (be it documnentation or code).

[14:42] <guifa> I’m getting the error Cannot locate native library '(null)': dlopen(libarchive.13.dylib, 10): image not found

[14:43] <ggoebel> what version of macos? ...colomon recently mentioned issues with dynamic libraries. let me see if I can track that down.

[14:45] <guifa> ggoebel: I’m on 10.15.6 

[14:45] <guifa> I think the last time I did this install I was on 10.15.[≤4] and it worked okay, but it’s been a while

[14:46] <ggoebel> https://colabti.org/irclogger/irclogger_log/raku?date=2020-10-03#l326

[14:46] <ggoebel> backlogging it now

[14:47] <ggoebel> his workaround was to copying the offending *.dylib to /usr/local/lib

[14:47] <guifa> Ah yikes.  Okay, so it’s definitely not just Libarchive 

[14:48] * guifa tries to remember where homebrew said it had to install libarchive because, hooray, macOS doesn’t like files going in certain places

[14:48] *** cpan-raku left
[14:50] *** cpan-raku joined
[14:50] *** cpan-raku left
[14:50] *** cpan-raku joined
[14:51] <guifa> ggoebel++ you’re a lifesaver

[14:52] <ggoebel> your welcome. but really... colomon++

[14:52] <guifa> also thanks colomon__++ :-)

[14:53] *** BenGoldberg left
[15:03] * colomon__ is wondering what he did

[15:04] <colomon__> Ah, my muddling about with GTK::Simple a week ago.

[15:14] <guifa> https://imgur.com/a/FPZmREG <— yay, my updater script actually worked as expected once I fixed Libarchive

[15:15] *** MilkmanDan left
[15:16] *** MilkmanDan joined
[15:17] *** squashable6 left
[15:17] *** squashable6 joined
[15:17] *** squashable6 left
[15:17] *** squashable6 joined
[15:24] *** MilkmanDan left
[15:25] *** MilkmanDan joined
[15:25] * guifa releases DateTime::Timezones update 

[15:28] *** pecastro joined
[15:29] <ggoebel> guifa++

[15:31] *** rir joined
[15:35] *** pecastro left
[15:41] *** skids joined
[15:47] *** sena_kun joined
[15:49] *** molaf joined
[15:56] *** m_ joined
[16:06] *** jmerelo joined
[16:08] *** vrurg left
[16:23] *** Sgeo left
[16:34] *** dakkar left
[16:37] *** maettu left
[16:40] *** Sgeo joined
[16:44] *** Xliff joined
[16:45] <Xliff> Is there a mechanism to use a portion of a CArray as another CArray?

[16:46] <timotimo> must be CPointer

[16:46] <Xliff> How would that work?

[16:46] <timotimo> nativecast the array to a pointer and increment the pointer, also make sure the array is kept alive by a reference

[16:47] <Xliff> I mean in C it would be: int i[10]; *new_i; new_i = i + 5; new_i[0] == i[4]

[16:48] *** approaching236 joined
[16:48] <Xliff> Or would that be i[5]... haha

[16:48] <timotimo> &i[5] or i + 5

[16:49] <Xliff> Yeah. Long day.

[16:49] <timotimo> i[5] will be of type int, but you want int*

[16:49] <Xliff> At any rate, can we simulate that with NativeCall?

[16:49] <timotimo> yeah

[16:49] <Xliff> Is it in the docs somewhere?

[16:50] <timotimo> m: use NativeCall; my $a = CArray[int].new(1, 2, 3, 4, 5); my $p = nativecast(CPointer[int], $a); say $p.dereference; say ($p + 3).dereference

[16:50] <camelia> rakudo-moar 85847d2f1: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    CPointer used at line 1. Did you mean 'Pointer'?␤␤»

[16:50] <timotimo> m: use NativeCall; my $a = CArray[int].new(1, 2, 3, 4, 5); my $p = nativecast(Pointer[int], $a); say $p.dereference; say ($p + 3).dereference

[16:50] <camelia> rakudo-moar 85847d2f1: OUTPUT: «No such method 'dereference' for invocant of type␤'NativeCall::Types::Pointer[int]'␤  in block <unit> at <tmp> line 1␤␤»

[16:50] <timotimo> m: use NativeCall; my $a = CArray[int].new(1, 2, 3, 4, 5); my $p = nativecast(Pointer[int], $a); say $p.deref; say ($p + 3).deref

[16:50] <camelia> rakudo-moar 85847d2f1: OUTPUT: «1␤No such method 'deref' for invocant of type 'Int'␤  in block <unit> at <tmp> line 1␤␤»

[16:50] <timotimo> that's not the one, hold on

[16:51] <timotimo> m: use NativeCall; my $a = CArray[int].new(1, 2, 3, 4, 5); my $p = nativecast(Pointer[int], $a); say $p.deref; say ($p.add(3)).deref

[16:51] <camelia> rakudo-moar 85847d2f1: OUTPUT: «1␤4␤»

[16:51] <timotimo> m: use NativeCall; my $a = CArray[int].new(1, 2, 3, 4, 5); my $p = nativecast(Pointer[int], $a); say $p.deref; say ($p.add(3)).deref; $p.add(3) = 99; .say for $a[^5]

[16:51] <camelia> rakudo-moar 85847d2f1: OUTPUT: «1␤Cannot modify an immutable NativeCall::Types::Pointer[int] (NativeCall::Types::P...)␤  in block <unit> at <tmp> line 1␤␤4␤»

[16:52] <timotimo> mhh hu?

[16:52] <timotimo> m: use NativeCall; my $a = CArray[int].new(1, 2, 3, 4, 5); my $p = nativecast(Pointer[int], $a); say $p.deref; say ($p.add(3)).deref; $p.add(3)[0] = 99; .say for $a[^5]

[16:52] <camelia> rakudo-moar 85847d2f1: OUTPUT: «1␤Cannot modify an immutable Int (4)␤  in block <unit> at <tmp> line 1␤␤4␤»

[16:52] <timotimo> that's not what i was expecting

[16:56] <Xliff> Yeah.

[16:57] <Xliff> m: use NativeCall; my $a = CArray[int].new(1, 2, 3, 4, 5); my $p = nativecast(Pointer[int], $a); say $p.deref; say ($p.add(3)).deref; $p.add(3).deref = 99;

[16:57] <camelia> rakudo-moar 85847d2f1: OUTPUT: «1␤Cannot modify an immutable Int (4)␤  in block <unit> at <tmp> line 1␤␤4␤»

[16:59] <timotimo> i mean, you can easily-ish turn the pointer to an array and assign to the array's first slot

[16:59] <timotimo> that's not fun to type out, of course

[17:02] *** MilkmanDan left
[17:05] <jdv79> shouldn't type constrained parms win in multi over "non-constrained" or less narrowly constrained?

[17:06] <jdv79> i'm a bit confused how named params factor in general i guess might be it

[17:08] <Xliff> jdv79: Yes. However I've run into issues where params you'd think were more constrained lost to a more permissive variant

[17:08] <Xliff> I have yet to get it to a golfable problem that's not tied to a Significantly Larger effort.

[17:09] <timotimo> named parameters will only rule out candidates if they already match

[17:10] <jdv79> m: https://gist.github.com/jdv/d9b0c26ac52478872e55122c47bdea71

[17:10] <camelia> rakudo-moar 85847d2f1: OUTPUT: «2␤1␤2␤2␤2␤»

[17:10] <jdv79> i would have expected something more like 0␤1␤2␤4␤4␤

[17:11] <timotimo> having 2 there is probably because that's the first one with nameds that fit

[17:11] <timotimo> try switching :$a and :$a, :$b around

[17:13] <Xliff> https://repl.it/@Xliff/LinearGranularTaskscheduling#main.raku

[17:13] <Xliff> I think this will work, for now.

[17:14] <timotimo> Pointer.new($b + 5) <- i would suggest $b.add(5) instead

[17:14] <jdv79> ah, so order of declartion matters - somehow i missed that in the docs i read

[17:14] <timotimo> and of course what you get back from $b[4] is a writable

[17:14] <timotimo> so you could bind that to a scalar and assign to that

[17:15] <Xliff> timotimo: That blows up in repl.it

[17:15] <timotimo> yeah, :$a and :$a, :$b are the same specificity according to the multi dispatch rules (because nameds don't enter into it in the first step)

[17:15] <timotimo> but i'm not exactly sure why the first doesn't get 0

[17:15] <Xliff> timotimo: Was .add introduced later than 2020.07?

[17:15] <timotimo> oh i think i misread that

[17:16] <jdv79> so why does the 0 arity one never get called?  i think that's my last confusion.

[17:16] <timotimo> Xliff: 2017-10-18 last touched that method

[17:16] <jdv79> tried reversing the order to no luck...

[17:16] <timotimo> i've got to AFK for a bit

[17:17] <Xliff> No such method 'add' for invocant of type 'NativeCall::Types::Pointer'

[17:17] <timotimo> maybe the roast tests can be of interest here, but i haven't looked yet

[17:17] <Xliff> So I'll use the + variant until I can find a better way. 

[17:18] <Xliff> This looks to be a usable workaround

[17:18] <jdv79> oh, that's not all - also why does a single named datetime param not hit the sig with datetimes and instead hits the "unconstrained" named sig...

[17:18] <timotimo> Xliff: it should come from TypedPointer

[17:18] <jdv79> timotimo: thanks

[17:19] *** MasterDuke left
[17:19] <Xliff> timotimo: OK. This is the result...

[17:19] <timotimo> Xliff: please check why method ^parameterize in NativeCall/Types.rakumod doesn't seem to give TypedPointer for Pointer[uint8]

[17:19] <timotimo> m: use NativeCall; my $p = Pointer[uint8].new; say $p.^name

[17:19] <camelia> rakudo-moar 85847d2f1: OUTPUT: «NativeCall::Types::Pointer[uint8]␤»

[17:19] <timotimo> m: use NativeCall; my $p = Pointer[int8].new; say $p.^name

[17:19] <camelia> rakudo-moar 85847d2f1: OUTPUT: «NativeCall::Types::Pointer[int8]␤»

[17:19] <timotimo> m: use NativeCall; my $p = Pointer[int8].new; say $p.^roles

[17:19] <camelia> rakudo-moar 85847d2f1: OUTPUT: «((NativeCall::Types::Pointer::TypedPointer[int8]))␤»

[17:19] <timotimo> m: use NativeCall; my $p = Pointer[uint8].new; say $p.^roles

[17:19] <camelia> rakudo-moar 85847d2f1: OUTPUT: «((NativeCall::Types::Pointer::TypedPointer[uint8]))␤»

[17:19] <timotimo> oh, it does

[17:19] <timotimo> m: use NativeCall; my $p = Pointer[uint8].new; say $p.add(1)

[17:20] <camelia> rakudo-moar 85847d2f1: OUTPUT: «NativeCall::Types::Pointer[uint8]<0x1>␤»

[17:20] <Xliff>  Pointer.new($b.add(5)) --> "Default constructor for 'NativeCall::Types::Pointer' only takes named arguments"

[17:20] <timotimo> you said you have 2020.07?

[17:20] <timotimo> yeah, you don't put it into Pointer.new

[17:20] <timotimo> it already returns a Pointer

[17:20] <Xliff> I have fresh blead of the week. 

[17:20] <Xliff> It's repl.it that's got 2020.07

[17:20] <timotimo> raku don't often have "copy constructors"

[17:21] <Xliff> OK, that works!

[17:21] <Xliff> I wonder if I can augment CArray

[17:22] <timotimo> it's a class like any other, but not a P6opaque, so you can't add attributes

[17:27] *** natrys joined
[17:28] *** camelCaser joined
[17:33] *** maettu joined
[17:42] *** Altai-man joined
[17:44] *** sena_kun left
[17:45] *** BenGoldberg joined
[17:55] *** pecastro joined
[17:58] *** molaf left
[18:00] *** ufobat__ joined
[18:04] *** ufobat_ left
[18:05] <rir> CArray, I seem to be missing a trick.  Starting with the timespec/clock_get_time and following the CArray section on the same page ( https://docs.raku.org/language/nativecall#index-entry-nativecall ), I could not get a CArray[timespec] to work with the native function.  Searching all of Github, I didn't find one example of a CArray of CStruct written. Any help out here? 

[18:06] *** pecastro left
[18:08] <[Coke]> already submitted this for a contest, be curious if anyone had feedback on https://github.com/coke/matt-parkers-maths-puzzles/blob/main/prime-pairs to make it more "natural" for Raku. (Looking at it, I'd probably switch the MAIN to a unit sub since it's the whole file.)

[18:11] *** patrickb joined
[18:19] *** BenGoldberg left
[18:23] *** bocaneri left
[18:48] *** jmerelo left
[18:52] *** xinming left
[18:54] *** xinming joined
[19:08] *** Doc_Holliwould joined
[19:08] *** approaching236 left
[19:18] *** abraxxa left
[19:29] *** natrys left
[19:42] *** kst joined
[19:43] *** kst left
[19:43] *** kst` left
[19:44] *** kst joined
[19:48] *** maettu left
[19:52] <AlexDaniel> [Coke]: .tail instead of [*-1], destructuring for $left and $right instead of accessing $_, yes for a unit sub. check-path is recursive, how about putting gather outside your first call?

[19:52] *** patrickb left
[19:53] <AlexDaniel> that is, you can `take` no matter how deep you are

[19:58] *** vrurg joined
[19:58] *** xinming left
[19:59] *** xinming joined
[20:01] <AlexDaniel> [Coke]: the code seems to be doing depth-first search so it makes sense to describe it as such in the comments. Describing it this way may also give clues on how to optimize it

[20:03] <AlexDaniel> [Coke]: `next if @path.first($next)` is needlessly O(n) while you could've used an array with boolean markers

[20:04] *** kensanata joined
[20:05] <AlexDaniel> another way is to use a more generic approach – describe your edges and vertices by using objects, then you can have “already used” field in each object

[20:05] *** molaf joined
[20:07] *** MasterDuke joined
[20:08] *** vrurg left
[20:08] <AlexDaniel> [Coke]: as for optimizing it, the slowest and most obvious part is when you hit the same vertex more than once from slightly reordered initial steps. That is, if you've already found solutions (or figured out that there are no solutions) for a certain combination of remaining vertices, you're currently checking them all over again anyway

[20:09] <AlexDaniel> usually that's very easy to solve for tasks that just ask for the shortest path to finish (or the number of possible paths), but from the top of my head I don't know how to do that in cases when you must hit every vertex

[20:10] <AlexDaniel> also looking at it now you can just `take` your @path when you hit the finish without any additional logic

[20:11] <MasterDuke> could it be something `for %paths{$last}.values (-) @path -> $next {`?

[20:12] <AlexDaniel> that's probably still significantly slower than just checking an array of bools or checking a field of an object

[20:14] <AlexDaniel> I definitely wouldn't do it that way in a competition, which you can probably tell I used to enjoy back in the day :)

[20:14] *** Xliff left
[20:15] <AlexDaniel> doing something like that might also stress GC a bit too much, it depends. But a few ms wasted on something as simple as that can really lose you some points :)

[20:16] <AlexDaniel> can't help it x) the task itself reads almost like something straight from one of the competitions

[20:21] <AlexDaniel> another interesting part is optimizing the tree generation itself ( `($min..$max).combinations(2).grep(*.sum.is-prime)` )

[20:21] *** xinming left
[20:22] *** kensanata left
[20:22] <AlexDaniel> maybe a good idea to generate the primes first and then generate the edges starting with known primes

[20:22] *** xinming joined
[20:23] *** chloekek joined
[20:23] <MasterDuke> m: (1..9).combinations(2).grep(*.sum.is-prime).elems.say; say now - INIT now

[20:23] <camelia> rakudo-moar 85847d2f1: OUTPUT: «14␤0.00493635␤»

[20:23] <AlexDaniel> for 1..9 yes, but for 1..9 you can probably bruteforce the whole thing too

[20:24] <MasterDuke> m: (1..900).combinations(2).grep(*.sum.is-prime).elems.say; say now - INIT now # what's an actually useful range?

[20:24] <camelia> rakudo-moar 85847d2f1: OUTPUT: «59678␤2.5261464␤»

[20:24] <AlexDaniel> that being said, on a competition I would've probably written something that's relatively slow-ish, and then just feed it all possible inputs, create a lookup table, and submit the lookup table as a solution x)

[20:25] <AlexDaniel> 2.5s is already too slow, the limit is usually 1s

[20:27] *** approaching236 joined
[20:28] <MasterDuke> ^^^ drops to 0.5s on my gmp branch

[20:29] <MasterDuke> though it was only 1.7s locally on master

[20:29] <AlexDaniel> MasterDuke: the gmp branch… is working? :O

[20:29] <AlexDaniel> that's fantastic news

[20:30] <MasterDuke> it only fails a single spectest because 2**10000000000 doesn't die anymore

[20:31] <AlexDaniel> that's amazing

[20:31] <AlexDaniel> what does it do instead?

[20:31] <AlexDaniel> I guess, hangs while trying too hard? :)

[20:32] <AlexDaniel> that test can be thrown away, 2**1000000000 behaves the same way I don't see a good reason why anything larger should be different

[20:34] <AlexDaniel> in fact maybe it's actually wrong to throw an exception at an arbitrary point, just adds an edge case where one doesn't have to exist

[20:37] <MasterDuke> `my $a = 2**10000000000; say $a > 4` # outputs `True` almost instantly

[20:38] *** wamba left
[20:39] <MasterDuke> but the branch still needs a little cleanup. it's not using the gmp we build unless i LD_PRELOAD it, and i'm using a signal handle and setjmp+longjmp to handle abort()s from gmp, which i don't believe is threadsafe

[20:39] <MasterDuke> *signal handler

[20:39] *** chloekek left
[20:40] <MasterDuke> but otherwise it's faster and ~500 fewer lines of code in bigintops.c

[20:40] <lizmat> MasterDuke++   # hard work and progress!

[20:41] <Altai-man> MasterDuke++ # very impressive!

[20:43] <MasterDuke> 90% done. now just the remaining 90% to finish...

[20:46] <AlexDaniel> MasterDuke: how much faster? Did you by any chance notice any difference running the spectest?

[20:49] <MasterDuke> i don't think there's much difference in a spectest. i just did an assortment of math operations in a loop and noticed a measurable difference

[20:49] <AlexDaniel> okay

[20:49] <MasterDuke> stringification is dramatically faster

[20:50] *** ufobat__ left
[20:51] *** pecastro joined
[20:55] <MasterDuke> `my ($a; $b; $c; $s); for 66..2_000 -> $e { $a = 23**$e; $b = 7**$e; $c = $a % $b; $c *= $c; $c += $a; $c -= $b; $s = $c.is-prime }; say $s; say now - INIT now` takes 10s on gmp branch, 30s on master

[20:58] <MasterDuke> yeah, no change in spectest time

[20:58] <AlexDaniel> MasterDuke: btw I think there's third chunk of 90% for switching to gmp rats :) But that's for later

[21:01] *** xinming left
[21:02] *** xinming joined
[21:08] *** rindolf left
[21:08] *** Altai-man left
[21:10] *** BenGoldberg joined
[21:18] *** Xliff joined
[21:18] *** Xliff left
[21:18] *** Xliff joined
[21:19] *** xinming left
[21:19] *** xinming joined
[21:28] <[Coke]> MasterDuke++

[22:06] *** perryprog left
[22:06] *** perryprog joined
[22:20] *** BenGoldberg left
[22:23] *** mowcat joined
[22:28] *** lucasb joined
[22:47] *** abraxxa joined
[22:51] *** ggoebel left
[23:03] *** dotdotdot left
[23:10] *** dotdotdot joined
[23:16] *** cgfbee left
[23:18] *** xinming left
[23:19] *** xinming joined
[23:22] *** mid_laptop joined
[23:23] *** El_Che left
[23:24] *** ensamvarg left
[23:24] *** gordonfish left
[23:24] *** cgfbee joined
[23:24] *** kybr left
[23:25] *** Util left
[23:25] *** kybr joined
[23:26] *** Util joined
[23:26] *** ensamvarg joined
[23:28] *** colomon__ left
[23:28] *** El_Che joined
[23:35] *** colomon joined
[23:35] *** colomon left
[23:36] *** vrurg joined
[23:37] *** pecastro left
[23:41] *** vrurg left
[23:43] *** xkr47 left
[23:45] *** lizmat left
[23:47] <Xliff> Huh, 

[23:48] <Xliff> This is an odd error... "Can only store CPointer attribute in CPointer slot in CStruct"

[23:48] <Xliff> m: use NativeCall; class A is CStruct { has Pointer $.a }; my $a = A.new; $a := Pointer

[23:48] <camelia> rakudo-moar 85847d2f1: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤'A' cannot inherit from 'CStruct' because it is unknown.␤at <tmp>:1␤»

[23:48] <Xliff> m: use NativeCall; class A is repr<CStruct> { has Pointer $.a }; my $a = A.new; $a := Pointer

[23:48] <camelia> rakudo-moar 85847d2f1: ( no output )

[23:48] *** lizmat joined
[23:49] <Xliff> m: use NativeCall; class A is repr<CStruct> { has Pointer $.a }; my $a = A.new; $a := Pointer[uint8].new(1)

[23:49] <camelia> rakudo-moar 85847d2f1: ( no output )

[23:55] *** xkr47 joined
[23:57] *** Xliff left
[23:58] *** andreoss joined
