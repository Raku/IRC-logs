[00:08] *** evalable6 left
[00:08] *** linkable6 left
[00:09] *** evalable6 joined
[00:09] *** linkable6 joined
[00:38] *** pecastro left
[01:02] *** lucasb left
[01:20] *** asymptotically left
[01:22] *** cydf left
[01:33] *** Doc_Holliwould left
[01:34] *** pecastro joined
[01:54] *** jmchael left
[02:00] *** BenGoldberg joined
[02:03] *** ggoebel left
[02:04] *** ggoebel joined
[02:11] *** ggoebel left
[02:12] *** ggoebel joined
[02:22] *** finsternis joined
[02:22] *** leont left
[02:40] *** ggoebel left
[03:14] *** pecastro left
[03:34] <xinming> Is there a way to pause a Supply.interval(1)  supply?

[03:35] <xinming> What I mean is something like,    my Channel $c .= new; react whenever Supply.interval(1) {  "pause interval here".say; my $t = $c.receive; "Process here"; "resume interval here again".say; }

[03:36] <xinming> I know we have throttle already, But I wish to do it myself to understand how these kind of problems to be solved correctly.

[03:37] <xinming> Hmm, BTW, I know I can use    loop { .. sleep 1; .. }   thing,    But I wish to try it in Supply

[04:05] <codesections> xinming: I'm not sure if this does quite what you're looking for (I haven't done a whole lot with Supplies), but how about: 

[04:08] <codesections> my $s = Supply.interval(1).share; my $t0 = $s.tap; $t0.close; my $t1 = $s.tap

[04:14] *** ab5tract left
[04:59] *** camelCaser left
[05:01] *** Celelibi left
[05:02] *** camelCaser joined
[05:16] <xinming> codesections: hmm, not about tap, I mean pause the Supply source itself. :-)

[05:19] *** Celelibi joined
[05:25] <raku-bridge> <EsperLily> I can't figure out why (0, 0), (* Z+ (3, 1)) ... * produces ((0 0) (5) (4) (4) (4) (4) (4) (4) (4) ...)

[05:29] <raku-bridge> <EsperLily> huh $(0, 0) Z+ (3, 1) produces (5). wtf?

[05:29] <guifa2> EsperLily: when using the whatever code, the * is getting treated in scalar contexts, and +(0,0) --> 2, and 2 Z+ (3,1) --> 5 as the 1 is seen as extra and is ignored

[05:29] <guifa2> compare

[05:30] <raku-bridge> <EsperLily> ahhh I missed that +(0, 0) == 2. I had just come to the realization that * was being treated as scalar though

[05:30] <guifa2> my @a = (0, 0), {$^i Z+ (3, 1)} ... *; say @a[0..20]; # explicit scalar

[05:30] <evalable6> guifa2, rakudo-moar ac84c1886: OUTPUT: «((0 0) (5) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4))␤»

[05:30] <guifa2> my @a = (0, 0), {@^i Z+ (3, 1)} ... *; say @a[0..20]; # explicit array

[05:30] <evalable6> guifa2, rakudo-moar ac84c1886: OUTPUT: «((0 0) (3 1) (6 2) (9 3) (12 4) (15 5) (18 6) (21 7) (24 8) (27 9) (30 10) (33 11) (36 12) (39 13) (42 14) (45 15) (48 16) (51 17) (54 18) (57 19) (60 20))␤»

[05:30] <guifa2> my @a = (0, 0), {*<> Z+ (3, 1)} ... *; say @a[0..20]; # I wonder if zen operator works

[05:30] <guifa2> err

[05:31] <raku-bridge> <EsperLily> yeah it does

[05:31] <guifa2> m: my @a = (0, 0),  *<> Z+ (3, 1) ... *; say @a[0..20]; 

[05:31] <camelia> rakudo-moar ac84c1886: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Only identical operators may be list associative; since 'Z+' and '...' differ, they are non-associative and you need to clarify with parentheses␤at <tmp>:1␤------> 3my @a = (0, 0),  *<> Z+ (3, 1)7…»

[05:31] <raku-bridge> <EsperLily> oh you need parens

[05:31] <guifa2> my @a = (0, 0), (*<> Z+ (3, 1)) ... *; say @a[0..20];

[05:31] <guifa2> m: my @a = (0, 0), (*<> Z+ (3, 1)) ... *; say @a[0..20];

[05:31] <camelia> rakudo-moar ac84c1886: OUTPUT: «The iterator of this Seq is already in use/consumed by another Seq␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[05:31] <guifa2> m: my @a = (0, 0), (|* Z+ (3, 1)) ... *; say @a[0..20];

[05:31] <camelia> rakudo-moar ac84c1886: OUTPUT: «The iterator of this Seq is already in use/consumed by another Seq␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[05:32] <guifa2> m: my @a = (0, 0), (*.list Z+ (3, 1)) ... *; say @a[0..20];

[05:32] <camelia> rakudo-moar ac84c1886: OUTPUT: «The iterator of this Seq is already in use/consumed by another Seq␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»

[05:32] <guifa2> jeez

[05:32] <guifa2> haha

[05:33] <raku-bridge> <EsperLily> I was testing with .head(10) myself

[05:36] <raku-bridge> <EsperLily> hmm I can't seem to figure out how to iterate a sequence and stop once an element fails a predicate

[05:37] <raku-bridge> <EsperLily> (in a functional manner I mean)

[05:47] <guifa2> something probably like

[05:48] <guifa2> .head( .first( not *, :k) ) 

[05:48] <guifa2> but obviously in a way that it'll compiile

[05:48] <guifa2> lol

[05:55] *** frost-lab joined
[05:59] *** BenGoldberg left
[06:02] <raku-bridge> <EsperLily> The use here is for terminating an infinite sequence. Scanning it with first would presumably consume it so that's a no-go

[06:05] *** BenGoldberg joined
[06:06] *** xinming_ joined
[06:06] <guifa2> my @a = 1,2,3,4,5,Any,6,7,8,9,10; @a.map({ $^i // IterationEnd }).say

[06:06] <evalable6> guifa2, rakudo-moar ac84c1886: OUTPUT: «(1 2 3 4 5)␤»

[06:07] <guifa2> Granted, that consumes it, but it also gets you the values.  But you can do other things obviously inside the map and just terminate by returning IterationEnd whenever you hit an undefined or whatever sentinel value you want

[06:09] *** xinming left
[06:20] <raku-bridge> <EsperLily> Hmm

[06:21] <raku-bridge> <EsperLily> Here's a weird one: (1, 2; 3, 4)[1; 1] returns 4 but (1, 2; 3, 4)[1; 1 % *] returns (4). What the heck?

[06:24] <elcaro> m: say ((0, 0), (*[] Z+ (3, 1)) ...^ *[0] > 20);

[06:24] <camelia> rakudo-moar ac84c1886: OUTPUT: «((0 0) (3 1) (6 2) (9 3) (12 4) (15 5) (18 6))␤»

[06:25] <elcaro> or could use toggle

[06:25] <elcaro> m: ((0, 0), (*[] Z+ (3, 1)) ... *).toggle(*[0] < 20);

[06:25] <elcaro> m: say ((0, 0), (*[] Z+ (3, 1)) ... *).toggle(*[0] < 20);

[06:25] <camelia> rakudo-moar ac84c1886: OUTPUT: «(timeout)»

[06:25] <camelia> rakudo-moar ac84c1886: OUTPUT: «((0 0) (3 1) (6 2) (9 3) (12 4) (15 5) (18 6))␤»

[06:26] <elcaro> if you've already got a (maybe infinite) sequence you want to stop when it fails (or passes) a predicate, use toggle

[06:27] <elcaro> it's a generalization of takewhile/dropwhile/takeuntil/dropuntil... depending on how you use it

[06:29] <guifa2> EsperLily:  Makes sense to me

[06:29] <guifa2> [1; * % 1] is equivalent to [1; .elems % 1]

[06:30] <guifa2> Which is to say, [1; 1]

[06:30] <elcaro> yep, and elems is 2, so `1 % 2` is still 1, so there's no difference in the output of both expressions

[06:31] * guifa2 just finished getting the <units> element prepped for CLDR.  Hooray.  

[06:32] <guifa2> Although it's killed loading time, dang.  I need to figure something out.  .28s per language is too slow

[06:37] <raku-bridge> <EsperLily> ok toggle looks neat, oddly hard to find

[06:37] *** squashable6 left
[06:37] <raku-bridge> <EsperLily> guifa2: [1; 1 % *] should be the same as [1; 1] in this case, but the output is different!

[06:37] <raku-bridge> <EsperLily> Subscripting with [1; 1] gives me a single element. Subscripting with [1; 1 % *] gives me a list of one element

[06:38] <guifa2> Yeah

[06:38] <guifa2> Because you can also do

[06:38] <guifa2> Well

[06:38] <guifa2> since 1 % * returns a single value, it shouldn't go into slicing mode

[06:39] <raku-bridge> <EsperLily> it only seems to do this in the multidimensional subscript (or whatever you call the [a; b] form)

[06:40] *** squashable6 joined
[06:40] <guifa2> Yeah, I think it's being overzealous perhaps with slices

[06:40] <guifa2> m: say (1, 2; 3, 4)[*; 1] # that I expect to return a list

[06:40] <camelia> rakudo-moar ac84c1886: OUTPUT: «(2 4)␤»

[06:40] <raku-bridge> <EsperLily> 3[0; 0 % *] returns (3)

[06:41] <guifa2> say (1, 2; 3, 4, 5, 6)[*; * % 2]

[06:41] <evalable6> guifa2, rakudo-moar ac84c1886: OUTPUT: «(1 3)␤»

[06:41] <raku-bridge> <EsperLily> also curiously, tacking additional ; 0s on the end doesn't unwrap the list. I have to use a separate subscript entirely

[06:41] <guifa2> oh there you go

[06:42] <guifa2> say (1, 2, 3, 4; 5, 6, 7, 8)[*; * % 2]

[06:42] <evalable6> guifa2, rakudo-moar ac84c1886: OUTPUT: «(1 5)␤»

[06:42] <guifa2> hmm I dunno, weird

[06:42] <raku-bridge> <EsperLily> This feels like a bug

[06:43] <raku-bridge> <EsperLily> I'd just use multiple subscripts but AFIAK there's no way to say "subscript the invocant only if it's non-nil", and someNilValue[1 % *] gives a divide-by-zero error

[06:44] <raku-bridge> <EsperLily> oh, regarding toggle, it doesn't exist as a standalone sub so I can't use it with ==> :'(

[06:44] *** jmerelo joined
[06:44] <raku-bridge> <EsperLily> well, I could use ==> { @^a.toggle(*.defined) }() but that just feels ugly

[06:48] <guifa2> Actually wait. The reason is probably that whatever code could still potentially return a list

[06:48] <guifa2> There's no reason to distinguish whatever code from any other callable

[06:49] *** lizmat left
[06:50] *** lizmat joined
[06:55] <guifa2> Except a callable returning a list still gets evaluated as a number.  Hm..  okay, I'm definitely agreeing with there's something weird going on here

[07:03] <guifa2> bisectable: (1, 2; 3, 4)[1; 1 % *]

[07:03] <bisectable6> guifa2, Will bisect the whole range automagically because no endpoints were provided, hang tight

[07:03] <bisectable6> guifa2, ¦6c (49 commits): «»

[07:03] <bisectable6> guifa2, Nothing to bisect!

[07:03] <guifa2> so been that way for basically ever

[07:09] * guifa2 is afk

[07:10] *** parabolize left
[07:17] *** sjm_uk joined
[07:25] *** Sgeo left
[07:38] *** dmc00 left
[07:41] <coldpress> Hi, what's the idiomatic way of grouping and then summing contiguous 1s in the array [1, 1, 0, 1, 0, 1, 1, 1]? The result should be [2, 1, 3]

[07:41] *** domidumont joined
[07:42] *** aluaces left
[07:44] <moritz> coldpress: I don't understand how the grouping is supposed to work

[07:44] *** aluaces joined
[07:44] <moritz> split on 0s?

[07:47] *** xinming_ left
[07:47] *** xinming_ joined
[07:49] <coldpress> yes, split on 0s

[07:52] *** aluaces left
[07:54] <moritz> m: say [1, 1, 0, 1, 0, 1, 1, 1].join('').split(0).map(*.comb.sum)

[07:54] <camelia> rakudo-moar ac84c1886: OUTPUT: «(2 1 3)␤»

[07:55] <moritz> but that's cheating, assuming that each entry is just one digit

[07:56] <moritz> m: say  [1, 1, 0, 1, 0, 1, 1, 1].grep(:k, 0)

[07:56] <camelia> rakudo-moar ac84c1886: OUTPUT: «(2 4)␤»

[07:56] <moritz> this gives you the indexes to split on

[07:57] * moritz too distracted with $work to come up with something clever

[07:57] <moritz> I guess you could always just do a boring iteration

[07:58] <moritz> m: say gather { my $sum = 0; for [1, 1, 0, 1, 0, 1, 1, 1] -> $x { if ( $x == 0 ) { take $sum; $sum = 0 } else { $sum += $x } }

[07:58] <camelia> rakudo-moar ac84c1886: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3e $sum; $sum = 0 } else { $sum += $x } }7⏏5<EOL>␤»

[07:58] *** aluaces joined
[07:59] <moritz> m: say gather { my $sum = 0; for [1, 1, 0, 1, 0, 1, 1, 1] -> $x { if $x == 0 { take $sum; $sum = 0 } else { $sum += $x } }

[07:59] <camelia> rakudo-moar ac84c1886: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3e $sum; $sum = 0 } else { $sum += $x } }7⏏5<EOL>␤»

[07:59] <moritz> m: say gather { my $sum = 0; for [1, 1, 0, 1, 0, 1, 1, 1] -> $x { if $x == 0 { take $sum; $sum = 0 } else { $sum += $x } } }

[07:59] <camelia> rakudo-moar ac84c1886: OUTPUT: «(2 1)␤»

[07:59] <coldpress> moritz: yeah, assuming one digit is cheating

[07:59] <moritz> m: say gather { my $sum = 0; for [1, 1, 0, 1, 0, 1, 1, 1] -> $x { if $x == 0 { take $sum; $sum = 0 } else { $sum += $x } }; take $sum }

[07:59] <camelia> rakudo-moar ac84c1886: OUTPUT: «(2 1 3)␤»

[07:59] <coldpress> moritz: I am doing iteration, and I don't like it because it's too verbose. .grep(:k, 0) looks like a good solution

[07:59] <moritz> a split + reduce approach would be more satisfying, I guess

[08:00] <samebchase-> there should be a way to split on arrays like Str.split

[08:00] <coldpress> indeed

[08:00] <samebchase-> which was take arbitary predicates

[08:01] <samebchase-> s/was/can/

[08:08] *** stoned75 joined
[08:13] <coldpress> what's the Raku way to scan (as in parallel scan, as in https://hackage.haskell.org/package/foldl-1.4.10/docs/Control-Foldl.html#v:scan)

[08:13] <coldpress> (not necessarily parallel)

[08:13] *** sena_kun joined
[08:40] *** dakkar joined
[08:42] <moritz> sorry, I don't follow that terminology

[08:42] <frost-lab> Hi, everybody. How can I make sure that an array contains a specific part? For example, to determine whether [3,1,2,0,0,8,7] contains the part 2,0,0.

[08:42] *** ufobat joined
[08:42] <moritz> coldpress: what do you want to achieve?

[08:43] <moritz> m: say [3,1,2,0,0,8,7] ~~ [*, 2, 0, 0, *]

[08:43] <camelia> rakudo-moar ac84c1886: OUTPUT: «False␤»

[08:44] <frost-lab> I just know transform the array to a string and use string method to match the specific part, but is there any other way?

[08:46] <moritz> m: say any([3,1,2,0,0,8,7].rotor(4 => -3) ~~ [2, 0, 0]

[08:46] <camelia> rakudo-moar ac84c1886: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' (corresponding starter was at line 1)␤at <tmp>:1␤------> 031,2,0,0,8,7].rotor(4 => -3) ~~ [2, 0, 0]7⏏5<EOL>␤»

[08:46] <moritz> m: say any([3,1,2,0,0,8,7].rotor(4 => -3)) ~~ [2, 0, 0]

[08:46] <camelia> rakudo-moar ac84c1886: OUTPUT: «any(False, False, False, False)␤»

[08:46] <frost-lab> :m so [3,1,2,0,0,8,7].Str ~~ /'2 0 0'/

[08:46] <frost-lab> m:so [3,1,2,0,0,8,7].Str ~~ /'2 0 0'/

[08:46] <evalable6> frost-lab, rakudo-moar ac84c1886: OUTPUT: «WARNINGS for /tmp/FYwaBQQD9e:␤Useless use of "so " in expression "so [3,1,2,0,0,8,7].Str ~~" in sink context (line 1)␤»

[08:46] <moritz> m: say any([3,1,2,0,0,8,7].rotor(3 => -2)) ~~ [2, 0, 0]

[08:46] <camelia> rakudo-moar ac84c1886: OUTPUT: «any(False, False, False, False, False)␤»

[08:47] <frost-lab> p6:so [3,1,2,0,0,8,7].Str ~~ /'2 0 0'/

[08:47] <evalable6> frost-lab, rakudo-moar ac84c1886: OUTPUT: «WARNINGS for /tmp/2EYhR7PIFX:␤Useless use of "so " in expression "so [3,1,2,0,0,8,7].Str ~~" in sink context (line 1)␤»

[08:47] <moritz> m: say any([3,1,2,0,0,8,7].rotor(3 => -2)) ~~ (2, 0, 0)

[08:47] <camelia> rakudo-moar ac84c1886: OUTPUT: «any(False, False, False, False, False)␤»

[08:47] <moritz> my: say so [3,1,2,0,0,8,7].Str ~~ /'2 0 0'/

[08:47] <moritz> m: say so [3,1,2,0,0,8,7].Str ~~ /'2 0 0'/

[08:47] <camelia> rakudo-moar ac84c1886: OUTPUT: «True␤»

[08:47] <frost-lab> yep

[08:47] <moritz> frost-lab: nothing clever comes to mind

[08:49] <frost-lab> moritz thanks for your answer.

[08:56] *** cpan-raku joined
[08:56] *** cpan-raku left
[08:56] *** cpan-raku joined
[09:02] *** rindolf joined
[09:07] *** Altai-man joined
[09:10] *** sena_kun left
[09:11] *** pecastro joined
[09:12] *** asymptotically joined
[09:15] *** wamba joined
[09:18] *** ufobat left
[09:18] *** ufobat joined
[09:28] *** dakkar left
[09:29] *** dakkar joined
[09:38] *** albino left
[09:42] *** cydf joined
[09:46] <elcaro> frost-lab: To compare lists, you need to use `eqv`... so to fix moritz's example

[09:46] <elcaro> m: say so any([3,1,2,0,0,8,7].rotor(3 => -2)) eqv (2,0,0);

[09:46] <camelia> rakudo-moar ac84c1886: OUTPUT: «True␤»

[09:51] <frost-lab> Aha, interesting!

[09:52] *** albino joined
[10:13] *** MasterDuke joined
[10:18] <frost-lab> m: (6,7,8) ~~ (6,7,8)

[10:18] <camelia> rakudo-moar ac84c1886: ( no output )

[10:18] <frost-lab> m: say (6,7,8) ~~ (6,7,8)

[10:18] <camelia> rakudo-moar ac84c1886: OUTPUT: «True␤»

[10:19] <frost-lab> m: say ((6,7,8) | (6,8,7)) ~~ (6,7,8)

[10:19] <camelia> rakudo-moar ac84c1886: OUTPUT: «any(False, False)␤»

[10:20] <frost-lab> Weird, why (6,7,8) ~~ (6,7,8) is true but ((6,7,8) | (6,8,7)) ~~ (6,7,8) gets two fales?

[10:21] <moritz> the matcher is always on the right-hand side

[10:21] <moritz> m: say (6,7,8) ~~ (6,7,8) | (6, 8, 7)

[10:21] <camelia> rakudo-moar ac84c1886: OUTPUT: «True␤»

[10:22] <frost-lab> Oh, I forget the characteristic of the ~~, thanks.

[10:34] <elcaro> you can also use `cmp`

[10:34] <elcaro> m: say (1,1,1) cmp (1,1,1)

[10:34] <camelia> rakudo-moar ac84c1886: OUTPUT: «Same␤»

[10:34] <elcaro> m: say (1,1,1) cmp (1,2,1)

[10:34] <camelia> rakudo-moar ac84c1886: OUTPUT: «Less␤»

[10:38] <holyghost> DWIM ?

[10:40] <holyghost> There's several equalitiy operators as you see

[10:40] <holyghost> eq? equal?, eqv? in Scheme for example

[10:56] <moritz> https://stackoverflow.com/questions/176343/whats-the-deal-with-all-the-different-perl-6-equality-operators-eq

[11:13] *** evalable6 left
[11:13] *** linkable6 left
[11:14] *** linkable6 joined
[11:14] *** evalable6 joined
[11:37] *** ggoebel joined
[11:47] *** grondilu left
[11:53] *** ufobat_ joined
[11:56] *** ufobat left
[11:57] <frost-lab> m:say ((1,2)|(2,1,9)).WAHT, ((1,2)|(2,1,9)).Seq.WHAT

[11:57] <evalable6> frost-lab, rakudo-moar ac84c1886: OUTPUT: «(exit code 1) No such method 'WAHT' for invocant of type 'List'.  Did you mean any of␤these: 'Rat', 'WALK', 'WHAT', 'WHO'?␤  in block <unit> at /tmp/SzIDdH4LYN line 1␤␤»

[11:57] <frost-lab> m:say ((1,2)|(2,1,9)).WHAT, ((1,2)|(2,1,9)).Seq.WHAT

[11:57] <evalable6> frost-lab, rakudo-moar ac84c1886: OUTPUT: «(Junction)(Junction)␤»

[11:57] <frost-lab> m: say ((1,2)|(2,1,9)).Seq eqv (1,2), ((1,2)|(2,1,9)) eqv (1,2)

[11:57] <camelia> rakudo-moar ac84c1886: OUTPUT: «any(False, False)any(True, False)␤»

[11:58] <frost-lab> m: say so ((1,2)|(2,1,9)).Seq eqv (1,2), so ((1,2)|(2,1,9)) eqv (1,2)

[11:58] <camelia> rakudo-moar ac84c1886: OUTPUT: «FalseTrue␤»

[11:59] <frost-lab> What is the difference between  ((1,2)|(2,1,9)).Seq  and  ((1,2)|(2,1,9)) ?

[12:01] <frost-lab> There are still things that confuse me X) . 

[12:05] *** ggoebel left
[12:12] *** frost-lab left
[12:18] *** ggoebel joined
[12:18] *** ggoebel left
[12:22] *** dmc00 joined
[12:28] *** dakkar left
[12:28] *** dakkar joined
[12:39] *** MasterDuke left
[12:41] *** Black_Ribbon left
[12:42] <moritz> Seq is an iterator type

[12:42] <moritz> with it, you can you produce potentially inifinte streams that are never held fully in memory

[12:42] <moritz> perfect for things like a file iterator

[12:43] <moritz> or a UNIX pipe

[12:48] <notandinus> m: my @t = 0; push @t, 1..3; say @t.raku;

[12:48] <camelia> rakudo-moar ac84c1886: OUTPUT: «[0, 1..3]␤»

[12:48] <notandinus> m: my @t = 0; my @k = 1 .. 3; push @t, @k; say @t.raku;

[12:48] <camelia> rakudo-moar ac84c1886: OUTPUT: «[0, [1, 2, 3]]␤»

[12:49] <notandinus> how do i do the above but make it push each element one by one instead of pushing the whole array?

[12:49] <notandinus> m: my @t = 0; my @k = 1 .. 3; push @t, $_ for @k; say @t.raku;

[12:49] <camelia> rakudo-moar ac84c1886: OUTPUT: «[0, 1, 2, 3]␤»

[12:49] <notandinus> like ^, for loop works fine, are there more ways?

[12:49] <Altai-man> m: my @t = 0; my @k = 1 .. 3; push @t, |@k; say @t.raku;

[12:49] <camelia> rakudo-moar ac84c1886: OUTPUT: «[0, 1, 2, 3]␤»

[12:50] <Altai-man> m: my @t = 0; my @k = 1 .. 3; @t.append(@k); say @t.raku;

[12:50] <camelia> rakudo-moar ac84c1886: OUTPUT: «[0, 1, 2, 3]␤»

[12:51] <notandinus> i see, thanks.

[12:51] <Altai-man> notandinus, use `append` or `|` "slip" operator.

[12:51] <notandinus> also, is unshift more costly compared to push? cost being cpu time.

[12:52] <dakkar> ah, we had the same question yesterday ☺

[12:52] <dakkar> I ran some benchmarks, and couldn't see a difference

[12:52] <notandinus> yeah, looks like there is not much difference when testing against large arrays

[12:52] <notandinus> i found push to be faster on small arrays.

[12:52] <Altai-man> https://github.com/MoarVM/MoarVM/pull/1392 ?

[12:53] <Altai-man> push is faster in cases of large inputs, but in new release this will be fixed. :]

[12:54] <notandinus> oh their raku initializes in less than 200ms

[12:54] <notandinus> mine takes about 1s

[12:55] <Altai-man> notandinus, what rakudo version do you use?

[12:56] <notandinus> ah yeah, i was talking about unshifing a single item vs initializing with that item and pushing the rest. looks like both are equally as fast.

[12:56] <notandinus> Altai-man: It's Rakudo v2020.10

[12:56] <Altai-man> I see, that's pretty fresh. :)

[12:56] <Altai-man> notandinus, for small inputs it won't really matter, I'd say.

[12:57] <notandinus> yeah i compiled it myself, can i do anything to improve this initialization time?

[12:58] <Altai-man> notandinus, what do you mean by "initialization time"? Repl start? Particular script start?

[12:59] <notandinus> Altai-man: time taken to run "raku -e ''"

[12:59] <Altai-man> `Executed in   93,26 millis` for me.

[13:00] <Altai-man> I don't think there is anything for the user to improve particularly that.

[13:00] <notandinus> i see

[13:08] *** sena_kun joined
[13:09] *** rindolf left
[13:10] *** Altai-man left
[13:20] *** rindolf joined
[13:45] *** b2gills left
[13:45] *** b2gills joined
[13:52] *** leont joined
[14:02] *** jmerelo left
[14:07] *** ggoebel joined
[14:08] <ggoebel> raku: (|(1, 2..3))

[14:08] <evalable6> ggoebel, rakudo-moar ac84c1886: OUTPUT: «»

[14:08] <ggoebel> raku: say (|(1, 2..3))

[14:08] <evalable6> ggoebel, rakudo-moar ac84c1886: OUTPUT: «(1 2..3)␤»

[14:08] <ggoebel> raku: say (1, 2..3).flat

[14:08] <evalable6> ggoebel, rakudo-moar ac84c1886: OUTPUT: «(1 2 3)␤»

[14:08] <ggoebel> wondering why these are different?

[14:12] *** MasterDuke joined
[14:31] *** ajdplaysalto joined
[14:41] <tbrowder> .tell jmerelo i have NOT scheduled it

[14:41] <tellable6> tbrowder, I'll pass your message to jjmerelo

[14:43] *** morayj joined
[14:48] *** a3r0 left
[14:48] *** a3r0 joined
[14:49] *** Sgeo joined
[15:10] <guifa2> ggoebel: a slip doesn't flatten 

[15:13] <ggoebel> thx

[15:13] <ggoebel> guifa2++

[15:21] *** brtastic1 joined
[15:25] *** brtastic1 is now known as brtastic

[15:45] *** morayj left
[15:45] *** ufobat_ left
[15:47] *** ufobat joined
[15:52] *** cydf left
[15:56] *** morayj joined
[15:57] *** jmchael joined
[16:08] *** parabolize joined
[16:08] *** __jrjsmrtn__ joined
[16:10] *** _jrjsmrtn left
[16:16] *** Maylay left
[16:18] *** cgfbee left
[16:22] *** Maylay joined
[16:25] *** guifa2 left
[16:28] *** ajdplaysalto left
[16:32] *** wamba left
[16:35] *** jmerelo joined
[16:37] *** guifa2 joined
[16:39] *** guifa2 left
[16:42] *** skids joined
[16:42] *** BenGoldberg left
[16:46] <notandinus> what will be the equivalent of following perl code:

[16:48] <notandinus> print sprintf('%02d ', $_) for(0...10)

[16:48] *** hal99999 joined
[16:48] <lizmat> m: 	print sprintf('%02d ', $_) for ^11

[16:48] <camelia> rakudo-moar 392d8be20: OUTPUT: «00 01 02 03 04 05 06 07 08 09 10 »

[16:49] <lizmat> m: 	printf('%02d ', $_) for ^11

[16:49] <camelia> rakudo-moar 392d8be20: OUTPUT: «00 01 02 03 04 05 06 07 08 09 10 »

[16:49] <notandinus> oh 

[16:49] <notandinus> thanks, i was trying something with say, map, sprintf

[16:49] <lizmat> you don't have to use .fmt if you don't want to :-)

[16:50] <notandinus> i don't know what fmt is, i'll check it otu

[16:51] <notandinus> m: say (0 ... 10).fmt("%02d")

[16:51] <camelia> rakudo-moar 392d8be20: OUTPUT: «00 01 02 03 04 05 06 07 08 09 10␤»

[16:51] <notandinus> thanks, that makes it easy

[16:51] <lizmat> yw 

[16:53] <notandinus> is there a better way to get last index other than @_.elems - ?

[16:53] <notandinus> @_.elems -1

[16:55] <lizmat> m: my @a = ^10; say @a[*-1]

[16:55] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «9␤»

[16:55] <lizmat> m: my @a = ^10; say @a[*-1,*-2, *-3]

[16:55] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «(9 8 7)␤»

[16:55] <lizmat> notandinus: is that what you're looking for?

[16:55] <lizmat> m: my @a = ^10; say @a.end

[16:55] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «9␤»

[16:56] <lizmat> if you just want .elems - 1

[16:56] <notandinus> no i was looking for the index

[16:56] <notandinus> yeah .end is what i was looking for :)

[16:57] <MasterDuke> huh, i didn't know about .end

[16:58] <lizmat> .oO( it's not the end :-)

[16:58] <notandinus> yeah raku always has a method you dont know about

[17:01] * dakkar imagines a raku repl with tab-completion of method names via the mop…

[17:01] <tony-o> that'd not be difficult

[17:01] <tellable6> 2020-12-04T10:20:46Z #raku <patrickb> tony-o If there is any think I can help you with wrt. a new ecosystem please do contact me!

[17:02] <dakkar> in the meantime, `.^methods` helps

[17:02] <tony-o> .tell patrickb i kind of gave up on it, there didn't seem to be a lot of discussion about it in raku community. if you think this is not the case please lmk and i'll resume testing and playing around with it

[17:02] <tellable6> tony-o, I'll pass your message to patrickb

[17:02] <dakkar> m: my @a;say @a.^methods

[17:02] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «(iterator from-iterator from-list new STORE reification-target Method+{is-nodal}.new Method+{is-nodal}.new shape Method+{is-nodal}.new Method+{is-nodal}.new grab name of default dynamic clone Method+{is-nodal}.new Method+{is-nodal}.new Method+{is-noda…»

[17:07] *** Altai-man joined
[17:09] *** epony left
[17:10] <jmerelo> dakkar: that would be pretty cool. With colors, too.

[17:10] <tellable6> 2020-12-10T14:41:34Z #raku <tbrowder> jmerelo i have NOT scheduled it

[17:10] *** sena_kun left
[17:10] <jmerelo> .tell tbrowder OK, I'm checking it and scheduling it then.

[17:10] <tellable6> jmerelo, I'll pass your message to tbrowder

[17:12] <tbrowder> thanks, jj, wordpress and i don't get along very well  :-(

[17:12] <notandinus> .tell tellable6 hi

[17:12] <tellable6> notandinus, Thanks for the message

[17:14] <dakkar> oh nice, REPL already has completion hooks (only for Linenoise, which doesn't install for me, but shouldn't be too hard to add them to readline as well)

[17:14] <jmerelo> tbrowder: does not seem to get along with anyone, up to and including my cable provider. I have to log via private navigation every time.

[17:14] <tbrowder> is there any way to get Pod::To::HTML to get better styling for wordpress by creating a mustache template for it?

[17:14] <jmerelo> Doesn't latest version have Mustache baked in?

[17:15] <tbrowder> i really like using pod6 for writing this year!

[17:16] *** guifa joined
[17:17] <tbrowder> yeah, baked in i think, but it looks pretty bland when i view it locally with firefox, so i'm not sure. was i supposed to use partials or something like that?

[17:18] <tbrowder> btw, lizmat seems to have wordpress tamed pretty well, at least style-wise

[17:18] <lizmat> it did take some getting used to

[17:19] <lizmat> and every now and then, it fights me still

[17:21] <tbrowder> lizmat: i assume you use a script to collect the wkly info. do you create the html outside of wp and then copy/paste?

[17:21] <lizmat> only for the new / update modules

[17:22] <tbrowder> hm.

[17:22] <lizmat> which gfldex kindly created a script for

[17:22] <tbrowder> so the styling is from wp?

[17:22] <lizmat> yup, for that style that I selected well over a year ago now

[17:23] <lizmat> it's only disadvantage is really is that Preview doesn't work

[17:23] <lizmat> OTOH, the editor is close enough so that doesn't really feel like a problem most of the time

[17:24] <tbrowder> thnx

[17:25] <notandinus> how do you match something like "<this is a name>"in raku grammar?

[17:25] <notandinus> i'm doing this: token name { '<' \w+ '>'} 

[17:26] <notandinus> but it only matches when there are no space characters inside of '<>'

[17:26] <dakkar> yes, because `\w` does not match spaces

[17:26] <guifa> Easiest way is probably ‘<‘ ~ ‘>’ .*?

[17:26] <MasterDuke> { '<' [^>]+ '>' } is the normal regex way

[17:27] <dakkar> m: 'foo <bar baz> moo' ~~ /'<' [\w|\s]+? '>'/

[17:27] <camelia> rakudo-moar 9dbb52f9e: ( no output )

[17:27] <MasterDuke> and ^^^ is the raku way

[17:27] <dakkar> m: say 'foo <bar baz> moo' ~~ /'<' [\w|\s]+? '>'/

[17:27] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «｢<bar baz>｣␤»

[17:27] <dakkar> change that alternation to match what you mean

[17:27] <tony-o> btw dakkar, Bench showed a pretty decent difference in shift/pop https://gist.github.com/tony-o/22bb89f23c44bac271f2ac7a76da4721

[17:27] <notandinus> i see

[17:28] <dakkar> (I fear that guifa's suggestion may capture more than you want)

[17:28] <notandinus> also why doesn't '<' .* '>' work?

[17:28] <notandinus> is it because token doesn't backtrack?

[17:28] <dakkar> tony-o: yes, but for me it was not stable, different runs would produce very different results

[17:28] <guifa> notandinus because ‘>’ is a ., and tokens don’t backtrack

[17:28] <dakkar> m: say 'foo <bar baz> moo' ~~ /'<' .*? '>'/

[17:28] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «｢<bar baz>｣␤»

[17:28] <guifa> but if you make it frugal, it works

[17:29] <tony-o> i'm skeptical of 2m ops with that taking less than .5s

[17:30] <guifa> I remember jnhtn saying that there can be a slight memory efficiency in using native strs (especially if in an array)

[17:30] <notandinus> guifa: i see, thanks

[17:30] <notandinus> dakkar:  that last one works

[17:30] <guifa> Is there much of a penalty for unboxing them?

[17:30] <dakkar> tony-o: yes, me to

[17:30] <MasterDuke> highly recommend https://www.amazon.com/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/0596528124/ one of only two programming books i've read cover to cover (the other being Programming Perl)

[17:30] <tony-o> do you mind trying the one liner with Bench the way i wrote it?

[17:30] <notandinus> '<' ~ '>' .* doesn't seem to work with that

[17:30] <MasterDuke> also moritz++ has a good Raku grammar book

[17:31] <guifa> moritz is the Raku grammar guru

[17:31] <MasterDuke> https://www.amazon.com/Parsing-Perl-Regexes-Grammars-Recursive/dp/1484232275/

[17:32] <dakkar> tony-o: (running)

[17:32] <notandinus> i see, i'll check those out

[17:32] <notandinus> btw i've never ever completed any programming book

[17:32] <notandinus> very bad at reading

[17:33] <notandinus> i lose focus after a while

[17:33] <tony-o> dakkar: i'm asking because if Bench is broken then i'd like to fix it - it might've just evaluated Block rather than running it

[17:33] <dakkar> tony-o: Benchy was the one that returned very fast, not Bench

[17:34] <lizmat> fwiw, Benchy is up for adoption: https://github.com/raku-community-modules/Benchy

[17:34] <notandinus> so i wrote this grammar to parse a log file (included), anything i could improve there? https://paste.debian.net/hidden/a7a6275f/

[17:35] <lizmat> other modules up for adoption: https://github.com/Raku/ecosystem/blob/master/ADOPT-ME.md

[17:35] <dakkar> https://github.com/raku-community-modules/Benchy/blob/master/lib/Benchy.pm6#L24 would that actually call &old?

[17:36] <guifa> notandinus: you might try jmerelo’s Recipes for Raku.  It’s a bit more task-oriented but in bite-size pieces

[17:36] <jmerelo> guifa: thanks :-)

[17:37] * guifa . o O ( you know my OCD is bad when I rename constants from FOO-OFFSET and BAR-A-OFFSEST to OFFSET-FOO and OFFSET-BAR-A so they vertically align )

[17:37] <lizmat> guifa: that's just doing your future self a favour!

[17:37] <jmerelo> .tell tbrowder I think I've seen what you wanted to do; I've switched back the old version to draft, promoted the new version to be published in ~ 7 hours.

[17:37] <tellable6> jmerelo, I'll pass your message to tbrowder

[17:38] <guifa> lizmat: I’ve taken vertical alignment to an extreme I think

[17:38] <notandinus> guifa: i see, can you link me to it?

[17:38] <notandinus> was that the first book you mentioned?

[17:38] <guifa> but it’s so good for catching copy paste bugs

[17:39] <guifa> MasterDuke’s recommendation is from moritz, this one is from jmerelo 

[17:39] <guifa> https://www.apress.com/gp/book/9781484262573

[17:39] <tony-o> m: sub b (&o) { my $i=-1; nqp::until(nqp::islt_i(1, $i = nqp::add_i($i, 1)), o, :nohandler); };  b({ 'hi'.say; });

[17:39] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not find nqp::add_i, did you forget 'use nqp;' ?␤at <tmp>:1␤------> 3il(nqp::islt_i(1, $i = nqp::add_i($i, 1)7⏏5), o, :nohandler); };  b({ 'hi'.say; });␤»

[17:39] <guifa> They are both very good books

[17:39] <tony-o> m: use nqp; sub b (&o) { my $i=-1; nqp::until(nqp::islt_i(1, $i = nqp::add_i($i, 1)), o, :nohandler); };  b({ 'hi'.say; });

[17:39] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «hi␤hi␤»

[17:39] <tony-o> dakkar: looks like it should

[17:40] <notandinus> thanks, i'll check it out

[17:41] <dakkar> tony-o: then I don't see why benchy was suspiciously fast for me

[17:41] <tony-o> what version of raku are you on?

[17:42] <tony-o> you might try that one nqp one liner and see if it outputs 'hi\nhi\n'

[17:42] <dakkar> it does

[17:43] <dakkar> `raku -e 'use Benchy; my $a=0;my $b=0;my @front = ^100; my @back = ^100; b 2_000_000, { @front.unshift(1); @front.pop(); ++$a}, { @back.push(1); @back.shift(); ++$b };say $a;say $b'` prints 2000002 at the end

[17:44] <dakkar> so stuff gets called

[17:44] <dakkar> ok, Bench has finished, pop: 72.302 shift: 73.779

[17:45] <dakkar> anyway, end of workday for me, see I'll be back on monday

[17:50] *** brtastic left
[17:51] *** dakkar left
[17:53] *** patrickb joined
[18:02] <notandinus> so i wrote a script to find out the most active hour over here

[18:02] <notandinus> https://paste.debian.net/hidden/c73a0889/

[18:03] <notandinus> looks like it's 12:00 (UTC-5)

[18:05] <tony-o> what were the other values dakkar?

[18:06] <tony-o> my benchmark was on 2020.11

[18:07] <tbrowder> jmerelo: thanks!

[18:07] <tellable6> 2020-12-10T17:37:50Z #raku <jmerelo> tbrowder I think I've seen what you wanted to do; I've switched back the old version to draft, promoted the new version to be published in ~ 7 hours.

[18:14] *** morayj left
[18:15] <ggoebel> I'm not sure whether to be proud or ashamed of my 66 character solution to part 1 of today's AoC puzzle...

[18:15] <ggoebel> say lines».Int.sort.&{((|@$_,.max+3) Z-(0,|@$_)).Bag.&{.{1}*.{3}}}

[18:16] * lizmat doesn't like .&{ ... } very much

[18:17] <lizmat> feels like we should have better syntactic sugar for that

[18:19] <guifa> It’s ugly but it’s also internally consistent I suppose

[18:21] <guifa> tbrowder: re DateTime:: prefix, I’m actually thinking now about using an entirely different one, a User:: prefix for all types of “get information about current system/user preferences”, so User::Timezone, User::Locale, etc

[18:22] <lizmat> guifa: yeah, it's internally consistent  :-)

[18:22] <lizmat> bit it also looks like linenoise  :-)

[18:22] <lizmat> at least to me

[18:23] <guifa> I’m going to assume it’d not be visibly distinguished for most people but maybe

[18:23] <lizmat> when the RBP arrives (Raku Best Practices) book arrives...

[18:24] <guifa> maybe use the · for call-sub/block-as-method

[18:24] <guifa> foo·bar; foo·{bar}

[18:24] <guifa> eh…nah too small

[18:27] <jmerelo> We're waiting for your talks @ the FOSDEM perl & Raku devroom https://news.perlfoundation.org/post/fosdem-2021-call-for-papers you can send short, long, or longer talks, it's up to you!

[18:28] <guifa> jmerelo: I’ve got an idea for one

[18:29] <patrickb> tony-o: Are you around for a little longer?

[18:29] <tellable6> 2020-12-10T17:02:34Z #raku <tony-o> patrickb i kind of gave up on it, there didn't seem to be a lot of discussion about it in raku community. if you think this is not the case please lmk and i'll resume testing and playing around with it

[18:30] *** ufobat left
[18:31] <patrickb> tony-o: I kicked off a rather lenghty discussion about fixing our ecosystems in https://github.com/Raku/ecosystem/pull/512

[18:31] <jmerelo> BTW, check out also other tracks and tell them things about Raku. We want to expand the community as much as possible, and not get a blank stare and a "Rakuwhat?" every time we talk about Raku

[18:32] *** aborazmeh joined
[18:32] *** aborazmeh left
[18:32] *** aborazmeh joined
[18:33] <patrickb> tony-o: I was basically at the point of trying to do something about CPAN being a real pain to use. (I got lots of "you'll have little chance of succeeding, touching PAUSE is near to impossible" comments.)

[18:33] <lizmat> patrickb: you have no idea how long it took to get CPAN where it is now

[18:33] <lizmat> then again, maybe things have changed

[18:34] <lizmat> fwiw, I am the least likely person to pursue this and be successful

[18:34] <patrickb> tony-o: People tend to either lean on the side of "Let's do it like Go does and only have a very simple git repo approach" (aka keep p6c) and the other crew that says, p6c is difficult to get right and we should go for a proper solution.

[18:35] <lizmat> patrickb: the world is different from when CPAN started

[18:35] <patrickb> tony-o: Then I read about your proposal and was very happy that wouldn't have to try persuing a goal everyone warned me about.

[18:35] <lizmat> so an ecosystem that depends on one ore more cloud based content stores, should be workable nowadays

[18:38] <patrickb> tony-o: Then your proposal got rejected, and now I am in misery again. I still firmly believe we need to do something about the ecosystem, it's really really broken. Discussions tend to not flourish action as there are naysayers for all possible approaches I know of. So I think someone just has to push for a solution.

[18:39] <patrickb> tony-o: You are in a good position to come up with a good approach because of your knowledge of zef and knowing ugexe well. (ugexe being one of the few people who really understands the problems with our current ecosystems).

[18:40] <patrickb> tony-o: So yes, you do have my full support to push further with your ecosystem rewrite. I am willing to actually help.

[18:41] <patrickb> I hope tony-o actually notices the above...

[18:42] * patrickb is away for a bit. He does backlog.

[18:43] <guifa> jmerelo: I already have my title slide ready

[18:43] <jmerelo> guifa: which is...

[18:43] <guifa> Well, first slide after the title slide haha

[18:43] <guifa> one sec

[18:44] *** epony joined
[18:48] <guifa> https://imgur.com/WlzhL0e 

[18:49] <guifa> Title is going to be “Surprisingly unsurprising: Making things work for end users”

[18:49] <guifa> Or maybe something like “The joy in making things work for end users”

[18:49] <jmerelo> guifa: that's mirandés?

[18:49] <jmerelo> Préstame is not lend me?

[18:49] <guifa> asturiano

[18:50] <guifa> prestar = gustar

[18:50] <jmerelo> guifa: love it :-)

[18:51] <guifa> I’m thinking about starting to do a poetic epigraph for different files in my modules

[18:52] <guifa> When I was writing the advent post I remembered how cool it was to go through the tz database and its code: full of references to literature, waxing poetic on historians, fanciful and enlightening — if totally superfluous — musings

[18:52] <jmerelo> guifa++

[18:53] *** jmerelo left
[18:57] *** domidumont left
[18:58] *** sjm left
[18:59] <Grinnz> feel free to ask me or mst about feasibility of any particular PAUSE or CPAN changes, or tag us in to liaise

[19:00] *** sjm joined
[19:07] * guifa notes to self.  access penalty using method { .return with $!foo; $!foo = load-foo } over loading it at BUILD is 0.0002s 

[19:08] * perryprog gasps

[19:09] <guifa> perryprog: does it feel abnormally high or low to you?

[19:09] <perryprog> That seems very low to me

[19:09] <tony-o> patrickb: yea i'm around

[19:10] <perryprog> I would have to guess it's within experimental error

[19:11] <tony-o> patrickb: my code was at the point where it needs a zef plugin to use but was working in an alpha sort of way

[19:12] <guifa> It’s quite consistent in my tests. I do `say CLDR<en>.dates.calendars.gregorian.months.stand-alone.wide[11]` with 5 languages.  the .dates element is what I was testing on lazy load penalty

[19:12] <guifa> all else is pre-cached

[19:12] <tony-o> go's ecosystem is horrific.  so is pythons. haskell's is fine but is way too manual

[19:13] *** sjm left
[19:13] <tony-o> lizmat: my code uses cloudflare and s3 and was pretty pluggable with other similar serices

[19:13] *** sjm joined
[19:17] <guifa> whoa

[19:17] <guifa> actually it’s even less

[19:17] <guifa> m: say my $lazy-load-avg = ([+] 0.0003798, 0.0004655, 0.00043866, 0.000378, 0.0003691, 0.00038276, 0.000360024, 0.0003852, 0.00038173, 0.00043363) / 10;

[19:17] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «0.0003974404␤»

[19:17] <guifa> say my $eager-load-avg = ([+] 0.0003076, 0.000297, 0.00032552, 0.00032676, 0.000297, 0.0002976, 0.0003199, 0.0003535, 0.0003071, 0.000342) / 10; say "Difference: ", $lazy-load-avg - $eager-load-avg

[19:17] *** Maylay left
[19:17] *** samcv left
[19:17] <guifa> m: say my $lazy-load-avg = ([+] 0.0003798, 0.0004655, 0.00043866, 0.000378, 0.0003691, 0.00038276, 0.000360024, 0.0003852, 0.00038173, 0.00043363) / 10; say my $eager-load-avg = ([+] 0.0003076, 0.000297, 0.00032552, 0.00032676, 0.000297, 0.0002976, 0.0003199, 0.0003535, 0.0003071, 0.000342) / 10; say "Difference: ", $lazy-load-avg - $eager-load-avg

[19:17] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «0.0003974404␤0.000317398␤Difference: 0.0000800424␤»

[19:18] *** sivoais left
[19:19] *** samcv joined
[19:19] *** Maylay joined
[19:20] *** sivoais joined
[19:22] *** abraxxa left
[19:28] *** samcv_ joined
[19:30] *** samcv left
[19:30] *** Maylay left
[19:30] *** Maylay joined
[19:33] *** BenGoldberg joined
[19:35] *** rindolf left
[19:46] *** sjm_uk left
[19:54] *** rir joined
[19:57] *** wamba joined
[20:05] <guifa> m: class Foo is Associative { method AT-KEY ($) { 42 } }; say Foo<a>;

[20:05] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «42␤»

[20:05] <guifa> class Foo is Associative { method AT-KEY ($) { 42 } }; say Foo{'a'}

[20:05] <guifa> m: class Foo is Associative { method AT-KEY ($) { 42 } }; say Foo{'a'}

[20:05] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Autovivifying object closures not yet implemented. Sorry.␤at <tmp>:1␤------> 3method AT-KEY ($) { 42 } }; say Foo{'a'}7⏏5<EOL>␤»

[20:06] <guifa> Anyway to get around that compile error?

[20:07] *** BenGoldberg left
[20:08] <patrickb> tony-o: We are in different timezones. Communication tends to be a bit difficult. How could I get involved? Is there any code I could dig into? Do you have a list of open tasks?

[20:10] <stoned75> guifa: F{'a'}. really ? Are you sure you do not mean Foo.new{'a'} (Foo.new<a> btw) ?

[20:10] <stoned75> s/F/Foo/

[20:11] <guifa> stoned75: yeah.  It’s a singleton object, so I’ve no need for it to be instantiated

[20:11] <stoned75> I see

[20:11] <stoned75> Map<a> Map{'a'} behave the same

[20:12] <moritz> jsut be careful, < > splits on whitespace

[20:12] <moritz> os %h<a b c > is the same as %h{'a', 'b', 'c'}, not %h{'a b c '}

[20:12] <moritz> s/os/so/

[20:13] <[Coke]> back in review saw this question, and an almost answer, but this works:

[20:14] <[Coke]> m: my @a = 1,2,3,4,2,0,0,7,8,9; dd @a.rotor(3 => -2).grep(* ~~ (2,0,0))

[20:14] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «((2, 0, 0),).Seq␤»

[20:14] <guifa> moritz: Yeah.  In this use case, I don’t think anyone would ever call it with spaces it (it’s to call up language codes)

[20:15] <guifa> I mean I guess I can give the class a different name and export an instantiated copy but … feels like a lot of work ^_-

[20:18] <tony-o> patrickb: i can start a channel or pm is fine, i need to stand up the infrastructure again and we can work on a zef plugin

[20:19] *** hal99999 left
[20:19] <tony-o> nick had a few notes too, need to see if i can find them or if i lost them

[20:23] *** aborazmeh_ joined
[20:23] *** aborazmeh_ left
[20:23] *** aborazmeh_ joined
[20:23] *** aborazmeh left
[20:23] *** aborazmeh_ is now known as aborazmeh

[20:31] <Geth> ¦ doc/more-catch-index: 19741db102 | (Stoned Elipot)++ | doc/Language/exceptions.pod6

[20:31] <Geth> ¦ doc/more-catch-index: Add more CATCH index locations

[20:31] <Geth> ¦ doc/more-catch-index: review: https://github.com/Raku/doc/commit/19741db102

[20:31] <Geth> ¦ doc: stoned++ created pull request #3729: Add more CATCH index locations

[20:31] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3729

[20:38] *** aborazmeh left
[20:41] *** morayj joined
[20:45] *** kensanata joined
[20:46] *** stoned75 left
[20:51] <raku-bridge> <EsperLily> Why does this not work? "abc" ~~ /:r [ "a" || "ab" ] "c" /

[20:51] <raku-bridge> <EsperLily> || is documented as trying alternatives even in non-backtracking contexts. Using | works but || doesn't

[20:57] <moritz> in ["a" || "ab"], the first alternative is prefered, so it matches "a". The :r (ratchet) tells the regex engine not to try a different path when the following token doesn't match

[20:57] *** aborazmeh joined
[20:57] *** aborazmeh left
[20:57] *** aborazmeh joined
[20:59] <moritz> in [a|ab]c, all parts of the regex are part of a "regular" language, and so are compiled into an NFA that matches the whole string without backtracking

[20:59] <moritz> || is not regular, it's explicitly sequential

[21:08] *** sena_kun joined
[21:10] *** Altai-man left
[21:23] <raku-bridge> <EsperLily> https://docs.raku.org/language/regexes#Alternation:_|| says "Even in non-backtracking contexts, the alternation operator || tries all the branches in order until the first one matches."

[21:26] <moritz> yes, abut it doesn't try the second one, if the first one already matched

[21:27] <raku-bridge> <EsperLily> since it's mentioning non-backtracking contexts, I interpret "matched" as meaning the entire branch matches

[21:32] <raku-bridge> <EsperLily> bleh, /:r [ a | {} ab ] c/ won't match either

[21:37] <raku-bridge> <EsperLily> ooh wait, I just realized my confusion with [ a || ab ]. The whole group matches on the first branch, then fails after the group, so it won't backtrack

[21:38] <raku-bridge> <EsperLily> and [ a | ab ] works because it's matching the longest declarative prefix, which ends up being "ab"

[21:38] <raku-bridge> <EsperLily> [ a | {} ab ] doesn't because the longest declarative prefix matches "a" instead

[21:48] <guifa> EsperLily: exactly

[21:49] *** patrickb left
[22:10] *** pilne joined
[22:13] *** morayj left
[22:26] *** grep0r left
[22:26] *** grep0r joined
[22:27] *** aborazmeh left
[22:31] *** lucasb joined
[22:39] *** skids left
[22:43] *** sena_kun left
[22:46] <coldpress> moritz │ coldpress: what do you want to achieve?

[22:48] <coldpress> moritz: calculate prefix sum of an array of numbers https://en.wikipedia.org/wiki/Prefix_sum

[22:58] *** BenGoldberg joined
[23:06] <guifa> coldpress: ([\+] @numbers).tail

[23:06] *** cpan-raku left
[23:06] <guifa> m: say [\+] ^10

[23:06] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «(0 1 3 6 10 15 21 28 36 45)␤»

[23:07] <guifa> m: say ([\+] ^10).tail

[23:07] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «45␤»

[23:08] *** gfldex left
[23:08] *** gfldex joined
[23:09] <coldpress> guifa: thanks, it's not easy to search for this in Raku docs

[23:10] <guifa> The [\+] is in the metaoperators section.  Basically, you can put any operator inside of [ ] and it will turn it into a reduce function for you

[23:11] <guifa> If you use [\ ] (in Raku terminology, a triangle reduction becase [\ looks like a triangle lol) it does the euqivalent of what other languages call a scan

[23:12] *** cpan-raku joined
[23:12] *** cpan-raku left
[23:12] *** cpan-raku joined
[23:13] <guifa> (even better, it’s lazy, so you can use it on infinite lists)

[23:14] *** Jack joined
[23:14] <guifa> my @a = [\+] ^Inf; say @a; say @a[10]

[23:14] <evalable6> guifa, rakudo-moar 9dbb52f9e: OUTPUT: «[...]␤55␤»

[23:14] *** squashable6 left
[23:14] *** Jack left
[23:16] *** squashable6 joined
[23:19] *** melezhik joined
[23:20] <melezhik> .tell @patrickb at some point I was trying to help tony-o as well, he is aware, with new eco system stuff . For example - http://sparrowhub.io/search?q=function

[23:20] <tellable6> melezhik, I cannot recognize this command. See wiki for some examples: https://github.com/Raku/whateverable/wiki/Tellable

[23:21] <melezhik> .tell  @patrickb at some point I was trying to help tony-o as well, he is aware, with new eco system stuff . For example - http://sparrowhub.io/search?q=function

[23:21] <tellable6> melezhik, I cannot recognize this command. See wiki for some examples: https://github.com/Raku/whateverable/wiki/Tellable

[23:21] <melezhik> .tell  patrickb: at some point I was trying to help tony-o as well, he is aware, with new eco system stuff . For example - http://sparrowhub.io/search?q=function

[23:21] <tellable6> melezhik, I'll pass your message to patrickb

[23:23] <tbrowder> .tell jmerelo the latest source is here: https://github.com/tbrowder/advent2020/blob/master/fancy-advent.html

[23:23] <tellable6> tbrowder, I'll pass your message to jmerelo

[23:25] <tbrowder> .tell jmerelo same title: Santa Claus TWEAKs with a Class

[23:25] <tellable6> tbrowder, I'll pass your message to jmerelo

[23:25] *** aluaces left
[23:26] *** kensanata left
[23:33] *** BenGoldberg left
[23:41] *** pilne left
[23:51] *** melezhik left
[23:54] *** asymptotically left
[23:55] *** abraxxa joined
