[00:04] *** zacts left
[00:07] *** zacts joined
[00:08] *** zacts left
[00:13] *** zacts joined
[00:20] <[Coke]> I'm about 75% done on my article - is there pressure to get it done before midnight?

[00:25] *** aborazmeh joined
[00:25] *** aborazmeh left
[00:25] *** aborazmeh joined
[00:35] *** Doc_Holliwood joined
[00:39] *** Kaeipi joined
[00:39] *** Kaiepi left
[00:52] *** epony left
[00:53] *** epony joined
[01:00] *** __jrjsmrtn__ joined
[01:01] *** _jrjsmrtn left
[01:14] *** Altai-man joined
[01:17] *** sena_kun left
[01:28] *** aborazmeh left
[01:33] *** Doc_Holliwood left
[01:40] <Geth> ¦ doc: 99a5f62f16 | Coke++ | doc/Language/quoting.pod6

[01:40] <Geth> ¦ doc: fix spelling

[01:40] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/99a5f62f16

[01:40] <linkable6> Link: https://docs.raku.org/language/quoting

[01:42] *** MilkmanDan left
[01:43] *** molaf left
[01:44] *** MasterDuke left
[01:56] *** telex left
[01:56] *** molaf joined
[01:58] *** telex joined
[02:21] <guifa> Is there anyway a module can insert a dynamic variable into the same scope as the ‘use’ statement so it can have lexically scoped values?

[02:26] *** AlexDaniel joined
[02:26] *** AlexDaniel left
[02:26] *** AlexDaniel joined
[02:27] *** aborazmeh joined
[02:27] *** aborazmeh left
[02:27] *** aborazmeh joined
[02:29] *** fooist joined
[02:35] *** fooist left
[02:38] *** fooist joined
[02:43] *** fooist left
[02:44] *** fooist joined
[02:44] <fooist> guifa: is this what you’re looking for? https://docs.raku.org/language/modules#EXPORT

[02:55] *** fooist left
[02:57] *** MilkmanDan joined
[03:08] *** zacts left
[03:13] *** zacts joined
[03:15] *** aborazmeh left
[04:15] *** unicodable6 left
[04:15] *** benchable6 left
[04:15] *** quotable6 left
[04:15] *** coverable6 left
[04:15] *** notable6 left
[04:15] *** linkable6 left
[04:15] *** bloatable6 left
[04:15] *** releasable6 left
[04:15] *** nativecallable6 left
[04:15] *** reportable6 left
[04:15] *** statisfiable6 left
[04:15] *** evalable6 left
[04:15] *** shareable6 left
[04:15] *** sourceable6 left
[04:15] *** committable6 left
[04:15] *** greppable6 left
[04:15] *** bisectable6 left
[04:15] *** tellable6 left
[04:15] *** squashable6 left
[04:15] *** coverable6 joined
[04:15] *** benchable6 joined
[04:16] *** sourceable6 joined
[04:16] *** linkable6 joined
[04:16] *** releasable6 joined
[04:16] *** unicodable6 joined
[04:16] *** shareable6 joined
[04:16] *** evalable6 joined
[04:16] *** nativecallable6 joined
[04:16] *** bisectable6 joined
[04:16] *** greppable6 joined
[04:16] *** tellable6 joined
[04:16] *** bloatable6 joined
[04:16] *** quotable6 joined
[04:17] *** ensamvarg3 joined
[04:17] *** statisfiable6 joined
[04:17] *** squashable6 joined
[04:17] *** reportable6 joined
[04:18] *** notable6 joined
[04:18] *** committable6 joined
[04:18] *** cpan-raku left
[04:19] *** cpan-raku joined
[04:20] *** cpan-raku left
[04:20] *** cpan-raku joined
[05:15] *** sena_kun joined
[05:16] *** Altai-man left
[05:27] *** gnufr33dom joined
[05:46] *** bocaneri joined
[05:48] *** ab5tract left
[05:48] *** ab6tract left
[05:59] *** Grauwolf_ is now known as Grauwolf

[06:11] *** Doc_Holliwood joined
[06:19] *** ab5tract joined
[06:19] *** ab6tract joined
[06:20] <ab6tract> hey timotimo, great! except I have the complete edition of Comma so was planning to use the opportunity to explore the extended profiling options there :D

[06:21] <ab6tract> I just want to take a bit of a break from the rational topic, definitely planning to post a follow-up on the personal blog

[06:23] *** sjm_uk joined
[06:26] *** skids left
[06:34] *** JJMerelo joined
[06:36] *** zacts left
[06:37] *** zacts joined
[06:47] *** zacts left
[07:16] *** MilkmanDan left
[07:17] *** MilkmanDan joined
[07:22] <Geth> ¦ advent: eb7f7bd6fa | (JJ Merelo)++ | 20th/articles/rfc307.html

[07:22] <Geth> ¦ advent: Starting RFC 307, just in case

[07:22] <Geth> ¦ advent: review: https://github.com/Raku/advent/commit/eb7f7bd6fa

[07:35] *** Sgeo left
[07:36] *** leont joined
[07:55] <Geth> ¦ advent: 691fb5732d | (JJ Merelo)++ | 20th/articles/rfc307.html

[07:55] <Geth> ¦ advent: Finishing draft

[07:55] <Geth> ¦ advent: review: https://github.com/Raku/advent/commit/691fb5732d

[07:55] <JJMerelo> OK, finished this draft which I'll hold as reserve, or schedule it for today if nothing shows up earlier. Comments and suggestions are welcome.

[08:00] *** JJMerelo left
[08:35] *** Doc_Holliwood left
[08:39] *** squashable6 left
[08:39] *** squashable6 joined
[08:41] *** kensanata joined
[08:43] *** wamba joined
[08:51] *** Doc_Holliwood joined
[09:04] *** molaf left
[09:11] <Geth> ¦ advent: taboege++ created pull request #60: 20th: Write about RFC 190

[09:11] <Geth> ¦ advent: review: https://github.com/Raku/advent/pull/60

[09:14] *** Altai-man joined
[09:16] *** sena_kun left
[09:47] *** molaf joined
[09:49] *** ab6tract left
[09:49] *** ab5tract left
[09:57] *** wamba left
[09:59] *** molaf left
[10:03] *** bocaneri left
[10:03] *** Doc_Holliwood left
[10:06] *** wamba joined
[10:06] *** rindolf joined
[10:06] *** ab5tract joined
[10:06] *** ab6tract joined
[10:07] *** ab5tract_ joined
[10:11] <Geth> ¦ advent: c49ded740b | (Tobias Boege)++ | 2 files

[10:11] <Geth> ¦ advent: 20th: Write about RFC 190

[10:11] <Geth> ¦ advent: review: https://github.com/Raku/advent/commit/c49ded740b

[10:11] <Geth> ¦ advent: 51b45d72de | (Tobias Boege)++ | 20th/articles/rfc190.md

[10:11] <Geth> ¦ advent: Linkify RFC 190

[10:11] <Geth> ¦ advent: review: https://github.com/Raku/advent/commit/51b45d72de

[10:11] <Geth> ¦ advent: fb27f4443a | (Tobias Boege)++ (committed using GitHub Web editor) | 2 files

[10:11] <Geth> ¦ advent: Merge pull request #60 from taboege/master

[10:11] <Geth> ¦ advent: 

[10:11] <Geth> ¦ advent: 20th: Write about RFC 190

[10:11] <Geth> ¦ advent: review: https://github.com/Raku/advent/commit/fb27f4443a

[10:11] *** ab5tract left
[10:11] *** ab6tract left
[10:12] *** ab5tract joined
[10:14] *** molaf joined
[10:18] *** cpan-raku left
[10:19] *** cpan-raku joined
[10:19] *** cpan-raku left
[10:19] *** cpan-raku joined
[10:34] *** molaf left
[10:42] *** dolmen joined
[10:42] <Geth> ¦ advent: 538971c610 | (Tobias Boege)++ | 20th/articles/rfc190.md

[10:42] <Geth> ¦ advent: Add halfsentence to article

[10:42] <Geth> ¦ advent: review: https://github.com/Raku/advent/commit/538971c610

[10:44] *** Black_Ribbon left
[10:48] *** JJMerelo joined
[11:02] *** JJMerelo left
[11:09] *** stoned75 joined
[11:36] <Geth> ¦ doc/setbagmix-op: c032704ed8 | (Stoned Elipot)++ | 6 files

[11:36] <Geth> ¦ doc/setbagmix-op: Simplify and uniformize sections on set operators

[11:36] <Geth> ¦ doc/setbagmix-op: 

[11:36] <Geth> ¦ doc/setbagmix-op: While here tweak examples' output to match current rakudo behavior

[11:36] <Geth> ¦ doc/setbagmix-op: and remove (now?) inaccurate mention about results' type with SetHash

[11:36] <Geth> ¦ doc/setbagmix-op: operands.

[11:36] <Geth> ¦ doc/setbagmix-op: review: https://github.com/Raku/doc/commit/c032704ed8

[11:37] <Geth> ¦ doc: stoned++ created pull request #3557: Simplify and uniformize sections on set operators

[11:37] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3557

[11:39] *** wamba left
[11:51] *** wamba joined
[12:14] *** rindolf left
[12:16] *** Doc_Holliwood joined
[12:23] *** molaf joined
[12:31] *** stoned75 left
[12:34] *** rindolf joined
[12:40] *** dolmen left
[12:51] *** molaf left
[13:00] *** dolmen joined
[13:04] *** Doc_Holliwood left
[13:06] *** skids joined
[13:10] *** stoned75 joined
[13:15] *** sena_kun joined
[13:17] *** Altai-man left
[13:28] *** keutoi joined
[13:28] <keutoi> Is there a reference manual for raku?

[13:30] <codesections> keutoi: I'm not quite sure what you mean by "reference manual".  The language documentation is at docs.raku.org  If that isn't what you're looking for, can you be a bit more specific about what you'd like?

[13:32] <keutoi> This is what I am looking for, https://docs.raku.org/language.html. Thanks.

[13:32] <keutoi> Is there any offline pdf version of it?

[13:36] *** squashable6 left
[13:36] <codesections> I'm not aware of a PDF version.  The p6doc tool (which I believe is installed by default with the toolchain?) has an offline plaintext version

[13:37] <codesections> I'm pretty sure that tool is in the process of being upgraded/rewritten as rakudoc, but I'm not positive of the status of that process

[13:37] *** squashable6 joined
[13:39] <codesections> You can also build the HTML documentation locally using https://github.com/Raku/Documentable

[13:39] <codesections> (which is how it's built for the site)

[13:40] <keutoi> Things would be a lot easier if these were available for default: https://github.com/Raku/doc/tree/master/doc/Language

[13:40] <keutoi> something like perldoc

[13:40] *** molaf joined
[13:42] *** molaf left
[13:42] <codesections> I'm not quite sure I follow (others probably would – many people have experience with perl that I lack).  But my understanding was that p6doc/rakudoc were intended to be direct equivalents to perldoc

[13:45] <keutoi> codesections: So rakudoc/p6doc is equivalent to perldoc? Is it packaged separately or does it come with raku itself?

[13:46] <tobs> I only know that once upon a time I `zef install p6doc`d and got the pod files for offline documentation in the perldoc manner.

[13:46] <tobs> But there have been changes. I don't know how it works nowadays and I couldn't find out tracing these repositories.

[13:46] <codesections> I *thought* it was came with Raku, but I can't remember 100% (it might be packaged with Rakudo Star, which is Rakudo + some helpful packages, but doesn't release as often)

[13:47] <codesections> s/was came/came/

[13:47] <tobs> In any case, in your stead I would try to install the new rakudoc with zef and see if it brings the documentation files with it, and if not open an issue.

[13:47] <codesections> Oh, if tobs had to install it with zef (the raku package manager) then it must not have come with Raku

[13:48] <tobs> this was in 2017 :)

[13:48] <codesections> My (maybe wrong) understanding is that rakudoc isn't really released yet, and you should still use p6 doc

[13:48] <codesections> *p6doc

[13:49] <keutoi> I found p6doc using zef. Let me try install and see...

[14:00] <rypervenche> p6doc should work for you. rakudoc is not yet ready.

[14:02] <codesections> rypervenche: do you know what advantages rakudoc will provide (other than the updated name, I mean :D)

[14:02] <codesections> ?

[14:06] <rypervenche> codesections: What I know is the current documentation roadmap here: https://github.com/Raku/doc/issues/2983

[14:06] <keutoi> Hmm, `zef install p6doc` fails with permissions requiring /usr/share/perl6/doc/site: mkdir failed. A defaulting to home directory installation would have been nice.

[14:07] <codesections> hmm, agreed, keutoi.  I'm not sure if that's a p6doc issue or a zef one

[14:07] <rypervenche> keutoi: Yes, that's unfortunately the current state of p6doc, it needs to be run as root. I'm also a fan of keeping things inside my home directory.

[14:08] <codesections> rypervenche: thanks, I'd seen that roadmap but wasn't sure if it was still the current plan.  So it's helpful to hear that it is :)

[14:21] <tbrowder> leont: you here?

[14:22] *** Sgeo joined
[14:26] <leont> Busy with $work, but otherwise yes

[14:26] <tellable6> 2020-08-12T17:10:30Z #raku <JJMerelo> leont still nothing scheduled for today. I'm gonna upload your article. Please accept the invitation and I'll assign authorship to you.

[14:26] <tellable6> 2020-08-13T06:45:37Z #raku-dev <JJMerelo> leont I still need you to accept the invitation so that the article carries your byline (and you can edit it if necessary)

[14:26] <tbrowder> .ask leont how can i, using Path::Finder, limit a base :name to the dos glob "[A-Z]*"?

[14:26] <tellable6> tbrowder, I'll pass your message to leont

[14:26] <leont> I'm here ;-)

[14:27] <tbrowder> ok! i'm trying out path::finder for first time and all is well except the globbing prob ^^

[14:28] <tbrowder> i live the depth restiction File::Find doesn't have

[14:28] <tbrowder> *love

[14:28] <tbrowder> *restriction

[14:28] <leont> Passing it like that should work, it will convert a Str argument to an IO::Glob

[14:29] <tbrowder> but it seems IO::Glob has the same problem

[14:30] <tbrowder> i see no test in either module for that case, or how to implement it

[14:32] <tbrowder> i can do it after the fact but thought you could show how to do it

[14:33] <tbrowder> if we could "use module" here (hint, hint) it would be "usefu"

[14:33] *** dogbert17 joined
[14:34] *** skids left
[14:35] <tbrowder> maettu: is there any way to load more modules into camelia?

[14:37] <codesections> tbrowder: the other day AlexDaniel showed a way to load modules into one of the other evalbots (evalable?)

[14:37] <tbrowder> m: use IO::Glob

[14:37] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not find IO::Glob in:␤    inst#/home/camelia/.raku␤    inst#/home/camelia/rakudo-m-inst-2/share/perl6/site␤    inst#/home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    inst#/home/camelia/…»

[14:37] <codesections> You can search the logs for the details

[14:37] <AlexDaniel> I should make it simpler :)

[14:37] <tbrowder> but we were told that would be a security problem for the bots to do it

[14:38] <AlexDaniel> no? Who told you that? You can already run arbitrary code x)

[14:39] <codesections> Well, it's a security *concern* certainly.  And I think whoever maintains camelia said they didn't want the maintainence burden of adding that feature

[14:39] <codesections> but I guess that's why we have multiple bots :)

[14:39] <AlexDaniel> huh? where have you all heard all that weird stuff? x)

[14:39] *** Doc_Holliwood joined
[14:40] *** Sgeo left
[14:40] <tbrowder> well go look back at the log. i then asked why most all the modules couldn't be available on the server and...

[14:40] <AlexDaniel> the current situation is that all bots allow you to do a bit too much. Respect them and don't break them. That's about it.

[14:42] <AlexDaniel> all except perlbot, that one is sandboxed properly, but then you get all the limitations

[14:42] <codesections> AlexDaniel: the conversation tbrowder mentioned was at https://colabti.org/irclogger/irclogger_log/raku?date=2020-08-05#l501

[14:43] <guifa> Let’s say I have a dynamic variable

[14:44] <guifa> Is there a way I can get a (pref ordered) list of all matching ones up the call chain?

[14:44] <AlexDaniel> “I don't want camelia's build process to get any more complicated” – I don't see anything about security

[14:44] <AlexDaniel> and that's right, because the bot is not secure by itself

[14:45] *** molaf joined
[14:46] <lizmat> guifa: not without the use of nqp ops

[14:46] <lizmat> afaik

[14:46] <codesections> Yeah, you're right.  I guess it was a bit later (https://colabti.org/irclogger/irclogger_log/raku?date=2020-08-05#l651 ) when _rba speculated about security issues.  But I guess that isn't quite right.  Thanks for the correction :)

[14:47] <tbrowder> ok, so how do we use a module with camelia?

[14:48] <guifa> lizmat: ah okay.  I was experimenting around with scoping overrides/fallbacks for UserLanguage and UserTimezone, and things work perfectly … until an override is cleared and then it goes to the normal setting, rather than grabbing any enclosing override.

[14:48] <guifa> that said, that’s probably a much more manageable quirk than having fallback/overrides be global only

[14:49] <lizmat> dynamic variables have been good enough to make parsing Raku actually work... so  I guess you need to look at what you're trying to achieve

[14:52] <guifa> lizmat: no doubt.  I think actually I should probably include the whole override chain with each use * :override statement instead of trying to do a single variable

[14:53] <guifa> When you add a custom operator, that scope basicallt gets a cloned copy of the grammar, plus the new operator, yeah?

[14:53] <codesections> guifa: I'm slightly confused – I thought CALLERS did what you're asking about?

[14:54] <codesections> or OUTERS

[14:55] <codesections> Oh, I guess they don't return a list?  Just the first match?  That's a shame

[14:55] <guifa> CALLERS and OUTERS go up the chain but will only return the first value — at least in my first implementation attempt, the issue would be when one of them was undefined, I’d want to progress to the *next* one up, and if it......

[14:56] <guifa> yeah that :-)

[14:57] <lizmat> guifa: did you try CALLERS::CALLERS:: ?

[14:57] <vrurg> CALLERS flatten down the call stack contexts. It's CALLER which gives exactly one.

[14:58] <codesections> vrurg: that's what I thought too.  But actually, CALLERS gives exactly one result from any number of stacks

[14:58] <guifa> m: my $a = 1; { my $a = 2; { my $a = 3; { my $a = 4; { say $OUTERS::a } } } }; 

[14:58] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «4␤»

[14:58] <guifa> (as opposed to (4, 3, 2, 1) )

[14:59] <vrurg> Besides, I had to rewrite the PseudoStash for 6.e because in 6.c there was too many flaws.

[14:59] * guifa agrees that 4 is the best DWIM result, for the record

[15:00] <vrurg> codesections: I didn't follow the whole discussion, just was passing by. What one result do you mean?

[15:00] <guifa> vrurg: basically, getting just scalar 4, as opposed to listy (4,3,2,1) in the above example

[15:00] <codesections> yeah, that

[15:02] <codesections> I would have thought this would work, but it seems not to: 

[15:02] <codesections> m:   {my $*a = 1; { my $*a is default(CALLERS::<$*a>) = 2; $*a = Nil; { say OUTERS::('$*a')}}}

[15:02] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «Nil␤»

[15:02] *** MilkmanDan left
[15:02] <vrurg> Any pseudostash is looking for the first occurence only. I.e. it gives you the symbol visible in a  particular context. To get a list one would have to traverse the contexts manually.

[15:02] *** MilkmanDan joined
[15:06] <guifa> I’ll probably do something akin to my @*override .= append: CALLERS::<@*override>, $new-override;

[15:06] <guifa> at each level

[15:07] <codesections> Any idea why the `is default(OUTERS::<@*override>)` approach doesn't seem to work? 

[15:07] <codesections> Will traits just not work with dynamic variables?

[15:10] <codesections> Or variables at all, I guess.  

[15:10] <vrurg> I guess the confusion comes from the plural for of CALLERS/OUTERS names. But the point of it is to make distinction between CALLER/OUTER which give exactly and only the requested scope contrary to collecting data from all upstream frames.

[15:10] <codesections> m: {constant $a=1; {my $b is default(OUTERS::<$a>); say $b}}

[15:10] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «1␤»

[15:10] * vrurg is afk for a while.

[15:11] <guifa> Having an ALL-CALLERS and ALL-OUTERS could be cool, but would probably be of very limited used and definitely has workarounds

[15:12] *** aluaces left
[15:14] *** stoned75 left
[15:18] *** MilkmanDan left
[15:18] *** squashable6 left
[15:19] <lucs> Does having 'use v6.e' mean "This code requires at least version 6.e of Raku to run correctly" or rather "This code can only use features that are present in version 6.e (although I'm running 6.f for example)"?

[15:20] *** squashable6 joined
[15:22] <[Coke]> if something is only defined in 6.f, and you are in a block that has 6.e, it is expected to fail.

[15:22] <[Coke]> (if you use the aforementioned something)

[15:23] <[Coke]> if you don't specify, you get latest, which in your example, I assume is 6.f

[15:23] *** ab5tract_ left
[15:23] *** ab5tract left
[15:26] <lucs> So more the latter, eh. Thanks.

[15:27] <lucs> By the way, that sounds painful to maintain for the developers.

[15:27] <[Coke]> "torture the implementors on behalf of the users" was a motto

[15:27] <lucs> :)

[15:27] *** molaf left
[15:27] *** MilkmanDan joined
[15:28] <AlexDaniel> [Coke]: I think language switching can only be done in files, not in blocks

[15:32] <[Coke]> m: use v6.d; say "hi"; {use v6.c; say "I think it works, maybe it doesn't restrict?"}

[15:32] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «Don't know setting RESTRICTED␤   at gen/moar/ModuleLoader.nqp:249  (/home/camelia/rakudo-m-inst-2/share/perl6/lib/Perl6/ModuleLoader.moarvm:previous_setting_name)␤ from gen/moar/ModuleLoader.nqp:254  (/home/camelia/rakudo-m-inst-2/share/perl6/lib/…»

[15:33] <[Coke]> oops.

[15:34] <[Coke]> so, s/block/file/ in my statement.

[15:34] <[Coke]> AlexDaniel++

[15:34] <lucs> Okiedoke

[15:34] <AlexDaniel> e: use v6.d; say "hi"; {use v6.c; say "I think it works, maybe it doesn't restrict?"}

[15:34] <evalable6> AlexDaniel, rakudo-moar 9d6d8dd7a: OUTPUT: «(exit code 1) 04===SORRY!04=== Er…»

[15:34] <evalable6> AlexDaniel, Full output: https://gist.github.com/e062001407aaa70c6828c192ca5833f4

[15:34] <AlexDaniel> “Too late to switch language version. Must be used as the very first statement.”

[15:38] <Geth> ¦ doc: a0e2aa0fb3 | stoned++ (committed using GitHub Web editor) | 6 files

[15:38] <Geth> ¦ doc: Simplify and uniformize sections on set operators (#3557)

[15:38] <Geth> ¦ doc: 

[15:38] <Geth> ¦ doc: While here tweak examples' output to match current rakudo behavior

[15:38] <Geth> ¦ doc: and remove (now?) inaccurate mention about results' type with SetHash

[15:39] <Geth> ¦ doc: operands.

[15:39] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/a0e2aa0fb3

[15:39] <linkable6> DOC#3557 [closed]: https://github.com/Raku/doc/pull/3557 Simplify and uniformize sections on set operators

[15:39] *** keutoi left
[15:41] <codesections> m: my &*a= {1}; { my &*a is default( { say CALLER::CALLER::<&*a>()}) = { 2 }; say &*a(); &*a = Nil; say &*a() }

[15:41] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «2␤1␤True␤»

[15:42] <codesections> guifa: ^^^^ works (I realize I spent far too long thinking about that, esp. considering it's not even my code, it doesn't generate an elegant solution, and you already have a (probably better) workaround)

[15:43] <codesections> *but* it was helpful in understanding what Raku is doing at compile time vs runtime, so not *entirely* a waste :)

[15:43] <codesections> er, there's any extra `say` I didn't mean to have

[15:44] <codesections> m: my &*a= {1}; { my &*a is default( { CALLER::CALLER::<&*a>()}) = { 2 }; say &*a(); &*a = Nil; say &*a() }

[15:44] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «2␤1␤»

[15:46] <Geth> ¦ advent: cf33725412 | (Elizabeth Mattijsen)++ (committed using GitHub Web editor) | 20th/README.md

[15:46] <Geth> ¦ advent: Claim #159

[15:46] <Geth> ¦ advent: 

[15:46] <Geth> ¦ advent: Turns out that the intro to #200 is worth a blog post of its own

[15:46] <Geth> ¦ advent: review: https://github.com/Raku/advent/commit/cf33725412

[15:54] *** demostanis joined
[15:54] <demostanis> Hello everyone! I am trying to install GPGME module, but it is failing with this error: ===> Failed to find dependencies: gpgme:from<native>

[15:54] <demostanis> What does this mean?

[15:54] *** Chi1thangoo left
[15:55] <codesections> demostanis: it means that it expected you to have a non-Raku package `gpgme` installed, but you don't

[15:55] <codesections> (e.g., though your package manager) 

[15:55] <codesections> s/you don't/it can't find it/

[15:56] <demostanis> I did as they adviced, sudo apt install libgpgme11, but it doesn't change anything.

[15:56] <demostanis> Or do I need libgpgme-dev?

[15:57] <codesections> I'm not sure.  I can interpret the error msg, but that's about it :)

[15:58] <demostanis> I believe that was the error.

[15:59] <demostanis> They should change their README, but it has been 2 months seen the project had a change.

[16:01] <codesections> 2 months isn't that long :)

[16:01] <Geth> ¦ doc/mix-op-ref: 0a9d217b35 | (Stoned Elipot)++ | 2 files

[16:01] <Geth> ¦ doc/mix-op-ref: More on { } and < > operators for Mix and MixHash

[16:01] <Geth> ¦ doc/mix-op-ref: 

[16:01] <Geth> ¦ doc/mix-op-ref: - mention <> postcircumfix

[16:01] <Geth> ¦ doc/mix-op-ref: - add ref to operators' description

[16:01] <Geth> ¦ doc/mix-op-ref: review: https://github.com/Raku/doc/commit/0a9d217b35

[16:01] *** stoned75 joined
[16:01] <tbrowder> e: use IO::Glob;

[16:01] <evalable6> tbrowder, rakudo-moar 9d6d8dd7a: OUTPUT: «(exit code 1) 04===SORRY!04=== Er…»

[16:01] <evalable6> tbrowder, Full output: https://gist.github.com/619b0a2d065cd30b5b63a668de84d102

[16:01] <Geth> ¦ doc: stoned++ created pull request #3558: More on { } and < > operators for Mix and MixHash

[16:01] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3558

[16:02] <tbrowder> e: use NativeCall;

[16:02] <evalable6> tbrowder, rakudo-moar 9d6d8dd7a: OUTPUT: «»

[16:03] <tbrowder> m: use NativeCall;

[16:03] <camelia> rakudo-moar 9d6d8dd7a: ( no output )

[16:03] <tbrowder> e: require IO::Glob

[16:03] <evalable6> tbrowder, rakudo-moar 9d6d8dd7a: OUTPUT: «(exit code 1) Could not find IO::Glob in:␤    f…»

[16:03] <evalable6> tbrowder, Full output: https://gist.github.com/c2e8f5fb5eb40ccc16890a3738bd0df4

[16:04] <guifa> codesections: hmm that’s a really creative solution.  I wonder though if upper levels change if the default there will change as well (e.g. if they’re bound or not, and if not if they can be)

[16:05] <tbrowder> i still haven't heard why more published modules can't be made available. need volunteers? need resources? security?

[16:07] <codesections> tbrowder, I thought we established that they could be, as shown here: https://colabti.org/irclogger/irclogger_log/raku?date=2020-08-12#l189

[16:08] <AlexDaniel> tbrowder: for whateverable, it just needs code to make that process ↑ easier

[16:09] <tbrowder> ok, so i should fork and take a look. thanks, AlexDaniel

[16:09] <sena_kun> releasable6, status

[16:09] <releasable6> sena_kun, Next release in ≈9 days and ≈2 hours. 1 blocker. Changelog for this release was not started yet

[16:09] <releasable6> sena_kun, Details: https://gist.github.com/e357de4caf55a3fd2981aa7cc2cfa9f5

[16:09] <sena_kun> ouch, that's close

[16:09] <AlexDaniel> tbrowder: for example: detect use statements automatically, build the dependency tree, find the required modules in perl6-all-modules, create a PERL6LIB string

[16:10] <AlexDaniel> tbrowder: you can prototype this without forking, I'll help to bring your code into whateverable

[16:10] <AlexDaniel> there are easier approaches but they might not exactly work. For example, we can ask `zef` to install detected modules into a separate directory

[16:11] <AlexDaniel> that's very easy to implement

[16:11] <AlexDaniel> … but then it'd probably take minutes before it can actually run anything…

[16:11] *** gnufr33dom left
[16:11] <AlexDaniel> that said, we can perhaps cache some stuff to make further commands faster

[16:11] <AlexDaniel> actually, try it?

[16:12] <tbrowder> to me, though, looking at the path, someone running the server could have them loaded already. why that can't be done is a mystery to me.

[16:12] <AlexDaniel> tbrowder: no no

[16:12] <AlexDaniel> that'd mean having 1000+ modules in your PERL6LIB

[16:12] <AlexDaniel> I doubt that's going to work well

[16:14] <tbrowder> ok, that's what i don't understand is where this is all happening. where is home?

[16:14] *** Doc_Holliwood left
[16:14] <AlexDaniel> tbrowder: what exactly?

[16:16] <tbrowder> well, everytime i do a use i see evidence that the code is looking in all the usual places and can't find. so where is the file system it's looking at?

[16:16] <tbrowder> m: use IO::Glob

[16:16] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not find IO::Glob in:␤    inst#/home/camelia/.raku␤    inst#/home/camelia/rakudo-m-inst-2/share/perl6/site␤    inst#/home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    inst#/home/camelia/…»

[16:17] <AlexDaniel> e: use IO::Glob

[16:17] <evalable6> AlexDaniel, rakudo-moar 9d6d8dd7a: OUTPUT: «(exit code 1) 04===SORRY!04=== Er…»

[16:17] <evalable6> AlexDaniel, Full output: https://gist.github.com/d2e4f8218850cdb365cf15131805ba1b

[16:17] <tbrowder> see the paths? where are they?

[16:17] <AlexDaniel> tbrowder: on the server

[16:18] <AlexDaniel> I don't really understand the question :(

[16:19] <tbrowder> so what does PERL6LIB have to do with it? color me dumb, but i don't understand why the modules can't be installed there.

[16:19] <Geth> ¦ doc: f547ef406f | stoned++ (committed using GitHub Web editor) | 2 files

[16:19] <Geth> ¦ doc: More on { } and < > operators for Mix and MixHash (#3558)

[16:19] <Geth> ¦ doc: 

[16:19] <Geth> ¦ doc: - mention <> postcircumfix

[16:19] <Geth> ¦ doc: - add ref to operators' description

[16:19] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/f547ef406f

[16:19] <linkable6> DOC#3558 [closed]: https://github.com/Raku/doc/pull/3558 More on { } and < > operators for Mix and MixHash

[16:19] <AlexDaniel> tbrowder: as I said, because we can't really install 1612 modules there

[16:20] <tbrowder> in camelia's home dir unless it's ephemeral or something.

[16:20] *** Doc_Holliwood joined
[16:20] <AlexDaniel> you can try it on your own machine and then tell us if this affects anything in a negative way :)

[16:20] <AlexDaniel> preferably in a vm…

[16:21] <AlexDaniel> I doubt it's going to work well, but maybe somebody can share their experience and let me know if it should be ok

[16:22] <AlexDaniel> for example, will it affect startup time?

[16:22] <tbrowder> ok, i asked why couldn't we get or vote for a subset, anything

[16:22] <AlexDaniel> I have a hunch that it will

[16:23] <AlexDaniel> tbrowder: OK, I can give you very actionable steps: detect use statements in code, run `zef` to install detected modules into a specific directory (preferably in /tmp), construct a PERL6LIB string so that these modules are included, send me the code for all that and all whateverable bots will support modules

[16:23] <codesections> re: subset: isn't that basically how the current manual approach works?  Just the "subset" is "any modules people have bothered to install manually"

[16:23] <codesections> and by "people" I just mean "anyone who understands the (slightly involved, but not hard) process for doing it"

[16:24] <tbrowder> i'll stop bugging y'all about this--seems to be too hard to do, but it could be very useful.

[16:24] <AlexDaniel> you've got to be kidding me

[16:24] <AlexDaniel> “too hard to do” I gave you three freaking steps

[16:25] <AlexDaniel> which translate to… actually about three lines of code give or take

[16:25] <tbrowder> AlexDaniel i know, but you indicated that that was temporary and  would't last. i'm happy to load a bunch of modules here.

[16:25] <AlexDaniel> what do you mean wouldn't last

[16:26] <AlexDaniel> where have I said that

[16:26] <AlexDaniel> I said that the idea of loading hundreds of modules isn't going to fly, but installing the ones you can autodetect and including just them is perfect

[16:26] *** dolmen_ joined
[16:27] *** dolmen left
[16:27] <tbrowder> we obviously are talking around each other, sorry. i'll just do what you said when it's quiet.

[16:29] <AlexDaniel> not sure about the each other part. When it comes to whateverable, I tend to provide very clear actionable tasks. See my first reply in this discussion.

[16:32] <AlexDaniel> I can expand on any specific one if you want. For example, for the first part you don't need to have a very accurate parser, just a regex to find ‘use ……;’ in text is going to be OK. Perfect is the enemy of good in this case.

[16:33] <AlexDaniel> for zef to install into a specific location use `--to` parameter when running zef

[16:34] <AlexDaniel> btw /tmp is isolated for every bot, so it sounds like a good location to use for now

[16:34] <AlexDaniel> here's example usage: https://github.com/Raku/Blin/blob/9ad9b7d2a8d021f45df63f2eaa5a6f309af1d1cd/lib/Blin/Processing.pm6#L405

[16:35] <AlexDaniel> and for the last part just `run <perl6>` with a modified ENV

[16:36] *** molaf joined
[16:36] <AlexDaniel> after that's done, give me an hour or two and we'll be able to test it on the bots

[16:43] *** Xliff joined
[16:43] <Xliff> \o

[16:44] <codesections> o/

[16:44] <Xliff> Any thoughts on the best way to package up a Raku module distribution? Particularly if I want to convert that to something digestable to the major Linux distro package managers?

[16:45] <Xliff> deb, rpm, etc

[16:51] <timotimo> nine has implemented stuff for packaging raku modules on suse with rpm

[16:51] <timotimo> so i guess steal all of that :)

[16:55] <AlexDaniel> Xliff: yeah, see OBS and nine's efforts. Ideally it shouldn't even be something you'd do, that is we can just build all modules

[17:00] <tbrowder> AlexDaniel: thank you

[17:00] *** skids joined
[17:01] <codesections> AlexDaniel: when you say "not something you do" do you mean "you don't do it, distro maintainers do" or "no one needs to do it, users just install with zef or something similar?"

[17:01] <AlexDaniel> codesections: my hope is that OBS will be able to build all modules automatically

[17:02] <AlexDaniel> codesections: so as a module author you'd just go to obs and see your module already built for at least one distro, hopefully more

[17:02] <AlexDaniel> that is, it shouldn't be your worry

[17:02] <AlexDaniel> module author's worry I mean

[17:03] <AlexDaniel> nine: feel free to correct me if I'm wrong :)

[17:03] <codesections> But how do you go from there to "can be installed with apt/yum/pacman/etc"?  Unless I'm missing something, *someone* still has to do the packaging work (even if it's much easier at that point) and approve the package, right?

[17:04] <AlexDaniel> codesections: well, we can provide packages. Each distro has its own rules for what's included and how

[17:04] <codesections> Fair enough.  I'm with you now.  Thanks for clarifying :)

[17:05] <AlexDaniel> Xliff: my understanding is that the question is “how do I generate .deb .rpm etc. of my modules”, and that's something we should do with OBS for all modules

[17:05] <AlexDaniel> codesections: ↑ :)

[17:05] <El_Che> I think it's a terrible idea

[17:06] <AlexDaniel> El_Che: honest and direct, I like it :)

[17:06] <AlexDaniel> El_Che: why

[17:06] <El_Che> best to leave debs/rpms for modules packages and used by the OS itself

[17:06] <El_Che> for starters, it requires root to install

[17:07] <AlexDaniel> so? All system packages require root on most distros?

[17:08] <El_Che> packaged modules can not just be upgraded as they are used as dependencies

[17:08] <El_Che> those modules are global

[17:08] <El_Che> and one of the nice things of raku is local as default

[17:09] <El_Che> (in constrast with other dynamic languages where you get global as default)

[17:09] <AlexDaniel> I don't understand… you're against modules being packaged altogether?

[17:09] <El_Che> not at all

[17:09] <El_Che> I think modules should be packaged by distros

[17:10] <El_Che> and their upgrades within their rules

[17:10] <El_Che> also security

[17:10] <AlexDaniel> that's true, but if you need a module that's not in your distro?

[17:10] <Xliff> AlexDaniel: OK. So I need to read up on OBS. Is that the same thing timotimo was talking about?

[17:10] <El_Che> and for regular apps, I would like to see their deps in their repo

[17:11] <AlexDaniel> Xliff: yes

[17:11] <El_Che> as a vendor dir

[17:11] <El_Che> for for now, zef-able will do

[17:11] <Xliff> AlexDaniel++ timotimo++

[17:11] <El_Che> Xliff: OBS is very capable

[17:11] <El_Che> Xliff: too capable for me. I tried it and stopped somewhat with a 1994 feeling

[17:12] <El_Che> very non intuitive

[17:14] *** Altai-man joined
[17:16] <Xliff> El_Che: 1994 or 1984? Huge difference. :)

[17:17] *** sena_kun left
[17:17] <El_Che> hehe

[17:18] <El_Che> I don't think they are evil :)

[17:18] *** timlegge left
[17:20] *** Sgeo joined
[17:29] <Xliff> AlexDaniel: What about RakuDist?

[17:30] <AlexDaniel> Xliff: I don't know

[17:31] <Xliff> Where can I read up on Raku OBS?

[17:34] <AlexDaniel> Xliff: for RakuDist, get in contact with melezhik. For OBS, talk to nine

[17:56] *** bocaneri joined
[18:03] *** stoned75 left
[18:03] *** bocaneri left
[18:14] *** xinming joined
[18:16] *** xinming_ left
[18:17] <demostanis> How do I merge two hashes in Raku? Something like Object.assign() in JavaScript

[18:17] <demostanis> Nevermind, I've found

[18:18] <demostanis> https://stackoverflow.com/questions/60874124/merge-hash-raku

[18:21] *** dolmen_ left
[18:21] *** dolmen_ joined
[18:31] <AlexDaniel> demostanis: which of the answer did you choose? :)

[18:31] <AlexDaniel> answers*

[18:32] *** dolmen_ left
[18:35] *** Xliff left
[18:36] *** skids left
[18:39] *** vrurg left
[18:43] *** squashable6 left
[18:46] *** squashable6 joined
[18:50] *** xinming left
[18:50] *** Kaiepi joined
[18:52] *** Kaeipi left
[18:52] <codesections> I really like the %(|%h1, |%h2) approach.  It shows off a bit of how well-designed Raku is: because we have the Pair concept, a Hash is built on top of a List of pairs.  (I'm not saying it *really* is implemented that way, but it is semantically). 

[18:53] *** xinming joined
[18:53] <codesections> That means it makes perfect sense that %h.List gives you a List of Pairs.  And that %h.Slip (or `|%h`, which is the same thing) gives you a Slip of Pairs

[18:54] <codesections> and, *of course* concatinateing two Slips of Pairs gets you a List of Pairs.  

[18:54] <codesections> And, a List of Pairs is all you need to build a new Hash out of

[18:55] <codesections> And all that *just falls out* of Raku's basic semantics 

[18:56] <codesections> Compare to JavaScript, which had to add a bunch of hard-to-remember APIs to do the same thing (Object.entries(hash) is `|%h`, Object.assign(hash) is %(|%h, |$h), etc)

[18:58] *** wamba left
[18:59] <codesections> Also, minor note: the first `|` isn't required.  `%(%a, |%b)` works just as well (which, again, makes semantic sense)

[19:04] *** vrurg joined
[19:08] <tobs> I like the flustered face operator too:

[19:08] <AlexDaniel> codesections: but it's slower compared to `my %c = %a, %b`

[19:08] <tobs> m: my %foo = :42a, :50b; my %bar = :10b, :12d, :1c; say %foo »//« %bar

[19:08] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «{a => 42, b => 50, c => 1, d => 12}␤»

[19:09] <AlexDaniel> tobs: yeah I can kinda guess the performance of that

[19:09] * AlexDaniel measures

[19:09] <tobs> note that in this case %foo's keys win over %bar's

[19:09] <AlexDaniel> actually, it's pretty fast!

[19:09] <AlexDaniel> nice

[19:10] <AlexDaniel> as fast as |%a, |%b is

[19:12] <codesections> AlexDaniel: When I care enough about performance to sacrifice good/ergonomic semantics for perf, I write Rust (my other main language) :D

[19:12] <codesections> (Mostly joking)

[19:12] *** molaf left
[19:12] <codesections> By the way, what's a good way to micro-benchmark things like that? 

[19:13] <codesections> You measured »//« super quickly :)

[19:17] <codesections> tobs: I had to think through the semantics of »//« for a minute but, after giving it some thought, I like it too.  It also makes perfect semantic sense

[19:24] *** ensamvarg3 left
[19:30] *** sjm_uk left
[19:32] *** rindolf left
[19:34] *** seanrobert joined
[19:38] <AlexDaniel> codesections: it's not about microbenchmarking, most perf differences in rakudo are very significant and require no accurate tooling

[19:38] <AlexDaniel> which is why you can even bisect for perf regressions and stuff like that

[19:41] <AlexDaniel> m: my %a = (1..200000); my %b = (1..200000); say %(|%a, |%b).keys.elems; say now - INIT now

[19:41] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «100000␤2.4014804␤»

[19:41] <AlexDaniel> m: my %a = (1..200000); my %b = (1..200000); my %c = %a, %b; say %c.keys.elems; say now - INIT now

[19:41] <camelia> rakudo-moar 9d6d8dd7a: OUTPUT: «100000␤1.812962␤»

[19:41] <AlexDaniel> keep in mind though that a lot of that time is spent on constructing the hashes

[19:43] <codesections> I see, thanks. (I didn't know INIT worked in a REPL; interesting)

[19:44] <codesections> AlexDaniel: And you're not worried about misleading results from Rakudo optimizing out operations in a simple loop yet because that level of optimization work hasn't yet been done?

[19:49] <AlexDaniel> codesections: yeah, it rarely does anything that smart

[19:49] <AlexDaniel> codesections: camelia is not REPL, it's just executing a file

[19:50] <codesections> Fair enough.  I'm sure we'll get there.

[19:50] <AlexDaniel> codesections: also note that in this case I *am* using the result, it can't exactly just optimize it away

[19:51] <AlexDaniel> well, maybe something built on llvm can, I'm not sure

[19:51] <codesections> (INIT now works in the local REPL too.  Which also isn't quite as statefull as it could be, e.g., with not persisting syntax changes, so I guess I shouldn't be too surprised)  

[19:53] <codesections> Yeah, things built on LLVM definitely do – it's a real issue with Rust benchmarks.  But Rakudo has an optimizer, and I'm pretty sure it could do the same sort of tricks.  It's just a matter of investing the time in writing it (and making sure the code complexity doesn't get out of hand – it's easy for that sort of code to turn into special-case spaghetti  

[19:53] <codesections> )

[19:58] <AlexDaniel> everything is a matter of investing the time

[19:58] <codesections> Well, I plan to do so :)

[19:59] <AlexDaniel> question is, will it be wiser to just rebuild it on top of llvm, or spend time trying to optimize it for all architectures and stuff…

[20:00] <codesections> I guess that *is* a question.  Has anyone proposed rebuilding on LLVM?  That seems like… not a great fit for how dynamic Raku is

[20:01] <AlexDaniel> codesections: why? Seems to be no problem for Rust and Julia

[20:02] <AlexDaniel> ok maybe Rust is not the best example, but Julia is

[20:03] *** seanrobert left
[20:04] <codesections> AlexDaniel: Yeah, that's a fair point – I hadn't really thought about the Julia example.  They compile to LLVM but also run code via an interpreter.  I guess the idea you're floating would be to do something similar for Raku?  Have the LLVM output replace the precompiled bytecode, but still have non-modules run via the existing interpreter?

[20:05] *** xinming left
[20:06] <AlexDaniel> codesections: I don't know what's the easiest approach. Forking Julia is probably going to be faster

[20:06] *** xinming joined
[20:06] <AlexDaniel> codesections: note that it already has most of the cool features, multiple dispatch, rats, etc.

[20:06] <codesections> I could see that working, though it would be a big undertaking that wouldn't have any payoff until it's complete.  I'd prefer to be more incremental and follow a similar model to the Dyalog APL interpreter.  They've build up a list of commonly used idioms that get optimized by the compiler (they keep the same semantics, just run faster)

[20:07] <AlexDaniel> idioms is exactly the problem. You step outside and suddenly it's a lot slower

[20:07] <rypervenche> Question here: What is the logic of: say now - INIT now; ?

[20:07] <AlexDaniel> for example, a lot of Raku functionality is available through both methods and subs at the same time

[20:08] <AlexDaniel> it's not uncommon to have sub vs method to be twice or more times faster/slower

[20:08] <AlexDaniel> and depending on which sub we're talking about it's can be other way around

[20:08] <AlexDaniel> s/it's/it/

[20:09] <AlexDaniel> codesections: the immediate downside of forking Julia is that the startup time is actually worse. It's close, but it's worse.

[20:09] <AlexDaniel> rypervenche: INIT blocks run as soon as possible during execution

[20:10] <AlexDaniel> rypervenche: is INIT { now } is executed immediately and it's value is placed into the expression, pretty much

[20:10] <AlexDaniel> s/is/so

[20:10] <AlexDaniel> rypervenche: it looks cool because you can avoid the brackets in this case :)

[20:10] <codesections> Yeah, that's the sort of idiom work I'm talking about.  If two forms have exactly the same meaning but one is faster, there's no reason at all for the optimizer not to be able to replace the slower one with the faster one.  It's just a matter of building/maintaining that list

[20:11] <AlexDaniel> codesections: well, it's more complicated

[20:11] <rypervenche> AlexDaniel: Ahhh, that makes much more sense now. Thanks.

[20:11] <AlexDaniel> codesections: for example, when'd be that I'd be able to write some Raku code and have the compiler use SIMD instructions?

[20:12] <AlexDaniel> codesections: looking at the current development pace I'd say in 5 years or later. Probably later

[20:12] <AlexDaniel> codesections: for example, we don't even have JIT for arm or other archs

[20:13] <codesections> AlexDaniel: Ohhh, I was confusing INIT for $*INIT-INSTANT!  Which is why I was surprised it worked.  rypervenche, thanks for asking about that – you saved me from some confusion later

[20:13] <AlexDaniel> codesections: and then compare it to Julia which can do it right now…

[20:13] <AlexDaniel> it's not very nice from what I can see, but it's a lot better than nothing

[20:15] <codesections> Those are all fair points.  I'd still prefer the more incremental approach but (luckily for all concerned!) that's not my call to make :)

[20:16] *** MilkmanDan left
[20:16] *** MilkmanDan joined
[20:17] *** aluaces joined
[20:17] <demostanis> Due to a lot of testing for HubToDate, it looks like GitHub rate limited me... 

[20:17] <demostanis> ==> Fetching sharkdp/bat on github...

[20:17] <demostanis>  [!!!] Failed to fetch: (HANDLED) Error 403: 403 Forbidden

[20:17] <demostanis> y

[20:19] <demostanis> API rate limit exceeded for 134.19.189.190. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)

[20:23] <jdv79> why are you hitting github so hard?  i don't get it.

[20:24] *** demostanis left
[20:27] *** demostanis joined
[20:30] *** skids joined
[20:31] *** wamba joined
[20:31] <AlexDaniel> demostanis: yea I see that a lot

[20:31] <AlexDaniel> demostanis: if you authenticate then you can do more requests, yeah

[20:34] <AlexDaniel> jdv79: I think it's just 500 unauthenticated requests per hour or so

[20:35] <AlexDaniel> that's like 1 request per ≈7 seconds? Very small number

[20:36] <AlexDaniel> codesections: well, it's a taboo topic around here x)

[20:37] <jdv79> what endpoints have this rate limit?

[20:37] <jdv79> i guess i've never hit it that hard but with composer (php) we do hit github a lot for builds and stuff

[20:37] <AlexDaniel> jdv79: the whole api

[20:38] <AlexDaniel> or so I think

[20:38] <jdv79> but we're probably using auth since some of the repos are private so that makes a little more sense

[20:38] <AlexDaniel> it feels like they've been changing a lot of stuff, possibly related to their switch to GraphQL

[20:38] <AlexDaniel> so maybe my experience is no longer relevant

[20:39] <jdv79> ugh, GraphQL.  i think all the stuff i've ever hit is not that thank god

[20:40] <AlexDaniel> jdv79: on the upside, you'd be able to get everything in a single request when using their new GraphQL API

[20:42] <AlexDaniel> codesections: you'll often see people talking about a “100-Year Programming Language”, but nobody really puts an asterisk with a note saying that it's the amount of years it'll take to create that language x)

[20:42] <AlexDaniel> codesections: so my question really is how to avoid that

[20:44] <jdv79> i guess.  ignoring the fact that GraphQL is stupid and most of hte interactions i do with gh's endpoints aren't complicated.

[20:45] <AlexDaniel> jdv79: I haven't tried using it for my own APIs yet, but so far it makes sense. It's very hard to create a predictable API, so being able to ask for what you really need sounds great

[20:45] <jdv79> i think its reasonable to think it would take extraordinarily longer to procure a "100y lang";)

[20:45] <El_Che> AlexDaniel: it sounds like a huge change in the way of thinking of APIs

[20:45] <AlexDaniel> jdv79: for example, it's a common practice to return the request in your response, for whatever reason. Github does that consistently, including when you send a few megabytes of data in a gist

[20:45] <jdv79> i would have never guess 20-30 but in hindsight it makes sense i guess

[20:46] <AlexDaniel> jdv79: so that's why whateverables sometimes get in trouble when they try to decode the response…

[20:46] <jdv79> parroting the req has nothing to do with graphql vs anything else

[20:46] <codesections> AlexDaniel: Well, I haven't been involved *nearly* long enough to have a real say in the strategic issues at play in the pace of development.  But, personally, I plan roll up my sleeves and get to work :)  I really like how accessible the Raku/Rakudo src is, and already have some ways I think I can help (I'm starting with docs and tooling, but that's just the start) 

[20:47] <AlexDaniel> El_Che: yeah, but it's probably better than the typical “We have REST API! … Oh it's actually not exactly REST, it's a bit of RPC and… whatever, just be glad we have an API!”

[20:47] <AlexDaniel> :)

[20:48] <jdv79> graphql is more of an rpc itself

[20:48] <El_Che> AlexDaniel: yeah, API design is hard

[20:48] <El_Che> at least, for me :)

[20:48] <jdv79> anwyay, its a fad that's likely here to stay.  whatever.

[20:48] <AlexDaniel> it is

[20:48] *** vrurg left
[20:48] <moritz> API design is hard, and implementing the features behind the APIs can also be hard :D

[20:49] <codesections> jdv79: I *generally* dislike GraphQL – it seem over-built for most use cases.  However, GitHub does seem like the perfect fit for it – so many different people use their API for different things (including things they didn't imagine when writing it) that having a REST API that's decent for everyone is a tall order 

[20:49] <AlexDaniel> jdv79: I dunno, I'm actually more optimistic about it

[20:49] <AlexDaniel> maybe because of my previous experiences with APIs…

[20:50] <jdv79> having a decent rest-ish service offering isn't impossible but its not terribly common ime

[20:51] <AlexDaniel> “rest-ish” :)

[20:51] <jdv79> i guess graphql gives an easier way to paper over crappy backends under the guise of "optmized for mobile" or whatever you want to call it

[20:51] *** Black_Ribbon joined
[20:52] <jdv79> and if fb is doing it shoudln't we all;)

[20:52] <AlexDaniel> codesections: that sounds wonderful

[20:55] <AlexDaniel> codesections: yeah, well, the strategic issues… it's a bit of an echo chamber. I guess those who don't like what they see just leave, so don't expect any radical changes

[20:55] <AlexDaniel> codesections: it's a bit more complicated when you dive into the details

[20:55] <SmokeMachine> Talking about API, JSON:API is an option... and I don’t know if that’s interesting for any body else, but I’m playing into a Cro plugging for serving Red models using JSON:API. https://github.com/FCO/CroX-Red-JsonAPI/blob/master/test.raku#L32

[20:56] <jdv79> codesections: docs as in pod stuff or docs.raku.org?

[20:56] <AlexDaniel> codesections: let's try this example. Say you're remaking the compiler to make sure it's really really fast. How would you implement strings?

[20:57] <AlexDaniel> codesections: see, it's where the lines start to blur between the language design decisions and the compiler stuff

[20:57] <jdv79> restql seemed like a neat idea but i haven't looked into it as i haven't been in that biz for a whilte

[20:57] <jdv79> *whilte

[20:57] <jdv79> *while

[20:58] <codesections> AlexDaniel: How *do* we implement strings right now?  I've actually been curious about it, but I didn't see it documented anywhere and the Str src doesn't really lay it out (because Str comes from Bootstrap, and I wasn't *that* curious!) 

[21:00] <AlexDaniel> codesections: see, when you get your string it's probably just a bunch of bytes. Most languages do nothing or close to nothing with it, so they don't waste any time on touching any character

[21:01] <AlexDaniel> codesections: now, Raku wants to get unicode right, which is great. Except that it does that by going through the string and forming graphemes and stuff

[21:01] <jdv79> i feel a NFG coming up

[21:02] <AlexDaniel> codesections: Swift does that too, but differently. Counting the amount of characters there is O(n), same as indexing I believe

[21:02] <jdv79> is that a real issue?

[21:02] <codesections> jdv79: Both, actually.  My current (almost done!) project is to overhaul/significantly expand the `list-missing-methods` script that docs.raku.org uses to check for undocumented methods.  Once that's done, that should unlock a good bit of low-hanging fruit for docs.raku.org.  But I also have ideas/plans related to Pod.  In particular, I'd really like the docs to be usable from inside emacs, which

[21:02] <codesections> will take a bit of doing

[21:02] *** demostanis left
[21:02] <AlexDaniel> codesections: so people here say “oh hey look, we have O(1) indexing, isn't it great!” yeah it would've been great if the performance in general didn't suck that much :)

[21:03] <AlexDaniel> it's hard to beat another language in terms of performance when that other language does **nothing**. No operations

[21:03] <AlexDaniel> or at least that's my basic understanding of things, I could be wrong

[21:04] *** MasterDuke joined
[21:04] <jdv79> you could just not use a full out string, no?  a Buf or a ascii/latin-1 rep?

[21:04] <AlexDaniel> jdv79: yeah, but the context here is about making things fast by design

[21:04] <jdv79> kinda the same sort of deal with Rats

[21:05] <AlexDaniel> sure you can force the user to use some workaround

[21:05] <jnthn> All the extra work Raku does is why if you benchmark looping over the lines of a million line UTF-8 file, then Raku comes out a good bit faster than Perl 5 with :encoding(UTF-8). :P

[21:05] <jdv79> default is "correct" but you can do perf if you want...

[21:06] <codesections> AlexDaniel: Yeah, Rust does something similar to what you're talking about preferring.  A Rust String is (internally) an Array of bytes + a length + a capacity, but the only API exposed deals with Unicode chars.  So you can't index directly at all, and doing so through the API is O(n)

[21:06] <AlexDaniel> jdv79: well, in some sense Swift is correct also

[21:07] <AlexDaniel> jnthn: have a quick link to that benchmark?

[21:08] <codesections> It's all about perf tradeoffs.  Rust's approach works for them – it makes it really fast to create Strings and keeps mem usage down, but means accessing them may be slower.  A good tradeoff for their realtime use-cases (where good perf is important, but *predictable* perf is just as important)

[21:09] <codesections> But we aren't playing in that space – we already have a stop-the-world GC, for one thing.  So it *might* make sense for us to have Str that are slower to build and take more memory but that are faster to access 

[21:10] <jnthn> AlexDaniel: It's in my private benchmark suite, but here: https://gist.github.com/jnthn/cdeb4813801896b7afbba3e0d66bca50

[21:11] <AlexDaniel> jnthn: nice, thanks

[21:11] <AlexDaniel> codesections: well, most people will agree with you. But what others handwave as perf tradeoffs I call “slow by design” :S

[21:12] <codesections> (But I still don't know how Raku Strs work – I get that they're more than an Array of bytes in a way that makes working with unicode easier, but I don't know the details.  Are they an Array of pointers to Unicode grapheimes? Or what?

[21:12] <codesections> )

[21:13] <jnthn> codesections: They are an array, but when there's a sequence that NFC doesn't have a precomposed for, the char is represented as a negative integer and there's a lookup table for those. For many operations, though, such as substr, you don't ever need to resolve them.

[21:13] <jnthn> Those are interned also, so string comparisons can just do a memory comparison

[21:15] <jnthn> Stuff like case transitions or char class lookups have to chase them, as well as encoding to, say, utf-8 for output

[21:15] <codesections> jnthn: Thanks, that makes sense and seems like a reasonable design.  But how does that allow O(1) indexing, given that not all unicode chars have the same size?

[21:15] *** sena_kun joined
[21:15] *** mowcat joined
[21:15] <jnthn> codesections: 32-bit array (for stuff in latin-1 range without any need of synthetics an 8-bit array is used, though)

[21:16] <jnthn> So the classic time vs. memory trade-off

[21:16] <AlexDaniel> jnthn: that benchmark is faster with perl5

[21:16] <codesections> Ah, so it's basically like we're using utf32 + a lookup table?

[21:17] <jnthn> AlexDaniel: Not on my $dayjob box (Ubuntu 16.04 native) nor (by a smaller margin) the same thing virtualized on a Windows box.

[21:17] *** Altai-man left
[21:17] <AlexDaniel> jnthn: I get 0m1.285s for perl5 and 0m1.819s for perl6

[21:17] <jnthn> (I ran it this morning on the former, when checking the consequences of the hash changes)

[21:17] <codesections> Agreed re: time vs memory.  And also agreed that it makes sense for Raku to be on the "use more memory, take less time" side of that tradeoff most of the time

[21:18] <AlexDaniel> rakudo 2020.05.1-304-ge231558c4, perl v5.30.3

[21:18] <jnthn> No idea what perl version (not at either of those boxes right now)

[21:19] <jnthn> Though surely an Ubuntu from a few years ago doesn't have 5.30 :)

[21:19] *** kensanata left
[21:19] <AlexDaniel> fwiw it's very consistent and is in that ballpark, <1.3s vs ≈1.8s

[21:21] *** melezhik joined
[21:22] <melezhik> El_Che - "packaged modules can not just be upgraded as they are used as dependencies" second that , it's just one of the consequences of installing thins as native packages

[21:22] <tellable6> 2020-08-08T10:56:19Z #raku <demostanis> melezhik: I was just checking some existing projects written in Raku, but I don't plan on using Sparrowdo. Also security doesn't seem to be that important as it's supposed to be running locally.

[21:22] <tellable6> 2020-08-09T16:19:53Z #raku <demostanis> melezhik: What I meant is that the sparrowfile is executed locally, and isn't being fetched from an untrusted somewhere else? Am I right?

[21:23] <melezhik> in all linux distros native / aka system packages are "global" ones and implies a privileged user  to install

[21:23] <melezhik> the idea of distributing A language packages (raku/perl/ruby/python) is not new 

[21:24] <melezhik> there is also native package manager  install method VS language package manager competition

[21:24] <melezhik> both approaches have pros and cons 

[21:26] <melezhik> _usually_  it's linux distribution maintainers responsibility to maintain native packages alternatives for a language pakages   

[21:27] <melezhik> they do it based on their consideration of security, stability, whatever coming from OS/distribution point of view rather then A language perspective 

[21:28] <rypervenche> Hmmm, I'm getting 0.865s for perl v5.30.3 and 1.068s for Raku 2020.07 for those benchmarks.

[21:28] <melezhik> and that is fine, because when/if a developers or whoever needs to play/install the latest/unstable version of a module they use a language package manager (zef for Raku)  giving them all the flexibility 

[21:28] <melezhik> including local installations 

[21:29] <melezhik> cc AlexDaniel El_Che Xliff:

[21:31] <codesections> rypervenche: and, to throw one more set of numbers in the mix, I'm getting 711.4 ± 8.2 ms for Perl v5.30.0 vs 870.0 ± 12.1 ms for Raku 2020.07

[21:31] <melezhik> .tell Xliff:  RaluDist is not for packaging Raku modules but for testing them against various Rakudo versions and Linuxes

[21:31] <tellable6> melezhik, I'll pass your message to Xliff

[21:31] <melezhik> it uses zef to install modules dependecies

[21:32] *** Henry151 joined
[21:32] <melezhik> however RakuDist uses Sparrow scenarios (I call it pacthes ) to manage none Raku  dependencies if a module requires ones 

[21:33] <melezhik> one can find examples here - https://github.com/melezhik/RakuDist/tree/master/modules/default/files/patches

[21:34] <melezhik> the process is explained here - https://sparrowdo.wordpress.com/2020/06/22/install-raku-modules-and-external-dependencies-using-sparrow/

[21:35] <AlexDaniel> jnthn: also beating perl5 is not even a high bar. I present to you the same benchmark in julia: https://gist.github.com/AlexDaniel/be99d9f930b7307fbca70127d53271a7

[21:35] <AlexDaniel> jnthn: gives the same result in 0m0.703s

[21:35] <AlexDaniel> jnthn: which is probably 2x as fast compared to perl5 (julia has slow startup time, similar to rakudo)

[21:36] <AlexDaniel> my understanding is that everything is UTF8, so encoding not specified

[21:38] <codesections> AlexDaniel: Why is Julia a better comparison than perl 5?  You could get even bigger perf numbers from C/C++/Rust – but we're not playing in that space (that's what NativeCall is for :D).  Which isn't to say that we don't need to focus on perf/have areas for improvement.  I'm sure we do.  But I'd be happy with speed without it winning any abosolute benchmarks

[21:39] <melezhik> .tell Xliff: sorry the last link described another method of managing none Raku dependencies through META6 "interface" ))) though it could be of interest too   

[21:39] <tellable6> melezhik, I'll pass your message to Xliff

[21:40] <AlexDaniel> codesections: well, Julia feels a lot like Raku. It's completely different, but also very similar

[21:41] <AlexDaniel> codesections: also I'm not sure why you don't want to play in that space. It's very trendy

[21:41] <AlexDaniel> codesections: machine learning and stuff, processing a lot of data where performance actually matters

[21:43] <AlexDaniel> jnthn: also, that benchmark looks a bit… incomplete to me. Sure, we optimzed ascii strings. Great. Wonderful.

[21:43] <AlexDaniel> jnthn: now do `$fh.say("Juλ" x 60);`

[21:44] <codesections> Because I *already* play in that space when I write Rust :)  To give a less flippant answer, that level of perf requires some *real* tradeoffs, many of which I'd hate to see Raku make.  Trying to fit *all* use cases is a good way for a language to be mediocre at them all, and I'm happy to see Raku focus on some use cases over others 

[21:44] <jnthn> AlexDaniel: You're nicely illustrating why I have private benchmark suite. :)

[21:44] <AlexDaniel> 0m0.846s vs 0m1.656s vs 0m7.714s, you can guess which one is which

[21:45] <AlexDaniel> jnthn: then don't bring it up as an argument for raku tradeoffs

[21:45] <codesections> Which - again - doesn't mean avoiding work to improve performance.  I bet there are ways we can make speed gains *without* losing anything.  But I'm also sure that those gains won't make us the fastest language in the world.  Which is fine with me :)

[21:47] <jnthn> AlexDaniel: Don't worry, I won't bother engaging with you on anything else in the future. I only wish I hadn't each time I do. :/

[21:47] <jnthn> afk

[21:47] <AlexDaniel> jnthn: it doesn't matter, no argument will pull you out of the bubble :P

[21:48] *** MasterDuke left
[21:48] <AlexDaniel> codesections: yeah, well, we can try Swift's way maybe

[21:49] <AlexDaniel> codesections: but again that will completely change the language

[21:50] <AlexDaniel> well… “completely”, actually most people might not even notice

[21:50] <codesections> And, again, I'm more a fan of incremental changes.  And again, we're both lucky that I don't make those decisions :)

[22:03] <AlexDaniel> codesections: we're not, no. Raku needs fresh minds like you who don't operate on presuppositions and sunk cost reasoning

[22:04] <AlexDaniel> codesections: it's not about being right or wrong, it's about looking back, admitting mistakes and planning on how to move forward

[22:05] * lizmat suggests AlexDaniel opens up a problem solving issue with a list of mistakes that need admitting to

[22:06] *** molaf joined
[22:08] <AlexDaniel> lizmat: and then what? Get a few pages of text about things that I already explained, just beacuse it's fun to debate people? And then get shit for refusing to engage in this improvised debate club?

[22:10] <lizmat> you seem to enjoy debating?

[22:10] <AlexDaniel> I enjoy identifying issues and finding a way to solve them

[22:11] <AlexDaniel> the fact that I typically get “NO! Not an issue!!” in response is a different story…

[22:12] <El_Che> AlexDaniel, lizmat, jnthn: I hope we can keep discussing without the edgy tone?

[22:12] <lizmat> so the joy is in "finding a way", not to reach a solution, then?

[22:12] <codesections> El_Che++

[22:13] <lizmat> El_Che: yeah, you're right.  I should not engage AlexDaniel

[22:13] <lizmat> afk&

[22:13] <nicholatian> ANSI C, anyone? :P

[22:13] <El_Che> maybe letś cool off and do engage later?

[22:14] <El_Che> ignoring is the passive-aggressive variant of edgy discussions

[22:14] <AlexDaniel> El_Che: well, I actually think we had a reasonably useful discussion, until jnthn decided to leave a passive aggressive comment that he thought invalidated my point.

[22:14] <AlexDaniel> which is fine, I don't mind that

[22:14] <El_Che> yes, that's why I metioned him as well. 

[22:15] <El_Che> let go for cooling off and reset, for everyone

[22:17] <melezhik> El_Che++ 

[22:24] *** vike left
[22:30] *** vike joined
[22:31] <jdv79> aw, i was about to get some popcorn

[22:34] *** mowcat left
[22:44] <AlexDaniel> codesections: btw stop-the-world GC doesn't necessarily mean slow performance, just stutters. Surely affects games, and unfortunately some realtime-ish processes, so I can relate to that issue. But I don't think it's a big deal by itself unless you're creating objects unnecessarily

[22:46] <codesections> I never said stop-the-world GC meant slow.  I said it meant "unpredictable", which is why it's OK to have Str creation take longer (which can cause bumpy performance) in return for speedups in using Strs.

[22:48] <AlexDaniel> not really, just because something causes stutters doesn't mean you should be making decisions that result in less than awesome performance everywhere else

[22:49] <AlexDaniel> “in return for speedups” assumes that we win performance in the end, but I don't think that's the case

[22:50] <AlexDaniel> the switch from O(n) to O(1) is not by itself a speedup, it just defines how you should and shouldn't work with Strs as a user

[22:50] <AlexDaniel> or rather how you can

[22:56] *** melezhik left
[22:57] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2020/08/14/guarding-dynamics/

[22:59] <AlexDaniel> codesections: but anyway, that's just one example, you can pick anything else. For example, you bring up GC, well, you can avoid GC runs if you want to write realtime(ish) code. But for that you need to be able to comfortably work with preallocated data without creating a bunch of new objects. Something that I think is impossible with rakudo right now, but it's hard for me to tell because I never got to the point where stutters mattered

[22:59] <AlexDaniel> (it was always the performance itself in the first place).

[23:01] <AlexDaniel> codesections: maybe it doesn't make much sense, but you can play with Julia for a slap back to reality of your own :)

[23:05] <AlexDaniel> gfldex: have you seen https://github.com/Raku/doc/issues/3497 ? :)

[23:06] <gfldex> how i do

[23:06] <gfldex> *now

[23:06] <AlexDaniel> gfldex: in whateverable I did something like this: https://github.com/Raku/whateverable/commit/152bd39da650cc655d610e2b77c7c3a4768a0022#diff-dca4b2bf358590c20288b14a7ec8d7c5R28

[23:07] <AlexDaniel> gfldex: basically switched to process variables instead. They're still accessible with $*foo I think so they can be used like dynamic vars

[23:07] *** robm joined
[23:08] <codesections> AlexDaniel: well, I don't know your use case, but it's starting to seem like a language like Julia might be a better fit for what you want out of a language.  As for me, I'm very happy with the tradeoffs Raku has made.  I'm still going to write Rust when I need speed, but I'm happy to have the power Raku provides at other times (and, again, will work to improve speed to the extent it can be done

[23:08] <codesections> without losing power/ergonomics) 

[23:08] <gfldex> AlexDaniel: dynvars exist on the stack, so it is not surprising they don't mix well with threads

[23:09] <AlexDaniel> codesections: yeah, Two-Language Programming Problem :)

[23:09] *** cpan-raku left
[23:10] *** cpan-raku joined
[23:11] *** cpan-raku left
[23:11] *** cpan-raku joined
[23:11] <AlexDaniel> gfldex: yes, you're right. I was still surprised though :)

[23:32] *** seanrobert joined
[23:34] <gfldex> raku: sub check-dynvar(Mu \dynvar) is raw { dynvar ~~ Mu or die("{dynvar.VAR.name} wrong type!"); dynvar }; my $*d = Mu.new; dd check-dynvar($*d);

[23:34] <evalable6> gfldex, rakudo-moar 9d6d8dd7a: OUTPUT: «Mu $*d = Mu.new␤»

[23:34] <gfldex> Today I learded that subs can be is raw.

[23:35] *** wamba left
[23:39] *** seanrobert left
[23:47] *** MilkmanDan left
[23:47] *** MilkmanDan joined
