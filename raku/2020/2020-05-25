[00:06] *** guifa2 joined
[00:07] *** ohmycloud joined
[00:10] *** guifa2 left
[00:11] *** ohmycloud left
[00:13] *** guifa2 joined
[00:18] <uzl[m]> .seen jjmerelo 

[00:18] <tellable6> uzl[m], I saw jjmerelo 2020-05-22T12:13:54Z in #raku-dev: <JJMerelo> This is maybe a bit more recent https://www.reddit.com/r/rakulang/comments/f95r2o/how_to_create_a_binary_executable_in_raku/

[00:21] *** guifa2 left
[00:34] *** vike1 left
[00:43] *** aborazmeh joined
[00:43] *** aborazmeh left
[00:43] *** aborazmeh joined
[00:51] *** vike1 joined
[00:55] *** guifa2 joined
[00:55] *** stoned75 left
[00:56] *** marcusr left
[00:57] *** marcusr joined
[00:59] *** guifa2 left
[01:06] *** marcusr left
[01:07] *** marcusr joined
[01:10] *** KindOne left
[01:22] *** ensamvarg3 joined
[01:23] *** gdonald left
[01:29] *** KindOne joined
[01:29] *** molaf left
[01:41] *** molaf joined
[02:04] *** klapperl_ joined
[02:05] *** klapperl left
[03:12] *** cpan-raku left
[03:13] *** cpan-raku joined
[03:13] *** cpan-raku left
[03:13] *** cpan-raku joined
[03:16] *** Dock_Holliwood joined
[03:17] *** KindTwo joined
[03:18] *** KindOne left
[03:21] *** guifa2 joined
[03:21] *** KindTwo is now known as KindOne

[03:25] *** guifa2 left
[03:25] *** mowcat left
[03:32] *** _jrjsmrtn joined
[03:32] *** __jrjsmrtn__ left
[03:39] *** baboo joined
[03:41] *** baboo left
[04:07] *** brtastic joined
[04:18] *** saxon joined
[04:19] <saxon> hey guys, i have tried rakudo-pkg on fedora system of mine but it does not come with a documentation like perl.

[04:20] <saxon> is there a way to get the documentation like perldoc?

[04:22] <ShimmerFairy> I don't know of an offline method offhand, but there's docs.raku.org at least

[04:25] <saxon> tbh beautiful documentation in perldoc accessible at terminal is one of the best things about perl. little low on the bandwidth and ram here.

[04:26] <saxon> can i get docs without opening browser?

[04:28] <tobs> I think `zef install p6doc` should get you offline documentation

[04:30] <tobs> which is accessed in the familiar fashion, e.g. p6doc Str.chomp

[04:35] *** xinming_ left
[04:37] *** xinming_ joined
[04:37] <saxon>  tobs: looks cool. thanks!

[04:37] *** saxon left
[04:45] *** suman joined
[04:47] *** wamba joined
[04:48] <suman> https://pastebin.com/NGa4MrW3

[04:48] <suman> Any help here?

[04:53] *** ensamvarg3 left
[04:53] *** ensamvarg3 joined
[04:54] <suman> m: 'my %hash;

[04:54] <camelia> rakudo-moar 800878a1b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in single quotes; couldn't find final "'" (corresponding starter was at line 1)␤at <tmp>:1␤------> 3'my %hash;7⏏5<EOL>␤    expecting any of:␤        single quote…»

[04:54] <suman> sub count_each_chars($val) {

[04:57] <tobs> suman: '22/7'.chars is different from 22/7.chars

[04:57] <tobs> the former is the literal string of 4 characters, the latter is a Rat object (rational number) which chooses to stringify to "3.142857" which has 8 characters

[04:58] <suman> m: 22/7.chars

[04:58] <camelia> rakudo-moar 800878a1b: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "/" in expression "22/7.chars" in sink context (line 1)␤»

[04:59] <tobs> you have to `say` it

[04:59] <tobs> m: say 22/7.chars

[04:59] <camelia> rakudo-moar 800878a1b: OUTPUT: «22␤»

[04:59] <suman> m: say 22/7.chars

[04:59] <camelia> rakudo-moar 800878a1b: OUTPUT: «22␤»

[04:59] <tobs> m: say (22/7).chars  # ok, parenthesize then

[04:59] <camelia> rakudo-moar 800878a1b: OUTPUT: «8␤»

[04:59] <suman> @tob gotch it

[05:00] <suman> thank you

[05:00] <tobs> no problem

[05:01] <suman> https://pastebin.com/BDQ8Tdgf

[05:05] <tobs> %hash<$val> does not interpolate the value of $val. You are incrementing the value at literally '$val' each time (as your output shows). Try %hash{$val} instead.

[05:07] <suman> @tobs Yeah it works after that. But I thought %hash<$val> were same as %hash{$val}. Where can I read more on it?

[05:08] *** aborazmeh left
[05:11] <tobs> the best I found is a little blurb here https://docs.raku.org/language/operators#postcircumfix_%3C_%3E

[05:15] *** brtastic left
[05:17] *** xinming_ left
[05:17] *** xinming_ joined
[05:18] <tobs> it's a number of hours past bed time here, I can't be of more help :)

[05:32] <ShimmerFairy> m: my %h; my $val = "foo"; %h«$val» = 42; say %h

[05:32] <camelia> rakudo-moar 800878a1b: OUTPUT: «{foo => 42}␤»

[05:33] <ShimmerFairy> just to make life more fun :P

[05:42] *** stoned75 joined
[06:19] *** brtastic joined
[06:25] *** klapperl_ left
[06:28] *** cpan-raku left
[06:28] *** cpan-raku joined
[06:28] *** cpan-raku left
[06:28] *** cpan-raku joined
[06:49] *** suman left
[06:49] <Geth> ¦ doc: 4c49cea5a4 | (Luis F. Uceta)++ | doc/Language/typesystem.pod6

[06:49] <Geth> ¦ doc: Index :api and add bit of documentation

[06:49] <Geth> ¦ doc: 

[06:49] <Geth> ¦ doc: refs: https://github.com/Raku/doc/issues/3308

[06:49] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/4c49cea5a4

[06:49] <Geth> ¦ doc: d2e7fee86f | (Luis F. Uceta)++ | doc/Language/typesystem.pod6

[06:49] <Geth> ¦ doc: Make changes as requested

[06:49] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/d2e7fee86f

[06:49] <linkable6> Link: https://docs.raku.org/language/typesystem

[06:49] <Geth> ¦ doc: 6cfab4455c | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | doc/Language/typesystem.pod6

[06:49] <Geth> ¦ doc: Merge pull request #3316 from uzluisf/master

[06:50] <Geth> ¦ doc: 

[06:50] <Geth> ¦ doc: Index :api and add bit of documentation

[06:50] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/6cfab4455c

[06:52] *** JJMerelo joined
[06:57] *** domidumont joined
[07:16] *** stoned75 left
[07:18] *** stoned75 joined
[07:22] *** JJMerelo left
[07:26] *** abraxxa left
[07:30] *** abraxxa joined
[07:34] *** Sgeo left
[07:34] *** abraxxa left
[07:35] *** abraxxa joined
[07:41] *** Dock_Holliwood left
[07:43] *** rindolf joined
[07:48] *** leont joined
[07:53] *** Kaiepi left
[07:57] *** Kaiepi joined
[08:09] *** JJMerelo joined
[08:16] <Geth> ¦ ecosystem/JJ-patch-10: 6c1d069627 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | META.list

[08:16] <Geth> ¦ ecosystem/JJ-patch-10: Add Test::Script

[08:16] <Geth> ¦ ecosystem/JJ-patch-10: 

[08:16] <Geth> ¦ ecosystem/JJ-patch-10: Another testing module

[08:16] <Geth> ¦ ecosystem/JJ-patch-10: review: https://github.com/Raku/ecosystem/commit/6c1d069627

[08:17] <Geth> ¦ ecosystem: JJ++ created pull request #496: Add Test::Script

[08:17] <Geth> ¦ ecosystem: review: https://github.com/Raku/ecosystem/pull/496

[08:17] *** Altai-man_ joined
[08:24] <Geth> ¦ ecosystem/JJ-patch-10: cf7eb17af6 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | META.list

[08:24] <Geth> ¦ ecosystem/JJ-patch-10: Force re-check

[08:24] <Geth> ¦ ecosystem/JJ-patch-10: review: https://github.com/Raku/ecosystem/commit/cf7eb17af6

[08:25] <Geth> ¦ ecosystem/JJ-patch-10: ebacdf8456 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | META.list

[08:25] <Geth> ¦ ecosystem/JJ-patch-10: Force re-chec,

[08:25] <Geth> ¦ ecosystem/JJ-patch-10: review: https://github.com/Raku/ecosystem/commit/ebacdf8456

[08:27] *** sena_kun joined
[08:29] *** Altai-man_ left
[08:30] <Geth> ¦ ecosystem/JJ-patch-10: 75970bee86 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | META.list

[08:30] <Geth> ¦ ecosystem/JJ-patch-10: Eliminates space.

[08:30] <Geth> ¦ ecosystem/JJ-patch-10: review: https://github.com/Raku/ecosystem/commit/75970bee86

[08:31] <JJMerelo> ^^^ sorry about that...

[08:31] <Geth> ¦ ecosystem/master: 5 commits pushed by (Juan Julián Merelo Guervós)++

[08:31] <Geth> ¦ ecosystem/master: 6c1d069627 | Add Test::Script

[08:31] <Geth> ¦ ecosystem/master: cf7eb17af6 | Force re-check

[08:31] <Geth> ¦ ecosystem/master: ebacdf8456 | Force re-chec,

[08:31] <Geth> ¦ ecosystem/master: 75970bee86 | Eliminates space.

[08:31] <Geth> ¦ ecosystem/master: e21b1490ad | Merge pull request #496 from Raku/JJ-patch-10

[08:31] <Geth> ¦ ecosystem/master: review: https://github.com/Raku/ecosystem/compare/a7e9ef62b8c9...e21b1490adb1

[08:34] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2020/05/25/returning-the-right-amount/

[08:42] *** klapperl joined
[09:05] *** wamba left
[09:12] *** sparcio left
[09:13] *** JJMerelo left
[09:19] *** pecastro joined
[09:25] <Geth> ¦ problem-solving: lizmat assigned to jnthn Issue The Problem Solving Process is not working https://github.com/Raku/problem-solving/issues/200

[09:26] *** abraxxa left
[09:26] *** abraxxa joined
[09:28] *** Grauwolf left
[09:28] *** Grauwolf joined
[09:29] *** JJMerelo joined
[09:45] *** schlaftier joined
[10:16] *** Kaeipi joined
[10:16] *** Kaiepi left
[10:17] *** andrzejku joined
[10:22] *** veesh left
[10:23] *** veesh joined
[10:26] *** Altai-man_ joined
[10:29] *** sena_kun left
[10:31] *** wamba joined
[10:48] *** chloekek joined
[10:55] *** sjm_uk joined
[11:07] *** andrzejku left
[11:08] *** andrzejku joined
[11:19] *** Dwarf left
[11:19] *** konvertex joined
[11:27] *** chloekek left
[11:28] *** Manifest0 left
[11:30] *** Manifest0 joined
[11:47] *** kensanata joined
[11:47] <Geth> ¦ doc: Prince213++ created pull request #3426: Fix typo & removed extra blank lines

[11:47] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3426

[11:52] *** Geth left
[11:52] *** Geth joined
[11:53] <Geth> ¦ doc: 7631cf90e6 | (Sizhe Zhao)++ | README.md

[11:53] <Geth> ¦ doc: Fix typo & removed extra blank lines

[11:53] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/7631cf90e6

[11:53] <Geth> ¦ doc: d49c3ec7c2 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | README.md

[11:53] <Geth> ¦ doc: Merge pull request #3426 from Prince213/readme-improvements

[11:53] <Geth> ¦ doc: 

[11:53] <Geth> ¦ doc: Fix typo & removed extra blank lines

[11:53] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/d49c3ec7c2

[11:55] *** janus_ joined
[11:56] *** janus_ left
[11:57] *** andrzejku left
[11:59] *** andrzejku joined
[12:07] *** BuildTheRobots left
[12:11] *** BuildTheRobots joined
[12:16] *** Xliff joined
[12:16] <Xliff> \o

[12:27] *** sena_kun joined
[12:29] *** Altai-man_ left
[12:41] <Geth> ¦ doc: Prince213++ created pull request #3427: Update Chinese translation

[12:41] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3427

[12:43] <Geth> ¦ doc: 622f08ad54 | (Sizhe Zhao)++ | resources/i18n/zh/README.zh.md

[12:43] <Geth> ¦ doc: Update Chinese translation

[12:43] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/622f08ad54

[12:43] <Geth> ¦ doc: b7884987e1 | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | resources/i18n/zh/README.zh.md

[12:43] <Geth> ¦ doc: Merge pull request #3427 from Prince213/zh-cn-translation-update

[12:43] <Geth> ¦ doc: 

[12:43] <Geth> ¦ doc: Update Chinese translation

[12:43] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/b7884987e1

[12:49] *** JJMerelo left
[12:51] <lizmat> PSA: There will not be a Rakudo Weekly News this week.  Yours truly needs a break.  Please check in again next week!

[12:54] <El_Che> lizmat: if you feel burn out closing in, take whatever tieme you need!

[12:57] <SmokeMachine> m: role Bla[::T] { has T $.a is required; method b(--> T) { $!a } }; Bla[Int].new(:42a).b

[12:57] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Died with X::TypeCheck::Return␤  in method b at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[12:58] <SmokeMachine> why can't I use T as return type?

[12:58] <jnthn> Because instantiating type varialbes there is NYI

[12:59] <SmokeMachine> by type variable you mean ::T?

[12:59] <jnthn> The T after -->

[13:00] <SmokeMachine> why is that being instantiated? (sorry, I'm curious)

[13:02] <SmokeMachine> is that the same reason of why I can't do something like `--> (::?CLASS, T)`?

[13:03] <SmokeMachine> or that should not work at all?

[13:04] <jnthn> It should work. "instantaition" in this context means resolving the T into the correct type, e.g. by compiling it to do a lexical lookup of T rather than hard-coding the type

[13:04] *** wamba left
[13:04] <jnthn> Which I guess is how it's compiling now

[13:06] <SmokeMachine> so, some day this will just work? https://usercontent.irccloud-cdn.com/file/8nIZEtcG/image.png

[13:07] <jnthn> The --> T at least

[13:08] <jnthn> The tuple one was discussed on a problem-solving issue and I kinda agreed with it too

[13:08] <lizmat> SmokeMachine: why the ::?CLASS:U: case for WHICH, looks to me that is Mu::WHICH ?

[13:08] <lizmat> afk&

[13:08] <SmokeMachine> lizmat: good question

[13:10] <SmokeMachine> I just saw I've even 👍ed

[13:12] <SmokeMachine> (sorry, `I had`)

[13:14] <SmokeMachine> I was trying to find a easier way of using it then `($stack, my $ret) = $stack.pop`...

[13:15] <SmokeMachine> I was thinking on something like this... does this make any sense? https://www.irccloud.com/pastebin/7gqvxCRV/

[13:15] *** wamba1 joined
[13:17] <SmokeMachine> but my first idea was to try to modify the `.=` op to make `my $val = $stack.=pop` get the first value and set $stack with it and return the rest...

[13:19] <SmokeMachine> is it possible to create an operator that would behave like that? (not necessarily the `.=`)

[13:19] <SmokeMachine> but I think `.=` would be perfect for that

[13:20] <vrurg> SmokeMachine: should work if you define the lhs as 'is rw'

[13:20] <SmokeMachine> vrurg: lhs?

[13:21] <vrurg> SmokeMachine: left hand side

[13:22] <SmokeMachine> the $stack?

[13:23] <vrurg> SmokeMachine: yes.

[13:24] <vrurg> m: multi infix:«<-»($a is raw, @b) { $a = @b.head; @b[1..*] }; my $s; say $s <- (1,2,3); say $s; 

[13:24] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «(2 3)␤1␤»

[13:24] <vrurg> m: multi infix:«<-»($a is rw, @b) { $a = @b.head; @b[1..*] }; my $s; say $s <- (1,2,3); say $s; 

[13:24] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «(2 3)␤1␤»

[13:25] <vrurg> is rw is better because it would check if lhs is a Scalar.

[13:26] <SmokeMachine> but how to do that calling the method?

[13:26] <vrurg> m: multi infix:«<-»($a is rw, @b) { $a = @b.head; @b[1..*] }; my $s; say 12 <- (1,2,3); say $s; 

[13:26] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Cannot resolve caller infix:«<-»(Int:D, List:D); the following candidates␤match the type but require mutable arguments:␤    ($a is rw, @b)␤  in block <unit> at <tmp> line 1␤␤»

[13:27] <vrurg> m: multi infix:«<-»($a is raw, @b) { $a = @b.pop; @b }; my $s; say $s <- [1,2,3]; say $s; 

[13:27] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[1 2]␤3␤»

[13:27] <vrurg> SmokeMachine: ^^

[13:29] *** chloekek joined
[13:31] *** cognomin_ joined
[13:34] *** cognominal left
[13:39] <SmokeMachine> I mean the op receive the name of the method...

[13:40] *** Dock_Holliwood joined
[13:43] <SmokeMachine> I mean, if you do `$stask.pop` you'll receive the new stack and the poped value, but if you do `$stack.=pop` you only receive the poped value and $stack is changed to the new stack

[13:43] <vrurg> SmokeMachine: I'm afraid you'd either have to expect a string on rhs or wait for RakuAST.

[13:43] *** Merfont joined
[13:43] <SmokeMachine> I was thinking on a Slang

[13:46] *** Kaeipi left
[13:48] <vrurg> SmokeMachine: feels like you're gonna waste time on it. What's the use case?

[13:48] <SmokeMachine> study...

[13:49] <SmokeMachine> vrurg: I'm studying functional data structures, and wonder is would be a easier way of using it

[13:51] <vrurg> SmokeMachine: a method name in a string would spare you a lot of time, to my view.

[13:51] <vrurg> Unless you'd like to study Raku grammar/action from inside out too.

[13:54] *** aborazmeh joined
[13:54] *** aborazmeh left
[13:54] *** aborazmeh joined
[13:55] <SmokeMachine> vrurg: that's one of my intents

[13:56] <vrurg> Ok then. :)

[13:57] <vrurg> Have fun then. Grammar/Action/World trio is a tricky place.

[13:59] *** guifa2 joined
[14:02] *** hyperak left
[14:09] <cpan-raku> New module released to CPAN! Log (0.1.1) by 03TYIL

[14:10] *** fluca1978 joined
[14:11] <fluca1978> hi, I'm a little lost, what if I want to initialize a list with all True values like my @chessboard =  True xx $dimension, True xx $dimension, True xx $dimension; and then have it mutable?

[14:11] <tellable6> 2020-02-08T12:13:54Z #moarvm <rba> fluca1978: pl6anet.org feeds are configured in https://github.com/perl6/pl6anet.org/blob/master/perlanetrc , so commit or PR

[14:12] <jnthn> fluca1978: Try something like my @chessboard = [True xx $dimension] xx $dimension

[14:12] <timotimo> m: my @board = [True xx 4] xx 4; say @board; @board <<=>> (Bool.pick xx *); say @board

[14:12] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing << or >>␤at <tmp>:1␤------> 3True xx 4] xx 4; say @board; @board <<=>7⏏5> (Bool.pick xx *); say @board␤    expecting any of:␤        infix␤        infix stopper␤»

[14:12] <timotimo> m: my @board = [True xx 4] xx 4; say @board; @board <<[=]>> (Bool.pick xx *); say @board

[14:12] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[True True True True] [True True True True] [True True True True] [True True True True]]␤List on right side of hyperop of infix:<=> is known to be infinite␤  in block <unit> at <tmp> line 1␤␤»

[14:12] <timotimo> m: my @board = [True xx 4] xx 4; say @board; @board <<[=]<< (Bool.pick xx *); say @board

[14:12] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[True True True True] [True True True True] [True True True True] [True True True True]]␤List on right side of hyperop of infix:<=> is known to be infinite␤  in block <unit> at <tmp> line 1␤␤»

[14:12] <timotimo> m)

[14:15] <fluca1978> uhm... my @chessboard = [ True xx $dimension ] xx $dimension; still give me Cannot modify an immutable Bool (True) when trying to modify a single element

[14:17] <jnthn> m: my $dimension = 4; my @chessboard = [ True xx $dimension ] xx $dimension; @chessboard[1][1] = False; say @chessboard;

[14:17] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[True True True True] [True False True True] [True True True True] [True True True True]]␤»

[14:20] <fluca1978>     my @chessboard = [ True xx $dimension ] xx $dimension;

[14:20] <fluca1978>     @chessboard[ 0 ][ 0 ][ 0 ] = "Q"; 

[14:20] <fluca1978> with $dimension = 3

[14:21] <fluca1978> not working, maybe "This is Rakudo version 2020.01 built on MoarVM version 2020.01.1" ?

[14:21] <jnthn> Oh, that meaning of dimension...

[14:21] <timotimo> ohhh

[14:22] <Xliff> m: my $dimension = 3; my @chessboard = [ True xx $dimension ] xx $dimension; @chessboard[0][0] = 'Q'; @chessboard.gist.say

[14:22] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[Q True True] [True True True] [True True True]]␤»

[14:22] <jnthn> You...want a 3D chess board? :)

[14:22] *** skids joined
[14:22] <Xliff> fluca1978: You then need to choose a side.

[14:22] <Xliff> s/side/size/

[14:22] <fluca1978> well, an n-dimension chessboard...

[14:22] <timotimo> m: my $size = 3; my @dim = 5; my @chessboard; @chessboard[||($size xx @dim)] = 1; @chessboard >>[=]>> 1; say @chessboard

[14:22] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[1 1 1 1]␤»

[14:23] <timotimo> hm, = isn't nodal?

[14:23] <timotimo> m: my $size = 3; my @dim = 5; my @chessboard; @chessboard[||($size xx @dim)] = 1; @chessboard.duckmap(-> Any:U $v is rw { $v = 9 }); say @chessboard

[14:23] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[9 9 9 1]␤»

[14:24] <timotimo> m: my $size = 3; my @dim = 5; my @chessboard; @chessboard[||([$size] xx @dim)] = 1; @chessboard.duckmap(-> Any:U $v is rw { $v = 9 }); say @chessboard

[14:24] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[9 9 9 1]␤»

[14:24] <timotimo> m: my $size = 3; my @dim = 5; my @chessboard; @chessboard[||([$size,] xx @dim)] = 1; @chessboard.duckmap(-> Any:U $v is rw { $v = 9 }); say @chessboard

[14:24] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[9 9 9 1]␤»

[14:24] <timotimo> how did i do the thing with interpolating a list-of-lists in a postcircumfix:<[ ]>

[14:26] <Xliff> m: my $size = 3; my $dim = 2; my @chessboard; for ^$dim { my $r = True xx $dim; $r xx $_ for ^($dim-1); @chessboard[$_] = $r; }; @chessboard.say;

[14:26] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «WARNINGS for <tmp>:␤[(True True) (True True)]␤Useless use of $r in sink context (line 1)␤»

[14:26] <Xliff> m: my $size = 3; my $dim = 2; my @chessboard; for ^$dim { my $r = True xx $dim; $r = $r xx $_ for ^($dim-1); @chessboard[$_] = $r; }; @chessboard.say;

[14:26] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[() ()]␤»

[14:26] *** Altai-man_ joined
[14:27] <Xliff> m: my $size = 3; my $dim = 2; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $ for ^($dim-1); @chessboard[$_] = $r; }; @chessboard.say;

[14:27] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Cannot resolve caller infix:<xx>(Code:D, Any:U); none of these signatures match:␤    ()␤    (Mu \x)␤    (&x, Num:D(Any):D $n)␤    (&x, Whatever)␤    (&x, Bool:D $b)␤    (&x, Int:D $n)␤    (Mu \x, Num:D(Any):D $n)␤    (Mu \x, Whatever)…»

[14:27] <Xliff> m: my $size = 3; my $dim = 2; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $_ for ^($dim-1); @chessboard[$_] = $r; }; @chessboard.say;

[14:27] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[() ()]␤»

[14:27] *** ohmycloud joined
[14:28] <Xliff> m: my $size = 3; my $dim = 2; my @chessboard; for ^$dim { my $r = True xx $size; @chessboard[$_] = $r; }; @chessboard.say;

[14:28] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[(True True True) (True True True)]␤»

[14:28] <Xliff> m: my $size = 3; my $dim = 2; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $_ for ^($dim-2); @chessboard[$_] = $r; }; @chessboard.say;

[14:28] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[(True True True) (True True True)]␤»

[14:28] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $_ for ^($dim-2); @chessboard[$_] = $r; }; @chessboard.say;

[14:28] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[() () ()]␤»

[14:28] <elcaro> for 3D chessboard, you would just further nest it: my @chessboard = [[True xx $dimension] xx $dimension] xx $dimension; 

[14:29] *** sena_kun left
[14:29] <Xliff> elcaro: The trick is to generalize that.

[14:29] <elcaro> yeah

[14:30] <elcaro> you could do it with a shaped array :D

[14:30] <elcaro> m: my @c[2;2;2].map({ $_ = True }); say @c;

[14:30] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[True True]␤  [True True]]␤ [[True True]␤  [True True]]]␤»

[14:30] <elcaro> tho i hear perf isn't great on shaped arrays atm

[14:31] <Xliff> elcaro: Yes, but again.. how would you initialize that without needing to know the number of dimensions in advance? ;)

[14:31] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim); @chessboard[$_] = $r; }; @chessboard.say;

[14:31] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[((((True True True) (True True True) (True True True)) ((True True True) (True True True) (True True True)) ((True True True) (True True True) (True True True))) (((True True True) (True True True) (True True True)) ((True True True) (True True True)…»

[14:32] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim); @chessboard[$_] = $r; }; @chessboard[0].elems.say

[14:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «3␤»

[14:32] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim); @chessboard[$_] = $r; }; @chessboard[0][0].elems.say

[14:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «3␤»

[14:32] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim); @chessboard[$_] = $r; }; @chessboard[0][0][0].elems.say

[14:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «3␤»

[14:32] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim); @chessboard[$_] = $r; }; @chessboard[0][0][0][0].elems.say

[14:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «3␤»

[14:32] <elcaro> Xliff: can use a variable in shaped array definition

[14:32] <elcaro> m: my $d = 3; my @c[$d;$d;$d].map({ $_ = True }); @c[0;0;0] = False; say @c; 

[14:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[False True True]␤  [True True True]␤  [True True True]]␤ [[True True True]␤  [True True True]␤  [True True True]]␤ [[True True True]␤  [True True True]␤  [True True True]]]␤»

[14:32] <Xliff> elcaro: Ah! Excellent!\

[14:33] <Xliff> But again... you are still locking the dimensions to 3.\

[14:33] <elcaro> using map to initialise slots feels a little dirty :)

[14:33] <Xliff> Yeah, well..../

[14:33] *** fluca1978 left
[14:33] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[0][0][0][0].elems.say

[14:33] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «1␤»

[14:34] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[0][0][0].elems.say

[14:34] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «3␤»

[14:34] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[0][0].elems.say

[14:34] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «3␤»

[14:34] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[0].elems.say

[14:34] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «3␤»

[14:34] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[0].gist.say

[14:34] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «(((True True True) (True True True) (True True True)) ((True True True) (True True True) (True True True)) ((True True True) (True True True) (True True True)))␤»

[14:34] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = True xx $size; $r = $r xx $dim for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[1][1][1] = 'Q'; @chessboard[0].gist.say

[14:34] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Cannot modify an immutable List (((True True True) (T...)␤  in block <unit> at <tmp> line 1␤␤»

[14:35] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = [ True xx $size ]; $r = $r xx $dim for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[1][1][1] = 'Q'; @chessboard[0].gist.say

[14:35] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Cannot modify an immutable List (([True True True] [T...)␤  in block <unit> at <tmp> line 1␤␤»

[14:36] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = [ True xx $size ]; $r = [ $r xx $dim ] for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[1][1][1] = 'Q'; @chessboard[0].gist.say

[14:36] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[True True True] [True True True] [True True True]] [[True True True] [True True True] [True True True]] [[True True True] [True True True] [True True True]]]␤»

[14:36] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = [ True xx $size ]; $r = [ $r xx $dim ] for ^($dim-1); @chessboard[$_] = $r; }; @chessboard[1][1][1] = 'Q'; @chessboard.gist.say

[14:36] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[[True True True] [True True True] [True True True]] [[True True True] [True True True] [True True True]] [[True True True] [True True True] [True True True]]] [[[True True True] Q [True True True]] [[True True True] Q [True True True]] [[True True …»

[14:36] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = [ True xx $size ]; $r = [ $r xx $dim ] for ^($dim-2); @chessboard[$_] = $r; }; @chessboard[1][1][1] = 'Q'; @chessboard.gist.say

[14:36] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[True True True] [True True True] [True True True]] [[True Q True] [True Q True] [True Q True]] [[True True True] [True True True] [True True True]]]␤»

[14:37] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = [ True xx $size ]; $r = [ $r xx $dim ] for ^($dim-2); @chessboard[$_] = $r; }; @chessboard[1][1][1][0] = 'Q'; @chessboard.gist.say

[14:37] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Cannot modify an immutable Bool (True)␤  in block <unit> at <tmp> line 1␤␤»

[14:37] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = [ True xx $size ]; $r = [ $r xx $dim ] for ^($dim-2); @chessboard[$_] = $r; }; @chessboard[1][1][1].gist.say; @chessboard.gist.say

[14:37] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «True␤[[[True True True] [True True True] [True True True]] [[True True True] [True True True] [True True True]] [[True True True] [True True True] [True True True]]]␤»

[14:37] <Xliff> m: my $size = 3; my $dim = 3; my @chessboard; for ^$dim { my $r = [ True xx $size ]; $r = [ $r xx $dim ] for ^($dim-2); @chessboard[$_] = $r; }; @chessboard[1][1][1].gist.say;

[14:37] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «True␤»

[14:38] <Xliff> Well... FWIW, I think that's close. Enough camelia play for today.

[14:40] *** mowcat joined
[14:41] *** mowcat left
[14:41] *** mowcat joined
[14:42] *** sjm_uk left
[14:43] *** mowcat left
[14:43] *** sjm_uk joined
[14:43] *** mowcat joined
[14:45] *** mowcat left
[14:46] *** mowcat joined
[14:46] <elcaro> Xliff: perhaps they wer looking for something as simple as numpy.zeros((3, 3, 3))

[14:47] <elcaro> shaped arrays is as close as we get... you can slip arrays to the initialiser which completely generalises it

[14:47] <elcaro> m: my @d = 3, 3, 3; my @c[|@d].map({ $_ = True }); @c[0;0;0] = False; say @c 

[14:47] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[False True True]␤  [True True True]␤  [True True True]]␤ [[True True True]␤  [True True True]␤  [True True True]]␤ [[True True True]␤  [True True True]␤  [True True True]]]␤»

[14:48] <elcaro> m: my @d = 1, 2, 4, 3; my @c[|@d].map({ $_ = True }); @c[0;0;0] = False; say @c 

[14:48] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Cannot assign to a 4 dimension array with only 3 dimensions␤  in block <unit> at <tmp> line 1␤␤»

[14:48] *** guifa2 left
[14:49] <elcaro> hm

[14:49] <elcaro> m: my @d = 2,2,2,2; my @c[|@d].map({ $_ = True }); @c[0;0;0;0] = False; say @c

[14:49] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[[False True]␤   [True True]]␤  [[True True]␤   [True True]]]␤ [[[True True]␤   [True True]]␤  [[True True]␤   [True True]]]]␤»

[14:50] <elcaro> oh... i forgot to update my assignment to False in the example that failed

[14:50] <elcaro> m: my @d = 1,2,3,4; my @c[|@d].map({ $_ = True }); @c[0;0;0;0] = False; say @c 

[14:50] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[[False True True True]␤   [True True True True]␤   [True True True True]]␤  [[True True True True]␤   [True True True True]␤   [True True True True]]]]␤»

[14:51] <elcaro> actually... i don't think the slip is needed 

[14:52] *** Dock_Holliwood left
[14:52] <elcaro> my @d = 2,2,2; say my @c[@d];

[14:52] <evalable6> elcaro, rakudo-moar 8b94d8d27: OUTPUT: «[[[(Any) (Any)]␤  [(Any) (Any)]]␤ [[(Any) (Any)]␤  [(Any) (Any)]]]␤»

[14:54] *** Merfont left
[14:55] <Xliff> elcaro++!

[14:55] <Xliff> So it goes a lil somethin' like this... hit it!

[14:55] <Xliff> m: my $size = 3; my $dim = 2; my @c = $size xx $dim; my @chessboard[@c]; @chessboard.map({ $_ = True }); @chessboard[1;1] = 'Q'; @chessboard.say

[14:55] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[True True True]␤ [True Q True]␤ [True True True]]␤»

[14:56] <Xliff> m: my $size = 3; my $dim = 3; my @c = $size xx $dim; my @chessboard[@c]; @chessboard.map({ $_ = True }); @chessboard[1;1] = 'Q'; @chessboard.say

[14:56] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Cannot assign to a 3 dimension array with only 2 dimensions␤  in block <unit> at <tmp> line 1␤␤»

[14:56] <Xliff> m: my $size = 3; my $dim = 3; my @c = $size xx $dim; my @chessboard[@c]; @chessboard.map({ $_ = True }); @chessboard[1;1;1] = 'Q'; @chessboard.say

[14:56] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[True True True]␤  [True True True]␤  [True True True]]␤ [[True True True]␤  [True Q True]␤  [True True True]]␤ [[True True True]␤  [True True True]␤  [True True True]]]␤»

[14:57] *** Kaiepi joined
[14:57] <Xliff> \o/

[15:03] <Geth> ¦ doc: uzluisf++ created pull request #3429: Minor rewording with few examples

[15:03] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3429

[15:03] <Xliff> So this example brings up the question of: When are shaped array partials going to be implemented?

[15:04] <Xliff> Because it is one thing to create a multi-dimensional array. It's another thing to access it without knowing its dimensionality ahead of time.

[15:05] <elcaro> I think the answer to that is "well volunteered"

[15:05] <elcaro> :D

[15:05] <Xliff> Yeah. I kinda figured that. 

[15:06] <elcaro> We are a small community around a very big language. I've learned to wait for things.

[15:06] <timotimo> m: my $dims = 9; my @foo := Array[int].new(:shape(3 xx $dims)); say @foo

[15:06] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[[[[[[[(int) (int) (int)]␤        [(int) (int) (int)]␤        [(int) (int) (int)]]␤       [[(int) (int) (int)]␤        [(int) (int) (int)]␤        [(int) (int) (int)]]␤       [[(int) (int) (int)]␤        [(int) (int) (int)]␤        […»

[15:06] <timotimo> but shaped native arrays are not very fast  last time i checked

[15:07] *** melezhik joined
[15:10] <melezhik> .tell rba , please ping me when you are here, thanks

[15:10] <tellable6> melezhik, I'll pass your message to rba

[15:11] *** sno left
[15:16] *** andrzejku left
[15:17] <Xliff> m: my $size = 3; my $dim = 3; my @c = $size xx $dim; my @chessboard[@c]; @chessboard.map({ $_ = ++$ }); @chessboard[1;1;1] = 'Q'; @chessboard.say

[15:17] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «[[[1 2 3]␤  [4 5 6]␤  [7 8 9]]␤ [[10 11 12]␤  [13 Q 15]␤  [16 17 18]]␤ [[19 20 21]␤  [22 23 24]␤  [25 26 27]]]␤»

[15:18] *** oneeggeach left
[15:32] *** brtastic left
[15:36] *** domidumont left
[15:36] *** ohmycloud left
[15:38] *** Sgeo joined
[15:52] *** sjm_uk left
[15:52] *** sno joined
[15:57] *** domidumont joined
[16:01] *** NODE left
[16:02] *** NODE joined
[16:10] *** RaycatWhoDat joined
[16:10] <RaycatWhoDat> c: say "Hello"

[16:10] <committable6> RaycatWhoDat, Seems like you forgot to specify a revision (will use “v6.c” instead of “say”)

[16:11] <committable6> RaycatWhoDat, ¦v6.c (43 commits): «Hello␤»

[16:11] <RaycatWhoDat> p6: say "Hello".substr(-1)

[16:11] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Start argument to substr out of range. Is: -1, should be in 0..5; use *-1 if you want to index relative to the end␤  in block <unit> at <tmp> line 1␤␤»

[16:11] <RaycatWhoDat> So, this makes sense. But when you do this:

[16:11] <RaycatWhoDat> p6: say "Hello".substr(*-1)

[16:11] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «o␤»

[16:12] <RaycatWhoDat> Or maybe I'm mistaken.

[16:12] <timotimo> hm?

[16:12] <RaycatWhoDat> p6: say "Hello".substr(*-1) ~~ "o"

[16:12] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «True␤»

[16:12] *** brtastic joined
[16:13] <RaycatWhoDat> timotimo: I was running into a weird error while trying to do a comparison on a substring

[16:13] <RaycatWhoDat> Seems like I might be mistaken, though. Let me double-check.

[16:13] <timotimo> m: say "Hello".substr(*-20)

[16:13] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Start argument to substr out of range. Is: -15, should be in 0..5; ␤  in block <unit> at <tmp> line 1␤␤»

[16:14] <timotimo> ^- i wonder if we can make this error message cleverer based on knowing it's a whatever star based calculation

[16:14] <RaycatWhoDat> Yeah, I think the test suite is passing in an empty string

[16:17] <RaycatWhoDat> I could give it a fang.

[16:18] <RaycatWhoDat> Could you capture your initial thoughts on it in an issue?

[16:18] <timotimo> oh, hmm

[16:19] <timotimo> another thing we'd want to think about: what if someone does the dangerous™ thing and puts code with a side-effect in there

[16:19] <timotimo> and we would re-evaluate it when coming up with the error message

[16:19] *** domidumont left
[16:19] <timotimo> hmmm

[16:20] <timotimo> in general, do we have many cases where calling .message on an exception at different times will give different, potentially wrong, outputs?

[16:21] <RaycatWhoDat> I dunno, man. I'm just a fan of the language.

[16:21] <RaycatWhoDat> Haha.

[16:21] <RaycatWhoDat> Maybe one day, I'll be able to tell you off the cuff.

[16:22] <timotimo> i'm not sure anybody would be able to without going through the Exceptions file in core

[16:23] <ShimmerFairy> m: say (-> $a {$a - 1}).WHAT; say (*-1).WHAT;

[16:23] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «(Block)␤(WhateverCode)␤»

[16:23] <ShimmerFairy> I feel like you could just check the type of the code, no?

[16:25] <timotimo> hmm. we can probably get the value we had passed into the code and the value that came out

[16:25] <timotimo> for use in the error message

[16:26] *** sno left
[16:27] *** sena_kun joined
[16:28] *** aindilis left
[16:29] <timotimo> (without making performance suffer, hopefully!)

[16:29] *** Altai-man_ left
[16:29] <RaycatWhoDat> Man, the regexes are doing my head in

[16:30] <RaycatWhoDat> Can't seem to make one that just checks the whole string for uppercase letters

[16:30] *** aborazmeh left
[16:30] <RaycatWhoDat> /^^ <upper> ** 2..* $$/ doesn't work like I thought

[16:30] *** aindilis joined
[16:31] *** aindilis left
[16:31] <ShimmerFairy> m: say "HELLO" ~~ /^ <:Upper>+ $/; say "WORLd" ~~ /^ <:Upper>+ $/;

[16:31] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «｢HELLO｣␤Nil␤»

[16:31] <ShimmerFairy> I don't think <upper> exists by default, but there is of course the unicode property

[16:32] <RaycatWhoDat> What does the colon do?

[16:32] *** aindilis joined
[16:34] <ShimmerFairy> It allows you to match based on some unicode property (it works like colon pair notation)

[16:34] <RaycatWhoDat> Ah. Nice.

[16:35] <RaycatWhoDat> Now I just need it to capture more than the first word

[16:35] <ShimmerFairy> m: say "a_b" ~~ /^ <alpha>+ $/; say "a_b" ~~ /^ <:Alpha>+ $/; # <alpha> by default includes an underscore because stuff you parse tends to treat it like a kind of letter

[16:35] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «｢a_b｣␤ alpha => ｢a｣␤ alpha => ｢_｣␤ alpha => ｢b｣␤Nil␤»

[16:35] <RaycatWhoDat> Apparently, you can't adverb on ~~?

[16:36] <ShimmerFairy> If you need adverbs on / regex / that can't go inside the regex, you could use m:adv/ ... /

[16:36] <RaycatWhoDat> That's what it's complaining on

[16:36] <RaycatWhoDat> p6: say "test" ~~ rx:g/<:Upper>+/

[16:36] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Adverb g not allowed on rx␤at <tmp>:1␤------> 3say "test" ~~ rx:g/<:Upper>+/7⏏5<EOL>␤»

[16:37] <ShimmerFairy> m: say "test" ~~ m:g/<:Upper>+/

[16:37] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «()␤»

[16:37] <ShimmerFairy> I don't know offhand why rx// isn't working there

[16:37] <RaycatWhoDat> Oh, literally use the 'm'

[16:41] <ShimmerFairy> IIUC, :global is a match option and so it gets passed to the match function, not attached to the regex itself. m:g/something/ is really just $_.match(/something/, :g)

[16:42] <ShimmerFairy> whereas rx// just makes a Regex object.

[16:42] <RaycatWhoDat> Ah, that makes sense.

[16:45] <melezhik> Hi! rakudist now is available as https://rakudist.raku.org/ . I'd appreciate if someone could test it. - https://sparrowdo.wordpress.com/2020/05/25/rakudist-raku-org-better-testing-started/

[16:45] <tellable6> 2020-05-24T22:29:28Z #raku-dev <vrurg> melezhik thanks! I overlooked a strange copy/paste issue.

[16:45] <melezhik> thanks to rba and AlexDaniel` for the help with https://rakudist.raku.org/

[16:46] <melezhik> vrurg you are welcome, now you can test it through rakudist )))

[16:52] *** sno joined
[17:01] *** kensanata left
[17:12] *** epony left
[17:22] *** epony joined
[17:28] <RaycatWhoDat> How would you make this more concise?

[17:28] <RaycatWhoDat> m:g/<:Upper> ** 2..*/ and not m:g/<:Lower>/

[17:28] <evalable6> RaycatWhoDat, rakudo-moar 8b94d8d27: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/6uQ0fchb3r␤Undeclared routines:␤    and used at line 1. Did you mean 'end', 'any', 'rand'?␤    g used at line 1␤␤»

[17:29] <RaycatWhoDat> TIL m does a thing in IRC

[17:29] <timotimo> heh

[17:29] <timotimo> well what do you want the regex to do exactly?

[17:30] <timotimo> the first one requires two or more uppercase in a row, the other requires no lower case to be in the string

[17:31] <RaycatWhoDat> Hmm. Is there a way to ensure the string can only have capital letters?

[17:31] <RaycatWhoDat> (and whitespace and punctuation)

[17:31] <sena_kun> .uc eq $_?

[17:32] <sena_kun> m: say "FOO AND BAR".uc eq "FOO AND BAR";

[17:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «True␤»

[17:32] <sena_kun> m: say "FOO AND BaR".uc eq "FOO AND BAR";

[17:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «True␤»

[17:32] <sena_kun> wait, not this one

[17:32] <timotimo> need to compare to itself pre-uc

[17:32] <sena_kun> m: my $a = "FOO AND BAr"; say $a eq $a.uc;

[17:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «False␤»

[17:32] <timotimo> not two literals that are different :D

[17:32] <sena_kun> m: my $a = "FOO AND BAR"; say $a eq $a.uc;

[17:32] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «True␤»

[17:33] <sena_kun> timotimo, well, I was lazy to write out a variable. A bit too lazy for it to work. :P

[17:33] *** gdonald joined
[17:33] <timotimo> :)

[17:34] <RaycatWhoDat> Mm. Seems to fail on certain tests.

[17:34] <sena_kun> RaycatWhoDat, like what ones?

[17:34] <RaycatWhoDat> "1, 2, 3" does equal "1, 2, 3" but it would fail the tests for this particular exercise

[17:35] <sena_kun> Why, it prohibits digits?

[17:36] <RaycatWhoDat> No, it's looking for context. Specifically between talking, questioning, shouting, and shouting a question.

[17:36] <timotimo> "are all letters uppercase?" is true for "1, 2, 3"

[17:37] <RaycatWhoDat> Right. But it would fail the test.

[17:38] <timotimo> m: my $a = "1, 2, 3"; say $a eq $a.uc

[17:38] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «True␤»

[17:38] <RaycatWhoDat> Not that test, heh.

[17:38] <RaycatWhoDat> https://exercism.io/tracks/raku/exercises/bob/solutions/045ece720bce494c9ba72e19b6bb2cac

[17:38] <RaycatWhoDat> Click on the instructions tab.

[17:38] *** Dock_Holliwood joined
[17:38] <timotimo> is "!!!!!!!!!!!!!!!!!!!!!!!!" not a yell? :D

[17:39] <RaycatWhoDat> According to the rules, that wouldn't be valid because there are no letters in there.

[17:39] <timotimo> OK

[17:40] <RaycatWhoDat> Yeah, arbitrary problems are weird but I'm still trying to get my sea legs with the language.

[17:42] *** NODE left
[17:44] *** NODE joined
[17:45] <timotimo> ah :)

[17:49] *** NODE left
[17:52] *** NODE joined
[18:08] *** Xliff left
[18:19] *** molaf left
[18:22] *** chloekek left
[18:27] *** Altai-man_ joined
[18:29] *** sena_kun left
[18:38] *** KindTwo joined
[18:39] *** KindOne left
[18:42] *** KindTwo is now known as KindOne

[18:49] *** oneeggeach joined
[18:55] *** Black_Ribbon joined
[19:15] *** juanfra_ left
[19:19] <colomon_> m: sub check($a) { $a eq “a” | “b” }; my $c = check(“b”); dd $c

[19:19] <camelia> rakudo-moar 8b94d8d27: OUTPUT: «Junction $c = any(Bool::False, Bool::True)␤»

[19:27] *** chloekek joined
[19:30] *** abraxxa left
[19:32] *** abraxxa joined
[19:38] *** lucs joined
[19:55] *** brtastic left
[19:55] *** melezhik22 joined
[19:55] *** melezhik22 is now known as melezhik2

[20:24] *** aborazmeh joined
[20:24] *** aborazmeh left
[20:24] *** aborazmeh joined
[20:26] *** [Sno] joined
[20:28] *** sena_kun joined
[20:29] *** Altai-man_ left
[20:30] *** sno left
[20:31] *** stoned75 left
[20:33] *** stoned75 joined
[20:38] *** melezhik2 left
[20:53] *** rindolf left
[20:54] *** molaf joined
[20:56] *** ensamvarg3 left
[21:01] *** NODE left
[21:02] *** NODE joined
[21:03] *** average left
[21:23] *** wamba1 left
[21:35] *** clarjon1 joined
[21:39] *** leont left
[21:40] *** oneeggea_ joined
[21:40] *** oneeggea_ left
[22:01] *** cpan-raku left
[22:02] *** cpan-raku joined
[22:02] *** cpan-raku left
[22:02] *** cpan-raku joined
[22:05] *** patrickb joined
[22:15] *** chloekek left
[22:15] <SmokeMachine> how can I access the Raku's hash function?

[22:27] *** Altai-man_ joined
[22:29] *** sena_kun left
[22:47] *** patrickb left
[23:11] *** rir joined
[23:12] *** RaycatWhoDat left
[23:13] *** pecastro left
[23:16] *** oneeggea_ joined
[23:16] *** oneeggea_ left
[23:18] *** guifa2 joined
[23:23] *** MasterDuke left
[23:24] <rir> Hello wonderful people and bots that pass the test.  I uninstall Timmerman's todo-viewer but am left with this file:  rakudo/install/share/perl6/site/sources/BF065922962C238A6A7D3B5D8B10FD2625F9789F which is Marcel's lib/Gui.pm6.  What's going on?

[23:24] <rir> ^zef

[23:41] *** marcusr left
[23:43] *** marcusr joined
[23:44] *** guifa2 left
[23:46] *** mowcat left
