[00:01] <codesections> m: dd $*RAKU.compiler

[00:01] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Compiler rakudo = Compiler.new(id => "B0D6A0338B85BFBFE1C14B4AEDA60C0788BB2C25", release => "", codename => "", name => "rakudo", auth => "The Perl Foundation", version => v2020.07.66.g.2.db.92.e.04.f, signature => Blob, desc => Str)‚ê§¬ª

[00:24] *** mowcat left
[00:51] *** Altai-man joined
[00:53] *** sena_kun left
[01:03] *** _jrjsmrtn joined
[01:05] *** __jrjsmrtn__ left
[01:10] *** gugod left
[01:13] *** gugod joined
[01:17] *** gugod left
[01:17] *** gugod joined
[01:17] *** gugod left
[01:17] *** gugod joined
[01:18] *** gugod left
[01:18] *** gugod joined
[01:27] *** kotrcka joined
[01:56] *** cpan-raku left
[01:59] *** cpan-raku joined
[01:59] *** cpan-raku left
[01:59] *** cpan-raku joined
[02:02] *** Noisytoot left
[02:19] *** ilogger2 joined
[02:20] *** go|dfish joined
[02:35] *** fooist joined
[02:38] *** Cabanossi joined
[02:40] <fooist> Does anyone here know what the status/provenance is of the p6dists.json.gz file in CPAN (under /authors)? Sorry

[02:41] <fooist> Total raku #n00b

[02:42] <fooist> Mostly wondering if it‚Äôs officially supported

[03:51] *** hungrydonkey joined
[04:00] *** rockxloose joined
[04:54] *** sena_kun joined
[05:05] *** finanalyst joined
[05:08] <moritz> fooist: iirc it's the file that package managers use to get a list of p6/raku distributions on CPAN

[05:22] *** stoned75 joined
[05:22] *** epony joined
[05:37] *** bocaneri joined
[07:07] *** sjm_uk joined
[07:10] *** sarna joined
[07:12] *** hungrydonkey left
[07:13] <sarna> o/

[07:15] <Geth> ¬¶ ecosystem: 318bb77d0d | (Daniel Lathrop)++ (committed using GitHub Web editor) | META.list

[07:15] <Geth> ¬¶ ecosystem: remove duplicate from META.list

[07:15] <Geth> ¬¶ ecosystem: review: https://github.com/Raku/ecosystem/commit/318bb77d0d

[07:15] <Geth> ¬¶ ecosystem: 14877cef2d | (Juan Juli√°n Merelo Guerv√≥s)++ (committed using GitHub Web editor) | META.list

[07:15] <Geth> ¬¶ ecosystem: Merge pull request #526 from fooist/patch-1

[07:15] <Geth> ¬¶ ecosystem: 

[07:15] <Geth> ¬¶ ecosystem: remove duplicate from META.list

[07:15] <Geth> ¬¶ ecosystem: review: https://github.com/Raku/ecosystem/commit/14877cef2d

[07:15] *** hungrydonkey joined
[07:18] *** oddp joined
[07:20] *** JJMerelo joined
[07:22] <sarna> m: say join("hello ", "world"); say ("hello ", "world").join;  # is there a viable use case for `sub join` when `*@list` has < 2 things in it?

[07:22] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´world‚ê§hello world‚ê§¬ª

[07:29] <JJMerelo> what's happened to "hello"?

[07:29] <tellable6> 2020-08-16T21:06:49Z #raku <lizmat> JJMerelo https://github.com/Raku/advent/blob/master/20th/articles/rfc200.md

[07:29] <tellable6> 2020-08-17T22:52:12Z #raku <tbrowder> jjmerelo: how often are public-facing doc pages regenerated? do i need to trash my browser cache to see an update?

[07:29] <JJMerelo> .tell tbrowder they are updated... from time to time. I'll do it today.

[07:29] <tellable6> JJMerelo, I'll pass your message to tbrowder

[07:33] <sarna> JJMerelo: sub's signature is `sub    join($separator, *@list)`, it thinks "hello " is the separator, and "world" is the list :(

[07:33] <sarna> it's very confusing when you first encounter it

[07:33] <JJMerelo> Ah, right, of course...

[07:35] <sarna> it could check the length of the list, but idk about performance loss/use cases I missed

[07:44] *** stoned75 left
[07:45] *** dakkar joined
[07:48] *** xinming joined
[07:54] *** stoned75 joined
[08:04] <Geth> ¬¶ advent: 51018fd824 | (JJ Merelo)++ | 20th/articles/rfc265.md

[08:04] <Geth> ¬¶ advent: Minor modifications

[08:04] <Geth> ¬¶ advent: review: https://github.com/Raku/advent/commit/51018fd824

[08:11] *** hungrydonkey left
[08:32] <Geth> ¬¶ ecosystem: 9f1c7aa568 | (JJ Merelo)++ | 2 files

[08:32] <Geth> ¬¶ ecosystem: Rearranges test file

[08:32] <Geth> ¬¶ ecosystem: 

[08:32] <Geth> ¬¶ ecosystem: So that it builds before testing for the existence of files. Closes #527

[08:32] <Geth> ¬¶ ecosystem: It also updates to use the latest version of the Docker container, which includes make and gcc

[08:32] <Geth> ¬¶ ecosystem: review: https://github.com/Raku/ecosystem/commit/9f1c7aa568

[08:47] *** [Sno] joined
[08:51] *** Altai-man joined
[08:54] *** sena_kun left
[09:02] *** rindolf joined
[09:05] *** JJMerelo left
[09:56] <tbrowder> .tell jjmerelo thnx, amigo

[09:56] <tellable6> tbrowder, I'll pass your message to JJMerelo

[09:57] <tbrowder> gracias

[09:57] <tellable6> 2020-08-19T07:29:38Z #raku <JJMerelo> tbrowder they are updated... from time to time. I'll do it today.

[10:04] *** hungrydonkey joined
[10:13] <sarna> is there really no way of preventing Nil propagation in method chains? I'd prefer it to fail fast :(

[10:19] *** sjm_uk left
[10:20] <sarna> can I maybe specify that I want to take `self:D`? not sure how to do that..

[10:21] <sarna> oh no, that wouldn't work, since every method called on Nil returns Nil >.>

[10:25] *** [Sno] left
[10:29] *** JJMerelo joined
[10:29] *** yangzq50 joined
[10:29] <codesections>  sarna: hmmm, you seem to be right, that doesn't work; I'm a bit surprised

[10:29] <codesections> m:  class A { method n { Nil }; method non-nil(A:D $:) { 42}}; say A.new.n.non-nil  

[10:29] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Nil‚ê§¬ª

[10:29] <sarna> codesections: I've found this - https://stackoverflow.com/questions/60155276/i-can-call-any-method-on-nil-and-this-feels-wrong/60155442#60155442

[10:30] <sarna> I don't find the reasoning (not having to insert null checks between chains) that convincing

[10:30] <sarna> m:  class A { method n { Nil }; method non-nil(A:D $:) { 42}}; my $foo = A.new.n; say $foo.non-nil  

[10:30] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´No such method 'non-nil' for invocant of type 'Any'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[10:31] <sarna> this dies (as it should), but you have to break up your method chains like this, every time..

[10:33] <codesections> And that makes sense, given how assigning Nil works 

[10:34] <sarna> yeah, but I'd say the default behavior is LTA - nothing less fun than hunting for a bug that propagated from something deep down the call stack

[10:35] <sarna> Nil carries absolutely no information

[10:35] <codesections> m: class A { method n { Nil }; method non-nil(A:D $:) { 42}}; say (my $ = A.new.n).non-nil

[10:35] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´No such method 'non-nil' for invocant of type 'Any'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[10:35] <codesections> that's pretty ugly, though

[10:37] <sarna> it is, and the ugliness is O(n) where n is the number of methods in a chain

[10:38] <codesections> Yep!

[10:38] <codesections> Though, I think it'd work without the `my` which helps (very slightly)

[10:40] <sarna> maybe raku has something like dart's cascade notation? that would help - https://stackoverflow.com/questions/49447736/list-use-of-double-dot-in-dart

[10:42] <sarna> I may be onto something

[10:42] <sarna> m: class A { method n { Nil }; method non-nil(A:D $:) { 42}}; $ = A.new.n; $ .= non-nil; .say

[10:42] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´No such method 'non-nil' for invocant of type 'Any'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[10:43] <sarna> just replace all dots with `$ .=` et voila

[10:44] <codesections> Is that really less ugly than 

[10:44] <codesections> m:  class A { method n { Nil }; method non-nil(A:D $:) { 42}}; say ($ =A.new.n).non-nil

[10:44] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´No such method 'non-nil' for invocant of type 'Any'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[10:45] <sarna> semicolons instead of parens? :D

[10:46] <sarna> mine would read better when splitted across multiple lines

[10:47] *** yangzq50 left
[10:47] <codesections> oooh, I think I have something:

[10:47] <codesections> m: sub postfix:<‚ÄΩ>($a) { $ = $a};  class A { method n { Nil }; method non-nil(A:D $:) { 42}}; say A.new.n‚ÄΩ.non-nil

[10:47] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´No such method 'non-nil' for invocant of type 'Any'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[10:49] <sarna> codesections: what's that?

[10:50] <sarna> oh darn it's your own operator

[10:50] <sarna> I searched for it in the docs :DDD

[10:50] <codesections> :D

[10:50] <sarna> I love this

[10:50] <sarna> also I hate this

[10:51] <codesections> Agreed

[10:53] <sarna> noo you can't do  ‚ÄΩ<newline>. :(((

[10:53] <sarna> all the methods have to be on one line

[10:54] *** [Sno] joined
[10:56] <codesections> Hmmm, I've run into that problem with &.subroutine method calls too

[11:01] <tobs> it's probably better to extinguish that behavior at the source if you dislike it and don't want to change your entire code to a new method call operator:

[11:02] <tobs> m: Nil.^find_method("FALLBACK").wrap: -> $, $ { fail 'method call on Nil' }; class A { method n { Nil }; method non-nil (A:D $:) { 42 } }; say A.new.n.non-nil

[11:02] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´method call on Nil‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[11:02] <sarna> monkey patching Nil because I don't like a design decision? is that legal?

[11:03] <tobs> by keeping the return value of that wrap call you can make the change lexical by unwrapping at scope exit

[11:03] <tobs> actually, I am not sure how stable wrapping core class's methods is

[11:04] <sarna> that still seems heavy-handed, and confusing to whoever will come and look at my code

[11:04] <codesections> tobs: I like that approach.  It strikes me that forgetting to unwrap that at the end of a scope could break ‚Ä¶ lots of things, though

[11:08] *** aluaces joined
[11:08] *** aluaces is now known as alberto

[11:09] <codesections> sarna: I'm not getting an error when breaking the method chain across multiple lines with the new operator

[11:09] *** alberto is now known as Guest47135

[11:09] <sarna> codesections: where do you break it? I tried `foo?!<newline>.bar` and I kept getting "bogus operator"

[11:11] <tbrowder> hi, anyone use raku on win  10 as primary os?

[11:12] *** xinming left
[11:12] <tbrowder> if so, what is preferred raku installation method and editor? thnx

[11:13] *** xinming joined
[11:14] <tbrowder> win is not my cup of tea, but trying to wean grandson off python and such

[11:15] <tbrowder> as is taught in govt schools

[11:22] <kawaii> Is there some way to switch the state of a Bool between True/False without doing some janky if statement saying `if $blah = True { $blah = False }`? :) 

[11:22] *** aborazmeh joined
[11:22] *** aborazmeh left
[11:22] *** aborazmeh joined
[11:22] <Altai-man> kawaii, $blah = !$blah2?

[11:22] <kawaii> (implying I don't know the state of the Bool, I just want to switch it regardless)

[11:22] <Altai-man> $blah = !$blah?

[11:22] <kawaii> ah :D

[11:23] <kawaii> wait really

[11:23] <kawaii> this is a thing

[11:23] <codesections> sarna: here's the code that was working for me with newlines https://gist.github.com/codesections/445e2a043c4ffe4a4cfbb7aac75d5462

[11:23] <kawaii> Altai-man++

[11:23] *** xinming left
[11:24] *** xinming joined
[11:25] *** hungrydonkey left
[11:26] <codesections> kawaii: and you don't really need the final `?`, though it might make the expression clearer, at least to some readers

[11:26] <kawaii> codesections: trust me, no one is capable of reading anything I write :)

[11:27] <codesections> :D

[11:28] <sarna> codesections: https://repl.it/repls/OnerlookedAngryClimate#main.raku take a look here, without line 8 it works fine

[11:31] <codesections> hmm, odd.  I *bet* that's something to do with the precedence/associativity of the operator, but I'm not sure. https://docs.raku.org/language/functions#Precedence

[11:35] <SmokeMachine> is there a way of getting the block that called the current block?

[11:38] *** JJMerelo left
[11:42] <codesections> SmokeMachine: I assume CALLER doesn't do what you want, because you want the actual _block_ and not a way to look up symbols in that block?

[11:46] <SmokeMachine> codesections: it would be... but it doesn't seem to work inside a Proxy's fetch block... :(

[11:48] *** hungryd22 joined
[11:50] <SmokeMachine> I was trying to do something like this to make rerun every block where the variable was used when it changes it value:

[11:50] <SmokeMachine> m: my %blocks is SetHash; my $a := Proxy.new: FETCH => sub fetch(|) { say CALLER; %blocks{CALLER} = True; 42 }, STORE => -> $, | { .() for %blocks.keys }; sub bla { say $a }; bla; $a = 13

[11:50] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´(CALLER)‚ê§Cannot invoke this object (REPR: Uninstantiable; CALLER)‚ê§  in block  at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§(CALLER)‚ê§(CALLER)‚ê§(CALLER)‚ê§(CALLER)‚ê§(CALLER)‚ê§(CALLER)‚ê§42‚ê§¬ª

[11:54] *** hungryd22 left
[11:54] *** hungrydonkey joined
[12:01] <Geth> ¬¶ doc/default-0: 421864a707 | (Stoned Elipot)++ | doc/Type/Baggy.pod6

[12:01] <Geth> ¬¶ doc/default-0: Current and explicit Baggy.default signature

[12:01] <Geth> ¬¶ doc/default-0: review: https://github.com/Raku/doc/commit/421864a707

[12:01] <Geth> ¬¶ doc: stoned++ created pull request #3565: Current and explicit Baggy.default signature

[12:01] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/pull/3565

[12:12] *** aborazmeh left
[12:25] <kawaii> Is there a clean way of removing a value from an @array if what we try to `push` already exists?

[12:27] <andinus> why push if it already exists?

[12:27] <moritz> you mean, moving an element to the end?

[12:27] *** lichtkind joined
[12:28] <kawaii> andinus: because the $end-user doesn't know if it exists or not :) but you're saying I should check first before pushing in my code?

[12:28] *** Maylay joined
[12:28] <kawaii> I was just wondering if there was some built-in logic 

[12:28] <moritz> kawaii: does the order of elements matter?

[12:28] <kawaii> nope

[12:29] <moritz> then maybe a Set is the better data structure

[12:29] <moritz> because there adding an element that's already in there is a no-op

[12:29] <kawaii> I was thinking Hash

[12:30] <moritz> and checking if an element is in a set is fast, compared to an array

[12:30] <moritz> kawaii: a Set is basically Hash without values

[12:30] <moritz> do you need to store values?

[12:30] <kawaii> I don't, so you're probably right about using a Set

[12:31] <moritz> I use hashes a lot in p5, but python has taught me to take sets seriously :D

[12:31] <lizmat> and then the SetHash variety, if you want a mutable one

[12:32] *** finanalyst left
[12:32] <moritz> lizmat++ good point, forgot that sets are immutable by default

[12:32] <kawaii> ah, yes I need to add and remove from it regularly :)

[12:35] <kawaii> moritz: `my SetHash[Str] $monitored-channels;`, so once I've defined it, how would I `push` a value here? :)

[12:35] <kawaii> It's basically storing just a few hundred strings

[12:36] <kawaii> (but by default will be empty)

[12:36] <moritz> my SetHash[Str] $monitored-channels .= new(); $monitored-channels<stuff> = True;

[12:36] <moritz> https://docs.raku.org/type/SetHash

[12:39] <kawaii> https://www.irccloud.com/pastebin/C0xdswFQ/

[12:39] *** stoned75 left
[12:39] <kawaii> moritz: hey this is really cool :D

[12:39] <kawaii> thanks!

[12:40] <moritz> my pleasure

[12:52] *** sena_kun joined
[12:53] *** skids joined
[12:53] *** Altai-man left
[13:03] <lizmat> kawaiiL it you're using a SetHash, you can also use the .set and .unset methods

[13:04] <lizmat> m: my %sh is SetHash; %sh.set(1,2,3,4); dd %sh; %sh.unset(2,3); dd %sh

[13:04] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Too many positionals passed; expected 2 arguments but got 5‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[13:04] <lizmat> hmmm

[13:04] <kawaii> lizmat: `$monitored-channels{$message.channel-id} = !$monitored-channels{$message.channel-id};` I'm doing it like this to flip between adding and removing based on the user running a command :)

[13:04] *** stoned75 joined
[13:04] <lizmat> m: my %sh is SetHash; %sh.set((1,2,3,4)); dd %sh; %sh.unset((2,3)); dd %sh

[13:04] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´SetHash.new(4,3,1,2)‚ê§SetHash.new(4,1)‚ê§¬ª

[13:04] <lizmat> hmmm... I guess that a. needs documentation, and b. another slurpy candidate

[13:05] <codesections> I have documenting that (and BagHash.add) on my to-do list

[13:06] <lizmat> codesections: could you create an issue for the above problem>

[13:07] <tobs> m: my $b = True; $b .= not; say $b  # kawaii: another way to toggle a boolean without mentioning it twice

[13:07] <lizmat> ?

[13:07] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´False‚ê§¬ª

[13:07] <codesections> lizmat: will do!

[13:07] <lizmat> codesections++

[13:08] <kawaii> tobs: there are too many ways of doing these things, raku has spoiled me :)

[13:09] <codesections> tobs: the only inconsistency there is that $b != $b _looks_ like it should do the same thing, but that means something else entirely :)  

[13:12] *** aborazmeh joined
[13:12] *** aborazmeh left
[13:12] *** aborazmeh joined
[13:12] <tobs> yeah, I guess Raku made a concession to the widespread use of != there.

[13:13] *** gnufr33dom joined
[13:14] <codesections> agreed.  In retrospect (and with the knowledge of how many people will know at least a little JS, with its broken comparitors), I kind of wish we'd gone with `!==`

[13:15] <lizmat> codesections: but you can

[13:15] <lizmat> m: say 42 !=== 666

[13:15] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´True‚ê§¬ª

[13:15] <lizmat> m: say 42 !== 666

[13:15] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´True‚ê§¬ª

[13:16] <lizmat> prefix ! is a meta op in that context

[13:16] <lizmat> so if you want your code to be more readable in that respect, you can

[13:17] <codesections> Ok, fair point.  But I meant that we could have not had `!=` be a comparison operator, which would have freed it up to be the negation operator with assignment 

[13:17] <codesections> to keep the parallelism with .= and other assignment meta ops

[13:19] <jdv79> =! isn't good enough for you;)

[13:21] <codesections> jdv79: ha, I didn't know you could put the whitespace like that!

[13:26] <lizmat> m: sub infix:<!=>(\a,\b) { a = !b }; my $a != True; say $a

[13:26] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´False‚ê§¬ª

[13:27] <codesections> :D

[13:30] <tobs> for the original task we'd want this to be "prefix mutating unary metaop"-lookalike though

[13:30] <tobs> m: sub prefix:<!=>($a is rw) { $a .= not }; my $b = True; say $b; say !=$b; say $b

[13:30] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´True‚ê§False‚ê§False‚ê§¬ª

[13:35] *** lucasb joined
[13:40] <AlexDaniel> lizmat: != and ‚â† are roughly the same in performance, !== is much slower

[13:41] <AlexDaniel> pretty much any uncommon syntax is several times slower

[13:42] <rir> How to "redirect" $*ERR to $some-Str for a bit?

[13:44] <lizmat> AlexDaniel: nothing a "constant &infix:<!==> = &infix:<!=>" wouldn't fix

[13:45] *** oddp left
[13:45] <codesections> AlexDaniel: only "roughly the same"?  I thought they _were_ the same operation

[13:45] <codesections> m: say &infix<!=> === &infix<‚â†>

[13:45] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    infix used at line 1. Did you mean 'index', 'indir'?‚ê§‚ê§¬ª

[13:46] <codesections> m: say &infix:<!=> === &infix:<‚â†>

[13:46] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´True‚ê§¬ª

[13:46] <rir> ^ s/for a bit/for more than one bit/  Ha!

[13:46] <lizmat> codesections: they are the same 

[13:46] <AlexDaniel> lizmat: that's probably true

[13:47] <AlexDaniel> lizmat: IIRC ‚â† required a bit of wiggling to make sure it works right and is fast at the same time, I guess indeed the same can be applied to other ops

[13:48] <lizmat> m: dd &infix:<‚â†>.name   # they're aliased

[13:48] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´"infix:<!=>"‚ê§¬ª

[13:49] <lizmat> so there is *no* runtime overhead

[13:49] <lizmat> m: my $a = 42; for ^1000000 { my $b := $a != 666 }; say now - INIT now

[13:49] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´0.02375516‚ê§¬ª

[13:50] <lizmat> m: constant &infix:<!==> = &infix:<!=>; my $a = 42; for ^1000000 { my $b := $a !== 666 }; say now - INIT now

[13:50] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´0.0409685‚ê§¬ª

[13:50] <lizmat> m: constant &infix:<!==> = &infix:<!=>; my $a = 42; for ^1000000 { my $b := $a !== 666 }; say now - INIT now

[13:50] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´0.0269728‚ê§¬ª

[13:50] <lizmat> m: my $a = 42; for ^1000000 { my $b := $a != 666 }; say now - INIT now

[13:50] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´0.024267‚ê§¬ª

[13:50] <lizmat> m: my $a = 42; for ^1000000 { my $b := $a != 666 }; say now - INIT now

[13:50] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´0.0246294‚ê§¬ª

[13:50] <lizmat> m: constant &infix:<!==> = &infix:<!=>; my $a = 42; for ^1000000 { my $b := $a !== 666 }; say now - INIT now

[13:50] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´0.04128212‚ê§¬ª

[13:50] <AlexDaniel> not enough iterations and possibly too much stuff optimized away

[13:50] <lizmat> yeah,  but anyway, in the same ballpark

[13:56] <codesections> Is `note $msg; exit 1` (or other non-zero number) the preferred way to exit a CLI app when printing an error msg to the end user?  I thought `die $msg` would be better, but it adds `===SORRY!===`, which the end user doesn't really need to see...

[13:56] <lizmat> codesections: that's how I would do it if it was a compile time error and I would want to get rid of the SORRY

[13:57] <codesections> lizmat++

[13:59] <codesections> (someday, I need to understand Raku's notion of "compile time" better.  The error I encountered was based on calling EVALFILE on a file that the user passes in with a CLI flag... and yet that's a compile-time error?  I guess because EVALFILE is "compiling" the file before/as it runs it? 

[13:59] <codesections> )

[14:00] <lizmat> yup

[14:00] <moritz> yes, compile and run time can be nested in each other

[14:00] <moritz> EVAL/EVALFILE nests a compile time inside run time

[14:01] <lizmat> one of the cases of tormenting the implementor  :-)

[14:01] <moritz> and BEGIN (and other constructs) nest in a run time during compile time

[14:02] <tobs> rir: I think you would need to wrap a Str inside an IO::Handle like interface and `temp` assign that to $*ERR. There is a module for that: https://github.com/hoelzro/p6-io-string

[14:02] *** aborazmeh left
[14:02] <codesections> wow.  That's all crazy powerful.  But also makes some things a bit harder to reason about.  I'm used to thinking of "it's done at compile time" as "it's free at runtime".  But I guess that isn't always true with Raku

[14:02] <codesections> (Which might matter as we start doing more compile-time programming with RakuAST)

[14:04] <rir> codesections: Tanstafl.  tobs: Thanks.

[14:04] <codesections> rir: fair

[14:09] <Geth> ¬¶ doc/baggy-bool-eg: 2ce6a8f169 | (Stoned Elipot)++ | doc/Type/Baggy.pod6

[14:09] <Geth> ¬¶ doc/baggy-bool-eg: Fix example output

[14:09] <Geth> ¬¶ doc/baggy-bool-eg: review: https://github.com/Raku/doc/commit/2ce6a8f169

[14:10] <Geth> ¬¶ doc: stoned++ created pull request #3566: Fix example output

[14:10] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/pull/3566

[14:10] *** sarna left
[14:15] *** aborazmeh joined
[14:15] *** aborazmeh left
[14:15] *** aborazmeh joined
[14:16] *** rockxloose left
[14:17] *** mtj_ left
[14:17] *** MilkmanDan joined
[14:18] *** wamba joined
[14:19] *** aborazmeh left
[14:21] <Geth> ¬¶ doc: 2ce6a8f169 | (Stoned Elipot)++ | doc/Type/Baggy.pod6

[14:21] <Geth> ¬¶ doc: Fix example output

[14:21] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/2ce6a8f169

[14:21] <Geth> ¬¶ doc: 44df452c0b | (Will Coleda)++ (committed using GitHub Web editor) | doc/Type/Baggy.pod6

[14:21] <Geth> ¬¶ doc: Merge pull request #3566 from Raku/baggy-bool-eg

[14:21] <Geth> ¬¶ doc: 

[14:21] <Geth> ¬¶ doc: Fix example output

[14:21] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/44df452c0b

[14:21] <linkable6> Link: https://docs.raku.org/type/Baggy

[14:44] *** guifa joined
[14:45] <guifa> Um, wow.  I figured this refactor would be a little bit faster but I wasn‚Äôt expeting it to be THAT much faster

[14:45] <tellable6> 2020-08-18T21:26:41Z #raku <rir> guifa`:  Thanks, I'll look at Comma.  I've been mired in 'too much to learn' and forgot all about it.

[14:45] <guifa> https://bit.ly/31bSRni

[14:46] *** wamba left
[14:46] <guifa> Basically a three order of magnitude speed up.  That should let loading of CLDR data be MUCH faster hopefully

[15:00] *** gnufr33dom left
[15:09] <xinming> m: my $x = "t"; class T { method t { "T v".say } }; (T."$x").raku.say;

[15:09] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Quoted method name requires parenthesized arguments. If you meant to concatenate two strings, use '~'.‚ê§at <tmp>:1‚ê§------> 3ss T { method t { "T v".say } }; (T."$x"7‚èè5).raku.say;‚ê§¬ª

[15:10] <xinming> I know that T."$x"() works fine. Is it possible that in the future, raku can return the code for  T."$x"  kind of syntax?

[15:12] <guifa> I‚Äôve always wondered about that requirement myself

[15:14] <moritz> what do you mean by "return the code for"?

[15:15] <moritz> return the method instead of calling it?

[15:15] <codesections> and, relatedly, why does `T."$x"()` work, but T::("$x") does not?

[15:15] <moritz> T.^lookup($x)

[15:15] <codesections> moritz: I think xinming just meant "restore the functionality to be able to do"

[15:15] <moritz> because methods live in a classes (or roles) method table, not in a scope

[15:16] <moritz> and T::($x) is a lookup in a scope

[15:16] <moritz> codesections: if you want the method object, and not call it, use T.^lookup($x)

[15:17] <moritz> or T.^find_method($x); the two differ a bit when it comes to role and auto punning -- cannot remember which one is better for your use case right now

[15:17] <codesections> yeah, I get all that :).  I've been diving pretty deep into these introspection methods

[15:17] <codesections> I'm saying that there's some special casing to get T."$x"() to work

[15:18] <guifa> moritz: what‚Äôs the logic in requiring () though for calling?  Obviously, normally you just need to do foo.call-method, and not foo.call-method().  It‚Äôs seemed odd to me to require the parentheses for the quoted method, though I‚Äôm sure there‚Äôs a reason

[15:18] <codesections> it has to resolve "$x" into `t`, and then lookup `t` in the T method table

[15:19] <codesections> and it seems like the same special casing could just as easily apply to T::("$x"), and increase consistency by doing so

[15:19] <moritz> guifa: that has to do with producing better error messages for accidentally using . as the concat operator (a common p5ism)

[15:19] <guifa> perlisms strike again lol

[15:19] <xinming> moritz: yes, I do mean return the method object with the specified name.

[15:20] <xinming> hmm, Ignore me, I just realized, that calling method doesn't require the ().

[15:21] <xinming> so, require $obj."$method-name"()  is fine. ;-)

[15:21] <guifa> The recent question on SO about adding a sub infix:¬´>>¬ª keeps reminding me how catering to users from other languages can sometimes prevent fluent Raku users from doing certain things :-)

[15:21] <moritz> on the one hand, I hate that so many p5isms shape current-day raku. OTOH I still use Perl 5 quite a lot, and those error messages often saved my butt

[15:21] * guifa . o O ( although why anyone would really WANT to have a >> infix given how it already pulls at least double duty elsewhere‚Ä¶ )

[15:25] <Geth> ¬¶ doc: 5ff724940a | stoned++ (committed using GitHub Web editor) | doc/Type/Baggy.pod6

[15:25] <Geth> ¬¶ doc: Current and explicit Baggy.default signature (#3565)

[15:25] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/5ff724940a

[15:25] <linkable6> Link: https://docs.raku.org/type/Baggy

[15:25] <guifa> Also, random thought: andthen has basically a perfect precedence level

[15:25] <linkable6> DOC#3565 [closed]: https://github.com/Raku/doc/pull/3565 Current and explicit Baggy.default signature

[15:26] <guifa> looser than commas so I can still use a colon method call, but tighter than postfix if

[15:27] <guifa> m: say ‚Äúa‚Äù, ‚Äúb‚Äù andthen say ‚Äúc‚Äù if True

[15:27] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´ab‚ê§c‚ê§¬ª

[15:28] <guifa> m: say ‚Äúa‚Äù, ‚Äúb‚Äù andthen say ‚Äúc‚Äù if False

[15:28] <camelia> rakudo-moar 2db92e04f: ( no output )

[15:44] *** MilkmanDan left
[15:51] *** MilkmanDan joined
[15:51] *** melezhik joined
[16:01] *** mtj_ joined
[16:20] *** dogbert11 joined
[16:33] *** dakkar left
[16:44] *** gabiruh joined
[16:51] *** Altai-man joined
[16:53] *** sena_kun left
[17:07] <codesections> I mentioned this the other day, but I *really* like that this form works:

[17:08] <codesections> m: say 1 ==> {$_ + 1}()

[17:08] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´1‚ê§¬ª

[17:08] <codesections> m: say: 1 ==> {$_ + 1}()

[17:08] <camelia> rakudo-moar 2db92e04f: ( no output )

[17:09] <codesections> m: ( 1 ==> {$_ + 1}() ).say

[17:09] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´2‚ê§¬ª

[17:10] <Geth> ¬¶ doc/list-eg-output: 7a0b5821fe | (Stoned Elipot)++ | doc/Type/List.pod6

[17:10] <Geth> ¬¶ doc/list-eg-output: Uniformize examples' output

[17:10] <Geth> ¬¶ doc/list-eg-output: 

[17:10] <Geth> ¬¶ doc/list-eg-output: And while here, if we would like an example to produce an output,

[17:10] <Geth> ¬¶ doc/list-eg-output: we might as well call `say` :)

[17:10] <Geth> ¬¶ doc/list-eg-output: review: https://github.com/Raku/doc/commit/7a0b5821fe

[17:10] <Geth> ¬¶ doc: stoned++ created pull request #3568: Uniformize examples' output

[17:10] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/pull/3568

[17:10] <codesections> (grr, getting the output to print correctly there made the syntax less pretty and undermined the point I was making.  Oh well)

[17:19] *** Kaiepi joined
[17:21] <xinming> m: class B { has $.a is rw; }; class T is B { method t () { $.B::a = 5 }; }; my $o = T.new; $o.t.say;

[17:21] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´No such method 'B::a' for invocant of type 'T'‚ê§  in method t at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:21] <xinming> m: class B { has $.a is rw; }; class T is B { method t () { self.B::a = 5 }; }; my $o = T.new; $o.t.say;

[17:21] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´5‚ê§¬ª

[17:21] <xinming> In this case, Should $.B::a work as expected?

[17:22] <xinming> hmm, ignore me, I think I realized, that $.meth is to mean $(self.meth) literally

[17:37] <rypervenche> m: 1 ==> {say $_ + 1}();

[17:37] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´2‚ê§¬ª

[17:37] <rypervenche> codesections: Better? Or not what you wanted?

[17:38] <codesections> Meh, close enough :)  That's technically printing out the sum of $_ + 1 and then returning True from the block, and I was printing out the return value of the block.  But I didn't really care about printing ‚Äì I just like that we can pass args in from the left when it's clearer to do so!

[17:40] *** sftp joined
[17:41] <codesections> wait... it just occurred to me that we can also do 1.&{$_ + 1}

[17:44] <rypervenche> You win.

[17:46] *** stoned75 left
[17:48] <CIAvash> codesections: you can do `==> say()` too

[17:58] *** Guest47135 is now known as aluaces

[18:23] *** finanalyst joined
[18:23] *** bocaneri left
[18:27] *** rindolf left
[18:28] <brass> Hey, is there a way to limit floats to 2 decimal places when printing?

[18:29] <brass> Or I guess it's a Num, not a float 

[18:30] <codesections> m: say '%.2f'.sprintf(20.sqrt)

[18:30] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´4.47‚ê§¬ª

[18:30] <codesections> brass ^^^ 

[18:31] <codesections> docs are here: https://docs.raku.org/language/independent-routines#routine_sprintf

[18:31] <tobs> or 20.sqrt.fmt('%.2f')

[18:31] <brass> Oh awesome, thank you

[18:32] <codesections> tobs: oh, I didn't know about that one.  Any idea why we have two such similar subs?  Just for TIMTOWTDI?

[18:33] <tobs> pretty sure that fmt uses sprintf internally, but one is a method on (format) Strs, the other on Cool

[18:34] <codesections> makes sense

[18:34] <tobs> depends on what is the subject and what the object of that statement in your head, so yes TIMTOWTDI

[18:35] *** rindolf joined
[18:42] *** xelxebar joined
[18:49] *** cpan-raku joined
[18:49] *** cpan-raku left
[18:49] *** cpan-raku joined
[18:53] *** wamba joined
[18:55] *** melezhik left
[19:05] *** guifa` joined
[19:13] *** wamba left
[19:35] <[Coke]> m: dd FatRat.^methods[*-1]

[19:35] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Submethod+{is-hidden-from-backtrace} BUILDALL = Submethod+{is-hidden-from-backtrace}.new‚ê§¬ª

[19:37] <kawaii> Is it allowed to wrap `when` in `if` within switches like this? https://www.irccloud.com/pastebin/jbKPVgPn/

[19:43] <SmokeMachine> is there a way of changing the default class for @, % and $ on a specific class or on a class created by a specific metaclass?

[19:44] <SmokeMachine> I mean on attributes

[19:44] *** melezhik joined
[19:46] <guifa`> kawaii: it appears to work okay

[19:47] <kawaii> guifa`: thanks for testing, not on my raku box :)

[19:48] <guifa`> kawaii If you've gome complex logic though, you can always use given $blah, $something 

[19:48] <guifa`> and then

[19:49] <guifa`> when 1, .not {¬†}; when 2, .not {¬†}, when 3, * {¬†}

[19:57] *** melezhik left
[20:03] <brass> Is it intentional that when I run something like &print.^methods I get completely borked output?

[20:04] <brass> I get a ton of lines mixed in with the methods that just say "implementation detail and has no serviceable parts inside" and it makes the output unreadable 

[20:07] <brass> Like this https://imgur.com/WaI2SZO

[20:11] <brass> Like I can use something like `&print.^methods.grep(!*.gist.contains(" "))' but that seems unnecessary 

[20:12] <lizmat> brass: what are you trying to achieve?

[20:12] <[Coke]> when you dump them methods, you're getting a gist of the methods, not the method names.

[20:12] <brass> I just like checking out the methods on random things out of curiosity 

[20:12] <brass> Ah ok I see

[20:13] <[Coke]> m: &print.^methods>>.name

[20:13] <camelia> rakudo-moar 2db92e04f: ( no output )

[20:13] <tadzik> m:  say &print.^methods¬ª.name

[20:13] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´(<anon> <anon> <anon> gist multi <anon> leave <anon> <anon> <anon> <anon> <anon> <anon> soft <anon> <anon> package <anon> wrap unwrap <anon> <anon> <anon> onlystar raku cando <anon> <anon> <anon> <anon> candidates BUILDALL POSITIONS phasers returns WH‚Ä¶¬ª

[20:13] <[Coke]> m: dd &print.^methods>>.name 

[20:13] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´("<anon>", "leave", "<anon>", "<anon>", "<anon>", "<anon>", "<anon>", "raku", "<anon>", "<anon>", "soft", "<anon>", "cando", "<anon>", "package", "gist", "<anon>", "onlystar", "<anon>", "<anon>", "multi", "<anon>", "<anon>", "<anon>", "<anon>", "wrap"‚Ä¶¬ª

[20:13] <tadzik> ha :)

[20:13] <[Coke]> so that's a little better.

[20:13] * [Coke] shakes his old-man fist in the air.

[20:13] <[Coke]> <-- too slow

[20:14] <brass> Haha

[20:14] * tadzik has the ping advantage

[20:14] <brass> What are the anonymous methods use for?

[20:14] * [Coke] is also theoretically supposed to be paying attention to this presentation

[20:14] <[Coke]> m: dd &print.^methods[0]

[20:14] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´ForeignCode <anon> = The 'ForeignCode' class is a Rakudo-specific‚ê§implementation detail and has no serviceable parts inside‚ê§¬ª

[20:15] <[Coke]> m: dd &print.^methods[2]

[20:15] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´ForeignCode <anon> = The 'ForeignCode' class is a Rakudo-specific‚ê§implementation detail and has no serviceable parts inside‚ê§¬ª

[20:15] <[Coke]> m: dd &print.^methods[3]

[20:15] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Method gist = proto method gist (Mu: |) {*}‚ê§¬ª

[20:15] <[Coke]> m: dd &print.^methods[2].Signature

[20:15] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´No such method 'Signature' for invocant of type 'ForeignCode'.  Did you‚ê§mean 'signature'?‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[20:15] <[Coke]> m: dd &print.^methods[2].signature

[20:15] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´:(|)‚ê§¬ª

[20:15] <tadzik> what a weird smiley face

[20:16] <[Coke]> so you can poke around at the individual methods a bit if you want.

[20:16] <[Coke]> tadzik++

[20:20] *** MasterDuke joined
[20:33] *** Kaiepi left
[20:36] <SmokeMachine> how can I do something like this (but that works)

[20:36] <SmokeMachine> m: class P is Proxy { has $!value; method new { ::?CLASS.bless: FETCH => -> | { $!value }, STORE => -> $value { $!value = $value } } }; my $p := P.new

[20:36] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Cannot invoke this object (REPR: Null; VMNull)‚ê§  in method new at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[20:39] <lizmat> SmokeMachine: fwiw, I haven't been able to subclass Proxy  :-(

[20:40] *** stoned75 joined
[20:40] <SmokeMachine> lizmat: :(

[20:40] <SmokeMachine> I think that's not the first time I do that question...

[20:42] <lizmat> perhaps this is of use: https://gist.github.com/lizmat/4bb3e1d997f9e6a84256d985815a431d

[20:43] <stoned75> hi it seems the independent routine join's first parameter has a default value, how can I trigger its usage ?

[20:43] <stoned75> cf. https://github.com/rakudo/rakudo/blob/master/src/core.c/Any-iterable-methods.pm6#L2146

[20:44] <lizmat> interesting: I don't think you can, and it's there for documentation / introspection only

[20:45] <lizmat> https://gist.github.com/lizmat/4bb3e1d997f9e6a84256d985815a431d   # for SmokeMachine 

[20:45] <stoned75> that's what I thought but I don't get how it is useful

[20:46] <lizmat> it could be considered dead code

[20:46] <stoned75> ok :)

[20:51] <raku-bridge> <primetoxinz> Hello, I'm working a module that is doing some native calls and I have a Pointer[int32] that I'm trying to get the int value out of.  my $p = Pointer[int32].new();  # Native call that assigns the value  say $p.deref;  This causes a segfault. What am I missing? If I say $p I can see the value is visible NativeCall::Types::Pointer[int32]<0x2>

[20:51] *** thundergnat joined
[20:52] *** sena_kun joined
[20:53] <Geth> ¬¶ doc: taboege assigned to codesections Issue Document the .add/.remove BagHash methods and the .set/.unset SetHash methods  https://github.com/Raku/doc/issues/3569

[20:53] <lizmat> m: say join'

[20:53] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> 3say join7‚èè5'‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§   ‚Ä¶¬ª

[20:54] <lizmat> m: say join

[20:54] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´‚ê§¬ª

[20:54] *** Altai-man left
[20:54] <lizmat> stoned75: the reason $sep = '' is in there

[20:54] <lizmat> without it, the above would throw an error

[20:56] <stoned75> so a straigth join a is fancy way to get an empty string ? :)

[20:56] <lizmat> yeah, looks like  :-)

[20:57] <raku-bridge> <primetoxinz> Oh I think I realized part my the problem. I wasn't aware native CPointers don't allocate memory.  how would I do that for an Pointer[int32]?

[20:58] <SmokeMachine> lizmat: but I still need to pass FETCH and STORE, right? :(

[20:58] <thundergnat> This fills me with nearly equal parts pleasure and horror:  https://gist.github.com/thundergnat/76b406a52ed92a3478d008a99b80715a

[20:59] <thundergnat> I'm debating whether that is worth packaging up and releasing as a module.

[20:59] <lizmat> SmokeMachine: don't think so

[20:59] *** rindolf left
[20:59] <lizmat> as long as the Proxy is set up the correct way and returned, it shouldn't matter

[20:59] <SmokeMachine> no, you are right... I haven't removed the !s

[21:01] <lizmat> thundergnat: I seem to recall this is being done for 1,2,4 bit native ints on MoarVM

[21:01] <lizmat> or: work is underway to do that

[21:01] <SmokeMachine> lizmat: but can I use positional inside the FETCH block?

[21:02] <thundergnat> I am somewhat amused that mine will support ANY sized UInt. Want a 23 bit UInt? No problem. :-)

[21:02] <lizmat> SmokeMachine 

[21:02] <lizmat> SmokeMachine: not sure what you mean

[21:03] <lizmat> thundergnat: 1,2,4 native bit support would also imply native arrays with those sizes

[21:03] <MasterDuke> primetoxinz: i haven't used NativeCall, but i'd suggest asking timotimo or nine, they should be able to help

[21:04] <raku-bridge> <primetoxinz> MasterDuke: thanks

[21:07] <SmokeMachine> lizmat: I what to have a attribute on the proxy's child and use it inside the FETCH and STORE blocks

[21:08] <lizmat> what an attribute?  Shouldn't a closed over variable have the same functionality ?

[21:09] <lizmat> *why

[21:09] *** sftp left
[21:09] <SmokeMachine> lizmat: to store the value

[21:11] <SmokeMachine> lizmat: what I'm trying to do is a "Scalar" that does something on FETCHing and on STOREing besides everything Scalar already do

[21:11] <lizmat> SmokeMachine: have you read https://raku-advent.blog/2020/08/17/rfc-159-by-nathan-wiger-true-polymorphic-objects/ ?

[21:12] <lizmat> in the "proxier" sub, the $value parameter is closed over and acts as an attribute, no ?

[21:13] <SmokeMachine> lizmat: you mean storing it on a local var? that makes sense...

[21:13] <lizmat> inside the sub you can as many as you want

[21:13] <lizmat> *the proxier sub

[21:14] <SmokeMachine> lizmat: yes, thank you very much!

[21:16] *** sftp joined
[21:18] <SmokeMachine> lizmat: about that, is there a way to change the default Class for @, % and $ on a class being created by a custom meta class?

[21:18] <SmokeMachine> without need to do `has @.bla is MyNewDefault`

[21:18] <lizmat> actually, I ran into that recently myself

[21:19] <SmokeMachine> lizmat: and have you found a way of doing that?

[21:19] <SmokeMachine> :)

[21:20] <lizmat> m: BEGIN say Array.WHERE; class Array is Array { }; BEGIN say Array.WHERE

[21:20] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´66032432‚ê§139810078667168‚ê§¬ª

[21:20] <lizmat> so that establishes that you *can* subclass Array lexically with same name

[21:21] <SmokeMachine>  m: BEGIN say Array.WHERE; class Array is Array { method what { say "Im not array" } }; BEGIN say Array.WHERE; Array.what

[21:21] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´52253584‚ê§139954543880224‚ê§Im not array‚ê§¬ª

[21:21] <lizmat> m: class Array is Array { method AT-POS($pos) { say "fetching $pos"; nextsame } }; my @a is Array = ^10; say @a[2]

[21:21] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´fetching 2‚ê§2‚ê§¬ª

[21:21] <SmokeMachine> interesting...

[21:21] <lizmat> so, the codegen is *not* looking at what Array means when it is compiling

[21:22] <lizmat> I would consider that a bug, actually

[21:22] <SmokeMachine>  m: BEGIN say Scalar.WHERE; class Scalar is Scalar { method what { say "Im not scalar" } }; BEGIN say Scalar.WHERE; Scalar.what; my $a; $a.VAR.what

[21:22] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´62009056‚ê§No such method 'what' for invocant of type 'Any'.  Did you mean 'flat'?‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§140267424113536‚ê§Im not scalar‚ê§¬ª

[21:24] <SmokeMachine> lizmat: it really seems to be a bug, but that should be a way to change the default, shouldn't it?

[21:24] <lizmat> I would say so, yes, at least lexically

[21:26] <SmokeMachine> lizmat: I was thinking on something like existing a method on the meta class that returns the default, like: sub default-class-for(\type, Positional) { Array }

[21:27] <lizmat> that feels like a lot of action-at-a-distance to me

[21:27] <lizmat> class Array is Array { } would at least only be active in the scope where the "subclass" exists

[21:27] <SmokeMachine> lizmat: that way I could implement a meta class that would use different defaults than ClassHOW

[21:28] <lizmat> sure...  :-) 

[21:29] <SmokeMachine> that way it would affect only the types created by that meta class... but if you are using that new keyword for using that meta class, you want the new default

[21:29] <SmokeMachine> lizmat: why would be that action-at-a-distance?

[21:29] <SmokeMachine> isn't the meta class responsible to define everything about the new type?

[21:30] <lizmat> if you're creating a new meta-class, that's ok

[21:30] <lizmat> I was referring to adding that default-class-for( to the current meta-class

[21:30] <SmokeMachine> lizmat: yes, that's my intention

[21:30] <tony-o> m: say Version.new("1.2.1") cmp Version.new("1.2.1Œ≥")

[21:30] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´More‚ê§¬ª

[21:31] <tellable6> 2020-08-17T22:48:26Z #raku <melezhik> tony-o - here the list of aws related sparrow plugins, including the ones to work with lambdas - http://rakudist.raku.org/hub/search?q=aws

[21:31] <tellable6> 2020-08-17T22:52:39Z #raku <melezhik> tony-o some of aws plugins might now work as they were created for old version of Sparrow written in Perl, but these ones (lambda related) should work - http://rakudist.raku.org/hub/search?q=function

[21:31] <tellable6> 2020-08-17T23:05:28Z #raku <melezhik> tony-o - might NOT work

[21:31] <lizmat> and *that* would affect classes outside of the lexical scope where you wet a different default class, would it not ?

[21:31] <SmokeMachine> lizmat: but would be a way of new meta classes use a method to define the defaults and ClassHOW do not implement that?

[21:32] <lizmat> I'm not sure I can parse that line in the way you meant

[21:32] <SmokeMachine> sorry, my english is terrible

[21:33] <lizmat> no pb, please try to explain again :-)

[21:33] <SmokeMachine> I mean, if ClassHOW has a `default-class-for`, every type created by that would use that defaults, right?

[21:35] <lizmat> yes

[21:35] <SmokeMachine> when creating the type, when find an attribute with @, for example, it would run `type.^default-class-for(Positional)` it would return Array and that type would have a new Array attribute

[21:36] <SmokeMachine> the only way of changing the defaults would be creating a new meta class.

[21:36] <lizmat> ah, so you mean that would not be settable ?

[21:36] <lizmat> I got the impression from you that it would be settable

[21:36] <SmokeMachine> yes, read only

[21:36] <SmokeMachine> no...

[21:37] <lizmat> sure, that could work  :-)

[21:37] <SmokeMachine> do you think people would accept something like that?

[21:37] <Geth> ¬¶ doc/list-join: cb606ae8f3 | (Stoned Elipot)++ | doc/Type/List.pod6

[21:37] <Geth> ¬¶ doc/list-join: Rework List.join examples and description

[21:37] <Geth> ¬¶ doc/list-join: 

[21:37] <Geth> ¬¶ doc/list-join: - Remove duplicate note about the optional separator for the method form

[21:37] <Geth> ¬¶ doc/list-join: - It's the subroutine form that is slurpy and flattening

[21:37] <Geth> ¬¶ doc/list-join: - Group related examples

[21:37] <Geth> ¬¶ doc/list-join: - Correct a typo

[21:37] <Geth> ¬¶ doc/list-join: review: https://github.com/Raku/doc/commit/cb606ae8f3

[21:37] <Geth> ¬¶ doc: stoned++ created pull request #3570: Rework List.join examples and description

[21:37] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/pull/3570

[21:38] <lizmat> SmokeMachine: I would give it a good chance  :-)

[21:38] * guifa` just got a drawing tablet at $day-job 

[21:38] <guifa`> Time to make some fancy ¬ª√∂¬´

[21:39] <SmokeMachine> lizmat: so, I think I'll create a new problem solving issue...

[21:39] <lizmat> ++SmokeMachine

[21:40] <Geth> ¬¶ doc: codesections++ created pull request #3571: Overhaul the list-missing-methods.p6 script

[21:40] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/pull/3571

[22:04] *** wamba joined
[22:11] <tony-o> m: say say Version.new("Œ≥") cmp Version.new("0"); say "Œ≥" cmp "0";

[22:11] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Less‚ê§True‚ê§More‚ê§¬ª

[22:11] <tony-o> m: say Version.new("Œ≥") cmp Version.new("0"); say "Œ≥" cmp "0";

[22:11] <camelia> rakudo-moar 2db92e04f: OUTPUT: ¬´Less‚ê§More‚ê§¬ª

[22:17] *** sftp left
[22:25] *** guifa` left
[22:28] *** japhb joined
[22:28] *** sftp joined
[22:30] *** yuplushi joined
[22:31] *** stoned75 left
[22:36] *** squashable6 joined
[22:50] *** sena_kun left
[22:51] *** sena_kun joined
[22:57] *** Sgeo joined
[23:04] *** hungrydonkey left
[23:07] *** guifa` joined
[23:08] *** lichtkind left
[23:25] *** wamba left
[23:37] *** aborazmeh joined
[23:37] *** aborazmeh left
[23:37] *** aborazmeh joined
[23:39] *** MilkmanDan left
[23:39] *** MilkmanDan joined
[23:42] *** aborazmeh left
[23:46] <SmokeMachine> lizmat: https://github.com/Raku/problem-solving/issues/220

[23:48] *** aborazmeh joined
[23:48] *** aborazmeh left
[23:48] *** aborazmeh joined
