[00:00] *** cpan-raku left
[00:00] *** cpan-raku joined
[00:02] <raku-bridge> <DataKinds> ruby -e 'loop { puts "hello"; break }' üòõ

[00:03] *** sena_kun joined
[00:05] *** Altai-man_ left
[00:14] *** quester_temp joined
[00:25] *** flossy left
[00:26] *** flossy_ joined
[00:34] <AlexDaniel> still doesn't hurt to tell that it's valid Raku code too :P

[00:39] *** pecastro joined
[00:44] *** reach_satori left
[00:44] *** reach_satori joined
[00:55] *** quester_temp left
[01:02] <raku-bridge> <DataKinds> could I bother y'all to help me understand what's going on here? https://modules.raku.org/dist/Cro::HTTP::Session::Pg:cpan:JNTHN/lib/Cro/HTTP/Session/Pg.pm6#L66

[01:03] <raku-bridge> <DataKinds> what's Capture? I read the docs and it doesn't feel any clearer

[01:05] <raku-bridge> <DataKinds> ahh I found it https://docs.raku.org/type/Mu#method_Capture

[01:05] <raku-bridge> <DataKinds> that's cute

[01:39] *** lichtkind left
[01:41] *** oddp left
[01:55] *** molaf left
[01:57] *** yuplushi left
[01:58] *** yuplushi joined
[02:02] *** Altai-man_ joined
[02:05] *** sena_kun left
[02:07] *** molaf joined
[02:16] *** schlaftier left
[02:30] *** schlaftier joined
[02:34] *** Zero_Dogg left
[02:35] *** Cabanossi left
[02:39] *** pecastro left
[02:43] *** xinming left
[02:44] *** xinming joined
[02:46] *** Zero_Dogg joined
[02:46] *** Cabanossi joined
[02:48] *** vike left
[02:55] *** softmoth left
[02:55] *** hungryd48 joined
[02:56] *** vike joined
[02:58] <rypervenche> Is it possible for a map block to know if the variable it is working on is the last element of the list?

[02:59] *** hungrydonkey left
[03:55] <raku-bridge> <DataKinds> rypervenche: does the LAST phaser work?

[03:56] <rypervenche> Oh, I just figured out a much better way to do what I'm trying to do.

[03:59] *** evalable6 left
[03:59] *** linkable6 left
[03:59] <vrurg> weekly: https://vrurg.github.io/arfb.html

[03:59] <notable6> vrurg, Noted! (weekly)

[04:01] *** linkable6 joined
[04:01] *** evalable6 joined
[04:03] *** sena_kun joined
[04:05] *** Altai-man_ left
[04:11] *** xinming left
[04:12] *** xinming joined
[04:27] *** hungryd48 left
[04:28] *** OpenZen left
[04:34] *** JRaspass left
[04:43] *** orinthe left
[04:43] *** orinthe joined
[04:46] *** sivoais left
[04:49] *** xinming left
[04:50] *** xinming joined
[04:50] *** brtastic joined
[04:57] *** sivoais joined
[05:00] *** m_athias left
[05:04] *** molaf left
[05:06] *** zacts joined
[05:14] *** xinming left
[05:18] *** xinming joined
[05:24] *** rindolf joined
[05:25] *** rindolf left
[05:49] *** wamba joined
[05:51] *** Cabanossi left
[05:54] *** notandinus left
[05:58] *** andinus joined
[06:01] *** zacts left
[06:02] *** Altai-man_ joined
[06:02] *** Cabanossi joined
[06:04] *** sena_kun left
[06:12] *** JRaspass joined
[06:32] *** brtastic left
[06:40] *** dolmen joined
[06:41] *** rindolf joined
[06:41] *** dolmen left
[06:43] *** flossy_ left
[06:50] *** sarna joined
[06:53] *** JRaspass left
[06:58] *** aluaces joined
[06:58] *** aluaces is now known as alberto

[06:58] *** alberto is now known as Guest17178

[07:09] *** dolmen joined
[07:31] *** dakkar joined
[07:43] *** leont joined
[07:49] *** xinming left
[07:53] *** xinming joined
[07:54] *** Cabanossi left
[08:03] *** sena_kun joined
[08:04] *** aborazmeh joined
[08:04] *** aborazmeh left
[08:04] *** aborazmeh joined
[08:04] *** Altai-man_ left
[08:22] *** pecastro joined
[08:29] *** stoned75 joined
[08:30] *** wamba left
[08:42] *** xinming left
[08:44] *** xinming joined
[09:02] *** sarna76 joined
[09:03] *** sarna left
[09:03] *** sarna76 left
[09:03] *** sarna joined
[09:05] *** synthmeat left
[09:08] *** synthmeat joined
[09:09] *** synthmeat left
[09:12] *** antoniogamiz joined
[09:12] *** synthmeat joined
[09:12] <antoniogamiz> o/

[09:13] <antoniogamiz> is there a module to make end to end testing in web pages?

[09:15] *** aborazmeh left
[09:23] *** wamba joined
[09:24] *** vike left
[09:26] *** flossy joined
[09:31] *** vike joined
[09:33] *** Guest17178 is now known as aluaces

[09:33] *** eseyman left
[09:34] *** oddp joined
[09:38] *** eseyman joined
[09:43] <samebchase-> What's the best way to pipe the output of program into a Raku script for further processing? Want to use it in a shell pipeline

[09:43] <antoniogamiz> >?

[09:45] *** stoned75 left
[09:45] <antoniogamiz> samebchase-, idk if this can help you: https://stackoverflow.com/a/4643808/8849071

[09:46] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2020/07/06/unrecursing/

[09:46] <samebchase-> I have been able to call external programs from Raku using `qqx`, but I want to do something like: "cat file | ./script.raku"

[09:46] <gfldex> samebchase-: I'm actually working on the best way right now. May take another few weeks.

[09:46] *** stoned75 joined
[09:46] <samebchase-> gfldex: yes, I liked that blog post!

[09:46] <samebchase-> What variable should I use in Raku to refer to the piped in data?

[09:47] <gfldex> samebchase-: https://docs.raku.org/language/variables#index-entry-$*ARGFILES

[09:47] <antoniogamiz> samebchase-, maybe https://docs.raku.org/type/IO::Pipe

[09:48] <samebchase-> Thanks gfldex, and antoniogamiz for all the help! This is what I need.

[09:48] <antoniogamiz> though ARGGILES is better I think

[09:49] <gfldex> samebchase-: there is also https://docs.raku.org/type/IO::Handle#routine_lines

[09:50] <sjn> o/

[09:50] *** Black_Ribbon left
[09:51] <samebchase-> gfldex: Can I use $*IN directly? 

[09:51] <sjn> I seem to remember there once was a list of "low-hanging fruit" tasks somewhere. Does anyone here remember if this still exists somewhere, of if I remember wrong? :-)

[09:51] <gfldex> samebchase-: yes

[09:51] <gfldex> raku: .say for lines;

[09:51] <evalable6> gfldex, rakudo-moar f550c9f97: OUTPUT: ¬´‚ô•ü¶ã Ííõ„é≤‚Çä‚º¶üÇ¥‚ßø‚åü‚ìú‚âπ‚Ñª‚ÄÖ‚Ä¶¬ª

[09:51] <evalable6> gfldex, Full output: https://gist.github.com/6a29eb382ab6c7b7a5b4f065d425b704

[09:53] *** flossy left
[09:56] <samebchase-> awesome, `lines` is doing the trick!

[09:57] <AlexDaniel> sjn: depends on what you want to work on

[09:57] <AlexDaniel> sjn: if you want to work on rakudo, then maybe try this: https://github.com/rakudo/rakudo/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22easy+to+resolve%22

[10:02] *** Altai-man_ joined
[10:05] *** sena_kun left
[10:05] <Geth> ¬¶ doc: 56b42ef062 | Antonio++ (committed using GitHub Web editor) | 2 files

[10:05] <Geth> ¬¶ doc: fix: rename doc-generation.json to documentable.json, refs Raku/Documentable#62

[10:05] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/56b42ef062

[10:08] *** rir left
[10:11] *** xinming left
[10:13] *** xinming joined
[10:14] *** MasterDuke left
[10:16] *** sarna left
[10:17] *** veesh left
[10:17] *** veesh joined
[10:19] *** sarna joined
[10:28] <codesections> I suspect the answer to this may just be, "no, it's not possible" and that's fine.  But I figure it's worth a shot: when building a CLI with Raku's built-in arg parser, is there a way to get it to accept options with a space (--length 42) instead of just with an equals (--length=42) ?

[10:29] <antoniogamiz> hum, good question

[10:33] <El_Che> codesections: I wrote a module for that

[10:33] <El_Che> codesections: https://github.com/nxadm/SuperMAIN

[10:34] <El_Che> no extra syntax or semantics

[10:34] <Manifest0> Getopt::Long will also allow to do that

[10:34] <[ptc]> m: say sort(["\c[CHICKEN]", "\c[EGG]"])

[10:34] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´(üêî ü•ö)‚ê§¬ª

[10:34] <codesections> cool, I'll check both of those out.  Thanks

[10:34] <El_Che> have fun

[10:35] <[ptc]> bummer, doesn't appear on my terminal  :-/

[10:35] <codesections> ptc I guess you'll never know

[10:36] <[ptc]> codesections: https://www.babelstone.co.uk/Unicode/whatisit.html shows the result :-)

[10:36] <codesections> :)

[10:37] <[ptc]> python seems to agree with the ordering as well: https://twitter.com/bencbartlett/status/1279522579766587393?s=20

[10:38] <El_Che> codesections: both modules have a very different scopes, I think. Getopt::Long is feature-rich and with semantics and syntax close to the Perl module with the same name. SuperMAIN just enables a few features (named everywhere, spaces between param names and values and auto alias) with changes in your code

[10:38] <El_Che> depending on what you need, one may be more appropiate than the other

[10:41] <codesections> Yeah, I'm looking at the READMEs now.  Looks like SuperMAIN is just what I'm looking for at the moment ‚Äì I like the built in syntax

[10:42] <El_Che> codesections: feel free to ping if something does not work. 

[10:42] <codesections> thanks :)

[10:50] <sjn> AlexDaniel: thanks! I'm actually talking with another person who found that the idea of "easy to resolve" issues (low hanging fruit) was something worth adopting, so he wanted an example of it (thanks for the url! :-))

[10:51] <AlexDaniel> sjn: well, as you can see, most of these tickets are pretty old. Nobody is really marking the tickets actively

[10:52] <antoniogamiz> what is the difference between xt/ and t/?

[10:52] <AlexDaniel> one easy to resolve issue would be to mark tickets easy to resolve :)

[10:53] <AlexDaniel> antoniogamiz: usually xt/ is for tests that you shouldn't normally run. For example, if they take too long to finish, or something like that

[10:53] <AlexDaniel> antoniogamiz: they're still tests and are likely used by the maintainers of the project

[10:54] <AlexDaniel> for example, all tests in whateverable are xt tests: https://github.com/Raku/whateverable/tree/master/xt

[10:54] <AlexDaniel> because I don't think anybody wants the test suite to start up an IRC server, run hundreds of tests per each bot, download all the required builds, etc.

[10:54] <antoniogamiz> oh it makes sense 

[10:54] <antoniogamiz> thanks :)

[10:55] <antoniogamiz>  has anyone made end to end testing for a webpage with raku?

[10:55] <AlexDaniel> I wanna know too

[10:56] <antoniogamiz> well, I gotta go, .tell me if someone appears :D 

[10:56] *** antoniogamiz left
[11:04] <dakkar> El_Che: thank you for writing that module! I just sent you a bug report ‚ò∫

[11:05] *** stoned75 left
[11:07] *** stoned75 joined
[11:10] *** rbt left
[11:10] <El_Che> dakkar: great catch

[11:10] <El_Che> it should be an easy fix, and I'll add the tests

[11:11] *** rbt joined
[11:11] <El_Che> I naively use split and join to eagerly

[11:14] <dakkar> command line option parsing is harder than it looks!

[11:14] <dakkar> (I once sent a bug report to Damian because one of his opt-parsing p5 modules got confused by whitespace!)

[11:26] <El_Che> dakkar: it certainly is

[11:26] <El_Che> dakkar: I try to document the cornercases in my tests

[11:27] <El_Che> dakkar: but we'll find most of them only when enough people use it 

[11:32] *** hungrydonkey joined
[11:34] <codesections> El_Che: I believe I found another corner case for you :)

[11:34] <codesections> (and thanks for the module!)

[11:34] <El_Che> hehe :)

[11:35] <El_Che> I know what to do :)

[11:49] *** hungrydonkey left
[11:49] *** wamba left
[11:50] *** wamba joined
[11:55] *** rindolf left
[12:03] *** sena_kun joined
[12:05] *** Altai-man_ left
[12:55] *** hungrydonkey joined
[13:03] <rypervenche> What's the difference between my Str @array and something like my @array = Array[Str].new; ?

[13:03] <rypervenche> I may have the syntax wrong on that last one.

[13:05] *** titsuki joined
[13:05] <moritz> the first one is a type constraint on the variable @array

[13:05] <moritz> the second one is an initiliazation

[13:06] <moritz> but the second allows you to to write: @array = (1, 2, 3);

[13:06] <moritz> without a type error

[13:06] <moritz> m: my Str @a; @a.push: 'a'; say 'OK'; @a.push(42)

[13:06] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´OK‚ê§Type check failed in assignment to @a; expected Str but got Int (42)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[13:06] <moritz> m: my @a = Array[Str].new; @a.push: 'a'; say 'OK'; @a.push(42)

[13:06] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´OK‚ê§¬ª

[13:07] <moritz> m: my @a := Array[Str].new; @a.push: 'a'; say 'OK'; @a.push(42)

[13:07] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´OK‚ê§Type check failed in assignment to ; expected Str but got Int (42)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[13:07] <moritz> m: my @a := Array[Str].new; @a.push: 'a'; @a := Arry.new();  say 'OK'; @a.push(42)

[13:07] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared name:‚ê§    Arry used at line 1. Did you mean 'array', 'Array'?‚ê§‚ê§¬ª

[13:07] <moritz> m: my @a := Array[Str].new; @a.push: 'a'; @a := Array.new();  say 'OK'; @a.push(42)

[13:07] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´OK‚ê§¬ª

[13:14] *** hungryd10 joined
[13:17] *** hungrydonkey left
[13:25] *** hungrydonkey joined
[13:27] *** hungryd10 left
[13:36] *** hungryd50 joined
[13:37] *** hungrydonkey left
[13:41] *** hungrydonkey joined
[13:42] *** orinthe5 joined
[13:43] *** orinthe left
[13:43] *** orinthe5 is now known as orinthe

[13:44] *** hungryd50 left
[13:45] *** hungryd88 joined
[13:48] *** hungrydonkey left
[13:52] *** hungrydonkey joined
[13:55] *** hungryd88 left
[13:56] *** hungrydonkey left
[13:57] *** hungrydonkey joined
[13:59] *** sarna left
[14:02] *** Altai-man_ joined
[14:05] *** sena_kun left
[14:07] *** hungryd15 joined
[14:10] *** hungryd76 joined
[14:10] *** hungrydonkey left
[14:12] *** hungryd15 left
[14:12] *** hungrydonkey joined
[14:15] *** stux|RC left
[14:15] *** hungryd76 left
[14:16] *** stux|RC joined
[14:18] *** OpenZen joined
[14:23] *** rindolf joined
[14:25] *** skids joined
[14:50] *** angelds joined
[14:51] *** JRaspass joined
[14:56] *** aborazmeh joined
[14:56] *** aborazmeh left
[14:56] *** aborazmeh joined
[14:58] <lizmat> and yet another Rakudo Weekly News hits the Net: https://rakudoweekly.blog/2020/07/06/2020-27-advanced-beginning/

[15:01] *** aborazmeh left
[15:03] *** hungryd38 joined
[15:05] *** hungrydonkey left
[15:05] *** natrys joined
[15:12] *** orinthe left
[15:13] *** angelds left
[15:13] *** orinthe joined
[15:14] *** natrys_ joined
[15:14] *** natrys_ left
[15:18] *** natrys left
[15:28] *** rbt left
[15:28] *** rbt joined
[15:30] <ensamvarg> m: $a = 2;

[15:30] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Variable '$a' is not declared‚ê§at <tmp>:1‚ê§------> 3<BOL>7‚èè5$a = 2;‚ê§¬ª

[15:31] <ensamvarg> m: my $a = 2;

[15:31] <camelia> rakudo-moar f550c9f97: ( no output )

[15:31] <ensamvarg> m: my $a = 2; print $a;

[15:31] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´2¬ª

[15:33] <AlexDaniel> m: my $a = 2; say $a¬≤;

[15:33] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´4‚ê§¬ª

[15:33] <AlexDaniel> m: my $a = 2; say $a¬≥¬≤

[15:33] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´4294967296‚ê§¬ª

[15:33] *** molaf joined
[15:35] <ensamvarg> m: my $a = 2; say ¬º$a;

[15:35] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> 3my $a = 2; say ¬º7‚èè5$a;‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚ê§        statement mod‚Ä¶¬ª

[15:35] <ensamvarg> m: my $a = 2; say $a¬º;

[15:35] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Bogus postfix‚ê§at <tmp>:1‚ê§------> 3my $a = 2; say $a7‚èè5¬º;‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚Ä¶¬ª

[15:37] <AlexDaniel> ensamvarg: hmm what do you want to happen?

[15:38] <AlexDaniel> ensamvarg: maybe try with a √ó (or *) sign?

[15:38] <AlexDaniel> m: my $a = 2; say $a √ó ¬º;

[15:38] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´0.5‚ê§¬ª

[15:38] <AlexDaniel> m: my $a = 2; say $a * ¬º;

[15:38] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´0.5‚ê§¬ª

[15:40] <ensamvarg> AlexDaniel: Thank you, AlexDaniel.

[15:41] <ensamvarg> m: my $a = 2; say $a * ¬º;

[15:41] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´0.5‚ê§¬ª

[15:42] <codesections> I have a question about the semantics of Raku lists.  Here's what is confusing me:

[15:42] <codesections> sub show-capture(|c) { say "list: {c.list}"; say "hash: {c.hash}"}

[15:43] <codesections> m: sub show-capture(|c) { say "list: {c.list}"; say "hash: {c.hash}"}

[15:43] <camelia> rakudo-moar f550c9f97: ( no output )

[15:43] <codesections> m: show-capture(:foo)

[15:43] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    show-capture used at line 1‚ê§‚ê§¬ª

[15:43] <AlexDaniel> m: sub show-capture(|c) { say "list: {c.list}"; say "hash: {c.hash}"}; show-capture(:foo)

[15:43] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´list: ‚ê§hash: foo        True‚ê§¬ª

[15:43] <codesections> thanks

[15:44] <AlexDaniel> codesections: that's just how Captures work

[15:44] <codesections> m: sub show-capture(|c) { say "list: {c.list}"; say "hash: {c.hash}"}; show-capture(do if True {:foo} ) 

[15:44] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´list: foo       True‚ê§hash: ‚ê§¬ª

[15:45] <AlexDaniel> m: sub show-capture(|c) { say "list: {c.list}"; say "hash: {c.hash}"}; show-capture(|do if True {:foo} ) 

[15:45] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´list: ‚ê§hash: foo        True‚ê§¬ª

[15:45] *** brtastic joined
[15:45] <codesections> yeah.  That's the bit that I'm not following.  Why is the slip operator needed?

[15:45] <AlexDaniel> m: sub show-capture(|c) { say "list: {c.list}"; say "hash: {c.hash}"}; my $pair = :foo; show-capture($pair)

[15:45] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´list: foo       True‚ê§hash: ‚ê§¬ª

[15:45] <AlexDaniel> m: sub show-capture(|c) { say "list: {c.list}"; say "hash: {c.hash}"}; my $pair = :foo; show-capture(|$pair)

[15:45] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´list: ‚ê§hash: foo        True‚ê§¬ª

[15:45] <AlexDaniel> codesections: it's like this ‚Üë

[15:46] <codesections> So, does `do` create a pair?

[15:46] <AlexDaniel> if you pass an object as an argument it just takes it as a positional argument

[15:46] <AlexDaniel> codesections: no, `:foo` is a pair

[15:47] <codesections> oh, right.  `:foo` is already a pair, but is being destructured when passed in literally!

[15:47] <AlexDaniel> yeah

[15:47] <codesections> Ok, thanks.  That was tripping me up for quite a while.

[15:47] <codesections> A little more magic than I was expecting, but I get it now

[15:48] <AlexDaniel> codesections: actually it's hard to make it work any other way

[15:48] <AlexDaniel> codesections: otherwise you won't have any predictability as to whether an argument ends up being positional or named

[15:48] <AlexDaniel> for example

[15:48] <AlexDaniel> foo($bar) ‚Äì what does it do?

[15:49] <AlexDaniel> right now it's simple, it's passing $bar as a positional arg, that's very clear

[15:49] <AlexDaniel> if it slipped pairs and hashes automatically the answer would've been ‚Äúnobody knows, we have to figure out what $bar is first‚Äù

[15:49] <codesections> Yeah.  I mean, the language could just *not* destructure a literal `:foo` (and make everyone type `|:foo` every time).  That would be the more explicit/less magic way, but would also be really annoying.

[15:50] <codesections> but yeah, I agree it couldn't slip pairs and hashes automatically ‚Äì all it could do is *not* slip them when passed literally 

[15:50] <AlexDaniel> you have an interesting point

[15:51] <AlexDaniel> codesections: wanna have a heart attack?

[15:52] <codesections> sure

[15:52] <AlexDaniel> m: sub foo(:$bar) { say ‚Äúbar is $bar‚Äù }; foo():42bar

[15:52] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´bar is 42‚ê§¬ª

[15:52] <AlexDaniel> m: sub foo(:$bar) { say ‚Äúbar is $bar‚Äù }; foo:42bar

[15:52] <camelia> rakudo-moar f550c9f97: OUTPUT: ¬´bar is 42‚ê§¬ª

[15:52] <AlexDaniel> jnthn: ‚Üë I wonder if this would surprise you :)

[15:53] <lizmat> m: foo:42bar; sub foo(:$bar) { say ‚Äúbar is $bar‚Äù }

[15:53] <camelia> rakudo-moar a4b982cde: OUTPUT: ¬´bar is 42‚ê§¬ª

[15:53] <AlexDaniel> you can also do this if you want:

[15:53] <lizmat> now, *that* surprises me

[15:53] <AlexDaniel> m: sub foo(:$bar, :$baz) { say ‚Äúbar is $bar, $baz‚Äù }; foo:42bar:43baz

[15:53] <camelia> rakudo-moar a4b982cde: OUTPUT: ¬´bar is 42, 43‚ê§¬ª

[15:54] <lizmat> AlexDaniel I'm pretty sure that's all intentional

[15:54] <AlexDaniel> lizmat: almost everything in Raku is intentional

[15:54] <AlexDaniel> but I still have to pick up my jaw from the floor every time :P

[15:55] <lizmat> nah, most of it just naturally falls out of its foundation  :-)

[15:55] <codesections> Yeah, AlexDaniel's examples don't surprise me ‚Äì but probably because I just saw that syntax in the docs when I was trying to figure my issue out 

[15:55] <lizmat> AlexDaniel: it's the same mechanism that allows s:i:g/foo/bar/

[15:56] <AlexDaniel> lizmat: I wouldn't call it same, I don't think it always worked

[15:56] <AlexDaniel> 6c: sub foo(:$bar, :$baz) { say ‚Äúbar is $bar, $baz‚Äù }; foo:42bar:43baz

[15:56] <committable6> AlexDaniel, Sorry kid, that's not my department.

[15:56] <AlexDaniel> uhh poor bot

[15:58] <AlexDaniel> oh I think I know

[16:00] <AlexDaniel> actually, no, I don't‚Ä¶ given that it was unable to gist the error it's probably a precomp bug again :(

[16:00] <AlexDaniel> bisectable6: sub foo(:$bar, :$baz) { say ‚Äúbar is $bar, $baz‚Äù }; foo:42bar:43baz

[16:00] <bisectable6> AlexDaniel, Will bisect the whole range automagically because no endpoints were provided, hang tight

[16:00] <bisectable6> AlexDaniel, Sorry kid, that's not my department.

[16:00] <AlexDaniel> yeaah‚Ä¶

[16:01] <AlexDaniel> bot spam incoming, sry

[16:01] *** bisectable6 left
[16:01] *** quotable6 left
[16:01] *** shareable6 left
[16:01] *** evalable6 left
[16:01] *** squashable6 left
[16:01] *** statisfiable6 left
[16:01] *** notable6 left
[16:01] *** committable6 left
[16:01] *** greppable6 left
[16:01] *** sourceable6 left
[16:01] *** reportable6 left
[16:01] *** tellable6 left
[16:01] *** bloatable6 left
[16:01] *** unicodable6 left
[16:01] *** releasable6 left
[16:01] *** nativecallable6 left
[16:01] *** linkable6 left
[16:01] *** benchable6 left
[16:01] *** coverable6 left
[16:02] <lucs> Wow, that's a lot of bots.

[16:02] *** guifa2 joined
[16:02] <lucs> Is their usage publically documented?

[16:02] <AlexDaniel> lucs: of course: https://github.com/Raku/whateverable/wiki

[16:02] <lucs> Thanks

[16:03] *** sena_kun joined
[16:05] *** Altai-man_ left
[16:10] *** rbt left
[16:11] *** rbt joined
[16:14] <codesections> m: multi p(:$foo, *% where $foo == 0) { 0 }; multi p(:$foo, :$bar) { 47 }; say p(:foo(42), (do if True { :bar }));

[16:14] <camelia> rakudo-moar a4b982cde: OUTPUT: ¬´Cannot resolve caller p(bar => True, :foo(42)); none of these signatures match:‚ê§    (:$foo, *% where { ... })‚ê§    (:$foo, :$bar)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[16:14] <codesections> that was the error message that caused me such trouble

[16:15] <codesections> m: multi p(:$foo, :$bar) { 47 }; say p(:foo(42), (do if True { :bar }));

[16:15] <camelia> rakudo-moar a4b982cde: OUTPUT: ¬´Cannot resolve caller p(Pair:D, :foo(Int)); none of these signatures match:‚ê§    (:$foo, :$bar)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[16:15] <AlexDaniel> lizmat: ‚Üë the error message is wrong here?

[16:15] <codesections> Not the second one -- that one's fine

[16:15] <AlexDaniel> it doesn't show that `bar => True` is a positional

[16:15] <AlexDaniel> yeah, the one before

[16:16] <lizmat> Pair:D, ?

[16:16] <lizmat> that's a positional?

[16:17] <codesections> But the first msg doesn't say `Pair`.  It just has `bar => True`

[16:17] <AlexDaniel> ‚ÄúCannot resolve caller p(bar => True, :foo(42))‚Äù

[16:17] <lizmat> hmmmm

[16:17] <lizmat> maybe make an issue for it, so it won't fall through the cracks ?

[16:18] <AlexDaniel> codesections: please :)

[16:19] <codesections> Will do.  Would this be for the doc repo or the Rakudo repo?

[16:19] *** nativecallable6 joined
[16:19] *** unicodable6 joined
[16:19] <AlexDaniel> codesections: rakudo

[16:19] *** shareable6 joined
[16:19] *** tellable6 joined
[16:19] *** coverable6 joined
[16:19] *** evalable6 joined
[16:20] *** squashable6 joined
[16:20] *** reportable6 joined
[16:20] *** bisectable6 joined
[16:20] *** benchable6 joined
[16:20] <oddp> Thank you for yet another edition of the weekly, liz!

[16:20] *** notable6 joined
[16:20] *** sourceable6 joined
[16:20] <lizmat> oddp: yw

[16:21] *** bloatable6 joined
[16:21] *** committable6 joined
[16:21] <AlexDaniel> bisectable: sub foo(:$bar, :$baz) { say ‚Äúbar is $bar, $baz‚Äù }; foo:42bar:43baz

[16:21] <bisectable6> AlexDaniel, Will bisect the whole range automagically because no endpoints were provided, hang tight

[16:21] *** linkable6 joined
[16:21] <bisectable6> AlexDaniel, Output on all releases: https://gist.github.com/ffc7fbd362d91488c468bfbe3cc88b86

[16:21] <bisectable6> AlexDaniel, Output on all releases and bisected commits: https://gist.github.com/6ef4a5291e3b37936ea63db00ff6e5cd

[16:21] *** greppable6 joined
[16:21] <AlexDaniel> hmmm

[16:21] *** quotable6 joined
[16:21] *** statisfiable6 joined
[16:22] *** releasable6 joined
[16:22] *** brtastic left
[16:22] <AlexDaniel> I think I ran out of space but actually didn't

[16:22] <AlexDaniel> it's weird

[16:22] <guifa2> lizmat: I was looking at making LanguageTag a value type because it seems a natural fit.  But do you think it would be necessary for it to be inmutable for that to work realstically?

[16:23] <lizmat> yes, it should be immutable, that's really the definition of a value type  :-)

[16:24] <guifa2> *sigh* I kind of figured.  Arg, I really liked the beauty of being able to say "$langtag.language = $foo" to edit the language, but maybe it wouldn't be terrible for it to be immutable especially if I have a robust clone method

[16:29] *** softmoth joined
[16:41] <gfldex> AlexDaniel: I can help you with your imagined space problem. My next blogpost will explain. :->

[16:47] *** dakkar left
[16:49] *** patrickb joined
[17:00] *** aindilis left
[17:01] <rypervenche> guifa2: I saw your talk recently. Very cool to see the progress that you've made with Intl-CLDR :)

[17:01] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2020/07/06/spinning-up-sort/

[17:02] *** natrys joined
[17:03] <guifa2> rypervenche: thanks! it's been slow but steady progress, but I'm hopeful by this time next year it'll be really powerful

[17:04] *** aindilis joined
[17:11] *** nightfrog left
[17:11] *** tejr left
[17:16] *** tejr joined
[17:17] <AlexDaniel> gfldex: I ran out of inodes!

[17:18] <gfldex> Sorry, cant help you with that first world probem. :->

[17:19] <AlexDaniel> okay back to 60% inode use‚Ä¶

[17:23] *** tejr left
[17:26] <lizmat> afk for a few hours&

[17:30] *** tejr joined
[17:33] *** titsuki left
[17:33] *** wamba left
[17:34] *** dolmen left
[17:35] *** dolmen joined
[17:42] *** brtastic joined
[17:45] *** hungryd38 left
[17:49] *** aindilis left
[18:02] *** Altai-man_ joined
[18:02] <gfldex> AlexDaniel: If you run out of inodes again, you might give btrfs a try. It got a limit of 2^64 inodes.

[18:05] *** sena_kun left
[18:05] <El_Che> use ZFS? dynamic all the way

[18:06] <El_Che> https://docs.oracle.com/cd/E19253-01/819-5461/6n7ht6qr5/index.html#6n7ht6qtm

[18:08] *** aindilis joined
[18:13] *** aindilis left
[18:20] *** Sauvin left
[18:24] *** hungrydonkey joined
[18:25] *** softmoth left
[18:29] <guifa2> (jnthn | sena_kun)++ on a minor detail I just noticed with Comma.  When you open a project for the first time, it defaults to the README.md (yet another reason for a fancy banner image ha, my module had teh pwetty‚Ñ¢ in Comma)

[18:29] *** m_athias joined
[18:34] *** aindilis joined
[18:37] <Zero_Dogg> Does a rakumod file automatically create its own private namespace? Ie. when I "use" something above the "unit class" line, what kind of namespace is that actually being declared in?

[18:38] <rypervenche> When trying to use raku from the command line to grep out some things from stdin, I'm unable to add a :g to my regex. Curious what I might be doing wrong.

[18:39] <rypervenche> | raku -e 'say $*IN.lines ~~ /\" (<-["]>+ mp3) \"/'; This grabs one instance, but if I add :g before the / it gives; Unexpected closing bracket at -e:1 ------> say $*IN.lines ~~ :g/\" (<-["‚èè]>+ mp3) \"/

[18:41] <guifa2> Zero_Dogg: so by default, if the rakumod is declared as a package of some sort, then the namespace will be whatever that package is called.

[18:42] <guifa2> But if the package exports things, they will end up in the current name space

[18:42] <guifa2> (that's a fairly simplistic overview but hopefully it helps)

[18:42] <Zero_Dogg> guifa2: okay, so even if that use statement is before the actual unit declaration, it's actually imported into that namespace then

[18:43] <Zero_Dogg> guifa2: nod, just trying to wrap my head around it :)

[18:45] <guifa2> If you've got a specific example, I'm happy to take a look at it.  

[18:47] *** molaf left
[18:48] <Zero_Dogg> not really, I'm doing something rather basic. just "use App::Base;" followed by "unit class App::Backend::Foo is App::Base;"

[18:57] <guifa2> ah, well in that case you don't actually need to use the use statement

[18:57] <Zero_Dogg> I don't?

[18:58] <Zero_Dogg> It implicitly does it?

[18:59] *** xinming left
[18:59] *** xinming joined
[19:04] *** wamba joined
[19:06] <AlexDaniel> gfldex: no no‚Ä¶ no‚Ä¶

[19:06] <AlexDaniel> gfldex: already gave it a try and regretted so many times that I didn't use something as stable as ext4

[19:06] *** brtastic left
[19:07] <gfldex> you need a fairly recent kernel. Or at least used to. The fairly recent kernel back then are not not so recent anymore.

[19:08] <AlexDaniel> last time I had issues was like half a year ago

[19:08] <AlexDaniel> I'm using debian unstable so the kernel is as recent as it can be

[19:08] <gfldex> well ‚Ä¶

[19:09] <guifa2> Zero_Dogg: actually, I may have spoken too soon, as I'm testing out the structure you're using.  You may need to have a "use Foo::Bar" after all

[19:10] *** MasterDuke joined
[19:10] <gfldex> AlexDaniel: Linux 5.4.0-4-amd64 GNU/Linux that is Debian/unstable. Mainline is at 5.7.7.

[19:10] <AlexDaniel> gfldex: then how can I have 5.7.0

[19:11] <gfldex> not without pain :)

[19:11] <Zero_Dogg> guifa2: oh well, what I have now works, I just want to make sure I understand why correctly :)

[19:12] <guifa2> Zero_Dogg: I've always found the module loading / symbol export a bit confusing.  One of these days I should probably investigate it much further and write up a guide (in the typical "learn by teaching" methodology haha)

[19:12] <AlexDaniel> gfldex: are you sure? https://packages.debian.org/sid/linux-image-amd64

[19:12] <Zero_Dogg> guifa2: haha, looking forward to it :P

[19:14] <gfldex> AlexDaniel: oh, that one is quite new. I don't fancy booting my machine tho. I didn't have problems with btrfs because I'm cheating. I use bcache with an ssd to make sure that metadata is always on some permanent storage.

[19:14] <AlexDaniel> hmm

[19:14] <AlexDaniel> gfldex: my last issue was that I was trying to figure out why it is so slow, so I tried to run the rebalance operation on the metadata

[19:14] <gfldex> Also I use a mirror for metadata and data. That way scrubbing can actually help

[19:14] <AlexDaniel> and it segfaulted‚Ä¶

[19:15] <gfldex> ouch

[19:15] <AlexDaniel> so, basically I asked the filesystem to do something and it segfaulted halfway through

[19:15] <AlexDaniel> I was prepared for the worst but folks on #btrfs said ‚Äúah you're probably alright, take a chance and reboot‚Äù

[19:15] <AlexDaniel> and yeah, it was fine

[19:15] <AlexDaniel> but omg‚Ä¶

[19:16] <gfldex> You belly shouldn't feel like that. :)

[19:17] *** Geth left
[19:17] *** Geth joined
[19:18] <ShimmerFairy> rypervenche: You can't put adverbs there, you'd need to type m:g/my regex/ (that is, using the m// form)

[19:18] <gfldex> ShimmerFairy: does the adverb go to ~~ or to say in this case?

[19:18] <AlexDaniel> I started using it initially thinking that I'll be using cow snapshots

[19:18] <rypervenche> ShimmerFairy: Ahh, that changes things. It gives me the output of False now. I suppose I need to reread the regexes page since I'm likely not doing what I really want to be doing.

[19:19] <AlexDaniel> but I just don't, so I'm not sure what's the point of having worse performance‚Ä¶ just for the shininess? :)

[19:20] <gfldex> AlexDaniel: did you have plenty of free RAMs? btrfs likes those. It can slow down quite a bit machines with little RAM.

[19:20] <ShimmerFairy> gfldex: I think it's seen as the RHS of the ~~, and then gets confused by the funny-looking code between the //   (remember, you can do things like   $filehandle ~~ :e  to do the same thing as $filehandle.e)

[19:20] <AlexDaniel> sorry Raku eats all my ram :P

[19:22] <gfldex> No wonder Camelia can grow to a wingspan of 10 foot.

[19:24] <ShimmerFairy> To put it another way, I think in that case it's not seen as an adverb in the first place, but as a Pair.

[19:31] *** rbt left
[19:31] *** rindolf left
[19:31] *** rbt joined
[19:34] <Zero_Dogg> aside from using modules and thus getting precompilation, is there anything else I can do to speed up raku compilation overhead? I've split what I can into modules, what's left is basically a MAIN and USAGE, but it's still taking over 1 second to display --help or --version

[19:35] <El_Che> Zero_Dogg: normally, just the first time

[19:36] <Zero_Dogg> El_Che: This is subsequent runs, so two "app --help" after each other each take 1s+

[19:37] <El_Che> that looks problematic indeed. Is the filesystem read-only?

[19:38] <Zero_Dogg> nope, and it has built a load of stuff in lib/.precomp

[19:39] <El_Che> maybe someone with more knowlegde of precom will have an idea. nine? lizmat?

[19:39] <lizmat> does the module have "no precompilation" in it?

[19:39] <Zero_Dogg> stubbing out MAIN and removing the import of modules reduces it to 0.7s, which is fairly long for an essentially empty script

[19:40] <Zero_Dogg> nope. I think module precomp is working as intended, actually

[19:40] <lizmat> does --profile give any hints?

[19:43] <rypervenche> How can I get this to match both a1.mp3 and b1.mp3?; echo 'blah:"a1.mp3", then:"b1.mp3", end' | raku -e 'say $*IN.lines ~~ m:i/ <?after \: \"> <-[":]>+ \. mp3 <?before \">/;'

[19:43] <rypervenche> Using m:i:g/ doesn't give what I would expect.

[19:43] <Zero_Dogg> lizmat: can't say it's telling me much, no. It's not spending that time in *my* code, it's in the interpreter/vm

[19:44] <lizmat> hmmm

[19:45] <El_Che> Zero_Dogg: recent rakudo?

[19:46] <Zero_Dogg> This might be expected, I'm just trying to figure out if I can somehow optimize it, since it's very noticeable with command-line apps. My perl apps use 0,06s for --help, while my raku app uses 1,25s

[19:46] <Zero_Dogg> El_Che: 2020.02

[19:46] *** cpan-raku left
[19:46] <AlexDaniel> rypervenche: but this does work:  raku -e 'say $*IN.slurp ~~ m:i:g/ <?after \: \"> <-[":]>+ \. mp3 <?before \">/;

[19:46] <El_Che> 1,25 is noticeable and thus annoying, indeed

[19:47] *** cpan-raku joined
[19:47] *** cpan-raku left
[19:47] *** cpan-raku joined
[19:47] <AlexDaniel> Zero_Dogg: on which architecture is that?

[19:47] <Zero_Dogg> AlexDaniel: x86-64

[19:48] <rypervenche> AlexDaniel: Ahh I wasn't sure if .lines was the right tool for the job. That does the trick. Thanks!

[19:48] <AlexDaniel> could it be that there's too much stuff in the precomp folders?

[19:49] <AlexDaniel> rypervenche: well, your input has only one line‚Ä¶

[19:49] *** rindolf joined
[19:49] <AlexDaniel> rypervenche: so $*IN.lines[0] ~~ also works

[19:50] <rypervenche> AlexDaniel: I'm doing a curl from a website, but I did the echo as a test. but still. I didn't care about going through each line. I needed it to run across the entirety of the data. slurp works perfectly :)

[19:50] <Zero_Dogg> AlexDaniel: maybe? I tried stubbing out almost everything (including imports) but it's still slow. "raku -e 'say "Hello"'" is fast though, so I'm a bit confused. I'm using MAIN and USAGE subs

[19:50] <lizmat> lines.head  # AlexDaniel 

[19:52] <AlexDaniel> lizmat: #huffmancodinggonewrong ? :)

[19:52] <guifa2> haha

[19:52] <MasterDuke> Zero_Dogg: try --profile-compile

[19:52] <AlexDaniel> Zero_Dogg: if nothing else works, do try wiping all of your precomp folders and trying again

[19:52] <AlexDaniel> I had this issue once

[19:53] <AlexDaniel> although it's still unclear to me as to why it'd cause slowness

[19:53] <lizmat> lines defaults to $*IN, .head is faster than [0] on a Seq, as it doesn't need to set up caching

[19:54] <AlexDaniel> lizmat: well, that's kinda the point. .[0] is shorter, more readable and just more versatile (e.g. for non-0 indices you need some .skip combination)

[19:54] <lizmat> then by all means, use [0]

[19:55] <lizmat> I thought this was about getting the first line only

[19:55] <AlexDaniel> yeah but it turns seqs into what can be best described as arrays

[19:56] <Zero_Dogg> MasterDuke: That gave me a 12M html file that my browsers are really struggling with :P

[19:56] *** xinming left
[19:56] <Zero_Dogg> Removing precomp's didn't change anything

[19:57] <MasterDuke> that's not normal, so something probably isn't getting precomped

[19:57] <MasterDuke> i'd suggest creating a sql profile and using moarperf to view it

[19:57] *** hungrydonkey left
[19:59] <AlexDaniel> actually, why indexing with [] does some sort of action at a distance at all, instead of just working?

[19:59] <AlexDaniel> for 0..10 { say $seq[$_] } # this can just work without any issues

[19:59] *** xinming joined
[20:00] <AlexDaniel> for everything else it's fair to fail with ‚ÄúYou're iterating your Seq backwards, dum dum!‚Äù

[20:03] *** sena_kun joined
[20:03] <AlexDaniel> that is, this would just work:

[20:03] <AlexDaniel> m: my $s = ‚Äòfoo bar baz‚Äô.words; say $s.head; say $s[2]

[20:03] <camelia> rakudo-moar 939634335: OUTPUT: ¬´foo‚ê§The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[20:03] <AlexDaniel> also, notice how caching behavior just happens not to help you in this case

[20:05] <lizmat> m: m: my $s = ‚Äòfoo bar baz‚Äô.words; say $s[2]; say $s.head;

[20:05] <camelia> rakudo-moar 939634335: OUTPUT: ¬´baz‚ê§foo‚ê§¬ª

[20:05] *** Altai-man_ left
[20:11] *** xinming left
[20:14] *** xinming joined
[20:21] *** molaf joined
[20:23] <Zero_Dogg> MasterDuke: anything in particualr to look for in there?

[20:29] *** kensanata joined
[20:39] <lizmat> https://www.flickr.com/photos/wendyga/50083937343/in/dateposted-public/    # a clear message ?

[20:42] *** rindolf left
[20:43] *** xinming left
[20:46] <[Coke]> ... not really, no. :)

[20:47] *** xinming joined
[20:48] <[Coke]> ... I haven't collected comics in a while... is that the beyonder?

[20:49] *** dolmen left
[20:49] *** wamba left
[20:49] <timotimo> perl7 died so raku could change the world?

[20:50] <timotimo> honestly, i'm not educated about the comics, so i don't know what that character is

[20:50] <timotimo> is it a villain that's as big as a skyscraper?

[20:54] <AlexDaniel> ‚Äúclaimed to be omnipotent being who kidnapped the heroes and villains of the Marvel Universe and had them do battle on another planet called Battleworld‚Äù ‚ÄúThe character later appeared in a more antagonistic role in the 1985 sequel Secret Wars II, in which he took human form, and threatened to destroy the Marvel multiverse.‚Äù

[20:54] <timotimo> thanks AD

[20:55] <AlexDaniel> actually it's the first time I hear about it

[20:56] <AlexDaniel> my point is that it doesn't depict a good image of Raku

[20:56] <timotimo> well, all three of these are kind-of villains, but iron man is framed quite heroic at least on a surface level - only refering to the recent movies, of course

[20:57] <[Coke]> AlexDaniel: if that's even him.

[20:57] <AlexDaniel> there's more than one Beyonder?

[20:59] <timotimo> to infinity, and the beyonder!

[20:59] <[Coke]> I was only guessing that was him in the image.

[20:59] <El_Che> "The Beyonder is an infinite-dimensional,[26] or beyond-dimensional,[2] entity" <-- maybe he want to work on raku arrays

[20:59] <AlexDaniel> xD

[20:59] <AlexDaniel> [Coke]: well, the description says so

[21:00] <[Coke]> AlexDaniel: OH

[21:00] <[Coke]> AlexDaniel: I didn't even see there was a description. And I got it! woo!

[21:01] <AlexDaniel> good for you, but I still don't get it :P

[21:01] <[Coke]> oh, me either. :)

[21:10] <lucs> How can I set environment variables that will be visible to a program that I 'run'?

[21:10] *** rbt left
[21:11] *** rbt joined
[21:11] <AlexDaniel> lucs: run accepts an :env or :ENV (?) named arg

[21:11] <AlexDaniel> lucs: by default it's set to %*ENV I think, so you can change %*ENV directly

[21:12] <AlexDaniel> at least that's how I always understood it

[21:12] <AlexDaniel> lucs: and ‚Äúenv‚Äù vs ‚ÄúENV‚Äù depends on whether you use run or Proc::Async, I think

[21:12] <AlexDaniel> please double check :)

[21:12] <lucs> Ah, I missed that :env (will check).

[21:12] <lucs> Although setting %*ENV<Foo> to whatever appears not to be picked up.

[21:13] <AlexDaniel> that's weird

[21:13] <AlexDaniel> m: %*ENV<foo> = 42; run <perl6 -e>, ‚Äòsay %*ENV<foo>‚Äô

[21:13] <camelia> rakudo-moar 5f423a7e6: OUTPUT: ¬´42‚ê§¬ª

[21:13] <AlexDaniel> lucs: how is that not being picked up?

[21:14] <lucs> Hmm... Like I said, "appears" -- I'm fighting with procmail, so not sure exactly what's going on.

[21:16] <AlexDaniel> lizmat: speaking of at a distance caching of seqs, some core operations cache your seqs without any warning

[21:16] <AlexDaniel> for example

[21:16] <AlexDaniel> ah

[21:16] <AlexDaniel> nevermind

[21:16] <lizmat> ?

[21:16] <lizmat> :-)

[21:16] <AlexDaniel> misread my code :)

[21:17] <lizmat> ah, *phew*

[21:19] <AlexDaniel> lizmat: actually, I was just doing it wrong a bit. Here:

[21:19] <AlexDaniel> m: my $seq = <foo bar baz>.words; say sort $seq; say $seq.head; say $seq

[21:19] <camelia> rakudo-moar 5f423a7e6: OUTPUT: ¬´(bar baz foo)‚ê§foo‚ê§(foo bar baz)‚ê§¬ª

[21:20] <AlexDaniel> so if I sort a Seq with a `sort` sub, then it's cached without any warning

[21:20] <AlexDaniel> buuuut

[21:20] <AlexDaniel> m: my $seq = <foo bar baz>.words; say $seq.sort; say $seq.head; say $seq

[21:20] <camelia> rakudo-moar 5f423a7e6: OUTPUT: ¬´(bar baz foo)‚ê§The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[21:20] <AlexDaniel> but .sort method doesn't cache!

[21:20] <lucs> AlexDaniel: (FWIW, procmail is happy when I do 'procmail foo=42 ...')

[21:20] <timotimo> ooh, fascinating

[21:21] <AlexDaniel> just out of curiousity

[21:21] <AlexDaniel> c: releases my $seq = <foo bar baz>.words; say sort $seq; say $seq.head; say $seq

[21:21] <committable6> AlexDaniel, https://gist.github.com/0a5e532111f89e5c1cda91888fae75a8

[21:21] <AlexDaniel> bisect: old=2017.03 my $seq = <foo bar baz>.words; say sort $seq; say $seq.head; say $seq

[21:21] <bisectable6> AlexDaniel, Bisecting by exit code (old=2017.03 new=5f423a7). Old exit code: 1

[21:22] *** skids left
[21:22] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/0986828e7cc5c93bd6135b26cc3fb14a

[21:22] <bisectable6> AlexDaniel, (2017-05-03) https://github.com/rakudo/rakudo/commit/400f4ec8835c5ce80b59098d73bd79988b03939f

[21:24] <AlexDaniel> R#3781

[21:24] <linkable6> R#3781 [open]: https://github.com/rakudo/rakudo/issues/3781 [regression] Unexpected caching of Seqs

[21:26] <guifa2> Speaking of ENV‚Ä¶for those that work in *nix more often, is a generally acceptable practice to read values at the beginning and assume they're static, leaving it to the user to restart if they change them? 

[21:27] * guifa2 is looking to add in some extra user locale information into UserLanguage, but it's going to get complex enough it'd probably be nicer to just cache it when it's first loaded

[21:27] <AlexDaniel> guifa2: huh? ENV variables don't just propagate when they're changed. Or what are we talking about?

[21:28] <guifa2> AlexDaniel: that's why I ask the question haha, I'm not as familiar as to how that stuff goes but want to model behavior more or less based on that

[21:28] *** aluaces left
[21:28] <AlexDaniel> ‚ÄúBy default, when a process is created, it inherits a duplicate environment of its parent process, except for explicit changes made by the parent when it creates the child‚Äù

[21:29] <AlexDaniel> so your %*ENV won't change no matter what, unless you change it yourself of course

[21:29] <guifa2> AlexDaniel++ so I think it's reasonable for me to have it cached then

[21:30] <guifa2> (on the Mac and Windows, I could actually pick up different results later in runtime because I have to use a different detection method)

[21:31] <AlexDaniel> timotimo: fascinating is an interesting word to describe that. There are clearly no visible boundaries for seq caching which makes it hard to know if your seqs are going to waste memory or not

[21:31] <AlexDaniel> on small scale that's unnoticable, but we're beyond fun one-liner snippets, right?

[21:31] *** kensanata left
[21:32] <guifa2> AlexDaniel: caching is also the most performant, so since the *nix results would never change, makes my decision for UserLanguage easy :-)

[21:32] <AlexDaniel> guifa2: I'm starting to confuse the two conversations x)

[21:33] * guifa2 steps away from the keyboard *simpsons-bush-gif*

[21:33] <AlexDaniel> maybe I should start my own documentation

[21:33] *** natrys left
[21:34] <AlexDaniel> ‚ÄúSeqs are things that sometimes turn into lists. How would you know when they do that? Well, I dunno, just test it, and maybe it'll last for a release or two.‚Äù

[21:35] <lizmat> PositionalBindFailover    # https://docs.raku.org/type/PositionalBindFailover

[21:35] <AlexDaniel> lizmat: did you see the bug report?

[21:37] *** dolmen joined
[21:39] <AlexDaniel> c: 400f4ec8835c^,400f4ec8835c my $seq := ‚Äòfoobar‚Äô.comb; say reverse $seq; say $seq.head; say $seq

[21:40] <committable6> AlexDaniel, https://gist.github.com/9f309c83dd80f60335213e1f92bdd7ec

[21:43] <AlexDaniel> lizmat: and you show me these docs as if I don't understand something

[21:44] <AlexDaniel> the docs barely even describe when sequences are cached

[21:44] <AlexDaniel> for example

[21:44] <AlexDaniel> $seq ~ ‚Äòz‚Äô

[21:44] <AlexDaniel> does it cache or not?

[21:45] <AlexDaniel> can you guess?

[21:45] <oddp> Same thing haunts us over at dlang with ranges and .save. :)

[21:46] <AlexDaniel> well, I propose a very simple answer: no

[21:46] <lizmat> interesting

[21:46] <AlexDaniel> seqs are never cached. That's it. Easy

[21:46] <AlexDaniel> want to cache it? Turn it into a list explicitly

[21:47] <AlexDaniel> OK fine maybe passing a seq as a @ arg can turn it into an array or whatever, I'm fine OK with that

[21:47] <lizmat> fwiw, I would love to drop the PositionalBindFailover dance

[21:47] <lizmat> but the last time I tried it, too much broke

[21:48] *** dolmen left
[21:48] <AlexDaniel> do it, and then we release usable Raku 7

[21:48] <AlexDaniel> lizmat: why did it break? Did you make $seq[$i] work?

[21:49] <lizmat> $seq[$i] implies caching

[21:49] <lizmat> that would just not be allowed if Seq doesn't cache

[21:49] <AlexDaniel> lizmat: no, it implies ‚Äúgive me an element on that index‚Äù

[21:50] <AlexDaniel> which you can absolutely do

[21:50] <AlexDaniel> for 0..10 { say $seq[$_] }

[21:50] <AlexDaniel> no problem

[21:50] <lizmat> because it cached

[21:50] <AlexDaniel> no

[21:50] <lizmat> *caches

[21:50] <AlexDaniel> you can remove caching and make it work

[21:50] <AlexDaniel> say $seq[3]; say $seq[10]; say $seq[15];

[21:50] <AlexDaniel> this can also work

[21:50] <lizmat> but not for 10 ... 0 

[21:50] <AlexDaniel> correct

[21:51] <AlexDaniel> lizmat: in which case you'd get ‚ÄúThe iterator of this Seq is already in use/consumed by another Seq‚Äù or something similar, that's already the current situation

[21:52] <codesections> Coming from different languages, $seq[10] implies constant-ish lookup time to me (because it looks like array access), which wouldn't be the case with that proposed syntax, right?

[21:52] <AlexDaniel> codesections: what if you have a linked list?

[21:52] <lizmat> codesections: whether cached or not, it would need to produce values 0..9

[21:53] <AlexDaniel> codesections: I like your point, I like the idea of thinking about the language in these terms

[21:53] <AlexDaniel> codesections: but in this particular case I don't think O(1) is implied

[21:53] <codesections> Well, I don't know enough about Raku's implementation details to know how it's done around theses parts, but I wouldn't expect something that is accessed with seq[i] to be a linked list

[21:54] <AlexDaniel> or O(1-ish) :)

[21:54] <codesections> I'd expect something like seq.nth(i)

[21:54] <AlexDaniel> codesections: yeah, you can currently do .skip($i).head or something similar

[21:55] <AlexDaniel> it's a lot more painful but it's kinda like that

[21:55] <AlexDaniel> but [] is a perfectly usable syntax IMO, no time constraints implied

[21:55] <codesections> yeah, that's very similar to what I'm used to (Iterators in Rust)

[21:55] <AlexDaniel> codesections: btw lists can be lazy too here, so it's not just Seqs at all

[21:55] <codesections> Fair point

[21:56] <AlexDaniel> but right now you can't use [] unless you're ready for your Seqs to turn into Lists (which is essentially what caching is)

[21:57] <lizmat> AlexDaniel: lazy lists *are* iterators under the hood.  Seq is just a wrapper for an iterator

[21:57] <AlexDaniel> it's weird, basically it was decided that [] implies working random access

[21:58] <AlexDaniel> lizmat: laziness is an interesting term‚Ä¶

[21:58] <AlexDaniel> would be nice to define that too :P

[21:58] <AlexDaniel> and have .is-lazy work :P

[21:59] <lizmat> Looking at how Seq is currently implemented, is that we could actually rather easily *not* cache a Seq if the AT-POS indices were always increasing

[21:59] <timotimo> what if the at-pos indices are lazy? :Œ¥

[22:00] <AlexDaniel> just explode once you stumble upon one

[22:00] <lizmat> right, and what if that contract is broken?  There is no way to get older values

[22:00] <lizmat> AlexDaniel: you'd be amazed how much fails then...

[22:00] <AlexDaniel> lizmat: let's test it? Forget about the spectest, commit it into a branch and let's see what Blin says

[22:01] <lizmat> will look at that tomorrow

[22:01] <AlexDaniel> thanks!

[22:01] <lizmat> I'm not sure Raku will actually build with such a change, so don't get your hopes up too much :-)

[22:01] <AlexDaniel> I do expect a lot of spectest failures, but that's OK because we're redefining the spec with that change

[22:02] <AlexDaniel> lizmat: well, if it doesn't build then the core relies on caching?

[22:02] <lizmat> that would be the implication...

[22:02] *** Altai-man_ joined
[22:02] <lizmat> I sorta half expect it will build, but that installing the core modules *will* fail

[22:05] *** sena_kun left
[22:11] *** xinming left
[22:13] *** xinming joined
[22:25] *** patrickb left
[22:48] *** epony left
[22:57] *** epony joined
[22:59] <AlexDaniel> what's `skip`?

[23:00] <AlexDaniel> sourceable6: <foo bar.words.skip(1)

[23:00] <sourceable6> AlexDaniel, No idea, boss. Can you give me a Code object? Output: https://gist.github.com/4020fa99bab008a4a5d8565f654d8b13

[23:00] <AlexDaniel> sourceable6: <foo bar>.words.skip(1)

[23:00] <sourceable6> AlexDaniel, https://github.com/rakudo/rakudo/blob/a745505/src/core.c/Any-iterable-methods.pm6#L1997

[23:00] <AlexDaniel> so .skip is a constructor for new Seqs?

[23:00] <AlexDaniel> or whatever you wanna call that

[23:01] <AlexDaniel> so every time I want to skip a value, I create a new Seq object?

[23:01] <AlexDaniel> that's honestly a yet another argument for proper implementation of [] on Seqs

[23:02] <codesections> That's the same way `.skip` is implemented in Rust, https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip

[23:02] <AlexDaniel> codesections: but how do they make it fast?

[23:02] <timotimo> rust is probably a bunch better at not creating objects that aren't needed

[23:02] <timotimo> "zero-overhead abstractions" and such

[23:03] <codesections> yeah.  But that's part of the point I'm gesturing at

[23:03] <timotimo> is Seq an Any and doesn't have its own skip method?

[23:03] <timotimo> m: say Seq ~~ Any

[23:03] <camelia> rakudo-moar a74550507: OUTPUT: ¬´True‚ê§¬ª

[23:03] *** dataangel joined
[23:03] <timotimo> m: say Seq.^lookup("skip")

[23:03] <camelia> rakudo-moar a74550507: OUTPUT: ¬´skip‚ê§¬ª

[23:03] <timotimo> m: say Seq.^lookup("skip").raku

[23:03] <camelia> rakudo-moar a74550507: OUTPUT: ¬´proto method skip ($: |) {*}‚ê§¬ª

[23:03] <timotimo> m: say Seq.^lookup("skip").candidates>>.raku

[23:03] <camelia> rakudo-moar a74550507: OUTPUT: ¬´(multi method skip ($: *%_) { #`(Method|66610304) ... } multi method skip ($: Whatever $, *%_) { #`(Method|66610448) ... } multi method skip ($: Callable:D $w, *%_) { #`(Method|66610592) ... } multi method skip ($: $n, *%_) { #`(Method|66610736) ... }‚Ä¶¬ª

[23:04] <timotimo> m: say Seq.^lookup("skip").candidates>>.package>>.raku

[23:04] <camelia> rakudo-moar a74550507: OUTPUT: ¬´(Any Any Any Any)‚ê§¬ª

[23:04] <AlexDaniel> timotimo: sourceable is right

[23:04] <timotimo> mhm

[23:04] <timotimo> quite possibly Seq can just return self after skipping? it's not like seqs can sensibly be cloned?

[23:04] <AlexDaniel> I haven't seen it give a wrong result ever, yet

[23:04] <timotimo> i mean, some can, but not all

[23:04] <AlexDaniel> timotimo: no no you can't return self

[23:04] <codesections> whether the "new object" is created doesn't *need* to be tied to whether there's a performace penalty; it can be an abstraction showing that you've lost access to the previous elements without (literally, in memory) allocating a new object

[23:05] <AlexDaniel> timotimo: because something else can have that same seq too

[23:05] <timotimo> do we guarantee that a Seq is still sane after we called .skip on it?

[23:05] <AlexDaniel> codesections: right. I guess other compilers can do something like that

[23:06] <AlexDaniel> m: my $s = <foo bar baz>.words; my $other = $s.skip(1); say $s

[23:06] <camelia> rakudo-moar a74550507: OUTPUT: ¬´The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[23:06] <AlexDaniel> timotimo: ‚Üë

[23:06] <timotimo> m: my @a = 1, 1, *+* ... *; my $seq := @a.Seq; say $seq.head(1); my $oseq := $seq.skip(1); say $oseq.head(); say $seq.head();

[23:06] <camelia> rakudo-moar a74550507: OUTPUT: ¬´(1)‚ê§The iterator of this Seq is already in use/consumed by another Seq‚ê§(you might solve this by adding .cache on usages of the Seq, or‚ê§by assigning the Seq into an array)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[23:07] <timotimo> ah, so if you return self there, it wouldn't give you that error

[23:07] <AlexDaniel> right, and you will even get a wrong result

[23:07] <timotimo> i imagine the self.iterator does that?

[23:07] <timotimo> i've wanted to skip an iterator forward without going through a whole dance

[23:07] <timotimo> but i guess what i should have done is $seq .= skip(1)

[23:08] <AlexDaniel> or, in Raku 7, just index with []

[23:08] <AlexDaniel> x)

[23:09] <AlexDaniel> btw I don't know about iterators, there's no such thing for users in normal code

[23:09] <AlexDaniel> right?

[23:09] <timotimo> true

[23:10] <timotimo> you can build your own if you want to

[23:10] <timotimo> and you can directly grab an object's iterator

[23:11] <timotimo> and we code-gen some for loops to grab an object's iterator and .pull-one until it gives IterationEnd

[23:11] * AlexDaniel squints

[23:13] <timotimo> hm?

[23:14] <AlexDaniel> timotimo: why is that needed?

[23:15] <AlexDaniel> timotimo: why, for example, Seqs can't be our iterators?

[23:16] <AlexDaniel> conceptually, what's the difference between a Seq and an Iterator?

[23:16] *** oddp left
[23:16] <AlexDaniel> codesections: see, I ask very dumb questions here, please don't mind :)

[23:17] <codesections> :)

[23:18] <timotimo> can you pull one value out of a Seq and then iterate over the rest with a for loop or map or something?

[23:18] <codesections> It is interesting how similar this is to Rust's Iterator.  They have exactly the same semantics, with a `next` in place of `.pull-one`

[23:19] <AlexDaniel> codesections: so they have an Iterator, do they have Seqs?

[23:20] *** pecastro left
[23:20] <AlexDaniel> timotimo: interesting question

[23:20] <AlexDaniel> no, but why not?

[23:21] <AlexDaniel> basically, currently it's guaranteed you have just one consumer of a Seq

[23:21] <codesections> Well Rust's `Iterator` is a Trait (which, despite the name, is more similar to Raku's role if I'm understanding roles-vs-traits correctly in Raku)

[23:21] <timotimo> Seq is there to have a list-like API, so it can be used mostly interchangeably?

[23:21] <timotimo> iterator doesn't have .map, but Seq does

[23:22] <AlexDaniel> well, you can add .map to an iterator‚Ä¶ maybe?

[23:22] <timotimo> all of Any-iterable-methods? :)

[23:22] <AlexDaniel> well, or other way around, make Seqs our iterators

[23:24] <AlexDaniel> it's an interesting design decision

[23:24] <AlexDaniel> I should amend my dumbed down description above, saying that Seqs always have just one consumer

[23:24] <AlexDaniel> ‚Ä¶ unless they're cached‚Ä¶

[23:24] *** Kaiepi left
[23:24] *** nebuchadnezzar left
[23:25] *** Kaiepi joined
[23:25] <AlexDaniel> but it's still guaranteeing that you won't accidentally read just the remaining values out of a seq (because something else read the first ones)

[23:26] *** Kaiepi left
[23:27] <AlexDaniel> codesections: Iterator is also a role

[23:28] *** Kaiepi joined
[23:28] *** Kaiepi left
[23:34] <AlexDaniel> m: my $s = <a b c>.words; say $s.pairs

[23:34] <camelia> rakudo-moar a74550507: OUTPUT: ¬´(0 => a 1 => b 2 => c)‚ê§¬ª

[23:34] <AlexDaniel> m: my $s = <a b c>.words; say pairs $s

[23:34] <camelia> rakudo-moar a74550507: OUTPUT: ¬´(0 => a 1 => b 2 => c)‚ê§¬ª

[23:34] <AlexDaniel> m: my $s = <a b c>.words; say $s.antipairs

[23:34] <camelia> rakudo-moar a74550507: OUTPUT: ¬´(a => 0 b => 1 c => 2)‚ê§¬ª

[23:35] <AlexDaniel> m: my $s = <a b c>.words; say antipairs $s

[23:35] <camelia> rakudo-moar a74550507: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    antipairs used at line 1‚ê§‚ê§¬ª

[23:35] <AlexDaniel> :|

[23:35] <AlexDaniel> srsly?

[23:36] <AlexDaniel> R#3782

[23:36] <linkable6> R#3782 [open]: https://github.com/rakudo/rakudo/issues/3782 antipairs sub is not implemented

[23:41] *** leont left
[23:44] *** Voldenet left
[23:45] *** Voldenet joined
[23:45] *** Voldenet left
[23:45] *** Voldenet joined
[23:58] *** Black_Ribbon joined
