[00:07] *** caterfxo joined
[00:15] *** caterfxo is now known as mrwisdom

[00:27] *** xelxebar joined
[00:37] *** pilne_ joined
[00:39] *** pilne left
[00:40] *** mrwisdom is now known as caterfxo

[00:59] *** upupbb-user3 joined
[01:01] *** hungrydonkey joined
[01:20] *** markong left
[01:39] *** molaf left
[01:42] *** ryn1x joined
[01:43] <ryn1x> p6: sub foo ( --> (Bool, Str) ) { return (True, "Success") }

[01:43] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Malformed return value‚ê§at <tmp>:1‚ê§------> 3sub foo ( -->7‚èè5 (Bool, Str) ) { return (True, "Success"‚ê§¬ª

[01:44] <ryn1x> Can I do a type signature like this in someway? I want to return a typed 2 tuple (list?)

[01:52] *** molaf joined
[02:00] *** PacoLinux joined
[02:09] <uzl[m]> m: subset Type where { $_[0] ~~ Bool && $_[1] ~~ Str }; sub foo ( --> Type ) { return (True, "Success") }

[02:09] <camelia> rakudo-moar 61b5e488e: ( no output )

[02:09] <uzl[m]> m: subset Type where { $_[0] ~~ Bool && $_[1] ~~ Str }; sub foo ( --> Type ) { return (True, "Success") }; say foo() ~~ Type;

[02:09] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´True‚ê§¬ª

[02:10] <uzl[m]> ryn1x: ^ Probably like this?

[02:10] <ryn1x> cool thx

[02:11] <ryn1x> Is this how I would type against a Class that does a Role?  sub foo($x where {$x does SomeRole})

[02:13] <sjn> m: sub a (--> Pair) { return True => "yes" }; say a.perl

[02:13] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´:True("yes")‚ê§¬ª

[02:14] <sjn> no support for parameterized Pair though

[02:14] <ryn1x> hmm... but can I assign the pair like I can a list...

[02:15] <uzl[m]> m; role A {}; class B does A {}; sub f( $x where {$_.does(A)} ) {}; f B

[02:15] <ryn1x> p6: my $a; my $b; ($a, $b) = sub a (--> Pair) { return True => "yes" };

[02:15] <camelia> rakudo-moar 61b5e488e: ( no output )

[02:15] <uzl[m]> m: role A {}; class B does A {}; sub f( $x where {$_.does(A)} ) {}; f B

[02:15] <camelia> rakudo-moar 61b5e488e: ( no output )

[02:15] <ryn1x> p6: my $a; my $b; ($a, $b) = sub a (--> Pair) { return True => "yes" }; say $a, $b

[02:15] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´&a(Any)‚ê§¬ª

[02:15] <uzl[m]> m; role A {}; class B {}; sub f( $x where {$_.does(A)} ) {}; f B

[02:15] <uzl[m]> m: role A {}; class B {}; sub f( $x where {$_.does(A)} ) {}; f B

[02:15] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´Constraint type check failed in binding to parameter '$x'; expected anonymous constraint to be met but got B (B)‚ê§  in sub f at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[02:17] <ryn1x> m: role A {}; class B does A {}; sub f( $x where {$_.does(A)} ) {}; f B

[02:17] <camelia> rakudo-moar 61b5e488e: ( no output )

[02:17] <ryn1x> m: role A {}; class B does A {}; sub f( $x where {$_.does(A)} ) { say "worked" }; f B

[02:17] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´worked‚ê§¬ª

[02:17] <uzl[m]> m: role A {}; class B {} does A; sub f( $x where { $_ ~~ A} ) {}; f B

[02:17] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´Cannot use 'does' operator on a type object B.‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[02:18] <uzl[m]> m: role A {}; class B does A {}; sub f( $x where {$_ ~~ A} ) {}; f B

[02:18] <camelia> rakudo-moar 61b5e488e: ( no output )

[02:18] <uzl[m]> role A {}; class B; sub f( $x where {$_ ~~ A} ) {}; f B

[02:18] <ryn1x> m: role A {}; class B does A {}; class C; sub f( $x where {$_.does(A)} ) { say "worked" }; f C

[02:18] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Too late for unit-scoped class definition;‚ê§Please use the block form.‚ê§at <tmp>:1‚ê§------> 3role A {}; class B does A {}; class C;7‚èè5 sub f( $x where {$_.does(A)} ) { say "w‚ê§¬ª

[02:19] <uzl[m]> m: role A {}; class B {} sub f( $x where {$_ ~~ A} ) {}; f B

[02:19] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Strange text after block (missing semicolon or comma?)‚ê§at <tmp>:1‚ê§------> 3role A {}; class B {}7‚èè5 sub f( $x where {$_ ~~ A} ) {}; f B‚ê§    expecting any of:‚ê§        infix‚ê§        infix ‚Ä¶¬ª

[02:19] *** k-man joined
[02:19] <ryn1x> m: role A {}; class B does A {}; class C {}; sub f( $x where {$_.does(A)} ) { say "worked" }; f C

[02:19] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´Constraint type check failed in binding to parameter '$x'; expected anonymous constraint to be met but got C (C)‚ê§  in sub f at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[02:19] <ryn1x> yeah $x where {$_.does(A)}  seems to work

[02:19] <uzl[m]> m: role A {}; class B {}; sub f( $x where {$_ ~~ A} ) {}; f B

[02:19] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´Constraint type check failed in binding to parameter '$x'; expected anonymous constraint to be met but got B (B)‚ê§  in sub f at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[02:20] <ryn1x> that one is missing class B does A {}

[02:21] <uzl[m]> Yeah, I was testing a class that doesn't implement the role and it fails as expected.

[02:21] <ryn1x> ahh ok. cool.

[02:22] <uzl[m]> ^ It seems you could use smartmatching too but .does looks clearer to me.

[02:22] <ryn1x> so does or ~~...

[02:22] <ryn1x> ok yeah... thats what I was thinking

[02:33] *** upupbb-user3 left
[02:46] *** Geth_ joined
[02:46] *** Geth left
[02:58] *** hungrydonkey left
[03:01] <ryn1x> should I use "is rw" or "ir raw" to pass by reference to a sub?

[03:01] <ryn1x> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 42; sub replace($foo is rw) {$foo = Foo.new; $foo.x = 99}; replace $foo; say $foo.x;

[03:01] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´99‚ê§¬ª

[03:01] <ryn1x> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 42; sub replace($foo is raw) {$foo = Foo.new; $foo.x = 99}; replace $foo; say $foo.x;

[03:01] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´99‚ê§¬ª

[03:03] *** hungrydonkey joined
[03:08] *** hungrydonkey left
[03:21] <irced> "Raw parameters bind either a variable or a value passed to it, with no decontainerization taking place. That means that if a variable was passed to it, you can assign to the parameter. This is different from rw-parameter which can only bind to variables, never to values."

[03:21] * irced parses.

[03:23] <irced> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 24; sub replace($foo is raw) { $foo = Foo.new; $foo.x = 99}; replace 42; say $foo.x;

[03:23] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´Cannot assign to an immutable value‚ê§  in sub replace at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[03:25] *** ryn1x left
[03:26] <irced> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 24; sub replace($foo is rw, $blah is raw) { $foo = Foo.new; $foo.x = 99}; replace $foo 42; say $foo.x;

[03:26] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> 3oo = Foo.new; $foo.x = 99}; replace $foo7‚èè5 42; say $foo.x;‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        s‚Ä¶¬ª

[03:27] <irced> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 24; sub replace($foo is rw, $blah is raw) { $foo = Foo.new; $foo.x = 99}; replace ($foo 42); say $foo.x;

[03:27] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> 3o = Foo.new; $foo.x = 99}; replace ($foo7‚èè5 42); say $foo.x;‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        statement end‚ê§  ‚Ä¶¬ª

[03:27] <irced> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 24; sub replace($foo is rw, $blah is raw) { $foo = Foo.new; $foo.x = 99}; replace ($foo, 42); say $foo.x;

[03:27] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´Too few positionals passed; expected 2 arguments but got 1‚ê§  in sub replace at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[03:27] <irced> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 24; sub replace($foo is rw, $blah is raw) { $foo = Foo.new; $foo.x = $blah}; replace($foo, 42); say $foo.x;

[03:27] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´42‚ê§¬ª

[03:28] <irced> m: my class Foo {our $.x}; my $foo = Foo.new; $foo.x = 24; sub replace($foo is rw, $blah is rw) { $foo = Foo.new; $foo.x = $blah}; replace($foo, 42); say $foo.x;

[03:28] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´Parameter '$blah' expected a writable container, but got Int value‚ê§  in sub replace at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[03:28] <irced> that sums it up. ryn1x ah crap

[03:32] * irced uses raku code to decrypt satellite communications, intercept an authorization, reproduce it, submits an images of ryn1x's face and body posture, triangulate ryn1x's current geolocation based on facial recognition and cell phone location (with history), deploys a drone to deliver a hand written note that reads BANG.

[03:33] *** hungrydonkey joined
[03:38] *** Doc_Holliwould left
[03:38] * [Coke] wonders how to setup a main so he can have a fixed string, then -x args, then normal args

[03:40] <[Coke]> MAIN("combo", $stuff, :$nonsense) wants to be invoked as ./exe -nonsense combo stuff

[03:43] <irced> It's possible to alter how arguments are processed before they're passed to sub MAIN {} by setting options in the %*SUB-MAIN-OPTS hash. Due to the nature of dynamic variables, it is required to set up the %*SUB-MAIN-OPTS hash and fill it with the appropriate settings.

[03:43] <irced> "

[03:44] <irced> "For example....raku example.raku 1 --c=2 3 --d=4"

[03:44] <irced> [Coke] does that get a cigar?

[03:45] * irced fiddles happily with his thumb err cigar cutter, making a steel slicing sound repeatedly.

[03:45] <[Coke]> checking...

[03:45] <irced> https://docs.raku.org/language/create-cli#index-entry-$PERCENT_SIGN*SUB-MAIN-OPTS

[03:47] * irced draws a pocket blow torch and a bag of thermite from a satchel, to ensure the cigar burns of course.

[03:49] <[Coke]> irced++

[03:49] <irced> cool, i had hoped it was close enuf

[03:50] * irced puts on light shielding goggles and lights the torch. Cigar time.

[03:51] *** roguelazer left
[03:53] *** roguelazer joined
[03:55] *** pilne_ left
[04:04] *** PacoLinux left
[04:19] *** discord6 joined
[04:19] *** discord6 left
[04:19] *** discord6 joined
[04:19] *** cpan-raku left
[04:20] *** cpan-raku joined
[04:20] *** cpan-raku left
[04:20] *** cpan-raku joined
[04:21] *** discord6 left
[04:22] *** discord6 joined
[04:22] *** discord6 left
[04:22] *** discord6 joined
[04:22] *** cpan-raku_ joined
[04:22] *** cpan-raku_ left
[04:22] *** cpan-raku_ joined
[04:22] *** cpan-raku left
[04:22] *** irced left
[04:33] *** holyghost left
[04:56] *** upupbb-user3 joined
[05:27] *** upupbb-user3 left
[05:37] *** rindolf joined
[05:43] *** helit left
[05:47] *** wamba joined
[05:47] *** helit joined
[05:51] *** sjm_uk joined
[06:13] *** Doc_Holliwould joined
[06:19] *** PacoLinux joined
[06:21] *** kensanata joined
[06:53] *** tadzik left
[06:54] *** SQuoll left
[06:54] *** b2gills left
[06:54] *** wamba left
[06:54] *** SQuoll joined
[07:00] *** tadzik joined
[07:01] *** wamba joined
[07:02] *** b2gills joined
[07:02] *** upupbb-user3 joined
[07:05] *** xelxebar left
[07:05] *** abraxxa joined
[07:05] *** xelxebar joined
[07:06] *** abraxxa left
[07:09] *** abraxxa joined
[07:09] *** Sgeo__ joined
[07:11] <SmokeMachine>  m: role A {}; class B does A {}; sub f( A $x ) {}; f B

[07:11] <camelia> rakudo-moar 61b5e488e: ( no output )

[07:13] *** Sgeo_ left
[07:13] *** abraxxa left
[07:13] <SmokeMachine> :(

[07:13] <SmokeMachine>  m: role A {}; class B {}; sub f( A $x ) {}; f B

[07:13] <camelia> rakudo-moar 61b5e488e: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Calling f(B) will never work with declared signature (A $x)‚ê§at <tmp>:1‚ê§------> 3ole A {}; class B {}; sub f( A $x ) {}; 7‚èè5f B‚ê§¬ª

[07:14] <SmokeMachine> :)

[07:14] *** abraxxa joined
[07:15] *** stoned75 joined
[07:41] *** dakkar joined
[07:52] *** pecastro joined
[07:58] *** sena_kun joined
[07:59] *** AlexDaniel joined
[08:00] *** AlexDaniel left
[08:00] *** AlexDaniel joined
[08:00] *** PacoLinux left
[08:00] *** wamba left
[08:06] *** Altai-man_ joined
[08:08] *** sena_kun left
[08:09] *** natrys joined
[08:22] *** PacoLinux joined
[08:27] *** Geth joined
[08:28] *** Geth_ left
[08:35] *** AlexDaniel left
[08:36] *** hungrydonkey left
[08:36] *** angelds joined
[08:37] *** hungrydonkey joined
[08:40] *** Doc_Holliwould left
[08:44] *** lichtkind left
[08:45] <Altreus> No matter what I do I cannot seem to get this client to reconnect if the heartbeat is not acknowledged. https://github.com/shuppet/p6-api-discord/blob/bug/35-reconnect-issue/lib/API/Discord/Connection.pm6#L193

[08:45] <Altreus> It just ... stops

[08:45] <Altreus> It appears to print out a whole bunch of spaces on STDERR but I have no idea how that's even possible

[08:46] <Altreus> Line 203 just never appears to be reached

[08:50] *** angelds left
[08:59] *** eythian joined
[08:59] *** eythian left
[08:59] *** eythian joined
[09:00] *** eythian left
[09:28] *** ufobat joined
[09:52] *** Black_Ribbon left
[10:07] *** sena_kun joined
[10:07] <tbrowder> m: class f { has $.f; method f {} }; my $o = f.new

[10:07] <camelia> rakudo-moar 9b735b769: ( no output )

[10:09] *** Altai-man_ left
[10:10] <tbrowder> m: class f { has $.f; method f { say 'foo'}}; my $f = f.new; $f.f

[10:10] <camelia> rakudo-moar 9b735b769: OUTPUT: ¬´foo‚ê§¬ª

[10:11] *** wamba joined
[10:14] <tbrowder> m: class f { has $.f is rw = 'f'; method f {say self.f}}; my $f.new; $f.f; $f.f = 'a'; $f.f

[10:14] <camelia> rakudo-moar 6793713b2: OUTPUT: ¬´No such method 'f' for invocant of type 'Any'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[10:18] *** AlexDaniel joined
[10:18] *** AlexDaniel left
[10:18] *** AlexDaniel joined
[10:21] *** MasterDuke left
[10:29] <lizmat> my $f.new  ??

[10:30] <lizmat> tbrowder 

[10:30] <lizmat> what are you trying to achieve ?

[10:31] <tbrowder> experimenting with identical names for methods and attrs. finished offline to my satisfaction.

[10:32] <tbrowder> we can if needed--very cool!

[10:35] <tbrowder> lizmat: is it safe to say in general that i can change perl's value of "undef" to "Nil" in raku for assignments?

[10:35] <lizmat> yes

[10:36] <tbrowder> that helps. do you know why Nil was chosen over undef for raku?

[10:37] <lizmat> because every type object is basically undef

[10:37] <tbrowder> ?

[10:37] <lizmat> in Perl undef is many things

[10:37] <lizmat> it's a function and it's a value and it's a state

[10:38] <lizmat> in Raku these are split up really

[10:38] <lizmat> there's an undefine() function still, but that's deprecated

[10:38] <lizmat> because it has different semantics for scalar / arrays / hashes

[10:39] <lizmat> every type object is a typed undefined value  :-)

[10:39] <lizmat> and Nil is the "untyped" undefined value

[10:39] <lizmat> assigning Nil to a scalar will return that scalar to its default state

[10:39] <tbrowder> erg, no wonder i never tried to get into perl guts...

[10:40] <lizmat> m: my $a is default(42) = 666; say $a; $a = Nil; say $a

[10:40] <camelia> rakudo-moar 6793713b2: OUTPUT: ¬´666‚ê§42‚ê§¬ª

[10:43] <tbrowder> !!

[10:44] <tbrowder> cool if needed. my pea brain can't think of a practical use offhand...

[10:45] <lizmat> it could be handy for arrays

[10:45] <lizmat> m: my @a is default(1); say @a[1000]

[10:45] <camelia> rakudo-moar 6793713b2: OUTPUT: ¬´1‚ê§¬ª

[10:46] <lizmat> or hashes

[10:46] <lizmat> m: my %h is default(1); say %h<foobar>

[10:46] <camelia> rakudo-moar 6793713b2: OUTPUT: ¬´1‚ê§¬ª

[10:46] <tbrowder> oh, so an automatically full defined infinite array?

[10:46] <lizmat> well, conceptually, yes

[10:47] <lizmat> m: my %h is default(1); say %h<foobar>; say %h.elems

[10:47] <camelia> rakudo-moar 6793713b2: OUTPUT: ¬´1‚ê§0‚ê§¬ª

[10:47] <lizmat> in reality, no  :-)

[10:48] <tbrowder> hm, raku is indeed wondrous!

[10:49] <tbrowder> thnx for the interesting trip

[10:50] <lizmat> yw

[11:00] *** upupbb-user3 left
[11:05] *** aborazmeh joined
[11:05] *** aborazmeh left
[11:05] *** aborazmeh joined
[11:10] *** chloekek joined
[11:12] *** ufobat left
[11:12] *** ufobat joined
[11:18] *** epony left
[11:19] *** epony joined
[11:23] *** MasterDuke joined
[11:34] <Altreus> any grown-ups able to help with my problem? :S

[11:34] <Altreus> I'm at a total loss ;_;

[11:34] <lizmat> Altreus: I have no idea either :-(

[11:35] <Altreus> wait! I have output!

[11:35] <Altreus> ¬´ ‚ô•üíî! üîå‚Ä¶Closing connection

[11:35] <Altreus> It just doesn't reconnect :z

[11:35] <Altreus> I'm pretty sure all I changed was the string but ok

[11:41] <chloekek> I want something like state but that makes it a property of self instead of the block. Does that exist?

[11:41] <chloekek> There is has but its name must be unique across all methods.

[11:42] <Geth> ¬¶ doc: Kaiepi++ created pull request #3300: Document sigiled method calls

[11:42] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/pull/3300

[11:42] <discord6> <tmtvl> Oh hey, the IRC bridge works again. Hello everyone!

[11:42] *** markong joined
[11:42] <chloekek> I want to make prepared statements persist throughout my instance, but I would really like to just call all of them $sth, for brevity.

[11:42] <cpan-raku_> New module released to CPAN! DBIish::Transaction (1.0.1) by 03RBT

[11:44] <chloekek> Like this: https://glot.io/snippets/fm3jkrnrf7

[11:46] <MasterDuke> m: class F { my $sth = "select"; method get-sth() { $sth }; method set-sth($a) { $sth = $a } }; my $f = F.new; say $f.get-sth; my $g = F.new; $g.set-sth("update"); say $f.get-sth    # or this?

[11:46] <camelia> rakudo-moar 432597283: OUTPUT: ¬´select‚ê§update‚ê§¬ª

[11:47] <chloekek> I specifically want them per instance, not global.

[11:47] <chloekek> At runtime like has, but syntactically like my.

[11:48] <chloekek> The storage of has but scoped per lexical scope, not for the entire class.

[11:49] <MasterDuke> you could probably make some sort of Proxy object that stores in a hash keyed on the calling method's name

[11:50] <chloekek> I can make a hash that maps SQL to prepared statements.

[11:52] <chloekek> has DBDish::SQLite::StatementHandle %!sths;

[11:52] <chloekek> method !sth(::?CLASS:D: Str:D $sql) { %!sths{$sql} //= $!dbh.prepare($sql); }

[11:52] <chloekek> That should do the trick.

[11:53] *** NODE left
[11:54] <chloekek> Example use: my $sth := self!sth(q:to/SQL/); ‚ò∫

[11:55] *** NODE joined
[11:58] *** vike joined
[12:00] *** markoong joined
[12:03] *** markong left
[12:04] *** xelxebar left
[12:06] *** Altai-man_ joined
[12:08] *** sena_kun left
[12:11] *** markong joined
[12:11] *** aborazmeh left
[12:12] *** xelxebar joined
[12:12] *** |oLa| joined
[12:15] *** markoong left
[12:26] *** markoong joined
[12:29] *** |oLa| left
[12:30] *** markong left
[12:31] *** markoong left
[12:31] *** markong joined
[12:37] *** hungrydonkey left
[12:39] *** Doc_Holliwould joined
[12:52] <Geth> ¬¶ doc: 7a4f43b118 | (Ben Davies)++ | doc/Language/objects.pod6

[12:52] <Geth> ¬¶ doc: Document sigiled method calls

[12:52] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/7a4f43b118

[12:52] <Geth> ¬¶ doc: 9cd4c4d35b | (Ben Davies)++ | xt/words.pws

[12:52] <Geth> ¬¶ doc: Learn the enqueue and dequeue words

[12:52] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/9cd4c4d35b

[12:52] <Geth> ¬¶ doc: 795dc6c896 | (Juan Juli√°n Merelo Guerv√≥s)++ (committed using GitHub Web editor) | 2 files

[12:52] <Geth> ¬¶ doc: Merge pull request #3300 from Kaiepi/sigiled-methods

[12:52] <linkable6> Link: https://docs.raku.org/language/objects

[12:52] <Geth> ¬¶ doc: 

[12:52] <Geth> ¬¶ doc: Document sigiled method calls

[12:52] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/795dc6c896

[12:54] *** daxim left
[12:57] *** Kaeipi is now known as Kaiepi

[12:57] *** xelxebar left
[12:59] *** daxim joined
[13:01] *** xelxebar joined
[13:05] *** |oLa| joined
[13:11] *** |oLa| left
[13:14] <Geth> ¬¶ doc: 4d7c12fb7d | (Ben Davies)++ | doc/Language/objects.pod6

[13:14] <Geth> ¬¶ doc: Add missing quote in sigiled method call example

[13:14] <Geth> ¬¶ doc: review: https://github.com/Raku/doc/commit/4d7c12fb7d

[13:14] <linkable6> Link: https://docs.raku.org/language/objects

[13:16] *** Doc_Holliwould left
[13:40] *** NODE left
[13:47] *** NODE joined
[13:50] <cpan-raku_> New module released to CPAN! DBIish::Transaction (1.0.2) by 03RBT

[13:54] *** vrurg_ joined
[13:58] *** vrurg joined
[13:58] <chloekek> When writing actions for grammars, how do you know what $/ will be like, when the grammar uses repetition?

[13:59] <chloekek> In my grammar I have token TOP { <option>* %% \n } so I would expect $<option> to be a list of matches.

[13:59] <lizmat> moritz jnthn ^^

[13:59] <jnthn> I'd epxect so too :)

[14:00] <chloekek> For some reason I get a Nil here: https://glot.io/snippets/fm3nbm4non

[14:00] <chloekek> I inspected the match objects but it was not clear how I would get the option ASTs out.

[14:01] *** vrurg_ left
[14:02] <chloekek> $<option>¬ª.made just evaluates to [Nil, Nil]

[14:02] <jnthn> You forgot to write `make` in the action methods

[14:02] <chloekek> Ah

[14:03] * jnthn wonders if that's a common enough mistake to deserve a weak warning in Comma... 

[14:03] <chloekek> Thanks, now it works great. :)

[14:04] <chloekek> Raku::Critic

[14:07] *** sena_kun joined
[14:08] *** Altai-man_ left
[14:14] *** Tirifto joined
[14:26] *** aluaces left
[14:27] *** lucasb joined
[14:28] *** molaf left
[14:35] *** Doc_Holliwould joined
[14:38] <cpan-raku_> New module released to CPAN! Data::Record (0.1.2) by 03KAIEPI

[14:44] *** rindolf left
[14:46] <uzl[m]> m: my @a := (1, 2); say @a.VAR.^name;  say @a[0].VAR.^name;

[14:46] <camelia> rakudo-moar 77defa770: OUTPUT: ¬´List‚ê§Int‚ê§¬ª

[14:46] <uzl[m]> m: my @a := (1, 2); say @a.VAR.^name;  say @a[0].VAR.^name; @a[0] = 1;

[14:46] <camelia> rakudo-moar 77defa770: OUTPUT: ¬´List‚ê§Cannot modify an immutable List ((1 2))‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Int‚ê§¬ª

[14:47] <uzl[m]> m: my %a := Map.new('a', 1, 'b', 2); say %a.VAR.^name;  say %a<a>.VAR.^name;

[14:47] <camelia> rakudo-moar 77defa770: OUTPUT: ¬´Map‚ê§Int‚ê§¬ª

[14:47] <uzl[m]> m: my %a := Map.new('a', 1, 'b', 2); say %a.VAR.^name;  say %a<a>.VAR.^name; %a<a> = 'Hi'; say %a

[14:47] <camelia> rakudo-moar 77defa770: OUTPUT: ¬´Map‚ê§Int‚ê§Map.new((a => 1, b => 2))‚ê§¬ª

[14:50] *** rindolf joined
[14:51] <uzl[m]> ^ Is there any reason why trying to mutate a Map bound to a %-sigiled variable doesn't throw an error the same way  a List bound to a @-sigiled variable does?

[14:52] *** kanliot joined
[14:52] *** kanliot left
[14:52] *** kanliot joined
[14:54] <kanliot> i was reading https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html  and I think i read that raku supports coroutine semantics, but not actual coroutines.  is this true?  I think raku would be more interesting if it had real coroutines with the existing semantics which seem very good in raku!

[14:58] <jnthn> Raku has multiple constructs that are coroutine-powerful (gather/take, and await); the actual impl of them is done in terms of continuations rather than coroutines, though that's an implementation detail.

[15:05] *** ufobat left
[15:05] *** ufobat joined
[15:12] <kanliot> hmm. does golang use multithreaded goroutines by default?

[15:12] <kanliot> and thanks for the reply sir

[15:14] *** rindolf left
[15:19] <chloekek> At any one time a goroutine runs on at most one thread.

[15:20] <chloekek> The number of threads that can be running different goroutines is given by GOMAXPROCS, which defaults to the number of cores.

[15:20] *** ufobat left
[15:21] *** ufobat joined
[15:22] <chloekek> A goroutine may run on different threads along its lifetime.

[15:22] *** molaf joined
[15:23] *** rindolf joined
[15:23] *** ufobat_ joined
[15:25] <kanliot> thanks chloekek, I guess you looked that up. 

[15:26] <kanliot> I'm having trouble learning perl OOP.  is raku OOP easier somehow... Im reading https://raku.guide/#_classes_objects

[15:26] <kanliot> mainly the problem is i'm just not smart enough or something

[15:26] <chloekek> I looked up the default to GOMAXPROCS. :P

[15:27] *** ufobat left
[15:31] <Altreus> jnthn: help me jnthn-kenobi, you're my only hope :(

[15:31] <Altreus> https://github.com/shuppet/p6-api-discord/blob/bug/35-reconnect-issue/lib/API/Discord/Connection.pm6#L193 I've got this far. It notices the exception and disconnects, but never seems to try to reconnect

[15:32] <Altreus> I don't know what debugging to add to help figure out why

[15:32] *** Kaiepi left
[15:32] *** NODE left
[15:34] *** Kaiepi joined
[15:34] *** NODE joined
[15:35] *** mowcat joined
[15:35] *** k-man left
[15:37] <chloekek> p6: sprintf("%4s", ‚ÄòÊ•Ω‚Äô).chars;

[15:37] <camelia> rakudo-moar 77defa770: ( no output )

[15:37] <chloekek> p6: say sprintf("%4s", ‚ÄòÊ•Ω‚Äô).chars;

[15:37] <camelia> rakudo-moar 77defa770: OUTPUT: ¬´4‚ê§¬ª

[15:38] <AlexDaniel> what

[15:38] <AlexDaniel> m: say sprintf("%4s", ‚ÄòÊ•Ω‚Äô);

[15:38] <camelia> rakudo-moar 77defa770: OUTPUT: ¬´   Ê•Ω‚ê§¬ª

[15:38] <AlexDaniel> ah

[15:38] *** hungrydonkey joined
[15:38] <chloekek> But Ê•Ω is twice as wide as Latin characters. :(

[15:39] <AlexDaniel> chloekek: so? The width of some characters is unknown even

[15:39] <AlexDaniel> unidump: Ê•Ω

[15:39] <unicodable6> AlexDaniel, https://gist.github.com/673a178a454e675d1e5a520fde87faf0

[15:39] <uzl[m]> kanliot: I'd dare to say that Raku's  OOP is one of the cleaniest and most straightforward OOP implementations I've seen in a programming language. I'm bit biased though ;-).

[15:39] <AlexDaniel> chloekek: check East_Asian_Width property

[15:40] <chloekek> Would be great to have support for that in s?printf.

[15:40] <chloekek> Maybe it‚Äôs already there, I‚Äôd have to check.

[15:40] <AlexDaniel> I doubt it

[15:40] <AlexDaniel> you're asking for something that is generally not possible

[15:40] <AlexDaniel> at least as far as I know

[15:41] <AlexDaniel> maybe there's a unicode doc somewhere saying how to do it

[15:41] <chloekek> UAX #14 mentions it.

[15:44] <AlexDaniel> UAX #14 is talking about where to break lines, I don't think it's helpful for font-related width

[15:44] <AlexDaniel> UAX #11 is probably more useful

[15:45] <chloekek> There are also characters that take up no space such as the zero-width joiner.

[15:45] <AlexDaniel> well, zero-width joiner normally appears in the middle of things that form a single grapheme anyway

[15:46] <chloekek> Right.

[15:46] <kanliot> thx uzl[m] https://raku.guide/#_classes_objects  this web page seems well written as well.  I stopped reading the page since I had to google how to distribute raku programs.  I didn't like what i saw there

[15:47] <AlexDaniel> chloekek: it's an interesting issue, maybe file a ticket about it? https://github.com/perl6/problem-solving/

[15:47] <chloekek> I‚Äôll have to do some more research firts.

[15:48] <chloekek> I found a Perl 5 module called Unicode::GCString that has a columns function for terminal printing. Let‚Äôs see what that has to say.

[15:48] <AlexDaniel> chloekek: once there's a ticket I believe samcv will take a look at it, and she knows a lot more :)

[15:49] *** NODE left
[15:49] <chloekek> Ok.

[15:51] *** NODE joined
[15:53] <AlexDaniel> ‚ÄúIn "NONEASTASIAN" context, characters with East_Asian_Width property ambiguous (A) are treated as "narrow" and with Line Breaking Class AI as alphabetic (AL).‚Äù

[15:53] <AlexDaniel> thing is, your terminal probably has no idea

[15:54] <AlexDaniel> so my understanding is that you can guesstimate the number of fixed-pitch columns, but it doesn't mean much once you start printing them somewhere

[16:02] <Geth> ¬¶ problem-solving: chloekek assigned to samcv Issue printf padding and wide East Asian characters https://github.com/Raku/problem-solving/issues/171

[16:05] <uzl[m]> kanliot: I think raku.guide is meant to give you an overview of the language. For more in-depth treatment of a particular subject, always refer to the documentation. If you feel something isn't clear on there, you can ask here and/or submit an issue to https://github.com/Raku/doc/issues.

[16:06] *** Altai-man_ joined
[16:06] <kanliot> uzl[m], ok thanks. i see the documentation is linked at the top of raku.guide

[16:06] <uzl[m]> kanliot: By distributing a Raku program, do you mean how to "modularize" it and then make it available in the ecosystem?

[16:08] <kanliot> uzl[m], no I mean make it accessible to uh non-experts like me who google stuff and occassionally get a google result from github.

[16:09] *** sena_kun left
[16:09] <kanliot> so you could zip up your raku module, but the user still needs to know how to install it on his/her OS

[16:10] <kanliot> so it's a nonstarter for most people

[16:13] <uzl[m]> hmm...  if a module has its META6.json, installing it is quite easy since zef takes care of everything for you. https://docs.raku.org/language/modules#Looking_for_and_installing_modules.

[16:15] <uzl[m]> kanliot: BTW, do you mind sharing what you didn't like on raku.guide? You could submit an issue to https://github.com/hankache/rakuguide.

[16:15] <kanliot> you remove the appeal of simplicity if it requires expertise.  anyhow I can't lecture you

[16:16] <kanliot> i love raku.guide.  i have a problem with "modern perl fourth edition" which gives me a headache

[16:16] <kanliot> sorry if i was unclear

[16:20] <uzl[m]> Np!

[16:22] *** Kaiepi left
[16:30] *** Kaiepi joined
[16:52] *** dakkar left
[17:09] *** daxim left
[17:20] *** NODE left
[17:22] *** dakkar joined
[17:22] *** kensanata left
[17:22] *** NODE joined
[17:24] <samcv> AlexDaniel, i have looked at it now chloekek 

[17:33] *** daxim joined
[17:41] *** NODE left
[17:43] *** NODE joined
[17:49] <AlexDaniel> samcv: but it's not just different unicode versions

[17:49] <AlexDaniel> samcv: people want to use it to render tui stuff in terminals

[17:50] <AlexDaniel> which will probably work in 99% of cases but this 1% will drown us with unfixable bug reports

[17:51] <AlexDaniel> if they want to know if something fits in the terminal then why don't they ask their terminal? :)

[17:54] <cpan-raku_> New module released to CPAN! DBIish::Transaction (1.0.3) by 03RBT

[18:01] <lizmat> printf is grapheme based, and I think it should stay that way

[18:02] <lizmat> which is already much better than printf's in other languages

[18:02] *** hungrydonkey left
[18:03] <Grinnz> if you want to know how something will physically fit in terminal columns, you need something smarter than printf

[18:03] <AlexDaniel> lizmat: is it? when somebody writes ‚Äú%3s‚Äù what do they even mean?

[18:04] <AlexDaniel> why would you even want exactly three graphemes

[18:04] <Grinnz> consider full width characters also

[18:04] <lizmat> I'm not saying having a better capability for something like that wouldn't be nice

[18:04] <Grinnz> ah, i see that's what the conversation was about :)

[18:05] <lizmat> but printf has a POSIX background, and in earlier discussions about adding features to it

[18:05] *** aluaces joined
[18:05] <Grinnz> yes, in Perl we use Unicode::GCString's "columns" method

[18:05] <lizmat> it was decided to keep to the POSIX meaning of it

[18:05] <Grinnz> (for terminal columns)

[18:05] <chloekek> I think A good compromise would be to mention a module that implements terminal-aware spacing, once such a module exists.

[18:06] <Grinnz> i don't think it would work well as a printf extension, because what do you do when someone tries to print two full-width characters and specifies a width of 3 columns

[18:06] <lizmat> thing is, even something like the "columns" method, assumes a fixed width font

[18:07] *** sena_kun joined
[18:07] <lizmat> anybody creating a nice GUI would *not* use a fixed with font if they can help it

[18:07] <Grinnz> of course, if you have to know about the particular font widths everything goes out the window

[18:07] <lizmat> so feels to me, that the GUI system of choice, should figure out how much space a string needs

[18:08] <Grinnz> yes, much like when dealing with CSS

[18:08] <chloekek> What good is space padding with a proportional font?

[18:08] <AlexDaniel> fixed-width or not, you just can't know how it's going to render

[18:09] *** Altai-man_ left
[18:09] <Grinnz> space padding would not be the appropriate approach in such cases

[18:09] <Grinnz> instead you'd need to align it to other components of the display

[18:10] <Grinnz> AlexDaniel: you can't know, but you can assume what will happen if it's properly displayed in fixed width

[18:10] <Grinnz> this would be essential for any TUI app

[18:12] <AlexDaniel> ‚Äúessential‚Äù

[18:13] <AlexDaniel> here lynx renders stuff in a fake window: https://github.com/ThomasDickey/lynx-snapshots/blob/178bb762e0b5c5e40ebbee627862de2b7504a9f5/src/LYCurses.c#L2240

[18:14] *** vike1 joined
[18:15] *** vike left
[18:18] *** vike1 left
[18:19] *** vike joined
[18:24] *** dakkar left
[18:24] <samcv> AlexDaniel, TUI?

[18:25] <AlexDaniel> samcv: text-based/terminal user interface

[18:25] <samcv> Ah terminal user interfaces. Well. We go by what unicode says. The end. If they make a bug report, we close it since we go with unicode spec on this, otherwise it needs to go in a module

[18:25] <samcv> it's not going to be guaranteed to be accurate. but only based on the unicode data. I think if we make that clear then that should be okay

[18:29] *** sauvin left
[18:29] <samcv> lizmat, yes it *is* the gui's job. unicode makes that clear. but also they understand that this is a useful use-case. previously they didn't want to change any of the width properties, but at least as far as I know, they changed their stance to allow changing tho east asian width for non-asian characters to accomodate it. So they don't guarantee it is perfect or even correct information, but just "better" than not having that information.

[18:32] <samcv> though. it can just be kicked to a module, regardless, so i guess the question is if it should exist in sprintf or not

[18:33] <samcv> and also, if it will add value to the language itself

[18:33] <lizmat> you can use sprintf to convert any numerical value to a Str, then have another module take care of twiddling grapheme widths

[18:33] <AlexDaniel> anything can add value, doesn't mean that everything should be in the language itself

[18:34] <samcv> yep. that is true.

[18:36] <AlexDaniel> also I'm a fan of naming things for what they actually do. %10w makes it look like it does something proper while :guess-rendered-length is a bit more transparent and better :)

[18:36] <vrurg> I would say 'printf ..., :wide;' should be cheap enough to be considered.

[18:37] <vrurg> AlexDaniel: no guessing. Only clear "use" or "don't". Things must be predictable.

[18:37] <samcv> in addition, what are the pros and cons of letting a module do this. If them reimplementing sprintf is not really feasible. the options are to implement it or have some way people can plug into sprintf or something (just spitballing here, I haven't thought hard enough about all of this)

[18:38] <AlexDaniel> vrurg: yeah, exactly why a feature like this should be called this way :P

[18:39] <vrurg> AlexDaniel: perhaps because the feature should be "use 2 char if I ask you for this", not "try guessing if 2char should be used".

[18:40] <vrurg> ¬Ø\_(„ÉÑ)_/¬Ø

[18:41] <AlexDaniel> vrurg: ‚ÄúSome characters behave differently in an East Asian context than in a non-East Asian context‚Äù

[18:41] <AlexDaniel> vrurg: how do you define context without guessing?

[18:43] <vrurg> If "context" is defined by surrounding symbols ‚Äì it's not guessing, it's knowing. If it's defined by the purpose and destination of a string ‚Äì then it's up to the user to determine the context. A 3rd party module can help him in this task.

[18:43] <vrurg> But it's Raku job to do it.

[18:44] <samcv> AlexDaniel, example?

[18:44] <vrurg> Or I don't understand what 'context' means in this context. :)

[18:45] <AlexDaniel> ‚ÄúAmbiguous characters behave like wide or narrow characters depending on the context (language tag, script identification, associated font, source of data, or explicit markup; all can provide the context). If the context cannot be established reliably, they should be treated as narrow characters by default.‚Äù

[18:46] <AlexDaniel> for terminals it seems to depend on the locale

[18:46] <samcv> AlexDaniel, oh. well. unicode gives us values for all(not actually all but, some) characters. so go on that, and let that be it? i think you are talking about how unicode decides if something is wide or not?

[18:46] <vrurg> AlexDaniel: and on a font used. I use DejaVu Mono because it fits most if not all wide-chars (like arrows) into a single position.

[18:46] <samcv> though i need to read that document

[18:47] <vrurg> Shoud Raku take care finding out what font am I using?

[18:47] <samcv> vrurg, never

[18:47] <vrurg> samcv: this is my point too.

[18:47] <AlexDaniel> samcv: I'm talking about characters that unicode defines as East Asian Ambiguous

[18:48] <samcv> ah yeah. fair enough

[18:48] <samcv> " If they are not used in context of the specific legacy encoding they belong to, their width resolves to narrow" hmm

[18:49] <samcv> so. that leads me to believe. that it is usually only wide if it's using a two byte encoding (DBCS)

[18:50] <samcv> and that is a bit out of our scope. so if I am right then those are just narrow, except if you're converting from some dual byte encoding (which we aren't since it's just a NFG unicode string)

[18:51] <vrurg> Iterm2 has a configuration option "Ambiguous characters are double-width". So, this would most likely affect things too.

[18:51] <samcv> vrurg, well. that is out of scope. we can't control what anybody else does with the data

[18:51] <AlexDaniel> interesting bug report https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=471021

[19:08] *** pilne joined
[19:09] *** abraxxa left
[19:12] *** abraxxa joined
[19:14] *** daxim left
[19:17] <chloekek> Finally got around to writing a dark style sheet for docs.raku.org.

[19:19] *** daxim joined
[19:19] <chloekek> Even inverting the type graphs. :)

[19:21] *** sjm_uk left
[19:29] *** sjm_uk joined
[19:29] *** upupbb-user1 joined
[19:33] *** sjm_uk left
[19:36] *** dustinm` left
[19:39] *** Black_Ribbon joined
[19:39] *** daxim left
[19:40] *** dustinm` joined
[19:45] *** daxim joined
[20:00] *** upupbb-user1 left
[20:00] *** veesh left
[20:00] *** MasterDuke left
[20:02] *** veesh joined
[20:05] *** daxim left
[20:05] *** rindolf left
[20:06] *** Altai-man_ joined
[20:07] *** MasterDuke joined
[20:09] *** sena_kun left
[20:10] * lizmat just noticed that https://en.wikipedia.org/wiki/Raku_(programming_language) has nothing about supplies,. channels, react / whenever

[20:11] *** daxim joined
[20:14] <AlexDaniel> lizmat: yes, but even our own docs don't talk enough about react/whenever :(

[20:15] <lizmat> :-(

[20:15] *** pilne left
[20:15] *** pilne joined
[20:16] <chloekek> p6: my (IO() $x) = "foo"; say $x

[20:16] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´foo‚ê§¬ª

[20:16] <chloekek> p6: my (IO() $x is copy) = "foo"; say $x

[20:16] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´foo‚ê§¬ª

[20:17] <chloekek> p6: my (:$x) = |{x => 1}; say $x;

[20:17] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´x => 1‚ê§¬ª

[20:17] <AlexDaniel> chloekek: how is this legal :D

[20:18] <chloekek> > Signatures appear ‚Ä¶ as the input to variable declarators like my

[20:18] <chloekek> p6: my (*@xs) = (1, 2, (3, 4), 5); say @xs

[20:18] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´[1 2 (3 4) 5]‚ê§¬ª

[20:18] <chloekek> p6: my (**@xs) = (1, 2, (3, 4), 5); say @xs

[20:18] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´[1 2 (3 4) 5]‚ê§¬ª

[20:19] <AlexDaniel> m: my ($x is wtf); $x = 42; say $x

[20:19] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´42‚ê§¬ª

[20:19] <lizmat> feels to me it's parsing as a signature, but losing all of the extra info

[20:20] <chloekek> p6: my ($x --> Str) = 1; say $x;

[20:20] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´1‚ê§¬ª

[20:22] <AlexDaniel> m: my ($x returns Int) # not sure why this parses

[20:22] <camelia> rakudo-moar 371590fa1: ( no output )

[20:22] <AlexDaniel> but yeah you can do --> 42 and everything else and it is simply ignored

[20:22] <jnthn> It *is* parsed as a signature

[20:23] <jnthn> That's why you can write my ($x, :$y) := ...; to do destructuring

[20:23] <AlexDaniel> jnthn: yeah but returns can't really be inside a signature, right? :)

[20:23] *** caterfxo left
[20:23] <jnthn> Sure, syntactically it's just a trait

[20:23] <jnthn> The problem is that when we see it's just an assignment, we reduce it to a variable list and discard everything else

[20:23] <jnthn> We never apply the trait

[20:24] <jnthn> It should really be much stricter there

[20:24] <jnthn> Though probably at a language version break so we don't turn ignored into boom.

[20:24] <AlexDaniel> 6c: my (IO() $x) = "foo"; say $x # just in case

[20:24] <committable6> AlexDaniel, ¬¶6c (42 commits): ¬´foo‚ê§¬ª

[20:24] <chloekek> p6: my (IO() $x) = ‚Äòfoo‚Äô; say $x.raku

[20:24] <camelia> rakudo-moar 371590fa1: OUTPUT: ¬´"foo"‚ê§¬ª

[20:24] <AlexDaniel> 6c: my (IO() $x return 42) = "foo"; say $x # just in case

[20:24] <AlexDaniel> 6c: my (IO() $x return Int) = "foo"; say $x # just in case

[20:25] <AlexDaniel> 6c: my (IO() $x returns Int) = "foo"; say $x # just in case

[20:25] <committable6> AlexDaniel, https://gist.github.com/3d1c1a206b353b9bb2e7acb874e4dbbf

[20:25] <committable6> AlexDaniel, https://gist.github.com/90245c0cb4c1c68a59b685f0c249b04d

[20:25] <committable6> AlexDaniel, ¬¶6c (42 commits): ¬´foo‚ê§¬ª

[20:25] *** caterfxo joined
[20:27] <jnthn> Ah, and to be clear: it's parsed as a signature and then reduced because we don't do lookaheads while parsing, but we'd not know what to parse it as until we got to the = or :=

[20:27] <jnthn> So it's parsed as the most general thing

[20:30] *** caterfxo left
[20:31] *** caterfxo joined
[20:36] <AlexDaniel> m: my ($x returns Int --> 5) # wheeeee

[20:36] <camelia> rakudo-moar aa5154e02: ( no output )

[20:37] <AlexDaniel> m: my ($x of Str returns Str returns Str returns Str --> Str)

[20:37] <camelia> rakudo-moar aa5154e02: ( no output )

[20:37] <AlexDaniel> :)

[20:40] *** p6steve joined
[20:40] *** chloekek left
[20:44] <jnthn> Well yeah, it's pretty obvious that if it ignores traits, then you can write whatever crazy thing you wnat ;)

[20:45] <jnthn> My worry is if anyone has got such thing in modules. I wonder if greppable can be convinced to help...

[20:45] <jnthn> .oO( When we have a Raku AST, write astable so we can query the ecosystem by AST )

[20:47] <p6steve> could use some macros, too

[20:53] <AlexDaniel> greppable6: my\s*\(

[20:53] <AlexDaniel> let's see if there are many results for this

[20:53] <greppable6> AlexDaniel, 2223 lines, 390 modules: https://gist.github.com/d0ee9f6e83b83949eab06ad3e9f4cd10

[20:54] <AlexDaniel> uh

[20:54] *** caterfxo left
[20:54] <AlexDaniel> greppable6: my\s*\(.*Int

[20:54] <greppable6> AlexDaniel, 38 lines, 22 modules: https://gist.github.com/f9114712d13be2e2b7e93cea1c1ba453

[20:55] <AlexDaniel> greppable6: my\s*\(.*Int\(

[20:55] <greppable6> AlexDaniel, 3 lines, 1 module: https://gist.github.com/88fdada4f38cccb37bfb07c5b0f2a346

[20:55] <AlexDaniel> greppable6: my\s*\(.*Str\(

[20:55] <greppable6> AlexDaniel, Found nothing!

[20:55] <AlexDaniel> greppable6: my\s*\(.*IO\(

[20:55] <greppable6> AlexDaniel, Found nothing!

[20:56] <AlexDaniel> jnthn: I guess it happens but it's not common

[20:56] <AlexDaniel> greppable6: my\s*\(.*\(\).*=

[20:56] <greppable6> AlexDaniel, 5 lines, 3 modules: https://gist.github.com/3fd9c2c0c3bdf3380da45b08ac681886

[20:57] <AlexDaniel> what else can we search for, default value?

[20:58] <AlexDaniel> greppable6: my\s*\(.*=.*\)\s*=

[20:58] <greppable6> AlexDaniel, 2 lines, 2 modules: https://gist.github.com/6fda2c575009c97a25e34297e5e45117

[20:58] <AlexDaniel> heh

[21:00] *** Fildeon joined
[21:01] *** dg joined
[21:03] *** wamba left
[21:04] *** caterfxo joined
[21:05] *** p6steve left
[21:06] <AlexDaniel> jnthn: R#3587

[21:06] <linkable6> R#3587 [open]: https://github.com/rakudo/rakudo/issues/3587 Signature handling in `my (‚Ä¶)` is too permissive

[21:06] <AlexDaniel> feel free to edit/comment :)

[21:07] <MasterDuke> re searching via AST, what about using Perl6::Parser?

[21:10] *** Fildeon left
[21:15] *** lichtkind joined
[21:15] <lichtkind> in supply cpu burden is on sender?

[21:15] *** stoned75 left
[21:19] *** MasterDuke left
[21:23] <jnthn> The sender pays for the processing costs of what it sends unless you do something to prevent that, yes

[21:24] <jnthn> Whether that's CPU cost or just time cost is another matter; in principle something downstream can `await` in its `whenever` and that won't use CPU, but will mean it's longer until you get back control.

[21:25] <jnthn> (That's the difference between `await` of a Promise or a nested `whenever`: one causes backpressure, the other doesn't)

[21:25] <lichtkind> jnthn++ 

[21:25] <lichtkind> thank you, so actually my slides were correct :)

[21:27] <lichtkind> jnthn: so whenever  does the asking?

[21:31] *** MasterDuke joined
[21:35] <jnthn> Not sure what you mean by "asking"; it subscribes, at least :)

[21:45] *** benlittle left
[21:46] *** benlittle joined
[21:49] *** natrys left
[21:53] *** Tirifto left
[21:59] *** benlittle left
[22:01] *** Mithaldu left
[22:01] *** benlittle joined
[22:02] *** polettixx left
[22:03] *** natrys joined
[22:03] *** Mithaldu joined
[22:07] *** pilne left
[22:07] *** polettixx joined
[22:07] *** sena_kun joined
[22:07] *** pilne joined
[22:08] *** Altai-man_ left
[22:09] *** k-man joined
[22:11] *** dotdotdot left
[22:13] *** dotdotdot joined
[22:15] *** squashable6 left
[22:16] *** squashable6 joined
[22:18] *** natrys left
[22:20] *** benlittle left
[22:20] *** benlittle joined
[22:28] *** _jrjsmrtn joined
[22:29] *** __jrjsmrtn__ left
[22:30] *** NODE left
[22:32] *** NODE joined
[22:39] *** benlittle left
[22:42] *** benlittle joined
[22:59] *** benlittle left
[22:59] *** benlittle joined
[23:16] *** sena_kun left
[23:17] *** pecastro left
[23:37] *** mowcat left
[23:41] *** NODE left
[23:43] *** NODE joined
