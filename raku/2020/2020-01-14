[00:01] <bps> Hmm... Ok. Thanks. The weird thing is, I installed successfully on another laptop a couple days ago. I'll probably try cleaning everything out and going through the installation again... 

[00:02] *** lostinfog joined
[00:06] *** snarkyboojum_ joined
[00:07] *** patrickz joined
[00:09] *** bps left
[00:10] *** sena_kun joined
[00:11] *** patrickb left
[00:12] *** Altai-man_ left
[00:24] *** patrickz left
[00:25] *** ToddAndMargo joined
[00:39] *** wamba left
[00:41] <ToddAndMargo> anyone on newbie duty?

[01:02] *** snarkyboojum_ left
[01:11] <ToddAndMargo> Qustion: when I use "UInt" and "uint", they act exactly the same for me.  One is a subset of Int and the other is a native type, but they act exactly alike (well, for me).  What is the difference between them?

[01:26] <AlexDaniel> one is a native type and the other isn't

[01:26] <AlexDaniel> uint is uint64 I think

[01:26] <AlexDaniel> while UInt can be of any size

[01:30] <ToddAndMargo> Hi Alex,  I though that if you did not give a type a size (uint16, etc.) that it was assigned one on the fly based on what data you fed it.  Am I to presume now that it will always assign the largest size?

[01:31] <ToddAndMargo> What confuses me is if one is a native type and the other is a subset of Int, what do they act exactly the same?

[01:32] <ToddAndMargo> why not what.  Stinking typos

[01:42] *** llfourn left
[01:43] <ToddAndMargo> By any change was UInt just an academic task to show how to duplicate an uint?

[01:47] *** llfourn joined
[02:02] *** wildtrees left
[02:09] *** Altai-man_ joined
[02:12] *** sena_kun left
[02:16] <[Coke]> when you say they act the same - can you provide an example?

[02:19] *** llfourn left
[02:20] <[Coke]> native types can have more compact storage, but that's not going to impact functionality.

[02:21] <[Coke]> ... the fact that they don't have an object associated with them I would expect to impact some functionality, though.

[02:21] <[Coke]> m: my UInt $a = 3; my uint $b = 4; dd $a; dd $b

[02:21] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «Int $a = 3␤4␤»

[02:21] <[Coke]> m: my UInt $a = 3; my uint $b = 4; say $a.^name, $b.^name;

[02:21] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «IntInt␤»

[02:23] <[Coke]> (that explodes on the uint in my REPL, weird.) - but I think what's happening there is that the uint sees you're trying to do something object-y on it, so it upgrades. So then the method call works, but it's not technically being called on the uint.

[02:26] <ToddAndMargo> p6 'my UInt $a = 3; my uint $b = 4; say $a.^name, " ", $b.^name;'Int Intsays they are the same thing.  I am starting to think UInt is an academic exercise on how to create an unsigned integer

[02:34] *** cpan-raku left
[02:34] *** cpan-raku joined
[02:34] *** cpan-raku left
[02:34] *** cpan-raku joined
[02:36] *** llfourn joined
[02:36] <ToddAndMargo> oh wait a minute.  UInt is not constrained.  p6 'my UInt $c = 0x0; $c = $c +| 0x1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; say $c'862718293348820473429344482784628181556388621521298319395315527974911

[02:36] <ToddAndMargo> Up to that point they act exactly the same.

[02:41] <uzl[m]> [Coke]: Yeah, those are outside articles so I went with the articles's original titles ;-). I wonder if lizmat will update the OpenSource articles.

[02:46] *** mahmudov left
[02:54] <[Coke]> ToddAndMargo: yes. when you try to invoke methods on a native type, it converts it first, then calls the method.

[02:55] <[Coke]> https://docs.raku.org/language/nativetypes 

[02:55] <[Coke]> m: my uint $a = 3; say $a ~~ uint; say $a ~~ UInt;

[02:55] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «False␤True␤»

[02:56] <[Coke]> in order to call .ACCEPTS with ~~, it has to put it into a box first.

[02:56] <[Coke]> so yes; if you call methods on it, it looks like the same.

[02:57] * [Coke] wanders off

[03:03] <ToddAndMargo> Now I am confused.  $ p6 'my uint $a = 3; say $a ~~ uint; say $a ~~ UInt; say $a.^name'FalseTrueInt

[03:08] <ToddAndMargo> oh, I get it, it was converted before the method was called.

[03:13] <vrurg> Total memory malfunction: how do I get %?RESOURCES set for the current directory where I debug?

[03:13] <tellable6> hey vrurg, you have a message: https://gist.github.com/4860b7a544513b72626a59971ac8461a

[03:41] <ToddAndMargo> How do I flip the bits?  how do I turn 0xFF00 into 0X00FF?

[03:42] <ToddAndMargo> foudn this, but can figure out what they are saying: https://docs.raku.org/language/operators#prefix_?^

[03:56] *** bps joined
[03:57] <bps> Have a lot of people been reporting errors attempting to install raku from source?

[03:57] <bps> ===SORRY!=== Error while compiling /home/bstahlman/rakudo/home#sources/4166C19B90D62E6DB23143963A5A2C2E658CACB3 (Zef::Distribution)Method 'content' must be implemented by Zef::Distribution because it is required by roles: Distribution.at /home/bstahlman/rakudo/home#sources/4166C19B90D62E6DB23143963A5A2C2E658CACB3 (Zef::Distribution):5

[04:01] *** NODE left
[04:03] *** NODE joined
[04:05] *** NODE left
[04:06] *** NODE joined
[04:10] *** sena_kun joined
[04:12] *** Altai-man_ left
[04:26] <ToddAndMargo> figured it out: $ p6 'my uint8 $c = 0xA5; my uint8 $d =  +^$c; say $d.base(16);'    5A

[04:30] *** lostinfog left
[04:43] *** snarkyboojum_ joined
[04:47] *** lostinfog joined
[04:50] *** bps left
[04:52] *** snarkyboojum_ left
[04:55] *** snarkyboojum_ joined
[05:04] *** guifa2 joined
[05:16] <guifa2> Someone on SO asked about carp

[05:16] *** llfourn left
[05:17] <guifa2> Only thing I can't figure out is how to properly create a new backtrace in the subclassed exception but

[05:17] <guifa2> https://bit.ly/30k7enl (long TIO url so shortened)

[05:18] <guifa2> err, I just realized I'm jumping up to the sub but not preserving the line number within it, oops

[05:28] *** llfourn joined
[05:28] *** squashable6 left
[05:28] <xinming> m: my $t = try { 3/0 } // 'Inf'; "$t".perl.say;

[05:28] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «Attempt to divide by zero when coercing Rational to Str␤  in block <unit> at <tmp> line 1␤␤»

[05:28] <xinming> How can we force the 3/0 to be evaluated?

[05:29] <xinming> m: my $t = try { 3/0 } // 'Inf'; $t.perl.say;

[05:29] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «<1/0>␤»

[05:29] *** squashable6 joined
[05:29] <xinming> I mean this example, I wan the exception to be thrown within try, not delayed to the latter use of $t.

[05:29] *** squashable6 left
[05:31] *** squashable6 joined
[05:34] <guifa2> You have to force an evaluation with it, for example you could do

[05:34] <guifa2> m: my $t = try { my $a = 3/0; sink $a.Str; $a } // 'Inf'; $t.perl.say;

[05:34] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «"Inf"␤»

[05:34] <guifa2> Rats intentionally will go as long as they can, because you can always adjust the denominator at will:

[05:35] <guifa2> m: my $x = 3/0; $x.denominator = 1; say $x

[05:35] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «Cannot modify an immutable Int (0)␤  in block <unit> at <tmp> line 1␤␤»

[05:35] <guifa2> err... well you used to be able to ha

[05:36] <guifa2> (or at least I thought you could.  Either way, the thinking was there are multiple reasons why a Rat might be unevaluatable, and that it would be more useful to allow for checking that later than force it to be done earlier)

[05:43] *** llfourn left
[05:49] *** NODE left
[05:51] *** NODE joined
[05:56] *** [Coke] left
[06:03] *** lostinfog left
[06:09] *** Altai-man_ joined
[06:12] *** sena_kun left
[06:17] *** sauvin joined
[06:18] *** llfourn joined
[06:24] *** llfourn left
[06:28] *** ToddAndMargo left
[06:56] *** llfourn joined
[06:56] *** stoned75 left
[07:01] *** llfourn left
[08:01] *** quotable6 left
[08:01] *** bloatable6 left
[08:01] *** nativecallable6 left
[08:01] *** committable6 left
[08:01] *** sourceable6 left
[08:01] *** releasable6 left
[08:01] *** bisectable6 left
[08:01] *** greppable6 left
[08:01] *** reportable6 left
[08:01] *** notable6 left
[08:01] *** unicodable6 left
[08:01] *** benchable6 left
[08:01] *** coverable6 left
[08:01] *** statisfiable6 left
[08:01] *** shareable6 left
[08:01] *** squashable6 left
[08:02] *** squashable6 joined
[08:02] *** nativecallable6 joined
[08:03] *** sourceable6 joined
[08:03] *** notable6 joined
[08:03] *** committable6 joined
[08:03] *** quotable6 joined
[08:03] *** reportable6 joined
[08:03] *** releasable6 joined
[08:03] *** statisfiable6 joined
[08:04] *** benchable6 joined
[08:04] *** shareable6 joined
[08:04] *** bisectable6 joined
[08:04] *** bloatable6 joined
[08:04] *** coverable6 joined
[08:04] *** greppable6 joined
[08:04] *** unicodable6 joined
[08:10] *** sena_kun joined
[08:12] *** Altai-man_ left
[08:18] *** xinming left
[08:19] *** xinming joined
[08:34] *** rindolf joined
[08:57] *** llfourn joined
[09:02] *** llfourn left
[09:13] *** pedr0 joined
[09:14] *** pedr0 left
[09:17] <xinming> guifa2: Thanks, I use something like,  try { my $a = Num(3/0) } // 'Inf';

[09:21] *** pedr0 joined
[09:22] <pedr0> hello everybody - I am a bit new to the perl6 world so forgive me the silly question. I'd like to run a command with 'run', get the output and run a regex on it, then loop through all grouping command.

[09:23] <pedr0> I've managed to run the command and get the output, but I am stuck at the point of running a regex on it

[09:24] *** scimon joined
[09:24] *** rindolf left
[09:29] <xinming> pedr0: If you captured output all at once, You can use  my $output = qx:/command/;  then   $output ~~ //;

[09:31] <pedr0> yeah, but how can I iterate through the captured groups ?

[09:33] <xinming> You can check the $/ var

[09:33] <xinming> if it's named capture, You can have $<capture-name>

[09:33] <xinming> If it's positioned, You can use  $0 $1 $2 ...

[09:34] *** kensanata joined
[09:34] *** rindolf joined
[09:37] <pedr0> thanks

[09:39] *** wamba joined
[09:40] *** wamba left
[09:56] *** fingolfin70 joined
[09:56] <fingolfin70> Hello! Where can I find out how to properly create and apply my own exception types?

[09:57] <Xliff> fingolfin70: https://docs.perl6.org/language/exceptions

[09:57] <fingolfin70> I read https://docs.perl6.org/language/exceptions, but there is only about using.

[09:58] <Xliff> Creating an exception is as simple as defining a class that inherits from exception. "class X::My::Exception is exception { }"

[09:58] <Xliff> Then to use it, X::MyL::Exception.new.throw

[09:58] <Xliff> X::My::Exception.new.throw # Oops

[09:59] <Xliff> So... to sum it up PROPERLY!

[09:59] <Xliff> m: class X::My::Exception is Exceptionl; X::My::Exception.new.throw

[09:59] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤'X::My::Exception' cannot inherit from 'Exceptionl' because it is unknown.␤Did you mean one of these?␤    'Exception'␤    'Exceptions'␤␤at <tmp>:1␤»

[09:59] <Xliff> m: class X::My::Exception is Exception; X::My::Exception.new.throw

[09:59] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Semicolon form of 'class' without 'unit' is illegal.  You probably want to use 'unit class'␤at <tmp>:1␤------> 3class X::My::Exception is Exception;7⏏5 X::My::Exception.new.throw␤»

[09:59] <Xliff> m: class X::My::Exception is Exception {}; X::My::Exception.new.throw

[09:59] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «Died with X::My::Exception␤  in block <unit> at <tmp> line 1␤␤»

[10:00] <Xliff> There you go...

[10:00] <fingolfin70> Thanks. I was hoping that there was detailed information. But if not, then I’ll get along with it.

[10:00] <Xliff> Between what I just showed you, the exeption page, and https://docs.perl6.org/type/Exception

[10:01] <Xliff> That should be all you really need. If not, please ask your questions here.

[10:02] <Xliff> To help us improved the documentation, please suggest changes, here... or even better, let us know where the docs fall short by raising an issue, here:  https://github.com/Raku/doc/issues

[10:07] <Xliff> m: $a = 'const * char *'; say $a ~~ m:g/

[10:07] <Xliff> 8

[10:07] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$a' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5$a = 'const * char *'; say $a ~~ m:g/␤»

[10:07] <Xliff> m: $a = 'const * char *'; say $a ~~ m:g/'*'/

[10:07] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$a' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5$a = 'const * char *'; say $a ~~ m:g/'*'␤»

[10:07] <Xliff> m: my $a = 'const * char *'; say $a ~~ m:g/'*'/

[10:07] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «(｢*｣ ｢*｣)␤»

[10:08] <Xliff> m: my $a = 'const * char *'; ($a ~~ m:g/'*'/).elems,sat

[10:08] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    sat used at line 1. Did you mean 'set', 'say'?␤␤»

[10:08] <Xliff> m: my $a = 'const * char *'; ($a ~~ m:g/'*'/).elems.asy

[10:08] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «No such method 'asy' for invocant of type 'Int'. Did you mean 'any'?␤  in block <unit> at <tmp> line 1␤␤»

[10:08] <Xliff> m: my $a = 'const * char *'; ($a ~~ m:g/'*'/).^name.say

[10:08] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «List␤»

[10:08] <Xliff> m: my $a = 'const * char *'; ($a ~~ m:g/'*'/).Array.elems.say

[10:08] <camelia> rakudo-moar 0e9f96ea9: OUTPUT: «2␤»

[10:09] *** Altai-man_ joined
[10:12] *** sena_kun left
[10:28] *** pedr0 left
[10:32] *** laama left
[10:52] *** NODE left
[10:55] *** NODE joined
[10:56] *** NODE left
[10:57] *** NODE joined
[10:58] *** llfourn joined
[11:04] *** llfourn left
[11:13] <Kaiepi> releasable6, status

[11:13] <releasable6> Kaiepi, Next release will happen when it's ready. 1 blocker. 0 out of 438 commits logged

[11:13] <releasable6> Kaiepi, Details: https://gist.github.com/015cf3abc225ab6cdf9c54f14bc03a62

[11:19] *** llfourn joined
[11:31] *** kensanata left
[11:35] *** NODE left
[11:36] *** NODE joined
[11:38] *** laama joined
[11:56] *** Doc_Holliwood left
[11:57] *** Doc_Holliwood joined
[12:10] *** sena_kun joined
[12:12] *** Altai-man_ left
[12:19] *** NODE left
[12:21] *** NODE joined
[12:29] *** fingolfin70 left
[12:31] *** kensanata joined
[12:41] *** NODE left
[12:42] *** NODE joined
[12:44] *** NODE left
[12:45] *** NODE joined
[12:46] *** xinming left
[12:47] *** xinming joined
[12:50] *** wamba joined
[12:50] *** NODE left
[12:52] *** NODE joined
[12:53] *** NODE left
[12:54] *** NODE joined
[12:55] *** wamba left
[13:15] *** wamba joined
[13:15] *** [Coke] joined
[13:15] *** [Coke] left
[13:15] *** [Coke] joined
[13:15] *** snarkyboojum_ left
[13:18] *** llfourn left
[13:19] *** domidumont joined
[13:19] *** NODE left
[13:21] *** lucasb joined
[13:21] *** NODE joined
[13:53] *** xinming left
[13:54] *** xinming joined
[14:05] * lizmat clickbaits https://rakudoweekly.blog/2020/01/13/2020-02-important-things/

[14:07] *** xinming left
[14:07] *** xinming joined
[14:09] *** Altai-man_ joined
[14:12] *** sena_kun left
[14:13] <[Coke]> lizmat++, as always.

[14:25] *** kensanata left
[14:35] *** Guest78373 left
[14:41] *** xinming left
[14:42] *** xinming joined
[14:50] *** Poohman joined
[15:01] <Geth> ¦ doc: Kaiepi++ created pull request #3160: [WIP] Begin documenting HOW archetypes and document parameterization

[15:01] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3160

[15:17] *** pmurias joined
[15:17] <pmurias> hi

[15:17] <tellable6> 2020-01-12T21:58:44Z #raku-dev <AlexDaniel> pmurias: what's the status of https://github.com/perl6/perl6-parcel-example ?

[15:17] <tellable6> 2020-01-12T22:07:42Z #raku-dev <AlexDaniel> pmurias: also https://github.com/perl6/parcel-plugin-nqp

[15:19] <pmurias> AlexDaniel`: those repos are usefull if you want to parcel up rakudo.js apps for use in the browser

[15:20] <pmurias> AlexDaniel`: I haven't done anything raku related in a while (mostly focused on job interview preparation, had a google phone screen today)

[15:20] <pmurias> AlexDaniel`: rakudo.js stuff should be migrated to parcel 2.0

[15:48] *** Guest78373 joined
[15:53] *** NODE left
[15:55] *** NODE joined
[15:56] *** NODE left
[15:58] *** NODE joined
[16:04] *** kensanata joined
[16:10] *** sena_kun joined
[16:12] *** Altai-man_ left
[16:13] *** pmurias left
[16:24] *** xinming left
[16:25] *** xinming joined
[16:26] *** domidumont left
[16:29] *** Geth left
[16:36] *** Geth joined
[16:43] *** Kaiepi left
[16:44] *** Kaiepi joined
[17:00] *** NODE left
[17:02] *** NODE joined
[17:03] <xinming> What is the right way to redirect the stdout to different handle please?

[17:03] <xinming> I tried something like...     temp $*OUT = "test-stdout.txt".IO;       But I got error

[17:03] <xinming> somethign like    Too many positionals passed; expected 1 argument but got 2

[17:04] <jnthn> You need to open the file, so there's a file handle there, not a path

[17:04] <jnthn> temp $*OUT = open "test-stdout.txt", :w;

[17:05] <xinming> Thanks, it worked.

[17:05] <xinming> m: (open "test.txt").WHAT.say;    "test-io.txt".IO.WHAT.say;

[17:05] <camelia> rakudo-moar da9929c89: OUTPUT: «(Failure)␤(Path)␤»

[17:05] <xinming> m: (open "/dev/null").WHAT.say;    "test-io.txt".IO.WHAT.say;

[17:05] <camelia> rakudo-moar da9929c89: OUTPUT: «(Handle)␤(Path)␤»

[17:06] *** ab5tract joined
[17:10] *** bps joined
[17:11] *** NODE left
[17:12] *** NODE joined
[17:13] <xinming> Some one asked here before, Is it possible to change args to race and hyper prefix??

[17:13] <xinming> what I thought maybe something like   race:batch<4>:degree<3> would be nice. :-)

[17:14] *** NODE left
[17:14] <xinming> race:batch<4>:degree<3> for @xxx -> $yy { ... }

[17:15] <ab5tract> \@xxx.race: &func :batch(4)

[17:15] <ab5tract> backslash was to disable the webchat thiny

[17:15] <ab5tract> *thingy

[17:15] *** NODE joined
[17:16] *** lostinfog joined
[17:16] <ab5tract> xinming: basically those settings are very easy to pass to the race when used in method form

[17:17] *** NODE left
[17:18] *** kensanata left
[17:18] *** NODE joined
[17:20] *** NODE left
[17:21] *** kensanata joined
[17:23] <xinming> I don't mean the &func thing,

[17:23] <xinming> I wish something to support at statement level.

[17:23] <xinming> I know @array.race(...).map({ });  will do the job

[17:23] <ab5tract> just put the block you are supplying the for loop as an argument to the race method 

[17:24] <jnthn> You can say `race for @foo.race(:batch(1)) { }`. I don't think there'll be sugar for this, since the goal really is that in most cases it picks an appropriate batch/arity for you, and so you'd need to specify them less.

[17:25] <ab5tract> nvm, i think i forgot the race syntax, sorry xinming

[17:25] <xinming> ab5tract: It's ok. :-)

[17:25] <xinming> jnthn: the algorithm to choose degree in race statement prefix is the same as one used in .race method, right?

[17:26] <ab5tract> xinming might be a fun project to try defining your own sugar op for it :)

[17:26] * guifa2 is packaging up a Raku Carp module.  Should it just be "Carp" or "Exceptions::Carp" or?

[17:26] *** NODE joined
[17:27] *** NODE left
[17:27] <jnthn> xinming: Yes

[17:27] <lizmat> guifa2++  # glad I don't have to do that

[17:28] <lizmat> I would call it just Carp and if it adheres to the P5 interface, mark it as such

[17:28] *** NODE joined
[17:30] *** scimon left
[17:30] *** NODE left
[17:33] <guifa2> lizmat: for right now, I just took the basic carp/croak/cuckle/confess output behaviors and replicated (full trace vs single line, and throwing vs just outputing to $*ERR).  Might investigate if I can capture the arguments like it seems the P5 one does

[17:34] *** NODE joined
[17:37] *** NODE left
[17:39] <guifa2> (it looks like I can't, at least not without digging into deeper internals or implementing a very different way, oh well, the baseline stuff should be enough for now)

[17:40] <lizmat> yeah, baseline is good  :-)

[17:41] *** NODE joined
[17:42] *** xinming left
[17:43] *** xinming joined
[17:54] <xinming> m: my @h = <a b c>; my @a = <x y z>; @h.map(-> $h { @a.map({ "$_:$h" }).Slip }).perl.say;

[17:54] <camelia> rakudo-moar da9929c89: OUTPUT: «("x:a", "y:a", "z:a", "x:b", "y:b", "z:b", "x:c", "y:c", "z:c").Seq␤»

[17:56] <xinming> In this example, Is there other way to not write the  .Slip  the list within list, But still does the Slip thing?   I don't mean the  | op.

[18:03] <HollisterSmiley> m: say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4);  # OUTPUT: «False␤»

[18:03] <camelia> rakudo-moar da9929c89: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Bogus statement␤at <tmp>:2␤------> 3<BOL>7⏏5»␤    expecting any of:␤        prefix␤        term␤»

[18:03] <HollisterSmiley> m: say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4);

[18:03] <camelia> rakudo-moar da9929c89: OUTPUT: «True␤»

[18:03] <HollisterSmiley> evalable: say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4);

[18:04] <evalable6> HollisterSmiley, rakudo-moar da9929c89: OUTPUT: «True␤»

[18:04] <HollisterSmiley> As per documentation this should say False

[18:07] <lizmat> HollisterSmiley: I disagree

[18:07] <lizmat> or are you referring to the containerness of $(2,3) ?

[18:07] <HollisterSmiley> With the documentation?

[18:08] <HollisterSmiley> I am referring to the docs saying it should return False

[18:08] <HollisterSmiley> And yet it doesn't. 

[18:08] <HollisterSmiley> https://docs.raku.org/language/list#___top

[18:08] <HollisterSmiley> last example in the paragraph

[18:09] <HollisterSmiley> https://docs.raku.org/language/list#Slips that is

[18:09] *** Altai-man_ joined
[18:10] <lizmat> hmmm... but "(1, |$(2, 3), 4)" is functionally equivalent to (1, slip($(2, 3)), 4)

[18:10] <lizmat> m: dd (1, slip($(2, 3)), 4)

[18:10] <camelia> rakudo-moar da9929c89: OUTPUT: «(1, 2, 3, 4)␤»

[18:10] <lizmat> m: dd (1, |$(2, 3), 4)

[18:10] <camelia> rakudo-moar da9929c89: OUTPUT: «(1, 2, 3, 4)␤»

[18:10] <HollisterSmiley> That's what I thought. Probably just wrong the docs is.

[18:10] <lizmat> yes, /me thinks

[18:12] *** sena_kun left
[18:13] <ab5tract> i wonder if that documentation is pre-Great List Refactor?

[18:13] <Geth> ¦ doc: 2dd56f758c | (Elizabeth Mattijsen)++ | doc/Language/list.pod6

[18:13] <Geth> ¦ doc: Fix output value

[18:13] <Geth> ¦ doc: 

[18:13] <Geth> ¦ doc: (1, |$(2, 3), 4) is functionally equivalent with (1, slip($(2, 3)), 4)

[18:13] <Geth> ¦ doc: so both should give the same answer.  Whether or not containerness if

[18:13] <Geth> ¦ doc: the list should be taken into account, is possibly another question.

[18:13] <Geth> ¦ doc: But not a documentation issue.

[18:13] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/2dd56f758c

[18:14] <lizmat> ab5tract: could well be

[18:18] <HollisterSmiley> lol

[18:18] <HollisterSmiley> i was about to do it, 

[18:19] *** wildtrees joined
[18:19] <lizmat> HollisterSmiley: sorry  :-)

[18:20] *** wildtrees left
[18:20] *** wildtrees joined
[18:21] <HollisterSmiley> but still. what does , "so it only affects a single

[18:21] <HollisterSmiley> value, but unlike the above options, it will break L<Scalars|/type/Scalar>." mean

[18:22] <HollisterSmiley> I mean, the example you just fixed was related to this very statement

[18:22] <HollisterSmiley> i'm thinking, it should also go. 

[18:23] *** wildtrees left
[18:23] *** wildtrees joined
[18:24] <lizmat> HollisterSmiley: possibly, but that would require more thought / discussion

[18:24] <lizmat> and possibly a doc issue  :-)

[18:36] <guifa2> lizmat: will probably finish up Carp tonight — having a few edge case issues and about ot have to go into $day-job.  

[18:36] <lizmat> guifa2+

[18:37] <lizmat> +

[18:41] <xinming> I think Slip thing and @array[]  thing is a bit confusing to perl5 users at first.

[18:41] <xinming> Slip will be the behavior in perl5 we want. the @array[] returns an Seq

[18:43] *** wamba left
[18:44] *** bps left
[18:47] *** kensanata left
[18:49] <lizmat> m: my @a; dd @a[]   # @array[] does not return a Seq?  or is that what you want ?

[18:49] <camelia> rakudo-moar 826c3ead8: OUTPUT: «Array @a = []␤»

[18:50] <xinming> hmm, Ignore me, my bad,

[18:50] <guifa2> is there a way to have a module set variables using :named-parameters on use?  it seems if you include a EXPORT::foo package, its block gets called whether you intend to load it or not

[18:50] <xinming> I have example wrong. :-)

[18:55] *** chloekek joined
[18:55] <guifa2> Or should I just do

[18:56] <guifa2> use Module :export, :export, :export, <multiple options in a string like this to get caught by sub EXPORT>

[18:56] <lizmat> there's a way to do named params on a use

[18:57] <HollisterSmiley> Whatever I touch I break, eh lizmat ;-)

[18:57] <lizmat> sounds familiar  :)

[18:59] <xinming> Is it possible to get how much the :degree and :batch value be calcuated on this machine?

[19:00] <ab5tract> guifa2 check out the dispatch table example from the export docs

[19:01] <ab5tract> you can programmatically include whatever you want into the importing namespace based on arguments to use

[19:02] <ab5tract> 'dispatch table' eqv 'map of functions keyed on function name'

[19:02] *** mahmudov joined
[19:04] <lizmat> xinming: afaik, they are public attributes

[19:04] <lizmat> pretty sure :$batch = 64 and :$degree = cpucores / 2

[19:05] <lizmat> hmmmm apparently not:

[19:05] <lizmat> method hyper(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4) {

[19:06] <lizmat> method race(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4) {

[19:13] <xinming> Yea, They are hard coded.

[19:13] <xinming> in gen/moar/CORE.c.setting

[19:13] *** stoned75 joined
[19:14] *** NODE left
[19:16] *** NODE joined
[19:19] *** xinming left
[19:19] *** xinming joined
[19:22] <guifa2> ab5tract: so it seems that the OUR::{'foo'} export symbols are only exported in the case that a named parameter is passed BUT any code inside of the block is run

[19:24] <guifa2> I'll probably just do it

[19:25] <guifa2> use Carp :confess, :croak, :cluck, <block ofun>

[19:25] *** mahmudov left
[19:26] *** sauvin left
[19:27] *** Poohman left
[19:27] <ab5tract> guifa2 is it easy to gist?

[19:28] <ab5tract> here is the pattern i mentioned https://github.com/ab5tract/Terminal-Print/blob/8f6278ebdeab3ea929484bc9ca5524beb33dcfd7/lib/Terminal/Print.pm6#L350

[19:29] <ab5tract> but it might not apply to your case :/

[19:30] <guifa2> ab5tract: yeah, that sub EXPORT() only captures positionals =\

[19:30] *** rypervenche left
[19:31] <ab5tract> ooof, now i grok you properly

[19:31] *** maettu left
[19:32] <guifa2> ab5tract: https://gist.github.com/alabamenhu/81eecb708148f53a530ececd437f80a9

[19:32] <guifa2> If you go "use Carp" you'll see that even though the confess symbol wasn't imported, you still get the output of the 'say' in the same block. I'm sure that there's a reason for it, but it's unexpected

[19:34] *** rypervenche joined
[19:37] <lizmat> https://github.com/rakudo/rakudo/pull/3424   # xinming 

[19:40] * guifa2 . o O ( plus I'm sure that using named parameters the way I'm trying to is a total abuse of the way the export system was designed )

[19:43] <ab5tract> guifa2 what happens if you wrap the &confess in a block?

[19:44] <ab5tract> i don't know if this is the output i'm supposed to get (haven't used confess in ages) but.. 

[19:44] <ab5tract> $ perl6 -Ilib -e 'use Carp :confess; confess(die "obviously")'didn't call ofunobviously  in block <unit> at -e line 1

[19:44] *** wamba joined
[19:44] <ab5tract> ah, the new lines didn't translate

[19:45] <ab5tract> so it seems that this change might do the trick? 

[19:45] <ab5tract> my package EXPORT::DEFAULT { OUR::{'&carp'}    := { &carp(@_) }  }

[19:45] <guifa2> ab5tract: notice that it said "didn't call ofun" (but you didn't say use Carp :confess, :ofun)

[19:46] <ab5tract> egads

[19:46] <guifa2> hmm I'll try that out later and see if it works.  Worst case scenario I can just add the options in later for a future version.  

[19:47] <ab5tract> guifa2 well it stopped complaining about not having a confess in the namespace

[19:47] <ab5tract> but i'm not sure it was actually confessing :(

[19:47] <ab5tract> and indeed the didnt call ofun was triggering

[19:48] <ab5tract> i think this export logic might deserve some revisiting

[19:48] <ab5tract> every time i touch it i feel like it doesn't exactly map to how i would expect a Raku solution to order itself

[19:49] <ab5tract> which would make since if it since it would have been one of the earliest and most bedrock functionalities to get into place before further work

[19:49] <ab5tract> *which would make sense

[19:50] <guifa2> I think 95% of it works fairly straightforwardly

[19:50] <ab5tract> *which would make sense since    (:

[19:50] <guifa2> The other 5% is tricky, but it's also for people trying to do weird things, so it's not tooooo evil

[19:51] <ab5tract> the general use case of specifying is export(:tag) does work quit well

[19:52] <guifa2> In other cases, where you want to enable loooots of options, it's almost easier to export subs for it

[19:52] <guifa2> set-foo-option(crazy arguments)

[19:52] <ab5tract> ah, that's a thought

[19:54] <ab5tract> but here's the thing

[19:55] <ab5tract> i feel like i encounter this weirdness whenever i want to enable a default behavior while providing extensibility

[19:55] <ab5tract> that sounds like the kind of corner i don't expect to encounter in a perly world

[19:57] *** mahmudov joined
[19:57] <guifa2> OTOH I suppose I could make my life easy, and just export all four (the default in Perl5 was to export three of the four), and have use Carp <optionA optionB>; 

[20:00] <ab5tract> i mean, if a camel wants to carp, you think they aren't gonna confess to wanting a block until they've had all their ofun? 

[20:01] <ab5tract> i don't properly remember the four exports of carp, i just riffed on the exports in your gist :)

[20:02] <HollisterSmiley> "i mean, if a camel wants to carp, you think they aren't gonna confess to wanting a block until they've had all their ofun?" Imagine saying that to the guys at starbucks. they call the police on you for vrazy talk :-D

[20:04] *** guifa2 left
[20:04] <ab5tract> i'll be carping about my camel confession rights till i die!! :') 

[20:05] <HollisterSmiley> or maybe they'd just think you work in marketing

[20:06] <guifa> hahaha

[20:06] <ab5tract> 2020 the return of the camel.. now with butterfly wings!

[20:07] <guifa> Oh and crap I messed up my names in that gist anyways 

[20:08] <guifa> basically, carp = warn (but from caller side), cluck = carp + backtrace, croak = die (but from caller side), confess = croak + backtrace

[20:09] <Grinnz> I'd say you should get away from our weird Perl names while you can, but you'd have to come up with something better ;)

[20:09] *** cpan-raku left
[20:09] <ab5tract> Grinnz lol

[20:09] *** xinming left
[20:09] <guifa> Grinnz: the whole reason for the :ofun opion was to have a frog emoji with a thought bubble saying the croak message, a fish emoji with a thought bubble saying the carp message, etc ;-)

[20:10] <ab5tract> hahahahaha

[20:10] *** cpan-raku joined
[20:10] *** cpan-raku left
[20:10] *** cpan-raku joined
[20:10] <ab5tract> now i can get behind that kind of ofun@

[20:10] <ab5tract> !

[20:11] *** xinming joined
[20:11] *** sena_kun joined
[20:11] <guifa> croak “I’m a frog”

[20:11] <guifa> 🐸 . o O ( I’m a frog ) in block <unit> at foo.raku line 1

[20:11] <Grinnz> 🐸🐟🐔🙏

[20:12] *** Altai-man_ left
[20:18] *** mahmudov left
[20:20] <HollisterSmiley> m: my \🐟 = 1;

[20:20] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my␤at <tmp>:1␤------> 3my7⏏5 \🐟 = 1;␤»

[20:20] <HollisterSmiley> m: my \_🐟 = 1;

[20:20] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Term definition requires an initializer␤at <tmp>:1␤------> 3my \_7⏏5🐟 = 1;␤»

[20:21] <HollisterSmiley> m: my \A🐟 = 1;

[20:21] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Term definition requires an initializer␤at <tmp>:1␤------> 3my \A7⏏5🐟 = 1;␤»

[20:21] <HollisterSmiley> m: my \A🐟 := 1;

[20:21] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Term definition requires an initializer␤at <tmp>:1␤------> 3my \A7⏏5🐟 := 1;␤»

[20:21] *** mahmudov joined
[20:22] <HollisterSmiley> m: sub 🐟 { 1; }

[20:22] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub7⏏5 🐟 { 1; }␤    expecting any of:␤        new name to be defined␤»

[20:22] <HollisterSmiley> too bad

[20:24] <HollisterSmiley> m: sub postfix<🐟>($fish) { 1; }

[20:24] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub postfix7⏏5<🐟>($fish) { 1; }␤    expecting any of:␤        new name to be defined␤»

[20:24] <HollisterSmiley> m: sub postfix:<🐟>($fish) { 1; }

[20:24] <camelia> rakudo-moar a81b28a4d: ( no output )

[20:26] <HollisterSmiley> m: sub postfix:<🐟>($fish) { 🐟 x $fish; }; say 8🐟

[20:26] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Bogus statement␤at <tmp>:1␤------> 3sub postfix:<🐟>($fish) {7⏏5 🐟 x $fish; }; say 8🐟␤    expecting any of:␤        prefix␤        term␤»

[20:26] <HollisterSmiley> m: sub postfix:<🐟>($fish) { '🐟' x $fish; }; say 8🐟

[20:26] <camelia> rakudo-moar a81b28a4d: OUTPUT: «🐟🐟🐟🐟🐟🐟🐟🐟␤»

[20:26] <HollisterSmiley> hihi

[20:26] *** ryan88 joined
[20:26] <HollisterSmiley> this language is amazing

[20:27] <ryan88> The docs say `==` is the Numeric equality operator, but it seems to work fine for Bool... should I use == or ~~ for Bool?

[20:28] <HollisterSmiley> None of the above. It's bool

[20:28] <ryan88> oh... shoot.. what am I thinking smh

[20:29] <HollisterSmiley> m: sub foo { True }; say "this is a code smell" if f() ~~ True

[20:29] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5===␤Undeclared routine:␤    f used at line 1␤␤Other potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at <tmp>:1␤    ------>…»

[20:29] <HollisterSmiley> m: sub foo { True }; say "this is a code smell" if foo() ~~ True

[20:29] <camelia> rakudo-moar a81b28a4d: OUTPUT: «Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at <tmp>:1␤    ------> 3 say "this is a code smell" if foo() ~~ 7⏏5True␤this is a code sm…»

[20:29] <HollisterSmiley> m: sub foo { True }; say "this is a code smell" if foo() == True

[20:29] <camelia> rakudo-moar a81b28a4d: OUTPUT: «this is a code smell␤»

[20:31] *** wamba left
[20:33] <tobs> what does the hint mean by "use :so [...] instead"?

[20:33] <tobs> m: temp $_ = False; say :so

[20:33] <camelia> rakudo-moar a81b28a4d: OUTPUT: «Unexpected named argument 'so' passed␤  in block <unit> at <tmp> line 1␤␤»

[20:34] <tobs> m: say False:so

[20:34] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Invalid type smiley 'so' used in type name␤at <tmp>:1␤------> 3say False:so7⏏5<EOL>␤    expecting any of:␤        pair value␤»

[20:34] <tobs> m: temp $_ = False; say "true" if :so

[20:34] <camelia> rakudo-moar a81b28a4d: OUTPUT: «true␤»

[20:36] <[Coke]> *.so, not :so

[20:36] <[Coke]> m: sub foo { True }; say "this is a code smell" if foo().so

[20:36] <camelia> rakudo-moar a81b28a4d: OUTPUT: «this is a code smell␤»

[20:37] <tobs> [Coke]: it lists :so and *.so

[20:37] <tobs> so I doubt :so was a typo

[20:38] <ab5tract> m: temp $_ = False; say "true" if .so

[20:38] <camelia> rakudo-moar a81b28a4d: ( no output )

[20:39] <ab5tract> tobs is that in the docs somewhere? 

[20:40] <[Coke]> tobs - oops, so it does.

[20:40] <[Coke]> apologies.

[20:40] <ab5tract> i believe that it isn't a typo, just wondering where that behavior is coming from

[20:40] <tobs> ab5tract: a method call without invocant applies to the topic $_. It's in the docs for sure, but I haven't found it yet

[20:41] <ab5tract> :so isn't a method call itself

[20:41] <ab5tract> if it causes a method call, it would be something like self.self(:so)

[20:41] <ab5tract> m: say Any:so;

[20:41] <camelia> rakudo-moar a81b28a4d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Invalid type smiley 'so' used in type name␤at <tmp>:1␤------> 3say Any:so7⏏5;␤    expecting any of:␤        pair value␤»

[20:42] <ab5tract> m: temp $_ = Any; say :so;

[20:42] <camelia> rakudo-moar a81b28a4d: OUTPUT: «Unexpected named argument 'so' passed␤  in block <unit> at <tmp> line 1␤␤»

[20:42] <tobs> ab5tract: there's a mention in the OOP tutorial: https://docs.raku.org/language/classtut#index-entry-methods

[20:42] <ab5tract> m: temp $_ = Any; say "true" if :so;

[20:42] <camelia> rakudo-moar a81b28a4d: OUTPUT: «true␤»

[20:42] <ab5tract> m: temp $_ = Any; say "true" if .so;

[20:42] <camelia> rakudo-moar a81b28a4d: ( no output )

[20:42] <ab5tract> there it is

[20:43] <ab5tract> looks like an unwired dispatch error

[20:43] <ab5tract> :so and .so should have the same output

[20:44] <ab5tract> jnthn ^^ does that parse to you?

[20:44] <ab5tract> m: temp $_ = Any; say "true" if :so; say "true" if .so; 

[20:44] <camelia> rakudo-moar a81b28a4d: OUTPUT: «true␤»

[20:44] *** libertas left
[20:45] *** wamba joined
[20:45] <ab5tract> or lizmat or other second eyes?

[20:46] <ab5tract> tobs from my standpoint you should feel confident reporting that as a bug on github

[20:46] <lizmat> I'm surprised "if :so" even parses

[20:46] <tobs> that warning was introduced in 2010 apparently and there's a sibling warning that mentions :!so, so it really seems like it's intended as an adverb

[20:47] <tobs> will bug if you don't mind

[20:56] <tobs> ↑ R#3425

[21:05] *** melezhik joined
[21:06] *** rindolf left
[21:11] *** mahmudov left
[21:12] *** squashable6 left
[21:13] *** squashable6 joined
[21:19] *** pmurias joined
[21:21] <Kaiepi> greppable6, Parameter.new

[21:22] <greppable6> Kaiepi, 25 lines, 6 modules: https://gist.github.com/63cf57c63ad18c7b6286fafe2bc21cb2

[21:32] *** libertas joined
[21:33] <lucasb> IIUC, '$foo ~~ :bar' is equivalent to ?($foo.bar), and '$foo ~~ :!bar' equivalent to !($foo.bar)

[21:34] <lucasb> I expect it to work with ~~ and given/when as it does. I *don't* expect it to work if "if :so" (meaning to call $_.so)

[21:35] *** libertas_ joined
[21:35] <lucasb> 'if :foo {...}' is ok. It's just checking the truthiness of a Pair object, which is always true.

[21:40] <ab5tract> lucasb interesting boundary distinction! mind sharing on the ticket?

[21:40] <ab5tract> https://github.com/rakudo/rakudo/issues/3425

[21:41] *** llfourn joined
[21:42] <lizmat> fwiw, I find that syntax *very* confusing

[21:42] <lizmat> I know it was intended to be used on IO::Path objects

[21:43] <lizmat> so you could say "filename".IO ~~ :r

[21:43] <lizmat> but yuck

[21:44] <ab5tract> lizmat if i read lucasb's examples correctly, it looks more like this is sugar around truthifying the results of a method call in list format?

[21:44] <AlexDaniel> lizmat: I know that it exists but I never used it

[21:44] <AlexDaniel> just doing .r on IO is clearer

[21:44] <lizmat> well, for a long time I've not known about it, and I never used it

[21:45] <lizmat> feels to me this feature falls in the "overengineered" section  :-)

[21:45] <ab5tract> lizmat where in the git org do we pour these things now? :)

[21:46] <lizmat> perl6/problem-solving I think ?

[21:46] <AlexDaniel> ab5tract: bugs https://github.com/rakudo/rakudo/issues ; requests to change the language https://github.com/Raku/problem-solving/issues/new/choose

[21:47] <ab5tract> AlexDaniel awesome work with that issues path chooser!!

[21:48] <ab5tract> in the requests to change link. i really like the way it invites critique and discussion

[21:50] <AlexDaniel> actually, I think we should be able to force different order there

[21:50] <AlexDaniel> maybe by simply adding numbers like “1. ” to template titles

[21:53] <ab5tract> that should work

[21:55] <ab5tract> regardless, your attention to detail is appreciated AlexDaniel :)

[21:56] <AlexDaniel> ah no, then the number will appear in all kinds of places :S

[21:56] <ab5tract> yuk

[22:09] *** Altai-man_ joined
[22:12] *** sena_kun left
[22:13] <cpan-raku> New module released to CPAN! ScaleVec (0.0.6) by 03SAMGWISE

[22:17] *** llfourn left
[22:28] <guifa> HollisterSmi: you can do it, but you have to make 🐟 a term first

[22:39] <ab5tract> guifa in fact, you can take an entire unicode category and dynamically create a sub term:<T> { T }  

[22:39] <ab5tract> guifa in fact, you can take an entire unicode category and dynamically create a sub term:<T> { "T" }  

[22:40] <ab5tract> for all animals, for instance

[22:40] *** guifa2 joined
[22:40] <ab5tract> or in this case, sub postfix:<T>(Int $n) { "T" xx 8 }

[22:42] <ab5tract> erg, sorry, calling my own get out tonight. much love to all, as always! <3  #raku

[22:42] *** ab5tract left
[22:46] *** ryan88 left
[22:46] *** chloekek left
[22:56] *** NODE left
[22:58] <guifa2> what's the best way to prevent the REPL from returning a value off of a sub (for when it makes no sense)?

[22:58] *** NODE joined
[23:00] *** NODE left
[23:00] <[Coke]> It's always going to get the value, even if the value is Nil

[23:00] <[Coke]> you could add "; True" to your input

[23:01] <guifa2> Ah okay

[23:01] <guifa2> I won't consider it a bug in my module then :-)

[23:01] *** NODE joined
[23:03] *** NODE left
[23:04] *** NODE joined
[23:06] <cpan-raku> New module released to CPAN! Date::Names (2.0.4) by 03TBROWDER

[23:21] *** guifa2 left
[23:23] <kybr>  is there a way to open a .gz transparently like vim does? 

[23:23] <sjn> using what?

[23:25] <sjn> less? cat? LibreOffice?

[23:25] <kybr> for 'huge-csv.gz'.IO.lines -> $line { ... }

[23:25] <Xliff> O_o

[23:25] <Xliff> Um... no

[23:25] <Xliff> You could write a module to do that, though...

[23:26] <kybr> okay. thanks.

[23:26] <Grinnz> i assume the raku equivalent of https://metacpan.org/pod/PerlIO::via::gzip would look very different

[23:27] <sjn> Maybe a role you could apply to an IO object?

[23:27] * sjn makes a guess

[23:28] <Grinnz> the main difficulty is that you can't tell where lines are until it's decompressed

[23:29] <Grinnz> so you need something that can gzip/gunzip a stream so as to not read the whole thing at once

[23:29] <sjn> Or, if you accept how vim does it, just temporarily uncompress the file and iterate over that one

[23:31] <sjn> I see https://github.com/retupmoca/P6-Compress-Zlib has some functionality to extend filehandles. Maybe it can work in IO objects too?

[23:32] <Grinnz> that layer just uses https://metacpan.org/pod/IO::Uncompress::Gunzip#getline which handles those details

[23:32] <sjn> ah

[23:33] <Grinnz> that module is also higher level than Compress::Zlib which this looks like an equivalent to

[23:34] <Grinnz> i try not to look at https://metacpan.org/pod/Compress::Raw::Zlib any more than i have to 😬

[23:34] <sjn> Hm. Sure? Code says it uses Compress::Zlib::Raw, which is a NativeCall wrapper around zlib.so

[23:35] <sjn> Don't know the code though, so I might be missing something

[23:35] <Grinnz> there's also a subtle difference between raw zlib compression and gzip compression

[23:41] <lizmat> we need a module that creates a Supply out of a gzipped file, then you could run .lines on the Supply

[23:41] <lizmat> the supply would get fed with anything the next batch of decompressed data

[23:47] *** guifa2 joined
[23:48] *** wamba left
