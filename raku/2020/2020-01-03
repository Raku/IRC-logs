[00:07] *** patrickz joined
[00:11] *** patrickb left
[00:20] <cpan-raku> New module released to CPAN! Red (0.1.4) by 03FCO

[00:42] *** sena_kun left
[00:43] *** lucasb left
[00:44] *** patrickz left
[00:45] *** brass left
[00:47] *** johnjohn101 left
[00:57] *** sena_kun joined
[01:00] *** brass joined
[01:01] <AlexDaniel> .tell sergot Sorry, I was in the middle of something, not sure if you received my late answer. Basically, you are free to do it if you think it's going to be better, but there's no guarantee that it will in fact be better this way. Now with more people with privs contributing should be easier, but again I can't promise anything :)

[01:01] <tellable6> AlexDaniel, I'll pass your message to sergot

[02:01] *** unicodable6 left
[02:01] *** sourceable6 left
[02:01] *** statisfiable6 left
[02:01] *** reportable6 left
[02:01] *** coverable6 left
[02:01] *** notable6 left
[02:01] *** quotable6 left
[02:01] *** bloatable6 left
[02:01] *** benchable6 left
[02:01] *** releasable6 left
[02:01] *** greppable6 left
[02:01] *** squashable6 left
[02:01] *** nativecallable6 left
[02:01] *** bisectable6 left
[02:01] *** shareable6 left
[02:01] *** committable6 left
[02:02] *** reportable6 joined
[02:02] *** bisectable6 joined
[02:02] *** sourceable6 joined
[02:02] *** coverable6 joined
[02:02] *** shareable6 joined
[02:02] *** nativecallable6 joined
[02:03] *** squashable6 joined
[02:03] *** committable6 joined
[02:03] *** notable6 joined
[02:04] *** benchable6 joined
[02:04] *** greppable6 joined
[02:04] *** statisfiable6 joined
[02:04] *** bloatable6 joined
[02:04] *** unicodable6 joined
[02:04] *** quotable6 joined
[02:04] *** releasable6 joined
[02:05] *** Doc_Holliwood left
[02:42] *** sena_kun left
[02:57] *** sena_kun joined
[03:57] *** evalable6 left
[03:57] *** evalable6 joined
[04:25] *** mahmudov left
[04:42] *** sena_kun left
[04:55] *** sena_kun joined
[05:55] *** sourceable6 left
[05:55] *** coverable6 left
[05:55] *** nativecallable6 left
[05:55] *** quotable6 left
[05:55] *** squashable6 left
[05:55] *** notable6 left
[05:55] *** bloatable6 left
[05:55] *** committable6 left
[05:55] *** releasable6 left
[05:55] *** reportable6 left
[05:55] *** benchable6 left
[05:55] *** shareable6 left
[05:55] *** greppable6 left
[05:55] *** statisfiable6 left
[05:55] *** unicodable6 left
[05:56] *** bisectable6 left
[05:56] *** nativecallable6 joined
[05:56] *** squashable6 joined
[05:56] *** sourceable6 joined
[05:57] *** greppable6 joined
[05:57] *** bisectable6 joined
[05:57] *** notable6 joined
[05:57] *** benchable6 joined
[05:57] *** reportable6 joined
[05:57] *** shareable6 joined
[05:57] *** bloatable6 joined
[05:57] *** statisfiable6 joined
[05:58] *** coverable6 joined
[05:58] *** releasable6 joined
[05:58] *** committable6 joined
[05:59] *** quotable6 joined
[05:59] *** unicodable6 joined
[06:25] *** sauvin joined
[06:41] *** sena_kun left
[06:57] *** sena_kun joined
[07:02] *** epony left
[07:05] *** epony joined
[07:19] *** horsepatat joined
[07:45] *** jmerelo joined
[07:50] *** veesh_ joined
[07:52] *** veesh left
[07:52] *** veesh_ is now known as veesh

[07:57] <squashable6> 🍕 JJ++ submitted a review on pull request “Clarification of item an…”: https://github.com/Raku/doc/pull/3137#pullrequestreview-337975710

[07:57] <squashable6> 🍕🍕🍕  First contribution by JJ++! ♥

[07:57] <squashable6> 🍕 JJ++ merged pull request “Clarification of item an…”: https://github.com/Raku/doc/pull/3137

[07:57] <Geth> ¦ doc/master: 4 commits pushed by threadless-screw++, (Juan Julián Merelo Guervós)++

[07:57] <Geth> ¦ doc/master: 3a1a6440ba | Clarification of item and list assignment syntax and evaluation.

[07:57] <Geth> ¦ doc/master: 7d9fcffc0d | Typo correction.

[07:57] <Geth> ¦ doc/master: 7ebb005f99 | Type correction.

[07:57] <Geth> ¦ doc/master: c3311f90b1 | Merge pull request #3137 from threadless-screw/item_list_assignments

[07:57] <Geth> ¦ doc/master: review: https://github.com/Raku/doc/compare/3cd20ae522b9...c3311f90b140

[07:58] *** Doc_Holliwood joined
[08:00] <squashable6> 🍕 JJ++ wrote a comment on “Cache generated documentation”: https://github.com/Raku/doc/issues/717#issuecomment-570495321

[08:11] <Xliff> squashable6: status

[08:11] <squashable6> Xliff, 🍕🍕 SQUASHathon is in progress! The end of the event in 2 days and ≈3 hours. See https://github.com/rakudo/rakudo/wiki/Monthly-Bug-Squash-Day

[08:11] <squashable6> Xliff, Log and stats: https://gist.github.com/108474be1333314431de63d5d36bf800

[08:11] <tellable6> hey Xliff, you have a message: https://gist.github.com/00a174a73f96cac7963a1f92cb67d9d4

[08:11] <jmerelo> Hum

[08:12] <tellable6> 2020-01-01T21:40:38Z #raku <tbrowder> jmerelo: ^^^

[08:12] <jmerelo> I think this is just squashable working on autopilot

[08:12] <Xliff> Doesn't look to be a squashathon for this month.

[08:12] <Xliff> jmerelo: Yep.

[08:14] <jmerelo> .tell tbrowder raku-advent.blog is cool. 

[08:14] <tellable6> jmerelo, I'll pass your message to tbrowder

[08:17] *** wamba joined
[08:35] *** wamba left
[08:38] *** xinming_ joined
[08:39] <Geth> ¦ doc: 107da69ab6 | (JJ Merelo)++ | README.md

[08:39] <Geth> ¦ doc: Clarifies cache closes #717

[08:39] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/107da69ab6

[08:39] <squashable6> 🍕 JJ++ closed issue “Cache generated documentation”: https://github.com/Raku/doc/issues/717

[08:41] *** xinming left
[08:41] <Geth> ¦ doc: bdae66fbfe | (JJ Merelo)++ | README.md

[08:41] <Geth> ¦ doc: Some reflow and rewriting

[08:41] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/bdae66fbfe

[08:42] *** sena_kun left
[08:56] *** sena_kun joined
[08:57] *** scimon joined
[08:57] <stoned75> jmerelo ?

[08:57] <jmerelo> yep

[08:58] <stoned75> an example in doc/language/typesystem had me wondering for a couple of minutes, until I found in this file history a commit from you that now is making me wondering :)

[08:59] <jmerelo> stoned75: which one?

[08:59] <stoned75> so if I may disturb you, I would like to have your comments on commit c9539cf2230f45fda3be25637ffa5c8ad469f5da about the enum exemple starting with enum E(<one two>)

[09:00] <jmerelo> m: enum E(<one two>); my @keys = E::.values; say @keys.map: *.enums;

[09:00] <camelia> rakudo-moar 672c5d403: OUTPUT: «(Map.new((one => 0, two => 1)) Map.new((one => 0, two => 1)))␤»

[09:00] <stoned75> see how the 'map: *.perl' was rewritten as 'map: *enums' ?

[09:01] <jmerelo> right

[09:02] <stoned75> it seems a bit odd to me. or at least I do not understand the purpose of the example

[09:02] *** chloekek joined
[09:02] <jmerelo> stoned75: that was more than a year ago. And I should have done that example separately, but I would say that since the example talks about keys _and_ values, the original one just returned keys

[09:03] <stoned75> IC

[09:03] <jmerelo> But then it repeats the key-value mapping twice, so...

[09:04] <stoned75> hum I suppose I don't quite get the 'All of them turn the values into C<Str>' part

[09:05] <jmerelo> m: enum E(<one two>); say = E::.values; 

[09:05] <camelia> rakudo-moar 672c5d403: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix = instead.␤Did you make a mistake in Pod syntax?␤at <tmp>:1␤------> 3enum E(<one two>); say =7⏏5 E::.values;␤»

[09:05] <jmerelo> m: enum E(<one two>); say  E::.values; 

[09:05] <camelia> rakudo-moar 672c5d403: OUTPUT: «(one two)␤»

[09:05] <jmerelo> stoned75: I didn't write that part myself... But I guess it's because what you want is the enum object, not the string equivalent.

[09:05] <jmerelo> m: enum E(<one two>); say  E::.values[0]

[09:05] <camelia> rakudo-moar 672c5d403: OUTPUT: «two␤»

[09:05] <jmerelo> m: enum E(<one two>); say  E::.values[0].enums

[09:05] <camelia> rakudo-moar 672c5d403: OUTPUT: «Map.new((one => 0, two => 1))␤»

[09:06] <jmerelo> m: enum E(<one two>); say  E::.values[0].^name

[09:06] <camelia> rakudo-moar 672c5d403: OUTPUT: «E␤»

[09:06] <jmerelo> m: enum E(<one two>); say  E::.values[0].^mro

[09:06] <camelia> rakudo-moar 672c5d403: OUTPUT: «((E) (Int) (Cool) (Any) (Mu))␤»

[09:07] <stoned75> oh and btw, do you agree that the () serve no purpose in E(<one two>) ?

[09:08] <jmerelo> stoned75: I think that's the thing. E::.values returns the actual objects, of the actual type, E in this case. enums works on the type as well as the instances, so I guess that's the intention https://docs.raku.org/routine/enums

[09:08] <jmerelo> stoned75: right-on, yes.

[09:09] <jmerelo> m: enum E <one two>; say  E::.values

[09:09] <camelia> rakudo-moar 672c5d403: OUTPUT: «(two one)␤»

[09:10] <jmerelo> stoned75: the thing is that, looking at the context, enums returns key and values for an enum. It's probably a bit misguided to modify the original instead of rewriting from scratch

[09:10] <jmerelo> m: enum E <one two>; say  E.enums

[09:10] <camelia> rakudo-moar 672c5d403: OUTPUT: «Map.new((one => 0, two => 1))␤»

[09:11] <chloekek> Is there a reliable way to check (mechanically) whether a distribution allows redistribution? There’s of course the license field in META6.json but how reliable is it?

[09:11] <chloekek> I want to mirror all versions of all distributions provided they are free software.

[09:12] <chloekek> But I’m going through each manually. :þ

[09:12] <stoned75> jmerelo: ok, thanks for your comments. I'll ponder this a bit more :)

[09:12] <jmerelo> chloekek: I don't think it's even compared with the actual LICENSE file.

[09:12] <chloekek> not going through each manually*

[09:13] <chloekek> Ah yeah, license files.

[09:13] <jmerelo> stoned75: any time :-)

[09:13] <chloekek> There is probably a Perl or Node.js library that has a function that takes a tarball and returns a license name.

[09:13] <chloekek> That implements all of the heuristics.

[09:14] <jmerelo> chloekek: github does that. They might have released that thing...

[09:14] <chloekek> I’ll give that a try and then fall back to the license field in META6.json.

[09:14] <chloekek> Thanks.

[09:14] <jmerelo> chloekek: sure :-)

[09:17] <chloekek> I also want to extrac readmes and render them with pandoc. :)

[09:22] <stoned75> hum. how can I get the origin of a method ?

[09:23] <lizmat> what do you mean by "the origin of a method|

[09:23] <lizmat> "?

[09:23] <lizmat> the class it is actually defined in?

[09:23] <stoned75> I mean which class/role defines it

[09:24] <lizmat> hmmm...

[09:25] <lizmat> m: dd Str.^find_method("Int").package

[09:25] <camelia> rakudo-moar 672c5d403: OUTPUT: «Str␤»

[09:25] <lizmat> m: dd Str.^find_method("elems").package

[09:25] <camelia> rakudo-moar 672c5d403: OUTPUT: «Any␤»

[09:25] <stoned75> cool. thanks !

[09:31] <jmerelo> chloekek: cool!

[09:33] *** rindolf joined
[09:44] *** jmerelo left
[09:57] <Xliff> m: my @a = <1 2 3 4 5>; @a.splice(0, *, ()); @a.say;

[09:57] <camelia> rakudo-moar 672c5d403: OUTPUT: «[]␤»

[10:14] <Xliff> m: my @a = <1 2 3 4 5>; @a.WHERE.say; @a.splice(0, *, ()); @a.say; @a.WHERE.say

[10:14] <camelia> rakudo-moar 672c5d403: OUTPUT: «140440692970344␤[]␤140440692970344␤»

[10:14] <Xliff> m: my @a = <1 2 3 4 5>; @a.WHERE.say; @a.splice(0, *, ()); @a.say; @a.WHERE.say; @a = (); @a.WHERE.say

[10:14] <camelia> rakudo-moar 672c5d403: OUTPUT: «139683972896872␤[]␤139683972896872␤139683972896872␤»

[10:15] <Xliff> m: my @a = <1 2 3 4 5>; @a.WHERE.say; @a.splice(0, *); @a.say; @a.WHERE.say; @a = (); @a.WHERE.say

[10:15] <camelia> rakudo-moar 672c5d403: OUTPUT: «140691319903136␤[]␤140691319903136␤140691319903136␤»

[10:19] <stoned75> m: enum E <one two>; say (E.elems, E.^elems)

[10:19] <camelia> rakudo-moar 672c5d403: OUTPUT: «(1 2)␤»

[10:20] <stoned75> even if I understand the result, I can't help being a bit troubled by this result :-}

[10:21] <stoned75> E.elems returning 2 would make sense to me. what would break if it was ?

[10:24] <stoned75> m: enum E <one two>; say (one.^name, one.^elems, E.elems, E.^elems)

[10:24] <camelia> rakudo-moar 672c5d403: OUTPUT: «(E 2 1 2)␤»

[10:24] <stoned75> I'm even more wondering ;-)

[10:25] <stoned75> ahah. the thing is one and E are of the same type.

[10:26] <chloekek> p6: enum E <one two>; .say for (E:U, E:D) X~~ (E, one)

[10:26] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤False␤True␤False␤»

[10:26] <chloekek> p6: enum E <one two>; for (E:U, E:D) X (E, one) -> ($t, $x) { say $t.perl, $x.perl, $t ~~ $x }

[10:26] <camelia> rakudo-moar 672c5d403: OUTPUT: «E:UETrue␤E:UE::oneFalse␤E:DETrue␤E:DE::oneFalse␤»

[10:27] <chloekek> Ayy lmao.

[10:27] <chloekek> p6: say 1 ~~ Int:U

[10:27] <camelia> rakudo-moar 672c5d403: OUTPUT: «False␤»

[10:27] <chloekek> p6: enum E <one two>; say one ~~ E:U

[10:27] <camelia> rakudo-moar 672c5d403: OUTPUT: «False␤»

[10:27] <chloekek> p6: say 1 ~~ Int:D

[10:27] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤»

[10:27] <chloekek> p6: enum E <one two>; say one ~~ E:D

[10:27] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤»

[10:27] <chloekek> I’m confused.

[10:28] <chloekek> p6: enum E <one two>; say E ~~ E:D

[10:28] <camelia> rakudo-moar 672c5d403: OUTPUT: «False␤»

[10:30] <chloekek> p6: enum E <one two>; for (E:U, E:D) X (E, one) -> ($t, $x) { say $t.perl, ' ~~ ', $x.perl, ' = ', $t ~~ $x }

[10:30] <camelia> rakudo-moar 672c5d403: OUTPUT: «E:U ~~ E = True␤E:U ~~ E::one = False␤E:D ~~ E = True␤E:D ~~ E::one = False␤»

[10:30] <chloekek> p6: enum E <one two>; for (E:U, E:D) X (E, one) -> ($t, $x) { say $t.perl, ' ~~ ', $x.perl, ' = ', $x ~~ $t }

[10:30] <camelia> rakudo-moar 672c5d403: OUTPUT: «E:U ~~ E = True␤E:U ~~ E::one = False␤E:D ~~ E = False␤E:D ~~ E::one = True␤»

[10:30] <chloekek> Ah, the order matters. ~~ is not commutative.

[10:30] <moritz> indeed

[10:30] <tellable6> 2020-01-02T20:24:14Z #raku-dev <lizmat> moritz I thought old ircloge.perlgeek links would be redirected to colabti?

[10:30] <moritz> the matcher/pattern is on the right

[10:30] <chloekek> Which makes perfect sense.

[10:31] <moritz> lizmat: I know of no such plans. But if anybody wants to invest more energy into it, I'm happy to have the irclog.perlgeek.de subdomain be a CNAME to wherver

[10:33] <stoned75> so back to E.elems being 1 and not 2. am I the only one troubled by this ? ;-)

[10:34] <stoned75> or even by the following ? ;-)

[10:34] <stoned75> m: enum E <one two>; E::.values == E::.keys

[10:34] <camelia> rakudo-moar 672c5d403: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression ".values == E::.keys" in sink context (line 1)␤»

[10:35] <stoned75> m: enum E <one two>; say E::.values == E::.keys

[10:35] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤»

[10:35] <chloekek> m: enum E <one two>; say E::.values.perl; say E::.keys.perl

[10:35] <camelia> rakudo-moar 672c5d403: OUTPUT: «(E::one, E::two).Seq␤("one", "two").Seq␤»

[10:35] <chloekek> With == you check if there are equally many of them.

[10:35] <stoned75> ah damned. 

[10:36] <chloekek> m: enum E <one two>; say E::.values == 2;

[10:36] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤»

[10:37] <chloekek> m: enum E <one two>; say E::.values eqv E::.keys;

[10:37] <camelia> rakudo-moar 672c5d403: OUTPUT: «False␤»

[10:38] <Xliff> m: enum E <one two>; say E::one ~~ E:D

[10:38] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤»

[10:38] <Xliff> m: enum E <one two>; say E:D ~~ E::one

[10:38] <camelia> rakudo-moar 672c5d403: OUTPUT: «False␤»

[10:38] <Xliff> m: enum E <one two>; say E::one ~~ E::one

[10:38] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤»

[10:38] <Xliff> m: enum E <one two>; say E::two ~~ E::one

[10:38] <camelia> rakudo-moar 672c5d403: OUTPUT: «False␤»

[10:38] <stoned75> m: enum E <one two>; E::.values.values == E::.keys.values

[10:38] <camelia> rakudo-moar 672c5d403: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression ".values == E::.keys.values" in sink context (line 1)␤»

[10:38] <stoned75> m: enum E <one two>; say E::.values.values == E::.keys.values

[10:38] <camelia> rakudo-moar 672c5d403: OUTPUT: «True␤»

[10:39] <chloekek> cmp :p

[10:39] <chloekek> or eqv

[10:39] <stoned75> m: enum E <one two>; say E::.values.values cmp E::.keys.values

[10:39] <camelia> rakudo-moar 672c5d403: OUTPUT: «Same␤»

[10:39] <stoned75> fun with enum

[10:40] <chloekek> m: enum E <one two>; dd E::.values.values, E::.keys.values;

[10:40] <camelia> rakudo-moar 672c5d403: OUTPUT: «(E::one, E::two)␤("one", "two")␤»

[10:40] <chloekek> Oh yeah cmp does string comparison.

[10:40] <chloekek> m: enum E <one two>; say E::.values.values eqv E::.keys.values;

[10:40] <camelia> rakudo-moar 672c5d403: OUTPUT: «False␤»

[10:41] *** sena_kun left
[10:41] <chloekek> Oh no it doesn’t.

[10:42] <chloekek> Oh it does sometimes.

[10:42] <chloekek> “cmp will first try to compare operands as strings (via coercion to Stringy), and, failing that, will try to compare numerically via the <=> operator or any other type-appropriate comparison operator. See also the documentation for the cmp operator.”

[10:42] <chloekek> It’s leg that does string comparison in every case.

[10:43] <stoned75> ahah I'm back to my original question !

[10:43] <stoned75> m: enum E <one two>; say E::.keys.values.map({.perl})

[10:43] <camelia> rakudo-moar 672c5d403: OUTPUT: «("one" "two")␤»

[10:43] <stoned75> m: enum E <one two>; say E::.values.values.map({.perl})

[10:43] <camelia> rakudo-moar 672c5d403: OUTPUT: «(E::one E::two)␤»

[10:57] *** sena_kun joined
[11:15] *** wamba joined
[11:16] <xinming_> https://termbin.com/63e7    <--- In this example, the whenever will always try to wait for result of @channel[0], so we don't need the final `await |@channel` statement.  But when I changed `whenever @channel[0]` to  `whenever @channel`    I'll have to add the final   `await @chanenl` thing.  Anyone here would clarify this for me please?

[11:17] <xinming_> And also, What is the right way to wait result for multiple channels in an array in this case please?

[11:17] <xinming_> Also, with   `whenever @channel.map(*.receive) {... }`    It'll also quite after we receive things once.

[11:18] <xinming_> So, what is the correct way to listen to multiple channels?  I don't think something like      for @channel -> $channel { whenever $channel { ... } }    is the right perlish way to do this anyway.

[11:20] <xinming_> s/ 'await |@p' / 'await |@channel' /

[11:22] <xinming_> the reason I don't think the sollution right is:    for @channel -> $channel { ... }     This may cause problem when there are too many channels IMHO

[11:32] *** jmerelo joined
[11:34] *** kensanata joined
[11:39] <jmerelo> What's the deal with autowatch-test-repo?

[11:52] *** mscha joined
[11:53] <mscha> m: race for ^10 -> $i { sleep .5-$i/20; say $i } # Any way to pass batch and degree?

[11:53] <camelia> rakudo-moar 672c5d403: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[11:53] <mscha> m: (^10).race(:1batch, :10degree).map(-> $i { sleep .5-$i/20; say $i });

[11:53] <camelia> rakudo-moar 672c5d403: OUTPUT: «9␤8␤7␤6␤5␤4␤3␤2␤1␤0␤»

[11:54] <mscha> Is there any way to supply batch size and degree when using race/hyper as a statement prefix?

[11:56] <xinming_> mscha: I don't think so. Maybe someone will give some adverbs to statement prefix. :-)

[11:58] <mscha> m: for (^10).race(:1batch, :10degree) -> $i { sleep .5-$i/20; say $i } # doesn't DWIM

[11:58] <camelia> rakudo-moar 672c5d403: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[11:58] <mscha> m: race for (^10).race(:1batch, :10degree) -> $i { sleep .5-$i/20; say $i } # This works for some reason I don't understand

[11:58] <camelia> rakudo-moar 672c5d403: OUTPUT: «9␤8␤7␤6␤5␤4␤3␤2␤1␤0␤»

[12:00] <xinming_> mscha: the (^10).race   returns discorded result already

[12:01] <xinming_> yea, statement prefix should have someway to be tunnable

[12:02] <mscha> But why do I need `race for (^10).race ...`?

[12:02] <xinming_> We need     race for ...

[12:02] <xinming_> No need the (^10).race

[12:04] <chloekek> m: (^10).race(:1batch, :10degree).map: -> $i { sleep .5-$i/20; say $i }

[12:04] <camelia> rakudo-moar 672c5d403: OUTPUT: «9␤8␤7␤6␤5␤4␤3␤2␤1␤0␤»

[12:10] <chloekek> p6: sub hyperlöb(*@f) { my @r = @f.hyper.map({ &^f(@r) }).lazy }; say hyperlöb({ 1 }, { 2 }, { [+] @^s[0, 1] })

[12:10] <camelia> rakudo-moar 672c5d403: OUTPUT: «[...]␤»

[12:10] <chloekek> p6: sub hyperlöb(*@f) { my @r = @f.hyper.map({ &^f(@r) }).lazy }; .say for hyperlöb({ 1 }, { 2 }, { [+] @^s[0, 1] })

[12:10] <chloekek> Interesting, recursive lazy hyper seq is not happy.

[12:12] <chloekek> And camelia doesn’t respond with a timeout either.

[12:12] <chloekek> p6: sub löb(*@f) { my @r = @f.map({ &^f(@r) }).lazy }; .say for löb({ 1 }, { 2 }, { [+] @^s[0, 1] })

[12:13] <chloekek> Ah camelia seems to be stuck.

[12:15] *** camelia left
[12:17] <lizmat> https://info.jetbrains.com/idea-webinar-january-2020.html

[12:17] <lizmat> weekly: https://info.jetbrains.com/idea-webinar-january-2020.html

[12:17] <notable6> lizmat, Noted! (weekly)

[12:18] <lizmat> weekly: https://news.ycombinator.com/item?id=21943565

[12:18] <notable6> lizmat, Noted! (weekly)

[12:39] <Xliff> chloekek: You killed camelia! <Insert obligatory South Park response, here>

[12:39] <Geth> ¦ doc: 1a6e507cca | (Stoned Elipot)++ | doc/Language/typesystem.pod6

[12:39] <Geth> ¦ doc: Sync enum example with its (original?) intent

[12:39] <Geth> ¦ doc: 

[12:39] <Geth> ¦ doc: ... At least as far as I understood it.

[12:39] <Geth> ¦ doc: Also, while here, drop unneeded parentheses in enum construction.

[12:39] <squashable6> 🍕🍕🍕  First contribution by stoned++! ♥

[12:39] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/1a6e507cca

[12:40] <jmerelo> stoned75: hum. You have simply restored it to the state before correction. 

[12:40] <jmerelo> stoned75: see below vvvvv

[12:41] *** wamba left
[12:41] <jmerelo> m: enum E <one two>; say E.enums

[12:41] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «Map.new((one => 0, two => 1))␤»

[12:41] <jmerelo> I would say that was the original intent...

[12:41] <jmerelo> Or maybe

[12:42] <jmerelo> m: enum E <one two>; say E::.kv

[12:42] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «(two two one one)␤»

[12:42] <stoned75> oh really ? sorry I misunderstood our earlier conversation then

[12:42] <jmerelo> m: enum E <one two>; say E::.keys

[12:42] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «(two one)␤»

[12:42] <jmerelo> m: enum E <one two>; say E::.values

[12:42] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «(two one)␤»

[12:42] <jmerelo> No, what will not work

[12:42] <jmerelo> this is the one:

[12:42] <jmerelo> m: enum E <one two>; say E.enums

[12:42] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «Map.new((one => 0, two => 1))␤»

[12:42] *** sena_kun left
[12:43] <jmerelo> Hum, not that either

[12:43] <jmerelo> It's probably OK, stoned.

[12:43] <jmerelo> Forget it.

[12:43] <stoned75> jmerelo: hum... :-}

[12:44] <jmerelo> If "get a list of types for the keys" means something, I guess the original, or your restored form, is it.

[12:44] <jmerelo> E::one is the actual type, so we're good.

[12:44] <jmerelo> stoned75: thanks!

[12:45] <stoned75> ok great! what I took away is... enum are a bit strange :-}

[12:45] <jmerelo> stoned75: the thing is that the first sentence in that paragraph is kind of misleading.

[12:45] <stoned75> exactly!

[12:46] <stoned75> also the second sentence says 'values' and the 'third' is about the keys !

[12:46] <jmerelo> stoned75: maybe it would be better if we completed it with another example that actually returned the values

[12:46] <jmerelo> although that's kinda easy

[12:46] <xinming_> jmerelo: Do you have time to check about my question? :-)

[12:47] <xinming_> The    whenever @channel { ... }    thing

[12:47] <stoned75> but to get the keys as type we do have to use E::.values :-}

[12:47] <jmerelo> m: enum E <one two>; say ~E::.values[0]

[12:47] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «one␤»

[12:47] <jmerelo> xinming_: no, sorry, I didn't

[12:47] <jmerelo> I can add some urgency as a label if it's critical, xinming_ 

[12:48] <jmerelo> m: enum E <one two>; say ~E::.values

[12:48] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «two one␤»

[12:48] <jmerelo> m: enum E <one two>; say E::.values

[12:48] <evalable6> jmerelo, rakudo-moar 5f335aa49: OUTPUT: «(one two)␤»

[12:48] *** camelia joined
[12:48] <jmerelo> m: enum E <one two>; say E::.values[0].value

[12:48] <jmerelo> well...

[12:49] <camelia> rakudo-moar 5f335aa49: OUTPUT: «1␤»

[12:49] <jmerelo> camelia++

[12:50] <jmerelo> But I don't know what took so long...

[12:50] <jmerelo> stoned75: anyway, maybe I'll add something like the stuff above to clarify

[12:52] <stoned75> sure ! I admit I'm a bit skeptical, so I look forward to what you'll add :-)

[12:54] <jmerelo> stoned75: thanks anyway and as usual, great work :-)

[12:55] <stoned75> my pleasure!

[12:55] *** kensanata left
[12:55] <xinming_> jmerelo: not critical, If you are in channel, You can just backlog. I posted not long ago.

[12:56] <xinming_> Maybe 3 or 4 screens

[12:56] <jmerelo> xinming_: you mean this issue, right? https://github.com/Raku/doc/issues/3136

[12:56] <xinming_> Nope

[12:57] <xinming_> that is the doc issue.

[12:57] <jmerelo> xinming_: OK, let me check then

[12:57] *** sena_kun joined
[12:58] <jmerelo> xinming_: you mean this? https://termbin.com/63e7

[13:01] <jmerelo> xinming_: I'm no expert in concurrency, but I see several things there

[13:01] *** xinming_ left
[13:01] <jmerelo> xinming_: (also it would be maybe better if you ask in StackOverflow, where all the experts are)

[13:01] <tellable6> jmerelo, I'll pass your message to xinming_

[13:01] *** xinming_ joined
[13:02] <jmerelo> xinming_: await is here: https://docs.raku.org/routine/await it waits until a value is available on a channel

[13:03] <jmerelo> If you want to listen on several channels, it's better to start several promises that listen to it using whenever

[13:04] <jmerelo> xinming_: the await at the end of the script will actually wait on channel items, not on the promises. You are effectively starting a promise for every element of the channel, when you use start

[13:05] <jmerelo> xinming_: why don't you send stuff to the channel, and process it (using whenever) in a different statement? It will clarify what's going on.

[13:07] <xinming_> jmerelo: When I use  my @p = @channel.map({ start { } });   await |@p    await here still await on @channel instead of Promise returned by start ?

[13:07] <tellable6> 2020-01-03T13:01:30Z #raku <jmerelo> xinming_: (also it would be maybe better if you ask in StackOverflow, where all the experts are)

[13:08] <jmerelo> xinming_: in that case, you're mapping channel _items_ to promises, if I'm not wrong.

[13:08] <jmerelo> xinming_: let me check

[13:08] <xinming_> I didn't receive that.

[13:08] <scimon> I'd advise taking a look at react blocks. React blocks are awesome.

[13:09] <scimon> https://docs.raku.org/language/concurrency#index-entry-react

[13:09] <xinming_> scimon: I do read that, and several times. I just now practise to get the idea of it.

[13:10] <jmerelo> xinming_: Channel is an Any, so it's got map. Channel.map will eagerly read the Channel and then map every element to the block, in this case, a promise.

[13:10] <jmerelo> xinming_: but scimon is right, react blocks are the way to go...

[13:10] <xinming_> jmerelo: Actually, What I asked is the differences between      whenever @channel     and     whenever @channel[0]

[13:10] <xinming_> I do have whenever block in my example.

[13:10] <xinming_> https://termbin.com/63e7

[13:12] <jmerelo> xinming_: whenever is used for react or supply blocks, not for channels. You need to put a react block around that channel to read from it.

[13:12] <jmerelo> xinming_: something like react { whenever @channel[0].receive { ... } }

[13:13] <xinming_> jmerelo: Yea,  actually,  react { whenever @channel[0] { } }   work as    `whenever @channel[0].receive`

[13:13] <eiro> hello people.

[13:13] <lizmat> eiro o/

[13:13] <jmerelo> xinming_: ah, OK.

[13:13] <xinming_> jmerelo: But how do we monitor multiple channels in this case then?

[13:14] <eiro> hug lizmat !

[13:14] <jmerelo> xinming_: do a loop within the react block

[13:14] <xinming_> I know we can do    react { for @channel -> $x { whenever $x { ... } }

[13:14] <jmerelo> xinming_: exactly

[13:14] <xinming_> jmerelo: But I thought that might not be right to do. as if the @channel is large

[13:14] <scimon> m: my $c = Channel.new;my $p = start react { whenever $c { .say } };$c.send("test");$c.close;await $p;say "done"

[13:14] <camelia> rakudo-moar 5f335aa49: OUTPUT: «test␤done␤»

[13:14] <xinming_> too many subscriptions.

[13:14] <scimon> React blocks totally work on Channels ;)

[13:14] <chloekek> p6: react { for ^10 { whenever Promise.in($_) { .say } } }

[13:15] <camelia> rakudo-moar 5f335aa49: OUTPUT: «True␤True␤True␤True␤True␤True␤True␤True␤True␤True␤»

[13:15] <xinming_> I thought there maybe a way to whenever on an @array activity

[13:15] <jmerelo> xinming_: you're creating an asynchronous event. It should be really fast, just setting the hook.

[13:15] <xinming_> I mean a single whenever to react to that @array.

[13:15] <xinming_> If the for loop is the only, Then, I know that. :-)

[13:16] <jmerelo> xinming_: you can use map if you don't like for... :-) Actually, you should use map always :-)

[13:16] <chloekek> Why use map always if TIMTOWTDI?

[13:17] <Xliff> chloekek++

[13:17] <xinming_> just now, I start to realize that  the difference between   react { whenever @channel.map(*.receive) { ... } }   and react { whenever @channel[0] { ... } }

[13:17] <xinming_> The *.receive   wait every channel returns a single thing, then quit.

[13:17] <jmerelo> chloekek: TIMTOWTDI .. with maps :-) You can use the feed operator, you can use map/reduce, you can use it with grep...

[13:18] <xinming_> While @channel[0]  means whenever will loop on @channel[0].received

[13:18] <chloekek> I wish the feed operator let me write ==> map { … } but it crashes.

[13:18] <chloekek> ({ ... }) is ugly. :(

[13:18] <jmerelo> chloekek: right. You need the parenthesis...

[13:18] <jmerelo> chloekek: and reminds us of JavaScript

[13:19] <Xliff> chloekek: why not map: { … }?

[13:19] <xinming_> after I saw so many features builtin in the syntax level, That really makes me feel so happy about using perl.

[13:19] <jmerelo> Xliff: doesn't work well with ==>

[13:20] *** mscha left
[13:20] <xinming_> raku*

[13:20] <Xliff> m: @a = <1 2 3>; @a ==> map: { $_ + 2 } ==> @b; @b.say;

[13:20] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@a' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5@a = <1 2 3>; @a ==> map: { $_ + 2 } ==>␤»

[13:20] <Xliff> m: my @a = <1 2 3>; @a ==> map: { $_ + 2 } ==> @b; @b.say;

[13:20] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3my @a = <1 2 3>; @a ==> map:7⏏5 { $_ + 2 } ==> @b; @b.say;␤    expecting any of:␤        colon pair␤»

[13:20] <Xliff> m: my @a = <1 2 3>; @a ==> map: @a, { $_ + 2 } ==> @b; @b.say;

[13:20] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3my @a = <1 2 3>; @a ==> map:7⏏5 @a, { $_ + 2 } ==> @b; @b.say;␤    expecting any of:␤        colon pair␤»

[13:20] <Xliff> m: my @a = <1 2 3>; @a.map: { $_ + 2 } ==> @b; @b.say;

[13:20] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@b' is not declared␤at <tmp>:1␤------> 3my @a = <1 2 3>; @a.map: { $_ + 2 } ==> 7⏏5@b; @b.say;␤»

[13:20] <Xliff> m: my @b; my @a = <1 2 3>; @a.map: { $_ + 2 } ==> @b; @b.say;

[13:20] <camelia> rakudo-moar 5f335aa49: OUTPUT: «[3 4 5]␤»

[13:20] <Xliff> Hrm.

[13:21] <Xliff> m: my @a = <1 2 3>; @a ==> $_ + 2  ==> @b; @b.say;

[13:21] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@b' is not declared␤at <tmp>:1␤------> 3my @a = <1 2 3>; @a ==> $_ + 2  ==> 7⏏5@b; @b.say;␤»

[13:21] <Xliff> m: my @b; my @a = <1 2 3>; @a ==> $_ + 2  ==> @b; @b.say;

[13:21] <camelia> rakudo-moar 5f335aa49: OUTPUT: «Too many positionals passed; expected 0 to 2 arguments but got 3␤  in block <unit> at <tmp> line 1␤␤»

[13:21] <jmerelo> Xliff: in some cases precedence will DWIM, but not always.

[13:22] <Xliff> m: my @b; my @a = <1 2 3>; @a ==> { $_ + 2 } ==> @b; @b.say;

[13:22] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Only routine calls or variables that can '.push' may appear on either side of feed operators.␤at <tmp>:1␤------> 3my @b; my @a = <1 2 3>; @a ==> 7⏏5{ $_ + 2 } ==> @b; @b.say;␤»

[13:22] <Xliff> m: my @b; my @a = <1 2 3>; @a ==> -> $_ { $_ + 2 } ==> @b; @b.say;

[13:22] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Only routine calls or variables that can '.push' may appear on either side of feed operators.␤at <tmp>:1␤------> 3my @b; my @a = <1 2 3>; @a ==> 7⏏5-> $_ { $_ + 2 } ==> @b; @b.say;␤»

[13:22] *** Tirifto joined
[13:22] <Xliff> Well, I never grok'd the feed op.

[13:22] <Xliff> Something for the future.

[13:22] <jmerelo> Xliff: let's call it rocket

[13:22] <Xliff> Heh.

[13:29] *** lucasb joined
[13:34] *** jmerelo left
[13:46] <sarna> hey, how to bind $*IN and $*OUT to something else for testing? I want to have a string in $*IN and read a string from $*OUT

[13:46] <sarna> (I want to emulate input to `prompt` and check what a function prints)

[13:46] <sena_kun> sarna: can't you just assign it?

[13:47] <sarna> sena_kun: I can! but to what? I can't find that in the docs

[13:47] <chloekek> No, you must define it with my: my $*IN = ... or my $*IN := ...;

[13:47] <chloekek> If you assign it then it will remain that value after returning.

[13:48] <sarna> m: my $*IN = "foo"; $foo = prompt

[13:48] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$foo' is not declared␤at <tmp>:1␤------> 3my $*IN = "foo"; 7⏏5$foo = prompt␤»

[13:48] <sarna> "foo".IO wants to get a file called foo :^(

[13:48] <sarna> I haven't found a way of making a handle without a file on disk

[13:48] <chloekek> https://github.com/hoelzro/p6-io-string/

[13:49] <eiro> my @doubles = * * 2 for 4..8; should rise a warning. worth a gh issue ?

[13:49] <chloekek> p6: my $*IN := "A\nB\nC\n"; .say for lines;

[13:49] <camelia> rakudo-moar 5f335aa49: OUTPUT: «No such method 'nl-in' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[13:49] <chloekek> p6: my $*IN := "A\nB\nC\n" but role { method nl-in { "\n" } }; .say for lines;

[13:49] <camelia> rakudo-moar 5f335aa49: OUTPUT: «No such method 'encoding' for invocant of type 'Str+{<anon|1>}'␤  in block <unit> at <tmp> line 1␤␤»

[13:50] <eiro> camelia: my @doubles = * * 2 for 4..8; @doubles.elems.say

[13:50] <sarna> chloekek: thanks, bookmarked! :D

[13:50] <eiro> p6: my @doubles = * * 2 for 4..8; @doubles.elems.say

[13:50] <camelia> rakudo-moar 5f335aa49: OUTPUT: «1␤»

[13:51] <eiro> this is true but nonsense. the fix is

[13:51] <eiro> p6: my @doubles = (* * 2 for 4..8); @doubles.elems.say

[13:51] <camelia> rakudo-moar 5f335aa49: OUTPUT: «5␤»

[14:00] *** veesh_ joined
[14:02] *** veesh left
[14:03] *** veesh_ is now known as veesh

[14:15] <Geth> ¦ doc: b56d6044e2 | Coke++ | doc/Language/variables.pod6

[14:15] <Geth> ¦ doc: Fix example code

[14:15] <Geth> ¦ doc: 

[14:15] <Geth> ¦ doc: * additional my causes compile time error

[14:15] <Geth> ¦ doc: * Follow style guide and use ^name instead of .WHAT

[14:15] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/b56d6044e2

[14:15] <Geth> ¦ doc: 44973b2ac8 | Coke++ | 2 files

[14:15] <squashable6> 🍕🍕🍕  First contribution by coke++! ♥

[14:15] <Geth> ¦ doc: Fix typo, learn word

[14:15] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/44973b2ac8

[14:19] <Xliff> eiro: That syntax will not work.

[14:20] <Xliff> It's written as...

[14:20] <Xliff> p6: my @doubles = (4..8).map(* * 2); @doubles.elems.say

[14:20] <camelia> rakudo-moar 9ccfedb18: OUTPUT: «5␤»

[14:21] <Xliff> using a "my" and a "for" in the same line usually will not DWIM

[14:22] <scimon> p6: my @doubles = (* * 2 for 4..8); @doubles.say

[14:22] <camelia> rakudo-moar 9ccfedb18: OUTPUT: «[8 10 12 14 16]␤»

[14:23] <scimon> Does work. I guess because the whatever start makes it the same as my @doubles = ({$_ * 2 } for 4..8); which is fine. (But yeah you need the brackets).

[14:24] <Xliff> scimon: So should that be an error without the parens?

[14:27] <eiro> Xliff: at least a warning. that was my proposal 

[14:28] *** horsepatat left
[14:29] *** wamba joined
[14:29] <scimon> Without the brackets you get a list with 1 item (the whatever block). It probably gets assigned to 4 times because of the for 4..8 but the system is fine with that.

[14:30] <scimon> m: my @doubles = * * 2;@doubles[0](4).say

[14:30] <camelia> rakudo-moar 9ccfedb18: OUTPUT: «8␤»

[14:30] <scimon> Fun fun fun :)

[14:32] <eiro> i had no sense of humour after spending 5 minutes to understand it was possible :)

[14:32] <eiro> beacause at the end: @double could be local to the loop so a warning should happen at line 2 

[14:33] <eiro> or @double is in the scope so a warning should happen because it is redefined 4 times 

[14:33] <scimon> There's no block. Here's a fun one. 

[14:33] <eiro> (actually i really think it should rise an error)

[14:34] <scimon> m: my $a++ for ^4;say $a

[14:34] <camelia> rakudo-moar add2ec0d4: OUTPUT: «4␤»

[14:34] <scimon> :D

[14:34] <eiro> yep

[14:34] <chloekek> p6: say ($++ for ^4);

[14:35] <camelia> rakudo-moar add2ec0d4: OUTPUT: «(0 1 2 3)␤»

[14:35] <eiro> so i come back to my first question: is it worth an issue ?

[14:35] <scimon> I'm not sure. It seems weird but valid.

[14:36] <chloekek> eiro: it never harms to make an issue. If it turns out it’s ok the way it currently is, then the issue can be used as a reference for future visitors.

[14:36] <eiro> i guess not

[14:36] <scimon> Point

[14:37] <lizmat> .oO( I have no issue with more issues :-)

[14:38] <eiro> i don't understand what an issue is anymore. github is the worse thing that happens to me. i regret rt so much

[14:38] <lizmat> eiro: alas, not enough people to maintain RT, so...

[14:39] <eiro> lizmat: because no one asked for ...

[14:39] <eiro> what i heard was "every one wants to use gh anyway"

[14:40] <chloekek> Make a decent bug tracker that uses GitHub Issues API as its DBMS.

[14:42] *** sena_kun left
[14:42] <eiro> interesting idea but if no one wants to maintain a working product like RT, who want to write a descent bug tracker? at some point it would be yet another tool to maintain ...

[14:43] <eiro> anyway: i fill an issue on the rakudo repo

[14:43] <chloekek> Was RT made specifically for Rakudo?

[14:44] <moritz> no

[14:45] <eiro> nope

[14:47] <eiro> it was a generic tool used by all the perl5 community. interacting with it using mails was really enjoyable and the scrip system (scripts to handle events) made things really customizable

[14:47] <chloekek> Nice.

[14:47] <eiro> https://bestpractical.com/request-tracker 

[14:49] <eiro> also: it is still wildly used in french universities and there are extension for ISO quality certifications so https://www.easter-eggs.com/ still maintains it

[14:49] <moritz> so far, RT and OTRS have been the only bug trackers I've used that worked well with email

[14:49] <moritz> well, and the Debian bug tracker, but I've never seen that used anywhere besides Debian :D

[14:51] <chloekek> Amazing.

[14:53] <eiro> the last time i checked for the code, my feeling was:

[14:54] <eiro> * there is a clean, elegant core

[14:54] <Geth> ¦ doc: 3f8e74021d | (Stoned Elipot)++ | doc/Language/typesystem.pod6

[14:54] <Geth> ¦ doc: Fix whitespace handling in examples

[14:54] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/3f8e74021d

[14:55] <eiro> * there is so many things that are written "php application alike" way with business model parts written directly in the templates

[14:56] *** sena_kun joined
[15:08] <chloekek> I wish I could maintain a large Perl app.

[15:11] <uzl[m]> Where I can find the tar file for Rakudo 2019.11? I remember coming across it but I forgot where I saw it though.

[15:11] <eiro> uzl[m]:that's what i reported on the ml 

[15:12] <eiro> also webpages are outdated. i guess 2019.11 was only released on github

[15:14] <eiro> chloekek: i hoped sympa and RT to share some efforts because both of them have engines to automate stuff using emails as interface but it seems no one care anymore

[15:14] <eiro> they just want to maintain the status quo: those apps are now in "maintainance mode"

[15:14] <chloekek> Email is out of fashion.

[15:15] <eiro> true. but it was so much superior to everything i see these days

[15:15] *** wamba left
[15:15] <eiro> so what's the point of maintaining them if no one cares

[15:16] <uzl[m]> eiro: Yeah, on Github. I think it was AlexDaniel that released. Do you have the Github link to that release?

[15:16] <eiro> https://github.com/rakudo/rakudo/releases

[15:16] <eiro> especially https://github.com/rakudo/rakudo/tree/2019.11

[15:17] <uzl[m]> eiro: Thanks!

[15:17] <AlexDaniel> eiro: hold on which web pages are we talking about?

[15:17] *** melezhik joined
[15:18] *** horsepatat joined
[15:18] <eiro> AlexDaniel: https://rakudo.org/files

[15:18] <AlexDaniel> eiro: that's rakudo star

[15:18] <eiro> and also https://raku.org/

[15:18] <eiro> especially https://raku.org/downloads

[15:19] <AlexDaniel> and that too. Rakudo Star has a different release cycle

[15:19] <AlexDaniel> I beleive there's a release candidate for rakudo star 2019.11

[15:20] <AlexDaniel> ah, there's one for 2019.07.1

[15:20] <eiro> ??

[15:20] <eiro> so raku can be ahead of rakudo star?

[15:20] <lizmat> it is by definition ahead

[15:21] <lizmat> just as the odd Perl releases are ahead of the stable even releases

[15:21] <AlexDaniel> tyil: can you tell me what can be done with https://github.com/rakudo/star/pull/144 ?

[15:21] <AlexDaniel> tyil: I reviewed it and nothing seems to be wrong

[15:21] <AlexDaniel> tyil: does it mean that it is one click away from being released?

[15:22] <eiro> ok ... so rakudo star became "the rakudo normal people should use"?

[15:22] <AlexDaniel> tyil: I didn't test it though, but I see that other people did

[15:22] <melezhik> AlexDaniel: thank you for responding to my email. Where is the best to fill the RakuDist issue?

[15:22] <eiro> (the stable one ?)

[15:23] <AlexDaniel> eiro: it is hard to say. There was a point when it was the recommended way to get rakudo, but today it's a bit different. Some people wonder if star is needed at all for operating systems other than Windows

[15:24] <AlexDaniel> for example, I'd personally recommend to get rakudo from distro packages if the version in the package is recent enough

[15:24] <tyil> AlexDaniel: Im waiting for the windows guy to make a .msi

[15:25] <tyil> to ensure that it will also work for windows users

[15:25] <AlexDaniel> tyil: ookay. Please kick me if it stalls for any other reason

[15:25] <tyil> I haven't been able to get in touch with the mac guy to make a .dmg of it

[15:25] <tyil> so I gave up on that for now

[15:28] <Tirifto> Hello! Is there any way at all to directly get a value from a hash variable in a regex match/substitution, given that their use therein is reserved? The best I could think of is: ‘$var ~~ s[$_] = $replacement given %hash<key>’, which looks alright to me, but I'm still wondering if there's anything simpler/more elegant. :)

[15:28] <eiro> AlexDaniel: ok. so i think that guix should package rakudo, not star. right ?

[15:32] <Geth> ¦ problem-solving: c146268616 | (Aleks-Daniel Jakimenko-Aleksejev)++ | .github/ISSUE_TEMPLATE/issue-template-infrastructure.md

[15:32] <Geth> ¦ problem-solving: Remove second assignee from the template

[15:32] <Geth> ¦ problem-solving: 

[15:32] <Geth> ¦ problem-solving: Otherwise the template doesn't work at all. I think the syntax was

[15:32] <Geth> ¦ problem-solving: wrong, but this fix will do for now.

[15:32] <Geth> ¦ problem-solving: review: https://github.com/perl6/problem-solving/commit/c146268616

[15:32] <Geth> ¦ problem-solving: 834840e43a | (Aleks-Daniel Jakimenko-Aleksejev)++ | 2 files

[15:32] <Geth> ¦ problem-solving: Rakufy the templates

[15:32] <Geth> ¦ problem-solving: review: https://github.com/perl6/problem-solving/commit/834840e43a

[15:32] <AlexDaniel> melezhik: it's not entirely an infrastructure issue, but I think that label is most fitting: https://github.com/perl6/problem-solving/issues/new?assignees=rba&labels=infrastructure&template=issue-template-infrastructure.md&title=

[15:33] *** wamba joined
[15:33] <AlexDaniel> melezhik: rba will likely tell you if it's possible to get a machine for it, and they'll also assist you to set things up

[15:34] <melezhik> AlexDaniel: thanks, will fill a ticket

[15:34] <AlexDaniel> melezhik: ideally we should have a label here related to modules and ecosystem https://github.com/perl6/problem-solving#labels-and-responsible-devs

[15:34] <AlexDaniel> but there's no such label yet, so infrastructure it is :)

[15:35] <melezhik> ok

[15:37] <Geth> ¦ problem-solving: 48d036cb42 | (Aleks-Daniel Jakimenko-Aleksejev)++ | README.md

[15:37] <Geth> ¦ problem-solving: Rakufy the README

[15:37] <Geth> ¦ problem-solving: review: https://github.com/perl6/problem-solving/commit/48d036cb42

[15:47] <Geth> ¦ problem-solving: melezhik assigned to rba Issue Test Raku modules against different OS, Rakudo versions https://github.com/perl6/problem-solving/issues/144

[15:56] *** abraxxa left
[15:58] *** wamba left
[16:03] <AlexDaniel> weekly: ever wondered if your module works on different operating systems, rakudo versions, etc.? Meet RakuDist! https://github.com/melezhik/RakuDist. There's currently a discussion on whether we can and should run it on our whole ecosystem. Feedback is welcome! https://github.com/perl6/problem-solving/issues/144

[16:03] <notable6> AlexDaniel, Noted! (weekly)

[16:04] <melezhik> AlexDaniel: thanks!

[16:23] *** pilne left
[16:43] *** sena_kun left
[16:44] <xinming_> m: %h = %(:a<a b c>, :b<x y z>); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[16:44] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '%h' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5%h = %(:a<a b c>, :b<x y z>); for roundr␤»

[16:44] <xinming_> m: my %h = %(:a<a b c>, :b<x y z>); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[16:44] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «("a", "x")␤("b", "y")␤("c", "z")␤»

[16:45] <xinming_> In this example, If the hash contains only one element, We'll get the eror

[16:45] <xinming_> m: my %h = %(:a<a b c>); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[16:45] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «Type check failed in binding to parameter '@list'; expected Positional but got Str ("a")␤  in block <unit> at <tmp> line 1␤␤»

[16:46] <xinming_> What is the right way to fix this please?  For now, My sollution is adding an empty array to the hash, But I think it's an ugly hack. So, here for the idea

[16:46] <xinming_> m: my %h = %(:a<a b c>, :NOT_EXIST_THING[]); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[16:46] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «("a",)␤("b",)␤("c",)␤»

[16:46] <xinming_> m: my %h = %(:a<a b c>, :NOT_EXIST_THING); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[16:46] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «(Bool::True, "a")␤("b",)␤("c",)␤»

[16:46] *** cpan-raku left
[16:48] *** cpan-raku joined
[16:48] *** cpan-raku left
[16:48] *** cpan-raku joined
[16:51] <chloekek> p6: my %h = :a<a b c>; say %h<>

[16:51] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «{a => (a b c)}␤»

[16:52] <chloekek> p6: my %h = :a<a b c>; say %h

[16:52] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «{a => (a b c)}␤»

[16:52] <chloekek> p6: my %h = :a<a b c>; say %h<>:v

[16:52] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «((a b c))␤»

[16:56] <xinming_> I think this is probably a bug

[16:57] <xinming_> m: my %h = :a<a b c>, :b<a c>; say %h<>:v

[16:57] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «((a b c) (a c))␤»

[16:57] *** sena_kun joined
[16:57] <xinming_> m: my %h = :a<a b c>, :b<a c>; say %h<>:v.map(*.flat)

[16:57] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «((a c) (a b c))␤»

[16:57] <xinming_> m: my %h = :a<a b c>; say %h<>:v.map(*.flat)

[16:57] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «((a b c))␤»

[16:57] <chloekek> I’d expect %h<> to be empty list.

[16:58] <chloekek> p6: say <>

[16:58] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of <>; in Raku please use lines() to read input, ('') to represent a null string or () to represent an empty list␤at <tmp>:1␤------> 3say <7⏏5>␤»

[16:58] <chloekek> p6: say []<>

[16:58] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «[]␤»

[16:58] <jnthn> %h<> is the zen slice, no?

[16:58] <chloekek> p6: say [1, 2, 3]<>

[16:58] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «[1 2 3]␤»

[16:58] <chloekek> Oh I see.

[16:58] <chloekek> p6: say [1, 2, 3]{}

[16:58] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «[1 2 3]␤»

[16:58] <xinming_> %h<> is just decontainer operation.

[16:58] <xinming_> [] is the same as <>

[16:58] <xinming_> If you want Empty list, You'll have to do something like  %h{()}

[16:59] <xinming_> jnthn: when we have list there, it's a zen slice. but <> alone is decont

[16:59] <xinming_> I search the diff between [] and <>, and finally I realized they are the same.

[16:59] <chloekek> p6: my $x = 1; my $y := $x<>; say $y.VAR.^name

[16:59] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «Int␤»

[17:00] <chloekek> p6: my $x = 1; my $y := $x[]; say $y.VAR.^name

[17:00] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «Int␤»

[17:00] <xinming_> jnthn: Do you think   my %h = %(:a<a b c>); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }      work like this is a bug in roundrobin?

[17:00] *** scimon left
[17:01] <xinming_> https://docs.perl6.org/language/containers   <--- Here, However, the decont operator <> is more appropriate to decontainerize items that aren't lists:

[17:01] <jnthn> xinming_: <> alone is a zen slice on an Array or Hash

[17:01] <xinming_> :-)

[17:01] <xinming_> jnthn: Ok, Then I'll try []

[17:02] <jnthn> Or so I thought, anyway

[17:02] <xinming_> Anyway,  neither works

[17:02] <xinming_> m: my %h = %(:a<a b c>); for roundrobin(%h[]:v.map: *.flat) -> @list { @list.perl.say; }

[17:02] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «Type check failed in binding to parameter '@list'; expected Positional but got Pair (:a($("a", "b", "c")))␤  in block <unit> at <tmp> line 1␤␤»

[17:02] <jnthn> Oh, I guess they're equivalent in that sense

[17:02] <xinming_> hmm, They are different.

[17:02] <xinming_> bbl

[17:03] <jnthn> https://github.com/rakudo/rakudo/blob/master/src/core.c/hash_slice.pm6#L163

[17:03] <xinming_> jnthn: They are different, The doc needs to be fixed.

[17:03] <jnthn> I think in `my %h = %(:a<a b c>);` the conextualizer is pointless, btw

[17:04] <jnthn> It just creates a throwaway hash

[17:04] <xinming_> Ok, Will fix that

[17:04] <jnthn> (Harmless, just a bit of wasted work)

[17:04] <chloekek> p6: my %h = :1a, :2b, :3c; say %h{'a' | 'b'} == 1

[17:04] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «any(True, False)␤»

[17:06] <xinming_> But what about the roundrobin(...) thing in this case?

[17:06] <jnthn> xinming_: fwiw I don't see anything that looks buggish in the various %h<>:v and %h and so on usages

[17:07] <xinming_> It seems, that roundrobin doesn't work right on single list item within list.

[17:07] <AlexDaniel> btw I highly recommend this extension: https://github.com/sindresorhus/refined-github#install

[17:07] <jnthn> Trying to find the case you think is wrong in all the backlog...can you write it again here? :)

[17:08] <xinming_> m: my %h = %(:a<a b c>); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[17:08] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «Type check failed in binding to parameter '@list'; expected Positional but got Str ("a")␤  in block <unit> at <tmp> line 1␤␤»

[17:08] <xinming_> m: my %h = %(:a<a b c>, :xx); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[17:08] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «(Bool::True, "a")␤("b",)␤("c",)␤»

[17:08] <xinming_> m: ((<a b c>,)).perl.say;

[17:08] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «(("a", "b", "c"),)␤»

[17:08] <xinming_> m: roundrobin((<a b c>,))).perl.say

[17:09] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3roundrobin((<a b c>,))7⏏5).perl.say␤»

[17:09] <xinming_> m: roundrobin((<a b c>,)).perl.say

[17:09] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «("a", "b", "c").Seq␤»

[17:09] <xinming_> m: my %h = :a<a b c>; %h<>:v.perl.say;

[17:09] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «($("a", "b", "c"),)␤»

[17:10] <jnthn> m: my %h = %(:a<a b c>); dd roundrobin(%h<>:v.map: *.flat)

[17:10] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «("a", "b", "c").Seq␤»

[17:10] <xinming_> m: my %h = %(:a<a b c>, :xx); dd roundrobin(%h<>:v.map: *.flat)

[17:10] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «(("a", Bool::True), ("b",), ("c",)).Seq␤»

[17:10] <jnthn> m: my %h = %(:a<a b c>, :xx); dd roundrobin(%h<>:v.map: *.flat)

[17:10] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «((Bool::True, "a"), ("b",), ("c",)).Seq␤»

[17:10] *** rindolf left
[17:10] <jnthn> m: my %h = %(:a<a b c>, :xx); dd roundrobin(%h<>:v.map: *.list)

[17:10] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «(("a", Bool::True), ("b",), ("c",)).Seq␤»

[17:11] <jnthn> m: my %h = %(:a<a b c>); dd roundrobin(%h<>:v.map: *.list)

[17:11] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «("a", "b", "c").Seq␤»

[17:11] <xinming_> So, there is some inconsistency here.

[17:11] <jnthn> m: my %h = %(:a<a b c>); dd (%h<>:v.map: *.list)

[17:11] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «(("a", "b", "c"),).Seq␤»

[17:11] <jnthn> m: my %h = %(:a<a b c>, :xx); dd (%h<>:v.map: *.list)

[17:11] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «((Bool::True,), ("a", "b", "c")).Seq␤»

[17:12] <jnthn> Yeah, everything looks right until it reaches roundrobin

[17:12] <jnthn> Then I'm indeed a bit surprised by it

[17:13] <xinming_> Why?

[17:13] *** rindolf joined
[17:13] <xinming_> I'd consider this is bug in roundrobin. though, no idea how it should be fixed.

[17:14] <jnthn> Yes, that's what I'm saying: if there's something to fix, it's roundrobin

[17:15] <jnthn> m: sub rr(+@lol) { dd @lol }; rr (<a b c>, (True))

[17:15] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «Array element = [("a", "b", "c"), Bool::True]␤»

[17:15] <jnthn> m: sub rr(+@lol) { dd @lol }; rr (<a b c>,)

[17:15] <camelia> rakudo-moar 262b6fc7a: OUTPUT: «Array element = [("a", "b", "c"),]␤»

[17:16] <jnthn> And no structure loss from the signature binding, so looks like it'll be in the Rakudo::Iterator.RoundrobinIterables impl

[17:18] <jnthn> I think it's maybe trying to be more efficient at https://github.com/rakudo/rakudo/blob/131d253a20e9cc50daca6ff084a67ace3d4d89d6/src/core.c/Rakudo/Iterator.pm6#L3265 but getting it wrong

[17:19] <jnthn> e.g. it just iterates the underlying thing, but doesn't wrap them into the 1-element array

[17:19] <jnthn> Probably only special-casing 0 elements is a fix

[17:20] *** chloekek left
[17:23] <xinming_> Do you mean the  == 1 change to == 0?

[17:23] <xinming_> shape.elems == 1   to   shape.elems == 0

[17:23] <xinming_> I'm thinking that if it's 0, We can just return

[17:24] <jnthn> Hm, where is shape? Not sure if we're looking at the same code

[17:25] <xinming_> hmm, Ignore me, I was in different branch. :-)

[17:25] <xinming_> I was looking at the ShapeIndex method

[17:25] <jnthn> I think it should maybe just be like

[17:25] <jnthn>     method RoundrobinIterables(@iterables) {

[17:25] <jnthn>         nqp::if(

[17:25] <jnthn>           nqp::isgt_i(@iterables.elems,0),  # reifies

[17:25] <jnthn>           RoundrobinIterables.new(@iterables),

[17:25] <jnthn>           Rakudo::Iterator.Empty,

[17:26] <jnthn>         )

[17:26] <xinming_> Ok, Waiting for the patch. :-)

[17:32] <jnthn> Can you open an issue with this information?

[17:32] <xinming_> Ok

[17:35] <jnthn> Maybe somebody will beat me to getting the patch in; otherwise I can in a day or so

[17:35] <jnthn> Need to sort out a dev environment for me... :)

[17:35] <jnthn> Well, re-sort :)

[17:40] <xinming_> jnthn: Your code does fix the problem.

[17:41] <xinming_> I just re-compile the raku

[17:44] <Geth> ¦ doc: threadless-screw++ created pull request #3138: Expansion of Operator precedence and Assignment operators sections

[17:44] <Geth> ¦ doc: review: https://github.com/Raku/doc/pull/3138

[17:44] <squashable6> 🍕 threadless-screw++ opened pull request “Expansion of Operator pr…”: https://github.com/Raku/doc/pull/3138

[17:44] <squashable6> 🍕🍕🍕  First contribution by threadless-screw++! ♥

[17:45] <AlexDaniel> SORRY

[17:45] <AlexDaniel> squashable6: next

[17:45] <squashable6> AlexDaniel, Next SQUASHathon in 28 days and ≈10 hours (2020-02-02 UTC-12⌁UTC+20). See https://github.com/rakudo/rakudo/wiki/Monthly-Bug-Squash-Day

[17:48] <xinming_> my %h = %(:a<a b c>, :xx[]); for roundrobin(%h<>:v.map: *.flat) -> @list { @list.perl.say; }

[17:48] <evalable6> xinming_, rakudo-moar 262b6fc7a: OUTPUT: «("a",)␤("b",)␤("c",)␤»

[17:52] *** Altai-man_ joined
[17:52] *** sena_kun left
[17:54] <xinming_> jnthn: https://github.com/rakudo/rakudo/issues/3402

[17:59] *** wamba joined
[18:05] *** xinming_ left
[18:06] *** xinming_ joined
[18:13] *** Poohmaan joined
[18:14] <Geth> ¦ doc: 0f6fa999b7 | threadless-screw++ | doc/Language/operators.pod6

[18:14] <Geth> ¦ doc: Expansion of Operator precedence and Assignment operators sections; work towards resolving #2920

[18:14] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/0f6fa999b7

[18:14] <Geth> ¦ doc: 562b3c189d | (Juan Julián Merelo Guervós)++ (committed using GitHub Web editor) | doc/Language/operators.pod6

[18:14] <Geth> ¦ doc: Merge pull request #3138 from threadless-screw/operators_assignment

[18:14] <Geth> ¦ doc: 

[18:14] <Geth> ¦ doc: Expansion of Operator precedence and Assignment operators sections

[18:14] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/562b3c189d

[18:16] *** Poohman left
[18:16] <eiro> tyil: thanks for replying on the list as well

[18:16] *** patrickb joined
[18:18] <stoned75> commit: releases .signature.say for "foo".^can("comb")[0].cando: \(Cool, "o");

[18:18] <committable6> stoned75, https://gist.github.com/abeebf18a3d63c86d48f2f32a3a5e0ac

[18:20] <stoned75> it seems we lost our comb :)

[18:21] *** mahmudov joined
[18:23] <Geth> ¦ doc: af869314fe | (Stoned Elipot)++ | doc/Type/Routine.pod6

[18:23] <Geth> ¦ doc: xref proto

[18:23] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/af869314fe

[18:36] <xinming_> I think I found another bug

[18:36] <xinming_> I'll try to narrow it down.

[18:40] <AlexDaniel> bisect: old=2017.02 .signature.say for "foo".^can("comb")[0].cando: \(Cool, "o");

[18:40] <bisectable6> AlexDaniel, Bisecting by output (old=2017.02 new=e5627b8) because on both starting points the exit code is 0

[18:40] <xinming_> https://termbin.com/47tu   <--- In this example, We'll get error

[18:40] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/d7541cc997a835109c136f17445a3823

[18:40] <bisectable6> AlexDaniel, (2017-02-22) https://github.com/rakudo/rakudo/commit/a08e9530181ea08d4d79b44bb77c18e678cbc4b0

[18:40] <xinming_> No such method 'key' for invocant of type 'Str'. Did you mean 'keys'?    <---

[18:40] <AlexDaniel> stoned75: ↑

[18:42] <xinming_> if anyone here have time, Please check this bug too.  https://termbin.com/47tu   <--- If I change this to $regex, It'll work, by using $_ var, I'll get error    o such method 'key' for invocant of type 'Str'. Did you mean 'keys'?

[18:52] <moritz> xinming_: change what, exactly?

[18:52] <xinming_> moritz: with  $regex, It'll work

[18:52] <moritz> xinming_: you have to be careful, $a ~~ $b sets $_ to $a

[18:53] <moritz> when the RHS of the ~~ is evaulated

[18:53] <xinming_> Ah, Got it, I thought this is a bug.

[18:53] <moritz> which is why using $_ or not using $_ can make a big difference in smart matches

[18:54] <xinming_> I thought that when use of  `when`, the $_ is used, otherwise, It won't.

[18:57] <moritz> blocks without a signature tend to set $_

[18:57] <moritz> "for", "given" etc.

[19:20] <Xliff> When you re-export a package by using "use Package; sub EXPORT { %(PACKAGE::EXPORT::DEFAULT::) }", it works, but doesn't have a package itself so it can be re-exported. How can I fix that?

[19:21] <Xliff> s/can/can't/

[19:22] <Xliff> See this example: https://github.com/Xliff/p6-GLib/blob/master/lib/GLib/Raw/Types.pm6

[19:24] <Xliff> I can "use GLib::Raw::Types" and it will DWIM, but I cannot re-export the symbols from GLib::Raw::Types using the same mechanism, because GLib::Raw::Types isn't a package.

[19:24] <Xliff> So what am I missing?

[19:29] *** sauvin left
[19:38] *** timotimo joined
[19:45] *** wildtrees joined
[19:52] *** sena_kun joined
[19:53] *** Altai-man_ left
[19:54] *** wildtrees left
[19:55] <moritz> probably the not-yet-specced/implemented re-export feature?

[20:17] <tyil> eiro: no problem :)

[20:18] *** wildtrees joined
[20:20] <Xliff> moritz: Well, got this --- https://github.com/LLFourn/p6-CompUnit-Util#re-export

[20:20] <Xliff> And it seems to work. Time will tell.

[20:20] <Xliff> .seen LLFourn

[20:20] <tellable6> Xliff, I saw LLFourn 2018-12-19T10:41:23Z in #perl6: <llfourn> nod. I think I just have to let go of that feeling and only use :D when I actually want to do a runtime check.

[20:30] *** rindolf left
[20:45] *** patrickz joined
[20:46] *** patrickb left
[21:00] *** horsepatat left
[21:00] *** chloekek joined
[21:02] *** kensanata joined
[21:02] *** wamba left
[21:17] *** MasterDuke joined
[21:38] *** mahmudov left
[21:39] *** mahmudov joined
[21:51] *** Altai-man_ joined
[21:53] *** sena_kun left
[22:20] *** mahmudov left
[22:20] *** mahmudov joined
[22:23] <Doc_Holliwood> jnthn, you will have to spend an extra weekend in purgatory for this terrible, terrible pun.

[22:23] *** MasterDuke left
[22:28] *** kensanata left
[22:33] <Xliff> Doc_Holliwood: What terrible, terrible pun?

[22:33] <Doc_Holliwood> my Cro::Service

[22:36] <lizmat> hehe...  :-)

[22:37] * bartolin giggles

[22:42] <Doc_Holliwood> weekly: https://www.perlmonks.org/?node_id=11110913

[22:42] <notable6> Doc_Holliwood, Noted! (weekly)

[22:44] * lizmat hopes the flak will be bearable

[22:45] <Xliff> .....

[22:45] <Xliff> Ooooooo

[22:45] <Xliff> Doc_Holliwood: I think you are being too kind. Let's go for two weekends.

[22:48] <chloekek> p6: say 2¹²; say (2¹⁰)²

[22:48] <camelia> rakudo-moar e5627b83a: OUTPUT: «4096␤1048576␤»

[22:57] *** lucasb left
[23:04] <stoned75> AlexDaniel: thanks!

[23:27] *** mahmudov left
[23:30] *** mahmudov joined
[23:31] <Doc_Holliwood> lizmat: One hour in. No flak yet, but no upvotes either.

[23:31] <Doc_Holliwood> I guess the monks are sleeping.

[23:34] <lizmat> yeah...  most likely...  

[23:37] *** mahmudov left
[23:39] *** mahmudov joined
[23:44] *** mahmudov left
[23:49] <jnthn> Doc_Holliwood: You only just noticed? :D

[23:50] *** mahmudov joined
[23:52] *** sena_kun joined
[23:54] *** Altai-man_ left
