[00:10] *** pecastro left
[00:15] *** sena_kun joined
[00:16] *** zacts joined
[00:16] *** Altai-man_ left
[00:18] *** aborazmeh joined
[00:18] *** aborazmeh left
[00:18] *** aborazmeh joined
[00:20] *** zacts left
[00:28] *** NewGreyhawke left
[00:32] <guifa2> Xliff: You could make a suffix, I suppose, but IME it's *very* tricky keeping native stuff as natives.  Even doing something like $a + ($b - $c) has booted them out of native and into general Ints

[00:43] *** MilkmanDan left
[00:45] *** MilkmanDan joined
[00:45] *** aborazmeh left
[00:53] *** _jrjsmrtn joined
[00:55] *** __jrjsmrtn__ left
[01:02] *** silug left
[01:03] *** silug joined
[01:22] *** NewGreyhawke joined
[01:23] *** silug6 joined
[01:23] *** silug left
[01:23] *** silug6 is now known as silug

[01:23] *** lucasb left
[01:59] *** molaf left
[02:02] <Xliff> guifa: Yeah. Everything has to be typed!

[02:02] <Xliff> Using binds also helps.

[02:02] <Xliff> The moment it conts, you lose the native, I think.

[02:03] *** Noisytoot left
[02:06] *** ManifestO left
[02:06] *** ManifestO joined
[02:07] *** Noisytoot joined
[02:11] *** molaf joined
[02:13] *** Altai-man_ joined
[02:16] *** sena_kun left
[02:21] *** Noisytoot left
[02:24] *** Noisytoot joined
[02:30] *** Noisytoot left
[02:35] *** oodani_ left
[02:35] *** oodani joined
[02:37] *** kst left
[02:48] <Geth> ¦ doc: coke self-assigned xt/examples-compilation.t https://github.com/Raku/doc/issues/3391

[03:22] *** kst joined
[03:25] *** guifa2_ joined
[03:25] *** guifa2 left
[03:25] *** guifa2_ is now known as guifa2

[03:34] *** gordonfish joined
[03:48] *** cpan-raku left
[03:50] *** RaycatWhoDat joined
[03:50] *** zacts joined
[03:50] *** cpan-raku joined
[03:50] *** cpan-raku left
[03:50] *** cpan-raku joined
[03:50] *** RaycatWhoDat left
[04:09] *** leont joined
[04:14] *** sena_kun joined
[04:15] *** sivoais_ left
[04:15] *** sivoais joined
[04:16] *** Altai-man_ left
[05:05] *** reach_satori left
[05:05] *** reach_satori joined
[05:07] *** skids joined
[05:18] *** wamba joined
[05:45] *** rindolf joined
[06:13] *** Altai-man_ joined
[06:16] *** sena_kun left
[06:17] *** NewGreyhawke left
[06:19] <cpan-raku> New module released to CPAN! Chart::Gnuplot (0.0.18) by 03TITSUKI

[06:30] *** skids left
[06:44] *** xinming left
[06:51] <cpan-raku> New module released to CPAN! Chart::Gnuplot (0.0.19) by 03TITSUKI

[07:15] *** wamba left
[07:32] *** xinming joined
[07:47] *** xinming left
[07:49] *** xinming joined
[07:49] <Geth> ¦ doc: 889c6aa040 | (Tom Browder)++ (committed using GitHub Web editor) | doc/Language/intro.pod6

[07:49] <Geth> ¦ doc: proposed table of Raku vs. Perl 6 deprecations (#3252)

[07:49] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/889c6aa040

[07:49] <linkable6> Link: https://docs.raku.org/language/intro

[07:49] <linkable6> DOC#3252 [closed]: https://github.com/Raku/doc/pull/3252 proposed table of Raku vs. Perl 6 deprecations

[07:59] *** Zero_Dogg left
[08:08] *** Noisytoot joined
[08:14] *** sena_kun joined
[08:16] *** Altai-man_ left
[08:25] <Geth> ¦ doc: e707196480 | (JJ Merelo)++ | doc/Type/Supply.pod6

[08:25] <Geth> ¦ doc: Changes former definition to table

[08:25] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/e707196480

[08:25] <Geth> ¦ doc: f818b95bce | (JJ Merelo)++ | doc/Type/Supply.pod6

[08:25] <Geth> ¦ doc: Adds new definitions to Supply.throttle.

[08:25] <Geth> ¦ doc: 

[08:25] <Geth> ¦ doc: Also rewrites a part. Closes #175

[08:25] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/f818b95bce

[08:25] <linkable6> Link: https://docs.raku.org/type/Supply

[08:25] <linkable6> DOC#175 [closed]: https://github.com/Raku/doc/issues/175 [docs] Document Supply.throttle(:$vent-at)

[08:36] *** Zero_Dogg joined
[08:50] <Geth> ¦ doc: d9fa24d5bc | (JJ Merelo)++ | doc/Type/Supply.pod6

[08:50] <Geth> ¦ doc: Reformatting working on #1875

[08:50] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/d9fa24d5bc

[08:50] <Geth> ¦ doc: b4ac61ded0 | (JJ Merelo)++ | doc/Type/Supply.pod6

[08:50] <Geth> ¦ doc: Moves Supply.reduce, closes #1875

[08:50] <Geth> ¦ doc: 

[08:50] <Geth> ¦ doc: Also, some clarification.

[08:50] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/b4ac61ded0

[08:50] <linkable6> Link: https://docs.raku.org/type/Supply

[08:50] <linkable6> DOC#1875 [closed]: https://github.com/Raku/doc/issues/1875 [bug][docs] Supply.reduce waits for the Supply to finish

[09:13] *** oddp joined
[09:13] *** MasterDuke joined
[09:26] *** Sgeo left
[09:31] *** cpan-raku left
[09:31] *** cpan-raku_ joined
[09:31] *** cpan-raku_ left
[09:31] *** cpan-raku_ joined
[09:42] *** HarmtH_ joined
[09:43] *** markong joined
[09:43] *** HarmtH left
[09:49] *** wamba joined
[09:51] *** Black_Ribbon left
[09:54] *** markong left
[09:55] *** markong joined
[10:02] <Geth> ¦ doc: bb4543d9ac | (JJ Merelo)++ | doc/Type/Supply.pod6

[10:02] <Geth> ¦ doc: Adds definitionf of Supply.tail #3527

[10:02] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/bb4543d9ac

[10:02] <linkable6> Link: https://docs.raku.org/type/Supply

[10:02] <linkable6> DOC#3527 [open]: https://github.com/Raku/doc/issues/3527 [RFE][docs][help wanted][versions] Checklist for 2020.07

[10:13] *** Altai-man_ joined
[10:16] *** sena_kun left
[10:22] *** pecastro joined
[10:26] <holyghost> I am going to start Tuesday on racul, a scheme language extension compiler/interpreter which extends raku applications, probably not the compiler itself

[10:26] <holyghost> It's on Xliff's server and at http://github.com/theholyghost2/racul

[10:27] <holyghost> I chose the name from dracul (dragon knight) and guile (gnu extensions system from the scheme language)

[10:28] <holyghost> So basically it's scheme language specifically for raku, instead of using guile, I start from scratch

[10:28] <holyghost> It'll be revised scheme report 3 at the minimum

[10:29] <holyghost> So no continuations for example, to start with

[10:29] <holyghost> (I've written unterpaganperl)

[10:31] <holyghost> It's probably be written in plain ANSI C

[10:32] <holyghost> I cannot give pf and pm a new language though, but if racul is somewhere, anyone can extend the scheme language

[10:33] <holyghost> It'll be a modularized system

[10:55] *** NewGreyhawke joined
[10:58] *** erdic left
[10:59] *** telex left
[11:01] *** erdic joined
[11:02] *** telex joined
[11:19] *** xinming left
[11:20] *** xinming joined
[11:20] *** aborazmeh joined
[11:20] *** aborazmeh left
[11:20] *** aborazmeh joined
[11:24] *** xinming left
[11:25] *** xinming joined
[11:29] *** kensanata joined
[11:41] *** kensanata left
[11:44] *** wamba left
[11:55] *** NewGreyhawke left
[12:14] *** sena_kun joined
[12:17] *** Altai-man_ left
[12:34] *** aborazmeh left
[12:48] <Xliff> https://gist.github.com/Xliff/600d1c8ba52ce33c6c0bcbf43fb24ccc <- Solves my enum problem 

[12:48] *** Ven`` joined
[12:55] *** Zero_Dogg left
[12:59] *** sena_kun1 joined
[13:03] *** kensanata joined
[13:09] *** Zero_Dogg joined
[13:25] <[ptc]> silly question time: theoretically, the regex `m:i:g/ 'bb' || <-[ b ]> ** 2 /` should match either two 'b's or not a 'b' twice

[13:26] <[ptc]> my question is: is it possible to write that more elegantly?

[13:32] <codesections> Hmmm, interesting question.  My first thought (combining into `[ 'bb' || <-[ b ]> ] ** 2` doesn't work.

[13:34] <[ptc]> maybe `[ 'b' || <-[ b ]> ] ** 2` ?

[13:36] <codesections> er, right, that's what I meant (the 'bb' was a typo on my part).  I thought that might work, but it doesn't

[13:37] <codesections> but that matches 'ab'.  Which I'm slightly surprised by – I guess the branch is evaluated seperately on each repetition 

[13:40] <[ptc]> hrm, true.  Weird.

[13:40] <[ptc]> m: say "abBii" ~~ m:i:g/ 'bb' || <-[ b ]> ** 2 /;

[13:40] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢bB｣ ｢ii｣)␤»

[13:40] <[ptc]> say "abBii" ~~ m:i:g/ [ 'b' || <-[ b ]> ] ** 2 /;

[13:40] <evalable6> [ptc], rakudo-moar 3843a1e89: OUTPUT: «(｢ab｣ ｢Bi｣)␤»

[13:41] <lizmat> moritz ^^

[13:41] <[ptc]> my raku is amazingly rusty...  still trying to get back up to speed

[13:42] <Voldenet> m: "aaabbbac" ~~ m:Perl5:g/bb|[^b]{2}/

[13:42] <camelia> rakudo-moar 3843a1e89: ( no output )

[13:43] <[ptc]> Voldenet: in theory that should work (at least, that was the version on the T-shirt I used to own ;-) )

[13:44] <Voldenet> oh, i just realized what it means :D

[13:45] <Voldenet> and it'd work in perl5, so I wonder why doesn't it now

[13:45] <Voldenet> m: "aaabbbac" ~~ m:Perl5:g/a/

[13:45] <camelia> rakudo-moar 3843a1e89: ( no output )

[13:45] <Voldenet> m: "aaabbbac" ~~ m:Perl5/a/

[13:45] <camelia> rakudo-moar 3843a1e89: ( no output )

[13:46] <codesections> I'll be kind of sad if the best Raku regex we can come up with involves the `Perl5` adverb :)

[13:46] <Voldenet> that's weird

[13:46] <codesections> m: say "aaabbbac" ~~ m:Perl5:g/bb|[^b]{2}/ 

[13:46] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢aa｣ ｢bb｣ ｢ac｣)␤»

[13:46] <Voldenet> …lol, right

[13:46] <codesections> :)

[13:47] <Voldenet> I'd argue about "best" - shortest maybe ;)

[13:48] <[ptc]> yeah, I'd like to steer clear of the Perl5 adverb :-)

[13:48] <Voldenet> m: say "aaabbbac" ~~ m:g/bb||<-[b]> ** 2/

[13:48] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢aa｣ ｢bb｣ ｢ac｣)␤»

[13:48] <Voldenet> it's almost the same

[13:49] <Voldenet> in fact

[13:49] <Voldenet> m: say "aaabbbac" ~~ m:g/bb|<-[b]> ** 2/

[13:49] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢aa｣ ｢bb｣ ｢ac｣)␤»

[13:49] <[ptc]> true, but it has more of a raku flavour, and that's what I'm interested in

[13:50] <[ptc]> yeah, that's definitely better than my attempt

[13:50] <Voldenet> it's literally the same tho :D

[13:51] <[ptc]> but in p5 it's not possible to spread it out with whitespace (not using /x, of course)

[13:51] <[ptc]> and I think that makes it easier for the brain to parse when reading it

[13:52] <Voldenet> i've seen regex hell, nothing scares me anymore

[13:52] <[ptc]> hehe

[13:52] <[ptc]> m: say "aaabbbac" ~~ m:g/ bb || <-[b]> ** 2/

[13:52] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢aa｣ ｢bb｣ ｢ac｣)␤»

[13:53] <[ptc]> that feels a bit more "idiomatic raku" to me...  Dunno if there's such a thing as idiomatic raku yet though

[13:56] <Voldenet> m: say "aaabbbac" ~~ m:g/ bb || <-[b]><-[b]> /

[13:56] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢aa｣ ｢bb｣ ｢ac｣)␤»

[13:59] <[ptc]> m: my $question = 'aaabbbac'; $question ~~ m:g/ bb || <-[b]> ** 2/;

[13:59] <camelia> rakudo-moar 3843a1e89: ( no output )

[13:59] <[ptc]> m: my $question = 'aaabbbac'; say $question ~~ m:g/ bb || <-[b]> ** 2/;

[13:59] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢aa｣ ｢bb｣ ｢ac｣)␤»

[13:59] *** wamba joined
[14:00] <[ptc]> I had hoped to be able to use rx//, but the :g adverb doesn't work with rx//

[14:00] <[ptc]> took me a while to work out why, but once I found the place in the docs, it became clearer :-)

[14:00] <[ptc]> thanks for the tips everyone!

[14:01] <codesections> m: say 'aaabbbac' ~~ m:i:g/ 'a' ** {(1, 3)}/

[14:01] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(｢aa｣)␤»

[14:02] <codesections> why doesn't that dwim?  I would have thought that would be "either 1 or 3 'a's", but it returns 2

[14:04] <timotimo> it numifies the list, the list has two elements, so it's equivalent to `** 2`

[14:05] <codesections> …oh.  Right, because it won't take a list, just a Range

[14:05] <timotimo> that's right

[14:05] *** sena_kun1 left
[14:05] <timotimo> if you want to have two alternatives, you will need an alteration

[14:06] <timotimo> perhaps at some point junctions of integers could be supported?

[14:06] <codesections> and the same is true of something like (1, * + 5 … 6)

[14:06] <codesections> Which I *think of* as a Range, but really reduces to a (perhaps lazy) List

[14:07] <timotimo> i would not call that a range

[14:08] <timotimo> especially since it has a gap :)

[14:08] <codesections> Well, it's a Seq 

[14:08] <timotimo> yeah, ... is the Sequence operator

[14:08] <timotimo> Range is more closely related to the mathematical notion of an Interval

[14:09] <codesections> I (sloppily) think of as being "like Ranges but fancier" :)

[14:09] <codesections> which I should probably stop doing!

[14:13] <codesections> m: 'aa' ~~ /a ** {('str', 'str2')}/

[14:13] <camelia> rakudo-moar 3843a1e89: ( no output )

[14:14] <codesections> m: 'aa' ~~ /a ** {'str2'}/

[14:14] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Cannot use non-Numeric or NaN value as quantifier␤  in block <unit> at <tmp> line 1␤␤»

[14:14] *** Altai-man_ joined
[14:14] <moritz> a sequence operator is closer to a loop

[14:14] <codesections> Do you think it's a bug that the List example coerces to Numeric without throwing the same error that the Str version does?

[14:14] *** rawr is now known as grumble

[14:15] <timotimo> could probably warn when it's a literal

[14:16] <timotimo> if you're using a variable that has a list in it and it gets numified for you, that's usually a feature; like "match a string with as many 'a's as the array has elements" essentially

[14:16] <codesections> is that just to save typing `.elems`?

[14:16] *** sena_kun left
[14:18] <moritz> yes

[14:18] <moritz> also, p5 heritage

[14:19] *** xelxebar_ joined
[14:20] *** xelxebar left
[14:20] <codesections> and I guess we do have a warning sign https://docs.raku.org/language/traps#Lists_numify_to_their_number_of_elements_in_numeric_context

[14:20] *** sftp left
[14:20] <codesections> :)

[14:21] <codesections> (Just not on the Regex page)

[14:23] *** sftp joined
[14:37] *** Xliff left
[14:59] <samebchase-> In Raku, we use grep when we want to filter elements based on a predicate. How do we return the elements from a sequence that do NOT match a predicate. Other languages have a "remove" function, what's the most idiomatic Raku way of doing this? 

[14:59] *** xinming left
[15:00] <samebchase-> "Note that if you want to grep for elements that do not match, you can use a none-Junction:" hmm, found this in the documentation

[15:00] *** xinming joined
[15:01] <codesections> In many cases, you can also just flip the test, right?

[15:01] <codesections> m: (^20).grep({!.is-prime}) 

[15:01] <camelia> rakudo-moar 3843a1e89: ( no output )

[15:01] <codesections> m: say (^20).grep({!.is-prime}) 

[15:01] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(0 1 4 6 8 9 10 12 14 15 16 18)␤»

[15:03] <samebchase-> hmm, complementing the predicate seems to be the easiest way

[15:03] <samebchase-> thanks codesections!

[15:04] <codesections> you're welcome :)

[15:05] <codesections> (Something I really like about Raku is how it does a lot more with simple combinations of well-thought out operations (here, smartmatching and junctions) where other languages use a lot more methods)

[15:06] <timotimo> codesections: many tests are not code :)

[15:06] <timotimo> m: say <a b c d e f g>.grep(none <a e f>)

[15:06] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(b c d g)␤»

[15:06] <samebchase-> The reason I ask is, I was writing some code recently, and to write a filter, I had an "if", of the form (if cond A and cond B, then check cond C or return true otherwise). It seemed clunky to have a true in the else branch, so I changed it to use remove with the if changing to (if cond A and cond B then check inverse of cond C), and I got rid of t

[15:06] <samebchase-> he "true" part if that makes any sense

[15:08] *** pi4 left
[15:09] *** e left
[15:10] <samebchase-> , but the language I was using (Clojure) had "when", but Raku's when has the behaviour which bit me recently "When the when block is executed, control is passed to the enclosing block and /following statements are ignored/!"

[15:11] <codesections> That *feels* like a good use case for a Junction, but I'm not quite sure…

[15:11] <samebchase-> so I avoid using when as much as possible

[15:12] <codesections> Why's that?  To avoid multiple exit points for the fn?

[15:12] <samebchase-> I guess, it seems to me right now, that we can use a combination of flipping the predicate or the none Junction as described in the documentation, depending on the case

[15:13] <samebchase-> codesections, basically someone used to Lisp or Clojure's when/unless should be wary of Raku "when" gotcha, but interestingly enough Raku's "unless" does not have the same gotcha 

[15:15] <codesections> Interesting.  I hadn't thought about it from a Lisp point of view.  There, the distinction between `if` and `when` is that `when` allows multiple forms without `progn` or whatever?  (My Lisp is a bit rusty)

[15:15] <samebchase-> If you don't have an else branch, it just seems cleaner to use when/unless (in those languages), but I guess, in Raku we should use if without an else branch in situations where there could be other statements following the if block.

[15:16] *** kensanata left
[15:16] <samebchase-> codesections: yeah, the implicit progn/do is a convenience feature

[15:17] <samebchase-> If anyone can let me know why Raku's "when" does it this way, I am interested to know the reason, purely out of curiosity.

[15:18] *** NewGreyhawke joined
[15:18] <codesections> re "use if without an else branch", especially since `if` can be an expression, with either `do` or parens 

[15:18] <samebchase-> I had a major, "is there something wrong with the universe" situation, when the last few statements of my program were just not getting executed, and then I read the documentation

[15:18] <codesections> m: say (if True { 'foo' } ~ 'bar' 

[15:18] <camelia> rakudo-moar 3843a1e89: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3say (if True { 'foo' }7⏏5 ~ 'bar'␤»

[15:18] <codesections> m: say (if True { 'foo' }) ~ 'bar' 

[15:18] <camelia> rakudo-moar 3843a1e89: OUTPUT: «foobar␤»

[15:18] *** MilkmanDan left
[15:21] <codesections> I can't speak to the "why" – I'm new and wasn't there – but `when`'s behavior always made sense to me because I thought of it as part of the `given … when` construct, just used without the `given`.  Which makes it a bit like the `case` block in switch statements in many langauges (or, the `match` block in Rust, where I was coming from).  Not having fall through there made sense to me 

[15:22] <codesections> Well, that and I wasn't expecting a `when` to exist, so I first learned it as "if without fallthrough" instead of expecting it to exist

[15:23] *** MilkmanDan joined
[15:27] <Kaiepi> `when` is a bit weird and took me a while to understand how to use it well

[15:28] <Kaiepi> i don't like to think of it like `case` in a `switch` because you can use it anywhere, not just in a `given`

[15:28] <Kaiepi> unlike `if`, it smartmatches $_ against its condition

[15:28] <Kaiepi> this makes it useful in stuff like `for` loops as well:

[15:28] <Kaiepi> m: for 1..100 { when * %% 15 { say 'FizzBuzz' }; when * %% 3 { say 'Fizz' }; when * %% 5 { say 'Buzz' }; default { say $_ } }

[15:28] <camelia> rakudo-moar 3843a1e89: OUTPUT: «1␤2␤Fizz␤4␤Buzz␤Fizz␤7␤8␤Fizz␤Buzz␤11␤Fizz␤13␤14␤FizzBuzz␤16␤17␤Fizz␤19␤Buzz␤Fizz␤22␤23␤Fizz␤Buzz␤26␤Fizz␤28␤29␤FizzBuzz␤31␤32␤Fizz␤34␤Buzz␤Fizz␤37␤38␤Fizz␤Buzz␤41␤Fizz…»

[15:30] <holyghost> ok, I started work on racul, I have some lines for a symbol table already, I will continue later on

[15:30] <holyghost> Bzzzt

[15:31] *** wamba left
[15:43] <samebchase-> Kaiepi: nice

[15:43] *** wamba joined
[15:45] *** Voldenet left
[15:51] *** NickSeagull joined
[15:52] *** NickSeagull left
[15:53] *** NickSeagull joined
[15:55] <codesections> m: sub f($i) { (^$i).map({CATCH { default { "PLACEHOLDER" } }; if $_ == 5 {die}; $_ × 2})}; say f 10 

[15:56] <camelia> rakudo-moar 3843a1e89: OUTPUT: «(0 2 4 6 8 Nil 12 14 16 18)␤»

[15:56] <NickSeagull> Hi! Raku newcomer here :) Coming from Haskell, I'm loving the language a lot

[15:56] <codesections> why is the 6th item in that list ^^^^ `Nil` and not `PLACEHOLDER`?

[15:57] <codesections> NickSeagull: Welcome!  I'm also fairly new, and came here from Rust

[15:57] *** Voldenet joined
[15:57] *** Voldenet left
[15:57] *** Voldenet joined
[15:58] <NickSeagull> I'd like to be a bit more involved in the community. Are there any efforts geared towards having LSP ready for Raku? I'd like to work on that :)

[15:58] <codesections> I miss `Option` and expect you'll miss `Maybe`, but otherwise like it a lot :)

[15:58] <lizmat> LSP ?

[15:58] <NickSeagull> codesections: Thanks! :D

[15:58] <codesections> Language Server Protocol 

[15:59] <NickSeagull> lizmat: Language Server Protocol: https://microsoft.github.io/language-server-protocol/

[15:59] <lizmat> ah...  I seem to recall it being mentioned before

[15:59] <lizmat> but I think it was like "a nice to have"

[16:00] <NickSeagull> I thought about starting to work on it as a pet project, while getting more in depth with Raku. But didn't want to split efforts if something was going on already

[16:00] <NickSeagull> Looks like there's nothing on GitHub about it though

[16:01] <codesections> I've been toying with the idea of building an Emacs extension that's modeled after a striped down version of the LSP – but just focused on documentation rather than autocompletion 

[16:02] <codesections> but using the same basic json transport and client/server model 

[16:03] <NickSeagull> codesections: Cool! What I like about LSP itself is that it unifies the core part of the language support and then the users can use their favorite editors :)

[16:03] <codesections> Yeah, that is powerful!

[16:03] <Altai-man_> NickSeagull, there is https://github.com/azawawi/ide-perl6 and https://github.com/azawawi/app-perl6langserver but I think they are incomplete and want a maintainer, so if you feel like doing a great thing you can try to contact author / fork and go.

[16:04] <NickSeagull> This is super helpful Altai-man_ , thanks!

[16:05] <codesections> have you seen this talk by Jonathan Worthington about building the Comma IDE for Raku? https://www.youtube.com/watch?v=zDP9uUMYrvs

[16:05] <NickSeagull> codesections, Nope, but will look into it now ty

[16:06] <codesections> He talks about writing a different compiler/interpreter for the IDE work to deal with the (very different) challenge of real-time autocompletion/etc with program input that is usually invalid 

[16:07] <codesections> I *suspect* that a LSP implementation might also need a different compiler backend 

[16:07] <codesections> (The Comma one is not currently open source, though I know Johnathan has mentioned the possibility of releasing it at some point)

[16:13] *** zacts left
[16:15] *** sena_kun joined
[16:16] *** Altai-man_ left
[16:18] *** Sgeo joined
[16:21] <Geth> ¦ doc: 5850cdf925 | (JJ Merelo)++ | doc/Type/Supply.pod6

[16:21] <Geth> ¦ doc: New functionalities of Supply.tail #3527

[16:21] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/5850cdf925

[16:22] <linkable6> Link: https://docs.raku.org/type/Supply

[16:22] <linkable6> DOC#3527 [open]: https://github.com/Raku/doc/issues/3527 [RFE][docs][help wanted][versions] Checklist for 2020.07

[16:22] *** zacts joined
[16:24] *** zacts left
[16:25] *** zacts joined
[16:26] *** zacts left
[16:31] <NickSeagull> I'm confused, why are there two github orgs: Raku and Perl6?

[16:31] <timotimo> the name change ws just recently

[16:32] <NickSeagull> timotimo, Yep, but shouldn't it be just a rename of the GH org instead of creating a new one?

[16:32] <moritz> there's a slow migration from Perl6 to Raku

[16:32] <NickSeagull> in what way moritz ?

[16:34] *** Zero_Dogg left
[16:35] <moritz> repos are being migrated one by one, after careful consideration if we still need it

[16:36] <NickSeagull> Ah cool :)

[16:39] <NickSeagull> Is there a way to typecheck a module using Rakudo? Without running that is

[16:40] <timotimo> very difficult

[16:40] <timotimo> BEGIN time stuff, including using modules, and types that are defined with predicates that are code, all make it extra hard

[16:41] <moritz> NickSeagull: there are some type errors that are caught at compile time. You can catch those with rakudo -c path/to/file

[16:41] <moritz> but most type errors are run time

[16:41] <timotimo> the lack of restrictions on what subclasses are allowed to do with methods also makes things dicey

[16:41] <NickSeagull> ah :(

[16:42] <timotimo> in C++ for example, you have restrictions what subclasses do with a virtual method's signature, right?

[16:43] <NickSeagull> I see

[16:44] <NickSeagull> Yet for simple functions it'd be nice to have something. E.g.: sub f(Int $x --> Bool){ "hello" }; say f 3.4

[16:44] <holyghost> First write of variable and lambda symbol ADTs are in, in racul

[16:44] <timotimo> m: sub f(Int $x){ say "hi" }; f(4.3)

[16:44] <camelia> rakudo-moar 3843a1e89: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Calling f(Rat) will never work with declared signature (Int $x)␤at <tmp>:1␤------> 3sub f(Int $x){ say "hi" }; 7⏏5f(4.3)␤»

[16:44] <timotimo> ^- this is a compile-time error

[16:45] <NickSeagull> timotimo, Yep, but if that compilation succeeds, it will get run

[16:45] <timotimo> ah, there's a syntaxcheck flag to rakudo

[16:45] <NickSeagull> Would be nice if that rakudo -c checked that

[16:45] <timotimo>   -c                   check syntax only (runs BEGIN and CHECK blocks)

[16:45] <NickSeagull> With -c I only get "Syntax OK" for that code

[16:46] <timotimo> oh, it doesn't

[16:46] <Geth> ¦ doc: 1db69d68e1 | (JJ Merelo)++ | doc/Type/Supply.pod6

[16:46] <Geth> ¦ doc: New functionalities of Supply.head using WhateverCode #3527

[16:46] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/1db69d68e1

[16:46] <linkable6> Link: https://docs.raku.org/type/Supply

[16:46] <linkable6> DOC#3527 [open]: https://github.com/Raku/doc/issues/3527 [RFE][docs][help wanted][versions] Checklist for 2020.07

[16:46] <timotimo> in that case, just use --target=optimize instead, lol

[16:46] <timotimo> because this check currently lives in the optimizer

[16:46] <timotimo> (among other things it's because subs can be post-declared and thus may not be available for checking at the call site)

[16:46] <Geth> ¦ doc: acf784f300 | (JJ Merelo)++ | doc/Type/Supply.pod6

[16:46] <Geth> ¦ doc: New functionalities of Supply.head using WhateverCode #3527

[16:46] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/acf784f300

[16:47] <timotimo> perhaps RakuAST will allow this to happen earlier

[16:48] *** Zero_Dogg joined
[16:50] <NickSeagull> timotimo, --target=optimize works, thanks! Coming from Haskell, I'm used that mostly everything happens in the compilation phase heh

[16:51] <timotimo> right

[16:51] <NickSeagull> btw timotimo where can I learn more about RakuAST? Is that a library in development?

[16:51] <timotimo> raku has some things that you usually get from dependent typing environments, but only checked at run time, and therefore not exhaustive at all like a full agda or coq thing

[16:52] <timotimo> i'll dig up some links for you

[16:52] <timotimo> https://www.youtube.com/watch?v=91uaaSyrKm0 - this ought t get you started

[16:52] <NickSeagull> Thanks will watch it

[16:53] <NickSeagull> timotimo, regarding checking types at runtime and ensuring code correctness, how do we work around that? With a TDD approach?

[16:54] *** NewGreyhawke left
[16:54] <timotimo> yeah, perl in general has been big on TDD for a long long time

[16:56] <NickSeagull> But with Raku's type system would it be a thing yet?

[16:56] <timotimo> https://u.setxkbmap.de/#0-H_jmNFEquodjEBSMW8tQ eeeeexcuse me?

[16:57] <sena_kun> timotimo, some of the characters from famous `$character death` are alive though. :P

[16:57] <NickSeagull> timotimo, it looks like its another guy

[16:58] <timotimo> impostors trying to ruin our reputation

[16:59] <NickSeagull> heh

[17:07] *** NewGreyhawke joined
[17:07] <NickSeagull> What's the current way of starting a new project? Does one have to write meta6.json by hand and all that jazz? Or am I missing some hidden thing in zef?

[17:10] <timotimo> Comma offers this functionality i think

[17:10] <timotimo> can also try App::Assixt, mi6, and similar tools

[17:11] <timotimo> there is more, i forgot the other names

[17:12] <NickSeagull> timotimo, thanks looking into them

[17:12] <timotimo> i use mi6 for JSON::Fast

[17:13] <timotimo> "mi6 new Foo::Bar" exists according to its USAGE

[17:13] <NickSeagull> Awesome!

[17:14] <kawaii> someone once sent me a one-liner that would identify all of the module namespaces for easy meta population, but I've long since lost it

[17:15] <codesections> NickSeagull: there's also this page of Module dev tools: https://docs.raku.org/language/modules-extra

[17:16] <NickSeagull> codesections, wow!!! That's what I needed :)

[17:16] <codesections> I can't personally vouch for how up-to-date that page is

[17:18] <codesections> I'm still struggling to understand Raku's model for handling exceptions.

[17:18] <codesections> m: sub f { CATCH { default { 42 }}; die}; say f 

[17:18] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Nil␤»

[17:18] <codesections> why does that return `Nil` instead of `42`?

[17:18] <NickSeagull> codesections, perhaps you have to wrap it in try?

[17:18] *** Ven`` left
[17:18] <timotimo> blocks return the last thing in them

[17:18] <NickSeagull> m: sub f { try { CATCH { default { 42 }}}; die}; say f 

[17:18] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Died␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:19] <timotimo> m: sub f { die; CATCH { default { 42 }}; }; say f

[17:19] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Nil␤»

[17:19] <timotimo> hm, ok

[17:20] <codesections> there is a different form, with try as a statement modifier

[17:20] <codesections> sub f { CATCH { default { 42 }}; die}; say f 

[17:20] <evalable6> codesections, rakudo-moar 3843a1e89: OUTPUT: «Nil␤»

[17:21] <codesections>  m: sub f { try { die } // 42 }; say f

[17:21] <camelia> rakudo-moar 3843a1e89: OUTPUT: «42␤»

[17:21] <codesections> so I know how to get the output I'm looking for, but I'd still like to understand what CATCH is doing

[17:36] *** Ven`` joined
[17:42] <guifa2> CATCH will grab whatever exception was thrown.  It's a phaser though, so it's not called in the normal flow

[17:42] <guifa2> Most languages require you to use the structure   try { … } catch { … }

[17:43] <codesections> with you so far

[17:44] *** markoong joined
[17:44] <guifa2> Just like sometimes it can be cleaner / more readable / etc to use a postfix "if" (esp as a first line in a sub, "DIE If { condition is of secondary importance}" )

[17:44] <guifa2> It can be nice from a readability standpoint to let me know what will happen in the case of a failure in a true

[17:44] <guifa2> try*

[17:44] <guifa2> so you can do 

[17:44] *** markong left
[17:45] <guifa2> try { CATCH { *this-is-important-to-know* } now we try the stuff }

[17:45] <guifa2> phasers will execute at special times, rather than in code order

[17:45] <codesections> m: sub f { CATCH { default { say "I caught something.  Returning 42"; 42 } }; die }; say f

[17:45] <camelia> rakudo-moar 3843a1e89: OUTPUT: «I caught something.  Returning 42␤Nil␤»

[17:45] <guifa2> CATCH is a phaser, so you can put the catch wherever you want in a block

[17:45] <guifa2> and it will only execute if there's an exception

[17:46] <codesections> That CATCH block is being triggered, but it's *not* returning anything?

[17:46] <guifa2> If you want to ignore the error you need to tell CATCH things are okay

[17:48] <guifa2> use .resume if you want to continue the operations from the point of the exception

[17:49] <codesections> Yeah, but I *don't* want to continue from the point of the exception.  I want to abort the current function with a default return value 

[17:49] <guifa2> sub f { say "1. "; CATCH { default { say "Caught"; } }; say "2. "; die; say "3. "; "4." }; say f

[17:49] <evalable6> guifa2, rakudo-moar 3843a1e89: OUTPUT: «1. ␤2. ␤Caught␤Nil␤»

[17:49] <guifa2> ah

[17:49] <guifa2> then just put in "return foo" :-)

[17:49] <guifa2> m: sub f { say "1. "; CATCH { default { say "Caught"; .resume } }; say "2. "; die; say "3. "; "4." }; say f 

[17:49] <camelia> rakudo-moar 3843a1e89: OUTPUT: «1. ␤2. ␤Caught␤3. ␤4.␤»

[17:50] <guifa2> is what I wanted to say but

[17:50] <guifa2> m: sub f { say "1. "; CATCH { default { say "Caught"; return "5." } }; say "2. "; die; say "3. "; "4." }; say f

[17:50] <camelia> rakudo-moar 3843a1e89: OUTPUT: «1. ␤2. ␤Caught␤5.␤»

[17:50] <codesections> m: sub f { CATCH { default { say "I caught something.  Returning 42"; return 42 } }; die }; say f

[17:50] <camelia> rakudo-moar 3843a1e89: OUTPUT: «I caught something.  Returning 42␤42␤»

[17:51] <codesections> oh

[17:51] <codesections> I could have sworn I tried that...

[17:52] <guifa2> Ha, that's how it always goes 

[17:53] <codesections> m: sub f($i) { (^$i).map({CATCH { default { return 42 } }; when $_ == 5 { fail }; $_ × 2})}; say f 10 

[17:53] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block  at <tmp> line 1␤  in any  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:56] <codesections> Or, simplified a bit: 

[17:56] <codesections> m: sub f { (1).map({CATCH { default { return 42 } }; die })}; say f  

[17:56] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block  at <tmp> line 1␤  in any  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[17:56] <codesections> how is that different? 

[17:56] *** NewGreyhawke left
[17:59] <guifa2> hmmm

[18:03] *** Xliff joined
[18:04] <Xliff> \o

[18:04] <guifa2> codesections: if you put it in a try block, it all works fine

[18:05] <guifa2> err no

[18:06] <codesections> This has *something* to do with the difference between Blocks and Routines. «Blocks that aren't of type Routine (which is a subclass of Block) are transparent to return»

[18:06] <codesections> I'm used to thinking of `map`, etc as Higher Order Functions that take fns as their arguments.  But in Raku they take Blocks

[18:07] <codesections> which (I think?) makes a subtle but key difference

[18:14] *** Altai-man_ joined
[18:16] *** sena_kun left
[18:20] <codesections> actually, maybe 100% of my confusion comes from `map` or other HoF and not from CATCH at all

[18:20] <guifa2> codesections:  here's a way to make it work: https://tio.run/##K0gtyjH7/7@4NEkhjatagYtTI85IUy83sUCDi5OzmksBDjg5QWo0VDQVQKqAwNkxxNkDyElJTUsszSkBsopSS0qL8hRMjBRqFWrBalIyU7k4gVprNVTiNYEiQFFNrlouLq7ixEqFtP//AQ

[18:20] <codesections> m: sub f { (1).map({return 42}) }; say f

[18:20] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block <unit> at <tmp> line 1␤␤»

[18:20] <guifa2> I'm sure what's going on is that map is obscuring the ability to return to locate the main sub

[18:21] <guifa2> But you can pass a sub into map, and violà, return function works (but it will do it once per map operation)

[18:23] <codesections> interesting – thanks!

[18:23] <codesections> that's exactly the behavior I would have expected (without needing the inner sub)

[18:25] <jdv79> which is exactly what the docs point to:)

[18:27] <codesections> jdv79: how do you mean/which docs?

[18:27] <jdv79> for some reason when i see pointy block i think sub but i guess semantics are different

[18:28] <jdv79> https://docs.raku.org/routine/map#(List)_routine_map

[18:28] *** melezhik joined
[18:34] <timotimo> yeah, pointy blocks aren't Routine, which is where returns happen

[18:35] *** ab5tract joined
[18:36] <ab5tract> I've written a new blog post that I thought some folks here might enjoy: https://5ab5traction5.bearblog.dev/for-love-of-the-underdog

[18:36] <codesections> timotimo: I get that.  But what don't get is why `return` from a pointy block inside a `map` inside a `sub` can't seem to find the sub it's in to return from

[18:36] <codesections> m: sub f { (1).map({return 47})}; say f 

[18:36] <camelia> rakudo-moar 3843a1e89: OUTPUT: «Attempt to return outside of immediately-enclosing Routine (i.e. `return` execution is outside the dynamic scope of the Routine where `return` was used)␤  in block <unit> at <tmp> line 1␤␤»

[18:37] <timotimo> is execution actually sill inside the sub, or was the lazy list returned from the sub already?

[18:37] <codesections> ..... ohhh

[18:37] <timotimo> that seems to be the case here

[18:37] <codesections> light bulb moment 

[18:37] <ab5tract> I only indirectly discuss Raku in this one because this post is about filling in the perspective that leads me to choose Raku as one of my "chosen few" programming languages.

[18:38] <codesections> sub f { eager (1).map({return 47})}; say f 

[18:38] <evalable6> codesections, rakudo-moar 3843a1e89: OUTPUT: «47␤»

[18:38] <codesections> It all suddenly makes sense!

[18:40] <guifa2> ab5tract++

[18:40] <guifa2> weekly: https://5ab5traction5.bearblog.dev/for-love-of-the-underdog

[18:40] <notable6> guifa2, Noted! (weekly)

[18:41] <ab5tract> thanks guifa2 :)

[18:42] <codesections> guifa2: so, with timotimo's insight, that means the code you posted to Tio could become

[18:42] <codesections> m: sub f { eager (^2).map({ CATCH { default { return 42 } }; die } ) }; say f 

[18:42] <camelia> rakudo-moar 3843a1e89: OUTPUT: «42␤»

[18:43] <timotimo> or your code could become

[18:43] <timotimo> m: say 42

[18:43] <camelia> rakudo-moar 3843a1e89: OUTPUT: «42␤»

[18:43] <guifa2> ;-)

[18:43] <timotimo> i'm not sure what exactly the code is trying to do :D

[18:43] <guifa2> codesections: I guess the questino is whether you want one single return or multiple

[18:43] <codesections> yeah.  And there are pretty good options for both :)

[18:47] <jdv79> fun stuff

[19:00] <timotimo> you can also "last" out of a map, can't you?

[19:05] <codesections> I would assume so.  Aren't for loops compiled down to maps?

[19:07] <CIAvash> m: say 1,2,3 ≡ 3,2,1

[19:07] <camelia> rakudo-moar 3843a1e89: OUTPUT: «12True21␤»

[19:07] <CIAvash> is that expected?

[19:08] *** melezhik left
[19:09] <lizmat> CIAvash: yes, because ≡ applies .Set semantics

[19:10] <lizmat> ah, you mean, why does it output 12...21 ?

[19:10] <lizmat> hmmm... maybe the precedence is off

[19:10] <lizmat> m: say 1,2,3 (==) 3,2,1

[19:10] <camelia> rakudo-moar 3843a1e89: OUTPUT: «12True21␤»

[19:10] <lizmat> m: say 1,2,3 (<=) 3,2,1

[19:10] <camelia> rakudo-moar 3843a1e89: OUTPUT: «12True21␤»

[19:10] <CIAvash> yeah

[19:11] <lizmat> well, if it's off, it's off for all set semantics operators

[19:11] <lizmat> m: say (1,2,3) (==) 3,2,1

[19:11] <camelia> rakudo-moar 3843a1e89: OUTPUT: «False21␤»

[19:11] <lizmat> m: say (1,2,3) (==) (3,2,1)

[19:11] <camelia> rakudo-moar 3843a1e89: OUTPUT: «True␤»

[19:19] *** kensanata joined
[19:20] *** Noisytoot left
[19:20] *** Noisytoot joined
[19:28] *** skids joined
[19:44] <timotimo> codesections: no, in some cases we generate a little while loop that repeatedly calls .pull-one on an iterator

[19:48] *** kensanata left
[19:51] <codesections> timotimo: interesting! So when the docs say «The :$label and :$item are useful only internally, since for loops get converted to maps.», I guess that's incorrect/incomplete?

[19:51] <codesections> https://docs.raku.org/type/Any#routine_map

[19:57] <codesections> ab5tract: Nice post :)  One way I like to look at that sort of question is by asking *why* something is popular, and then seeing how/if that reason applies to me

[19:57] <timotimo> they are only optimized to a while loop if there are no tricky things

[19:57] <timotimo> also not in a context where the foor loop would be lazy

[19:57] <codesections> so, for programming languages, many are popular because they are good fits for coding in large teams.  That might be a real advantage for some use cases, but not for mine

[19:58] <timotimo> optimizations happen only if 1) you cannot find out that we've cheated or 2) when we get caught, we can immediately fix stuff as if we never did anything

[19:58] <ab5tract> codesections: thanks!

[19:58] <codesections> timotimo: Interesting :D On a related question, is there any semantic difference between a `do for` loop and a `map`? 

[19:59] <timotimo> not sure, don't think so

[19:59] <codesections> cool

[19:59] *** xinming left
[20:00] *** xinming joined
[20:05] <ab5tract> codesections I like that line of questioning. Thanks for sharing :)

[20:05] <ab5tract> In other news, I've just broken ground on a project that will really, really benefit from the upcoming macro system: https://github.com/ab5tract/raku-SilverAPL/blob/master/lib/SilverAPL/Functions.pm6

[20:15] *** sena_kun joined
[20:16] <NickSeagull> ab5tract, any info on this macro system you talking about?

[20:17] *** Altai-man_ left
[20:17] <ab5tract> NickSeagull only what's been written up recently in the RakuAST proposal/reports

[20:18] <NickSeagull> Links to that? I'm new to Raku :)

[20:20] <ab5tract> https://jnthn.net/papers/2020-gpw-realizing-raku-macros.mp4 :)

[20:21] <ab5tract> proposal: https://news.perlfoundation.org/post/gp_rakuast

[20:21] <ab5tract> updates (starting from May): https://news.perlfoundation.org/list?category=Raku%20Development

[20:23] <NickSeagull> Thanks ab5tract :)

[20:24] *** wamba left
[20:26] <ab5tract> enjoy and welcome to raku!

[20:28] <NickSeagull> ^_^

[20:29] *** [particle] joined
[20:29] *** [particle] left
[20:31] <guifa2> NickSeagull: there's been a fair bit more too, jnthn++ gave a good talk/overview of it at CiC this year

[20:31] <NickSeagull> I'm watching it right now guifa2 

[20:31] <guifa2> https://www.youtube.com/watch?v=91uaaSyrKm0&t

[20:31] <guifa2> ah haha

[20:32] <NickSeagull> If we end up having macros, it'd be interesting to see how implementing a type system in it would work in Raku

[20:32] <NickSeagull> I mean this: http://www.ccs.neu.edu/home/stchang/pubs/ckg-popl2017.pdf

[20:34] <NickSeagull> The talk gives a lot of intersting ideas for sure

[20:41] <guifa2> It's going to be great for formatters — as soon as it's released I'll be updating a few of my modules and they should be muuuuch faster

[20:42] <NickSeagull> guifa2, are there any formatters for Raku? :o

[20:42] <NickSeagull> also, is there an estimated release date?

[20:46] <codesections> Johnathan's initial grant proposal had a timeline that ran through August: https://news.perlfoundation.org/post/gp_rakuast

[20:47] <codesections> (That same blog has a couple of updates since then.  I don't think they've said anything about the schedule, but they're interesting reading nonetheless)

[20:50] <guifa2> NickSeagull: you have sprintf built in

[20:50] <guifa2> I've been developing international formatters for, e.g., numbers and dates

[20:52] <codesections> Oh, I misunderstood what you meant – I thought you were talking about formatters in the sense of "code formatters" (like gofmt, rustfmt, prettier.js, etc)

[20:53] *** dolmen joined
[21:02] *** markong joined
[21:03] *** markoong left
[21:03] *** Kaeipi joined
[21:03] *** Kaiepi left
[21:05] <NickSeagull> No, I actually meant code formatters lol

[21:08] <codesections> :) Well, I don't *think* there are any – or even any pervasive style guides, for that matter.  Part of what I like about Raku is the There's-More-Than-One-Way-To-Do-It philosophy that recognizes that different problems call for different solutions (including differently formatted solutions!)

[21:08] <codesections> Just imo, anyway

[21:09] <sena_kun> Comma does code formatting with more or less rich config.

[21:10] <sena_kun> It's based on intellij API, though, and even considering this it was kind of a pain to implement. :)

[21:11] <codesections> Interesting – I didn't realize that.  Does it have a default ruleset online anywhere?  (I'd be interested in seeing what line lengths and such it defaults to)

[21:16] *** leont left
[21:19] *** rindolf left
[21:30] *** Xliff left
[21:30] *** dolmen left
[21:31] *** dolmen joined
[21:31] *** dolmen left
[21:34] <codesections> Raku may rightly pride itself on having fewer "WAT" moments than your typical language, but I will say it's the only language where I type `say .WHAT` with any regularity :D

[21:34] <ab5tract> jnthn are you expecting there to be any significant differences from a user-facing perspective between writing macros against `use experimental :macros` today vs post-RakuAST? (eg, is the experimental flag a result of a missing semantics, a missing syntax, or both?)

[21:35] <ab5tract> codesections hehehe

[21:35] <timotimo> jnthn's on vacation for two weeks :)

[21:36] <ab5tract> timotimo good to hear :D

[21:37] <ab5tract> I finally bought Comma PRo

[21:38] <ab5tract> *Pro

[21:38] <ab5tract> very glad I did

[21:38] <timotimo> nice

[21:39] *** Ven`` left
[21:39] <ab5tract> My brain is definitely taking a while to adjust to the idea of having the power of Raku amplified to the power of an IDE. I have spent so much time with dynamic languages that I never acclimated to the living standards of a modern IDE

[21:40] <ab5tract> Now that I've been placed over a steaming hot pile of Java at work, I've come to appreciate all these delightful trappings and am really excited to use them with a language that I actually enjoy using :)

[21:41] <codesections> What does it have that impressed/surprised you?  I'm not a big IDE fan, but I checked out the Community Edition just to see how the other half lived :D

[21:42] <ab5tract> codesections hard to specifically pin down the benefits of the IDE lifestyle without a whole lot of words

[21:42] <ab5tract> at this point I still haven't used a whole lot of Comma, but plenty of IntelliJ IDEA

[21:42] <thundergnat> Hey, Anybody around have the latest version of JSON::Fast installed that can test a potential bug for me to confirm it isn't just me?

[21:43] <codesections> yeah, sure

[21:43] <ab5tract> "of time" xx 2 

[21:43] <thundergnat> https://gist.github.com/thundergnat/69457d3c8fa9a92d01401ef05ec776e8  <-- Try running that and see if it fails.

[21:43] *** Petr37 joined
[21:43] <codesections> "Hard to pin down without a whole lot of words", yeah, I feel that way about both vim and emacs, so I know what that's like :)

[21:45] <NickSeagull> My issue with Comma is that it is unable to set the Raku SDK on Win10 :(

[21:45] <timotimo> did you try it with the version that was released just about a week ago?

[21:45] <ab5tract> codesections venerable text editors. I've decided to dedicate my limited brain space on that front to really learning `kakoune` . I know quite a bit of `vim` but I still do plenty of things wrong.

[21:45] <thundergnat> timotimo:  version 0.13? yes

[21:46] <NickSeagull> I tried it yesterday for the first time timotimo 

[21:46] <Petr37> good day/night. I need help with my problem. How i can catch redirect url when request any url? Many thanks

[21:46] <ab5tract> enough that I decided re-learning them the right way (buffers vs tabs for instance) is functionally more or less equivalent to learning a brand new editor

[21:47] <codesections> I get output of: «unexpected R in an object at 15» plus a backtrace

[21:47] *** mistersir joined
[21:47] <timotimo> sorry i meant comma

[21:47] <ab5tract> `kak` is so cool that it even comes with Clippy resurrected in ASCII form (and as an actually useful software helper too)

[21:47] <thundergnat> codesections: Yeah, that's what I'm seeing to. I'm pretty sure it's a bug in JSON::Fast

[21:48] <thundergnat> I'll file an issue. Thanks for confirming.

[21:49] <codesections> np

[21:49] <Petr37> can't find any solutions in Raku ..

[21:49] <timotimo> weird, i think to-json shouldn't have changed

[21:50] <timotimo> oh, hm

[21:50] <thundergnat> timotimo: It was working with previous version and many before that. Suddenly went sideways. I have to assume it was a problem in the latest version.

[21:50] <rypervenche> Petr37: You're using Cro?

[21:51] <timotimo> ok, str-escape seems to have changed

[21:51] <timotimo> er, no, that's also old

[21:51] <Petr37> rypervenche, no, i try WEW module

[21:51] <Petr37> WWW

[21:52] <thundergnat> timotimo: It only seems to be a problem escaping in hash keys, regular string seem to get escaped ok

[21:52] <timotimo> ok got the fix

[21:53] <thundergnat> Um. I was just about to file an issue, should I skip it if you are already on top of it?

[21:53] *** NickSeagull left
[21:53] <codesections> But then the PR won't have an issue to close :D

[21:54] <thundergnat> What the heck, it's already written.  https://github.com/timo/json_fast/issues/70

[21:55] <timotimo> uploaded to cpan

[21:59] <thundergnat> Woot! Installed 0.14, seems to be fixed.

[21:59] *** ab5tract left
[21:59] <timotimo> thank you for your contribution

[21:59] <timotimo> naturally i also added a test

[22:00] *** sjn joined
[22:00] <thundergnat> 18 minutes from first hmm. I think there may be a problem to publicly disseminated fix. Thanks!

[22:00] <timotimo> i hope you're also enjoying liz' rewritten json parser bit

[22:01] <codesections> wow, that's pretty amazing.  Reminds me of old stories about live-patching an production Lisp server while on a customer support call

[22:02] <codesections> "bug, what bug?  Try [reinstalling the package] and see if that fixes it" :D

[22:02] <rypervenche> Petr37: It looks to follow redirects, from what I can tell. Do you have an example where it's not working for you?

[22:02] <thundergnat> Um. Well not too much yet. It promptly fell over and corrupted my JSON files the first time I tried to use it. ;) But I'm sure it will grow on me! :D

[22:02] <Petr37> rypervenche, i cant find examples))

[22:04] *** Kaeipi left
[22:04] <rypervenche> Petr37: If you do something like this: use WWW; say get 'http://google.com';

[22:04] <rypervenche> It will redirect to 'http://www.google.com'.

[22:05] <Petr37> rypervenche, when i write get(url),i get redirect url in response.can i use cro for this?

[22:15] *** Altai-man_ joined
[22:16] *** sena_kun left
[22:20] *** yuplushi left
[22:24] <rypervenche> Petr37: What are you trying to ultimately do?

[22:26] <Petr37> rypervenche, i try extract redirect uri from response.

[22:31] *** Black_Ribbon joined
[22:33] *** Kaiepi joined
[22:33] <rypervenche> Petr37: Ah yeah, WWW doesn't look like it can do that. It's a very simple module. It only has a few subroutines: https://github.com/raku-community-modules/perl6-WWW/blob/master/lib/WWW.pm6

[22:34] <Petr37> rypervenche, may be cro can do that?

[22:38] <rypervenche> Someone else may be able to chime in here, but I think you could do it with HTTP::UserAgent, which is what WWW uses on the backend.

[22:38] <rypervenche> You might need to write the logic in there.

[22:48] <Petr37> rypervenche, thanks. i try

[22:48] <rypervenche> Looks like HTTP::UserAgent also does the redirect without telling you. Hmmm... Maybe someone else will have some ideas.

[23:13] *** pecastro left
[23:13] *** eseyman left
[23:18] *** Petr37 left
[23:21] *** eseyman joined
[23:38] *** markong left
[23:38] *** MilkmanDan left
[23:39] *** Petr37 joined
[23:39] *** MilkmanDan joined
