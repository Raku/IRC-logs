[00:03] *** xinming_ left
[00:05] *** xinming_ joined
[00:11] *** devmikey left
[00:12] <cpan-raku> New module released to CPAN! Data::Record (0.0.3) by 03KAIEPI

[00:45] *** xinming_ left
[00:48] *** xinming_ joined
[01:01] *** Doc_Holliwould left
[01:15] *** xinming_ left
[01:17] *** xinming_ joined
[01:41] *** molaf left
[01:54] *** molaf joined
[02:01] *** Manifest0 left
[02:02] *** Manifest0 joined
[02:07] *** xinming_ left
[02:27] *** xinming joined
[02:45] *** xinming left
[02:45] <cpan-raku> New module released to CPAN! Data::Record (0.0.4) by 03KAIEPI

[02:47] *** xinming joined
[02:51] *** hungrydonkey joined
[03:12] *** aborazmeh joined
[03:12] *** aborazmeh left
[03:12] *** aborazmeh joined
[03:24] <cpan-raku> New module released to CPAN! Data::Record (0.0.5) by 03KAIEPI

[03:24] <Kaiepi> ok done spamming releases now lol

[03:47] *** aborazmeh left
[04:02] *** xinming left
[04:03] *** xinming joined
[04:07] <Geth> ¦ doc: 7e6082b87e | Coke++ | doc/Language/modules.pod6

[04:07] <Geth> ¦ doc: remove doubled .

[04:07] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/7e6082b87e

[04:07] <Geth> ¦ doc: 6d5adefaad | Coke++ | xt/words.pws

[04:07] <Geth> ¦ doc: learn new words

[04:07] <Geth> ¦ doc: review: https://github.com/Raku/doc/commit/6d5adefaad

[04:07] <linkable6> Link: https://docs.raku.org/language/modules

[04:10] *** cpan-raku left
[04:10] *** cpan-raku joined
[04:10] *** cpan-raku left
[04:10] *** cpan-raku joined
[04:12] *** pilne left
[04:13] *** molaf left
[04:26] *** xinming left
[04:26] *** wamba joined
[04:26] *** xinming joined
[04:36] *** Xliff joined
[04:53] *** Sgeo_ joined
[04:54] *** xelxebar left
[04:54] *** xelxebar joined
[04:56] *** Sgeo left
[05:12] *** xinming left
[05:14] *** xinming joined
[05:27] *** Doc_Holliwould joined
[05:51] *** hungryd36 joined
[05:55] *** hungrydonkey left
[06:00] *** hungrydonkey joined
[06:02] *** hungryd36 left
[06:17] *** stoned75 joined
[06:18] *** kensanata joined
[06:37] *** hungryd6 joined
[06:41] *** hungrydonkey left
[06:47] *** stoned75 left
[06:53] *** xinming left
[06:53] *** xinming joined
[06:58] *** rindolf joined
[07:05] <cpan-raku> New module released to CPAN! Data::Record (0.0.6) by 03KAIEPI

[07:06] *** upupbb-user2 joined
[07:34] *** sjm_uk joined
[07:36] *** xinming left
[07:36] *** pecastro joined
[07:38] *** xinming joined
[07:38] *** dakkar joined
[07:47] *** sjm_uk left
[07:50] *** hungryd6 left
[07:51] *** Actualeyes joined
[07:58] *** wamba left
[08:12] *** xinming left
[08:14] *** xinming joined
[08:17] *** leont joined
[08:26] *** sena_kun joined
[08:32] *** sena_kun left
[08:40] *** Doc_Holliwould left
[09:00] <Kaiepi> m: say (a => 1, b => 2, c => 3) Z| (a => 4, b => 5)

[09:00] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(any(a => 1, a => 4) any(b => 2, b => 5))␤»

[09:00] <Kaiepi> m: say (a => 1, b => 2, c => 3) <<|>> (a => 4, b => 5)

[09:00] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(a => any(1, 4) b => any(2, 5) Nil)␤»

[09:01] <Kaiepi> m: say (1,2,3) <<+>> (4,5)

[09:01] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(5 7 7)␤»

[09:01] <Kaiepi> m: say (a => 1, b => 2, c => 3) <<|<< (a => 4, b => 5)

[09:01] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(a => any(1, 4) b => any(2, 5))␤»

[09:01] <Kaiepi> m: say (a => 1, b => 2, c => 3) >>|>> (a => 4, b => 5)

[09:01] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(a => any(1, 4) b => any(2, 5) Nil)␤»

[09:02] <Kaiepi> is there already a way i can generate (a => any(1, 4), b => any(2, 5), c => 3) from these?

[09:23] *** xinming left
[09:23] *** xinming joined
[09:25] *** daxim left
[09:31] *** daxim joined
[09:41] *** cpan-raku left
[09:42] *** cpan-raku joined
[09:42] *** cpan-raku left
[09:42] *** cpan-raku joined
[09:52] *** xinming left
[09:53] *** xinming joined
[09:53] *** Kaiepi left
[09:57] *** Kaiepi joined
[09:59] *** chloekek joined
[10:13] *** helit left
[10:16] *** helit joined
[10:18] *** helit left
[10:19] *** helit joined
[10:20] *** helit is now known as helix7

[10:24] *** wamba joined
[10:25] *** helix7 is now known as clem16

[10:27] *** clem16 is now known as helit

[10:29] *** helit is now known as clem16

[10:29] *** clem16 is now known as clem_15

[10:31] *** clem_15 is now known as helix7

[10:36] *** helix7 is now known as wfh

[10:39] *** LTM joined
[10:40] *** LTM left
[10:41] *** wfh is now known as helit

[10:42] *** xinming left
[10:42] *** xinming joined
[10:51] *** hungrydonkey joined
[10:55] *** helit is now known as helix7

[10:55] *** helix7 is now known as clem16

[10:56] *** clem16 is now known as helit

[10:57] *** helit is now known as clem16

[10:58] *** clem16 is now known as helit

[11:01] *** natrys joined
[11:14] *** helit is now known as clem16

[11:14] *** clem16 is now known as helit

[11:15] *** kensanata left
[11:17] *** helit is now known as revor

[11:18] *** revor is now known as helit

[11:21] *** kensanata joined
[11:22] *** helit is now known as clem16

[11:22] *** clem16 is now known as helit

[11:23] *** helit is now known as helix7

[11:23] *** helix7 is now known as helit

[11:24] *** helit is now known as clem16

[11:26] *** thundergnat joined
[11:26] <thundergnat> Kaiepi: not easily in a single operation (that I can think of) Could do something like

[11:26] <thundergnat> m: say ({}.append: |(a => 1, b => 2, c => 3), |(a => 4, b => 5)).map: { .key => any(|.value) }

[11:26] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(b => any(2, 5) a => any(1, 4) c => any(3))␤»

[11:27] <chloekek> Set up CI for a bunch of Raku community modules using Nix and GitHub Actions. ☺

[11:27] *** clem16 left
[11:28] *** thundergnat left
[11:30] *** xinming left
[11:31] *** aborazmeh joined
[11:31] *** aborazmeh left
[11:31] *** aborazmeh joined
[11:32] *** leont left
[11:32] *** xinming joined
[11:45] *** leont joined
[11:46] *** upupbb-user2 left
[11:48] *** kensanata left
[12:27] *** aborazmeh left
[12:33] *** mensvaga joined
[12:41] <chloekek> TIL you can put next in map to skip it.

[12:41] <chloekek> p6: say (1, 2, 3).map({ $_ %% 2 ?? next() !! $_ })

[12:41] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(1 3)␤»

[12:41] <chloekek> p6: say (1, 2, 3).map({ $_ %% 2 ?? Empty !! $_ })

[12:41] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(1 3)␤»

[12:42] <chloekek> p6: say (1, 2, 3).map({ $_ %% 2 ?? last() !! $_ })

[12:42] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(1)␤»

[12:45] <lizmat> m: sub foo { last }; for ^100 { .say; foo }

[12:45] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «0␤»

[12:45] <lizmat> next/last/redo are dynamic, not lexical

[12:46] <chloekek> Yep.

[12:48] <chloekek> p6: sub f($l, @xs) { @xs.map({ $_ == 3 ?? last($l) !! 0 }) }; l: for ^10 { say f(l, ^$_) }

[12:48] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «()␤(0)␤(0 0)␤(0 0 0)␤»

[13:03] *** sena_kun joined
[13:05] *** rba[m] left
[13:06] *** sena_kun left
[13:06] *** sena_kun joined
[13:06] *** xinming left
[13:08] *** xinming joined
[13:13] *** kst` joined
[13:14] *** Grauwolf_ joined
[13:14] *** Some-body_ joined
[13:15] *** timeless left
[13:15] *** Grauwolf left
[13:15] *** oodani left
[13:15] *** leah2 left
[13:16] *** timeless_ joined
[13:16] *** oodani_ joined
[13:16] *** ssm joined
[13:17] *** hungrydonkey left
[13:18] *** DarthGandalf left
[13:18] *** Some-body_ is now known as DarthGandalf

[13:18] *** timeless_ is now known as timeless

[13:19] *** timeless left
[13:19] *** timeless joined
[13:19] *** leah2 joined
[13:19] *** rbt left
[13:20] *** uzl[m] joined
[13:20] *** rbt joined
[13:20] *** BlackChaosNL[m] joined
[13:22] *** unclechu joined
[13:23] *** hungrydonkey joined
[13:33] *** molaf joined
[13:37] *** AlexDaniel left
[13:37] <Altreus> That seems like a great way to have bugs

[13:38] <Altreus> If other code is anything to go by, putting secret nexts in a function will seem like a good idea to a lot of people

[13:38] <Altreus> And then you'll call it from outside of a nextable construct and get an error you have *no idea* how to work around

[13:39] <Altreus> Personally I would have made those things lexical

[13:40] *** Sgeo_ left
[13:40] *** Sgeo_ joined
[13:43] <lizmat> as always, there are tradeoffs

[13:44] <lizmat> fwiw, I think Raku inherited that behaviour from Perl

[13:44] <vrurg> Altreus: OTOH, I use a construct `$.for_children: { next unless .ready; #`{ do something with ready children } }` – for lock-protected iteration.

[13:44] <lizmat> the code of ... in the setting uses this feature extensively

[13:44] <chloekek> Altreus: Just don’t write or call bad code. ;)

[13:46] *** xinming left
[13:49] *** xinming joined
[14:00] <chloekek> What is wrong when moar --version prints “This is MoarVM version  built with JIT support” without a version number?

[14:00] <chloekek> Ah, git was not available during configure.

[14:05] *** Xliff left
[14:09] *** statisfiable6 joined
[14:10] *** shareable6 joined
[14:10] <Altreus> chloekek: I shant

[14:11] *** notable6 joined
[14:13] *** Altai-man_ joined
[14:16] *** sena_kun left
[14:27] <Altreus> can zef install a specific branch from github?

[14:27] <Altreus> not important, just QOL

[14:28] <Altai-man_> Altreus, if you clone and do `zef install .`...

[14:29] <Altreus> yeah :)

[14:29] <Altreus> I cloned and used raku -I

[14:29] <Altreus> Just wondered if it had the feature

[14:29] *** dakkar left
[14:30] *** dakkar joined
[14:30] <Altai-man_> Altreus, I think zef is rather agnostic to a lot of things like ecosystems, fetching protocols and so on, so probably writing a zef plugin could do.

[14:35] <Kaiepi> i think being able to call `next` from a routine called from a loop is useful, just not very often a good idea

[14:36] <Kaiepi> earlier i had a pretty big block of code that was repeated in a loop, but the logic didn't allow for it to only be in the loop once, so i wrote it out into a routine

[14:43] *** perlmaros joined
[14:44] *** Doc_Holliwould joined
[14:46] *** chloekek left
[14:48] <[Coke]> you could do something like next if long-routine and have it return a boolean.

[14:53] *** xinming left
[14:54] *** xinming joined
[15:04] <Altreus> well that was my thought

[15:05] <Altreus> The function itself could return information about what to do, but the loop is the only thing that can actually be nexted

[15:05] <Altreus> Which means you could end up writing a long routine you can't use outside of a loop, which seems silly to me

[15:05] <Altreus> You might as well return a boolean or something, and then you can do anything with it

[15:05] <Altreus> Coupling a function to a loop seems daft

[15:06] <Altreus> mind you, I don't know what the use-cases are, so I'm ready to be convinced

[15:06] <Altreus> Just enough rope to hang yourself, right?

[15:06] <lizmat> it's the module that ... currently uses

[15:06] <lizmat> basically figure out a lambda that will produce the next value, and have it do a "last" if it is supposed to be done

[15:06] <Altreus> The operator that makes a "virtual function"?

[15:07] <Altreus> oh

[15:07] <Altreus> the generator

[15:07] <lizmat> m: dd 1,2,4 ... 100

[15:07] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «(1, 2, 4, 8, 16, 32, 64).Seq␤»

[15:07] *** jargan joined
[15:07] *** jargan is now known as jast

[15:07] <Altreus> Why not a Last object

[15:07] <Altreus> A terminator

[15:07] <Altreus> Seems very similar to Failures to me

[15:07] <lizmat> you should ask TimToady  :-)

[15:07] *** Alchemy joined
[15:08] <lizmat> this is ~ 10 year old code now, am currently refactoring it to use iterators

[15:08] <Altreus> It seems ideal to have a value whose semantics mean "end of whatever it was"

[15:08] <lizmat> and making it 4x to 15x as fast (preliminary benchmarks)

[15:08] <lizmat> Altreus: that would be IteratioEnd   :-)

[15:09] *** tobs joined
[15:09] <Altreus> I have the answer!

[15:09] <lizmat> which comes with its own set of issues:

[15:09] *** xelxebar_ joined
[15:09] <Altreus> What if you put an IterationEnd in a list

[15:09] *** sergot left
[15:09] *** linkable6 left
[15:09] <lizmat> m: my @a = 1,2,3,IterationEnd,5,6;  dd @a

[15:09] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «Array @a = [1, 2, 3, IterationEnd, 5, 6]␤»

[15:09] *** xelxebar left
[15:09] <lizmat> m: my @a = 1,2,3,IterationEnd,5,6;  .say for @a

[15:09] <camelia> rakudo-moar 2f8538ed0: OUTPUT: «1␤2␤3␤»

[15:09] <Altreus> That seems like a more sensible "don't do that" than calling a function with a last in it

[15:09] *** reportable6 left
[15:09] *** daemon left
[15:09] *** Alchemy is now known as daemon

[15:10] *** shareable6 left
[15:10] <Altreus> If you're allowed to say "Don't do that" then put it there

[15:10] <lizmat> putting IterationEnd in a list is a case of DIHWIDT

[15:10] *** notable6 left
[15:10] *** statisfiable6 left
[15:10] <Altreus> that's a new initialism on me

[15:10] *** literal joined
[15:10] *** Bucciarati joined
[15:11] *** APic joined
[15:11] <Altreus> I suppose it could show up in a variable

[15:11] <Altreus> But that's exactly as dangerous as last showing up in a function

[15:11] *** rypervenche left
[15:11] *** masak joined
[15:11] <Altreus> I guess the "don't do that" is putting last in a function unless you *really* have to

[15:13] *** NODE left
[15:13] *** masak is now known as Guest54471

[15:14] *** NODE joined
[15:14] *** AlexDaniel`1 joined
[15:19] *** xinming left
[15:20] *** xinming joined
[15:23] *** rindolf left
[15:29] *** chloekek joined
[15:32] *** perlmaros left
[15:33] *** hahainternet joined
[15:38] *** justout joined
[15:40] *** thundergnat joined
[15:42] <thundergnat> Altreus: there are certain instances where I find being able to have a next or last in a map statement is quite useful. http://rosettacode.org/wiki/Magnanimous_numbers#Raku for instance. 

[15:42] *** Tirifto joined
[15:43] <Altreus> but a map is nextable - although knowing that and including it in the rules for next is probably a lot harder than just allowing dynamic nexts

[15:43] <thundergnat> Could it be written differently? for sure, but that fits the way I think 

[15:44] <thundergnat> I may be misunderstanding your point...

[15:44] *** molaf left
[15:44] *** NODE left
[15:45] *** thundergnat left
[15:45] *** awwaiid joined
[15:45] *** tbrowder joined
[15:45] *** matiaslina joined
[15:46] *** NODE joined
[15:46] <jdv79> how come just "accessing" a promise seems to kick it off?

[15:48] *** unclechu left
[15:48] *** awwaiid left
[15:48] *** matiaslina left
[15:48] *** BlackChaosNL[m] left
[15:48] *** uzl[m] left
[15:49] *** AlexDaniel`1 left
[15:49] *** benkolera left
[15:50] <jnthn> jdv79: A Promise has no concept of being "kicked off"; typically by the time you have it, whatever's behind it is already scheduled or underway.

[15:51] <jdv79> i'm trying to golf it atm but i had some promises in a datastructure and when i pulled them out they ran.  i map'd 2 times and they ran 2 times.  it seemed odd.

[15:51] <jdv79> maybe i did something dumb

[15:52] *** hungrydonkey left
[15:54] *** ilbelkyr joined
[15:55] *** linkable6 joined
[15:56] *** rypervenche joined
[15:56] *** markoong joined
[15:59] *** albongo joined
[16:06] *** sourceable6 joined
[16:06] *** sergot joined
[16:06] *** greppable6 joined
[16:06] *** bisectable6 joined
[16:06] *** squashable6 joined
[16:07] *** benchable6 joined
[16:07] *** unicodable6 joined
[16:07] *** bloatable6 joined
[16:07] *** statisfiable6 joined
[16:07] *** notable6 joined
[16:08] *** committable6 joined
[16:08] *** Altai-man_ left
[16:08] *** releasable6 joined
[16:08] *** tellable6 joined
[16:08] *** reportable6 joined
[16:08] *** nativecallable6 joined
[16:08] *** sena_kun joined
[16:08] *** shareable6 joined
[16:09] *** quotable6 joined
[16:13] *** Grauwolf_ is now known as Grauwolf

[16:13] *** hungrydonkey joined
[16:14] *** upupbb-user3 joined
[16:31] *** regreg joined
[16:31] *** mowcat joined
[16:38] <Altreus> jnthn: this GPW talk is very helpful!

[16:38] <Altreus> jnthn++

[16:39] *** kybr left
[16:40] *** dakkar left
[16:42] *** wbn joined
[16:43] *** sergot left
[16:43] *** sergot joined
[16:45] *** vike1 left
[16:46] *** benkolera joined
[16:50] *** stoned75 joined
[16:51] *** kybr joined
[16:54] *** vike1 joined
[16:56] *** xinming left
[16:58] *** xinming joined
[17:00] *** vike1 left
[17:11] *** rindolf joined
[17:12] <Altreus> in fact I think I know what to do

[17:12] <Altreus> just from this talk :)

[17:13] <[Coke]> Nice.

[17:17] *** sjm_uk joined
[17:19] *** AlexDaniel` joined
[17:19] *** matiaslina joined
[17:19] *** BlackChaosNL[m] joined
[17:19] *** awwaiid joined
[17:19] *** unclechu joined
[17:19] *** uzl[m] joined
[17:24] *** cognominal left
[17:27] <jdv79> what talk was this?

[17:31] <chloekek> Is there a fast way to find the index of a byte in a Blob, a la memchr?

[17:38] *** ryn1x joined
[17:38] <ryn1x> p6: try { start { die "died in thread" }; sleep 1; CATCH { say "reporting error"; exit 0; } }

[17:38] <camelia> rakudo-moar 478239e61: OUTPUT: «Unhandled exception in code scheduled on thread 4␤died in thread␤  in block  at <tmp> line 1␤␤»

[17:39] <ryn1x> how can I bubble up an error from another thread?

[17:39] <ryn1x> is that even possible?

[17:42] *** upupbb-user3 left
[17:43] <lizmat> ryn1x: if the error is not caught, the job will finish ?

[17:45] <ryn1x> the job on the thread will not finish, but the main program calling it can continue...

[17:45] <ryn1x> i can give the user a friendly error message to report and an option to return to the main menu

[17:48] <ryn1x> the exit 0 in the example would happen only if the user chose to quit instead of return to the main menu in reality

[17:50] *** girafe left
[17:51] *** girafe2 joined
[17:54] <ryn1x> the example is very over simplified... i am actually launching other executables... not just using start blocks... but the behavior and errors are the same

[17:54] <[Coke]> you can wrap the threads in a catch so they don't die, and then the main thread can check status and keep going.

[17:55] <lizmat> or just "try start { }"  :-)

[17:57] <ryn1x> p6: try { try start { die "died in thread" }; sleep 1; CATCH { say "reporting error"; exit 0; } }

[17:57] <camelia> rakudo-moar 478239e61: OUTPUT: «Unhandled exception in code scheduled on thread 4␤died in thread␤  in block  at <tmp> line 1␤␤»

[18:04] *** hungrydonkey left
[18:05] <ryn1x> p6: try start { die "died in thread"; CATCH { say "reporting error"; exit 0;} }

[18:05] <camelia> rakudo-moar 478239e61: OUTPUT: «reporting error␤»

[18:05] <ryn1x> i guess that could work, but I have to do it everywhere a new thread it launched instead of around all of them

[18:06] *** Altai-man_ joined
[18:07] <ryn1x> p6: try start { die "died in thread"; CATCH { say "reporting error"} }; say "hi from main thread"

[18:07] <camelia> rakudo-moar 478239e61: OUTPUT: «reporting error␤hi from main thread␤»

[18:08] *** sena_kun left
[18:26] *** vike1 joined
[18:34] *** regreg left
[18:45] <chloekek> When I see Raku libraries from NASA all I can think of is $rocket-fuel ⚛️-= 1;

[18:47] <lizmat> And another Rakudo Weekly News hits the Net: https://rakudoweekly.blog/2020/03/30/2020-13-noconf-reached/

[18:47] <chloekek> lizmat⚛️++

[18:47] <lizmat> .oO( I feel radiant :-)

[18:49] <chloekek> We need something to use the ☣ character with

[18:49] <lizmat> m: dd "☣".uninames

[18:49] <camelia> rakudo-moar 478239e61: OUTPUT: «("BIOHAZARD SIGN",).Seq␤»

[18:49] <lizmat> hehe

[19:03] <synthmeat> thanks, lizmat, i love these

[19:08] *** lichtkind joined
[19:09] <lichtkind> which celebration if 6.e named after?

[19:13] *** someuser left
[19:18] <chloekek> The obvious one would be Easter, but I am not certain.

[19:23] *** genevino joined
[19:23] <genevino> oh wow, there's a blue butterfly in the topic

[19:24] <chloekek> It used to be »ö« but then it matured. :)

[19:26] <genevino> it probably matured in exactly the moment when the caterpillar thought life is over

[19:27] <genevino> 8)

[19:27] *** sjm_uk left
[19:29] *** ryn1x left
[20:02] *** xinming left
[20:02] *** xinming joined
[20:07] *** sena_kun joined
[20:07] *** molaf joined
[20:08] *** Altai-man_ left
[20:09] <stoned75> commit: releases say Bag.new-from-pairs: 'butter' => 0.22, 'sugar' => 0.1, 'sugar' => 0.02;

[20:10] <committable6> stoned75, https://gist.github.com/c682ee687457093839033339b44b05fb

[20:10] <stoned75> commit: releases say Mix.new-from-pairs: 'butter' => 0.22, 'sugar' => 0.1, 'sugar' => 0.02;

[20:11] <committable6> stoned75, https://gist.github.com/31556863c7c99143810e1092168f6906

[20:16] *** pilne joined
[20:22] *** leont left
[20:43] *** bdju left
[20:44] *** bdju joined
[20:44] <Altreus> jdv79: https://www.youtube.com/watch?v=GdU5XUck8OA&list=UUPl0v0Gg-kaHYLzRsaDtEDw&index=24&t=7s

[20:45] <Altreus> GPW 2019

[20:45] <Altreus> on react, supply, whenever

[20:52] <Altreus> jnthn: If you have a moment could you tell me if this looks reasonable? https://github.com/shuppet/p6-api-discord/blob/bug/35-reconnect-issue/lib/API/Discord/Connection.pm6#L180-L213

[20:53] <Altreus> maybe if I could spell discord

[20:57] <jdv79> Altreus: oh i thought jnthn's missing talk from this year was up.  saw the concurrency one already.  thanks.

[21:02] <Doc_Holliwould> Stackoverflow is down. We will all die

[21:03] <Altreus> These sentences seem unrelated, but both true

[21:05] *** NODE left
[21:07] * chloekek barely ever visits Stack Overflow.

[21:07] *** NODE joined
[21:07] *** erdic left
[21:08] *** erdic joined
[21:08] <jdv79> i end up there via googling a lot - that's about it

[21:09] <chloekek> I find that Google got worse over the years when it comes to providing accurate and complete solutions to programming problems.

[21:10] <Altreus> that's probably because people got worse at it

[21:10] <chloekek> For PostgreSQL I stopped using it altogether and bookmarked the index of the documentation.

[21:10] <Altreus> eh it is bothersome that it indexes a random version of each document page

[21:10] <chloekek> Now I get accurate and complete results for the latest versions, instead of incomplete or wrong SO answers and blog posts, or links to docs of older versions.

[21:10] <Altreus> rather than e.g. /latest/

[21:11] <Grinnz> stack overflow is a pretty decent way to provide google results that smarter people can fix later

[21:11] <Grinnz> whether they do that, is another matter

[21:13] <chloekek> It’s sometimes useful when documentation for something is missing or impenetrably confusing.

[21:14] <jdv79> i find many useful solutions on so on a regular basis - idk

[21:14] <Altreus> like postgres? :D

[21:14] <Altreus> low blow, PG has decent docs most of the time

[21:15] <jdv79> some of the pg docs are a bit difficult to read sometimes

[21:16] <chloekek> Just had an epiphany, I always wondered what I should call my variable for a string with JSON in it, and an object that is parsed JSON (in contrast with a validated and more specific data structure), can’t call both $json

[21:16] <chloekek> So I came up with $raw for the string passed to from-json, and $rare for the value returned by from-json ☺

[21:17] <jdv79> i don't get rare

[21:17] <chloekek> It’s less raw than raw, but not quite cooked

[21:18] <Altreus> sounds cooked to me

[21:18] <chloekek> my $raw = '{ "foo": "123" }'; my $rare = from-json($raw); my $cooked = Foo.new(bar => +$rare<foo>);

[21:18] <jdv79> hopefully there are better names in situ for both but i guess if not

[21:19] <jdv79> would $well be something to do with a Factory/Repository/IOC/something else complex?

[21:19] <Altreus> put the raw statement in from-json and never have an unparsed variable at all :)

[21:20] <jdv79> that was my first thought - why have a name if you can get away without one

[21:22] <chloekek> The raw one is a parametr.

[21:22] *** mowcat left
[21:25] <Grinnz> I tend to reserve $json for the actual string of json, since once you've decoded it to a data structure, it's not actually anything to do with JSON anymore

[21:25] <Grinnz> JSON is a string format

[21:25] <Altreus> Also true!

[21:26] <Grinnz> (technically more than that if you're in javascript, but)

[21:26] *** rindolf left
[21:27] <Altreus> Except for the incompatibilities

[21:27] <chloekek> Is it possible to slip a hash slice into named arguments?

[21:27] <Altreus> I'm sure I've done |(%hash<...>:kv) before

[21:27] <Grinnz> Altreus: afaik all of the weird stuff is actually because that's how it works in regular javascript syntax

[21:27] <chloekek> p6: sub f(:$x, :$y) { say $x, $y; }; my %h = :x(1), :y(2), :z(3); f(|%h<x y>:p);

[21:27] <camelia> rakudo-moar 478239e61: OUTPUT: «Too many positionals passed; expected 0 arguments but got 2␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:28] <Altreus> what's :p now

[21:28] <Altreus> pairs

[21:28] <Altreus> Is that different from kv?

[21:28] <chloekek> %h<x y>:p returns a list of pairs, but I need a hash.

[21:28] <chloekek> p6: sub f(:$x, :$y) { say $x, $y; }; my %h = :x(1), :y(2), :z(3); f(|%(%h<x y>:p));

[21:28] <camelia> rakudo-moar 478239e61: OUTPUT: «12␤»

[21:28] <chloekek> Hmm that works.

[21:28] <Altreus> magique

[21:28] <chloekek> p6: sub f(:$x, :$y) { say $x, $y; }; my %h = :x(1), :y(2), :z(3); f(|%(%h<x y>));

[21:28] <camelia> rakudo-moar 478239e61: OUTPUT: «Unexpected named argument '1' passed␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:28] <chloekek> Kinda ugly.

[21:29] <Altreus> um

[21:29] <chloekek> Maybe I can define a :h adverb that returns a hash.

[21:29] <Altreus> p6: sub f(:$x, :$y) { say $x, $y; }; my %h = :x(1), :y(2), :z(3); f(|(%h<x y>:p));

[21:29] <camelia> rakudo-moar 478239e61: OUTPUT: «Too many positionals passed; expected 0 arguments but got 2␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:29] <Altreus> p6: sub f(:$x, :$y) { say $x, $y; }; my %h = :x(1), :y(2), :z(3); f(|(%h<x y>:kv));

[21:29] <camelia> rakudo-moar 478239e61: OUTPUT: «Too many positionals passed; expected 0 arguments but got 4␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:29] <Altreus> welp

[21:29] <Altreus> I guess I haven't done that before :)

[21:30] *** Black_Ribbon joined
[21:37] <jdv79> being only one char less - is it worth more syntax at that point?

[21:39] <jdv79> oh, i'm not looking - 3 less.  not bad.

[21:40] *** ZaheerIsRight joined
[21:41] <ZaheerIsRight> is perl 6 a good first language? 

[21:41] <Altreus> Can't be worse than PHP

[21:41] <chloekek> p6: sub f(:$x, :$y) { say $x, $y; }; my %h = :x(1), :y(2), :z(3); f(|%h);

[21:41] <camelia> rakudo-moar 478239e61: OUTPUT: «Unexpected named argument 'z' passed␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:42] <ZaheerIsRight> lol

[21:42] <Altreus> also it's raku now

[21:42] <Altreus> I think it's bedtime

[21:42] <ZaheerIsRight> sorry 

[21:43] <chloekek> ZaheerIsRight: It depends: why does the pupil want to learn programming?

[21:43] *** cpan-raku left
[21:43] *** cpan-raku joined
[21:43] *** cpan-raku left
[21:43] *** cpan-raku joined
[21:43] <ZaheerIsRight> just for fun 

[21:43] <Grinnz> mst: looks like some vhosts need updating ^

[21:44] <mst> eventually yes

[21:44] *** mensvaga left
[21:45] <chloekek> ZaheerIsRight: Plausible. I’ve had nothing but fun with Raku.

[21:49] *** ZaheerIsRight left
[21:52] <rbt> Is there anything for memory profiling? Specifically, memory taken by each Class (sum of objects for class) at a given point in time (when called)?

[21:52] *** NODE left
[21:54] <MasterDuke> rbt: look at the Telemetry class/snapper module (https://docs.raku.org/type/Telemetry), or the heap profiler (--profile-kind=heap)

[21:54] *** NODE joined
[21:54] <rbt> Thanks

[21:55] <MasterDuke> for the latter you'll need https://github.com/jnthn/p6-app-moarvm-heapanalyzer to process the resulting output file

[21:57] *** stoned75 left
[21:58] *** NODE left
[22:00] *** NODE joined
[22:01] <rbt> Anyone have commit access to DBIish? Getting this 1 liner pushed would be helpful: https://github.com/raku-community-modules/DBIish/pull/178

[22:06] *** Altai-man_ joined
[22:06] <lizmat> rbt: merged it

[22:07] <rbt> Thanks!

[22:07] *** cognominal joined
[22:08] *** sena_kun left
[22:18] <lichtkind> are parametric coles gone?

[22:18] *** natrys left
[22:23] <lizmat> lichtkind: you mean roles?  no

[22:23] <lizmat> m: dd Rat.^roles

[22:23] <camelia> rakudo-moar 478239e61: OUTPUT: «(Rational[Int,Int], Real, Numeric)␤»

[22:23] <lizmat> would be an example of the use of the parametrix role Rational in the rat class

[22:24] <lizmat> *Rat

[22:24] <lichtkind> lizmat: thanks i aked becasue i cant find them in docs

[22:24] <lichtkind> hugs

[22:24] * lizmat hugs back

[22:24] <lizmat> lichtkind: then maybe make a documentation issue  :-)

[22:25] *** wamba left
[22:29] <MasterDuke> https://docs.raku.org/language/objects#Parameterized_roles

[22:29] <lizmat> MasterDuke++

[22:29] <lizmat> sleep&

[22:36] <lichtkind> MasterDuke++ oh man its too late

[22:37] <lichtkind> yes 

[22:50] *** pecastro left
[23:23] <tbrowder>  can anyone give me a link to a good, detailed video or slide presento of using comma for debugging modules? thnx

[23:24] *** upupbb-user3 joined
[23:26] *** Altai-man_ left
[23:32] *** xelxebar_ left
[23:34] *** xelxebar joined
[23:35] *** AlexDaniel joined
[23:35] *** AlexDaniel left
[23:35] *** AlexDaniel joined
[23:36] *** lichtkind left
[23:44] *** lichtkind joined
[23:54] *** chloekek left
