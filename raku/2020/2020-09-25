[00:02] *** BenGoldberg left
[00:06] *** rir left
[00:27] *** wamba left
[00:46] <timotimo> oh, moon-child, you'll want to know that there's usually a point in the .bin file where there's a return instruction and afterwards is just values, not valid assembly

[00:46] *** leont left
[01:02] *** mowcat left
[01:07] *** sono__ joined
[01:07] <timotimo> wow, this is a whole load of mov

[01:08] <timotimo> 55 movs in a row

[01:10] *** Black_Ribbon left
[01:10] <timotimo> from one particular point the code just goes getspeshslot, sp_bind_o, const_i64_16, sp_p6obind_i, set, set, getspeshslot, set, set, set, set, getspeshslot, set, getspeshslot, set, set, set, set, getspeshslot, set, getspeshslot, set, set, return_o

[01:13] *** molaf left
[01:14] *** BenGoldberg joined
[01:23] *** ggoebel joined
[01:25] *** RaycatWhoDat joined
[01:25] *** molaf joined
[01:25] *** ggoebel_ joined
[01:27] <RaycatWhoDat> Hey, all. I'm trying to test out grammars by making a script to reformat some code and I'm running into a strange situation where grammars are hanging when I use the <ws> term.

[01:27] *** ggoebel left
[01:27] <guifa> (one thing that used to get me with <ws>: it matches the empty string, so it‚Äôs easy to catch yourself in an infinite loop)

[01:28] <RaycatWhoDat> wait what

[01:28] <RaycatWhoDat> I thought it was just whitespace characters. It also catches the empty string?

[01:28] <RaycatWhoDat> uh-oh

[01:33] <RaycatWhoDat> So, tried adding a quantifier and that didn't stop it from hanging

[01:34] <RaycatWhoDat> Is there a better way to say "ignore any whitespace in front of this" than <.ws>+ ?

[01:37] *** squashable6 left
[01:38] *** squashable6 joined
[01:56] <timotimo> The default ws matches zero or more whitespace characters, as long as that point is not within a word (in code form, that's regex ws { <!ww> \s* }):

[01:56] <timotimo> ^- stolen from the docs

[01:57] <RaycatWhoDat> Right, but then it hangs

[01:57] <timotimo> are you using "rule" or "token" perchance?

[01:57] <RaycatWhoDat> yeah, I'm using "token"

[01:57] <timotimo> that prevents backtracking

[01:57] <RaycatWhoDat> ohhh

[01:58] <RaycatWhoDat> Because space is only significant in rules

[01:58] <timotimo> when there's a ws followed by like \s+ that won't work in a token

[01:58] <RaycatWhoDat> Ah

[01:58] <RaycatWhoDat> Lemme try that

[01:58] <timotimo> since the ws will have taken the entirety of the whitespace, and there's no whitespace for the \s+ to match

[02:01] *** skyl4rk left
[02:23] *** AlexDani` joined
[02:27] *** AlexDaniel left
[02:44] *** AlexDani` is now known as AlexDaniel

[02:44] *** AlexDaniel left
[02:44] *** AlexDaniel joined
[02:49] *** dataangel joined
[02:51] *** vike joined
[03:01] *** skyl4rk joined
[03:14] *** BenGoldberg left
[03:25] *** Sgeo_ joined
[03:26] <RaycatWhoDat> Figured it out. Was way simpler than I originally thought

[03:26] <RaycatWhoDat> Smart-matching got me there and once I had the Match object, .replace-with was a godsend

[03:26] <RaycatWhoDat> This language is sweet

[03:28] *** Sgeo left
[03:56] *** Kaiepi left
[03:56] *** Kaiepi joined
[04:05] *** zacts joined
[04:05] *** Mawile joined
[04:06] *** Archenoth left
[04:17] *** RaycatWhoDat left
[04:19] *** aborazmeh_ joined
[04:19] *** aborazmeh_ left
[04:19] *** aborazmeh_ joined
[04:19] *** aborazmeh left
[04:19] *** aborazmeh_ is now known as aborazmeh

[04:29] *** Kaiepi left
[04:29] *** Kaiepi joined
[04:32] *** aborazmeh left
[04:35] *** aborazmeh joined
[04:35] *** aborazmeh left
[04:35] *** aborazmeh joined
[04:48] *** Kaiepi left
[04:48] *** Kaiepi joined
[04:52] *** BenGoldberg joined
[05:13] *** Kaeipi joined
[05:14] *** Kaiepi left
[05:16] *** molaf left
[05:20] *** andrzejku joined
[05:25] *** BenGoldberg left
[05:25] *** zacts left
[05:27] *** squashable6 left
[05:30] *** squashable6 joined
[05:34] *** bocaneri joined
[05:41] *** wamba joined
[05:45] *** andrzejku left
[06:10] *** skids left
[06:15] *** sono__ left
[06:26] *** aluaces left
[06:26] *** cpan-raku left
[06:28] *** cpan-raku joined
[06:28] *** cpan-raku left
[06:28] *** cpan-raku joined
[06:36] *** jmerelo joined
[06:43] *** domidumont joined
[06:55] *** MasterDuke joined
[07:04] *** aluaces joined
[07:12] *** raku-bridge left
[07:13] *** raku-bridge joined
[07:13] *** raku-bridge left
[07:13] *** raku-bridge joined
[07:16] *** pepl joined
[07:34] *** Altai-man joined
[08:17] *** BenGoldberg joined
[08:29] *** wamba left
[08:51] *** BenGoldberg left
[08:57] *** Sgeo_ left
[09:01] *** lizmat_ joined
[09:03] *** lizmat__ joined
[09:04] *** lizmat left
[09:04] *** lizmat___ joined
[09:07] *** lizmat_ left
[09:07] *** lizmat__ left
[09:08] *** lizmat___ is now known as lizmat

[09:10] *** wamba joined
[09:21] *** aborazmeh left
[09:21] *** aborazmeh joined
[09:21] *** aborazmeh left
[09:21] *** aborazmeh joined
[09:40] *** sena_kun joined
[09:42] *** Altai-man left
[10:21] *** Kaeipi left
[10:21] *** Merfont joined
[10:34] *** sftp left
[10:35] *** sftp joined
[10:39] *** dakkar joined
[10:40] <Geth> ¬¶ problem-solving: JJ assigned to jnthn Issue To what extent are resources part of the API of a distribution? https://github.com/Raku/problem-solving/issues/234

[10:41] *** leont joined
[10:52] *** frot-lab left
[11:30] *** wamba left
[11:31] *** wamba joined
[11:42] *** BenGoldberg joined
[12:03] *** zacts joined
[12:15] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2020/09/25/list-breaks-the-chain/

[12:16] *** BenGoldberg left
[12:18] <Geth> ¬¶ problem-solving: jnthn self-unassigned To what extent are resources part of the API of a distribution? https://github.com/Raku/problem-solving/issues/234

[12:29] *** jmerelo left
[12:36] *** mowcat joined
[12:47] *** ihb joined
[12:47] *** ihb left
[13:09] *** skids joined
[13:18] *** _jrjsmrtn joined
[13:19] *** __jrjsmrtn__ left
[13:30] *** molaf joined
[13:40] *** Altai-man joined
[13:43] *** sena_kun left
[13:43] *** lucasb joined
[14:02] *** sjn left
[14:09] *** kst left
[14:11] *** orinthe left
[14:11] *** orinthe joined
[14:19] *** zacts left
[14:42] *** Merfont left
[14:42] *** Kaiepi joined
[14:46] *** rindolf joined
[14:51] *** Kaeipi joined
[14:51] *** Kaiepi left
[14:58] *** MilkmanDan left
[14:59] *** MilkmanDan joined
[15:02] <Altreus> Is there a sensible way of having a non-existent hash entry be considered an empty list? map { ... } %hash<value><>

[15:06] <timotimo> you could make it depend on whether it exists by using "with"

[15:06] <timotimo> m: my %hash; .map({ .say }) with %hash<value><>

[15:06] <camelia> rakudo-moar 85847d2f1: ( no output )

[15:07] <timotimo> m: my %hash = value => [1, 2, 3]; .map({ .say }) with %hash<value><>

[15:07] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´1‚ê§2‚ê§3‚ê§¬ª

[15:07] <timotimo> oh but that'll not Do It for 0 or False or such

[15:07] <Altreus> isn't with for definedness?

[15:07] <Altreus> That's why I wanted wif

[15:07] <timotimo> ummm yes lol

[15:07] <Altreus> nice

[15:07] *** BenGoldberg joined
[15:07] <timotimo> it may be 1700 on the clock, but i'm not awake yet

[15:09] <lizmat> m: my %h is default(());  dd %h<a>

[15:09] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´List %h{'a'} = $( )‚ê§¬ª

[15:09] <lizmat> m: my %h is default(Empty);  dd %h<a>

[15:09] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Slip %h{'a'} = Empty‚ê§¬ª

[15:09] <Altreus> hash is being provided to me :)

[15:09] <Altreus> oh but the signature

[15:10] <Altreus> *%rest is default(()) ?

[15:10] *** AlexDani` joined
[15:11] <xinming> How do we do circular module loading please? Let's say, in file A.rakumod    class A { has B $.attr };     in file B.rakumod   class B { has A @.a }

[15:11] *** finsternis left
[15:12] *** AlexDaniel left
[15:12] <xinming> If they are in the same file, I can use     class A { ... }    to solve this, But what if these things must be in different .rakumod file pleae?

[15:13] <lizmat> Altreus: no, that won't work

[15:13] <xinming> hmm, Ignore me.

[15:13] <lizmat> I guess the "with" option is you're best bet then

[15:13] <xinming> https://docs.raku.org/language/faq#Can_I_have_circular_dependencies_between_modules?   <--- >_<

[15:19] *** jmerelo joined
[15:23] <Altreus> cool

[15:27] *** abraxxa left
[15:28] *** molaf left
[15:31] <lizmat> *your

[15:35] <Altreus> I already forgave you

[15:37] <lizmat> :-)

[15:37] <xinming> m: subset A of Str where <a b c>; sub t(A $x) { $x.say; }; t(A("a"))

[15:37] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Cannot invoke this object (REPR: Uninstantiable; A)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[15:38] <xinming> m: subset A of Str where <a b c>; sub t(A $x) { $x.say; }; t(my A $ = 'a')

[15:38] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Type check failed in assignment; expected A but got Str ("a")‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[15:38] <xinming> How do we coerce the "a" to subset A type in this case please?

[15:42] <timotimo> you cannot coerce to a subset type

[15:42] *** BenGoldberg left
[15:42] <timotimo> what you want is probably where any(<a b c>) instead

[15:42] <timotimo> m: subset A of Str where any(<a b c>); sub t(A $x) { $x.say; }; t('a')

[15:42] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´a‚ê§¬ª

[15:43] <xinming> Ok, got it, yea, I do mean any(<a b c>)

[15:44] <timotimo> when you assign to my A $ = "a", you will only get a check

[15:48] *** MilkmanDan left
[15:49] *** MilkmanDan joined
[15:58] <guifa> xinming: you can also use ::(‚Äúfoo‚Äù) if I remember correctly, because that‚Äôs evaluated at runtime

[15:58] <Altreus> I was just thinking about the magic of junctions

[15:58] <Altreus> earlier today

[15:58] <Altreus> I wish every language had them

[16:00] <guifa> Altreus: right?  they become so natural and the reality is the work arounds for them aren‚Äôt always very pretty

[16:03] <Altreus> One of my first mistakes in P5 back in 2008 was doing if x == (a or b)

[16:04] <Altreus> I was clearly a visionary but too green to achieve it

[16:04] <guifa> xinming: actually, small correction.  Instead of just ::(‚ÄúFoo‚Äù), use CHECK ::(‚ÄúFoo‚Äù), so that it it‚Äôs guaranteed to happen at runtime and not compile time

[16:05] <guifa> I knew I had used it before and even left it in the comments: https://github.com/alabamenhu/LanguageTag/blob/3e5f1d8ac078925df5ebf619ba96011f4ced9df5/lib/Intl/LanguageTag.pm6#L301

[16:08] <codesections> m: say 'ab' ~~ /[a|(b) {say $0}] ** { print 'outer: '; say $0; 2}/ 

[16:08] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´outer: Nil‚ê§[ÔΩ¢bÔΩ£]‚ê§ÔΩ¢abÔΩ£‚ê§ 0 => ÔΩ¢bÔΩ£‚ê§¬ª

[16:09] <codesections> why is the outer expression ^^^ evaluated first (while $0 is still Nil)?

[16:13] <codesections> And, to avoid an XY problem, what would be a good way to do this with in a grammar: given a string of spaces and tabs, count each tab as four spaces and match 8 spaces?

[16:14] <guifa> The quantifier gets evaluated first

[16:15] <codesections> My first thought was to do something like /[\s|(\t)] ** {8 - (+$0 √ó 4)}/, but that doesn't work because the $0 match isn't available 

[16:16] <codesections> guifa: :) yeah, but isn't that just restating my question?  _Why_ does the quantifier get evaluated first?  Is that just a rule of precedence that I need to remember? 

[16:17] <guifa> My guess is the way that the other quantifiers were done they work on an assumption that the quantities are known in advance.  So the same logic was applied.  It‚Äôs been a while sinc eI was hunting around in that code though

[16:17] <guifa> I‚Äôm actually surprised that it evalutes multiple times.  I would have figured it evaluates once and is done

[16:17] *** Black_Ribbon joined
[16:17] <guifa> err actually I guess it does

[16:18] <codesections> yeah

[16:19] <guifa> I think you might be overthinking it though.    :$i = 0; [\s {$i++) |¬†\t {$i += 4}] { $i = formula }

[16:19] <guifa> err, <?{ $i == 8 }> or whatever

[16:27] <codesections> That's clever, but I don't think it _quite_ gets there:

[16:27] <codesections> m: my $i = 0; say "  \t    foo" ~~ /[' ' { $i++} | \t { $i += 4}]* <?{ $i == 8}> <(.*/;

[16:27] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Nil‚ê§¬ª

[16:27] <timotimo> i would really capture tabs and spaces in two named captures and count their matches and do the math  at the end

[16:28] <codesections> that has 10 spaces worth of whitespace, and thus doesn't match at all; it should have matched on the first 8 and then left '  foo' for the `.*`.

[16:28] <codesections> Oh, interesting idea, timotimo 

[16:31] <codesections> that has the downside of complicating the logic for extracting the item after the 8-space worth (e.g., in the above, I want to get '  foo' out, not just 'foo' or "  \t     foo"

[16:31] <codesections> )

[16:32] <codesections> I don't suppose there's any easy way to just replace the tabs with spaces in place, before matching against the string, is there?  There've been a few times where I've wondered if there's a way to modify the string-I'm-trying-to-match before checking for the next match, but I haven't seen one

[16:36] <guifa> codesections: you can use either of our methods (timotimo‚Äôs is more legible, mine should be mildly more performance for not creating extra match objects) but change things slightly like

[16:37] <guifa> [ [ <space> | <tab> ] <?{ count logic }> ]*

[16:40] *** wamba left
[16:41] <codesections> m:  my $i = 0; say "  \t    foo" ~~ /[[' ' { $i++} | \t { $i += 4}] <?{ $i == 8}>]  <(.*/;  

[16:41] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´ÔΩ¢  fooÔΩ£‚ê§¬ª

[16:42] * guifa is off to $day-job, have fun everyone!

[16:42] <codesections> guifa++ thanks.  This might be a very basic question, but how do I set $i inside a grammar's token/regex?  Is that what the `:$i =0` syntax you used aboeve was about? 

[16:43] <guifa> yeah, :$foo let‚Äôs you set a variable at in the regex‚Äôs scope

[16:43] <codesections> guifa++ 

[16:46] *** aluaces left
[16:48] *** wamba joined
[16:59] *** domidumont left
[17:02] *** aluaces joined
[17:04] *** Sgeo joined
[17:08] *** orinthe left
[17:08] *** orinthe joined
[17:25] *** aluaces left
[17:25] *** pamplemousse__ joined
[17:30] *** aluaces joined
[17:41] *** sena_kun joined
[17:42] *** sjn joined
[17:43] *** Altai-man left
[17:48] <AlexDani`> guifa: there isn't anything natural in passing junctions as objects, a lot of things break apart once you do, and I'm definitely not surprised that other languages don't do it. But being able to construct expressions without repeating yourself is indeed nice, so Raku just went a little bit overboard :)

[17:48] *** AlexDani` is now known as AlexDaniel

[17:48] *** AlexDaniel left
[17:48] *** AlexDaniel joined
[17:52] *** wamba left
[17:55] <AlexDaniel> as a user, you probably don't consider Junctions as something you'd get as an input, obviously nobody wants this mental load

[17:56] <AlexDaniel> and we all get away with it because most of the time people don't use junctions :)

[17:56] <AlexDaniel> m: say (5, any(1, 42), 6).min

[17:56] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´6‚ê§¬ª

[17:56] <AlexDaniel> m: say (5, any(1, 42), 6).max

[17:56] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´6‚ê§¬ª

[17:56] <AlexDaniel> hmm :)

[17:56] <timotimo> i mean, unless you type your parameters to take Mu, you won't actually get a junction in your user code

[17:57] <AlexDaniel> timotimo: ‚Ä¶ seriously?

[17:57] <AlexDaniel> timotimo: what about arrays?

[17:57] <timotimo> ah, i guess

[17:58] *** approaching236 left
[17:59] *** approaching236 joined
[17:59] <codesections> AlexDaniel: Out of curiosity, how should a user rewrite `say (5, any(1, 42), 6).max` to get 42? 

[17:59] <codesections> (I'm assuming that's what they want/expect)

[18:00] <AlexDaniel> codesections: it's just a snippet to reproduce interesting behavior, the user is unlikely to type something exactly like that, obviously

[18:00] <moritz> you should not use a junction unless you get a booleean answer

[18:00] <moritz> unless you *want

[18:01] <AlexDaniel> moritz: what does that mean?

[18:02] <moritz> AlexDaniel: if you try to use junctions for set arithmetic, instead of lists or so, you're working against the system

[18:02] <[Coke]> codesections: I think in general you don't get to intropsect the values of a junction, so I wouldn't expect to be able to get 42 there.

[18:02] <tellable6> 2020-09-25T06:36:58Z #raku-dev <jmerelo> [coke] it's a license for the repo itself. It's a markdown file, doesn't make a lot of sense to make it GPL.

[18:02] <[Coke]> if you want a set, use a Set.

[18:02] <moritz> junctions only help to make your code easier if in the end you want a True or a False as the result

[18:03] *** jmerelo left
[18:03] <AlexDaniel> [Coke]: so why is it printing 6 instead of 5 xD

[18:03] <AlexDaniel> [Coke]: point is, it could've returned a junction itself

[18:04] <AlexDaniel> moritz: that only works in simple cases. If I have a junction in an array and pass the array to a third-party sub, then I just couldn't know what it's going to do with it

[18:04] <[Coke]> m: say (any(1,42), 5, 6).min # the ordering here matters.

[18:04] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´5‚ê§¬ª

[18:05] <moritz> AlexDaniel: well, that's a general problem with violating expectations. If a sub expects a list of numbers, you better pass it a list of numbers

[18:05] <moritz> junctions aren't magical

[18:05] <[Coke]> m: say (5,6,any(1,42)).min # the ordering here matters.

[18:05] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´any(1, 42)‚ê§¬ª

[18:05] <moritz> they work well in just a few, simple cases

[18:05] <sjn> junctions aren't magical, they're "quantum" :-)

[18:05] <AlexDaniel> how about not violating an expectation that it shouldn't be possible to have multiple values in a spot for one

[18:06] <AlexDaniel> and yes, that's correct, they work in a few simple cases

[18:06] <moritz> that would be preferable indeed

[18:06] <AlexDaniel> which is why I say that it should've been a compile-time feature that simply expands expressions

[18:06] <moritz> but typing arrays is sadly also fraught with peril

[18:06] <AlexDaniel> that is, no junctions as objects

[18:07] <moritz> that wouldn't work in a case like @array.first: Int|Str

[18:08] <[Coke]> m: use nqp; say nqp::isconcrete( any(1,42) );

[18:08] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´1‚ê§¬ª

[18:08] <moritz> (not saying that's a deal killer, but something to be considered)

[18:08] <codesections> [Coke]: it's not _great_ to have order matter in functions named after mathematical operations that are well-known to be associative 

[18:08] <[Coke]> m: say any(1,42) cmp 5

[18:08] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´any(Less, More)‚ê§¬ª

[18:08] <codesections> s/associative/commutative  

[18:09] <[Coke]> m: say +(any(Less,More))

[18:09] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´any(-1, 1)‚ê§¬ª

[18:09] <AlexDaniel> moritz: it'd work with { $_ == 1 | 42 }, not sure about * == 1 | 42 but maybe a lone 1 | 42 could be made a shortcut for that

[18:09] <[Coke]> m: say so (any(Less,More))

[18:09] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´True‚ê§¬ª

[18:10] <[Coke]> m: say so (any(Less,More)) < 0

[18:10] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´True‚ê§¬ª

[18:11] <AlexDaniel> moritz: yeah actually I'm fairly certain that it'd work

[18:11] <AlexDaniel> but yes, there will be cases that won't, and that's ok

[18:11] <[Coke]> codesections: Seems like the solution is to complain when you find a junction in a list you're trying to the the min of.

[18:12] <[Coke]> or, label it DIHWIDT.

[18:12] <AlexDaniel> [Coke]: IIRC .sort already received special handling for Junctions. The ultimate solution, of course, is to rethink junctions instead‚Ä¶

[18:17] <lizmat> m: say (5, 7 | 42, 6).max

[18:17] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´any(7, 42)‚ê§¬ª

[18:17] <AlexDaniel> that looks about right

[18:17] <lizmat> well, if you think that that is correct, then:

[18:17] <lizmat> m: say (5, 1 | 42, 6).max

[18:17] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´6‚ê§¬ª

[18:17] <lizmat> is *also* correct

[18:17] <AlexDaniel> why

[18:17] <lizmat> the "1" in the junction is smaller than "6"

[18:18] <lizmat> so it compares larger than 5, so the junction becomes the targetr

[18:18] <AlexDaniel> hmm, what about .min ?

[18:18] <lizmat> and then when it compares to 6, the 1 is smaller, so 6 becomes the max

[18:19] <lizmat> m: say (5, 1 | 2, 6).min

[18:19] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´any(1, 2)‚ê§¬ª

[18:19] <lizmat> same thing

[18:19] <AlexDaniel> m: say (5, 1 | 2, 8).min

[18:19] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´any(1, 2)‚ê§¬ª

[18:19] <AlexDaniel> m: say (5, 1 | 10, 8).min

[18:19] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´8‚ê§¬ª

[18:19] <AlexDaniel> no, here

[18:19] <AlexDaniel> that's definitely not the smallest number?

[18:20] <lizmat> first compare is 5 cmp 1 | 10, the 1 is smaller, so the junction becomes the next target

[18:20] <lizmat> the second compare is 1 | 10 cmp 8

[18:20] <AlexDaniel> it doesn't matter in what sequence it breaks apart, it's not the right answer

[18:20] <codesections> lizmat: if I'm following that correctly, there's no difference between `any` and `all` in these functions and (semantically) it works to think of them both as `all` junctions?  

[18:21] <lizmat> codesections: it's the any that is causing the apparent confusion

[18:21] <lizmat> but yeah, doesn't matter in this case whether it is any or all

[18:22] <lizmat> m: dd 1 | 5 > 4

[18:22] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´any(Bool::False, Bool::True)‚ê§¬ª

[18:22] <codesections> yeah ‚Äì and the fact that it doesn't matter is what makes it confusing (at least in my head).  

[18:23] <lizmat> I agree it *is* confusing

[18:23] <lizmat> but it is procedurally correct afacs

[18:23] <lizmat> afaics

[18:23] <lizmat> m: dd 1 & 5 > 4

[18:23] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´all(Bool::False, Bool::True)‚ê§¬ª

[18:24] *** bocaneri left
[18:24] <codesections> yep, agreed.  I'm really glad the channel talks through things like this; it helps all the confusing bits click into place :)

[18:25] <lizmat> and there is no way to fix this, really, as you can Bool-ify a Junction, but there is no way to Order-ify a Junction

[18:25] <AlexDaniel> well, there is a way to fix it

[18:25] <lizmat> please, do tell

[18:26] <AlexDaniel> across the whole language in fact, not limited to min/max :)

[18:26] <lizmat> throw out the baby with the bath-water ?

[18:26] <AlexDaniel> I've told you several times, it's a design mistake, junctions should not exist as objects

[18:26] <lizmat> please note that *everything* in Raku is an object

[18:27] <lizmat> so effectively you're saying that junctions should be removed from the language

[18:27] <AlexDaniel> no, I'm saying it should be a compile-time syntactic feature

[18:28] <AlexDaniel> that is, `if $foo == 42 | 43` should work, `@a = 42 | 43` shouldn't

[18:28] <AlexDaniel> then all the edge cases go away

[18:29] <lizmat> so: if $foo == $a | $b would not work anymore

[18:29] <AlexDaniel> it will

[18:29] <lizmat> ah?  magically?

[18:29] <codesections> It _is_ interesting to think about hypothetical counterfactuals about how the language might have developed if we'd made different decisions in the past.  But it's also helpful to move on and think about how to best explain the language we have now

[18:29] <lizmat> bar( $a | $b ) ?

[18:30] <lizmat> codesections++

[18:30] <AlexDaniel> no magic, it'll expand it to `$foo == $a || $foo == $b`, very well defined

[18:30] <codesections> (for a definition of "we" that doesn't, you know, include me given when these decsions were made ‚Ä¶)

[18:31] <AlexDaniel> lizmat: calling functions is debatable, it can still do what it does now, maybe it shouldn't, I'm not 100% sure

[18:31] <AlexDaniel> I don't understand what is so hard and bad about outlining the mistakes, accepting them and perhaps thinking on how fix them

[18:32] <lizmat> you will first have to convince enough people that they are mistakes

[18:32] <AlexDaniel> yeah, that's a big problem currently

[18:32] <lizmat> no, it isn't

[18:32] <perigrin> that's also step 2 in your "what's so hard" list

[18:33] *** BenGoldberg joined
[18:33] <AlexDaniel> perigrin: ah yeah, good point :)

[18:33] <lizmat> most people love Junctions they way they are now, and never run into any issues or gotchas

[18:34] <lizmat> so, instead of just keeping on how Junctions should basically be removed from the language, choose another battle to fight, please

[18:34] <codesections> AlexDaniel: In my view, there are two different questions for anything like this: 1) was it a mistake, at the time the decision was made, and 2) If it was a mistake, would the benefit of changing it now outweigh the costs of making the change (including breaking code, re-inventing the wheel, etc)

[18:34] *** wamba joined
[18:35] <codesections> in my experience, there are a _lot_ of times the answer to 1) is "yeah, looking back, that was the wrong call" and the answer to 2) is "No, it's not worth changing at this point".  

[18:35] <codesections> tldr; life is path-dependant 

[18:35] <AlexDaniel> codesections: 1) is irrelevant, 2) I completely agree with and I'd love if people were discussing things like that

[18:37] <sena_kun> 2 seems the most interesting one here. It is rare people do really care about details like that. Each and every language has mistakes "included" and everyone complains about them but everyone uses them nonetheless. Fallout of the removal would be great and the result won't be tons of people like "Oh, finally they removed Junctions, now I'll write software in Raku".

[18:37] <lizmat> sena_kun++

[18:37] <codesections> Well, 1 _can't_ be irrelevant because 2) starts with "*if* it was a mistake at the time".  Here, it's not clear at all that it was a mistake (I mean, not clear to me because I don't understand enough of the tradeoffs; I recognize it's clear to others in opposite directions)

[18:38] * lizmat steps away from the discussion

[18:39] <AlexDaniel> codesections: I don't understand what you're saying. Why does it matter if it was a mistake at the time? Maybe it was fully justified back then, but it isn't today.

[18:40] <AlexDaniel> and yeah, last time people got very emotional when I mentioned that even at the time it wasn't justified :P :P

[18:40] <codesections> Ok, sure.  I guess I should have said ¬´1) if we were making the decision for the first time today, would we chose a different implementation or would we do it the same way we really did¬ª

[18:40] <sena_kun> If our human resources are scarce (to be frank, they are), it is optimal to aim actions towards the goals that appear to be like the most result-returning. If anyone would ask me, I don't think "Junctions are bad and scary" is in top 20 reasons Raku is not so popular.

[18:40] <AlexDaniel> so maybe let's skip that part x)

[18:41] <codesections> sena_kun: Agreed.  In fact, I'd go further: junctions are a net positive in drawing people to the language

[18:41] <AlexDaniel> codesections: oh, if you mean that, then I completely agree with! If the feature didn't exist, would we have added it today? It's a good way of thinking about design decisions

[18:41] <perigrin> codesections: the problem with atemporal question is we don't live atemporal lives ... 1) is this causing a problem that needs solving *today* 2) what's the cost/benefit analysis of *this* change

[18:42] <perigrin> if you can answer those two questions in step one of AlexDaniel's three part list ... then steps 2 and 3 become vastly easier

[18:42] <codesections> yeah.  But then part 2) is accepting that, sometimes, we need to live with things that aren't the way we would do them if we were writing on a blank canvas

[18:42] <sena_kun> In the same way we can talk about e.g. bugs / issues in DBIish, how Raku needs a top notch, solid DB solution and how can we address them. This will be actionable without tearing the language apart suffering code breakages everywhere (everyone hates broken code).

[18:43] <AlexDaniel> sena_kun: I don't know. Yes and no. One of the things that attracted me to Raku is that it seemed like a well-designed language that had less design issues than other ones. Don't know if this was marketed, but I felt like that was implied.

[18:43] <AlexDaniel> needless to say I ended up with a bad taste in my mouth x)

[18:43] <perigrin> it was slightly marketed.

[18:44] <AlexDaniel> so if we're not aiming to get a perfect language, then we're again back at the recent-ish question for the council. What's Raku now and what should it be?

[18:44] <codesections> AlexDaniel: yeah, of course.  I think we all agree that Raku is better-designed than _most_ languages (which is a pretty low bar!).  That doesn't mean we are/can be/should try to be perfect 

[18:45] <AlexDaniel> codesections: I don't agree

[18:45] <perigrin> perfect is impossible

[18:45] <AlexDaniel> the bar is actually pretty high

[18:45] <sena_kun> AlexDaniel, depending on the target audience, no? I mean, damn, people write java because their projects are written in java. Because there are tons of libraries, manuals, it is relatively fast and does the job. This, apparently, matters, contrary to folks who think about consistency.

[18:46] <codesections> sena_kun: exactly.  And you could s/java/javascript/ or /Python/ or /Ruby/

[18:46] <AlexDaniel> sena_kun: that's totally fine, yes. But if having a well-designed consistent language is not the goal, then what are the values of Raku? That's basically the question.

[18:47] *** molaf joined
[18:47] <sena_kun> C++ has so many things (ok, just.. HORRIBLE DESIGN SOLUTIONS OH GOD I CRY WITH BLOOD) that make Raku a nice English garden, yet it is widely used and is taken.

[18:48] <AlexDaniel> because it has other things to offer. Again, what does raku offer?

[18:48] <sena_kun> AlexDaniel, https://github.com/Raku/Raku-Steering-Council/issues/3 <- no?

[18:48] <codesections> I'd say ¬´having a well-designed, consistent language¬ª is *a* goal, because it helps enable other goals.

[18:50] <codesections> Personally, my main goal for Raku is for it to be a language that optimises for individual developer productivity (sort of the inverse of Golang/Java ‚Äì they sacrifice individual productivity for team productivity via consistent style and protective practices that keep weaker devs from shooting others in the foot)  

[18:51] <codesections> that's just my personal take, though

[18:51] * perigrin has found Golang a lot more optimized for the individual than he expected

[18:51] <AlexDaniel> sena_kun: yeah, it's related. I'm more interested in the practical side of things, but it's a start

[18:52] <codesections> perigrin: I agree that Golang actually does surprisingly well there.  But if you listen to statments the dev team has made, it's clear that they were/are optimizing for solving the problems of large teams (e.g., the type of teams Google has)

[18:53] <perigrin> Yes and no

[18:53] <perigrin> I think what they were optimizing for was orthogonal to the team size

[18:53] <perigrin> they were optimizing for large *projects* where developers come and go

[18:54] <codesections> Yeah, that's 100% fair

[18:54] <perigrin> and that's the feeling I get from working in go a lot for the last 8 months or so

[18:54] <codesections> But that's a large team in my book.  Maybe spread out over 4 dimensions instead of just 3, but still :D 

[18:55] <AlexDaniel> for me, today, Raku only offers syntax that I find pleasing. If you gave me Julia, JS or even Python that simply had the same (or very similar) syntax, I'd be a happy dev.

[18:57] <perigrin> codesections: yes|no ... the project may only have a handful or fewer developers over the course of a decade, but touch thousands of machines and have hundreds of deployments 

[18:57] <AlexDaniel> and this understanding is actually rather promising in some ways

[18:59] <perigrin> What about the syntax pleases you? That will lead you to why certain features are consistent/inconsitent with that view

[18:59] <codesections> perigrin: (shouldn't that be an `all` junction, not an `any` one? :D )

[18:59] <perigrin> possibly :)

[18:59] <perigrin> depends on what you consider a large team ... 

[19:00] <perigrin> team size is a fuzzy set 

[19:00] <AlexDaniel> perigrin: I love statement modifiers, no need for parens in sub calls, $_ default variable, `my` (somehow I always get the scoping wrong in Julia)

[19:02] <perigrin> So far you're in the Perl family of languages ... 

[19:03] <AlexDaniel> oh, functional programming that reads from left to right :)

[19:03] <perigrin> I don't know of another language with a topicalizer ... lexical scoping is around in other languages and method/function dispatching can do your head in elsewhere

[19:03] <perigrin> So far you're in a "tastefully constrained programmer wrote this" Perl family of languages :)

[19:04] <AlexDaniel> perigrin: Julia is the closest thing I think, JS is also not horribly bad. None of them have all the features I mentioned, of course, so syntax-wise Raku is still better for me

[19:04] <codesections> perigrin: the main tradeoff I view golang as making is that it very explicitly aims to be easy to learn: ¬´The need to get programmers productive quickly in a new language means that the language cannot be too radical¬ª https://talks.golang.org/2012/splash.article

[19:05] <AlexDaniel> but the feature sets are close enough, which is why I say that it's just the syntax that I value

[19:05] <codesections> Raku, on the other hand, isn't as easy to learn (at least at more than a superficial/baby-talk level) but that allows us to reward deep mastery a lot more

[19:06] <perigrin> yes Go (and Java) are both explicitly tiny languages in semantics becasue they want to be easy to pick up and they don't want a lot of idioms because jargon is always difficult to maintain

[19:07] <perigrin> and yes Raku (and originally Perl) were intentionally idiomatic languages where Jargon was encouraged to improve expressivity 

[19:07] *** BenGoldberg left
[19:07] <codesections> Well, no, jargon isn't *always* difficult to maintain; it's always dificult to maintain for other people who don't know the jargon :) but creating your own jargon can be extremely powerful too, especially with a small team that is on the same page about what things mean

[19:07] <perigrin> my verb tenses there and my parens are causing my english diploma to singe at the edges

[19:08] <codesections> :)

[19:10] <codesections> I'd make a similar point about gofmt.  It's a _great_ tool in a lot of usecases.  But there are also a lot of times that I'm _really_ glad there's no Rakufmt ‚Äì many times, I can write clearer code with more stylistic freedom.  And, yeah, that would slow someone else down for a few minutes when first reading my code.  But I'm ok with that tradoff

[19:10] <perigrin> I disagree, jargon by definiton is held by a small group ... it *needs* to be maintained to keep up with the standards of that group more than more generic language because changes neccessarily happen faster within that group

[19:10] <El_Che> about go and java, both small languages: go projects are fairly easy to pick up and understand, java projects are not. One lang tried to limit the abstraction, while the other went crazy (injections, factories, impl classes, etc)

[19:10] * perigrin hasn't used Java in a *long* time ... was treading carefully anyway.

[19:11] <El_Che> so in practice, both languages are very far from each other conceptually

[19:11] <perigrin> that was also my feeling. I was pretty sure my Java 1.4 experience didn't translate to Java 6+

[19:11] <codesections> Well, sure.  But ‚Äì well, here's an example: before I was a software dev, I was a practicing attorney.  There's a _lot_ of legal jargon, and it's known by only a small (ish) group.  But talking about the law would be *way* harder if you avoided all legal jargon

[19:11] <perigrin> since it predated generics and lexical subroutines if nothing else

[19:12] <perigrin> codesections: I'm not saying jargon is a bad thing! Far from it, for exactly that point

[19:12] <perigrin> but you have to admit that legal jargon from the 1930s is vastly different than that from today

[19:13] <El_Che> perigrin: the java lang is fine and got better --easier-- over the years

[19:13] <perigrin> I'd hate to think it got worse 

[19:13] <El_Che> perigrin: it's the ecosystem that it's built around overengineered design patterns and every you do is painful

[19:13] <perigrin> I felt like a contortionist even *after* I stopped trying to write Perl in Java.

[19:15] <El_Che> perigrin: I learnt java to get OO. Perl's OO was too painful pre-Moose

[19:15] <codesections> ... well, actually not really.  The legal profession moves _slowly_!  Vivid memories of doing both law and coding at the same time: I'd find a "recent" case (e.g., from 1980) and "old" code docs (e.g., from 2010)

[19:15] <El_Che> bbl

[19:15] <perigrin> El_Che: I learn't Perl to get OO ... Java was like working with gloves on

[19:17] <perigrin> codesections: fair, I have only looked at the legal profession from a "oh my god, that has to be better than dealing with docker" point of view

[19:17] <perigrin> (so roughly the opposite direction)

[19:17] <codesections> :D

[19:17] *** autarch left
[19:17] <perigrin> well and I watched 6 of the 7 seasons of Suits

[19:18] <perigrin> that counts right?

[19:18] <codesections> haha, I've actually not seen it.  The Wire is depressingly accurate, though

[19:20] <perigrin> (actually I have a number of books on "how to start and run a law practice" in my kindle library becasue the parallels between that and running a code-consultancy seem enormous)

[19:20] <Grinnz> suits :D

[19:20] <Grinnz> the only tv show with a duchess of britain

[19:22] <codesections> interesting, I can kind of see the parallels.  But, really, I won't pretend to be much of an authority on that ‚Äì the legal jobs I had were clerking for a federal judge and then working for a 700+ lawyer firm, so I was about as far from "starting and running a small firm" as you can get! 

[19:23] *** pamplemousse__ left
[19:24] <perigrin> Grinnz: to be fair she wasn't a dutches when she was on it

[19:25] <perigrin> she in fact left becasue she was about to become a Dutchess

[19:25] <perigrin> and then they had two more seasons to see if it would work without the main character / premise ... and it didn't.

[19:25] * perigrin still liked it ... but it wasn't the same without Mike.

[19:26] <Grinnz> havent gotten to those yet

[19:26] <Grinnz> sad

[19:26] <Grinnz> but also like... i dont know if its a concept you can milk for that many seasons anyway :P

[19:27] <perigrin> There is apparently also a spinoff about Jessica 

[19:27] <Grinnz> ah yes

[19:27] <perigrin> but I don't think they got any further than the backdoor pilot

[19:28] <kiti_nomad[m]> I want to ask some questions about the open source license agreement. For example, I have a program to be open sourced, but when people who use it create a new program, the code based on it must also be open sourced.  So, what protocol should I choose

[19:29] <lizmat> kiti_nomad[m]: I think https://nl.wikipedia.org/wiki/GNU_General_Public_License may be what you're looking for

[19:29] <lizmat> actually: https://en.wikipedia.org/wiki/GNU_General_Public_License if you're not Dutch  :-)

[19:30] <lizmat> or another copyleft license, I guess :-)

[19:30] <codesections> yeah, agreed that GPL is basically what you want (not legal advice :) ) 

[19:30] <kiti_nomad[m]> So why can gms on Android not be open source? Why can the apk running on it not be open source?

[19:31] <lizmat> kiti_nomad[m]: no idea, feels like a question you should ask on a different IRC channel, not sure which one  :-(

[19:31] <kiti_nomad[m]> The linux kernel is gpl protocol

[19:31] <lizmat> this channel is devoted to the Raku Programming Language aka #rakulang

[19:32] <codesections> agreed.  But here's the short answer: Google services don't use the Linux *code* even though they ship on a platform that runs that code (which is also true for many apps released on Linux ‚Äì just because you run on a GPL platform doesn't mean the same as using the *code*)

[19:33] <AlexDaniel`> kiti_nomad: what kind of a program? For some cases GPLv3 does not imply sharing code, see AGPLv3 instead and the difference between them

[19:34] <codesections> Here's a Raku question:  a few hours ago, guifa mentioned that I can use syntax like `:$foo` inside a regex to access a variable scoped to the regex.  I'm turning to that now, and can't get the syntax to work.

[19:35] <codesections> can anyone show a quick example of how that works?

[19:37] <AlexDaniel> lizmat: it's an OK channel, devs deal with licenses all the time so we know what they do and can explain some things. At least, it's not a bad place to place, that is if we're welcoming and all :)

[19:37] <timotimo> perhaps more like ":my $foo" rather than ":$foo"?

[19:37] <AlexDaniel> of course there are other places for legal advise, but it's OK to ask here too

[19:37] <lizmat> I was referring to the question: "So why can gms on Android not be open source? Why can the apk running on it not be open source?"

[19:37] <lizmat> those aren't requests for advice ?

[19:39] <codesections> timotimo: I don't understand, sorry

[19:40] <kiti_nomad[m]> Forget it, I don't understand the problem I want to describe.

[19:40] <perigrin> kiti_nomad[m]: if you'd like I can give you the email address of a FOSS licensing consultant I know, she *may* charge for her services because this is what she does professionally

[19:40] <lizmat> in src/Perl6/Grammar.nqp you wil find examples, e.g.     token babble($l, @base_tweaks?) {

[19:40] <lizmat>         :my @extra_tweaks;

[19:40] <timotimo> there's syntax in regexes to have things like variable declarations

[19:41] <lizmat> codesections ^^

[19:41] <perigrin> (she also does way more than FOSS licensing consulting)

[19:41] <codesections> lizmat++ Thanks, I should have thought to check there :)

[19:41] <lizmat> codesections: perhaps even more useful, using dynamic vars:  :my $*FOO

[19:42] <kiti_nomad[m]> Thx

[19:42] <codesections> lizmat: ohh, that made me realize that https://docs.raku.org/language/grammars#Dynamic_variables_in_grammars is relevant 

[19:45] <perigrin> kiti_nomad[m]: is that a "thanks, yes please" or a "thanks but I'm good for now" or a "Oh that wasn't even about you perigrin"?

[19:48] <AlexDaniel`> kiti_nomad: if you have more details like what is the type of a project and when exactly you want/don't want others to share code, we can give you some more specific suggestions. Generally, you are right, GPL offers the strongest protection (use AGPLv3 if you want it even stronger), but the intent of GPL does not always result in people sharing code, it can be complicated.

[19:54] <kiti_nomad[m]> Thank you, I'm not interested in this anymore, I think as long as open source, it doesn't make any sense.  In China, open source license agreements have no legal effect

[19:55] <AlexDaniel`> kiti_nomad: well, yeah. However, some people won't use a project unless it has a license that they like, so specifying one is a good idea to attract users

[19:55] <kiti_nomad[m]> Open source may be just for sharing happiness

[20:01] <kiti_nomad[m]> The agreement has no practical meaning. To attract users, I think why I don‚Äôt specify all the license agreements.

[20:02] <AlexDaniel`> kiti_nomad: in most of the world, if a license is not specified, then other people *can not* use it

[20:04] <kiti_nomad[m]> Yes, some people are gentlemen and they have their own principles

[20:04] <AlexDaniel`> it might not have a practical meaning in some cases, but a lot of the times following the rules is preferred, especially if you are working for a company

[20:23] *** evalable6 left
[20:23] *** linkable6 left
[20:25] *** evalable6 joined
[20:25] *** linkable6 joined
[20:26] <[Coke]> if I want to use an OSS product for work, it must be licensed or we can't touch it.

[20:26] <[Coke]> (and everything that does have a license, I have to get approvals, make sure we follow rules of the license, etc.)

[20:33] <El_Che> if a project has no license, it's a propriatary product that you can not legally use in a country with copyright laws

[20:33] <El_Che> no license == defaults to "all rigths reserved and you have none" 

[20:38] <tbrowder>  hi, need some more help with undef objects. can i alway test $obj ~~ Any to detect an undefined object?

[20:38] <sena_kun> tbrowder, "undef" objects being what, type objects or?

[20:38] <lizmat> m: my $foo; dd $foo ~~ Any:U

[20:38] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Bool::True‚ê§¬ª

[20:39] <lizmat> m: my $foo; dd $foo ~~ Any

[20:39] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Bool::True‚ê§¬ª

[20:39] <lizmat> m: my $foo; dd $foo ~~ Any:D

[20:39] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Bool::False‚ê§¬ª

[20:39] <Grinnz> https://choosealicense.com/no-permission/

[20:40] <MasterDuke> there's also .DEFINITE

[20:41] <tbrowder> i'm using Inline::Perl5 to unpack some Perl data that is 'undef' in Perl terms and need a good Raku test for it. i think lizmat just reminded me to use the Any:D which i forgot about.

[20:42] <tbrowder> m: my $foo; say $foo.DEFINITE

[20:42] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´False‚ê§¬ª

[20:43] <tbrowder> okay! several options. thnx gang!

[20:44] <tbrowder> m: my @a; say @a.DEFINITE

[20:44] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´True‚ê§¬ª

[20:45] <tbrowder> m: my Array $a; say $a.DEFINITE

[20:45] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´False‚ê§¬ª

[20:46] <tbrowder> m: my Array $a; say $a.^name

[20:46] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´Array‚ê§¬ª

[20:47] <tbrowder> m: my Array $a; say so $a ~~ Any

[20:47] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´True‚ê§¬ª

[20:48] <tbrowder> m: my Array $a; say so $a ~~ Any:D

[20:48] <camelia> rakudo-moar 85847d2f1: OUTPUT: ¬´False‚ê§¬ª

[20:49] <tbrowder> thanks a mil. bye

[20:58] *** dakkar left
[21:30] *** aluaces left
[21:43] *** sena_kun left
[21:45] *** mowcat left
[21:55] <tbrowder> btw, when using unpacking the perl data the smart match won't work as expected in all cases. comparing on Any:U seems to work as needed in all cases. to detect the actual type i had to interrogate $obj.^name because it seems Inline::Perl5 has its own hash and array wrappers. although they unpack as expected for the type.

[21:56] <tbrowder> i assume .DEFINITE would work but didn't use it so far

[21:58] *** BenGoldberg joined
[22:17] *** mowcat joined
[22:28] *** rindolf left
[22:29] *** BenGoldberg left
[22:29] *** Ben_Goldberg joined
[22:29] *** Ben_Goldberg is now known as BenGoldberg

[22:34] *** BenGoldberg left
[22:51] *** wamba left
[23:03] *** aborazmeh left
[23:10] *** dogbert17 left
[23:10] *** aindilis left
[23:16] *** sjaveed joined
[23:26] *** BenGoldberg joined
[23:27] *** reportable6 left
