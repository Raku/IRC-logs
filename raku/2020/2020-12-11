[00:13] *** pecastro left
[00:15] *** xelxebar left
[00:15] *** tejr left
[00:17] *** redhands_001 left
[00:21] <coldpress> guifa: thanks again, that's very helpful. I just wish the Raku docs mentioned the more common term "scan", instead of "triangular reduce"

[00:22] *** tejr joined
[00:22] *** xelxebar joined
[00:32] *** frost-lab joined
[01:00] * guifa never knew that it was called a scan until reading the article

[01:00] <guifa> I efinitely would have related scan with something else

[01:01] *** guifa left
[01:25] *** wamba left
[01:26] *** wamba joined
[01:30] *** lucasb left
[01:37] *** BenGoldberg joined
[01:37] *** klapperl_ joined
[01:39] *** klapperl left
[01:40] *** MasterDuke left
[01:51] *** jmchael left
[01:57] *** wamba left
[02:00] <coldpress> guifa: fair enough

[02:00] <tellable6> coldpress, I'll pass your message to guifa

[02:07] *** Black_Ribbon joined
[02:16] <tbrowder> .tell jmerelo "you da man!"

[02:16] <tellable6> tbrowder, I'll pass your message to jmerelo

[03:07] *** evalable6 left
[03:07] *** linkable6 left
[03:07] *** tellable6 left
[03:07] *** tellable6 joined
[03:10] *** linkable6 joined
[03:10] *** evalable6 joined
[03:28] *** leont left
[04:17] <moon-child> m: print [\-] ^6

[04:17] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «0 -1 -3 -6 -10 -15»

[04:22] *** maggotbrain joined
[04:29] *** guifa2 joined
[04:48] <coldpress> today's advent of raku is cute and I love it

[05:29] *** evalable6 left
[05:29] *** linkable6 left
[05:31] *** linkable6 joined
[05:32] *** evalable6 joined
[05:35] *** jcallen left
[05:36] *** hobbs left
[05:36] <notandinus> oof raku is coming too much in my way today

[05:37] <notandinus> how do i make a list mutable?

[05:37] <notandinus> i'm taking it from a file with IO.lines.map(*.comb.cache)

[05:38] <notandinus> it is a list within a list

[05:39] *** jcallen joined
[05:40] *** hobbs joined
[05:40] *** hobbs left
[05:40] *** hobbs joined
[05:45] *** Ben_Goldberg joined
[05:45] *** BenGoldberg left
[05:45] *** Ben_Goldberg is now known as BenGoldberg

[05:47] *** rindolf joined
[05:56] <notandinus> i just added .Array to the map and it works fine

[06:14] *** jmerelo joined
[06:15] <coldpress> notandinus: are you doing AoC?

[06:15] *** ufobat joined
[06:15] <guifa2> Lists are unmutable, Arrays are mutable.

[06:15] <tellable6> 2020-12-11T02:00:53Z #raku <coldpress> guifa: fair enough

[06:24] <guifa2> coldpress: I kind of regret not giving my article thisyear more of a Christmas theme

[06:24] <guifa2> But tbrowder++ for today's advent calendar post

[06:28] <notandinus> coldpress:  yeah

[06:28] <notandinus> i feel i would've finished earlier if i knew about lists and arrays

[06:29] <guifa2> Basically, Lists/Maps are unmutables, and Arrays/Hashes are the mutable equivalents

[06:30] <guifa2> (Lists/Maps also don't containerize, and that's technically the difference — if you add a scalar container to a List, that particular item *is* mutable)

[06:53] *** aluaces joined
[06:58] <notandinus> i see, i'll read up on it

[06:59] <notandinus> coldpress:  i'm andinus on advent-of-raku repository that you have

[07:00] <notandinus> i have my own repo so i add solutions at once after a few days

[07:02] *** BenGoldberg left
[07:02] *** Ben_Goldberg joined
[07:02] *** Ben_Goldberg is now known as BenGoldberg

[07:04] <notandinus> is there a shorthand for "if $x and $x == 1" ?

[07:04] <coldpress> notandinus: I'm wondering how mutable arrays solve today's AoC. I thought the solution requires immutable arrays

[07:04] <notandinus> coldpress:  you need to change the seat position to occupied/unoccupied right?

[07:05] <coldpress> yes, but you need to change all of them at once

[07:05] <coldpress> so mutating only one element in the array of seats will give you the wrong result

[07:05] <notandinus> yeah, my solution is very messy. what i did was to copy the input in other array (@hi) and check if seat is occupied/unoccupied with @hi and reflect the changes in @input

[07:06] <notandinus> ^ loop this again till @hi eq @input

[07:06] <notandinus> my part 2 is still running, been 7 minutes since i started it.

[07:07] <coldpress> oh, right, the other array has to be mutable

[07:07] <jmerelo> notandinus: Well, $x == 1 will do pretty much the same. You can precede it with "with $x" if you want. 

[07:07] <tellable6> 2020-12-10T23:23:36Z #raku <tbrowder> jmerelo the latest source is here: https://github.com/tbrowder/advent2020/blob/master/fancy-advent.html

[07:07] <tellable6> 2020-12-10T23:25:14Z #raku <tbrowder> jmerelo same title: Santa Claus TWEAKs with a Class

[07:07] <tellable6> 2020-12-11T02:16:52Z #raku <tbrowder> jmerelo "you da man!"

[07:07] <coldpress> just realized I have a huge performance penalty with a 2D array

[07:08] <notandinus> jmerelo: how would you use it in postfix, like so "say 'hi' if $x and $x == 1"?

[07:09] <notandinus> coldpress:  i see, 2d array meaning @input[$y][$x] thing?

[07:09] *** parabolize left
[07:11] <notandinus> m: my $x; say 'hi' if $x == 1;

[07:11] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤»

[07:11] <notandinus> m: my $x; say 'hi' if $x and $x == 1;

[07:11] <camelia> rakudo-moar 9dbb52f9e: ( no output )

[07:11] <notandinus> ^ this thing i want to shorten

[07:22] *** guifa2 left
[07:22] *** guifa2 joined
[07:23] <guifa2> 'and' has an extremely low precedence

[07:23] <guifa2> so you have

[07:24] <guifa2> (say 'hi' if $x) and ($x == 1)

[07:24] <guifa2> coldpress: lizmat improved performance on 2D arrays a lot if you're building from source -- 60x improvements I believe she said

[07:25] <notandinus> ah i see, that's why it wasn't working

[07:25] <guifa2> && has higher

[07:25] <no-n> and has low blood pressure

[07:25] <no-n> it needs to eat something salty

[07:25] <notandinus> guifa2: what would be a better way to write:

[07:26] <notandinus> m: say 'hi' if ($x and $x == 1)

[07:26] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$x' is not declared␤at <tmp>:1␤------> 3say 'hi' if (7⏏5$x and $x == 1)␤»

[07:26] <guifa2> m: my $x; say 'hi' if $x && $x == 1

[07:26] <camelia> rakudo-moar 9dbb52f9e: ( no output )

[07:26] <notandinus> ^ yeah this, is there something that shortens 'if $x && $x == 1' to 'something $x == 1' ?

[07:29] <guifa2> Unfortuantely precedence of with is too high to use "if $x == 1 with $x" 

[07:29] <guifa2> If you're going to use it a lot

[07:30] <notandinus> i see, i think i'll just use && then, i thought there will be something in base

[07:30] <notandinus> issue is that you'll have to change the variable at 2 places

[07:30] <guifa2> sub infix:<=?=> (\a, \b) { a && a == b }; my $x; my $y = 1; say "hi" if $x =?= 1; say "hello" if $y =?= 1;

[07:30] <evalable6> guifa2, rakudo-moar 9dbb52f9e: OUTPUT: «hello␤»

[07:32] * guifa2 is afk

[07:32] <notandinus> i see, this is nice, thanks

[07:34] <jmerelo> guifa2: cool

[07:40] *** patrickb joined
[07:52] *** sena_kun joined
[07:52] *** webstrand left
[07:54] *** domidumont joined
[08:01] *** wamba joined
[08:07] *** sjm_uk joined
[08:07] <coldpress> guifa2: thanks for letting me know, I'll just do a 1D array for now

[08:09] *** pecastro joined
[08:11] *** stoned75 joined
[08:14] *** pecastro left
[08:24] *** Sgeo left
[08:30] *** BenGoldberg left
[08:32] *** BenGoldberg joined
[08:35] *** stoned75 left
[08:36] *** abraxxa left
[08:37] *** abraxxa joined
[08:51] *** stoned75 joined
[09:06] *** BenGoldberg left
[09:07] *** Altai-man joined
[09:09] *** BenGoldberg joined
[09:10] *** sena_kun left
[09:11] *** pecastro joined
[09:12] <guifa2> notandinus: oh, I thought of another way you could do it

[09:12] <guifa2> Can't believe I didn't think of it sooner

[09:12] <guifa2> my $x; say "hi" if $x ~~ 1

[09:13] <guifa2> m: my $x; say "hi" if $x ~~ 1; $x = 1; say "hi" if $x ~~ 1

[09:13] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «hi␤»

[09:14] <notandinus> guifa2: ah i see, that's nice thanks

[09:14] <notandinus> guifa2++

[09:16] <guifa2> ~~ is the smartmatcher, the idea is each class will do what makes the most sense (not sure if you've come across it too much yet)

[09:20] <notandinus> ~~ was discouraged in perl so i don't use it much

[09:21] <notandinus> so @t ~~ @h will do what i want?

[09:21] *** poga left
[09:21] <notandinus> m: my @t = ^2; my @h = 0, 1, 2; say @t ~~ @h;

[09:21] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «False␤»

[09:22] <notandinus> m: my @t = ^2; my @h = ^2; say @t ~~ @h;

[09:22] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «True␤»

[09:23] <notandinus> m: my @t = ^2; my @h = 0, 1; say @t ~~ @h;

[09:23] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «True␤»

[09:23] <notandinus> m: my @t = ^2; my @h = 1,0; say @t ~~ @h;

[09:23] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «False␤»

[09:23] <notandinus> oh nice

[09:25] <notandinus> i saw a literate programming article for raku with ob-raku, does anyone have a link for it? can't find it 

[09:29] <notandinus> ah i found it, was on raku-advent blog https://raku-advent.blog/2020/12/03/day-3-literate-programming-with-raku/

[09:33] <guifa2> notandinus: yeah, smartmatching definitely had some issues in perl

[09:35] <notandinus> guifa2: will ~~ have speed penatly ?

[09:36] <guifa2> notandinus: probably minimal

[09:36] <guifa2> it might involve a single extra method call

[09:36] <guifa2> $a ~~ $b is the same as doing $b.ACCEPTS($a)

[09:37] <guifa2> ACCEPTS(Any:D: Any:U) is, I believe always false

[09:38] <moon-child> you can also use

[09:38] <moon-child> m: my $x; say 'a' if $x eqv 3; $x = 3; print 'b' if $x eqv 3;

[09:38] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «b»

[09:38] <guifa2> ACCEPTS(Numeric:D $a: Numeric:D $b) is probably just defined as { $a == $b }

[09:39] <moon-child> which has the (arguable advantage that)

[09:39] <moon-child> which has the (arguable) advantage that

[09:39] <moon-child> m: say <a b c> ~~ 3, <a b c> eqv 3

[09:39] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «TrueFalse␤»

[09:41] *** BenGoldberg left
[09:41] <guifa2> moon-child++

[09:41] *** BenGoldberg joined
[09:44] <notandinus> i see, i'll use eqv then, it also works on lists

[09:44] <notandinus> m: say ^2

[09:44] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «^2␤»

[09:44] <notandinus> m: my @t = ^2; my @p = ^2; say @t eqv @p

[09:44] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «True␤»

[09:46] <moon-child> m: say (^2).eager

[09:46] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «(0 1)␤»

[09:47] <moon-child> m: say (^2).eager eqv ^2

[09:47] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «False␤»

[09:47] <moon-child> gotta be careful

[09:49] <notandinus> yeah it says that on docs, 

[09:49] <notandinus> m: say (^2).eager ~~  (^2)

[09:49] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «True␤»

[09:49] <notandinus> hmm i see

[09:50] *** lizmat_ joined
[09:50] <moon-child> you can also use eq, although if you're worried about performance that's probably an even worse idea

[09:53] *** lizmat left
[10:10] *** BenGoldberg left
[10:31] <notandinus> is Int and int different?

[10:32] <notandinus> i was reading this https://raku-advent.blog/2020/12/10/day-10-my-10-commandments-for-raku-performances/ and they call int as Native type and Int as explicit object type, what's the difference??

[10:41] <tadzik> Int is an int in a scalar container, which allows you to modify it

[10:42] <tadzik> (as in: modify its contents rather than reassign it)

[10:42] <tadzik> ...or something like that :P My Raku's a bit rusty these days, I may be messing something up

[10:42] *** brtastic1 joined
[10:45] *** brtastic1 is now known as brtastic

[10:46] *** asymptotically joined
[10:49] *** lizmat_ is now known as lizmat

[10:56] *** literal_ is now known as literal

[10:59] <jmerelo> tadzik notandinus int is a native container, which is mapped to the architecture int. Int is a Raku int, which has infinite precision. Both are containers, unlike the intxx, which don't, as tadzik says.

[11:01] *** brtastic left
[11:02] <tadzik> ah, I almost got it :P

[11:02] <lizmat> except that native ints are only conceptual containers, they don't actually have a container, they're essentially just memory somewhere

[11:03] <lizmat> with objects pointing to them

[11:06] <lizmat> m: sub a(\a) { say a.VAR.name }; my $i = 42; a $i   # a proper container with a name

[11:06] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «$i␤»

[11:06] <lizmat> m: sub a(\a) { say a.VAR.name }; my int $i = 42; a $i    # NOT a container

[11:06] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «No such method 'name' for invocant of type 'Int'.  Did you mean any of␤these: 'base', 'none', 'note', 'Num'?␤  in sub a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:13] *** squashable6 left
[11:14] <jmerelo> lizmat: ah. But a container by any other NAME... 

[11:14] *** squashable6 joined
[11:14] <jmerelo> lizmat: sorry, couldn't help it.

[11:21] <coldpress> damn, I think the biggest overhead in today's AoC is using functional programming to calculate the neighbors' indices

[11:33] <guifa2> Also, working with native ints can sometimes be tricky.  I would recommend against using them unless you reach a point where speed is worth the extra trouble of strict typing and and dealing with some of the other oddities of native ints

[11:37] *** guifa2 left
[11:47] <lizmat> what guifa2 said

[11:50] <tbrowder> hi, diff subject: wordpress, advent, Pod::To::HTML, question:

[11:53] <tbrowder> does anyone have a mustache template, css, etc. setup for Pod::To::HTML that would do nicely on the raku advent wordpress site?

[11:53] *** ufobat_ joined
[11:56] *** ufobat left
[11:59] *** leont joined
[12:00] *** cgfbee joined
[12:14] <notandinus> coldpress: can you share your solution for today's AoC ?

[12:20] *** abraxxa left
[12:21] *** asymptotically left
[12:24] *** asymptotically joined
[12:26] *** Altai-man left
[12:26] *** Altai-man joined
[12:27] *** jmchael joined
[12:27] *** squashable6 left
[12:30] *** squashable6 joined
[12:35] *** wamba left
[12:39] <tadzik> I can show you mine, but it's in Rust :)

[12:44] <notandinus> sure, i just want to see how others solved it, mine is too slow

[12:44] <notandinus> tadzik:

[12:47] *** orinthe9 joined
[12:48] *** orinthe left
[12:48] *** orinthe9 is now known as orinthe

[12:52] <notandinus> will hashes be better for memoization ?

[12:52] <notandinus> compared to arrays

[12:52] *** frost-lab left
[13:03] <lizmat> notandinus: if your lookup key can be in integer, then yes

[13:03] <notandinus> i see, also how do i do the deepcopy thing?

[13:05] <tadzik> notandinus: https://git.tadzik.net/tadzik/aoc2020/src/master/src/bin/day11.rs

[13:05] <tadzik> I don't uses any sort of memoization in there, fwiw

[13:05] <tadzik> the first two functions in there are the interesting bits

[13:06] <notandinus> yeah i was talking about memoization in relation to yesterday's puzzle

[13:06] <tadzik> I now see that I could actually refactor it to use raycasting in both cases, just shorter in the first

[13:06] <tadzik> oh, I solved it in a very hacky way D:

[13:07] <tadzik> https://git.tadzik.net/tadzik/aoc2020/src/master/src/bin/day10.rs#L33

[13:08] *** sena_kun joined
[13:09] * [Coke] wonders what the origins of .rotor are.

[13:10] *** Altai-man left
[13:10] <[Coke]> m: say (1..50).rotor(1,2=>-1,3=>-2, :partial)

[13:10] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «((1) (2 3) (3 4 5) (4) (5 6) (6 7 8) (7) (8 9) (9 10 11) (10) (11 12) (12 13 14) (13) (14 15) (15 16 17) (16) (17 18) (18 19 20) (19) (20 21) (21 22 23) (22) (23 24) (24 25 26) (25) (26 27) (27 28 29) (28) (29 30) (30 31 32) (31) (32 33) (33 34 35) (3…»

[13:10] <lizmat> [Coke]: you mean the name?

[13:11] <[Coke]> name & functionality. first time I'd seen it was Raku

[13:12] <[Coke]> I find it a useful tool for solving certain types of problems, but never would have thought to put it in the toolbox.

[13:13] <[Coke]> is it from Enigma?

[13:13] <lizmat> first commit mentioning " rotor" is a29614c54bb5e96

[13:13] <linkable6> (2015-04-23) https://github.com/rakudo/rakudo/commit/a29614c54b shim in .rotor(Pair) for transition to gapishness

[13:13] <lizmat> well, that's an association that I have as well

[13:13] <lizmat> (linking it to the Enigma machine)

[13:18] *** sacomo joined
[13:31] *** brtastic1 joined
[13:34] *** brtastic1 is now known as brtastic

[13:48] *** orinthe2 joined
[13:49] *** orinthe left
[13:49] *** orinthe2 is now known as orinthe

[13:54] <notandinus> can i compile raku script like it does with the modules? 

[13:56] <moritz> last I tried it, you could compile it, but then couldn't run the result :/

[13:57] <notandinus> i see, i wanted to see how much faster it becomes

[14:07] <tadzik> a common hack is putting it all in the module and just importing that in a file

[14:07] <tadzik> https://github.com/ugexe/zef/blob/master/bin/zef

[14:07] <tadzik> the startup will get faster, but I don't think it will improve the actual runtime

[14:09] *** brtastic left
[14:19] *** Sgeo joined
[14:21] *** brtastic joined
[14:39] *** jmerelo left
[14:42] *** codesect` joined
[14:44] *** brtastic left
[14:44] *** hal99999 joined
[14:47] *** codesections left
[14:49] <notandinus> how could i count the number of '#' characters in an array of arrays?

[14:50] <notandinus> i know i could always loop over it, are there better ways?

[14:51] *** orinthe4 joined
[14:51] <lizmat> join them and then .comb('#').elems ?

[14:51] *** cpan-raku left
[14:52] *** cpan-raku joined
[14:52] *** cpan-raku left
[14:52] *** cpan-raku joined
[14:52] *** orinthe left
[14:52] *** orinthe4 is now known as orinthe

[14:55] <notandinus> lizmat: thanks, direct .comb('#).elems also works fine

[14:55] *** hal99999 left
[14:55] <notandinus> m: my @a = (1, 3), (1, 2); say @a.comb(1).elems;

[14:55] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «7␤»

[14:55] <tadzik> huh

[14:55] <notandinus> m: my @a = (1, 3), (1, 2); say @a.comb(1)

[14:55] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «(1   3   1   2)␤»

[14:56] <notandinus> hmm

[14:56] <notandinus> maybe it works fine with strings

[14:56] <lizmat> notandinus: yeah, but that may actually get a warning in the future  :)

[14:56] <notandinus> m: my @a = ('#', 'l'), ('#'); say @a.comb('#').elems;

[14:56] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «2␤»

[14:56] <lizmat> see: https://github.com/rakudo/rakudo/issues/4098

[14:56] <notandinus> lizmat: i see, i'll join them before then

[14:56] <tadzik> what's it doing with ints?

[14:56] <tadzik> ah

[14:57] *** hal99999 joined
[14:57] <notandinus> yeah what is it doing with ints? is it treating 1 as true or something?

[14:57] <lizmat> it's stringifying  the ints before applying the .comb

[14:58] *** ggoebel left
[14:58] <notandinus> m: my @a = (1, 3), (1, 2); say @a.comb('1')

[14:58] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «(1 1)␤»

[14:59] <notandinus> i see

[15:00] <notandinus> what is RSC?

[15:00] <tyil> Raku Steering Council

[15:01] <notandinus> so it steers the way raku goes?

[15:02] <notandinus> i see,nvm

[15:03] <tyil> we discuss (and optionally vote) on things if the community can't reach concensus

[15:05] <notandinus> i see, thanks

[15:14] *** brtastic joined
[15:17] *** brtastic left
[15:18] *** brtastic joined
[15:32] <notandinus> is 7% time spent of GC fine?

[15:33] <notandinus> it says 1250 collections occured +  7 full collections

[15:35] <lizmat> that feels...  not very optimal

[15:35] <lizmat> but it all really depends

[15:41] *** parabolize joined
[15:43] <notandinus> if there is an array that i declare on every subroutine call, should i make it a global var so that the over head of creating the array doesnt slow down my program?

[15:43] <notandinus> the array is same for all function calls

[15:44] <notandinus> or is there another way to do this?

[15:44] <tyil> notandinus: there's always another way to do it :)

[15:44] <notandinus> maybe this causes high GC calls thing

[15:45] <notandinus> i see, how could i do it? global variables are bad right?

[15:45] <tyil> I generally avoid them, yes

[15:45] <tyil> can you show your code?

[15:46] <tadzik> a state variable may help you

[15:46] <tadzik> those are probably smart enough to only be allocated once, for obvious reasons :) Though it probably wouldn't be a state per se in your case

[15:46] <notandinus> here: it's AoC day-11 part 1, i'll add part 2 code later on

[15:46] <notandinus> https://paste.debian.net/hidden/d086afa3/

[15:47] <notandinus> i see, i'll checkout state thing

[15:47] <tyil> I presume you're talking about my @directions?

[15:47] <notandinus> tyil: right

[15:48] <notandinus> can that be causing high GC calls?

[15:48] <tyil> yeah, iirc it's just making it `state @directions` to use a state variable instead, alternatively you can declare my @directions outside of the sub, and pass it as an argument

[15:48] <tyil> notandinus: I don't know the core well enough to make a statement on whether it'll improve the GC situation

[15:49] <lizmat> if the @directions array is lexically visiible for the sub, you don't need to pass it as an argument

[15:50] <notandinus> i see, thanks, i'll profile it again & see if there's any improvements

[15:50] <tyil> lizmat: that would require it being a global variable here, right?

[15:50] <lizmat> m: my @foo = ^10; sub a($value) { @foo.push($value) }; a 42; dd @foo

[15:50] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «Array @foo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 42]␤»

[15:50] <notandinus> oh i see, thats nice

[15:51] <lizmat> I would consider an "our" variable a global one, as it would be accessible from other scopes by name

[15:51] <notandinus> but i'm writing the code under sub MAIN, does that change anything?

[15:51] <lizmat> the above @foo is just a lexical at the "global" level if you will

[15:52] <lizmat> but it could well be within another scope, as long as the sub lives inside that scope

[15:52] <tadzik> if you don't want it to really be global then there's a Perl 5 trick that could come in handy...

[15:52] <lizmat> m: { my @foo = ^10; sub a($value) { @foo.push($value) }; a 42; dd @foo }

[15:52] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «Array @foo = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 42]␤»

[15:52] <notandinus> red call frames = bad and green call frames = good right? talking about the profiler

[15:52] <lizmat> yeah, read means unoptimized

[15:52] <tadzik> m: { my @not-global; our sub foo { @not-global.gist.say } }; foo

[15:52] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    foo used at line 1␤␤»

[15:52] <tadzik> oh, that's not a thing anymore? :(

[15:52] <notandinus> https://ttm.sh/dCU.png and what is Scalar and BootHash here?

[15:53] <lizmat> BOOThashes are the implicit *%_ that method calls have, usually

[15:53] <lizmat> the Scalar allocations are just that: you seem to create a lot of variables

[15:54] <lizmat> or elements in an array or hash :-)

[15:54] <notandinus> i see, yeah i change it a lot of times, does that count too?

[15:54] <notandinus> changing hash would be faster than changing array right?

[15:55] <notandinus> https://ttm.sh/dCl.png

[15:55] <lizmat> well, changing the value of an element in a hash requires a hash lookup

[15:55] <lizmat> which is inherently more expensive than indexing into an array

[15:55] <tadzik> indexing arrays may be one of the only things faster than indexing hashes ;)

[15:55] <notandinus> i clicked on Scalar view allocations and it shows this ^, i'm not using any push statement 

[15:56] <notandinus> i see, 

[15:56] <lizmat> hmmm... odd... Array.push should optimize

[15:58] <notandinus> is that push interal raku thing? because i'm not doing any pushing

[15:58] <lizmat> ah?

[15:58] <tadzik> you are growing your @changed array by adding things to it, which presumably does pushes under the hood

[15:58] <lizmat> guess I do need to look at your code  :)

[15:58] <tadzik> I wonder if cloning it first and then editing it later would perform better

[15:58] <notandinus> tyil: the state thing made the whole thing faster

[15:59] <notandinus> tadzik: i'll test that

[15:59] <notandinus> The profiled code ran for 410946.37ms. Of this, 36202.65ms were spent on garbage collection (that's 8.81%). 

[15:59] <tadzik> though it's probably not a continous blob in memory, so it may turn out similar

[15:59] <notandinus> ^ state thing

[15:59] <notandinus> The profiled code ran for 600864.29ms. Of this, 47310.08ms were spent on garbage collection (that's 7.87%). 

[15:59] <notandinus> without state thing ^

[15:59] <tadzik> oh wow, it's taking its sweet time, innit

[16:00] <notandinus> GC went from 1248 to 1220

[16:00] <lizmat> notandinus: my Int ($x-max, $y-max) = (@seats[0].end, @seats.end);   looks like dead code to me ?

[16:00] <notandinus> lizmat: ah dead as in i should move it out of the loop right?

[16:01] <notandinus> makes sense

[16:01] <lizmat> you're setting $x-max and $y-max but not using it ?

[16:02] <notandinus> i'm using it in line 15 and 18

[16:02] <lizmat> I meant inside of adjecent-occupied sub

[16:03] <notandinus> oh right that is dead for now, i think i added it for part 2

[16:04] <lizmat> also: I would separate the x and Y directions into separate "global" arrays

[16:04] <lizmat> actually, you know the size of the matrix, right ?

[16:04] <notandinus> yeah, it's fixed

[16:05] <notandinus> also, i just put it outside the subs to make it global right? 

[16:05] <notandinus> i did tha

[16:05] <lizmat> yeah

[16:05] <lizmat> you could actually think of using a 1 dim array for this

[16:06] <notandinus> also just by doing the 'state' thing number of red frame calls decreased by half

[16:06] <notandinus> lizmat: i see, i'lll checkout dim arrays

[16:06] <lizmat> then the check for adjacentness would be a single integer value

[16:07] <lizmat> and if you'd make the array allow for an empty slot at each side of the "line"

[16:07] <lizmat> you wouldn't even need to test boundaries

[16:08] *** brtastic left
[16:09] <notandinus> hmm i searched for dim array in docs, didn't find it, can you link to what it is?

[16:09] *** brtastic joined
[16:09] <tadzik> I think lizmat means a one dimensional array: (1, 2, 3, 4, 5, 6) rather than ((1, 2, 3), (4, 5, 6))

[16:10] <tadzik> but then you need to calculate what your offsets need to be depending on the number of elements in each row

[16:11] <notandinus> ah i see, yeah ^

[16:11] <lizmat> yeah, but they'd just depend on the dimensions 

[16:11] <notandinus> is there a way to get it 2 by 2?

[16:11] <tadzik> 2 by 2?

[16:11] <notandinus> lizmat: so you're saying i do it my @dimensions = ( -1, 0, -1, +1 ..) etc?

[16:12] <tadzik> the element directly above would be offset by $row-length rather than by (0, -1)

[16:12] <notandinus> tadzik: i mean if i can iterate over 2 elems of array instead of only 1 then i can make it a dim array

[16:12] <notandinus> ah

[16:12] <tadzik> (if we're thinking about the same thing)

[16:12] <notandinus> i get it, so you want me to make the whole thing dim array?

[16:13] <notandinus> so i just remove the .comb thing?

[16:13] <notandinus> makes sense

[16:14] <lizmat> he... reminds me of the days I was working on a DoD maze  :-)

[16:15] <notandinus> whats DoD maze?

[16:15] <notandinus> wow making it global array completed the thing in just 4m instead of 6min

[16:15] <notandinus> i'll profile it to see what changed

[16:16] <lizmat> basically a game where you walk around in a maze and encounter dragons and other monsters

[16:16] <notandinus> https://ttm.sh/dCo.png

[16:17] <m6locks> nethack ftw

[16:17] <notandinus> this is allocations thing when i changed it to state ^

[16:17] <notandinus> all red became green + yellow

[16:17] <lizmat> yup, and you got rid of the dead code in the sub >

[16:17] <lizmat> ?

[16:17] <notandinus>  lizmat: i see, nice

[16:17] <tadzik> notandinus: well, to be honest, I'm not sure if a 1-dim array (the 1 is crucial: all arrays have dimensions, your have two so far :)) would actually make it faster

[16:17] <tadzik> it could be an interesting experiment thoughu :)

[16:17] <notandinus> lizmat: dead code is there in this profile, next profile won't have dead code

[16:18] <notandinus> i profiled this before you told me of that

[16:18] <notandinus> tadzik:  i see, i'll test it

[16:20] <m6locks> 1 dim array of 8, the top 3, the one left, the one right, the bottom 3, then sum elements to see if >3

[16:21] <notandinus> yeah i'll do that after this profile completes, 

[16:22] *** orinthe left
[16:22] <notandinus> wait, does profiling slow down raku?

[16:22] <tadzik> oooh, I thought you meant the entire thing as a one-dim array

[16:22] <notandinus> without profiling it took 3 min, with it took 6min 

[16:23] <tadzik> I'm confused, I'll now shut up :D

[16:23] <tadzik> notandinus: yeah, it does have an overhead

[16:23] <notandinus> tadzik: yeah 1 dmin array of entire thing right?

[16:23] <tadzik> it needs to spend some time counting all these stats :)

[16:23] <notandinus> wait, i too understood that

[16:23] <tadzik> notandinus: I'm not sure what's the idea anymore :D

[16:23] <notandinus> m6locks: you mean 1 dmin array of the whole thing right?

[16:23] <tony-o> .tell patrickb sent you an email

[16:23] <tellable6> tony-o, I'll pass your message to patrickb

[16:25] *** cpan-raku left
[16:25] *** cpan-raku joined
[16:25] *** cpan-raku left
[16:25] *** cpan-raku joined
[16:26] <m6locks> notandinus: yes, if the whole thing is the 3x3 square to be checked

[16:26] <notandinus> ok making @directions global made 1095 gc calls

[16:26] <notandinus> red calls increased by  a bit

[16:26] *** orinthe joined
[16:26] <notandinus> tadzik: see, it's the whole thing

[16:27] <notandinus> m6locks: yeah that

[16:27] <notandinus> however the overall frame calls decreased

[16:28] <notandinus> hmm and allocations decreased by lot

[16:28] <notandinus> i'll now implement 1 dim array thing

[16:31] *** ufobat_ left
[16:33] *** orinthe6 joined
[16:35] *** orinthe left
[16:35] *** orinthe6 is now known as orinthe

[16:36] *** kensanata joined
[16:47] *** jmerelo joined
[16:51] <notandinus> ok i finally implemented 1 dim thing

[16:52] <notandinus> here is the code: https://paste.debian.net/hidden/80478d0f/

[16:52] <notandinus> anything that should be changed on first glance?

[16:53] <notandinus> woah the code is lot faster, it completed in 1m 23s

[16:53] <tadzik> wow, nice :)

[16:53] <notandinus> i'm profiling it now

[16:53] <codesect`> is there a decent way to dwim in this code: 

[16:53] <codesect`> m: my @a[2;2] = (1,2;3,4); my @b[2;2] = (4,5;6,7); @a «+» @b # want [[5,7], [9,11]]

[16:53] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «Potential difficulties:␤    Useless use of «+» in sink context␤    at <tmp>:1␤    ------> 3= (1,2;3,4); my @b[2;2] = (4,5;6,7); @a 7⏏5«+» @b # want [[5,7], [9,11]]␤»

[16:53] <codesect`> m: my @a[2;2] = (1,2;3,4); my @b[2;2] = (4,5;6,7); say @a «+» @b # want [[5,7], [9,11]]

[16:53] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «Type check failed in binding to parameter '@dims'; expected Positional but got Any (Any)␤  in block <unit> at <tmp> line 1␤␤»

[16:54] <codesect`> that is, to use «+» or similar to add each element of shaped arrays 

[16:55] <tadzik> notandinus: I wonder if passing arrays to adjacent-occupied() like you do isn't making a copy of them each time: probably a shallow copy, but still. It could give you some wins if you pass it, um, differently, but my raku knowledge eludes me now and I don't know what to suggest you

[16:56] <tadzik> but from what I see, you only use @directions in adjacent-occupied(), not in MAIN(). So you could try making it global and using that global in the adjacent-occupied(), just to see if there'll be some savings

[16:56] <notandinus> tadzik: to compute @directions, i need $row-length which is bound to MAIN sub

[16:56] <tadzik> notandinus: oh, right

[16:56] <notandinus> should i make both global?

[16:57] <tadzik> well, you won't know the value until main runs :)

[16:57] <tadzik> that's a silly idea after all

[16:57] <notandinus> i see, yeah, can i make @directions global from whitin main sub?

[16:57] <tadzik> but I don't remember the name or the syntax for this "pass by reference" thing that I have in mind, for the lack of a better term

[16:57] <tadzik> well, you could define your own sub inside the main sub

[16:57] <notandinus> oh wait, or should i just put adjacent-thigng in main sub?

[16:57] <tadzik> and then it'll have access to its locals, yes

[16:58] <notandinus> hah i'll do that then

[16:58] <tadzik> not sure if it's worth it, but maybe worth trying :)

[16:58] <notandinus> red frames went down from 13106524 to 104217

[16:58] <tadzik> also, `@seats eqv @changed;` probably involves a lot of looping and checking: have you considered a `my Bool $changed = False` that you set to true if anything changes?

[16:59] <notandinus> GC was havled

[16:59] <notandinus> tadzik: i see, i'll implement that too

[16:59] <notandinus> should i make a post compiling all of this?

[16:59] *** maggotbrain left
[16:59] <tadzik> like a blog post? That would be quite interesting

[17:00] <notandinus> also is sharing profiler data safe? does it include sensitive information that i might now want to share?

[17:00] <tadzik> not unless you have passwords in your code, I think :P

[17:00] <tadzik> or sensitive file/directory names, possible

[17:01] <notandinus> i see, ok then i'll put the profiler output too, i'll now make those changes

[17:02] <tadzik> another potential GC saving, not sure how effective it'll be though: instead of copying the whole @seats immediately, build a list of changes, and then apply them all to the existing array. This could give you a win, but most likely only if the amount of changes per step is quite small, which will probably not be the case here

[17:04] <notandinus> inling the sub sped it up by a bit, not much

[17:05] <notandinus> i'll implement the checking now & then this thing you shared ^

[17:07] *** Altai-man joined
[17:08] <notandinus> tadzik: it would still make it little faster right? if instead of copying whole @seats, i just apply the changes

[17:08] <notandinus> surprisiingly there is not much change after changing 'eqv' to a Bool '$change' variable

[17:08] <notandinus> ^ i'm saying this by comparing `time' output

[17:08] <tadzik> notandinus: I guess so: although you'll still need to allocate space for the list of changes, which will also need a copy of all the coordinates to apply these changes to

[17:09] <tadzik> I guess eqv is smarter than I thought :)

[17:10] *** sena_kun left
[17:10] *** MasterDuke joined
[17:14] <notandinus> tadzik: i meant @changed will only contain the changes and i'll loop over it with it's index to apply the changes to @seats

[17:15] <notandinus> wouldn't that be abit faster because @changed will be smaller

[17:15] <notandinus> tadzik: maybe `time' is not able to mesaure that small change, i'll profile 'eqv' vs bool later

[17:16] <notandinus> also looks like there is some issue with the code, it contains ' ' in between

[17:16] <notandinus> i mean the arrays are seperated by ' ' 

[17:16] <tadzik> notandinus: depends on how much smaller it'd be :)

[17:17] <tadzik> if every cell changes, or almost every cell, it'll probably be a waste of time

[17:17] <notandinus> i see, yeah, how do i remove these stray ' ' that entered my @seats?

[17:17] <notandinus> it's repeating after every row

[17:17] <tadzik> did it? Or is it just how it's printed?

[17:17] <notandinus> yeah it did, i checked it with .raku

[17:18] <notandinus> tadzik: yeah also the seats change by large margins so i think it might not be much helpful

[17:19] <notandinus> ok i checked @inputs, doesn't have stray ' ', looks like .comb introduces them

[17:21] <notandinus> m: my @t = "hi", "b", "y"; my @l = @t.comb; say @l.raku;

[17:21] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «["h", "i", " ", "b", " ", "y"]␤»

[17:21] <notandinus> look ^^

[17:22] <notandinus> what is causing this?

[17:22] <notandinus> hmm wait or am i using the wrong fucntion?

[17:23] <notandinus> hmm .flat.comb too doesnt fix it, looks like it's comb's behaviour

[17:23] <notandinus> .join.comb should fix it

[17:23] <notandinus>  m: my @t = "hi", "b", "y"; my @l = @t.join.comb; say @l.raku;

[17:23] <camelia> rakudo-moar 9dbb52f9e: OUTPUT: «["h", "i", "b", "y"]␤»

[17:24] <notandinus> yeah

[17:28] <notandinus> oof the logic is wrong, i need to do some more checking

[17:31] <tobs> notandinus: comb is a stringy method. If you apply it to an array, that array will be stringified first, which adds spaces between the elements. That's why you saw the additional space earlier between "b" and "y".

[17:31] *** wamba joined
[17:34] *** orinthe6 joined
[17:35] *** orinthe left
[17:35] *** orinthe6 is now known as orinthe

[17:36] *** domidumont left
[18:02] *** melezhik joined
[18:05] *** guifa2 joined
[18:09] <notandinus> tobs: makes sense, thanks

[18:15] *** melezhik left
[18:16] <notandinus> tadzik: eqv is very smart, it works better than recording change in Bool

[18:16] <notandinus> i compared the profiler outputs

[18:23] <notandinus> oof but this 1 dim array is too hard, it prints correct output for sample but fails on actual input

[18:23] <notandinus> i think i'll go back to arrays of arrays later, night 0/

[18:24] * notandinus going awa

[18:24] *** wamba left
[18:26] *** maggotbrain joined
[18:27] *** maggotbrain left
[18:27] <tadzik> notandinus: hah, interesting

[18:27] <tadzik> 'night!

[18:39] *** wamba joined
[18:51] *** webstrand joined
[18:54] *** jmerelo left
[19:04] *** aindilis` joined
[19:04] *** sjm left
[19:05] *** aindilis left
[19:18] *** sjm joined
[19:46] *** sjm_uk left
[20:06] *** aindilis` left
[20:07] *** aindilis joined
[20:39] *** Kaiepi left
[20:39] *** Kaiepi joined
[20:47] <coldpress> notandinus: I can't share my AoC solution now that I realized most of my performance loss is because I did too many unnecessary computations

[20:47] <coldpress> it's my fault for writing the code wrongly, not the languages fault of 1D/2D arrays

[20:48] <coldpress> but I'll show you once I fixed it

[20:49] *** bbkr joined
[20:53] <bbkr> Hi. Can someone make Advent Calendar main column wider? Currently 2/3 of screen space is wasted and also some code sections do not fit in narrow column (must be scrolled horizontally). Thanks!

[21:04] *** kensanata left
[21:08] *** sena_kun joined
[21:09] *** Altai-man left
[21:10] <tadzik> bbkr: it gets a lot better in firefox's reader mode, fwiw :)

[21:41] *** RaycatWhoDat joined
[21:43] <RaycatWhoDat> Howdy. Do you think it's possible to learn more than 3 programming languages to proficiency? 

[21:45] <guifa2> If people can learn 3+ human languages to proficiency, I think three PLs isn't too much :-) 

[21:45] <RaycatWhoDat> that's fair

[21:46] <Grinnz> as with most things, it depends how much effort you want to expend and how intuitive you find each language

[21:46] <guifa2> Of course, the question of defining proficiency comes up too.  I can read C and C++ code, and can muck with them, but I wouldn't start my next big project in them, just like I'm not going to write a novel in Mirandese, though I can read it just fine lol

[21:51] *** MasterDuke left
[21:52] *** hal99999 left
[21:53] <RaycatWhoDat> Hmm

[21:56] *** rindolf left
[21:59] *** wamba left
[21:59] *** wamba joined
[22:10] *** sena_kun left
[22:21] *** asymptotically left
[22:26] *** patrickb left
[22:26] *** Geth left
[22:26] *** Geth joined
[22:29] *** wamba left
[22:39] *** brtastic left
[22:40] *** webstrand left
[22:43] *** hal99999 joined
[23:02] *** hal99999 left
[23:11] *** ape666 joined
[23:14] *** ape666 left
[23:23] *** ape666 joined
[23:27] *** rir left
[23:31] *** stoned75 left
[23:45] <RaycatWhoDat> What language do people normally use for NativeCall?

