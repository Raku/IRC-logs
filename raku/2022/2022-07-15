[00:06] *** reportable6 left
[00:09] *** reportable6 joined
[01:09] *** committable6 left
[01:09] *** reportable6 left
[01:09] *** bloatable6 left
[01:09] *** statisfiable6 left
[01:09] *** nativecallable6 left
[01:09] *** notable6 left
[01:09] *** unicodable6 left
[01:09] *** bisectable6 left
[01:09] *** benchable6 left
[01:09] *** greppable6 left
[01:09] *** quotable6 left
[01:09] *** linkable6 left
[01:09] *** releasable6 left
[01:09] *** coverable6 left
[01:09] *** tellable6 left
[01:09] *** sourceable6 left
[01:09] *** shareable6 left
[01:09] *** evalable6 left
[01:09] *** notable6 joined
[01:09] *** bisectable6 joined
[01:09] *** statisfiable6 joined
[01:10] *** sourceable6 joined
[01:10] *** quotable6 joined
[01:10] *** evalable6 joined
[01:10] *** tellable6 joined
[01:10] *** greppable6 joined
[01:10] *** reportable6 joined
[01:10] *** nativecallable6 joined
[01:11] *** bloatable6 joined
[01:11] *** benchable6 joined
[01:11] *** unicodable6 joined
[01:12] *** shareable6 joined
[01:12] *** coverable6 joined
[01:12] *** linkable6 joined
[01:12] *** releasable6 joined
[01:12] *** committable6 joined
[01:34] *** swaggboi left
[02:07] *** frost joined
[03:07] *** bisectable6 left
[03:07] *** tellable6 left
[03:07] *** nativecallable6 left
[03:07] *** shareable6 left
[03:07] *** coverable6 left
[03:07] *** linkable6 left
[03:07] *** sourceable6 left
[03:07] *** quotable6 left
[03:07] *** unicodable6 left
[03:07] *** notable6 left
[03:07] *** bloatable6 left
[03:07] *** benchable6 left
[03:07] *** greppable6 left
[03:07] *** evalable6 left
[03:07] *** statisfiable6 left
[03:07] *** reportable6 left
[03:07] *** committable6 left
[03:07] *** releasable6 left
[03:07] *** bisectable6 joined
[03:07] *** unicodable6 joined
[03:07] *** reportable6 joined
[03:08] *** quotable6 joined
[03:08] *** tellable6 joined
[03:08] *** sourceable6 joined
[03:08] *** shareable6 joined
[03:08] *** evalable6 joined
[03:08] *** benchable6 joined
[03:08] *** greppable6 joined
[03:08] *** committable6 joined
[03:08] *** nativecallable6 joined
[03:08] *** linkable6 joined
[03:09] *** statisfiable6 joined
[03:09] *** notable6 joined
[03:09] *** coverable6 joined
[03:10] *** releasable6 joined
[03:10] *** bloatable6 joined
[04:10] *** unicodable6 left
[04:10] *** coverable6 left
[04:10] *** committable6 left
[04:10] *** quotable6 left
[04:10] *** linkable6 left
[04:10] *** benchable6 left
[04:10] *** greppable6 left
[04:10] *** bloatable6 left
[04:10] *** shareable6 left
[04:10] *** evalable6 left
[04:10] *** nativecallable6 left
[04:10] *** sourceable6 left
[04:10] *** releasable6 left
[04:10] *** statisfiable6 left
[04:10] *** reportable6 left
[04:10] *** tellable6 left
[04:10] *** notable6 left
[04:10] *** bisectable6 left
[04:10] *** evalable6 joined
[04:10] *** bloatable6 joined
[04:10] *** unicodable6 joined
[04:10] *** coverable6 joined
[04:10] *** quotable6 joined
[04:11] *** bisectable6 joined
[04:11] *** sourceable6 joined
[04:11] *** nativecallable6 joined
[04:12] *** benchable6 joined
[04:12] *** tellable6 joined
[04:12] *** statisfiable6 joined
[04:13] *** releasable6 joined
[04:13] *** greppable6 joined
[04:13] *** linkable6 joined
[04:13] *** shareable6 joined
[04:13] *** reportable6 joined
[04:13] *** committable6 joined
[04:13] *** notable6 joined
[04:37] <guifa> You know what would actually make slangs much easier to write?

[04:37] <guifa> private tokens

[04:39] <guifa> oh wait, private methods compose (I feel like they shouldn't?)

[05:01] <guifa> I can my scope it, but stubbing doesn't really work with tokens 

[05:13] *** linkable6 left
[05:13] *** evalable6 left
[05:14] *** linkable6 joined
[05:15] *** evalable6 joined
[06:07] *** reportable6 left
[06:08] *** reportable6 joined
[07:01] <moritz> private methods (in roles, I assume) must compose; you never call anything on a role, but on a role applied to a class. If they didn't compose, you'd never be able to call them

[07:04] *** Sgeo left
[08:04] *** evalable6 left
[08:04] *** linkable6 left
[08:05] *** evalable6 joined
[08:06] *** linkable6 joined
[08:07] *** sena_kun joined
[08:22] *** Sankalp left
[08:22] *** Sankalp joined
[09:29] *** sena_kun left
[09:30] *** linkable6 left
[09:31] *** linkable6 joined
[09:35] *** jaguart joined
[09:37] *** sena_kun joined
[09:37] *** sena_kun left
[10:15] *** linkable6 left
[10:16] *** linkable6 joined
[10:52] *** kaskal left
[10:58] *** kaskal joined
[11:34] *** kaskal left
[11:45] *** Sankalp left
[11:46] *** Sankalp joined
[11:47] *** kaskal joined
[11:54] <guifa_> moritz yeah, that makes sense.  I'm just annoyed at having to namespace my tokens in slangs, that's all :-)

[12:07] *** reportable6 left
[12:08] *** reportable6 joined
[12:18] *** kaskal left
[12:22] *** kaskal joined
[12:30] *** zmoment_ left
[13:07] *** Colere left
[13:08] *** Colere joined
[13:10] *** Furor joined
[13:13] *** Colere left
[13:19] *** frost left
[13:31] *** Furor is now known as Colere

[14:31] *** evalable6 left
[14:34] *** evalable6 joined
[15:05] *** Sgeo joined
[15:12] *** Guest48 joined
[15:13] *** jaguart left
[15:36] <SmokeMachine> lizmat: yes, vim accepts `-q`... https://github.com/lizmat/Edit-Files/pull/1

[15:38] <lizmat> s/vim/nvim/ I assume  :-)

[15:38] <SmokeMachine> yes :)

[15:51] *** Guest48 left
[16:03] *** oliphant joined
[16:05] <oliphant> Hello whats an assertion way in Raku? like the assert or static_assert in some other languagse

[16:10] *** FehmiD joined
[16:11] *** saint- joined
[16:11] *** FehmiD left
[16:12] <discord-raku-bot> <Nemokosch> are you writing test cases?

[16:13] <oliphant> no writing a code where some place asserted to be unreachable

[16:14] <oliphant> or some mathematical logic satisfied

[16:19] <moritz> die "this should never be reached because of $reason"

[16:19] <moritz> there's actually a built-in always-fail assertion, prefix:<!!!!>

[16:19] <moritz> m: !!! "foo"

[16:19] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«fooâ¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:21] <oliphant> So did it fail?

[16:21] <moritz> yes

[16:21] <moritz> m: !!! "foo"; say "never reached"

[16:21] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«fooâ¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:22] <oliphant> oh

[16:22] <moritz> to answer the original question, raku has a lot of constructs that assertions are often used for

[16:22] *** Tirifto left
[16:22] <moritz> these include: subtypes with code checks, PRE and POST conditions for routines, and code checks in signatures

[16:23] <moritz> m: subset Positive of Int where { $_ > 0 }; my Positive $x = 42; say "alive"; $x = -4; say "no more alive"

[16:23] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«aliveâ¤Type check failed in assignment to $x; expected Positive but got Int (-4)â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:23] <moritz> m: sub factors(Int $x where !.is-prime) { 42 }; factors(13)

[16:23] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Constraint type check failed in binding to parameter '$x'; expected anonymous constraint to be met but got Int (13)â¤  in sub factors at <tmp> line 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:24] <moritz> m: sub increment(Numeric $x) { POST $_ > $x; return $x +1 }; increment 4

[16:24] <camelia> rakudo-moar 7ec4b10d7: ( no output )

[16:24] <moritz> m: sub increment(Numeric $x) { POST $_ > $x; return $x  - 1 }; increment 4

[16:24] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Postcondition '$_ > $x' failedâ¤  in sub increment at <tmp> line 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:25] <moritz> that said, I don't think there's an explicit assert

[16:27] <lizmat> m: sub assert($condition, $message) { die $message unless $condition }; assert 42 < 666, 'foo';  assert 42 > 666, 'bar'

[16:27] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«barâ¤  in sub assert at <tmp> line 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:27] *** Tirifto joined
[16:27] <lizmat> oliphant: ^^ something like that ?

[16:27] <moritz> it's easy to make one as lizmat demonstrated, though it does evaluate the message even if the condition is true

[16:28] <moritz> once RakuAST lands, it'll probably be easy to make a higher-quality one

[16:28] <oliphant> wow POST

[16:28] <oliphant> Whats $_ in POSt being?

[16:28] <oliphant> Im familiar with $_

[16:28] <oliphant> Asking its topic there

[16:29] <lizmat> m: { POST say "POST: $_"; 42 }

[16:29] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«WARNINGS for <tmp>:â¤POST: 42â¤Useless use of constant integer 42 in sink context (line 1)â¤Â»

[16:29] <moritz> oliphant: the return value of the routine

[16:29] <lizmat> m: my $b := { POST say "POST: $_"; 42 }; $b()

[16:29] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«POST: 42â¤Â»

[16:29] <lizmat> m: sub foo() { POST say "POST: $_"; 42 }; foo

[16:29] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«POST: 42â¤Â»

[16:30] <oliphant> thank you Raku persons

[16:30] <oliphant> My other query is difference of fail and die

[16:30] <lizmat> you're welcome :-)

[16:30] <oliphant> Above used die for example

[16:31] <oliphant> But why not fail?

[16:31] <oliphant> Its not cathchable?

[16:31] <oliphant> (the die)

[16:32] <moritz> fail is a bit softer than die

[16:32] <oliphant> When should i fail insteed

[16:32] <moritz> fail returns an exception wrapped in a timebomb, that explodes if you use it like a regular value, but if you check it for .defined first, it's good

[16:32] <lizmat> m: sub foo() { fail "bar" }; my $a = foo; say "still alive"; my $b = $a

[16:32] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«still aliveâ¤Â»

[16:33] <lizmat> m: sub foo() { fail "bar" }; my $a = foo; say "still alive"; my $b = $a + 2

[16:33] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«still aliveâ¤barâ¤  in sub foo at <tmp> line 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:33] <moritz> this enables routines that both throw an exception if nobody checks it, but doesn't need exceptions if the user prefers it that way. More magical, supposedly better for highly parallel computations

[16:34] <moritz> it's a bit too magical for my tastes, so I go straight for die(), usually.

[16:34] <moritz> YMMV

[16:35] <oliphant> oo timebomb ğŸ˜‚ i understand the diff

[16:36] <oliphant> i need to see more code of people where to use where not i say

[16:36] <oliphant> thanking again

[16:38] *** oliphant left
[16:38] <moritz> my pleasure

[17:38] *** linkable6 left
[17:38] *** evalable6 left
[17:38] *** linkable6 joined
[17:41] *** evalable6 joined
[17:46] *** kaskal left
[17:51] *** sena_kun joined
[17:52] *** kaskal joined
[18:07] *** reportable6 left
[18:09] *** reportable6 joined
[18:10] <discord-raku-bot> <Nemokosch> what is needed for a new version of a module to be published?

[18:10] <discord-raku-bot> <Nemokosch> I mean, my PR to Terminal::Getpass got merged - is something additional needed so that the new version gets available?

[18:14] <moritz> the maintainer needs to make a release and upload it to whatever ecosystem is used

[18:15] <discord-raku-bot> <Nemokosch> ğŸ‘

[18:39] *** Guest48 joined
[18:39] *** Guest48 left
[18:53] *** Xliff joined
[18:53] <Xliff> \o

[18:53] <Xliff> m: sub a (*@a) { @a.say }; my &b = &a.assuming(1, 2); &b.is-wrapped.say;

[18:53] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Falseâ¤Â»

[18:53] <Xliff> m: sub a (*@a) { @a.say }; my &b = &a.assuming(1, 2); &b.is-wrapped.say; &b;

[18:53] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«WARNINGS for <tmp>:â¤Falseâ¤Useless use of &b in sink context (line 1)â¤Â»

[18:53] <Xliff> m: sub a (*@a) { @a.say }; my &b = &a.assuming(1, 2); &b.is-wrapped.say; &b.say;

[18:53] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Falseâ¤&__PRIMED_ANONâ¤Â»

[18:54] <Xliff> m: sub a (*@a) { @a.say }; my &b = &a.assuming(1, 2); &b.is-wrapped.say; &b().say;

[18:54] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Falseâ¤[1 2]â¤Trueâ¤Â»

[18:54] <Xliff> m: sub a (*@a) { @a.say }; my &b = &a.assuming(1, 2); &b.is-wrapped.say; &b();

[18:54] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Falseâ¤[1 2]â¤Â»

[18:54] <Xliff> m: sub a (*@a) { @a.say }; my &b = &a.assuming(1, 2); &b.is-wrapped.say; &b(); &b.name.say

[18:54] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Falseâ¤[1 2]â¤__PRIMED_ANONâ¤Â»

[18:55] <Xliff> OK, If I have &b as above, is there any way to get back the reference to the original callable?

[19:24] *** guifa left
[19:45] *** guifa joined
[19:45] *** guifa left
[19:50] *** m_athias left
[19:50] *** nine left
[19:50] *** nine joined
[19:51] *** m_athias joined
[19:52] *** Guest23 joined
[19:52] *** Guest23 left
[20:09] *** sena_kun left
[20:10] *** sena_kun joined
[21:04] *** melezhik joined
[21:04] <melezhik> o/

[21:04] <melezhik> What's up

[21:10] <discord-raku-bot> <Nemokosch> hello

[21:10] <discord-raku-bot> <Nemokosch> as time passes, the more urgent it seems for me to document returned containers better

[21:10] *** Nemokosch joined
[21:10] <Nemokosch> let me illustrate

[21:10] *** melezhik left
[21:11] <Nemokosch> m: my @flat-array = <the name is bond bon bond>; @flat-array.batch(2)[1;1] = 'short'; dd @flat-array;

[21:11] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Array @flat-array = ["the", "name", "is", "short", "bon", "bond"]â¤Â»

[21:11] *** Nemokosch left
[21:12] <discord-raku-bot> <Nemokosch> this is unbelievably cool - but how should one expect it?

[21:20] *** habere-et-disper joined
[21:20] <habere-et-disper> How do you take the odd or even elements of a list?

[21:20] <habere-et-disper> m: say (10,11,12,13,14,15,16,17,18,19,20).grep( *.keys %% 2 )

[21:20] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«()â¤Â»

[21:22] <lizmat> m: say (10,11,12,13,14,15,16,17,18,19,20).grep({ $++ %% 2 })

[21:22] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«(10 12 14 16 18 20)â¤Â»

[21:22] <lizmat> m: say (10,11,12,13,14,15,16,17,18,19,20).grep({ ++$ %% 2 })

[21:22] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«(11 13 15 17 19)â¤Â»

[21:22] <discord-raku-bot> <p6steve> m: say (10,11,12,13,14,15,16,17,18,19,20).grep( {$_ %% 2} )

[21:22] <discord-raku-bot> <Nemokosch> oh for some reason I thought indices

[21:22] <discord-raku-bot> <Nemokosch> liz also thought indices, it's fine then ğŸ˜„

[21:22] <lizmat> .oO( the magic of the nameless state variable

[21:22] <lizmat> )

[21:23] <discord-raku-bot> <Nemokosch> the nameless state variable bit me this week

[21:23] <lizmat> habere-et-disper: I interpreted it as odd or even *elements*, not the values

[21:23] <discord-raku-bot> <Nemokosch> don't use it with recursive functions...

[21:23] <lizmat> yeah

[21:23] <lizmat> true

[21:24] <lizmat> m: say (10,11,12,13,14,15,16,17,18,19,20).grep(:2nd)   # wonder if that would make sense

[21:24] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Cannot resolve caller grep(List:D: :nd(Int)); none of these signatures matches:â¤    ($: Bool:D $t, *%_)â¤    ($: Mu $t, *%_)â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[21:25] <discord-raku-bot> <Nemokosch> categorize can also work, to get both

[21:25] *** Nemokosch joined
[21:26] <Nemokosch> (10..20).categorize({ $++ % 2 })

[21:26] <Nemokosch> oops

[21:26] <Nemokosch> m: dd (10..20).categorize({ $++ % 2 })

[21:26] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«(my Any %{Mu} = 0 => $[10, 12, 14, 16, 18, 20], 1 => $[11, 13, 15, 17, 19])â¤Â»

[21:27] <discord-raku-bot> <p6steve> (10..20).classify({$_ %% 2})

[21:27] <discord-raku-bot> <p6steve> {False => [11 13 15 17 19], True => [10 12 14 16 18 20]}

[21:27] <habere-et-disper> lizmat Thank you -- I did want the indices! :)

[21:28] <discord-raku-bot> <Nemokosch> right, categorize is the one that can overlap, classify is the one that cannot

[21:29] <discord-raku-bot> <p6steve> (10..20).keys.classify({$_ %% 2})

[21:29] <discord-raku-bot> <p6steve> {False => [1 3 5 7 9], True => [0 2 4 6 8 10]}

[21:30] <Nemokosch> of course rotor can also be useful to a certain degree

[21:30] <discord-raku-bot> <p6steve> (10..20).keys.categorize(* %% 2)

[21:31] <Nemokosch> m: dd (10..20).rotor(1 => 1)

[21:31] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«((10,), (12,), (14,), (16,), (18,), (20,)).Seqâ¤Â»

[21:31] <discord-raku-bot> <p6steve> {False => [1 3 5 7 9], True => [0 2 4 6 8 10]}

[21:31] <Nemokosch> rotor emits one-element lists though

[21:32] <lizmat> and nowadays, there's also snip!

[21:32] <Nemokosch> what is that?

[21:32] <lizmat> m: dd (^10).snip( * < 5 )

[21:32] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«No such method 'snip' for invocant of type 'Range'.  Did you mean anyâ¤of these: 'Slip', 'skip', 'flip', 'sin'?â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[21:32] <discord-raku-bot> <p6steve> huh?

[21:32] <lizmat> meh

[21:33] <lizmat> m: dd (0,1,2,3,4,5,6,7,8,9).snip( * < 5 )

[21:33] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«No such method 'snip' for invocant of type 'List'.  Did you mean any ofâ¤these: 'Slip', 'skip', 'flip', 'sin'?â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[21:33] <lizmat> hmmm

[21:33] <discord-raku-bot> <Nemokosch> what version?

[21:33] <discord-raku-bot> <Nemokosch> I also don't have it with 2022.04

[21:34] <lizmat> m: dd Compiler.new.version

[21:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«v2022.06.55.g.7.ec.4.b.10.d.7â¤Â»

[21:34] <SmokeMachine> m: my &incr := * + 1; 41 ==> incr() ==> say() #`(this works...); [==>] 41, incr(), say() # should this work?

[21:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Potential difficulties:â¤    Useless use of [==>] in sink contextâ¤    at <tmp>:1â¤    ------> ==> incr() ==> say() #`(this works...); â[==>] 41, incr(), say() # should this woâ¤42â¤Cannot resolve caller METAOP_REDUCE_LIST(VMNull); none â€¦Â»

[21:34] <SmokeMachine> m: my &incr := * + 1; 41 ==> incr() ==> say() # this works...

[21:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«42â¤Â»

[21:34] <lizmat> aah...

[21:34] <SmokeMachine> m: my &incr := * + 1;  [==>] 41, incr(), say() # should this work?

[21:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Potential difficulties:â¤    Useless use of [==>] in sink contextâ¤    at <tmp>:1â¤    ------> my &incr := * + 1;  â[==>] 41, incr(), say() # should this woâ¤Cannot resolve caller METAOP_REDUCE_LIST(VMNull); none of these signatures matchâ€¦Â»

[21:34] <lizmat> m: use v6.e; dd (^10).snip( * < 5 )

[21:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«===SORRY!=== Error while compiling <tmp>â¤Raku v6.e requires PREVIEW modifierâ¤at <tmp>:1â¤------> use v6.eâ; dd (^10).snip( * < 5 )â¤Â»

[21:34] <lizmat> m: use v6.*; dd (^10).snip( * < 5 )

[21:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«((0, 1, 2, 3, 4), (5, 6, 7, 8, 9)).Seqâ¤Â»

[21:35] <lizmat> *phew*   only on 6.e  :-)

[21:35] <discord-raku-bot> <p6steve> oh there was a recent SO on that - cool

[21:37] <discord-raku-bot> <p6steve> https://stackoverflow.com/questions/72809469/in-raku-how-does-one-write-the-equivalent-of-haskells-span-function

[21:37] <discord-raku-bot> <p6steve> is snip === nsap

[21:37] <discord-raku-bot> <p6steve> /snip/span/

[21:37] <discord-raku-bot> <p6steve> btw why not call it span?

[21:38] <habere-et-disper> .grep(:2nd)Â  is rather css like

[21:38] <lizmat> m: use v6.*; dd (^20).snip( * < 5, * < 10 )   # p6steve: can have more than one condition, and span cannot

[21:38] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«((0, 1, 2, 3, 4), (5, 6, 7, 8, 9), (10, 11, 12, 13, 14, 15, 16, 17, 18, 19)).Seqâ¤Â»

[21:39] <discord-raku-bot> <Nemokosch> also, any idea how to be more explicit about the containers? Namely that functions usually treat their arguments as raw

[21:39] *** sena_kun left
[21:41] <lizmat> afk&

[21:41] <discord-raku-bot> <Nemokosch> actually this also means that some things _only work_ with @, which is a whole new perspective for me

[21:43] <discord-raku-bot> <p6steve> lizmat: tx!

[21:44] <habere-et-disper> Is there a list of deprecations? I want to ask the REPL if possible.

[21:45] *** Nemokosch left
[21:45] <discord-raku-bot> <Nemokosch> the REPL about deprecations?

[21:45] *** Nemokosch joined
[21:47] <gfldex> habere-et-disper: There is no complete list but since they are introduced by a trait, you could wire Rakudo up to show them all.

[21:56] <habere-et-disper> gfldex Thank you. I don't know how to do this but will investigate.

[22:02] *** habere-et-disper left
[22:03] *** Nemokosch left
[22:03] <SmokeMachine> m: use v6.*; dd (^20).snip( |^Inf .map: { { $^a * 5 > $^B }  } )

[22:03] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«===SORRY!=== Error while compiling <tmp>â¤Unsupported use of $^B variableâ¤at <tmp>:1â¤------> ^20).snip( |^Inf .map: { { $^a * 5 > $^Bâ }  } )â¤Â»

[22:06] *** Tirifto left
[22:06] <SmokeMachine> m: use v6.*; dd (^20).snip( |^Inf .map: { { $^a * 5 > $^b }  } )

[22:06] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«Too few positionals passed; expected 2 arguments but got 0â¤  in block  at <tmp> line 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[22:07] <SmokeMachine> m: use v6.*; dd (^20).snip( |^Inf .map: { * * 5 > * } )

[22:07] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«===SORRY!=== Error while compiling <tmp>â¤Malformed double closure; WhateverCode is already a closure without curlies, so either remove the curlies or use valid parameter syntax instead of *â¤at <tmp>:1â¤------> dd (^20).snip( |^Inf .map: {â€¦Â»

[22:07] <SmokeMachine> m: use v6.*; dd (^20).snip( |^Inf .map: { (* * 5 > *) } )

[22:07] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«MoarVM panic: Memory allocation failed; could not allocate 67462656 bytesâ¤Â»

[22:23] *** euandreh joined
[22:24] *** Tirifto joined
[22:46] *** Tirifto left
[22:51] *** discord-raku-bot left
[22:51] *** discord-raku-bot joined
[22:55] *** discord-raku-bot left
[22:55] *** discord-raku-bot joined
[23:00] *** discord-raku-bot left
[23:00] *** discord-raku-bot joined
[23:00] *** Tirifto joined
[23:02] <lizmat> SmokeMachine:hmmm.. interesting.. :-)

[23:02] <lizmat> care to make an issue for that ?

[23:04] *** discord-raku-bot left
[23:04] *** discord-raku-bot joined
[23:05] <El_Che> hi lizmat 

[23:06] *** Tirifto left
[23:07] <lizmat> El_Che: hi, but going afk for the night &

[23:13] <El_Che> :)

[23:40] *** gugod left
