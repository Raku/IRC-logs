[00:01] *** morte_ left
[00:06] *** reportable6 left
[00:09] *** reportable6 joined
[01:07] *** irc_user left
[01:19] *** squashable6 left
[01:21] *** squashable6 joined
[01:28] *** Guest10 joined
[01:29] *** Guest10 left
[02:05] *** Guest10 joined
[02:07] *** Guest10 left
[03:07] *** evalable6 left
[03:07] *** shareable6 left
[03:07] *** linkable6 left
[03:07] *** bloatable6 left
[03:07] *** notable6 left
[03:07] *** unicodable6 left
[03:07] *** sourceable6 left
[03:07] *** bisectable6 left
[03:07] *** releasable6 left
[03:07] *** greppable6 left
[03:07] *** coverable6 left
[03:07] *** committable6 left
[03:07] *** benchable6 left
[03:07] *** reportable6 left
[03:07] *** squashable6 left
[03:07] *** nativecallable6 left
[03:07] *** quotable6 left
[03:07] *** tellable6 left
[03:07] *** statisfiable6 left
[03:07] *** reportable6 joined
[03:07] *** tellable6 joined
[03:07] *** linkable6 joined
[03:07] *** sourceable6 joined
[03:07] *** coverable6 joined
[03:07] *** notable6 joined
[03:07] *** evalable6 joined
[03:08] *** releasable6 joined
[03:08] *** bloatable6 joined
[03:08] *** quotable6 joined
[03:09] *** statisfiable6 joined
[03:09] *** greppable6 joined
[03:09] *** squashable6 joined
[03:09] *** committable6 joined
[03:09] *** bisectable6 joined
[03:09] *** shareable6 joined
[03:09] *** benchable6 joined
[03:10] *** nativecallable6 joined
[03:10] *** unicodable6 joined
[03:50] *** vrurg_ joined
[03:50] *** vrurg left
[04:50] *** nativecallable6 left
[04:50] *** benchable6 left
[04:50] *** coverable6 left
[04:50] *** linkable6 left
[04:50] *** unicodable6 left
[04:50] *** committable6 left
[04:50] *** quotable6 left
[04:50] *** sourceable6 left
[04:50] *** bloatable6 left
[04:50] *** bisectable6 left
[04:50] *** squashable6 left
[04:50] *** reportable6 left
[04:50] *** evalable6 left
[04:50] *** releasable6 left
[04:50] *** greppable6 left
[04:50] *** shareable6 left
[04:50] *** notable6 left
[04:50] *** statisfiable6 left
[04:50] *** tellable6 left
[04:50] *** releasable6 joined
[04:50] *** notable6 joined
[04:50] *** unicodable6 joined
[04:51] *** benchable6 joined
[04:51] *** jmcgnh left
[04:51] *** reportable6 joined
[04:51] *** statisfiable6 joined
[04:51] *** nativecallable6 joined
[04:52] *** quotable6 joined
[04:52] *** evalable6 joined
[04:52] *** coverable6 joined
[04:52] *** squashable6 joined
[04:52] *** bisectable6 joined
[04:52] *** tellable6 joined
[04:52] *** sourceable6 joined
[04:52] *** shareable6 joined
[04:53] *** linkable6 joined
[04:53] *** greppable6 joined
[04:53] *** bloatable6 joined
[04:53] *** committable6 joined
[05:05] *** jmcgnh joined
[06:05] *** linkable6 left
[06:05] *** evalable6 left
[06:06] *** reportable6 left
[06:06] *** evalable6 joined
[06:08] *** linkable6 joined
[06:09] *** reportable6 joined
[06:47] *** eseyman left
[07:37] *** Sgeo left
[08:37] *** statisfiable6 left
[08:37] *** coverable6 left
[08:37] *** benchable6 left
[08:37] *** reportable6 left
[08:37] *** shareable6 left
[08:37] *** squashable6 left
[08:37] *** sourceable6 left
[08:37] *** nativecallable6 left
[08:37] *** linkable6 left
[08:37] *** committable6 left
[08:37] *** releasable6 left
[08:38] *** sourceable6 joined
[08:38] *** squashable6 joined
[08:39] *** linkable6 joined
[08:39] *** shareable6 joined
[08:39] *** benchable6 joined
[08:39] *** nativecallable6 joined
[08:39] *** coverable6 joined
[08:40] *** statisfiable6 joined
[08:40] *** reportable6 joined
[08:40] *** committable6 joined
[08:40] *** releasable6 joined
[09:40] *** vrurg joined
[09:40] *** vrurg_ left
[10:14] *** sena_kun joined
[11:14] *** coverable6 left
[11:14] *** sourceable6 left
[11:14] *** committable6 left
[11:14] *** nativecallable6 left
[11:14] *** quotable6 left
[11:14] *** unicodable6 left
[11:14] *** bloatable6 left
[11:14] *** shareable6 left
[11:14] *** notable6 left
[11:14] *** benchable6 left
[11:14] *** greppable6 left
[11:14] *** reportable6 left
[11:14] *** squashable6 left
[11:14] *** tellable6 left
[11:14] *** releasable6 left
[11:14] *** statisfiable6 left
[11:14] *** evalable6 left
[11:14] *** linkable6 left
[11:14] *** bisectable6 left
[11:15] *** statisfiable6 joined
[11:15] *** bisectable6 joined
[11:15] *** nativecallable6 joined
[11:15] *** reportable6 joined
[11:15] *** unicodable6 joined
[11:16] *** shareable6 joined
[11:16] *** releasable6 joined
[11:16] *** linkable6 joined
[11:16] *** coverable6 joined
[11:16] *** notable6 joined
[11:16] *** evalable6 joined
[11:16] *** tellable6 joined
[11:16] *** squashable6 joined
[11:17] *** bloatable6 joined
[11:17] *** quotable6 joined
[11:17] *** sourceable6 joined
[11:17] *** greppable6 joined
[11:17] *** committable6 joined
[11:18] *** benchable6 joined
[11:19] *** grondilu joined
[11:20] <grondilu> wasn't there a shorthand for &infix:<op>?

[11:21] <grondilu> m: dd &[+]

[11:21] <camelia> rakudo-moar 6c948e006: OUTPUT: «Sub+{is-pure}+{Precedence infix:<+> = proto sub infix:<+> ($?, $?, *%) {*}␤»

[11:21] <grondilu> found it

[11:35] *** grondilu left
[12:07] *** reportable6 left
[12:09] *** reportable6 joined
[12:20] <Geth> ¦ docker: 652cf35f9d | (Daniel Mita)++ (committed using GitHub Web editor) | README.md

[12:20] <Geth> ¦ docker: Fix travis-ci badge

[12:20] <Geth> ¦ docker: review: https://github.com/Raku/docker/commit/652cf35f9d

[12:22] *** MitarashiDango[m joined
[12:51] *** wingfold joined
[13:06] *** wingfold_ joined
[13:06] *** wingfold left
[13:17] *** wingfold_ left
[13:30] *** jgaz joined
[13:36] *** wingfold joined
[13:41] *** morte_ joined
[13:49] *** Kaiepi left
[14:06] <leont> Apparently, junctions will turn ranges into lists when they're the only argument

[14:07] <leont> m: dd any(1..4)

[14:07] <camelia> rakudo-moar dbf035d83: OUTPUT: «any(1, 2, 3, 4)␤»

[14:07] <leont> Is that a bug or is that intended? (it is annoying me because it doesn't allow me to do none(1..4) to negate the junction)

[14:08] <leont> m: dd any(1..4, 42)

[14:08] <camelia> rakudo-moar dbf035d83: OUTPUT: «any(1..4, 42)␤»

[14:09] <leont> It's especially annoying because I haven't found any way to turn it off without passing more arguments

[14:11] *** jmcgnh left
[14:14] <lizmat> I think that's intentional, to prevent a lot of code having to be more or less duplicated

[14:14] <lizmat> wrt to collapsing the Junction

[14:16] *** jmcgnh joined
[14:19] <leont> There should be some way to override that, though.

[14:24] *** wingfold left
[14:28] *** thundergnat joined
[14:29] <thundergnat> m: say any(1..4,Empty) # Kinda bogus but...

[14:29] <camelia> rakudo-moar dbf035d83: OUTPUT: «any(1..4)␤»

[14:29] <leont> thundergnat: unexpected, but for now I can work with it

[14:30] *** Sgeo joined
[14:30] <thundergnat> Yeah, not ideal but sometimes you gotta go with what works.

[14:30] <leont> I think that fundementally we're missing a negated() builtin. Which is a bit like none but only takes one value.

[14:31] <leont> Smartmatching against none($whatever) feels a bit confusing, even if it's terribly useful

[14:31] *** thundergnat left
[14:55] <discord-raku-bot> <Nemokosch> Junctions have underdeveloped semantics

[14:58] <discord-raku-bot> <Nemokosch> I say this every now and then but yeah, junctions have a very anglocentric interface, even at the expense of usefulness

[15:12] <tonyo> what could anglocentric interface possibly mean

[15:14] *** wingfold joined
[15:18] *** wingfold left
[15:49] <discord-raku-bot> <Nemokosch> Embracing logically vague or convoluted concepts like "any" and "none"

[15:56] <Altreus> This perspective interests me because I am an anglo, and therefore I have never seen it before

[15:56] <Altreus> Are these concepts not formalised? Could they not be replaced with some set logic symbols and become purely mathematical?

[16:04] <tonyo> not sure i'd consider those vague, any means at least one of a set and none seems clear to me.  why do you consider those vague or convoluted?

[16:06] <discord-raku-bot> <Nemokosch> "For none, P holds" is logically equivalent to "For all, P doesn't hold". This is no big deal, except Raku _forces_ you to write the former, because of "negation lifting" which is, well, a questionable principle

[16:06] <discord-raku-bot> <Nemokosch> So you are left with a less clear and less mentally flexible phrasing

[16:06] <discord-raku-bot> <Nemokosch> "Any" is unsavable on the other hand

[16:06] <tonyo> a∈B == any && x∉A == none

[16:08] <discord-raku-bot> <Nemokosch> Since "I can do anything" and "Can I do anything" have different "any"s in them,  it's a mess, without inventing some higher order logic

[16:08] <tonyo> can you write that equivalence in raku?

[16:08] <tonyo> i think by asking the latter you've already answered it

[16:10] <discord-raku-bot> <Nemokosch> I think I have pinpointed a legitimate design mistake

[16:12] <tonyo> i don't disagree, i'd like to see what you're saying the equivalent "For none, P holds" and "For all, P doesn't hold" translate to

[16:12] <tonyo> without the translation to actual code it's just vague and convoluted

[16:18] *** evalable6 left
[16:18] *** linkable6 left
[16:19] *** linkable6 joined
[16:20] *** evalable6 joined
[16:20] <tonyo> thinking about that a bit more, i don't think those two statements are equivalent "For none, P holds", "For all, P doesn't hold"

[16:21] <tonyo> m: say 1 ~~ all(1,2,3); say 1 ~~ none(1,2,3); 

[16:21] <camelia> rakudo-moar dbf035d83: OUTPUT: «False␤False␤»

[16:21] <tonyo> m: say 1 ~~ all(1,1,1); say 1 ~~ none(1,1,1); 

[16:21] <camelia> rakudo-moar dbf035d83: OUTPUT: «True␤False␤»

[16:22] <tonyo> sure enough, https://en.wikipedia.org/wiki/Denying_the_antecedent

[16:23] <tonyo> nemokosch ^

[16:27] *** sena_kun left
[16:41] <discord-raku-bot> <Nemokosch> I think you are getting this wrong

[16:42] <discord-raku-bot> <Nemokosch> There is no inversion here

[16:43] <discord-raku-bot> <Nemokosch> This is really just "no prime numbers are even" versus "all prime numbers are not-even aka odd"

[16:45] <discord-raku-bot> <Nemokosch> (1, 2, 3).none == 2 # False

[16:45] <discord-raku-bot> <Nemokosch> Versus

[16:45] <discord-raku-bot> <Nemokosch> (1, 2, 3).all != 2 # True, transformed into !((1, 2, 3) == 2) for the wrong reasons

[16:46] <discord-raku-bot> <Nemokosch> So yeah, if you want to say "all of these are different from X", you are forced to say "none of these are equal to X"

[17:02] <tonyo> (1,1,1).none == 1 # False

[17:02] <tonyo> (1,1,1).all != 1 # False

[17:03] <tonyo> you can pick examples where the inversion is true but there are at least as many cases as there are real numbers where it's untrue

[17:06] <tonyo> i mean, the logical fallacy i posted is using exactly the language you are using, i'm not sure how you can defend it

[17:07] <tonyo> "If all, then P"  "If none, then !P"

[17:13] <tonyo> ().none == 2 #False

[17:13] <tonyo> ().all == 2 #False

[17:17] *** jgaz left
[17:20] <tonyo> ().all != 2 # still False

[17:23] <discord-raku-bot> <Nemokosch> If you can point out where the fallacy is in "all primes are odd" <=> "no primes are even", I pay you a trip to Dubai

[17:24] <tonyo> i said already, your hand picked single example works fine. asserting something based on one example is wrong and so is your thought process. i've already shown you counter examples using your same logic

[17:24] <discord-raku-bot> <Nemokosch> You literally didn't

[17:25] <tonyo> haha, ok.

[17:25] <discord-raku-bot> <Nemokosch> You just showed that you failed to understand the very example and went for some strawman

[17:26] <tonyo> no strawman here, just an example of you misunderstanding set theory and showing your logic applied to an example where it doesn't work out for you

[17:26] <discord-raku-bot> <Nemokosch> The fact that you linked something about implications when I'm talking about quantors on sole predicates

[17:27] <discord-raku-bot> <Nemokosch> No "if"s to begin with

[17:27] <tonyo> set.none == 2 == false, set.all != 2 == true where set = (1,2,3) => (true), set = () => (false)

[17:28] <tonyo> set = (2,2,2) => (false)

[17:28] <discord-raku-bot> <Nemokosch> Yes, and this is wrong behavior

[17:29] <discord-raku-bot> <Nemokosch> set.all != X is NOT the same as !(set.all == X) in logic, only in Raku

[17:29] <discord-raku-bot> <Nemokosch> It is the same as set.none == X

[17:29] <tonyo> it isn't.

[17:30] <tonyo> (set.all != X) != (set.none == X) in logic or in theory

[17:31] <discord-raku-bot> <Nemokosch> Not in Raku, yes in logic

[17:31] <discord-raku-bot> <Nemokosch> If and only if all values are different from X, are none of the values equal to it

[17:31] <discord-raku-bot> <Nemokosch> Yes, it is, lol

[17:31] <tonyo> no, it isn't.  what is the result of set.none == 2 when set is empty?

[17:35] <Voldenet> True, obviously

[17:35] <discord-raku-bot> <Nemokosch> See, that's what the problem is by using anglo-centric quantors in the first place...

[17:35] <tonyo> and then what is the result of set.all != 2 when, again, the set is empty?

[17:36] <tonyo> oops, nemokosch there is not problem with anglo-centric quantors

[17:36] <ugexe> the result should obviously be True, nil or False, nil

[17:37] <Voldenet> none -> no element matches the predicate

[17:37] <Voldenet> all -> all elements match the predicate

[17:37] <discord-raku-bot> <Nemokosch> True, that one is for sure

[17:37] <tonyo> going back to work instead of arguing with someone who just says `no` and then refuses to use examples outside of cherry picked examples

[17:37] <Voldenet> so `set.all != 2` and `set.all == 2` can be used to test whether the set is empty

[17:38] <tonyo> or set.elems : )

[17:38] <Voldenet> with empty set and a single predicate, all elements match the predicate and no elements match the predicate

[17:38] <Voldenet> that makes perfect sense

[17:39] <discord-raku-bot> <Nemokosch> For "all", it's a well-established practice that the value on an empty set is true, that's the algebraically sane "default" for logical "and"

[17:39] <discord-raku-bot> <Nemokosch> No gotcha with this

[17:39] <Voldenet> so `().all == 2`, `().all != 2`, `().none != 2` and `().none == 2` should be all true

[17:40] <discord-raku-bot> <Nemokosch> ^this

[17:41] <discord-raku-bot> <Nemokosch> Seems like we can agree with Voldenet on some things, after all :D

[17:41] <Voldenet> ;)

[17:41] <discord-raku-bot> <Nemokosch> Although I would stay away from .none in borderline cases like this, which is part of my whole point

[17:42] <discord-raku-bot> <Nemokosch> Because it's not really a common quantifier in math

[17:45] <discord-raku-bot> <Nemokosch> Who would dare to contradict a cornerstone of basically all formalisms used for e.g relational databases

[17:46] <Voldenet> …in relational databases predicate can be both true and false at the same time and I think it's beautiful ;)

[17:52] <discord-raku-bot> <Anton Antonov> For what is worth, here is how Mathematica does the tests listed by Voldenet :

[17:54] <discord-raku-bot> <Anton Antonov> Here is the image link: https://i.imgur.com/uGy6WVu.jpg

[17:55] <discord-raku-bot> <Anton Antonov> Meaning Mathematica agrees with Voldenet's statement :  

[17:55] <discord-raku-bot> <Anton Antonov> "` ().all == 2, ().all != 2, ().none != 2 and ().none == 2`  should be all true."

[17:57] <Voldenet> raku/mathematica definitions are slightly different though

[17:58] <discord-raku-bot> <Nemokosch> It's rather the issue itself in this case

[17:58] <Voldenet> Sure, I'd expect the mathematica ones

[17:58] <discord-raku-bot> <Anton Antonov> Sure, I am just mentioned the handling/implementation in Mathematica of similar functionalities.

[17:58] <discord-raku-bot> <Nemokosch> We do know that blah.all != X implicitly transforms into !(blah.all == X)

[17:59] <Voldenet> which is unfortunate in this case

[18:00] <discord-raku-bot> <Nemokosch> This is a deliberate design... mistake, and I really feel I can't just drop the judgemental part

[18:00] <discord-raku-bot> <Anton Antonov> @Voldenet Sorry for this ignorant question -- did you see the image I posted in Discord, or saw the image I posted at Imgur?

[18:00] <tonyo> @anton antonov: yes

[18:00] <tonyo> it came through

[18:00] <Voldenet> The imgur one, discord one was just devoured by bot

[18:00] <discord-raku-bot> <Anton Antonov> Ok, good to know!

[18:02] <discord-raku-bot> <Anton Antonov> @tonyo Which one came through?

[18:02] <tonyo> also, nemokosch isn't 2 a prime number?  nevermind about dubai though.

[18:03] <tonyo> anton - the imgur link (at least in irc)

[18:03] <ugexe>  12:54:30 	<discord-raku-bot>	

[18:03] <ugexe> <Anton Antonov> Here is the image link: https://i.imgur.com/uGy6WVu.jpg

[18:04] <discord-raku-bot> <Nemokosch> It is but what does this have to do with logical equivalence? :D

[18:04] <discord-raku-bot> <Anton Antonov> @tonyo and @ugexe -- Thanks! I will use Imgur in the future.

[18:04] <tonyo> <Nemokosch> If you can point out where the fallacy is in "all primes are odd" <=> "no primes are even", I pay you a trip to Dubai

[18:05] <Voldenet> hehehe :D

[18:06] <tonyo> aside from that, your original assertion was about any and none, which is still untrue, no matter how many times you say otherwise

[18:07] <tonyo> not sure how we got off on the all <> none strawman you brought forth, possibly a backtrack

[18:08] *** reportable6 left
[18:08] *** irc_user joined
[18:08] *** reportable6 joined
[18:11] *** kolofon joined
[18:15] <Voldenet> fortunately this is easy fo tix

[18:15] <Voldenet> to fix*

[18:16] <Voldenet> m: sub infix:<!=>($a, $b) { !($a == $b) };

[18:16] <camelia> rakudo-moar dbf035d83: ( no output )

[18:16] <tonyo> only two prime numbers are even <=> all but two prime numbers are odd (sometimes)

[18:16] <Voldenet> m: sub infix:<!=>($a, $b) { !($a == $b) };  say so ().none != 2;

[18:16] <camelia> rakudo-moar dbf035d83: OUTPUT: «True␤»

[18:17] <tonyo> m: say 2 !~~ none(); say 2 ~~ none();

[18:17] <camelia> rakudo-moar dbf035d83: OUTPUT: «False␤True␤»

[18:17] <tonyo> m: say 2 !~~ any(); say 2 ~~ any();

[18:17] <camelia> rakudo-moar dbf035d83: OUTPUT: «True␤False␤»

[18:48] *** kolofon left
[18:52] <leont> Apparently, coercing to a role isn't well supported. It puns, and therefor only works on concrete types. I'd argue this a bug, because it's really not helpful for anything.

[18:55] *** melezhik joined
[18:55] <discord-raku-bot> <Nemokosch> Good sir, I made points that you had no intentions to engage in, instead you started pointing fingers at random unrelated things, like whether equivalent statements used as an example for equivalence are true or not, and some random fallacy that I also don't like but doesn't fit here whatsoever.

[18:56] *** [Coke]_ is now known as [Coke]

[18:56] <melezhik> .

[18:57] <discord-raku-bot> <Nemokosch> What should I prove further? You yourself proved pretty well that none is a mess to start defining

[18:59] *** melezhik left
[19:06] <[Coke]> iwbni raku.land deps were links

[19:17] *** morte_ left
[19:33] <tbrowder>  anyone tired of debating is welcome to voice an opinion of rakudo PR #5031 which is concerned with adding a method for breaking down an IO::Path basename onto parts..

[19:35] <tbrowder> already existing is .extension, but no equivalent method exists for the part of the basename with the extension removed.

[19:41] *** morte_ joined
[19:41] *** morte_ left
[20:17] <discord-raku-bot> <Nemokosch> I'm not at home but if you need an advocate for "torturing implementors on the user's behalf", I'm ready to help :)

[20:37] *** irc_user left
[21:21] *** sena_kun joined
[21:22] *** irc_user joined
[21:26] <discord-raku-bot> <p6steve> tbrowder: phew

[21:31] <discord-raku-bot> <p6steve> tbrowder: you have this ```<_file.tar.gz.1_> ``` what are the underscores?

[21:40] *** mexen left
[21:46] <tbrowder> Those were the examples given by … I’ll have to check. If you look at the PR you should be able to see the author. I’ll check and return…

[21:54] <tbrowder> Ah, I saw those _ while editing my reply to @vrurg. I see now they don’t show in the browser view, so I need to clean up my response—thanks for that catch!

[21:55] <leont> Did we ever end up documenting the details of the coercion protocol? I have questions and I can't find the answers anywhere

[22:00] <tbrowder> <p6steve>: it looks correct now, thnx

[22:01] *** sena_kun left
[22:17] <leont> m: sub f(\rows) { dd rows }; f([ [ 1, 2 ] ])

[22:17] <camelia> rakudo-moar dbf035d83: OUTPUT: «[1, 2]␤»

[22:17] *** sena_kun joined
[22:18] <leont> I don't get why Raku eats the outer brackets

[22:18] <leont> Is there any way to make it not do that?

[22:18] *** sena_kun left
[22:26] *** thundergnat joined
[22:26] <thundergnat> m: sub f(\rows) { dd rows }; f([ [ 1, 2 ], ]) # single argument woes once again

[22:26] <camelia> rakudo-moar dbf035d83: OUTPUT: «[[1, 2],]␤»

[22:28] <leont> I was expecting \ not to have those woes

[22:30] <leont> Wasn't the whole point of that "pass me this verbatim"?

[22:30] <thundergnat> m: sub f(**@rows) { dd @rows }; f([ [ 1, 2 ] ]) # maybe this will help?

[22:30] <camelia> rakudo-moar dbf035d83: OUTPUT: «[[1, 2],]␤»

[22:32] <thundergnat> single argument ends up biting in unexpected places. I still prefer to have it but it can lead to some convolutions.

[22:33] <leont> thundergnat: that breaks when actually having more than one inner list

[22:35] <thundergnat> hmm. It does. ok, I've got nothing.

[22:35] <ugexe> i really dislike having these generic method names like 'suffix' and 'stem' being added for very specific, not often used features

[22:36] <ugexe> when those terms, to me at least, are very much not tied to a path

[22:38] <ugexe> this can introduce future inconsistencies where you have a 'suffix' for IO::Path that acts on the basename only, and a suffix for strings in general that would have no concept of basename

[22:39] <ugexe> like whats wrong with basename-suffix or basename-stem?

[22:43] <leont> I can't imagine ever wanting stem in particular

[22:43] <leont> What is want is the basename as implemented in Unix and in Perl: one that can remove a given suffix. Bonus points if it can take a junction of them.

[22:44] <leont> The basename method not doing what any other basename does is rather frustrating

[22:45] <leont> Possibly basename should just take an optional argument to do just that

[22:50] *** thundergnat left
[23:04] *** swaggboi left
[23:07] *** Kaiepi joined
[23:17] *** swaggboi joined
[23:21] *** vrurg_ joined
[23:21] *** vrurg left
[23:34] *** guifa left
[23:54] *** vrurg_ is now known as vrurg

