[00:07] *** reportable6 left
[00:10] *** reportable6 joined
[00:26] *** Sgeo joined
[01:10] *** Kaipei joined
[01:12] *** Kaiepi left
[02:12] *** linkable6 left
[02:12] *** sourceable6 left
[02:12] *** evalable6 left
[02:12] *** statisfiable6 left
[02:12] *** greppable6 left
[02:12] *** tellable6 left
[02:12] *** quotable6 left
[02:12] *** squashable6 left
[02:12] *** coverable6 left
[02:12] *** reportable6 left
[02:12] *** unicodable6 left
[02:12] *** notable6 left
[02:12] *** committable6 left
[02:12] *** bloatable6 left
[02:12] *** releasable6 left
[02:12] *** nativecallable6 left
[02:12] *** bisectable6 left
[02:12] *** shareable6 left
[02:12] *** benchable6 left
[02:13] *** bisectable6 joined
[02:13] *** sourceable6 joined
[02:13] *** committable6 joined
[02:13] *** bloatable6 joined
[02:13] *** notable6 joined
[02:14] *** coverable6 joined
[02:14] *** statisfiable6 joined
[02:14] *** evalable6 joined
[02:14] *** tellable6 joined
[02:14] *** benchable6 joined
[02:14] *** releasable6 joined
[02:14] *** shareable6 joined
[02:14] *** quotable6 joined
[02:15] *** reportable6 joined
[02:15] *** nativecallable6 joined
[02:15] *** linkable6 joined
[02:15] *** greppable6 joined
[02:15] *** unicodable6 joined
[02:15] *** squashable6 joined
[03:15] *** evalable6 left
[03:15] *** linkable6 left
[03:17] *** evalable6 joined
[03:18] *** linkable6 joined
[03:43] *** Xliff left
[04:43] *** quotable6 left
[04:43] *** evalable6 left
[04:43] *** tellable6 left
[04:43] *** linkable6 left
[04:43] *** bloatable6 left
[04:43] *** statisfiable6 left
[04:43] *** reportable6 left
[04:43] *** releasable6 left
[04:43] *** benchable6 left
[04:43] *** bisectable6 left
[04:43] *** unicodable6 left
[04:43] *** notable6 left
[04:43] *** greppable6 left
[04:43] *** squashable6 left
[04:43] *** committable6 left
[04:43] *** sourceable6 left
[04:43] *** nativecallable6 left
[04:43] *** coverable6 left
[04:43] *** shareable6 left
[04:43] *** committable6 joined
[04:43] *** nativecallable6 joined
[04:43] *** reportable6 joined
[04:43] *** quotable6 joined
[04:44] *** statisfiable6 joined
[04:44] *** shareable6 joined
[04:44] *** benchable6 joined
[04:45] *** coverable6 joined
[04:45] *** notable6 joined
[04:45] *** greppable6 joined
[04:45] *** squashable6 joined
[04:45] *** tellable6 joined
[04:45] *** bloatable6 joined
[04:45] *** sourceable6 joined
[04:45] *** bisectable6 joined
[04:45] *** evalable6 joined
[04:46] *** unicodable6 joined
[04:46] *** releasable6 joined
[04:46] *** linkable6 joined
[05:46] *** reportable6 left
[05:46] *** benchable6 left
[05:46] *** greppable6 left
[05:46] *** sourceable6 left
[05:46] *** coverable6 left
[05:46] *** nativecallable6 left
[05:46] *** linkable6 left
[05:46] *** statisfiable6 left
[05:46] *** quotable6 left
[05:46] *** evalable6 left
[05:46] *** tellable6 left
[05:46] *** committable6 left
[05:46] *** shareable6 left
[05:46] *** notable6 left
[05:46] *** releasable6 left
[05:46] *** bloatable6 left
[05:46] *** bisectable6 left
[05:46] *** unicodable6 left
[05:46] *** squashable6 left
[05:46] *** quotable6 joined
[05:47] *** nativecallable6 joined
[05:47] *** coverable6 joined
[05:47] *** squashable6 joined
[05:47] *** releasable6 joined
[05:47] *** notable6 joined
[05:47] *** shareable6 joined
[05:47] *** unicodable6 joined
[05:47] *** bisectable6 joined
[05:48] *** reportable6 joined
[05:48] *** statisfiable6 joined
[05:48] *** benchable6 joined
[05:48] *** evalable6 joined
[05:48] *** bloatable6 joined
[05:48] *** linkable6 joined
[05:48] *** greppable6 joined
[05:48] *** sourceable6 joined
[05:49] *** committable6 joined
[05:49] *** tellable6 joined
[06:07] *** reportable6 left
[06:08] *** reportable6 joined
[07:08] *** reportable6 left
[07:08] *** unicodable6 left
[07:08] *** evalable6 left
[07:08] *** benchable6 left
[07:08] *** shareable6 left
[07:08] *** coverable6 left
[07:08] *** nativecallable6 left
[07:08] *** greppable6 left
[07:08] *** notable6 left
[07:08] *** committable6 left
[07:08] *** statisfiable6 left
[07:08] *** tellable6 left
[07:08] *** bloatable6 left
[07:08] *** bisectable6 left
[07:08] *** quotable6 left
[07:08] *** releasable6 left
[07:08] *** sourceable6 left
[07:08] *** linkable6 left
[07:08] *** squashable6 left
[07:08] *** bloatable6 joined
[07:08] *** squashable6 joined
[07:09] *** releasable6 joined
[07:09] *** sourceable6 joined
[07:09] *** shareable6 joined
[07:09] *** quotable6 joined
[07:09] *** reportable6 joined
[07:10] *** notable6 joined
[07:10] *** committable6 joined
[07:10] *** benchable6 joined
[07:10] *** nativecallable6 joined
[07:10] *** unicodable6 joined
[07:10] *** coverable6 joined
[07:11] *** tellable6 joined
[07:11] *** greppable6 joined
[07:11] *** linkable6 joined
[07:11] *** evalable6 joined
[07:11] *** bisectable6 joined
[07:11] *** statisfiable6 joined
[07:59] *** Sgeo left
[08:59] *** committable6 left
[08:59] *** quotable6 left
[08:59] *** greppable6 left
[08:59] *** linkable6 left
[08:59] *** unicodable6 left
[08:59] *** evalable6 left
[08:59] *** statisfiable6 left
[08:59] *** notable6 left
[08:59] *** bisectable6 left
[08:59] *** coverable6 left
[08:59] *** shareable6 left
[08:59] *** reportable6 left
[08:59] *** benchable6 left
[08:59] *** tellable6 left
[08:59] *** bloatable6 left
[08:59] *** sourceable6 left
[08:59] *** squashable6 left
[08:59] *** nativecallable6 left
[08:59] *** releasable6 left
[08:59] *** committable6 joined
[09:00] *** reportable6 joined
[09:00] *** bloatable6 joined
[09:00] *** tellable6 joined
[09:00] *** shareable6 joined
[09:00] *** bisectable6 joined
[09:00] *** squashable6 joined
[09:01] *** sourceable6 joined
[09:01] *** statisfiable6 joined
[09:01] *** evalable6 joined
[09:01] *** unicodable6 joined
[09:01] *** benchable6 joined
[09:02] *** greppable6 joined
[09:02] *** coverable6 joined
[09:02] *** notable6 joined
[09:02] *** nativecallable6 joined
[09:02] *** linkable6 joined
[09:02] *** quotable6 joined
[09:02] *** releasable6 joined
[09:04] *** Altai-man joined
[10:04] *** coverable6 left
[10:04] *** linkable6 left
[10:04] *** bloatable6 left
[10:04] *** shareable6 left
[10:04] *** unicodable6 left
[10:04] *** quotable6 left
[10:04] *** greppable6 left
[10:04] *** nativecallable6 left
[10:04] *** bisectable6 left
[10:04] *** committable6 left
[10:04] *** reportable6 left
[10:04] *** benchable6 left
[10:04] *** sourceable6 left
[10:04] *** evalable6 left
[10:04] *** squashable6 left
[10:04] *** notable6 left
[10:04] *** releasable6 left
[10:04] *** tellable6 left
[10:04] *** statisfiable6 left
[10:04] *** reportable6 joined
[10:05] *** shareable6 joined
[10:05] *** statisfiable6 joined
[10:05] *** benchable6 joined
[10:05] *** bloatable6 joined
[10:05] *** tellable6 joined
[10:06] *** committable6 joined
[10:06] *** notable6 joined
[10:06] *** coverable6 joined
[10:06] *** linkable6 joined
[10:06] *** quotable6 joined
[10:06] *** bisectable6 joined
[10:06] *** nativecallable6 joined
[10:06] *** releasable6 joined
[10:06] *** evalable6 joined
[10:07] *** sourceable6 joined
[10:07] *** unicodable6 joined
[10:07] *** greppable6 joined
[10:07] *** squashable6 joined
[10:48] *** frost joined
[11:17] *** euandreh left
[11:23] *** simcop2387 left
[11:23] *** simcop2387 joined
[11:40] *** perlbot left
[11:40] *** simcop2387 left
[11:42] *** perlbot joined
[11:43] *** simcop2387 joined
[11:47] *** simcop2387 left
[11:48] *** simcop2387 joined
[12:04] *** Guest86 joined
[12:06] *** reportable6 left
[12:08] *** reportable6 joined
[12:10] *** frost left
[12:55] *** Guest86 left
[13:27] <discord-raku-bot> <p6steve> m: my $t = 'dkjgsj2022skjh'; my regex yr { \d**4 }; $t ~~ /<yr>/; my $r = ~$<yr> if $<yr>; $r.say

[13:27] *** _________ left
[13:27] *** p6steve joined
[13:28] <guifa> m: my $t = 'dkjgsj2022skjh'; my regex yr { \d**4 }; $t ~~ /<yr>/; my $r = ~$<yr> if $<yr>; $r.say

[13:28] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´2022‚ê§¬ª

[13:28] * guifa . o O ( camelia bot can't see through discord bot)

[13:28] <p6steve> hmmm - need to be on irssi ;-), not discord

[13:28] <tellable6> 2022-08-04T19:03:32Z #raku <Xliff> p6-steve: Looked into that. Decodes into a Buf which I can't do anything with. It doesn't seem to work with Raku's decode.

[13:28] <tellable6> 2022-08-04T21:24:04Z #raku <Xliff> p6steve: I did get that far, however it appears that the string I am tryig to parse fails the deserializer.,

[13:29] <p6steve> anyway, question is is there a better idiom to say 'my $r = ~$<yr> if $<yr>' ?

[13:30] <p6steve> this seems like I have to say '<yr>' twice... and I'm very lazy

[13:30] <guifa> my $r = $<yr>.?Str

[13:30] <evalable6> guifa, rakudo-moar dc180bd95: OUTPUT: ¬´Use of Nil in string context‚ê§  in block <unit> at /tmp/iZTL1O9mrU line 1‚ê§¬ª

[13:30] <guifa> err

[13:30] <p6steve> yeah - that's the err

[13:31] <guifa> oh right.  Nil returns Nil for everything except for a few methods

[13:31] <guifa> we need a true Nil that returns Nil always lol

[13:31] <p6steve> i was wondering something like //= ?

[13:32] <guifa> I mean, what is the value you want if there's nothing there?

[13:32] <guifa> if you do my $r = ~$<yr> if $<yr>, but $<yr> isn't there

[13:32] <guifa> $r will be (Any)

[13:32] *** _________ joined
[13:33] <p6steve> m: my $t = 'dkjgsjskjh'; my regex yr { \d**4 }; $t ~~ /<yr>/; my $r = ~$<yr> if $<yr>; $r.say

[13:33] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´(Any)‚ê§¬ª

[13:33] <guifa> my $r = .Str with $<yr>; is what I'd do

[13:34] <p6steve> m: my $t = 'dkjgsj2022skjh'; my regex yr { \d**4 }; $t ~~ /<yr>/; my $r = .Str with $<yr>; $r.say

[13:34] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´2022‚ê§¬ª

[13:35] <p6steve> m: my $t = 'dkjgsj2022skjh'; my regex yr { \d**4 }; $t ~~ /<yr>/; my $r .= Str with $<yr>; $r.say

[13:35] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Use of uninitialized value $r of type Any in string context.‚ê§Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.‚ê§‚ê§  in block  at <tmp> line 1‚ê§¬ª

[13:35] <Voldenet> Wait, there's so many operators in raku, but not the one for `?.`-like method call?

[13:35] <discord-raku-bot> <Nemokosch> that's right

[13:35] <p6steve> guifa: that's the ticket !! thanks

[13:35] <guifa> Voldenet there is

[13:36] <guifa> BUT ‚Äî¬†and it's a big but

[13:36] <discord-raku-bot> <Nemokosch> it's such a big but that the answer is essentially _no_

[13:36] <p6steve> so with topicalizes into the expression - how cool is that

[13:36] <guifa> .? returns Nil when the method isn't there

[13:37] <guifa> Nil in Raku is almost a true Nil, but frustratingly not quite when it comes to a handful of methods

[13:37] * Voldenet tilts head

[13:37] <guifa> notably, in this case, .Str

[13:37] <discord-raku-bot> <Nemokosch> the closest to a `?.` is `andthen`

[13:37] <discord-raku-bot> <Nemokosch> `.?` is pretty much the opposite of `?.`

[13:37] <Voldenet> m: my $x; my $y = $x?.Str;

[13:37] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Bogus postfix‚ê§at <tmp>:1‚ê§------> my $x; my $y = $x‚èè?.Str;‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚ê§        statement modif‚Ä¶¬ª

[13:37] <discord-raku-bot> <Nemokosch> not just visually - it checks if the method exists on the type

[13:37] *** p6steve left
[13:37] <discord-raku-bot> <Nemokosch> not if the data is available

[13:38] <Voldenet> essentially .? isn't ?. tho, ?. is more useful when traversing data that could be missing

[13:38] <Voldenet> Would be nice if that op was added

[13:39] <discord-raku-bot> <Nemokosch> `.?` is barely ever useful I think

[13:39] <discord-raku-bot> <Nemokosch> make one - it's literally just $x andthen .method

[13:39] <discord-raku-bot> <Nemokosch> "the tight `andthen`"

[13:40] <guifa> You'd need to go to the slang level for it though.  all the dot operators are psuedo operators ‚Äî¬†there's no way to catch the bare string on RHS with standard operators

[13:42] <discord-raku-bot> <Nemokosch> tbh `andthen` itself is tricky the least to say

[13:45] <discord-raku-bot> <Nemokosch> let's add one more to the RakuAST bucket list üòÑ

[13:46] <Voldenet> :)

[13:48] <Voldenet> it's actually a tricky problem, btw

[13:49] <discord-raku-bot> <Nemokosch> oh right, you might remember that andthen chain as well

[13:49] <discord-raku-bot> <Nemokosch> where the second andthen absolutely failed to get a closure

[13:50] <Voldenet> given `sub a(Any, ‚Äì> Str)` and `sub b(Str, ‚Äì> Int)` what should '$x?.&a?.&b` return, (Str) or (Int)?

[13:50] <guifa> Speaking of slangs

[13:50] <guifa> I think tonight or tomorrow I'll finally release my regex one. Infinitely more advanced than my BASIC one

[13:51] <discord-raku-bot> <Nemokosch> If there are 5 free minutes on the conference... üòâ

[13:52] <guifa> lol I already teased the idea of regex slangs at P&RC

[13:52] <guifa> I just don't have time to get a presentation together for that

[13:53] <guifa> Plus 90% of the cool stuff will be far more interesting once RakuAST is ready ‚Äî¬†I'm still having to do old fashioned string concats with a string-based EVAL because the regex nodes aren't quite finished

[13:54] <discord-raku-bot> <Nemokosch> a shame really

[13:54] <discord-raku-bot> <Nemokosch> Voldenet: my call (haha) would be (Int), by the way

[13:54] <discord-raku-bot> <Nemokosch> If that call chain is allowed to succeed at all, I think that would only make sense

[13:55] <guifa> I'd say Nil if the call fails.  That works fine on typed variables:

[13:55] <guifa> m: my Str $a = Nil; say $a.WHAT

[13:55] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´(Str)‚ê§¬ª

[13:56] <discord-raku-bot> <Nemokosch> Yes, the regexes are kinda yucky at the moment... I mean it's nice that there is built-in syntax for them, but as long as there is no way to generate them, it's really just dummy weight

[13:56] <discord-raku-bot> <Nemokosch> in the meantime, Python doesn't have actual regexes but strings and nothing can be missing

[13:57] <guifa> You can handle some regex with RakuAST right now, just ‚Ä¶¬†not everything.  And my slang is to convert a full regex flavor to Raku

[13:58] <discord-raku-bot> <Nemokosch> I think Nil also leads to (Int) in that chain

[13:58] <guifa> It'll lead to the type of the variable it's assigned to

[13:58] <guifa> so by default, (Any)

[14:00] *** discord-raku-bot left
[14:01] *** discord-raku-bot joined
[14:03] *** discord-raku-bot left
[14:03] *** discord-raku-bot joined
[14:03] <discord-raku-bot> <Nemokosch> oh right, this won't run for any of us in this channel

[14:04] *** Nemokosch joined
[14:04] <Nemokosch> m: sub demo(-->Int) { Nil }; my Str $demo = demo; dd $demo;

[14:04] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Str $demo = Str‚ê§¬ª

[14:04] <tellable6> 2022-08-04T22:01:12Z #raku <Xliff> Nemokosch: How do I parse that whole string as a string?

[14:04] *** Nemokosch left
[14:05] *** euandreh joined
[14:05] <discord-raku-bot> <Nemokosch> It basically dodges all the type safety attempts

[14:05] <discord-raku-bot> <Nemokosch> I would also have expected this function to return (Int), rather

[14:06] <discord-raku-bot> <Nemokosch> since that's what my Int $result = Nil; would give

[14:07] <Voldenet> Indeed, type safety is problematic here

[14:07] <discord-raku-bot> <Nemokosch> again, this is not something I can foresee changing any time soon, if ever... but

[14:07] <discord-raku-bot> <Nemokosch> doing "Nil is empty" and "Nil is a soft exception" at the same time is a hardly saveable approach

[14:08] <Voldenet> m: sub why(‚Äì> Int()) { Nil }; why()

[14:08] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> sub why(‚èè‚Äì> Int()) { Nil }; why()‚ê§¬ª

[14:09] <Voldenet> m: sub foo(‚Äì> Int()) { Nil }; foo()

[14:09] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> sub foo(‚èè‚Äì> Int()) { Nil }; foo()‚ê§¬ª

[14:09] <Voldenet> ah, right

[14:09] <Voldenet> m: sub foo(--> Int()) { Nil }; foo()

[14:09] <camelia> rakudo-moar dc180bd95: ( no output )

[14:09] <Voldenet> m: sub foo(--> Int()) { Nil }; foo().WHAT.say

[14:09] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Nil‚ê§¬ª

[14:09] <discord-raku-bot> <Nemokosch> all Failures derive from Nil, probably we wouldn't want to wrap them all into that certain Int...

[14:11] <Voldenet> m: sub x() returns Int:D { Nil }; x().WHAT.say'

[14:11] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------>  x() returns Int:D { Nil }; x().WHAT.say‚èè'‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        statement end‚ê§        statement ‚Ä¶¬ª

[14:11] <Voldenet> m: sub x() returns Int:D { Nil }; x().WHAT.say

[14:11] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Nil‚ê§¬ª

[14:12] <Voldenet> I'm not sure about getting Nil from a routine apparently returning `Int:D`

[14:12] <lizmat> Nil is allowed to do that, as is Failure

[14:13] <lizmat> m: sub a(--> Int:D) { fail "foo" }; say a

[14:13] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´foo‚ê§  in sub a at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[14:13] <discord-raku-bot> <Nemokosch> > Absence of a value or a benign failure

[14:13] <discord-raku-bot> <Nemokosch> the problem itself is combining these two things

[14:14] <discord-raku-bot> <Nemokosch> the "absence of a value" has all reasons to still obey type safety

[14:14] <discord-raku-bot> <Nemokosch> Actually, it can be argued that a failure also has

[14:14] <Voldenet> If I wanted type safety, I'd say that `Int` should either return `(Int)` or `Int:D`

[14:15] <Voldenet> failure is an exception, so I'd expect the call to never return anything

[14:15] <lizmat> suppose types were checked for Failure and Nil, then any sub potentially return a Failure or Nil would not be able to have a return constraint

[14:15] <discord-raku-bot> <Nemokosch> I frankly don't get why failures are even allowed to silently fall back to "the absence of a value"

[14:15] <discord-raku-bot> <Nemokosch> But if they are allowed to do that, maybe even a failure should obey type annotations...

[14:16] <discord-raku-bot> <Nemokosch> you wish but Failure is not an Exception

[14:16] <lizmat> Failure wraps an Exception

[14:17] <lizmat> it's an Exception with a built-in bomb disposal team :-)

[14:17] <discord-raku-bot> <Nemokosch> I'm not sure I like the idea of "failures" in the first place but for all intents and purposes, they keep your code running, they don't break the flow

[14:17] <discord-raku-bot> <Nemokosch> they act much more like values than exceptions

[14:18] <lizmat> m: dd [].pop

[14:18] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Failure.new(exception => X::Cannot::Empty.new(action => "pop", what => "Array"), backtrace => Backtrace.new)‚ê§¬ª

[14:19] <lizmat> m: if [].pop { } else { say "nothing to pop" }

[14:19] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´nothing to pop‚ê§¬ª

[14:19] *** _________ left
[14:20] <discord-raku-bot> <Nemokosch> for example, this could be just "the absence of a value", without the bells and fanfars

[14:20] <discord-raku-bot> <Nemokosch> a failure-agnostic Nil value

[14:20] <discord-raku-bot> <Nemokosch> this example pretty much hints why I wasn't sure about failures regarding the type safety

[14:22] <discord-raku-bot> <Nemokosch> you lose the assigned data I guess, or it has to "explode" some way

[14:22] <discord-raku-bot> <Nemokosch> but assuming that Nil is JUST "the absence of a value", it could still be type safe

[14:22] <discord-raku-bot> <Nemokosch> the same way nothing bad happens when you assign Nil to a typed variable, the function could do that by itself, hence not leaving a big hole on the type

[14:24] <discord-raku-bot> <Nemokosch> what happens when you assign a Failure to a usual variable, though ü§î

[14:24] <discord-raku-bot> <Anton Antonov> @lizmat Just submitted a new minor issue in the "App::Rak" GitHub repository. üôÇ

[14:24] <discord-raku-bot> <Nemokosch> I checked it now - it doesn't act like Nil...

[14:24] <lizmat> Anton Antonov: thanks

[14:24] *** Nemokosch joined
[14:25] <Nemokosch> my $blah = [].pop; dd $blah ~~ Nil; $blah = Nil; dd $blah ~~ Nil;

[14:25] <evalable6> Nemokosch, rakudo-moar dc180bd95: OUTPUT: ¬´Bool::True‚ê§Bool::False‚ê§¬ª

[14:26] <discord-raku-bot> <Nemokosch> okay, I think this is the no.1 madness this week

[14:26] <Voldenet> ‚Ä¶

[14:26] <discord-raku-bot> <Nemokosch> what isn't Nil is Nil but what is Nil isn't Nil... this is roughly as bonkers as the legendary [] == ![] in Javascript

[14:27] <Voldenet> `[] == ![]` isn't crazy, it makes perfect sense

[14:28] <discord-raku-bot> <Nemokosch> okay... Raku/Problem-Solving...

[14:28] <Nemokosch> Voldenet: it "makes sense" the same way this does

[14:28] <Voldenet> :)

[14:28] <Voldenet> when you look at the code it's obvious

[14:29] <Nemokosch> it is deterministic alright, but it is unintuitive to anyone who hasn't learned the conversion rules by heart

[14:29] <Nemokosch> I feel strongly about [] converting to '' and 0 anyway

[14:29] <Nemokosch> or '' to 0, for the matter, I praise Python for avoiding that conceptual clusterfuck

[14:30] <Voldenet> no matter how you define it, automatic type conversions are going to be pain

[14:30] <Nemokosch> well, if you define them in all directions, maybe

[14:30] <Voldenet> -1 is true and also false

[14:31] <lizmat> Nil returns a container to its original state

[14:31] *** _________ joined
[14:31] <lizmat> m: my $a is default(42) = 666; say $a; $a = Nil; say $a

[14:31] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´666‚ê§42‚ê§¬ª

[14:31] <Nemokosch> You know, I tried this because I "expected" this result

[14:31] <Nemokosch> "expected" in the bad sense

[14:32] <Nemokosch> was afraid of it, we could say

[14:32] <Nemokosch> I see this as the ultimate proof Failures should have nothing to do with Nil

[14:32] <Nemokosch> they don't behave like Nil but falsely claim they are Nil

[14:33] <Nemokosch> If they already don't behave like Nil, it would be very desirable that they don't claim to descend from Nil

[14:33] <lizmat> m: dd Failure.^mro

[14:33] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´(Failure, Nil, Cool, Any, Mu)‚ê§¬ª

[14:34] <Nemokosch> Yes - take that Nil out of the chain, is my proposal

[14:34] <Nemokosch> It violates the substitution principle in the craziest way

[14:36] <Nemokosch> To be honest, I'm already afraid of the attempt to even write down the issue

[14:38] *** Nemokosch left
[14:38] <discord-raku-bot> <Nemokosch> But this is so insane that I wouldn't sleep well if I didn't even try to bring it up

[14:41] *** discord-raku-bot left
[14:41] *** discord-raku-bot joined
[14:41] <lizmat> Insane?  I'd say strangely consistent

[14:42] <Voldenet> m: my Int:D $x = Nil;

[14:42] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Type check failed in assignment to $x; expected Int:D but got Int (Int) (perhaps Nil was assigned to a :D which had no default?)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[14:42] <Voldenet> m: sub x() returns Int:D { Nil }; x().say

[14:42] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Nil‚ê§¬ª

[14:42] <Voldenet> so‚Ä¶ is it allowed or not?

[14:43] <discord-raku-bot> <Nemokosch> lizmat, please...

[14:43] <discord-raku-bot> <Nemokosch> you have just seen a Failure being Nil while Nil itself NOT being Nil

[14:43] <discord-raku-bot> <Nemokosch> what is so consistent about this...

[14:44] <lizmat> returning Nil from a sub is *not* an assignment of Nil to a container

[14:44] *** Altai-man left
[14:44] <Voldenet> obviously

[14:44] <discord-raku-bot> <Nemokosch> the behavior of Nil is the one of an absent value

[14:44] <discord-raku-bot> <Nemokosch> the behavior of the descendants of Nil is one of a captured error

[14:44] <Voldenet> but it's kind of surprising obviously

[14:44] <discord-raku-bot> <Nemokosch> consistent?

[14:45] <discord-raku-bot> <Nemokosch> but is it something the user should care about?

[14:45] <discord-raku-bot> <Nemokosch> is this something _right_, even?

[14:45] <Voldenet> if you return Int:D from method, it should be assignable to Int:D

[14:46] <lizmat> perhaps...    Nil predates having complete :D support

[14:46] <lizmat> so perhaps it not failing was an oversight

[14:46] <lizmat> for returning Nil

[14:46] <lizmat> vrurg ^^  any ideas ?

[14:46] <discord-raku-bot> <Nemokosch> the outlook of this is that the type system has a permanent leak on values that will come up every now and then

[14:48] <discord-raku-bot> <Nemokosch> But even with a sole Int, shouldn't the missing value be (Int), as if there was indeed an assigment?

[14:49] <discord-raku-bot> <Nemokosch> and this is were failures kick in again, as they descend from Nil but don't behave like Nil

[14:57] <Voldenet> I'm not sure how jit is supposed to handle this

[14:58] <Voldenet> is there even a way to say that `this returns int always`?

[14:59] <Voldenet> I mean uh, I know

[14:59] <Voldenet> m: sub x() returns int { Nil }; x().say

[14:59] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Cannot unbox a type object (Nil) to int.‚ê§  in sub x at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[15:00] <Voldenet> but perhaps it would be more useful if it type system was more constrained

[15:01] <lizmat> perhaps, but it would have to be a 6.e feature, as otherwise I think too much code will start to fail in the wild

[15:02] <lizmat> Possibly even a 6.f feature by now

[15:02] <Voldenet> I suppose it is a big breaking change

[15:02] <lizmat> afk for a few hours&

[15:18] <discord-raku-bot> <Nemokosch> Issue created

[15:19] <Voldenet> Nemokosch++

[15:19] <discord-raku-bot> <Nemokosch> One day, I will at least write a post about != and ne, that one is really a chest full of treasure, there could be so many acceptable and fully working solutions there

[15:20] <discord-raku-bot> <Nemokosch> this one is tougher but also more important in a way

[15:21] <Voldenet> im a lot of programming languages `x != y` is not equal to `!(x == y)`

[15:22] <Voldenet> also `x == y` is not equal to `y == x`

[15:30] <Voldenet> less surprisingly it's a result of convenient conversions

[15:33] <Voldenet> m: my $nil-assigned = Nil; say $nil-assigned ~~ Nil;

[15:33] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´False‚ê§¬ª

[15:33] <Voldenet> m: my $nil-assigned = Nil; say Nil ~~ $nil-assigned;

[15:33] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´True‚ê§¬ª

[15:33] <Voldenet> Ah yes.

[15:36] <Voldenet> but it's described in docs, so it's hrdly surprising

[15:36] <gfldex> Smartmatching against Nil is a big code smell.

[15:39] <Voldenet> having `Nil` anywhere near the code is a big code smell ;)

[15:39] <gfldex> There can be very good reason to return Nil explicitely.

[15:42] <Voldenet> with good enough reason you can also juggle null pointers casually, but it's still smelly code

[15:44] *** linkable6 left
[15:44] *** evalable6 left
[15:45] *** linkable6 joined
[15:46] *** evalable6 joined
[15:55] <discord-raku-bot> <Nemokosch> Having Failure is Nil is language smell

[15:56] <discord-raku-bot> <Nemokosch> Voldenet: I'm arguing that != should indeed not be a shorthand for !( x == y)

[15:57] <discord-raku-bot> <Nemokosch> And I'm not the first one actually

[15:59] <Voldenet> I do like my boolean algebra working though

[15:59] *** discord-raku-bot left
[15:59] *** discord-raku-bot joined
[16:03] <Voldenet> messing with equality leads you to creation of `equals` method

[16:04] <Voldenet> (keep in mind missing `notEquals` method)

[16:51] *** silug left
[17:01] <sjn> heya; folks. I'm trying to build raku, and getting some linking issues with libmoar.so, during Configure.pl 

[17:01] <sjn> anyone who has similar issues here?

[17:04] <sjn> here's the error: /usr/bin/ld: ./libmoar.so: undefined reference to `uv__cloexec_ioctl'

[17:07] <sjn> Hm. looks like my nqp dir was outdated, and Configure.pl didn't fix that

[17:09] <Voldenet> apparently bad version of libuv was linked, btw

[17:12] <Voldenet> but nevermind

[17:15] <sjn> deleting the nqp dir seems to do the trick, though I kinda expected that to have happened when I ran "make distclean" earlier.... :-|

[17:16] <sjn> (libuv was found somewhere deep below in that dir)

[17:17] <sjn> ...so in other words, rebuilding raku from git when there are files lying around from a previous build, is a bit meh

[17:17] <sjn> "make distclean" ought to have fixed that, tbh

[17:20] *** silug joined
[18:02] <lizmat> sjn: could you please make an issue for that?  It's been bugging me a few times as well

[18:05] <leont> I've seen such issues before, it happens sometimes and it is annoying

[18:06] *** reportable6 left
[18:07] *** reportable6 joined
[18:09] <discord-raku-bot> <Nemokosch> Voldenet: bad news, !(x == y) gets in the way here

[18:09] <discord-raku-bot> <Nemokosch> Hint: Junctions

[18:18] <Voldenet> no wonder I didn't think of it, I don't know how to use junctions :D

[18:19] <Voldenet> I mean uh, I know the syntax and all, I just don't know where to apply them

[18:49] *** Altai-man joined
[18:50] <discord-raku-bot> <Nemokosch> Fair enough, perhaps nobody really knows

[18:50] <discord-raku-bot> <Nemokosch> anyway, (1, 4, 6).all >= 2 does mean "all these numbers are at least two", and will eventually collapse to False

[18:51] <discord-raku-bot> <Nemokosch> but (1, 4, 6).all != 1 will collapse to True, because it expands to !((1, 4, 6).all == 1) ü§¶‚Äç‚ôÇÔ∏è

[18:52] <discord-raku-bot> <Nemokosch> and like this is a design decision, mind you. There is nothing that keeps it from being consistent

[18:53] <discord-raku-bot> <Nemokosch> != and ne aren't operators that are allowed to act upon the individual values because Larry Wall said something about how English natives expect the negation to be lifted

[18:55] <discord-raku-bot> <Nemokosch> maybe this is an oversimplification but I'm fairly certain if it wasn't for Larry's insisting that this makes sense, it would have never happened

[18:56] <Voldenet> that's the problem of junctions though

[18:57] <discord-raku-bot> <Nemokosch> Not really

[18:57] <Voldenet> you can't simply apply logic operators to junctions

[18:57] <discord-raku-bot> <Nemokosch> The junctions would be able to handle != and ne on individual values

[18:57] <discord-raku-bot> <Nemokosch> no logic operators involved

[18:57] <Voldenet> (1, 4, 6).all != 1 => (1, 4, 6).none == 1

[18:57] <discord-raku-bot> <Nemokosch> the sole fact that NO, != and ne do NOT contain logic operators

[18:57] <discord-raku-bot> <Nemokosch> they are _just operators_

[18:58] <Voldenet> negation is logic operator

[18:58] *** Sgeo joined
[18:59] <discord-raku-bot> <Nemokosch> != is one operator, let alone ne

[18:59] <discord-raku-bot> <Nemokosch> ne cannot even be argued to contain a logic operator

[18:59] <discord-raku-bot> <Nemokosch> and inbefore yes, I do know that the design decision was to make them meta-involved

[18:59] <discord-raku-bot> <Nemokosch> but like why unnecessarily break the expectation that they are operators?

[19:00] <discord-raku-bot> <Nemokosch> that's why I brought >=, you know

[19:01] <discord-raku-bot> <Nemokosch> this is the exact reason

[19:01] <discord-raku-bot> <Nemokosch> >= is indeed not implemented as !<

[19:01] <discord-raku-bot> <Nemokosch> >= is real but by deliberate design, != is not real, even though they could be, like in all other languages where this even comes up

[19:01] <discord-raku-bot> <Nemokosch> != could visually be <> by the same chance, like back in the Pascal days

[19:01] <Voldenet> Sure, while it's very practical to implement just equality matching

[19:02] <Voldenet> it won't work in this case

[19:03] <discord-raku-bot> <Nemokosch> I mean, for yourself, you can decide to implement not equal as not ( equal )

[19:03] <discord-raku-bot> <Nemokosch> but why should they be allowed to introduce inconsistencies with built-in stuff that led to the creation of the Mu type in the first place?

[19:05] <discord-raku-bot> <Nemokosch> the fact that you _have to_ convert @values.all != $value into @values.none == $value is both against TIMTOWDY and I'd argue general linguistic inclusivity, as "none" is quite characteristically an anglo concept

[19:05] <discord-raku-bot> <Nemokosch> I wouldn't bring these things up if I weren't repeatedly told how much Raku is about the community and the high ideals

[19:05] <discord-raku-bot> <Nemokosch> and escaping anglocentrism in particular is an ideal I very much admire

[19:07] <Voldenet> junctions are very anglocentric

[19:09] <discord-raku-bot> <Nemokosch> that should mean it's an easy target

[19:09] <discord-raku-bot> <Nemokosch> and since there are still usability issues with junctions, maybe it's not late to target them with this, in particular

[19:10] <discord-raku-bot> <Nemokosch> that there is a non-technical issue around the design of junctions

[19:10] <Voldenet> forall((1, 4, 6), * >= 2) would be more universal

[19:10] <Voldenet> or `!exists((1, 4, 6), * < 2)`

[19:11] <Voldenet> since it's `forall` handling operators, it can introduce special cases

[19:11] <discord-raku-bot> <Nemokosch> the big idea of junctions (if it is really a "big" idea) is that it's a type

[19:11] <discord-raku-bot> <Nemokosch> not a utility function but something built-in that works with quite literally anything that takes any

[19:11] <discord-raku-bot> <Nemokosch> like subscripts

[19:12] <Voldenet> which leads us to operator overloading

[19:12] <Voldenet> and more and more anglocentric design

[19:15] <Voldenet> it's not the problem with `(*!=*)` => `!(*==*)` transformation, it's that the junctions define their special case for this

[19:16] <discord-raku-bot> <Nemokosch> why does it lead us to operator overloading? operator overloading, in the Pythonic, C++ish sense is virtually nonexistent in Rkau

[19:16] *** deoac joined
[19:16] <Voldenet> because essentially, operators can't be used on junctions, junctions use operators for the outcome

[19:17] <leont> ‚Ä¶ I can't follow you now

[19:17] <discord-raku-bot> <Nemokosch> If the operator is defined with Any

[19:17] <discord-raku-bot> <Nemokosch> If I were to guess, this ! meta-magic happens on Mu level

[19:18] <discord-raku-bot> <Nemokosch> so != takes up Mu values and already makes the "conversion"

[19:18] <discord-raku-bot> <Nemokosch> transposal, rather

[19:18] *** deoac left
[19:18] *** deoac joined
[19:19] <leont> Like, I get that negated operators can be confusing, but I don't see the problem with any operators

[19:19] <discord-raku-bot> <Nemokosch> and then == is defined on Any

[19:19] <leont> And part of the difficulty is that the current behavior is sensible for any but not for all, but any is much more common than all so I think it's the right call

[19:21] <leont> Negating the junction instead of negating the operator is almost always the sensible solution though

[19:23] <discord-raku-bot> <Nemokosch> the current behavior is not sensible for any, either

[19:23] <discord-raku-bot> <Nemokosch> and like I'm not the first one to discover that - it came up in 2016 already, there is a rakudo issue as well, and Liz opened a pull request to change it but gave up because of the lack of consensus

[19:26] <discord-raku-bot> <Nemokosch> (1, 2, 3).any != 2 -> "if any of the values are not 2"? "if any of the values are different from 2"? "if any of the values are greater or less than 2"?

[19:26] <discord-raku-bot> <Nemokosch> doesn't match the semantics all these sentences set up

[19:28] <discord-raku-bot> <Nemokosch> and the bigger problem is: if you picked ANY OPERATOR that isn't != or ne, it would match that semantics

[19:28] <discord-raku-bot> <Nemokosch> including >= <= stuff

[19:28] <discord-raku-bot> <Nemokosch> because it was insisted that != and ne not be real first-class operators

[19:29] <Voldenet> m: say (1, 2, 6).all .is-prime

[19:29] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´all(False, True, False)‚ê§¬ª

[19:30] <Voldenet> m: sub my-prime { $^x.is-prime };  say (1, 2, 6).all my-prime;

[19:30] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> ime { $^x.is-prime };  say (1, 2, 6).all‚èè my-prime;‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        stateme‚Ä¶¬ª

[19:30] <Voldenet> m: sub my-prime { $^x.is-prime };  say (1, 2, 6).all .&my-prime;

[19:30] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Malformed postfix call (only basic method calls that exclusively use a dot can be detached)‚ê§at <tmp>:1‚ê§------> e { $^x.is-prime };  say (1, 2, 6).all .‚èè&my-prime;‚ê§¬ª

[19:31] <Voldenet> junctions have some rough edges

[19:31] <vrurg> lizmat: Nil is bypassing any type checks. No exceptions. In part, this is what allows fails to be use used pretty much everywhere.

[19:32] <discord-raku-bot> <Nemokosch> this is core Raku syntax though

[19:32] *** Nemokosch joined
[19:32] <Nemokosch> m: sub my-prime { $^x.is-prime };  say (1, 2, 6).all.&my-prime;

[19:32] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´all(False, True, False)‚ê§¬ª

[19:33] <Voldenet> ah, right, it's about .& op being hacky

[19:34] <discord-raku-bot> <Nemokosch> vrurg: fails could do this on their own without Nil being involved, no?

[19:34] <discord-raku-bot> <Nemokosch> It could be rephrased as "Failure is bypassing any type checks, no exceptions"

[19:34] <discord-raku-bot> <Nemokosch> and then Nil could be safely used for one purpose: "the absence of a value"

[19:34] *** Nemokosch left
[19:42] *** deoac2 joined
[19:44] *** deoac2 left
[19:44] *** deoac17 joined
[19:45] *** deoac17 left
[19:50] *** [Coke] left
[20:04] *** vrurg_ joined
[20:04] *** vrurg left
[20:13] *** Altai-man left
[20:20] <vrurg_> Nemokosch: Consider this way: Nil is a polite way of informing about a problem. Fail is "the last call". Throwing is the ultimate.

[20:20] <tellable6> vrurg_, I'll pass your message to Nemokosch

[20:20] *** vrurg_ is now known as vrurg

[20:22] <vrurg> Nemokosch: another thing, a container may have a default value to which it is gets reset when assigned with Nil. From this perspective returning Nil also makes full sense.

[20:22] <tellable6> vrurg, I'll pass your message to Nemokosch

[20:27] <Voldenet> you can return thing of type Int:D that can't be assigned to Int:D later

[20:30] <Voldenet> m: sub get-thing() returns Int:D { Nil }; sub use-thing(Int:D $thing) { say $thing; }; my $x = get-thing() xx 3; use-thing($x[0])

[20:30] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Type check failed in binding to parameter '$thing'; expected Int but got Nil (Nil)‚ê§  in sub use-thing at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[20:33] <Voldenet> well, can't be assigned to Int either

[21:15] <discord-raku-bot> <Nemokosch> vrurg: I get how Nil and Failure can both make sense; my point is that making a connection between them is troublesome

[21:16] <discord-raku-bot> <Nemokosch> without that connection, it would really be "up to us" to deal with the code Voldenet sent. If Nil is absence, it could either be enforced to become Int when the function gives the return value - or it could be a compile error or something

[21:17] <discord-raku-bot> <Nemokosch> However, if we want to allow Failures at all, essentially one needs to keep pretending they aren't some sort of Nil

[21:18] <vrurg> Nemokosch: there will be no way to distinct a Nil return from Int when the latter is returned. See my comment in the problem-solving issue, actually. But the point is both Nil and Failure are actually "no value". But the latter is a _problematic_ no value.

[21:18] <tellable6> vrurg, I'll pass your message to Nemokosch

[21:19] <discord-raku-bot> <Nemokosch> it would be better if one didn't have to "pretend" but they really wouldn't be a sort of Nil

[21:19] <discord-raku-bot> <Nemokosch> after all, they don't really fulfill the expectations Nil sets

[21:20] <discord-raku-bot> <Nemokosch> Anyway, it's okay if it is "no value" but perhaps it still shouldn't be mixed up with the absence of a value. Because it's not that and it doesn't behave like that.

[21:20] *** linkable6 left
[21:20] *** evalable6 left
[21:21] <vrurg> An absence is singalled by undefinedness. I.e. by a type object. More over, the convenience is that absence can tell the type of the absent value. :)

[21:22] *** evalable6 joined
[21:22] *** linkable6 joined
[21:25] <discord-raku-bot> <Nemokosch> And Nil is the typed undefinedness

[21:25] <discord-raku-bot> <Nemokosch> and Failures are not undefinedness

[21:28] <vrurg> They are too, but they're more than that.

[21:31] <vrurg> And, BTW, failures actually only match to Mu/Any, but explode for any other typecheck.

[21:31] <vrurg> ... typecheck on assignement.

[21:36] <discord-raku-bot> <Nemokosch> ... and to Nil :DDD

[21:37] <discord-raku-bot> <Nemokosch> Something that holds a value that you need to store and retrieve is not a "missing value"

[21:38] <discord-raku-bot> <Nemokosch> Simply by the fact that you need to store it

[21:38] <discord-raku-bot> <Nemokosch> Also, this is not directed towards you in particular, I just notice that it's really hard to discuss these things because of a certain prejudice

[21:39] <discord-raku-bot> <Nemokosch> Just because you (or even me, in certain cases) know why something works that way internally, won't make that behavior sane per se

[21:42] <discord-raku-bot> <Nemokosch> it helps thinking about what lead to the anomaly but won't make the anomaly go away

[21:45] *** avuserow left
[21:48] <discord-raku-bot> <Nemokosch> Just think of Javascript. As I have read You Don't Know JS, I have to say, JS type coercion rules are mostly sane. There are only a few choices that I don't agree with, and even less that introduce inconsistencies (like [] converting to '' and 0, while being a truthy value). Yet, Javascript is remembered as the lunatic, 10-days language, and most of the clich√© WTFs lead to coercion rules or hoisting.

[21:49] <discord-raku-bot> <Nemokosch> Of course Javascript had such a headstart with the browser that this reputation couldn't kill it still, but Raku doesn't have any similar headstart.

[21:49] <Voldenet> just remember that `[] - {}` is not a number

[21:50] <Voldenet> valid

[21:50] <discord-raku-bot> <Nemokosch> üòÇ

[21:50] <discord-raku-bot> <Nemokosch> fair

[21:50] <discord-raku-bot> <Nemokosch> even - {} is not a number, is it üòÑ

[21:51] <Voldenet> ofc

[21:51] <discord-raku-bot> <Nemokosch> but {} - [] is 0 I think

[21:51] <Voldenet> unlike `[] - []` which clearly is 0

[21:51] <discord-raku-bot> <Nemokosch> oh sorry, `-0`

[21:52] <discord-raku-bot> <Nemokosch> still fair xD

[21:53] <discord-raku-bot> <Nemokosch> and I have to say, many of these WATs in Raku don't seem justified at all, there is either no feedback on why they have to be like that, or that feedback is very unconvincing...

[21:56] <Voldenet> Though maybe Nil should be hiden behind some black magic namespace

[21:56] <Voldenet> it's clearly not something sane code should use

[21:56] <Voldenet> it's more like internal type system related thing

[21:57] <discord-raku-bot> <Nemokosch> well, that's how vrurg made it sound for sure

[21:57] <discord-raku-bot> <Nemokosch> and what really reassures me about these WATs is when I notice that "somebody was faster"

[21:57] <discord-raku-bot> <Nemokosch> somebody has already noticed that very same thing and asked about it some way

[21:59] <Voldenet> m: sub x() returns Int:D { Nil }; x

[21:59] <camelia> rakudo-moar dc180bd95: ( no output )

[21:59] <Voldenet> m: use nqp; sub x() returns Int:D { nqp::null() }; x

[21:59] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Type check failed for return value; expected Int:D but got Mu (Mu)‚ê§  in sub x at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:00] <Voldenet> nqp::null() is safet ro use than Nil

[22:00] <Voldenet> s/safet ro/safer to/

[22:01] <discord-raku-bot> <Nemokosch> the justified ancients of Mu Mu

[22:01] <vrurg> Voldenet: Then just use Mu instead.

[22:02] <Voldenet> problem is that any lib can use Nil instead

[22:03] <vrurg> I have a string feeling that what you, ppl, need is just an undefined value. If you don't understand Nil then you likely not using it the way it is supposed to be used.

[22:03] <vrurg> I myself normally avoid it because there are better ways.

[22:03] <lizmat> in that case, I'd say Any is what you're looking for

[22:03] <Voldenet> Yes, indeed

[22:03] <vrurg> *strong feeling

[22:05] <Voldenet> you're assuming that producer of the code is also consuming the code

[22:05] <discord-raku-bot> <Nemokosch> ^^

[22:05] <Voldenet> type safety of libs become the problem

[22:05] <discord-raku-bot> <Nemokosch> And where is the compiler to tell you (or others, for that matter) that you are drilling a hole in the type system, for example?

[22:06] <Voldenet> I'm expecting some objective-c to default to using Nil

[22:06] <Voldenet> s/objective-c/objective-c programmers/

[22:06] <vrurg> m: sub foo(--> Int:D) { Nil }; my Int:D $v = foo;

[22:06] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Type check failed in assignment to $v; expected Int:D but got Int (Int) (perhaps Nil was assigned to a :D which had no default?)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:07] <vrurg> This is it. This is how things are to be done.

[22:07] <vrurg> If strict typing is required.

[22:07] * lizmat calls it a day

[22:07] <discord-raku-bot> <Nemokosch> Voldenet made a pretty good example that counteracts this

[22:08] <discord-raku-bot> <Nemokosch> > sub get-thing() returns Int:D { Nil }; sub use-thing(Int:D $thing) { say $thing; }; my $x = get-thing() xx 3; use-thing($x[0])

[22:08] <vrurg> Which one? I don't have time to follow everything here.

[22:08] <vrurg> m: sub get-thing() returns Int:D { Nil }; sub use-thing(Int:D $thing) { say $thing; }; my $x = get-thing() xx 3; use-thing($x[0])

[22:08] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Type check failed in binding to parameter '$thing'; expected Int but got Nil (Nil)‚ê§  in sub use-thing at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:08] <vrurg> First of all, we do get a typecheck error here.

[22:09] <vrurg> Second:

[22:09] <Voldenet> error on use

[22:09] <vrurg> m: sub get-thing() returns Int:D { Nil }; sub use-thing(Int:D $thing) { say $thing; }; my Int:D @x = get-thing() xx 3; use-thing($x[0])

[22:09] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Variable '$x' is not declared.  Did you mean '@x'?‚ê§at <tmp>:1‚ê§------>  Int:D @x = get-thing() xx 3; use-thing(‚èè$x[0])‚ê§¬ª

[22:09] <discord-raku-bot> <Nemokosch> that sub lied like a boss üòÑ

[22:09] <vrurg> m: sub get-thing() returns Int:D { Nil }; sub use-thing(Int:D $thing) { say $thing; }; my Int:D @x = get-thing() xx 3; use-thing(@x[0])

[22:09] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Type check failed in assignment to @x; expected Int:D but got Int (Int) (perhaps Nil was assigned to a :D which had no default?)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:09] <discord-raku-bot> <Nemokosch> yes - from a function that should actually produce Int:D

[22:09] <discord-raku-bot> <Nemokosch> because that's its signature

[22:09] <Voldenet> the more complex codebase, the harder will it be to find out what's the problem

[22:09] <discord-raku-bot> <Nemokosch> it cannot be trusted

[22:10] <vrurg> Voldenet: that's why you use typing in that codebase. Not `my $x` where you expect a typed array, but `my Int:D @x`.

[22:10] <Voldenet> this is not helpful at all

[22:10] <vrurg> Why?????

[22:10] <Voldenet> you're filling the codebase with all the pointless types

[22:10] <Voldenet> the only functions that are interested in those types are `get-thing` and `use-thing`

[22:11] <vrurg> C'mon, tell this to Rust people where everything typed! 

[22:11] <discord-raku-bot> <Nemokosch> even Rust strongly relies on type inference though

[22:11] <Voldenet> Not really!

[22:12] <vrurg> Either way, I would keep away from big codebase which blindly trusts third-party libraries. They're not proven to be bugless. Also, a module/lib dev must document the return values, Nil too.

[22:12] <discord-raku-bot> <Nemokosch> I have an urge to call this "type sanity" instead of "type safety" üòÖ

[22:12] <vrurg> Rust infers types, as far as I remember.

[22:12] <vrurg> Any way, the principle of 'better safe than sorry' is working.

[22:13] <discord-raku-bot> <Nemokosch> because it's "type safe" in the sense that the supposed types match - however it's not "type sane" because an unchecked type got in and broke all expectations

[22:13] <vrurg> So, either one is toying with code and can allow themselve skip types. Or it's something serious and types are used anywhere there are doubts.

[22:13] <Voldenet> > sub get-thing() returns Int:D { my Int:D $x = third-party-value; $x };

[22:14] <Voldenet> it's extremely weird code right there

[22:14] <vrurg> Ok, I have a lot of work for today. Just have nothing else to add.

[22:15] <discord-raku-bot> <Nemokosch> vrurg: you know

[22:15] <discord-raku-bot> <Nemokosch> Many people (who aren't us)

[22:15] <discord-raku-bot> <Nemokosch> would keep away from a language where something that is Nil is not Nil but something that is not Nil is Nil

[22:15] <discord-raku-bot> <Nemokosch> so I think you're sitting backwards on that horse

[22:15] <vrurg> Voldenet: it's simpler as `sub get-thing(--> Int:D) { my Int:D $ = foo }`

[22:16] * vrurg is afk&

[22:16] <Voldenet> I'm not getting my pitchfork for this, it's not worth fighting for, let's just hope nobody uses Nil ;)

[22:18] <discord-raku-bot> <Nemokosch> Frankly, those people who want to be safe all the time and get their money on time, won't choose Raku as it is now. I'm definitely not that type of person.

[22:19] <discord-raku-bot> <Nemokosch> I'm okay with reporting issues, looking for a module that may be somewhat similar to what I want to do, polishing code just for the sake of it

[22:19] <discord-raku-bot> <Nemokosch> But this "git gud" attitude is a sure way to keep those others away from this language

[22:28] <ugexe> there are no perfect tradeoffs

[22:28] <ugexe> unless i did them

[22:29] <Voldenet> ;D

[22:29] <Voldenet> I think in objective-c you can assign nil to NSNumber, btw

[22:30] <ugexe> m: my Int:D $x is default(42) = Nil # there is also this behavior

[22:30] <camelia> rakudo-moar dc180bd95: ( no output )

[22:31] <Voldenet> the thing I'm on about is the discrepancy between returned type and the one accepted for the container

[22:36] <discord-raku-bot> <Nemokosch> zef install Ugexe::Tradeoffs

[22:36] <Voldenet> :)

[22:38] <discord-raku-bot> <Nemokosch> And like apparently the container isn't even needed for the check, right? A binding is enough.

[22:40] <Voldenet> > Any method call on Nil of a method that does not exist, and consequently, any subscripting operation, will succeed and return Nil.

[22:40] <Voldenet> m: say Nil.CALL-ME()

[22:40] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´No such method 'CALL-ME' for invocant of type 'Nil'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:40] <Voldenet> uh

[22:42] <Voldenet> m: say Nil()

[22:42] <camelia> rakudo-moar dc180bd95: OUTPUT: ¬´Nil‚ê§¬ª

[22:43] <ugexe> https://github.com/rakudo/rakudo/blob/9b13a55a12b4c2708c842ed864c673c1de1d7a46/src/Perl6/bootstrap.c/BOOTSTRAP.nqp#L3866

[22:43] <ugexe> looks like the code for CALL-ME() goes through a different code path than most others

[22:44] <ugexe> eh thats !moar tho

[22:45] *** linkable6 left
[22:45] *** evalable6 left
[22:45] *** evalable6 joined
[22:45] <Voldenet> not like I'm expecting to use Nil any time soon, but it is sufficiently weird

[22:46] *** linkable6 joined
[22:47] <Voldenet> it's a tool that looks like it only invites subtle bugs into well-typed code

[22:48] *** pamplemousse joined
[22:49] <discord-raku-bot> <Nemokosch> (Any) is my favorite Nil

[22:49] <discord-raku-bot> <Nemokosch> :PP

[22:53] *** deoac left
[22:53] <Voldenet> i'm looking through codebases and in most cases (Any) would be better

[22:55] *** deoac joined
[22:55] <Voldenet> there are some null object design pattern uses tho

[22:56] <Voldenet> but after seeing number of occurences, I understand why can't it be changed easily

[22:57] <discord-raku-bot> <Nemokosch> Well that's still no reason to make Failures descend from Nil...

[22:58] *** pamplemousse left
[23:24] <Voldenet> they don't behave like Nil anyway, I'm pondering why

[23:58] *** evalable6 left
[23:58] *** linkable6 left
[23:59] *** linkable6 joined
