[00:07] *** reportable6 left
[00:08] *** reportable6 joined
[00:10] *** [Coke] left
[00:20] *** [Coke] joined
[00:50] *** simcop2387 joined
[00:52] *** perlbot joined
[01:07] *** kjp left
[01:29] *** perlbot left
[01:30] *** simcop2387_ joined
[01:30] *** simcop2387 left
[01:31] *** simcop2387_ is now known as simcop2387

[01:33] *** perlbot joined
[01:37] *** Sankalp left
[01:38] *** Sankalp joined
[01:57] *** frost joined
[02:15] *** Sankalp left
[02:17] *** Sankalp joined
[03:17] *** linkable6 left
[03:17] *** bloatable6 left
[03:17] *** benchable6 left
[03:17] *** evalable6 left
[03:17] *** greppable6 left
[03:17] *** notable6 left
[03:17] *** statisfiable6 left
[03:17] *** quotable6 left
[03:17] *** unicodable6 left
[03:17] *** releasable6 left
[03:17] *** shareable6 left
[03:17] *** coverable6 left
[03:17] *** sourceable6 left
[03:17] *** committable6 left
[03:17] *** reportable6 left
[03:17] *** tellable6 left
[03:17] *** nativecallable6 left
[03:17] *** bisectable6 left
[03:17] *** linkable6 joined
[03:17] *** evalable6 joined
[03:18] *** quotable6 joined
[03:18] *** benchable6 joined
[03:18] *** notable6 joined
[03:18] *** unicodable6 joined
[03:18] *** coverable6 joined
[03:19] *** bloatable6 joined
[03:19] *** statisfiable6 joined
[03:19] *** sourceable6 joined
[03:19] *** greppable6 joined
[03:19] *** bisectable6 joined
[03:20] *** committable6 joined
[03:20] *** shareable6 joined
[03:20] *** tellable6 joined
[03:20] *** releasable6 joined
[03:20] *** reportable6 joined
[03:20] *** nativecallable6 joined
[03:59] *** simcop2387 left
[03:59] *** perlbot left
[04:09] *** simcop2387 joined
[04:10] *** perlbot joined
[04:18] *** vrurg_ joined
[04:18] *** vrurg left
[05:18] *** nativecallable6 left
[05:18] *** unicodable6 left
[05:18] *** statisfiable6 left
[05:18] *** tellable6 left
[05:18] *** notable6 left
[05:18] *** reportable6 left
[05:18] *** coverable6 left
[05:18] *** quotable6 left
[05:18] *** evalable6 left
[05:18] *** committable6 left
[05:18] *** benchable6 left
[05:18] *** shareable6 left
[05:18] *** linkable6 left
[05:18] *** greppable6 left
[05:18] *** sourceable6 left
[05:18] *** bisectable6 left
[05:18] *** bloatable6 left
[05:18] *** releasable6 left
[05:19] *** evalable6 joined
[05:19] *** releasable6 joined
[05:19] *** bisectable6 joined
[05:19] *** sourceable6 joined
[05:20] *** bloatable6 joined
[05:20] *** statisfiable6 joined
[05:20] *** tellable6 joined
[05:20] *** greppable6 joined
[05:20] *** quotable6 joined
[05:20] *** reportable6 joined
[05:20] *** nativecallable6 joined
[05:21] *** committable6 joined
[05:21] *** benchable6 joined
[05:21] *** coverable6 joined
[05:21] *** unicodable6 joined
[05:21] *** notable6 joined
[05:21] *** linkable6 joined
[05:22] *** shareable6 joined
[06:09] *** reportable6 left
[06:09] *** reportable6 joined
[06:51] *** ToddAndMargo joined
[07:03] *** Sgeo left
[07:43] *** ProperN[out] left
[07:44] *** ProperNoun joined
[07:59] *** Kaiepi left
[07:59] *** Kaiepi joined
[08:05] *** sena_kun joined
[08:19] *** abraxxa joined
[08:25] *** kaskal left
[08:26] *** abraxxa left
[08:26] *** abraxxa joined
[08:53] *** lockywolf_ joined
[08:54] *** lucs left
[08:54] *** lucs joined
[08:54] *** lockywolf left
[08:55] *** lockywolf_ is now known as lockywolf

[09:12] *** lichtkind joined
[09:15] *** Kaiepi left
[09:19] *** Sankalp left
[09:21] *** Sankalp joined
[09:36] *** mexen joined
[09:44] *** jaguart joined
[10:04] <jjatria> melezhik: I saw that you had sent it, but I haven't had a chance to take a proper look. I'll try to look at it over the weekend üôá 

[10:04] <tellable6> jjatria, I'll pass your message to melezhik

[10:05] *** Altai-man joined
[10:31] *** sena_kun_ joined
[10:31] *** Altai-man left
[11:14] *** sacomo left
[11:34] <SmokeMachine> s/suiting/studying/

[11:34] <SmokeMachine> m: use v6.e.PREVIEW; m: my @a=<a b c d>; my %h{||@a} = True; dd %h;

[11:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Invalid hash shape; type expected‚ê§at <tmp>:1‚ê§------> PREVIEW; m: my @a=<a b c d>; my %h{||@a}‚èè = True; dd %h;‚ê§    expecting any of:‚ê§        constraint‚ê§¬ª

[11:36] <SmokeMachine> gfldex: I think that's the way I mostly use .none... :) Good to know I was useful for something...

[11:38] <SmokeMachine> m: use v6.e.PREVIEW; my @a=<a b c d>; my %h{||@a} = True; dd %h;

[11:38] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Invalid hash shape; type expected‚ê§at <tmp>:1‚ê§------> .e.PREVIEW; my @a=<a b c d>; my %h{||@a}‚èè = True; dd %h;‚ê§    expecting any of:‚ê§        constraint‚ê§¬ª

[11:39] <SmokeMachine> m: use v6.e.PREVIEW; my @a=<a b c d>; (my %h){||@a} = True; dd %h

[11:39] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Hash %h = {:a(${:b(${:c(${:d(Bool::True)})})})}‚ê§¬ª

[11:50] *** frost left
[12:00] *** frost joined
[12:05] *** frost left
[12:08] *** reportable6 left
[12:11] *** reportable6 joined
[12:54] *** habu joined
[12:55] <habu> Hello, does Raku have fast native shaped arrays a-la-numpy?

[12:56] <habu> or, better, is it straightforward to use numpy with Inline::Python

[13:08] *** habu left
[13:10] <SmokeMachine> lizmat: maybe that's not rak's duty but would it make sense to allow something like this? `rak --allow-json --allow-yaml '*.<bla>.defined'` and that would parse any json or yaml files and show the ones that has a `bla` key defined at the structure of the document? Maybe 2 patterns, one when the file is json/yaml and other when its not? (Sorry, I'm just asking because I just needed something like that.)

[13:13] <lizmat> well, we already have JSON::Fast as a dependency, so handling JSON files would be trivial

[13:13] <lizmat> hmmm

[13:14] <discord-raku-bot> <Nemokosch> by the way, I suspect JSON::Fast might be still way too slow

[13:15] <lizmat> Nemokosch: perhaps, but "rak" is not about speed, but about features  :-)

[13:15] <tellable6> lizmat, I'll pass your message to Nemokosch

[13:15] <lizmat> much like Raku for that matter

[13:15] <discord-raku-bot> <Nemokosch> well, for rak, it would be good to keep it useful

[13:16] <discord-raku-bot> <Nemokosch> what's the use of finding the needle in the haystack if it turned winter in the meantime

[13:17] <lizmat> well, I keep efficiency in mind, but not at all cost

[13:17] <discord-raku-bot> <Nemokosch> by the way, no, perhaps it's not JSON::Fast that is too slow

[13:17] <discord-raku-bot> <Nemokosch> took around 10 seconds to parse a 4,5 MB JSON string

[13:17] <discord-raku-bot> <Nemokosch> that's okay by me

[13:17] <discord-raku-bot> <Nemokosch> well then I have no idea what Cro is doing with that request...

[13:18] <SmokeMachine> But it would only be slower if a flag was used...

[13:19] <lizmat> Nemokosch: if the outer part of your JSON is an array, you could use https://raku.land/zef:lizmat/JSON::Fast::Hyper to make things about 3x as fast

[13:19] <tellable6> lizmat, I'll pass your message to Nemokosch

[13:20] <discord-raku-bot> <Nemokosch> I'm afraid that isn't the case

[13:20] <discord-raku-bot> <Nemokosch> but I wonder

[13:20] <discord-raku-bot> <Nemokosch> it takes around 10 seconds for Cro to get a response

[13:21] <SmokeMachine> lizmat: would that also be faster for something like `{ "count": 999999999, "items": [ ... ] }`?

[13:21] <discord-raku-bot> <Nemokosch> if I take the response as string and parse it with JSON::Fast, that would take an additional 10 seconds

[13:22] <discord-raku-bot> <Nemokosch> what on earth is Cro doing that it doesn't finish in a minute

[13:22] <discord-raku-bot> <Nemokosch> is it stuck?

[13:22] <SmokeMachine> (with `*.items` being an array with 999999999 items (the size is just an example))

[13:22] <lizmat> perhaps ask on #cro ?

[13:23] <SmokeMachine> is there a #rak? or should I keep asking/suggesting stuff about oak here?

[13:24] <SmokeMachine> s/oak/rak/

[13:24] <lizmat> there's no #rak, but maybe there should be a #raku-rak ?

[13:24] <lizmat> but I'm happy with rak being mentioned here  :-)

[13:24] <lizmat> for now, anyway

[13:24] <SmokeMachine> :)

[13:25] *** Nemokosch joined
[13:27] <SmokeMachine> now I thought about auto-parsing json I am think if something like auto-parsing Raku would be useful, but someday it would be cool to search by RakuAST... (probably that should be a different tool...)

[13:35] <lizmat> fwiw, I intend rak to be a customizable swiss-army knife :-)

[14:03] *** dogbert17 left
[14:14] *** Nemokosch left
[14:32] *** dogbert17 joined
[14:35] *** dogbert11 joined
[14:38] *** ToddAndMargo left
[14:39] *** dogbert17 left
[14:40] *** Nemokosch joined
[14:58] *** dogbert17 joined
[15:01] *** dogbert11 left
[15:15] *** abraxxa left
[15:18] *** abraxxa-home joined
[15:26] *** kaskal joined
[15:26] *** dogbert17 left
[15:30] <SmokeMachine> lizmat: so, searching by Raku's (and maybe other languages) AST is an option?

[15:32] *** kaskal left
[15:38] <SmokeMachine> lizmat: could/should it have different treats/plugins for each file type?

[15:42] <SmokeMachine> lizmat: should the block needle be able to receive an IO::Path instead of the content of the file? (or maybe something like IO::Path but also with the content, maybe the content as a Supply, something like node's vinyl-file (https://github.com/gulpjs/vinyl))

[15:43] <SmokeMachine> that way you could also use the file name to filter

[15:46] <SmokeMachine> maybe the object representing the file could have a `.parsed` method that would return a data structure that would be the file content parsed if that's a json (for example)...that way, my first suggestion from today could be written like: `rak --allow-json --allow-yaml '*.?parsed.<bla>.defined'`

[15:47] <SmokeMachine> `rak --allow-json --allow-yaml '*.parsed andthen .<bla>.defined'

[15:49] <SmokeMachine> lizmat: (sorry for keep talking, but I got exited...)

[16:01] <SmokeMachine> excited

[16:02] *** morte_ joined
[16:11] *** Nemokosch left
[16:13] *** sena_kun_ left
[16:14] *** sena_kun_ joined
[16:18] <[Coke]> fast way to find if dupes in a list of no more than 25 items? I am doing .sort.unique.elems == $original_length

[16:23] <SmokeMachine> m: say so <a b c a d e f>.Bag.values.any > 1

[16:23] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´True‚ê§¬ª

[16:24] <SmokeMachine> m: say so <a b c a d e f>.Bag.values.max > 1

[16:24] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´True‚ê§¬ª

[16:26] *** kaskal joined
[16:27] <SmokeMachine> m: say so <a b c a d e f>.repeated

[16:27] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´True‚ê§¬ª

[16:28] <discord-raku-bot> <Nemokosch> repeated üí™

[16:30] <SmokeMachine> [Coke]: hy are you sort()ing before unique()ing? You need that for squish() but not for unique(), right?

[16:32] <[Coke]> m: my @a=<1 3 2 3>. dd @a.unique

[16:32] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Two terms in a row‚ê§at <tmp>:1‚ê§------> my @a=<1 3 2 3>. dd‚èè @a.unique‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚ê§        stat‚Ä¶¬ª

[16:32] <[Coke]> m: my @a=<1 3 2 3>; dd @a.unique

[16:32] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´(IntStr.new(1, "1"), IntStr.new(3, "3"), IntStr.new(2, "2")).Seq‚ê§¬ª

[16:33] <[Coke]> ... habit, I guess. Thank you. :)

[16:33] *** Sgeo joined
[16:34] <SmokeMachine> m: .repeated.so.say for [<a e I o u>, <a e I o u a>, <a a e I o u>]

[16:34] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´False‚ê§True‚ê§True‚ê§¬ª

[16:36] <Voldenet> not sure if using .repeated is the fastest way

[16:37] <Voldenet> m: sub has-duplicates { my $h = SetHash.new(); for @^a { return True if $h.EXISTS-KEY($_); $h.set($_) }; False }; .&has-duplicates.say for [<a e I o u>, <a e I o u a>, <a a e I o u>];

[16:37] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´False‚ê§True‚ê§True‚ê§¬ª

[16:38] <Voldenet> m: sub has-duplicates { my $h = SetHash.new(); for @^a { return True if $h{$_}; $h.set($_) }; False }; .&has-duplicates.say for [<a e I o u>, <a e I o u a>, <a a e I o u>];

[16:38] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´False‚ê§True‚ê§True‚ê§¬ª

[16:38] <discord-raku-bot> <Nemokosch> it would be pretty bizarre if it isn't, that's for sure though

[16:39] <SmokeMachine> .repeated returns a Seq, so I suppose when converting to Bool it would return on the first repeated found... but I haven't read the code yet...

[16:40] <discord-raku-bot> <Nemokosch> Oh right, there was a conversion

[16:42] <discord-raku-bot> <Nemokosch> Then it's quite possible that calculating the bool value eagerly is faster; not sure if these conversions are implemented effectively

[16:43] <Voldenet> I'm sure the above can be rewritten with nqp::hash

[16:45] *** dogbert17 joined
[16:47] <SmokeMachine> https://usercontent.irccloud-cdn.com/file/PomNp6VY/CleanShot%202022-07-20%20at%2017.47.02%402x.png

[16:48] <Voldenet> SetHash doesn't seem efficient enough compared to nqp::hash

[16:49] <Voldenet> though practically you're testing against the worst case

[16:49] <SmokeMachine> I think this is it: https://github.com/rakudo/rakudo/blob/af31b1df89e0e00b80e9481062fa34bc24b3339b/src/core.c/Any-iterable-methods.pm6#L1950-L1960

[16:49] <SmokeMachine> yes, I'm testing over the worst case...

[16:49] <SmokeMachine> s/over/against/

[16:52] <SmokeMachine> https://usercontent.irccloud-cdn.com/file/sb5547gA/CleanShot%202022-07-20%20at%2017.51.56%402x.png

[16:57] <Voldenet> .repeated.so will shortcircuit too, so to beat it by anything one would have to copy the code of pull-one and optimize it for returning bool

[16:57] <SmokeMachine>  I think so...

[16:59] <SmokeMachine> But I think `.repeated.so` is fast enough...

[17:03] <discord-raku-bot> <Nemokosch> nice

[17:06] *** sena_kun_ left
[17:07] <SmokeMachine> just out of curiosity: https://usercontent.irccloud-cdn.com/file/Yn9kB9T1/CleanShot%202022-07-20%20at%2018.06.45%402x.png

[17:50] *** swaggboi joined
[18:06] *** reportable6 left
[18:06] *** eseyman left
[18:08] *** reportable6 joined
[18:15] *** sftp_ joined
[18:15] *** sftp left
[18:15] *** sftp_ is now known as sftp

[18:21] *** jaguart left
[18:32] *** jmcgnh left
[18:42] *** sftp_ joined
[18:44] *** sftp left
[18:44] *** sftp_ is now known as sftp

[18:45] *** eseyman joined
[18:47] *** jmcgnh joined
[19:01] *** eseyman left
[19:22] *** vrurg_ is now known as vrurg

[19:36] *** abraxxa-home left
[19:45] *** sena_kun left
[19:47] *** sena_kun joined
[20:20] *** jgaz joined
[20:22] *** morte_ left
[20:30] *** morte_ joined
[20:56] *** simcop2387 left
[20:57] *** perlbot left
[20:58] *** morte_ left
[20:58] *** morte_ joined
[20:59] *** simcop2387 joined
[20:59] *** perlbot joined
[21:02] *** sena_kun left
[21:17] <lizmat> SmokeMachine: to see whether a key exists in a JSON file, wouldn'r '"keyname":' suffice ?

[21:17] <lizmat> % rak '"depends":' META6.json 

[21:17] <lizmat> META6.json

[21:17] <lizmat> 8:"depends": [

[21:26] *** jgaz left
[21:59] *** kaskal left
[22:13] *** saint- joined
[22:16] <saint-> Hey, I was wondering why as part of a Grammar, this works:  token sentRefEnd { <char>+? <endPunc> <ref> }  but not this:     token sentFrag { <char>+? }

[22:16] <saint->     token sentRefEnd { <sentFrag> <endPunc> <ref> }

[22:17] <saint-> In other words, I replace the <char>+? with another token, sentFrag, and then it doesn't work for whatever reason

[22:20] <discord-raku-bot> <Nemokosch> I wonder what happens if you use `regex` instead of `token`

[22:25] *** kaskal joined
[22:34] <SmokeMachine> lizmat: no, because it also can be a value‚Ä¶

[22:35] <SmokeMachine> And it can be oddly idented

[22:38] *** Tirifto left
[22:38] <SmokeMachine> And maybe you need something like: `rak ‚Äîallow-json ‚Äò*.parsed andthen.<bla> ~~ [**, ‚Äúspecific value‚Äù, **]‚Äô

[22:39] <SmokeMachine> m: say <bla ble bli blo blu> ~~ [**, ‚Äúbli‚Äù. **]

[22:39] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Unsupported use of .  to concatenate strings.  In Raku please use: ~.‚ê§at <tmp>:1‚ê§------> say <bla ble bli blo blu> ~~ [**, ‚Äúbli‚Äù.‚èè **]‚ê§¬ª

[22:39] *** Tirifto joined
[22:39] <SmokeMachine> m: say <bla ble bli blo blu> ~~ [**, ‚Äúbli‚Äù, **]

[22:39] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´True‚ê§¬ª

[22:40] <SmokeMachine> m: say <bla ble bli blo blu> ~~ [**, ‚Äúbla‚Äù, **]

[22:40] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´True‚ê§¬ª

[22:40] <SmokeMachine> m: say <bla ble bli blo blu> ~~ [**, ‚Äúblu‚Äù, **]

[22:40] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´True‚ê§¬ª

[22:40] *** morte_ left
[22:56] <SmokeMachine> lizmat: keyname could also be on a path different from the one you want it‚Ä¶ matching that would get every time that was used as key‚Ä¶ and that may not be what you want‚Ä¶

[22:57] *** kaskal- joined
[22:58] *** kaskal left
[23:38] <saint-> Could anyone tell me why this code doesn't work (but the commented line works) https://www.toptal.com/developers/hastebin/ujuhovalac.properties

[23:58] *** evalable6 left
[23:58] *** linkable6 left
[23:59] *** evalable6 joined
