[00:00] *** reportable6 left
[00:00] *** reportable6 joined
[00:03] *** BinGOs left
[00:04] *** bingos joined
[00:05] *** bingos is now known as BinGOs

[00:27] *** perlbot left
[00:27] *** simcop2387 left
[00:43] *** lichtkind_ left
[00:53] <SmokeMachine> m: https://gist.github.com/FCO/333914ae1c63697d3746f190eb5bc9b2

[00:53] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: Â«(signal XCPU)Â»

[01:43] *** linkable6 left
[01:44] *** linkable6 joined
[01:44] *** simcop2387 joined
[01:45] *** perlbot joined
[02:45] *** nativecallable6 left
[02:45] *** committable6 left
[02:45] *** reportable6 left
[02:45] *** benchable6 left
[02:45] *** quotable6 left
[02:45] *** linkable6 left
[02:45] *** releasable6 left
[02:45] *** greppable6 left
[02:45] *** coverable6 left
[02:45] *** bloatable6 left
[02:45] *** evalable6 left
[02:45] *** sourceable6 left
[02:45] *** statisfiable6 left
[02:45] *** unicodable6 left
[02:45] *** shareable6 left
[02:45] *** notable6 left
[02:45] *** bisectable6 left
[02:45] *** statisfiable6 joined
[02:46] *** bisectable6 joined
[02:46] *** greppable6 joined
[02:46] *** notable6 joined
[02:46] *** quotable6 joined
[02:46] *** bloatable6 joined
[02:46] *** sourceable6 joined
[02:47] *** coverable6 joined
[02:47] *** nativecallable6 joined
[02:47] *** shareable6 joined
[02:47] *** reportable6 joined
[02:47] *** releasable6 joined
[02:47] *** evalable6 joined
[02:47] *** benchable6 joined
[02:48] *** committable6 joined
[02:48] *** unicodable6 joined
[02:48] *** linkable6 joined
[03:13] *** melezhik joined
[03:13] <melezhik> o/

[03:13] <melezhik> looks like whateverable Rakudo builds are not accessible? - https://gist.github.com/melezhik/3f23646439795be519eb55b7d32c81e1

[03:13] <melezhik> ^^ AlexDaniel

[03:15] <melezhik> http://sparrowhub.io:2222/report/899 - init section

[03:16] *** melezhik left
[04:05] *** Kaipii joined
[04:05] *** ismustac1 joined
[04:08] *** ismustachio left
[04:08] *** Kaipei left
[04:31] *** tellable6 joined
[04:41] <AlexDaniel> melezhik: I ran out of space again ğŸ˜­

[04:41] <AlexDaniel> but it's fixed now

[04:41] <AlexDaniel> should be

[04:41] <tellable6> AlexDaniel, I'll pass your message to melezhik

[04:44] *** Kaipii left
[05:20] *** Kaipii joined
[05:26] *** chickenwings joined
[05:37] *** chickenwings left
[06:07] *** reportable6 left
[06:07] *** reportable6 joined
[07:07] *** linkable6 left
[07:07] *** evalable6 left
[07:08] *** evalable6 joined
[07:08] *** linkable6 joined
[07:35] *** sena_kun joined
[07:42] *** Kaipii is now known as Kaiepi

[07:49] *** Sankalp joined
[07:49] *** lichtkind_ joined
[08:05] *** Sgeo left
[08:15] *** sena_kun left
[08:17] *** sena_kun joined
[08:59] *** Kaiepi left
[09:14] *** Kaiepi joined
[09:15] *** lichtkind__ joined
[09:18] *** lichtkind_ left
[09:18] *** Sankalp left
[09:19] *** Sankalp joined
[09:21] <discord-raku-bot> <Nemokosch> Is there a situation where one should prefer @$array-actually over $array-actually[] ?

[09:22] *** jaguart joined
[09:25] *** sena_kun left
[09:34] <lizmat> I think the former does $a.list and the latter returns $a itself

[09:45] <discord-raku-bot> <Nemokosch> I think the latter is essentially what is also known as "decont"

[09:49] <lizmat> could well be, would have to check :-)

[10:08] *** sena_kun joined
[10:35] *** Geth left
[10:36] *** lizmat_ joined
[10:36] *** Geth joined
[10:38] *** lizmat left
[10:38] *** lizmat_ is now known as lizmat

[10:39] <lizmat> .

[10:40] *** Geth left
[10:40] *** Geth joined
[11:07] <Voldenet> I prefer @$array-actually because it's more perl style

[11:08] <Voldenet> + when i tested it with for @$ was actually faster, but I wouldn't bet on it

[11:30] *** jercos_ left
[11:30] *** jercos joined
[12:06] *** reportable6 left
[12:08] *** reportable6 joined
[12:10] <lizmat> SmokeMachine: rak with default option value replacement and --json-per-line just uploaded

[12:13] <SmokeMachine> lizmat: great news! \o/

[12:13] <SmokeMachine> have you used the hyper one for --json-per-line?

[12:18] *** jgaz joined
[12:21] <lizmat> only at file level

[12:49] *** sena_kun left
[12:57] *** sena_kun joined
[12:59] <discord-raku-bot> <Nemokosch> How would you write the data of a Supply to a file?

[13:03] <discord-raku-bot> <Nemokosch> oh right, that may not even be the wisest way, so I could just say the issue

[13:04] <discord-raku-bot> <Nemokosch> I want to generate a huge HTML file. By huge I mean that it could easily go up to dozens of megabytes

[13:05] *** morte_ joined
[13:05] <discord-raku-bot> <Nemokosch> The way HTML::Tag currently does it is by concatenating all strings of the world. I think this is a very obvious performance issue.

[13:05] <discord-raku-bot> <Nemokosch> Since it's really just appending, it would be better to produce the data some different way than one humonguous string created by concatenating all strings on earth

[13:05] <discord-raku-bot> <Nemokosch> This could be a buffer, too

[13:05] <discord-raku-bot> <Nemokosch> or a supply

[13:06] <discord-raku-bot> <Nemokosch> Something that I can write to, without building yet another several megabytes string

[13:06] <discord-raku-bot> <Nemokosch> and then eventually I want to write it to a file

[13:07] <Voldenet> I'd just tap .say or .write method into the supply with out-buffer set on the handle

[13:07] <japhb> Nemokosch: concatenating on MoarVM is efficient; it uses strands internally

[13:07] <tellable6> japhb, I'll pass your message to Nemokosch

[13:10] <discord-raku-bot> <Nemokosch> I only know that I had no patience for it to finish...

[13:10] <discord-raku-bot> <Nemokosch> and I have the impression that after the last step, the slowdown was worse than linear

[13:16] <discord-raku-bot> <Nemokosch> we will see... the other possibility is that the entity encoder/decoder module is slow but now that really has no reason to be slow...

[13:29] <Voldenet> profile first, don't reason ;)

[13:46] *** morte_ left
[14:10] *** saint- joined
[14:16] <discord-raku-bot> <Nemokosch> I don't hate my life enough for that, lol

[14:20] <Xliff> m: use experimental :macros; macro S { quasi {{{ |&?ROUTINE.signature.params }}} }; sub a ($a, $b, $c) { say [$a, $b, $c] }; sub b ($a, $b, $c) { S.gist.say;  }; b(1, 2, 3)

[14:20] <camelia> rakudo-moar af114429c: OUTPUT: Â«()â¤Â»

[14:20] <Xliff> Hmmm... why is that not printing out [1,2,3]?

[14:20] <Xliff> Is &?ROUTINE referring to S instead of b?

[14:27] *** kbtz joined
[14:35] *** xinming left
[14:36] *** xinming joined
[14:38] *** sena_kun left
[14:38] *** kbtz left
[14:38] *** kbtz joined
[14:43] <jaguart> Just wondering - do the gods of Raku have any opinion either way on Dependency Injection vs Service Container?

[14:46] *** sena_kun joined
[15:14] <discord-raku-bot> <Nemokosch> The situation is worse than I imagined: this file that took me minutes to generate was somewhat less than 1 megabyte

[15:14] <discord-raku-bot> <Nemokosch> not an outrageously big size even for a text file

[15:28] *** ab5tract joined
[15:28] <ab5tract> o/

[15:28] <tellable6> 2020-08-04T08:20:00Z #raku-dev <JJMerelo> .tell ab5tract how's your article for the 20th anniversary going? 

[15:28] <tellable6> 2020-08-07T09:36:00Z #raku-dev <JJMerelo> .tell ab5tract amazing. Good luck.

[15:28] <tellable6> 2020-08-10T07:51:00Z #raku-dev <JJMerelo> .tell ab5tract will do. Also, online now.

[15:29] <ab5tract> oof

[15:29] <ab5tract> I have not been around for a while :/

[15:29] <ab5tract> I hope everyone is doing well.

[15:29] <ab5tract> I was lurking in the logs and found that nine mentioned "low-hanging fruit" existing for the new-disp branch

[15:30] <ab5tract> I'm curious to make a few grabs for said fruit.

[15:31] <Xliff> \o

[15:34] <ab5tract> I've also got what I think is a bug:

[15:36] <ab5tract> m: my &w = *.contains('foo') && *.contains('bar'); say w("bar"); my &c = {$_.contains('foo') && $_.contains('bar')}; say c("bar")

[15:36] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Falseâ¤Â»

[15:36] <discord-raku-bot> <Nemokosch> and indeed - the "naive" concatenation is faster than building a buffer from the string parts; not much faster but the fact that it's not slower is more than enough

[15:37] <Xliff> my &c = sub { $^a.contains('foo') && $^a.contains('bar')}; say c("bar")

[15:37] <evalable6> Xliff, rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[15:37] <ugexe> m: my $a = 1 && 2; say $a

[15:37] <camelia> rakudo-moar af114429c: OUTPUT: Â«2â¤Â»

[15:37] <ab5tract> IMO the WhateverCode version should require two arguments, just like other WhateverCodes that have two Whatever stars in them.

[15:37] <Xliff> m: my &c = -> $_{ .contains('foo') && .contains('bar')}; say c("bar")

[15:37] <camelia> rakudo-moar af114429c: OUTPUT: Â«===SORRY!===â¤Shape declaration is not yet implemented; please use whitespace if you meant something elseâ¤at <tmp>:1â¤------> my &c = -> $_â{ .contains('foo') && .contains('bar')};â¤Invalid typename 'say' in parameter declaration.â€¦Â»

[15:38] <Xliff> m: my &c = -> $_ { .contains('foo') && .contains('bar')}; say c("bar")

[15:38] <camelia> rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[15:38] <Xliff> Hmm.,

[15:38] <Voldenet> >my &w = *.contains('foo') && *.contains('bar')

[15:38] <ab5tract> m: my &w = *.Int * *.Int; say w(5); say w(5,5);

[15:38] <camelia> rakudo-moar af114429c: OUTPUT: Â«Too few positionals passed; expected 2 arguments but got 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[15:38] <Xliff> m: my &c = -> $_ { .contains('foo') && .contains('bar')}; say c("foobar")

[15:38] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[15:38] <ugexe> m: my $a = 1 && 2; say $a

[15:38] <camelia> rakudo-moar af114429c: OUTPUT: Â«2â¤Â»

[15:38] <Xliff> Which is right.

[15:38] <ugexe> that is why

[15:38] <Voldenet> this probably equals to `my &w = *.contains('foo')`

[15:39] <Voldenet> m: my &w = *.contains('foo') && False; w("foo").say

[15:39] <camelia> rakudo-moar af114429c: OUTPUT: Â«Type check failed in assignment to &w; expected Callable but got Bool (Bool::False)â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[15:39] <ab5tract> Xliff: yes, "foobar" should be the only thing that passes the whatevercode

[15:39] <Voldenet> â€¦or not

[15:39] *** Sgeo joined
[15:40] <Xliff> m: my &w = *.contains('foo') && *.contains('bar'); say w('foo', "bar");

[15:40] <camelia> rakudo-moar af114429c: OUTPUT: Â«Too many positionals passed; expected 1 argument but got 2â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[15:40] <ab5tract> I'm assuming some special case was made for whatevercode's that do a &&/||, for the sake of given/when

[15:40] <ab5tract> but if that is the case, it is broken

[15:41] <ab5tract> Xlifff: and that is what I would _expect_ the whatevercode to act like

[15:41] <ab5tract> I wonder if some elder Rakoon can shed some light

[15:42] <Voldenet> m: my &w = True && *.contains("foo"); w("foo").say

[15:42] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[15:42] <Voldenet> Ah, it's as I thought

[15:42] <Voldenet> WhateverStar just doesn't support && at all

[15:42] <ab5tract> m: my &w = *.so && *.contains("foo"); w("foo").say

[15:42] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[15:43] <ab5tract> m: my &w = (!*.so) && *.contains("foo"); w("foo").say

[15:43] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[15:43] <ugexe> m: my &w = -> {False} && *.contains("bar"); say w("bar");

[15:43] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[15:43] <Voldenet> m: my &w = *.say && *.contains("foo"); say "uh"; w("foo").say

[15:43] <camelia> rakudo-moar af114429c: OUTPUT: Â«uhâ¤Trueâ¤Â»

[15:43] <Voldenet> m: my &w = *.so.say && *.contains("foo"); say "uh"; w("foo").say

[15:43] <camelia> rakudo-moar af114429c: OUTPUT: Â«uhâ¤Trueâ¤Â»

[15:43] <Voldenet> wut

[15:43] <ab5tract> Something fishy indeed

[15:44] <ab5tract> m: my &w = *.contains('foo') && *.contains('bar'); say w("foobrrr");

[15:44] <camelia> rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[15:44] <ab5tract> m: my &w = *.contains('foo') && *.contains('bar'); say w("foo");

[15:44] <camelia> rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[15:44] <Voldenet> first Callable turns into True (and never gets called) and second Callable gets assigned

[15:44] <Voldenet> m: my &w = *.very-fancy-syntax.for-comments && *.contains("foo"); say "uh"; w("foo").say

[15:44] <camelia> rakudo-moar af114429c: OUTPUT: Â«uhâ¤Trueâ¤Â»

[15:45] <ab5tract> I have expect that the construction of whatevercodes will look very different in implementation in new-disp

[15:45] <ab5tract> They were very Dark Arts when I looked at them before

[15:45] <Voldenet> probably rakuast could be relevant

[15:46] <ab5tract> yup, I'm thinking the same.

[15:46] <ab5tract> it really should create a block that expects two arguments, in the case we are testing

[15:46] <ab5tract> that's how it works for every other multi-whatever whatevercode

[15:47] <ab5tract> m: my &w = *.contains('foo') & *.contains('bar'); say w("foo");

[15:47] <camelia> rakudo-moar af114429c: OUTPUT: Â«Too few positionals passed; expected 2 arguments but got 1â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[15:47] <ab5tract> :)

[15:48] <ab5tract> .ask nine I'd be interested in perusing a list of low-hanging fruit for new-disp, if you have the tuits to put one together

[15:48] <tellable6> ab5tract, I'll pass your message to nine

[15:49] <ab5tract> m: my &w = *.contains('foo') & *.contains('bar'); say w("pho", "foobar");

[15:49] <camelia> rakudo-moar af114429c: OUTPUT: Â«all(False, True)â¤Â»

[15:49] <ab5tract> m: my &w = *.contains('foo') & *.contains('bar'); say so w("pho", "foobar");

[15:49] <camelia> rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[15:49] <ab5tract> m: my &w = so *.contains('foo') & *.contains('bar'); say w("pho", "foobar");

[15:49] <camelia> rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[16:01] *** Furor joined
[16:04] *** vrurg_ joined
[16:04] *** vrurg left
[16:04] *** Colere left
[16:09] <ab5tract> m: my &w = so *.contains('foo') and *.contains('bar'); say w("pho", "foobar");

[16:09] <camelia> rakudo-moar af114429c: OUTPUT: Â«Too many positionals passed; expected 1 argument but got 2â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:09] <ab5tract> m: my &w = so *.contains('foo') and *.contains('bar'); say w("foo");

[16:09] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[16:09] <ab5tract> m: my &w = *.contains('foo') && *.contains('bar'); say w("foo");

[16:09] <camelia> rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[16:09] *** dogbert17 left
[16:10] <ab5tract> the plot thickens...

[16:10] *** dogbert17 joined
[16:12] <japhb> ab5tract: HI THERE!

[16:12] <japhb> Long time no see

[16:17] <ab5tract> Hey japhb, great to see you

[16:18] <Voldenet> I'd assume that * would turn expression into 'magic expression' where every * would become a separate parameter

[16:19] <ab5tract> Voldenet: That is indeed what happens in every other case (that I know of, at least)

[16:19] <Voldenet> so `my &x = *.contains(*.map(*))` would be valid

[16:20] <ab5tract> m: my &x = *.contains(*); say x("hihi","hi")

[16:20] <camelia> rakudo-moar af114429c: OUTPUT: Â«Too many positionals passed; expected 1 argument but got 2â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:20] <ab5tract> m: my &x = *.contains(*.Str); say x("hihi","hi")

[16:20] <camelia> rakudo-moar af114429c: OUTPUT: Â«Too many positionals passed; expected 1 argument but got 2â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:20] <Voldenet> actually *.Str gets passed as WhateverCode to contains

[16:21] <Voldenet> `my &w = "foobar".contains(*)` isn't valid either

[16:21] <ab5tract> m: my &x = *.contains(*.Str); say x("hihi")("hi")

[16:21] <camelia> rakudo-moar af114429c: OUTPUT: Â«Cannot resolve caller contains(Str:D: WhateverCode:D); none of these signatures matches:â¤    (List:D: Cool:D \needle, *%_)â¤    (Cool:D: Cool:D $needle, :i(:$ignorecase)!, :m(:$ignoremark), *%_ --> Bool)â¤    (Cool:D: Cool:D $needle, :m(:$ignoremaâ€¦Â»

[16:21] <Voldenet> Well, it sort of is, but not in a way you would expect

[16:22] *** morte_ joined
[16:22] <ab5tract> m: my &x = "foo".contains(*); say x("f")

[16:22] <camelia> rakudo-moar af114429c: OUTPUT: Â«Cannot resolve caller contains(Str:D: Whatever:D); none of these signatures matches:â¤    (List:D: Cool:D \needle, *%_)â¤    (Cool:D: Cool:D $needle, :i(:$ignorecase)!, :m(:$ignoremark), *%_ --> Bool)â¤    (Cool:D: Cool:D $needle, :m(:$ignoremark)!â€¦Â»

[16:23] <ab5tract> Right, there's something about needing some operators in the mix that creates a proper whatevercode

[16:23] <ab5tract> The best question is whether or not the current limitations were by design or due to implementation constraints

[16:23] <Voldenet> because of such cases I don't use much WhateverStar outside of trivial use cases

[16:24] <ab5tract> Yeah, it's got a bit too many curious corners for heavy use

[16:24] <ab5tract> m: my &x = { "foo".contains(*) }; say x("f")

[16:24] <camelia> rakudo-moar af114429c: OUTPUT: Â«Cannot resolve caller contains(Str:D: Whatever:D); none of these signatures matches:â¤    (List:D: Cool:D \needle, *%_)â¤    (Cool:D: Cool:D $needle, :i(:$ignorecase)!, :m(:$ignoremark), *%_ --> Bool)â¤    (Cool:D: Cool:D $needle, :m(:$ignoremark)!â€¦Â»

[16:24] <Voldenet> {"foo".contains($^a)} isn't that much longer

[16:25] <ab5tract> m: my &x = { "foo".contains(*.Str) }; say x("f")

[16:25] <camelia> rakudo-moar af114429c: OUTPUT: Â«Cannot resolve caller contains(Str:D: WhateverCode:D); none of these signatures matches:â¤    (List:D: Cool:D \needle, *%_)â¤    (Cool:D: Cool:D $needle, :i(:$ignorecase)!, :m(:$ignoremark), *%_ --> Bool)â¤    (Cool:D: Cool:D $needle, :m(:$ignoremaâ€¦Â»

[16:25] <ab5tract> m: my &x = { "foo".contains($_.Str) }; say x("f")

[16:25] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[16:25] <ab5tract> Yeah, it's honestly a bit strange, the way it works now... it's a bit more consistent "just" as a whatever

[16:26] <japhb> ab5tract: I've got to run in a couple minutes, but would you mind dropping me an email?  Got some Terminal::* stuff to chat with you about ...

[16:26] <ab5tract> The reason that contains(*) isn't working is because that is actually passing Whatever as an argument to the method, which the method could create a candidate for

[16:27] <ab5tract> japhb: Sure thing!

[16:29] <ab5tract> m: my &w = * - 1; my @f = ^5; say @f[w(@f.size - 1)]

[16:29] <camelia> rakudo-moar af114429c: OUTPUT: Â«No such method 'size' for invocant of type 'Array'.  Did you mean anyâ¤of these: 'sign', 'sin', 'sinh', 'sink', 'slice'?â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:29] <ab5tract> m: my &w = * - 1; my @f = ^5; say @f[w(@f - 1)]

[16:29] <camelia> rakudo-moar af114429c: OUTPUT: Â«3â¤Â»

[16:29] <Voldenet> it's really useful when you do code like .map(*.a.b.c)

[16:29] <ab5tract> m: my &w = * - 1; my @f = ^5; say @f[w(@f)]

[16:29] <camelia> rakudo-moar af114429c: OUTPUT: Â«4â¤Â»

[16:30] <ab5tract> ^^ that's more or less the code that makes @array[*-1] work

[16:31] <ab5tract> Voldenet: yup.

[16:32] <ab5tract> my @a = ^5; dd @a.kv.map: [*,*]

[16:32] <ab5tract> m: my @a = ^5; dd @a.kv.map: [*,*]

[16:32] <camelia> rakudo-moar af114429c: OUTPUT: Â«Cannot map a Seq using a Arrayâ¤Did a * (Whatever) get absorbed by a comma, range, series, or list repetition?â¤Consider using a block if any of these are necessary for your mapping code.â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:32] <ab5tract> m: my @a = ^5; dd @a.kv.map: * + *

[16:32] <camelia> rakudo-moar af114429c: OUTPUT: Â«(0, 2, 4, 6, 8).Seqâ¤Â»

[16:33] *** [Coke] left
[16:34] <ab5tract> It gets less useful when you add more arguments, but I wonder if that is because of inconsistency and strange constraints than anything else

[16:34] <ab5tract> m: my @a = ^5; dd @a.kv.map: { [$^a,Â  $^b] };

[16:34] <camelia> rakudo-moar af114429c: OUTPUT: Â«([0, 0], [1, 1], [2, 2], [3, 3], [4, 4]).Seqâ¤Â»

[16:39] <Voldenet> m: my &f = [+] *; f((1, 2, 3));

[16:39] <camelia> rakudo-moar af114429c: OUTPUT: Â«Cannot resolve caller Numeric(Whatever:D: ); none of these signatures matches:â¤    (Mu:U \v: *%_)â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[16:39] <Voldenet> â€¦also wrong

[16:40] *** [Coke] joined
[16:41] *** discord-raku-bot left
[16:42] *** discord-raku-bot joined
[16:44] *** simcop2387 left
[16:44] *** [Coke] left
[16:45] *** [Coke] joined
[16:45] *** perlbot left
[16:45] *** perlbot joined
[16:47] *** simcop2387 joined
[16:54] *** kbtz left
[16:59] *** jgaz left
[17:09] *** sena_kun left
[17:14] <ab5tract> m: my &w = * Z=> True; say w(<a b c>); my &c = { $_ Z=> True }; say c(<a b c>)

[17:14] <camelia> rakudo-moar af114429c: OUTPUT: Â«(a => True)â¤(a => True)â¤Â»

[17:15] <ab5tract> m: my &w = * Z=> True; say w(<a b c>); my &c = { @_ Z=> True }; say c(<a b c>)

[17:15] <camelia> rakudo-moar af114429c: OUTPUT: Â«(a => True)â¤(a => True)â¤Â»

[17:15] <ab5tract> m: say <a b c> Z=> True

[17:15] <camelia> rakudo-moar af114429c: OUTPUT: Â«(a => True)â¤Â»

[17:16] <ab5tract> ok, I wasn't expecting that..

[17:16] <ab5tract> Ahh, doh!

[17:17] <ab5tract> m: my &w = * X=> True; say w(<a b c>); my &c = { @_ X=> True }; say c(<a b c>)

[17:17] <camelia> rakudo-moar af114429c: OUTPUT: Â«(a => True b => True c => True)â¤(a => True b => True c => True)â¤Â»

[17:17] <ab5tract> Yeah, it's so weird, what works and what doesn't work with whatevercodes

[17:19] *** melezhik joined
[17:19] <discord-raku-bot> <Nemokosch> yes, frankly..

[17:19] <melezhik> AlexDaniel whatevarable builds Â work now, thanks

[17:19] <tellable6> 2022-07-20T10:04:47Z #raku <jjatria> melezhik: I saw that you had sent it, but I haven't had a chance to take a proper look. I'll try to look at it over the weekend ğŸ™‡ 

[17:19] <tellable6> 2022-07-22T04:41:25Z #raku <AlexDaniel> melezhik: I ran out of space again ğŸ˜­

[17:27] <SmokeMachine> jaguart: Iâ€™m not one of these, but Iâ€™ve been playing with this (https://github.com/FCO/Injector) for a whileâ€¦ but Iâ€™ve never used that for anything seriousâ€¦

[17:31] <ab5tract> .ask moritz I'm curious whether you have any recollections as to how whatever's ended up with their current constraints. Were the limitations based on implementation, limits to parsing, or through considered design?

[17:31] <tellable6> ab5tract, I'll pass your message to moritz

[17:32] *** melezhik left
[17:33] <discord-raku-bot> <Nemokosch> yesterday I opened an issue for a WhateverCode constraint

[17:33] <discord-raku-bot> <Nemokosch> for that matter

[17:33] <discord-raku-bot> <Nemokosch> https://github.com/rakudo/rakudo/issues/4995 here it is

[17:42] <discord-raku-bot> <Nemokosch> okay, I messed up the testing; concatenation seems slower but the difference is rather insignificant still, could be 5%

[17:43] <jaguart> SmokeMachine++ - thanks

[17:46] *** sena_kun joined
[17:51] *** saint- left
[17:52] <discord-raku-bot> <Nemokosch> I managed to reduce the time to less than half just by making the render function hypered...

[17:53] *** ismustac1 left
[17:56] <ab5tract> Nemokosch: Looks like there is some community impulse towards looking into whatevers going forward

[17:56] <tellable6> ab5tract, I'll pass your message to Nemokosch

[17:57] <ab5tract> Nemokosch: What's this other thing you are working on?

[17:57] <tellable6> ab5tract, I'll pass your message to Nemokosch

[17:57] *** Kaiepi left
[17:57] <discord-raku-bot> <Nemokosch> I'm still sure there is something painfully slow about the rendering

[17:58] <discord-raku-bot> <Nemokosch> And as my luck goes, perhaps Voldenet was right again and it is in fact the entity replacement

[17:58] <discord-raku-bot> <Nemokosch> I can temporarily remove that because I probably don't even have anything to remove

[18:01] <discord-raku-bot> <Nemokosch> XDDD

[18:02] <discord-raku-bot> <Nemokosch> so yeah

[18:02] <discord-raku-bot> <Nemokosch> with encode-html-entities: 160 seconds (with hypering)

[18:03] <discord-raku-bot> <Nemokosch> without encode-html-entities: 20 seconds (again, with hypering)

[18:03] <discord-raku-bot> <Nemokosch> this is absurd

[18:03] <ab5tract> Is encode-html-entities from a library?

[18:04] <ab5tract> Also, what is this that you are working on? Color me curious

[18:05] <discord-raku-bot> <Nemokosch> yes, encode-html-entities is from XML::Entity::HTML

[18:06] *** reportable6 left
[18:06] <discord-raku-bot> <Nemokosch> I want to generate a HTML report from Jira data

[18:09] *** reportable6 joined
[18:10] <moritz> ab5tract: erm, limitations of what, specifically?

[18:10] <tellable6> 2022-07-22T17:31:54Z #raku <ab5tract> moritz I'm curious whether you have any recollections as to how whatever's ended up with their current constraints. Were the limitations based on implementation, limits to parsing, or through considered design?

[18:10] *** morte_ left
[18:10] <moritz> what, Whatever star?

[18:11] <ab5tract> There doesn't seem to be any hard edged rules that apply to what can be done and what can't

[18:11] <ab5tract> But yeah, I'm speaking here in terms of the currying functionality

[18:11] <moritz> there aren't?

[18:11] <moritz> I'm pretty sure there

[18:12] <moritz> you can current *.method and * passed to "regular" operators (which exclude things like conditional execution, like &&, and assignment operators)

[18:13] <ab5tract> then I would expect this not to even become a whatevercode

[18:13] <ab5tract> m: my &w = *.contains('foo') && *.contains('bar'); say w("foo");

[18:13] <camelia> rakudo-moar af114429c: OUTPUT: Â«Falseâ¤Â»

[18:13] <moritz> the currying also stops as sub and method arguments, because you want to able write @a.map(*.sqrt) and get a list

[18:14] <moritz> maybe I misremeber the part about short-circuiting operators

[18:15] <ab5tract> nope I expect you remember correctly and something snuck in

[18:15] <ab5tract> The above behavior would ideally create a two-arg WhateverCode

[18:15] <ab5tract> m: my &w = *.contains('foo') && *.contains('bar'); say w("bar");

[18:15] <camelia> rakudo-moar af114429c: OUTPUT: Â«Trueâ¤Â»

[18:16] <ab5tract> (or generate a failure)

[18:16] <moritz> https://github.com/rakudo/rakudo/blob/master/src/Perl6/Actions.nqp#L10554-L10590

[18:24] *** ismustac1 joined
[18:33] *** Kaiepi joined
[18:39] <ab5tract> Those restrictions are clear, yeah.

[18:39] <ab5tract> But things like:

[18:39] <ab5tract> m: &w = [+] *; say w([1,2,3])

[18:39] <camelia> rakudo-moar af114429c: OUTPUT: Â«===SORRY!=== Error while compiling <tmp>â¤Undeclared routine:â¤    w used at line 1â¤â¤Â»

[18:40] <ab5tract> m: my &w = [+] *; say w([1,2,3])

[18:40] <camelia> rakudo-moar af114429c: OUTPUT: Â«Cannot resolve caller Numeric(Whatever:D: ); none of these signatures matches:â¤    (Mu:U \v: *%_)â¤  in block <unit> at <tmp> line 1â¤â¤Â»

[18:41] <ab5tract> seem to fail for more unclear reasons.

[18:52] *** ismustac1 left
[18:56] *** vrurg_ is now known as vrurg

[19:11] *** [Coke] left
[19:14] *** [Coke] joined
[19:46] *** Nemokosch joined
[19:46] <Nemokosch> m: my $dummy-data = { testCase => { something => 33 }};  say ($dummy-data{'testCase'; 'objective'} // '-');

[19:46] <camelia> rakudo-moar a7e9b1938: OUTPUT: Â«((Any))â¤Â»

[19:46] <tellable6> 2022-07-19T12:27:09Z #raku <SmokeMachine> Nemokosch: you mean like this ğŸ‘†?

[19:46] <tellable6> 2022-07-20T13:15:03Z #raku <lizmat> Nemokosch: perhaps, but "rak" is not about speed, but about features  :-)

[19:46] <tellable6> 2022-07-20T13:19:32Z #raku <lizmat> Nemokosch: if the outer part of your JSON is an array, you could use https://raku.land/zef:lizmat/JSON::Fast::Hyper to make things about 3x as fast

[19:46] <tellable6> 2022-07-22T13:07:13Z #raku <japhb> Nemokosch: concatenating on MoarVM is efficient; it uses strands internally

[19:46] <tellable6> 2022-07-22T17:56:44Z #raku <ab5tract> Nemokosch: Looks like there is some community impulse towards looking into whatevers going forward

[19:46] <tellable6> 2022-07-22T17:57:02Z #raku <ab5tract> Nemokosch: What's this other thing you are working on?

[19:47] <Nemokosch> let me reiterate

[19:47] <Nemokosch> m: my $dummy-data = { testCase => { something => 33 }};  say ($dummy-data{'testCase'; 'objective'} // '-');

[19:47] <camelia> rakudo-moar a7e9b1938: OUTPUT: Â«((Any))â¤Â»

[19:47] <Nemokosch> I feel like throwing something against the wall. -Ofun, you said?

[19:48] <Nemokosch> m: my $dummy-data = { testCase => { something => 33 }};  say (($dummy-data{'testCase'; 'objective'}) // '-')

[19:48] <camelia> rakudo-moar a7e9b1938: OUTPUT: Â«((Any))â¤Â»

[19:48] <Nemokosch> There is just no escape

[19:49] <SmokeMachine> m: use v6.*; my $dummy-data = { testCase => { something => 33 }};Â  say (($dummy-data{'testCase'; 'objective'}) // '-')

[19:49] <camelia> rakudo-moar a7e9b1938: OUTPUT: Â«-â¤Â»

[19:51] <Nemokosch> you know what the funny thing is

[19:51] <Nemokosch> m: my $dummy-data = { testCase => { something => 33, objective => 'survive Raku' }};  say ($dummy-data{'testCase'; 'objective'} // '-')

[19:51] <camelia> rakudo-moar a7e9b1938: OUTPUT: Â«(survive Raku)â¤Â»

[19:52] <Nemokosch> why is this a godforsaken array

[19:52] <lizmat> Nemokosch: multidim hash access in 6.c and 6.d was meh

[19:52] <SmokeMachine> Before v6.e it returned a Listâ€¦

[19:52] <Nemokosch> yes, List, to be precise

[19:52] <lizmat> I think I fixed a lot of that to get the same semantics everywhere

[19:53] <lizmat> yes, and it shouldn't, just as @a[42] doesn't return a list

[19:53] <Nemokosch> It's definitely relieving to know that I'm not the one to explore all this

[19:53] <lizmat> so 6.c and 6.d are wrong on that respect

[19:54] <Nemokosch> Still waiting for the day when I don't bump into issues that make my head ache

[19:54] <Nemokosch> And this is not an overstatement. I bump into issues every single day I'm using Raku.

[19:54] <lizmat> sorry to hear you're bumping your head a lot

[19:55] <lizmat> :-(

[19:55] <lizmat> do you create Github issues for the issues you encounter ?

[19:56] <Nemokosch> Today I only created one. :DD 

[19:56] <Nemokosch> and even that was for a library... you might know it, XML::Entity::HTML

[19:56] <lizmat> https://github.com/rakudo/rakudo/issues/4996 ?

[19:57] <Nemokosch> Oh right, that was yesterday

[19:57] <Nemokosch> Yesterday I created 3 I think

[20:12] <lizmat> 2 that I can see?

[20:13] <discord-raku-bot> <Nemokosch> One was in problem solving

[20:16] <lizmat> check

[20:17] <discord-raku-bot> <Nemokosch> the other thing is, sadly, still the performance

[20:21] <discord-raku-bot> <Nemokosch> Bringing back ~ 5 MB from a REST API with Cro: 3-5 seconds; could be better, could be worse

[20:21] <discord-raku-bot> <Nemokosch> Parsing it with JSON::Fast: again, say, 2-3 seconds, not competing with the "elite" but not a show-stopper

[20:21] <discord-raku-bot> <Nemokosch> Building up a HTML structure with HTML::Tag that I took over: similar result, definitely seconds but a forgivable amount of them

[20:21] <discord-raku-bot> <Nemokosch> And then comes the parsing of HTML tags to normal HTML text... 5MB HTML took second on 4 cores, with almost 4GB memory usage, this is insane

[20:21] <discord-raku-bot> <Nemokosch> 180 seconds*

[20:21] <discord-raku-bot> <Nemokosch> and this with "optimized usage", that is, I minimized the use of XML::Entity::HTML to basically zero

[20:22] <discord-raku-bot> <Nemokosch> if I let that encode the characters, it would be easily over 10 minutes

[20:23] <discord-raku-bot> <Nemokosch> I could jokingly say that I might write the tags down in that time

[20:25] <discord-raku-bot> <Nemokosch> Thankfully this machine is strong enough to run 3 or 4 VMs of railway control systems but come on...

[20:26] <lizmat> Nemokosch: looking at the HTML::Tag code.... it feels like it was ported from Perl a *long* time ago

[20:27] <lizmat> and I'm not sure what the logic behind "do-assignments" is ?

[20:28] <Nemokosch> was that the one that just spammed attribute = field if the field is present?

[20:29] <Nemokosch> with the gazillion of callsame dispatches

[20:32] <lizmat> well, for one, I'm not sure why it uses callsame, instead of nextsame at the end

[20:32] <lizmat> callsame in sink context is a code smell

[20:33] <Nemokosch> When I looked at it, I couldn't even decide if it was correct. Apparently callsame does return but I wouldn't have known by heart

[20:34] <lizmat> callsame returns *and* spends time returning a value

[20:34] <Nemokosch> Changing it to nextsame at the end is a no-brainer, but do you think that can be a significant win?

[20:35] <lizmat> I think it will be noticeable

[20:35] <Nemokosch> well, let's try, that doesn't break any test cases :D

[20:40] <lizmat> looking at it some more, my fingers start itching, for two reasons

[20:41] <lizmat> 1. that's a mighty cumbersome interface, with a lot of required typing

[20:41] <lizmat> instead of: say HTML::Tag::p.new(:text('This is my paragraph'), :class('pretty')).render

[20:41] <lizmat> why not:

[20:41] <lizmat> say p(:text('This is my paragraph'), :class('pretty'))

[20:41] <lizmat> ??

[20:42] <lizmat> 2. this feels like you need a templating engine?

[20:43] <lizmat> https://cro.services/docs/reference/cro-webapp-template  is a templating engine integrated in Cro, but can also be used stand-alone

[20:43] <lizmat> see https://cro.services/docs/reference/cro-webapp-template#Template_language for features

[20:44] <lizmat> irclogs.raku.org uses Cro::WebAPp

[20:45] <Nemokosch> Look, if Cro, which imports most of the known universe, is the best tool to generate an utterly dumb HTML file, then I might as well stop programming and use Word

[20:46] <lizmat> I think Cro::WebApp is a little leaner on the dependencies: https://github.com/croservices/cro-webapp/blob/master/META6.json

[20:46] *** evalable6 left
[20:46] *** linkable6 left
[20:46] *** linkable6 joined
[20:47] <Nemokosch> But I don't need a web app, I just need a lot of tables

[20:47] <lizmat> ah, ok, Cro::HTTP drags in a lot

[20:47] <lizmat> ok

[20:47] <Nemokosch> it's really just a big dumb file that looks like 1995

[20:47] <patrickb> I think it's a good idea to dog food one of our rather important libraries.

[20:47] <Nemokosch> I could have used PDF if PDF wasn't mostly like a vectorgraphic sheet one can draw onto

[20:48] <lizmat> ok, could you create a gist with the elements that you need?

[20:48] <lizmat> because 1995 HTML is HTML I know all about  :-)

[20:48] <Nemokosch> by the way, it didn't really get faster with nextsame, honestly

[20:48] <patrickb> Also the looks of a web page has nothing to do with the complexity of the server side code.

[20:48] *** evalable6 joined
[20:49] <Nemokosch> 175 s on the last execution

[20:49] <lizmat> Nemokosch: well, I guess new-disp took care off that

[20:49] <lizmat> so that's 5 sec better ?

[20:50] <Nemokosch> that could easily be within the error margin; there are nondeterministic parts and also, I'm using the computer so the load on different cores can change I guess

[20:50] <patrickb> Ugh, I'm a bit ranty tonight. Sorry for that. I guess I should head for bed...

[20:50] <patrickb> o/

[20:50] <Nemokosch> Me too, man xD

[20:51] <Nemokosch> But yeah, if taking over a 5 years old module and refurbishing it is not "dog fooding", I'm frankly not sure what is

[20:51] <lizmat> Nemokosch: if you have time tomorrow, could you write a gist on what you actually need ?

[20:52] <Nemokosch> It's not that long really

[20:53] <Nemokosch> html, body, table, tr, th, td, h-elements, maybe hr, em (or span, CSS is a thing after all)

[20:53] <Nemokosch> I think that's it

[20:54] <Nemokosch> Anyway, I still can't get over the fact that something this banal needs a nuclear reactor to work

[20:55] <Nemokosch> and not the objects, absolutely not, those are bearable

[20:55] <Nemokosch> the rendering, the rendering and again, the rendering

[20:55] <Nemokosch> which is essentially about building one big string and that's about it

[20:55] <lizmat> .render should just be .Str really, I'd say

[20:56] <Nemokosch> but like what can be so grotesquely slow about it? I can also only think of this do-assignment crap

[20:57] <lizmat> well, there's also

[20:57] <Nemokosch> also what?

[20:58] <lizmat> https://github.com/2colours/HTML-Tag/blob/master/lib/HTML/Tag.rakumod#L21   # introduces an additions scope that is not needed

[20:58] <lizmat> same for https://github.com/2colours/HTML-Tag/blob/master/lib/HTML/Tag.rakumod#L22

[20:58] <lizmat> no use of private attributes, they all use the public accessor methods

[20:59] <lizmat> need to go afk now, will check in again tomorrow

[20:59] <Nemokosch> what scope?

[20:59] <lizmat> {encode-html-entities($.attr{$_}.Str)}

[21:00] <lizmat> that line could be written as:

[21:00] <Nemokosch> you of all people should know how morbidly slow encode-html-entities itself is, in the first place...

[21:00] *** melezhik joined
[21:00] <lizmat> qq/ $_="&encode-html-entities($.attr{$_}.Str()"/

[21:01] <Nemokosch> I made changes about this part, by the way. I not only didn't like this imperative map but it's not very hypering friendly, so to speak

[21:03] <Nemokosch> also, what I don't like about that line is that $_ is already identified as 'value'

[21:03] <melezhik> Hi lizmat I am running tomty tests for App::Rak and they fail on SparkyCI - http://sparrowhub.io:2222/report/902

[21:03] <lizmat> need to be afk now  :-)   

[21:03] <lizmat> &

[21:03] <lizmat> sorry

[21:03] <Nemokosch> so it could be written as $.attr<value> and then one wouldn't have to wonder what $_ might be here

[21:03] <melezhik> no worries

[21:05] <Nemokosch> melezhik: how do Sparky and Sparrow relate to each other? I could never quite follow your activity.

[21:06] <melezhik> SparkyCI is CI server. The way it could be extended is writing Sparrow plugins - https://github.com/melezhik/sparkyci/blob/main/docs/dsl.md#sparkyci-plugins

[21:07] <melezhik> well this is not _all_ truth ğŸ˜ - there is also Sparky - low CI level server, but you probably asking about SparkyCI - http://sparrowhub.io:2222

[21:09] <melezhik> low -> low level

[21:09] <Nemokosch> yes yes

[21:10] <Nemokosch> so what is Sparrow, after all? Is it an automation tool in a broader sense?

[21:10] <melezhik> exactly

[21:11] <melezhik> this is framework for gluing of many languages into Raku code

[21:11] <melezhik> so ones say writes code on Bash ( where it's appropriate ) and Sparrow would glue it and expose it as Raku function

[21:11] <melezhik> that is it

[21:11] <melezhik> the same stands for Python/Perl/Powershell/Ruby

[21:12] <japhb> tonyo: Are there docs on creating a zef/fez org and populating it with uploaders?

[21:12] <melezhik> plus one has Raku backed DSL to write tests for scripts stdout

[21:12] <melezhik> it all included into Sparrow

[21:13] <melezhik> a plenty of examples ( well plugins ) - https://sparrowhub.io

[21:14] <Nemokosch> I need something happy :D after turning my office computer into a nuclear reactor by rendering a 5MB HTML file

[21:21] *** melezhik left
[21:38] *** sena_kun left
[21:42] <discord-raku-bot> <Quibono> Does anyone just write in NQP directly instead of raku, or does that only make sense from the perspective of writing the compiler?

[21:44] <discord-raku-bot> <Nemokosch> It can be seen as a means of optimization in certain cases

[21:44] <discord-raku-bot> <Nemokosch> like I think you can actually come across NQP calls in some modules

[21:45] <japhb> JSON::Fast and CBOR::Simple both use nqp::op() calls, but they are written in Raku.  They just break the abstraction.  Repeatedly.  For great justice.

[21:46] <discord-raku-bot> <Quibono> So is there like a use case for writing NQP?

[21:47] <ab5tract> I've considered working through Crafting Interpreters in NQP

[21:47] <ab5tract> The use case is generally speed.

[21:48] <discord-raku-bot> <Nemokosch> and speed is, let's be honest, still a very considerable challenge

[21:50] <discord-raku-bot> <Nemokosch> khm, after suffering for one day with the nuclear reactor module that I adopted...

[21:50] <discord-raku-bot> <Nemokosch> it should generate simple HTML but it turns your computer into a nuclear reactor for minutes instead

[21:50] <discord-raku-bot> <Nemokosch> xD

[21:52] <discord-raku-bot> <Quibono> Raku still pretty slow eh? Like how bad is it, I thought it recently got a lot faster

[21:52] <discord-raku-bot> <Nemokosch> I wonder how slow it could have been before

[21:52] <discord-raku-bot> <Nemokosch> usually when they say it got faster, it indeed got faster, the results reacknowledge that the gaps between the obvious way and the tricky way closed

[21:54] <discord-raku-bot> <Quibono> So like slower than python slow? Are there graphs lol

[21:54] <discord-raku-bot> <Nemokosch> Definitely slower

[21:54] <discord-raku-bot> <Nemokosch> And I think this is especially true for a naively implemented native module

[21:54] <discord-raku-bot> <Nemokosch> by native I mean pure Raku

[21:55] <discord-raku-bot> <Nemokosch> The trick is the nuclear reactor part

[21:55] <discord-raku-bot> <Nemokosch> it's really easy to run all the cores on max, lol

[21:55] <SmokeMachine> Why not `p(â€˜This is my paragraphâ€™), :class(â€˜prettyâ€™))` (without the names parameter for text)?

[21:56] <discord-raku-bot> <Quibono> Lol

[21:56] <discord-raku-bot> <Quibono> Is it known /why/ raku is so slow? Like python is known for being slow.

[21:56] <discord-raku-bot> <Nemokosch> and then you can decrease the time for, idk, a quarter

[21:56] <discord-raku-bot> <Nemokosch> running CPU at 500% be like

[21:56] <discord-raku-bot> <Nemokosch> sometimes that's still not enough, though, and I just came across a situation like that

[21:58] <discord-raku-bot> <Nemokosch> > Why not p(â€˜This is my paragraphâ€™), :class(â€˜prettyâ€™)) (without the names parameter for text)?

[21:58] <discord-raku-bot> <Nemokosch> Other than this has an unmatching number of parens? ğŸ˜› I don't know frankly, but tag('p', text => 'This is my paragraph', class => 'pretty' ) isn't that bad anymore

[21:58] <discord-raku-bot> <Nemokosch> if I were to guess, simply because the author was lazy to write constructors by hand or something

[22:00] <discord-raku-bot> <Nemokosch> Nobody likes to appear thankless but you know, there is one way bigger problem with that module than the interface. If you ask me, the interface is bearable - that's why I adopted it in the first place.

[22:00] <discord-raku-bot> <Nemokosch> I would say, you guys are allowed to make 5 picky remarks *per one performance idea*

[22:02] <discord-raku-bot> <Nemokosch> because it cannot be that I need the resources of 5 youtube videos in the browser, for generating a banally simple, 5 MB large HTML file

[22:02] <discord-raku-bot> <Nemokosch> and very apparently it's not only XML::Entity::HTML that is very slow about it

[22:03] <discord-raku-bot> <Nemokosch> I'd say that's even less usable in its current condition but that's not meant as an excuse

[22:08] *** silug left
[22:10] *** ab5tract left
[22:19] <discord-raku-bot> <Quibono> So is it known if the performance issue is more the compiler not emitting optimized bytecode or moreso the VM being slow?

[22:29] <japhb> Quibono: One of the major intermediate layers of the compiler is being rewritten presently, and among other things should allow easier static optimization.  *General* speed improvements (as opposed to specific routines found to be bottlenecks) are essentially waiting behind that.

[22:30] <japhb> There are also WIP improvements to run-time optimizations, but again they are at present waiting for RakuAST to complete and merge.

[22:31] <discord-raku-bot> <Quibono> Gotcha. Any ideas on order of magnitude speed improvements from that? Iâ€™d love to help but Iâ€™m a raku newb lol

[22:39] *** Nemokosch left
[22:40] *** lichtkind__ left
[22:40] *** silug joined
[22:40] <discord-raku-bot> <Nemokosch> To be honest, RakuAST is so promising that we have a lot of reason to wait for it even without performance considerations

[22:43] <discord-raku-bot> <Nemokosch> is RakuAST MoarVM specific, though?

[22:43] <guifa>  No

[22:44] <guifa> If you look at the source for it, everything RakuAST compiles either (A) to Raku code or (B) NQP/QAST

[22:45] <guifa> And that will work fine on all the backends

[22:50] <discord-raku-bot> <Nemokosch> Oh okay

[22:50] <discord-raku-bot> <Nemokosch> I tend to ask about this, less because I actually want to use a different backend anytime soon, and more because I want to get a better understanding of the architecture

[22:50] *** kbtz joined
[22:52] *** kbtz left
[22:59] <guifa> Yeah.  The impetus for RakuAST was to basically allow things that could only be done using QAST

[22:59] <guifa> Except that QAST has been explicitly a Rakudo-only thing

[23:03] *** kbtz joined
[23:09] <SmokeMachine> Nemkoschâ€¦ yes, the first ) is wrong

[23:15] <discord-raku-bot> <Quibono> So what is the difference between RakuAST and the current architecture

[23:16] <SmokeMachine> Nemokosch: I have done something that looks like that: https://github.com/FCO/MemoizedDOM/blob/master/examples/todo/Todo.pm6

[23:16] <tellable6> SmokeMachine, I'll pass your message to Nemokosch

[23:28] <Voldenet> Quibono: without rakuast to generate code you have to use EVAL, with rakuast you can really just generate the code by passing proper parts of it

[23:31] <discord-raku-bot> <Quibono> Yeah I found a nice slide deck explaining it.

[23:38] <discord-raku-bot> <Quibono> I guess like out of curiosity would there be interest in alternative VMs/compilers for Raku?

[23:54] <japhb> Quibono: Alternative VMs is already a thing (though of course, if that's your thing, go for it!) -- so far MoarVM, JVM, and V8 (JavaScript) can all be used.  One of the *other* advantages of NQP is that it forms a portability layer.

[23:56] <discord-raku-bot> <Quibono> Okay so three VMs one compiler

[23:58] *** Furor is now known as Colere

