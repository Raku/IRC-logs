[00:00] *** xinming left
[00:00] *** reportable6 left
[00:00] *** nativecallable6 left
[00:00] *** quotable6 left
[00:00] *** sourceable6 left
[00:00] *** notable6 left
[00:00] *** tellable6 left
[00:00] *** releasable6 left
[00:00] *** shareable6 left
[00:00] *** greppable6 left
[00:00] *** bloatable6 left
[00:00] *** sftp left
[00:00] *** ecocode left
[00:00] *** perlmaros left
[00:00] *** ilogger2 left
[00:00] *** tinita left
[00:00] *** elcaro left
[00:00] *** a3r0 left
[00:00] *** Sevalecan left
[00:00] *** Scotteh left
[00:00] *** tib left
[00:00] *** ecocode_ joined
[00:00] *** a3r0 joined
[00:00] *** perlmaros joined
[00:00] *** elcaro joined
[00:00] *** tib joined
[00:00] *** tinita joined
[00:02] *** Scotteh joined
[00:02] *** sftp joined
[00:02] *** Sevalecan joined
[00:03] *** ilogger2 joined
[00:05] <japhb> "Zipping" conceptually has a reasonable default realization that makes sense as a "simplest version" of its general operation.  What would be your expected default realization for "operator reversing"?

[00:06] *** xinming joined
[00:09] *** reportable6 joined
[00:13] <habere-et-disper> I don't know. I hadn't thought about it as operator reversing and as just reversing. Your terminology is helpful (I see no official docs on R yet?). Thank you japhb!

[00:14] <guifa_> habere-et-disper https://docs.raku.org/language/operators#index-entry-R_reverse_metaoperator

[00:25] *** lichtkind left
[00:27] *** habere-et-disper left
[00:46] *** greppable6 joined
[00:46] *** releasable6 joined
[01:38] *** Sankalp left
[01:42] *** Sankalp joined
[01:46] *** notable6 joined
[01:47] *** shareable6 joined
[01:47] *** bloatable6 joined
[01:48] *** tellable6 joined
[01:48] *** quotable6 joined
[01:54] *** frost joined
[02:48] *** nativecallable6 joined
[03:48] *** evalable6 left
[03:48] *** linkable6 left
[03:49] *** evalable6 joined
[03:50] *** linkable6 joined
[03:53] *** sourceable6 joined
[04:53] *** greppable6 left
[04:53] *** shareable6 left
[04:53] *** committable6 left
[04:53] *** nativecallable6 left
[04:53] *** unicodable6 left
[04:53] *** coverable6 left
[04:53] *** reportable6 left
[04:53] *** quotable6 left
[04:53] *** evalable6 left
[04:53] *** linkable6 left
[04:53] *** benchable6 left
[04:53] *** statisfiable6 left
[04:53] *** bisectable6 left
[04:53] *** releasable6 left
[04:53] *** tellable6 left
[04:53] *** bloatable6 left
[04:53] *** notable6 left
[04:54] *** unicodable6 joined
[04:54] *** reportable6 joined
[04:54] *** releasable6 joined
[04:54] *** coverable6 joined
[04:54] *** benchable6 joined
[04:54] *** evalable6 joined
[04:55] *** bisectable6 joined
[04:55] *** committable6 joined
[04:55] *** greppable6 joined
[04:55] *** quotable6 joined
[04:55] *** notable6 joined
[04:56] *** nativecallable6 joined
[04:56] *** linkable6 joined
[04:56] *** tellable6 joined
[04:56] *** shareable6 joined
[04:56] *** bloatable6 joined
[04:56] *** statisfiable6 joined
[05:56] *** reportable6 left
[05:56] *** sourceable6 left
[05:56] *** releasable6 left
[05:56] *** committable6 left
[05:56] *** unicodable6 left
[05:56] *** notable6 left
[05:56] *** bisectable6 left
[05:56] *** bloatable6 left
[05:56] *** nativecallable6 left
[05:56] *** tellable6 left
[05:56] *** shareable6 left
[05:56] *** benchable6 left
[05:56] *** quotable6 left
[05:56] *** coverable6 left
[05:56] *** greppable6 left
[05:56] *** evalable6 left
[05:56] *** statisfiable6 left
[05:56] *** linkable6 left
[05:57] *** releasable6 joined
[05:57] *** unicodable6 joined
[05:57] *** shareable6 joined
[05:57] *** notable6 joined
[05:58] *** quotable6 joined
[05:58] *** committable6 joined
[05:58] *** bisectable6 joined
[05:58] *** greppable6 joined
[05:58] *** benchable6 joined
[05:58] *** evalable6 joined
[05:59] *** nativecallable6 joined
[05:59] *** linkable6 joined
[05:59] *** bloatable6 joined
[05:59] *** statisfiable6 joined
[05:59] *** sourceable6 joined
[05:59] *** reportable6 joined
[05:59] *** tellable6 joined
[05:59] *** coverable6 joined
[06:06] *** reportable6 left
[06:08] *** reportable6 joined
[06:30] *** abraxxa joined
[06:33] *** abraxxa left
[06:33] *** abraxxa joined
[06:47] *** abraxxa1 joined
[06:48] *** abraxxa left
[06:56] *** Sgeo left
[07:21] *** [Coke] joined
[07:23] *** sena_kun joined
[07:25] *** [Coke]_ left
[08:07] <SmokeMachine> does ae think somenthig like this is interesting for Raku? https://usercontent.irccloud-cdn.com/file/SbGKyJet/CleanShot%202022-07-19%20at%2008.59.56%402x.png

[08:09] <discord-raku-bot> <Nemokosch> what is ae?

[08:10] <SmokeMachine> sorry?

[08:11] <discord-raku-bot> <Nemokosch> > does ae think somenthig like this is interesting for Raku

[08:11] <discord-raku-bot> <Nemokosch> exactly... sorry? üòÑ

[08:12] <SmokeMachine> sorry... my machine is not working very well... my intention was to write: `Does anyone think something like this is interesting for Raku`

[08:13] <SmokeMachine> for some reason `anyone` become `ae`...

[08:14] <Kaiepi> what is it exactly? port of Maybe?

[08:15] <SmokeMachine> Kaiepi: my intention is a port of functors, applicatives and monads (I'm trying to study it) and some useful monads, like Maybe...

[08:16] <Kaiepi> you're gonna run into trouble eventually without higher kinded generics for niceties like MaybeT

[08:16] <SmokeMachine> currently it's Maybe[T]...

[08:17] <Kaiepi> the monad transformer

[08:17] <SmokeMachine> Kaiepi: I haven't step there yet... :) (sorry, I don't know what's that about)

[08:19] <SmokeMachine> I think this is a bit better (explicit return type will probably be required in the next version): https://usercontent.irccloud-cdn.com/file/WK35sJGU/CleanShot%202022-07-19%20at%2009.18.37%402x.png

[08:22] <Kaiepi> Semigroup and Monoid would be nice

[08:29] <discord-raku-bot> <Nemokosch> why would it?

[08:29] *** Kaiepi left
[08:35] <SmokeMachine> maybe this would also be interesting? https://usercontent.irccloud-cdn.com/file/UmKfYHmP/CleanShot%202022-07-19%20at%2009.34.42%402x.png

[09:11] <Voldenet> it's a good idea, but in practice needs really good language support

[09:12] <Voldenet> otherwise it's either slow or painful to use

[09:16] <Voldenet> btw, currying already exists

[09:16] <Voldenet> m: my &bla = * / *; &bla = &bla.assuming(*, 2); say &bla(10)

[09:16] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´5‚ê§¬ª

[09:29] *** evalable6 left
[09:29] *** linkable6 left
[09:31] *** linkable6 joined
[09:32] *** evalable6 joined
[09:46] <Voldenet> ofc, Maybe[T] is useful in some cases, but in most of those you can simply use one-element lists for everything

[09:47] <Voldenet> e.g.

[09:47] <Voldenet> m: sub split-email { $^optional-email.map: { .contains("@") ?? .split("@").tail !! |() } }; say ("abc@def.ghi").&split-email;

[09:47] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´(def.ghi)‚ê§¬ª

[09:48] <discord-raku-bot> <Nemokosch> Well, what is it useful for?

[09:48] <discord-raku-bot> <Nemokosch> I feel like a good share of this stuff comes from insisting on a type system

[09:48] <Voldenet> Building enormously long chains of maybe-based calls

[09:48] <SmokeMachine> Voldenet: I tried simply using .assuming, but I found using curry implicitly easier...

[09:49] <Voldenet> well, .assuming had one gigantic performance problem in the past

[09:50] <Voldenet> `&f.assuming(*, 2);` was slower than `{ &f($^a, 2) }`

[09:50] <Voldenet> iirc rakuast is doing something about it

[09:50] <discord-raku-bot> <Nemokosch> that's indeed quite a problem...

[09:52] <discord-raku-bot> <Nemokosch> why `&`f, tho

[09:52] <discord-raku-bot> <Nemokosch> is that a call or not?

[09:53] <SmokeMachine> about the 1 element list, doing that that way, you need to expect the list, right? isn't the monad/bind advantage that you can use functions that expect only the value and return a monad? (I'm still studying it... I may have misunderstood)

[09:54] <SmokeMachine> (I may have misunderstood it)

[09:55] <Voldenet> (it was just an example, actual currying would require capturing original function and creating new one)

[09:56] <Voldenet> m: my &bla = * / *; &bla = -> &f { -> $x { &f($x, 2); } }(&bla); say &bla(10); say now - BEGIN now

[09:56] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´5‚ê§0.016728923‚ê§¬ª

[09:56] <Voldenet> m: my &bla = * / *; &bla = &bla.assuming(*, 2); say &bla(10); say now - BEGIN now

[09:56] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´5‚ê§0.079365177‚ê§¬ª

[09:56] <Voldenet> ye, still painfully slow

[09:57] <Voldenet> SmokeMachine: Not quite, it's the monad that decides whether the function will be applied or not, so you first have to convert value into a monad to call a function

[09:57] *** lichtkind joined
[09:58] <SmokeMachine> yes, but the function itself receives the value, not the monad, right? that the reason for the bind, right?

[09:58] <Voldenet> Yes

[09:58] <Voldenet> consider this:

[09:58] <Voldenet> m: sub maybe { (try &^f($^a)) // Any }; sub split-email { $^email.split("@")[1..*].tail }; say Any.&maybe(&split-email);

[09:58] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´(Any)‚ê§¬ª

[09:59] <SmokeMachine> like, on my example, split-email and split-domain receives a Str, and not a Maybe[Str]

[10:00] <Voldenet> you can also do `$^a ?? &^f($^a) !! Any`

[10:01] <SmokeMachine> yes, but I'll need to do that on every function I'd bind in sequence... with Maybe and bind it will just not call the function, right?

[10:03] <El_Che> (not that someone is asking, but you can have more @ if quoted, or no @ at all, eg using !)

[10:04] <SmokeMachine> El_Che: sorry, I didn't get it

[10:04] <SmokeMachine> I was also wondering if containers could be Monads... Positional already kind of is, right?

[10:04] <El_Che> SmokeMachine: being pedanrtic about sub split-email { $^email.split("@")[1..*].tail } :)

[10:05] <SmokeMachine> El_Che: :)

[10:05] <Voldenet> SmokeMachine: also correct, that's why I said that it has its uses

[10:07] <Voldenet> still: Maybe(Any).map(&split-email).map(&split-domain) isn't much better

[10:08] <Voldenet> and using an operator for this is going to introduce some weird-looking syntax

[10:16] <SmokeMachine> I thought this would work... but it didn't: https://usercontent.irccloud-cdn.com/file/D2qGtagP/CleanShot%202022-07-19%20at%2011.15.39%402x.png

[10:18] <SmokeMachine> my bad, I meant this: https://usercontent.irccloud-cdn.com/file/Gw2ZeMbK/CleanShot%202022-07-19%20at%2011.17.39%402x.png

[10:34] <Voldenet> either way, it introduces weird style

[10:38] <discord-raku-bot> <Nemokosch> what doesn't work about it?

[10:39] <discord-raku-bot> <Nemokosch> seems to me that it did exactly what one would expect

[10:51] <Voldenet> ‚Ä¶or you could just skip all that nonsense and get to the point

[10:51] <Voldenet> m: sub split-email(Str:D $e) { $e.split("@")[1..*].tail }; sub split-domain(Str:D $d) { $d.split(".").head }; say try { "abc".&split-email.&split-domain };

[10:51] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Nil‚ê§¬ª

[10:53] *** Kaiepi joined
[10:54] <discord-raku-bot> <Nemokosch> aand it would still be nil üòÑ

[10:57] <Voldenet> but in this case, it's possible to do this:

[10:57] <Voldenet> sub split-email(Str:D $e) { $e.split("@")[1..*].tail }; sub split-domain(Str:D $d) { fail "domain has no dot" unless $d.contains("."); $d.split(".").head }; say try { "abc@def".&split-email.&split-domain } // $!;

[10:57] <evalable6> Voldenet, rakudo-moar 14fb6a5c3: OUTPUT: ¬´domain has no dot‚ê§  in sub split-domain at /tmp/L3gDILjdSj line 1‚ê§  in block <unit> at /tmp/L3gDILjdSj line 1‚ê§‚ê§¬ª

[10:58] <discord-raku-bot> <Nemokosch> what is the significant difference?

[10:59] <Voldenet> you can know why did you get an empty result‚Ä¶ ;)

[11:01] <discord-raku-bot> <Nemokosch> I mean... actually not convinced by that, lol

[11:02] <discord-raku-bot> <Nemokosch> especially regarding the split-email

[11:05] <Voldenet> ‚Ä¶uh uh :)

[11:05] <Voldenet> `Type check failed in binding to parameter '$d'; expected Str but got Nil (Nil)` is telling you why things failed :)

[11:06] <SmokeMachine> But a Either would also do that, right?!

[11:06] *** dogbert2 joined
[11:10] *** dogbert17 left
[11:11] <Voldenet> yes, but it'd be another layer of pain, because now you'd have to convert any non-either subs to new conventions‚Ä¶ and you have no language support

[11:15] *** frost left
[11:19] *** frost joined
[11:25] <discord-raku-bot> <Nemokosch> split-email doesn't really show why you got Nil in the first place

[11:27] <Voldenet> it might lack a few checks‚Ä¶

[11:27] <Voldenet> ‚Ä¶probably all of them

[11:30] <SmokeMachine> https://usercontent.irccloud-cdn.com/file/RwYgMNrb/CleanShot%202022-07-19%20at%2012.30.11%402x.png

[11:33] <SmokeMachine> better: https://usercontent.irccloud-cdn.com/file/SMvSdB6J/CleanShot%202022-07-19%20at%2012.32.01%402x.png

[11:50] <Voldenet> there's one problem with this - you have to type Result and Error separately

[11:50] *** dogbert2 left
[11:50] <Voldenet> I bet you can add a coercer for this

[11:51] <Voldenet> so the code can become `‚Ä¶ ‚Äì> Either[Str, Str] { $email.contains("@") ?? ok $email.split("@").tail !! error "Invalid email" }`

[11:53] <Voldenet> or `‚Äì> Either[Str, Str]()`

[11:53] *** dogbert11 joined
[11:59] <SmokeMachine> yes, I'm planing doing that... `-> Either[Str, Str]() { Bool.pick ?? right "ok" !! left "error" }` would coerce and also `-> Maybe[Int]() { nothing }`

[12:00] <SmokeMachine> but I haven't done that yet...

[12:07] *** reportable6 left
[12:08] <discord-raku-bot> <Nemokosch> something else

[12:08] <discord-raku-bot> <Nemokosch> what gets passed to <?{}> in regex?

[12:09] *** reportable6 joined
[12:24] <SmokeMachine> what am I doing wrong?

[12:24] <SmokeMachine> m: role Left[$, $] { ... }; role Either[::L = Any, ::R = Any] { multi method COERCE(Left[L, Any] (L :$value)) { Left[L, R].new: :$value } }; role Left[::L = Any, ::R = Any] does Either[L, R] { has L $.value; }; my Either[Str, Str]() $a = Left[Str, Any].new: :value("error")

[12:24] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Type check failed in assignment to $!value; expected L but got Str ("error")‚ê§  in method COERCE at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[12:25] <SmokeMachine> m: say "abc" ~~ /.*<?{ False }>/

[12:25] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Nil‚ê§¬ª

[12:25] <SmokeMachine> m: say "abc" ~~ /.*<?{ 1 == 1 }>/

[12:25] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´ÔΩ¢abcÔΩ£‚ê§¬ª

[12:27] <SmokeMachine> Nemokosch: you mean like this üëÜ?

[12:27] <tellable6> SmokeMachine, I'll pass your message to Nemokosch

[12:33] <SmokeMachine> m: role Left[$, $] { ... }; role Either[::L = Any, ::R = Any] { multi method COERCE(Left[L, Any] (L :$value)) { Left[L, R].new: :$value } }; role Left[::L = Any, ::R = Any] does Either[L, R] { has $.value; }; my Either[Str, Str]() $a = Left[Str, Any].new: :value("error") # worst

[12:33] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Impossible coercion from 'Left[Str,Any]' into 'Either[Str,Str]': method COERCE returned an instance of Left[L,R]‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[12:33] <SmokeMachine> should this be working? üëÜ

[12:34] <SmokeMachine> m: role Left[$, $] { ... }; role Either[::L = Any, ::R = Any] { multi method COERCE(Left[L, Any] (L :$value)) { Left[L.WHAT, R.WHAT].new: :$value } }; role Left[::L = Any, ::R = Any] does Either[L, R] { has $.value; }; my Either[Str, Str]() $a = Left[Str, Any].new: :value("error") # this seems to work

[12:34] <camelia> rakudo-moar 7ec4b10d7: ( no output )

[12:54] <SmokeMachine> m: role Either[::L = Any, ::R = Any] {}; role Left[::L = Any, ::R = Any] does Either[L, R] { has L $.value; }; sub a(-->Either[Str, Str]()) { Left[Str, Str].new: :value("error") }; say a # Should it be trying to coerce??? Left[Str, Str] does Either[Str, Str]

[12:54] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Left[Str,Str].new(value => "error")‚ê§¬ª

[12:54] <SmokeMachine> oh! it isn't working on mi machine... let me update Raku...

[12:57] *** Xliff joined
[13:03] <discord-raku-bot> <Nemokosch> > Nemokosch: you mean like this üëÜ?

[13:03] <discord-raku-bot> <Nemokosch> yes, I mean like that üôÇ

[13:10] <SmokeMachine> Voldenet: now it works: https://usercontent.irccloud-cdn.com/file/y2wGpRQ1/CleanShot%202022-07-19%20at%2014.09.23%402x.png

[13:14] <Voldenet> regarding Either, it's nice to have such a feature that can coerce Either[L, R] into T when L is T or R is T

[13:17] <SmokeMachine> And maybe Failure/Exception into Left...

[13:18] <Voldenet> ‚Ä¶ https://doc.rust-lang.org/std/result/enum.Result.html

[13:53] *** vrurg_ joined
[13:53] *** vrurg left
[14:00] <[Coke]> https://docs.raku.org/language/operators#index-entry-R_reverse_metaoperator (Docs for R)

[14:08] *** Sgeo joined
[14:21] *** dogbert17 joined
[14:21] *** dogbert11 left
[14:26] *** ismustachio left
[15:26] *** notable6 left
[15:26] *** greppable6 left
[15:26] *** statisfiable6 left
[15:26] *** reportable6 left
[15:26] *** evalable6 left
[15:26] *** quotable6 left
[15:26] *** linkable6 left
[15:26] *** shareable6 left
[15:26] *** coverable6 left
[15:26] *** committable6 left
[15:26] *** tellable6 left
[15:26] *** nativecallable6 left
[15:26] *** bloatable6 left
[15:26] *** benchable6 left
[15:26] *** sourceable6 left
[15:26] *** releasable6 left
[15:26] *** unicodable6 left
[15:26] *** bisectable6 left
[15:27] *** tellable6 joined
[15:27] *** shareable6 joined
[15:27] *** reportable6 joined
[15:27] *** quotable6 joined
[15:27] *** notable6 joined
[15:27] *** coverable6 joined
[15:27] *** bisectable6 joined
[15:27] *** evalable6 joined
[15:27] *** linkable6 joined
[15:27] *** bloatable6 joined
[15:28] *** sourceable6 joined
[15:28] *** greppable6 joined
[15:28] *** committable6 joined
[15:28] *** releasable6 joined
[15:28] *** benchable6 joined
[15:28] *** nativecallable6 joined
[15:28] *** statisfiable6 joined
[15:29] *** unicodable6 joined
[15:38] *** frost left
[15:42] *** sftp left
[15:43] *** sftp joined
[15:44] *** Xliff left
[15:57] *** ismustachio joined
[16:28] *** razetime joined
[16:33] *** dogbert11 joined
[16:35] *** dogbert17 left
[16:50] *** dogbert11 left
[16:52] *** dogbert11 joined
[17:05] *** dogbert17 joined
[17:05] *** dogbert11 left
[17:21] *** razetime left
[18:07] *** reportable6 left
[18:09] *** reportable6 joined
[18:38] <[Coke]> doc visit today. They couldn't do my blood draw because they couldn't get into my chart.... because they were rolling out a new version of the software, and someone 10 states away was "in" my chart somehow. The future sucks! :)

[18:45] * [Coke] yawns.

[19:09] *** linkable6 left
[19:09] *** evalable6 left
[19:09] *** linkable6 joined
[19:09] *** evalable6 joined
[19:11] *** vrurg_ left
[19:13] *** vrurg joined
[19:28] *** sena_kun left
[19:29] *** sena_kun joined
[19:36] *** discord-raku-bot left
[19:36] *** discord-raku-bot joined
[19:37] *** discord-raku-bot left
[19:37] *** discord-raku-bot joined
[19:42] <SmokeMachine> How my functional suiting is going: https://github.com/FCO/raku-functional/blob/main/example.raku

[19:43] <discord-raku-bot> <Nemokosch> seems rather sadistic ngl

[19:45] <discord-raku-bot> <Nemokosch> iirc Erlang also wasn't this dogmatic

[19:51] <[Coke]> someone have some shorthand for turning my @a=<a b c d> into my %h<a><b><c><d>=True ?

[19:52] <gfldex> m: my @a=<a b c d>; my %h{||@a} = True; dd %h;

[19:52] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Odd number of elements found where hash initializer expected:‚ê§Only saw: Bool::True‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:53] <gfldex> my @a=<a b c d>; (my %h){||@a} = True; dd %h;

[19:53] <evalable6> gfldex, rakudo-moar 14fb6a5c3: OUTPUT: ¬´Hash %h = {:a(Bool::True), :b(Any), :c(Any), :d(Any)}‚ê§¬ª

[19:54] <gfldex> m: use v6.*; my @a=<a b c d>; (my %h){||@a} = True; dd %h;

[19:54] <camelia> rakudo-moar 7ec4b10d7: OUTPUT: ¬´Hash %h = {:a(${:b(${:c(${:d(Bool::True)})})})}‚ê§¬ª

[19:54] <gfldex> [Coke]: ^^^ yes but v6.*

[19:58] <gfldex> SmokeMachine: tyvm, I learned something from https://github.com/FCO/raku-functional/blob/main/lib/Functional.rakumod#L21

[20:06] <discord-raku-bot> <Nemokosch> and what was the new thing?

[20:07] <discord-raku-bot> <Nemokosch> damn, I will learn the names eventually

[20:08] <discord-raku-bot> <Nemokosch> gfldex is the one who always blogs a little...

[20:17] *** perlbot left
[20:19] <gfldex> I did not realise that I can chain methods calls after a call to `.none` and friends.`

[20:19] *** simcop2387 left
[20:20] <discord-raku-bot> <Nemokosch> oh

[20:20] <discord-raku-bot> <Nemokosch> well I don't even know if I knew it or not xD

[20:22] <gfldex> I used FALLBACK in the same way as Junction does (or could, without -O) but didn't make the connection to `.none`, which I used a lot.

[20:31] *** mexen left
[20:58] *** sena_kun left
[21:21] <discord-raku-bot> <altreus‚Ñ¢> Anyone know how to configure raku.vim to fold POD blocks? If I let raku_fold=1, then it just folds my entire class and doesn't seem to have multiple levels of fold ...

[21:27] <discord-raku-bot> <altreus‚Ñ¢> Looks like I tried to figure it out a year ago https://github.com/Raku/vim-raku/issues/32

[21:58] *** evalable6 left
[21:58] *** linkable6 left
[21:59] *** linkable6 joined
[22:01] *** evalable6 joined
[23:01] *** linkable6 left
[23:01] *** evalable6 left
[23:03] *** evalable6 joined
[23:04] *** linkable6 joined
[23:24] *** abraxxa1 left
[23:31] <Geth> ¬¶ ecosystem: 598b19565d | (Richard Hainsworth)++ (committed using GitHub Web editor) | META.list

[23:31] <Geth> ¬¶ ecosystem: Update META.list

[23:31] <Geth> ¬¶ ecosystem: 

[23:31] <Geth> ¬¶ ecosystem: Migrating finanalyst/Collection to fez

[23:31] <Geth> ¬¶ ecosystem: review: https://github.com/Raku/ecosystem/commit/598b19565d

[23:34] *** lichtkind left
