[00:00] *** jjido left
[00:06] *** reportable6 left
[00:07] *** reportable6 joined
[00:42] *** avar left
[00:47] *** avar joined
[00:53] *** epony joined
[01:00] *** Kaipei joined
[01:04] *** Kaiepi left
[01:30] *** avar left
[01:30] *** avar joined
[02:00] *** razetime joined
[02:20] *** HvszrStykp left
[02:20] *** Sauvin left
[02:20] *** Geth left
[02:20] *** ProperNoun left
[02:20] *** hexology left
[02:20] *** peder left
[02:20] *** zostay left
[02:20] *** jcallen left
[02:20] *** leedo left
[02:20] *** GreaseMonkey left
[02:20] *** bartolin left
[02:20] *** thowe left
[02:20] *** esh left
[02:20] *** jdv left
[02:20] *** nebuchadnezzar left
[02:20] *** TieUpYourCamel left
[02:20] *** bdju left
[02:20] *** archenoth left
[02:20] *** kjp left
[02:20] *** nebuchadnezzar joined
[02:20] *** jdv joined
[02:20] *** bartolin joined
[02:20] *** TieUpYourCamel joined
[02:20] *** thowe joined
[02:20] *** peder joined
[02:20] *** greaser|q joined
[02:20] *** leedo joined
[02:20] *** zostay joined
[02:20] *** kjp joined
[02:21] *** greaser|q left
[02:21] *** greaser|q joined
[02:21] *** jcallen joined
[02:22] *** Sauvin joined
[02:22] *** jroc joined
[02:22] *** hexology joined
[02:22] *** greaser|q is now known as GreaseMonkey

[02:22] *** archenoth joined
[02:22] *** ProperNoun joined
[02:22] *** HvszrStykp joined
[02:23] *** Geth joined
[02:23] *** jroc left
[02:25] *** esh joined
[02:25] *** bdju joined
[02:26] *** HvszrSty1p joined
[02:28] *** HvszrStykp left
[02:29] *** HvszrSty1p left
[02:57] *** epony left
[02:58] *** epony joined
[03:58] *** greppable6 left
[03:58] *** coverable6 left
[03:58] *** sourceable6 left
[03:58] *** unicodable6 left
[03:58] *** shareable6 left
[03:58] *** linkable6 left
[03:58] *** bisectable6 left
[03:58] *** notable6 left
[03:58] *** statisfiable6 left
[03:58] *** committable6 left
[03:58] *** bloatable6 left
[03:58] *** releasable6 left
[03:59] *** unicodable6 joined
[03:59] *** bisectable6 joined
[03:59] *** shareable6 joined
[03:59] *** statisfiable6 joined
[03:59] *** committable6 joined
[03:59] *** notable6 joined
[04:00] *** bloatable6 joined
[04:00] *** linkable6 joined
[04:00] *** greppable6 joined
[04:00] *** coverable6 joined
[04:00] *** sourceable6 joined
[04:01] *** releasable6 joined
[04:12] *** archenoth left
[04:43] *** vrurg left
[04:45] *** vrurg joined
[04:56] *** labster joined
[05:01] *** epony left
[05:03] *** epony joined
[05:07] *** labster left
[06:07] *** committable6 left
[06:07] *** statisfiable6 left
[06:07] *** squashable6 left
[06:07] *** bisectable6 left
[06:07] *** greppable6 left
[06:07] *** tellable6 left
[06:07] *** benchable6 left
[06:07] *** nativecallable6 left
[06:07] *** linkable6 left
[06:07] *** evalable6 left
[06:07] *** bloatable6 left
[06:07] *** coverable6 left
[06:07] *** sourceable6 left
[06:07] *** unicodable6 left
[06:07] *** quotable6 left
[06:07] *** releasable6 left
[06:07] *** shareable6 left
[06:07] *** notable6 left
[06:07] *** reportable6 left
[06:07] *** greppable6 joined
[06:07] *** linkable6 joined
[06:07] *** squashable6 joined
[06:07] *** sourceable6 joined
[06:07] *** quotable6 joined
[06:07] *** evalable6 joined
[06:08] *** bisectable6 joined
[06:08] *** statisfiable6 joined
[06:08] *** unicodable6 joined
[06:08] *** nativecallable6 joined
[06:08] *** reportable6 joined
[06:08] *** releasable6 joined
[06:09] *** tellable6 joined
[06:09] *** coverable6 joined
[06:09] *** shareable6 joined
[06:09] *** bloatable6 joined
[06:09] *** committable6 joined
[06:10] *** notable6 joined
[06:10] *** benchable6 joined
[06:18] *** Xliff joined
[06:19] <Xliff> \o

[06:19] <tellable6> 2022-10-26T07:34:58Z #raku-dev <lizmat> Xliff: about 3.5x as fast

[06:19] <tellable6> 2022-10-26T07:38:28Z #raku-dev <lizmat> Xliff Actually, more than 7.4x as fast, if you want strings, as .comb.rotor() will give you lists that would need to get joined: .comb.rotor(3 => -2)>>.join

[06:19] <Xliff> How can I get function key input in raku?

[06:19] <Xliff> .tell lizmat Wow! Nice work. Thanks for the info.

[06:19] <tellable6> Xliff, I'll pass your message to lizmat

[06:43] <Xliff> How can I get function key input in raku?

[06:43] <Xliff> I've tried Term::ReadKey and it's not working as I expected.

[06:46] *** Sgeo left
[07:03] *** labster joined
[07:05] *** epony left
[07:07] *** epony joined
[07:46] *** archenoth joined
[07:50] *** epony left
[08:03] *** epony joined
[08:05] <Xliff> How can I get function key input in raku?

[08:05] <Xliff> Inline::Perl5 still doesn't work.

[08:05] <Xliff> So the one working solution I've found isn't applicable, ATM

[08:09] *** dakkar joined
[08:22] <discord-raku-bot> <Anton Antonov> <@742445366489645080> On what platform / OS is not working as expected?

[08:30] <Xliff> Linux / Terminal, so I don't have access to GUI toolkits

[08:35] *** lichtkind joined
[09:09] *** razetime left
[09:10] *** epony left
[09:11] *** epony joined
[09:11] *** sena_kun joined
[09:50] <lizmat> weekly: https://dev.to/lizmat/dont-fear-the-grepper-4-nki

[09:50] <notable6> lizmat, Noted! (weekly)

[09:50] <tellable6> 2022-10-27T06:19:42Z #raku <Xliff> lizmat Wow! Nice work. Thanks for the info.

[09:54] *** japhb left
[09:58] *** japhb joined
[10:02] <Xliff> lizmat: I'm trying to detect function keys like F1, F2, etc... do you know of a good mechanism in Raku for that?

[10:02] <lizmat> nope :-(

[10:02] *** labster left
[10:02] <Xliff> :(

[10:03] <Xliff> Term::ReadKey gives you the sequences, but that's hard to switch into F1/F2 and such because you have to build the sequences manually.

[10:04] <Xliff> Inline::Perl5 is still br0kered.

[10:04] <Xliff> m: use CPAN:from<Perl5>

[10:04] <camelia> rakudo-moar ef835615f: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Please install Inline::Perl5 for Perl 5 support. ␤at <tmp>:1␤»

[10:04] <Xliff> Ah.

[10:05] <lizmat> Xliff: looks like you will need to make a supply converter

[10:10] <Xliff> How would that work?

[10:12] <lizmat> https://github.com/rakudo/rakudo/blob/master/src/core.c/Supply-factories.pm6#L498 gives a nice example of that

[10:13] <Xliff> Not really. That's a lot of code with no examples. :)

[10:14] <lizmat> method produce

[10:14] <lizmat> taking a Supply, and producing another Supply

[10:15] <Xliff> And how does that apply to keystroke sequences?

[10:15] <lizmat> Term::Readkey produces a Supply, right ?

[10:15] <Xliff> Yes.... it can.

[10:16] <lizmat> key-pressed 

[10:16] <lizmat> the problem is that function keys are emitted as more than one value by that supply, right ?

[10:18] <Xliff> Yes.

[10:18] <Xliff> I've only ever used supplies as event handlers.

[10:18] <Xliff> I've never used them for things like lists, so this is new to me.

[10:19] <Xliff> So can you get a Supply to take successive values and then check if that list is (1, 2, 3, 4)?

[10:19] <lizmat> the Supply produce method is an example of a taking a supply, and collecting info from a given supply, and emitting values on a new supply

[10:20] <lizmat> yup, just collect them, and pass them on when it matches your idea of a sensible sequence

[10:20] <Xliff> Is there an example of this?

[10:20] <lizmat> the link I just posted ?

[10:21] <Xliff> That's the source for produce. Not an example.

[10:22] <Xliff> And the docs have this: https://docs.raku.org/type/Supply#method_produce

[10:22] <Xliff> Which is just a sum, not a sequence tracker.

[10:26] <lizmat> https://gist.github.com/lizmat/737f60089a92e0b560bb12bbfed4f17d

[10:26] <lizmat> I mean, it's very simplified

[10:30] *** kjp left
[10:30] <Xliff> Thinking. I just tried something like this, myself.

[10:30] *** kjp joined
[10:32] *** razetime joined
[10:38] <Xliff> This still doesn't work --

[10:39] <Xliff> raku -e 'use Mojo::DOM:from<Perl5>; #===SORRY!=== Error while compiling -e. Too many positionals passed; expected 1 argument but got 2

[10:40] *** Nemokosch joined
[10:42] *** sena_kun left
[10:43] *** sena_kun joined
[10:44] <Xliff> It would be nice if Supply.tail(3) would automatically give me the last 3 values emitted.

[10:54] *** jjido joined
[11:02] <lizmat> it doesn't?

[11:03] <lizmat> it should?

[11:04] <lizmat> ah, you mean "the last 3 values emitted before the current value"

[11:05] <lizmat> Xliff: but that wouldn't help you, would it?   because it would pass on invalid values also?

[11:11] *** jjido left
[11:14] *** epony left
[11:15] *** epony joined
[11:19] *** sena_kun left
[11:25] <lizmat> afk&

[11:33] *** razetime left
[11:34] *** jjido joined
[11:36] *** jjido left
[11:38] <SmokeMachine> m: Supply.from-list(4, 3, 2, 1, 2, 3, 4).rotor(3 => -2).grep({ $_ ~~ [1, 2, 3] }).act: &say # Xliff would something like this help?

[11:38] <camelia> rakudo-moar ef835615f: OUTPUT: «[1 2 3]␤»

[12:07] *** reportable6 left
[12:07] *** reportable6 joined
[12:27] *** xinming left
[12:35] <Xliff> SmokeMachine: Thanks for trying, but no.

[12:35] <SmokeMachine> then I think I gon't get what the problem is... :(

[12:35] <Xliff> The valies come one at a time, therefore .rotor and .tail don't wokr.

[12:36] <Xliff> So it's more like...

[12:36] <SmokeMachine> but it works with that coming aone at a time...

[12:38] *** derpydoo joined
[12:39] <Xliff> m: my $s = Supplier::Preserving.new; $s.emit($_) for 4, 3, 2, 1, 2, 3, 4; my $sup = $s.Supply; $s.rotor(3 => -2).grep({ $_ ~~ [1, 2, 3] ]).act: .say

[12:39] <camelia> rakudo-moar ef835615f: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> s.rotor(3 => -2).grep({ $_ ~~ [1, 2, 3] ⏏]).act: .say␤    expecting any of:␤        statement end␤        statement modifier␤        statement modif…»

[12:39] <Xliff> m: my $s = Supplier::Preserving.new; $s.emit($_) for 4, 3, 2, 1, 2, 3, 4; my $sup = $s.Supply; $s.rotor(3 => -2).grep({ $_ ~~ [1, 2, 3] }).act: .say

[12:39] <camelia> rakudo-moar ef835615f: OUTPUT: «(Any)␤No such method 'act' for invocant of type 'Seq'␤  in block <unit> at <tmp> line 1␤␤»

[12:39] <SmokeMachine> m: supply { whenever Supply.interval: 0.001 { emit ^5 .roll } }.rotor(3 => -2).grep({ $_ ~~ [1, 2, 3] }).act: &say; sleep 1

[12:39] <camelia> rakudo-moar ef835615f: OUTPUT: «[1 2 3]␤[1 2 3]␤[1 2 3]␤[1 2 3]␤[1 2 3]␤[1 2 3]␤»

[12:40] <Xliff>  m: supply { whenever Supply.interval: 0.001 { emit (^5).roll } }.rotor(3 => -2).grep({ $_ ~~ [1, 2, 3] }).act: &say; sleep 1

[12:40] <camelia> rakudo-moar ef835615f: OUTPUT: «[1 2 3]␤[1 2 3]␤»

[12:40] <Xliff> That might work.

[12:40] <SmokeMachine> the rotor I'm using is not the List's one, but the Supply's one

[12:41] <Xliff> That's what I was hoping to use.

[12:42] <Xliff> Let me try that last one and see what I get.

[12:47] *** archenoth left
[12:48] *** archenoth joined
[13:15] *** xinming joined
[13:18] *** epony left
[13:19] *** epony joined
[13:21] <Xliff> SmokeMachine: OK, after attempts I have managed to get this: "use Term::ReadKey; react { whenever key-pressed( :!echo ).rotor(4) { .map( *.ord ).say }; }; 

[13:22] <Xliff> However, if the return sequence isn't 3 characters, I have to wait until a 4th character comes before I can act on the input.

[13:24] <Xliff> The problem is I need to be able to act on sequences of an arbitrary number of values

[13:25] <Xliff> F1-F4 have 3 characters per sequence.

[13:25] <Xliff> F-F10 have 5 characters.

[13:26] <Xliff> s/F-F10/F5-F10/

[13:26] <Xliff> How can the supply pattern handle that in a non-blocking way?

[13:32] *** Sgeo joined
[13:42] *** archenoth left
[13:43] *** archenoth joined
[13:58] *** xinming left
[13:59] *** Nemokosch left
[14:00] *** xinming joined
[14:14] *** Nemokosch joined
[14:23] <Xliff> How can I detect if $*OUT is redirected to a file?

[14:25] <Xliff> Oh! .t is available. Excellent!

[14:27] <japhb> Oh dear lord, don't do this by hand!

[14:28] <japhb> Xliff: See Terminal::ANSIParser if you absolutely need the key sequence yourself.

[14:29] <japhb> See Terminal::LineEditor (and its guts) if you want to learn more about how to use a parsed ANSI sequence

[14:29] <japhb> See also Terminal::Widgets (and its guts) for an even more advanced user of same

[14:29] *** Nemokosch1 joined
[14:31] *** Nemokosch left
[14:32] <japhb> In particular Terminal::LineEditor::RawTerminalInput and Terminal::Widgets::Terminal may be of use.

[14:33] <japhb> Do we still have a knowledge bot in channel?

[14:33] <Xliff> japhb: Oh. Thank. You. Jeebus!

[14:33] <Xliff> I just wanna get the keystrokes.

[14:33] <japhb> I feel like I need to create a bot that detects Term::ReadKey and goes "YOU PROBABLY DON'T WANT THAT, PLEASE LOOK OVER HERE."  ;-)

[14:33] <Xliff> YES, PLS!

[14:33] <Xliff> :-)

[14:34] <Xliff> I thought I looked at Terminal::Widgets. But it was late at night. I want to put an interface on this app I am writing for $dayJob.

[14:35] <japhb> Terminal::Widgets only has a very small actual widget set.  Most of my available hours were spent on getting the guts right.

[14:35] <japhb> So that's completely understandable.

[14:36] <japhb> I mean, it's usable for some things, with some work on your part, but certainly not "out of the box ready"

[14:36] <Xliff> japhb: I am most happy to PR the parts I need that aren't there.

[14:36] <Xliff> I just need something to take keystrokes and give me: F1, or F2, etc

[14:37] <japhb> Look at Terminal::LineEditor::RawTerminalInput, that should give you an idea how I wrapped up usage of Terminal::ANSIParser.

[14:37] <japhb> BTW, I gave a talk on all this at the last Raku conf.

[14:39] <japhb> https://conf.raku.org/talk/178  (It's not technical, but the second half does show you what each of the Terminal::Modules do.  The first half talks about *why* I've been going through all this pain.)

[14:39] <Xliff> So far, not seeing any function key symbols.

[14:39] <Xliff> Ooh! Watching, now.

[14:40] <japhb> https://github.com/japhb/Terminal-LineEditor/blob/main/lib/Terminal/LineEditor/RawTerminalInput.rakumod#L21

[14:42] <japhb> The next couple hundred lines have structures and declarations for decoding the result of Terminal::ANSIParser; starting around https://github.com/japhb/Terminal-LineEditor/blob/main/lib/Terminal/LineEditor/RawTerminalInput.rakumod#L356 are the input and output pumps for the ANSI parser.

[14:43] <japhb> (And the length of all that is why I suggest just using the module.  ;-)

[14:46] *** razetime joined
[14:53] *** Nemokosch1 left
[14:54] *** Nemokosch joined
[15:06] <Xliff> japhb: So how is ::RawTerminalInput used?

[15:20] <Xliff> japhb: This doesn't seem to be sufficient. All of your examples focus on line, not key based input handling...

[15:20] <japhb> Xliff: Starting here: https://github.com/japhb/Terminal-LineEditor/blob/main/lib/Terminal/LineEditor/RawTerminalInput.rakumod#L652 you can see how all of that is used to make a single-line line editor input.  https://github.com/japhb/Terminal-Widgets/blob/main/lib/Terminal/Widgets/Terminal.rakumod shows using the building blocks to form an event pump for terminal events.

[15:21] <japhb> Xliff: Have you watched the whole video?  :-)

[15:21] <Xliff> --> "use Terminal::LineEditor; use Terminal::LineEditor::RawTerminalInput; my $cli = Terminal::LineEditor::CLIInput.new; $cli.start-decoder; react { whenever $cli.decoded { say $_ } }

[15:21] <Xliff> Not yet. I am doing like... 3 things at once. I'm in the middle of the workday, here.

[15:21] <japhb> AH!

[15:21] <Xliff> I got as far as your Basic games books and cracked up laughing. Got strange looks, here. 

[15:21] <Xliff> =D

[15:22] <Xliff> I think I had those.

[15:22] <japhb> Terminal::LineEditor::CLIInput *uses* the real-time key handling to create a line editor.  But that's just the cap on that particular stack.  ;-)

[15:22] <japhb> :-D

[15:22] <japhb> Love it!

[15:22] *** epony left
[15:24] <Xliff> OK. I might have to wait until lunch.

[15:24] <Xliff> .... oh wait....

[15:24] <Xliff> It is lunch!

[15:25] <japhb> :-)

[15:25] *** Kaipei left
[15:25] *** Kaipei joined
[15:27] *** epony joined
[15:31] *** Kaipii joined
[15:34] *** Kaipei left
[15:38] *** razetime left
[15:50] *** razetime joined
[15:57] *** archenoth left
[15:58] *** archenoth joined
[16:07] *** archenoth left
[16:18] *** archenoth joined
[16:27] *** clarjon1 joined
[16:30] *** dakkar left
[16:54] *** Kaipei joined
[16:57] *** Kaipii left
[17:02] *** archenoth left
[17:03] *** archenoth joined
[17:12] *** archenoth left
[17:13] *** archenoth joined
[17:16] *** Kaipii joined
[17:16] *** razetime left
[17:18] <Xliff> japh: Do you still have those OpenGL demos?

[17:19] *** Kaipei left
[17:20] <Xliff> japhb: https://github.com/Xliff/p6-COGL

[17:20] <Xliff> I can pull >60fps from this one: https://github.com/Xliff/p6-COGL/blob/master/t/03-crate.t

[17:23] <Nemokosch> What is this?

[17:23] <Xliff> Raku bindings for the COGL library.

[17:24] <Xliff> It's based on my p6-GLib work, so it's a bear to install.

[17:29] <Nemokosch> wowie

[17:31] *** derpydoo left
[17:31] *** epony left
[17:32] *** epony joined
[17:35] <Xliff> COGL is basically a wrapper around Open GL

[17:35] <Xliff> Installation instructions updated in case anyone wants to check it out.

[17:52] *** archenoth left
[17:52] *** jjido joined
[17:53] *** archenoth joined
[18:05] <Xliff> japhb: Is the mad scientist demo anywhere?

[18:06] *** reportable6 left
[18:07] <Xliff> japhb: MMORPG roguelike FTW?

[18:07] *** reportable6 joined
[18:11] <Xliff> Oh! MUGS!

[18:15] *** Kaipei joined
[18:18] *** Kaipii left
[18:22] * Nemokosch wonders which one is the real Kaiepi

[18:23] <Xliff> Nemokosch... it's the one with two eyes!

[18:24] <Xliff> japhb: my &parse-codepoint := make-ansi-parser( emit-item => { @parsed.push: $_ }); parse-codepoint($_) for $input-buffer.list; # missing the definition for $input-buffer!

[18:31] <Nemokosch> what is the state of MUGS, by the way?

[18:35] *** Kaipei left
[18:58] *** Kaipei joined
[19:09] <Xliff> <punchy>Advocating an Array.lop as the front analog for .chop -- who's with me?</punchy>

[19:10] <Xliff> m: "Hello".chop(2).say

[19:10] <camelia> rakudo-moar ef835615f: OUTPUT: «Hel␤»

[19:10] <Xliff> m: "Hello".lop(2).say

[19:10] <camelia> rakudo-moar ef835615f: OUTPUT: «No such method 'lop' for invocant of type 'Str'.  Did you mean 'log'?␤  in block <unit> at <tmp> line 1␤␤»

[19:10] <Xliff> :( -- This needs correcting!! # :-)

[19:11] * Xliff got into the catnip again.... don't mind him

[19:18] <Xliff> japhb: use Terminal::Print::DecodedInput; my $in = decoded-input-supply; react { whenever $in { .say } };

[19:18] <Xliff> Ahhhhhhh.....

[19:19] *** Sauvin left
[19:20] *** Xliff left
[19:28] *** Nemokosch left
[19:34] *** Sauvin joined
[19:36] *** epony left
[19:37] *** epony joined
[20:06] <gfldex> .tell Xliff a simple implementation for your problem: https://gist.github.com/abebd2c82c79858a43763bb1bf564412

[20:06] <tellable6> gfldex, I'll pass your message to Xliff

[20:09] *** jgaz joined
[21:04] *** jjido left
[21:14] *** jjido joined
[21:24] *** jgaz left
[21:25] *** jjido left
[21:25] *** Xliff joined
[21:26] *** mykhal left
[21:28] *** mykhal joined
[21:30] <japhb> Xliff: It's an older code, but it checks out.  :-)

[21:33] <japhb> Xliff: Several of the demos from that talk are not *externally* available, mostly because people get weird expectations around released code, and those don't hit the bar for me.

[21:34] <japhb> Still working on the rpg-ui demo in my "spare time".  The "intuitive character creation" demo will eventually be merged into that.

[21:35] <japhb> MUGS development has been paused a bit while I throw energy at those demos, and try to turn them into decent code via Terminal::Widgets improvements.

[21:35] <japhb> My life as a yak shaver, I guess.  :-)

[21:49] *** jjido joined
[22:16] <Xliff> Hahahaha!

[22:16] <tellable6> 2022-10-27T20:06:26Z #raku <gfldex> Xliff a simple implementation for your problem: https://gist.github.com/abebd2c82c79858a43763bb1bf564412

[22:19] *** deoac joined
[22:21] <Xliff> gfldex: Ooh! Thanks

[22:22] <Xliff> japhb: What am I missing from the newer code. I would prefer to use the latest and greatest, but I see a lot of similarities between the two... and it works.

[22:22] *** lichtkind left
[22:25] <Xliff> How can I get a method's callable object?

[22:25] <Xliff> m: class A { method a { }; method b { &self.a.^name.say }; }; A.b

[22:25] <camelia> rakudo-moar ef835615f: OUTPUT: «Nil␤»

[22:26] <Xliff> m: class A { method a { }; method b { &self.a.^name.say }; }; A.b()

[22:26] <camelia> rakudo-moar ef835615f: OUTPUT: «Nil␤»

[22:26] <Xliff> m: class A { method a { }; method b { &self.a.name.say  }; }; A.b()

[22:26] <camelia> rakudo-moar ef835615f: OUTPUT: «Nil␤»

[22:26] <Xliff> ??

[22:26] *** Xliff left
[22:37] *** Kaipei left
[23:14] *** patterner____ left
[23:14] *** patterner____ joined
[23:30] <Voldenet> m: class A { method a { say "a called"; }; method b { self.^lookup("a") }; }; A.b.(A)

[23:30] <camelia> rakudo-moar ef835615f: OUTPUT: «a called␤»

[23:31] <Voldenet> consider the following

[23:31] <Voldenet> https://docs.raku.org/type/Metamodel::MethodContainer

[23:36] *** jjido left
[23:44] *** epony left
[23:45] *** epony joined
