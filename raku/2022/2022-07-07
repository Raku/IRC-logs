[00:05] *** swaggboi joined
[00:06] *** reportable6 left
[00:07] *** reportable6 joined
[00:43] *** morte_ joined
[01:43] *** bloatable6 left
[01:43] *** quotable6 left
[01:43] *** evalable6 left
[01:43] *** sourceable6 left
[01:43] *** releasable6 left
[01:43] *** linkable6 left
[01:43] *** reportable6 left
[01:43] *** unicodable6 left
[01:43] *** notable6 left
[01:43] *** benchable6 left
[01:43] *** tellable6 left
[01:43] *** committable6 left
[01:43] *** greppable6 left
[01:43] *** nativecallable6 left
[01:43] *** bisectable6 left
[01:43] *** shareable6 left
[01:43] *** coverable6 left
[01:43] *** statisfiable6 left
[01:44] *** releasable6 joined
[01:44] *** tellable6 joined
[01:44] *** quotable6 joined
[01:44] *** notable6 joined
[01:44] *** sourceable6 joined
[01:45] *** coverable6 joined
[01:45] *** linkable6 joined
[01:45] *** shareable6 joined
[01:45] *** bloatable6 joined
[01:45] *** benchable6 joined
[01:46] *** bisectable6 joined
[01:46] *** statisfiable6 joined
[01:46] *** greppable6 joined
[01:46] *** nativecallable6 joined
[01:46] *** evalable6 joined
[01:46] *** unicodable6 joined
[01:46] *** committable6 joined
[01:47] *** reportable6 joined
[01:53] *** morte_ left
[02:53] *** notable6 left
[02:53] *** bisectable6 left
[02:53] *** coverable6 left
[02:53] *** tellable6 left
[02:53] *** shareable6 left
[02:53] *** quotable6 left
[02:53] *** sourceable6 left
[02:53] *** benchable6 left
[02:53] *** releasable6 left
[02:53] *** nativecallable6 left
[02:53] *** committable6 left
[02:53] *** unicodable6 left
[02:53] *** evalable6 left
[02:53] *** reportable6 left
[02:53] *** statisfiable6 left
[02:53] *** linkable6 left
[02:53] *** bloatable6 left
[02:53] *** greppable6 left
[02:53] *** coverable6 joined
[02:53] *** bloatable6 joined
[02:53] *** evalable6 joined
[02:53] *** tellable6 joined
[02:53] *** unicodable6 joined
[02:53] *** linkable6 joined
[02:53] *** shareable6 joined
[02:53] *** reportable6 joined
[02:54] *** sourceable6 joined
[02:54] *** bisectable6 joined
[02:54] *** releasable6 joined
[02:54] *** notable6 joined
[02:55] *** benchable6 joined
[02:55] *** greppable6 joined
[02:55] *** committable6 joined
[02:55] *** statisfiable6 joined
[02:55] *** nativecallable6 joined
[02:56] *** quotable6 joined
[03:06] *** frost joined
[03:58] <coleman> The Web::Request module; can it be installed with zef?

[03:58] <coleman> Example usage https://github.com/Raku/examples/blob/master/categories/cookbook/19cgi-programming/19-01cgi-script.raku#L20

[04:02] <guifa> nine: if `$*W.install_lexical_symbol: $*UNIT…` installs a my-scoped var, how would an our scoped one be installed?

[04:03] *** vrurg_ joined
[04:04] *** vrurg left
[04:10] <Voldenet> coleman: you may be looking for `zef install Web`

[04:11] <guifa> (although if it's not a simple one or two liner, I'll just hold off until RakuAST when I know it'll be much easier lol)

[04:12] *** wcs left
[04:12] <Voldenet> but the package itself doesn't work for me

[04:19] *** _Xliff joined
[04:20] <Voldenet> if you need to make requests consider Cro::HTTP

[04:20] <Voldenet> or Http::Tiny for the most recent module

[04:22] *** Xliff_ left
[05:22] *** sourceable6 left
[05:22] *** notable6 left
[05:22] *** reportable6 left
[05:22] *** bisectable6 left
[05:22] *** benchable6 left
[05:22] *** coverable6 left
[05:22] *** unicodable6 left
[05:22] *** nativecallable6 left
[05:22] *** statisfiable6 left
[05:22] *** committable6 left
[05:22] *** bloatable6 left
[05:22] *** shareable6 left
[05:22] *** greppable6 left
[05:22] *** quotable6 left
[05:22] *** evalable6 left
[05:22] *** tellable6 left
[05:22] *** linkable6 left
[05:22] *** releasable6 left
[05:22] *** coverable6 joined
[05:22] *** linkable6 joined
[05:23] *** reportable6 joined
[05:23] *** evalable6 joined
[05:23] *** nativecallable6 joined
[05:23] *** benchable6 joined
[05:23] *** sourceable6 joined
[05:23] *** notable6 joined
[05:23] *** shareable6 joined
[05:23] *** quotable6 joined
[05:23] *** greppable6 joined
[05:24] *** releasable6 joined
[05:24] *** bloatable6 joined
[05:24] *** statisfiable6 joined
[05:24] *** bisectable6 joined
[05:24] *** committable6 joined
[05:25] *** unicodable6 joined
[05:25] *** tellable6 joined
[06:06] *** reportable6 left
[06:07] *** reportable6 joined
[06:08] *** daxim left
[06:12] *** irc_user joined
[06:39] *** patrickb left
[06:39] *** patrickb joined
[06:46] *** jaguart joined
[06:52] *** melezhik joined
[06:52] <melezhik> .

[06:55] <melezhik> CIAvash: I've setup sparkyci for api sport football module, so if codeberg does not have it's own CI system you can you sparkyci , for example http://sparrowhub.io:2222/report/825

[06:56] <melezhik> From HN I read people move from GH recently )))

[07:03] *** andm joined
[07:06] *** melezhik left
[07:11] *** melezhik joined
[07:12] *** melezhik left
[07:17] *** abraxxa joined
[07:22] <CIAvash> melezhik: Thanks. It has CI, but it's in "closed testing phase" and you have to request early access.

[07:22] <tellable6> CIAvash, I'll pass your message to melezhik

[07:24] *** Madcapjake joined
[07:31] *** abraxxa left
[07:31] *** abraxxa joined
[07:36] *** Sgeo_ left
[07:41] *** mjgardner left
[07:42] *** mjgardner joined
[07:42] *** patterner____ left
[07:42] *** zostay left
[07:42] *** pjlsergeant left
[07:42] *** patterner____ joined
[07:42] *** zostay joined
[07:42] *** pjlsergeant joined
[07:56] *** daxim joined
[07:56] <abraxxa> is it a bug,  that the raku repl doesn't increment the number shown at the prompt when say is called?

[07:56] <tellable6> 2022-07-06T16:57:24Z #raku <nine> abraxxa: as far as I can tell thats already the case

[07:56] <abraxxa> nine: to what of my questions was this your answer?

[07:57] *** killown joined
[07:57] <killown> why should someone give a try for raku and what his language is good for?

[08:01] *** dakkar joined
[08:02] <abraxxa> killown: for me it's grammars and async/multihtreading

[08:02] <abraxxa> wrote a parser for the firehol config syntax which I wouldn't known how to do without grammars

[08:04] <killown> lots os languages can do async and multistuff, but I am interested in this grammars, seems like good for any parser

[08:05] *** andm left
[08:06] <killown> what about speed, in case I need for example load 5gb log file and parse some stuff from it

[08:08] *** sena_kun joined
[08:09] <abraxxa> you have to benchmark your use case, but for me runtime performance isn't an argument against using Raku for me

[08:13] <killown> always the fastest method is the good one, I am using rust to parse logs, hardware resources matters a lot, but just trying around new languages stuff and you said about grammars, seems interesting depending on the case

[08:14] <killown> abraxxa, I am curious, what kind of issue did you have that only grammars could solve it for you

[08:15] <abraxxa> killown: as I already wrote parsing Firehol config files

[08:15] <abraxxa> I had a custom Perl syslog parser for our network devices and it was faster than Logstash which I didn't expect

[08:16] <abraxxa> I don't know anything about Rusts regex capabilities, builtin or crate. But as this is old technology the most regex engines are quite well optimized I guess

[08:18] <killown> abraxxa, if the thing is only about regex, even python can do that

[08:19] <killown> so raku is just perl with name of raku

[08:19] <killown> ok got it

[08:20] <killown> thank you for all the explanations

[08:21] <abraxxa> no, it's not, which is why it was renamed from Perl 6 to Raku

[08:22] <abraxxa> I don't know any other scripting language (compiled on execution) that can do true native multithreading

[08:22] <abraxxa> Perl, Python, PHP, Ruby at least

[08:30] *** andm joined
[08:32] *** irc_user left
[08:38] <nine> abraxxa: I meant that as far as I can tell all methods are usually documented

[08:41] <abraxxa> nine: of isn't: https://docs.raku.org/type/Rat

[08:41] <nine> guifa: our scoped variables are just entries in the package's stash:

[08:41] <nine> m: my Int $i; module Foo { }; Foo.WHO<$bar> := $i; say $Foo::bar

[08:41] <camelia> rakudo-moar 6dc2f92c9: OUTPUT: «(Int)␤»

[08:41] <nine> abraxxa: Rat does not have a method called 'of'

[08:42] <abraxxa> nine: sorry, yes, that was made clear yesterday. What is missing is VAR

[08:43] <nine> abraxxa: VAR is not a method. It just looks like one. It's more like a macro and documented in https://docs.raku.org/language/mop#index-entry-syntax_VAR-VAR

[08:45] <abraxxa> my point is that the documentation should be organized around the human user, not how it is implemented

[08:50] <nine> abraxxa: that is certainly a valid point and something every doc author should strive for. I just don't see how it could be done better in this case. To stay with your example: VAR does not have anything to do with the Rat type. Not more than for example 'my'. Would you expect to have 'my' explained on every single type's documentation page? While a little repetition does not hurt (it's the basis of learning 

[08:50] <nine> after all), too much repetition will cause confusion again, since it makes it harder to find what's actually unique about Rat.

[08:54] <nine> FWIW I am with you that currently the docs probably err a little too much on the side of "don't repeat too much". Raku is a big language and the examples for one feature often require understanding of many other features which a beginner won't necessarily understand yet.

[08:55] <nine> That said, bringing a beginner into the language sounds like something that books are meant for. Of course it could be that people just don't read books anymore :)

[09:00] <abraxxa> nine: the type docs show all methods inherited and I've expected the topmost type Mu to have the VAR method defined and so it shows up in every types' docs

[09:01] <abraxxa> for example even after 20+ years in programming I don't know what the term 'macro' means (besides from clusterfuck in Excel)

[09:10] <nine> killown: grammars are not just regexes. They are really the next step in evolution. While some of the things you can do with grammars can actually be done with regexes, you really have to know them extremely well and even then it's tedious. You just know that these advanced features were bolted on. The re-thinking that went into grammars made them much easier to learn.

[09:11] <nine> abraxxa: VAR is _not_ a method. Not on Mu, not on anything.

[09:12] <killown> so this is some kind of regex but easier to use advanced stuff

[09:12] <abraxxa> nine: maybe, but why would a user care when they call it like one?

[09:15] <thowe> pattern matching in Raku is a leap forward...  I was just reading a book on it and playing with some online examples; it is an eyebrow raiser

[09:19] <nine> abraxxa: because it's only the "call" that's like a method. You will not find it for example in the results of a call to 'Mu.^methods'. And that's why listing it as a method could even cause more confusion.

[09:20] <nine> abraxxa: Int() looks like a call as well. Except that in my Int() $i; it's actually a coercion type and not a call at all. There are just cases where syntax has been re-used and just because something looks similar on a first glance, it is not similar at all.

[09:21] <abraxxa> nine: does a languageserver suggest if for autocompletion? How should a user know that it's available to call?

[09:24] <nine> abraxxa: if it's a good language server, it will. If not, then the loss is not huge though. We are talking about a very obscure feature after all. A feature that's probably most useful for introspection.

[09:26] <nine> abraxxa: At the end of the day, auto-complete is no susbstitute for really learning a language. If one wants to do advanced stuff (which needing .VAR clearly indicates), one will have to learn the language for real and that will require reading through the "Fundamental topics" section of the docs and not just the reference pages for types.

[09:27] <abraxxa> objecting to documentation improvements won't help to get more users into the language...

[09:29] <nine> Who is objecting to improvements?

[09:32] *** evalable6 left
[09:32] *** linkable6 left
[09:34] *** evalable6 joined
[09:34] *** linkable6 joined
[09:47] <abraxxa> you are by not wanting to list those 'macros' or link to them in the docs

[09:47] <abraxxa> and that isn't the first time I'm turned down with docs improvements with some technical argument

[10:04] <nine> If you think I'm making a technical argument (only) then I did not get the message across.

[10:05] <nine> 10:50 < nine> abraxxa: that is certainly a valid point and something every doc author should strive for. I just don't see how it could be done better in this case. To stay with your example: VAR does not have anything to do with the Rat type. Not more than for example 

[10:06] <nine>               'my'. Would you expect to have 'my' explained on every single type's documentation page? While a little repetition does not hurt (it's the basis of learning 

[10:06] <nine> abraxxa: this ^^^ was the crucial message

[10:06] <abraxxa> is 'my' something than can be called on every type?

[10:08] <nine> Every type can be used with my

[10:09] <nine> You can for example use every type as coercion type: Rat(). Should that be documented with every single type?

[10:10] <nine> You can call meta methods on every type: Rat.^name. Should those be documented with every type?

[10:17] <discord-raku-bot> <Scimon> I'm trying to get type coercion and binding to play nicely together. It's not going well, can anyone advise? (Example incoming).

[10:19] <discord-raku-bot> <Scimon> Using my Tree::Binary class it does and Iterable Role and that's fine. If I bind a variable as a Tree::Binary I can then iterate through it. EG : raku -MTree::Binary -e 'class IntTree does Tree::Binary::Role::BinaryTree[Int] {};my $int-tree := IntTree.from-Str("1(2(3)(4))(3(4)(5))");.say for $int-tree'

[10:19] <discord-raku-bot> <Scimon> That works.

[10:19] <discord-raku-bot> <Scimon> (If I assign it then it doesn't iterate... I *guess* that makes sense).

[10:19] <discord-raku-bot> <Scimon> I also have a COERCE function so I can assign using my IntTree(Str) $int-tree = "1(2)(3)" and *that works*

[10:20] <discord-raku-bot> <Scimon> But my IntTree(Str) $int-tree := "1(2)(3)"... gives me a Str object.

[10:21] <discord-raku-bot> <Scimon> v2022.06

[10:22] <lizmat> m: my $l = (1,2,3); .say for $l; .say for $l<>   # Scimon

[10:22] <camelia> rakudo-moar 6dc2f92c9: OUTPUT: «(1 2 3)␤1␤2␤3␤»

[10:22] <lizmat> if it is in a variable, it is containerized.  If an Iterable is containerized, it won't iterate with for

[10:23] <lizmat> decontainerizing with <> is maybe a solution?

[10:23] <discord-raku-bot> <Scimon> Ahhhh.

[10:23] <discord-raku-bot> <Scimon> Well that deals with half my confusion.

[10:24] <discord-raku-bot> <Scimon> Yup. Still the Coercion not working on binding feels like a bug.

[10:25] <lizmat> well, I guess either it should work, or you should get a typecheck error ?

[10:26] <discord-raku-bot> <Scimon> Yeah... and instead it does neither. I may try and make a smaller test case see if I can reproduce.

[10:26] <lizmat> m: my Str(Int) $a := 42; dd $a.^name

[10:26] <camelia> rakudo-moar 6dc2f92c9: OUTPUT: «"Int"␤»

[10:26] <lizmat> vrurg_  ^^  ??

[10:27] <lizmat> m: my Str $a := 42

[10:27] <camelia> rakudo-moar 6dc2f92c9: OUTPUT: «Type check failed in binding; expected Str but got Int (42)␤  in block <unit> at <tmp> line 1␤␤»

[10:27] <lizmat> feels worthy of an issue

[10:27] <discord-raku-bot> <Scimon> Did I find a bug?

[10:28] <lizmat> feels like to me now  :-)

[10:34] <discord-raku-bot> <Scimon> I'm looking at this code and documenting the bits I'd missed before (like the iteration options).

[10:34] *** evalable6 left
[10:35] *** evalable6 joined
[11:03] *** linkable6 left
[11:04] <Geth> ¦ problem-solving: 18890dc9f4 | (Elizabeth Mattijsen)++ (committed using GitHub Web editor) | solutions/language/Add-head-skip-tail-subs.md

[11:04] <Geth> ¦ problem-solving: Add solution for #328 (#329)

[11:04] <Geth> ¦ problem-solving: 

[11:04] <Geth> ¦ problem-solving: https://github.com/rakudo/rakudo/commit/af31b1df89 made this change.

[11:04] <Geth> ¦ problem-solving: review: https://github.com/Raku/problem-solving/commit/18890dc9f4

[11:06] *** linkable6 joined
[11:12] <guifa> nine: forgive my ignorant Q, but how would I add an entry to a package stash via action code?  Just switch $*UNIT to $*PACKAGE ? 

[11:25] *** jaguart left
[11:29] <nine> guifa: oh, in actions. Sorry, I missed that context. Look into $*W.install_lexical_container. It takes a :scope. But really....this sounds like bad timing for fiddling in that stuff. This is really what RakuAST is making so much easier it's not even funny.

[11:29] <nine> So if at all possible, I'd suggest working with the rakuast branch instead.

[11:30] <guifa> nine: yeah I know :-) I finally have gotten the hang of slangs, but I'm in the really awkward middle phase where it's super easy to generate the code with RakuAST, but things still need to be installed via $*W to be usable in the slang :-)

[11:30] <_Xliff> nine: I want to emit a set of need statements into a given lexical scope. Does the existing set of macros allow for that or will I need to test with RakuAST?

[11:31] <_Xliff> Right now, if I use "macro A { quasi { need B; Need C; Need D } };" the compunits are not cvisible to the scope that called A.

[11:36] <_Xliff> : use experimental :macros; macro A { quasi { need NativeCall; NativeCall::CArray[uint32].^name.say }; }; sub a { A; NativeCall::CArray[uint32].^name.say }; a

[11:37] <_Xliff> m: use experimental :macros; macro A { quasi { need NativeCall; NativeCall::CArray[uint32].^name.say }; }; sub a { A; NativeCall::CArray[uint32].^name.say }; a

[11:37] <camelia> rakudo-moar af31b1df8: OUTPUT: «No such method 'AT-KEY' for invocant of type 'VMNull'␤  in any  at <tmp> line 1␤  in sub a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:37] <_Xliff> ^^ Oh, and there's that...

[12:07] *** reportable6 left
[12:09] *** reportable6 joined
[12:22] *** frost left
[12:29] *** melezhik joined
[12:29] *** melezhik left
[12:30] *** melezhik joined
[12:35] *** melezhik left
[12:43] *** dakkar left
[12:43] *** dakkar joined
[13:05] *** Geth left
[13:05] *** lizmat joined
[13:13] *** jaguart joined
[13:25] *** lizmat left
[13:26] *** lizmat joined
[13:36] *** killown left
[13:54] *** killown joined
[13:55] *** vodkra left
[14:00] *** vodkra joined
[14:02] *** morte_ joined
[14:07] *** Sgeo joined
[14:16] *** Geth joined
[14:22] *** Geth left
[14:22] *** Geth joined
[14:35] *** p6steve joined
[14:36] <p6steve> raku

[14:37] <lizmat> you're damn right!

[14:37] <p6steve> -m 'Nan.^name'

[14:37] <p6steve> -m Nan.^name

[14:40] <p6steve> m: Nan.^name

[14:40] <camelia> rakudo-moar af31b1df8: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Undeclared name:␤    Nan used at line 1␤␤»

[14:40] <p6steve> m: NaN.^name

[14:40] <camelia> rakudo-moar af31b1df8: ( no output )

[14:40] <p6steve> m: say NaN.^name

[14:40] <camelia> rakudo-moar af31b1df8: OUTPUT: «Num␤»

[14:40] <p6steve> phew

[14:40] <p6steve> M: say "".^name

[14:40] <p6steve> m: say "".^name

[14:40] <camelia> rakudo-moar af31b1df8: OUTPUT: «Str␤»

[14:41] <p6steve> so both Num and Str have a "none" value of their type

[14:42] <p6steve> does Int have similar?

[14:43] <discord-raku-bot> <Nemokosch> Every type does, no?

[14:44] <p6steve> I am trying to use something more concrete than (Int)

[14:45] <p6steve> as in "its defined to be 'none'"

[14:48] <p6steve> guess I will have to go with (Int) anyways since I want

[14:48] <p6steve> m: (1,2,3).are

[14:48] <camelia> rakudo-moar af31b1df8: ( no output )

[14:48] <lizmat> m: dd (1,2,3).are

[14:48] <camelia> rakudo-moar af31b1df8: OUTPUT: «Int␤»

[14:49] <p6steve> m: dd (1,2,3,(Int)).are

[14:49] <camelia> rakudo-moar af31b1df8: OUTPUT: «Int␤»

[14:49] <p6steve> tx

[14:50] <p6steve> m: <a b c>.are

[14:50] <camelia> rakudo-moar af31b1df8: ( no output )

[14:50] <p6steve> m: dd <a b c>.are

[14:50] <camelia> rakudo-moar af31b1df8: OUTPUT: «Str␤»

[14:50] <p6steve> m: dd <a b c (Str)>.are

[14:50] <camelia> rakudo-moar af31b1df8: OUTPUT: «Str␤»

[14:50] <p6steve> and so on

[14:53] <p6steve> m: dd (1.0, NaN).are

[14:53] <camelia> rakudo-moar af31b1df8: OUTPUT: «Real␤»

[14:53] <p6steve> m: dd (1e0, NaN).are

[14:53] <camelia> rakudo-moar af31b1df8: OUTPUT: «Num␤»

[14:53] <p6steve> m: dd (1e0, NaN, (Num)).are

[14:53] <camelia> rakudo-moar af31b1df8: OUTPUT: «Num␤»

[15:02] <jaguart> Whats the diff between .WHAT and .^name?

[15:02] <nine> What gives the type object, name gives the type's name

[15:03] <jaguart> ummm

[15:03] <p6steve> I heard that .^name is to be preferred, not sure why

[15:04] <jaguart> ok - makes sense, when I `say 0.WHAT` it stringify's the class into its name?

[15:05] <nine> yes

[15:06] <p6steve> m: say 0.^name.^methods

[15:06] <camelia> rakudo-moar af31b1df8: OUTPUT: «(BUILD Capture COERCE Int Num Version pred succ match subst-mutate parse-base Date DateTime IO WHY WHICH Bool Str Stringy DUMP ACCEPTS chomp chop starts-with ends-with substr-eq contains indices index rindex Numeric gist raku comb subst lines split sa…»

[15:06] <p6steve> .^name seems to give you more than just a Str

[15:07] <p6steve> m: say 0.^name.^name

[15:07] <camelia> rakudo-moar af31b1df8: OUTPUT: «Str␤»

[15:07] <p6steve> OK - that's cool

[15:09] <jaguart> where in docs can I find details on .are - it's hard to search for :/

[15:09] *** irc_user joined
[15:14] <discord-raku-bot> <Nemokosch> What even is it

[15:15] <jaguart> looks like it's a List thingy that tells you about the List content type

[15:15] <jaguart> m: say (1,2,3).are

[15:15] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Int)␤»

[15:15] <jaguart> m: say (1,2,'a').are

[15:15] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Cool)␤»

[15:16] <jaguart> m: say (1.0,0.2).are

[15:16] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Rat)␤»

[15:19] <nine> Method are is a recent addition (only introduced this year) that's not yet documented

[15:21] <p6steve> .are returns the narrowest type that all items match

[15:23] <p6steve> (guess it only applies to built in types??)

[15:23] <p6steve> generally that is types that have ancestor Cool

[15:24] <p6steve> https://docs.raku.org/type/Cool#Type_Graph

[15:25] <p6steve> m: say ((Map),(Range)).are

[15:25] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Iterable)␤»

[15:25] <jaguart> oh that is nice :)

[15:29] <p6steve> m: class Kid{}; my Kid $john; my Kid $anna; say ($anna,$john).are;

[15:29] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Kid)␤»

[15:29] <p6steve> nope applies to stuff youmake too

[15:30] <nine> I think it would actually have been more difficult to restrict it to builtin types...

[15:32] <jaguart> Hmm a lot of `Died with X::Method::NotFound`

[15:32] <jaguart> m: say (1,2,3.0).are

[15:32] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Real)␤»

[15:33] <jaguart> Oh interesting - that `Died with X::Method::NotFound` in my REPL...

[15:33] <jaguart> and works after restart

[15:36] *** wcs joined
[15:38] <jaguart> m: say ((Map),(Iterable)).are

[15:38] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Iterable)␤»

[15:38] <jaguart> m: say ((Iterable),(Map)).are

[15:38] <camelia> rakudo-moar af31b1df8: OUTPUT: «No such method 'mro' for invocant of type␤'Perl6::Metamodel::ParametricRoleGroupHOW'␤  in block <unit> at <tmp> line 1␤␤»

[15:39] <jaguart> m: say ((Map),(Iterable)).are

[15:39] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Iterable)␤»

[15:42] *** morte_ left
[15:45] *** morte_ joined
[15:47] <nine> jaguart: why do you use those extra parentheses there?

[15:47] *** abraxxa left
[15:47] <nine> m: say (Map, Iterable).are

[15:47] <camelia> rakudo-moar af31b1df8: OUTPUT: «(Iterable)␤»

[15:48] *** melezhik joined
[15:48] <melezhik> .

[15:48] <tellable6> 2022-07-07T07:22:55Z #raku <CIAvash> melezhik: Thanks. It has CI, but it's in "closed testing phase" and you have to request early access.

[15:49] <melezhik> lizmat: Probably you're seen, just decided to tell just in case - I created a couple of GH issues for your modules test failures on sparkyci, hopefully helpful

[15:50] <melezhik> you're -> you've

[15:50] *** morte_ left
[15:51] *** morte_ joined
[15:55] *** melezhik left
[16:22] *** morte_ left
[16:32] *** dakkar left
[16:59] *** guifa left
[16:59] <[Coke]> https://github.com/Raku/doc/issues/4034 (the ticket for documenting .are)

[16:59] <[Coke]> (extra parens) you're outputting a type object, not a string. that's how the type object stringifies.

[16:59] <[Coke]> m: dd (Map, Iterable).are

[16:59] <camelia> rakudo-moar af31b1df8: OUTPUT: «Iterable␤»

[17:00] <[Coke]> m: dd (Map, Iterable).are.^WHAT

[17:00] <camelia> rakudo-moar af31b1df8: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Cannot use .^ on a non-identifier method call␤at <tmp>:1␤------> dd (Map, Iterable).are.^WHAT⏏<EOL>␤    expecting any of:␤        method arguments␤»

[17:00] <[Coke]> m: (Map, Iterable).are.new.^WHAT.say

[17:00] <camelia> rakudo-moar af31b1df8: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Cannot use .^ on a non-identifier method call␤at <tmp>:1␤------> (Map, Iterable).are.new.^WHAT⏏.say␤    expecting any of:␤        method arguments␤»

[17:00] <[Coke]> oof.

[17:02] <[Coke]> m: dd (Map, Iterable).are.WHAT

[17:02] <camelia> rakudo-moar af31b1df8: OUTPUT: «Iterable␤»

[17:04] <[Coke]> I was conflating ^name and WHAT. :)

[17:42] <[Coke]> `cal`to emit this month's calendar: 0.01s; raku to run 'say now': .7s

[17:48] <[Coke]> Guessing it's not worth trying to do any optimizations on App::Cal. :)

[17:50] *** jaguart left
[17:59] *** Sankalp joined
[18:07] *** reportable6 left
[18:09] *** reportable6 joined
[18:20] *** jaguart joined
[18:25] <jaguart> Coke: thanks for the correction - just assumed I needed the extra parens

[18:26] <japhb> [Coke]: What kind of system has raku getting a .7s startup time?

[18:27] <japhb> (FWIW, it's less than .2s on my heavily loaded several-year-old laptop)

[18:27] <lizmat> my 10+ year old MacMini it's .218 seconds

[18:27] <lizmat> (running Debian)

[18:28] <lizmat> on the 2 year old MacMini with an M1: .11

[18:42] <[Coke]> my 2014 mac mini

[18:43] <[Coke]> it's .179 for -e1;

[18:44] <[Coke]> ... numbers I'm seeing now are much faster. wtf?

[18:44] <[Coke]> might have had something running in the bg.

[18:57] *** peder left
[19:00] *** peder joined
[19:01] *** peder_ joined
[19:02] *** swaggboi left
[19:05] <discord-raku-bot> <Anton Antonov> I am looking for (much) faster alternative of "Text::CSV"  -- any suggestions. (I should be able to easily run it on macOS.)

[19:06] <discord-raku-bot> <Anton Antonov> I am looking for (much) faster alternative of "Text::CSV"  -- any suggestions? (I should be able to easily run it on macOS.)

[19:06] <[Coke]> Not unless you're willing to cheat and not follow the spec.

[19:07] <[Coke]> text::csv is commonly used as a performance canary to ensure rakudo isn't slowing down; it's implemented by the author of perl5's version of the module. You're not going to find another implementation that's as accurate.

[19:07] <discord-raku-bot> <Anton Antonov> @Coke Haha, ok. I tried cheating and failed...

[19:08] <discord-raku-bot> <Anton Antonov> Ok, good to know! (Almost all my packages use "Text::CSV" for resource data ingestion.)

[19:08] <[Coke]> You could try Inline::Perl5 and perl5's version of Text::CSV - I believe that is reported as slightly faster.

[19:09] <[Coke]> yah, whenver I write something that needs CSV, if I try to cheat, I have to pull in T::CSV not long after. Have learned to just embrace it for consumption.

[19:10] <lizmat> the Perl version of Text::CSV is about 6x faster, I believe

[19:11] <[Coke]> even when used via rakudo?

[19:11] <lizmat> ah...   hmmm... possibly,   :-)

[19:11] <discord-raku-bot> <Anton Antonov> @lizmat 6 times faster motivates me to try it.

[19:12] <lizmat> Anton Antonov: please let us know what you find!

[19:13] <discord-raku-bot> <Anton Antonov> Will do -- it is a "real life" project with production level data. I trying to evaluate my Raku-implemented recommender over some of the data.

[19:14] <lizmat> cool!

[19:16] <discord-raku-bot> <Anton Antonov> BTW, my Raku implementation is a "reference implementation" -- it has all the features needed for most recommendations workflows and it is based on Mix objects. Usually, after ingesting the data works fast enough.

[19:20] *** swaggboi joined
[19:28] *** irc_user left
[19:32] <japhb> .oO( Transcode from CSV to CBOR using whatever's the fastest transcoder you can find, then use CBOR::Simple for loading the transcoded data )

[19:37] *** vrurg_ is now known as vrurg

[19:39] <discord-raku-bot> <Anton Antonov> @japhb Great suggestion! I will try it out today.

[19:42] <discord-raku-bot> <Anton Antonov> @japhb "Transcode[r] from CSV to CBOR" -- Any suggestions?

[19:46] *** Madcapjake left
[19:48] <japhb> Thinking.

[19:48] <japhb> Is the CSV you're loading mixed text and numbers, or just pure numbers, or pure text?

[19:50] *** sena_kun left
[19:51] <p6steve> japhb: there lies the problem ;-)

[19:52] <japhb> p6steve: That you don't know?  Or that it is mixed and weird?

[19:53] *** sena_kun joined
[19:55] <japhb> Hmmm, I'm seeing various premade JSON <-> CBOR transcoders, but not off the shelf for CSV.  Actually, I wonder if having a pure-perl5 process that uses one of the faster CSV modules to load, then e.g. CBOR::XS or CBOR::Free to write, would be a fast enough transcoder.

[19:57] <p6steve> btw you can use Dan::Pandas; my \df .= DataFrame.new; df.pd: '.read_csv("test.csv")';

[19:58] <japhb> Looks like Text::CSV_XS is the fast one on the Perl 5 side.

[19:59] <p6steve> japhb: sorry - just reflecting that CSV slowness is because usually you don't know what's out there

[20:01] <japhb> p6steve: Oh sure, I was just meaning, if you *happened* to know what the data sets roughly looked like, there are different ways you can do the transcode to speed things up.  For example, CBOR has the concept of packed arrays ... if what you've got in each row is for instance all numbers, or a couple text fields and then a lot of numeric fields, you can take advantage of packed arrays to get much smaller and 

[20:01] <japhb> faster.

[20:01] <discord-raku-bot> <Anton Antonov> I am trying to use Python package called "cbor2" right now.

[20:01] <japhb> Let us know how it goes!  :-)

[20:03] <discord-raku-bot> <Anton Antonov> 🤞

[20:04] <p6steve> anton: IMO Inline::Python is OK for light use ... but I'm wary of pycall for heavy lifting

[20:05] <p6steve> anton: I'm knee deep right now in Rust/Polars (thus this non-module https://github.com/p6steve/raku-Inline-Rust)

[20:09] <p6steve> anton: would that help?

[20:09] <discord-raku-bot> <Anton Antonov> <@928301352029937715> I was never able to install "Inline::Python" on my mac.

[20:10] <discord-raku-bot> <Anton Antonov> <@928301352029937715> Doing it with Rust !? 🙂  I am not sure.

[20:10] <p6steve> https://container-service-1.gs7k0bfrb4gvk.eu-west-2.cs.amazonlightsail.com/lab/workspaces/auto-d/tree/raku-Dan-Jupyter/eg?reset

[20:10] <p6steve> password 'p6steve'

[20:11] <discord-raku-bot> <Anton Antonov> Sounds good, thanks! Will try it in the next 30 min.

[20:12] <p6steve> anton: please do have a play on the Jupyter - IMO Rust/Polars is the best engine (ie. no Python)

[20:14] *** MadcapJake joined
[20:16] <p6steve> gnight

[20:21] <p6steve> ah - need to restart lightsail ...

[20:22] <discord-raku-bot> <Anton Antonov> Ok -- will do.

[20:26] <p6steve> anton: new url -> https://container-service-1.gs7k0bfrb4gvk.eu-west-2.cs.amazonlightsail.com/

[20:27] <p6steve> anton: password 'p6steve'

[20:30] <discord-raku-bot> <Anton Antonov> <@928301352029937715>, Do I have to have an account at amazonlightsail?

[20:37] <discord-raku-bot> <Anton Antonov> @japhb I got a CBOR file -- how do I read it in Raku? Using `slurp` with ":bin" ?

[20:49] <discord-raku-bot> <Anton Antonov> @japhp Yeah, I got it working. And, yes, the CBOR utilization gives me the fastest ingestion of ≈700MB CSV file in Raku.

[20:54] *** andm left
[21:12] *** jaguart left
[21:14] <nine> [Coke]: according to the daily test runs, Text::CSV_XS via Inline::Perl5 is about 4x faster than Text::CSV. The valid comparison is csv-ip5xs-20 vs. test-t-20. The versions with fewer iterations are mostly comparing startup overhead. The --race version can't be compared because the benchmark doesn't include a threaded version using Inline::Perl5.

[21:15] *** swaggboi left
[21:26] *** swaggboi joined
[21:28] *** wcs left
[21:57] *** Colere left
[22:29] *** sena_kun left
[22:44] <japhb> Antonov: \o/

[22:44] <japhb> Glad to hear that.  :-)

[23:12] *** MadcapJake left
[23:13] *** _Xliff left
[23:13] *** Xliff left
[23:21] *** wcs joined
[23:32] *** Colere joined
[23:36] *** perlbot left
[23:37] *** simcop2387 left
[23:37] *** swaggboi left
[23:38] *** swaggboi joined
[23:58] *** perlbot joined
[23:59] *** simcop2387 joined
