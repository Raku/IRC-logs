[00:16] *** lichtkind left
[01:43] *** hulk joined
[01:44] *** kylese left
[02:15] *** hulk left
[02:15] *** kylese joined
[02:21] *** guifa left
[03:45] *** kylese left
[03:47] *** kylese joined
[04:04] *** Aedil joined
[05:52] *** defaultxr joined
[06:02] <defaultxr> Hi. What would be the best way to define some kind of syntax sugar wrapping `sub` that will automatically add the name of the subroutine being defined to an array. I was thinking of doing that with a macro like macro my-sub($name) { quasi { sub {{{$name}}}($param) { ... } OUR::<@my-array>.push: {{{$name}}}; } } but I get "variable $text is not defined" when i try to call it like this: my-sub foo {

[06:02] <defaultxr> say "Hi"; } I know macros are experimental, so is there a more "Raku" way to do what i'm looking for?

[06:03] <defaultxr> In this case, $text should be an argument in the resulting function, which is why it's not an argument to the macro.

[06:04] <defaultxr> Oh I mistyped, $param in my macro should say $text

[06:41] <disbot3> <jubilatious1_98524> @defaulfxr I don't know about arrays, but you can do that with a Pair literal variant, see: https://discord.com/channels/538407879980482560/538420565980086273/1375820541835083856

[06:42] <disbot3> <jubilatious1_98524> m: my $var =42; say ~:$var

[06:42] <disbot3> <Raku eval>  var    42 

[06:51] <disbot3> <cerumod> oh, i forgot about this discord server.. but yeah, thanks, though i'm not sure i'm understanding how that can be used to do what i'm looking for. it looks like that is for getting a string of the variable name and its value?

[06:54] <disbot3> <cerumod> basically what i want is a sugary way to do raku sub foo(...) { ... } @my-array.push: &foo;  without having to manually remember to write the second line of that every time

[06:55] <disbot3> <cerumod> instead i'd like to be able to just write raku my-sub foo { ... } 

[06:56] <disbot3> <cerumod> my attempt seems close, but i get a "variable $text is not declared" error when i try to use this: raku macro my-sub($name, &body) {     quasi {         sub {{{$name}}}($text) { &body; }         OUR::<@my-array>.push: {{{$name}}};     } } 

[07:01] <disbot3> <cerumod> not sure if there's some way to escape the $text so that the macro isn't trying to expand it at macro expansion time

[07:31] <Voldenet> I don't really get what you're trying to do, but you're getting into very deep hole with this

[07:32] <Voldenet> which may be not even necessary

[07:32] <Voldenet> m: my @all; sub trait_mod:<is>(&sub, :$known) { @all.push(&sub.name); &sub.wrap( -> |c { say "do you even need it wrapped tho?"; callsame }) }; sub huh is known { 2 }; say huh; say @all

[07:32] <camelia> rakudo-moar f52cc9284: OUTPUT: «do you even need it wrapped tho?␤2␤[huh]␤»

[07:36] <Voldenet> it's not exactly the same syntax, but I'd argue it's more flexible, composable etc.

[07:46] <Voldenet> tiny problem is of the approach is that it's possible to create a sub with non-reachable name

[07:47] <Voldenet> m: my @all; sub trait_mod:<is>(&sub, :$known) { @all.push(&sub.name); &sub.wrap( -> |c { say "do you even need it wrapped tho?"; callsame }) }; sub p(&x){}; p(sub huh is known { 2 }); say @all

[07:47] <camelia> rakudo-moar f52cc9284: OUTPUT: «[huh]␤»

[07:59] <disbot3> <cerumod> yeah i'm not married to the idea of using macros or anything, they're just what i'm used to using for tasks like this when i'm writing in other languages. this trait_mod snippet looks like exactly what i need though, thank you!

[08:02] <Voldenet> it should be `multi trait_mod` probably

[08:06] <Voldenet> m: my @all; multi trait_mod:<is>(Sub $sub, :$known) { say $sub.name.WHAT; @all.push($sub.name); $sub.wrap( -> |c { say "do you even need it wrapped tho?"; callsame }) }; sub huh is known { }; say @all

[08:06] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Str)␤[huh]␤»

[08:06] <disbot3> <jubilatious1_98524> m: raku -e 'sub foo($name) { put $name; }; say ~:foo("arnold");'

[08:06] <disbot3> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Two terms in a row at /home/glot/main.raku:1 ------> raku -e⏏ 'sub foo($name) { put $name; }; say ~:f     expecting any of:         infix         infix stopper         postfix         statement end         statement modifier         statement modifier loop 

[08:08] <disbot3> <jubilatious1_98524> m: sub foo($name) { put $name; }; say ~:foo("arnold");'

[08:08] <disbot3> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Unable to parse expression in single quotes; couldn't find final "'" (corresponding starter was at line 1) at /home/glot/main.raku:1 ------> e) { put $name; }; say ~:foo("arnold");'⏏<EOL>     expecting any of:         single quotes         term 

[08:09] <disbot3> <jubilatious1_98524> m: sub foo($name) { put $name; }; say ~:foo("arnold");

[08:09] <disbot3> <Raku eval>  foo    arnold 

[08:45] *** wayland joined
[08:45] *** wayland76 left
[09:31] *** Sgeo left
[09:41] *** lichtkind joined
[09:47] <disbot3> <librasteve> weekly: https://dev.to/fco/cromponent-new-features-3bhf

[10:14] *** Aedil left
[11:10] *** Guest41 joined
[11:33] *** Tanto79 joined
[11:34] *** Tanto79 left
[11:40] *** jjido joined
[11:57] *** guifa joined
[12:14] <SmokeMachine> m: raku -e 'sub foo($name) { put $name; }; say ~:&foo("arnold");'

[12:14] <camelia> rakudo-moar f52cc9284: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> raku -e<HERE> 'sub foo($name) { put $name; }; say ~:&␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤    …»

[12:15] <SmokeMachine> m: sub foo($name) { put $name }; say ~:&foo

[12:15] <camelia> rakudo-moar f52cc9284: OUTPUT: «Sub object coerced to string (please use .gist or .raku to do that)␤foo foo␤  in block <unit> at <tmp> line 1␤»

[12:18] <SmokeMachine> cerumod: I don’t know what you want to do, but maybe storing the subs themselves would be better than storing their names?

[12:21] <SmokeMachine> m: my @all; multi trait_mod:<is>(Sub $sub, :$known) { @all.push($sub) }; sub huh is known { say 42 }; .() for @all

[12:21] <camelia> rakudo-moar f52cc9284: OUTPUT: «42␤»

[12:30] *** markong joined
[12:37] *** abraxxa-home joined
[12:40] *** jjido left
[12:50] *** abraxxa-home left
[13:30] *** simcop2387 joined
[13:34] *** Guest41 left
[13:55] *** jjido joined
[14:14] *** jjido left
[14:14] <arkiuat> So the solution that y'all proposed yesterday using subsets and a parameterized role is coming along nicely; thanks for your help!

[14:14] <arkiuat> or was it day before yesterday?

[14:26] *** guifa left
[14:29] *** jjido joined
[14:36] *** markong left
[14:39] *** jjido left
[14:47] <SmokeMachine> :)

[15:25] *** Guest41 joined
[15:28] *** arkiuat left
[15:39] *** jjido joined
[15:45] *** arkiuat joined
[15:50] *** arkiuat left
[15:53] <tbrowder> hi

[15:54] <tbrowder> is there any way to make a subroutine private other than not exporting it?

[15:57] *** guifa joined
[15:58] <tbrowder> if not, in a package, can a lower-levej sub be made private to external users for higher-level subs?

[16:00] <tbrowder> i'm talking about normal use, not exotic access by determined users of Raku who can probably inspect everything.

[16:02] *** Guest41 is now known as poisNada

[16:12] *** markong joined
[16:18] *** Aedil joined
[16:20] *** arkiuat joined
[16:24] *** poisNada27 joined
[16:25] *** poisNada27 left
[16:25] *** arkiuat left
[16:36] *** poisNada left
[16:45] *** jjido left
[16:51] *** cliviafreak joined
[16:52] *** arkiuat joined
[16:57] *** guifa left
[17:00] *** guifa joined
[17:01] *** arkiuat left
[17:02] *** arkiuat joined
[17:06] *** arkiuat left
[17:08] <disbot3> <librasteve> hi tom … as https://docs.raku.org/type/Sub says subs are private already, nothing outside the block can see it … they are “my” scoped

[17:16] *** jjido joined
[17:24] *** arkiuat joined
[17:28] *** bisectable6 left
[17:29] *** arkiuat left
[17:31] *** bisectable6 joined
[17:36] *** cliviafreak left
[17:44] *** wayland76 joined
[17:45] *** wayland left
[17:47] *** Guest41 joined
[17:49] *** Guest41 is now known as poisNada

[17:51] <tbrowder> librasteve: ah, that sound familiar, thank you very much!

[17:51] <tellable6> tbrowder, I'll pass your message to librasteve_

[17:52] <tbrowder> back to the docs…

[17:55] <disbot3> <librasteve> you're welcome

[17:56] *** guifa left
[18:00] *** arkiuat joined
[18:05] *** arkiuat left
[18:25] *** arkiuat joined
[18:31] *** arkiuat left
[18:34] *** markong left
[18:46] *** guifa joined
[18:54] *** ManfredLaner joined
[18:56] *** ManfredLaner left
[18:59] *** arkiuat joined
[18:59] *** guifa left
[19:02] *** guifa joined
[19:05] *** arkiuat left
[19:08] *** arkiuat joined
[19:11] *** poisNada left
[19:49] <disbot3> <librasteve> weekly: https://rakujourney.wordpress.com/2025/07/13/harc-stack-modelling/

[20:07] *** Sgeo joined
[20:29] *** Guest41 joined
[20:59] <arkiuat> okay, I know there is a way to provide two different names for the same method, but I'm blanking on it. noai.duckduckgo.com mostly comes up with docs on multi subs or other irrelevancies no matter what search phrase I try, and I haven't turned it up in docs.raku.org after many searches

[21:01] <arkiuat> and yes, I've also been trying all sorts of things in the REPL, and seeing a lot of different error messages there

[21:06] <guifa> uh I don't think for methods there is

[21:06] <guifa> I've added a quick trait in the past allowing for aliasing of method names

[21:09] <guifa> m: multi sub trait_mod:<is>(Method \m, Str :$also-called) { $*PACKAGE.^add_method($also-called,m) }; class A { method foo is also-called<bar> { say 42 } }; Foo.foo; Foo.bar;

[21:09] <camelia> rakudo-moar f52cc9284: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Undeclared name:␤    Foo used at lines 1, 1␤␤»

[21:09] <guifa> err

[21:09] <guifa> m: multi sub trait_mod:<is>(Method \m, Str :$also-called) { $*PACKAGE.^add_method($also-called,m) }; class A { method foo is also-called<bar> { say 42 } }; A.foo; A.bar;

[21:09] <camelia> rakudo-moar f52cc9284: OUTPUT: «42␤42␤»

[21:10] <guifa> arkiuat: ^^ you can obviously change the name of the trait as suits you

[21:20] <arkiuat> guifa++ thanks

[21:22] <guifa> I think the only reason I did that kind of aliasing was to allow for kebab and camel case simultaneously

[21:23] <arkiuat> I just wanted to have a long name that was clear and a short name for typing in the REPL and whatnot

[21:24] <guifa> ah yeah

[21:24] <guifa> totally good usecase

[21:51] *** Guest41 left
[22:01] *** lichtkind left
[22:10] *** guifa left
[22:22] <arkiuat> I just realized the "technique" I had originally been thinking of but was unable to bring to mind, a much simpler one: declaring a method that simply passes its args through to the method that I wanted to alias

[22:22] <arkiuat> weird how blanking on things works

[22:33] *** markong joined
[22:33] <arkiuat> the only special sauce is using |@_, |%_ as the args for the internal call

[22:55] <SmokeMachine> arkiuat: maybe it would be better to use a Capture for that…

[22:56] <SmokeMachine> m: sub a(|c) { b |c }; sub b(|d) { say d }; a 42, :13bla

[22:56] <camelia> rakudo-moar f52cc9284: OUTPUT: «\(42, :bla(13))␤»

[22:58] *** jjido left
[22:58] *** wayland76 left
[23:01] *** arkiuat left
[23:13] *** arkiuat joined
[23:18] *** arkiuat left
[23:46] *** arkiuat joined
[23:51] *** arkiuat left
[23:53] *** guifa joined
