[01:26] *** kylese left
[01:27] *** kylese joined
[01:44] *** dg left
[01:45] *** kylese left
[01:49] *** dg joined
[01:56] *** dg left
[02:02] *** dg joined
[03:14] *** Aedil joined
[07:43] <ab5tract> antononcube: Nice article! I stumbled on this code though: $poet4.defined && $poet4 ?? $poet4 !! $poet3

[07:44] <ab5tract> Why not $poet4 || $poet3 ?

[08:22] <Voldenet> more expressive

[08:32] <Voldenet> same reason why people prefer True and False over !0 and !1 despite them being shorter

[08:40] *** kylese joined
[09:07] *** Aedil left
[09:10] *** oodani left
[09:14] <disbot1> <jubilatious1_98524> In the R-programming language that's written: if(!is.na(poet4)) ifelse(test=poet4, yes=poet4, no=poet3)

[09:15] <disbot1> <jubilatious1_98524> Or more simply (because R understands positionals if named-arguments are not used): if(!is.na(poet4)) ifelse(poet4, poet4, poet3)

[09:16] *** oodani joined
[09:51] *** Sgeo left
[10:22] <ab5tract> Voldenet: it reads as overly verbose and pedantic. I don’t agree at all with the comparison to inverted integers standing as boolean

[10:23] <ab5tract> And besides, I was asking the author

[10:25] <ab5tract> I guess through acts of borderline conceptual violence, someone could create an undefined object which is also True

[10:26] <ab5tract> Writing overly verbose code to protect against corner cases like that is what I disliked most about Perl, fwiw

[10:27] *** Aedil joined
[10:43] <ab5tract> jubilatious1_98524: that’s how now::if works (minus the named params). It can be pretty handy to have that construct, even if it can also feel a bit clunky as a bit of syntax

[10:46] *** cryosis left
[10:47] *** cryosis joined
[10:47] *** cryosis left
[10:47] *** cryosis joined
[10:52] <disbot1> <jubilatious1_98524> @ab5tract I'm just coming back to R so a bit rusty. Not sure it can be simplified and wheter-or-not that's what @antononcube intends. R used tri-valued logic so poet4 = NA works.  But automatic char -> logical conversion doesn`t.

[10:55] <ab5tract> the || operator ($a || $b) is literally doing $a.defined && $a.so ?? $a !! $b

[10:56] <ab5tract> Again unless user space has introduced objects that not defined but are true

[10:57] <ab5tract> So I’m not sure there’s any need for a new construct

[10:57] *** cryosis left
[10:58] <ab5tract> But it’s accessible via use nqp if it’s wanted

[10:59] *** cryosis joined
[10:59] * ab5tract sees nqp::if was autocorrected to now::if in a previous message :/

[11:00] <disbot1> <jubilatious1_98524> AboveR code might need isTRUE(x), which in R  "is the same as { is.logical(x) && length(x) == 1 && !is.na(x) && x }; isFALSE() is defined analogously.

[11:00] <disbot1> <jubilatious1_98524> Thx, nqp:if makes sense.

[11:04] <disbot1> <jubilatious1_98524> I think I understand. In R you can define  x <- NA and you'll get back is.na(x) #TRUE, but if you haven't defined y you'll get back is.na(y) #Error: object 'y' not found

[11:05] <disbot1> <jubilatious1_98524> But you're saying you can declare an object tyoe in Raku which is True.

[11:06] <disbot1> <jubilatious1_98524> 'tyoe' should be 'type'

[11:06] <disbot1> <jubilatious1_98524> (cool, editing works).

[11:42] <disbot1> <jubilatious1_98524> I'm glad Raku has True and False, in contrast someone told me Perl started with !!1 and !!0.

[11:43] <Voldenet> maybe I went overboard with !0 and !1, but it's a neat trick, I'll use it ;)

[11:46] <Voldenet> I wasn't explaining, just trying to justify the "why" behind it

[11:48] <Voldenet> I do like expressive syntax though, even if it means verbose code

[11:49] <Voldenet> so I like things like `if(thing == false) { }`

[11:49] <Voldenet> even if they're not elegant and redundant at times

[11:52] <Voldenet> > Can't locate object method "say" via package "true" (perhaps you forgot to load "true"?) at -e line 1.

[11:56] <Voldenet> going back to perl after using raku for a while is not pleasant

[13:20] *** wayland76 joined
[13:20] *** wayland left
[13:51] *** human-blip left
[13:53] *** human-blip joined
[14:05] *** LainIwakura joined
[14:18] <disbot1> <antononcube> @ab5tract Good point. Basically, that was an initial “LLM::Graph” development and documentation example. “LLM::Graph” provides asynchronous (LLM-)programming and initially I was not sure how reliably the input variables to the graph are propagated and treated with the introspection routines.

[14:19] <disbot1> <antononcube> For example, any Whatever before given to the LLM-functions is replaced with the empty string, etc.

[14:28] <disbot1> <antononcube> Also, as a documentation example I want to be seen that $poet4 can be undefined -- this hints that corresponding sub is not always evaluated. (Because of the result of the corresponding test function.)

[14:34] *** LainIwakura left
[14:41] <ab5tract> antononcube: makes sense!

[14:44] <ab5tract> It’s always a balancing act with this stuff. My reaction was that spelling it out this way may give the impression that Raku requires that kind of detailed style of handling defined truthies

[14:45] <ab5tract> Voldene: fair point. I reacted a bit quickly there, should have processed a bit I think

[14:49] <ab5tract> WRT Perl, I think ‘use v5.38’ should give you say (and sub signatures, with a new enough version).

[14:49] <ab5tract> ‘say’ was always a tough one for them to put into the namespace because I guess there were tons of bespoke implementations on the DarkPAN

[14:52] <disbot1> <antononcube> I am not sure now -- now I think therer should be a remark in the post that clarifies the verbose code. Or the other way around uses the short code and explains that $poet4 can be undefined, but also be an empty string.

[14:52] <disbot1> <antononcube> Currently, "LLM::Graph" does not handle broken promises directly, and it should. So far, LLMs handle those nicely, but the handling should be more targeted.

[15:08] <ab5tract> antononcube: maybe another option to highlight these potential states would be to use a named subset

[15:24] *** melezhik joined
[15:24] <melezhik> .

[15:35] *** Aedil left
[15:45] *** Aedil joined
[17:18] *** jgaz joined
[17:34] *** melezhik left
[17:57] *** librasteve_ joined
[18:18] <disbot1> <librasteve> I just fezzed https://github.com/librasteve/FatRatStr which solves the issues covered in https://github.com/issues/created?issue=Raku%7Cproblem-solving%7C494 ... ideally this would have used class FatRatStr is Allomorph is FatRat {} but I couldn't get the inheritance to work ... anyone with proper raku skills welcome to come in and advise ;-)

[18:19] <disbot1> <librasteve> also ... perhaps a candidate for adding to rakudo core (?)

[18:28] *** eseyman left
[18:32] *** manu_ joined
[18:32] *** samebchase left
[18:33] *** samebchase joined
[18:41] <SmokeMachine> AI has helped me to create new .groups for ASTQuery, does anyone have any opinion about that? Does anyone have any suggestion on new groups I should add? https://github.com/FCO/ASTQuery/blob/main/REFERENCE.md

[19:06] *** Sgeo joined
[19:17] *** TempIRCLogger joined
[19:17] <lizmat> .

[19:18] *** TempIRCLogger left
[19:21] *** TempIRCLogger joined
[19:21] <lizmat> TempIRCLogger: Hello in there

[19:21] *** TempIRCLogger left
[19:21] *** TempIRCLogger joined
[19:23] *** TempIRCLogger left
[19:23] *** TempIRCLogger joined
[19:24] *** TempIRCLogger left
[19:25] *** TempIRCLogger joined
[19:36] <disbot1> <librasteve> hello

[19:39] <lizmat> PSA: it looks like irclogs.raku.org and Geth will be down on Mon 15 Sep from 0600 - 0800 UTC due to electricity works at their data center

[19:39] <lizmat> twas in preparation for ^^  :-)

[19:41] <disbot1> <librasteve> SmokeMachine: gosh ... that looks very comprehensive ... its all a bit unexplored for me so I cant really add anything concrete - nice job

[19:41] <disbot1> <librasteve> weekly: https://github.com/FCO/ASTQuery/blob/main/REFERENCE.md

[19:41] <notable6> librasteve, Noted! (weekly)

[19:43] <SmokeMachine> librasteve: thanks! :) AI helped me with the README as well, if you'd like to give it a read:  https://github.com/FCO/ASTQuery

[19:48] <ab5tract> SmokeMachine: that is genuinely impressive. It’s a bit intense seeing the full volume of RakuAST classes all in one place tho!

[19:50] <disbot1> <librasteve> the readme helps a lot ... I have dabbled in the very shallow end of AST and found it very turgid to deal with ... so I grok that a tool ike this is a big big improvement. would you mind posting an "idiots guide" on https://www.reddit.com/r/rakulang/ or wherever... if you can think of "the code box to do on raku.org but with extended explanation maybe?

[19:53] <SmokeMachine> librasteve: I'll try to ask opencode to help me preparing something for that...

[19:54] <disbot1> <librasteve> =b

[19:55] <SmokeMachine> here is an example of usage: https://github.com/FCO/Acme-Overreact/blob/main/lib/Acme/Overreact.rakumod

[19:59] <disbot1> <librasteve> as a certified idiot, sadly that goes over my head

[19:59] <SmokeMachine> ab5tract: I agree... but I couldn't find a better way to show that... :(

[20:00] <SmokeMachine> librasteve_: https://usercontent.irccloud-cdn.com/file/taBZutUC/image.png

[20:01] <disbot1> <librasteve> not to worry - RakuAST is a big step change and we will work out best way to grip it and to show it off

[20:25] <disbot1> <jubilatious1_98524> m: my $poet1 = 'Blake'; my $bl = '', my $nil = Nil; say $poet1 // $poet1.so ?? $poet1 !! 'no return' ;

[20:25] <evalable6> jubilatious1_98524, rakudo-moar f56482941: OUTPUT: «Blake␤»

[20:25] <disbot1> <Raku eval>  Blake 

[20:26] <disbot1> <jubilatious1_98524> m: my $poet1 = 'Blake'; my $bl = '', my $nil = Nil; say $bl // $bl.so ?? $bl !! 'no return' ;

[20:26] <evalable6> jubilatious1_98524, rakudo-moar f56482941: OUTPUT: «no return␤»

[20:26] <disbot1> <Raku eval>  no return 

[20:26] <disbot1> <jubilatious1_98524> m: my $poet1 = 'Blake'; my $bl = '', my $nil = Nil; say $nil // $nil.so ?? $nil !! 'no return' ;

[20:26] <disbot1> <Raku eval>  no return 

[20:26] <evalable6> jubilatious1_98524, rakudo-moar f56482941: OUTPUT: «no return␤»

[20:29] <disbot1> <jubilatious1_98524> (I screwed up the semicolons between my declarations, but the code still worked)

[20:50] *** zetaaaa joined
[21:08] <ab5tract> SmokeMachine: I didn’t mean it as a knock on the current presentation. It looks great to me. Just a bit fazed by the sheer scope of RakuAST

[21:12] *** jmcgnh left
[21:14] *** manu_ is now known as eseyman

[21:46] *** TempIRCLogger left
[21:46] *** TempIRCLogger joined
[21:47] *** TempIRCLogger left
[21:48] <SmokeMachine> I'm trying to write the post about ASTQuery... It seems most of rakuast attributes are RO... that limits a lot the possibilities...

[21:48] *** TempIRCLogger joined
[21:49] *** jmcgnh joined
[21:49] <lizmat> SmokeMachine: a RakuAST is supposed to be immutable from the outside

[21:49] <SmokeMachine> lizmat: even on CHECK?

[21:49] <lizmat> well... that's the question, really  :-)

[21:50] <lizmat> do we want to make changes to the tree itself, or create a copy with changes

[21:51] <SmokeMachine> but, I have found a few things mutable before, for example the args of a function...

[21:51] <SmokeMachine> I tried the making the copy to... but it seems $*CU is also RO...

[21:51] <lizmat> sure, there are some mutator methods... but they are intended to be used by the grammar to fix chicken/egg problems

[21:53] <SmokeMachine> I think RakuAST will be much more powerful if editable on CHECK...

[21:54] <lizmat> agree that the RakUAST tree will need to be mangled for all types of uses: think static opts, constant folding, etc...

[21:55] <lizmat> but whether that should be attainable by modifying an existing tree, I'm not sure

[21:56] <SmokeMachine> I don't see a huge gain to make all nodes imutable if you can change the root... but I may not be seeing something...

[21:56] <lizmat> consider that a lot of RakuAST nodes contain internal state

[21:57] *** bolangi joined
[21:57] <SmokeMachine> that will be needed on the copy as well, right?

[21:58] <lizmat> but then you would only need to write logic that creates internal state on instantiation of a node

[21:59] <lizmat> otherwise you would also need to write logic for the internal state on alteration of a node

[22:00] <lizmat> whether immutable or mutable is the best way to go, is *not* that clear to me at the moment

[22:00] <lizmat> but maybe I'm more functional programmer than the pope here   :-)

[22:07] <SmokeMachine> lizmat: I had not thought about the state creation... that makes sense...

[22:13] <SmokeMachine> I think I'll change ast-query to return a copy of the tree then... maybe create a new func for that...

[22:41] *** zetaaaa left
[22:41] *** zetaaaa joined
[23:26] *** librasteve_ left
[23:46] *** cryosis left
[23:46] *** cryosis joined
[23:47] *** cryosis left
[23:47] *** cryosis joined
[23:51] *** cryosis left
[23:52] *** cryosis joined
[23:52] *** cryosis left
[23:53] *** cryosis joined
