[01:12] *** kylese left
[01:14] *** kylese joined
[01:22] *** wayland76 joined
[01:22] *** wayland left
[02:15] *** kylese left
[02:17] *** kylese joined
[02:48] *** elcaro left
[02:48] *** elcaro joined
[03:12] *** apogee_ntv left
[03:12] *** apogee_ntv joined
[04:08] *** cm left
[04:09] *** stanrifkin joined
[04:16] *** cm joined
[04:37] *** kjp_ joined
[04:41] *** kjp left
[04:50] *** kylese left
[04:56] *** kylese joined
[05:01] *** derpydoo joined
[05:55] *** Aedil joined
[07:01] *** Sgeo left
[07:19] *** Aedil left
[08:08] <disbot> <simon_sibl> why the :g adverb cannot be used with rx but with m ?

[08:53] *** hvxgr left
[09:03] *** hvxgr joined
[10:00] *** lichtkind joined
[10:18] <disbot> <jubilatious1_98524> Not sure how to explain it: rx is a sequence of atoms that will be used within a regex-matcher. m denotes the matcher itself. Only m can take the adverbs (e.g. :g) that tune the Raku regex engine, probably because these can only be declared once per matcher (although some local exceptions exist, :i for example).

[10:57] <disbot> <simon_sibl> because I wanted to capture all numbers in a string but I could only make it work using m:g/\d+/, and I encountered something weird, when using m:g/something {code}/ it doesnt seem to process all the match, I need to force it by looping over $/ to get all the matches and execute all the code, I was wondering if rx would have the same behavior, or if m:g is lazy by default or something

[11:14] *** sftp left
[11:20] *** LainIwakura joined
[11:40] *** Aedil joined
[11:46] *** benchable6 left
[11:46] *** notable6 left
[11:46] *** shareable6 left
[11:46] *** coverable6 left
[11:46] *** unicodable6 left
[11:46] *** bisectable6 left
[11:46] *** quotable6 left
[11:46] *** evalable6 left
[11:46] *** sourceable6 left
[11:46] *** tellable6 left
[11:46] *** linkable6 left
[11:49] *** greppable6 joined
[11:49] *** tellable6 joined
[11:50] *** unicodable6 joined
[11:51] *** coverable6 joined
[11:53] *** evalable6 joined
[11:55] *** notable6 joined
[11:57] *** nativecallable6 joined
[12:08] *** LainIwakura left
[12:30] *** derpydoo left
[12:48] *** bd3i left
[12:48] *** bd3i joined
[12:57] <disbot> <antononcube> @lizmat I think it is good idea to have a Raku documentation/sites navigation LLM persona.

[12:58] <disbot> <antononcube> Agh -- that is actually wayland"s post.

[13:00] *** apa_c joined
[13:03] <lizmat> weekly: https://dev.to/lizmat/purl-support-4m8h

[13:03] <notable6> lizmat, Noted! (weekly)

[13:12] *** apa_c left
[13:12] <disbot> <antononcube> What is a good / better way to determine what a string doesn't have interpretation variables in it? I can, of course, make a regex which looks for sigiled sub-strings and/or code blocks, but is that enough? There might be a better way, given that Raku has a full-blown qq/qqx DSL.

[13:13] <lizmat> antononcube a string with interpretation variables in them, doesn't exist: they're a grammar construct

[13:13] *** avar left
[13:14] *** avar joined
[13:14] <lizmat> "foo$bar-baz" is just a short way of saying "foo ~ $bar ~ "-baz"

[13:14] <disbot> <antononcube> I'm sorry I meant "interpolation". (It was AutoCorrected..)

[13:15] <lizmat> "foo$bar+baz" is just a short way of saying "foo ~ $bar ~ "+baz"

[13:15] <lizmat> in the AST / QAST there's just that expression

[13:16] <lizmat> so is the question:  check whether 'foo$bar+baz" has a $bar string in it? 

[13:16] <lizmat> s/"/'

[13:29] <disbot> <antononcube> I want to check is a string a potential string template that has to be filled in with variable values. For example: (1) 'escaped $x not interpolation', (2) "percent %hash interpolation", (3) "brace { 1 + 2 } interpolation", etc.

[13:30] <lizmat> try to EVAL the string and see if it produces errors ?

[13:30] *** stanrifkin left
[13:30] *** apa_c joined
[13:32] <disbot> <antononcube> Yeah, that is a good, concise approach. The &has-interpolation sub I have is way too big and cumbersome.

[13:48] <disbot> <m.dango> The L10N project prompted a thought: Would it be worth having filter as a synonym for grep? I don't think its a term we use anywhere in Raku currently, and Perl is exceptional in using the term grep for the higher order function: https://en.wikipedia.org/wiki/Filter_(higher-order_function)

[13:50] <disbot> <antononcube> @m.dango Why using "filter" why not using "select"?

[13:50] <disbot> <antononcube> Meaning, I think it is fine to just have grep.

[13:51] <lizmat> fwiw, for newbies without unix background, I think "filter" would make a lot of sense

[14:06] <disbot> <m.dango> For why not "select" I guess I would phrase it as "select is Ruby's method for a filter, and grep is Raku's method for a filter", filter being the language-agnostic term.

[14:08] <disbot> <jubilatious1_98524> Can't you just push matches onto an array? FYI you'll get a ton of info if you run dd m/ my match here /

[14:08] <lizmat> also, "select" feels more to select only one item, at least to me, akin to "first" rather than "grep"

[14:10] <disbot> <antononcube> But "filter" is both a verb and a noun. "Select" is a verb and adjective. "Grep" are just a verb.

[14:12] <lizmat> so is frobnicate

[14:12] <disbot> <jubilatious1_98524> @m.dango filter is a bad term. Are you "filtering in" or 'filtering out"? Much discussion about this in Perl6 docs. Don't do it.

[14:13] <disbot> <simon_sibl> I mean in the exo I was doing, I was doing this:

[14:13] <disbot> <simon_sibl> m:g/mul( (\d+), (\d+) ) {$sum += $0 * $1}/ (basically and without the quoting)

[14:13] <evalable6> simon_sibl, rakudo-moar f56482941: OUTPUT: «(exit code 1) ===SORRY!=== Error while compilin…»

[14:13] <evalable6> simon_sibl, Full output: https://gist.github.com/26d82ad14f2938e8dcfcb437ac74377d

[14:13] <disbot> <simon_sibl> this happens in a loop for each line of input, and I realized it only runs the first number it found, to force to do all the numbers it found in the ligne I had to "force" looping through $/ after all the matches

[14:14] <disbot> <simon_sibl> so something like this for ... {m:g/mul( (\d+), (\d+) ) {$sum += $0 * $1}/; .sink for $/[]} only then it would do all the matches and execute all the code blocks within the regex

[14:14] <disbot> <simon_sibl> and that doesnt make sense to me xD

[14:59] *** stanrifkin joined
[15:11] *** arkiuat joined
[15:56] *** arkiuat left
[16:14] *** Sgeo joined
[16:17] *** arkiuat joined
[17:04] *** jjido joined
[17:08] *** arkiuat left
[17:16] *** jjido left
[17:18] *** jjido joined
[17:22] *** arkiuat joined
[17:27] *** arkiuat left
[17:54] *** arkiuat joined
[17:59] *** arkiuat left
[18:08] *** librasteve_ joined
[18:10] <disbot> <librasteve> fwiw - I think it would be weird to have two ways to write grep in raku

[18:12] <disbot> <antononcube> One grep to rule them all!!

[18:12] *** arkiuat joined
[18:12] <disbot> <librasteve> no one (?) is proposing to rewrite Linux to have filter instead of grep, so since we want raku to play well as a command line utility I think it is a bonus to teach newbs that grep == filter in less refined languages

[18:13] <librasteve_> weekly: https://discourse.nixos.org/t/development-environments-with-nix/68028/8

[18:13] <notable6> librasteve_, Noted! (weekly)

[18:16] <disbot> <antononcube> Correction -- grep filters out all the rest.

[18:17] *** arkiuat left
[18:23] *** grondilu left
[18:24] *** jast left
[18:46] *** jast joined
[18:47] *** arkiuat joined
[18:55] *** arkiuat left
[19:12] *** Guest1057 left
[19:13] *** Guest2599 joined
[19:23] *** arkiuat joined
[19:27] *** arkiuat left
[19:51] *** arkiuat joined
[19:56] *** arkiuat left
[19:58] *** Aedil left
[20:21] *** arkiuat joined
[20:26] *** arkiuat left
[20:33] *** apa_c left
[20:40] *** DavidSch__ joined
[20:52] *** arkiuat joined
[20:57] *** arkiuat left
[21:07] *** apac joined
[21:09] <disbot> <jubilatious1_98524> I'd probably say (to) frobnicate if I needed a verb, frobnicating if I needed a participle, and frobnication if I needed a noun. But only because of my native language.

[21:11] *** apac left
[21:11] *** apac joined
[21:12] <disbot> <antononcube> Ok. "One frobnicator to rule them all!" sounds completely right.

[21:17] *** apac left
[21:17] *** DavidSch__ left
[21:17] *** apac joined
[21:19] *** jjido left
[21:26] <disbot> <jubilatious1_98524> @simonsibl ```~ % printf "19 20\n21\n22\n" | \     raku -ne 'BEGIN my @matches;               my $line = $;               @matches.push($/.Str) if m:g/  (\d+) (\d+) / for $line;               END .say for @matches;' 19 20 21 22 ```

[21:26] *** arkiuat joined
[21:28] <disbot> <jubilatious1_98524> Simpler: ~ % printf "19 20\n21\n22\n" | \     raku -ne 'BEGIN my @matches;               @matches.push($/.Str) if m:g/  (\d+) (\d+) /;               END .say for @matches;' 19 20 21 22 

[21:41] *** itaipu joined
[21:54] *** wayland joined
[21:54] *** wayland76 left
[21:56] <disbot> <jubilatious1_98524> @antononcube I've relied on the .raku (or .perl) routine to tell me what the compiler sees. But thsi might help: ~ % printf 'foo$bar+baz\n' | raku -ne 'put m/<-[\\]>+ \$bar/ ?? .raku !! "backslashed-input";' "foo\$bar+baz" ~ % printf 'foo\$bar+baz\n' | raku -ne 'put m/<-[\\]>+ \$bar/ ?? .raku !! "backslashed-input";' backslashed-input 

[22:02] *** apac left
[22:09] *** arkiuat left
[22:33] *** stanrifkin left
[22:36] *** wayland76 joined
[22:36] *** wayland left
[22:37] *** arkiuat joined
[22:42] *** arkiuat left
[22:42] *** AlexDaniel joined
[22:48] *** unicodable6 left
[22:50] *** bisectable6 joined
[22:55] *** committable6 joined
[22:56] *** releasable6 joined
[23:01] *** unicodable6 joined
[23:02] *** wayland76 left
[23:06] *** lichtkind left
[23:21] *** arkiuat joined
[23:39] *** simcop2387 left
[23:40] *** simcop2387 joined
