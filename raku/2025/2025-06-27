[00:02] *** librasteve left
[00:08] *** jjido left
[00:15] *** librasteve joined
[00:20] *** librasteve left
[00:48] *** librasteve joined
[00:53] *** librasteve left
[01:21] *** librasteve joined
[01:26] *** librasteve left
[01:26] *** hulk joined
[01:27] *** kylese left
[01:37] *** tejr left
[01:38] *** tejr_ joined
[01:38] *** tejr_ is now known as tejr

[01:55] *** librasteve joined
[02:00] *** librasteve left
[02:12] <[Coke]> .seen util

[02:12] <tellable6> [Coke], I saw util 2024-04-16T20:36:58Z in #raku: <Util> Summary: (1) we want more Raku talks. (2) Rakudo internals qualifies for the Science track (paper or poster). Thanks!

[02:15] *** hulk left
[02:15] *** kylese joined
[02:16] *** tejr left
[02:21] *** tejr joined
[02:31] *** librasteve joined
[02:35] *** librasteve left
[03:04] *** librasteve joined
[03:09] *** librasteve left
[03:25] *** maylay left
[03:31] *** maylay joined
[03:36] *** librasteve joined
[03:41] *** librasteve left
[03:45] *** kylese left
[03:47] *** kylese joined
[03:55] *** oodani left
[03:58] *** oodani joined
[04:11] *** librasteve joined
[04:16] *** librasteve left
[04:38] *** tejr left
[04:44] *** librasteve joined
[04:46] *** tejr joined
[04:49] *** librasteve left
[04:57] *** tejr left
[05:18] *** librasteve joined
[05:19] *** sjm_ joined
[05:22] *** librasteve left
[05:24] *** soverysour joined
[05:39] *** ACfromTX joined
[05:51] *** librasteve joined
[05:59] *** librasteve left
[06:11] *** librasteve joined
[06:15] *** librasteve left
[06:18] *** soverysour left
[06:21] *** soverysour joined
[06:34] *** tbrowder left
[06:34] *** tbrowder joined
[06:44] *** librasteve joined
[06:46] *** soverysour left
[06:49] *** librasteve left
[06:57] *** PotatoGim left
[06:57] *** PotatoGim joined
[07:07] *** Aedil left
[07:13] *** librasteve joined
[07:17] *** librasteve left
[07:18] *** wayland76 joined
[07:25] *** jjido joined
[07:28] *** Sgeo left
[07:45] *** librasteve joined
[07:49] *** soverysour joined
[07:55] *** librasteve left
[08:11] *** soverysour left
[08:27] *** jjido left
[09:22] *** librasteve joined
[09:29] *** avuserow left
[09:34] *** avuserow joined
[09:40] *** human-blip left
[09:56] *** nine left
[09:57] *** nine joined
[09:58] *** nine left
[09:59] *** nine joined
[10:02] *** nine left
[10:03] *** nine joined
[10:20] *** librasteve left
[10:47] *** librasteve joined
[10:48] *** merp left
[10:50] *** merp joined
[10:52] *** librasteve left
[11:33] *** librasteve joined
[11:47] *** sjm_ left
[11:48] *** human-blip joined
[12:03] *** librasteve left
[12:15] *** librasteve joined
[12:17] <Geth> ¬¶ problem-solving: slavenskoj assigned to codesections Issue Towards an AI-powered Raku https://github.com/Raku/problem-solving/issues/481

[12:19] *** librasteve left
[12:30] <Geth> ¬¶ problem-solving: lizmat unassigned from codesections Issue Towards an AI-powered Raku https://github.com/Raku/problem-solving/issues/481

[12:30] *** sivoais left
[12:31] *** sivoais joined
[12:50] *** librasteve joined
[12:54] *** librasteve left
[13:01] *** leah2 left
[13:03] *** leah2 joined
[13:19] *** librasteve joined
[13:22] <ugexe> I suspect they‚Äôve never had to review code generated by ai at any real level

[13:23] <ugexe> Nor have they had to review ai code reviews at any real level 

[13:23] *** librasteve left
[13:24] <ugexe> I have and it is one of the biggest issues I deal with because it is impossible to properly review mass amounts of code berated by someone with little understanding of the workings directing an ai 

[13:25] <ugexe> It might even be the single biggest issue I deal with as an engineering manager 

[13:27] <ugexe> s/berated/generated/

[13:33] <ugexe> The main problem here being the magnitude of output 

[13:52] *** librasteve joined
[13:55] *** Aedil joined
[13:59] *** librasteve left
[14:01] <lizmat> ugexe: mind if I add these comments to the issue ?

[14:05] <lizmat> specifically https://irclogs.raku.org/raku/gist.html?,2025-06-27Z13:22,2025-06-27Z13:23,2025-06-27Z13:24,2025-06-27Z13:25,2025-06-27Z13:27,2025-06-27Z13:33

[14:18] *** Sgeo joined
[14:25] *** librasteve joined
[14:42] *** simcop2387 left
[14:50] <SmokeMachine> What is ‚Äúthe xz incident‚Äù? Sorry if I shouldn‚Äôt be asking that‚Ä¶

[14:52] <Voldenet> https://en.wikipedia.org/wiki/XZ_Utils_backdoor

[14:55] <Voldenet> AI-generated docs are mostly ok, a lot better than no docs at all

[14:55] <Voldenet> they should only contain info about being automatically generated

[14:56] <SmokeMachine> Voldenet: thanks

[14:57] <Voldenet> iirc AI-written tests (both white and blackbox) are often not testing what they should

[14:58] <Voldenet> whitebox often test behaviors that are not guaranteed, blackbox skip testing important things

[15:01] <Voldenet> so these tests can become truly evil, because they give false sense of safety net, but the net isn't attached to anything solid

[15:02] <Voldenet> or rather, AI needs to be instructed on what has to be tested

[15:11] *** human-blip left
[15:13] *** human-blip joined
[15:21] *** simcop2387 joined
[15:24] *** librasteve left
[15:26] *** librasteve joined
[15:30] *** melezhik joined
[15:30] <melezhik> o/

[15:31] <melezhik> Anyone has an experience calling Raku from c++ ?

[15:32] <lizmat> eh...  perhaps Perl's Inline::Perl6 module could serve as inspiration (although that may have bitrotted significantly)

[15:34] *** librasteve left
[15:35] <melezhik> Thanks Liz. I thought maybe someone has already something with that regards . Maybe I will go with just ‚Äúspawn Rakudo process‚Äù way , extremely inefficient but probably ok for my purposes ‚Ä¶

[15:44] *** librasteve joined
[15:45] *** soverysour joined
[15:45] *** soverysour left
[15:45] *** soverysour joined
[15:49] *** librasteve left
[15:51] <disbot3> <apogee> What's best practice for shipping a module with a C FFI dependency?

[15:54] <lizmat> ugexe may have some ideas about that

[15:56] <disbot3> <apogee> I'm writing a wrapper for Tokenizers

[15:56] <disbot3> <apogee> Then probably onnx

[15:57] <disbot3> <apogee> Oh hm onnx has one

[15:57] <disbot3> <apogee> Thats good

[15:58] <disbot3> <apogee> ‚ö†Ô∏è Important: Due to a bug in Raku's module precompilation system when using NativeCall with function pointers, the bindings cannot be packaged as a traditional Raku module. Instead, use the standalone scripts provided.  Oh üòÑ

[15:58] <lizmat> is that still true ?

[15:58] <disbot3> <apogee> Not sure, it's on the ONNX::Runtime readme

[15:59] <disbot3> <apogee> Looks like it was 11 days ago.

[16:00] <lizmat> aah...  well, there's no reference to any issue afaics

[16:00] <lizmat> ah, yes, AI generated module

[16:01] <disbot3> <apogee> So probably not a Raku issue?

[16:01] <lizmat> well, what can I say: If the AI, or its manager, doesn't report problems, we cannot fix them

[16:01] *** soverysour left
[16:03] *** soverysour joined
[16:03] *** soverysour left
[16:03] *** soverysour joined
[16:03] *** orangebot joined
[16:09] *** librasteve joined
[16:09] *** Aedil left
[16:13] *** Aedil joined
[16:19] <disbot3> <apogee> I'll try to confirm the issue later & report if I can with a minimum reproduction example.

[16:21] <lizmat> apogee fwiw I did https://github.com/slavenskoj/raku-onnx-bindings/issues/1

[16:26] <disbot3> <apogee> Nice, if they don't reply I'll try to reproduce the issue.

[16:26] <disbot3> <apogee> I've been meaning to take a look at the Rakudo sources

[16:26] <disbot3> <apogee> And MoarVM

[16:28] *** librasteve left
[16:29] *** librasteve joined
[16:29] <disbot3> <apogee> I want to optimize that Simplex implementation and it's hard without seeing how the bytecode gets compiled/optimized and run.

[16:30] <disbot3> <apogee> I'd imagine using native types would help

[16:30] <lizmat> yes, as I suggested yesterday ?

[16:30] <disbot3> <apogee> Yeah

[16:30] <disbot3> <apogee> I just need to get it done üòÑ

[16:31] <disbot3> <apogee> Your help is much appeciated. I did some of the low hanging fruit stuff but it was so hot yesterday I ended up falling asleep before getting back to it.

[16:32] <lizmat> heh.. upper 90s (35C) expected here for next Tue/We

[16:32] <lizmat> d

[16:32] <disbot3> <apogee> But it'll be nice to be able to understand the whole stack, what happens under the hood etc. C is very comfortable for me, I'm new to Raku.

[16:33] <lizmat> well, C questions will be mostly answerable by people on #moarvm

[16:33] <disbot3> <apogee> Yeah it's not quite that hot here but I live on a boat and no AC. üòÑ

[16:33] <disbot3> <apogee> 80 right now at 5.30pm

[16:33] <[Coke]> we just spent 2 days in the car with it 95-100F outside.

[16:33] * [Coke] melts at the thought of no ac

[16:33] <disbot3> <apogee> Yeah I'll hop on IRC over the weekend

[16:33] <disbot3> <apogee> Yeah here in the UK heat tends to be a passing thing

[16:34] <disbot3> <apogee> There's no space on the boat for a proper AC unit, could probably get a caravan unit on

[16:34] <disbot3> <apogee> But those are pricy.

[16:35] *** librasteve left
[16:37] <[Coke]> I used to be OK with no AC, but then I spent 1.5 years in Houston, Texas, and was spoiled for it.

[16:37] <disbot3> <apogee> Yeah I spent a couple of years in Florida and also got spoiled on it.

[16:38] <[Coke]> Nearly everything was AC'd all year, and I don't want to go through the withdrawal.

[16:40] <disbot3> <apogee> Yeah was similar in Tampa

[16:47] *** soverysour left
[16:47] <SmokeMachine> ab5tract: I must be doing something wrong... https://usercontent.irccloud-cdn.com/file/RC7dQiFu/image.png

[16:47] *** soverysour joined
[16:47] *** soverysour left
[16:47] *** soverysour joined
[16:50] <SmokeMachine> ab5tract: if I did not misundtood it, it should print 42, no?

[16:56] <[Coke]> You want .result.say

[16:56] <[Coke]> otherwise you're saying the promise itself, not the result of the promise

[16:57] <[Coke]> m: await Promise.kept(42).andthen: { .result.say }

[16:57] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´42‚ê§¬ª

[16:58] <ab5tract> SmokeMachine: you need to `use v6.e.PREVIEW`

[16:58] <ab5tract> or `use 6.*`

[16:58] <SmokeMachine> oh! of course, sorry!

[16:59] <[Coke]> ? that doesn't seem to change the result of the .say, does it?

[16:59] <ab5tract> ]Cok

[16:59] <ab5tract> [Coke]: R#5917 and R#5892

[16:59] <linkable6> R#5917 [open]: https://github.com/rakudo/rakudo/pull/5917 New andthen/orelse for 6.e

[16:59] <linkable6> R#5892 [open]: https://github.com/rakudo/rakudo/issues/5892 Promise.andthen and Promise.orelse could provide the .result or .cause directly.

[17:00] <SmokeMachine> now it's working! sorry ignoring that was guarded for v6.e...

[17:00] <ab5tract> your thoughts appreciated on those tickets

[17:00] <ab5tract> SmokeMachine: no worries!

[17:01] <[Coke]> as long as it's guarded, no issues here.

[17:01] *** human-blip left
[17:01] <[Coke]> m: use v6.e.PREVIEW; await Promise.kept(42).andthen: { .say }

[17:01] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´Promise.new(scheduler => ThreadPoolScheduler.new(uncaught_handler => Callable), status => PromiseStatus::Kept)‚ê§¬ª

[17:02] <[Coke]> Just checking, is that change only in a branch right now? (or PR?)

[17:02] <SmokeMachine> https://usercontent.irccloud-cdn.com/file/ryfWrH99/image.png

[17:03] <ab5tract> indeed. it's SmokeMachine's job now to try and break it :)

[17:03] *** human-blip joined
[17:04] <ab5tract> [Coke]: note the third example in that screenshot is the one I'd most like feedback on. The branch currently implements as JS does, where the promise result is awaited if Awaitable

[17:04] <ab5tract> er, if the result of the andthen block is a promise it is awaited if Awaitable, sorry

[17:05] <ab5tract> I'm back and forth on whether that's too much action at a distance or not.. but today I'm leaning towards it being the better semantics

[17:06] <SmokeMachine> I like very much using that with JS...

[17:08] <ab5tract> yeah I've warmed up to it. And it fits the name "andthen" (also "orelse") in that I can understand why a user would expect it to be blocking

[17:09] *** human-blip left
[17:09] <[Coke]> I like usability

[17:10] <[Coke]> As long as it's not too... fiddly?

[17:10] <[Coke]> This feedback probably not entirely useful. :)

[17:10] *** librasteve joined
[17:10] <ab5tract> you've more or less described my position, so.. :)

[17:11] *** human-blip joined
[17:11] <ab5tract> So if someone really wanted/needed the promise "itself", I believe a `start { start { ... } }` would do it

[17:12] *** orangebot left
[17:14] <SmokeMachine> or use `then` instead of andthen/orelse...

[17:15] <ab5tract> even better!

[17:16] *** vrurg_ joined
[17:16] *** vrurg left
[17:18] <SmokeMachine> should infix andthen/orelse work as the methods?

[17:37] *** vrurg joined
[17:38] <Voldenet> ab5tract: very nice addition - but consider using `$!result` in orelse too

[17:38] <Voldenet> instead of self

[17:40] *** vrurg_ left
[17:40] <Voldenet> also, maybe consider `sub try-await($value) { nqp::istype($value, Awaitable) ?? ‚Ä¶`

[17:40] *** melezhik left
[17:41] <Voldenet> so then it can become `try-await code($!result)`

[17:42] <Voldenet> fwiw my attempt, it also has failing test https://0x0.st/8l0Y.raku

[17:43] <Voldenet> because I didn't build try-await yet

[17:44] <Voldenet> one thing I find not nice about it is that it doesn't strictly behave like await

[17:45] <Voldenet> m: use nqp; say await [Promise.kept(1), Promise.kept(2)]; say nqp::istype([Promise.kept(1), Promise.kept(2)], Awaitable) # array with Awaitable gets awaited, but is not Awaitable directly

[17:45] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´(1 2)‚ê§0‚ê§¬ª

[17:47] <[Coke]> Do we want to have REA modules as part of the standard blin test?

[17:47] <[Coke]> ww

[17:47] <SmokeMachine> I have used something similar (but opposite) in a project... something like: `multi my-await(Awaitable $a) { my-await await $a }; multi my-await($a) { $a }`

[17:48] <Voldenet> so instead‚Ä¶

[17:49] <SmokeMachine> (it could also have a Positional candidate... but I didn't need that at time...)

[17:51] <SmokeMachine> (maybe the returning Awaitable from andthen/orelse could be on await instead of on those modules... that way it would work for "everuthing"...)

[17:52] <Voldenet> m: my $x = [Promise.kept(1)]; say nqp::istype($x, Awaitable) || nqp::istype($x, Any) && nqp::istype($x.are, Awaitable)

[17:52] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Could not find nqp::istype, did you forget 'use nqp;' ?‚ê§at <tmp>:1‚ê§------> kept(1)]; say nqp::istype($x, Awaitable)<HERE> || nqp::istype($x, Any) && nqp::istype(‚ê§¬ª

[17:52] <Voldenet> m: use nqp; my $x = [Promise.kept(1)]; say nqp::istype($x, Awaitable) || nqp::istype($x, Any) && nqp::istype($x.are, Awaitable)

[17:52] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´1‚ê§¬ª

[17:53] <Voldenet> However, await-all variant needs to be called for Array of Awaitable

[17:53] <Voldenet> m: use nqp; my $x = [Promise.kept(1)]; say nqp::istype($x, Awaitable) || nqp::istype($x, Any) && $x.are(Awaitable)

[17:53] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´True‚ê§¬ª

[17:53] <Voldenet> right, this works as well

[17:55] *** melezhik joined
[17:55] <melezhik> .

[17:55] <SmokeMachine> https://glot.io/snippets/h8ozutcapu

[17:56] *** soverysour left
[17:57] <SmokeMachine> Voldenet: but does that all need to be Awaitable? couldn't it be a single value inside that array?

[17:58] <Voldenet> yes, all value arrays need to be awaitable

[17:58] <Voldenet> erm

[17:58] <Voldenet> all array values

[17:59] <Voldenet> m: await [Promise.kept(1), 42]; # or this happens

[17:59] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´An operation first awaited:‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Died with the exception:‚ê§    Can only specify Awaitable objects to await (got a Int)‚ê§      in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[17:59] <SmokeMachine> but why? shouldn't be possible to await a single value inside an array?

[18:01] <SmokeMachine> (as the code on my link example)

[18:04] <SmokeMachine> https://usercontent.irccloud-cdn.com/file/0GvEAnIg/image.png

[18:10] <Voldenet> SmokeMachine: single value inside an array doesn't need to be awaited

[18:10] <SmokeMachine> why not?

[18:12] *** librasteve left
[18:19] <Voldenet> SmokeMachine: ‚Ä¶well, they are resolved already, aren't they

[18:19] <Voldenet> though maybe I'm too fixated on how `await` currently works

[18:19] <SmokeMachine> not that awaitable one...

[18:21] <[Coke]> japhb, patrickb: https://github.com/Raku/Blin/blob/coke/cleanup/lib/Blin/Essential.rakumod

[18:25] *** librasteve joined
[18:30] *** librasteve left
[18:33] <ab5tract> Voldenet: I interpreted that the request for orelse was to have the cause, so not sure what you mean

[18:34] <ab5tract> orelse by its nature doesn't have a value for  $!result? 

[18:35] <jdv> does Text::Diff::Sift4 test clean for anyone?

[18:35] <jdv> i get fail on head and 2025.03

[18:36] <Voldenet> ab5tract: well `.cause` is using `$!result` directly, I added github comment that should add more clarity

[18:37] <Voldenet> I'm assuming that .andthen and .orelse should use the lowest level possible, so they can avoid pointless overhead

[18:37] <Voldenet> otherwise they could be implemented in `.then` in saner way:

[18:38] <[Coke]> Uho, the essentials is bisecting PDF?

[18:39] <ab5tract> I don't really understand your comment, sorry

[18:40] *** human-blip left
[18:40] <Voldenet> ab5tract: if `$!status == Broken`, then `my \final-result := code(self.cause);` can become `my \final-result := code($!result);`

[18:40] <ab5tract> on the one hand you want to avoid overhead with self.cause (which does more than just $!result, it has conditional logic in it)

[18:41] <ab5tract> on the other hand you are suggesting to wrap $*AWAITER.await, and I can't see a reason for that

[18:41] *** human-blip joined
[18:42] *** soverysour joined
[18:42] <Voldenet> ab5tract: `await $x` can also operate on Array of Awaitables, which is‚Ä¶ debatable, but to maintain the consistency I this should be supported in andthen/orelse

[18:44] <ab5tract> Can you give an example as to how an array of awaitables can be supplied to andthen/orelse?

[18:44] <ab5tract> ah, sorry, you mean as a result of the block

[18:44] <Voldenet> m: say await await Promise.kept(5).andthen( $p -> { [Promise.kept($p.result)] })

[18:44] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Variable '$p' is not declared. Perhaps you forgot a 'sub' if this was‚ê§intended to be part of a signature?‚ê§at <tmp>:1‚ê§------> ay await await Promise.kept(5).andthen( <HERE>$p -> { [Promise.kept($p.result‚Ä¶¬ª

[18:45] <Voldenet> m: say await await Promise.kept(5).andthen( -> $p { [Promise.kept($p.result)] })

[18:45] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´(5)‚ê§¬ª

[18:45] <jdv> [Coke]: so SmokeMachine can run that module's test clean on "some linux"?

[18:45] <Voldenet> it's more obvious when you do things like this:

[18:45] <[Coke]> jdv: ?

[18:46] <[Coke]> .seen masterduke17

[18:46] <tellable6> [Coke], I saw masterduke17 2025-06-20T20:26:50Z in #raku-dev: <MasterDuke> Undeclared routine: evo used at line 1`

[18:46] <jdv> ok, you mean verified the failures?

[18:47] <Voldenet> $db.getUser(login => "test").andthen(-> $user { [$db.getProfile($user.id), $db.getAvatarUrl($user.id)] })

[18:47] <[Coke]> jdv: ?

[18:47] <Voldenet> or $db.get-user(login => "test").andthen(-> $user { [$db.get-profile($user.id), $db.get-avatar-url($user.id)] })

[18:47] <ab5tract> I don't know. That just makes me start flipping back to thinking it is more appropriate for the user to manager their own awaits

[18:48] <SmokeMachine> jdv: I do not have "some linux" here...

[18:49] <SmokeMachine> that would be the equivalent to return a Promise.all-of, right?

[18:50] <jdv> SmokeMachine: ok.  but you can reproduce the test failures?

[18:50] <Voldenet> ab5tract: perhaps so, in fact in most languages `await` only handles single awaitable and for arrays there are more obvious helpers `Promise.all-kept`, `Promise.all-broken`, `Promise.all` etc.

[18:50] <Voldenet> (`all` is unfortunate naming)

[18:53] <SmokeMachine> I'm start thinking that the "recursive" await should be on await (or a new &recursive-await) instead of on andthen/orelse... and it's easy enough to just instead of `return returns-promise()` to `return await returns-promise()`...

[18:56] <Voldenet> yes, but await is a method

[18:56] <Voldenet> e

[18:56] <Voldenet> m: say await Promise.kept(Promise.kept(2)).andthen(await *.result) # nope

[18:56] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´An operation first awaited:‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Died with the exception:‚ê§    Can only specify Awaitable objects to await (got a WhateverCode)‚ê§      in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[18:57] <Voldenet> m: say await Promise.kept(Promise.kept(2)).andthen(*.result.&await) # uh

[18:57] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´2‚ê§¬ª

[18:59] <SmokeMachine> m: multi my-await(Awaitable $a) { my-await await $a }; multi my-await(@a) { @a.map: { my-await $_ } }; multi my-await($a) { $a }; say my-await Promise.kept(Promise.kept(2)).andthen(await *.result)

[18:59] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´An operation first awaited:‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Died with the exception:‚ê§    Can only specify Awaitable objects to await (got a WhateverCode)‚ê§      in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:00] <SmokeMachine> m: multi my-await(Awaitable $a) { my-await await $a }; multi my-await(@a) { @a.map: { my-await $_ } }; multi my-await($a) { $a }; say my-await Promise.kept(Promise.kept(2)).andthen(*.result)

[19:00] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´2‚ê§¬ª

[19:00] <SmokeMachine> Voldenet: ^^

[19:01] <Voldenet> m: multi my-await(Awaitable $a) { my-await await $a }; multi my-await(@a) { @a.map: { my-await $_ } }; multi my-await($a) { $a }; say my-await Promise.kept([Promise.broken(1), Promise.in(5)]).andthen(*.result); say now - BEGIN now

[19:01] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´An operation first awaited:‚ê§  in sub my-await at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Died with the exception:‚ê§    1‚ê§      in sub my-await at <tmp> line 1‚ê§      in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:01] <Voldenet> m: multi my-await(Awaitable $a) { my-await await $a }; multi my-await(@a) { @a.map: { my-await $_ } }; multi my-await($a) { $a }; say my-await Promise.kept([Promise.broken(1), Promise.in(5)]).andthen(*.result).orelse( -> $p { 5 }); say now - BEGIN now

[19:01] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´An operation first awaited:‚ê§  in sub my-await at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§Died with the exception:‚ê§    1‚ê§      in sub my-await at <tmp> line 1‚ê§      in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[19:02] <Voldenet> a very long line this becomes

[19:02] <Voldenet> anyway, if you just do `map`, you will not await for all the results if the first dies

[19:04] <[Coke]> anyone know of an irc channel for cpantesters?

[19:06] <Voldenet> `my $file = open("x"); recursive-await Promise.kept(2).andthen( $p -> { [Promise.broken("foo"), start { $file.write("got $p"); }] }); $file.close` # if you don't await all the results, this might fail somehow, because the file is closed

[19:06] <Voldenet> so instead Promise.allof would have to be used, but it only handles array of awaitables :(

[19:07] <SmokeMachine> but if the first dies, it it does m: multi my-await(Awaitable $a) { my-await await $a }; multi my-await(@a) { @a.map: { my-await $_ } }; multi my-await($a) { $a }; say my-await Promise.kept([Promise.broken(1), Promise.in(5)]).andthen(*.result).orelse( -> $p { 5 }).andthen: {"1"}; say now - BEGIN now

[19:07] <SmokeMachine> m: multi my-await(Awaitable $a) { my-await await $a }; multi my-await(@a) { @a.map: { my-await $_ } }; multi my-await($a) { $a }; say my-await Promise.kept([Promise.broken(1), Promise.in(5)]).andthen(*.result).orelse( -> $p { 5 }).andthen: {"1"}; say now - BEGIN now

[19:07] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´1‚ê§0.060420252‚ê§¬ª

[19:07] <Voldenet> it should finish after 5 seconds

[19:09] <[Coke]> (cpantesters) never mind, got what I needed.

[19:11] <SmokeMachine> I was going to write that the it would not wait for the other promise...

[19:13] *** guifa joined
[19:17] *** guifa left
[19:22] *** librasteve joined
[19:23] *** Aedil left
[19:24] <Voldenet> m: sub my-await($a) { my @n = $a.map: { $_ ~~ Awaitable ?? $_ !! Promise.kept($_) }; await Promise.allof(@n); await @n }; say await Promise.kept([Promise.broken(1), Promise.in(2)]).andthen({ my-await .result }).orelse( -> $p { say $p.cause; 5 }); say now - BEGIN now

[19:24] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´An operation first awaited:‚ê§  in sub my-await at <tmp> line 1‚ê§  in block  at <tmp> line 1‚ê§‚ê§Died with the exception:‚ê§    1‚ê§      in sub my-await at <tmp> line 1‚ê§      in block  at <tmp> line 1‚ê§‚ê§5‚ê§2.062931677‚ê§¬ª

[19:24] <SmokeMachine> Voldenet: why should it wait 5 secs?

[19:24] <SmokeMachine> m: m: try await Promise.broken(1), Promise.in: 5; say now - BEGIN now

[19:24] <camelia> rakudo-moar dd636945c: OUTPUT: ¬´0.040709131‚ê§¬ª

[19:25] <Voldenet> SmokeMachine: when you run multiple async operations, they run independently - some operations could fail, some operations could succeed - after awaiting you close resources used for the operations

[19:26] <Voldenet> ‚Ä¶otherwise, promise is never awaited, it's running in the background with nothing ever awaiting it, so the program could even close in the middle of it

[19:26] <SmokeMachine> but it seems await breaks fast... as shown on my lass piece of code...

[19:26] *** librasteve left
[19:27] <Voldenet> yeah, it seems that `await(@)` is `await Promise.anyof(@)` actually, it's a choice

[19:28] <SmokeMachine> (I think that makes sense...)

[19:31] <SmokeMachine> I think I'll create a recursive-await module...

[19:39] <Voldenet> in fact, what I think that when working on arrays of promises, there's no shorthand for `await for all promises, then continue with results if none of them failed`

[19:43] *** guifa joined
[19:48] *** librasteve joined
[19:53] <ab5tract> so do I hear two votes in favor of leaving auto-await out of andthen/orelse?

[20:00] *** melezhik left
[20:12] *** soverysour left
[20:14] *** librasteve left
[20:24] <guifa> Does anyone know what happened to the old P6 exegesis docs?

[20:24] <guifa> Working on a history of presentation for the conference this weekend and I can't seem to find them anymore

[20:32] <[Coke]> guifa: good question.

[20:32] <[Coke]> the syn are at https://github.com/Raku/old-design-docs

[20:32] <jdv> https://web.archive.org/web/20221219205436/https://design.raku.org/

[20:32] <jdv> is the best i can do

[20:33] <guifa> jdv: thanks!

[20:33] <guifa> grrr

[20:34] <[Coke]> https://www.perl.com/authors/damian-conway/ looks like it has a bunch of them still

[20:34] <guifa> ah actually it was apoca that I needed but jdv's link worked

[20:34] <jdv> which is here?: https://github.com/Raku/raku.org/tree/main/archive/doc/design/exe

[20:35] <jdv> so https://github.com/Raku/raku.org/tree/main/archive/doc/design/apo

[20:35] <guifa> hrm I think I ended up on a different github

[20:35] <jdv> what a twisty maze of yesteryear 

[20:35] <[Coke]> mmm

[20:38] <guifa> I'm going to be starting from Perl v0 up through MooseX::Declare to Perl 6 to Raku to Corinna (aka "you didn't want a good thing then, but apparently now you do lol")

[20:41] <jdv> nice

[20:42] <guifa> except ruth pushed my talk from Sunday to Saturday and it was at 0% written as of about an hour ago :)

[20:42] *** librasteve joined
[20:42] <guifa> codesections got sick and couldn't make it :-(

[20:43] <Voldenet> ab5tract: not entirely ‚Äì basic await is a good idea, but `await []` is not that useful

[20:43] <[Coke]> guifa - thanks for stepping up!

[20:43] <ab5tract> ok

[20:44] <[Coke]> I'll give you a drink ticket if that helps. :)

[20:44] <guifa> hahahaha

[20:44] <guifa> honestly getting it done for tomorrow means I can enjoy Saturday night more fully

[20:44] <guifa> also sounds like I'm going to be put on a call with damian to get more deets on the history side.  now I'm really wishing i had more time to write this talk

[20:47] *** librasteve left
[20:47] <Voldenet> around the topic of await  - `multi await(*@ --> Array)` says `Waits until one or more promises are I<all> fulfilled, and then returns their

[20:47] <Voldenet> ...values`

[20:49] <Voldenet> My question is: what does `fullfilled` in the context mean and is the behavior of broken promise in that array specified in roast?

[20:50] *** guifa left
[20:50] <Voldenet> `Waits until one or more promises are kept or until first promise is broken` would be more reality-aligned

[20:51] <ab5tract> we could adjust the behavior in 6.e to align with the docs :)

[20:52] <Voldenet> what I mean:

[20:52] <Voldenet> m: { CATCH { default {  }}; say await [Promise.broken(0), Promise.in(1)] }; say now - BEGIN now # this breaks early

[20:52] <camelia> rakudo-moar e0d0d960c: OUTPUT: ¬´0.042674309‚ê§¬ª

[20:53] <ab5tract> Ah, I missed the ambiguity in the docs there ("one or more")

[20:53] <ab5tract> paired with "are all"

[20:53] <Voldenet> https://github.com/Raku/roast/blob/master/S17-promise/nonblocking-await.t -- this specifies breaking on the first promise, but doesn't specify that all of them have to be completed

[20:54] <ab5tract> I honestly feel like it should have always been `allof` and not `anyof`

[20:55] <ab5tract> but I guess we have methods on Promise for that ..

[20:55] <Voldenet> it's kind of anyof

[20:55] <Voldenet> anyof has other problem -- it gives you "True"

[20:55] <Voldenet> erm, allof

[20:55] *** jjido joined
[20:56] <Voldenet> m: { CATCH { default {  }}; my @x = [Promise.broken(0), Promise.in(1)]; say await Promise.allof(@x); say await @x }; say now - BEGIN now # typical usage of anyof :(

[20:56] <camelia> rakudo-moar e0d0d960c: OUTPUT: ¬´True‚ê§1.032650659‚ê§¬ª

[20:57] <SmokeMachine> Is the event happening tomorrow? Is it going to be recorded?

[21:07] *** bartolin joined
[21:15] *** guifa joined
[21:16] *** librasteve joined
[21:20] *** guifa left
[21:21] <tbrowder> hi, i‚Äôm back trying to use multi sub MAINs instead of trying to roll my own. is there some way to define a set  of default values of named options so they are auto-included with selected multi MAIN subs?

[21:22] *** librasteve left
[21:38] <SmokeMachine> m: multi MAIN(:$bla = "something default") { say $bla } # tbrowder something like this?

[21:38] <camelia> rakudo-moar e0d0d960c: OUTPUT: ¬´something default‚ê§¬ª

[21:42] <jdv> why do we still get "Merging GLOBAL symbols failed: duplicate definition" errors these days?

[21:43] <jdv> i thought lexically scoping is cleaner now

[21:43] <jdv> i think its because 2 versions of the same module are being used

[21:43] <jdv> lizmat: https://github.com/lizmat/IRC-Client/issues/66 is not resolved methinks

[21:49] *** librasteve joined
[22:13] <tbrowder> SmokeMachine: no, thanks, not exactly. when i get a chance, i‚Äôll provide a gist expanding on my question.

[22:25] *** jjido left
[22:30] *** librasteve left
[23:00] *** librasteve joined
[23:05] *** librasteve left
[23:15] <lizmat> jdv: zef install IRC::Client is clean for me?

[23:16] *** tejr joined
[23:16] <lizmat> anyways, too tired to look at now, first sleep&

[23:34] *** librasteve joined
[23:40] *** librasteve left
[23:56] <Voldenet> SmokeMachine, ab5tract: https://github.com/rakudo/rakudo/issues/5919 - relevant to andthen and orelse - thoughts?

