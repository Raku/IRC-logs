[00:42] *** avuserow left
[00:42] *** avuserow joined
[00:44] *** sacomo joined
[01:06] *** hulk left
[01:06] *** kylese joined
[01:44] *** ecocode___ left
[02:07] <avuserow> I'm running into a weird issue where importing a module `A` seems to prevent finding `our` scoped items in `A::B`. I tried to golf it down, and line 4 here seems to prevent line 12 from working: https://codeberg.org/avuserow/temp-raku-module-20250822/src/branch/main/lib/MyCLI/CLI.rakumod

[02:08] <avuserow> am I missing something about `our` scoped modules? I can never quite remember how modules are supposed to work with non-exported subs.

[02:11] *** topnep left
[02:12] *** topnep joined
[02:15] *** kylese left
[02:15] *** kylese joined
[02:44] *** gordonfish left
[02:44] *** gordonfish joined
[03:59] *** stanrifkin_ joined
[04:02] *** stanrifkin left
[04:39] *** Aedil joined
[04:50] *** kylese left
[04:51] *** kylese joined
[05:07] *** abraxxa left
[05:52] <wayland> avuserow: Are those line numbers in the error still correct? 

[05:59] <wayland> Also, is there a reason you don't have all the "use" statements grouped at the top?  

[06:04] *** SEric left
[06:05] *** SEric joined
[06:22] *** Guest5 joined
[06:23] *** Guest5 left
[08:06] <wayland> General question: if I'm in a start block, and I want to return a result from the start block, how do I do that?  "return" doesn't work.  

[08:07] <Voldenet> general answer: you don't

[08:09] <Voldenet> I don't think there's way to "return" from the block

[08:09] <Voldenet> m: say await start { return 3; 42 + 5 } # will not work

[08:09] <camelia> rakudo-moar f56482941: OUTPUT: «An operation first awaited:␤  in block <unit> at <tmp> line 1␤␤Died with the exception:␤    Attempt to return outside of any Routine␤      in block  at <tmp> line 1␤␤»

[08:09] <Voldenet> m: say await start -> { return 3; 42 + 5 }() # also will not work

[08:09] <camelia> rakudo-moar f56482941: OUTPUT: «An operation first awaited:␤  in block <unit> at <tmp> line 1␤␤Died with the exception:␤    Attempt to return outside of any Routine␤      in code  at <tmp> line 1␤␤»

[08:10] <Voldenet> m: say await start sub { return 3; 42 + 5 }() # will not work

[08:10] <camelia> rakudo-moar f56482941: OUTPUT: «3␤»

[08:10] <Voldenet> erm, will work*

[08:12] <Voldenet> but I think the most elegant way to do this is something like that:

[08:12] <Voldenet> m: sub foo { return 42; }; say await start foo;

[08:12] <camelia> rakudo-moar f56482941: OUTPUT: «42␤»

[08:16] <Voldenet> `leave` was supposed to be implemented for blocks, but it's NYI

[08:16] <Voldenet> it's made in a way that lets you return from a sub even when in a block

[08:17] <Voldenet> m: sub foo { 3.map({ .return }); return 42; }; say await start foo;

[08:17] <camelia> rakudo-moar f56482941: OUTPUT: «3␤»

[08:17] <Voldenet> these scoping rules could be very useful if "leave" was a thing

[08:29] <Voldenet> though I suppose that anonymous blocks are not made for anything really complex

[08:35] <Voldenet> Nothing prevents complex use, but I see their use mostly for one-liners in grep/map etc.

[08:40] <Voldenet> ah, there's also code organization, so you can do `sub x { { return 42 } }` - in this form it's more obvious why return works like it does inside blocks

[08:42] <Voldenet> but I'm not sure if Block object is created then, it's my guess only

[09:17] <disbot8> <jubilatious1_98524> What happens if you drop the {...} curlie braces around your BLOCK ? I find with -ne one-liners, BEGIN blocks run just  fine without any {...} curlie braces, in fact, they cause problems.

[09:20] *** greenfork left
[09:20] *** greenfork joined
[09:21] <disbot8> <jubilatious1_98524> What happens if you drop the {...} curlie braces around your BLOCK ? I find with -ne one-liners, BEGIN blocks run just  fine without any {...} curlie braces, in fact, they cause problems.

[09:23] *** Sgeo left
[09:24] *** hankache joined
[09:24] <disbot8> <jubilatious1_98524> What happens if you drop the {...} curlie braces around your BLOCK ? I find with -ne one-liners, BEGIN blocks run just  fine without any {...} curlie braces, in fact, they cause problems.

[09:26] <disbot8> <jubilatious1_98524> Sorry, thinking about PHASERS. https://docs.raku.org/language/phasers

[09:33] <disbot8> <jubilatious1_98524> m: my $promise = start { sleep 2; 42 }; say "This line executes immediately."; say "The asychronous result is ", $promise.result;

[09:33] <disbot8> <Raku eval>  This line executes immediately. The asychronous result is 42 

[09:34] *** hankache left
[09:35] <disbot8> <jubilatious1_98524> @wayland76 ☝️

[09:36] *** hankache joined
[09:38] *** hankache left
[09:42] *** hankache joined
[09:45] *** hankache left
[09:46] *** hankache joined
[09:47] *** hankache left
[09:50] <wayland> Voldenet: Unfortunately, lizmat has indicated that "leave" will probably never be implemented in Rakudo (which is a pity; I'd like it :) ).  

[09:51] <wayland> OK, so it looks like the answer is to put a sub in the start block, and then return from the sub.  Not wonderfully elegant, but probably workable.  

[09:52] <wayland> I'm at the point where I'm in a "start" block, and I've caught an exception, and I want to return a different result from the Promise.  

[09:52] <wayland> Thanks!  

[09:53] <lizmat> yeah, the benefits of a "leave" command vs the runtime overhead on all other blocks, were just too small

[09:53] <lizmat> change the block you want to leave from to a sub, and use "return"

[09:58] *** hankache joined
[09:59] <Voldenet> I was wondering if leave couldn't be implemented as goto, but goto isn't implemented either

[09:59] <Voldenet> :(

[09:59] <Voldenet> but probably goto is even more deadly

[09:59] <lizmat> well, yeah  :-)

[10:07] <wayland> Voldenet: haha, I was wondering the same thing an hour ago :) 

[10:08] <Voldenet> I'm thinking out loud now, but maybe compiler could recognize leave

[10:08] <SmokeMachine> Would it make sense to, in a module, implement leave throwing a control exception and on CHECK (using ASTQuery) search for “.block >> RakuAST::Call::Name#leave” and add a CONTROL on that block?

[10:09] <SmokeMachine> And at least have leave on module space? Would that work?

[10:09] <Voldenet> and do the following transformation `{ leave; code 1; leave; code 2 }` -> `{ my $left = 0; $left = 1; unless $left { code 1 }; $left = 1; unless $left { code 2 } }`

[10:10] <lizmat> well...  I guess that technically could be done in module space

[10:10] <lizmat> but you need to remember that e.g. "return" just happens to be a subroutine that throws a return control message

[10:11] <Voldenet> hm, or rather

[10:11] <lizmat> so the actual semantics of "return" can be changed lexically

[10:11] <Voldenet> `{ leave; code 1; leave; code 2 }` -> `{ my $left = 0; $left = 1; unless $left { code 1; $left = 1; unless $left { code 2 } } }`

[10:11] <lizmat> the same would apply to "leave"

[10:13] <SmokeMachine> That’s why I suggested the same to leave… and if leave was changed to something else lexically, the CONTROL would just not be used, no?

[10:14] <Voldenet> i wonder if syntax-levels transformations could work overall - it would produce jump as it should

[10:14] <SmokeMachine> And that way we would have CONTROL only on block that have leave inside…

[10:15] <Voldenet> CONTROL exceptions is fun and all, but it's totally not what I'd expect from "return"

[10:15] <Voldenet> and leave

[10:17] <Voldenet> i'd expect something closer to that silly transformation above

[10:20] <Voldenet> in that model leave/return would introduce another conditional block recursively

[10:40] *** hankache left
[10:40] <disbot8> <jubilatious1_98524> @wayland76 the start docs say you can die inside the async block, so wy not report your exception (or another value with die?

[10:41] <disbot8> <jubilatious1_98524> m: start { die "We're dead"; }; say "working"; sleep 10;

[10:41] <disbot8> <Raku eval>  working  Exit code: 1 Unhandled exception in code scheduled on thread 4 We're dead   in block  at main.raku line 1  

[10:48] <wayland> jubilatious1_98524: Good idea, but I've already followed the approach of making it a separate method :) 

[10:53] *** leedo left
[10:53] *** leedo joined
[11:13] <Voldenet> dying inside async block seems like a silly way to report results because it introduces lots of boilerplate

[11:14] <Voldenet> compared to sub I mean

[11:21] <Voldenet> m: class Value is Exception { has $.value }; sub throw-val { Value.new(:$^value).throw }; sub await-val { CATCH { when Value { .value.return } }; await $^p }; say await-val start { throw-val 42 }

[11:21] <camelia> rakudo-moar f56482941: OUTPUT: «42␤»

[11:22] <Voldenet> with better naming it could be even nice

[11:29] *** Ekho left
[11:39] *** lichtkind joined
[11:41] *** Ekho joined
[11:59] *** topnep left
[12:02] *** topnep joined
[12:04] *** topnep left
[12:05] *** topnep joined
[12:08] <tbrowder> hi, how can i precompile a module before use?

[12:09] <tbrowder> hm. i guess just loading it in a test should work, yes?

[12:18] <lizmat> make sure you run the test file with -I.

[12:59] *** eseyman left
[13:01] *** manu_ joined
[13:01] *** manu_ is now known as eseyman

[14:10] <tbrowder> ok, thnx, that’s in my my std alias now:  raku -I. … per librasteve

[14:13] *** apac joined
[14:14] <tbrowder> so i’ve been using ChatGPT to the max and wonder if i should publish any more modules since everyone seems to be using it. i have been packaging modules useful to me so they are managed by App::Mi6 and i try to have good docs

[14:21] <tbrowder> i have created a package that emulates MS’s Access except it is unicode csv based with hooks for sqlite and postgresql, graphical interface, pdf and online docs, etc. i call it “CarolynDB” named for my late mother. i will strive to publish it if anyone is interested. it uses noto fonts for wide language use

[14:23] <tbrowder> my first use will be for our various Christmas card, birthday, and anniversary lists.

[14:46] <tbrowder> mm

[15:11] *** apac left
[15:12] *** apac joined
[15:56] <disbot8> <simon_sibl> Sounds amazing, is it accessible anywhere ?

[16:08] *** _________ left
[16:08] *** _________ joined
[16:16] <disbot8> <antononcube> @tbrowder "[...]  everyone seems to be using it" -- I am not so sure. 🙂

[16:17] <Voldenet> yeah I use different llms ;p

[16:17] <disbot8> <antononcube> Can you give a list?

[16:18] *** topnep left
[16:18] <disbot8> <antononcube> I'm only using using ChatGPT, Gemini, LLaMA ones, and Grock.

[16:18] *** topnep joined
[16:19] <disbot8> <antononcube> A fair amount of people have mentioned using Claude for programming.

[16:19] <Voldenet> well mostly deepseek, copilot, claude

[16:19] <disbot8> <antononcube> I've used DeepSeek only for LLaMA.

[16:19] <Voldenet> local models for tests, but my gpu is small

[16:20] <Voldenet> so I can only load toy 14b models

[16:20] <disbot8> <antononcube> Not that "toy", but OK...

[16:22] <disbot8> <antononcube> Related to what @tbrowder mentioned, I am considering making LLM-graphs for package development. Too much documentation, though, have to be done first.

[16:23] *** ecocode___ joined
[16:24] <Voldenet> it's toy compared to 600b models, one day I'll have 200GB vram to test them out too

[16:24] <Voldenet> hopefully ;)

[16:26] <Voldenet> considering that vram doubles every… uh 5 years or so, I'll be able to run them in 20 years perhaps

[17:07] <tbrowder> antononcube: i meant "everyone' seems to be using AI

[17:10] <tbrowder> simon_sibl: it's not on github yet, but it will be soon i hope. i have more immediate TODOs first. but the site will be at "https://github.com/tbrowder/CarolynDB"

[17:11] <tbrowder> i'll create that now and you can express interest with an issue...

[17:16] <tbrowder> ok, it's up...

[17:36] *** bingos left
[17:36] *** bingos joined
[17:38] *** sivoais left
[17:38] *** sivoais joined
[18:31] <disbot8> <jubilatious1_98524> @SmokeMachine This sound like a scoping issue. If the Exception is in the global scope, it should be seen by all inner scopes. How to fix?

[18:33] <avuserow> wayland: you're right, adding the error message within CLI.rakumod changed the line number below, I should've added it at the end :( I think they're correct in output.txt in the root of the repo though

[18:33] <avuserow> as for why I didn't put the `use` at the top, in my original code it was a `require` so it could be lazy-loaded, and I swapped it at some point to try different things

[19:08] *** vasko4 left
[19:10] *** vasko4 joined
[19:10] <SmokeMachine> jubilatious1_98524: why? It would add the CONTROL just outside the block… so, it would always be the “inner” one…

[19:14] *** Aedil left
[19:14] <disbot8> <jubilatious1_98524> @SmokeMachine Wayland says problem is "I'm at the point where I'm in a "start" block, and I've caught an exception, and I want to return a different result from the Promise." Not seeing how to do that from: https://docs.raku.org/syntax/start

[19:18] *** Sgeo joined
[19:18] *** wayland76 joined
[19:19] *** wayland left
[19:20] <SmokeMachine> I was thinking more about a generic leave func on module space…

[19:22] *** ecocode___ left
[19:32] *** ecocode___ joined
[19:37] <disbot8> <antononcube> weekly: https://rakuforprediction.wordpress.com/2025/08/23/llmgraph/

[20:29] *** topnep left
[20:31] *** topnep joined
[21:02] *** apac left
[21:04] *** apac joined
[21:05] <disbot8> <jubilatious1_98524> <@SmokeMachine> I wish I understood it better. Does module space get containerized when imported? Then you could have a CONTROL layer for import/export and/or enter/leave etcetera.

[21:24] <SmokeMachine> jubilatious1_98524: I plan to use https://github.com/FCO/ASTQuery to find the blocks that contains the call to leave and manipulate the AST to add the CONTROL block.

[21:32] <SmokeMachine> example of using ASTQuery: https://github.com/FCO/Acme-Overreact/blob/main/lib/Acme/Overreact.rakumod

[21:42] *** ecocode___ left
[22:03] *** kylese left
[22:08] *** _________ left
[22:14] *** ecocode___ joined
[22:35] *** topnep left
[22:36] *** topnep joined
[22:56] *** apac left
[23:05] *** Guest7 joined
[23:35] *** Guest7 left
[23:47] <SmokeMachine> Any idea on how can I insert a CONTROL inside a RakuAST::Block.body.statement-list?

[23:48] <SmokeMachine> lizmat: suggestion? ☝️

