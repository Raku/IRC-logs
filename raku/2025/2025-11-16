[00:47] *** arkiuat left
[00:48] *** arkiuat joined
[00:53] *** arkiuat left
[00:59] <perryprog> Interesting challenge: write a function that is like @xs.pick(**).rotor(n).head(x) where n < @xs.Set.elems (alternatively, assume all elements of @xs are unique) with the additional constraint that every sublist has all unique entries. For example f(xs => <a b c>, x => 3, n => 2) could give ((b, a), (c, a), (c, b)) but not ((b, a), (c, c), (b, a)) or ((a, b), (a, c), (b, a))

[01:00] <perryprog> (bonus points for golfing it)

[01:20] *** arkiuat joined
[01:25] *** arkiuat left
[01:46] *** arkiuat joined
[01:51] *** arkiuat left
[02:04] *** kylese left
[02:04] *** arkiuat joined
[02:05] *** kylese joined
[02:09] *** arkiuat left
[02:09] <tbrowder> ref the viewer: i'm not sure i understand the problem. i just want an app to see the tables and records.

[02:16] <Voldenet> heh interesting challenge above, most trivial solution would be to simply *.sort.unique sublists and take away non-solutions

[02:16] <Voldenet> m: sub f(:@xs, :$x, :$n) { my &add = s; @xs.pick(**).rotor($n).map(*.sort.unique).grep(* == $n).head($x) }; say f(xs => <a b c>, x => 3, n => 2)

[02:16] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«===SORRY!=== Error while compiling <tmp>â¤Quantifier quantifies nothingâ¤at <tmp>:1â¤------> xs, :$x, :$n) { my &add = s; @xs.pick(**<HERE>).rotor($n).map(*.sort.unique).grep(* ==â¤Â»

[02:16] <Voldenet> m: sub f(:@xs, :$x, :$n) { @xs.pick(**).rotor($n).map(*.sort.unique).grep(* == $n).head($x) }; say f(xs => <a b c>, x => 3, n => 2)

[02:16] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«((a b) (a b) (b c))â¤Â»

[02:17] <Voldenet> though it has duplicates, but that's one .unique away

[02:17] <Voldenet> m: sub f(:@xs, :$x, :$n) { @xs.pick(**).rotor($n).map(*.sort.unique).grep(* == $n).unique.head($x) }; say f(xs => <a b c>, x => 3, n => 2)

[02:17] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«((a b) (a c) (b c))â¤Â»

[02:18] <Voldenet> m: sub f(:@xs, :$x, :$n) { @xs.pick(**).rotor($n).map(*.sort.unique).grep(* == $n).unique.head($x) }; say f(xs => <a b c>, x => 3, n => 2)

[02:18] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«((a b) (a b) (a b))â¤Â»

[02:18] <Voldenet> but yeah, it doesn't work

[02:21] *** arkiuat joined
[02:25] <Voldenet> m: sub uniq2(@it) { @it.grep({ (my $u := (state %x){$^a}) ?? False !! ($u = True) }) }; sub f(:@xs, :$x, :$n) { @xs.pick(**).rotor($n).map(*.sort.unique).grep(* == $n).&uniq2.head($x) }; say f(xs => <a b c>, x => 3, n => 2)

[02:25] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«((b c) (a b) (a c))â¤Â»

[02:26] *** arkiuat left
[02:28] *** kylese left
[02:28] *** kylese joined
[02:30] <Voldenet> it has potential to infinitely loop in all greps, but that can be solved by adding elegant safety nets ;>

[02:30] <Voldenet> m: sub uniq2(@it) { @it.grep({ (my $u := (state %x){$^a}) ?? False !! ($u = True) }) }; sub f(:@xs, :$x, :$n) { @xs.pick(**).rotor($n).map(*.sort.unique).head(1000).grep(* == $n).head(1000).&uniq2.head($x) }; say f(xs => <a b c>, x => 5, n => 2)

[02:30] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«((b c) (a b) (a c))â¤Â»

[02:30] <Voldenet> m: sub uniq2(@it) { @it.grep({ (my $u := (state %x){$^a}) ?? False !! ($u = True) }) }; sub f(:@xs, :$x, :$n) { @xs.pick(**).rotor($n).map(*.sort.unique).head(1000).grep(* == $n).head(1000).&uniq2.head($x) }; say f(xs => <a b c>, x => 5, n => 4)

[02:30] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«()â¤Â»

[02:33] <Voldenet> it's extremely slow, but I can't think of any solution that'd fit it one-liner

[02:33] <Voldenet> that is fast

[02:41] <Voldenet> nevermind

[02:42] <Voldenet> it is early in the morning

[02:43] <Voldenet> m: sub f(:@xs, :$x, :$n) { @xs.combinations($n).pick(*).head($x) }; say f(xs => <a b c>, x => 3, n => 2)

[02:43] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«((b c) (a b) (a c))â¤Â»

[02:43] *** justache left
[02:44] *** arkiuat joined
[02:49] <Voldenet> or

[02:49] <Voldenet> m: sub f(:@xs, :$x, :$n) { @xs.combinations($n).pick(*).head($x).map(*.pick(*)) }; say f(xs => "a".."z", x => 4, n => 5)

[02:49] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«((z a b s g) (j s v b a) (m p n v l) (x o g c v))â¤Â»

[02:49] *** arkiuat left
[02:50] *** justache joined
[03:15] *** kylese left
[03:15] *** kylese joined
[03:15] *** Aedil left
[03:19] *** arkiuat joined
[03:24] *** arkiuat left
[03:29] *** arkiuat joined
[03:33] <disbot1> <.landyacht.> is there any way to set the name on the initial thread to something other than "Initial thread"?

[03:34] *** arkiuat left
[03:46] *** arkiuat joined
[03:50] *** arkiuat left
[04:16] <Voldenet> no

[04:18] *** arkiuat joined
[04:23] *** arkiuat left
[04:24] <Voldenet> actually yes, but it's a hacl

[04:24] <Voldenet> hack

[04:24] <Voldenet> m: use nqp; nqp::bindattr($*THREAD, Thread, <$!name>, <foo>); say $*THREAD

[04:24] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«Immortal Thread #1 (foo)â¤Â»

[04:26] <Voldenet> or

[04:26] <Voldenet> m: use nqp; say $*THREAD; nqp::bindattr(PROCESS::<$THREAD>, Thread, <$!name>, <foo>); say $*THREAD

[04:26] <camelia> rakudo-moar 2d4a8c837: OUTPUT: Â«Immortal Thread #1 (Initial thread)â¤Immortal Thread #1 (foo)â¤Â»

[04:26] <Voldenet> (PROCESS::<$THREAD> gets initialized when you first access $*THREAD)

[04:29] <Voldenet> of course it's very closely tied to implementation details, so it's not a perfect solution and it might even stop working if InitialThread became separate class â€“ currently it's regular Thread

[04:38] *** lichtkind__ joined
[04:40] <Voldenet> there's also nqp::setthreadname that shortens the argument to 15 and uses pthread_setname_np, you can see that description in top for example

[04:40] *** lichtkind_ left
[04:46] *** arkiuat joined
[04:52] *** arkiuat left
[05:08] *** Sgeo left
[05:19] *** arkiuat joined
[05:20] *** pi1 is now known as johnjay

[05:20] *** Aedil joined
[05:24] *** arkiuat left
[05:40] *** lichtkind joined
[05:42] *** lichtkind__ left
[05:46] *** arkiuat joined
[05:52] *** Sgeo joined
[05:55] *** arkiuat left
[06:03] *** Sgeo left
[06:05] *** xinming left
[06:23] *** arkiuat joined
[06:28] *** arkiuat left
[06:31] *** arkiuat joined
[06:37] *** arkiuat left
[06:48] *** xinming joined
[07:05] *** arkiuat joined
[07:10] *** arkiuat left
[07:32] *** arkiuat joined
[07:37] *** arkiuat left
[07:46] *** xinming left
[07:55] *** arkiuat joined
[08:06] *** arkiuat left
[08:15] *** arkiuat joined
[08:21] *** arkiuat left
[08:36] *** arkiuat joined
[08:41] *** arkiuat left
[08:56] *** abraxxa joined
[09:12] *** arkiuat joined
[09:17] *** arkiuat left
[09:30] *** arkiuat joined
[09:38] *** arkiuat left
[09:52] *** librasteve_ joined
[09:55] *** arkiuat joined
[09:59] *** arkiuat left
[10:22] *** arkiuat joined
[10:27] *** arkiuat left
[10:30] *** arkiuat joined
[10:40] *** arkiuat left
[10:41] *** arkiuat joined
[10:47] *** arkiuat left
[11:03] *** arkiuat joined
[11:24] <timo> could be interesting to expose thread name setting to the user program actually

[11:29] <timo> even for threads you create yourself it can be interesting to adjust the name as time passes, if it goes through like, phases of doing different things?

[11:29] <timo> or something like postgres does when it changes the name of threads tells you what kind of action it's running at the moment, like SELECT or UPDATE or something

[11:30] <lizmat> m: use nqp; nqp::setthreadname("foo"); say $*THREAD

[11:30] <camelia> rakudo-moar eb8c9b138: OUTPUT: Â«Immortal Thread #1 (Initial thread)â¤Â»

[11:30] <lizmat> doesn't seem to work ?

[11:31] <timo> it probably only changes the underlying operating system thread name, not the name stored in the Thread object

[11:31] <timo> the thread name you should be able to see in the output of tools like "ps"

[11:31] <timo> not sure what flags ps needs so you actually see threads

[11:32] <timo> especially on osx

[11:32] <timo> m: use nqp; nqp::setthreadname("blorble"); say qx/ ps aux | grep blorble /

[11:32] <camelia> rakudo-moar eb8c9b138: OUTPUT: Â«camelia  27336  0.0  0.1   4616  3072 ?        S    12:32   0:00 /bin/sh -c  ps aux | grep blorble â¤camelia  27338  0.0  0.0   5812  1920 ?        S    12:32   0:00 grep blorbleâ¤â¤Â»

[11:32] <timo> nope! :D

[11:33] <lizmat> nqp::setthreadname appears to only be able to set the name of the current thread though

[11:33] <timo> m: use nqp; nqp::setthreadname("blorble"); say qx/ ps -L | grep blorble /

[11:33] <camelia> rakudo-moar eb8c9b138: OUTPUT: Â«27426 27426 ?        00:00:00 blorbleâ¤â¤Â»

[11:34] <timo> we would have to add another op, maybe a syscall, that also takes the thread as an argument

[12:26] *** ds7832 joined
[12:38] *** ds7832 left
[13:08] *** arkiuat left
[13:20] *** arkiuat joined
[13:25] *** arkiuat left
[13:32] *** arkiuat joined
[13:38] *** wayland joined
[13:38] *** wayland76 left
[13:39] *** abraxxa left
[14:22] *** librasteve_ left
[14:57] <japhb> How does one get the list of available volumes (drives) on Windows?  I see references to 'volume' in a number of lines of src/core.c/IO/... but no obvious (to me at least) way to just see what volumes *exist*.

[15:04] <timo> just go "A".."Z" and try to access to see if it exists? :D

[15:04] *** arkiuat left
[15:18] <disbot1> <.landyacht.> Voldenet - thanks!

[15:18] <japhb> timo: I was afraid that might be the answer.  :-/

[15:19] <japhb> Plus it doesn't help find mounted UNC paths ...

[15:23] <Geth> Â¦ raku.org: librasteve self-assigned Pages briefly flash between dark/light theme when loading https://github.com/Raku/raku.org/issues/274

[15:24] <timo> i have no idea about windows, so take my advice with a mountain of salt

[15:32] *** arkiuat joined
[15:39] *** arkiuat left
[15:57] *** arkiuat joined
[16:04] <Voldenet> japhb: something like qx/wmic logicaldisk get name/.lines.map(*.trim).skip(1) perhaps

[16:05] <Voldenet> it will include mapped network drives (with net use)

[16:13] <disbot1> <antononcube> @lizmat I think you mentioned some time ago that in 6.e a pipeline like this would work: <a b c> ==> { say($_) } .  I cannot find that in your advent posts from 2023 and 2024. Maybe, you just mentioned it here in IRC.

[16:13] <lizmat> are you sure it was me/

[16:14] <lizmat> ?

[16:14] <disbot1> <antononcube> ğŸ’¯

[16:14] <disbot1> <antononcube> Yes. ğŸ™‚

[16:14] <disbot1> <antononcube> Anyway -- if there is an "official annoucement" about that feature I would to refer to it.

[16:22] <lizmat> looks like <a b c> ==> { say($_) } actually compiles in RakuAST

[16:22] <disbot1> <antononcube> Right. So it is a 6.e feature?

[16:23] <lizmat> m: say Q|<a b c> ==> { say($_) }()|.AST.EVAL

[16:23] <camelia> rakudo-moar 41a1b3cd1: OUTPUT: Â«(a b c)â¤Trueâ¤Â»

[16:24] <lizmat> hmmm

[16:24] <disbot1> <antononcube> Right. I know I can make it work by adding () in 6.d.

[16:26] <lizmat> well, I don't recall saying that, I'm afraid: but please correct me if I'm wrong  :-)

[16:27] <disbot1> <antononcube> Yeah, ok.  I was searching through Raku advent posts only, I will scan the IRC logs too.

[16:38] *** kylese left
[17:12] *** Guest7020 joined
[17:12] *** Guest7020 left
[17:12] *** Guest7020 joined
[17:18] *** simcop2387 left
[17:57] *** kylese joined
[17:57] *** Guest7020 is now known as ds7832

[18:41] *** simcop2387 joined
[18:44] <lizmat> weekly: https://fosdem.org/2026/news/2025-11-16-accepted-stands/

[18:44] <notable6> lizmat, Noted! (weekly)

[20:11] *** Aedil left
[20:28] *** Sgeo joined
[20:50] <disbot1> <antononcube> weekly: https://rakuforprediction.wordpress.com/2025/11/16/monad-laws-in-raku/

[20:50] <notable6> antononcube, Noted! (weekly)

[21:24] *** simcop2387 left
[22:00] *** holyghost left
[22:00] *** holyghost joined
[22:00] <holyghost> .

[22:01] <holyghost> Hi, I just imported a testbed for the rakudo compiler on NetBSD WIP pkgsrc

[22:01] <holyghost> It's available at http://sf.net/p/nraku

[22:01] <holyghost> I'm afk

[22:10] *** wayland left
[22:27] *** [Coke] left
