[00:02] *** nort joined
[01:07] *** hulk joined
[01:08] *** kylese left
[01:38] *** ecocode___ joined
[02:15] *** hulk left
[02:15] *** kylese joined
[03:10] *** topnep left
[03:12] *** topnep joined
[03:50] *** rjbs left
[03:51] *** rjbs joined
[04:18] *** ecocode___ left
[04:38] <tonyo> .

[04:50] *** kylese left
[04:51] *** kylese joined
[04:58] *** Aedil joined
[05:02] *** kjp left
[05:16] *** topnep left
[05:19] *** topnep joined
[05:24] *** kjp joined
[05:32] *** kjp_ joined
[05:32] *** kjp left
[06:13] *** ecocode___ joined
[06:53] *** Sgeo left
[06:54] *** kjp_ left
[06:55] *** kjp joined
[07:23] *** topnep left
[07:23] *** topnep joined
[07:33] *** nine left
[07:34] *** nine joined
[07:38] <disbot> <simon_sibl> I am a bit confused: https://termbin.com/w0ea

[07:39] <disbot> <simon_sibl> since I added a second whenever in the react block, it prints all at once, it doesnt seem to do little by little (with the sleep it should show some food receive, the bad message etc. but here it does nothing for few seconds, then print all at once

[07:45] *** wayland joined
[07:53] <disbot> <simon_sibl> I thought it could have multiple whenever at the same time: https://docs.perl6.org/type/Proc::Async

[07:57] <disbot> <simon_sibl> and I thought it would switch between them to get the one "ready"

[08:02] <disbot> <simon_sibl> this example should be simpler: https://termbin.com/n18h

[08:07] <disbot> <simon_sibl> if its async, it should switch between the two tap each time no ?

[08:08] *** lichtkind joined
[08:25] *** refactus left
[08:25] *** refactus joined
[08:33] *** ecocode___ left
[08:42] <disbot> <simon_sibl> ok I think I get it, it needs a whenever in the supply block which behave like an await giving time to other Supply to run

[09:04] *** Aedil left
[09:27] *** topnep left
[09:28] *** topnep joined
[09:28] <Voldenet> supply itself isn't introducing any sort of async, sleep just sleeps and blocks whole thread

[09:30] <Voldenet> it just executes the code and the result isn't wrong either, just a bit delayed :>

[09:43] <disbot> <simon_sibl> yeah I think I understand now, played a bit with supply/channels/whenever/react  start creates "lightweight" thread right ?

[09:48] <Voldenet> sort of

[09:50] <Voldenet> when working with supplies, you have two good options

[09:50] <Voldenet> Supply.interval(1) will emit the value every second, Promise.in(1) will end after a second

[09:53] <Voldenet> m: my $food-supplier = supply { my @f = <tomato potato apple fries>; whenever Supply.interval(1) { emit @f[(state $s)++]; if $s >= @f { done; }}}; react { for ^2 { whenever $food-supplier { .say } }}

[09:53] <camelia> rakudo-moar f56482941: OUTPUT: «tomato␤tomato␤potato␤potato␤apple␤apple␤fries␤fries␤»

[10:02] <Voldenet> usually if your source is well-behaved, it's very easy to add react/supply block on top of it without problems

[10:05] <Voldenet> however if your source has blocking code (e.g. if you do "prompt/sleep/read"), you're going to see it

[10:07] <Voldenet> `start` is an escape hatch that in such case, may and in a lot of cases will use os-level thread, it might get heavy if you use it for networking

[10:11] *** disbot left
[10:11] *** disbot8 joined
[10:32] *** Aedil joined
[10:40] *** cleo left
[11:43] *** [Coke] left
[11:43] <disbot8> <simon_sibl> I am a bit confused here with the for loop, why it does each element twice instead of the list twice ?

[11:44] <disbot8> <simon_sibl> oh I thought start was better than Thread.new

[11:46] <lizmat> The Thread class is considered plumbing...  you should have a real good reason for using that

[11:54] <Voldenet> start is a bit smarter because it can reuse workers if they're free

[11:54] <Voldenet> but it's not magic that will make your programs parallel

[11:55] <Voldenet> if you use a lot of os level non-async primitives

[11:55] <Voldenet> simon_sibl: because I did `for ^2 { whenever $food-supplier { .say }` which attaches "whatever" to the react block twice

[11:56] <Voldenet> you could do ^10 for more dramatic effect and also to see how beautifully parallel it is

[12:01] <disbot8> <simon_sibl> ooooh okok I see, it does the loop which "attach" the whenever twice, so they both run concurrently, is that right ?

[12:23] *** [Coke] joined
[13:37] *** topnep left
[13:38] *** topnep joined
[13:50] <Voldenet> yes, they run concurrently, but only one element is processed at the time

[13:54] *** ashfield left
[14:04] *** nine left
[14:05] *** nine joined
[14:19] *** Sgeo joined
[14:22] *** jetchisel left
[14:22] *** jetchisel joined
[15:02] *** apac joined
[15:22] *** human-blip left
[15:24] *** human-blip joined
[15:41] *** apac left
[16:30] *** apac joined
[16:35] *** stanrifkin joined
[16:46] *** nort left
[16:54] *** stanrifkin left
[16:55] <[Coke]> please enjoy my new dog: https://imgur.com/gallery/new-adoptee-quix-9OReK1h

[17:11] *** human-blip left
[17:13] *** human-blip joined
[18:24] *** ecocode___ joined
[19:00] *** Aedil left
[19:50] *** stanrifkin joined
[19:55] *** topnep left
[19:56] *** topnep joined
[20:41] *** apac left
[20:56] *** melezhik joined
[20:56] <melezhik> .

[20:56] <melezhik> [Coke]: ..

[20:57] <melezhik> ))

[21:04] *** ilogger2 left
[21:04] *** ilogger2 joined
[21:59] *** topnep left
[22:01] *** topnep joined
[22:04] *** ecocode___ left
[22:08] <[Coke]> __

[22:21] *** hulk joined
[22:23] *** kylese left
[22:30] *** lichtkind left
[22:50] *** itaipu left
[22:52] *** itaipu joined
[23:06] *** melezhik left
[23:18] *** wayland left
[23:19] *** wayland joined
[23:23] *** ecocode___ joined
[23:52] *** itaipu left
[23:55] *** itaipu joined
