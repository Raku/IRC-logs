[01:28] *** hulk joined
[01:28] *** kylese left
[01:48] <tbrowder> no need now, i see Voldenet already mentioned the oopsie

[01:58] *** LainIwakura joined
[02:04] *** LainIwakura left
[02:15] *** hulk left
[02:15] *** kylese joined
[02:16] *** LainIwakura joined
[03:01] *** LainIwakura left
[04:10] <perryprog> > how can we on "normal" irc pm with the growing number of ppl on discord and other strange places?

[04:10] <perryprog> by peer pressuring them to come back to irc

[04:37] *** Aedil joined
[04:42] *** [Coke] left
[05:43] *** Aedil left
[05:47] *** Pixi joined
[05:52] *** derpydoo joined
[06:34] *** [Coke] joined
[06:55] *** Aedil joined
[07:02] *** Sgeo left
[07:05] *** abraxxa joined
[07:07] *** abraxxa1 joined
[07:08] *** abraxxa2 joined
[07:10] *** abraxxa left
[07:11] *** abraxxa1 left
[07:24] <disbot> <librasteve> lol … i am trying hard to make the journey from Discord to IRC. Discord has the convenience of multiple server tabs to eg the HTMX and Polars servers, works well on various devices, supports media sharing and keeps the message history. otoh IRC doesn’t mess with text such as code for camelia and the bots are more reliable. IRCcloud has helped … it is always logged in in ios so i get the message history there … my

[07:24] <disbot> macbook habit is to log off a few times a day so i need something like screen or tmux to keep the history live and then would run them on my aws instance which I haven’t got around to yet…

[07:33] *** abraxxa joined
[07:37] *** abraxxa2 left
[07:51] *** melezhik joined
[08:02] *** abraxxa1 joined
[08:02] *** crnlskn joined
[08:06] *** abraxxa left
[08:06] *** dakkar joined
[08:09] *** abraxxa joined
[08:12] *** abraxxa1 left
[08:12] *** abraxxa1 joined
[08:15] *** abraxxa left
[09:00] *** abraxxa joined
[09:04] *** abraxxa1 left
[09:57] *** crnlskn left
[09:58] *** crnlskn joined
[10:40] *** melezhik left
[10:47] *** abraxxa1 joined
[10:48] <tbrowder>  yes, Irccloud has been  Godsend for me who has not figured out the overarching msg stuff. and their suport folks can fix it when i do something stupid

[10:48] *** disbot left
[10:48] *** disbot1 joined
[10:50] *** abraxxa left
[11:07] *** melezhik joined
[11:10] *** Aedil left
[12:27] *** derpydoo left
[12:35] *** Aedil joined
[12:37] <Geth> ¦ raku.org: librasteve self-assigned Pin Deps https://github.com/Raku/raku.org/issues/256

[12:43] *** apac joined
[12:44] *** apac left
[13:28] *** crnlskn left
[14:22] *** apac joined
[15:30] *** melezhik left
[15:57] *** abraxxa1 left
[16:05] *** human-blip left
[16:07] *** human-blip joined
[16:18] *** apac left
[16:19] *** apac joined
[16:36] *** dakkar left
[16:47] *** arkiuat joined
[16:48] <arkiuat> I'm on MacOS as well, but I just keep a browser tab open to https://irclogs.raku.org/raku/live.html

[16:48] <tellable6> 2025-09-02T07:44:47Z #raku <librasteve> arkiuat: thanks - now fixed

[16:49] <arkiuat> not familiar with IRCcloud

[16:50] <arkiuat> so I was wondering about my lack of luck in ever constraining return values of subs that return a List or Seq

[16:50] <arkiuat> has anyone else ever tried to do this and run into troubles with it?

[16:50] <[Coke]> Are you trying to use a list all of a type? or just a List?

[16:51] <arkiuat> [Coke], I've tried both I think

[16:52] <arkiuat> certainly the former, since I don't see much point in constraining a return value to any ole List

[16:52] <[Coke]> m: sub b returns List { return 1,2,3}; b;

[16:52] <camelia> rakudo-moar a988e79f9: ( no output )

[16:52] <[Coke]> m: sub a returns List { return 3 }; a

[16:52] <camelia> rakudo-moar a988e79f9: OUTPUT: «Type check failed for return value; expected List but got Int␤  in sub a at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:54] <arkiuat> I guess I'll have to settle for restraining the return value to any ole List, then

[16:54] <arkiuat> there's no way to constrain it to a List[Int] or suchlike?

[16:55] <[Coke]> m: sub b returns Array[Int] { my @a of Int = 1,2,3 } ; b

[16:55] <camelia> rakudo-moar a988e79f9: ( no output )

[16:56] <[Coke]> Don't think you can do that with list - but you can with Array, for sure.

[16:58] <arkiuat> Okay, so List and Seq "cannot be parametrized" (that's in the error message), and I need to containerize the return value if I want to constrain the type of its component items. Is that right?

[16:59] <arkiuat> [Coke]++

[17:00] <[Coke]> I believe that is correct. (need the container to "hold" the parameterization)

[17:01] <arkiuat> Gotcha, thanks!

[17:01] <[Coke]> m: sub b returns Array[Int] { my @a =1,2,3}; b

[17:01] <camelia> rakudo-moar a988e79f9: OUTPUT: «Type check failed for return value; expected Array[Int] but got Array. You have to pass an explicitly typed␤array, not one that just might happen to contain elements of the correct␤type.␤  in sub b at <tmp> line 1␤  in block <unit> at <tmp> li…»

[17:01] <[Coke]> ^^

[17:01] <arkiuat> Right

[17:01] <[Coke]> (and you can't "guess" at the type, has to be explicit)

[17:01] <[Coke]> Good luck. :)

[17:07] <arkiuat> Well, it works. I mean I think I'll get more helpful error messages this way when I break stuff. But having the return value of the sub begin with "my @r of Capture =" is pretty funny-looking if you ask me.

[17:08] <arkiuat> (it was returning a list of 4 Captures originally)

[18:07] <disbot1> <librasteve> you may want to try coercion in the return type

[18:11] <disbot1> <librasteve> m: sub fn(--> Hash()) { :a(0), :b(1) }; dd fn()

[18:11] <evalable6> librasteve, rakudo-moar f56482941: OUTPUT: «{:a(0), :b(1)}␤»

[18:11] <disbot1> <Raku eval>  {:a(0), :b(1)} 

[18:11] <disbot1> <librasteve> m: sub fn(--> Hash()) { :a(0), :b(1) }; say fn().WHAT

[18:11] <evalable6> librasteve, rakudo-moar f56482941: OUTPUT: «(Hash)␤»

[18:11] <disbot1> <Raku eval>  (Hash) 

[18:12] <disbot1> <librasteve> not sure if/how that interacts with the Array[Int] types - would need to experiment a bit

[18:28] *** arkiuat left
[18:29] *** arkiuat joined
[18:46] <arkiuat> hmm!

[19:15] *** Aedil left
[21:07] <disbot1> <librasteve> m: 1.6605402e-27.FatRat.nude

[21:07] <evalable6> librasteve, rakudo-moar f56482941: OUTPUT: «»

[21:07] <disbot1> <Raku eval>  

[21:07] <disbot1> <librasteve> m: 1.6605402e-27.FatRat.nude.say

[21:07] <evalable6> librasteve, rakudo-moar f56482941: OUTPUT: «(0 1)␤»

[21:07] <disbot1> <Raku eval>  (0 1) 

[21:11] <disbot1> <librasteve> this feels wrong to me ... since the Num (IEEE 1754 64-bit FP) has finite information, it can be expressed as a FatRat without too much trouble, seems that  Raku holds the opinion that an irrational number cannot be converted to a rational one

[21:12] <disbot1> <librasteve> m: 1e-1.FatRat.nude.say

[21:12] <evalable6> librasteve, rakudo-moar f56482941: OUTPUT: «(1 10)␤»

[21:12] <disbot1> <Raku eval>  (1 10) 

[21:12] <perryprog> "fatrat nude say" is a crazy thing to come up in a programming language 100% unintentionally

[21:13] <disbot1> <librasteve> hmm sometimes it works, I wonder if Num => FatRat is implemented as Num => Rat => FatRat (which should be the other way around)

[21:14] <disbot1> <librasteve> lol - but this small Larry jokettes stick in the mind when it comes to having to remenber stuff

[21:43] *** arkiuat left
[21:48] *** arkiuat joined
[21:52] *** arkiuat left
[22:05] *** arkiuat joined
[22:29] <Voldenet> m: sub tiniest-fat-rat($n = 2) { with $n / 2 { return $n if .FatRat == 0; samewith($n / 2); } }; say tiniest-fat-rat.FatRat.nude;

[22:29] <camelia> rakudo-moar a988e79f9: OUTPUT: «(1 9223372036854775808)␤»

[22:29] <Voldenet> one might see a very specific number in here…

[22:31] <Voldenet> (roughly maximum value of int64)

[22:37] <Voldenet> FatRat internally can hold large values though

[22:37] <Voldenet> m: FatRat.new(1, 16 ** 32).nude.say

[22:37] <camelia> rakudo-moar a988e79f9: OUTPUT: «(1 340282366920938463463374607431768211456)␤»

[22:40] <Voldenet> hah, of course, "reat the docs"

[22:42] <Voldenet> read

[22:42] <Voldenet> m: 1.6605402e-27.FatRat(1e-28).nude.say

[22:42] <camelia> rakudo-moar a988e79f9: OUTPUT: «(1 602213665167515970973990912)␤»

[22:43] <Voldenet> by default FatRat cuts Num's precision to 1e-6

[22:54] <Voldenet> m: 1.6605402e-200.FatRat(1e-200).say # it might seem perfectly sane to set this high

[22:54] <camelia> rakudo-moar a988e79f9: OUTPUT: «0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000166054␤»

[22:55] <Voldenet> m: sub n64 { my num64 $n = $^x.Num }; (n64(0.1) + n64(0.2)).FatRat(1e-30).say; # but then you get this

[22:55] <camelia> rakudo-moar a988e79f9: OUTPUT: «0.3000000000000000266454␤»

[22:58] *** Sgeo joined
[23:19] <perryprog> Hmm, does DateTime not have a way to initialize a date from a string given some format specifier?

[23:19] <perryprog> (using a strftime-like format string)

[23:23] <perryprog> (To be more specific, I have a yyyymmddHHMMSS string, and I want to parse it)

[23:31] *** apac left
[23:51] <arkiuat> perryprog, I don't believe so. It's basically the .new multi methods listed in https://docs.raku.org/type/DateTime#method_new

[23:51] <arkiuat> I've rolled my own plenty of times

[23:51] <perryprog> Thought so, that's too bad

[23:52] <arkiuat> Although I haven't checked raku.land -- maybe someone has already written it?

