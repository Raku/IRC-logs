[00:00] <[Coke]> welcome aboard

[00:53] *** arkiuat left
[00:58] *** deoac joined
[01:09] *** arkiuat joined
[01:13] <korvo> Solved it! Humming-Bird::Core::listen() requires a :no-block argument in order to actually `start` concurrently.

[02:28] <disbot7> <aruniecrisps> @librasteve sure I can do that, what exactly are you looking for?

[02:30] <disbot7> <aruniecrisps> Or can it just be any snippet?

[02:36] *** kylese left
[02:37] *** kylese joined
[02:49] *** deoac left
[03:04] <disbot7> <jubilatious1_98524> @aruniecrisps have you tried NFKD decomposition? https://docs.raku.org/routine/NFKD

[03:07] *** deoac joined
[03:15] *** kylese left
[03:15] *** kylese joined
[03:28] *** itaipu left
[03:44] *** itaipu joined
[04:11] *** Aedil joined
[04:13] *** cm left
[04:15] *** deoac left
[04:20] *** lichtkind_ joined
[04:21] *** cm joined
[04:23] *** lichtkind left
[04:38] *** itaipu left
[05:16] <Voldenet> jubilatious1_98524: it's not a contradiction – to group things you need a container for the grouping (a scope) and another value that escapes that scope is the only one preserved

[05:17] <disbot7> <jubilatious1_98524> @Voldenet so what's the 'escape key'?

[05:18] <Voldenet> 'escape key' hm?

[05:18] <Voldenet> what do you mean

[05:19] <Voldenet> m: my $result = do { my $a = 1; my $b = 2; $a + $b }; say $result # this is the pattern - $result gets assigned, but $a and $b are not preserved

[05:19] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «3␤»

[05:20] <Voldenet> it can get a lot more complicated with FINALIZER module for instance

[05:21] <disbot7> <jubilatious1_98524> Have you posted this do { ... } idiom previously? I might have missed it.

[05:21] <Voldenet> yes a while earlier, but without 'do'

[05:23] <disbot7> <jubilatious1_98524> It doesn't seem exactly like the Rust code you posted, which talked about immutability of variables manipulated in that blog code-example.

[05:23] <Voldenet> in C# there's `using(var x = new SomeIDisposableImpl()) { … }` for tracking IDisposable values

[05:23] <Voldenet> it's a bit similar to using do-block

[05:25] <Voldenet> where you can `my $item = do { using FINALIZER; my $x = FoosRepository.new(:conn(await $connections.connect()); $x.items.fetch(:id(42)); }; `

[05:25] <disbot7> <jubilatious1_98524> In my Raku one-liners, I use BEGIN blocks all the time: https://unix.stackexchange.com/search?q=user%3A227738+BEGIN

[05:26] <Voldenet> obviously rust is a different kind of language, but you can make things immutable by turning it into List on the end

[05:26] <Voldenet> for example

[05:26] <disbot7> <jubilatious1_98524> Here are some (other) examples with state variables: https://unix.stackexchange.com/search?q=user%3A227738+state

[05:28] <disbot7> <jubilatious1_98524> So I thought a hypothetical  {STATE .... } keyword would replicate what you wanted to bring over from Rust.

[05:28] <Voldenet> I agree that BEGIN blocks are very useful, I still do time things with `now - BEGIN now` :>

[05:28] <Voldenet> though I guess do-block is just something that's totally unnecessary

[05:28] <Voldenet> it hardly does anything

[05:29] <Voldenet> so using it in this context is just not very obvious

[05:29] <disbot7> <jubilatious1_98524> (Never heard of FINALIZER before...).

[05:31] <Voldenet> very cool module, it's something that should be in stdlib, basically it implements the IDisposable (C#) AutoCloseable (java) or Drop (rust) patterns

[05:33] <Voldenet> so instead of directly using DBIish, you'd use method attaching .dispose to current scope

[05:37] <disbot7> <jubilatious1_98524> do blocks make for loops imperative, I'll use it instead of (complicated)map calls: https://unix.stackexchange.com/a/734258/227738

[05:38] <Voldenet> I use for loops if I plan for them to have side effects

[05:39] <Voldenet> .map is for things without side effects

[05:39] *** [Coke] left
[05:41] <disbot7> <jubilatious1_98524> As long as you assign outside the do for loop, there doesn't seem to be any difference from map.

[05:42] *** [Coke] joined
[05:42] <Voldenet> m: say do for ^10 { $_ * 10 } # this feels a bit weird to write compared to `(^10).map({ $_ * 10 })`

[05:42] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «(0 10 20 30 40 50 60 70 80 90)␤»

[05:45] <Voldenet> of course, in the end they're both equivalent in what they do, so it's only a matter of preference

[05:48] <disbot7> <jubilatious1_98524> m: my @a = 0..9; @a = do for @a { <a b c d e f g h i j>[ $_ ] }; .say for @a.pairs;

[05:48] <disbot7> <jubilatious1_98524>  raku -e 'my @a = 0..9; @a = do for @a { <a b c d e f g h i j>[ $_ ] }; .say for @a.pairs;' 0 => a 1 => b 2 => c 3 => d 4 => e 5 => f 6 => g 7 => h 8 => i 9 => j 

[05:48] *** arkiuat left
[05:48] <SmokeMachine> For making stuff immutable, one could also use something like this: https://raku.land/zef:FCO/ValueClass

[05:50] <SmokeMachine> Or maybe something like these: https://raku.land/zef:FCO/Functional::LinkedList   https://raku.land/zef:FCO/Functional::Queue   or   https://raku.land/zef:FCO/Functional::Stack

[05:51] <Voldenet> (it's not the same as in rust - in rust mutability will stop some optimizations and immutability could make them possible)

[05:51] <Voldenet> rust is just very different

[05:52] <SmokeMachine> Sorry, I’m not comparing with rust… (I don’t know rust)

[05:52] <Voldenet> I mean, language knows the concept of mutability

[05:53] <Voldenet> in raku, language will asume that ValueClass is mutable

[05:54] <Voldenet> the only thing preventing mutation is Proxy STORE dying

[06:18] *** arkiuat joined
[06:23] *** arkiuat left
[06:27] <Voldenet> the above example doesn't need for btw

[06:27] <Voldenet> m: my @a = 0..9; @a = do for @a { <a b c d e f g h i j>[ $_ ] }; .say for @a.pairs; # this

[06:27] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «0 => a␤1 => b␤2 => c␤3 => d␤4 => e␤5 => f␤6 => g␤7 => h␤8 => i␤9 => j␤»

[06:28] <Voldenet> m: my @a = <a b c d e f g h i j>[0..9]; .say for @a.pairs;

[06:28] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «0 => a␤1 => b␤2 => c␤3 => d␤4 => e␤5 => f␤6 => g␤7 => h␤8 => i␤9 => j␤»

[06:28] <korvo> LangJam GameJam is done. I made a little S-expression language declaring an idle game and a friend wrote a little scenario. I'll have a blog post ready in a day or two.

[06:29] <Voldenet> m: my $a = 0; my $b = 1; say do for ^10 { my $n = $b + $a; $b = $a; $a = $n; $n } # this is something that totally wouldn't work with .map

[06:29] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «(1 1 2 3 5 8 13 21 34 55)␤»

[06:52] *** arkiuat joined
[06:57] *** arkiuat left
[07:26] *** arkiuat joined
[07:31] *** arkiuat left
[07:44] <disbot7> <jubilatious1_98524> m: my $a = 0; my $b = 1; for ^10 { my $n = $b + $a; $b = $a; $a = $n; print "$n " }; put();

[07:45] <disbot7> <jubilatious1_98524>  raku -e 'my $a = 0; my $b = 1; for ^10 { my $n = $b + $a; $b = $a; $a = $n; print "$n " }; put(); ' 1 1 2 3 5 8 13 21 34 55 

[07:46] <disbot7> <jubilatious1_98524> @Voldenet did you not just show that the code worked without map?

[08:00] *** arkiuat joined
[08:05] *** arkiuat left
[08:18] *** Aedil left
[08:28] *** arkiuat joined
[08:33] *** arkiuat left
[08:41] *** Sgeo left
[08:54] <Voldenet> yes, maybe I mistyped, but from my understanding it might not work with map

[08:54] <Voldenet> m: my $a = 0; my $b = 1; my $x = (^10).map({ my $n = $b + $a; $b = $a; $a = $n; $n }); say $x, $x

[08:54] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «(1 1 2 3 5 8 13 21 34 55)(1 1 2 3 5 8 13 21 34 55)␤»

[08:54] <Voldenet> Yes, it happens to work as expected, maybe it's even documented

[08:55] *** jjidozzz joined
[08:56] <Voldenet> but side effects feel wrong in such snippet – it might just work because initial sequence is ^10 or it might work for lists etc.

[08:58] <Voldenet> It doesn't conceptually map values at all, so it might not work

[09:02] *** arkiuat joined
[09:03] <Voldenet> in all other languages such things may or might not work: https://dotnetfiddle.net/Widget/zNieq1

[09:07] *** arkiuat left
[09:22] <Voldenet> m: my $a = 0; my $b = 1; my $x = (1..*).race(:1batch).map({ my $n = $b + $a; sleep rand; $b = $a; sleep rand; $a = $n; $n }); say $x[^10] # just throwing in "race + sleep" makes it not work

[09:22] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «(1 1 1 2 1 1 3 3 3 4)␤»

[09:29] *** arkiuat joined
[09:34] *** arkiuat left
[10:03] *** arkiuat joined
[10:08] *** arkiuat left
[10:23] *** arkiuat joined
[10:30] *** Aedil joined
[10:36] *** arkiuat left
[10:48] *** arkiuat joined
[10:54] *** arkiuat left
[11:08] *** arkiuat joined
[11:12] *** arkiuat left
[11:26] *** arkiuat joined
[11:35] *** arkiuat left
[12:05] *** arkiuat joined
[12:07] <tbrowder> if you are interested in tonyo's help on DateTime formatters, check my code at https://github.com/tbrowder/LocalTime. Besides the published code you can see code based on tonyo's suggestion in the ./tools directory. if you can still search #raku look for tonyo / tbrowder/ formatter in 2022 novemberish

[12:10] *** arkiuat left
[12:12] *** Ekho left
[12:13] <tbrowder> also see tonyo's name in the file names and code in the ./dev directory

[12:21] *** itaipu joined
[12:25] *** jjidozzz left
[12:31] *** arkiuat joined
[12:34] *** melezhik joined
[12:36] *** arkiuat left
[12:38] <lizmat> Q: what do you think was a noticeable new module in the Raku Ecosystem?    (yes, you can mention your own :-)

[12:46] *** sibl joined
[12:47] *** arkiuat joined
[12:50] *** sibl left
[12:52] *** arkiuat left
[13:11] *** arkiuat joined
[13:16] *** arkiuat left
[13:26] <disbot7> <antononcube> @lizmat How about 5 answers?

[13:26] <lizmat> sure!

[13:26] <disbot7> <antononcube> Agh, you are too gracious. I thought you might prompt me to reduce to 1, at most two.

[13:28] <lizmat> there's no guarantee I'll include all 5  :-)

[13:29] <disbot7> <antononcube> Hmm... this can be a motivation to provide ML supplied answers, across the whole ecosystem.

[13:30] <disbot7> <antononcube> Or, just using "plain" statistics.

[13:31] <lizmat> using "plain" statistics is not really an issue

[13:31] <lizmat> I'm more interested with what resonated in the community (rather than just with me)

[13:32] <disbot7> <antononcube> First of all, I think simple metrics, like, frequencies of updates, number of lines, discussions on IRC, do not tell the whole picture.

[13:32] <lizmat> indeed, they do not

[13:32] *** arkiuat joined
[13:32] <disbot7> <antononcube> But, that can be used to support certain candidates -- post-selection.

[13:33] <lizmat> take e.g. https://raku.land/zef:patrickb/Anolis

[13:33] <lizmat> just a simple module, 1 release so far, but I know how much work went in there to get to that point

[13:34] <disbot7> <antononcube> Yes, I looked at/browsed the page but did not install it yet.

[13:34] <lizmat> see also https://raku-advent.blog/2025/12/21/a-terminals-tale/   :-)

[13:34] <disbot7> <antononcube> Just about to read it -- it was published "later" than I thought.

[13:34] <disbot7> <antononcube> (Meaning, not at midnight UTC-0.)

[13:34] <lizmat> yeah, technically it was on time, just not easily found  :-)

[13:35] <disbot7> <antononcube> Agh, yeah -- some of my posts were like that too.

[13:36] <disbot7> <antononcube> Back to my statistics angle -- I was looking for an excuse to try and use "Draku" by Brian Duggan for those.

[13:37] <disbot7> <antononcube> *those statistics.

[13:37] *** arkiuat left
[13:42] *** itaipu left
[13:45] *** arkiuat joined
[13:52] *** arkiuat left
[13:59] *** itaipu joined
[14:15] <disbot7> <librasteve> lizmat: my top modules are Jupyter::Chatbook and FatRatStr (wot i rote)

[14:17] <disbot7> <librasteve> first because I use it every day and it has “taught me” LLM best practice prompt engineering, second because it demonstrates the usefulness Allomorphs and makes FatRat more practical

[14:18] *** arkiuat joined
[14:22] <disbot7> <antononcube> @librasteve  I think @lizmat said "new modules" which I interpret as "2025 modules."

[14:23] <disbot7> <antononcube> "Jupyter::Chatbook" is, of course, great, but it is also an "old" module.

[14:23] <disbot7> <antononcube> And thanks for proposing it!

[14:53] *** melezhik left
[15:40] <tbrowder> i second the FatRatStr package--very allomorph helpful

[15:45] <arkiuat> tbrowder: thanks for the info on DateTime :formatter. I still wish I could find those ruminations about the original design that I remember reading somewhere.

[15:54] *** itaipu left
[16:10] *** itaipu joined
[16:24] *** melezhik joined
[17:00] <lizmat> librasteve you don't need sets to be able to use set operators!

[17:00] <lizmat> m: my @cities  = <London Oslo Paris Amsterdam Berlin>; my @visited = <Berlin Oslo>; say  "I still need to visit the following cities: " ~ (@cities (-) @visited);

[17:00] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «I still need to visit the following cities: Paris London Amsterdam␤»

[17:02] <lizmat> in response to https://news.ycombinator.com/item?id=46346132

[17:06] *** silug left
[17:08] <Geth> ¦ advent/main: d7804d25d0 | (Elizabeth Mattijsen)++ (committed using GitHub Web editor) | raku-advent-2025/authors.md

[17:08] <Geth> ¦ advent/main: Update an move review to the 25th

[17:08] <Geth> ¦ advent/main: review: https://github.com/Raku/advent/commit/d7804d25d0

[17:09] <lizmat> One slot in the Advent Calender opened up!

[17:14] *** silug joined
[17:42] *** [Coke] left
[17:42] *** [Coke] joined
[17:48] *** arkiuat left
[17:51] *** arkiuat joined
[18:00] <disbot7> <jubilatious1_98524> m: my @cities  = <London London Oslo Paris Amsterdam Berlin>; my @visited = <Berlin Oslo Oslo>; say  "I still need to visit the following cities: " ~ (@cities (-) @visited);

[18:00] <disbot7> <jubilatious1_98524>  raku -e 'my @cities  = <London London Oslo Paris Amsterdam Berlin>; my @visited = <Berlin Oslo Oslo>; say  "I still need to visit the following cities: " ~ (@cities (-) @visited);' I still need to visit the following cities: London Paris Amsterdam 

[18:13] *** arkiuat left
[18:28] *** arkiuat joined
[19:05] * grondilu got: '===> Failed to find dependencies: pq:ver<5>:from<native>' when trying to install Red (https://raku.land/zef:FCO/Red)

[19:08] <grondilu> oh nevermind that's documented in the readme

[19:13] *** melezhik left
[19:21] *** abraxxa-home joined
[19:23] *** arkiuat left
[19:28] *** arkiuat joined
[19:33] *** arkiuat left
[19:38] *** abraxxa-home left
[19:42] *** arkiuat joined
[19:44] *** Sgeo joined
[19:54] *** Ekho joined
[20:02] <disbot7> <librasteve> lizmat: ah - should have stringified - thanks!

[20:03] <lizmat> librasteve also lose the .Set  :-)

[20:03] <disbot7> <librasteve> holy moly - that's cool

[20:03] <lizmat> m: dd <a b c> (-) <a>

[20:03] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «Bool  = Set.new("c","b")␤»

[20:04] <lizmat> m: dd ~<a b c> (-) <a>

[20:04] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «Bool  = Set.new("a b c")␤»

[20:04] <lizmat> m: dd ~(<a b c> (-) <a>)

[20:04] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «"c b"␤»

[20:04] <lizmat> set operators either produce a QuantHash, or a Bool

[20:05] <lizmat> but the input doesn't have to be a QuantHash

[20:05] *** abraxxa-home joined
[20:05] <lizmat> m: dd <a b c> (elem) <a b c d e f>

[20:05] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «Bool::False␤»

[20:05] <lizmat> m: dd "a" (elem) <a b c d e f>

[20:05] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «Bool::True␤»

[20:05] <lizmat> m: dd <a b c> (<) <a b c d e f>

[20:05] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «Bool::True␤»

[20:06] <lizmat> m: dd <a b g> (<) <a b c d e f>

[20:06] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «Bool::False␤»

[20:06] <disbot7> <librasteve> wonders how to retain the list order

[20:06] <lizmat> well... it doesn't as a Set is a QuantHash

[20:07] <disbot7> <librasteve> just an idle wonder in case that's a requirement of "array math" ... didnt expect to get it from Set

[20:08] <lizmat> m: my @c = <a b c d e f g>; my @s = <a e>; dd (@c (-) @s){@c}:k

[20:08] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «("b", "c", "d", "f", "g")␤»

[20:09] <lizmat> that would keep the order

[20:11] <disbot7> <librasteve> .oO - very glad I asked that is awesome

[20:11] <disbot7> <librasteve> betcha can't do that in Ruby

[20:12] <lizmat> :-)

[20:16] <disbot7> <librasteve> finally groks index adverbs (about time)

[20:37] <disbot7> <antononcube> @lizmat "One slot in the Advent Calender opened up!" -- fairly late notice...

[21:38] *** Aedil left
[21:39] *** abraxxa-home left
[21:55] <tonyo> .

[21:56] <tonyo> whew, glad it was a mention from tbrowder and not something with the eco ;)

[22:02] <disbot7> <aruniecrisps> @jubilatious1_98524 i'm playing around with them, how do i replace a character at position x in an NFKD string?

[22:12] <disbot7> <jubilatious1_98524> Hi @arun don't think I've done that exact one-liner, but here are three NFKD examples to get you started: https://unix.stackexchange.com/search?q=user%3A227738+NFKD

[22:20] <disbot7> <jubilatious1_98524>  echo 'ëêÝÒÉ' | raku -pe 's/ (.) )> . $/{NFKD($0).[0].chr}/;' ëêÝOÉ 

[22:20] *** manu_ is now known as eseyman

[22:24] <disbot7> <jubilatious1_98524> @aruniecrisps Otherwise look at the match variable and work from there (e.g. :from() and :pos()):

[22:25] <disbot7> <jubilatious1_98524>  echo 'ëêÝÒÉ' | raku -ne '$0.raku.put for m/ (.) )> . $/;' Match.new(:orig("ëêÝÒÉ"), :from(3), :pos(4)) 

[22:34] <disbot7> <aruniecrisps> @jubilatious1_98524 wait i'm confused in your first example why is the O the only character getting changed? doesnt look like it's being accessed

[22:37] <disbot7> <jubilatious1_98524> @aruniecrisps the s/// substitution operator has the recognition pattern (.) )> . $, which take the second-to-last character and stores it in $0, the )> capture marker tells Raku to match-then-drop the next character from the match variable, and of course $ means end-of-line.

[22:40] <disbot7> <jubilatious1_98524> @arun or are you asking more about -pe and s/// conventions? -pe invokes sed-like behavior (autoprinting) and s/// defaults to matching against $_.

[22:42] <disbot7> <jubilatious1_98524>  echo 'ëêÝÒÉ' | raku -ne 'NFKD($0).raku.put for m/ (.) )> . $/;' Uni.new(0x004f, 0x0300).NFKD 

[22:50] <disbot7> <jubilatious1_98524> Or use >> right-side word boundary:

[22:50] <disbot7> <jubilatious1_98524>  echo 'ëêÝÒÉ ëêÝÒÉ' | raku -pe 's:g/ (.) )> . [ >> | $ ]/{NFKD($0).[0].chr}/;' ëêÝOÉ ëêÝOÉ 

[22:59] <disbot7> <aruniecrisps> i think the first think you showed me is what i'm looking for, i'm looking to basically replace something like அகம் with அகத்து

[23:01] <disbot7> <aruniecrisps> this is really making my head hurt tho

[23:01] <disbot7> <aruniecrisps> okay i think i understand the first one

[23:11] <disbot7> <jubilatious1_98524> @aruniecrisps Oh my fault if I've confused you. You should use \H token (non-horizontal whitespace), instead of . token!

[23:12] *** arkiuat left
[23:13] <disbot7> <jubilatious1_98524>  echo 'அகம் அகம்' | raku -ne 'NFKD($0).raku.put for m:g/ (\H) )> \H [ >> | $ ]/;' Uni.new(0x0b95).NFKD Uni.new(0x0b95).NFKD 

[23:15] <disbot7> <jubilatious1_98524>  echo 'அகம் அகம்' | raku -ne '.uniname.say for m:g/ (\H) )> \H [ >> | $ ]/;' TAMIL LETTER KA TAMIL LETTER KA 

[23:25] *** arkiuat joined
[23:30] *** arkiuat left
[23:37] *** arkiuat joined
[23:48] <disbot7> <aruniecrisps> got it

[23:49] <disbot7> <aruniecrisps> i have a follow up question: is there a way to just look at the mark? like say for example i match against 'கி' or 'கு', would i have to use NFKD or NFD format in order to grab the modifying character or no?

[23:51] <lizmat> you could look at the NFKD of the match

[23:52] <lizmat> m: $_ = 42; / 42 { say .NFKD } /

[23:52] <camelia> rakudo-moar 6db1eb23c: OUTPUT: «NFKD:0x<0034 0032>␤»

[23:53] <disbot7> <jubilatious1_98524>  raku -pe 's:g/ம்/த்து/;' <<< $'  நேரம்    நேரம்    நேரம் '  நேரத்து   நேரத்து   நேரத்து 

