[00:18] *** deoac joined
[00:20] *** arkiuat joined
[00:25] *** arkiuat left
[00:40] *** arkiuat joined
[00:47] *** arkiuat left
[01:00] *** arkiuat joined
[01:04] *** arkiuat left
[01:15] *** deoac left
[01:26] *** markong left
[01:26] *** arkiuat joined
[01:30] *** arkiuat left
[01:40] *** arkiuat joined
[01:40] <arkiuat> good idea

[01:42] *** kylese left
[01:42] *** hulk joined
[01:47] <arkiuat> since placeholder variables can't be used in a method!

[01:48] *** [Coke] left
[02:08] <arkiuat> not sure i can use that technique with multi methods though

[02:12] <kjp> m: sub a($x) {say $x}; my &b := &a; b(42);

[02:12] <camelia> rakudo-moar f52cc9284: OUTPUT: «42␤»

[02:12] <kjp> arkiuat: ^ seems the simplest way to get multiple names for a sub to me.

[02:15] *** hulk left
[02:15] <arkiuat> yeah, I'm not sure that will work with methods. And the particular ones I was wanting to do this with happen to be multi methods

[02:15] *** kylese joined
[02:23] <Voldenet> let me give you some extremely boring code…

[02:23] <Voldenet> m: class A { multi method x(Int $a) { say Int }; multi method x(Str $a) { say Str }; method y(|c) { self.x(|c) } }; A.y(1); A.y("foo")

[02:23] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Int)␤(Str)␤»

[02:24] *** kjp left
[02:24] <arkiuat> well, these are stubbed in a role, and instantiated in two different classes that do the role

[02:25] <arkiuat> one destructures to (Int, named-subset, named-subset) and the other to (Real, named-subset)

[02:26] *** kjp joined
[02:26] <arkiuat> I've used captures before, but haven't done enough with them that I can easily wrap my head around this

[02:26] <arkiuat> all three named-subsets are the same type, at least

[02:29] <Voldenet> hm, maybe then some boring proxy would do the job

[02:29] <Voldenet> m: class A { multi method x(Int $a) { say Int }; multi method x(Str $a) { say Str } }; class XX { has $.a; method y(|c) { $.a.x(|c) }}; sub X($a) { XX.new(a => $a) }; A.&X.y(1); A.&X.y("e")

[02:29] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Int)␤(Str)␤»

[02:29] <Voldenet> now this is some proper boring code

[02:30] <Voldenet> in fact

[02:31] <Voldenet> m: class A { multi method x(Int $a) { say Int }; multi method x(Str $a) { say Str } }; sub X(A $a, |c) { $a.x(|c) }; A.&X(1); A.&X("foo")

[02:31] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Int)␤(Str)␤»

[02:34] <Voldenet> the worst part is that needs & which is annoying to type

[02:34] <Voldenet> however

[02:34] <Voldenet> m: class A { multi method x(Int $a) { say Int }; multi method x(Str $a) { say Str } }; sub infix:<bar>(A $a, |c) { $a.x(|c) }; A bar("foo"); A bar(2)

[02:34] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Str)␤(Int)␤»

[02:36] <Voldenet> m: class A { multi method x(Int $a) { say Int }; multi method x(Str $a) { say Str } }; sub infix:<bar> { $^a.x(|$^c) }; A bar("foo"); A bar(2)

[02:36] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Str)␤(Int)␤»

[02:38] <Voldenet> m: class A { multi method x(Int $a) { say Int }; multi method x(Str $a) { say Str } }; sub infix:<@> { $^a.x(|$^c) }; A@("foo"); A@(2)

[02:38] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Str)␤(Int)␤»

[02:39] <Voldenet> it can get sufficiently short if it only exists for repl

[02:40] <Voldenet> though I'd still stick to the plain &sub, because it's not ridiculously unpredictable unlike passing list to the method

[02:41] <arkiuat> these are basically alternative .new() methods, so

[02:42] <Voldenet> m: class A { multi method x(Int $a) { say Int }; multi method x(Str $a) { say Str }; multi method x(Str, Int) { say (Str, Int) } }; sub infix:<,new> { $^a.x(|$^c) }; A,new("foo"); A,new("bar", 42)

[02:42] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Str)␤((Str) (Int))␤»

[02:43] <Voldenet> :>

[02:44] <Voldenet> the above is a helper for ensuring the confusion

[02:46] <arkiuat> yeah, working with infix: this would be a first for me

[02:46] <arkiuat> I'll come back to this later, but right now I just want to revert and get all my tests working again :D

[02:47] <arkiuat> thanks though! I took notes.

[02:49] <Voldenet> that infix: looks a bit like sub call, but it's actually passing A and list (not a capture)

[02:50] <Voldenet> m: class A { multi method x(Str $a, :$heh) { say Str }; }; sub infix:<,new> { $^a.x(|$^c) }; A,new("foo", :heh); # doesn't work

[02:50] <camelia> rakudo-moar f52cc9284: OUTPUT: «Cannot resolve caller x(A:U: Str:D, Pair:D); none of these signatures matches:␤    (A $:: Str $a, :$heh, *%_)␤  in sub infix:<,new> at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[02:50] <Voldenet> m: class A { multi method x(Str $a, :$heh) { say Str }; }; sub infix:<,new> { $^a.x(|$^c) }; A,new\("foo", :heh); # does work, because it passes capture instead

[02:50] <camelia> rakudo-moar f52cc9284: OUTPUT: «(Str)␤»

[02:51] <Voldenet> …so I wouldn't really recommend it

[02:52] <Voldenet> on top of it,  every infix op alters the grammar, so this will get slow if you introduced a lot of helpers

[02:56] <Voldenet> (defining an op takes around ~200ms iirc)

[03:44] *** [Coke] joined
[03:45] *** kylese left
[03:49] *** kylese joined
[05:46] *** arkiuat left
[06:17] *** arkiuat joined
[06:21] *** arkiuat left
[06:27] <disbot3> <librasteve> votes for core team to optimize defining an op (macros?)

[06:28] *** lichtkind joined
[06:41] *** arkiuat joined
[06:47] *** arkiuat left
[07:15] *** arkiuat joined
[07:18] *** Sgeo left
[07:20] *** arkiuat left
[07:22] <Voldenet> it's a difficult topic, operators change the grammar

[07:24] <Voldenet> so that 200ms is actually pretty fast considering what it can do

[07:25] <Voldenet> + you can precompile it in a module

[07:26] <Voldenet> but it still takes a lot of time depending on what you want to do

[07:28] <Voldenet> oh and macros are entirely different thing, they emit ast directly without changing the grammar

[07:38] <SmokeMachine> are macros already using RakuAST?

[07:39] *** mc2 joined
[07:40] <mc2> hello peiple

[07:41] <mc2> s/peiple/rakoons/

[07:43] *** mc2 left
[07:43] *** mc2 joined
[07:45] *** arkiuat joined
[07:50] *** arkiuat left
[07:51] *** dakkar joined
[07:56] <mc2> I used to think <&-> can produce the dirrerence between 2 lists. like @authorized = @logins - @blacklist. Did i just dream ? 

[08:03] *** arkiuat joined
[08:05] <lizmat> m: say (1,2,3) (^) (3,4,5)

[08:05] <camelia> rakudo-moar f52cc9284: OUTPUT: «Set(1 2 4 5)␤»

[08:05] <lizmat> m: say (1,2,3) (-) (3,4,5)

[08:05] <camelia> rakudo-moar f52cc9284: OUTPUT: «Set(1 2)␤»

[08:06] <lizmat> mc2 ^^ that what you're looking for ?

[08:06] *** Aedil left
[08:08] <mc2> m: say 1..3 ^ 3..5

[08:08] <camelia> rakudo-moar f52cc9284: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Operators '..' and '..' are non-associative and require parentheses␤at <tmp>:1␤------> say 1..3 ^ 3.<HERE>.5␤»

[08:08] <mc2> m: say (1..3) ^ (3..5)

[08:08] <camelia> rakudo-moar f52cc9284: OUTPUT: «one(1..3, 3..5)␤»

[08:08] <mc2> m: say (1..3) (^) (3..5)

[08:08] <camelia> rakudo-moar f52cc9284: OUTPUT: «Set(1 2 4 5)␤»

[08:08] <mc2> thanks lizmat :)

[08:09] *** arkiuat left
[08:10] <mc2> m: say (1..3) ^^ (3..5)

[08:10] <camelia> rakudo-moar f52cc9284: OUTPUT: «Nil␤»

[08:10] <lizmat> note that the ascii version of all set operators come in parentheses, so you can easily recognize them

[08:21] *** arkiuat joined
[08:24] *** Aedil joined
[08:26] *** arkiuat left
[08:26] <mc2> yep. also easy to memorize: (op) is for lists, op is for scalar context

[08:26] <mc2> nice

[08:43] *** arkiuat joined
[08:57] *** arkiuat left
[09:08] *** arkiuat joined
[09:12] *** arkiuat left
[09:28] *** arkiuat joined
[09:32] *** arkiuat left
[09:51] *** wayland76 joined
[10:01] *** arkiuat joined
[10:06] *** arkiuat left
[10:29] *** arkiuat joined
[10:33] *** arkiuat left
[10:43] *** RaNoob joined
[10:50] *** RaNoob left
[11:02] *** arkiuat joined
[11:07] *** arkiuat left
[11:30] *** arkiuat joined
[11:34] *** arkiuat left
[12:02] *** arkiuat joined
[12:06] *** markong joined
[12:07] *** arkiuat left
[12:31] *** arkiuat joined
[12:35] *** arkiuat left
[13:05] *** arkiuat joined
[13:10] *** arkiuat left
[13:32] *** arkiuat joined
[13:37] *** arkiuat left
[13:42] *** arkiuat joined
[13:44] *** wayland joined
[13:45] *** wayland76 left
[13:54] <tbrowder> hi, in the docs, types, Sub; y'all pointed me to the example how to call any sub in a different scope. can that same syntax be used to call a sub in another module in the same package? i would like to call sub A::B.foo() from A:B:C.bar().

[14:09] <tbrowder> *A:🅱️:C.bar()

[14:10] <tbrowder> arg, A:🅱️:C.bar()

[14:11] <tbrowder> whatever g

[14:15] <tbrowder> call 'sub A::B.foo()' from 'sub A:🅱️:C.bar()'

[14:16] <tbrowder> dang! you get the idea i guess...

[14:17] *** markong left
[14:19] *** arkiuat left
[14:20] *** maylay left
[14:23] *** maylay joined
[14:32] *** arkiuat joined
[14:36] *** arkiuat left
[14:46] *** arkiuat joined
[14:50] *** arkiuat left
[14:56] <[Coke]> I think you want PARENT

[14:59] <[Coke]> https://docs.raku.org/language/packages#Pseudo-packages

[15:00] <[Coke]> $::("PARENT::&foo"), maybe?

[15:03] *** arkiuat joined
[15:08] *** arkiuat left
[15:09] *** markong joined
[15:37] *** arkiuat joined
[15:42] *** arkiuat left
[16:09] *** arkiuat joined
[16:14] *** arkiuat left
[16:35] *** dakkar left
[16:40] *** arkiuat joined
[16:49] *** arkiuat left
[16:51] *** vrurg_ left
[16:53] *** vrurg joined
[16:56] *** vrurg_ joined
[16:58] *** vrurg left
[17:01] *** arkiuat joined
[17:05] *** arkiuat left
[17:19] *** deoac joined
[17:20] *** arkiuat joined
[17:21] *** deoac left
[17:25] *** arkiuat left
[17:26] *** markong left
[17:45] *** arkiuat joined
[17:49] *** arkiuat left
[17:51] *** deoac joined
[17:56] *** librasteve_ joined
[17:57] <tbrowder> thanks! forgot about that stuff, too, i'll report results for my use case...

[18:06] *** arkiuat joined
[18:07] *** poisNada joined
[18:11] *** arkiuat left
[18:21] <librasteve_> notable6: weekly

[18:21] <notable6> librasteve_, 2 notes: 2025-07-09T11:49:09Z <wayland76>: https://wayland.github.io/blog/raku/ReachingOut/Pathways-of-Entry.xml  ;  2025-07-11T22:19:38Z <SmokeMachine>: https://dev.to/fco/cromponent-new-features-3bhf

[18:21] <tellable6> 2025-07-12T12:01:04Z #raku <SmokeMachine> librasteve: by &HTML, I mean Cro template’s &HTML (https://cro.raku.org/docs/reference/cro-webapp-template-syntax#Inserting_HTML_and_JavaScript)

[18:21] <tellable6> 2025-07-12T18:53:46Z #raku <patrickb> librasteve: Did you see my reply here? https://github.com/croservices/cro-http/pull/204#issuecomment-3064882921

[18:21] <tellable6> 2025-07-13T17:51:34Z #raku <tbrowder> librasteve: ah, that sound familiar, thank you very much!

[18:23] *** arkiuat joined
[18:28] *** arkiuat left
[18:41] <librasteve_> notable6: weekly reset

[18:41] <notable6> librasteve_, Moved existing notes to “weekly_2025-07-14T18:41:30Z”

[18:46] *** Sussy joined
[18:46] *** poisNada left
[18:46] <Sussy> Good Evening

[18:48] *** poisNada joined
[18:50] *** Aedil left
[18:51] *** poisNada left
[18:53] *** Sussy left
[18:54] <librasteve_> https://rakudoweekly.blog/2025/07/14/2025-28/

[18:55] <[Coke]> OH it monday

[18:59] *** arkiuat joined
[19:01] *** Some-body_ joined
[19:02] *** DarthGandalf left
[19:05] *** Some-body_ is now known as DarthGandalf

[19:07] *** arkiuat left
[19:11] *** Aedil joined
[19:37] *** arkiuat joined
[19:42] *** arkiuat left
[19:50] *** human-blip left
[19:51] *** human-blip joined
[19:56] <tonyo> .

[19:58] *** arkiuat joined
[20:09] *** arkiuat left
[20:33] *** arkiuat joined
[20:38] *** arkiuat left
[20:50] *** arkiuat joined
[20:53] *** zuphinx joined
[21:03] *** zuphinx left
[21:15] *** Aedil left
[21:23] *** arkiuat left
[21:23] *** jjido joined
[21:25] *** arkiuat joined
[21:30] *** arkiuat left
[21:43] *** jjido left
[21:58] *** arkiuat joined
[22:04] *** arkiuat left
[22:16] *** Sgeo joined
[22:18] *** arkiuat joined
[22:24] *** arkiuat left
[22:52] *** arkiuat joined
[22:57] *** arkiuat left
[22:57] *** markong joined
[23:13] *** wayland left
[23:22] *** arkiuat joined
[23:29] *** arkiuat left
[23:36] *** librasteve_ left
[23:54] *** arkiuat joined
[23:59] *** arkiuat left
