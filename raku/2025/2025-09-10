[00:10] *** kjp left
[00:11] *** kjp joined
[00:12] *** kjp left
[00:12] *** kjp joined
[01:20] *** jgaz left
[01:28] *** hulk joined
[01:28] *** kylese left
[02:15] *** hulk left
[02:15] *** kylese joined
[02:55] <coleman> rebooting docs and main website.

[03:10] <elcaro> perryprog: There's DateTime::Parse, but it's not super documented. Looking at the tests, it looks like it supports a few formats, but I'm not sure if you can specify your own à la strptime

[03:11] <perryprog> there is??

[03:11] <elcaro> parsing 'YYYYmmddHHMMSS' is not too difficult. One way: DateTime.new: |'20250910131152'.match(/(....)(..)(..)(..)(..)(..)/)

[03:12] <perryprog> ... that is better than what I went with

[03:12] <perryprog>  DateTime.new("{.[0..3].join}-{.[4..5].join}-{.[6..7].join}T{.[8..9].join}:{.[10..11].join}:{.[12..13].join}Z") given $time.comb

[03:12] <elcaro> Or if your on linux, here's a test module I wrote for strftime/strptime: https://gist.github.com/0racle/67c4e9e8f516f565b9d5911ac2162f3c

[03:13] <elcaro> I never released it, or tested/used it much... but it seems to work ok

[03:13] <perryprog> interesting 👀

[03:13] <perryprog> this is just for a one off so it's not too big a deal, but it is definitely one of those things that's a big nice to have in a stdlib

[03:15] <elcaro> Here's another way to do what you did: '20250910130537'.comb.rotor(4,2,2,2,2,2)».join

[03:15] <disbot1> <jubilatious1_98524> Maybe DateTime::Parse will be of interest: https://raku.land/github:sergot/DateTime::Parse

[03:17] <disbot1> <jubilatious1_98524> https://unix.stackexchange.com/a/709253

[03:17] <perryprog> elcaro: in my defense it's been a while since I've done Raku🫣

[03:17] <perryprog> that is really elegant, though

[03:19] <perryprog> thanks for the pointer jubilatious!

[03:22] <perryprog> man rotor has got to be one of the most weirdly powerful functions that I always forget about

[03:30] <elcaro> Yeah, even tho I don't use it heaps, I always appreciate it when I need it.

[03:30] <elcaro> Note also that if what you need is `.rotor(n, :partial)`, that's just `.batch(n)`

[03:31] <Voldenet> m: grammar MyDateFormat { regex TOP { <year=d4> <month=d2> <day=d2> <hour=d2> <minute=d2> <second=d2> { make DateTime.new(|$/) } }; regex d2 { \d**2 }; regex d4 { \d**4 } }; say MyDateFormat.parse("20250910130537").made

[03:31] <camelia> rakudo-moar a988e79f9: OUTPUT: «2025-09-10T13:05:37Z␤»

[03:32] <Voldenet> here, have some sledgehammer solution

[03:34] <Voldenet> though jokes aside, it's very easy to adjust to any other format

[03:36] <Voldenet> m: grammar MyDateFormat { regex TOP { <year=.d4> <month=.d2> <day=.d2> <hour=.d2> <minute=.d2> <second=.d2> { make DateTime.new(|$/) } }; regex d2 { \d**2 }; regex d4 { \d**4 } }; say MyDateFormat.parse("20250910130537").made # don't pass those d2 to datetime's constructor

[03:36] <camelia> rakudo-moar a988e79f9: OUTPUT: «2025-09-10T13:05:37Z␤»

[03:47] <elcaro> FWIW, the first .match one I posted benches faster than the .rotor one or the grammar one.

[03:51] *** arkiuat left
[03:53] <elcaro> Using .substr would be even faster, but annoying to write

[03:55] <elcaro> Like so: DateTime.new: |(.substr(0,4),.substr(4,2),.substr(6,2),.substr(8,2),.substr(10,2),.substr(12,2)) given '20250910131152'

[03:55] <elcaro> ~250% faster than the .match version

[03:58] <elcaro> Actually don't need the `|` on that last one

[04:02] <Voldenet> the grammar one is actually going to be pretty slow without tons of optimizations

[04:02] <Voldenet> because it's using the hash to initialize new and grammars are not horribly fast either

[04:03] <Voldenet> m: grammar MyDateFormat { regex TOP { <day=.d2> <year=.d4> <month=.d2> <hour=.d2> <minute=.d2> <second=.d2> { make DateTime.new(|$/) } }; regex d2 { \d**2 }; regex d4 { \d**4 } }; say MyDateFormat.parse("20250910130537").made # but you can do that easily

[04:03] <camelia> rakudo-moar a988e79f9: OUTPUT: «2509-10-20T13:05:37Z␤»

[04:03] *** arkiuat joined
[04:31] *** tbrowder left
[04:34] *** tbrowder joined
[05:32] *** Sgeo left
[05:37] *** Aedil joined
[05:50] *** arkiuat left
[05:52] *** abraxxa joined
[06:04] *** arkiuat joined
[07:07] *** arkiuat left
[07:21] *** arkiuat joined
[07:26] *** arkiuat left
[07:31] *** lichtkind joined
[07:49] *** arkiuat joined
[07:54] *** arkiuat left
[08:09] *** dakkar joined
[08:16] *** Aedil left
[08:23] *** arkiuat joined
[08:28] *** arkiuat left
[08:31] *** melezhik joined
[08:48] *** Guest31 joined
[08:50] *** arkiuat joined
[08:54] *** apac joined
[09:06] *** itaipu left
[09:17] *** Guest31 left
[09:21] *** arkiuat left
[09:34] *** arkiuat joined
[09:38] *** arkiuat left
[10:06] *** arkiuat joined
[10:11] *** arkiuat left
[10:16] *** apac left
[10:29] *** crnlskn joined
[10:32] *** arkiuat joined
[10:39] *** arkiuat left
[10:50] *** melezhik left
[11:09] *** arkiuat joined
[11:14] *** arkiuat left
[11:20] *** arkiuat joined
[11:24] *** arkiuat left
[11:49] *** Aedil joined
[11:52] *** arkiuat joined
[11:57] *** arkiuat left
[12:04] <disbot1> <antononcube> @jubilatious1_98524 "DateTime::Grammar" is better: https://raku.land/zef:antononcube/DateTime::Grammar

[12:16] *** arkiuat joined
[12:21] *** arkiuat left
[12:34] *** simcop2387 left
[12:36] *** simcop2387 joined
[12:45] *** arkiuat joined
[12:48] *** simcop2387 left
[12:50] *** arkiuat left
[13:17] *** arkiuat joined
[13:17] *** itaipu joined
[13:22] *** arkiuat left
[13:25] *** oodani left
[13:27] *** itaipu left
[13:30] *** oodani joined
[13:31] *** xinming left
[13:32] *** xinming joined
[13:34] *** simcop2387 joined
[13:38] *** arkiuat joined
[13:43] *** itaipu joined
[13:44] *** arkiuat left
[14:15] *** arkiuat joined
[14:20] *** arkiuat left
[14:20] <perryprog> elcaro, wait HOW IS .MATCH FASTER

[14:21] <perryprog> *than rotor

[14:29] *** crnlskn left
[14:39] *** arkiuat joined
[14:43] *** arkiuat left
[15:11] *** arkiuat joined
[15:16] *** arkiuat left
[15:19] *** apac joined
[15:20] <ab5tract> m: "20250910131152" ==> -> $ts { [[0,4],[4,2],[6,2],[8,2],[10,2],[12,2]].map: ->[ \f,\l] { $ts.substr(f,l)} }()  ==> { DateTime.new(|$_) }() ==> dd()

[15:20] <camelia> rakudo-moar a988e79f9: OUTPUT: «DateTime.new(2025,9,10,13,11,52)␤»

[15:22] <ab5tract> was inspired to pull out the old feed operator 

[15:40] *** arkiuat joined
[15:44] *** arkiuat left
[16:09] *** apac left
[16:13] *** arkiuat joined
[16:17] *** arkiuat left
[16:39] *** dakkar left
[16:41] *** arkiuat joined
[16:45] *** arkiuat left
[16:46] *** arkiuat joined
[16:51] *** arkiuat left
[17:20] *** arkiuat joined
[17:24] *** arkiuat left
[17:42] *** arkiuat joined
[17:47] *** arkiuat left
[17:49] *** itaipu left
[18:02] *** itaipu joined
[18:16] *** arkiuat joined
[18:21] *** arkiuat left
[18:34] *** arkiuat joined
[18:35] *** abraxxa left
[18:39] *** arkiuat left
[18:45] *** arkiuat joined
[18:49] *** arkiuat left
[19:18] *** arkiuat joined
[19:24] *** arkiuat left
[19:27] *** apac joined
[19:44] *** arkiuat joined
[19:48] *** Aedil left
[19:48] *** arkiuat left
[20:11] *** arkiuat joined
[20:18] *** arkiuat left
[20:36] *** arkiuat joined
[21:14] <disbot1> <librasteve> Voldenet: et al ... how about https://github.com/Raku/problem-solving/issues/494 .FatRatStr

[21:55] *** ACfromTX left
[22:07] <Voldenet> ah, so it would never become Num in the first place

[22:08] *** ACfromTX joined
[22:10] <Voldenet> m: say FatRat.new(16605402, 10**34).nude; say 1.6605402e-27.FatRat(1e-100) # those are equal, but str can be directly interpreted as FatRat

[22:10] <camelia> rakudo-moar a988e79f9: OUTPUT: «(8302701 5000000000000000000000000000000000)␤0.00000000000000000000000000166054␤»

[22:10] <Voldenet> m: say FatRat.new(16605402, 10**34); say 1.6605402e-27.FatRat(1e-100)

[22:10] <camelia> rakudo-moar a988e79f9: OUTPUT: «0.0000000000000000000000000016605402␤0.00000000000000000000000000166054␤»

[22:11] *** human-blip left
[22:13] *** human-blip joined
[22:18] <Voldenet> m: sub z(Str() $_) { S:g/('0'+)/{ "\{0x{$0.chars}}" }/ }; say z FatRat.new(16605402, 10**34); say z 1.6605402e-27.FatRat(1e-100) # more readable

[22:18] <camelia> rakudo-moar a988e79f9: OUTPUT: «{0x1}.{0x26}166{0x1}54{0x1}2␤{0x1}.{0x26}166{0x1}54␤»

[22:20] <Voldenet> m: sub z(Str() $_) { S:g/('0'+)/{ $0.chars > 3 ?? "\{0x{$0.chars}}" !! $0 }/ }; say z FatRat.new(16605402, 10**34); say z 1.6605402e-27.FatRat(1e-100)

[22:20] <camelia> rakudo-moar a988e79f9: OUTPUT: «0.{0x26}16605402␤0.{0x26}166054␤»

[22:22] <Voldenet> I'd say that special casing NumStr -> FatRat should be enough

[22:31] <Voldenet> > https://glot.io/snippets/hazwbo9b0m

[22:33] <Voldenet> in fact, NumStr -> Rat would be more than enough to handle this, after all 16605402 is not a large number

[22:39] <Voldenet> (the above is llm generated, because I hoped that it'd cover all possible cases, I didn't test it on more than one example)

[23:09] *** itaipu left
[23:17] *** Sgeo joined
[23:24] *** itaipu joined
[23:25] *** vasko left
[23:27] *** vasko joined
[23:46] *** itaipu left
