[00:05] *** arkiuat joined
[00:13] *** arkiuat left
[00:16] <Voldenet> it's not actually impossible to compile raku into binaries - in fact given some specific AST it's possible to write C directly from it

[00:19] <Voldenet> generating C from tiny subset of the language should be trivial due to having built-in parser for it

[00:24] <Voldenet> for example "all types must be defined, only Str and Int are supported, only simple subs" should be relatively easy, types for scopes, signatures would need to be practically implemented in C

[00:27] <Voldenet> otoh, scopes, dynamic variables, await can't be written in trivial C, so that'd require bundling the whole raku runtime - it's not impossible to generate bytecode and use this path

[00:27] *** arkiuat joined
[00:30] <Voldenet> at some point I was planning to build some poc of embeddable raku (something like PerlInterpreter), it would definitely make this more feasible

[00:33] <arkiuat> some Str somewhere isn't getting initialized. I think this is the kind of thing that made me flee *brew and scurry back into MacPorts (which hasn't updated rakudo since v2025.05)

[00:34] <Voldenet> hm, is there any stack trace?

[01:03] *** notable6__ joined
[01:03] *** quotable6 left
[01:03] *** notable6 left
[01:03] *** bisectable6 left
[01:03] *** linkable6 left
[01:03] *** Ekho left
[01:03] *** cryosis left
[01:03] *** unicodable6 left
[01:03] *** sourceable6__ left
[01:03] *** coverable6 left
[01:03] *** benchable6 left
[01:03] *** releasable6 left
[01:03] *** quotable6 joined
[01:03] *** bisectable6 joined
[01:03] *** linkable6 joined
[01:04] *** nativecallable6_ left
[01:05] *** nativecallable6 joined
[01:05] *** zetaaaa_ left
[01:05] *** Sgeo__ joined
[01:06] *** cryosis joined
[01:06] *** Ekho joined
[01:07] *** benchable6 joined
[01:08] *** Sgeo_ left
[01:08] <arkiuat> Nope, it's a compilation error

[01:09] <arkiuat> pointing to /private/var/folders/p2/ with what look like hashes in the rest of the path

[01:11] <arkiuat> It happened most recently when I was installing ValueType and then later with App::Ecosystems

[01:12] <arkiuat> just now I tried "zef install rakudoc" -- same compilation error

[01:14] <arkiuat> perhaps when I decided to try *brew again, I needed to thoroughly eradicate MacPorts from my system first. Not sure that I've done that correctly

[01:18] <arkiuat> okay, this is fun. I just used rakubrew to switch from v2025.08 back to v2025.05, and now ValueType just installed with no problem, and rakudoc is installing

[01:19] <arkiuat> installed successfully, and now installing App::Ecosystems. So this seems to be a bug introduced in v2025.08 maybe?

[01:21] *** hulk joined
[01:21] *** kylese left
[01:22] *** zetaaaa_ joined
[01:22] <arkiuat> that failed, but for a much more graspable reason: expected module eigenstates v0.0.11 but got eigenstates v0.0.12

[01:29] *** nine left
[01:30] *** nine joined
[01:32] <Voldenet> hmm, ValueType doesn't have very large test, maybe it could be further reduced to one line

[01:59] <arkiuat> yes, that's a good tip

[02:04] <arkiuat> the compilation error singled out line 2 of the single test file, which is "use Test" which would certainly explain why this is happening across all modules!

[02:06] <arkiuat> however, "raku -MTest" under v2025.08 starts up with no problem

[02:15] *** hulk left
[02:15] *** kylese joined
[02:49] *** zetaaaa_ left
[03:08] *** arkiuat left
[03:20] *** arkiuat joined
[03:24] *** arkiuat left
[03:25] *** dg left
[03:26] *** dg joined
[03:44] *** arkiuat joined
[03:54] *** arkiuat left
[04:36] *** Aedil joined
[05:22] *** phogg left
[05:27] *** phogg joined
[06:26] *** Geth left
[06:27] *** Sgeo__ left
[06:28] *** kylese left
[06:29] *** kylese joined
[06:45] *** quotable6 left
[06:45] *** cryosis left
[06:45] *** quotable6 joined
[06:45] *** bisectable6 left
[06:57] *** dg left
[06:57] *** timo2 left
[06:57] *** timo2 joined
[06:58] <disbot9> <simon_sibl> I am not sure to understand the do whenever  at https://docs.raku.org/type/IO/Socket/Async/ListenSocket why is the do required, why is the return value handled that way ?

[07:00] *** dg joined
[07:10] *** tadzik joined
[07:13] *** merpp left
[07:13] *** merp joined
[07:48] <disbot9> <simon_sibl> also, will Raku recognize such instruction and use sendfile or similar trick: $socket.write($path.IO.slurp(:bin)) ? or it will slurp the whole file in memory and only then send it through the socket ?

[07:50] <disbot9> <simon_sibl> or linked to that question, would it be possible to lazily read a file, pipe it through a base64 generator and lazily send that output through a socket ?

[08:09] *** dakkar joined
[08:44] *** Maylay left
[08:46] *** lichtkind_ joined
[08:47] *** Maylay joined
[09:23] *** mimosa_ joined
[09:32] *** mimosa_ left
[09:33] *** mimosa joined
[10:15] <ab5tract> .IO.lines is lazy already, IIRC

[10:16] <ab5tract> `do` is a way of evaluating an expression into its sunk value. so here it's a sort of conditional `await`

[10:17] <ab5tract> FWIW, I've never seen that in the wild and I think it fails a docs smell test of only demonstrating as few language features at a time in an example

[10:19] <lizmat> simon_sibl afaik, sendfile is out of reach at the moment: but I have set up irclogs.raku.org to be able to use that as soon as it becomes possible

[10:20] <lizmat> although I think it will more become something like: $socket.sendile($path)

[10:20] <lizmat> *sendfile

[10:31] *** ds7832 joined
[11:12] *** Geth joined
[12:32] *** apa_c joined
[13:27] *** ds7823 joined
[13:30] *** ds7823 left
[13:30] *** ds7832 left
[13:31] *** ds7832 joined
[13:38] *** ds7832 left
[13:39] *** ds7823 joined
[13:41] *** ds7823 left
[13:43] *** ds7823 joined
[14:10] <disbot9> <jubilatious1_98524> I don't understand that do either. Usually I see do before a for loop, not within a block.

[14:12] *** Sgeo joined
[14:15] <disbot9> <librasteve> Technically, do is a loop which runs exactly one iteration.  .oO

[14:15] <disbot9> <librasteve> [I have used do a bit but never really understood what it does]

[14:15] *** ds7823 left
[14:15] *** apa_c left
[14:16] <disbot9> <jubilatious1_98524> Don't we have once for that?

[14:16] <disbot9> <librasteve> I am quoting the docs - https://docs.raku.org/language/control#do ... doesn't mean that I have any clue what they mean!

[14:18] <disbot9> <jubilatious1_98524> I've used do to send the return of a for loop into a LHS assignment, usually overwriting the same object I started from.

[14:21] *** arkiuat joined
[14:25] <ab5tract> I hadn't ever considered `do` a looping construct. otherwise `do for` wouldn't make sense

[14:26] <ab5tract> once is per-scope. It can be used in a loop or outside of one

[14:26] <ab5tract> `do` is a statement prefix modifier that turns an expression into a value

[14:26] <disbot9> <jubilatious1_98524> m:my @a = "a".."e"; @a = for @a { $_.uc }; say @a;

[14:26] <disbot9> <Raku eval>  Exit code: 1 ===SORRY!=== Word 'for' interpreted as a listop; please use 'do for' to introduce the statement control word at /home/glot/main.raku:1 ------> my @a = "a".."e"; @a = for⏏ @a { $_.uc }; say @a; Unexpected block in infix position (two terms in a row) at /home/glot/main.raku:1 ------> my @a = "a".."e"; @a = for @a⏏ { $_.uc }; say @a;  

[14:27] <ab5tract> m:my @a = "a".."e"; @a = do for @a { $_.uc }; say @a;

[14:27] <evalable6> ab5tract, rakudo-moar 483307f7c: OUTPUT: «[A B C D E]␤»

[14:27] <disbot9> <jubilatious1_98524> m: my @a = "a".."e"; @a = do for @a { $_.uc }; say @a;

[14:27] <disbot9> <Raku eval>  [A B C D E] 

[14:27] <disbot9> <librasteve> yeah - I read that do for returns the value of the last iteration (better go review what my do fors are doing!)

[14:27] <ab5tract> sorry if I got that impression. I was referring to the final value in the statement list

[14:28] <arkiuat> I've always thought of do as "what you use when you want to obtain the return value of a control statement usually evaluated in sink context"

[14:28] <ab5tract> but it's probably not a good way to explain it

[14:29] <ab5tract> arkiuat: well said

[14:29] <arkiuat> as for my zef install issues, I've had to fall back from v2025.08 to v2025.05 because at least I can install modules on it

[14:30] <disbot9> <librasteve> I am having a few niggles with installs atm

[14:31] <disbot9> <librasteve> but does seem to be around 2025.08 / 2025.05 boundary ...

[14:47] <librasteve_> m: say do for ^3 {$++}

[14:47] <camelia> rakudo-moar 483307f7c: OUTPUT: «(0 1 2)␤»

[14:48] <librasteve_> m: say for ^3 {$++}

[14:48] <camelia> rakudo-moar 483307f7c: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Unsupported use of bare "say". In Raku please use: .say if you meant to␤call it as a method on $_, or use an explicit invocant or argument, or␤use &say to refer to the function as a noun.␤at <tmp>:1␤-…»

[14:49] <disbot9> <librasteve> yeah - that's what I expected do for to do (ie do the for loop and return the results as a List)

[14:51] <disbot9> <librasteve> weekly: https://unix.stackexchange.com/questions/385632/in-consecutive-rows-sum-2nd-value-column-if-ids-in-1st-key-column-are-ident/800463#800463

[14:52] <disbot9> <librasteve> lools like the weekly bot is down here (Discord)

[14:52] <librasteve_> weekly: https://unix.stackexchange.com/questions/385632/in-consecutive-rows-sum-2nd-value-column-if-ids-in-1st-key-column-are-ident/800463#800463

[14:52] <notable6__> librasteve_, Noted! (weekly)

[14:52] <librasteve_> but not here (IRC)

[14:53] <arkiuat> I've been using do + given a lot lately

[14:54] <arkiuat> do + given-when, I should say

[14:55] *** apa_c joined
[14:56] <arkiuat> ab5tract, thanks!

[14:57] <arkiuat> and by a lot, I mean two or three times, which only seems like a lot because it's a new usage for me

[14:57] *** guifa joined
[15:01] *** apa_c left
[15:02] <disbot9> <librasteve> yeah it took me a while to get into it ... such as

[15:02] <disbot9> <librasteve> my @todos = do for <one two> -> $text { Todo.new: :$text };

[15:03] <arkiuat> librasteve, that stackexchange example has me wondering if the one-and-only distinction between for and given is that given doesn't loop

[15:03] *** abraxxa left
[15:03] <disbot9> <librasteve> that's how it feels to me

[15:04] <lizmat> m: .say for 42

[15:04] <camelia> rakudo-moar 483307f7c: OUTPUT: «42␤»

[15:04] <arkiuat> I don't think I've ever used for-when yet

[15:04] <lizmat> m: .say given 42

[15:04] <camelia> rakudo-moar 483307f7c: OUTPUT: «42␤»

[15:04] <lizmat> m: .say for (1,2,3)

[15:04] <camelia> rakudo-moar 483307f7c: OUTPUT: «1␤2␤3␤»

[15:04] <lizmat> m: .say given (1,2,3)

[15:04] <camelia> rakudo-moar 483307f7c: OUTPUT: «(1 2 3)␤»

[15:04] <disbot9> <librasteve> I think the only thing given does is to set the topic afaik

[15:05] <lizmat> indeed

[15:05] <arkiuat> lizmat, oh, very interesting

[15:05] <lizmat> and it will not iterate on iterables

[15:05] <arkiuat> so that's a second difference, thanks

[15:05] <disbot9> <librasteve> .oO (gee I love this language!)

[15:06] <arkiuat> and that totally makes sense, given the close connection between looping and wanting to iterate over iterables vs treating an iterable as an item

[15:07] <arkiuat> that makes the distinction between for and given a lot clearer for me

[15:09] <arkiuat> librasteve, so I guess a series of whens followed by a default (with scattered proceeds and succeeds as needed) would work inside any topic-setting control syntax?

[15:10] <lizmat> m: $_ = 42; when 42 { say "success" }

[15:10] <camelia> rakudo-moar 483307f7c: OUTPUT: «success␤»

[15:10] <arkiuat> Nice.

[15:11] <disbot9> <librasteve> I bow to lizmat in all matters, natch

[15:12] *** apa_c joined
[15:14] <arkiuat> that's incredibly flexible

[15:17] <arkiuat> I am going to be on the lookout for opportunities to use for-when now!

[15:18] *** apa_c left
[15:21] <arkiuat> thanks, lizmat

[15:54] <disbot9> <jubilatious1_98524> @arkiuat I wrote it both ways, given/when and for/when, nd finally decided to post the for/when version.

[15:54] <arkiuat> I'm glad you did!

[16:06] <disbot9> <jubilatious1_98524> m: $_ = 43; when  43 { say "success" };

[16:06] <disbot9> <Raku eval>  success 

[16:06] <disbot9> <jubilatious1_98524> m: $_ = 43; when none 42 { say "failure" };

[16:06] <disbot9> <Raku eval>  failure 

[16:07] <disbot9> <jubilatious1_98524> Use none to negate.

[16:16] <arkiuat> that's certainly more elegant-looking than when $_ ne 42, but I expect non-rakuuns are going to cite as yet another of Raku's weird idioms

[16:16] <arkiuat> sorry, meant !=, not ne

[16:23] <disbot9> <jubilatious1_98524> m: $_ = 43; when $_ != 42 { say "failure" }

[16:23] <disbot9> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Confused at /home/glot/main.raku:1 ------> $\⏏_ = 43; when $_ != 42 { say "failure" } 

[16:24] <disbot9> <jubilatious1_98524> m: $_ = 43; when $_ != 42 { say "failure" }

[16:24] <disbot9> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Confused at /home/glot/main.raku:1 ------> $\⏏_ = 43; when $\_ != 42 { say "failure" } 

[16:25] <disbot9> <jubilatious1_98524> Bot interprets $ ... $ as italics (markdown). Anyway $_ != 42 works also.

[16:29] *** dakkar left
[17:00] *** arkiuat left
[17:05] *** arkiuat joined
[17:13] <arkiuat> yes, but none 42 looks prettier

[17:14] <disbot9> <librasteve> I recommend back ticks as in m: code when in discord

[17:20] <Voldenet> btw, "none" isn't even the same thing

[17:20] <disbot9> <jubilatious1_98524> Thanks Steve.

[17:22] <Voldenet> under the hood I mean, it's a lot more complicated than plain !=

[17:23] <disbot9> <jubilatious1_98524> m: my @a = "a".."e"; @a.grep( {! /f/ } ).say;

[17:23] <disbot9> <Raku eval>  (a b c d e) 

[17:23] <Voldenet> m: given 42 { when * != 42 { say "failure" }}; # another way of writing it

[17:23] <camelia> rakudo-moar 483307f7c: ( no output )

[17:23] <disbot9> <jubilatious1_98524> m: my @a = "a".."e"; @a.grep( none /f/ ).say;

[17:23] <disbot9> <Raku eval>  (a b c d e) 

[17:24] <disbot9> <jubilatious1_98524> m: my @a = "a".."e"; @a.grep( none /e/ ).say;

[17:24] <disbot9> <Raku eval>  (a b c d) 

[17:25] <Voldenet> m: sub x(Mu $x) { say $x }; x none 42;

[17:25] <camelia> rakudo-moar 483307f7c: OUTPUT: «none(42)␤»

[17:26] <Voldenet> it's useful, but plain op for "not equals" can't do the above, for example

[17:26] <disbot9> <jubilatious1_98524> Why are you complicating things by creating a sub?

[17:27] <Voldenet> Obviously to show that you can complicate things by complicating them ;)

[17:27] <disbot9> <jubilatious1_98524> [ BTW, grep examples are straight from the Docs ].

[17:30] <Voldenet> huh, I've checked and apparently grep(none /f/) is faster

[17:32] <Voldenet> so apparently in some cases junctions are even faster than simple negation

[17:32] <Voldenet> I can guess that the `none /e/` doesn't even create a block and blocks aren't cheap

[17:34] <disbot9> <jubilatious1_98524> m: $ = 43; when $ eq none 42 { say "failure" };

[17:34] <disbot9> <Raku eval>  failure 

[17:35] <disbot9> <jubilatious1_98524> The Junction page suggests: "In general it is more readable to use a positive comparison operator and a negated junction".

[17:38] <Voldenet> hm, I remember there was some weird gotcha about negated junctions

[17:39] <Voldenet> m: say none([]) != 42

[17:39] <camelia> rakudo-moar 483307f7c: OUTPUT: «False␤»

[17:41] <Voldenet> which means that the array contains value 42…

[17:42] <Voldenet> so I tend to avoid junctions, because I simply don't understand the why behind it

[17:43] <arkiuat> well, not exactly. It means that none of the values are unequal to 42, and there are no values, so none of them are

[17:44] <arkiuat> neither != nor ne will accept Nil as an arg

[17:45] <Voldenet> I understand technically, but I intuitively would use it wrong

[17:45] <arkiuat> oh wait, I'm wrong. It complains with an error msg, but:

[17:45] <arkiuat> m: say so Nil != 42

[17:45] <camelia> rakudo-moar 483307f7c: OUTPUT: «Use of Nil in numeric context␤True␤  in block <unit> at <tmp> line 1␤»

[17:45] <arkiuat> it does return True.  Huh.

[17:47] <Voldenet> m: say so 42 (elem) [] # this is what I prefer

[17:47] <camelia> rakudo-moar 483307f7c: OUTPUT: «False␤»

[17:47] <arkiuat> sure, that's much clearer

[17:48] <Voldenet> and

[17:48] <Voldenet> m: say so 42 !(elem) []

[17:48] <camelia> rakudo-moar 483307f7c: OUTPUT: «True␤»

[17:49] <Voldenet> otoh when there's no negation, it works as I'd expect

[17:50] <Voldenet> m: say none() eq 42

[17:50] <camelia> rakudo-moar 483307f7c: OUTPUT: «none()␤»

[17:50] <Voldenet> m: say so none() eq 42

[17:50] <camelia> rakudo-moar 483307f7c: OUTPUT: «True␤»

[17:57] <arkiuat> now I'm even more confused

[17:59] <Voldenet> hehe, I know right? :)

[17:59] <Voldenet> the trick is in how negation is implemented

[18:00] <Voldenet> it simply does !($op1 eq $op2)

[18:00] <Voldenet> so in case of negated junctions… it actually finds equal values and negates the result

[18:00] *** [Coke]_ joined
[18:03] *** [Coke] left
[18:10] <lizmat> Voldenet arkiuat https://github.com/Raku/problem-solving/issues/319

[18:14] <arkiuat> lizmat, thanks!

[18:19] <arkiuat> oh no, and I just told tbrowder the other day that !(elem) is equiv to ∉

[18:19] <arkiuat> I suppose in most context it still is

[18:19] <lizmat> yeah, it is (usually)

[18:23] <arkiuat> so it looks as if some of the confusing behavior we were discussing will change in 6.e

[18:35] <lizmat> it does ?

[18:38] <arkiuat> okay, that's surmising too much. there are some unmerged PRs outstanding that haven't been closed that *seem* to address at least part of the issue

[18:38] <disbot9> <jubilatious1_98524> @Voldenet are you equating say so none() eq 42 with say so $_ eq none 42?

[18:38] <arkiuat> but the main one is still marked DRAFT, so definitely surmising too much

[18:40] *** silug4 left
[18:41] *** silug4 joined
[19:28] *** guifa left
[19:30] *** disbot10 joined
[19:31] *** charsbar_ joined
[19:31] *** dano2 joined
[19:32] *** guifa joined
[19:32] *** ab5tract_ joined
[19:32] *** oodani joined
[19:32] *** gabiruh joined
[19:33] *** [Coke]_ is now known as [Coke]

[19:34] *** greaser|q_ joined
[19:35] *** sivoais_ joined
[19:35] *** andinus2 joined
[19:36] *** ab5tract left
[19:36] *** camelia left
[19:36] *** charsbar left
[19:36] *** ab5tract_ is now known as ab5tract

[19:36] *** ugexe left
[19:36] *** oodani_ left
[19:36] *** disbot9 left
[19:36] *** andinus left
[19:36] *** dano left
[19:36] *** gabiruh_ left
[19:37] *** greaser|q left
[19:37] *** sivoais left
[19:37] *** dano2 is now known as dano

[19:37] *** charsbar_ is now known as charsbar

[19:38] *** linkable6 left
[19:38] *** greppable6__ left
[19:38] *** committable6 left
[19:38] *** benchable6 left
[19:38] *** nativecallable6 left
[19:38] *** notable6__ left
[19:38] *** quotable6 left
[19:38] *** bloatable6 left
[19:38] *** evalable6 left
[19:40] *** shareable6 joined
[19:40] *** linkable6 joined
[19:40] *** releasable6 joined
[19:40] *** bloatable6 joined
[19:41] *** committable6 joined
[19:41] *** greppable6 joined
[19:41] *** tellable6 joined
[19:41] *** evalable6 joined
[19:41] *** bisectable6 joined
[19:42] *** coverable6 joined
[19:42] *** sourceable6 joined
[19:43] *** unicodable6 joined
[19:43] *** benchable6 joined
[19:43] *** nativecallable6 joined
[19:43] *** notable6 joined
[19:43] *** quotable6 joined
[19:44] *** Aedil left
[19:47] *** ugexe joined
[19:47] *** jdv joined
[19:51] *** camelia joined
[20:00] *** camelia left
[20:07] *** arkiuat left
[20:08] *** apa_c joined
[20:19] *** arkiuat joined
[20:23] *** camelia joined
[20:24] *** arkiuat left
[20:38] *** stanrifkin joined
[20:39] *** melezhik_ joined
[20:39] <melezhik_> .

[20:39] *** arkiuat joined
[20:41] *** itaipu left
[20:47] *** melezhik_ left
[20:47] *** melezhik_ joined
[20:48] <arkiuat> seen on another channel: "rak will rename with `git mv' if it sees the file is under git control" <-- this is super cool

[20:48] <arkiuat> lizmat++

[20:49] *** itaipu joined
[21:03] <Voldenet> jubilatious1_98524: Yes, `none of elements () is equal to 42` and `from () none is equal to 42` sound very similar to me, but that only works with these specific operands

[21:05] <Voldenet> but it might be that I'm not seeing something, I'm not very fluent in junctions

[21:07] <Voldenet> I still prefer the code I know best from C#, so explicitly checking if element is in collection or if it matches some predicate

[21:10] *** Manifest0 joined
[21:11] *** ds7832 joined
[21:15] *** lichtkind_ left
[21:18] *** melezhik_ left
[22:00] *** halloy2489 joined
[22:00] *** arkiuat left
[22:06] *** arkiuat joined
[22:10] *** ds7823 joined
[22:16] *** apa_c left
[22:21] *** ds7832 left
[22:38] *** halloy2489 left
[22:38] *** Geth left
[22:40] *** itaipu left
[22:45] *** itaipu joined
[22:49] *** ds7823 left
[22:52] *** ds7832 joined
[22:55] <disbot10> <jubilatious1_98524> m: $ = 43; say so $ == none(42);

[22:55] <disbot10> <Raku eval>  True 

[22:55] <disbot10> <jubilatious1_98524> m: $ = 43; say $ ~~ none(42);

[22:55] <disbot10> <Raku eval>  True 

[23:16] *** librasteve_ left
