[00:47] *** SEric left
[00:55] *** Aedil left
[03:27] *** apogee_ntv left
[03:29] *** apogee_ntv joined
[04:12] *** Aedil joined
[05:59] *** cryosis left
[06:42] *** apac joined
[07:05] *** lichtkind joined
[07:08] *** apac left
[07:24] *** swaggboi left
[07:32] *** abraxxa joined
[07:37] *** abraxxa1 joined
[07:40] *** abraxxa left
[07:43] *** Sgeo left
[07:48] *** bolangi left
[08:04] *** ACfromTX left
[08:15] *** dakkar joined
[08:18] *** ACfromTX joined
[08:49] *** acidsys left
[09:02] *** acidsys joined
[09:49] *** melezhik joined
[10:17] *** abraxxa joined
[10:19] *** ACfromTX left
[10:20] *** abraxxa1 left
[10:23] *** ACfromTX joined
[10:34] *** abraxxa2 joined
[10:35] *** abraxxa3 joined
[10:36] *** abraxxa left
[10:38] *** abraxxa2 left
[10:40] *** abraxxa joined
[10:41] *** abraxxa1 joined
[10:42] *** abraxxa3 left
[10:45] *** abraxxa left
[11:14] *** Guest75 joined
[11:20] *** Guest75 left
[12:18] *** melezhik left
[12:20] *** ACfromTX left
[12:34] *** ACfromTX joined
[12:37] *** apac joined
[12:38] <disbot1> <melezhik.> Concat CSV files using Sparky plugin - https://gist.github.com/melezhik/96ce5fe848c2fec073d35800693076fe

[13:00] *** ACfromTX left
[13:14] *** ACfromTX joined
[13:58] *** maylay left
[13:58] *** maylay joined
[14:05] *** Sgeo joined
[14:23] *** ACfromTX left
[14:28] *** apac left
[14:32] *** abraxxa1 left
[14:37] *** ACfromTX joined
[14:42] *** apac joined
[14:46] *** ACfromTX left
[15:01] *** ACfromTX joined
[15:37] *** abraxxa-home joined
[15:38] *** abraxxa-home left
[15:39] *** abraxxa-home joined
[16:03] *** cm_ joined
[16:03] *** cm left
[16:03] *** cm_ is now known as cm

[16:04] *** melezhik joined
[16:04] *** apac left
[16:24] <[Coke]> ^^ should that use tmpdir instead of /tmp

[16:24] <[Coke]> er, $*TMPDIR

[16:25] <[Coke]> m: say $*TMPDIR

[16:25] <camelia> rakudo-moar 89765fe8b: OUTPUT: «"/tmp".IO␤»

[16:25] <[Coke]> (locally I get "/var/folders/6v/fwvrwcyd74v8s1wg_2l4_y1r0000gp/T/".IO)

[16:35] *** apac joined
[16:35] *** dakkar left
[16:54] *** human-blip left
[16:56] *** human-blip joined
[17:17] *** apac left
[17:35] *** ACfromTX left
[17:42] *** apac joined
[17:48] *** ACfromTX joined
[18:02] *** ACfromTX left
[18:03] *** vasko joined
[18:13] *** melezhik left
[18:13] *** ACfromTX joined
[18:48] *** abraxxa-home left
[19:00] *** vrurg_ left
[19:02] *** vrurg joined
[19:03] *** abraxxa-home joined
[19:26] *** abraxxa-home left
[20:35] *** apac left
[20:35] *** disbot1 left
[21:01] *** Aedil left
[21:42] <[Coke]> anyone know if centos has an "heir"? https://github.com/rakudo/star/issues/214

[22:10] <ds7832> Hey folks, do you think Raku would be a good choice for a daemon that monitors electricity prices, makes them available to other programs, and may also itself issue control commands for things ranging from BOINC to a washing machine? Different countries/zones/providers have vastly varying APIs and formats for price data, so Raku's expressivity and power are a huge argument in its favour. Plus I'm just growing to love it. The 

[22:10] <ds7832> thing that's making me hesitate is that it'd be nice if the software ran also on cheap/small/integrated/older hardware. Do you think Raku would be a decent choice in this regard? Would it run, say, on a Raspi 3, Raspi 2, or Raspi Zero? I'm also interested in any other thoughts you have.

[22:13] <Voldenet> at some point I was about to test whether raku would compile on cheap arm SoC

[22:13] <leont> I'm pretty sure it compiles, I'm not sure if it JITs on such a system

[22:13] <Voldenet> memory requirements for runtime are pretty high

[22:14] <Voldenet> iirc raku uses luajit so probably there is

[22:15] <Voldenet> though the biggest problem for cheap SoC would be ram requirements, I'd simply check if it works on target minimal hardware

[22:18] <Voldenet> out of good parts performance is going to be quite not an issue thanks to `react whenever` blocks from various sources

[22:18] <Voldenet> thanks to that every probe could work in one thread reducing needs for locking and making codebase trivial

[22:21] <Voldenet> regarding compatibility, I'd check if all libs are ootb supported https://github.com/MoarVM/MoarVM/tree/main/3rdparty

[22:24] <ds7832> Another possibility would be to use Raku more or less just for glue code. But I suspect it has some baseline RAM requirement -- should I expect this already to be high by SoC standards?

[22:25] <Voldenet> typical run is around that > 0.16user 0.04system 0:00.21elapsed 97%CPU (0avgtext+0avgdata 134584maxresident)k

[22:26] <Voldenet> I remember that not even loading grammars and using precompiled moarvm bytecode could optimize this further, but that'd require low-level nqp hacking

[22:27] <Geth> ¦ docker: 8c213b2fb8 | AntonOks++ | 4 files

[22:27] <Geth> ¦ docker: Bump to 2025.08.1 [skip workflow]

[22:27] <Geth> ¦ docker: review: https://github.com/rakudo/docker/commit/8c213b2fb8

[22:28] <Voldenet> At some point rakuast will become "the only" raku grammar so it'll probably be less memory-hungry

[22:28] <Voldenet> But is even 200MB a lot in terms of modern rpis? I don't think so

[22:29] <Voldenet> rpi 1A (released 12 years ago) had around 256MB

[22:33] <Voldenet> while it's possible to use raku for glue code I wouldn't do that here, because of reactivity

[22:34] <Voldenet> yes, it's possible to use threads, processes and synchronize everything through channels, but it'd add a lot of overhead IMO

[22:35] <ds7832> Already sounds good in total. I wasn't yet so aware of Raku's reactivity capabilities, but they would of course be especially useful.

[22:41] <ds7832> I think I might just write the thing in Raku, which should already cover a majority of the interesting machines today let alone a few years down the road.

[22:42] <ds7832> Even more so since insofar the goal is to make use of unused computation power.

[22:46] <Voldenet> for example I like how trivial it is to listen to multiple sockets on one thread easily

[22:46] <Voldenet> > raku -e 'react { for 5000..5010 -> $port { whenever IO::Socket::Async.bind-udp("127.1", $port) { whenever .Supply -> $packet { say "port $port: $packet" } } } }'

[22:46] <Voldenet> probably no language could get it shorter

[22:48] <Voldenet> maybe nodejs since it's single-threaded by design

[22:49] <ds7832> that does look lovely. In my use case, I don't think I'll be listening on web sockets; it'll rather be periodical requests, and then working with whatever they respond. Could reactive programming also have a role to play here?

[22:50] <Voldenet> yes, you can define multiple per-interval processes in such loop as well

[22:51] <Voldenet> with something like `react { whenever Supply.interval(1) { .say }; whenever Supply.interval(.3) { .say } }` etc.

[22:55] <Voldenet> and you can make a loops with it too, for every probe: `react { for (1..10).map(* / 10) -> $time { whenever Supply.interval($time) { ($time, $_).say }}; }`

[22:55] <Voldenet> s/a loops/loops/

[22:58] <ds7832> I think I may do something like update some variables whenever a request-response turned back (new) data. And have another loop running that just works with whatever the current values are. This should be especially fitting to handle several sources of data, e.g. also an additional thermostat, right?

[22:59] <Voldenet> Yeah, it's perfect fit for that

[23:00] <ds7832> Then I've made my decision :)

[23:01] <ds7832> The primary source to learn about these things is the docs page https://docs.raku.org/language/concurrency#react , right?

[23:02] <Voldenet> Yes, maybe also raku irc logs, reddit, SO and https://github.com/Raku/roast

[23:03] <Voldenet> some LLMs (not chatgpt) are decent at understanding raku

[23:03] <Voldenet> chatgpt notably always gives me the code that doesn't work, idk what's up with that

[23:06] <ds7832> Thanks a lot!

[23:06] <ds7832> I have to go to bed now, I think tomorrow I'll dig into things :)

[23:08] *** lichtkind left
[23:14] *** kaskal left
[23:25] *** itaipu left
[23:31] *** itaipu joined
[23:43] *** itaipu left
[23:46] *** itaipu joined
[23:50] *** bolangi joined
