[00:24] *** arkiuat left
[00:53] *** arkiuat joined
[00:58] *** arkiuat left
[01:08] *** hulk joined
[01:08] *** kylese left
[01:28] *** arkiuat joined
[01:32] *** arkiuat left
[01:55] *** arkiuat joined
[02:15] *** hulk left
[02:15] *** kylese joined
[02:22] *** nort joined
[02:57] *** Aedil left
[03:03] *** stanrifkin_ joined
[03:06] *** stanrifkin left
[03:27] *** arkiuat left
[04:10] *** elcaro left
[04:20] *** Aedil joined
[04:21] *** maylay left
[04:50] *** kylese left
[04:50] *** kylese joined
[05:38] <disbot> <simon_sibl> is it possible to have an optional variable argument in a subroutine that is also mutable ?

[05:38] <disbot> <simon_sibl> sub schedule(@str_jobs, $time is rw = 0) {*} doest work..

[05:40] <Voldenet> no idea what you precisely mean, but maybe `is copy` would work

[05:41] <Voldenet> probably not

[05:45] <disbot> <simon_sibl> oh is copy work

[05:45] <disbot> <simon_sibl> thanks !

[05:46] <Voldenet> but then, of course, it doesn't alter the value you pass in

[05:46] <Voldenet> m: sub set-value($n is rw) { $n = 42; }; my $x = 2; set-value($x); say $x

[05:46] <evalable6> Voldenet, rakudo-moar f56482941: OUTPUT: ¬´42‚ê§¬ª

[05:47] <Voldenet> if you wanted "optional output" in such case, I know that multi would work

[05:47] <disbot> <simon_sibl> oh it doesnt have to alter the value I pass in, at least not for now

[05:48] <Voldenet> m: multi sub set-value($n is rw) { say "rw"; $n = 42; }; multi sub set-value { say "optional multi"; samewith($ = 2); }; my $x = 2; set-value($x); set-value(); say $x

[05:48] <evalable6> Voldenet, rakudo-moar f56482941: OUTPUT: ¬´rw‚ê§optional multi‚ê§rw‚ê§42‚ê§¬ª

[06:01] *** derpydoo joined
[06:07] <disbot> <simon_sibl> üôè  had to lookup samewith xD

[06:18] <Voldenet> I pondered and there is a way to do it

[06:19] *** Aedil left
[06:19] <Voldenet> m: sub schedule(@str_jobs, $time is raw = ($ = 0)) { $time = 42 }; my $n = 1; schedule([], $n); schedule([]); say $n

[06:19] <evalable6> Voldenet, rakudo-moar f56482941: OUTPUT: ¬´42‚ê§¬ª

[06:19] <Voldenet> it's a lot cleaner

[06:21] <Voldenet> m: sub schedule(@str_jobs, $time is raw = (my $x = 0)) { say $x.defined; $time = 42 }; my $n = 1; schedule([], $n); schedule([]); say $n # if you need to know whether default value was used or not

[06:21] <evalable6> Voldenet, rakudo-moar f56482941: OUTPUT: ¬´False‚ê§True‚ê§42‚ê§¬ª

[06:21] <disbot> <simon_sibl> thank you so much üôè

[06:22] <disbot> <simon_sibl> I try to sort the jobs before passing them to the sub with basically @jobs.map(...).sort-jobs

[06:22] <disbot> <simon_sibl> but I get No such method 'sort-jobs' for invocant of type 'Seq'

[06:22] <disbot> <simon_sibl> its just a sub sort-jobs(@jobs) {@jobs.sort(...)}

[06:23] <Voldenet> @jobs.map(‚Ä¶).&sort-jobs

[06:23] <Voldenet> `.thing` syntax calls the method of the lvalue

[06:24] <Voldenet> well not lvalue, but the thing on the left

[06:25] <disbot> <simon_sibl> isnt the thing on the left the result of the map ?

[06:27] <Voldenet> yes, but if @jobs is a regular array or list and map is the default method, map returns sequence

[06:27] <disbot> <simon_sibl> I get a Malformed postfix call if I use .&sort-jobs ü•π

[06:27] *** derpydoo left
[06:28] <disbot> <simon_sibl> oh when all is on one line it works

[06:28] <disbot> <simon_sibl> I thought I could add newline before the . calls

[06:28] <Voldenet> m: sub sort-jobs(@p) { @p.sort }; my @a = 1..5; @a.map(20 - *).&sort-jobs.say

[06:28] <evalable6> Voldenet, rakudo-moar f56482941: OUTPUT: ¬´(15 16 17 18 19)‚ê§¬ª

[06:29] <Voldenet> yeah it's some old design decision that it must be on one line :\

[06:29] <Voldenet> iirc

[06:35] *** jjido joined
[06:49] *** wayland joined
[07:02] *** disbot7 joined
[07:02] *** disbot left
[07:03] *** disbot7 is now known as disbot

[07:05] <disbot> <simon_sibl> I dont get why this doesnt work

[07:05] <disbot> <simon_sibl> sub sort-jobs(@jobs) { @jobs.sort: { $^a<priority> <= $^b<priority>, $^a<submit> <=> $^b<submit> } }, when I just do sort: {-.priority, .submit} it works but less flexlible

[07:10] <disbot> <simon_sibl> > This type cannot unbox to a native integer: P6opaque, List

[07:10] *** jjido left
[07:17] *** jjido joined
[07:23] <disbot> <simon_sibl> forces me to do .sort().sort() xD

[07:26] <Voldenet> m: enum prio <low med high>; sub sort-jobs(@jobs) { @jobs.sort({ -.<prio>, .<submit> }) }; my @jobs = do for ^20 { %(prio => prio.roll, submit => (^10).roll) }; .say for @jobs.&sort-jobs

[07:26] <evalable6> Voldenet, rakudo-moar f56482941: OUTPUT: ¬´{prio => high, submit => 0}‚ê§{prio => high, subm‚Ä¶¬ª

[07:26] <evalable6> Voldenet, Full output: https://gist.github.com/f4c29e88e284df05fa86af7f5155115b

[07:26] <Voldenet> yeah it works ofc

[07:30] <Voldenet> but in $^a $^b form you're supposed to return -1 0 or 1

[07:30] <Voldenet> not list

[07:33] <Voldenet> Order::Same, Order::Less or Order::More even ;\

[07:36] *** Sgeo left
[07:36] <wayland> simon_sibl: It's specifically complaining that the return value from the sort block is of the wrong type.  

[07:37] <disbot> <simon_sibl> but why in one way it accepts a list and in another way it doesnt ?

[07:38] *** jjido left
[07:39] <Voldenet> because in one case it accepts one argument and extracts list of values to match

[07:39] <Voldenet> and in second it accepts two arguments and produces comparison results

[07:43] <Voldenet> you can do something like this if you really need second form

[07:43] <Voldenet> m: enum prio <low med high>; sub sort-jobs(@jobs) { @jobs.sort({ $^b<prio> <=> $^a<prio> || $^a<submit> <=> $^b<submit> }) }; my @jobs = do for ^20 { %(prio => prio.roll, submit => (^10).roll) }; .say for @jobs.&sort-jobs

[07:43] <evalable6> Voldenet, rakudo-moar f56482941: OUTPUT: ¬´{prio => high, submit => 0}‚ê§{prio => high, subm‚Ä¶¬ª

[07:43] <evalable6> Voldenet, Full output: https://gist.github.com/e55d72c8c7b6c55d1c785bdfaf3f5473

[07:46] <disbot> <simon_sibl> aaah I havent thought of that, thank you !

[07:47] <wayland> Voldenet: Do you know how sort decides which form it has?  Links to doco appreciated :)   

[07:52] <Voldenet> one/two arguments being expected according to docs: https://docs.raku.org/type/List#routine_sort

[07:52] <Voldenet> in practice it does .arity on the comparing routine

[07:53] <Voldenet> https://github.com/rakudo/rakudo/blob/main/src/core.c/List.rakumod#L1400

[07:59] <Voldenet> Oh and, the form that returns Order is going to be a lot faster at the moment (rakuast could significantly speed it up by rewriting one form to the other)

[08:00] <wayland> Nice!  Thanks :) 

[08:02] <Voldenet> I'm not sure if it that has to be the case though, in theory it's possible to do recursive sort on every field in list

[08:05] <disbot> <simon_sibl> please critic my code: https://termbin.com/408w, especially if its to discover shorter and simpler way to do this the "raku" way, its a basic scheduler, it calculates the average wait time for each priority level of jobs

[08:05] *** lichtkind joined
[08:06] *** lizmat_ left
[08:07] *** lizmat joined
[08:08] <Voldenet> this sort is not going to work, it has to return not `1/0` but also `-1`

[08:08] <Voldenet> you have to use <=>

[08:13] <Voldenet> and .sort(‚Ä¶).sort(‚Ä¶) is not going to work well either

[08:19] <Voldenet> it might work due to sort stability, but I'm not sure if it's guaranteed in practice

[08:34] *** maylay joined
[08:38] <Voldenet> heh, I looked at the code again ‚Äì in fact, the `grep(.<submit>)` has probably no point

[08:38] <Voldenet> because it's a very silly sorting method, but you end up with sorted jobs anyway

[08:56] <disbot> <simon_sibl> its because the sort is first by priority but yeah, if you have a better shorter way, please let me know xD

[09:07] <disbot> <simon_sibl> It‚Äôs a grep < and == and > It‚Äôs to make the 3 list of priority  Or I sent the wrong code ? Let me check

[09:07] <disbot> <simon_sibl> Yeah yeah the grep is a bit silly but it‚Äôs to make the 3 lists

[09:30] *** apac joined
[09:49] *** tejr left
[10:09] *** elcaro joined
[10:27] *** jjido joined
[10:27] *** apac left
[10:32] *** jjido left
[10:35] *** tejr joined
[11:33] *** camelia joined
[11:41] *** apac joined
[11:43] <disbot> <simon_sibl> alright: https://termbin.com/1w6f

[11:43] <disbot> <simon_sibl> better right ?

[11:57] <disbot> <simon_sibl> (shorter and maybe a bit less readable) https://termbin.com/4n75

[12:05] <Voldenet> heh I feel like the last code is actually more readable

[12:10] *** jjido joined
[12:10] *** jjido left
[12:15] <disbot> <jubilatious1_98524> @simon_sibl typo?  $^a<priority> <= $^b<priority>

[12:17] <Voldenet> actually, after reading and understanding what that sort actually does, you need to find the minimum

[12:17] <Voldenet> not sort the list

[12:20] *** nort left
[12:20] <Voldenet> > @jobs.min(:p, { +($^a<submit> > $time), -$^a<priority>, $^a<submit> })

[12:20] <Voldenet> something like this perhaps

[12:21] <Voldenet> or

[12:22] <Voldenet> > @jobs.min(:p, { +($^a<submit> > $time), -$^a<priority>, $^a<submit> }).head # we don't care which pending item with the same priority

[12:23] <Voldenet> it's bound to be orders of magnitude faster, because it would just go through the list once

[12:26] <Voldenet> afterwards, you would need to either extract the item from list or set it to Any

[12:28] <Voldenet> m: enum prio <low med high>; my @jobs = do for ^10 { %(priority => prio.roll, submit => (^10).roll) }; my $time = 3; while $_ = @jobs.min(:p, { +(.<submit> > $time), -.<priority>, .<submit> }).head { say "processing {.value.gist}"; @jobs[.key] = Any };

[12:28] <camelia> rakudo-moar f56482941: OUTPUT: ¬´processing {priority => high, submit => 3}‚ê§processing {priority => med, submit => 2}‚ê§processing {priority => med, submit => 2}‚ê§processing {priority => low, submit => 3}‚ê§processing {priority => high, submit => 4}‚ê§processing {priority => med, ‚Ä¶¬ª

[12:34] <disbot> <simon_sibl> for the last link ?

[13:04] <disbot> <simon_sibl> oh wow Voldenet, I need to check that min function

[13:07] <disbot> <simon_sibl> not sure how I would combine that with the shift, but the min should be faster than the sort for sure

[13:12] <disbot> <simon_sibl> pretty happy with the last one, pretty short and clear, the one who made the challenge and solved it with Python had it in ~70 lignes

[13:16] <disbot> <simon_sibl> for the first argument I am not sure to understand +($^a<submit> > $time)

[13:20] <disbot> <simon_sibl> why not keeping the <=>, because with > we wont have the difference between the late one and the on time jobs right ?

[13:40] <disbot> <jubilatious1_98524> @simon_sibl When sorting I'd  use <=> or leg or  cmp with $^a $^b.

[13:45] <disbot> <simon_sibl> when going while @jobs.min(:p, { $^a<submit> <=> $time, -$^a<priority>, $^a<submit> }) -> $i, $j { even with .head and .flat and <> it doesnt want to split the item in two, I thought <> could be used to decontainerize

[13:45] <disbot> <simon_sibl> I tried with <=> and it works with min üôè

[13:50] <disbot> <simon_sibl> but so far, this do it pretty well and faster thanks to the usage of min instead of sort üôè  (thank you again Voldenet)

[13:50] <disbot> <simon_sibl> https://termbin.com/afnz

[14:10] <disbot> <nahita3882> you are passing :p to &min, so it returns a Sequence of Pairs. To match this on the destructuring side, you can do, e.g., -> (:$key, :$value)

[14:11] <disbot> <nahita3882> if you want names other than "key" and "value", you can use the aliasing as -> (:key($i), :value($j))

[14:12] <disbot> <nahita3882> lastly, when you do -> $i, $j (i.e., without the parens), this will make the loop request 2 things from the iterated thing at a time, and assign first to $i, second to $j

[14:13] <disbot> <nahita3882> as such, for example, it would fail if the iterable doesn't have even number of elements (can workaround that by -> $i, $j? but that's a digression)

[14:14] <disbot> <nahita3882> so with parens, I'd like to think of it as "okay give me 1 thing, and I want it destructured as what's in the parens"

[14:15] <disbot> <nahita3882> ($i, $j) wouldn't work though, since Pair is not Iterable to give its 2 components like that unlike a List

[14:23] <disbot> <simon_sibl> That makes a lot more sense, thank you Still have a lot to learn about those list xD still need to review how >> works also

[14:24] *** Sgeo joined
[14:24] <disbot> <simon_sibl> Destruction seems very nice, also need to learn more about it, I think I got it for the sub side but here I couldn‚Äôt see the key/value when doing say on it so I didn‚Äôt think about trying

[14:24] *** apac left
[14:27] *** melezhik joined
[14:36] *** perryprog left
[14:36] *** perryprog joined
[15:02] *** topnep joined
[15:27] <Voldenet> simon_sibl: re `+(.<submit> > $time)`: this translates to `is the job overdue already` - overdue jobs should get `0` (so their first "digit" in min is 0), non-overdue ones get `1`

[15:31] <Voldenet> but if you replace the cmp with `<=>`, overdue jobs will get -1, jobs that should start now will get `0` and non-overdue jobs will get 1, it changes the algorithm a bit I guess

[16:48] *** GreaseMonkey left
[16:48] *** greaser|q joined
[16:57] *** melezhik left
[17:31] *** bdju left
[18:05] *** bdju joined
[18:15] *** librasteve_ joined
[18:29] *** tgt joined
[18:30] <disbot> <librasteve> ~~

[18:31] *** tgt left
[18:48] *** topnep left
[18:49] *** topnep joined
[18:55] *** nort joined
[19:01] *** lichtkind left
[20:59] *** andinus left
[20:59] *** andinus joined
[21:22] *** Guest66 joined
[21:27] *** Guest66 left
[21:39] *** bdju left
[21:48] *** bdju joined
[22:17] *** greaser|q left
[22:17] *** greaser|q joined
[22:17] *** greaser|q is now known as GreaseMonkey

[22:30] *** Altreus left
[22:30] *** Altreus joined
[23:06] *** wayland left
[23:23] *** nort left
[23:30] *** stanrifkin_ left
[23:31] *** librasteve_ left
