[00:02] *** dg left
[00:03] *** librasteve_ left
[00:05] *** kaskal left
[00:05] *** kaskal joined
[00:13] *** dg joined
[00:25] *** ACfromTX left
[00:27] *** kjp left
[00:28] *** kjp joined
[00:30] *** kjp left
[00:31] *** kjp joined
[00:54] *** dg left
[01:00] *** dg joined
[01:12] *** vrurg joined
[01:12] *** vrurg_ left
[01:32] *** zetaaaa joined
[01:37] *** dgl joined
[01:40] *** dg left
[01:40] *** dgl is now known as dg

[01:49] *** hulk joined
[01:50] *** kylese left
[01:56] *** kylese joined
[01:57] *** vrurg_ joined
[01:57] *** hulk left
[01:57] *** vrurg left
[01:57] *** kaskal left
[01:58] *** kaskal joined
[01:58] *** kjp left
[01:59] *** kjp joined
[02:15] *** kylese left
[02:15] *** kylese joined
[02:42] *** arkiuat left
[02:45] *** zetaaaa left
[02:48] *** arkiuat joined
[02:53] *** arkiuat left
[02:54] *** arkiuat joined
[02:59] *** arkiuat left
[03:08] *** arkiuat joined
[03:17] *** ACfromTX joined
[03:19] *** dg left
[03:25] *** dg joined
[03:43] *** dgl joined
[03:48] *** dg left
[03:48] *** dgl left
[03:52] *** dg joined
[03:59] *** stanrifkin_ joined
[04:01] *** stanrifkin left
[04:25] *** dg left
[04:30] *** dg joined
[04:34] *** dg left
[04:44] *** dg joined
[05:12] *** Aedil joined
[05:19] *** dgl joined
[05:23] *** dg left
[05:23] *** dgl is now known as dg

[05:35] *** arkiuat left
[05:37] *** arkiuat joined
[05:45] *** arkiuat left
[05:55] *** dg left
[05:59] *** arkiuat joined
[05:59] *** kylese left
[06:00] *** dg joined
[06:00] *** kylese joined
[06:03] *** arkiuat left
[06:33] *** arkiuat joined
[06:38] *** arkiuat left
[06:54] *** Sgeo left
[07:09] *** arkiuat joined
[07:13] *** arkiuat left
[07:20] *** abraxxa joined
[07:33] *** arkiuat joined
[07:35] *** librasteve_ joined
[07:38] *** arkiuat left
[07:51] *** arkiuat joined
[07:54] <disbot5> <simon_sibl> is there an "easy" way in Raku to loop through an array indefinitely ? for example [1,2,3] to yield [1,2,3,1,2,3,1,2,3,1,2,3...]

[07:56] *** arkiuat left
[07:59] <disbot5> <nahita3882> m: (|[1, 2, 3] xx *).head(10).say

[08:00] <disbot5> <nahita3882> > (1 2 3 1 2 3 1 2 3 1)

[08:00] <disbot5> <nahita3882> so for |[1, 2, 3] xx * {...}

[08:01] <disbot5> <nahita3882> infinitely repeat the list and slip the contents to get flat 1, 2, 3, 1... stream

[08:01] <disbot5> <nahita3882> there is also third-party &Iter::Able::cycle with self-promotion

[08:02] <disbot5> <nahita3882> for cycle([1, 2, 3]) { ... }

[08:04] <disbot5> <nahita3882> interestingly the number of characters is the same in both if you do a parenthesesless call in the latter

[08:05] <disbot5> <simon_sibl> I dont see cycle sub anywhere, is it new ?

[08:06] <disbot5> <simon_sibl> oh third party my bad

[08:06] <disbot5> <simon_sibl> I like the |[1,2,3] xx *, thanks !

[08:06] <lizmat> actually, |(1,2,3) xx *    should marginally be more performant

[08:15] *** dakkar joined
[08:18] *** arkiuat joined
[08:23] *** arkiuat left
[08:50] *** arkiuat joined
[08:54] *** arkiuat left
[08:56] *** stanrifkin_ left
[09:07] *** melezhik_ joined
[09:08] <melezhik_> .

[09:15] *** melezhik_ left
[09:15] *** melezhik_ joined
[09:16] *** melezhik_ left
[09:19] *** arkiuat joined
[09:24] *** arkiuat left
[09:40] <disbot5> <librasteve> o/

[09:42] <disbot5> <librasteve> I am working on a proposal for Raku devroom participation at Fosdem 2026 ... depending on the time allocated we need 6 or 8 talks and, while the formal request for papers will happen if and when the room is granted, I would like to be able to position some of the topics that we can offer in the submission (due on Sunday 12th)

[09:43] <disbot5> <librasteve> The twenty-sixth edition will take place on Saturday 31st January and Sunday 1st February 2026 at the usual location, ULB Campus Solbosch in Brussels. This is a face to face event. And we are inviting speakers to come at your own expense.

[09:44] <disbot5> <librasteve> Please PM me (librasteve@furnival.net) if you are interested - ideally with a draft title and very short summary.

[09:52] *** arkiuat joined
[09:57] *** arkiuat left
[10:06] *** apac joined
[10:20] *** arkiuat joined
[10:25] *** arkiuat left
[10:52] *** arkiuat joined
[10:56] *** arkiuat left
[11:00] <ds7832> I'm trying to understand what the double semicolon does in multi signatures (https://docs.raku.org/language/signatures#Long_names): "exclude certain parameters from being considered in multiple dispatch" — From some trials it looks like this means that signatures with parameters after a double semicolon are "as narrow" as signatures without those parameters. Is that right? 

[11:08] <ab5tract> Looking at that example does not give much clarity. It uses a named param `:$b`, which would have dispatched exactly the same without `;;`

[11:08] <ds7832> I thought so too - just until now

[11:09] <ds7832> m: multi e(Int $i) { say "just $i" }; multi e(Int $i, Str :$s) { say "both $i and $s" }; e(42)

[11:09] <camelia> rakudo-moar 21dd9921d: OUTPUT: «Use of uninitialized value of type Str in string context.␤Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.␤both 42 and ␤  in sub e at <tmp> line 1␤»

[11:09] <ds7832> Whereas with ;; we get

[11:09] <ds7832> m: multi e(Int $i) { say "just $i" }; multi e(Int $i;; Str :$s) { say "both $i and $s" }; e(42)

[11:09] <camelia> rakudo-moar 21dd9921d: OUTPUT: «Ambiguous call to 'e(Int)'; these signatures all match:␤  (Int $i) from <tmp> line 1␤  (Int $i;; Str :$s) from <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:13] <ds7832> So in the first example what's going on is that the signature with $s is considered narrower than that with just 42 (fair enough), *and* it actually matches in the call e(42), but I don't recall exactly why that is

[11:20] <ds7832> So it seems that ;; reduces the "narrowness", and thus the precedence, of the signature, down to the level it would have if those parameters weren't present at all

[11:21] *** arkiuat joined
[11:23] <ds7832> However that interpretation of ;; is not fully consistent with another experiment:

[11:24] <ds7832> m: multi f(Int $a, Int $b;; Int $c){ say "would be narrower" }; multi f(Int $a;; Int $b, Int $c){ say "but this is considered equally narrow" }; f(1,2,3)

[11:24] <camelia> rakudo-moar 21dd9921d: OUTPUT: «Ambiguous call to 'f(Int, Int, Int)'; these signatures all match:␤  (Int $a, Int $b;; Int $c) from <tmp> line 1␤  (Int $a;; Int $b, Int $c) from <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:26] <ds7832> It apparently does work in the described way though if all parameters after ;; are named parameters.

[11:26] *** arkiuat left
[11:27] <ds7832> m: multi f(Int $a, Int :$b;; Int :$c){ say "more narrow" }; multi f(Int $a;; Int :$b, Int: $c){ say "less narrow" }; f(1,2,3)

[11:27] <camelia> rakudo-moar 21dd9921d: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Cannot put required parameter  after named parameters␤at <tmp>:1␤------> arrow" }; multi f(Int $a;; Int :$b, Int:<HERE> $c){ say "less narrow" }; f(1,2,3)␤    expecting any of:␤        formal paramete…»

[11:27] <ds7832> Uh, ignore that. This is what I meant:

[11:28] <ds7832> m: multi f(Int $a, Int :$b;; Int :$c){ say "more narrow" }; multi f(Int $a;; Int :$b, Int :$c){ say "less narrow" }; f(1,:2b,:3c)

[11:28] <camelia> rakudo-moar 21dd9921d: OUTPUT: «more narrow␤»

[11:29] <ds7832> The difference being that the first one (with "more narrow") has the parameter :$b before the double semicolon.

[11:46] <ds7832> Also in line with that: If in any of the above examples that threw "Ambiguous call" one adds the trait "is default" to either one of the multi definition, this definition then takes precedence. This actually seems like one of the most important use cases for ;;

[11:55] *** arkiuat joined
[12:00] *** arkiuat left
[12:10] <ab5tract> ds7832: would you consider adding any examples / clarifications you've gotten to the docs?

[12:11] <ds7832> Definitely, I'm writing on it :)

[12:22] *** arkiuat joined
[12:26] *** arkiuat left
[12:44] *** arkiuat joined
[12:55] <arkiuat> Now I'm wondering where and how the behavior of the double-semicolon ;; is tested in roast

[12:56] <arkiuat> To distinguish the language spec that should be documented from what might be unspecified implementation detail

[13:00] <disbot5> <librasteve> appreciate the help in ironing out this corner of the docs ... at first look at this section I am mystified why it is headed "Long Names" - I for one would be happy to change that, plus the example imo would be better with multiple multis to show both narrow and broad as you show ^^

[13:04] *** apac left
[13:09] *** apac joined
[13:23] <ds7832> arkiuat: Good question. Part of it here: https://github.com/Raku/roast/blob/master/S06-signature/multi-invocant.t -- i.e. the last two tests. Especially the last one indicates that there are different types of parameters, "positional multi" for positionals before ;;, and just "positional" for those after ;;.   So it's most likely that only "positional multi"s contribute to determining the precedence of multi, and that that's what'

[13:23] <ds7832> s behind the current phrasing in the docs.

[13:24] <ds7832> "multi-invocant" seems to be the technical name

[13:25] <arkiuat> ds7832, thanks! (both for finding that for me and for all the great work you've been doing on the docs lately)

[13:26] <ds7832> makes me happy to hear that! The work on the docs is also a good way to learn

[13:28] <arkiuat> yes it is!

[13:34] <arkiuat> for this bit, it would be helpful if you could refer to the doc for the .multi-invocant method, which belongs to class Parameter but hasn't been added yet (unless you just added it recently)

[13:36] <arkiuat> and I never would have known about the .multi-invocant method without looking at roast, because it's not mentioned anywhere in the https://docs.raku.org/language/signatures doc that you're working on

[13:42] <arkiuat> and the double-semicolons probably need to be at least mentioned in the "Parameter seperators" section up near the top of that doc you're working on

[13:44] <arkiuat> I'd add that myself but I wouldn't want to collide; maybe I'll add method .multi-invocant to class Parameter

[13:48] <ds7832> The top section, I already plan to put slurpies in there. That'll make it already quite long, so I'm mulling keeping the more advanced and less-needed things out of there: the "invocant marker" can probably just live in its own section (which comes right thereafter), and I think the ;; too is difficult to explain and at the same time seldom needed, much less than e.g. the required/optional markers ! and ?

[13:49] *** m6locks left
[13:49] <ds7832> which are good, intuitive, less-technical-to-explain alternatives for it, so I think it's good to have ;; far down at the bottom

[13:50] <ds7832> (yeah, that's good to avoid git collisions, thanks)

[13:52] <arkiuat> I literally meant that it just ought to be mentioned: a section labeled "Parameter separators" ought to at least mention all the possibilities. Like "For semicolon separators, see [[your-section-reference-here]] below."

[13:53] <arkiuat> I've started on my fork to add .multi-invocant to class Parameter's docs

[14:02] <ds7832> Ah, in the section "Parameter separators", sorry I misunderstood. Yeah, it should be mentioned there

[14:08] *** apac left
[14:17] *** apac joined
[14:39] <arkiuat> .tell tbrowder thanks for that Contributing-PRs.md doc of yours! I left a suggestion for you about it over on #raku-doc

[14:39] <arkiuat> hmm, is tellable offline?

[14:40] <disbot5> <librasteve> lemme try

[14:40] *** guifa left
[14:41] *** guifa joined
[14:43] <librasteve_> .tell arkuiat hello

[14:43] <librasteve_> .seen jnthn

[14:43] <librasteve_> m: say 0.1+0.2

[14:43] <camelia> rakudo-moar 21dd9921d: OUTPUT: «0.3␤»

[14:44] *** apac left
[14:44] <librasteve_> tall: arkuiat hello

[14:44] <librasteve_> tell: arkuiat hello

[14:44] <librasteve_> looks like some of the bots are offline...

[14:55] *** dg left
[14:57] *** apac joined
[15:01] <tbrowder> is there any magic way to parameterizs sub returns? i know this doesn't work: --> List of Str

[15:04] <tbrowder> m: sub F(--> List of Str) { my @w = "a", "b"; }

[15:04] <camelia> rakudo-moar 21dd9921d: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤List cannot be parameterized␤at <tmp>:1␤------> sub F(--> List of Str<HERE>) { my @w = "a", "b"; }␤»

[15:09] <librasteve_> m: sub fn(--> Array[Str]()) { <a b> }; say fn();

[15:09] <camelia> rakudo-moar 21dd9921d: OUTPUT: «[a b]␤»

[15:11] <librasteve_> tbrowder: a couple of things going on here (i) if you want to have a Positional that polices the types of its elements, then Array[Str] or Array[Int] can do that, while List does not have that power and (ii) then you can either be explicit in your code that you are making one of these, or you can apply the extra parens () to coerce your values into the desired type as in my example

[15:12] *** arkiuat left
[15:13] <Voldenet> coercing from Array to Array[Str] costs so it's cheaper to simply start with Array[Str] if possible

[15:14] <disbot5> <librasteve> well yes, but if speed is what you want then I suggest golang

[15:14] <disbot5> <librasteve> or rust

[15:14] <Voldenet> m: sub F(–> Array[Str]) { my Str @w = "a", "b" }; say F() # not overly verbose

[15:14] <camelia> rakudo-moar 21dd9921d: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> sub F(<HERE>–> Array[Str]) { my Str @w = "a", "b" };␤»

[15:14] <disbot5> <librasteve> ;-)

[15:14] <Voldenet> m: sub F(--> Array[Str]) { my Str @w = "a", "b" }; say F() # not overly verbose/

[15:14] <camelia> rakudo-moar 21dd9921d: OUTPUT: «[a b]␤»

[15:15] <disbot5> <librasteve> timtowdi

[15:15] <Voldenet> but why pay more if you can pay less

[15:15] <Voldenet> it's still a tradeoff

[15:17] <disbot5> <librasteve> now if this was Python we could spend a couple of hours telling each other they are wrong

[15:17] <Voldenet> ridiculous I could pull a benchmark ;p

[15:18] <disbot5> <librasteve> what about the zen dude

[15:20] *** human-blip left
[15:21] <Voldenet> ngl it's more significant than I thought https://0x0.st/Ku1u.raku

[15:21] <Voldenet> and with only 2-element array

[15:22] <Voldenet> what I'm benchmarking is ram though, it's pointless

[15:22] *** human-blip joined
[15:23] <Voldenet> I agree that I'd pick the coercing syntax if I had to pick one myself

[15:23] <Voldenet> other version feels redundant and it makes my head itch wrong

[15:24] *** arkiuat joined
[15:24] <Voldenet> in the perfect world the compiler could easily say that @w gets returned and nothing uses this copy, so it could avoid allocation… ;)

[15:28] *** arkiuat left
[15:43] *** arkiuat joined
[15:46] *** snonux left
[15:48] *** arkiuat left
[15:48] *** snonux joined
[15:50] *** arkiuat joined
[16:10] *** apac left
[16:37] *** dakkar left
[17:17] *** stanrifkin joined
[17:21] <tonyo> .

[17:47] <tbrowder> thnx gang

[17:57] *** melezhik joined
[18:35] *** librasteve_ left
[18:43] *** AntonOks joined
[18:43] *** arkiuat left
[18:50] *** arkiuat joined
[18:54] *** AntonOks left
[18:54] *** arkiuat left
[19:07] *** arkiuat joined
[19:12] *** arkiuat left
[19:29] *** apac joined
[19:31] *** arkiuat joined
[19:37] *** snonux left
[19:38] *** snonux joined
[20:07] *** melezhik left
[20:30] *** kylese left
[20:45] *** sourceable6 left
[20:45] *** nativecallable6 left
[20:45] *** notable6__ left
[20:45] *** benchable6 left
[20:45] *** greppable6 left
[20:45] *** unicodable6 left
[20:45] *** evalable6 left
[20:45] *** committable6 left
[20:48] *** evalable6 joined
[20:48] *** unicodable6 joined
[20:48] *** linkable6 joined
[20:48] *** bloatable6 joined
[20:48] *** benchable6 joined
[20:49] *** bisectable6 joined
[20:49] *** tellable6 joined
[20:49] *** greppable6 joined
[20:49] *** releasable6 joined
[20:49] *** coverable6 joined
[20:49] *** shareable6 joined
[20:49] *** notable6 joined
[20:49] *** quotable6 joined
[20:49] *** nativecallable6 joined
[20:50] *** committable6 joined
[20:50] *** sourceable6 joined
[21:58] *** stanrifkin left
[22:43] *** zetaaaa joined
[23:25] *** apac left
[23:44] *** Sgeo joined
[23:55] *** Aedil left
