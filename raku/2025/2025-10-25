[00:53] *** Aedil joined
[01:16] *** hulk joined
[01:16] *** kylese left
[01:29] *** sibl joined
[01:53] *** sibl left
[02:01] *** Sgeo_ left
[02:01] *** Sgeo joined
[02:15] *** hulk left
[02:15] *** kylese joined
[02:21] *** arkiuat left
[02:28] *** arkiuat joined
[02:38] *** stanrifkin left
[02:39] *** stanrifkin joined
[02:51] *** hulk joined
[02:52] *** kylese left
[03:14] <disbot1> <aruniecrisps> @SmokeMachine Wanted to see whether I could make a PR to amend the README for Red to also indicate that you may need to add -exclude="pq:ver<5>:from<native>" when installing Red

[03:53] *** stanrifkin_ joined
[03:55] *** stanrifkin left
[04:22] *** Aedil left
[04:28] *** stanrifkin joined
[04:30] *** stanrifkin_ left
[04:52] *** Aedil joined
[05:13] *** arkiuat left
[05:15] *** arkiuat joined
[05:21] *** arkiuat left
[05:34] *** arkiuat joined
[05:41] *** arkiuat left
[05:53] *** arkiuat joined
[06:01] *** camelia joined
[06:02] *** arkiuat left
[06:02] *** LainIwakura left
[06:15] *** melezhik joined
[06:15] <melezhik> .

[06:15] *** arkiuat joined
[06:19] *** arkiuat left
[06:48] *** arkiuat joined
[06:54] *** arkiuat left
[06:56] *** arkiuat joined
[07:00] *** arkiuat left
[07:12] *** arkiuat joined
[07:17] *** arkiuat left
[07:21] <SmokeMachine> aruniecrisps: sure, please do it!

[07:30] *** arkiuat joined
[07:32] *** Aedil left
[07:56] *** arkiuat left
[07:57] *** arkiuat joined
[08:01] *** arkiuat left
[08:13] *** arkiuat joined
[08:22] *** arkiuat left
[08:22] *** melezhik left
[08:23] *** LainIwakura joined
[08:29] *** mimosa joined
[08:32] *** ACfromTX left
[08:49] *** arkiuat joined
[08:54] *** arkiuat left
[09:01] *** Sgeo left
[09:09] *** arkiuat joined
[09:13] *** arkiuat left
[09:16] *** lichtkind_ joined
[09:23] *** melezhik joined
[09:23] <melezhik> .

[09:24] <melezhik> If someone wish to participate in brownie demo - here is information - https://irclogs.raku.org/raku-dev/2025-10-24.html#09:05 , thanks üôè

[09:27] *** sftp joined
[09:27] *** sftp left
[09:27] *** sftp joined
[09:42] *** arkiuat joined
[09:47] *** arkiuat left
[09:57] *** Guest15 joined
[09:57] *** Guest15 left
[10:15] *** arkiuat joined
[10:19] *** arkiuat left
[10:47] *** arkiuat joined
[10:52] *** arkiuat left
[11:17] *** arkiuat joined
[11:24] *** arkiuat left
[11:43] *** arkiuat joined
[11:48] *** arkiuat left
[11:58] <melezhik> .

[12:01] *** arkiuat joined
[12:06] *** arkiuat left
[12:20] *** arkiuat joined
[12:26] *** arkiuat left
[13:00] *** arkiuat joined
[13:10] *** apa_c joined
[13:15] *** melezhik_ joined
[13:26] *** melezhik_ left
[13:28] *** melezhik_ joined
[13:56] *** melezhik_ left
[14:01] *** melezhik_ joined
[14:06] *** melezhik_ left
[14:19] *** apa_c left
[14:21] *** apa_c joined
[14:38] *** ACfromTX joined
[14:44] *** apa_c left
[15:03] <disbot1> <.landyacht.> I'm trying to design a threadpool that handles a mix of future-scheduled and ASAP jobs. My current thought is to have two queues, one for work ready to be performed which the worker threads read from, and one for future jobs that a coordinator thread reads from and moves them to the former queue at the appropriate time. My idea is, if the soonest scheduled job say, n seconds away, to have the coordinator queue sleep n seconds

[15:03] <disbot1> and then do its thing. But I need some way to "wake" that thread if another future-scheduled job comes in, say, n - 1 seconds away...

[15:03] <disbot1> <.landyacht.> the coordinator thread*

[15:04] <disbot1> <.landyacht.> is there a mechanism in Raku to sleep a thread but be able to wake it sooner?

[15:05] <disbot1> <.landyacht.> or will I just need to decide on a time resolution at which the coordinator thread will check regardless of when the soonest job is scheduled

[15:05] *** Aedil joined
[15:16] <disbot1> <rcmlz> Is that perhaps something than can use - instead of sleep - something like this: https://rosettacode.org/wiki/IPC_via_named_pipe#Raku

[15:24] *** Romanson joined
[15:24] <disbot1> <.landyacht.> react/whenever might well come in handy.. not sure, might need to rework my approach entirely

[15:40] *** LainIwakura left
[15:58] *** vasko453 left
[15:58] *** vasko4535 joined
[16:02] *** ds7832 joined
[16:02] *** melezhik_ joined
[16:05] *** melezhik_ left
[16:17] *** LainIwakura joined
[16:19] *** melezhik_ joined
[16:21] *** LainIwakura left
[16:25] *** LainIwakura joined
[16:28] *** melezhik_ left
[16:28] *** melezhik_ joined
[16:31] *** ds7832 left
[16:33] *** melezhik left
[16:34] *** LainIwakura left
[16:39] *** LainIwakura joined
[16:40] *** apa_c joined
[16:44] *** melezhik joined
[16:46] *** melezhik_ left
[16:59] *** ds7832 joined
[17:04] <disbot1> <rcmlz> using ‚Äûbussy wait‚Äú-approaches feels so 90‚Äòs üòÄ

[17:07] <disbot1> <rcmlz> Perhaps the whole thing can be designed entirely without file system (and thus OS specific) events - just is case you aim for Windows & Linux users ‚Ä¶

[17:08] <disbot1> <rcmlz> and still not use bussy waiting

[17:41] *** hulk left
[17:41] *** kylese joined
[17:44] *** apa_c left
[17:52] *** melezhik_ joined
[17:52] *** melezhik_ left
[17:58] *** arkiuat left
[18:09] *** arkiuat joined
[18:10] <disbot1> <m_zero> Have the coordinator thread wait on a semaphore - when it triggers, it evaluates the current queue, moves jobs to be done to the ready queue, and launches a thread that: wakes in n seconds (the soonest job in the waiting queue) then signals the semaphore.  If when some other code puts something on the waiting queueu - just signal the semaphore and let the coordinator sort it out. The idea here is that waking the coordinator is

[18:10] <disbot1> always safe - it just looks at the state of the queues and adjusts.  If it ends up setting off extra timers (like if something comes in that is to be done sooner than the previous next task) - that's okay.

[18:11] *** avuserow_ is now known as avuserow

[18:13] <disbot1> <.landyacht.> Ahhh that‚Äôs a very clever solution, I think that will work for what I want. Thanks!

[18:15] *** arkiuat left
[18:26] *** arkiuat joined
[18:35] <Voldenet> busy wait solution is actually used for spinlocks though

[18:35] <Voldenet> it is a good solution if lock/monitor isn't held for very long

[18:35] *** Romanson left
[18:37] <Voldenet> if you simply want it to work, plain locks are good enough, you might get a bit clever and use Lock.condition (which I think uses uv_cond_wait underneath, but I'm not sure)

[18:38] <Voldenet> it removes need for busy loop

[18:49] *** Sgeo joined
[18:50] <Voldenet> rough example of basic thread pool https://0x0.st/K2VR.raku

[19:04] *** corwin is now known as pii

[19:05] <Voldenet> with some random waits you can see that it's more or less fair https://0x0.st/K2Wz.raku

[19:05] *** apa_c joined
[19:05] <Voldenet> (as they should, since only idle tasks are waiting for items)

[19:06] <Voldenet> I'm deliberately not using .join or more primitives to highlight the conditional variables, which are incredibly useful for this specific case

[19:19] *** Guest70 joined
[19:33] *** melezhik left
[19:35] *** pii is now known as corwin

[19:35] *** corwin is now known as pii

[19:37] <Guest70> When using map, is there a way to get the index?

[19:41] <Guest70> For example, in Javascript, the map callback gets up to three arguments: the data element, its index within the sequence, and the full sequence.

[19:41] <Guest70> Failing that, is there a way to define a map-like operator that does get the index?

[19:43] <mc2> Guest70: < a b c >.kv.map: {¬†say "$^k = $^v" }

[19:44] <mc2> Guest70: < a b c >.pairs.map: {¬†say "{.key} = {.value}" }

[19:45] <Guest70> Thanks

[19:46] <mc2> you're welcome

[19:47] *** LainIwakura left
[19:55] *** Geth left
[20:45] *** librasteve_ joined
[21:00] *** apa_c left
[21:02] *** mimosa left
[21:10] *** kylese left
[21:44] *** Aedil left
[22:16] *** arkiuat left
[22:28] *** arkiuat joined
[22:35] *** arkiuat left
[22:46] *** lichtkind_ left
[22:49] *** tailgate left
[22:50] *** tailgate joined
[22:52] *** ds7832 left
[22:52] *** arkiuat joined
[22:57] *** arkiuat left
[23:09] *** arkiuat joined
[23:11] *** Geth joined
[23:16] *** arkiuat left
[23:21] *** arkiuat joined
