[00:00] *** Manifest0 left
[00:01] <grondilu> it cannot use the comparison I defined in A?

[00:02] <discord-raku-bot> <nemokosch> hmm

[00:03] <grondilu> If it can't, it means I can't reuse any sub defined in Real??

[00:03] <discord-raku-bot> <nemokosch> m: class A does Real { }; multi sub infix:¬´<¬ª(A, 0) { Bool.pick }; multi sub prefix:<->(A) { rand }; say A.new.abs

[00:03] <discord-raku-bot> <Raku eval>  

[00:03] <discord-raku-bot> <nemokosch> that's not much...

[00:04] <discord-raku-bot> <nemokosch> oh right, your candidate was probably wrong

[00:04] <discord-raku-bot> <nemokosch> I don't like this whole mishmash with types as sometimes types, sometimes values

[00:05] <grondilu> m: class A does Real { }; multi sub infix:¬´<¬ª(A, 0) { Bool.pick }; multi sub prefix:<->(A) { rand }; say A.new.abs

[00:05] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´MoarVM panic: Memory allocation failed; could not allocate 131072 bytes‚ê§¬ª

[00:05] <discord-raku-bot> <nemokosch> m: class A does Real { }; multi sub infix:¬´<¬ª(A, 0) { say 'Actually executed'; Bool.pick }; say A < 0;

[00:05] <discord-raku-bot> <Raku eval>  Actually executed True 

[00:05] *** merp left
[00:05] <discord-raku-bot> <nemokosch> m: class A does Real { }; multi sub infix:¬´<¬ª(A, 0) { say 'Actually executed'; Bool.pick }; say A.new < 0;

[00:05] <discord-raku-bot> <Raku eval>  Actually executed True 

[00:05] <discord-raku-bot> <nemokosch> but it does run for an instance as well ü•π

[00:06] <discord-raku-bot> <nemokosch> m: class A does Real { method Bridge {...} }; multi sub infix:¬´<¬ª(A, 0) { say 'Actually executed'; Bool.pick }; say A.new < 0;

[00:06] <discord-raku-bot> <Raku eval>  Actually executed True 

[00:07] <grondilu> m: wth

[00:07] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    wth used at line 1‚ê§‚ê§¬ª

[00:07] *** merp joined
[00:07] <tonyo> haha

[00:07] <grondilu> wait the difference is just the multi?

[00:08] <discord-raku-bot> <nemokosch> m: class A does Real { method Bridge {...} }; multi sub infix:¬´<¬ª(A, 0) { say 'Actually executed'; Bool.pick }; multi sub prefix:<->(A) { say 'Unary minus also executed...'; rand };  say -A.new

[00:08] <discord-raku-bot> <Raku eval>  Unary minus also executed... 0.10870624375577653 

[00:08] <grondilu> no it's not

[00:08] <discord-raku-bot> <nemokosch> m: class A does Real { method Bridge {...} }; multi sub infix:¬´<¬ª(A, 0) { say 'Actually executed'; Bool.pick }; multi sub prefix:<->(A) { say 'Unary minus also executed...'; rand };  say A < 0 ?? -A !! A;

[00:08] <discord-raku-bot> <Raku eval>  Actually executed Unary minus also executed... 0.3647369977724271 

[00:08] <grondilu> I don't see the difference with what I wrote earlier

[00:09] <discord-raku-bot> <nemokosch> right...

[00:09] <grondilu> m: class A does Real { method Bridge {...} }; multi sub infix:¬´<¬ª(A, 0) { Bool.pick }; multi sub prefix:<->(A) { rand }; say A.new.abs

[00:09] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´Stub code executed‚ê§  in method Bridge at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[00:09] <discord-raku-bot> <nemokosch> m: class A does Real { method Bridge {...} }; multi sub infix:¬´<¬ª(A, 0) { say 'Actually executed'; Bool.pick }; multi sub prefix:<->(A) { say 'Unary minus also executed...'; rand };  my $v = A.new; say $v < 0 ?? -$v !! $v;

[00:09] <discord-raku-bot> <Raku eval>  Actually executed Unary minus also executed... 0.5301130943966046 

[00:09] <discord-raku-bot> <nemokosch> so if you hardcode everything, it works

[00:09] <discord-raku-bot> <nemokosch> if you want to reuse code

[00:09] <discord-raku-bot> <nemokosch> which supposedly roles are for

[00:10] <discord-raku-bot> <nemokosch> m: class A does Real { method Bridge {...} }; multi sub infix:¬´<¬ª(A, 0) { say 'Actually executed'; Bool.pick }; multi sub prefix:<->(A) { say 'Unary minus also executed...'; rand };  my $v = A.new; say $v.abs

[00:10] <discord-raku-bot> <Raku eval>  Exit code: 1 Stub code executed   in method Bridge at main.raku line 1   in block <unit> at main.raku line 1  

[00:10] <discord-raku-bot> <nemokosch> then it doesn't work

[00:11] <discord-raku-bot> <nemokosch> I see two possible explanations. Either it can't see the dynamic type of self, which would make it completely useless

[00:11] <grondilu> ok I see now.  so in the end, no, I can't reuse the abs code, because it refers to sub calls

[00:12] <discord-raku-bot> <nemokosch> or it cannot see the global multi definitions

[00:12] <discord-raku-bot> <nemokosch> indeed, the latter is much more probable, and it kinda rings a bell

[00:12] <grondilu> my guess is it does not see the global multi

[00:12] <discord-raku-bot> <nemokosch> the same way sort won't take your own cmp operator into account

[00:13] <discord-raku-bot> <nemokosch> it could be made work but it's overhead and there was some controversy

[00:13] <grondilu> is it correct semantics, though?  It should be basic but I actually don't know enough about OOP to know.

[00:15] <grondilu> m: role A { sub foo {...}; method bar { foo() } }; say class B does A { sub foo { "B::foo!" }; }.bar

[00:15] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´Stub code executed‚ê§  in sub foo at <tmp> line 1‚ê§  in method bar at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[00:15] <grondilu> ^here for instance is A::bar suppose to call B::foo?

[00:16] <grondilu> *supposed

[00:16] <discord-raku-bot> <nemokosch> I think this is completely different from the operators, and here I think you are right

[00:16] <grondilu> well operators are just subroutines with special syntax

[00:16] <discord-raku-bot> <nemokosch> m: role A { sub foo {...}; method bar { foo() } }; say class B does A { sub foo { "B::foo!" }; }.foo

[00:16] <discord-raku-bot> <Raku eval>  Exit code: 1 No such method 'foo' for invocant of type 'B'   in block <unit> at main.raku line 1  

[00:17] <discord-raku-bot> <nemokosch> wait, why was it a sub?

[00:17] <discord-raku-bot> <nemokosch> of course the method wouldn't dispatch to a sub in a random different scope

[00:17] <grondilu> is it obvious?  not to me.

[00:18] <discord-raku-bot> <nemokosch> what does it even mean for a class or a role to contain a sub?

[00:18] <grondilu> it's in its lexical scope?

[00:19] <discord-raku-bot> <nemokosch> most probably

[00:19] <discord-raku-bot> <nemokosch> and I wouldn't expect scopes to have anything to do with method resolution rules

[00:20] <grondilu> I mean lately I've been learning how to use dynamic variables, so I may be starting to hope to do something similar with subs.

[00:20] <discord-raku-bot> <nemokosch> why would a simple local sub resolution turn into some method resolution mechanism

[00:21] <grondilu> the point is anyway that using subs in a role, and inside its methods, kind of ruins the purpose of roles since we can't reuse these sub calls.

[00:21] <grondilu> or rather redispatch them if that makes sense

[00:23] <grondilu> like this abs method: it relies on infix:<-> and prefix:<->, but I have no way to modify how these work and apply it to abs.  I have to rewrite it all.

[00:23] <discord-raku-bot> <nemokosch> I think it's kinda different because in the operator case you didn't even scope the operator, it was in the mainline. Now, if not even the mainline is visible to the called core code, what is?

[00:24] <grondilu> *infix:¬´<¬ª

[00:24] <grondilu> I don't know what is what you call the mainline

[00:26] <grondilu> If abs had been written with only method calls :  method abs { self.less-than(0) ?? self.negate !! self }, I could re-use it.

[00:26] <discord-raku-bot> <nemokosch> that's right

[00:27] <discord-raku-bot> <nemokosch> honestly, I also don't know why it would be so difficult to add actual syntax to retrieve a method of a class, rather than doing metamodel hackery

[00:28] <discord-raku-bot> <nemokosch> it feels like a lot of effort is duplicated with functions and methods and the differences are too big

[00:30] <discord-raku-bot> <nemokosch> I'm almost certain an operator-driven approach would work in C++ and it would definitely work in Python where operators are really methods

[00:32] <discord-raku-bot> <vendethiel> Some are, but then‚Ä¶

[00:32] <discord-raku-bot> <vendethiel> These have a predefined set of operators

[00:35] <discord-raku-bot> <nemokosch> the question is, is this really a good tradeoff?

[00:36] <discord-raku-bot> <nemokosch> do you want to rather use new arbitrary operators in your own code and be unable to reuse existing operators when interacting with other code, or give up on the arbitrary operators while retaining the composability for the existing ones?

[00:37] <discord-raku-bot> <nemokosch> sounds like the usual weak typing vs strong/duck typing dichotomy

[00:37] <grondilu> Is this really weak typing?  We're still in the same branch of the inheritance tree.

[00:38] <discord-raku-bot> <nemokosch> the inheritance tree did nothing here, as we can see...

[00:39] <grondilu> because subs are not part of it

[00:39] <discord-raku-bot> <nemokosch> the subs we care about are global anyway

[00:40] <grondilu> why couldn't I overload them, then?

[00:40] <discord-raku-bot> <vendethiel> Scala mangles the name of your operators

[00:40] <discord-raku-bot> <nemokosch> because the core has a limited global scope compared to your own code

[00:40] <discord-raku-bot> <vendethiel> No it‚Äôs the usual expression problem

[00:41] <discord-raku-bot> <nemokosch> basically it's a scope registered into your global scope

[00:41] <discord-raku-bot> <nemokosch> it's mainly an interface problem

[00:42] <discord-raku-bot> <nemokosch> the principle that you should reserve existing operators with their existing behavior and provide clever coercions for your data types if you want to use them, and if you don't like the behavior, just ditch them and define new operators

[00:42] <discord-raku-bot> <vendethiel> no

[00:42] *** ProperNoun joined
[00:42] *** deoac left
[00:42] <discord-raku-bot> <nemokosch> this is basically the weak typing Raku worked out based on Perl

[00:42] *** deoac joined
[00:43] *** rf left
[00:43] <discord-raku-bot> <nemokosch> and it works well as long as the vast majority of your operations are carried out on common types only

[00:43] <discord-raku-bot> <nemokosch> probably that's why it worked so well for Perl

[00:44] <discord-raku-bot> <nemokosch> however, for more general purpose programming, you will define your own types much more often than new operations for the existing common types

[00:45] <discord-raku-bot> <nemokosch> and that's where reusing the same structural interfaces is not a curse but a necessity and a blessing

[00:46] <grondilu> when it works

[00:46] *** vrurg left
[00:46] <discord-raku-bot> <nemokosch> the irony is that the coercions that power the weak typing system also couldn't work without such common interfaces, like the .Typename methods for Raku

[00:47] *** vrurg joined
[00:47] * grondilu goes to sleep

[00:48] <discord-raku-bot> <nemokosch> good night

[01:02] *** ProperNoun left
[01:03] *** ProperNoun joined
[01:19] *** rf joined
[02:00] *** deoac left
[02:22] *** edr left
[02:44] *** Sgeo left
[02:44] *** Sgeo_ joined
[02:46] *** Xliff joined
[02:47] <Xliff> What's the best way to re-export a symbol when you are already exporting a bunch using "is export"?

[05:43] *** sena_kun joined
[07:35] <grondilu> Xliff: I was told some time ago to define EXPORT before declaring the module: https://discord.com/channels/538407879980482560/538420565980086273/1059178244647170049

[07:51] *** jpn left
[08:02] *** lichtkind joined
[08:09] <Xliff> grondilu: What's at that link? I generally don't do discord because it litters accounts!

[08:09] <Xliff> And I am now getting the dreaded "Message failed to load" error.

[08:10] <Xliff> grondilu: Can you please port the important bits of that somewhere I can view it? Thank.s

[08:13] *** Sgeo_ left
[08:15] *** dakkar joined
[08:15] *** Manifest0 joined
[08:19] <lizmat> the EXPORT sub needs to be outside of any package in the compunit

[08:19] <lizmat> example of exporting "ok" from Test:

[08:20] <lizmat> use Test;

[08:20] <lizmat> sub EXPORT() { Map.new: ('&ok' => &ok) }

[08:21] <Xliff> Does that also work for a compunit that is already exporting things? In that example, would anything else marked "is export" also be exported or only &ok?

[08:23] <lizmat> only ok in that case: the EXPORT sub overrides

[08:23] <Xliff> OK. How can I write one to preserve the existing exports

[08:26] <lizmat> by walking EXPORT::DEFAULT::.keys

[08:26] <lizmat> m: sub foo() is export { }; dd EXPORT::DEFAULT::.keys

[08:26] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´("\&foo",).Seq‚ê§¬ª

[08:27] <Xliff> Or would this work?

[08:28] <Xliff> sub EXPORT() { Map.new: ( '&ok', |Module::EXPORT::DEFAULT::.pairs ) }

[08:29] <Xliff> Err... that would be...

[08:29] <Xliff> sub EXPORT() { Map.new: ( '&ok' => &ok, |Module::EXPORT::DEFAULT::.pairs ) }

[08:30] <lizmat> without the Module:: I think

[08:30] <lizmat> that's the whole point: the export is done by the compunit, *not* any other package

[08:36] <Xliff> lizmat: OK, so I would have to do that inside the module and publish it via some data structure.

[08:36] <Xliff> m: package A { sub a is export { 42; }; A::EXPORT::DEFAULT::.keys

[08:36] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> xport { 42; }; A::EXPORT::DEFAULT::.keys‚èè<EOL>‚ê§    expecting any of:‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifier loo‚Ä¶¬ª

[08:36] <lizmat> the publishing is done by the EXPORT sub by what it returns in the Map

[08:37] <Xliff> m: package A { sub a is export { 42; }; }; A::EXPORT::DEFAULT::.keys.gist.say

[08:37] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´(&a)‚ê§¬ª

[08:37] <Xliff> Actually...that works well enough.

[08:37] <lizmat> m: package A { sub a is export { 42; }; }; EXPORT::DEFAULT::.keys.gist.say

[08:37] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´(&a)‚ê§¬ª

[08:37] <lizmat> not sure why it is in both

[08:38] <Xliff> Well... not a real compunit, yeah?

[08:38] <lizmat> whatever you put in m:   is a compunit

[08:38] <lizmat> anything inside an EVAL is a compunit

[08:39] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |EXPORT::DEFAULT::.pairs ) }; 

[08:39] <camelia> rakudo-moar 7dc21fcff: ( no output )

[08:39] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |EXPORT::DEFAULT::.pairs ) };  EXPORT::dEFAULT::.keys.gist.say

[08:39] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´Could not find symbol '&dEFAULT' in 'EXPORT'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[08:39] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |EXPORT::DEFAULT::.pairs ) };  EXPORT::DEFAULT::.keys.gist.say

[08:39] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´(&a)‚ê§¬ª

[08:40] <Xliff> Hmmm...

[08:40] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  EXPORT::DEFAULT::.keys.gist.say

[08:40] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´(&a)‚ê§¬ª

[08:40] <lizmat> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  dd EXPORT()

[08:41] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Target type too complex to form a coercion type‚ê§at <tmp>:1‚ê§------> XPORT::DEFAULT::.pairs ) };  dd EXPORT()‚èè<EOL>‚ê§¬ª

[08:41] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  EXPORT().gist.say

[08:41] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Target type too complex to form a coercion type‚ê§at <tmp>:1‚ê§------> ::EXPORT::DEFAULT::.pairs ) };  EXPORT()‚èè.gist.say‚ê§¬ª

[08:41] <lizmat> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  dd EXPORT

[08:41] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´EXPORT‚ê§¬ª

[08:41] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  EXPORT.gist.say

[08:41] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´(EXPORT)‚ê§¬ª

[08:41] <lizmat> hmmm

[08:41] <lizmat> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  dd &EXPORT()

[08:41] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´Map.new(("\&a" => sub a { #`(Sub|6111105622400) ... },"\&ok" => sub ok { #`(Sub|6111105622784) ... }))‚ê§¬ª

[08:41] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new( '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  &EXPORT().gist.say

[08:41] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´Map.new((&a => &a, &ok => &ok))‚ê§¬ª

[08:41] <Xliff> Aha!

[08:42] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new: '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs ) };  &EXPORT().gist.say

[08:42] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´===SORRY!=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> ok' => &ok, |A::EXPORT::DEFAULT::.pairs ‚èè) };  &EXPORT().gist.say‚ê§    expecting any of:‚ê§        statement end‚ê§        statement modifier‚ê§        sta‚Ä¶¬ª

[08:42] <Xliff> m: sub ok { "ok!" }; package A { sub a is export { 42; }; }; sub EXPORT { Map.new: '&ok' => &ok, |A::EXPORT::DEFAULT::.pairs  };  &EXPORT().gist.say

[08:42] <camelia> rakudo-moar 7dc21fcff: OUTPUT: ¬´Map.new((&a => &a, &ok => &ok))‚ê§¬ª

[08:43] <Xliff> Hmm.... that extra set of parents is looking at me suspiciously!

[08:49] <lizmat> no, it's needed to disambiguate from named arguments to a list of pairs

[08:50] <lizmat> otherwise the Map.new will silently eat any named args and create an empty Map (in most cases)

[09:00] <Xliff> Ah, OK. Well, it's a starting place. Thanks, lizmat!

[09:20] *** jpn joined
[09:21] *** cm left
[10:19] * lizmat clickbaits https://rakudoweekly.blog/2023/09/25/2023-39-releaseses/

[10:46] <Xliff> \o/ -- My name in text!

[11:09] <sjn> lizmat++ # keeping up the weeklies

[11:09] * sjn enjoys reading them at least :-D

[11:11] <lizmat> sjn: always good to hear  :-)

[11:53] <sjn> btw, who cares about https://github.com/Raku/vim-raku ?

[11:53] <sjn> I've had a pull request there for looong while now

[11:54] <sjn> zostay: ^

[11:54] <lizmat> sjn: maybe you want a commit bit ?

[11:55] <sjn> The PR is mostly for my QoL, and a nuisance which is trivial to fix

[11:55] <sjn> Not sure if I'm competent at vimrc to do anything useful

[11:55] <Geth> ¬¶ vim-raku: 84a65c415f | (Salve J. Nilsen)++ (committed using GitHub Web editor) | .gitignore

[11:55] <Geth> ¬¶ vim-raku: doc/tags is generated, so let's ignore it (#30)

[11:55] <Geth> ¬¶ vim-raku: 

[11:55] <Geth> ¬¶ vim-raku: When loading this vim package, a tags file may be generated in

[11:55] <Geth> ¬¶ vim-raku: the doc directory. Let's not track it in git! This is so we the

[11:55] <Geth> ¬¶ vim-raku: checked-out repository (or submodule) stays "clean"

[11:55] <Geth> ¬¶ vim-raku: review: https://github.com/Raku/vim-raku/commit/84a65c415f

[11:56] <sjn> oh, thanks :-D

[11:56] <lizmat> yw

[12:07] <Xliff> Oh! Nice name, sjn!

[12:11] <sjn> Xliff: huh? which name?

[12:11] *** jgaz joined
[12:11] <Xliff> Yours. :)

[12:12] <sjn> ah. it's an old Norwegian name. pretty rare (70-ish in .no who has it as a first name)

[12:12] <sjn> not really related to italian or latin words :-)

[12:12] <El_Che> it sounds latin

[12:13] <sjn> there's the latin word "Salve" which basically means "Greetings" or "Hello"

[12:13] <sjn> kinda-formal meaning, I think

[12:13] <El_Che> as long as you don't accompany it with the arm greeting

[12:13] <El_Che> :)

[12:13] <sjn> but that's not a name :)

[12:13] <Xliff> :)

[12:15] <sjn> El_Che: when introducing myself, I actually say my name, so <confusion ensues among latin-speakers and italians> :-D

[12:15] <El_Che> hehe

[12:15] <El_Che> salve, morituri te salutant!

[12:17] <sjn> El_Che: dramatically different translation with and without "salve" on google :-D

[12:17] <sjn> "Hello, they are dying to greet you" 

[12:23] <discord-raku-bot> <nemokosch> Servus salvus

[12:25] <discord-raku-bot> <sjoshuan> @nemokosch o/ üòÅ

[12:25] <discord-raku-bot> <nemokosch> üëÄ

[12:26] <sjn> sjn = sjn üá≥üá¥ on discord

[12:29] <discord-raku-bot> <nemokosch> Flagged user? ^^

[12:33] *** derpydoo joined
[12:35] <El_Che> sjn: google would fail a Latin exam :)

[12:50] *** grondilu left
[12:51] <El_Che> sjn: I help may daughter with the translations for her exams and I was surprised how bad google translate was for latin. You would think that they have enough conclusive data of a dead language to feed their AI monster :)

[12:51] <discord-raku-bot> <nemokosch> Latin exams? What is the context?

[12:52] <El_Che> high school

[12:52] <El_Che> or middle school in the usa

[12:53] <discord-raku-bot> <nemokosch> We were quite the weirdos to learn Latin at high school around here, in return, we almost always had good national results. I think even I made it to the top 10 once but one of my classmates made it to Italy, he was first or maybe second

[12:53] <El_Che> it's a pretty popular study choice around here, resulting in one of the highest succes rates for university later all over the board, including the sciences

[12:54] <El_Che> Latin is pretty mainstream here

[12:54] <discord-raku-bot> <nemokosch> It was great because you never really had to learn vocabulary xD

[12:55] <El_Che> hehe

[12:55] <discord-raku-bot> <nemokosch> Lots of math and science folks performed well on these translation competitions, it was a good coupling, you mostly just needed essential grammar and logic

[12:56] <El_Che> yeah, that's why latin high school pupils score well on science as well

[12:57] <El_Che> but there is also the matter of cause and correlation 

[12:58] <El_Che> here, only good students choose Latin as their core study. In the beginning there are many, at the end a lot less. So there is a selection there

[12:58] <El_Che> people that study ancient greek or mathematics do also well on university

[12:58] <El_Che> (in general of course)

[12:58] <El_Che> *in

[13:01] <discord-raku-bot> <nemokosch> Yes, I wonder what this correlation means under the hood, what does it tell us

[13:03] <El_Che> That challenging good students pays off, but we don't have to be 

[13:04] <El_Che> fetishist about the subject themselves (hallo elitists thinking ancient languages is the only way to go or that STEM is the only thing that matters)

[13:05] <El_Che> and that we can't build an education system around elitism, so we need to make it wide enough so people can learn and have fun 

[13:05] <El_Che> 2c :)

[13:06] <El_Che> In my neck of the wood there is a history of elitism in education (of course not on the US levels, that's another level of crazy)

[13:07] <El_Che> sadly the very active STEM proponents aren't any better and just do a quick s/.+/STEM/g

[13:07] <El_Che> :)

[13:08] <discord-raku-bot> <nemokosch> Education itself is kind of intertwined with elitism, which is not to say "back to monke" but it's not surprising it will peek in here and there

[13:09] <discord-raku-bot> <nemokosch> It's also kind of acquired knowledge, so to speak

[13:09] <El_Che> I think the Scandinavian countries are better structured on that subject, at least finland

[13:21] *** rf left
[13:45] <jdv> any idea why its seemingly impossible to search for "stat"?

[13:53] *** tjr left
[14:02] <jdv> also, why is .modified's value wrong?

[14:04] *** TieUpYourCamel left
[14:05] <jdv> https://gist.github.com/jdv/9e7190e2f84ae4e85538bb0f533fe3f3

[14:17] <dakkar> jdv: wow, it looks like something messed up the timezone conversion

[14:18] <dakkar> is that WSL?

[14:19] <dakkar> (also, I don't think we have any `stat` function/method)

[14:20] <dakkar> ooh, it happens on linux as well!

[14:20] <dakkar> jdv: looks like you found a bug!

[14:20] <jdv> i am on linux

[14:20] <jdv> looks like older version were worse

[14:20] <jdv> i only have current and 2023.04 atm

[14:20] <dakkar> I'm on 2023.02, maybe I should check on latest‚Ä¶

[14:20] <jdv> at least its closer

[14:20] <dakkar> "closer"?

[14:21] <dakkar> it's adding the timezone offset to the values returned by `stat`, which are guaranteed to be gmtime

[14:21] <jdv> the fractional portion is "closer" on 2023.09 vs 2023.04

[14:22] <dakkar> uh, I hadn't even noticed that it's wrong on my 2023.02

[14:22] <jdv> i was just looking for full resolution mtime and noticed

[14:23] <jdv> i know there was some stat work that made it into the last release

[14:24] <Xliff> I need application server project names. Can anyone help?

[14:28] <dakkar> looks like rakudo calls nqp, nqp calls moarvm, moarvm calls libuv‚Ä¶ and I can't see any data manipulation anywhere

[14:28] <dakkar> so maybe the bug is inside libuv? weird, but possible

[14:29] <dakkar> hmmm

[14:31] *** jpn_ joined
[14:32] <dakkar> ok, the Instant returned by `IO::Path.modified` contains the right value

[14:33] <dakkar> jdv: can you double check? `raku -e '"foo.txt".IO.modified.to-posix.say'` should print the same integer part as `stat --format='%Y' foo.txt`

[14:33] *** jpn left
[14:34] <jdv> proabably libuv:(  node looks the same.

[14:35] <dakkar> dammit, now I can't reproduce the problem anymore (still 2023.02)

[14:35] <jdv> the integer portion is the same for me - just fractional 

[14:36] <dakkar> hmmm

[14:37] <dakkar> curiosity: what timezone is UTC-4?

[14:37] <dakkar> America/New_York?

[14:38] <jdv> yeah

[14:40] <dakkar> uh‚Ä¶ I fear the problem is that we both can't read

[14:40] <dakkar> `TZ=America/New_York date -d @1695318519` prints `Thu Sep 21 01:48:39 PM EDT 2023`

[14:40] <dakkar> 13:48

[14:40] <dakkar> which is‚Ä¶ correct?

[14:40] <jdv> huh?

[14:40] <jdv> yeah, the non-frac portion seems fine

[14:40] <dakkar> (I know I got confused by my machine printing 12h instead of 24th, I should fix that)

[14:41] <dakkar> no, I mean, the integer part looks fine too

[14:41] <jdv> yeah

[14:41] <dakkar> ok, so I was looking at a completely different "error" than you were, and got triply-confused

[14:41] <dakkar> sorry, let's start again

[14:41] <dakkar> (I really can't read, today ‚òπ)

[14:43] <dakkar> then I suspect it's "just" a matter of floating point representation

[14:43] <dakkar> if you `.to-nanos.say`, it should show up the right digits

[14:43] <dakkar> (instead of `.raku.say` or `.to-posix.say`)

[14:45] <jdv> https://gist.github.com/jdv/62f6107b5ff8f341884c6214063c5719

[14:45] <dakkar> yes, now try `.to-nanos`

[14:47] <jdv> still wrong

[14:47] <dakkar> oh?

[14:47] <dakkar> oh yes, I see it here too

[14:48] <dakkar> ah, ok, found it

[14:48] <dakkar> it's still a floating point representation issue

[14:49] <jdv> stat 131224342, nanos 131224320

[14:49] <jdv> sweet

[14:49] <dakkar> that whole logic is a bit complicated ‚òπ

[14:50] <jdv> how does that require logic?

[14:51] <dakkar> https://github.com/MoarVM/MoarVM/blob/main/src/io/fileops.c#L40 this is the bottom call

[14:51] <jdv> sub-second it should just be verbatim from the system, no?

[14:52] <dakkar> https://github.com/MoarVM/MoarVM/blob/main/src/io/fileops.c#L96 next one up, notice how it completely drops the `.tv_nsec` of the `st_mtim` structure

[14:56] <dakkar> correction‚Ä¶ I was looking at the wrong "stat" bit

[14:57] <dakkar> https://github.com/MoarVM/MoarVM/blob/main/src/disp/syscall.c#L1377

[14:57] <dakkar> that's the important bit

[14:57] <dakkar> see? floating point

[14:57] <dakkar> that should very probably be a rat, not a num, but I'm not sure if rats exist at this level

[15:00] <jdv> is it not just https://github.com/MoarVM/MoarVM/blob/main/src/io/fileops.c#L140 ?

[15:00] <jdv> rando guess

[15:00] <dakkar> possibly! there's a few different places and I already got confused once

[15:01] <dakkar> but again, float/num is not the best representation for somethin that arrives as a pair of longs

[15:01] <jdv> meh:()

[15:01] <jdv> oop

[15:01] <jdv> :(

[15:01] <jdv> i guess i'll file a bug somewhere

[15:05] <dakkar> it will need changes in rakudo, nqp, and moarvm, I'm really not sure where would be the best place to report the bug‚Ä¶

[15:05] <dakkar> maybe report it against rakudo, linking to the moarvm bits of code?

[15:11] *** jpn joined
[15:13] *** jpn_ left
[16:03] *** jpn left
[16:32] *** tjr joined
[16:35] *** dakkar left
[16:54] <jdv> there's a bunch of number stuff going wrong

[16:54] <jdv> i don't even know what to report now

[16:56] *** grondilu joined
[16:58] <grondilu> m: class A does Real { method Bridge { pi } }; multi infix:<+>(A, $) { 0 }; say A.new + 1

[16:58] <camelia> rakudo-moar d9f2767c2: OUTPUT: ¬´4.141592653589793‚ê§¬ª

[16:58] <grondilu> why doesn't my multi take precedence?

[16:58] <grondilu> m: class A does Real { method Bridge { pi } }; multi infix:<+>(A, Int $) { 0 }; say A.new + 1

[16:58] <camelia> rakudo-moar d9f2767c2: OUTPUT: ¬´0‚ê§¬ª

[17:01] <jdv> for instance

[17:01] <jdv> m: say 1695747489000167947/10e8

[17:01] <camelia> rakudo-moar d9f2767c2: OUTPUT: ¬´1695747489.0001678‚ê§¬ª

[17:01] <jdv> m: say 1695747489000167947/10e8.Int

[17:01] <camelia> rakudo-moar d9f2767c2: OUTPUT: ¬´1695747489.000167947‚ê§¬ª

[17:01] <jdv> wut

[17:02] <jdv> well, wat

[17:03] <grondilu> m: class A does Real { method Bridge { pi } }; multi infix:<+>(A, Real $) { 0 }; say A.new + 1

[17:03] <camelia> rakudo-moar d9f2767c2: OUTPUT: ¬´0‚ê§¬ª

[17:09] <grondilu> nevermind

[17:15] *** MoC joined
[17:17] <discord-raku-bot> <nemokosch> multi resolution should be better documented

[17:17] <discord-raku-bot> <nemokosch> I just haven't come across anybody who knew it and was willing to explain

[17:18] <grondilu> In the doc they say "The selection process is primarily based on types and number of arguments (arity), where the narrowest, most specific candidate wins, "

[17:18] <discord-raku-bot> <nemokosch> it's not precise enough though, in this case, is it?

[17:18] <discord-raku-bot> <nemokosch> m: 1695747489000167947/10e8.Int andthen .WHAT.say

[17:18] <discord-raku-bot> <Raku eval>  (Rat) 

[17:18] <grondilu> I suppose having the second argument not typed at all made it very unspecific.

[17:19] <discord-raku-bot> <nemokosch> still, the first one was as specific as gets so there should be some precision...

[17:19] <discord-raku-bot> <nemokosch> m: 1695747489000167947/10e8 andthen .WHAT.say

[17:19] <discord-raku-bot> <Raku eval>  (Num) 

[17:19] <grondilu> my initial issue was when I had typed it as Rat(Cool).  I'll see if I can reproduce it here.

[17:19] <grondilu> m: class A does Real { method Bridge { pi } }; multi infix:<+>(A, Rat(Cool) $) { 0 }; say A.new + 1

[17:19] <camelia> rakudo-moar f4ceaf95d: OUTPUT: ¬´4.141592653589793‚ê§¬ª

[17:19] <discord-raku-bot> <nemokosch> jdv: I'm not sure if this is enough of an explanation but I'd think it was just another floating-point weirdness

[17:20] <grondilu> so here the bridge is used, which is not what I wanted.

[17:20] <grondilu> s/wanted/expected/

[17:20] <discord-raku-bot> <nemokosch> m: say 10e8.Int == 100000000

[17:20] <discord-raku-bot> <Raku eval>  False 

[17:20] <discord-raku-bot> <nemokosch> dang

[17:20] <discord-raku-bot> <nemokosch> that's immediately quite some precision lost

[17:20] <jdv> yeah.  its too much for me to delve into atm.

[17:20] <discord-raku-bot> <nemokosch> say 10e8.Int

[17:20] <discord-raku-bot> <nemokosch> oops

[17:21] <discord-raku-bot> <nemokosch> m: say 10e8.Int

[17:21] <discord-raku-bot> <Raku eval>  1000000000 

[17:21] <discord-raku-bot> <nemokosch> but then how can they be not equal, lol

[17:21] <discord-raku-bot> <nemokosch> m: say 10e8.Int == 1000000000

[17:21] <discord-raku-bot> <Raku eval>  True 

[17:21] <discord-raku-bot> <nemokosch> maybe I miscounted

[17:22] <discord-raku-bot> <nemokosch> oh right, 10e8 is 10**9 actually

[17:22] <discord-raku-bot> <nemokosch> but anyway, the type is not the same, that much is for sure.

[17:24] <discord-raku-bot> <nemokosch> grondilu: if this is causing problems for you, I honestly encourage you to make an issue for it. I do think that it's a very significant problem that the multi dispatch resolution order is basically un(der)defined behavior and I'm sure there are other people who think the same

[17:26] <discord-raku-bot> <nemokosch> it's like, we are stronger together, bluntly put

[17:26] <discord-raku-bot> <nemokosch> if there are problems, it's the worst to let passivity and comfort to take over

[17:28] <tonyo> you wouldn't be alone in that ^.  currently following 386 or i'd take a look at it

[17:31] <discord-raku-bot> <nemokosch> https://github.com/rakudo/rakudo/pull/5377 here's this PR from recently. A relatively easy fix for a corner case

[17:32] <discord-raku-bot> <nemokosch> Originally, I just wanted to create a separate multi candidate for the happy path... I think? I should have noted what happened exactly.

[17:33] <discord-raku-bot> <nemokosch> But in vague terms, I created candidate C which made something that originally dispatched to candidate A, dispatch to candidate B. I haven't touch either of those candidates

[17:33] <discord-raku-bot> <nemokosch> touched*

[17:38] <discord-raku-bot> <nemokosch> actually, I did document what happened reasonably well in the issue (#5340) itself

[17:50] <grondilu> posting an issue is not always the best imho.  In this case, I think I failed to realize that Rat(Cool) is less specific than Real.  Because of the (Cool), I suppose.

[18:23] <grondilu> anyway I think I finally manage to write that class for Quadratic Irrationals I wanted: https://gist.github.com/grondilu/b70fb0d8abac36221f0d763f3a7317c6

[18:23] <grondilu> It does Real, but man I had to define so many of the operators.

[18:25] <grondilu> Using Bridge was so not possible that I ended up stubbing it so that the code halts whenever it tries to use it.

[18:29] <discord-raku-bot> <nemokosch> maybe it is less specific, maybe it isn't. I mean, it's useful that you are able to convince yourself but really, I think it's telling that there is no proper material about multiple dispatch

[18:29] <grondilu> If you look at lines 78 to 98, really all these lines should be inherited from Real IMHO.  I shouldn't have to write them down myself.

[18:29] <discord-raku-bot> <nemokosch> and smartmatch to a coercive type is broken for a long time, perhaps since the COERCE protocol landed

[18:30] <discord-raku-bot> <nemokosch> so there definitely are issues, it's not all just our poor understanding

[18:30] <grondilu> maybe

[18:30] <discord-raku-bot> <nemokosch> 'almafa' ~~ Real() was False until late 2020 iirc

[18:31] <grondilu> still I'm not keen on posting issues unless it's really bothering me.

[18:31] <discord-raku-bot> <nemokosch> it's True since, go figure, I think False was right

[18:32] <discord-raku-bot> <nemokosch> the funny thing is, I think you might be the person who caused me to open the most issues

[18:33] <discord-raku-bot> <nemokosch> actually, not just about the issues opened, the person who brought the largest amount of problematic code to ponder about

[18:35] <grondilu> lol I've heard that before.  I've been told I have a knack to find weird issues or something.

[18:36] <grondilu> The thing is, usually when I start a toy project in raku, I stumble upon a bug.  That being said, it's becoming rarer these times as raku matures.

[18:36] <discord-raku-bot> <nemokosch> but as much as I can recall, most of the things you tried to do made sense for me, it's not like you clearly did "something that hurts"

[18:40] <discord-raku-bot> <nemokosch> from my personal perspective, the problem is really that I'm a golem when it comes to stuff like this and I engage in this rather shitty role of bringing problems and criticism

[18:42] <discord-raku-bot> <nemokosch> eventually, if I bring up stuff like this, it will be just received with some personal remarks and swept away, to be honest

[19:11] *** MoC left
[19:32] *** stanrifkin joined
[19:34] <stanrifkin> Is there a v6.e feature list?

[19:52] <tonyo> nemokosch: i don't think any of us find it shitty that you bring up issues, it generally hardens the language to not have gaps everywhere

[19:52] <tonyo> rather, most of us appreciate it.

[20:11] <discord-raku-bot> <nemokosch> well, there are direct and indirect ways in which it can appear to me that certain issues inflate by the mere fact that I bring them up

[20:11] <discord-raku-bot> <antononcube> Some actively encourage it. (Willingly or not...)

[20:13] *** stanrifkin left
[20:13] <discord-raku-bot> <nemokosch> sometimes it's the lack of feedback for a problem-solving issue that is either very important or very actionable (as in, I gave loads of details and proposed a solution, like the one with the Raku books)

[20:14] <discord-raku-bot> <nemokosch> sometimes it's the ad nauseam "whatever, that's just your opinion"

[20:15] <discord-raku-bot> <nemokosch> the latter in itself makes me cling onto whenever I see others have the same issue

[20:19] *** grondilu left
[20:35] <tonyo> sometimes it's difficult to see past your own opinion, particularly when someone else shares it and silence on the topic is the norm because it's mostly a non-issue for them.  most of have been called on that in some capacity, including myself, ugexe, lizmat, nine, etc

[20:36] <tonyo> but it doesn't mean the enthusiasm and role are for naught, everyone benefits from it when it's constructive conversation

[20:37] <discord-raku-bot> <nemokosch> I think there are several "sleeping issues" thanks survivor bias, that is, when it's not surprising that it's not an issue to most of you, because if it were an issue for you, you would have just walked away

[20:40] <discord-raku-bot> <nemokosch> this is part of the reason I don't believe in "democratic methods" much for certain topics

[20:42] <discord-raku-bot> <nemokosch> I much rather believe in traditional arguments compiled from evidence, fundamental value judgements and deduction

[20:43] <discord-raku-bot> <nemokosch> and it happened just today that I compiled a large argument and it got shut down by "you've already got to say your opinion"

[20:46] <discord-raku-bot> <nemokosch> are "this is very useful" and an analysis of cost-benefit, or giving alternative solutions to a problem, all just "opinions" on equal terms?

[20:52] *** AlexDaniel joined
[20:57] <tonyo> giving solutions to things people don't think are problems is always a dead end.  from what i've seen, the value judgements need to align with the overall goals of the project.  having one way to do something is very far from the goals of raku or it's mother language in general and, especially in raku, it's important to balance one's personal preference/opinion/experience with the language

[20:58] *** jpn joined
[20:58] <tonyo> having only one way*

[21:13] <discord-raku-bot> <nemokosch> well, this particular case was about the for-else proposal of Damian Conway back in an article, so the "problem" was defined by Damian

[21:14] <discord-raku-bot> <nemokosch> I think it really was (would have been, rather) a good opportunity to at least try to address why we have such a different view of the usefulness of it

[21:36] *** jpn left
[21:37] *** jpn joined
[21:49] *** sena_kun left
[22:35] *** derpydoo left
[22:35] *** Sgeo joined
[22:48] *** jpn left
[22:49] *** jpn joined
[22:54] *** MasterDuke left
[22:55] *** jpn left
[22:57] *** jpn joined
[23:28] *** jpn left
[23:36] *** jpn joined
[23:44] *** hexology- left
[23:45] *** hexology joined
[23:45] <tbrowder__> i need to have a single module to be used by 2 diff releases of raku. i know i can use ‚Äúno precompilation‚Äù but where do i put the words.

[23:49] <tbrowder__> i a

[23:50] <tbrowder__> i‚Äôm assuming precomp would cause a problem in this situation

[23:52] <tbrowder__> i‚Äôm guessing ‚Äúunit module Foo;\nno precompilation;‚Äù

[23:53] <ugexe> i'd probably put it as the first line of my source code

[23:53] <ugexe> but i don't think it matters too much

[23:53] <ugexe> also why are you assuming precomp would cause a problem?

[23:55] <ugexe> precompilation isn't going to step on each other for different versions because the rakudo compiler id (or something like it) is used to create a hash of the files

[23:55] <ugexe> so if you have two different versions of raku, they will each precompile those files into different file names that will only be used by the given rakudo version

[23:59] *** jpn left
