[00:00] *** reportable6 left
[00:02] *** reportable6 joined
[00:12] *** mtj left
[00:12] *** mtj joined
[00:36] *** perryprog left
[00:36] *** perryprog joined
[00:54] *** ProperNoun left
[01:19] *** Manifest0 left
[01:31] *** stanrifkin left
[02:11] *** ProperNoun joined
[03:11] *** nativecallable6 left
[03:11] *** notable6 left
[03:11] *** sourceable6 left
[03:11] *** greppable6 left
[03:11] *** benchable6 left
[03:11] *** committable6 left
[03:11] *** squashable6 left
[03:11] *** statisfiable6 left
[03:11] *** bloatable6 left
[03:11] *** coverable6 left
[03:11] *** bisectable6 left
[03:11] *** linkable6 left
[03:11] *** unicodable6 left
[03:11] *** quotable6 left
[03:11] *** tellable6 left
[03:11] *** reportable6 left
[03:11] *** releasable6 left
[03:11] *** evalable6 left
[03:11] *** shareable6 left
[03:11] *** bisectable6 joined
[03:11] *** linkable6 joined
[03:11] *** notable6 joined
[03:11] *** shareable6 joined
[03:11] *** committable6 joined
[03:11] *** greppable6 joined
[03:12] *** statisfiable6 joined
[03:12] *** sourceable6 joined
[03:12] *** reportable6 joined
[03:12] *** unicodable6 joined
[03:12] *** bloatable6 joined
[03:12] *** releasable6 joined
[03:13] *** quotable6 joined
[03:13] *** nativecallable6 joined
[03:13] *** benchable6 joined
[03:13] *** tellable6 joined
[03:13] *** coverable6 joined
[03:14] *** squashable6 joined
[03:14] *** evalable6 joined
[04:14] *** unicodable6 left
[04:14] *** greppable6 left
[04:14] *** benchable6 left
[04:14] *** reportable6 left
[04:14] *** shareable6 left
[04:14] *** committable6 left
[04:14] *** bloatable6 left
[04:14] *** evalable6 left
[04:14] *** squashable6 left
[04:14] *** sourceable6 left
[04:14] *** tellable6 left
[04:14] *** notable6 left
[04:14] *** bisectable6 left
[04:14] *** coverable6 left
[04:14] *** nativecallable6 left
[04:14] *** quotable6 left
[04:14] *** statisfiable6 left
[04:14] *** releasable6 left
[04:14] *** linkable6 left
[04:14] *** tellable6 joined
[04:14] *** notable6 joined
[04:14] *** evalable6 joined
[04:14] *** nativecallable6 joined
[04:15] *** shareable6 joined
[04:15] *** unicodable6 joined
[04:15] *** coverable6 joined
[04:15] *** linkable6 joined
[04:15] *** bisectable6 joined
[04:15] *** statisfiable6 joined
[04:15] *** committable6 joined
[04:16] *** sourceable6 joined
[04:16] *** releasable6 joined
[04:16] *** bloatable6 joined
[04:16] *** benchable6 joined
[04:17] *** greppable6 joined
[04:17] *** reportable6 joined
[04:17] *** squashable6 joined
[04:17] *** quotable6 joined
[05:17] *** shareable6 left
[05:17] *** tellable6 left
[05:17] *** nativecallable6 left
[05:17] *** squashable6 left
[05:17] *** bloatable6 left
[05:17] *** notable6 left
[05:17] *** greppable6 left
[05:17] *** statisfiable6 left
[05:17] *** linkable6 left
[05:17] *** reportable6 left
[05:17] *** unicodable6 left
[05:17] *** committable6 left
[05:17] *** coverable6 left
[05:17] *** quotable6 left
[05:17] *** evalable6 left
[05:17] *** benchable6 left
[05:17] *** bisectable6 left
[05:17] *** releasable6 left
[05:17] *** sourceable6 left
[05:17] *** reportable6 joined
[05:17] *** coverable6 joined
[05:18] *** nativecallable6 joined
[05:18] *** greppable6 joined
[05:18] *** evalable6 joined
[05:18] *** bloatable6 joined
[05:18] *** notable6 joined
[05:18] *** committable6 joined
[05:19] *** squashable6 joined
[05:19] *** sourceable6 joined
[05:19] *** bisectable6 joined
[05:19] *** statisfiable6 joined
[05:19] *** shareable6 joined
[05:19] *** linkable6 joined
[05:19] *** quotable6 joined
[05:19] *** benchable6 joined
[05:19] *** tellable6 joined
[05:19] *** unicodable6 joined
[05:20] *** releasable6 joined
[06:00] *** reportable6 left
[06:03] *** reportable6 joined
[06:27] *** swaggboi left
[06:40] *** jpn joined
[06:40] *** abraxxa-home joined
[06:50] *** swaggboi joined
[07:29] *** abraxxa-home left
[07:49] *** merp left
[07:54] *** merp joined
[08:22] *** jpn left
[08:23] *** tea3po left
[08:23] *** tea3po joined
[08:24] *** tea3po left
[08:25] *** tea3po joined
[08:25] *** jpn joined
[08:39] *** andinus joined
[08:54] *** jpn left
[09:12] *** wayland left
[09:12] *** wayland joined
[09:16] *** jpn joined
[10:03] *** Manifest0 joined
[10:22] *** Sgeo left
[10:59] *** raiph joined
[11:10] *** jpn left
[11:13] *** leah2 left
[11:26] *** leah2 joined
[11:50] *** jpn joined
[11:51] *** derpydoo left
[11:54] *** jpn left
[12:00] *** reportable6 left
[12:03] *** reportable6 joined
[12:15] *** jpn joined
[12:20] *** jpn left
[13:20] *** evalable6 left
[13:20] *** linkable6 left
[13:21] *** evalable6 joined
[13:23] *** linkable6 joined
[13:32] *** jpn joined
[13:38] *** jpn left
[13:41] <leont> Is it by accident or on purpose that \:foo doesn't do the same as \(:foo)?

[13:42] <leont> The former creates a capture with a pair as its only positional argument, the latter creates a capture with a named argument.

[13:42] <leont> Frankly, the former confuses the hell out of me

[13:43] <lizmat> feels like a case of DIHWIDT

[13:47] <leont> In what way?

[13:48] <lizmat> well, I never manually create captures like that, let alone a fixed \:foo one

[13:48] <lizmat> but I guess that's me then  :-)

[13:48] <leont> Oh I know I do something weird here, but weird isn't wrong.

[13:48] <lizmat> anyways, not sure if it is an accident or intentionally so

[13:49] <leont> I can't think of any reason for the former behavior, so I'm kind of assuming it's an accident.

[13:49] <leont> (I'm using captures as a syntax for some complicated stuff in SQL::Abstract)

[13:54] <lizmat> bisectable6: dd \:foo

[13:54] <bisectable6> lizmat, Will bisect the whole range automagically because no endpoints were provided, hang tight

[13:55] <bisectable6> lizmat, Output on all releases: https://gist.github.com/4e4c727b69e228c0e96ff6eeeb4ad74d

[13:55] <bisectable6> lizmat, Bisecting by output (old=2021.12 new=2022.02) because on both starting points the exit code is 0

[13:55] <bisectable6> lizmat, (2022-01-05) https://github.com/rakudo/rakudo/commit/27ede8cb0ea9d6ba1ddf0843bd1dc44fbbe6f9fa

[13:55] <bisectable6> lizmat, bisect log: https://gist.github.com/bb336c79e6b586791084e99d46368b8e

[13:56] <bisectable6> lizmat, Output on all releases and bisected commits: https://gist.github.com/cf35b1a3beca8b61442588f6c53bf273

[13:57] <lizmat> seems to have been the same always?

[13:58] <lizmat> bisectable6: .say for (\:foo).hash

[13:58] <bisectable6> lizmat, Will bisect the whole range automagically because no endpoints were provided, hang tight

[13:58] <leont> The latter case is because List.Capture, the former case I don't fully understand yet

[13:58] <bisectable6> lizmat, ¦6c (68 commits): «»

[13:58] <bisectable6> lizmat, Nothing to bisect!

[13:59] <lizmat> hmmm

[14:00] <discord-raku-bot> <nemokosch> so, is this the way to create a Capture where a pair is a positional?

[14:01] <leont> nemokosch: why would you want that?

[14:01] <discord-raku-bot> <nemokosch> for destructuring

[14:02] <discord-raku-bot> <nemokosch> if your data happens to be a Pair for whatever reason, you basically can't retrieve it via destructuring because it will be faked as named

[14:03] <leont> Right, because List.Capture

[14:06] <discord-raku-bot> <nemokosch> it doesn't even matter that your pair doesn't have string keys but honestly, that's still better than downright having different behavior based on the type of the keys of your data...

[14:08] <discord-raku-bot> <nemokosch> I think this is the actual meaning of "strangely consistent" - high-order data is used for faking a lot of syntax, and whenever you want to use them as generic data, it will cause problems

[14:08] <discord-raku-bot> <nemokosch> confer smartmatching, confer the ... operator, confer pairs and argument passing

[14:10] <leont> Things in this area aren't quite optimal

[14:16] <leont> nemokosch: I don't think it solves your problem either, unless you want to pass a single argument

[14:16] <leont> In which case you're probably not using destructuring

[14:17] <discord-raku-bot> <nemokosch> yes, true

[14:18] <lizmat> fwiw, I wouldn't be against making :colonpair syntax for named args only, and fatarrow syntax for Positional Pairs in a future language version

[14:21] <discord-raku-bot> <nemokosch> I'm kinda sorry for the fatarrow syntax because I don't like the colonpair syntax at all... but if that's the sacrifice to be made...

[14:23] <discord-raku-bot> <nemokosch> My "evolutional cycle" with Pairs went from "Pairs are kinda cute and exotic for 2-tuples" to "Pairs are fundamentally asymmetric and should only be used for associating keys with values" and eventually "Pairs shouldn't be used in user code at all"

[14:30] <leont> I find them useful but a little too magical at times

[14:31] <discord-raku-bot> <nemokosch> and then there are people around Raku doing sort of promotional stuff on various platforms - I don't think there is any point in naming them, and I do think they act in good faith - who practically make novice users feel gaslighted by stubbornly sticking to the ideals that everything in the language is thoroughly planned and for the greater benefit

[14:32] <discord-raku-bot> <nemokosch> it's rather the ideal that is harmful and hard to escape

[14:38] *** linkable6 left
[14:38] *** evalable6 left
[14:38] *** evalable6 joined
[14:38] *** linkable6 joined
[14:45] *** xinming left
[14:47] *** xinming joined
[15:02] *** ab5tract joined
[15:04] *** jpn joined
[15:11] *** jpn left
[15:35] *** jpn joined
[15:39] *** jpn left
[16:17] *** jpn joined
[16:27] *** jgaz joined
[16:40] *** tea3po left
[16:44] *** [Coke] left
[17:11] *** teatime joined
[18:00] *** reportable6 left
[18:01] *** reportable6 joined
[18:54] <japhb> m: sub foo($p (:$key, :$value)) { dd $p, $key, $value };  foo("a" => "pair");

[18:54] <camelia> rakudo-moar f4fc256b0: OUTPUT: «:a("pair")␤"a"␤"pair"␤»

[18:54] <japhb> Of *course* you can destructure a pair.  ^^

[19:01] *** evalable6 left
[19:01] *** linkable6 left
[19:02] *** linkable6 joined
[19:04] *** evalable6 joined
[19:11] <discord-raku-bot> <nemokosch> m: ((1 => 2,  5 => 4), ).map(-> ($first, $second) { say "The second horse is $second" })

[19:11] <discord-raku-bot> <Raku eval>  Exit code: 1 Too few positionals passed to '<anon>'; expected 2 arguments but got 0 in sub-signature   in block <unit> at main.raku line 1  

[19:11] <discord-raku-bot> <nemokosch> tough luck

[19:12] <discord-raku-bot> <nemokosch> this is what I meant, not that you can't look into a Pair when you know you got one

[19:17] *** ab5tract left
[19:19] *** andinus left
[19:21] *** jpn left
[19:26] *** ab5tract joined
[19:30] <japhb> What are you even trying to accomplish there?  That looks like a lot of confusion.

[19:30] *** jpn joined
[19:44] *** jpn left
[19:45] <discord-raku-bot> <nemokosch> it's not that difficult

[19:45] <discord-raku-bot> <nemokosch> m: (<1 2>, ).map(-> ($first, $second) { say "The second horse is $second" })

[19:45] <discord-raku-bot> <Raku eval>  The second horse is 2 

[19:45] <discord-raku-bot> <nemokosch> say, you have an indefinite amount of n-tuples and want to destructure each one of them

[19:46] <discord-raku-bot> <nemokosch> if the n-tuples happen to contain Pairs, you are suddenly screwed

[19:58] <japhb> If you know the n-tuples *might* contain Pairs, you just don't handle them that way.  I'll grant you that Pairs with string keys are handled specially by binding (which is what destructuring is actually doing).

[19:58] <japhb> m: ((1 => 2,  5 => 4), ).map(-> $t { say "The second horse is $t[1]" })

[19:58] <camelia> rakudo-moar 65d84a4d5: OUTPUT: «The second horse is 5   4␤»

[19:59] <japhb> Especially since that ^^ works perfectly well

[19:59] <japhb> m: ((1 => 2,  5 => 4), ).map(-> $t { say "The second horse's key is $t[1].key()" })

[19:59] <camelia> rakudo-moar 65d84a4d5: OUTPUT: «The second horse's key is 5␤»

[19:59] <japhb> As does that ^^

[20:01] <discord-raku-bot> <nemokosch> well yes, that's the problem. The values provided can sabotage the structure. If Pairs are so special that they can break the expectation that you get positionals back as positionals, maybe they are not suited for user space. This is not something that should ever happen

[20:01] <japhb> Do you feel similarly about Junction and Mu and other such special cases?

[20:05] <discord-raku-bot> <nemokosch> I think these comparisons usually derail the topic too much

[20:07] <discord-raku-bot> <nemokosch> For Junction, it can be argued that it's both a structure and something abstracted away from the users, who probably should only use it as structure, not as a value in the traditional sense. If the same stands for something that is called simply "Pair", then the name itself is a trap.

[20:07] <japhb> Wasn't trying to derail.  I'm asking "Do you dislike having certain types that carry semantic value *to Raku itself*, and that thus have behaviors that are not exactly like "plain old objects"?"

[20:09] <japhb> Because all abstractions eventually leak, so having abstractions over such special types simply means that eventually they'll leak and people will be surprised.

[20:09] <japhb> Junction, Mu, Seq, Pair, ... they all leak.

[20:10] <discord-raku-bot> <nemokosch> Well, I don't know if we can just push Junction and Pair into the same bag like that

[20:11] <discord-raku-bot> <nemokosch> What I don't like - or it would be more accurate to say, I deem problematic for writing reliable code and understanding it - is this pattern that a lot of apparent syntax is special handling of data types, which looks clever and all as long as you only use hardcoded literals but will cause serious headaches once you want to use the exploited types as mere data to be passed around

[20:13] <discord-raku-bot> <nemokosch> I can stand by the three examples I've given: 1. this behavior of Pairs 2. the special casing of Boolean and especially Match in smartmatches 3. the special handling of Callables and everything that can create a list, in the ... operator

[20:13] <japhb> It's very valuable to be able to pass around Capture and Signature.  I can totally understand if you want a true Tuple type.  So ... make one?

[20:14] <discord-raku-bot> <nemokosch> oh right, Callables themselves are a special case in smartmatches

[20:15] <japhb> Callables are a special case for most things, because the DWIM outweighs the WAT for most of us.

[20:16] <discord-raku-bot> <nemokosch> and this is why Raku is damned to be a "90% language"

[20:16] <discord-raku-bot> <nemokosch> 90% of times, it will do the right thing. But 90% is usually not enough for serious work

[20:16] <japhb> The whole point of Raku's design was to be mutable.  If you don't like it, mutate it!  :-)

[20:16] *** El_Che left
[20:17] <japhb> Are you claiming that other languages do not have WATs in them?

[20:17] *** El_Che joined
[20:18] <discord-raku-bot> <nemokosch> they have a disproportionally smaller amount of it, and I have Javascript in mind right now, not a language praised for visionary design

[20:19] * japhb actually boggles

[20:19] <discord-raku-bot> <nemokosch> I do enjoy writing Raku code for little scripts, don't get me wrong

[20:19] <japhb> I was expecting you to pull out Rust or Haskell or some language praised for its design, but JS?

[20:19] <discord-raku-bot> <nemokosch> but after 2 years of using it, I can actually feel the difference, even when using JS

[20:20] <discord-raku-bot> <nemokosch> there are just disproportionally fewer things that can go wrong, it's that simple

[20:22] <japhb> I don't even know how to respond to that.  I'm flummoxed.

[20:22] <discord-raku-bot> <nemokosch> In Raku, I can write the "most clever" (subjectively speaking, of course) piece of code - but I would never have the confidence that a user won't break it with certain unexpected input

[20:22] <discord-raku-bot> <nemokosch> and that is a really bad thing

[20:22] *** teatime left
[20:23] *** teatime joined
[20:23] <discord-raku-bot> <nemokosch> and not to be arrogant but I think I have learned the way Raku works more than the vast majority of people would - this is why I am even aware of these problems

[20:24] <japhb> "Clever" and "secure" don't go well together in *any* language.

[20:24] <japhb> And no one should write code that has security requirements if they don't understand it.

[20:26] <discord-raku-bot> <nemokosch> the problem is that Raku has been designed around cleverness, and never around understandability

[20:26] <japhb> As for the arrogance question ... what level of skill do you think most of the inhabitants of #raku-dev have?  Note how many of them are also here.

[20:27] <japhb> You can speak plainly in English.  And you can be obfuscated in English too.  Same with C, for example.  And Raku.

[20:27] <discord-raku-bot> <nemokosch> or how to put it... it's not like Raku could not be understandable, it's much rather that it's designed in a way that discourages understanding it, because it will "magically do the right thing" 90% of cases

[20:28] <discord-raku-bot> <nemokosch> The vast majority of people will only notice something was there to be thought of when they hit the 10% when something else happened that they would have never even dreamed of

[20:29] <japhb> So this comes full circle -- it sounds like you would rather have vastly less DWIM if you also got less WAT.

[20:30] <discord-raku-bot> <nemokosch> it took me some time to understand this layer of the philosophy... that DWIM itself created DIHWIDT, as a means to escape a lot of WATs

[20:30] <discord-raku-bot> <nemokosch> "if it didn't do what you meant, surely you couldn't have really mean it"

[20:32] <japhb> DIHWIDT means "Well, you continued trying to find the breaking point of the magic, and you eventually found it.  Congratulations, here's your Raku Darwin award.  We're not fixing it."

[20:32] <japhb> It does *not* mean that we don't recognize that said person did in fact find the breaking point.

[20:33] <discord-raku-bot> <nemokosch> The tough part is to be able to tell what sort of breakage is really "illegitimate"

[20:34] <discord-raku-bot> <nemokosch> and with JS as well, I think what needs to be realized and come in terms with, is that these questions are considerably less common for an average mainstream language (even without any theoretical purity)

[20:35] <japhb> And that's fair.  But that's why you *ask* about it, rather than *gripe* about it.

[20:35] <japhb> JS went through a period (around ES6 IIRC) where the language was vastly improved and regularized.  It's not at all the giant mess it was back in the 90's.

[20:37] <discord-raku-bot> <nemokosch> JS6 mostly extended the existing JS and "strict mode" allowed certain common mistakes to be signalled as errors. It's true that it was easy to make mistakes in "old JS" but it was also pretty easy to understand them, there was not a lot to learn

[20:37] <japhb> (Though I suppose if you tried to swim upstream, you could probably recreate that hellscape and get it to "run" on a modern JS runtime.  But that's just saying that old stuff will still compile, not that it represents JS as it is taught now.)

[20:39] <discord-raku-bot> <nemokosch> By the way, can we agree that DWIM is practically the antithesis of Python's "explicit is better than implicit"?

[20:41] <japhb> Well ... if Python actually *kept* to that, I'd agree.  But I'd perhaps say that those two *statements* are in opposition, rather than that the two *language implementations* are in opposition on that point.

[20:42] <discord-raku-bot> <nemokosch> Well, it's always kind of vague

[20:43] <discord-raku-bot> <nemokosch> even the staments aren't very "explicit", and also they kind of convey a bias

[20:44] <discord-raku-bot> <nemokosch> the word "implicit" is more stigmatic than the phenomenon itself, thinking of C++ for example

[20:45] <teatime> speaking aloud in a human language is a lot like typing with your mouth

[20:45] <teatime> wrong window, apologies

[20:45] <discord-raku-bot> <nemokosch> 😂

[20:48] <discord-raku-bot> <nemokosch> also, for what it's worth, I still haven't reached the point of the "late" AlexDaniel to completely prefer a simplistic and opinionated language

[20:50] <discord-raku-bot> <nemokosch> in fact, more of these problems could be addressed by introducing certain distinctions, rather than removing behavior. Like, the distinction of a named argument, a named parameter and a pair

[21:09] *** dustinm` left
[21:10] *** dustinm` joined
[21:17] *** jpn joined
[21:23] *** jpn left
[21:24] *** raiph left
[21:35] *** Sgeo joined
[22:15] <tonyo> go is pretty boring/verbose to write and about as simple as they come

[22:29] *** kk joined
[22:29] *** kk is now known as DeVol

[22:29] *** DeVol is now known as DeVoL

[22:38] *** DeVoL left
[22:48] <coleman> Go in the streets, Raku in the sheets

[22:56] <discord-raku-bot> <nemokosch> Go is the polar opposite of Raku, pretty much

[22:57] <discord-raku-bot> <nemokosch> it's a self-proclaimed counter-revolutionary of C++

[23:01] <leont> tonyo: neoclassical is my favorite description

[23:03] <leont> nemokosch: the problem isn't even pairs itself, it's literally List.Capture that makes this weird translation

[23:03] <discord-raku-bot> <nemokosch> https://github.com/rakudo/rakudo/issues/4534 I suspected

[23:03] <discord-raku-bot> <nemokosch> this issue will soon have its second birthday

[23:04] <discord-raku-bot> <nemokosch> anyway... neoclassical? is that for Go?

[23:05] <leont> Yeah, that's for go

[23:05] <leont> And I didn't know that ticket, but I should follow it

[23:06] <leont> Literally changing that one method would change everything in this area, but I have no idea what relies on this currently and how to fix it

[23:06] <discord-raku-bot> <nemokosch> well, vrurg didn't really say anything cheerful about it

[23:07] <discord-raku-bot> <nemokosch> I would rather say neoclassicist for Go, neoclassical reminds me of progressive rock and stuff, usually baroque-ish

[23:08] <leont> The sensible thing is a List always turns into a positional Capture, and a hash a named capture. Anything else it just madness.

[23:08] <leont> It has the smell of a quick-fix

[23:08] <discord-raku-bot> <nemokosch> https://youtu.be/05k8DgEXZXM?t=166 this sounds more Raku to me than Go lol

[23:08] <leont> (as in, it came about as a quick fix instead of actual design)

[23:09] <discord-raku-bot> <nemokosch> "just learn the instrument" xD

[23:20] *** wayland left
[23:37] *** charsbar left
[23:37] *** charsbar joined
[23:57] <leont> The operation it performs is essential in some places, function calls being the obvious one, but it should have been wired differently.

[23:59] <discord-raku-bot> <nemokosch> makes sense

