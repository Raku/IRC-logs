[00:01] *** jpn joined
[00:07] *** deoac left
[00:07] *** jpn left
[00:13] *** jpn joined
[00:27] *** donpdonp- joined
[00:28] *** donpdonp|z_ left
[00:38] *** donpdonp|z_ joined
[00:38] *** donpdonp- left
[00:38] *** jpn left
[00:39] *** jpn joined
[00:42] *** donpdonp joined
[00:42] *** donpdonp|z_ left
[00:57] *** jpn left
[00:59] *** jpn joined
[01:06] *** jpn left
[01:13] *** jpn joined
[01:30] *** sena_kun left
[01:47] *** derpydoo left
[02:13] *** jpn left
[02:33] *** hythm joined
[02:37] *** jpn joined
[02:42] *** ProperNoun joined
[02:43] *** jpn left
[02:52] *** jpn joined
[02:58] *** jpn left
[03:22] *** jpn joined
[03:27] *** jpn left
[03:59] *** jpn joined
[04:06] *** jpn left
[04:09] *** jpn joined
[04:17] *** jpn left
[04:29] *** jpn joined
[04:36] <discord-raku-bot> <nemokosch> AlexDaniel returns for one occasion and immediately spots a Rakudo regression

[04:36] *** jpn left
[04:43] <discord-raku-bot> <nemokosch> Not gonna lie, I'm slightly relieved that it's not a Pastebin-Gist regression for my personal involvement but it's not looking good

[05:16] *** Maylay joined
[05:23] *** hythm left
[05:45] *** sena_kun joined
[06:17] *** Woodi left
[07:33] *** jpn joined
[07:33] *** derpydoo joined
[07:53] *** lichtkind joined
[07:54] *** dakkar joined
[08:41] *** derpydoo left
[09:10] <Geth> ¦ ecosystem/main: 85add8be8f | (Elizabeth Mattijsen)++ | META.list

[09:10] <Geth> ¦ ecosystem/main: Remove Text::CSV, moving to zef ecosystem

[09:10] <Geth> ¦ ecosystem/main: review: https://github.com/Raku/ecosystem/commit/85add8be8f

[09:12] <discord-raku-bot> <nemokosch> > The FileSystem repo is meant to be used during module development and actually works just like Perl when looking for a module. It doesn't support versions or auths and simply maps the short-name to a filesystem path.

[09:12] <discord-raku-bot> <nemokosch> in this case, I really don't get why it can't work as efficiently as in Perl

[09:13] <discord-raku-bot> <nemokosch> most notably, why does it build a repository eagerly?

[09:14] <discord-raku-bot> <nemokosch> also, there should be at least a way to allow for precomp, if the performance depends on that

[09:14] <discord-raku-bot> <nemokosch> even if it's the user's responsibility to keep it in sync

[09:16] <discord-raku-bot> <nemokosch> at least some opt-in feature, like "I understand the risks, I want the performance gain even at a cost"

[09:28] <Geth> ¦ ecosystem/main: ee61ce592c | (Elizabeth Mattijsen)++ | META.list

[09:28] <Geth> ¦ ecosystem/main: Remove Logger, it now lives in zef

[09:28] <Geth> ¦ ecosystem/main: review: https://github.com/Raku/ecosystem/commit/ee61ce592c

[09:31] *** Sgeo left
[09:33] *** sena_kun left
[10:16] *** abraxxa joined
[11:23] *** clarkema_ joined
[11:23] *** atweedie_ joined
[11:23] *** bingos_ joined
[11:23] *** patrickb_ joined
[11:24] *** hexology- joined
[11:24] *** rjbs_ joined
[11:30] *** rjbs left
[11:30] *** BinGOs left
[11:30] *** hexology left
[11:30] *** lucerne left
[11:30] *** patrickb left
[11:30] *** clarkema left
[11:30] *** atweedie left
[11:31] *** rjbs_ is now known as rjbs

[11:31] *** patrickb_ is now known as patrickb

[11:31] *** clarkema_ is now known as clarkema

[11:31] *** atweedie_ is now known as atweedie

[11:31] *** clarkema left
[11:31] *** atweedie left
[11:31] *** patrickb left
[11:31] *** atweedie joined
[11:31] *** atweedie left
[11:31] *** atweedie joined
[11:31] *** patrickb joined
[11:33] *** clarkema joined
[11:35] *** lucerne joined
[11:35] *** lucerne left
[11:35] *** lucerne joined
[11:44] *** jpn left
[11:45] *** jpn joined
[11:52] <ugexe> it does work with versions

[11:52] <ugexe> if you point it at a directory containing a META6.json file (./) instead of e.g. ./lib

[11:52] <ugexe> and it does so because it has to know when files in the repository are changed to re-precompile

[11:53] <ugexe> you can't check the file times because windows timestamp granularity isn't good enough

[11:55] <ugexe> and CURFS does precompile

[11:57] <discord-raku-bot> <nemokosch> I don't know how that applies here but I can definitely recall that you have to set "no precompilation" for a great variety of "use lib" cases

[11:58] <ugexe> i honestly have no idea what you're referring to

[11:58] <ugexe> precompilation works with CURFS

[11:59] <discord-raku-bot> <nemokosch> then I guess we are stuck here

[12:00] <ugexe> i mean i can only refute your incorrect statements. i cant read your mind to tell you what you aren't saying

[12:01] <discord-raku-bot> <nemokosch> and I can't magically gather more data on it

[12:01] <lizmat> and yet another Rakudo Weekly News hits the Net: https://rakudoweekly.blog/2023/09/25/2023-39-releaseses/

[12:01] <ugexe> i wouldn't expect you to use magic

[12:01] <discord-raku-bot> <nemokosch> that's nice

[12:02] <ugexe> well when you learn to ask what you want instead of throwing a fit, I (and others) will be here to try and answer it

[12:04] <discord-raku-bot> <nemokosch> sure. I thought remembering that I literally got compilation errors for it was enough.

[12:05] <lizmat> nemokosch please supply a stack trace or a gist or whatever other tangible than "remembering", please

[12:09] <discord-raku-bot> <nemokosch> um, about the asking part https://irclogs.raku.org/raku-beginner/2023-04-12.html#14:58

[12:09] <lizmat> well, maybe ugexe will correct me on that one

[12:11] <ugexe> i mean that can be tested in like 5 seconds

[12:11] <ugexe> https://gist.github.com/ugexe/6b80d704c293c07e98670bc1c0a2bfae

[12:12] <ugexe> it is usually worth attempting to validate any advice that is given just to be sure

[12:12] <lizmat> ugexe: I think this was about using "use lib" *inside* a module ?

[12:13] <lizmat> aka precompiling a "use lib"

[12:13] <discord-raku-bot> <nemokosch> so does that actually make a difference?

[12:13] <ugexe> use lib only potentially re-trigger precompilation

[12:13] <ugexe> which makes sense

[12:14] <ugexe> putting a `use lib "..."` in a module that will be installed doesn't make sense and is arguably wrong

[12:14] <ugexe> but it would still work fine

[12:14] <ugexe> you'd just have some invalid repository in your repo chain any time that module is loaded

[12:15] <discord-raku-bot> <nemokosch> okay, then next question

[12:15] <discord-raku-bot> <nemokosch> is there any way to decompose Raku code into compunits without making all of the compunits a part of the API?

[12:17] <discord-raku-bot> <nemokosch> by the way, just a quick heads-up that between encouraging me to ask questions, you just kept repeating "CURFS does precompile" which had little meaning to me, while the point I was going to raise was actually legitimate

[12:17] <lizmat> ugexe: wouldn't that be an action at a distance and a potential attack vector?

[12:17] <lizmat> precomping "use lib" ?

[12:18] <discord-raku-bot> <nemokosch> to only expose an executable that is backed up by several non-API modules? sounds everyday to me

[12:18] <ugexe> lizmat: yeah

[12:18] *** bingos_ is now known as BinGOs

[12:18] <discord-raku-bot> <nemokosch> this is just the most trivial example

[12:18] *** BinGOs left
[12:18] *** BinGOs joined
[12:20] <ugexe> i dont know what decompose raku code into compunits without. making all of the compunits a part of the API means

[12:22] <ugexe> maybe something in https://github.com/LLFourn/p6-CompUnit-Util 

[12:24] <discord-raku-bot> <nemokosch> So my understanding is that if you want precompilation for something that depends on other modules (living in other compunits) of yours, you'll end up adding the dependency to the "provides" section of the META file

[12:25] <discord-raku-bot> <nemokosch> that's the encouraged way at least, and the only way I have ever heard of

[12:25] <ugexe> that isn't entirely accurate because `provides` isn't directly used to generate precomp stuff. rather, `provides` lets rakudo know which source code files are available

[12:27] <discord-raku-bot> <nemokosch> but it is required for resolving the dependency in the other module, unless you do use lib

[12:27] <discord-raku-bot> <nemokosch> or is there a non-use-lib, non-provides way?

[12:28] *** jpn left
[12:28] <ugexe> well with something like -Ilib (which points at a directory that does not contain a META6.json) your META6.json isn't getting used at all. however, rakudo generates an in memory representation of what it thinks the META6.json should be (because it doesn't know one exists)

[12:28] *** derpydoo joined
[12:29] <discord-raku-bot> <nemokosch> that's only for running an executable, isn't it

[12:30] *** jpn joined
[12:30] <ugexe> i'm not sure i understand, but i'm inclined to say no it is for everything

[12:32] <ugexe> it is true that whatever your raku entry point is to run some code won't be precompiled. i.e. running `raku my-prog.raku` won't precompile that code, but running like `raku -e 'require "my-prog.raku";` should (I think) because in the second scenario my-prog.raku isn't the entry point (the one liner itself is)

[12:32] <ugexe> unning `raku my-prog.raku` won't precompile that code -> i mean running that won't precompile my-prog.raku, it will still precompile all the modules it uses

[12:34] <discord-raku-bot> <nemokosch> are we still talking about the case where the modules also depend on some modules in the folder?

[12:35] <ugexe> yes

[12:36] *** jpn left
[12:36] <discord-raku-bot> <nemokosch> okay, nice. Let me try to put this together, now

[12:39] <discord-raku-bot> <nemokosch> So there are some rakumod files in the lib folder, they voluntaristically require each other by path when they need to, and there is an executable that is going to use some of these modules. If I start this executable setting -Ilib (maybe could just contain use lib as well at this point?), it can retrieve the modules without triggering a new precompilation for any of them?

[12:39] <ugexe> can you clarify what you mean by require each other by path?

[12:40] <ugexe> do you mean `require "/path/to/module.rakumod"` or `use lib "/my/distribution/root"`?

[12:41] <discord-raku-bot> <nemokosch> we were talking about require most recently but I'm all "the ends justify the means" with this

[12:42] <discord-raku-bot> <nemokosch> all I want to achieve is precompilation kept for those rakumod files as well that don't appear in the provides section

[12:43] *** jpn joined
[12:45] <ugexe> the files that you aren't listing in provides... do they exist when you start your program?

[12:45] <ugexe> or are they created at runtime

[12:47] <ugexe> if they are created at runtime i'm not sure how/if that can work. if they exist when you start the program (which is generally going to be the case for most people) then yes it should precompile and do what you want with -Ilib

[12:47] <ugexe> raku -e 'my $cur = CompUnit::Repository::FileSystem.new(prefix => $*CWD.add("lib")); say $cur.distribution.meta<provides>.keys'

[12:48] <ugexe> if you run that snippet i suspect you'll see the files you don't list in the actual `provides` in the provides

[12:50] <discord-raku-bot> <nemokosch> the files do exist. The whole reason I want to not add them to the provides section is that the provides section is sort of a public interface towards all users; it's not sure if "users" even makes sense in the context, and not all modules are meant to be public API anyway

[12:51] <discord-raku-bot> <nemokosch> a provides-only-for-the-dist-itself would solve this problem, for example

[12:53] <ugexe> that does complicate things, but it is still possible via the `require $some-absolute-file-path.rakumod`. if this is going to be code you distribute then you'd want to create something that can absolutify the paths at runtime so to speak

[12:56] <discord-raku-bot> <nemokosch> it's good to know that this is possible - but I think it's also good to know that this is a complicated thing that one has a good reason not to try

[12:58] <discord-raku-bot> <nemokosch> this is nothing extraordinary for Node, though - I'm saying Node because that's what I'm most familiar with but I suspect that a lot of similar languages have a similar approach

[13:02] <ugexe> node can do what you are saying without exposing additional public api similar to what you mentioned earlier?

[13:02] <discord-raku-bot> <nemokosch> yes

[13:02] <discord-raku-bot> <nemokosch> I think the underlying idea is so common that people tend to even take it for granted: you want to have finegrained control over what you expose to users, while you want to keep modularity for your underlying "private" code

[13:05] *** edr joined
[13:07] *** jpn left
[13:10] <ugexe> i'm not entirely sure how that could work in raku with -Ilib specifically

[13:10] <ugexe> there wouldn't be a way for raku to know which files are private

[13:11] <ugexe> with -I. sure, it could be listed in some theoretical meta6.json key, but -Ilib needs to guess what that should be

[13:16] *** jpn joined
[13:19] <discord-raku-bot> <nemokosch> that's still better than nothing

[13:21] <discord-raku-bot> <nemokosch> I will check around with different languages as well, there is some PHP coming up anyway and I'm curious about Python as well...

[13:21] *** jpn left
[13:23] <ugexe> having it listed in provides is kinda better than nothing as well

[13:23] <discord-raku-bot> <nemokosch> I think this is an overlooked aspect of filesystem-based resolution: it simply doesn't get more decentralized than this. You can just start a local project and decompose it later, as it grows, you don't even need a META file... and when an ecosystem is based around that, you will "cherrypick" what you want to expose to the user either way, which is what you'd normally want

[13:24] <ugexe> like one could be a bit more explicit by doing `module Foo is implementation-detail { }'`

[13:24] <ugexe> technically its still exposed, but at least its explicit in that it isn't supported publically

[13:26] <ugexe> to generalize your problem further I would say yes META6.json needs a type of manifest listing for stuff like test files, but these type of private files could also probably leverage such a mechanism

[13:28] <discord-raku-bot> <nemokosch> regarding the provides section: since they are involved in the dependency-resolution on the ecosystem level, is implementation-detail really feels like monkeypatching

[13:29] <discord-raku-bot> <nemokosch> I still don't get why that was a good idea in the first place, making the modules the dependencies, that is

[13:29] *** jpn joined
[13:29] <ugexe> i imagine because it is the only way to build a dependency graph without actually running or parsing raku code

[13:30] <ugexe> so things like determining what order to precompile in most efficiently

[13:33] *** jpn left
[13:35] *** jpn joined
[13:35] <discord-raku-bot> <nemokosch> hm, not sure I get it. The metadata belongs to the dist so the conceptual jump has to happen somewhere, linking the module to the dist, but then we lose the possibility to link the module directly to another module...

[13:41] <ugexe> well that was all before precompilation

[13:41] <ugexe> i think

[13:41] <ugexe> so maybe my theory isn't correct

[13:42] <ugexe> hmm, or maybe precompilation existed but at the time it was up to panda/zef or whatever to do the precompilation

[13:43] <ugexe> because panda and zef used to both have regexes for parsing use/require statements to try and figure out the correct order to precompile (which was bad and didn't work a lot of times)

[13:43] <lizmat> fwiw, I dread the time when every Rakudo core compilation meant I needed to reinstall *all* modules

[13:44] <lizmat> I am *soooo* glad I don't have to do that anymore

[13:53] <discord-raku-bot> <nemokosch> I don't know what would be better to know: that modules-as-dependencies has a good technical reason (meaning it was actually well thought through) or that modules-as-dependencies is just a Perlish habit (meaning that it's just a sociocultural thing to roll out an alternative where dists are the dependencies)

[14:30] *** kjp left
[14:37] *** Manifest0 joined
[14:47] *** abraxxa left
[15:51] *** Vyrus left
[15:52] *** Vyrus joined
[15:52] *** perlbot left
[15:53] *** simcop2387 left
[15:53] *** simcop2387_ joined
[15:54] *** simcop2387_ is now known as simcop2387

[15:55] *** perlbot joined
[15:56] *** jpn left
[15:58] *** jpn joined
[16:05] *** Woodi joined
[16:06] *** Maylay left
[16:15] *** derpydoo left
[16:17] *** jpn left
[16:25] *** Woodi left
[16:26] *** Woodi joined
[16:33] *** derpydoo joined
[16:36] *** MoC joined
[16:36] *** dakkar left
[16:44] *** jpn joined
[16:48] <ugexe> i assume it would also help with things like the theoretical supercedes, superceded_by, and emulates meta6 fields

[16:49] <ugexe> although off the top of my head i'm not sure how

[16:49] *** spacekookie left
[16:50] <ugexe> but those all worked at the module level

[16:50] *** jpn left
[16:50] *** spacekookie joined
[16:51] <ugexe> see: https://github.com/Raku/old-design-docs/blob/master/S22-package-format.pod#emulates

[16:53] <ugexe> those kind of make sense at a module level instead of distribution level, since I think it would be more common to emulate modules than entire distributions (which I'm not sure what emulating a distribution would even mean)

[16:58] <tonyo> m: my Buf[uint8] $b .= new;  $b.append(1 +< 8); dd $b;

[16:58] <camelia> rakudo-moar 92485d66c: OUTPUT: «Buf[uint8] $b = Buf[uint8].new(0)␤»

[16:59] *** jpn joined
[17:03] *** jpn left
[17:13] *** jpn joined
[17:18] *** jpn left
[17:36] *** ProperNoun left
[17:43] *** grondilu joined
[17:44] * grondilu stumbled upon this:

[17:44] <grondilu> m: my Rational(Cool) $ = -my Rational(Cool) $ = 1

[17:44] <camelia> rakudo-moar 92485d66c: OUTPUT: «Impossible coercion from 'Num' into 'Rational': no acceptable coercion method found␤  in block <unit> at <tmp> line 1␤␤»

[17:44] <grondilu> Not sure why a Num is involved anywhere here.

[17:44] <grondilu> Especially since it works with Rat

[17:45] <grondilu> m: my Rat(Cool) $ = -my Rat(Cool) $ = 1

[17:45] <camelia> rakudo-moar 92485d66c: ( no output )

[17:45] <lizmat> vrurg might know

[17:46] <discord-raku-bot> <nemokosch> let's do a little QAST and parsing first, after all, the structure itself is kinda weird

[17:47] <discord-raku-bot> <grondilu> m: print (-my Rational(Cool) $ = 1).WHAT

[17:47] <discord-raku-bot> <Raku eval>  Use of uninitialized value of type Num in string context. Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.   in block <unit> at main.raku line 1 

[17:48] <grondilu> m: dd -my Rat(Cool) $ = 1

[17:48] <camelia> rakudo-moar 92485d66c: OUTPUT: «-1.0␤»

[17:48] <grondilu> m: dd -my Rational(Cool) $ = 1

[17:48] <camelia> rakudo-moar 92485d66c: OUTPUT: «-1e0␤»

[17:48] <grondilu> o_O

[17:49] <discord-raku-bot> <nemokosch> you win

[17:50] <discord-raku-bot> <nemokosch> m: dd -my Rat(Cool) $ = 1

[17:50] <discord-raku-bot> <Raku eval>  -1.0 

[17:50] <discord-raku-bot> <nemokosch> m: dd -my Rational(Cool) $ = 1

[17:50] <discord-raku-bot> <Raku eval>  -1e0 

[17:50] <discord-raku-bot> <nemokosch> okay, so same in 2022.02

[17:50] <discord-raku-bot> <nemokosch> m: dd -my Rational(Cool) $foobar = 1

[17:50] <discord-raku-bot> <Raku eval>  -1e0 

[17:50] <discord-raku-bot> <nemokosch> m: dd my Rational(Cool) $foobar = 1

[17:50] <discord-raku-bot> <Raku eval>  Rational $foobar = Rational.new(numerator => 1, denominator => 1) 

[17:51] <discord-raku-bot> <nemokosch> m: dd -Rational.new(numerator => 1, denominator => 1)

[17:51] <discord-raku-bot> <Raku eval>  -0e0 

[17:51] <discord-raku-bot> <nemokosch> uh oh xD

[17:51] <grondilu> it's very wrong, isn't it?

[17:51] <discord-raku-bot> <nemokosch> sourcery time

[17:53] <discord-raku-bot> <nemokosch> m: dd Rational.new(numerator => 1, denominator => 1).bridge

[17:53] <discord-raku-bot> <Raku eval>  Exit code: 1 No such method 'bridge' for invocant of type 'Rational'.  Did you mean 'Bridge'?   in block <unit> at main.raku line 1  

[17:53] <discord-raku-bot> <nemokosch> I did mean that

[17:53] <discord-raku-bot> <nemokosch> m: dd Rational.new(numerator => 1, denominator => 1).Bridge

[17:53] <discord-raku-bot> <Raku eval>  0e0 

[17:53] <discord-raku-bot> <nemokosch> so...

[17:53] <discord-raku-bot> <nemokosch> why? xD

[17:53] <lizmat> Rational.new takes 2 positionals

[17:53] <grondilu> I suppose there is no prefix:<-> candidate for Rational?

[17:53] <lizmat> m: say Rational.new(1,1)

[17:54] <camelia> rakudo-moar fbacec386: OUTPUT: «1␤»

[17:54] <lizmat> m: say Rational.new(1,2)

[17:54] <camelia> rakudo-moar fbacec386: OUTPUT: «0.5␤»

[17:54] <discord-raku-bot> <nemokosch> lizmat: then dd is a bit funny - but the conversion is still wrong

[17:54] <discord-raku-bot> <nemokosch> it should not become a floating point number

[17:54] <discord-raku-bot> <nemokosch> grondilu: that's right, it's all just Real

[17:55] <discord-raku-bot> <nemokosch> which Bridges straight into Num

[17:55] <lizmat> yeah, the .raku of Rational is wrong

[17:55] <grondilu> and that seems wrong.  Rat doesn't do that.

[17:55] *** AlexDaniel left
[17:56] *** sena_kun joined
[17:56] <discord-raku-bot> <nemokosch> yeah Rat constructs its own negation

[17:57] <discord-raku-bot> <nemokosch> it is a class, after all, unlike Real or Rational

[17:57] *** derpydoo left
[17:57] <grondilu> maybe it should inherit it from Rational instead, after we put it in Rational

[17:58] <grondilu> FYI I was using Rational as the type of an attribute as I wanted to make it possible to be a FatRat too, not just a Rat.

[17:59] <grondilu> someone tells me if there was a better way.

[17:59] <lizmat> grondilu: no, your thinking is correct

[18:03] <lizmat> grondilu nemokosch https://github.com/rakudo/rakudo/commit/54c5682f9d

[18:04] <grondilu> lizmat++ that's some quick fixing, thanks

[18:04] <grondilu> oh wait that's just the raku method?

[18:05] <lizmat> well, yeah, the problems stemmed from using the wrong interface to .new , did it not ?

[18:05] <grondilu> I don't think so

[18:05] <lizmat> ah, then I misunderstood

[18:06] <grondilu> my original issue was with prefix:<->

[18:06] <grondilu> m: my Rational(Cool) $ = -my Rational(Cool) $ = 1

[18:06] <camelia> rakudo-moar fbacec386: OUTPUT: «Impossible coercion from 'Num' into 'Rational': no acceptable coercion method found␤  in block <unit> at <tmp> line 1␤␤»

[18:06] <grondilu> m: my Rational(Cool) $ = +my Rational(Cool) $ = 1

[18:06] <camelia> rakudo-moar fbacec386: ( no output )

[18:07] <lizmat> I think the problem is really is coercion to a role

[18:07] <lizmat> should that be possible at all I wonder

[18:07] <lizmat> vrurg ^^

[18:08] *** jpn joined
[18:08] <lizmat> you'd be coercing to a pun of the role

[18:08] <gfldex> Not all roles can autopun.

[18:08] <lizmat> m: dd Rational.^pun

[18:08] <camelia> rakudo-moar fbacec386: OUTPUT: «Rational␤»

[18:09] <lizmat> looks like Rational thinks it can

[18:12] *** mfiano left
[18:28] <vrurg> lizmat: I'm not sure it makes much sense coercing into a role. If source object implements Rational method then it knows what the destination class is preferable.

[18:29] <lizmat> yeah, that'd be my point as well

[18:29] <lizmat> and maybe we shouldn't allow coercing into a role ?

[18:30] <vrurg> Otherwise if a role can't be punned (often times it's when there is a yada-yada method) the resulting error would create more confusion and complicate debugging.

[18:30] <vrurg> Disabling it would effectively disable it even if the source object implements a role-named method.

[18:32] <vrurg> Perhaps a more informative error message is needed for when no method is found and the coercion falls back to .CORECE/.new on the target. At this point we can intercept roles and abort proceedings.

[18:32] * vrurg is afk for ~1hr

[18:57] *** jpn left
[19:01] *** Sgeo joined
[19:06] *** jpn joined
[19:11] *** jpn left
[19:20] *** jpn joined
[19:22] *** kjp joined
[19:28] *** AlexDaniel joined
[19:28] *** jpn left
[19:36] *** jpn joined
[19:43] *** jpn left
[19:45] *** jpn joined
[19:56] *** donpdonp left
[20:00] *** MoC left
[20:05] *** jpn left
[20:06] *** jpn joined
[20:14] *** sena_kun left
[20:50] <grondilu> In the docs they say Real is the "Common role for non-Complex numbers.", but they're not really reals, are they?

[20:51] <grondilu> Like, this afternoon I was trying to define a type for so-called quadratic irrationals, and I struggled to make it work as a "Real".

[20:52] <discord-raku-bot> <nemokosch> why?

[20:53] <grondilu> I'm struggling with the comparison operators, but now that I think about it again, I may be at fault.

[20:55] <grondilu> I was hoping I could define infix:[<=>] and that then the other ones, like infix:[<], infix:[>] and so on would be deduced.  It does not seem so.

[20:56] <grondilu> m: class Foo does Real {}; multi infix:<<<=>>>(Foo, $) { Same }

[20:56] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> ass Foo does Real {}; multi infix:<<<=>>⏏>(Foo, $) { Same }␤    expecting any of:␤        new name to be defined␤»

[20:56] <grondilu> m: class Foo does Real {}; multi infix:[<=>](Foo, $) { Same }

[20:56] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Cannot override infix operator '=', as it is a special form handled directly by the compiler␤at <tmp>:1␤------> lass Foo does Real {}; multi infix:[<=>]⏏(Foo, $) { Same }␤»

[20:57] <grondilu> m: class Foo does Real {}; multi infix:«<=>»(Foo, $) { Same }

[20:57] <camelia> rakudo-moar 7dc21fcff: ( no output )

[20:57] <grondilu> hang n

[20:57] <grondilu> *on

[20:57] <grondilu> m: class Foo does Real {}; multi infix:«<=>»(Foo, $) { Same }; say Foo.new <=> pi

[20:57] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «MoarVM panic: Memory allocation failed; could not allocate 131072 bytes␤»

[20:58] <grondilu> not too dissimilar from the issues I was facing.  Often the program was hanging on a loop until it consumed all memory and broke my terminal.

[20:59] <grondilu> I wasn't asking much in this tiny example, though.

[20:59] <grondilu> Overall I find defining custom Real classes hard.

[21:00] <grondilu> Even though that would be useful, as there are plenty of real types in math that can be useful.

[21:01] <grondilu> Is there a module that provides a nice example of a custom Real class?

[21:02] <grondilu> For what it's worth here is a snapshot of what I was trying to do: https://gist.github.com/grondilu/b70fb0d8abac36221f0d763f3a7317c6

[21:03] <grondilu> every time I try to mix in the Real role, I get errors.

[21:07] <discord-raku-bot> <nemokosch> you definitely cannot expect the others to be "deduced"

[21:08] <discord-raku-bot> <nemokosch> overloading is pretty much "all or nothing" business

[21:09] <grondilu> really?  Should there be an abstract class mechanism or something?

[21:09] <grondilu> *shoudn't

[21:10] <discord-raku-bot> <nemokosch> I think that would be weak typing hell on steroids, and Raku already has kind of a bad rap

[21:10] <discord-raku-bot> <nemokosch> when there are default implementations to fall back to, it's at least predictable that whatever you don't overload will fall back to the default

[21:11] <grondilu> shouldn't `$a < $b` always mean `$a <=> $b ~~ Less` ?

[21:11] <discord-raku-bot> <nemokosch> what would "always" even mean?

[21:11] <discord-raku-bot> <nemokosch> what if somebody overloads it specifically, for whatever reason?

[21:12] <grondilu> well, by default at least.

[21:12] <discord-raku-bot> <nemokosch> by default, all of these operands have a certain behavior, you started the overloading business

[21:12] <discord-raku-bot> <nemokosch> actually, I was about to suggest checking whether it's possible to manage with the default

[21:13] <grondilu> I mean that semantic could be in the Real role, it's high enough in the inheritance tree to be easily overloadable.

[21:13] <discord-raku-bot> <antononcube> Clickbait -- "Jupyter Chatbook multi cell LLM chats teaser (Raku)" : https://youtu.be/wNpIGUAwZB8

[21:14] <discord-raku-bot> <nemokosch> in general it's better to first think of a non-overloading solution whenever there is a default behavior

[21:15] <discord-raku-bot> <nemokosch> the core itself is guilty of not following this principle close enough - even though I didn't make it up, Larry Wall collected it in the "seeing right wrong" article

[21:15] <grondilu> Honestly it's like infix:<**>.  I don't understand why I always have to rewrite it every time I implement a Numeric-like class.

[21:17] <grondilu> same for prefix:<->, prefix:<+> and so on.  Either I'm doing something wrong, or the Numeric role is incomplete.

[21:18] <discord-raku-bot> <nemokosch> I think you should overload none here

[21:18] <discord-raku-bot> <nemokosch> https://docs.raku.org/routine/Bridge

[21:19] <discord-raku-bot> <nemokosch> I suspected this was the intention with Bridge but actually, it's stated in the docs

[21:19] <discord-raku-bot> <nemokosch> so you should just derive from Real and implement the Bridge method

[21:19] <grondilu> I'm pretty sure I had tried using the bridge before, but it's no good.

[21:20] <grondilu> as they say in the doc, `Bridge` returns one of the *core* type. 

[21:20] <discord-raku-bot> <nemokosch> if you can show code, maybe we can dig something out. The principle seems fairly straightforward

[21:20] <discord-raku-bot> <nemokosch> that's only up to you I think what you make it return

[21:21] <grondilu> hum...

[21:21] <grondilu> I guess I should try with a toy model.

[21:22] <discord-raku-bot> <nemokosch> oh, I see the point

[21:22] <discord-raku-bot> <nemokosch> if the implementation of > is "call Bridge and then do >"

[21:22] <discord-raku-bot> <nemokosch> then we're at zero squared

[21:23] <grondilu> well yeah

[21:23] <discord-raku-bot> <nemokosch> well, this is not terribly useful tbh

[21:23] <grondilu> instead what I really want is an abstract class

[21:24] <grondilu> that is one that would be in the core and that I could use as a basic algebraic type template.

[21:24] <grondilu> so that I don't have to reinvent the wheel all the time.

[21:25] <grondilu> I thought Real or Numeric functioned like that.  I guess I was wrong.

[21:26] *** rf joined
[21:28] <discord-raku-bot> <nemokosch> core or not, there could be a trait for defining mundane stuff like the one you said, "define a walrus operator and deduce all numeric comparisons from that"

[21:30] <grondilu> pretty much

[21:30] <discord-raku-bot> <nemokosch> I guess even a role would do

[21:31] <grondilu> oh you mean a user-space role?

[21:31] * grondilu hadn't thought about that

[21:32] <discord-raku-bot> <nemokosch> well, that's easier to set off than something new in the core

[21:32] <grondilu> you're right

[21:33] <discord-raku-bot> <nemokosch> well, let me try, I have basically never created a role but hey, no pain no gain

[21:34] <grondilu> naming is going to bug me though, as it's competing with what the core Real and Numeric should do.

[21:35] <discord-raku-bot> <nemokosch> for now I was only thinking of a role that supplies comparisons from a walrus operator

[21:36] <grondilu> you could call it "Ordered"

[21:36] *** deoac joined
[21:36] <grondilu> or "Order"

[21:36] <lizmat> m: dd Order

[21:36] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «Order␤»

[21:37] <grondilu> oh yeah

[21:37] <discord-raku-bot> <nemokosch> it's a total order even, isn't it?

[21:38] <grondilu> I don't think so.  

[21:38] <grondilu> I seem to recall that < is total order.  ≤ is partial order.

[21:38] <grondilu> Nope, it's the opposite.  My bad.

[21:39] <discord-raku-bot> <nemokosch> seems like total ordering is partial ordering, plus either a <=b or b <= a is true

[21:40] <grondilu> yeah, I confused terms.

[21:42] <discord-raku-bot> <nemokosch> hm, the only thing that can get in the way with a role is that these operators are global functions...

[21:42] <grondilu> m: role Comparison { method compare($ --> Order) {...} }; multi method infix:«<=>»(Comparison $a, Comparison $b) { $a <=> $b } }

[21:42] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «===SORRY!===␤Unexpected closing bracket␤at <tmp>:1␤------> arison $a, Comparison $b) { $a <=> $b } ⏏}␤Other potential difficulties:␤    Useless declaration of a has-scoped multi-method in mainline (did you mean 'my method infi…»

[21:42] <grondilu> m: role Comparison { method compare($ --> Order) {...} }; multi method infix:«<=>»(Comparison $a, Comparison $b) is export { $a <=> $b } }

[21:42] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «===SORRY!===␤Unexpected closing bracket␤at <tmp>:1␤------>  Comparison $b) is export { $a <=> $b } ⏏}␤Other potential difficulties:␤    Useless declaration of a has-scoped multi-method in mainline (did you mean 'my method infi…»

[21:43] <grondilu> m: role Comparison { method compare($ --> Order) {...} }; my multi method infix:«<=>»(Comparison $a, Comparison $b) { $a <=> $b } }

[21:43] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> arison $a, Comparison $b) { $a <=> $b } ⏏}␤»

[21:43] <grondilu> m: role Comparison { method compare($ --> Order) {...} }; my multi method infix:«<=>»(Comparison $a, Comparison $b) { $a <=> $b }

[21:43] <camelia> rakudo-moar 7dc21fcff: ( no output )

[21:43] <grondilu> nah that's wrong

[21:44] <grondilu> m: role Comparison { method compare($ --> Order) {...} }; my multi method infix:«<=>»(Comparison $a, Comparison $b) { $a.compare: $b }

[21:44] <camelia> rakudo-moar 7dc21fcff: ( no output )

[21:45] <grondilu> maybe "Comparable" instead

[21:46] <discord-raku-bot> <nemokosch> oh so you are planning to define the operators for the role?

[21:46] <grondilu> m: role Comparable { method compare($ --> Order) {...} }; my multi method infix:«<=>»(Comparable $a, Comparable $b) { $a.compare: $b }; my multi method infix:«<»(Comparable $a, Comparable $b) { $a.compare($b) ~~ Less }

[21:46] <camelia> rakudo-moar 7dc21fcff: ( no output )

[21:46] <grondilu> nemokosch: yeah, that is the point.

[21:48] <grondilu> m: role Comparable { method compare($ --> Order) {...} }; my multi method infix:«<=>»(Comparable $a, Comparable $b) { $a.compare: $b }; my multi method infix:«<»(Comparable $a, Comparable $b) { $a.compare($b) ~~ Less }; class Foo does Comparable { method compare($x) { Order.pick } };

[21:48] <camelia> rakudo-moar 7dc21fcff: ( no output )

[21:49] <grondilu> m: role Comparable { method compare($ --> Order) {...} }; my multi method infix:«<=>»(Comparable $a, Comparable $b) { $a.compare: $b }; my multi method infix:«<»(Comparable $a, Comparable $b) { $a.compare($b) ~~ Less }; class Foo does Comparable { method compare($x) { Order.pick } }; say Foo.new <=> Foo.new

[21:49] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «Too few positionals passed; expected 3 arguments but got 2␤  in method infix:«<=>» at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[21:50] <grondilu> oh I defined a method instead of a sub, silly me

[21:50] <discord-raku-bot> <nemokosch> gotcha

[21:50] <grondilu> m: role Comparable { method compare($ --> Order) {...} };  multi infix:«<=>»(Comparable $a, Comparable $b) { $a.compare: $b };  multi infix:«<»(Comparable $a, Comparable $b) { $a.compare($b) ~~ Less }; class Foo does Comparable { method compare($x) { Order.pick } }; say Foo.new <=> Foo.new

[21:50] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «More␤»

[21:51] <grondilu> m: role Comparable { method compare($ --> Order) {...} };  multi infix:«<=>»(Comparable $a, Comparable $b) { $a.compare: $b };  multi infix:«<»(Comparable $a, Comparable $b) { $a.compare($b) ~~ Less }; class Foo does Comparable { method compare($x) { Order.pick } }; say Foo.new < Foo.new

[21:51] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «False␤»

[21:51] <grondilu> something like that

[21:56] <grondilu> To me, the Numeric role should have 'add', 'subtract', 'multiply', 'divide' and maybe 'compare' virtual methods.  Then to the risk of oversimplifying it, I would say that someone wanting to create his own numeric type would only have to define these methods and be done with it. 

[21:56] *** AlexDaniel left
[22:03] <discord-raku-bot> <nemokosch> originally, the div and mod methods were meant to be such generic operators

[22:05] <discord-raku-bot> <nemokosch> by the way, I was hoping to dynamically generate the operators so that the signature contains the exact type... that's beyond my level

[22:08] <grondilu> m: role R { method what { ::?CLASS } }; say class Foo does R {}.new.what 

[22:08] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «(Foo)␤»

[22:08] <grondilu> you can use ::?CLASS

[22:09] <grondilu> m: role R { method what returns ::?CLASS {...} }; say class Foo does R { method what { Foo } }.new.what 

[22:09] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «(Foo)␤»

[22:10] <grondilu> m: role R { method what returns ::?CLASS {...} }; use Test; dies-ok { say class Foo does R { method what { Mu } }.new.what }

[22:10] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «(Mu)␤not ok 1 - ␤# Failed test at <tmp> line 1␤»

[22:10] <grondilu> hum

[22:11] <grondilu> m: role R { method what returns ::?CLASS {...} }; say class Foo does R { method what { Mu } }.new.what

[22:11] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «(Mu)␤»

[22:12] <grondilu> not sure if that is correct

[22:24] *** deoac left
[22:45] *** deoac joined
[22:52] <ugexe> Why?

[22:52] <ugexe> doesnt Mu match damn near anything?

[22:53] <ugexe> (Is on the phone so cant probe into it)

[22:59] <tonyo> looks like the .what in Foo just overrides the role method, which is what i'd expect

[23:05] <grondilu> well ok I suppose overloading a method is not just about the body, but also the return type.  Fair enough, I guess.

[23:06] <grondilu> I'll check if it's the same with class inhertance, though.

[23:06] <grondilu> m: class A { method foo returns Str {...} }; class B is A { method foo returns Blob {...} }; 

[23:06] <camelia> rakudo-moar 7dc21fcff: ( no output )

[23:06] <grondilu> m: class A { method foo returns Str {...} }; class B is A { method foo returns Blob {...} }; say B.new

[23:06] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «B.new␤»

[23:07] <grondilu> yeah that's not too suprising.

[23:07] <grondilu> m: class A { method foo returns Str {...} }; class B is A { method foo returns Blob { Blob.new } }; say B.new.foo  # just one more check

[23:07] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «Blob:0x<>␤»

[23:08] <grondilu> m: role A { method foo returns Str {...} }; class B does A { method foo returns Blob { Blob.new } }; say B.new.foo  # just one more check

[23:08] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «Blob:0x<>␤»

[23:17] <ugexe> I think if you make it a multi the signature will matter more 

[23:17] <ugexe> The interface method 

[23:18] <ugexe> m: role A { multi method foo returns Str {...} }; class B does A { multi method foo returns Blob { Blob.new } };

[23:18] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Multi method 'foo' with signature :(B: *%_ --> Str) must be implemented by B because it is required by a role␤at <tmp>:1␤»

[23:19] <grondilu> here is an other issue : I can't overload prefix:<-> from a compunit.

[23:20] <grondilu> m: class A does Real { method Bridge {...}; multi prefix:<->(::?CLASS $) is export { rand } }; import A; say -A.new

[23:20] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «0.8016484849660362␤»

[23:20] <grondilu> ^this works fine, but not if I put A in a file as a compunit.

[23:20] <ugexe> What if you put no precompilation in it?

[23:20] <grondilu> wdym

[23:21] <grondilu> rm -rf .precomp?

[23:21] <ugexe> I thought there was some issue regarding precompilation overriding the candidate or some such 

[23:21] <ugexe> no, the pragma 

[23:21] <ugexe> ‘no precompilation;’

[23:21] * grondilu tries

[23:22] <grondilu> lol nevermind I was running the wrong command.  sorry

[23:29] *** lichtkind left
[23:35] *** rf left
[23:36] *** rf joined
[23:36] *** rf left
[23:36] *** rf joined
[23:43] <grondilu> hum, in Real there is `method abs()  { self < 0 ?? -self !! self }`, yet I can't use it:

[23:44] <grondilu> m: class A does Real { method Bridge {...} }; multi sub infix:«<»(A, 0) { Bool.pick }; multi sub prefix:<->(A) { rand }; say A.new.abs

[23:44] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «Stub code executed␤  in method Bridge at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[23:45] <grondilu> why is it trying to call Bridge here??

[23:45] <grondilu> oh wait

[23:46] <grondilu> the new sub candidates are not visible inside Real or something?

[23:52] <grondilu> I suppose I was trying to apply the concept of abstract class for subs, not methods.

[23:52] <grondilu> And only methods can be abstract, not subs, perhaps.

[23:58] <grondilu> m: role A { sub foo { "A::foo!" }; method bar { foo } }; say class B does A { sub foo { "B::foo!" }; }.bar

[23:58] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «A::foo!␤»

[23:58] <grondilu> m: role A { sub foo {...}; method bar { foo } }; say class B does A { sub foo { "B::foo!" }; }.bar

[23:58] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «Stub code executed␤  in sub foo at <tmp> line 1␤  in method bar at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[23:59] <grondilu> m: role A { sub foo {...}; method bar { ::?CLASS::foo() } }; say class B does A { sub foo { "B::foo!" }; }.bar

[23:59] <camelia> rakudo-moar 7dc21fcff: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------>  { sub foo {...}; method bar { ::?CLASS:⏏:foo() } }; say class B does A { sub foo␤    expecting any of:␤        colon pair␤»

[23:59] <discord-raku-bot> <nemokosch> because the comparison itself relies on the bridge

[23:59] <discord-raku-bot> <nemokosch> the self < 0 bit

