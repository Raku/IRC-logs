[00:00] *** reportable6 left
[00:02] *** reportable6 joined
[00:05] *** rf joined
[00:29] *** ProperNoun joined
[00:29] *** epony left
[00:36] *** lichtkind left
[00:48] <leont> Skarsnik: you can work around the dot in @INC issue by setting the PERL_USE_UNSAFE_INC environmental variable

[01:04] *** xinming left
[01:04] *** xinming_ left
[01:05] *** xinming joined
[01:06] *** xinming_ joined
[01:28] <discord-raku-bot> <Nemokosch> a fun little task (I hope):

[01:28] <discord-raku-bot> <Nemokosch> what does the following snippet achieve?

[01:29] <discord-raku-bot> <Nemokosch> $descriptor.comb.skip >>ne>> '-' andthen

[01:29] <discord-raku-bot> <Nemokosch> $_>>.Int.join.parse-base(2).base(8)

[01:29] <discord-raku-bot> <Nemokosch> inb4 I'm absolutely sure there can be corner cases this doesn't account for, but if you can notice that, you probably won 😛

[01:50] *** deoac joined
[01:59] *** razetime joined
[02:02] *** razetime1 joined
[02:03] *** razetime left
[02:03] *** razetime1 is now known as razetime

[02:38] *** epony joined
[03:27] *** rf left
[03:56] *** deoac left
[04:37] *** sftp left
[04:38] *** sftp joined
[05:04] *** [Coke]_ joined
[05:04] *** [Coke] left
[05:16] *** alfonsox joined
[05:44] *** Kaiepi left
[06:00] *** reportable6 left
[06:03] *** reportable6 joined
[07:03] *** greppable6 left
[07:03] *** evalable6 left
[07:03] *** bloatable6 left
[07:03] *** coverable6 left
[07:03] *** committable6 left
[07:03] *** statisfiable6 left
[07:03] *** releasable6 left
[07:03] *** bisectable6 left
[07:03] *** benchable6 left
[07:03] *** unicodable6 left
[07:03] *** notable6 left
[07:03] *** sourceable6 left
[07:03] *** squashable6 left
[07:03] *** quotable6 left
[07:03] *** nativecallable6 left
[07:03] *** reportable6 left
[07:03] *** tellable6 left
[07:03] *** linkable6 left
[07:03] *** shareable6 left
[07:03] *** bloatable6 joined
[07:03] *** statisfiable6 joined
[07:04] *** committable6 joined
[07:04] *** tellable6 joined
[07:04] *** evalable6 joined
[07:04] *** releasable6 joined
[07:04] *** greppable6 joined
[07:04] *** linkable6 joined
[07:04] *** shareable6 joined
[07:05] *** notable6 joined
[07:05] *** quotable6 joined
[07:05] *** reportable6 joined
[07:05] *** nativecallable6 joined
[07:05] *** benchable6 joined
[07:05] *** coverable6 joined
[07:05] *** squashable6 joined
[07:06] *** sourceable6 joined
[07:06] *** bisectable6 joined
[07:06] *** unicodable6 joined
[07:13] *** Homer_Simpson joined
[07:19] *** abraxxa joined
[07:23] *** abraxxa left
[07:25] *** abraxxa joined
[07:28] *** abraxxa1 joined
[07:29] *** abraxxa left
[07:40] *** xinming left
[07:40] *** xinming joined
[07:53] <discord-raku-bot> <jaguart> nemokosch: This is the updated grok of a compunit https://gist.github.com/jaguart/9c69db9d8d281ed49c69a9c379756dcf

[07:55] <discord-raku-bot> <jaguart> the CompUnit contains a Distribution and a set of namespaces aka Packages and Modules. In this example Foo is a unit module, with two roles and two classes

[07:58] <discord-raku-bot> <jaguart> One interesting thing I discovered is that  auth/ver/api attributes are only populated on top level modules. If I change from `unit module Foo:auth<me>` to `unit module Foo::Bar:auth<me>` the :auth is no longer present/available (or at least I cant spot it in the MOP)

[08:13] *** Sgeo left
[09:09] <discord-raku-bot> <Skarsnik> nvm, I still got the multiple redefinition of symbol error for mid 2018 to 2019

[09:13] *** dakkar joined
[09:24] <discord-raku-bot> <Skarsnik> 2020.02 fixed this x)

[09:25] *** jpn joined
[09:26] *** sena_kun joined
[09:33] *** Homer_Simpson left
[09:35] *** lichtkind joined
[09:37] *** xinming left
[09:57] *** xinming joined
[10:05] *** sena_kun left
[10:10] *** sena_kun joined
[10:10] *** sena_kun left
[10:20] *** grondilu joined
[10:44] *** Kaiepi joined
[11:01] <grondilu> any reason `reduce * ~^ *, ` would not be the same as `[~^]` ?  I can't replace the former with the latter in https://github.com/grondilu/pbkdf2-raku/blob/main/lib/PBKDF2.rakumod

[11:02] <nine> jaguart: I think it depends more on how a package gets created whether it inherits those attributes or not. Support was just added to one code path. Grep for pkg_create_mo in rakudo src

[11:02] <grondilu> Also unfortunately I can't reproduce the error in a simple one-liner.

[11:03] <grondilu> (I haven't tried very hard though, ngl)

[11:06] <discord-raku-bot> <Nemokosch> grondilu: well, what happens in one case and another?

[11:09] *** sena_kun joined
[11:13] *** jpn left
[11:22] <grondilu> Nemokosch: It works fine with `reduce` and I get a stringification of Blob error with `[ ]` 

[11:22] <tellable6> grondilu, I'll pass your message to Nemokosch

[11:23] <dakkar> grondilu: random thought: `($seed, { foo } ... *)[1..$c]` may be better written `({ foo } ... *)[^$c]`

[11:23] <dakkar> (this does not actually relate to your question)

[11:24] <grondilu> dakkar: noted

[11:26] *** jpn joined
[11:28] <grondilu> dakkar: actually, no.  I don't want the first element of the sequence, and &foo does take an argument so you can't just remove $seed.

[11:28] <dakkar> grondilu: I'm not familiar with pbkdf2, what would be some arguments to run it with?

[11:28] <dakkar> aaaaah, sorry, I had mis-parsed the sequence operator!

[11:29] <grondilu> you can use the synopsis in the README

[11:29] <grondilu> https://github.com/grondilu/pbkdf2-raku

[11:29] * dakkar does that

[11:31] <grondilu> if you don't want to install MD5 you can make up a dumb prf function.  It just needs to take two args that can be converted into blob8 and it must return a blob8

[11:32] <dakkar> uh… I have replaced the line `reduce * ~^ *, (` with `[~^] (` and I get the same blob in output

[11:32] <grondilu> really?  odd.

[11:32] <dakkar> running on v2022.06

[11:33] <grondilu> oh you're right it does work with the synopsis

[11:34] <grondilu> I was using the other test file

[11:34] * dakkar installs Digest::HMAC

[11:35] <discord-raku-bot> <Nemokosch> uh oh

[11:35] <dakkar> which zef can't find…

[11:35] <discord-raku-bot> <Nemokosch> wait what? that's new

[11:36] <grondilu> Digest::HMAC is the name of a module in the Digest repo

[11:36] <discord-raku-bot> <Nemokosch> not anymore though, right?

[11:36] <grondilu> huh

[11:36] <grondilu> oh yeah

[11:37] <discord-raku-bot> <Nemokosch> that's what sparked the whole topic of module-dependencies

[11:39] <discord-raku-bot> <Nemokosch> for what it's worth, I still can't install Digest::HMAC because of test failures

[11:39] * grondilu reinstalls his Digest module 

[11:41] <discord-raku-bot> <Nemokosch> oh right, your module used to provide Digest

[11:41] <discord-raku-bot> <Nemokosch> now the module vs distribution polemy bit the other way around...

[11:43] <grondilu> well now the name of the module is just HMAC.  The name of the repo is still Digest.

[11:43] <discord-raku-bot> <Nemokosch> I don't mean this in a bad way, just curious. Did you know that the modules you provide are essentially the API of your distribution?

[11:44] <grondilu> Nemokosch:  I am not quite sure about what you mean

[11:44] <tellable6> grondilu, I'll pass your message to Nemokosch

[11:44] <discord-raku-bot> <Nemokosch> and hence eliminating the Digest *module* was an API-breaking change either way?

[11:44] <grondilu> I knew it would necessarily break things in any case.

[11:45] <grondilu> but I really wasn't happy with how the module was organized anyway.

[11:45] <discord-raku-bot> <Nemokosch> although to be frank, if something didn't specify at least the api field for a dependency, it would still break...

[11:45] <grondilu> there is an api field?

[11:46] * grondilu looks up https://docs.raku.org/language/modules

[11:46] <grondilu> oh yeah there is

[11:47] <discord-raku-bot> <Nemokosch> Yes, not sure how it would integrate with semver tbh, maybe it's just more explicit

[11:47] <discord-raku-bot> <Nemokosch> but where I'm getting at is that when you change the provides section, that's arguably a breaking change on the biggest possible level

[11:47] <grondilu> damn I guess this repo will need quite a bit of cleaning

[11:49] <grondilu> I'll submit an issue refering this conversation for memorandum

[11:50] <discord-raku-bot> <Nemokosch> this may be somewhat selfish of me but I think all these precedents are very good for eliminating the whole "recommendation-manager" logic in dependency resolution

[11:50] <discord-raku-bot> <Nemokosch> Of course there is the path of always blaming it on the author or the user...

[11:51] * grondilu submitted https://github.com/grondilu/libdigest-raku/issues/36

[11:52] <discord-raku-bot> <Nemokosch> but really, what if someone decides to break up a module while leaving the rest of the modules untouched (pretty much what you did)? That's a breaking change on compunit level so you might want to reflect that with the versions. Now, simply because versioning happens at META6 level, all your other modules will jump to a version marked as breaking, even though they could be used just like before

[11:54] <grondilu> I should have at least changed the major version number, that's for sure.

[11:54] <discord-raku-bot> <Nemokosch> And again, I don't find it constructive to just blame this on the author. Things change over time, including our knowledge. It's still a best interest of everyone to only break when necessary.

[11:55] <discord-raku-bot> <Nemokosch> My 2 cents is, what you could have done is to still provide the Digest module, as something that just re-exports the stuff from its new location.

[11:55] <grondilu> there is no need to blame anyone for anything.  There's a reason for the disclaimer in the license.

[11:55] *** xinming left
[11:55] *** xinming joined
[11:57] <discord-raku-bot> <Nemokosch> Well, I think it's valid to blame the language spec itself for this bizarre idea inherited from Perl.

[11:57] <grondilu> Nemokosch:  at the time I didn't know how to re-export stuff without just copy-pasting.

[11:57] <tellable6> grondilu, I'll pass your message to Nemokosch

[11:57] <discord-raku-bot> <Nemokosch> that metadata comes from distributions, installation happens on distribution level, yet dependency resolution is tied to modules

[11:58] <dakkar> grondilu: the problem is the `:c(1)`

[11:58] <dakkar> change that to `:c(2)` and now both `reduce` and `[~^]` work the same

[11:58] <grondilu> dakkar: is it? Interesting.

[11:58] <dakkar> (I'm now trying to figure out why)

[11:59] <dakkar> essentially, `[~^] ($thing)` works differently from `reduce * ~^ *, ($thing)`

[11:59] <grondilu> m: say [~^] "foo".encode

[11:59] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «foo␤»

[11:59] <discord-raku-bot> <Nemokosch> why does it?

[12:00] *** reportable6 left
[12:00] <dakkar> m: say [~^] (Buf.new(1..10))

[12:00] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Stringification of a Buf is not done with 'Stringy'.  The 'decode'␤method should be used to convert a Buf to a Str.␤  in block <unit> at <tmp> line 1␤␤»

[12:00] <dakkar> m: say [~^] Buf.new(1..10)

[12:00] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Stringification of a Buf is not done with 'Stringy'.  The 'decode'␤method should be used to convert a Buf to a Str.␤  in block <unit> at <tmp> line 1␤␤»

[12:00] <grondilu> wait it returned a Str?

[12:00] <dakkar> no?

[12:01] <grondilu> m: say [~^] "foo".encode # should return a blob

[12:01] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «foo␤»

[12:01] <dakkar> oh

[12:01] <grondilu> m: say [~^] "foo".encode xx 2

[12:01] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «utf8:0x<00 00 00>␤»

[12:01] <discord-raku-bot> <Nemokosch> > [~^] utf8.new(102,111,111)

[12:01] <discord-raku-bot> <Nemokosch> does return a Str

[12:01] <grondilu> well that is wrong, I think

[12:01] <dakkar> m: say ([~^] (Buf.new(1..10), Buf.new(1..10),)).raku;

[12:01] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Buf.new(0,0,0,0,0,0,0,0,0,0)␤»

[12:02] <dakkar> no, it's a buf, `say` calls `.gist` on it that may stringify it

[12:02] <discord-raku-bot> <Nemokosch> if I do my &op = * ~^ *; [[&op]] utf8.new(102,111,111) - that returns utf8

[12:02] *** reportable6 joined
[12:03] <grondilu> say doesn't stringify a blob, that's precisely what the error message said in the first place

[12:03] <grondilu> m: say "foo".encode

[12:03] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «utf8:0x<66 6F 6F>␤»

[12:03] <grondilu> hang on

[12:04] <grondilu> that's an utf8 blob.  I guess that's special

[12:04] <dakkar> m: say (reduce * ~^ *, ( Buf.new(1..10) )).raku;

[12:04] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Buf.new(1,2,3,4,5,6,7,8,9,10)␤»

[12:04] <discord-raku-bot> <Nemokosch> utf8 is a specific blob

[12:04] <dakkar> m: say ([~^] ( Buf.new(1..10) )).raku;

[12:04] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Stringification of a Buf is not done with 'Stringy'.  The 'decode'␤method should be used to convert a Buf to a Str.␤  in block <unit> at <tmp> line 1␤␤»

[12:04] <grondilu> ^here

[12:04] <dakkar> m: [~^] ( Buf.new(1..10) )

[12:04] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Potential difficulties:␤    Useless use of [~^] in sink context␤    at <tmp>:1␤    ------> <BOL>⏏[~^] ( Buf.new(1..10) )␤Stringification of a Buf is not done with 'Stringy'.  The 'decode'␤method should be used to convert a Buf to a …»

[12:04] <dakkar> no say, no print, no anything, still explodes

[12:05] <grondilu> another case of degeneracy issue

[12:05] <discord-raku-bot> <Nemokosch> it's a warning probably

[12:05] *** xinming left
[12:05] <dakkar> m: [~^] ( Buf.new(1..10) );say "was a warning"

[12:05] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Potential difficulties:␤    Useless use of [~^] in sink context␤    at <tmp>:1␤    ------> <BOL>⏏[~^] ( Buf.new(1..10) );say "was a warni␤Stringification of a Buf is not done with 'Stringy'.  The 'decode'␤method should be used to co…»

[12:06] <dakkar> m: my $a=[~^] ( Buf.new(1..10) );say "was a warning"

[12:06] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Stringification of a Buf is not done with 'Stringy'.  The 'decode'␤method should be used to convert a Buf to a Str.␤  in block <unit> at <tmp> line 1␤␤»

[12:06] <dakkar> nope, it's an exception and it terminates the program

[12:07] *** xinming joined
[12:07] <discord-raku-bot> <Nemokosch> okay

[12:07] <discord-raku-bot> <Nemokosch> Buf.new is still kinda morbid imo

[12:08] <dakkar> m: my $a= reduce &infix:<~^>, ( Buf.new(1..10) );

[12:08] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «Stringification of a Buf is not done with 'Stringy'.  The 'decode'␤method should be used to convert a Buf to a Str.␤  in block <unit> at <tmp> line 1␤␤»

[12:08] <dakkar> ok, so it's got something to do with the operator… probably its identity value

[12:08] *** jjido joined
[12:09] <dakkar> because we're reducing a 1-element list with a binary operator

[12:09] <discord-raku-bot> <Nemokosch> now that's a great observation

[12:10] <dakkar> so `reduce` has to guess what to pass to the operator as its first argumnent, and it picks the operator's identity value… which I'm not sure how to access

[12:10] <dakkar> m: dd [~^]

[12:10] <camelia> rakudo-moar 212e5e6eb: OUTPUT: «""␤»

[12:11] <dakkar> aha! there's our string

[12:11] <dakkar> grondilu: so, solution is: don't pass a 1-element list to the reduce stop

[12:11] <dakkar> step

[12:11] <dakkar> (because the result would be very unclear anyway…)

[12:11] <discord-raku-bot> <Nemokosch> look: https://github.com/rakudo/rakudo/blob/2022.12/src/core.c/Stringy.pm6#L77

[12:11] <dakkar> (it's now lunchtime for me, see you in an hour or so)

[12:12] <dakkar> also https://github.com/rakudo/rakudo/blob/2022.12/src/core.c/Stringy.pm6#L66-L69

[12:14] <discord-raku-bot> <Nemokosch> anyway, it seems to me that ~^ is not even meant to be used here

[12:15] <discord-raku-bot> <Nemokosch> UNLESS you do want to get a string

[12:19] <discord-raku-bot> <Nemokosch> oh right, it was line 68, I miswrote it to prefix

[12:22] <discord-raku-bot> <Nemokosch> meh, now I can see that there is no other buffer operator for binary stuff

[12:27] <discord-raku-bot> <Nemokosch> I think this is something to fix, if not two things to fix. Whether a random Buf role should be coerceable with .Stringy is one question - but that the default shouldn't be an empty string *for all types*, that's fairly certain

[12:28] <discord-raku-bot> <Anton Antonov> I want to (re-)implement a spellchecker that produces suggestions of misspelled words taking into account the surrounding words. What would be a good namespace for it? I consider "ML::Spellchecker", "ML::PhrasalSpellchecker", "ML::ContextualSpellchecker". (For a brief time I considered using "Lingua::*", but the design I have in mind "learns" from textual data.)

[12:35] <lizmat> ML::ContextualSpellchecker feels good to me

[12:39] *** simcop2387 left
[12:40] *** simcop2387 joined
[12:40] <discord-raku-bot> <Anton Antonov> @lizmat Thanks! "ML::ContextualSpellchecker" is my favorite, but wonder to what degree "Contextual*" is implied by "ML::".

[12:41] <lizmat> so you're implying that ML implies learning from context...  hmmmm

[12:42] <discord-raku-bot> <Anton Antonov> @lizmat Yeah, that is a long implication chain... 🙂

[12:42] <lizmat> if you feel strongly about that, then indeed, I would drop the Contextual part  :-)

[12:43] <discord-raku-bot> <Anton Antonov> Ok, sounds good. Of course, "ML::Spellchecker" is going to have "dumb", non-contextual spellchecker(s).

[12:50] *** jpn left
[12:52] *** jpn joined
[12:58] *** jpn left
[12:59] <discord-raku-bot> <Nemokosch> grondilu: apparently if you take two utf8 buffers, they will turn into Str with ~^ either way

[12:59] *** guifa left
[13:00] <discord-raku-bot> <Nemokosch> although I think this is a crazy feature, it definitely seems deliberate, like there is no other real reason for it to exist

[13:00] *** guifa joined
[13:00] <discord-raku-bot> <Nemokosch> I wonder if it's possible to beat the .Stringy part down, at least

[13:18] *** jpn joined
[13:32] *** jpn left
[13:42] *** jgaz joined
[13:46] *** jpn joined
[13:59] <discord-raku-bot> <Skarsnik> Finally I can run my benchmark, I should do a blog about this xD

[14:00] <lizmat> hehe.. please do!

[14:07] *** Homer_Simpson joined
[14:07] <Homer_Simpson> anyone know how to view a functions signaure in comma IDE

[14:07] <Homer_Simpson> eg say print put prompt readline get close open etc

[14:12] *** epony left
[14:14] <discord-raku-bot> <Skarsnik> 2018.04 give me a moar panic, fun

[14:22] *** epony joined
[14:30] <discord-raku-bot> <Skarsnik> err, there are some perf regression since 2020 for my benchmark

[14:34] <lizmat> could well be... I'd be interested to see compared to 2022.12 and blead, though

[14:38] <discord-raku-bot> <Skarsnik> <https://gist.github.com/Skarsnik/2e472a97d34a91936575b5fc3fe556fc>

[14:41] <discord-raku-bot> <Nemokosch> Gumbo gives me NativeCall flashbacks

[14:42] <discord-raku-bot> <Skarsnik> If I remember my profiling attempt, the nativecall stuff is very unsignifiant

[14:44] *** jjido left
[14:44] <discord-raku-bot> <Skarsnik> I wonder if I still have my leak tests x)

[14:45] <discord-raku-bot> <Anton Antonov> @lizmat Here is an MVP of "ML::Spellchecker" : https://github.com/antononcube/Raku-ML-Spellchecker

[14:46] <lizmat> nice, but what decides to go for "arise beautiful butterfly" ?

[14:48] *** razetime left
[15:04] <leont> I'm trying to use $*IN.Supply in a react { whenever ..}, but it seems to hang, anyone got a clue?

[15:05] *** rf joined
[15:06] <leont> Like, it will only receive the data on EOF

[15:07] <leont> That makes the whole thing rather useless from an asynchronous POV

[15:10] <dakkar> leont: `.Supply(:size(10))` or something?

[15:10] <dakkar> the docs say that it batches 64KB at a time…

[15:10] <leont> Yeah, I had just come to that conclusion. Or probably :1size and then .lines really.

[15:11] * dakkar has vague memories of Supply.lines and IO::Handle.lines behaving pretty differently

[15:14] <lizmat> https://stackoverflow.com/questions/75075019/asynchronous-reading-of-an-stdout perhaps ?

[15:21] <leont> It's really a weird way of going about though. It forces one to read byte-for-byte, which is quite inefficient. What one really wants is to read a large buffer, but if the result is small read that. It's read(2) versus fread(3) semantics really.

[15:22] <discord-raku-bot> <Anton Antonov> @lizmat [nice, but what decides to go for "arise beautiful butterfly" ?]  -- yeah, to answer this question (with probabilities and evidence) a more dedicate ML algorithms is needed. (Using contexts.)

[15:25] <lizmat> $*DEFAULT-READ-ELEMS perhaps ?

[15:25] *** Kaiepi left
[15:25] <leont> lizmat: it's not about the number, it's about the retries.

[15:25] <discord-raku-bot> <Anton Antonov> Basically, I use the tries-with-frequencies data structure to find most probably completions. For example, "cooking ice in the kitchen" should get a correction suggestion for "cooking rice in the kitchen", although none of the words in the former phrase are misspelled.

[15:25] <lizmat> dann bin ich uberfragt

[15:25] <lizmat> Anton cool!

[15:27] <discord-raku-bot> <Anton Antonov> "dann bin ich uberfragt" - I can spellcheck that if find large enough German text.

[15:29] <discord-raku-bot> <Nemokosch> leont: which one is the useful behavior here: read(2) or fread(3)? (for context, I don't know either lol)

[15:30] <leont> read(2) IMNSHO

[15:30] <leont> read(2) semantics is "read up to X bytes", fread means "read exactly X bytes unless EOF".

[15:31] <leont> The latter can't be combined well with something like .lines, because it will read all those 65536 characters before even considering splitting them up.

[15:32] <leont> (or .words, or anything else interesting)

[15:32] *** Kaiepi joined
[15:33] <discord-raku-bot> <Nemokosch> so what happens if there is no data to retrieve, for example?

[15:34] <leont> It won't emit anything until there is data

[15:35] <leont> I'm not exactly sure about the details, I would hope a blocking read inside a supply{} (in IO::Handle.Supply) doesn't block anything else from running but I'm not sure about that)

[15:37] <discord-raku-bot> <Anton Antonov> Are there rules or policies for having / providing / distributing large resource data files in Raku modules?

[15:38] <discord-raku-bot> <Nemokosch> <@694526400488669234> (Anton) this would make a great FAQ question

[15:39] <discord-raku-bot> <Anton Antonov> For example, the "ML::Spellchecker" module I am working on will have some large text corpus (say ≈20MB), which is used for _training_ of the spellchecker; the trained, ready to use spellchecker has much smaller operation data. I can use two module repositories: "ML::Spellchecker" and "ML::Spellchecker::Training". (Although, I am not very happy with that separation.)

[15:40] <discord-raku-bot> <Nemokosch> leont: Supplies and react blocks still seem to be something that kind of require pioneering from a user point of view

[15:41] <discord-raku-bot> <Nemokosch> this sort of stuff could be a killer feature or at least a solid offer

[15:47] * grondilu is back

[15:47] *** frithnanth joined
[15:49] <grondilu> dakkar: ok but that doesn't tell me why it worked fine with reduce * ~^ * 

[15:50] <dakkar> grondilu: because, when presented with something that's not an operator, reduce doesn't try to guess the identity value

[15:50] <grondilu> is that specced?

[15:51] <grondilu> I mean maybe I'm dense, but I don't see why reduce * op * would behave any differently than [op]

[15:51] <dakkar> https://docs.raku.org/routine/reduce look for "identity"

[15:53] <grondilu> ok I get it.

[15:53] <dakkar> `[op]` works the same as `reduce &infix<op>`

[15:54] *** Sgeo joined
[15:54] <grondilu> * ~^ * is an adhoc function so it can't be assigned an identity.  Got it.

[15:55] <leont> I have been bitten by supply/react edge cases without fully understanding before, I'm slightly suspicious about them. They're mainly poorly documented though.

[15:55] <dakkar> btw, the "identity" is just "call the code with 0 arguments, see what happens"

[15:56] <grondilu> oh, I thought it was an attribute or something.

[15:56] <dakkar> I'm sort-of guessing by looking at the definiton of the op (I linked it earlier)

[16:03] <discord-raku-bot> <Nemokosch> I kind of have an OCD for issues (also bad experience) so I didn't want to take that burden just yet. BUT.

[16:03] *** frithnanth left
[16:03] <discord-raku-bot> <Nemokosch> https://github.com/2colours/Raku-ideas/blob/main/Issues.md points 19 and 20 try to point out the things collected from this discussion

[16:05] *** melezhik joined
[16:10] <melezhik> .tell Skarsnik: if you play with Rakudo benchmarks I can setup a simple SparrowCI pipeline to run your tests against the 2022.12 and the blead  Rakudo , we have everything we need - https://sparrowhub.io/plugin/sparkyci-package-rakudo/0.000010

[16:10] <tellable6> melezhik, I'll pass your message to Skarsnik

[16:10] <melezhik> ^^ lizmat

[16:12] <sjn> .seen zostay 

[16:12] <tellable6> sjn, I saw zostay 2020-09-21T20:22:21Z in #raku: <zostay> I have a sort of production project that was built on Smack + Cofra which is a application framework I started building, but both are only half-baked.

[16:15] *** melezhik left
[16:19] <discord-raku-bot> <Nemokosch> oof

[16:19] <discord-raku-bot> <Nemokosch> sjn: what's up?

[16:21] *** epony left
[16:22] *** epony joined
[16:26] *** Homer_Simpson left
[16:27] *** sena_kun left
[16:28] *** Homer_Simpson joined
[16:28] <discord-raku-bot> <Skarsnik> https://blogs.perl.org/users/sylvain_colinet/2023/01/benchmarking-rakudo-releases-is-raku-still-slow.html

[16:28] <Homer_Simpson> .

[16:30] <Homer_Simpson> how come doing my $fh = open "test.txt", :r; my $contents = $fh.slurp; print($contents); does not print £ ¬ or ¦ properly

[16:30] <Homer_Simpson> I get 1234567890-=[];'#,./!"┬ú$%^&*()_+{}:@~<>?\|`┬¼┬ª

[16:30] <discord-raku-bot> <Skarsnik> Can you terminal display these?

[16:30] *** jpn left
[16:31] <Homer_Simpson> yes

[16:31] <Homer_Simpson> my terminal is powershell

[17:08] *** epony left
[17:10] *** epony joined
[17:12] *** archenoth joined
[17:12] *** sena_kun joined
[17:27] <discord-raku-bot> <Nemokosch> I'm still somewhat doubtful if a powershell window uses UTF-8 encoding

[17:28] *** alfonsox left
[17:29] <discord-raku-bot> <Nemokosch> <@106510366283952128> (Skarsnik) definitely weekly material 🙂

[17:33] <discord-raku-bot> <Nemokosch> by the way... it's fairly suspicious that 2021.10 is around the time new-disp got merged

[17:35] *** dakkar left
[17:52] <discord-raku-bot> <Skarsnik> is that power shell terminal or the new Windows 10+ terminal?

[17:53] <tonyo> Homer_Simpson: what should it say? 

[17:55] <tonyo> skarsnik: that's great - can you bisect and figure out which commit set that performance back?

[17:56] <discord-raku-bot> <Skarsnik> Not today x)

[17:56] <discord-raku-bot> <Skarsnik> Maybe tomorrow or this week end, not sure

[17:57] *** lichtkind_ joined
[17:59] *** lichtkind left
[18:00] *** reportable6 left
[18:03] *** reportable6 joined
[18:07] <rf> Would anyone be interested in a functional programming with Raku guide/blog? I feel like Raku suites a functional style so well!

[18:08] <moritz> my experience as a former Perl 6 blogger: yes, lots of people would be interested

[18:08] <moritz> and yes, lots of great features for FP in raku

[18:08] <moritz> (as long as you don't want to statically type your functions, that can get ugly pretty quickly)

[18:09] <rf> Great! It'll probably be a while but I'll figure something out

[18:12] <tonyo> the typing is what prevents me from doing fp with raku

[18:15] <moritz> honstly, I don't have much experience with statically typed FP; Haskell and OCaml come to mind where it's supposed to be less daunting

[18:23] <discord-raku-bot> <Nemokosch> yes and the ML end of things starts to look more like a cult than reasonable design

[18:25] <discord-raku-bot> <Nemokosch> Raku would probably be more like Erlang or some Lisp. The data types, though... we still don't know a lot about Daniel Sockwell's work.

[18:26] <discord-raku-bot> <Skarsnik> Every modern language has anonymous functions/lambda/whatever. Aside from strong type contract thing functionnal languages are kinda useless x)

[18:26] <discord-raku-bot> <Skarsnik> I wish Raku has a pragma that say "don't ignore method signature at compile time"

[18:30] <discord-raku-bot> <Nemokosch> I doubt it's "ignored", considering that dispatch relies on actual types, and quite surely there is some JITting at the very least, involving dispatches

[18:33] <discord-raku-bot> <Skarsnik> If you write like class A { method foo(Int $a)} ; A $a .= new; $a.foo("plop"); this fail at run time since it assume you can always add method at runtime

[18:34] <discord-raku-bot> <Skarsnik> btw does the multiline error repport get finally fixed? or it's more something for RakuAST?

[18:37] <discord-raku-bot> <Nemokosch> what is the "multiline error report"?

[18:38] <discord-raku-bot> <Nemokosch> ironically, this will fail at compile time because this is not valid Raku code

[18:45] *** Maylay left
[18:47] <discord-raku-bot> <Nemokosch> Anyway, I'm not sure if the "bytecode" from the compilation even cares about those types.

[18:53] <discord-raku-bot> <Skarsnik> multierror thing is if you have like a multiline instruction and something bad happens in like the last line, ti will repport error on the first line

[18:56] <rf> Raku FP is a lot like Clojure tbh\

[18:57] <rf> You have all of the immutability you want when you need it (Map, List etc) but without implicit partial application

[18:58] *** jpn joined
[18:59] <discord-raku-bot> <Nemokosch> And that's why Daniel's "Persistent Data Structures" are so long awaited

[18:59] <discord-raku-bot> <Nemokosch> That could really help with performance of immutable stuff

[19:04] *** jpn left
[19:06] *** jjido joined
[19:10] *** jpn joined
[19:16] *** Maylay joined
[19:23] <tonyo> i disagree about the strong type contract being the only thing FP is good for

[19:24] <tonyo> monads are great, it at least hasn't been bastardized to the point of OO yet.  in haskell they'd be better without thunking

[19:25] *** Maylay left
[19:33] *** deoac joined
[19:41] *** jpn left
[19:51] *** deoac left
[19:52] <rf> Monads are very good, even if they aren't statically typed. I agree

[20:01] *** abraxxa1 left
[20:04] *** abraxxa-home joined
[20:32] *** melezhik joined
[20:36] *** Homer_Simpson left
[20:36] <discord-raku-bot> <Nemokosch> monads are decorators in a costume, change my mind 😛

[20:37] <melezhik> .seen rawleyfowler

[20:37] <tellable6> melezhik, I haven't seen rawleyfowler around

[20:38] <melezhik> .tell rf

[20:38] <tellable6> melezhik, I saw rf 2023-01-11T19:52:01Z in #raku: <rf> Monads are very good, even if they aren't statically typed. I agree

[20:38] <melezhik> .tell rf: you probably need to add a simple sparrow.yaml to Monads to make CI works

[20:38] <tellable6> melezhik, I'll pass your message to rf

[20:39] <melezhik> the same way you did for Humming Bird ...

[20:43] <discord-raku-bot> <Nemokosch> so is rf rawleyfowler, at the end of the day?

[20:48] <melezhik> I guess so, I tell from the comment s I've found fir this alias )) I might be wrong though , sorry ahead of time ))

[20:48] <rf> Yes. That is me. Sorry melezhik I was about to add that before my work needed me!

[20:49] <melezhik> No worries, and nothing to say sorry for )))

[20:49] <melezhik> I just keep my eye on sparrowci builds and try to help whenever I can ...

[20:51] <discord-raku-bot> <Nemokosch> holy based

[20:52] <rf> melezhik: Should be good I think

[20:53] <melezhik> yup 👍

[20:55] <rf> Thanks again for SparrowCI it works very nicely :D

[20:58] *** melezhik left
[20:59] *** abraxxa-home left
[21:10] *** grondilu left
[21:11] <discord-raku-bot> <Nahita> rf: i had no idea you could escape > in a user defined operator, thanks for that

[21:11] <discord-raku-bot> <Nahita> i was using the nonascii version of that

[21:11] *** melezhik joined
[21:11] <melezhik> .

[21:14] <melezhik> rf - success - https://ci.sparrowhub.io/report/2565

[21:15] *** melezhik left
[21:22] <rf> Nahita: No problem :D

[21:25] <rf> I'm going to try to implement the Option monad next, then I want to see if I can do Lightweight Threads

[21:37] *** jpn joined
[21:40] *** melezhik joined
[21:40] <melezhik> .

[21:40] <melezhik> rf - welcome

[21:41] *** melezhik left
[21:43] *** jpn left
[21:45] <discord-raku-bot> <Anton Antonov> Monads allow your code to have algebraic structure. (Which can be leveraged in variety of ways, e.g. readability, making re-interpreters, etc.) Decorators -- I agree very similar in function -- do not generally provide that ability. The other thing about monads is that the "process of decoration" itself is programmable -- monads are based on "programable semi-columns."

[21:47] *** n1to joined
[21:49] <discord-raku-bot> <Nemokosch> I think you pointed out the thing that makes monads controversial. It's just so. much. abstract. boilerplate. I used to like math at high school, I was even competitive but programming is about solving problems, at the end of the day, not to describe some overblown algebraic concept with code

[21:52] <tonyo> nemokosch: monads are decorators in what way

[21:52] <tellable6> tonyo, I'll pass your message to Nemokosch

[21:53] <discord-raku-bot> <Nemokosch> in a way that adds a costume to them :kappa:

[21:54] <tonyo> oh, monads are so much more than that.  and they're more than overblown algebraic concepts.  monads can easily be used to model business processes with failure modes congruent with operations

[21:54] <tonyo> the boilerplate around creating them is far less than littering an otherwise useful process with `if err go here`

[21:55] <discord-raku-bot> <Anton Antonov> My monad is very problem-solving oriented based. You can see how I use monads in the movie I posted today in the showcase channel.

[21:56] <discord-raku-bot> <Nemokosch> it's rather that the sole concept of a monad is basically something one can come up with by common sense - except the overabundance of crippling category theory jargon, and some axioms taken from that

[21:56] <discord-raku-bot> <Nemokosch> inb4 "there is a difference between doing something like that and doing it exactly right"

[21:56] <discord-raku-bot> <Anton Antonov> * ... my monad usage is problem solving based ...

[21:57] <tonyo> they're really not

[22:01] <discord-raku-bot> <Nemokosch> hah, they all claim that 😆

[22:02] <tonyo> have you ever used monads practically?

[22:02] <discord-raku-bot> <Nemokosch> perhaps it would be good to have a command for tellable that goes like - "if my first message is this command, drop the messages stacking up immediately"

[22:03] <discord-raku-bot> <Nemokosch> because it will be really hell on earth if I log in once

[22:04] <discord-raku-bot> <Nemokosch> the question is: has anybody used monads practically, WHILE calling them monads?

[22:10] *** xinming left
[22:10] *** xinming joined
[22:11] *** discord-raku-bot left
[22:11] *** discord-raku-bot joined
[22:15] <tonyo> yes

[22:15] <tonyo> monads are not some glorified class

[22:17] <discord-raku-bot> <Nemokosch> well, depends on the implementation of the class 😛

[22:18] <rf> I do agree most developers use monads without knowing they're monads. But I have worked with people who know they are monads.

[22:20] <tonyo> personally i've used them in projects where business processes were important so it could handle failure modes for things like `Order.get(id=5).update_status(status='shipped', tracking_no='123').email_customer()`  .. without monads there's a lot of `if order == nil { .. handle this here }` and this introduces a lot of branching.  `update_status` on a monad where the side effect is the order doesn't

[22:20] <tonyo> exist handles this case without branching and email_customer still can do the right thing, which is not email a customer that their order id doesn't exist

[22:21] <tonyo> i hated monads and also thought they were a dumb way of thinking about data relationships but after using them, they're far easier to grok and use practically where clarity in process is important

[22:21] *** jgaz left
[22:22] <tonyo> i'd like to see a class that can handle that without littering the code logical branches to handle failure modes

[22:23] <rf> I work at a bank, we use monads for the critical stuff that I'm not allowed to touch :D

[22:24] <tonyo> stephen diehl (another bank person), i think, has a good talk on all that stuff

[22:24] <tonyo> where he's highly critical of monads and more so of thunking

[22:27] <discord-raku-bot> <Nemokosch> I think monads as in software architecture bricks may very well be useful. It's rather the discourse that it involves, this carried weight, that fires back.

[22:28] <tonyo> agreed, how difficult it is to actually understand/teach what they are is a huge barrier

[22:29] *** discord-raku-bot left
[22:30] *** discord-raku-bot joined
[22:30] <discord-raku-bot> <Nemokosch> My own experience is that I could never understand even banally simple things when I started programming. Like, what an interface even is, or what polymorphism is about. And then I faced problems that these means could help with. Same with decorators: couldn't for the life of me understand them, until one day it came naturally as a solution to various checks performed for command execution.

[22:30] <rf> That's sort of the running joke. Once you learn Monads you can't teach Monads

[22:31] <discord-raku-bot> <Nemokosch> Yes, and it's fairly logical that the joke has some actual truth to it. One cannot use a half-monad or quasi-monad. It's either the thing or not. And to make sure it is the thing, you need to enter a discourse that requires a much more axiomatic approach that you'd be used to with software architecture most of the time.

[22:32] <rf> Monads are also really hard to teach without a strong type-system, which most languages don't have

[22:32] *** jpn joined
[22:35] <discord-raku-bot> <Nemokosch> that's why I can only say: decorators, at least in the Pythonic sense, perhaps I get; and I have a strong impression that a monad is something like that, with some additional formal criteria I guess?

[22:36] <rf> A monad is simply a box that may or may not produce a side-effect upon looking inside of it.

[22:36] <rf> An empty List is the side effect of viewing a List (lists are Monads)

[22:37] *** jpn left
[22:38] <discord-raku-bot> <Nemokosch> well, what if a side-effect does happen?

[22:38] <rf> Nothing typically, what happens right now if you try to map an empty list?

[22:40] <discord-raku-bot> <Nemokosch> well, Raku aside, I would say I get an empty list back

[22:40] <rf> Yes, the side-effect is hidden from you and you continue on your way safely

[22:40] <discord-raku-bot> <Nemokosch> you know, it trips me up that you said that a value is a side effect 😅 how does that add up?

[22:41] <rf> A monad has to have some kind of side-effect, could be async-io, could be an exception, could be an empty list

[22:41] <rf> Promise is a monad, it's side-effect is that it might fail

[22:41] <rf> Or not resolve (whatever the term for promises is)

[22:42] <discord-raku-bot> <Nemokosch> that would have been the next question (can a valid Promise in this context never return)

[22:43] <rf> That is where bind and map come in (>>= and >>=?)

[22:43] <rf> They're just functions that hide the unwrapping of the object from you, you can review my code for an example: https://github.com/rawleyfowler/Monad-Result

[22:50] <discord-raku-bot> <Nemokosch> well the map operation is indeed a lot like Promise#then in JS

[22:51] <rf> .then is actually just .map

[22:51] <rf> It's just named differently because JavaScript

[22:53] *** discord-raku-bot left
[22:53] *** discord-raku-bot joined
[22:53] <discord-raku-bot> <Nemokosch> well, thank heavens they didn't mean it map, that's something else already

[22:54] <discord-raku-bot> <Nemokosch> and you are lucky if it's only one other thing because associative arrays are also often called maps

[22:56] <tonyo> the monad itself both describes the side effect and hints the compiler on how to tell you that you've forgotten to handle some case

[22:58] <discord-raku-bot> <Nemokosch> and this bind really seems like "map but things might go wrong", in this Result context at least

[22:58] <tonyo> the latter is the biggest rub, i think, with things that claim strong typing but really have types without strong typing (like go)

[23:03] <tonyo> well, it's kind of more than that too.  i mean, if you think about something as simple as Maybe(List) and think about calling map on Maybe (which is a container for a `List|None`) then the compiler should force you to understand your code needs to handle both cases, remember you're calling it on a Container and not the list itself.  In both cases you may prefer to have it return the list or an empty

[23:03] <tonyo> list so your monad handles the side effect of `you gave me a nil value`, or you may prefer it just continues to give you `Maybe(List)` which will still unwrap to `None`.  This gives you the ability to go a step further and start linking method calls on the Container with the safety of knowing you're not going to use the unwrapped `List|None` in a way that blows.  practically it's a little more

[23:03] <tonyo> complicated (usually)

[23:04] <discord-raku-bot> <Nemokosch> I'm not so fond of static typing but maybe if they were actually robust, like supposedly in certain functional languages, they could make a good appeal

[23:07] <tonyo> i found it a very crappy experience at first but thought better of it after using it for a while

[23:08] <tonyo> otherwise agree though, go's typing kind of stinks

[23:09] <tonyo> python's leaves a lot desired

[23:10] *** n1to left
[23:11] <rf> OCaml is probably the best truly statically typed language I have written

[23:14] <tonyo> looks pretty interesting

[23:14] <tonyo> esp with that beautiful vim logo on their main page

[23:16] <discord-raku-bot> <Nemokosch> :DDD

[23:26] *** jpn joined
[23:30] *** jpn left
[23:33] <tonyo> rf: i wonder if that Monad-Result could be generic-ized a bit to make Monads definable in just the course of writing raku

[23:35] *** vrurg_ is now known as vrurg

[23:37] *** sena_kun left
[23:49] *** hythm left
[23:53] <discord-raku-bot> <Anton Antonov> I have a proof -- please watch this movie : https://www.youtube.com/watch?v=Xy7eV8wRLbE . (I referred to it above.)

[23:53] <guifa> o/

[23:56] <tonyo> that guy is using your name

