[00:00] *** reportable6 left
[00:00] *** reportable6 joined
[00:13] *** MasterDuke left
[00:57] *** jpn joined
[01:02] *** jpn left
[01:29] *** bigdata joined
[01:43] *** razetime joined
[01:58] *** razetime1 joined
[01:59] *** razetime left
[01:59] *** razetime1 is now known as razetime

[02:00] <guifa> FINALLY 

[02:00] <guifa> all formatter patterns done

[02:19] *** tea3po joined
[02:22] *** teatwo left
[02:30] *** rf left
[02:33] <guifa> الثلاثاء، ١١ أبريل ٢٠٢٤، ١٠:٣٢:٥٦ م التوقيت الصيفي الشرقي لأمريكا الشمالية

[02:33] <guifa> 2024年4月11日火曜日 22時33分30秒 アメリカ東部夏時間

[02:33] <guifa> martes, 11 d’abril de 2024, 22:33:46 Hora braniega del este norteamericanu

[02:34] *** rf joined
[02:35] <guifa> or for AntonAntonov вторник, 11 април 2024 г., 22:35:02 ч. Северноамериканско източно лятно часово време

[02:36] <guifa> now I just have to transfer over a few blocks of code tomorrow and I can release this sucker

[03:34] *** linkable6 left
[03:34] *** evalable6 left
[03:35] *** razetime left
[03:35] *** evalable6 joined
[03:35] *** linkable6 joined
[04:12] *** rf left
[04:19] *** razetime joined
[04:57] *** Vyrus left
[04:58] *** Vyrus joined
[05:17] <discord-raku-bot> <snufkin> @rf Thanks for your response, I did try this, but it seems to be overwritten when the  HTML is produced.

[05:19] *** cm_ joined
[05:19] *** cm left
[05:19] *** cm_ is now known as cm

[05:20] *** bigdata left
[05:28] <discord-raku-bot> <snufkin> I used this as the $response.html <html><head><meta charset="UTF-8"></head><body><h1>好</h1></body></html> This is what comes back: <html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"></head><body><h1>好</h1></body></html>

[05:44] *** bigdata joined
[05:54] *** cm left
[05:55] *** cm joined
[06:00] *** reportable6 left
[06:02] *** reportable6 joined
[06:27] *** holyghost joined
[06:36] *** holyghost left
[06:43] *** holyghost joined
[06:44] *** holyghost left
[06:47] *** razetime left
[06:52] *** bigdata left
[06:53] <discord-raku-bot> <Nemokosch> @snufkin what web server do you use?

[06:53] *** holyghost joined
[06:58] *** holyghost left
[07:12] *** abraxxa joined
[07:18] *** bigdata joined
[07:20] *** deoac left
[07:26] *** bigdata left
[07:28] *** Sgeo left
[07:29] *** jpn joined
[07:35] *** jpn left
[07:43] *** Vyrus left
[07:43] *** squashable6 left
[07:43] *** epony left
[07:43] *** bloatable6 left
[07:43] *** coverable6 left
[07:43] *** statisfiable6 left
[07:43] *** tellable6 left
[07:43] *** sourceable6 left
[07:43] *** shareable6 left
[07:43] *** bisectable6 left
[07:43] *** nativecallable6 left
[07:43] *** benchable6 left
[07:43] *** greppable6 left
[07:43] *** ProperNoun left
[07:43] *** Sauvin left
[07:43] *** codesections left
[07:43] *** kjp left
[07:43] *** tobs left
[07:43] *** sftp left
[07:43] *** peder left
[07:43] *** jdv left
[07:43] *** gugod left
[07:43] *** renormalist left
[07:43] *** human-blip left
[07:43] *** samcv left
[07:43] *** tinita left
[07:43] *** bartolin_ left
[07:43] *** jjatria left
[07:43] *** polettix_ left
[07:43] *** nicole left
[07:43] *** tobs joined
[07:43] *** Vyrus joined
[07:43] *** nicole joined
[07:43] *** tinita joined
[07:43] *** jjatria joined
[07:43] *** bartolin joined
[07:43] *** polettix joined
[07:43] *** peder joined
[07:43] *** Vyrus left
[07:43] *** Vyrus joined
[07:43] *** kjp joined
[07:44] *** jdv joined
[07:44] *** renormalist joined
[07:44] *** codesections joined
[07:45] *** Sauvin joined
[07:45] *** samcv joined
[07:46] *** ProperNoun joined
[07:46] *** sftp joined
[07:47] *** human-blip joined
[07:47] *** gugod joined
[07:56] <discord-raku-bot> <snufkin> Running hummingbird locally for development, it handles the serving.

[07:58] *** kjp left
[08:00] <discord-raku-bot> <Nemokosch> I can only think of the server being messy... how else would it explicitly turn into Windows setup

[08:00] *** jpn joined
[08:03] *** sourceable6 joined
[08:03] *** bisectable6 joined
[08:03] *** shareable6 joined
[08:03] *** tellable6 joined
[08:03] *** benchable6 joined
[08:03] *** nativecallable6 joined
[08:03] *** statisfiable6 joined
[08:03] *** squashable6 joined
[08:03] *** coverable6 joined
[08:03] *** bloatable6 joined
[08:03] *** greppable6 joined
[08:05] *** jpn left
[08:08] <discord-raku-bot> <snufkin> It could be related to WSL perhaps. I'm running it in Ubuntu in WSL.

[08:09] *** dakkar joined
[08:12] *** sena_kun joined
[08:20] <discord-raku-bot> <Nemokosch> Issue or not, I wonder what actually "handles the serving" because I'm pretty sure Humming-Bird does no such thing

[08:20] <discord-raku-bot> <Nemokosch> and the answer to that question would hopefully lead to an answer about the locale

[08:25] <discord-raku-bot> <snufkin> > Humming-Bird has 2 simple layers, at its core we have Humming-Bird::HTTPServer which handles all of the low-level HTTP bits. Then you have the routing stack that handles: routing, middleware, error handling, cookies, etc.

[08:26] <discord-raku-bot> <snufkin> It looks like RF has pushed a default to UTF-8 update to Humming-Bird so I'll try that when I am able.

[08:29] *** holyghost joined
[08:31] <discord-raku-bot> <Nemokosch> oh it uses a vanilla socket

[08:34] *** derpydoo left
[08:38] *** derpydoo joined
[08:40] *** jpn joined
[08:51] *** holyghost left
[08:53] *** jpn left
[09:02] *** epony joined
[09:04] *** holyghost joined
[09:04] *** holyghost left
[09:04] <discord-raku-bot> <snufkin> Do you know if that could explain the locale?

[09:05] <discord-raku-bot> <Nemokosch> I don't know but the socket shouldn't be HTTP level, you'd think

[09:08] <discord-raku-bot> <Nemokosch> and I don't see any obvious sign in the code that it would try to figure out a charset - prior to the recent modification that is

[09:08] *** holyghost joined
[09:10] *** holyghost left
[09:16] <discord-raku-bot> <snufkin> I don't know enough about networking/sockets to really know how it should/shouldn't be.

[09:19] *** sena_kun left
[09:32] <Voldenet> snufkin: are you testing with curl or some other sane tool?

[09:32] *** holyghost joined
[09:40] <Voldenet> $response.html writes `Content-Type: text/html` header, so whatever UA you're using, it could simply use that as a content-type instead of meta charset

[09:40] *** derpydoo left
[09:40] <Voldenet> no other place attaches text/html to the response

[09:45] *** holyghost left
[09:46] <discord-raku-bot> <snufkin> @Volenet I'm testing with Chrome currently. Didn't use curl because intending it be a website. I can try it though

[09:49] *** kjp joined
[09:50] *** razetime joined
[09:59] *** Vyrus left
[09:59] *** Vyrus joined
[10:00] *** jpn joined
[10:03] *** sena_kun joined
[10:09] <Voldenet> Chrome is quite famous for being modern age internet explorer

[10:10] <Voldenet> for instance it tried to deprecate SMIL despite it being in active use

[10:11] <Voldenet> so I wouldn't be surprised if it rewrote the body of received html as well, sadly

[10:12] *** sena_kun left
[10:12] *** Altai-man joined
[10:15] <discord-raku-bot> <snufkin> Would Firefox be a better browser to test with?

[10:18] <Voldenet> Since chrome is IE, you need to test on it for most common case

[10:18] <Voldenet> firefox is better at following set standards

[10:24] <discord-raku-bot> <snufkin> Are all chrome derived browsers similar also?

[10:28] <Voldenet> theoretically they could use patched version of chromium that revert risky changes, but I doubt they do

[10:29] <Voldenet> while I've not tested a lot of them, the ones I have installed do behave like chromium a lot

[10:31] *** jpn left
[10:38] <discord-raku-bot> <snufkin> That makes sense. I'll see what happens with curl and firefox also.

[11:04] *** gcd left
[11:10] *** razetime left
[11:22] *** gcd joined
[11:27] *** jpn joined
[11:37] *** jpn left
[11:52] *** razetime joined
[12:00] *** reportable6 left
[12:02] *** reportable6 joined
[12:04] *** ab5tract joined
[12:06] *** razetime left
[12:12] *** razetime joined
[12:16] <[Coke]> would it make sense to offer a single method to do a unique sort? either way you chain .unique/.sort you're processing the elements twice, and for long lists, a combined method (presumably an adverb on one of them) could do less work.

[12:16] *** ProperNoun left
[12:16] *** ProperN[out] joined
[12:21] *** ab5tract left
[12:25] <ugexe> i think you could do that with the current sort by passing an appropriate callback

[12:27] <ugexe> the problem with having a specialized method for that particular combo though is doing sort + almost any list mutating/filtering operation would do better with such a method, and that would be a lot of methods

[12:30] *** bigdata joined
[12:32] <Voldenet> Those apis could produce iterators that would "know" about each other and then the method wouldn't be necessary

[12:33] *** bigdata left
[12:50] <Voldenet> using iterators there also allows implementing various optimizations in chained calls like `.unique.sort.kv.Hash`

[12:53] *** razetime left
[12:53] <lizmat> .unique can be streaming, but .sort can not be, or am I missing something?

[12:54] <lizmat> for a sort you would need to have seen all elements

[12:54] <Voldenet> but iterators don't have to be streaming

[12:54] <Voldenet> iterators can evaluate result when needed

[12:54] *** razetime joined
[12:54] <Voldenet> so, .unique would not do anything, .sort would not do anything, only .Hash would consume all the iterators

[12:55] <Voldenet> so .sort would return UniqueSortIterator or SortIterator depending on the input

[12:55] <lizmat> but that's how iterators already work ?

[12:55] <lizmat> m: dd (2,3,1).sort

[12:55] <camelia> rakudo-moar 56d63c96c: OUTPUT: «(1, 2, 3).Seq␤»

[12:55] <lizmat> m: dd (2,3,1).sort.iterator

[12:55] <camelia> rakudo-moar 56d63c96c: OUTPUT: «Rakudo::Iterator::ReifiedListIterator.new␤»

[12:56] <Voldenet> m: dd (2,3,3,1).unique.sort.iterator

[12:56] <camelia> rakudo-moar 56d63c96c: OUTPUT: «Rakudo::Iterator::ReifiedListIterator.new␤»

[12:56] <Voldenet> m: dd (2,3,3,1).unique.sort.WHAT

[12:56] <camelia> rakudo-moar 56d63c96c: OUTPUT: «Seq␤»

[12:56] <Voldenet> m: dd (2,3,3,1).unique.WHAT

[12:56] <camelia> rakudo-moar 56d63c96c: OUTPUT: «Seq␤»

[12:57] <lizmat> m: dd (2,3,3,1).unique.iterator

[12:57] <camelia> rakudo-moar 56d63c96c: OUTPUT: «Any::Unique.new␤»

[12:57] <Voldenet> Ha, so the method for "unique sorting" can be fully internal

[12:57] <Voldenet> and no change is needed

[12:58] <lizmat> except there's currently no way to indicate that iterator X is used as a source for iterator Y

[12:58] <lizmat> that I know of, anyway

[13:09] *** razetime left
[13:10] <Voldenet> It's not, but sort/unique can make the choice of right iterator

[13:12] <Voldenet> this feels like a hacky approach http://ix.io/4tgs

[13:16] <Voldenet> in fact iterable can be used so .iterator method can return right iterator when it's requested http://ix.io/4tgt

[13:17] <lizmat> I'm not seeing the win here...  .sort already effectively calls the iterator to create a list to work on

[13:18] <Voldenet> it's related to earlier question whether making unique-sort() method makes sense

[13:18] <lizmat> or do you want the sorting to be building the result list?

[13:18] <lizmat> fwiw, such optimization might be better done at RakuAST level

[13:19] <lizmat> when seeing a .unique.sort combo

[13:19] <Voldenet> both approaches are not mutually exclusive

[13:19] <lizmat> of course, this has it pitfalls as well, as we cannot be sure that the .unique  and .sort would be the system's .unique / .sort as they are late bound

[13:19] <discord-raku-bot> <Nemokosch> are these iterators meant to postpone execution as much as possible?

[13:20] <Voldenet> Nope, which is pretty weird

[13:21] <lizmat> https://docs.raku.org/type/Iterator.html

[13:21] <Voldenet> my $x = 1..1000000; $x.sort; say now - BEGIN now

[13:21] <evalable6> Voldenet, rakudo-moar 56d63c96c: OUTPUT: «1.129273468␤»

[13:21] <discord-raku-bot> <Nemokosch> WALK now 😄

[13:22] <lizmat> iterators are meant to allow for lazy evaluation

[13:22] <lizmat> without them, this would not be possible:

[13:23] <lizmat> m: my @l = 1..Inf; say @l[100]

[13:23] <camelia> rakudo-moar 56d63c96c: OUTPUT: «101␤»

[13:23] <lizmat> by accessing the 101st element, the list is reified upto that element

[13:23] <discord-raku-bot> <Nemokosch> so here the idea is that actual evaluation could wait until we know how to do it better, no?

[13:23] <discord-raku-bot> <Nemokosch> meta-laziness

[13:24] <Voldenet> Yes, and in fact

[13:24] <Voldenet> m: my $x = 1..1000000; my $y = $x.iterator.sort; say $x.WHAT, $y.WHAT; say now - BEGIN now

[13:24] <camelia> rakudo-moar 56d63c96c: OUTPUT: «(Range)(Seq)␤0.015011134␤»

[13:25] <lizmat> that sorts a list of 1 element containing an Iterator object ?

[13:26] <lizmat> m: m: my $x = 1..1000000; my $y = $x.iterator.sort; say $x.WHAT, $y.WHAT; say $y

[13:26] <camelia> rakudo-moar 56d63c96c: OUTPUT: «(Range)(Seq)␤(Rakudo::Iterator::IntRange.new)␤»

[13:26] <discord-raku-bot> <Nemokosch> I don't think "smh" translates into actually shaking your head well enough

[13:27] <Voldenet> I'm not entirely sure why is magic `iterator` keyword even needed in this case

[13:27] *** razetime joined
[13:27] <lizmat> iterator is just a method ??

[13:27] <discord-raku-bot> <Nemokosch> Range probably has its nice list method

[13:27] <Voldenet> s/keyword/word/

[13:27] <discord-raku-bot> <Nemokosch> while Iterator probably does not

[13:28] <lizmat> Iterator is a role

[13:28] <lizmat> you use it to build iterator classes

[13:28] <lizmat> the iterator method on a Seq returns the Iterator object it uses

[13:28] *** razetime left
[13:28] <discord-raku-bot> <Nemokosch> the underlying iterator instance probably also doesn't provide list

[13:29] <Voldenet> so Seq is Iterable

[13:29] <lizmat> m: say Seq ~~ Iterable

[13:29] <camelia> rakudo-moar 56d63c96c: OUTPUT: «True␤»

[13:29] <discord-raku-bot> <Nemokosch> Range also is

[13:30] <Voldenet> this means that .sort.unique could be more specialized for special cases of Iterables

[13:30] <lizmat> sure... just write another .sort candidate

[13:31] <discord-raku-bot> <Nemokosch> for Range, well... xD

[13:31] <discord-raku-bot> <Nemokosch> 99,9999% performance improvement

[13:31] <Voldenet> m: my @x = (1..Inf).sort

[13:31] <camelia> rakudo-moar 56d63c96c: OUTPUT: «Cannot sort a lazy list␤  in block <unit> at <tmp> line 1␤␤»

[13:31] <Voldenet> I know this code is pure nonsense, but that's low-hanging fruit

[13:32] <lizmat> how is that low hanging fruit ?

[13:33] <discord-raku-bot> <Nemokosch> well yeah... by the same chance it does what it does currently, it could do the same thing but better... how many lines would that modification be?

[13:33] <lizmat> how can you sort something without inspecting all of the elements ?

[13:33] <discord-raku-bot> <Nemokosch> by knowing that it is ordered by definition

[13:33] <Voldenet> Sort could inspect properties of iterable (like type) to not do any work

[13:33] <lizmat> ok, well, then write a Range.sort

[13:34] <lizmat> for the default case

[13:34] <lizmat> if you pass a comparator, all deals are off

[13:35] <lizmat> PR's welcome  :-)

[13:35] <discord-raku-bot> <Nemokosch> this reminds me of type checks

[13:35] <discord-raku-bot> <Nemokosch> something that would allow you to define type transformations in any shape or form would be great

[13:35] <lizmat> fwiw, the above would only work with either (1..Inf).sort or my @x := 1..Inf

[13:36] <discord-raku-bot> <Nemokosch> to give a mundane example: if you have an odd number $x, $x + 1 is guaranteed to be an even number, no need to check for that

[13:37] <Voldenet> or if you do (1..Inf).sum you should get -1/12 _obviously_ :P

[13:37] <discord-raku-bot> <Nemokosch> 🧠

[13:37] <lizmat> I guess an additional optional Iterator method could indicate that the elements are monotonically increasing

[13:37] <lizmat> and sort could use that

[13:38] <lizmat> and pass on the iterator as is in that case

[13:38] <Voldenet> the comparator could also have specified ordering, but that'd probably require rakuast to work well

[13:38] <discord-raku-bot> <Nemokosch> for the type checking - even something to say "trust me bro", like a kind of cast, could be good sometimes

[13:47] <Voldenet> m: class A does Iterable { method iterator { (1..1000000).iterator } }; my $a = A.new; my $b = $a.sort; say now - BEGIN now

[13:47] <camelia> rakudo-moar 56d63c96c: OUTPUT: «0.858667208␤»

[13:51] <[Coke]> sort - I liked the comment earlier about making it an optimization; .sort.unique could be optimized to .sort.squish

[13:51] <[Coke]> (and for now I'll just do that manually anyway!)

[13:52] <Voldenet> Apparently Any.sort would need to be changed for different cases of self.iterator, it's doable

[13:55] <lizmat> [Coke]: depending on the number of dupes, .unique.sort may still be faster

[13:56] <lizmat> if you expect a lot of dupes, then .unique, if only a few, then .sort.squish I'd say

[14:01] <Voldenet> $iterator.optimization-hint(:duplicate-probability(* > .5)).sort.unique

[14:02] *** rf joined
[14:02] <rf> Morning folks

[14:05] <lizmat> Voldenet: https://github.com/rakudo/rakudo/pull/5243

[14:05] <Voldenet> Wow

[14:07] *** jpn joined
[14:10] <Voldenet> So with this change, Any.sort could skip work if self.iterator.is-monotonically-increasing

[14:10] <lizmat> yup

[14:11] *** teatwo joined
[14:14] <Voldenet> now that I think of it, it would break certain assumptions that expect sort to be always evaluated, but docs say:

[14:14] *** Guest10 joined
[14:14] <Voldenet> > method sort – Sorts iterables with cmp or given code object and returns a new Seq.

[14:14] *** tea3po left
[14:15] <lizmat> right

[14:15] <Voldenet> I'm not sure if it implies that actual work must be done on Ranges

[14:15] <Voldenet> probably not

[14:15] *** jpn left
[14:15] <lizmat> the PR did not break any spectests

[14:17] <lizmat> adapted the PR to do the check in Any.sort, and removed the Range.sort candidate

[14:19] <discord-raku-bot> <Nemokosch> why is that better?

[14:19] <Voldenet> When your graph plotting sub and you provide xvalues, the plotting would obviously sort them first

[14:20] <Voldenet> :xvalues(1..100000) would skip sorting entirely

[14:20] <lizmat> because it will apply the lazy pass-on behaviour on .sort to *any* object that has an iterator that is monotonically increasing, not just for Ranges?

[14:20] <discord-raku-bot> <Nemokosch> fair enough, lol

[14:21] <Voldenet> also, nice use case is that it's possible to sort lists only once

[14:22] <Voldenet> m: my @y = (1..100000); for ^10 { @y .= sort; say now - BEGIN now }

[14:22] <camelia> rakudo-moar 5f66d8534: OUTPUT: «0.217464027␤0.323814427␤0.461667202␤0.568463025␤0.669587122␤0.776436546␤0.885371005␤0.988860073␤1.097826471␤1.231786325␤»

[14:23] <lizmat> m: my @y = (1..100000); for ^10 { @y .= sort; say now - ENTER now }

[14:23] <camelia> rakudo-moar 5f66d8534: OUTPUT: «0.12006733␤0.113010976␤0.105366429␤0.14353936␤0.117764756␤0.103655504␤0.111089322␤0.115132678␤0.105012741␤0.159288894␤»

[14:23] <Voldenet> :)

[14:24] <Voldenet> either way, Seq can now know it is sorted

[14:27] <lizmat> well, if the PR is merged, but yes

[14:28] <Voldenet> the original point was that sort could be fully lazy so later operations can change how sort is being done

[14:28] <Voldenet> like .sort.head(10)

[14:28] <Voldenet> or .sort.squish

[14:28] <lizmat> yeah, that would work, .sort.tail(10) not so much

[14:29] <lizmat> eh... well, in the case of 1..*   -)

[14:29] <lizmat> but 1..10000  yeay

[14:31] <Voldenet> that's up to later creativity of underlying Sequence

[14:31] <Voldenet> and since Sequences have `.eager` always, if someone really expected things to be eager, it can be forced

[14:38] <[Coke]> in this PR, could calling .sort return a seq that has the flag set?

[14:39] <[Coke]> (or is that too much magic)

[14:40] <lizmat> it does that... because it returns the underlying iterator in that case

[14:40] <lizmat> so that magic is already there

[14:42] <[Coke]> I mean if you have an unsorted list first, then sort it.

[14:42] <[Coke]> not if you start with a sorted list.

[14:43] <lizmat> yeah, but I find Voldenets example of an argument to a sub that could be either sorted or not, so you call .sort on it

[14:43] <lizmat> in that case:  :points(1..10)   would not need to be sorted at all

[14:54] *** Aozen joined
[14:55] *** Aozen left
[14:58] *** Guest10 left
[15:01] *** Sgeo joined
[15:24] *** Xliff joined
[15:43] *** jpn joined
[15:47] *** jpn left
[16:36] *** dakkar left
[16:37] *** abraxxa left
[16:48] *** jpn joined
[16:53] *** jgaz joined
[16:56] *** epony left
[17:07] *** abraxxa joined
[17:11] *** Altai-man left
[17:26] * [Coke] finds an uncommitted change to App::Uni on an old dev box.

[17:27] *** epony joined
[17:30] *** gcd left
[17:36] *** gcd joined
[17:39] <[Coke]> (\_/)

[17:39] <[Coke]> (•_•)

[17:39] <[Coke]> > 🦋

[17:40] <[Coke]> ^^ the very helpful change that lets you generate the bunny emoticon with a specified character.

[17:46] *** sena_kun joined
[17:49] *** jgaz left
[17:55] <[Coke]> I think that was pre-pandemic.

[18:00] *** reportable6 left
[18:01] *** reportable6 joined
[18:20] *** jgaz joined
[18:47] *** MoC joined
[18:51] <tonyo> heh, there used to be a dragon with a gold tooth in zef

[18:54] *** jpn left
[19:04] *** xkr47 left
[19:13] *** deoac joined
[19:15] *** deoac left
[19:16] *** jpn joined
[19:26] *** MoC left
[19:26] *** jpn left
[19:46] *** jpn joined
[20:07] *** deoac joined
[20:07] *** xkr47 joined
[20:27] *** vrurg_ is now known as vrurg

[20:41] *** deoac left
[20:43] *** jpn left
[20:59] *** rf left
[21:07] *** jgaz left
[21:17] *** tobs left
[21:19] *** tobs joined
[21:55] *** sena_kun left
[22:55] *** linkable6 left
[22:55] *** evalable6 left
[22:55] *** linkable6 joined
[22:57] *** evalable6 joined
[23:29] *** Xliff left
[23:34] *** bigdata joined
[23:55] *** cm_ joined
[23:56] *** cm left
[23:56] *** cm_ is now known as cm

