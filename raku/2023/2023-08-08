[00:00] *** reportable6 left
[00:02] *** reportable6 joined
[00:33] *** tankf33der left
[01:04] *** razetime joined
[01:18] *** ab5tract left
[01:56] *** MasterDuke joined
[02:00] *** swaggboi joined
[02:09] *** rf left
[02:14] *** rf joined
[02:26] *** hh1488 joined
[02:38] *** hh1488 left
[03:38] *** reportable6 left
[03:38] *** quotable6 left
[03:38] *** bisectable6 left
[03:38] *** benchable6 left
[03:38] *** tellable6 left
[03:38] *** coverable6 left
[03:38] *** bloatable6 left
[03:38] *** unicodable6 left
[03:38] *** nativecallable6 left
[03:38] *** linkable6 left
[03:38] *** shareable6 left
[03:38] *** statisfiable6 left
[03:38] *** evalable6 left
[03:38] *** notable6 left
[03:38] *** squashable6 left
[03:38] *** sourceable6 left
[03:38] *** committable6 left
[03:38] *** greppable6 left
[03:38] *** releasable6 left
[03:38] *** reportable6 joined
[03:38] *** statisfiable6 joined
[03:39] *** nativecallable6 joined
[03:39] *** coverable6 joined
[03:39] *** linkable6 joined
[03:39] *** benchable6 joined
[03:39] *** sourceable6 joined
[03:40] *** committable6 joined
[03:40] *** greppable6 joined
[03:40] *** bisectable6 joined
[03:40] *** unicodable6 joined
[03:40] *** evalable6 joined
[03:40] *** quotable6 joined
[03:41] *** notable6 joined
[03:41] *** tellable6 joined
[03:41] *** squashable6 joined
[03:41] *** releasable6 joined
[03:41] *** shareable6 joined
[03:41] *** bloatable6 joined
[03:49] *** bigdata left
[03:53] *** bigdata joined
[03:58] *** rf left
[04:13] *** razetime left
[04:51] *** euandreh left
[04:57] *** euandreh joined
[05:17] *** razetime joined
[05:30] *** jpn joined
[05:30] *** bigdata left
[05:34] *** jpn left
[05:49] <discord-raku-bot> <nemokosch> In one situation people act like Raku is literally Rakudo, in another, the distinction is drawn carefully

[05:53] *** siavash joined
[05:54] <discord-raku-bot> <nemokosch> If one looks at the state of the "standard", ecosystem modules, language versioning, it's clear that 1. the standard is very far from exhaustive 2. the ecosystem is full of content that would only ever work with Rakudo or MoarVM specifically 3. the versioning is used as a backup mechanism for continuously releasing backwards compatible Rakudo

[06:00] *** reportable6 left
[06:01] *** reportable6 joined
[06:05] *** HobGoblin joined
[06:06] *** siavash left
[06:06] *** rantanplan joined
[06:07] *** samcv_ joined
[06:08] *** siavash joined
[06:12] *** heartburn left
[06:12] *** samcv left
[06:12] *** timo left
[06:12] *** goblin left
[06:12] *** thebb left
[06:12] *** snonux left
[06:12] *** rjbs left
[06:12] *** spacekookie left
[06:12] *** skaji_ left
[06:12] *** pjlsergeant__ left
[06:17] *** spacekookie joined
[06:17] *** skaji_ joined
[06:18] *** thebb joined
[06:19] *** timo joined
[06:21] *** heartburn joined
[06:31] *** pjlsergeant__ joined
[06:32] *** rjbs joined
[06:55] *** jpn joined
[07:01] *** jpn left
[07:12] *** jpn joined
[07:15] <lizmat> weekly: https://news.ycombinator.com/item?id=37040681#37041705

[07:15] <notable6> lizmat, Noted! (weekly)

[07:18] *** Sgeo left
[07:19] *** jpn left
[07:23] *** jpn joined
[07:24] <discord-raku-bot> <nemokosch> this is a good example actually. There is no reason why the default behavior couldn't be negotiated - except the lack of compatibility policy of Rakudo...

[07:31] *** jpn left
[07:33] <discord-raku-bot> <nemokosch> same forum, labelling Go as neither readable, nor expressive made my day :DD

[07:36] *** jpn joined
[07:41] *** jpn left
[07:42] <discord-raku-bot> <nemokosch> > When I was looking at the language, I didn't find the documentation "really poor". In fact I was impressed at how much of a one-stop-shop the official docs site was for both conceptual docs and API docs. okay, I think it was only fair that this opinion also popped up

[07:45] <discord-raku-bot> <nemokosch> there are many based takes in that thread

[07:57] *** jpn joined
[08:04] *** jpn left
[08:10] *** dakkar joined
[08:14] *** teatime left
[08:15] *** teatime joined
[08:16] *** teatwo joined
[08:19] *** teatime left
[08:25] <SmokeMachine> m: say (rand xx 10).min: :k

[08:25] <camelia> rakudo-moar 5d4bb333d: OUTPUT: «0.10457051696021624␤»

[08:25] <SmokeMachine> should we have adverbs on .min and .max?

[08:25] <lizmat> possibly

[08:26] <lizmat> it wouldn't make sense for Seq.min|max

[08:26] <lizmat> *much

[08:26] <SmokeMachine> m: my @a = rand xx 10; say @a.min: :k

[08:26] <camelia> rakudo-moar 5d4bb333d: OUTPUT: «0.22860281190188647␤»

[08:27] <SmokeMachine> lizmat: maybe not, but for Positional?

[08:27] <lizmat> sure... 

[08:49] *** siavash left
[08:57] <discord-raku-bot> <nemokosch> There is an issue for it I think

[09:01] <discord-raku-bot> <nemokosch> https://github.com/Raku/problem-solving/issues/367

[09:14] *** abraxxa joined
[09:17] *** jpn joined
[09:19] *** jmcgnh left
[09:32] *** jmcgnh joined
[09:36] *** jpn left
[09:45] *** jpn joined
[09:52] *** sftp left
[09:52] *** a3r0 left
[09:52] *** tbrowder__ left
[09:52] *** gordonfish left
[09:52] *** avar left
[09:52] *** tib_ left
[09:52] *** BinGOs left
[09:52] *** rba left
[09:52] *** dpk left
[09:52] *** leont left
[09:52] *** bd3i left
[09:56] <SmokeMachine> m: say given 13 { 42 } # Is this a LTA error message? should it suggest say do given 13 { 42 } ?

[09:56] <camelia> rakudo-moar 5d4bb333d: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Unsupported use of bare "say".  In Raku please use: .say if you meant␤to call it as a method on $_, or use an explicit invocant or argument,␤or use &say to refer to the function as a noun.␤at <tmp…»

[10:04] *** sftp joined
[10:04] *** a3r0 joined
[10:04] *** tbrowder__ joined
[10:04] *** gordonfish joined
[10:04] *** avar joined
[10:04] *** tib joined
[10:04] *** BinGOs joined
[10:04] *** rba joined
[10:04] *** dpk joined
[10:04] *** leont joined
[10:04] *** bd3i joined
[10:14] *** razetime left
[10:30] *** razetime joined
[10:40] <lizmat> m: .say given 13 { 42 }

[10:40] <camelia> rakudo-moar 5d4bb333d: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> .say given 13⏏ { 42 }␤    expecting any of:␤        infix␤        infix s…»

[10:40] <lizmat> hmmm

[10:41] <discord-raku-bot> <nemokosch> Legit

[10:42] <discord-raku-bot> <nemokosch> The surprise is rather that the error message changed, i.e the say took precedence over the mere syntax

[10:50] *** abraxxa left
[11:32] *** abraxxa joined
[12:00] *** reportable6 left
[12:01] *** euandreh left
[12:01] *** reportable6 joined
[12:03] * lizmat clickbaits https://rakudoweekly.blog/2023/08/07/2023-32-rakudoc-gamma/

[12:07] *** jpn_ joined
[12:08] *** jpn left
[12:08] *** squashable6 left
[12:11] *** squashable6 joined
[12:12] *** jpn_ left
[12:22] <lizmat> SmokeMachine: with regards to .min :k    what's wrong with minpairs?

[12:22] <lizmat> m: dd <a b a c a d>.minpairs

[12:22] <camelia> rakudo-moar 5d4bb333d: OUTPUT: «(0 => "a", 2 => "a", 4 => "a").Seq␤»

[12:23] <SmokeMachine> lizmat: my lack of knowledge about that... :)

[12:23] <discord-raku-bot> <nemokosch> anyway, what's wrong with min :k ?

[12:24] <SmokeMachine> lizmat: but probably, if .min had :p that wouldn't need to exist...

[12:24] <lizmat> yeah, but then we get to the semantics: what if there's more than one min / max ?

[12:24] *** ab5tract joined
[12:25] <lizmat> I think that's better covered in the name this way

[12:25] <lizmat> (with the s at the end)

[12:25] <discord-raku-bot> <nemokosch> that should be an orthogonal manner tbh

[12:26] <discord-raku-bot> <nemokosch> even different values can compare equal

[12:26] <discord-raku-bot> <nemokosch> so it's kind of hackish to assume the only reason you want all minimums is to get the key

[12:28] <discord-raku-bot> <nemokosch> at the end of the day, minpairs wouldn't be needed if min had a :k and an :a(ll) flag

[12:30] <SmokeMachine> :s? (as for plural) .min: :s (mins)

[12:31] <discord-raku-bot> <nemokosch> the three hard problems in IT

[12:31] *** samebchase left
[12:32] <SmokeMachine> it's not global, but it would be kind  of consistent with regex it it was :g (just wondering...)

[12:32] *** samebchase joined
[12:32] <drakonis> lizmat: that url points to moonchild's comment

[12:32] <lizmat> drakonis: which URL ?

[12:32] <drakonis> https://news.ycombinator.com/item?id=37040681#37041705 this one

[12:33] <drakonis> which you added to the weekly blog post tracker

[12:33] <lizmat> aaah... ok:

[12:33] <lizmat> weekly: https://news.ycombinator.com/item?id=37040681

[12:33] <notable6> lizmat, Noted! (weekly)

[12:33] <lizmat> drakonis++

[12:33] <drakonis> i see

[12:33] <drakonis> there it is

[12:43] *** ab5tract left
[12:44] *** jpn joined
[12:55] *** jpn left
[12:58] <discord-raku-bot> <nemokosch> Perl seems to have a great record of "popcorn grabber" moments in the community lmfao

[12:58] <lizmat> it was less fun on stage

[12:58] <discord-raku-bot> <nemokosch> I wonder if drama is mandatory in open-source communities

[12:58] *** jpn joined
[12:59] <lizmat> I hope it isn't

[12:59] <teatwo> drama is mandatory in communities

[12:59] <lizmat> but it definitely appears to be customary

[12:59] <drakonis> what is this about?

[13:00] <teatwo> you just do the best you can, I think Perl community is waaay above average

[13:00] <teatwo> also you can't do big, impactful work w/o upsetting some people

[13:01] <discord-raku-bot> <nemokosch> I was thinking that in a corporatist setup it's simply not affordable, it explodes quicker in case

[13:07] <tbrowder__> hi, i just saw an article about 'cython' on Code Project and thought about our NativeCall. It would be a giant Raku selling point if App::GPTrixie could be enhanced to handle the latest standard C and C++ open source compilers. it would be nice if someone with the chops and time could apply for a grant to do that.

[13:14] *** razetime left
[13:14] *** razetime_ joined
[13:18] <lizmat> nemokosch I'm pretty sure the RHS of ~~ is not thunky, where did you get that idea from?

[13:21] <discord-raku-bot> <nemokosch> well, how do I illustrate this, other than "trust me bro"

[13:22] <discord-raku-bot> <nemokosch> anyway, it needs to be thunky, if you think about it. The topic of the RHS is set to the value coming from the LHS, BUT for nothing else

[13:22] <discord-raku-bot> <nemokosch> Do you see any other way to do that?

[13:24] *** tankf33der joined
[13:24] <lizmat> thing is that if you see how ~~ is QASTed, it is just a call to &infix:<~~> with two arguments (by value)

[13:25] <discord-raku-bot> <nemokosch> m: my $result = 1 ~~ say($ + $); dd $result

[13:25] <discord-raku-bot> <Raku eval>  2  Bool $result = Bool::True 

[13:25] <discord-raku-bot> <nemokosch> that's just not what the behavior is like

[13:26] <lizmat> smartmatch against True always matches    and say returns True

[13:27] <discord-raku-bot> <nemokosch> yes, that's not the thing. The thing is that by the time say ran, it knew that the topic needs to be 1

[13:27] <discord-raku-bot> <nemokosch> in other words, the left handside was evaluated and was already passed into the right handside

[13:28] *** Ven_de_Thiel joined
[13:28] <discord-raku-bot> <nemokosch> m: my $result = &infix:<~~>(1, say($ + $)); dd $result

[13:28] <discord-raku-bot> <Raku eval>  0  Use of uninitialized value of type Any in numeric context   in block <unit> at main.raku line 1 Use of uninitialized value of type Any in numeric context   in block <unit> at main.raku line 1 Bool $result = Bool::True 

[13:28] <discord-raku-bot> <nemokosch> that's not something a normal subroutine call could achieve

[13:32] <lizmat> m: my $result = 1 ~~ say($ + $); dd $result

[13:32] <camelia> rakudo-moar 1579da00a: OUTPUT: «Use of uninitialized value of type Any in numeric context␤0␤  in block <unit> at <tmp> line 1␤Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤Bool $result = Bool::True␤»

[13:32] <lizmat> I wonder why the Raku eval bot produces a different result

[13:33] <discord-raku-bot> <nemokosch> oh damn

[13:33] <discord-raku-bot> <nemokosch> the question is, what did you see?

[13:33] <lizmat> <Raku eval>  2  Bool $result = Bool::True 

[13:33] <discord-raku-bot> <nemokosch> yeah that part was okay, I mean the code

[13:33] <discord-raku-bot> <nemokosch> because mine was $_ + $_

[13:33] <lizmat> my $result = 1 ~~ say($ + $); dd $result

[13:33] <evalable6> lizmat, rakudo-moar 4b69dd51e: OUTPUT: «Use of uninitialized value of type Any in numer…»

[13:33] <evalable6> lizmat, Full output: https://gist.github.com/321cdc5bbe70f6d61daee9958264ec37

[13:34] <discord-raku-bot> <nemokosch> I thought the markdown was only a client-side hackery but then apparently it doesn't carry through the bridge at all??

[13:34] *** NemokoschKiwi joined
[13:35] <NemokoschKiwi>  my $result = 1 ~~ say($_ + $_); dd $result

[13:35] <evalable6> NemokoschKiwi, rakudo-moar 4b69dd51e: OUTPUT: «2␤Bool $result = Bool::True␤»

[13:35] <lizmat> ok that makes more sense and is indeed   intriguing

[13:35] <NemokoschKiwi> m: my $result = &infix:<~~>(1, say($_ + $_)); dd $result

[13:35] <camelia> rakudo-moar 1579da00a: OUTPUT: «Use of uninitialized value of type Any in numeric context␤0␤  in block <unit> at <tmp> line 1␤Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤Bool $result = Bool::True␤»

[13:35] <discord-raku-bot> <nemokosch> $ test $

[13:35] <NemokoschKiwi> pfft

[13:36] <lizmat> looking at the QAST it is indeed doing some trickery with $_

[13:36] <NemokoschKiwi> I wonder how the bot works that markdown there is markdown here xd

[13:36] <NemokoschKiwi> **asd**

[13:36] <NemokoschKiwi> yeah, it's not raw string

[13:36] *** NemokoschKiwi left
[13:37] <lizmat> TIL  :-)

[13:37] <discord-raku-bot> <nemokosch> so yeah ^^ part of the reason ~~ m/.../ seems so antagonistic

[13:37] <discord-raku-bot> <nemokosch> it actually makes the match call as the thunky part, AND THEN matches to the returned match object

[13:38] <discord-raku-bot> <nemokosch> this is why smartmatching of Match objects needs to be the RHS itself 😢

[13:38] <lizmat> looks like

[13:39] <discord-raku-bot> <nemokosch> and this is why one of my "Christmas wishes" for RakuAST is to have a syntactic transformation for ~~ m/../ and the likes

[13:40] <discord-raku-bot> <nemokosch> so that they indeed just call .match, .subst and so on, acknowledging that they are special cases

[13:43] *** xinming left
[13:45] *** xinming joined
[13:47] <discord-raku-bot> <nemokosch> this is one of the few cases where it's relatively simple to propose a solution that "saves the code", rather than "this shouldn't ever be tried, case closed"

[14:01] *** jagtalon joined
[14:11] <discord-raku-bot> <antononcube> Somebody has been pushing lots of P5* modules in raku.land — that might be an usurping assault attempt!!!

[14:11] <lizmat> antononcube  that would be me, and they're old

[14:11] <discord-raku-bot> <antononcube> Never mind, it is Liz…

[14:12] <discord-raku-bot> <antononcube> @lizmat Good luck! 🙂

[14:12] <lizmat> antononcube I realized yesterday that a small change in these modules, would make it possible for $_ to not have to be marked as "dynamic" anymore

[14:12] <lizmat> which makes it *much* better optimizable

[14:13] <discord-raku-bot> <antononcube> Do you mean “across all Raku”, or “just” the Perl5 sub-parts.

[14:13] <lizmat> all across Raku

[14:13] <lizmat> these P5xxx modules where basically blocking that]

[14:15] <discord-raku-bot> <antononcube> Wow! I assume (maybe wrongly) that epiphany is a byproduct of the articles you wrote on Perl5->Raku syntax  ?

[14:15] <lizmat> no, vrurg was responsible for that  

[14:16] <lizmat> the articles had been mostly written already about 2.5 years ago

[14:16] <Ven_de_Thiel> I guess that breaks the filemode operators?

[14:16] <lizmat> Ven_de_Thiel ??   P5-X you mean, or the Raku ones ?

[14:17] <Ven_de_Thiel> P5-X

[14:17] <lizmat> nope, it doesn't

[14:17] <vrurg_> lizmat: responsible for what?

[14:17] *** vrurg_ is now known as vrurg

[14:17] <discord-raku-bot> <antononcube> @lizmat Agh, ok. 😉

[14:17] <lizmat> instead of CALLERS::<$_>  it now uses CALLER::LEXICAL::<$_>

[14:18] <Ven_de_Thiel> ah :)

[14:18] <lizmat> vrurg realizing ^^

[14:18] <discord-raku-bot> <antononcube> @lizmat “these P5xxx modules where basically blocking that]“ — That might be a subject of another interesting/instructive article.

[14:18] <vrurg> Ah, OK. :)

[14:18] * vrurg was worried that something needs fixing. 

[14:18] <lizmat> m: sub a() { dd CALLER::LEXICAL::<$a> }; my $a = 42; a

[14:18] <camelia> rakudo-moar 1579da00a: OUTPUT: «Int $a = 42␤»

[14:19] <lizmat> the $a is *not* marked as dynamic

[14:19] <discord-raku-bot> <antononcube> @vrurg I was trying to raise a fake “Perl5 is coming” alarm because of too much coffee.

[14:20] <discord-raku-bot> <nemokosch> it isn't marked as dynamic, indeed. But what does this change about how it works?

[14:20] <Ven_de_Thiel> it means you don't need a dynamic $_ to use that behavior

[14:20] <lizmat> what Ven_de_Thiel said  :-)

[14:20] <discord-raku-bot> <nemokosch> what does that mean in practice, though?

[14:20] <lizmat> CALLERS::<$_> requires t to be dynamic

[14:20] <discord-raku-bot> <antononcube> Which means faster or safer code?

[14:21] <discord-raku-bot> <nemokosch> why is this CALLER::LEXICAL:: lookup better than the one before?

[14:21] <lizmat> it's better because it doesn't require the looked up thing to be marked as dynamic

[14:21] <lizmat> m: sub a() { dd CALLERS::<$a> }; my $a = 42; a

[14:21] <camelia> rakudo-moar 1579da00a: OUTPUT: «Int $a = 42␤»

[14:21] <lizmat> hmmm

[14:21] <lizmat> that is...  huh?

[14:22] <lizmat> m: sub a() { dd CALLERS::<$_> }; my $a = 42; a

[14:22] <camelia> rakudo-moar 1579da00a: OUTPUT: «Any $_ = Any␤»

[14:22] <discord-raku-bot> <nemokosch> surprising surprises

[14:22] <lizmat> indeed

[14:22] <vrurg> lizmat: The problem is that CALLERS:: won't see $a in the immediate caller lexical scope.

[14:24] <Ven_de_Thiel> m: sub a() { dd CALLERS::<$_> }; a with 42

[14:24] <camelia> rakudo-moar 1579da00a: OUTPUT: «Rakudo::Internals::LoweredAwayLexical␤»

[14:24] <Ven_de_Thiel> meh

[14:24] *** Ven_de_Thiel left
[14:26] <discord-raku-bot> <nemokosch> hah, I just came across your name in some historical module repo

[14:26] <discord-raku-bot> <nemokosch> like an hour ago or so

[14:29] *** Ven_de_Thiel joined
[14:29] <Ven_de_Thiel> m: sub a() { dd CALLERS::<$_> }; a with 42

[14:29] <camelia> rakudo-moar 1579da00a: OUTPUT: «Rakudo::Internals::LoweredAwayLexical␤»

[14:29] <Ven_de_Thiel> lol

[14:30] <lizmat> I'm wondering if some optimization somewhere knows it can get away with lowering $_

[14:31] <lizmat> m: sub a() { dd CALLERS::<$_> }; $_; a with 42

[14:31] <camelia> rakudo-moar 1579da00a: OUTPUT: «WARNINGS for <tmp>:␤Useless use of $_ in sink context (line 1)␤Rakudo::Internals::LoweredAwayLexical␤»

[14:31] <lizmat> m: sub a() { dd CALLERS::<$_> }; .say; a with 42

[14:31] <camelia> rakudo-moar 1579da00a: OUTPUT: «(Any)␤Rakudo::Internals::LoweredAwayLexical␤»

[14:31] <lizmat> hmmm

[14:31] <vrurg> Ven_de_Thiel: $_ gets optimized away because it is not used in a lexical scope other than where it's declared. CALLERS::<$_> is a dynamic operation and the optimizer can't be aware of it.

[14:32] <vrurg> m: sub a() { dd CALLERS::<$_> }; with 42 { .say; a }

[14:32] <camelia> rakudo-moar ec0007729: OUTPUT: «42␤Rakudo::Internals::LoweredAwayLexical␤»

[14:32] <vrurg> m: sub a() { dd CALLERS::<$_> }; with 42 { if True { .say; }; a }

[14:32] <camelia> rakudo-moar ec0007729: OUTPUT: «42␤Rakudo::Internals::LoweredAwayLexical␤»

[14:33] <lizmat> have we found a problem?

[14:33] *** Xliff joined
[14:33] <vrurg> It's not easy to convince the optimizer it shouldn't do it because it does its best to lower lexicals.

[14:34] <vrurg> lizmat: it depends. Because the only solution would be to disable lowering of the topic.

[14:35] <vrurg> I'd rather be for a way to explicitly disable lowering when it's necessary.

[14:35] <lizmat> it was my understanding of the way I implemented the P5xxx modules inhibited the lowering of $_

[14:35] <vrurg> m: sub a() { dd CALLERS::<$_> }; with 42 { if .rand > 0 { .say; }; a }

[14:35] <camelia> rakudo-moar ec0007729: OUTPUT: «42␤Rakudo::Internals::LoweredAwayLexical␤»

[14:35] <vrurg> m: sub a() { dd CALLERS::<$_> }; with 42 { if .rand > 0 { say $_; }; a }

[14:35] <camelia> rakudo-moar ec0007729: OUTPUT: «42␤Rakudo::Internals::LoweredAwayLexical␤»

[14:36] <lizmat> perhaps we need to take this to #raku-dev  :-)

[14:36] *** Ven_de_Thiel38 joined
[14:37] <vrurg> Moving over there.

[14:37] *** rf joined
[14:37] *** Ven_de_Thiel left
[14:44] *** tankf33der left
[15:12] *** Ven_de_Thiel38 left
[15:26] <lizmat> weekly: https://lobste.rs/s/x5impj/raku_language_for_gremlins

[15:26] <notable6> lizmat, Noted! (weekly)

[15:27] *** rir joined
[15:30] *** abraxxa left
[15:32] <rir> https://news.ycombinator.com/item?id=37040681 focuses on Raku the idea of judging languages on  delightful/horrifing and surprising/unsurprising  x/y quadrants.

[15:32] <rir> ^focuses on Raku with...

[15:33] <lizmat> rir:  yeah  we've been discussing it here  :-)

[15:34] <lizmat> notable6 weekly

[15:34] <lizmat> notable6: weekly

[15:34] <notable6> lizmat, 3 notes: https://gist.github.com/4bbd2941d41ae5f69eefa5e679ab52fc

[15:34] <lizmat> notable6: weekly reset

[15:34] <notable6> lizmat, Moved existing notes to “weekly_2023-08-08T15:34:26Z”

[15:34] <lizmat> weekly: https://news.ycombinator.com/item?id=37040681

[15:34] <notable6> lizmat, Noted! (weekly)

[15:34] <lizmat> weekly: https://lobste.rs/s/x5impj/raku_language_for_gremlins

[15:34] <notable6> lizmat, Noted! (weekly)

[15:34] <lizmat> notable6: weekly reset

[15:34] <notable6> lizmat, Moved existing notes to “weekly_2023-08-08T15:34:52Z”

[15:34] <lizmat> weekly: https://news.ycombinator.com/item?id=37040681

[15:34] <notable6> lizmat, Noted! (weekly)

[15:34] <lizmat> weekly: https://lobste.rs/s/x5impj/raku_language_for_gremlins

[15:34] <notable6> lizmat, Noted! (weekly)

[15:35] <lizmat> notable6: weekly 

[15:35] <notable6> lizmat, 2 notes: 2023-08-08T15:34:57Z <lizmat>: https://news.ycombinator.com/item?id=37040681  ;  2023-08-08T15:34:59Z <lizmat>: https://lobste.rs/s/x5impj/raku_language_for_gremlins

[15:35] <lizmat> there's nothing you can do against doing the wrong thing  :-)

[15:40] *** Ven_de_Thiel joined
[15:44] <discord-raku-bot> <librasteve> since @hillel wants raku as a calculator, I thought I'd make one for him - App::Ralc is born

[15:44] <discord-raku-bot> <librasteve> ralc 'say (1.6km / (60 * 60 * 1s)).in: <mph>' #0.994194mph

[15:44] <discord-raku-bot> <librasteve> and so on...

[15:44] <Xliff> m: role A { has $!invocant; $!invocant = self }; class A { }; my $a = A.new; $a = $a but A;

[15:44] <camelia> rakudo-moar 8157c0335: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Variable $!invocant used where no 'self' is available␤at <tmp>:1␤------> role A { has $!invocant; $!invocant⏏ = self }; class A { }; my $a = A.new; $␤»

[15:45] <Xliff> m: role A { has $!invocant; submethod COMPOSE { $!invocant = self } }; class A { }; my $a = A.new; $a = $a but A;

[15:45] <camelia> rakudo-moar 8157c0335: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Redeclaration of symbol 'A'.␤at <tmp>:1␤------> COMPOSE { $!invocant = self } }; class A⏏ { }; my $a = A.new; $a = $a but A;␤    expecting any of:␤        generic role␤»

[15:45] <Xliff> m: role A { has $!invocant; submethod COMPOSE { $!invocant = self } }; class B { }; my $a = B.new; $a = $a but A;

[15:45] <camelia> rakudo-moar 8157c0335: ( no output )

[15:46] <Xliff> m: role A { has $!invocant; submethod COMPOSE { say "Y"; $!invocant = self } }; class B { }; my $a = B.new; $a = $a but A;

[15:46] <camelia> rakudo-moar 8157c0335: ( no output )

[15:46] <Xliff> m: role A { has $!invocant; submethod COMPOSE { say "Y"; $!invocant = self.compute-from-object } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A;

[15:46] <camelia> rakudo-moar 8157c0335: ( no output )

[15:47] <Xliff> m: role A { has $!invocant; submethod COMPOSE { say "Y"; $!invocant = self } method i { $!invocant.say } }; class B { }; my $a = B.new; $a = $a but A;; $a.i

[15:47] <camelia> rakudo-moar 8157c0335: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> d COMPOSE { say "Y"; $!invocant = self }⏏ method i { $!invocant.say } }; class B ␤    expecting any of:␤       …»

[15:47] <Xliff> m: role A { has $!invocant; submethod COMPOSE { say "Y"; $!invocant = self.compute-from-object }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i

[15:47] <camelia> rakudo-moar 8157c0335: OUTPUT: «(Any)␤»

[15:48] <Xliff> What is the best way to set role attributes from the object when the role is mixed in?

[15:48] <Xliff> vrurg: ^^ Does this explain why I want COMPOSE any better? Or maybe a better submethod name would be MIXIN?

[15:48] <lizmat> you can't: when the role is mixed in, it hasn't been instantiated yet

[15:49] <lizmat> so there are no attributes to assign

[15:49] <Xliff> lizmat

[15:49] <lizmat> Xliff 

[15:50] <Xliff> lizmat: Is this something that would be difficult to add?

[15:50] <lizmat> yes, because at the time a role is mixed in, there is no instantiated object yet

[15:50] <Xliff> So "$a = $a but A" is done at compile time.

[15:51] <Xliff> And there's no mechanism that tells A it needs something from $a?

[15:51] <lizmat> no it isn't

[15:51] <Xliff> I always thought "but" was more of a runtime thing.

[15:51] <lizmat> but is an infix op

[15:52] <Xliff> So I would want a custom infix op, then?

[15:52] <lizmat> ah, ok, misread / missynced

[15:52] <lizmat> that would be possible, in macro land

[15:52] <Xliff> RakuAST, then?

[15:53] <lizmat> well, yes, potentially

[15:53] <lizmat> you could try with a macro right now...  

[15:54] <Xliff> It seems to me if I have things I want abstracted into a role, then this is something that a Role should be able to accomplish.

[15:54] <Xliff> Or maybe I am going about it wrong?

[15:55] <Xliff> It seems that "$a = $a but A" might be a good place for a PHASER.

[15:56] <lizmat> well, I'm not 100% what you're trying to achieve

[15:56] <lizmat> "What is the best way to set role attributes from the object when the role is mixed in?"

[15:56] <Xliff> Yes.

[15:57] <Xliff> m: role A { has $!invocant; submethod COMPOSE { say "Y"; method setInvocant { $!invocant = self.compute-from-object }; }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.setInvocant; $a.i

[15:57] <camelia> rakudo-moar 8157c0335: OUTPUT: «P6opaque: no such attribute '$!invocant' on type $?CLASS in a B+{A} mixin when trying to get a value␤  in method setInvocant at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[15:58] <Xliff> m: role A { has $!invocant; method setInvocant { $!invocant = self.compute-from-object }; }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.setInvocant; $a.i

[15:58] <camelia> rakudo-moar 8157c0335: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Cannot understand $!invocant in this context␤at <tmp>:1␤------> -from-object }; }; method i { $!invocant⏏.say } }; class B { method compute-from-␤»

[15:58] <Xliff> m: role A { has $!invocant; method setInvocant { $!invocant = self.compute-from-object }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.setInvocant; $a.i

[15:58] <camelia> rakudo-moar 8157c0335: OUTPUT: «2023-08-08T17:58:14.541465+02:00␤»

[15:58] <Xliff> I guess something like that might work, but it's clumsy.

[15:59] *** jpn left
[16:03] <lizmat> nothing comes to mind atm

[16:05] <Xliff> OK, thanks.

[16:07] <Xliff> m: multi sub infix:<mybut> (Mu $a is rw, Mu \R) { $a = $a but R; $a.MIXEDIN };  role A { has $!invocant; method MIXEDIN { $!invocant = self.compute-from-object }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a mybut A; $a.i

[16:07] <camelia> rakudo-moar 8157c0335: OUTPUT: «No such method 'i' for invocant of type 'DateTime'.  Did you mean 'IO'?␤  in block <unit> at <tmp> line 1␤␤»

[16:07] <Xliff> m: multi sub infix:<mybut> (Mu $a is rw, Mu \R) { $a = $a but R; $a.MIXEDIN; $a };  role A { has $!invocant; method MIXEDIN { $!invocant = self.compute-from-object }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a mybut A; $a.i

[16:07] <camelia> rakudo-moar 8157c0335: OUTPUT: «2023-08-08T18:07:50.034902+02:00␤»

[16:07] <lizmat> the closest thing I can think of is an attribute on a TWEAK method in the role that would cause the calling of TWEAK to be done

[16:08] <Xliff> lizmat: ^^ something like that, maybe.

[16:08] <lizmat> after any TWEAK method in the class has done

[16:08] <lizmat> so that a TWEAK method in the class does *not* override the one from the role

[16:08] <Xliff> lizmat: Will that work if the instance has alreayd been instantiated?

[16:08] <lizmat> no, because than TWEAK will have run already ?

[16:09] <Xliff> Exactly. That's not what I want. 

[16:09] <Xliff> See previous camelia run.

[16:09] <lizmat> more exactly: the BUILDPLAN has been executed

[16:09] <lizmat> feels complicated ?

[16:10] <Xliff> That's pretty much what I need, but now all of the roles I would use would need to standardize on MIXEDIN, which I cannot guarantee.

[16:10] <Xliff> It's no more complicated than a TWEAK hack that's not guaranteed to run.

[16:10] <Xliff> So... custom infix with standardized method call for now.

[16:11] <Xliff> Thanks for the help.

[16:11] <lizmat> m: role B { method TWEAK(|) { dd "role" } }; class A { }; dd A.new but B

[16:11] <camelia> rakudo-moar 8157c0335: OUTPUT: «"role"␤A+{B}.new␤»

[16:11] <lizmat> m: role B { method TWEAK(|) { dd "role" } }; class A { method TWEAK(|) { dd "class" } }; dd A.new but B

[16:11] <camelia> rakudo-moar 4645317d7: OUTPUT: «"class"␤"role"␤A+{B}.new␤»

[16:11] <Xliff> role B { method TWEAK(|) { dd "role" } }; class A { }; my ($a, $b) = A.new xx 2; $a but B; $b but B

[16:11] <evalable6> Xliff, rakudo-moar 4b69dd51e: OUTPUT: «"role"␤"role"␤»

[16:12] <Xliff> Hmmm... maybe that does work.

[16:12] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a mybut A; $a.i

[16:12] <camelia> rakudo-moar 4645317d7: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> ateTime.now }; }; my $a = B.new; $a = $a⏏ mybut A; $a.i␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤     …»

[16:13] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i

[16:13] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:13:04.137395+02:00␤»

[16:13] <Xliff> \o/

[16:13] <lizmat> *phew*  :-)

[16:13] <Xliff> :-)

[16:18] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object }; class C does A { submethod TWEAK { say "BOO!" }; method compute-from-object{ say "BAH!" }; }; method i { $!invocant.say } }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new

[16:18] <camelia> rakudo-moar 4645317d7: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤Cannot declare our-scoped class inside of a role␤(the scope inside of a role is generic, so there is no unambiguous␤package to install the symbol in)␤at <tmp>:1␤------> lf.compute-from-object …»

[16:18] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object }; method i { $!invocant.say } }; class C does A { submethod TWEAK { say "BOO!" }; method compute-from-object{ say "BAH!" }; }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new

[16:18] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:18:51.670299+02:00␤BOO!␤»

[16:19] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object; nextsame }; method i { $!invocant.say } }; class C does A { submethod TWEAK { say "BOO!" }; method compute-from-object{ say "BAH!" }; }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new

[16:19] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:19:00.305001+02:00␤BOO!␤»

[16:19] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object; }; method i { $!invocant.say } }; class C does A { submethod TWEAK { say "BOO!"; nextsame }; method compute-from-object{ say "BAH!" }; }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new

[16:19] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:19:40.527956+02:00␤BOO!␤»

[16:20] <Xliff> Hmmm... so overloaded TWEAK does not work.

[16:20] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object; }; method i { $!invocant.say } }; class C does A { submethod TWEAK { say "BOO!"; nextsame }; method compute-from-object{ say "BAH!" }; }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new.i

[16:20] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:20:32.665734+02:00␤BOO!␤(Any)␤»

[16:20] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object; }; method i { $!invocant.say } }; class C does A { submethod TWEAK { say "BOO!"; nextsame }; method compute-from-object{ "BAH!" }; }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new.i

[16:20] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:20:45.928285+02:00␤BOO!␤(Any)␤»

[16:21] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object; }; method i { $!invocant.say } }; class C does A { submethod TWEAK { say "BOO!"; self::A::TWEAK }; method compute-from-object{ "BAH!" }; }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new.i

[16:21] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:21:38.129613+02:00␤Could not find symbol '&TWEAK' in 'GLOBAL::self::A'␤  in submethod TWEAK at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤BOO!␤»

[16:22] <Xliff> m: role A { has $!invocant; submethod TWEAK { $!invocant = self.compute-from-object; }; method i { $!invocant.say } }; class C does A { submethod TWEAK { say "BOO!"; self.::A::TWEAK }; method compute-from-object{ "BAH!" }; }; class B { method compute-from-object { DateTime.now }; }; my $a = B.new; $a = $a but A; $a.i; C.new.i

[16:22] <camelia> rakudo-moar 4645317d7: OUTPUT: «2023-08-08T18:22:07.590035+02:00␤BOO!␤BAH!␤»

[16:22] <Xliff> And there's the workaround.

[16:38] *** dakkar left
[17:05] <discord-raku-bot> <librasteve> hmmm I just rtfm and tested --- seems like the numerator of a Rat is unlimited --- I believe a better default would be to limit the numerator to 2128-1 (anyway the denominator is limited to 264)

[17:07] <lizmat> librasteve could you elaborate on that in an issue ?

[17:08] <discord-raku-bot> <librasteve> why ... well we have both Int and FatRat that are "infinite" precision and I think that for the average coder that usually anything that results in a number bigger than 2 ^ 128-1 is either a very large Real (in which case it should be in a Num) or an error in which case, there should be an (optional) warn or error

[17:08] <discord-raku-bot> <librasteve> yeah - just an issue in rakudo ok?

[17:09] *** Ven_de_Thiel left
[17:09] *** Ven_de_Thiel joined
[17:11] <lizmat> yes please  :- )

[17:19] <discord-raku-bot> <librasteve> https://github.com/rakudo/rakudo/issues/5335

[17:22] *** razetime_ left
[17:23] *** Xliff left
[17:30] *** jpn joined
[17:31] *** rf left
[17:37] *** jpn left
[17:38] <discord-raku-bot> <nemokosch> What makes this a good idea, though?

[18:00] *** reportable6 left
[18:02] *** Ven_de_Thiel left
[18:02] *** reportable6 joined
[18:17] <discord-raku-bot> <librasteve> fair question - and it does apply a limit to the current Rat size - but one principle here is that if a type gracefully UNDERFLOWs then it should also OVERFLOW in the same size region

[18:17] <discord-raku-bot> <librasteve> after all we have FatRats to give us "unlimited" precision (although I am not a fan of unlimited precision)

[18:18] *** Ven_de_Thiel joined
[18:19] <discord-raku-bot> <librasteve> do you agree with the principle that Ints, Rats, Nums and Complex should share the same unified Numeric space?

[18:19] <discord-raku-bot> <librasteve> (and FatRats)

[18:19] *** tankf33der joined
[18:39] *** Ven_de_Thiel left
[18:40] <discord-raku-bot> <librasteve> https://design.raku.org/S02.html#Numeric_Types line_810 ... looks like I am asking for a Rat64 ... I have closed the issue for now since this was considered and decided a long time ago

[18:42] *** Tirifto left
[18:43] *** Tirifto joined
[18:45] <vrurg> Xliff: I don't have time to read it all through, but in 6.e TWEAK is absolutely legal way to achieve your goal.

[18:45] <tellable6> vrurg, I'll pass your message to Xliff

[19:02] *** ab5tract joined
[19:15] *** Ven_de_Thiel joined
[19:18] *** ab5tract left
[19:32] *** Ven_de_Thiel left
[19:33] *** jpn joined
[19:50] *** jpn left
[20:16] *** teatwo left
[20:16] *** teatwo joined
[20:21] *** tea3po joined
[20:23] *** tea3po left
[20:24] *** tea3po joined
[20:24] *** teatwo left
[20:35] *** jpn joined
[20:48] *** Ven_de_Thiel joined
[21:25] *** ab5tract joined
[21:30] *** kst joined
[21:53] *** jpn left
[22:02] *** Ven_de_Thiel left
[22:11] *** ab5tract left
[22:49] *** jpn joined
[22:52] <discord-raku-bot> <nemokosch> okay, I learned it the hard way that this HackerNews has a funny idea about what "posting too fast" means

[22:53] <discord-raku-bot> <nemokosch> I don't know, maybe 5 messages in 15 minutes? Now I wonder how much of a cooldown somebody has to bear for this crime

[22:54] *** jpn left
[22:56] *** ab5tract joined
[22:57] <guifa> TIL

[22:59] <guifa> in perl you can reference named regexen internally

[22:59] <guifa> but I don't think we have an equivalent in Raku do we?

[23:01] <guifa> something akin to / $<hex>=<[0..9a..z]> '-' <hex> ** 3/ which would match any four hex digits with a dash between the first two

[23:01] *** rir_ joined
[23:02] *** rir left
[23:02] <guifa> m: say '0-a4f' ~~ / $<hex>=<[0..9a..z]> '-' &<hex> ** 3/;

[23:02] <camelia> rakudo-moar 8b4aca57a: OUTPUT: «Nil␤»

[23:03] <guifa> m: say '0-a4f' ~~ / $<hex>=<[0..9a..z]> '-' <hex> ** 3/;

[23:03] <camelia> rakudo-moar 8b4aca57a: OUTPUT: «No such method 'hex' for invocant of type 'Match'␤  in block <unit> at <tmp> line 1␤␤»

[23:08] *** ab5tract left
[23:16] <guifa> is there any way to do that without a complicated workaround?

[23:18] <guifa> I guess I could do /:my $hex = /<[0..9a..z]>/; $hex '-' $hex ** 3/; to keep things simple but feels like &<hex> or even &hex should work 

[23:19] *** rf joined
[23:23] *** Sgeo joined
[23:29] *** rf left
[23:38] <discord-raku-bot> <nemokosch> isn't it enough to just define a regex and then use it in the other regex?

[23:40] <guifa> I mean, probably.  But if it's a one for that regex

[23:51] <discord-raku-bot> <nemokosch> disclaimer, there is still a non-negligible chance that there is something we just don't know about, this is Raku, after all

[23:51] <guifa> yeah

[23:51] <discord-raku-bot> <nemokosch> but at the same time, this desperately seems like something that would just be a weird flex nobody actually demands

[23:52] <discord-raku-bot> <nemokosch> my regex hex { ... } and then using <hex> is really just fine

[23:58] <guifa> I mean, it has been Perl regex for quite sometime (albeit slightly different syntax, but basically the idea of one sequence is match the stringy result of a named match, and the other is used the regex code of the named match).  I haven't gone through all major engines yet but I imagine it's not the only one

[23:59] *** wayland joined
