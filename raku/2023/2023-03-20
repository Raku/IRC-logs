[00:00] *** reportable6 left
[00:02] *** reportable6 joined
[00:21] *** cacci left
[01:01] <leont> I'm observing that «raku -e 'unit sub MAIN(:$foo);' --foo» gives warnings from rakudo's own argument handling (as in of the binary, not the Raku level argument handling). I'm pretty sure it didn't use to do that (but I don't have an old rakudo laying around)

[01:05] <leont> Oh, it's more fascinating than that. It works as I expect when there's a space between -e and its argument, but breaks if there isn't. That has got to be a bug.

[01:12] <lucs> <https://docs.raku.org/language/modules.html> mentions:

[01:13] <lucs> "｢require｣ loads a compunit and imports definite symbols at runtime."

[01:13] <lucs> What are "definite symbols"?

[01:13] <guifa_> probably should read "defined symbols", as in the symbols defined as exported by the module

[01:13] <guifa_> actually, "exported symbols" is probably even better

[01:14] <lucs> I guess that would make sense.

[01:14] <lucs> I wonder how sentences like that get produced...

[01:14] <guifa_> probably by people whose native language isn't English

[01:14] <guifa_> definite and definite are fairly close in meaning

[01:14] <guifa_> err

[01:14] <guifa_> defined and definite 

[01:15] <lucs> Right.

[01:15] *** zebzzw joined
[01:15] <lucs> But even "defined" doesn't seem to convey what is meant.

[01:15] <guifa_> defined in the sense of "defined by the module" (which is different from being defined in the assigned context)

[01:16] <guifa_> hooray for English ambiguity lol

[01:17] *** clsn_ left
[01:25] *** initrd joined
[01:43] <lucs> Welp, after a bunch of tests, 'require Foo;' appears to be unable to import anything, no matter how they are declared in Foo.rakumod.

[01:44] <lucs> I hope I'm just missing something.

[01:44] <guifa_> So if my memory serves me correctly, `require Foo` might only give you access to `our` scoped variables

[01:45] <guifa_> rather than exported

[01:45] <guifa_> via Foo::whatever

[01:45] <guifa_> in other words, the docs are really poorly worded

[01:46] <lucs> Was about to say... :)

[01:46] <lucs> Which is sad, because hey, they're the docs.

[01:50] <guifa_> Tbh, require isn't used very often

[01:50] <guifa_> most people just use, well, use

[01:51] <lucs> I understand, but still, LTA.

[01:51] *** razetime joined
[01:52] <lucs> If I understood it more, I'd offer a pull request, but right now, the best I can do is raise and issue that would basically say "That doc doesn't work.", and that's not very helpful.

[01:52] <lucs> *an

[01:53] <guifa_> just put in an issue instead

[01:54] <lucs> (I'm not even able to work out a correct "our" usage to make an export work.)

[01:54] <guifa_> seriously, that's hugely helpful, anytime a doc isn't clear, that's something that needs to be fixed

[01:54] <guifa_> so in theory with our

[01:54] <guifa_> it should be

[01:54] <guifa_> module Foo { our $foo = 42); 

[01:54] <guifa_> then later

[01:54] <guifa_> require Foo; say $Foo::foo; 

[01:54] <guifa_> or 

[01:55] <guifa_> say Foo::<$foo>

[01:55] * guifa_ is saying this from memory so don't quote him

[01:55] <lucs> I was trying with  class Foo {our method foo {say "FOO"}  , and later  sa

[01:56] <lucs> Dammit, pressed return before finishing editing, please disregard.

[01:58] <lucs> Your example works.

[01:58] <guifa_>                                                  -

[01:59] <guifa_> if I can ask, is there any reason you're using require instead of use?

[02:00] <lucs> For help with development: given a foo.raku, I want to either 'require FooVersionOne' or '...VersionTwo' for example, based on some condition.

[02:01] <lucs> It's not intended to be in released code.

[02:02] <lucs> There are othe ways to do this of course, but I wanted to try with 'require'.

[02:04] *** cacci joined
[02:05] <guifa_> yeah I think the run-time loading of symbols is a little tricky, because at compile time it can't be sure what's available

[02:05] <guifa_> so you have to indirect references

[02:05] <guifa_> in the docs that's mentioned as 

[02:06] <guifa_> ::("Foo::EXPORT::exportpackage::symbol_name")

[02:06] <lucs> Ah, I see that, right.

[02:07] <guifa_> (indirects are always resolved at runtime, which is needed because `requries` is a runtime thing)

[02:07] <lucs> I seem to remember it was easier in Perl, where 'use' was kind of like 'require', then 'import'.

[02:08] <lucs> (Perl was easier, but a lot less powerful, there is that :-) )

[02:08] <guifa_> I think the general idea is that  MOST of the time you just want to use, well, `use`

[02:09] <lucs> That is certainly my experience.

[02:10] <guifa_> Raku really pushes hard the idea of torturing the developer to benefit the user

[02:10] <guifa_> optional importing is definitely a module developer level thing -- an end user should know what modules they have and just install accordingly

[02:10] <lucs> Hehe! I like that, even though I'm not much of a masochist.

[02:11] <guifa_> I definitely take it to the extreme in my modules.  I like to make it so they ultimately export a single sub or two, and make the end user completely unaware of all the stuff going on in the background

[02:17] <lucs> I totally agree. The interface to a module should be as simple as possible.

[02:18] <lucs> And if there are many features, good defaults should cover the most frequent usages.

[02:27] <lucs> (reported the doc issue)

[02:29] <guifa_> Right now I'm working on an international number formatter

[02:29] <guifa_> 99% of users will just use `format-number $number`

[02:30] <guifa_> but I do have an advanced interface for power users who need extra control, by way the more traditional `number-formatter(%options)`, that produces a callable

[02:31] <lucs> I know there are comma vs period delimiter differences, but I don't know of others.

[02:31] <lucs> Will be interesting to see.

[02:31] <guifa_> ha there's a lot

[02:31] <guifa_> what symbols are used for digits (01234, versus eastern arabic, versus a bunch of other systems)

[02:32] <lucs> I'm sure there are. I've been confronted to my ignorance often enough to expect unexpected stuff a lot :)

[02:32] <guifa_> how large numbers are separated (e.g. English in most countries uses 123,456,789; but in India, it's 1,234,567,89)

[02:33] *** initrd left
[02:33] <guifa_> and I think some places do 1,2345,6789 because their systems are based on myriads

[02:38] * guifa_ is afk

[02:41] <lucs> (crazier than I'd ever have thought)

[03:10] *** cacci left
[03:17] *** rf left
[03:25] *** razetime left
[04:00] *** razetime joined
[04:34] *** razetime1 joined
[04:36] *** razetime left
[04:36] *** razetime1 is now known as razetime

[05:21] *** razetime1 joined
[05:22] *** razetime left
[05:22] *** razetime1 is now known as razetime

[05:51] *** razetime1 joined
[05:51] *** razetime left
[05:51] *** razetime1 is now known as razetime

[05:52] *** razetime left
[05:54] *** nort joined
[05:55] *** razetime joined
[06:00] *** reportable6 left
[06:01] *** razetime left
[06:02] *** reportable6 joined
[06:35] *** abraxxa joined
[06:49] *** tea3po left
[06:49] *** tea3po joined
[06:50] *** japhb left
[06:55] *** Sgeo left
[06:57] *** japhb joined
[07:07] *** tea3po left
[07:07] *** tea3po joined
[07:33] *** jpn joined
[07:48] *** jpn left
[08:05] *** jpn joined
[08:15] *** jpn left
[08:57] *** dakkar joined
[09:22] *** jpn joined
[09:33] *** jpn left
[09:35] *** jpn joined
[10:17] *** cacci joined
[11:06] <discord-raku-bot> <Nemokosch> Yesterday, I messed around with RakuConfig and string serialization overall, because of the syntax highlighter

[11:06] <discord-raku-bot> <Nemokosch> Today, it paid off: there is a Template6 issue I can finally take up on.

[11:12] *** peder left
[11:17] *** sena_kun joined
[11:18] <Geth> ¦ Raku-Steering-Council/main: 89250c6fa4 | (Elizabeth Mattijsen)++ | minutes/20230318.md

[11:18] <Geth> ¦ Raku-Steering-Council/main: Add minutes of 18 March 2023 meeting

[11:18] <Geth> ¦ Raku-Steering-Council/main: review: https://github.com/Raku/Raku-Steering-Council/commit/89250c6fa4

[11:26] *** peder joined
[11:42] *** peder left
[11:43] <lizmat> and yet another Rakudo Weekly News hits the Net: https://rakudoweekly.blog/2023/03/20/2023-12-priced-2/

[11:45] *** peder joined
[12:00] *** reportable6 left
[12:02] *** reportable6 joined
[12:23] *** mtj left
[12:34] <discord-raku-bot> <Nemokosch> the docs say: "Heredocs include the newline from before the terminator."

[12:35] <lizmat> and they do?

[12:35] <discord-raku-bot> <Nemokosch> what if I don't want that newline to be added? do I just chomp it or is there a more official way?

[12:37] <lizmat> chomp is what I always use

[12:37] <lizmat> q:to/FOO/.chomp

[12:38] <lizmat> or .chop

[12:44] <discord-raku-bot> <Nemokosch> hm okay, .chomp will do I suppose. It's not the worst thing to happen that something can be solved from code, without entering yet another tricky escape situation

[12:45] <lizmat> if you're worried about speed, .chop is quicker I think, but .chomp more conveys meaning

[13:12] *** kolibrie joined
[13:23] <kolibrie> I have a program that I intend to run for days or weeks at a time, but it is being killed by the OS after a day or so, I think because it is using up too much memory (growing over time). I would like to be able to debug the memory leak and find out where it is happening, so I can fix it. What tools, modules, or procedures do you recommend for

[13:23] <kolibrie> tracking down a memory leak? The program itself is short, but uses a multitude of modules, some of which are custom built for this program, and some that are open source. What seems ideal to me would be to have a list of which objects exist, with snapshots of that over time, so I can see which objects are growing in number, and which are staying

[13:23] <kolibrie> relatively stable. Or maybe there is something better. What do you recommend?

[13:33] *** jgaz joined
[13:38] *** rf joined
[13:39] <lizmat> kolibrie perhaps https://commaide.com/features 's features wrt to running and debugging could be of help ?

[13:39] <lizmat> you would need the paid version for the profiler though

[13:41] <rf> Morning folks

[13:41] <lizmat> rf o/

[13:42] *** peder left
[13:44] <discord-raku-bot> <Anton Antonov> @rf "Humming-Bird is a very unopinionated web framework." -- Yeah, right.

[13:44] <rf> :^) it's just functions

[13:44] *** peder joined
[13:45] <discord-raku-bot> <Anton Antonov> @rf Sure. Basically that is a popular excuse to be lazy and not make the necessary functionalities that facilitate rapid development.

[13:46] <jast> can't have everything :)

[13:46] <discord-raku-bot> <Anton Antonov> In other words -- opinionated frameworks are more useful.

[13:46] <jast> (I have no familiarity with Humming-Bird but more generally you can't check all the boxes in *any* project)

[13:46] <jast> depends on what you want

[13:46] <jast> things designed for rapid development can have downsides for more complex / more mature projects

[13:46] <discord-raku-bot> <Anton Antonov> @jast Not everything, just the most common, popular, or useful.

[13:46] <rf> I disagree. I made Humming-Bird so that people could structure, design, and create systems that make sense to them

[13:47] <rf> I don't want to impose a strict guideline on how to build systems, rather, I'd prefer to give them the tools to do so

[13:47] <jast> I do like unopinionated projects, and a subset of opinionated ones

[13:47] <discord-raku-bot> <Anton Antonov> @rf I get it. (Still sounds like excuse for laziness.)

[13:48] <jast> of course some things do suffer from being unopinionated, too

[13:48] <discord-raku-bot> <Anton Antonov> @rf Generally speaking, documenting other approaches might be useful.

[13:49] <discord-raku-bot> <Anton Antonov> @rf It looks like that blog post refers to two, right? (Or is it just one.)

[13:49] <rf> The only opinions Humming-Bird has is that your routes type Request, Response -> Response and I prefer it that way. If I wanted an opinionated framework I would have used Cro

[13:49] <jast> the straightforward way to make something unopionated more friendly for rapid development is to layer an optional, more opinionated thing on top of it

[13:50] <jast> and whether that's up to the original maintainer or other people... well, matter of opinion :)

[13:50] <kolibrie> lizmat Thanks for your recommendation. Looking at a summary of what the comma profiler reports on, I'm not sure how that would help me. Have you used it for tracking down memory leaks?

[13:50] <discord-raku-bot> <Anton Antonov> @rf I have only heard (or remembered) leont making statements like that. (Including Cro.)

[13:51] <jast> looking at other languages there's a huge market for very unopinionated web frameworks that are mostly "just functions"

[13:51] <lizmat> kolibrie: no, I'm stockholm syndromed to vim  :-)

[13:51] <jast> come to the dark side (emacs + evil-mode) :-)

[13:52] <discord-raku-bot> <Anton Antonov> Amsterdam syndromed too.

[13:52] <leont> Anton Antonov: what did I say?

[13:52] <lizmat> well, I was born in Amsterdam, so that's hard to forget  :-)

[13:52] <discord-raku-bot> <Anton Antonov> @leont 🙂 Hi!

[13:52] <discord-raku-bot> <Anton Antonov> @leont "The distance to Cro matters." (For Raku projects.)

[13:53] <kolibrie> @lizmat I'm also a vim user.

[13:53] * leont was also born in Amsterdam and a vim user 😛

[13:53] <discord-raku-bot> <Anton Antonov> @lizmat You might have seen this : "They say I have been in Amsterdam, but I don't remember..."

[13:53] <jast> I've been to Amsterdam and I used to use vim pretty much exclusively

[13:54] <jast> so you're basically past me

[13:54] <lizmat> Anton Antonov then you must have had a good time :-)

[13:54] <discord-raku-bot> <Anton Antonov> So, my speculation is that lizmat tries other non-vi(m) editors, but remembers/recalls only vi(m) the next day.

[13:55] <lizmat> :-)

[13:56] <discord-raku-bot> <Anton Antonov> @lizmat Just in passing to a conference in Egmond aan Zee.

[13:58] <rf> Anton another thing is, I think web-development should be fun too. I find it's a lot more enjoyable to work on less-opinionated frameworks.

[14:00] *** kolibrie left
[14:02] <discord-raku-bot> <Nemokosch> The problem with opinionated framework is that you learn something that you don't even know if you need, or why you need it

[14:02] <discord-raku-bot> <Anton Antonov> @rf I get it. I am saying that you should/could demonstrate that the framework is non-opinionated by building different, opinionated solutions with it. Ideally, for the same problem (but that might be boring.)

[14:02] <discord-raku-bot> <Nemokosch> which breaks down especially badly if there are more meaningful approaches

[14:02] *** kolibrie joined
[14:04] <rf> I write a lot of Spring-Boot for my job, it's super duper opinionated, I hate it. Mainly because the ideas don't cross-over to other languages or frameworks. That's one thing I wanted to avoid as well.

[14:10] *** sena_kun left
[14:15] *** kolibrie left
[14:20] <jast> somewhat unrelated: I'm working on designing (not implementing yet :-)) a somewhat opinionated (non-Raku) web framework where data is virtually always operated on in RAM without fetches from disk/network, but still allowing Web Scale™. It's... complicated. :-)

[14:21] <jast> currently researching ways to achieve fast reads on distributed consensus based top-level metadata without breaking the current design. fun stuff.

[14:23] <El_Che> jast: everything in RAM, mm. When I think about springboot I think of our containerized apps that use 2-4 gig RAM to do less that out Go apps do with 20-40 mb :)

[14:23] <jast> the goal was to do it in a language that doesn't treat RAM like candy :-)

[14:23] <El_Che> jast: so the "adding everything in RAM" sound weird because I thought maybe they were already doing that 

[14:23] <El_Che> :)

[14:24] <El_Che> *sound

[14:24] <jast> the thing they're doing is probably slightly different, it's a complicated technology called "bloat"

[14:24] <El_Che> they are good at it

[14:24] <El_Che> :)

[14:25] <jast> I was planning to give the application code the illusion that all the data it needs is always available in RAM, except in certain cases where it needs to work on data dependencies involving billions of objects

[14:25] <El_Che> talking about bload Java-based Keycloak moved from wildfly/jboss to quarkus and now it uses 1/4 of the ram as before in my usedcase (a busy oidc provider)

[14:26] <jast> and in well-defined cases all of the data needed for an operation *is* actually in RAM so you get free linearization of operations and ultra fast write throughput

[14:26] *** Sgeo joined
[14:26] <jast> I like thinking about weird stuff like this :)\

[14:26] <El_Che> well, if ram behaviour is known before hand, there is no problem. Lost of people wouldn't mind adding ram for lots of speed

[14:27] <El_Che> however, web scalable == expenisve

[14:27] <jast> as keeping everything in RAM (even across many machines) gets too expensive, the application can transition towards having some of its data use more traditional access patterns where async fetches will be necessary

[14:28] <El_Che> you'll get blog post on how X moved from Ruby to Go/Rust/Whatever and now uses 50x less RAM :)

[14:28] <jast> which gives you the best of both worlds

[14:28] <jast> assuming I can make it work............

[14:28] <jast> small "if" :)

[14:28] <El_Che> so caching, essentially?

[14:28] <jast> that's more of an afterthought

[14:29] <jast> the cornerpoint of distributing the dataset is being confident that you know which node has primary authority over each bit of data

[14:29] <jast> getting that and having it be both fast and 100% robust is... non-trivial

[14:29] <El_Che> that's a hard problem

[14:29] <jast> so I think there'll be a way to specify that certain data can be eventually consistent using simple conflict resolution rules

[14:30] <jast> for instance, submitting a log entry to the wrong node by accident is healable, log entries (ideally) don't depend on each other so it can be inserted in the right place later on without violating the semantic integrity of the log

[14:31] <jast> (assuming that it's fine for log entries to show up slightly delayed)

[14:31] <El_Che> isn't that what mongodb is trying?

[14:31] <jast> have I mentioned that distributed computing is super fun, and impossibly difficult?

[14:32] <jast> but really the key of what I'm doing is to make it possible to control which guarantees you need for which of your application data, and have simple code initially which you can extend to deal with more difficult distribution requirements over time

[14:32] <jast> mongodb is more of a "this is what you get for all your data, take it or leave it" and personally I wouldn't trust it with anything important :)

[14:33] *** cacci left
[14:37] *** rypervenche joined
[14:37] *** cacci joined
[14:42] <El_Che> haha

[14:58] <[Coke]> We're using it for a large internal project, so far so good

[15:03] <exp> for what purpose [Coke]?

[15:03] <discord-raku-bot> <Anton Antonov> @Coke What? A you referring to: (1) a Raku package (e.g. "Humming-Bird"), (2) Raku in general, or (3) MongoDB?

[15:05] <exp> jast: i'm very sceptical about the proposition that "log entries ideally don't depend on each other"

[15:10] <jast> I mean obviously it depends on the exact thing you're using a log for

[15:11] <jast> but time series data often has a lot of data independence as long as there's an eventual clear ordering of events

[15:14] <jast> for instance, recording a series of measurements, if you send in a measurement out of order the other measurements don't suffer as a result, and if the measurement arrives in the correct spot before you actually do anything with the measurements, it doesn't matter

[15:15] <jast> going back to MongoDB, I suspect that in the presence of network congestion or partitions there can be stale reads. stale reads are really hard to prevent without significantly affecting read throughput

[15:20] <[Coke]> 1/2/3 - 3. MongoDB. I use Raku for lots of automation, tooling, but it's not part of our main app

[15:20] <tonyo> .

[15:20] <tonyo> .

[15:21] <discord-raku-bot> <Anton Antonov> @Coke -- good to know.

[15:24] <discord-raku-bot> <Anton Antonov> There are at least a dozen of Raku packages for doing Artificial Intelligence (AI) and Machine Learning (ML). I consider making some likely and unlikely combinations of them. What would be a good namespace for those? Here are few names I consider: "AI::Fusion", "ACME::AI::Blending" , "ACME::AI::MushUp" .

[15:25] <perryprog> ... there's ML stuff for Raku? That is a surprise.

[15:25] <discord-raku-bot> <Anton Antonov> I think "AI::Fusion" might be misleading -- seen as referring to a concrete AI contraption.

[15:26] <discord-raku-bot> <Anton Antonov> @perryprog Are you joking, provocative, or you really do not know? 🙂

[15:26] <dakkar> (very tangential: it's usually "mash up", not much "must up"; also traditionally it's spelled `Acme` not `ACME`; then again, it's just names)

[15:26] <perryprog> I really didn't know!

[15:26] <dakkar> (and of course I typo that… ☹)

[15:26] <discord-raku-bot> <Anton Antonov> @perryprog Here is reference: https://raku.land/?q=ML .

[15:27] <perryprog> But I'm also still in the mindset of assuming no-one uses Raku in production for some reason.

[15:28] <perryprog> ... hopefully that makes sense and isn't as cynical as I think it is

[15:28] <discord-raku-bot> <Nemokosch> yeah, go figure lol

[15:28] <discord-raku-bot> <Anton Antonov> @perryprog Yeah, I use DSLs like https://raku.land/zef:antononcube/DSL::English::DataQueryWorkflows to help production. But that is not directly in production...

[15:28] <perryprog> That counts!

[15:29] <perryprog> I would count "in production" as "used on a preferably non-solo team for non-personal reasons". I think that definition works.

[15:30] <El_Che> perryprog: you underestimate the non-solo team in big places

[15:30] <discord-raku-bot> <Anton Antonov> I am currently trying to convince a certain company to use Raku in production. (Again, for natural DSL-related projects.)

[15:31] <perryprog> I said "non-solo" team because it'd be easy to have a personal workflow that consists of raku scripts being part of a runbook for example (which is basically personal), where Raku was chosen due to you being the sole member, and not the product of a group decision on how to architect some system.

[15:32] <discord-raku-bot> <Anton Antonov> @El_Che ... and  non-multi cohorts in small places...

[15:32] <perryprog> Since the idea behind "in production" is really that "people agree that this thing is good to use in a professional environment, with dynamic groups of people working on the project the thing is being used for"

[15:33] <discord-raku-bot> <Anton Antonov> I am solo Raku programmer in that company, but I there are at least a few consumers of the Raku-mande functionalities (via Cro and Docker.)

[15:33] *** buffet left
[15:34] <discord-raku-bot> <Nemokosch> this definition also rules out a lot of consulting, pretty much

[15:35] <discord-raku-bot> <Anton Antonov> My motivation for implementing Raku ML packages initially was mostly to support my DSLs.

[15:35] *** buffet joined
[15:36] <rf> In production means its accessible to stake-holders and customers imo

[15:36] <discord-raku-bot> <Anton Antonov> * ... "Raku-made" above, not "Raku-mande"...

[15:36] <perryprog> As an example, I'm reminded of the classic Hacker Scripts. I wouldn't count whatever language these were written in to be used "in production", in most contexts. https://github.com/NARKOZ/hacker-scripts#readme

[15:37] <perryprog> Nemokosch, disagree speaking from personal experience.

[15:37] <perryprog> (albeit limited)

[15:37] <rf> If when you use my product, Raku code is even touched, it's in production.

[15:37] <perryprog> also we should get raku added to that repo

[15:38] <perryprog> rf, but what about Raku used in build automation? (CI/CD)

[15:38] <discord-raku-bot> <Anton Antonov> @rf Then this is Raku-product then : https://antononcube.shinyapps.io/DSL-evaluations/ .

[15:39] <rf> perryprog: Sure, CI/CD is part of a production pipeline therfor it is part of production

[15:39] <perryprog> But that's not always accessible to stake-holders and customers, right?

[15:39] <rf> The stake-holders are the developers

[15:39] <perryprog> Oh

[15:39] <rf> the customers are the developers, anaylysts, etc

[15:39] <perryprog> neeeeeeeevermind

[15:40] <discord-raku-bot> <Anton Antonov> @rf Is this a Raku-production: https://pypi.org/project/DSLTranslation/ ?  (For access of a Raku Cro service within Python sessions.)

[15:40] <rf> Probably?

[15:42] <discord-raku-bot> <Anton Antonov> @rf For me to claim "production level" effort means extensive documentation. (Also, often related demo-movies.)

[15:42] *** mtj joined
[15:43] <discord-raku-bot> <Nemokosch> I don't know. It seems a bit bizarre to say it's not production if, for example, others don't have to know that the tool you created for a particular problem, is written in Raku

[15:43] <discord-raku-bot> <Nemokosch> It would make more sense for the outcome to matter.

[15:45] <rf> Anton: Documentation has nothing to do with something being used in production. Look at most internal libraries, they're typically not documented at all but still used extensively

[15:46] <rf> If you want people to adopt your library documentation is important, but it is not determanistic of how the software is used

[15:46] <discord-raku-bot> <Anton Antonov> To a large extend, my efforts to make Raku "work" with/within Jupyter, Markdown, and Mathematica are for production purposes. My target users are data analysts and data scientists. Hence, transparency of the algorithms and easy to understand usage documentation are essential.

[15:47] <rf> Yeah that makes sense, you're targeting your audience

[15:48] <discord-raku-bot> <Anton Antonov> @rf "If you want people to adopt your library documentation is important, but it is not determanistic of how the software is used" -- unfortunately that is not true for code generating DSL packages. People are really not paying attention to the results, they just get stuck "why is this working" / "why are showing me this" .

[15:49] <[Coke]> another ping: any raku folks attending TPRC in Toronto?

[15:50] <Voldenet> I've worked with tons of production-ready software that was massively underdocumented

[15:50] <Voldenet> apparently business needs features, not docs. eh

[15:51] <rf> Typically haha

[15:51] <discord-raku-bot> <Nemokosch> Anyway, the social aspect is very important, and one part of it is to set the right expectations, rather than falling into the nirvana trap

[15:51] <discord-raku-bot> <Anton Antonov> @Coke FWIW I considered the idea to go TPRC this year, and decided not to go. For logistics / time related reasons...

[15:51] <perryprog> Voldenet but it's self documenting!! :P

[15:52] <Voldenet> perryprog: well yes, I can read that disassembly just fine, it's _relatively_ self-documenting :>

[15:53] <discord-raku-bot> <Nemokosch> we don't know if Raku will ever be rationally (whatever we mean by that) chosen over XYZ super duper popular general purpose language

[15:53] <discord-raku-bot> <Nemokosch> but I'd say that goes for most languages, and there are many popular languages that don't have a "killer feature", or perhaps never even had one

[15:53] *** derpydoo joined
[15:54] <Voldenet> Raku was chosen over XYZ many times by now

[15:55] <Voldenet> by me at least

[15:55] <Voldenet> You can't exclude people from your statement, otherwise you'd end up with a tautology :)

[15:55] <discord-raku-bot> <Anton Antonov> @perryprog "but it's self documenting" -- I know where these kind statements make discussion go. Here is A relevant summary with ML-context flavor: https://cdn.discordapp.com/attachments/768511641758466088/1037069857256128632/unknown.png

[15:55] <discord-raku-bot> <Nemokosch> same - whether that was a "rational" choice, is another story 🙂

[15:56] <perryprog> ... lol

[15:56] <perryprog> not totally fair, but still funny

[15:56] <rf> Do I need performance? C++. Do I need to formally verify? OCaml. Else, Raku.

[15:58] <discord-raku-bot> <Anton Antonov> @rf "Do I need to formally verify? OCaml." -- Another non-Mathematica user. (Thinking of non-opinionated-ness.)

[15:58] <rf> Coq and OCaml > Mathematica

[15:59] <discord-raku-bot> <Nemokosch> from what I can recall, Mathematica was very much "pay to win" software 😆

[15:59] <rf> Yeah, you pay someone else to do it for you

[15:59] <rf> Because its not a very good language :^)

[16:00] <discord-raku-bot> <Anton Antonov> @rf "Coq and OCaml > Mathematica" -- Maybe true in some specific, idiosyncratic universe (populated mostly with hummingbirds.)

[16:00] <rf> Hahahah

[16:00] <Voldenet> I like TLA+ more than coq

[16:02] <Voldenet> maybe because I use it for distributed concurrency

[16:03] <discord-raku-bot> <Anton Antonov> @perryprog -- thanks!

[16:12] <[Coke]> .ask tbrowder - why is https://github.com/tbrowder/Windows-Test/blob/master/META6.json.pdf ??

[16:12] <tellable6> [Coke], I'll pass your message to tbrowder__

[16:13] <[Coke]> (it looks like it's a META6.json for PDF, not a pdf of the json file)

[16:23] <perryprog> rf, what about Julia? :>

[16:24] <rf> It's a fine language, just not my cup of tea

[16:27] <discord-raku-bot> <Anton Antonov> @perryprog Julia is little bit like Obama -- it got an award for just showing up.

[16:27] <perryprog> I don't follow.

[16:27] <perryprog> But personally I'm quite a fan of Julia, I've used it pretty often for a few years now.

[16:28] <perryprog> Cliche but I suspect it will be a fairly Big Deal™ in a few years in a lot of environments

[16:28] <discord-raku-bot> <Anton Antonov> Since Julia is a Lisp-based -- and so are R and Mathematica -- I do not see Julia worth learning. (If I am not payed to use it.)

[16:30] <rf> I think one benefit of Julia over R is it's very fast but idk if that's important in data land

[16:30] <discord-raku-bot> <Nemokosch> isn't the "killer feature" of Julia being fast?

[16:31] <perryprog> It's one of them.

[16:31] <perryprog> rf, it very much is

[16:31] <discord-raku-bot> <Anton Antonov> @perryprog  "I don't follow." -- see https://en.wikipedia.org/wiki/J._H._Wilkinson_Prize_for_Numerical_Software . The way I see it, Julia got an award for releasing version 1.0. Nothing about Julia is that new or outperforming existing systems. (Mathematica, R, Python, etc...)

[16:31] <perryprog> (Though I'm an outsider to data land, so take that with a grain of salt)

[16:31] <perryprog> Oh, that's not at all true IMO Anton

[16:32] <discord-raku-bot> <Anton Antonov> Of course speed is important in the data land.

[16:32] *** derpydoo left
[16:32] <discord-raku-bot> <Anton Antonov> It has to be balanced -- again, of course -- with easy-ness of computation specifications.

[16:32] *** cacci left
[16:33] <discord-raku-bot> <Anton Antonov> R is way too arcane in that regard. (Because it was made statisticians.) But the ecosystem of packages by RStudio makes R much more useful.

[16:34] <Voldenet> Julia is nice, because you can even replace core types

[16:35] <perryprog> There's a lot of excellent stuff Julia does in a way that makes it uniquely well suited for a lot of tasks. It has a quite good dynamic type system, it has multiple dispatch (which is super, super, super awesome), great C and python interop (among other things), amazing support for distributed computing, as well as threading and coroutines, extremely good handling of typecasting between different number types...

[16:35] <Voldenet> the worst part is that "you can replcae core types"

[16:35] <perryprog> lol

[16:36] <Voldenet> now, imagine amount of combinations you can produce with it

[16:36] <Voldenet> and debugging all of it

[16:36] <rf> I wonder how outlandish it would be to run Raku on Beam

[16:36] <perryprog> multiple dispatch also lends itself extremely well to interop between different packages. There's a Measurements package which provides a generic Measurement which wraps a numerical value, letting you say 1.0 ± 0.1.

[16:36] <discord-raku-bot> <Anton Antonov> @perryprog In the Rraku DSL Data Wrangling package I mentioned above I show code generation for Julia. In those experiments -- 1-2 years ago -- Julia was always slower than R and Python. (But I was comparing only CSV file ingestion and a particular paradigm of data transformations. See Julia's "DataFrames".)

[16:37] <Voldenet> basically this: https://yuri.is/not-julia/

[16:37] <Voldenet> apparently julialang is too flexible at some points

[16:38] <tbrowder__> [Coke]: thats correct, i should mv it to a dev subdir

[16:38] <perryprog> It then automatically propagates that error according to normal rules, so ((1.0 ± 0.1) * 2)^2 = 4.0 ± 0.8. The way it's implemented also takes advantage of automatic differentiation of functions which basically means any package instantly supports this propagation. (Except for some things that only work with strict Float64 :P)

[16:38] <tellable6> 2023-03-20T16:12:28Z #raku <[Coke]> tbrowder - why is https://github.com/tbrowder/Windows-Test/blob/master/META6.json.pdf ??

[16:39] <perryprog> Anton, are you including the JIT compilation cost? While it's fair to sometimes include it in some benchmarks, it's worth noting there's now ways to minimize it.

[16:39] <Voldenet> in fact for large things non-flexible languages are better

[16:39] <discord-raku-bot> <Anton Antonov> @perryprog  Below WL == Mathematica 1. "It has a quite good dynamic type system" -- so does WL.  2. "it has multiple dispatch (which is super, super, super awesome),"  -- so does WL 3. "great C and python interop (among other things)" - so does WL 4.  "amazing support for distributed computing" -- so does WL 5. "as well as threading and coroutines" -- cannot comment now... 6. "extremely good handling of typecasting between different

[16:39] <discord-raku-bot> number types..." -- so does WL

[16:40] <perryprog> Voldenet, while Yuri has some good points in that now-infamous article, there have since been like eight hundred responses to that essay on why some stuff they say isn't totally fair.

[16:40] <discord-raku-bot> <Nemokosch> Voldenet: enter Go xD

[16:40] <perryprog> Anton, WL is icky!!

[16:40] <perryprog> checkmate freedom hater

[16:40] <discord-raku-bot> <Anton Antonov> Now, these "responses" of mine are just to support my claim that Julia does not bring something particularly new.

[16:40] <perryprog> Totally fair

[16:41] <discord-raku-bot> <Anton Antonov> @perryprog Your attitude is something Stephen Wolfram does not understand.

[16:41] <perryprog> lol

[16:41] <discord-raku-bot> <Nemokosch> Stephen 'Sigma' Wolfram

[16:42] <discord-raku-bot> <Anton Antonov> Julia is not different -- it really feels "same family" language if you know LISP, Mathematica, (or R).

[16:42] <perryprog> Don't get me wrong, WL is genuinely incredible, but I don't think it's ethical to rely on closed source algorithms or implementations in academic research. You're locking your methodology behind a paywall.

[16:42] <Voldenet> Nemokosch: well yes, golang is awfully simple and non-abstract, it's nice for doing things

[16:42] <tellable6> Voldenet, I'll pass your message to Nemokosch

[16:42] <[Coke]> tbrowder__: my recommendation would be to rename it to meta6-pdf.json - the last extension should be the type.

[16:43] <Voldenet> but at some point you start hating how non-generic and inelegant it is, it feels too simple

[16:43] <discord-raku-bot> <Anton Antonov> @perryprog Simply not true. Wolfram Engine is free for developers -- you get it using an email.

[16:43] <discord-raku-bot> <Nemokosch> it's almost like you are biased towards the Wolfram system, Anton

[16:43] <discord-raku-bot> <Nemokosch> :DD

[16:43] <perryprog> The algorithms are still closed source and proprietary!

[16:43] <discord-raku-bot> <Anton Antonov> WL has first class documentation -- I do not know any other system for mathematical computations with better documentation.

[16:44] <perryprog> Oh that's 100% true

[16:44] <perryprog> It's absurdly good

[16:44] <perryprog> Like, it's unfair how good it is

[16:44] <rf> https://octave.org/

[16:44] <discord-raku-bot> <Nemokosch> by the way, I only read like the first two paragraphs of that "why I can't recommend Julia anymore" and like... do y'all not realize that it could be literally written about Raku?

[16:45] <rf> It could also be written about 95% of languages

[16:45] <discord-raku-bot> <Nemokosch> too many tricky interactions, impossible to prove anything on the most superficial level

[16:45] <perryprog> Anton, perhaps I should've been clearer: I view the closed source implementation bit as a much bigger detail than WL being paywalled (in some cases, in some cases like you said it's free).

[16:45] <discord-raku-bot> <Nemokosch> from the OCaml nihilist's perspective, maybe

[16:46] <discord-raku-bot> <Anton Antonov> @perryprog "The algorithms are still closed source and proprietary!" -- 1) So?  2) Not entirely true, many of the complicated algorithms have published WL-written prototypes. 3) Especially, for ML algorithms -- they are verifiable (in a variety of ways.)

[16:46] <discord-raku-bot> <Nemokosch> but this is something Raku does particularly bad at, thanks to the Perl heritage

[16:46] <rf> I can use dependent typing

[16:46] <perryprog> "To reproduce our results just run this black box that we created with these inputs"

[16:46] <rf> It is semi-provable

[16:47] <discord-raku-bot> <Nemokosch> the control flow is crazy though

[16:47] <discord-raku-bot> <Nemokosch> (and the type system is stuck in the "weird flex" position - that I really wouldn't call "production ready" at all)

[16:48] <perryprog> I just don't think it's in the spirit of academic research to have the algorithms (among other details) that some research was done using to be just as open as the results of the research.

[16:48] <discord-raku-bot> <Anton Antonov> @perryprog I am somewhat biased toward WL (as @Nemokosch was readily kind enough to mention above.)

[16:48] <perryprog> That's totally fine, no worries

[16:49] <perryprog> It'd be like omitting the "Procedure" section saying "To reproduce the results, hire one of of our lab employees who will perform the test in our lab with no witnesses and will send you the results"

[16:49] <perryprog> (And these analogies aren't totally fair, I'm just using them to illustrate where I'm coming from—they aren't meant to be the basis of my points.)

[16:50] <discord-raku-bot> <Anton Antonov> @perryprog I am / was a Mathematica power user. So, the WL-community is somewhat surprised I am spending so much time with Raku. (BTW, that includes Stephen.)

[16:50] <perryprog> Lol

[16:50] <perryprog> Stephen is a very interesting guy.

[16:51] <perryprog> His personality is... something.

[16:51] <discord-raku-bot> <Anton Antonov> Absolutely! Some of the most insightful comments about computing I have heard from him.

[16:52] <perryprog> Heh. I meant that in the slightly negative connotation.

[16:52] <perryprog> I don't agree with a lot of his views.

[16:52] <discord-raku-bot> <Anton Antonov> It is just academia for reason decided to "hate" Stephen. (And understand why, but I also understand why he finds that surprising.)

[16:53] <perryprog> I mean, the reason he finds that surprising is part of the reason for that hate, I think.

[16:53] <rf> The only person I know who uses WL besides anton is Xah Lee, and he is pretty crazy

[16:53] <tonyo> stephen diehl ?

[16:54] <perryprog> Stephen Wolfram

[16:54] <discord-raku-bot> <Anton Antonov> @perryprog I know. 🙂 That is why I produce and compare same computational workflows in different systems. Mathematica often wins, and in many cases is just decisively  better.

[16:54] <perryprog> But he's very, very, very self-centered on his work. This isn't necessarily a bad thing but it makes a lot of his discussions end up going from a normal topic (like PL theory) to "oh here's how WL does that" and then a giant tangent about WL and how great it is.

[16:55] <perryprog> I really just can't get by the fact that it's closed source. To me that's a fundamental reason to never use it for anything that's not intended only for yourself.

[16:55] <discord-raku-bot> <Anton Antonov> @rf You realize, I might mention idiosyncratic, hummingbird universes, again, right!

[16:56] <perryprog> oh goodness

[16:57] <discord-raku-bot> <Anton Antonov> @perryprog "But he's very, very, very self-centered on his work." -- One of my friends summarized Mathematica as "made for brilliant physicists."

[16:57] <perryprog> s/brilliant physicists/SW

[16:57] <discord-raku-bot> <Anton Antonov> Fine -- I am just saying there are other people thinking in those lines.

[16:57] <discord-raku-bot> <Nemokosch> so Mr Wolfram is a physicist I guess? xD

[16:58] <perryprog> You aren't good at Mathematica. You're good at temporary emulating a fraction of Stephen Wolfram's mindset. —Joseph-Louis Lagrange

[16:58] <perryprog> Oh I'm just being facetious, sorry

[16:58] <discord-raku-bot> <Nemokosch> Lagrange xdd

[16:59] <perryprog> Also, correct me if I'm wrong, but isn't Mathematica only fast for... /some/ things, but way slower for any task that isn't just normal numerical analysis? Like, isn't it slow in the areas outside of the parts that have fine-tuned optimized compiled implementations?

[16:59] <discord-raku-bot> <Anton Antonov> I need to go to a meeting -- I will tell more about Julia's mandelbrot-ness later.

[16:59] <discord-raku-bot> <Nemokosch> The French are historically outstanding at claiming people who would have never been French in a less imperialistic world

[17:01] <perryprog> Anton hasn't responded, therefore I wasn't wrong, and therefore WL is slow.

[17:01] <perryprog> I win.

[17:03] <perryprog> Also very relevant: https://blog.wolfram.com/2019/04/02/why-wolfram-tech-isnt-open-source-a-dozen-reasons/

[17:03] <discord-raku-bot> <Anton Antonov> @perryprog "[...] normal numerical analysis" -- symbolic mathematics of WL is fast.

[17:03] <perryprog> Oh, that too yeah

[17:03] <perryprog> I mean stuff outside of like. Math stuff.

[17:04] <discord-raku-bot> <Anton Antonov> Like what? 🙂

[17:04] <perryprog> Not-math stuff.

[17:04] * perryprog hides

[17:05] <discord-raku-bot> <Anton Antonov> It is complicated to answer this -- of course there are some "preferred" areas.

[17:06] <discord-raku-bot> <Anton Antonov> @perryfrog "Not-math stuff." -- For example, let us take image processing. Is this math stuff or not?

[17:07] <discord-raku-bot> <Anton Antonov> I would say Mathematica's image processing is great -- again I do not know any other system that it is better.

[17:08] <tonyo> perryprog: what in the actual crap is this list

[17:08] <discord-raku-bot> <Anton Antonov> @tonyo Hahaha

[17:09] <tonyo> everyone knows FOSS repos have no direction or hierarchies, it's just absolute chaos on the git hub!!!!

[17:10] <tonyo> meanwhile i'm rewriting a bunch of stuff i lost in fez because the vm corrupted itself

[17:20] <rf> I love FOSS anarchy

[17:29] <discord-raku-bot> <Anton Antonov> @rf Yes, lots of fuss-ing humbugs.

[17:33] <tbrowder__> yeah, sounds good

[17:33] <discord-raku-bot> <Anton Antonov> @trbrowder__ Interesting "Date::*"  mnodules.

[17:39] *** dakkar left
[17:50] <rf> Hmm, I don't think I necessarily understand the whole "Unwinds the whole stack" thing when it comes to the LEAVE phaser

[17:52] <rf> I thought unwinding the stack was mostly a thing with exceptions

[17:55] *** ab5tract joined
[18:00] <discord-raku-bot> <Nemokosch> well, exceptions are caught by another phaser

[18:00] <discord-raku-bot> <Nemokosch> I guess the principles are shared

[18:00] *** reportable6 left
[18:00] <rf> I guess it is possible to have memory problems if LEAVE is called after the call-stack pops the block

[18:00] <rf> Maybe that's why

[18:01] *** reportable6 joined
[18:01] <discord-raku-bot> <Nemokosch> the latest Template6 version just doesn't want to show up on raku.land

[18:02] <discord-raku-bot> <Nemokosch> even though it is installable

[18:03] <rf> raku.land has a update timer iirc

[18:03] <rf> Just give it a few minutes

[18:03] <discord-raku-bot> <Nemokosch> the thing is, I uploaded 3 hours ago 😅

[18:03] <rf> oof

[18:03] <discord-raku-bot> <Nemokosch> and the site is built "3 mins ago"

[18:06] <tonyo> m: try { CATCH { default { $_.&dd; } }; my $p = Proc::Async.new('curl5', '--version'); await $p.start; };

[18:06] <camelia> rakudo-moar 58157b8d3: OUTPUT: «X::OS+{X::Await::Died}.new(await-backtrace => Backtrace.new, os-error => "Failed to spawn process curl5: no such file or directory (error code -2)")␤»

[18:08] <tonyo> i think this documentation may be wrong, https://docs.raku.org/type/Proc::Async#method_start

[18:10] <rf> m: try { CATCH { default { $_.&dd; } }; my $p = Proc::Async.new('curl5', '--version'); try sink await $p.start; };

[18:10] <camelia> rakudo-moar 58157b8d3: ( no output )

[18:11] <rf> m: try { CATCH { default { $_.&dd; } }; my $p = Proc::Async.new('echo', 'foo'); $p.start.tap({ .say }); };

[18:11] <camelia> rakudo-moar 58157b8d3: OUTPUT: «foo␤X::Method::NotFound.new(invocant => Promise.new(scheduler => ThreadPoolScheduler.new(uncaught_handler => Callable), status => PromiseStatus::Kept), method => "tap", typename => "Promise", private => Bool::False, addendum => Any, in-class-call =>…»

[18:11] <tonyo> locally i get Unhandled exception in code scheduled on thread 4

[18:11] <tonyo> Failed to spawn process curl: no such file or directory (error code -2)

[18:11] <tonyo> and i have curl in my path

[18:12] <tonyo> m: try { CATCH { default { $_.&dd; } }; my $p = Proc::Async.new('curl5', '--version'); sink await $p.start; };

[18:12] <camelia> rakudo-moar 58157b8d3: OUTPUT: «X::OS+{X::Await::Died}.new(await-backtrace => Backtrace.new, os-error => "Failed to spawn process curl5: no such file or directory (error code -2)")␤»

[18:12] <tonyo> m: try { CATCH { default { $_.&dd; $_.resume; die 'dead' } }; my $p = Proc::Async.new('curl5', '--version'); sink await $p.start; };

[18:12] <camelia> rakudo-moar 58157b8d3: OUTPUT: «X::OS+{X::Await::Died}.new(await-backtrace => Backtrace.new, os-error => "Failed to spawn process curl5: no such file or directory (error code -2)")␤Too late to resume this exception␤  in block  at <tmp> line 1␤  in any  at <tmp> line 1␤  in b…»

[18:12] <rf> m: my $p = shell 'echo foo'; $p.say;

[18:12] <camelia> rakudo-moar 58157b8d3: OUTPUT: «foo␤Proc.new(in => IO::Pipe, out => IO::Pipe, err => IO::Pipe, exitcode => 0, signal => 0, pid => 12763, command => ("echo foo",))␤»

[18:13] <perryprog> tonyo, that list is one of the reasons I don't like WL for ideological reasons. It's closed source because they want $$.

[18:13] <rf> Why the try catch?

[18:13] <rf> At the start

[18:13] <perryprog> The second reason being I don't think implementation details in academic research should be closed source.

[18:14] <tonyo> perryprog: that list is a thinly veiled attempt at guarding revenue under the guise of "it's for your benefit" 

[18:14] <perryprog> Aye.

[18:16] <tonyo> academia has mostly skated the implications of covid..if their intentions were really altruistic then the videos, lectures, etc would be made available to anyone interested since covid kind of forced them to figure out how to digitalize their content.  seems like the wrong kind of non-news

[18:17] <tonyo> rf: makes little difference, i still get the code 4

[18:17] <perryprog> Anton, image processing is mathy stuff. I'm thinking of things that Mathematica isn't really designed for. It's not a very good point ("Programming language X is bad at the things X wasn't designed for!")—I'm thinking about things like what you'd more often see in commercial environments like high scale web apps/APIs, or high performance tools that aren't pure number crunching. (Say, parsing)

[18:18] <perryprog> Oh, like Wolfram Alpha. Wolfram Alpha is as slow as poop.

[18:23] <tonyo> rf: i'm trying to make that Proc::Async statement _not_ die whether the command exists or not

[18:24] <tonyo> right now, no matter what i seem to do it responds with Unhandled exception in code scheduled on thread 4

[18:24] *** jpn left
[18:28] *** jpn joined
[18:47] <rf> you need to use try sink

[18:47] <rf> I think

[18:47] <rf> m: try { CATCH { default { $_.&dd; } }; my $p = Proc::Async.new('curl5', '--version'); try sink await $p.start; };

[18:47] <camelia> rakudo-moar 58157b8d3: ( no output )

[18:50] *** teatwo joined
[18:50] *** tea3po left
[18:50] *** teatwo left
[18:51] *** teatwo joined
[18:53] *** tea3po joined
[18:56] *** teatwo left
[18:57] <ugexe> could probably do like whenever .start(|%_)   { .so ?? Promise.new.keep($_) !! Promise.new.break($_) }

[19:00] *** jpn left
[19:01] *** ProperNoun left
[19:05] *** jpn joined
[19:11] *** jpn left
[19:14] *** teatwo joined
[19:17] *** tea3po left
[19:18] <discord-raku-bot> <Anton Antonov> @tonyo Wolfram Research made available for everyone all of the COVID materials, data, simulations, discussions procured and curated by them. (And now @perryprog is going to say "because they $$.")

[19:19] <perryprog> because they $$

[19:19] <perryprog> oops just finished reading your message

[19:19] *** abraxxa left
[19:19] <perryprog> google, how do I delete my message in IRC

[19:19] <discord-raku-bot> <Anton Antonov> 🙂 Aha, as expected. And on cue.

[19:19] <discord-raku-bot> <Anton Antonov> You should ChatGPT

[19:19] <perryprog> Jokes aside, Wolfram Research does a lot of great stuff.

[19:19] <discord-raku-bot> <Anton Antonov> You can use "WWW::OpenAI"

[19:20] <perryprog> And to be clear, WL is incredible.

[19:21] <perryprog> It's just a combination of dislike for Stephen Wolfram, the business practices of WR, and primarily the closed sourceness that makes me adverse to WL's use.

[19:23] <discord-raku-bot> <Anton Antonov> Here :

[19:23] <discord-raku-bot> <Anton Antonov> https://cdn.discordapp.com/attachments/633753286209699870/1087456356249899148/OpenAI-IRC-message-deletion.png

[19:24] <perryprog> Awesome so glad ChatGPT added that feature to IRC for me

[19:25] <discord-raku-bot> <Anton Antonov> @perryprog "[...] high performance tools that aren't pure number crunching. (Say, parsing)" -- I have made a fair amount of parsing in /with Mathematica before I moved to Raku.

[19:25] *** ab5tract left
[19:25] <perryprog> Oh neat! Okay so I'm probably just wrong regarding that point.

[19:26] <perryprog> Though WA is slow as poop. (And I say that as a paid subscriber for WA Pro.)

[19:26] <discord-raku-bot> <Anton Antonov> Actually, Mathematica can be just fine in that regard. It is LISP-descendant, so the usual LISP-paradigm methodologies apply.

[19:27] <discord-raku-bot> <Anton Antonov> Yeah, W|A is something I do not use often. (And I speak as former W|A developer...)

[19:28] <perryprog> Oh wow, you worked for WR?

[19:29] <discord-raku-bot> <Anton Antonov> Aha, 7-8 years.

[19:29] <perryprog> That's pretty neat.

[19:30] <discord-raku-bot> <Anton Antonov> @perryprog You can read here some of my thought on the LISP-Mathematica-Raku connection: https://mathematica.stackexchange.com/a/246565/34008 .

[19:30] <perryprog> btw can you hook me up with free mathematical license? Thanks in advance

[19:32] <perryprog> Looking at your bio... I think I've directly used both NIntegrate and the chemical equation balancer thingy. That's kinda wild.

[19:33] <discord-raku-bot> <Anton Antonov> @perryprog "btw can you hook me up with free mathematical license? Thanks in advance" -- 🙂 See here: https://www.wolfram.com/developer/

[19:33] <perryprog> That doesn't give access to Mathematica! :P

[19:33] <discord-raku-bot> <Anton Antonov> As for NIntegerate --

[19:34] <perryprog> oh. My school gives free access to Mathematica. Hahahaha

[19:34] <discord-raku-bot> <Anton Antonov> @perryprog "That doesn't give access to Mathematica!" -- Yeah, you have hook it up to Jupyter.

[19:34] <discord-raku-bot> <Anton Antonov> And/or Visual Studio Code.

[19:35] <discord-raku-bot> <Anton Antonov> @perryprog Most of the chemical balancer  is available in Raku: https://raku.land/zef:antononcube/Chemistry::Stoichiometry

[19:36] <perryprog> Oh that's very cool. I naïvely assumed former employees couldn't do... that, on account of the history WR has with NDAs and research.

[19:37] <perryprog> (aka, CA/ANKoS drama)

[19:37] <discord-raku-bot> <Anton Antonov> No, the NDA is not that restrictive. It is in my TODO list to implement NIntegrate in Raku: https://github.com/antononcube/Raku-Math-NIntegrate .

[19:38] <perryprog> And great Stack Exchange post btw

[19:39] <discord-raku-bot> <Anton Antonov> @perryprog Thanks! And, yeah, Stephen Wolfram have made fair amount of academia enemies over the years.

[19:39] <perryprog> That's putting it lightly

[19:40] <perryprog> Also not exactly well known for his... workspace environment but that's only heresy so it's less fair to him to argue using that.

[19:48] <lizmat> moritz: is there a semantic difference between rx:s/ \d+ / and rx:s/ \d + / ?

[19:49] *** jpn joined
[20:10] *** vrurg_ joined
[20:13] *** vrurg__ joined
[20:13] *** vrurg left
[20:16] *** vrurg_ left
[20:52] *** jpn left
[21:13] <moritz> lizmat: uhm, that's the kind of rule I don't remember particularly well

[21:13] <moritz> I have a raku v2022.02 lying around here whose `--target=ast` claim they differ

[21:14] <moritz> seems that it parses \d + as [\d<ws>]+

[21:22] *** jpn joined
[21:28] *** jpn left
[21:30] *** squashable6 left
[21:31] *** squashable6 joined
[21:39] *** zebzzw left
[21:41] *** jpn joined
[21:48] *** sena_kun joined
[22:07] *** jpn left
[22:26] <guifa_> that's correct

[22:26] <guifa_> That little things get me all the time when I use rules lol

[23:03] <tonyo> try sink await exits badly locally..wondering if it's a single cpu/thread vm i'm running in

[23:07] *** evalable6 left
[23:07] *** linkable6 left
[23:09] *** evalable6 joined
[23:10] *** linkable6 joined
[23:11] <lizmat> moritz: yeah, working on regexes and RakuAST atm.  That's how it parses, but does it have a different semantic?  I don't think so?

[23:15] <guifa_> Yeah semantics should be different.  Imagine…

[23:16] <guifa_> rx:s/ <word> + /   # <-- inserts spaces between each word

[23:17] <guifa_> rx:s/ $<word>=[<alpha>+] + / # <-- no spaces between alpha, but yes spaces between words

[23:23] <lizmat> m: say "ab   cd" ~~ rx:s/ [<alpha>+]+ /

[23:23] <camelia> rakudo-moar 58157b8d3: OUTPUT: «｢ab   ｣␤ alpha => ｢a｣␤ alpha => ｢b｣␤»

[23:23] <lizmat> m: say "ab   cd" ~~ rx:s/ [<alpha>+] + /

[23:23] <camelia> rakudo-moar 58157b8d3: OUTPUT: «｢ab   cd｣␤ alpha => ｢a｣␤ alpha => ｢b｣␤ alpha => ｢c｣␤ alpha => ｢d｣␤»

[23:23] <lizmat> ok, gotcha  :-)

[23:24] <tonyo> m: my $proc = Proc.new(:command('curl5', '-v'), :out, :err); dd $proc.err.slurp

[23:24] <camelia> rakudo-moar 58157b8d3: OUTPUT: «No such method 'Channel' for invocant of type 'Any'␤  in block <unit> at <tmp> line 1␤␤»

[23:29] <tonyo> something is very wrong locally

