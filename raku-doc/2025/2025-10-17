[00:14] *** ds7832 left
[00:52] *** arkiuat left
[01:04] *** arkiuat joined
[07:35] *** Geth joined
[08:37] *** arkiuat left
[08:48] *** arkiuat joined
[08:53] *** arkiuat left
[09:22] *** arkiuat joined
[09:27] *** arkiuat left
[09:57] *** arkiuat joined
[10:02] *** arkiuat left
[10:29] *** arkiuat joined
[10:34] *** arkiuat left
[10:35] *** ds7832 joined
[11:01] *** arkiuat joined
[11:06] *** arkiuat left
[11:31] *** arkiuat joined
[11:36] *** arkiuat left
[11:40] *** ds7832 left
[11:40] *** ds7832 joined
[12:03] *** arkiuat joined
[12:08] *** arkiuat left
[12:32] *** arkiuat joined
[12:36] *** arkiuat left
[13:06] *** arkiuat joined
[13:11] *** arkiuat left
[13:26] <ds7832> I feel like in the section https://docs.raku.org/language/signatures#Constraining_signatures_of_Callables, the last example should be replaced by something simpler, but I don't yet know what

[13:29] <ds7832> Also, it looks to me like the sentence above is wrong, because lambda syntax works perfectly fine even with the $ sigil. One only needs to have actually matching signatures, i.e. add the "--> Str" (just like in the example above, "--> Int:D" was necessary):

[13:29] <ds7832> [10] > sub play-with-tens($c where .signature ~~ :(Int, Str --> Str)) { say $c(10, 'ten') }

[13:29] <ds7832> &play-with-tens

[13:29] <ds7832> [11] > play-with-tens -> Int \i, Str \s --> Str { s x (1..10).roll mod i };ten

[13:29] <ds7832> tententententen

[13:33] *** arkiuat joined
[13:36] <ds7832> Or slight correction of my point: The fourth line in the last example of https://docs.raku.org/language/signatures#Constraining_signatures_of_Callables already shows that lambda syntax works even with $-sigiled parameters, not just with &. 

[13:37] <ds7832> My examples with added "--> Str" just demonstrate that also output constraints work just as they do with &-sigiled variables.

[13:38] *** arkiuat left
[13:38] <ds7832> The third line, with "play-with-tens &by-joining-them", can likewise be rewritten in lambda-form as "play-with-tens -> Int \i, Str \s { s ~ i }"

[13:39] <ds7832> And the very last line only fails because the signature uses Num instead of Int, which would fail just as much with an &-sigiled parameter

[13:48] *** librasteve_ joined
[13:51] <ds7832> I get it now. Looks like nobody ever meant to say that. The sentence "note that this shorthand syntax..." was referring to the syntax of stating the required signature directly after the param in the signature, i.e. to the first examplc line "sub apply(&l:(Int:D --> Int:D), Int:D \n)". So what it says is that with $ instead of &, one has to use the "where" form instead. Later another example got added below, without adapting the text, 

[13:51] <ds7832> whence it currently reads strangely: https://github.com/cfa/raku-doc/commit/c286df1a68bcb1ba103f17130a31744035a16f4d

[14:08] *** arkiuat joined
[14:13] *** arkiuat left
[14:17] *** arkiuat joined
[14:22] *** arkiuat left
[14:36] *** arkiuat joined
[14:42] *** arkiuat left
[15:01] *** ds7823 joined
[15:10] *** arkiuat joined
[15:10] *** ds7832 left
[15:15] *** arkiuat left
[15:28] *** ds7832 joined
[15:31] *** arkiuat joined
[15:46] *** ds7832 left
[15:47] *** ds7823 left
[15:59] <[Coke]> again, a history of line edits, not always taking context into account.

[15:59] <[Coke]> good find

[19:00] <arkiuat>  PR 4668 is ready for review. I'm going to take a look at class Any now, with issue 4560 in mind

[19:05] <arkiuat> the first thing that jumps out at me is that junction-creators any, all, none, & one are listed as methods only but they can be called as subs also, so those should be converted to "routine" entries

[19:33] <arkiuat> in class Any, I'm noticing several instances where something is said to return a Seq or List; in reference to https://github.com/Raku/problem-solving/issues/499 should I go ahead and change these to specify returning Iterable as I go? Or should we keep separate issues in separate PRs?

[19:38] <arkiuat> another question: in Mu, the few routines that listed both the sub and the method form listed the sub first and then the method. In Any, the first of these that I found listed the method first and sub second. See routine gist and routine map for examples 

[19:38] <arkiuat> Do we want a uniform ordering here? and if so, which one

[19:39] <arkiuat> I think listing the method first looks more natural, because extra whitespace is provided between "multi" and "sub" so that the routine name will line up with itself

[19:40] <arkiuat> in which case I'll want to add one more commit to PR 4668

[19:41] <arkiuat> well, the "sub" isn't explicitly there

[19:46] <arkiuat> I went ahead and added that third commit to PR 4668, and will list method before sub until I hear reason to do otherwise

[19:59] <arkiuat> sub item is documented in class Any, but method item is documented in Mu.  Should I move the doc for sub item into a merged 'routine item' in Mu, or is there some reason for things to be the way they are?

[20:02] <arkiuat> (now I wish I hadn't removed PR 4668's draft status, because I don't know how to put it back)

[21:57] *** ds7832 joined
[21:59] *** ds7832 left
[22:04] *** ds7832 joined
[22:06] *** ds7832 left
[22:10] *** ds7832 joined
[22:12] *** ds7832 left
[22:26] <[Coke]> I can do it

[22:26] <[Coke]> done

[22:26] <[Coke]> it's under reviewers, I think.

[22:27] <[Coke]> Just let me know when it's ready to check. (will probably do so tomorrow)

[22:27] <[Coke]> (post release)

[22:53] *** ds7832 joined
[23:32] *** ds7832 left
