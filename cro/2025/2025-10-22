[07:38] <disbot1> <m_zero> I'm wondering what is the plan for prefix // and prefix ||?   Prefix // seems useful: It tests for "definedness". It isn't implemented in the current release... but src/Raku/ast implements it and can parse it.  On the other hand, prefix || seems not  useful: it always just returns its argument unchanged (as far as I can tell or infer). It is implemented in the current release... but src/Raku/ast doesn't support it at all.

[07:50] *** lizmat left
[08:11] <SmokeMachine> Isn‚Äôt it for being able to align the || on every line, as it can be done on regex?

[11:06] *** patrickb left
[11:14] <disbot1> <jubilatious1_98524> @m_zero  On another note, I'm not sure I understand the need for prefix // when we can metaop just about anything:

[11:15] <disbot1> <jubilatious1_98524> m: my @a = 1..3; my @b = (); say [&&] @a,@b;

[11:15] <disbot1> <Raku eval>  [] 

[11:15] <disbot1> <jubilatious1_98524> m: my @a = 1..3; my @b = (); say [&&] @b,@a;

[11:15] <disbot1> <Raku eval>  [] 

[11:15] <disbot1> <jubilatious1_98524> m: my @a = 1..3; my @b = (); say [||] @a,@b;

[11:15] <disbot1> <Raku eval>  [1 2 3] 

[11:16] <disbot1> <jubilatious1_98524> m: my @a = 1..3; my @b = (); say [||] @b,@a;

[11:16] <disbot1> <Raku eval>  [1 2 3] 

[11:16] <disbot1> <jubilatious1_98524> m: my @a = 1..3; my @b = (); say [//] @a,@b;

[11:16] <disbot1> <Raku eval>  [1 2 3] 

[11:17] <disbot1> <jubilatious1_98524> m: my @a = 1..3; my @b = (); say [//] @b,@a;

[11:17] <disbot1> <Raku eval>  [] 

[11:37] *** librasteve_ left
[11:48] <disbot1> <m_zero> @jubilatious1_98524 I think the use case is in checking if a scanner has been defined.

[11:48] *** lizmat joined
[11:49] <disbot1> <m_zero> m: use v6.*; my $a; say //$a;

[11:49] <disbot1> <Raku eval>  False 

[11:56] *** lizmat left
[12:19] *** patrickb joined
[12:27] *** lizmat joined
[12:28] *** lizmat left
[12:45] *** rba left
[13:00] *** rba joined
[13:14] *** lizmat joined
[13:16] *** lizmat left
[13:16] *** lizmat_ joined
[13:19] *** lizmat_ left
[13:32] *** librasteve_ joined
[14:14] <disbot1> <.landyacht.> Does it have the same precedence as defined? If it were a bit tighter that would be nice, specifically tighter than ?? so ternaries based on definedness are easier

[14:19] <disbot1> <librasteve> it has symbolic unary precedence

[14:20] <disbot1> <librasteve> ! + - ~ ? | || +^ ~^ ?^ ^ // <== same as these guys - which I think is what you want

[14:22] <disbot1> <librasteve> m: my $x = 1; say //$x ?? 'yo' !! 'no';

[14:22] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Null regex not allowed.  Please use .comb if you wanted to produce a sequence of characters from a string. at /home/glot/main.raku:1 ------> my $x = 1; say //‚èè$x ?? 'yo' !! 'no'; 

[14:22] <disbot1> <librasteve> hmm sadly not

[14:22] <disbot1> <librasteve> oh its 6.e

[14:23] <disbot1> <librasteve> m: use 6.e.*; my $x = 1; say //$x ?? 'yo' !! 'no';

[14:23] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Malformed postfix call at /home/glot/main.raku:1 ------> use 6.e.*‚èè; my $x = 1; say //$x ?? 'yo' !! 'no'; 

[14:24] <disbot1> <librasteve> m: m: use v6.*; my $x = 1; say //$x ?? 'yo' !! 'no';

[14:24] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Too late to switch language version. Must be used as the very first statement. at /home/glot/main.raku:1 ------> m: use v6.*‚èè; my $x = 1; say //$x ?? 'yo' !! 'no'; 

[14:24] <disbot1> <librasteve> huh

[14:25] <disbot1> <librasteve> anyway when I use v6 on my local box still get the same Null regex error

[14:25] <disbot1> <.landyacht.> She‚Äôs putting up a fight üòÜ

[14:26] <disbot1> <.landyacht.> I wonder if something about the surrounding context confuses the parser

[14:26] <disbot1> <librasteve> yeah - maybe

[14:26] <disbot1> <librasteve> guess I would defer to one of the grown ups on this...

[16:08] <disbot1> <jubilatious1_98524> m: use v6.*; my $x = 1; say //$x ?? 'yo' !! 'no';

[16:08] <disbot1> <Raku eval>  yo 

[16:09] <disbot1> <jubilatious1_98524> m: use v6.*; my $x = 1; say $x ?? 'yo' !! 'no';

[16:09] <disbot1> <Raku eval>  yo 

[16:17] <disbot1> <jubilatious1_98524> m: use v6.*; my $x = Nil; say //$x ?? 'yo' !! 'no';

[16:17] <disbot1> <Raku eval>  no 

[16:18] <disbot1> <jubilatious1_98524> m: use v6.*; my $x = Nil; say $x ?? 'yo' !! 'no';

[16:18] <disbot1> <Raku eval>  no 

[16:21] <[Coke]> v6.* is only needed for experimental preview.

[16:21] <[Coke]> (per the docs)

[16:22] <[Coke]> m: my $x = Nil; say //$x ?? 'yo' !! 'no'; # try without...

[16:22] <[Coke]> ah. ok, tried that locally and in #raku, without the v6.c it dies.

[16:23] <[Coke]> er, v6.*

[16:25] <[Coke]> ... what are you trying to do with //$x ?

[16:25] <[Coke]> I've only see // as an infix.

[16:25] <[Coke]> like 'my $x; say $x // "default value"'

[16:26] <[Coke]> ah. https://docs.raku.org/language/operators#prefix_//

[16:26] <[Coke]> ... available only in 6.e, so that tracks.

[16:28] <[Coke]> ok, I was only paying attention from the code samples, what's the actual issue, sorry?

[18:59] <disbot1> <jubilatious1_98524> m: my $a = Nil; say !!$a;

[18:59] <disbot1> <Raku eval>  False 

[19:00] <disbot1> <jubilatious1_98524> m: use v6.e; my $a = Nil; say //$a;

[19:00] <disbot1> <Raku eval>  Exit code: 1 ===SORRY!=== Error while compiling /home/glot/main.raku Raku v6.e requires PREVIEW modifier at /home/glot/main.raku:1 ------> use v6.e‚èè; my $a = Nil; say //$a; 

[19:02] <disbot1> <jubilatious1_98524> m: use v6.e.* my $a = Nil; say //$a;

[19:02] <disbot1> <Raku eval>  False 

[19:03] <disbot1> <jubilatious1_98524> m: use v6.e.* my $a = Nil; say !!$a;

[19:03] <disbot1> <Raku eval>  False 

[19:06] <disbot1> <jubilatious1_98524> I'm not seeing a difference between the new //boolean coercer, and the classic !! "bang-bang"  (or not-not) double boolean method.

[19:09] <disbot1> <jubilatious1_98524> m: use v6.e.* my $a = 1; say !!$a;

[19:09] <disbot1> <Raku eval>  True 

[19:09] <disbot1> <jubilatious1_98524> m: use v6.e.* my $a = 0; say !!$a;

[19:09] <disbot1> <Raku eval>  False 

[19:19] <librasteve_> [Coke] earlier today we had these three examples of prefix `//`

[19:20] <librasteve_> m: use v6.*; dd //Nil

[19:20] <librasteve_> #True

[19:20] <librasteve_> m: use v6.*; dd //1

[19:20] <librasteve_> #True

[19:20] <librasteve_> m: use v6.*; dd //0

[19:20] <librasteve_> #True

[19:21] <librasteve_> arggh - the first one is False of course

[19:21] <librasteve_> then the idea arose to use `//` as a modifier on the test in a ternary like

[19:22] <librasteve_> m: my $x = Nil; say //$x ?? 'yo' !! 'no';

[19:22] <librasteve_> as you saw above this errors, shame

[19:23] <librasteve_> the question is, is the compiler too eager to pick `//` up and error as an empty regex in this case

[19:23] <librasteve_> [btw Camelia is dead for me]

[19:29] <[Coke]> You need to have v6.e.PREVIEW enabled, I think

[19:29] <[Coke]> which v6.* does

[19:30] <[Coke]> camelia doesn't work in here, but does in #raku

[19:31] <[Coke]> yah, just tested that line with v6.* in #raku, it works.

[19:32] <[Coke]> so if you want the experimental stuff, you'll need to scope it for the entire file (script or module)

[19:37] <disbot1> <librasteve> tx!

[21:56] <disbot1> <m_zero> @librasteve - surely there is a difference between Nil and the state of being undefined.  Hence, it makes sense to me that //Nil should indeed return True

[21:58] <disbot1> <m_zero> @jubilatious1_98524 - // is a test for definedness, not "truthiness"

[21:59] <disbot1> <m_zero> m: use v6.*; my $n = Nil; dd //$n; dd !!$n;

[21:59] <disbot1> <Raku eval>  Bool::False Bool::False 

[21:59] <disbot1> <m_zero> Gah! does Nil mean the same as undefined? Surely that isn't so....

[22:01] <disbot1> <m_zero> Nevermind - it indeed does let you undefine a variable.    Okay then....

[22:25] <disbot1> <librasteve> m: use v6.*; my $n; dd //$n;

[22:25] <disbot1> <Raku eval>  Bool::False 

[22:25] <disbot1> <librasteve> yeah assign Nil just resets a var to its default, in this case (Any)

[22:44] <[Coke]> you can see the difference with a typed var declaration.

[22:47] <disbot1> <cokebot9000> m: my Int $a = 3; $a=Nil; dd $a

[22:47] <disbot1> <Raku eval>  Int $a = Int 

[22:47] <SmokeMachine> Boolean coerced? Shouldn‚Äôt it be ? Or so?

[22:48] <SmokeMachine> m: say ?42

[22:48] <[Coke]> ? is boolean, // is "defined", I think

[22:49] <disbot1> <cokebot9000> m: use v6.*; dd ?False; dd //False;

[22:49] <disbot1> <Raku eval>  Bool::False Bool::True 

[22:49] <disbot1> <cokebot9000> ^^

[23:41] *** lizmat joined
[23:44] *** lizmat left
