[00:00] <lue> I can't say I understand that "useless use" warning :)

[00:04] *** kurahaupo left
[00:05] <Mouq> TimToady: Very ooc, how would you feel about method lol taking an argument that specifies the size of the lists it is the list of

[00:05] <Mouq> ?

[00:06] <TimToady> that sounds like a different thing to me

[00:06] <Mouq> e.g. (^10).lol(2) eqv lol($(0,1),$(2,3),$(4,5),$(6,7),$(8,9))

[00:07] <lue> Mouq: sounds like a case for .map , or maybe even .tree?

[00:07] <TimToady> 'druther name it something else

[00:07] <lue> r: say (^10).map({($^a, $^b)}).perl

[00:07] <camelia> rakudo-{parrot,jvm,moar} 22ca11: OUTPUT«((0, 1), (2, 3), (4, 5), (6, 7), (8, 9)).list␤»

[00:07] <Mouq> lue: But that map example isn't really extensible

[00:07] <TimToady> well, a more interesting case is overlapping

[00:08] <TimToady> (1,2),(2,3),(3,4)...

[00:08] <lue> .partition($size, $stride) ?

[00:08] <Mouq> TimToady: (^10 »xx» 2)[1.*-1]

[00:09] <lue> (^10).partition(2, 1) -> ((0,1),(1,2),(2,3),...)

[00:09] * Mouq doesn't see an easy way to grab by X out of a list

[00:09] <Mouq> partition would be nice

[00:09] <Mouq> I'd be so Cool with that

[00:10] <lue> I wonder what would happen when $stride > $size (probably just skip the values, so you could get every other elem with @list.partition(1,2))

[00:10] * TimToady keeps wanting a way to say "bind the rest of this signature but don't eat args permanently", kinda like )>

[00:14] <TimToady> the name "partition" doesn't do it for me

[00:16] <lue> TimToady: yeah, me neither. It was merely the first thing that came to mind for "separate this list into a bunch of lists... like HDD partitions... partition!"

[00:16] <TimToady> except those are all exclusive

[00:16] <lue> (that's the condensed version of the logic, anyway)

[00:16] <TimToady> the whole idea of a partition is you put things on one side or the other, not both

[00:17] <TimToady> it's more like .rotor

[00:17] <lue> true. (Note that I came up with the name before you mentioned the overlapping case :P)

[00:17] <TimToady> or the underapping case you came up with :P

[00:17] <TimToady> *underlapping

[00:21] <lue> Another possibility for the args is .rotor($stride, *@sizes), (for varied (cycling) sizes), .rotor($size, *@strides), or... maybe that **@arg thing would come in handy here, or perhaps I'm overthinking the function's utility :)

[00:22] <TimToady> not general enough

[00:22] <TimToady> .rotor( $take1, $skip1, $take2, $skip2, $take3, $skip3... )

[00:22] <TimToady> where skip can be negative

[00:22] <TimToady> so overlap is .rotor(2,-1)

[00:24] <TimToady> or maybe interleave relative strides

[00:24] <TimToady> that would work better for taking a fibonacci slice, for instance

[00:24] <lue> I'm almost tempted to say a Hash[Int,Int] to enforce evenness in the arg count :)

[00:25] <lue> (except that wouldn't work at all; Array[Pair[Int,Int]] then)

[00:25] <TimToady> another common pattern would be triangular arrays

[00:27] <lue> actually, I should think .rotor(2) would be equal to .rotor(2,0) in your give/take case of args

[00:27] <Mouq> TimToady: Mayhaps $take and $skip could be optional Callables? Esp. WhateverCodes

[00:29] <Mouq> Where the argument(s) to the Callable, if it requires any, are either the index or the last X sizes

[00:29] <TimToady> about to reinvent the sequence operator here, I suppose

[00:29] <Mouq> TimToady: YEah

[00:30] <Mouq> *Yeah

[00:30] <Mouq> But it's still cleaner-looking to me than:

[00:31] <Mouq> m: my @a = ^10; .say for {$(@a.shift xx ++state$)}...{@a}

[00:31] <camelia> rakudo-moar 22ca11: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ky4ojTqGh_␤Unsupported use of $) variable; in Perl 6 please use $*EGID␤at /tmp/ky4ojTqGh_:1␤------> [32m= ^10; .say for {$(@a.shift xx ++state$)[33m⏏[31m}...{@a}[0m␤»

[00:31] <Mouq> m: my @a = ^10; .say for {$(@a.shift xx ++state$ )}...{@a}

[00:31] <camelia> rakudo-moar 22ca11: OUTPUT«0␤»

[00:31] <Mouq> Hm..

[00:31] <Mouq> m: my @a = ^10; .say for {$(@a.shift xx ++state$ )}...{!@a}

[00:31] <camelia> rakudo-moar 22ca11: OUTPUT«0␤1 2␤3 4 5␤6 7 8 9␤===SORRY!===␤Element shifted from empty list␤»

[00:31] <Mouq> m: my @a = ^10; .say for {$(@a.shift xx ++state$ )}...{not @a-1}

[00:31] <camelia> rakudo-moar 22ca11: OUTPUT«0␤1 2␤3 4 5␤6 7 8 9␤===SORRY!===␤Element shifted from empty list␤»

[00:31] <Mouq> m: my @a = ^10; .say for {$(@a.shift xx ++state$ )}...^{not @a-1}

[00:31] <camelia> rakudo-moar 22ca11: OUTPUT«0␤1 2␤3 4 5␤6 7 8 9␤===SORRY!===␤Element shifted from empty list␤»

[00:32] <lue> I think .rotor($take, $skip, $take, $skip) is good enough for .rotor

[00:32] <Mouq> Oh, my list is too small :P

[00:33] <Mouq> m: my @a = ^10; .say for {$(@a[^4 »+» 4*++state$] )}...{@a}

[00:33] <camelia> rakudo-moar 22ca11: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/8WFriRN_X2␤Unsupported use of $] variable; in Perl 6 please use $*PERL_VERSION␤at /tmp/8WFriRN_X2:1␤------> [32m= ^10; .say for {$(@a[^4 »+» 4*++state$][33m⏏[31m )}...{@a}[0m␤»

[00:33] <Mouq> m: my @a = ^10; .say for {$(@a[^4 »+» 4*++state$ ] )}...{@a}

[00:33] <camelia> rakudo-moar 22ca11: OUTPUT«4 5 6 7␤»

[00:34] <Mouq> Anyway...

[00:34] <Mouq> It's harder than it should be is my point

[00:34] <Mouq> m: my @a = ^10; .say for $(@a[^4 »+» 4*(state$)++ ]) xx @a/4

[00:34] <camelia> rakudo-moar 22ca11: OUTPUT«0 1 2 3␤4 5 6 7␤»

[00:35] <Mouq> m: my @a = ^100; .say for $(@a[^4 »+» 4*(state$)++ ]) xx @a/4

[00:35] <camelia> rakudo-moar 22ca11: OUTPUT«0 1 2 3␤4 5 6 7␤8 9 10 11␤12 13 14 15␤16 17 18 19␤20 21 22 23␤24 25 26 27␤28 29 30 31␤32 33 34 35␤36 37 38 39␤40 41 42 43␤44 45 46 47␤48 49 50 51␤52 53 54 55␤56 57 58 59␤60 61 62 63␤64 65 66 67␤68 69 70 71␤72 73 74 75␤…»

[00:35] <Mouq> m: my @a = ^100; .say for $(@a[^4 »+» 4*(state$)++ ]) xx @a/4+4

[00:35] <camelia> rakudo-moar 22ca11: OUTPUT«0 1 2 3␤4 5 6 7␤8 9 10 11␤12 13 14 15␤16 17 18 19␤20 21 22 23␤24 25 26 27␤28 29 30 31␤32 33 34 35␤36 37 38 39␤40 41 42 43␤44 45 46 47␤48 49 50 51␤52 53 54 55␤56 57 58 59␤60 61 62 63␤64 65 66 67␤68 69 70 71␤72 73 74 75␤…»

[00:37] <TimToady> std: sub foo(@a[4]) { [@a] }; .say for map &foo, ^8

[00:37] <camelia> std e347792: OUTPUT«ok 00:01 139m␤»

[00:37] * Mouq may have fixed the heredoc issue, btw ^_^

[00:38] <Mouq> TimToady: :L

[00:39] <TimToady> smoking isn't good for you

[00:39] <Mouq> p6: sub foo(@a[4]) { [@a] }; .say for map &foo, ^8

[00:39] <camelia> rakudo-jvm 22ca11: OUTPUT«Nominal type check failed for parameter '@a'␤  in sub foo at /tmp/tmpfile:1␤  in method reify at gen/jvm/CORE.setting:7627␤  in method reify at gen/jvm/CORE.setting:7490␤  in method reify at gen/jvm/CORE.setting:7490␤  in method reify at gen/jvm/C…»

[00:39] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«Unhandled exception: Nominal type check failed in binding '@a' in 'foo'; got Int, needed Positional␤  at /tmp/tmpfile line 0 (foo @ 1) ␤  at <unknown> line 0 (KERNEL map @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2634 (GatherIterator.r…»

[00:39] <camelia> ..rakudo-moar 22ca11: OUTPUT«cannot stringify this␤  in sub foo at /tmp/tmpfile:1␤  in method reify at src/gen/m-CORE.setting:7686␤  in method reify at src/gen/m-CORE.setting:7549␤  in method reify at src/gen/m-CORE.setting:7549␤  in method reify at src/gen/m-CORE.setting:76…»

[00:39] <TimToady> or is that a toothpick?

[00:39] <camelia> ..rakudo-parrot 22ca11: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Int instead␤  in sub foo at /tmp/tmpfile:1␤  in method reify at gen/parrot/CORE.setting:7607␤  in method reify at gen/parrot/CORE.setting:7498␤  in method reify at gen/parr…»

[00:40] <TimToady> yes, well, you'd probably want better syntax for binding N args, since this is really gonna want to bind a single array with 4 elems

[00:41] <TimToady> and I'm guess .rotor or some such will end up a lot cleaner looking than trying to shoehorn extra semantics into binding

[00:42] <TimToady> not to mention being more parameterizable

[00:42] <TimToady> .oO(more argumentative?)

[00:43] <lue> Wouldn't that be arguable?

[00:44] <lue> (or alternatively parameterized)

[00:44] <dalek> rakudo/nom: e210385 | Mouq++ | src/Perl6/Grammar.nqp:

[00:44] <dalek> rakudo/nom: Adding `token starter` to q and qq messed up heredoc parsing

[00:44] <dalek> rakudo/nom: 

[00:44] <dalek> rakudo/nom: So we basically just delete them when it's actually a heredoc.

[00:44] <dalek> rakudo/nom: integration/advent2012-day10.t no longer hangs, and passes with flying

[00:44] <dalek> rakudo/nom: colors

[00:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e210385f97

[00:44] <dalek> rakudo/nom: b55db03 | Mouq++ | / (3 files):

[00:44] <dalek> rakudo/nom: Merge branch 'nom' of https://github.com/rakudo/rakudo into nom

[00:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b55db03530

[00:45] <dalek> rakudo/nom: ae2bc53 | Mouq++ | t/spectest.data:

[00:45] <dalek> rakudo/nom: Revert "Skip integration/advent2012-day(6|10).t for now"

[00:45] <dalek> rakudo/nom: 

[00:45] <dalek> rakudo/nom: This reverts commit 4a1e6a78adb179a33616601f415734dcf45c3a88.

[00:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ae2bc53760

[00:46] <Mouq> lizmat++

[00:47] <Mouq> dwarring++ again for great tests :)

[00:48] <Mouq> std: q:to/END/␤I'm not broken, am I?␤END

[00:48] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤(Possible runaway string from line 2)␤Couldn't find delimiter for heredoc␤ at /tmp/me9BV5lgu7 line 3 (EOF):␤------> [32mEND[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 121m␤»

[00:48] <Mouq> std: q:to/END/␤I am broken, am I?␤END

[00:48] <camelia> std e347792: OUTPUT«ok 00:01 121m␤»

[00:48] <Mouq> :|

[00:50] <dalek> std: ec3d853 | Mouq++ | STD.pm6:

[00:50] <dalek> std: Fix heredocs that contain a quote's standard starter

[00:50] <dalek> std: review: https://github.com/perl6/std/commit/ec3d8533ca

[00:53] *** hoverboard joined
[00:58] <Mouq> m: say "🚬".ord.succ.chr # Not smoking is clearly superiour to smoking, btw

[00:58] <camelia> rakudo-moar 22ca11: OUTPUT«🚭␤»

[01:03] <Mouq> m: say qq["\\c[NO SMOKING $_]" cmp "\\c[SMOKING $_]"].EVAL for Buf.new(+«comb /../,838977667976).decode

[01:03] <camelia> rakudo-moar 22ca11: OUTPUT«More␤»

[01:06] *** klapperl_ joined
[01:16] <TimToady> I think I'd like to see macros at a higher level than AST, more like at the CST level

[01:16] <TimToady> that is, at a more "documentary" level

[01:17] <TimToady> with delayed evaluation of action routines

[01:17] *** dmol joined
[01:18] <TimToady> with control of exactly when the action routines are called on bits of the syntax tree

[01:19] <TimToady> at the moment we tightly couple the syntax tree with the action routines, and that seems like a bit of a mistake sometimes

[01:20] <TimToady> maybe we could have a mode where we annotate the concrete syntax tree with the action routines we *think* we would call, but they're overrideable/wrappable

[01:22] *** dmol left
[01:22] <TimToady> we also might be able to start sneaking in a fully bootstrapped Perl 6 parser at this point too

[01:24] <Mouq> (lue++'s blog post brought up standardization of parts of the grammar; my two cents are that some parts of it should be standardized where people are going to be interfacing with the grammar, but as little as possible)

[01:24] <Mouq> o/ #perl6

[01:24] *** Mouq left
[01:27] <TimToady> I think the categories are pretty standardized by now, so recognizing that something is "infix" or "term" is gonna be a non-problem from the standpoint of language change

[01:28] *** FROGGS_ joined
[01:29] <lue> Yeah, the tricky thing is the part after the colon :)

[01:29] <TimToady> :sym< MyOp > is pretty straightforward

[01:31] <lue> I suppose the problem of "niecza's name for the rule is different from rakudo's!" seems larger than it is.

[01:31] <TimToady> well, there are various reasons we've been trying to converge on STD :)

[01:31] <lue> :)

[01:33] <TimToady> not that STD is really the end goal anymore, but it stands in for a "perfect" Perl 6 parser that, say, has a lot of the hash entries turned into object attributes of some sort, assuming we can sort out the classes/roles for that

[01:34] *** sftp joined
[01:34] <TimToady> maybe it's about time to write that new STD

[01:34] <lue> The part about not having the AST and action methods so coupled is I think an important thing to keep in mind.

[01:34] <TimToady> the CST you mean :)

[01:35] <TimToady> we use "AST" in way too overloaded a fashion

[01:35] <TimToady> I cringed at masak++'s 2nd step of AST -> AST

[01:35] <TimToady> to me those should be considered two different types :)

[01:35] <lue> Ah, so it should be ① Text -> CST, ② CST -> AST, ③ AST -> BC then?

[01:36] <TimToady> and if we made as many passes on it as C# does, we'd run out of letters for the xASTs

[01:37] <lue> Could $/ be considered a CST?

[01:38] <TimToady> that's the general idea, yes

[01:39] <TimToady> that doesn't mean we have to separate the parse pass from the CST -> AST pass all the time, only that it be possible to detangle them at need

[01:41] <TimToady> so the immediate calling of the Action routine corresponding to a Match is just a degenerate case of something that walks any Match tree and makes sure all the Action routines are called

[01:42] <lue> It does feel like we could accomplish a higher-level AST traversal if it were rather a CST traversal...

[01:43] <TimToady> well, being called to dinner, so I'd better stop ignoring it... :)

[01:43] <lue> later TimToady o/

[01:45] *** kurahaupo joined
[01:48] <colomon> darn, missed TimToady++

[01:48] * colomon didn't have anything to say to him, mind you.

[01:59] *** kurahaupo left
[02:00] * lue afk

[02:02] *** hoverboard left
[02:03] *** Sqirrel joined
[02:03] <TimToady> colomon: that doesn't stop most of us from saying things :)

[02:04] <colomon> :)

[02:04] <colomon> Though now that I think on it, Happy Easter!

[02:04] <TimToady> likewise

[02:05] <TimToady> since you'll get there first, tell me how it was :)

[02:05] <TimToady> well, likely I won't be paying much attention tomorrow morning though...

[02:31] *** xragnar_ joined
[02:31] *** xragnar_ is now known as xragnar

[02:36] <colomon> TimToady: I'll probably be too busy playing in the church orchestra to report before it reaches you.  ;)

[02:55] *** cognominal left
[02:55] *** cognominal joined
[02:58] <TimToady> a violin solo for me :)

[02:58] <TimToady> not to mention the drums

[03:13] *** sftp left
[03:14] *** sftp joined
[03:17] *** adu joined
[03:19] <lue> TimToady: thinking about how macros and slangs and such could function, what do you think of this?    https://gist.github.com/lue/95084d5800a6d5328115

[03:22] <lue> (treating macros as a way to walk a CST in that case)

[03:22] <lue> ... now I know what the slang keyword should do.

[03:23] <TimToady> naming a parameter $/ is insufficient to indicate its type, in my estimation

[03:24] <lue> Updated the gist to show my crazy idea for the slang keyword

[03:25] * TimToady is a bit distracted at the moment, sorry...

[03:25] <lue> that's fine

[03:25] <adu> what does this mean "use of uninitialized value of type Any in string context"?

[03:26] <lue> You used an uninitialized object of type Any in a stringy fashion :)

[03:26] <adu> lol

[03:27] <lue> If you're using moar, you're not getting as much info as you could (can't recall if JVM gives you a backtrace, but I know for sure Parrot does)

[03:27] <geekosaur> it's an untyped undefined value, and you're trying to use it as a string. perl 5 lets that kind of thing go (with a warning if you've got that turned on as you always should); perl 6 is more pedantic about it

[03:29] <adu> lue: I don't know what the output is on JVM and Parrot

[03:30] <lue> adu: I was just suggesting that if you don't know where the problem lies already, then Parrot (and perhaps JVM) would give you a backtrace.

[03:31] <lue> (r-m needs some help in the Telling You Where The Problem Is department)

[03:31] <adu> I ran my test on MoarVM and it only took 45s, but I ran it on Parrot and JVM, and I stopped it after 2 minutes

[03:32] <adu> maybe I should just start it now, then check when I wake up

[03:32] *** raiph joined
[03:32] <lue> If you're about to go to bed, it shouldn't hurt to do that :)

[03:33] <adu> the test is throwing my C11 parser at parsing "int main() {return 0;}"

[03:36] *** adu left
[03:38] <lue> .oO(maybe instead of "slang rule", it would be "srule", and then "slang" would be kept around as the way to specify things for $~ vars... 'my sregex' à la 'my regex' ?)

[04:12] *** BenGoldberg left
[04:29] <lue> .tell masak this might interest you: https://gist.github.com/lue/95084d5800a6d5328115

[04:29] <yoleaux> lue: I'll pass your message to masak.

[04:36] *** Psyche^ joined
[05:03] *** raiph left
[05:21] *** xenoterracide joined
[05:43] *** xenoterracide left
[05:49] *** logie_ left
[05:50] *** avuserow joined
[05:51] *** grep0r joined
[05:51] *** zby_home joined
[05:52] *** zby_home left
[05:57] <FROGGS_> TimToady: about `"bind the rest of this signature but don't eat args permanently", kinda like )>`

[05:58] <FROGGS_> TimToady: would a combination with Whatever work? like a <* and *> in a signature?

[06:02] *** gaussblurinc_ joined
[06:06] <moritz> \o

[06:06] <FROGGS_> morning

[06:17] *** rindolf joined
[06:25] *** SamuraiJack_ joined
[06:30] *** bjz joined
[06:40] *** darutoko joined
[06:57] *** raiph joined
[07:09] *** raiph left
[07:15] *** raiph joined
[07:30] <lizmat> good *, #perl6!

[07:40] *** vendethiel left
[07:46] <moritz> \o FROGGS_, lizmat 

[07:46] <moritz> the R* DBIish/t/05-mock.t failure is a precompilation bug

[07:46] <moritz> deleting the .jar files makes it pass

[07:52] <FROGGS_> moritz: were you able to golf it down to something?

[07:53] <moritz> FROGGS_: I haven't tried yet

[07:54] <moritz> FROGGS_: are there known precompilation bugs on the JVM?

[07:55] <FROGGS_> moritz: no, the ones I know about were fixed

[07:55] <FROGGS_> but we could query RT for these bugs and look for similarities

[07:59] <moritz> RT #121319 is the only known precomp issue that a naive search found

[07:59] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=121319

[07:59] *** pippo_ joined
[08:00] <moritz> which looks like it doesn't fit the problem at all

[08:13] *** gaussblurinc_ left
[08:19] *** pippo_ left
[08:20] *** molaf joined
[08:23] <FROGGS_> moritz: I bet it is the gather/take

[08:34] * moritz tries to get rid of the gather/take

[08:36] <masak> good antenoon, #Perl6

[08:36] <yoleaux> 04:29Z <lue> masak: this might interest you: https://gist.github.com/lue/95084d5800a6d5328115

[08:36] <moritz> http://perlpunks.de/paste/show/535386f0.739.216 # does this look reasonable?

[08:37] <masak> today's autopun spotting: https://twitter.com/mikeisbrill/status/457508879778451458

[08:38] <masak> moritz: looks reasonable, but there is lots of repetition between those two methods.

[08:38] <masak> did you consider a helper sub to lift out the control flow?

[08:44] *** denis_boyun_ joined
[08:45] <FROGGS_> moritz: at least it solves the precomp bug

[08:45] <FROGGS_> m: my $i = 0; say do while $i++ < 10 { $i }

[08:45] <camelia> rakudo-moar ae2bc5: OUTPUT«False␤»

[08:47] <FROGGS_> m: my $i = 0; say do while $i++ < 10 { say $i; $i } # I thought while can produce values like that?

[08:47] <camelia> rakudo-moar ae2bc5: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤False␤»

[08:49] <FROGGS_> m: say do for ^10 -> $x { $x } # works for for but not for while :/

[08:49] <camelia> rakudo-moar ae2bc5: OUTPUT«0 1 2 3 4 5 6 7 8 9␤»

[08:49] <FROGGS_> if it would work for while it would happily replace the gather/take

[08:50] <masak> if you ask me, it's a singularly bad idea to have loops collect/evaluate to lists of values.

[08:51] <masak> it's a Nice Thing for a small number of use cases, but it slurps memory and perf for everyone.

[08:52] <FROGGS_> hmmm, I was thinking that at least in the current implementation gather/take is way more heavy than a nice while loop

[08:52] <FROGGS_> and I can't imagine that a while loop is very expensive

[08:52] *** Rotwang joined
[08:52] <FROGGS_> masak: especially when one wraps the while in gather/take like in the previous code of http://perlpunks.de/paste/show/535386f0.739.216

[08:54] <FROGGS_> masak: and a for loop is just a map, and you would not argue that LIST.map --> LIST is a bad idea I guess?

[08:55] <FROGGS_> I'd like to here something jnthn about the performance of the current implementation though

[08:56] <lizmat> is there a reason we don't have a Benchmark module / sub yet ?

[08:56] <lizmat> *why

[08:57] <FROGGS_> there is p6bench what timotimo uses... do you mean that or a built-in?

[08:58] <lizmat> builtin, really

[08:58] <FROGGS_> how would you imagine this would be used?

[08:58] <masak> FROGGS_: I've never fully subscribed to the notion of "a for loop is just a map". because to me, it isn't.

[08:59] <FROGGS_> masak: then we are back to QAST :o)

[08:59] <masak> FROGGS_: in fact, if you try to be consistent in that way, then you have to make up a story for while loops too, or they would be awfully special.

[09:00] <lizmat> FROGGS_: https://metacpan.org/pod/Benchmark

[09:00] <FROGGS_> for LIST { ... } is identical to LIST.map({...}) and in fact both produce identical QAST

[09:01] <dalek> rakudo/nom: b1ace93 | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[09:01] <dalek> rakudo/nom: Fix Supply::on for @supply case

[09:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b1ace935ab

[09:02] *** pippo_ joined
[09:02] <FROGGS_> masak: well, we do not have the "map method form" of while, because for loops of a range/list of a certain size, which can happily be a thing (a range or array or list)

[09:02] *** SamuraiJack_ left
[09:02] <FROGGS_> masak: a while/until loops as long as a condition holds... how do you make a thing out of that soyou can call methods on it?

[09:03] <FROGGS_> s^/a\s//

[09:03] <FROGGS_> damn,  "loops" -> "loops loop"

[09:04] <masak> m: my $i1 = 0; while $i1++ < 5 { say $i1 }; my $i2 = 0; (0..*).map({ last if $i2++ < 5; say $i2 })

[09:04] <camelia> rakudo-moar ae2bc5: OUTPUT«1␤2␤3␤4␤5␤»

[09:04] <masak> er.

[09:04] <masak> m: my $i1 = 0; while $i1++ < 5 { say $i1 }; my $i2 = 0; (0..*).map({ last unless $i2++ < 5; say $i2 })

[09:04] <camelia> rakudo-moar ae2bc5: OUTPUT«1␤2␤3␤4␤5␤1␤2␤3␤4␤5␤»

[09:04] <avuserow> https://github.com/avuserow/perl6-audio-taglib-simple # I wrote some bindings for taglib to read ID3v2 tags and stuff

[09:05] <masak> seems to me all while loops are maps on 0..* in a sense. optionally with a 'last' thrown in for the condition.

[09:10] <FROGGS_> masak: I don't think that while loops have anything to do with 0..*

[09:11] <FROGGS_> it is just about exception handlers that trigger to run the block if the condition is still true

[09:11] <FROGGS_> so it is just check/run/check/run/...

[09:12] <FROGGS_> avuserow++ # very niec!

[09:13] <FROGGS_> nice*

[09:16] <FROGGS_> masak: btw, what I really like about loops generating value: you have the thing you assign to and the list/condition you looping over near to each other

[09:16] <FROGGS_> masak: and the perhaps bigger codeblocks follows

[09:17] <FROGGS_> map in perl 5 gets ugly when the code block is big

[09:17] <FROGGS_> because like in p5 regexes you have to look at the end to see what it is doing

[09:17] <masak> FROGGS_: I don't think that for loops have much to do with maps.

[09:18] <masak> FROGGS_: they may be as alike on the QAST level as they like; I use them for mostly different things.

[09:18] <masak> largely, I use for loops for mutation and side effects, and maps to transform lists to lists.

[09:18] <masak> if I need to do both at the same time, I consider that a code smell.

[09:19] <FROGGS_> ahh, now I see your point

[09:20] *** Rotwang left
[09:21] <FROGGS_> hmmm, but we hand over callable code turn run something later/elsewhere and call that higher order programming and we tend to like that

[09:21] <FROGGS_> I want to see control structures that produce values in the same way

[09:22] <masak> during Rakudo's lifetime, for loops producing values has produced about 10x more grief than happiness, in my estimation.

[09:23] <FROGGS_> I just know a fraction of that lifetime :o)

[09:27] <raiph> Is there a bot that says when new versions of Rakudo etc. are scheduled?

[09:27] <raiph> (I recall moritz creating one)

[09:27] <FROGGS_> raiph: have a look at the release guide

[09:27] <FROGGS_> but there is no bot AFAIK

[09:29] *** dmol joined
[09:32] *** Alina-malina joined
[09:34] <masak> interestingly, 'println!' is a macro in Rust. this allows the compiler to check the format string against the number and types of arguments at compile time. that feels oddly right somehow.

[09:35] <masak> (and it's a good example of a useful use of macros)

[09:36] <masak> let's try on a new slogan: "if you're not generating, analyzing or typechecking code, then macros are not what you want".

[09:36] <dalek> rakudo/nom: 33ea6e5 | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[09:36] <dalek> rakudo/nom: Implement index feature for @supply

[09:36] <dalek> rakudo/nom: 

[09:36] <dalek> rakudo/nom: This allows the more/done/quit to determine which supply they were called for.

[09:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/33ea6e5301

[09:41] *** hummeleB1 joined
[10:07] *** rindolf left
[10:13] *** raiph left
[10:21] *** kurahaupo joined
[10:26] *** kaare_ joined
[10:28] <jnthn> masak: Note that loops of any kind at statementlist level these days never produce values, even if as last statemnet of the block. Keep up!

[10:29] <lizmat> given a block, how can I find out the number of parameters it takes ?

[10:29] <lizmat> $b.signature.foo I guess, but what foo?

[10:29] <moritz> .arity/.count

[10:30] <masak> jnthn: :)

[10:30] <moritz> m: say -> $a, $b? { }.arity

[10:30] <camelia> rakudo-moar b1ace9: OUTPUT«1␤»

[10:30] <masak> jnthn: I know that.

[10:30] <moritz> m: say -> $a, $b? { }.count

[10:30] <camelia> rakudo-moar b1ace9: OUTPUT«2␤»

[10:30] <jnthn> masak: Ah, ok :)

[10:30] <moritz> lizmat: ^^

[10:30] <masak> jnthn: was just arguing against having more of the madness, again.

[10:30] <colomon> masak on for vs map, +1.  if that's now official p6, \o/

[10:30] <FROGGS_> jnthn: and while loops are intended to produce values but are NYI that way, right?

[10:30] <lizmat> moritz++

[10:31] <jnthn> FROGGS_: Right, they never produce them at present.

[10:31] <jnthn> FROGGS_: But by spec they should if not in statement list context, yes.

[10:31] <FROGGS_> jnthn: and more importantly for me: are for loop/while loops that produce values cheaper than gaver/take?

[10:31] <FROGGS_> gather*

[10:32] <jnthn> FROGGS_: Depends how we implement them, which depends on batching semantics, but working those out could make gather/take cheaper too.

[10:32] <jnthn> gather/take's efficiency also varies widely by backend.

[10:32] <FROGGS_> I mean, I do like gather/take, but it feels kinda obscure to use it if I only have a single branch in my block that will produce values

[10:32] <FROGGS_> ahh, k

[10:33] <moritz> I like it too, unless it breaks in precomp :-)

[10:33] <FROGGS_> hehe, yeah :o)

[10:33] <jnthn> moritz: I haven't seen a case where gather/take broke in precomp ever.

[10:33] <FROGGS_> jnthn: that is/was the DBIish r-j* bug

[10:33] <moritz> FROGGS_: did you verify that assumption?

[10:33] <jnthn> The only loop-related fail I saw in pre-comp of late was the while loop with pointy block issue I fixed in Moar's code-gen.

[10:33] <jnthn> Which was why 05-mock.t failed in DBIish on Moar.

[10:33] <FROGGS_> moritz: yes, your patch makes the tests pass

[10:34] <moritz> FROGGS_: \o/

[10:34] <FROGGS_> jnthn: ohh, then this is the same issue on jvm

[10:34] <jnthn> uh, did the moritz patch eliminate the while loop too?

[10:34] <FROGGS_> yes

[10:34] <FROGGS_> it is a (0..*).map... now

[10:34] <moritz> -        gather while self.fetchrow-hash -> %h {

[10:34] <moritz> -            take %h.item;

[10:34] <moritz> -        }

[10:34] <jnthn> Then it'll be same issue, I imagine, given that I think JVM has similar approach to Moar on compiling those.

[10:34] <jnthn> Yeah, it's that -> %h

[10:35] <jnthn> Well, we should fix the code-gen bug

[10:35] <jnthn> But maybe leave the patch in for this release as it's one more working module on r-j

[10:35] <moritz> but will we, in time for R*?

[10:35] <jnthn> This star release, I mean.

[10:35] <FROGGS_> jnthn: is it doable to port the fix for somebody who dislikes Java?

[10:35] <jnthn> FROGGS_: Given the fix is entirely in NQP code, yes. :)

[10:35] <FROGGS_> k :o)

[10:36] <jnthn> moritz: Well, that'd need a point release of NQP with the patch...

[10:36] <moritz> ok, I'll patch DBIish :-)

[10:36] <jnthn> moritz: May be easier to ship a patched DBI *and* fix it and unpatch DBI later.

[10:36] <dalek> DBIish: 1ef4584 | moritz++ | lib/DBDish.pm6:

[10:36] <dalek> DBIish: Work around precompilation issue on rakudo-j

[10:36] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/1ef45843c7

[10:36] <FROGGS_> cool!

[10:37] <dalek> star: 9fb3187 | moritz++ | modules/DBIish:

[10:37] <dalek> star: Bump DBIish revision to work around precomp bug

[10:37] <dalek> star: review: https://github.com/rakudo/star/commit/9fb3187d46

[10:38] *** dmol left
[10:44] *** bjz left
[10:50] <dalek> rakudo/nom: 6e04fb6 | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[10:50] <dalek> rakudo/nom: Make sending $index depend on arity of block

[10:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6e04fb616b

[10:50] *** SamuraiJack_ joined
[10:56] <jnthn> lizmat: All of this is the cost of supporting @foo => ...

[10:56] <lizmat> well, yes

[10:56] <lizmat> but it makes it *so* much easier to use "on"  :-)

[10:56] <jnthn> lizmat: It may be worth it in so far as we need to take less closures

[10:56] <lizmat> yup, that was the idea

[10:56] <jnthn> I'm...not convinced it's easier than a map over the input supplies that produces a list of pairs, to be honest.

[10:57] <lizmat> ?? 

[10:57] <jnthn> Well, what I was originally thinking was

[10:58] <jnthn> on -> $res { @mergeees.map(-> $m { $m => { more => -> $val { ... }, done => { ... } } }) };

[10:58] <jnthn> Then you can get at the right one just out of normal lexical scoping

[10:58] <jnthn> Rather than needing the whole $index mechanism.

[10:58] <FROGGS_> jnthn: that was the patch that wants porting, right? https://github.com/perl6/nqp/commit/c12a9a19771fbfc3c8e12dc5887108c4061d30cf

[10:59] <jnthn> FROGGS_: Yeah. You understand what it's doing?

[10:59] <FROGGS_> (as a side note: I am currently drinking a Cherry Porter)

[10:59] <jnthn> ooh :)

[10:59] * jnthn is currently drinking coffee. 

[10:59] <lizmat> but the $index is needed for simplifying things like zip and merge

[10:59] <jnthn> You win :P

[11:00] <jnthn> lizmat: How does it simplify them?

[11:00] <lizmat> if you have the supply in question, that doesn't help you in grouping information

[11:00] <FROGGS_> jnthn: it keeps the blocktype in case the thing was replaced

[11:00] <jnthn> FROGGS_: Right.

[11:00] <lizmat> because when you're zipping, you're not interested in which supply did what, just the ordinal of the supply, so you can then zip up when you need to

[11:01] <lizmat> zip becomes:

[11:01] <lizmat>   my $on = on -> $res {

[11:01] <lizmat>       my @values = ([],[]);

[11:01] <lizmat>       ($a,$b) => sub ($val,$index) {

[11:01] <lizmat>           @values[$index].push($val);

[11:01] <lizmat>           if all(@values) {

[11:01] <lizmat>               $res.more( (@values>>.shift) );

[11:01] <lizmat>           }

[11:01] <lizmat>       }

[11:01] <lizmat>   }

[11:01] <lizmat> well, essentially (this from changes in S17

[11:01] <lizmat> I'm writing right now)

[11:02] *** kurahaupo left
[11:06] <jnthn> lizmat: That's cute, though note that @mergees.kv.map(-> $index, $m { ... }) woulda givne the indexes quite neatly too :)

[11:07] <lizmat> let me first finish the spec changes, and I'll go back to implementation

[11:08] <lizmat> are are you saying that you're talking about the "on" syntax?

[11:08] <jnthn> Yes

[11:09] <lizmat> hmmmm....

[11:11] <jnthn> lizmat: Here is how I'd have written it:

[11:11] <dalek> specs: 0d7e427 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[11:11] <dalek> specs: Spec 'on' more elaborately

[11:11] <dalek> specs: 

[11:11] <dalek> specs: Add "index" feature, let implementation of "zip" and "merge" follow from the

[11:11] <dalek> specs: examples.

[11:11] <dalek> specs: review: https://github.com/perl6/specs/commit/0d7e427a08

[11:11] <jnthn> on -> $res { my @values = [] xx @mergees; my $ready  = all(@values); @mergees.kv.map(-> $index, $m {

[11:11] <jnthn>         $m => sub ($val) {

[11:11] <jnthn>             @values[$index].push($val);

[11:11] <jnthn>             if $ready {

[11:11] <jnthn>                 $res.more( (@values>>.shift) );

[11:11] <jnthn>             }

[11:11] <jnthn>         }

[11:11] <jnthn>     }

[11:11] <jnthn> ugh, it butchered the first lines, but think it's still understandable.

[11:11] <jnthn> }

[11:12] <lizmat> yes, but that seems like boilerplate to me... 

[11:12] *** dmol joined
[11:12] <lizmat> that's why I wanted to transparently support this

[11:12] <lizmat> by just sending the index extra when needed

[11:13] <lizmat> it makes the "on" code a bit more elaborate, but it makes coding "on" a lot understandable, I think

[11:16] <jnthn> I can see it's easier for those of a more imperative persuasion, yes. :)

[11:16] <jnthn> Anyway, I punt to TimToady on if the sugar is worth it.

[11:16] <lizmat> well, "on" being a sub, makes it more imperative to me  :-)

[11:16] <jnthn> Just wanted to point out the original design was simpler and capable of supporting these things.

[11:17] <lizmat> perhaps, but that wasn't clear to me from the spec :-(

[11:17] <lizmat> also: I eliminated the need for a "combine", I think

[11:17] <lizmat> so it's also a syntax simplification

[11:18] <jnthn> Yeah, I guess it relied on being able to generalize from "I return a list of Pairs in setup" to "I can programatically produce those pairs"

[11:18] <jnthn> Which was obvious to me when I wrote it, but probably wanted calling out.

[11:18] <jnthn> Of course, you've not made it so we can't write things that way :)

[11:18] <lizmat> indeed   :-)

[11:19] <lizmat> I added semantics, no real syntax changes

[11:19] <lizmat> (apart from the index value)

[11:22] *** anaeem1_ joined
[11:27] <lizmat> fg

[11:33] <lizmat> r: my &op = &[~]; say [&op] <a b c d e>  # what am I missing here?

[11:33] <camelia> rakudo-jvm 33ea6e: OUTPUT«(timeout)»

[11:34] <camelia> ..rakudo-{parrot,moar} 33ea6e: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32m] <a b c d e>  # what am I missing here?[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        infix stop…»

[11:34] <lizmat> r: my &op = &[~]; say [~] <a b c d e>  # what am I missing here?

[11:34] <camelia> rakudo-{parrot,jvm,moar} 33ea6e: OUTPUT«abcde␤»

[11:34] <lizmat> that works....

[11:35] <lizmat> Am I missing something about [&op] list ?

[11:35] <FROGGS_> std: my &op = &[~]; say [&op] <a b c d e>  # what am I missing here?

[11:35] <camelia> std ec3d853: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/1mn28Xk8Ew line 1 (EOF):␤------> [32m] <a b c d e>  # what am I missing here?[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 131m␤»

[11:36] <FROGGS_> something upsets the parser

[11:36] <FROGGS_> std: my &op = &[~]; say( [&op] <a b c d e> ) # what am I missing here?

[11:36] <camelia> std ec3d853: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/4UsC_Yxod_ line 1:␤------> [32mmy &op = &[~]; say( [&op] <a b c d e> [33m⏏[31m) # what am I missing here?[0m␤Parse failed␤FAILED 00:01 133m␤»

[11:36] <lizmat> how am I supposed to meta-op any given operator then?

[11:36] <FROGGS_> std: my &op = &[~]; # what am I missing here?

[11:36] <camelia> std ec3d853: OUTPUT«ok 00:01 128m␤»

[11:37] <FROGGS_> I'd guess what you are doing is not wrong, there is just a parsing bug

[11:38] <jnthn> I think that we never implemented the [&foo] case of reduction meta-op is all

[11:38] <lizmat> ok, so there is currently no way to do that?

[11:39] <FROGGS_> you miss that std is unable to parse it

[11:39] <lizmat> I was always under the impression you could write your own ops, and have them metaopped automagically

[11:40] *** sftp left
[11:40] <jnthn> FROGGS_: oh...hmm

[11:41] <jnthn> Well, here you are not defining your own op though.

[11:41] <jnthn> my @op is not enough

[11:41] <jnthn> needs to be a categorical I guess

[11:41] <jnthn> An infix:<op>

[11:41] <lizmat> my &op = [~]

[11:41] <lizmat> is not an op?

[11:41] <FROGGS_> it is not an infix

[11:41] <jnthn> No, it's a variable.

[11:41] <FROGGS_> [ something ] resolves to &infix:<something>

[11:42] <FROGGS_> so that you cannot reduce prefix/postfixes

[11:42] <lizmat> m: my &op = [~]; say &op.signature.arity

[11:42] <camelia> rakudo-moar 6e04fb: OUTPUT«Type check failed in assignment to '&op'; expected 'Callable' but got 'Str'␤  in block  at /tmp/jW6fxre3ex:1␤␤»

[11:42] <lizmat> m: my &op = &[~]; say &op.signature.arity

[11:42] <camelia> rakudo-moar 6e04fb: OUTPUT«0␤»

[11:42] <lizmat> m: my &op = &[~]; say &op.signature.count

[11:42] <camelia> rakudo-moar 6e04fb: OUTPUT«2␤»

[11:43] <lizmat> m: my &op = &[~]; say &op.perl

[11:43] <camelia> rakudo-moar 6e04fb: OUTPUT«sub infix:<~>(Any $?, Any $?) { #`(Sub+{<anon>}+{Precedence}|139819708037728) ... }␤»

[11:43] <lizmat> feels like an infix to me

[11:43] <FROGGS_> r: my &infix:<%%%> = &[~]; say [%%%] <a b c d e>

[11:44] <camelia> rakudo-jvm 6e04fb: OUTPUT«(timeout)»

[11:44] <camelia> ..rakudo-{parrot,moar} 6e04fb: OUTPUT«abcde␤»

[11:44] <FROGGS_> m: my &infix:<op> = &[~]; say [op] <a b c d e>

[11:44] <camelia> rakudo-moar 6e04fb: OUTPUT«abcde␤»

[11:44] <lizmat> ah, ok

[11:44] *** sftp joined
[11:45] <lizmat> FROGGS_++

[11:45] <FROGGS_> :o)

[11:45] <FROGGS_> though, that error msg from the parser is more than crap

[11:46] <lizmat> yeah...  that reeaaally confused me

[11:46] <jnthn> I can guess why, mind.

[11:46] <jnthn> [&op] is a perfectly nice array.

[11:46] <lizmat> yeah

[11:54] <masak> I see nothing to rakudobug, unfortunately.

[11:55] <lizmat> indeed, just a lizmatbug

[11:56] <FROGGS_> hmmm, I would at least hope to see the TTIAR between two terms, and not at EOF

[11:56] <FROGGS_> s/hope/something else/

[11:57] <dalek> star: 0e87ffe | moritz++ | / (3 files):

[11:57] <dalek> star: Add "verbose-modules-test" target

[11:57] <dalek> star: review: https://github.com/rakudo/star/commit/0e87ffeb33

[11:58] <lizmat> *sigh* code that runs perfectly in test, breaks when in settings  :-(

[12:00] <dalek> rakudo/nom: c3de83b | (Elizabeth Mattijsen)++ | src/core/SupplyOperations.pm:

[12:00] <dalek> rakudo/nom: Re-implement Supply.(zip|merge) with new "on" features

[12:00] <dalek> rakudo/nom: 

[12:00] <dalek> rakudo/nom: Alas, they break with cryptic "cannot stringify this" message

[12:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c3de83bcc8

[12:01] <dalek> roast: bcbeccc | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[12:01] <dalek> roast: Many more "on" tests and fudge Supply.(zip|merge)

[12:01] <dalek> roast: 

[12:01] <dalek> roast: Oddly enough, identical implementations of .zip and .merge work in the test,

[12:01] <dalek> roast: but not when they're pre-compiled in the settings.  Go figure  :-(

[12:01] <dalek> roast: review: https://github.com/perl6/roast/commit/bcbeccc8db

[12:03] <dalek> rakudo/nom: 15b0352 | (Elizabeth Mattijsen)++ | docs/ChangeLog:

[12:03] <dalek> rakudo/nom: Update ChangeLog

[12:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15b0352408

[12:04] <lizmat> jnthn: could it be that during settings compilation, in the -> $res { ... }, the {} is seen as a hash and it tries to stringify @s and can't ?

[12:05] *** rindolf joined
[12:05] <jnthn> lizmat: Did you try --ll-exception?

[12:05] <jnthn> lizmat: Could be an error erporting fail

[12:06] <lizmat> https://gist.github.com/lizmat/11112591

[12:10] <lizmat> I'm not seeing it  :-(

[12:10] <lizmat> guess I need some fresh air  :-)

[12:12] *** kurahaupo joined
[12:12] <jnthn> Well, it's exploding during signautre binding for some reason or other.

[12:12] <lizmat> but the same code does not explode during testing

[12:12] <FROGGS_> for some reason or other?

[12:12] <jnthn> Worse, on the slow path binder

[12:13] <jnthn> That either means that some signature you've got hits the slow path

[12:13] <jnthn> Or it failed over to it in order to generate an error message.

[12:13] *** bjz joined
[12:17] <lizmat> could it be that "on" is not really known at setting compile time?

[12:17] <lizmat> SupplyOperations *are* after Supply, but still

[12:18] <dalek> nqp/asyncops: a66079d | jnthn++ | docs/ops.markdown:

[12:18] <dalek> nqp/asyncops: Tweak signal definition.

[12:18] <dalek> nqp/asyncops: review: https://github.com/perl6/nqp/commit/a66079d8a8

[12:18] <dalek> nqp/asyncops: feefbf2 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[12:18] <dalek> nqp/asyncops: Signal constants.

[12:18] <dalek> nqp/asyncops: review: https://github.com/perl6/nqp/commit/feefbf24f9

[12:18] <jnthn> lizmat: on is just a normal sub call really

[12:19] <lizmat> but if somehow in the settings it doesn't know the sig yet

[12:19] <jnthn> lizmat: So should be no problem.

[12:19] <jnthn> Why would it need to?

[12:19] <lizmat> would that not explain the slow binding path ?

[12:19] <jnthn> No.

[12:19] <jnthn> That's all callee side, not caller.

[12:21] <FROGGS_> jnthn: it looks like I successfully ported the pointy fix

[12:21] <jnthn> FROGGS_: yay

[12:23] <jnthn> lizmat: oh...

[12:23] <jnthn> method zip(Supply @s is copy, :&with is copy) {

[12:23] <lizmat> ?

[12:24] <jnthn> I'm surprised that ever works, with the typed array.

[12:24] <jnthn> Unless it's declared typed elsewhere?

[12:24] <lizmat> you mean, is copy ?

[12:24] <lizmat> or Supply @s

[12:24] <jnthn> The type

[12:24] <jnthn> Supply @s

[12:25] <jnthn> Though the "is copy" is what forces it onto the slow path.

[12:25] <lizmat> ah, ok

[12:26] <lizmat> checking

[12:29] <jnthn> ooh, I can now tap sig_int 

[12:29] <jnthn> or SIGINT or call it what you will :)

[12:29] <lizmat> cool!

[12:30] <jnthn> >perl6-m -e "signal(Signal::SIGINT).tap({ say 'omg sigint!'; exit; }); sleep 10;"

[12:30] <jnthn> <hit ctrl+c>

[12:30] <jnthn> omg sigint!

[12:30] <jnthn> :)

[12:30] <jnthn> API up for discussion.

[12:31] <jnthn> But gets something working.

[12:31] <masak> jnthn++

[12:31] <lizmat> for clarity, maybe make it a class method on Supply?

[12:31] <lizmat> so Supply.signal(....) ?

[12:31] <jnthn> That feels...an odd place to put it.

[12:31] <lizmat> would make it consistent with other methods such as .for :-)

[12:31] <masak> jnthn: how do you un-register the signal handler?

[12:31] <jnthn> masak: Once I get around to it, by closing the tab

[12:31] <jnthn> masak: Doesn't do the right thing there yet

[12:32] <lizmat> jnthn: why?  it generates a Supply, not?

[12:32] <jnthn> masak: But I didn't get nqp::cancel and so forth in place

[12:32] <masak> jnthn: oki, good to know there's a plan for it.

[12:32] <jnthn> lizmat: Yeah, but...so will async socket stuff in places, but that doesn't mean they all want to have stuff in Supply.

[12:32] <masak> jnthn: would also be interesting to have a story, perhaps, about having (Perl 5) `local` semantics for handlers.

[12:32] <jnthn> masak: What are those?

[12:32] <masak> jnthn: could probably be arranged with `will leave` in Perl 6 or something.

[12:33] <masak> jnthn: they are handlers that stay alive during the *dynamic* scope of a routine.

[12:33] <jnthn> ugh

[12:33] <masak> oh, ok, forget it, then ;)

[12:33] <jnthn> Well, given our signal handlers are delivered asynchronously...

[12:33] <jnthn> You don't actually know which thread is gonna get 'em.

[12:34] <dalek> rakudo/nom: c0b27ba | (Elizabeth Mattijsen)++ | src/core/Supply (2 files):

[12:34] <dalek> rakudo/nom: Fix signature issues with Supply.(zip|merge)

[12:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c0b27baac9

[12:34] <jnthn> lizmat: Does that make the tests happy?

[12:34] <lizmat> the .zip test yes

[12:35] <lizmat> the .merge test breaks again now of "Cannot call method on a null object"

[12:36] <dalek> roast: 1684177 | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[12:36] <dalek> roast: Unfudge Supply.zip, change fudge on Supply.merge

[12:36] <dalek> roast: review: https://github.com/perl6/roast/commit/1684177fd1

[12:37] <dalek> Heuristic branch merge: pushed 16 commits to rakudo/async by jnthn

[12:38] *** haroldwu joined
[12:39] *** spider-mario joined
[12:40] <dalek> rakudo/async: 327e9dc | jnthn++ | src/core/ThreadPoolScheduler.pm:

[12:40] <dalek> rakudo/async: Expose underlying scheduler queue.

[12:40] <dalek> rakudo/async: 

[12:40] <dalek> rakudo/async: For the sake of things that want to use it as a target for any

[12:40] <dalek> rakudo/async: asynchronous operations.

[12:40] <dalek> rakudo/async: review: https://github.com/rakudo/rakudo/commit/327e9dc068

[12:40] <dalek> rakudo/async: 0b1f8aa | jnthn++ | / (2 files):

[12:40] <dalek> rakudo/async: Very first pass at signal handlers.

[12:40] <dalek> rakudo/async: 

[12:40] <dalek> rakudo/async: Probably some we could support are missing (though it's an LHF for

[12:40] <dalek> rakudo/async: somebody to add those), and the API is certainly up for discussion.

[12:40] <dalek> rakudo/async: But now there is, at least, a way. Closing the tap doesn't in any

[12:40] <dalek> rakudo/async: way remove the handler yet; that'll come later once the more general

[12:40] <dalek> rakudo/async: cancellation mechanism arrives.

[12:40] <dalek> rakudo/async: review: https://github.com/rakudo/rakudo/commit/0b1f8aa52f

[12:55] <lizmat> Files=808, Tests=31332, 195 wallclock secs ( 8.03 usr  3.87 sys + 1286.83 cusr 131.16 csys = 1429.89 CPU)

[12:55] <lizmat> Somewhere along the past few days, the spectest has gotten significantly longer and more CPU

[12:56] <lizmat> running again without S17 tests

[13:04] <lizmat> Files=801, Tests=30998, 185 wallclock secs ( 7.92 usr  3.76 sys + 1243.98 cusr 102.33 csys = 1357.99 CPU)

[13:04] <lizmat> so it's not the S17 tests, but something underneath that we lost  :-(

[13:06] <jnthn> Feel free to triage.

[13:10] <lizmat> I probably will, after some cycling&

[13:11] <jnthn> have a nice cycle o/

[13:14] *** darutoko left
[13:18] *** xenoterracide joined
[13:22] *** rindolf left
[13:26] *** gaussblurinc_ joined
[13:36] *** gaussblurinc_ left
[13:43] <FROGGS_> k, now I spectest the nqp-j patch and then I am going to commit...

[13:43] <FROGGS_> more than two hours for 10 changes lines :/

[13:44] <FROGGS_> changed*

[13:44] *** xenoterracide left
[13:45] <jnthn> I've had 10 hours for 2 changed lines in the past...

[13:46] <jnthn> But yeah, such things are annoying.

[13:48] *** LLamaRider joined
[13:51] *** rindolf joined
[13:59] *** gaussblurinc_ joined
[14:04] *** gaussblurinc_ left
[14:06] <FROGGS_> 10 hours??

[14:07] <FROGGS_> what took so long?

[14:12] *** darutoko joined
[14:15] <jnthn> FROGGS_: Debugging. Threads. GC. :P

[14:17] <dalek> nqp: 2a31697 | (Tobias Leich)++ | src/vm/jvm/QAST/Compiler.nqp:

[14:17] <dalek> nqp: port "Don't ruin input QAST in pointy if/while." to jvm backend

[14:17] <dalek> nqp: 

[14:17] <dalek> nqp: That is, we set blocktype to 'declaration' while compiling it to jast,

[14:17] <dalek> nqp: and now set it to its original value afterwards.

[14:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2a316976f6

[14:18] <jnthn> Wish there was a neater fix than that...

[14:18] <dalek> rakudo/nom: 87a6833 | (Tobias Leich)++ | tools/build/NQP_REVISION:

[14:18] <dalek> rakudo/nom: bump nqp rev that fixes pointy messup for jvm

[14:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/87a6833ad9

[14:18] <jnthn> (Of course, you just ported by one, I mean I wish I coulda thought of one.)

[14:18] <jnthn> s/by/my/

[14:19] <jnthn> walk; bbiab, then will continue on async sockety bits

[14:19] *** guru joined
[14:19] *** guru is now known as ajr_

[14:21] <FROGGS_> yes, that fix feels more like these two properties (declarative and the other one) does not belong to the same attribute

[14:21] <FROGGS_> but maybe it is evan cheaper that way, dunno

[14:21] <FROGGS_> walk also &

[14:23] <FROGGS_> moritz: that makes the previous code of DBDish.pm6 work

[14:24] <FROGGS_> current state of star: https://gist.github.com/FROGGS/0ea5537eb675588baaa2

[14:36] *** anaeem1_ left
[14:39] *** anaeem1 joined
[14:39] *** anaeem1 left
[14:39] *** anaeem1 joined
[14:40] *** xenoterracide joined
[14:53] *** Mouq joined
[14:53] <Mouq> Happy Easter #perl6!

[15:05] <pippo_> Mouq: Heppy Easter!

[15:10] <jnthn> Happy Easter, Mouq!

[15:12] <pippo_> exit

[15:12] *** pippo_ left
[15:13] <moritz> FROGGS_: seems that most remaining test failures have a common source

[15:16] *** SamuraiJack_ left
[15:22] *** pippo_ joined
[15:23] *** kurahaupo left
[15:23] <FROGGS[mobile]> moritz: yes, and also these are too heavy for me

[15:24] <FROGGS[mobile]> I already tried to fix the URI bug

[15:28] <moritz> FROGGS[mobile]: is the URI bug also precomp?

[15:28] <FROGGS[mobile]> yes

[15:29] <FROGGS[mobile]> about accessing lexicals from an our sub or so

[15:35] <nwc10> t/spec/S04-phasers/first.t keeps failing for me, with a parallel test

[15:35] <nwc10> (fewer than 4 of the planned tests run)

[15:35] <nwc10> but it never fails when being run alone

[15:35] <nwc10> even if I do things like pipe it to cat

[15:35] <jnthn> nwc10: Does it trip ASAN or valgrind?

[15:36] <nwc10> or pipe it to (sleep 3; cat)

[15:36] <nwc10> IIRC no

[15:36] <moritz> nwc10: I get those failures too

[15:37] <moritz> and last time I checked, they went away with that env var that disables spesh

[15:37] *** dmol left
[15:37] *** xinming_ joined
[15:39] *** dmol joined
[15:48] <moritz> http://www.biostat.jhsph.edu/courses/bio621/misc/Chocolate%20consumption%20cognitive%20function%20and%20nobel%20laurates%20%28NEJM%29.pdf # eat more chocolate!

[15:49] <jnthn> What an opportune thing to be told at easter :)

[15:49] *** BenGoldberg joined
[15:50] <jnthn> (Especially when $dayjob++ gave me a huge egg thingy full of it...)

[15:50] *** anaeem1 left
[15:51] <nwc10> jnthn: actually, no it *can't* be failing under ASAN, as the build is with ASAN

[15:51] <nwc10> and I get technicolor stack traces if anything fails

[15:51] <jnthn> nwc10: Ah...too bad.

[15:52] <timotimo> germany seems oddly unaffected by chocolate consumption

[15:54] <jnthn> .oO( And that's why Germany has so few nobel laureates...oh, wait... )

[15:54] <tadzik> you still on beer and sausage? :P

[15:54] <tadzik> not sure if I'll pick chocolate over that...

[15:59] * moritz likes susage *and* chocolate (just not in the same meal)

[16:00] <pippo_> m: say "Hello, world".words.perl

[16:00] <camelia> rakudo-moar 87a683: OUTPUT«("Hello,", "world").list␤»

[16:00] <pippo_> m: say "Hello, world" ~~ m/<<Hello>>/;

[16:00] <camelia> rakudo-moar 87a683: OUTPUT«｢Hello｣␤␤»

[16:02] <pippo_> .words includes puntuation? 

[16:02] *** anaeem1 joined
[16:02] <pippo_> .words includes puntuation but ">>" which is word bondaries does not? 

[16:03] <pippo_> *boundaries

[16:04] *** ssutch left
[16:04] <pippo_> *punctuation 

[16:05] *** anaeem___ joined
[16:06] *** anaeem1 left
[16:20] *** xenoterracide left
[16:25] *** anaeem___ left
[16:27] *** gaussblurinc_ joined
[16:31] *** xenoterracide joined
[16:35] *** telex left
[16:35] *** LLamaRider left
[16:36] *** telex joined
[16:54] *** rindolf left
[16:58] *** raiph joined
[17:03] *** Rotwang joined
[17:07] <FROGGS_> retupmoca: this seems fixed: https://gist.github.com/retupmoca/9953591

[17:18] *** SamuraiJack_ joined
[17:21] *** denis_boyun___ joined
[17:22] *** denis_boyun_ left
[17:24] *** rindolf joined
[17:40] *** adu joined
[17:45] <raiph> #6now #mop http://en.wikipedia.org/wiki/Metaobject

[17:47] <raiph> #6now #fish techniques for exploring P6 (eg metaprogramming)

[17:48] <raiph> m: say Block.^methods #6now #fish see http://irclog.perlgeek.de/perl6/2014-04-20#i_8613889

[17:48] <camelia> rakudo-moar 87a683: OUTPUT«<anon> add_phaser fire_phasers phasers perl <anon> <anon> <anon> <anon> <anon> <anon> arity count signature outer static_id of returns ACCEPTS Str␤»

[17:48] *** adu left
[17:51] <timotimo> what is "fish" for?

[17:52] *** ajr_ left
[17:55] <pippo_> m: my @a = 1..10; say @a[0..^*-1]; say @a[0.. ^*-2]; say @a[0..^*-2];

[17:55] <camelia> rakudo-moar 87a683: OUTPUT«1 2 3 4 5 6 7 8 9␤1 2 3 4 5 6 7 8 9␤1 2 3 4 5 6 7 8␤»

[17:56] <pippo_> Why a space before the "^" makes a difference? 

[17:58] <Mouq> pippo_: because "..^" is an infix

[17:58] *** denis_boyun_ joined
[17:59] *** denis_boyun___ left
[18:02] <pippo_> Mouq: Ha. OK. ty. I was thinking "^"is a prefix and ".." and infix.

[18:04] <raiph> timotimo: http://irclog.perlgeek.de/perl6/2014-04-20#i_8614688

[18:04] *** LLamaRider joined
[18:05] *** Rotwang left
[18:05] <raiph> timotimo: "teach a person to fish..."

[18:07] <jnthn> "...and they'll probably poke themself in the eye with the fishing rod"

[18:10] <raiph> jnthn: :) Presumably you just mean that for amusement, not as guidance away from teaching folk to fish (eg call ^methods, read p6doc, use #perl6 evalbots etc.) right?

[18:10] <FROGGS_> learnings is never bad

[18:11] <jnthn> raiph: Yes, was just amusing myself. :)

[18:11] <FROGGS_> learning*

[18:11] <jnthn> raiph: Using .^methods to discover is a good thing. Also .WHY when it's defined.

[18:12] <jnthn> (sadly, not yet on the built-ins)

[18:13] <raiph> yeah, I'm already intending to do a .WHY example and point that to lots of little #LHFs for adding #='s to builtins and another larger #LHF to suck those in to p6doc

[18:14] <raiph> and more generally to turn #perl6 itself into a fishable network of #6now lines

[18:16] <raiph> which could plausibly be circular: could use hashtags in .WHYs that link to the #perl6 IRC log and back again

[18:19] *** zakharyas joined
[18:20] <raiph> s/turn #perl6 itself into/try have #perl6 work as/

[18:23] <lizmat> jnthn: are you serious about the need of adding pod to the settings ?

[18:23] <lizmat> I seem to recall the last time I suggested / thought about that, it was a no because of increase parsing times while building the settings

[18:25] <jnthn> lizmat: I'm serious about making .WHY work. I don't think it needs to be done by adding it into the setting.

[18:25] <jnthn> lizmat: It can be done as a fallback.

[18:25] <jnthn> "ooh, no docs. Well, lemme look over there...OOH docs!"

[18:26] <lizmat> so you mean we implement a WHY that looks up the pod elsewhere ?

[18:26] <lizmat> (for the settings?)

[18:27] <jnthn> lizmat: That's what I'm thinking, yes.

[18:27] <jnthn> lizmat: I didn't think much about the details, and not saying it needs to happen Right Now.

[18:27] <jnthn> lizmat: But it'd enhance language explorability.

[18:28] <lizmat> indeed

[18:28] <lizmat> m: say 42.WHY

[18:28] <camelia> rakudo-moar 87a683: OUTPUT«(Any)␤»

[18:28] <FROGGS_> .WHY could happily fall back and cite from Pod files

[18:29] <FROGGS_> if there would be a nice mechanism it could even be nice for modules

[18:29] <FROGGS_> so you dont have to write pod twice

[18:29] <jnthn> lizmat: "Because the life, universe and everything" :P

[18:30] *** SamuraiJack_ left
[18:31] <raiph> can we please one day have 42.WHY respond with that? :)

[18:34] <cognominal> that's the time for easter eggs :)

[18:35] <dalek> rakudo/nom: 36d2580 | (Elizabeth Mattijsen)++ | src/core/Int.pm:

[18:35] <dalek> rakudo/nom: Implement 42.WHY

[18:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/36d25809e2

[18:36] <cognominal> lizmat++

[18:39] <lizmat> raiph: is today early enough?

[18:43] <raiph> timotimo: although I've no doubt folk will generally see this as proof that P6 isn

[18:43] <raiph> grr

[18:45] *** darutoko left
[18:46] <raiph> isn't serious, I think there's scope for a nice little video on code annotations, use thereof, and doc LHF, P6 style

[18:46] <raiph> gotta run

[18:47] *** a3gis joined
[18:48] <lizmat> r: my $x = -> $a { { a => sub () { $a } } }; my $foo = $x(42); say $foo<a>.();

[18:49] <camelia> rakudo-jvm 87a683: OUTPUT«(timeout)»

[18:49] <camelia> ..rakudo-{parrot,moar} 87a683: OUTPUT«42␤»

[18:49] <lizmat> hmmm...

[18:52] *** LLamaRider left
[18:59] <moritz> is there some kind of a "stealth mode" feature on github that might prevent me to add somebody to a team?

[18:59] <moritz> I'm trying to add softmoth++ to the perl6 team, but the UI won't allow it :(

[19:00] <jnthn> not as far as I know.

[19:02] <moritz> maybe I should open a bug report with the github folks

[19:04] <dalek> specs: f143d1a | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[19:04] <dalek> specs: Supply.(zip|merge) can be called as class method

[19:04] <dalek> specs: review: https://github.com/perl6/specs/commit/f143d1a064

[19:04] <jnthn> hehe...I thought my signals patch which depended on that might lead to it coming to work ;)

[19:11] <lizmat> it worked already, it just wasn't specced :-)

[19:15] <dalek> roast: 77fbcff | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[19:15] <dalek> roast: Tests calling Supply.(zip|merge) as class methods

[19:15] <dalek> roast: 

[19:15] <dalek> roast: Sadly, the .merge tests still need to be fudged because of

[19:15] <dalek> roast: "Cannot call method 'more' on a null object"

[19:15] <dalek> roast: review: https://github.com/perl6/roast/commit/77fbcffbc7

[19:17] *** raiph left
[19:19] <Mouq> pippo_: Understandable :)

[19:29] *** molaf_ joined
[19:32] *** molaf left
[19:33] <lizmat> m: say 42.WHY  # :-)

[19:33] <camelia> rakudo-moar 36d258: OUTPUT«Life, the Universe and Everything␤»

[19:39] <masak> ...because we didn't have enough bugs caused by serious commits? :P

[19:41] <lizmat> well, it seemed the right time of the year   :-)

[19:41] <moritz> lizmat++

[19:43] <masak> lizmat++ # for all the rest of the great stuff I see flying by almost daily

[19:43] <nwc10> This is a very interesting thread. It starts out about how to make Python 2 to Python 3 migration easier (by removing 80% of the flag day) but migrations to a more meta-discussion about how python-dev is working, and how it's overloaded/at risk of burning out: https://mail.python.org/pipermail/python-dev/2014-April/133986.html

[19:43] <nwc10> er, but migrates

[19:44] <nwc10> naughty fingers

[19:45] <lizmat> *blush*

[19:46] <masak> nwc10: looking

[19:46] <nwc10> it's quite long, but I think that all of the messages are worth reading

[19:47] <nwc10> (2 or 3 have mostly quoting and little content, but it's faster to read them and skip them than for me to go back and try to give you a list of them)

[19:48] *** kurahaupo joined
[19:50] <masak> nwc10: I'm mostly through the OP, and thinking that it sounds like a very sane strategy, and possibly relevant for Perl 5/6. (even though the jump is bigger in Perl's case.)

[19:50] *** rindolf left
[19:51] <lizmat> FWIW, I think perl 5 is already moving in that direction, with sub signatures and what not

[19:51] <masak> actually, forget that. I entertained the idea of hybrid Perl 5/6 code some years back, and concluded that it's basically too wide a gap.

[19:51] <masak> would love to be proven wrong, though.

[19:58] <masak> so far what I like best is the idea of a "Perl 5 and a half", a kind of stylized Perl 5 that is small and predictable enough to act as a bridge from 5 to 6.

[19:59] <masak> i.e. it should be strightforward to convert most Perl 5 to 5 1/2, and it should do a good-enough job rendering 5 1/2 code as Perl 6 code.

[20:00] <masak> nwc10: I'm halfway through the thread. frankly, I don't see why they don't just target http://pythonhosted.org/six/

[20:04] <nwc10> not sure, but I think the intent was that you could use the hypothetical thing to migrate your codebase file by file from 2.7-ish to 3.x-ish

[20:05] <nwc10> whereas I don't know with six whether you whole codebase has to agree that it's using six

[20:05] <nwc10> ie - I don't know anywhere near enough Python to know whether you have to do a flag day migation to six, or whether you can do it bit by bit

[20:08] <masak> me neither, though I don't see offhand why parts of the code base couldn't use six.

[20:08] *** hoverboard joined
[20:08] <masak> finished reading the thread. it was interesting.

[20:10] * Mouq finishes http://codegolf.stackexchange.com/a/26060/15012 and is done coding for today

[20:10] <Mouq> o/

[20:11] *** Mouq left
[20:12] *** raiph joined
[20:12] <lizmat> Mouq++

[20:16] *** zakharyas left
[20:21] <lue> I'm with lizmat, my very limited knowledge of Perl 5 suggests that they keep taking things from P6, and thus are already helping the migration process :) .

[20:23] <FROGGS_> well, you kinda have a migration process for the mind of the dev, but not for the codebase this way

[20:27] <lizmat> If *we* would make v5 better (note emphasis on "we", not just you, FROGGS_)

[20:27] <lizmat> and we would have an effort for creating Pure Perl (5) versions of CPAN modules with XS

[20:27] <lizmat> we would be attacking the migration issue from both ends

[20:28] <masak> 'night, #perl6

[20:28] <FROGGS_> that is why I still work on v5

[20:28] <lizmat> gnight masak

[20:29] <lizmat> FROGGS_++

[20:29] <FROGGS_> :o)

[20:29] <FROGGS_> gnight masak 

[20:30] *** a3gis left
[20:37] *** hoverboard left
[20:40] *** molaf_ left
[20:46] <dalek> specs: d6cdde4 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[20:46] <dalek> specs: Spec Supply.(buffering|delayed) and up Version

[20:46] <dalek> specs: review: https://github.com/perl6/specs/commit/d6cdde481f

[20:46] <dalek> rakudo/nom: 36750ae | (Elizabeth Mattijsen)++ | src/core/Supply (2 files):

[20:46] <dalek> rakudo/nom: Implement Supply.buffering

[20:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/36750ae335

[20:48] <jnthn> lizmat: I'd *love* an overlap thing for buffering

[20:48] <lizmat> overlap?

[20:48] <jnthn> .buffer(elems => 2, overlap => 1)

[20:48] <jnthn> I think .buffer is better than .buffering too

[20:48] <jnthn> Yeah

[20:48] <lizmat> well, I wanted to prevent confusion with buffers

[20:49] <jnthn> Imagine that you're getting a sequence of mouse co-ordinates in, while the mouse is being moved around.

[20:49] <jnthn> And you want to draw lines between them

[20:49] <lizmat> yes

[20:49] <jnthn> Then you'd want to get coordinates in pairs

[20:49] <jnthn> But you'd one them like

[20:49] <jnthn> c1,c2

[20:49] <jnthn> c2,c3

[20:49] <jnthn> c3,c4

[20:49] <jnthn> tec.

[20:49] <jnthn> *etc.

[20:49] <lizmat> ah, I see

[20:49] <lizmat> ok

[20:49] <lizmat> that should be doable  :-)

[20:49] <jnthn> This is really useful :)

[20:50] <lizmat> still, I think "buffering" is a better word

[20:50] <jnthn> I'm fine with it

[20:50] <lue> Yesterday we ran into that desired feature for simple lists, and called it .rotor while talking about it.

[20:50] <lizmat> especially if it has an overlap function

[20:51] <jnthn> Very happy to see the functionality. Was gonna implement it before my talk. Now I don't have to ;)

[20:51] <lizmat> hehe, great minds think alike  :)

[20:51] <colomon> https://github.com/colomon/List-Utils/blob/master/lib/List/Utils.pm (sliding-window, etc)

[20:52] <FROGGS_> hmmm, I always that that methods should be verbs, not nouns

[20:52] <FROGGS_> thought*

[20:53] <lue> only .rotor was designed to be rotor($take, $skip, $take, $skip...) so (^10).rotor(2,-1) would give you (0,1),(1,2),(2,3),...

[20:53] <raiph> Mouq++ # epic golf

[20:53] <lizmat> hmmmm....  

[20:55] <lue> (and something like rotor(2,0,1,0) would result in (0,1),(2),(3,4),(5),... and I *think* we also decided a missing skip value would be eqv. to 0, so .rotor(2) == .rotor(2,0))

[20:56] <lizmat> and that would make it the same as .buffering( :elems(2) )

[20:56] <lizmat> right ?

[20:56] <lue> probably, let me check S17 to make sure :)

[20:56] <lizmat> lue: https://github.com/perl6/specs/commit/d6cdde481f

[20:57] <lue> maybe, the point of .rotor as we discussed was to turn a flat list (like ^10) into one with more structure, not sure that's exactly what buffering does.

[20:58] <raiph> m: say Block.^method # I'm getting spoiled by awesome error messages; I was surprised this didn't say "did you mean 'methods'?" :)

[20:58] <camelia> rakudo-moar 36d258: OUTPUT«No such method 'method' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in block  at /tmp/FfaLpF8l3q:1␤␤»

[20:59] <raiph> m: say Block.^methods # Presumably it wouldn't be difficult to eliminate <anon>s?

[20:59] <camelia> rakudo-moar 36d258: OUTPUT«<anon> add_phaser fire_phasers phasers perl <anon> <anon> <anon> <anon> <anon> <anon> arity count signature outer static_id of returns ACCEPTS Str␤»

[21:02] <jnthn> I suspect those are the methods on Block written in NQP, as part of the circularity sawing.

[21:02] <jnthn> Doens't make any sense to eliminate them.

[21:02] *** kaare_ left
[21:02] <jnthn> Might make sense to figure out how to make their names show up

[21:02] <raiph> gotchya

[21:08] <FROGGS_> ~/dev/v5$ ./p5 '$::{bar}'

[21:08] <FROGGS_> Perl5: 

[21:08] <FROGGS_> v5:    ===SORRY!=== MVMArray: Index out of bounds

[21:08] <FROGGS_> -.-

[21:08] <FROGGS_> gnight

[21:09] <lizmat> gnight FROGGS_!

[21:09] <jnthn> 'night FROGGS_ 

[21:13] *** vendethiel joined
[21:15] <vendethiel> m: my %h; %h{1, 2, 3} = 5; say %h.perl;

[21:15] <camelia> rakudo-moar 36d258: OUTPUT«("1" => 5, "3" => Any, "2" => Any).hash␤»

[21:15] <vendethiel> m: my %h; %h{1, 2, 3} = 5 X=> 1..*; say %h.perl;

[21:15] <camelia> rakudo-moar 36d258: OUTPUT«("3" => 5 => 3, "2" => 5 => 2, "1" => 5 => 1).hash␤»

[21:16] <lizmat> m: my %h; %h{1, 2, 3} = (5 X=> 1..*); say %h.perl;

[21:16] <camelia> rakudo-moar 36d258: OUTPUT«("1" => 5 => 1, "2" => 5 => 2, "3" => 5 => 3).hash␤»

[21:19] <dalek> rakudo/nom: 3492812 | (Elizabeth Mattijsen)++ | src/core/Supply (2 files):

[21:19] <dalek> rakudo/nom: Implement :overlap in Supply.buffering

[21:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3492812b95

[21:19] <lizmat> jnthn: ^^^  :-)

[21:19] <vendethiel> m: constant A = 50; my %powers; for 2..Int(sqrt A) -> \a { next if a ~~ %powers; %powers{a, a**2, a**3 ...^ * > A} = a X=> 1..*; }; say %powers;

[21:19] <camelia> rakudo-moar 36d258: OUTPUT«("16" => 2 => 4, "2" => 2 => 1, "25" => 5 => 2, "27" => 3 => 3, "3" => 3 => 1, "32" => 2 => 5, "36" => 6 => 2, "4" => 2 => 2, "49" => 7 => 2, "5" => 5 => 1, "6" => 6 => 1, "7" => 7 => 1, "8" => 2 => 3, "9" => 3 => 2).hash␤»

[21:20] <dalek> roast: 162bbf4 | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[21:20] <dalek> roast: Add :elems/:overlap tests for Supply.buffering

[21:20] <dalek> roast: 

[21:20] <dalek> roast: Timed buffering is a bit trickier to test, more on that later

[21:20] <dalek> roast: review: https://github.com/perl6/roast/commit/162bbf4c3c

[21:21] <jnthn> lizmat: yays!

[21:21] <jnthn> lizmat: Will look at the code later; working on async socket reads.

[21:21] <lizmat> sure...   :-)

[21:24] <dalek> specs: 692aa10 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[21:24] <dalek> specs: Spec the Supply.buffering( :overlap )

[21:24] <dalek> specs: 

[21:24] <dalek> specs: Or maybe we should separate this into a .rotor method, as the use is really

[21:24] <dalek> specs: different.

[21:24] <dalek> specs: review: https://github.com/perl6/specs/commit/692aa105f3

[21:25] * lizmat has reached her commit limit for today  :-)

[21:25] <vendethiel> lizmat++

[21:25] <lizmat> goodnight #perl6!

[21:26] <vendethiel> m: say 27, 28 ... *%%13

[21:26] <camelia> rakudo-moar 36d258: OUTPUT«27 28 29 30 31 32 33 34 35 36 37 38 39␤»

[21:26] <jnthn> 'night, lizmat++

[21:26] *** a3gis joined
[21:27] <a3gis> m: say 27, 28 ... *%%13

[21:27] <camelia> rakudo-moar 36d258: OUTPUT«27 28 29 30 31 32 33 34 35 36 37 38 39␤»

[21:27] <a3gis> m: say 27, 28 ... * %% 13

[21:27] <camelia> rakudo-moar 36d258: OUTPUT«27 28 29 30 31 32 33 34 35 36 37 38 39␤»

[21:27] * vendethiel got a3gis to join randomly

[21:28] *** gaussblurinc_ left
[21:28] <vendethiel> r: say (*+*+3).perl

[21:28] <camelia> rakudo-{parrot,moar} 36d258: OUTPUT«WhateverCode.new()␤»

[21:28] <camelia> ..rakudo-jvm 36d258: OUTPUT«Unhandled exception: java.lang.RuntimeException: Missing or wrong version of dependency 'src/Perl6/Grammar.nqp'␤  in  (gen/jvm/main.nqp)␤␤»

[21:28] <vendethiel> m: say (*+*+3)(4).perl;

[21:28] <camelia> rakudo-moar 36d258: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block  at /tmp/x5Tx7Lyhty:1␤␤»

[21:29] <vendethiel> m: say (*+*+3)(4, 5);

[21:29] <camelia> rakudo-moar 36d258: OUTPUT«12␤»

[21:29] <vendethiel> m: say (3*(*+2))(5)

[21:29] <camelia> rakudo-moar 36d258: OUTPUT«21␤»

[21:34] <vendethiel> m: say one((1, 2, 3)) == 1 | 2

[21:34] <camelia> rakudo-moar 36750a: OUTPUT«one(any(True, False), any(False, True), any(False, False))␤»

[21:34] <raiph> hi a3gis: what comp langs do you know, what sort of programming do you do?

[21:34] <vendethiel> m: say so one((1, 2, 3)) == 1 | 2

[21:34] <camelia> rakudo-moar 36750a: OUTPUT«True␤»

[21:34] <vendethiel> raiph: he's busy doing Agda atm :)

[21:35] <vendethiel> m: say so one((1, 2, 3)) == 1 & 2

[21:35] <camelia> rakudo-moar 36750a: OUTPUT«True␤»

[21:35] <vendethiel> ^ wat

[21:35] <a3gis> raiph: hey! why? 

[21:35] * vendethiel thought one() was xor-ish

[21:36] <raiph> a3gis: just saying hi

[21:36] <a3gis> raiph: haha I am not used to people being that friendly on IRC (though vendethiel warned me perl folks are pretty cool)

[21:37] <a3gis> raiph: I've never touched perl but I intend to :p

[21:37] * vendethiel is pretty convinced most programmers are cool on IRC, in general :)

[21:38] * a3gis is too but usually they are to busy to say hello when you enter a chan

[21:40] <raiph> a3gis: just wrapped easter dinner and was taking a mo watching audio/visualization of sort algos

[21:40] <raiph> https://www.youtube.com/watch?v=kPRA0W1kECg

[21:41] <a3gis> vendethiel has been trying to evangelise me for the past month and it's slowly sinking in

[21:41] <a3gis> raiph: I actually say that one a few months back; really cool

[21:41] * vendethiel has been "evangelising" a3gis on many stuff through these last years, eh?

[21:42] <raiph> anyhoo, yeah, peak productivity comes from having fun, thus http://perl6.org/fun/

[21:43] <dalek> ecosystem: 62d661c | Adrian++ | META.list:

[21:43] <dalek> ecosystem: Add Audio::Taglib::Simple

[21:43] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/62d661cd76

[21:43] <dalek> ecosystem: 2d49b0e | colomon++ | META.list:

[21:43] <dalek> ecosystem: Merge pull request #28 from avuserow/patch-1

[21:43] <dalek> ecosystem: 

[21:43] <dalek> ecosystem: Add Audio::Taglib::Simple

[21:43] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/2d49b0e41e

[21:43] <avuserow> thanks colomon++ :)

[21:43] <colomon> now to check it out.  ;)

[21:44] * colomon has been using a .NET library with Niecza for MP3 tagging

[21:44] <a3gis> raiph: haha that sounds like good language design principles

[21:45] <avuserow> oh yeah, taglib is fantastic. I'm planning on adding support for editing tags too.

[21:45] <avuserow> Too bad that we need C++ support to get the advanced API which can let us see more tags, but the simplified API is still good enough for quite a bit

[21:49] <colomon> avuserow++ # I may be your first user.  ;)

[21:58] *** kurahaupo_mobile joined
[22:00] *** kurahaupo left
[22:00] <dalek> rakudo/async: 170241a | jnthn++ | src/core/ThreadPoolScheduler.pm:

[22:00] <dalek> rakudo/async: Tweak thread starting in queue accessor.

[22:00] <dalek> rakudo/async: 

[22:00] <dalek> rakudo/async: Create up towards the limit, rather than assuming one is enough, as

[22:00] <dalek> rakudo/async: that may lead to deadlocks.

[22:00] <dalek> rakudo/async: review: https://github.com/rakudo/rakudo/commit/170241ac0b

[22:00] <dalek> rakudo/async: 25e2ff4 | jnthn++ | / (2 files):

[22:00] <dalek> rakudo/async: Add basic async client socket support.

[22:00] <dalek> rakudo/async: 

[22:00] <dalek> rakudo/async: Only works on MoarVM so far, missing reading bytes and robustness and

[22:00] <dalek> rakudo/async: various other bits, but enough for writing a simple async HTTP client.

[22:00] <dalek> rakudo/async: review: https://github.com/rakudo/rakudo/commit/25e2ff42cc

[22:03] <dalek> nqp/asyncops: c042626 | jnthn++ | docs/ops.markdown:

[22:03] <dalek> nqp/asyncops: Sync async op docs with reality.

[22:03] <dalek> nqp/asyncops: review: https://github.com/perl6/nqp/commit/c04262617d

[22:05] *** a3gis left
[22:06] <tadzik> New Perl6 game is out! https://github.com/tadzik/RetroRacer

[22:06] <tadzik> blog post coming soonish

[22:09] *** kurahaupo_mobile left
[22:10] <jnthn> ooh :)

[22:13] <vendethiel> m: my %h; %h{1, 2, 3} = 1..*; say %h.perl;

[22:13] <camelia> rakudo-moar 36750a: OUTPUT«("2" => 2, "1" => 1, "3" => 3).hash␤»

[22:16] *** kurahaupo joined
[22:19] <pippo_> Nobody answered my question...

[22:19] <pippo_> m: say "Hello, world".words.perl

[22:19] <camelia> rakudo-moar 36750a: OUTPUT«("Hello,", "world").list␤»

[22:20] <pippo_> ^^ why the comma is captured as part of the word Hello? Is it as per spec?

[22:20] <vendethiel> pippo_: https://github.com/rakudo/rakudo/blob/7111fa8c13b51c0908288bc009bee0efd5b663ae/src/core/Str.pm#L818 

[22:20] <vendethiel> I really like the fact that, since rakudo is just perl6, you can check yourself so easily :D

[22:20] <vendethiel> it's just splitting "everything that isn't space", apparently.

[22:21] <retupmoca> is there anyone working on/planning to work on SSL sockets?

[22:21] <retupmoca> istr something about a gsoc thing involving ssl

[22:21] <tadzik> sergot may end up doing it on gso

[22:23] <retupmoca> ok, I may wait and see if he does

[22:23] <retupmoca> because I want ssl for all the Net::* stuff I'm writing, but I don't know if I want to jump into the complication of ssl and tls :P

[22:24] *** a3gis joined
[22:24] <jnthn> What's so scary? It ain't gonna make your heart bleed...

[22:24] <tadzik> blag toast: http://ttjjss.wordpress.com/2014/04/21/new-perl6-game-retroracer/

[22:27] <pippo_> m: say ',' ~~ /\S+/; 

[22:27] <camelia> rakudo-moar 36750a: OUTPUT«｢,｣␤␤»

[22:29] <pippo_> vendethiel: indeed. ty. So "Hello," and "Hello" are two different words...

[22:30] <vendethiel> m: say 'Hello, world'.comb(/\w+/);

[22:30] <camelia> rakudo-moar 36750a: OUTPUT«Hello world␤»

[22:30] <pippo_> I know. But .words is somewhat misleading.

[22:31] <tadzik> hm. Are there env vars or something I can modify to help rakudo look for Perl6::BOOTSTRAP?

[22:31] <pippo_> I know. But .words method name is somewhat misleading.

[22:31] <tadzik> I tried to distribute a tarball with moarvm, rakudo and the new game, but it still looks for some things in /home/tadzik :

[22:31] *** prevost joined
[22:31] <jnthn> tadzik: --libpath given to moar may help...

[22:32] <tadzik> jnthn: didn't :/

[22:32] <tadzik> I tried --libpath=moar-bundle/nqp/lib/Perl6

[22:32] <jnthn> hmmm

[22:32] <tadzik> maybe it wants absolutes

[22:32] <jnthn> maybe, yeah

[22:33] <tadzik> nah

[22:34] <jnthn> Oh

[22:34] <jnthn> Try strigging the Perl6 off the end of that

[22:34] <jnthn> Since it wil be putting that on itself I think.

[22:34] <tadzik> oh, well

[22:34] <vendethiel> what does "LSM" stand for ?

[22:34] <tadzik> perl6.moarvm contains string "tadzik" in it

[22:35] <tadzik> not a good sign :/

[22:35] <tadzik> jnthn: that I already had in libpath 

[22:35] <tadzik> LD_LIBRARY_PATH=moar-bundle moar-bundle/moar --libpath=moar-bundle/nqp/lib --libpath=moar-bundle/perl6/lib --libpath=moar-bundle/runtime moar-bundle/runtime/perl6.moarvm ./RetroRacer is what I tried

[22:35] <tadzik> it worked on my machine :D

[22:35] <vendethiel> (from Str.pm)

[22:35] <tadzik> obviously

[22:36] <lue> pippo_: words are things separated by whitespace, I fail to see how .words is misleading (after all, "2,600" shouldn't count as two words, should it?)

[22:37] *** prevost left
[22:39] <pippo_> m: say "Hello," ~~ m/<<Hello>>/

[22:39] <camelia> rakudo-moar 349281: OUTPUT«｢Hello｣␤␤»

[22:39] <pippo_> lue: is '>>' word boundary symbol?

[22:40] *** prevost joined
[22:40] *** prevost left
[22:40] *** spider-mario left
[22:40] <pippo_> m: say "Helloa" ~~ m/<<Hello>>/

[22:40] <camelia> rakudo-moar 349281: OUTPUT«False␤»

[22:40] <lue> Yep, « for left boundary, » for right

[22:41] <pippo_> lue: seems that the ',' is not part of a word.

[22:42] <lue> yeah, 'cos it isn't a word character

[22:43] <pippo_> why then for .words it is?

[22:43] *** prevost joined
[22:43] <lue> pippo_: .words is a shortcut for .split(/\s+/), that's why. No \w or \W involved

[22:44] <lue> (like how .lines is a shortcut for .split(/\n+/))

[22:45] <vendethiel> m: sub MAIN(Int $n) { say $n }

[22:45] <camelia> rakudo-moar 349281: OUTPUT«Usage:␤  /tmp/U_EfVJLTcJ <n> ␤»

[22:46] <vendethiel> ^ does it auto-convert to Int ?

[22:46] <lue> vendethiel: try it locally and see :) [I think the answer is yes]

[22:46] <vendethiel> I can't, that's why I ask here :p

[22:47] <avuserow> perl6 -e'sub MAIN(Int $n) {say $n.WHAT; say $n ~~ Int}' 123 # (Int+{orig-string[Str]}); True

[22:47] <pippo_> lue: in my opinion a shorcut to .split(/\s+/) should not be called .words because in contradiction with the notion of word.

[22:48] <lue> pippo_: what else would you call a thing surrounded by space?

[22:48] <vendethiel> "anything that's surrounded by space"?

[22:49] <lue> pippo_: if you need a more complex definition of what a word is, you'll have to do it yourself. Perl 6 is not in the business of locale-specific things

[22:49] <pippo_> lue: a word. But also thing delimited puntuation are words (punctuation excluded).

[22:49] <lue> (at least not yet)

[22:49] <pippo_> lue: a word. But also thing delimited by puntuation are words (punctuation excluded).

[22:49] *** adu joined
[22:49] <lue> r: say "Only 3.0 words".split(/\W+/).elems;

[22:50] <camelia> rakudo-{parrot,jvm,moar} 349281: OUTPUT«4␤»

[22:50] <cognominal> in perl6/Actions.pm, in methods statements and regex_declarator, is the $key? parameter a fossil, or does it mean something?

[22:50] <cognominal> oops

[22:50] <cognominal> I meant nqp/Actions.pm

[22:51] <cognominal> here :  https://github.com/perl6/nqp/blob/master/src/NQP/Actions.nqp#L148

[22:51] <cognominal> and here :  https://github.com/perl6/nqp/blob/master/src/NQP/Actions.nqp#L148

[22:51] <pippo_> lue: I see. Not so simple... 

[22:51] <raiph> Vendethiel: LSM = longest_substitution_matcher

[22:52] <vendethiel> ty raiph

[22:52] <lue> pippo_: precisely :) most scripts can agree on whitespace to separate words, but everything else depends on what your current goals are.

[22:53] <raiph> (didn't know; just searched irclogs for lsm :) )

[22:53] <pippo_> lue: OK. ty. and good night .-)

[22:53] <pippo_> lue: OK. ty. and good night :-)

[22:53] <lue> ♞ pippo_ o/

[22:53] *** pippo_ left
[22:57] <cognominal> https://github.com/perl6/nqp/blob/master/src/NQP/Actions.nqp#L1268 # the second one

[23:04] <lue> cognominal: seems to be unused, but I can't say for sure if it's truly useless. (Do any calls to those methods supply a key, for instance?)

[23:07] <dalek> rakudo-star-daily: 297fef5 | coke++ | log/ (5 files):

[23:07] <dalek> rakudo-star-daily: today (automated commit)

[23:07] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/297fef55ef

[23:07] <dalek> rakudo-star-daily: 5859664 | coke++ | log/ (5 files):

[23:07] <dalek> rakudo-star-daily: today (automated commit)

[23:07] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/58596648dc

[23:07] *** CJ__ joined
[23:07] <dalek> perl6-roast-data: 0aac7a4 | coke++ | / (6 files):

[23:07] <dalek> perl6-roast-data: today (automated commit)

[23:07] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/0aac7a442c

[23:07] <dalek> perl6-roast-data: 06ffeee | coke++ | / (6 files):

[23:07] <dalek> perl6-roast-data: today (automated commit)

[23:07] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/06ffeee9c9

[23:09] <dalek> rakudo/async: c4efc57 | jnthn++ | src/core/IO/Socket/Async.pm:

[23:09] <dalek> rakudo/async: Provide async server sockets on MoarVM.

[23:09] <dalek> rakudo/async: review: https://github.com/rakudo/rakudo/commit/c4efc57010

[23:09] <jnthn> Complete with mandatory crappy async HTTP server, of course...

[23:10] <jnthn> https://gist.github.com/jnthn/11127634

[23:10] *** CJ__ left
[23:11] <tadzik> awesome thins \o/

[23:15] *** a3gis left
[23:16] *** denis_boyun_ left
[23:26] *** dmol left
[23:27] <lue> jnthn: it's not much of a party without <blink>strobe effects</blink> :)

[23:35] <jnthn> Chrome doesn't seem to support blink, sadly

[23:35] <jnthn> marquee works, though.

[23:35] <geekosaur> blink was removed some versions back, yes

[23:38] <timotimo> that's cute, i like it

[23:39] <timotimo> and now we can combine that stuff with start blocks to do actual computations in parallel :)

[23:40] *** xenoterracide left
[23:40] <jnthn> Aye

[23:40] <jnthn> Well, will need some hardening, etc.

[23:42] *** adu left
[23:44] <jnthn> Enough code for today

[23:44] <jnthn> 'night, #perl6

[23:46] <timotimo> gnite jnthn :)

[23:50] <timotimo> hbmm

[23:50] <timotimo> er. i meant to write "hmm"

[23:50] <timotimo> i wonder ... libuv is older than node.js, isn't it?

[23:52] <timotimo> hmm

[23:52] *** kurahaupo left
