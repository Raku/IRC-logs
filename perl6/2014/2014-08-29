[00:00] <colomon> m: say map  *.base(36), ^50;

[00:00] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1Dâ¤Â»

[00:00] <grondilu> m: say "9" before "A"

[00:00] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:00] <grondilu> m: say "9" before "12"

[00:00] <camelia> rakudo-moar ce2631: OUTPUTÂ«Falseâ¤Â»

[00:01] <grondilu> :/

[00:01] <colomon> m: say "9" lt "12"

[00:01] <camelia> rakudo-moar ce2631: OUTPUTÂ«Falseâ¤Â»

[00:01] <colomon> m: say "9" < "12"

[00:01] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:02] * grondilu wants to create a infinite list of strings in lexicographic order

[00:02] <timotimo> colomon: just idly clicking around in the call graph shows that report-box-diff takes three times as report-attributes-diff, which takes a bit longer than report-coordinate-diff

[00:02] * grondilu though 'map *.base(36), 1..*' would do

[00:02] <grondilu> *thought

[00:03] <colomon> m: say ('a', *.incr â€¦ *)['1000]

[00:03] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/pyucksOVDJâ¤Two terms in a rowâ¤at /tmp/pyucksOVDJ:1â¤------> [32msay ('a', *.incr [33mâ[31mâ€¦ *)['1000][0mâ¤    expecting any of:â¤        method argumentsâ¤        postfixâ¤        iâ€¦Â»

[00:03] <colomon> m: say ('a', *.incr â€¦ *)[1000]

[00:03] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/UurNBZoh9nâ¤Two terms in a rowâ¤at /tmp/UurNBZoh9n:1â¤------> [32msay ('a', *.incr [33mâ[31mâ€¦ *)[1000][0mâ¤    expecting any of:â¤        method argumentsâ¤        postfixâ¤        inâ€¦Â»

[00:03] <colomon> m: my $a = 'a'l; say ('a', $a++ â€¦ *)[1000]

[00:03] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/SyZHX12yrFâ¤Two terms in a rowâ¤at /tmp/SyZHX12yrF:1â¤------> [32mmy $a = 'a'[33mâ[31ml; say ('a', $a++ â€¦ *)[1000][0mâ¤    expecting any of:â¤        postfixâ¤        infix stopperâ¤ â€¦Â»

[00:04] <colomon> m: my $a = 'a'; say ('a', $a++ â€¦ *)[1000]

[00:04] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/yQ9dEYFWGbâ¤Two terms in a rowâ¤at /tmp/yQ9dEYFWGb:1â¤------> [32mmy $a = 'a'; say ('a', $a++ [33mâ[31mâ€¦ *)[1000][0mâ¤    expecting any of:â¤        postfixâ¤        infix stopperâ¤  â€¦Â»

[00:04] <grondilu> m: say 'a', *.incr ... 'z'

[00:04] <camelia> rakudo-moar ce2631: OUTPUTÂ«===SORRY!===â¤No such method 'incr' for invocant of type 'Str'â¤Â»

[00:04] * colomon apparently cannot type

[00:04] <colomon> or remember method names

[00:04] <colomon> m: say ('a', *.succ â€¦ *)[1000]

[00:04] <grondilu> m: say 'a', *.succ ... 'z'

[00:04] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/F505gfDY1Kâ¤Two terms in a rowâ¤at /tmp/F505gfDY1K:1â¤------> [32msay ('a', *.succ [33mâ[31mâ€¦ *)[1000][0mâ¤    expecting any of:â¤        method argumentsâ¤        postfixâ¤        inâ€¦Â»

[00:04] <camelia> rakudo-moar ce2631: OUTPUTÂ«a b c d e f g h i j k l m n o p q r s t u v w x y zâ¤Â»

[00:04] <colomon> m: say 'a', *.succ ... 'zz'

[00:04] <camelia> rakudo-moar ce2631: OUTPUTÂ«a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci cj ck cl cm cn co cp â€¦Â»

[00:04] <grondilu> colomon++

[00:05] <colomon> errr, come to think of it though, that's not lexicographic order

[00:05] *** erkan joined
[00:06] <colomon> m: say ('a', * ~ 'a' â€¦ *)[100]

[00:06] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/wPQ0476j8iâ¤Two terms in a rowâ¤at /tmp/wPQ0476j8i:1â¤------> [32msay ('a', * ~ 'a' [33mâ[31mâ€¦ *)[100][0mâ¤    expecting any of:â¤        postfixâ¤        infix stopperâ¤        infixâ€¦Â»

[00:06] <colomon> m: say 'a', * ~ 'a' â€¦ *

[00:06] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/8K_pNKBdcvâ¤Two terms in a rowâ¤at /tmp/8K_pNKBdcv:1â¤------> [32msay 'a', * ~ 'a' [33mâ[31mâ€¦ *[0mâ¤    expecting any of:â¤        postfixâ¤        infix stopperâ¤        infix or metâ€¦Â»

[00:06] <grondilu> well, what I do want is my strings to be as small as possible, and still be in some order

[00:06] <timotimo> that's right, aa comes after a, not after z

[00:06] <colomon> ah, well there's a definite order to the *.succ strings, they're just not in lexicographic order

[00:07] <grondilu> how could I use more characters than just 'a'..'z'?

[00:07] *** gfldex left
[00:07] <grondilu> and I do need an infix comparison operator, though

[00:07] <colomon> oh, that's easy

[00:08] <colomon> m: say 45.char

[00:08] <camelia> rakudo-moar ce2631: OUTPUTÂ«No such method 'char' for invocant of type 'Int'â¤  in block <unit> at /tmp/F8MtE_QS0l:1â¤â¤Â»

[00:08] <colomon> m: say 45.chr

[00:08] <camelia> rakudo-moar ce2631: OUTPUTÂ«-â¤Â»

[00:08] <colomon> m: say (32..100).map(*.chr)

[00:08] <camelia> rakudo-moar ce2631: OUTPUTÂ«  ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c dâ¤Â»

[00:08] <colomon> m: say (32..1000).map(*.chr)

[00:08] <camelia> rakudo-moar ce2631: OUTPUTÂ«  ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~  Â€ Â Â‚ Âƒ Â„ Â… Â† Â‡ Âˆ Â‰ ÂŠ Â‹ ÂŒ Â Â Â Â Â‘ Â’ Â“ Â” â€¦Â»

[00:08] <colomon> etc

[00:08] <timotimo> colomon: which line does src/gen/m-CORE.setting:1096 correspond to on your build?

[00:08] <colomon> guess you'll run out of unicode at some point

[00:08] <grondilu> I want an infinite list

[00:09] <timotimo> what about src/gen/m-CORE.setting:8118?

[00:09] *** gfldex joined
[00:09] <timotimo> you could write a class that does Positional and implement at_pos by doing .chr :P

[00:10] <colomon> grondilu: I have a notion for you, but I'm answering timotimo first

[00:10] <colomon> timotimo: 1096:     multi method Stringy(Mu:D $:) { self.Str }

[00:10] <timotimo> huh, i wonder why that doesn't get spesh'd

[00:10] <grondilu> :/ that would be a hassle.  I don't get why '[before] *.base(36), 0..*' doesn't work :/

[00:10] <colomon> timotimo: 8118: GatherIter,         $state := { 

[00:10] <timotimo> and what does it need the $ for?

[00:11] <colomon> grondilu: because base 36 isn't in lexographical order any more than base 10 is

[00:11] <grondilu> std: say [Before] map *.base(26), ^50;

[00:12] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Two terms in a row (preceding is not a valid reduce operator) at /tmp/UF1Rlr_fdf line 1:â¤------> [32msay [Before] [33mâ[31mmap *.base(26), ^50;[0mâ¤    expecting any of:â¤        feed_separatorâ¤ infix or meta-infixâ¤    infixedâ€¦Â»

[00:12] <grondilu> m: say [before] map *.base(26), ^50;

[00:12] <camelia> rakudo-moar ce2631: OUTPUTÂ«Falseâ¤Â»

[00:12] <timotimo> colomon: i don't have a line matching GatherIter,.*state

[00:12] <colomon> timotimo: no, no, it's in GatherIter

[00:12] <timotimo> oh

[00:12] <colomon> the line is just

[00:12] <colomon>         $state := {

[00:12] <timotimo> derp :)

[00:12] <colomon>         $state := {

[00:12] <colomon>             nqp::handle( $block(),

[00:12] <colomon>                 'TAKE', SEQ($takings := nqp::getpayload(nqp::exception()); yield(); nqp::resume(nqp::exception())));

[00:12] <colomon>             $takings := $SENTINEL; yield();

[00:12] <colomon>         };

[00:12] * grondilu needs to read the WP page about lexicographic order

[00:12] <colomon> to be precise

[00:12] <timotimo> yes, now i found it :)

[00:12] <timotimo> and 1096 is inside class Mu, yes?

[00:13] <colomon> timotimo: yes

[00:15] <colomon> m: sub lex($n) { 1001.chr x ($n div 1000) ~ ($n mod 1000).chr }; say (999..1111).map({ lex($_) })

[00:15] <camelia> rakudo-moar ce2631: OUTPUTÂ«Ï§ Ï©â€ Ï© Ï© Ï© Ï© Ï© Ï© Ï© Ï© Ï©        Ï©â¤ Ï© Ï© Ï©

[00:15] *** gfldex left
[00:15] <colomon> m: sub lex($n) { 127.chr x ($n div 126) ~ ($n mod 126).chr }; say (100..200).map({ lex($_) })

[00:15] <camelia> rakudo-moar ce2631: OUTPUTÂ«d e f g h i j k l m n o p q r s t u v w x y z { | } â€               â¤   

[00:16] *** Jerry__ joined
[00:16] <colomon> hurmph

[00:17] *** gfldex joined
[00:20] *** kurahaupo_ joined
[00:21] *** Jerry__ left
[00:21] *** Jerry90 joined
[00:23] *** kurahaupo left
[00:25] <colomon> grondilu: got it

[00:26] <colomon> grondilu: https://gist.github.com/colomon/196e74c18c504d1150c4

[00:26] <colomon> you can tweak @codes to control how quickly the string gets longer

[00:29] *** BenGoldberg joined
[00:29] <grondilu> that's quite complicated

[00:30] *** jnap joined
[00:31] <grondilu> it's hard for me to believe it's not easier to create an infinite ordered list of strings :/

[00:31] *** jnap left
[00:32] <grondilu> I could of course use map *.Str, 0..* but I wanted to compress things a bit

[00:32] <BenGoldberg> That wouldn't be in lexigraphical order.

[00:33] <grondilu> I don't mind which kind of order as long as I have an order

[00:33] <BenGoldberg> Ok, nmind.

[00:33] <grondilu> m: say [<] map *.Str, 0..100; # just checking

[00:33] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:34] <BenGoldberg> m: say [lt] map *.Str, 0..100;

[00:34] <camelia> rakudo-moar ce2631: OUTPUTÂ«Falseâ¤Â»

[00:34] <grondilu> m: say [<] map *.fmt("%x"), 0..100; # just checking

[00:34] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/7b6S9eUV_b:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:34] <grondilu> wth?

[00:35] <grondilu> m: say 42.fmt("%x");

[00:35] <camelia> rakudo-moar ce2631: OUTPUTÂ«2aâ¤Â»

[00:35] <BenGoldberg> m: say *.fmt("%x");

[00:35] <grondilu> m: say map *.fmt("%x"), ^10;

[00:35] <camelia> rakudo-moar ce2631: OUTPUTÂ«WhateverCode.new()â¤Â»

[00:35] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 1 2 3 4 5 6 7 8 9â¤Â»

[00:35] <grondilu> m: say [+] map *.fmt("%x"), ^10;

[00:35] <camelia> rakudo-moar ce2631: OUTPUTÂ«45â¤Â»

[00:35] <grondilu> m: say [<] map *.fmt("%x"), ^10;

[00:35] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:36] <grondilu> m: say [<] map *.fmt("%x"), ^100;

[00:36] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/9mxEvrcN0K:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:36] <BenGoldberg> m: say [<] map *.fmt("%x"), ^99;

[00:36] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/gMUfE6yx4z:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:36] <grondilu> m: say [<] map *.fmt("%x"), ^50;

[00:36] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/FbFmoZlxcT:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:36] <grondilu> m: say [<] map *.fmt("%x"), ^20;

[00:36] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/6Mw_CpU73e:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:36] <BenGoldberg> m: say [<] map *.fmt("%x"), ^11;

[00:36] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/lc5aNFCnKB:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:36] <grondilu> m: say map *.fmt("%x"), ^20;

[00:36] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13â¤Â»

[00:37] <grondilu> j: say [<] map *.fmt("%x"), ^20;

[00:37] <camelia> rakudo-jvm ce2631: OUTPUTÂ«(timeout)Â»

[00:37] <grondilu> n: say [<] map *.fmt("%x"), ^20;

[00:37] <camelia> niecza v24-109-g48a8de3: OUTPUTÂ«Unhandled exception: Cannot parse number: aâ¤  at /home/p6eval/niecza/lib/CORE.setting line 1536 (die @ 5) â¤  at /home/p6eval/niecza/lib/CORE.setting line 3757 (ANON @ 10) â¤  at /home/p6eval/niecza/lib/CORE.setting line 3759 (NumSyntax.str2num @ â€¦Â»

[00:37] <BenGoldberg> m: say '9' < 'a';

[00:37] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/CnuFByDpmw:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:37] <BenGoldberg> Aha!

[00:37] <grondilu> oh yeah

[00:38] <grondilu> n: say [<] map *.fmt("0x%x"), ^20;

[00:38] <camelia> niecza v24-109-g48a8de3: OUTPUTÂ«Trueâ¤Â»

[00:38] <BenGoldberg> n: say '9' < 'a';

[00:38] <camelia> niecza v24-109-g48a8de3: OUTPUTÂ«Unhandled exception: Cannot parse number: aâ¤  at /home/p6eval/niecza/lib/CORE.setting line 1536 (die @ 5) â¤  at /home/p6eval/niecza/lib/CORE.setting line 3757 (ANON @ 10) â¤  at /home/p6eval/niecza/lib/CORE.setting line 3759 (NumSyntax.str2num @ â€¦Â»

[00:38] <BenGoldberg> n: say '9' < '0xa';

[00:38] <camelia> niecza v24-109-g48a8de3: OUTPUTÂ«Trueâ¤Â»

[00:38] <BenGoldberg> p6: say '9' < 'a';

[00:38] <grondilu> yeah I must not forget 0

[00:38] <camelia> rakudo-parrot ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in any  at gen/parrot/BOOTSTRAP.nqp:1221â¤â¤use of uninitialized value $/ of type Nil in string contextâ¤Cannot call 'Real'; none of these signatures match:â¤:(Mu:U \v: *%_)â¤  in any  at â€¦Â»

[00:38] <camelia> ..rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/tmpfile:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:38] <camelia> ..niecza v24-109-g48a8de3: OUTPUTÂ«Unhandled exception: Cannot parse number: aâ¤  at /home/p6eval/niecza/lib/CORE.setting line 1536 (die @ 5) â¤  at /home/p6eval/niecza/lib/CORE.setting line 3757 (ANON @ 10) â¤  at /home/p6eval/niecza/lib/CORE.setting line 3759 (NumSyntax.str2num @ â€¦Â»

[00:38] <grondilu> yeah I must not forget 0x

[00:38] <camelia> ..rakudo-jvm ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in any  at gen/jvm/BOOTSTRAP.nqp:1214â¤â¤Unhandled exception: use of uninitialized value $/ of type Nil in string contextâ¤  in warn (gen/jvm/CORE.setting:732)â¤  in warn (gen/jvm/CORE.settingâ€¦Â»

[00:39] <BenGoldberg> niecza's error msg is sensible.  rakudo's is less so.

[00:39] <grondilu> isn't there an extension of the printf format for base 36?

[00:40] *** Jerry90 left
[00:40] <BenGoldberg> m: say 11.base(16);

[00:40] <camelia> rakudo-moar ce2631: OUTPUTÂ«Bâ¤Â»

[00:40] *** Jry joined
[00:40] <grondilu> since Z is the last letter, it could be 0Z.  so *.fmt("0Z%Z")

[00:44] <BenGoldberg> m: say '0' lt '00';

[00:44] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:44] <grondilu> also, if I define infix:Â«<=>Â» on a custom type, aren't infix:Â«<Â» and infix:Â«>Â» automatically defined as well?

[00:44] <timotimo> colomon: did you have time to try the jit with your code yet?

[00:44] <grondilu> P5's overload do something like that IIRC

[00:44] <grondilu> *does

[00:44] <colomon> grondilu: quick answer is no

[00:44] <BenGoldberg> m: say [<] map 'a' x *, ^10;

[00:44] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/UaKTibGN0A:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[00:44] <colomon> timotimo: I have not had time, sorry

[00:44] <BenGoldberg> m: say [lt] map 'a' x *, ^10; # d'oh

[00:44] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:44] <timotimo> that's fine

[00:44] <BenGoldberg> m: say [lt] map 'a' x *, ^1000;

[00:44] <timotimo> i'm distracted at the moment anyway

[00:44] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:45] <BenGoldberg> Ta-da!  Lexigraphical order achieved.

[00:45] <colomon> BenGoldberg: I already did that one, and grondilu said he wanted reasonable length.

[00:49] *** ClarusCogitatio joined
[00:49] *** xenoterracide joined
[00:50] *** MilkmanDan left
[00:50] <grondilu> .oO( use MONKEY_TYPING; augment class Int { multi method base($base, :$lexicographic!) {...} } )

[00:50] *** Akagi201_ joined
[00:50] <colomon> grondilu: you can't make base lexicographic.  

[00:51] <grondilu> damn it

[00:52] <grondilu> I just want a base method so that $a.base($base) < $b.base($base) if and only if $a < $b

[00:52] <grondilu> in other words a base method that preserves integer order

[00:53] <colomon> do you mean $a.base($base) lt $b.base($base) ?

[00:53] *** MilkmanDan joined
[00:53] <grondilu> yes

[00:53] <colomon> that can't work with any normal base, that was the point of my above comment.

[00:53] <colomon> I don't understand why you think it might?

[00:53] <grondilu> oh

[00:53] <BenGoldberg> You mean a numeric encoding, not necessarily a base.  Use the right terms, and people will be less confused ;)

[00:54] *** dayangkun joined
[00:54] <grondilu> ok

[00:54] <grondilu> fair point

[00:54] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(2); 1 ~ encode($n.chars-1) ~ $n.substr(1) }; say [lt] map { encode($_) }, ^200;

[00:54] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[00:54] <colomon> certianly a numeric encoding can be done, both BenGoldberg and I have suggested them

[00:54] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(2); 1 ~ encode($n.chars-1) ~ $n.substr(1) }; say map { encode($_) }, ^200;

[00:54] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 10 1100 1101 1110000 1110001 1110010 1110011 11101000 11101001 11101010 11101011 11101100 11101101 11101110 11101111 111100000000 111100000001 111100000010 111100000011 111100000100 111100000101 111100000110 111100000111 111100001000 111100001001 1111000â€¦Â»

[00:55] <colomon> BenGoldberg++ # that's a lovely one

[00:55] <BenGoldberg> There's a name for it, but I forget what ;)

[00:56] <BenGoldberg> That one is asymtotically optimal, if you don't mind that it produces bits :)

[00:57] <grondilu> well you beat me.  This one is too smart for me to get it quickly.  I'll digest it and maybe I'll find a version that uses a larger alphabet.

[00:57] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(2); 1 ~ encode($n.chars-1) ~ $n.substr(1) }; say [lt] map { ('0b'~encode($_)).Int.base(37) }, ^200;

[00:58] <camelia> rakudo-moar ce2631: OUTPUTÂ«base must be between 2 and 36, got 37â¤  in method Str at src/gen/m-CORE.setting:13249â¤  in method Stringy at src/gen/m-CORE.setting:1096â¤  in sub infix:<lt> at src/gen/m-CORE.setting:1517â¤  in sub  at src/gen/m-CORE.setting:17995â¤  in block <unitâ€¦Â»

[00:58] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(2); 1 ~ encode($n.chars-1) ~ $n.substr(1) }; say [lt] map { ('0b'~encode($_)).Int.base(36) }, ^200;

[00:58] <camelia> rakudo-moar ce2631: OUTPUTÂ«Falseâ¤Â»

[00:59] <BenGoldberg> I'm sure there's a way to do it, I'm just not thinking of it right now.

[00:59] <grondilu> you wanted to use :2[encode($_)]

[00:59] <grondilu> (though it does not help much)

[01:01] <BenGoldberg> I meant, to make it base 36 for shorter strings, and still be a lexigraphical encoding.

[01:01] <grondilu> so my challenge is:  find a sub f(Int $ --> Str) {...}  such that  f($a) lt f($b) if and only if $a < $b and with f($a) as short as possible.

[01:01] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); $n.substr(0,1) ~ encode($n.chars-1) ~ $n.substr(1) }; say map { encode($_) }, ^200;

[01:01] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 10 20 30 40 50 60 70 80 90 A0 B0 C0 D0 E0 F0 G0 H0 I0 J0 K0 L0 M0 N0 O0 P0 Q0 R0 S0 T0 U0 V0 W0 X0 Y0 Z0 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 110A 110B 110C 110D 110E 110F 110G 110H 110I 110J 110K 110L 110M 110N 110O 110P 110Q 110R 110S 110Tâ€¦Â»

[01:02] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); encode($n.chars-1) ~ $n }; say map { encode($_) }, ^200;

[01:02] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0G 0H 0I 0J 0K 0L 0M 0N 0O 0P 0Q 0R 0S 0T 0U 0V 0W 0X 0Y 0Z 0110 0111 0112 0113 0114 0115 0116 0117 0118 0119 011A 011B 011C 011D 011E 011F 011G 011H 011I 011J 011K 011L 011M 011N 011O 011P 011Q 011R 011S 011Tâ€¦Â»

[01:02] <grondilu> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); $n.substr(0,1) ~ encode($n.chars-1) ~ $n.substr(1) }; say [lt] map { encode($_) }, ^200;

[01:02] <camelia> rakudo-moar ce2631: OUTPUTÂ«Falseâ¤Â»

[01:03] <grondilu> maybe I should ask on stackexchange or something :)

[01:03] * BenGoldberg 's brain is tired.

[01:05] *** colomon_ joined
[01:06] *** colomon left
[01:06] *** colomon_ is now known as colomon

[01:07] <grondilu> or more precisely:  given an alphabet @abc and a subset Word of Str where /^^<@abc>+$$/; find a sub f(Int $n --> Word) {...} such that f is bijective and f($a) lt f($b) iff $a < $b

[01:08] <grondilu> (if such a bijection exists, which I'm not sure of)

[01:09] <colomon> you left out the "short as possible" bit there...

[01:09] <colomon> good news: I just got a working smoke run

[01:09] <grondilu> no need since I imposed an alphabet and a bijection

[01:10] <colomon> bad news is I had to manually kill two run-away test file runs to get the smoke test to finish

[01:11] <colomon> grondilu: 'a' x $n is bijective and in your alphabet

[01:11] <colomon> but it's the least short vaguely sane approach

[01:11] <grondilu> yeah but you pick your own alphabet

[01:11] <grondilu> and it's injective, not surjective

[01:11] <grondilu> I mean what's f^-1("b")?

[01:12] *** FROGGS_ joined
[01:12] <grondilu> (what I meant is that 'a' x $n works only if @abc = 'a')

[01:12] <colomon> ah, I see

[01:14] <colomon> yeah, I don't see any obvious reason to believe that is possible.

[01:15] *** FROGGS left
[01:15] <grondilu> I think it's possible and it's pretty easy to prove

[01:15] <grondilu> both sets are totally ordered with a minimal element each.

[01:16] <grondilu> so you can remove the minimal elements and associate them.  Then reiterate.

[01:18] <colomon> :\

[01:18] <grondilu> you don't agree?

[01:18] <colomon> nope

[01:18] <colomon> consider your alphabet

[01:19] <colomon> do you agree that there are an infinite number of strings that start with "a"?

[01:19] <grondilu> there is

[01:19] <grondilu> there are indeed I mean

[01:19] <colomon> then how can you ever map a string that starts with 'b' to a number

[01:19] <colomon> ?

[01:19] <colomon> by your method, I mean

[01:20] <grondilu> damn it

[01:21] <dalek> roast: 7fc8efd | TimToady++ | S32-exceptions/misc.t:

[01:21] <dalek> roast: update to new P5var warnings

[01:21] <dalek> roast: review: https://github.com/perl6/roast/commit/7fc8efdbe0

[01:22] <grondilu> you're right my method can not be surjective, it would give [\~] 'a' xx * again

[01:24] <grondilu> I guess there's soething about lexicographic orders I simply don't fundamentally understand.

[01:24] <colomon> grondilu: I think you might even be able to reverse your proof to prove why it's impossible to do.

[01:24] <dalek> rakudo/nom: 54cd8fb | TimToady++ | src/ (3 files):

[01:24] <dalek> rakudo/nom: update to new P5var warnings

[01:24] <dalek> rakudo/nom: 

[01:24] <dalek> rakudo/nom: Also a start on implementing sigil-only variables, which parse but produce

[01:24] <dalek> rakudo/nom: an erroneous QAST at the moment.  They do not, however, interfere with

[01:24] <dalek> rakudo/nom: existing code, so in they go without a branch. :)

[01:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/54cd8fb6d9

[01:25] <grondilu> you mean by absurdo or something?  Possibly indeed.

[01:25] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(2); 1 ~ encode($n.chars-1) ~ $n.substr(1) }; say map { :2(reverse(encode($_))).base(36).reverse }, ^200;

[01:25] <camelia> rakudo-moar ce2631: OUTPUTÂ«Type check failed in binding $str; expected 'Str' but got 'Array'â¤  in sub unbase at src/gen/m-CORE.setting:7102â¤  in block <unit> at /tmp/PFOwnT4B8D:1â¤â¤Â»

[01:26] * BenGoldberg is confused.

[01:26] <colomon> grondilu: suppose there *is* an bijective mapping for the first N numbers.  

[01:27] <colomon> find the longest string in those N strings.

[01:27] <BenGoldberg> m: say 'abc'.reverse; # what's the right way to do this?

[01:27] <camelia> rakudo-moar ce2631: OUTPUTÂ«abcâ¤Â»

[01:27] <colomon> then make a string of a's one character longer than that long string.

[01:27] <colomon> BenGoldberg: 'abc'.flip

[01:27] <grondilu> BenGoldberg: flip

[01:27] <BenGoldberg> Ok.

[01:28] <colomon> grondilu: that string of all a's will be lexographically before at least N/4 of the strings you already have

[01:28] <grondilu> colomon: well done

[01:29] <grondilu> so I must give up on requiring a bijection.  Nevermind.  The problem remains.  Just need to rephrase it.

[01:33] <BenGoldberg> You need a "universal coding", I think.

[01:34] <BenGoldberg> The encoding() function I gave was a variation of the "Elias Omega Coding", modified to be able to represent 0

[01:34] <grondilu> Interstingly enough, the set of strings with the lexicographic order is totally order, and yet when we take all successive smallest elements, we don't exhaust the set.  I thoutht that was not possible.

[01:35] * grondilu checks out Elias Omega Coding

[01:36] <BenGoldberg> Also, besides reading the wikipedia page, you might pester the folks on ##math.

[01:36] <colomon> grondilu: the problem is that a longer string still fits in between shorter strings.

[01:37] <colomon> I reckon the set of strings in an alphabet is uncountable.

[01:38] <grondilu> BenGoldberg++ neat ideas for RC tasks

[01:39] <grondilu> colomon: if the alphabet is finite, the set of strings is very much countable.

[01:39] <grondilu> actually, even with an infinite alphabet it's still countable

[01:40] <colomon> hmmm, yeah, that seems right

[01:40] <grondilu> as long as the strings are finite

[01:40] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(10); 1 ~ encode($n.chars-1) ~ $n }; say [<] map { encode($_) }, ^200; # success!

[01:40] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[01:41] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); 1 ~ encode($n.chars-1) ~ $n }; say [<] map { encode($_) }, ^200; # success!

[01:41] <camelia> rakudo-moar ce2631: OUTPUTÂ«use of uninitialized value $/ of type Nil in string context  in block <unit> at /tmp/XnsVMzS3q2:1â¤â¤Error while creating error string: No exception handler located for warnâ¤Â»

[01:41] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); 1 ~ encode($n.chars-1) ~ $n }; say [lt] map { encode($_) }, ^200; # success!

[01:41] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[01:41] <BenGoldberg> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); 1 ~ encode($n.chars-1) ~ $n }; say map { encode($_) }, ^200; # success!

[01:41] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 101 102 103 104 105 106 107 108 109 10A 10B 10C 10D 10E 10F 10G 10H 10I 10J 10K 10L 10M 10N 10O 10P 10Q 10R 10S 10T 10U 10V 10W 10X 10Y 10Z 110110 110111 110112 110113 110114 110115 110116 110117 110118 110119 11011A 11011B 11011C 11011D 11011E 11011F 11â€¦Â»

[01:42] <grondilu>  m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); 1 ~ 

[01:42] <camelia> rakudo-moar ce2631: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ZiBlULt6dBâ¤Bogus statementâ¤at /tmp/ZiBlULt6dB:1â¤------> [32murn '0' unless $n; $n = $n.base(36); 1 ~[33mâ[31m<EOL>[0mâ¤    expecting any of:â¤        postfixâ¤        infix stopperâ¤â€¦Â»

[01:42] <grondilu> oops

[01:43] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say map { encode($_) }, ^200;

[01:43] <camelia> rakudo-moar ce2631: OUTPUTÂ«a ba1 ba2 ba3 ba4 ba5 ba6 ba7 ba8 ba9 baA baB baC baD baE baF baG baH baI baJ baK baL baM baN baO baP baQ baR baS baT baU baV baW baX baY baZ bba110 bba111 bba112 bba113 bba114 bba115 bba116 bba117 bba118 bba119 bba11A bba11B bba11C bba11D bba11E bba11F bbâ€¦Â»

[01:43] <grondilu> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); 1 ~ encode($n.chars-1) ~ $n }; say [lt] map { encode($_) }, ^200; 

[01:43] <camelia> rakudo-moar ce2631: OUTPUTÂ«Trueâ¤Â»

[01:43] <grondilu> BenGoldberg++

[01:44] <grondilu> m: sub encode($n is copy) { return '0' unless $n; $n = $n.base(36); 1 ~ encode($n.chars-1) ~ $n }; say map { encode($_).chars - .chars }, ^200; 

[01:44] <camelia> rakudo-moar ce2631: OUTPUTÂ«0 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 â€¦Â»

[01:44] <grondilu> lol they are actually longer than the decimal encoding, though :)

[01:44] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say map { encode(10 ** $_) }, ^20;

[01:44] <camelia> rakudo-moar ce2631: OUTPUTÂ«ba1 baA bba12S bba1RS bba27PS bba3255S bba3LFLS bba45YC1S bba51NJCHS bba5GJDGXS bba64LDQPDS bba719XTF1TS bba7CRE66I9S bba83JLXPT2PS bba8ZG3D62R5S bba99UGXNORJLS bbaA2QGPCKVNG1S bbaARCN1HSSIGHS bbaB7LIEEXZX4KXS bbaC23Z405FZ79TDSâ¤Â»

[01:45] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say map { encode(10 ** $_).chars - $_ }, ^20;

[01:45] <camelia> rakudo-moar ce2631: OUTPUTÂ«3 2 4 3 3 3 2 2 2 1 1 1 0 0 -1 -1 -1 -2 -2 -2â¤Â»

[01:45] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say map { encode(10 ** $_).chars / $_ }, ^20;

[01:45] <camelia> rakudo-moar ce2631: OUTPUTÂ«Type check failed for return value; expected 'Int' but got 'Failure'â¤  in any return_error at src/vm/moar/Perl6/Ops.nqp:646â¤  in method floor at /home/p6eval/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:1â¤  in method Str at src/gen/m-CORâ€¦Â»

[01:45] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say map { encode(10 ** $_).chars / ($_+1) }, ^20;

[01:45] <camelia> rakudo-moar ce2631: OUTPUTÂ«3 1.5 2 1.5 1.4 1.333333 1.142857 1.125 1.111111 1 1 1 0.923077 0.928571 0.866667 0.875 0.882353 0.833333 0.842105 0.85â¤Â»

[01:46] <grondilu> well, I must add as a requirement that it must do better than the decimal encoding.  That is f($a).chars <= $a.chars

[01:46] <grondilu> at least for most $a

[01:46] <BenGoldberg> When the numbers get big enough, it will be smaller than the base 10 version.

[01:46] <grondilu> ok, I can believe that.

[01:47] <grondilu> (though I was planning on using that for relatively small numbers  :)  )

[01:48] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say first { encode(10 ** $_).chars < $_ }, ^20;

[01:48] <camelia> rakudo-moar ce2631: OUTPUTÂ«14â¤Â»

[01:48] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say first { encode(10 ** $_).chars <= $_ }, ^20;

[01:48] <camelia> rakudo-moar ce2631: OUTPUTÂ«12â¤Â»

[01:49] <BenGoldberg> So, encoding(10**12) has a length of 12.

[01:49] <grondilu> that's pretty big

[01:49] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(10); 'b' ~ encode($n.chars-1) ~ $n }; say first { encode(10 ** $_).chars <= $_ }, ^40;

[01:49] <camelia> rakudo-moar ce2631: OUTPUTÂ«Nilâ¤Â»

[01:49] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(10); 'b' ~ encode($n.chars-1) ~ $n }; say first { encode(10 ** $_).chars <= $_ }, ^100;

[01:49] <camelia> rakudo-moar ce2631: OUTPUTÂ«Nilâ¤Â»

[01:50] <grondilu> I guess I'll go with *.fmt("0x%x") then

[01:50] *** nbrown__ left
[01:51] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say map { encode(10 ** $_).chars <= $_ }, 12..13;

[01:51] <camelia> rakudo-moar ce2631: OUTPUTÂ«True Trueâ¤Â»

[01:51] <BenGoldberg> m: sub encode($n is copy) { return 'a' unless $n; $n = $n.base(36); 'b' ~ encode($n.chars-1) ~ $n }; say map { encode(10 ** $_) }, 12..13;

[01:51] <camelia> rakudo-moar ce2631: OUTPUTÂ«bba7CRE66I9S bba83JLXPT2PSâ¤Â»

[01:52] <BenGoldberg> Hmm... all of the 'overhead' is right at the front.  Maybe we can encode it!

[01:53] <colomon> timotimo: oooh!  moar_jit is rakudobrew config

[01:54] <colomon> recent addition.  :)

[02:24] *** kyun joined
[02:30] <kyun> NMAKE : fatal error U1077: â€œC:\ProgramData\Oracle\Java\javapath\java.EXEâ€: return codeâ€œ0x1â€

[02:30] <kyun> Oh, I build jvm backend faild

[02:34] <colomon> timotimo: https://gist.github.com/colomon/8e89203b8dd97b88cf56#comment-1290523

[02:35] *** noganex joined
[02:38] *** noganex_ left
[02:45] *** MilkmanDan left
[02:49] *** MilkmanDan joined
[03:01] *** kyun_ joined
[03:03] *** kyun left
[03:03] *** kyun_ is now known as kyun

[03:03] *** mberends left
[03:12] *** mberends joined
[03:14] *** pochi_ joined
[03:20] *** tphilipp joined
[03:20] *** tphilipp left
[03:20] *** rindolf joined
[03:26] *** salv0 left
[03:27] *** salv0 joined
[03:50] *** xenoterracide left
[03:59] *** raiph left
[04:00] *** mr-foobar joined
[04:00] *** rindolf left
[04:01] *** rindolf joined
[04:04] *** kaare_ joined
[04:06] *** Jry left
[04:09] *** xenoterracide joined
[04:10] *** [Sno] left
[04:21] *** tphilipp joined
[04:24] *** tphilipp left
[04:26] *** xenoterracide left
[04:27] *** anaeem1 joined
[04:32] *** xenoterracide joined
[04:37] *** tphilipp joined
[04:37] *** tphilipp left
[04:39] *** tphilipp joined
[04:39] *** tphilipp left
[04:40] *** tphilipp joined
[04:40] *** tphilipp left
[04:40] *** tphilipp joined
[04:41] *** tphilipp left
[04:41] *** rindolf left
[04:41] *** tphilipp joined
[04:41] *** rindolf joined
[04:41] *** tphilipp left
[04:48] *** Jry joined
[04:54] *** jack_rabbit joined
[04:55] *** hagiri joined
[04:55] <hagiri> hi all

[04:56] <hagiri> ;)

[04:56] *** kaare_ left
[04:57] *** BenGoldberg left
[04:57] <jack_rabbit> ,r my $v=0;loop ($i=0;$i+12 < @nums.elems;$i++){my $w=[*] @nums[$i..($i+12)];if ($w > $v) {$v = $w;}};say $v;

[04:58] <jack_rabbit> r: my $v=0;loop ($i=0;$i+12 < @nums.elems;$i++){my $w=[*] @nums[$i..($i+12)];if ($w > $v) {$v = $w;}};say $v;

[04:58] <camelia> rakudo-jvm 54cd8f: OUTPUTÂ«(timeout)Â»

[04:58] <camelia> ..rakudo-{parrot,moar} 54cd8f: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfileâ¤Variable '$i' is not declaredâ¤at /tmp/tmpfile:1â¤------> [32mmy $v=0;loop ($i[33mâ[31m=0;$i+12 < @nums.elems;$i++){my $w=[*] @[0mâ¤    expecting any of:â¤        postfiâ€¦Â»

[04:58] <jack_rabbit> r: my $v=0;loop (my $i=0;$i+12 < @nums.elems;$i++){my $w=[*] @nums[$i..($i+12)];if ($w > $v) {$v = $w;}};say $v;

[04:58] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfileâ¤Variable '@nums' is not declaredâ¤at /tmp/tmpfile:1â¤------> [32my $v=0;loop (my $i=0;$i+12 < @nums.elems[33mâ[31m;$i++){my $w=[*] @nums[$i..($i+12)];if ([0mâ¤    expâ€¦Â»

[04:59] <jack_rabbit> r: my @nums = [1..1000]; my $v=0;loop (my $i=0;$i+12 < @nums.elems;$i++){my $w=[*] @nums[$i..($i+12)];if ($w > $v) {$v = $w;}};say $v;

[04:59] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: OUTPUTÂ«0â¤Â»

[04:59] <jack_rabbit> r: my @nums = 1..1000; my $v=0;loop (my $i=0;$i+12 < @nums.elems;$i++){my $w=[*] @nums[$i..($i+12)];if ($w > $v) {$v = $w;}};say $v;

[04:59] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: OUTPUTÂ«(timeout)Â»

[05:00] *** xenoterracide left
[05:02] <jack_rabbit> Is there a reason the comparison operators need spaces on either side of them?

[05:04] <jack_rabbit> well.. I guess only sometimes?

[05:04] <jack_rabbit> Is this a bug?

[05:04] <jack_rabbit> r: my @nums = 1..50; my $v=0;loop (my $i=0;$i+12 < @nums.elems;$i++){my $w=[*] @nums[$i..($i+12)];if ($w>$v) {$v=$w;}};say $v;

[05:04] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: OUTPUTÂ«2209723830420986880000â¤Â»

[05:05] <jack_rabbit> is fine, but

[05:05] <jack_rabbit> r: my @nums = 1..50; my $v=0;loop (my $i=0;$i+12<@nums.elems;$i++){my $w=[*] @nums[$i..($i+12)];if ($w>$v) {$v=$w;}};say $v;

[05:05] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfileâ¤Missing blockâ¤at /tmp/tmpfile:1â¤------> [32m++){my $w=[*] @nums[$i..($i+12)];if ($w>[33mâ[31m$v) {$v=$w;}};say $v;[0mâ¤    expecting any of:â¤        postfixâ¤   â€¦Â»

[05:05] <jack_rabbit> is an error.

[05:07] *** hagiri left
[05:09] <TimToady> %foo<bar> is the postfix notation for a literal key, so less-than requires a space

[05:09] *** rindolf left
[05:09] *** rindolf joined
[05:10] <TimToady> Perl 6 is not optimized for golf

[05:13] <TimToady> though when you think about it, real golf is not optimized for golf either...

[05:13] *** Zikomos joined
[05:14] <TimToady> you can't use your putter to get from a term to an infix, you need a longer club :)

[05:14] <moritz> and much space on either side of the club :-)

[05:15] <jack_rabbit> Makes sense. I was just curious.

[05:15] *** ecocode_ joined
[05:18] *** rindolf left
[05:18] *** rindolf joined
[05:25] *** kaare_ joined
[05:29] *** telex left
[05:30] <jack_rabbit> so, there's no way I can tell to assign an infinite list to an array variable. Someone suggested a sub that returns the list.

[05:30] <jack_rabbit> But with this: sub rnd {(rand * 2).Int} ... *)};

[05:30] <jack_rabbit> rnd[0] varies.

[05:30] *** telex joined
[05:30] <jack_rabbit> Is there some way to "memoize" this?

[05:31] *** Zikomos left
[05:31] *** rindolf left
[05:31] *** rindolf joined
[05:34] <jack_rabbit> this, rather: sub rnd {{(rand * 2).Int} ... *};

[05:36] <moritz> m: my @rand := (rand * 2) xx *; say @rand[^5] for ^2

[05:36] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«1.00679510450107 1.94302298007086 1.43152089303529 0.375055139916747 0.156311243017144â¤1.00679510450107 1.94302298007086 1.43152089303529 0.375055139916747 0.156311243017144â¤Â»

[05:36] *** [Sno] joined
[05:36] <moritz> jack_rabbit: like this?

[05:37] <moritz> an array variable is exactly right for memoizing this

[05:37] <moritz> and, if you can't assign, use binding (:=)

[05:38] <jack_rabbit> hmm. the interpreter just spins like it's trying to realize the entire list.

[05:39] <jack_rabbit> only if there are no statements following the assignment, though.

[05:40] <jack_rabbit> your example works fine.

[05:44] <jack_rabbit> Is there a way to do the assignment without a follow-up statement in the interpreter?

[05:53] *** rindolf left
[05:53] *** rindolf joined
[05:56] *** _thou left
[06:01] *** rindolf left
[06:01] *** rindolf joined
[06:02] *** SamuraiJack joined
[06:12] *** rindolf left
[06:12] *** flussence joined
[06:12] *** rindolf joined
[06:13] *** isacloud____ joined
[06:18] *** mberends left
[06:19] *** kyun_ joined
[06:21] *** kyun_ is now known as kyunsiu

[06:21] *** itz left
[06:21] *** kyun left
[06:21] *** kyunsiu is now known as kyun

[06:22] *** gfldex left
[06:23] *** itz joined
[06:27] *** mj41 joined
[06:28] *** itz_ joined
[06:30] *** itz left
[06:32] *** Vlavv left
[06:36] *** virtualsue joined
[06:45] *** itz joined
[06:46] <sergot> o/

[06:49] *** itz_ left
[06:52] *** kyun_ joined
[06:52] *** kyun left
[06:54] <sergot> m: say 1[1]

[06:54] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/L2iPiNIiD9:1â¤â¤use of uninitialized value of type Nil in string context  in block <unit> at /tmp/L2iPiNIiD9:1â¤â¤Error while creating error string: No exception handler â€¦Â»

[06:54] *** _thou joined
[06:54] *** virtualsue left
[06:55] <sergot> m: say 1;

[06:55] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«1â¤Â»

[06:56] *** kyun_ is now known as kyun

[06:58] *** _thou left
[06:59] *** kurahaupo_ left
[07:01] <sergot> m: <a a a b b c>.Set.say

[07:01] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«set(a, b, c)â¤Â»

[07:03] <sergot> m: <a a a b b c>.Set.fmt('%s').say

[07:03] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«aâ¤bâ¤câ¤Â»

[07:03] <sergot> m: <a b c>.fmt('%s').say

[07:03] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«a b câ¤Â»

[07:12] *** FROGGS_ is now known as FROGGS

[07:17] <sergot> TimToady: could you give us the answer here: https://rt.perl.org/Public/Bug/Display.html?id=121947 ? will be great :)

[07:18] *** kurahaupo joined
[07:30] *** rindolf left
[07:30] *** rindolf joined
[07:33] *** virtualsue joined
[07:45] *** donaldh joined
[07:51] *** domidumont joined
[07:54] *** darutoko joined
[08:04] *** rindolf left
[08:04] *** rindolf joined
[08:09] *** zakharyas joined
[08:13] *** Ven joined
[08:23] *** fhelmberger joined
[08:29] *** skarn joined
[08:31] *** virtualsue left
[08:35] *** dakkar joined
[08:36] *** tomaw- joined
[08:40] *** SamuraiJack left
[08:42] *** _thou joined
[08:47] *** _thou left
[08:51] *** JimmyZ joined
[08:51] <JimmyZ> http://planeteria.org/perl6/ is for sale ...

[08:52] <moritz> oh noez

[08:59] *** Jry left
[09:03] *** virtualsue joined
[09:07] *** JimmyZ left
[09:10] *** virtualsue left
[09:16] *** Ven left
[09:16] *** donaldh left
[09:16] *** salv0 left
[09:16] *** araujo left
[09:16] *** xinming left
[09:16] *** zoosha left
[09:16] *** pmichaud left
[09:17] *** Ven joined
[09:17] *** donaldh joined
[09:17] *** salv0 joined
[09:17] *** araujo joined
[09:17] *** xinming joined
[09:17] *** zoosha joined
[09:17] *** pmichaud joined
[09:17] *** Pleiades` joined
[09:17] *** thilp_ joined
[09:17] *** tadzik joined
[09:17] *** pochi_ left
[09:17] *** Possum left
[09:17] *** _sri left
[09:17] *** moritz left
[09:17] *** sjohnson left
[09:19] *** rindolf left
[09:19] *** rindolf joined
[09:22] *** pochi joined
[09:23] *** moritz joined
[09:23] *** Possum joined
[09:27] *** Exodist joined
[09:27] *** stux|RC-only joined
[09:30] *** _sri joined
[09:30] *** yeltzooo joined
[09:30] *** silug joined
[09:30] *** \00 joined
[09:30] *** ingy joined
[09:30] *** sjohnson joined
[09:34] *** pecastro joined
[09:38] *** nebuchad` joined
[09:46] *** lizmat_ joined
[09:47] *** fling joined
[09:47] *** Gruber joined
[09:47] *** bonsaikitten joined
[09:47] *** Juerd_ joined
[09:48] *** oetiker_ joined
[09:48] *** eviltwin_b joined
[09:49] *** nhayashi joined
[09:50] *** geekosaur left
[09:50] *** Grrrr left
[09:50] *** eviltwin_b is now known as geekosaur

[09:50] *** Juerd_ is now known as Juerd

[09:51] *** jnthn left
[09:51] *** jnthn joined
[09:51] *** Ven left
[10:11] *** ilogger2 joined
[10:11] *** ChanServ sets mode: +v ilogger2

[10:12] *** ivan`` joined
[10:15] *** aborazmeh joined
[10:20] *** virtualsue joined
[10:23] *** colomon_ joined
[10:24] *** anaeem___ joined
[10:25] *** psch joined
[10:26] *** jnthn_ joined
[10:26] *** japhb_ joined
[10:27] *** rindolf joined
[10:29] *** nbrown__ joined
[10:30] *** _thou joined
[10:33] *** ClarusCogitatio_ joined
[10:34] *** colomon_ is now known as colomon

[10:35] *** donaldh joined
[10:35] *** _thou left
[10:38] *** Ven joined
[10:38] <donaldh> .tell jnthn NQPMatch objects are getting through add_inlining_info_if_possible in QAST::Want objects

[10:38] <yoleaux> donaldh: I'll pass your message to jnthn.

[10:39] <lizmat_> r: $

[10:39] <donaldh> .tell jnthn this is an odd one - https://gist.github.com/donaldh/f5502df973ec2b41a9c2 fixes it, but why?

[10:39] <yoleaux> donaldh: I'll pass your message to jnthn.

[10:39] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: ( no output )

[10:40] <moritz> donaldh: is this about what keeps the parse tree alive / in memory?

[10:40] <lizmat_> std: $

[10:40] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:00 121mâ¤Â»

[10:40] *** virtualsue left
[10:41] <donaldh> moritz: causes matches and the CORE.setting text to get serialized into the compiled setting.

[10:41] <lizmat_> there are spectests for bare sigils that are supposed to fail with "anonymous $sigil variable outside of declaration"

[10:41] <lizmat_> judging from std, this test seems faulty rather than the code

[10:41] <moritz> lizmat_: then it seems those are outdated

[10:42] <lizmat_> well, it's just that they started failing after my latest pull

[10:42] <lizmat_> Ah, I see TimToady is busy with 54cd8fb6d9f43e147c06665f357ccccfb6f749cb

[10:42] * lizmat_ fixed the tests

[10:43] <moritz> TimToady++ # getting rid if "Non-declarative sigil is missing its name"

[10:44] <moritz> it always took me a minute to understand what that meant

[10:45] <dalek> roast: 60951ad | (Elizabeth Mattijsen)++ | S03-operators/context.t:

[10:45] <dalek> roast: Fix tests now that bare sigils are ok

[10:45] <dalek> roast: review: https://github.com/perl6/roast/commit/60951ad292

[10:47] <moritz> hoelzro: re "Include the offending variable name in uninitialized warning", commit 5f583edc15d779d2b200ca2850abca889107cc32: -- I intentially removed that, because it reported wrong variable names too often

[10:48] <moritz> hoelzro: like vars from the setting, which are of no interest to the user

[10:50] *** mattp___ joined
[10:50] *** immortal joined
[10:50] *** rindolf left
[10:51] *** Tene_ joined
[10:51] *** smash_ joined
[10:51] *** brother| joined
[10:51] *** btyler_ joined
[10:51] *** cxreg joined
[10:51] *** rindolf joined
[10:51] *** anocelot joined
[10:51] *** revdiablo joined
[10:51] *** hoelzro_ joined
[10:51] *** sergot_ joined
[10:51] *** jnthn joined
[10:51] <lizmat> std: $@

[10:51] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:01 121mâ¤Â»

[10:52] <moritz> m: $@

[10:52] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«===SORRY!===â¤Unknown QAST node type NQPMuâ¤Â»

[10:52] <moritz> that's LTA

[10:53] * masak submits rakudobug

[10:53] <lizmat> m: sub f { f(|$) }

[10:53] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«===SORRY!===â¤Cannot find method 'returns'â¤Â»

[10:53] <lizmat> std: sub f { f(|$) }

[10:53] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:01 125mâ¤Â»

[10:53] <moritz> TimToady: ^^ return self if $name eq '$' || $name eq '@' || $name eq '%' || $name eq '&';  this probably leaves $/.ast undefined/NQPMu

[10:55] <moritz> hoelzro: perl6/doc htmlify.p6 spits out many "use of uninitialized value of type Nil in string context  in any enter at src/gen/m-Metamodel.nqp:3080" warnings; do you know where those come from?

[10:55] *** betterwo1ld left
[10:55] *** Tene left
[10:55] *** anocelot_ left
[10:55] *** jnthn_ left
[10:55] *** sergot left
[10:56] <masak> moritz: it's a recent change in rakudo.

[10:56] <masak> m: say ~Nil

[10:56] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/A16vG05IMp:1â¤â¤â¤Â»

[10:56] <masak> things like this are probably the culprit:

[10:56] <masak> m: say ~(42 if 0)

[10:56] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/JKr1gM4VQY:1â¤â¤â¤Â»

[10:56] *** Celelibi joined
[10:56] <lizmat> std: "$"

[10:56] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:01 122mâ¤Â»

[10:56] <lizmat> m: "$"

[10:57] <camelia> rakudo-moar 54cd8f: ( no output )

[10:57] <masak> moritz: TimToady ruminated over them in the backlog, that `if` is a tricky one here -- whether it should give back () or Nil

[10:57] *** betterworld joined
[10:57] *** rindolf left
[10:58] *** rindolf joined
[10:58] <dalek> roast: 40c5a41 | (Elizabeth Mattijsen)++ | S32-exceptions/misc.t:

[10:58] <dalek> roast: More test fixups after TimToady++'s work

[10:58] <dalek> roast: review: https://github.com/perl6/roast/commit/40c5a4199a

[11:00] *** nbrown__ left
[11:02] *** mj41 joined
[11:02] *** dakkar joined
[11:03] *** JTABCU5B joined
[11:03] *** Celelibi left
[11:03] *** dg joined
[11:03] *** timotimo joined
[11:04] *** Celelibi joined
[11:07] <lizmat> r: my @a=({:a<1>}, {:b<1>}, {:a<1>}); my $with = &[evq]; @a .= uniq(:$with)); say @a

[11:07] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«===SORRY!===â¤Cannot find method 'returns'â¤Â»

[11:07] <camelia> ..rakudo-{parrot,jvm} 54cd8f: OUTPUTÂ«===SORRY!===â¤No such method 'returns' for invocant of type 'NQPMu'â¤Â»

[11:07] <lizmat> this seems to segfault in some situations during spectesting

[11:08] * lizmat is investigating

[11:09] <FROGGS> evq?

[11:09] <nwc10> lizmat: it might well be http://irclog.perlgeek.de/moarvm/2014-08-29#i_9262222

[11:09] <FROGGS> r: my @a=({:a<1>}, {:b<1>}, {:a<1>}); my $with = &[eqv]; @a .= uniq(:$with)); say @a

[11:09] <lizmat> src/Perl6/Actions.nqp:6940

[11:09] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfileâ¤Unexpected closing bracketâ¤at /tmp/tmpfile:1â¤------> [32m); my $with = &[eqv]; @a .= uniq(:$with)[33mâ[31m); say @a[0mâ¤Â»

[11:09] <FROGGS> r: my @a=({:a<1>}, {:b<1>}, {:a<1>}); my $with = &[eqv]; @a .= uniq(:$with); say @a

[11:10] <camelia> rakudo-{parrot,jvm,moar} 54cd8f: OUTPUTÂ«{"a" => "1"} {"b" => "1"}â¤Â»

[11:10] *** vike left
[11:11] <lizmat> FROGGS: what is the diff ?

[11:11] <FROGGS> s/evq/eqv/ and s/))/)/

[11:11] <masak> m: say (1, 2, 3) ~~ (1, 2, Int)

[11:11] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«Falseâ¤Â»

[11:11] <masak> why doesn't the above match?

[11:11] <lizmat> aha!

[11:11] *** Ven left
[11:11] <masak> or rather, what happens in that match?

[11:11] <FROGGS> m: &[baz]

[11:11] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«===SORRY!===â¤Cannot find method 'returns'â¤Â»

[11:12] <FROGGS> LTA

[11:12] * masak submits rakudobug

[11:12] <FROGGS> masak++

[11:13] <masak> I reiterate my question, though: why doesn't `(1, 2, 3) ~~ (1, 2, Int)` match?

[11:13] <masak> :)

[11:13] <FROGGS> m: say (1, 2, 3) ~~ (1, 2, 3) # doesnt it only call Accepts on the list?

[11:13] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«Trueâ¤Â»

[11:13] <lizmat> m: say &[evq].WHAT

[11:13] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«===SORRY!===â¤Cannot find method 'returns'â¤Â»

[11:13] <lizmat> that's the root of the problem, I would think

[11:15] <FROGGS> m: say (1, 2, 3) Â»~~Â« (1, 2, Int) # masak: you meant that?

[11:15] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«True True Trueâ¤Â»

[11:15] <masak> FROGGS: well, you can do that and it works.

[11:15] *** vike joined
[11:16] <masak> FROGGS: but I'm more wondering why ~~ on the whole parcel doesn't DWIM and smartmatch 3 against Int.

[11:16] <lizmat> hmmm....  it;s just another LTA error message, the failing test code has eqv, not evq  :-(

[11:16] <FROGGS> that feels weird...

[11:18] *** telex joined
[11:18] *** brother| is now known as brother

[11:18] *** rindolf left
[11:19] *** cognome_ joined
[11:19] *** rindolf joined
[11:20] <masak> or rather, since `(1, 2, 3) ~~ (1, 2, Int)` is False but `3 ~~ Int` is True, what kind of matching does happen, element-wise?

[11:20] <masak> m: say (1, 2, (3, 4)) ~~ (1, 2, (3, 4))

[11:20] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«Falseâ¤Â»

[11:20] <masak> o.O

[11:20] <FROGGS> hmmm

[11:21] <masak> clearly my intuition about this is way off.

[11:21] <FROGGS> rakudo/src/core/Parcel.pm:11:    multi method ACCEPTS(Parcel:D: $topic) { self.list.ACCEPTS($topic) }

[11:21] *** Alina-malina joined
[11:21] *** synopsebot joined
[11:21] *** avuserow_ joined
[11:22] <FROGGS> m: say (1, 2, 3) ~~ (1, 2, *)

[11:22] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«Trueâ¤Â»

[11:22] *** apejens joined
[11:22] <FROGGS> masak: it checks using === on the elems

[11:22] *** Woodi joined
[11:22] *** Ulti joined
[11:24] <masak> m: say (3, 4) === (3, 4)

[11:24] <camelia> rakudo-moar 54cd8f: OUTPUTÂ«Falseâ¤Â»

[11:24] *** lestrrat joined
[11:24] <masak> FROGGS: that's just sad.

[11:25] <masak> I vote for === being changed to ~~ for the elements.

[11:25] <dalek> roast: d755436 | (Elizabeth Mattijsen)++ | S32-exceptions/misc.t:

[11:25] <dalek> roast: Add RT number

[11:25] <dalek> roast: review: https://github.com/perl6/roast/commit/d75543609b

[11:25] <masak> furthermore, I vote for the abolition of *, which is seldom used and mostly muddling up the semantics of list/parcel matching.

[11:25] <masak> it has no "model integrity".

[11:25] <FROGGS> masak: I am already spectesting that

[11:25] <masak> and it's more-than-subsumed by the awesome matching powers of signatures.

[11:26] *** oetiker joined
[11:27] <jnthn> masak++ # reporting the issue that bit me today :)

[11:27] <yoleaux> 28 Aug 2014 16:00Z <japhb> jnthn: When you're awake again, can you look at https://gist.github.com/japhb/a452a0a8dd7bd5682e1c ?  I'm concerned by *both* the weird NPE when threading, but also the fact that having threads <= items causes apparent lockup.  I would think the tasks would just share threads in the pool in the normal fashion, making for slow results, but no lock.

[11:27] <yoleaux> 28 Aug 2014 22:46Z <flussence> jnthn: Is this a bug, or am I grossly misunderstanding how S17 works? http://irclog.perlgeek.de/perl6/2014-08-28#i_9260839

[11:27] <yoleaux> 10:38Z <donaldh> jnthn: NQPMatch objects are getting through add_inlining_info_if_possible in QAST::Want objects

[11:27] <yoleaux> 10:39Z <donaldh> jnthn: this is an odd one - https://gist.github.com/donaldh/f5502df973ec2b41a9c2 fixes it, but why?

[11:27] <dalek> roast: 23abe1b | (Elizabeth Mattijsen)++ | S32-list/uniq.t:

[11:27] <dalek> roast: Mark test as skip because of segfault

[11:27] <dalek> roast: review: https://github.com/perl6/roast/commit/23abe1bb7f

[11:27] <jnthn> omfg, that's a lot of messages

[11:27] *** bowtie joined
[11:27] *** mhasch joined
[11:27] *** bowtie is now known as Guest36225

[11:27] <nwc10> jnthn: there's also a few nopastes from me in #moarvm

[11:28] <jnthn> Yeah, noticed...

[11:28] <jnthn> That channel is rather easier to backlog :)

[11:28] *** Ulti_ joined
[11:28] *** [Coke]_ joined
[11:29] *** carlin joined
[11:29] *** arnsholt_ joined
[11:29] *** diakopte1 joined
[11:30] *** apejens_ joined
[11:30] *** perlpilot joined
[11:30] *** Ulti left
[11:30] *** apejens left
[11:31] <timotimo> o/

[11:33] <colomon> timotimo: I got some JIT timings for you last night.

[11:33] <colomon> https://gist.github.com/colomon/8e89203b8dd97b88cf56#comment-1290523

[11:35] <colomon> also, channel in general: I figured out that what's been blocking smoke testing for the last few days are hangs in Test-ClientServer and Chess

[11:35] <colomon> I got a successful run last night

[11:35] *** dayangkun joined
[11:35] <FROGGS> ohh!

[11:35] <colomon> by killing those tests manually

[11:35] <FROGGS> do tell

[11:35] <FROGGS> ahh

[11:35] <colomon> 02-simple-socket.t hangs in the former

[11:36] <colomon> pgn.t in the latter

[11:36] <dalek> roast: 2b3a12a | (Elizabeth Mattijsen)++ | S32-exceptions/misc.t:

[11:36] <dalek> roast: Add test for #122646

[11:36] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122646

[11:36] <dalek> roast: review: https://github.com/perl6/roast/commit/2b3a12a65a

[11:36] *** BenGoldberg joined
[11:38] <FROGGS> masak: that's the spectest using ~~: https://gist.github.com/FROGGS/80b086660badcf365e5a

[11:38] <FROGGS> running a unmodified now

[11:40] <FROGGS> colomon: btw, v5 should be build- and testable now

[11:41] <masak> FROGGS: only the first and maybe the last two look relevant, methinks.

[11:41] <FROGGS> masak: I think the same

[11:41] <colomon> FROGGS: do tests fail in v5 at the moment?

[11:42] <FROGGS> colomon: it will just run sanity tests, so it should pass

[11:42] <masak> food &

[11:42] <colomon> hmm, they failed in the smoke run last night.

[11:42] <FROGGS> colomon: because it did not use Build.pm, but it should now

[11:42] <colomon> oh, very recent change, eh?

[11:43] <FROGGS> colomon: 5 minutes :o)

[11:43] <colomon> FROGGS++

[11:43] *** cotto joined
[11:43] <jnthn> dinner &

[11:43] *** epochbell joined
[11:45] *** SHODAN joined
[11:46] *** zacts joined
[11:47] <colomon> smoke test done: http://host07.perl6.com:8080/report

[11:48] <colomon> there's an extra batch of build failures there that didn't happen ten hours ago.  :\

[11:48] *** rindolf left
[11:48] *** rindolf joined
[11:51] <nwc10> jnthn: current --profile-comile http://ccl4.org/~nick/profile-1409312777.79459.html.gz

[11:51] <nwc10> (or without .gz if your connection is fine with about 4M

[11:54] <FROGGS> masak: only t/spec/integration/advent2010-day12.t fails due to the change

[11:55] <FROGGS> masak: fails with: Cannot convert string to number: base-10 number must begin with valid digits or '.' in 'âbar' (indicated by â)

[11:55] <dalek> rakudo/nom: b6b3f55 | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[11:55] <dalek> rakudo/nom: A bare 'say' is now an exception

[11:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6b3f55af1

[11:55] <FROGGS> lizmat++ # ohh nice!

[11:55] <dalek> roast: fd376fc | (Elizabeth Mattijsen)++ | S32-exceptions/misc.t:

[11:55] <dalek> roast: Add test for bare say exception

[11:55] <dalek> roast: review: https://github.com/perl6/roast/commit/fd376fc2e4

[11:56] <lizmat> it's runtime, not compile time yet

[11:56] <lizmat> late lunch&

[11:58] <hoelzro_> moritz: I have a fix for the ~Nil problem; I'm just going to test it real quick

[12:00] *** hoelzro_ is now known as hoelzro

[12:06] <hoelzro> ok, my patch fixes perl6/doc

[12:06] <hoelzro> waiting for spectest

[12:07] *** kaleem joined
[12:11] *** mattp_ joined
[12:13] *** Ben_Goldberg joined
[12:13] *** BenGoldberg left
[12:13] *** Ben_Goldberg is now known as BenGoldberg

[12:13] *** mattp___ left
[12:14] *** smash_ left
[12:15] *** xinming joined
[12:18] *** dayangkun left
[12:18] *** arnsholt_ left
[12:19] *** arnsholt joined
[12:20] *** BizarreCake joined
[12:23] <moritz> hoelzro: but why does it try to stringify Nil? did it do that before the S17 merge too?

[12:23] *** smash joined
[12:24] *** xenoterracide joined
[12:24] <hoelzro> it's because Mu.Stringy used to unconditionally call .Str

[12:24] <hoelzro> I changed it yesterday so it doesn't, but I have a fix I'm testing right now for that

[12:25] *** araujo joined
[12:26] *** dayangkun joined
[12:28] *** rindolf left
[12:29] *** rindolf joined
[12:32] *** kaleem left
[12:39] *** xenoterracide left
[12:42] <moritz> hoelzro: then my real question is, is it new that htmlify calls Nil.Stringy?

[12:42] <hoelzro> moritz: if you interpolate Nil into a string, it calls Stringy

[12:42] <hoelzro> it probably happens somewhere!

[12:42] <moritz> hoelzro: let me rephrase

[12:42] <moritz> hoelzro: htmlify makes quite some assumptions regarding the generated Pod tree

[12:43] <moritz> hoelzro: and I don't want any regressions due to changed parsing or Pod tree to go unnoticed

[12:43] <moritz> hoelzro: so I wonder if these Nil interpolations point to some new, deeper problem, or if they existed before, and were silent

[12:43] <hoelzro> ah ha

[12:44] <moritz> hoelzro: did you diff the output before and after the merge, for example?

[12:44] <hoelzro> I did not

[12:44] <moritz> s/output/generated files/

[12:44] <hoelzro> I can do that later today

[12:44] <moritz> that would be cool

[12:44] <moritz> also I noticed that it became much slower

[12:44] <moritz> it ran in 41m18s today

[12:44] <moritz> I remember more like 15 to 20m

[12:44] <hoelzro> wow

[12:45] <hoelzro> I'll test timing too

[12:45] <moritz> not sure if that's due to the many new wornings, or something else

[12:45] <hoelzro> I just ran it 45 minutes ago or so; it definitely didn't take 40 minutes

[12:49] *** Ulti_ is now known as Ulti

[12:53] <hoelzro> ok, my fix for the Stringy stuff is clean

[12:54] <dalek> rakudo/nom: 7c8a4a7 | (Rob Hoelz)++ | src/Perl6/Grammar.nqp:

[12:54] <dalek> rakudo/nom: Fix problems with incomplete POD

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7c8a4a7da3

[12:54] <dalek> rakudo/nom: 187d75c | (Rob Hoelz)++ | src/core/Mu.pm:

[12:54] <dalek> rakudo/nom: Still invoke $.Str from Stringy

[12:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/187d75cc0e

[12:54] <hoelzro> lizmat++ nice work on the bare say!

[12:56] <hoelzro> I'm seeing a bunch of warnings even before my S26 merge

[12:56] *** guru joined
[12:56] *** xfix joined
[12:56] *** anaeem___ left
[12:56] *** guru is now known as Guest99782

[12:57] *** anaeem1 joined
[12:57] *** Guest99782 is now known as ajr_

[12:57] *** anaeem1 left
[12:59] <moritz> hoelzro: isn't Mu.Stringy a relatively hot path?

[12:59] <moritz> I'm kinda worried about introducing a dynamic var there

[13:00] <moritz> m: my $x := Nil; '' ~ $x

[13:00] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/CWh1EV7PTJ:1â¤â¤Â»

[13:01] <hoelzro> hmm, you're probably right

[13:02] <hoelzro> the dynamic var is only created for undefined invocants, though, if that helps

[13:02] <FROGGS> that's what it was at the release: https://github.com/rakudo/rakudo/blob/5dd10bbc9f34a67e2751d49725a0bd05a37352c3/src/core/Mu.pm#L402

[13:04] <moritz> hoelzro: yes, might help

[13:07] <FROGGS> do we need the variable name in that warning at all?

[13:07] <FROGGS> I mean, this often led to leaking internal variable names

[13:10] *** perlpilot is now known as PerlJam

[13:12] <hoelzro> well, we don't *need* it

[13:13] <hoelzro> it's just a very nice-to-have, especially for people coming from Perl 5

[13:13] *** rindolf left
[13:13] *** rindolf joined
[13:14] <flussence> colomon: I've hacked around that Test-ClientServer/t/ hang for the time being, hope that helps.

[13:16] <BenGoldberg> m: my $a = 'abc'; $a R~= 'd'; say $a; # how do I make this produce 'abcd' ?

[13:16] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«Cannot modify an immutable Strâ¤  in block  at src/gen/m-CORE.setting:17800â¤  in block  at src/gen/m-CORE.setting:17812â¤  in block <unit> at /tmp/45fd9tO_tI:1â¤â¤Â»

[13:16] <flussence> (it's ironic that that problem's in a bit of code that exists entirely to *prevent* test lockups...)

[13:16] *** ivanshmakov left
[13:17] <BenGoldberg> m: my $a = 'abc'; $a [R~]= 'd'; say $a; # This doesn't work, either.

[13:17] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«Not enough positional parameters passed; got 0 but expected 2â¤  in block  at src/gen/m-CORE.setting:17812â¤  in block <unit> at /tmp/FFzbNQsN_Y:1â¤â¤Â»

[13:17] <FROGGS> m: my $a = 'abc'; 'd' R~= $a; say $a;

[13:17] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«abcdâ¤Â»

[13:17] <BenGoldberg> Oops, I mistated my goal: I want 'dabc'

[13:17] <FROGGS> BenGoldberg: you have to swap the operands when you use R

[13:17] <FROGGS> ohh

[13:18] <[Coke]_> m: say

[13:18] * BenGoldberg needs more coffe

[13:18] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«Unhandled exception: Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argumentâ¤   at <unknown>:1  (/home/p6eval/rakudo-inst-2/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)â¤ from srâ€¦Â»

[13:18] <[Coke]_> m: say()

[13:18] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«Unhandled exception: Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argumentâ¤   at <unknown>:1  (/home/p6eval/rakudo-inst-2/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)â¤ from srâ€¦Â»

[13:18] *** [Coke]_ is now known as [Coke]

[13:18] <PerlJam> BenGoldberg: my $a = "abc";  $a = "d$a";  #   :-)

[13:18] <[Coke]> std: say

[13:18] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/7LcH6qoC9G line 1:â¤------> [32msay[33mâ[31m<EOL>[0mâ¤Check failedâ¤FAILED 00:00 120mâ¤Â»

[13:18] <[Coke]> std: say()

[13:18] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:01 121mâ¤Â»

[13:18] <BenGoldberg> n: say()

[13:18] <camelia> niecza v24-109-g48a8de3: OUTPUTÂ«â¤Â»

[13:19] <FROGGS> BenGoldberg: I'm afraid, I think you have to do it the 'long' way

[13:19] <BenGoldberg> Oh well :)

[13:20] <BenGoldberg> m: sub encode($n is copy) { my $m = 0; my $rest = ''; while ($n) { $n = $n.base(10); ++$m; $rest = $n~$rest; $n = $n.chars-1; }; $m.base(36)~$rest; }; say [lt] map { encode($_) }, ^2000

[13:20] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«Trueâ¤Â»

[13:20] <BenGoldberg> grondilu, there's a solution for you ^ :)

[13:21] <PerlJam> m: my $a = 'abc';  $a=($a.flip ~ 'd').flip; say $a  # this is the *long* way :)

[13:21] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«dabcâ¤Â»

[13:22] <BenGoldberg> m: sub encode($n is copy) { my $m = 0; my $rest = ''; while ($n) { $n = $n.base(36); ++$m; $rest = $n~$rest; $n = $n.chars-1; }; $m.base(36)~$rest; }; say [lt] map { encode($_) }, ^2000

[13:22] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«Trueâ¤Â»

[13:22] <[Coke]> n: use Test; eval_dies_ok('say', 'what');

[13:22] <PerlJam> BenGoldberg: you can shorten $n = $n.base(10) to $n.=base(10);  That'll help mitigate those extra chars you had to use to prepend 

[13:22] <camelia> niecza v24-109-g48a8de3: OUTPUTÂ«ok 1 - whatâ¤Â»

[13:22] <[Coke]> M: use Test; eval_dies_ok('say', 'what');

[13:22] *** ivanshmakov joined
[13:22] <[Coke]> m: use Test; eval_dies_ok('say', 'what');

[13:22] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argumentâ¤  in sub eval_exception at lib/Test.pm:319â¤  in sub eval_dies_ok at lib/Test.pm:240â¤  in sub eval_dies_ok at lib/Test.pm:238â¤  in blocâ€¦Â»

[13:22] <BenGoldberg> m: sub encode($n is copy) { my $m = 0; my $rest = ''; while ($n) { $n = $n.base(36); ++$m; $rest = $n~$rest; $n = $n.chars-1; }; $m.base(36)~$rest; }; say map { encode($_) }, ^40;

[13:22] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«0 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 1G 1H 1I 1J 1K 1L 1M 1N 1O 1P 1Q 1R 1S 1T 1U 1V 1W 1X 1Y 1Z 2110 2111 2112 2113â¤Â»

[13:24] <BenGoldberg> m: sub encode($n is copy) { my $m = 0; my $rest = ''; while ($n) { $n = $n.base(36); ++$m; $rest = $n~$rest; $n = $n.chars-1; }; $m.base(36)~$rest; }; say map { encode($_).chars - $_.Str.chars }, ^100;

[13:24] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2â¤Â»

[13:25] <BenGoldberg> It is a nearly-universal numeric coding, whose outputs are at most 2 letters longer than ordinary base 10.

[13:26] *** gmunoz joined
[13:26] <BenGoldberg> And, unlike ordinary base 10, the results are in lexigraphical order :)

[13:26] *** gmunoz is now known as zoosha

[13:35] <hoelzro> moritz: I found no performance issues, but I did find a regression

[13:35] <hoelzro> the section links aren't being correctly generated

[13:36] <hoelzro> I have to start getting to work, but I'll check it out tonight

[13:37] <[Coke]> m: my $::x 

[13:37] *** rindolf left
[13:37] <camelia> rakudo-moar b6b3f5: ( no output )

[13:37] <[Coke]> m: my $::x = 3; say $::x;

[13:37] <camelia> rakudo-moar b6b3f5: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/B2xaa_Iy_oâ¤Variable '$x' is not declaredâ¤at /tmp/B2xaa_Iy_o:1â¤------> [32mmy $::x = 3; say $::x[33mâ[31m;[0mâ¤    expecting any of:â¤        postfixâ¤Â»

[13:37] *** rindolf joined
[13:40] <dalek> roast: 2759035 | (Elizabeth Mattijsen)++ | S32-exceptions/misc.t:

[13:40] <dalek> roast: TODO test for bare say being a compile time error

[13:40] <dalek> roast: review: https://github.com/perl6/roast/commit/2759035c36

[13:41] <[Coke]> m: say (3+4i).reals.fmt("%d %d")

[13:41] <camelia> rakudo-moar 187d75: OUTPUTÂ«No such method 'item' for invocant of type 'NQPMu'â¤  in method message at src/gen/m-CORE.setting:12938â¤â¤Â»

[13:41] <[Coke]> lizmat: see also S16-io/bare-say.t

[13:43] <lizmat> std: print

[13:43] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of bare 'print'; in Perl 6 please use .print if you meant $_, or use an explicit invocant or argument at /tmp/q3iLRLpKId line 1:â¤------> [32mprint[33mâ[31m<EOL>[0mâ¤Check failedâ¤FAILED 00:00 120mâ¤Â»

[13:43] <lizmat> std: print()

[13:43] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:00 121mâ¤Â»

[13:44] <lizmat> I'm not sure what one would mean by 'print()' that wouldn't warrant the same error

[13:44] <[Coke]> no clue, just reporting about the old ticket.

[13:46] <carlin> m: my $x = "foobar"; say $x.split

[13:46] <camelia> rakudo-moar 187d75: OUTPUTÂ«Cannot call 'split'; none of these signatures match:â¤:(Cool: Regex $pat, Any $limit = { ... }, Any :all($all), *%_)â¤:(Cool: Cool $pat, Any $limit = { ... }, Any :all($all), *%_)â¤:(Str:D: Regex $pat, Any $limit = { ... }, Any :all($all), *%_)â¤:(Str:â€¦Â»

[13:46] <carlin> m: my $x = "foobar"; say $x[2]

[13:46] <camelia> rakudo-moar 187d75: OUTPUTÂ«Index out of range. Is: 2, should be in 0..0â¤  in method gist at src/gen/m-CORE.setting:13255â¤  in sub say at src/gen/m-CORE.setting:14193â¤  in block <unit> at /tmp/0S0eb1ZMJF:1â¤â¤Â»

[13:54] <carlin> ah, my local rakudo was busted

[13:55] *** rindolf left
[13:55] *** rindolf joined
[13:57] <BenGoldberg> A bare say at least might be expected to produce a newline.  A bare print seems useless, unless we want to change the spec to it uses $_ like perl5.

[13:57] <[Coke]> m: my $x = "hi"; say $x[0];

[13:57] <camelia> rakudo-moar 187d75: OUTPUTÂ«hiâ¤Â»

[13:57] <lizmat> fwiw, a bare say in p5 prints a newline

[13:57] <timotimo> i would like for say; to generate a newline

[13:58] <lizmat> oops, no: in p5 it takes $_

[13:58] <lizmat> and that's what TimToady is against (for good reasons, I might add :-)

[13:58] <timotimo> yeah

[13:58] <lizmat> $ perl5.20.0 -E '$_=42; say'

[13:58] <lizmat> 42

[13:59] <timotimo> well, i'd also accept say doing the newline thing only if you "use idontcareaboutperl5"

[13:59] <huf> no v5; at the top?

[14:00] <timotimo> maybe like that, yeah

[14:02] <grondilu> m: sub f returns Int { 1/1 }; say f'  # shouldn't there be automatic promotion to Int?

[14:02] <camelia> rakudo-moar 187d75: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/O0w0DKeXjeâ¤Two terms in a rowâ¤at /tmp/O0w0DKeXje:1â¤------> [32msub f returns Int { 1/1 }; say f[33mâ[31m'  # shouldn't there be automatic promot[0mâ¤    expecting any of:â¤        arguâ€¦Â»

[14:02] <timotimo> m: try eval "say"; say $!.WHAT; say $!.perl;

[14:02] <camelia> rakudo-moar 187d75: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/RLWzU96VhOâ¤Undeclared routine:â¤    eval used at line 1â¤â¤Â»

[14:03] <timotimo> m: try EVAL "say"; say $!.WHAT; say $!.perl;

[14:03] <camelia> rakudo-moar 187d75: OUTPUTÂ«Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argumentâ¤  in block <unit> at /tmp/rvw2qgoPEO:1â¤â¤Â»

[14:03] <lizmat> timotimo [Coke]  : working on making it a compile time error

[14:03] <timotimo> ... huh?

[14:04] <lizmat> m: { try EVAL "say"; say $!.WHAT; say $!.perl; }

[14:04] <camelia> rakudo-moar 187d75: OUTPUTÂ«Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argumentâ¤  in block <unit> at /tmp/h5PR5W9Fom:1â¤â¤Â»

[14:04] <lizmat> hmmm...

[14:04] <lizmat> m: { try EVAL "say"; say $!.WHAT; say $!.perl; }; 1

[14:04] <camelia> rakudo-moar 187d75: OUTPUTÂ«Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argumentâ¤  in block <unit> at /tmp/oNtKmX_AxD:1â¤â¤Â»

[14:04] <timotimo> i wasn't able to find where that error message is currently implemented

[14:04] <lizmat> atm, it is a say MMD candidate

[14:04] *** rindolf left
[14:05] *** rindolf joined
[14:06] *** _thou joined
[14:06] <dalek> rakudo/nom: 1450e3e | (Elizabeth Mattijsen)++ | src/core/IO.pm:

[14:06] <dalek> rakudo/nom: Remove bare say as a candidate

[14:06] <dalek> rakudo/nom: 

[14:06] <dalek> rakudo/nom: We need a more comprehensive approach

[14:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1450e3eb4c

[14:07] <timotimo> theoretically, you could have "no v5" implemented in pure perl6 by wrapping the multi sub say() candidate and just { print "\n" } instead

[14:08] <timotimo> if it's a compile-time error, that's going to be harder to "fix"

[14:08] <timotimo> oh well

[14:08] <timotimo> it's a step in the right direction.

[14:08] <timotimo> i'm all for errors exploding at compile time rather than at run time

[14:13] <lizmat> if say wouldn't have a 'say (|) candidate', the optimizer would already have been complaining at compile time

[14:13] <timotimo> ah

[14:14] <PerlJam> Seems to me you just add a "say" term (just like "now") that calls $*W.throw()

[14:14] <lizmat> PerlJam: but that would be a runtime error, no?

[14:14] <jnthn> Oh yay...I have a big bottle of Belgian in the fridge, the AC is cranked up, and I've no work to get up for in the morning. That makes for at lesat a couple of hours hacking time. :)

[14:15] <timotimo> yays, jnthn :)

[14:15] <timotimo> lizmat: $*W is a compile-time construct

[14:16] <nwc10> the great firewall of China doesn't stop beer getting in?

[14:16] <[Coke]> jnthn: good evening.

[14:17] <PerlJam> granted, there's probably some hidden difficulty behind my "just"  :)

[14:17] <jnthn> nwc10: No, just googl emaps requests getting in/out :)

[14:17] <jnthn> o/ [Coke], timotimo 

[14:17] <jnthn> I should probably backlog properly, but - why aren't we stealing precisely the STD solution for say? :)

[14:18] <[Coke]> I figure if it was easy, someone would have done it 4 years ago? ;)

[14:18] <jnthn> Ok, fine, I'll do it :P

[14:18] * jnthn looks at STD

[14:18] <timotimo> don't waste precious jnthn time for such little details :P

[14:19] <timotimo> jnthn: i'll have a look

[14:19] * lizmat wonders where jnthn looks at STD

[14:19] <jnthn> Well, this one comes up again and again, and I'd like to see it nails.

[14:19] <jnthn> std: say

[14:19] <PerlJam> ah, STD is more general too in that it fixes this for many things.

[14:19] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/ltWTMfGTPT line 1:â¤------> [32msay[33mâ[31m<EOL>[0mâ¤Check failedâ¤FAILED 00:01 120mâ¤Â»

[14:19] <TimToady> except, of course, that it just uses a list

[14:19] <TimToady> rather than having a trait

[14:19] <PerlJam> aye

[14:19] <jnthn> Ah, there...

[14:19] <TimToady> or a signature

[14:19] *** PotatoGim^Home joined
[14:20] *** PotatoGim^Home left
[14:20] <timotimo> ah, yeah, it has the %deftrap thing

[14:20] <timotimo> jnthn: OK, you can do it :P

[14:20] <jnthn> :P

[14:20] * PerlJam waits for the future to become slightly more distributed  ;)

[14:20] *** PotatoGim^Home joined
[14:21] * jnthn has also found a nice Indian restaurant here :)

[14:21] * lizmat wonders (again) where everybody looks at STD

[14:21] <nwc10> jnthn: that seems to happen to you surprisingly often

[14:21] <jnthn> lizmat: https://github.com/perl6/std/blob/master/STD.pm6

[14:21] <TimToady> jnthn: I'm this close to having anonymous rvalue variables working; they successfully declare a variable, but then lose track of it somewhere

[14:21] <timotimo> huh? i don't even know what "anonymous rvalue variables" is for :S

[14:21] <jnthn> nwc10: Well, it got to the point that eating Chinese/Korean noms each day was starting to overwhelm my stomach, so something more familiar to it is nice to find. :)

[14:22] <TimToady> so if I say: $; $ANON_VAR__1 = 42; say $ANON_VAR__1  then it prints 42

[14:22] <TimToady> but $ = 42 gets a NQPMu

[14:22] <jnthn> A NQPMu where, exactly?

[14:23] <TimToady> I don't know how to answer that, which is part of the problem :)

[14:23] *** aborazmeh left
[14:23] <jnthn> Does it leak into Perl 6 land?

[14:24] <jnthn> Or does it crop up during compilation?

[14:24] <jnthn> It may be easiest for me to look at a patch; working on the death trap first. :)

[14:25] <TimToady> m: $ = 42

[14:25] <camelia> rakudo-moar 187d75: OUTPUTÂ«===SORRY!===â¤Unknown QAST node type NQPMuâ¤Â»

[14:26] <TimToady> an older version, but shows the issue

[14:26] <nwc10> jnthn: it was more the "nice" part. You seem to have consistent good luck in finding reasonable Indians

[14:26] <timotimo> hm, so maybe it expects to build a QAST::Var somewhere, but if the name isn't set it doesn't end up assigning to the $var that would hold it

[14:26] <timotimo> and then it puts $var into the qast tree without checking?

[14:29] <jnthn> nwc10: Research. ;)

[14:29] <jnthn> nwc10: I've found the odd bad one, but online reviews are good for avoiding many of the sucky ones.

[14:30] <dalek> rakudo/nom: c711b1e | TimToady++ | src/Perl6/Actions.nqp:

[14:30] <dalek> rakudo/nom: latest version of rvalue $

[14:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c711b1e556

[14:30] <nwc10> do you have a co-worker who always seens to end up going to gigs where all the Indians are LTA, and he/she has no idea why that happens? :-)

[14:30] <jnthn> TimToady: That often means you incorporated something into the QAST tree that was undefined; most often due to .ast on something make wasn't called on :)

[14:31] <jnthn> nwc10: No, actually I have many co-workers who also like Indian noms, so we share tips :)

[14:31] <TimToady> but it's in the same path as a normal token variable, so it oughta return the ast the same way from there upward

[14:31] <jnthn> At one place we got it down to the level of "don't eat at X on a Monday 'cus the usual chef is off that day and it sucks, but any other day is wonderful" :)

[14:31] <nwc10> jnthn: so if everyone is busy, clients who are in places with good Indians seem to get priority for gigs? :-)

[14:32] *** mberends joined
[14:32] <nwc10> oh gosh

[14:32] <nwc10> mberends: MoarVM is fast!

[14:32] <TimToady> well, faster :)

[14:33] <nwc10> I suppose that's true too.

[14:33] <timotimo> nwc10: that seems like a response to something, but i don't see what it's in response to ... !?

[14:33] <nwc10> partly, that I've not seen mberends in ages

[14:34] <mberends> nwc10: yes! I'm currently at DebConf14 and one of my goals here is to become Debian Maintainer for MoarVM :-)

[14:34] <dalek> rakudo/nom: dd580df | (Elizabeth Mattijsen)++ | src/core/Exception.pm:

[14:34] <dalek> rakudo/nom: We don't need no bare exception either

[14:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dd580dfc92

[14:34] <nwc10> mberends: cool

[14:34] <nwc10> mberends: I don't know how many architectures it's currently portable to

[14:34] <lizmat> one of these days I hope to be able doing some commits that I don't need to revoke a few hours later

[14:35] <[Coke]> nwc10: nobody sees mberends.

[14:35] <nwc10> at one point it has worked on x86_64, x86, arm and ppc

[14:35] <PerlJam> lizmat++ I was just looking at that.   Apparently we already have X::TypeCheck::Argument which does that job already

[14:35] <mberends> nwc10: surely just amd64

[14:35] <[Coke]> you're just talking to yourself, it seems. :)

[14:35] <[Coke]> There he is! whew.

[14:35] <timotimo> the first bunch of yapceu talk recordings have been uploaded: https://www.youtube.com/user/yapceu/videos

[14:35] <timotimo> AFAICT no perl6-related videos yet

[14:35] <[Coke]> I even see him in backscroll a bit. weird! :)

[14:35] <[Coke]> hugme: hug mberends 

[14:35] * hugme hugs mberends

[14:36] <tadzik> mberends: it runs on my ARM phone just fine :)

[14:36] <nwc10> mberends: I fail to think of an actually funny response to that, so all I can think of is "isn't it heresy in debian to just think of x86_64?"

[14:36] * mberends hugs [Coke]

[14:36] <nwc10> the crazy bit was that ppc (big endian) was fairly easy, and ARM wasn't

[14:37] <nwc10> I don't have access to anything else useful, and haven't had time to check them recently.

[14:37] *** Alula_ joined
[14:37] <masak> mberends! \o/

[14:37] <masak> mberends: I've *missed* you! :D

[14:37] <mberends> tadzik: that's awesome, must try it on my Nexus 4

[14:37] <nine> moritz: I managed to write a failing test with only inline Perl 5: https://github.com/niner/Inline-Perl5/commit/de167995c90fe2cd2267ab699d50ca6a7895dcc4

[14:37] * mberends hugs masak extra hard :D

[14:37] <masak> FROGGS: t/spec/integration/advent2010-day12.t is the only file that fails? that's telling me we're onto something here.

[14:37] * masak feels extra hug'd :)

[14:38] <nwc10> mberends: getting moarvm on debian (and hence rakudo available on more-than-just-parrot) would be really $expletive useful.

[14:38] <tadzik> mberends: well, "just fine" is maybe a bit of an overstatement. It did run, but running nqp on top of it resulted in a mysterious sigpipe

[14:38] <japhb_> jnthn: re: the gist I sent you yesterday ... is it expected that if I create promises in a tree (starting tasks that themselves make promises), I need a fair amount of threads just to make any progress at all under r-j?

[14:38] *** japhb_ is now known as japhb

[14:38] <nwc10> mberends: please ask for help if stuck, although I can't promise that I can answer

[14:39] <mberends> nwc10: thanks, I make no promises about timescales either

[14:39] <masak> m: say "bar" ~~ (15..25)

[14:39] <camelia> rakudo-moar 187d75: OUTPUTÂ«Falseâ¤Â»

[14:39] <nwc10> mberends: so, in the big mushy window after "this week" but "before Christmas"? :-/

[14:39] <jnthn> japhb: If you use "await" a bunch it's not smart enough (anywhere) to give the thread back to the scheduler for the time being.

[14:39] <japhb> (anywhere) meaning "any back end"?

[14:40] <japhb> Also: ah, hmmm.

[14:40] <jnthn> japhb: That'll likely happen on MoarVM at some point in the not too distant future. On the JVM...continuation barrier stuff...mumble...argh...so yeah :)

[14:40] <japhb> heh

[14:40] *** rindolf left
[14:41] *** rindolf joined
[14:41] <jnthn> (I really want to do it on JVM too, it's just I tried it once, and know there's some work to do)

[14:41] <japhb> Is there a better construction for my "outer loops" than what I gist'ed?

[14:41] <japhb> (Meaning, one that doesn't trip over that problem?)

[14:42] *** donaldh left
[14:42] <lizmat> I'm considering adding an "abspath" attribute to IO::Handle

[14:43] <japhb> lizmat: as a cache, to avoid having to compute it if someone asks?

[14:43] <lizmat> which would contain the absolute path

[14:43] *** smash left
[14:43] <lizmat> yes, because now we get a "rel2abs" call for every file test operation

[14:43] *** guru joined
[14:43] *** ajr_ left
[14:44] <lizmat> and that's expensive

[14:44] *** guru is now known as Guest53698

[14:44] *** Guest53698 is now known as ajr_

[14:44] <lizmat> method abspath { $!abspath //= rel2abs($!path) }  # something like that

[14:45] <japhb> Yeah, it is.  I haven't been able to follow the discussion -- was there any progress in making rel2abs any less expensive, or has it just hit a wall that we can't improve right now?  (And if so, what is that wall?)

[14:45] *** SamuraiJack joined
[14:45] <lizmat> for Unix we can simplify, but not for Win

[14:45] *** BizarreCake left
[14:46] <lizmat> in the best case, rel2abs is: return self.canonpath($path) if self.is-absolute($path);

[14:47] <lizmat> the canonpath is rather extensive and involved

[14:47] <mberends> nwc10: yes, definitely between next week^Wmonth and Christmas :-/

[14:47] <japhb> nodnod

[14:48] <lizmat> I guess I could make the canonpath a multi

[14:48] <japhb> lizmat: But is it *correct*?  There are so many edge cases in path canonicalization, I'm wondering if we even handle it properly (where "as well as Perl 5" would be a good start)

[14:48] *** smash joined
[14:48] <lizmat> one with and one withhout :$parent

[14:48] <lizmat> japhb: I only know that if a change the smallest thing, I get spectest errors  :-)

[14:49] <lizmat> *I

[14:49] *** denis_boyun_ joined
[14:50] * japhb nods in appreciation of that particular pain

[14:51] <lizmat> I guess another thing making this slow, is the forced runtime lookup of methods

[14:51] <lizmat> method rel2abs( |c )               { $SPEC.rel2abs( |c )               }

[14:52] *** rindolf left
[14:55] *** ajr joined
[14:55] *** ajr_ left
[14:56] <masak> m: set(1, 2) ~~ set(1, 2, 3)

[14:56] <camelia> rakudo-moar 1450e3: ( no output )

[14:56] *** ajr is now known as Guest66751

[14:56] <masak> m: say set(1, 2) ~~ set(1, 2, 3)

[14:56] <camelia> rakudo-moar 1450e3: OUTPUTÂ«Falseâ¤Â»

[14:56] *** Guest66751 is now known as ajr_

[14:56] <masak> m: say set(1, 2) (<) set(1, 2, 3)

[14:56] <camelia> rakudo-moar 1450e3: OUTPUTÂ«Trueâ¤Â»

[14:57] *** bjz joined
[14:58] <lizmat> m: say set(1, 2) (<) bag(1, 2, 3)

[14:58] <camelia> rakudo-moar 1450e3: OUTPUTÂ«Trueâ¤Â»

[14:58] <lizmat> m: say set(1, 2) (<) bag(1, 1, 2, 3)

[14:58] <camelia> rakudo-moar 1450e3: OUTPUTÂ«Trueâ¤Â»

[14:58] <lizmat> m: say set(1, 2) (<) bag(2, 3)

[14:58] <camelia> rakudo-moar 1450e3: OUTPUTÂ«Falseâ¤Â»

[14:58] <lizmat> seems to work?

[14:59] <masak> yes :)

[14:59] *** fhelmberger_ joined
[14:59] *** fhelmberger_ left
[14:59] * masak is thinking about smartmatching

[14:59] *** rindolf joined
[15:00] <masak> here is the draft of my change so far: https://gist.github.com/masak/1322886ed7092c522bd8

[15:00] <masak> a. smartmatch on lists/parcels becomes structural; that is, it does ~~ on its elements. the fallout is that `(1, 2, 3) ~~ (1, 2, Int)` does what I expect.

[15:01] <masak> b. the funky behavior with whatevers in lists/arrays/parcels goes away. whatevers now mean only "whatever". tadzik++'s example in the advent post then actually becomes correct. :)

[15:02] <lizmat> and how would that work for (1,2,3,4) ~~ (1,2,anyothernumber of ints)

[15:02] *** H2O1 joined
[15:02] *** PotatoGim^Home left
[15:02] <masak> m: say (1, 2, 3, 4) ~~ :(1, 2, *@ints where { .all ~~ Int })

[15:02] <camelia> rakudo-moar 1450e3: OUTPUTÂ«Falseâ¤Â»

[15:03] <masak> hrm.

[15:03] <jnthn> std: my $s = set;

[15:03] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤The 'set' listop may not be called without arguments (please use () or whitespace to clarify) at /tmp/4Znrem_HlD line 1:â¤------> [32mmy $s = set[33mâ[31m;[0mâ¤Check failedâ¤FAILED 00:01 123mâ¤Â»

[15:03] <jnthn> S02-types\set.rakudo.moar fails like that

[15:03] *** kaare_ joined
[15:03] <lizmat> actually, I just realize an abspath wouldn't speed up Perl6 start time

[15:03] <masak> m: say (1, 2, 3, 4) ~~ :(1, 2, *@ints where { .all >>~~>> Int })

[15:03] <camelia> rakudo-moar 1450e3: OUTPUTÂ«Trueâ¤Â»

[15:03] <masak> \o/

[15:03] *** H2O1 left
[15:03] <lizmat> as each path (except one) is only ever checked once during startup anyway

[15:04] <masak> lizmat: when you want to do fancy stuff like "any number of X", what you want is not a smartmatch against a simple sequence. making sequences do that fragile/weird logic in the first place was crazy.

[15:04] <masak> doubly so after signatures turned out to do all that better.

[15:04] <lizmat> ok, just checking  :-)

[15:05] <jnthn>  is $s, setâ.new(5), '(|) has correct precedence.';

[15:05] <jnthn> bah :)

[15:05] <masak> jnthn: Set :)

[15:05] <jnthn> Right :)

[15:05] *** donaldh joined
[15:05] <masak> lizmat: it's OK, I want this proposal to be challenged. that's why I didn't just commit it directly :)

[15:05] <lizmat> the coercer has the same name as the type

[15:06] <jnthn> TimToady: I get a failure in S32-str/substr-rw.t claiming "Unsupported use of $$ variable; in Perl 6 please use $*PID" over is($$râ, "gloop", '$r referent is eq to the sub

[15:06] <masak> m: say (1, 2, 3, 4, 5) >>~~>> Int

[15:06] <camelia> rakudo-moar 1450e3: OUTPUTÂ«True True True True Trueâ¤Â»

[15:07] <jnthn> TimToady: Related to your recent patches? I don't see right off how it could be my one...

[15:07] <jnthn> TimToady: Also another test has a "can't find method returns"

[15:08] <jnthn> Bah, I'll just push this thing then we can distribute triage :)

[15:08] <dalek> rakudo-star-daily: 94f4ab8 | coke++ | log/ (14 files):

[15:08] <dalek> rakudo-star-daily: today (automated commit)

[15:08] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/94f4ab8a0d

[15:09] <dalek> rakudo/nom: e616060 | jonathan++ | src/Perl6/Grammar.nqp:

[15:09] <dalek> rakudo/nom: Add deftrap mechanism from STD.

[15:09] <dalek> rakudo/nom: 

[15:09] <dalek> rakudo/nom: Catches say; and similar mistakes.

[15:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e616060051

[15:10] <timotimo> hurm. i cannot build rakudo-moar on a vserver i'm on because there's a 300 seconds cpu time ulimit

[15:10] <TimToady> jnthn: found the problem, kinda

[15:10] <Ulti> >>~~>> just need a <3 operator to go with that

[15:10] <jnthn> japhb: I can't see any issues in the code you sent me right away...

[15:10] <TimToady> in Action variable, there's a make $past at the end, but it doesn't seem to work

[15:11] <TimToady> if I put an explicit make $past in my branch and return, it works

[15:11] <timotimo> wait, 300 seconds should be enough

[15:11] <TimToady> hang on, I'll test and push

[15:11] <jnthn> timotimo: Dunno what the hardware you have is like but on my box I can build all of Moar/NQP/Rakudo in under 300s :)

[15:11] <timotimo> after 1:11 minutes it gets "Terminated"

[15:13] <jnthn> .oO( A server *so* fast 300s time-dilates to 71s! )

[15:14] <timotimo> 2009216maxresidentk

[15:14] <timotimo> m: say 2009216 / 1024; say 2009216 / 1024 / 1024;

[15:14] <camelia> rakudo-moar 1450e3: OUTPUTÂ«1962.125â¤1.916138â¤Â»

[15:14] <timotimo> 2gb of ram

[15:14] <timotimo> could be the cause for the kill

[15:15] <timotimo> stack size              (kbytes, -s) 10240 - but we shouldn't get past that limit, right?

[15:15] <dalek> rakudo/nom: 3d233ed | TimToady++ | src/Perl6/ (2 files):

[15:15] <dalek> rakudo/nom: oddly, need explicit make $past; return;

[15:15] <dalek> rakudo/nom: 

[15:15] <dalek> rakudo/nom: It should fall through and do the 'make $past' at the end of the function but doesn't.

[15:15] <dalek> rakudo/nom: (Also, remove a useless line from check_variable.)

[15:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3d233ed70e

[15:15] <TimToady> there, that version works, but I don't know why it's different

[15:16] <timotimo> TimToady: you have a "my $past" in the inner scope

[15:16] <TimToady> ah!

[15:16] <timotimo> that's why the $past at the end of the function ends up NQPMu

[15:16] <dalek> roast: 42e5824 | jonathan++ | S0 (2 files):

[15:16] <dalek> roast: A couple of fixes for the deftrap rule.

[15:16] <dalek> roast: 

[15:16] <dalek> roast: STD rejected these two before; now Rakudo does also.

[15:16] <dalek> roast: review: https://github.com/perl6/roast/commit/42e5824c8c

[15:16] <TimToady> timotimo++

[15:16] * timotimo is pleased with himself

[15:17] <jnthn> heh, nice, does that mean I needn't look at it? :)

[15:17] <timotimo> i hope so :)

[15:17] * TimToady feels appropriately stupid :)

[15:17] <timotimo> blame your recent eye troubles

[15:17] <TimToady> jnthn: yes, that's preciselyu what it means

[15:18] <TimToady> well, and that I'm a lousy programmer :)

[15:18] <jnthn> std: say()

[15:18] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:01 121mâ¤Â»

[15:18] <jnthn> That isn't meant to be an error, right?

[15:18] <jnthn> ('cus we have a spectest that things it is, and I'm about to nuke it)

[15:18] <jnthn> *thinks

[15:18] <dalek> rakudo/nom: 114ba1d | TimToady++ | src/Perl6/Actions.nqp:

[15:18] <dalek> rakudo/nom: remove stupid 'my' spotted by timotimo++

[15:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/114ba1d9c6

[15:19] <TimToady> say() and say '' are both fine, I think, and likewise set(), to indicate emptiness explicitly

[15:20] <timotimo> std: say()

[15:20] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:01 121mâ¤Â»

[15:20] <timotimo> m: say()

[15:20] <camelia> rakudo-moar 1450e3: OUTPUTÂ«â¤Â»

[15:20] <timotimo> m: say

[15:20] <camelia> rakudo-moar 1450e3: OUTPUTÂ«â¤Â»

[15:20] <timotimo> i'm fine with say() working and say complaining

[15:20] <timotimo> it's a bit less pretty, but it'll still get the point across

[15:20] <tadzik> masak: which example?

[15:22] <masak> tadzik: http://irclog.perlgeek.de/perl6/2014-08-29#i_9263844

[15:22] <masak> tadzik: FROGGS was spectesting making ~~ structural, and it had exactly one failure in that file.

[15:22] <masak> FROGGS++

[15:23] <[Coke]> m: say for 1

[15:23] <camelia> rakudo-moar 1450e3: OUTPUTÂ«â¤Â»

[15:23] <[Coke]> m: say  for 1

[15:23] <camelia> rakudo-moar 1450e3: OUTPUTÂ«â¤Â»

[15:23] <[Coke]> oh, are we not caught up here?

[15:23] <timotimo> exactly

[15:23] <timotimo> it should work as expected after the next update

[15:24] <[Coke]> jnthn: "say for 1" dies as expected. "say  for 1" does not.

[15:24] <[Coke]> std: say for 1

[15:24] <masak> TimToady: any thoughts on https://gist.github.com/masak/1322886ed7092c522bd8 ?

[15:24] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/Ceno6bWhot line 1:â¤------> [32msay[33mâ[31m for 1[0mâ¤Check failedâ¤FAILED 00:01 121mâ¤Â»

[15:24] <[Coke]> std: say  for 1

[15:24] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/gbC6IdRsb7 line 1:â¤------> [32msay[33mâ[31m  for 1[0mâ¤Check failedâ¤FAILED 00:01 121mâ¤Â»

[15:26] <jnthn> [Coke]: Yeah, just noticed that. wtf.

[15:27] <dalek> roast: 06159ea | jonathan++ | S16-io/bare-say.t:

[15:27] <dalek> roast: Unfudge passing tests; toss a bogus one.

[15:27] <dalek> roast: review: https://github.com/perl6/roast/commit/06159ead32

[15:29] *** rindolf left
[15:29] *** rindolf joined
[15:30] <jnthn> [Coke]: Fixed it locally, so now bare-say.t can pass in full

[15:31] <timotimo> looking forward to seeing what caused that behavior %)

[15:31] *** rindolf left
[15:32] <jnthn> Well, I kinda cheated on the fix.

[15:32] <jnthn> :)

[15:32] <lizmat> m: do { return 42 }

[15:32] <camelia> rakudo-moar 1450e3: ( no output )

[15:32] <timotimo> does that mean say   for 1 will still fail now? :P

[15:32] <lizmat> hmmm.. that segfaults locally

[15:32] <timotimo> and after that say           for 1? :D

[15:33] <masak> m: do { return 42 }; say "I will survive"

[15:33] <camelia> rakudo-moar 1450e3: ( no output )

[15:33] <masak> lizmat: well, *something* is wrong.

[15:33] <masak> (and it's in RT at least once already)

[15:33] <lizmat> yeah, I know: I was just wondering about the segfault

[15:34] <lizmat> easy segfaults are the best food of the debugger  :-)

[15:36] <cxreg> after all these years i still <3 electricfence

[15:43] *** tphilipp joined
[15:53] <dalek> rakudo/nom: a98d264 | jonathan++ | src/Perl6/Grammar.nqp:

[15:53] <dalek> rakudo/nom: Make "say  for 1;" complain also.

[15:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a98d264a5c

[15:53] <jnthn> m: say;

[15:53] <camelia> rakudo-moar dd580d: OUTPUTÂ«â¤Â»

[15:53] <jnthn> ENOTYET...

[15:54] <dalek> roast: 927f3e1 | jonathan++ | S16-io/bare-say.t:

[15:54] <dalek> roast: Unfudge "say  for 1;" test.

[15:54] <dalek> roast: review: https://github.com/perl6/roast/commit/927f3e1638

[15:54] *** tphilipp left
[15:55] <dalek> roast: 1059587 | TimToady++ | S03-operators/context.t:

[15:55] <dalek> roast: update for anonyvars

[15:55] <dalek> roast: review: https://github.com/perl6/roast/commit/105958774d

[15:55] * jnthn read that as "annoyvars" :)

[15:57] <TimToady> m: say ++$

[15:57] <camelia> rakudo-moar dd580d: OUTPUTÂ«===SORRY!===â¤Cannot find method 'returns'â¤Â»

[15:57] <TimToady> not there yet

[15:59] <TimToady> so, who owned "planeteria"?

[15:59] *** MilkmanDan joined
[16:01] *** jack_rabbit joined
[16:01] <TimToady> it's kind of a pity we can't just upload our newly compiled version to run under camelia immediately...

[16:04] <TimToady> or run camelia on a machine with enough cores to recompile as soon as a change comes it

[16:06] *** virtualsue joined
[16:09] *** virtualsue left
[16:21] *** xinming left
[16:24] *** cognome_ left
[16:24] <lizmat> not ok 3 - Calling sub if without parens parsefails

[16:24] <lizmat> jnthn TimToady ^^^

[16:25] *** cognome joined
[16:25] <lizmat> from t/spec/S02-lexical-conventions/one-pass-parsing.t

[16:25] *** raiph joined
[16:26] <lizmat> also: not ok 253 - alternation and conjunction (&|) - parse error

[16:26] <lizmat> from t/spec/S05-mass/rx.t

[16:28] <TimToady> probably anonyvar collision there

[16:28] <jnthn> TimToady: Which one? Or both?

[16:29] <jnthn> I can't imagine the latter is mine; first one may be...

[16:29] <TimToady> the latter

[16:29] <TimToady> probably parsing & as a variable somehow

[16:29] *** cognome left
[16:29] <TimToady> but I'll look at the &| one

[16:30] <TimToady> m: say ++$

[16:30] <camelia> rakudo-moar dd580d: OUTPUTÂ«===SORRY!===â¤Cannot find method 'returns'â¤Â»

[16:30] <lizmat> $ 6 'say ++$'

[16:30] <lizmat> 1

[16:30] <jnthn> std: sub if() { "#foo" }; say if;

[16:30] <camelia> std 53b3ca6: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/kG_B89Ln4H line 1:â¤------> [32msub if() { "#foo" }; say[33mâ[31m if;[0mâ¤Confused at /tmp/kG_B89Ln4â€¦Â»

[16:31] <jnthn> Rakudo now matches that error

[16:31] <TimToady> note that 'if' is a kind of terminator

[16:31] <jnthn> But the test wants it to be Confused.

[16:31] <jnthn> So, the test wants an update

[16:31] <TimToady> it is confused, in std

[16:32] <TimToady> std: sub if() { "#foo" }; say if();

[16:32] <camelia> std 53b3ca6: OUTPUTÂ«ok 00:01 126mâ¤Â»

[16:32] <lizmat> all current fails: https://gist.github.com/lizmat/d0968a1791e605f52ba1

[16:32] <jnthn> I guess it does both

[16:32] <jnthn> But throws_like now sees the first...

[16:32] <TimToady> yes, std is being more lazily panicky

[16:32] <lizmat> throws_like just makes sure it dies for the right reason

[16:33] <dalek> Inline-Perl5: 2e80595 | nine++ | / (3 files):

[16:33] <dalek> Inline-Perl5: Allow passing Perl 6 objects through Perl 5 space.

[16:33] <dalek> Inline-Perl5: 

[16:33] <dalek> Inline-Perl5: Create Perl 5 objects for Perl 6 objects passed to Perl 5 methods.

[16:33] <dalek> Inline-Perl5: Use an "unwrap" callback to get back the Perl 6 object if a wrapped

[16:33] <dalek> Inline-Perl5: object is returned by a Perl 5 method.

[16:33] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/2e8059544a

[16:33] <jnthn> lizmat: If you want an easy patch to do, making the patch I did throw a typed exception could be nice...

[16:33] <jnthn> lizmat: And then update that S02 test to look for it

[16:33] <TimToady> it's not necessary to follow STD slavishly there

[16:33] <lizmat> if it shouldn't die, or differently from the test, the test should be adapted

[16:33] <jnthn> Oh, wait...

[16:33] <jnthn> It *is* a typed already...

[16:33] <TimToady> though the Confused is perhaps useful information as to why say has no argument

[16:33] <lizmat> if it is X::AdHoc, it isn't  :-)

[16:34] <TimToady> Any is a type too :P

[16:34] *** denis_boyun_ left
[16:34] <TimToady> maybe we should rename Any to AdHoc :)

[16:34] <dalek> roast: 7910209 | jonathan++ | S02-lexical-conventions/one-pass-parsing.t:

[16:34] <dalek> roast: Sync test to expect same error STD gives.

[16:34] <dalek> roast: review: https://github.com/perl6/roast/commit/7910209ae2

[16:35] <jnthn> Well, STD calls sorryobs in this case.

[16:35] <TimToady> which is lazyish

[16:35] <jnthn> So we get an X::Obselete

[16:35] <nine> It really makes me nervous that this Inline::Perl5 stuff works with so little hassle. This ought to be much more complicated.

[16:35] <lizmat> actually, renaming X::AdHoc to X::Die would make sense to me

[16:35] *** SAA2TAD joined
[16:35] <lizmat> or X::Died

[16:35] <jnthn> or X::pired :P

[16:35] <TimToady> nine: well, have you looked at diakopter's design to see where your design is going to break?

[16:36] <nine> TimToady: not at all. Where can I find it?

[16:36] <TimToady> well, it's in his grant proposal

[16:36] <jnthn> Oh heck, I need to implement DESTROY stuff for nine++ too, don't I... :)

[16:36] <lizmat> I thought most of the design was in diakopter's head ?

[16:36] <nine> jnthn: yes, pretty please :)

[16:36] <TimToady> dunno if there's a separate document somewhere offhand

[16:36] <lizmat> jnthn: well, *some* code to be executed at GC expulsion would be nice

[16:37] <jnthn> lizmat: Yeah, the GC changes are not too bad

[16:37] <jnthn> lizmat: It's where to run the code that's tricky.

[16:37] <TimToady> I'm sure diakopter++ would be glad to foist some of the work off on nine++

[16:37] *** BizarreCake joined
[16:37] <carlin> using NativeCall, I have a CStruct that `has int $.v`, how do I use that to pass to a C function? `some_struct.new(v => 42)` doesn't work

[16:38] <lizmat> TimToady: I hope so too

[16:38] *** jdv79 joined
[16:38] <nine> TimToady: what I can find in his grant proposal is completely different from my implementation.

[16:38] <jdv79> where is the planet site now?

[16:39] <jdv79> i wanted to find the link to that json lib integration so i could test the speed with the new rakudo but that's the only place i know to find that link

[16:39] <jnthn> carlin: Dunno off hand but maybe check the nativecall README, or failing that the cstruct tests...

[16:39] <nwc10> jnthn: Josette is already busy that weekend, so can't make the APW in Salzburg :-(

[16:40] <nwc10> It's also Pycon Ireland

[16:41] * TimToady would prefer to attend Pyron Iceland

[16:41] <jnthn> nwc10: Aww

[16:42] <TimToady> but I guess they've closed their airspace or so

[16:42] <dalek> rakudo/nom: 4887ae5 | (Elizabeth Mattijsen)++ | src/core/IO.pm:

[16:42] <dalek> rakudo/nom: Make filetests only check for existence once

[16:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4887ae5c91

[16:42] <btyler_> jdv79: https://github.com/kanatohodets/p6-json-jansson ? I'm still working on it, but I'd love feedback if you end up playing with it

[16:43] <jnthn> Only over the immediate surroundings afaik

[16:43] <jnthn> It's "only" a fissure eruption, last I checked...

[16:43] <jdv79> jansson - that's it

[16:43] <jnthn> Probably quite pretty from a distance. :)

[16:43] <TimToady> well, but that's where the Pyron is :)

[16:43] <jnthn> But not ash spewing...yet. :)

[16:45] * jnthn got to see Eyjafjallajokull errupting and since then has kinda hoped to have chane to see more volcanic stuff at some point :)

[16:45] <jnthn> *chance

[16:47] * TimToady saw Mt St Helens erupt...from 150 miles away...

[16:48] *** domidumont joined
[16:49] * lizmat is getting lost in the maze that is IO IO::Handle IO::Path and IO::Spec

[16:50] *** dayangkun left
[16:50] <jnthn> lizmat: You and me both... :)

[16:52] *** ajr_ left
[16:53] *** donaldh left
[16:54] *** rindolf joined
[16:54] <tony-o> btyler_: looks p cool

[16:56] <btyler_> tony-o: thanks! I think I'm going to change the api a bit, "from-json(<foo>, True)" isn't a great way to declare that you want a handle on a jansson object instead of a core p6 data structure

[16:56] <lizmat> hmmm.... according to spec, IO::Handle should *not* be doing IO::FileTestable

[16:56] <btyler_> but otherwise I feel ok about it. colomon++ spotted some bugs, the worst of which I fixed, will probably pull from his repo at some point this weekend

[16:56] <lizmat> is that a problem in the spec?  or a problem in the implementation ?

[16:58] <lizmat> also: according to spec (S32/Str), a bare say or print should warn, not die

[16:58] <lizmat> "As with C<print>, the compiler will warn you if you use a bare sub C<say>

[16:58] <lizmat> without arguments."

[17:00] <lizmat> About IO::FileTestable: the spec states: "If you apply that role to a class, that class must provide a C<Str> method which returns the full path."

[17:00] <lizmat> TimToady: is "full path" the same as "absolute path", and is therefore the .Str of IO faulty atm ?

[17:01] * TimToady lost track of everything IO about 87,000 years ago

[17:02] <lizmat> so "slushy" would be a good description of the current state of IO

[17:02] <tony-o> lol

[17:04] *** rindolf left
[17:04] *** BizarreCake left
[17:04] <TimToady> m: say lol

[17:04] <camelia> rakudo-moar a98d26: OUTPUTÂ«â¤Â»

[17:04] <lizmat> m: lol

[17:04] <camelia> rakudo-moar a98d26: ( no output )

[17:05] *** rindolf joined
[17:05] <lizmat> .oO( silently laughing out load )

[17:05] <TimToady> well, that's why people invented "lol"

[17:05] <TimToady> cuz you can't hear it

[17:05] *** dakkar left
[17:06] <lizmat> for Dutch people, "lol" just means "fun"

[17:06] <lizmat> with "lollig" being "funny"

[17:06] <huf> yeah, that's how we use it too, pretty much

[17:06] <huf> it's a word.

[17:06] * TimToady wonders if it's etymologically related to "droll"

[17:07] <huf> hmm.... i think our "lol" is a bit more schadenfreude-liek

[17:07] <huf> has the connotations of "what has this idiot done again?"

[17:08] <lizmat> you can have "lol" on your own...

[17:08] *** itz_ joined
[17:12] *** kaare_ left
[17:13] <huf> you can lol if you want to

[17:14] <huf> you can leave your friends behind...

[17:17] *** gfldex joined
[17:19] *** donaldh joined
[17:22] *** donaldh left
[17:23] *** rindolf left
[17:23] *** rindolf joined
[17:25] *** itz joined
[17:27] *** itz_ left
[17:28] <[Coke]> (planeteria) site admin is working on the issue, please be patient.

[17:28] *** zacts left
[17:29] <dalek> rakudo/nom: 6a6b5d0 | TimToady++ | src/core/List.pm:

[17:29] <dalek> rakudo/nom: gist should, like, give you the tl;dr of the list

[17:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a6b5d085a

[17:29] <dalek> perl6-roast-data: d4ca3cc | coke++ | / (6 files):

[17:29] <dalek> perl6-roast-data: today (automated commit)

[17:29] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d4ca3ccfbc

[17:30] *** BizarreCake joined
[17:30] <[Coke]> hey, someone borked the spectests.

[17:30] <TimToady> yes, there's still a bit of fallout from the anonyvars

[17:30] <[Coke]> jvm: 49, moar: 68; moar-jit: 67; parrot: 731

[17:31] <TimToady> but it's not all my fault

[17:31] <[Coke]> (as of rakudo 54cd8fb, spectest 7fc8efd)

[17:31] <grondilu> p6: subset LinComb of Hash where *.values.all ~~ Numeric; say (my % = a => 1, b => -1) ~~ LinComb

[17:31] <[Coke]> likely story. :)

[17:31] *** itz_ joined
[17:31] <TimToady> m: say ++$

[17:31] <camelia> rakudo-jvm 4887ae: OUTPUTÂ«(timeout)Â»

[17:31] <camelia> ..rakudo-{parrot,moar} 4887ae, niecza v24-109-g48a8de3: OUTPUTÂ«Falseâ¤Â»

[17:31] <camelia> rakudo-moar 4887ae: OUTPUTÂ«1â¤Â»

[17:31] *** itz left
[17:31] <TimToady> say what?

[17:32] <TimToady> oh, that's you

[17:32] <TimToady> or, rather, not you

[17:33] * [Coke] ponders a script that does a roast blame on people.

[17:33] <[Coke]> "200 new failures: possible culprits include:"

[17:33] <hoelzro> [Coke]++ # knowing full well I will probably often appear in that listing

[17:34] <[Coke]> Seriously, though, I'll see if I can clean those for tomororw.

[17:34] <nwc10> 0) Jon Orwant, for throwing coffee mugs in the first place

[17:34] <nwc10> etc

[17:34] *** zacts joined
[17:34] <grondilu> mayb camelia should reply with username:

[17:34] <grondilu> I mean nick:

[17:35] <TimToady> some of them may be transients

[17:37] <lizmat> jnthn: from a performance point of view, would it make sense to just add a fallback to IO::Spec that would install the right IO::Spec::xxx method at runtime

[17:37] <lizmat> rather than the class method -> variable class.method approach right now?

[17:37] *** rindolf left
[17:38] *** rindolf joined
[17:38] <lizmat> to prevent this kind of mapping: method rel2abs( |c )               { $SPEC.rel2abs( |c )               }

[17:39] <TimToady> m: say 1...*

[17:39] <lizmat> possibly doing this in the optmizer?

[17:39] <camelia> rakudo-moar 4887ae: OUTPUTÂ«(timeout)Â»

[17:39] <nwc10> Rakudo 2014.05 doesn't build on NQP 2014.05 on MoarVM 2014.05 on PPC :-(

[17:39] <grondilu> so with this new $++ thing I remembered there is a (state $)++ in RC's evolutionary algorithm.  So I try it before I change it and I got:

[17:39] <grondilu> Internal error: invalid thread ID in GC work pass

[17:39] <nwc10> so, didn't nail that bug back then

[17:39] <nwc10> :-(

[17:40] * grondilu wonders if there was not some test for RC regressions

[17:40] <grondilu> issue was in http://rosettacode.org/wiki/Evolutionary_algorithm#Perl_6

[17:40] <zacts> hi

[17:40] <TimToady> zacts: lo

[17:41] <zacts> lo

[17:41] <TimToady> and behold

[17:41] *** shlomif joined
[17:41] *** rindolf left
[17:41] *** shlomif is now known as rindolf

[17:43] <grondilu> (the $++ seems to work, though.  No idea why)

[17:44] * grondilu meant the $++ version of the same code

[17:46] <zacts> $++ looks kind of scary to me, coming from perl5. is that $+ with a +? or is $ the default variable? I have much to learn.

[17:46] *** telex left
[17:46] <moritz> zacts: an anonymous variable $ being ++ed

[17:46] <zacts> ah ok

[17:47] <moritz> m: say ++(state $) for ^10

[17:47] <camelia> rakudo-moar 4887ae: OUTPUTÂ«1â¤2â¤3â¤4â¤5â¤6â¤7â¤8â¤9â¤10â¤Â»

[17:47] <BenGoldberg> Say grondilu, did you see my solution for your problem?

[17:48] <BenGoldberg> m: sub encode($n is copy) { my $m = 0; my $rest = ''; while ($n) { $n = $n.base(36); ++$m; $rest = $n~$rest; $n = $n.chars-1; }; $m.base(36)~$rest; }; say [lt] map { encode($_) }, ^2000

[17:48] <camelia> rakudo-moar 4887ae: OUTPUTÂ«Trueâ¤Â»

[17:48] *** telex joined
[17:49] <grondilu> m: sub encode($n is copy) { my $m = 0; my $rest = ''; while ($n) { $n = $n.base(36); ++$m; $rest = $n~$rest; $n = $n.chars-1; }; $m.base(36)~$rest; }; say map { encode($_).chars }, ^10

[17:49] <camelia> rakudo-moar 4887ae: OUTPUTÂ«1 2 2 2 2 2 2 2 2 2â¤Â»

[17:49] <grondilu> m: sub encode($n is copy) { my $m = 0; my $rest = ''; while ($n) { $n = $n.base(36); ++$m; $rest = $n~$rest; $n = $n.chars-1; }; $m.base(36)~$rest; }; say uniq map { encode($_).chars }, ^1000

[17:49] <camelia> rakudo-moar 4887ae: OUTPUTÂ«1 2 4â¤Â»

[17:49] <grondilu> hum not bad

[17:49] <grondilu> BenGoldberg++

[17:49] <BenGoldberg> :)

[17:52] <BenGoldberg> It does have a limitation: if $m exceeds 36, then it won't be lexigraphically sorted.  On the other hand, you would need truly gargantuan numbers to do that, so it's not a practical concern.

[17:52] <grondilu> ok

[17:54] <grondilu> is decoding easy?

[17:54] <BenGoldberg> I think so.

[17:54] <BenGoldberg> Split off the first character, decode that char in base 36; that's the number of times to go through the inner loop.

[17:56] <dalek> specs: 6ab1396 | TimToady++ | S02-bits.pod:

[17:56] <dalek> specs: .gist only prints 100 entries of long lists

[17:56] <dalek> specs: review: https://github.com/perl6/specs/commit/6ab1396b0e

[17:56] <BenGoldberg> Then... hmm..... 

[17:56] <TimToady> m: say 1...*

[17:56] <TimToady> ENOTYET

[17:56] <camelia> rakudo-moar 4887ae: OUTPUTÂ«(timeout)Â»

[17:58] <hoelzro> are dynamic variables specific to a single compilation unit?

[17:58] <hoelzro> ex. if I have $*VAR_NAME in my module, and someone else uses that same variable name in another module, will they interfere?

[17:58] <nwc10> mberends: sorry, looks like I ran out of time in May and never figured out how to get Rakudo itself building on PPC

[17:58] <nwc10> mberends: sorry, part 2, NQP used to work, but seems to be bust

[17:59] <nwc10> bisecting

[17:59] <dalek> rakudo/nom: 32cb14d | TimToady++ | src/core/List.pm:

[17:59] <dalek> rakudo/nom: off-by-one on gist's tl;dr

[17:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/32cb14d398

[18:00] *** lizmat_ joined
[18:01] <moritz> hoelzro: perl6/doc htmlify.p6 is back to < 10min with latest rakudo

[18:01] *** rindolf left
[18:02] *** rindolf joined
[18:02] * TimToady guesses that's de-pessimizing push

[18:02] <moritz> possible

[18:03] <hoelzro> moritz: yeah, performance wasn't an issue when I tried it this morning

[18:03] <hoelzro> but the generated Pod doesn't match up yet

[18:03] <hoelzro> I'll fix that after work

[18:03] <jnthn> TimToady: About push: the reason it became pessimized wasn't so much the special case for item and avoiding the *@foo, afaict

[18:04] <jnthn> TimToady: It wsa the callsame and the fact that ruins the optimizer's ability to avoid building *%_

[18:04] <jnthn> TimToady: I *think* if we can do the special case and avoid he callsame we may come out ahead...

[18:06] <TimToady> well, the old n-ary push was not as efficient as the new one, especially for many values

[18:06] <TimToady> but it was certainly beating the unary one in this case

[18:07] <jnthn> Oh, there's a new n-ary push?

[18:07] <jnthn> that may well have shifted the balance since I did the original opt

[18:08] <jnthn> I don't commit opts on guesswork; I certainly woulda measured that one at the time.

[18:08] <TimToady> yes, it just does a splice rather than pushing one at a time

[18:08] <jnthn> If you want to see an interesting profile about push, though, see the while push one in perl6-bench

[18:08] <jnthn> It spent - last I checked - > 30% of its time in sink, somehow...

[18:08] <TimToady> that's just one-arg

[18:09] <jnthn> I think 'cus it was sinking the list after the push, since push returns the list itself...

[18:09] <TimToady> I haven't got around to adding @a.push(@a) yet

[18:09] <TimToady> which is blazingly faster than it used to be

[18:09] <TimToady> for larger N

[18:09] *** molaf__ joined
[18:09] <jnthn> :)

[18:11] *** lizmat_ is now known as lizmat

[18:12] <moritz> tadzik++ # panda, rebootstrap.pl

[18:14] <BenGoldberg> grondilu, here's a decoding function written in perl5:

[18:14] <BenGoldberg> eval: use warnings; sub unencode { local $_ = shift; s/(.)//; my $m = $1 or return 0; my $n = 1; for my $mm ( 1 .. $m ) { warn "[$m;$n;$mm;$_]\n"; s/(.{$n})// or die; $n = $1 }; $_ }; [ unencode("3114562949953421312") ];

[18:15] <BenGoldberg> I'm sure it can be easily be rewritten in perl6... but I'm not good at golfing, yet :)

[18:15] <lizmat> the more I look at it, I think IO::Path is overenginieered and mostly useless

[18:16] <lizmat> a lot of effort is spent converting IO::Path to Str and vice-versa

[18:16] <grondilu> p6: role Foo {}; my %h = ("foo" but Foo) => 1; say %h.keys[0] ~~ Foo;

[18:16] <camelia> rakudo-{parrot,jvm,moar} 4887ae, niecza v24-109-g48a8de3: OUTPUTÂ«Falseâ¤Â»

[18:16] *** perfectredneck joined
[18:17] <grondilu> so Hash keys can not have a role attached to them?

[18:17] <lizmat> typed hashes can contain anything, including objects with roles attached to them?

[18:17] <lizmat> or is that not what you mean?

[18:17] <TimToady> m: role Foo {}; my %h{Any} = ("foo" but Foo) => 1; say %h.keys[0] ~~ Foo;

[18:17] <camelia> rakudo-moar 4887ae: OUTPUTÂ«Trueâ¤Â»

[18:18] <TimToady> grondilu: ^^

[18:18] <grondilu> oh, ok

[18:18] * grondilu is not quite familiar with typed structures

[18:18] *** perfectredneck left
[18:18] <lizmat> some subs even have a Str candidate in the spec:

[18:18] <lizmat>     multi sub visitdir(Str:D)

[18:18] <lizmat>     multi sub visitdir(IO::Path:D)

[18:18] <nine> moritz: do you have some time to look at my strange method call problem?

[18:19] <jnthn> nine: What is the problem, ooc?

[18:19] <jnthn> nine: Is it a MOP-related thing?

[18:20] * jnthn might be able to give a hint if so...

[18:20] <nine> jnthn: yes, you might. I managed to write a test with only inline Perl 5: https://github.com/niner/Inline-Perl5/commit/de167995c90fe2cd2267ab699d50ca6a7895dcc4

[18:22] <nine> jnthn: we're using add_fallback to pass through method calls on Perl5Objects to the Perl 5 interpreter: https://github.com/niner/Inline-Perl5/blob/master/lib/Inline/Perl5.pm6#L247

[18:22] <nine> jnthn: but there's strange calls to "sink" and in the test, $!perl5 seems to end up being a Perl5Object instead of a PerlInterpreter

[18:23] <jnthn> nine: Yes, that's because things in void context do .can('sink') or so

[18:23] <jnthn> Perl5Object.^add_fallback(-> $, $ { True },

[18:23] <jnthn> That means you're claiming you support *every* method.

[18:24] <jnthn> You migh try adding a method sink() { self } in Perl5Object

[18:24] <jnthn> Eventually, though, we really should write a Perl5HOW meta-object...

[18:25] <jnthn> That way we can even have Perl 5 object dispatches go through the method cache rather than the slow path.

[18:27] *** rindolf left
[18:28] *** rindolf joined
[18:29] <nine> jnthn: ok that takes care of the "sink" problem. But there's still the following error: http://paste.scsys.co.uk/420296 caused by $!perl5 being a Perl5Object instead of a PerlInterpreter. I really have no idea why. The code seems to be very straight forward.

[18:30] <jnthn> My latest talk slides are now linked from http://jnthn.net/articles.shtml

[18:31] *** brrt joined
[18:31] <brrt> \o

[18:31] *** guru joined
[18:32] *** guru is now known as ajr_

[18:32] <dalek> Inline-Perl5/transparent_method_call_regression: 71dcdeb | nine++ | lib/Inline/Perl5.pm6:

[18:32] <dalek> Inline-Perl5/transparent_method_call_regression: Add a sink method to Perl5Object as suggested by jnthn++

[18:32] <dalek> Inline-Perl5/transparent_method_call_regression: 

[18:32] <dalek> Inline-Perl5/transparent_method_call_regression: Apparently can('sink') may be called on Perl5Objects in some situations.

[18:32] <dalek> Inline-Perl5/transparent_method_call_regression: Since we claim to support _any_ method, we have to provide a somewhat

[18:32] <dalek> Inline-Perl5/transparent_method_call_regression: sane implementation.

[18:32] <dalek> Inline-Perl5/transparent_method_call_regression: review: https://github.com/niner/Inline-Perl5/commit/71dcdeb31a

[18:33] <ajr_> 150 miles away sounds like a good distance at which to view Mt. St. Helens erupt.

[18:33] <dalek> roast: 48160f2 | TimToady++ | S03-operators/context.t:

[18:33] <dalek> roast: anonymous & doesn't make a lot of sense

[18:33] <dalek> roast: review: https://github.com/perl6/roast/commit/48160f2b43

[18:34] <BenGoldberg> If I could, I'd watch Mt. St. Helens erupt from Iceland, and vice versa. ;)

[18:34] <dalek> rakudo/nom: 9a9da9f | TimToady++ | src/Perl6/Grammar.nqp:

[18:34] <dalek> rakudo/nom: anonymous & doesn't make a lot of sense

[18:34] <dalek> rakudo/nom: 

[18:34] <dalek> rakudo/nom: (and causes bugs in rx parsing of &)

[18:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9a9da9f3ff

[18:34] <jnthn> nine: Hmm....what on earth...

[18:35] <jnthn> nine: You're sure it's actually that the value is changing?

[18:36] <TimToady> m: say 1...*

[18:36] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8â€¦Â»

[18:36] <lizmat> given a file "foo" with "foo" in it, and "bar" with "bar in it:

[18:36] <lizmat> this seems *very* wrong to me:

[18:36] <lizmat> $ 6 'my $h = "foo".IO.open; $h.open("bar"); say $h.lines'

[18:36] <lizmat> bar

[18:36] <TimToady> m: say 1,1...*

[18:36] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...â¤Â»

[18:36] *** denis_boyun_ joined
[18:36] <dalek> Inline-Perl5/call_backs: a563d94 | nine++ | / (3 files):

[18:36] <dalek> Inline-Perl5/call_backs: Failing call backs

[18:36] <dalek> Inline-Perl5/call_backs: review: https://github.com/niner/Inline-Perl5/commit/a563d9413b

[18:36] <TimToady> notice that's rakudo's ... there

[18:37] <lizmat> in other words, you can open another file on an open file handle, and it will read from the new file from there one

[18:37] <lizmat> *on

[18:37] <lizmat> is this intended as a feature?  or is this a bug?

[18:37] <TimToady> but what kind of output is that....

[18:37] <BenGoldberg> lizmat, That's not very different from how perl5 does it.

[18:37] <BenGoldberg> Or stdio.

[18:38] <BenGoldberg> Reusing a handle isn't that uncommon.

[18:38] <brrt> ooh TimToady i meant to bug you about the recent div spec change

[18:38] <lizmat> that it changes the file handle *itself* ?

[18:38] <BenGoldberg> ?

[18:38] <jnthn> TimToady: wtf, why the 1 1 1...

[18:39] <brrt> that's a spesh or jit error

[18:39] <TimToady> m: say (1,1...*)

[18:39] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...â¤Â»

[18:39] <TimToady> cool!

[18:39] <brrt> bug!

[18:39] <TimToady> m: say (1,1.1...*)

[18:39] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 6.7 6.8 6.9 7 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 8 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9 9.1 â€¦Â»

[18:39] <brrt> :-)

[18:40] <TimToady> wow

[18:40] <nine> jnthn: I put a warn $!perl5 in there and I get a line with: Perl5Object<139780065295616>  in block  at /home/nine/Inline-Perl5/lib/Inline/Perl5.pm6:237

[18:40] <jnthn> 57 is a magical number

[18:40] <BenGoldberg> m: say ('a',1.1...*);

[18:40] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 -54.9 -55.9 -56.9 -57.9 -58.9 -59.9 -60.9 -61.9 -62.9 -63.9 -64.9 -65.9 -66.9 -67.9 -68.9 -69.â€¦Â»

[18:40] <BenGoldberg> m: say (3,'a'...*);

[18:40] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci câ€¦Â»

[18:40] <brrt> what the

[18:40] <TimToady> m: say (0, 1/10 ... 1)

[18:40] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11â¤Â»

[18:40] *** SamuraiJack left
[18:40] <jnthn> 100 = number of iterations of a loop for OSR to trigger + 8 = number of trace iterations...

[18:40] <TimToady> there's a spectest failing from this one

[18:41] <brrt> i can imagine

[18:41] <TimToady> specifically that 0, 1/10 one

[18:41] <brrt> what i wanted to bug about: integer division rounds to <negative infinity | zero > 

[18:41] <brrt> which one?

[18:41] <TimToady> integration/advent2013-day15.t

[18:42] <lizmat> BenGoldberg: indeed, I'm surprised...

[18:42] <lizmat> and this is a good thing because ?

[18:42] <lizmat> I mean, in Perl 6 the old handle at the OS level will probably stay open, as we don't DESTROY

[18:42] <TimToady> m: say ~(0, 1/10 ... 1)

[18:42] <camelia> rakudo-moar 32cb14: OUTPUTÂ«0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1â¤Â»

[18:42] <nine> jnthn: $!perl5 is actually the same as self in that case.

[18:42] <jnthn> lizmat: Feels like a wtf to me...

[18:43] <TimToady> ooh, it's something about my gist change

[18:43] <BenGoldberg> I'm not saying it's a good thing, just not a surprising thing.

[18:43] <TimToady> m: say (0, 1/10 ... 1).gist

[18:43] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11â¤Â»

[18:43] <TimToady> huh

[18:43] <lizmat> it's surprising to me..  :-)

[18:43] <jnthn> lizmat: Well, the VM GCs IOHandles and will close them...

[18:43] <jnthn> lizmat: So we're not *too* bad from that angle.

[18:43] <jnthn> lizmat: Unless the original handle makes gen2.

[18:44] <jnthn> From data I'm seeing at present, full collection frequency wants to becme a function of bytes promoted

[18:44] <lizmat> ok, but still, you run the risk of running out of OS handles pretty soon in some applications that way

[18:44] <BenGoldberg> If you reopen the same handle to a different file, the old c-level filedescriptor gets closed right away, instead of having to wait for GC.

[18:44] <TimToady> oh, duh, I'm an idgit

[18:44] <BenGoldberg> Or at least, it should.

[18:45] <lizmat> pretty sure it doesn't in rakudo atm

[18:45] <jnthn> BenGoldberg: That's now how things actually work unless we make it so

[18:45] <jnthn> And what lizmat said

[18:45] <lizmat> it's just doing a nqp::bindattr

[18:45] <lizmat> and that doesn't know about filehandles

[18:45] <jnthn> To me, trying to do .open on a dhnel a second time is likely to be a bug.

[18:45] <jnthn> *handle

[18:45] <jnthn> So better to whine, I think...

[18:45] <lizmat> feels "DOS"sy to me

[18:46] <TimToady> testing fix

[18:46] <lizmat> as in MS-DOSsy

[18:46] <BenGoldberg> If we run out of OS-level filehandles, does it trigger a GC?

[18:46] <nwc10> BenGoldberg: no. (I know that already)

[18:47] <TimToady> though I don't understand why it worked around my nested $_ binding bug halfway through

[18:47] <TimToady> probably indicates a different bug

[18:47] *** ggherdov left
[18:48] <brrt> we have a known inlining-related bug in moar with $_

[18:49] <jnthn> brrt: We...do?

[18:49] <brrt> aye

[18:49] <dalek> rakudo/nom: 1ff1d30 | TimToady++ | src/core/List.pm:

[18:49] <dalek> rakudo/nom: don't use $_ two different ways

[18:49] <dalek> rakudo/nom: 

[18:49] <dalek> rakudo/nom: previous .gist patch did just that, TimToady--

[18:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1ff1d3065c

[18:49] <jnthn> Ticket?

[18:49] <brrt> you probably have missed that since flight

[18:49] <brrt> let me see that

[18:50] <TimToady> would that account for my buggy code getting the right (wrong) $_ after 57?

[18:50] <brrt> https://github.com/MoarVM/MoarVM/issues/127 jnthn

[18:50] <jnthn> TimToady: As I said, 57 is a *very* suspect number

[18:50] <lizmat> TimToady: not sure whether that fix isn't just circumventing a spec bug

[18:50] <lizmat> *spesh / jit

[18:50] <TimToady> what I just said

[18:51] *** ggherdov joined
[18:51] <TimToady> it just showed the other bug by accident

[18:51] <brrt> i'd note that the old behaviour (div int rounding to zero) never caused one spectest to fail :-)

[18:51] <TimToady> by compensating for my mistake partway through :)

[18:52] *** elfphiltrum joined
[18:52] *** elfphiltrum left
[18:53] <TimToady> unfortunately, I tested the sequence 1...* so I didn't see the error, and wrote off the failure in integration as some Rat problem

[18:54] <TimToady> wasn't until I tried the 1,1...* here to get the gist to fit into camelia's limit that I spotted the goofup

[18:55] * lizmat finally sees the goofup

[18:56] <TimToady> yes, it sort of doesn't register at first

[18:57] <TimToady> m: say 1,1,*+*...*

[18:57] <camelia> rakudo-moar 32cb14: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 591286729879 956722026041 1548008755920 2504730781961 4052739537881 6557470319842 106102098577â€¦Â»

[18:57] <TimToady> we now get an answer to that from camelia

[18:57] <jnthn> brrt: Thanks, got a fix for #127 locally

[18:57] <brrt> jnthn++

[18:57] <TimToady> even if it's still the wrong answer in the first 57 spots

[18:58] <jnthn> Nemozem inline le getlexouter... :)

[18:58] <TimToady> wow, and that's the exact bug I hit...how lucky I am! :)

[18:59] <brrt> :-)

[19:00] <TimToady> escape analysis should be really easy on anonymous variables

[19:00] <jnthn> Pushed the fix.

[19:01] <brrt> jnthn++

[19:01] *** rindolf left
[19:01] <jnthn> And yeah, guess that one got lost in my travel blind spot :)

[19:01] <FROGGS> o/

[19:02] <jnthn> o/ FROGGS 

[19:02] *** rindolf joined
[19:03] <TimToady> jnthn: you weren't living in interesting times

[19:03] <brrt> \o FROGGS

[19:04] <TimToady> good grief, how did it get to be lunchtime already?

[19:04] <jnthn> You think you got it bad. It's got to be 3am here... :P

[19:05] <TimToady> which city?

[19:05] <jnthn> Shenzhen

[19:05] <TimToady> wow, I even know where that is now...

[19:05] <jnthn> :)

[19:05] <FROGGS> m: [&baz]

[19:06] <camelia> rakudo-moar 32cb14: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/bDTNoZdkZUâ¤Undeclared routine:â¤    &baz used at line 1. Did you mean '&bag'?â¤â¤Â»

[19:06] <jnthn> My last time in China was in Beijing. My weather app told me the sky was clear every day. I saw a blue sky one day out of 7 thanks to smog.

[19:06] <FROGGS> m: [[&baz]]

[19:06] <camelia> rakudo-moar 32cb14: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/NBXzhwwfJTâ¤Undeclared routine:â¤    &baz used at line 1. Did you mean '&bag'?â¤â¤Â»

[19:06] <FROGGS> ohh, somebody fixed that

[19:06] <jnthn> Here I've seen it every day. :)

[19:06] <jnthn> So at least the air here isn't so bad. :)

[19:08] *** Ven joined
[19:11] * Ven chuckles at colomon++'s IRC client inserting "â€¦" instead of "..."

[19:12] <colomon> Ven: it's downright evil.

[19:12] <Ven> makes backlogging a bit funier :-)

[19:13] <colomon> distressingly, I think it may be general OS X behavior instead of just my IRC client.  :\

[19:13] *** mberends left
[19:15] <TimToady> I suppose .gist could use â€¦ too

[19:16] <Ven> colomon: it is, but it doesn't happen on ,ine

[19:17] <TimToady> your l has gone commatose

[19:18] <Ven> http://stackoverflow.com/questions/19178989/is-there-a-language-with-constrainable-types <- oh, Perl6 can do that ;)

[19:18] * Ven is writing an answer

[19:19] *** rindolf left
[19:20] *** rindolf joined
[19:20] <jnthn> Time for some sleep, before I accidentally get myself back onto European time... &

[19:20] <brrt> sleep well :-)

[19:21] <TimToady> o/

[19:21] <TimToady> now we can Break All The Things

[19:23] <TimToady> actually, if .gist is supposed to be human readable, it should use etc. instead of ... :)

[19:24] <TimToady> well, ... translates better to other languages, except maybe Latin

[19:24] <Ven> http://stackoverflow.com/questions/19178989/is-there-a-language-with-constrainable-types/25574936#25574936 <- answered with PErl6 :)

[19:24] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=25574936

[19:24] <Ven> calm down, synopsebot 

[19:24] <Ven> we're not there yet.

[19:25] <brrt> m: my int $i = 8; my int $y = -3; say $i div $y;

[19:25] <camelia> rakudo-moar 32cb14: OUTPUTÂ«-3â¤Â»

[19:25] <brrt> m: my int $i = 8; my int $y = 3; say $i div $y;

[19:25] <camelia> rakudo-moar 32cb14: OUTPUTÂ«2â¤Â»

[19:25] <Ven> ^ if anybody has to fix my answer, feel free to :)

[19:26] <brrt> p6: my int $i = 8; my int $y = -3; say $i div $y;

[19:26] <camelia> rakudo-jvm 32cb14: OUTPUTÂ«(timeout)Â»

[19:26] <camelia> ..rakudo-{parrot,moar} 32cb14: OUTPUTÂ«-3â¤Â»

[19:26] <camelia> ..niecza v24-109-g48a8de3: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Malformed my at /tmp/tmpfile line 1:â¤------> [32mmy[33mâ[31m int $i = 8; my int $y = -3; say $i div [0mâ¤â¤Parse failedâ¤â¤Â»

[19:27] *** domidumont left
[19:30] <brrt> ok, i won't be complaining anymore :-) 

[19:32] <TimToady> p6: my int $i = 8; my int $y = 0; say $i div $y;

[19:32] <camelia> rakudo-jvm 1ff1d3: OUTPUTÂ«(timeout)Â»

[19:32] <camelia> ..niecza v24-109-g48a8de3: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Malformed my at /tmp/tmpfile line 1:â¤------> [32mmy[33mâ[31m int $i = 8; my int $y = 0; say $i div $[0mâ¤â¤Parse failedâ¤â¤Â»

[19:32] <camelia> ..rakudo-moar 1ff1d3: OUTPUTÂ«Division by zeroâ¤  in block <unit> at /tmp/tmpfile:1â¤â¤Â»

[19:32] <camelia> ..rakudo-parrot 1ff1d3: OUTPUTÂ«(signal )Â»

[19:33] <brrt> why does that cause a timeout on the jvm? 

[19:33] <brrt> or is that the jvm's way of dying 

[19:34] <TimToady> j: say "hi"

[19:34] <camelia> rakudo-jvm 1ff1d3: OUTPUTÂ«hiâ¤Â»

[19:34] <TimToady> beats me

[19:35] <Ven> TimToady: camelia-r-j only is able to say.

[19:35] *** Ven left
[19:36] <TimToady> m: say 1,1,*+*...*

[19:36] <camelia> rakudo-moar 1ff1d3: OUTPUTÂ«1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 70140873â€¦Â»

[19:36] <TimToady> that's better

[19:36] <TimToady> j: say 1,1,*+*...*

[19:36] <camelia> rakudo-jvm 1ff1d3: OUTPUTÂ«1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733â€¦Â»

[19:37] *** brrt left
[19:38] *** dwarring joined
[19:41] <moritz> mm: say (1, 1, *+* ... *).gist.chars

[19:41] <moritz> m: say (1, 1, *+* ... *).gist.chars

[19:41] <camelia> rakudo-moar 1ff1d3: OUTPUTÂ«1174â¤Â»

[19:45] <TimToady> 100 seems about the right limit to me; unlikely to interfere with printing small lists, and not so long it scrolls off your screen

[19:46] <TimToady> I also don't bother to check .infinite

[19:46] <TimToady> if it's not infinite, I'd have to check .elems, and that could be huge, or effectively infinite

[19:47] <TimToady> m: my @a = 1..*; say @a

[19:47] <camelia> rakudo-moar 1ff1d3: OUTPUTÂ«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 8â€¦Â»

[19:47] <TimToady> works there too

[19:56] *** mberends joined
[19:57] *** Ven joined
[19:57] *** Ven left
[20:02] *** mberends left
[20:04] *** Ven joined
[20:05] *** cognome joined
[20:13] <nwc10> jnthn: other PPC "bug" was solved with fadd779... Update to simpler MAST::Label API.

[20:14] <nwc10> ie was trying to use too old an NQP

[20:14] <raiph> .oO( subset Probability of Num where 0.0 <= * <= 1.0; ??? .oO( % of Probability always total 1.0; ??? ) )

[20:16] *** beastd joined
[20:16] *** rindolf left
[20:17] <nwc10> botherit, Rakudo still unhappy

[20:19] <Ven> sometimes, I see posts about TCL, and I really laugh.

[20:19] <Ven> Like, well, you may badmouth php, but when you see how terrible tcl is... hahaha

[20:21] *** [Sno] joined
[20:21] <[Coke]> I would say that tcl has a consistency that php lacks.

[20:22] *** molaf__ left
[20:24] <Ven> [Coke]: it's consistently offering the worst the world has to offer

[20:24] <tadzik> naah

[20:25] <zacts> I've decided to specifically put on my portfolio/resume that I don't know php, and I specifically won't do anything php related.

[20:26] <zacts> they'll have to use someone else for that

[20:26] *** MilkmanDan left
[20:27] <Ven> zacts: I put that I know it, but the last time a recruiter called for a php job, I said "sorry, I'd rather be programming"

[20:31] *** MilkmanDan joined
[20:31] <[Coke]> Ven: I respectfully disagree.

[20:31] <Ven> [Coke]: let's :)

[20:32] *** Ven left
[20:44] <nine> How can a typed private attribute of an object get a value of a different type?!

[20:45] *** ivanshmakov left
[20:46] <TimToady> binding?

[20:46] *** Ven joined
[20:46] <TimToady> m: my Int $x; $x := "foo"; say $x.WHAT

[20:46] <camelia> rakudo-moar 1ff1d3: OUTPUTÂ«Type check failed in binding; expected 'Int' but got 'Str'â¤  in any bind_error at src/vm/moar/Perl6/Ops.nqp:221â¤  in block <unit> at /tmp/2vMWNk6dgO:1â¤â¤Â»

[20:46] <TimToady> nope, checks there

[20:47] <nine> TimToady: this is the complete source of the class: https://gist.github.com/niner/11490afd74ede2af7b8b

[20:49] *** ivanshmakov joined
[20:51] <TimToady> you aren't deriving Perl5Object from Perl5Interpreter or some such?

[20:51] <nine> TimToady: not that I know of

[20:51] <TimToady> maybe the Opaque is overflowing somehow?

[20:52] <TimToady> you on 32 or 64-bit?

[20:52] <nine> 64

[20:52] <TimToady> if something is assuming 32 and something else assuming 64, you could get that sort of damage

[20:52] <nine> Changeing the order of attributes in that class changes the error message. I now get: No such method 'call' for invocant of type 'Perl6::Metamodel::ContainerDescriptor'

[20:53] <diakopte1> o_O

[20:54] <nine> And if I put a dummy Int in between those two attributes I get Cannot call method 'isa' on a null object

[20:55] <nine> I suspect, my code is not at fault here ;)

[20:55] <diakopte1> not solely, anyway ;)

[20:57] *** nbrown__ joined
[20:59] <nine> If I change the private attributes to public ones and remove the BUILD method the errors disappear.

[21:00] *** tphilipp joined
[21:03] *** itz joined
[21:03] <moritz> nine: if you make them public, but keep the BUILD, what happens?

[21:05] <nine> moritz: Cannot find method 'STORE' in submethod BUILD at /home/nine/Inline-Perl5/lib/Inline/Perl5.pm6:262

[21:06] <Ven> no cont?

[21:06] <raiph> m: subset Probability of Num where 0.0 <= * <= 1.0; # Is this a solution to question part `1` in SO question (as answered by ven++ at http://stackoverflow.com/a/25574936/1077672)? What about a solution to part `2`?

[21:06] <camelia> rakudo-moar 1ff1d3: ( no output )

[21:06] *** itz_ left
[21:06] *** dolmen joined
[21:07] <Ven> hahaha someone downvoted my perl6 answer on that SO question

[21:07] <nine> Ven: cont?

[21:07] <Ven> nine: container

[21:08] *** nbrown__ left
[21:09] *** amkrankr1leuen left
[21:10] *** amkrankruleuen joined
[21:10] *** amkrankruleuen left
[21:10] *** amkrankruleuen joined
[21:10] <moritz> nine: this is getting weirder and weirder

[21:11] *** mj41 left
[21:11] <Ven> TimToady: subsets can't get a type parameter, can they? So, we can't subset a role[::T], right?

[21:13] <nine> moritz: jnthn gave some advice: http://irclog.perlgeek.de/perl6/2014-08-29#i_9266406

[21:13] *** avuserow_ left
[21:14] * Ven 's trying to find the second part to raiph++'s answer

[21:15] <raiph> .oO( raiph thought so, in a bubbly kinda way )

[21:15] <nine> moritz: I fear I know just too little about Perl 6 to make real progress here :/

[21:16] <Ven> role DPD[::T] { has @.values where [+] == 1; }

[21:16] <Ven> raiph: ^ how does that sound?

[21:17] <raiph> m: role DPD[::T] { has @.values where [+] == 1; } # ven: really?

[21:17] <camelia> rakudo-moar 1ff1d3: OUTPUTÂ«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/da9kDOkt2Lâ¤Preceding context expects a term, but found infix == insteadâ¤at /tmp/da9kDOkt2L:1â¤------> [32mole DPD[::T] { has @.values where [+] ==[33mâ[31m 1; } # ven: really?[0mâ¤Â»

[21:17] <Ven> [+] *, whoops

[21:18] <raiph> m: role DPD[::T] { has @.values where [+] * == 1; } # ven: really!?

[21:18] <TimToady> * doesn't usually work in argument position

[21:18] <camelia> rakudo-moar 1ff1d3: OUTPUTÂ«Unhandled exception: Could not instantiate role 'DPD':â¤Not enough positional parameters passed; got 1 but expected 2â¤   at <unknown>:1  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/Perl6/Metamodel.moarvm:specialize:4294967295)â¤ from src/gen/m-Metamoâ€¦Â»

[21:18] <Ven> true.

[21:19] <raiph> m: role DPD { has @.values where [+] * == 1; }

[21:19] <camelia> rakudo-moar 1ff1d3: ( no output )

[21:19] <TimToady> * won't work there

[21:19] *** tphilipp left
[21:19] <Ven> TimToady: I'm using *.values now anyway

[21:19] <Ven> raiph: updated

[21:20] <TimToady> you still have a proecedence problem

[21:20] <Ven> 1 ==, then !

[21:20] <TimToady> or [+](@.values)

[21:21] <moritz> nine: well, the part about method sink { self } is worth trying, at least

[21:21] <TimToady> or { ([+] @$_ ) == 1 } or so

[21:21] <Ven> @.values?

[21:21] <Ven> it's a Map, just [+](.values) I think

[21:22] <TimToady> okay

[21:22] <Ven> because, well, since it's a "Map"(whatever *that* is), I switched back to $.values

[21:22] <Ven> I'll rename it...

[21:22] <dalek> Inline-Perl5: 67dfcac | moritz++ | lib/Inline/Perl5.pm6:

[21:22] <dalek> Inline-Perl5: give Perl5Object a no-op sink method

[21:22] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/67dfcac559

[21:23] <moritz> nine: if it doesn't work, just revert the commit that made the attributes private

[21:25] *** mberends joined
[21:30] *** BizarreCake left
[21:37] *** dwarring left
[21:38] *** Ven left
[21:41] *** ggoebel111119 joined
[21:46] *** guru joined
[21:46] *** guru is now known as Guest59771

[21:47] *** jdv79_ joined
[21:48] *** itz_ joined
[21:51] *** yeltzooo9 joined
[21:52] *** itz left
[21:52] *** ajr_ left
[21:52] *** jdv79 left
[22:01] *** rindolf joined
[22:02] *** cognome left
[22:03] *** cognome joined
[22:07] *** cognome left
[22:11] *** _sri joined
[22:11] *** silug joined
[22:11] *** \00 joined
[22:11] *** ingy joined
[22:11] *** sjohnson joined
[22:14] <dalek> Inline-Perl5/call_backs: 1baec29 | nine++ | / (3 files):

[22:14] <dalek> Inline-Perl5/call_backs: Implement parameterless callbacks

[22:14] <dalek> Inline-Perl5/call_backs: review: https://github.com/niner/Inline-Perl5/commit/1baec29555

[22:16] <dalek> Inline-Perl5/call_backs: 5ea1c61 | nine++ | / (2 files):

[22:16] <dalek> Inline-Perl5/call_backs: Implement passing parameters to call backs

[22:16] <dalek> Inline-Perl5/call_backs: 

[22:16] <dalek> Inline-Perl5/call_backs: We now can pass Perl 6 objects to Perl 5 code and have that code call methods

[22:16] <dalek> Inline-Perl5/call_backs: on the Perl 6 objects and pass parameters to them.

[22:16] <dalek> Inline-Perl5/call_backs: review: https://github.com/niner/Inline-Perl5/commit/5ea1c61a00

[22:16] *** Guest59771 left
[22:16] <dalek> Inline-Perl5/call_backs: 10aa036 | nine++ | / (3 files):

[22:16] <dalek> Inline-Perl5/call_backs: Implement parameterless callbacks

[22:16] <dalek> Inline-Perl5/call_backs: review: https://github.com/niner/Inline-Perl5/commit/10aa0360cc

[22:16] <dalek> Inline-Perl5/call_backs: 770eb5c | nine++ | / (2 files):

[22:16] <dalek> Inline-Perl5/call_backs: Implement passing parameters to call backs

[22:16] <dalek> Inline-Perl5/call_backs: 

[22:16] <dalek> Inline-Perl5/call_backs: We now can pass Perl 6 objects to Perl 5 code and have that code call methods

[22:16] <dalek> Inline-Perl5/call_backs: on the Perl 6 objects and pass parameters to them.

[22:16] <dalek> Inline-Perl5/call_backs: review: https://github.com/niner/Inline-Perl5/commit/770eb5cca5

[22:16] <dalek> Inline-Perl5: 10aa036 | nine++ | / (3 files):

[22:16] <dalek> Inline-Perl5: Implement parameterless callbacks

[22:16] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/10aa0360cc

[22:16] <dalek> Inline-Perl5: 770eb5c | nine++ | / (2 files):

[22:16] <dalek> Inline-Perl5: Implement passing parameters to call backs

[22:16] <dalek> Inline-Perl5: 

[22:16] <dalek> Inline-Perl5: We now can pass Perl 6 objects to Perl 5 code and have that code call methods

[22:16] <dalek> Inline-Perl5: on the Perl 6 objects and pass parameters to them.

[22:16] <dalek> Inline-Perl5: review: https://github.com/niner/Inline-Perl5/commit/770eb5cca5

[22:16] <diakopte1> dalek--

[22:19] *** mberends left
[22:21] <spider-mario> nqp on parrot builds with various -Werror=â€¦ parameters

[22:21] <spider-mario> this causes problems, as it also builds dyncall with those

[22:22] <spider-mario> but dyncall doesnâ€™t try to avoid those warnings

[22:25] *** skarn joined
[22:26] *** skarn is now known as Guest21595

[22:28] <spider-mario> and once built, it doesnâ€™t appear to know its version number

[22:28] <spider-mario> $ nqp-p --version

[22:28] <spider-mario> This is nqp version  built on parrot 6.7.0 revision 0                                                                                                         

[22:35] *** BenGoldberg left
[22:36] *** cognome joined
[22:39] *** mberends joined
[22:41] *** donaldh joined
[22:41] * donaldh noticed some spam in RT that needs deleted https://rt.perl.org/Ticket/Display.html?id=122651

[22:42] *** Guest21595 left
[22:42] *** Guest21595 joined
[22:42] *** Guest21595 is now known as skarn

[22:45] *** donaldh left
[22:46] *** cognome_ joined
[22:46] *** cognome left
[22:52] <colomon> nine++

[22:55] <spider-mario> even after patching nqp so it prints â€œThis is nqp version 2014.08 built on parrot 6.7.0 revision 0â€, Rakudoâ€™s Configure.pl thinks itâ€™s too oldâ€¦ whatâ€™s going on? :/

[22:57] <dalek> rakudo/nom: 7467ee8 | (Rob Hoelz)++ | src/core/Pod.pm:

[22:57] <dalek> rakudo/nom: Add :content in Pod::Block constructor, but warn about deprecation

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7467ee88c4

[22:58] <dalek> doc: 0a5229d | (Rob Hoelz)++ | lib/Pod/Convenience.pm6:

[22:58] <dalek> doc: Don't use deprecated contents attribute

[22:58] <dalek> doc: review: https://github.com/perl6/doc/commit/0a5229df83

[22:58] *** xragnar_ joined
[22:58] *** xragnar_ is now known as xragnar

[22:58] <hoelzro> .tell moritz I fixed up and checked the docs; they're fine now!

[22:58] <yoleaux> hoelzro: I'll pass your message to moritz.

[23:00] *** denis_boyun_ left
[23:16] *** avuserow_ joined
[23:20] *** mberends left
[23:24] *** gfldex left
[23:25] <dalek> rakudo/nom: d8c8342 | TimToady++ | src/core/List.pm:

[23:25] <dalek> rakudo/nom: first whack at implementing .plan

[23:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d8c83425a1

[23:26] *** mbaby joined
[23:26] <TimToady> > perl6 -e 'my @a = 1,2,3; @a.plan(4..*); say @a'

[23:26] <TimToady> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ...

[23:27] *** mbaby left
[23:28] <TimToady> unfortunately, hangs if you try to subscript into the lazy part

[23:28] *** mbaby joined
[23:28] <TimToady> but it's a start

[23:29] *** mbaby left
[23:29] *** je joined
[23:37] *** dolmen left
[23:37] *** itz joined
[23:38] *** nbrown__ joined
[23:38] *** cognome_ is now known as cognome

[23:38] *** mberends joined
[23:39] *** itz_ left
[23:51] *** nbrown__ left
[23:51] *** itz_ joined
[23:52] *** itz left
[23:58] *** itz joined
[23:59] *** itz_ left
