[00:00] <colomon> I have to kill it by hand to complete a smoke run.

[00:00] <TimToady> m: infix:<*>(Any,Any)

[00:00] <camelia> rakudo-moar 2e9a1d: OUTPUT«use of uninitialized value of type Any in numeric context  in block <unit> at /tmp/y0hPY59RX7:1␤␤use of uninitialized value of type Any in numeric context  in block <unit> at /tmp/y0hPY59RX7:1␤␤»

[00:01] * colomon is very happy to just to have completed a few smoke runs again, mind you.  a nice predictable hang is annoying but not fatal.

[00:01] <TimToady> m: my $any = Any.new; infix:<*>($any,$any))

[00:01] <camelia> rakudo-moar 2e9a1d: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/mTIQNd30_2␤Unexpected closing bracket␤at /tmp/mTIQNd30_2:1␤------> [32mmy $any = Any.new; infix:<*>($any,$any)[33m⏏[31m)[0m␤»

[00:01] <TimToady> m: my $any = Any.new; infix:<*>($any,$any)

[00:01] <camelia> rakudo-moar 2e9a1d: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<*> at src/gen/m-CORE.setting:4404␤  in block <unit> at /tmp/RL5Y04JVoA:1␤␤»

[00:02] *** chenryn joined
[00:04] *** telex left
[00:04] <TimToady> m: my $mu = Mu.new; infix:<*>($mu,$mu)

[00:04] <camelia> rakudo-moar 2e9a1d: OUTPUT«Cannot call 'infix:<*>'; none of these signatures match:␤:(Any $x = { ... })␤:(Any \a, Any \b)␤:(Real \a, Real \b)␤:(Int:D \a, Int:D \b --> Int)␤:(int $a, int $b --> int)␤:(Num:D \a, Num:D \b)␤:(num $a, num $b)␤:(Rational \a, Rational \b)…»

[00:05] <TimToady> m: subset Foo of Array; multi infix:<*>(Foo $, Real $) { "tada" }; say [ 0, 2 ] * 0;

[00:05] <camelia> rakudo-moar 2e9a1d: OUTPUT«tada␤»

[00:05] *** chenryn left
[00:05] <TimToady> we have a signature with Real, but not one with Numeric

[00:06] <TimToady> that might be considered an oversight

[00:06] *** telex joined
[00:10] <grondilu> well, that is weird:

[00:10] <grondilu> use Chess::PGN; say "1. e4" ~~ /<Chess::PGN::game>/;  # works

[00:10] <grondilu> use Chess::PGN; say "1. e4" ~~ /<Chess::PGN::game>+/;  # hangs

[00:10] *** dj_goku_ joined
[00:11] <TimToady> can it match ''?

[00:11] <grondilu> yes

[00:12] <TimToady> well, it's probably doing that multiple times

[00:12] <grondilu> hum

[00:12] <TimToady> maybe +? $

[00:12] <grondilu> TimToady++

[00:13] <grondilu> yes, well spotted

[00:14] <dj_goku_> so I came across this example: (*/2)(4)

[00:14] <grondilu> should give 2

[00:14] <TimToady> looks like 2 to me

[00:14] <dj_goku_> there is an implict multiplication?

[00:15] <TimToady> */2 is implicitly a closure, same as { $_ / 2 }

[00:15] <dj_goku_> reading over this btw: http://learnxinyminutes.com/docs/perl6/

[00:15] <TimToady> yeah, that's rather...terse... :)

[00:16] <dj_goku_> well for the most part I get most of it. :D

[00:16] <TimToady> couldn't hope for more :)

[00:16] <dj_goku_> I thought perl6 was a lot different from p5.

[00:17] <TimToady> it is, except where it isn't :)

[00:17] *** kurahaupo left
[00:17] <grondilu> dj_goku_: */2 is an example of what is called *autopriming* in case you want to look it in the specs

[00:18] <timotimo> other words related to this: WhateverCode

[00:18] <TimToady> we stole * from typeglobs, and used it for more interesting things

[00:20] <dj_goku_> well I guess the part I am hung up on is (.5)(4) != 2, (.5)*(4) == 2

[00:21] <grondilu> is there something between Real and Numeric that includes Complex?

[00:21] <TimToady> no

[00:22] <TimToady> the (4) is the argument to the closure

[00:22] * grondilu can probably use Real anyway

[00:22] <TimToady> so it's like sub foo ($x) { $x / 2 }; foo(4)

[00:23] <dj_goku_> oh

[00:24] <dj_goku_> so (*/2) is an anonmous sub, and (4) is calling that sub with a value of 4. Right?

[00:25] <TimToady> don't even really need the parens

[00:25] <TimToady> m: my $x = * / 2; say $x(4)

[00:25] <camelia> rakudo-moar 2e9a1d: OUTPUT«2␤»

[00:25] <TimToady> the parens are only to bind the / tighter than the .()

[00:26] <dj_goku_> interesting.

[00:26] <TimToady> can even call it as a fake method

[00:26] <TimToady> m: my $x = * / 2; say 4.$x

[00:26] <camelia> rakudo-moar 2e9a1d: OUTPUT«2␤»

[00:27] <dj_goku_> haha interesting.

[00:28] * grondilu didn't know about that

[00:30] <grondilu> oh yes it's the same as in $arg.&f

[00:30] <jack_rabbit> Is there syntax for turning an infix operator into a function?

[00:30] * timotimo knew that

[00:30] <grondilu> jack_rabbit: use the full name &infix:<symbol>

[00:31] <jack_rabbit> gotcha.

[00:31] <grondilu> m: say &infix:<+>(1, 1)

[00:31] <camelia> rakudo-moar 2e9a1d: OUTPUT«2␤»

[00:31] <grondilu> there's also .assuming

[00:32] <grondilu> (but last time I tried it was working great)

[00:32] <grondilu> *wasn't

[00:32] <grondilu> m: say &infix:<+>.assuming(*, 2)( 1)

[00:32] <camelia> rakudo-moar 5f9cd5: OUTPUT«Too many positional parameters passed; got 3 but expected between 0 and 2␤  in sub infix:<+> at src/gen/m-CORE.setting:4394␤  in sub CURRIED at src/gen/m-CORE.setting:3387␤  in block <unit> at /tmp/X_znV7HFt_:1␤␤»

[00:33] <grondilu> m: say &infix:<+>.assuming(2)( 1)

[00:34] <camelia> rakudo-moar 5f9cd5: OUTPUT«3␤»

[00:36] <TimToady> you don't need the & there

[00:36] <TimToady> just as you don't need to say &foo(1)

[00:37] <TimToady> oh, well, you need it for assuming

[00:37] <TimToady> I was loking at the first one

[00:37] <TimToady> m: say infix:<+>(1,1)

[00:37] <camelia> rakudo-moar 5f9cd5: OUTPUT«2␤»

[00:37] <TimToady> that's what I mean

[00:38] <grondilu> m: my %a{Array}; %a{[0, 1]}++ xx 2; say %a;

[00:38] <camelia> rakudo-moar 5f9cd5: OUTPUT«([0, 1] => 1, [0, 1] => 1).hash␤»

[00:39] <grondilu> n: my %a{Array}; %a{[0, 1]}++ xx 2; say %a;

[00:39] <camelia> niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Postconstraints, and shapes on variable declarators NYI at /tmp/TVsqNFGSrg line 1:␤------> [32mmy %a{Array}[33m⏏[31m; %a{[0, 1]}++ xx 2; say %a;[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6ev…»

[00:39] <grondilu> j: my %a{Array}; %a{[0, 1]}++ xx 2; say %a;

[00:39] <camelia> rakudo-jvm 5f9cd5: OUTPUT«(timeout)»

[00:39] * grondilu expected ([0, 1] => 2).hash

[00:40] <grondilu> was I asking too much or something?

[00:40] <grondilu> because I realize consolidating on structured keys must be complicated.

[00:41] <grondilu> j: my %a{Array}; %a{[]}++ xx 2; say %a;

[00:41] <camelia> rakudo-jvm 5f9cd5: OUTPUT«([] => 1, [] => 1).hash␤»

[00:41] <grondilu> m: my %a{Array}; %a{[]}++ xx 2; say %a;

[00:41] <camelia> rakudo-moar 5f9cd5: OUTPUT«([] => 1, [] => 1).hash␤»

[00:42] *** Mouq joined
[00:42] <Mouq> ping!

[00:42] <yoleaux> 26 Aug 2014 11:13Z <moritz> Mouq: FYI, perl6/doc htmlify.p6 now needs latest rakudo + latest Pod::To::HTML

[00:43] <Mouq> m: say [0, 1].WHICH

[00:43] <camelia> rakudo-moar 5f9cd5: OUTPUT«Array|55709040␤»

[00:43] <Mouq> grondilu: ^^

[00:44] * grondilu is not sure what WHICH is.

[00:44] <Mouq> m: say set(0,1).WHICH # for example

[00:44] <camelia> rakudo-moar 5f9cd5: OUTPUT«Set|Int|0 Int|1␤»

[00:44] <Mouq> .WHICH is an object's unique ID

[00:44] <grondilu> hum

[00:44] <timotimo> hey there mouq!

[00:44] <timotimo> how are you doing? :)

[00:45] <Mouq> An Array can be pushed to, so can't get a unique ID based on its values

[00:45] <grondilu> if which is what is used in a typed array that's not really helpful

[00:45] <Mouq> timotimo: Hey! Decent, hbu?

[00:45] <Mouq> timotimo: Just finished my first week of college, lots of fun and work :)

[00:47] <grondilu> m: say .WHICH for [] xx 3

[00:47] <camelia> rakudo-moar 5f9cd5: OUTPUT«Array|55509952␤Array|55510016␤Array|55510080␤»

[00:47] <timotimo> i'm all right :)

[00:48] <Mouq> m: say $(0, 1).WHICH # Hmmmm

[00:48] <camelia> rakudo-moar 5f9cd5: OUTPUT«Parcel|73234664␤»

[00:49] <grondilu> I read in S02 that WHICH is supposed to give the same output for objects that have the same content value.

[00:51] <grondilu> so it's kind of like a marshalization or something, isn't it?

[00:51] <Mouq> m: my @a; my @b; say set($@a, $@b)

[00:51] <camelia> rakudo-moar 5f9cd5: OUTPUT«set(, )␤»

[00:51] <Mouq> m: my @a; my @b; say set($@a, $@b).WHICH

[00:51] <camelia> rakudo-moar 5f9cd5: OUTPUT«Set|Array|80678544 Array|80678608␤»

[00:51] <Mouq> @a and @b can be changed after the creation of the set

[00:52] <grondilu> oh ic

[00:53] <grondilu> well, no I don't.

[00:54] <grondilu> what's the difference with WHERE then?

[00:54] <grondilu> m: say .WHERE for [] xx 3

[00:54] <camelia> rakudo-moar 5f9cd5: OUTPUT«139868124857736␤139868124869416␤139868124874136␤»

[00:54] * Mouq didn't know WHERE was a thing

[00:54] *** zacts left
[00:55] <timotimo> Mouq: on moarvm you can use nativecast and a CStruct repr to reach right into an MVMObjects internal stuff by getting its WHERE :D

[00:55] <grondilu> m: (my %a{Array}){[]}++ xx 2; say %a

[00:55] <camelia> rakudo-moar 5f9cd5: OUTPUT«([] => 1, [] => 1).hash␤»

[00:55] <Mouq> :O

[00:56] <Mouq> m: (my %a{Array}){@}++ xx 2; say %a

[00:56] <camelia> rakudo-moar 5f9cd5: OUTPUT«No such method 'succ' for invocant of type 'Parcel'␤  in sub postfix:<++> at src/gen/m-CORE.setting:1942␤  in block <unit> at /tmp/kRTrOOW_EO:1␤␤»

[00:56] <grondilu> m: (my %a{Array}){[]}++ xx 2; say %a # should really return ([] => 2).hash IMHO

[00:56] <camelia> rakudo-moar 5f9cd5: OUTPUT«([] => 1, [] => 1).hash␤»

[00:56] <Mouq> m: (my %a{Array}){$@}++ xx 2; say %a

[00:56] <camelia> rakudo-moar 5f9cd5: OUTPUT«([] => 2).hash␤»

[00:56] <grondilu> the very idea of ([] => 1, [] => 1).hash is just wrong to me

[00:57] *** xenoterracide joined
[00:57] * grondilu looks at Mouq's solution

[00:57] <Mouq> m: say 1.WHERE

[00:57] <camelia> rakudo-moar 5f9cd5: OUTPUT«140483368194624␤»

[00:58] <grondilu> m: (my %a{Array}){$([0, 1])}++ xx 2; say %a

[00:58] <camelia> rakudo-moar 5f9cd5: OUTPUT«([0, 1] => 1, [0, 1] => 1).hash␤»

[00:58] <grondilu> m: (my %a{Array}){static @ = [0, 1]}++ xx 2; say %a

[00:58] <camelia> rakudo-moar 5f9cd5: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/JvrMw2Nu6L␤Undeclared routine:␤    static used at line 1␤␤»

[00:59] <Mouq> m: (my %a{Array}){$=[0,1]}++ xx 2; say %a # bare sigil variables are stateful now, I believe

[00:59] <camelia> rakudo-moar 5f9cd5: OUTPUT«([0, 1] => 1, [0, 1] => 1).hash␤»

[00:59] <grondilu> m: (my %a{Array}){state @ = [0, 1]}++ xx 2; say %a

[00:59] <camelia> rakudo-moar 5f9cd5: OUTPUT«No such method 'succ' for invocant of type 'Parcel'␤  in sub postfix:<++> at src/gen/m-CORE.setting:1942␤  in block <unit> at /tmp/m9wnGPuYXV:1␤␤»

[00:59] <Mouq> m: (my %a{Array}){state$=[0,1]}++ xx 2;

[00:59] <camelia> rakudo-moar 5f9cd5: OUTPUT«Unhandled exception: cannot stringify this␤   at src/gen/m-BOOTSTRAP.nqp:831  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/Perl6/BOOTSTRAP.moarvm:bind_sig:128)␤ from src/gen/m-CORE.setting:9982  (/home/p6eval/rakudo-inst-2/languages/perl6/runtime/CORE…»

[00:59] <Mouq> Uhh

[01:02] <TimToady> m: my @a = [1,2]; my @b = [3,4]; my $s = set($@a, $@b); say $s; push @b, 5; say $s

[01:02] <camelia> rakudo-moar 5f9cd5: OUTPUT«set(1 2, 3 4)␤set(1 2, 3 4 5)␤»

[01:02] <grondilu> m: my %a{Array}; my %a{[]} = $++ for ^3; say %a{[]}

[01:02] <camelia> rakudo-moar 5f9cd5: OUTPUT«Potential difficulties:␤    Redeclaration of symbol %a␤    at /tmp/qu6Mf2votq:1␤    ------> [32mmy %a{Array}; my %a{[]} [33m⏏[31m= $++ for ^3; say %a{[]}[0m␤Odd number of elements found where hash initializer expected␤  in method STORE at s…»

[01:02] <TimToady> the identity of a container is its containerness, not its contents

[01:03] *** xenoterracide left
[01:03] <TimToady> lvalues are abstract locations, unlike rvalues, which are not

[01:04] <grondilu> ok.  So I should not use Arrays for my keys, but rather an immutable type, right?

[01:04] <TimToady> yes

[01:04] <grondilu> m: say (1, 2).WHAT

[01:04] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Parcel)␤»

[01:04] <TimToady> m: my %a{Array}; %a{[]} = $++ for ^3; say %a.keys

[01:04] <camelia> rakudo-moar 5f9cd5: OUTPUT«  ␤»

[01:05] <TimToady> m: my %a{Array}; %a{[]} = $++ for ^3; say %a.elems

[01:05] <camelia> rakudo-moar 5f9cd5: OUTPUT«3␤»

[01:05] <grondilu> m: my %a{Parcel}; %a{(1, 2)}++; say %

[01:05] <camelia> rakudo-moar 5f9cd5: OUTPUT«cannot stringify this␤  in method at_key at src/gen/m-CORE.setting:9982␤  in sub postcircumfix:<{ }> at src/gen/m-CORE.setting:2792␤  in sub postcircumfix:<{ }> at src/gen/m-CORE.setting:2827␤  in block <unit> at /tmp/gjNResNTOc:1␤␤»

[01:05] <grondilu> m: my %a{Parcel}; %a{(1, 2)}++; say %a

[01:05] <camelia> rakudo-moar 5f9cd5: OUTPUT«cannot stringify this␤  in method at_key at src/gen/m-CORE.setting:9982␤  in sub postcircumfix:<{ }> at src/gen/m-CORE.setting:2792␤  in sub postcircumfix:<{ }> at src/gen/m-CORE.setting:2827␤  in block <unit> at /tmp/hhdiomRPYF:1␤␤»

[01:05] <grondilu> m: my %a{Parcel}; %a{(1, 2).item}++; say %a

[01:05] <camelia> rakudo-moar 5f9cd5: OUTPUT«($(1, 2) => 1).hash␤»

[01:05] *** jerrycheung left
[01:05] <grondilu> m: my %a{Parcel}; %a{(1, 2).item}++ xx 2; say %a

[01:05] <camelia> rakudo-moar 5f9cd5: OUTPUT«($(1, 2) => 2).hash␤»

[01:05] <grondilu> \o/

[01:05] <TimToady> m: say (1,2) === (1,2)

[01:05] <camelia> rakudo-moar 5f9cd5: OUTPUT«False␤»

[01:06] <grondilu> m: my %a{Parcel}; %a{(1, 2).item}++ xx 10; say %a

[01:06] <camelia> rakudo-moar 5f9cd5: OUTPUT«($(1, 2) => 10).hash␤»

[01:06] <grondilu> m: my %a{Parcel}; %a{().item}++ xx 10; say %a

[01:06] <camelia> rakudo-moar 5f9cd5: OUTPUT«($( ) => 10).hash␤»

[01:06] <grondilu> cool

[01:06] <TimToady> we only sort of have an immutable tuple type

[01:06] <grondilu> you mean apart from Parcel?

[01:06] <TimToady> m: say (1,2).WHICH

[01:06] <camelia> rakudo-moar 5f9cd5: OUTPUT«Parcel|63731816␤»

[01:07] <Mouq> TimToady: Should that be more like Parcel|Int|1 Int|2 ?

[01:07] <TimToady> it's counting itself as a container, albeit an immutable container

[01:07] <TimToady> it can contain mutables though, ($x,$y)

[01:07] <grondilu> for all intends and purposes, can I consider that Parcel is Perl6's Tuple?

[01:07] <TimToady> but probably we should think about that more

[01:08] *** FROGGS_ joined
[01:08] <TimToady> well, we just said its WHICH is not exactly value based yet

[01:08] <TimToady> oops, being called (again) to dinner &

[01:09] *** zacts joined
[01:09] *** aborazmeh joined
[01:11] *** FROGGS left
[01:12] <grondilu> m: my %a{Parcel}; %a{().item}++; $a{().item}++; say %a

[01:12] <camelia> rakudo-moar 5f9cd5: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/JPx1Nug6g7␤Variable '$a' is not declared. Did you mean '%a'?␤at /tmp/JPx1Nug6g7:1␤------> [32m%a{Parcel}; %a{().item}++; $a{().item}++[33m⏏[31m; say %a[0m␤    expecting any of:␤     …»

[01:12] <grondilu> m: my %a{Parcel}; %a{().item}++; %a{().item}++; say %a

[01:12] <camelia> rakudo-moar 5f9cd5: OUTPUT«($( ) => 1, $( ) => 1).hash␤»

[01:12] <grondilu> indeed.  Not value based.

[01:12] * grondilu is disappointed

[01:14] <Mouq> m: my %a{Capture}; %a{\(0,1)}++; %a{\(0,1)}++; say %a

[01:14] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Capture.new(list => (0, 1,)) => 2).hash␤»

[01:14] <Mouq> Hack-y..

[01:15] <grondilu> That looks acceptable

[01:15] <grondilu> m: my %a{Capture}; %a{\(0,1)}++ xx 4; say %a

[01:15] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Capture.new(list => (0, 1,)) => 4).hash␤»

[01:16] <grondilu> m: my %a{Capture}; %a{\()}++ xx 4; say %a

[01:16] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Capture.new() => 4).hash␤»

[01:16] <grondilu> Mouq++

[01:16] <grondilu> I think I can use that.

[01:17] <grondilu> though I would need to convert a Capture into a list or array at some point.

[01:17] <grondilu> m: say (\(0, 1))[0]

[01:17] <camelia> rakudo-moar 5f9cd5: OUTPUT«0␤»

[01:17] <grondilu> m: say (\(0, 1))[].WHAT

[01:17] <camelia> rakudo-moar 5f9cd5: OUTPUT«(List)␤»

[01:17] <grondilu> m: say (\(0, 1))[*]

[01:17] <camelia> rakudo-moar 5f9cd5: OUTPUT«0 1␤»

[01:17] <grondilu> well, that was easy

[01:18] <Mouq> :)

[01:20] <grondilu> I've just tried in what I was currently doing, and it actually works.  Thanks.

[01:21] <grondilu> It's a pity we don't have a Tuple type, though.

[01:21] *** zoosha left
[01:24] <TimToady> well, just derive from Parcel and override its WHICH :)

[01:25] <TimToady> actually, we should simply make a Parcel's WHICH derived from the component WHICHs

[01:26] <TimToady> which will automatically account for the value/container distinction of its components

[01:26] <grondilu> Capture is actually more convenient because I don't have to use .item to prevent flattening

[01:26] <TimToady> well, that too

[01:26] <TimToady> m: say \(1,2).WHICH

[01:26] <camelia> rakudo-moar 5f9cd5: OUTPUT«Capture|(Int|1)(Int|2)␤»

[01:26] <TimToady> oh, that's already correct

[01:27] <grondilu> m: say \(1,2).WHICH xx 2

[01:27] <camelia> rakudo-moar 5f9cd5: OUTPUT«Capture|(Int|1)(Int|2) Capture|(Int|1)(Int|2)␤»

[01:27] <TimToady> parcels should really work the same way

[01:28] *** diakopte1 is now known as diakopter

[01:30] <grondilu> though the cleanest would probably to define my own type, allow instanciation with a circumfix:«e[,]»(Int *@), and define my own WHICH

[01:31] <TimToady> parcels ought to act like tuples

[01:31] <grondilu> yeah but frankly, I hate to work with them.  Their behavior is kind of odd

[01:31] <TimToady> though you'd want a decont-ish constructor

[01:33] <TimToady> what bothers you

[01:33] <TimToady> ?

[01:33] <grondilu> flattening, for one

[01:33] <TimToady> well, that's lazy

[01:33] <TimToady> parcels are completely agnostic on the subject

[01:34] <TimToady> m: my $p := (1,(1,2),3); say $p.elems

[01:34] <camelia> rakudo-moar 5f9cd5: OUTPUT«4␤»

[01:34] <grondilu> oh, then I guess that's me not mastering the flattening rules in Perl 6.  Not too surprising.  That's one thing I need to improve on.

[01:34] <TimToady> ah, that's .elems flattinging it

[01:34] <TimToady> m: my $p := (1,(1,2),3); say $p.lolelems

[01:34] <camelia> rakudo-moar 5f9cd5: OUTPUT«No such method 'lolelems' for invocant of type 'Parcel'␤  in block <unit> at /tmp/6Sra52YjSn:1␤␤»

[01:34] <TimToady> m: my $p := (1,(1,2),3); say $p.lol.elems

[01:34] <camelia> rakudo-moar 5f9cd5: OUTPUT«3␤»

[01:35] <TimToady> m: my $p := (1,(1,2),3); say $p.flat.elems

[01:35] <camelia> rakudo-moar 5f9cd5: OUTPUT«4␤»

[01:36] <TimToady> m: my $p := (1,(1,2),3); say $p.count

[01:36] <camelia> rakudo-moar 5f9cd5: OUTPUT«No such method 'count' for invocant of type 'Parcel'␤  in block <unit> at /tmp/uQ38UvjzSY:1␤␤»

[01:36] <TimToady> hmm, I thought we have a raw method of some sort for that

[01:36] <TimToady> m: my $p := (1,(1,2),3); say $p.^methods

[01:36] <camelia> rakudo-moar 5f9cd5: OUTPUT«BUILD Parcel Capture elems item flat list lol reverse rotate at_pos STORE FLATTENABLE_LIST FLATTENABLE_HASH fmt of Bool Numeric Str ACCEPTS gist perl DUMP␤»

[01:37] *** jerrycheung joined
[01:38] <TimToady> n: my $p := (1,(1,2),3); say $p.elems

[01:38] <camelia> niecza v24-109-g48a8de3: OUTPUT«3␤»

[01:38] <TimToady> yes, it's not flattening in niecza

[01:38] <grondilu> do you think Parcel.WHICH will behave as Capture.WHICH any time soon?

[01:39] <TimToady> dunno, seems like an easy fix

[01:39] <TimToady> and I could be argued into making .elems return 3

[01:39] <TimToady> if we're going to make parcel behave more like an official tuple type

[01:39] <grondilu> well, if as you said Parcel are agnostic regarding flattening, then Parcel.elems is not defined, is it?

[01:40] <TimToady> well, it just implies that you requested flattening currently, but we could undo that

[01:40] <TimToady> .map is the same way

[01:41] <grondilu> ok

[01:41] <grondilu> wouldn't it be simpler to have a Tuple type, though?

[01:41] <TimToady> not if parcel already is one

[01:42] <grondilu> well, yeah I guess.

[01:42] <TimToady> we do need a better way of calling nqp::decont though

[01:43] * grondilu does not know what that is

[01:44] <Mouq> m: my $a = 4; my $b = ($a,); $b[0] = 5

[01:44] <camelia> rakudo-moar 5f9cd5: ( no output )

[01:45] <Mouq> m: my $a = 4; my $b = (nqp::decont($a),); $b[0] = 5

[01:45] <camelia> rakudo-moar 5f9cd5: OUTPUT«Cannot modify an immutable Int␤  in method assign_pos at src/gen/m-CORE.setting:1867␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2566␤  in block <unit> at /tmp/JLLol1Fa0F:1␤␤»

[01:45] *** Mouq left
[01:49] *** aborazmeh left
[01:49] <grondilu> oh, "decontenarize".  I could have guessed that.

[01:49] <TimToady> so we need a tuple constructer that deconts, probably

[01:49] <TimToady> or a method, or something

[01:50] <grondilu> wouldn't it need its own syntax?

[01:50] <TimToady> depends on when you want it bound

[01:50] <TimToady> you can write (1, (2,3), 4).decont right now with a bit of monkey typing

[01:50] <grondilu> maybe a "freeze" method.

[01:50] <TimToady> well, I'd hope for something shorter, but yeah

[01:51] <grondilu> though "decont" is probably fine

[01:51] <TimToady> well, that's the jargon, but I don't really like it

[01:51] <grondilu> a unicode braket maybe?

[01:51] *** aborazmeh joined
[01:51] *** jerrycheung left
[01:53] <TimToady> maybe, but perhaps decont should be decoupled from that

[01:53] <TimToady> (decont 1, (2,3), 4)

[01:53] <TimToady> if it were a listop, for instance

[01:53] <TimToady> though I note that [1,(2,3),4] has both flattening and decont built in

[02:00] <TimToady> well, decont and then recont inside the array

[02:01] <grondilu> S-expressions are cool.  If we had native support for them, we could make immutable types easily, couldn't we?

[02:01] <grondilu> like  my $a = (1, 2).S

[02:02] <TimToady> Lisp doesn't consider s-exprs to be immutable

[02:02] <grondilu> oh, doesn't it?  My bad, then.

[02:03] <TimToady> that's sort of a later notion in FP

[02:03] <TimToady> in Lisp it's more convention

[02:03] <grondilu> I thought everything was immutable in FP

[02:04] <TimToady> well, Lisp likes to think of itself as FP, but doesn't enforce it

[02:04] <diakopter> not when you write interpreters and monads to simulate mutating state!

[02:05] <diakopter> ^ (whether everything is immutable in FP)

[02:06] <grondilu> what about my $a = constant (1, 2)   ?

[02:06] <grondilu> or even:

[02:07] <grondilu> what about my $a = constant $ = (1, 2)   ?

[02:07] <TimToady> doesn't decont

[02:07] <grondilu> m: my $a = constant $ = (1, 2); $a[]

[02:07] <camelia> rakudo-moar 5f9cd5: ( no output )

[02:07] <grondilu> m: my $a = constant $ = (1, 2); say $a[]

[02:07] <camelia> rakudo-moar 5f9cd5: OUTPUT«1 2␤»

[02:07] <grondilu> m: my $a = constant $ = (1, 2); $a[0] = pi; say $a

[02:07] <camelia> rakudo-moar 5f9cd5: OUTPUT«Cannot modify an immutable Int␤  in method assign_pos at src/gen/m-CORE.setting:1867␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2566␤  in block <unit> at /tmp/7Kdcutzjon:1␤␤»

[02:07] <TimToady> m: my $x = 42; constant a = (1,$x);  $x = 43; say a

[02:07] <camelia> rakudo-moar 5f9cd5: OUTPUT«1 (Any)␤»

[02:07] <TimToady> oh, duh

[02:08] <TimToady> m: my $x; BEGIN $x = 42; constant a = (1,$x);  $x = 43; say a

[02:08] <camelia> rakudo-moar 5f9cd5: OUTPUT«1 42␤»

[02:08] <TimToady> I guess it deconts

[02:08] <TimToady> m: my $x; BEGIN $x = 42; constant a := (1,$x);  $x = 43; say a

[02:08] <camelia> rakudo-moar 5f9cd5: OUTPUT«1 42␤»

[02:09] <TimToady> makes sense, for constant

[02:09] <grondilu> a constant is not a type though, so I can't make a typed array for it, can I?

[02:09] <TimToady> I think the type can stay tuple

[02:09] <TimToady> er, parcel

[02:11] <grondilu> but I can not create something like that at runtime.

[02:12] <grondilu> (which is very restricting)

[02:13] <TimToady> m: sub fix (|c) { c.deepmap: { nqp::decont($_) } }; say(fix 1,(2,3),4).perl

[02:13] <camelia> rakudo-moar 5f9cd5: OUTPUT«:(1, 2, 3, 4)␤»

[02:14] <grondilu> m: sub fix (|c) { c.deepmap: { nqp::decont($_) } }; say(fix 1,(2,3),4).WHICH xx 2

[02:14] <camelia> rakudo-moar 5f9cd5: OUTPUT«:(1, 2, 3, 4)␤:(1, 2, 3, 4)␤»

[02:14] <TimToady> hmm

[02:14] <grondilu> that would do

[02:14] <TimToady> deepmap shouldn't flatten

[02:15] <TimToady> m: sub fix (|c) { c.deepmap: { nqp::decont($_) } }; say(fix 1,(2,3),4).WHAT

[02:15] <camelia> rakudo-moar 5f9cd5: OUTPUT«:(1, 2, 3, 4)␤»

[02:15] <TimToady> oops

[02:15] <TimToady> m: sub fix (|c) { c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,3),4).WHAT

[02:15] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Parcel)␤»

[02:15] <grondilu> the say takes it all

[02:15] <TimToady> m: sub fix (|c) { c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,3),4).perl

[02:15] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Capture.new(list => (1, 2, 3, 4,)),)␤»

[02:15] <grondilu> m: sub fix (|c) { c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,3),4).WHICH xx 2

[02:15] <camelia> rakudo-moar 5f9cd5: OUTPUT«Parcel|74683024 Parcel|74683224␤»

[02:16] <TimToady> deepmap still failing

[02:16] <grondilu> m: sub fix (|c) { c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,3),4).WHAT

[02:16] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Parcel)␤»

[02:16] <TimToady> m: sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,3),4).perl

[02:16] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, 3), 4)␤»

[02:16] <TimToady> that's betterish

[02:16] <TimToady> m: sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,<buckle my shoe>),4).perl

[02:16] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, ("buckle", "my", "shoe")), 4)␤»

[02:17] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,@foo),4).perl

[02:17] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, Array.new("buckle", "my", "shoe")), 4)␤»

[02:18] <TimToady> hmm, deepmap not descending into @foo, I guess

[02:18] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,$@foo),4).perl

[02:18] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, ["buckle", "my", "shoe"]), 4)␤»

[02:18] <TimToady> anyway, decont is failing on that level

[02:20] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,\@foo),4).perl

[02:20] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, Capture.new(list => ("buckle", "my", "shoe",))), 4)␤»

[02:20] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,@foo.list),4).perl

[02:20] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, Array.new("buckle", "my", "shoe")), 4)␤»

[02:20] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,@foo.Parcel),4).perl

[02:20] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, (ListIter.new(),)), 4)␤»

[02:21] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (fix 1,(2,fix @foo),4).perl

[02:21] <camelia> rakudo-moar 5f9cd5: OUTPUT«(1, (2, (["buckle", "my", "shoe"],)), 4)␤»

[02:21] <TimToady> hmm, that's wrongish

[02:21] <TimToady> anyway, it's not so far off of being there

[02:22] *** nbrown__ joined
[02:22] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (1,(2,@foo),4).tree(*.&fix).perl

[02:22] <camelia> rakudo-moar 5f9cd5: OUTPUT«(((1, 2, "buckle", "my", "shoe", 4),).list.item,)␤»

[02:23] <TimToady> m: my @foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (1,(2,$@foo),4).tree(*.&fix).perl

[02:23] <camelia> rakudo-moar 5f9cd5: OUTPUT«(((1, 2, ["buckle", "my", "shoe"], 4),).list.item,)␤»

[02:24] <TimToady> the question is whether the tuple contains a reference or a copy of @foo

[02:24] <grondilu> m: my $foo = <buckle my shoe>; sub fix (**@c) { @c.deepmap: { nqp::decont($_) } }; say (1,(2,$foo),4).tree(*.&fix).perl

[02:24] <camelia> rakudo-moar 5f9cd5: OUTPUT«(((1, 2, ("buckle", "my", "shoe"), 4),).list.item,)␤»

[02:25] * TimToady regrets the spam

[02:25] <TimToady> m: say (1,(2,3),4)[2]

[02:25] <camelia> rakudo-moar 5f9cd5: OUTPUT«3␤»

[02:26] *** nbrown__ left
[02:32] *** jerrycheung joined
[02:32] *** noganex joined
[02:32] <grondilu> m: .say for *..*

[02:33] *** xenoterracide joined
[02:33] <grondilu> ^ just trolling :)

[02:33] <camelia> rakudo-moar 5f9cd5: OUTPUT«(timeout)-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-I…»

[02:33] <grondilu> lol, makes sense.

[02:33] <TimToady> you'll note that it didn't time out :)

[02:33] <TimToady> oh wait, it di

[02:33] <TimToady> m: say *..*

[02:33] <camelia> rakudo-moar 5f9cd5: OUTPUT«-Inf..Inf␤»

[02:34] <TimToady> m: say (*..*).list

[02:34] <camelia> rakudo-moar 5f9cd5: OUTPUT«-Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -…»

[02:34] <TimToady> that one didn't :)

[02:34] <grondilu> that's kind of awesome

[02:34] <TimToady> m: say (*..*).reverse

[02:34] <camelia> rakudo-moar 5f9cd5: OUTPUT«Cannot .reverse from an infinite list␤  in method gist at src/gen/m-CORE.setting:13276␤  in sub say at src/gen/m-CORE.setting:14211␤  in block <unit> at /tmp/4ntEakyBKC:1␤␤»

[02:34] <TimToady> aww

[02:35] <grondilu> you were hoping for +Int +Inf ....

[02:35] <grondilu> ?

[02:35] <TimToady> kinda :)

[02:35] <TimToady> kinda not :)

[02:35] *** noganex_ left
[02:36] <TimToady> thing is, there's no such range as +Inf .. -Inf, since that's just ()

[02:36] <TimToady> ranges are not autoreversing

[02:36] <grondilu> oh yeah indeed

[02:36] *** BenGoldberg left
[02:38] <grondilu> m: say grep * > 0, *..*;  # no way that would work, right?

[02:38] <camelia> rakudo-moar 5f9cd5: OUTPUT«(timeout)»

[02:38] <TimToady> maybe "snap", for take a snapshot of the tuple

[02:39] <grondilu> m: say first * > 0, *..*;  # no way that would work, right?

[02:39] <TimToady> seems unlikely

[02:39] <camelia> rakudo-moar 5f9cd5: OUTPUT«(timeout)»

[02:39] <TimToady> we're not trying to invent algebra

[02:40] *** colomon left
[02:44] *** jerrycheung left
[02:44] <TimToady> m: say *..* minmax 0..*

[02:44] <camelia> rakudo-moar 5f9cd5: OUTPUT«(timeout)»

[02:44] <TimToady> hmm

[02:44] <TimToady> that oughta work

[02:44] <TimToady> m: say (*..*) minmax (0..*)

[02:45] <camelia> rakudo-moar 5f9cd5: OUTPUT«(timeout)»

[02:46] <TimToady> m: say (*..*).bounds minmax (0..*).bounds

[02:46] <camelia> rakudo-moar 5f9cd5: OUTPUT«-Inf..Inf␤»

[02:47] <TimToady> I guess that expands, it doesn't contract

[02:48] <TimToady> well, see http://rosettacode.org/wiki/Set_of_real_numbers#Perl_6

[02:49] *** nbrown__ joined
[02:50] *** kjs_ joined
[02:53] *** nbrown__ left
[02:56] *** njmurphy joined
[02:58] *** aborazmeh left
[02:58] <grondilu> "relatively simple are the convex sets"

[02:58] <grondilu> I think what is meant is, is "connex"

[02:59] * grondilu corrects it

[03:00] * grondilu checks and realizes the correct word is "connected"

[03:01] <grondilu> ("connexe" being the French word)

[03:04] <masak> grondilu: no, it should be "convex".

[03:05] <masak> (good time-of-day, #perl6)

[03:05] * grondilu looks up "convex"

[03:05] <TimToady> yes, no "holes"

[03:05] <TimToady> caves are holes

[03:06] <masak> "In Euclidean space, an object is convex if for every pair of points within the object, every point on the straight line segment that joins the pair of points is also within the object." -- https://en.wikipedia.org/wiki/Convex_set

[03:06] <masak> that analogy is valid down to 1-space, the real line.

[03:06] <TimToady> not what a topologist calls a "hole" of course

[03:07] <masak> I think the term "convex hull" could've worked here, too.

[03:07] <diakopter> heh

[03:07] *** PZt left
[03:07] <grondilu> Fine.  Reverting to convex.

[03:13] <masak> grondilu++ # shared learning

[03:18] *** rindolf joined
[03:20] *** aborazmeh joined
[03:22] *** xenoterracide left
[03:26] *** aborazmeh left
[03:41] *** firefish5000 left
[03:42] <masak> TimToady: I recently dipped into algebraic topology. result: I now have an eerie sense of what a hole "feels" like if you're a group.

[03:50] *** kjs_ left
[03:54] <masak> hoelzro: congratulations on your upcoming marriage!

[03:54] <masak> it may be an institution, but it's one to which many of us are happy to be committed. :P

[03:56] <TimToady> last SciAm has an article indicate we may have been largely monogamous for the last N million years, and that this perhaps accounts for some of our social skills as a species

[03:56] <masak> also, hoelzro++ # docker image

[03:58] *** Alina-malina joined
[04:00] <jack_rabbit> Hey, would someone take a look at this? I must be missing something obvious. http://lpaste.net/110283

[04:00] <jack_rabbit> The error is: Type 'HTTPParser::Request' is not declared at HTTPParser.p6:72

[04:02] *** njmurphy left
[04:03] <TimToady> I would guess that you're clobbering the previous HHTPParser package somehow; maybe try stubbing class HTTPParser {...} at the front

[04:04] <masak> m: sub circumfix:<ev[ ]>(*@L) { die "List needs an even number of elements, but got @L.elems()" unless @L %% 2; @L }; say ev[ 1, 2, 3, 4 ].perl

[04:04] <camelia> rakudo-moar 5f9cd5: OUTPUT«Array.new(1, 2, 3, 4)␤»

[04:04] <masak> m: sub circumfix:<ev[ ]>(*@L) { die "List needs an even number of elements, but got @L.elems()" unless @L %% 2; @L }; say ev[ 1, 2, 3 ].perl

[04:04] <camelia> rakudo-moar 5f9cd5: OUTPUT«List needs an even number of elements, but got 3␤  in sub circumfix:<ev[ ]> at /tmp/MjBtAROxkq:1␤  in block <unit> at /tmp/MjBtAROxkq:1␤␤»

[04:04] <masak> grondilu: ^^ that's how I'd do the even-item lists thing

[04:04] <TimToady> or stub the Request class and then declare the parent package name next

[04:04] <masak> in fact, I would try it with multis, but that gave me suspicious errors. golfing.

[04:05] <jack_rabbit> TimToady, can you see quite how?

[04:05] <jack_rabbit> TimToady, Should I put literally class HTTPParser {}; at the beginning?

[04:05] *** xenoterracide joined
[04:05] <TimToady> I mean ... literally

[04:06] <TimToady> that will tell the later def that it's redefining, and perhaps not clobber the existing contents of the package

[04:06] <grondilu> masak: yeah I thought about using circumfix as well.  Not decided yet.

[04:07] <TimToady> "class Foo {...}" is how you stub a class

[04:07] <masak> grondilu: I don't know if it's just impl weakness -- probably -- but I find that `subset` and `where` still falls short of doing manual precondition testing.

[04:07] <TimToady> if you need a forward reference

[04:07] <masak> ooh.

[04:07] <jack_rabbit> TimToady, weird. That seems to work.

[04:07] <jack_rabbit> TimToady, can you tell why it's clobbering?

[04:07] <masak> m: sub circumfix:<ev[ ]>(*@L) { PRE { @L %% 2 }; @L }; say ev[ 1, 2, 3 ].perl

[04:07] <camelia> rakudo-moar 5f9cd5: OUTPUT«Precondition '{ @L %% 2 }' failed␤  in sub circumfix:<ev[ ]> at /tmp/AH7DRG4w1q:1␤  in block <unit> at /tmp/AH7DRG4w1q:1␤␤»

[04:07] <masak> better :)

[04:08] <masak> m: sub circumfix:<ev[ ]>(*@L) { PRE { @L %% 2 }; @L }; say ev[ 1, 2, 3, 4 ].perl

[04:08] <camelia> rakudo-moar 5f9cd5: OUTPUT«Array.new(1, 2, 3, 4)␤»

[04:08] <TimToady> ordinarily people will put the shorter classes before the longer classnames

[04:08] <masak> \o/

[04:08] <diakopter> if you make it a multi can you put the filter as a parameter constraint?

[04:08] <TimToady> so you would never see that the earlier class clobbered its package space

[04:08] *** kaare_ joined
[04:09] <jack_rabbit> TimToady, don't I need to declare the classes that the shorter one has as members before it?

[04:09] <masak> diakopter: yes, but I got wyrd messages from a chaotic realm doing that. so I stopped.

[04:09] <grondilu> In case you guys have time to give it some thought:  what I really want to do is a type that is a list of increasing positive integers.  Then I want to define a multiplication on this type so that the result of the multiplication is the increasing list of combined integers, along with the sign of the permutaiton required to get this list.

[04:09] <TimToady> so it might be considered a bug that the implicit package declared by class HTTPParser::Foo doesn't consider it stubbed

[04:09] <diakopter> o_O

[04:09] <diakopter> masak: dare I ask where is this chaotic realm

[04:09] <masak> grondilu: increasing but not necessarily contiguous, right?

[04:10] <grondilu> not necessarily contiguous indeed

[04:10] <masak> diakopter: the concept of 'where' reveals your frailty, mortal.

[04:10] <TimToady> m: class Foo::Bar {}; class Foo { has Foo::Bar $.x }

[04:10] <camelia> rakudo-moar 5f9cd5: ( no output )

[04:10] <TimToady> that seems to work, though...

[04:10] <masak> grondilu: didn't grok the "sign of the permutation" part.

[04:11] <grondilu> signature is more accurate I think

[04:11] <TimToady> m: class Foo::Bar {}; class Foo { }; class Foo::Baz { has Foo::Bar $.x }

[04:11] <camelia> rakudo-moar 5f9cd5: ( no output )

[04:11] <TimToady> hmm, can't seem to reproduce my thinking

[04:11] <grondilu> (1, 2, 3) -> (2, 1, 3) has a -1 signature for instance. 

[04:12] <diakopter> m: class Foo::Foo::Bar { say Foo::Foo; }

[04:12] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Foo)␤»

[04:12] <grondilu> (https://en.wikipedia.org/wiki/Parity_of_a_permutation)

[04:12] <masak> grondilu: ok, but "required to get this list" from what other list, then?

[04:13] <grondilu> you start from two lists, and you get a third

[04:13] <masak> oh, ok, so you concat factor1 and factor2?

[04:13] <grondilu> the initial list is the concatenation of the first two

[04:13] <TimToady> star-m: class Foo::Bar {}; class Foo { has Foo::Bar $.x }

[04:13] <camelia> star-m 2014.04: ( no output )

[04:13] <masak> grondilu: got it.

[04:15] <grondilu> I which there was an option to the sort function to get the signature of the permutaiton, but maybe that's asking a lot.

[04:15] <grondilu> *wish

[04:15] <masak> m: class IncList { has @.values; submethod PRE { @!values eqv @!values.sort } }; say IncList.new(:values(1, 5, 3))

[04:15] <camelia> rakudo-moar 5f9cd5: OUTPUT«IncList.new(values => Array.new(1, 5, 3))␤»

[04:15] * masak submits NYI rakudobug

[04:16] <masak> m: say [1, 5, 3] eqv [1, 5, 3].sort

[04:16] <camelia> rakudo-moar 5f9cd5: OUTPUT«False␤»

[04:16] <jack_rabbit> TimToady, thanks for the help. I'm still not sure exactly what was wrong with the code before.

[04:16] <jack_rabbit> I'd really like to know.

[04:16] *** xenoterracide left
[04:17] <grondilu> masak: you can consider integers to be unique in the concatenated list because if they appear twice they ought to disappear.

[04:18] <TimToady> jack_rabbit: it's because it's already in a module of that name

[04:19] <jack_rabbit> Oh, so I can't have a class of the same name as the module?

[04:19] <masak> FROGGS++ # star

[04:20] <masak> grondilu: ok, so kind of like a sorted set.

[04:21] <diakopter> m: class Foo::Foo::Bar { say Foo::Foo; class Foo::Foo { say Foo::Foo }; say Foo::Foo }

[04:21] <grondilu> it's about my recent interest in Geometric Algebra.  What I want to do is to learn how to multiply unitary blades.

[04:21] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Foo)␤(Foo::Foo)␤(Foo::Foo)␤»

[04:21] <diakopter> o_O

[04:21] <diakopter> One of these FooFoos is not like the other

[04:22] <grondilu> so now that I think about it, repeating numbers do matter because the number of steps to have them join together can change the sign of the permutation.

[04:22] <diakopter> m: class Foo::Foo::Bar { say Foo::Foo; class Foo::Foo { ... }; class Foo::Foo { say Foo::Foo }; say Foo::Foo }

[04:22] <camelia> rakudo-moar 5f9cd5: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/04o8J5bytx␤The following packages were stubbed but not defined:␤    Foo::Foo␤at /tmp/04o8J5bytx:1␤------> [32moo::Foo { say Foo::Foo }; say Foo::Foo }[33m⏏[31m<EOL>[0m␤    expecting …»

[04:22] <diakopter> er wut

[04:23] <diakopter> looks defined-ish to me

[04:24] <masak> m: class IncList { has @.values; submethod BUILD(:@!values) { PRE { @!values.sort eqv @!values } } }; say IncList.new(:values(1, 2, 3)) # why in the world does this precond fail?

[04:24] <camelia> rakudo-moar 5f9cd5: OUTPUT«Precondition '{ @!values.sort eqv @!values }' failed␤  in submethod BUILD at /tmp/OUPeteVt6X:1␤  in method BUILDALL at src/gen/m-CORE.setting:918␤  in method bless at /home/p6eval/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:1␤  in met…»

[04:24] <masak> oh, result of .sort is of a different type, perhaps?

[04:25] <masak> yep, Parcel vs Array.

[04:25] <masak> m: say (1, 2, 3) eqv [1, 2, 3]

[04:25] <camelia> rakudo-moar 5f9cd5: OUTPUT«False␤»

[04:25] <masak> must it be thus?

[04:26] <masak> it's kind of annoying.

[04:26] <grondilu> m: say [^10].sort.WHAT

[04:26] <camelia> rakudo-moar 5f9cd5: OUTPUT«(Parcel)␤»

[04:26] <TimToady> an array is nothing like a parcel

[04:26] <grondilu> testing increasingness can be done with [<]

[04:27] <masak> m: class IncList { has @.values; submethod BUILD(:@!values) { PRE { [@!values.sort] eqv @!values } } }; say IncList.new(:values(1, 2, 3)) # this works

[04:27] <camelia> rakudo-moar 5f9cd5: OUTPUT«IncList.new(values => Array.new(1, 2, 3))␤»

[04:27] <masak> grondilu: good point.

[04:27] <masak> m: class IncList { has @.values; submethod BUILD(:@!values) { PRE { [<] @!values } } }; say IncList.new(:values(1, 5, 3))

[04:27] <camelia> rakudo-moar 5f9cd5: OUTPUT«Precondition '{ [<] @!values }' failed␤  in submethod BUILD at /tmp/NVY44_BdJX:1␤  in method BUILDALL at src/gen/m-CORE.setting:918␤  in method bless at /home/p6eval/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:1␤  in method new at src…»

[04:27] <masak> cute!

[04:27] <avuserow_> FROGGS++ # pushing through with a star release

[04:27] *** avuserow_ is now known as avuserow

[04:28] * grondilu didn't know about a PRE phaser

[04:28] <masak> suggestion: emit a summary of all the values that figure in the precondition, saving a debugging iteration.

[04:29] <masak> grondilu: I would've put it on the class instead of in BUILD, but that's NYI.

[04:33] <masak> m: class IncList { has @.values; submethod BUILD(:@!values) { PRE { [<] @!values } }; method gist { "inc[{@.values.join(", ")}]" } }; sub circumfix:<inc[ ]>(*@values) { IncList.new(:@values) }; multi infix:<(*)>(IncList $l, IncList $r) { IncList.new(:values(($l.values X* $r.values).sort.squish)) }; say inc[1, 2] (*) inc[2, 4]

[04:33] <camelia> rakudo-moar 5f9cd5: OUTPUT«inc[2, 4, 8]␤»

[04:33] <masak> grondilu: I believe that's a start.

[04:34] <masak> m: class IncList { has @.values; submethod BUILD(:@!values) { PRE [<] @!values }; method gist { "inc[{@.values.join(", ")}]" } }; sub circumfix:<inc[ ]>(*@values) { IncList.new(:@values) }; multi infix:<(*)>(IncList $l, IncList $r) { IncList.new(:values(($l.values X* $r.values).sort.squish)) }; say inc[1, 2] (*) inc[2, 4]

[04:34] <camelia> rakudo-moar 5f9cd5: OUTPUT«inc[2, 4, 8]␤»

[04:34] <masak> (in fact, can skip the block for the PRE phaser)

[04:34] <grondilu> no you're not supposed to multiply the integers of the list

[04:34] <masak> oh!

[04:34] <masak> just concat them. got it.

[04:35] <masak> m: class IncList { has @.values; submethod BUILD(:@!values) { PRE [<] @!values }; method gist { "inc[{@.values.join(", ")}]" } }; sub circumfix:<inc[ ]>(*@values) { IncList.new(:@values) }; multi infix:<(*)>(IncList $l, IncList $r) { IncList.new(:values(($l.values, $r.values).sort.squish)) }; say inc[1, 2] (*) inc[2, 4]

[04:35] <camelia> rakudo-moar 5f9cd5: OUTPUT«inc[1, 2, 4]␤»

[04:35] <masak> released a new version :P

[04:35] <grondilu> avoid putting a common integer in both list as this is a special case.

[04:36] <masak> er, but one I explicitly wanted to test...

[04:36] <grondilu> so for instance [1, 3] and [2, 4]

[04:36] <masak> m: class IncList { has @.values; submethod BUILD(:@!values) { PRE [<] @!values }; method gist { "inc[{@.values.join(", ")}]" } }; sub circumfix:<inc[ ]>(*@values) { IncList.new(:@values) }; multi infix:<(*)>(IncList $l, IncList $r) { IncList.new(:values(($l.values, $r.values).sort.squish)) }; say inc[1, 3] (*) inc[2, 4]

[04:36] <camelia> rakudo-moar 5f9cd5: OUTPUT«inc[1, 2, 3, 4]␤»

[04:36] <grondilu> should give -[1, 2, 3, 4]

[04:36] <masak> ok, siggie is the remaining bit.

[04:37] <grondilu> that's the most tedious part I'm afraid.

[04:37] <masak> time to do it in a gist instead.

[04:38] <masak> I guess the siggie can be computed as (-1) ** [+] @displacements

[04:38] <masak> where each number in @displacements is the diff in position between actual and sorted.

[04:39] <grondilu> I'm glad to see you're motivated.  If you want to do it all the way the rule for an integer appearing in both lists is that you should "move" one towards the other one and if the number of step is n then you multiply the signature by (-1)^n

[04:39] <masak> right.

[04:39] <masak> I think what I said comes down to that.

[04:39] *** pyrimidine joined
[04:39] <masak> and so the problem reduces to computing @displacements in a nice way.

[04:40] <grondilu> it seems to be this indeed.  You can sort as in a squish but in the end all pairs of identic numbers must disappear.

[04:40] *** pyrimidine left
[04:41] <grondilu> "pairs" not triplets or more.  E.g    3,4,4,4,5 -> 3,4,5  

[04:42] *** bjz_ left
[04:42] <masak> oh, the displacement has to be done post-squish. I kind of assumed that.

[04:42] *** bjz joined
[04:42] <grondilu> hum not really

[04:43] <masak> oh, I see what you're saying.

[04:43] <grondilu> first you displace, counding the number of displacement.  then you remove all pairs of conitguous numbers

[04:43] <grondilu> I mean pairs of contiguous identical numbers

[04:44] <masak> what about the case 2,4,3,4,5

[04:44] <grondilu> that will in the end give -[2,3,5]

[04:44] <masak> where did the 4s go?

[04:44] <grondilu> poofed

[04:44] <masak> this is a new requirement I didn't hear about until now.

[04:45] <grondilu> 2,4,3,5 -> -[2,3,4,4,5] -> -[2,3,5]

[04:45] <grondilu> I added it a bit earlier.

[04:45] <grondilu> I promess after this that's all :)

[04:46] <masak> ok, things made sense for me up until that point. giving up. sorry.

[04:46] <grondilu> ahh nevermind.  Thanks for trying.

[04:46] <hoelzro> masak: thanks!

[04:47] <grondilu> 2,4,3,4,5 -> -[2,3,4,4,5] -> -[2,3,5]   # fixing typo just in history

[04:49] *** pyrimidine joined
[04:51] <pyrimidine> Hola; seeing an error when I am running local tests for bioperl6

[04:52] <masak> hi pyrimidine 

[04:52] <masak> go on. :)

[04:52] <pyrimidine> o/

[04:52] <pyrimidine> Merging GLOBAL symbols failed: duplicate definition of symbol CodonTable

[04:53] <masak> pyrimidine: usually from importing two modules/files that declare the same module/class.

[04:53] <pyrimidine> I'm running a 'use Bio::Tools::CodonTable' in the tests, but later on I am running some tests with a 'use Bio::PrimarySeq' (which also has a 'use Bio::Tools::CodonTable')

[04:54] <pyrimidine> These don't declare the same class

[04:54] <masak> ah, so a diamond pattern usage kind of thing?

[04:54] <pyrimidine> no

[04:54] <masak> sounds like it.

[04:54] <pyrimidine> let's see, I'll point to github

[04:54] <masak> A -> B, C; B, C -> D

[04:55] <pyrimidine> masak: https://github.com/cjfields/bioperl6/blob/master/t/PrimarySeq.t

[04:56] <pyrimidine> oh wait, I think I see it

[04:56] <pyrimidine> nm, wrong URL: https://github.com/cjfields/bioperl6/blob/master/t/Tools/CodonTable.t

[04:57] <pyrimidine> I run all the tests I need, then pull in PrimarySeq using 'use Bio::Tools::PrimarySeq' here: https://github.com/cjfields/bioperl6/blob/master/t/Tools/CodonTable.t#L174

[04:58] <pyrimidine> I can probably golf that down quite a bit

[05:01] *** kurahaupo joined
[05:03] *** mberends left
[05:03] <pyrimidine> masak: https://gist.github.com/cjfields/ec8d7ed93e72db10854f

[05:05] * masak looks

[05:07] <pyrimidine> I can see what the problem is (CodonTable is used by PrimarySeq, so 'has' but no 'extends/does').  I wouldn't expect there to be a collision.

[05:07] <masak> ok, abstracting away from the specifics:

[05:08] <masak> your file T uses module C which declares a global type.

[05:08] <masak> then, a bit later, your file T uses another module P which transitively uses C, again.

[05:08] <masak> the collision seems to come from those two separate uses of C.

[05:08] * masak tries to confirm this

[05:09] <masak> so it's not really a diamond, it's T -> C, P; P -> C

[05:10] <masak> hm.

[05:10] <pyrimidine> yep

[05:10] <masak> just setting up that situation locally doesn't trigger the error.

[05:10] <masak> pyrimidine: would you be willing to golf the files down to the bare minimum? that'd be interesting.

[05:10] <pyrimidine> will try

[05:10] <masak> (like really the bare minimum. if the files end up having one line in them, that's optimal.)

[05:14] <kurahaupo> masak: do you really need that trailing newline ? :)

[05:15] <masak> heh.

[05:15] <masak> well, I tend to view the golfing as being on tokens, not characters. so I'm not too bothered by the newline.

[05:15] <masak> besides, how many lines would you say that a file without a trailing newline has?

[05:16] <kurahaupo> according to wc, 0

[05:17] <kurahaupo> after all, if you concateate such a file with another file that has N lines, the result is a file with N lines

[05:17] <masak> yes, though wc's man page refers to them as "newlines", not "lines".

[05:17] *** kaare__ joined
[05:18] <masak> m: say "".lines.elems

[05:18] <camelia> rakudo-moar 5f9cd5: OUTPUT«0␤»

[05:18] <masak> m: say "I told you it was soap".lines.elems

[05:18] <camelia> rakudo-moar 5f9cd5: OUTPUT«1␤»

[05:20] *** kaare_ left
[05:23] <pyrimidine> masak: https://github.com/cjfields/perl6-testcase

[05:23] <pyrimidine> it's... odd

[05:23] * kurahaupo mutters quietly in the corner about mad dwimmery

[05:23] *** jack_rabbit left
[05:24] *** SamuraiJack joined
[05:25] <pyrimidine> masak: ran using "prove -e 'perl6' -l t/CodonTable.t"

[05:25] <masak> pyrimidine: did you need 'use Test' for it to trigger?

[05:25] <masak> and 'done()'?

[05:25] <masak> I doubt that, since this is a compile-time thing.

[05:25] <pyrimidine> nope, just tried it w/o 'use Test'/done

[05:26] <masak> pyrimidine: does it still trigger without the 'class Bio::PrimarySeq;' line?

[05:26] <pyrimidine> yep

[05:26] * masak clones and plays around with it

[05:28] <masak> pyrimidine: s/Codontable/CodonTable/ in PrimarySeq.pm6

[05:29] <masak> pyrimidine: after that change, everything runs fine here.

[05:29] <masak> This is perl6 version 2014.08-128-g72852f1 built on MoarVM version 2014.08-36-g7938703

[05:30] * pyrimidine testing it out...

[05:31] <pyrimidine> nope, still a problem.

[05:35] *** jack_rabbit joined
[05:36] <pyrimidine> I'll run a clean checkout just to make sure, but changing the case didn't make a difference

[05:37] <masak> em, changing the case was necessary for me to get it running in the first place.

[05:37] <masak> if I didn't, I got an error that it didn't find the module.

[05:37] <masak> are you on a case-insensitive file system, perchance?

[05:38] <pyrimidine> that's my thought: Mac OS X

[05:38] *** JimmyZ joined
[05:41] * pyrimidine is testing this on a Linux box 

[05:44] <pyrimidine> btw, on the Mac: This is perl6 version 2014.08-163-g5f9cd51 built on MoarVM version 2014.08-55-ga5ae111

[05:45] <masak> wow, I'm so behind.

[05:45] * masak git pulls and rebuilds

[05:46] <pyrimidine> I think it's a namespace thing

[05:47] <pyrimidine> if I remove the Bio* namespace it works fine

[05:47] <masak> interesting.

[05:49] <pyrimidine> Also have to save the files in the base directory.  It's odd

[05:51] * pyrimidine just pushed a few more

[05:52] <grondilu> m: module Foo { subset Bar of Str is export where /\!/ }; import Foo; say "foo!" ~~ Bar;

[05:52] <camelia> rakudo-moar 5f9cd5: OUTPUT«True␤»

[05:52] <masak> pyrimidine: both the test files run fine here. I'm now on 2014.08-163-g5f9cd51 too.

[05:53] <pyrimidine> about to test on our linux server

[05:55] <pyrimidine> yep, passes there without problems

[05:56] <pyrimidine> masak: so, first test fails for me on Mac but second passes.  On Linux both pass.

[05:56] *** SamuraiJack left
[05:56] <pyrimidine> more specifically, CodonTable.t fails, but CodonTable2.t passes

[05:57] * pyrimidine is going to sleep, golfed out

[05:58] <pyrimidine> should I go ahead and file a bug?

[05:58] *** SamuraiJack joined
[05:59] <masak> yes, please.

[05:59] <pyrimidine> will do.  thanks!

[05:59] <masak> pyrimidine++

[05:59] <pyrimidine> masak: RT or GitHub?

[06:00] <pyrimidine> nm, found it (RT)

[06:02] <masak> aye.

[06:04] * grondilu got surprised by the =END not being valid anymore.  Fortunately he remembered that it has been replaced by =finished lately.

[06:04] <grondilu> *=finish

[06:06] *** cxreg2 is now known as cxreg

[06:07] *** darutoko joined
[06:10] <pyrimidine> masak: done, RT #122660

[06:10] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122660

[06:11] <pyrimidine> Night!

[06:11] *** pyrimidine left
[06:15] <grondilu> p6: say "".split(':').perl

[06:15] <camelia> rakudo-{parrot,jvm,moar} 5f9cd5: OUTPUT«("",).list␤»

[06:15] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«[""].list␤»

[06:16] * grondilu was expecting [] for some reason

[06:17] *** kaare__ left
[06:17] *** kaare__ joined
[06:17] <masak> grondilu: what would you expect "foo".split(':') to result in?

[06:23] <grondilu> yeah, makes sense

[06:24] <grondilu> thing is I got "" from joining [] and that was not reversible

[06:25] <grondilu> m: say [].join(":").perl

[06:25] <camelia> rakudo-moar 5f9cd5: OUTPUT«""␤»

[06:25] <grondilu> m: say [].join(":").split(":").perl

[06:25] <camelia> rakudo-moar 5f9cd5: OUTPUT«("",).list␤»

[06:26] <grondilu> I was taking for granted that split would reverse join, but it doesn't in the degenerate case

[06:27] <grondilu> m: say <foo bar>.join(":").split(":").perl

[06:27] <camelia> rakudo-moar 5f9cd5: OUTPUT«("foo", "bar").list␤»

[06:29] <grondilu> m: say [].join

[06:29] <camelia> rakudo-moar 5f9cd5: OUTPUT«␤»

[06:29] <grondilu> m: say [].join.perl

[06:29] <camelia> rakudo-moar 5f9cd5: OUTPUT«""␤»

[06:30] <grondilu> it's a bit odd that [].join returns the same thing as [""].join

[06:32] <grondilu> but that's ok.  Not a big deal.

[06:35] <masak> m: ["", "", "", ""].join

[06:35] <camelia> rakudo-moar 5f9cd5: ( no output )

[06:35] <masak> m: say ["", "", "", ""].join.perl

[06:35] <camelia> rakudo-moar 5f9cd5: OUTPUT«""␤»

[06:35] <masak> that's like saying "it's a bit odd that [+]() returns the same thing as [+](0)"

[06:36] <masak> m: say [+](); say [+](0)

[06:36] <camelia> rakudo-moar 5f9cd5: OUTPUT«0␤0␤»

[06:37] <grondilu> it's indeed the same thing.  The fact remains that as a consequence split is not the inverse of join.

[06:37] <moritz> it's simply that '' is the neutral element of string concatenation

[06:38] * moritz mumbles something about monoids

[06:38] *** anaeem1 joined
[06:43] <masak> it goes deeper than that. split and join may feel like mutual inverses, but I don't think they ever promised that.

[06:44] <masak> it's more like they are adjoint functors, actually.

[06:45] <grondilu> so you know, this happened as I decided to just join my arrays before using them as keys for a hash.  I thought it would be simpler.  So I wrote something like %h{@a.join(':')}++.  But then when I wrote .split(':') for %h.keys it did not work as expected where @a was initially []

[06:46] * masak doesn't see why not

[06:46] <masak> oh, ok; I do.

[06:46] <grondilu> because I was testing @a == 0

[06:47] <masak> will you ever have a case of @a eqv [""] ?

[06:47] <grondilu> yes

[06:47] <grondilu> oh sorry I mean no

[06:47] <masak> I'm just wondering which of the two paths you'll want to take here.

[06:48] <masak> right, ok. so you in effect want "" to map to () by some operation that is almost like .split(':')

[06:49] <grondilu> what I really want is to reliably serialize arrays for use as a key.

[06:50] <grondilu> split/join proved to not work if not careful of degenerate cases

[06:52] <masak> m: sub strictsplit($s) { my @L = $s.split(":"); @L eqv [""] ?? Array.new !! @L }; say strictsplit($_).perl for "foo:bar", "foo", ""

[06:52] <camelia> rakudo-moar 5f9cd5: OUTPUT«Array.new("foo", "bar")␤Array.new("foo")␤Array.new()␤»

[06:53] *** virtualsue joined
[06:54] <masak> grondilu: a lot of things in programming prove to not work if one is not careful of degenerate cases :)

[06:54] <grondilu> definitely

[06:54] <masak> grondilu: more specifically, I think that this is a case of you having unusual requirements rather than .split being wrongly spec'd

[06:55] <grondilu> :/

[06:55] <grondilu> Well, I wouldn't have to serialize arrays for use as a key if we had a proper Parcel.WHICH  (see backlog)

[06:56] <masak> that we should indeed have.

[06:56] <masak> there are a lot of small annoyances with .WHICH that I look forward to us straightening out.

[06:56] *** domidumont joined
[06:57] *** virtualsue left
[07:03] *** dolmen joined
[07:06] <moritz> note that .WHICH will only work for your use case if the array/parcel elements are all of value types

[07:53] *** dolmen left
[08:02] *** JimmyZ_ joined
[08:03] *** JimmyZ left
[08:04] *** JimmyZ_ is now known as JimmyZ

[08:11] *** mj41 joined
[08:11] *** gfldex joined
[08:12] *** ivan`` left
[08:12] *** JimmyZ_ joined
[08:13] *** JimmyZ left
[08:13] *** JimmyZ_ is now known as JimmyZ

[08:17] *** ivan`` joined
[08:24] *** SamuraiJack left
[08:32] *** kurahaupo_ joined
[08:32] *** FROGGS_ is now known as FROGGS

[08:33] *** kurahaupo left
[08:41] *** mberends joined
[08:43] *** Alina-malina left
[08:44] *** Alina-malina joined
[08:44] *** kurahaupo_ left
[08:46] *** JimmyZ_ joined
[08:47] *** JimmyZ left
[08:47] *** JimmyZ_ is now known as JimmyZ

[08:49] *** bpalmer joined
[09:07] <FROGGS> .tell coloman: why does the OpenSSL smoke test complain about LibraryMake when LibraryMake itself is green?

[09:07] <yoleaux> FROGGS: What kind of a name is "coloman:"?!

[09:08] <FROGGS> .tell colomon why does the OpenSSL smoke test complain about LibraryMake when LibraryMake itself is green?

[09:08] <yoleaux> FROGGS: I'll pass your message to colomon.

[09:18] *** anaeem1 left
[09:18] *** anaeem1 joined
[09:20] <masak> moritz: but they all seem to be value types in grondilu's case.

[09:23] *** anaeem1 left
[09:27] *** bpalmer left
[09:28] *** JimmyZ_ joined
[09:28] *** MilkmanDan joined
[09:29] *** JimmyZ left
[09:29] *** JimmyZ_ is now known as JimmyZ

[09:30] *** kurahaupo joined
[09:39] *** JimmyZ_ joined
[09:41] *** jerrycheung joined
[09:41] *** JL235__ left
[09:42] *** JimmyZ left
[09:42] *** JimmyZ_ is now known as JimmyZ

[10:00] *** cognome_ left
[10:00] *** cognome joined
[10:04] *** cognome left
[10:06] *** spider-mario joined
[10:17] *** bbkr joined
[10:34] *** brrt joined
[10:38] *** JimmyZ_ joined
[10:38] *** kaare__ left
[10:39] *** JimmyZ left
[10:40] *** JimmyZ_ is now known as JimmyZ

[10:43] *** SamuraiJack joined
[10:47] *** colomon joined
[10:52] *** kjs_ joined
[10:53] *** JimmyZ_ joined
[10:55] *** JimmyZ left
[10:55] *** JimmyZ_ is now known as JimmyZ

[10:59] *** zakharyas joined
[11:02] <colomon> smoker ran to completion on its own last night!  \o/  grondilu++ 

[11:02] <yoleaux> 09:08Z <FROGGS> colomon: why does the OpenSSL smoke test complain about LibraryMake when LibraryMake itself is green?

[11:03] *** mberends left
[11:07] <colomon> FROGGS: Might mean LibraryMake isn't installing to the right place or something?

[11:09] <masak> stray idea: https://gist.github.com/masak/d59749975a1d4e200903 -- comments/scorn/amusement welcome.

[11:09] <FROGGS> colomon: hmmm, weird

[11:10] *** brrt left
[11:11] * colomon remembers how he tests these things….

[11:19] <colomon> actually looks like the problem is the other way around.  LibraryMake correctly installs to /home/smoker/emmentaler/installlib/lib/LibraryMake.pm6.moarvm

[11:19] <colomon> but OpenSSL isn't looking there to find it.

[11:20] <nine> masak: your grammar seems less strict on white space than your classes.

[11:20] <masak> nine: how so? they're all tokens.

[11:21] <masak> oh!

[11:21] <masak> yes.

[11:21] <masak> nine: corrected ':' to ': '

[11:24] <nine> masak: my gut feeling says that your grammar generator would become too complicated too quickly for this to be really useful. But if you know someone who needs a topic for a bachelor's thesis, this would certainly be very interesting.

[11:25] <masak> I think that you're right.

[11:26] <masak> it *would* be interesting to see how far one could push this.

[11:26] <masak> I had a related thought as I was writing this, though:

[11:26] * jnthn imagines feeding a bachelor student the Grammar::Generative project :)

[11:26] <jnthn> Such cruelty :)

[11:26] <masak> jnthn: you mean costudent, surely

[11:27] <jnthn> masak: Categorically not... :P

[11:28] <masak> I think my absolute ideal environment for putting together a Perl 6 grammar would be a web application where one started by writing a test case, an input that one wanted to parse. application would immediately take that and turn it into a grammar that just parsed the whole big blob of text and nothing else.

[11:28] <lizmat_> on the low-hangning segfaulting front:

[11:28] <lizmat_> $ perl6 t/spec/integration/99problems-51-to-60.t

[11:28] <masak> but then one would go into that grammar and selectively apply refactors and generalizations, all the time keeping the original input passing.

[11:28] <lizmat_> segfaults consistently for me

[11:30] <FROGGS> lizmat_: look at my paste in #moarvm

[11:30] *** lizmat_ is now known as lizmat

[11:31] <dalek> roast: f8edcac | (Elizabeth Mattijsen)++ | S32-exceptions/misc.t:

[11:31] <dalek> roast: Unfudge now passing test

[11:31] <dalek> roast: review: https://github.com/perl6/roast/commit/f8edcac06a

[11:38] <colomon> hmmm, lots of modules failing because they can't find LibraryMake, not just OpenSSL

[11:39] <FROGGS> colomon: can you rename the installed file from .pm6.moarvm to .pm.moarvm?

[11:40] <colomon> FROGGS: think that's it?  It's not terribly easy to do in the middle of a smoke test run

[11:41] <lizmat> Looking at S01:120, one could get the impression that "use v5" should be part of the core

[11:41] <synopsebot> Link: http://perlcabal.org/syn/S01.html#line_120

[11:41] <FROGGS> colomon: I have no idea, really

[11:41] <lizmat> although probably not part of the core settings

[11:41] <FROGGS> lizmat: I know

[11:41] <FROGGS> lizmat: but it tends to be too big to be part of the compiler

[11:45] <lizmat> too big as in: adding to much time for a make ?

[11:45] <lizmat> *too

[11:46] <FROGGS> exactly

[11:47] *** zakharyas left
[11:53] *** brrt joined
[11:56] *** Akagi201 joined
[12:06] *** rindolf left
[12:13] *** bbkr left
[12:13] <dalek> rakudo/nom: 428e0e6 | (Elizabeth Mattijsen)++ | src/core/Process.pm:

[12:13] <dalek> rakudo/nom: Make initialization of $*TMPDIR lazy

[12:13] <dalek> rakudo/nom: 

[12:13] <dalek> rakudo/nom: This takes off about .005 off the startup of Perl6, effects in spectest

[12:13] <dalek> rakudo/nom: are not visible, perhaps because many of the tests use $*TMPDIR implicitely.

[12:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/428e0e6036

[12:19] <colomon> FROGGS: actually, I think the problem might be with panda?

[12:19] <lizmat> m: my $a = do { return 42 }

[12:19] <camelia> rakudo-moar 5f9cd5: ( no output )

[12:20] <lizmat> $ MVM_SPESH_DISABLE=1 perl6 -e 'my $a = do { return 42 }'

[12:20] <lizmat> Segmentation fault: 11

[12:20] <lizmat> segfaults locally for me

[12:20] <lizmat> can someone confirm ?

[12:21] <colomon> seems to throw me in the REPL?!?

[12:21] <colomon> lizmat: ^^

[12:21] <colomon> ah, no, I see

[12:21] <colomon> seg fault on OS X

[12:22] <colomon> and linux

[12:22] <lizmat> also in the REPL

[12:22] *** kaare_ joined
[12:22] *** rindolf joined
[12:23] <colomon> lizmat: wasn't actually the REPL, I missed the closing quote in my copy-n-paste so the shell wanted more input.

[12:23] <lizmat> actually, I can golf it down to just { return }

[12:23] <lizmat> $ MVM_SPESH_DISABLE=1 perl6 -e '{ return }'

[12:23] <lizmat> Segmentation fault: 11

[12:24] <lizmat> hmmm... actually just return is enough 

[12:24] * lizmat rakudobugs

[12:25] <colomon> lizmat: confirmed for just { return }, too

[12:25] <lizmat> $ perl6-p -e 'return'

[12:25] <lizmat> Attempt to return outside of any Routine

[12:25] <lizmat> is what it probably should be

[12:28] <lizmat> r: say EVAL "return 42; die"   # slightly related

[12:28] <camelia> rakudo-{parrot,jvm,moar} 5f9cd5: OUTPUT«42␤»

[12:28] <lizmat> are we expecting a retiurn in an EVAL to return from the EVAL sub ?

[12:43] *** cibs joined
[12:44] *** cognome joined
[12:47] *** JimmyZ_ joined
[12:47] *** Gruber joined
[12:48] <colomon> FROGGS: okay, I think broadly speaking the problem here is that the customer smoker installlib directory isn't making it to the instance of rakudo that tries to build OpenSSL

[12:50] *** grondilu_ joined
[12:50] *** mj41_nb joined
[12:51] *** cxreg2 joined
[12:51] *** btyler_ joined
[12:53] *** brrt left
[12:57] *** JimmyZ left
[12:57] *** mj41 left
[12:57] *** grondilu left
[12:57] *** Grrrr left
[12:57] *** renormalist left
[12:57] *** btyler left
[12:57] *** cxreg left
[12:57] *** Alula_ left
[12:58] *** telex left
[13:00] *** telex joined
[13:01] *** renormalist joined
[13:09] *** chenryn joined
[13:15] *** colomon left
[13:17] *** colomon joined
[13:20] <colomon> aha!

[13:20] <colomon> emmentaler carefully sets PERL6LIB before calling into panda

[13:21] <colomon> panda carefully sets aside the exisitng PERL6LIB to construct one of its own

[13:21] *** Gruber is now known as Grrrr

[13:22] <colomon> errr, no, it's trying to use the existing one....

[13:28] *** jerrycheung left
[13:29] *** JimmyZ joined
[13:30] <dalek> rakudo/nom: 02e73a2 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[13:30] *** JimmyZ_ left
[13:30] <dalek> rakudo/nom: .join instead of join() shaves off one indirection

[13:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/02e73a274e

[13:33] *** JimmyZ_ joined
[13:34] *** JimmyZ left
[13:35] *** JimmyZ_ is now known as JimmyZ

[13:36] <colomon> huh.  the withp6lib command definitely seems to be building up a workable PERL6LIB, but then the actual build command ignores it?

[13:41] *** guru joined
[13:41] *** guru is now known as ajr_

[13:43] *** mj41_nb left
[13:45] *** JimmyZ_ joined
[13:46] <dalek> rakudo/nom: 684002d | (Elizabeth Mattijsen)++ | src/core/Hash.pm:

[13:46] <dalek> rakudo/nom: Make Hash.gist according to spec

[13:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/684002d65b

[13:48] *** JimmyZ left
[13:48] *** JimmyZ_ is now known as JimmyZ

[13:53] *** jerrycheung joined
[13:58] *** SamuraiJack left
[14:00] <dalek> rakudo/nom: d417459 | (Elizabeth Mattijsen)++ | src/core/Hash.pm:

[14:00] <dalek> rakudo/nom: Be consistent in use of self

[14:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d417459d92

[14:00] <moritz> o/

[14:01] *** zakharyas joined
[14:03] <lizmat> now that we have stable .WHICH

[14:04] <lizmat> does anybody have an idea on how to fix:

[14:04] <lizmat> m: my @a; @a[0]=@a; @a.say

[14:04] <jnthn> lizmat: Glad to see that's being taken advantage of already :)

[14:04] <camelia> rakudo-moar 428e0e: OUTPUT«(timeout)»

[14:05] *** colomon left
[14:07] *** colomon joined
[14:08] *** araujo left
[14:11] *** araujo joined
[14:11] <moritz> lizmat: I guess you'd have to keep a %SEEN hash somewhere, and consider it in .perl

[14:11] <colomon> lizmat's on a roll again!  \o/

[14:12] <moritz> lizmat: but I can only think of solutions that aren't thread safe

[14:12] <lizmat> well, the %SEEN would first need to create a hash for the thread it's in

[14:12] <lizmat> and have that protected

[14:13] <moritz> is there a stash THREAD:: ? like GLOBAL::, but local to the current thread?

[14:13] <lizmat> I was hoping to create a generic mechanism that could be used by all .perl methods

[14:13] <lizmat> I don't think there is a THREAD::

[14:14] <moritz> if there were, it'd be the ideal place to put such a thing

[14:15] <lizmat> .oO( I think I can hear jnthn already scream: NOOOOOOOOO....  :-)

[14:16] *** nbrown__ joined
[14:16] <lizmat> OTOH, perhaps this could be lazily created

[14:17] <masak> %*SEEN, a dynamic variable.

[14:17] <masak> ISTR dynamic variables already DTRT with threads, too.

[14:17] <jnthn> Well, we have a $*THREAD, but I'd be a little wary of it

[14:17] <jnthn> Dynvars are the safe thing here.

[14:18] <masak> seems like the obvius hook to hang it on to me.

[14:18] <masak> obvious*

[14:18] <masak> as this is a structural recursion, so the variable is tied to a process, not an object or a lexical scope.

[14:19] <lizmat> but how can I create a dynvar at the start thread level from a sub?

[14:20] <lizmat> as we don't want to create this dynvar every time we start a thread, right ?

[14:20] <jnthn> I don't really see how it relates to threading, tbh; feels jus tlike straight dynvar usage to me

[14:21] <lizmat> so if two threads start to construct a .perl representation using a %*SEEN hash, they will never interfere with each other ?

[14:22] <jnthn> lizmat: Provided it's a real lexical in a callframe rather than a GLOBAL fallback, sure

[14:23] <jnthn> lizmat: my %*FOO; # really declares a lexical, just one we can find by looking down the call stack

[14:23] <jnthn> and threads have their own call stacks.

[14:23] <lizmat> ah, yes, I get that

[14:23] *** denis_boyun_ joined
[14:23] <lizmat> my %h = a => { b => 1 }

[14:24] <lizmat> Hash.perl is called twice creating a .perl of %h

[14:24] <lizmat> how will it know one call is the "outer" without having some global state ?

[14:24] <lizmat> by checking for %*SEEN.defined ?

[14:25] <jnthn> It's not about outer

[14:25] <jnthn> It's about caller

[14:25] <jnthn> and yeah, it can be done that way

[14:25] <lizmat> sorry, caller

[14:26] <jnthn> my %*SEEN := CALLER::<%*SEEN> // Hash{Mu}.new; # or so

[14:26] <jnthn> Though I'd call it something a little less generic 

[14:26] <lizmat> hmmm...  

[14:26] <jnthn> %*GIST-SEEN and %*PERL-SEEN maybe

[14:27] *** JimmyZ left
[14:28] <lizmat> still, that would only be a pattern, and not a generic solution :-(

[14:29] <jnthn> What problem are you wanting a general solution for?

[14:29] <lizmat> for the .perl case, I would also probably need to be able to represent 'my @a; @a[0]=@a' as a single statement

[14:29] <lizmat> m: my @a; @a[0]; say @a

[14:29] <camelia> rakudo-moar 428e0e: OUTPUT«␤»

[14:30] <lizmat> m: my @a; @a[0]=@a; say @a

[14:30] <camelia> rakudo-moar 428e0e: OUTPUT«(timeout)»

[14:30] <TimToady> masak: yes, we determined last night that Parcel probably needs to have a .WHICH that is based on its component .WHICHes, so that parcels of values behave like proper tuples

[14:31] <TimToady> shower &

[14:31] <masak> I missed that discussion, but I already assumed it'd have to.

[14:32] <masak> if it were a simple hash code, I'd expect it to use all of its component hash codes.

[14:32] <lizmat> m: say (1,).WHICH  # so this should become Parcel|Int|1  ?

[14:32] <camelia> rakudo-moar 428e0e: OUTPUT«Parcel|60273496␤»

[14:34] <lizmat> masak: ^^^  ?

[14:34] <jnthn> We probably need to stop constructing strings for ObjAt...

[14:34] <jnthn> And start making it an integer.

[14:34] <jnthn> But that needs work on hashes more generally

[14:35] <jnthn> But anyway, it means combining integers in some good way

[14:35] <jnthn> Loads of literature on that

[14:35] <colomon> mmmmm, integers

[14:35] <masak> +1 to stop with the strings

[14:35] <lizmat> also: for .perl and friends, we probably also need to have a way to determine if the object type is value base or not

[14:36] <lizmat> *based

[14:37] <lizmat> jnthn: so you're saying that now that .WHICH is unique for each object during the lifetime of a process

[14:37] <lizmat> we don't need the type in ObjAt anymore ?

[14:37] *** pmurias joined
[14:37] <jnthn> lizmat: Important note; unique for each object during the lifetime of *that object*.

[14:38] <jnthn> lizmat: Once you start combining them, conflicts are, of course, possible.

[14:38] <lizmat> ah, so the same nqp::objectid can still occur for 2 objects during the lifetime of the process

[14:38] <jnthn> lizmat: That's how we generally understand hash codes, though.

[14:39] *** nbrown__ left
[14:40] <colomon> jnthn: does that imply that memoize needs to hold a copy of each object its called with so the objectid stored in the cache doesn't get recycled

[14:41] <masak> colomon: I think that's a case of "both ways".

[14:41] <jnthn> colomon: Sure, but that's how any non-perfect hash has to work anyway.

[14:42] <masak> colomon: some will want memoize to keep stuff alive; some will want it to not leak.

[14:42] <jnthn> colomon: Hashes always have the real values of their keys to hand, in general, to make sure it's not a false positive.

[14:46] *** zakharyas left
[14:48] <moritz> lizmat: we can't get rid of the type in ObjAt, because value types don't use the object ID in there

[14:48] <moritz> lizmat: value types use a representation of the value, and we need to be able to distinguish 1 from "1"

[14:49] <moritz> (though we should use the object ID of the type, not the type name, for that

[14:49] *** xenoterracide joined
[14:49] <lizmat> moritz: that's not the issue

[14:49] <jnthn> Indeed. nqp::objectid(thing.WHAT)

[14:49] <lizmat> it's just that when creating a .perl representation of e.g. (1,1,1,1,1)

[14:50] <lizmat> I don;'t want the 2nd and later "1" to be represented by the first value of the parcel

[14:50] <lizmat> or in P5 data::dumper format:

[14:50] <moritz> yes, that should only be done for reference types

[14:50] <xfix> Just asking. Is it possible to match a set of elements in any order, but every element can be matched only once? For example, let's say I want to match "", "a", "b", "ab", "ba", but not "aba" or "bb"?

[14:50] <lizmat> $VAR1 = ( 1, $VAR1[1], $VAR1[1],... )

[14:51] <moritz> so we need to come up with a way of asking a type if it's a value type or a reference type

[14:51] <lizmat> yes

[14:51] <xfix> Int is immutable, isn't it?

[14:51] <moritz> xfix: yes

[14:51] <moritz> xfix: also yes

[14:51] <jnthn> lizmat: I think it's for the .perl method of the type in question to know whether it should go looking in the seen hash...

[14:52] <xfix> moritz: ok, now how can I match "", "a", "b", "ab", "ba", but not "aba" or "bb"?

[14:52] <jnthn> "Am I a reference type? Do I caontain other things? OK, I should check..."

[14:52] <xfix> (now that I got an answer that I can)

[14:52] <moritz> xfix: $thing eq any("", "a", "b", "ab", "ba")

[14:52] <lizmat> jnthn: good point, but that just makes that pattern to be more spread out over the whole settings

[14:53] <moritz> xfix: or in a regex, [ '' | 'a' | ' b' | 'ab' | 'ba ]

[14:53] <moritz> xfix: (+ the closing quote I forgot)

[14:53] <lizmat> but I guess, there is no other way than that  :-(

[14:53] <xfix> Uhm, yeah. But well, I have more tokens than just "a" and "b".

[14:53] <xfix> And I don't want to exponentially write the regex.

[14:53] <moritz> xfix: then maybe you should ask the question you actually wanted to know the answer of

[14:53] <masak> xfix: all(@things) eq any(@tokens) && @things.uniq == @things

[14:54] <xfix> Thanks.

[14:54] <moritz> masak++ # reading minds better than I do

[14:55] <jnthn> lizmat: Hm, true...

[14:55] <timotimo> how about doing that with a Bag instead?

[14:55] <masak> m: my @tokens = <a b>; for [], [<a>], [<a b>], [<a b a>] -> @things { say all(@things) eq any(@tokens) && @things.uniq == @things }

[14:55] <camelia> rakudo-moar d41745: OUTPUT«True␤True␤True␤False␤»

[14:56] <timotimo> like "the bag's values are all 1 and the keys are a subset of the @tokens"

[14:56] <masak> xfix: if I wanted to do it in a regex, I'd simply scan token by token, check that it's among the ones I accept, and keep a %seen hash.

[14:57] <xfix> Thanks, this sounds great.

[14:57] <jnthn> lizmat: Maybe there would be some way to factor out the check...like a method perl-or-seen(&how-to-perl) { ... }

[14:57] <jnthn> lizmat: And then Hash.perl does something like method perl() { self.perl-or-seen({ ...code that does what .perl does today in this closure })

[14:58] <jnthn> lizmat: And if the thing has been seen then we never call that closure and hand back the seen value...

[14:58] <lizmat> handing back the seen value is not a solution either

[14:58] <lizmat> you want to return something that refers to the first place seen in the structure

[14:58] <jnthn> uh, I mean like a string that corresponds to it.

[14:59] <jnthn> $VAR1 or so

[14:59] *** nbrown__ joined
[14:59] <lizmat> ok

[14:59] <jnthn> That is, .perl-or-seen is always returning a string.

[14:59] <lizmat> ok, yes, that makes sense

[15:00] <jnthn> That can then even be used by those who want to make their own types play along with this.

[15:00] <masak> m: my @tokens = <a b>; for "", "a", "ab", "aba" -> $input { say $input ~~ /^ (@tokens)* $/ && @0>>.Str.uniq == @0 } # xfix

[15:00] <camelia> rakudo-moar d41745: OUTPUT«True␤True␤True␤False␤»

[15:00] <lizmat> we don't have a smart way to refer to the current base data structure, do we?

[15:00] <grondilu_> p6: (sub (Int @) {})([^3]);

[15:00] <masak> xfix: couldn't figger out a way to do it all from inside the regex

[15:00] <xfix> Thanks.

[15:00] <xfix> I'll use a set anyway.

[15:00] *** grondilu_ is now known as grondilu

[15:00] <camelia> niecza v24-109-g48a8de3: ( no output )

[15:00] <camelia> ..rakudo-jvm d41745: OUTPUT«(timeout)»

[15:00] <camelia> ..rakudo-moar d41745: OUTPUT«Type check failed in binding <anon>; expected 'Positional[Int]' but got 'Array'␤  in sub  at /tmp/tmpfile:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[15:00] <camelia> ..rakudo-parrot d41745: OUTPUT«Type check failed in binding; expected 'Positional[Int]' but got 'Array'␤  in sub  at /tmp/tmpfile:1␤  in block <unit> at /tmp/tmpfile:1␤␤»

[15:00] <jnthn> lizmat: No, but could do the smae kinda dynvar trick I mentioned before...

[15:00] *** grondilu left
[15:00] *** grondilu joined
[15:00] <masak> xfix: sure, that works too.

[15:03] *** nbrown__ left
[15:05] <grondilu> p6: (sub (Int @) {})(my Int @ = ^3);   # OK, found relevant spec in S14

[15:05] <camelia> rakudo-{parrot,jvm,moar} d41745, niecza v24-109-g48a8de3: ( no output )

[15:06] <dalek> ecosystem: 17b10a3 | Carlin++ | META.list:

[15:06] <dalek> ecosystem: add Crypt::Reop

[15:06] <dalek> ecosystem: 

[15:06] <dalek> ecosystem: NativeCall interface for reop

[15:06] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/17b10a3a6e

[15:07] *** denis_boyun_ left
[15:07] *** kurahaupo left
[15:07] *** denis_boyun joined
[15:08] <grondilu> n: subset Foo of Int; (sub (Foo @) {})(my Foo @ = ^3);

[15:08] <camelia> niecza v24-109-g48a8de3: OUTPUT«Unhandled exception: Constraint type check failed for parameter '' in 'ANON'␤  at /tmp/H1Xc59dv52 line 0 (ANON @ 1) ␤  at /tmp/H1Xc59dv52 line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4595 (ANON @ 3) ␤  at /home/p6eval/…»

[15:10] *** cxreg2 is now known as cxreg

[15:10] *** nbrown__ joined
[15:12] *** mberends joined
[15:14] *** nbrown__ left
[15:15] <timotimo> oooh, it's not terribly long until the advent calendar is going to happen again

[15:15] <jnthn> Wonder if we'll find anything to write about this year... :P

[15:16] <timotimo> hmm. sounds difficult

[15:16] <jnthn> ;)

[15:16] <timotimo> i didn't do anything at all!

[15:16] <jnthn> Time for some rest here...hopefully will feel up to writing code again by tomorrow evening...

[15:16] *** nbrown__ joined
[15:16] <jnthn> 'night

[15:17] <timotimo> get well soon! :)

[15:21] *** BizarreCake joined
[15:21] <lizmat> gnight jnthn and get well!

[15:23] *** mj41_nb joined
[15:24] *** nbrown__ left
[15:27] *** denis_boyun left
[15:28] <masak> yes, 'night, #perl6, and sweet dreams.

[15:28] <moritz> early night in south sweden today? :-)

[15:28] *** jepeway joined
[15:31] *** kjs_ left
[15:32] *** jerrycheung left
[15:32] *** jepeway left
[15:33] <lizmat> moritz: afaik, masak is at +0800 GMT

[15:34] <moritz> lizmat: oh, I must have missed some travel announcement :-)

[15:36] <timotimo> he's in china with jnthn afaict

[15:36] <grondilu> std: (sub (Hash{Int} %) {})(my Hash{Int} % = 1 => 2);  # not sure I can use a typed array as a parameter

[15:36] <camelia> std 53b3ca6: OUTPUT«ok 00:01 133m␤»

[15:37] <grondilu> n: (sub (Hash{Int} %) {})(my Hash{Int} % = 1 => 2);  # I know moar fails.  Testing Niecza

[15:37] <camelia> niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤WHENCE blocks not allowed on declarative type names at /tmp/SRFjZccbdG line 1:␤------> [32m(sub (Hash{Int}[33m⏏[31m %) {})(my Hash{Int} % = 1 => 2);  # I k[0m␤␤WHENCE blocks not allowed on declarative ty…»

[15:40] *** jepeway joined
[15:46] <jepeway> 'lo?

[15:49] *** brrt joined
[15:51] <brrt> lizmat: confirmed for return. i suspect the optimizer may throw away the return lexotic?

[15:51] <lizmat> it even happens with MVM_SPESH_DISABLE=1 ?

[15:52] <lizmat> $ perl6 --optimize=0 -e 'return'

[15:52] <lizmat> Segmentation fault: 11

[15:52] <lizmat> also with --optimize=0

[15:52] *** Alula_ joined
[15:53] <brrt> hmmm

[15:53] <brrt> ok, then i just don't know. there is at any rate no RETURN lexotic there

[15:53] <brrt> and moar returns null where it should return a register

[15:54] <brrt> (a register that might return contain null, but that's not the point)

[15:54] <brrt> s/return//

[15:55] <brrt> i... don't think i've a commit bit for rakudo, but it seems to me that the routine thinks NULL is acceptable as a return value

[15:55] <brrt> so it seems to be the best fix is to not deref the register pointer immediately

[15:56] <brrt> (oh, i should've said, it burns on src/vm/moar/ops/perl6_ops.c:466

[15:57] <lizmat> seems wrong to fix it there, as that is hot code

[15:58] <lizmat> I'd rather see this fixed by adding an outer frame or sub or whatever, that would then throw if entered from a return

[15:58] <lizmat> then we'd only have the overhead if something's wrong, not for every return

[15:58] <brrt> hmmm

[15:58] <brrt> it's not really a cheap function as it is

[15:59] *** mj41_nb left
[15:59] <brrt> but maybe you're right and this should be caught much earlier

[16:00] <brrt> anyway, it /does/ do the right thing :-)

[16:04] <lizmat> brrt: I think I have a solution at the P6 level

[16:05] <brrt> more awesome :-)

[16:05] <lizmat> spectesting now

[16:05] <brrt> anyway, this is the fix at c level: https://gist.github.com/bdw/cc441decdeec2ff692be

[16:07] <timotimo> we have a piece of optimization that throws away returns if they are at the end of a block

[16:07] <timotimo> maybe that happens here?

[16:08] <lizmat> perhaps... anyways, I'll try brrt's fix

[16:08] <lizmat> and make sure we don't lose too much in the spec test

[16:08] <grondilu> std: my (%a{Int}, %b{Int});

[16:08] <camelia> std 53b3ca6: OUTPUT«ok 00:01 127m␤»

[16:08] <grondilu> m: my (%a{Int}, %b{Int});

[16:08] <camelia> rakudo-moar d41745: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/zuiLfqm9vJ␤Unable to parse expression in declarator; couldn't find final ')' ␤at /tmp/zuiLfqm9vJ:1␤------> [32mmy (%a[33m⏏[31m{Int}, %b{Int});[0m␤    expecting any of:␤        scoped…»

[16:12] *** anaeem1 joined
[16:13] *** anaeem1 left
[16:14] *** anaeem1 joined
[16:17] *** mj41_nb joined
[16:18] <dalek> rakudo/nom: b6bc387 | (Elizabeth Mattijsen)++ | src/vm/moar/ops/perl6_ops.c:

[16:18] <dalek> rakudo/nom: Fix for #122667, as suggested by brrt++

[16:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6bc387377

[16:18] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122667

[16:19] <brrt> do we lose a lot?

[16:19] *** nbrown__ joined
[16:20] *** xinming_ joined
[16:21] <lizmat> I don't see it in the spectest

[16:21] <lizmat> my other fix made quite a lot spectests fail

[16:22] <lizmat> so, I shelved it in favour of your solution

[16:24] *** nbrown__ left
[16:24] *** xinming left
[16:28] *** nbrown__ joined
[16:28] *** mj41_nb left
[16:32] *** nbrown__ left
[16:34] *** kurahaupo joined
[16:40] *** mberends left
[16:41] *** vendethiel joined
[16:43] <vendethiel> o/, #perl6.

[16:43] <colomon> \o

[16:44] *** mberends joined
[16:45] <vendethiel> I've been backlogging during my trip (tired of >24h travel) and I've seen some people stumbling on minor "issues"

[16:45] <vendethiel> (feel free to just .tell anyway in these cases)

[16:46] *** Rounin_ is now known as Rounin

[16:51] <timotimo> issues with what now?

[16:51] <vendethiel> tutorial

[16:52] <timotimo> thought so

[16:52] <vendethiel> I've also seen grondilu++ struggling a bit with flattening, reminded me that's a very important part I didn't cover yet.

[16:52] <timotimo> good thing we have new people looking at that stuff

[16:52] <grondilu> n: sub f {...}; sub f {};

[16:52] <camelia> niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Illegal redeclaration of routine 'f' (see line 1) at /tmp/LsZhuiFJxh line 1:␤------> [32msub f {...}; sub f [33m⏏[31m{};[0m␤␤Potential difficulties:␤  &f is declared but not used at /tmp/LsZhuiFJxh lin…»

[16:52] <timotimo> yes, flattening is definitely A Thing.

[16:53] <timotimo> grondilu: fortunately, there is no need to stub subs

[16:53] <timotimo> m: f(1); sub f(Int $a) { say $a }

[16:53] <camelia> rakudo-moar d41745: OUTPUT«1␤»

[16:53] <vendethiel> also, going to push Sprockets code working with filters now. If somebody wants to create a web framework with asset managing, it'd fit right in

[16:53] <grondilu> there's no need but I wanted to do it anyway to pre-declare.  For tidying.

[16:54] <vendethiel> (I only need to create a grammar to parse manifest files now. Not pushed yet, as I had no internet when I wrote that piece of code)

[16:54] <grondilu> like predeclare everything on the top of my module.

[16:54] *** anaeem1_ joined
[16:55] *** anaeem1 left
[16:57] *** anaeem1_ left
[16:59] *** erkan joined
[17:00] *** immortal left
[17:00] <timotimo> m: my &foo; sub foo(Int $a) { say $a }; foo(5);

[17:00] <camelia> rakudo-moar d41745: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/sF63gysyjg␤Redeclaration of routine foo␤at /tmp/sF63gysyjg:1␤------> [32mmy &foo; sub foo(Int $a) { say $a }[33m⏏[31m; foo(5);[0m␤    expecting any of:␤        postfix␤        stat…»

[17:00] <timotimo> :\

[17:00] <timotimo> m: my &foo; &foo := sub foo(Int $a) { say $a }; foo(5);

[17:00] <camelia> rakudo-moar d41745: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Y62T9os9Qx␤Redeclaration of routine foo␤at /tmp/Y62T9os9Qx:1␤------> [32m&foo; &foo := sub foo(Int $a) { say $a }[33m⏏[31m; foo(5);[0m␤    expecting any of:␤        postfix␤       …»

[17:00] <timotimo> m: my &foo; &foo := anon sub foo(Int $a) { say $a }; foo(5);

[17:00] <camelia> rakudo-moar d41745: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/BpczuWECof␤Redeclaration of routine foo␤at /tmp/BpczuWECof:1␤------> [32m &foo := anon sub foo(Int $a) { say $a }[33m⏏[31m; foo(5);[0m␤    expecting any of:␤        postfix␤       …»

[17:00] <timotimo> shouldn't "anon sub foo" work properly?

[17:05] <moritz> it should, IMHO

[17:07] <moritz> m: my &bar; &bar := anon sub foo { }; &foo

[17:07] <camelia> rakudo-moar d41745: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/laBqDIbosF␤Cannot use bind operator with this left-hand side␤at /tmp/laBqDIbosF:1␤------> [32mmy &bar; &bar := anon sub foo { }[33m⏏[31m; &foo[0m␤    expecting any of:␤        statem…»

[17:07] <moritz> m: my &bar; &bar = anon sub foo { }; &foo

[17:07] <camelia> rakudo-moar d41745: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/vbQbZy0Fao␤Undeclared routine:␤    &foo used at line 1␤␤»

[17:07] <moritz> m: my &bar; &bar = anon sub foo { };

[17:07] <camelia> rakudo-moar d41745: ( no output )

[17:07] <moritz> m: my &bar; &bar = anon sub bar { };

[17:07] <camelia> rakudo-moar d41745: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CyI9IeAVzA␤Redeclaration of routine bar␤at /tmp/CyI9IeAVzA:1␤------> [32mmy &bar; &bar = anon sub bar { }[33m⏏[31m;[0m␤    expecting any of:␤        statement list␤        horizont…»

[17:11] *** zakharyas joined
[17:15] *** araujo left
[17:16] *** nbrown__ joined
[17:16] *** ajr_ left
[17:20] *** nbrown__ left
[17:22] *** araujo joined
[17:24] *** brrt left
[17:25] *** BizarreCake left
[17:28] *** ivanshmakov left
[17:39] *** raiph joined
[17:45] *** ivanshmakov joined
[17:52] <dalek> rakudo/nom: 59df77e | (Elizabeth Mattijsen)++ | src/ (2 files):

[17:52] <dalek> rakudo/nom: Make Parcel.WHICH value based

[17:52] <dalek> rakudo/nom: 

[17:52] <dalek> rakudo/nom: As discussed earlier today.  Not sure whether it is a good idea to cache

[17:52] <dalek> rakudo/nom: the .WHICH string.  Caching is easily removed should that be found to be

[17:53] <dalek> rakudo/nom: the right thing.

[17:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59df77edc0

[17:55] <moritz> m: my $parcel = (my $x = 42, 1); say $parcel.WHICH; $x = 5; say $parcel.WHICH

[17:55] <camelia> rakudo-moar b6bc38: OUTPUT«Parcel|67691520␤Parcel|67691520␤»

[17:56] <lizmat> $ 6 'my $parcel = (my $x = 42, 1); say $parcel.WHICH; $x = 5; say $parcel.WHICH'

[17:56] <lizmat> Parcel|(Int|42)(Int|1)

[17:56] <lizmat> clearly not right

[17:57] <lizmat> m: my $p = (42,1); $p[0] = 5

[17:57] <camelia> rakudo-moar b6bc38: OUTPUT«Cannot modify an immutable Int␤  in method assign_pos at src/gen/m-CORE.setting:1867␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2566␤  in block <unit> at /tmp/3nyrFGoxAt:1␤␤»

[17:57] <lizmat> m: my $p = (my $x = 42,1); $p[0] = 5

[17:57] <camelia> rakudo-moar b6bc38: ( no output )

[17:59] <spider-mario> r: 1..10 ==> [+]

[17:59] <spider-mario> m: 1..10 ==> [+]

[17:59] <camelia> rakudo-jvm b6bc38: OUTPUT«(timeout)»

[17:59] <camelia> ..rakudo-{parrot,moar} b6bc38: ( no output )

[17:59] <camelia> rakudo-moar b6bc38: ( no output )

[17:59] <spider-mario> m: 1..10 ==> [+] ==> say

[17:59] <camelia> rakudo-moar b6bc38: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/zzdTFUAYJJ␤Preceding context expects a term, but found infix ==> instead␤at /tmp/zzdTFUAYJJ:1␤------> [32m1..10 ==> [+] ==>[33m⏏[31m say[0m␤»

[18:00] <vendethiel> spider-mario: use explicit parens for the time being

[18:00] <spider-mario> okay

[18:00] <vendethiel> m: 1..10 ==> [+]() ==> say()

[18:00] <camelia> rakudo-moar b6bc38: OUTPUT«55␤»

[18:00] <vendethiel> not sure they are needed on [+]

[18:00] <spider-mario> they are, my example is badly chosen

[18:00] <spider-mario> m: 1..10 ==> [+] ==> my $sum;

[18:00] <camelia> rakudo-moar b6bc38: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/m3dpwPggY3␤Preceding context expects a term, but found infix ==> instead␤at /tmp/m3dpwPggY3:1␤------> [32m1..10 ==> [+] ==>[33m⏏[31m my $sum;[0m␤»

[18:01] <vendethiel> there's a RT already for that

[18:01] <spider-mario> oh, ok

[18:02] <lizmat> moritz: attempting fix

[18:03] <lizmat> motitz: $ 6 'my $parcel = (my $x = 42, 1); say $parcel.WHICH; $x = 5; say $parcel.WHICH'

[18:03] <lizmat> Parcel|(140460802207184)(Int|1)

[18:04] <lizmat> if the value is a container, just use the nqp::objectid of it

[18:04] <FROGGS> timotimo / arnsholt / jnthn: what's the most pleasing C globals syntax? "my Str $version is global('C') is symbol($optional)"? or "... is cglobal($optional-name)"?

[18:05] <FROGGS> timotimo / arnsholt / jnthn: or more like: "my Str $version:from<C>"?

[18:05] <lizmat> m: my $parcel = (my $ = 42, 1); say $parcel.perl   # also incorrect 

[18:05] <camelia> rakudo-moar b6bc38: OUTPUT«$(42, 1)␤»

[18:07] <moritz> lizmat: without having backlogged yet, I think I disagrew tih Parcel.WHICH being value-based

[18:07] <moritz> after all it's a container which can have mutable elements

[18:07] <lizmat> S07:55

[18:07] <synopsebot> Link: http://perlcabal.org/syn/S07.html#line_55

[18:08] <moritz> "A Parcel is immutable, although the elements of a Parcel may be either mutable or immutable."

[18:08] <moritz> that doesn't say it's a value type

[18:09] <dalek> rakudo/nom: d06f7a9 | (Elizabeth Mattijsen)++ | src/core/Parcel.pm:

[18:09] <dalek> rakudo/nom: Use nqp::objectid for containers in WHICH

[18:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d06f7a9dcd

[18:10] <lizmat> Moritz: Mouq started it at http://irclog.perlgeek.de/perl6/2014-08-31#i_9273480

[18:10] *** molaf__ joined
[18:13] *** molaf_ left
[18:17] *** nbrown__ joined
[18:17] *** Mouq joined
[18:17] <lizmat> m: say (1,2) === (1,2)

[18:17] <camelia> rakudo-moar b6bc38: OUTPUT«False␤»

[18:18] <lizmat> $ 6 'say (1,2) === (1,2)'

[18:18] <lizmat> True

[18:20] <lizmat> my fix makes one TODO test pass

[18:20] <lizmat>     my ($x, $y) = <a b>;

[18:20] <lizmat>     ok(«$x $y» === <a b>, "«$x $y» interpolation works correctly");

[18:21] *** nbrown__ left
[18:22] <dalek> rakudo/nom: b4f6b54 | Mouq++ | src/Perl6/Actions.nqp:

[18:22] <dalek> rakudo/nom: Anniversarily conclude commit ce3ea392

[18:22] <dalek> rakudo/nom: 

[18:22] <dalek> rakudo/nom: This makes, e.g., `my $perl = 5; say $perl.:<++>` print "6", as though

[18:22] <dalek> rakudo/nom: `++$perl` had been written

[18:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b4f6b54b4b

[18:23] <FROGGS> std: my $perl = 5; say $perl.:<++>

[18:23] <camelia> std 53b3ca6: OUTPUT«ok 00:01 124m␤»

[18:23] <FROGGS> what the

[18:24] <Mouq> Not really a high-priority feature :P but it's spec

[18:25] <FROGGS> a weird bit of the spec :o)

[18:29] <lizmat> with my Parcel.WHICH change, one spectest breaks: is(<a b c> === <a b c>, False);

[18:29] <lizmat> clearly, roast is inconsistent

[18:29] <Mouq> moritz: I see many advantages to having Parcel have a value-based .WHICH, and none to it having the old .WHICH provided the new is done correctly

[18:30] <lizmat> Mouq: do you think my patches are the correct way, or not ?

[18:30] *** erkan left
[18:31] <Mouq> lizmat: I think so :) I was curious if there were negative consequences from it, though. lizmat++

[18:31] <lizmat> well, one TODO passes now, another test fails now

[18:31] *** erkan joined
[18:31] *** raiph left
[18:32] <lizmat> $ 6 'my $p1 = (my $x = 42,1); my $p2 = (my $y := $x,1); say $p1 === $p2'

[18:32] <lizmat> True

[18:33] *** raiph joined
[18:33] <lizmat> would you consider that to be correct ?

[18:36] <Mouq> m: my $x = 42; my $y := $x; say $y.VAR.name;

[18:36] <camelia> rakudo-moar 59df77: OUTPUT«$x␤»

[18:36] * Mouq really doesn't know

[18:37] <Mouq> m: my $x = 42; my $z = 24; my $y := $x; say $y.VAR.name; $y := $z; say $y.VAR.name

[18:37] <camelia> rakudo-moar 59df77: OUTPUT«$x␤$z␤»

[18:39] <grondilu> I have a module that seems to work fine but when I try to use it and call an exported function I get a === SORRY === can not find method 'origin'

[18:39] <grondilu> *origin

[18:39] <grondilu> no:  orig

[18:39] * grondilu copy/pastes the exact error message:

[18:39] <grondilu> Cannot find method 'orig'

[18:40] <moritz> is that with precompilation?

[18:40] <grondilu> no

[18:40] <grondilu> not that I know of anyway

[18:41] <Mouq> grondilu: I got that writing my last commit when I forgot to include :node($/) to the QAST::Op

[18:43] <grondilu> I'm not doing anything that complicated

[18:43] *** zakharyas1 joined
[18:44] * grondilu tries to strip the module while keeping reproducing the error

[18:44] *** denis_boyun_ joined
[18:44] <Mouq> m: my $x = 42; my $z = 24; my $y := $x; my $p := ($y,); $p.Parcel = 56; say $x; $y := $z; $p.Parcel = 56; say $z

[18:44] <camelia> rakudo-moar 59df77: OUTPUT«56␤24␤»

[18:45] *** zakharyas left
[18:46] <Mouq> lizmat: ^^ $p still contains a reference to $x. So it would appear that your last snippit is correct

[18:46] <Mouq> AFAICT

[18:46] <lizmat> thanks for checking!

[18:47] <Mouq> grondilu: You're not, but you may be tickling a bug in Rakudo

[18:47] <Mouq> I mean, you definitely are

[18:48] <Mouq> But that's at least a pointer to where the bug lies :P

[18:48] <grondilu> m: module Foo { sub circumfix:<e[ ]>(*@) is export { "hi" } }; import Foo; say e[1];

[18:48] <camelia> rakudo-moar 59df77: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[18:48] <grondilu> ^ here

[18:49] <grondilu> it works fine with sub e(*@) is export

[18:50] <colomon> about to afk to drive home, but here's what I'm seeing with the OpenSSL build failure.  Somehow panda is calling an "override the normal build process" Build.pm even though OpenSSL doesn't have a Build.pm file.  

[18:50] <grondilu> and *@ does not matter:

[18:50] <grondilu> m: module Foo { sub circumfix:<e[ ]> is export { "hi" } }; import Foo; say e[ ];

[18:50] <camelia> rakudo-moar 59df77: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[18:51] *** colomon left
[18:51] <lizmat> module Foo { sub circumfix:<e[ ]>(*@) is export { "hi" } }; import Foo; say ::.keys.grep: { m/circumfix/ };  # oddly enough, it *is* exported

[18:51] <lizmat> m: module Foo { sub circumfix:<e[ ]>(*@) is export { "hi" } }; import Foo; say ::.keys.grep: { m/circumfix/ };  # oddly enough, it *is* exported

[18:51] <camelia> rakudo-moar 59df77: OUTPUT«&circumfix:<e[ ]>␤»

[18:52] <lizmat> m: module Foo { sub circumfix:<e[ ]>(*@) is export { "hi" } }; import Foo; say circumfix:<e[ ]>(1);  # calling it by its long name works

[18:52] <camelia> rakudo-moar 59df77: OUTPUT«hi␤»

[18:53] <Mouq> m: module Foo { sub postfix:<~>(*@) is export { "hi" } }; import Foo; say 1~;

[18:53] <camelia> rakudo-moar 59df77: OUTPUT«hi␤»

[18:53] <Mouq> m: module Foo { sub postcircumfix:<e[ ]>(*@) is export { "hi" } }; import Foo; say 1\e[4];

[18:53] <camelia> rakudo-moar 59df77: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[18:53] <lizmat> m: module Foo { sub circumfix:<zap[ ]>(*@) is export { "hi" } }; import Foo; say zap[1];  # it's not the name 'e'

[18:53] <camelia> rakudo-moar 59df77: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[18:54] <Mouq> I believe it's any non-standard circumfix

[18:54] *** darutoko left
[18:54] <grondilu> m: module Foo { sub circumfix:<a b> is export { "hi" } }; import Foo; say a b;

[18:54] <camelia> rakudo-moar 59df77: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[18:55] <lizmat> it's happening in the optimizer

[18:55] <lizmat> it's trying to generate a X::Undeclared exception

[18:56] <lizmat>         %opts<line>            := HLL::Compiler.lineof($op.node.orig, $op.node.from, :cache(1));

[18:56] *** beastd joined
[18:56] <lizmat> is the line it actually fails on

[18:59] *** raiph left
[18:59] <lizmat> seems it required an extra & in its name: trying to find &&circumfix:<zap[ ]>

[19:01] <FROGGS> m: multi trait_mod:<is>(Mu:U $v, :$cglobal!) { say 42 }; my int8 $foo is cglobal; # why does this no worky?

[19:01] <camelia> rakudo-moar 59df77: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/zy6zVVl4lG␤Can't use unknown trait 'is cglobal' in a variable declaration.␤at /tmp/zy6zVVl4lG:1␤------> [32mal!) { say 42 }; my int8 $foo is cglobal[33m⏏[31m; # why does this no worky?[0…»

[19:03] *** Akagi201 left
[19:04] <FROGGS> nvm

[19:07] <Mouq> lizmat: Yeah, looks like Grammar.nqp LL 4154, 4166 are at fault

[19:07] <Mouq> (Indirectly)

[19:07] <lizmat> testing fix

[19:08] <Mouq> m: module Foo { sub term:<foo>(*@) is export { "hi" } }; import Foo; say foo

[19:08] <camelia> rakudo-moar 59df77: OUTPUT«===SORRY!===␤Cannot find method 'orig'␤»

[19:09] <lizmat> 4178 also, I would guess then

[19:09] <lizmat> $ 6l 'module Foo { sub circumfix:<zap[ ]>(*@) is export { "hi" } }; import Foo; say zap[1];'

[19:09] <lizmat> hi

[19:10] *** raiph joined
[19:10] <lizmat> running spectest now

[19:10] <Mouq> lizmat: Does you fix break sub circumfix before an import, though?

[19:11] *** Sterver joined
[19:11] <lizmat> do you have an example ?

[19:11] *** Ven joined
[19:11] <vendethiel> soo. some little stuff I picked up while working durin gthe afternoon ...

[19:11] <Sterver> hi all

[19:11] <Ven> m: Nil.push: 1; # this loops 

[19:11] <camelia> rakudo-moar 59df77: OUTPUT«(timeout)»

[19:11] <Ven> m: my @a; [$@a][0].push: 1; say @a.perl; # is this supposed to work? useful that it does, but I kinda expected $ to return a "different" "reference". 

[19:11] <camelia> rakudo-moar 59df77: OUTPUT«Array.new(1)␤»

[19:12] <Mouq> lizmat: Does `sub circumfix:<e[ ]>(*@) { "hi" }; say e[1]` still work?

[19:12] <Ven> Also: say $*OUT.slurp, type some stuff, CR then ^D will give "write string requires an object with REPR MVMOSHandle" (might be a MoarVM bug, can't repro on camelia)

[19:12] <Ven> and lastly, is there already a package of a method to get a temp file? I actually wanted to buffer output, but had to resort to creating the file manually etc

[19:12] <FROGGS> hi Sterver 

[19:12] <lizmat> Mouq: nope, that now breaks with 'cannot find .orig'

[19:12] <Ven> o/ Sterver 

[19:13] <lizmat> hmmm...  so you could argue it's something in the export mechanism

[19:13] * Ven dumps some "bug reports" here and there

[19:13] <Mouq> The LTA error can be fixed by adding :node($/) to the lines mentioned above, but yeah, I think it's an issue with do_import

[19:13] <Mouq> or export

[19:13] <FROGGS> Ven: I hope either 'here' or 'there' is RT

[19:13] <Sterver> How can I repair this: ===SORRY!=== Error while compiling PORN.p6 multi-dimensional indexes not yet implemented. Sorry. at PORN.p6:18 ------> 		}⏏<EOL>

[19:14] <Ven> FROGGS: both are "this channel"

[19:14] <FROGGS> :/

[19:14] <Ven> as I'm not sure what should happen

[19:14] <Sterver> this is that part of code: http://pastebin.com/2Aq3h3L7

[19:14] <Ven> I should probably report the moarvm one to the github repo, tho?

[19:14] <lizmat> Ven: anything called on Nil should give Nil

[19:14] <Ven> lizmat: well, here, it gives an infinite loop

[19:14] <Ven> also, I've asked before, but: why??

[19:14] <Mouq> Sterver: That part of the code is probably not what is causing the error

[19:14] *** domidumont left
[19:15] <FROGGS> Sterver: what is in the lines before 18?

[19:15] <Sterver> oh, wait

[19:15] <Sterver>  17                 my $percentage = (100-$runs/$poc*100);

[19:16] <Mouq> Sterver: what's perl6 -v ?

[19:16] <FROGGS> Sterver: no, there must be something accessing an array

[19:16] *** kjs_ joined
[19:16] <Sterver> Mouq: This is perl6 version 2013.12 built on parrot 5.9.0 revision 0

[19:17] <lizmat> wow, that's *ancient* !

[19:17] <Sterver> FROGGS, i dont use arrays in this program

[19:17] <FROGGS> Sterver: this error message is not even in our codebase anymore... so perhaps upgrading to a newer rakudo version will help

[19:17] <Mouq> Sterver: Recommended solution: https://github.com/tadzik/rakudobrew

[19:18] <Sterver> oh.. ok :)

[19:18] *** nbrown__ joined
[19:18] <Sterver> thanks, i'll try

[19:18] <lizmat> Mouq: with the :node additions, we now get: Variable '&&circumfix:<zap[ ]>' is not declared

[19:18] <lizmat> which clearly shows the problem

[19:18] <FROGGS> Sterver: build for MoarVM backend, this will take just threeish minutes and you are done

[19:18] <Ven> err, do I need to explicitly list every module in the META.info?

[19:18] <Sterver> are here any lunchpad repos for actual perl6?

[19:18] <Ven> I mean, package

[19:18] <Ven> Sterver: lunchpad repos?

[19:18] <FROGGS> Ven: every direct dependency

[19:19] <FROGGS> Ven: no, dists

[19:19] <Ven> FROGGS: what?

[19:19] <FROGGS> Ven: distributions

[19:19] *** pyrimidine joined
[19:19] <Sterver> Ven: for ubuntu I ment https://launchpad.net/ubuntu

[19:19] <Ven> alright.

[19:19] <Ven> You were replying to that part...

[19:19] <Ven> FROGGS: "direct dependency"?

[19:20] <Sterver> probably not :D

[19:20] <FROGGS> Ven: I thought you were asking if you need to list the deps of your deps

[19:20] <dalek> rakudo/nom: 8007565 | (Elizabeth Mattijsen)++ | src/Perl6/Grammar.nqp:

[19:20] <dalek> rakudo/nom: Make import errors less LTA

[19:20] <dalek> rakudo/nom: 

[19:20] <dalek> rakudo/nom: Instead of "Cannot find method 'orig'", we now get a proper error message

[19:20] <dalek> rakudo/nom: when not finding an exported operator.  Mouq++ for directions.

[19:20] <FROGGS> Ven: but I think you're'nt

[19:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8007565de5

[19:20] <Ven> FROGGS: no, I mean every package my code has

[19:21] <FROGGS> Ven: no, the top level one is enough, so one entry per repository you depend on

[19:21] <Ven> I mean perl6 "package"

[19:21] <Ven> not ecosystem packages

[19:21] <Mouq> lizmat: Now to figure out WTF is going wrong with import/export :D

[19:21] <lizmat> yup

[19:21] <FROGGS> Ven: yes, I understand

[19:21] <Ven> I don't think so...

[19:22] <Ven> FROGGS: ie I have Sprockets, Sprockets:::File, do I need provides: {Sprockets: ..., Sprockets::File:...}?

[19:22] <FROGGS> Ven: you do not need to list every namespace you depend on

[19:22] <Ven> I know I'm really unclear

[19:22] *** nbrown__ left
[19:22] <FROGGS> Ven: yes, you do need to put in every namespace you provide

[19:22] <Ven> only the one with the `is export` "main"s/classes?

[19:22] <Ven> alright. thanks

[19:22] <FROGGS> Ven: even when you declare several namespaces per file, list every namespace that point to the same file

[19:24] <Ven> noted.

[19:24] <Ven> is there some kind of ordering in ecosystem/META.list?

[19:25] *** Sqirrel joined
[19:25] <FROGGS> Ven: no

[19:26] <Ven> then...

[19:26] <dalek> ecosystem: 4d19641 | Nami-Doc++ | META.list:

[19:26] <dalek> ecosystem: Add Sprockets

[19:26] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/4d19641503

[19:26] <Ven> \o/

[19:26] <lizmat> Mouq: I'm starting to think it may be a codegen issue on the zap[1]

[19:27] <Ven> first published package. Now I'll focus back on my preprocessors...

[19:27] <FROGGS> Ven: what is that?

[19:27] <Ven> FROGGS: Ruby/Rails's Sprockets-thingie.

[19:27] <pyrimidine> masak: found out the problem thanks to FROGGS++.  Had a PERL6LIB in my env pulling in an old module which caused problems.  Updated RT #122660

[19:27] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122660

[19:27] <Ven> asset manager for the web.

[19:28] <FROGGS> pyrimidine: \o/

[19:28] <FROGGS> pyrimidine: also, that BEGIN { @*INC.push... } made me curious :o)

[19:28] <Ven> FROGGS: basically, responsible for "manifest" asset files, preprocessor usage, etc.

[19:28] <Mouq> lizmat: That was my first though, but maybe add_categorical just expects something different than do_import feeds it

[19:28] <lizmat> Mouq: --target=ast seems to indicate QAST::Op(call &&circumfix:<zap[ ]>) zap[1]

[19:28] <Mouq> *thought

[19:28] <FROGGS> pyrimidine: because 'use lib' unishifts, and that usually make more sense

[19:29] <pyrimidine> FROGGS++ (again).  Yep, and RAKUDO_MODULE_DEBUG=1 helped work that out

[19:29] <Mouq> lizmat: Gimme a bit to test a possible fix...

[19:29] <FROGGS> nice

[19:30] <Mouq> spectest &

[19:30] <jepeway> so...might somebody point me to some LHF I could take a beginners swing at?

[19:34] <FROGGS> jepeway: this? RT #122319

[19:34] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122319

[19:36] * jepeway looks

[19:36] <FROGGS> jepeway: and/or this: RT #122173

[19:36] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122173

[19:38] *** mberends left
[19:39] *** SamuraiJack joined
[19:39] <jepeway> FROGGS: think I'll chew away at the timezone tests, thanks.

[19:40] <FROGGS> ++jepeway

[19:42] <jepeway> well, FROGGS++ for the pointing out

[19:44] <mr-foobar> jnthn: I wonder if this can be useful for jvminterop http://web.stanford.edu/class/cs243/joeq/javadoc/joeq/Util/DescriptorUtil.html

[19:44] <carlin> are those timezone tests supposed to actually work?

[19:44] *** chenryn left
[19:44] <carlin> they rely on rakudo being able to work out DST in various timezones

[19:50] *** avuserow left
[19:51] <carlin> if I do, DateTime.new('2014-02-01T07:00:00Z').local

[19:51] <carlin> the result is 2014-02-01T19:00:00+1200

[19:51] <carlin> those tests expect the result to be: 2014-02-01T18:00:00+1300

[19:52] <lizmat> vendethiel: the basic problem with Nil.push is really:

[19:52] <carlin> because my timezone was in DST in February

[19:52] <lizmat> m: say Nil.^mro

[19:52] <camelia> rakudo-moar b4f6b5: OUTPUT«Nil (Iterator) (Iterable) (Cool) (Any) (Mu)␤»

[19:52] <carlin> I don't think that's right

[19:52] <jepeway> carlin: yeah, I'm thinking the test's notion of DST is...off. trying to confirm.

[19:52] <lizmat> any method that exists in these classes, is tried with Nil as self

[19:52] <lizmat> some give errors:

[19:53] <lizmat> m: say Nil.first-index

[19:53] <camelia> rakudo-moar b4f6b5: OUTPUT«Cannot call 'first-index'; none of these signatures match:␤:(Any: Bool:D $t, *%_)␤:(Any: Regex:D $test, *%_)␤:(Any: :D $test, *%_)␤:(Any: $test, *%_)␤  in block <unit> at /tmp/wbqho2BkYx:1␤␤»

[19:53] <lizmat> and others (like the auto-vivifying .push and .unshift) loop

[19:53] <jepeway> m: use Test; note 'foo'

[19:53] <camelia> rakudo-moar b4f6b5: OUTPUT«foo␤»

[19:53] <lizmat> all add .push and .unshift to Nil for now, to prevent hanging

[19:53] <vendethiel> can we fix that?

[19:54] <vendethiel> :|

[19:54] <jepeway> shouldn't that be "# foo"?

[19:54] <lizmat> jepeway: no

[19:54] <vendethiel> jepeway: note is not from Test

[19:54] <jepeway> or am I showing 5er bias?

[19:54] <lizmat> m: use Test; diag "foo"

[19:54] <camelia> rakudo-moar b4f6b5: OUTPUT«# foo␤»

[19:54] <jepeway> aha!

[19:54] <vendethiel> at least I don't think so

[19:54] <lizmat> m: note

[19:55] <camelia> rakudo-moar b4f6b5: OUTPUT«Noted␤»

[19:55] <lizmat> :-)

[19:57] *** SamuraiJack left
[19:58] <jepeway> m: note 'eep' ; say 'eel'

[19:58] <camelia> rakudo-moar b4f6b5: OUTPUT«eep␤eel␤»

[19:59] <jepeway> what's the diff 'twixt the 2? can note be suppressed, eg?

[19:59] <grondilu> m: module Foo { our @a := 1 xx *; our sub f { @a[^3] } }; @Foo::a[0] = -1; say Foo::f;

[19:59] <camelia> rakudo-moar b4f6b5: OUTPUT«1 1 1␤»

[19:59] <grondilu> n: module Foo { our @a := 1 xx *; our sub f { @a[^3] } }; @Foo::a[0] = -1; say Foo::f;

[19:59] <camelia> niecza v24-109-g48a8de3: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/nBlWe0As6y line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4595 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4596 (module-CORE @ 576) ␤  at /home/p6e…»

[20:00] <grondilu> rakudo should have died here as well

[20:01] <jepeway> (can I be asking these elementary q's here? I'll be patient re: answers and understand should none come)

[20:01] <grondilu> don't ask to ask

[20:01] <FROGGS> jepeway: I think note() prints to stderr

[20:01] <lizmat> note is say to STDERR (or $*ERR as it's called here)

[20:01] <dalek> rakudo/nom: ccee46e | Mouq++ | src/Perl6/World.nqp:

[20:01] <dalek> rakudo/nom: Fix exporting circumfixes and terms

[20:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ccee46ef0f

[20:02] <lizmat> Mouq++

[20:02] <dalek> roast: 00a2b66 | Mouq++ | / (2 files):

[20:02] <dalek> roast: Add test for exporting circumfixes

[20:02] <dalek> roast: review: https://github.com/perl6/roast/commit/00a2b662bb

[20:02] <grondilu> lizmat++ Mouq++.  Awesome guys

[20:03] <jepeway> grondilu: hokay.

[20:04] <jepeway> lizmat, FROGGS: got it.

[20:04] *** kaare_ left
[20:06] * Mouq badly wants slangy macros for a project he's working on

[20:07] *** Sterver left
[20:09] <lizmat> m: Nil = 3 # feels this should fail somehow

[20:09] <camelia> rakudo-moar b4f6b5: ( no output )

[20:10] <grondilu> ok

[20:10] *** grondilu left
[20:12] *** raiph left
[20:14] *** broquaint joined
[20:16] *** brrt joined
[20:16] *** brrt left
[20:17] *** raiph joined
[20:18] *** nbrown__ joined
[20:20] *** avuserow joined
[20:21] *** grondilu joined
[20:22] *** nbrown__ left
[20:23] <Ven> std: $_ = 1

[20:23] <camelia> std 53b3ca6: OUTPUT«ok 00:01 123m␤»

[20:23] <Ven> eh. thought this was a p5ism somewhat?

[20:24] <lizmat> but one that is allowed, afaik

[20:24] <lizmat> Ven: BTW, soon it will do:

[20:24] <lizmat> $ 6 'Nil.push'

[20:24] <lizmat> Attempted to push to Nil.

[20:24] <vendethiel> lizmat: thanks! Was trying to figure out why prove was running blind for a while

[20:26] <vendethiel> I know I asked some other stuff ... like $@some_var.push: 1; pushing to @some_var, handy but "how does it work"y; too

[20:27] <lizmat> I was focussing on potential hangs...

[20:27] <lizmat> and am about to call it a night...

[20:28] *** ecocode joined
[20:32] <dalek> rakudo/nom: 0099d69 | (Elizabeth Mattijsen)++ | src/core/Nil.pm:

[20:32] <dalek> rakudo/nom: Some cleanup in Nil handling.

[20:32] <dalek> rakudo/nom: 

[20:32] <dalek> rakudo/nom: - Making sure specific methods wil catch all possible params combinations

[20:32] <dalek> rakudo/nom: - Adding several modifying methods to have them die (possible infiniloops)

[20:32] <dalek> rakudo/nom: - Add 'sink' method, because RESTRICTED setting apparently needs that

[20:32] <dalek> rakudo/nom: 

[20:32] <dalek> rakudo/nom: vendethiel++ for mentioning issues

[20:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0099d69b1f

[20:33] <vendethiel> lizmat++

[20:35] <dalek> specs: c6448fe | (Elizabeth Mattijsen)++ | S02-bits.pod:

[20:35] <dalek> specs: Make attempting changes to Nil cause an exception.

[20:35] <dalek> specs: review: https://github.com/perl6/specs/commit/c6448fece2

[20:37] <lizmat> goodnight, #perl6&

[20:37] <timotimo> gnite lizmat :)

[20:37] <Mouq> 'night lizmat++

[20:37] <Ven> gnite !

[20:37] <pyrimidine> lizmat++

[20:44] *** flussence joined
[20:46] *** nbrown__ joined
[20:47] *** flussence left
[20:47] *** flussence joined
[20:53] *** Ven left
[20:54] *** raiph left
[20:56] *** dolmen joined
[21:00] *** zakharyas1 left
[21:04] <dalek> doc: ecb3848 | (Kamil Kułaga)++ | bin/p6doc-index:

[21:04] <dalek> doc: s/$*PROGRAM_NAME index/$*PROGRAM_NAME build/

[21:04] <dalek> doc: 

[21:04] <dalek> doc: there is no such option index

[21:04] <dalek> doc: review: https://github.com/perl6/doc/commit/ecb38485c2

[21:05] *** denis_boyun___ joined
[21:05] *** denis_boyun_ left
[21:08] *** molaf__ left
[21:09] *** JL235__ joined
[21:10] *** cooper joined
[21:10] *** cooper left
[21:10] *** cooper joined
[21:11] *** cooper left
[21:11] *** cooper joined
[21:11] *** cooper left
[21:11] *** cooper joined
[21:11] <grondilu> p6: class Foo { method postcircumfix:<[ ]>(Int $n) { "$n\!" } }; say Foo.new[5];

[21:12] <camelia> rakudo-jvm ccee46: OUTPUT«(timeout)»

[21:12] <camelia> ..rakudo-moar ccee46: OUTPUT«Index out of range. Is: 5, should be in 0..0␤  in method gist at src/gen/m-CORE.setting:13287␤  in sub say at src/gen/m-CORE.setting:14222␤  in block <unit> at /tmp/tmpfile:1␤␤»

[21:12] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«5!␤»

[21:12] <camelia> ..rakudo-parrot ccee46: OUTPUT«Index out of range. Is: 5, should be in 0..0␤  in method gist at gen/parrot/CORE.setting:13225␤  in method gist at gen/parrot/CORE.setting:1107␤  in sub say at gen/parrot/CORE.setting:14180␤  in sub say at gen/parrot/CORE.setting:14167␤  in blo…»

[21:12] *** nbrown__ left
[21:13] *** xinming_ left
[21:16] <Mouq> We need to warn on method postcircumfix:*, but it's pretty much deprecated in Rakudo

[21:17] <jepeway> FROGGS: so...a quick q re: DateTime.in-timezone() b/4 I gotta run.

[21:17] <grondilu> Mouq: what do you mean?

[21:18] *** dolmen left
[21:18] <grondilu> do you mean I should use a sub maybe?

[21:18] <jepeway> FROGGS: seems like there's 2 notions of "timezone." first is "my locale's offset from GMT."

[21:19] <jepeway> FROGGS: second is "the set of rules my locale uses to determine offset from GMT for any given time."

[21:19] <Mouq> grondilu: Yeah a multi, the method forms no longer work, except postcircumfix:<( )>, though method invoke is preferred to that now

[21:20] *** gfldex left
[21:20] <Mouq> grondilu: Alternatively, use method at_pos if you only care about single values

[21:20] <FROGGS> jepeway: I'm not sure I am the best person to ask... masak has implemented the DateTime stuff in P6, and drolsky is the gof of Perl 5's DateTime

[21:20] <jepeway> FROGGS: I think the temporal/local tests conflate the two.

[21:20] <FROGGS> jepeway: yeah, I guess that is likely

[21:20] <jepeway> FROGGS: gof?

[21:21] * grondilu tries at_pos

[21:21] <FROGGS> jepeway: 'god', sorry

[21:22] <jepeway> FROGGS: (np.) I can ask masak later, then.

[21:22] <FROGGS> yeah, might be the best

[21:23] *** pyrimidine left
[21:28] *** JL235__ left
[21:29] *** kjs_ left
[21:29] *** nbrown__ joined
[21:30] *** khisanth_ joined
[21:31] *** JL235 joined
[21:31] <jepeway> hm.  gotta golf my q down a bit. but gotta run, instead.

[21:32] *** Khisanth left
[21:32] *** raiph joined
[21:33] *** rindolf left
[21:34] *** avuserow left
[21:41] *** ggoebel1111111 joined
[21:41] *** Mouq left
[21:43] *** ggoebel1111110 left
[21:48] *** pmurias left
[21:48] *** Mouq joined
[21:51] <dalek> rakudo/nom: 94952d9 | Mouq++ | src/core/Capture.pm:

[21:51] <dalek> rakudo/nom: :() is for Signatures, \() for Captures

[21:51] <dalek> rakudo/nom: 

[21:51] <dalek> rakudo/nom: Makes Capture.gist more round-trippy

[21:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/94952d92de

[21:51] <dalek> rakudo/nom: 1cbbe5e | Mouq++ | src/core/Nil.pm:

[21:51] <dalek> rakudo/nom: Merge branch 'nom' of http://github.com/rakudo/rakudo into nom

[21:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1cbbe5ef72

[21:55] <Mouq> m: my (*@a, :$from, :$to, :$classical) := \(<plasm dram>, :from<a>, :to<ata>)

[21:55] <camelia> rakudo-moar 0099d6: ( no output )

[21:57] *** cotto left
[21:57] *** cotto joined
[22:01] *** colomon joined
[22:03] *** pdcawley joined
[22:08] *** cooper left
[22:09] *** raiph left
[22:13] *** avuserow joined
[22:13] <Mouq> m: \(:key<a>).WHICH

[22:13] <camelia> rakudo-moar 0099d6: OUTPUT«Cannot find method 'keys': no method cache and no .^find_method␤  in submethod WHICH at src/gen/m-CORE.setting:7239␤  in block <unit> at /tmp/GukOZ87ZrD:1␤␤»

[22:14] <dalek> rakudo/nom: ebccb2a | Mouq++ | src/core/Capture.pm:

[22:14] <dalek> rakudo/nom: Fix \(:key<a>).WHICH

[22:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ebccb2a830

[22:17] *** telex left
[22:18] *** telex joined
[22:19] <grondilu> p6: class Foo {}; multi infix:<+>(Foo $, Foo $) { 1 }; say [+] Foo.new xx 4;

[22:19] <camelia> rakudo-jvm 0099d6: OUTPUT«(timeout)»

[22:19] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«Unhandled exception: Cannot use value like Foo as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 300 (Any.Numeric @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/COR…»

[22:19] <camelia> ..rakudo-parrot 0099d6: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in any  at gen/parrot/BOOTSTRAP.nqp:1221␤  in method Numeric at gen/parrot/CORE.setting:1070␤  in sub infix:<+> at gen/parrot/CORE.setting:4400␤  in sub infix:<+> at gen/p…»

[22:19] <camelia> ..rakudo-moar 0099d6: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<+> at src/gen/m-CORE.setting:4396␤  in sub  at src/gen/m-CORE.setting:17951␤  in block <unit> at /tmp/tmpfile:1␤␤»

[22:20] <timotimo> grondilu: may need to add candidates for only (Foo $)

[22:20] <timotimo> a candidate*

[22:20] <Mouq> m: class Foo {}; multi infix:<+>(Foo $, Foo $?) { 1 }; say [+] Foo.new xx 4;

[22:20] <camelia> rakudo-moar 0099d6: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<+> at src/gen/m-CORE.setting:4396␤  in sub  at src/gen/m-CORE.setting:17951␤  in block <unit> at /tmp/7ZoB34hcRY:1␤␤»

[22:21] <Mouq> m: class Foo {}; multi infix:<+>(Foo $?, Foo $?) { 1 }; say [+] Foo.new xx 4;

[22:21] <camelia> rakudo-moar 0099d6: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<+> at src/gen/m-CORE.setting:4396␤  in sub  at src/gen/m-CORE.setting:17951␤  in block <unit> at /tmp/5oePjYQSSn:1␤␤»

[22:21] * Mouq really wishes that would display the Capture it's called with

[22:21] <timotimo> aye.

[22:22] * Mouq tries to fulfill that wish

[22:22] <timotimo> i don't really know what to do at the moment

[22:22] *** denis_boyun___ left
[22:22] <timotimo> p6 related stuff, i mean

[22:26] <cognome> r: use lib 'FOOO'; say @*INC

[22:26] <camelia> rakudo-moar 0099d6: OUTPUT«file:/home/p6eval/rakudo-inst-1/languages/perl6/lib inst:/home/p6eval/rakudo-inst-1/languages/perl6␤»

[22:26] <camelia> ..rakudo-jvm 0099d6: OUTPUT«file:/home/p6eval/rakudo-inst-1/languages/perl6/runtime file:/home/p6eval/rakudo-inst-1/languages/perl6/lib file:/home/p6eval/rakudo-inst-1/languages/nqp/lib file:/home/p6eval/rakudo-inst-1/languages/perl6/lib inst:/home/p6eval/rakudo-inst-1/languages/perl6␤»

[22:26] <camelia> ..rakudo-parrot 0099d6: OUTPUT«file:/home/p6eval/rakudo-inst-1/lib/parrot/6.7.0-devel/languages/perl6/lib inst:/home/p6eval/rakudo-inst-1/lib/parrot/6.7.0-devel/languages/perl6␤»

[22:27] <cognome> it drops it silently because of inadequate format?

[22:29] <Mouq> m: class Foo {}; multi infix:<+>(Foo $, Foo $) { 1 }; multi infix:<+> (Numeric $, Foo $) { 1 }; say [+] Foo.new xx 4;

[22:29] <camelia> rakudo-moar 0099d6: OUTPUT«1␤»

[22:30] <Mouq> It does (Foo + Foo) + Foo, which is 1 + Foo

[22:32] <grondilu> hum yeah

[22:32] <grondilu> p6: class Foo {}; multi infix:<+>(Foo $, Foo $) { Foo.new }; say [+] Foo.new xx 4;

[22:33] <camelia> rakudo-jvm 1cbbe5: OUTPUT«(timeout)»

[22:33] <camelia> ..rakudo-{parrot,moar} 1cbbe5: OUTPUT«Foo.new()␤»

[22:33] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«Foo.new(...)␤»

[22:33] <grondilu> I guess I'm missing a case in my module.

[22:35] * grondilu tries to find a simple example closer to his issue

[22:36] <grondilu> m: class Foo {}; multi infix:<+>(Foo $, Foo $) { 1 }; say [+] Foo.new xx 2;

[22:36] <camelia> rakudo-moar 1cbbe5: OUTPUT«1␤»

[22:36] <grondilu> m: class Foo {}; multi infix:<+>(Foo $, Foo $) { 1 }; say [+] Foo.new;

[22:37] <camelia> rakudo-moar 1cbbe5: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<+> at src/gen/m-CORE.setting:4395␤  in sub  at src/gen/m-CORE.setting:17947␤  in block <unit> at /tmp/MZMUd47oZS:1␤␤»

[22:40] *** nbrown__ left
[22:42] *** nbrown__ joined
[22:46] *** nbrown__ left
[22:48] *** beastd left
[22:55] <Mouq> Aww, surprisingly the Captures coming from NQP land are NQP Captures. Maybe they can be coerced somehow

[22:58] *** xragnar_ joined
[22:58] *** xragnar left
[22:58] *** xragnar_ is now known as xragnar

[23:10] *** nbrown__ joined
[23:13] <Mouq> Oh... it's a... MVMCallCapture?

[23:16] <Mouq> jnthn: What would be the best way to approach keeping a copy of the original Capture a routine is called with, for error reporting purposes? I'm concerned with how it would effect performance

[23:17] *** colomon left
[23:20] *** colomon joined
[23:22] *** nbrown__ left
[23:24] *** avuserow left
[23:27] *** avuserow joined
[23:31] *** spider-mario left
[23:34] *** fathogwash joined
[23:34] *** xenoterracide left
[23:34] *** fathogwash left
[23:36] *** silverpuff joined
[23:36] *** nbrown__ joined
[23:37] *** robinsmidsrod left
[23:38] *** robinsmidsrod joined
[23:39] *** dwarring joined
[23:41] *** colomon left
[23:42] *** nbrown__ left
[23:43] *** BenGoldberg joined
[23:44] *** avuserow left
[23:44] *** colomon joined
[23:45] *** silverpuff left
[23:47] *** jepeway left
[23:53] *** jerrycheung joined
[23:55] *** eiro left
[23:55] *** eiro joined
[23:55] *** immortal joined
[23:56] *** erkan left
[23:56] *** Psyche^ left
[23:56] *** Psyche^ joined
[23:59] *** nebuchad` joined
