[00:01] *** Mouq joined
[00:01] *** nbrown joined
[00:01] <Mouq> jnthn++

[00:01] <yoleaux> 14 Aug 2014 17:08Z <jnthn> Mouq: MoarVM HEAD fixes the htmlify grapheme iter crash

[00:01] *** immortal joined
[00:01] *** immortal left
[00:01] *** immortal joined
[00:02] *** erkan left
[00:02] *** zakharyas left
[00:05] *** nbrown left
[00:09] <rurban> I had to read a lot of wrong things about parrot here .2013-02-07#i_6423589 on reddit. First parrot threading is better than moar threading. No blocking, it scales linearily. Second, parrot is actively being maintained.

[00:10] <rurban> Missing async and signals is a good point though

[00:26] *** iarna left
[00:33] *** BenGoldberg joined
[00:36] <Mouq> What's missing to make "LoL" a + on http://perl6.org/compilers/features ?

[00:37] <Mouq> m: my @a = [ [5,3], [6,2] ]; @a[*;1] = @a[*;0] X+ 1; say @a.perl

[00:37] <camelia> rakudo-moar f4ed49: OUTPUT«Array.new([[5, 3], 3])␤»

[00:37] <Mouq> m: my @a = [5,3], [6,2]; @a[*;1] = @a[*;0] X+ 1; say @a.perl

[00:37] <camelia> rakudo-moar f4ed49: OUTPUT«Array.new([5, 6], [6, 7])␤»

[00:41] *** jnap joined
[00:56] <TimToady> I guess we just need to rewrite all the 2d logic on RC to use the new notation, but so far it looks pretty good to me :)

[00:57] *** thou joined
[00:57] <TimToady> will also be nice when we get this integrated with shaped array support eventually

[00:57] <TimToady> but it's looking pretty LoLish to me

[00:58] *** BenGoldberg left
[00:59] <TimToady> it's really cool to see things that were specced a decade ago finally coming into being

[01:00] *** jnap left
[01:01] *** nbrown joined
[01:01] *** thou left
[01:04] *** AforAcronym left
[01:05] *** nbrown left
[01:08] *** BenGoldberg joined
[01:08] *** dayangkun joined
[01:11] *** psch left
[01:13] <Mouq> Hm.. Looks like we still need &lol, and we could use better integration with the subs and Cool.methods

[01:14] <Mouq> S29:413 shouldn't that be --> LoL

[01:14] <synopsebot> Link: http://perlcabal.org/syn/S29.html#line_413

[01:14] *** iarna joined
[01:16] <TimToady> yeah, I suspect so

[01:17] <TimToady> we probably need to make sure that ** params bind nicely to a LoL

[01:17] <Mouq> Oh, that's another thing too, they hyper-thingies

[01:18] <TimToady> alternately, lol doesn't really produce a LoL, but just an itemized list of lists

[01:18] <TimToady> er, a list of itemized lists

[01:18] <TimToady> but that's what ** is supposed to do anyway

[01:18] <TimToady> yeah, also hyperwhatever, and || interpolation

[01:19] *** psch joined
[01:20] <TimToady> so the other theory is that lol is simply a binder to a **@lists param, and returns that

[01:20] <TimToady> but this whole business is something we need to feel our way into

[01:20] <psch> with $/ being implicit without an argument, i think?

[01:21] <psch> S05 suggests something like that -- that's one of the things missing for m:g//

[01:21] <psch> S05:"Capturing from repeated matches" 

[01:21] <psch> or is that just topicalization inside the if?

[01:22] * TimToady doesn't understand what you're asking

[01:22] <TimToady> this doesn't seem to have much to do with LoL

[01:22] <psch> yeah, i misremembered.  :g doesn't do anything with LoL, :ex and :ov do

[01:22] <psch> or maybe i'm just misunderstanding in general :)

[01:23] <psch> it doesn't directly relate i guess

[01:23] <TimToady> we were talking about LoL and ** binding just before you came on

[01:23] <TimToady> not ** as in regex

[01:23] <TimToady> but I can how you might misread what I said

[01:23] <psch> i did catch the backlog, i was wondering about lol() in the example in S05 under "Capturing from repeated matches"

[01:24] <TimToady> okay

[01:24] <psch> say "Match { +lol() } times"

[01:24] <TimToady> it's certainly true that submatches may themselves be lists

[01:25] <TimToady> but as I say, we're still kinda feeling our way into this multidimensional thing

[01:25] <TimToady> and it's not always clear at what point we want to switch from a structural definition to a typed definition

[01:26] <TimToady> we use the LoL type to distinguish a .[1,2,3] subscript from a .[1,2,3;4,5,6] subscript

[01:27] <TimToady> but outside of that, we probably want to define things as structural, so if we can get away with not creating a LoL object every time we don't flatten (or however you say that positively), then I think that's probably a good thing

[01:28] <Mouq> TimToady, would **@lol simplify, e.g., infix:<Z>?

[01:28] <TimToady> so maybe lol itself doesn't want to return a LoL, just something that is a list of individually lazy sublists that won't automatically flatten

[01:29] <TimToady> well, that's generally a list of two lists, but it could be more, since it's list associative

[01:29] <TimToady> @foo Z @bar Z @baz

[01:29] <TimToady> and each of them is potentially lazy

[01:30] *** FROGGS_ joined
[01:30] <Mouq> m: my @a = 1,2,3; my @b = 4,5,6; sub foo (*@a) { say @a.perl }; foo @a, @b

[01:30] <camelia> rakudo-moar f4ed49: OUTPUT«Array.new(1, 2, 3, 4, 5, 6)␤»

[01:30] <Mouq> Ahh

[01:30] <TimToady> it's a bit of an intrusion for the grammar to install a LoL coercion, but it arises in subscripts because we don't want to wrap up every single-dimensional slice up as if it's multi-dimensional

[01:31] <TimToady> m: my @a = 1,2,3; my @b = 4,5,6; sub foo (**@a) { say @a.perl }; foo @a, @b

[01:31] <camelia> rakudo-moar f4ed49: OUTPUT«LoL.new([1, 2, 3], [4, 5, 6])␤»

[01:31] <TimToady> I guess ** does automatically make a LoL

[01:31] <Mouq> Oh! I thought it was NYI

[01:31] <TimToady> no, we've actually had that part for a long time :D

[01:31] <psch> the other ** is NYI though

[01:32] <TimToady> right, HyperWhatever

[01:32] <TimToady> and prefix:<||>, to interplate at the dimensional level rather than the list level

[01:32] <Mouq> Hm, how would you use that in a closure?

[01:32] <psch> TimToady: i think the spec example i mentioned above wants to be .lol then? seeing as it's supposed to act on $/, which should be the topic in the if

[01:33] <Mouq> psch: Might be a typo or artifact

[01:33] *** FROGGS left
[01:33] <psch> m: say (******)([1,2,3],[1,2,3])

[01:33] <camelia> rakudo-moar f4ed49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/OASF04oczF␤HyperWhatever (**) not yet implemented. Sorry. ␤at /tmp/OASF04oczF:1␤------> [32msay (**[33m⏏[31m****)([1,2,3],[1,2,3])[0m␤»

[01:33] *** Sqirrel left
[01:33] <psch> somewhat like that, i think

[01:34] <BenGoldberg> std: say (******)([1,2,3],[1,2,3])

[01:34] <camelia> std 81e0d07: OUTPUT«ok 00:01 129m␤»

[01:34] <Mouq> m: say (1,2,{@_.&sum}...*)[^5]

[01:34] <camelia> rakudo-moar f4ed49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/hmyCV5USHa␤Undeclared routine:␤    &sum used at line 1␤␤»

[01:34] <TimToady> m: say [Z+] (1,2,3),(4,5,6),(7,8,9);

[01:34] <camelia> rakudo-moar f4ed49: OUTPUT«12 15 18␤»

[01:34] <TimToady> there's a hidden **

[01:35] <TimToady> but you'll notice that the lists are not separated by ; there

[01:35] <Mouq> m: say (1,2,{@_.join.Int}...*)[^5]

[01:35] <camelia> rakudo-moar f4ed49: OUTPUT«1 2 12 1212 12121212␤»

[01:36] <Mouq> m: say (1,2,**.join.Int...*)[^5] # Is this right?

[01:36] <camelia> rakudo-moar f4ed49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/I9LNI4s4nm␤HyperWhatever (**) not yet implemented. Sorry. ␤at /tmp/I9LNI4s4nm:1␤------> [32msay (1,2,**[33m⏏[31m.join.Int...*)[^5] # Is this right?[0m␤»

[01:36] <Mouq> (On my part, not rakudo's)

[01:37] <TimToady> well, if 1 and 2 were both lists, it might make more sense

[01:37] *** obra left
[01:37] <Mouq> Right...

[01:37] <Mouq> I just have trouble wrapping my head around some of this stuff

[01:38] <psch> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my $a = A.new; .say for $a 

[01:38] <camelia> rakudo-moar f4ed49: OUTPUT«A.new()␤»

[01:38] <psch> that's even differenter than i expected

[01:39] <Mouq> Is there a use case for a currying HyperWhatever?

[01:39] <TimToady> beats me

[01:39] <psch> i came across the combination of .Str() and .list() with m:g// and wondered which it should be in e.g. for

[01:39] <Mouq> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my $a = A.new; .print for $a

[01:39] <camelia> rakudo-moar f4ed49: OUTPUT«foo»

[01:39] <Mouq> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my $a = A.new; .say for @$a

[01:39] <camelia> rakudo-moar f4ed49: OUTPUT«a␤b␤c␤»

[01:40] <psch> Mouq++: thanks

[01:40] <psch> TimToady: should $/ after a m:g// prefer .list over .Str?

[01:41] <psch> in a for, as in Mouq's two examples

[01:41] *** chenryn left
[01:41] <TimToady> that's an excellent question, except that $/ is an item, so maybe it's more like @/

[01:42] <psch> the actual case i'm worrying about is 'for m:g/./ { ... }'

[01:42] <psch> which, as i have it, gives the whole match once

[01:42] <TimToady> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my \a = A.new; .say for a

[01:42] <camelia> rakudo-moar f4ed49: OUTPUT«A.new()␤»

[01:42] <TimToady> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my \a = A.new; .say for a,

[01:42] <camelia> rakudo-moar f4ed49: OUTPUT«A.new()␤»

[01:42] <TimToady> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my \a = A.new; .say for a,a

[01:42] <camelia> rakudo-moar f4ed49: OUTPUT«A.new()␤A.new()␤»

[01:42] <PerlJam> psch: That's a "say what you mean" situation to me.  i.e. you need to say .list if that's what you mean.

[01:42] *** rindolf left
[01:43] <TimToady> for something that isn't an item, it sure keeps acting like an item :)

[01:43] *** chenryn joined
[01:43] <Mouq> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my @a := A.new; .say for @a

[01:43] <camelia> rakudo-moar f4ed49: OUTPUT«Type check failed in binding; expected 'Positional' but got 'A'␤  in any bind_error at src/vm/moar/Perl6/Ops.nqp:221␤  in block  at /tmp/mT47VeaoYx:1␤␤»

[01:43] <TimToady> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my \a = A.new; say list(a).WHAT

[01:43] <camelia> rakudo-moar f4ed49: OUTPUT«(List)␤»

[01:44] <TimToady> arguably, things in a list context should prefer a .list interpretation

[01:44] <TimToady> m: class A { method Str() { "foo" }; method list() { <a b c> } }; my \a = A.new; say a.list.WHAT

[01:44] <camelia> rakudo-moar f4ed49: OUTPUT«(Parcel)␤»

[01:44] <psch> PerlJam: that's the assumption i was operating under, and how the branch works currently.  still, i'm not really happy with it

[01:44] <dalek> rakudo/nom: f9f7464 | Mouq++ | src/core/LoL.pm:

[01:44] <dalek> rakudo/nom: Add &lol

[01:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9f7464137

[01:45] <Mouq> One of my more complicated commits

[01:45] <TimToady> you're getting cynical in your old age :)

[01:45] *** klapperl_ joined
[01:45] <psch> fwiw, https://github.com/perl6/roast/compare/matching_quote_ops are the spectest changes to get those tests to pass for https://github.com/peschwa/rakudo/tree/rt82108

[01:46] <Mouq> TimToady, how's they eye btw?

[01:46] <TimToady> the bubble keeps getting smaller

[01:47] <TimToady> still somewhat inflamed as long as I'm reabsorbing stitches, but it doesn't seem to be sending too many leucocytes in the direction of my cornea graft

[01:47] <Mouq> Glad to hear it's improving though! :)

[01:47] <psch> PerlJam: the break-neck case is just 'for m:g/$pat/ { }' and 'for s:g/$pat/$rep/ { }', where .list or @(...) don't really seem idiomatic

[01:47] <Mouq> psch++

[01:48] <TimToady> yeah, likewise when you return something from a @a[1][2] and have to add a .list or [] on the end to get it to work

[01:48] *** klapperl left
[01:49] <PerlJam> aye, I guess that's true.  Perhaps I've gotten too used to saying @() or .list :)

[01:49] <TimToady> it's like, we don't really want to have a .list method that returns a Parcel, but a Match is a kind of Parcel, or Capture, or some such

[01:50] <TimToady> or contrariwise, things in list context should automatically have .list called on 'em at some point

[01:50] * TimToady thinks we're confusing two different things under .list currently

[01:51] <PerlJam> TimToady: how so?

[01:51] <TimToady> all these different list contexts turned into mere methods, and that's part of why we need a list refactor, so that we can negotiate up and down a list whether it's eager, hyper, sunk, etc

[01:52] <PerlJam> Hmm.  That rings true.

[01:53] <TimToady> and the whole point of having Parcels returned was to let it decide later whether it was in list or item context later

[01:53] <TimToady> but we're using .list both to indicate context and to return a Parcel, so it doesn't work right

[01:53] <TimToady> once we actually have parcels, it works out fine:

[01:54] <TimToady> m: say [Z+] (1,2,3),(4,5,6),(7,8,9);

[01:54] <camelia> rakudo-moar f4ed49: OUTPUT«12 15 18␤»

[01:54] <TimToady> those Parcels can wait until they get into [Z+] to decide whether to flatten or lol

[01:55] <TimToady> but the ideal of return a Parcel to be used within a list seems to have come on hard times

[01:55] <TimToady> *returning

[01:55] *** psch left
[01:56] <TimToady> I've kinda been putting off thinking about this till we do the list refactor, but now that pmichaud++ is availabler, and I've been getting ichier about list efficiency, it's probably time to work that out better

[01:56] <PerlJam> n: say [Z+] (1,2,3),(4,5,6),(7,8,9);  # curious

[01:56] <camelia> niecza v24-109-g48a8de3: OUTPUT«45␤»

[01:57] *** psch joined
[01:57] <TimToady> it takes special magic to get that to work, which I hacked into rakudo several months ago, but not into niecza

[01:58] <dalek> rakudo/S26-WHY: 9843893 | (Rob Hoelz)++ | src/Perl6/ (2 files):

[01:58] <dalek> rakudo/S26-WHY: Implement docs for subset types

[01:58] <dalek> rakudo/S26-WHY: review: https://github.com/rakudo/rakudo/commit/984389392a

[01:58] <dalek> rakudo/S26-WHY: 12bbede | (Rob Hoelz)++ | src/Perl6/Grammar.nqp:

[01:58] <dalek> rakudo/S26-WHY: Fix our Mu check

[01:58] <dalek> rakudo/S26-WHY: 

[01:58] <dalek> rakudo/S26-WHY: nqp::isnull(Mu)?  That's not true!  THAT'S IMPOSSIBLE

[01:58] <dalek> rakudo/S26-WHY: review: https://github.com/rakudo/rakudo/commit/12bbede072

[01:59] <Mouq> (TimToady++)

[01:59] <psch> i guess that means that for m:g// isn't really a Match issue, but a list context issue

[01:59] * Mouq is entertained that we can get ** to autocurry just by making HyperWhatever is Whatever

[02:00] <Mouq> m: class Whyever is Whatever { }; say Whyever.perl

[02:00] <camelia> rakudo-moar f4ed49: OUTPUT«WhateverCode.new()␤»

[02:00] <dalek> roast/S26-WHY: 0b9fb38 | (Rob Hoelz)++ | S26-documentation/why- (3 files):

[02:00] <dalek> roast/S26-WHY: Test docs on subset types

[02:00] <dalek> roast/S26-WHY: review: https://github.com/perl6/roast/commit/0b9fb3887b

[02:00] <dalek> roast/S26-WHY: bf5de42 | (Rob Hoelz)++ | S26-TODO.md:

[02:00] <dalek> roast/S26-WHY: Check off subset types from the list

[02:00] <dalek> roast/S26-WHY: review: https://github.com/perl6/roast/commit/bf5de4287d

[02:00] <dalek> roast/S26-WHY: 0639ccf | (Rob Hoelz)++ | S26-TODO.md:

[02:00] <dalek> roast/S26-WHY: Document weirdness

[02:00] <dalek> roast/S26-WHY: review: https://github.com/perl6/roast/commit/0639ccf137

[02:01] <TimToady> psch: it might also mean that Match is Parcel, or that the both share a role

[02:02] *** nbrown joined
[02:04] <PerlJam> hoelzro++ that todo is almost todone it seems  :)

[02:04] <hoelzro> it's close!

[02:04] <hoelzro> there are a few bugs

[02:04] <hoelzro> but I can start working on them after the matrix is full

[02:06] *** nbrown left
[02:09] <Mouq> TimToady: @a[**] should basically completely flatten the array, right?

[02:09] <TimToady> I don't think of it that way

[02:09] <TimToady> I think of it as meaning @a[*;*;*;*...] however many * you need

[02:10] *** kurahaupo_ left
[02:10] <TimToady> whereas @a[*] only gives you top dimension

[02:11] <psch> TimToady: maybe "should i start trying to make it work or wait for the list refactor" is the better utterance

[02:11] <psch> as in, aside from the behavior of m:g// in a for i don't have anything that's not to-spec for my branch, but that's a pretty big "aside"

[02:11] <psch> (also, landline is having trouble and my mobile is droppy, sorry for delays and rejoins)

[02:11] <TimToady> no problem, I'm interleaving dinner prep :)

[02:13] <TimToady> psch: if it requires a .list currently, we may well be able to relax that later, if things work out

[02:13] <Mouq> But that's the effect, isn't it? Unless we want @a[**;0] to grab the first element of the last dimension...

[02:14] <Mouq> *elements

[02:14] <TimToady> but we need to rethink how lists policies are distributed

[02:14] <TimToady> the thinking was that ** in a subscript could represent an arbitrary number of * in a row, potentially with normal dimensions on either or both ends

[02:15] <TimToady> that probably can't work unless you know the actual shape

[02:15] <TimToady> otherwise you don't know the boundary to stop at

[02:16] <Mouq> We can try guessing :P but that's probably not wise in the long run

[02:17] <TimToady> I'd think that @a[**] would return the dimensional info as parcels, and then it's someone else's decision whether to flatten

[02:17] <TimToady> there's always @a.flat if you need it :)

[02:17] <psch> oh, i just noticed one other thing that was a bit wonky with my changes.  RT #121789, where https://github.com/perl6/roast/commit/500a45e718d4d0f002850d12b85cf170c84d8416 has my thoughts on it

[02:17] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=121789

[02:17] <psch> those should maybe also go into the ticket

[02:19] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say @a[*;*;*].perl

[02:19] <camelia> rakudo-moar f4ed49: OUTPUT«(((1, 2, 3),), ((4, 5, 6),), ((7, 8, 9),), ((10, 11, 12),)).list␤»

[02:19] <Mouq> TimToady: Something like that ^ then?

[02:20] <TimToady> er, yeah :)

[02:20] <TimToady> hope you don't have much trouble implementing that, oh wait

[02:20] <Mouq> LoL

[02:21] <TimToady> though in the absence of shape, you'd have to guess from structure that [**] means [*;*;*]

[02:22] <TimToady> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say @a[*;*;*].tree.perl

[02:22] <camelia> rakudo-moar f4ed49: OUTPUT«([1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]).list␤»

[02:22] *** iarna left
[02:22] <TimToady> as you see, .tree is only defaulting to lol semantics at the moment

[02:23] <TimToady> spec says it should default to all levels, not first level

[02:24] <TimToady> in fact, it's very difficult to emulate that behavior in the absence of recursive .tree

[02:26] <TimToady> which may be why .tree hasn't done it yet :)

[02:28] <TimToady> but really, when you think about it, .tree is standing in for another one of those list negotiators that really wants to tell the originating code how to produce it, rather than actually going through the () intermediate form, at least on the optimizer level

[02:29] *** iarna joined
[02:32] <TimToady> it's almost like these are pseudomethods that are trying to shove adverbs back upstream to pick a different algo

[02:33] <TimToady> or wrapping different line disciplines or layers around a handle

[02:35] <TimToady> but we have to do it lazily depending on eventual bound context, so it's worse than just treating the contextualizers as fancy macros, because macros would pass adverbs at compile time, which is too early

[02:36] *** iarna left
[02:36] <TimToady> we also want to be able to distribute list policy over multiple list items, with optional recursion (a là .tree)

[02:38] <TimToady> *à la

[02:40] <TimToady> worse, you might have a contextualizer that depends on yet another contextualizer downstream lazily, so the the negotiation may include multiple hops

[02:41] *** prevost left
[02:41] *** iarna joined
[02:43] <TimToady> a lazy inside an eager is probably going to want to promote to eager, unless you're depending on side effects happening in a particular order

[02:45] <TimToady> but a lazy inside a sink (think 'for' loops) is almost certainly evaluating the lazy for its side effects, and you might want to 'last' out before getting all those side effects

[02:45] *** thou joined
[02:46] <TimToady> so all we really need to do is solve the halting problem for the loop :)

[02:49] *** thou left
[02:50] *** Sqirrel joined
[02:51] <Mouq> Can we ()[^5]:eager?

[02:51] *** noganex_ joined
[02:52] <TimToady> syntactically, sure

[02:52] <Mouq> :P

[02:52] <TimToady> but that's not gonna be lazy

[02:53] *** kurahaupo joined
[02:53] <TimToady> you'd (perhaps) like 'lazy ()[^5]' to behave differently from 'eager ()[^5]', where those contexts might not be determinable statically

[02:54] <TimToady> if it is determinable, you just put the particular output function, but if not, you return a meta-function that you talk to that gives you the appropriate output function to call

[02:54] *** noganex left
[02:54] <TimToady> it's all higher-order functions in the abstract, but those are hard to optimize before you know how they're boudn

[02:56] <TimToady> we want to avoid list functions remaking the same decisions each time they're called; that needs to come out into the meta-function, and the actual functions we eventually use to process a list can be simple

[02:57] <TimToady> we started to get there with .gimme but it's view of iterators is just not quite abstract enough

[02:58] <TimToady> these meta-functions might almost behave like junctions that leap outside the Any domain into the conceptual domain of Mu, then rewire the program for you

[02:58] <TimToady> only they'd do it for list args rather than items

[02:59] <TimToady> that's kinda why we have Mu outside of Any, to allow more conceptual types like junctions, but so far all we've used it for is junctions

[03:00] <TimToady> but as you might imagine, this is not a small refactor

[03:00] *** AforAcronym joined
[03:00] <TimToady> but given the Mu space, we can probably prototype it there and migrate list processing piecemeal

[03:00] <TimToady> gotta think more about this though...

[03:01] <TimToady> it's quite possible that this will make static analysis harder, but provide simpler semantics for the inliner and jitter

[03:02] *** Akagi201 left
[03:03] *** nbrown joined
[03:05] <psch> i don't have the brains anymore to add my thoughts to the ticket linked above; sleep it is o/

[03:05] <TimToady> o/

[03:05] *** psch left
[03:07] *** nbrown left
[03:13] *** lxmahyar joined
[03:16] * Mouq is trying to make sense of S02:1281

[03:16] * synopsebot Link: http://perlcabal.org/syn/S02.html#line_1281

[03:17] *** lxmahyar left
[03:19] * TimToady doesn't think we necessarily have to implement multidimensional ranges for ^** if ** means the same thing

[03:20] <TimToady> ^** is a bit out there

[03:20] <TimToady> it's sort of a ||( ^* xx *)

[03:21] <TimToady> might eventually be a useful idea, but might well not

[03:21] <TimToady> in any case, ** is already a multidimensional whatever, so maybe we don't need to generate multidim ranges

[03:22] <Mouq> Still, I'm not sure "@array[{ map { ^* }, @_ }]" makes sense. It doesn't to me, anyway

[03:22] *** dayangkun left
[03:22] <TimToady> especially since @a[**]:keys would give us something similar

[03:22] <TimToady> I think it's probably confusing autopriming with Inf there

[03:23] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;*]:keys).perl

[03:23] <camelia> rakudo-moar f9f746: OUTPUT«Unexpected named parameter 'keys' passed␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2507␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2663␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2663␤  in sub postcircumfix:<[ ]…»

[03:23] <TimToady> m: say (^*).WHAT

[03:23] <camelia> rakudo-moar f9f746: OUTPUT«(WhateverCode)␤»

[03:23] <TimToady> well, I guess it autoprimes

[03:23] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;*]:kv).perl

[03:23] <camelia> rakudo-moar f9f746: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<<> at src/gen/m-CORE.setting:4286␤  in method exists_pos at src/gen/m-CORE.setting:8127␤  in block  at src/gen/m-CORE.setting:2356␤  in sub SLICE_MORE at src/gen/…»

[03:23] <TimToady> since excluding Inf from 0..Inf is not terribly meaningful

[03:23] <TimToady> so maybe it does make sense(ish)

[03:25] <TimToady> presumably each key from the :kv has to be multidimensional [0,0,0] => 1, [0,0,1] => 2, etc

[03:26] <TimToady> presumably in the same parcel structure the values woulda come out

[03:26] *** xenoterracide joined
[03:26] <TimToady> well, $(0,0,0) => 1 mabye

[03:27] *** chenryn left
[03:27] <TimToady> or even just (0,0,0) => 1

[03:27] <TimToady> the pair kindof itemized its own self without help

[03:28] <TimToady> m: say ((0,0,0) => 1).perl

[03:28] <camelia> rakudo-moar f9f746: OUTPUT«$(0, 0, 0) => 1␤»

[03:28] <TimToady> yeah

[03:28] *** chenryn joined
[03:28] <TimToady> arguably it should be syntactically an item, but just use \ semantics on the key and value

[03:29] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;*]:delete).perl

[03:29] <camelia> rakudo-moar f9f746: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub infix:<<> at src/gen/m-CORE.setting:4286␤  in method delete_pos at src/gen/m-CORE.setting:8851␤  in block  at src/gen/m-CORE.setting:2207␤  in sub SLICE_MORE at src/gen/…»

[03:29] <Mouq> Huh

[03:30] <TimToady> that...might require a different visitation order...

[03:30] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;1]:delete).perl

[03:30] <camelia> rakudo-moar f9f746: OUTPUT«((2,), (5,), (8,), (11,)).list␤»

[03:30] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;1]:delete).perl; say @a.perl

[03:30] <camelia> rakudo-moar f9f746: OUTPUT«((2,), (5,), (8,), (11,)).list␤Array.new([[1, Any, 3], [4, Any, 6]], [[7, Any, 9], [10, Any, 12]])␤»

[03:31] <TimToady> just can't wildcard the last dim, I guess

[03:32] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;1]:kv).perl; say @a.perl

[03:32] <camelia> rakudo-moar f9f746: OUTPUT«(((1, 2),), ((1, 5),), ((1, 8),), ((1, 11),)).list␤Array.new([[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]])␤»

[03:32] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;1]:pairs).perl;

[03:32] <camelia> rakudo-moar f9f746: OUTPUT«Unexpected named parameter 'pairs' passed␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2507␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2663␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2663␤  in sub postcircumfix:<[ …»

[03:32] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say (@a[*;*;1]:p).perl;

[03:32] <camelia> rakudo-moar f9f746: OUTPUT«((1 => 2,), (1 => 5,), (1 => 8,), (1 => 11,)).list␤»

[03:32] * Mouq will stop spamming

[03:32] *** rurban1 joined
[03:32] <TimToady> is it distributing :kv etc to the subarrays?

[03:33] <Mouq> Yes

[03:33] <TimToady> I wouldn't want that for shaped arrays, but maybe it makes more sense for ad hoc

[03:34] <TimToady> for shaped arrays, (0,0,0) is the real key, and there's no key to the subarrays that is meaningful

[03:34] <TimToady> however, if you flatten a distributed :kv it's not going to make much sense, since it loses the key context

[03:34] <TimToady> so I'm not sure it makes much sense there either

[03:35] *** dayangkun joined
[03:35] <TimToady> you could still get that behavior wish something like a deepmap

[03:35] <TimToady> if you wanted it

[03:35] <TimToady> but I suspect multidim subscripts should return multidim keys

[03:36] <TimToady> whether shaped or not

[03:36] <TimToady> someting you could bind to -> $x, $y, $z and get back to the original element

[03:37] <TimToady> dunno how hard that is given your current setup

[03:38] <TimToady> @line[*-6] ~~ s/wish/with/

[03:40] <Mouq> I think it'll be easier than getting @a[**] to work right

[03:40] <TimToady> well, arguably the key should be (0;0;0) in case they turn into slices :D

[03:41] <TimToady> 'course, that syntax is taken...

[03:42] <TimToady> Not only are there not enough brackets in ASCII, there are not enough semicolons...

[03:42] <Mouq> It's still written that (@a;@b;@c) is a LoL in spec, I just didn't implement it for fear of breaking code

[03:42] <Mouq> :P

[03:43] <TimToady> yeah, that's fossilic

[03:43] <TimToady> fossilacious?

[03:43] <TimToady> fossilly, even

[03:43] <sjohnson> hey timtoday, how're things?

[03:44] <sjohnson> oops, timtoady*

[03:44] <TimToady> I been worse

[03:44] <TimToady> barely

[03:44] <TimToady> been a while

[03:44] <sjohnson> Timothy Toadstool

[03:45] <TimToady> never met 'im

[03:45] <sjohnson> "could be better, could be worse" is a good way to be.

[03:45] <TimToady> well, bad eye chose to get badder last month, but we're on the mend, for the most part

[03:46] <sjohnson> hmm, i might have to backlog.

[03:46] <sjohnson> wasn't aware of any eye problems.

[03:46] <TimToady> it remains to be seen whether I'll be able to give people the stinkeye better with my good eye or my bad eye :)

[03:47] <TimToady> yeah, search the logs for 'detachment'

[03:47] <TimToady> or 'retina'

[03:47] <TimToady> or 'bubble' :)

[03:48] <TimToady> or heck, just read everything I wrote for the last five years :)

[03:48] <PerlJam> .oO( bubble, bubble, toil and trouble )

[03:50] <Mouq> m: my %h = :a, :b, :c; given %h { when :q { die ":(" }; when :a { say ":)" }}

[03:50] <camelia> rakudo-moar f9f746: OUTPUT«:(␤  in block  at /tmp/eCDU0dY62D:1␤␤»

[03:51] *** chenryn left
[03:55] *** chenryn joined
[03:57] *** chenryn left
[04:00] *** chenryn joined
[04:00] *** davido__ left
[04:02] *** kaare_ joined
[04:02] *** davido__ joined
[04:04] *** nbrown joined
[04:06] *** BenGoldberg left
[04:08] *** nbrown left
[04:16] <TimToady> hmm, unfortunately, :q returns True, which is always True

[04:17] *** thou joined
[04:22] *** [Sno] left
[04:30] *** xinming left
[04:31] *** xinming joined
[04:31] *** thou left
[04:32] *** kaare_ left
[04:32] *** ren1us left
[04:33] *** ventica2 left
[04:40] *** molaf_ left
[04:41] *** rindolf joined
[04:41] * Mouq manages to reduce Stage Parse to Inf

[04:42] <Mouq> m: my %h = :a, :b, :c; given %h { when :q{so $_} { die ":(" }; when :a{so $_} { say ":)" }}

[04:42] <camelia> rakudo-moar f9f746: OUTPUT«:)␤»

[04:42] <Mouq> :P

[04:47] *** ventica2 joined
[04:50] *** chenryn left
[04:58] *** kaare_ joined
[05:04] *** nbrown joined
[05:09] *** nbrown left
[05:13] <moritz> \o

[05:13] *** psch joined
[05:19] *** rurban1 left
[05:27] *** xenoterracide left
[05:40] *** [Sno] joined
[05:49] * Mouq has spent close to 60x more time debugging this than he did writing it :(

[05:50] *** kurahaupo left
[06:03] *** anaeem1 joined
[06:05] *** nbrown joined
[06:06] *** thou joined
[06:10] *** nbrown left
[06:10] *** denis_boyun_ joined
[06:11] *** thou left
[06:32] *** xenoterracide joined
[06:49] *** anaeem1__ joined
[06:51] *** xenoterracide left
[06:52] *** anaeem1 left
[07:00] *** dmol joined
[07:06] *** nbrown joined
[07:09] *** dayangkun left
[07:10] *** nbrown left
[07:11] *** dayangkun joined
[07:14] *** Alula_ left
[07:15] *** Alula_ joined
[07:21] *** brrt joined
[07:30] *** PotatoGim left
[07:32] <dalek> rakudo/nom: 02277af | Mouq++ | src/core/ (3 files):

[07:32] <dalek> rakudo/nom: Have [;] and {;} return LoL-y indices for :{p,k,kv}

[07:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/02277aff1c

[07:33] *** klaas-janstol joined
[07:33] <Mouq> Oh, wtf, that's not the code I wanted to push

[07:38] <Mouq> Now I have to try to remake what I want, debug it, because everything inexplicably buildfails or is extremely touchy, and test that it doesn't regress. Lucky this is not a highly used feature yet

[07:41] *** klaas-janstol left
[07:43] <Mouq> i don't even know what the issue is, moar keeps segfaulting in stage parse if I hand it some valid setting code that it doesn't like :/

[07:46] *** klaas-janstol joined
[07:47] *** Akagi201 joined
[07:49] *** donaldh joined
[07:49] *** donaldh left
[07:55] *** thou joined
[07:56] *** FROGGS[mobile] joined
[07:59] *** thou left
[08:02] <FROGGS[mobile]> rurban: at at the time you said that parrot's threading was better than moar's moar had no threading support

[08:02] <FROGGS[mobile]> rurban: so it was just rediculous to say that

[08:03] *** klaas-janstol left
[08:04] <FROGGS[mobile]> rurban: and parrot's developement took a quite long pause, and until this year's gsoc I thought it was stalled

[08:05] <FROGGS[mobile]> rurban: and non-blocking threading is nice but does not help much when the lexpad slows down everything

[08:07] <dalek> rakudo/nom: 39f7354 | Mouq++ | src/core/ (2 files):

[08:07] <dalek> rakudo/nom: Bugfixes to the last commit

[08:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/39f7354400

[08:07] *** nbrown joined
[08:08] <Mouq> Only took 4 hours /o\

[08:10] <moritz> Mouq: I know that feeling very well

[08:10] <moritz> Mouq++ # for doing it anyway

[08:10] <FROGGS[mobile]> Has this something todo with a build fail I've seen about 10 hours ago?

[08:11] *** dmol left
[08:13] *** nbrown left
[08:13] <Mouq> FROGGS[mobile]: My latest commit was to fix my own commit from 40 minutes ago

[08:13] <FROGGS[mobile]> ahh, okay :o)

[08:15] *** darutoko joined
[08:15] <Mouq> m: 1[3]:kv # this was one thing that caused me a lot of pain; i didn't realize it wasn't (directly) my fault

[08:15] <camelia> rakudo-moar f9f746: OUTPUT«Invocant requires a type object, but an object instance was passed␤  in method exists_pos at src/gen/m-CORE.setting:1491␤  in block  at src/gen/m-CORE.setting:2139␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2493␤  in block  at /tmp/RPmX…»

[08:16] *** dayangkun left
[08:22] *** dayangkun joined
[08:24] <Mouq> m: 1[3]:exists

[08:24] <camelia> rakudo-moar f9f746: OUTPUT«Invocant requires a type object, but an object instance was passed␤  in method exists_pos at src/gen/m-CORE.setting:1491␤  in block  at src/gen/m-CORE.setting:2106␤  in sub postcircumfix:<[ ]> at src/gen/m-CORE.setting:2490␤  in block  at /tmp/N5V6…»

[08:26] <dalek> rakudo/nom: 976f5c4 | Mouq++ | src/core/Any.pm:

[08:26] <dalek> rakudo/nom: Fix 1[1]:exists and 1<foo>:exists

[08:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/976f5c40f7

[08:34] <Mouq> However... This begs the question of why we only return a value for :kv, :k, or :p if the element exists

[08:35] <Mouq> m: my @a = 2,3,4; my ($k, $v) := @a[1]:kv; $v = 5

[08:35] <camelia> rakudo-moar f9f746: OUTPUT«Cannot assign to a readonly variable or a value␤  in block  at /tmp/0EdAUI3bhx:1␤␤»

[08:35] <Mouq> m: my @a = 2,3,4; say @a[3]:kv;

[08:35] <camelia> rakudo-moar f9f746: OUTPUT«␤»

[08:36] <Mouq> I'd expect 3 => Any, but maybe my expectations are wrong here

[08:40] <ChoHag> Why doesn't this work?

[08:40] <ChoHag> grammar Lines { rule TOP { ^ <line>+ $ }; rule line { ^^ <( \N* )> $$ } }

[08:41] *** Ven joined
[08:41] <FROGGS_> m: grammar Lines { rule TOP { ^ <line>+ $ }; rule line { ^^ <( \N* )> $$ } }; say Lines.subparse("a\n\b\n")

[08:41] <camelia> rakudo-moar 39f735: OUTPUT«#<failed match>␤»

[08:41] <FROGGS_> m: grammar Lines { rule TOP { ^ <line>+ % \n $ }; rule line { ^^ <( \N* )> $$ } }; say Lines.subparse("a\n\b\n")

[08:41] <camelia> rakudo-moar 39f735: OUTPUT«#<failed match>␤»

[08:41] <FROGGS_> m: grammar Lines { rule TOP { ^ <line>+ % \n $ }; rule line { \N* } }; say Lines.subparse("a\n\b\n")

[08:41] <camelia> rakudo-moar 39f735: OUTPUT«#<failed match>␤»

[08:42] <Mouq> s/rule/token/?

[08:43] <Mouq> It's eating the \n's before you can match them

[08:43] <FROGGS_> m: grammar Lines { rule TOP { ^ <line>+ % \n $ }; token line { ^^ <( \N* )> $$ } }; say Lines.subparse("a\nb\n")

[08:43] <camelia> rakudo-moar 39f735: OUTPUT«｢a␤b␤｣␤ line => ｢a｣␤ line => ｢b｣␤␤»

[08:43] <Ven> o/

[08:43] <FROGGS_> and I also did \b sadly :o)

[08:44] <Mouq> m: "\b".perl.say

[08:44] <camelia> rakudo-moar 39f735: OUTPUT«"\b"␤»

[08:44] <Mouq> informative

[08:45] <Mouq> Also \o Ven!

[08:45] <Ven> isn't it <|b> in perl6 ?

[08:45] <Ven> the word boundary one, that is.

[08:46] <Mouq> Ven: He wrote "a\n\b\n" :)

[08:46] <Ven> fair enough :o)

[08:46] * Ven has been reading and re-reading s05 

[08:46] <Mouq> Ven: I think so, though

[08:47] * Mouq tends to use « and » more often when a boundary is needed

[08:49] <masak> good antenoon, #perl6

[08:50] <masak> m: my $r = /foo<\w>/; say so "foo" ~~ $r; say so "foobar" ~~ $r

[08:50] <camelia> rakudo-moar 39f735: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter < (must be quoted to match literally)␤at /tmp/X1pxv7FMEx:1␤------> [32mmy $r = /foo<[33m⏏[31m\w>/; say so "foo" ~~ $r; say so "foobar[0m␤Unable to parse regex; couldn't find fina…»

[08:50] <masak> m: my $r = /foo<|w>/; say so "foo" ~~ $r; say so "foobar" ~~ $r

[08:50] <camelia> rakudo-moar 39f735: OUTPUT«True␤False␤»

[08:50] <masak> Ven: <|w>, not <|b> -- to parallel \w

[08:51] <Ven> ah, alrighty.

[08:51] <Ven> guess I still havn't read it enough times :o)

[08:52] <moritz> m: say so m/foo<.wb>/ for <foo foobar>

[08:52] <camelia> rakudo-moar 39f735: OUTPUT«True␤False␤»

[08:57] <Mouq> So **+1 means {@_.map(*+1)}. What does **+** mean?

[09:00] <dalek> rakudo/HyperWat: 412920f | Mouq++ | src/ (5 files):

[09:00] <dalek> rakudo/HyperWat: Add HyperWhatever, move NYIs

[09:00] <dalek> rakudo/HyperWat: review: https://github.com/rakudo/rakudo/commit/412920f998

[09:00] <dalek> rakudo/HyperWat: fbae5fd | Mouq++ | src/core/ (4 files):

[09:00] <dalek> rakudo/HyperWat: Merge branch 'nom' into HyperWat

[09:00] <dalek> rakudo/HyperWat: review: https://github.com/rakudo/rakudo/commit/fbae5fd274

[09:00] <Mouq> (so others can stare at the code and wonder what it's supposed to do, too ;)

[09:05] *** donaldh joined
[09:09] *** nbrown joined
[09:11] <Mouq> hoelzro++ for continuing to work on #| and #=

[09:12] *** spider-mario joined
[09:12] *** pmurias joined
[09:13] *** nbrown left
[09:14] *** PotatoGim joined
[09:15] <PotatoGim> Hi

[09:15] <Mouq> Hiya

[09:15] <Mouq> :)

[09:17] <Mouq> http://perlcabal.org/syn/S13.html#Type_Casting needs to be fixed to represet the method -> sub change

[09:18] <Mouq> And mention at_pos, exists_pos, and delete_pos

[09:19] <Mouq> m: say Any.^methods.grep(*.name ~~ /pos/) # that's all of them, right?

[09:19] <camelia> rakudo-moar 39f735: OUTPUT«␤»

[09:19] <Mouq> m: say Any.^methods.grep({.name ~~ /pos/}) # that's all of them, right?

[09:19] <camelia> rakudo-moar 39f735: OUTPUT«exists_pos delete_pos at_pos assign_pos␤»

[09:20] <moritz> bind_pos maybe?

[09:21] <moritz> m: say Array.^methods(:all).grep({.name ~~ /pos/})

[09:21] <camelia> rakudo-moar 39f735: OUTPUT«bind_pos delete_pos at_pos assign_pos exists_pos at_pos exists_pos delete_pos at_pos assign_pos␤»

[09:21] <moritz> m: say Array.^methods(:all).map(*.name).grep(/pos/).uniq

[09:21] <camelia> rakudo-moar 39f735: OUTPUT«bind_pos delete_pos at_pos assign_pos exists_pos␤»

[09:25] <Ven> m: <foo bar baroo>.grep(/oo/)

[09:25] <camelia> rakudo-moar 39f735: ( no output )

[09:25] <Ven> m: <foo bar baroo>.grep(/oo/).say # ENOSAY.

[09:25] <camelia> rakudo-moar 39f735: OUTPUT«foo baroo␤»

[09:26] <Ven> oh, moritz++ was faster, eh.

[09:34] <spider-mario> m: macro hello($name) {quasi { say "Hello { {{{$name}}} } !"; };}

[09:34] <camelia> rakudo-moar 39f735: OUTPUT«===SORRY!===␤Unknown QAST node type QAST::Unquote␤»

[09:34] <spider-mario> I think it used to work, a while back

[09:34] *** cognome left
[09:36] <Mouq> star: macro hello($name) {quasi { say "Hello { {{{$name}}} } !"; };}

[09:36] <camelia> star-{m,p} 2014.04: OUTPUT«===SORRY!===␤Error while compiling op call: Unknown QAST node type QAST::Unquote␤»

[09:37] <Mouq> spider-mario: I've come across it a bunch with macros, I'm not sure what the issue is :(

[09:38] <spider-mario> :/

[09:38] *** dmol joined
[09:43] *** thou joined
[09:47] <Ven> maybe masak knows

[09:47] *** thou left
[09:48] <Mouq> I poked him and he made a bug report about it

[09:48] <Mouq> So he may or may not :)

[09:49] *** dmol left
[09:49] <Ven> .o( masak only knows if masak knows )

[09:50] <Mouq> method postcircumfix:<( )> -> method invoke was really easy, just a few spectest fails that still use method postcircumfix:<( )>

[09:51] *** dmol joined
[09:51] <Mouq> We should probably emit a warning upon parsing a method postcircumfix:<*>

[09:52] *** brrt left
[09:52] *** dmol left
[09:53] *** Ven left
[09:53] *** dmol joined
[09:57] <dalek> rakudo/nom: d7808f5 | Mouq++ | src/ (5 files):

[09:57] <dalek> rakudo/nom: method postcircumfix:<( )> becomes method invoke

[09:57] <dalek> rakudo/nom: 

[09:57] <dalek> rakudo/nom: per http://irclog.perlgeek.de/perl6/2014-07-08#i_8992020

[09:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d7808f5f99

[10:02] <jnthn> Mouq: We probably coulda done with a deprecation cycle there. That patch will almost certainly have to be backed out, because it's being landed less than a week to a release and will totally bust multiple modules in the ecosystem.

[10:02] <Mouq> O_O oh

[10:02] <Mouq> kay

[10:02] <jnthn> NativeCall being one of them

[10:02] <jnthn> That one I can update in time

[10:02] <jnthn> But I suspect there will be wider fallout.

[10:02] *** klaas-janstol joined
[10:03] <jnthn> I think still supporting postcircumfix:<( )> if there's no invoke should be possible.

[10:03] <jnthn> And then we can put in some kind of deprecation notice if you do use one.

[10:04] <jnthn> (There's already a system for doing that).

[10:05] <Mouq> jnthn: I'll try to make it fall back to postcircumfix:<( )>, there's only 2 or 3 places that call it

[10:05] <jnthn> The other thing is that I think the spec doesn't want us to pass a Capture, but rather just the args directly.

[10:05] <jnthn> So we might want to break that while we're also breaking this :)

[10:06] *** dmol left
[10:07] *** dmol joined
[10:07] <jnthn> Anyway, yeah, looking at the patch, there's just 2 places that'll need the fallback thing.

[10:08] *** dmol left
[10:09] <jnthn> (And updating the spectests to the new thing is sensible too, of course.)

[10:09] *** dmol joined
[10:10] <timotimo> i'm looking forward to actually understanding what hyperwhatever actually does when it's implemented %)

[10:10] <jnthn> Same :D

[10:10] <jnthn> Happy to see Mouq++ taking on the multi-dim stuff :)

[10:10] *** nbrown joined
[10:10] <timotimo> me, too

[10:11] <timotimo> and when we have native/packed multi-dim arrays that have access to them speshed (and jitted!), we'll be unstoppable!

[10:11] <jnthn> Yeah, much better native stuff is on my roadmap for autumn :)

[10:12] <dalek> rakudo/nom: 08fec13 | Mouq++ | src/Perl6/Metamodel/ (2 files):

[10:12] <dalek> rakudo/nom: Allow old postcircumfix:<( )> to work too, for now

[10:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/08fec1349e

[10:15] *** nbrown left
[10:15] *** dmol left
[10:16] *** dmol joined
[10:17] *** cognome joined
[10:17] *** dmol left
[10:20] *** dmol joined
[10:20] <dalek> rakudo/nom: 9062e4c | Mouq++ | src/Perl6/Metamodel/InvocationProtocol.nqp:

[10:20] <dalek> rakudo/nom: Uh, don't look in other classes if postcircumfix:<( )> is defined

[10:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9062e4c01a

[10:25] <Mouq> m: my @a = [ [1,2,3], [4,5,6] ], [ [7,8,9], [10,11,12] ]; say @a[*;*;1]:p; # btw :)

[10:25] <camelia> rakudo-moar 976f5c: OUTPUT«LoL.new(0, 0, 1).item => 2 LoL.new(0, 1, 1).item => 5 LoL.new(1, 0, 1).item => 8 LoL.new(1, 1, 1).item => 11␤»

[10:39] <jnthn> Mouq: Looks good; thanks! :)

[10:40] <lizmat> is the .item there really necessary ?

[10:42] <Mouq> m: say (LoL.new(0,0,1) => 2).perl

[10:42] <camelia> rakudo-moar d7808f: OUTPUT«LoL.new(0, 0, 1).item => 2␤»

[10:43] <lizmat> so an artefact somehow

[10:43] *** grondilu joined
[10:43] <jnthn> Without it, a LoL would flatten, I guess?

[10:44] *** AforAcronym left
[10:44] <lizmat> I thought it shouldn't?

[10:45] *** AforAcronym joined
[10:45] *** dmol1 joined
[10:45] <lizmat> r: say EVAL'(LoL.new(0,0,1) => 2').perl

[10:45] <camelia> rakudo-jvm d7808f: OUTPUT«(timeout)»

[10:45] <camelia> ..rakudo-{parrot,moar} d7808f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32msay EVAL[33m⏏[31m'(LoL.new(0,0,1) => 2').perl[0m␤    expecting any of:␤        argument list␤        postfix␤   …»

[10:46] <lizmat> r: say EVAL'((LoL.new(0,0,1) => 2)').perl

[10:46] <camelia> rakudo-{parrot,jvm,moar} d7808f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32msay EVAL[33m⏏[31m'((LoL.new(0,0,1) => 2)').perl[0m␤    expecting any of:␤        argument list␤        postfix…»

[10:46] <lizmat> r: say EVAL('LoL.new(0,0,1) => 2').perl

[10:46] *** dmol left
[10:46] <camelia> rakudo-{parrot,jvm,moar} d7808f: OUTPUT«LoL.new(0, 0, 1).item => 2␤»

[10:46] <lizmat> doesn't seem to be necessary for rountripping ?

[10:47] <jnthn> In that particular context, no.

[10:47] <jnthn> Not sure that always applies..

[10:47] <lizmat> ah, ok, in that way

[10:47] <lizmat> r: say EVAL('(LoL.new(0,0,1),3,4).list').perl

[10:47] <camelia> rakudo-{parrot,jvm,moar} d7808f: OUTPUT«(0, 0, 1, 3, 4).list␤»

[10:48] <lizmat> r: say EVAL('(LoL.new(0,0,1).item,3,4).list').perl

[10:48] <camelia> rakudo-{parrot,jvm,moar} d7808f: OUTPUT«(LoL.new(0, 0, 1).item, 3, 4).list␤»

[10:48] <lizmat> I see what you mean  :-)

[10:51] * Mouq . o O ( [0, 0, 1]:lol )

[10:53] * Mouq wonders, actually how many WATs [0; 0; 1] -> LoL.new(0, 0, 1).item would be

[10:54] <Mouq> s/actually)>/,/

[10:54] <Mouq> s/')>'/<( :P

[10:59] *** donaldh left
[11:01] <masak> Mouq: the issue with the macros is that it gets confused as soon as you have a block or a sub in there.

[11:02] <masak> Mouq: I'm pretty sure I know where to start looking for a solution to that.

[11:02] <Mouq> Ok :) ++masak ;)

[11:08] <grondilu> m: say { $^X }("hi")

[11:08] <camelia> rakudo-moar d7808f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ibDEw7b6Ax␤Unsupported use of $^X variable; in Perl 6 please use $*EXECUTABLE_NAME␤at /tmp/ibDEw7b6Ax:1␤------> [32msay { $^X[33m⏏[31m }("hi")[0m␤»

[11:09] <grondilu> ^that's a bit inconvenient

[11:11] *** nbrown joined
[11:12] <psch> grondilu: S06:1953 "Positional placeholder names consisting of a single uppercase letter are disallowed, [...]"

[11:12] <synopsebot> Link: http://perlcabal.org/syn/S06.html#line_1953

[11:12] *** PacoLinux joined
[11:12] <psch> i think $^X only has the problem of a wrong error there?

[11:13] <psch> m: { say $^Q }("hi")

[11:13] <camelia> rakudo-moar d7808f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/i7dG3FyW_q␤Unsupported use of $^Q variable␤at /tmp/i7dG3FyW_q:1␤------> [32m{ say $^Q[33m⏏[31m }("hi")[0m␤»

[11:13] <psch> hm, no.  should probably still be more precise

[11:13] <grondilu> psch: OK, noted.

[11:14] <psch> well, the $^X error is definitely wrong; it should probably be something like "if you mean a placeholder use lowercase, if you mean Perl 5's $^X use $*EXECUTEABLE_NAME" or somesuch

[11:15] <grondilu> I've just realised I don't have to use uppercase anyway

[11:15] *** nbrown left
[11:16] <psch> Mouq++ # HyperWat

[11:17] <lizmat> psch: that text is more geared towards people coming from Perl 5

[11:17] <lizmat> $^X is quite common for some uses in Perl 5

[11:17] <lizmat> specifically testing related

[11:18] <psch> lizmat: i understand that.  i just think that the placeholder intent should be mentioned in the error message for both cases as well

[11:19] <lizmat> working on that

[11:19] <psch> ah, ok, i was just about to look into it :)

[11:19] <lizmat> src/core/Exception.pm, line 711

[11:19] <ChoHag> FROGGS_: Thanks. Didn't mean to ignore you - got kicked off the net.

[11:19] <lizmat> be my guest  :-)

[11:31] *** thou joined
[11:33] *** klaas-janstol left
[11:35] <hoelzro> morning #perl6

[11:36] <timotimo> hey hoe :P

[11:36] *** thou left
[11:36] <hoelzro> ahoy timotimo!

[11:37] <timotimo> i think at this point i'll just do a 2-week weekly again ...

[11:37] <lizmat> timotimo: that seems wise

[11:38] <hoelzro> agreed - unless the activity level merits it

[11:39] *** donaldh joined
[11:39] <timotimo> there was lots of activity, but later in the week it feels hard to keep the changes since monday to yourself and it seems silly to do a weekly on friday and then another on monday

[11:39] <timotimo> even though it feels like jnthn does a lot of his amazing work on weekends and mondays %)

[11:40] <hoelzro> heh

[11:40] <hoelzro> timotimo: is there anything people can do to help? I mean, we can all PM you and brag about ourselves =)

[11:40] <timotimo> i'd actually appreciate that :P

[11:46] <lizmat> r: my $a = 42; { my $a = 16; EVAL "say $a", :context(OUTER::); }  # shouldn't this say "42" ?

[11:47] <camelia> rakudo-jvm 9062e4: OUTPUT«(timeout)»

[11:47] <camelia> ..rakudo-{parrot,moar} 9062e4: OUTPUT«16␤»

[11:48] <Mouq> jnthn, timotimo: If either of you have a sec, could you check the logic of src/Perl6/Metamodel/BOOTSTRAP.nqp L 1820 to the end of that loop? I don't really understand what it's doing that well

[11:48] <timotimo> r: my $a = 42; { my $a = 16; EVAL "say $a", :context(OUTER::OUTER::); }

[11:48] <camelia> rakudo-{parrot,jvm,moar} 9062e4: OUTPUT«16␤»

[11:48] <timotimo> hm.

[11:49] <lizmat> hmmm indeed, no?

[11:50] <timotimo> hmm indeed, yes.

[11:52] <moritz> the $a interpolates into the string you pass to EVAL

[11:52] <lizmat> grrr

[11:52] <lizmat> of course

[11:52] <lizmat> m: my $a = 42; { my $a = 16; EVAL q[say $a], :context(CALLER::); }

[11:52] <camelia> rakudo-moar 9062e4: OUTPUT«42␤»

[11:52] <lizmat> moritz++

[11:53] <lizmat> m: my $a = 42; { my $a = 16; EVAL q[say $a], :context(OUTER:); }

[11:53] <camelia> rakudo-moar 9062e4: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/gx5BBgEAkk␤Two terms in a row␤at /tmp/gx5BBgEAkk:1␤------> [32m $a = 16; EVAL q[say $a], :context(OUTER[33m⏏[31m:); }[0m␤    expecting any of:␤        postfix␤        infix stopper…»

[11:53] <lizmat> m: my $a = 42; { my $a = 16; EVAL q[say $a], :context(OUTER::); }

[11:53] <camelia> rakudo-moar 9062e4: OUTPUT«42␤»

[11:53] <timotimo> moritz: aaaaah m)

[11:55] <Mouq> (nvm, it seems to be an otherwise ungolfable setting bug -_-)

[11:55] *** iarna left
[11:55] *** iarna joined
[11:56] <timotimo> d'oh

[12:00] <lizmat> m: sub a { say $^a }; { say OUTER::.keys } # shouldn't this also list &a ?

[12:00] <camelia> rakudo-moar 9062e4: OUTPUT«$! $/ $_ GLOBALish EXPORT $?PACKAGE ::?PACKAGE &a $=pod !UNIT_MARKER␤»

[12:00] <lizmat> ah, but it does ?

[12:05] <timotimo> m: sub a { say $^a }; say ::.keys

[12:05] <camelia> rakudo-moar 9062e4: OUTPUT«$! $/ $_ GLOBALish EXPORT $?PACKAGE ::?PACKAGE &a $=pod !UNIT_MARKER␤»

[12:05] <timotimo> yeah, both do

[12:06] <timotimo> m: sub HERE_I_AM_LOOK_AT_ME { say $^a }; say ::.keys # much easier to spot

[12:06] <camelia> rakudo-moar 9062e4: OUTPUT«$! $/ $_ GLOBALish EXPORT $?PACKAGE ::?PACKAGE &HERE_I_AM_LOOK_AT_ME $=pod !UNIT_MARKER␤»

[12:08] <dalek> rakudo/nom: 13df800 | (Elizabeth Mattijsen)++ | lib/Test.pm:

[12:08] <dalek> rakudo/nom: Make sure EVAL is done in right context

[12:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/13df80079f

[12:09] <jnthn> lizmat: Wait wait wait...

[12:09] *** klaas-janstol joined
[12:09] <jnthn> lizmat: We have eval_lives_ok and eval_dies_ok taking blocks for things like this, I thought?

[12:09] <jnthn> lizmat: But moreover: the optimizer looks for EVAL to appear

[12:10] <jnthn> And since the test doesn't contain a call to EVAL, it's free to optimize lexicals out.

[12:10] <jnthn> So this will be highly unreliable.

[12:12] *** nbrown joined
[12:12] *** AforAcronym left
[12:13] <lizmat> hmmm....

[12:13] <lizmat> so maybe then the "context" option should be taken from EVAL ?

[12:14] <lizmat> FWIW, I unspecced "eval_dies/lives_ok" in favour of handling this with dies_ok/lives_ok (taking a string to EVAL)

[12:15] <jnthn> context is not spec'd at all

[12:15] <lizmat> but if what you say is true, then *any* sub doing an EVAL and referencing things in an OUTER:: scope is fragile

[12:15] <jnthn> It exists purely to make .EVAL work

[12:16] *** nbrown left
[12:16] <jnthn> my $a; ... if x { while y {  EVAL 'blah $a' } } # fine because the EVAL poisons optimizations for everything in the surrounding scopes

[12:17] <lizmat> and the same goes for .EVAL ?

[12:17] <jnthn> Right

[12:17] <jnthn> The optimizer specifically looks for them

[12:17] <jnthn> This is why the change to uppercase

[12:18] <lizmat> and eval_dies/lives_ok then?

[12:18] <lizmat> is that checked for as well, by name ?

[12:19] <jnthn> No

[12:19] <lizmat> but that would have the same problem, no ?

[12:19] <jnthn> Hm...we don't actually have thsoe, do we?

[12:19] <moritz> those currently eval in their own scope

[12:20] <moritz> (and I had to fix many tests that implicitly assumed otherwise)

[12:20] <jnthn> oh, we do

[12:20] <jnthn> Right

[12:20] <moritz> ("it fails at compile time? let's just put an eval around it")

[12:20] <lizmat> eval_dies_ok uses a sub: eval_exception($code);

[12:20] <jnthn> I do wonder if we should just encourage lives_ok { EVAL '...' }

[12:20] <lizmat> well, that's fine by me

[12:20] <jnthn> Which is reliable and not a lot longer

[12:21] <lizmat> and I'll deprecate eval_lives/dies_ok

[12:21] <moritz> and viable since EVAL doesn't catch exceptions any longer

[12:21] <jnthn> moritz: aye, good point

[12:21] <lizmat> and handle the test-suite, because I want to basically use throws_like wherever possible

[12:22] <lizmat> to make sure things die for the right reason

[12:22] *** jnap joined
[12:22] <jnthn> Well, yes, that's preferable anyway

[12:22] <FROGGS_> ChoHag: np, I don't expect that the ppl I am talking are at the keyboard all the time :o)

[12:22] <lizmat> shall I rewrite .EVAL so that it won't need the :context parameter anymore, and remove it from sub EVAL ?

[12:24] *** PacoLinux left
[12:24] <moritz> that sounds somewhat wrong

[12:25] *** brrt joined
[12:25] <lizmat> otoh, if there would be an easy way to "poison" a scope

[12:26] <timotimo> EVAL ""

[12:26] <timotimo> or CALLER::

[12:26] <lizmat> then we could e.g. have "use Test" poison the scope in which it is loaded automaticaly

[12:26] <timotimo> i don't like the sound of that

[12:26] <jnthn> Me either...

[12:27] <jnthn> lizmat: Well, the point of :context(...) is that .EVAL can be implemented in terms of EVAL

[12:27] <lizmat> perhaps we should have a EVAL() candidate that does nothing

[12:27] <lizmat> can be removed itself, but poisons the scope ?

[12:27] <lizmat> and spec it as such ?

[12:29] <jnthn> No, I don't see how that helps much

[12:29] *** Mouq left
[12:30] <jnthn> I mean, why would you want to prevent optimizations if you aren't going to do something that they would make a problem for?

[12:31] <lizmat> the reason for all of this was this code:

[12:31] <lizmat> throws_like q[fac('oh noes i am a string')], X::TypeCheck::Argument;

[12:31] <lizmat> the eval was done in the wrong scope, and therefore it didn't see the fac() definition

[12:32] <lizmat> so it was failing because of Undeclared Symboils, rather than because of the type check

[12:33] <lizmat> in this particular case, I could only see a problem if the enitre sub fac() was optimized away

[12:33] <lizmat> (file in question: t/spec/integration/advent2009-day04.t )

[12:34] *** kurahaupo joined
[12:34] <lizmat> if you're saying we should always do:

[12:34] <lizmat> throws_like { EVAL q[fac('oh noes i am a string')] }, X::TypeCheck::Argument;

[12:34] <lizmat> that's fine by me...  but then we will need to get rid of eval_lives/dies_ok

[12:34] <lizmat> and replace that with lives/dies_ok and the necessary { EVAL ... }

[12:35] <jnthn> It's only an issue for things that want symbols in the outer scope

[12:35] <jnthn> So for testing parse errors the string form of throws_like isn't so bad

[12:36] <jnthn> I think eval_lives_ok and eval_dies_ok could happily go, though.

[12:36] <lizmat> but from a naive user point of view, why need { EVAL ... } in this case, and not in others ?

[12:37] <lizmat> I'd rather then remove the string eval option from throws_like

[12:37] <lizmat> and be clear about it

[12:37] <lizmat> "yeah, you can specify a string, and it may work now, but not in the future when we optimize differently"

[12:38] <jnthn> Um, it reliably fails to work today, no?

[12:38] <cognome> https://github.com/rakudo/rakudo/blob/nom/src/core/Attribute.pm#L33                       nqp::die("Cannot create rw-accessors for natively typed attribute '$name'");

[12:38] <cognome> Is this a limitation of the rakudo implementation or is it specified?

[12:38] <jnthn> The optimization fragility was to do with passing context => CALLER::CALLER::

[12:38] <moritz> cognome: implementation limit

[12:38] <timotimo> cognome: implementation limit

[12:39] <lizmat> well, if "dies_ok" dies for the wrong reason, you're not testing right

[12:39] <timotimo> yeah

[12:39] <timotimo> cognome: jnthn has that on his "to do" list for autumn

[12:39] <jnthn> lizmat: Yes, that's why I don't worry much about throws_like and the string case.

[12:39] <jnthn> lizmat: Because you specify the mode of failure

[12:39] <jnthn> lizmat: So false positives are much less likely

[12:39] <lizmat> true

[12:40] <jnthn> Agree eval_[dies|lives]_ok are fragile 

[12:40] * moritz d'accord

[12:40] <cognome> thx, moritz++, timotimo++     Where is that TODO list, jnhtn specific, or not?

[12:40] <lizmat> still, hard to explain why sometimes you would need to use { EVAL ... } for throws_like, and when not

[12:40] <moritz> cognome: there's a docs/ROADMAP in the rakudo repository

[12:41] <lizmat> so I'd rather remove the string option for clarity

[12:41] <moritz> lizmat: don't remove it; just explain it in the docs

[12:41] <moritz> lizmat: it's very convenient to have

[12:42] <jnthn> lizmat: "If you will use any symbols in the surrouding scope, use the block and EVAL form. If you are purely testing ability to parse, the string form is fine."

[12:42] <moritz> cognome: it says "missing native operators, including ++/--", which requires rw-access to natives

[12:42] <moritz> cognome: so it's a bit hidden in the ROADMAP

[12:42] <jnthn> Well, unless the parse depends on things in the outer scope :P

[12:42] <lizmat> moritz, jnthn: in the S24 spec?  as there is hardly any docs inside lib/Test.pm

[12:42] <jnthn> So probably drop the second aprt of what I said :)

[12:42] <lizmat> nor do I know a way to easily look up the pod

[12:42] <moritz> lizmat: in S24, yes

[12:43] <moritz> lizmat: we might want to import S24 (or parts thereof) into Test.pm eventually

[12:44] <lizmat> it feels wrong to me, but will do so

[12:44] *** brrt left
[12:45] *** brrt joined
[12:46] *** guru joined
[12:46] *** guru is now known as ajr_

[12:50] <masak> recursively removing a directory in a platform-independent way?

[12:50] <dalek> specs: 2128e89 | (Elizabeth Mattijsen)++ | S24-testing.pod:

[12:50] <dalek> specs: Only throws_like accepts a string as well

[12:50] <dalek> specs: review: https://github.com/perl6/specs/commit/2128e898fd

[12:50] <dalek> specs: c80388e | (Elizabeth Mattijsen)++ | S24-testing.pod:

[12:50] <dalek> specs: Mention caveat with symbols when using string

[12:50] <dalek> specs: review: https://github.com/perl6/specs/commit/c80388e3ed

[12:50] <masak> guess there is a File::Utils somewhere that does that, right?

[12:51] * masak goes with `shell("rm -r dir")` for now

[12:53] <dalek> rakudo/nom: 1378792 | (Elizabeth Mattijsen)++ | lib/Test.pm:

[12:53] <dalek> rakudo/nom: Using an internal EVAL feature considerd BAD(TM)

[12:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1378792501

[13:06] *** kaare_ left
[13:09] *** _sri left
[13:12] *** nbrown joined
[13:16] *** nbrown left
[13:18] <psch> hm, the $^X thing is a tad more complicated than it appears on the surface i fear

[13:18] <psch> m: EVAL "{ $^X }"; CATCH { default { .^name.say } }

[13:18] <camelia> rakudo-moar 9062e4: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/bqGQ1jdkKy␤Unsupported use of $^X variable; in Perl 6 please use $*EXECUTABLE_NAME␤at /tmp/bqGQ1jdkKy:1␤------> [32mEVAL "{ $^X[33m⏏[31m }"; CATCH { default { .^name.say } }[0m␤»

[13:18] <psch> m: { EVAL "{ $^X }"; CATCH { default { .^name.say } } }

[13:18] <camelia> rakudo-moar 9062e4: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ZY6QToC9Hh␤Unsupported use of $^X variable; in Perl 6 please use $*EXECUTABLE_NAME␤at /tmp/ZY6QToC9Hh:1␤------> [32m{ EVAL "{ $^X[33m⏏[31m }"; CATCH { default { .^name.say } } }[0m␤»

[13:18] <psch> ehh, double quotes :)

[13:18] <psch> m: { EVAL '{ $^X }'; CATCH { default { .^name.say } } }

[13:18] <camelia> rakudo-moar 9062e4: OUTPUT«X::Syntax::Perl5Var␤»

[13:19] <psch> m: { EVAL '$^X'; CATCH { default { .^name.say } } }

[13:19] <camelia> rakudo-moar 9062e4: OUTPUT«X::Syntax::Perl5Var␤»

[13:19] <psch> what i have now groups X::Placeholder::Mainline and X::Syntax::Perl5Var instead of always throwing Perl5Var for any possible Perl5Var

[13:19] *** thou joined
[13:20] <psch> but that breaks about 29 spectest tests, because those don't expect a Comp::Group

[13:20] *** FROGGS_ left
[13:20] *** itz left
[13:20] *** BooK_ left
[13:20] <lizmat> isn't it just a matter of changing the messages in those two classes if it matches $^[A-Z] ?

[13:21] <lizmat> $^<[A..Z]>  (excuse my p5)

[13:21] <psch> right, i added the message for Perl5Var

[13:21] <moritz> maybe throws_like should special-case Comp::Group, and go into the list of exceptions in that case

[13:21] <moritz> it's a recurring theme

[13:21] <lizmat> is this a throws_like problem ?

[13:22] <moritz> well

[13:22] <psch> kindasorta, i think

[13:22] <moritz> maybe it's a more general exception classification problem

[13:22] <moritz> usually we ask "is this exception a X::Foo?"

[13:22] <dalek> rakudo/nom: dd8679e | (Elizabeth Mattijsen)++ | lib/Test.pm:

[13:22] <dalek> rakudo/nom: No longer allow strings with dies_ok/lives_ok

[13:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dd8679e1ea

[13:22] <moritz> but in the case of group exception, we ought to ask "is there an exception of type X::Foo in there?"

[13:22] <lizmat> we do $_ ~~ ex_type

[13:23] <lizmat> so it is not an isa relationship

[13:23] <moritz> not always

[13:23] <lizmat> are you saying the test should also .isa($ex_type) ?

[13:24] *** BooK joined
[13:24] *** thou left
[13:24] <pmichaud> good morning, #perl6

[13:25] <lizmat> morning pmichaud 

[13:25] *** itz joined
[13:25] <pmichaud> lizmat   o/

[13:25] <psch> hi pmichaud \o

[13:26] <psch> moritz: just having throws_like go into the group seems a bit magicy to me

[13:26] <pmichaud> note to yapceu folks:   I've decided not to make it to sofia... I have a few other things going on here and I can't quite justify the 30 hours of air travel

[13:26] <pmichaud> but salzburg is definitely on my calendar

[13:26] <psch> and smartmatch in general against a Comp::Group on the lhs probably shouldn't do that, even though i kind of would like it to

[13:26] <jnthn> pmichaud: Aww, ok.

[13:27] *** dmol1 left
[13:27] <jnthn> 30 hours *is* quite a bit.

[13:27] <dalek> Heuristic branch merge: pushed 86 commits to rakudo/S26-WHY by hoelzro

[13:28] *** _sri joined
[13:29] <psch> m: { EVAL "infix:<>() {}"; CATCH { when X::Comp::Group { .^name.say for .worries, .panic } } }

[13:29] <camelia> rakudo-moar 9062e4: OUTPUT«X::Comp::AdHoc␤X::Undeclared::Symbols␤»

[13:29] <psch> m: { EVAL "/m ** 1..-1/"; CATCH { when X::Comp::Group { .^name.say for .worries, .sorrows, .panic } } } 

[13:29] <camelia> rakudo-moar 9062e4: OUTPUT«X::Syntax::Regex::MalformedRange␤X::Syntax::Regex::UnrecognizedMetachar␤X::Comp::AdHoc␤»

[13:31] <psch> anyway, the core issue i had with adding the hint about the placeholder was, that placeholders that produce a Perl5Var swallow other issues with the placeholder at the moment, e.g. X::Placeholder::Mainline

[13:31] *** dmol joined
[13:32] <psch> that's not really an issue with the hint, but more about Comp::Group and how we process them

[13:33] <psch> how does grouping interact with NYI .pending, anyway? Comp::Group doesn't seem specced

[13:33] *** anaeem1__ left
[13:34] <dalek> specs: 455c422 | (Elizabeth Mattijsen)++ | S24-testing.pod:

[13:34] <dalek> specs: throws_like also can have a description

[13:34] <dalek> specs: review: https://github.com/perl6/specs/commit/455c4221e2

[13:35] *** ivanshmakov| left
[13:36] <dalek> rakudo/nom: eb1df63 | (Elizabeth Mattijsen)++ | lib/Test.pm:

[13:36] <dalek> rakudo/nom: throws_like can also have a description

[13:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eb1df63e66

[13:37] <masak> some newlines missing in this error message? https://gist.github.com/masak/f4a2feb098e28197c1fa

[13:37] *** iarna left
[13:38] *** FROGGS_ joined
[13:38] <masak> the extra space before each signature indicates to me the newlines were intended?

[13:38] <masak> shall I open a ticket for this?

[13:38] *** xusia left
[13:38] *** iarna joined
[13:38] <masak> also, ++ to everyone who was involved in the Levenshtein distance thing. it's a thing of beauty.

[13:39] <masak> it's so obviously what an error message should have.

[13:39] <lizmat> do we have that for methods now?

[13:40] *** brrt left
[13:40] * lizmat remembers putting that on her list once, a while ago, but got blocked

[13:41] *** AforAcronym joined
[13:43] <pmurias> jnthn: is :$want supposed to influence semantics or is it just an optimalization hint?

[13:43] *** ivanshmakov| joined
[13:44] <jnthn> pmurias: It can influence semantics. Of note, it can control the choice of a QAST::Want node branch, and Rakudo (maybe NQP too) uses it to do different things in/out of sink context.

[13:44] <psch> masak: the newline is missing in Optimizer.nqp:1534 in the for

[13:45] * psch .oO( i don't want to open a PR for 4 characters... )

[13:45] <pmurias> jnthn: what I care about is when compiling ifs do I have to pass the want (context?) to both branches in exactly the same way

[13:46] <masak> psch: thanks. fixing.

[13:46] <jnthn> pmurias: Well, they're both in the same context, so I'd say so

[13:47] <jnthn> pmurias: Though given you're asking I think I'm missing some subtlety in your question :)

[13:47] *** anaeem1_ joined
[13:48] *** anaeem1_ left
[13:48] <pmurias> I seem to have got confused about something, too much looking at all the $il.append(...) ;)

[13:49] <timotimo> tadzik: btw, you should totally run your steroids game on moar-jit and tell us what the bail log looks like, as well as the performance :)

[13:49] <jnthn> Hm, some day we really should JIT native calls...

[13:50] <timotimo> yeah, that'd be neat

[13:50] *** rurban1 joined
[13:51] <timotimo> masak: i'm glad you're enjoying the hell out of the levenshtein error message thing i kicked off :D

[13:51] <timotimo> .o( yeah! i'm taking all the praise! )

[13:51] <masak> timotimo++ # Levenshtein

[13:52] <masak> psch++ # finsing that place in Optimizer.nqp -- building a fix now

[13:52] <pmurias> I'm jealous of the nice rakudo error messages, as I'm mostly using nqp :(

[13:53] <timotimo> masak: https://twitter.com/loltimo/status/417302567236816897 ← :D

[13:53] *** kurahaupo left
[13:53] <masak> timotimo: :)

[13:56] <dalek> rakudo/nom: 287e49e | masak++ | src/Perl6/Optimizer.nqp:

[13:56] <dalek> rakudo/nom: spread some newline love in between signatures

[13:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/287e49e610

[13:56] <jnthn> timotimo: *lol*

[13:58] *** thou joined
[14:01] <lizmat> :-)

[14:01] <lizmat> too bad the Levenshtein distance is not 666  :-)

[14:02] * lizmat just found another case of 'dies_ok' that was dying for the wrong reason

[14:03] <lizmat> jnthn: related, do we want to check for X::AdHoc exceptions?  

[14:03] <lizmat> as generated by nqp::die()

[14:03] <lizmat> e.g. in src/Perl6/Metamodel/RoleToClassApplier.nqp

[14:04] <lizmat> or do you think it makes sense to turn these into proper Exceptions ?

[14:04] *** treehug88 joined
[14:05] <jnthn> lizmat: I think we'd like to converge towards everything the langauge/compiler produces being typed

[14:05] <masak> heh -- under what conditions does one get "Premature heredoc consumption"?

[14:05] <timotimo> the langauge is up to 11

[14:05] <masak> (also, why no file and line number? grmbl.)

[14:05] * masak injects `BEGIN say` into his code

[14:06] <timotimo> masak: it occurs to me that it's pretty cool we can even do that

[14:06] <jnthn> masak: Anything that tries to run an expression at BEGIN time I guess

[14:06] <jnthn> masak: And the heredoc text is after the expr or blorst in question

[14:06] <jnthn> So we didn't parse it befoer trying to use it

[14:06] <masak> ah, found it.

[14:07] <masak> golfing.

[14:07] <timotimo> that error message could get the LTA treatment

[14:07] <jnthn> Weird it misses a file/line

[14:07] <jnthn> Well, the error tells you what's wrong.

[14:07] <jnthn> I mean, you know it's about a heredoc at least :)

[14:07] <timotimo> yeah, but "premature" could mean anything

[14:08] <jnthn> Mebbe the word doesn't conjure the right idea, yeah... Hmm. 

[14:08] <timotimo> "tried to use a heredoc's content before it was parsed fully"

[14:08] <jnthn> Yeah

[14:10] <masak> golfed: https://gist.github.com/masak/83df9c4ad3a859730109

[14:10] <masak> if I can get a ruling on whether that is OK, I can submit a rakudobug.

[14:12] <jnthn> Oh, I wondered if it's constant

[14:12] <jnthn> No, I can't see that being OK.

[14:12] <masak> you can't?

[14:12] <jnthn> No; we evaluate constants at BEGIN time

[14:13] *** nbrown joined
[14:13] <jnthn> It's one of those "would be nice if it could work but I can't see how to pull it off" things

[14:14] <masak> oh, so if I do `constant B = qq:to/END/ ~ <newline> <heredoc> END <newline> "";`, then we're all fine?

[14:14] <masak> yeah, that works here.

[14:14] <jnthn> If it's finished parsing the heredoc by the time it compiles the expression, you're good.

[14:14] <masak> something here is exceedingly silly.

[14:14] <masak> I mean, I hear what you're saying.

[14:14] <masak> but...

[14:15] <jnthn> Heredocs are, from a parsing perspective, exceedingly silly. :/

[14:15] <masak> the failure mode seems to be "compiler can't be arsed to parse the heredoc because the constant needs the value right now and looking at the next few lines is a really hard problem" :P

[14:16] <jnthn> Well, what if the constant gets used later on on the same line?

[14:16] <masak> point.

[14:16] <masak> m: constant W = W; say "alive"

[14:16] <camelia> rakudo-moar 137879: OUTPUT«===SORRY!===␤Cannot invoke null object␤»

[14:16] * masak submits rakudobug

[14:16] <masak> :D

[14:16] <jnthn> That one *is* a bug, but already in there :P

[14:16] <masak> m: constant W = W * 18; say "alive"

[14:16] <camelia> rakudo-moar 137879: OUTPUT«===SORRY!===␤Cannot invoke null object␤»

[14:16] <jnthn> I *think*

[14:17] <masak> m: constant W = "hey, does {W} work?"; say "alive"

[14:17] <camelia> rakudo-moar 137879: OUTPUT«===SORRY!===␤Cannot invoke null object␤»

[14:17] *** iarna left
[14:17] *** kaare_ joined
[14:17] <masak> m: constant W = EVAL "W"; say "alive"

[14:17] <camelia> rakudo-moar 137879: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling EVAL_0␤Undeclared name:␤    W used at line 1␤␤»

[14:17] <masak> meh.

[14:18] *** iarna joined
[14:18] <masak> anyway, the answer to "what if the constant is used in the heredoc" seems to me to be "well, *then* we give an error. not in the general case!"

[14:18] *** nbrown left
[14:19] <pmurias> why isn't the SORRY! error message style used in nqp?

[14:19] <masak> m: class C { has $x, $y }

[14:19] <camelia> rakudo-moar 137879: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/LU5fSc5GbT␤Variable '$y' is not declared␤at /tmp/LU5fSc5GbT:1␤------> [32mclass C { has $x, $y[33m⏏[31m }[0m␤    expecting any of:␤        postfix␤»

[14:20] <jnthn> I'd be happy to be shown a sane solution to heredoc in constant. I don't *like* it.

[14:20] <masak> that one could do with a better error message -- like "did you mean to put parens around those variables? `has ($x, $y);`"

[14:20] <jnthn> I just don't see a good way to do it that doesn't have a bunch of other issues...

[14:21] <jnthn> std: class C { has $x, $y }

[14:21] <camelia> std 81e0d07: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $y is not predeclared (declarators are tighter than comma, so maybe your 'has' signature needs parens?) at /tmp/irz2GByYeC line 1:␤------> [32mclass C { has $x, [33m⏏[31m$y }[0m␤Check failed␤FAILED 00:01 126m␤»

[14:21] <jnthn> Steal that error! :)

[14:21] <jnthn> pmurias: Because nobody implemented it yet.

[14:22] <jnthn> pmurias: Because implementing things takes time and NQP isn't user-facing enough for it to be worth spending the time on this compared to other things.

[14:22] <masak> jnthn: suggested way to make it work: parser sees that it's about to give a value to the constant, but in order to do that it needs to parse a heredoc first, so it parses the heredoc and then sets the value of the constant.

[14:22] <moritz> that kinda goes against both our control flow, and the concept of compile time being immediate compile time

[14:22] <jnthn> masak: Yes, when I said "suggestion" I meant "patch". I can see how to do it waving my hands. :)

[14:23] <masak> ok, got it ;)

[14:23] <jnthn> pmurias: If it annoys you enough you want to patch it, please do go ahead.

[14:23] <masak> moritz: I see it as breaking a rule in order to reach up to user expectations.

[14:23] <timotimo> and then we put a { BEGIN 1234 } inside the heredoc's string :D

[14:24] <masak> moritz: I certainly expected that one to work; only after having it explained to me did I even perceive the problem.

[14:24] <jnthn> timotimo: Yes, I'm seeing us "fixing" this and then masak finding 20 new things to submit because of the hack to make it work... :)

[14:25] <pmurias> what I thinking is shouldn't the "fancy" SORRY error messages be something that can be reused by different grammar

[14:25] <pmurias> * grammars

[14:25] <jnthn> As moritz said, it does break a relatively deep assumption...

[14:25] <jnthn> pmurias: I'm not sure. Exposing the highwater stuff is something we've pondered in the past...

[14:26] <masak> ok, if you think the fix isn't going to lead anywhere good, then let's skip it.

[14:27] <masak> I'm aware I'm discussing this with people who are better versed in the internals than I.

[14:27] <masak> I'm just reporting the expectations of a lowly userland coder. :>

[14:28] <jnthn> Well, I agree on the expectations... I'm just struggling on how to meet them without making some nice problems.

[14:28] <jnthn> uh

[14:28] <jnthn> some *new* problems

[14:28] <jnthn> :)

[14:30] <dalek> nqp-js: c707a6d | (Pawel Murias)++ | src/vm/js/ (2 files):

[14:30] <dalek> nqp-js: Implement the if and unless ops. (pass tests 2,3,4)

[14:30] <dalek> nqp-js: review: https://github.com/pmurias/nqp-js/commit/c707a6da68

[14:30] <dalek> nqp-js: dfa81ce | (Pawel Murias)++ | TODO:

[14:30] <dalek> nqp-js: Update TODO.

[14:30] <dalek> nqp-js: review: https://github.com/pmurias/nqp-js/commit/dfa81ce16b

[14:42] *** iarna left
[14:42] *** ggoebel1111118 joined
[14:44] *** FROGGS[mobile] left
[14:44] *** ggoebel1111117 left
[14:45] *** chenryn joined
[14:47] *** guru joined
[14:47] *** ajr_ left
[14:47] *** guru is now known as Guest81950

[14:47] *** Guest81950 is now known as ajr_

[14:53] *** itz_ joined
[14:56] *** itz left
[15:00] <masak> std: class C { has ($.x, $.y) is rw; }

[15:00] <camelia> std 81e0d07: OUTPUT«ok 00:01 125m␤»

[15:01] <masak> m: class C { has ($.x, $.y) is rw; }

[15:01] <camelia> rakudo-moar 287e49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/OCu5FIHkCz␤Two terms in a row␤at /tmp/OCu5FIHkCz:1␤------> [32mclass C { has ($.x, $.y) [33m⏏[31mis rw; }[0m␤    expecting any of:␤        scoped declarator␤        formal paramete…»

[15:01] * masak submits rakudobug

[15:08] *** xylixy joined
[15:09] *** xylixy left
[15:10] *** chenryn left
[15:13] *** denis_boyun_ left
[15:14] *** nbrown joined
[15:17] *** chenryn joined
[15:18] *** nbrown left
[15:19] <dalek> roast: 3076e09 | (Elizabeth Mattijsen)++ | integration/advent20 (15 files):

[15:19] <dalek> roast: dies_ok -> throws_like cleanup, part 1

[15:19] <dalek> roast: review: https://github.com/perl6/roast/commit/3076e09ffd

[15:19] <lizmat> FWIW, this fixes several cases of dies_ok tests that were dying for the wrong reason

[15:20] *** en is now known as enp3s0

[15:20] *** enp3s0 is now known as en

[15:24] *** chenryn left
[15:26] *** chenryn joined
[15:28] * masak throws one more coin into the "masak was golfing something, but it turned out to be a bug in masak, not in Rakudo" piggy-bank

[15:29] *** iarna joined
[15:29] *** xfix is now known as GlitchMr

[15:30] *** chenryn left
[15:35] *** chenryn joined
[15:36] *** dmol left
[15:44] *** dayangkun left
[15:50] *** chenryn left
[15:51] *** chenryn joined
[15:58] <donaldh> Truly bizarre. If I add an int field to SixModelObject then the JVM crashes, If I add a long or object field then it's fine.

[15:59] <jnthn> o.O

[15:59] <jnthn> Some weird alignment fail, maybe...

[15:59] <donaldh> Well I was thinking that, but object references are the same size as ints, no?

[16:01] <donaldh> compressed oops and all.

[16:01] *** [Sno] left
[16:03] <jnthn> ah, true

[16:03] <jnthn> OK, so it's just bizzare :)

[16:04] <jnthn> .oO( That's why they call it "oops"... )

[16:06] *** ajr_ left
[16:06] <donaldh> So I can store SC indices in SixModelObject using an Integer, which sucks, but is still more efficient than a separate HashMap, both in space and time.

[16:14] <jnthn> Well, space ways, for objects that are in an SC...

[16:15] *** nbrown joined
[16:15] <jnthn> *space wise

[16:19] *** nbrown left
[16:19] *** Rotwang joined
[16:19] *** guru joined
[16:19] *** telex left
[16:20] *** guru is now known as Guest75357

[16:20] *** telex joined
[16:20] *** Guest75357 is now known as ajr_

[16:26] *** dmol joined
[16:29] <sjn> yay, bfoy is tweeting about a 2013 jnthn-rant \o/

[16:29] <sjn> bdfoy*

[16:31] * sjn wonders if this is a good thing; https://twitter.com/briandfoy_perl/status/500316449311715330

[16:32] <sjn> hm. maybe it is. /me goes back to lurk-mode

[16:32] <jnthn> Well, I vastly prefer where we are now than where we were then.

[16:32] <sjn> jnthn: yeah, figured that

[16:34] <geekosaur> we left pugs behind but it played a very important role in getting us here,,,

[16:34] <FROGGS_> like Parrot

[16:35] * sjn has managed to stay optimistic about perl6 mostly because of being proficient at putting history into the "let's learn from that" box

[16:35] <FROGGS_> there wouldn't be a good Perl 6 implementation without Parrot

[16:35] <FROGGS_> sjn: true

[16:39] <pmurias> it's hard to say if the other Perl 6 implementations couldn't evolve towards what rakudo is today via a different route

[16:40] <pmurias> s/couldn't evolve/couldn't have evolved/

[16:41] <pmurias> what's good about rakudo is that it got a lot of different people working together

[16:52] <TimToady> m: say (*.name).Str

[16:52] <camelia> rakudo-moar 287e49: OUTPUT«WhateverCode.new()␤»

[16:52] <TimToady> m: say *.name

[16:52] <camelia> rakudo-moar 287e49: OUTPUT«WhateverCode.new()␤»

[16:53] <TimToady> I'm thinking the first of those should warn, rather than just delegating to .gist

[16:53] <TimToady> then maybe *.name ~~ /pos/ would have given better feedback

[16:54] <donaldh> Okay, so turned off compressed oops with -XX:-UseCompressedOops and no longer get a JVM crash. Almost enough info for a useful bug report to Oracle.

[16:56] <dalek> tablets: ae3d871 | (Herbert Breunung)++ | docs/ (5 files):

[16:56] <dalek> tablets: chapter assignement on ops tablet

[16:56] <dalek> tablets: review: https://github.com/perl6/tablets/commit/ae3d871d82

[16:56] <diakopter> "here's my golfed repro instance; sorry for the 9MB .jar"

[16:57] *** raiph left
[16:57] *** denis_boyun_ joined
[16:58] * donaldh was thinking more along the lines of "Here's a github repo, knock yourselves out."

[16:59] * donaldh will try a different arch first, to see if it's OSX specific.

[17:07] *** kaare_ left
[17:13] *** raiph joined
[17:14] *** chenryn left
[17:15] <dalek> tablets: 805bc72 | (Herbert Breunung)++ | docs/tablet-4-operators.txt:

[17:15] <dalek> tablets: links cant touch headings

[17:15] <dalek> tablets: review: https://github.com/perl6/tablets/commit/805bc72d1e

[17:15] *** nbrown joined
[17:19] *** nbrown left
[17:22] *** brrt joined
[17:22] <dalek> tablets: 85efc32 | (Herbert Breunung)++ | docs/tablet-4-operators.txt:

[17:22] <dalek> tablets: new op order

[17:22] <dalek> tablets: review: https://github.com/perl6/tablets/commit/85efc328d0

[17:23] *** lichtkind joined
[17:24] *** nbrown joined
[17:24] *** itz_ is now known as itz

[17:25] *** donaldh left
[17:29] *** nbrown left
[17:36] *** [Sno] joined
[17:37] *** ajr_ left
[17:44] <TimToady> m: class A { has $!foo = 42; multi sub sayfoo(A \this) is export { say this!foo } }; import A; sayfoo(A.new)

[17:44] <camelia> rakudo-moar 287e49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/dxSiySVjvS␤No such private method 'foo' for invocant of type 'A'␤at /tmp/dxSiySVjvS:1␤------> [32mub sayfoo(A \this) is export { say this![33m⏏[31mfoo } }; import A; sayfoo(A.new)[0m␤»

[17:45] <TimToady> hmm

[17:45] <TimToady> should that work?

[17:46] <TimToady> (we were discussing this on #moarvm, but it's more of a language issue)

[17:47] <TimToady> that is, should a multi sub defined inside a class have private trusted access to a parameter object's attributes

[17:48] <TimToady> I can't think of a good reason why not, offhand, other than we'd have to implement it :)

[17:48] <jnthn> Other question is if we're meant to create private methods per attribute...or some other trick :)

[17:48] <TimToady> could perhaps autogen on seeing this!foo

[17:50] <jnthn> Really we'd like to optimize it into nqp::getattr(...), of course 

[17:50] <jnthn> Which in turn under spesh/JIT can become something that's a pointer offset

[17:51] <TimToady> right, we want it fast, and there's no reason not to trust code inside the class

[17:51] <TimToady> so it's really a matter of notation

[17:52] <TimToady> is this!foo sufficient notation given we know it's A, or do we need to annotate the parameter somehow further

[17:52] <TimToady> and many of these will have both a this and a that parameter

[17:54] <TimToady> currently I suppose many things are written this.foo that are really intended to be this!foo, that is, non-virtual

[17:54] <jnthn> At present, if you don't quality it, I think we take the encosing package

[17:54] <jnthn> So class Foo { ...blah... self!x() } really means self!Foo::x

[17:54] <TimToady> so the trust already there, but not the mechanism, maybe

[17:54] <jnthn> Since they're non-virtual, the (static) optimizer already resolves them into, essentially, sub calls.

[17:55] <jnthn> The missing mechanism is for accessing attributes via private method syntax.

[17:55] <TimToady> I'm thinking that would be very useful for optimization of our operators

[17:56] <TimToady> so we know which ones don't have to take virtuality into account, and which do, based on ! vs .

[17:56] <TimToady> instead of relying on class finality to decide that, which is hard

[17:56] <jnthn> Well, many operators today are expressed in nqp:: ops ;)

[17:57] *** zakharyas joined
[17:57] <TimToady> indeed, so maybe this is really a way to write them in something that is a little less not quite :)

[17:57] <jnthn> If we put this in *and* optimize it well, we might be able to make them prettier and keep the speed benefit and give others writing custom ops a good way to do it :)

[17:57] <jnthn> 'cus we don't want folks using nqp::foo outside of the Rakudo built-ins, really...

[17:58] <TimToady> nodnod

[17:58] <TimToady> or is that shakeshake...

[18:00] <TimToady> m: class A { has $!foo = 42; multi sub sayfoo(A \this) is export { say this!A::foo } }; import A; sayfoo(A.new)

[18:00] <camelia> rakudo-moar 287e49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/5qDYSQNCC3␤No such private method 'foo' for invocant of type 'A'␤at /tmp/5qDYSQNCC3:1␤------> [32mub sayfoo(A \this) is export { say this![33m⏏[31mA::foo } }; import A; sayfoo(A.new)[0m␤»

[18:01] <TimToady> m: class A { trusts A; has $!foo = 42; multi sub sayfoo(A \this) is export { say this!A::foo } }; import A; sayfoo(A.new)

[18:01] <camelia> rakudo-moar 287e49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/BRnCGlkcR8␤No such private method 'foo' for invocant of type 'A'␤at /tmp/BRnCGlkcR8:1␤------> [32mub sayfoo(A \this) is export { say this![33m⏏[31mA::foo } }; import A; sayfoo(A.new)[0m␤»

[18:02] <TimToady> how do we support private methods in the general case?  or is that NYI?

[18:03] <jnthn> m: class A { method !private() { say 'shhh!' }; method public() { self!private() } }; A.public

[18:03] <camelia> rakudo-moar 287e49: OUTPUT«shhh!␤»

[18:04] <jnthn> m: class A { method !private() { say 'shhh!' }; method public() { self!privates() } }; A.public

[18:04] <camelia> rakudo-moar 287e49: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tUCeZT4CUK␤No such private method 'privates' for invocant of type 'A'␤at /tmp/tUCeZT4CUK:1␤------> [32mhh!' }; method public() { self!privates([33m⏏[31m) } }; A.public[0m␤»

[18:04] <diakopter> hehehe

[18:04] <jnthn> Take advantage of non-virtualness to give errors on typos :)

[18:04] <TimToady> but we don't have an autogen of a !private accessor yet for attrs?

[18:04] <jnthn> Correct.

[18:04] <TimToady> gotcha

[18:05] <TimToady> but as you say, we almost don't need on, if we just translate to nqp::

[18:05] <TimToady> *one

[18:06] <TimToady> offhand I don't see a problem with bypassing the autogen entirely

[18:06] <jnthn> Yeah, only trouble is if folks try and access it from the outside...otoh then there'd have to be a "trusts"

[18:06] <jnthn> So maybe we just auto-gen them if we see that

[18:06] <TimToady> well, but a class implicitly trusts itself...

[18:07] <TimToady> so you'd always autogen them :)

[18:07] *** klaas-janstol left
[18:07] <jnthn> I meant "a use of the trusts trait" :P

[18:07] <TimToady> well, you could remark upon the presence of this!foo

[18:07] <TimToady> oh, okay

[18:07] <jnthn> Oh, I think I see the confusion...

[18:07] *** brrt left
[18:07] <TimToady> me too :)

[18:07] <jnthn> What I more meant was that within a class, we can easily know which attributes we might need private accessors for.

[18:08] <jnthn> So it's only in the trusts FooOtherThing case that we might want to auto-gen them to make things we can't have figured out by composition time (at the closing }) work out.

[18:09] <TimToady> right, though we might have noticed the !foo usages in the other class as well, unless we want to allow !"$foo"()

[18:09] <TimToady> in which case we'd have to generate all of them

[18:10] <jnthn> Yeah, I was hoping we might get away with having to generate all of them...

[18:10] <TimToady> well, generating all of them is easier on some level than generating some of them :)

[18:10] <TimToady> and it's not like they're huge

[18:11] * TimToady will leave that decision up to the Harried Implementor :)

[18:12] <jnthn> True, though across the whole CORE.setting they add up...

[18:12] *** molaf joined
[18:12] * TimToady takes off the hat of Lazy Language Designer, and starts thinking about list abstraction again, and sweating...

[18:14] <TimToady> but in general, I like it whenever the circularity saw can be moved from the setting to the codegen :)

[18:15] * jnthn thinks its time for some dinner :)

[18:15] <jnthn> bbiab

[18:16] <TimToady> it's still a longterm goal of mine to get the setting written in Pure Perl 6, but I understand the usefulness of the nqp model too

[18:16] *** dmol left
[18:16] * TimToady goes back to coffee/backlog mode

[18:17] *** GlitchMr is now known as xfix

[18:22] *** molaf left
[18:25] *** nbrown joined
[18:26] <timotimo> o/

[18:28] <TimToady> \o

[18:28] <avuserow> hey, someone mentioned a bug with Compress::Snappy a few days ago IIRC? If someone could open an issue, I'll see about fixing it

[18:29] <avuserow> (also one of these days, I should muse about Bufs and Blobs and my interactions/pains with them when writing Compress::Snappy)

[18:29] *** nbrown left
[18:30] * TimToady considers Bufs and Blobs to still be a WIP

[18:30] <timotimo> sadly they seem to be

[18:32] <dalek> specs: 4c7c7d0 | TimToady++ | S99-glossary.pod:

[18:32] <dalek> specs: define WIP

[18:32] <dalek> specs: review: https://github.com/perl6/specs/commit/4c7c7d01f1

[18:33] <raiph> Anyone comments? "rakudo is still pretty damn slow, frankly. ... From my personal experiments, from the first day moarvm came out to now, the speed is at best twice as good, when what would be hoped would be ten times as good. Or even one hundred times." http://www.reddit.com/r/perl6/comments/2cozob/week_31_rakudos_speedram_performance_improves_at/

[18:33] <raiph> cjqwesc

[18:34] <TimToady> we agree completely :)

[18:35] <timotimo> i'm writing a little bit on that

[18:35] <TimToady> however, when we improve the compiler to the point where it runs P6 as fast as NQP, we'll definitely be pretty zippy

[18:36] <avuserow> TimToady: I'm fine with Bufs and Blobs being WIP. I'm hoping that sharing what I ran into previously will positively influence how they interact with NativeCall and other things :)

[18:37] <TimToady> sure, we want to know where the sticky wickets are

[18:38] *** kaare_ joined
[18:39] <diakopter> raiph: u just looking to stimulate downvotes? :)

[18:42] <diakopter> "57 seconds for a Rakudo build (used to be 1:15)"  ... I thought it used to be 5-6 minutes

[18:43] <jnthn> diakopter: That was talking about improvement in the space of a 1-2 week period...

[18:43] <diakopter> ah :)

[18:43] <diakopter> <- reading too slowly/quickly

[18:44] <timotimo> i posted on that thread

[18:46] <jnthn> "Rakudo's speed/ram performance improves at fastest rate since optimization work began" makes a bunch of improvements that mostly affect compilation speed sound more general than many of them were, tbh.

[18:46] <jnthn> They helped with some grammars.

[18:47] <jnthn> And of course, compilation speed influences how fast things feel.

[18:47] <timotimo> did anybody build the rakudo-specific caphash thing yet? i seem to recall froggs did that?

[18:47] <jnthn> timotimo: I didn't do it...

[18:47] <jnthn> I don't remember seeing it done but maybe it was.

[18:47] *** denis_boyun_ left
[18:48] <timotimo> hmm, seems like i was wrong

[18:48] <timotimo> hm. i'm sitting next to two 3d printers

[18:48] <timotimo> i don't have an idea what i could print, though :\

[18:49] <TimToady> obviously, another 3d printer

[18:49] <TimToady> extra credit for working sex into it

[18:52] *** spider-mario left
[18:53] <diakopter> want: "3d printer" that makes large things from duct tape and baling wire and glue and trash

[18:53] <timotimo> that would be way cool.

[18:53] <TimToady> I thought you were supposed to feed those things to Mr Fusion

[18:53] <masak> std: constant (a, b, c) = 1, 2, 3;

[18:54] <camelia> std 81e0d07: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing symbol in constant declaration at /tmp/T1vqsNO_Z3 line 1:␤------> [32mconstant [33m⏏[31m(a, b, c) = 1, 2, 3;[0m␤Missing initializer on constant declaration at /tmp/T1vqsNO_Z3 line 1:␤------> [32mconstant [33m…»

[18:54] <TimToady> hey, enum has to be better at something

[18:57] <TimToady> on top of which, I really hate it when people use list initialization to set up a bunch of complete unrelated items, especially since it decouples the name from the value, unless you line them up on the next line

[18:57] <TimToady> so if the constants are in fact unrelated, I'd much rather see three constant declarations on three lines

[18:58] <TimToady> that's not to say we couldn't support the notation here, but I'm not in a hurry :)

[19:00] <masak> *nod*

[19:00] <TimToady> but if the constants are in fact related, you might well get more bang for the buck out of an enum, like a typename

[19:00] <masak> I just have a piece of code here with literally 10 lines, all starting with `constant`

[19:01] <TimToady> maybe you should write a macro :P

[19:01] <masak> they're all constants, to be sure, but the JavaScript programmer in me helpfully suggested that those 10 declarations maybe could be 1.

[19:01] *** klaas-janstol joined
[19:01] <masak> TimToady: that should totally be writable as a macro, yes.

[19:01] <masak> by the way, I can feel my focus turn back to macros. I fully intent to bring that grant to completion. 

[19:02] <masak> though we already know we want something a fair bit different from what the grant talks about.

[19:02] <masak> (which is fine, IMO)

[19:02] <timotimo> glad to hear it :)

[19:02] <TimToady> Cool!  I mean...Mu!

[19:08] *** darutoko left
[19:11] <diakopter> want: macros that can use regex-genex-ish to permute names and types/formulas

[19:12] <masak> yeah, it's increasingly clear that macros should hook into the grammar level.

[19:12] <tadzik> timotimo: hehe, will try :)

[19:13] <masak> right now we have them as hooking into (parsed) function calls, which is right for some things but not for a big class of things.

[19:13] *** klaas-janstol left
[19:14] *** AforAcronym left
[19:17] *** guru joined
[19:18] *** guru is now known as Guest22875

[19:18] <tadzik> timotimo: do you happen to have a rakudobrew config for moar-jit?

[19:18] *** Guest22875 is now known as ajr_

[19:18] <timotimo> no; --moar-option=--enable-jit should be enough

[19:19] <timotimo> you can supply that even for rakudo-Configure.pl

[19:19] *** ggoebel1111119 joined
[19:19] <timotimo> hm. so what do i supply for bench time to get accurate data and lots of it?

[19:20] *** ggoebel1111118 left
[19:20] <timotimo> i suppose i'll up the --runs and up the --enough-time

[19:22] <tadzik> so master branches are alright?

[19:22] <timotimo> yes

[19:22] <tadzik> awesome :)

[19:22] *** klaas-janstol joined
[19:22] <timotimo> we merged moar-jit into master at the beginning of the week

[19:23] <jnthn> Aye. Still needs explicit --enable-jit, bu tit's in theer

[19:23] <jnthn> so typing...

[19:24] <tadzik> tit's in there? :>

[19:24] <tadzik> I mean, :o

[19:24] <diakopter> :O

[19:25] *** AforAcronym joined
[19:25] <masak> IRC needs a spell checker.

[19:26] *** nbrown joined
[19:26] <timotimo> this might take a long while, but i have no use for my desktop otherwise.

[19:26] * timotimo runs rakudo-moar from 2014.01 through 2014.07

[19:26] <diakopter> (space heater)++

[19:29] <FROGGS_> timotimo++ # levenshtein

[19:30] <masak> timotimo++ # levhensetin :)

[19:30] *** nbrown left
[19:32] *** klaas-janstol left
[19:33] *** treehug88 left
[19:34] <timotimo> diakopter: i'm far away from it at the moment, so it's of no consequence to me personally :)

[19:34] <dalek> rakudo/nom: af5df3e | TimToady++ | src/core/Code.pm:

[19:34] <dalek> rakudo/nom: Warn on Str(Code) coercion

[19:34] <dalek> rakudo/nom: 

[19:34] <dalek> rakudo/nom: This almost always indicates a mistake, and the message can be suppressed by

[19:34] <dalek> rakudo/nom: use of .gist or .perl, if the behavior is intended.

[19:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af5df3e052

[19:39] <TimToady> $ ./perl6 -e '*.name ~~ /pos/'

[19:39] <TimToady> Code object coerced to string (please use .gist or .perl to do that  in any !cursor_init at gen/moar/stage2/QRegex.nqp:598

[19:40] <dalek> rakudo/nom: ed7e8d3 | TimToady++ | src/core/Code.pm:

[19:40] <dalek> rakudo/nom: lost closing paren

[19:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ed7e8d369c

[19:40] *** ssutch joined
[19:40] <TimToady> the traceback leaves something to be desired though

[19:41] <jnthn> Yes, I'm curious why it ends up there...

[19:41] *** nbrown joined
[19:42] *** nbrown_ joined
[19:44] <TimToady> apparently doesn't escape nqp-land

[19:44] <TimToady> a normal coercion produces a correct traceback, so somethingin QRegex maybe

[19:45] <TimToady> is there a CONTROL that is trapping warnings inadvertently?

[19:45] <jnthn> Can't think of one

[19:45] *** nbrown left
[19:45] <TimToady> well, you'd think it would just disappear in that case anyway

[19:46] <timotimo> m: next

[19:46] <camelia> rakudo-moar 287e49: ( no output )

[19:46] <timotimo> m: last

[19:46] <camelia> rakudo-moar 287e49: ( no output )

[19:47] <TimToady> m: nextsame

[19:47] <camelia> rakudo-moar 287e49: OUTPUT«nextsame is not in the dynamic scope of a dispatcher␤  in block  at src/gen/m-CORE.setting:639␤  in block  at /tmp/LqNijE9RBZ:1␤␤»

[19:47] *** nbrown_ left
[19:47] <TimToady> m: say "here"; redo

[19:47] <camelia> rakudo-moar 287e49: OUTPUT«here␤»

[19:47] <TimToady> o.O

[19:47] *** kaare_ left
[19:47] <timotimo> haha, wat.

[19:47] <jnthn> m: say "here"; redo; say 'survived';

[19:47] <camelia> rakudo-moar 287e49: OUTPUT«here␤»

[19:48] <FROGGS_> it misses its handler and then exits

[19:48] <jnthn> hm, should be an error...

[19:48] <timotimo> TimToady: i suppose you tried that in the repl, too?

[19:48] <jnthn> Yes, it should end up in print_control...

[19:48] *** gfldex joined
[19:49] <TimToady> well, our repl is still really just a total kludge

[19:50] <TimToady> it wants to be integrated with the parser

[19:50] <timotimo> https://gist.github.com/timo/2b490027d6473340e4e1

[19:51] <jnthn> bah...did it do a "redo" in the REPL loop and confuse itself?

[19:51] <timotimo> :D

[19:51] <timotimo> it'd really be good if our repl would be more clever, then the iperl6 kernel thingie wouldn't be as kludgy as well (hopefully)

[19:52] <TimToady> we should rely on the parse to tell the repl when to execute the next top-level statement

[19:53] <jnthn> The REPL is one of the least changed things since I started working on Rakudo :)

[19:53] <TimToady> that would be a good mid-level project for someone trying to move on from LHF

[19:53] *** ventica2 left
[19:54] <jnthn> aye

[19:54] <TimToady> basically, at the point where STD calls .moreinput is where the REPL would decide whether to E

[19:55] <FROGGS_> we have no .moreinput in rakudo :/

[19:55] <FROGGS_> (yet)

[19:56] <TimToady> the L part is implicit in parsing statements at the top level

[19:56] *** brrt joined
[19:57] <TimToady> yes, that's one of the dusty corners where rakudo has yet to catch up to STD

[19:57] <FROGGS_> hmmm, I almost think I've produced a measurable speedup of rakudo's stage parse O.o

[19:58] <timotimo> well ... it'll have to parse a new statement and then directly execute it, even though it's not supposed to be BEGIN time ... no?

[19:59] <jnthn> FROGGS_: ooh?

[20:00] *** brrt left
[20:00] <FROGGS_> jnthn: yeah, in method_def it does not call $*W.dissect_longname now when it sees a colonpair, it just builds the method name string like deflongname does it

[20:00] <TimToady> timotimo: well, it only happens at the top level, so unless there's something that has to happen at CHECK time (like deal with forward refs on sub calls), it's equivalent

[20:00] *** lichtkind left
[20:00] <timotimo> ah

[20:01] <timotimo> fair enough

[20:01] *** rurban1 left
[20:02] <TimToady> and of course anything BEGIN that happens later will be out of sequence with what came before, but that's the price for a repl

[20:04] <TimToady> the other tricky bit is going on when there's a parse error

[20:05] *** ventica joined
[20:06] <TimToady> now I'm imagining a repl that can suspend on delayed decls "previous execution suspended on call to foo(); please define it to continue"

[20:07] <dalek> rakudo/nom: 3c6bcff | (Tobias Leich)++ | src/Perl6/Actions.nqp:

[20:07] <dalek> rakudo/nom: canonicalize method names with colonpairs, to fit grammar rule names

[20:07] <dalek> rakudo/nom: 

[20:07] <dalek> rakudo/nom: We turned rule names like term:sym«<=» into term:sym<<=> internally

[20:07] <dalek> rakudo/nom: but we forgot to do the same with action methods. This meant that when

[20:07] <dalek> rakudo/nom: the rule matched the action method was *not* called.

[20:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3c6bcff5ea

[20:07] <TimToady> at some point a repl becomes a self-parody though

[20:08] <TimToady> the pythonistas haven't got the joke yet

[20:08] *** AforAcronym left
[20:09] <FROGGS_> >>> if you say so :o)

[20:09] <nwc10> FROGGS_: I'm not quite following (what's new then) - is that commit a behaviour bugfix, or just a performance bug fix?

[20:10] <FROGGS_> nwc10: behaviour

[20:10] <FROGGS_> m: grammar G { token TOP { <a> }; proto token a {*}; token a:sym«<foo>» { <sym> } }; class A { method a:sym«<foo>»($/) { say("awesome") } }; G.parse("<foo>", :actions(A) )

[20:10] <camelia> rakudo-moar 287e49: ( no output )

[20:10] <FROGGS_> this is meant to say "awesome"

[20:10] <nwc10> are there tests for this?

[20:10] <FROGGS_> no

[20:11] <nwc10> oh.

[20:11] <jnthn> (But there should be... :))

[20:12] <FROGGS_> as always :o)

[20:12] <PerlJam> FROGGS_: you've been working on that one for at least 3 days.  FROGGS++ for finally finding and fixing it.

[20:12] *** rindolf left
[20:12] <FROGGS_> but yeah, I will add one in a sec... # nwc10++ :o)

[20:12] <FROGGS_> PerlJam: well, I got a almost-fix yesternight, but was too tired

[20:14] <jnthn> FROGGS_++ is a very persistent bug fixer :)

[20:14] *** nbrown_ joined
[20:15] *** jnap left
[20:16] *** jnap joined
[20:17] <timotimo> it sounds great that it also improves performance :)

[20:18] *** zakharyas left
[20:18] *** nbrown_ left
[20:18] <FROGGS_> m: class Foo { method special_variable:sym['$<'] { } }

[20:18] <camelia> rakudo-moar 287e49: ( no output )

[20:19] *** iarna left
[20:20] *** iarna joined
[20:23] <FROGGS_> m: grammar Foo { token special_variable:sym["foo"] { } }; say Foo.^methods(:local)

[20:23] <camelia> rakudo-moar 287e49: OUTPUT«===SORRY!===␤Cannot find method 'ast'␤»

[20:23] <FROGGS_> (that is not due to my patch)

[20:26] *** spider-mario joined
[20:31] *** mj41 joined
[20:34] *** rurban1 joined
[20:34] <dalek> tablets: afdf4bb | (Herbert Breunung)++ | docs/tablet-4-operators.txt:

[20:34] <dalek> tablets: even better ordering

[20:34] <dalek> tablets: review: https://github.com/perl6/tablets/commit/afdf4bb133

[20:38] <dalek> rakudo/nom: 50c7653 | (Tobias Leich)++ | src/Perl6/Actions.nqp:

[20:38] <dalek> rakudo/nom: point out that we cannot handle all colonpairs yet

[20:38] <dalek> rakudo/nom: 

[20:38] <dalek> rakudo/nom: Before a token foo:sym["bar"] leaked internal information, now it states

[20:38] <dalek> rakudo/nom: that "bar" is too complex to use it as a name. This also makes the behaviour

[20:38] <dalek> rakudo/nom: consistant in grammars and classes.

[20:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/50c7653ad8

[20:38] *** kurahaupo_ joined
[20:42] *** klaas-janstol joined
[20:45] *** en is now known as eo

[20:46] *** eo is now known as en

[20:46] *** rurban2 joined
[20:47] <dalek> perl6-bench: 807c8e8 | jnthn++ | bench:

[20:47] <dalek> perl6-bench: Don't assume #! handling is portable.

[20:47] <dalek> perl6-bench: 

[20:47] <dalek> perl6-bench: This is one tiny, easily applyable, improvement that helps get things

[20:47] <dalek> perl6-bench: working on Windows.

[20:47] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/807c8e84b4

[20:49] *** rurban1 left
[20:54] *** colomon left
[21:00] <dalek> roast: 20d6f3b | (Tobias Leich)++ | S05-grammar/action-stubs.t:

[21:00] <dalek> roast: test colonpairs in tokens/ation methods

[21:00] <dalek> roast: review: https://github.com/perl6/roast/commit/20d6f3bb51

[21:03] *** colomon joined
[21:04] *** nbrown_ joined
[21:08] *** gfldex left
[21:08] *** nbrown_ left
[21:10] <dalek> specs: 3625f13 | (Stéphane Payrard)++ | S99-glossary.pod:

[21:10] <dalek> specs: Update S99-glossary.pod

[21:10] <dalek> specs: 

[21:10] <dalek> specs: Added MI as short for Multiple inheritance (used in https://github.com/MoarVM/MoarVM/blob/master/src/6model/reprs/P6opaque.h)

[21:10] <dalek> specs: review: https://github.com/perl6/specs/commit/3625f13018

[21:14] *** davido__ left
[21:16] *** Mouq joined
[21:19] <dalek> rakudo/nom: b982bdd | Mouq++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[21:19] <dalek> rakudo/nom: Somewhat improve rare error

[21:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b982bdd747

[21:21] <dalek> perl6-bench: 9ebd6cd | jnthn++ | timeall:

[21:21] <dalek> perl6-bench: A quotes fixup for invoking with Windows shell.

[21:21] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/9ebd6cdce1

[21:21] <dalek> perl6-bench: 32b35bf | jnthn++ | compilers.pl:

[21:21] <dalek> perl6-bench: Fix to cope with Perl 5 on Windows install path.

[21:21] <dalek> perl6-bench: 

[21:21] <dalek> perl6-bench: Still have to build this quite manually on Windows for perl6-bench,

[21:21] <dalek> perl6-bench: but this does at least mean once you've done that it'll be invoked

[21:21] <dalek> perl6-bench: correctly.

[21:21] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/32b35bffd4

[21:22] *** aindilis joined
[21:25] <TimToady> m: *.name ~~ /pos/

[21:25] <camelia> rakudo-moar 3c6bcf: OUTPUT«Code object coerced to string (please use .gist or .perl to do that)  in any !cursor_init at gen/moar/stage2/QRegex.nqp:598␤␤»

[21:26] <Mouq> m: [ (1,2,3), (4,) ].tree.perl.say

[21:26] <camelia> rakudo-moar 3c6bcf: OUTPUT«(1, 2, 3, 4).list␤»

[21:26] <Mouq> m: [ (1,2,3), (4,) ].tree(2).perl.say

[21:26] <camelia> rakudo-moar 3c6bcf: OUTPUT«(1, 2, 3, 4).list␤»

[21:26] <Mouq> ...?

[21:28] *** BenGoldberg joined
[21:28] <Mouq> m: ( (1,2,3), (4,) ).tree(2).perl.say #wtf

[21:28] <camelia> rakudo-moar 3c6bcf: OUTPUT«(LoL.new(1, 2, 3).item, LoL.new(4).item).list␤»

[21:29] <Mouq> That doesn't seem right at *all*

[21:30] *** rurban2 left
[21:30] <TimToady> [] flattens

[21:31] <TimToady> m: ( (1,2,3), (4,) ).tree(1..2).perl.say

[21:31] <camelia> rakudo-moar 3c6bcf: OUTPUT«(LoL.new(1, 2, 3).item, LoL.new(4).item).list␤»

[21:31] <TimToady> m: ( (1,2,3), (4,) ).tree(1).perl.say

[21:31] <camelia> rakudo-moar 3c6bcf: OUTPUT«LoL.new($(1, 2, 3), $(4,))␤»

[21:32] <Mouq> m: ( (1,2,3), (4,) ).tree({$_ ~~ 1..2|).perl.say

[21:32] <camelia> rakudo-moar 50c765: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CPznxAUEYi␤Bogus statement␤at /tmp/CPznxAUEYi:1␤------> [32m( (1,2,3), (4,) ).tree({$_ ~~ 1..2|[33m⏏[31m).perl.say[0m␤    expecting any of:␤        postfix␤        infix stopper␤…»

[21:32] <TimToady> m: ( (1,2,3), (4,) ).tree(1,2).perl.say

[21:32] <camelia> rakudo-moar 50c765: OUTPUT«Cannot call 'tree'; none of these signatures match:␤:(Any:U: *%_)␤:(Any:D: *%_)␤:(Any:D: Cool $count, *%_)␤:(Any:D: &c, *%_)␤  in block  at /tmp/LfrM4zPY9s:1␤␤»

[21:32] <Mouq> m: ( (1,2,3), (4,) ).tree({$_ ~~ 1..2}).perl.say

[21:32] <camelia> rakudo-moar 50c765: OUTPUT«(Bool::True, Bool::False).list␤»

[21:32] <BenGoldberg> m: say $(1..3);

[21:32] <camelia> rakudo-moar 50c765: OUTPUT«1..3␤»

[21:32] <TimToady> m: ( (1,2,3), (4,) ).tree(1000..1001).perl.say

[21:32] <camelia> rakudo-moar 50c765: OUTPUT«(LoL.new(1, 2, 3).item, LoL.new(4).item).list␤»

[21:32] <TimToady> that's +(1000..1001) :/

[21:33] <TimToady> I don't think .tree is implemented anywhere close to spec yet

[21:33] <TimToady> last I knew, it could only do a lol impression

[21:39] <dalek> nqp-js: 44817ff | (Pawel Murias)++ | src/vm/js/ (4 files):

[21:39] <dalek> nqp-js: Pass test 7.

[21:39] <dalek> nqp-js: 

[21:39] <dalek> nqp-js: Add a special $T_BOOL want type which produces something we can test for truth in javascript.

[21:39] <dalek> nqp-js: QAST::Compiler.boolify is replaced with coersions to this type.

[21:39] <dalek> nqp-js: Implement nqp::istrue, nqp::falsey, nqp::isle_n, nqp::concat.

[21:39] <dalek> nqp-js: Add &ok and &plan to the mini-setting.

[21:39] <dalek> nqp-js: review: https://github.com/pmurias/nqp-js/commit/44817ff964

[21:41] <dalek> nqp-js: c75badb | (Pawel Murias)++ | src/vm/js/bin/run_tests:

[21:41] <dalek> nqp-js: Add passing test 8 to run_tests.

[21:41] <dalek> nqp-js: review: https://github.com/pmurias/nqp-js/commit/c75badb327

[21:42] *** en left
[21:42] *** en joined
[21:42] *** en left
[21:43] *** en joined
[21:44] <dalek> specs: 63a4830 | (Stéphane Payrard)++ | S99-glossary.pod:

[21:44] <dalek> specs: Glossary: opcode, role, stable...

[21:44] <dalek> specs: review: https://github.com/perl6/specs/commit/63a483052a

[21:46] <Mouq> pmurias++

[21:48] <dalek> roast: bf6c3cb | (Elizabeth Mattijsen)++ | integration/ (6 files):

[21:48] <dalek> roast: More dies_ok -> throws_like cleanup

[21:48] <dalek> roast: review: https://github.com/perl6/roast/commit/bf6c3cb166

[21:50] *** kurahaupo_ left
[21:54] *** rurban1 joined
[21:56] <dalek> rakudo/HyperWat: d7808f5 | Mouq++ | src/ (5 files):

[21:56] <dalek> rakudo/HyperWat: method postcircumfix:<( )> becomes method invoke

[21:56] <dalek> rakudo/HyperWat: 

[21:56] <dalek> rakudo/HyperWat: per http://irclog.perlgeek.de/perl6/2014-07-08#i_8992020

[21:56] <dalek> rakudo/HyperWat: review: https://github.com/rakudo/rakudo/commit/d7808f5f99

[21:56] *** dalek left
[21:56] <Mouq> Sorry dalek :(

[21:57] *** dalek joined
[21:57] *** ChanServ sets mode: +v dalek

[21:57] <Mouq> Relevant commit: https://github.com/rakudo/rakudo/commit/87a0ca8048f280b7e4444a8c94232ad16fc3566e

[21:58] <Mouq> So that means that ** + 1 works, and ** + ** is the same as * + ** or ** + ** becase I don't know exactly what either of things should mean

[21:59] <masak> the conservative thing would be to make it a compile error until we do know what they should mean :)

[21:59] <masak> I'd rather we guess right later without having guessed wrong first.

[22:00] <Mouq> I considered that, I was hoping there would be somekind of epiphany from #perl6 :) I guess that's the way to go for now

[22:01] <masak> Mouq: when I saw you write about it earlier today, I almost replied "no-one knows what ** does because no-one's ever implemented it". then I noticed that you *were* implementing it, so I didn't say anything. but I think it still holds. :)

[22:01] <TimToady> well, it makes no sense to write a subscript [1; **; 2; **; 3] either

[22:01] *** Rotwang left
[22:02] <TimToady> so I think ** is 'non associative'

[22:02] <TimToady> unless we go whole hog on pattern matching

[22:02] <lizmat> TimToady: wrt to EVAL not poisoning

[22:02] <lizmat> wouldn't a simple flag already serve a lot of this?

[22:03] <lizmat> EVAL "foo" :clean

[22:03] <lizmat> EVAL "foo" :remedy # as opposed to poisoning

[22:03] <TimToady> that does some of it, but I'm thinking more EVAL "$a", :uses<$a>

[22:03] <TimToady> er, '$a'

[22:04] <lizmat> hehe..  -)

[22:04] *** mj41 left
[22:05] *** nbrown_ joined
[22:05] <lizmat> OTOH, would an EVAL be able to deopt a previously jitted scope at runtime?

[22:05] <lizmat> jnthn: ^^^

[22:06] <timotimo> we can deopt out of both jitted and spesh'd bytecode

[22:06] <masak> I had it as it never trying to opt in the first place if there's an EVAL in there.

[22:06] <timotimo> and invocations get a deoptpoint

[22:06] <timotimo> the qast-level optimizer bails out when it sees EVAL

[22:06] <lizmat> I'm more thinking on what I did earlier today:

[22:06] <TimToady> I thought it had more to do with turning lexicals into locals

[22:06] <timotimo> exactly

[22:06] <jnthn> lizmat: Level error

[22:06] <lizmat> EVAL "foo", :context(CALLER::CALLER::CALLER::CALLER::)

[22:06] <timotimo> and inlining frames

[22:07] <jnthn> lizmat: EVAL is about Perl6::Optimizer

[22:07] <timotimo> what TimToady said

[22:07] <TimToady> and if you know which lexicals will be used in the EVAL, then a :uses<$a> can pessimize just that lexical

[22:07] *** rurban2 joined
[22:07] <TimToady> alternately, if the intend of 'my $a' is to be used in an eval, we could mark it on that end

[22:08] <TimToady> *tent

[22:08] <jnthn> TimToady: "my $a is context" or whatever we call that nowadays is enough for that :)

[22:08] <timotimo> maybe even "is dynamic"

[22:08] <TimToady> well, but maybe we don't want to make it visible to callees

[22:09] * lizmat is losing visibility and gets some sleep&

[22:09] <TimToady> though I guess in the case of the testers it's off in a different scope anyway

[22:09] *** Ven joined
[22:09] *** nbrown_ left
[22:09] *** autark left
[22:09] <TimToady> anyway, doesn't seem like it always needs to be an all-or-nothing decision

[22:11] *** rurban1 left
[22:11] <masak> CALLER::CALLER::CALLER::CALLER:: isn't worrying to me because it uses an internal thing. it's worrying because it couples that statement with the dynamic state of the call stack. (making refactors error-prone.)

[22:11] *** ventica left
[22:14] *** treehug88 joined
[22:14] <Ven> o/o\o/, people.

[22:14] <masak> look behind you, a three-headed monkey!

[22:16] <timotimo> hey ven! :)

[22:17] <timotimo> enjoying your vacation?

[22:17] *** treehug88 left
[22:17] <Ven> I pushed the learnxiny and am currently fighting with agda

[22:17] <Ven> so, yeah :D.

[22:23] <diakopter> can you do anything with agda other than fight?

[22:23] <TimToady> masak: the fundamental problem with making the constant lookahead for the heredoc is that it violates the one-pass parsing rule

[22:24] <masak> TimToady: yes, I realize that.

[22:25] <TimToady> in fact, STD used to do the lookahead like P5 does, and I rewrote it to avoid that :)

[22:25] *** nbrown_ joined
[22:26] <TimToady> in fact, the discussion at S02:4474 stems from that time

[22:26] <synopsebot> Link: http://perlcabal.org/syn/S02.html#line_4474

[22:27] <masak> there are a couple of cases where we deviate from one-pass parsing.

[22:27] <masak> what would be the nasty WAT of doing it in this case, and allowing constants to have heredocs?

[22:27] <dalek> rakudo/HyperWat: adc2971 | Mouq++ | src/ (3 files):

[22:27] <dalek> rakudo/HyperWat: Make multiple **s or *s fail

[22:27] <dalek> rakudo/HyperWat: 

[22:27] <dalek> rakudo/HyperWat: Also make HyperWhatever !== Whatever due to issues it caused with multis

[22:27] <dalek> rakudo/HyperWat: that had candidates for both

[22:27] <dalek> rakudo/HyperWat: review: https://github.com/rakudo/rakudo/commit/adc2971f1f

[22:27] * masak reads that discussion

[22:28] <masak> right, that "slight restriction" is OK by me.

[22:28] <masak> and I realize `constant` has BEGIN semantics.

[22:28] <masak> but... still... I wouldn't have expected constant + q:to to fail.

[22:29] *** nbrown_ left
[22:29] <TimToady> nobody expects the spanish influenza

[22:29] <masak> OK, let me put it like this:

[22:30] <masak> when this becomes a FAQ, what will be the recommended workaround?

[22:30] <TimToady> put the ; after the END

[22:30] <masak> huh.

[22:31] *** Psyche^ joined
[22:31] <masak> OK, I can live with that, I think.

[22:33] *** ivanshmakov| left
[22:35] *** Psyche^_ left
[22:38] *** ivanshmakov| joined
[22:38] <dalek> specs: 9a3ba4d | (Stéphane Payrard)++ | S99-glossary.pod:

[22:38] <dalek> specs: Update S99-glossary.pod

[22:38] <dalek> specs: 

[22:38] <dalek> specs: too many changes to track.

[22:38] <dalek> specs: review: https://github.com/perl6/specs/commit/9a3ba4d4c2

[22:38] <Mouq> Getting @a[**] to work on an unshaped @a is really tricky... I'm not sure it should be allowed

[22:39] * TimToady either, feel free to stub it out for now

[22:40] <TimToady> it would probably have to be based on deepmap semantics, if allowed

[22:40] *** rurban2 left
[22:46] * TimToady compares the insides of his eyelids &

[22:46] *** pmurias left
[22:48] *** ventica joined
[22:48] <masak> 'night, #perl6

[22:48] *** klaas-janstol left
[22:49] <dalek> rakudo/HyperWat: 2856ec6 | Mouq++ | src/core/array_slice.pm:

[22:49] <dalek> rakudo/HyperWat: Uncomment NYI for ** in postcircumfix:<[ ]>

[22:49] <dalek> rakudo/HyperWat: review: https://github.com/rakudo/rakudo/commit/2856ec6ab3

[22:49] <Mouq> 'night masak

[22:51] <Ven> diakopter: no. There's actually a theory that says that, once your program typechecks, you don't gain any information running it :)

[22:52] * diakopter is familiar with this theory

[22:55] <en> When this channel gets really quite for a prolonged period of time, dalek should yell "exterminate" into this channel.

[22:55] <tadzik> hah

[22:56] <en> And on the offchance that a random number between 1 and 10 is 3, it yells "explain" into the channel.

[22:56] <en> Along with the previous statement.

[22:57] <diakopter> "exterminate" is more a command-to-self than statement :p

[22:58] <dalek> specs: fe908aa | duff++ | S99-glossary.pod:

[22:58] <dalek> specs: minor typos

[22:58] <dalek> specs: review: https://github.com/perl6/specs/commit/fe908aa834

[22:59] <timotimo> tadzik: did you try steroids jitted yet? :)

[23:00] *** iarna left
[23:00] <tadzik> timotimo: http://www.meemes.com/sites/default/files/styles/large/public/Soon-Sloth.png?itok=zlZ2eZAU

[23:02] <timotimo> :)

[23:02] <tadzik> it ran without problems, apparently

[23:02] <timotimo> as it should

[23:03] <tadzik> it seems to run at about the same speed as HEAD

[23:03] <tadzik> 2 "Too Slow" frames on jit vs 3 on HEAD

[23:03] <tadzik> and of course I played it differently each time

[23:03] <tadzik> I should design a steroids benchmark

[23:03] <timotimo> did you build an MVM_JIT_LOG?

[23:04] <tadzik> nope

[23:04] *** iarna joined
[23:04] <tadzik> how do I do that?

[23:04] <timotimo> env MVM_JIT_LOG=foobar.txt perl6-m ...

[23:04] <tadzik> Segmentation fault (core dumped)

[23:04] <tadzik>  :)

[23:05] <tadzik> timotimo: http://feather.perl6.nl/~tjs/foo.txt

[23:08] *** rom1504 joined
[23:09] *** klaas-janstol joined
[23:09] *** klaas-janstol left
[23:10] <timotimo> just adding the log should not make it segfault :\

[23:10] *** rom1504 left
[23:10] <timotimo> oh

[23:11] <timotimo> we haven't bumped moarvm/nqp recently

[23:11] <timotimo> at least existspos has been implemented. probably more importantly: paramnamesused

[23:13] *** raiph left
[23:15] <timotimo>       6 BAIL: op <bool_I>

[23:15] <jnthn> May be easy.

[23:16] *** spider-mario left
[23:16] <timotimo> add_sprite bails with getlex_no

[23:18] *** klaas-janstol joined
[23:18] <timotimo> remove_sprite does the same

[23:19] <timotimo> div_In makes a Num method bail

[23:19] *** klaas-janstol left
[23:22] <timotimo> wow, we get not only to speshing, but also to jitting METAOP_NEGATE

[23:22] <timotimo> (fairly far towards the end, so it's probably barely prominent enough to make the cut or something

[23:26] *** jnap left
[23:26] *** bjz joined
[23:42] *** grondilu left
[23:43] *** kurahaupo joined
