[00:00] * TimToady finds "%0{$!l}d" the most readable, or maybe "%0{ $!l }d"

[00:04] *** daniel-s joined
[00:06] *** virtualsue left
[00:07] *** ajr_ left
[00:09] *** Rotwang left
[00:18] *** sisar left
[00:25] *** xenoterracide joined
[00:26] *** xenoterracide left
[00:26] *** xenoterracide joined
[00:30] *** jnap1 left
[00:31] <thilp> r: my $a = if 1 { 2 } else { 3 }

[00:31] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m␤Word 'if' interpreted as a listop; please use 'do if' to introduce the statement control word␤at /tmp/tmpfile:1␤------> [32mmy $a = if[33m⏏[31m 1 { 2 } else { 3 }[0m␤Unex…»

[00:31] *** xenoterracide left
[00:41] <grondilu> r: say my $ = 1 ?? 2 !! 3;  # 

[00:41] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«2␤»

[00:41] <grondilu> r: say my $ = do if 1 { 2 } else { 3 } 

[00:41] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«2␤»

[01:01] *** jnap joined
[01:03] *** iolympian1 joined
[01:03] *** iolympian1 left
[01:04] *** iolympian2 joined
[01:05] *** jnap left
[01:07] *** iolympian2 left
[01:11] *** raiph joined
[01:12] <grondilu> r: say (my uint64 $ = 2**42 + 1) ==  1;  # I got True this on local 

[01:12] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«False␤»

[01:19] <raiph> lizmat++ # perlmonks post

[01:24] *** grondilu left
[01:37] *** slavik left
[01:38] <[Coke]> URL?

[01:40] *** slavik joined
[01:42] <skids> perl6 -e "require NativeCall 'trait_mod:<is>'; sub a is native { };" # This gives "Can't use unknown trait 'is native' in a sub declaration."  Trying to figure out runtime conditional NativeCall loading.

[01:46] <thilp> I don't get it: I've the same rakudos than camelia, but I got a "Null PMC access in get_string()" with perl6-p and an infinite loop of "Word 'if' interpreted as…" + "Unexpected block in infix position (two terms in a row)"

[01:46] <thilp> with my $a = if 1 { 2 } else { 3 } I mean

[01:47] <thilp> with perl6-m for the last error message*

[01:48] <thilp> this is 1c1a085 on branch nom, no doubts…

[01:48] <skids> Does "do if" work?

[01:49] <thilp> yes it does, with both :)

[01:50] <thilp> I know this is bad syntax, but the error messages seem buggy

[01:50] <skids> star gives the "Word if" error message, but not in an infinite loop.

[01:51] <skids> star: my $a = do if 1 { 2 } else { 3 }; $a.say

[01:51] <thilp> star is on parrot, right? And yet I got a PMC… Could this be something local?

[01:51] <camelia> star 2013-09: OUTPUT«2␤»

[01:51] <skids> Yes.

[01:52] <skids> wait 2013-09?

[01:52] <thilp> I --gen'd nqp and parrot and moar in Configure.pl…

[01:54] *** kurahaupo left
[01:56] <thilp> will investigate later with a fresh star, thanks

[02:02] *** jnap joined
[02:06] *** jnap left
[02:09] <dalek> perl6-roast-data: df86307 | coke++ | / (4 files):

[02:09] <dalek> perl6-roast-data: today (automated commit)

[02:09] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/df86307706

[02:25] *** xragnar left
[02:27] *** xragnar joined
[02:30] <raiph> S11: "OVERVIEW: This synopsis discusses those portions of Apocalypse 12 that ought to have been in Apocalypse 11."

[02:43] *** hoverboard joined
[02:44] *** bjz left
[02:45] *** bjz joined
[02:45] *** klapperl joined
[02:46] *** raiph left
[02:48] *** klapperl_ left
[02:51] *** FROGGS_ joined
[02:52] *** Sqirrel left
[02:54] *** Sqirrel joined
[02:54] *** FROGGS left
[02:57] *** thou left
[03:02] *** jnap joined
[03:07] *** jnap left
[04:00] *** BenGoldberg left
[04:02] *** araujo left
[04:03] *** jnap joined
[04:07] *** jnap left
[04:10] *** hoverboard left
[04:20] *** hoverboard joined
[04:48] *** ggoebel11117 joined
[04:58] *** rurban1 joined
[05:02] *** rurban2 joined
[05:02] *** telex left
[05:03] *** rurban1 left
[05:04] *** jnap joined
[05:04] *** telex joined
[05:07] *** kaare__ joined
[05:08] *** jnap left
[05:19] *** xenoterracide joined
[05:22] *** cibs joined
[05:47] *** Mouq joined
[05:57] *** daniel-s left
[05:57] *** daniel-s joined
[05:58] *** xinming_ left
[06:01] <Mouq> r: say "abcd" ne "abcd" ne "efg"

[06:01] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«False␤»

[06:01] <Mouq> r: say "abcd" ne "abcd" ne "abcd"

[06:01] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«False␤»

[06:01] <Mouq> Aww

[06:02] <Mouq> r: say [ne] "abcd", "abcd", "abcd"

[06:02] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«False␤»

[06:02] * Mouq is spoiled by chaining comparators

[06:02] <Mouq> r: say set "abcd", "abcd", "abcd"

[06:02] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«set(abcd)␤»

[06:02] <Mouq> r: say +set "abcd", "abcd", "abcd"

[06:02] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1␤»

[06:02] <Mouq> That works though

[06:05] *** jnap joined
[06:07] *** logie_ left
[06:09] *** jnap left
[06:10] *** logie_ joined
[06:10] <Mouq> r: say (1,2,3,4).sort

[06:10] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1 2 3 4␤»

[06:10] <Mouq> r: say ([1,42],[2,24],[3,56],[4,44]).sort(*.[0])

[06:10] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1 42 2 24 3 56 4 44␤»

[06:11] <Mouq> r: say ((1,42),(2,24),(3,56),(4,44)).sort(*.[0])

[06:11] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1 42 3 56 4 44 2 24␤»

[06:11] <Mouq> r: say ((1,42),(4,44),(2,24),(3,56)).sort(*.[0])

[06:11] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1 42 2 24 4 44 3 56␤»

[06:11] <Mouq> ...

[06:11] <Mouq> what?

[06:12] <Mouq> r: say ((1,42),(4,44),(2,24),(3,56)).sort({$^v.say;$^v[0])

[06:12] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Unable to parse expression in block; couldn't find final '}' ␤at /tmp/tmpfile:1␤------> [32m,44),(2,24),(3,56)).sort({$^v.say;$^v[0][33m⏏[…»

[06:12] <Mouq> r: say ((1,42),(4,44),(2,24),(3,56)).sort({$^v.say;$^v[0]})

[06:12] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1␤42␤4␤44␤2␤24␤3␤56␤1 42 2 24 4 44 3 56␤»

[06:12] <Mouq> r: say ([1,42],[4,44],[2,24],[3,56]).sort({$^v.say;$^v[0]})

[06:12] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1 42␤4 44␤2 24␤3 56␤1 42 2 24 3 56 4 44␤»

[06:13] <Mouq> r: say (my$=42)[0]

[06:13] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«42␤»

[06:13] <Mouq> r: say ((1,42),(4,44),(2,24),(3,56)).sort({$^v[0].say;$^v[0]})

[06:13] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«1␤42␤4␤44␤2␤24␤3␤56␤1 42 2 24 4 44 3 56␤»

[06:15] <dalek> roast: 16020ff | Mouq++ | S (3 files):

[06:15] <dalek> roast: Some updates and fudges for JVM

[06:15] <dalek> roast: review: https://github.com/perl6/roast/commit/16020ff0e9

[06:15] * Mouq isn't sure what's going on with baghash.t and mixhash.t

[06:19] *** rurban2 left
[06:19] *** kaare__ left
[06:21] *** cibs left
[06:35] *** xenoterracide left
[06:40] <dalek> roast: 8a6c445 | Mouq++ | S02-lexical-conventions/comments.t:

[06:40] <dalek> roast: Unfudge test that passes on all rakudo backends

[06:40] <dalek> roast: review: https://github.com/perl6/roast/commit/8a6c445e27

[06:44] *** daniel-s left
[06:45] *** daniel-s joined
[06:52] *** xenoterracide joined
[06:57] *** Mouq left
[06:58] *** vincent22 joined
[07:03] *** logie_ left
[07:05] *** jnap joined
[07:08] <moritz> \o

[07:08] <nwc10> o/

[07:09] *** anna joined
[07:09] *** anna is now known as Guest66412

[07:10] *** jnap left
[07:13] *** hoverboard left
[07:19] *** Guest66412 is now known as anna_

[07:20] *** rurban1 joined
[07:21] <Timbus> <Mouq> r: say "abcd" ne "abcd" ne "abcd"

[07:21] <Timbus> huh.. did he want that to.. not chain

[07:22] <Timbus> r: say <asdf asdf asdf>.reduce(&infix:<ne>) #does this work

[07:22] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«True␤»

[07:24] <Timbus> .. why didnt i just use (* ne *) =\

[07:24] *** rurban1 left
[07:47] *** arnsholt joined
[07:49] *** [Sno] left
[07:53] *** xenoterracide left
[07:55] *** virtualsue joined
[07:55] *** molaf joined
[07:57] *** aindilis joined
[08:06] *** jnap joined
[08:10] *** jnap left
[08:20] *** rurban1 joined
[08:22] *** dmol joined
[08:23] *** anna_ left
[08:25] *** rurban1 left
[08:26] *** virtualsue left
[08:37] *** anna joined
[08:37] *** anna is now known as Guest4885

[08:45] *** darutoko joined
[08:58] <colomon> dagurval_: Time::Duration is failing my smoke tests.  Two nights in a row now...

[09:00] *** SamuraiJack_ joined
[09:01] *** Guest4885 left
[09:06] *** cibs joined
[09:07] *** arnsholt left
[09:07] *** jnap joined
[09:11] *** jnap left
[09:13] <sergot> morning o/

[09:15] <masak> good antenoon, #perl6

[09:16] <masak> r: say <asdf asdf asdf>.reduce( (* ne *) )

[09:16] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«True␤»

[09:16] <masak> I'm not sure (* ne *) chains the way &infix:<ne> does.

[09:17] <masak> trying to think up a chain of three values that would show that.

[09:18] <masak> oh, wait.

[09:19] <masak> <asdf asdf asdf> should've come out False if either of them chained.

[09:19] <masak> ...so they don't, I guess.

[09:20] *** FROGGS_ is now known as FROGGS

[09:20] <FROGGS> morning

[09:21] *** rurban1 joined
[09:22] <xfix> https://github.com/masak/markdown/blob/master/lib/Text/Markdown.pm#L29

[09:22] <xfix> I love magic.

[09:22] <xfix> Anyway, any idea how to match indents, like in CoffeeScript or Python using Perl 6 grammars?

[09:25] <masak> xfix: arnsholt++ has worked out a good answer to that.

[09:25] <masak> xfix: I think it deserves a blog post, actually. stand by for that. not today, but soon.

[09:25] <masak> xfix: it involves contextual variables, that's all I know.

[09:26] *** rurban1 left
[09:26] <masak> xfix: that table was actually lifted wholesale from the original Markdown program, IIRC.

[09:26] <masak> xfix: but I think I shouldn't be looking so much at what the original program does internally. I should just re-create the outwards semantics.

[09:27] <xfix> I was hoping that Markdown would help me, but not really.

[09:27] <xfix> It doesn't even support more complex parts of Markdown, such as code blocks.

[09:27] <masak> yeah :/

[09:27] <masak> would like to work on it more, but... tuits.

[09:27] <masak> xfix: pmichaud has also solved the indentation problem once, and could probably give a good explanation. but he's not often here.

[09:28] <xfix> YAML module only outputs YAML.

[09:28] <xfix> So YAML module isn't of help either.

[09:29] <masak> let me see if I can figure it out in a 5-minute coding session.

[09:29] <xfix> Thanks.

[09:30] *** Guest4885 joined
[09:30] <xfix> Contextual variables... could be helpful, I guess.

[09:39] *** brrt joined
[09:40] *** Sqirrel left
[09:43] <masak> ok, I have a prototype working. it gave me some insights.

[09:44] <masak> https://gist.github.com/masak/9703867

[09:44] <masak> but I realize that the above isn't going far enough.

[09:44] *** Guest4885 left
[09:44] <masak> what we want is for the parser to divide things into "blocks".

[09:45] <masak> each block consists of a sequence of simple strings (lines), or other blocks.

[09:45] * masak codes up that solution

[09:57] *** FROGGS[mobile] joined
[10:03] *** brrt left
[10:07] *** denis_boyun joined
[10:08] *** jnap joined
[10:12] *** jnap left
[10:20] *** SamuraiJack_ left
[10:20] <masak> ok, I think I have a fully functional solution now.

[10:20] *** rindolf joined
[10:22] <masak> xfix: https://gist.github.com/masak/9703867

[10:22] *** rurban1 joined
[10:22] *** Alula joined
[10:26] *** rurban1 left
[10:28] <masak> so, yeah, I guess that's how you do it :)

[10:28] <masak> dang, now I probably have to apply that to arnsholt++'s Python project :P

[10:29] *** spider-mario joined
[10:32] <JimmyZ> :P

[10:33] <masak> I keep coming up with fixes and simplifications, too.

[10:33] *** NATANaYELL joined
[10:33] <masak> now I eliminated the $*INDENT variable. only @*SUITES left.

[10:33] <masak> verra nice.

[10:45] *** virtualsue joined
[10:48] <masak> added two more error conditions.

[10:49] <masak> heh, "five minutes" :P

[10:52] *** denis_boyun left
[10:55] *** Rotwang joined
[11:03] <masak> I'll really really try to write this up. it was an interesting exercise.

[11:04] <masak> but in short, learnings on the way:

[11:04] <masak> (a) contextuals are a really good fit for this

[11:04] <masak> (b) TDD rocks when developing a grammar -- especially when remembering to test for all the error conditions

[11:05] <masak> (c) the 'handles' keyword rocks

[11:06] *** Rotwang left
[11:06] *** NATANaYELL left
[11:06] *** Rotwang joined
[11:08] *** jnap joined
[11:13] *** jnap left
[11:14] *** virtualsue left
[11:17] *** arnsholt joined
[11:17] <arnsholt> o/

[11:17] <dalek> nqp/jastcompiler: 99ca7b8 | (Arne Skjærholt)++ | src/vm/jvm/runtime/org/perl6/nqp/jast2bc/J (4 files):

[11:17] <dalek> nqp/jastcompiler: Remove dependence of JASTCompiler on static caches.

[11:17] <dalek> nqp/jastcompiler: 

[11:17] <dalek> nqp/jastcompiler: First attempt at this attached static caches of the various JAST::Node type

[11:17] <dalek> nqp/jastcompiler: objects in the compiler class, which caused failures under the evalserver, as

[11:17] <dalek> nqp/jastcompiler: the type objects form the first compile would be reused for all subsequent

[11:17] <dalek> nqp/jastcompiler: compiles. Now, we only cache the type objects per compilation.

[11:17] <dalek> nqp/jastcompiler: 

[11:17] <dalek> nqp/jastcompiler: The Rakudo sanity tests now pass.

[11:17] <dalek> nqp/jastcompiler: review: https://github.com/perl6/nqp/commit/99ca7b8a14

[11:18] <masak> arnsholt: https://gist.github.com/masak/9703867

[11:18] <masak> arnsholt: I... think I know what my first contribution to snake will be :)

[11:19] <arnsholt> \o/

[11:20] <arnsholt> That's awesome!

[11:20] <masak> btw, if I were allowed to bikeshed the project name: 'snake' is fine, but 'serpentine' or 'slytherin' would be funnier :>

[11:21] <masak> also, people won't confuse it with a https://en.wikipedia.org/wiki/Snake_(video_game) implementation

[11:23] *** rurban1 joined
[11:24] *** rurban2 joined
[11:25] *** arnsholt left
[11:27] *** rurban1 left
[11:27] <FROGGS> btw, I would have called it Parsel instead of snake :o)

[11:28] <masak> oh, that works too :)

[11:28] <masak> anything which *hints* at the connection between Python and snakes is funnier than something which states it outright.

[11:29] *** rurban2 left
[11:35] <FROGGS> masak: I just like the quote: "Parsel, Harry. Snake language?"

[11:35] <FROGGS> masak: ahh btw, do you have slides of a talk you thing worked out very well?

[11:35] <FROGGS> I need to prepare my talks for the gpw, and it would be nice to steal some ideas :o)

[11:36] <masak> FROGGS: I have quite a number of slides here: http://feather.perl6.nl/~masak/

[11:36] <FROGGS> masak: which is the best? :o)

[11:36] <FROGGS> which one*

[11:36] <masak> FROGGS: things tend to work out the best when I follow https://en.wikipedia.org/wiki/Takahashi_method , have adequate time to prepare, and have nice images.

[11:36] <masak> FROGGS: hm.

[11:37] <FROGGS> hmmm

[11:37] <masak> objectively, http://www.perlworkshop.no/npw2009/talk/1734 worked out the best.

[11:37] <masak> but I have no idea why. :) it was just popular. maybe right things to the right audience.

[11:38] <FROGGS> k, thank you :o)

[11:39] <FROGGS> I enjoyed mst++'s talks, which use this method very well it seems

[11:39] <FROGGS> but his talk was some kind of rant, and my talks are nothing like that

[11:43] <masak> well, they don't have to be rants.

[11:43] <masak> that said, don't underestimate the power of taking a strongly negatice stance on *something*.

[11:44] <FROGGS> yeah I know, but this feels very difficult to do for me...

[11:44] <masak> people react better to strong feelings, and ranting seems to be the easiest way for a beginner to do well at talks :)

[11:44] *** pecastro joined
[11:44] <masak> though more generally, showing that you're passionate about something is the important bit

[11:52] <FROGGS> okay, perhaps it would work out... at least it seems kind of possible now that I look at my slides from YAPC::NA 2013

[11:53] *** Sqirrel joined
[11:55] <FROGGS> masak: my talks will be in german, do you think it is feasible to have these large words in german and at the bottom like english sentences?

[11:56] <simula67> cosimo: What do you think ? https://github.com/cosimo/perl6-lwp-simple/pull/27

[11:58] <vendethiel> r: given 301 { when 301 | 302 { say "hello, i'm a turtle"; } }

[11:58] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«hello, i'm a turtle␤»

[11:59] <vendethiel> not why is https://github.com/cosimo/perl6-lwp-simple/blob/master/lib/LWP/Simple.pm#L85 using regexps

[12:04] <masak> vendethiel: dunno, but the semantics is a little different.

[12:04] <masak> vendethiel: the regexp is essentially an .index operation, looking for a substring.

[12:09] *** jnap joined
[12:13] *** arnsholt joined
[12:13] <arnsholt> And hello again

[12:13] <arnsholt> masak: Sorry for disappearing. Train Wifi isn't terribly reliable =)

[12:14] *** jnap left
[12:14] <arnsholt> I'm not at all committed to a name at this point, either

[12:14] <arnsholt> Many good suggestions in the backlog

[12:22] <tadzik> http://cudl.lib.cam.ac.uk/view/MS-ADD-04000/28 this is awesome

[12:22] <tadzik> Isaac Newton's college notebook

[12:22] <tadzik> 450 years old

[12:23] <tadzik> er, 350, more like

[12:25] *** rurban1 joined
[12:26] *** arnsholt left
[12:26] <colomon> r: 2014 - 1664

[12:26] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: ( no output )

[12:26] <colomon> r: say 2014 - 1664

[12:26] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32msay 2014 - 16[33m⏏[31m64[0m␤    expecting any of:␤        postfix␤        infix s…»

[12:27] <colomon> r: say 2014 - 1664

[12:27] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«350␤»

[12:30] *** rurban1 left
[12:37] * colomon is not sure why his brain thought 450 years, but is somewhat relieved that tadzik made the same mistake.

[12:49] *** myfree joined
[12:52] <FROGGS> my $dbh = ...; my @rows = -> 'Carl%' { use SQL:$dbh; SELECT * FROM foo WHERE name LIKE ? } # '?' is a placeholder valiable here

[12:52] <FROGGS> how useful would be this kind of thing?

[12:53] <moritz> it'd be a PITA, because $dbh would need to be available at compile time

[12:54] <FROGGS> I guess the most useful aspect is that it would die at compile time when there is a syntax error in the sql statement

[12:54] <FROGGS> true

[12:54] <moritz> also, IMHO there should still be some form of delimiter

[12:54] <moritz> but, what kind of SQL are you talking about?

[12:54] <FROGGS> well, it could also just compile to a call that will run later

[12:55] <FROGGS> I just know about mysql

[12:55] <moritz> mysql is not the only kind of sql

[12:55] <moritz> and every dialect has a slightly different syntax

[12:55] <FROGGS> moritz: this is just about a slide for my talk, nothing I would implement right away

[12:55] *** myfree left
[12:57] *** kurahaupo joined
[12:57] *** ClarusCogitatio left
[12:58] <FROGGS> I try to find some examples of slangs that are not about programming languages, but about other things that turn text into either a structure or into something that does something :o)

[12:58] <moritz> FROGGS: it's the kind of idea that looks very cute, but is full of conceptual problems

[12:58] <moritz> (with SQL)

[12:58] <FROGGS> yeah, probably

[13:00] *** ClarusCogitatio joined
[13:00] *** jnap joined
[13:01] *** Mouq joined
[13:01] <Mouq> Timbus: Oh, I was reading what I was doing wrong. Thanks :)

[13:06] *** ClarusCogitatio left
[13:07] *** ClarusCogitatio joined
[13:12] <spider-mario> rakudo.org/downloads does not contain nqp 2014.03

[13:12] <FROGGS> lol: http://www.archaicbinary.net/wp-content/uploads/Syntax-Error.jpg

[13:12] <FROGGS> tadzik: ping

[13:15] <tadzik> FROGGS: pong

[13:15] <tadzik> spider-mario: http://rakudo.org/downloads/rakudo/ does

[13:15] <FROGGS> tadzik: unping then :o)

[13:16] <Mouq> Should we still upload nqp to http://rakudo.org/downloads/nqp/?

[13:16] <tadzik> unrelated: http://i.imgur.com/iEXc9t5.gif

[13:16] <Mouq> *n't

[13:16] <FROGGS> tadzik: there is no nqp

[13:16] <spider-mario> only rakudo, though, not nqp?

[13:17] <tadzik> :o

[13:17] <tadzik> troo

[13:17] <tadzik> 'tis true

[13:19] <masak> FROGGS: I want to flick this post your way: http://zachholman.com/posts/slide-design-for-developers/

[13:19] <Mouq> arnsholt++ # JASTCompiler branch :D

[13:19] <masak> FROGGS: I dunno, I just vibe very much with what's written in it.

[13:21] <tadzik> if somebody can quick-fix this, I'd be delighted, I have to run soon

[13:22] <masak> colomon, tadzik: here's why you both made the 450 mistake: subtraction kind of contains a built-in off-by-one error.

[13:22] <tadzik> yep :)

[13:22] <masak> the brain looks at 20xx and 16xx and thinks "oh, that's four centuries in between [and maybe some years more]"

[13:22] <masak> and so it's much more likely to go 400 + 50 than 400 - 50.

[13:23] <FROGGS> masak: thanks a lot! that looks very nice indeed :o)

[13:23] <masak> the best remedy for the off-by-one in subtraction is to *never do subtraction* :)

[13:23] <masak> which is less ridiculous than it sounds, because addition and subtraction can be defined in terms of each other.

[13:23] <masak> notice how for example clerks always do this when they give you change back.

[13:24] <masak> if you're to pay 650 and give them a 1000, they give you change back by adding 650 + 100 + 100 + 100 + 50 == 1000.

[13:25] <FROGGS> but then you don't care about the sum of the exchange

[13:26] *** rurban1 joined
[13:27] <masak> the sum is 1000. you care about giving enough change to reach that sum.

[13:28] <masak> all I'm saying really is that Z - Y == X and X + Y == Z are equivalent statements, but that humans are better equipped to do the latter.

[13:31] *** rurban1 left
[13:31] <FROGGS> that is true, yes

[13:32] <FROGGS> but if you want to know the difference, adding stuff to the smaller number and sum these additions is not better than doing subtractions

[13:32] <FROGGS> (might be just because HT is not turned on for my brane)

[13:34] <masak> yes, it *is* better, and that's my point.

[13:34] <masak> the brain is less likely to stumble on the off-by-one when carrying over a ten during the addition than during the subtraction.

[13:35] <masak> equivalently, you're much less likely to do the 650 + 450 != 1000 mistake than you are doing the 1000 - 650 != 450 mistake.

[13:35] *** VINU joined
[13:36] <FROGGS> hmm, yeah, I think you are right

[13:39] <masak> mental arithmetic is full of those little tricks. I loved learning them when I was younger.

[13:40] *** VINU left
[13:42] *** wooden joined
[13:42] *** wooden left
[13:42] *** wooden joined
[13:52] <FROGGS> .u check

[13:52] <yoleaux> U+237B NOT CHECK MARK [So] (⍻)

[13:52] <yoleaux> U+2447 OCR AMOUNT OF CHECK [So] (⑇)

[13:52] <yoleaux> U+2611 BALLOT BOX WITH CHECK [So] (☑)

[13:55] <timotimo> o/

[13:57] <FROGGS> hi timotimo 

[13:57] <Mouq> r: say ($_,.chr,.&uniname) if .chr.&uniname ~~ /CHECK/ for 0..0xffff

[13:58] <camelia> rakudo-moar 1c1a08: OUTPUT«9083 ⍻ NOT CHECK MARK␤9287 ⑇ OCR AMOUNT OF CHECK␤9745 ☑ BALLOT BOX WITH CHECK␤9989 ✅ WHITE HEAVY CHECK MARK␤10003 ✓ CHECK MARK␤10004 ✔ HEAVY CHECK MARK␤»

[13:58] <camelia> ..rakudo-jvm 1c1a08: OUTPUT«uniname NYI on jvm backend␤  in sub uniname at gen/jvm/CORE.setting:6768␤  in sub uniname at gen/jvm/CORE.setting:6768␤  in block  at /tmp/tmpfile:1␤␤»

[13:58] <camelia> ..rakudo-parrot 1c1a08: OUTPUT«uniname NYI on parrot backend␤  in sub uniname at gen/parrot/CORE.setting:6772␤  in sub uniname at gen/parrot/CORE.setting:6772␤  in block  at /tmp/tmpfile:1␤␤»

[13:58] <timotimo> i don't yet have an idea what to hack on during the GPW if i get time to hackathonize ...

[13:58] <timotimo> https://sphere.chronosempire.org.uk/~HEx/8402/ - someone made this thing!

[13:58] <FROGGS> Mouq++ # that contains the one I was looking for! :o)

[14:03] *** salv0 left
[14:03] *** sunnavy left
[14:05] *** Tene joined
[14:05] *** Tene left
[14:05] *** Tene joined
[14:06] *** zamolxes joined
[14:06] *** apejens joined
[14:06] *** PerlJam joined
[14:06] *** ashleydev joined
[14:07] *** larks joined
[14:07] *** sjn joined
[14:07] *** anocelot joined
[14:07] *** sunnavy joined
[14:07] *** ruoso joined
[14:07] *** sjohnson joined
[14:07] *** Yappo__________8 joined
[14:07] *** takesako____ joined
[14:07] *** djanatyn joined
[14:07] *** masak joined
[14:08] *** awwaiid joined
[14:08] *** felher joined
[14:08] *** segomos joined
[14:08] *** amkrankruleuen joined
[14:08] *** amkrankruleuen left
[14:08] *** amkrankruleuen joined
[14:08] *** clkao joined
[14:09] *** gfldex joined
[14:09] *** yeltzooo joined
[14:09] *** Gothmog_ joined
[14:09] *** mattp_ joined
[14:09] *** dalek joined
[14:09] *** ChanServ sets mode: +v dalek

[14:09] *** integral joined
[14:09] *** jnthn joined
[14:09] *** frettled joined
[14:09] *** salv0 joined
[14:09] *** woolfy joined
[14:09] *** silug____ joined
[14:09] *** integral left
[14:09] *** integral joined
[14:10] *** xybre joined
[14:10] <masak> netsplit: *sigh*, you.

[14:10] *** bonsaikitten joined
[14:10] *** ivan`` joined
[14:10] *** go|dfish joined
[14:10] <timotimo> oh, you

[14:10] *** labster joined
[14:11] *** eternaleye joined
[14:11] *** hugme joined
[14:11] *** ChanServ sets mode: +v hugme

[14:11] *** lestrrat joined
[14:11] <timotimo> that was a rather short netsplit, though

[14:12] *** camelia joined
[14:12] *** Rotwang left
[14:12] *** FrankG joined
[14:12] *** LordV joined
[14:12] <masak> "could be worse. could be raining."

[14:12] *** huf joined
[14:12] *** jnap left
[14:12] *** ChanServ sets mode: +v camelia

[14:13] *** dagurval joined
[14:13] *** ponbiki joined
[14:13] *** ponbiki is now known as Guest97287

[14:13] *** sergot_ joined
[14:13] <FrankG> Hello, I am learning Perl 6, could you suggest where I can sample code demonstrating usage of "callable"?

[14:14] *** FROGGS left
[14:14] <Mouq> r: my &callable = -> 

[14:14] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Malformed parameter␤at /tmp/tmpfile:1␤------> [32mmy &callable = ->[33m⏏[31m<EOL>[0m␤    expecting any of:␤        infix noun␤     …»

[14:14] <Mouq> Ooops

[14:14] <Mouq> r: my &callable = ->{say "like this?"}; callable

[14:14] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«like this?␤»

[14:14] <Mouq> r: my &callable = ->{say "like this?"}; callable for 1..15

[14:14] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤like this?␤»

[14:14] *** FROGGS joined
[14:14] <Mouq> FrankG: What do you mean, exactly?

[14:14] *** klapperl_ joined
[14:14] <skids> r: sub a { }; &a.^roles.say # or like this?

[14:14] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«(Callable)␤»

[14:14] <masak> FrankG: Callable is just a type for things that can be called with .()

[14:14] <masak> r: sub x {}; say x ~~ Callable

[14:14] *** Timbus left
[14:15] *** Khisanth left
[14:15] <colomon> m: say ($_,.chr,.uniname) if .chr.uniname ~~ /CHECK/ for 0..0xffff

[14:15] *** Alina-malina left
[14:15] *** sergot left
[14:15] *** klapperl left
[14:16] <camelia> rakudo-parrot 1c1a08: OUTPUT«use of uninitialized value of type Callable in string context  in any  at gen/parrot/Metamodel.nqp:1481␤␤Too many positional parameters passed; got 1 but expected 0␤  in sub x at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[14:16] <camelia> ..rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«use of uninitialized value of type Callable in string context␤Too many positional parameters passed; got 1 but expected 0␤  in sub x at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[14:16] <masak> r: sub x {}; say &x ~~ Callable

[14:16] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«True␤»

[14:16] <masak> r: say { "Block of code" } ~~ Callable

[14:16] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«True␤»

[14:16] <FROGGS> m: say (-> { 42 }) ~~ Callable

[14:16] <camelia> rakudo-moar 1c1a08: OUTPUT«True␤»

[14:16] *** Timbus_ joined
[14:16] <masak> r: say "Just a string, not callable" ~~ Callable

[14:16] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«False␤»

[14:16] *** Khisanth joined
[14:16] <camelia> rakudo-moar 1c1a08: OUTPUT«No such method 'uniname' for invocant of type 'Str'␤  in block  at /tmp/L5RfygAxbp:1␤␤»

[14:16] <FrankG> I was fascinated by how expressive Perl6 is, reading the code of "OddWord".

[14:16] <FROGGS> m: say (sub foo { }).^mro

[14:16] <camelia> rakudo-moar 1c1a08: OUTPUT«(Sub) (Routine) (Block) (Code) (Any) (Mu)␤»

[14:16] <masak> FrankG: :)

[14:16] <masak> FrankG: rosetta code?

[14:16] *** BitPuffin left
[14:16] <FrankG> it reads: my &in = { $*IN.getc // last };

[14:16] <masak> TimToady++'s plan is working! \o/

[14:17] <masak> http://rosettacode.org/wiki/Odd_word_problem#Perl_6

[14:17] *** BitPuffin joined
[14:17] <FrankG> is & a sigil for callable?

[14:17] <FROGGS> yes

[14:17] *** Alina-malina joined
[14:17] <FROGGS> though, mostly the & is omitted

[14:18] <FROGGS> but to make it clear that a variable contains something callable, you can use the & sigil

[14:18] <FrankG> and how is the input from stdin magically converted to a block, and assign to a callable?

[14:18] <masak> TimToady: Randall Schwartz would glare at you for `ow(in) x .print`. twice. :)

[14:18] <FROGGS> FrankG: no, &in is just like a subroutine, when you call it, it will execute the stuff in the block

[14:19] <masak> FrankG: the first line merely says "this is how you do input"

[14:19] <FROGGS> yeah, a declaration

[14:19] <masak> FrankG: it's declaring a callable thing that reads a line or exits the loop if there is no more input.

[14:19] <FrankG> like closure?

[14:19] <masak> yeah.

[14:19] <masak> then the other occurrectes of 'in' are calls.

[14:20] <FROGGS> m: my &thing = { say 42 }

[14:20] <camelia> rakudo-moar 1c1a08: ( no output )

[14:20] <FROGGS> m: my &thing = { say 42 }; &thing()

[14:20] <camelia> rakudo-moar 1c1a08: OUTPUT«42␤»

[14:20] *** virtualsue joined
[14:20] <masak> s/line/character/

[14:21] <FrankG> in that case, & is used to be a reference to subroutine, how is it related to callable?

[14:21] <Mouq> FrankG: In this case, it's just another way to say "sub in () { $*IN.getc // last }"

[14:22] <Mouq> But because it's declared as a variable, &in is reassignable and has lexical scope

[14:22] <Mouq> *declared as a 'my' variable

[14:23] <masak> FrankG: @ is for Positional (like arrays), % is for Associative (like hashes), & is for Callable (like subs)

[14:23] <Mouq> m: my &not-callable = 1; not-callable

[14:23] <camelia> rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/1m9hkeMAqS␤Undeclared routine:␤    callable used at line 1. Did you mean 'callsame'?␤␤»

[14:23] <Mouq> Erm

[14:23] <Mouq> m: my &not_callable = 1; not_callable

[14:23] <camelia> rakudo-moar 1c1a08: OUTPUT«Type check failed in assignment to '&not_callable'; expected 'Callable' but got 'Int'␤  in block  at /tmp/R4e5DMNn02:1␤␤»

[14:24] <masak> Mouq: type check failed in *assignment*.

[14:24] <masak> m: my &not_callable = 1

[14:24] <camelia> rakudo-moar 1c1a08: OUTPUT«Type check failed in assignment to '&not_callable'; expected 'Callable' but got 'Int'␤  in block  at /tmp/EDDqVu8CET:1␤␤»

[14:24] <Mouq> m: my &not_callable = 1 but Callable; not_callable

[14:24] <camelia> rakudo-moar 1c1a08: OUTPUT«Cannot find method 'postcircumfix:<( )>'␤  in block  at /tmp/BMDlTiiKJt:1␤␤»

[14:24] <Mouq> :P

[14:24] <FrankG> yeah, I got it, very helpful, Thanks so much, 

[14:29] <masak> m: my &fake_callable = 1 but role :: does Callable { method postcircumfix:<( )>($) { say "mwhaha!" } }; fake_callable

[14:29] <camelia> rakudo-moar 1c1a08: OUTPUT«mwhaha!␤»

[14:29] <masak> :D

[14:30] <Timbus_> aaaaaaAAAA

[14:30] <masak> today's evil code!

[14:30] * Timbus_ tries to stuff the worms back in the can

[14:30] <FROGGS> hmmm, stuffed worms

[14:31] <Mouq> m: my &fake_callable = 42 but role :: does Callable { method postcircumfix:<( )>($) { say "mwhaha!" } }; say &fake_callable

[14:31] <camelia> rakudo-moar 1c1a08: OUTPUT«42␤»

[14:31] <Mouq> :)

[14:34] <timotimo> how can you live with yourself? :)

[14:35] <Timbus_> guess he found a meaning

[14:35] <masak> I don't do evil, I merely provide it to others as educational examples.

[14:35] <masak> in short, I sleep pretty well at night. :)

[14:35] *** Timbus_ is now known as Timbus

[14:36] <timotimo> :3

[14:39] *** daniel-s left
[14:39] *** rurban1 joined
[14:46] <masak> is there a corpus somewhere of all the URLs linked on HN, ever, along with their discussion threads?

[14:46] <masak> relatedly, has someone ever created "find HN discussion thread for this URL or domain name" as a service? :)

[14:50] <timotimo> HNaaS?

[14:52] * Mouq beat https://sphere.chronosempire.org.uk/~HEx/8402/! o/

[14:52] <masak> timotimo: more like *reverse* HNaaS.

[14:52] *** molaf left
[14:54] <skids> Mouq: now you just have to loop the game around so people are playing PvP without knowing it.

[14:55] <Mouq> skids: That's what I was hoping the "AI" was when I first opened the page, but alas

[14:57] <vendethiel> Mouq++, masak++ # evil geniuses

[14:57] <Mouq> masak: https://hn.algolia.com/api?

[14:57] <Mouq> https://hn.algolia.com/api/v1/search?url=X

[14:57] <Mouq> Maybe?

[14:57] <Mouq> Nope

[15:00] *** ClarusCogitatio left
[15:00] *** ClarusCogitatio joined
[15:05] <vendethiel> I often forget last and others are dynamically scoped in perl 6. I like it.

[15:06] <masak> it's the more general form, and therefore something Perl 6 would naturally do. :)

[15:06] *** jnap joined
[15:06] <masak> that said, a smart-enough compiler should cheat as much as it could, and reduce all dynamic exception-mediated control flow to static jumps.

[15:07] <vendethiel> though you can simulate that behavior in any language that has *at least* one dynamic jump (like exception)

[15:08] <vendethiel> most languages have them (break, continue) lexically scoped

[15:09] <masak> well, lexically scoped is the "sane" option.

[15:10] <dalek> specs: eb7c5b3 | (Elizabeth Mattijsen)++ | S22-package-format.pod:

[15:10] <dalek> specs: Wave some hands about bundles

[15:10] <dalek> specs: review: https://github.com/perl6/specs/commit/eb7c5b373a

[15:10] <masak> easy to explain, implement, and debug.

[15:10] * masak waves some hands to lizmat :)

[15:10] <vendethiel> masak: though I believe that's "easy to explain" because people are used to it

[15:10] * lizmat waves back at masak and the rest of #perl6

[15:10] <vendethiel> (which is true for most features)

[15:11] * vendethiel waves at #perl6 and the rest of lizmat

[15:11] *** jnap left
[15:11] *** xenoterracide joined
[15:11] <masak> vendethiel: you don't consider the lexical variant inherently conceptually simpler? I do.

[15:11] *** kaare__ joined
[15:12] *** virtualsue left
[15:12] <vendethiel> masak: I think it makes one less concept to explain if you have to explain exceptions after/before

[15:12] <vendethiel> that's probably easier to keep *track of*, but not to understand

[15:12] *** logie_ joined
[15:14] <masak> exceptions or no exceptions, with lexical scoping the behavior comes down to "you can only next/last/redo within the textual boundaries of the loop".

[15:14] <masak> with dynamic scoping it comes down to "you can only next/last/redo within the (dynamic) life time of the loop itself"

[15:14] <vendethiel> or just "you can only next/last/redo within a loop"

[15:15] <masak> that could describe both, and is not precise enough.

[15:15] <vendethiel> we should have an experiment -- would person that get the explanation "you can only next/last/redo within a loop"

[15:15] <masak> I dunno, I just find textual boundaries easier to think about.

[15:15] <vendethiel> without prior experience in programming

[15:15] <vendethiel> and see if they understand the "within" as lexical or dynamic :). Though I'd think they'd understand lexical, because you see it

[15:16] <masak> right, that's what I mean.

[15:16] <masak> "within" sounds like a spatial restriction.

[15:16] <masak> whereas the temporal restriction of dynamic lookup is a bit less obvious.

[15:16] <vendethiel> "while a loop is running", maybe

[15:17] <vendethiel> but then it's a bit harder to grasp, I guess ...

[15:18] <masak> that covers it better, yes.

[15:19] *** xenoterracide left
[15:23] *** kurahaupo left
[15:25] <vendethiel> masak: WRT TimToady++'s plan, what would be the best perl6 examples you'd recommend to interest somebody ?

[15:25] <vendethiel> I linked him the same example as FrankG and he seemed interested

[15:26] *** aborazmeh joined
[15:30] *** xenoterracide joined
[15:31] <masak> vendethiel: I don't have a good enough overview of RC to answer that...

[15:31] <masak> vendethiel: I think grondilu has edited RC quite a lot. maybe ask him.

[15:31] <masak> &

[15:32] *** raiph joined
[15:37] *** xenoterracide left
[15:38] *** logie_ left
[15:44] *** FROGGS[mobile] left
[15:48] *** xenoterracide joined
[15:48] *** vincent22 left
[15:52] * Mouq debates where to put his tuits

[16:00] *** xenoterracide left
[16:00] *** jnap joined
[16:04] *** jnap left
[16:08] *** yogan joined
[16:09] <vendethiel> I'll wait for grondilu to be back then :)

[16:10] *** xenoterracide joined
[16:14] *** aborazmeh left
[16:23] <masak> might want to consult TimToady++ for nice examples as well.

[16:24] <masak> he wrote a bunch of them :)

[16:25] <xfix> Is it possible to stringify macro argument?

[16:25] <FROGGS> I guess that really depends in what one is interested in... (like I am not very interested in maths, but grondilu most certainly is)

[16:25] <xfix> For example, in C I can do #define assert(condition) printf(#condition).

[16:25] <vendethiel> he's interested in FP :p

[16:26] <xfix> I need this because of http://codegolf.stackexchange.com/questions/24681/self-containing-logs

[16:29] <FROGGS> vendethiel: then I guess it will be interesting for him how we pass named args (flattened hashes and things like :$foo, :$<foo>, :!bar)

[16:29] <FROGGS> I have no example to show though

[16:31] <masak> xfix: you're thinking of "textual macros". they're not currently supported in any compiler, except Pugs.

[16:31] <vendethiel> "only" quasiquotes are implemented atm, right ?

[16:31] <TimToady> why can't you stringify within the quasy

[16:31] <TimToady> quasi*

[16:32] <TimToady> or do you need the string at compile time?

[16:32] <xfix> I want to stringify AST object.

[16:32] <vendethiel> I guess he wants to generate `if !COND { die "COND" }`

[16:32] <vendethiel> or something along those lines

[16:32] <xfix> Yeah, something like this.

[16:33] <Mouq> `unless COND -> $c { $c.die }`?

[16:33] <masak> we should definitely be able to stringify AST objects, I think.

[16:33] <masak> that's a reasonable request.

[16:33] <TimToady> r: macro foo($a) { say $a }; foo($_ + 42); # curious

[16:33] <camelia> rakudo-moar 1c1a08: OUTPUT«AST.new()␤===SORRY!===␤Not enough positional parameters passed; got 2 but expected 3␤»

[16:33] <camelia> ..rakudo-parrot 1c1a08: OUTPUT«AST.new()␤===SORRY!===␤too few positional arguments: 2 passed, 3 (or more) expected␤»

[16:33] <camelia> ..rakudo-jvm 1c1a08: OUTPUT«AST.new()␤===SORRY!===␤Wrong number of arguments passed; expected 3..3, but got 2␤»

[16:33] <masak> don't think it works right now, though.

[16:34] <masak> huh.

[16:34] <Mouq> r: macro A ($ast) { say ~$yus; quasi {$ast} }; A(1+1)

[16:34] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Variable '$yus' is not declared␤at /tmp/tmpfile:1␤------> [32mmacro A ($ast) { say ~$yus[33m⏏[31m; quasi {$ast} }; A(1+1)[0m␤    expect…»

[16:34] <Mouq> r: macro A ($ast) { say ~$ast; quasi {$ast} }; A(1+1)

[16:34] <camelia> rakudo-jvm 1c1a08: OUTPUT«AST<66511588>␤»

[16:34] <camelia> ..rakudo-moar 1c1a08: OUTPUT«AST<140387194419848>␤»

[16:34] <camelia> ..rakudo-parrot 1c1a08: OUTPUT«AST<-825766304312482331>␤»

[16:34] <Mouq> r: macro A ($ast) { say $ast; quasi {$ast} }; A(1+1)

[16:34] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«AST.new()␤»

[16:34] <masak> yeah.

[16:34] <masak> I think it could be made to stringify to its souce code.

[16:35] <masak> I'm not 100% that's Least Surprise, but I agree it would be Nice.

[16:35] <xfix> Also, I don't like this {{{ }}} syntax, but that's probably just me.

[16:36] <xfix> Cannot it be something like .run method, or something?

[16:36] <vendethiel> Well, there should something else than {{{ }}} imho

[16:36] <xfix> (well, not .run, run() already exists)

[16:36] <geekosaur> that sounds like a bad mixing of levels to me

[16:37] <geekosaur> {{{ }}} is ugly but it's at the right level, it's telling you something is being spliced at that point instead of a normal evaluation happening

[16:37] <geekosaur> there might be cleaner ways to do it (maybe some unicode bracket if they're not all taken already)

[16:37] <vendethiel> "crying cat face brackets" seems good.

[16:38] <geekosaur> .u skull and crossbones

[16:38] <yoleaux> U+2620 SKULL AND CROSSBONES [So] (☠)

[16:38] <geekosaur> .u splice

[16:38] <yoleaux> No characters found

[16:40] <Mouq> r: say ($_,.chr,.&uniname) if .chr.&uniname ~~ /ARROW/ for 0..0xffff

[16:40] <TimToady> {{{}}} is going to go away

[16:40] <camelia> rakudo-jvm 1c1a08: OUTPUT«uniname NYI on jvm backend␤  in sub uniname at gen/jvm/CORE.setting:6768␤  in sub uniname at gen/jvm/CORE.setting:6768␤  in block  at /tmp/tmpfile:1␤␤»

[16:40] <camelia> ..rakudo-moar 1c1a08: OUTPUT«706 ˂ MODIFIER LETTER LEFT ARROWHEAD␤707 ˃ MODIFIER LETTER RIGHT ARROWHEAD␤708 ˄ MODIFIER LETTER UP ARROWHEAD␤709 ˅ MODIFIER LETTER DOWN ARROWHEAD␤751 ˯ MODIFIER LETTER LOW DOWN ARROWHEAD␤752 ˰ MODIFIER LETTER LOW UP ARROWHEAD␤753 ˱ MODI…»

[16:40] <camelia> ..rakudo-parrot 1c1a08: OUTPUT«uniname NYI on parrot backend␤  in sub uniname at gen/parrot/CORE.setting:6772␤  in sub uniname at gen/parrot/CORE.setting:6772␤  in block  at /tmp/tmpfile:1␤␤»

[16:40] <timotimo> :}}}

[16:40] <vendethiel> what's the synopsis with macros ?

[16:40] * Mouq keeps forgetting to only use m: on that

[16:41] * vendethiel is really glad perl 6 has macros

[16:41] * vendethiel is really glad perl 6 has all these features, anyway.

[16:42] *** raiph left
[16:42] <TimToady> S06:Macros

[16:42] <masak> everybody loves to hate {{{ }}} -- but counterproposals are few and far between, let alone ones I could see working out.

[16:43] * vendethiel think macros are a huge topic that can probably have their own synopsis. Maybe not right now, though

[16:43] <geekosaur> yeh, that's the problem

[16:44] *** nagu joined
[16:44] <vendethiel> yeah. IIRC, scala uses q"" with normal interpolation

[16:44] <Mouq> ↬ and ↫? :9

[16:44] <geekosaur> also while {{{ }}} is big and ugly, that also means it is distinctive which IMO is good here

[16:45] <geekosaur> since it's a big obvious flag that something unusual is going on

[16:45] <Mouq> geekosaur: But isn't macro and quasi enough of an indication of that?

[16:46] <geekosaur> not really, imo

[16:46] <xfix> $code.INTERPOLATE

[16:46] <vendethiel> r: macro stuff($foo) { quasi < 2 + <<< $foo.chars >>> > }; say stuff("abc");

[16:46] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Missing block␤at /tmp/tmpfile:1␤------> [32mmacro stuff($foo) { quasi [33m⏏[31m< 2 + <<< $foo.chars >>> > }; say stuff([0m␤    expectin…»

[16:46] <vendethiel> NYI, then

[16:46] <xfix> This should work according to specification.

[16:46] <xfix> Yes, NYI.

[16:46] <dalek> doc: 5065843 | Mouq++ | lib/modules.pod:

[16:46] <dalek> doc: Copy more formatting from archived wiki

[16:46] <dalek> doc: review: https://github.com/perl6/doc/commit/50658436c6

[16:46] <xfix> std: macro stuff($foo) { quasi < 2 + <<< $foo.chars >>> > }; say stuff("abc");

[16:46] <camelia> std 09dda5b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/7wzgIUH3gH line 1:␤------> [32mfoo) { quasi < 2 + <<< $foo.chars >>> > [33m⏏[31m}; say stuff("abc");[0m␤Parse failed␤FAILED 00:01 138m␤»

[16:46] <masak> yes, NYI.

[16:47] <geekosaur> xfix: that is a level confusion, everything else is *not* evaluated but .INTERPOLATE there is

[16:47] <vendethiel> r: macro stuff($foo) { quasi < 2 + { {{{ $foo.chars }}} } }; say stuff("abc");

[16:47] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Missing block␤at /tmp/tmpfile:1␤------> [32mmacro stuff($foo) { quasi [33m⏏[31m< 2 + { {{{ $foo.chars }}} } }; say stuf[0m␤    expectin…»

[16:47] <geekosaur> this is very bad

[16:47] <vendethiel> r: macro stuff($foo) { quasi { 2 + {{{ $foo.chars }}} } }; say stuff("abc");

[16:47] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Method 'chars' not found for invocant of class 'AST'␤at /tmp/tmpfile:1␤------> ␤»

[16:47] <geekosaur> and may be even more confusing if you can do multiple levels in there (a macro inside a macro, anyone?)

[16:48] <xfix> I always thought of macros as functions that took functions as arguments (like `map` in Perl 5).

[16:48] <xfix> But I guess this is wrong.

[16:48] <vendethiel> that's higher order functions

[16:48] <geekosaur> what is happening with the splice is completely different from what is happening with everything else in the macro; it should not look like a magic method call

[16:48] <Mouq> QUASI

[16:48] <Mouq> :P

[16:49] <xfix> That a 2 + 2; is actually syntactic sugar for NONMACRO::a sub {2 + 2}.to-ast, assuming that .to-ast and NONMACRO:: namespaces exist.

[16:49] <xfix> namespace exists*

[16:51] <xfix> The problem with {{{ }}} is that it's a valid syntax.

[16:51] <xfix> rn: {{{ say "Hello, world!" }}}

[16:51] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08, niecza v24-109-g48a8de3: OUTPUT«Hello, world!␤»

[16:52] <xfix> Why it changes meaning in macros?

[16:52] <TimToady> quasis are a different language

[16:52] <vendethiel> r: (defmacro addlen [str] `(+ 2 (length ~str)))

[16:52] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32m(defmacro addlen [str] [33m⏏[31m`(+ 2 (length ~str)))[0m␤    expecting any of:␤     …»

[16:52] <TimToady> jsut as "" and // are different languages

[16:52] <vendethiel> perl 6 is a very  bad lisp, apparently.

[16:53] <xfix> C uses # for special characters in macros. Except that doesn't change anything, as # is unused in language itself.

[16:55] <vendethiel> r: macro mouse ($arg) { my $l = $arg.chars; quasi { 2 + $l } }; say mouse("abc")

[16:55] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Method 'chars' not found for invocant of class 'AST'␤at /tmp/tmpfile:1␤------> ␤»

[16:56] <xfix> r: macro double($code) { quasi { {{{ $code }}}, {{{ $code }}} } }; double say("WORLD!");

[16:56] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«WORLD!␤WORLD!␤»

[16:56] <xfix> How is that different from a function that takes a function as an argument?

[16:56] <vendethiel> WORLD is eval'd two times ?

[16:56] <xfix> r: sub double(&code) { code, code }; double { say("WORLD!") };

[16:56] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«WORLD!␤WORLD!␤»

[16:57] <xfix> vendethiel, it's not eval-ed. It's AST object..

[16:57] <vendethiel> r: sub saytwo($r) { say $r ~ $r; }; sub gettext() { "WORLD" }; saytwo(gettext());

[16:57] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«WORLDWORLD␤»

[16:57] <vendethiel> r: sub saytwo($r) { say $r ~ $r; }; sub gettext() { say "side effect"; return "WORLD" }; saytwo(gettext());

[16:57] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«side effect␤WORLDWORLD␤»

[16:57] <vendethiel> r: macro saytwo($r) { quasy { {{{ $code }}} ~ {{{ $code }}} } }; sub gettext() { say "side effect"; return "WORLD" }; saytwo(gettext());

[16:57] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Variable '$code' is not declared␤at /tmp/tmpfile:1␤------> [32mmacro saytwo($r) { quasy { {{{ $code[33m⏏[31m }}} ~ {{{ $code }}} } }; sub …»

[16:58] <xfix> I said, a function taking a function as argument.

[16:58] <Timbus> queasy

[16:58] <vendethiel> r: macro saytwo($r) { quasy { {{{ $r }}} ~ {{{ $r }}} } }; sub gettext() { say "side effect"; return "WORLD" }; saytwo(gettext());

[16:58] <camelia> rakudo-parrot 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Could not find sub &quasy␤at /tmp/tmpfile:1␤------> ␤»

[16:58] * vendethiel sighs

[16:58] <camelia> ..rakudo-jvm 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤java.lang.NullPointerException␤at /tmp/tmpfile:1␤------> ␤»

[16:58] <camelia> ..rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Cannot invoke null object␤at /tmp/tmpfile:1␤------> ␤»

[16:58] <xfix> r: macro saytwo($r) { quasi { {{{ $r }}} ~ {{{ $r }}} } }; sub gettext() { say "side effect"; return "WORLD" }; saytwo(gettext());

[16:58] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«side effect␤side effect␤»

[16:58] <vendethiel> here.

[16:58] <vendethiel> r: macro saytwo($r) { quasi { say {{{ $r }}} ~ {{{ $r }}} } }; sub gettext() { say "side effect"; return "WORLD" }; saytwo(gettext());

[16:58] <vendethiel> ^ that, really

[16:58] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«side effect␤side effect␤WORLDWORLD␤»

[16:59] <xfix> r: sub saytwo($r) { say $r ~ $r; }; sub gettext() { say "side effect"; return "WORLD" }; saytwo {gettext()};

[16:59] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«␤»

[16:59] <xfix> Oh, right

[16:59] <vendethiel> but that just demonstrates that, in the macro case, since you pass in the AST "gettext()" instead of the function's value, it's gonna get executed two times

[16:59] <xfix> r: sub saytwo(&r) { say r ~ r; }; sub gettext() { say "side effect"; return "WORLD" }; saytwo {gettext()};

[16:59] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«side effect␤side effect␤WORLD␤»

[16:59] <vendethiel> (other languages such as scala offer call-by-name parameters, doing the same thing)

[17:01] *** jnap joined
[17:04] *** SamuraiJack_ joined
[17:06] *** jnap left
[17:07] <Mouq> xfix: https://gist.github.com/masak/3438222

[17:08] <xfix> Ok, I doubt a function could do this easily.

[17:08] <xfix> Macros save context. right...

[17:10] <vendethiel> perl 6 sdl game - 0.5 fps :)

[17:10] <Mouq> xfix: If you can replace a macro with a sub, I don't see any reason not to, and I don't see it as an argument against macros

[17:11] <Mouq> macros are supposed to be for doing weird things you shouldn't be allowed to do but it's Perl 6 so you can anyway

[17:11] <Mouq> ;)

[17:13] <tadzik> vendethiel: which one?

[17:13] <vendethiel> tadzik: none yet !

[17:14] <tadzik> I hope so

[17:14] <tadzik> mine are running on stable 120fps

[17:14] <xfix> Perl 6 is now faster than Perl 5.

[17:14] <vendethiel> tadzik: SDL+perl6 ?

[17:14] <tadzik> yep

[17:14] <vendethiel> well, that's impressive ;-)

[17:14] <tadzik> :)

[17:14] <vendethiel> I'd like to get a gist, though

[17:15] <tadzik> oh, you can play them too :)

[17:15] <tadzik> https://github.com/tadzik/p6steroids is the only one I released so far

[17:15] <Mouq> tadzik++

[17:15] <tadzik> I'm working on a full-blown framework now

[17:15] <tadzik> based on SDL2

[17:15] <vendethiel> tadzik++

[17:16] <tadzik> https://gist.github.com/tadzik/9710797 preview

[17:16] <tadzik> but don't tell anybody, it's a secret

[17:16] <vendethiel> oh okay. I won't :)

[17:17] <vendethiel> It's cool if you get to 120fps, though. Do you know which features not to use not to blow up ?

[17:17] *** iolympian joined
[17:18] <masak> tadzik++

[17:20] <vendethiel> TimToady, do you know cool and expressive examples I could link to my interested friend ? (fp-style is a bonus, I know you wrote one)

[17:20] <vendethiel> r: { !!! }

[17:20] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«Stub code executed␤  in block  at /tmp/tmpfile:1␤␤»

[17:21] <vendethiel> r: { ... }

[17:21] <camelia> rakudo-jvm 1c1a08: OUTPUT«Unhandled exception: Stub code executed␤  in throw (gen/jvm/CORE.setting:10978)␤  in sink (gen/jvm/CORE.setting:12406)␤  in MAIN (gen/jvm/main.nqp:47)␤  in  (gen/jvm/main.nqp:41)␤  in  (gen/jvm/main.nqp)␤␤»

[17:21] <camelia> ..rakudo-parrot 1c1a08: OUTPUT«Stub code executed␤current instr.: 'throw' pc 417025 (src/gen/p-CORE.setting.pir:174619) (gen/parrot/CORE.setting:10998)␤called from Sub 'sink' pc 454426 (src/gen/p-CORE.setting.pir:188619) (gen/parrot/CORE.setting:12427)␤called from Sub 'MAIN' pc …»

[17:21] <camelia> ..rakudo-moar 1c1a08: OUTPUT«Unhandled exception: Stub code executed␤   at src/gen/m-CORE.setting:11035  (/home/p6eval/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:129)␤ from src/gen/m-CORE.setting:12461  (/home/p6eval/rakudo-inst-1/languages/perl6/runtime/CORE.…»

[17:21] <vendethiel> r: { ??? }

[17:21] <camelia> rakudo-parrot 1c1a08: OUTPUT«Stub code executed  in block  at /tmp/tmpfile:1␤␤»

[17:21] <camelia> ..rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«Stub code executed␤»

[17:23] <tadzik> vendethiel: well, nothing blows up that's not a programming error

[17:23] <tadzik> but if you call a perl6 sub from C code, and don't give a good number of arguments, it explodes in a very nasty way

[17:23] *** iolympian left
[17:25] <masak> tadzik: have you seen http://impactjs.com/ ? it impressed me a lot, and you might be able to st^Wborrow some ideas from it.

[17:27] <Mouq> vendethiel: A simple one: http://rosettacode.org/wiki/Greatest_common_divisor#Perl_6

[17:28] <tadzik> masak: I'm borrowing from phaser.js mostly

[17:30] <Mouq> `cd Perl6; ls | wc -l` -> 73

[17:31] <Mouq> I think I need to clean up a bit

[17:31] *** pecastro left
[17:32] <masak> tadzik: ah. nice.

[17:36] <colomon> Mouq: nice

[17:37] <FROGGS> tadzik: would be cool, to a have what I did for P5's SDL, an SDLx::LayerManager

[17:38] <colomon> though I think I'd make the concise sub gcd($a, $b) { ($a.abs, $b.abs, * % * … 0)[*-2] }

[17:38] <colomon> the series version is awesome, at any rate.

[17:41] <colomon> er, sequence version.  :)

[17:41] <FROGGS> tadzik: because this thing offers all what you'd need for a board or card game

[17:41] *** denisboyun joined
[17:43] <tadzik> FROGGS: hmm, I'll look that up

[17:43] * colomon attention is suddenly on what FROGGS is saying after that last comment.

[17:45] <FROGGS> here is a solitaire game in 448 loc, which uses the said layermanager: https://github.com/FROGGS/Games-Solitaire/blob/master/solitaire.pl

[17:46] *** guru joined
[17:46] *** guru is now known as ajr_

[17:47] <FROGGS> a screenshot of that game: http://i.imgur.com/pboCxPG.jpg

[17:48] <FROGGS> if somebody needs card games images, feel free :o)

[17:52] <FROGGS> tadzik: this layermanager resolves a layer for you when you click somewhere in your app

[17:53] <FROGGS> and you can attach information to a layer, like the color/suite of the card

[17:53] <FROGGS> and the layermanager is responsible for drawing the layers

[17:55] <FROGGS> so we could do this in p6: $layer-manager.at(:$x,:$y).meta<on-click>()

[17:55] <FROGGS> (in case you want to put callbacks into a layer, which could be a button in this case)

[18:00] <FROGGS> this is a base for a chess game, where you can move the figures: https://github.com/PerlGameDev/SDL/blob/master/examples/SDLx/SDLx_LayerManager_Chess.pl

[18:00] <FROGGS> (only 139 loc)

[18:02] *** jnap joined
[18:02] *** raiph joined
[18:04] <vendethiel> tadzik: I mean blow up performance-wise, sory

[18:05] <colomon> FROGGS++

[18:05] <vendethiel> thanks Mouq

[18:06] *** jnap left
[18:06] <colomon> BTW, live streaming robot competition from the high school down the road: http://www.first-glbr.org/event-livestream.html

[18:07] <FROGGS> "Live Streaming is wegen Rechteproblemen in Deutschland leider nicht möglich." -.-

[18:07] <colomon> :(

[18:08] <colomon> wonder if there's any sort of valid reason?

[18:09] <FROGGS> it is about the GEMA

[18:09] <FROGGS> same reason why I can't see some music videos, one would have to do payments to the GEMA to broadcast this content

[18:13] *** araujo joined
[18:18] <nwc10> .tell arnsholt works on "my" machine (jastcompiler, that is), did one run, but numbers look better.

[18:18] <yoleaux> nwc10: I'll pass your message to arnsholt.

[18:19] *** wooden left
[18:19] *** Alula_ joined
[18:22] <dalek> specs: 0fa12d8 | (Konrad Borowski)++ | S02-bits.pod:

[18:22] <dalek> specs: Use space instead of underscore in Wikipedia reference.

[18:22] <dalek> specs: 

[18:22] <dalek> specs: While both forms, `Mu_(negative)` and `Mu (negative)` are correct, only

[18:22] <dalek> specs: the form with the space inside is intended to be public version

[18:22] <dalek> specs: (however, the version with underscore is also correct because of

[18:22] <dalek> specs: technical details - otherwise it would have to represented with `%20`

[18:22] <dalek> specs: which is just ugly).

[18:22] <dalek> specs: 

[18:22] <dalek> specs: If you disagree with this change, then I propose to change the Perl 6's

[18:22] <dalek> specs: name to Perl_6. After all, this is what technically it is on Wikipedia.

[18:22] <dalek> specs: Or Perl-6, after all Perl 6 prefers hyphens instead of underscores.

[18:22] <dalek> specs: 

[18:22] <xfix> ...

[18:22] <dalek> specs: The alternative options are "無 (negative)", "Moo", "Mu.new", "MU",

[18:22] <dalek> specs: "Star Trek [Ii]nto Darkness", and some more. However, I'm not going to

[18:22] <dalek> specs: consider them, because it would ridiculous.

[18:22] <dalek> specs: 

[18:22] <dalek> specs: Then again, this commit changes one character. This is ridiculous

[18:22] <dalek> specs: anyway. But it's not that I'm going to consider "Moo" instead of "Mu",

[18:22] <xfix> I fail

[18:22] <dalek> specs: even considering this minor change with huge commit description (yes,

[18:22] <dalek> specs: I noticed).

[18:22] <dalek> specs: review: https://github.com/perl6/specs/commit/0fa12d8e1d

[18:22] *** Alula left
[18:24] <lue> wat

[18:25] <Mouq> FROGGS⨤⨤

[18:25] * Mouq wonders why his terminal renders ⨤ but his browser doesn't

[18:28] *** bcode joined
[18:31] *** hoverboard joined
[18:32] * colomon 's home robot team is up next.  2619.  :)

[18:32] <vendethiel> That's one long commit message...

[18:34] *** raiph left
[18:34] <Mouq> Oh, shoot, why did I think that commit was by FROGGS?

[18:35] <Mouq> xfix⨤⨤ :P

[18:35] <Mouq> Because it's incredibly important to trail strange, meaningless symbols after the *correct* person's name!

[18:38] <tadzik> vendethiel: well, no specific things

[18:44] <dalek> rakudo/nom: ffa5722 | Mouq++ | src/Perl6/Grammar.nqp:

[18:44] <dalek> rakudo/nom: Let, e.g., B«I<boldlyimportant>» work

[18:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ffa5722982

[18:44] * colomon finally figured out he and his son could watch the robots on his Windows box, leaving the MBP free for $work.

[18:54] *** denis_boyun joined
[18:55] *** denisboyun left
[18:58] *** kurahaupo joined
[19:03] *** jnap joined
[19:03] *** darutoko left
[19:03] <masak> xfix: please try to correlate long commit messages with significant commits. thank you. ;)

[19:07] <lue> masak: to put it another way, "huffmanize your commit messages" :)

[19:07] *** jnap left
[19:09] <masak> right.

[19:12] *** ajr_ left
[19:12] <Mouq> r: my %letters = a => 5, b => 15, c => 2; say 'abcba' ~~ /%letters*/

[19:12] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«｢｣␤␤»

[19:12] <Mouq> r: my @letters = a , b , c; say 'abcba' ~~ /@letters*/

[19:12] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Preceding context expects a term, but found infix , instead␤at /tmp/tmpfile:1␤------> [32mmy @letters = a ,[33m⏏[31m b , c; say 'abcba' ~~…»

[19:12] <Mouq> r: my @letters = <a b c>; say 'abcba' ~~ /@letters*/

[19:12] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«｢abcba｣␤␤»

[19:13] <tadzik> lol, that commit message

[19:13] *** guru joined
[19:14] *** guru is now known as Guest3873

[19:14] *** Guest3873 is now known as ajr_

[19:15] <masak> r: my @letters = <a b c>; say 'abcda' ~~ /@letters*/

[19:15] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«｢abc｣␤␤»

[19:15] <masak> \o/

[19:16] *** mtk joined
[19:16] * Mouq just wonders what /%letters*/ does

[19:17] <lue> Mouq: absolutely nothing!

[19:17] <lue> or rather, absolutely [reserved]!

[19:17] <Mouq> r: my %letters = a => 5, b => 15, c => 2; say 'abcba' ~~ /@%letters.keys*/

[19:17] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«Nil␤»

[19:17] <Mouq> r: my %letters = a => 5, b => 15, c => 2; say 'abcba' ~~ /@%letters.keys()*/

[19:17] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Null regex not allowed␤at /tmp/tmpfile:1␤------> [32m c => 2; say 'abcba' ~~ /@%letters.keys([33m⏏[31m)*/[0m␤    expecting any of:␤  …»

[19:18] <Mouq> r: my %letters = a => 5, b => 15, c => 2; say 'abcba' ~~ /@%letters*/

[19:18] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«｢｣␤␤»

[19:18] <Mouq> r: my %letters = a => 5, b => 15, c => 2; say 'a5' ~~ /@%letters*/

[19:18] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«｢｣␤␤»

[19:18] <Mouq> r: my %letters = a => 5, b => 15, c => 2; say 'a 5' ~~ /@%letters*/

[19:18] <camelia> rakudo-parrot 1c1a08, rakudo-jvm 1c1a08, rakudo-moar 1c1a08: OUTPUT«｢｣␤␤»

[19:19] *** SamuraiJack_ left
[19:19] * Mouq &

[19:31] *** FrankG left
[19:33] *** BitPuffin left
[19:33] *** iolympian joined
[19:33] *** iolympian left
[19:38] *** logie_ joined
[19:43] *** kurahaupo left
[19:50] *** kurahaupo joined
[20:03] *** jnap joined
[20:05] <tadzik> argsh

[20:05] <tadzik> something is super-wrong with nativecall :/

[20:05] <tadzik> screenshot, because people usually can't read my shell logs anyway: http://imgur.com/mXai9lQ

[20:05] <tadzik> can provide code if someone wants to try to reproduce it

[20:06] *** nebuchadnezzar joined
[20:07] <tadzik> it's the same on all the backends

[20:07] <tadzik> it's weird, because nativecall tests all pass for me

[20:07] <masak> tadzik: it's working 2 times out of 7! that's great! :P

[20:08] *** jnap left
[20:08] <tadzik> quick math: how much of a working chance do I have if the game works 6 textures? :P

[20:08] <tadzik> s/works/loads/

[20:08] <jnthn> tadzik: "has int32 $.test"

[20:09] <masak> m: sub percent { say $^n.fmt("%.2f%%") }; say percent (2/7) ** 6

[20:09] <camelia> rakudo-moar ffa572: OUTPUT«0.00%␤True␤»

[20:10] <masak> m: sub percent { $^n.fmt("%.5f%%") }; say percent (2/7) ** 6

[20:10] <camelia> rakudo-moar ffa572: OUTPUT«0.00054%␤»

[20:10] <masak> er.

[20:10] <masak> m: sub percent { ($^n * 100).fmt("%.5f%%") }; say percent (2/7) ** 6

[20:10] <camelia> rakudo-moar ffa572: OUTPUT«0.05440%␤»

[20:10] <masak> tadzik: ^

[20:10] <masak> tadzik: one chance in ~200. not bad.

[20:10] <masak> m: sub percent { ($^n * 100).fmt("%.3f%%") }; say percent (2/7) ** 6

[20:10] <camelia> rakudo-moar ffa572: OUTPUT«0.054%␤»

[20:10] *** nebuchadnezzar left
[20:10] <tadzik> jnthn: :o

[20:11] *** nebuchadnezzar joined
[20:11] <jnthn> tadzik: int in C is never any bigger than 32 bits, but in Perl 6 int tends to me "whatever is a comfortable integer size for whatever we're running on"

[20:11] <tadzik> of course it helps :)

[20:11] <jnthn> Yeah, it worked when you were lucky enough that the next 4 bytes are zeroes.

[20:12] <jnthn> If you check the numbers you got in binary I suspect it'll make more senes :)

[20:12] <tadzik> jnthn: yeah, the bittage thought even crossed my mind, but somehow I thought "well, I wrote «has int», not «has long»...." :)

[20:12] <jnthn> Or even in hex will do :)

[20:12] <tadzik> yeah, probably :)

[20:14] <tadzik> now I'm back to the 'C calls Perl6' bug...

[20:16] <TimToady> vendethiel: http://rosettacode.org/wiki/Pattern_matching#Perl_6 http://rosettacode.org/wiki/Same_Fringe#Perl_6 http://rosettacode.org/wiki/Partial_function_application#Perl_6 http://rosettacode.org/wiki/First-class_functions#Perl_6 http://rosettacode.org/wiki/Function_composition#Perl_6 http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences#Perl_6 http://rosettacode.org/wiki/Runge-Kutta_method#Perl_6

[20:16] <vendethiel> TimToady++

[20:16] <vendethiel> Thanks !

[20:17] <jnthn> If you're having C callbacks on Moar, there's two things that the VM will get REALLY upset about and probably poop unicorns in response to: unwinding an exception handler across the boundary, and taking a continuation over the boundary.

[20:17] <jnthn> I actually don't know what it will do, I just know I didn't take the time to put in proper handling of the two cases yet.

[20:18] <jnthn> I guess making them panic is a reasonable start.

[20:18] <jnthn> C has no concept of exceptions so it's really icky knowing what to do if the Perl 6 code throws one.

[20:18] <tadzik> Internal error: Unwound entire stack and missed handler is what I get now

[20:19] <tadzik> it used to do that when I called a perl6 sub from C that had a wrong signature or something

[20:19] <jnthn> oh, that's not actually terrible...compared to a SEGV :)

[20:19] <tadzik> now I have no idea what's happening :)

[20:19] *** pippo_ joined
[20:19] <pippo_> Hello #perl6!

[20:20] <masak> hello pippo_!

[20:20] <jnthn> Well, you can put a CATCH in your callback that dumps the exception I guess

[20:20] <tadzik> it's not even a callback

[20:20] <jnthn> I wonder what semantics we (a) want and (b) can sanely implement here...

[20:20] <tadzik> well, it's from a callback, somehow

[20:20] <jnthn> Oh...

[20:20] <tadzik> C calls Perl6 calls C

[20:20] <jnthn> Yeah

[20:20] <jnthn> That'd do it

[20:20] <jnthn> I mena, it's fine, but if that Perl 6 ever results in an exception at the moment, things will hurt.

[20:20] <pippo_> Hi masak! Backlogging I have seen this { $*IN.getc // last }

[20:21] <tadzik> X::AdHoc.new(payload => "Native call expected object with CPointer representation, but got something else")

[20:21] <tadzik> ha!

[20:21] <masak> m: constant p = "p"; constant i = "i"; constant o = "o"; constant underscore = "_"; say "hello {p}{i}{p xx 2}{o}{underscore}!"

[20:21] <camelia> rakudo-moar ffa572: OUTPUT«hello pip po_!␤»

[20:21] <tadzik> I wonder, why can't NativeCall do that for me

[20:21] <masak> m: constant p = "p"; constant i = "i"; constant o = "o"; constant underscore = "_"; say "hello {p}{i}{p x 2}{o}{underscore}!"

[20:21] <camelia> rakudo-moar ffa572: OUTPUT«hello pippo_!␤»

[20:21] <jnthn> tadzik: "that"?

[20:21] <pippo_> but I do not understand how it works. For me // is an empty regex but ther is no math operator before???

[20:21] <tadzik> yay, works

[20:22] <tadzik> jnthn: well, I expect to get a Perl6-level exception if something breaks

[20:22] <tadzik> and I get a weird moarvm error

[20:22] <masak> pippo_: "defined or", see S03.

[20:22] <Mouq> pippo_: http://perlcabal.org/syn/S03.html#Tight_or_precedence

[20:23] <jnthn> tadzik: Yeah; I'm more inclined to find a MoarVM-level way to more safely propagate or report the exception.

[20:23] <pippo_> masak: Mouq: Thank you!!

[20:23] <Mouq> http://doc.perl6.org/language/operators#infix+%252F%252F

[20:24] <tadzik> jnthn: that'd be great

[20:26] <jnthn> tadzik: It was already on my todo list; I just ran out of tuits this side of the Rakudo release. :)

[20:27] *** kaare__ left
[20:27] <jnthn> Also there's something I'm planning to build out of nativecall things in the coming weeks, so I hope to discover/hunt more bugs out of that too :)

[20:27] <tadzik> okay :)

[20:29] <masak> pippo_: also in Perl 5.10+

[20:32] <Mouq> Hurm

[20:32] *** jnap joined
[20:33] <nwc10> jnthn: hmm, int on I-forget-which-sort of Cray was 64 bit. As was short.

[20:33] <Mouq> So I added a dynamic variable to Pod::To::HTML and the compiled-to-moarvm version of the module now segfaults… rebuilding RM in case it's just me

[20:33] <nwc10> no, there was no type which had a sizeof(...) 2. Or 4.

[20:35] <jnthn> nwc10: We may need to introduce c_int, c_long, c_short, c_side, etc. that some point for dealing with this...

[20:35] <pippo_> masak: thanks!

[20:36] <nwc10> "was" in that I'm not sure how many are still around

[20:37] <nwc10> then again, there's at least one PDP11 in Canada for at least 36 years: http://www.vintage-computer.com/vcforum/showthread.php?37827-Greetings-from-GE-Canada

[20:41] *** virtualsue joined
[20:44] *** rindolf left
[20:49] <Mouq> Oh, nope, fresh build, reverted Pod::To::HTML to before my recent changes, and it still segfaults; I musta borked panda...

[20:52] *** iolympian1 joined
[20:52] *** iolympian1 left
[20:53] <FROGGS> run it in gdb?

[20:55] *** ajr_ left
[21:10] *** hoverboard left
[21:14] *** kurahaupo left
[21:14] <Mouq> FROGGS: How?

[21:15] <FROGGS> Mouq: that is for perl6-m?

[21:15] <Mouq> Yes

[21:15] <FROGGS> do:

[21:15] <FROGGS> which perl6-m

[21:15] <FROGGS> then: cat /path/to/perl6-m

[21:16] <Mouq> FROGGS: Ok

[21:16] <FROGGS> and then: gdb --args /path/to/moar <option until $@> -e 'whatever you did before'

[21:16] <FROGGS> options*

[21:16] <FROGGS> without the $@ in fact

[21:17] <FROGGS> and then when you are in the gdb prompt, type: run

[21:17] <Mouq> FROGGS: Ok, thank you

[21:17] <FROGGS> and when it segfaults: bt full

[21:17] <FROGGS> Mouq: you might want to recompile MoarVM with --debug though, otherwise you will not see much

[21:17] <FROGGS> (you dont have to recompile nqp or rakudo afterwards)

[21:21] <pippo_> good night #perl6!

[21:21] *** pippo_ left
[21:21] <Mouq> o/ pippo_

[21:23] <Mouq> Program received signal EXC_BAD_ACCESS, Could not access memory.

[21:23] <Mouq> Reason: KERN_INVALID_ADDRESS at address: 0x0000000000000070

[21:23] <Mouq> 0x0000000100013804 in AO_fetch_and_add_full ()

[21:23] *** zakharyas joined
[21:23] <FROGGS> Mouq: can you no-paste the bt full?

[21:24] <Mouq> https://gist.github.com/Mouq/38b74be36e0834cb8248

[21:24] <Mouq> But rerunning with --debug

[21:25] <FROGGS> yeah, --debug will help

[21:25] <Mouq> https://gist.github.com/Mouq/6d7a158e3046d93e5b47

[21:27] <FROGGS> #1  0x00000001000137d7 in MVM_frame_inc_ref (tc=<value temporarily unavailable, due to optimizations>, frame=0x0) at src/core/frame.c:43

[21:27] <FROGGS> that frame there is NULL

[21:28] <FROGGS> that p6captureouters is new I think

[21:28] <jnthn> It changed recently

[21:29] <FROGGS> rakudo/src/vm/moar/ops/perl6_ops.c:502:            outer->outer = MVM_frame_inc_ref(tc, ((MVMCode *)tgt)->body.outer);

[21:29] <FROGGS> must be this

[21:29] <FROGGS> s/must/could/

[21:29] *** Alula_ is now known as Alula

[21:29] <jnthn> Hm, if that ends up being null that's...less than useful.

[21:32] <FROGGS> hmmm, no, I don't think it can be NULL

[21:32] <FROGGS> that outer->outer two lines before would explode in that case

[21:33] <FROGGS> ohh, no

[21:33] <FROGGS> I am unable to read properly :o)

[21:35] *** mtk left
[21:35] *** daniel-s joined
[21:35] *** virtualsue left
[21:40] *** mtk joined
[21:41] *** jnap left
[21:43] <vendethiel> r: my &gcd = { (abs $^a, abs $^b, * % * ... 0)[*-2] }; gcd 1, 2;

[21:43] <camelia> rakudo-moar ffa572: OUTPUT«===SORRY!===␤Not enough positional parameters passed; got 1 but expected 2␤»

[21:43] <camelia> ..rakudo-jvm ffa572: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block  at gen/jvm/CORE.setting:16576␤  in block  at gen/jvm/CORE.setting:16514␤  in block  at gen/jvm/CORE.setting:7614␤  in block  at gen/jvm/CORE.setting:7616␤  in method reify a…»

[21:43] <camelia> ..rakudo-parrot ffa572: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block  at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[21:43] <Mouq> r: my &gcd = { (abs $^a, abs $^b, * % * ... 0)[*-2] }; gcd(1, 2);

[21:44] <camelia> rakudo-moar ffa572: OUTPUT«===SORRY!===␤Not enough positional parameters passed; got 1 but expected 2␤»

[21:44] <camelia> ..rakudo-jvm ffa572: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block  at gen/jvm/CORE.setting:16576␤  in block  at gen/jvm/CORE.setting:16514␤  in block  at gen/jvm/CORE.setting:7614␤  in block  at gen/jvm/CORE.setting:7616␤  in method reify a…»

[21:44] <camelia> ..rakudo-parrot ffa572: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block  at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[21:44] <Mouq> m: my &gcd = { abs $^a, abs $^b, * % * ... 0 }; gcd(1, 2);

[21:44] <camelia> rakudo-moar ffa572: OUTPUT«===SORRY!===␤Not enough positional parameters passed; got 1 but expected 2␤»

[21:44] <Mouq> ?

[21:44] <vendethiel> my question exactly

[21:44] <Mouq> m: my &gcd = { abs $^a, abs $^b, ->$a,$b{$a % $b} ... 0 }; gcd(1, 2);

[21:44] <camelia> rakudo-moar ffa572: OUTPUT«===SORRY!===␤Not enough positional parameters passed; got 1 but expected 2␤»

[21:45] <jnthn> m: my &gcd = { say 'in call'; abs $^a, abs $^b, * % * ... 0 }; gcd(1, 2);

[21:45] <camelia> rakudo-moar ffa572: OUTPUT«in call␤===SORRY!===␤Not enough positional parameters passed; got 1 but expected 2␤»

[21:45] <jnthn> I think it's the * % * maybe?

[21:45] <Mouq> m: my &gcd = ->$a,$b{ abs $a, abs $b, ->$c,$d{$c % $d} ... 0 }; gcd(1, 2);

[21:45] <vendethiel> I believe it

[21:45] <camelia> rakudo-moar ffa572: OUTPUT«===SORRY!===␤Not enough positional parameters passed; got 1 but expected 2␤»

[21:45] <Mouq> Oh!

[21:46] <Mouq> r: my &gcd = { (abs($^a), abs($^b), * % * ... 0)[*-2] }; gcd(1, 2);

[21:46] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: ( no output )

[21:46] <Mouq> r: my &gcd = { (abs($^a), abs($^b), * % * ... 0)[*-2] }; say gcd 1, 2;

[21:46] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«1␤»

[21:46] <Mouq> r: my &gcd = { ($^a.abs, $^b.abs, * % * ... 0)[*-2] }; say gcd 1, 2;

[21:46] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«1␤»

[21:46] <vendethiel> hahahaha, might need RC fix then

[21:47] <Mouq> vendethiel++

[21:48] <vendethiel> TimToady++ # linking these RC

[21:49] <vendethiel> not sure why that's ..., though.

[21:49] <vendethiel> can it filter out explicit results ?

[21:49] <Mouq> vendethiel: What do you mean?

[21:49] <vendethiel> oh no, it's just [*-2] ¬¬

[21:49] <vendethiel> I'm blind

[21:50] <Mouq> http://doc.perl6.org/language/operators#infix+...

[21:50] <vendethiel> r: say 1, 2, 3 ... 1;

[21:50] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«1␤»

[21:50] <vendethiel> okay, that's what I meant

[21:50] <Mouq> Oh

[21:50] <Mouq> okay

[21:50] *** spider-mario left
[21:50] <Mouq> r: say 1, 2, 3 ... 0;

[21:50] <vendethiel> Broke it.

[21:51] <Mouq> (timeout)?

[21:51] <vendethiel> Not quite.

[21:51] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«(timeout)»

[21:51] <Mouq> (timeout).

[21:51] <vendethiel> although ...

[21:51] <vendethiel> say 1, 2, 3 ... * > 0;

[21:51] <vendethiel> (timeout)?

[21:52] <Mouq> vendethiel: Missing r:

[21:52] <vendethiel> Mouq++ # I'm so blind ¬¬

[21:52] <vendethiel> r: say 1, 2, 3 ... * > 0;

[21:52] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«1␤»

[21:52] <vendethiel> Oh, I guess 1 > 0. Makes sense.

[21:53] <vendethiel> r: say so 1 > 0

[21:53] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«True␤»

[21:53] <lizmat> r: say 1 > 0

[21:53] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«True␤»

[21:54] <vendethiel> r: say 1, 2, 3 ...^ * > 0;

[21:54] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«␤»

[21:54] <lizmat> not sure why you would need a so there

[21:54] <vendethiel> Much better.

[21:54] <vendethiel> lizmat, because I think "say so" looks cool :)

[21:55] <lizmat> r: say so.so  :-)

[21:55] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32msay so.so  [33m⏏[31m:-)[0m␤    expecting any of:␤        method arguments␤        …»

[21:55] <lizmat> r: say so.so 

[21:55] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«False␤»

[21:56] <vendethiel> lizmat++ # even if I'm not sure what's going on

[21:57] <lizmat> r: say 1.so

[21:57] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«True␤»

[21:57] <lizmat> r: say so .so

[21:57] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«False␤»

[21:58] <lizmat> r: $_=1; say so .so

[21:58] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«True␤»

[21:58] <Mouq> r: say so.so given ~so.so

[21:58] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«True␤»

[21:58] <lizmat> does that make sense?

[21:58] <vendethiel> oh.

[21:58] <vendethiel> yeah.

[21:58] <vendethiel> r: say so$_;

[21:58] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«False␤»

[21:59] <vendethiel> cause it's (Any)

[21:59] <lizmat> r: say so$_=1

[21:59] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«True␤»

[21:59] <lizmat> r: say so True

[21:59] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«True␤»

[22:00] <vendethiel> damn, now I'm gonna feel obligated to write my boolean tests like that: `say so.so given 1;`

[22:01] <lizmat> :-)

[22:02] *** kivutar joined
[22:04] <FROGGS> m: say ?^+?$0.?so # linenoise++

[22:04] <camelia> rakudo-moar ffa572: OUTPUT«True␤»

[22:04] <vendethiel> linenoise is easy to get with custom ops.

[22:04] <FROGGS> there is nothing custom in it :o)

[22:05] <vendethiel> Yeah, but you can do whatever you want :p

[22:05] <FROGGS> yes, that is the plan basically

[22:05] <FROGGS> you should be allowed to mess with it

[22:10] *** logie_ left
[22:12] *** jnap joined
[22:16] *** jnap left
[22:22] *** xenoterracide left
[22:26] *** Mouq left
[22:27] <lizmat> sleep&

[22:28] <FROGGS> lizmat: it got merged! https://github.com/andk/pause/pull/106

[22:28] <FROGGS> lizmat: now I just need to implement the bits for the indexer :o)

[22:28] <FROGGS> (should not be too hard now)

[22:29] <lizmat> cool!

[22:29] <lizmat> really sleep now  :-)

[22:29] <FROGGS> lizmat: sleep well!

[22:33] *** rurban1 left
[22:50] *** daniel-s left
[22:51] *** daniel-s joined
[22:52] <masak> m: grammar G { regex TOP { foo } }; say so G.parse("how utterly foo-lish")

[22:52] <camelia> rakudo-moar ffa572: OUTPUT«False␤»

[22:52] <masak> so, TOP has implicit ^ and $ nowadays, huh? :)

[22:53] <lue> yep

[22:53] <vendethiel> m: grammar G { regex TOP { foo } }; say so G.parse("how utterly \nfoo\n-lish")

[22:53] <camelia> rakudo-moar ffa572: OUTPUT«False␤»

[22:53] <vendethiel> m: grammar G { regex TOP { ^^ foo $$ } }; say so G.parse("how utterly \nfoo\n-lish")

[22:53] <camelia> rakudo-moar ffa572: OUTPUT«False␤»

[22:54] <lue> m: grammar G { regex TOP { foo } }; say so G.subparse("how utterly foo-lish")

[22:54] <camelia> rakudo-moar ffa572: OUTPUT«False␤»

[22:54] <lue> I thought subparse was supposed to work there.

[22:56] <FROGGS> p: grammar G { regex TOP { foo } }; say so G.subparse("fooo")

[22:56] <camelia> rakudo-parrot ffa572: OUTPUT«True␤»

[22:56] <FROGGS> p: grammar G { regex TOP { foo } }; say so G.subparse("xfooo")

[22:56] <camelia> rakudo-parrot ffa572: OUTPUT«False␤»

[22:56] <vendethiel> that's, uh, surprising

[22:56] <FROGGS> implicit ^ for some reason

[22:56] <lue> subparse shouldn't have implicit anchors at all, unless I'm seriously misremembering what it's for.

[22:56] *** Mouq joined
[22:56] <timotimo> "some" reason?

[22:57] <timotimo> i thought parse is for having anchors, subparse is for not having any

[22:58] <FROGGS> "some" in like "wrong" :o)

[22:59] *** xenoterracide joined
[23:02] *** zakharyas left
[23:06] *** Psyche^ joined
[23:10] *** Psyche^_ left
[23:13] *** jnap joined
[23:17] *** jnap left
[23:22] *** jnap joined
[23:23] <dalek> rakudo-star-daily: eda5956 | coke++ | log/ (5 files):

[23:23] <dalek> rakudo-star-daily: today (automated commit)

[23:23] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/eda5956b71

[23:23] <dalek> perl6-roast-data: 6f94935 | coke++ | / (4 files):

[23:23] <dalek> perl6-roast-data: today (automated commit)

[23:23] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/6f949352c4

[23:24] *** BenGoldberg joined
[23:25] <masak> Text::Indent published: https://github.com/masak/text-indented

[23:25] <masak> proceeding to blog.

[23:25] <timotimo> coolio :)

[23:26] <masak> if someone could be so kind as to pull-request the à la mode module/Panda stuffs, that would be muchly appreciated.

[23:26] <timotimo> is there a way to do things like "brackets allow you to have not indented stuff on the next line"?

[23:27] <timotimo> especially "wrong" unindents

[23:27] <masak> no, but if you pull-request a test for that, I might consider it :)

[23:28] <timotimo> you drive a hard bargain

[23:29] <masak> :3

[23:29] *** Fg_ joined
[23:29] <Mouq> masak: Do you mean perl6/ecosystem?

[23:30] <Mouq> Gah, Perl 5. If @_ = (0), is `if (!@_)` run? :|

[23:31] <timotimo> huh?

[23:31] <masak> Mouq: no.

[23:31] <masak> Mouq: the list has 1 element, so !@_ is falsy.

[23:31] <Mouq> masak: Even in p5?

[23:31] <masak> even in p5.

[23:31] <masak> there's no mixing of those two levels.

[23:31] <Mouq> Ok :) Thanks

[23:32] <masak> $ perl -Mstrict -wE '@_ = (0); if (!@_) { say "does not run" }; say "see?" '

[23:32] <masak> see?

[23:33] <Mouq> Ok, perl5++ for not being completely insane :)

[23:33] <masak> in general, both in Perl 5 and Perl 6, if the test is !@ary, then you can be sure that only the size of the array is under test, not its contents.

[23:34] *** telex left
[23:36] *** telex joined
[23:43] <masak> is there an RT TODO ticket for /<atom> ** {+N}/ ?

[23:43] <Mouq> r: class A { has $.foo; method bar (:$op = $.foo) { say $op } }; my $a = A.new; $a.bar; $a.foo = 42; $a.bar

[23:43] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«(Any)␤Cannot assign to a readonly variable or a value␤  in block  at /tmp/tmpfile:1␤␤»

[23:44] <Mouq> r: class A { has $.foo is rw; method bar (:$op = $.foo) { say $op } }; my $a = A.new; $a.bar; $a.foo = 42; $a.bar

[23:44] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«(Any)␤42␤»

[23:46] <lue> masak: a quick search for "block case of" turned up nothing for me.

[23:52] <vendethiel> r: role A[::T]; class B[::T] does A[T];

[23:52] <camelia> rakudo-parrot ffa572, rakudo-jvm ffa572, rakudo-moar ffa572: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Unable to parse class definition␤at /tmp/tmpfile:1␤------> [32mrole A[::T]; class B[33m⏏[31m[::T] does A[T];[0m␤    expecting any of:…»

[23:52] <vendethiel> r: role A[::T] {}; role B[::T] does A[T] {};

[23:52] <camelia> rakudo-parrot ffa572: OUTPUT«Could not instantiate role 'B':␤Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'specialize' pc 22132 (src/gen/perl6-metamodel.pir:10426) (gen/parrot/Metamodel.nqp:2102)␤called from Sub '' pc 27863 (src/gen/perl6-metam…»

[23:52] <camelia> ..rakudo-moar ffa572: OUTPUT«Unhandled exception: Could not instantiate role 'B':␤Not enough positional parameters passed; got 1 but expected 2␤   at <unknown>:1  (/home/p6eval/rakudo-inst-1/languages/nqp/lib/Perl6/Metamodel.moarvm:specialize:4294967295)␤ from src/gen/m-Metamode…»

[23:52] <camelia> ..rakudo-jvm ffa572: OUTPUT«Unhandled exception: Could not instantiate role 'B':␤Not enough positional parameters passed; got 1 but expected 2␤  in specialize (gen/jvm/Metamodel.nqp:2025)␤  in  (gen/jvm/Metamodel.nqp:2465)␤  in  (gen/jvm/Metamodel.nqp:2461)␤  in compose (gen…»

[23:52] <vendethiel> Why's that :(

[23:56] <masak> lue: I searched to, and came up empty-handed. just wanted to check.

