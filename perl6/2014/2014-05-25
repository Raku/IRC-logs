[00:14] *** hummeleBop left
[00:21] *** sunnavy joined
[00:32] *** Sqirrel left
[00:35] *** Sqirrel joined
[01:02] *** klapperl_ joined
[01:06] *** klapperl left
[01:09] *** thou joined
[01:21] *** tusooa joined
[01:22] *** tusooa left
[01:22] *** thistusooa joined
[01:23] *** thistusooa left
[01:23] *** thistusooa joined
[01:40] *** takesako_____ left
[01:44] *** FROGGS_ joined
[01:46] *** Su-Shee_ joined
[01:46] *** Sqirrel_ joined
[01:47] *** Sqirrel left
[01:48] *** FROGGS left
[01:48] <ren1us> Okay, as part of my continuing struggle to work through the book, such as it is, I now have a question: When it comes to constructing a new instance via self.bless, how would the syntax look for sending in a param with a name which doesn't quite match an attribute?

[01:48] <ren1us> And because that clearly made no sense in words, here's a quick example:  new($value) { return self.bless(:$value); } works fine, given a "$value" attribute

[01:49] *** Su-Shee left
[01:49] <ren1us> However, let's say you wanted to do something along the lines of: new($val) { return self.bless(value => $val); }.  How would the *proper* syntax for that look?

[01:50] <ren1us> I think my big confusion is, exactly what is that : operator actually doing and how is bless trying to match things.

[01:51] <BenGoldberg> As far as I know, :$foo is exactly identical to foo => $foo

[01:52] <ren1us> But what if you're trying to do foo => $bar?

[01:53] <BenGoldberg> Then write foo => $bar

[01:53] <flussence> You can write :foo($bar) if you want, but they're both the same everywhere.

[01:54] <ren1us> That works and actualyl makes a ton of sense.  Thanks.

[01:58] *** prevost left
[02:20] *** hoverboard joined
[02:30] *** perltricks joined
[02:38] *** perltricks left
[03:08] *** perltricks joined
[03:09] <perltricks> anyone know why this capture doesn't work? perl6 -e '"one two" ~~ m:g/(\w+)/; for @() { say }

[03:12] <avuserow2> m: "one two" ~~ m:g/(\w+)/; for @() { .say }

[03:12] <camelia> rakudo-moar dca172: OUTPUT¬´ÔΩ¢twoÔΩ£‚ê§‚ê§¬ª

[03:12] <avuserow2> perltricks: ^

[03:12] *** avuserow2 is now known as avuserow

[03:12] <avuserow> is that what you are seeing?

[03:13] <avuserow> m: "one two" ~~ m:g/(\w+)/; @().perl.say

[03:13] <camelia> rakudo-moar dca172: OUTPUT¬´(Match.new(orig => "one two", from => 4, to => 7, ast => Any, list => ().list, hash => EnumMap.new()),).list‚ê§¬ª

[03:14] <perltricks> Hi, thanks. I'm getting the last match ... but I want to iterate all matches

[03:15] <perltricks> With global matching I expected 'one' and 'two' as captures

[03:20] <avuserow> you could always use .comb here

[03:21] *** thou left
[03:21] <avuserow> m: .say for "one two".comb(/\w+/)

[03:21] <camelia> rakudo-moar dca172: OUTPUT¬´one‚ê§two‚ê§¬ª

[03:21] <perltricks> aha, thanks avuserow let me try that

[03:22] <lue> m: .say for "one two".words  # even shorter, if you're specifically looking for /\w+/

[03:22] <camelia> rakudo-moar dca172: OUTPUT¬´one‚ê§two‚ê§¬ª

[03:24] *** xragnar_ joined
[03:24] *** xragnar left
[03:24] *** xragnar_ is now known as xragnar

[03:25] *** Sqirrel_ left
[03:26] <perltricks> thanks lue, will try that also

[03:29] *** thou joined
[03:33] *** Sqirrel joined
[03:52] *** perltricks left
[04:00] *** skids joined
[04:22] *** Sqirrel left
[04:24] *** BenGoldberg left
[04:33] *** thou left
[04:33] *** Sqirrel joined
[04:39] *** Sqirrel left
[04:41] *** Sqirrel joined
[04:45] *** Sqirrel left
[04:46] *** hoverboard left
[04:51] *** Sqirrel joined
[05:14] *** kaare_ joined
[05:32] *** xinming joined
[05:34] *** xinming_ left
[05:39] *** SevenWolf joined
[05:56] *** huf_ is now known as huf

[06:05] *** bjz left
[06:05] *** bjz joined
[06:21] *** bbkr left
[06:26] *** darutoko joined
[06:27] *** darutoko- joined
[06:31] *** darutoko left
[06:31] *** darutoko joined
[06:31] *** darutoko- left
[06:32] *** Sqirrel left
[06:52] *** Sqirrel joined
[07:10] *** [Sno]_ is now known as [Sno]

[07:17] *** kurahaupo joined
[07:36] <FROGGS_> moritz: the LWP::Simple r-m* problems you mentioned make me think that we cannot have a star release *after* the compiler release anymore

[07:36] <FROGGS_> moritz: I think we should do a star release and compiler release at the same time, so do not have regressions in star that require a point release

[07:37] *** FROGGS_ is now known as FROGGS

[07:42] <moritz> lue: iirc .words uses \S+, not \w+

[07:51] <FROGGS> correct

[07:51] <FROGGS> m: .say for "ohh, yeah".words

[07:51] <camelia> rakudo-moar dca172: OUTPUT¬´ohh,‚ê§yeah‚ê§¬ª

[07:53] <moritz> FROGGS: I dunno, the failures shoudl have been obvious from the rakudo-star-daily thingy

[07:53] <FROGGS> moritz: nothing hangs on my box when I build r-m*

[07:53] <FROGGS> just checked

[07:53] <moritz> FROGGS: maybe adding that to the release guide would help

[07:53] <moritz> FROGGS: it hung here on two different machines :(

[07:54] <moritz> FROGGS: does r-p* build the modules fine for you?

[07:54] <xfix> http://perlcabal.org/syn/S03.html#line_1456 - interesting, ANSI C explicitly allows for operator looser in the precedence in middle part. But I guess it's because there is rarely an use for that.

[07:54] <FROGGS> moritz: it did on wednesday, but I'll check in a minute

[07:55] <moritz> (that is, no SORRY in the output)

[07:56] <FROGGS> I see that LWP::Simple fails a test though (on r-m)

[07:57] <FROGGS> "Internal error: inconsistent bind result"

[07:57] <FROGGS> never seen that before

[08:24] *** bjz left
[08:31] *** spider-mario joined
[08:37] *** denis_boyun_ joined
[08:57] *** denis_boyun___ joined
[08:57] *** denis_boyun_ left
[08:58] *** uniejo joined
[08:59] *** SevenWolf left
[09:04] *** denis_boyun_ joined
[09:05] *** denis_boyun___ left
[09:08] *** SamuraiJack__ joined
[09:12] *** Su-Shee_ is now known as Su-Shee

[09:26] *** Sqirrel left
[09:31] <masak> FROGGS++ # a new internal error; well done!

[09:31] <FROGGS> meh

[09:31] <FROGGS> :P

[09:32] <moritz> git grep  -i inconsistent in rakudo/nqp/parrot/moarvm doesn't yield that error message anywhere

[09:33] <moritz> any idea where it comes from?

[09:33] <FROGGS> rakudo/src/Perl6/Metamodel/BOOTSTRAP.nqp:2927:            nqp::die("Internal error: inconsistent bind result");

[09:43] *** Sqirrel joined
[09:45] * jnthn waves from the mojoconf hackathon

[09:45] *** bowtie left
[09:45] <moritz> oh, my local copy of rakudo is "a bit" out of date

[09:45] <moritz> like, 1225 commits

[09:46] <jnthn> FROGGS: That means that the lowered signature code thought the bind failed, it fell back to the binder proper to generate an error message, and that then thought all was OK, and the internal error is 'cus that should not happen.

[09:46] <FROGGS> hmmm

[09:47] *** Psyche^ joined
[09:49] * jnthn agrees with moritz that we need to use the star-daily thingy to try and make sure we don't cut releases that bust stuff for Star

[09:50] <jnthn> On the other hand, given it seems that that only some of us can re-produce the bug...

[09:51] *** Sqirrel left
[09:53] *** Sqirrel joined
[09:55] *** kaare__ joined
[09:59] *** kaare_ left
[10:01] <jnthn> FROGGS: Can you get me a condensed test case on the internal bind error?

[10:02] <FROGGS> jnthn: gimme a minute

[10:02] <jnthn> ok

[10:03] <jnthn> I'm also looking into the crazy slowness of IO::Path.contents

[10:06] *** sqirrel_ joined
[10:09] <jnthn> Uhh...yeah

[10:09] <jnthn> Doing it 100 times hits the binder slow path around 30,000 times. 

[10:10] *** dmol joined
[10:13] <jnthn> We also hit it 78 times at startup now.

[10:13] <jnthn> Wonder how much that is costing...

[10:13] <vendethiel> that reminds me of String#hashCode which is itself called so much time in Java's library that the JIT optimized it already when your own program starts

[10:14] * jnthn wonders which on earth BUILD method is so costly...

[10:14] <vendethiel> (what tools do you use for bottlenecks ?)

[10:16] <xfix> timotimo++, I just noticed you (yes, I know, late, but I don't follow Perl 6 news lately) continued my old blog I didn't have time to write anymore. Also, it seems you write better posts than I did :-).

[10:18] <FROGGS> jnthn: the lwp-simple problem is about this: https://gist.github.com/FROGGS/9228162347e3b4c03a18

[10:19] <FROGGS> jnthn: when I delete the LWP/Simple.moarvm, I get the gisted bt

[10:19] <FROGGS> and it passes when I disable spesh

[10:19] *** Rotwang joined
[10:20] <jnthn> FROGGS: eek, yeah, that obj looks like junk

[10:21] <FROGGS> I am not sure I can provide a one-liner though

[10:22] <FROGGS> but perhaps.... I create a shorter script that shows the problem

[10:22] <xfix> I barely have time for programming and writing because of school.

[10:23] <xfix> (perhaps I should try Perl 6 again, and check how it improved...)

[10:23] <FROGGS> xfix: you should :o)

[10:24] <xfix> It was 6 months, after all. Is MoarVM usable now?

[10:24] <xfix> (or should I continue using Parrot Perl 6?)

[10:27] *** denis_boyun_ left
[10:27] <jnthn> xfix: Many folks are using MoarVM as their Perl 6 backend of choice these days.

[10:28] <jnthn> xfix: Worth it for the speedup.

[10:28] <xfix> So, it's reasonably complete.

[10:28] <jnthn> Well, it passes more spectests than any of the other backends by now.

[10:28] <jnthn> So at least by that measure...

[10:28] <jnthn> :)

[10:28] <jnthn> Has full nativecall support too

[10:28] <xfix> Interestnig.

[10:29] *** anaeem1_ joined
[10:32] <xfix> Compared to Perl 5, how fast MoarVM Rakudo Perl is?

[10:34] <xfix> But considering Parrot's performance six months ago, it's probably comparable or faster.

[10:35] <moritz> xfix: try it and see

[10:35] <xfix> :-)

[10:35] <xfix> Right now it's compiling.

[10:35] <jnthn> Comparison with Perl 5 varies greatly by benchmark.

[10:36] <xfix> note: expected ‚Äòchar (*)(struct DCCallback *, struct DCArgs *, union DCValue *, void *)‚Äô but argument is of type ‚Äòchar (*)(struct DCCallback *, struct DCArgs *, union DCValue *, struct MVMNativeCallback *)‚Äô

[10:36] <xfix> I love overzealous compilers.

[10:36] * jnthn doesn't

[10:36] <jnthn> The MSVC build of MoarVM is warning free. The clang build on OSX apparently spits out 1000 warnings o.O

[10:37] <xfix> Well, I guess that void * in function is not compatible with struct MVMNativeCallback *, but it will work on most platforms.

[10:37] <jnthn> gcc is a few

[10:37] <xfix> Except for Emscripten if I remember correctly.

[10:38] <xfix> But considering MoarVM is JIT, I doubt it would work on Emscripten either way.

[10:39] <FROGGS> three warning using gcc

[10:39] <FROGGS> warnings*

[10:39] <xfix> I got one while compiling MoarVM.

[10:39] *** anaeem1_ left
[10:40] <xfix> gcc 4.8.1, if you ask.

[10:40] <FROGGS> I've got also 4.8.1

[10:41] <jnthn> I htink I have 3 on GCC...

[10:41] <jnthn> I'll fix those is nobody else gets to them first.

[10:41] <jnthn> The clang 1000 is just crazy though :)

[10:42] <xfix> Why it would report way more than gcc?

[10:42] <FROGGS> jnthn: I can't provide a simple case for the lwp-simple issue, the problem vanishes when I rip out random stuff

[10:42] <vendethiel> (is clang bad ?)

[10:42] <vendethiel> I watched some C++ talks and they kept making fun of clang ;o)

[10:42] <jnthn> vendethiel: Not bad, just different defaults, I guess :)

[10:42] <FROGGS> I like clang

[10:43] <xfix> For fish shell, I get two warnings in clang, and one in gcc.

[10:43] <vendethiel> the little I used clang, it was just soo good because it was soo fast

[10:43] <xfix> But let's be honest, before fixing them, clang reported way more.

[10:44] <xfix> Those two warnings that were left are about unused static functions for which calls are generated using preprocessor.

[10:44] <tadzik> I think clang is awesome

[10:44] <xfix> It is.

[10:45] <xfix> It found lots of legit issues in fish shell.

[10:46] <xfix> https://github.com/fish-shell/fish-shell/blob/master/fallback.cpp#L804

[10:46] <xfix> Now I wonder who added __attribute__((unused)) here, and didn't add it anywhere else.

[10:48] *** denis_boyun_ joined
[10:48] *** thou joined
[10:49] <xfix> MoarVM installed, and it seems more responsive than Parrot. Interesting.

[10:50] *** prevost joined
[10:50] <xfix> Its REPL still loads faster than Node.js's REPL, which is already quite great.

[10:52] <tadzik> well, I started writing Steroids and games because Mokudo was faster than Typescript :)

[10:52] <xfix> The only issue I see for now is that -e code loads in 0.8 seconds or so.

[10:52] *** thou left
[10:53] <xfix> Typescript slower than Rakudo? What?

[10:53] <xfix> Aren't JavaScript implementations optimized really well?

[10:53] <tadzik> well, startup-time wise

[10:53] <tadzik> typescript needed like 3 seconds to compile an empty file

[10:53] <vendethiel> xfix: they mean the compiler :-)

[10:53] <tadzik> so I said "screw this, I'll write it in Perl 6"

[10:53] <vendethiel> compile it is long, not running it

[10:54] <tadzik> which is funny, since typescript compiler is written is JS which is supposed to be OMG FAST

[10:54] <xfix> 3 seconds is faster than C++ that can easily compile for 2 days :-).

[10:54] <tadzik> but it was super annoying to deal with

[10:54] <moritz> xfix: I don't know any C++ compiler that takes >3s for an empty fie

[10:54] <xfix> Hm, right.

[10:55] <xfix> I assumed that 3 seconds for a complete program.

[10:55] <tadzik> well, Rakudo now takes more than 3 seconds to compile the entire steroids too

[10:55] <tadzik> and it's possible that typescript is still at 3 :)

[10:55] <tadzik> but the startup time was unbearable so I ditched it

[10:55] <xfix> I remember compiling HHVM. It took so long that I just installed Fedora in VM, and downloaded the .rpm package in meantime.

[10:56] <xfix> (yes, it's PHP_)

[10:56] <tadzik> I like Go :)

[10:56] <tadzik> well, Hiphop is C++, I don't think it uses PHP in itself, does it

[10:56] <xfix> Well, it's VM for PHP.

[10:57] <xfix> I like Go, but I cannot get used to the types being on the right side just because.

[10:57] <vendethiel> go is bad :/

[10:57] <vendethiel> all hail rust !

[10:57] <xfix> And this array declaration syntax which looks like []int. Like, why?

[10:58] <tadzik> because writing function pointers isn't crazy like in C :)

[10:58] <tadzik> and it all makes sense

[10:59] <xfix> It's not even consistent. func main() should be main func() IMO.

[10:59] <tadzik> *

[11:03] <FROGGS> ohh dang, panda's sub local-fetch needs some love...

[11:04] <xfix> And there is issue of Unicode support. It claims to be Unicode supporting programming language. It even has fmt.Println("Hello, ‰∏ñÁïå") on main page.

[11:04] <xfix> It even has some methods that only make sense in Unicode. But they don't work, strings.EqualFold("ss", "√ü") returns false.

[11:05] <xfix> What's worse? Not having Unicode support, or claiming to have Unicode support without having it?

[11:06] <moritz> xfix: the world isn't just black and white. Get used to it.

[11:06] <moritz> xfix: it simply could have Unicode support that's not perfect.

[11:06] <xfix> I guess you are right here, but it still annoys me.

[11:11] <xfix> But it's annoying when according to Go, uppercase version of √ü is √ü. That's basic ISO-8859-1.

[11:12] <xfix> Then again, it's not that Rakudo does it better.

[11:13] <xfix> rn: say uc "√ü"

[11:13] <camelia> rakudo-jvm dca172: OUTPUT¬´SS‚ê§¬ª

[11:13] <camelia> ..rakudo-{parrot,moar} dca172, niecza v24-109-g48a8de3: OUTPUT¬´√ü‚ê§¬ª

[11:13] <xfix> But I assume it's just a bug in Rakudo.

[11:14] <moritz> r-j does better.

[11:14] <xfix> r-j: say uc "√ü"

[11:14] <camelia> rakudo-jvm dca172: OUTPUT¬´SS‚ê§¬ª

[11:15] <xfix> I already know it was reported - https://rt.perl.org/Public/Bug/Display.html?id=121377

[11:16] <tadzik> isn't √ü defined as case neutral in unicode?

[11:16] <xfix> 00DF; 00DF; 0053 0073; 0053 0053; # LATIN SMALL LETTER SHARP S

[11:16] <xfix> No, it's not.

[11:16] <tadzik> The Unicode standard defines, that ‚Äú√ü‚Äù does not change when mapping to upper, title, or lower case.

[11:17] <xfix> (according to SpecialCasing.txt)

[11:17] <tadzik> no source for that above sentence though

[11:17] <tadzik> just an internet comment that people didn't disagree wiht :)

[11:17] <xfix> According to Unicode, \xDF is \xDF (lowercase), \x53\x73 (titlecase) or \x53\x53 (uppercase).

[11:18] <moritz> tadzik: that comment is wrong; I recently looked it up

[11:18] <tadzik> fair enough

[11:20] <xfix> http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt - this is newest version of Unicode, if you want it.

[11:22] <xfix> In most cases √ü is uppercased to SS.

[11:23] <xfix> Apparently ·∫û is obligatory for official documentation when wriing geographical names in all-caps (http://141.74.33.52/stagn/Portals/0/101125_TopR5.pdf), but other than that, SS is being used.

[11:27] *** molaf left
[11:29] <FROGGS> xfix: I also had email conversation with german grammar officals, and it is quite possible that ·∫û will be the offical √ü.uc in a few years

[11:30] <FROGGS> which would result in an update to unicode of course

[11:30] <xfix> Well, yes, but currently Unicode doesn't change this change.

[11:31] <FROGGS> "change this change"?

[11:31] <xfix> update for this change*

[11:31] <xfix> wasn't updated*

[11:31] <FROGGS> the officals will only accept ·∫û if it used more widely btw

[11:32] <FROGGS> xfix: unicode can't do that on its own

[11:32] <xfix> That would be an interesting change.

[11:33] <xfix> Especially considering that ·∫û was added rather recently. Windows Vista doesn't have ·∫û character, but I bet that Microsoft would release an update if ·∫û would be officially accepted.

[11:34] <xfix> (assuming that it will be changed before Vista end of support)

[11:37] <FROGGS> ·∫û is there since uniode 5.1 (2008)

[11:37] <FROGGS> not that recently

[11:38] *** SamuraiJack__ left
[11:50] <tadzik> hmm, I don't suppose there's something like nqp::getattr() that'll traverse the inheritance hierarchy for me?

[11:50] <FROGGS> hehe

[11:51] <FROGGS> nice try :o)

[11:51] <tadzik> :>

[11:51] *** anaeem1_ joined
[11:51] <tadzik> that nice try would've saved me a 'for { ... try {' :P

[11:51] * tadzik is porting MooseX::StrictConstructor

[11:51] <jnthn> .oO( "It looks like you're after a method" )

[11:53] *** denis_boyun__ joined
[11:54] *** denis_boyun_ left
[11:56] *** sqirrel_ left
[12:02] <jnthn> grr

[12:02] <jnthn> So I got :enc(:$encoding) to work out for bind lowering, thus dealing with open, subst, etc.

[12:02] <jnthn> Then I discovered match :/

[12:02] <jnthn> :st(:nd(:rd(:th(:$nth))))

[12:03] <FROGGS> :/

[12:04] * jnthn just hacks it

[12:05] <timotimo> o/

[12:05] <timotimo> xfix: thanks for your kind words

[12:06] *** bowtie joined
[12:08] <xfix> r: a: goto a;

[12:08] <camelia> rakudo-{parrot,jvm,moar} dca172: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Undeclared routine:‚ê§    goto used at line 1‚ê§‚ê§¬ª

[12:08] <jnthn> It turns out the slow-path binder is less slow than I thought... Eliminating the 30,000 calls to it doesn't really make much difference to the IO::Path.contents slowness

[12:09] <xfix> Any idea why 'a:' causes SIGSEGV in r-m (on my computer)?

[12:09] <xfix> (but only in REPL)

[12:09] <FROGGS> hmmmm

[12:09] <jnthn> No idea. Doesn't here in REPL for me.

[12:09] <xfix> > a:

[12:09] <xfix> fish: Job 1, 'perl6' terminated by signal SIGSEGV (Address boundary error)

[12:09] <xfix> Strange.

[12:09] <FROGGS> segfaults for me too :(

[12:09] *** bowtie left
[12:10] <jnthn> Odd. No problems here.

[12:10] <xfix> Perhaps it's x86_64 specific or something.

[12:10] *** bowtie joined
[12:11] * jnthn is on x86_64...

[12:11] <xfix> I have 3.11.10-7 kernel, but it's probably not about that.

[12:12] <xfix> Well, 3.11.10-7-desktop (openSUSE).

[12:12] <xfix> Let me check gdb...

[12:12] <xfix> (after I install it)

[12:14] <FROGGS> xfix++

[12:14] <xfix> "/home/xfix/Code/rakudo/install/bin/perl6": not in executable format: File format not recognized

[12:14] <xfix> Hm...

[12:15] <xfix> It's a shell script. Ok.

[12:18] <xfix> https://gist.github.com/xfix/7313ed1b82d2047f7faa

[12:18] <xfix> huh

[12:19] <FROGGS> xfix: you need a MoarVM --debug=3 build

[12:19] <xfix> Hm, ok

[12:20] <FROGGS> you don't need to reinstall nqp/rakudo afterwards btw

[12:20] <xfix> So, I guess I have to recompile Moar.

[12:20] <FROGGS> just reconfigure MoarVM, and provide --prefix and --debug=3

[12:20] <xfix> I installed Rakudo using --gen-moar.

[12:20] <FROGGS> --prefix needs to point to your install directory

[12:20] <xfix> And there is --moar-option

[12:22] <xfix> I guess I have to download Moar then.

[12:22] * jnthn now has a Rakudo that doesn't hit the slow-path binder at all at startup

[12:22] *** Sqirrel left
[12:22] <jnthn> or match/subst

[12:23] <xfix> Heh, fish shell still calls sed on startup.

[12:25] *** kaare__ is now known as kaare_

[12:25] <FROGGS> jnthn: do you recognize a speed improvement?

[12:26] *** spider-mario left
[12:26] <jnthn> Not a great one...

[12:26] *** pippo joined
[12:26] <pippo> o/ #perl6

[12:26] <jnthn> I mean, it knows some off IO::Path.contents

[12:26] <xfix> Hi, pippo.

[12:26] <jnthn> But it appears not to be the main thing that makes it costly

[12:27] <jnthn> Even though 100 of them did it 30,000 times

[12:27] <pippo> xfix: same problem as yours on my box here. I have a 32bits machine.

[12:27] <pippo> xfix: btw also on perl6-j REPL.

[12:28] <xfix> https://gist.github.com/xfix/8aa1ba6cb3d9f8679654

[12:28] <xfix> Is it useful enough?

[12:29] <FROGGS> xfix: yeah

[12:29] <FROGGS> it tries to unbox_s a NULL object

[12:30] <xfix> Why it would do that...

[12:31] <FROGGS> I dunno

[12:31] <FROGGS> but I will find out

[12:31] <xfix> Anyway, I have to go away

[12:32] <FROGGS> thanks for the backtrace :o)

[12:33] *** Sqirrel joined
[12:36] *** thou joined
[12:36] <dalek> nqp: b436340 | jonathan++ | / (3 files):

[12:36] <dalek> nqp: Support having a pair of possible parameter names.

[12:36] <dalek> nqp: 

[12:36] <dalek> nqp: Just on MoarVM backend for now, but that's the only one that lowers

[12:36] <dalek> nqp: Perl 6 signatures at present.

[12:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b43634052a

[12:38] *** Sqirrel left
[12:38] <dalek> rakudo/nom: 10d5c92 | jonathan++ | src/Perl6/Actions.nqp:

[12:38] <dalek> rakudo/nom: Lower attributive parameter binds.

[12:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/10d5c926ae

[12:38] <dalek> rakudo/nom: 9df1a8c | jonathan++ | / (2 files):

[12:38] <dalek> rakudo/nom: Lower :a(:$amaze) in signatures.

[12:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9df1a8ceb7

[12:38] <dalek> rakudo/nom: 33e16f0 | jonathan++ | src/core/Str.pm:

[12:38] <dalek> rakudo/nom: Tweak match signature to be lowerable.

[12:38] <dalek> rakudo/nom: 

[12:38] <dalek> rakudo/nom: With this, we never hit the slow-path binder on startup, and avoid it

[12:38] <dalek> rakudo/nom: on all the calls to match.

[12:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/33e16f0bf4

[12:39] *** Sqirrel joined
[12:41] *** thou left
[12:41] <tadzik> "A class's explicit method definition hides any role definition of the same name", says S14. Is there a way to call it anyway?

[12:41] <vendethiel> tadzik: .RoleName.method ? .*method ?

[12:42] <tadzik> nah, doesn't work

[12:42] <masak> m: role R { method foo { say "R!" } }; class C does R { method foo { say "C!" } }; C.new::R.foo

[12:42] <camelia> rakudo-moar dca172: OUTPUT¬´===SORRY!===‚ê§Could not find symbol 'new'‚ê§¬ª

[12:43] <masak> m: role R { method foo { say "R!" } }; class C does R { method foo { say "C!" } }; C.new()::R.foo

[12:43] <camelia> rakudo-moar dca172: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/GVUay61J3v‚ê§Two terms in a row‚ê§at /tmp/GVUay61J3v:1‚ê§------> [32ms R { method foo { say "C!" } }; C.new()[33m‚èè[31m::R.foo[0m‚ê§    expecting any of:‚ê§        method arguments‚ê§        ar‚Ä¶¬ª

[12:43] <jnthn> ummm...

[12:43] <masak> m: role R { method foo { say "R!" } }; class C does R { method foo { say "C!" } }; C.new().R::foo

[12:43] <camelia> rakudo-moar dca172: OUTPUT¬´R!‚ê§¬ª

[12:43] <tadzik> hmm

[12:43] <masak> got the syntax wrong first. but there it is.

[12:43] <tadzik> how about from C.foo? :)

[12:43] <jnthn> in IO::Path.contents

[12:44] <jnthn> We do

[12:44] <jnthn> next unless $elem ~~ $test;

[12:44] <jnthn> And then a few lines later

[12:44] <jnthn> take $elem.path if $elem ~~ $test;

[12:44] <jnthn> Meaning we're doing the test twice?

[12:44] <tadzik> m: role Bar { method meth { say "from role" } }; class Foo does Bar { method meth { say "from class"; Bar::meth } }; Foo.meth

[12:44] <camelia> rakudo-moar dca172: OUTPUT¬´from class‚ê§===SORRY!===‚ê§Could not find symbol '&meth'‚ê§¬ª

[12:44] <jnthn> That won't be helping its speed...

[12:44] <tadzik> masak: that's what I want to do here

[12:45] <jnthn> tadzik: self.Bar::meth

[12:45] <tadzik> maybe I get the syntax wrong too

[12:45] <tadzik> aha!

[12:45] <tadzik> jnthn++

[12:45] <masak> yeah, it's still a method call.

[12:45] <masak> I used to not like the syntax, feeling it mixed together roles with module 'our' sub lookup.

[12:45] <tadzik> and I guess I can do that with callwith() too

[12:46] <masak> but nowadays I think it's fairly brilliant.

[12:46] <tadzik> or something

[12:46] <jnthn> FROGGS: Do you know if the test in contents is meant to happen on the fully qualified path after we catfile, or on the unqualified one?

[12:46] <jnthn> FROGGS: Feels wrong to do it on both...

[12:48] <FROGGS> jnthn: what test on contents?

[12:49] <jnthn> FROGGS: In IO::Path.contents

[12:49] <jnthn> We try $test twice.

[12:49] <jnthn>                     next unless $elem ~~ $test;

[12:49] <jnthn>                     $elem := $.SPEC.catfile($!path, $elem) if self ne '.';

[12:49] <jnthn>                     if $elem.substr(0, 2) eq any("./", ".\\") {

[12:49] <jnthn>                         $elem := $elem.substr(2);

[12:49] <jnthn>                     }

[12:49] <jnthn>                     take $elem.path if $elem ~~ $test;

[12:50] <jnthn> There's so much fail in here...

[12:50] <jnthn> Just avoe

[12:50] <jnthn> *above

[12:50] <jnthn>                 my Str $elem := nqp::nextfiledir($dirh);

[12:50] <jnthn>                 if nqp::isnull_s($elem) || !$elem.chars {

[12:50] <jnthn> isnull_s is meant to be used on a native str...

[12:51] <FROGGS> hmmm

[12:53] <FROGGS> I've seen that we test twice yesterday or so... but we also modify $elem in between

[12:53] <jnthn> yeah but...only on Moar

[12:53] <jnthn> on JVM we check it once

[12:55] <tadzik> I ported MooseX::StrictConstructor to Perl 6: https://github.com/tadzik/ClassX-StrictConstructor

[12:55] <tadzik> it was fun :)

[12:56] <tadzik> I wonder if I should maybe reuse some existing exception class, but X::Attribute::Undeclared only supports one attribute

[12:56] <tadzik> and I feel it's more helpful to show them all

[12:57] <Juerd> What does .^ do and does anybody know a way to google for punctuation? :)

[12:57] <Juerd> Or another search engine

[12:58] *** Sqirrel left
[12:58] <masak> tadzik++ # boa constrictconstructor

[12:58] <tadzik> Juerd: calls to MOP

[12:58] <Juerd> Thanks

[12:58] <masak> Juerd: $obj.^meth == $obj.HOW.meth($obj)

[12:59] <tadzik> and no, I don't know how to search for punctuation

[12:59] <vendethiel> m: role R { method foo { say "R!" } }; class C does R { method foo { say "C!" } }; C.new().R.foo # what's that ambigous with ?

[12:59] <camelia> rakudo-moar dca172: OUTPUT¬´No such method 'R' for invocant of type 'C'‚ê§  in block  at /tmp/SKp2ZG4DVx:1‚ê§‚ê§¬ª

[12:59] <vendethiel> oh, it's left associative ?

[12:59] <dalek> rakudo/nom: 2c54ffd | jonathan++ | src/core/IO.pm:

[12:59] <dalek> rakudo/nom: Various optimizations to IO::Path.contents.

[12:59] <dalek> rakudo/nom: 

[12:59] <dalek> rakudo/nom: Eliminate duplicate application of $test on MoarVM; probably just an

[12:59] <dalek> rakudo/nom: accident in porting. Then do a range of other optimizations. Cuts the

[12:59] <dalek> rakudo/nom: time taken to less than half of what it was.

[12:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2c54ffdc27

[12:59] <tadzik> hm. I can remove nextsame; from the end of Boa::Constrictor's new(), and tests will still work

[12:59] <vendethiel> m: role R { method foo { say "R!" } }; class C does R { method foo { say "C!" } }; C.new().(R::foo) # what's that ambigous with ?

[12:59] <camelia> rakudo-moar dca172: OUTPUT¬´===SORRY!===‚ê§Could not find symbol '&foo'‚ê§¬ª

[12:59] <Juerd> Not being able to search for punctuation has always been annoying when learning Perl... Maybe I'll create an operator lookup web thingy.

[12:59] *** Sqirrel joined
[12:59] <tadzik> I wonder if tests are lacking, or is it indeed unnecessary :)

[13:00] <vendethiel> Juerd: "poogle", like hoogle :P

[13:00] <Juerd> ?

[13:00] <jnthn> FROGGS: Hopefully the various patches today alleviate your .contents slowness issues a little.

[13:00] <vendethiel> Juerd: haskell.org/hoogle

[13:00] <Juerd> Ah, I was googling for poogle and found nothing relevant :)

[13:01] <Juerd> This does look like something we could use indeed

[13:01] *** denis_boyun__ left
[13:01] <masak> tadzik: well, can you think of a situation where 'nextsame' would make an observational difference?

[13:02] <tadzik> masak: I just thought of one

[13:02] <FROGGS> jnthn: that'd be nice :o)

[13:02] <tadzik> masak: https://gist.github.com/tadzik/815aa29efaebd5d15adf

[13:02] *** WAAD4CC joined
[13:03] <tadzik> this outputs "new from B\nnew from A"

[13:03] <FROGGS> installing v5 using panda takes more than 10m

[13:03] <tadzik> if teh class weren't using the StrictConrnsyarntoa it would never say "new from A"

[13:03] <tadzik> so the nextsame is rong

[13:03] <masak> aye.

[13:04] <masak> tadzik: minor thing, but I saw https://github.com/tadzik/ClassX-StrictConstructor/blob/master/lib/ClassX/StrictConstructor.pm#L6 and thought "hm, using the private forms in that string means that a subclass cannot polymorphically override typename and extras in that message"

[13:04] <jnthn> FROGGS: Almost all the rest of the time is taken up in evaluating the test...

[13:05] <masak> tadzik: usually, I use the ! forms in command methods and the . forms in query methods, for this reason... YMMV.

[13:06] <tadzik> masak: hm, I see

[13:06] <tadzik> but speaking of this nextsame, I found a counter-example

[13:06] <FROGGS> jnthn: looks like I need to profile my use-case and then come up with something sane :o)

[13:06] <tadzik> m: class A { method new { say "new from A" } }; class B is A { }; B.new

[13:06] <camelia> rakudo-moar dca172: OUTPUT¬´new from A‚ê§¬ª

[13:06] <FROGGS> my brane is not very capable of doing this right now sadly

[13:06] <tadzik> so adding a StrictConstructor to B should not change anything

[13:06] <tadzik> so A.new still should get called

[13:07] <tadzik> so nextsame is necessary after all

[13:08] <jnthn> FROGGS: Well, looks like Junction.ACCEPT being slow is muchly to blame.

[13:10] *** sqirrel_ joined
[13:10] <FROGGS> jnthn: k, I'll have a look at that

[13:11] <dalek> ecosystem: ed7482a | tadzik++ | META.list:

[13:11] <dalek> ecosystem: Add ClassX::StrictConstructor

[13:11] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/ed7482a290

[13:12] <tadzik> this name is horrible to type :o

[13:13] <jnthn> FROGGS: Yeah, I can get it down to less than half again with a tweak there

[13:13] *** kaare_ left
[13:13] <tadzik> wow, P5's Moosex::StrictConstructor's code is so complicated by comparison

[13:14] <FROGGS> jnthn: uhh, nice

[13:15] <FROGGS> right now I have the problem that I can't really make v5 pandable because I need to install stuff to nqp's lib folder

[13:18] <dalek> rakudo/nom: f9138ba | jonathan++ | src/core/IO.pm:

[13:18] <dalek> rakudo/nom: Optimize IO::Path.contents default test.

[13:18] <dalek> rakudo/nom: 

[13:18] <dalek> rakudo/nom: Really, we should make Junction.ACCEPTS faster - or junctions faster

[13:18] <dalek> rakudo/nom: in general - but this helps further reduce the awful slowness of

[13:18] <dalek> rakudo/nom: IO::Path.contents.

[13:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9138ba9c5

[13:23] *** Sqirrel left
[13:24] *** sivoais left
[13:25] *** Sqirrel joined
[13:25] <jnthn> bah, there's more LHF in here to optimize too

[13:26] *** spider-mario joined
[13:26] <jnthn> We really need to be more careful in implementing setting things...

[13:27] <jnthn> Sure enough, another .1s off it

[13:27] *** SamuraiJack__ joined
[13:29] <dalek> rakudo/nom: d96eb3f | jonathan++ | src/core/IO.pm:

[13:29] <dalek> rakudo/nom: Don't re-dispatch to other new, just bless.

[13:29] <dalek> rakudo/nom: 

[13:29] <dalek> rakudo/nom: This is the way constructors are meant to be written.

[13:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d96eb3f616

[13:29] <dalek> rakudo/nom: 2e758a8 | jonathan++ | src/core/IO.pm:

[13:29] <dalek> rakudo/nom: Just construct IO::Path, don't go via coercion.

[13:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e758a863b

[13:38] <jnthn> Next up: @list.push

[13:41] <jnthn> m: my @a; @a.push(1); @a[0] = 2; say @a

[13:41] <camelia> rakudo-moar dca172: OUTPUT¬´2‚ê§¬ª

[13:51] *** Pleiades` left
[13:54] *** cognominal left
[13:54] <tadzik> eek

[13:54] *** Pleiades` joined
[13:54] <tadzik> m: my @a; @a.push(1); @a[0] = 2; say @a.perl

[13:54] <camelia> rakudo-moar dca172: OUTPUT¬´Array.new(2)‚ê§¬ª

[13:54] <tadzik> ah

[13:54] <jnthn> Yeah, it's fine 

[13:54] <jnthn> I meant @list.push performance

[13:55] <jnthn> I now have a benchmark that took almost 4s running in < 1s

[13:55] *** cognominal joined
[13:55] <tadzik> nice :)

[13:55] <jnthn> but spectest fails :(

[14:03] *** sqirrel_ left
[14:16] *** spider-mario left
[14:19] *** anaeem1_ left
[14:20] *** anaeem1 joined
[14:23] *** anaeem1_ joined
[14:23] *** anaeem1 left
[14:24] *** thou joined
[14:27] *** Alina-malina left
[14:27] *** anaeem1_ left
[14:28] *** Alina-malina joined
[14:28] *** telex left
[14:29] *** thou left
[14:30] *** telex joined
[14:31] <timotimo> jnthn: excellent work! :)

[14:32] <JimmyZ_> :)

[14:32] *** JimmyZ_ is now known as JimmyZ

[14:32] *** guru joined
[14:33] *** guru is now known as Guest415

[14:33] *** Guest415 is now known as ajr_

[14:34] <FROGGS[mobile]> still very nice improvements :o)

[14:35] <jnthn> Think I got the spectest fails cleared up now too

[14:36] <jnthn> Also looking into the for 1..100000 { } -> while loop opt.

[14:36] <timotimo> oh yay

[14:38] <jnthn> It's a bit of a cheat for the benchmarks, but afaik Perl 5 also does the same cheat. :)

[14:39] <tadzik> :)

[14:44] <JimmyZ> What a cheat!

[14:45] <timotimo> i don't think it's bad to cheat at this; for ^$n loops are pretty common

[14:45] <timotimo> and making them slimmer would be great

[14:45] *** prevost left
[14:45] <JimmyZ> +1

[14:46] *** anaeem1 joined
[14:46] *** denis_boyun_ joined
[14:46] <masak> what's the actual cheat?

[14:46] *** SamuraiJack__ left
[14:47] <timotimo> turn a for loop into a while loop

[14:47] <masak> oh, that sounds totally legit.

[14:47] <timotimo> well, for for loops over ranges, that is

[14:47] <vendethiel> you can just eliminate the loop if it's empty, can't you ?

[14:47] <masak> in the long run, I would only expect us to retain the for-ishness of for loops if we were actually directly using the iterator somehow.

[14:49] <jnthn> 13.5s -> 2.7s. Not bad.

[14:49] <masak> nice.

[14:49] <vendethiel> haha :D.

[14:49] <jnthn> And since this is the outer loop of various benchmarks... :)

[14:50] <masak> m: say "that's around a []x speedup".subst("[]", (13.5 / 2.7).round)

[14:50] <camelia> rakudo-moar 2c54ff: OUTPUT¬´that's around a 5x speedup‚ê§¬ª

[14:50] <timotimo> jnthn: now if we could lower for loops over different iterators, that would be fantastic, too :)

[14:50] <timotimo> but that seems much harder

[14:50] <jnthn> well, yeah, that needs something more

[14:50] <timotimo> that's perhaps something that spesh may do at one point when we have inlining?

[14:50] <jnthn> Not really

[14:51] <jnthn> Really, it wants Rakudo's iterators to be a bit more co-operative in the whole process.

[14:51] *** SamuraiJack__ joined
[14:51] <timotimo> OK; sounds like something the big list re-do would be needed for

[14:52] *** uniejo left
[14:53] *** anaeem1 left
[14:53] <jnthn> aye

[14:54] <jnthn> This opt is useful independent of that, though.

[14:55] *** xfix left
[14:57] *** SamuraiJack__ left
[15:00] <masak> I have some colored diff test routines and recursive data structure colored diff test routines here that I should probably publish as a module or two.

[15:02] <timotimo> i'm confused, what exactly does that do?

[15:03] *** xfix joined
[15:04] * jnthn spectests his range opt along with the push/unshift opts.

[15:05] *** pdurbin left
[15:06] <jnthn> oops, off by one :)

[15:08] * masak .oO( but what's a one between friends, huh? )

[15:08] <jnthn> it's a few failed spectests :P

[15:09] *** cognominal left
[15:09] <jnthn> timotimo: Got a link to the latest bench results you posted, btw?

[15:10] *** cognominal joined
[15:14] <timotimo> gimme a sec

[15:15] <timotimo> 2014-05-12-spesh_log_and_stuff.html and 2014-05-12-spesh_log_and_stuff_sans_startup.html in http://t.h8.lv/p6bench/

[15:15] <timotimo> as well as 2014-05-03-return_types.html or 2014-05-03-moar_progress.html

[15:20] *** sqirrel_ joined
[15:23] <jnthn> Thanks

[15:27] <timotimo> i should build a static website generator thingie for that or something :)

[15:30] *** kaare_ joined
[15:38] <masak> the WAT for the DWIM of implicit boolification is the semipredicate problem.

[15:39] <masak> in other words, your two choices are "suffer through strictness" or "risk confusing 'false' with 'not applicable'"

[15:40] <masak> relatedly, the correct way to spell "is $small part of $large" in code is `defined $large.index($small)`, not `$large.index($small)`

[15:40] <timotimo> oh, yeah :|

[15:40] <timotimo> wouldn't we use ~~ for that?

[15:41] <masak> normally, yes.

[15:41] <masak> but this was inside an action method.

[15:41] <timotimo> ah

[15:41] <masak> and I got an error message saying that I oughtn't mess with $/

[15:42] <timotimo> mhh

[15:42] <dalek> rakudo/nom: ca5ce73 | jonathan++ | src/core/List.pm:

[15:42] <dalek> rakudo/nom: Optimize push and unshift.

[15:42] <dalek> rakudo/nom: 

[15:42] <dalek> rakudo/nom: Often we're just dealing with single items, so add multi candidates

[15:42] <dalek> rakudo/nom: that efficiently handle that case. Need to take a lot of care to get

[15:42] <dalek> rakudo/nom: flattening right. Also some small optimizations in the multi-item

[15:42] <dalek> rakudo/nom: code paths.

[15:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ca5ce73a16

[15:42] <dalek> rakudo/nom: 1a103e7 | jonathan++ | src/Perl6/Optimizer.nqp:

[15:42] <dalek> rakudo/nom: Optimize for 1..100000 { } loops into while loops.

[15:42] <dalek> rakudo/nom: 

[15:42] <dalek> rakudo/nom: This pattern shows up especially often in benchmarks, but can crop up

[15:42] <dalek> rakudo/nom: in various bits of real-world code also.

[15:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1a103e7457

[15:43] <timotimo> # Range operators we can optimize into loops, and how to do it.   ‚Üê this comment reads really weird

[15:43] <jnthn> timotimo: Feel free to improve it

[15:43] <jnthn> timotimo: Also I only did ..

[15:44] <jnthn> timotimo: But the code is easily extensible for ..^, ^.., ^..^ and prefix ^

[15:44] <jnthn> timotimo: I thought you might like to do those? ;)

[15:44] <tadzik> Ilike looking at those optimization commits and wondering under what circumstances an optimizer could do that

[15:44] * masak .oO( range operators we can optimize. and how! ) :P

[15:44] <Juerd> Isn't code for ..^ automatically used by prefix ^? :)

[15:44] <timotimo> can do, thanks for leaving some crumbs :)

[15:45] <jnthn> Juerd: Not sure...not at the level we're analyizing things here

[15:45] <jnthn> It may well call ..^ internally

[15:45] <jnthn> But we can't see into ^

[15:45] <Juerd> I thought ^$x would be translated to 0..^$x before most of the rest

[15:46] <jnthn> - QAST::Op(call &prefix:<^>) ^

[15:46] <jnthn> Seems not.

[15:46] <timotimo> hmm, could compile-time evaluate that to a Range object, no?

[15:47] <masak> long term, I should hope so.

[15:47] <masak> that's just a kind of constant folding, after all.

[15:47] <tadzik> unless .. is redefined in that scope, right?

[15:47] <tadzik> I want to do that:)

[15:47] <timotimo> of course

[15:48] <tadzik> that'll be the second logical step for my first ever patch to rakudo

[15:48] <tadzik> which was the Range.pick optimization :)

[15:48] <timotimo> we always inspect the operators to make sure they are the ones from the setting

[15:48] <tadzik> okay, I'm going to attempt to do it now :)

[15:48] <timotimo> cool

[15:48] <timotimo> there should be an "is_from_setting" method or something

[15:48] <tadzik> I'll probably ask you for your optimization toolkit

[15:49] <tadzik> I mean, "what was that commandline option for dumping ASTs"

[15:49] <timotimo> ah, --target=ast, --target=optimize

[15:53] <timotimo> what's the term for the implicit *%_ on methods again?

[15:54] <tadzik> rakudo has reached the point when I stare at the "Stage parse" line and ask "come on, what takes you so long?" :)

[15:54] <timotimo> interface consistency*

[15:55] <tadzik> huh, 113 seconds

[15:55] <tadzik> ah, that's just powersave mode

[15:58] <tadzik> shouldn't sub infix:<..>($min, $max) be pure?

[15:58] <timotimo> i think it could be, aye

[15:59] <tadzik> then I wouldn't even need to mess with the optimizer probably

[15:59] <timotimo> yes

[15:59] <timotimo> the others from that group should be, too

[15:59] <tadzik> yeah

[15:59] <tadzik> this would shave the whole 1 call from most loop-y benchmarks :o

[16:00] <timotimo> this should also give us a tiny improvement for nested loops

[16:00] <tadzik> yep

[16:00] <timotimo> well, since for loops on ranges are going to turn into while loops anyway, it's not that important ;)

[16:02] <timotimo> we'll also need a candidate for %range_bounds that introspects Range objects rather than operators

[16:03] <tadzik> hmm, adding the pure markers didn't help

[16:03] <timotimo> interesting, maybe the constant folding happens after we look at the other optimization

[16:04] <timotimo> at the moment, the code doesn't handle &infix:<,> being lexically replaced

[16:04] <timotimo> which sounds like a very "interesting" idea in any case

[16:08] <tadzik> ah no, I just forgot about --target=optimize

[16:09] *** cognominal left
[16:09] <jnthn> tadzik: If you put in this, it'll likely completely break the opt I just put in. :(

[16:10] *** cognominal joined
[16:10] *** sivoais joined
[16:10] <jnthn> tadzik: so if you do it, please update the opt too :)

[16:10] <tadzik> jnthn: what purifying the infix:<..>?

[16:10] <jnthn> tadzik: Yeah

[16:10] <jnthn> tadzik: 'cus the thing I just put in loops for a use of the .. op

[16:11] <tadzik> aha

[16:11] <timotimo> it could look at Range objects instead

[16:11] <timotimo> hm

[16:12] <tadzik> huh. if I don --target=ast --target=optimize, all I get is "Unhandled exception: cannot stringify this"

[16:12] <timotimo> does it only look at ranges with QAST::Want endpoints?

[16:12] <timotimo> only one of those targets is allowed

[16:12] <tadzik> ah, that explains stufff :)

[16:13] *** thou joined
[16:14] <timotimo> LTA error still.

[16:14] <timotimo> it probably tries to stringify a list of "ast, optimize" or something?

[16:14] <tadzik> I don't get this: https://gist.github.com/tadzik/c14a7499b1006be2f14c

[16:14] <tadzik> there is Range there, _and_ infix:<..>

[16:15] <timotimo> aye, one for void context

[16:15] <timotimo> for sinking and stuff

[16:15] <timotimo> not 100% sure why

[16:15] <tadzik> doesn't sound necessary

[16:15] <timotimo> i think we only ever optimize one of the two branches or something?

[16:17] *** thou left
[16:18] <tadzik> I wonder if we need optimizer tests, to make sure that new optimizations don't break the old ones :)

[16:19] <timotimo> would be nice if it were easier to run in isolation; we still have some trouble handling classes from NQP i think

[16:19] <timotimo> other than that you can getcomp and call the stages one by one

[16:19] <tadzik> there are 58 pure operators in the setting, and 736 unpure ones. It'd be a nasty surprise if someone (me) purified some of them in a good will, and then make stuff slower by accident

[16:20] <tadzik> well, you could run 'perl6 --target=optimize' and grep for stuff... :P

[16:20] <timotimo> it may be easy enough to grep the optimizer for the names of subs you pure'd

[16:20] <tadzik> there we go

[16:21] <tadzik> or have a superclass of the optimizer that writes logs of opts it makes

[16:21] *** zakharyas joined
[16:24] <timotimo> if we could have lightweight "trace points" in mvm bytecode so that we can output if or how often a given line was hit, that might be interesting

[16:25] *** thou joined
[16:26] * jnthn has a couple of patches that make the reduce_int_comb_range benchmark a little less of a disaster.

[16:26] <timotimo> oh, cool :)

[16:26] <timotimo> we need to get better benchmarks if our microbenchmarks are exhausted for optimization opportunities :)

[16:26] <jnthn> Well, we need more benchmarks.

[16:26] <timotimo> yes

[16:27] <jnthn> One idea I had for the JSON parsing benchmark: write a Perl 5 implementation using Parse::RecDescent and building up a similar data structure.

[16:28] <timotimo> so that the comparison is fair?

[16:28] <dalek> rakudo/nom: 97ad565 | jonathan++ | src/core/Str.pm:

[16:28] <dalek> rakudo/nom: Optimize .comb().

[16:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/97ad5659ac

[16:28] <dalek> rakudo/nom: d201a27 | jonathan++ | src/core/Mu.pm:

[16:28] <dalek> rakudo/nom: Optimize no-args-to-pass case of >>.meth.

[16:28] <dalek> rakudo/nom: 

[16:28] <dalek> rakudo/nom: Easy to check once outside of the hyper and then avoid flattening an

[16:28] <dalek> rakudo/nom: empty Capture in every time.

[16:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d201a27f6e

[16:29] <jnthn> Well, right now there's no Perl 5 impl for that one.

[16:29] <jnthn> So there's no comparison. :)

[16:29] <timotimo> a few months ago i thought about writing a json parser that doesn't use grammars

[16:29] <timotimo> so what you said, but the other way around :)

[16:29] <dalek> panda: 43822c6 | (Tobias Leich)++ | lib/Panda/Fetcher.pm:

[16:29] <dalek> panda: optimize local-fetch by moving things out of the loop

[16:29] <dalek> panda: review: https://github.com/tadzik/panda/commit/43822c6c64

[16:29] <jnthn> But I think that's fair. As a data point, the Petamem modules that will be ported to Perl 6 use Parse::RecDescent and will be re-written using Perl 6 grammars.

[16:29] <timotimo> that sounds good

[16:30] <tadzik> FROGGS[mobile]++

[16:30] <tadzik> FROGGS[mobile]: does it bring a visible improvement in local-fetching?

[16:34] <jnthn> So, final benchmark to see if I can make less awful today is forrest fire :)

[16:35] <FROGGS[mobile]> yeah, I'll give you numbers soonish

[16:36] *** ajr_ left
[16:36] <tadzik> awesome

[16:36] *** guru joined
[16:36] *** guru is now known as ajr_

[16:36] *** ggoebel111116 joined
[16:37] *** breinbaa1 joined
[16:39] *** sorear left
[16:39] *** denis_boyun__ joined
[16:39] *** Shozan joined
[16:39] *** Shozan left
[16:39] *** Shozan joined
[16:39] *** erdic_ joined
[16:41] *** sorear joined
[16:44] *** sivoais left
[16:44] *** denis_boyun_ left
[16:44] *** kurahaupo left
[16:44] *** erdic left
[16:44] *** ggoebel111115 left
[16:44] *** SHODAN left
[16:44] *** breinbaas left
[16:44] *** erdic_ is now known as erdic

[16:47] *** zakharyas left
[16:49] <timotimo> oooh forest fire!

[16:49] <timotimo> there's stuff in there that i wish was moar faster in general

[16:50] <timotimo> also, forest fire is currently b0rked

[16:50] <timotimo> no trees ever set other trees on fire

[16:50] <timotimo> no clue what's going on there

[16:50] *** sivoais joined
[16:51] *** sqirrel_ left
[16:53] <dalek> rakudo/nom: 17ab8d1 | jonathan++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[16:53] <dalek> rakudo/nom: Cache junctional fallbacks in multi-dispatch.

[16:53] <dalek> rakudo/nom: 

[16:53] <dalek> rakudo/nom: This means we can hit the cache in a bunch of junctional dispatch

[16:53] <dalek> rakudo/nom: cases for operators.

[16:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/17ab8d118c

[16:53] <jnthn> timotimo: Hm, I've mostly just paid attention to its runtime :P

[16:54] <jnthn> That helps a little bit. Actually with anything Junction-heavy.

[16:54] <jnthn> Proivded it's the multi-dispatcher that catches it.

[16:57] *** zakharyas joined
[17:08] <timotimo> oh that seems nice!

[17:20] *** ajr_ left
[17:21] *** hoverboard joined
[17:22] *** Rotwang left
[17:24] *** Alina-malina left
[17:24] *** zakharyas left
[17:26] *** zakharyas joined
[17:28] *** daxim left
[17:31] *** anaeem1 joined
[17:33] <FROGGS> eww, panda's rebootstrap.pl infiniloops :/

[17:33] <jnthn> ugh

[17:33] *** vendethiel left
[17:33] <jnthn> Maybe best to bissect to work out what broke it?

[17:34] <FROGGS> yeah

[17:34] *** krunen left
[17:39] <timotimo> ah, that must be why it didn't do anything for a long time last time i tried it

[17:41] *** daxim joined
[17:44] <jnthn> dinner &

[17:51] *** Alina-malina joined
[17:51] *** vendethiel joined
[17:55] *** vendethiel left
[18:05] *** spider-mario joined
[18:08] <FROGGS> jnthn: this one introduces the infiniloop: https://github.com/rakudo/rakudo/commit/2c54ffdc27c021673e0006bfdc4de94ad14a6de4

[18:08] <timotimo> so it could happen that $cwd_chars is as long as $elem itself?

[18:09] <FROGGS> that was possible before

[18:09] <timotimo> er, of course

[18:10] <FROGGS> I think only "next unless $elem ~~ $test;" can be the offending (now missing) line

[18:10] <timotimo> i didn't even look at the other differences m)

[18:10] <timotimo> silly me

[18:12] <timotimo> my god, this thing is ifdef hell

[18:12] <timotimo> hm. well, not quite as bad as i thought

[18:12] <timotimo> but i gotta run now

[18:21] <FROGGS> eww

[18:22] <FROGGS> jnthn: it infiniloops over stuff like that:

[18:22] <FROGGS> path=/home/froggs/dev/nqp/install/languages/perl6/site/lib/../../../nqp/../perl6 elem=..

[18:22] <FROGGS> path=/home/froggs/dev/nqp/install/languages/perl6/site/lib/../../../nqp/../perl6 elem=site

[18:22] <FROGGS> path=/home/froggs/dev/nqp/install/languages/perl6/site/lib/../../../nqp/../.. elem=lib

[18:22] <FROGGS> I print that where the additional 'next' was

[18:22] <FROGGS> so one line before '$elem = nqp::substr($elem, $cwd_chars + 1) if self.is-relative;'

[18:23] <FROGGS> err, one line before '$elem = $SPEC.catfile($!path, $elem) if $!path ne '.';'

[18:23] *** hoverboard left
[18:23] <FROGGS> m: say 1 if 'a' eq 'a' | 'b'

[18:23] <camelia> rakudo-moar 17ab8d: OUTPUT¬´1‚ê§¬ª

[18:24] <FROGGS> m: say 1 if 'a' ne 'a' | 'b'

[18:24] <camelia> rakudo-moar 17ab8d: ( no output )

[18:24] <FROGGS> m: say 1 if 'b' ne 'a' | 'b'

[18:24] <camelia> rakudo-moar 17ab8d: ( no output )

[18:33] *** hoverboard joined
[18:37] <FROGGS> jnthn: this would be my solution: https://gist.github.com/FROGGS/217301b3625f919aaf8d

[18:48] *** rurban_ left
[18:49] <FROGGS> okay, looks like .contents is about 10 to 15% faster

[18:54] *** hoverboard left
[18:55] <pippo> m: my @a; @a.push: $("one,two,three".split(','); say @a[0];

[18:55] <camelia> rakudo-moar 17ab8d: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/U7OWy_zyVS‚ê§Unable to parse expression in contextualizer; couldn't find final ')' ‚ê§at /tmp/U7OWy_zyVS:1‚ê§------> [32m$("one,two,three".split(','); say @a[0];[33m‚èè[31m<EOL>[0m‚ê§    expecti‚Ä¶¬ª

[18:55] <pippo> m: my @a; @a.push: $("one,two,three".split(',')); say @a[0];

[18:55] <camelia> rakudo-moar 17ab8d: OUTPUT¬´‚ê§¬ª

[18:56] *** rurban_ joined
[18:56] <pippo> ^^ Is this correct? 

[18:57] <pippo> m: my @a; @a.push: $(<one two three>); say @a[0];

[18:57] <camelia> rakudo-moar 17ab8d: OUTPUT¬´one two three‚ê§¬ª

[18:58] <FROGGS> m: say "one,two,three".split(',')

[18:58] <camelia> rakudo-moar 17ab8d: OUTPUT¬´one two three‚ê§¬ª

[18:58] <FROGGS> m: say "one,two,three".split(',').item

[18:58] <camelia> rakudo-moar 17ab8d: OUTPUT¬´one two three‚ê§¬ª

[18:59] <FROGGS> hmmm

[18:59] <FROGGS> m: my @a; @a.push: $("one,two,three".split(',')); say @a

[18:59] <camelia> rakudo-moar 17ab8d: OUTPUT¬´‚ê§¬ª

[18:59] <FROGGS> m: my @a; @a.push( $("one,two,three".split(',')) ); say @a

[18:59] <camelia> rakudo-moar 17ab8d: OUTPUT¬´‚ê§¬ª

[18:59] <FROGGS> m: my @a; @a.push( "one,two,three".split(',') ); say @a

[18:59] <camelia> rakudo-moar 17ab8d: OUTPUT¬´one two three‚ê§¬ª

[19:00] <FROGGS> hmmm, I have no idea..

[19:00] <FROGGS> m: my @a; @a.push( "one,two,three".split(',').item ); say @a

[19:00] <camelia> rakudo-moar 17ab8d: OUTPUT¬´‚ê§¬ª

[19:01] *** darutoko left
[19:01] *** FROGGS[mobile] left
[19:04] *** raiph joined
[19:08] <raiph> #perl6: would a P6ian approach to http://www.reddit.com/r/ProgrammingLanguages/comments/260aed/the_safe_construct_on_my_wishlist_for_programming/ be a variant of "use fail"?

[19:11] *** zakharyas left
[19:12] *** zakharyas joined
[19:18] *** Alula left
[19:19] *** rurban_ left
[19:19] *** zakharyas left
[19:23] *** molaf joined
[19:24] *** Vlavv left
[19:30] *** rurban_ joined
[19:36] <masak> raiph: are you thinking of 'use fatal' ?

[19:37] *** Vlavv joined
[19:43] <dalek> rakudo/nom: 2b2ab99 | (Tobias Leich)++ | src/core/IO.pm:

[19:43] <dalek> rakudo/nom: do not accidently take .. into dir's .content

[19:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b2ab994cc

[19:50] *** molaf left
[19:53] *** vendethiel joined
[19:53] <pippo> FROGGS: That was working (at least few weeks ago) and now stopped...

[19:54] <FROGGS> p: : my @a; @a.push( "one,two,three".split(',').item ); say @a

[19:54] <camelia> rakudo-parrot 17ab8d: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/DBamSgz2gH‚ê§Bogus statement‚ê§at /tmp/DBamSgz2gH:1‚ê§------> [32m<BOL>[33m‚èè[31m: my @a; @a.push( "one,two,three".split([0m‚ê§    expecting any of:‚ê§        statement list‚ê§        prefix ‚Ä¶¬ª

[19:54] <FROGGS> p: my @a; @a.push( "one,two,three".split(',').item ); say @a

[19:54] <camelia> rakudo-parrot 17ab8d: OUTPUT¬´one two three‚ê§¬ª

[19:55] <FROGGS> hmmm, so it is moarvm specific...

[19:55] <FROGGS> I guess we should bisect this one

[19:55] <FROGGS> j: my @a; @a.push( "one,two,three".split(',').item ); say @a

[19:56] <camelia> rakudo-jvm 17ab8d: OUTPUT¬´‚ê§¬ª

[19:56] <FROGGS> O.o

[19:58] <vendethiel> j: my @a; @a.push( "one,two,three".split(',').item ); say @a.perl; say "one,two,three".split(',').item.perl;

[19:58] <camelia> rakudo-jvm 17ab8d: OUTPUT¬´Array.new(().list.item)‚ê§("one", "two", "three").list.item‚ê§¬ª

[19:58] <pippo> p: my @a; @a.push: $("one,two,three".split(',')); say @a[0];

[19:58] <camelia> rakudo-parrot 17ab8d: OUTPUT¬´one two three‚ê§¬ª

[19:59] <pippo> n: my @a; @a.push: $("one,two,three".split(',')); say @a[0];

[19:59] *** SevenWolf joined
[19:59] <camelia> niecza v24-109-g48a8de3: OUTPUT¬´one two three‚ê§¬ª

[20:03] *** hoverboard joined
[20:10] <FROGGS> hmmm, building v5 feels ridiculous fast right now

[20:12] <lizmat> good *, #perl6!

[20:12] <lizmat> Files=871, Tests=31480, 200 wallclock secs ( 8.24 usr  3.68 sys + 1245.40 cusr 134.37 csys = 1391.69 CPU)

[20:13] <lizmat> haven't seen a spec test quite so fast in a long time

[20:13] *** daxim left
[20:13] <lizmat> mainly caused by lower CPU usage (I would say about 3% down)

[20:14] <FROGGS> hi lizmat 

[20:15] <lizmat> FROGGS  o/

[20:20] <jnthn> evening o/

[20:21] <lizmat> jnthn o/

[20:22] <dalek> specs: 29d4026 | (Elizabeth Mattijsen)++ | S32-setting-library/IO.pod:

[20:22] <dalek> specs: Specify IO.* return values and Nil on failure

[20:22] <dalek> specs: review: https://github.com/perl6/specs/commit/29d4026292

[20:23] <lizmat> m:say "doesnotexist.t".IO.z

[20:23] <lizmat> m: say "doesnotexist.t".IO.z

[20:23] <camelia> rakudo-moar 17ab8d: OUTPUT¬´0‚ê§¬ª

[20:23] <jnthn> lizmat: Yeah, I think we lost some off startup time perhaps

[20:24] *** anaeem1 left
[20:24] <FROGGS> lizmat: umm, did I messed it up again? √≥.√≤

[20:24] <lizmat> FROGGS: don't worry

[20:25] <lizmat> I'll look at it... 

[20:25] <jnthn> FROGGS: OK, well, doing the test *twice* is really wrong...

[20:25] <lizmat> I also think it should return Nil in that case

[20:25] <lizmat> as with any of the IO.* methods

[20:25] <lizmat> if the path does not exist

[20:26] <FROGGS> Str.index returns (Int) for not found instead of Nil btw

[20:27] *** daxim joined
[20:27] <lizmat> so you'd expect Bool instead of True/False ?

[20:27] <FROGGS> jnthn: yeah, I guess there is still room for improvement :/

[20:27] <FROGGS> lizmat: I don't know what to expect

[20:27] <lizmat> and in the case of IO.s, we'd return an undef Int ?

[20:28] <lizmat> the Int type I mean  :-)

[20:28] <FROGGS> yeah, I dunno

[20:28] <FROGGS> if the file does not exist I'd be happy with Int and/or Nil I think

[20:29] <FROGGS> m: say 'olala'.IO.d

[20:29] <camelia> rakudo-moar 17ab8d: OUTPUT¬´0‚ê§¬ª

[20:30] * lizmat feels a Bool would be too easily interpreted as False

[20:30] <lizmat> m: my Bool $a = Nil

[20:31] <camelia> rakudo-moar 17ab8d: ( no output )

[20:31] <lizmat> m: my Bool $a = Nil; say $a

[20:31] <camelia> rakudo-moar 17ab8d: OUTPUT¬´(Bool)‚ê§¬ª

[20:31] <dalek> rakudo/nom: e16709f | jonathan++ | src/core/Junction.pm:

[20:31] <dalek> rakudo/nom: Optimizations to Junction construction.

[20:31] <dalek> rakudo/nom: 

[20:31] <dalek> rakudo/nom: Means we construct Junctions more quickly, and makes them flatter in

[20:31] <dalek> rakudo/nom: nature.

[20:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e16709f398

[20:31] <dalek> rakudo/nom: 19e085f | jonathan++ | src/core/Junction.pm:

[20:31] <dalek> rakudo/nom: Another Junction.new candidate to avoid wrapping.

[20:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/19e085f00b

[20:31] *** hoverboard left
[20:31] *** Khisanth left
[20:34] <woolfy> First videos of Netherlands Perl Workshop are online now, including talks by lizmat and jnthn: https://www.youtube.com/channel/UCAsxQEJp-ov1qEDNjvLfjCA

[20:34] <woolfy> (thanks to vanHoesel)

[20:34] <jnthn> Also, my talk at Mojoconf this weekend was recorded :)

[20:34] <jnthn> So hopefully will also be online at some point.

[20:35] <lizmat> timotimo: you can finally link to jnthn's reactive programming presentation :-)

[20:35] <lizmat> https://www.youtube.com/watch?v=JROvKKei4u8

[20:35] <jnthn> Anyway, this was the final jnthn talk until YAPC::EU :)

[20:36] <jnthn> timotimo: If you fancy kicking off a p6bench run on the latest improvements, it could be interesting.

[20:44] *** Khisanth joined
[20:50] *** kurahaupo joined
[20:51] *** Alula joined
[20:54] *** spider-mario left
[20:59] *** bjz joined
[21:12] <timotimo> will do that later tonight

[21:12] <timotimo> how many backends? :)

[21:12] *** kaare_ left
[21:14] <jnthn> timotimo: Well, Moar should give us a good idea

[21:15] <timotimo> aye

[21:18] *** hoverboard joined
[21:22] <masak> tadzik: did you see the p6u email about passing excess parameters to .new ?

[21:22] <masak> tadzik: clearly your new constrictor should be advertized here! :D

[21:22] <tadzik> oh, I'll advertise it as soon as I get over the election results :o

[21:24] <lizmat> .oO( boa constrictor? )

[21:24] <jnthn> .oO( StructX::Constrict )

[21:25] <jnthn> .oO( ClassX::StructConstricter :P )

[21:25] <jnthn> beer attempt &

[21:27] * masak looks at election results

[21:27] <masak> ...wow.

[21:29] <tadzik> remember the guy I told you about, that says he candidates to take teh EU money and build a bomb that'll blow it up

[21:30] <masak> yes...?

[21:30] <masak> (uh oh)

[21:31] <tadzik> brb emigrating &

[21:32] <vendethiel> masak: I'm sooo sad.

[21:33] *** FROGGS left
[21:34] *** bjz left
[21:34] <masak> vendethiel: 25%!

[21:34] <masak> vendethiel: what is happening over there!?

[21:34] <vendethiel> I really need to get the fuck out of here.

[21:34] <vendethiel> It's getting literally cancerous

[21:35] <masak> :/

[21:35] <tadzik> vendethiel: where are you?

[21:35] <masak> .fr

[21:35] <vendethiel> tadzik: france

[21:35] <vendethiel> and basically, the nazi won.

[21:35] <masak> tadzik: the racists just got a fourth of the votes.

[21:36] <vendethiel> and not the little racists playing in the sandbox, the racists that you still hear went to fascist stuff and so on...

[21:36] <vendethiel> disgusting

[21:36] <masak> tadzik: their party line seems to be "how about we Ebola those immigrants, eh?"

[21:36] <vendethiel> exactly

[21:36] <tadzik> oh fuck

[21:36] <masak> exactly

[21:36] <vendethiel> well, before I go and lie down to cry, are there other p6 talks in the NLPW::2014 ?

[21:37] <lizmat> how the camel is de-cocooning, but that is really more for Perl 5 people  :-)

[21:37] <vendethiel> lizmat: yeah, I noted your and jnthn's talk already :)

[21:39] <woolfy> The Dutch extreme-right (PVV) seems to have lost 1 or 2 seats.  lizmat and I can stay Dutch for a bit longer...

[21:39] <vendethiel> woolfy: I'll consider coming over

[21:39] <vendethiel> I'm frightened, literally.

[21:40] <vendethiel> well then, g'night y'all :-)

[21:40] <woolfy> vendethiel: i think there is a Dutch company that assimilates a lot of good Perl-developers, you might have a chance...  :-)

[21:42] <vendethiel> masak: it's heil here (;-).)

[21:42] <vendethiel> woolfy: I don't p5, though :)

[21:42] <vendethiel> and I'm still in school. That's really the only reason i'm still in france, actually

[21:42] <masak> .se is behind the curve, but we seem to be building our own flavor of right-wing extremism and xenophobia.

[21:42] <woolfy> vendethiel: I am afraid not much money with p6 can be earned at the moment in The Netherlands...

[21:42] <vendethiel> hehe

[21:43] <masak> well, there's always stealth usage of p6...

[21:43] <vendethiel> .oO( The Masak Ninja )

[21:43] <masak> (1) write something indispensable (2) deploy it (3) people really like it (4) wouldn't you know, it's written in Perl 6!

[21:44] <masak> (5) ... profit!

[21:44] <woolfy> Cloak on!

[21:44] <vendethiel> well, I'm starting to build small blocks to do that :)

[21:45] <vendethiel> I actually had a vision for Styley (p6 css), so I'm gonna try it soon. Sprockets is working, I just need to add filters. And then profit :)

[21:45] <vendethiel> Real g'night now !

[21:45] *** raiph left
[21:46] <masak> 'night, vendethiel 

[22:01] *** denis_boyun__ left
[22:07] <timotimo> this time i'll also run benchmarks with CGOTO=1

[22:08] <dalek> specs: f017efd | (Elizabeth Mattijsen)++ | S32-setting-library/IO.pod:

[22:08] <dalek> specs: Further refinement on IO.x methods

[22:08] <dalek> specs: review: https://github.com/perl6/specs/commit/f017efdf4b

[22:11] *** hoverboard left
[22:13] <dalek> rakudo/nom: d1b16a1 | (Elizabeth Mattijsen)++ | src/core/IO.pm:

[22:13] <dalek> rakudo/nom: Implement initial say / note optimization

[22:13] <dalek> rakudo/nom: 

[22:13] <dalek> rakudo/nom: As suggested by jnthn in https://gist.github.com/jnthn/41dbb7ab7150f6cfd41c

[22:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d1b16a113b

[22:14] <lizmat> other optimization suggested by jnthn currently breaks stuff  :-(

[22:15] <jnthn> timotimo: Feel free also to make CGOTO the default on compilers that support it, if you fancy a little configure work.

[22:15] <jnthn> lizmat: Yeah, I'll ponder that a bit more.

[22:15] <timotimo> no clue how to figure out if that is supported ...

[22:16] <lizmat> we need a better way to read / write files in memory, ala open \$foo in Perl 5

[22:16] <jnthn> beer attempt failed... hotel bar + Sunday night = out of luck

[22:16] <lizmat> :-(

[22:16] <jnthn> lizmat: IO::Capture in the ecosystem? :)

[22:16] <lizmat> shouldn't that be in core then ?

[22:17] <jnthn> Not sure :)

[22:17] <jnthn> We don't have to put *everything* in core. :P

[22:18] <jnthn> We're already well past 20,000 lines of CORE.setting.

[22:18] <lizmat> indeed, but open \$scalar *is* in Perl 5 core

[22:18] <lizmat> and it is really useful

[22:19] <jnthn> So is CGI.pm :P

[22:19] <timotimo> good one! :)

[22:19] <jnthn> I can kinda see the use, yes

[22:19] <lizmat> also: looking at the IO::Capture code: it would also break with your more aggresive optimisation

[22:19] <tadzik> :>

[22:19] <lizmat> CGI.pm is evicted from core in 5.20, or will be in 5.22

[22:19] <jnthn> Yeah, well, we never really did say what we expect you to provide if you implement your own IO mechanism.

[22:20] <jnthn> We should do that.

[22:20] <lizmat> indeed... and we need to, I'm afraid

[22:20] <lizmat> 6.0.0 blocker  :-)

[22:20] <jnthn> Right.

[22:20] <jnthn> Yes, S16 will probably want a going over.

[22:20] <tadzik> do we have a list of those? :)

[22:21] <jnthn> I haven't look at it closely in a while. It used to be this huge bong-full of weird, but I get the impression it's been made at least somewhat saner. :)

[22:24] <timotimo> actually, no CGOTO=1 this time (i can't easily get it in there without much hassle)

[22:25] <jnthn> ok

[22:25] <jnthn> But my "if you want to patch Configure" offer/request stands ;)

[22:25] <jnthn> It's potentially a nearly-free several percent win on everything.

[22:26] <jnthn> lizmat: I wonder if maybe we want some role that provides things like a .say that can delegate to .print, to keep down the amount needed. And similar such things.

[22:26] <timotimo> fair enough

[22:26] <timotimo> also, --configure=3 will probably not make it into the benchmark

[22:26] <timotimo> er

[22:26] <timotimo> --optimize=3 of course

[22:26] <lizmat> jnthn: I was thinking among similar lines

[22:27] <timotimo> oh, wait, can i give --gen-moar options?

[22:28] <timotimo> if i can, the configure.pl --help output doesn't say

[22:30] <lizmat> jnthn: does nqp::p6box_i box to Int or int ?

[22:30] <lizmat> I guess int, right?

[22:30] <jnthn> Int

[22:30] <jnthn> int isn't an object type, it's a native type

[22:31] <jnthn> So it's unboxed

[22:31] <lizmat> ok, *phew*

[22:31] <lizmat> I feared we would have a problem with files > 4G in size

[22:31] <jnthn> int on MoarVM and JVM is 64-bit anyway... :)

[22:32] <jnthn> (EU election results) arrrgghhhh, wtf :/

[22:32] <lizmat> indeed  :-(

[22:34] <masak> "oh shit, there goes the planet" -- Space Balls

[22:36] <timotimo> oh hey

[22:36] <timotimo> the tools/lib/NQP/Configure.pl files have diverged a bit

[22:37] <timotimo> it seems like there were changes made to gen_nqp in rakudo which weren't ever needed in nqp/ because nqp never gets --gen-nqp

[22:37] <timotimo> but i think the files should still be kept in sync if possible

[22:37] <lizmat> if these files need to be kept in sync, maybe they should be generated from a common source ?

[22:37] <jnthn> timotimo: Makes sense to me

[22:38] <timotimo> and it ought to have --moar-option to go along with --parrot-option IMO.

[22:38] <timotimo> that would make my life easier with p6bench :)

[22:39] <lizmat> IO.changed and friends currently return Int

[22:39] <timotimo> oh, interesting

[22:39] <lizmat> shouldn't that a DateTime ?

[22:39] <timotimo> NQP/Configure.pl already seems to know about --moar-options

[22:39] <timotimo> er, --moar-option actually

[22:40] <timotimo> i'm not sure the unconditional push @opts, "--optimize" would be right if --moar-option has a --optimize=n in it

[22:43] <timotimo> hm

[22:44] <timotimo> did my mail answer to the passing excess arguments thread reach the mailing list?

[22:44] <timotimo> i don't see the bounce

[22:46] <dj_goku> jnthn: wow, just walked your talk on Reactive Programming in P6! awesome stuff.

[22:46] <timotimo> walk the talk!

[22:46] <dj_goku> s/walked/watched/

[22:46] <dj_goku> :D

[22:46] <timotimo> :3

[22:46] <timotimo> i liked that talk very much, too

[22:46] <jnthn> :)

[22:46] <jnthn> It was a fun talk to give

[22:47] <timotimo> and it seemed like you and liz had lots of fun preparing for it :)

[22:47] <dj_goku> That is the type of thing I have a hard time wrapping my head around. I hope with P6 it'll make it easier to do.

[22:47] <lizmat> dj_goku: that's the idea  :-)

[22:49] <lizmat> BTW, I'm starting to wonder whether the IO.x methods shouldn't just return an unthrown X::PathDoesNotExist exception if the path does not exist

[22:49] <lizmat> return just a Bool (rather than True or False) feels dangeroue

[22:50] <lizmat> in the sense that a Bool might be easily interpretable as a False

[22:50] <dj_goku> lizmat: awesome.

[22:50] <timotimo> yeah, the same pitfall with "defined @list.index($item)"

[22:50] <jnthn> Teaching tomorrow, so sleep...

[22:51] <jnthn> 'night, #perl6

[22:51] <lizmat> gnight jnthn !

[22:51] <timotimo> gnite jnthn!

[22:57] *** colomon joined
[22:57] <colomon> o/

[22:58] <timotimo> i'd love to get some concurrency-using benchmarks into the benchmark suite

[22:59] <lizmat> colomon o/

[22:59] <lizmat> timotimo: wish we did not have to mark so many S17 tests as todo / skip  :-(

[22:59] <timotimo> aye :(

[23:03] *** stux|away is now known as stux|away|away

[23:04] * colomon programmed mandelbrot to use promises while up at the in-laws' cabin...

[23:05] <colomon> now pushed to github.

[23:05] <colomon> afk # 5yo bedtime

[23:05] <lizmat> gnight colomon!

[23:06] <timotimo> cool! :)

[23:06] <timotimo> 5 years of bedtime? :o

[23:06] <lizmat> hmm.. I thought: that's early for colomon to go to bed  :-)

[23:11] <dalek> rakudo/nom: c32fb15 | (Elizabeth Mattijsen)++ | src/core/IO.pm:

[23:11] <dalek> rakudo/nom: IO.* methods return type if path doesn't exist

[23:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c32fb15e38

[23:11] <masak> 'night, #perl6

[23:11] <lizmat> gnight masak!

[23:12] *** hoverboard joined
[23:14] <timotimo> gnite masak!

[23:16] <lizmat> does .s on a directory make sense ?

[23:17] <masak> it does in Perl 5.

[23:18] <masak> really sleep &

[23:18] <geekosaur> it *does something* in perl5. I don't think it *makes sense* though; it just treats a dir like a file

[23:19] <geekosaur> (this means in particular that if a directory exists, -s will always pass)

[23:20] <lizmat> oddly enough we're checking for "regular file" in Perl 6 for -z, but not for -s

[23:21] <geekosaur> (also it will fail oddly if the filesystem does not treat directories like files)

[23:22] *** Timbus_ left
[23:23] <lizmat> so, this feels like it could use some improvement...  :-)

[23:24] *** Timbus joined
[23:26] *** BenGoldberg joined
[23:27] <timotimo> 28/43 of the first run of 2, maybe i'll add a fresh perl5 run after that

[23:27] <timotimo> given i've got a newer gcc this time around

[23:28] <flussence> .oO( but what if you're using the anti-feature from ancient reiser4fs versions where files can act like directories?! :)

[23:30] * geekosaur gives flussence OS/400

[23:31] <lizmat> well, either both .s and .z should check for fileness, or they both shouldn't

[23:31] <colomon> timotimo: 5-year-old, as in my son.  ;)

[23:32] <timotimo> i know ;)

[23:32] <timotimo> i must say i'm pretty glad jnthn was able to find some stuff to improve in junctions

[23:33] <colomon> so, between cleaning up the control loops and doing a very naive parallelization, a mandelbrot that took 120 seconds two days ago takes 20 seconds today.

[23:33] <timotimo> junctions being a very expressive syntax feature that sadly gets pretty costly easily

[23:33] <timotimo> \o/

[23:35] <colomon> interestingly, moar is significantly faster than jvm for this, but returns slightly wrong answers.

[23:35] <lizmat> urgh?

[23:36] <timotimo> slightly wrong, eh?

[23:36] <timotimo> would you be able to extract some tests from that?

[23:36] <flussence> fun with floats/big ints?

[23:36] <timotimo> complex i believe

[23:36] <timotimo> uses Num inside

[23:37] <timotimo> or num i guess

[23:38] <colomon> It's Complex, which is num inside, I believe.

[23:38] <colomon> but it's not the math, it's the parallel code.

[23:38] <timotimo> er, did i write Complex?

[23:38] <timotimo> we don't have that yet

[23:38] <lizmat> colomon: how are you parallelizing ?

[23:38] <colomon> we call complex Complex

[23:38] <timotimo> there's some trouble with $_, $/, $! maybe being re-used accidentally

[23:38] <colomon> lizmat: promise

[23:39] <colomon> there is a $_ in there, hmm...

[23:39] <timotimo> try to my $_ nearby and see if that improves things

[23:39] <timotimo> we definitely need to correct this in the future, though

[23:40] * colomon just changed $_ to a proper variable

[23:40] <timotimo> now that for ^10 is much quicker, maybe we can have the same treatment for for ^10 X ^10 or something :)

[23:40] <colomon> nope, still wrong

[23:41] <timotimo> ah dang

[23:42] <colomon> http://www.harmonyware.com/pictures/moar.png demonstrates what I mean by slightly wrong

[23:42] <dalek> rakudo/nom: 501a702 | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[23:42] <dalek> rakudo/nom: Make IO.x fail with typed exceptions

[23:42] <dalek> rakudo/nom: 

[23:42] <dalek> rakudo/nom: This breaks some tests, but it feels right to have checks on non-existing

[23:42] <dalek> rakudo/nom: paths fail.  But perhaps not right enough for TimToady.  So please revert this

[23:42] <dalek> rakudo/nom: patch if it is too late to be breaking behaviour like this away from Perl 5.

[23:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/501a70270b

[23:42] <timotimo> wow, ouch

[23:43] <lizmat> colomon: I assume you mean the blue spec noise ?

[23:43] <colomon> lizmat: it's not all blue, but yes.

[23:43] <timotimo> yeah, seems like it gets results from the wrong spots

[23:43] <timotimo> and if you remove the number of concurrent threads it gets better?

[23:44] <colomon> timotimo: I believe so, but hold a moment.  (switch to jvm to generate a correct one)

[23:44] <timotimo> Failed to run command: install/bin/perl6 --optimize=3 /home/timo/perl6/bench/perl6/rc-forest-fire 16 16 8

[23:44] <timotimo> :\

[23:45] <colomon> here's what it should look like: http://www.harmonyware.com/pictures/jvm.png

[23:45] <timotimo> yeah

[23:45] <lizmat> TimToady: if this approach to IO.* methods on non-existing paths is ok, I'll adapt the spec and tests accordingly

[23:45] <timotimo> how much faster is moar at this?

[23:46] <colomon> timotimo: about 19s vs 32s.

[23:46] <timotimo> mhh, not bad :)

[23:46] <colomon> (that's rough, and counting start-up time)

[23:46] <timotimo> yeah, start-up for jvm is about 6s on one of my machines

[23:47] <timotimo> running a 2014.05 rakudo benchmark now

[23:47] <colomon> seems like it's about that here as well

[23:48] <colomon> anyway, the crazy thing about this is I just looped on all the lines of the graphic and used start to generate a promise for each.  something like 701 threads.

[23:48] <timotimo> well, those aren't "threads" per se

[23:48] <timotimo> just "jobs"

[23:48] <colomon> yeah, wasn't sure.

[23:48] <colomon> it's definitely running them in parallel

[23:49] <colomon> I can confirm the non-parallel version works fine in moar.

[23:49] <timotimo> i think the thread pool scheduler has a default max thread value built in

[23:49] <timotimo> rather than asking the computer what's sensible

[23:49] <lizmat> 32 atm

[23:49] <timotimo> oh, wow.

[23:50] <timotimo> we have enough ram for that? ;)

[23:50] <timotimo> well, i suppose an extra thread is somewhat cheap

[23:50] <lizmat> actually: 16

[23:50] <lizmat> submethod BUILD(:$!initial_threads = 0, :$!max_threads = 16) {

[23:50] <timotimo> OK

[23:51] <lizmat> threads are cheap, they're not P5 ithreads  :-)

[23:51] <flussence> this *might* be the same root problem I was having with moar + threads going haywire, for me it looked like they were scribbling over each other's state

[23:51] <timotimo> yes, that could be the case

[23:52] <timotimo> there are no regexes involved, right?

[23:52] <lizmat> that may well be the case, and it's sort of on jnthn's radar

[23:52] <timotimo> i once had code where that was problematic

[23:52] <timotimo> when i put a lock around the piece of code where a regex was smartmatched against, it worked

[23:52] <colomon> check this out:

[23:52] <colomon> real	0m18.327s

[23:52] <colomon> user	2m5.557s

[23:52] <colomon> that's moar again.

[23:52] <lizmat> m: await do for ^1000 { start { 1 for ^10000; .print } }

[23:52] <camelia> rakudo-moar d1b16a: OUTPUT¬´(signal )¬ª

[23:53] <lizmat> ^^^  segfaulting  :-(

[23:53] <timotimo> :o

[23:54] <flussence> Mine was a test file that called .trans on a few dozen things... not regex. Most of the errors seemed to be coming from around that call though

[23:55] <timotimo> i wonder if trans uses regex internally

[23:55] <lizmat> well, the above example, segfaults without any regexes involved

[23:55] <timotimo> yes

[23:56] <colomon> I seem to be seeing very occasional segfaults as well.

[23:56] <timotimo> i think there's some thread sanitization tools much like ASAN

[23:56] <timotimo> that may be worth investigating

[23:56] <lizmat> like I said, it's on jnthn's radar, but he needs some Quality Time to get to the bottom of it

[23:57] <timotimo> right

[23:58] <colomon> yeah, definite issues here running under moar.

[23:58] <colomon> just tried a very small mandelbrot set.

[23:58] <colomon> ran in under a second the first two tries, segfaulted the third time.

[23:59] <flussence> oh well... at least now I know it's not just my crappy coding to blame again :D

[23:59] *** volodin661 left
[23:59] <timotimo> right

[23:59] <lizmat> ok, it's midnight UTC now, time to go to bed

[23:59] <timotimo> we should probably hold off on tooting the "perl6 concurrency is awesome on moar!" for a bit longer

[23:59] <lizmat> gnight #perl6!

[23:59] <timotimo> gnite lizmat :)

