[00:00] <ab5tract> semicolons?

[00:00] <TimToady> m: say ( < 4 23 33 21 22 21 >; <12 23 22 41 2>; <5 7 2>)

[00:00] <camelia> rakudo-moar 012450: OUTPUT«4 23 33 21 22 21 12 23 22 41 2 5 7 2␤»

[00:00] <TimToady> m: say ( < 4 23 33 21 22 21 >; <12 23 22 41 2>; <5 7 2>).perl

[00:00] <camelia> rakudo-moar 012450: OUTPUT«("4", "23", "33", "21", "22", "21"; "12", "23", "22", "41", "2"; "5", "7", "2")␤»

[00:00] <TimToady> hmm

[00:00] <TimToady> that's supposed to LoL now

[00:01] <TimToady> m: say ( < 4 23 33 21 22 21 >; <12 23 22 41 2>; <5 7 2>).WHAT

[00:01] <camelia> rakudo-moar 012450: OUTPUT«(LoL)␤»

[00:01] <BenGoldberg> At least the semicolons are there in the output

[00:01] <TimToady> oh, you're right, they are

[00:01] <TimToady> m: say ( < 4 23 33 21 22 21 >; <12 23 22 41 2>; <5 7 2>)[1]

[00:01] <camelia> rakudo-moar 012450: OUTPUT«12 23 22 41 2␤»

[00:02] *** woosley left
[00:02] <TimToady> m: say ( < 4 23 33 21 22 21 >; 1,1,*+*...* ; <5 7 2>)[1][100]

[00:02] <camelia> rakudo-moar 012450: OUTPUT«573147844013817084101␤»

[00:02] *** woosley joined
[00:04] <TimToady> m: say zip( < 4 23 33 21 22 21 >; 1,1,*+*...* ; <5 7 2>)

[00:04] <camelia> rakudo-moar 012450: OUTPUT«4 1 5 23 1 7 33 2 2␤»

[00:06] <grondilu> TimToady: looking at http://rosettacode.org/wiki/Iterated_digits_squaring#Perl_6, I notice that at some point the division of two integers is computed with infix:<div>, and then the remainder is computed.  Shouldn't there be a version of the integer division that returns both the dividend and the remainder?

[00:07] *** cognome left
[00:07] <grondilu> (because I thought normally when you do the euclidean division you get both for the same price)

[00:08] *** cognome joined
[00:08] <grondilu> I'm not sure that would improve performance a lot but still it was nagging me a bit. 

[00:08] *** cognome left
[00:09] *** cognome joined
[00:11] <TimToady> we've discussed that here, but it really depends on how smart the optimizer is whether it makes sense to provide a combined op

[00:11] <TimToady> a smart optimizer will notice the common code and move it out front, and leave the register returns where they need to be

[00:11] *** dayangkun joined
[00:11] <TimToady> we don't do that yet though

[00:13] <TimToady> that being said, I could see a kind of listy divmod for repeated extraction of lower parts, such as for extracting seconds and minutes from time values

[00:13] <TimToady> but that would be more for user convenience

[00:14] *** cognome left
[00:14] <grondilu> ok

[00:14] <TimToady> so you could say something like $time divmod (60,60,24)

[00:14] *** Jerry joined
[00:15] <TimToady> or express getting all the digits out with $integer divmod 10 xx *

[00:16] <grondilu> ^ that'd be coold.  In RC I often struggle a bit to get the base decomp of an integer

[00:17] <TimToady> but maybe since it returns the mod before the div, it should be called "moddiv", or "mods" or some such

[00:18] * grondilu wonders if there's an even smarter way to do this with a triangular reduction

[00:19] <TimToady> well, you'd have to bake the modulus into the operator

[00:20] <TimToady> and it's sort of inside out from a normal list->scalar notion

[00:20] <grondilu> yeah that would not fly

[00:20] <TimToady> [\op] $num, 10 xx * or some such

[00:21] <zacts> ok, I will read this when I get the time this weekend, but does Perl6 allow you to use Perl5 modules within Perl6 code?

[00:21] <TimToady> trouble is the partial product is a list in the 2nd iteration

[00:21] <TimToady> maybe it's not triangular

[00:22] <BenGoldberg> @whatever = $integer remainders 10;

[00:22] <TimToady> well, the problem is that it has to return two different things

[00:22] <grondilu> so if I want to get say the 256-based decomposition of an integer in perl6, what's the best way to do it?

[00:23] <TimToady> m: say 123456789.base(256)  # won't work

[00:23] <camelia> rakudo-moar 012450: OUTPUT«base must be between 2 and 36, got 256␤  in method gist at src/gen/m-CORE.setting:13262␤  in sub say at src/gen/m-CORE.setting:14195␤  in block <unit> at /tmp/7bdg_NrYNi:1␤␤»

[00:24] <TimToady> m: say :256[1,2,3,4]

[00:24] <camelia> rakudo-moar 012450: OUTPUT«16909060␤»

[00:24] <BenGoldberg> sub infix:<divmod>($numer, $denom) { $numer div $denom, $numer %% $denom }; say 1234567 divmod 256 xx *;

[00:24] <TimToady> we allow that direction though

[00:24] <BenGoldberg> m: sub infix:<divmod>($numer, $denom) { $numer div $denom, $numer %% $denom }; say 1234567 divmod 256 xx *;

[00:24] <camelia> rakudo-moar 012450: OUTPUT«(timeout)»

[00:25] <grondilu> in RC I often have to do:  gather while $n > 0 { take $n % $base; $n div= $base }  # not the most elegant

[00:25] <TimToady> BenGoldberg: we were thinking of the precedence as 1234567 divmod (256 xx *)

[00:25] <TimToady> but you're defining it the other way there

[00:25] <BenGoldberg> m: sub infix:<divmod>($numer, $denom) { $numer div $denom, $numer %% $denom }; say 1234567 divmod (256 xx *);

[00:25] <camelia> rakudo-moar 012450: OUTPUT«Cannot call 'infix:<div>'; none of these signatures match:␤:(Int:D \a, Int:D \b)␤:(int $a, int $b --> int)␤  in sub infix:<divmod> at /tmp/YzgQFrgekW:1␤  in block <unit> at /tmp/YzgQFrgekW:1␤␤»

[00:26] <grondilu> couldn't we get a Int.base($n where $n > 36) candidate?

[00:26] <TimToady> p6 is not going to intuit list processing for you

[00:26] <TimToady> grondilu: probably, since :256 works

[00:27] <grondilu> or a :$numeric!

[00:27] <TimToady> no, that syntax is taken

[00:27] <grondilu> oh?

[00:27] <grondilu> no I mean:

[00:27] <grondilu> hang on

[00:27] <TimToady> m: my $numeric = 42; say (:$numeric)

[00:27] <camelia> rakudo-moar 012450: OUTPUT«"numeric" => 42␤»

[00:28] <grondilu> say 8.base(2, :numeric); # would return [1, 0, 0, 0] instead of "1000"

[00:28] <ab5tract> TimToady, #perl6: thanks for the discussion! have a good night

[00:28] <TimToady> o/

[00:29] *** ab5tract left
[00:29] <TimToady> grondilu: yes, that seems reasonable-ish, and it's just mandatory for >36

[00:29] <grondilu> or say 8.base(2, :list)

[00:31] <TimToady>  m: sub infix:<divmod>($numer, @denom) { gather for @denom, 999999999999999999999999 -> $denom { take $numer % $denom; $numer div= $denom } }; say 1234567 divmod (256 xx *)

[00:32] <camelia> rakudo-moar 012450: OUTPUT«===SORRY!===␤Cannot assign to a readonly variable or a value␤»

[00:32] <TimToady>  m: sub infix:<divmod>($numer is copy, @denom) { gather for @denom, 999999999999999999999999 -> $denom { take $numer % $denom; $numer div= $denom } }; say 1234567 divmod (256 xx *)

[00:32] <camelia> rakudo-moar 012450: OUTPUT«(timeout)»

[00:32] <TimToady>  m: sub infix:<divmod>($numer is copy, @denom) { gather for @denom -> $denom { take $numer % $denom; $numer div= $denom } }; say 1234567 divmod (256 xx *)

[00:32] <camelia> rakudo-moar 012450: OUTPUT«(timeout)»

[00:32] <TimToady> oh, duh

[00:33] <TimToady>  m: sub infix:<divmod>($numer is copy, @denom) { gather for @denom -> $denom { take $numer % $denom; $numer div= $denom || last } }; say 1234567 divmod (256 xx *)

[00:33] <camelia> rakudo-moar 012450: OUTPUT«(timeout)»

[00:33] <TimToady>  m: sub infix:<divmod>($numer is copy, @denom) { gather for @denom -> $denom { take $numer % $denom; $numer div= $denom or last } }; say 1234567 divmod (256 xx *)

[00:33] <camelia> rakudo-moar 012450: OUTPUT«135 214 18␤»

[00:34] <grondilu> m: say (-> $n, $b { $n < $b ?? $b !! ($n % $b, &?ROUTINE($n div $b, $b))(8, 2)

[00:34] <camelia> rakudo-moar 012450: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/r0jPkZAtiD␤Unable to parse expression in block; couldn't find final '}' ␤at /tmp/r0jPkZAtiD:1␤------> [32m$n % $b, &?ROUTINE($n div $b, $b))(8, 2)[33m⏏[31m<EOL>[0m␤    expecting any of…»

[00:34] <grondilu> m: say (-> $n, $b { $n < $b ?? $b !! ($n % $b, &?ROUTINE($n div $b, $b)) })(8, 2)

[00:34] <camelia> rakudo-moar 012450: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ArdprDSibu␤Undeclared routine:␤    &?ROUTINE used at line 1␤␤»

[00:34] *** cognome joined
[00:34] <TimToady>  m: sub infix:<divmod>($numer is copy, @denom) { gather for @denom -> $denom { take $numer % $denom; $numer div= $denom or last } }; say 1234567 divmod (10 xx *)

[00:34] <camelia> rakudo-moar 012450: OUTPUT«7 6 5 4 3 2 1␤»

[00:34] * grondilu always forgot the name for the anonymous recursion

[00:35] <TimToady> -> isn't a routine

[00:35] <grondilu> m: say (-> $n, $b { $n < $b ?? $b !! ($n % $b, &?BLOC($n div $b, $b)) })(8, 2)

[00:35] <camelia> rakudo-moar 012450: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Bz_phZDVYh␤Undeclared routine:␤    &?BLOC used at line 1␤␤»

[00:35] <TimToady> try sub ($a, $b)

[00:35] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $b !! ($n % $b, &?ROUTINE($n div $b, $b)) })(8, 2)

[00:35] <camelia> rakudo-moar 012450: OUTPUT«0 0 0 2␤»

[00:36] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $n !! ($n % $b, &?ROUTINE($n div $b, $b)) })(8, 2)

[00:36] <camelia> rakudo-moar 012450: OUTPUT«0 0 0 1␤»

[00:37] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $n !! ($n % $b, &?ROUTINE($n div $b, $b)) })(1234567, 10)

[00:37] <camelia> rakudo-moar 012450: OUTPUT«7 6 5 4 3 2 1␤»

[00:38] <TimToady> that's gotta be pretty slow, but then, so is gather/take

[00:39] <TimToady> we don't do tail recursion optimization

[00:39] <grondilu> isn't that a pity?

[00:39] <grondilu> I remember I've already been explained, but still...

[00:39] <TimToady> it's an unnatural act for computers, even if mathematicians like it :)

[00:40] <grondilu> would it be possible to allow it when explicitely requested?  Like:  "use tail-recursion;"

[00:40] <TimToady> probably

[00:41] <grondilu> ok.  Maybe long term, then.

[00:43] <TimToady> the hardest bit is not the tail recursion itself, but managing everything else around it, like return value construction, and stack frame maintenance if you want your introspection to pretend it really did make N new frames

[00:47] <TimToady> another problem is that you're really constructing (7, (6, (5, (4, (3, (2, (1, (0)))))))) there in terms of Parcels, and you're assuming it's all just going to flatten

[00:47] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0)))))))).perl

[00:47] <camelia> rakudo-moar 012450: OUTPUT«(7, (6, (5, (4, (3, (2, (1, 0)))))))␤»

[00:48] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0)))))))).flat.perl

[00:48] <camelia> rakudo-moar 012450: OUTPUT«(7, 6, 5, 4, 3, 2, 1, 0).list␤»

[00:48] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0)))))))).tree.perl

[00:48] <camelia> rakudo-moar 012450: OUTPUT«(7; 6, (5; 4, (3; 2, (1; 0).item).item).item).item␤»

[00:48] <TimToady> hah, that's funny

[00:48] <TimToady> it lols every other layer

[00:49] <TimToady> might have to tune that a bit

[00:50] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0))))))))[1;1;1;0]

[00:50] <camelia> rakudo-moar 012450: OUTPUT«␤»

[00:50] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0))))))))[0]

[00:50] <camelia> rakudo-moar 012450: OUTPUT«7␤»

[00:51] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0))))))))[1][0]

[00:51] <camelia> rakudo-moar 012450: OUTPUT«6␤»

[00:51] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0))))))))[1;0]

[00:51] <camelia> rakudo-moar 012450: OUTPUT«␤»

[00:51] <TimToady> something wrongish there

[00:51] *** xinming_ joined
[00:51] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0)))))))).tree[1;0]

[00:51] <camelia> rakudo-moar 012450: OUTPUT«6␤»

[00:51] <TimToady> I guess [1;0] doesn't work on parcels yet

[00:51] *** xinming left
[00:51] <TimToady> m: say (7, (6, (5, (4, (3, (2, (1, (0)))))))).tree[1;1;1;0]

[00:52] <camelia> rakudo-moar 012450: OUTPUT«4␤»

[00:56] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $n !! ($n % $b, &?ROUTINE($n div $b, $b)) })(1234567, 10).tree

[00:56] <camelia> rakudo-moar 012450: OUTPUT«7 6 5 4 3 2 1␤»

[00:56] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $n !! ($n % $b, &?ROUTINE($n div $b, $b)) })(1234567, 10).perl

[00:56] <camelia> rakudo-moar 012450: OUTPUT«(7, (6, (5, (4, (3, (2, 1))))))␤»

[00:57] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $n !! ($n % $b, @&?ROUTINE($n div $b, $b)) })(1234567, 10).perl

[00:57] <camelia> rakudo-moar 012450: OUTPUT«Cannot find method 'postcircumfix:<( )>'␤  in sub  at /tmp/7FNp1XSdtL:1␤  in block <unit> at /tmp/7FNp1XSdtL:1␤␤»

[00:57] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $n !! ($n % $b, @(&?ROUTINE($n div $b, $b))) })(1234567, 10).perl

[00:57] <camelia> rakudo-moar 012450: OUTPUT«(7, (6, 5, 4, 3, 2, 1).list)␤»

[00:57] <grondilu> hum

[00:57] <grondilu> m: say (sub ($n, $b) { $n < $b ?? $n !! @($n % $b, @(&?ROUTINE($n div $b, $b))) })(1234567, 10).perl

[00:57] <camelia> rakudo-moar 012450: OUTPUT«(7, 6, 5, 4, 3, 2, 1).list␤»

[01:05] *** jack_rabbit_ left
[01:12] *** hagiri joined
[01:12] <TimToady> m: say @(1,2).WHAT

[01:12] <camelia> rakudo-moar 012450: OUTPUT«(List)␤»

[01:14] *** FROGGS_ joined
[01:15] <hagiri> hi all

[01:15] <hagiri> ;P

[01:17] *** FROGGS left
[01:18] <timotimo> o/

[01:18] <timotimo> i just ruined my first 3d print %)

[01:20] *** kyun joined
[01:22] <timotimo> about to ruin my second :)

[01:23] <TimToady> forgot to put a formfeed in there, did you?  :P

[01:25] <kyun> Have anybody use perl6 on Windows?

[01:26] <kyun> I compile it faild

[01:26] <hagiri> kyun, ye, download rakudo man

[01:26] <hagiri> =)

[01:26] <[Coke]> http://blogs.perl.org/users/ovid/2014/08/try-rakudobrew-and-play-with-concurrency.html

[01:26] *** kurahaupo left
[01:26] <[Coke]> ovid++

[01:28] <hagiri> for win no have mystery kyun

[01:28] <TimToady> curtispoe++ in here

[01:28] <hagiri> :)

[01:28] * TimToady -> drums &

[01:28] <kyun> I followed it but... 

[01:33] <[Coke]> our primary developer is on windows, so we know it works there for someone.

[01:33] <[Coke]> What did you download? how did you try to build it? what was the failure?

[01:36] <kyun> I use Rakudo, followed the man

[01:37] <kyun> I think that it lack something,

[01:41] *** kurahaupo joined
[01:47] <zacts> wow, you guys have been doing lots of stuff

[01:49] *** mberends left
[01:50] <[Coke]> which rakudo.

[01:50] <[Coke]> what url did you download from?

[01:50] <[Coke]> what commands did you run?

[01:50] <kyun> And rakudo stopped in 2014.04？

[01:51] <[Coke]> what output did they generate? (you can use a service like http://gist.github.com to write down the answers and paste in the commands & output

[01:51] <[Coke]> kyun: I am guessing that you are referring to the windows MSI?

[01:52] <kyun> I want the newest perl6, so I try to build it.

[01:52] <[Coke]> and also that you are refering to Rakudo *, not the compiler-only release.

[01:52] <[Coke]> kyun: please be specific about what you're trying to do.

[01:53] *** hagiri left
[01:53] <kyun> Coke: OK

[01:54] <kyun> Follow the http://rakudo.org/how-to-get-rakudo/

[01:54] <[Coke]> there hasn't been a rakudo * release in a few months, but we have done monthly compiler-only releases every month.

[01:55] *** firefish5000 left
[01:55] <kyun> Now I try to compile rakudo-2014.08 on Windows

[01:55] <[Coke]> you skipped a step.

[01:56] <[Coke]> I assume you clicked on http://rakudo.org/downloads/star/. ?

[01:56] <zacts> also, is there a Perl6 social semi-offtopic channel?

[01:56] <[Coke]> whoops.

[01:56] <kyun> No No

[01:56] <[Coke]> ok, you went to http://rakudo.org/downloads/rakudo/

[01:57] <kyun> Yes, I have download it 

[01:57] <[Coke]> ok. so you grabed the latest release, what command did you try to use to configure/build rakudo?

[01:58] <kyun> perl Configure.pl --gen-moar --gen-nqp --backends=jvm,moar

[02:02] <[Coke]> ok. seems reasonable so far. What error did you get during the build? (I assume there's a lot of build output, if you could paste it into gist.github.com and share the URL, that'd help.

[02:02] <kyun> OK, I try to build it again, thank you.

[02:05] <kyun> Oh, it need git, and I download

[02:14] <[Coke]> Yes, the compiler doesn't bundle Moar or NQP, and you'll need a command line git available.

[02:14] <[Coke]> Rakudo * bundles snapshots of everything

[02:14] <[Coke]> Apologies, there are a lot of moving parts the first time you build.

[02:15] <[Coke]> I may drop off soon, but I'm sure someone else will be aroudn to help you if you get stuck again. 

[02:16] *** kaleem joined
[02:23] <kyun> Thanks for your help

[02:30] *** telex left
[02:32] *** telex joined
[02:36] *** noganex_ joined
[02:39] *** noganex left
[03:04] *** ren1us2 left
[03:09] *** BenGoldberg left
[03:24] *** rindolf joined
[03:26] *** akaseki joined
[03:52] *** [Sno] left
[03:53] *** raiph left
[04:11] *** Jerry left
[04:16] *** Jerry joined
[04:20] *** Jerry left
[04:47] *** kaare_ joined
[04:53] *** kaare_ left
[04:57] *** Jerry joined
[05:07] *** ecocode_ joined
[05:13] *** [Sno] joined
[05:19] <kyun> https://gist.github.com/anonymous/9a948de54103acd211b9 Failed while build perl6

[05:26] *** SamuraiJack joined
[05:27] <TimToady> the git clone seems to have failed

[05:27] <TimToady> try running the same command again

[05:27] <TimToady> it acts like your network connection went down in the middle

[05:34] <dalek> rakudo/nom: 5f583ed | (Rob Hoelz)++ | src/core/Mu.pm:

[05:34] <dalek> rakudo/nom: Include the offending variable name in uninitialized warning

[05:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5f583edc15

[05:34] <dalek> rakudo/nom: 72852f1 | (Rob Hoelz)++ | src/Perl6/ (2 files):

[05:34] <dalek> rakudo/nom: Change =begin END to =begin finish

[05:34] <dalek> rakudo/nom: 

[05:34] <dalek> rakudo/nom: In accordance with S26

[05:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/72852f11f7

[05:36] <TimToady> but in English we say "the beginning of the end", not "the beginning of the finish" :/

[05:37] <TimToady> why did it get changed to "finish"?

[05:39] <hoelzro> TimToady:     This commit also renames =END to =finish, because =end would clash

[05:39] <hoelzro>     with the end marker of delimited blocks.

[05:39] <hoelzro> that's masak's excuse from three years ago =)

[05:42] <dalek> roast: 7d859d6 | (Rob Hoelz)++ | S0 (3 files):

[05:42] <dalek> roast: Rename =begin END to =begin finish

[05:42] <dalek> roast: review: https://github.com/perl6/roast/commit/7d859d685f

[05:42] <TimToady> but END doesn't clash with end...

[05:42] <TimToady> and it was to remind people of __END__

[05:44] *** Mrsmoo joined
[05:45] <hoelzro> TimToady: I can always revert the changes to nom/roast if you want to change the spec back

[05:46] <ecocode_> so I played with ovid's post...

[05:46] <ecocode_> to better understand what happens I added a "say $_", which gives weird results

[05:46] <ecocode_> perl6 -e 'await do for 1 .. 100 { start { say $_; rand.sleep } }'

[05:46] <ecocode_> sometimes I get 2 numbers to be 'glued' together:

[05:46] <ecocode_> 47

[05:46] <ecocode_> 48

[05:46] <ecocode_> 49

[05:46] <ecocode_> 50

[05:46] <ecocode_> 5152

[05:46] <ecocode_> 53

[05:46] <ecocode_> 54

[05:47] <ecocode_> 51 and 52 are glued

[05:47] <ecocode_> there's an empty line after 5152, meaning part of say $_ , namely printing \n is done after another promise got finished ?

[05:47] <ecocode_> then after running it few times more I got this error mess:

[05:48] <TimToady> the IO isn't always serialized correctly, and there's some kind of race condition between the string and the \n that allows other threads to say something in between

[05:48] <ecocode_> http://pastebin.com/hQdqfWNJ

[05:49] <ecocode_> TimToady: is that expected behavior ?

[05:49] <TimToady> I've seen it before; it was supposedly fixed, but isn't right yet

[05:50] <ecocode_> ok

[05:50] <ecocode_> what about the fatal error (see pastebin)

[05:51] <ecocode_> it happened only once... but it happened

[05:54] <TimToady> dunno, I can't make any sense of it, offhand, because there's no .count at that location in the setting

[05:55] *** kaare_ joined
[05:57] *** gfldex joined
[05:57] <ecocode_> in that particular case the numbers 1 and 2 where glued together. Might be unrelated to the exception, but I'd say chances are high it is related

[05:57] <hoelzro> TimToady: should we wait until European morning and wait for masak to weigh in about that =finish vs =END thing?

[05:58] <TimToady> hoelzro: sure, I'm in no rush, after all, I didn't notice the change for 3 years...

[05:58] <hoelzro> alright, I'll mention it in the morning

[05:59] *** Mrsmoo left
[05:59] <TimToady> and =finish makes a little more sense than =begin finish does

[05:59] *** mrsmoo joined
[05:59] <ecocode_> hmmm... nope not related: http://pastebin.com/7eRw2Mkg

[05:59] <TimToady> but =coda and =begin coda might make more sense

[05:59] <TimToady> or some such

[06:00] <TimToady> and I still think it's special enough to be capitalized, whatever word we end up with, since it's an exception to requiring an =end

[06:01] <ecocode_> should I file a bug report ? if yes, any link to the perl6 bug tracker ?

[06:01] *** mrsmoo left
[06:01] <TimToady> you can just email to [email@hidden.address] I believe

[06:02] <TimToady> masak++ usually just copies in the relevant irc lines

[06:04] <dalek> doc: e067745 | (Rob Hoelz)++ | lib/Perl6/TypeGraph/Viz.pm:

[06:04] <dalek> doc: Fail hard if we fail to run dot

[06:04] <dalek> doc: review: https://github.com/perl6/doc/commit/e067745ae1

[06:07] <grondilu> ecocode_: wouldn't it make more sense to add say $_ *after* rand.sleep?

[06:09] <hoelzro> m: my $foo; say "foo = $foo";

[06:09] <camelia> rakudo-moar 012450: OUTPUT«use of uninitialized value of type Any in string context  in block <unit> at /tmp/a5Ke7WSi6t:1␤␤foo = ␤»

[06:10] <hoelzro> hmm, it hasn't landed yet

[06:11] <ecocode_> grondilu: well I wanted to know when the task was started... I could add a message at the end also...

[06:11] <hoelzro> well, I'll check in the US morning

[06:11] <hoelzro> sleep &

[06:11] <TimToady> o/

[06:13] <ecocode_> like this: perl6 -e 'await do for 1 .. 20 { start { say "$_.."; rand.sleep; say "$_..done" } }'

[06:14] <ecocode_> which still glues stuff

[06:14] <ecocode_> 2..done

[06:14] <ecocode_> 20..done11..done

[06:14] <ecocode_> 14..done

[06:14] <ecocode_> seems that narrows down the exception...

[06:15] <ecocode_> It seems the exception happens when I have >16 concurrent tasks

[06:15] <TimToady> oh, maybe someone hardcode a limit somewhere...

[06:15] <ecocode_> as in http://pastebin.com/nB5NcmTW

[06:15] *** _thou joined
[06:16] <ecocode_> TimToady: yep, can be

[06:18] <grondilu> concurrent access to IO is a source of troubles anyway.  If you want to get start time you could write start { my $start = now; rand.sleep; $start }

[06:19] <ecocode_> TimToady: seems to be rand related too

[06:19] <TimToady> but there's no way to keep separate say commands from interleaving

[06:19] <ecocode_> this works: perl6 -e 'await do for 1 .. 20 { start { say "$_.."; 3.sleep; say "$_..done" } }'

[06:20] <TimToady> oh, maybe something is not threadsafe in rand

[06:20] *** _thou left
[06:20] <ecocode_> although there's a hang after the 16th process

[06:21] *** kaleem left
[06:21] <ecocode_> http://pastebin.com/UaKuYPnY

[06:21] <grondilu> my @rand = rand xx 20; await do for 1 .. 20 { start { say "$_.."; @rand[$_].sleep; say "$_ is done" } }  # maybe try this then

[06:21] *** gfldex left
[06:22] <grondilu> or rather:

[06:22] <grondilu> my @rand = rand xx 20; await do for ^20 { start { say "$_.."; @rand[$_].sleep;  say "$_ is done" } }

[06:24] <ecocode_> grondilu: same error when 16 tasks are running concurrently

[06:24] <ecocode_> otherwise ok

[06:25] <ecocode_> oh gosh :(

[06:25] <grondilu> look at line 16 in src/core/ThreadPoolScheduler.pm

[06:25] <ecocode_> http://pastebin.com/Gpa4MpSW

[06:25] <grondilu> Int :$!max_threads = (%*ENV<RAKUDO_MAX_THREADS> // 16).Int

[06:25] <ecocode_> worse

[06:25] <grondilu> ^here's a 16 magic number

[06:26] <grondilu> so try setting the env variable RAKUDO_MAX_THREADS to say 100

[06:26] <grondilu> export RAKUDO_MAX_THREADS=100  on bash for instance

[06:27] <ecocode_> yep, I'll try

[06:27] <ecocode_> but I was figuring why your code failed that badly after 10 threads

[06:27] <ecocode_> even 9 now

[06:28] <ecocode_> and still, why does it hang when using rand and not when using a fixed number ?

[06:28] * grondilu has no idea

[06:28] <ecocode_> uhoh ! got the exception with a fixed number now !

[06:28] <ecocode_> http://pastebin.com/p1MV67GR

[06:29] <ecocode_> so the exception ALWAYS happens after 16 threads, but >16 threads not always gives the exception

[06:30] <ecocode_> and 'export RAKUDO_MAX_THREADS=100' has no effect

[06:31] <grondilu> what's your shell?

[06:31] *** kurahaupo left
[06:32] <grondilu> (assuming your on unix/linux that is)

[06:32] <ecocode_> macosx bash

[06:32] <ecocode_> the max concurrent threads stays on 16, but I have no exceptions anymore (for the moment)

[06:33] <ecocode_> oops... got one :)

[06:33] <ecocode_> so RAKUDO_MAX_THREADS has no effect at all

[06:33] *** anaeem1 joined
[06:34] <grondilu> it may be taken into account only while compiling CORE.setting.  Not sure.

[06:35] <grondilu> I mean (%*ENV<RAKUDO_MAX_THREADS> // 16).Int is the default value for a parameter argument.  Does that get frozen after compilation?

[06:35] *** _sri joined
[06:36] * grondilu suspects it does

[06:37] <grondilu> so you may have to recompile with RAKUDO_MAX_THREADS set to a bigger value.  But that'd be weird.

[06:37] <ecocode_> indeed...

[06:37] <ecocode_> also that would only bring the limit higher before getting the exception

[06:37] <ecocode_> that doesn't help

[06:38] <grondilu> yeah but at least we'd get closer to understanding the issue

[06:40] *** awwaiid left
[06:40] <ecocode_> also, if the exception occurs, it occurs after the 16th task. once it passed that one it won't occur even with

[06:40] <ecocode_> perl6 -e 'await do for 1 .. 1000 { start { say "$_.."; 1.sleep; say "$_..done" } }'

[06:41] *** awwaiid joined
[06:42] * ecocode_ building perl6 with RAKUDO_MAX_THREADS=1000

[06:44] <ecocode_> ayé

[06:44] <ecocode_> http://pastebin.com/vha6QyiV

[06:50] <ecocode_> even fails with 100

[06:50] <ecocode_> only compiles when RAKUDO_MAX_THREADS is not set

[06:51] *** Jerry left
[06:51] <lizmat> ecocode_ grondilu o/

[06:51] <sergot> hi o/

[06:52] <lizmat> I found this problem already months ago, and there is actually a skipped test in roast for this

[06:53] <lizmat> from what I remember discussing this with jnthn++ , is that there is some type of memory corruption going on when the crash occurs

[06:53] <lizmat> which seems to be hard to track

[06:53] <ecocode_> which problem ? failing to build with RAKUDO_MAX_THREADS=100 or the random exception when reaching 16 threads

[06:53] <lizmat> random exception

[06:53] <ecocode_> ok

[06:54] <lizmat> it's still on jnthn's radar

[06:54] <ecocode_> is that only on moar ? or also jvm ?

[06:54] <lizmat> but there are other, more pressing issues that would probably need to be fixed first

[06:54] <lizmat> afaik, this is only on Moar

[06:55] <ecocode_> ok, I'll switch to jvm then

[06:55] <lizmat> fwiw, this *could* be a problem in the underlying libuv, for all we know

[06:55] <ecocode_> RAKUDO_MAX_THREADS=20 also fails build moar

[06:56] <lizmat> not sure what you mean there

[06:58] <ecocode_> rakudobrew build moar fails when environment var is set to 20

[06:58] <ecocode_> http://pastebin.com/vha6QyiV

[06:59] <ecocode_> without setting RAKUDO_MAX_THREADS it builds ok

[07:00] <TimToady> maybe there's a reason it was set to 16

[07:02] <TimToady> but surely you can have more start blocks than worker threads...

[07:02] <lizmat> indeed...

[07:02] <lizmat> BTW, confirm that segfault on make install on OS X is gone !

[07:03] <ecocode_> yep saw that :)

[07:03] <ecocode_> and rakudobrew++ !

[07:04] *** rindolf left
[07:04] <ecocode_> the glue-stuff mentioned above apso happens on jvm backend

[07:04] *** rindolf joined
[07:05] <ecocode_> but it seems the exception doesn't happen

[07:07] <lizmat> afk for a bit&

[07:11] *** kjs_ joined
[07:12] <ecocode_> seems RAKUDO_MAX_THREADS has no impact on compilation for jvm

[07:13] <kyun>     probing whether your compiler thinks that it is gcc  Can't compile simple gc

[07:13] <kyun> c probe, so something is badly wrong at build/probe.pm line 92.

[07:14] <ecocode_> hmmm got an exception on jvm

[07:14] <ecocode_> perl6 -e 'await do for 1 .. 200 { start { say "$_.."; 2.sleep; say "$_..done" } }'

[07:15] <ecocode_> http://pastebin.com/jVytVLFW

[07:16] <ecocode_> is there any way to keep track of how many start blocks are running ?

[07:17] <ecocode_> (in Perl6)

[07:19] *** Ovid joined
[07:20] *** Ovid is now known as Guest34380

[07:20] *** curtispoe left
[07:21] *** zakharyas joined
[07:25] *** FROGGS_ is now known as FROGGS

[07:25] <FROGGS> morning

[07:25] <nwc10> agree!

[07:29] *** kaleem joined
[07:35] *** rindolf left
[07:35] *** rindolf joined
[07:43] <lizmat> so, it might be easier for him to just take a train to e.g. Bremen, and then take the ICE down to Munich

[07:43] <lizmat> or something like that

[07:44] <nwc10> wrong window! :-)

[07:44] <lizmat> oops

[07:44] <lizmat> hehe

[07:44] <nwc10> if you've going to leak stuff, please leak *interesting* stuff :-)

[07:44] <ecocode_> how come perl6 can have more start blocks running than threads ?

[07:44] *** brrt joined
[07:44] <brrt> o/

[07:44] <lizmat> hehe   hi brrt

[07:44] <ecocode_> perl6 -e 'my $runners=0;await do for 1 .. 2000 { start { $runners++; (0.2).sleep; $runners--; say "running: $runners finished: $_" } }'

[07:45] <brrt> uhm, TimToady here? or anyone who can answer questions wrt to the correct behavior of integer-division-by-zero?

[07:45] <lizmat> ecocode_: that code has race conditions

[07:45] *** darutoko joined
[07:45] <ecocode_> uh ?

[07:46] <brrt> also, i'm all pro divmod

[07:46] <ecocode_> any doc explaining that ?

[07:46] <lizmat> if you're trying to update a scalar from multiple threads

[07:46] <lizmat> especially ++

[07:46] <brrt> except i want the round-towards-negative-infinity thingy specced out

[07:46] <lizmat> or --

[07:46] <ecocode_> ok. so how should that be done ?

[07:47] <lizmat> since ++ and -- are not atomic (yet anyway, they might be for natives in the future)

[07:47] <ecocode_> is there some locking on scallars ?

[07:47] <lizmat> you may miss an update

[07:47] <lizmat> no, there is no locking

[07:48] <ecocode_> so how can I keep track of runners ?

[07:48] <lizmat> you are encouraged to use the other primitives that S17 provides for your "shared" variable updates

[07:48] <ecocode_> S17 ?

[07:48] <lizmat> S17:01

[07:48] <synopsebot> Link: http://perlcabal.org/syn/S17.html#line_01

[07:49] <ecocode_> ok thanks ! some reading required :)

[07:49] <lizmat> you could e.g. start a supply that has an .act on it that either does the ++ or the --

[07:50] <lizmat> the .act will make sure that there is only one thread doing any update at a time

[07:54] <brrt> m: nqp::div_i(4, 0);

[07:54] <camelia> rakudo-moar 72852f: OUTPUT«Division by zero␤  in block <unit> at /tmp/F2WTyA89WL:1␤␤»

[07:54] <brrt> p6: nqp::div_i(4, 0)

[07:54] <brrt> r: nqp::div_i(4,0)

[07:54] <camelia> rakudo-jvm 72852f: OUTPUT«(timeout)»

[07:54] <camelia> ..rakudo-moar 72852f: OUTPUT«Division by zero␤  in block <unit> at /tmp/tmpfile:1␤␤»

[07:54] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Any␤  at /tmp/tmpfile line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4595 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4596 (module-CO…»

[07:54] <camelia> ..rakudo-parrot 72852f: OUTPUT«(signal )»

[07:54] <camelia> rakudo-moar 72852f: OUTPUT«Division by zero␤  in block <unit> at /tmp/tmpfile:1␤␤»

[07:54] <camelia> ..rakudo-parrot 72852f: OUTPUT«(signal )»

[07:54] <camelia> ..rakudo-jvm 72852f: OUTPUT«java.lang.ArithmeticException: / by zero␤  in block <unit> at /tmp/tmpfile:1␤␤»

[07:54] <grondilu> brrt: division by zero is normalized in https://en.wikipedia.org/wiki/IEEE_754

[07:55] <lizmat> ecocode_: for instance:

[07:55] <lizmat> m: my $r=0; my $s=Supply.new; $s.act: { $_ ?? $r++ !! $r--; say "r = $r" }; await do for ^10 { start { $s.more(1); rand.sleep; say "j = $_"; $s.more(0) } }

[07:55] <camelia> rakudo-moar 72852f: OUTPUT«r = 1␤r = 2␤r = 3␤r = 4␤r = 5␤r = 6␤r = 7␤r = 8␤r = 9␤r = 10␤j = 8␤r = 9␤j = 7␤r = 8␤j = 3␤r = 7␤j = 4␤j = 2␤r = 6␤r = 5␤j = 5␤r = 4␤j = 0␤r = 3␤j = 9␤r = 2␤j = 6␤r = 1␤j = 1␤r = 0␤»

[07:56] <brrt> grondilu: is that valid for integer division as well?

[07:57] <lizmat> ecocode_: if I run the above code with ^1000, it does *not* crash

[07:57] <brrt> not really in a great position to lead long documentation since $dayjob :-(

[07:58] <lizmat> which implies to me that somehow the simple act of $r++ not being atomic, is what's causing the segv

[07:58] <lizmat> jnthn: ^^^

[07:58] *** rindolf left
[07:58] *** rindolf joined
[07:59] *** grondilu left
[08:00] *** grondilu joined
[08:01] <ecocode_> lizmat: this just hanged

[08:01] <ecocode_> perl6 -e 'my $r=0; my $s=Supply.new; $s.act: { $_ ?? $r++ !! $r--; say "# running = $r" }; await do for ^1000 { start { say "started $_"; $s.more(1); rand.sleep; say "finished $_"; $s.more(0) } }'

[08:01] <ecocode_> Unhandled exception: When invoking more, Provided outer frame 0x7f8104c36d80 (MVMStaticFrame tappers) does not match expected static frame type 0x7f8104c35dc0 (MVMStaticFrame )

[08:01] <lizmat> aha... intriguing...

[08:02] <lizmat> I'm going to run it a few more times to see if it breaks for me as well

[08:02] <ecocode_> well I got no #running output for a while and still start blocks launched

[08:03] *** _thou joined
[08:04] <lizmat> do you have jit enabled?

[08:04] *** kjs_ left
[08:05] <ecocode_> this might help : http://pastebin.com/13jqpQuJ

[08:05] <ecocode_> on moar

[08:05] <ecocode_> jit enabled ? how should I do that ?

[08:05] <ecocode_> just rakudobrew moar-vm

[08:06] <lizmat> hmmm... not sure with rakudobrew

[08:06] <lizmat> the extra parameter for the config should be: --moar-option=--enable-jit

[08:07] <FROGGS> does the behaviour change when you run it under MVM_JIT_DISABLE=1?

[08:07] <FROGGS> or MVM_SPESH_DISABLE=1 or MVM_SPESH_INLINE_DISABLE=1

[08:07] <FROGGS> I hope I wrote it correctly

[08:08] <FROGGS> also: MVM_SPESH_OSR_DISABLE=1

[08:08] <ecocode_> well, I cannot reproduce it even without it

[08:08] *** _thou left
[08:08] <FROGGS> hmmmm :/

[08:09] * brrt thinks we need to fix a few more bugs before we'll enable jit by default

[08:09] <brrt> although when we'd get more in-the-wild testing, that'd be great

[08:09] <ecocode_> aaah got it again !

[08:09] <brrt> that sounds racy

[08:09] <brrt> or garbage-collector-problemy

[08:10] <brrt> although the latter have been pretty reliable for me, when i've had them

[08:10] <FROGGS> brrt: I also think that we should enable risky features for HEAD, but not for a releases...

[08:11] <brrt> yeah... but at some point you have to bite the bullet or not?

[08:11] <ecocode_> seems that it doesn't occur with MVM_JIT_DISABLE=1

[08:11] <brrt> \o/

[08:11] <brrt> great

[08:12] <brrt> please report a bug :-) 

[08:12] <ecocode_> maybe that should be disabled in rakudobrew

[08:12] <brrt> hmm

[08:12] <brrt> if you did that, i could never find the bugs

[08:12] <lizmat> hmmm.. pretty sure that rakudobrew doesn't enable JIT

[08:12] <lizmat> by default

[08:12] <brrt> ecocode_: can you set something like MVM_JIT_LOG=a-file.txt and run it again

[08:13] <brrt> if a-file.txt actually contains text, you have JIT, otherwise, not

[08:13] <brrt> but that's the tradeoff between convenience / safety / reliablitly for users and for convenience / test coverage for developers

[08:14] <brrt> i.e. it be ideal for me if everybody just booted directly into moarvm-with-jit on startup (since that would catch the greatest amount of usage) but that's not particularly ideal for users

[08:14] <grondilu> perl6 --version should tell whether or not JIT is enable

[08:15] <grondilu> (imho)

[08:15] <ecocode_> hmmm I don't have jit then

[08:15] <ecocode_> and pretty awkward I cannot produce the exception again

[08:16] <grondilu> I have been configuring with --moar-option=--enable-jit and yet I have the feeling there's no JIT

[08:16] <grondilu> (because I don't see much performance improvement whatsoever)

[08:17] <ecocode_> This is perl6 version 2014.08-128-g72852f1 built on MoarVM version 2014.08-36-g7938703

[08:18] <brrt> uhm, that should say 'on MoarVM version .... with JIT enabled' i think

[08:18] <brrt> although i wasn't involved with that

[08:18] <ecocode_> oh .. segfault !

[08:18] <ecocode_> perl6: line 2: 52428 Segmentation fault: 11  /Users/ec/.rakudobrew/moar-HEAD/install/bin/perl6 "$@"

[08:18] <camelia> niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Invocant handling is NYI at /tmp/tmpfile line 1:␤------> [32mline 2: 52428 [33m⏏[31mSegmentation fault: 11  /Users/ec/.rakud[0m␤␤Confused at /tmp/tmpfile line 1:␤------> [32mline 2: 52428 [33m⏏[31…»

[08:18] <camelia> ..rakudo-{parrot,jvm,moar} 72852f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32mline 2[33m⏏[31m: 52428 Segmentation fault: 11  /Users/e[0m␤    expecting any of:␤        postfix␤        infix…»

[08:19] <brrt> lol

[08:19] <lizmat> $ perl6 --version

[08:19] <lizmat> This is perl6 version 2014.08-128-g72852f1 built on MoarVM version 2014.08-36-g7938703

[08:19] <ecocode_> \o/

[08:19] *** mr-foobar left
[08:19] <brrt> hmmm

[08:19] <brrt> lizmat: you do have JIT don't you?

[08:19] <lizmat> I *do* have jit, as checked with MVM_JIT_LOG

[08:19] *** mr-foobar joined
[08:19] <nwc10> $ ./perl6-m --version

[08:19] <nwc10> This is perl6 version 2014.08-128-g72852f1 built on MoarVM version 2014.08-44-g5b574f8

[08:19] <nwc10> $ /home/nicholas/Sandpit/moar-san-jit/bin/moar --version

[08:19] <nwc10> This is MoarVM version 2014.08-44-g5b574f8 built with JIT support

[08:19] <ecocode_> happened on this:

[08:20] <ecocode_> perl6 -e 'my $r=0; my $s=Supply.new; $s.act: { $_ ?? $r++ !! $r--; say "# running = $r" }; await do for ^200 { start { say "started $_"; $s.more(1); (.1).sleep; say "finished $_"; $s.more(0) } }'

[08:20] <nwc10> so, currently, perl6-m --version doesn't say anything about JIT

[08:20] <lizmat> nwc10: are you on --gen-moar=master ?

[08:20] <brrt> we should fix that, though

[08:21] <ecocode_> that line generates exceptions allmost all of the time

[08:21] <nwc10> no, I'm building MoarVM separately

[08:21] <nwc10>  perl Configure.pl --backends=moar --prefix=/home/nicholas/Sandpit/moar-san-jit

[08:22] <lizmat> ecocode_: haven't seen a single crash yet :-(

[08:23] <ecocode_> even on jvm

[08:23] <brrt> nwc10: does the --asan flag work for you today?

[08:23] <ecocode_> lizmat: pffff :/

[08:23] <nwc10> it seems to

[08:23] <ecocode_> why O why does it happen only to me ?

[08:24] <lizmat> what does perl6 --version say for you?

[08:24] <ecocode_> on jvm: http://pastebin.com/mYnfi96Q

[08:24] <ecocode_> lizmat: same as yours on moar

[08:25] <ecocode_> and this for jvm: This is perl6 version 2014.08-128-g72852f1 built on JVM

[08:25] <ecocode_> I'm doomed

[08:25] <lizmat> ok, that paste may be useful for jnthn, please keep it around for a bit

[08:25] <lizmat> I'll be away for the next ~2 hours...

[08:26] <lizmat> hope someone else will be able to pick this up

[08:26] <ecocode_> well, it's on pastebin :)

[08:27] *** rindolf left
[08:28] *** rindolf joined
[08:28] <lizmat> finally got one to crash, without any sleep at all

[08:28] <lizmat> Unhandled exception: When invoking is_bindable, Provided outer frame 0x7fd54a27eae0 (MVMStaticFrame bind_one_param) does not match expected static frame type 0x7fd54a27e8a0 (MVMStaticFrame )

[08:29] <lizmat> afk&

[08:30] *** anaeem1 left
[08:31] *** anaeem1_ joined
[08:31] *** kjs_ joined
[08:31] *** kurahaupo joined
[08:31] *** dakkar joined
[08:36] *** brrt left
[08:38] * grondilu cleaned his nqp/MoarVM and now recompiles with --enable-jit

[08:41] *** JimmyZ joined
[08:41] *** brrt joined
[08:44] *** molaf__ left
[08:54] *** xinming joined
[08:54] <brrt> where are the arithmetic operations specced?

[08:55] *** molaf joined
[08:55] *** integral joined
[08:55] *** integral left
[08:55] *** integral joined
[08:56] <JimmyZ> brrt: https://github.com/perl6/specs/blob/ed80b33d5e5b376285b9f3c1ef4177fde7ff3c36/S03-operators.pod

[08:56] *** xinming_ left
[08:56] *** donaldh joined
[08:57] <brrt> tnx

[08:57] *** mrf_ joined
[08:59] *** rindolf left
[08:59] *** fhelmberger joined
[08:59] *** rindolf joined
[09:03] <nine> zacts: yes, we started on that: https://github.com/niner/Inline-Perl5 But mind that it is just a couple of days old right now.

[09:05] *** molaf left
[09:05] <nine> ecocode_: WRT your glueing problem with threads: I really can't see anything wrong with that. That's exactly the kind of behaviour you have to expect with threads. To prevent that you'd have to synchronize your output.

[09:08] *** SamuraiJack left
[09:18] <ecocode_> lizmat: yep, jvm crashed without sleep also

[09:19] *** salv0 joined
[09:20] <ecocode_> nine: well, if this is expected behavior, is there a way to mark a block inside a start block as "unbrakable" ?

[09:21] <ecocode_> lizmat: on moar the error is not always the same

[09:22] <ecocode_> I got this now: Unhandled exception: When invoking bind...

[09:22] <ecocode_> then this: Unhandled exception: When invoking infinite

[09:22] <ecocode_> and even a Segmentation fault

[09:25] *** pecastro joined
[09:26] <nine> ecocode_: I'm not really familiar with Perl 6's concurrency primitives yet. I'd guess you want to use a Supply or Channel for serializing your output.

[09:26] *** JimmyZ_ joined
[09:28] *** JimmyZ left
[09:28] *** JimmyZ_ is now known as JimmyZ

[09:29] *** pecastro left
[09:29] *** pecastro joined
[09:32] *** JimmyZ left
[09:33] *** molaf joined
[09:37] *** rindolf left
[09:37] *** rindolf joined
[09:40] *** zakharyas left
[09:42] <Timbus> ecocode_, the 'simple', dumb way to do it is to use a lock, i guess.

[09:44] <donaldh> Perl6 concurrency is all about avoiding locks in user code though.

[09:45] <brrt> i'd argue that fixing-concurrency-bug is also high-priority for next hackathons :-)

[09:52] *** _thou joined
[09:56] *** _thou left
[09:57] *** kjs_ left
[10:00] <ecocode_> I guess I can circumvent lock for my app... just use print "..\n" instead of say "..." solves the issue :)

[10:01] *** kjs_ joined
[10:06] *** c1sung joined
[10:14] *** rindolf left
[10:14] *** rindolf joined
[10:20] *** kyun left
[10:21] *** anaeem1_ left
[10:22] *** kjs_ left
[10:23] *** anaeem1_ joined
[10:24] *** zakharyas joined
[10:34] *** mrf_ left
[10:37] <Ulti> ecocode_ you could create a channel and have a promise consume and print from that channel and everything else write to that channel

[10:37] <Ulti> that way only one thread is doing the IO safely

[10:39] * jnthn notes that Moar and JVM take care to lock while messing with handles down at the VM level, so that shouldn't  be a source of issues.

[10:39] <jnthn> The easiest way to shove work somewhere asynchronously and make sure the worker is only doing one thing at a time ain't a Channel, it's a Supply

[10:40] <jnthn> my $output = Supply.new; $output.act(-> $value { ...do whatever thing you need with $value... }); # and pass $output where needed

[10:40] <jnthn> And act ensures only one thread is ever in tha tblock

[10:40] <jnthn> *that

[10:41] <Ulti> when would you use a channel over a supply?

[10:41] <jnthn> This solution also performs better (thanks to greatly better thread affinity) than Channel will.

[10:41] <jnthn> Ulti: When you actually want a thread to efficiently block waiting for something.

[10:42] <jnthn> Ulti: Most common example is a set of stages with queues between them.

[10:43] <ecocode_> so the block in act can only run on a specific thread, even in different calls ?

[10:43] <jnthn> ecocode_: It can run on any thread, but only one at a time.

[10:43] *** salv0 left
[10:44] <jnthn> ecocode_: That is, you can never have two different threads in the block passed to act at the same time.

[10:44] <ecocode_> got it ! thx

[10:47] *** rindolf left
[10:47] *** rindolf joined
[10:50] *** kjs_ joined
[10:51] *** salv0 joined
[10:51] <Ulti> I'll have to play with my implementation which is currently using a channel then ;P

[10:54] *** nbrown_ joined
[10:54] *** beastd joined
[10:57] <timotimo> oh my.

[10:57] <timotimo> perl6 --version won't say "built with jit"

[10:57] <timotimo> moar --version will, however

[11:00] <masak> re `=begin finish`, I made the commit but not the decision. this happened in a discussion between tadzik, TheDamian, me, and possibly more people as part of YAPC::EU 2011 (I think it was).

[11:00] <masak> I don't remember what went into the decision at this point. though I do remember both END and end being considered as alternatives.

[11:01] <timotimo> we might want to point out rakudobrew on rakudo.org's "how to get rakudo" page

[11:04] <masak> +1

[11:15] <masak> no consensus on *..* yet?

[11:16] <masak> I still vote for allowing it, by the way. I haven't found good reasons to disallow *..* but allow *..0 and -Inf..Inf.

[11:16] <timotimo> something i would really like to have pointed out to people who look at our benchmarks:

[11:16] <lizmat> masak: +1

[11:16] <timotimo> our Rat classes are implemented in Perl 6 itself and they are *still* outperforming perl5's FatRat implementation by a large margin

[11:17] <timotimo> so even if they were offered as some kind of module through CPAN, they'd have fantastic performance

[11:17] <lizmat> timotimo: that's mostly because FatRat in P5 uses tie()

[11:17] <timotimo> is that a correct assumption?

[11:17] <lizmat> and tie() is notoriously slow on P5

[11:17] <timotimo> oh

[11:17] <timotimo> why is that necessary?

[11:17] <masak> colomon: I saw your reasoning at http://irclog.perlgeek.de/perl6/2014-08-27#i_9250329 much later than you posted it -- sorry about that.

[11:18] <lizmat> timotimo: otherwise you would not be able to use them as "normal" variables

[11:18] *** rindolf left
[11:18] <timotimo> oh my.

[11:18] <masak> colomon: I disagree with points 3 and 3.1 -- there's no confusion at all, *especially* when you consider that some ranges might be created programmatically rather than being literals.

[11:18] <lizmat> the same performance issue exists with shared variables in ithreads

[11:18] *** rindolf joined
[11:18] <timotimo> they automatically get locks created for them?

[11:19] <lizmat> in ithreads, shared variables are simply tied to some logic that will read/write the values in a hidden thread

[11:19] <masak> colomon: I disagree with 3.2 as well. provided we stick to our guns with Inf being polytypic, then *..* has no less problems than -Inf..Inf in that regard.

[11:19] <lizmat> there's *nothing* shared about shared variables in Perl 5

[11:19] <timotimo> ah

[11:19] <lizmat> timotimo: yes

[11:20] <masak> the argument "you can still pass -Inf..Inf" speaks in favor of allowing *..* (with the same meaning) rather than disallowing it, IMO.

[11:20] <timotimo> ok, not quite "locks created for them", more like "accesses are serialized to a single thread"

[11:20] <lizmat> masak: +1

[11:20] * brrt cannot find any reference to rounding to negative infinity

[11:20] <lizmat> timotimo: as are the updates  :-)

[11:20] <brrt> wrt integer division

[11:20] * masak would still like to hear opinions of TimToady or pmichaud about *..*

[11:20] <brrt> which means integer division  can be cheaper

[11:21] <timotimo> lizmat: right, both read and write accesses

[11:22] <lizmat> still think we need some sugar for the my $s=Supply.new; $s.act( { ...} ) pattern for serializing access

[11:23] <timotimo> lizmat: every single thing i hear about ithread sounds like you can't get happy with ithreads

[11:23] <lizmat> indeed, that's why I wrote forks.pm  :-)

[11:23] <timotimo> did anybody already step up to write sporks.pm? :)

[11:24] <lizmat> e.g. if you load Moose in P5, starting a thread will suddently cost you .5 second, instead of the 0.05 second without

[11:24] <lizmat> why?  Because starting an ithread means copying over *all* P5 data structures to the new thread

[11:24] <timotimo> right

[11:24] <lizmat> and Moose and its dependencies have quite a few

[11:25] <lizmat> the irony of forks.pm was

[11:25] <lizmat> that the ithreads implementation of P5 uses code that was originally written to emulate fork() on Windows

[11:25] <timotimo> ah, yeah, forking on windows

[11:25] <jnthn> lizmat: Please stop trying to put sugar for everything into the core language.

[11:26] <jnthn> lizmat: We should have *primitives* there. 

[11:26] <jnthn> Otherwise we get a 50,000 line CORE.setting.

[11:26] <timotimo> what is that a reference to?

[11:27] <jnthn> Seeing my talk and wanting to stick some throttling scheme into the core, when it bbelongs in a module, for one...

[11:27] <timotimo> ah, yes, that's module space

[11:27] <jnthn> And "still think we need some sugar for the my $s=Supply.new; $s.act( { ...} ) pattern"

[11:27] <jnthn> That's called an Actors module. :)

[11:28] <timotimo> mhm

[11:28] <timotimo> (my Supply $s .= new).act: { ... }

[11:28] <timotimo> sugary enough for me

[11:29] <jnthn> The idea of what's in core is to make sure we have common mechanisms so different modules can do their concurrency in a composable way.

[11:29] <lizmat> jnthn: if you're really that worried about the size of the core setting

[11:29] <lizmat> why don't we get rid of Sets/Bags/Mixes?

[11:29] <masak> m: sub nth { $^n ~ (<. st nd rd>[$n] // "th") }; for <. 220 153 128 268 273 147 172 190>.kv -> $m, $c { next unless $m; say "$c Rakudo commits in the {nth $m} month", (Date.today.month == $m ?? " (so far)" !! "") }

[11:29] <camelia> rakudo-moar 72852f: OUTPUT«220 Rakudo commits in the 1st month␤153 Rakudo commits in the 2nd month␤128 Rakudo commits in the 3rd month␤268 Rakudo commits in the 4th month␤273 Rakudo commits in the 5th month␤147 Rakudo commits in the 6th month␤172 Rakudo commits in the 7t…»

[11:29] <lizmat> they're not used in the core, and could live without *any* problem in a Set module

[11:30] <masak> dang, it cut off at July.

[11:30] <masak> m: sub nth { $^n ~ (<. st nd rd>[$n] // "th") }; for <. 220 153 128 268 273 147 172 190>.kv -> $m, $c { next unless $m; say "$c commits in the {nth $m} month", (Date.today.month == $m ?? " (so far)" !! "") }

[11:30] <camelia> rakudo-moar 72852f: OUTPUT«220 commits in the 1st month␤153 commits in the 2nd month␤128 commits in the 3rd month␤268 commits in the 4th month␤273 commits in the 5th month␤147 commits in the 6th month␤172 commits in the 7th month␤190 commits in the 8th month (so far)␤»

[11:30] <jnthn> lizmat: I just think these things belong more in module space, not in CORE.

[11:31] <lizmat> If Sets had been out of the core, we would have had the empty set symbol months ago already

[11:31] <lizmat> 29 occurrences of "sugar" in the specs

[11:31] <masak> sweet spec.

[11:32] <masak> m: sub nth { $^n ~ (<. st nd rd>[$n] // "th") }; for <. 220 153 128 268 273 147 172 190>.kv -> $m, $c { next unless $m; say "$c Rakudo commits in the {nth $m} month", ~(" (so far)" if Date.today.month == $m) }

[11:32] <camelia> rakudo-moar 72852f: OUTPUT«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/RMubO7wmwP:1␤␤220 Rakudo commits in the 1st month␤use of uninitialized value of type Nil in string context  in block <unit> at /tmp/RMubO7wmwP:1␤␤153 Rakudo commits…»

[11:32] <masak> huh, I don't get that warning locally.

[11:32] <lizmat> jnthn: I disagree with you on S17 sugaring

[11:33] * brrt is just going to bug TimToady about the spec change :-)

[11:33] <lizmat> it's going to be hard enough to prevent people from creating race conditions (like ecocode_  did earlier today)

[11:33] <lizmat> and we're going to need all the sugar we can get to make it easy for people to program asynchronously

[11:33] *** Possum left
[11:33] <jnthn> lizmat: Sets could be argued to be a core data structure that there's little desire to implement differently. Not to mention that we've got a good understanding today of what sets are and plenty of successful implementations to look at.

[11:34] <lizmat> if size of setting is really the issue, then I would vote to expel Set/Bag/Mixes out of the core

[11:34] <jnthn> lizmat: The concurrency space is still evolving *fast*. 

[11:34] <jnthn> lizmat: We should be extremely careful what we pick to put in CORE, 'cus once it's in there it will be a nightmare to get it out again in the long run.

[11:35] <lizmat> I'm familiar with the concept  :-)

[11:35] <jnthn> lizmat: Also there will be common areas where the async problems look fairly similar.

[11:35] <lizmat> fortunately, we're a little better positioned to deprecate stuff

[11:35] <jnthn> lizmat: And I think those can be dealt with by domain specific modules better than with generic sugar.

[11:35] <brrt> what is a Mix?

[11:36] <lizmat> it's a Bag of floats

[11:36] <brrt> why is that different?

[11:36] <masak> brrt: "Unordered collection of values with weights"

[11:36] <brrt> right

[11:36] <masak> "Bag of floats" sounds like it's the keys that are floats.

[11:36] <jnthn> lizmat: I'm open to looking at concrete suggetions, but I'd rather we encourage prototyping of sugar for conc stuff in module space first.

[11:37] <lizmat> Bags only have natural values

[11:37] <arnsholt> masak: Also known as a probability distribution?

[11:37] <lizmat> so my proposal for :max and :id for start {} is a no go, as far as you're concerned ?

[11:37] *** Possum joined
[11:38] <lizmat> specs 6989f5a79880e37851d0a7a6178e9ba2902c51cc

[11:38] <jnthn> lizmat: I think I could be persuaded we want some kind of throttling functionality in CORE, but I do think Promise.start is the wrong hook.

[11:38] <masak> arnsholt: well, except there's no ∑=1 restriction, I guess.

[11:38] <jnthn> lizmat: Notice that it fails to handle my second scenario, with processes...

[11:38] * lizmat looks again

[11:39] <jnthn> lizmat: Some kind of scheduler wrapper is likely better

[11:39] <jnthn> lizmat: Since it's a scheduling problem rather than a Promise-specific one...

[11:39] <jnthn> Or start-specific.

[11:39] <jnthn> Time for dinner :)

[11:39] <jnthn> bbl

[11:39] <brrt> nom well

[11:40] <brrt> my 2c: i can argue for having throttling 'supported' out of the box, it's easy to get wrong

[11:40] *** _thou joined
[11:40] <brrt> and... it seems very important to have, too

[11:44] *** Jerry__ joined
[11:44] <dalek> specs: b8eaa8a | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[11:44] <dalek> specs: Revert "Add :max :id to start { }"

[11:44] <dalek> specs: 

[11:44] <dalek> specs: This reverts commit 6989f5a79880e37851d0a7a6178e9ba2902c51cc.

[11:44] <dalek> specs: review: https://github.com/perl6/specs/commit/b8eaa8a536

[11:44] *** _thou left
[11:48] *** Jerry__ left
[11:48] <lizmat> errands&

[11:48] *** Jerry__ joined
[12:02] *** spider-mario joined
[12:13] *** breinbaas joined
[12:16] *** kjs_ left
[12:24] *** kjs_ joined
[12:25] *** rindolf left
[12:25] *** rindolf joined
[12:31] *** brrt left
[12:35] <hoelzro> morning #perl6

[12:35] <colomon> \o

[12:41] <hoelzro> I found a fun behavior last night:

[12:41] <hoelzro> m: 'pod' ~~ /'pod' $*/

[12:41] <camelia> rakudo-moar 72852f: OUTPUT«(signal )»

[12:42] <hoelzro> this is essentially what causes '=begin title' to never finish parsing

[12:43] *** SamuraiJack joined
[12:48] *** telex left
[12:48] <hoelzro> also, what determines which roast tests make it into t/spectest.data? I noticed t/spec/S04-phasers/exit-in-check.t is failing, and isn't being run

[12:48] <timotimo> right, we're missing a few sadly

[12:48] <timotimo> and i don't know why

[12:50] *** telex joined
[13:01] *** clkao left
[13:05] <colomon> generally, they're not in there if they seriously didn't work at some point.  or perhaps if the test itself is considered questionable due to spec changes / underspeccing / whatever.

[13:06] <colomon> though I suppose it's possible that one was disabled during one of the complete Rakudo overhauls and no one ever thought to add it back in.

[13:10] *** Alina-malina left
[13:11] <timotimo> .o( 100 TODOs marked "nom regression" )

[13:13] *** Alina-malina joined
[13:15] <hoelzro> o_O

[13:15] <hoelzro> commute &

[13:16] *** isBEKaml joined
[13:17] *** isBEKaml left
[13:18] *** brrt joined
[13:19] *** kaare_ left
[13:23] *** guru joined
[13:23] *** guru is now known as Guest19296

[13:24] *** Guest19296 is now known as ajr_

[13:29] *** _thou joined
[13:33] *** _thou left
[13:40] *** raiph joined
[13:40] *** MilkmanDan left
[13:44] *** MilkmanDan joined
[13:47] *** kaleem left
[13:51] <Ulti> what is the disadvantage of something not being in CORE?

[13:52] *** kjs_ left
[13:53] *** kjs_ joined
[13:53] *** Woodi joined
[13:53] <tadzik> people have to install it themselves

[13:55] <Ulti> but its part of the language spec that primitives like Bag and Set exist...

[14:00] <lizmat> but they're completely implemented in Perl 6, *and* they're not referenced inside the core itself afaik

[14:00] <lizmat> so they *can* be expelled quite easily

[14:00] *** _thou joined
[14:01] <lizmat> and needing to do a 'use Set' would not hurt much, I would think

[14:01] <lizmat> I mean, we do the same for 'use Test'

[14:01] <lizmat> and that is *also* part of the standard distribution, although not part of the core setting

[14:01] <colomon> I think TimToady's idea has been to err on the side of including things in the core.  So that the core langauge has a very rich set of tools available.

[14:01] <brrt> uhm, it seems that moving from core to standard module is sane enough

[14:02] <brrt> however, python does have set() as a core type

[14:02] <brrt> perl5 doesn't exactly have the kitchen sink in it's core functions and that works out quite well

[14:03] <ecocode_> lizmat: do you mean the code which also failed @ your system has a race condition ? or are you referring to my first trials which indeed had a race condition ?

[14:03] <lizmat> colomon: that's not the vibe I've been getting recently

[14:04] <lizmat> ecocode_: it also failed when I didn't put any sleep in it

[14:04] <colomon> lizmat: yes, well, you have to stop somewhere.  ;)

[14:05] *** SamuraiJack left
[14:05] <ecocode_> lizmat: yep I've read that. and it also crashes on jvm without the sleep

[14:05] <lizmat> away again&

[14:12] <Ulti> lizmat I dunno, I've been using bags a lot but if I needed to use one in full flow I would write my %bag; @list.map({%bag{$_}++}) than include use Bag and then put my %bag = bag @list I guess if I wanted the additional functionality I would bother >:3

[14:13] <Ulti> maybe I am being baggist and should maybe use them a little less anyway

[14:13] <Ulti> but for calculating stats they are really useful

[14:14] * Ulti job is mostly counting beans

[14:14] <timotimo> java beans?

[14:14] <donaldh> literally?

[14:14] <Ulti> genomic beans

[14:15] <Ulti> protein domains really, but they are just a special kind of magic bean that needs counting

[14:15] <brrt> Ulti is Baggins

[14:15] <colomon> I've been using Set and Bag quite a lot in my code, too.

[14:16] <colomon> though just earlier this week I discovered what a nice performance gain I could get in one script by rewriting one beautiful line of set operations into 10+ ugly lines of hash manipulation in loops.

[14:16] <Ulti> yeah :(

[14:16] <timotimo> :(

[14:16] <timotimo> i don't think we have any benchmarks for set operations

[14:17] <timotimo> colomon: do you still have the pre-rewrite code?

[14:17] <colomon> timotimo: sure

[14:17] * colomon believes strongly in version control

[14:17] <timotimo> it might be very interesting to see the --profile and have a stab at benchmarkifying it

[14:18] <Ulti> I have been more of the opinion of keeping things how I want them and feeling entitled to have that be fast eventually ;)

[14:18] <colomon> timotimo: ($model.keys (-) $current.keys, $current.keys (-) $model.keys, $current.keys (&) $model.keys)

[14:18] <colomon> is the key line.

[14:18] <timotimo> and the .keys are probably returning lists, right?

[14:18] <colomon> actually, I left it in as a comment so I'd know what the heck the sub was actually doing

[14:18] <Ulti> that is so much nicer to look at than tonnes of loops and hash playing

[14:18] <colomon> timotimo: yes, $model and $current are hashes

[14:19] <Ulti> colomon yeah once you are using actual code as the comment to other code... ;___;

[14:19] <timotimo> right. so we're doing hash -> list -> set three times for $model and $current

[14:19] <colomon> timotimo: yes

[14:20] <timotimo> have you tried building the sets only once up front instead?

[14:20] <colomon> timotimo: though I suspect (possibly wrongly) that the actual set operations are what's slow there.

[14:20] <Ulti> colomon: yeah my code thats slow spends all its time initialising lists endlessly

[14:21] <colomon> timotimo: … I can't tackle this right this instant, but I'll see what I can do to do a full set of profiles later this morning.

[14:21] <timotimo> that's fine, no hurry :)

[14:21] <Ulti> now there is a profiler! jnthn++

[14:22] <timotimo> quite sadly, "common sub-expression elimination" would probably not have enough info to move the set constructions up front

[14:23] <Ulti> does .keys not cache the result?

[14:23] <timotimo> maybe we can do a better job at hash.keys.Set by mixing in a custom .Set into the list returned by keys that gets invalidated as soon as you change the list

[14:24] * jnthn pulls latest stuff and sees if he can get a patch in before sleeping...

[14:26] <Ulti> though I guess having something thread safe that understands if something mutable became tainted between you doing set operations becomes scary complex quickly

[14:27] <timotimo> yes, i'm scared of that, too

[14:27] <Ulti> plus thats the whole point of immutable types being in the language o___O

[14:27] <timotimo> aye

[14:28] <timotimo> so ... hash.keys.Set will end up calling Set.new-fp(self.list) on the .keys

[14:28] <timotimo> that's not too, too bad

[14:29] <timotimo> new-fp will do a given/when to determine if something is a Pair or not before pushing the things in

[14:30] * lizmat just looked at the Set.pm code and realised it doesn't make much sense to cache pairs for Sets

[14:30] <timotimo> that ought to be efficient

[14:30] <lizmat> is now rewriting it to have .keys cached instead

[14:31] <timotimo> that doesn't sound bad

[14:31] <timotimo> i mean ... the proposed fix

[14:34] <timotimo> the (-) operator already helpfully uses the "view" adverb on the set and bag coercers

[14:34] <timotimo> as does (&)

[14:35] <lizmat> yeah, I tried to do some optimizations already

[14:36] <timotimo> lizmat++

[14:38] *** woolfy joined
[14:38] *** avs_ left
[14:39] <hoelzro> m: my $foo; say "foo = $foo"

[14:39] <camelia> rakudo-moar 72852f: OUTPUT«use of uninitialized value $foo of type Any in string context  in block <unit> at /tmp/8KTp_JBvSb:1␤␤foo = ␤»

[14:40] <hoelzro> awesome, that patch is in the evalbot now

[14:40] <timotimo> very cute

[14:40] <lizmat> hoelzro++

[14:40] <lizmat> so, how do I put a list of values into an array and make them read-only

[14:40] <hoelzro> that drove me nuts comings from Perl 5, not knowing *what* was uninitialized

[14:41] *** ecocode_ left
[14:41] <timotimo> use an array rather than a list, so it won't have containers?

[14:41] <timotimo> or a parcel

[14:43] *** SamuraiJack joined
[14:44] <hoelzro> what's the difference between Stringy and Str?

[14:44] <masak> m: say //

[14:44] <camelia> rakudo-moar 72852f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/7MnfDZp6XV␤Null regex not allowed␤at /tmp/7MnfDZp6XV:1␤------> [32msay //[33m⏏[31m<EOL>[0m␤»

[14:44] *** treehug88 joined
[14:44] <masak> m: my $foo = ""; say / <$foo> /

[14:44] <camelia> rakudo-moar 72852f: OUTPUT«␤»

[14:44] <masak> shouldn't the latter one also error with "Null regex not allowed"?

[14:45] <masak> hoelzro: all(Str, Cat) ~~ Stringy

[14:45] <timotimo> Blob or Buf or something is Stringy, too, no?

[14:45] <timotimo> m: say Blob ~~ Stringy

[14:45] <camelia> rakudo-moar 72852f: OUTPUT«True␤»

[14:45] <timotimo> m: say Buf ~~ Stringy

[14:45] <hoelzro> so .Stringy creates a Stringy, and .Str creates a Str, then

[14:45] <camelia> rakudo-moar 72852f: OUTPUT«True␤»

[14:45] <masak> hoelzro: there are no Stringy instances, so it tries to coerce to a type which does Stringy.

[14:46] <masak> m: say "foo".Stringy.^name

[14:46] <camelia> rakudo-moar 72852f: OUTPUT«Str␤»

[14:46] <masak> m: say 42.Stringy.^name

[14:46] <camelia> rakudo-moar 72852f: OUTPUT«Str␤»

[14:46] <hoelzro> ah ha

[14:48] <timotimo> do we still have the sillyness that Buf (or Blob?) will infinitely loop .Stringy on itself when we try to ~ it to something?

[14:48] *** Jerry__ left
[14:49] <psch> S05:2729 

[14:49] <synopsebot> Link: http://perlcabal.org/syn/S05.html#line_2729

[14:49] <psch> masak: ^^^

[14:49] * psch goes back to packing

[14:49] *** raiph left
[14:49] <hoelzro> I ask because code that wants to override behavior for stringification of uninit'd values will no longer be able to just override .Str =/

[14:49] <hoelzro> due to my patch

[14:50] *** rindolf left
[14:50] <hoelzro> it would also be nice to get my change working for "self = {self}", but I don't know if self is a container or not

[14:50] *** rindolf joined
[14:51] <timotimo> you can't nqp::iscont in that case?

[14:51] <timotimo> i think self is always decont'd for you

[14:52] <hoelzro> that would make sense

[14:52] <hoelzro> I don't know if my Rakudo fu .oO( Ra-fu-do? ) is strong enough to pull that off

[14:52] <hoelzro> but it's a start

[14:52] <timotimo> what happens if you annotate the invocant parameter of a method with "is rw"?

[14:53] <hoelzro> hmm

[14:53] * hoelzro tries

[14:53] <timotimo> m: class Test { method doit($foo is rw:) { say nqp::iscont(self); say nqp::iscont($foo) } }; Foo.new.doit;

[14:53] <camelia> rakudo-moar 72852f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/8LPpAFEAo_␤Undeclared name:␤    Foo used at line 1␤␤»

[14:53] <timotimo> m: class Test { method doit($foo is rw:) { say nqp::iscont(self); say nqp::iscont($foo) } }; Test.new.doit;

[14:53] <camelia> rakudo-moar 72852f: OUTPUT«0␤0␤»

[14:53] <timotimo> apparently not

[14:53] <hoelzro> =/

[14:54] <masak> psch: my first instinct was to disagree, as the example doesn't seem to be about that kind of case.

[14:54] <timotimo> m: class Test { method doit($foo is rw:) { say nqp::iscont(self); say nqp::iscont($foo) } }; my $foo = Test.new; $foo.doit;

[14:54] <camelia> rakudo-moar 72852f: OUTPUT«0␤1␤»

[14:54] <timotimo> aha!

[14:55] <timotimo> of course it's not in a container if you don't put it into one

[14:55] <masak> psch: but I think you're right. forbidding null patterns is mostly a syntactic thing, and when the null pattern is not syntactic, there's no sense in forbidding it.

[14:55] <masak> psch++

[14:56] <timotimo> hoelzro: did you see that?

[15:01] <lizmat> afk again&

[15:03] *** JimmyZ joined
[15:09] <hoelzro> timotimo: I did

[15:09] <hoelzro> since self itself isn't containerized, it makes what I want trickier =/

[15:16] *** JimmyZ left
[15:20] <jnthn> hoelzro: You can write something that keeps a containerized invocant around if you need it

[15:20] <jnthn> method foo(\SELF:) { ... }

[15:20] <jnthn> Gives you SELF with its container, if it had one

[15:21] *** mj41 joined
[15:22] <hoelzro> ah ha

[15:22] <hoelzro> well, I'm thinking of your average Joe Perl 6 programmer

[15:22] <hoelzro> who just writes something like method foo { "self = {self}" }

[15:23] <hoelzro> it would be nice if he (or she, if it's average Jane) saw "use of uninitialized value self of type Something in string context"

[15:23] *** guru joined
[15:23] <jnthn> ah

[15:23] *** ajr_ left
[15:23] <jnthn> Not sure how to make that one happen...

[15:24] <hoelzro> it's probably infrequent enough not to matter, but I thought it might be nice

[15:24] *** guru is now known as Guest82144

[15:24] *** Guest82144 is now known as ajr_

[15:24] *** brrt left
[15:24] <hoelzro> heck, "value = {$obj.method()}" do something special would be nice, but I think that would take deeper and darker wizardry than I'd care to add to Rakudo

[15:25] <hoelzro> jnthn: on an unrelated note, did you see that bug I found regarding an infinite loop in the regex engine?

[15:25] <hoelzro> m: 'pod' ~~ /'pod' $*/

[15:25] <camelia> rakudo-moar 72852f: OUTPUT«(signal )»

[15:26] <jnthn> ...uh, which signal is that? :)

[15:26] <jnthn> You quantified a zero-width thing. Tht's kinda asking for it.

[15:26] <jnthn> Though in this case we could statically detect it and whine.

[15:26] <TimToady> most regex compilers will specifically forbid quantifying something of known zero width

[15:26] <PerlJam> hoelzro: is it really like that in the code?  or does $* come from some indirection somehow?

[15:26] <jnthn> std: 'pod' ~~ /'pod' $*/ # curious

[15:26] <camelia> std ee1ef48: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of $* variable; in Perl 6 please use ^^ and $$ at /tmp/QwSfYuB3md line 1:␤------> [32m'pod' ~~ /'pod' $*[33m⏏[31m/ # curious[0m␤Parse failed␤FAILED 00:01 126m␤»

[15:26] <hoelzro> PerlJam: it's through indirection

[15:27] <jnthn> heh :)

[15:27] <hoelzro> I just golfed it down

[15:27] <jnthn> std: 'pod' ~~ /^* 'pod'/ # curious

[15:27] <camelia> std ee1ef48: OUTPUT«ok 00:01 125m␤»

[15:27] <hoelzro> jnthn, PerlJam: it happens during POD processing

[15:27] <jnthn> Darn, can't crib from STD

[15:27] <hoelzro> ex:

[15:27] <hoelzro> m: =begin title

[15:28] <camelia> rakudo-moar 72852f: OUTPUT«(timeout)»

[15:28] <hoelzro> I think it's pod_whitespace or something that has a $ in it, and we try matching <pod_whitespace>*

[15:29] *** raiph joined
[15:29] *** zakharyas left
[15:30] <dalek> rakudo/nom: 1e89800 | jonathan++ | src/Perl6/Actions.nqp:

[15:30] <dalek> rakudo/nom: Don't sink binds to array/hash/dynvar.

[15:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1e898008c1

[15:30] <dalek> rakudo/nom: 034cbdb | jonathan++ | src/core/Temporal.pm:

[15:30] <dalek> rakudo/nom: Only calcuate $*TZ the first time we need it.

[15:30] <dalek> rakudo/nom: 

[15:30] <dalek> rakudo/nom: This calculation used to be 7.19% of the time spent loading setting

[15:30] <dalek> rakudo/nom: on my box; on others where rel2abs isn't so terribly expensive it

[15:30] <dalek> rakudo/nom: probably counted for more.

[15:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/034cbdb70d

[15:30] <TimToady> that's kinda like saying <.ws>*

[15:31] <TimToady> whitespace rules should do their own quantification, usually

[15:31] <jnthn> I'm not sure what we decided on whether to try and detect non-progressing quantification.

[15:31] <jnthn> It will make the code generated for every single quantifier bigger...

[15:31] <hoelzro> pod_newline

[15:31] <TimToady> obviously we decided not to try yet :)

[15:31] <hoelzro> that's the offending rule

[15:32] <jnthn> TimToady: Yes, will, I'm generally not in a hurry to put in things that will slow us down and that the spec doesn't mandate ;)

[15:32] <jnthn> s/will/well/

[15:32] <hoelzro> granted, that's the offending rule after I removed the pod_configuration parsing

[15:32] <TimToady> where there's a well there's a way

[15:33] <hoelzro> it could be that the fix is to change the rule in the grammar, rather than "fix" the regex engine

[15:33] <PerlJam> hoelzro: technically, it's whatever calls <pod_newline>* that offends :)

[15:33] <hoelzro> PerlJam: true

[15:34] <hoelzro> I just found it shocking when curtispoe came across this behavior

[15:34] <PerlJam> though ...  why is $ in pod_newline?

[15:35] *** rindolf left
[15:35] *** rindolf joined
[15:37] <hoelzro> that's a good point

[15:37] <TimToady> "Why do we even have that lever?"

[15:37] <hoelzro> PerlJam++ # thinking things through

[15:38] <donaldh> jnthn: I still have NQPMatch objects getting serialized on JVM.

[15:38] <TimToady> I think the (at least temporary) decision was that we don't try to detect infinite loops or deadlock in other parts of the language, so why here?

[15:38] <donaldh> jnthn: definitely no derived grammars on rakudo latest

[15:39] <FROGGS> good evening

[15:39] <donaldh> jnthn: any suggestions for how to debug?

[15:39] *** chenryn joined
[15:39] <FROGGS> donaldh: I think I'm used to debug these things... what exactly is your problem?

[15:40] <PerlJam> .oO(  perl6 --FROGGS problem_script )

[15:40] <donaldh> FROGGS: the CORE.setting text is getting added to the CORE.setting.jar because Match objects are getting serialized.

[15:41] <donaldh> From what I can tell, 5 NQPMatch objects are getting serialized as part of the CORE.setting

[15:41] <FROGGS> ahh

[15:42] <FROGGS> donaldh: is that still about add_categorical or what it is called?

[15:42] *** awwaiid left
[15:42] <FROGGS> and does that only happen on jvm?

[15:42] <donaldh> I don't think so because I was tracing calls to add_categorical and there are none left.

[15:42] <FROGGS> k

[15:43] <FROGGS> let's think.... Labels and macros pass a match into the setting me thinks...

[15:44] <donaldh> It might only happen on JVM. jnthn++ declared victory for it in https://github.com/rakudo/rakudo/commit/8af523bd23b94ce6807462df96feec63579dc5f8

[15:45] <donaldh> Yeah, I was guessing it might be labels but they appear to deliberately avoid keeping the Match. The label code extracts info from the match and stores that instead.

[15:45] <FROGGS> k...

[15:45] <FROGGS> how do I check for these five NQPMatch objects?

[15:46] *** akaseki is now known as CrashNBurn

[15:46] *** CrashNBurn is now known as Salai

[15:46] <donaldh> Best I've managed to debug is NQPArray -> QAST::Want+{QAST::SpecialArg} -> NQPMatch is getting serialized.

[15:47] <donaldh> But I'm kind of working backwards so it's impractical to find where the NQPArray comes from :-)

[15:48] <dalek> rakudo/nom: c0ac56f | jonathan++ | src/core/Instant.pm:

[15:48] <dalek> rakudo/nom: Cheapen $*INITTIME handling.

[15:48] <dalek> rakudo/nom: 

[15:48] <dalek> rakudo/nom: Capture the value as a num at startup and stash it away. Use it to

[15:48] <dalek> rakudo/nom: lazily construct an Instant from it there first time we are asked.

[15:48] <dalek> rakudo/nom: This was 4% of the time in setting loading.

[15:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c0ac56fc4f

[15:49] *** kaleem joined
[15:49] <jnthn> donaldh: Look up add_inline_info or so in Actions.nqp and see if not calling that helps.

[15:50] <jnthn> donaldh: It's meant to strip out match objects, but maybe it leaks osmehow.

[15:50] <jnthn> *somehow

[15:50] <FROGGS> donaldh: do you look at the --target=ast of the setting compilation to see that?

[15:51] <donaldh> FROGGS: yes, big AST, no Matches iirc

[15:51] <donaldh> jnthn: add_inlining_info_if_possible ?

[15:51] <jnthn> donaldh: Yes, that one.

[15:51] <jnthn> Called from routine_def iirc

[15:51] <donaldh> yep

[15:52] <FROGGS> donaldh: I still don't know how you check that the setting contains NQPMatches and the CORE.setting text

[15:53] <donaldh> oh, planeteria.org domain has just expired - http://planeteria.org/perl6/

[15:53] <timotimo> oh, d'oh

[15:54] *** mj41 left
[15:54] <donaldh> FROGGS: I extract the setting .class from CORE.setting.jar then I run javap -v on the .class file. Shows all the constant strings in the classfile.

[15:54] <donaldh> Also all the bytecode, linenumber info, etc.

[15:55] <jnthn> Time for some sleep &

[15:55] <FROGGS> gnight jnthn 

[15:56] <timotimo> have a good rest, jnthn!

[15:56] <donaldh> jnthn++ (that might be it)

[15:59] <donaldh> Yep, it's coming from add_inlining_info_if_possible 

[16:00] <japhb> .ask jnthn When you're awake again, can you look at https://gist.github.com/japhb/a452a0a8dd7bd5682e1c ?  I'm concerned by *both* the weird NPE when threading, but also the fact that having threads <= items causes apparent lockup.  I would think the tasks would just share threads in the pool in the normal fashion, making for slow results, but no lock.

[16:00] <yoleaux> japhb: I'll pass your message to jnthn.

[16:00] <donaldh> .class file down to 7.7M from 9.1M

[16:00] <FROGGS> I see that CORE.setting.moarvm contains the core_prologue.pm, perhaps more

[16:00] <FROGGS> it is possible that it is truncated in the --dump

[16:01] <japhb> donaldh: Nice savings!

[16:01] <donaldh> jar down to 2.3M from 2.6M

[16:02] <donaldh> Just need to find out how matches are leaking through add_inlining_info_if_possible

[16:02] <japhb> donaldh: Do you know the threading code on r-j, or is that just jnthn?

[16:03] <donaldh> may just be jnthn. I've worked with bits of it for the async IO

[16:04] <FROGGS> CORE.setting.moarvm before: 12443832 - after: 10542224

[16:05] *** dayangkun left
[16:06] <donaldh> japhb: what bits?

[16:06] *** rindolf left
[16:07] *** rindolf joined
[16:07] *** Rotwang joined
[16:15] <japhb> I was mostly wondering if anyone else would be able to contemplate what's going wrong with my gist from 15 minutes ago.

[16:20] <donaldh> japhb: I might get a chance to take a look late this evening. I'm not hugely familiar with the promise implementation but can poke into it.

[16:20] * donaldh decommute&

[16:20] *** donaldh left
[16:21] <japhb> OK, thanks, donaldh

[16:22] *** anaeem1_ left
[16:25] *** Ven joined
[16:29] *** fhelmberger left
[16:35] *** isBEKaml joined
[16:40] <tadzik> oh, ingy :P "IO::All - I Owe All to Larry Wall!"

[16:49] <Timbus> m: "asdf" ~~ /../; say $/

[16:49] <camelia> rakudo-moar c0ac56: OUTPUT«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/CYZAdpCp6q:1␤␤｢as｣␤␤»

[16:49] <Timbus> ?

[16:51] *** kaare_ joined
[16:52] <Timbus> oh ok, its just something in .gist

[16:55] *** rindolf left
[16:55] *** mberends joined
[16:55] *** rindolf joined
[16:57] *** dakkar left
[16:59] *** ajr_ left
[17:06] *** tgt joined
[17:09] *** kaleem left
[17:17] *** pecastro left
[17:22] *** Ven left
[17:23] *** rindolf left
[17:23] *** MilkmanDan left
[17:23] *** rindolf joined
[17:24] *** tgt left
[17:26] *** MilkmanDan joined
[17:28] *** rindolf left
[17:29] *** rindolf joined
[17:34] *** numberone joined
[17:35] <dalek> rakudo-star-daily: 162b1f3 | coke++ | log/ (14 files):

[17:35] <dalek> rakudo-star-daily: today (automated commit)

[17:35] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/162b1f3133

[17:35] <dalek> perl6-roast-data: d5f13ff | coke++ | / (6 files):

[17:35] <dalek> perl6-roast-data: today (automated commit)

[17:35] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d5f13ff0f6

[17:36] *** Guest34380 left
[17:36] <numberone> perl6: say 1..7;

[17:36] <camelia> rakudo-jvm c0ac56: OUTPUT«(timeout)»

[17:36] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«1..7␤»

[17:36] <camelia> ..rakudo-{parrot,moar} c0ac56: OUTPUT«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/tmpfile:1␤␤use of uninitialized value of type Nil in string context  in block <unit> at /tmp/tmpfile:1␤␤1..7␤»

[17:38] <[Coke]> m: say ~1..7

[17:38] <camelia> rakudo-moar c0ac56: OUTPUT«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/vmtEftIgTt:1␤␤use of uninitialized value of type Nil in string context  in block <unit> at /tmp/vmtEftIgTt:1␤␤"1"..7␤»

[17:39] <[Coke]> m: say ~(1..7)

[17:39] <camelia> rakudo-moar c0ac56: OUTPUT«1 2 3 4 5 6 7␤»

[17:39] <[Coke]> gist--

[17:40] <isBEKaml> m: (1..7).perl.say; (1..7).gist.say;

[17:40] <camelia> rakudo-moar c0ac56: OUTPUT«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/6UDqvwfPx2:1␤␤use of uninitialized value of type Nil in string context  in block <unit> at /tmp/6UDqvwfPx2:1␤␤1..7␤use of uninitialized value of type Nil in string …»

[17:40] *** kjs_ left
[17:40] <isBEKaml> r: (1..7).perl.say; (1..7).gist.say;

[17:41] <camelia> rakudo-{parrot,jvm,moar} c0ac56: OUTPUT«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/tmpfile:1␤␤use of uninitialized value of type Nil in string context  in block <unit> at /tmp/tmpfile:1␤␤1..7␤use of uninitialized value of type Nil in …»

[17:41] <isBEKaml> Nil in string context?

[17:44] *** Rotwang left
[17:44] *** ecocode_ joined
[17:45] *** [Sno] left
[17:51] *** numberone left
[17:51] *** rindolf left
[17:51] *** rindolf joined
[17:52] *** Ven joined
[17:55] *** rindolf left
[17:55] *** rindolf joined
[17:57] *** Rotwang joined
[18:02] <spider-mario> http://www.reddit.com/r/programming/comments/2estux/in_2008_i_bought_a_book_titled_php_6_six_years/ck2z5qv?context=3

[18:02] <spider-mario> is that true?

[18:02] <spider-mario> (the “from the beginning” part)

[18:03] <colomon> I dunno about promised, but no one expected it to take very long at the start.

[18:03] <Ven> spider-mario: err, I think the beta was supposed to be "18 months away"

[18:04] <colomon> and the Perl 6 book that came out in 2003 is hilariously wrong.

[18:05] <nine> At least Perl 6.0 will be released. Unlike PHP 6. And at least it will be useful to the users of the previous version. Unlike Python 3.

[18:05] <PerlJam> colomon: it was updated in 2004 ;)

[18:05] <TimToady> the bizarrest thing: trying to recompile STD, and the bootstrap parser fails to parse some random op=, but it varies from run to run

[18:05] <spider-mario> the same redditor also says “they promise [Perl 5 compatibility] every summer after some hackathon and every year the proof of concept gets abandoned in a couple of months.”

[18:06] <Ven> the same redditor also says a lot of crap, tbh.

[18:06] <Ven> nine: python 2->3 took, what, 12 years, for around 4 changes in the behavior. Worth it!

[18:06] <spider-mario> I was suspecting that

[18:06] <Ven> (now they want gradual types :P)

[18:06] <colomon> spider-mario: I don't think that's true, I only recall one perl 5 compatibility promise since I started working on p6 in 2009 or so, and that v5 project is still ongoing.

[18:07] <spider-mario> yeah, print not a function, and except: syntax slightly different. :p

[18:07] <spider-mario> hm, ok

[18:07] <spider-mario> thanks

[18:07] <spider-mario> Ven: there are even changes that I find negative

[18:07] <spider-mario> for example, no destructuring in function signatures anymore

[18:07] <nine> Technically Inline::Perl5 did not start at a hackathon either. And I never meant for it to be just a proof of concept :)

[18:07] <Ven> spider-mario: IIRC, perl5 was in from the start, but I very much doubt "getting it working" was something they promised every year back then

[18:07] <colomon> actually, I guess there were two different promises last year, now that I think on it -- v5 and an idea for gluing p5 directly to Moar.  Dunno the status of the latter.

[18:08] <spider-mario> so lambdas that take tuples are less readable in python3

[18:08] <spider-mario> yeah, I’m hopeful about your project, nine :)

[18:08] <spider-mario> thanks, btw

[18:09] *** molaf_ joined
[18:09] * nine is just glad to finally be able to contribute something

[18:09] <PerlJam> nine++

[18:09] <spider-mario> nine++

[18:09] <hoelzro> ten

[18:09] <hoelzro> er, nine++

[18:12] *** molaf left
[18:12] <nine> I wonder why the Python 3 guys never tried having a Python 2 interpreter running in a separate process to allow a smooth upgrade. Doesn't sound that difficult to me.

[18:13] *** ecocode_ left
[18:13] <spider-mario> it would certainly have sped up its adoption

[18:13] <timotimo> with pypy, you could have two python interpreters with different versions in one process, afaict

[18:13] <Ven> oh, could you :)?

[18:13] <spider-mario> seeing as the main reason why people kept using python2 was the libraries

[18:13] *** ecocode_ joined
[18:13] * Ven brb: making nqp being able to run all languages at the same time&

[18:13] <timotimo> i think their code doesn't have globals that'd prevent that

[18:13] <nine> But pypy is not compatible to CPython either

[18:13] <isBEKaml> timotimo: one process? :O

[18:13] <spider-mario> but pypy only recently added support for Python 3

[18:14] <Ven> https://twitter.com/codemiller/status/495505344349491200

[18:15] <isBEKaml> nine: because making any interpreter compatible with something that has no spec of its own is masochism. :)

[18:17] *** ecocode_ left
[18:18] <nine> isBEKaml: but Python does have a somewhat reasonable spec. I wrote a compiler that compiles Python expressions to Perl for my master's thesis and I just took the grammar from the python documentation and it worked.

[18:18] *** virtualsue joined
[18:18] <isBEKaml> nine: I was referring to CPython. I'm aware Python does have a spec. 

[18:19] <ingy> tadzik: :) actually I coined that circa 2012

[18:25] <isBEKaml> nine: actually, I take that back. I searched and can only find the grammar specification - nothing else apart from that other than the language reference. 

[18:27] <isBEKaml> nine: This SO page says python doesn't have a full specification, per se. http://stackoverflow.com/q/1094961 [2009]

[18:28] *** rindolf left
[18:28] *** kurahaupo left
[18:28] *** rindolf joined
[18:31] *** gfldex joined
[18:34] *** isBEKaml left
[18:35] <lizmat> m: ~("b" if 0)  # golfed down problem that numberone saw

[18:35] <camelia> rakudo-moar c0ac56: OUTPUT«use of uninitialized value of type Nil in string context  in block <unit> at /tmp/YNUtimzGI4:1␤␤»

[18:37] <lizmat> I'm pretty sure that is a recent change

[18:37] <hoelzro> lizmat: I wondre if that's from my change

[18:38] <FROGGS> star-m: ~("b" if 0)

[18:38] <camelia> star-m 2014.04: ( no output )

[18:38] <lizmat> star: say ~("b" if 0)

[18:38] <camelia> star-{m,p} 2014.04: OUTPUT«␤»

[18:39] <FROGGS> m: say ("b" if 0).perl

[18:39] <camelia> rakudo-moar c0ac56: OUTPUT«Nil␤»

[18:39] <lizmat> this pattern is used all over the place in the setting

[18:39] *** SamuraiJack left
[18:39] <TimToady> Nil isn't supposed to turn into () anymore

[18:39] *** [Tux] joined
[18:40] <lizmat> so anywhere we do postfix if in a stringification, we would need to turn it into a ternary ?

[18:40] <[Tux]> rakudobrew should detect where it is installed and not blindly assume it is in ~/.rakudobrew

[18:40] <hoelzro> yeah, I think that's my fault

[18:40] <hoelzro> Nil needs to override Stringy as well as Str

[18:41] <lizmat> well, maybe you changed it according to spec

[18:41] <hoelzro> either that, or I have to devise a good way to not warn twice when invoking Str from Stringy

[18:41] <hoelzro> on accident? =P

[18:41] <lizmat> if I understand TimToady correctly

[18:41] <TimToady> "b" if 0 should prbably be returning () these days

[18:41] <TimToady> not Nil

[18:41] <TimToady> I've been working on removing the list semantics from Nil, but it's a tough one

[18:43] <FROGGS> how do we return () here? https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L866

[18:43] <timotimo> just call to infix:<,>?

[18:43] <timotimo> without arguments?

[18:44] <FROGGS> hmmm

[18:44] <FROGGS> this could work

[18:45] *** ren1us joined
[18:47] *** rindolf left
[18:47] <flussence> tmux a

[18:47] *** rindolf joined
[18:49] <flussence> WHOOPS

[18:49] <flussence> ww.

[18:49] <flussence> (jeez, ww, and capslock in a row...)

[18:50] <flussence> we don't have a websockets module yet, do we? I'm looking for something to code during travel downtime...

[18:53] *** guru joined
[18:54] *** guru is now known as Guest59688

[18:54] *** Guest59688 is now known as ajr_

[18:59] <hoelzro> is there a way to check if a dynamic variable exists?

[18:59] <hoelzro> I basically want to do if $*SOMETHING, defaulting to False for $*SOMETHING's value if it's not found

[19:00] <TimToady> defined is the best you've got

[19:00] <hoelzro> TimToady: that should work, thanks

[19:01] *** rindolf left
[19:02] *** rindolf joined
[19:03] *** Rotwang left
[19:06] <PerlJam> Seems like $*SOMETHING // False is what's wanted from here.

[19:09] *** Ven left
[19:10] *** chenryn left
[19:10] * lizmat is looking at the rel2abs issue

[19:10] <nwc10> cool

[19:10] <nwc10> thanks for digging into that

[19:11] *** [Sno] joined
[19:12] <lizmat> fwiw, with moarVM, *all* calls to rel2abs are redundant at startup, as all paths *are* already absolute

[19:12] <PerlJam> [Coke]: btw, Happy Anniversary!  It'll be my 19th in 3 days  :)

[19:13] <colomon> PerlJam: that's a lot of anniversaries to have in just 3 days!

[19:13] <lizmat> furthermore, each path has 2 rel2abs calls

[19:14] <nwc10> to be sure to be sure :-/

[19:15] <lizmat> indeed...  :-(

[19:15] <labster> uh oh, sounds like I did something stupid

[19:15] <colomon> labster!

[19:15] <labster> good *, everyone

[19:16] <PerlJam> hey labster!  LTNS

[19:17] *** ecocode_ joined
[19:17] *** rindolf left
[19:17] <labster> rel2abs sounds like my handiwork.  Or at least it was at one time.

[19:17] <timotimo> oh, labster is back :)

[19:17] *** rindolf joined
[19:17] <lizmat> fg

[19:18] <labster> Hey, I've been in channel, just occupied with other things.  I'm going to claim $dayjob things, but launching a wiki was in there too.

[19:18] *** darutoko left
[19:19] <colomon> labster: whatever, just glad to see you back!  :)

[19:19] <timotimo> aye

[19:22] *** Ven joined
[19:22] <labster> I've been looking at the module smoke testing... can anyone (maybe [Coke]) tell me what caused File::Spec::Case to fail?

[19:23] <itz> are there any yapcasia perl6 streams likely?

[19:26] <[Coke]> did yapc:eu streams get saved somewhere?

[19:26] <itz> I'd hope they might be available in the promised week or two

[19:26] *** Ven_ joined
[19:27] *** Ven left
[19:28] <tadzik> nine | At least Perl 6.0 will be released. Unlike PHP 6.

[19:28] <tadzik> nine: well, how can you know either? :)

[19:28] *** kurahaupo joined
[19:29] <tadzik> I'm around for about 4 years I think, and I don't recall at any point anyone being sure on what Perl 6.0 will even be

[19:29] <tadzik> (sorry for being a slowpoke)

[19:29] <tadzik> labster! \o/

[19:30] <PerlJam> [Coke], itz: I have a link, but I don't know how "public" it is or should be.

[19:30] <Ven_> tadzik: 'cause they're jumping to php7

[19:30] <Ven_> so, no php6.

[19:30] <dalek> rakudo/nom: 5ba59f4 | (Elizabeth Mattijsen)++ | src/core/IO/Spec/Unix.pm:

[19:30] <dalek> rakudo/nom: Make Unix is-absolute test cheaper

[19:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ba59f4592

[19:30] <tadzik> Ven_: ahahaha, seriously? :D

[19:30] <Ven_> tadzik: yeeep.

[19:31] <tadzik> this reminds me of a few things...

[19:31] <labster> tadzik! o/

[19:31] <FROGGS> tadzik: you can read about php6/7 in their wiki

[19:31] <FROGGS> in short: "6" is equivalent to failure

[19:32] <labster> I thought we all agreed that Perl 6 will be awesome.

[19:32] <nwc10> lizmat: would be nice if an optimiser could figure out the change in 5ba59f4592

[19:32] <nwc10> but that's a bug for another day

[19:32] <FROGGS> labster: I think it is awesome, aye

[19:32] <PerlJam> labster: *IS* awsome

[19:32] <PerlJam> er, aweseom

[19:32] <PerlJam> er, blah!

[19:32] <labster> lizmat++

[19:32] <FROGGS> *is* blah!

[19:34] <nine> tadzik: PHP 6 has been officially cancelled. The next one will be 7. And believing that Perl 6 is going to be released is as close as I can become to being religious ;)

[19:35] <flussence> they had a good reason for skipping php6... they'd proclaimed all the "hard" unicode fixing work would be deferred to that version.

[19:35] <Ven_> the beta is awesome :P

[19:35] <flussence> so by skipping it entirely, they never had to do any work!

[19:35] <nine> tadzik: also I can somewhat influence a relase of Perl 6 by contributing ;)

[19:35] <FROGGS> well, it might not be close fsdo close

[19:35] <dalek> rakudo/nom: 70e9be5 | (Elizabeth Mattijsen)++ | src/core/IO/Spec/Unix.pm:

[19:35] <dalek> rakudo/nom: Reduce the number of $*CWD lookups in rel2abs

[19:35] <dalek> rakudo/nom: 

[19:35] <dalek> rakudo/nom: Was at least one, even when not needed.

[19:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/70e9be5673

[19:36] <Ven_> nine: I didn't want to "believe" anything -- that's lame

[19:36] <Ven_> so I just started using it in prod.

[19:37] <FROGGS> I'd need at least libxml bindings plus a port of XML::Compile me thinks

[19:37] <PerlJam> Ven_: I'm finally over that hurdle myself.   A coworker asked me the other day if I'd use Perl 6 in production and not only did I say "yes", but I'd already used it in a couple of small projects.

[19:38] <tadzik> I see; true; but what I meant to bring up is that everytime sometimes comes here and asks "when will 6.0 be released?" we all go "but... but you can use it today!!1"

[19:38] <Ven_> PerlJam: well, I don't have any million-lines project in it. It's just that releasing, versioning managing, history management (+ generating log file), processing some files, etc.

[19:38] <tadzik> while it's true, I don't think that anyone has a goal in mind when they think Perl 6.0

[19:38] <tadzik> neither the late-adopters, neither the contributors, such as us

[19:39] <Ven_> tadzik: "a goal in mind"?

[19:39] <tadzik> and if the developers themselves don't know what Perl 6.0 is actually going to be, it's hard for me to imagine a Release

[19:39] <FROGGS> tadzik: NFG + shaped Arrays... maybe the list refactor, that is it I think

[19:40] <tadzik> FROGGS: I think it'd be a wise move, even if it's just a marketing move, to say "we're <this> far from Perl 6.0, look how close we are"

[19:40] <FROGGS> tadzik: true

[19:40] <tadzik> if <this> is NFG + shaped Arrays + the list refactor, it's fine by me

[19:40] <PerlJam> I don't think so.

[19:40] <Ven_> it's hard to judge how many percents

[19:40] <Ven_> I think lizmat said 80%, but I think a lot more

[19:40] <PerlJam> I think the best marketing now will be: Here's an "official" Perl 6 compiler release!

[19:40] <FROGGS> Ven_: don't talk about percent and don't say how long it will take

[19:40] <Ven_> well, I only know from RFCs and not from implem-PoV :)

[19:41] <FROGGS> just say that there is knowledge about what is missing

[19:41] <flussence> I still kinda want p6regex-on-Bufs to work as specced...

[19:42] <lizmat> we also need native array support and jitted

[19:42] <FROGGS> lizmat: we do not need a JIT to comply to a spec

[19:42] <lizmat> true

[19:42] <tadzik> I think JIT is the "nice to have" thing

[19:42] <Ven_> well, the spec does say "jit" now :)

[19:42] <tadzik> oh :)

[19:43] <tadzik> doesn't it say "should be jittable"?

[19:43] <Ven_> tadzik: you got me :P

[19:43] <tadzik> at least today's patch

[19:43] <lizmat> ok, just native arrays then  :-)

[19:43] <Ven_> well, it still has "jit" in it :-)

[19:43] <flussence> seems like we've eased off on the "torturing implementors for the benefit of users" mantra :)

[19:43] *** rindolf left
[19:44] *** rindolf joined
[19:44] <FROGGS> also, we need to work on HTTP::UserAgent cross-platformability to be able to use that as a base for the connection to CPAN

[19:44] <colomon> flussence: I'm sure the turning point was when pmichaud++ talked TimToady++ into rewriting the sequence operator so it could be sanely implemented.  ;)

[19:45] <Ven_> colomon: when was that :P?

[19:45] <colomon> Ven_: round about YAPC::NA 2010, maybe?  The one in Columbus.

[19:46] <Ven_> it indeed seems pmichaud++ has less time these days

[19:46] <FROGGS> Ven_: well, it seems to change since two weeks or so :o)

[19:46] <colomon> Ven_: yes

[19:47] <Ven_> FROGGS: he surfaced 2 weeks before, too :p

[19:47] <FROGGS> but he was there like three days in a row *g*

[19:47] <colomon> Ven_: with luck that's changing now, but his time has been very precious the last few years

[19:47] <FROGGS> that must mean something *g*

[19:47] <flussence> r: my uint16 $FOO = 0; my uint16 \BAR = 1;

[19:47] <camelia> rakudo-{parrot,jvm} c0ac56: OUTPUT«Type check failed in binding; expected 'uint16' but got 'Int'␤  in block <unit> at /tmp/tmpfile:1␤␤»

[19:47] <camelia> ..rakudo-moar c0ac56: OUTPUT«Type check failed in binding; expected 'uint16' but got 'Int'␤  in any bind_error at src/vm/moar/Perl6/Ops.nqp:221␤  in block <unit> at /tmp/tmpfile:1␤␤»

[19:48] <flussence> r: my uint16 $FOO = 0

[19:48] <camelia> rakudo-{parrot,jvm,moar} c0ac56: ( no output )

[19:48] <flussence> that only breaks for sigilless, and I'm not sure why...

[19:51] <flussence> (also, writing «my uint16 \FOO := 0;␤» in the REPL perma-breaks everything)

[19:52] <lizmat> there are tests for this in roast that are being skipped because of this

[19:52] <lizmat> so it's a known NYI issue

[19:52] *** hagiri joined
[19:52] <flussence> oh, okay

[19:54] *** FROGGS left
[19:54] *** telex left
[19:54] *** hagiri left
[19:54] <dalek> rakudo/nom: 69add21 | (Elizabeth Mattijsen)++ | src/core/CompUnit (2 files):

[19:54] <dalek> rakudo/nom: Paths for compunits need to be absolute now

[19:54] <dalek> rakudo/nom: 

[19:54] <dalek> rakudo/nom: We're going to assume they are.  This shaves ~ .02 seconds off of startup time.

[19:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69add218a7

[19:55] * colomon has parallel rakudo builds going on on two different accounts on his linux box.  :)

[19:55] <dalek> roast: 3f87fb4 | (Elizabeth Mattijsen)++ | S22-package-format/local.t:

[19:55] <dalek> roast: Paths need to be absolute always

[19:55] <dalek> roast: review: https://github.com/perl6/roast/commit/3f87fb4d16

[19:56] *** telex joined
[19:57] *** Ovid joined
[19:58] *** Ovid is now known as Guest39120

[20:00] *** FROGGS joined
[20:02] *** ren1us left
[20:04] *** rindolf left
[20:04] *** rindolf joined
[20:23] <nine> I still think that declaring anything an official 6.0 release without any backwards compatability would be very unwise. Learn from Python 3's failure.

[20:25] <FROGGS> nine: but that is the reason to have "6.0", to not be forced to be backwards compatible

[20:25] <FROGGS> of course, a migration path is very very important

[20:25] <PerlJam> and a plan for forwards incompatibility would be nice too  (learn from Perl 5 :)

[20:26] <FROGGS> use experimental, use feature... I like it :o)

[20:26] <nine> A migration path that does not involve rewriting CPAN (which is large) and proprietary code (which is probably much larger).

[20:27] <lizmat> re core_epilogue source being in the setting: I suspect "Perl6::Metamodel::GrammarHOW.HOW.compose(Perl6::Metamodel::GrammarHOW);"

[20:27] <lizmat> not sure how to fix

[20:27] <lizmat> the rel2abs is being called for any filetest operation

[20:27] <FROGGS> nine: a migration path for me means that there are adjustments needed to a codebase, that are of reasonable size

[20:28] <FROGGS> nine: it is not realistic that we just can run P5 code without any change at all

[20:28] <lizmat> one solution would be to put an is-absolute test in each of the filetest operations

[20:28] <lizmat> another solution could be candidates with the is-absolute test built in ?

[20:28] <lizmat> in the MMD, I mean

[20:29] <FROGGS> can't we cache the absolute path of a path?

[20:29] <lizmat> sure we can, but these all operate on strings

[20:29] <nine> FROGGS: well I think it is :)

[20:30] <FROGGS> nine: if you run the codebase using the perl 5 interpreter...

[20:30] <lizmat> take .e:

[20:30] <lizmat> method e() {

[20:30] <lizmat>         nqp::p6bool(nqp::stat(nqp::unbox_s(IO::Spec.rel2abs(self.Str)),

[20:30] <lizmat>                               nqp::const::STAT_EXISTS))

[20:30] <lizmat>     }

[20:31] <lizmat> hmmm... I guess we could do an absolute path in there

[20:31] <lizmat> ok, will look at that tomorrow...

[20:31] <lizmat> for now, I'm tired and sleepy so good night #perl6!

[20:31] <FROGGS> nine: but then there is no migration going on

[20:31] <FROGGS> gnight lizmat 

[20:32] *** kaare_ left
[20:32] <FROGGS> nine: how do I rewrite a part of my large codebase when the rest that is using it is P5?

[20:32] *** awwaiid joined
[20:32] *** ecocode_ left
[20:33] *** ecocode_ joined
[20:33] <flussence> .oO( crazy proposal: absolute/relative paths could be separated, like absolute/relative times )

[20:33] <FROGGS> personally I would rewrite only these parts first that are ugly or need extensions... but what if these parts are used heavily by the codebase and not just use the codebase?

[20:34] <[Coke]> nine: perhaps python three's issue was that they didn't change enough.

[20:37] *** ecocode_ left
[20:37] *** jdv79 left
[20:39] *** rindolf left
[20:39] *** rindolf joined
[20:40] *** rindolf left
[20:46] *** kurahaupo left
[20:46] <TimToady> FROGGS: I suspect we're going to have to leave Nil with () semantics for now; everything I've tried has ended up stymied somewhere deep in the internals

[20:47] <colomon> smoke test appears to be frozen in Test-ClientServer?

[20:47] <FROGGS> TimToady: yeah, I was fearing that there is a rather large impact :/

[20:47] <flussence> I think Python's mistake wasn't the amount of change, but that it was poorly distributed between the boring and fun parts.

[20:47] *** beastd left
[20:47] <flussence> colomon: Oh! That module's probably my fault. I don't know why it'd be stuck though...

[20:47] *** mr-foobar left
[20:48] <TimToady> I just remember when I first heard the proposed changes, I said to myself, "You're gonna break backward compatibility just for that?!?"

[20:48] *** pippo joined
[20:48] <pippo> o/ #perl6

[20:48] <pippo> I think I have found a regression:

[20:48] <pippo> m: my $now = now; my @a; for ^20_000 {@a.push: $(1...20)}; say now - $now;

[20:49] <flussence> hm, that module's hanging in tests for me too. will look into it.

[20:49] <camelia> rakudo-moar 69add2: OUTPUT«(timeout)»

[20:49] <pippo> that takes almost 40 seconds on my box!

[20:50] <TimToady> m: my $now = now; my @a; for ^20_000 {@a.push: $(1..20)}; say now - $now;

[20:50] <camelia> rakudo-moar 69add2: OUTPUT«1.9166325␤»

[20:51] <TimToady> ... is a fairly heavyweight operator

[20:51] <colomon> flussence: thanks

[20:51] <TimToady> though it really should know that 1...20 is constant foldable

[20:52] <flussence> there's two problems - the test is hanging, and also the timeout code that's supposed to be a safety net for that isn't doing anything...

[20:52] <TimToady> m: constant $range = 1..20; my $now = now; my @a; for ^20_000 {@a.push: $range}; say now - $now;

[20:52] <camelia> rakudo-moar 69add2: OUTPUT«3.3303724␤»

[20:53] <TimToady> heh, that's slower?

[20:53] <pippo> m: my $now = now; my @a; for ^20_000 {@a.push: $('1,2,3,4,5,6,7'.split(',')}; say now - $now;

[20:53] <camelia> rakudo-moar 69add2: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/aRGSRpNhAF␤Unable to parse expression in contextualizer; couldn't find final ')' ␤at /tmp/aRGSRpNhAF:1␤------> [32m0 {@a.push: $('1,2,3,4,5,6,7'.split(',')[33m⏏[31m}; say now - $now;[0m…»

[20:53] <TimToady> m: constant $range = eager 1..20; my $now = now; my @a; for ^20_000 {@a.push: $range}; say now - $now;

[20:53] <camelia> rakudo-moar 69add2: OUTPUT«2.90769890␤»

[20:53] <pippo> m: my $now = now; my @a; for ^20_000 {@a.push: $('1,2,3,4,5,6,7'.split(','))}; say now - $now;

[20:53] <TimToady> m: constant $range = list 1..20; my $now = now; my @a; for ^20_000 {@a.push: $range}; say now - $now;

[20:54] <camelia> rakudo-moar 69add2: OUTPUT«(timeout)»

[20:54] <camelia> rakudo-moar 69add2: OUTPUT«2.6700113␤»

[20:54] <TimToady> m: constant $range = $(1..20); my $now = now; my @a; for ^20_000 {@a.push: $range}; say now - $now;

[20:54] <camelia> rakudo-moar 69add2: OUTPUT«0.1451941␤»

[20:54] <TimToady> oh wow

[20:54] <pippo> TimToady: that is even slower. 75 secs

[20:54] <colomon> TimToady: what does @a.push: $(1..20) push on @a?

[20:54] <TimToady> pushes the range as an item

[20:54] <TimToady> push will otherwise flatten

[20:55] <colomon> that seems like an odd thing to time?

[20:56] <TimToady> pippo: notice that last one of mine was more then 10 times faster than inlining $(1..20)

[20:56] <Ven_> colomon: push is slow, let's make it better :)

[20:56] <colomon> Ven_: it's not the push, it's what is being pushed that strikes me as weird

[20:56] <TimToady> m: constant $range = $(1..20); my $now = now; my @a = $range xx 20000; say now - $now;

[20:56] <camelia> rakudo-moar 69add2: OUTPUT«0.3903180␤»

[20:58] <TimToady> m: constant range = $(1..20); my $now = now; my @a = range xx 20000; say now - $now;

[20:58] <camelia> rakudo-moar 69add2: OUTPUT«0.0323894␤»

[20:58] <TimToady> makes a big difference if you don't thunk the left side of xx

[20:59] <TimToady> m: constant range = $(1..20); my $now = now; my @a; for ^20_000 {@a.push: range}; say now - $now;

[20:59] <pippo> TimToady: I am parsing a CVS file and I am putting all lines on an array. so that for example @a[n] is a list of CVS's line n values.

[20:59] <camelia> rakudo-moar 69add2: OUTPUT«0.14698392␤»

[20:59] <Ulti> spider-mario the redditor you keep referring to is "carlosdelrey" previously "educatedpoo" and almost certainly a sock puppet account for a disgruntled core dev of *something* relating to Perl. No one else would care this much or be this negative.

[21:00] <pippo> This is the reason I have used .split(',')

[21:00] <Ulti> spider-mario: check all of the posts by carlosdelrey they are immediately after anything relating to Perl6 where he will just spread FUD against any announcement of progress even on /r/programming if he/they/it thinks it might be interesting enough to make it there

[21:01] <spider-mario> hm, ok :|

[21:01] <spider-mario> thanks

[21:01] <Ulti> the fact it is someone close is kind of both worse and good, at least a lot of the stuff is at least accurate when its not FUD

[21:03] <pippo> TimToady: note that I can leave with it. I am only willing to report the regression for #perl6 information. :-)

[21:03] <TimToady> in what sense has it regressed?  wasn't it always slow?

[21:03] <Ven_> pippo: why'd you leave when it's so nice here?

[21:04] <TimToady> s/leave/live/ I suspect

[21:04] <TimToady> but I agree it would be nice to make it faster, for sure

[21:05] <FROGGS> star-m: my $now = now; my @a; for ^20_000 {@a.push: $(1...20)}; say now - $now;

[21:05] <camelia> star-m 2014.04: OUTPUT«7.47283248␤»

[21:05] <FROGGS> star-m: my $now = now; my @a; for ^20_000 {@a.push: $(1...20)}; say now - $now;

[21:05] <pippo> TimToady: It was fast. yes. I had a proggy that used to cmplete in 1m40s and now it takes 6m(inutes). I golfed the problem to this.

[21:05] <camelia> star-m 2014.04: OUTPUT«7.4162025␤»

[21:05] <TimToady> okay, that's a regression :)

[21:06] <pippo> TimToady: :-)

[21:07] <pippo> star-m: my $now = now; my @a; for ^20_000 {@a.push: $('1,2,3,4,5,6,7'.split(','))}; say now - $now;

[21:07] <camelia> star-m 2014.04: OUTPUT«8.5555218␤»

[21:07] <flussence> anyone currently awake && familiar with S17 stuff? I can't figure out why this isn't hitting the timeout when it should: https://github.com/flussence/Test-ClientServer/blob/master/lib/Test/ClientServer.pm#L19

[21:07] <pippo> Wow! This is fast! Why is it faster than m: ??

[21:08] <pippo> FROGGS: ??

[21:08] <FROGGS> pippo: because it is from april

[21:08] <pippo> FROGGS: :-))

[21:09] <TimToady> m: my $now = now; $('1,2,3,4,5,6,7'.split(',')) xx 20000; say now - $now;

[21:09] <camelia> rakudo-moar 69add2: OUTPUT«8.9287004␤»

[21:09] <grondilu> m: sleep 2; say now - BEGIN now # testing if this idiom still works

[21:09] <camelia> rakudo-moar 69add2: OUTPUT«2.051403␤»

[21:09] <TimToady> star-m: my $now = now; $('1,2,3,4,5,6,7'.split(',')) xx 20000; say now - $now;

[21:09] <camelia> star-m 2014.04: OUTPUT«(timeout)»

[21:10] <TimToady> star-m: my $now = now; $('1,2,3,4,5,6,7'.split(',')) xx 20000; say now - $now;

[21:10] <camelia> star-m 2014.04: OUTPUT«(timeout)»

[21:10] <TimToady> that part seems to be slower...

[21:11] <TimToady> maybe it's sinking

[21:11] <TimToady> star-m: my $now = now; my @a = $('1,2,3,4,5,6,7'.split(',')) xx 20000; say now - $now;

[21:11] <camelia> star-m 2014.04: OUTPUT«(timeout)»

[21:11] <TimToady> m: my $now = now; my @a = $('1,2,3,4,5,6,7'.split(',')) xx 20000; say now - $now;

[21:11] <camelia> rakudo-moar 69add2: OUTPUT«8.368638␤»

[21:11] <TimToady> yeah, the split is faster than it was

[21:12] <pippo> Indeed.

[21:12] <TimToady> m: constant range = $(1..20); my $now = now; my @a; for ^20_000 {@a.push: range}; say now - $now;

[21:12] <camelia> rakudo-moar 69add2: OUTPUT«0.24714300␤»

[21:12] <TimToady> m: constant range = $(1..20); my $now = now; my @a; for ^20_000 {@a.push: range; 42}; say now - $now;

[21:13] <camelia> rakudo-moar 69add2: OUTPUT«0.3108323␤»

[21:13] <FROGGS> reported as RT #122641: speed regression when pushing a range to an array

[21:13] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122641

[21:14] <TimToady> I think there was a push with single argument "optimization" that may have come since star-m

[21:14] <TimToady> possibly it's pessimal in this case

[21:15] <Ven_> there has, iirc

[21:15] <pippo> star-m: my $now = now; my @a; for ^20_000 {@a.push: $(<a b c d e f g>)}; say now - $now;

[21:16] <camelia> star-m 2014.04: OUTPUT«2.5859714␤»

[21:16] <cognome> Hi. How can I refer to a rule in a grammar to pass it as an argument to some other rule in the same grammar?

[21:16] <pippo> m: my $now = now; my @a; for ^20_000 {@a.push: $(<a b c d e f g>)}; say now - $now;

[21:16] <camelia> rakudo-moar 69add2: OUTPUT«0.1564487␤»

[21:16] <pippo> I am scratching my head :-))

[21:17] <TimToady> m: my $now = now; my @a; for ^20_000 {@a.push: $('1,2,3,4,5,6,7'.split(','))}; say now - $now;

[21:17] <camelia> rakudo-moar 69add2: OUTPUT«(timeout)»

[21:17] <TimToady> m: my $now = now; my @a; for ^20_000 {@a.push: (), $('1,2,3,4,5,6,7'.split(','))}; say now - $now;

[21:17] <cognome> ... short of using  TheGramar.^find_method('rule-name')

[21:17] <camelia> rakudo-moar 69add2: OUTPUT«6.8820434␤»

[21:18] <TimToady> see, pushing two elements, even though one of them is empty, is much faster

[21:18] *** virtualsue left
[21:18] *** donaldh joined
[21:18] <grondilu> m: grammar Foo { rule bar {} }; say &Foo::bar

[21:18] <camelia> rakudo-moar 69add2: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ZOR3LPSHU3␤Null regex not allowed␤at /tmp/ZOR3LPSHU3:1␤------> [32mgrammar Foo { rule bar {[33m⏏[31m} }; say &Foo::bar[0m␤    expecting any of:␤        statement list␤        prefi…»

[21:18] <grondilu> m: grammar Foo { rule bar { . } }; say &Foo::bar

[21:18] <camelia> rakudo-moar 69add2: OUTPUT«(Any)␤»

[21:18] <pippo> TimToady: Yes! I'll yuse this work around for now.

[21:18] <grondilu> m: grammar Foo { rule bar { . } }; say /<Foo::bar>/

[21:18] <camelia> rakudo-moar 69add2: OUTPUT«␤»

[21:18] <grondilu> m: grammar Foo { rule bar { . } }; say rx/<Foo::bar>/

[21:18] <camelia> rakudo-moar 69add2: OUTPUT«␤»

[21:19] <pippo> TimToady: thank you.

[21:19] <nine> FROGGS: use Inline::Perl6 to add new parts to your existing codebase. Use Inline::Perl5 to re-use existing code parts in new programs.

[21:20] <cognome> grondilu++

[21:20] <FROGGS> nine: in both cases as strings that get evaled in the foreign language?

[21:21] <nine> [Coke]: yes, Python 3 was certainly not appealing enough to abandon whole code bases... But has there ever been an example of a completely incompatible new version of any widely used programming language being successful?

[21:21] <grondilu> (C++ in a way)

[21:21] <flussence> does SQL count? :)

[21:22] <nine> FROGGS: probably yes. Or even with better integration since Perl does allow much molding. But from my experience with Inline::Python I can tell you that eval'ed strings would make up just a tiny part of the code. Take the trivial example on https://github.com/niner/Inline-Perl5

[21:22] <nine> $i.run() is the eval part. The rest looks like plain normal Perl 6 objects and method calls.

[21:23] <FROGGS> nine: yes sure, that example is very nice :o)

[21:23] <donaldh> Hmm, I don't think C++ has ever been completely incompatible with C or earlier C++es.

[21:23] <donaldh> marginally incompatible, yes.

[21:24] <Ven_> donaldh: yeah, there deprecate or change very minor stuff sometimes

[21:24] <nine> donaldh: it's compatible enough that you usually can start switiching by using a C++ compiler on your existing C codebase with just trivial modifications.

[21:25] <donaldh> Yeah, name mangling is the first thing that bites and extern "C" fixes that.

[21:25] * donaldh is trying to think of completely incompatible new versions and is failing.

[21:26] <donaldh> ^^ successful ones

[21:26] *** virtualsue joined
[21:26] *** gcifuentes joined
[21:27] <dalek> nqp: b598bd7 | (Donald Hunter)++ | src/vm/jvm/QAST/Compiler.nqp:

[21:27] <dalek> nqp: Remove bogus OperationsJAST.map_classlib_core_op calls that break nqp::sayfh

[21:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b598bd7b50

[21:27] <nine> Does anyone want to bet Perl 6's success on it being the first to achieve this feat? Frankly I don't. Even though if any new version can do it, it's probably Perl 6. But I'd much rather play it safe by allowing a piecemeal migration.

[21:28] <donaldh> Especially since a Perl 6 goal is seamless language interoperability.

[21:29] <Ven_> donaldh: well, there has been other stuff. function removed, default move constructor, and some "minor" stuff like that.

[21:29] <grondilu> 'use v5;' will be Perl 6's 'extern "C"'

[21:30] <grondilu> so P6 will be as incompatible with P5 as C++ is to C, imho

[21:30] <donaldh> I think the really useful stuff will come via use ... :from<v5>; use ... :from<java> etc.

[21:31] <grondilu> yeah, granted.

[21:31] <Ven_> The useful stuff will come from from ;)

[21:31] <nine> I want all of them :)

[21:31] <Ven_> .oO( gotta use 'em all )

[21:32] <Ven_> whhoops, only 30 min for me to finish my work. eh!

[21:32] <nine> use Inline::Java via Inline::Perl5 ;)

[21:32] <cognome> my question reminds me that I have this pull request for rakudo : https://github.com/rakudo/rakudo/pull/279

[21:34] <cognome> or should I revert the patch for the corressponding spec?

[21:34] <cognome> https://github.com/perl6/specs/commit/67579a1cf7

[21:36] *** itz_ joined
[21:38] <FROGGS> cognome: I think it makes sense

[21:38] <FROGGS> (to apply it, not to revert it)

[21:38] *** itz left
[21:38] <dalek> std: 53b3ca6 | TimToady++ | STD.pm6:

[21:38] <dalek> std: clean up misleading P5 special var warnings

[21:38] <dalek> std: 

[21:38] <dalek> std: Remove the tests for rare variables, especially those that will become

[21:38] <dalek> std: syntax errors anyway, like $) and friends.  This also allows us to parse

[21:38] <dalek> std: bare sigils as rvalues, so we don't have to distinguish ($a,*,$c) = ...

[21:38] <dalek> std: from my ($a,$,$c) = ... anymore.  That is, if you use a bare $ as an

[21:38] <dalek> std: rvalue, we'll simply declare an anonymous variable for you now.  If we

[21:38] <dalek> std: make the declarator default to 'state', it might even be useful as $++.

[21:38] <dalek> std: review: https://github.com/perl6/std/commit/53b3ca6ff2

[21:39] <FROGGS> ohh, nice

[21:40] <dalek> rakudo/nom: 3ce25ec | TimToady++ | src/core/List.pm:

[21:40] <dalek> rakudo/nom: remove single arg push as pessimal

[21:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ce25eccf1

[21:40] <TimToady> pippo: ^^^

[21:40] <pippo> TimToady: Trying...

[21:40] *** btyler joined
[21:41] *** ggoebel111118 joined
[21:41] *** itz joined
[21:41] <Ven_> TimToady++ # annoying $) and friends :P

[21:41] <Ven_> please no $++, though.

[21:41] *** itz_ left
[21:42] *** donaldh_ joined
[21:42] <TimToady> well, at least you'll be able to say state $++ now

[21:43] <Ven_> and yay for that :-)

[21:43] <Ven_> I mean, no `$++ for state $++`

[21:43] <Ven_> sorry for not being very clear, I'm happy with state $++.

[21:43] *** ggoebel111117 left
[21:44] <TimToady> so you think it should default to my $ then?

[21:45] <TimToady> that's probably the simplest, and still lets you say $++ for a non-state counter

[21:45] *** donaldh left
[21:45] *** kurahaupo joined
[21:45] *** itz left
[21:45] *** donaldh_ is now known as donaldh

[21:46] *** itz joined
[21:48] <Ven_> TimToady: yes, please.

[21:48] <Ven_> I know otherwise people will feel it's a corner-case.

[21:49] <Ven_> Well, at least I know I'd ...

[21:52] <cognome> I note some other  of the pull-requests for rakudo can readily apply (but may be not correct) and have not received feedback from the core team (at least not thru the pull request comment mechanism).

[21:52] <grondilu> TimToady++ default state declarator for anonymous variables

[21:53] * grondilu does not see any point to a (my $)++

[21:53] <pippo> TimToady++ fast now! Thank you!

[21:54] <kurahaupo> r: my $r=0..*; $r.reverse.max.say;

[21:54] <Ven_> grondilu: just wait until I changed postfix ++ to be something else :P

[21:54] <camelia> rakudo-jvm 69add2: OUTPUT«(timeout)»

[21:54] <camelia> ..rakudo-{parrot,moar} 69add2: OUTPUT«-Inf␤»

[21:56] <grondilu> though I can see $++ as a synonymous for (state $)++ looks like slightly excessive magic.

[21:57] <grondilu> it' kind of the relax mode use of anonymous variable

[21:57] <Ven_> ^

[21:58] <flussence> found a small problem in perl6/doc: on http://doc.perl6.org/type/Exception the type graph is (as expected) enormous and (the problem) it disappears off the page without even a scrollbar. Also the PNG version is unreadably tiny.

[21:58] <grondilu> so I would say it could be allowed only in relaxed mode, precisely.  But I have the feeling nobody wants the relax mode anymore anyway...

[21:58] <grondilu> I mean relax mode seems very, very low in the priority list :/

[22:00] <grondilu> (awkward silence?)

[22:05] <TimToady> well, I don't think of it as lax, I just think of it as the most reasonable thing to do with rvalue $, given how often we end up using (state $)++ currently inside lazy constants and ... sequences

[22:05] * cognome acks rakudo to see

[22:06] <TimToady> and we don't really have a good story yet for mixing ... with sequences that depend on position

[22:06] <grondilu> (state $)++ is a fairly common idiom indeed, but it's still a variable and in strict mode it has to be declared.  Thus $++ would be a declaratorless var, which is supposed to be allowed only in lax mode.  qed

[22:07] <TimToady> m: (1, { $_ + ++(state $) } ... *)[^10].say

[22:07] <camelia> rakudo-moar 69add2: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/weWmklG0Ld␤Unsupported use of $) variable; in Perl 6 please use $*EGID␤at /tmp/weWmklG0Ld:1␤------> [32m(1, { $_ + ++(state $)[33m⏏[31m } ... *)[^10].say[0m␤»

[22:07] <TimToady> m: (1, { $_ + ++state $ } ... *)[^10].say

[22:07] <camelia> rakudo-moar 69add2: OUTPUT«1 2 4 7 11 16 22 29 37 46␤»

[22:08] <Ven_> TimToady: modifying STD isn't enough :p

[22:08] <TimToady> spectesting

[22:08] <cognome> The idiom in action for people to see :      method keys(List:) {         self.values.map: { (state $)++ }     } 

[22:09] <cognome> It makes sense to accept $(++ as well.

[22:10] <grondilu> std: $(++$_) 

[22:10] <camelia> std ee1ef48: OUTPUT«ok 00:01 124m␤»

[22:10] <grondilu> m: say $(++$_) 

[22:10] <camelia> rakudo-moar 69add2: OUTPUT«1␤»

[22:11] *** avuserow joined
[22:11] <dalek> rakudo/nom: ce26312 | TimToady++ | src/Perl6/Grammar.nqp:

[22:11] <dalek> rakudo/nom: clean up misleading P5 special var warnings

[22:11] <dalek> rakudo/nom: 

[22:11] <dalek> rakudo/nom: Remove the tests for rare variables, especially those that will become

[22:11] <dalek> rakudo/nom: syntax errors anyway, like $) and friends.  This also allows us to parse

[22:11] <dalek> rakudo/nom: bare sigils as rvalues, so we don't have to distinguish ($a,*,$c) = ...

[22:11] <dalek> rakudo/nom: from my ($a,$,$c) = ... anymore.  That is, if you use a bare $ as an

[22:11] <dalek> rakudo/nom: rvalue, we'll simply declare an anonymous variable for you now.  If we

[22:11] <dalek> rakudo/nom: make the declarator default to 'state', it might even be useful as $++.

[22:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce263122bc

[22:11] <TimToady> m: say $(;

[22:11] <camelia> rakudo-moar 69add2: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/_19eoNFeMM␤Unable to parse expression in contextualizer; couldn't find final ')' ␤at /tmp/_19eoNFeMM:1␤------> [32msay $(;[33m⏏[31m<EOL>[0m␤    expecting any of:␤        sequence of …»

[22:12] <TimToady> m: say $);

[22:12] <camelia> rakudo-moar 69add2: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/rsGGF90qVR␤Unsupported use of $) variable; in Perl 6 please use $*EGID␤at /tmp/rsGGF90qVR:1␤------> [32msay $)[33m⏏[31m;[0m␤»

[22:12] <cognome> And huffmanization has a way to be an exception to many laws. Concision at the price of regularity and more learning to do.

[22:13] <grondilu> ok

[22:13] <TimToady> yes, $++ and ++$ could be very useful in maps

[22:13] <TimToady> the question is whether it's worth it, and whether the reader can guess what it means whether they quite understand how it works

[22:14] <TimToady> "Anonymous rvalue sigits default to 'state'" is pretty easy, as rules go.

[22:14] <TimToady> and if you use them as junk targets, it doesn't matter whether they are my or state

[22:15] <grondilu> is there any risk of wasting memory?

[22:15] <TimToady> arguable state targets don't have to be cloned so much in closures

[22:15] <TimToady> don't think so

[22:15] <Ven_> TimToady: It still really feels like a corner case to me, just too magic

[22:15] *** dolmen joined
[22:16] <grondilu> well, I'm glad I was here tonight so I can learn about this new feat early, for I often write (state$ )++ on RC

[22:16] <TimToady> unfortunately it's my task to figure out which of those people can get used to, and which they can't...

[22:16] *** smls joined
[22:17] <dolmen> The Perl 6 blog aggregator at http://planetsix.perl.org/ has disappeared :( It is a redirect to http://planetaria.org/perl6 but the planetaria.org domain expired...

[22:20] <smls> TimToady: As far as golfing down «(state $)++» goes, I think «state++» would be a less obfuscated way to do that than «$++»

[22:20] *** araujo left
[22:20] <grondilu> state++ has no sigil so it's more difficult to identify it as a variable

[22:21] *** araujo joined
[22:21] <smls> it returns a value

[22:21] <smls> just like other built-in terms (e.g. rand)

[22:22] <grondilu> I don't know.  Not easy to assess.

[22:22] <grondilu> in any way I'm not sure state++ really is less obfuscated than $++

[22:24] <grondilu> (frankly half of my mind keeps thinking $++ is the relaxed version of (state $)++ )

[22:26] *** treehug88 left
[22:26] <pippo> good night #perl6!

[22:26] *** pippo left
[22:32] *** donaldh left
[22:33] <sjn> Good * #perl6 :)

[22:35] <grondilu> sorry to insist, but also:  usually functions return a ro value, no a rw one.  So we rarely write foo++.  So rand is a bad example since rand++ is wrong.  Thus state++ is not so much better than $++

[22:35] <flussence> I'm very, very confused. If I do «await Promise.anyof(@threads, Promise.in($short))», and in one of those threads call sleep($long) or Promise.in($long) (or anything long-running?), the anyof doesn't return for the Promise.in($short) but blocks on the entire thing...

[22:37] <flussence> m: await Promise.anyof(start { sleep 8; say 8 }, Promise.in(3).then({ say 3 }));

[22:37] <camelia> rakudo-moar 3ce25e: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in sub start at src/gen/m-CORE.setting:18942␤  in block <unit> at /tmp/umzjH9Piwk:1␤␤»

[22:37] <flussence> m: await Promise.anyof(start({ sleep 8; say 8 }), Promise.in(3).then({ say 3 }));

[22:37] <camelia> rakudo-moar 3ce25e: OUTPUT«8␤3␤»

[22:37] <flussence> j: await Promise.anyof(start({ sleep 8; say 8 }), Promise.in(3).then({ say 3 }));

[22:37] <camelia> rakudo-jvm 3ce25e: OUTPUT«(timeout)»

[22:37] <flussence> j: await Promise.anyof(start({ sleep 5; say 5 }), Promise.in(1).then({ say 1 }));

[22:38] <camelia> rakudo-jvm 3ce25e: OUTPUT«5␤1␤»

[22:38] <flussence> okay, so not a moarbug at least...

[22:38] *** ajr_ left
[22:44] <arnsholt> Perhaps the oddest thing I've put in my .gitignore file: .gitignore itself =D

[22:44] *** smls left
[22:45] <flussence> why'd you do that?

[22:45] *** dwarring joined
[22:46] <arnsholt> Because the repo I'm working with is actually an SVN repo =)

[22:46] <flussence> .tell jnthn Is this a bug, or am I grossly misunderstanding how S17 works? http://irclog.perlgeek.de/perl6/2014-08-28#i_9260839

[22:46] <yoleaux> flussence: I'll pass your message to jnthn.

[22:47] <arnsholt> But since working with SVN makes me sad, I'm using git-svn instead

[22:47] <flussence> ah, now it makes sense!

[22:47] <arnsholt> But I don't want to rub my boss's nose in the fact that I'm not using his favourite version control system =)

[22:47] <arnsholt> Although I do hope he'll notice the timestamps on some commits at some point O=)

[22:51] <flussence> (I tried using git-svn at work once and got caught because the nice, colourized git log stood out from a room away. Needless to say, I stopped working there...)

[22:54] *** dolmen left
[22:55] <[Coke]> (planeteria) I've pinged my technical contact.

[22:56] <arnsholt> flussence: Yeah...

[22:58] *** xragnar_ joined
[22:58] *** xragnar is now known as Guest63690

[22:58] *** Guest63690 left
[22:58] *** xragnar_ is now known as xragnar

[22:59] *** virtualsue left
[23:06] <colomon> https://gist.github.com/colomon/8e89203b8dd97b88cf56 # the set operation, in four variations with times and links to profiles

[23:08] <colomon> timotimo: ^^^

[23:08] <colomon> timotimo: sorry it took me so long.

[23:09] *** raiph left
[23:10] *** nbrown__ joined
[23:11] <colomon> timotimo: I should probably mention the sub containing the code in question is called hash-set-split

[23:13] *** nbrown_ left
[23:14] <timotimo> oh!

[23:14] <timotimo> neato :)

[23:15] <timotimo> i'm glad we're getting pretty close to the hash-based solution with set operations

[23:15] <colomon> yes, I was very surprised by that.

[23:16] <timotimo> oh, you're not using jit

[23:16] <colomon> but I probably shouldn't have been.

[23:16] <colomon> true

[23:16] *** raiph joined
[23:16] * colomon tends to avoid features like jit he perceives as experimental, since he is actively using rakudo to Get Stuff Done.

[23:17] <timotimo> ah

[23:26] <colomon> If you think it would be interesting, I guess I can making a  special jit build in rakudobrew…

[23:29] <timotimo> you can just put MVM_DISABLE_JIT in your environment

[23:29] <timotimo> with any value that is not empty

[23:35] *** Ven_ left
[23:52] *** spider-mario left
[23:57] <grondilu> std: say [Before] map *.base(36), ^50;

[23:57] <camelia> std 53b3ca6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/SAKDSamDjP line 1:␤------> [32msay [Before] [33m⏏[31mmap *.base(36), ^50;[0m␤    expecting any of:␤        feed_separator␤ infix or meta-infix␤    infixed…»

[23:58] <colomon> m: say 34.base(36)

[23:58] <camelia> rakudo-moar ce2631: OUTPUT«Y␤»

[23:58] <colomon> m: say [before] map  *.base(36), ^50;

[23:58] <camelia> rakudo-moar ce2631: OUTPUT«False␤»

[23:59] <colomon> m: say [min] map  *.base(36), ^50;

[23:59] <camelia> rakudo-moar ce2631: OUTPUT«0␤»

