[00:18] <timotimo> what.

[00:19] <timotimo> using >>.ast is actually faster than .map(*.ast) in JSON::Tiny ... ?!

[00:20] <timotimo> and it's also faster than .map({ $_.ast })

[00:20] <timotimo> wow.

[00:21] *** rurban left
[00:22] *** kurahaupo joined
[00:22] <timotimo> perl6-m is nowadays starting up the repl's input prompt in 0.02s

[00:22] <timotimo> that's pretty good

[00:24] <timotimo> when you actually execute code, like "say 1", the time jumps up to 0.25s on my laptop and the memory usage balloons up to about 6x the size

[00:34] <Mouq> timotimo: well >>.ast is autothreaded ;)

[00:35] <timotimo> m)

[00:38] <Mouq> m: for 500..1000 { { $_.Str }($_) }; say now - BEGIN now

[00:38] <camelia> rakudo-moar e16766: OUTPUT«0.04111123␤»

[00:38] <Mouq> m: for 500..1000 { { $_.Str }($_) }; say now - BEGIN now

[00:38] <camelia> rakudo-moar e16766: OUTPUT«0.0387570␤»

[00:38] <Mouq> m: for 500..1000 { $_.'Str'() }; say now - BEGIN now

[00:39] <camelia> rakudo-moar e16766: OUTPUT«0.02135463␤»

[00:39] <Mouq> m: for 500..1000 { $_.'Str'() }; say now - BEGIN now

[00:39] <camelia> rakudo-moar e16766: OUTPUT«0.0404778␤»

[00:39] <Mouq> m: for 500..10000 { { $_.Str }($_) }; say now - BEGIN now

[00:39] <camelia> rakudo-moar e16766: OUTPUT«0.1061059␤»

[00:39] <Mouq> m: for 500..10000 { $_.'Str'() }; say now - BEGIN now

[00:39] <camelia> rakudo-moar e16766: OUTPUT«0.05337681␤»

[00:39] <Mouq> m: for 500..10000 { $_.'Str'() }; say now - BEGIN now

[00:39] <camelia> rakudo-moar e16766: OUTPUT«0.05296991␤»

[00:39] <Mouq> ^^ That's why, I think

[00:40] <Mouq> >>.meth is more like for ... { .'meth'() } and .map(*.meth) is more like for ... { (*.meth)($_) }, which is slower

[00:40] <Mouq> (apparently)

[00:41] <Mouq> Well, also, isn't .map lazy be default?

[00:41] *** rurban joined
[00:41] <Mouq> *by

[00:46] *** zakharyas joined
[00:48] <timotimo> oh, hm.

[00:48] <timotimo> hadn't considered that

[00:48] <timotimo> but at least .'meth'() sounds like it ought to be slower

[00:49] <[Coke]> moritz: no, I followed the directions on the perl6.org readme, which leaves off the --make; I'll give it a shot.

[00:51] <timotimo> i hope it'll lead you onto a path of productivity

[01:07] *** zakharyas left
[01:08] *** zakharyas joined
[01:09] *** colomon joined
[01:17] <Mouq> FROGGS: How do you use the nqp_to_perl6 branch of v5?

[01:30] *** FROGGS_ joined
[01:30] *** klapperl_ joined
[01:31] *** ren1us joined
[01:34] *** klapperl left
[01:34] *** FROGGS left
[01:35] <ren1us> is there a built in function/operator for getting the intersection of two lists?

[01:35] *** zakharyas left
[01:35] <timotimo> (&) should do

[01:36] <timotimo> it will coerce both arguments to sets and give you a set back, though

[01:37] <ren1us> i'm really not sure what to make of the result of &

[01:37] <ren1us> m: 0,1,2 & 1,2,3

[01:37] <timotimo> not &, (&)

[01:37] <camelia> rakudo-moar e16766: ( no output )

[01:37] <ren1us> ah

[01:37] <timotimo> if you need to keep the order, i'd suggest something like @list.grep(any(@otherlist))

[01:38] <ren1us> m: say 0,1,2 (&) 1,2,3 # this still seems rather peculiar

[01:38] <camelia> rakudo-moar e16766: OUTPUT«01set()23␤»

[01:39] <timotimo> yes

[01:39] <timotimo> it maskes a set from 2 and 1

[01:39] <timotimo> and that's inside a list of 0, 1, *here*, 2, 3

[01:39] <timotimo> m: say (0, 1, 2) (&) (1, 2, 3)

[01:39] <camelia> rakudo-moar e16766: OUTPUT«set(1, 2)␤»

[01:40] <timotimo> m: my @list = <foo bar baz quux>; my @otherlist = <bar quux potatoes>; say @list.grep(any(@otherlist))

[01:40] <camelia> rakudo-moar e16766: OUTPUT«bar quux␤»

[01:40] <ren1us> that makes sense.  it's weird that it showed up as 01set()23, since that looks like an empty set

[01:41] <timotimo> it is an empty set

[01:41] <timotimo> m: say (0,1,2 (&) 1,2,3).perl

[01:41] <camelia> rakudo-moar e16766: OUTPUT«(0, 1, set(), 2, 3)␤»

[01:41] <timotimo> it's just an operator precedence issue

[01:41] <ren1us> ah

[01:41] <ren1us> the list items need to be wrapped in something

[01:41] <ren1us> that makes sense

[01:42] <timotimo> it's not that it "needs to be wrapped in something", just that the , will bind looser than the (&)

[01:43] *** ventica2 joined
[01:44] *** ilbot3 left
[01:45] *** ventica left
[01:46] *** ilbot3 joined
[01:47] <ren1us> yeah, but the wrapping is a workaround to adjust the order, so close enough

[01:47] <ren1us> anyway, thanks :>

[01:47] <timotimo> right

[01:47] <timotimo> you're welcome :)

[01:47] * timotimo commutes

[01:51] <ren1us> oh, right.  timotimo++

[01:55] *** Mouq left
[01:59] *** ren1us left
[02:05] *** thou joined
[02:09] *** Alina-malina left
[02:11] *** thou left
[02:13] *** BenGoldberg left
[02:15] *** Alina-malina joined
[02:16] *** rurban left
[02:29] *** pecastro left
[02:29] *** Alina-malina left
[02:30] *** pecastro joined
[02:35] *** Alina-malina joined
[02:57] *** noganex_ joined
[03:00] *** noganex left
[03:03] *** ventica2 left
[03:07] *** echoprinter left
[03:13] *** xragnar_ joined
[03:13] *** xragnar left
[03:13] *** xragnar_ is now known as xragnar

[03:29] *** thou joined
[03:44] *** ventica2 joined
[03:46] *** akaseki joined
[03:49] *** kurahaupo left
[03:49] *** aoseki left
[04:30] *** xinming_ joined
[04:34] *** xinming left
[05:00] <dalek> rakudo/nom: c270e91 | duff++ | src/Perl6/Actions.nqp:

[05:00] <dalek> rakudo/nom: Fix for RT #79160

[05:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c270e91c14

[05:00] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=79160

[05:01] <dalek> roast: c2e9aa8 | duff++ | S12-subset/subtypes.t:

[05:01] <dalek> roast: un-todo test for RT #79160

[05:01] <dalek> roast: review: https://github.com/perl6/roast/commit/c2e9aa88f7

[05:01] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=79160

[05:04] *** dwarring left
[05:14] *** gfldex joined
[05:16] *** Akagi201 joined
[05:16] *** Akagi201 left
[05:16] *** Akagi201_ left
[05:17] *** Akagi201_ joined
[05:23] <dalek> rakudo/nom: b86a152 | duff++ | src/core/Temporal.pm:

[05:23] <dalek> rakudo/nom: Get Date from Instant (RT #111356)

[05:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b86a152cc1

[05:23] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=111356

[05:23] *** Akagi201 joined
[05:24] *** Akagi201 left
[05:24] *** Akagi201_ left
[05:24] *** Akagi201 joined
[05:25] *** kaare_ joined
[05:38] *** nbrown____ left
[05:51] *** kurahaupo_ joined
[06:17] *** iarna left
[06:18] *** iarna joined
[06:21] *** kurahaupo_ left
[06:22] *** chenryn joined
[06:29] *** dmol joined
[06:31] *** Alina-malina left
[06:42] *** khisanth_ joined
[06:44] *** Khisanth left
[06:50] *** iarna left
[06:51] *** iarna joined
[07:05] *** chenryn left
[07:07] <dalek> Perlito: c119825 | (Flavio S. Glock)++ | misc/alias.pl:

[07:07] <dalek> Perlito: misc - add a parameter aliasing example

[07:07] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/c119825471

[07:08] *** chenryn joined
[07:09] *** FROGGS_ is now known as FROGGS

[07:10] <FROGGS> .tell Mouq What do you mean by 'how'? <Mouq> FROGGS: How do you use the nqp_to_perl6 branch of v5?

[07:10] <yoleaux> FROGGS: I'll pass your message to Mouq.

[07:15] *** virtualsue joined
[07:18] *** denis_boyun_ joined
[07:34] *** darutoko joined
[07:53] *** [Sno] joined
[07:57] *** psch joined
[08:11] <FROGGS> .tell Mouq In case you meant build instructions I updated the README.md

[08:11] <yoleaux> FROGGS: I'll pass your message to Mouq.

[08:12] *** chenryn left
[08:15] *** anaeem1_ joined
[08:24] *** lizmat_ joined
[08:26] *** Rotwang joined
[08:28] *** lizmat left
[08:33] <itz> this has to be one to steal :>

[08:33] <itz> https://github.com/Russell91/pythonpy

[08:33] *** iarna left
[08:37] *** brrt joined
[08:38] *** lizmat_ left
[08:45] *** chenryn joined
[08:49] *** chenryn left
[08:54] *** thou left
[08:59] *** spider-mario joined
[09:01] *** FROGGS[mobile] joined
[09:15] *** Rotwang left
[09:16] *** chenryn joined
[09:16] *** chenryn left
[09:17] *** chenryn joined
[09:19] *** anaeem1_ left
[09:21] *** chenryn left
[09:22] *** anaeem1_ joined
[09:33] *** kivutar joined
[09:53] *** colomon left
[09:54] <masak> good noon, #perl6

[10:17] *** chenryn joined
[10:22] *** chenryn left
[10:23] <FROGGS[mobile]> o/

[10:44] *** brrt left
[10:47] *** anaeem1_ left
[11:12] <psch> hi #perl6 o/

[11:18] *** chenryn joined
[11:23] *** chenryn left
[11:23] *** brrt joined
[11:27] * psch unborked his pre-commit hook for roast.

[11:27] <psch> testneeded RTs here i come! :p

[11:27] <psch> ...after building latest rakudo for all backends, that is

[11:32] *** chenryn joined
[11:36] *** denis_boyun_ left
[11:36] *** denis_boyun_ joined
[11:43] *** akaseki left
[11:43] *** aoseki joined
[11:43] *** kurahaupo_ joined
[11:45] *** chenryn left
[11:46] *** chenryn joined
[11:50] *** chenryn left
[11:59] *** anaeem1 joined
[12:01] *** anaeem1 left
[12:02] *** anaeem1__ joined
[12:05] *** colomon joined
[12:08] *** rurban joined
[12:17] *** chenryn joined
[12:20] *** kurahaupo_ left
[12:21] *** chenryn left
[12:28] *** BenGoldberg joined
[12:58] <dalek> nqp: 02f47bf | jnthn++ | src/QAST/Block.nqp:

[12:58] <dalek> nqp: Give QAST::Block a code object property.

[12:58] <dalek> nqp: 

[12:58] <dalek> nqp: This will hold the code object associated with the code ref.

[12:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/02f47bf430

[12:58] <dalek> nqp: 435e62c | jnthn++ | src/vm/ (3 files):

[12:58] <dalek> nqp: Teach backends about QAST::Block.code_object.

[12:58] <dalek> nqp: 

[12:58] <dalek> nqp: This is just doing the simple, naive thing for now - generating the

[12:58] <dalek> nqp: code we once would have. However, this will enable doing something

[12:58] <dalek> nqp: smarter on some backends - Moar first.

[12:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/435e62c03d

[13:02] <carlin> sergot: are you planning on adding a .post() method to HTTP::UserAgent?

[13:06] <dalek> nqp: 17a5794 | jnthn++ | src/NQP/World.nqp:

[13:06] <dalek> nqp: Switch to using new code_object support.

[13:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/17a5794ea5

[13:07] <dalek> rakudo/nom: c8736ab | jnthn++ | / (2 files):

[13:07] <dalek> rakudo/nom: Bump NQP_REVISION; use new .code_object support.

[13:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c8736ab7ea

[13:16] *** brrt left
[13:19] *** chenryn joined
[13:22] *** pecastro left
[13:23] *** sjn left
[13:23] *** chenryn left
[13:23] *** sjn joined
[13:27] <vendethiel> oh what.

[13:27] <vendethiel> magic the gathering is turing-complete ???!!

[13:29] *** kivutar left
[13:29] <tadzik> :o

[13:30] <tadzik> well, you could probably define every operation in terms of a different infinite combo available in mtg

[13:32] *** pippo joined
[13:32] *** BenGoldberg left
[13:33] <pippo> o/ #perl6

[13:34] <vendethiel> timotimo: http://boingboing.net/2012/09/12/magic-the-gathering.html

[13:35] <vendethiel> timotimo: actually, http://beza1e1.tuxen.de/articles/accidentally_turing_complete.html - more global

[13:36] <pippo> Anybody has time to explain me what does sink context mean?

[13:37] <vendethiel> pippo: it means that everything will be thrown away

[13:37] <vendethiel> (the result is unused)

[13:38] <pippo> vendethiel: Thank you! 

[13:38] *** aghbas joined
[13:39] *** aghbas left
[13:40] *** pecastro joined
[13:41] <psch> RT #109800 is not horribly misplaced in S06-operator-overloading/sub.t, right?

[13:41] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=109800

[13:41] * psch .oO( "forgiveness before permission" might count for "this test should go somewhere else..." )

[13:43] <psch> on one hand the name sub.t seems to indicate it's for using sub {}, but on the other it has binding to e.g. my &infix:<plus> 

[13:44] <dalek> roast: a9171d7 | (Pepe Schwarz)++ | S06-operator-overloading/sub.t:

[13:44] <dalek> roast: Added test for RT #109800.

[13:44] <dalek> roast: review: https://github.com/perl6/roast/commit/a9171d7cc4

[13:44] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=109800

[13:44] <pippo> o/

[13:44] *** pippo left
[13:45] <psch> a few testneeded RTs depend on https://github.com/perl6/nqp/pull/173 and https://github.com/rakudo/rakudo/pull/301, the list on the rakudo PR is not exhaustive. i'll add those fudged i guess

[13:50] *** denis_boyun_ left
[13:53] <dalek> nqp: ee50e95 | (Pepe Schwarz)++ | src/QRegex/P6Regex/Grammar.nqp:

[13:53] <dalek> nqp: Convert panic() calls to more specific, overrideable methods.

[13:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ee50e95bea

[13:53] <dalek> nqp: 64be958 | jonathan++ | src/QRegex/P6Regex/Grammar.nqp:

[13:53] <dalek> nqp: Merge pull request #173 from peschwa/panics_to_typed

[13:53] <dalek> nqp: 

[13:53] <dalek> nqp: Convert panic() calls to more specific, overrideable methods.

[13:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/64be9585a7

[13:57] <dalek> rakudo/nom: d78a1c0 | (Pepe Schwarz)++ | src/ (2 files):

[13:57] <dalek> rakudo/nom: Add a few typed exceptions and override P6Regex::Grammar methods to throw them.

[13:57] <dalek> rakudo/nom: 

[13:57] <dalek> rakudo/nom: This lets us test sensibly for RT #77380, RT #77522 and similar.

[13:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d78a1c0b0b

[13:57] <dalek> rakudo/nom: 19a8e34 | jonathan++ | src/ (2 files):

[13:57] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=77380

[13:57] <dalek> rakudo/nom: Merge pull request #301 from peschwa/panics_to_typeds

[13:57] <dalek> rakudo/nom: 

[13:57] <dalek> rakudo/nom: Add a few typed exceptions and override P6Regex::Grammar methods to throw them.

[13:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/19a8e3478c

[14:01] <psch> good thing i'm so timid about pushing :) jnthn++

[14:02] *** eMBee left
[14:04] <FROGGS> jnthn: I need to follow the code_object changes?

[14:05] <jnthn> FROGGS: Don't need to

[14:06] <jnthn> FROGGS: May want to.

[14:06] <jnthn> FROGGS: The previous way will continue to work.

[14:06] *** chenryn joined
[14:06] *** khisanth_ is now known as Khisanth

[14:09] *** eMBee joined
[14:13] <timotimo> the next memory conservation win we're going to get might end up being pretty big :D

[14:13] <vendethiel> .oO( big++ )

[14:14] <timotimo> and startup time improvement etc etc

[14:17] *** brrt joined
[14:19] *** kaare_ left
[14:19] *** pippo joined
[14:31] *** nbrown____ joined
[14:36] *** groky left
[14:38] *** Bucciarati left
[14:38] *** avar left
[14:40] *** avar joined
[14:41] *** groky joined
[14:41] *** anaeem1__ left
[14:42] *** ggoebel1111113 joined
[14:43] *** guru joined
[14:43] *** guru is now known as Guest35458

[14:44] *** anaeem1 joined
[14:45] *** groky left
[14:46] <dalek> rakudo/nom: 5d5ec1e | jnthn++ | tools/build/NQP_REVISION:

[14:46] <dalek> rakudo/nom: Bump NQP_REVISION for regex error improvements.

[14:46] <dalek> rakudo/nom: 

[14:46] <dalek> rakudo/nom: Should allow tests to be safely unfudged and pass for everyone who

[14:46] <dalek> rakudo/nom: is building against NQP_REVISION.

[14:46] *** ggoebel1111112 left
[14:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5d5ec1e812

[14:46] *** anaeem1 left
[14:47] *** Guest35458 is now known as ajr_

[14:47] <dalek> nqp: c4db3ef | jnthn++ | / (2 files):

[14:47] <dalek> nqp: Adopt new MoarVM code object handling.

[14:47] <dalek> nqp: 

[14:47] <dalek> nqp: Includes a MOAR_REVISION bump.

[14:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c4db3efb1b

[15:00] *** pippo left
[15:07] *** pippo joined
[15:07] <psch> apparently those two PRs were somewhat stale, the only one of the Exceptions that still works is X::Syntax::Regex::Unterminated, and it gets grouped with a X::Comp::Adhoc

[15:09] <psch> the grouping might actually make sense, the Adhoc is "Unable to parse Regex; couldn't find final '/'"

[15:13] *** PZt left
[15:16] *** denis_boyun_ joined
[15:21] *** brrt left
[15:24] <psch> eh, no, i just again and again forget how to properly set up CATCH blocks for compile time Exceptions...

[15:24] *** ajr_ left
[15:25] *** guru joined
[15:25] *** thou joined
[15:26] *** guru is now known as Guest52917

[15:26] *** Guest52917 is now known as ajr_

[15:30] *** pippo left
[15:31] *** kaare_ joined
[15:47] *** denis_boyun_ left
[15:51] *** pippo joined
[15:53] <psch> m: /a ** 1 ..2/ # this does confuse me.  

[15:53] <camelia> rakudo-moar 5d5ec1: OUTPUT«===SORRY!===␤Cannot find method 'ast'␤»

[15:53] * masak submits rakudobug

[15:53] *** rakudobug joined
[15:53] * rakudobug submits masak

[15:54] <masak> it's mutual <3

[15:54] <psch> the curious bit is that P6Regex::Grammar has <.integer> '..' <.throw_bare_spaces_in_range> 

[15:54] <psch> which is the patch jnthn merged a bit

[15:54] *** rakudobug left
[15:54] <vendethiel> hahaha

[15:54] <psch> but apparently it matches differently and gets through to the corresponding action in Perl 6's Actions.nqp

[15:54] <carlin> uh oh, the rakudobugs have become sentient

[15:54] <psch> where there's nothing in $<min>

[15:54] <psch> because it shouldn't have matched or somesuch...?

[15:54] <vendethiel> if "language composition" is really the future, then perl 6 might be able to get some chunk of the cake ;-)

[15:55] <vendethiel> (did they read about perl 6 slangs ?)

[15:55] <masak> vendethiel: that matches my thinking.

[15:55] <psch> unfortunately i get a segfault with --target=parse for that case on moar, which makes it hard to gain some insight

[15:55] <vendethiel> masak: well, it certainly is an opportunity to get rid of string programming :-)

[15:56] <vendethiel> I like the idea of slangs because that means we can TOTALLY do away with SQL injections, XSS, etc.

[15:56] <vendethiel> (or, well, do away with it in 99% of the cases)

[15:56] <masak> *nod*

[15:56] <masak> one slang per child.

[15:57] <vendethiel> and the perl 6 slang to rule them all ;) ?

[15:57] <vendethiel> perl 6 is merely a slang of perl 6, after all

[15:57] <psch> supersede $~MAIN { } # rien ne va plus

[15:57] <masak> vendethiel: that's a good point.

[15:58] <vendethiel> psch: il y en a qui ont essayé, ils ont eu des problèmes ;-)

[15:58] <psch> vendethiel: to be honest, that's about the extend of my french

[15:58] <vendethiel> psch: haha - I guessed so, don't worry

[15:59] <vendethiel> masak: it does raise another point, though: we need something to get a bit terser slang-using.

[15:59] <vendethiel> we don't want to `{use SQL; SELECT * FROM a}.map(...)`; I don't think.

[15:59] <vendethiel> We could see `SQL{}`, obviously

[16:00] <psch> that's module space though, isn't it? exporting a block-taking sub that uses the module slang for the block

[16:00] *** iarna joined
[16:00] <masak> vendethiel: I think overloading circumfix:<` `> as switch-into-slang in a given scope would work fine.

[16:00] <masak> vendethiel: or, you know, something like SQL"..."

[16:00] <masak> I dunno.

[16:01] <masak> syntax will come for these things.

[16:01] <vendethiel> masak: that can't work. you can't decide which slang with just ``

[16:01] <vendethiel> also, SQL"" (scala/c++-like) doesn't work because it doesn't really do away with string programming

[16:01] <masak> I don't mean it should actually be a string.

[16:01] <vendethiel> I know, but you're implying it with ""

[16:02] <masak> so go with SQL[ ... ] or something.

[16:02] <masak> my point is I'm not too worried about the specifics of syntax.

[16:02] <vendethiel> no, but I'm very against using string-like anything.

[16:02] <masak> nailing how everything will interop is the interesting/difficult challenge.

[16:04] *** Bucciarati joined
[16:06] <vendethiel> it does seem interesting, though. I see myself doing stuff like that in 5 years

[16:06] <vendethiel> well, I already kinda do with haskell/hamlet and stuff like that

[16:10] *** chenryn left
[16:10] <masak> I see much of good module building as (a) finding the right algebra/model and building the corresponding functions for it, followed by (b) exposing this through an easy-to-grok grammar.

[16:11] *** echoprinter joined
[16:11] <masak> sometimes the (b) part only needs an "internal API" or something. sometimes, though, it would be greatly helped by some grammar tweak or other. sometimes, by an entirely different grammar.

[16:20] *** brrt joined
[16:21] *** brrt left
[16:22] *** flussence left
[16:25] *** flussence joined
[16:25] <FROGGS> ahh, the SQL slang pops up again :o)

[16:30] *** denis_boyun_ joined
[16:32] <vendethiel> FROGGS: It's 2014, and I refuse to write SQL strings ;-)

[16:32] <FROGGS> I don't

[16:32] <vendethiel> YMMV

[16:33] <FROGGS> but I'd like to see compile time errors for typo's in these

[16:33] <timotimo> there's people now who say "don't use ORM, write your sql yourself!"

[16:33] <vendethiel> well, they have reasons

[16:34] * geekosaur would very much prefer writing some good sql instead of relying on the horrors created by "smart" packages with the intelligence of a 2yo

[16:34] <timotimo> haha

[16:35] <timotimo> if we had a package that is anything like SQLAlchemy, that would be swee.

[16:39] <vendethiel> that string was in the programming sense.

[16:39] <vendethiel> I'm fine with handcrafting SQL queries. Not fine with them being strings

[16:40] <timotimo> since we have compile-time code running and macros, we could surely make a nice DSL for sql query construction that makes objects of different types give you the semantics you want or something

[16:40] <vendethiel> sure :)

[16:43] <vendethiel> that's the whole point

[16:43] <vendethiel> persistent (haskell) is pretty nice in that area

[16:43] *** ajr_ left
[16:44] <vendethiel> well, yesod in a whole is a great piece of techonology

[16:44] *** guru joined
[16:44] *** guru is now known as ajr_

[16:45] <psch> not sure what's more sensible here wrt the latest ticket that i saw masak++ create

[16:45] *** nbrown____ left
[16:46] <psch> turns out the error comes from the branch that throws the exception not capturing the integer

[16:46] <psch> i.e. does it make more sense to assume that the grammar ontop of P6Regex::Grammar checks for $<min> in the action for sym<**> or should the token capture even if it's throwing an exception

[16:47] <psch> or panicking rather, because that's the nqp grammar does

[16:48] *** dalek left
[16:48] <psch> i.e. capture here https://github.com/perl6/nqp/blob/master/src/QRegex/P6Regex/Grammar.nqp#L240

[16:48] <psch> or check for definedness of $<min> here https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L7290

[16:49] *** dalek joined
[16:49] *** ChanServ sets mode: +v dalek

[16:54] *** nbrown____ joined
[16:55] <psch> i have decided that the second of those options is out, because if anything it should be in P6Regex::Actions... :)

[16:56] <psch> and because that'd be two places to check for definedness capturing min even if we're panicking seems more sensible

[16:57] *** telex left
[16:58] *** telex joined
[16:59] *** nbrown____ left
[17:04] <psch> std: /a ** 1 ..2/

[17:04] <camelia> std 0f2049c: OUTPUT«===SORRY!===␤Spaces not allowed in bare range at /tmp/kN92GTOwA1 line 1:␤------> /a ** 1 ..⏏2/␤Parse failed␤FAILED 00:01 122m␤»

[17:04] <psch> std: /a ** 1.. 2/

[17:04] <camelia> std 0f2049c: OUTPUT«===SORRY!===␤Malformed range at /tmp/GiQ9V62RP0 line 1:␤------> /a ** 1..⏏ 2/␤    expecting quantifier␤Parse failed␤FAILED 00:01 122m␤»

[17:04] <psch> this is also kind of weird, i think

[17:04] <psch> the eject after .. in the first case bothers me very slightly

[17:05] <psch> i guess the different types are due to LTM?

[17:05] <psch> or rather, different messages

[17:10] <masak> the ⏏ being where it is in both cases makes some sense to me.

[17:10] <masak> it is where the error was discovered.

[17:10] <masak> in the first case, after discovering that it was a range (and thus the spaces earlier are wrong)

[17:11] <masak> in the second case, after not meeting the expectations of what comes after a range (which happens to be spaces, which we're not eating today)

[17:11] <masak> a very small case could be made for having the same error message in both cases, I guess. "Spaces not allowed in bare range" being the best one.

[17:12] *** denis_boyun_ left
[17:12] *** denis_boyun joined
[17:13] <psch> eject as "where an error was discovered" seems to be the better understanding.  i was operating with "where it breaks", which breaks in cases like these

[17:13] <psch> unifying the message makes sense to me, as it seems a bit more user friendly - the problem is the same in both cases, the distinction is parser guts

[17:23] *** FROGGS[mobile] left
[17:24] *** nbrown____ joined
[17:31] *** nbrown____ left
[17:37] *** colomon left
[18:04] *** xenoterracide joined
[18:12] *** pmurias joined
[18:17] <pmurias> masak: re quoting sql one problem is that our quasiquoting syntax is a bit heavyweight, quasi:lang(SQL) {select * from foobar}

[18:18] <masak> so... don't do it that way ;)

[18:19] <masak> qq string interpolation employs a kind of quasi quoting, and it doesn't need any heavyweight syntax.

[18:22] *** xenoterracide left
[18:25] *** denis_boyun left
[18:27] *** nbrown____ joined
[18:28] <vendethiel> pmurias: re masak: re quoting, we should totally be able to get `sql{}` to workj

[18:29] *** ajr_ left
[18:31] *** nbrown____ left
[18:32] *** molaf__ joined
[18:32] *** xenoterracide joined
[18:34] <raydiak> mornin p6ppl

[18:35] <vendethiel> o/, raydiak

[18:35] *** molaf_ left
[18:37] *** rurban left
[18:39] <geekosaur> do we still collect autopuns? "I both hate and love analogies with QM, but I can't decide until I see one"

[18:45] <masak> ;)

[18:46] <vendethiel> "how many implementations of `[a] -> [a]` are there ?" well, an infinite number. Parametricity doesn't buy you that.

[18:47] <vendethiel> that's one thing I dislike about these talks, saying that parametricity removes the need for a name. id and reverse can both have the type [a] -> [a].

[18:47] <vendethiel> A function that pattern matches on different list sizes also does. etc...

[18:47] <masak> aka "dang, we still have to implement stuff"

[18:48] <masak> I envision a future where my job is to provide a spec of some sort, and AI agents mill around to provide an implementation, coming back now and then to challenge me on specifics.

[18:48] <vendethiel> aka types aren't the only documentation. Function names *are* useful

[18:49] <vendethiel> admittedly, you can go *very* far, moreso with dependent typing, but it doesn't change the fact that *types are not a complete documentation*. Not even for abstractions

[18:49] *** woolfy joined
[18:50] <masak> *nod*

[18:51] <vendethiel> (though when idris/agda infers some implementation, I'm still quite happy :P (but then again, it knows which arguments your function takes))

[18:52] *** iarna left
[18:53] *** iarna joined
[18:53] <masak> "X don't prevent *all* bugs, but they're still useful in preventing some of them" where X (in) <<types tests "things like tab completion and other IDE things">>

[18:54] <vendethiel> that's a bit unfair.

[18:54] <vendethiel> "you don't have to tests to the extent that you have types" is a mantra I like to repeat

[18:54] *** pmurias left
[18:57] *** xenoterracide left
[18:58] <masak> pretty sure I don't agree with that.

[18:59] <masak> in the JavaScript code I write, I can feel how nice it is to move to something like TypeScript and have some stuff statically checked.

[18:59] <masak> but I wouldn't trade that away for writing unit tests.

[18:59] <masak> it's like, they catch errors, but two different kinds.

[19:02] *** iarna left
[19:02] *** iarna joined
[19:03] <vendethiel> masak: you read that wrong the same way I did first

[19:03] <vendethiel> "to the extent" doesn't mean they replace tests -- it means you start testing what can't be catched by said types

[19:04] <vendethiel> (and you can catch a lot more with haskell's type system than typescript (which is unsound))

[19:04] <masak> oh, you're talking about a kind of coverage then.

[19:04] <vendethiel> (it's a pretty confusing way to say it, admittedly :P)

[19:04] <vendethiel> yes.

[19:04] <masak> got it.

[19:04] <vendethiel> types are like "free coverage", somewhat.

[19:05] <masak> *nod*

[19:05] <masak> I would love to hear more about TypeScript's unsoundness, and whether it has any real-world consequences.

[19:05] <masak> I know it does inference both upwards and downwards.

[19:05] <vendethiel> well, it's simply: it has untagged unions

[19:05] <vendethiel> ie forall A. A=A|undefined|null

[19:06] *** brrt joined
[19:06] <vendethiel> masak: https://gist.github.com/t0yv0/4449351

[19:07] <vendethiel> their generics are also unsound, because they allow types to be used both in co- and contra-variant positions

[19:08] <vendethiel> (dart is unsound as well. TypeScript is sound, yay :-).)

[19:08] *** kurahaupo joined
[19:09] <vendethiel> https://www.dartlang.org/articles/why-dart-types/ <- there's even a blog post to justify it hahahaha.

[19:10] <vendethiel> .oO( they chose to be covariant by default because they couldn't decide whether they wanted definition-site variance or use-site variance. Little did they know they could have both ... )

[19:10] *** mr-foobar left
[19:11] <vendethiel> (on that note, I'll stop spamming #perl6 with was must not be an interesting topic for a lot of people here...)

[19:12] <masak> no, thank you for sharing.

[19:15] *** darutoko left
[19:22] *** virtualsue left
[19:28] *** nbrown____ joined
[19:29] <dalek> roast: c1f9b00 | (Pepe Schwarz)++ | S32-exceptions/misc.t:

[19:29] <dalek> roast: Added test for RT #77522.

[19:29] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=77522

[19:29] <dalek> roast: review: https://github.com/perl6/roast/commit/c1f9b00fe0

[19:29] <dalek> roast: ca327a9 | (Pepe Schwarz)++ | S32-exceptions/misc.t:

[19:29] <dalek> roast: Added test for RT #77380.

[19:29] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=77380

[19:29] <dalek> roast: review: https://github.com/perl6/roast/commit/ca327a9c7d

[19:30] <masak> vendethiel: took me a while to see, but yeah -- that looks like a bug.

[19:31] <vendethiel> masak: the typescript soundness?

[19:32] <masak> yes.

[19:32] *** nbrown____ left
[19:32] <masak> I can see it has to do with contravariance.

[19:32] <masak> but I had to step through it to viscerally feel that it does something wrong.

[19:35] <pippo> good night #perl6!

[19:35] *** pippo left
[19:35] <vendethiel> well, really, it's the simple rule that parameters are in a contravariant position.

[19:35] <masak> right.

[19:42] *** kaare_ left
[19:43] *** iarna left
[19:44] *** iarna joined
[19:45] *** cognome left
[19:46] *** iarna left
[19:48] <vendethiel> erm, are you supposed to read "programming perl" when you don't know any perl?

[19:49] <vendethiel> there's a lot of stuff that's "there" but havn't been introducted.

[19:50] <dalek> roast: 59436af | (Pepe Schwarz)++ | S32-exceptions/misc.t:

[19:50] <dalek> roast: Added (fudged) test for RT #122502.

[19:50] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122502

[19:50] <dalek> roast: review: https://github.com/perl6/roast/commit/59436af1c6

[19:53] <dalek> nqp: ad212c2 | (Pepe Schwarz)++ | src/QRegex/P6Regex/Grammar.nqp:

[19:53] <dalek> nqp: Always capture min for quantifier **.

[19:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ad212c2953

[19:53] <dalek> nqp: 50b2038 | (Tobias Leich)++ | src/QRegex/P6Regex/Grammar.nqp:

[19:53] <dalek> nqp: Merge pull request #174 from peschwa/master

[19:53] <dalek> nqp: 

[19:53] <dalek> nqp: Always capture min for quantifier **.

[19:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/50b2038821

[19:54] <psch> btw, CLA won't go out for at least 2 more months, i'm moving end of this month and TPF probably wants my then-current address

[19:55] <psch> but there won't be any PRs either starting in about 3 weeks 'cause we won't have internet for a bit so there's that at least

[19:56] *** xenoterracide joined
[19:57] *** cooper- is now known as cooper

[19:57] *** cooper left
[19:57] *** cooper joined
[19:58] <masak> psch++

[19:58] *** dmol left
[19:59] <FROGGS> ohh dear, no internet /o\

[19:59] <psch> well, maybe not none at all, but not enough to push and pull code around all the time :P

[20:00] <psch> although i could probably assume that git is better at saving bandwidth than i assumed

[20:01] *** xenoterracide left
[20:02] *** anaeem1 joined
[20:02] <FROGGS> git likes to eat up my mobile broadband limit very quickly :o)

[20:06] *** virtualsue joined
[20:06] <timotimo> m: my @test = 1, 2, 3; say " → @test[1..2] ← ";

[20:06] <camelia> rakudo-moar 5d5ec1: OUTPUT« → 2 3 ← ␤»

[20:07] *** rurban joined
[20:11] *** xenoterracide joined
[20:12] <masak> m: my @test = 1, 2, 3; say " → @test[0..2] ← ";

[20:12] <camelia> rakudo-moar 5d5ec1: OUTPUT« → 1 2 3 ← ␤»

[20:12] <masak> m: my @test = 1, 2, 3; say " → @test[] ← ";

[20:12] <camelia> rakudo-moar 5d5ec1: OUTPUT« → 1 2 3 ← ␤»

[20:12] <masak> m: my @test = 1, 2, 3; say " → @test[0..*] ← ";

[20:12] <camelia> rakudo-moar 5d5ec1: OUTPUT« → 1 2 3 ← ␤»

[20:12] <masak> m: my @test = 1, 2, 3; say " → @test[*..2] ← ";

[20:13] <camelia> rakudo-moar 5d5ec1: OUTPUT«(timeout)»

[20:13] <masak> hm.

[20:14] *** anaeem1__ joined
[20:14] *** denis_boyun_ joined
[20:14] <FROGGS> m: my @test = 1, 2, 3; say " → @test[-Inf..2] ← ";

[20:14] <FROGGS> well...

[20:14] <camelia> rakudo-moar 5d5ec1: OUTPUT«(timeout)»

[20:14] <FROGGS> perhaps not the best idea :o)

[20:16] <masak> I'm not able to locate a piece of spec that talks about what * means in the lhs of a range of an indexing.

[20:17] *** anaeem1 left
[20:18] <jnthn> What were you wanting it to mean?

[20:18] <jnthn> Or were you just wanting to break stuff? :P

[20:18] *** brrt left
[20:19] <masak> the latter.

[20:19] <masak> but now I'm curious: what *does* it mean?

[20:19] <masak> (a) by spec, and (b) in Rakudo today.

[20:20] <lue> masak: if that range turns into WhateverCode, how do you know when the * is in the LHS? So, I'd expect *..2 to be (+@test)..2

[20:20] <masak> me too, I think.

[20:21] <masak> more generally, I expect * to mean +@array in a range in an indexing.

[20:21] *** Khisanth left
[20:21] *** Khisanth joined
[20:22] <jnthn> Ranges don't turn into whatevercode, though; afair, they are excluded from taht

[20:22] <masak> *nod*

[20:23] <masak> still, it doesn't hurt if they play to users' intuition.

[20:23] <jnthn> I suspect therefore that indexing wiht a range must special-case the endpoint.

[20:23] <jnthn> The endpoint being a *, that is

[20:23] <jnthn> Probably nobody thought (quite reasonably :P) about the starting point being * :)

[20:24] <lue> If array indexing can tell when the * is on the left, then it'd make sense for it to be 0, but otherwise I expect things with * in them to be WhateverCode, which wouldn't know where the * is.

[20:28] *** nbrown____ joined
[20:29] <masak> jnthn: I get that no-one thought of writing the starting point as * before. it doesn't make much sense, since the first index is always 0.

[20:29] <masak> jnthn: but it doesn't explain why Rakudo hangs on it.

[20:30] <jnthn> masak: Oh, I can imagine that easily enough...

[20:30] <psch> m: my @a := *..0; say @a[􏿽xC2^10] # a bit like watman

[20:30] <camelia> rakudo-moar 5d5ec1: OUTPUT«===SORRY!=== Error while compiling /tmp/qFL5e1xob0␤Undeclared routine:␤    Â used at line 1␤␤»

[20:30] <jnthn> masak: For example, maybe it grabs the first endpoint and loops, incrementing, until we hit the number of elems - 1.

[20:31] <psch> eh, half a unicode character :/

[20:31] <psch> m: my @a := *..0; say @a[^10] # a bit like watman

[20:31] <camelia> rakudo-moar 5d5ec1: OUTPUT«-Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf␤»

[20:31] <jnthn> m: say -Inf + 1

[20:31] <camelia> rakudo-moar 5d5ec1: OUTPUT«-Inf␤»

[20:31] <jnthn> Right :)

[20:33] *** nbrown____ left
[20:35] <masak> m: my @a = 1..3; @a[-Inf]

[20:35] <camelia> rakudo-moar 5d5ec1: OUTPUT«Unhandled exception: Unsupported use of [-Inf] subscript to access from end of Array; in Perl 6 please use [*-Inf]␤   at <unknown>:1  (/home/p6eval/rakudo-inst-2/languages/perl6/runtime/CORE.setting.moarvm:throw:4294967295)␤ from src/gen/m-CORE.setting…»

[20:35] <masak> but it clearly doesn't try to index -Inf, or we'd see that.

[20:36] <masak> hehe, "in Perl 6 please use [*-Inf]" :P

[20:36] <jnthn> Right, we don't really want to have to make another multi-dispatch round-trip through postcircumfix instead of calling .at_pos, I guess...

[20:36] <jnthn> And the negative check is there

[20:36] *** lizmat joined
[20:37] <jnthn> I suspect we should probably just spot that it's -Inf at that point, tbh

[20:37] *** xenoterracide left
[20:39] <psch> m: my @a = 1..3; say @a[*-Inf] # but i am

[20:39] <camelia> rakudo-moar 5d5ec1: OUTPUT«Unsupported use of [-Inf] subscript to access from end of Array; in Perl 6 please use [*-Inf]␤  in method gist at src/gen/m-CORE.setting:12952␤  in sub say at src/gen/m-CORE.setting:13890␤  in block  at /tmp/eAPhGTSEue:1␤␤»

[20:39] <psch> m: my @a = 1..3; say @a[*-*]

[20:39] <camelia> rakudo-moar 5d5ec1: OUTPUT«1␤»

[20:40] <psch> the last one surprised me a bit, but i guess it makes sense

[20:42] <vendethiel> "inf inf inf inf BATMAN"++

[20:44] <masak> psch: it does make sense. one sometimes wants to do @a[*/2]

[20:45] <lue> masak: wouldn't * div 2 be safer, or is subscripting just that smart? :)

[20:45] <timotimo> i think we have an "as Int" nowadays

[20:45] <masak> lue: subscripting floors.

[20:45] *** xenoterracide joined
[20:45] <lue> ah, good to know.

[20:45] <masak> or rounds towards 0, rather.

[20:47] <lue> depends on your definition of flooring I guess :)

[20:47] <masak> flooring always means towards -Inf

[20:47] <masak> m: say floor(-2.5)

[20:47] <camelia> rakudo-moar 5d5ec1: OUTPUT«-3␤»

[20:48] <timotimo> right. so it truncates, right?

[20:48] <masak> indexing does, yes.

[20:48] <masak> which is the same semantics as "as Int"

[20:49] <lue> masak: huh. my own definition is towards zero (or towards the smaller absolute value)

[20:49] <masak> lue: if you can provide me with a source for that... :)

[20:49] <masak> lue: otherwise I recommend you adjust your definition to everyone else's.

[20:49] *** colomon joined
[20:50] <lue> masak: I recall hearing long ago about there being confusion with floor/ceiling and what it means to everyone else's, and recently when I had to contend with floor/ceiling negative numbers, I figured "towards zero" made the most sense.

[20:51] <masak> lue: the thing that rounds towards zero is called "truncating".

[20:51] *** zengargo1le left
[20:52] <dalek> nqp: 5f67fae | jnthn++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[20:52] <dalek> nqp: Don't neglect to pass down :$want.

[20:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5f67faee70

[20:52] <dalek> nqp: ba097e3 | jnthn++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[20:52] <dalek> nqp: Can use a native int for this flag.

[20:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ba097e3bca

[20:52] <dalek> nqp: 6f9397f | jnthn++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[20:52] <dalek> nqp: Convey $want down into variable compilation.

[20:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6f9397f1a1

[20:52] <masak> lue: the metaphor of "flooring" is that the space you're occupying between two integers has a floor (the integer below you). the floor is always downwards, towards a lower number.

[20:54] <masak> unless you're on the integer, in which case you're already there.

[20:55] <dalek> nqp: 224c4f7 | jnthn++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[20:55] <dalek> nqp: Void context variable can generate no code.

[20:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/224c4f774b

[20:55] <dalek> nqp: f962e8f | jnthn++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[20:55] <dalek> nqp: Cleanup/simplify compile_all_the_stmts.

[20:55] <dalek> nqp: 

[20:55] <dalek> nqp: No need to handle QAST::Var here specially; that falls out of the

[20:55] <dalek> nqp: logic in compile_var now. Also don't dupe-fetch .node.

[20:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f962e8f7a1

[20:55] <lue> eh, sure. (I could swear there was something debatable there...) I still think going for the smallest absolute value has a better symmetry to it though :)

[20:55] <masak> sure. it's just not called "flooring".

[20:56] <timotimo> jnthn: is there a big benefit to this codegen?

[20:56] <masak> you might be thinking of the debatability of infix:<%>

[20:56] * lue wonders if the absolute-value-based version of ceiling has a special name

[20:56] *** dwarring joined
[20:56] <lue> masak: no, it was purely mathematical, and about floor/ceiling. Maybe I'm misremembering the section on wikipedia called "stuff that got it wrong" :P

[20:57] <dalek> nqp: 804aa54 | jnthn++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[20:57] <dalek> nqp: Fix QAST::WVal void context optimization.

[20:57] <dalek> nqp: 

[20:57] <dalek> nqp: It failed to generate nothing if in a void context.

[20:57] <dalek> nqp: review: https://github.com/perl6/nqp/commit/804aa54e9a

[20:57] <dalek> nqp: 3f1e934 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[20:57] <dalek> nqp: Don't emit anything for a null in void context.

[20:57] <dalek> nqp: 

[20:57] <dalek> nqp: We often use nqp::null() as a symbolic "null" op when optimizing bits

[20:57] <dalek> nqp: away. Make the code-gen cooperate with this technique.

[20:57] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3f1e934a87

[20:57] <jnthn> timotimo: Yes, just take a look at Frame_1 for CORE.setting before and after it :P

[20:57] <masak> lue: it's called "rounding towards infinity" according to https://en.wikipedia.org/wiki/Rounding

[20:58] <lue> aw, that's not nearly as fun to say as "antitruncation" or something :)

[20:58] <timotimo> jnthn: ok

[20:58] *** iarna joined
[21:00] <lue> masak: thanks for clearing that up. I blame my brain taking "floor(n) rounds to the smaller integer for all positive n" and extending that concept to "smaller absolute value" instead of "smaller number, including negatives" :P

[21:01] <masak> extending concepts is always intriguing.

[21:02] *** xenoterracide left
[21:04] * lue vows to call rounding to infinity "countertruncation" or whatever prefix makes the most sense :)

[21:06] <psch> no good sounding antonym for truncate on thesaurus.com :/

[21:06] <psch> "prolong" is most striking, but not pretty

[21:07] <lue> The opposite of truncation would be to add more digits, so a pure antonym doesn't really make sense.

[21:10] <dalek> nqp: 40b6408 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[21:10] <dalek> nqp: Fix coercion code-gen bug found by FROGGS++.

[21:10] <dalek> nqp: 

[21:10] <dalek> nqp: We should not so carelessly re-use registers that may actually be

[21:10] <dalek> nqp: for variables.

[21:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/40b6408a2f

[21:10] <dalek> nqp: 92be0f8 | jnthn++ | tools/build/MOAR_REVISION:

[21:10] <dalek> nqp: Get latest MoarVM.

[21:10] <dalek> nqp: 

[21:10] <dalek> nqp: Includes lazy deserialization imrpovements, including thread safety

[21:10] <dalek> nqp: fixes.

[21:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/92be0f8599

[21:11] *** brrt joined
[21:12] <dalek> rakudo/nom: 9bca34d | jnthn++ | tools/build/NQP_REVISION:

[21:12] <dalek> rakudo/nom: Get latest NQP for code-gen fixes, better Moar.

[21:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9bca34da90

[21:12] <dalek> rakudo/nom: 40748bc | jnthn++ | src/vm/moar/ops/perl6_ops.c:

[21:12] <dalek> rakudo/nom: Use new API for grabbing a code object.

[21:12] <dalek> rakudo/nom: 

[21:12] <dalek> rakudo/nom: This handles lazily deserializing it if needed.

[21:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/40748bcd3e

[21:12] <jnthn> This also deals with the recent regressions in encode.t, which I think was also noticed in the ecosystem.

[21:13] <psch> lue: abtruncate maybe, as "truncate away from [zero]"

[21:14] <psch> actually that would have to be abstruncate, because t, says http://wordinfo.info/unit/2357/ip:1

[21:14] <lue> I was just going to say, there would need to be some sort of sound change for abtruncate.

[21:15] <psch> it doesn't sound bad to my german ears... :)

[21:15] <masak> 'night, #perl6

[21:15] <FROGGS> correct :o)

[21:15] <FROGGS> gnight masak 

[21:15] <lue> ♞ masak o/

[21:15] <colomon> \o

[21:16] <lue> abstruncate works for me, now to find excuses to spread it across the globe! :)

[21:16] <psch> night masak 

[21:19] <timotimo> sweet! we're down to 104 megabytes maxrss when we run "say 1" on perl6-m

[21:20] <timotimo> we seem to be going in the right direction

[21:21] <lizmat> jnthn: we got a few new failures though:

[21:21] <timotimo> oh no :<

[21:22] <lizmat> make t/spec/S32-list/uniq.t fails 11 tests, but running without the harness it's ok

[21:22] *** nbrown____ joined
[21:22] <jnthn> Yes, I get it fine without the harness too. Had no luck hunting down why. I'm not sure how much it is to do with recent changes.

[21:23] <lizmat> t/spec/S04-phasers/init.t fails 7 of 11

[21:23] <jnthn> Yup, that one's on my "to fix tomorrow" list.

[21:23] <jnthn> That one is easily reproducable without the harness, but really weird.

[21:23] <lizmat> the third one was a flap

[21:23] <jnthn> Which ws the third one?

[21:23] <jnthn> *was

[21:23] <lizmat> t/spec/S03-operators/subscript-adverbs.t

[21:23] <jnthn> Oh

[21:24] <jnthn> Never seen that one have any issues here...

[21:24] <lizmat> Non-zero wait status: 6

[21:24] <lizmat>   Parse errors: No plan found in TAP output

[21:24] <jnthn> Odd

[21:24] <lizmat> no, it's just every now and then a random test file fails

[21:24] <jnthn> Hm

[21:24] <jnthn> Was there a time improvement?

[21:24] <lizmat> Files=912, Tests=31961, 176 wallclock secs ( 8.91 usr  3.73 sys + 1099.75 cusr 127.86 csys = 1240.25 CPU)

[21:25] <lizmat> parsing the setting: 29.409

[21:25] <lizmat> the lowest I've ever seen

[21:25] *** anaeem1__ left
[21:25] <jnthn> What were your previous values, ooc?

[21:25] <jnthn> Lowest for spectest too?

[21:25] <lizmat> a few weeks ago around 35

[21:25] * jnthn is almost at a new low on spectest

[21:25] <lizmat> could be the lowest, lemme try again

[21:26] <jnthn> Lowest for me was before we added the threading tests

[21:26] <jnthn> Some of them still take a while and clog the run on windows. :(

[21:26] <jnthn> But certainly what I get now is the lowest since we've got them.

[21:27] *** nbrown____ left
[21:28] *** anaeem1_ joined
[21:29] <lizmat> Files=912, Tests=32080, 172 wallclock secs ( 8.56 usr  3.62 sys + 1065.74 cusr 125.92 csys = 1203.84 CPU)

[21:29] <lizmat> only t/spec/S04-phasers/init.t  failed this time

[21:29] <jnthn> Ah, OK

[21:29] <lizmat> that is *definitely* the loweset I've seen

[21:29] <jnthn> I'll see if I can nail that one tomorrow.

[21:30] <lizmat> okidoki... it was a long day and a long drive for me... so I'm calling it a day

[21:30] <lizmat> sleep&

[21:30] <jnthn> :)

[21:30] <jnthn> See you tomorrow o/

[21:33] *** iarna left
[21:37] *** anaeem1_ left
[21:42] *** brrt left
[21:48] *** iarna joined
[21:51] *** grondilu joined
[21:51] <grondilu> are transliterations supposed to accept the :pos adverb?

[21:52] <grondilu> m: say "foo bar".trans: 'ao' => 'oa', :pos(1);

[21:52] <camelia> rakudo-moar 5d5ec1: OUTPUT«faa bor␤»

[21:52] <grondilu> m: say "foo bar".trans: 'ao' => 'oa', :pos(3);

[21:52] <camelia> rakudo-moar 5d5ec1: OUTPUT«faa bor␤»

[21:55] *** denis_boyun_ left
[22:03] *** ventica3 joined
[22:04] <psch> .trans (and tr///) adverbs aren't really clear to me either.  i mentioned only thinking :i and :ii sensible a few days back, with lue++ adding :m and :mm

[22:04] <psch> roast tests for :c, :squash and :delete, the last of which seems redundant

[22:04] <lue> :p doesn't make sense, but I can see a case for :c

[22:05] *** spider-mario left
[22:06] *** ventica2 left
[22:06] <lue> I'm noticing more and more that S05 was either never fully completed, or it's an extreme victim of "oh, we won't bother mentioning stuff that's the same as in Perl 5" syndrome.

[22:10] <psch> i'm still a bit unsure about m:g//, especially in for

[22:10] <psch> the perl5 idiom is something like "say $1 while m/(.)/g"

[22:11] <psch> m: $_ = "abc"; for m:g/(.)/ { say $1 } # works now, iirc

[22:11] <camelia> rakudo-moar 5d5ec1: OUTPUT«(Any)␤(Any)␤(Any)␤»

[22:11] <psch> i don't... :)

[22:11] <psch> m: $_ = "abc"; for m:g/(.)/ { say $/[0] } # works now, iirc

[22:11] <camelia> rakudo-moar 5d5ec1: OUTPUT«｢c｣␤␤｢c｣␤␤｢c｣␤␤»

[22:11] <psch> m: $_ = "abc"; for m:g/(.)/ { .say  } # works now, iirc

[22:11] <camelia> rakudo-moar 5d5ec1: OUTPUT«｢a｣␤ 0 => ｢a｣␤␤｢b｣␤ 0 => ｢b｣␤␤｢c｣␤ 0 => ｢c｣␤␤»

[22:11] <psch> that last one

[22:12] <psch> but that's because m:g// returns a List

[22:12] <psch> but the spec usually says "m:g// returns a Match"

[22:12] *** gfldex left
[22:12] *** ventica joined
[22:12] <psch> so in the branch i implemented that does that we'd have to run it as 'for @(m:g/(.)/) ...' which seems a bit unwieldy

[22:13] <psch> but no one told me it's really wrong, so it sits there untill someone looks at it and says whether it's wrong or not :)

[22:13] <psch> that's the main gripe i have with S05 :P

[22:13] *** ventica3 left
[22:14] <lue> psch: like I said, either it's secretly never been finished, or suffers from "it's in Perl 5, so why say it" syndrome, or both :)

[22:15] <lue> btw, the P6 version of that idiom would be  say $_ for $str.comb(/./)  , most likely.

[22:17] <psch> that does seem more idiomatic, yes.

[22:23] *** iarna left
[22:23] *** nbrown____ joined
[22:27] *** nbrown____ left
[22:31] *** Psyche^ joined
[22:35] *** Psyche^_ left
[22:51] *** cono joined
[22:52] <cono> http://paste.org.ru/?krh2pi is it possible to say ^sqrt(*) somehow?

[22:55] <colomon> cono: what do you want it to do?

[22:55] <lue> r: my @a = 1,2,3,4; say $_ for @a[^*.sqrt]

[22:55] <camelia> rakudo-{parrot,jvm,moar} 40748b: OUTPUT«1␤2␤»

[22:55] <lue> for some reason [^sqrt(*)] fails

[22:55] <cono> uh :)

[22:56] <cono> thanks

[22:56] <lue> no problem :)

[22:57] <colomon> sqrt(*) is passing a Whatever to the sqrt function, rather than making a WhateverCode.

[22:58] <cono> my first version was with loop: http://paste.org.ru/?2zfau0 What am I doing wrone ?

[22:58] <cono> ------> t $i = 0; $i < @cache.elems.sqrt; ++$i) ⏏{

[23:00] *** grondilu left
[23:01] <psch> m: loop #`[[ without this space here you have a function call ]] (my $a = 0; $a < 5; ++$a) { say $a }

[23:01] <camelia> rakudo-moar 40748b: OUTPUT«0␤1␤2␤3␤4␤»

[23:01] <psch> m: loop(my $a = 0; $a < 5; ++$a) { say $a }

[23:01] <camelia> rakudo-moar 40748b: OUTPUT«===SORRY!===␤Word 'loop' interpreted as 'loop()' function call; please use whitespace around the parens␤at /tmp/7YqNoPLv1Z:1␤------> loop⏏(my $a = 0; $a < 5; ++$a) { say $a }␤Unexpected block in infix position…»

[23:01] <cono> uh, got it. Thanks

[23:12] *** aghbas joined
[23:12] *** aghbas left
[23:15] <colomon> m: my @a = 1..10; say @a.sqrt

[23:15] <camelia> rakudo-moar 40748b: OUTPUT«3.16227766016838␤»

[23:21] <cono> I did it :) ./perl6-m ~/perl/25k_prime.pl  1082.62s user 4.10s system 100% cpu 18:05.34 total

[23:24] *** nbrown____ joined
[23:26] <cono> inspired by this video https://www.youtube.com/watch?v=UJPdhx5zTaw

[23:28] *** nbrown____ left
[23:37] *** BenGoldberg joined
[23:42] <timotimo> oof, 18 minutes

[23:42] <timotimo> cono: can you tell us moar --version?

[23:56] *** SevenWolf joined
