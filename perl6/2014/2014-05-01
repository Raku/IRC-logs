[00:00] *** cognominal joined
[00:05] *** Entonian left
[00:06] <raiph> https://github.com/raiph/rakudo-debugger/commit/9ac8153eec1d370479ef3190cff6f668206027eb#commitcomment-6177323 would appreciate response by someone who knows how to use github to do updates of pull requests

[00:09] *** cognominal left
[00:11] *** rurban left
[00:32] *** cognominal joined
[00:38] *** moistcherry joined
[00:41] *** moistcherry is now known as hoverboard

[00:56] <dwarring> raiph: I'm no github expert by any stretch

[00:57] <dwarring> github automatically creates a branch for each PR

[00:58] <dwarring> that PR is on branch patch-4

[00:59] <dwarring> I'd try: git checkout patch-4 

[00:59] <raiph> dwarring: thanks for help

[01:00] <raiph> dwarring++ # for advent fixing too

[01:00] <raiph> dwarring: I don't currently use git but I guess it's time to change that :)

[01:02] <dwarring> it's fun

[01:02] <dwarring> have picked up lots of tips and techniques along the way

[01:04] <dwarring> still most of 2010 & 2011 open

[01:04] <dwarring> if anyone else wants to do some

[01:05] <raiph> i've used git over the last couple years for a couple things but not with github repos nor with my current rakudo dev environment (feather)

[01:07] <dwarring> github adds another layer of magic

[01:08] <dwarring> afk

[01:08] *** Sqirrel_ joined
[01:10] *** Sqirrel left
[01:22] *** xenoterracide_ joined
[01:31] *** FROGGS joined
[01:53] *** FROGGS left
[01:54] *** klapperl_ left
[01:55] *** klapperl joined
[01:56] *** hoverboard left
[01:56] *** Su-Shee left
[01:56] *** FROGGS joined
[01:57] *** xinming_ left
[01:58] *** Su-Shee joined
[01:58] *** xinming_ joined
[02:04] *** hoverboard joined
[02:06] *** FROGGS left
[02:06] *** btyler left
[02:06] <japhb> When a particular method of a common class in the setting does not make sense on some backends, what's the usual way to handle this?  Hide the method entirely on those backends?  Do an X::NYI.new(feature => 'The::Class.the-method').fail?

[02:12] <dalek> rakudo/nom: 6023d81 | (Geoffrey Broadwell)++ | src/core/IO.pm:

[02:12] <dalek> rakudo/nom: Add an IO::Path.watch convenience method

[02:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6023d81d76

[02:12] * japhb just picked one

[02:23] *** hoverboard left
[02:27] *** BenGoldberg left
[02:29] *** BenGoldberg joined
[02:33] *** xragnar_ joined
[02:33] *** xragnar is now known as Guest12522

[02:33] *** Guest12522 left
[02:33] *** xragnar_ is now known as xragnar

[02:41] *** hoverboard joined
[02:44] <colomon> hmmm, is there a way to do something in a loop every time but the first?

[02:44] *** thou joined
[02:49] *** hoverboard left
[02:50] <BenGoldberg> while ( blah blah blah ) { state $first; doit() if $first++ }

[02:50] <colomon> BenGoldberg++

[02:51] <BenGoldberg> :)

[02:52] <BenGoldberg> Although you might want to declare $first as a 'my' variable, before the loop

[02:52] <BenGoldberg> ... if this is in a subroutine, and if you *don't* want it to be influenced by previous calls to the subroutine.

[03:03] *** dayangkun left
[03:13] *** hoverboard joined
[03:15] *** dayangkun joined
[03:17] *** dayangkun left
[03:17] *** dayangkun joined
[03:18] *** dayangkun left
[03:19] *** dayangkun joined
[03:20] *** dayangkun left
[03:21] *** dayangkun joined
[03:22] *** dayangkun left
[03:23] *** dayangkun joined
[03:24] *** dayangkun left
[03:25] *** dayangkun joined
[03:41] *** stux joined
[03:45] *** thou left
[03:55] *** BenGoldberg left
[04:03] *** kaare_ joined
[04:04] *** thou joined
[04:09] *** zacts joined
[04:10] <zacts> is perl6 usable for production projects?

[04:10] *** FROGGS joined
[04:12] *** hoverboard is now known as moistcherry

[04:17] *** lvfjf left
[04:18] *** SamuraiJack joined
[04:18] *** lvfjf joined
[04:32] *** rindolf joined
[04:34] *** Psyche^_ left
[04:36] *** lvfjf left
[04:36] *** Psyche^ joined
[04:36] *** lvfjf joined
[04:37] *** FROGGS left
[04:39] *** adu joined
[04:42] *** bjz joined
[04:45] *** jnap1 left
[04:48] <TimToady> .tell BenGoldberg using 'my' instead of 'state' is not necessary, since the loop's closure is recloned at the same time the 'my' would have been, so the state resets on re-entry to the outer scope

[04:48] <yoleaux> TimToady: I'll pass your message to BenGoldberg.

[04:49] *** moistcherry is now known as hoverboard

[05:01] *** Alula_ left
[05:02] *** kaare_ left
[05:14] *** Alula_ joined
[05:16] *** jnap joined
[05:16] <adu> hi

[05:18] *** lvfjf left
[05:20] *** jnap left
[05:26] *** kaare_ joined
[05:30] *** sigstuff joined
[05:30] *** sigstuff left
[05:34] *** rindolf left
[05:42] *** telex left
[05:43] <vendethiel> o/, #perl6

[05:44] *** telex joined
[05:50] <nwc10> jnthn: only ASAN fail is t/spec/S17-lowlevel/lock.rakudo.moar

[05:50] <nwc10> jnthn: read by thread T3 of somethign freed by T1, allocated by T0

[06:04] *** hoverboard is now known as moistcherry

[06:05] *** rindolf joined
[06:16] *** jnap joined
[06:21] *** jnap left
[06:25] *** thou left
[06:25] *** cxreg left
[06:32] *** dayangkun left
[06:35] *** cxreg joined
[06:36] *** adu left
[06:41] *** pdcawley left
[06:43] *** pdcawley joined
[06:45] *** kaare_ left
[06:46] *** moistcherry left
[06:47] *** FROGGS joined
[06:49] *** dayangkun joined
[06:49] *** igorsutton joined
[06:52] *** grondilu joined
[06:55] <grondilu> std: $_ (-)= set ()

[06:55] <camelia> std ec3d853: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused at /tmp/RGWoGkVZS_ line 1:‚ê§------> [32m$_ [33m‚èè[31m(-)= set ()[0m‚ê§    expecting any of:‚ê§        feed_separator‚ê§ infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Parse failed‚ê§FAILED 00:01 125m‚ê§¬ª

[06:56] <grondilu> std: $_ = $_ (-) set ()

[06:56] <camelia> std ec3d853: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused at /tmp/iwM4f_285M line 1:‚ê§------> [32m$_ = $_ [33m‚èè[31m(-) set ()[0m‚ê§    expecting any of:‚ê§    feed_separator‚ê§ infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Parse failed‚ê§FAILED 00:01 1‚Ä¶¬ª

[06:58] <nwc10> jnthn: http://paste.scsys.co.uk/362401 -- ctx->callsite->has_flattening -- 0x6008003fab6c is located 28 bytes inside of 40-byte

[07:00] <nwc10> no, 28 doesn't make sense to me in terms of structure offset, but it's adamant

[07:06] *** logie left
[07:08] *** zakharyas joined
[07:09] *** pecastro left
[07:17] *** jnap joined
[07:22] *** jnap left
[07:22] *** sqirrel joined
[07:22] *** darutoko joined
[07:36] <lizmat> jnthn: didn't get around to testing async IO yet, got stuck with finding out why Supply.delay|stable tests don't work

[07:40] *** Sqirrel_ left
[07:40] *** Sqirrel_ joined
[07:46] *** sqirrel left
[07:51] *** denis_boyun_ joined
[07:53] *** thou joined
[07:58] *** thou left
[07:59] *** kaare_ joined
[08:07] <dalek> specs: 02e59c9 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[08:07] <dalek> specs: Formally spec Supply.(Channel|Promise)

[08:07] <dalek> specs: review: https://github.com/perl6/specs/commit/02e59c99b1

[08:07] *** Ven joined
[08:08] <Woodi> hi today :)

[08:09] <FROGGS> hi Woodi 

[08:09] <lizmat> hi Woodi FROGGS !

[08:09] <FROGGS> hi lizmat :o)

[08:12] *** virtualsue joined
[08:16] <dalek> roast: 219a020 | (Elizabeth Mattijsen)++ | S17-supply/Channel.t:

[08:16] <dalek> roast: Added basic Supply.Channel tests

[08:16] <dalek> roast: review: https://github.com/perl6/roast/commit/219a020e24

[08:18] *** jnap joined
[08:18] <FROGGS> jnthn: I think I need your help after you had your coffee :/

[08:19] *** darutoko- joined
[08:21] *** darutoko left
[08:23] *** jnap left
[08:23] <FROGGS> usually a HanderScope is made when I compile my script, which has a (labeled) loop

[08:23] <FROGGS> and this is differntly for MapIter, the HandlerScope is already made in the setting

[08:23] <FROGGS> so I cannot attach the label to the handler at that time

[08:23] <FROGGS> I think I need a way to attach/detach a label to a HandlerScope when it runs the MapIter.reify

[08:24] <FROGGS> jnthn: does that seem sane? and how do I get my hands on that HandlerScope?

[08:25] <Woodi> someone could help me how to get items from match object in order they was parsed ? I have files with colums definitions on top then data, then ocassionally columns redefinition. I trying to take this info from match object so working post-parse, no actions.

[08:25] <FROGGS> Woodi: can you put that in a gist? a runnable script including sample data?

[08:25] <Woodi> k

[08:28] *** lue left
[08:29] <Su-Shee> good morning everyone.

[08:29] <lizmat> Su-Shee o/

[08:33] <dalek> roast: 4ee319e | (Elizabeth Mattijsen)++ | S17-supply/Promise.t:

[08:33] <dalek> roast: Add basic Supply.Promise tests

[08:33] <dalek> roast: review: https://github.com/perl6/roast/commit/4ee319ecb6

[08:35] <dalek> rakudo/nom: 936fb75 | (Elizabeth Mattijsen)++ | t/spectest.data:

[08:35] <dalek> rakudo/nom: Make sure we test Supply.(Channel|Promise)

[08:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/936fb752f6

[08:36] <dalek> roast: c0fc454 | (Elizabeth Mattijsen)++ | S17-supply/ (2 files):

[08:36] <dalek> roast: We don't need Test::Tap here

[08:36] <dalek> roast: review: https://github.com/perl6/roast/commit/c0fc454825

[08:36] <lizmat> afk&

[08:37] <Woodi> hi Su-Shee

[08:37] *** darutoko joined
[08:38] <Woodi> FROGGS: script and data:  http://pastebin.com/qv7QnSUB

[08:39] *** darutoko- left
[08:40] <Woodi> probably I trying to mimic Perl5 way, badly etc. but I wonder can grammar be used in DOM/SAX/StAX ways ? :)  http://pl.wikipedia.org/wiki/Streaming_API_for_XML

[08:41] *** lue joined
[08:44] <Woodi> um,  http://en.wikipedia.org/wiki/StAX  :)

[08:44] <FROGGS> Woodi: so you want to be able to loop over the headers, and then have the dlines in its header?

[08:44] <Woodi> probably. I need to sums data in columns

[08:46] <Woodi> for start how to get something like $r.list...

[08:47] <Woodi> maybe "token lines" including all kinds could help...

[08:47] <FROGGS>       token TOP { [ <header> | <.comment> ]+ };

[08:47] <FROGGS>       token header { '=data ' <cs>+ % [\h+] \n [ <dline> | <.comment> ]* };

[08:48] <FROGGS> I would use these tokens instead

[08:48] <FROGGS> this way you would have the dlines nestid in their headers

[08:48] <FROGGS> and you discard the comments

[08:48] <Woodi> hmm

[08:48] <Woodi> right, let's build some grammar ;)

[08:49] <FROGGS> then you can do: for @($r<header>) -> $h { for @($r<dline>) -> $dl { ... } }

[08:49] *** raiph left
[08:50] <masak> antenoon, #perl6

[08:50] <Woodi> hallo masak 

[08:50] <FROGGS> Woodi: here is the gist: https://gist.github.com/FROGGS/3b7cebc3301e050a9b9a

[08:51] <FROGGS> I commented some stuff so it better fits on my screen :o)

[08:51] <FROGGS> hi masak 

[08:51] <Woodi> FROGGS: checking

[08:55] <Woodi> FROGGS: work ! thanx :)

[08:55] <FROGGS> Woodi: you're welcome :o)

[08:58] <Woodi> but still I have problem with understanding something:  for @($r<header>) -> $h { for @($r<dline>)...     $r<header> is level-one item in hash and $r<dline> is also level-one so normally they are unrelated. looks automagically works but I didn't try this approach becouse I expected <dlines> should be "inside" headers...

[08:59] <FROGGS> ohh

[08:59] <FROGGS> should be for @($h<dline>)

[09:00] <masak> m: $h = { dline => 42 }; say @($h<dline>); say @$h<dline>

[09:00] <camelia> rakudo-moar 6023d8: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/O8M1HLVfJo‚ê§Variable '$h' is not declared‚ê§at /tmp/O8M1HLVfJo:1‚ê§------> [32m$h[33m‚èè[31m = { dline => 42 }; say @($h<dline>); sa[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[09:00] <masak> m: my $h = { dline => 42 }; say @($h<dline>); say @$h<dline>

[09:00] <camelia> rakudo-moar 6023d8: OUTPUT¬´42‚ê§===SORRY!===‚ê§postcircumfix:<{ }> not defined for type List‚ê§¬ª

[09:01] <FROGGS> m: my $h = { dline => 42 }; say @h<dline>

[09:01] <camelia> rakudo-moar 6023d8: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/pe3EmJv7PL‚ê§Variable '@h' is not declared. Did you mean '$h'?‚ê§at /tmp/pe3EmJv7PL:1‚ê§------> [32mmy $h = { dline => 42 }; say @h<dline>[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        po‚Ä¶¬ª

[09:01] <FROGGS> ahh, wait, only @<foo> was sugar for @($<foo>) of course

[09:02] <Woodi> ook, so probably my grammar was messing with me. thanx

[09:03] <Woodi> btw. tips for grammars in Perl6:  a) forget "rules";  b) use \h, not \s :)

[09:05] <jnthn> FROGGS: No, 'cus that handler scope is static and so shared between all maps

[09:05] <FROGGS> and c) if the rules/token look overly complex, one is missing the obvious simple solution :o)

[09:05] <jnthn> FROGGS: So will need to see what label is being thrown, if any, and check it in the handler, I think.

[09:06] <FROGGS> jnthn: but how can I check it in the handler if I cannot attach it to the handler?

[09:06] <Woodi> no, no, no... for line-after-line format lines are obvious way !

[09:07] <FROGGS> I get the thrown payload, but I have nothing to compare it to

[09:07] <jnthn> FROGGS: huh? You pass the label into MapIter, no?

[09:07] <FROGGS> Woodi: I wasn't talking about the current piece of code :o)

[09:07] <FROGGS> jnthn: I have it in the MapIter, aye

[09:08] *** virtualsue left
[09:08] <FROGGS> hmmm

[09:08] <jnthn> And the label is conveyed through the exception object, surely?

[09:08] <FROGGS> the thrown label is in the payload of the exception, yes

[09:08] *** Rotwang joined
[09:09] <jnthn> So you get it and compare it?

[09:10] <jnthn> 'REDO', $state = 2,

[09:10] <FROGGS> jnthn: are you saying that I should try to get my hands on the thrown exception in MapIter.reify? using nqp::exception()?

[09:10] <jnthn> Like there.

[09:10] <jnthn> Right.

[09:10] <FROGGS> aha

[09:11] *** darutoko- joined
[09:11] <jnthn> I hope at some point we'll compile sink-context for loops into something that doesn't need to go through MapIter.

[09:11] <FROGGS> I am all 'for' it :o)

[09:12] <jnthn> :P

[09:12] <nwc10> good appropriate-time-of-day, real-jnthn

[09:12] <jnthn> o/ nwc10 

[09:14] *** darutoko left
[09:19] *** jnap joined
[09:23] *** jnap left
[09:35] *** plobsing left
[09:39] *** denis_boyun_ left
[09:43] *** rindolf left
[09:48] *** spider-mario joined
[09:52] <FROGGS> ohh, it seems to work now... damn, that was tricky

[09:55] <jnthn> Welcome to Perl 6 impl :P

[10:00] <FROGGS> :P

[10:00] <jnthn> righty...admin things done, now I can hack :)

[10:01] <nwc10> good afternoon, jnthn

[10:02] <jnthn> ;)

[10:05] <jnthn> I think the VMNull-introducing branch seems to not be busting things.

[10:05] <jnthn> So I think I'll go ahead and merge.

[10:06] *** dalek left
[10:06] <jnthn> Hm, well, it was a ff in Moar :)

[10:06] <jnthn> haha

[10:06] *** dalek joined
[10:06] *** ChanServ sets mode: +v dalek

[10:09] <jnthn> https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#parallel # that's a cute supply method idea :)

[10:15] <dalek> nqp: 2b8ad37 | jnthn++ | tools/build/MOAR_REVISION:

[10:15] <dalek> nqp: Bump to a Moar with VMNull changes.

[10:15] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2b8ad3703c

[10:17] <masak> this month still wants for a release manager.

[10:19] *** jnap joined
[10:23] *** jnap left
[10:26] *** vaskozl joined
[10:27] *** rindolf joined
[10:29] *** ponbiki left
[10:32] <dalek> rakudo/nom: 7a8d595 | (Timo Paulssen)++ | src/vm/moar/ops/perl6_ops.c:

[10:32] <dalek> rakudo/nom: this gets us through CORE.setting. but it's probably wrong.

[10:32] <dalek> rakudo/nom: 

[10:32] <dalek> rakudo/nom: at the very least p6captureouters is not correct this way.

[10:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7a8d595c57

[10:32] *** dalek left
[10:33] *** dalek joined
[10:33] *** ChanServ sets mode: +v dalek

[10:33] <colomon> ‚Ä¶. errr, that's a scary looking commit message.

[10:34] <jnthn> colomon: It was the first commit in a branch

[10:34] <jnthn> colomon: Which I just merged

[10:34] <colomon> ah

[10:34] *** vaskozl left
[10:38] *** denis_boyun_ joined
[10:51] *** vaskozl joined
[10:57] *** xinming_ left
[11:00] <dalek> Perlito: 4242a67 | (Flavio S. Glock)++ | / (4 files):

[11:00] <dalek> Perlito: Perlito5 - string parser flags \E \L \U \Q

[11:00] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/4242a6797e

[11:05] <dalek> nqp/async_ops: 7ca649e | (Donald Hunter)++ | src/vm/jvm/runtime/org/perl6/nqp/ (2 files):

[11:05] <dalek> nqp/async_ops: Implement asyncwritebytes on JVM.

[11:05] <dalek> nqp/async_ops: review: https://github.com/perl6/nqp/commit/7ca649edda

[11:06] *** donaldh joined
[11:08] <dalek> Perlito: 971dcd9 | (Flavio S. Glock)++ | / (3 files):

[11:08] <dalek> Perlito: Perlito5 - AST dumper tweak

[11:08] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/971dcd940a

[11:11] <tadzik> did anyone look into a deserialization bug from p6u?

[11:12] *** donaldh left
[11:13] *** donaldh joined
[11:16] <FROGGS> tadzik: not yet

[11:18] *** xenoterracide_ left
[11:18] *** Alina-malina left
[11:20] *** jnap joined
[11:24] *** pippo joined
[11:24] <pippo> o/ #perl6!

[11:25] *** jnap left
[11:25] <lizmat> pippo o/

[11:26] <pippo> o/ lizmat :-)

[11:27] <pippo> I have tried this jnthn example here https://gist.github.com/anonymous/260ffb652a390fa9bb45

[11:27] <pippo> but does not reliably work: https://gist.github.com/anonymous/4850e487711d1d97dca7

[11:27] <pippo> Is it a know bug? 

[11:29] * lizmat tries

[11:29] <pippo> Results differ and I also have unhandled exceptions ‚Ä¶

[11:30] <jnthn> If we're unlucky enough that .words uses gather/take, then it's probably the known issue around that.

[11:30] <jnthn> Only on Moar, not JVM.

[11:30] <pippo> jnthn: I confirm JVM works fine.

[11:31] <lizmat> confirmed the problem on moar

[11:31] <lizmat> .words uses .comb, which uses .map 

[11:31] <lizmat> oops

[11:32] *** Alula_ left
[11:32] <lizmat> words for defined objects uses com, which uses match, which uses gather

[11:32] <lizmat> although I'm really at a los to understand why gather would be needed here

[11:33] *** Alula_ joined
[11:33] <lizmat> *loss

[11:35] <dalek> rakudo/nom: 7c80abb | jnthn++ | src/vm/moar/ops/perl6_ops.c:

[11:35] <dalek> rakudo/nom: Fix a warning.

[11:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7c80abb8f7

[11:35] <dalek> rakudo/nom: 2f5809b | jnthn++ | src/vm/moar/ops/perl6_ops.c:

[11:35] <dalek> rakudo/nom: Move some reads after lexical lookups.

[11:35] <dalek> rakudo/nom: 

[11:35] <dalek> rakudo/nom: This is in preparation for making allocation of scalars etc. lazier.

[11:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f5809ba2f

[11:36] <pippo> lizmat: so at the moment gather/take is somehow causing glitches with concurrency on Moar. Thank you lizmat and jnthn.

[11:37] <pippo> I'll use JVM for that kind of tasks for now.

[11:38] *** pecastro joined
[11:39] <lizmat> pippo: that seems like a good temporary workaround

[11:39] <jnthn> Yeah. I looked a bit at the gather/take bug. It's hard.

[11:39] <jnthn> The fix may not be hard

[11:40] <jnthn> But working out what's going on is.

[11:44] <pippo> jnthn: I am not a pro. Well the contrary of that is more realistic. But if I can help I can have some hours this week-end.

[11:48] <pippo> afk &

[11:50] *** xinming_ joined
[11:59] *** anaeem1 joined
[12:03] *** anaeem1 left
[12:05] *** denis_boyun_ left
[12:16] *** Alina-malina joined
[12:16] *** SamuraiJack left
[12:18] *** SamuraiJack joined
[12:18] <masak> tip for when you know you only need one grammar/actions pair: put the grammar inside the actions class.

[12:19] <masak> and then do G.parse(..., :actions(self.new))

[12:20] <masak> or even $?CLASS.new

[12:20] *** Vlavv left
[12:21] *** jnap joined
[12:25] *** jnap left
[12:26] * lizmat senses an opportunity for a blog post :-)

[12:29] <masak> that's what I felt when I discovered this, yes.

[12:30] <masak> I also re-used the same actions *object* for several parses, something I hadn't done before.

[12:30] <masak> this tends to be something one wants when parsing a line-based format.

[12:35] <dalek> rakudo-star-daily: 0da4854 | coke++ | log/ (5 files):

[12:35] <dalek> rakudo-star-daily: today (automated commit)

[12:35] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/0da4854209

[12:37] <Ven> https://github.com/coke/rakudo-star-daily/compare/3067e832d1c4c03b28f32d5713d16676dd827eaf...0da4854209 -- changes over ~60 days

[12:37] *** kurahaupo joined
[12:38] <Ven> https://github.com/coke/rakudo-star-daily/compare/9937ef27fc73579a71b8be9674ebc6f4fdd20273...0da4854209 -- over one month

[12:39] <dalek> specs: b806d66 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[12:39] <dalek> specs: Spec Supply.act

[12:39] <dalek> specs: review: https://github.com/perl6/specs/commit/b806d66a24

[12:39] *** vaskozl left
[12:48] <lizmat> m: Supply.new.tap.WHAT.say

[12:48] <camelia> rakudo-moar 72f5b9: OUTPUT¬´(Tap)‚ê§¬ª

[12:49] <lizmat> m: Tap.WHAT.say

[12:49] <camelia> rakudo-moar 72f5b9: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Rc9_uyKrhR‚ê§Undeclared name:‚ê§    Tap used at line 1‚ê§‚ê§¬ª

[12:49] <lizmat> hmmm.. seems we cannot check if something is a Tap ?

[12:49] <jnthn> Not easily

[12:49] <jnthn> I think it's a lexical class at the moment within Supply

[12:50] <masak> m: my @fruits = { :apple }, { :orange }, { :orange }; for @fruits { when :(:$apple) { say "apple" }; when :(:$orange) { say "orange" } }

[12:50] <camelia> rakudo-moar 72f5b9: OUTPUT¬´apple‚ê§orange‚ê§orange‚ê§¬ª

[12:50] <lizmat> jnthn: it is

[12:50] <masak> syntax is a bit quirky, but can definitely use signatures to partially match hash pseudo-objects.

[12:51] <lizmat> is there a reason for having it only inside the Supply role ?

[12:51] <jnthn> Mostly because it's only meaningful for Supply to create them.

[12:52] <jnthn> And I tend to default to encapsulating things I consider implementation details :)

[12:52] <lizmat> indeed, it;s now just hard to test whether .tap actually returns a Tap  :-)  

[12:52] <jnthn> Aye.

[12:52] <jnthn> I've no particular feelings on how to fix that :)

[12:53] <lizmat> the odd thing of course, is that .WHAT *does* expose the inner Tap class

[12:54] <lizmat> as (Tap), not as e.g. (Supply::Tap)

[12:54] <masak> lizmat: well, there's your way to check whether something is a Tap, then :P

[12:55] <masak> m: say Supply.new.tap ~~ Supply.new.tap.WHAT

[12:55] <camelia> rakudo-moar 72f5b9: OUTPUT¬´True‚ê§¬ª

[12:55] <lizmat> eh...  that feels like checking that 42 ~~ 42

[12:55] <masak> more like 42 ~~ Int

[12:55] <masak> where someone gave you a type and told you it's an Int.

[12:56] <lizmat> would be more like 42 ~~ 42.WHAT

[12:56] <lizmat> I can't specify the Int, *that* is the problem

[12:57] <masak> could declare a Supply.Tap method that returns the Tap type.

[12:57] <masak> but I'm not sure that's preferable to just putting Tap outside Supply.

[12:57] <lizmat> well, that's what 

[12:57] <lizmat> brb

[12:58] <masak> if the reason for keeping it inside was to control who gets to create objects.

[12:58] <masak> m: my $t1 = Supply.new.tap; my $t2 = $t1.new; say $t2.^name; say $t1 === $t2

[12:59] <camelia> rakudo-moar 2f5809: OUTPUT¬´Tap‚ê§False‚ê§¬ª

[12:59] <masak> seems you can already.

[13:00] <jnthn> Yeah, it's not any real protection.

[13:01] <lizmat> so ok if I take it out of the role ?

[13:02] <jnthn> yeah, I guess it won't cause any problems...

[13:02] <lizmat> ok, will check if it regresses anything

[13:08] *** Vlavv joined
[13:12] <dalek> rakudo/nom: 071ee1a | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[13:12] <dalek> rakudo/nom: Move Tap class out of Supply role

[13:12] <dalek> rakudo/nom: 

[13:12] <dalek> rakudo/nom: Mainly so that we can easily check for Tappiness of a tap

[13:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/071ee1a919

[13:12] <lizmat> no regresssions

[13:15] <lizmat> jnthn: is there any reason why you didn't implement act as:

[13:16] <lizmat> self.tap(&actor,|%_)

[13:16] <lizmat> ?

[13:16] <lizmat> why the do, when the "more" on the tap would work just as well ?

[13:17] <lizmat> and we wouldn't need a moreless tap anymore then

[13:18] *** thou joined
[13:20] <jnthn> lizmat: act promises actor semantics

[13:20] <jnthn> lizmat: That is, you can be sure that you are only running the tap callback one at a time.

[13:20] <lizmat> ah, and more doesn't

[13:21] <[Coke]> still 2 segfaults in rakudo.moar spectests today (haven't pushed today's results yet)

[13:21] <jnthn> lizmat: The things you pass in .tap can run on many threads potentially

[13:21] <[Coke]> still 1 rakudo.parrot failure.

[13:22] *** jnap joined
[13:22] *** thou left
[13:23] <lizmat> gotcha

[13:26] *** jnap left
[13:27] <lizmat> jnthn: the only reason for the "moreless" tap, was act, right?

[13:28] <jnthn> lizmat: Yeah, though we may want a .wait() too

[13:29] <lizmat> as in Supply.wait ?

[13:29] <jnthn> Right

[13:29] <lizmat> what would that do?

[13:29] <jnthn> When you want to wait until a supply is done

[13:29] <lizmat> ah, ok

[13:29] <jnthn> Block until done or quit happens.

[13:29] <jnthn> It's sometimes useful, when you primarily want to tap a supply for its side-effects

[13:29] <lizmat> ack, will spec and implement and test  :-)

[13:30] <jnthn> though tbh I've used it mostly in demonstrations more than real code

[13:30] *** Alula_ left
[13:30] <lizmat> well, I guess the same goes for await()  :-)

[13:30] *** virtualsue joined
[13:32] <jnthn> No, await is nice in real things :)

[13:32] <timotimo> aye

[13:32] <jnthn> Though we probably want to teach it to return the thread to the scheduler.

[13:32] <jnthn> ala C#'s await

[13:33] <jnthn> I almost made that happen once, but our continuations on JVM still hit too many barriers

[13:33] <jnthn> Probably can do it on Moar

[13:35] <dalek> rakudo/nom: 0a4dad0 | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[13:35] <dalek> rakudo/nom: Leave some comments for future optimizers

[13:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0a4dad0a73

[13:36] *** virtualsue left
[13:36] *** virtualsue joined
[13:40] *** bluescreen10 joined
[13:43] *** rurban joined
[13:43] *** darutoko- left
[13:44] *** Alula_ joined
[13:49] <dalek> roast: 9c839e2 | (Elizabeth Mattijsen)++ | S17-supply/act.t:

[13:49] <dalek> roast: Add basic tests for Supply.tap

[13:49] <dalek> roast: review: https://github.com/perl6/roast/commit/9c839e25d2

[13:50] *** darutoko joined
[13:51] <lizmat> afk for a bit

[13:55] *** xinming_ left
[13:55] *** xinming_ joined
[13:59] *** PerlJam left
[13:59] *** thou joined
[14:00] *** Alula_ left
[14:00] *** Alina-malina left
[14:00] *** PerlJam joined
[14:00] *** Alula_ joined
[14:02] *** Alina-malina joined
[14:03] <dalek> Perlito: 1bf5467 | (Flavio S. Glock)++ | / (3 files):

[14:03] <dalek> Perlito: Perlito5 - string parser flags \E \L \U \Q (more)

[14:03] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/1bf5467798

[14:06] *** logie joined
[14:07] * masak notices, not for the first time, how often he fails to follow his own advice in http://strangelyconsistent.org/blog/theres-plurality-in-wrongness

[14:07] <masak> it's not even spelled out in that post. no wonder. :)

[14:07] <masak> "When testing that something fails, be sure to test for the *type* of failure."

[14:09] *** bluescreen100 joined
[14:12] *** bluescreen10 left
[14:15] *** Rounin left
[14:16] <moritz> that's why implemented typed exceptions :-)

[14:17] <masak> :)

[14:17] *** Rounin joined
[14:17] <masak> moritz++

[14:18] <masak> moritz: did you know that Python 2 went through a similar improvement?

[14:18] <masak> from strings to types.

[14:18] <moritz> masak: no, I didn't

[14:18] <masak> Python 3.x finally gets rid of the last vestiges of the string ways to throw exceptions.

[14:19] <moritz> $ git grep  throws_like|wc -l

[14:19] <moritz> 226

[14:19] <moritz> $ git grep 'class X::'|wc -l

[14:19] <moritz> 193

[14:20] *** donaldh left
[14:20] <moritz> the first one was in roast, the second in rakudo

[14:20] <moritz> seems like we're still a bit away from decent coverage here

[14:21] *** kurahaupo left
[14:22] <masak> the second insight, which jnthn++ taught me and which I haven't written a blog post about, is that exception objects are *objects*, representing the interesting state at the time of error, along with the interesting follow-up actions you can take from there (e.g. to fix it).

[14:22] <masak> slogan: "good exceptions tell you what to do next"

[14:22] <moritz> that's fine for high-level exceptions

[14:22] *** jnap joined
[14:23] <masak> right, my head is in application space ;)

[14:23] <moritz> for low-level exceptions like permissin denied", there simply is no good, universal perspective of what to do next

[14:24] <masak> no, those perspectives tend to emerge within a program, not inside the compiler or runtime.

[14:24] *** donaldh joined
[14:26] *** treehug88 joined
[14:27] *** jnap left
[14:29] *** xenoterracide joined
[14:31] *** jnap joined
[14:36] <dalek> Perlito: 96ad233 | (Flavio S. Glock)++ | / (3 files):

[14:36] <dalek> Perlito: Perlito5 - string parser flags \E \L \U \Q (more)

[14:36] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/96ad233e39

[14:38] *** bluescreen__ joined
[14:40] <moritz> masak: do you happen to remember that article on (weighted) dice rolling whose URL was floating around here a few times?

[14:41] *** bluescreen100 left
[14:46] <PerlJam> moritz: Are you talking about http://www.keithschwarz.com/darts-dice-coins/ ?

[14:46] *** plobsing joined
[14:48] <masak> that's the one. PerlJam++

[14:48] <vendethiel> shouldn't that improvement make perl6 really faster ?

[14:49] <moritz> PerlJam++

[14:49] <masak> vendethiel: Perl 6 is a specification, without any inherent speed.

[14:49] <vendethiel> -.-

[14:49] <vendethiel> rakudo.

[14:49] <masak> vendethiel: by "that improvement", do you mean the above-linked article?

[14:49] <masak> I don't believe weighted dice rolling is something that tends to be on hot paths... :)

[14:49] *** bluescreen__ left
[14:50] <jnthn> Only in .roll :P

[14:50] <masak> oh, does .roll still do weighted?

[14:50] <jnthn> No idea :)

[14:50] <vendethiel> masak: ah, that's right, there's no mention of that MoarVM commit here

[14:50] <masak> oh, that explains it.

[14:50] <vendethiel> no, I meant lazily allocate $/ and $!

[14:50] <masak> ah, yes.

[14:51] *** daniel-s joined
[14:56] <timotimo> i wonder if there's a similarly clever thing to make .pick more efficient when it has n > 1

[14:57] <moritz> timotimo: there are lots of things :-)

[14:57] <moritz> timotimo: assume you have M elements in the list

[14:57] <moritz> timotimo: if M >> n, it makes sense to do n separate pics, with a blacklist of already picked elements, and retry if you hit the blacklist

[14:58] <timotimo> oh

[14:58] <moritz> timotimo: if n is close to n, you can do a fisher-yates shuffle, and pick the first n elements

[14:58] <timotimo> ah, i was actually also thinking of bag semantics, but that can be done with a mapping from n to Bag.kxxv

[14:59] <jnthn> r: sub l () { 1, 2 }; my %a; my @z = (%a{'x'} = l, l); say @z.perl

[14:59] <camelia> rakudo-jvm 0a4dad: OUTPUT¬´(timeout)¬ª

[14:59] <camelia> ..rakudo-{parrot,moar} 0a4dad: OUTPUT¬´Array.new($((1, 2), (1, 2)))‚ê§¬ª

[14:59] <moritz> and inbetween, you can make a copy of the array; pick one, delete it, move the last element its place, repeat

[15:00] <lizmat> masak: fwiw, only scanning the article, I think that's how I implemented Baggy.roll and Baggy.pick

[15:00] <timotimo> that does sound pretty nice and should probably be done at some point :)

[15:01] <timotimo> #LHF

[15:01] *** pecastro left
[15:02] *** Alula_ left
[15:02] <jnthn> m: sub l () { 1, 2 }; my %a; say l.perl

[15:02] <camelia> rakudo-moar 0a4dad: OUTPUT¬´(1, 2)‚ê§¬ª

[15:02] *** pecastro joined
[15:02] <jnthn> m: sub l () { 1, 2 }; my %a; say (l, l).perl

[15:02] <camelia> rakudo-moar 0a4dad: OUTPUT¬´((1, 2), (1, 2))‚ê§¬ª

[15:02] <jnthn> m: sub l () { 1, 2 }; my %a; say (%a{'x'} = l, l).perl

[15:02] <camelia> rakudo-moar 0a4dad: OUTPUT¬´$((1, 2), (1, 2))‚ê§¬ª

[15:02] *** lvfjf joined
[15:04] <moritz> timotimo: actually, List.pick already uses Fisher-Yates

[15:04] <moritz> timotimo: and a lazy one at that :-)

[15:04] <timotimo> oh, very good

[15:04] <moritz> timotimo: so the only optimization might be to not clone the array if there's a small number of elements picked

[15:05] <timotimo> like a single one :)

[15:05] <moritz> timotimo: not sure if that's work it

[15:05] <moritz> maybe for really large lists

[15:05] <timotimo> already does that

[15:05] *** Alula_ joined
[15:06] <timotimo> return self.at_pos($elems.rand.floor) if $n == 1; - for list at least

[15:06] <PerlJam> Just read a brief discussion on #perl regarding threads and the usual mantra of "don't use threads" was, of course, uttered.   It is so nice to never have to say that for Perl 6.  :-)

[15:06] *** MilkmanDan left
[15:06] <timotimo> okay, all that stuff seems to have already seen a slight optimization pass some time in the past

[15:07] *** MilkmanDan joined
[15:07] <Ulti> if I get "Error while compiling op call: Iteration past end of iterator" whilst working with a Grammar.parse() any protips on golfing?

[15:08] <moritz> Ulti: run with --ll-exception, and nopaste the backtrace somewhere

[15:08] <timotimo> that usually happens inside the QAST/Operations.nqp of nqp

[15:10] * moritz detects lighting and thunder, and disconnects his laptop from the power cord

[15:10] <moritz> Battery 0: Discharging, 99%, 03:41:34 remaining

[15:11] <moritz> that should suffice :-)

[15:11] *** igorsutton left
[15:11] <Ulti> http://pastebin.com/6f7eeCZq

[15:12] <Ulti> code: https://gist.github.com/MattOates/0a0dac1fd96377da2c35

[15:12] *** average joined
[15:12] <Ulti> though a much simpler version with just the grammar and .parse had the same problem

[15:12] *** igorsutton joined
[15:12] <Ulti> slurp is all ok

[15:13] <Ulti> also perl6 version 2014.04-117-gc9f2239 built on MoarVM version 2014.04-29-ga109e8d

[15:15] <dalek> Perlito: 8dda686 | (Flavio S. Glock)++ | / (4 files):

[15:15] <dalek> Perlito: Perlito5 - string parser flags \E \L \U \Q (more)

[15:15] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/8dda686c1e

[15:16] <PerlJam> Ulti: What are all of those other letters for in dna/rna?

[15:16] <Ulti> various confusion sets

[15:16] <timotimo> bon marcher

[15:16] <timotimo> er.

[15:16] <Ulti> where you aren't sure which of two nucleotides it is

[15:16] *** igorsutton left
[15:17] <Ulti> or they have some modification

[15:17] <masak> lizmat: oh -- didn't know that, but very happy to hear it. lizmat++

[15:17] <Ulti> like you are talking about weird functionalised short bits of RNA or DNA

[15:18] <Ulti> PerlJam: if you are super interested http://en.wikipedia.org/wiki/FASTA_format#Sequence_representation

[15:18] <masak> Ulti: so, basically, any() semantics. :)

[15:18] <Ulti> yeah

[15:18] <masak> or one(), I guess.

[15:20] <moritz> Ulti: now that I'm looking at the backtrace, I have no clue. Sorry :(

[15:20] <Ulti> heh yeah

[15:21] <Ulti> I'll try something insanely simple like a trivial grammar

[15:21] <masak> pro tip: develop grammars using TDD. you'll thank yourself.

[15:22] * vendethiel is on an unity project and did not find the "tests" button

[15:22] <timotimo> m: for <1 2 3> Z <a b c> -> $a Z $b { say "$a $b" }; # this could do with a better error message, IMO.

[15:22] <camelia> rakudo-moar 0a4dad: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/lDELijvTtk‚ê§Missing block‚ê§at /tmp/lDELijvTtk:1‚ê§------> [32mfor <1 2 3> Z <a b c> -> $a [33m‚èè[31mZ $b { say "$a $b" }; # this could do wi[0m‚ê§    expecting any of:‚ê§        postfix‚ê§   ‚Ä¶¬ª

[15:23] <timotimo> m: for <1 2> Z <a b> -> $a Z $b { $a ~ $b }

[15:23] <camelia> rakudo-moar 0a4dad: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/lgqoxfTObL‚ê§Missing block‚ê§at /tmp/lgqoxfTObL:1‚ê§------> [32mfor <1 2> Z <a b> -> $a [33m‚èè[31mZ $b { $a ~ $b }[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§       ‚Ä¶¬ª

[15:23] <TimToady> why are you putting an operator into a signature?

[15:24] <PerlJam> TimToady: that would be the better error message  ;)

[15:24] <TimToady> well, unrecognized capitalized words in a sig are much likelier to be types

[15:26] <TimToady> if it's a rare enough failure mode, it's not worth the dwim, and it does, in fact, point at exactly where the problem was

[15:26] <TimToady> perhaps it could see that a { is nearby, and say "Unrecognized stuff before the {" or some such

[15:27] <TimToady> or maybe "Missing block or malformed signarue"

[15:27] <TimToady> s/ru/tur/

[15:28] <TimToady> we also don't know that they didn't intend => $a

[15:28] *** Alula_ left
[15:28] <TimToady> or suppose they said $a X $b, and really meant $a, X $b

[15:28] *** Alula_ joined
[15:29] <TimToady> sometimes better messages aren't better

[15:29] <PerlJam> "malformed signature" seems like it would have provided a little more cognitive push in a useful direction.

[15:30] *** MilkmanDan left
[15:31] <dalek> roast: c9dced7 | (Elizabeth Mattijsen)++ | S02-names/is_cached.t:

[15:31] <dalek> roast: Add test for "is cached" on proto

[15:31] <dalek> roast: 

[15:31] <dalek> roast: with --optimize=0, all is ok.  With any other setting, the proto is taken out

[15:31] <dalek> roast: and two tests fail.

[15:31] <dalek> roast: review: https://github.com/perl6/roast/commit/c9dced71fe

[15:31] *** MilkmanDan joined
[15:32] *** zakharyas left
[15:33] *** plobsing left
[15:36] <PerlJam> Ulti: I did a couple of quick tests and the iterator error only seems to appear when I have <-[ ]>+ as the pattern for id.  change that to \S+ and it doesn't generate that error anymore.

[15:38] *** beastd joined
[15:38] <Ulti> I have a flip between working and not working when I move from "grammar TRIVIAL { rule TOP {<[A..Z]>+} }" to "grammar TRIVIAL { rule TOP { <line>* } token line {<[A..Z]>+} }"

[15:39] <Ulti> this is with something super simple

[15:39] <Ulti> lines of random capital letters 

[15:39] <Ulti> and just the code for that grammar and a slurp and TRIVIAL.parse

[15:40] <Ulti> so unless what I've done with that rule/token is super weird there is some bug outside of my code

[15:40] <TimToady> where do you eat the \n?

[15:40] <Ulti> I don't, but I get the same thing if I tell "line" to eat the \n

[15:40] <Ulti> as in put it inside the character class

[15:40] <Ulti> <[A..Z\n]>

[15:41] <Ulti> is that wrong?

[15:41] <TimToady> well, the * on <line> is a difference

[15:41] *** isBEKaml joined
[15:41] *** bjz left
[15:41] <TimToady> if you put \n in the cclass it will eat the whole file

[15:41] <Ulti> yeah

[15:42] <Ulti> at the moment I dont really care what is matched... I just dont want a failed to compile OP

[15:42] <TimToady> what's the error message?

[15:42] <Ulti> Error while compiling op call: Iteration past end of iterator

[15:42] <TimToady> cool!

[15:43] <Ulti> yeah I thought the point of iterators is they dont iterate past the end of where you can iterate :3

[15:43] *** raiph joined
[15:43] *** dmol joined
[15:43] <TimToady> maybe someone here remmebers working in the neighborhood of that error message lately

[15:44] <Ulti> yeah I did `rakudobrew build moar` about half an hour ago

[15:44] <lizmat> FROGGS has been working in that area, no?  trying to get labels in?

[15:44] <PerlJam> yeah, but aren't his changes on a branch?

[15:44] <TimToady> or maybe lack-of-progress checking in regex?

[15:45] <PerlJam> Ulti: have you tried it on rakudo-jvm?

[15:45] <PerlJam> (or parrot?)

[15:45] <TimToady> .parse is supposed to enforce a complete match; maybe there's an extra \n at the end?

[15:46] <Ulti> PerlJam: it might not generate the error with the \S+ but it also goes utterly crazy

[15:46] <Ulti> also \S+ isn't what I want the format specifically is a ' ' not any white space :S

[15:46] <Ulti> PerlJam: nope

[15:47] <TimToady> you can't match not-space with <-[ ]> because ws is insigificant inside cclasses

[15:47] <Ulti> :(

[15:48] <PerlJam> Ulti: I think you can use <-space>

[15:48] <TimToady> m: $_ = "foo"; say ~/\X20/

[15:48] <PerlJam> <space> matches a literal space char, no/

[15:48] <camelia> rakudo-moar 0a4dad: OUTPUT¬´‚ê§¬ª

[15:48] <PerlJam> ?

[15:48] <TimToady> n: $_ = "foo"; say ~/\X20/

[15:48] <camelia> niecza v24-109-g48a8de3: OUTPUT¬´Regex()<instance>‚ê§¬ª

[15:48] <moritz> <-[\ ]>

[15:49] <TimToady> <-[\x20]>

[15:49] <PerlJam> tmtowtdi!  :)

[15:49] <TimToady> m: $_ = "foo"; say ~/<-[\ ]>/

[15:49] <camelia> rakudo-moar 0a4dad: OUTPUT¬´‚ê§¬ª

[15:49] <TimToady> m: $_ = "foo"; say ~m/<-[\ ]>/

[15:49] <camelia> rakudo-moar 0a4dad: OUTPUT¬´f‚ê§¬ª

[15:50] <TimToady> m: $_ = "foo"; say ~m/\X20/

[15:50] <camelia> rakudo-moar 0a4dad: OUTPUT¬´f‚ê§¬ª

[15:51] <dalek> rakudo/nom: aa19f5c | (Elizabeth Mattijsen)++ | t/spectest.data:

[15:51] <dalek> rakudo/nom: Make sure we test Supply.act

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa19f5c635

[15:52] <jnthn> "Iteration past end" things are normally due to something in NQP expecting an array to have a certain multiplicity of elements, and it failing to do so.

[15:52] *** Ven left
[15:52] *** ponbiki joined
[15:53] <PerlJam> so ... what does <-[ ]>  mean exactly?  Match any character that's not in the empty set?

[15:54] <PerlJam> Seems like that would be an easy target for an appropriately helpful error message.

[15:58] <FROGGS> PerlJam: my stuff is in a branch, aye

[16:07] <japhb> I just wandered around the search results for 'use NativeCall' in Perl code on GitHub.  There's some cool stuff in there.  :-)

[16:10] <japhb> avuserow: Do you mind if I use a snippet of your perl6-compress-snappy code as a NativeCall example in my talk-in-progress?

[16:14] <japhb> BTW, one thing I'm noticing in all this NativeCall-using code I'm looking through is that people have reinvented a sub to figure out the correct lib name to use in the 'is native()' trait on multiple platforms over and over and over.  This seems to be something NativeCall could just provide, at least for the relatively common cases.

[16:15] <FROGGS> it should at least provide a proper hook

[16:15] <FROGGS> or patterns or so

[16:19] <japhb> Is { ... } or {*} the current idiom for native routines?

[16:19] <FROGGS> the Whatever I think

[16:19] <jnthn> The whatever.

[16:20] <FROGGS> because that is like what the default proto is, ... is stub code

[16:20] *** dwarring left
[16:20] <FROGGS> and it is more like "yeah, dispath as you want" rather than "ohh dang, stub code /o\"

[16:21] <dalek> specs: c2543da | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[16:21] <dalek> specs: Spec Supply.wait

[16:21] <dalek> specs: review: https://github.com/perl6/specs/commit/c2543da57c

[16:23] <dalek> rakudo/nom: ac169ca | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[16:23] <dalek> rakudo/nom: Naive implementation of Supply.wait

[16:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac169ca2ca

[16:23] *** pecastro left
[16:26] <japhb> FROGGS, jnthn: I was hoping that was the right answer.  :-)

[16:26] <FROGGS> good :o)

[16:34] *** hoverboard joined
[16:36] * jnthn just taught the inliner to generate simpler code when it can see the args to the thing being inlined are used just once in inline target.

[16:38] <FROGGS> coool!

[16:38] <jnthn> Still spectesting, but https://gist.github.com/jnthn/7d2421d4e3e77b7570b5 is nice.

[16:38] <FROGGS> ohh

[16:38] <FROGGS> :o)

[16:38] <nwc10> interesting.

[16:39] <vendethiel> oh wow :-)

[16:39] <jnthn> It's just one benchmark. :)

[16:39] <jnthn> loop_empty_native from perl6-bench, of note

[16:40] <nwc10> sure, but it's the first one I've seen where interpreted Perl 6 has out-done interpreted Perl 5

[16:40] <jnthn> Same.

[16:40] <jnthn> Also, the code still ain't that great.

[16:41] <nwc10> also, I stress, "interpreted"

[16:41] <nwc10> in that, likely someone will say "but $other is faster, but their $other involves a JIT"

[16:41] <nwc10> er,

[16:41] <nwc10> in that, likely someone will say "but $other is faster", but their $other involves a JIT. Which isn't a fair race.

[16:42] <nwc10> but, of course, the way to beat the JIT is to do less work, so that the relative JIT startup cost hurts

[16:42] *** xenoterracide left
[16:42] <nwc10> (ie, the antithesis of PyPy benchmarks)

[16:42] *** xenoterracide_ joined
[16:42] <nwc10> jnthn: your new thing is cross-backend, or Moar only?

[16:43] <jnthn> cross-backend

[16:43] <timotimo> the benchmark is already done, huh.

[16:43] <dalek> nqp: 80e52eb | jnthn++ | src/QAST/ (11 files):

[16:43] <dalek> nqp: Add a way to count arg placeholder usages.

[16:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/80e52eb595

[16:44] <jnthn> timotimo: I guess you were just running a Moar one?

[16:46] <FROGGS> I stil have the dream that stage parse drops to like 20s... I wonder if we get there this year

[16:49] <jnthn> There's a good chance, what with spesh coming along, JIT, etc.

[16:49] <dalek> roast: 2b2646a | (Elizabeth Mattijsen)++ | S17-supply/wait.t:

[16:49] <dalek> roast: Add simple tests for Supply.wait

[16:49] <dalek> roast: review: https://github.com/perl6/roast/commit/2b2646a133

[16:49] <nwc10> we can have a pony? Er, racehorse? Er, racing camel?

[16:52] <nwc10> is that a standard benchmark in the suite? Would be interesting to see it across all 3 backends, and for different iterations on the JVM

[16:53] <dalek> nqp: a232e9a | jnthn++ | tools/build/MOAR_REVISION:

[16:53] <dalek> nqp: Get a MoarVM with lazy lexical alloc opt.

[16:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a232e9ab3f

[16:55] <jnthn> nwc10: The one I just did, or what FROGGS is asking about?

[16:56] <dalek> rakudo/nom: 270aec7 | jnthn++ | / (2 files):

[16:56] <dalek> rakudo/nom: Generate better code in some cases if inlining.

[16:56] <dalek> rakudo/nom: 

[16:56] <dalek> rakudo/nom: If the argument is only ever used once, no need to assign it to a

[16:56] <dalek> rakudo/nom: temporary. Also bumps NQP_REVISION to get needed QAST improvement.

[16:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/270aec7053

[16:56] <nwc10> your loop where MoarVM beats your Perl 5

[16:56] <jnthn> nwc10: oh, yeah, that's in there

[17:02] *** rurban left
[17:06] *** hoverboard left
[17:09] <dalek> rakudo/nom: 8ddb1e7 | (Elizabeth Mattijsen)++ | t/spectest.data:

[17:09] <dalek> rakudo/nom: Make sure we test Supply.wait

[17:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8ddb1e72d3

[17:15] *** LLamaRider joined
[17:15] <[Coke]>  jnthn++

[17:15] * [Coke] wonders if we should go through --optimize levels and run the spec test suite and see what breaks.

[17:15] <[Coke]> (for each level/backend combo)

[17:16] <[Coke]> (ratcheting up the default level as they test clean?)

[17:19] <lizmat> before these last changes:

[17:19] <lizmat> Files=834, Tests=31809, 225 wallclock secs ( 8.88 usr  4.12 sys + 1430.82 cusr 150.27 csys = 1594.09 CPU)

[17:19] <lizmat> after these changes:

[17:19] <lizmat> Files=834, Tests=31812, 212 wallclock secs ( 8.37 usr  3.94 sys + 1350.15 cusr 145.75 csys = 1508.21 CPU)

[17:19] <moritz> m: say (225 - 212) / 225

[17:19] <camelia> rakudo-moar aa19f5: OUTPUT¬´0.057778‚ê§¬ª

[17:20] *** LLamaRider left
[17:20] <lizmat> m: say (1594 - 1508) / 1594

[17:20] <camelia> rakudo-moar aa19f5: OUTPUT¬´0.053952‚ê§¬ª

[17:20] <lizmat> pretty consistent wallclock / CPU savings

[17:21] <lizmat> too bad we've gone from ~180 wallclock a few weeks ago to 210

[17:21] <lizmat> although there were quite some tests added

[17:21] <lizmat> I don't think they account for the difference

[17:22] *** LLamaRider joined
[17:24] <lizmat> fwiw, I'm not seeing such a good test on OSX:

[17:24] <lizmat> $ time perl6 --optimize=3 -e 'loop (my int $i = 1; $i <= 100000000; $i = $i + 1) { }'

[17:24] <lizmat> real	0m11.508s

[17:24] <lizmat> user	0m11.459s

[17:24] <lizmat> $ time perl  -e 'use integer; for (my $i = 1; $i <= 100000000; $i = $i + 1) { }'

[17:24] <lizmat> real	0m5.788s

[17:24] <lizmat> user	0m5.784s

[17:25] <lizmat> so on my machine, Perl 5 is still twice as fast :-(

[17:25] *** REPLeffect joined
[17:26] <nwc10> lizmat: figure out how to do dead code elimination in NQP. At which point, Rakudo will be faster :-)

[17:27] <nwc10> can NQP constant fold yet?

[17:29] <FROGGS> jnthn: doing the label checks in nqp::handle does not work too well...

[17:29] *** isBEKaml left
[17:30] <FROGGS> jnthn: because it means that I'd need to throw/rethrow in case we try to run the handler of the wrong label

[17:30] *** guru joined
[17:30] <FROGGS> jnthn: and rethrowing somedoes not work... it rethrows to itself

[17:30] *** guru is now known as ajr_

[17:30] <FROGGS> and its stops after eight times

[17:31] <jnthn> lizmat: Well, probably compiler differences.

[17:32] <lizmat> perhaps  :-(

[17:32] <jnthn> lizmat: Things in my Linux VMs are always a LOT slower than my native Windows builds.

[17:32] <jnthn> I wonder what optimization level we're using today.

[17:35] <jnthn> 'cus at one point (maybe still true) we didn't build with -O3 or even -O2 

[17:35] <jnthn> While MSVC has all the opts turned on.

[17:37] <lizmat> clang -fno-omit-frame-pointer -fno-optimize-sibling-calls -O1 -DNDEBUG  -D_DARWIN_USE_64_BIT_INODE=1 

[17:37] *** hoverboard joined
[17:37] <jnthn> -DNDEBUG won't be helping any either.

[17:38] * jnthn wonders what happens if that is bumped to -O2

[17:38] *** atta joined
[17:38] * lizmat tries

[17:43] *** lvfjf left
[17:44] *** lvfjf joined
[17:46] <nwc10> no, -DNDEBUG helps. That disables assertions.

[17:47] <nwc10> jnthn: HEAD/HEAD/HEAD works on "my" machine, still.

[17:47] *** pecastro joined
[17:48] <nwc10> and if -O2 breaks, try -O2 -fno-strict-aliasing

[17:48] <jnthn> oh...duh :)

[17:48] <nwc10> and be unhapy that we are still using something not entirely unlike C

[17:49] <nwc10> I can't remember if there was an actual usable tool, or just a paper about hacking clang to figure out what code is "dead" due to optimisations, but changes behaviour

[17:49] <nwc10> ie, undefined behaviour you should fix

[17:52] <jnthn> nqp: say(9 +> 3)

[17:52] <camelia> nqp-parrot: OUTPUT¬´Confused at line 2, near "say(9 +> 3"‚ê§current instr.: 'panic' pc 15634 (gen/parrot/stage2/NQPHLL.pir:5739) (gen/parrot/stage2/NQPHLL.nqp:425)‚ê§¬ª

[17:52] <camelia> ..nqp-moarvm: OUTPUT¬´Confused at line 2, near "say(9 +> 3"‚ê§   at gen/moar/stage2/NQPHLL.nqp:369  (/home/p6eval/rakudo-inst-1/languages/nqp/lib/NQPHLL.moarvm:panic:105)‚ê§ from gen/moar/stage2/NQP.nqp:917  (/home/p6eval/rakudo-inst-1/languages/nqp/lib/nqp.moarvm:comp_unit:346)‚ê§ fro‚Ä¶¬ª

[17:52] <camelia> ..nqp-jvm: OUTPUT¬´(timeout)#‚ê§# There is insufficient memory for the Java Runtime Environment to continue.‚ê§# pthread_getattr_np‚ê§# An error report file with more information is saved as:‚ê§# /home/p6eval/hs_err_pid4249.log‚ê§[thread 140456514119424 also had an error]‚ê§¬ª

[17:52] <jnthn> nqp: say(nqp::bitshiftl_i(9, 3))

[17:52] <camelia> nqp-jvm: OUTPUT¬´#‚ê§# There is insufficient memory for the Java Runtime Environment to continue.‚ê§# pthread_getattr_np‚ê§# An error report file with more information is saved as:‚ê§# /home/p6eval/hs_err_pid4304.log‚ê§¬ª

[17:52] <camelia> ..nqp-{moarvm,parrot}: OUTPUT¬´72‚ê§¬ª

[17:55] <nwc10> jnthn: on "my" machine, perl 5 is 12.5s, perl6-m is 17

[17:55] <vendethiel> (I guess a leftshift *is* a memory-intensive operation, after all)

[17:55] <nwc10> thats /usr/local/bin/perl

[17:56] * nwc10 builds blead with the same compiler as MoarVM used

[18:00] *** lvfjf left
[18:00] *** lvfjf joined
[18:02] <nwc10> blead is twice as fast as perl6-m

[18:02] <nwc10> this week.

[18:02] *** rurban joined
[18:03] <nwc10> (Better compiler, and likely better runtime, as /usr/local/bin/perl is 5.12.something)

[18:03] <nwc10> no, not my machine.

[18:05] * itz goes to http://rakudo.org/downloads/star/

[18:05] <itz> :(

[18:05] <nwc10> well volunteered! :-)

[18:07] *** rurban left
[18:07] *** Entonian joined
[18:08] *** Rotwang left
[18:09] *** Entonian left
[18:15] *** hoverboard is now known as moistcherry

[18:19] <masak> m: grammar G { regex TOP { $<thing>=a? } }; say ?G.parse("")<thing>

[18:19] <camelia> rakudo-moar 270aec: OUTPUT¬´True‚ê§¬ª

[18:20] <masak> this just suprised me a lil' bit :)

[18:20] <masak> m: grammar G { regex TOP { $<thing>=a? } }; say ?G.parse("")<thing>.chars

[18:20] <camelia> rakudo-moar 270aec: OUTPUT¬´False‚ê§¬ª

[18:20] <masak> guess I can check it like that instead...

[18:21] <FROGGS> a match is a match, even when it successfully matched an empty string

[18:21] <masak> I'm not saying it's not *reasonable*, by the way. the quantifier did match.

[18:21] <masak> right.

[18:21] <masak> so I'm not clamoring for change here.

[18:21] <masak> just saying it's a possible gotcha.

[18:21] <FROGGS> but yeah, it is a little WAT

[18:22] <timotimo> http://t.h8.lv/p6bench/2014-05-01-vmnull.html - interesting.

[18:25] <lizmat> nwc10 jnthn: so I hacked the Makefile s/O1/O2

[18:25] <lizmat> build and ran spectest: ok, and at 205/1455  (so less than before, but close to noiselevels)

[18:26] <lizmat> now I'm looking at a more reliable way of changing -O1 to -O2

[18:26] <lizmat> is there a parameter for that anywhere in Configure.pl?   

[18:26] <lizmat> or is it some template file I need to change?

[18:26] <lizmat> ^^ moritz ?

[18:26] <retupmoca> lizmat: I'm passing '--optimize=3' to moar's Configure.pl for -O3

[18:27] <retupmoca> gcc -O3 is looking clean as well so far, but I don't have any benchmark data points

[18:28] <lizmat> Unknown option: optimize

[18:28] <lizmat> guess I'm looking at the wrong Configure.pl

[18:28] <FROGGS> moar's configure.pl is that

[18:28] <retupmoca> I build moar/nqp/rakudo from separate checkouts, FWIW

[18:28] <FROGGS> me too

[18:29] <moritz> lizmat: are you talking about rakudo's optimize level? or that of the C compiler?

[18:29] <timotimo> seems like i need to get an even newer rakudo and test that

[18:29] <lizmat> C compiler

[18:29] <lizmat> I thought was the idea ?

[18:29] *** ivanshmakov left
[18:30] * lizmat is a noob developer who only uses --gen  :-)

[18:30] <moritz> lizmat: I think [Coke] was talking about rakudo's --optimize= levels

[18:30] <lizmat> ah, then we're miscommunicating  :-)

[18:31] <masak> I might've just discovered a new pattern. it's not earth-shattering, but it's nice.

[18:31] <masak> `if %h<prop> :delete { ... }`

[18:31] <masak> (only use when %h<prop> is guaranteed to only hold truthy values, I guess)

[18:32] <masak> oh wait.

[18:32] <lizmat> anything that booleanifies will do I guess

[18:32] <moritz> masak: you could say   if %h<prop> :delete :exists { ... }  otherwise

[18:32] <masak> moritz: yeah, just realized.

[18:32] <masak> this is verra nice.

[18:33] <lizmat> S02:2559

[18:33] <synopsebot> Link: http://perlcabal.org/syn/S02.html#line_2559

[18:33] <lizmat> I knew it would come in handy someday  :-)

[18:33] <masak> :)

[18:33] <moritz> lizmat++ # implementing it

[18:33] <masak> lizmat: yes, I remember it. it came in handy just now :)

[18:33] *** ivanshmakov joined
[18:34] <masak> lizmat: I remember discussing the semantics with you, too. but I forget which bit exactly.

[18:34] <lizmat> well, when I started looking at slice adverbs

[18:35] <lizmat> nobody had thougt (afaik) that you might want to do more than 1

[18:35] <lizmat> and nobody had thought about really using them as full blown adverbs

[18:35] <lizmat> e.g. :delete($really)

[18:35] <lizmat> would only delete if $really was true

[18:37] *** daxim left
[18:42] *** Timbus left
[18:46] <dalek> rakudo/nom: fd5f8eb | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[18:46] <dalek> rakudo/nom: We don't need a vow as we don't expose the Promise

[18:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd5f8eb530

[18:47] *** Timbus joined
[18:51] *** moistcherry is now known as hoverboard

[18:51] *** btyler joined
[18:52] *** daxim joined
[18:59] *** hoverboard is now known as moistcherry

[19:01] *** Rotwang joined
[19:02] *** Rotwang left
[19:02] *** lvfjf_ joined
[19:04] *** rurban joined
[19:05] *** SamuraiJack left
[19:06] <timotimo> http://t.h8.lv/p6bench/2014-05-01-vmnull.html - update

[19:06] *** lvfjf left
[19:06] *** lvfjf_ is now known as lvfjf

[19:07] <lizmat> what happend in while/push/join?

[19:08] <lizmat> and rc-forest-fire?

[19:08] *** rurban left
[19:08] <vendethiel> rakudo moar faster than nqp moar ?!

[19:09] <timotimo> probably noise?

[19:09] <lizmat> ah, of course... nqp vs moar

[19:09] <lizmat> *phew*

[19:09] <timotimo> whoa.

[19:09] <lizmat> ?

[19:09] <vendethiel> lizmat: you can go back to doing non-production-ready stuff with perl6 now :P

[19:10] <lizmat> eh, why would I want to ?

[19:10] <vendethiel> that was a joke. doesn't matter, anyway

[19:11] * lizmat must be too autistic

[19:13] <moritz> auto[sic]

[19:13] <timotimo> vendethiel: were you referring to "it came in handy just now"?

[19:13] *** darutoko left
[19:15] <vendethiel> timotimo: no, I thought lizmat read those benchmarks as nqp vs perl5 vs rakudo

[19:19] <vendethiel> m: augment class Int { supersede method Bool { !!! } }

[19:19] <camelia> rakudo-moar 8ddb1e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/YT1QI8AzdA‚ê§augment not allowed without 'use MONKEY_TYPING'‚ê§at /tmp/YT1QI8AzdA:1‚ê§------> [32maugment class Int [33m‚èè[31m{ supersede method Bool { !!! } }[0m‚ê§    expecting any of:‚ê§    ‚Ä¶¬ª

[19:19] <vendethiel> m: use MONKEY_TYPING; augment class Int { supersede method Bool { !!! } }

[19:19] <camelia> rakudo-moar 8ddb1e: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/TXKRzShZIs‚ê§"supersede" not yet implemented. Sorry. ‚ê§at /tmp/TXKRzShZIs:1‚ê§------> [32mass Int { supersede method Bool { !!! } [33m‚èè[31m}[0m‚ê§    expecting any of:‚ê§        argument list‚Ä¶¬ª

[19:21] *** rindolf left
[19:21] <masak> lizmat: oh, right. I suggested the :delete($really) use case. now I remember :)

[19:22] <masak> lizmat: I think multiple adverbs had been thought about before, but not really used in practice. nor thought through to the end, like you did.

[19:22] <lizmat> hence the "afaik" in my remark  :-)

[19:23] <masak> I distinctly remember discussing combintations of :exists and :delete in a certain room at Bishops here in Malm√∂, with jnthn, while drinking a nice beer or other...

[19:23] <masak> combinations*

[19:25] <jnthn> Bishops. What would we do without it...

[19:26] <lizmat> either I had too much Bishops, or I wasn't there  :-)

[19:28] <jnthn> lizmat: Yes, it was the place with the huge selection of whisky.

[19:28] <vendethiel> `let $a;` is basically `temp $a; UNDO undefine $a;` ?

[19:29] <timotimo> http://t.h8.lv/p6bench/2014-05-01-vmnull.html - now with more perl5

[19:31] <vendethiel> what is happening with while_bind's nqp version ?

[19:32] <timotimo> bad accuracy + noise?

[19:32] <vendethiel> I suppose.

[19:32] <vendethiel> postwhile_nil_native goes crazy too

[19:33] <timotimo> yes

[19:34] *** moistcherry left
[19:34] <masak> vendethiel: not sure about 'undefine' (which doesn't exist in Perl 6, by the way). doesn't it set $a back to its previous value if any?

[19:34] <timotimo> jnthn: make it even faster, please :)

[19:34] <jnthn> :P

[19:34] *** dwarring joined
[19:35] <vendethiel> masak: S04 "causes $x to start with its current value. Use `undefine temp $x;` to get Perl5 ..."

[19:35] *** molaf_ joined
[19:35] <timotimo> i'm going to build 2014.04 benchmarks for the nqps now, too

[19:36] <vendethiel> S04:200

[19:36] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_200

[19:36] * vendethiel looked through github's interface, and it was painful

[19:38] *** molaf left
[19:40] *** kurahaupo joined
[19:40] <masak> m: my $x = 42; undefine $x; say $x

[19:40] <camelia> rakudo-moar fd5f8e: OUTPUT¬´(Any)‚ê§¬ª

[19:40] <masak> vendethiel: I stand corrected.

[19:41] <lizmat> m: my $x is default(42) = 17; undefine $x; say $x

[19:41] <camelia> rakudo-moar fd5f8e: OUTPUT¬´42‚ê§¬ª

[19:42] <lizmat> sub undefine(Mu \x) { x = Nil }

[19:42] <lizmat> undefine foo is the same as assigning Nil to foo

[19:42] <lizmat> I seem to remember a discussion on whether to deprecate undefine

[19:43] <lizmat> S32/Basics:74

[19:44] <lizmat> "In all cases, calling C<undefine> on a variable should place the object in the same state as if it was just declared."

[19:46] <timotimo> tadzik: you're being sloppy with your docs!

[19:46] *** rurban joined
[19:48] *** dlem joined
[19:50] *** igorsutton joined
[19:51] *** LLamaRider left
[19:51] *** rurban left
[19:52] *** moistcherry joined
[19:54] *** Vlavv left
[19:58] *** nebuchadnezzar left
[19:59] <lizmat> should unlink return True on attempting to unlink a non-existing file ?

[19:59] <lizmat> Perl 5 returns 0 in that case, rather than 1

[19:59] *** kurahaupo left
[20:00] *** lvfjf left
[20:00] *** lvfjf joined
[20:00] <dlem> \o/

[20:00] <dalek> perl6-roast-data: 97375a0 | coke++ | / (6 files):

[20:00] <dalek> perl6-roast-data: today (automated commit)

[20:00] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/97375a0043

[20:01] <dlem> I just read jnthn's "Reactive Programming in Perl 6". Exciting times :-)

[20:01] *** vaskozl joined
[20:02] <timotimo> yes

[20:02] <timotimo> quite

[20:03] <dlem> One detail which seems a bit non-intuitive to me is the use of "more" to feed a supply.

[20:04] <dlem> How about "feed"? Or even "sink", to go with "tap" ;-)

[20:04] <lizmat> feed and sink already have distinct (other) meanings in Perl 6

[20:04] <lizmat> feels to me that could cause confusion

[20:05] <dlem> OK. But "more"? I had to think about that one more than once before undertanding the meaning.

[20:05] <dlem> *understanding

[20:05] <vendethiel> ^agreed. same with "winner"

[20:06] <lizmat> as far as I'm concerned, the last word about "winner" hasn't been said yet

[20:06] <dlem> I also read "tap" as a verb, so "more" doesn't quite do it for me.

[20:06] <lizmat> as in the current spec, it is really of very limited use

[20:07] *** Vlavv joined
[20:07] <lizmat> .provide instead of .more ?

[20:08] <lee_> .push?

[20:08] <dlem> .put, which is *almost* .tap backwards ;-)

[20:09] <dlem> lizmat: What are the current meanings of feed and sink which would cause confusion?

[20:09] <btyler> sink context, and ==> feeds

[20:10] <btyler> which someone else will have to explain, I only know the words :)

[20:10] <lizmat> S06:1390

[20:10] <synopsebot> Link: http://perlcabal.org/syn/S06.html#line_1390

[20:11] <dlem> AFAIK "sink context" ~ "void context". Using .sink to feed a supply wouldn't confuse me, at least.

[20:11] <vendethiel> .oO( pat a supply ? )

[20:11] <dlem> vendethiel: He he, I thought about that one, too :-)

[20:11] <lizmat> vendethiel: I was actually thinking the same thing

[20:12] <dlem> If the current meaning of feed is ==>, then .feed to feed the supply wouldn't confuse me either.

[20:13] <dlem> Similar concepts, IIUC.

[20:13] <dlem> But .more? Come on! ;-)

[20:13] <lizmat> it is a bit much, :-)

[20:14] <dlem> :-)

[20:14] <lizmat> well, I for one am starting to like .pat for 2 reasons

[20:14] <jnthn> I'm not attached to "more", but coming up with a short name for it that doesn't clash with something else is...tricky. I had it as "next" at first, I think.

[20:14] <lizmat> it's the inverse of .tap

[20:14] <lizmat> and you're patting the Supply to be good, giving it something along the way  :-)

[20:15] <lizmat> and it's short

[20:15] <jnthn> If we end up calling it pat, I'm going to give a talk with a supply named $cow :P

[20:15] <dlem> jnthn: Nice! :-)

[20:15] <lizmat> the only danger I see is for dyslexics who would type .tap instead of .pat

[20:16] <jnthn> Well, the thing that makes it not-quite-inverse is that .tap lets you tap all 3 of the events (more/done/quit), not just more...

[20:16] <lizmat> but generally you would only be intersted in the "more" value

[20:16] <masak> I don't have a horse in this race, but let me just say that .pat seems a bit cute-today, and .more seems about a hundred times more explanatory.

[20:16] <lizmat> I mean, the done/quit are optional

[20:16] <dlem> jnthn: I understand it can't be easy. I just felt compelled to point out the one thing in your nice talk which stood out as counter-intuitive to me.

[20:16] <btyler> this is a pure peanut gallery comment, but some of these sound a bit cute to my taste

[20:17] <dlem> btyler: Yes, pat is too cute IMHO. But that's just me.

[20:18] <dlem> From the peanut gallery: How can it be that .feed would cause confusion? Or even .sink=

[20:18] *** kurahaupo joined
[20:18] <jnthn> lizmat: Yes, which is the one you don't have to explicitly mention most of the time...

[20:18] <dlem> s/=/?/

[20:20] <jnthn> dlem: There isn't a .feed anywhere at the moment, so it's a possible in my view, though it does feel a tad awkward in that ==> is known as the feed operator and it does something a bit different...

[20:21] <jnthn> dlem: Thing is that they're event names more than they're method names...

[20:21] <lizmat> OTH, maybe .push would be good as well ?

[20:21] <lizmat> Supply.push

[20:21] <lizmat> Channel.push?

[20:21] <dalek> Perlito: 269a157 | (Flavio S. Glock)++ | / (4 files):

[20:21] <dalek> Perlito: Perlito5 - js - delete() fix

[20:21] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/269a1578a7

[20:22] <lizmat> I mean, Channel.send is internally a nqp::push already  :-)

[20:22] <jnthn> push works in a way, it just feels odd at the other end

[20:23] <lizmat> well, that is what Channels / Supplies different

[20:23] <lizmat> the receiving end is different, one could argue

[20:23] <lizmat> the other end is basically always pushing a value

[20:23] <dlem> jnthn: Hmm.. I just thought that you can "feed" the supply in one end and "tap" it on the other end.

[20:24] <lizmat> I mean, we already can coerce a Supply to a Channel

[20:25] <dlem> jnthn: Surely there is something I don't quite get, since that seems so obvious to me. I mentioned "sink" half jokingly, since I also associate that with a kitchen sink and tap :-)

[20:25] <lizmat> not yet the other way around (well, I guess you can't without the running the risk of losing stuff if there is another thread receiving)

[20:25] <lee_> it also seems a bit like pub/sub redis functions

[20:26] <dalek> Perlito: c350706 | (Flavio S. Glock)++ | / (3 files):

[20:26] <dalek> Perlito: Perlito5 - parser - use delete()

[20:26] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/c350706845

[20:26] <lizmat> I seem to recall Subscribable is what jnthn originally had

[20:26] <lizmat> which was not really fine with TimToady 

[20:29] *** nebuchadnezzar joined
[20:30] <dlem> In any case, great work jnthn++, lizmat++, others++

[20:31] *** virtualsue left
[20:32] <dlem> It really is exciting to see how Perl 6 is developing.

[20:32] <lizmat> I agree  :-)

[20:32] <jnthn> I didn't expect Subscribable to survive. In fact, I didn't want it to. :)

[20:33] <masak> jnthn: oh? what do you expect to take its place?

[20:34] <jnthn> masak: Supply already did take its place. :)

[20:34] <jnthn> masak: To be clear, I didn't expect my initial name to stick. :)

[20:34] *** treehug88 left
[20:34] <jnthn> masak: Which is fine; I was more interested in the semantics sticking ;)

[20:34] <dalek> rakudo/nom: 1775172 | jnthn++ | src/Perl6/Optimizer.nqp:

[20:34] <dalek> rakudo/nom: Various return typecheck/decont optimizations.

[20:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/17751728af

[20:35] *** treehug88 joined
[20:35] <masak> *nod*

[20:35] *** cogno joined
[20:35] * masak .oO( no big supplies when it changed its name... )

[20:36] *** cogno is now known as Guest84546

[20:36] * lizmat pulls and runs a spectest

[20:36] <timotimo> http://t.h8.lv/p6bench/2014-05-01-vmnull.html - updated again

[20:36] *** grondilu left
[20:37] <timotimo> oh, now it's lacking a rakudo-moarvm to compare to

[20:39] *** dlem left
[20:41] <lizmat> Files=834, Tests=31812, 208 wallclock secs ( 8.06 usr  3.88 sys + 1294.51 cusr 143.09 csys = 1449.54 CPU)

[20:42] <lizmat> seems like a good improvement again  :-)

[20:43] <timotimo> oh, where'd that come from :)

[20:43] <timotimo> jnthn digs them out between his couch cushions

[20:44] *** Guest84546 left
[20:45] <jnthn> Just picking off some easy ones. I'm too tired/stupid today to work on tricky ones.

[20:45] *** zacts left
[20:45] <jnthn> Pondered what I want to do next with spesh while taking a walk earlier, though.

[20:45] *** igorsutton left
[20:46] *** dlem joined
[20:46] * dlem bids goodnight

[20:46] *** dlem left
[20:47] *** rurban joined
[20:50] *** grondilu joined
[20:50] <grondilu> failed to load library 'dynext/libperl6_ops_moar.so':

[20:50] <grondilu> http://paste.siduction.org/20140501204858

[20:51] *** rurban left
[20:52] <jnthn> grondilu: Without looking: did you update your moar, but not do a clean Rakudo build?

[20:55] *** treehug88 left
[20:56] *** lue left
[20:57] <grondilu> I did update rakudo and I thought that would update moar automatically.  I'll do it manually and I'll make clean

[20:59] *** lvfjf left
[20:59] *** lvfjf joined
[21:00] <timotimo> no, we only pull new revisions of moar and nqp in if you explicitly perl Configure.pl

[21:00] *** Alula_ left
[21:00] <grondilu> ok

[21:00] *** dayangkun left
[21:02] *** treehug88 joined
[21:05] *** treehug88 left
[21:09] *** lue joined
[21:10] <dalek> rakudo/nom: c07c5e3 | jnthn++ | src/Perl6/Optimizer.nqp:

[21:10] <dalek> rakudo/nom: Eliminate unrequired p6bool usages.

[21:10] <dalek> rakudo/nom: 

[21:10] <dalek> rakudo/nom: If we are putting it in a boolean context, but the thing it is going

[21:10] <dalek> rakudo/nom: to boolify is simply some native int already (for example, coming

[21:10] <dalek> rakudo/nom: from a comparison instruction), then just skip the whole p6bool

[21:10] <dalek> rakudo/nom: thing.

[21:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c07c5e3e1f

[21:10] *** igorsutton joined
[21:13] <timotimo> http://t.h8.lv/p6bench/2014-05-01-vmnull.html - updated with a rakudo-moar/2014.04

[21:14] <dalek> rakudo/nom: a8e4df9 | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[21:14] <dalek> rakudo/nom: Make tap die $_, rather than .die

[21:14] <dalek> rakudo/nom: 

[21:14] <dalek> rakudo/nom: Str.die dies on method not found.  If we want to allow .die, we need Any.die

[21:14] <dalek> rakudo/nom: as well I guess.

[21:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a8e4df9aa4

[21:14] <masak> lexical subs totally rule.

[21:14] <masak> just wrote this line:

[21:14] <lizmat> TimToady: would there be a reason not to have an Any.die that just { die self } ?

[21:15] <masak> my $marker = %branch_markers{$value} // try_to_find_it_the_hard_way;

[21:15] <lizmat> s/_/-/ ?

[21:15] *** kaare_ left
[21:15] <vendethiel> lizmat: "an object shouldn't be responsible of its own death !" :o)

[21:15] <masak> lizmat: for various reasons, in my own projects, I tend to go all-underscore.

[21:16] <lizmat> TimToady: having to write "die $_" seems so twentieth century  :-)

[21:17] *** dayangkun joined
[21:17] *** Alula_ joined
[21:18] <masak> lizmat: what you're describing is already spec'd and implemented. it's spelled Exception.throw

[21:18] <jnthn> masak: But doesn't exist on a string...

[21:18] <masak> well, don't throw strings!

[21:19] <masak> even Python already learned this! :P

[21:19] <lizmat> jnthn: writing tests for IO::Notification.watch_path

[21:19] <lizmat> are there really only 2 types of events?  Renamed and Changed ?

[21:20] <lizmat> FWIW, the Rename also seems to occur when a file is created

[21:20] <jnthn> lizmat: Welcome to the world of IO notifications, where nothing can be relied upon at all ever. :/

[21:21] <timotimo> :(

[21:21] <jnthn> lizmat: I can imagine rename happening if you watch a file that didn't exist...

[21:21] <jnthn> No idea if that's portably reliable though.

[21:21] * grondilu eventually compiled rakudo after Configure

[21:21] <lizmat> well, I'm watching the dir, when I create a file in there, I get a rename event on the filename I create

[21:23] * jnthn wonders if exposing the kind of event libuv thinks it is is even a good idea...

[21:24] <jnthn> lizmat: I'd write the tests to assume rather little.

[21:24] <lizmat> trying to  :-)

[21:24] <jnthn> lizmat: Like, "if we create/change the file, we get at least one notification of some kind"

[21:24] <jnthn> On windows it's certainly not safe to assume you'll get one notification per change.

[21:26] *** pippo left
[21:26] <lizmat> I see a Rename on opening and closing the file

[21:28] <jnthn> oh my...

[21:29] <timotimo> we should use something like stable for that

[21:29] <lizmat> opening an existing file, writing and then closing, gives a Changed event

[21:30] <lizmat> timotimo: stable was designed for just that  :-)

[21:30] <lizmat> fwiw, on OSX I don't see any events more than once

[21:30] <timotimo> just a "more special" stable to handle the crazyness that is file change notifications

[21:30] <jnthn> timotimo: That's .uniq with :expires ;)

[21:30] <timotimo> oh

[21:31] <timotimo> of course!

[21:31] *** jsn joined
[21:31] <lizmat> that's what I meant, duh  :-)

[21:32] <lizmat> ok, I have a basic framework for doing the watch_path test...

[21:33] <lizmat> will do that tomorrow after some shuteye&

[21:33] <timotimo> \o/

[21:33] <timotimo> gnite lizmat 

[21:33] <timotimo> good work these past few weeks!

[21:34] <dalek> rakudo/nom: 0ed6d8f | jnthn++ | src/Perl6/Optimizer.nqp:

[21:34] <dalek> rakudo/nom: Don't preserve $_ if we just killed it.

[21:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ed6d8f6e5

[21:34] <jnthn> OK, now the code-gen for at least one benchmark is much nicer. :)

[21:34] <average> about IO::Notifications , it can be implemented with the inotify API

[21:34] <jnthn> Here:

[21:34] <jnthn> timecmd perl -e "use integer; for (my $i = 1; $i <= 100000000; $i = $i + 1) { }"

[21:34] <jnthn> command took 0:0:7.00 (7.00s total)

[21:35] <jnthn> timecmd perl6-m --optimize=3 -e "loop (my int $i = 1; $i <= 100000000; $i = $i + 1) { }"

[21:35] <timotimo> seems like i should get one more benchmark done

[21:35] <jnthn> command took 0:0:2.95 (2.95s total)

[21:35] *** jsn is now known as jsn2

[21:35] <timotimo> wait

[21:35] <timotimo> it's faster?

[21:35] <timotimo> perl6 is actually faster than perl5 at something?

[21:35] <jnthn> On my box, at least :P

[21:36] <timotimo> i'm warming up my benchmarks :)

[21:36] <jnthn> All these opts should work out on JVM too, fwiw.

[21:36] <masak> 'night, #perl6

[21:36] <jnthn> average: On one particular platform, yes...

[21:37] <cognominal> jnthn, you optimized out the loop?  :)

[21:37] <jnthn> cognominal: No, just improved code-gen for loops - and many other things along the way.

[21:37] <average> jnthn: and  FindFirstChangeNotification / FileSystemWatcher on Windows http://stackoverflow.com/a/3517475/827519

[21:37] <timotimo> jnthn: i don't need to --gen-nqp=master --gen-moar=master, right?

[21:38] <average> jnthn: and fsevents on OSX https://developer.apple.com/library/mac/documentation/Darwin/Reference/FSEvents_Ref/Reference/reference.html

[21:38] <jnthn> average: Yeah, the issue is that we'll need to build our own abstraction layer if we want to use these. At the moment we're just using what libuv provides us portably, which is...rather limited :(

[21:40] *** rurban joined
[21:40] <jnthn> average: Building said abstraction layer, configure probes, etc. is some work. I'd be happy to see it done by anyone who fancies working on it; it's probably not going to get to the top of my list anytime soon.

[21:40] <timotimo> jnthn: would parrot also be benchmarked?

[21:40] <timotimo> er, benefit from the things?

[21:41] <jnthn> timotimo: perhaps, yeah.

[21:41] <jnthn> timotimo: JVM certainly will

[21:41] <jnthn> I get its JIT likes the improvements I just did.

[21:41] <jnthn> *bet

[21:42] <average> jnthn: ah ok

[21:42] <timotimo> :)

[21:42] <timotimo> i don't have benchmark results for rakudo from recently :\

[21:43] <btyler> just did some super casual repeats of those one-liners, p6 comes out slower here (2010 macbook pro, osx10.9): 7.5 seconds-ish for p5, 11.5 for p6 (both over 5 runs). 

[21:43] <timotimo> especially since i've gone to jvm 8

[21:43] <timotimo> oh, also i can't build any more on my computer because of the -Xmx800

[21:43] <timotimo> i have to set it up to 1000 again

[21:43] <btyler> but holy cow does --optimize=3 make a huge difference, without it p6 takes ~30 seconds

[21:44] *** raiph left
[21:46] *** jsn2 left
[21:48] *** kurahaupo left
[21:50] <timotimo> wow, it just worked with only 800mx

[21:53] <timotimo> no, it really didn't :(

[21:53] <timotimo>   (use of '_' as an identifier might not be supported in releases after Java SE 8)

[21:53] <timotimo> all over the place

[21:58] <segomos> _

[22:00] *** Alula_ left
[22:00] *** Alula_ joined
[22:10] *** grondilu left
[22:14] *** rurban left
[22:18] *** moistcherry left
[22:29] <Timbus> make -j3

[22:30] <Timbus> aa

[22:30] <Timbus> been a while since ive done that

[22:30] *** ajr_ left
[22:32] *** Alula_ left
[22:32] <timotimo> aye, it makes me pretty happy that we can just -j3 for the three backends

[22:33] <Timbus> lol, what i meant was i typed that into the chat by accident :>

[22:33] <timotimo> oh

[22:33] <timotimo> :D

[22:33] <Timbus> yes it's cool how that works though

[22:34] <timotimo> we have moritz++ to thank for that

[22:35] <timotimo> does somebody run a sobby instance i could use with a friend?

[22:35] *** telex left
[22:36] *** telex joined
[22:40] *** colomon left
[22:43] *** xenoterracide_ left
[22:47] <jnthn> m: say 18.14 / 19.67

[22:47] <camelia> rakudo-moar fd5f8e: OUTPUT¬´0.922217‚ê§¬ª

[22:47] *** Alula_ joined
[22:48] *** spider-mario left
[22:52] *** colomon joined
[22:56] <dalek> rakudo/nom: 9991bb3 | jnthn++ | src/Perl6/Actions.nqp:

[22:56] <dalek> rakudo/nom: Can resolve Nil at compile-time, so do so.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9991bb30a3

[22:56] <dalek> rakudo/nom: 18b7e2e | jnthn++ | src/Perl6/Optimizer.nqp:

[22:56] <dalek> rakudo/nom: After inlining block, don't lex-capture the stub.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/18b7e2ea2d

[22:58] *** ponbiki left
[23:12] <jnthn> I'll get R* release worked out tomorrow

[23:14] <timotimo> \o/

[23:21] *** dmol left
[23:21] *** beastd left
[23:26] <timotimo> i wish i'd have thought of the nil opt :)

[23:27] *** lue left
[23:32] <jnthn> Time for some rest...'night o/

[23:36] <timotimo> gnite jnthn!

[23:40] *** lue joined
[23:42] *** pecastro left
[23:42] *** thou left
