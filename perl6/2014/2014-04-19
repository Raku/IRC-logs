[00:03] *** Mouq joined
[00:04] <lue> o/ Mouq (you missed me saying some things about that weird thing a short while ago)

[00:11] *** colomon joined
[00:15] <dalek> specs/pod6ify: f3a81da | lue++ | S22-package-format.pod6:

[00:15] <dalek> specs/pod6ify: [S22] Insert missing =end item

[00:15] <dalek> specs/pod6ify: review: https://github.com/perl6/specs/commit/f3a81da004

[00:15] <dalek> specs/pod6ify: 878ae54 | lue++ | S22-package-format-OLD.pod6:

[00:15] <dalek> specs/pod6ify: Pod6ify the old S22.

[00:15] <dalek> specs/pod6ify: review: https://github.com/perl6/specs/commit/878ae5445c

[00:20] *** ldthien0_ joined
[00:24] *** ldthien0_ left
[00:24] *** ldthien0_ joined
[00:33] *** ldthien0_ left
[00:39] <BenGoldberg> j: srand(42); my @o = 0x202D.chr, 0x202E.chr; print @o.pick, $_ for q[reJukcst aHA noetdhocinUer ].comb;

[00:39] <camelia> rakudo-jvm 22fbed: OUTPUT«‮r‮e‭J‭u‮k‮c‭s‭t‭ ‮a‮H‭A‮ ‭n‭o‮e‭t‮d‭h‮o‮c‮i‮n‮U‭e‭r‮ »

[00:39] <BenGoldberg> \o/ It works! :)

[00:41] *** Ben_Goldberg joined
[00:41] *** BenGoldberg left
[00:41] *** Ben_Goldberg is now known as BenGoldberg

[00:46] <BenGoldberg> What's the correct syntax for tr/// in perl6?  The following does not do what a perl5 programmer would expect it to do:

[00:46] <BenGoldberg> j: my $a = ('A'..'Z','_').join(''); $a ~~ tr[CDGHILNOQSYZ_XWVUTRPMKJFEBA][Just Another Unicode Hacker]; print "[$a]"

[00:46] <camelia> rakudo-jvm 22fbed: OUTPUT«[]»

[00:47] *** MikeFair_ joined
[00:47] <xenoterracide__> how is one supposed to tell by reading, whether Bar in class Foo is Bar, is a trait or a class?

[00:48] *** xenoterracide__ is now known as xenoterracide

[00:50] <Mouq> lue: Ok, I'll backlog

[00:51] <Mouq> xenoterracide: Watcha' mean?

[00:52] <Mouq> BenGoldberg: I'm not really sure that tr/// actually works.. :|

[00:52] <Mouq> my $a = ('A'..'Z','_').join(''); $a.=trans("CDGHILNOQSYZ_XWVUTRPMKJFEBA" => "Just Another Unicode Hacker)

[00:53] <Mouq> Oi, bad irc client

[00:53] <Mouq> j: my $a = ('A'..'Z','_').join(''); $a.=trans("CDGHILNOQSYZ_XWVUTRPMKJFEBA" => "Just Another Unicode Hacker"); say "[$a]"

[00:53] <camelia> rakudo-jvm 22fbed: OUTPUT«[reJukcst aHA noetdhocinUer ]␤»

[00:53] <BenGoldberg> Aha

[00:53] <Mouq> What you have is supposed to work, though

[00:56] <BenGoldberg> j: srand(42); my @o = 0x202D.chr, 0x202E.chr; print @o.pick, $_ for ('A'..'Z','_').join('').trans("CDGHILNOQSYZ_XWVUTRPMKJFEBA" => "Just Another Unicode Hacker").comb;

[00:56] <camelia> rakudo-jvm 22fbed: OUTPUT«‮r‮e‭J‭u‮k‮c‭s‭t‭ ‮a‮H‭A‮ ‭n‭o‮e‭t‮d‭h‮o‮c‮i‮n‮U‭e‭r‮ »

[00:56] <BenGoldberg> :)

[00:58] <Mouq> lue: Captures are a visual thing, or at least that's how I think of it. So (\N)+ fills up $0[0], $0[1], $0[2]. This is inherited from PCRE, and it's pretty useful in general imo

[01:00] <Mouq> That way in (\N)+ (\d) (;), you just count from left to right to get the group number

[01:03] * Mouq likes http://prog21.dadgum.com/194.html

[01:05] <xenoterracide> Mouq: think I found the doc where isa is just a trait... just seems confusing to use the same syntax for what seems like 2 different things

[01:05] <Mouq> Hmm

[01:05] <Mouq> std: class Foo isa Array { }

[01:05] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse class definition at /tmp/MoomceyH1H line 1:␤------> [32mclass Foo [33m⏏[31misa Array { }[0m␤    expecting trait␤Parse failed␤FAILED 00:01 120m␤»

[01:07] *** klapperl joined
[01:07] <xenoterracide> http://perlcabal.org/syn/S12.html#Single_inheritance < just referring to the sentence here

[01:08] <Mouq> xenoterracide: Oh, that wording may be bad

[01:08] <Mouq> m: say Set.^mro

[01:08] <camelia> rakudo-moar 22fbed: OUTPUT«(Set) (Any) (Mu)␤»

[01:08] <Mouq> m: say Set.^isa(Any)

[01:08] <camelia> rakudo-moar 22fbed: OUTPUT«1␤»

[01:08] <Mouq> m: say Set.isa(Any)

[01:08] <camelia> rakudo-moar 22fbed: OUTPUT«True␤»

[01:08] <Mouq> m: say Array.^mro

[01:08] <camelia> rakudo-moar 22fbed: OUTPUT«(Array) (List) (Iterable) (Cool) (Any) (Mu)␤»

[01:08] <Mouq> m: say Array.isa(List)

[01:08] <camelia> rakudo-moar 22fbed: OUTPUT«True␤»

[01:09] <xenoterracide> either way, moot point... I'm looking at using traits for a Java annotation like purpose

[01:09] <Mouq> "is" being a trait is the meaning of the construct itself, if that makes sense

[01:10] *** klapperl_ left
[01:10] <xenoterracide> either way, kinda wish that "is" didn't mean isa or extends, seems a bit overloaded

[01:10] <xenoterracide> imho

[01:11] <Mouq> xenoterracide: Well, we have '#=' and '#|' for annotations, not sure if that's what you mean

[01:11] <xenoterracide> but it is, what it is, pun sort of intended

[01:11] <xenoterracide> have what now?

[01:11] <xenoterracide> I've not heard of such a thing so I wouldn't know

[01:11] <xenoterracide> perhaps it's hwat I want

[01:11] <xenoterracide> what*

[01:12] <Mouq> xenoterracide: http://perlcabal.org/syn/S26.html#Declarator+blocks

[01:14] <xenoterracide> no not exactly, I'm referring to annotations like @Entity class Foo {}  in java

[01:14] <xenoterracide> they kind of serve as documentation but they're also used for introspection

[01:14] <Mouq> It looks like only #= works, though, and it works backwards :/

[01:17] <Mouq> xenoterracide: I mean.. You could use roles or custom traits? Is there a specific use for this?

[01:17] <xenoterracide> Mouq: I'm looking at possibly starting to bring the things I like from java ;)

[01:17] <xenoterracide> but it's likely to be slow

[01:19] <xenoterracide> basically I'm going to be working on my own enterprisey framework

[01:20] <xenoterracide> class Foo "notes" Entity "notes" Table name => "foo"

[01:20] <xenoterracide> maybe

[01:20] <Mouq> I still just don't understand :(

[01:21] * Mouq has avoided working with Java

[01:21] <xenoterracide> the "annotations" in java tell 3rd party libraries what to do with things on a class they don't know about

[01:21] <xenoterracide> java, and EE aren't the problem imho, the implementations are

[01:22] <xenoterracide> working with EE servers has been painful

[01:22] <xenoterracide> so you can have an EntityManager.persist( Object );

[01:22] <xenoterracide> it knows how to persist object by reading the annotations

[01:22] <xenoterracide> or that it can for that matter

[01:23] <xenoterracide> however the annotations do nothing for the class itself

[01:24] <Mouq> xenoterracide: Okay..

[01:24] <xenoterracide> might do something like has User notes Inject; and a Dependency injector would know to inject the User object it has into that attribute

[01:24] <xenoterracide> if any of that makes sense

[01:24] <xenoterracide> it's just metadata

[01:25] <Mouq> m: say (Array but role Inject {}).^roles

[01:25] <camelia> rakudo-moar 22fbed: OUTPUT«(Inject) (Positional)␤»

[01:25] <Mouq> m: say (Array but role Inject {}) ~~ Inject

[01:25] <camelia> rakudo-moar 22fbed: OUTPUT«True␤»

[01:26] <xenoterracide> what does but do?

[01:27] <Mouq> m: say (Array.^can('push') but role {#`(hmm…)})

[01:27] <camelia> rakudo-moar 22fbed: OUTPUT«push push␤»

[01:27] <xenoterracide> seems rather verbose though

[01:27] <Mouq> xenoterracide: Yeah

[01:28] <Mouq> xenoterracide: And that's not the way to do it either, I don't think

[01:30] <xenoterracide> possible I could make a grammar for doing this, but I might want to get the blessing of getting it included

[01:30] <xenoterracide> anyways, for now I'm mostly experimenting with how I'd want it to look, and funtionish

[01:31] *** FROGGS__ joined
[01:32] <xenoterracide> I'm kind of in a, every framework I've ever used has made me do more work to write simple things...

[01:32] <xenoterracide> maybe I can make one that makes Easy things Easy and hard things possible

[01:33] *** Sqirrel_ joined
[01:34] *** adu left
[01:34] *** FROGGS_ left
[01:34] *** Sqirrel left
[01:36] <Mouq> m: multi trait_mod:<notes> (Mu:U: $thing, :$table) { say $table<name> }; class Foo notes table(:name<foo>) { }

[01:36] <camelia> rakudo-moar 22fbed: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/FVTrpFiImu␤Unable to parse class definition␤at /tmp/FVTrpFiImu:1␤------> [32m$table) { say $table<name> }; class Foo [33m⏏[31mnotes table(:name<foo>) { }[0m␤    expecting any of:␤   …»

[01:36] <Mouq> Aww

[01:36] <Mouq> m: multi trait_mod:<notes> (Mu:U: $thing, :$table) { say $table<name> }; class Foo {}; Foo notes table(:name<foo>)

[01:36] <camelia> rakudo-moar 22fbed: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/BRNi66n_Wi␤Two terms in a row␤at /tmp/BRNi66n_Wi:1␤------> [32m{ say $table<name> }; class Foo {}; Foo [33m⏏[31mnotes table(:name<foo>)[0m␤    expecting any of:␤        postfix␤   …»

[01:36] <Mouq> std: multi trait_mod:<notes> (Mu:U: $thing, :$table) { say $table<name> }; class Foo {}; Foo notes table(:name<foo>)

[01:36] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/IB5vKyXRkd line 1:␤------> [32m{ say $table<name> }; class Foo {}; Foo [33m⏏[31mnotes table(:name<foo>)[0m␤    expecting any of:␤     feed_separator␤ infix or meta-infix␤    infixed function␤       …»

[01:37] <Mouq> std: multi trait_mod:<notes> (Mu:U: $thing, :$table) { say $table<name> }; class Foo notes table(:name<foo>) { }

[01:37] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse class definition at /tmp/0CMPEpmLNn line 1:␤------> [32m) { say $table<name> }; class Foo notes [33m⏏[31mtable(:name<foo>) { }[0m␤    expecting trait␤Other potential difficulties:␤  $thing is declared…»

[01:38] <Mouq> Looks like trait_mods are parser-defined and are any of is, hides, does, will, of, as, returns, or handles

[01:39] *** adu joined
[01:42] <xenoterracide> hmm

[01:42] <xenoterracide> I don't even know what half of those normally do

[02:00] <xenoterracide> what type is a class

[02:02] <Mouq> xenoterracide: Mu :P

[02:02] <Mouq> xenoterracide: You might want to look at it's HOW though

[02:02] <Mouq> m: say Any.HOW.WHAT

[02:03] <camelia> rakudo-moar 22fbed: OUTPUT«(Perl6::Metamodel::ClassHOW)␤»

[02:03] * Mouq has been extremely unproductive today

[02:05] <raiph> Mouq you ++d me earlier; did you read my quest?

[02:06] <raiph> (about commenting conventions on evalbot lines for mucho goodness)

[02:07] <Mouq> raiph: Yes, though I'd ++ you any day

[02:08] <lue> Mouq: I agree that it may make more sense (I seem to be bad at my initial reactions to unexpected spec behavior :P), but I know for sure that used to work the way I meant it to, and I recall a comment from TimToady once about using named subrules if you need that structure.

[02:09] <Mouq> Hm

[02:09] <Mouq> lue: Ok, in that case IDK

[02:09] <Mouq> :)

[02:18] <lue> Can't find it back, but it was in relation to me writing emacs-mode and discovering that P5 regexes in the case of (\N)+ would just keep writing $0 instead of $0, then $1, then $2, then...

[02:19] <lue> *p6-mode for emacs

[02:20] <lue> (TimToady said something along the lines of "if you need to know what the various $0 indices captured ahead of time (like you did with the P5 behavior), you should really used named subrules by that point.")

[02:25] <xenoterracide> :/

[02:25] <xenoterracide> can't seem to get the syntax right for putting another trait_mod on a class

[02:29] *** adu left
[02:30] <Mouq> xenoterracide: Is https://github.com/rakudo/rakudo/blob/nom/src/core/Routine.pm#L132 of any help? There's also https://github.com/rakudo/rakudo/blob/nom/src/core/traits.pm

[02:30] * Mouq is going for tonight o/ #perl6

[02:31] *** Mouq left
[02:31] <raiph> \o

[02:34] *** xragnar_ joined
[02:34] *** xragnar is now known as Guest92898

[02:34] *** Guest92898 left
[02:34] *** xragnar_ is now known as xragnar

[02:38] <raiph> "how is one supposed to tell by reading, whether Bar in class Foo is Bar, is a trait or a class?"

[02:39] *** kurahaupo left
[02:42] <raiph> xenoterracide: aiui a class can serve as a role and a trait is a kind of role

[02:43] <xenoterracide> (really want namespaces)

[02:44] <raiph> k

[02:45] <raiph> http://irclog.perlgeek.de/perl6/search/?nick=&q=namespace

[02:46] *** adu joined
[02:47] <raiph> xenoterracide: ^^ plenty of reading material!

[02:48] <xenoterracide> raiph: so far none of it seems to be relevant :D

[02:50] <xenoterracide> I just don't want to fully qualify things all the time

[02:59] <BenGoldberg> rn: print ('J,ursetk cAanHo tIhDeIrB /Pler'.comb.map({; ((state $ ) +^= True ?? 0x202d !! 0x202e).chr, $_ }));

[02:59] <camelia> niecza v24-109-g48a8de3: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1389 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 301 (Any.Numeric @ 8) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/tmpfile line…»

[02:59] <camelia> ..rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«‭J␀,‭u␀r‭s␀e‭t␀k‭ ␀c‭A␀a‭n␀H‭o␀ ‭t␀I‭h␀D‭e␀I‭r␀B‭ ␀/‭P␀l‭e␀r»

[03:01] <lue> xenoterracide: what are you qualifying, ooc?

[03:02] <xenoterracide> class names

[03:06] <lue> r: module Foo { class Bar { } }; say Foo::Bar;  # xenoterracide: like this?

[03:06] <xenoterracide> are attributes ro by default? 

[03:06] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«(Bar)␤»

[03:07] <xenoterracide> lue: yeah but if I then say have another file, and it has Foo::Bar $bar;

[03:07] <xenoterracide> sorry $.bar;

[03:07] <lue> yes, you need 'is rw' on the attribute (has $.foo is rw)

[03:08] <xenoterracide> there's afaik no way to write has Bar $.bar; to mean the same thing as has Foo::Bar $.bar;

[03:09] <xenoterracide> also if I have several large classes I don't want to put them in a single file

[03:09] <xenoterracide> basically I want behavior like module Foo { Bar {} } that works over several files

[03:10] <xenoterracide> so if I put module Foo; at the top of each file...

[03:10] <xenoterracide> they're all considered part  of that module

[03:10] <lue> If you attach 'is export' to that class definition, it'll be referenceable as just Bar. (doesn't work inline on camelia for some reason)

[03:11] <xenoterracide> right but I can't use the same module across files afaik, I was trying earlier didn't seem to work

[03:11] <xenoterracide> though I might have been doing something wrong

[03:15] <lue> xenoterracide: If you use the 'package' keyword instead of 'module' you can define package Foo { } across several files, just tried it and Rakudo deals with it fine :)

[03:18] <BenGoldberg> r: my @o = 0x202E.chr, 0x202D.chr; print @o[(state$ ) +^= 1], $_ for q[J,ursetk cAanHo tIhDeIrB /Pler].comb; # improved to run on all rakudo backends

[03:18] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«‭J‮,‭u‮r‭s‮e‭t‮k‭ ‮c‭A‮a‭n‮H‭o‮ ‭t‮I‭h‮D‭e‮I‭r‮B‭ ‮/‭P‮l‭e‮r»

[03:19] *** havenwood left
[03:20] *** adu left
[03:22] <xenoterracide> lue:  oh, I didn't realize that, I suppose you can export classes then?

[03:23] <lue> I just checked S11, and it seems the 'is export' trait is a feature of modules, so no :/  (Making modules definable across files involves some combination of MONKEY_TYPING, augment, and magic that I'm not at all familiar with)

[03:24] <xenoterracide> :/

[03:25] <xenoterracide> I think that what I want to do is not necessarily doable yet

[03:25] <xenoterracide> but it should be :/

[03:25] <lue> r: module Foo { our class Bar is export { } }; my \Bar = Foo::Bar; say Foo::Bar; say Bar;

[03:25] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«(Bar)␤(Bar)␤»

[03:25] <lue> ^ you can fake namespace aliasing this way, if you want

[03:26] <lue> (though some would argue that  'using namespace std;'  is an all-around terrible idea in the first place :P)

[03:26] <xenoterracide> that's all kinds of eww

[03:26] <xenoterracide> lue: not sure about the C++ variant but why?

[03:27] <lue> The point of namespaces is to prevent name conflicts, and some (like myself) think that that form of the using statement completely nullifies the point of namespaces.

[03:29] <lue> If not having the namespace in front is so important, you can either fake it with \Bar, 'is export' stuff in a module, or not wrap your stuff in a module or package in the first place, from what I gather.

[03:31] <xenoterracide> I use namespaces for more than just preventing conflict

[03:31] <xenoterracide> such as code organization

[03:33] <xenoterracide> perhaps just using packages willl make me happy

[03:33] <xenoterracide> enough

[03:33] <xenoterracide> though I don't like that I can't write package ... ; I suspect /that/ is because of p5

[03:33] <xenoterracide> and now that in p5 I can write package ... { }

[03:33] <xenoterracide> not sure that not allowing it helps at all

[03:35] <lue> Yeah, if you start the file with package foo; , it's to be read as Perl 5 code. Otherwise, it's seen as a perl5-o.

[03:35] <xenoterracide> perl5-o?

[03:38] <lue> perl5 thinko :)

[03:39] *** BenGoldberg left
[03:40] <xenoterracide> see... I just want to write something like this http://privatepaste.com/72bb084044

[03:41] <xenoterracide> the package is not so much about "using namespace" as not having to run around importing things and fully qualifying them within the same namespace

[03:44] <lue> I'm not sure if that's something Perl 6 is supposed to do yet, or if it would ever do such a thing. You'd have to ask those more experienced in this area on that.

[03:44] <xenoterracide> lue: I'm pretty sure it isn't

[03:45] <xenoterracide> I'm hoping if I talk about it enough, maybe someone notices and thinks its a good enough idea

[03:45] <xenoterracide> I can see a point of why using namespace isn't always good

[03:46] <lue> Yeah, that's hard to say. I can see arguments for "this is the same scope, spread across a bunch of places" and for "changing how you can refer to things implicitly (as opposed to an explicit 'is exported') is wrong"

[03:46] <xenoterracide> imho depends on tightness of package coupling, and some other stuff

[03:47] <lue> IMO, using namespace for specific things (like changing just std::cout to cout) is acceptable, using it to create an alias (boost::reallyLongName::Thing -> brLNT) is perfectly fine, and plain ol' getting rid of the namespace is never OK :)

[03:48] <xenoterracide> possibly nested namespaces would be good

[03:48] <xenoterracide> or nested handling

[03:48] <lue> (but of course opinions differ, and I'm not one to stop someone from incurring the wrath of preventable name conflicts :P)

[03:48] <xenoterracide> right

[03:49] <xenoterracide> such that one could use Model::User from in Controller::User both of which are part of the MyApp::

[03:50] <xenoterracide> but within Model::User and Model::Role could just refer to each other as User and Role

[03:50] <xenoterracide> yeah I'm not convinced I like aliasing

[03:51] <lue> I wonder how easily one could create a kind of package that let you do the C++ style "User and Role" thing ... .oO(cpp_style_package Foo { ... })

[03:52] <lue> xenoterracide: why not? It's just the superset of name::space:: -> ∅  :P

[03:52] <xenoterracide> lue: idk, just seems like that would be more difficult

[03:52] <xenoterracide> to specify which behavior you want

[03:53] <xenoterracide> but I think that'd be cool

[03:53] <xenoterracide> and would be reasonable

[03:53] <lue> why? In C++ it's just a matter of  namespace thing = super::long::name

[03:53] <xenoterracide> well I'm thinking of not specifying using

[03:53] <lue> Arguably  my \thing = super::long::name  is the same thing :)

[03:53] <xenoterracide> more a matter of looking relative too

[03:53] <xenoterracide> to*

[03:54] <xenoterracide> yeah but you still have to "import"

[03:54] <xenoterracide> I don't want to import things in the same package

[03:54] <lue> being able to leave off the Foo:: inside  package Foo { }  is debatable, I'm not sure which I like.

[03:55] <xenoterracide> well if you actually put both classes inside of the braces you could leave off Foo:: I htink

[03:55] <xenoterracide> but doesn't work across files

[03:56] <lue> Names need to be declared within a compliation unit, so if Foo::Bar is specified in another file, you'd have to import it. (Maybe you can put a stub definition in the file to avoid importation?)

[03:57] <xenoterracide> eww

[03:57] <xenoterracide> grammar should make magic happen

[03:58] <xenoterracide> I need to learn how to extend p6 grammar

[03:59] <lue> it's not very doable as of yet. (The most there is are macros)

[04:01] <lue> xenoterracide: Stub definitions are similar to C++ declarations in a header file, only we don't really have an explicit notion of "header files".

[04:02] <xenoterracide> ah, well I'm not very familiar with C++ more familiar with Java like things

[04:03] <xenoterracide> and p5

[04:03] <xenoterracide> in java things in the same directory are in the same package, things in the same package don't need to be imported

[04:03] <lue> admittedly I've never really used stub definitions before, so I don't know offhand what happens concerning them.

[04:04] <xenoterracide> the compiler "magically" combines them

[04:04] <lue> that's the kind of magic Perl 6 can't sanely do, because there's no standard directory structure. The way you combine them is with 'use' and friends :)

[04:05] <xenoterracide> personally I think the lack of a standard directory structure is a flaw

[04:06] <xenoterracide> it makes it harder to make the code nicer in this way

[04:06] <xenoterracide> and it makes it harder to find things

[04:07] <lue> There's the conventional structure of Foo::Bar -> lib/Foo/Bar.pm6 , though again that's not required.

[04:08] <xenoterracide> right

[04:08] <xenoterracide> which is of course what I write

[04:08] <xenoterracide> personally I think that should be required

[04:08] <xenoterracide> makes things simpler

[04:09] *** hoverboard joined
[04:10] <xenoterracide> when you put things in a standard place, all things are cleaner

[04:15] <Woodi> morning :)

[04:20] <Woodi> woo... Friday, 18 April 2014, 21:33 with seconds - first question about Perl6 stability on #perl6 channel gets decisively positive and rock stable answer... New Epoch ! Call President ! ;)

[04:23] <xenoterracide> http://privatepaste.com/0ae022d0d1 < I have a belief that the has could be pretty without over-complicating UserId 

[04:24] <xenoterracide> or adding a bunch more code to User

[04:29] *** bluescreen10 left
[04:35] *** Psyche^ joined
[05:02] *** kaare_ joined
[05:04] <xenoterracide> ^%$#@

[05:04] <xenoterracide> so how do I get the methods on the metaclass

[05:05] <xenoterracide> "".^.^methods.join(', '); it's not that

[05:12] *** adu joined
[05:13] <lue> r: say Mu.^methods;

[05:13] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«ACCEPTS WHERE WHICH take WHY Bool so not defined new CREATE bless BUILDALL BUILD_LEAST_DERIVED Numeric Real Str Stringy item say print gist perl DUMP DUMP-PIECES DUMP-OBJECT-ATTRS isa does can clone Capture Method+{<anon>}.new() dispatch:<::> …»

[05:13] <lue> r: say Mu.HOW.^methods;

[05:13] <camelia> rakudo-jvm 22fbed: OUTPUT«No such method 'gist' for invocant of type 'NQPRoutine'␤  in method gist at gen/jvm/CORE.setting:7090␤  in sub say at gen/jvm/CORE.setting:13498␤  in block  at /tmp/tmpfile:1␤␤»

[05:13] <camelia> ..rakudo-parrot 22fbed: OUTPUT«No such method 'gist' for invocant of type 'NQPRoutine'␤  in method gist at gen/parrot/CORE.setting:7094␤  in method gist at gen/parrot/CORE.setting:1056␤  in sub say at gen/parrot/CORE.setting:13540␤  in block  at /tmp/tmpfile:1␤␤»

[05:13] <camelia> ..rakudo-moar 22fbed: OUTPUT«No such method 'gist' for invocant of type 'NQPRoutine'␤  in method gist at src/gen/m-CORE.setting:7149␤  in sub say at src/gen/m-CORE.setting:13555␤  in block  at /tmp/tmpfile:1␤␤»

[05:14] <lue> r: print Mu.HOW.^methods;

[05:14] <camelia> rakudo-jvm 22fbed: OUTPUT«Nominal type check failed for parameter '$expected'␤  in method REIFY at gen/jvm/CORE.setting:8647␤  in method reify at gen/jvm/CORE.setting:7507␤  in method gimme at gen/jvm/CORE.setting:7942␤  in method print at gen/jvm/CORE.setting:13704␤  in s…»

[05:14] <camelia> ..rakudo-parrot 22fbed: OUTPUT«Nominal type check failed for parameter '$expected'; expected Any but got Mu instead␤  in method REIFY at gen/parrot/CORE.setting:8667␤  in method reify at gen/parrot/CORE.setting:7511␤  in method gimme at gen/parrot/CORE.setting:7962␤  in method…»

[05:14] <camelia> ..rakudo-moar 22fbed: OUTPUT«No such method 'Str' for invocant of type 'NQPRoutine'␤  in method print at src/gen/m-CORE.setting:13761␤  in sub print at src/gen/m-CORE.setting:13549␤  in block  at /tmp/tmpfile:1␤␤»

[05:17] *** xenoterracide left
[05:28] <lue> blag toast!    https://rdstar.wordpress.com/2014/04/19/about-those-slangs/

[05:37] <lue> ♘ #perl6 o/

[05:52] *** MikeFair_ left
[05:56] *** raiph left
[06:01] *** darutoko joined
[06:11] <moritz> \o

[06:14] *** xinming left
[06:20] *** FROGGS[mobile] joined
[06:24] <xfix> rn: if 0 { "lol".property }

[06:25] <camelia> rakudo-{parrot,jvm,moar} 22fbed, niecza v24-109-g48a8de3: ( no output )

[06:28] *** cognominal left
[06:28] *** cognominal joined
[06:29] *** cognominal left
[06:31] *** cognominal joined
[06:31] *** xinming joined
[06:36] *** Guest68711 joined
[06:36] *** adu left
[06:37] *** Guest68711 is now known as vincent21

[06:38] *** SamuraiJack joined
[06:52] <geekosaur> dear gmail, no, perl6 commits are not phishes. stop it. >.>

[06:55] *** SamuraiJack left
[07:10] *** water joined
[07:10] *** hoverboard left
[07:10] *** water is now known as hoverboard

[07:13] *** djanatyn left
[07:13] *** djanatyn1 joined
[07:13] *** darutoko left
[07:13] *** darutoko- joined
[07:13] *** slavik joined
[07:15] *** hoverboard left
[07:19] *** araujo left
[07:42] *** vincent21 left
[07:46] *** kurahaupo joined
[08:10] *** gaussblurinc_ joined
[08:13] <masak> antenoon, #perl6

[08:13] <lizmat> masak o/

[08:16] <masak> `make j-spectest` again got stuck after 't/spec/S17-concurrency/supply.rakudo.jvm ..................... 17/36'

[08:16] *** dmol joined
[08:21] *** FROGGS__ is now known as FROGGS

[08:22] <FROGGS> a LHF if someone like to do something: write a module that parses http://www.cpan.org/MIRRORED.BY

[08:25] <lee_> ail

[08:25] <lee_> whoops

[08:26] *** kaare_ left
[08:38] <lizmat> masak: looking

[08:39] <masak> lee_: we're here to ail, should you need anything :>

[08:40] *** ssutch left
[08:41] *** ssutch joined
[08:41] *** xinming left
[08:42] <FROGGS> m: my (*, *, $x) = (1, 2, 3);

[08:42] <camelia> rakudo-moar 22fbed: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/l1cG2neSj7␤Malformed parameter␤at /tmp/l1cG2neSj7:1␤------> [32mmy ([33m⏏[31m*, *, $x) = (1, 2, 3);[0m␤    expecting any of:␤        scoped declarator␤»

[08:42] <lizmat> NYI afaik

[08:43] <FROGGS> yes, I just wanted to see the msg

[08:43] <FROGGS> I am looking at that again: https://ethercalc.org/i982ooyabg.html

[08:43] <lizmat> breakfast&

[08:45] *** ssutch left
[08:47] *** rindolf joined
[08:48] *** xfix left
[09:02] *** Bucciarati joined
[09:02] *** xfix joined
[09:06] *** anaeem1 joined
[09:07] *** xfix left
[09:20] *** xfix joined
[09:27] *** anaeem1 left
[09:31] *** denis_boyun_ joined
[09:41] *** ssutch joined
[09:42] *** anaeem1_ joined
[09:46] *** ssutch left
[09:48] <jnthn> o/ #perl6

[09:48] <jnthn> FROGGS: It's a sig there, wants to be my ($, $, $x) = ...

[09:52] <jnthn> .tell xenoterracide type names are usually camel-cased, whereas trait names are typically lowercase. For me that's always been enough of a convention to know that I'm probably looking at inheritance. otoh, I tend to be a light user of inheritance these days, especially in Perl 6 where there are roles.

[09:52] <yoleaux> jnthn: I'll pass your message to xenoterracide.

[09:58] <timotimo> ohai

[10:01] *** ssutch joined
[10:03] <jnthn> o/ timotimo 

[10:06] *** ssutch left
[10:08] <timotimo> hey jnthn

[10:12] *** gaussblurinc_ left
[10:23] *** rindolf left
[10:29] *** spider-mario joined
[10:33] <FROGGS> jnthn: then the spec needs to be adjusted

[10:33] <FROGGS> m: my ($, $, $x) = (1, 2, 3); # does it parse it as P5 special var?

[10:33] <camelia> rakudo-moar 22fbed: ( no output )

[10:33] <FROGGS> cool

[10:35] <jnthn> FROGGS: It literally parses as a sig.

[10:36] <FROGGS> I know, but there was a bug once that complained about $, being a P5 special var

[10:36] <lizmat> masak: test #17 is fudged on the JVM, are you trying to run it without fudging?

[10:36] <vendethiel> r: anon sub { state $; }

[10:36] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Unsupported use of $; variable; in Perl 6 please use real multidimensional hashes␤at /tmp/tmpfile:1␤------> [32manon sub { state $;[33m⏏[31m }[0m␤»

[10:36] <lizmat> masak: ok 17 - # SKIP hangs

[10:37] <lizmat> r: anon sub { state $ ; }

[10:37] <camelia> rakudo-{parrot,jvm,moar} 22fbed: ( no output )

[10:38] <FROGGS> lizmat: I can confirm "ok 17 - # SKIP hangs"

[10:39] <lizmat> I need a reality check:

[10:39] <lizmat> is there something wrong with:

[10:39] <lizmat> method squish(Supply $a, :&as, :&with = &[===]) {

[10:40] <lizmat> I'm expecting &with to be set with &infix:<===> if not specified

[10:40] <jnthn> Isn't it a method on a supply?

[10:40] <jnthn> oh, wait, it's in SupplyOperatios

[10:40] <lizmat> yup

[10:40] <jnthn> lizmat: Yes, that seems sensible

[10:41] <lizmat> well, it doesn't get set: I just keep getting an empty (Callable) in there, which bombs later

[10:41] <jnthn> And how does your call into SupplyOperations look?

[10:41] <lizmat> ah... good point

[10:41] <lizmat> that's probably it  :-)

[10:41] <jnthn> ;)

[10:42] <jnthn> Hmm. Supply.interval doesn't work on Moar, despite the scheduler handling time stuff now.

[10:42] <jnthn> j: say 'alive?'

[10:42] <camelia> rakudo-jvm 22fbed: OUTPUT«alive?␤»

[10:42] <jnthn> j: Supply.interval(1).tap({ say 'here' }); sleep 5; say 'ok'

[10:42] <camelia> rakudo-jvm 22fbed: OUTPUT«here␤here␤here␤here␤here␤here␤ok␤»

[10:44] <lizmat> jnthn: did you have a reason for not using just |c for the proxy methods in Supply ?

[10:46] <jnthn> lizmat: It's slower.

[10:46] <jnthn> lizmat: And normally overkill

[10:46] <jnthn> lizmat: But for squish, makes sense.

[10:47] <lizmat> ok, because it makes sense not to have to keep default settings at 2 places

[10:47] <lizmat> otoh, I guess the SupplyOperations methods are not intended to be called directly, right ?

[10:48] <jnthn> Right.

[10:48] <jnthn> They exist because you can't implement a role inside of its declaration.

[10:49] <lizmat> feels a hacky solution in search for at least some syntactic sugar

[10:50] *** pippo_ joined
[10:50] <pippo_> m: my %h = a => 1, z => 4, b => 2; say %h.sort.WHAT;

[10:50] <camelia> rakudo-moar 22fbed: OUTPUT«(Parcel)␤»

[10:51] <pippo_> ^^ shouldn't this be a Hash iso a Parcel??

[10:51] <jnthn> No.

[10:52] <jnthn> %h.sort is really %h.list.sort which is really %h.pairs.sort

[10:52] *** rindolf joined
[10:52] <jnthn> A hash is unordered, so turning it back into one would simply throw away all the sorting work and basically be an expensive no-op 

[10:53] <jnthn> lizmat: I kinda agree. I wonder if we can use a fallback method to do all the forwarding.

[10:55] <dalek> rakudo/nom: 1f70700 | (Elizabeth Mattijsen)++ | src/core/SupplyOperations.pm:

[10:55] <dalek> rakudo/nom: Fix default setting of .squish(:with)

[10:55] <dalek> rakudo/nom: 

[10:55] <dalek> rakudo/nom: The proxy method in Supply was sending an empty callable, so the named parameter

[10:55] <dalek> rakudo/nom: default didn't work.  jnthn++ for pointing me in the right direction.

[10:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f707003b6

[10:55] <dalek> roast: 2964de5 | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[10:55] <dalek> roast: Activate Supply.squish tests without :with

[10:55] <dalek> roast: review: https://github.com/perl6/roast/commit/2964de5133

[10:56] <dalek> rakudo/nom: 651ed7c | (Elizabeth Mattijsen)++ | docs/ChangeLog:

[10:56] <dalek> rakudo/nom: Update ChangeLog

[10:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/651ed7c29e

[10:56] <pippo_> jnthn: I undertand. But does not work well with kv i.e. "say %h.sort.kv" is not what one would expect.

[10:57] <pippo_> m: my %h = a => 1, z => 4, b => 2; say %h.sort.kv;

[10:57] <jnthn> pippo_: Hm. I'd not really expect... ;)

[10:57] <camelia> rakudo-moar 22fbed: OUTPUT«0 "a" => 1 1 "b" => 2 2 "z" => 4␤»

[10:57] <jnthn> pippo_: What's the context of what you're trying to do?

[10:57] <lizmat> the .kv works on a list of pairs, so the output is correct

[10:58] <jnthn> Right.

[10:58] <pippo_> jnthn: simply print the %h sorted.

[10:58] <lizmat> r: (^10).kv.say

[10:58] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9␤»

[10:58] <lizmat> keys on a list are the element indexes

[10:59] <jnthn> pippo_: I'd typically just write for %hash.sort(*.key) -> $p { say "$p.key() is $p.value()" } or so

[10:59] <JimmyZ> jnthn: loop_runner is not used after MVM_thread_new, it still needs MVMROOT?

[10:59] <pippo_> Yes I have noticed. I was only curious about the reason why %h.sort is not a hash. Thank you!

[11:00] <jnthn> JimmyZ: ah, I see...

[11:00] <lizmat> mind you, if we would have something like Hash does Sorted

[11:00] <lizmat> Hash.sort could return a Sorted Hash

[11:00] <jnthn> lizmat: mebbe, but that sounds costly for the common "I just want to iterate it" case

[11:01] <lizmat> well, true

[11:01] <lizmat> but I recall the days when I started working with Perl 5

[11:01] <lizmat> and I would return hashes out of subs like:

[11:01] <lizmat> sub do_someting( my %h; ... ; %h ); my %a = do_something();

[11:02] <lizmat> it would work, but it would be very expensive for large hashes

[11:02] <lizmat> so maybe this is one of those expectancy things

[11:03] <lizmat> fwiw, I've been bitten by that behaviour of %h.sort in my early P6 days

[11:07] <jnthn> oh, hah...

[11:07] <FROGGS> S02:1022

[11:07] <synopsebot> Link: http://perlcabal.org/syn/S02.html#line_1022

[11:07] <jnthn> The thread pool never started a thread to handle the timer events :)

[11:07] <lizmat> then it's about time it did  :-)

[11:07] <jnthn> lizmat: Yeah, I can kinda see it...but I think it may be more consistent the way it is once you get used to the language.

[11:08] <jnthn> Yes, I hope that fixes my Supply.interval bug.

[11:08] <lizmat> TheDamian was mentioning a long, shallow learning curve for Perl 6

[11:08] <jnthn> yays

[11:08] <lizmat> I would call the current behaviour of Hash.sort quite a bump in the otherwise shallow slope

[11:11] *** hoelzro left
[11:11] *** atrodo left
[11:12] <dalek> rakudo/async: f7dcaa7 | jnthn++ | src/core/ThreadPoolScheduler.pm:

[11:12] <dalek> rakudo/async: Ensure there's a thread for timer events.

[11:12] <dalek> rakudo/async: 

[11:12] <dalek> rakudo/async: Also, a minor simplification.

[11:12] <dalek> rakudo/async: review: https://github.com/rakudo/rakudo/commit/f7dcaa7ddc

[11:12] *** atrodo joined
[11:13] <jnthn> perl6-m -e "Supply.interval(1).tap({ say $_ }); sleep 5;" # now works on Moar

[11:14] <lizmat> jnthn++

[11:14] <lizmat> can't wait to unfudge the tests :-)

[11:16] <jnthn> Supply.for(<beer fags metal>).zip(Supply.interval(1), -> $x, $ { $x }).tap({ say $_ }); sleep 4; # works too :)

[11:16] *** hummeleB1 joined
[11:16] <jnthn> Supplies. So rock and roll.

[11:16] <jnthn> lizmat: Was merge still busted?

[11:17] <lizmat> it's on that is busted for the EnumMap case

[11:17] <lizmat> on -> $res {

[11:18] <jnthn> ah, yes, I remember now.

[11:18] <lizmat> a => { more => >... }}

[11:18] <lizmat> which is what merge is using

[11:18] <jnthn> right, 'cus it needs both to get done

[11:18] <jnthn> on. It makes writing these combinators so much easier.

[11:18] <lizmat> the problem is that the "inner" more doesn't get the supply it is supposed to work on

[11:20] <jnthn> Unhandled exception in code scheduled on thread 10508

[11:20] <jnthn> Cannot call method 'more' on a null object

[11:20] <jnthn> hmm 

[11:20] <lizmat> https://gist.github.com/lizmat/11042880

[11:20] <lizmat> indeed

[11:22] <timotimo> i'm really tired :\

[11:23] <lizmat> get out in the sun, it's a beautiful day (well, it is here)

[11:23] <timotimo> and i'm attending an event where the net is quite ... flaky :)

[11:24] <lizmat> ah, so you're bored :-)

[11:27] <timotimo> have any low hanging fruit? :)

[11:27] <timotimo> i don't think i'd be able to do anything significant right now :\

[11:28] <lizmat> FROGGS had some LHF earlier tody

[11:28] <lizmat> *today

[11:31] <jnthn> lizmat: I may see it.

[11:31] <lizmat> that would be great, because that one has been driving me crazy for the better part of 2 days

[11:31] <lizmat> initially because it was just silent because all the exceptions got eaten

[11:32] <jnthn> r: my $x = -> $a { { a => $a } }; my $foo = $x(); say $foo.WHAT;

[11:32] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in block  at /tmp/tmpfile:1␤␤»

[11:32] <jnthn> r: my $x = -> $a { { a => $a } }; my $foo = $x(42); say $foo.WHAT;

[11:32] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«(Hash)␤»

[11:33] <jnthn> r: my $x = -> $a { { a => sub () { $a } } }; my $foo = $x(42); say $foo<a>.WHAT;

[11:33] <lizmat> que?

[11:33] <camelia> rakudo-{parrot,jvm,moar} 22fbed: OUTPUT«(Sub)␤»

[11:33] <jnthn> r: my $x = -> $a { { a => sub () { $a } } }; my $foo = $x(42); say $foo<a>.();

[11:33] <camelia> rakudo-{parrot,jvm} 22fbed: OUTPUT«42␤»

[11:33] <camelia> ..rakudo-moar 22fbed: OUTPUT«(Mu)␤»

[11:33] <jnthn> There.

[11:33] <lizmat> ketjing

[11:33] <jnthn> ah, it's one of those...

[11:36] <lizmat> Supply.flat is specced, but not implemented: 

[11:37] <lizmat> I assume you meant to .flat each incoming value and create a .more for each resulting value ?

[11:37] <jnthn> Yeah, though maybe it wants a block too

[11:37] <jnthn> Though in a Perl 6-y sense maybe .map should play this role also

[11:38] <lizmat> so, unspec .flat?

[11:38] <jnthn> Can do for now

[11:38] <jnthn> The list was a wild stab at some things we may want :)

[11:38] <moritz> wouldn'T that be Supply.list.flag?

[11:39] <jnthn> moritz: No, it's more when you want to have one value pushed in, and push many out 

[11:42] <jnthn> m: (1..4).map({ $_ xx $_ }).eager.perl.say

[11:42] <camelia> rakudo-moar 651ed7: OUTPUT«(1, 2, 2, 3, 3, 3, 4, 4, 4, 4).list␤»

[11:42] <jnthn> Like that.

[11:43] *** SamuraiJack joined
[11:46] *** anaeem1_ left
[11:47] *** anaeem1 joined
[11:51] *** anaeem1 left
[11:51] <jnthn> lizmat: Think I've got a fix.

[11:51] <lizmat> cool!

[12:02] <dalek> rakudo/async: 8232ea1 | jnthn++ | src/Perl6/Actions.nqp:

[12:02] <dalek> rakudo/async: Fix AST-gen for blocks in hash constructors.

[12:02] <dalek> rakudo/async: 

[12:02] <dalek> rakudo/async: Need to migrate inner blocks out to the right scope, given that the

[12:02] <dalek> rakudo/async: hash constructor does not imply one. Fixes "on" with the EnumMap

[12:02] <dalek> rakudo/async: case on MoarVM, and no doubt some other things.

[12:02] <dalek> rakudo/async: review: https://github.com/rakudo/rakudo/commit/8232ea1144

[12:03] *** ssutch joined
[12:04] <jnthn> That should do it.

[12:19] *** ilogger2 joined
[12:19] *** ChanServ sets mode: +v ilogger2

[12:20] *** xenoterracide joined
[12:20] <vendethiel> r: say @((1, \(2, 3)).perl

[12:20] <camelia> rakudo-jvm 651ed7: OUTPUT«(timeout)»

[12:20] <camelia> ..rakudo-{parrot,moar} 651ed7: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Unable to parse expression in contextualizer; couldn't find final ')' ␤at /tmp/tmpfile:1␤------> [32msay @((1, \(2, 3)).perl[33m⏏[31m<EOL>[0m␤    expecting any of:␤ …»

[12:20] <vendethiel> m: say @((1, \(2, 3))).perl

[12:20] <camelia> rakudo-moar 651ed7: OUTPUT«(1, Capture.new(list => (2, 3,))).list␤»

[12:22] <moritz> j: say 1

[12:22] <camelia> rakudo-jvm 651ed7: OUTPUT«Error while reading '/home/p6eval_eval/p6eval-token': Permission denied at /home/p6eval/jvm-rakudo/eval-client.pl line 10.␤»

[12:25] <jnthn> In Pagan Sweden, the supermarkets at least open every day over easter. Though with reduced opening hours. :)

[12:27] <dalek> roast: 9bf4cfb | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[12:27] <dalek> roast: Some more and more precise Supply tests

[12:27] <dalek> roast: review: https://github.com/perl6/roast/commit/9bf4cfb266

[12:30] <xenoterracide> how can I list the methods on a classes meta class? (ultimately trying to see if I can see the traits that were applied to it)

[12:30] <yoleaux> 09:52Z <jnthn> xenoterracide: type names are usually camel-cased, whereas trait names are typically lowercase. For me that's always been enough of a convention to know that I'm probably looking at inheritance. otoh, I tend to be a light user of inheritance these days, especially in Perl 6 where there are roles.

[12:31] <lizmat> xenoterracide: Int.HOW.^methods

[12:31] <lizmat> better:

[12:31] <lizmat> m: Int.HOW.^methods>>.name.say

[12:31] <camelia> rakudo-moar 651ed7: OUTPUT«archetypes new new_type parameterize add_fallback compose roles role_typecheck_list concretization is_composed can setup_junction_fallback find_method_fallback has_fallbacks set_name name set_docs docs ver auth set_ver set_auth set_stash_type add_stash add…»

[12:32] <lizmat> it's just a class like any other class  :-)

[12:32] *** kurahaupo joined
[12:33] <FROGGS> yes, unlike other languages it really is classes all the way down

[12:33] <moritz> classes and roles and KnowHOWs

[12:33] <FROGGS> yes

[12:40] <dalek> roast: 729b330 | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[12:40] <dalek> roast: Add tests for Supply.do + some simplifications

[12:40] <dalek> roast: review: https://github.com/perl6/roast/commit/729b330231

[12:52] *** raiph joined
[12:56] <dalek> rakudo/nom: a9b992c | (Elizabeth Mattijsen)++ | src/core/Supply (2 files):

[12:56] <dalek> rakudo/nom: Implement Supply.flat

[12:56] <dalek> rakudo/nom: 

[12:56] <dalek> rakudo/nom: Because we may want to use that a lot, and it would need to be fast (as

[12:56] <dalek> rakudo/nom: opposed to using .map, which would add another scope to handle for each original

[12:56] <dalek> rakudo/nom: value).

[12:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a9b992c928

[12:56] <dalek> roast: 071ebd3 | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[12:56] <dalek> roast: Add test for Supply.flat

[12:56] <dalek> roast: review: https://github.com/perl6/roast/commit/071ebd3dfb

[12:57] <dalek> rakudo/nom: 687e075 | (Elizabeth Mattijsen)++ | docs/ChangeLog:

[12:57] <dalek> rakudo/nom: Update ChangeLog

[12:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/687e0752dc

[12:59] <dalek> specs: 5ac4ae0 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[12:59] <dalek> specs: Elaborate on Supply.(flat|do|map|grep|uniq|squish)

[12:59] <dalek> specs: review: https://github.com/perl6/specs/commit/5ac4ae073c

[13:01] <lizmat> cycling&

[13:04] *** ssutch joined
[13:08] *** ssutch left
[13:14] <masak> m: grammar G { class Default::Actions { method TOP($/) { say "OH HAI" } }; rule TOP { ^ }; method parse($target, :$rule = "TOP", Mu :$actions = Default::Actions.new, *%opt) { my $*ACTIONS = $actions; my $result = self."!cursor_init"($target, |%opt)."$rule"().MATCH; $result = Nil unless $result.to == $target.chars; nqp::getlexcaller(q[$/]) = $result } }; G.parse("foo")

[13:14] <camelia> rakudo-moar 651ed7: OUTPUT«OH HAI␤»

[13:14] <masak> ...and that's how you can endow a grammar with its default (but overridable) actions. :)

[13:15] <masak> suggestions for how to (a) shorten and/or (b) package into a module, greatly appreciated.

[13:15] <jnthn> masak: You'd have been better off using callsame than copy-pasting internals :P

[13:15] <jnthn> uh, callwith

[13:15] <masak> m: grammar G { class Default::Actions { method TOP($/) { say "OH HAI" } }; rule TOP { ^ }; method parse($target, :$rule = "TOP", Mu :$actions = Default::Actions.new, *%opt) { callsame } }; G.parse("foo"); say "no such luck :("

[13:15] <camelia> rakudo-moar 651ed7: OUTPUT«no such luck :(␤»

[13:15] <masak> jnthn: show me.

[13:15] <jnthn> masak: call*with*

[13:16] <masak> m: grammar G { class Default::Actions { method TOP($/) { say "OH HAI" } }; rule TOP { ^ }; method parse($target, :$rule = "TOP", Mu :$actions = Default::Actions.new, *%opt) { callwith } }; G.parse("foo")

[13:16] <camelia> rakudo-moar 651ed7: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method parse at src/gen/m-CORE.setting:12981␤  in any call_with_args at src/gen/m-Metamodel.nqp:3005␤  in block  at src/gen/m-CORE.setting:632␤  in method parse at /tmp/wCMgZdNEc7:1…»

[13:16] <jnthn> callwith($target. :$rule, :$actions, |%opt);

[13:16] <masak> m: grammar G { class Default::Actions { method TOP($/) { say "OH HAI" } }; rule TOP { ^ }; method parse($target, :$rule = "TOP", Mu :$actions = Default::Actions.new, *%opt) { callwith($target. :$rule, :$actions, |%opt) } }; G.parse("foo")

[13:16] <camelia> rakudo-moar 651ed7: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/bbDxs_m36y␤Unsupported use of . to concatenate strings; in Perl 6 please use ~␤at /tmp/bbDxs_m36y:1␤------> [32mActions.new, *%opt) { callwith($target. [33m⏏[31m:$rule, :$actions, |%opt) …»

[13:16] <jnthn> In fact you can leave :$rule out of both and leave opt to get it.

[13:16] <jnthn> uh, comma :)

[13:16] <jnthn> typo'd that

[13:16] <masak> m: grammar G { class Default::Actions { method TOP($/) { say "OH HAI" } }; rule TOP { ^ }; method parse($target, :$rule = "TOP", Mu :$actions = Default::Actions.new, *%opt) { callwith($target, :$rule, :$actions, |%opt) } }; G.parse("foo")

[13:16] <camelia> rakudo-moar 651ed7: OUTPUT«OH HAI␤»

[13:16] <masak> ok, that's better. jnthn++

[13:17] * masak .oO( another desideratum: a module that allows me to default *one* parameter in a method in a subclass )

[13:17] <jnthn> Yeah. And :$rule can go also

[13:17] <jnthn> And %opt gets it

[13:17] <jnthn> *as

[13:17] <masak> m: grammar G { class Default::Actions { method TOP($/) { say "OH HAI" } }; rule TOP { ^ }; method parse($target, :$rule = "TOP", Mu :$actions = Default::Actions.new, *%opt) { callwith($target, :$actions, |%opt) } }; G.parse("foo")

[13:17] <camelia> rakudo-moar 651ed7: OUTPUT«OH HAI␤»

[13:18] <masak> m: grammar G { class Default::Actions { method TOP($/) { say "OH HAI" } }; rule TOP { ^ }; method parse($target, Mu :$actions = Default::Actions.new, *%opt) { callwith($target, :$actions, |%opt) } }; G.parse("foo")

[13:18] <camelia> rakudo-moar 651ed7: OUTPUT«OH HAI␤»

[13:18] <masak> there.

[13:18] <masak> getting shorter already :)

[13:18] *** anaeem1_ joined
[13:18] <masak> I don't see how this could be bundled-and-provided via a role, unfortunately.

[13:18] <jnthn> As for packaging it up, maybe a role or trait

[13:18] <masak> ooh, maybe a trait.

[13:18] <jnthn> is default_actions(...)

[13:18] <masak> then we could provide the name... yeah.

[13:19] <xenoterracide> hmm don't see an obvious methods that would allow me to list the traits I applied to the class

[13:19] *** anaeem___ joined
[13:20] <jnthn> xenoterracide: "the traits I applied" doesn't really make sense. A trait is a mechanism to run a bit of code to do something to a declared object.

[13:20] <jnthn> xenoterracide: That *may* be to attach something to the metaclass

[13:21] <jnthn> It's really up to you what a trait does.

[13:22] *** anaeem1_ left
[13:23] *** anaeem___ left
[13:24] <dalek> nqp/asyncops: 3c52445 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/ (3 files):

[13:24] <dalek> nqp/asyncops: Stub AsyncTask REPR on the JVM.

[13:24] <dalek> nqp/asyncops: 

[13:24] <dalek> nqp/asyncops: Unbusts the ThreadPoolScheduler build again in the async branch.

[13:24] <dalek> nqp/asyncops: review: https://github.com/perl6/nqp/commit/3c52445863

[13:28] <dalek> nqp: d958b6b | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[13:28] <dalek> nqp: Stub in timer and cancel ops on JVM backend.

[13:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d958b6b29e

[13:28] <dalek> nqp: 3b3ccda | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/ (2 files):

[13:28] <dalek> nqp: Partially implement nqp::timer.

[13:28] <dalek> nqp: 

[13:28] <dalek> nqp: Missing cancellation-related bits so far.

[13:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3b3ccda971

[13:28] <dalek> nqp: 362e7a4 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[13:28] <dalek> nqp: Map nqp::timer for MoarVM.

[13:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/362e7a46f2

[13:28] <dalek> nqp: 3c52445 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/ (3 files):

[13:28] <dalek> nqp: Stub AsyncTask REPR on the JVM.

[13:28] <dalek> nqp: 

[13:28] <dalek> nqp: Unbusts the ThreadPoolScheduler build again in the async branch.

[13:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3c52445863

[13:29] <dalek> nqp: 0ef8041 | jnthn++ | tools/build/MOAR_REVISION:

[13:29] <dalek> nqp: Bump to a MoarVM with timers.

[13:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0ef804140f

[13:29] <xenoterracide> jnthn: ok

[13:30] *** araujo joined
[13:30] *** araujo left
[13:30] *** araujo joined
[13:36] <dalek> rakudo/nom: a71eccd | jnthn++ | src/core/ThreadPoolScheduler.pm:

[13:36] <dalek> rakudo/nom: Switch ThreadPoolScheduler to use nqp::timer op.

[13:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a71eccdda1

[13:36] <dalek> rakudo/nom: 3814ab3 | jnthn++ | src/core/ThreadPoolScheduler.pm:

[13:36] <dalek> rakudo/nom: Pass an arg for the async handle to nqp::timer.

[13:36] <jnthn> lizmat: merged

[13:37] *** dalek joined
[13:37] *** ChanServ sets mode: +v dalek

[13:42] *** Khisanth joined
[13:57] <xenoterracide> obviously not doing this right :/ http://privatepaste.com/9b54073427

[13:59] <xenoterracide> want to add a role (seems like the best way) to the meta class of User

[14:04] *** ssutch joined
[14:08] <JimmyZ> 14,722 commits in rakudo ...

[14:08] * masak drops in on #python and re-laughs at "NO LOL | NO PROJECT EULER"

[14:09] <Rounin> Sounds like a charming place

[14:09] *** ssutch left
[14:09] <jnthn> masak: refactor it to NO [LOL | PROJECT EULER] :P

[14:10] <jnthn> xenoterracide: Doing .add_role there is adding it to the class itself

[14:10] <jnthn> xenoterracide: That is, you're essentially doing the same as if the class said "does Entity"

[14:10] <jnthn> Is that what you wanted?

[14:11] <jnthn> Anyway, it's working, it's just that when you stringify a type - like join is there - it acts as an uninitialized value

[14:11] <xenoterracide> jnthn: no, trying to add it to the meta class

[14:11] <jnthn> say LM::Model::User.^roles; # probably works out

[14:11] <jnthn> xenoterracide: OK, I'd do it by mixing in to the meta-object

[14:12] <xenoterracide> jnthn: so how do I do that?

[14:13] <xenoterracide> well maybe not the metaclass idk, in theory this should be on the "class" but not the resulting instance, if that makes any sense at all

[14:14] <jnthn> https://gist.github.com/jnthn/11085557

[14:14] <xenoterracide> jnthn: my ultimate goal is mimicking java annotations

[14:15] <jnthn> Yeah. I do wonder if a more generic mechanism is what you want.

[14:15] <jnthn> Like, you just have a way to have an annotations hash

[14:15] <jnthn> And your traits just put stuff into it.

[14:15] <jnthn> r: https://gist.github.com/jnthn/11085557

[14:16] <camelia> rakudo-moar 687e07: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Incompatible MROs in P6opaque rebless␤at /tmp/tmpfile:7␤------> ␤»

[14:16] <camelia> ..rakudo-{parrot,jvm} 687e07: OUTPUT«True␤»

[14:16] <jnthn> Some Moar issue there.

[14:16] <jnthn> Wonder if that's one of the handful of fudged spectests.

[14:17] <vendethiel> uuh. Entity is declared outside too ?

[14:18] <vendethiel> again with the compile vs runtime ?

[14:18] <vendethiel> r: sub foo { class A }; A.new; say 'alive'

[14:18] *** denis_boyun_ joined
[14:18] <camelia> rakudo-{parrot,jvm,moar} 687e07: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Unable to parse class definition␤at /tmp/tmpfile:1␤------> [32msub foo { class A [33m⏏[31m}; A.new; say 'alive'[0m␤    expecting any of:␤        statement list…»

[14:18] <vendethiel> r: sub foo { class A {} }; A.new; say 'alive'

[14:18] <xenoterracide> jnthn: probably

[14:18] <camelia> rakudo-{parrot,jvm,moar} 687e07: OUTPUT«alive␤»

[14:18] <vendethiel> r: sub foo { my class A {} }; A.new; say 'alive'

[14:18] <camelia> rakudo-{parrot,jvm,moar} 687e07: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Undeclared name:␤    A used at line 1␤␤»

[14:19] <vendethiel> I guess that's for the best...

[14:19] <jnthn> xenoterracide: Yeah. I'll see if I can come up with something.

[14:19] <vendethiel> r: sub foo(Str $name) { class A { has $.name = $name }; A.new(:$name) }; my $a1 = foo('a'); my $a2 = foo('b'); say $a1.perl; say $a2.perl;

[14:19] <camelia> rakudo-{parrot,jvm,moar} 687e07: OUTPUT«A.new(name => "a")␤A.new(name => "b")␤»

[14:20] <vendethiel> m: sub foo(Str $name) { class A { has $.name = $name }; A.new }; my $a1 = foo('a'); my $a2 = foo('b'); say $a1.perl; say $a2.perl;

[14:20] <camelia> rakudo-moar 687e07: OUTPUT«A.new(name => "a")␤A.new(name => "b")␤»

[14:20] <xenoterracide> jnthn: maybe they could be a first class citizen, I'm not actually convinced `is` is the correct applicator, though maybe another trait, or even it's own grammar

[14:20] <vendethiel> Good thing that it works, I guess.

[14:21] <vendethiel> m: sub foo(Str $name) { class A { has $.name = $name } }; my $a1 = foo('a').new; my $a2 = foo('b').new; say $a1.perl; say $a2.perl;

[14:21] <camelia> rakudo-moar 687e07: OUTPUT«A.new(name => "a")␤A.new(name => "b")␤»

[14:23] <jnthn> xenoterracide: In theory, we could make it possible to declare custom trait-introducing keywords.

[14:23] *** salv0 joined
[14:36] <xenoterracide> jnthn: would be cool. Either way, "annotations" as a first class citizen, however done, would be awesome. I figure I'm just experimenting with how that could be accomplished and what it's uses would look like

[14:36] <xenoterracide> its*

[14:38] <jnthn> I don't think we'll want annotations in the Java sense. They're quite restrictive in so far as you can't do anything other than attach information, and only then it's things that can live in the constant pool.

[14:39] <jnthn> But yeah, should have a good way to build a similar thing out of traits.

[14:39] <jnthn> And so they can feel first class, even if a module pulls them in.

[14:45] <xenoterracide> jnthn: yeah possibly should be more powerful, but I'm just trying to create things like an EntityManager or a JAX-RS like API, etc, and less sucky ;) (I've found EE to be sucky on the sheer basis that the components don't actually mesh well)

[14:47] <xenoterracide> jnthn: http://privatepaste.com/77b307f811 < being able to write it like this maybe

[14:49] <jnthn> eek

[14:49] <jnthn> .oO( multi trait_mod:<*>(...) )

[14:50] <jnthn> Funny thing is, I think there's not actually any syntactic reason what you want couldn't work if we actually allowed custom trait mods :)

[14:55] <xenoterracide> jnthn: well I'm just thinking maybe make them look like bullet points. I haven't come up with a better way, and I think `is table('users')` is grammatically weird

[14:56] <xenoterracide> < not a language designer

[14:58] <jnthn> I do wonder if a parametric role isn't a better way

[14:58] <jnthn> class Foo does Persist[table => 'users', ...] { }

[14:59] <jnthn> That could then also bring in any methods it wishes.

[14:59] <xenoterracide> my only thought has been that modifying the object itself for this seems wrong (though maybe java would have done that if it had gotten default interfaces sooner)

[15:00] <xenoterracide> also how does that work on attributes and methods?

[15:01] <jnthn> Ah, for those I guess you still want traits

[15:01] *** itz__ joined
[15:01] <jnthn> So maybe you want them overall

[15:03] <xenoterracide> jnthn: yeah, that's my first inclination

[15:04] <xenoterracide> jnthn: maybe underthe hood they'd apply a parametric role to the underlying object? or perhaps just one role with an annotation hash is needed

[15:04] *** itz joined
[15:05] <jnthn> The annotation hash may be the way to go, yeah.

[15:09] *** denis_boyun___ joined
[15:11] *** denis_boyun_ left
[15:22] *** kurahaupo left
[15:24] *** adu joined
[15:28] *** kurahaupo joined
[15:28] <jnthn> away for a while &

[15:30] <adu> hi jnthn 

[15:37] *** Mouq joined
[15:38] <Mouq> xenoterracide: Have you considered the largely unexplored Name:thing<a b c> syntax for annotations?

[15:39] <xenoterracide> no

[15:39] <Mouq> std: class Foo:persist(table => 'users') { }

[15:39] <xenoterracide> never heard of it

[15:39] <camelia> std e347792: OUTPUT«ok 00:01 126m␤»

[15:39] <Mouq> std: class Foo:persist(table => 'users') { }; say Foo

[15:39] <camelia> std e347792: OUTPUT«ok 00:01 126m␤»

[15:39] <xfix> std: sub destructive:seriously { }; destructive

[15:39] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'destructive' used at line 1␤Check failed␤FAILED 00:01 123m␤»

[15:40] <Mouq> There's no introspection or anything for it yet

[15:40] <Mouq> std: sub destructive:seriously { }; destructive:seriously # :/

[15:40] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'destructive:seriously' used at line 1␤Check failed␤FAILED 00:01 123m␤»

[15:40] <Mouq> Hm

[15:40] *** hoverboard joined
[15:40] <Mouq> std: sub destructive:seriously<> { }; destructive:seriously<>

[15:40] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'destructive:seriously<>' used at line 1␤Potential difficulties:␤  Pair with <> really means an empty list, not null string; use :seriously('') to represent the null string,␤  or :seriously() to repres…»

[15:40] *** itz_ joined
[15:40] *** itz___ joined
[15:40] <xfix> std: sub <><><><argh> {}

[15:40] <Mouq> It's the same thing that drives infix:<#whatev>

[15:40] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/2TVGsLnyzf line 1:␤------> [32msub [33m⏏[31m<><><><argh> {}[0m␤    expecting routine_def␤Parse failed␤FAILED 00:01 120m␤»

[15:40] <xfix> std: sub destroy<><><><argh> {}

[15:40] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/Drp5HxRkYe line 1:␤------> [32msub destroy[33m⏏[31m<><><><argh> {}[0m␤    expecting any of:␤     new name to be defined␤ routine_def␤Parse failed␤FAILED 00:00 120m␤»

[15:41] <Mouq> xfix: You need some colons

[15:41] <xfix> std: sub destroy:sure<><><><argh> {}

[15:41] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/bJIfZLkHNP line 1:␤------> [32msub destroy:sure<>[33m⏏[31m<><><argh> {}[0m␤    expecting any of:␤        coloncircumfix␤ routine_def␤Other potential difficulties:␤  Pair with <> really means an e…»

[15:41] <xfix> std: sub destroy:sure<argh> {}

[15:41] <camelia> std e347792: OUTPUT«ok 00:01 123m␤»

[15:42] <xenoterracide> Mouq: seems like it'd be hard to use without introspection unless I can do like I can with traits and have it execute arbitrary code

[15:42] *** itz__ left
[15:42] *** itz left
[15:43] <moritz> j: say 42

[15:43] <camelia> rakudo-jvm 612d0f: OUTPUT«(timeout)»

[15:43] <moritz> j: say 42

[15:43] <camelia> rakudo-jvm 612d0f: OUTPUT«Error while reading '/home/p6eval_eval/p6eval-token': Permission denied at /home/p6eval/jvm-rakudo/eval-client.pl line 10.␤»

[15:43] <Mouq> It's used in grammars for multi rules (pet peeve: remember you can use "proto rule num {*}\nrule num:int {\d+}" -- :sym<int> isn't necessary)

[15:43] <moritz> j: say 42

[15:44] <camelia> rakudo-jvm 612d0f: OUTPUT«(timeout)»

[15:44] <moritz> wtf

[15:44] <FROGGS> :/

[15:44] *** adu left
[15:44] <moritz> /home/p6eval_eval/p6eval-token has permissions -rw-rw-rw-

[15:46] *** denis_boyun joined
[15:48] *** denis_boyun___ left
[15:56] *** gaussblurinc_ joined
[16:00] *** guru joined
[16:00] *** guru is now known as Guest53041

[16:01] *** Guest53041 is now known as ajr_

[16:06] *** ssutch joined
[16:09] *** Rotwang joined
[16:10] *** ssutch left
[16:17] <dalek> rakudo/nom: 17f4ee3 | Mouq++ | src/Perl6/ (2 files):

[16:17] <dalek> rakudo/nom: Generalize quote escapes to include starter

[16:17] <dalek> rakudo/nom: 

[16:17] <dalek> rakudo/nom: This means that q< \< > parses and correcly produces " < "

[16:17] <dalek> rakudo/nom: (Whereas q< < > is a parse error due to unmatched openers and closers,

[16:17] <dalek> rakudo/nom:  and whereas q< \< > used to produce " \\< ")

[16:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/17f4ee3102

[16:18] <dalek> roast: b6097eb | Mouq++ | S02-literals/quoting.t:

[16:18] <dalek> roast: Add tests for quote starter being escapable

[16:18] <dalek> roast: review: https://github.com/perl6/roast/commit/b6097eb4a7

[16:18] <dalek> roast: 51f29eb | Mouq++ | / (8 files):

[16:18] <dalek> roast: Merge branch 'master' of https://github.com/perl6/roast

[16:18] <dalek> roast: review: https://github.com/perl6/roast/commit/51f29ebd70

[16:20] *** hoverboard left
[16:22] <Mouq> (only took me a month to get around to fixing that :|)

[16:22] <Mouq> (I kinda forgot about it)

[16:23] *** cognominal joined
[16:25] <FROGGS> Mouq++ # still nice to see it fixed :o)

[16:26] <FROGGS> r: .say for < $< $> > # RT #119401

[16:26] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=119401

[16:26] <camelia> rakudo-{parrot,jvm,moar} 612d0f: OUTPUT«$<$>␤»

[16:26] <Mouq> FROGGS: Was just about to look at that

[16:26] <FROGGS> hehe, cool!!

[16:26] <FROGGS> :o)

[16:26] <Mouq> Although I think that example is really misleading

[16:26] <Mouq> r: .say for < < a b c > >

[16:26] <camelia> rakudo-{parrot,jvm,moar} 612d0f: OUTPUT«<a␤b␤c>␤»

[16:27] <Mouq> That's more clear, I think

[16:27] <Mouq> FROGGS++ though :)

[16:34] <FROGGS> daxim: ping

[16:54] *** SHODAN joined
[17:06] *** mrg joined
[17:07] *** ssutch joined
[17:08] *** mrg left
[17:11] *** gaussblurinc_ left
[17:11] *** kurahaupo_mobile joined
[17:11] *** ssutch left
[17:12] *** kurahaupo left
[17:13] <raiph> m: package A {}; package A {} # looks like one can spread a package across multiple files

[17:13] <camelia> rakudo-moar 612d0f: ( no output )

[17:13] <raiph> m: use MONKEY_TYPING; grammar A {}; augment grammar A {} # looks like one can spread a grammar across multiple files (deliberately requires more effort)

[17:13] <camelia> rakudo-moar 612d0f: ( no output )

[17:13] <raiph> m: use MONKEY_TYPING; module A {}; augment module A {} # but not a module

[17:13] <camelia> rakudo-moar 612d0f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ScJA8QnKBB␤Cannot augment A because it is closed␤at /tmp/ScJA8QnKBB:1␤------> [32mY_TYPING; module A {}; augment module A [33m⏏[31m{} # but not a module[0m␤    expecting any of:␤    …»

[17:13] <Mouq> bbl; Easter shopping

[17:17] <raiph> TimToady: Is the above per spec / intentional ?

[17:21] *** daxim joined
[17:28] <xenoterracide> raiph: but from what I tried a class in package A*1 wasn't just available in A 2 without fully qualifying

[17:28] *** telex joined
[17:29] <raiph> xenoterracide: I see that as a separate issue

[17:29] *** rindolf joined
[17:29] <xenoterracide> raiph: just noting

[17:30] <raiph> sure

[17:31] *** kurahaupo_mobile left
[17:32] *** kurahaupo joined
[17:35] *** rindolf left
[17:39] *** Vlavv joined
[17:42] *** rindolf joined
[17:45] <FROGGS> std: package A {}; package A {}

[17:45] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'GLOBAL::<A>' (from line 1) at /tmp/xywOGAjFjI line 1:␤------> [32mpackage A {}; package A [33m⏏[31m{}[0m␤Check failed␤FAILED 00:01 122m␤»

[17:45] <FROGGS> std: use MONKEY_TYPING; grammar A {}; augment grammar A {}

[17:45] <camelia> std e347792: OUTPUT«Compiled lib/MONKEY_TYPING.pm6␤ok 00:01 123m␤»

[17:46] <FROGGS> std: use MONKEY_TYPING; module A {}; augment module A {}

[17:46] <camelia> std e347792: OUTPUT«ok 00:01 123m␤»

[17:46] <FROGGS> of course the monkey typing tests here with std are not very representative

[17:52] <TimToady> raiph: yes, it's intentional that modules and classes add in notions of "authority" to the package mechanism

[17:52] <yoleaux> 18 Apr 2014 23:49Z <lue> TimToady: I thought subpattern captures used to just fill up the array (  (\N)+ would fill $0, $1, $2, etc.  ), but now code of mine that assumes this (which worked in February) is broken and S05 has apparently been against this notion the whole time. I don't suppose you're to ask as to why this is?

[17:52] <yoleaux> 18 Apr 2014 23:51Z <lue> TimToady: my discovery starts here, for reference: http://irclog.perlgeek.de/perl6/2014-04-18#i_8609501

[17:56] <raiph> m: use MONKEY_TYPING; class A {}; augment class A {} # can augment a class

[17:56] <camelia> rakudo-moar 17f4ee: ( no output )

[17:57] <raiph> m: use MONKEY_TYPING; module A {}; augment module A {} # but not a module

[17:57] <camelia> rakudo-moar 17f4ee: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/SMonp1zllv␤Cannot augment A because it is closed␤at /tmp/SMonp1zllv:1␤------> [32mY_TYPING; module A {}; augment module A [33m⏏[31m{} # but not a module[0m␤    expecting any of:␤    …»

[18:02] <TimToady> well, that's because classes do late binding, not importation

[18:03] <TimToady> and given the importation mechanism has to be rerun anyway, there

[18:03] <TimToady> there's no reason to augment a module

[18:03] <TimToady> just import from another module

[18:07] *** ssutch joined
[18:09] *** xenoterracide left
[18:11] *** ssutch left
[18:20] *** xenoterracide joined
[18:22] *** vendethiel joined
[18:26] <TimToady> lue: you have to remember that you get both dynamically scoped and lexically scoped arrays out of ()+

[18:26] <raiph> m: use MONKEY_TYPING; module A {}; augment module A {} #6now #module #augment #disallowed

[18:26] <camelia> rakudo-moar 17f4ee: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/5z52KOLSbB␤Cannot augment A because it is closed␤at /tmp/5z52KOLSbB:1␤------> [32mY_TYPING; module A {}; augment module A [33m⏏[31m{} #6now #module #augment #disallowed[0m␤    expectin…»

[18:28] <TimToady> use []+ if you don't want the lexically scoped () arrays

[18:29] <TimToady> () should be thought of as an inline subrule match, not as a textual match; that's what [] is for

[18:31] <TimToady> and the fact that rakudo had a long-standing bug on this issue doesn't seem particularly relevant to the argument of how it *should* work, IMHO, for some value of H or other

[18:32] <TimToady> and I refuse to believe that you will refuse to believe :)

[18:34] <timotimo> oh, it had a long-standing bug? what was the bug?

[18:36] <TimToady> don't remember exactly, but if it used to work with incorrect code, and works correctly now, something musta got fixed :)

[18:37] <TimToady> m: my regex bar { (\N)+ };  "ABC" ~~ /<bar>+/; say $<bar>[0][0]

[18:37] <camelia> rakudo-moar 17f4ee: OUTPUT«｢A｣␤ ｢B｣␤ ｢C｣␤␤»

[18:38] <TimToady> that is correct behavior; the first [0] reflects the + on <bar>, while the second one reflects the *lexical* position of the first (and only, in this case) set of parens inside bar

[18:38] <TimToady> so another level is need to represent the dynamic capture of ()+

[18:39] <TimToady> m: my regex bar { (\N)+ (\N) };  "ABC" ~~ /<bar>+/; say $<bar>[0][0]

[18:39] <camelia> rakudo-moar 17f4ee: OUTPUT«｢A｣␤ ｢B｣␤␤»

[18:39] <TimToady> m: my regex bar { (\N)+ (\N) };  "ABC" ~~ /<bar>+/; say $<bar>[0][1]

[18:39] <camelia> rakudo-moar 17f4ee: OUTPUT«｢C｣␤␤»

[18:40] <TimToady> m: my regex bar { (\N) ** 2 (\N) };  "ABCDEF" ~~ /<bar>+/; say $<bar>[0][1]

[18:40] <camelia> rakudo-moar 17f4ee: OUTPUT«｢C｣␤␤»

[18:40] <TimToady> m: my regex bar { (\N) ** 2 (\N) };  "ABCDEF" ~~ /<bar>+/; say $<bar>[1][1]

[18:40] <camelia> rakudo-moar 17f4ee: OUTPUT«｢F｣␤␤»

[18:40] <TimToady> m: my regex bar { (\N) ** 2 (\N) };  "ABCDEF" ~~ /<bar>+/; say $<bar>[1][0][0]

[18:40] <camelia> rakudo-moar 17f4ee: OUTPUT«｢D｣␤␤»

[18:41] <TimToady> this all seems correct to me

[18:45] <TimToady> the other confusing thing is that the array for the + comes inside the array for the () position, but that can't really be helped much

[18:45] *** zby_home joined
[18:45] <TimToady> quantifiers turn singular things into plural things, is all

[18:46] <TimToady> we could conceivably have a (+ \N) form that would work to pul the quantifier out front, and inside, but that doesn't help with things like [()()]+ which also want to pluralize both inner ()s

[18:48] <TimToady> well, if we had the s-expr-y form, you could write [+ ()()] but it still wouldn't put the + inside the ()

[18:48] <TimToady> the distributive nature of quantifiers is just one of those Facts of Life you have to deal with

[18:50] <dalek> ecosystem: 8193f44 | (Andrew Egeler)++ | META.list:

[18:50] <dalek> ecosystem: Add Net::IMAP

[18:50] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/8193f448d8

[18:50] <TimToady> and please don't anyone argue that in the case of a single () we should drop the lexically scoped array; that would be an unacceptable discontinuity in my book, and a bug waiting to happen as soon as you add another ()

[18:55] <TimToady> () is in the category of simple tools that people are tempted to overuse, along with placeholders and junctions

[18:56] <TimToady> It would be amazing to see a drill-press built out of screwdrivers, but I don't recommend the attempt.

[18:56] <vendethiel> (makes sense)

[18:57] <TimToady> nevertheless, just because you could theoretically use a drill-press to turn a screw doesn't mean we don't need screwdrivers too.

[18:58] <vendethiel> m: my regex bar { \N+ };  "ABC" ~~ /<bar>+/; say $<bar>[0]

[18:58] <camelia> rakudo-moar 17f4ee: OUTPUT«｢ABC｣␤␤»

[18:58] <vendethiel> TimToady++ # consistency

[18:59] <TimToady> well, that particular consistency was TheDamian's fault, mostly

[18:59] <vendethiel> TheDamian++ then

[18:59] <timotimo> mhm

[19:08] *** hoverboard joined
[19:08] *** ssutch joined
[19:10] *** raiph left
[19:14] *** ssutch left
[19:17] <raydiak> timotimo: I have a little time today and hopefully more later in the week; which perl6-bench-related thing do you think I ought to work on?

[19:17] <lue> TimToady: yeah, and I even think it's better than a freeform collection of positional captures, I'm just bad with my initial reactions to unexpected spec behavior it seems :P .

[19:21] *** denis_boyun__ joined
[19:23] *** denis_boyun left
[19:30] <lizmat> Mouq: it looks like your last patch makes t/spec/integration/advent2012-day06.t hang  :-(

[19:31] <lizmat> even *before* plan, it seems

[19:35] <dalek> roast: 7084b8b | (Elizabeth Mattijsen)++ | S17-concurrency/ (2 files):

[19:35] <dalek> roast: Unfudge now passing timer related tests

[19:35] <dalek> roast: 

[19:35] <dalek> roast: jnthn++

[19:35] <dalek> roast: review: https://github.com/perl6/roast/commit/7084b8bd91

[19:39] *** sqirrel joined
[19:43] <timotimo> raydiak: i'd like the system for mashing data together, or the one that globally shows/hides individual pieces

[19:44] <timotimo> or ... whatever seems most useful for you to be doing at the moment :)

[19:47] <lizmat> seems  t/spec/integration/advent2012-day06.t  also sometimes hangs  ?

[19:48] *** sqirrel left
[19:50] <dalek> rakudo/nom: 4a1e6a7 | (Elizabeth Mattijsen)++ | t/spectest.data:

[19:50] <dalek> rakudo/nom: Skip integration/advent2012-day(6|10).t for now

[19:50] <dalek> rakudo/nom: 

[19:50] <dalek> rakudo/nom: The seem to hang since 17f4ee310239e1dd3d84c2205e479fdce8a7b966

[19:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4a1e6a78ad

[19:51] <lizmat> .tell Mouq seems your last patch introduces hangs in the advent2012, day 6/10, disabled them for now

[19:51] <yoleaux> lizmat: I'll pass your message to Mouq.

[19:53] <raydiak> timotimo: I'll give the global visibility toggles a shot today

[19:56] <dalek> specs: 05ea68b | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[19:56] <dalek> specs: Add examples for Supply.(merge|zip)

[19:56] <dalek> specs: review: https://github.com/perl6/specs/commit/05ea68b369

[19:58] *** raiph joined
[20:09] *** ssutch joined
[20:12] *** gaussblurinc_ joined
[20:14] *** ssutch left
[20:19] <dalek> perl6.org: 5f5fbce | raiph++ | source/documentation/index.html:

[20:19] <dalek> perl6.org: Delete dead link. Add perl6 video channel link.

[20:19] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/5f5fbcedb8

[20:26] <lizmat> .tell jnthn the problem with on -> EnumMap seems to have moved to the "done" section

[20:26] <yoleaux> lizmat: I'll pass your message to jnthn.

[20:26] <lizmat> .tell jnthn so subs seem to work ok now, but blocks seem to lose $res

[20:26] <yoleaux> lizmat: I'll pass your message to jnthn.

[20:28] <dalek> roast: c0f33ab | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[20:28] <dalek> roast: Adapt Supply.zip test for subtly changed signature

[20:28] <dalek> roast: 

[20:28] <dalek> roast: Made the zipping operator a named parameter (:with).  This should allow later

[20:28] <dalek> roast: implementation of zipping N supplies rather than just 2

[20:28] <dalek> roast: review: https://github.com/perl6/roast/commit/c0f33abf5d

[20:33] *** zby_home left
[20:43] * jnthn is back

[20:43] <yoleaux> 20:26Z <lizmat> jnthn: the problem with on -> EnumMap seems to have moved to the "done" section

[20:43] <yoleaux> 20:26Z <lizmat> jnthn: so subs seem to work ok now, but blocks seem to lose $res

[20:43] <lizmat> jnthn o/

[20:44] <jnthn> Making folks write the thing in :with(...) feels...icky.

[20:44] <jnthn> Unless there's a sane default.

[20:44] <lizmat> the sane default is &[,]

[20:44] <jnthn> I can go with that.

[20:44] <jnthn> I think.

[20:45] <lizmat> how would you handle zipping multiple supplies otherwise ?

[20:45] <lizmat> with multiple calls to zip ?

[20:45] <lizmat> that feels really icky to me  :-)

[20:46] <jnthn> Well, or passing an array of them, but yeah...

[20:46] <lizmat> working on that now  :-)

[20:46] <jnthn> I mean, you an do the two wiht multi-dispatch.

[20:47] <jnthn> Thankfully, on is built so setup can programmatically build up the list of pairs for things like this :)

[20:47] <lizmat> yes, working on that now as well  :-)

[20:49] <jnthn> Pondering API for signal supplies.

[20:49] <jnthn> signal(SIG_WINCH).tap(...); # maybe too huffman-short for an obscure thing.

[20:49] <lizmat> create a Signal object and .more them into a supply ?

[20:49] <jnthn> Well, signals want exposing as supplies.

[20:49] <lizmat> $*SIGNALS is the Supply for signals ?

[20:50] <jnthn> Why a contextual?

[20:50] <lizmat> good point

[20:50] <lizmat> not sure

[20:50] <lizmat> because $*SCHEDULER is ?

[20:50] *** ajr_ left
[20:50] <TimToady> faking internal signals?

[20:50] <jnthn> Hm, I can see a testing use case.

[20:50] <jnthn> Well, $*SCHEDULER is because there are obvious alternative ones :)

[20:51] <lizmat> true

[20:51] <jnthn> $*SIGNALS is less obvious, but yeah, I can see faking it

[20:51] <jnthn> I guess we put it in PROCESS::<$SIGNALS>

[20:51] <jnthn> TimToady: What would you do with $*SIGNALS?

[20:51] <jnthn> wait, is this actually in spec...

[20:51] * jnthn hunts

[20:52] <lizmat> I waved something about $*POSIX

[20:52] <TimToady> pretend I was on a different OS, maybe

[20:52] <raiph> m: my regex bar { (.)+ }; "ABC" ~~ /<bar>+/; say $<bar>[0][0] #6now #regex #capture #nested see also http://irclog.perlgeek.de/perl6/2014-04-19#i_8612126

[20:52] <camelia> rakudo-moar 4a1e6a: OUTPUT«｢A｣␤ ｢B｣␤ ｢C｣␤␤»

[20:52] <lizmat> S17:757

[20:52] <synopsebot> Link: http://perlcabal.org/syn/S17.html#line_757

[20:52] <jnthn> No, don't see it

[20:52] <jnthn> ah

[20:53] <jnthn> $*SIGNALS is probably nicer

[20:54] * TimToady agrees; to most Unixfolk signals have very little to do with Posix

[20:54] <jnthn> Will it be like $*SIGNALS.winch.tap({ ... }) ?

[20:54] <jnthn> Method per signal?

[20:55] <TimToady> doesn't feel right

[20:55] <jnthn> To me either.

[20:55] <lizmat> well, that would be a new supply using grep

[20:55] <jnthn> What?

[20:55] <jnthn> Oh...

[20:55] <lizmat> my $*POSIX = $*SIGNALS.grep( { $_ ~~ POSIX } );

[20:55] <jnthn> No, you can't implement this by grepping them out.

[20:55] <lizmat> s/my//

[20:56] <lizmat> why not ?

[20:56] <jnthn> Because that's not the way the low level stuff works.

[20:56] <jnthn> Unless you want us to pre-configure a signal handler for everything whether you ever use it or not

[20:56] <TimToady> the OS needs to know which signals have been registered to be caught

[20:56] <jnthn> But that feels wrong.

[20:56] <jnthn> Then we go installing handlers behind the programmer's back.

[20:56] <lizmat> ah, so you want a Supply for each signal ?

[20:57] <jnthn> Yeah.

[20:57] <jnthn> Well, generally you shouldn't care too much for the implementation details.

[20:57] <jnthn> Just that you can get a something for, say, SIG_WINCH that if you tap will notify you about that signal.

[20:58] <lizmat> but should it be called $*SIGNALS then ?

[20:58] <jnthn> I suspect the nqp level will be little more than nqp::signal(nqp::const::SIG_INT) or so.

[20:58] <jnthn> lizmat: Well, that's kinda what made me thing it's a bit odd. :)

[20:59] <lizmat> well, I guess $*SIGNALS could be a merge of all trappable signals

[20:59] <TimToady> sometimes you want to put one signal handler for a bunch of different signals

[20:59] <TimToady> creating a separate suppy for each and merging seems kinda kludgy

[20:59] <lizmat> and have each signal have its own supply

[20:59] <jnthn> TimToady: That's what it's going to be under the hood.

[21:00] <jnthn> TimToady: If we want a convenience method/sub that gives you just a supply, fine by me. :)

[21:00] <lizmat> well, yes, that's why I was thinking about $*SIGNALS, from which you could grep out the ones you want

[21:00] <jnthn> lizmat: But how do we know what to install handlers for?

[21:00] <TimToady> grep is too powerful, you just want a list

[21:00] <jnthn> Handler installation is explicit.

[21:00] <jnthn> s/is/has to be/

[21:00] <jnthn> Aye, agree

[21:02] <jnthn> So in a way signal(SIG_INT, SIG_OHNOES).tap(...); is closer...

[21:02] <dalek> rakudo/nom: c27f546 | (Elizabeth Mattijsen)++ | src/core/Supply (2 files):

[21:02] <dalek> rakudo/nom: Fix named parameter for Supply.zip

[21:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c27f54667f

[21:02] <dalek> rakudo/nom: 22ca110 | (Elizabeth Mattijsen)++ | src/core/Supply.pm:

[21:02] <dalek> rakudo/nom: "on" can have multiple supplies with same effect

[21:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/22ca110212

[21:03] <lizmat> can you have multiple taps on the same signal?

[21:03] <jnthn> Sure

[21:04] <jnthn> libuv even makes that bit easy

[21:04] *** gaussblurinc_ left
[21:05] * jnthn wonders how stable signal numbers are across platforms...

[21:05] <lizmat> so signal(...) creates a Supply, right ?

[21:05] <lizmat> (not)

[21:07] <jnthn> aye

[21:07] <jnthn> Underneath it'll be something like

[21:08] <jnthn> Supply.merge(@sigs.map({ sig_supply(nqp::signal(+$_)) })

[21:09] * TimToady hopes .merge is smart enough to optimize itself away when there's only one

[21:09] <lizmat> working on that  :-)

[21:10] *** ssutch joined
[21:10] <TimToady> unless, of course, a merged supply can have things added to it

[21:10] <lizmat> I'm not seeing that happen easily  :-(

[21:11] <jnthn> No, that's not the way you'd do it

[21:11] <jnthn> That'd more like having a supply of supplies.

[21:11] <TimToady> well, we have SetHashes...

[21:11] <jnthn> And things like the Rx switch combinator to migrate between them...

[21:11] <TimToady> so we do mutable/immutable in other spots

[21:12] *** denis_boyun__ left
[21:12] <jnthn> True. We could probably do something like it but I don't know that merge is the right place.

[21:12] <TimToady> just thinking about folks who want to write a registry of desired supplies, and how they add to it

[21:13] <TimToady> maybe it's not such a performance issue for supplies as it is for sets

[21:13] *** zakharyas joined
[21:14] *** ssutch left
[21:15] <TimToady> just don't want to assume that supplies are always immutable without a bit of thinking

[21:16] <TimToady> .oO(it's reactive programming, it's just not reactive reactive programming...)

[21:17] * TimToady mutates to a nap state &

[21:17] <jnthn> TimToady: Well, reactive reactive is generally handled by having a supply of supplies :)

[21:17] <jnthn> nap well :)

[21:22] <masak> lue++ # pushing the limits with https://rdstar.wordpress.com/2014/04/19/about-those-slangs/

[21:22] <lue> jnthn: ooc, what does Windows have in the way of signals?

[21:24] <jnthn> lue: https://github.com/joyent/libuv/blob/master/include/uv.h#L1940

[21:24] <lue> masak: was I right in my thought that quasi is supposed to be an independent way of generating AST? 'cos if so I think I finally see what the point of quasi is :) .

[21:24] <lue> thanks jnthn

[21:27] <lizmat> m: my @a=<a b>; { @a => 1 }.perl.say   # wish { } would upgrade to a typed Hash when needed :-(

[21:27] <camelia> rakudo-moar 4a1e6a: OUTPUT«{"a b" => 1}␤»

[21:28] *** Rotwang left
[21:35] *** itz joined
[21:37] *** itz_ left
[21:38] *** itz___ left
[21:38] *** itz_ joined
[21:38] *** LLamaRider joined
[21:38] *** rindolf left
[21:38] <masak> lue: yes, you are right in so thinking.

[21:39] * lizmat just finds out there are no direct tests for on -> yet  :-(

[21:39] <lue> so I could theoretically do  augment class Perl6::Actions { method thing($/) { make quasi { } } }  then? :)

[21:40] <masak> yes.

[21:40] <masak> lue: though let me save you some future head-scratching by saying that a quasi is actually made of two things: (a) the AST of the code it contains and (b) the context/scope it was evaluated in.

[21:40] <masak> in your case above, it shouldn't matter. but it could.

[21:41] <lue> yeah, I faintly recall your post about scoping and macros, that makes sense.

[21:41] <masak> m: macro hi { my $x = 42; quasi { say $x } }; my $x = 5; hi

[21:41] <camelia> rakudo-moar 22ca11: OUTPUT«42␤»

[21:41] <masak> m: macro hi { my $x = 42; quasi { say $COMPILING::x } }; my $x = 5; hi # doesn't work yet

[21:41] <camelia> rakudo-moar 22ca11: OUTPUT«(Any)␤»

[21:42] <lizmat> jnthn: any idea why on -> $res { @s => { more {....  would create a "cannot stringify this" error ?

[21:42] <lizmat> masak: shouldn't that be $?COMPILING ?

[21:43] <lizmat> Ah no, I guess not, it's the compiling namespace at BEGIN time

[21:43] <lue> I took a glance a elisp macros last night to try to better understand macros in general, and I'm hoping the quick takeaway of "code in, code out" (as opposed to "values in, values out") helps me with Perl 6 :) .

[21:43] <jnthn> lizmat: Not really... :S

[21:43] <jnthn> lizmat: Though, I'm rather surprised to see an array there

[21:44] <jnthn> That's not how I planned it.

[21:44] <lizmat> ah, I'm subverting your plan

[21:44] <jnthn> Well, you're making it so you need to make a load of changes to OnSupply

[21:44] <lizmat> not really, I don't think

[21:44] <jnthn> Whereas if you write it as on -> $res { @s.map({ { more => { ... } });

[21:45] <lizmat> see  https://github.com/rakudo/rakudo/commit/22ca110212

[21:45] <jnthn> uh, not quite quote, sorry

[21:45] <jnthn> Whereas if you write it as on -> $res { @s.map({ $_ => { more => { ... } });

[21:45] <jnthn> s/quote/that/

[21:46] <jnthn> I...don't see how that patch is working

[21:46] <masak> lizmat: yeah. S06 has it as $COMPILING::x

[21:46] <jnthn> oh...

[21:46] <jnthn> for $tap.key;

[21:46] <jnthn> That that somehow magically work on items?

[21:47] <jnthn> *Does that

[21:47] <lizmat> ah, you mean the problem is in the 'for $tap.key' ?

[21:47] <jnthn> grr, typing fail

[21:47] <jnthn> Well, all the usages at present are

[21:47] <jnthn> $supply => { ... }

[21:47] <jnthn> Meaning you end up calling $supply.key

[21:48] <jnthn> Which I would imagine blows up?

[21:48] <jnthn> oh, no

[21:48] <jnthn> Hmm

[21:48] <jnthn> No, it's just gonna .list it

[21:48] <jnthn> It should work.

[21:49] <lizmat> right, that's what I thought

[21:49] <jnthn> yeah, I misread

[21:49] <lizmat> short and to the point  

[21:49] <jnthn> yeah, and end-weightier than I can apparently read right now ;)

[21:49] <lizmat> should I move the sub below the for?

[21:49] <jnthn> Anyway, it's less work than I thought it might be.

[21:50] <lizmat> except that it doesn't work  :-(

[21:50] <jnthn> Well, no, it was just the normal for on the output and then a statement modifier one on the inside that threw me...

[21:50] <jnthn> Well, does it pass all tests it did before tha patch?

[21:50] <lizmat> well, yes

[21:50] <jnthn> Is it that patch that's at issue, or what you're tyring to build on top of it?

[21:50] <lizmat> but then I found out there are *no* tests specifically for "on" atm

[21:50] <jnthn> Right, it's tested implicitly through merge and friends.

[21:51] <lizmat> yup

[21:51] <lizmat> and merge doesn't work because of the other issue 

[21:51] <lizmat> it now says "can't call done on null object" when it gets to the done

[21:51] <lue> masak: I just realized something: slangs (are supposed to) allow you to modify the grammar of the language, with poor support for implementing the actions; macros allow you to modify the actions of the language, with poor support for implementing the grammar (just a lowly is parsed)

[21:52] <lizmat> so I think I'm going to get some sleep first

[21:52] <lue> masak: think there's something to be said about maybe connecting slangs and macros somehow?

[21:52] <lizmat> then add tests for 'on'

[21:52] <lizmat> and take it from there

[21:53] <jnthn> lizmat: OK, sounds good.

[21:53] <jnthn> lizmat: I'll be about tomorrow.

[21:53] <lizmat> okidoki!  gnight, jnthn and #perl6!

[21:54] <jnthn> 'night, lizmat 

[21:55] <lizmat> one more datapoint:

[21:55] <lizmat> cannot stringify this

[21:55] <lizmat>    at src/gen/m-BOOTSTRAP.nqp:846  (blib/Perl6/BOOTSTRAP.moarvm:bind_sig:129)

[21:55] <lizmat> now really sleep&

[21:56] <masak> lue: it's an interesting thought, but not one I can comment intelligently on.

[21:57] <masak> lue: I always kind of had it as "normal (non-macro) programming gets you *this* far, macros get you *this* much further, and if you need more, use slangs". but the lines may be blurrier and more fractal than that.

[21:59] <masak> lue: currently, macros are not awesome enough to be worthy of Perl 6. even if/when I complete the macros grant, they won't be of much interest. they have the "generate" aspect but lack the "analyze and typecheck" aspects.

[22:00] <raiph> does anyone here have admin privs on feather (other than juerd)?

[22:00] <lue> quasi { } gets us the high-level AST generator slangs need, at least.  .oO( slang Foo { rule TOP { ... }; macro/method TOP($/) { make quasi { } } })

[22:01] <masak> lue: quasi lets you reliably build ASTs. but after that, they are opaque. there's no spec'd way to take an AST apart and pull out the interesting bits.

[22:01] <lue> I think the most difficult point about slangs is how to stay independent of any implementation's rule names (we could just standardize the names, but I feel that's the boring solution :P)

[22:02] <lue> I did say "generator", no? :) But being able to pick apart the AST would be helpful in higher action methods. Hrm...

[22:03] *** pippo_ joined
[22:03] <masak> there are many possible macros I can imagine that would act on a block of code, going into that block and making appropriate modifications. by current spec, that's not possible.

[22:04] <masak> lue: yes, the thing about grammar rule names is a tricky one.

[22:04] * vendethiel -- AST traversal is hard without s(-like, i.e. d or m)-expressions

[22:04] <lue> Too bad the X:: method of solving string differences is harder to apply here :)

[22:05] <masak> lue: also, it seems to me there will be composition nightmares in some cases if several slangs went in and modified the same rule/action. protoregexes help a little here, but not enough.

[22:05] <lue> .oO(hygienic slangs)

[22:05] <jnthn> We also need to be careful not to box ourselves in in the long-term.

[22:05] <masak> vendethiel: here in Perl-land, we smile at "hard" and crack our knuckles ;)

[22:06] <jnthn> QAST is perhaps too low level anyway.

[22:06] <masak> yeah.

[22:06] <masak> that's largely my thinking lately.

[22:06] <masak> I'm pondering at what level I *want* to write those things.

[22:06] <jnthn> But I think it'd also be bad for Perl 6 implementations to tie them down that much.

[22:06] <masak> and my current answer is "at the Dijkstra level" :>

[22:07] <vendethiel> well, using QAST blocks mean it's implementation-dependent, doesn't it ?

[22:07] <vendethiel> (I mean "building blocks")

[22:07] <masak> yeah.

[22:07] <lue> .oO(CAST::Stmt.new(CAST::EXPR.new(EVAL("1+2"))))

[22:07] <masak> QAST basically ties it to Rakudo.

[22:08] <FROGGS> we just need to spec QAST as AST. done.

[22:08] <FROGGS> :P

[22:09] <masak> you jest, but it's one of the alternatives here.

[22:09] <jnthn> If you tie it to QAST, you also tie it to the specifics of how we currently choose to code-gen stuff.

[22:09] <masak> though I doubt it'd be agood long-term one.

[22:09] <masak> QAST has a certain minimalism to it, which does not help the macro author in the slightest.

[22:09] <lue> Yeah, I'd much rather invent a higher "Camelia AST" or something.

[22:10] <masak> I don't want to fiddle with an AST at all, preferably.

[22:10] <FROGGS> what else should the actions generate?

[22:10] *** ssutch joined
[22:11] <lue> If you're writing a grammar, you kinda have to (unless you used quasi { } of course)

[22:11] <masak> until someone invents something more high-level :)

[22:11] <masak> think of it as something akin to jQuery.

[22:11] <FROGGS> let's say you parse a term, and op and a term...

[22:11] <masak> jQuery avoids most of the low-level DOM drudgery.

[22:11] <vendethiel> .oO(jQuery-flavored macros)

[22:11] <masak> yeah.

[22:12] <vendethiel> .oO(perl6().new.end())

[22:12] <vendethiel> (ewww)

[22:12] <FROGGS> xml compliant textual macros?

[22:12] <masak> I want to do transformations like "go into the second loop" or "find all variable declarations, recursively in all nested blocks".

[22:12] <lue> High Level Syntax Tree?

[22:13] <lue> masak: it sounds like you want another language on the braid :) --- that might make some nice symmetry with the Regex lang, actually.

[22:13] <vendethiel> really, perl6-xpath :)

[22:13] <masak> lue: not really. just an API.

[22:14] <LLamaRider> So you want a jQuery-style abstraction over an XPath-style selector language over the Perl6 AST? (trying to understand the setup)

[22:14] <vendethiel> not sure the jquery-style stuff is neded :))

[22:14] <masak> LLamaRider: I don't know exactly what I want. just toying with ideas and analogies so far.

[22:15] <masak> what I really want is to be able to talk about the transformations macros usually make, at a level the author is comfortable thinking.

[22:15] *** ssutch left
[22:15] <lue> .oO( astlang { for @scopes { say $_ for @variables».name } } )

[22:15] <masak> that's why I brought up jQuery, because it ups the level of DOM exploration/manipulation to a level where it's fun rather than dull/painful.

[22:16] *** zakharyas left
[22:16] <LLamaRider> yeah the HTML and XML philosophies about doing things are usually completely opposed - jQuery/CSS selectors opts for pragmatic and usable, XPath/XQuery opts for formally beautiful

[22:16] <masak> also, as I've been thinking about CSP transforms in the past few days, I've realized how *control flow* simply doesn't have a meta-level API to hook into, and how having that would benefit macros a lot.

[22:17] <lue> masak: I can definitely get behind a more functional than imperative actions-side thing.

[22:17] <masak> LLamaRider: I don't care much for XML in general, but I do remember liking the feel of XPath. it's delightfully informal, especially compared to things like XSLT.

[22:18] <FROGGS> lue: btw, have you seen my comments to your blog?

[22:18] <lue> FROGGS: I haven't, let me see

[22:18] <vendethiel> masak: "new" tools are better than jquery

[22:19] <vendethiel> Xpath is something that really ought to die

[22:19] <vendethiel> (and by "new tools" I mean new DOM Thingies)

[22:19] <FROGGS> can we bury XML in the same run?

[22:20] *** hoverboard left
[22:21] <lue> FROGGS: that's interesting, slangs do indeed feel more like a collection of things to me.

[22:22] <lue> the obvious solution to crossing the NQP/Perl6 boundary is to write the grammar and everything in pure Perl 6, of course :P

[22:22] <FROGGS> yeah, I would really love to turn the grammar and actions into one thing... but I don't see a nice way besides what I have posted

[22:22] <FROGGS> lue: that is the problem, since Perl6's grammar is in nqp

[22:23] <FROGGS> so you cross an NQPCursor vs Cursor boundary when switching slangs

[22:23] <lue> we need to bootstrap the grammar like we do the various types. Problem solved! :)

[22:23] <masak> vendethiel: are you able to be more specific than "new tools" and "new DOM Thingies"?

[22:23] <vendethiel> masak: simply, querySelector{,All}

[22:24] <LLamaRider> So, Scala for example has native XML support, where you can mix XML content in Scala code.

[22:24] <vendethiel> I really think `$('a').find('foo').end()` looks silly.

[22:24] <masak> vendethiel: ok.

[22:24] <LLamaRider> The way I see it, you've got a bunch of trees regardless of what representation you're working with (XML or P6 AST or wtv.)

[22:25] <masak> LLamaRider: yes, sure. but you can implement the interface in many different ways.

[22:25] <LLamaRider> If P6 had an efficient low-level tree processing language (e.g. an XPath implementation) you could define higher level languages on top of that

[22:26] <vendethiel> Oh, I thought scala required "import scala.xml._" nowadays

[22:26] <LLamaRider> vendethiel: That's kinda-sorta native for me :)

[22:26] <vendethiel> Well, it doesn't even need the import

[22:27] <LLamaRider> masak: But I think it is a good observation that different languages will need different high-level shorthand selectors

[22:28] <masak> LLamaRider: I'm not sure that was my observation :)

[22:28] <LLamaRider> masak: The way HTML benefits from jQuery. XPath is very generic in comparison

[22:29] <LLamaRider> masak: sorry to misinterpret then -- my interpretation of your observation evaluated to the above >:-)

[22:29] <masak> I want a clean, Perlish, slightly awe-inspiring way to make the easy macro manipulations of programs easy, and the hard manipulations possible.

[22:29] <masak> I'm currently fishing for possibilities, and throwing around analogies, but I'm nowhere near proposing a solution.

[22:29] <lue> masak: if you could provide a dummy perl6 file showing off how you'd like ast traversals, that'd be cool. I offhandedly tried myself, but what came to me at first wasn't very good :P.

[22:30] <masak> lue: not ready to do that yet, I think. :)

[22:30] <masak> but I'll keep it in mind.

[22:31] <LLamaRider> having a nice practical task to solve would probably be very helpful for brainstorming

[22:31] * lue wonders if a cousin to EVAL() called COMPILE() or such would be helpful for macros... macro(Str $code) { my &a = COMPILE($code) }

[22:32] <LLamaRider> Could an P6 IDE use such a selector language to e.g. rewrite CamelCase variables into underscore_vars?

[22:32] <LLamaRider> that's probably way too simplistic to show off selectors though...

[22:32] <masak> here's what we know. a compiler is a thing that takes the program text and turns it into runnable bytecode. let's identify three stages: (1) text to AST [parsing], (2) AST to AST [optimization, analysis, correctness checks, macros], (3) AST to bytecode [code gen]

[22:33] <masak> an 'is parsed' macro operates at (1). let's forget about those for now. they are nifty and dangerous, but I feel like handling the other stuff first.

[22:34] <masak> an AST macro operates at (2). ASTs are deeply involved here. but I don't find myself *thinking* in terms of ASTs. quasis are kind of an acknowledgement of that. it's much nicer to write the code than to write the AST for the code.

[22:34] <lue> ('is parsed' might be just plain wrong, actually. It feels disproportionately small for a big thing like "new regex for the grammar")

[22:35] <masak> similarly (I opine), it would be much nicer to write "code transformations" than "AST transformations".

[22:35] <masak> but that's basically hand-waving.

[22:36] <masak> lue: I think 'is parsed' will end up being considered one of those safety valves, for when you can't be neat and do things the right way for some reason.

[22:36] <LLamaRider> ( masak: you mean similarly to the way ORMs replace verbatim SQL ?)

[22:36] <lue> nod

[22:36] <masak> lue: there will be purists who say "never" and pragmatists who reply "it's useful, just don't DIHWIDT it"

[22:37] <masak> LLamaRider: maybe.

[22:37] <lue> masak: could it be a simple as a new Routine- (or Callable-, or ...) based class, one that can do those code transforms?

[22:37] <masak> LLamaRider: there's something to that analogy, even if it isn't perfect.

[22:38] <FROGGS> I'd like to have macros where I would emit (Q)AST directly and not via code... but I fiddle with QAST often, so I might not be the regular user

[22:38] <FROGGS> and yes, when I see code I'm kind of thinking in QAST

[22:39] <FROGGS> so when I currently write a macro I am translating the code to QAST in my head to understand what it does

[22:39] <LLamaRider> In the middle of the forest all you see is trees :)

[22:40] <LLamaRider> I can relate to that when it comes to munging XML

[22:40] <lue> .oO(&code.variables.=scope(:our))

[22:41] <lue> or rather, ».= :)

[22:42] <LLamaRider> jQuery feels more fluent when you want to intermix some procedural logic with the DOM manipulation though

[22:47] *** kurahaupo left
[22:47] *** kurahaupo joined
[22:48] <dalek> nqp/asyncops: 0ef8041 | jnthn++ | tools/build/MOAR_REVISION:

[22:48] <dalek> nqp/asyncops: Bump to a MoarVM with timers.

[22:48] <dalek> nqp/asyncops: review: https://github.com/perl6/nqp/commit/0ef804140f

[22:48] <dalek> nqp/asyncops: 5fbd68b | jnthn++ | docs/ops.markdown:

[22:48] <dalek> nqp/asyncops: Docs nqp::timer and other coming-soon async ops.

[22:48] <dalek> nqp/asyncops: review: https://github.com/perl6/nqp/commit/5fbd68b0f1

[22:48] <dalek> nqp/asyncops: b397114 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[22:48] <dalek> nqp/asyncops: Map async nqp::ops for MoarVM.

[22:48] <dalek> nqp/asyncops: review: https://github.com/perl6/nqp/commit/b3971142cb

[22:57] <masak> or, here, like this.

[22:57] <masak> if you go back and read Dijkstra's "Go To Statement Considered Harmful", then you see that he's advocating for restricting `goto`, not banishing it.

[22:58] <masak> the restrictions are in the forms of `if` and `while` and `given` statements, constructs that we take for granted 40 years later but that weren't as widely accepted back then.

[22:59] <masak> most of the time you get by with the structured variants, and you can ignore `goto`. in those remaining 0.2% of the cases, you use a `goto` and get on with life. but structured programming saves a lot of head-scratching and puts us on a safe path.

[23:00] <masak> I posit that working directly on ASTs, besides being potentially implementation-specific, is a bit like worrying about individual `goto`s in your code: too low-level.

[23:01] <masak> what I want to worry about is the next level up: breaking out of a loop, or building a conditional, or moving a piece of code to after another.

[23:01] *** xenoterracide left
[23:02] <masak> if goto : structured_programming :: AST_transforms : <X>, then I posit that we need <X> for macros.

[23:02] <masak> (but we might still want to expose AST transforms, for those last 0.2% of the cases)

[23:02] <lue> masak: I wonder if Lisp or any of the other languages with Awesome Macros has anything resembling those higher level AST transforms you want, or if we have to make it up ourselves :)

[23:03] <masak> lue: as far as I know, Lisp avoids that by saying "the code *is* the AST".

[23:04] <lue> which is easy when you have basically one syntax rule :P

[23:06] <masak> right.

[23:06] <masak> Lisp's macros thrive on that syntactic simplicity.

[23:07] <lue> (incidentally I think Lisp's macros may be easy to implement as a feature, but it's hard to see as immediately what value they have over lisp functions, because they look the same at-a-glance. Hopefully Perl 6 will avoid the issue.)

[23:09] <LLamaRider> masak: I'm wondering when does one do AST manipulation in a macro, and when in a regular subroutine? 

[23:09] <LLamaRider> I'm still trying to catch up to you guys, but it's definitely an interesting discussion :) sorry to lag behind

[23:11] <lue> masak: AFAICT, lisp-style macros (which are the only ones I know of that are like what we want) tend to just manipulate low-level-ish representations of code, which we don't want. I'll do more searching, but it's just maybe possible we're being new here :P

[23:13] <masak> LLamaRider: subroutines generally don't deal in ASTs, because subroutines tend to be runtime, AST manipulation compile-time.

[23:14] <masak> LLamaRider: of course, that's not a hard-and-fast rule. a macro could easily use a subroutine as a helper, provided the macro occurs textually after the sub. but so far I've never needed that.

[23:15] <LLamaRider> masak: Oooh, ok, I was thinking of something completely different. Such as a P6 IDE, written in P6, refactoring code in runtime, which it is manipulating as an AST

[23:16] <LLamaRider> What you're discussing sounds somewhat more related to compile-time optimizations of the AST by some efficient rewrites, though I won't be surprised to be off again.

[23:17] *** pippo_ left
[23:18] <lue> masak: did you use this page on a theoretical macro thing for D as an inspiration? :)  https://dl.dropboxusercontent.com/u/18386187/ast_macros.html

[23:18] <masak> LLamaRider: we're talking about Perl 6 macros, and what they would tend to do, and how.

[23:19] <masak> lue: no. reading now.

[23:20] <vendethiel> I have quite the list of stuff around meta-programming, if anybody's interested. https://gist.github.com/Nami-Doc/7133634

[23:20] <masak> hm. having *separate* ASTs for each argument is nicer, actually. we should have that.

[23:21] <masak> vendethiel: thank you. will peruse.

[23:21] * vendethiel -- hhm, I really need to keep that list up to date

[23:22] <lue> [ masak: in case you didn't see it, the page just so happened to mention things like "the context in which the macro was called" and "quasi-quoting", which seemed like your macro stuff :) ]

[23:22] <masak> lue: it has clear similarities.

[23:23] <masak> lue: they use things like 'val' for the actual value captured, and '$val' for its AST, it seems.

[23:23] <masak> lue: no, wait. 'val' is an AST too.

[23:23] <masak> lue: but they have both .eval and .toString methods on the AST.

[23:24] <lue> I think their <[$thing]> is our quasi { {{{$thing}}} } , but I could be wrong

[23:24] <vendethiel> Dylan is really interested because it has "d-expressions" (not lisp-like syntax)

[23:25] <vendethiel> for "macros in scripting languages", I know of sweet.js (for JS) and macropy for python

[23:26] *** ssutch joined
[23:26] <masak> TimToady: I like the idea of "statement macros". it would make a lot of use cases easier, I think.

[23:26] * vendethiel doesn't know of any "successful" project to bring macros to perl, ruby or php

[23:27] <lue> masak: same here, you'd need to use 'is parsed' all the time otherwise.

[23:27] <vendethiel> masak: Honu-style macros look really cool : https://github.com/mozilla/sweet.js/pull/296

[23:28] <vendethiel> (there should be a paper in the list about it, too)

[23:30] <masak> vendethiel: meh -- looks less advanced than the operator overloading we already have in Perl 6. and which already works seamlessly with macros.

[23:30] <vendethiel> masak: you mean the PR ?

[23:30] <masak> yeah.

[23:31] <vendethiel> well, the main difference is what you can use as body, of course

[23:31] <masak> m: macro infix:<+++>($x, $y) { say "compile-time, baby!"; quasi { {{{$x}}} + {{{$y}}} } }; say "OH HAI"; say 40 +++ 2

[23:31] <camelia> rakudo-moar 22ca11: OUTPUT«compile-time, baby!␤OH HAI␤42␤»

[23:31] <vendethiel> other than that, perl 6 has definitely a big advantage

[23:32] <masak> m: macro infix:<+++>($x, $y) { say "compile-time, baby!"; quasi { {{{$x}}} + {{{$y}}} } }; say "OH HAI"; say 40 +++ 2; say 30 +++ 5

[23:32] <camelia> rakudo-moar 22ca11: OUTPUT«compile-time, baby!␤compile-time, baby!␤OH HAI␤42␤35␤»

[23:32] <masak> 'night, #perl6

[23:32] <vendethiel> 'night, masak

[23:32] <lue> ♞ masak o/

[23:32] *** LLamaRider left
[23:32] <vendethiel> .u ♞

[23:32] <yoleaux> U+265E BLACK CHESS KNIGHT [So] (♞)

[23:33] <vendethiel> (is that a pun ?)

[23:33] <lue> yep :)

[23:33] * Mouq is back

[23:33] <yoleaux> 19:51Z <lizmat> Mouq: seems your last patch introduces hangs in the advent2012, day 6/10, disabled them for now

[23:33] <Mouq> O_o

[23:34] <Mouq> I saw that, I thought it was some else's fault D:

[23:36] <jnthn> 'night, #perl6

[23:36] <Mouq> night jnthn!

[23:38] * woolfy and lizmat already asleep

[23:38] * woolfy is sleepwalking, not really here

[23:38] * woolfy :-)

[23:38] *** AW3i joined
[23:39] *** raiph left
[23:39] *** AW3i left
[23:41] <Mouq> (dwarring+++)

[23:51] <Mouq> I seem to have broken heredocs?

[23:55] <Mouq> No…

[23:56] <Mouq> Ohhh!

[23:56] <Mouq> m: q:to/END/;␤A single quote --> ' <--␤Messes it up bad␤END␤␤say "alive";

[23:56] <camelia> rakudo-moar 22ca11: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/jZcsnhU_yi␤Ending delimiter END not found␤at /tmp/jZcsnhU_yi:6␤------> [32msay "alive";[33m⏏[31m<EOL>[0m␤    expecting any of:␤        whitespace␤        vertical whitespace␤»

[23:57] <Mouq> m: q:to/END/;␤A single quote --> ' <--␤Messes 'it up bad␤END␤␤say "alive";

[23:57] <camelia> rakudo-moar 22ca11: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ZXEQ3q4q4h␤Ending delimiter END not found␤at /tmp/ZXEQ3q4q4h:6␤------> [32msay "alive";[33m⏏[31m<EOL>[0m␤    expecting any of:␤        whitespace␤        vertical whitespace␤»

[23:57] <Mouq> m: q:to/END/;␤A single quote --> () <--␤Messes it up bad␤END␤␤say "alive";

[23:57] <camelia> rakudo-moar 22ca11: OUTPUT«alive␤»

[23:57] *** BenGoldberg joined
[23:57] <lue> m: qq:to/END/;␤A single quote --> ' <--␤Messes it up bad␤END␤␤say "alive";

[23:57] <camelia> rakudo-moar 22ca11: OUTPUT«alive␤»

[23:57] <lue> m: qq:to/END/;␤A single quote --> " <--␤Messes it up bad␤END␤␤say "alive";

[23:57] <camelia> rakudo-moar 22ca11: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/uSnaXmkUhV␤Ending delimiter END not found␤at /tmp/uSnaXmkUhV:6␤------> [32msay "alive";[33m⏏[31m<EOL>[0m␤    expecting any of:␤        whitespace␤        vertical whitespace␤»

[23:58] <lue> m: Q:to/END/;␤A single quote --> ｢ <--␤Messes it up bad␤END␤␤say "alive";

[23:58] <camelia> rakudo-moar 22ca11: OUTPUT«alive␤»

[23:58] <lue> m: Q:to/END/;␤A single quote --> ｣ <--␤Messes it up bad␤END␤␤say "alive";

[23:58] <camelia> rakudo-moar 22ca11: OUTPUT«alive␤»

[23:59] <Mouq> m: qw:to/END/;␤A single quote --> < <--␤Messes it up bad␤END␤␤say "alive";

[23:59] <camelia> rakudo-moar 22ca11: OUTPUT«WARNINGS:␤Useless use of "A single quote --> < <--\nMesses it up bad\n" in expression "A single quote --> < <--\nMesses it up bad\n" in sink context (line 2)␤alive␤»

