[00:10] <timotimo> er ... well volunteered? ;)

[00:15] <[Coke]> zacts: check the logs, prolly not worth it.

[00:16] <[Coke]> you end up having to write a lot of stuff when using llvm.

[00:18] <zacts> oh interesting.. ok

[00:19] <[Coke]> I'm not an expert, but this really is a FAQ.

[00:20] <timotimo> yes, we do get it a lot

[00:20] <timotimo> even the pypy people get it often and i seem to recall they said at one point it's much too low-level for them

[00:20] <timotimo> but i may be misremembering

[00:24] *** thou joined
[00:25] *** btyler joined
[00:36] *** bjz left
[00:37] <[Coke]> irssi question : is there a way to make -some- windows autoscroll, but have others page?

[00:42] *** virtualsue left
[01:02] *** bjz joined
[01:03] <lue> the best hope is implementing a LLVM backend for MVM, from what I hear.

[01:07] *** benabik joined
[01:11] *** rurban joined
[01:16] *** rurban left
[01:23] *** bfulgham_ left
[01:29] *** klapperl_ joined
[01:32] *** bfulgham_ joined
[01:32] *** kurahaupo left
[01:33] *** klapperl left
[01:38] *** BenGoldberg joined
[01:45] *** ilbot3 left
[01:46] *** ilbot3 joined
[01:52] *** hoverboard joined
[02:12] *** rurban joined
[02:17] *** rurban left
[02:17] *** hoverboard left
[02:22] *** bfulgham_ left
[02:27] *** xragnar_ joined
[02:27] *** xragnar is now known as Guest48210

[02:27] *** xragnar_ is now known as xragnar

[02:31] *** Guest48210 left
[02:38] *** rindolf joined
[02:53] *** Quom left
[03:01] *** thilp_ left
[03:02] *** rindolf left
[03:02] *** xenoterracide left
[03:12] *** rurban joined
[03:14] *** WJB joined
[03:15] *** thou left
[03:26] *** kaare__ joined
[03:27] *** adu joined
[03:55] *** SamuraiJack joined
[04:19] <lue> My disappearing \x10FFFB problem comes from *something's* .ast method in Pod.nqp's merge_twines (@twines[0] is fine, @twines.shift.ast disappears \x10FFFB and \x10FFFC). But because nqp isn't willing to print typenames, I have no clue where the actual problem is :/

[04:19] * lue afk for a bit

[04:25] *** [Sno] left
[04:27] *** kaare__ left
[04:32] *** rurban left
[04:41] <moritz> good morning

[04:41] <JimmyZ> morning

[04:41] <moritz> nqp: my $x = 'foo'; say($x.HOW.name($x)); # print type names in NQP, for lue

[04:41] <camelia> nqp-jvm: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " 'foo'; sa"␤  in panic (gen/jvm/stage2/NQPHLL.nqp:396)␤  in infix:sym<=> (gen/jvm/stage2/NQP.nqp)␤  in !protoregex (gen/jvm/stage2/QRegex.nqp:791)␤  in infix (gen/jvm/stage2/NQPHLL.nqp)…»

[04:41] <camelia> ..nqp-parrot: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " 'foo'; sa"␤current instr.: 'panic' pc 15634 (gen/parrot/stage2/NQPHLL.pir:5766) (gen/parrot/stage2/NQPHLL.nqp:425)␤»

[04:41] <camelia> ..nqp-moarvm: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " 'foo'; sa"␤   at gen/moar/stage2/NQPHLL.nqp:369  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/NQPHLL.moarvm:panic:105)␤ from <unknown>:1  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/n…»

[04:41] <moritz> nqp: my $x := 'foo'; say($x.HOW.name($x)); # print type names in NQP, for lue

[04:41] <camelia> nqp-moarvm, nqp-jvm: OUTPUT«BOOTStr␤»

[04:41] <camelia> ..nqp-parrot: OUTPUT«Can only use get_how on a SixModelObject␤current instr.: '' pc 46 ((file unknown):63646681) (/tmp/tmpfile:1)␤»

[04:48] <moritz> (just don't use parrot)

[04:49] <lue> If I was compiling more than just perl6-m for this, it would be so much more unbearable to debug right now :)

[04:49] <lue> I tried $thing.HOW(Mu).name before, and it didn't work. Looks like I got it wrong :)

[04:49] *** kaleem joined
[04:50] <BenGoldberg> nqp: say("foo".HOW.name("bar"))

[04:50] <camelia> nqp-moarvm, nqp-jvm: OUTPUT«BOOTStr␤»

[04:50] <camelia> ..nqp-parrot: OUTPUT«Can only use get_how on a SixModelObject␤current instr.: '' pc 43 ((file unknown):61911943) (/tmp/tmpfile:1)␤»

[04:50] <BenGoldberg> nqp: say(42.HOW.name(53))

[04:50] <camelia> nqp-parrot: OUTPUT«Can only use get_how on a SixModelObject␤current instr.: '' pc 43 ((file unknown):42015783) (/tmp/tmpfile:1)␤»

[04:50] <camelia> ..nqp-moarvm, nqp-jvm: OUTPUT«BOOTInt␤»

[04:50] <BenGoldberg> nqp: say(42.HOW.name("mismatch?"))

[04:51] <camelia> nqp-moarvm, nqp-jvm: OUTPUT«BOOTInt␤»

[04:51] <camelia> ..nqp-parrot: OUTPUT«Can only use get_how on a SixModelObject␤current instr.: '' pc 43 ((file unknown):45329095) (/tmp/tmpfile:1)␤»

[04:55] *** aindilis joined
[04:58] *** kaare__ joined
[05:03] *** rurban joined
[05:05] *** rurban1 joined
[05:08] *** rurban left
[05:10] *** rurban1 left
[05:14] *** adu left
[05:30] *** BenGoldberg left
[05:30] *** adu joined
[05:31] *** perigrin left
[05:31] *** perigrin joined
[05:33] *** aborazmeh joined
[05:34] *** geekosaur joined
[05:35] *** sftp_ is now known as sftp

[05:43] *** kaleem left
[05:48] *** araujo left
[05:49] *** btyler left
[06:01] <TimToady> hi guys, you're on screen at PerlChina

[06:05] <adu> are you?

[06:05] <TimToady> indeed

[06:06] <adu> am I?

[06:06] <TimToady> yes, you are :)

[06:06] <adu> oh, then I better be quiet :)

[06:06] <TimToady> type some Chinese if you know how!

[06:07] <adu> 日本語だけわかります

[06:08] <lue> ♘ #perl6, perhaps tomorrow I'll fix MoarVM's Unicode problems :)

[06:08] <TimToady> 谢谢

[06:09] <TimToady> signing off now

[06:11] <TimToady> well, maybe not quite yet...they're all signing a book for me :)

[06:11] <adu> lol

[06:11] <TimToady> a dictionary

[06:12] <adu> 頑張る is my favorite Japanese word, do the characters mean the same thing in Chinese?

[06:14] *** dayangkun joined
[06:14] <sergot> morning o/

[06:16] <TimToady> good morning, signing off now for reals :)

[06:16] <adu> l8r

[06:17] *** adu left
[06:24] *** kaleem joined
[06:25] *** dayangkun left
[06:27] *** darutoko joined
[06:34] *** raiph left
[06:38] *** dayangkun joined
[06:43] *** Alina-malina left
[06:43] *** Alina-malina joined
[07:00] *** zakharyas joined
[07:04] <jnthn> morning, folks o/

[07:05] *** dmol joined
[07:06] <TimToady> jnthn: o/

[07:06] *** eMBee joined
[07:06] <TimToady> you're on screen in china

[07:06] <eMBee> hello

[07:07] *** rurban joined
[07:08] <jnthn> m: say "Hi, folks in China!" # :)

[07:08] <camelia> rakudo-moar eb8575: OUTPUT«Hi, folks in China!␤»

[07:11] * eMBee is in china too, watching the channel

[07:11] <eMBee> if you have any questions for the audience, or larry, i can pass them on

[07:12] <eMBee> you are on the screen now

[07:12] *** rurban left
[07:14] *** brrt joined
[07:15] <TimToady> m: say (1,2,3) >>+<< (10,20,30)

[07:15] <camelia> rakudo-moar eb8575: OUTPUT«11 22 33␤»

[07:16] <brrt> hi #perl6

[07:16] <TimToady> m: [*] 1..10

[07:16] <camelia> rakudo-moar eb8575: ( no output )

[07:16] <TimToady> m: say [*] 1..10

[07:16] <camelia> rakudo-moar eb8575: OUTPUT«3628800␤»

[07:17] <TimToady> m: sub postfix:<!>($x) { [*] 2..$xx }; say 10!

[07:17] <camelia> rakudo-moar eb8575: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/wVBuKeFrkU␤Variable '$xx' is not declared␤at /tmp/wVBuKeFrkU:1␤------> [32msub postfix:<!>($x) { [*] 2..$xx[33m⏏[31m }; say 10![0m␤    expecting any of:␤        postfix␤»

[07:17] <TimToady> m: sub postfix:<!>($x) { [*] 2..$x }; say 10!

[07:18] <camelia> rakudo-moar eb8575: OUTPUT«3628800␤»

[07:18] <TimToady> m: sub postfix:<!>($x) { [*] 2..$x }; say 1!

[07:18] <camelia> rakudo-moar eb8575: OUTPUT«1␤»

[07:19] <TimToady> m: sub postfix:<!>($x) { [+] 2..$x }; say 1!

[07:19] <camelia> rakudo-moar eb8575: OUTPUT«0␤»

[07:22] <JimmyZ> 下午好

[07:37] *** pdcawley joined
[07:44] * eMBee wonders if larry has any questions for the audience

[07:48] *** ChexMing joined
[07:55] *** salv0 left
[07:55] *** salv0 joined
[08:00] <arnsholt> o/

[08:03] <TimToady> \o talk is done, now just sitting and looking up characters I don't know, which is still a lot of 'em :)

[08:05] <eMBee> it was a great talk. unfortunately my camera battery died halfway through recording it...

[08:06] * eMBee should have brought his webcam... *facepalm*

[08:07] <eMBee> looks like someone else made a recording too. good!

[08:07] *** AW3i joined
[08:08] *** rurban joined
[08:13] *** rurban left
[08:18] <arnsholt> nqp:  my grammar G { method s_m(*%n) { say(%n<a>, %n<b>, %n<c>) } token TOP { <s_m(|hash(:a<1>, :c<3>), :b<2>)> } } G.s_m(|hash(:a<1>, :c<3>), :b<2>); G.parse('');

[08:18] <camelia> nqp-parrot: OUTPUT«Unable to parse expression in blockoid; couldn't find final '}'  at line 2, near "method s_m"␤current instr.: 'panic' pc 15634 (gen/parrot/stage2/NQPHLL.pir:5766) (gen/parrot/stage2/NQPHLL.nqp:425)␤»

[08:18] <camelia> ..nqp-jvm: OUTPUT«Unable to parse expression in blockoid; couldn't find final '}'  at line 2, near "method s_m"␤  in panic (gen/jvm/stage2/NQPHLL.nqp:396)␤  in FAILGOAL (gen/jvm/stage2/NQPHLL.nqp:403)␤  in blockoid (gen/jvm/stage2/NQP.nqp:989)␤  in package_def (gen/jvm/stage2/…»

[08:18] <camelia> ..nqp-moarvm: OUTPUT«Unable to parse expression in blockoid; couldn't find final '}'  at line 2, near "method s_m"␤   at gen/moar/stage2/NQPHLL.nqp:369  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/NQPHLL.moarvm:panic:105)␤ from gen/moar/stage2/NQPHLL.nqp:376  (/home/p6eval/rakud…»

[08:19] <arnsholt> nqp:  my grammar G { method s_m(*%n) { say(%n<a>, %n<b>, %n<c>) }; token TOP { <s_m(|hash(:a<1>, :c<3>), :b<2>)> }; }; G.s_m(|hash(:a<1>, :c<3>), :b<2>); G.parse('');

[08:19] <camelia> nqp-parrot: OUTPUT«123␤too many positional arguments: 3 passed, 1 expected␤current instr.: 's_m' pc 126 ((file unknown):74) (/tmp/tmpfile:1)␤»

[08:19] <camelia> ..nqp-moarvm: OUTPUT«This representation (VMHash) does not support positional access␤   at /tmp/tmpfile:1  (<ephemeral file>:s_m:0)␤ from /tmp/tmpfile:1  (<ephemeral file>::44)␤ from gen/moar/stage2/NQPHLL.nqp:1091  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/NQPHLL.moarvm:eva…»

[08:19] <camelia> ..nqp-jvm: OUTPUT«VMHash representation does not implement at_pos_boxed␤  in s_m (/tmp/tmpfile)␤  in  (/tmp/tmpfile:1)␤  in eval (gen/jvm/stage2/NQPHLL.nqp:1118)␤  in evalfiles (gen/jvm/stage2/NQPHLL.nqp:1310)␤  in command_eval (gen/jvm/stage2/NQPHLL.nqp:1214)␤  in command…»

[08:20] <arnsholt> nqp: my %hash := nqp::hash(:a<1>, :c<3>);  my grammar G { method s_m(*%n) { say(%n<a>, %n<b>, %n<c>) }; token TOP { <s_m(|%hash> }; }; G.s_m(|%hash, :b<2>); G.parse('');

[08:20] <camelia> nqp-moarvm: OUTPUT«Unable to parse expression in metachar:sym<assert>; couldn't find final '>'  at line 2, near "(|%hash> }"␤   at gen/moar/stage2/NQPHLL.nqp:369  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/NQPHLL.moarvm:panic:105)␤ from gen/moar/stage2/NQPHLL.nqp:376  (/home/…»

[08:20] <camelia> ..nqp-jvm: OUTPUT«Unable to parse expression in metachar:sym<assert>; couldn't find final '>'  at line 2, near "(|%hash> }"␤  in panic (gen/jvm/stage2/NQPHLL.nqp:396)␤  in FAILGOAL (gen/jvm/stage2/NQPHLL.nqp:403)␤  in metachar:sym<assert> (gen/jvm/stage2/NQPP6QRegex.nqp)␤  in …»

[08:20] <camelia> ..nqp-parrot: OUTPUT«Unable to parse expression in metachar:sym<assert>; couldn't find final '>'  at line 2, near "(|%hash> }"␤current instr.: 'panic' pc 15634 (gen/parrot/stage2/NQPHLL.pir:5766) (gen/parrot/stage2/NQPHLL.nqp:425)␤»

[08:20] *** fhelmberger joined
[08:21] <arnsholt> nqp: my %hash := nqp::hash(:a<1>, :c<3>);  my grammar G { method s_m(*%n) { say(%n<a>, %n<b>, %n<c>) }; token TOP { <s_m(|%hash)> }; }; G.s_m(|%hash, :b<2>); G.parse('');

[08:21] <camelia> nqp-moarvm: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤   at /tmp/tmpfile:1  (<ephemeral file>:s_m:0)␤ from <unknown>:1  (<ephemeral file>:TOP:61)␤ from gen/moar/stage2/QRegex.nqp:1302  (/home/p6eval/rakudo-inst-2/languages/nqp/lib/QRegex.moarvm:parse:4…»

[08:21] <camelia> ..nqp-parrot: OUTPUT«2␤too many positional arguments: 2 passed, 1 expected␤current instr.: 's_m' pc 125 ((file unknown):78) (/tmp/tmpfile:1)␤»

[08:21] <camelia> ..nqp-jvm: OUTPUT«2␤␤P6int representation does not support natively typed attributes␤  in TOP (/tmp/tmpfile)␤  in parse (gen/jvm/stage2/QRegex.nqp:1302)␤  in  (/tmp/tmpfile:1)␤  in eval (gen/jvm/stage2/NQPHLL.nqp:1118)␤  in evalfiles (gen/jvm/stage2/NQPHLL.nqp:1310)␤  …»

[08:22] *** AW3i left
[08:23] *** virtualsue joined
[08:30] <arnsholt> jnthn: I think part of the problem with O-refactor is the fact that hash flattening in rules is currently a bit wonky (NQP #46)

[08:30] *** denis_boyun_ joined
[08:34] <arnsholt> Not entirely sure why, though. Potentially something missing in the subrule QAST::Regex node stuff

[08:42] *** dakkar joined
[09:05] *** xinming_ left
[09:05] *** camelia left
[09:06] *** xinming_ joined
[09:07] *** camelia joined
[09:08] <lizmat> good *, #perl6!

[09:08] *** ChanServ sets mode: +v camelia

[09:08] <nwc10> good #perl6, *

[09:10] *** denis_boyun_ left
[09:11] *** hummeleB1 joined
[09:16] <arnsholt> o/ nwc10 

[09:19] *** lizmat left
[09:19] *** ChexMing left
[09:20] *** lizmat joined
[09:30] *** kaare__ left
[09:30] *** kaare_ joined
[09:39] *** AW3i joined
[09:44] *** rindolf joined
[09:46] <dalek> rakudo/nom: c575000 | (Elizabeth Mattijsen)++ | / (2 files):

[09:46] <dalek> rakudo/nom: Remove .winners for now

[09:46] <dalek> rakudo/nom: 

[09:46] <dalek> rakudo/nom: To prevent anybody from using it while the spec is still very much in flux.

[09:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c5750007e5

[09:50] <lizmat> jnthn, TimToady: to me the big question is now: do we want to have some kind of ".close" on a Promise

[09:50] <lizmat> or do we need to change Promises into Channels, and use the .closed attribute on the Channel

[09:51] <lizmat> to make winner {} and/or outcome {} sane

[09:56] *** xinming_ left
[09:57] *** xinming_ joined
[09:59] <lizmat> fwiw, it doesn't make sense to turn Promises into Channels automatically, as that would just be moving the problem

[10:00] *** aindilis left
[10:05] *** denis_boyun joined
[10:09] *** rurban joined
[10:14] *** rurban left
[10:19] <nwc10> There's more than one way to do it: https://tech.dropbox.com/2014/04/introducing-pyston-an-upcoming-jit-based-python-implementation/

[10:19] <nwc10> oh, and git, not mercurial https://github.com/dropbox/pyston

[10:20] <nwc10> "Currently, Pyston targets Python 2.7, only runs on x86_64 platforms, and only has been tested on Ubuntu" -- nothing wrong with any of those 3, but I assume that that's where the money is.

[10:22] <nwc10> 11 commits total, 10 from Kevin Modzelewski, 1 from Yetkin Öztürk

[10:37] *** plobsing left
[10:39] *** LLamaRider joined
[10:40] <jnthn> arnsholt: It's entirely possible something is a bit off there

[10:41] <jnthn> lizmat: A promise is implicitly closed once it is kept/broken. There's only ever one value.

[10:42] <LLamaRider> r: Nil.WHAT.say

[10:42] <jnthn> lizmat: I think TimToady is probably right: we should make winner just about channels.

[10:42] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«Nil␤»

[10:42] <LLamaRider> Nil types itself?

[10:42] <jnthn> It's a distinct tyep

[10:43] <jnthn> *type

[10:43] <lizmat> jnthn: but .result can be called N times on a promise

[10:43] <lizmat> maybe that's the problem?

[10:44] <jnthn> lizmat: No, that's the nature of a promsie

[10:44] <jnthn> lizmat: It *has* to be taht way otherwise "then" makes no sense.

[10:45] <lizmat> ok

[10:46] <lizmat> it still feels wrong to me though

[10:46] <jnthn> I think lets just stop trying to make winner work on promises

[10:46] <jnthn> Then you just have the wrong mental model of promises.

[10:47] <jnthn> It's not like we're doing them somehow different to JS/.Net/Java.

[10:48] <lizmat> well, fwiw, I want to be where the puck is going to be, not where it is

[10:49] <lizmat> any feelings about the name "outcome" versus "winner" ?

[10:50] <jnthn> lizmat: I think the nature of promises as a construct has largely reached the "where it's going to be" point now :)

[10:51] <jnthn> Don't feel strongly on outcome vs winner

[10:51] <jnthn> Neither feels "perfect"

[10:52] <jnthn> I guess I'd prefer a verb...

[10:54] <lizmat> why?  I mean, we're looking a sorting operation on the time axis

[10:54] <lizmat> the result of that, rarther

[10:54] <lizmat> *rather

[10:54] <lizmat> "outcome" feels to me like that covers it pretty much

[10:55] *** aindilis joined
[10:58] <jnthn> Yeah, it just doesn't quite convey the fact that yu're choosing one fo the avaialble options

[10:58] <jnthn> "ready" or "available" or "able" feel righter-ish to me

[11:00] <jnthn> hm, but don't go with the more/done so well

[11:03] <LLamaRider>  "present" would be a punny one

[11:09] *** AW3i left
[11:11] *** rurban joined
[11:15] *** rurban left
[11:21] <lizmat> how about using "whenever" instead of "more" ?

[11:21] <lizmat> the hopefully conveys the timeliness of the thing, rather than just "when" or "more"

[11:23] * moritz still likes race

[11:23] <moritz> or "asap"

[11:24] <brrt> i like 'present'

[11:25] <brrt> and… 'first'

[11:25] * brrt is a bit unhappy about brand new python implementations that target… python2.7 :-(

[11:26] <brrt> that is like building a brand new vm for.. perl5.8

[11:27] <moritz> huh, which one?

[11:27] <brrt> pyston, backlog of … . 12:19

[11:27] <brrt> (my time)

[11:29] <dalek> specs: 5027a94 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[11:29] <dalek> specs: Let's revert back to before I got into this

[11:29] <dalek> specs: review: https://github.com/perl6/specs/commit/5027a94137

[11:37] <dalek> specs: 7136f93 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[11:37] <dalek> specs: Make winner {} about Channel's only

[11:37] <dalek> specs: review: https://github.com/perl6/specs/commit/7136f9327c

[11:41] *** colomon left
[11:50] *** dmol left
[11:52] *** telex left
[11:54] *** araujo joined
[11:58] *** telex joined
[12:06] *** colomon joined
[12:12] *** rurban joined
[12:13] *** masak_ is now known as masak

[12:15] *** kaleem left
[12:15] *** benabik left
[12:16] <lizmat> jnthn: wrt to levenshteining the method not found error

[12:16] *** rurban left
[12:17] <lizmat> it seems that method not found errors are thrown at the end of BOOTSTRAP (at least in moar)

[12:17] <lizmat> I guess there is no way make it set up an exception at that stage, is there?

[12:20] *** daniel-s_ joined
[12:32] *** xenoterracide joined
[12:37] <cognominal> what are the languages targetting QAST apart Perl 6 and nqp?

[12:37] <moritz> uhm, none that I know of

[12:38] <cognominal> should reread jonathan slides. I think he had a toy ruby

[12:40] <masak> yes, and a toy PHP in the exercises :)

[12:40] <colomon> wasn't there a snake project as well?

[12:40] <tadzik> there is

[12:41] *** colomon left
[12:42] <tadzik> he couldn't stand it :D

[12:49] <moritz> who?

[12:50] *** xenoterracide left
[12:50] <masak> snake!

[12:50] <masak> :P

[12:53] *** kaare_ left
[13:01] *** colomon joined
[13:08] *** kbaker_ joined
[13:10] *** dayangkun left
[13:12] *** rurban joined
[13:17] *** rurban left
[13:23] *** kaleem joined
[13:25] *** BenGoldberg joined
[13:25] *** virtualsue left
[13:27] *** dayangkun joined
[13:27] <jnthn> lizmat: The way to do that is put soemthing in P6EX

[13:28] <jnthn> lizmat: See the multi-dispatcher, also in BOOTSTRAP, which throws typed exceptions

[13:28] <lizmat> ack, will look

[13:28] <jnthn> I want to find languages I can implement and call the implementations "badger" and "musrhroom", to go with snake :P

[13:30] *** dakkar left
[13:34] *** Bucciarati left
[13:34] *** avar joined
[13:36] *** Bucciarati joined
[13:36] *** treehug88 joined
[13:40] <vendethiel> :o. The -h autogeneration is soooo cool

[13:43] *** dakkar joined
[13:43] *** bluescreen10 joined
[13:47] <moritz> jnthn: Debian's firefox clone is called iceweasel, and it implements XUL. It's not too far from weasel to badger :-)

[13:47] *** benabik joined
[13:49] <frettled> iceweasel, mudbadger

[13:49] <vendethiel> Rosatta code is a great resource for building perl6 stuff.

[13:50] *** virtualsue joined
[13:51] <jnthn> m: sub product_name() { <ice fire snow tornado>.pick ~ <kangaroo goat manatee bear>.pick }; say product_name() for ^5

[13:51] <camelia> rakudo-moar c57500: OUTPUT«tornadokangaroo␤icegoat␤snowbear␤firebear␤snowkangaroo␤»

[13:52] <TimToady> I'm not sure which of those is scarier

[13:52] *** SamuraiJack left
[13:52] <benabik> fireferret

[13:53] <TimToady> a tornadokangaroo will kill you before you can finish typing it

[13:53] *** vendethiel left
[13:54] *** vendethiel joined
[13:55] *** kaare_ joined
[13:55] *** pmurias joined
[13:55] *** qiang joined
[13:56] <[Coke]> just saw a firetornado this weekend.

[13:56] *** virtualsue left
[13:57] *** vendethiel left
[13:57] <pmurias> jnthn: re badger and mushroom, it's already be decided QAST ruby will be called badger and php mushroom ;)

[13:58] <TimToady> mushroom as in "what they were smoking"?

[13:58] <jnthn> :D

[13:58] <jnthn> Well, when I watch the badger/mushroom/snake video, you gotta wonder what they were smoking to come up with it... :)

[13:59] <jnthn> wow, what a disagreeable sentence...

[13:59] <TimToady> you sure it wasn't a tenuki?

[13:59] *** jnap joined
[13:59] * jnthn had to look that up

[14:00] <jnthn> m: sub product_name() { <ice fire snow tornado>.pick ~ 'tenuki' }; say product_name() 

[14:00] <camelia> rakudo-moar c57500: OUTPUT«firetenuki␤»

[14:01] <TimToady> oops, I meant a tanuki, not a tenuki :)

[14:03] *** btyler joined
[14:03] <Woodi> hallo # today :)

[14:04] *** vendethiel joined
[14:04] <Woodi> m: my $c = Channel.new;

[14:04] <camelia> rakudo-moar c57500: ( no output )

[14:05] <Woodi> hmm, perls6 on my machine says: Undeclared name: Channel used at line 1  same for promises and supplies...

[14:07] *** vendethiel left
[14:11] <lizmat> p: my $c = Channel.new;

[14:11] <camelia> rakudo-parrot c57500: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CIu9oT7Eyg␤Undeclared name:␤    Channel used at line 1␤␤»

[14:11] <lizmat> are you sure you're using perl-m ?

[14:12] *** thou joined
[14:12] <Woodi> from reading S17: channels are blocking and shifty and supplies are non-blocking and tee-like. what about non-blocking and "checking" - like probe doing checks ocassionally ?

[14:12] *** vendethiel joined
[14:12] <Woodi> m: my $p = Promise.new;

[14:12] <camelia> rakudo-moar c57500: ( no output )

[14:12] <vendethiel> what the fuck is my internet doing

[14:12] <lizmat> cycling&

[14:13] <vendethiel> my internet is cycling ? not fast enough though ..

[14:13] <Woodi> on perl6-m on Promise I get: same as for parrot + "Cannot find method 'ast': no method cache and no..."

[14:13] *** rurban joined
[14:13] * vendethiel finished his little "changelog.pl" script to generate a changelog from a Git history

[14:15] <Woodi> one possibility is it's my local layout of compilers location is broken with many backends...

[14:17] <[Coke]> Did you alter the default install?

[14:17] <Woodi> umm, what mean default ?

[14:18] <Woodi> prefix is /opt/../..

[14:18] *** rurban left
[14:19] <Woodi> probably nqp was done for two backends and once and rakudo one by one

[14:19] <Woodi> *at once

[14:24] * nwc10 reads http://blog.kevmod.com/2014/04/pyston-xrange-example/ and wonders about "n reality, the situation is more complicated and the results less nice, since there will often be speculations inside the for loop that can require a rematerialization of the iterator object"

[14:24] <nwc10> oops, "In reality..."

[14:24] <nwc10> the wondering being actually the next part "but personally I find this kind of result to be a very promising indicator that type feedback + static optimizations can produce code similar to what a tracing JIT may be able to achieve."

[14:25] <nwc10> and how much are the correctness checks for rematerialising going to cost?

[14:34] *** fhelmberger left
[14:34] <hoelzro> moring #perl6

[14:35] *** rindolf left
[14:36] *** jnap1 joined
[14:37] *** jnap left
[14:38] <vendethiel> r: say (^4)[1..*]

[14:38] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«1 2 3␤»

[14:38] <vendethiel> r: say (^4)[0..*-1]

[14:38] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«0 1 2 3␤»

[14:41] *** hoverboard joined
[14:47] *** rurban joined
[14:48] <vendethiel> https://github.com/Nami-Doc/Changelog.pl6

[14:49] *** hoverboard left
[14:50] <vendethiel> It even seems to work !

[14:51] *** hoverboard joined
[15:02] *** sftp left
[15:03] *** jnap joined
[15:03] *** virtualsue joined
[15:03] *** jnap left
[15:04] *** sftp joined
[15:06] *** jnap1 left
[15:09] *** jnap joined
[15:11] *** denis_boyun left
[15:11] *** LLamaRider left
[15:14] *** dayangkun left
[15:14] <vendethiel> r: say "salut".tr(" -_abcdefghijklmnopqrstuvwxyz1234567890", " -_ɐqɔpǝɟɓɥıɾʞlɯuodbɹsʇnʌʍxʎz⇂ᄅƐㄣގ9ㄥ860")

[15:14] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«No such method 'tr' for invocant of type 'Str'␤  in block  at /tmp/tmpfile:1␤␤»

[15:18] <brrt> jhttp://catalogus.rug.nl/DB=1/SET=3/TTL=111/SHW?FRST=111 omg my library has a book called 'Perl 6 Essentials'

[15:22] <vendethiel> "foutIk ben uw resultaten vergeten"

[15:23] <dalek> roast: 5a1a50a | (Timo Paulssen)++ | S03-operators/orelse.t:

[15:23] <dalek> roast: orelse isn't supposed to "try" its LHS

[15:23] <dalek> roast: review: https://github.com/perl6/roast/commit/5a1a50add0

[15:26] <timotimo> http://p6weekly.wordpress.com/?p=137&shareadraft=5342c3962a069 - would like some feedback :)

[15:26] <timotimo> (don't forget to put your name in the box on the left if you use that)

[15:26] <timotimo> (i also accept feedback on irc)

[15:27] <vendethiel> timotimo: you can remove the outer `try` in that case :-)

[15:27] <brrt> excuse me : http://catalogus.rug.nl/DB=1/XMLPRS=Y/PPN?PPN=250239264

[15:27] *** dayangkun joined
[15:28] <timotimo> oh, yes i can

[15:28] <timotimo> and probably also the CATCH, right?

[15:28] *** dayangkun left
[15:29] <vendethiel> yes

[15:29] *** dayangkun joined
[15:29] <vendethiel> No need to try `orelse` exception semantics if it has none :)

[15:29] <vendethiel> r: say { die "foo" } // 1;

[15:29] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«Block.new()␤»

[15:29] <vendethiel> r: say (try { die "foo" } // 1);

[15:29] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«1␤»

[15:30] <vendethiel> r: say (try { 5 } // 1);

[15:30] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«5␤»

[15:30] * vendethiel is still unsure why orelse is needed

[15:30] *** dayangkun left
[15:30] <vendethiel> r: say (try { die "oh noes" } // ~$!);

[15:30] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«oh noes␤»

[15:30] <dalek> roast: 49c0367 | (Timo Paulssen)++ | S03-operators/orelse.t:

[15:30] <dalek> roast: make the whole "exception semantics" situation clearer.

[15:30] <dalek> roast: review: https://github.com/perl6/roast/commit/49c03677df

[15:30] <timotimo> how do you feel about this?

[15:31] *** dayangkun joined
[15:32] *** zakharyas left
[15:32] <vendethiel> looks good, though that could very well end the same way :)

[15:33] <timotimo> aye, since try automatically sets $! anyway >_>

[15:33] <timotimo> if you want to continue this ... wizard needs food, badly

[15:34] *** brrt left
[15:36] <vendethiel> this wizard will do some osu! then look back at the spec :)

[15:37] * vendethiel .oO( First time I'm in the p6weekly ... And it's a fail ! Ha ! :P )

[15:37] *** treehug88 left
[15:38] <timotimo> it's *my* fail :)

[15:38] <timotimo> i can also leave that point out if you'd rather not show up in that context

[15:39] <vendethiel> I'm fine with leaving that point as-is, but I'd rather get us correct tests and brag about it in the p6weekly :P

[15:39] *** LLamaRider joined
[15:39] <vendethiel> //'s doc says that "orelse is low-precedence, similar but not identic"

[15:41] <vendethiel> also, it seems `try { die "a" } orelse try { die "b" }` will return `try { die "b" }`'s result

[15:41] <vendethiel> r: say (try { die "a" } // try { die "b" })

[15:41] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«Nil␤»

[15:41] * jnthn back from teaching

[15:42] <jnthn> timotimo: Worth noting that the work to take advantage of the onlystar proto thing is not merged yet

[15:42] <jnthn> timotimo: The MoarVM bit is there but the NQP and Rakudo changes are in branches

[15:42] <jnthn> or at least the NQP one is

[15:42] <jnthn> uh

[15:42] <jnthn> or at least the Rakudo one is

[15:42] <jnthn> Also it's not a new cache, it's just bypassing invoking the onlystar proto at all.

[15:43] <timotimo> oh

[15:43] <jnthn> I have a bit more to do before it's mergeable

[15:43] <timotimo> where did i see that? o_O

[15:44] * timotimo just drops that point

[15:44] <jnthn> timotimo: Also note that getattr and box/unbox aren't spesh'd yet, but the infrastructure is there to do it

[15:44] <jnthn> We'll have 'em soon

[15:45] <jnthn> bindattr and create are though, so that's correct :)

[15:46] <jnthn> timotimo: Also, last week said:

[15:46] <jnthn> "However, the I/O subsystem has almost no locks in it, so doing I/O from multiple threads simultaneously is likely going to produce “interesting” results. "

[15:46] <jnthn> That has been addressed by now :)

[15:47] *** treehug88 joined
[15:51] <[Coke]> that library link doesn't work without your session, it seems. that book is very out of date and has a lot about an old version of parrot, IIRC.

[15:53] <vendethiel> r: lol (1, (2, (3, 4)))

[15:53] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Undeclared routine:␤    lol used at line 1. Did you mean 'log'?␤␤»

[15:55] <vendethiel> r: try fail "can't touch this";

[15:55] <camelia> rakudo-moar c57500: OUTPUT«Unhandled exception: can't touch this␤   at src/gen/m-CORE.setting:11047  (/home/p6eval/rakudo-inst-2/languages/perl6/runtime/CORE.setting.moarvm:throw:129)␤ from src/gen/m-CORE.setting:12481  (/home/p6eval/rakudo-inst-2/languages/perl6/runtime/CORE.se…»

[15:55] <camelia> ..rakudo-jvm c57500: OUTPUT«Unhandled exception: can't touch this␤  in throw (gen/jvm/CORE.setting:10988)␤  in sink (gen/jvm/CORE.setting:12424)␤  in MAIN (gen/jvm/main.nqp:47)␤  in  (gen/jvm/main.nqp:41)␤  in  (gen/jvm/main.nqp)␤␤»

[15:55] <camelia> ..rakudo-parrot c57500: OUTPUT«can't touch this␤current instr.: 'throw' pc 418069 (src/gen/p-CORE.setting.pir:174958) (gen/parrot/CORE.setting:11008)␤called from Sub 'sink' pc 456250 (src/gen/p-CORE.setting.pir:189173) (gen/parrot/CORE.setting:12445)␤called from Sub 'MAIN' pc 37…»

[15:56] <vendethiel> r: my $x; my $y ::= $x; $x = 5; say $y; $y = 5; say $x;

[15:56] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«5␤5␤»

[15:57] <vendethiel> r: my $x; my $y ::= $x; $x = 5; say $y; $y = 6; say $x;

[15:57] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«5␤6␤»

[15:57] <vendethiel> Shouldn't that fail because "::=" makes it readonly ?

[15:58] *** LLamaRider left
[16:01] <vendethiel> r: my $a ::= 5; { say $a; $a = 5; } say $a;

[16:01] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32mmy $a ::= 5; { say $a; $a = 5; } [33m⏏[31msay $a;[0m␤    expecting any of:␤        p…»

[16:01] <vendethiel> r: my $a ::= 5; { say $a; $a = 5; }; say $a;

[16:01] <camelia> rakudo-moar c57500: OUTPUT«5␤No such method 'STORE' for invocant of type 'Int'␤  in block  at /tmp/tmpfile:1␤␤»

[16:01] <camelia> ..rakudo-parrot c57500, rakudo-jvm c57500: OUTPUT«5␤Cannot modify an immutable value␤  in block  at /tmp/tmpfile:1␤␤»

[16:01] <vendethiel> I'd say moar result is wrong ?

[16:01] *** bfulgham_ joined
[16:02] <moritz> vendethiel: yes; there's a ticket open for that (and failing tests)

[16:04] <jnthn> Just sub-optimal error reporting

[16:04] *** bluescreen10 left
[16:04] *** bluescreen100 joined
[16:04] *** daniel-s_ left
[16:11] *** denis_boyun_ joined
[16:15] *** benabik left
[16:23] *** [particle] joined
[16:24] *** kaleem left
[16:38] *** treehug88 left
[16:38] *** qiang left
[16:38] *** treehug88 joined
[16:39] *** spider-mario joined
[16:42] *** guru joined
[16:43] *** guru is now known as ajr_

[16:43] *** benabik joined
[16:47] *** Rotwang joined
[16:54] <vendethiel> r: (my $x = 1) = 2; say $x;

[16:54] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«2␤»

[16:57] *** isBEKaml joined
[16:57] <vendethiel> r: sub a is rw { state $x; }; $a() = 5; say $a;

[16:57] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Variable '$a' is not declared␤at /tmp/tmpfile:1␤------> [32msub a is rw { state $x; }; $a()[33m⏏[31m = 5; say $a;[0m␤    expecting any …»

[16:58] <vendethiel> r: sub a is rw { state $x; }; a() = 5; say a;

[16:58] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«5␤»

[16:58] <jnthn> Not sure I've seen that trick before :)

[16:58] *** kivutar joined
[16:59] *** dmol joined
[17:00] <vendethiel> \o/

[17:00] * vendethiel wonders ...

[17:01] *** dakkar left
[17:01] <vendethiel> r: sub a is rw { state $ }; a() = 5; say a;

[17:01] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«5␤»

[17:01] <vendethiel> p6++

[17:03] <retupmoca> I just build a rakudo on moar/spesh - no new spectest fails that I see, and installing panda and a few modules works fine

[17:03] <retupmoca> from where I'm sitting, spesh Just Works \o/

[17:04] <retupmoca> s/build/built

[17:04] *** virtualsue left
[17:04] <isBEKaml> retupmoca: what's spesh?

[17:05] <retupmoca> an optimization branch of moarvm

[17:06] * jnthn will have to try and get a blog post out about it soon 

[17:06] <isBEKaml> cool, what does spesh stand for? :-)

[17:07] <isBEKaml> I guess this is another one of jnthn++'s too-short-for-a-name things. I still remember how he named a branch 'bs'  for bounded serialization. 

[17:07] <jnthn> isBEKaml: "specialization" as in "type-driven bytecode specialization"

[17:08] * vendethiel -- is it bound ? bind ? bounded ? binded ?

[17:09] *** rurban left
[17:09] *** rurban joined
[17:09] <isBEKaml> jnthn: what is it for? faster numeric computation? (now it's t.d.b.s)

[17:11] <jnthn> isBEKaml: Well, it may help on that, but much more about optimizing dispatch, memory access, argument handling, etc.

[17:11] <cognominal> I wish git would impose to declare what a branch is for. Or do I miss something?

[17:11] <PerlJam> so ... spesh is faster/

[17:12] <PerlJam> cognominal: you can give a branch a short description with --edit-description

[17:12] <jnthn> PerlJam: Typically, yes. 

[17:12] <cognominal> PelJam and how could I view it?

[17:13] <PerlJam> cognominal: very annoyingly. :(   I ended up writing a little script to do it.  It'll show up in the config as branch.BRANCHNAME.description

[17:14] <isBEKaml> jnthn: Ah, I see. But... do you always choose something with "b.s" in it? :P

[17:15] <cognominal> I never understood what "bounded" stood for in bs

[17:18] <cognominal> Perl 6, a language well speshified... with moar, at leat.

[17:19] <arnsholt> cognominal: IIRC, it's bounded in the sense that you serialise a whole object graph, but stop once the graph reaches certain boundaries

[17:19] <PerlJam> I thought it meant bounded as controlling the extent of serialization. 

[17:19] <PerlJam> what arnsholt said

[17:20] <cognominal> meaning the currently compiled compilation unit?

[17:21] <arnsholt> Something like that. I'm not very clear on the detail, but some things like the base metaobject for sixmodel and such, we don't actually want to serialise is the way I grokked it

[17:23] *** raiph joined
[17:24] <jnthn> Well, consider a A.pm with class A { }, and a B.pm with use A; class B is A { }

[17:25] <jnthn> When pre-compiling B.pm, we don't want to re-serialize the stuff in A.pm.

[17:25] <arnsholt> Yeah, that makes sense. Bounded by the current compilation unit, I guess?

[17:26] <jnthn> Yeah, it's about comp units

[17:26] <jnthn> At least, until augment 

[17:27] <arnsholt> Oh, heh. Always the wrinkle, in this language, isn't there? =)

[17:27] <arnsholt> Anyways, bounded by compilation unit should make it easier to remember next time this topic comes up =)

[17:28] <cognominal> bbcu does not sound like bs  :)

[17:30] *** kurahaupo joined
[17:30] <jnthn> om nom bbcu :)

[17:30] <timotimo> jnthn: i've incorporated your changes

[17:31] <jnthn> timotimo: Which changes?

[17:31] <timotimo> http://p6weekly.wordpress.com/?p=137&shareadraft=5342e0e149db2

[17:31] <jnthn> oh!

[17:31] <jnthn> heh, forgot already :)

[17:32] <raiph> https://questhub.io/realm/perl/quest/5342dda56e7817e03f000059 # quest to clarify (for me and P6 community) the relevance of Futamura projections to NQP and Rakudo (can we "easily" steal PyPy's "secret sauce" rather than use PyPy?)

[17:32] <arnsholt> timotimo:  s/publicised/published/

[17:32] <isBEKaml> raiph: "Futamura" ?? 

[17:33] <jnthn> timotimo: looks good

[17:33] <raiph> isBEKaml: I've added a comment to the quest that introduces the topic

[17:35] <raiph> isBEKaml: I've only just come to understand how PyPy gets to be fast

[17:36] <isBEKaml> raiph: a search for futamura gave me this: https://github.com/zombiecalypse/Futamura

[17:36] <isBEKaml> but that's over 2 years old.

[17:38] <raiph> I haven't yet figured if patrick/jnthn know all this stuff or have just "accidentally" built the right pieces to pull it off or if I'm off base

[17:40] <isBEKaml> and then there's this: http://en.wikipedia.org/wiki/Partial_evaluation#Futamura_projections and a blog by sigfpe: http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html

[17:40] <raiph> isBEKaml: yeah, those last two links are in my intro comment

[17:41] <isBEKaml> raiph: sorry, your comment is too-long for a comment that I didn't sit down at all. :-)

[17:42] <raiph> if anyone here should know it's timotimo but he seems to have focused on NQP targeting pypy rather than nqp just doing its own equivalent of what pypy does

[17:43] <timotimo> aye

[17:43] <isBEKaml> yeah, I can understand that. target VMs/backends and you get free specialized optimizations. 

[17:45] <raiph> timotimo: am I right to think NQP really ought to (or already does) leverage (something akin to) the futamura projections approach?

[17:45] <dalek> rakudo-star-daily: 71df6cb | coke++ | log/ (5 files):

[17:45] <dalek> rakudo-star-daily: today (automated commit)

[17:45] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/71df6cb7a0

[17:45] <dalek> perl6-roast-data: 47692cd | coke++ | / (6 files):

[17:45] <dalek> perl6-roast-data: today (automated commit)

[17:45] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/47692cdf7a

[17:47] *** benabik left
[17:54] <dalek> rakudo/nom: 2991f8e | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[17:54] <dalek> rakudo/nom: Naively add .object attribute to Method::NotFound

[17:54] <dalek> rakudo/nom: 

[17:54] <dalek> rakudo/nom: Part of work in progress

[17:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2991f8e410

[17:58] *** rindolf joined
[18:00] <moritz> lizmat++ # though I'd prefer it if the attribute was called 'invocant', because nearly everything is an object, so 'object' is very generic

[18:03] <raiph> isBEKaml: https://news.ycombinator.com/item?id=7061360#up_7061913 # I'm adding this to my quest comment as the best quick explanation I've yet found about Futamura projections and PyPy

[18:06] *** xinming_ left
[18:07] <isBEKaml> raiph: yeah, that helps - but I still don't understand why it is important to perl6. :-)

[18:08] *** xinming_ joined
[18:09] <isBEKaml> AFAICS, it's only pypy that's managed to fulfill some of the projections and it's something of an outlier. I remember being frustrated trying to build pypy. (too much computation power required and I have nothing :P)

[18:10] <vendethiel> r: Enum o <foo bar baz>; say foo before bar

[18:10] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> [32mEnum [33m⏏[31mo <foo bar baz>; say foo before bar[0m␤    expecting any of:␤        p…»

[18:10] <vendethiel> r: enum o <foo bar baz>; say foo before bar

[18:10] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«True␤»

[18:11] <vendethiel> r: enum o <foo bar baz>; enum z <baz bar foo>; say foo before bar

[18:11] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«False␤»

[18:11] <vendethiel> Well.

[18:11] <vendethiel> r: enum o <foo bar baz>; enum z <baz bar foo>; say o.foo before o.bar

[18:11] <camelia> rakudo-parrot c57500, rakudo-jvm c57500, rakudo-moar c57500: OUTPUT«No such method 'foo' for invocant of type 'o'␤  in block  at /tmp/tmpfile:1␤␤»

[18:12] <PerlJam> vendethiel: you need :: instead of .

[18:12] <vendethiel> PerlJam: got that already :)

[18:13] <vendethiel> Just decided to whisper camelia instead

[18:13] <raiph> isBEKaml: afaict NQP is poised to be a better PyPy, including the third projection, and aiui this would be a good thing. I'm trying to figure out if that's true or not and if jnthn et al have already thought this through.

[18:14] *** itz__ left
[18:15] * vendethiel wants to see a nqp better than pypy !

[18:15] *** itz_ joined
[18:17] <raiph> vendethiel: do you know of anything, other than tuits, that blocks application of the Futamura projection principles to NQP?

[18:17] * isBEKaml would be happy just to build NQP when it fufills all of the projections. Not aiming all that high...

[18:18] <vendethiel> raiph: no, I was just referring at the time factor

[18:23] <raiph> Anyhoo, the penny has only just dropped for me on Futamura projections and they are by far the most interesting optimization technique I've encountered in my life (I'm 54 and I've been exploring the fundamentals of CS for about 30 years)

[18:25] <raiph> (though I'm not claiming I really understand much of it)

[18:27] *** isBEKaml left
[18:42] *** ajr joined
[18:42] *** ajr_ left
[18:42] *** ajr is now known as Guest97040

[18:42] *** Guest97040 is now known as ajr_

[18:43] * BenGoldberg keeps reading Futamura as Futurama

[18:44] <tadzik> oh, I was sure it's Futurama

[18:44] <tadzik> heh

[18:44] <dalek> rakudo/nom: f524e97 | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[18:44] <dalek> rakudo/nom: s/object/invocant/ as per moritz++ suggestion

[18:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f524e9745c

[18:45] <PerlJam> lizmat++ moritz++

[18:52] *** bfulgham_ left
[18:54] *** dwarring joined
[18:56] *** bfulgham_ joined
[19:04] *** benabik joined
[19:05] *** ajr_ left
[19:05] <raiph> m: sub a is rw { state $ }; a() = 5, 6; say a; # why does this work? vendethiel?

[19:05] <camelia> rakudo-moar 2991f8: OUTPUT«5 6␤»

[19:05] <raiph> m: sub a is rw { state $; }; a() = 5, 6; say a; # and why not this?

[19:05] <camelia> rakudo-moar 2991f8: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/wNUdjKoF50␤Unsupported use of $; variable; in Perl 6 please use real multidimensional hashes␤at /tmp/wNUdjKoF50:1␤------> [32msub a is rw { state $;[33m⏏[31m }; a() = 5, 6; say a; # and w…»

[19:05] <raiph> m: sub a is rw { state $ ; }; a() = 5, 6; say a; # and why not this?

[19:05] <camelia> rakudo-moar 2991f8: OUTPUT«5 6␤»

[19:06] *** bluescreen100 left
[19:06] *** denis_boyun___ joined
[19:06] <vendethiel> raiph: not sure what the question is ?

[19:06] *** bluescreen100 joined
[19:06] <vendethiel> raiph: I mean -- your second snippet works

[19:07] <raiph> vendethiel: yeah I was just a bit surprised "state $;" is being disallowed

[19:07] *** denis_boyun_ left
[19:08] <vendethiel> raiph: I think it sees "$;" as a single variable name :)

[19:08] <vendethiel> Probably a perl5 special variable ?

[19:08] <jnthn> std: sub a is rw { state $; };

[19:08] <camelia> std e347792: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of $; variable; in Perl 6 please use real multidimensional hashes at /tmp/xfApfTiWy5 line 1:␤------> [32msub a is rw { state $;[33m⏏[31m };[0m␤Parse failed␤FAILED 00:01 124m␤»

[19:08] <jnthn> It's one of the p5 special variables, yeah

[19:09] <vendethiel> too bad this causes parse errors like that

[19:09] <BenGoldberg> In perl5, the $; variable allows one to pretend a single dimensional hash is multidimensional.  If, in perl5, you do $hash{$a, $b, $c} = 1, it will internally do: $hash{ join $;, $a, $b, $c } = 1

[19:10] <benabik> std: sub a is rw { state $ ; } #?

[19:10] <camelia> std e347792: OUTPUT«ok 00:01 124m␤»

[19:10] <raiph> vendethiel: but I'm still intrigued at why your original snippet even works

[19:10] <vendethiel> raiph: well, I can just get a nameless variable $. Then I decide it's a const, like C's static keyword : it won't change between invocation :

[19:10] <lizmat> std: sub a is rw { state $ }  # why bother with the semi-colon at all?

[19:10] <vendethiel> r: sub inc { state $i = 0; ++$i }; say inc; say inc; say inc;

[19:11] <vendethiel> lizmat: that's my original snippet :-)

[19:11] <BenGoldberg> It's probably storing a Parcel into the nameless state variable

[19:11] <camelia> std e347792: OUTPUT«ok 00:01 124m␤»

[19:11] <camelia> rakudo-jvm 2991f8: OUTPUT«(timeout)»

[19:11] <camelia> ..rakudo-parrot 2991f8, rakudo-moar 2991f8: OUTPUT«1␤2␤3␤»

[19:11] <vendethiel> and since it `is rw`, it returns the parcel to that state

[19:11] <BenGoldberg> r: sub a { ++( state $ = 0 ) }; say a, a, a

[19:11] <camelia> rakudo-parrot 2991f8, rakudo-jvm 2991f8, rakudo-moar 2991f8: OUTPUT«123␤»

[19:11] <lizmat> vendethiel: oops, you're right :-)

[19:13] <jnthn> a() is not a scalar LHS, meaning it parses list prec on the RHS

[19:17] *** darutoko left
[19:18] *** pecastro left
[19:20] <lizmat> r: my @a=^10; say (@a[*-1]:k).WHAT

[19:20] <camelia> rakudo-parrot 2991f8, rakudo-jvm 2991f8, rakudo-moar 2991f8: OUTPUT«(Parcel)␤»

[19:20] <lizmat> this should be fixed soon

[19:22] <dalek> rakudo/nom: be722dc | (Elizabeth Mattijsen)++ | src/core/array_slice.pm:

[19:22] <dalek> rakudo/nom: Fix Parcelness of @a[*-1] slices with adverbs

[19:22] <dalek> rakudo/nom: 

[19:22] <dalek> rakudo/nom: Before this, these would always return a Parcel, even when it was clear only one

[19:22] <dalek> rakudo/nom: element was requested.

[19:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be722dc6f4

[19:22] <lizmat> $ perl6 -e 'my @a=^10; say (@a[*-1]:v).WHAT'

[19:22] <lizmat> (Int)

[19:23] <lizmat> although I must admit I'm not at all happy about the way this was fixed.

[19:23] *** guru joined
[19:23] *** guru is now known as ajr_

[19:24] *** pecastro joined
[19:26] *** aborazmeh left
[19:28] *** aborazmeh joined
[19:31] *** bluescreen__ joined
[19:32] *** pecastro left
[19:33] <dalek> rakudo/nom: b428e8c | (Elizabeth Mattijsen)++ | docs/ChangeLog:

[19:33] <dalek> rakudo/nom: Some Changelog fixes

[19:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b428e8cecf

[19:35] *** bluescreen100 left
[19:35] *** jnap left
[19:40] *** BenGoldberg left
[19:41] <lizmat> jnthn: even when we're limiting winner {} to channels only, then you're still going to see re-do of any code blocks associated with "done"  :-(

[19:41] <lizmat> hmm... perhaps not, lemme check

[19:43] <lizmat> I just reallized I can refrain from adding an already closed channel to the "todo" list

[19:44] *** jnap joined
[19:45] *** Rotwang left
[19:48] *** jnap1 joined
[19:48] *** jnap left
[19:54] <nwc10> meanwhile, http://hippyvm.com/blog is curious (PHP atop PyPy. Code has moved from bitbucked to github and seemingly mislaid all mecurial history on the wawy)

[19:56] <geekosaur> not unusual, sadly

[19:56] <geekosaur> if the branching is at all odd, it's not possible to preserve history on migration

[19:56] * vendethiel dislikes mercurial a lot

[19:56] <vendethiel> (also, bitbucket does github)

[19:57] * geekosaur prefers hg to git, tbh

[19:58] * timotimo has had a whole lot of frustration with hg so far

[19:59] <vendethiel> this exactly. Lost around 2h trying to remote debug something before I realize hg corrupted the repo there.

[19:59] <timotimo> i just experienced it working against my wishes and desires

[20:00] <timotimo> "oh, no, you can't do that easily. just do a fresh clone and move the stuff over with unified diffs or something"

[20:00] <timotimo> yeah, thanks

[20:00] * benabik uses `git clone hg::ssh://host/path/to/hg/repo` whenever he has to use hg.

[20:01] <benabik> Have to have installed git-remote-hg to do that.  It’s in the contrib/ dir of git.git, don’t know if it’s commonly packaged.

[20:02] *** nebuchad` joined
[20:03] <nwc10> hippyvm is touting more speedup than HHVM. Does HHVM use reference counting or a "real" GC? and either way, how much PHP code relies on the timely semantics of reference counting?

[20:03] <nwc10> much like a chunk of Perl 5 code assumes that it knows when DESTROY fires

[20:03] *** bonsaikitten joined
[20:04] <timotimo> raiph: would you like to post my p6weekly to the reddits?

[20:04] <nwc10> they mention it here: http://morepypy.blogspot.co.at/2012/07/hello-everyone.html -- The project's biggest deviation from the PHP specification is probably that GC is no longer reference counting. That means that the object finalizer, when implemented, will not be called directly at the moment of object death, but at some later point.

[20:04] <raiph> just reading it now with that as the plan :)

[20:04] *** simcop2387_ joined
[20:05] <timotimo> thank you kindly

[20:05] *** jnthn_ joined
[20:05] *** integral_ joined
[20:05] *** cxreg2 joined
[20:05] *** frettled_ joined
[20:06] *** segomos_ joined
[20:06] *** perlpilot joined
[20:07] *** jlaire_ joined
[20:09] *** ivan``_ joined
[20:09] *** ribasushi_ joined
[20:09] *** lestaway joined
[20:10] <lizmat> timotimo++, raiph++

[20:10] *** woolfy1 left
[20:10] *** jlaire left
[20:10] *** simcop2387 left
[20:10] *** PerlJam left
[20:10] *** ribasushi left
[20:10] *** nebuchadnezzar left
[20:10] *** lestrrat left
[20:10] *** ivan`` left
[20:10] *** xiaomiao left
[20:10] *** silug____ left
[20:10] *** jnthn left
[20:10] *** frettled left
[20:10] *** go|dfish left
[20:10] *** integral left
[20:10] *** segomos left
[20:10] *** simcop2387_ is now known as simcop2387

[20:10] *** ribasushi_ is now known as ribasushi

[20:10] *** jnthn_ is now known as jnthn

[20:10] *** lestaway is now known as lestrrat

[20:11] <lizmat> jnthn: nope, winner {} with only channels is also broken

[20:11] <lizmat> unless you don't mind it calling "done" N times instead of 1

[20:17] *** go|dfish joined
[20:19] *** woolfy joined
[20:21] <jnthn> lizmat: Thing is, winner is typically used when you're multiplexing a bunch of channels.

[20:21] <lizmat> but how many times do you expect the "done" for a channel to be called ?

[20:22] <lizmat> because the way it is now, thats 1..Inf times

[20:22] <jnthn> I dunno. I don't tend to use channels like that elsewhere...

[20:23] <jnthn> That is, my use cases where I've got channels that have an end point and get closed are typically useful when I plan to sit consuming a single one...

[20:23] <lizmat> you mean, you don't tend to use  winner {}  ??

[20:23] <jnthn> I mean, when I use winner-like constructs elsewhere I don't tend to have an endpoint

[20:23] <jnthn> That is, a point when a channel closes

[20:23] <jnthn> Tend to be more "infinite"

[20:23] <lizmat> aha  indeed

[20:24] <jnthn> While SEDA-like situations tend to involve a single input channel

[20:24] <jnthn> Thus for $channel.list { ... } is actually a perfectly fine way to consume.

[20:24] <lizmat> but if you want to consume from multiple channels simultaneously

[20:25] <lizmat> as long as they're infinite, it's ok

[20:25] <jnthn> Yeah. I'm trying to recall a situation where I had that *and* finite...

[20:25] <jnthn> Oh, I guess I can.

[20:25] <lizmat> as soon as you start to depend on the "done" code being done once for a closed channel, you have a problem in the current implementation of winner {}

[20:25] *** hoverboard left
[20:25] <jnthn> But in that case I expected the same number of items on all channels so as soon as one thing was completed the lot would be.

[20:26] <jnthn> Yeah, I see the issue.

[20:26] <lizmat> how can you be sure the channels finish at the same time?

[20:26] *** silug____ joined
[20:26] <jnthn> Well, I "can't", except I know my program pushes the same number of things down them.

[20:26] <lizmat> ok, fair enough

[20:27] <lizmat> in the winner {} test, I have to do this hack to make it stop when all channels have closed:

[20:27] <lizmat> done @c { %done{$:k}++; last if +%done == 2 }

[20:27] <jnthn> *nod*

[20:27] <jnthn> Yeah, it's...icky.

[20:39] <dalek> rakudo/nom: 3e72f70 | (Elizabeth Mattijsen)++ | src/core/asyncops.pm:

[20:39] <dalek> rakudo/nom: winner {} is only about channels and not promises

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3e72f7011c

[20:39] <dalek> roast: f6d09ab | (Elizabeth Mattijsen)++ | S17-concurrency/winner.t:

[20:39] <dalek> roast: winner {} is only about promises

[20:39] <dalek> roast: review: https://github.com/perl6/roast/commit/f6d09ab253

[20:40] <lue> Huh?

[20:41] <lizmat> oops...  channels  :-)

[20:41] <lizmat> grrr

[20:41] <jnthn> o.O

[20:41] <jnthn> :)

[20:42] *** spider-mario left
[20:42] <lizmat> hmmm... not sure how to fix an already pushed commit message remotely

[20:42] <jnthn> you...don't. :)

[20:43] <vendethiel> (you'd have to force-push -- don't !)

[20:43] <benabik> Well, you can fix it locally and overwrite the remote version.  But it’s considered a bit rude.

[20:45] <dalek> roast: 8b9265f | (Elizabeth Mattijsen)++ | S17-concurrency/winner.t:

[20:45] <dalek> roast: Elaborate on winner {} and multiple *channels* (only)

[20:45] <dalek> roast: review: https://github.com/perl6/roast/commit/8b9265f3ed

[20:51] *** kaare_ left
[20:51] * colomon was going to read the S17 spec this week, but it's already changed about five times since he decided that.

[20:52] * vendethiel read the S17 spec, can't remember anything about it, and will probably have to re-read it later

[20:55] <dalek> roast: e414443 | (David Warring [email@hidden.address] | integration/advent2013-day14.t:

[20:55] <dalek> roast: remove commented code

[20:55] <dalek> roast: review: https://github.com/perl6/roast/commit/e4144437bd

[20:55] <dalek> roast: 2aa7b50 | (David Warring [email@hidden.address] | integration/advent2013-day21.t:

[20:55] <dalek> roast: adding advent 2013 day 21

[20:55] <dalek> roast: review: https://github.com/perl6/roast/commit/2aa7b50d4e

[20:55] <dalek> roast: 3ff5fbb | (David Warring [email@hidden.address] | S17-concurrency/winner.t:

[20:55] <dalek> roast: Merge branch 'master' of https://github.com/perl6/roast

[20:55] <dalek> roast: review: https://github.com/perl6/roast/commit/3ff5fbbd59

[20:58] *** hoverboard joined
[21:00] *** dayangkun left
[21:05] *** lue left
[21:07] *** Exodist joined
[21:08] *** yves__ joined
[21:09] *** lue joined
[21:09] <dalek> roast: 792f7a8 | (Elizabeth Mattijsen)++ | S17-concurrency/lock.t:

[21:09] <dalek> roast: Add diag message for thread running *after* join

[21:09] <dalek> roast: review: https://github.com/perl6/roast/commit/792f7a820f

[21:10] *** Grimnir_ joined
[21:11] <dalek> rakudo/nom: 45863ee | jonathan++ | src/core/ (3 files):

[21:11] <dalek> rakudo/nom: Remove unused parameter names.

[21:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/45863ee4a3

[21:11] <dalek> rakudo/nom: caa39a8 | jonathan++ | src/Perl6/Actions.nqp:

[21:11] <dalek> rakudo/nom: Mark generated *%_ as having hash sigil.

[21:11] <dalek> rakudo/nom: 

[21:11] <dalek> rakudo/nom: This prevents it getting wrapped up in an extra scalar container.

[21:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/caa39a8f6c

[21:11] <dalek> rakudo/nom: ebd3729 | jonathan++ | src/Perl6/Actions.nqp:

[21:11] <dalek> rakudo/nom: Simplify code-gen of slurpy things.

[21:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ebd3729f4e

[21:12] * lizmat runs spectest, then pulls, then runs spectest again

[21:14] *** kurahaupo left
[21:17] *** dayangkun joined
[21:24] <lizmat> unscientific testing shows spectest is using ~ 1% CPU less in about 1% less time

[21:24] <lizmat>       Files=801, Tests=31032, 205 wallclock secs ( 8.07 usr  3.68 sys + 1377.39 cusr 95.43 csys = 1484.57 CPU)

[21:24] <lizmat>     Files=801, Tests=31032, 203 wallclock secs ( 8.06 usr  3.67 sys + 1362.08 cusr 95.76 csys = 1469.57 CPU)

[21:25] <jnthn> That's probably noise...

[21:26] <jnthn> Nice you can spectest in 203s though :)

[21:26] <timotimo> that's amazing

[21:27] <timotimo> how many parallel tests is that?

[21:27] *** kivutar left
[21:28] <lizmat> 8

[21:29] <lizmat> Files=801, Tests=31028, 206 wallclock secs ( 8.36 usr  3.70 sys + 1372.86 cusr 96.37 csys = 1481.29 CPU)

[21:29] *** kbaker_ left
[21:29] <lizmat> and a test failure on t/spec/S04-phasers/first.t

[21:30] <jnthn> hm, odd...

[21:30] <jnthn> didn't get that here.

[21:30] <lizmat> $ perl6 t/spec/S04-phasers/first.t 

[21:30] <lizmat> 1..4

[21:30] <lizmat> ok 1 - FIRST only ran once

[21:30] <lizmat> ok 2 - FIRST {} ran before the loop body

[21:30] <lizmat> Segmentation fault: 11

[21:30] <lizmat> not consistently though

[21:31] <lizmat> many ok runs, but also this one:

[21:31] <lizmat> $ perl6 t/spec/S04-phasers/first.t 

[21:31] <lizmat> 1..4

[21:31] <lizmat> Segmentation fault: 11

[21:31] <jnthn> lizmat: That on Moar master, or spesh?

[21:31] <lizmat> hmmm... seems to segfault after any test

[21:32] <lizmat> master

[21:32] <lizmat> $ perl6 -v

[21:32] <lizmat> This is perl6 version 2014.03.01-83-gebd3729 built on MoarVM version 2014.03-63-g81d57d5

[21:35] *** bluescreen__ left
[21:37] *** BenGoldberg joined
[21:39] <lizmat> jnthn: it's *not* the last commit

[21:42] <jnthn> Hm, ok

[21:43] * jnthn wonders which it'll be...

[21:43] <jnthn> None of them seem likely candidates.

[21:43] <lizmat> caa39a8f6c6e8bfcdd514ed4f643f3a317ab62f7 breaks it

[21:44] <lizmat> I would assume special blocks somehow need it?  Or don't have *%_ set up at all ?

[21:46] <jnthn> lizmat: It's not about special blocks at all; it only impacts method declarations...

[21:47] *** bluescreen__ joined
[21:50] <jnthn> lizmat: It's really odd. I can't at all see how it could lead to a SEGV...

[21:50] *** rindolf left
[21:50] * lizmat checks again to make doubly sure it is caa39a8f6c6e8bfcdd514ed4f643f3a317ab62f7 who breaks things

[21:53] <lizmat> segfault on the 4th run of t/spec/S04-phasers/first.t

[21:53] <lizmat> going back one more commit

[21:53] *** rurban left
[21:56] <lizmat> 20 runs of t/spec/S04-phasers/first.t and not a single failure

[21:56] <lizmat> jnthn: so I'm afraid caa39a8f6c6e8bfcdd514ed4f643f3a317ab62f7 is the one :-(

[21:56] <jnthn> ugh

[21:56] <jnthn> OK. I've no idea what it could be.

[21:58] <lizmat> checking other special blocks

[21:59] <lizmat> to see if it is only FIRST, or any other phaser

[22:00] <jnthn> OK

[22:00] <jnthn> It's the "only fails sometimes" that worries me...

[22:03] <lizmat> yes, and that's even without threads  :-(

[22:04] <lizmat> FWIW, it only seems to happen with FIRST

[22:04] *** rurban joined
[22:04] <lizmat> seems a lot harder to get other tests in t/spec/S04-phasers to fail

[22:04] <lizmat> some are failing, but they don't appear to be part of spectest.data

[22:06] *** jnap1 left
[22:06] *** colomon left
[22:07] *** treehug88 left
[22:07] <lizmat> phasers are stored in a hash, so maybe key order differences between runs could be an explanation?

[22:08] <jnthn> maybe, but it still doesn't explain it too well...

[22:11] <BenGoldberg> Silly question about hash ordering:  While I realize that it's arbitrary, and cannot be depended on to be the same from one run to the next... how much effort goes into making the order *different* from one run to the next?

[22:11] *** Alula left
[22:11] *** rurban left
[22:11] *** bluescreen__ left
[22:11] *** colomon joined
[22:11] <dalek> rakudo/nom: 2b89776 | jonathan++ | src/Perl6/Actions.nqp:

[22:11] <dalek> rakudo/nom: Avoid parameter re-containering when possible.

[22:11] <dalek> rakudo/nom: 

[22:11] <dalek> rakudo/nom: In sub foo(Int $a) { ... }, we needn't wrap the incoming parameter up

[22:11] <dalek> rakudo/nom: in a scalar container, and instead can decontainerize and bind it. It

[22:11] <dalek> rakudo/nom: is safe since Int !~~ Iterable and Iterable !~~ Int, and thus we know

[22:11] <dalek> rakudo/nom: it doesn't need the container to promise non-flattening.

[22:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b89776bcf

[22:12] *** Alula joined
[22:12] * lizmat pulls and tests

[22:12] <jnthn> lizmat: Having trouble re-creating what you're seeing; I'll try some more tomorrow and also try to run it under the debugger.

[22:12] <lizmat> ack, almost time for sleep for me anyway

[22:12] <jnthn> lizmat: With the above I'm still at a non-regressed state.

[22:12] <jnthn> Also, above avoids quite a few more container creations.

[22:13] *** denis_boyun___ left
[22:13] * lizmat will run spectest and will report

[22:13] <jnthn> also:

[22:13] <jnthn> 9 843 335 CORE.setting.moarvm # before my work this evening

[22:13] <jnthn> 9 727 828 CORE.setting.moarvm # after my work this evening

[22:13] <lizmat> ~1%   cool!

[22:15] <lizmat> still seeing segfault in first.t

[22:15] <jnthn> aww

[22:15] <tadzik> not bad :)

[22:15] <jnthn> Any chance of a gdb backtrace?

[22:15] <jnthn> (tomorrow is fine, I'm gonna sleep now anyways)

[22:15] <lizmat> running full spectest to see if there is other breakage

[22:15] <lizmat> won't have much time tomorrow, mostly on the road to Zurich

[22:17] <lizmat> http://appweb2.ethz.ch/kurswesen/evento/dispatch.asp?fct=AnlassInfo&IDAnlass=1458

[22:17] <lizmat> from http://www.oetiker.ch/en/itservices/teaching-en-us/damian-conway-en-us/

[22:18] <jnthn> cool

[22:22] <tadzik> hah, r-m does forestfire significantly faster than r-j :)

[22:23] <lizmat> no apparent other breakage in spectest with latest commit

[22:24] *** rurban joined
[22:26] <jnthn> ok

[22:27] * lizmat gets some shuteye

[22:27] <lizmat> good night #perl6!

[22:27] * jnthn too

[22:27] <jnthn> 'night o/

[22:27] <tadzik> o/

[22:28] *** rurban left
[22:38] *** hoverboard left
[22:42] *** ivan``_ left
[22:44] *** jnap joined
[22:45] *** raiph left
[22:48] *** ivan`` joined
[22:48] *** ivan`` left
[22:48] *** ivan`` joined
[22:52] *** timo joined
[22:52] *** timo is now known as timo`

[22:53] *** dmol left
[22:53] *** rurban joined
[22:54] *** timo` left
[22:54] *** timo` joined
[23:00] <timo`> wow

[23:00] <timo`> time to replace all ssh keys

[23:01] <timo`> what a massive bother

[23:01] <colomon> ?

[23:01] <timo`> heartbleed.com

[23:02] <colomon> :(

[23:02] *** hoverboard joined
[23:02] <geekosaur> what?

[23:02] <geekosaur> no

[23:02] <geekosaur> ssh keys are not affected by this

[23:03] <timo`> host keys

[23:03] <geekosaur> TLS keys are

[23:03] <geekosaur> ssh does not use TLS

[23:03] <timo`> oh?

[23:03] <geekosaur> in particular ssh implements its own heartbeat, it *cannot* use the TLS heartbeat. completely incompatible protocol

[23:03] <colomon> oh, openSSL, not openSSH

[23:03] <timo`> well, that is a relief

[23:04] <colomon> one important letter different!   \o/

[23:04] <geekosaur> openssh does use openssl for crypto but it cannot use the TLS protocol and it's (an extension to) the TLS protocol that has the bug

[23:04] <timo`> thanks for clearing that up!

[23:04] <colomon> geekosaur++

[23:05] <geekosaur> it does mean that any server that uses https and uses openssl to implement it may have had its key stolen though

[23:05] <timo`> aye

[23:08] <timo`> i'll have a rakudo-moar benchmark of latest spesh changes soon and i'm also going to run nqp again for good measure

[23:08] <timo`> then i'll build a diff between 2014.03 nqp and rakudo against current master/spesh

[23:29] *** btyler left
[23:36] <timo`> need to build rakudo-moar/2014.03 first

[23:41] *** rurban left
[23:42] *** hoverboard left
[23:51] *** timo` left
[23:51] *** timo joined
[23:52] *** timo is now known as Guest20599

[23:53] *** Guest20599 is now known as timotimo

[23:58] *** bfulgham_ left
[23:59] *** ajr_ left
