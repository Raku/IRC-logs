[00:02] *** smls left
[00:06] <timotimo> ah, yes.

[00:06] <timotimo> when it's nicely optimized and all, the initial start-up time of farabi6 isn't that terrible any more

[00:06] <timotimo> however

[00:06] <timotimo> with my changes, i get a nice speed boost there as well

[00:07] <timotimo> m: say "i got a factor of { 0.197099208831787 / 0.000693559646606445 } improvement"

[00:07] <camelia> rakudo-moar 315ec6: OUTPUT«i got a factor of 284.1849432794774540 improvement␤»

[00:10] <timotimo> m: say ("a".."z").ords.join(", ")

[00:11] <camelia> rakudo-moar 315ec6: OUTPUT«97, 32, 98, 32, 99, 32, 100, 32, 101, 32, 102, 32, 103, 32, 104, 32, 105, 32, 106, 32, 107, 32, 108, 32, 109, 32, 110, 32, 111, 32, 112, 32, 113, 32, 114, 32, 115, 32, 116, 32, 117, 32, 118, 32, 119, 32, 120, 32, 121, 32, 122␤»

[00:11] *** chenryn left
[00:11] <timotimo> m: say ("a".."z")

[00:11] <camelia> rakudo-moar 315ec6: OUTPUT«"a".."z"␤»

[00:11] <timotimo> m: say ("a".."z").ords

[00:11] <camelia> rakudo-moar 315ec6: OUTPUT«97 32 98 32 99 32 100 32 101 32 102 32 103 32 104 32 105 32 106 32 107 32 108 32 109 32 110 32 111 32 112 32 113 32 114 32 115 32 116 32 117 32 118 32 119 32 120 32 121 32 122␤»

[00:12] <timotimo> oooh

[00:12] <timotimo> m: say ("a".."z")>>.ord.join(", ")

[00:12] <camelia> rakudo-moar 315ec6: OUTPUT«97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122␤»

[00:16] *** Alula left
[00:17] *** Alula joined
[00:18] <colomon> m: say ("a".."z").join("").ords

[00:18] <camelia> rakudo-moar 315ec6: OUTPUT«97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122␤»

[00:23] <timotimo> i wanted a representation i could copy & paste into a perl code file :)

[00:24] *** vendethiel left
[00:28] <timotimo> .tell azawawi i just sent out a pull request for HTTP::Easy that improves the time it takes to split a HTTP request into header and body by a factor of 300x, making the very first load of farabi6 much, much faster :)

[00:28] <yoleaux> timotimo: I'll pass your message to azawawi.

[00:28] *** anaeem1 left
[00:33] *** pierrot left
[00:34] *** pierrot joined
[00:36] *** vendethiel joined
[00:38] <timotimo> .tell azawawi my $index-file = '/home/azawawi/rakudo/install/languages/perl6/site/bin/index.data';

[00:38] <yoleaux> timotimo: I'll pass your message to azawawi.

[00:44] *** vendethiel left
[00:46] <timotimo> the p6doc-index has a super helpful entry "with C<m:s/a b/> or C<m:sigspace/a b/>, the blank in the regexes matches arbitrary whitespace"

[00:49] *** pochi left
[00:53] <dalek> doc: 1452a95 | (Timo Paulssen)++ | bin/p6doc-index:

[00:53] <dalek> doc: a little helper to locate the index file

[00:53] <dalek> doc: 

[00:53] <dalek> doc: farabi6 wants to read out the index itself

[00:53] <dalek> doc: review: https://github.com/perl6/doc/commit/1452a95b47

[00:55] *** gfldex left
[00:58] *** pochi joined
[01:00] *** vendethiel joined
[01:00] *** rurban joined
[01:08] *** xenoterracide left
[01:08] *** skarn left
[01:08] *** xenoterracide joined
[01:08] *** sivoais left
[01:13] *** xenoterracide left
[01:14] *** xenoterracide joined
[01:25] *** rurban left
[01:26] *** leont left
[01:31] *** sivoais joined
[01:33] *** xenoterracide left
[01:34] *** xenoterracide joined
[01:34] *** skarn joined
[01:34] * timotimo works on making the ansi color detection work

[01:34] *** xenoterracide left
[01:35] *** xenoterracide joined
[01:39] *** xenoterracide left
[01:39] *** xenoterracide_ joined
[01:50] *** silug left
[01:57] <timotimo> and off to bed i go

[01:58] <colomon> \o

[02:01] *** xenoterracide_ left
[02:13] <japhb> .ask timotimo Why does p6doc-index write it's own usage info manually, rather than just using #| doc comments for the MAIN multis and letting the magic do its job?

[02:13] <yoleaux> japhb: I'll pass your message to timotimo.

[02:13] <japhb> *its

[02:15] <japhb> .tell colomon For a fellow Perlish Forthwright: A Forth-in-Perl I wrote back in my Perl 5 days: http://www.broadwell.org/perl/ (gjbforth)

[02:15] <yoleaux> japhb: I'll pass your message to colomon.

[02:15] <colomon> o/

[02:15] <yoleaux> 02:15Z <japhb> colomon: For a fellow Perlish Forthwright: A Forth-in-Perl I wrote back in my Perl 5 days: http://www.broadwell.org/perl/ (gjbforth)

[02:18] <colomon> CamelForth?

[02:22] <colomon> japhb: that's some really nice looking p5 code.

[02:30] <Tekk_> japhb: forth in perl is really fun

[02:30] * Tekk_ wrote a really basic one once :)

[02:30] *** dayangkun joined
[02:39] *** chenryn joined
[02:41] <japhb> colomon: Lemme find the reference

[02:41] <japhb> Holy cow, it's *active*!  http://www.camelforth.com/news.php

[02:42] <japhb> I read the original articles

[02:44] *** ilbot3 left
[02:45] *** oetiker_ left
[02:46] *** ilbot3 joined
[02:59] <colomon> Woah, CamelForth isn't another Forth in Perl?  :)

[03:03] <japhb> Nope!  :-)  It caught my eye because it was a "teaching Forth" that I knew the assembly languages for (well, some of them, anyway)

[03:04] <colomon> I cut my teeth on 6502 Forth on the C64.  My first ever structured code.  :)

[03:07] <japhb> That is not a description that pops to mind when I think of an early Forth.  :-)

[03:08] <colomon> it was definitely more structured than C64 Basic.

[03:08] <japhb> Heh

[03:08] <japhb> NOT HARD.

[03:09] *** yeahnoob joined
[03:13] *** noganex joined
[03:16] *** noganex_ left
[03:33] *** fhelmberger joined
[03:38] *** fhelmberger left
[03:43] *** bjz joined
[03:50] *** BenGoldberg left
[03:52] *** rmgk_ joined
[03:52] *** rmgk is now known as Guest28978

[03:52] *** Guest28978 left
[03:52] *** rmgk_ is now known as rmgk

[03:54] *** vendethiel left
[03:56] *** vendethiel joined
[03:56] *** yeahnoob left
[03:59] *** xenoterracide_ joined
[03:59] *** BenGoldberg joined
[04:09] *** gfldex joined
[04:10] *** yeahnoob joined
[04:24] *** jack_rabbit joined
[04:33] *** BenGoldberg left
[04:35] *** bjz left
[04:40] *** mauke_ joined
[04:42] *** bjz joined
[04:44] *** mauke left
[04:44] *** mauke_ is now known as mauke

[04:47] *** ggoebel111111117 joined
[04:49] *** ggoebel111111116 left
[04:49] *** chenryn left
[05:02] *** gfldex left
[05:04] *** xenoterracide_ left
[05:12] *** [Sno] left
[05:26] *** chenryn joined
[05:46] *** oetiker joined
[06:15] *** kaare_ joined
[06:15] *** yeahnoob left
[06:16] *** FROGGS joined
[06:16] <FROGGS> lizmat: a big +1 to IO::Pipe

[06:16] *** khisanth_ joined
[06:17] *** Khisanth left
[06:19] *** gtodd left
[06:31] *** yeahnoob joined
[06:40] *** kaleem joined
[06:44] *** gtodd joined
[06:50] *** [Sno] joined
[06:56] *** esaym153 left
[07:04] *** anaeem1 joined
[07:05] *** anaeem1 left
[07:05] *** anaeem1 joined
[07:06] *** jac50 left
[07:09] *** esaym153 joined
[07:13] *** FROGGS left
[07:13] *** darutoko joined
[07:16] *** pecastro left
[07:33] *** fhelmberger joined
[07:35] * grondilu rewrote 'draw a sphere' into something like:  until start { do-this } { do-that } and wonders if a syntax like while { do-this } { do-that } would make sense or be usefeul.

[07:36] <grondilu> (https://gist.github.com/grondilu/ab824d3fbeaf54f9f9ba)

[07:38] *** fhelmberger left
[07:39] <lizmat> grondilu: if I understand your code correctly, you basically writing the file async?

[07:40] <lizmat> *made

[07:40] *** FROGGS joined
[07:40] <grondilu> lizmat: yes, so that I can watch the progress in real time.

[07:41] <lizmat> is each of the iterations of the for {} independent of each other ?  ( the pick(*) seems to indicate that)

[07:42] <lizmat> if so, have you tried replacing the until start { for ... -> {

[07:42] <lizmat> by await do for ... -> { start { ?

[07:42] <grondilu> not sure it's the same

[07:42] <lizmat> *that* would speed up calculation up a lot  

[07:43] <lizmat> if it doesn't break it  :-)

[07:43] <grondilu> 'until start {' repeats until the job has ended

[07:43] <lizmat> it would be a stress test for async

[07:43] <grondilu> oh

[07:43] <grondilu> hang on

[07:43] <grondilu> I see

[07:44] <FROGGS> lizmat: in the end I guess we want an openpipe() sub, so that we don't have a sub like open() that returns very different stuff depending on the arguments

[07:44] <grondilu> you're talking about making a thread for each pixel, right?  That seems violent.

[07:45] <lizmat> grondilu: in a world where you have 2K+ cores, it isn't  :-)

[07:47] <grondilu> but if I await do for, it won't write the file until everything is done, will it?

[07:47] <FROGGS> renderes like brazil create threads per bucket (16 by 16px for example), and only run N threads at a time (N is often #cores - 1)

[07:47] <lizmat> indeed

[07:47] *** erkan joined
[07:47] <lizmat> it will wait until *all* the promises returned, are either kept or broken

[07:47] <lizmat> FROGGS: start {} only puts it in the scheduler

[07:48] <grondilu> then I want until do for ... { start { } } { write-file(); sleep 1; }

[07:48] <lizmat> so rakudo would do this automagically more or less (less at the moment, I know, but you get the idea)

[07:48] <FROGGS> yes, so you already run only a few at a time

[07:49] <lizmat> grondilu: the last time I tried something like this, rakudo crashed in interesting ways (like japhb++ noted yesterday)

[07:49] <FROGGS> lizmat: about openpipe(), this would look like run() or shell() wrt signature, except that we also tell it that we want to read or write

[07:49] <lizmat> so: if it works, great!   if it doesn't, please keep the code around for when got thos wrinkles out of moar / libuv

[07:49] *** immortal left
[07:50] * grondilu tries

[07:51] *** JimmyZ joined
[07:51] *** dayangkun left
[07:52] <grondilu> use of uninitialized value of type Any in numeric context 

[07:52] <JimmyZ> grondilu: oh, you gist code got a segfault on moarvm :P

[07:52] <JimmyZ> segfault or 'invalid status 830244808 in GC orchestrate'

[07:52] <grondilu> Segmentation fault

[07:52] <lizmat> I was afraid so   :-(

[07:52] <JimmyZ> a nice bug to report to moarvm

[07:54] <grondilu> the truth is I hadn't actually tried the code currently on gist.  The previous version worked and differed only in that the start was affected to a variable.

[07:54] <JimmyZ> I will file a bug to moarvm 

[07:55] <grondilu> the previous version that worked: https://gist.github.com/grondilu/ab824d3fbeaf54f9f9ba/b98f317a82b23cd2be197536ced176f3914bae68   Differs only in syntax.

[07:56] <grondilu> (well, not in syntax actually, but in that there is an additional temp var)

[07:57] <grondilu> (or maybe @pixels being out of MAIN, but I doubt that matters)

[07:58] *** krunen joined
[07:59] <grondilu> just checked.  my $job = start { do-this }; until $job { do-that }  # works

[07:59] <grondilu> until start { do-this } { do-that }; # doesn't

[08:00] <moritz> try

[08:00] <moritz> until (start { do-this }) { do-that };

[08:00] <moritz> ah no

[08:00] <moritz> never mind

[08:00] <moritz> until (start { do-this }) { do-that }; would start a new job for each iteration of the loop

[08:00] <moritz> not what you want

[08:01] <grondilu> oh yeah

[08:02] <grondilu> wait, I am confused now

[08:03] *** chenryn left
[08:03] <grondilu> m: until start { say "A"; sleep 1 } { say "B" }

[08:03] <camelia> rakudo-moar 315ec6: OUTPUT«A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤Memory allocation failed; could not allocate 8480 bytes␤»

[08:03] <grondilu> m: until $ = start { say "A"; sleep 1 } { say "B" }

[08:03] <camelia> rakudo-moar 315ec6: OUTPUT«A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤A␤B␤Memory allocation failed; could not allocate 8480 bytes␤»

[08:04] <grondilu> m: my $job = start { say "A"; sleep 1 }; until $job { say "B" }

[08:04] <camelia> rakudo-moar 315ec6: OUTPUT«A␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤…»

[08:04] <grondilu> it does indeed repeat the "do-this".

[08:10] *** chenryn joined
[08:14] *** zakharyas joined
[08:15] *** baest joined
[08:23] <moritz> m: my $job = start { say "A"; sleep 1 }; until $job { say "B"; sleep 0.1 }

[08:23] <camelia> rakudo-moar 315ec6: OUTPUT«A␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤»

[08:23] <moritz> m: my $job = start { say "A"; sleep 1; say 'A done' }; until $job { say "B"; sleep 0.1 }

[08:23] <camelia> rakudo-moar 315ec6: OUTPUT«A␤B␤B␤B␤B␤B␤B␤B␤B␤B␤B␤A done␤»

[08:34] *** rindolf joined
[08:35] *** kjs_ joined
[08:35] *** JimmyZ_ joined
[08:37] *** JimmyZ left
[08:37] *** JimmyZ_ is now known as JimmyZ

[08:37] *** JimmyZ left
[08:38] *** kjs_ left
[08:42] *** tgt joined
[08:52] *** tgt left
[08:56] *** virtualsue joined
[08:57] *** fhelmberger joined
[09:00] *** brrt joined
[09:03] *** bjz left
[09:03] *** bjz joined
[09:08] *** ptc_p6 joined
[09:16] *** Ven joined
[09:16] <Ven> masak: http://www.reddit.com/r/programming/comments/2kowrd/status_of_perl_6/clne3aq :)

[09:16] <Ven> o/, #perl6

[09:17] <dalek> roast: 16bbdc6 | (Elizabeth Mattijsen)++ | S17-scheduler/ (4 files):

[09:17] <dalek> roast: Make sure we cancel all cued code

[09:17] <dalek> roast: 

[09:17] <dalek> roast: Hopefully this will make the JVM spectest using the eval server a viable option

[09:17] <dalek> roast: again.

[09:17] <dalek> roast: review: https://github.com/perl6/roast/commit/16bbdc62ea

[09:20] <Ven> .tell masak http://www.reddit.com/r/programming/comments/2kowrd/status_of_perl_6/clne3aq :)

[09:20] <yoleaux> Ven: I'll pass your message to masak.

[09:22] *** denis_boyun_ joined
[09:22] <brrt> wow, reddit is capable of positivity?

[09:24] <lizmat> 1/42 responses, afaics

[09:24] <brrt> but still :-)

[09:24] *** virtualsue left
[09:25] <moritz> I wonder if it's meant ironically :-)

[09:26] <brrt> nah.. reddit may not be a very positive place, but that doesn't mean we have to be the same

[09:26] *** kjs_ joined
[09:27] <moritz> also reddit has this disparity where the voting shows that the majority of readers like it, but the majority of commenters are very negative

[09:28] <Ven> Well, I can understand a pill that's been sitting here for 14 years is a bit bitter to swallow.

[09:29] *** yeahnoob left
[09:29] <brrt> hmm... not I

[09:30] <brrt> perl6 has taken it's time to develop and mature

[09:30] <brrt> so what

[09:30] <brrt> it's a technological project

[09:31] <brrt> it's not as if this causes some irrepairable damage

[09:31] <dalek> rakudo/nom: 6159f1d | (Elizabeth Mattijsen)++ | src/core/CurrentThreadScheduler.pm:

[09:31] <dalek> rakudo/nom: CurrentThreadScheduler can now also .cancel

[09:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6159f1dd4a

[09:32] <peteretep> brrt: There are Perl 5 developers of the view that Perl 6 killed Perl 5

[09:32] <Ven> brrt: that's not the issue. it was said "it's almost ready" a lot of times, and that gets people chewing on nothing

[09:32] <brrt> wait, lizmat, how does that work, how can you cancel a task on the current thread

[09:32] <lizmat> it doesn't, it's completely fake  :-)

[09:33] <brrt> peteretep: but that's kind of a passive world view right

[09:33] <brrt> as in, nobody could have improved / saved perl5 because perl6 was there

[09:33] <lizmat> afk for a few hours&

[09:34] <brrt> as if the pressence of other people working on another project inhibited the development of perl5 in any way

[09:34] <brrt> Ven: 'ready' is a moving target

[09:34] <brrt> :-)

[09:34] <Ven> brrt: ...which doesn't address the issue at hand.

[09:34] <Ven> "I thought I was in *it*, but then they changed what *it* means, and I'm not in anymore"

[09:35] <brrt> well, that happens

[09:35] <brrt> no reason to have hard feelings imho

[09:36] <Ven> I don't have hard feelings. I couldn't care less, I don't know perl 5. It's just that I can empathize.

[09:36] <Ven> http://www.reddit.com/r/perl/comments/2kkfk2/rakudo_perl_6_and_moarvm_performance_advances/ <- a more positive thread :P

[09:37] <brrt> :-)

[09:37] <brrt> i guess i can empathize with broken expectations

[09:37] <brrt> but that should not lead to hate among reasonable people

[09:37] *** pmurias joined
[09:37] <Ven> It's reddit. Who talked about reasonable people?

[09:38] <huf> programmers as a whole? reasonable people?

[09:38] <huf> we hold intense discussions on which editor is factually superior

[09:38] <huf> none of the discussions contain actual facts

[09:38] <Ven> Especially r/programming. It's mostly a bunch of script kiddies in awe before the Next Big Thing and with hundreds of replies on clickbait-titled articles :/

[09:38] <Ven> huf: yeah, but vimscript is not as good as elisp.

[09:38] <Ven> *g*

[09:38] <huf> i'll give you that

[09:39] <arnsholt> Vimscript is nuts...

[09:39] <huf> and elisp has had lexicals for a while now...

[09:39] <Ven> .oO( just use emacs with evil! )

[09:39] <huf> i dont even understand the purpose of vimscript. why even have it? why not just some random language like lua or tcl or perl or whatever

[09:39] <huf> or elisp!

[09:40] <brrt> i thought vim was perl-scriptable

[09:40] <huf> yeah, it is now

[09:40] <huf> but i assume it was originally vimscript-only

[09:40] <huf> and then the kitchen sink got added (perl, python, ruby, cake)

[09:40] <brrt> well, to be fair, having your own scripting language kind of was a unix rite of passge at one time

[09:40] <brrt> (for a program)

[09:40] <pmurias> vimscript was gradually evolved from the ex command language

[09:40] <huf> :)

[09:41] <huf> pmurias: ah! history.

[09:41] <pmurias> my guess is by random mutation

[09:41] <Ven> pmurias: very interesting. have got links on how that happened, maybe?

[09:42] *** virtualsue joined
[09:47] <pmurias> Ven: not really, I'm mostly guessing it was gradually evolved as it doesn't show any signs of being intelligently designed ;)

[09:47] *** TuxCM left
[09:47] <Ven> ha, that's harsh :P

[09:48] <Ven> (but true, just looking at my .vimrc...)

[09:49] *** virtualsue left
[09:51] <masak> Ven: http://www.reddit.com/r/programming/comments/2kowrd/status_of_perl_6/clne3aq -- :)

[09:51] <yoleaux> 09:20Z <Ven> masak: http://www.reddit.com/r/programming/comments/2kowrd/status_of_perl_6/clne3aq :)

[09:52] <Ven> eh.

[09:52] <Ven> masak++ anyways.

[09:52] <masak> moritz: both reddit and HN have a mechanism that enhance disagreements in threads.

[09:53] <Ven> do they?

[09:53] <masak> yes. people who agree don't reply.

[09:53] <Ven> they upvote, though

[09:53] <masak> right; so you end up having a lot of upvoted comments arguing back and forth.

[09:54] <masak> the fact that upvotes (agreement) are a property of comments (disagreement) is itself telling.

[09:54] <masak> Ven: I'm assuming you saw the Lisp I wrote yesterday.

[09:54] <masak> Ven: I now want to add macros to it. how should I do it? :)

[09:55] <Ven> eh. How does variance works in c#? If I override a `List<T> where T=Foo` with a List<Foo>, it doesn't consider it an overload...

[09:55] <Ven> masak: I... didn't :)

[09:55] * Ven backlogs at various times in the day...

[09:55] <masak> Ven: https://github.com/masak/ipso

[09:56] <Ven> masak: debugger invoked on a: Y-U-NO-CAPS :P

[09:56] <masak> within 200 lines, there's a Perl 6 implementation of eval, and a Lisp eval builtin.

[09:56] <Ven> ...now make it a  slang :DDD

[09:56] <moritz> masak++

[09:56] <Ven> masak++ indeed.

[09:56] <Ven> I'd leave caar and the family be generated by macros :P

[09:57] <masak> well, I don't *have* macros yet.

[09:57] <Ven> I know, I know :)

[09:57] <masak> and besides realizing that they will somehow be a part of the reader, I don't have much of a clue for how to get them.

[09:57] <Ven> (they probably want to be macros as well, though, so that (setf (car a) 'b) works)

[09:57] <moritz> masak: once thing I don't understand is why you need to have caar etc. once in %SETTING, and once as a sub in eval

[09:57] <moritz> *one thing

[09:58] <moritz> feels redundant

[09:58] <masak> moritz: I don't. I could probably remove those at this point.

[09:58] <masak> moritz: but I wrote the Perl 6 part first, so then I couldn't use the setting.

[09:58] <Ven> masak: I'm guessing you know how to get lexical scope at this point...

[09:58] <Ven> macros aren't reader-wise, btw.

[09:58] <Ven> (...except for reader-macros...)

[09:59] <masak> Ven: I have a hunch how to get lexical scope, yes. the key is tying scope to functions instead of to the interpreter.

[09:59] <Ven> masak: Your AST can just carry around a Scope, which is "inheriting" (in the prototype-based sense) parent scopes

[09:59] <Ven> or,if you want to do it visitor-style, you pass the scope

[10:00] <masak> Ven: let's please do the Perl 6 thing and ban "parent" outright for scopes.

[10:00] <masak> Ven: you mean "outer".

[10:00] <moritz> basically lexical scoping means having more than one %env

[10:00] *** spider-mario joined
[10:00] <Ven> sure, sure, outer.

[10:00] <Ven> it means a tree of %env :D

[10:00] <moritz> nope

[10:00] <masak> moritz: and the envs that you have sit on the functions, and they are singly-linked back up to the root.

[10:01] <moritz> masak: aye

[10:01] <moritz> but I don't think it ever needs to be a tree

[10:01] <masak> it does mean a tree of %env. kind of.

[10:01] <Ven> ...that's a tree for me...

[10:01] <masak> because of block re-entry.

[10:01] <Ven> The tree doesn't have to be filled at AST-time

[10:01] <masak> what I said ("singly-linked back up to the root") induces a tree.

[10:01] <moritz> if you support continuations, yes

[10:01] <masak> nonono

[10:02] <masak> if you support first-class closures!

[10:02] <moritz> oh right

[10:02] <masak> :)

[10:02] <moritz> never mind, it's a tree :-)

[10:02] <masak> haha

[10:02] <Ven> masak: do you want phased macros or ..."in-place" macros?

[10:02] <Ven> hehe :P

[10:02] <masak> Ven: please run me through their various merits.

[10:02] <masak> I'll probably go for the simplest one first.

[10:03] <masak> re-implementing pg's evaluator was delightfully simple. I'd like to keep it delightfully simple.

[10:03] <Ven> masak: well, I'm a bit biased, as I don't really like phased macros. They probably allow for cleaner implementations, though. A phased macros means that a macro-in-a-macro is "level 2", and so you need to declare functions in a "nested level"

[10:03] <masak> by the way, I plan to blog about this as soon as I have something with the eval function actually making macros easier/feasible.

[10:03] <Ven> scheme and racket use (begin-for-syntax) and (begin-for-meta) (iirc) for that. Or, (require (for-syntax racket/base))/(require (for-meta 2 racket/base))

[10:04] <Ven> Though admittedly, racket and scheme also have a -1 level that corresponds to their templates

[10:04] <masak> hm. ok.

[10:04] <Ven> with the "in-place" (aka CL's, and the ones before), you just register the macro/function/variable as soon as you encounter it

[10:05] <masak> Ven: stop me when I get it wrong: you register a macro, that is you put the macro in a lexical binding somewhere.

[10:06] <masak> Ven: then, during parsing, before evaluation of a program, macros are matched and expanded in some order that makes sense.

[10:06] <Ven> masak: no - here's the difference.

[10:06] * masak likes learning new stuff

[10:06] <Ven> CL macros are part of the evaluation of the progrma... kind of

[10:06] <masak> then they must at least be an early part.

[10:07] <Ven> ...yes and know. But being "too early" would prevent, for example, reader macros

[10:07] <Ven> because you need to parse and execute code *before reading the rest of the file*

[10:07] <masak> not sure I get that, but go on.

[10:07] <masak> like, (list a b c) could probably be expanded into (cons a (cons b (cons c '()))) through some appropriately-defined macro.

[10:08] *** TuxCM joined
[10:08] <Ven> well, it's very simple. If the program was just reading->parsing->evaluating, I couldn't define a reader macro and use it just after, because it'd be a parse error

[10:09] <masak> I see.

[10:09] <Ven> (with that kind of parsing, by the time the macro would be defined, the read was already made and said invalid)

[10:09] <Ven> s/made/done/

[10:09] <masak> I think I need to read up on reader macros. :)

[10:09] <arnsholt> They're essentially lex-stage macros, IIRC

[10:09] <Ven> .also... it's not really early. Fire up a SBCL and try this:

[10:10] <arnsholt> (The reader being the lexer)

[10:10] <Ven> (let ((a 5)) (defmacro bar () a)) (bar)

[10:10] <Ven> arnsholt: it's a bit more complicated than that are there are multiple readtables and al, but yes

[10:10] <Ven> ^ and yes, the (bar) call *does* print 5 ;-)

[10:11] <Ven> Now, the really interesting one is, what do you think this prints? :

[10:11] <Ven> (let ((a 5)) (defmacro bar () (print a) a)) (bar)

[10:13] <Ven> masak: you don't "need" reader macros, though. clojure is doing fine without them!

[10:13] <masak> back later &

[10:13] <Ven> :P

[10:14] <Ven> I have no clue what I'm doing, btw.

[10:20] *** yeahnoob joined
[10:22] *** chenryn_ joined
[10:22] *** chenryn left
[10:23] *** Akagi201 left
[10:24] *** chenryn_ left
[10:25] *** chenryn_ joined
[10:25] *** chenryn_ left
[10:25] *** pmurias left
[10:25] *** chenryn_ joined
[10:26] *** exixt left
[10:26] *** jack_rabbit left
[10:31] *** exixt joined
[10:33] <moritz> understanding is overrated

[10:34] <Ven> :-)

[10:37] <Ven> I'm sure I'm not the only one that helps friends just by reading wikipedia pages and googling!

[10:37] <timotimo> o/

[10:37] <yoleaux> 02:12Z <japhb> timotimo: Why does p6doc-index write it's own usage info manually, rather than just using #| doc comments for the MAIN multis and letting the magic do its job?

[10:37] <timotimo> .tell japhb i didn't write p6doc-index, i just wanted to add a little feature and didn't want to rewrite the code like that :)

[10:37] <yoleaux> timotimo: I'll pass your message to japhb.

[10:37] *** virtualsue joined
[10:37] *** kurahaupo joined
[10:38] <Ven> japhb: ooh, MAIN uses #| doc comments for each task? that's so amazing

[10:38] <timotimo> it does?

[10:39] <brrt> \o timotimo

[10:40] <timotimo> reddit is severely rate-limiting my posting :S

[10:44] <timotimo> i do think i have something worth adding to the conversation

[10:44] <timotimo> but there'll inevitably be some hate, no matter what exactly i'd write ... because this is the internet

[10:46] <Ven> timotimo: oh, don't say that... It's not the internet...

[10:46] *** FROGGS left
[10:46] <Ven> I hated you as much IRL. <3

[10:46] <timotimo> <3

[10:51] <timotimo> peteretep: i kind of find it weird to say "doesn't have non-blocking IO across all its backends" when we have that on JVM and MoarVM, just not on parrot (and never will)

[10:51] <tadzik> just skip that part :D

[10:52] <arnsholt> Or non-blocking IO on all backends except Parrot

[10:52] <timotimo> on the reddit thread, someone seemed to think perl6 "still has no support for threads"

[10:53] <brrt> it's somewhat easy to think that. we haven't exactly advertised it much

[10:55] <timotimo> yeah, jnthns voice tends to be kind of low in these awesome presentations he's giving a few times per year displaying all the crazy-cool shit we (well, "he") have been making

[10:59] * brrt afk

[11:01] *** yeahnoob left
[11:04] *** sqirrel_ joined
[11:13] *** pecastro joined
[11:13] *** gfldex joined
[11:17] <masak> "understanding is overrated" is a good slogan for some of the tests I write.

[11:17] <masak> and I mean that in the best of ways.

[11:17] <masak> it's like I'm outsourching to the unit tests some of the need to understand every detail.

[11:18] <timotimo> if you don't understand something, you'll end up asking much tougher questions

[11:18] <timotimo> which is what tests need in order to be really effective, right?

[11:19] <masak> tests need to ask "what does the use look from the outside?"

[11:19] <masak> if the implementation makes the tests happy, then *either* you've arrived, *or* you have more tests left to write.

[11:19] <masak> I'm talking about the freedom that comes with relying on that fact.

[11:20] <timotimo> OIC

[11:21] <masak> I have this demo I do in some of my courses, as a way to sneak TDD into other topics.

[11:21] <masak> I implement roman numerals. from integer 14 to string "XIV", etc.

[11:22] <masak> one nice thing about that task is that I can ruthlessly focus on the task at hand, just adding more exceptions in the form of if statements. thinking only about making the tests happy.

[11:22] <masak> and then with a little bit of refactoring afterwards, I still end up in a nice place. nicer, in fact, than one ends up with without tests (on average).

[11:22] <masak> in fact, the task is very amenable to refactoring, because of the "symmetry" between ones, tens, and hundreds.

[11:38] *** sqirrel_ left
[11:46] *** chenryn_ left
[11:49] *** salv0 left
[11:49] *** salv0 joined
[11:51] *** azawawi joined
[11:51] <azawawi> hi 

[11:51] <yoleaux> 00:28Z <timotimo> azawawi: i just sent out a pull request for HTTP::Easy that improves the time it takes to split a HTTP request into header and body by a factor of 300x, making the very first load of farabi6 much, much faster :)

[11:51] <yoleaux> 00:38Z <timotimo> azawawi: my $index-file = '/home/azawawi/rakudo/install/languages/perl6/site/bin/index.data';

[11:51] <azawawi> timotimo++

[11:52] <azawawi> timotimo: all the changes to farabi6 and http-easy are now merged

[11:57] *** mauke_ joined
[11:58] <masak> I still feel I don't have a good answer to the question "where do macros fire in the Lisp read-eval cycle?"

[11:58] <masak> I guess it depends on the type of macro and so on. that's fine.

[11:58] <masak> so I'll have to start by getting an OK overview.

[11:59] *** notfix is now known as xfix

[11:59] *** mauke left
[12:00] <azawawi> .tell timotimo In HTTP::Easy, $first-chunk can become Any after the recv loop on rare occasions while using the firefox browser

[12:00] <yoleaux> azawawi: I'll pass your message to timotimo.

[12:01] *** mauke_ is now known as mauke

[12:02] *** leont joined
[12:03] <azawawi> http://feather.perl6.nl:8080/   # is way faster than before. timotimo++

[12:05] *** ggoebel111111117 left
[12:05] *** smls joined
[12:06] <smls> regarding http://perl6.guide, surely there are some more "recent" developments than JVM that could be listed?

[12:07] <smls> MoarVM; implementation of the concurrency stuf; first few microbenchmarks beating Perl 5; etc

[12:08] *** amkrankruleuen left
[12:10] *** xinming_ joined
[12:10] <masak> "Contrary to popular belief, LISP was not originally derived from Church's λ-calculus." --  say what now?

[12:10] <masak> (from http://dspace.mit.edu/bitstream/handle/1721.1/6094/AIM-453.pdf )

[12:10] <brrt> that surprises me as well

[12:10] *** ibo2perl6 joined
[12:13] *** xinming left
[12:13] *** kill joined
[12:13] *** kill is now known as amkrankruleuen

[12:14] *** amkrankruleuen left
[12:14] *** amkrankruleuen joined
[12:16] <Ven> masak: back!

[12:16] <ibo2perl6> azawawi: when I run farabi6 I get something like: farabi.js is not found in ~/languages/perl6/site/lib/Farabi6/files/assets

[12:18] *** ggoebel111111117 joined
[12:18] <Ven> masak: well, it's... "as-it-goes"

[12:18] <Ven> you evaluate code as you see it

[12:19] *** ab5tract joined
[12:19] <Ven> when you read the code, you always check your readtable to see if it matched something. Once you've expanded all reader macros, you have your lisp tree

[12:19] <Ven> you then start looking for macros to expand from the inside, then once everything is expanded, you evaluate it

[12:21] *** denis_boyun joined
[12:21] *** denis_boyun_ left
[12:21] <Ven> Or something like that. I don't know, I can't common lisp :P

[12:22] <dalek> Perlito: 5961094 | (Flavio S. Glock)++ | / (2 files):

[12:22] <dalek> Perlito: Perlito5 - parser - protect compiler lexical variables during BEGIN execution

[12:22] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/5961094733

[12:22] <Ven> masak: macros carry around their lexical scope, as my pastes earlier showed

[12:25] <dalek> Perlito: a7bbc70 | (Flavio S. Glock)++ | TODO-perlito5:

[12:25] <dalek> Perlito: Perlito5 - js - TODO update

[12:25] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/a7bbc7095d

[12:26] <azawawi> ibo2perl6: the farabi6 server process has died because of a bug... are you using firefox?

[12:26] <ibo2perl6> azawawi: ok I set a symbolic link perl6/rakudo/install/languages -> languages

[12:27] <azawawi> ibo2perl6: i see, you're running it locally, right?

[12:28] <ibo2perl6> azawawi: yes I am using ff and I am running it locally but now get  "No such method 'subbuf' for invocant of type 'Any'" in method run at lib/HTTP/Easy.pm6:88

[12:29] <azawawi> ibo2perl6: try chromimum for now

[12:29] <azawawi> ibo2perl6: it is a parsing bug in http-easy

[12:29] *** kaleem left
[12:30] <ibo2perl6> azawawi: yes in chromium it works azawawi++

[12:31] <azawawi> ibo2perl6: have fun :)

[12:38] *** denis_boyun left
[12:39] *** denis_boyun joined
[12:40] *** amkrankr1leuen left
[12:41] <masak> Ven: what's the outer scope of the scope that the macro carries? the outer where it was defined?

[12:42] <Ven> masak: yes.

[12:42] <Ven> (let ((a 5)) (defmacro bar () (print a) (print "foo") "bar"))

[12:42] <Ven> then (bar) gives 5 "foo" "bar"

[12:45] *** khisanth_ is now known as Khisanth

[12:46] <masak> after the macro has been applied by whatever process, does it turn into a JS-style IIFE? otherwise, what's the mechanism that gives the macro-as-applied-in-code its own scope with its own outer?

[12:49] <Ven> masak: erm, it's a bit.. different.

[12:50] <Ven> say, `(let () (defmacro x () 5) (x))` will blow up. The macro is not "defined" before the end of the top-level expr

[12:51] *** ibo2perl6 left
[12:51] *** ibo2perl6 joined
[12:51] <timotimo> azawawi: i'll look into that Any bug

[12:51] <yoleaux> 12:00Z <azawawi> timotimo: In HTTP::Easy, $first-chunk can become Any after the recv loop on rare occasions while using the firefox browser

[12:52] <Ven> masak: that's the hard part, btw.

[12:52] <Ven> masak: but no, it doesn't need to carry anything out. CL isn't perl6 -- the subs/macros aren't lexical

[12:52] *** ibo2perl6 left
[12:53] *** guru joined
[12:53] *** guru is now known as Guest59613

[12:53] *** Guest59613 is now known as ajr_

[12:54] <timotimo> i have a feeling that bug will be interesting to find.

[12:54] <Ven> masak: as a "reminder", you need to pay attention to the fact that the lexical scope is used at *macro time*, not when returning stuff. That's very important

[12:54] <timotimo> the only way i can think of that'd cause that behavior is if the first .recv gives us nothing at all

[12:54] <Ven> (which *might* be related to my previous comments about `my $a = 1; quasi { ...} ` in perl6...)

[12:55] *** jimisdam joined
[12:55] <jimisdam> Hey !

[12:55] <Ven> \o

[12:55] *** sqirrel_ joined
[12:56] *** anaeem1 left
[12:56] *** woolfy left
[12:56] *** mephinet left
[12:57] *** rmgk left
[12:57] *** smls left
[12:57] *** cosimo_ left
[12:57] *** cosimo joined
[12:57] <timotimo> hi there

[12:58] <Ven> masak: macros really are functions that return syntax – nothing more. This works in perl6, as well:

[12:58] *** rmgk joined
[12:58] <Ven> m: my &foo; { my $a = 1; { &a = sub { $a++ } } }; say foo, foo;

[12:58] <camelia> rakudo-moar 315ec6: OUTPUT«===SORRY!=== Error while compiling /tmp/3fDf8bj39H␤Undeclared routine:␤    &a used at line 1␤␤»

[12:58] <Ven> m: my &foo; { my $a = 1; { &foo = sub { $a++ } } }; say foo, foo;

[12:58] <camelia> rakudo-moar 315ec6: OUTPUT«12␤»

[12:59] <Ven> masak: ^ the exact same happens in CL.

[12:59] *** woolfy joined
[12:59] *** jimisdam left
[12:59] <azawawi> timotimo: it happens with firefox browsers and rarely with chrome

[12:59] <timotimo> i've added a bit of debug print to see if my intuition is right

[12:59] <timotimo> i'll use firefox to reproduce. thanks!

[13:00] <azawawi> timotimo: i can replicate it on feather.perl6.nl btw

[13:00] <azawawi> timotimo: i'll enable :debug

[13:04] <masak> Ven: I notice that I am very, very confused.

[13:04] <masak> Ven: not because of you. I'm sure your explanations are great.

[13:04] <Ven> masak: I am so sorry. I'm terrible at explaining

[13:04] <masak> Ven: I'm just not seeing the things I need yet for a solid mental model of the thing.

[13:05] <Ven> okay. Just as you did for perl6, forget that a macro is more than a function. It's just a function that happens to return syntax.

[13:05] <Ven> What's preventing it from having a lexical scope? The access to the lexical scope is done *before* the macro is expanded. Just when it's preparing the code to return. In its body

[13:05] <masak> this defmacro thing -- it's a primitive, yes? like lambda?

[13:06] <[Coke]> bartolin++ # thanks for taking the lead on ticket wrangling!

[13:06] <Ven> We're not using the macro's lexical scope in the quasiquoting part. We're using it in the body – like a function would.

[13:06] <Ven> masak: yes

[13:06] <masak> ok, so the eval function handles it.

[13:06] <azawawi> timotimo: added --verbose option to enable debug info in farabi6

[13:06] <Ven> definitely

[13:06] <Ven> masak: will you be at FOSDEM2015?

[13:06] <masak> no :/

[13:06] <masak> I will start missing a bunch of conferences from now on for a while.

[13:07] <timotimo> thanks :)

[13:07] * Ven won't be there either :P

[13:08] *** dwarring left
[13:08] <[Coke]> winner called at: src/gen/m-CORE.setting, line 20305

[13:08] <[Coke]> ^^ today's roast run.

[13:09] <azawawi> timotimo: http://paste.debian.net/129394/  # farabi6 crash log

[13:09] <Ven> masak: when you encounter a defmacro, you just store the macro somewhere. In almost the same place as functions. But with a special flag instead

[13:09] <Ven> and then, when the reader returns a read tree, you recursively expands the macros you can find, from the inside out

[13:10] <masak> ah!

[13:10] <masak> this *does* resonate with me.

[13:10] <arnsholt> IIRC CL stores macros as special functions in the same place as functions

[13:10] <timotimo> [2014-10-30T13:10:36Z] Client connection received.

[13:11] <timotimo> use of uninitialized value of type Any in numeric context  in method run at lib/HTTP/Easy.pm6:89

[13:11] <masak> ok, let's momentarily forget about the definition of macros. let's just say we have a bunch of macros defined somewhere.

[13:11] <Ven> arnsholt: it probably does, that's why I said that :-)

[13:11] <timotimo> got this in my debug; even though i added a say statement at the very beginning of the loop that'd tell how many bytes have been found

[13:11] <timotimo> i'll have a look in wireshark to see what's up there

[13:11] <masak> (I think that's where I'm going to start in Ipso anyway, since I haven't really worked out the story for defining things in general, and that'll change around anyway once we get lexical scoping.)

[13:11] <Ven> :-)

[13:11] <Ven> I'll be around if you somehow need me...

[13:12] <arnsholt> IIRC defmacro() compiles down to something like (setf (symbol-function $the-name) $macro-code)

[13:12] <masak> so, the reader is about to return a big S-expression. before it does so, it does all the macro replacements, inside-out. correct?

[13:12] <azawawi> what's better $filename.IO.slurp or $filename.path.slurp ?

[13:12] <masak> arnsholt: ooh, setq and setf -- there's two of them because CL is a Lisp-2, right?

[13:13] <moritz> azawawi: I'd go with .path, because it's more transparent to me what that does

[13:13] <moritz> azawawi: though maybe lizmat++ will correct me soon :-)

[13:13] <Ven> masak: actually, no

[13:13] <arnsholt> No, setf is a more general setter

[13:13] <masak> oh.

[13:13] <Ven> setq is just setf underneath

[13:13] <arnsholt> Other way, no?

[13:13] <masak> I think what I have so far is actually more of a Lisp-1. because I can put lambdas in the first position.

[13:13] <Ven> setf is "set form", setq is "set quoted" (kinda)

[13:13] <Ven> arnsholt: is it? 

[13:13] <masak> oh. is one of them a macro? :)

[13:13] <arnsholt> setf is a very magical macro

[13:13] <Ven> ...very very magical.

[13:14] <Ven> to allow stuff like (setf (car a) 1) to work

[13:14] <arnsholt> Yeah

[13:14] <masak> o.O

[13:14] <Ven> you can define your own ... "setf handlers" so that (setf (masak foo) 1) works

[13:14] <masak> that's... kinda Perlish, actually.

[13:14] * masak backs away very slowly from setf

[13:14] <Ven> please do...

[13:14] <arnsholt> Perl is pretty much CL in Algol clothing

[13:14] <masak> MJD would approve.

[13:14] <arnsholt> Minus macros (for the time being ;)

[13:15] <Ven> .oO( PUT THE SETF DOWN! YOU CAN STILL GET AWAY WITH IT )

[13:15] <masak> arnsholt: we'll see about that. bwhahaha

[13:15] <arnsholt> Have you looked at loop() yet? =)

[13:15] <Ven> setf is "set field", sorry.

[13:15] <Ven> arnsholt: he's a functional programmers. He doesn't wan' no stinkin' loops

[13:15] <masak> arnsholt: was going to ask you to take your loop() and do something rude with it. stopped myself just in time. :P

[13:16] <arnsholt> =D

[13:16] <Ven> `loop` is one of the biggest hacks in CL I think

[13:16] <arnsholt> I like loop when I program in CL. In part because is so very much *not* Lispy =)

[13:16] <timotimo> azawawi: i'm kinda confused.

[13:16] <Ven> arnsholt++: you are kind-of-right. setf falls back to setq if no handlers have been defined

[13:17] <Ven> (setf a 5) will indeed call setq (which itself will call set: `(setq a 5)` is `(set 'a 5)`)

[13:17] <Ven> however, "special" setf do whatever they want (setf car uses rplaca, for example)

[13:18] <Ven> arnsholt: do you even `collect`

[13:18] <Ven> (or :collect, you decide)

[13:19] <arnsholt> Frequently (loop for stuff do (loop for other-stuff do (loop for more-stuff do things)))

[13:19] <arnsholt> For typical maps mapcar is fine =)

[13:19] <masak> I think I will implement (set 'a 5) and nothing more.

[13:19] <masak> maybe setq as a macro, we'll see.

[13:19] <arnsholt> Sounds very reasonable =)

[13:19] * masak likes to think he is very reasonable :)

[13:19] <Ven> arnsholt:  I plead guilty. https://github.com/vendethiel/readlist.cl/blob/master/utils.lisp#L3 <- this one is "fine"

[13:20] <Ven> https://github.com/vendethiel/readlist.cl/blob/master/utils.lisp#L53 <- this one isn't fine. I'm a bad person :(

[13:20] <Ven> It's kinda amazing that loop's `for` allows you to DESTRUCTURNG-BIND implicitly

[13:20] <arnsholt> Yeah

[13:20] * Ven 's only CL experience is the code linked just here :P

[13:20] <arnsholt> That loop isn't quite a straightforward map though

[13:21] <timotimo> azawawi: it looks like firefox is just opening a connection and immediately closing it again

[13:21] <timotimo> er, not "immediately"

[13:21] <timotimo> about 6 seconds after opening it successfully

[13:21] <azawawi> timotimo: i think for http pipelining

[13:21] <timotimo> which matches with what i see on the console. i load up farabi6, it comes up fine, a few seconds later it crashes in the console

[13:22] <timotimo> ah. may be.

[13:22] <Ven> (5 . = . 5) #t HEHE RACKET!

[13:22] <timotimo> http-easy is *not* equipped to deal with this :)

[13:22] <azawawi> timotimo: maybe it is asking in the headers and http-easy should answer back

[13:22] *** kaleem joined
[13:22] <timotimo> probably

[13:22] <timotimo> ah, yes. the browser asks for Connection: keep-alive

[13:23] <timotimo> but http-easy doesn't answer, it just terminates the socket later

[13:23] <timotimo> so i suppose firefox just expects it'd be fine to open a new socket even if there's no request yet

[13:23] <azawawi> timotimo: http-easy should be refactored to use https://github.com/sergot/http-useragent/

[13:23] *** NotJack left
[13:23] <azawawi> timotimo: for the parsing part

[13:25] <timotimo> probably, yeah

[13:26] <timotimo> it's pretty annoying that github doesn't syntax highlight .pm6 files at all

[13:26] <[Coke]> didn't hoelzro++ get that working?

[13:26] <timotimo> [Coke]: for .pl and .pm files, but apparently not for .pm6

[13:26] <azawawi> timotimo: that's why i built farabi6 :)

[13:26] <timotimo> azawawi: anyway, we're not equipped to deal with nonblocking sockets on parrot ...

[13:27] <azawawi> timotimo: and not equipped to work with EventSource

[13:29] <timotimo> EventSource is fine

[13:29] <timotimo> there we just send whenever we're interested in sending, we don't have to rely on hope or selecting or something for these sockets

[13:30] <timotimo> it'd be good to have an EventSource connection open for every user to reliably display a "farabi backend has crashed" message when the socket gets closed by the server

[13:30] <timotimo> and to push notifications like "building help index, please wait"

[13:31] <timotimo> hum. using "Connection: " doesn't seem to prevent the pipelining thing firefox does

[13:32] <Ven> ( masak: feel free to ping me, but I'm not reading actively the channel. just so you know )

[13:33] <masak> got it.

[13:33] * masak is a little bit curious about M-expressions

[13:34] <Ven> from the mccarthy paper?

[13:34] <Ven> meh. they're pretty bad.

[13:35] <timotimo> ah, Connection: close  is how you signal "no keep-alive"

[13:36] <masak> "S-expressions were originally intended only for data to be manipulated by M-expressions, but the first implementation of Lisp was an interpreter of S-expression encodings of M-expressions, and Lisp programmers soon became accustomed to using S-expressions for both code and data." -- from Wikipedia

[13:36] <masak> I'm curious about (something like) was this an accident of history, or could M-expressions have worked? how well can you "hide" the S-expressions?

[13:37] *** mephinet joined
[13:37] <timotimo> azawawi: i send "connection: close", but firefox still opens a dummy connection for future use ...

[13:39] <Ven> masak: really well. There a number of indented lisps, there are at-expressions (@Foo{bar} => (foo bar)) and some others

[13:39] <Ven> s/really/fairly/ # let's be honest here

[13:40] <timotimo> azawawi: if we had something like "select" on all backends, i could just throw the socket back into the "accepted sockets" queue, so to speak ..

[13:40] <timotimo> if nothing has been received

[13:41] <masak> Ven: what I'm fishing for is something like "homoiconicity is so great that those who don't do everything with S-expressions are missing out"

[13:43] * [Coke] stares at masak.

[13:43] <azawawi> timotimo: agreed

[13:44] <Ven> masak: you can *hide* homoiconicity

[13:44] <timotimo> azawawi: i'd like to move on to "only care about MoarVM and JVM" ASAP, but that has some consequences for including farabi6 in rakudo star ...

[13:45] <azawawi> timotimo: we can always install Farabi6 via panda

[13:45] <masak> [Coke]: what seems like utter crazy outside of an echo chamber is taken as evident truth inside sometimes. which makes it hard to decide exactly how true/crazy it is.

[13:45] <azawawi> timotimo: so having it in rakudo star is not a big issue after i have given it some thought.

[13:45] *** tinyblak joined
[13:46] *** tinyblak left
[13:46] <timotimo> hmm.

[13:46] <masak> [Coke]: I mean, you can't say that S-expressions aren't extremely popular in the Lisp communities themselves. including but not limited to Arc, Clojure, and Racket.

[13:46] *** tinyblak joined
[13:47] *** cognominal left
[13:47] <masak> [Coke]: in that light, it's interesting to ask what the reasons were that S-expressions took off but M-expressions didn't.

[13:48] <azawawi> timotimo: im going to work on pruning unused codemirror js tomorrow so that "fetching" stage in `panda install Farabi6` is faster

[13:48] <arnsholt> I suspect that homoiconicity is neat, but not the insane killer feature it is sometimes made out to be

[13:48] <timotimo> oh, cool :)

[13:48] *** mauke_ joined
[13:49] <azawawi> timotimo: and upgrade to codemirror 4.7. they have a new api for defining new syntax highlighting modes btw... but it is experimental at the moment... http://codemirror.net/demo/simplemode.html

[13:49] <masak> arnsholt: well, after spending some time in it yesterday, I can say that it's horribly confusing sometimes! everything's a bloody list, no matter if it should be one, or something more useful.

[13:49] <arnsholt> Yeah

[13:50] <arnsholt> And Lisp isn't the only homoiconic language

[13:50] <masak> arnsholt: I always loved how NQP essentially turns compilation into something that we can view in an OO light. that's awesome in my view.

[13:50] <arnsholt> Indeed

[13:50] * azawawi wonders if Perl 6 grammars can be mapped to dynamically-generated regex as in http://codemirror.net/demo/simplemode.html to make simple syntax highlighting

[13:50] <masak> arnsholt: what if we could do the same thing with compile-time program analysis/manipulation?

[13:50] <arnsholt> Might be interesting

[13:50] <timotimo> azawawi: neat. hoelzro would be interested in that, i'd believe; he doesn't have terribly much time these days, though

[13:51] <arnsholt> There is this concept of tree transducers, but IIRC they have some pretty hairy complexities for exact solutions and matching

[13:51] *** mauke left
[13:51] <arnsholt> But that's one of my favourite jnthn quotes: "Optimisation is solving undecidable problems is linear (or sub-linear) time"

[13:52] <arnsholt> Or something like that. Quoting from memory

[13:53] *** tinyblak_ joined
[13:54] <timotimo> azawawi: do you know where the timeout comes from in that recv call inside HTTP::Easy?

[13:55] *** mauke_ is now known as mauke

[13:56] *** tinyblak_ left
[13:56] *** tinyblak_ joined
[13:56] *** tinyblak left
[13:57] <azawawi> timotimo: no idea

[13:57] <dalek> rakudo/nom: ed8a987 | (Timo Paulssen)++ | src/core/IO/Socket/INET.pm:

[13:57] <dalek> rakudo/nom: eqat is way cooler than substr + eq.

[13:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ed8a987480

[13:58] *** kaare_ left
[13:59] *** mauke_ joined
[14:00] *** decafmainline left
[14:01] <masak> Ven: ok -- when I think about it, I don't think my first thrust of introducing Ipso macros needs to relate to scopes at all.

[14:01] *** mauke left
[14:01] <masak> Ven: it can just do subtree substitution, basically.

[14:01] *** tinyblak joined
[14:02] <timotimo> azawawi: using the fullscreen mode makes the menu occlude the leftmost part of the editor widget

[14:03] <masak> so `(list x y z)` turns into `(cons (x (list y z)))` in one step, and `(cons (x (cons (y (cons (z '()))))))` after two more steps.

[14:03] *** anaeem1 joined
[14:03] *** tinyblak_ left
[14:03] <masak> that part requires no scoping, just re-ordering of terms.

[14:03] <azawawi> timotimo: file an issue please so i can remember to fix it :)

[14:04] <timotimo> will do

[14:04] <timotimo> with a simple "if we didn't get any data, we close the socket" fix, HTTP::Easy no longer crashes when encountering a wild firefox

[14:04] <Ven> masak: sure, you needn't any kind of scopes anyways :) I was just talking about it because you said it was missing as well

[14:05] <masak> *nod*

[14:05] <masak> I feel I have to start in an end I understand.

[14:05] <masak> and then perhaps arrive at a situation where scopes would be clearly required, and evolve it from there.

[14:06] *** thou joined
[14:06] *** mauke_ is now known as mauke

[14:06] <azawawi> hmmm this IO::Handle.spurt deprecation is a bit confusing in 2014.10 . If i have the file handle, why would i need to use the $file-name.path.spurt instead... isnt it more work than simply $file-handle.spurt ?

[14:08] <Ven> masak: you're like an early lisp - dynamic scopes!

[14:08] <timotimo> azawawi: if you've opened a handle already, why would you spurt rather than just write?

[14:08] <timotimo> to me, spurt is "open, write, close"

[14:09] <timotimo> azawawi: also, you have a http-easy pull request :)

[14:09] <azawawi> timotimo: because spurt is cooler :)

[14:09] <masak> Ven: yep. but aiming to fix that.

[14:09] <timotimo> heh.

[14:09] <Ven> masak: btw, I'm "seriously" suggesting you make that into a slang :-)

[14:09] <masak> Ven: in the case of macros, it's more like "no scoping", though. my first attempt will be transparent to scoping.

[14:09] <Ven> that'd be amazing

[14:10] <masak> Ven: I want to get into slangs. I believe macros and slangs will be, like, best buddies.

[14:10] <Ven> I think macros will just before slangs like functions do

[14:10] <masak> that sentence no verb

[14:10] *** rurban joined
[14:11] *** sqirrel_ left
[14:11] <Ven> I think macros will just sit before slangs like functions do.

[14:11] <timotimo> thank you :)

[14:13] <azawawi> timotimo++ :)

[14:13] <azawawi> http://feather.perl6.nl:8080/  # works perfectly

[14:14] <Ven> class Scope{has %.vars; has Scope $.outer; method get(Str $key) { %.vars{$key}:exists ?? %.vars{$key} !! $.outer.?get($key); }; method set(Str $key, $value) { %.vars{$key} = $value; }}; my $s = Scope.new(); $s.set("foo", 1); say $s.get("foo"); my $s2 = Scope.new(outer => $s); say $s2.get("foo"); $s2.set("foo", 2); say $s2.get("foo");

[14:15] <Ven> ^ look masak, scopes \o/

[14:15] <Ven> m: class Scope{has %.vars; has Scope $.outer; method get(Str $key) { %.vars{$key}:exists ?? %.vars{$key} !! $.outer.?get($key); }; method set(Str $key, $value) { %.vars{$key} = $value; }}; my $s = Scope.new(); $s.set("foo", 1); say $s.get("foo"); my $s2 = Scope.new(outer => $s); say $s2.get("foo"); $s2.set("foo", 2); say $s2.get("foo");

[14:15] <camelia> rakudo-moar 315ec6: OUTPUT«1␤1␤2␤»

[14:15] <brrt> is that timotimo's work?

[14:15] <timotimo> brrt: only tiny parts of it are

[14:15] <Ven> m: class Scope{has %.vars; has Scope $.outer; method get(Str $key) { %.vars{$key}:exists ?? %.vars{$key} !! $.outer.?get($key); }; method set(Str $key, $value) { %.vars{$key} = $value; }}; my $s = Scope.new(); $s.set("foo", 1); say $s.get("foo"); my $s2 = Scope.new(outer => $s); say $s2.get("foo"); $s2.set("foo", 2); say $s2.get("foo"); say $s.get("foo");

[14:15] <camelia> rakudo-moar 315ec6: OUTPUT«1␤1␤2␤1␤»

[14:15] <Ven> :D

[14:15] <Ven> Perl6 makes it especially neat

[14:15] <brrt> oh it's azawawi

[14:15] <timotimo> yup

[14:15] <brrt> azawawi++

[14:16] <Ven> azawawi++

[14:16] *** ajr_ left
[14:16] <masak> Ven: nice.

[14:16] * brrt is watching TimToady++'s APW keynote

[14:16] * Ven saw the electric poles live!

[14:16] <Ven> well, photo-live...

[14:16] <timotimo> :))

[14:16] <timotimo> they were amazing

[14:17] <brrt> dunno if jnthn is here, but any idea what would be needed to add to the profiler /which op/ causes stuff not to JIT

[14:17] <hoelzro> [Coke]: there's an open PR addressing that

[14:17] *** guru joined
[14:18] *** guru is now known as Guest41234

[14:18] *** Guest41234 is now known as ajr_

[14:18] <timotimo> brrt: to be honest, i'd find it much more interesting to see what causes a frame not to get speshd

[14:19] <hoelzro> azawawi: that *is* a good idea

[14:19] <timotimo> oh, it's hoelzro! :D

[14:19] <hoelzro> o/ timotimo 

[14:19] <brrt> most likely a non-interned callsite

[14:19] <brrt> timotimo

[14:20] <timotimo> mhm mhm

[14:21] <timotimo> hmm. sometimes we have colored === around the SORRY! and sometimes it's not colored at all :\

[14:22] <azawawi> timotimo: fixed on http://feather.perl6.nl:8080/ . Please try it

[14:22] <timotimo> fixed what exactly?

[14:23] <masak> oh, I see what M-expressions are now, in http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf -- yeah, that's not much of an improvement. :)

[14:24] *** tinyblak left
[14:24] *** tinyblak joined
[14:25] <timotimo> azawawi: huh, it seems like i can't mousewheel-scroll in the output pane

[14:25] <timotimo> i can *horizontally* scroll, though

[14:25] <timotimo> there's only a horizontal scroll bar on chrome, though. not on firefox (even if it'd scroll horizontally)

[14:27] <timotimo> er ... i can't scroll in the regular editor either?

[14:27] <timotimo> i can only scroll in full screen mode, it seems

[14:27] <hoelzro> timotimo: I have some time, but my wife really wants to beat Spelunky, and I'm mired down in two other projects at the moment =/

[14:28] <Ven> masak: I should read those someday

[14:28] <timotimo> ooh spelunky

[14:28] <timotimo> that game is so harsh

[14:28] <hoelzro> hence why it's taking us so long =)

[14:28] <hoelzro> it's fun, though

[14:28] <azawawi> timotimo: i'll revise the full screen mode

[14:28] <ab5tract> hoelzro: what are you hacking on?

[14:28] <timotimo> last time i tried it in co-op, i ended up being more of a "friendly fire" kind of player

[14:29] *** tinyblak_ joined
[14:29] <hoelzro> ab5tract: working on a feature for ack2 that I can't seem to get out the door

[14:29] <hoelzro> and an offline GH issues browser in Ruby

[14:29] <hoelzro> timotimo: yeah, it's really hard together

[14:29] <hoelzro> you need a lot of practice and discipline

[14:29] <tadzik> hmm, never played it

[14:29] <hoelzro> but we've just discovered it's a *lot* easier if she plays on the TV and I play on my Vita =)

[14:29] *** isBEKaml joined
[14:29] <hoelzro> because we can explore the level separately

[14:30] <azawawi> timotimo: what about https://github.com/azawawi/farabi6/issues/49 ?

[14:30] <azawawi> timotimo: are u having the same issue?

[14:32] *** tinyblak left
[14:32] <Ven> https://github.com/azawawi/farabi6/blob/master/lib/Farabi6/Editor.pm6#L46 we should be able to get output as json, maybe?

[14:32] <Ven> text matching sucks :)

[14:32] <Ven> masak: btw, I disagree with arnsholt that s-expressions are overrated. I hate strings with a passion.

[14:33] <Ven> i.e. you want to store logs? Instead of "X encountered an error on thread Y with bar" just format it like data. it could be json or xml, no problem. But s-expression make it unified

[14:33] <moritz> and s-expressions can't contain strings?

[14:33] *** ajr_ left
[14:33] <Ven> moritz: sure they can.

[14:33] <dalek> Perlito: 1071c28 | (Flavio S. Glock)++ | / (3 files):

[14:33] <dalek> Perlito: Perlito5 - js - fix scope in while()

[14:33] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/1071c285c5

[14:33] <Ven> moritz: I don't understand your comment

[14:34] *** davido_ left
[14:34] <masak> Ven: I think your comment sounded a little bit like a strawman argument.

[14:34] <moritz> Ven: if you hate strings with a passion, and s-expressions contain strings, you hate s-expressions with a passion. No?

[14:34] <Ven> moritz: uh. no. The world contains cancer. I'm sure you hate cancer. Do you have the world? That's a syllogism

[14:35] <moritz> Ven: I hate the world a bit for containing cancer

[14:35] <Ven> masak: mmh, maybe. It's more about having one unified syntax. If lisp used a json-like syntax, it'd be the same in the end

[14:37] *** ajr joined
[14:37] *** ajr is now known as Guest12913

[14:38] <masak> aka "homoiconicity".

[14:38] <Ven> ;-)

[14:38] <masak> that's why I'm a little bit curious what will happen (with macros and such) if one wraps the whole Lisp in an ALGOL-like syntax.

[14:38] <timotimo> azawawi: when i try to run the "farabi.pl" i have in my path it'll say "switching to panda installed farabi" and then fail to find farabi.js or something

[14:38] *** Guest12913 left
[14:38] *** pmurias joined
[14:39] <Ven> masak: elixir is almost-homoiconic. dylan as well

[14:39] *** tinyblak joined
[14:40] <masak> they are both on my "to investigate" list.

[14:40] *** ajr_ joined
[14:42] <isBEKaml> Ven: Dylan? That's an ALGOL like language with Lisp forms too, right?

[14:42] <ab5tract> m: (1,1,2,2,3,3).pairs.say

[14:42] <camelia> rakudo-moar 315ec6: OUTPUT«0 => 1 1 => 1 2 => 2 3 => 2 4 => 3 5 => 3␤»

[14:42] *** ajr_ left
[14:42] <ab5tract> it seems like there should be a way to make pairs out of a list?

[14:42] <Ven> isBEKaml: -ish, yes :)

[14:42] *** tinyblak_ left
[14:43] <isBEKaml> Ven: I heard about it recently [OpenDylan]

[14:43] <Ven> apple killed dylan :(

[14:43] *** ajr_ joined
[14:43] <rurban> Dylan is a Lisp with Algol Syntax. Elixir erlang with macros and Python syntax

[14:44] <timotimo> m:  %((1, 1, 2, 2, 3, 3).rotor(2, 0)).perl.say # ab5tract 

[14:44] *** ajr_ left
[14:44] <isBEKaml> Ven: that's what I heard. I'm not old enough to remember Dylan. :)

[14:44] <camelia> rakudo-moar 315ec6: OUTPUT«Odd number of elements found where hash initializer expected␤  in method STORE at src/gen/m-CORE.setting:10116␤  in method hash at src/gen/m-CORE.setting:1637␤  in block <unit> at /tmp/gkNCGFAURk:1␤␤»

[14:44] <timotimo> er

[14:44] <timotimo> m:  %((1, 1, 2, 2, 3, 3)).perl.say # ab5tract 

[14:44] <camelia> rakudo-moar 315ec6: OUTPUT«("2" => 2, "1" => 1, "3" => 3).hash␤»

[14:44] <timotimo> even easier

[14:44] <Ven> isBEKaml: I'm probably younger than you, so, me neither!

[14:44] <ab5tract> rotor?? :(

[14:44] <Ven> rurban: my point was – elixir is homoiconic (-ish)

[14:45] <ab5tract> timotimo: i wanted a list of pairs though

[14:45] <muraiki> yeah, it breaks down into pretty much a lisp

[14:45] <rurban> Yes, elixir is very nice

[14:45] <muraiki> sum(1,2,3) becomes {:sum, [], [1, 2, 3]}

[14:45] <timotimo> m:  %((1, 1, 2, 2, 3, 3)).list.perl.say # ab5tract 

[14:45] <camelia> rakudo-moar 315ec6: OUTPUT«("1" => 1, "2" => 2, "3" => 3).list␤»

[14:46] <ab5tract> i don't see why .pairs should just re-implement .kv

[14:46] *** ajr_ joined
[14:46] <timotimo> .pairs gives you pairs, .kv gives you tuples

[14:46] <moritz> .kv is very handy for iteration

[14:46] *** ajr_ left
[14:47] <moritz> m: for <a b c>.kv: -> $i, $v { say "$i: $v" }

[14:47] <camelia> rakudo-moar 315ec6: OUTPUT«===SORRY!===␤Expression needs parens to avoid gobbling block␤at /tmp/mbD8YI288O:1␤------> r <a b c>.kv: -> $i, $v { say "$i: $v" }⏏<EOL>␤Missing block (apparently taken by expression)␤at /tmp/mbD8YI288O:1␤…»

[14:47] <ab5tract> indeed it is moritz. no more counters

[14:47] <moritz> m: for <a b c>.kv -> $i, $v { say "$i: $v" }

[14:47] <camelia> rakudo-moar 315ec6: OUTPUT«0: a␤1: b␤2: c␤»

[14:47] * azawawi home &

[14:47] <moritz> and .pairs on hashes for example is very handy for sorting

[14:48] <moritz> when you want to juggle around stuff without key and value getting separated

[14:48] <ab5tract> i understand that this has been well thought out

[14:49] <ab5tract> but to me the syntax for that would %h.kv.each.pair

[14:49] <ab5tract> but i haven't thought about it much

[14:50] <moritz> that's how you'd say it in human language

[14:50] *** azawawi left
[14:50] <moritz> but for programming, that doesn't work well

[14:50] <moritz> because at the time you've done kv.each, you've lost information on how to make pairs of it again

[14:50] * masak skimmed https://danielkeep.github.io/quick-intro-to-macros.html with interest

[14:51] <masak> the lexical model is very reminiscent of what we have so far (and will probably stick with) in Perl 6.

[14:51] <Ven> masak: you might be interested in http://www.greghendershott.com/fear-of-macros/all.html

[14:51] <isBEKaml> masak: <pedant>how do you skim something *with* interest?</pedant> :P

[14:51] <moritz> masak: read the first paragraph. Already loving it :-)

[14:51] <masak> isBEKaml: I fail to see the contradiction.

[14:52] <masak> isBEKaml: I can skim something in an interested way.

[14:52] <isBEKaml> masak: well, if you're *interested*, you'd read it all the way through - not skim/skip stuff. :)

[14:52] <masak> isBEKaml: I'm interested but I also have to manage my time.

[14:53] <masak> isBEKaml: I don't see why interest as such would require careful reading.

[14:53] <masak> Ven: all Racket pages I've seen so far have been beautifully syntax-highlighted.

[14:53] <isBEKaml> masak: I'm not falling into this trap :P

[14:54] <masak> what trap? the trap of arguing with pedants? :P

[14:55] <isBEKaml> :-)

[14:57] <dalek> Perlito: 4ef0140 | (Flavio S. Glock)++ | / (2 files):

[14:57] <dalek> Perlito: Perlito5 - js - emitter: while(), if() formatting

[14:57] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/4ef0140410

[14:58] <ab5tract> i guess i would just prefer that @a.pairs DWIM against the contents of the array, ignoring the index

[14:58] <Ven> masak: racket is good /o/

[14:59] <masak> m: my @a = <a b c>; say @a.pairs.perl

[14:59] <camelia> rakudo-moar 315ec6: OUTPUT«(0 => "a", 1 => "b", 2 => "c").list␤»

[14:59] <timotimo> ab5tract: that seems like a very bad idea

[14:59] <masak> ab5tract: the above is exactly what I expect from @a.pairs

[14:59] <masak> ab5tract: if you expect something else, consider whether you're expectations are wonky :>

[15:00] <ab5tract> haha

[15:00] <masak> your*

[15:00] <ab5tract> i've grown used to that fact :)

[15:00] <moritz> ab5tract: what would you have exptected?

[15:01] <colomon> m: my @a = <a b c>; say @a.map(-> $a, $b { $a => $b }).perl

[15:01] <camelia> rakudo-moar 315ec6: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at /tmp/BuX6PEY4EV:1␤␤»

[15:01] <ab5tract> in that case, i would expect an exception about uneven numbers of elements in list

[15:01] <colomon> ab5tract: there you go

[15:01] <colomon> not the best exception, admittedly

[15:01] <colomon> m: my @a = <a b c>; say @a.map(-> $a, $b? { $a => $b }).perl

[15:01] <camelia> rakudo-moar 315ec6: OUTPUT«("a" => "b", "c" => Mu).list␤»

[15:02] <ab5tract> <a b c d>.pairs # ((a => b).Pair, (c => d).Pair).list

[15:02] *** treehug88 joined
[15:02] <ab5tract> btw, this is just an exercise in understanding the _right_ way to do it

[15:03] <ab5tract> not to say that my expectation is/was reasonable or correct in any way

[15:03] <masak> m: my @a = <a b c d>; say @a.zipwith(&[=>]).perl

[15:03] <camelia> rakudo-moar 315ec6: OUTPUT«No such method 'zipwith' for invocant of type 'Array'␤  in block <unit> at /tmp/qdeiS1T7ec:1␤␤»

[15:03] <masak> hrm.

[15:03] <ab5tract> m: <a b c d>.map( -> $a,$b { ($a,$b).pair.say })

[15:03] <camelia> rakudo-moar 315ec6: OUTPUT«Unhandled exception: Method 'pair' not found for invocant of class 'Parcel'␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/nqp/lib/Perl6/BOOTSTRAP.moarvm::4294967295)␤ from /tmp/peeZFlbNMY:1  (<ephemeral file>::34)␤ from src/gen/m-CORE.set…»

[15:03] *** [particle] left
[15:04] <ab5tract> m: <a b c d>.map( -> $a,$b { ($a => $b).pair.say })

[15:04] <camelia> rakudo-moar 315ec6: OUTPUT«Unhandled exception: Method 'pair' not found for invocant of class 'Pair'␤   at <unknown>:1  (/home/camelia/rakudo-inst-1/languages/nqp/lib/Perl6/BOOTSTRAP.moarvm::4294967295)␤ from /tmp/NI_MZaPIjy:1  (<ephemeral file>::34)␤ from src/gen/m-CORE.setti…»

[15:04] <moritz> ($a => $b) already is a Pair

[15:04] <ab5tract> m: <a b c d>.map( -> $a,$b { ($a => $b).say })

[15:04] <camelia> rakudo-moar 315ec6: OUTPUT«"a" => "b"␤"c" => "d"␤»

[15:05] <moritz> m: say %(<a b c d>).pairs.perl

[15:05] <camelia> rakudo-moar 315ec6: OUTPUT«("a" => "b", "c" => "d").list␤»

[15:05] <ab5tract> right, that's reasonable enough for me

[15:07] *** ptc_p6 left
[15:07] <masak> ab5tract: for me, the important detail is that when you as an array for .keys, it gives you its indices. this is just in analogy with hashes; the indices are the "keys" of the array. therefore, when you ask it for (key-value) pairs, you get indices and elements.

[15:08] <lizmat> .tell azawawi   "foo".path is deprecated, "foo".IO is not

[15:08] <yoleaux> lizmat: I'll pass your message to azawawi.

[15:08] *** tinyblak left
[15:08] <lizmat> re clarity of .path: I think the term "path" is ambiguous

[15:08] *** tinyblak joined
[15:08] <timotimo> mhm mhm

[15:09] <lizmat> "/usr/local/bin/perl6" is a path

[15:09] <lizmat> but it's not an IO::Path

[15:09] *** tinyblak_ joined
[15:09] <lizmat> "/usr/local/bin/perl6".path doesn't seem to change anything in that

[15:10] <moritz> "/usr/local/bin/perl6" is a path in the same sense that "42" is an integer

[15:10] <moritz> that is, not really

[15:10] <lizmat> "/usr/local/bin/perl6".IO is sufficiently different from the string, and shorter and a marker for something special happening

[15:10] <moritz> just a string representing a $thing

[15:11] <lizmat> moritz: so 42.Int strikes you as making it an Int, rather than not changing anything ?

[15:11] <ab5tract> masak: indeed, and i don't think breaking that would be worth anything

[15:12] <moritz> m: say '/usr/local/bin/perl6'.path.^name

[15:12] <camelia> rakudo-moar 315ec6: OUTPUT«IO::Path␤»

[15:12] <moritz> lizmat: "42".Int makes an Int, just as /usr/local/bin/perl6'.path makes an (IO::)Path

[15:12] <isBEKaml> I can't put a finger on it - but isn't saying "anything that looks like a path is also a string" dangerous?

[15:13] <moritz> isBEKaml: who says that?

[15:13] *** tinyblak left
[15:13] <isBEKaml> moritz: me :-)

[15:13] <moritz> m: say 'sadfk'.IO.^name

[15:13] <camelia> rakudo-moar 315ec6: OUTPUT«IO::Path␤»

[15:14] *** [particle] joined
[15:14] <isBEKaml> moritz: cool, no issues then. 

[15:14] <moritz> the old philsophical distinction between .IO and .path was that .path was supposed to work with path strings, and .IO was supposed to work with file handles

[15:14] <moritz> with the background that only by working with file handles, you can avoid race conditions

[15:20] <lizmat> m: "foo".path.path.WHAT.say

[15:20] <camelia> rakudo-moar 315ec6: OUTPUT«(Str)␤»

[15:20] <lizmat> another reason I don't like .path on Str

[15:20] <timotimo> ooooh

[15:20] <timotimo> that's very silly

[15:20] <lizmat> m: "foo".IO.path.WHAT.say  # clearer

[15:20] <camelia> rakudo-moar 315ec6: OUTPUT«(Str)␤»

[15:21] <timotimo> yes, that should definitely be different

[15:22] <moritz> that's why the old IO::Path.path was a no-op

[15:22] <Ven> afk&

[15:22] *** Ven left
[15:27] <lizmat> which I think is a bit hackish

[15:27] <lizmat> but even so: .path could be considered a coercer, no?

[15:28] <lizmat> and don't we want coercers to be titlecased?   .Str  .Int  .Bag  .Set ?

[15:28] <lizmat> shouldn't it be at least .Path then?

[15:29] <moritz> except we have .list and .hash and .item

[15:30] <lizmat> well, I can see we agree to disagree

[15:33] *** tinyblak_ left
[15:33] *** FROGGS joined
[15:33] *** tinyblak joined
[15:33] <dalek> rakudo/nom: 6d7b37d | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[15:33] <dalek> rakudo/nom: Fix 2 winner stragglers, spotted by [Coke]++

[15:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6d7b37d260

[15:34] *** kaleem left
[15:34] *** guru joined
[15:35] *** guru is now known as Guest69127

[15:35] *** Guest69127 is now known as ajr_

[15:40] *** isBEKaml left
[15:44] <lizmat> azawawi: re. IO::Handle.spurt:  If you have a handle, why .spurt?  Why not .print ?

[15:45] <lizmat> but perhaps the deprecation is not needed

[15:46] <FROGGS> spurt is open+print+close... so .spurt makes sense when the handle is not opened

[15:46] <masak> not sure it doesn't make sense when a handle is already opened, though.

[15:46] <lizmat> ah, but that's just it: it is now very hard to get an IO::Handle object that did not open its handle

[15:46] <lizmat> .IO gives you an IO::Path

[15:47] <lizmat> .spurt on IO::Path will open / spurt / close

[15:47] <lizmat> should .spurt on IO::Handle close the handle afterwards or not >

[15:47] <lizmat> ?

[15:47] <FROGGS> I dunno

[15:48] <lizmat> or should it just be a .print  (which is what it is now )

[15:48] <lizmat> (and a deprecation message)

[15:48] <lizmat> well, depending on whether your spurting a Blob or not

[15:48] <lizmat> in the case of a Blob, it would do a .write

[15:49] *** kaare_ joined
[15:49] *** Timbus left
[15:50] <lizmat> same for IO::Handle.slurp: should it close the handle afterwards?  should it move the file pointer to the beginning >

[15:50] <lizmat> ?

[15:50] *** brrt left
[15:51] <FROGGS> fells weird to have .spurt on a handle that is open in almost all cases

[15:52] <moritz> IMHO slurp/spurt only make sense with file names

[15:52] <lizmat> hence the deprecation suggestion of using IO::Path.spurt

[15:52] <FROGGS> so... "foo".IO.print("bar", :autoclose) would be the replacement?

[15:53] <lizmat> moritz: "foo".path.spurt you mean?

[15:53] <moritz> lizmat: or that, yes

[15:53] *** isBEKaml joined
[15:53] <moritz> and on file handles, maybe a .readall method?

[15:53] <FROGGS> so Str.spurt

[15:53] <lizmat> well, I would suggest "foo".IO.spurt

[15:53] *** davido_ joined
[15:53] <lizmat> the .IO indicates you want to do something IO-y

[15:53] <moritz> +1

[15:53] *** Timbus joined
[15:53] <FROGGS> ahh, that's how I use it anyway

[15:53] <moritz> but .spurt on *opened* file handles makes not much sense

[15:54] <lizmat> hence the deprecation message  :-)

[15:54] <FROGGS> m: say $*PERL.compiler.build-date

[15:54] <camelia> rakudo-moar 315ec6: OUTPUT«2014-10-22T20:30:08Z␤»

[15:54] <FROGGS> :o(

[15:56] <pmurias> if macros will be able to use pieces of Perl 6 grammar for parsing will that force use to have an official grammar?

[15:56] <masak> pmurias: you mean, besides STD.pm6 ?

[15:59] <ab5tract> btw folks, i've made some progress on baggifying the set comparator operators, ie (>), (<), (>=), and (<=)

[16:00] <timotimo> ah, cool :)

[16:00] <ab5tract> though for some reason, code that works exactly as expected in the repl does not seem to do the right thing when it is in the method definition and compiled

[16:02] <ab5tract> m: $a = bag <1 1>; $b = bag <1 1 1 3>; (so $a.keys.all (elem) $b and so ($a{$_} < $b{$_} for $b.keys).all).say

[16:02] <camelia> rakudo-moar 315ec6: OUTPUT«===SORRY!=== Error while compiling /tmp/tr7MuK76uA␤Variable '$a' is not declared␤at /tmp/tr7MuK76uA:1␤------> $a⏏ = bag <1 1>; $b = bag <1 1 1 3>; (so $a␤    expecting any of:␤        postfix␤»

[16:03] <ab5tract> m: my $a = bag <1 1>; my $b = bag <1 1 1 3>; (so $a.keys.all (elem) $b and so ($a{$_} < $b{$_} for $b.keys).all).say

[16:03] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[16:03] <ab5tract> camelia: how strict you are :)

[16:04] <ab5tract> m: my $a = bag <1 1 3>; my $b = bag <1 1 1 3>; (so $a.keys.all (elem) $b and so ($a{$_} < $b{$_} for $b.keys).all).say

[16:04] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[16:04] *** treehug88 left
[16:04] <ab5tract> the second case will return True

[16:04] <masak> pmurias: anyway, yes -- I think so.

[16:05] <masak> pmurias: any platform-independent macro code that uses the underlying Perl 6 grammar will also make assumptions about that grammar.

[16:05] *** treehug88 joined
[16:06] <ab5tract> even though the expression is composed exactly the same in set_operators.pm

[16:07] *** kurahaupo left
[16:14] * PerlJam wonders who's going to document the public parts of the standard Perl 6 grammar

[16:14] <PerlJam> (or decide which parts are public and which parts are private)

[16:15] *** denis_boyun left
[16:17] <TimToady> .oO(token !don't-use-me {...})

[16:17] *** tgt joined
[16:19] *** tgt left
[16:19] *** tgt joined
[16:19] <masak> I am hopeful we are going to be able to abstract away from QAST. I don't think we'll be able to abstract away from the grammar.

[16:19] <TimToady> it's really sort of a question of which genes are conserved and which ones are mutable

[16:19] <TimToady> certainly the categories must be very public

[16:20] <masak> yes.

[16:20] <masak> they feel like "extension points" in themselves.

[16:20] <TimToady> and we should take one pass through to look for missing ones

[16:20] *** pmurias left
[16:22] <PerlJam> Should that be a requisite of 6.0.0?  (having a standardized (parts of) the grammar)

[16:22] *** tgt left
[16:24] * TimToady suspects the standardardizable bits will show up in tests as macros and ast develop.

[16:25] <TimToady> and arguably that's the main benefit of macros at the point 6.0.0 comes out, since hopefully we've de-incentivized people for overusing them :)

[16:26] *** Alula left
[16:26] *** tgt joined
[16:27] <TimToady> Perl 6 is all "Here's your hovercraft full of eels, but you can still make more eels if you like."

[16:27] *** kaleem joined
[16:27] *** tgt left
[16:32] *** zakharyas left
[16:37] <TimToady> m: my @headers = <foo bar baz quux>; say %@headers.perl;  # don't need the parens on %()

[16:37] <camelia> rakudo-moar 315ec6: OUTPUT«("baz" => "quux", "foo" => "bar").hash␤»

[16:37] <TimToady> timotimo: ^^

[16:40] <[Coke]> masak: I was staring at you because I didn't know what any of the nouns meant.

[16:41] <[Coke]> m: IO::Path.dir("/tmp").say

[16:41] <camelia> rakudo-moar 315ec6: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method dir at src/gen/m-CORE.setting:15601␤  in block <unit> at /tmp/E3UbfwJyKB:1␤␤»

[16:42] <lizmat> [Coke]: shouldn't be called as a class method

[16:43] <lizmat> huh, it has IO::Path:D: in signature ?

[16:43] *** isBEKaml left
[16:44] <lizmat> m: IO::Path.dir.say

[16:44] <camelia> rakudo-moar 315ec6: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method dir at src/gen/m-CORE.setting:15601␤  in block <unit> at /tmp/1kjlwQPe7O:1␤␤»

[16:44] <lizmat> that would be the error I'd expect

[16:44] <[Coke]> why do I need an instance?

[16:44] <[Coke]> m: IO::Path.new.dir('log').say

[16:44] <camelia> rakudo-moar 315ec6: OUTPUT«Required named parameter 'path' not passed␤  in submethod BUILD at src/gen/m-CORE.setting:15301␤  in method BUILDALL at src/gen/m-CORE.setting:956␤  in method bless at src/gen/m-CORE.setting:939␤  in method new at src/gen/m-CORE.setting:923␤  in …»

[16:44] <lizmat> [Coke]: it's either dir("/tmp")

[16:45] <lizmat> or "/tmp".IO.dir

[16:45] <[Coke]> That's not obvious from http://perlcabal.org/syn/S32/IO.html#dir()

[16:45] *** tinyblak left
[16:45] <[Coke]> that looks like I can call dir on IO::Path and pass in a dir.

[16:45] *** tinyblak joined
[16:45] <TimToady> if you're gonna use a class as a package, it's better to use package notation than method notation 

[16:46] <lizmat> [Coke]: this is about *sub* dir() ???

[16:47] <lizmat> what looks like you can call dir on IO::Path and pass in a dir?

[16:47] <TimToady> we try to keep our functional semantics very separate from our method semantics most of the time; MyClass.meth should really only be used for constructors and such

[16:47] <[Coke]> that's where I started, yes. Probably want some boilerplate at the functions level to explain how to call them for noobs.

[16:47] <[Coke]> which apparently I is.

[16:48] <lizmat> I guess we're going from spec to documentation then

[16:48] <TimToady> IO::Path.dir looks like a path factory

[16:48] <lizmat> which would be fine to me

[16:48] <TimToady> and factories are kind of an antipattern around here

[16:49] <[Coke]> is there better documentation for IO::Path than that url at the moment?

[16:49] <lizmat> reading http://perlcabal.org/syn/S32/IO.html#dir()  I don't understand where the IO::Path.dir notion comes from  :-(

[16:50] <TimToady> it will be a common failing for people coming from languages with factories

[16:50] <[Coke]> "I'm in IO path and I want to call a callable"

[16:50] *** tinyblak left
[16:50] <TimToady> it's a common idiom in languages that don't have packages, and make classes stand in for packages

[16:50] <[Coke]> looks to me like dir is a class method there, esp. if I am thinking perl5 ways where there isn't really a difference between a method and a function. (also: "function"? Should that be "sub" ?)

[16:51] <lizmat> TimToady: are you saying we need something better than "Invocant requires an instance, but a type object was passed" for IO::Path.dir ?

[16:51] <lizmat> m: IO::Path.dir

[16:51] <camelia> rakudo-moar 315ec6: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method dir at src/gen/m-CORE.setting:15601␤  in block <unit> at /tmp/EQEaR2sTHs:1␤␤»

[16:51] <[Coke]> lizmat++ # for giving me the right syntax, btw, thanks!

[16:52] <[Coke]> m: IO::Path.dir("here's an argument");

[16:52] <camelia> rakudo-moar 315ec6: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method dir at src/gen/m-CORE.setting:15601␤  in block <unit> at /tmp/KrZ7XSDn8J:1␤␤»

[16:52] <[Coke]> ^^ that's the problem, I don't see the nice error message. :)

[16:52] <lizmat> *that* I think is a MMD bug

[16:52] <TimToady> just trying to figure out if there's a way to recognize the particular cultureo

[16:52] <[Coke]> TimToady: documentation is a good start. :)

[16:53] <[Coke]> just for the idiots like me who think they have the right of it. :)

[16:53] <[Coke]> what would be the package notation you mentioned earlier that might have made more sense?

[16:53] <[Coke]> m: IO::Path::dir("hi");

[16:53] <camelia> rakudo-moar 315ec6: OUTPUT«Could not find symbol '&dir'␤  in method <anon> at src/gen/m-CORE.setting:13676␤  in any find_method_fallback at src/gen/m-Metamodel.nqp:2725␤  in any find_method at src/gen/m-Metamodel.nqp:988␤  in block <unit> at /tmp/gn0iVUm3QK:1␤␤»

[16:54] <[Coke]> (so those are really not in IO::Path?)

[16:55] * TimToady actually cringes as all the Promise.foo methods in S17

[16:55] <TimToady> *at

[16:56] <lizmat> m: class A { method foo(A:D:) { ... } }; A.foo(42)   # feels like a bug in MMD to me

[16:56] <camelia> rakudo-moar 315ec6: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in method foo at /tmp/m2W709aqor:1␤  in block <unit> at /tmp/m2W709aqor:1␤␤»

[16:56] <lizmat> m: class A { method foo(A:D:) { ... } }; A.foo   # expect this error first

[16:56] <camelia> rakudo-moar 315ec6: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method foo at /tmp/8kvenEuQBB:1␤  in block <unit> at /tmp/8kvenEuQBB:1␤␤»

[16:57] <lizmat> TimToady: re S17 Promise class methods: they all return an instantiated object, so are a bit like .new

[16:57] <TimToady> though I suppose those are arguably all constructors

[16:57] *** ajr_ left
[16:58] <lizmat> my point  :-)

[16:59] *** guru joined
[16:59] <[Coke]> I have no objection per se to class methods; but I do a lot of work in languages with no packages, as you say.

[16:59] *** guru is now known as Guest95799

[17:00] *** Guest95799 is now known as ajr_

[17:01] *** woolfy left
[17:01] <TimToady> another oddity is that we're falling into talking about things like List.unique, which is funny since that is actually illegal, but where List is standing for a parameter that is List:D

[17:02] * lizmat takes note

[17:02] <TimToady> perhaps that is benign, but maybe it's also confusing to people coming from those other languages

[17:02] <TimToady> I don't think we should switch to List::unique for that usage, since we are, in fact, discussing the method

[17:02] <lizmat> List:D:.unique, would that be better ?

[17:03] <masak> the Ruby world (and Java, I think) have those as List#unique

[17:03] <TimToady> no, that's even more confusing

[17:03] <lizmat> $List.unique ?

[17:03] *** kaleem left
[17:04] <masak> that one just adds confusion.

[17:04] *** tinyblak joined
[17:04] <nine_> Can there be a "unique" sub and a method with that name in List?

[17:04] <TimToady> I suspect people can be educated that the Foo.bar metanotation means that the class is to be taken polymorphic, and the method to be taken literally

[17:04] <TimToady> m: List.unique

[17:04] <camelia> rakudo-moar 315ec6: OUTPUT«No such method 'unique' for invocant of type 'List'␤  in block <unit> at /tmp/LGJQ1uPCGf:1␤␤»

[17:05] <lizmat> that's because Camelia is behind  :-(

[17:05] *** pdcawley left
[17:05] <[Coke]> do we have a builtin for creating a temp file?

[17:05] *** pdcawley joined
[17:06] <lizmat> [Coke]: we don't, afaik

[17:06] <ab5tract> m: role ToPair { method to_pairs { %(self).pairs } }; my @a = <a b c d>; @a does ToPair; @a.to_pairs;

[17:06] <camelia> rakudo-moar 315ec6: ( no output )

[17:06] <ab5tract> m: role ToPair { method to_pairs { %(self).pairs } }; my @a = <a b c d>; @a does ToPair; @a.to_pairs.say;

[17:06] <[Coke]> ^^ feature request. :)

[17:06] <camelia> rakudo-moar 315ec6: OUTPUT«"a" => "b" "c" => "d"␤»

[17:07] *** cognominal joined
[17:07] <ab5tract> that more than satisfies my desire for an Array -> List of Pairs shorthand :)

[17:08] *** ab5tract left
[17:08] <TimToady> loses ordering though

[17:08] <nine_> +1 for a temp file builtin # hand rolled temp file creation is one of the top security failures of all time

[17:09] *** Alula joined
[17:09] <TimToady> +Inf to that

[17:09] <lizmat> any prior art to copy from ?

[17:09] <TimToady> Perl 5

[17:09] *** ajr_ left
[17:10] <TimToady> much work has gone into removing race conditions from theirs

[17:10] *** woolfy joined
[17:11] *** rurban left
[17:11] <lizmat> aka File::Temp ?

[17:11] <TimToady> it's one of the first places hackers will look for a security flaw

[17:12] * TimToady remembers the berkeley break fondly, where the kernel had a race condition in starting #! files :)

[17:14] * masak .oO( since `defmacro` defines a macro, a `defun` must be for defining an un )

[17:15] <TimToady> no, it just takes all the fun out

[17:15] <masak> :)

[17:15] <[Coke]> I am trying to do a s:g/// over a file; without the :g, it finishes instantly. with the :g, oh so slow, whether I slurp it in and do it on the whole file, or if I do .lines and do it per line.

[17:16] <lizmat> hmmm... looking at P5's File::Temp code, it feels more like something ecosystemy to me

[17:16] <lizmat> or we should be able to decide on a subset

[17:17] <nine_> lizmat: usually I'd agree, but this feels imporant enough to have a builtin. The secure way should also be the easiest way to create a temp file.

[17:17] <[Coke]> module is probably a better default choice on this question, anyway.

[17:18] <[Coke]> (but not, as nine notes, maybe for this particular question)

[17:18] <lizmat> also: one might want to upgrade temp file creation without upgrading the rest of the system

[17:18] <[Coke]> um. wow. the jvm build broke pretty spectactularly.

[17:18] <lizmat> e.g. when a vulnerability is found

[17:22] <[Coke]> (jvm) oops, scratch that.

[17:22] *** cognominal left
[17:22] * lizmat is not seeing an JVM build problems

[17:23] <[Coke]> ^^ idiomatic "please ignore". sorry.

[17:24] <lizmat> np

[17:24] <TimToady> on linux, 'apropos temp' demonstrates how difficult it is to get it right; I count roughly 12 different calls in C for making temp files "safely"

[17:25] <lizmat> so, maybe this should be done at the nqp level...

[17:28] * TimToady also notes that searching a user-specified path for File::Temp is going to depend on the user not doing anything stupid, which is...difficult to guarantee...

[17:28] <[Coke]> ISTR parrot might have something already for us to use. I'm sure java does.

[17:28] <[Coke]> m: say %*ENV<HOME>

[17:28] <camelia> rakudo-moar 315ec6: OUTPUT«/home/camelia␤»

[17:29] <TimToady> one of the easiest ways to shoot yourself in the foot is to delegate the task to someone else

[17:29] <[Coke]> m: my $a = "/home/camelia/some/path" ; $a ~~ s/ %*ENV<HOME> /.../; say $a;

[17:29] <camelia> rakudo-moar 315ec6: OUTPUT«Potential difficulties:␤    Apparent subscript will be treated as regex␤    at /tmp/4mw2uUqIwg:1␤    ------> home/camelia/some/path" ; $a ~~ s/ %*ENV⏏<HOME> /.../; say $a;␤/home/camelia/some/path␤»

[17:30] <[Coke]> m: my $a = "/home/camelia/some/path" ; $a ~~ s/ {%*ENV<HOME>} /.../; say $a;

[17:30] <camelia> rakudo-moar 315ec6: OUTPUT«.../home/camelia/some/path␤»

[17:30] <nine_> Maybe of interest: O_TMPFILE (since Linux 3.11) Create an unnamed temporary file.  The pathname argument specifies a directory; an unnamed inode will be created in that directory's filesystem.  Anything written to the resulting file will be lost when the last file descriptor is closed, unless the file is given a name.

[17:30] * [Coke] heads back to S05 to see what's he's screwing up this time.

[17:30] * TimToady notes that Perl 5 considers both the command line and the environment to be tainted

[17:30] *** tgt joined
[17:32] <[Coke]> ah, {} is for the subst only, not the match, I'm guessing.

[17:32] <TimToady> it's very, very easy to install a usage of external data that assume a benevolent user

[17:34] *** nine_ is now known as nine

[17:35] <TimToady> m: my $a = "/home/camelia/some/path" ; $a ~~ s/ "{%*ENV<HOME>}" /.../; say $a;

[17:35] <camelia> rakudo-moar 315ec6: OUTPUT«.../some/path␤»

[17:36] <[Coke]> so, I have a file with 2688 lines, 177K bytes; if I slurp in the data and use s::g, it takes 20s; if I loop over the lines, 19s. sed is at 0.019s. anything I can do in general to get a faster result here?

[17:36] <TimToady> {} has no return value, and is used only for side effects, such as constructing the ast

[17:36] <[Coke]> er, s:g

[17:37] <[Coke]> TimToady++ thanks.

[17:37] *** kurahaupo joined
[17:38] <[Coke]> wtf? now getting 1.3s with slurp... checking...

[17:39] <[Coke]> TimToady: hee: so, with slurp and this regexp, 19s:

[17:39] <[Coke]> my $home = %*ENV<HOME>; $guts ~~ s:g/ $home /.../;

[17:40] <[Coke]> with your regexp, just over 1s:

[17:40] <[Coke]> $guts ~~ s:g/ "{%*ENV<HOME>}" /.../;

[17:40] <[Coke]> I assume that variable lookup is expensive. I would expect those to optimize out to the same thing eventually.

[17:41] <TimToady> now try: my $r = rx/ "{%*ENV<HOME>}" /; $guts ~~ s:g/ <$r> /

[17:41] <TimToady> or so

[17:41] *** Sqirrel left
[17:41] <TimToady> or maybe that's the same

[17:42] * TimToady does not suggest using an EVAL on %*ENV<HOME>...

[17:43] <[Coke]> 2.5s

[17:43] <japhb> With the "{...}" form, does the interpolation happen only once?

[17:43] <yoleaux> 10:37Z <timotimo> japhb: i didn't write p6doc-index, i just wanted to add a little feature and didn't want to rewrite the code like that :)

[17:43] <timotimo> hey japhb :)

[17:43] <japhb> timotimo: Fair enough

[17:43] <japhb> o/

[17:45] <TimToady> the $home variant should be really a really fast literal match; dunno why it's so slow

[17:45] <colomon> japhb: I've really enjoyed reading the Forth background material linked from the CamelForth page.  :)

[17:46] <TimToady> m: my $home = %*ENV<HOME>; say $home.WHAT;  # just checking

[17:46] <camelia> rakudo-moar 315ec6: OUTPUT«(Str)␤»

[17:46] <masak> m: sub prefix:<∑>([$from, $to, &term]) { [+] ($from..$to).map(&term) }; say ∑(0, 10, { $^n ** 2})

[17:46] <camelia> rakudo-moar 315ec6: OUTPUT«385␤»

[17:46] <masak> \o/

[17:46] * TimToady wonders if it's reboxing a native string many times

[17:46] <masak> so many cool things are possible in Perl 6 already.

[17:47] * vendethiel 's back and yawning

[17:47] <TimToady> m: my $home = %*ENV<HOME>; say $home.DUMP;  # just checking

[17:47] <camelia> rakudo-moar 315ec6: OUTPUT«"/home/camelia"␤»

[17:47] <TimToady> or however you check that

[17:48] <masak> by the way, this slide deck http://faculty.washington.edu/ikalet/courses/lisp/macros.pdf is worth perusing. it ends with "When to use macros -- When nothing else will do: - conditional evaluation - access to generalized variables (places) -- For computation at compiler-time -- For implementing embedded languages"

[17:48] <masak> I largely agree.

[17:49] <TimToady> when you need a safer escape valve than BEGIN

[17:49] <colomon> masak: why sub prefix instead of just sub?

[17:50] *** FROGGS_ joined
[17:50] *** ptc_p6 joined
[17:50] <colomon> (in your ∑ example, I mean.)

[17:51] <TimToady> [Coke]: my $home = "{%*ENV<HOME>}"; $guts ~~ s:g/ $home /.../;  # how 'bout this one?

[17:51] *** azawawi joined
[17:51] <azawawi> hi :)

[17:51] <yoleaux> 15:08Z <lizmat> azawawi: "foo".path is deprecated, "foo".IO is not

[17:52] <dalek> perl6-roast-data: 1b14411 | coke++ | / (5 files):

[17:52] <dalek> perl6-roast-data: today (automated commit)

[17:52] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/1b14411e16

[17:52] <dalek> perl6-roast-data: 86d11c4 | coke++ | bin/cleanse:

[17:52] <dalek> perl6-roast-data: Add script for cleaning up homedir info.

[17:52] <dalek> perl6-roast-data: 

[17:52] <dalek> perl6-roast-data: TimToady++ and lizmat++ for help.

[17:52] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/86d11c4cfb

[17:53] <[Coke]> TimToady: that variant is about 19s.

[17:53] <TimToady> with "" on the left?

[17:53] <azawawi> i didnt know that $file-handle.spurt would produce such a long discussion on #perl6 :)

[17:53] <azawawi> lizmat: thanks for the clarification

[17:53] *** FROGGS left
[17:53] <TimToady> forcing an unboxing of a native str?

[17:54] <[Coke]> TimToady: yes.

[17:54] <lizmat> sometimes the tiniest of remarks will do that, don't worry about it :-)

[17:54] <TimToady> that's completely bizarre

[17:54] <[Coke]> I feel almost masak-like.

[17:55] <[Coke]> https://github.com/coke/perl6-roast-data/commit/86d11c4cfb << that has bin/cleanse, you can try it out yourself if you want to play with it. (note that my local version is only checking one log file, the one checked in runs against all of them)

[17:55] <[Coke]> This is perl6 version 2014.09-256-g8102da0 built on MoarVM version 2014.09-54-g03ac9a7

[17:56] <[Coke]> (I skipped the tempfile there and just overrode the original. "close enough")

[17:58] *** pecastro left
[17:58] <TimToady> perhaps the $home code is doing something silly like checking to see if the string has changed using operators that are slower than just doing the operation

[17:59] *** virtualsue left
[17:59] <TimToady> or maybe it's the check to see if $home contains a regex

[18:00] *** Alula left
[18:05] *** mls left
[18:09] *** Alina-malina left
[18:10] *** kjs_ left
[18:10] <azawawi> lizmat: any idea why a ctrl-c handler can consume 100% of a cpu core https://github.com/MoarVM/MoarVM/issues/149 ?

[18:11] *** ptc_p6 left
[18:11] <lizmat> nothing other than it's continously polling ?

[18:11] <lizmat> feels more like a libuv issue than a MoarVM issue, really  :-(

[18:11] <azawawi> i see

[18:11] <lizmat> I hope jnthn will be able to say something about then when he's back from vacation

[18:11] <vendethiel> "why don't google pursue with dart" uh because dart sucks maybb

[18:12] <lizmat> on the "understanding is overrated" bit:

[18:12] <lizmat> what is a "named pipe" in the context of IO::Path.p ?

[18:12] <lizmat> S16:364

[18:12] <synopsebot> Link: http://perlcabal.org/syn/S16.html#line_364

[18:13] <lizmat> on an opened pipe, I can see .p returning True

[18:14] <timotimo> named pipe is what you get when you mkfifo on linux, no?

[18:15] *** ab5tract joined
[18:17] <lizmat> possibly  :-)

[18:18] *** grettis joined
[18:20] *** Alina-malina joined
[18:24] <dalek> specs: 8da8c15 | (Elizabeth Mattijsen)++ | S16-io.pod:

[18:24] <dalek> specs: Introduce pipe() for opening a pipe

[18:24] <dalek> specs: review: https://github.com/perl6/specs/commit/8da8c15aac

[18:24] <lizmat> FROGGS_:  ^^^ instead of openpipe()  ?

[18:25] <ab5tract> \o/ , set size comparator subs are working :D

[18:25] <ab5tract> (for baggies)

[18:25] <lizmat> ab5tract?

[18:25] <FROGGS_> lizmat: wfm :o)

[18:26] <moritz> taxonomy question: how do you call the little wood or plastic pieces of board games?

[18:26] <timotimo> pegs? pieces?

[18:26] <lizmat> a piece ?

[18:27] <timotimo> it seems like they really are called "pieces"

[18:27] <moritz> ok, thanks

[18:27] <moritz> ah, and "meeple" when they are person-shaped: http://en.wiktionary.org/wiki/meeple

[18:28] <ab5tract> m: multi sub infix:<<(<)>>(Baggy $a, Baggy $b --> Bool) { so $a.keys.all (elem) $b and so ($a{$_} < $b{$_} for $a.keys).all; } (bag(<1 1>) (<) bag<1 1 1>).say

[18:28] <camelia> rakudo-moar 315ec6: OUTPUT«===SORRY!=== Error while compiling /tmp/vANqODqG8e␤Two terms in a row␤at /tmp/vANqODqG8e:1␤------> so ($a{$_} < $b{$_} for $a.keys).all; } ⏏(bag(<1 1>) (<) bag<1 1 1>).say␤    expecting any of:␤        metho…»

[18:28] <moritz> oh, and that one says "token" instead of "piece"

[18:28] <ab5tract> m: multi sub infix:<<(<)>>(Baggy $a, Baggy $b --> Bool) { so $a.keys.all (elem) $b and so ($a{$_} < $b{$_} for $a.keys).all; }; (bag(<1 1>) (<) bag<1 1 1>).say

[18:28] <camelia> rakudo-moar 315ec6: OUTPUT«===SORRY!===␤The 'bag' listop may not be called without arguments (please use () or whitespace to clarify)␤at /tmp/P9I0xBRz25:1␤------> for $a.keys).all; }; (bag(<1 1>) (<) bag⏏<1 1 1>).say␤    expecting any o…»

[18:28] <ab5tract> m: multi sub infix:<<(<)>>(Baggy $a, Baggy $b --> Bool) { so $a.keys.all (elem) $b and so ($a{$_} < $b{$_} for $a.keys).all; }; (bag(<1 1>) (<) bag(<1 1 1>)).say

[18:28] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[18:28] <lizmat> .oO( me actually has some gummibear meeples )

[18:28] <ab5tract> (sorry about that)

[18:29] <timotimo> moritz: i didn't realize they'd actually call such pieces "meeples" outside of carcassone

[18:29] <timotimo> carcassonne*

[18:29] <ab5tract> lizmat: that seems like appropriate behavior for (<) when baggies are provided as args, no?

[18:30] <timotimo> ab5tract: junctions have quite severe performance implications; too expensive to be used in the core setting IMO

[18:30] <timotimo> i would suggest [&&] list-of-bools instead of so (list-of-bools).all

[18:30] <ab5tract> thank you for the feedback

[18:30] <ab5tract> i can convert other set operators to this form as well

[18:31] <timotimo> that would be appreciated :)

[18:31] <ab5tract> there are junctions all over the comparators

[18:32] <lizmat> timotimo: indeed

[18:32] <timotimo> ab5tract: i say this with a great deal of pain in my voice, you see

[18:32] <ab5tract> timotimo: if you have time, would you mind elaborating on the performance implications of junctions? 

[18:33] <timotimo> i personally love junctions

[18:33] <ab5tract> and more importantly, what can we do about it?

[18:33] <lizmat> ab5tract: so you're saying we should special case (<) for Bag/Bag ?  What about Mix/Bag, Mix/Mix, Bag/Mix ?

[18:33] <timotimo> for one, every time you want to do stuff with a junction, you create a full object that has all the values as a list

[18:34] <timotimo> and the autothreader actually goes ahead and evaluates the values in a pseudorandom order, so that people don't get the idea to use junctions as ordered execution of things

[18:34] <timotimo> .o( or is that just the hyper operators? )

[18:34] *** azawawi left
[18:35] <timotimo> what i do know - as i've measured it - is that the optimization that turns $foo == 1 | 2 | 3 into $foo == 1 || $foo == 2 || $foo == 3 was really worth it "back then"

[18:35] <lizmat> diner&

[18:37] <ab5tract> it's almost certainly me, but it seems to make (elem) usage more cumbersome

[18:37] *** fhelmberger left
[18:37] <ab5tract> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; so $a.keys.all (elem) $b

[18:37] <camelia> rakudo-moar 315ec6: ( no output )

[18:38] <ab5tract> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; (so $a.keys.all (elem) $b).say

[18:38] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[18:38] <ab5tract> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; (so $a.keys (elem) $b).say

[18:38] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[18:39] <ab5tract> is this the syntax that you recommend?

[18:39] <ab5tract> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; ([&&] $a.keys) (elem) $b

[18:39] <camelia> rakudo-moar 315ec6: ( no output )

[18:40] *** molaf joined
[18:42] *** mls joined
[18:43] <ab5tract> that doesn't work, nor make a lick of sense, which means it's not what you are recommending.

[18:43] * ab5tract goes golfing

[18:43] <FROGGS_> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; say ([&&] $a.keys) (elem) $b

[18:43] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[18:48] <raydiak> I'm not familiar with (elem); which synopsis is it in?

[18:49] *** ptc_p6 joined
[18:50] <FROGGS_> m: say <1 1>.Bag (elem) <1 1 1>.Bag

[18:50] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[18:50] <FROGGS_> m: say <1 1>.Bag (elem) <1 1>.Bag

[18:50] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[18:50] <FROGGS_> m: say <1 1>.Bag (elem) <1>.Bag

[18:50] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[18:50] <TimToady> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; say [&&] $a.keys X∈ $b

[18:50] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[18:51] <TimToady> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; say not first *.not, $a.keys X∈ $b

[18:51] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[18:51] <TimToady> there's a lazy one

[18:52] <TimToady> maybe [&&] is lazy enough

[18:54] <ab5tract> thanks TimToady!

[18:54] <TimToady> raydiak: the Texas versions of the set ops are not yet well documented

[18:55] <TimToady> and the standard ones, are, well, standard...

[18:55] <ab5tract> i saw the 'texas' label in the tests. what does it refer to?

[18:55] <TimToady> originally, refereed to the << >> versions of « »

[18:56] <TimToady> "Everything's bigger in Texas."

[18:56] <ab5tract> ahh

[18:56] <ab5tract> :)

[18:56] <TimToady> now it's the ASCII workaround for any fancy Unicode operator

[18:56] <TimToady> and still generally bigger and uglier :)

[18:59] <ab5tract> m: my $a = <1 1>.Bag; my $b = <1 1 1>.Bag; say [&&] $a.keys (elem) $b

[18:59] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:00] <ab5tract> so how to explain the difference in behavior?

[19:00] <timotimo> why would the list of keys of $a be an element in the bag $b?

[19:01] <ab5tract> no, it wouldn't.

[19:01] <ab5tract> this is all stuff i learned yesterday, when investigating junctions

[19:01] <ab5tract> but isn't X\u2208 just (elem) ?

[19:02] <timotimo> m: say "\u2208"

[19:02] <camelia> rakudo-moar 315ec6: OUTPUT«===SORRY!=== Error while compiling /tmp/5fvxzDpBmL␤Unrecognized backslash sequence: '\u'␤at /tmp/5fvxzDpBmL:1␤------> say "\⏏u2208"␤    expecting any of:␤        argument list␤        prefix or term␤    …»

[19:02] <timotimo> m: say "\x2208"

[19:02] <camelia> rakudo-moar 315ec6: OUTPUT«∈␤»

[19:02] <timotimo> no, just \x2208 is (elem)

[19:02] <ab5tract> ahh

[19:05] <ab5tract> so what is X\u2208 ? TimToady's invocation just gives an undeclared routine exception

[19:05] <ab5tract> in my repl

[19:06] <FROGGS_> what the heck is this?

[19:06] <FROGGS_> [2014-10-30T19:06:14Z] GET /recent HTTP/1.1

[19:06] <FROGGS_> Commands out of sync; you can't run this command now

[19:06] <FROGGS_>   in method execute at lib/DBDish/mysql.pm6:170

[19:07] <ab5tract> gar

[19:07] <ab5tract> don't worry folks, i do feel like i'm starting to get the hang of it :)

[19:07] <timotimo> sadly you don't have proper spec tests for that yet, right?

[19:08] <dalek> specs: eeb0e4e | TimToady++ | S99-glossary.pod:

[19:08] <dalek> specs: gloss "Texas operator"

[19:08] <dalek> specs: review: https://github.com/perl6/specs/commit/eeb0e4ec1b

[19:09] <TimToady> ab5tract: your repl doesn't handle Unicode right

[19:12] <ab5tract> hm. i can see all the unicode it replies to me

[19:12] <timotimo> that doesn't have to mean anything %)

[19:12] <TimToady> or maybe your copy pad is forcing non-Unicode?

[19:13] <TimToady> we all pretty much assume a consistent UTF-8 datastream here these days

[19:13] <TimToady> are you in a screen program or such?

[19:13] <timotimo> and then out of nowhere comes a BOM and blows up our everything

[19:13] <ab5tract> not to worry, the part that was really tricking me was that i was parsing the 'X' in X\u2208 as part of the unicode escaping, not as the operator :)

[19:14] <TimToady> at least at one time, you had to say screen -u to get utf8, but that's shouldn't be necessary in newer versions

[19:14] <TimToady> okay

[19:14] <ab5tract> it might be irssi.

[19:15] <TimToady> what's your LANG envvar set to?

[19:15] <TimToady> did the epsilon show up as \u in irssi?

[19:15] <ab5tract> it isn't actually. i'm on a mac, i guess it hasn't been necessary up until now

[19:15] <ab5tract> yes

[19:16] <TimToady> try LANG=en_US.UTF-8 or so

[19:16] <ab5tract> thanks TimToady, i will give it a try :)

[19:17] * TimToady guesses the ␤ is also not showing up correct either

[19:18] <TimToady> .u ␤

[19:18] <yoleaux> U+2424 SYMBOL FOR NEWLINE [So] (␤)

[19:18] <ab5tract> nope

[19:18] <ab5tract> i'll try restarting with the envvar

[19:18] *** ab5tract left
[19:19] *** ab5tract joined
[19:19] <TimToady> hyper is »+«

[19:20] <ab5tract> \o\ \o/ /o/ :D

[19:20] <ab5tract> it does the trick

[19:20] <TimToady> m: say 42

[19:20] <camelia> rakudo-moar 315ec6: OUTPUT«42␤»

[19:20] <TimToady> and you should have an NL char there after 42

[19:21] <TimToady> m: say "foo bar baz" ~~ / \w+ /

[19:21] <camelia> rakudo-moar 315ec6: OUTPUT«｢foo｣␤␤»

[19:21] <TimToady> m: say "foo bar baz" ~~ m:g/ \w+ /

[19:21] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:22] <ab5tract> yeah, it looks snazzy now

[19:22] <TimToady> m: say "foo bar baz" ~~ / (\w+)* % ' ' /

[19:22] <camelia> rakudo-moar 315ec6: OUTPUT«｢foo bar baz｣␤ 0 => ｢foo｣␤ 0 => ｢bar｣␤ 0 => ｢baz｣␤␤»

[19:22] <TimToady> \o/

[19:22] <ab5tract> plus the cool ｢braces｣

[19:23] <ab5tract> the wool has been pulled from my eyes, and camelia's voice is prettier than ever

[19:23] <timotimo> ooh

[19:23] <timotimo> poor you

[19:24] <ab5tract> once again i find myself thanking TimToady for changing everything :)

[19:24] <TimToady> if you wax too poetical, we'll make you write an Advent entry :P

[19:24] <ab5tract> i'd love to :)

[19:25] <masak> \o/

[19:26] <TimToady> [Coke]: me has reproduced the sloth of /$home/ here and will investigate further after lunch and backlogging (and all the other yaks that crop up to be shoven)

[19:27] <timotimo> /$home/ vs /"$home"/?

[19:28] *** rindolf left
[19:28] *** rindolf joined
[19:29] <lizmat> m: say 1 elem <1 1>.Bag

[19:29] <camelia> rakudo-moar 315ec6: OUTPUT«===SORRY!=== Error while compiling /tmp/JMXFdlQINA␤Two terms in a row␤at /tmp/JMXFdlQINA:1␤------> say 1 ⏏elem <1 1>.Bag␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-…»

[19:29] <timotimo> you want (elem), no?

[19:29] <lizmat> m: say 1 (elem) <1 1>.Bag

[19:29] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:29] <lizmat> hmmm

[19:29] <timotimo> huh, interesting

[19:29] <timotimo> (elem) just doesn't know what a bag is?

[19:30] <timotimo> m: say (1 => 2) (elem) <1 1>.Bag

[19:30] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:31] <[Coke]> TimToady: your gloss fo r texas operator uses a texas ellipsis, which I found amusing.

[19:32] *** sorear left
[19:35] <lizmat> update&

[19:35] *** lizmat left
[19:35] <dalek> cpandatesters.perl6.org: b816c3c | (Tobias Leich)++ | / (4 files):

[19:35] <dalek> cpandatesters.perl6.org: implement view of most recent reports

[19:35] <dalek> cpandatesters.perl6.org: review: https://github.com/perl6/cpandatesters.perl6.org/commit/b816c3c69d

[19:36] <ab5tract> i noticed that last night, but figured it was by design

[19:36] *** guru joined
[19:36] <TimToady> m: say '1' (elem) <1 1>.Bag

[19:36] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[19:36] <ab5tract> yup

[19:37] <TimToady> bags are type sensitive

[19:37] *** guru is now known as Guest78815

[19:37] *** Guest78815 is now known as ajr_

[19:37] <ab5tract> TimToady: is there any limit to what can be a key, then?

[19:37] *** sorear joined
[19:37] <ab5tract> i didn't find any while poking :)

[19:38] *** rindolf left
[19:39] *** lizmat joined
[19:39] *** rindolf joined
[19:42] <lizmat> TimToady++  :-)

[19:42] <lizmat> m: say 1 (elem) (1,1).Bag

[19:42] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[19:43] *** darutoko left
[19:46] <lizmat> m: say (1 => 2) (elem) (1 => 2).Bag

[19:46] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:46] <lizmat> not sure that is right...  I guess Pairs are special...

[19:46] *** kurahaupo_ joined
[19:46] <lizmat> m: say 1 (elem) (1 => 2).Bag

[19:46] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[19:46] <ab5tract> m: say (1 => 2) (elem) ( (1 => 2) => "could be useful" )

[19:46] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:47] <ab5tract> ah, it's just another pair

[19:47] <ab5tract> m: say (1 => 2) (elem) ( (1 => 2) => "could be useful" ).hash

[19:47] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:48] <masak> m: say 5 (elem) ( 5 => "OH HAI" ).hash

[19:48] <camelia> rakudo-moar 315ec6: OUTPUT«False␤»

[19:49] <FROGGS_> m: say '5' (elem) ( 5 => "OH HAI" ).hash

[19:49] <camelia> rakudo-moar 315ec6: OUTPUT«True␤»

[19:49] <ab5tract> of courtse

[19:49] <ab5tract> m: say (1 => 2) (elem) ( (1 => 2) => "could be useful" ).bag

[19:49] <camelia> rakudo-moar 315ec6: OUTPUT«No such method 'bag' for invocant of type 'Pair'␤  in block <unit> at /tmp/BaUpK5DwIz:1␤␤»

[19:49] *** kurahaupo left
[19:50] <masak> I'm not 100% sure what I would expect (elem) to mean with a Hash rhs...

[19:50] <ab5tract> right, as it is a set operator

[19:50] <ab5tract> it's a strange way to lookup a value in a hash :)

[19:50] <moritz> when it's a set operator, I expect coercion to set

[19:50] <masak> of... the hash keys...?

[19:51] <masak> I guess they are more set-like than the values.

[19:51] <moritz> m: say (set %( a => 2, b => 53)).perl

[19:51] <camelia> rakudo-moar 315ec6: OUTPUT«set("a" => 2,"b" => 53)␤»

[19:51] <moritz> oh, that makes sense

[19:51] <moritz> a hash in list context dissolves into a list of pairs

[19:51] <masak> it kinda does, yes.

[19:52] *** jfredett joined
[19:54] *** cognominal joined
[19:57] *** cognominal left
[19:58] <lizmat> m: say Mu.new.WHICH   # hmmm....

[19:58] <camelia> rakudo-moar 315ec6: OUTPUT«Mu|58385456␤»

[19:58] <ab5tract> moritz: wouldn't it make more sense to also add the values to the set, then?

[19:58] <moritz> ab5tract: why the values?

[19:58] <ab5tract> nevermind, i misread what you wrote

[19:59] <ab5tract> m: say (set %( a => 2, b => 53).kv).perl

[19:59] <camelia> rakudo-moar 315ec6: OUTPUT«set("a",2,"b",53)␤»

[19:59] <ab5tract> if you want it that way, its super clean to get it that way :)

[20:00] <dalek> rakudo/nom: a68a3ee | (Elizabeth Mattijsen)++ | src/core/io_operators.pm:

[20:00] <dalek> rakudo/nom: Simplify named params for open()

[20:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a68a3ee420

[20:01] <ab5tract> o O ( not sure why i said 'you', when i meant 'i' )

[20:15] *** kurahaupo_ left
[20:16] *** Ven joined
[20:32] <Ven> http://www.reddit.com/r/programming/comments/2ksz9w/objects_concurrency_video_link_skips_discussion/ <- ah/

[20:37] <lizmat> ah?

[20:38] *** fhelmberger joined
[20:38] <lizmat> nobody taking the bait, is what you're saying ?

[20:38] *** spider-mario left
[20:40] *** spider-mario joined
[20:40] <Ven> yes :P

[20:41] <lizmat> fwiw, I've said this a few days ago already, but it feels to me MoarVM and/or NQP has become a lot less stable of late

[20:41] <lizmat> when running a spectest, I get ~6 test files with errors, that don't appear when run by themselves

[20:41] <lizmat> and the ~6 test files are a different set each time

[20:42] *** fhelmberger left
[20:43] <[Coke]> lizmat: I'm seeing huge jit failures on a flapping basis.

[20:45] <bartolin> lizmat, [Coke]: you're both on macosx? I haven't seen such problems lately (neither on linux nor on freebsd)

[20:45] <lizmat> mac OS X, Mavericks

[20:46] <[Coke]> 10.9.5

[20:47] <FROGGS_> moritz: also had flapping tests until he wiped his /install

[20:47] *** anaeem1 left
[20:47] <FROGGS_> err, s/':'//

[20:47] <lizmat> will try that *again*

[20:48] <FROGGS_> I have no osx machine, I can't help here

[20:48] <[Coke]> this is a clean install every day here.

[20:49] <[Coke]> I do have an installed perl6, but that's not the install dir where the moarvm that's being built is being installed.

[20:54] * geekosaur should update his build and see what the testsuite does

[20:55] *** [Sno] left
[20:58] * lizmat nuked install, rebuilt from scratch, ran spectest, and sees another set of 8 testfiles with fails   :-(

[20:58] <lizmat> an example:

[20:58] <lizmat> t/spec/S02-literals/char-by-number.rakudo.moar              (Wstat: 6 Tests: 28 Failed: 0)

[20:58] <lizmat>   Non-zero wait status: 6

[20:58] <lizmat>   Parse errors: Bad plan.  You planned 42 tests but ran 28.

[20:59] <moritz> :(

[21:01] <ingy> heya moritz :)

[21:01] <moritz> \o ingy 

[21:01] <ingy> moritz: do you do the irc logs?

[21:01] <ingy> #inline on irc.perl.org needs one

[21:02] <PerlJam> ingy: I think the logs do themselves once he configures the bot :)

[21:02] <ingy> :P

[21:02] <moritz> ingy: did you ask in the channel if everybody is fine with public logs?

[21:02] <PerlJam> ingy: Are you getting much participation on #inline?

[21:03] <ingy> PerlJam: yes.

[21:03] <ingy> moritz: I can but it's pretty much just me and davido and mohawk, with others lurking

[21:03] <moritz> ingy: please ask anyway

[21:04] <moritz> ingy: I've had too many people ask me to do logs, and then had serious opposition after the bot joined the channel

[21:04] *** virtualsue joined
[21:06] <ingy> moritz: bulk88, davido_laptop, dams, dg, garu, mst, nine_, rafl, silverdirk, sivoais, ugexe, willthechill: any of you object to having a logging bot in here?

[21:06] <ingy> asked

[21:06] <PerlJam> ingy++

[21:06] <ingy> The channel will be registered to me

[21:06] <ingy> need to do that today

[21:07] <ingy> but it's the communication point for the TPF grant

[21:07] * moritz started to work on https://github.com/moritz/igel-aergern today

[21:07] <ingy> so I want it logged

[21:08] <ingy> moritz: is it possible to send you 10 days of prior weechat logging?

[21:08] <PerlJam> ingy: btw, I don't know if you get enough warm fuzzies about the work on Inline::C that you guys are doing, but I think the blog and your reports are great.  Tell davido I said so too.

[21:09] <moritz> ingy: I don't have any ready-made import script or so

[21:09] <ingy> PerlJam: thx

[21:09] <ingy> moritz: ok, maybe I can write one

[21:09] <ingy> if you want

[21:10] <moritz> ingy: well, your choice

[21:11] <ingy> ok, not top priority at the moment, but would be nice to have the whole grant work logged for posterity

[21:11] <moritz> ingy: but if you want an import, and I can only start logging after the import

[21:11] <moritz> (auto-increment keys + reliance on ordering)

[21:11] <ingy> moritz: I'll ping you tomorrow after everyone's had a chance to see the msg

[21:11] *** davido__ joined
[21:12] <moritz> ingy: ok, great

[21:12] <davido__> hi moritz :)  

[21:12] <ingy> moritz: you could start logging then I could apply the import to everything, and we could start over with that

[21:12] <ingy> so not really blocking on each other

[21:13] <moritz> ingy: that's a bit icky

[21:13] <ingy> ok

[21:13] <moritz> (also means I can't log during import)

[21:14] <ingy> ok forget it

[21:14] <ingy> I'll can just gist the prior log

[21:14] *** cognominal joined
[21:15] *** ptc_p6 left
[21:16] <ab5tract> so i'm adding some tests for baggied set comparators

[21:17] <ab5tract> i kind of appreciate this style of output: ok 107 - bag(n, e(4), d, y) is not a strict superbag of bag(n, e(2), d)

[21:18] <geekosaur> ok, so I can confirm on 10.9.5 that I get erratic behavior from the spectests

[21:18] <ab5tract> but i don't see any other tests expressing their values that wayt

[21:18] <dalek> rakudo/nom: 49658c7 | (Elizabeth Mattijsen)++ | src/core/IO/Handle.pm:

[21:18] <dalek> rakudo/nom: Add $!pipe attr/method, conflate close/close-pipe

[21:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/49658c7cca

[21:18] <dalek> rakudo/nom: ed2c12c | (Elizabeth Mattijsen)++ | src/core/IO/Path.pm:

[21:18] <dalek> rakudo/nom: Add .pipe method, as alternative to .open

[21:18] <dalek> rakudo/nom: 

[21:18] <dalek> rakudo/nom: This basically exposes flaws in the current setup: an IO::Path is supposed

[21:18] <dalek> rakudo/nom: to be a path on a file system.  Abusing it for the parameters of a pipe seems

[21:18] <dalek> rakudo/nom: counterproductive.  But I guess it will do as an intermediate step.

[21:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ed2c12c1af

[21:18] <dalek> rakudo/nom: 0eb4bc8 | (Elizabeth Mattijsen)++ | src/core/io_operators.pm:

[21:18] <dalek> rakudo/nom: Add pipe(), as loosely specced in S16

[21:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0eb4bc848d

[21:18] <ab5tract> i can compose it according to the existing style, of course. i'm just curious if anyone else sees value in seeing the variables themselves

[21:19] <lizmat> ab5tract: it helps in debugging tests, at least they helped me

[21:20] <lizmat> $ 6 'my $h = pipe "echo Hello"; say $h.get; say $h.close'

[21:20] <lizmat> Hello

[21:20] <lizmat> Proc::Status.new(exit => 0, pid => Any, signal => 0)

[21:20] <ab5tract> to print the variables with the test output, you mean? ok, cool. none of the other set operator tests do it, so i wasn't sure

[21:21] <lizmat> geekosaur: thanks for the reality check

[21:21] <geekosaur> and that was from a fresh install

[21:22] <lizmat> yeah, the last one was also from a fresh install for me

[21:22] <FROGGS_> lizmat++

[21:23] <masak> 'night, #perl6

[21:23] <bartolin> does anyone on non-OSX gets such erratic behaviour from the spectests?

[21:23] <moritz> \o masak 

[21:25] <ab5tract> ciao masak

[21:26] *** grettis left
[21:28] *** grettis joined
[21:29] *** cognominal left
[21:29] <FROGGS_> m: say uniname "\x0a".chr; say "\x0a".ord;   say uniname "\n"; say "\n".ord

[21:29] <camelia> rakudo-moar 315ec6: OUTPUT«NULL␤10␤LINE FEED (LF)␤10␤»

[21:29] <FROGGS_> what's going on here?

[21:30] <FROGGS_> m: say "\x0a"; say "\n"

[21:30] <camelia> rakudo-moar 315ec6: OUTPUT«␤␤␤␤»

[21:30] <FROGGS_> ohh

[21:30] <FROGGS_> FROGGS_--

[21:30] <FROGGS_> m: say "a".chr

[21:30] <camelia> rakudo-moar 315ec6: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏a' (indicated by ⏏)␤  in method Int at src/gen/m-CORE.setting:13668␤  in method Int at src/gen/m-CORE.setting:6096␤  in method chr at src/gen/m-CORE.setting:…»

[21:31] <FROGGS_> m: say "\n".chr

[21:31] <camelia> rakudo-moar 315ec6: OUTPUT«␀␤»

[21:31] <FROGGS_> weird

[21:42] *** xfix is now known as notfix

[21:43] <moritz> m: say +''

[21:43] <camelia> rakudo-moar 315ec6: OUTPUT«0␤»

[21:43] <moritz> oh

[21:43] <moritz> numification strips whitspace

[21:43] <moritz> and treats the empty string as zero (without warning)

[21:44] <lizmat> m: say "/".split("/").perl   # unexpected, but I guess specced that way

[21:44] <camelia> rakudo-moar 315ec6: OUTPUT«("", "").list␤»

[21:46] *** kaare_ left
[21:48] *** cognominal joined
[21:48] *** rindolf left
[21:53] <lizmat> FROGGS_: so, if I remember correctly, Win systems have been able to work with "/" on any version that we care to support with rakudo, right ?

[21:54] *** Ven left
[21:54] <mauke> / support goes back to something like DOS 2.0

[21:54] <mauke> in functions that deal with filenames, that is. the shell, not so much

[21:54] <FROGGS_> lizmat: correct

[21:55] <lizmat> so if we start using "/" literally as directory delimiter, we should be fine ?

[21:55] <FROGGS_> yes

[21:55] <lizmat> ok...  :-)

[21:56] <FROGGS_> :o)

[21:56] <FROGGS_> I've got no experience with symbian (which is windows-ish), but I also guess nobody is going to use rakudo there

[21:57] <lizmat> let's cross that bridge when we get there, I would say...

[21:59] <Tekk_> FROGGS_: I may be wrong but I believe that symbian has officially been dead for some years now hasn't it?

[22:00] <FROGGS_> Tekk_: probably, yes

[22:02] *** ruoso left
[22:08] *** ruoso joined
[22:09] *** funjon left
[22:11] *** funjon joined
[22:12] *** ruoso left
[22:12] *** ntln left
[22:13] <lizmat> I'm trying to make a lightweight IO::Dir object

[22:14] *** ntln joined
[22:15] *** funjon left
[22:16] *** ruoso joined
[22:21] *** funjon joined
[22:22] *** treehug88 left
[22:23] <dalek> panda/reporter: fa0ca63 | (Elizabeth Mattijsen)++ | ext/ (2 files):

[22:23] <dalek> panda/reporter: Revert dir() --> List[Str] changes

[22:23] <dalek> panda/reporter: review: https://github.com/tadzik/panda/commit/fa0ca636c2

[22:23] <dalek> panda/reporter: 7ba56ca | (Tobias Leich)++ | ext/ (2 files):

[22:23] <dalek> panda/reporter: Merge branch 'master' of github.com:tadzik/panda into reporter

[22:23] <dalek> panda/reporter: review: https://github.com/tadzik/panda/commit/7ba56ca32c

[22:23] <dalek> panda/reporter: 7785368 | (Tobias Leich)++ | lib/Panda/ (2 files):

[22:23] <dalek> panda/reporter: fix check of closed pipe's status

[22:23] <dalek> panda/reporter: review: https://github.com/tadzik/panda/commit/7785368761

[22:23] <dalek> panda/reporter: ee4588f | (Tobias Leich)++ | lib/Panda/Reporter.pm:

[22:23] <dalek> panda/reporter: add Content-Length header to reporter http client

[22:23] <dalek> panda/reporter: review: https://github.com/tadzik/panda/commit/ee4588f3b4

[22:23] *** [Sno] joined
[22:27] *** funjon left
[22:31] *** funjon joined
[22:32] *** grettis left
[22:37] *** legrady joined
[22:38] *** funjon left
[22:41] *** ruoso left
[22:41] <lizmat> sleep&

[22:41] *** funjon joined
[22:42] *** ruoso joined
[22:50] *** gfldex left
[22:57] *** grondilu left
[22:59] *** Alina-malina left
[23:02] *** tgt left
[23:04] *** FROGGS_ left
[23:06] *** spider-mario left
[23:16] *** kjs_ joined
[23:16] *** BenGoldberg joined
[23:16] *** cognominal left
[23:28] *** immortal joined
[23:29] *** erkan left
[23:43] *** BenGoldberg left
[23:44] *** virtualsue left
[23:46] *** kjs_ left
[23:51] *** BenGoldberg joined
