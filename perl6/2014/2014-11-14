[00:01] <tony-o> n: my $x := 5; my $y := '$x'; say(nqp::getlexdyn(self,$y));

[00:01] <camelia> niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤'self' used where no object is available at /tmp/QHGAhgyx6m line 1:␤------> [32m; my $y := '$x'; say(nqp::getlexdyn(self[33m⏏[31m,$y));[0m␤␤Potential difficulties:␤  $x is declared but not used at /tmp…»

[00:01] <tony-o> n: my $x := 5; my $y := '$x'; say(nqp::getlexdyn($y));

[00:01] <camelia> niecza v24-109-g48a8de3: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/RFHqJ6I3bs line 1:␤------> [32mmy [33m⏏[31m$x := 5; my $y := '$x'; say(nqp::getlexd[0m␤␤Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Any␤  at /t…»

[00:01] <TimToady> niecza has no nqp

[00:01] <tony-o> oh oops

[00:02] <tony-o> nqp-m: my $x := 5; my $y := '$x'; say(nqp::getlexdyn($y));

[00:02] <camelia> nqp-moarvm: OUTPUT«␤»

[00:02] *** Mouq left
[00:02] <tony-o> hm

[00:02] <TimToady> that's not what the 'dyn' means

[00:02] *** Mouq joined
[00:04] <TimToady> it's looking up the call stack for variables marked 'is dynamic'

[00:04] *** jfredett joined
[00:04] <TimToady> typically a $*foo variable

[00:05] <tony-o> ahh

[00:05] <TimToady> normal lexicals are considered invisible to the dynvar mechanism

[00:05] <TimToady> or we'd never be able optimize anything

[00:05] <Mouq> second Supply request: Supply.first()

[00:06] <tony-o> im trying to use v5 as a guide, trying to slang sql statements 

[00:06] <tony-o> nqp-m: my $x := 5; my $y := '$x'; say(nqp::getlex($y));

[00:06] <camelia> nqp-moarvm: OUTPUT«expected QAST constant; didn't get one␤   at gen/moar/stage2/QAST.nqp:5354  (/home/camelia/rakudo-inst-1/languages/nqp/lib/QAST.moarvm:as_mast_constant:6)␤ from gen/moar/stage2/QAST.nqp:5342  (/home/camelia/rakudo-inst-1/languages/nqp/lib/QAST.moarvm:as_mast_c…»

[00:07] <TimToady> nqp-m: my $x := 5; my $y := '$x'; say(::($y));

[00:07] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "say(::($y)"␤   at gen/moar/stage2/NQPHLL.nqp:485  (/home/camelia/rakudo-inst-1/languages/nqp/lib/NQPHLL.moarvm:panic:105)␤ from gen/moar/stage2/NQP.nqp:913  (/home/camelia/rakudo-inst-1/languages/nqp/lib/nqp.moarvm:comp_unit:872)␤ f…»

[00:07] <TimToady> I guess nqp doesn't support ::() notation

[00:08] *** jfredett left
[00:15] *** ab5tract left
[00:18] *** grondilu joined
[00:18] <Mouq> Hmm, actually it looks like using .first on a Supply is a bit of a smell

[00:20] <TimToady> sort of a heavy-duty promise

[00:21] <TimToady> except for the async notification

[00:22] <TimToady> really more of a heavy-duty callback

[00:22] <TimToady> why not just use a callback in that case?

[00:24] *** cognominal left
[00:24] *** cognominal joined
[00:25] <timotimo> tadzik: i don't remember if i have an account on feather ... though i probably do

[00:25] <TimToady> but yeah, it's also a bit like using (1..*)[0] to calculate 1 :)

[00:29] <timotimo> oh

[00:29] <timotimo> the benchmarks don't look terribly favourable for my recent optimizations >_<

[00:33] *** exixt_ is now known as exixt

[00:34] *** jfredett joined
[00:38] *** BenGoldberg joined
[00:38] *** jfredett left
[00:40] *** quarkie68 joined
[00:44] *** KCL_ joined
[00:52] *** dayangkun joined
[00:54] *** dayangkun left
[01:05] <Mouq> TimToady: Well, it's from a Supply.categorize and I wanted to do something like .first({.key eq "whatevs"}) ...

[01:07] <Mouq> (which in this case is equivalent to .map, except that .map would keep matching against each new value)

[01:12] *** quarkie68 left
[01:13] *** yoleaux left
[01:14] <TimToady> so it's really more of a map/reduce sort of behavior that is designed to do parallel search for early results

[01:15] <TimToady> yes, it's smelly, but as implemented by Google, it's disruptive technology :)

[01:16] * TimToady hates to think how many electrons Google wastes every year...

[01:18] *** tinyblak left
[01:19] *** tinyblak joined
[01:19] *** raiph left
[01:21] *** raydiak joined
[01:21] *** regreg left
[01:21] *** raydiak left
[01:22] *** raydiak joined
[01:22] *** user_4692 joined
[01:23] <Mouq> m: my $s = Supply.new; $s.map({say "mapped1"}).act({say "tap"}, :done{ say "done"} ); $s.emit(3); $s.done

[01:23] <camelia> rakudo-moar f8f6fe: OUTPUT«mapped1␤tap␤done␤»

[01:23] <Mouq> m: my $s = Supply.new; $s.map({say "mapped1"}).map({say "mapped2"}).act({say "tap"}, :done{ say "done"} ); $s.emit(3); $s.done

[01:23] <camelia> rakudo-moar f8f6fe: OUTPUT«Memory allocation failed; could not allocate 120832 bytes␤»

[01:24] <Mouq> Or timeout if you have enough mem :/

[01:24] *** user_4692 left
[01:30] <timotimo> http://t.h8.lv/p6bench/2014-11-14-futile_optimizations.html - all the optimization work for no visible improvement :\

[01:31] <Mouq> benchmarks !=== real-world code

[01:36] <timotimo> yeah, well ...

[01:36] <timotimo> not even in our flawed microbenchmarks i can see a difference :S

[01:41] *** telex left
[01:42] *** telex joined
[01:49] *** xenoterracide joined
[01:51] *** KCL_ left
[01:55] *** xenoterracide left
[01:56] <tony-o> Mouq: https://gist.github.com/tony-o/501440a2e7182db2beb3

[01:58] <timotimo> tony-o: --ll-exception shall be your tool of choice

[01:58] <timotimo> could be from your method sql needing a $/ argument

[01:59] <tony-o> timotimo: thank you

[02:00] <tony-o> it's from the method statement_control:sym<with> but i'm not sure why i get that problem but v5 has similar signatures and no problems

[02:03] <timotimo> dunno :\

[02:03] <timotimo> well, v5 also defines its own proto token statement_control, but i don't see a reason why it shouldn't work when you mix in your role to Perl6::Grammar like that

[02:03] <japhb> TimToady: We waste fewer electrons than you might expect ... because when you start talking about many, many megawatts, saving a few REALLY makes a difference.  So we do.  :-)

[02:04] <Mouq> tony-o: Found it

[02:04] <Mouq> nqp::bindkey(%*LANG, 'MAIN', %*LANG<MAIN>.HOW.mixin(%*LANG<MAIN>, SQL::Actions));

[02:04] <Mouq> Try s:g/MAIN/MAIN-actions

[02:05] <timotimo> oh

[02:05] <timotimo> hehe.

[02:05] <timotimo> good catch

[02:05] <tony-o> Mouq++

[02:07] <japhb> timotimo: It may just be that your optimizations are being either defeated (not actually used for any of these tests) or drowned out by things that are more expensive.  Nevertheless, currently invisible improvements may "pop out" at a later date when they are exposed by other changes.

[02:08] <timotimo> thank you for those encouraging words :)

[02:08] <timotimo> and now i remember i had said i'd turn that formula-evaluation-benchmark thingie into a perl6-bench, too!

[02:08] <japhb> Which is a wordy way of saying: Don't get discouraged.  Heck, after all these years SQLite got 50% faster in a single release with a whole bunch of optimizations, some only worth 0.05%

[02:08] <japhb> timotimo: yes please!

[02:09] <japhb> *whole bunch of tiny optimizations

[02:09] <japhb> And I quote: "Each of these optimizations is unmeasurable

[02:09] <japhb> on a real-world system (we have to use cachegrind to get repeatable

[02:09] <japhb> run-times) but if you do enough of them, they add up."

[02:11] <timotimo> fair enough

[02:11] <timotimo> we do still have a whole bunch of huge performance stupidities we ought to get rid of

[02:12] <Mouq> timotimo++

[02:14] <timotimo> Mouq: not the kind of thing i can do :S

[02:14] <timotimo> when we get free register selection for our jit, we'll be able to produce a crapton fewer loads and stores in there

[02:15] <japhb> Yep, that's true.  But I kinda like to look at the converse of Amdahl's law.  If the best single improvement could make the program twice as fast, but it's really hard to do, then do the second or third best improvement now, and when you finally figure out how to make that #1 fix, it will make the program faster by 3x, 4x, or more.  Which will make all that super hard work feel WAY better.  :-)

[02:16] * japhb makes mental lemonade

[02:17] <Mouq> No, no. timotimo++ for many tiny optimizations

[02:20] *** cognominal left
[02:25] <Mouq> third Supply request: when a .tap's :done gets called, call it with Supply.list as the argument

[02:27] <Mouq> (Of course, I could be misunderstanding Supply again)

[02:27] <tony-o> so many little things to go wrong with this mixing

[02:29] <timotimo> "many"? :S

[02:30] <timotimo> Mouq: Supply.list will give you the following events as a lazy list, won't it?

[02:30] <tony-o> yea i think i'm fried for today..even little things like seeing $<sym> in the -actions stuff isn't working for me and i'm just not seeing it

[02:30] <timotimo> does it make sense to call the :done with that?

[02:30] <Mouq> Ahh, yeah, I think I should be using .grab

[02:31] <timotimo> iirc :done is called on a tap when the tappee is done, so the list would be empty?

[02:31] <Mouq> This stuff is weird

[02:31] <timotimo> supplies don't store all the generated values that they have seen in the past

[02:31] <timotimo> i'd think you'd only ever want supply to store all your stuff if you explicitly ask for it

[02:31] <timotimo> i suppose you can introspect the :done callable to see if it accepts a parameter or not, but that seems a bit smelly in that position

[02:32] <Mouq> Well, the list would still be lazy anyway and block. I want to .join the Supply.. but I think I've figured it out

[02:32] <timotimo> don't forget that we want supplies also for things like keyboard and mouse events in a gui or something like that

[02:32] <timotimo> imagine you're moving your mouse across a window and it generates a few kilobytes of mouse position history data per second...

[02:33] <timotimo> jnthn: just now i'm seeing that an in-lined frame doesn't really get handled WRT the dominance tree

[02:34] <Mouq> Right, and I was actually making my head hurt trying to figure out how to do something that .grab is made for

[02:35] <timotimo> in this case of DIVIDE_NUMBERS, the infix:<<> gets inlined (and the lit_s(&infix:<<>) survives for some reason) by having an unconditional goto to bb 34 and from bb 34 back to the original successor of 8, which is simply 9 

[02:35] <timotimo> 9's only predecessor is 34, 8's only successor is 34, but it's not in the dominance tree

[02:35] <timotimo> is that very hard to get right?

[02:36] *** jfredett joined
[02:36] <timotimo> because in that case i ought to do the unbox skipping optimization as well, but it crosses bb borders quite a ways

[02:36] <timotimo> i suppose it could be enough to just check if there's only a single predecessor

[02:37] <timotimo> anyway, it's quite a bit past bedtime here

[02:37] <timotimo> o/

[02:37] *** jimmy_ joined
[02:37] *** jimmy_ is now known as JimmyZ

[02:37] <JimmyZ> good morning, #perl6

[02:39] <colomon> \o

[02:39] *** Mouq left
[02:40] *** jfredett left
[02:40] *** kjs_ left
[02:49] *** xenoterracide joined
[03:04] *** leont left
[03:11] *** Mso150 joined
[03:11] *** espadrine` left
[03:14] *** datums_nb joined
[03:16] *** Mouq joined
[03:37] *** JimmyZ left
[03:38] *** jimmy_ joined
[03:38] *** jimmy_ is now known as JimmyZ

[03:41] *** robinsmidsrod left
[03:42] *** adu joined
[03:43] *** robinsmidsrod joined
[03:44] *** hugme left
[03:45] *** Ulti joined
[03:45] *** hugme joined
[03:45] *** ChanServ sets mode: +v hugme

[03:46] *** revdiablo left
[03:47] *** haroldwu left
[03:47] *** haroldwu joined
[03:47] *** revdiablo joined
[03:49] *** labster left
[03:49] *** Mso150 left
[03:50] *** tinyblak_ joined
[03:52] <TimToady> long time, no dalek

[03:52] *** bjz_ joined
[03:53] *** tinyblak left
[04:01] *** datums_nb left
[04:04] *** rmgk is now known as Guest13057

[04:04] *** rmgk_ joined
[04:04] *** Guest13057 left
[04:04] *** rmgk_ is now known as rmgk

[04:11] *** raiph joined
[04:12] *** kaleem joined
[04:18] *** xenoterracide left
[04:19] *** xenoterracide joined
[04:20] *** erkan left
[04:21] *** xenoterracide_ joined
[04:21] *** xenoterracide left
[04:28] *** zakharyas joined
[04:32] *** kaleem left
[04:32] *** kaleem joined
[04:36] *** raiph left
[04:38] *** raiph joined
[04:44] *** labster joined
[04:49] *** xenoterracide_ left
[04:52] *** bjz_ left
[04:55] *** xenoterracide_ joined
[04:58] *** xenoterracide_ left
[04:58] *** xenoterracide_ joined
[05:01] *** bjz joined
[05:05] *** kaare_ joined
[05:14] *** xenoterracide_ left
[05:17] *** xenoterracide_ joined
[05:18] *** BenGoldberg left
[05:22] *** xenoterracide_ left
[05:23] *** raiph left
[05:26] *** kaleem_ joined
[05:30] *** kaleem left
[05:33] *** xenoterracide_ joined
[05:38] *** xenoterracide_ left
[05:39] *** zakharyas left
[05:46] <ugexe> panda install XML::Query

[05:46] <ugexe> t/basic.t .. | Default constructor for 'Query' only takes named arguments

[05:46] <ugexe> panda look XML::Query

[05:46] <ugexe> prove -v -e 'perl6 -Ilib' t/ | All tests successful.

[05:48] <ugexe> so panda install is affecting the testing in some way to make it fail?

[05:52] *** kaare_ left
[06:11] *** kjs_ joined
[06:14] *** xenoterracide_ joined
[06:15] *** kaare_ joined
[06:31] *** tinyblak_ left
[06:31] *** tinyblak joined
[06:35] *** telex left
[06:36] *** telex joined
[06:44] *** xenoterracide_ left
[06:45] *** esaym153 left
[06:48] *** adu left
[06:53] <tony-o> it happens for some of my modules too -

[06:54] <Mouq> Maybe precompilation issues?

[06:55] <tony-o> Mouq:  im totally stumped on the $<sym> thing for my slang

[06:55] <tony-o> whenever i try using thatbit tells me that $<whatever> is not defined

[07:04] *** anaeem1_ joined
[07:04] *** yoleaux joined
[07:04] *** ChanServ sets mode: +v yoleaux

[07:04] *** anaeem1_ left
[07:05] *** anaeem1_ joined
[07:06] <Mouq> What?

[07:07] <Mouq> as in nqp::atkey($/, 'sym') is undefined?

[07:16] *** rurban joined
[07:17] *** FROGGS joined
[07:18] *** kjs_ left
[07:23] *** rurban1 joined
[07:27] *** rurban left
[07:28] *** kaleem_ left
[07:29] *** smls joined
[07:31] <smls> o/

[07:31] <smls> Today I discovered that $( ) allows interpolating arbitrary code in a string, without creating a block!

[07:31] <smls> Which is great if you want to reference $_ from the outside:

[07:31] <smls> m: say "$_ truncated to zero decimal places is $(.Int), not {.Int}!" given pi

[07:31] <camelia> rakudo-moar f8f6fe: OUTPUT«3.14159265358979 truncated to zero decimal places is 3, not 0!␤»

[07:33] <smls> :)

[07:42] *** woolfy joined
[07:52] *** erkan joined
[07:52] *** erkan left
[07:52] *** erkan joined
[07:53] <TimToady> the bracket form is also supposed to work

[07:54] <TimToady> is is a known bug

[07:54] <TimToady> *it

[07:58] <smls> oh

[07:58] <smls> ok

[08:02] *** tinyblak left
[08:02] *** tinyblak joined
[08:06] <masak> mornings, #perl6

[08:09] <moritz> \o masak

[08:09] <moritz> \o #perl6

[08:10] <masak> "But in the end, I expect you to act like a group of friends who care about each other" -- +1 -- http://blog.codinghorror.com/what-if-we-could-weaponize-empathy/

[08:10] *** regreg joined
[08:11] <masak> of course a blog post titled "What if we could weaponize empathy?" would appeal to someone who once wrote a blog post titled "How can we scale kindness?"

[08:12] <sergot> hi o/

[08:13] <masak> sergocie++! \o/

[08:15] *** darutoko joined
[08:16] <jnthn> morning, #perl6

[08:16] <sergot> masaku++! \o/

[08:16] <sergot> jnthn o/

[08:16] <jnthn> o/ sergot 

[08:17] *** woolfy left
[08:17] <JimmyZ> morning, masak && jnthn !

[08:17] <jnthn> .tell timotimo Yes, we don't merge the dominance trees when inlining

[08:17] <yoleaux> jnthn: I'll pass your message to timotimo.

[08:18] <jnthn> .tell timotimo It's rather possible we should...EA will need it, at least...

[08:18] <yoleaux> jnthn: I'll pass your message to timotimo.

[08:18] *** tinyblak_ joined
[08:18] <jnthn> Of course, since I guess we'd EA as a separate pass, the cheat is just to re-compute the dominance before that pass :)

[08:20] <jnthn> Oh, though we may not need it since the inlined form is still an SSA form... :)

[08:20] *** zakharyas joined
[08:21] <masak> jnthn: you do realize that we have another week of EA hacking coming up...? :)

[08:21] *** tinyblak left
[08:21] <jnthn> masak: Um...mixed in with 2 longhaul flights? :P

[08:22] <masak> aka "design sessions" :P

[08:22] <jnthn> aka "Trying to write EA patches at the BJ airport Starbucks" :)

[08:22] <masak> hey! it almost worked!

[08:22] <jnthn> It SEGV /o\

[08:22] <masak> right. "almost" :)

[08:23] <JimmyZ> at least it builds!

[08:25] <jnthn> There is that :)

[08:25] <masak> right. a SEGV is just C's way of saying "you forgot something somewhere".

[08:25] <jnthn> Hm, I should probably go to work... :)

[08:26] <jnthn> Fun as it would be to stay home and hack native array stuffs instead...

[08:26] <jnthn> commute &

[08:29] <JimmyZ> Where is the broken EA branch?

[08:32] <nwc10> JimmyZ: probably on the way to the train

[08:33] <JimmyZ> :)

[08:33] <nwc10> (ie I'm guessing "jnthn's laptop")

[08:33] <masak> yeah. IIRC, the commit that caused things to SEGV was never pushed to the 'esc' branch.

[08:33] <JimmyZ> .oO( There was also a NFG branch in the secret repo)

[08:34] <nwc10> but it was NFG?

[08:34] <JimmyZ> a year ago :P

[08:35] <masak> nwc10: :P

[08:38] * smls wonders if Match should have a more reader-friendly shortcut for ".list>>.Str" - maybe ".captures-list"? (Considering in Perl 5 it was as easy as putting the match operation in list context, and quite a common thing to do...)

[08:40] <moritz> smls: the main difference is that named captures aren't second class citizens in p6 regexes (and that the matches are actually trees)

[08:40] <moritz> smls: it's much easier to visualize a one-dimensional list than a two-dimensional tree

[08:44] <smls> Still, many common regex (not grammar) use-cases will only deal with a one-dimensinal sequence of positional capture groups, and want to get them into an array or a list of variables easily.

[08:44] <Mouq> smls: Well, there is ~«@()

[08:45] <Mouq> :P

[08:45] <Mouq> m: $_ = "abcd"; m/a(b)c(d)/; say ~«@()

[08:45] <camelia> rakudo-moar f8f6fe: OUTPUT«b d␤»

[08:46] <smls> I didn't know prefix operators could be hyper'ed too!

[08:47] <Mouq> :)

[08:47] <smls> Although your solution won't exactly disabuse people of the notion that Perl is line noise... :S

[08:48] <sergot> ~«@() looks like a Cyclops with a mohawk, doesn't it?

[08:48] <sergot> and a scar on his forehead

[08:48] <moritz> you can always say @()>>.Str if you like :-)

[08:48] <smls> pretty much :)

[08:49] <moritz> @()>>.Str looks like a fish pushing a Str :-)

[08:49] <sergot> now it is a Cyclops with a beard

[08:49] *** molaf__ joined
[08:50] <sergot> fishes like Strs

[08:50] <sergot> :)

[08:53] *** molaf_ left
[08:55] *** virtualsue joined
[08:56] <lizmat> commute to Helsinki&

[08:56] *** lizmat left
[08:57] *** ghostlines joined
[09:04] * masak .oO( lizmat in Helsinki context )

[09:08] *** abraxxa joined
[09:10] *** Exodist left
[09:11] <masak> wow, Perl 5, you horrible wonderful language. :)

[09:11] * masak is using it at $work

[09:12] <JimmyZ> guess which language is used at my work :P

[09:13] * masak hopes it's not Perl 4

[09:13] *** Exodist joined
[09:13] <JimmyZ> No, it's modern language

[09:14] <masak> I can't believe no-one ever bothered to implement variable-length lookbehind in the Perl 5 regex engine.

[09:14] <masak> I mean, it's not *every* day I need it... but when I need it, I really need it.

[09:14] <masak> and the workarounds are painful.

[09:14] <nwc10> masak: have you looked at the source code?

[09:14] <nwc10> I don't think that "bothered" is the right word

[09:15] <masak> heh.

[09:15] <masak> I have looked at the source code. but it's been a while.

[09:17] *** rindolf joined
[09:24] *** fhelmberger joined
[09:26] <moritz> masak: not always, but often \K is a good workaround

[09:26] <moritz> (available in 5.10+)

[09:26] * masak checks out K

[09:26] <moritz> p5's \K is like p6's <(

[09:26] <masak> ooh

[09:30] *** |Tux| left
[09:32] *** TuxCM joined
[09:32] <moritz> very handy in substitutions and the like

[09:35] *** ab5tract joined
[09:36] *** ab5tract left
[09:36] <smls> masak: the (*SKIP)(*FAIL) backtracking control verbs can also be used in Perl 5 for solving *some* usecases that one would ideally use variable-length-lookbehind for

[09:36] *** Mouq left
[09:45] <timotimo> o/

[09:45] <yoleaux> 08:17Z <jnthn> timotimo: Yes, we don't merge the dominance trees when inlining

[09:45] <yoleaux> 08:18Z <jnthn> timotimo: It's rather possible we should...EA will need it, at least...

[09:47] <JimmyZ> morning, timotimo :)

[09:48] <timotimo> hello JimmyZ 

[09:50] *** kaleem_ joined
[09:51] <JimmyZ> timotimo: Eliminating stack allocations in C/C++ is done with an

[09:52] <JimmyZ> sorry

[09:52] *** tinyblak_ left
[09:52] *** Mso150 joined
[09:54] *** tinyblak joined
[09:54] <smls> $ perl -E 'say join ",", "foo11 22 bar33 !44" =~ /[a-z]+ \K \d+/xg'   # only numbers that are preceded by a word

[09:54] <smls> 11,33

[09:55] <smls> $ perl -E 'say join ",", "foo11 22 bar33 !44" =~ /[a-z]+ \d+ (*SKIP)(*FAIL) | \d+/xg'   # only numbers that are NOT preceded by a word

[09:55] <smls> 22,44

[09:55] <smls> ^^ masak: poor-man's variable-length lookbehind (positive & negative) in Perl 5

[09:59] <moritz> it might become more complicated if the look-behind is supposed to overlap with something that should match

[10:03] *** espadrine` joined
[10:06] *** exixt is now known as exixt_

[10:08] *** ptc_p6 joined
[10:09] *** zakharyas left
[10:14] *** pecastro joined
[10:15] *** ptc_p6 left
[10:15] *** ptc_p6 joined
[10:16] <masak> in my case it isn't, so the above might work.

[10:17] <masak> still, the above solutions might be adequate workarounds, but they still feel like a "poor man's Perl 6 regexes".

[10:17] <timotimo> i'm glad we have better features than pcre in basic stuff ... our performance ought to improve a bit still ... i think i'm starting to sound like a broken record :)

[10:19] <masak> it's fine to repeat stuff that's important :)

[10:19] * masak .oO( <ballmer>performance performance performance</ballmer> )

[10:19] <timotimo> yeah, kinda :)

[10:23] *** someanon joined
[10:23] <someanon> guys help me pls

[10:23] <someanon> hi to all

[10:23] <someanon> perl6 -v: This is perl6 version 2014.09 built on MoarVM version 2014.09

[10:24] <someanon> > my @c = map { { input => $_, asd => 123 } }, 0..2

[10:24] <someanon> does not works as expcted

[10:24] <someanon> *work

[10:24] <moritz> m: my @c = map { { input => $_, asd => 123 } }, 0..2; say @c.perl

[10:24] <camelia> rakudo-moar f8f6fe: OUTPUT«Array.new("input" => 0, "asd" => 123, "input" => 1, "asd" => 123, "input" => 2, "asd" => 123)␤»

[10:25] <moritz> yes, that looks wrong to me

[10:25] <timotimo> should be itemized, right?

[10:25] <moritz> m: my @c = map {;  { input => $_, asd => 123 } }, 0..2; say @c.perl

[10:25] <camelia> rakudo-moar f8f6fe: OUTPUT«Array.new("input" => 0, "asd" => 123, "input" => 1, "asd" => 123, "input" => 2, "asd" => 123)␤»

[10:25] <moritz> timotimo: aye

[10:25] <someanon> i expect list of hashes

[10:25] <timotimo> yes

[10:25] <moritz> m: my @c = map {; %( input => $_, asd => 123 ).item  }, 0..2; say @c.perl

[10:25] <camelia> rakudo-moar f8f6fe: OUTPUT«Array.new({"input" => 0, "asd" => 123}, {"input" => 1, "asd" => 123}, {"asd" => 123, "input" => 2})␤»

[10:25] <moritz> someanon: that's a workaround

[10:26] <someanon> las one?

[10:26] <moritz> yes

[10:26] <someanon> *last

[10:26] <timotimo> m: (map { { input => $_, asd => 123 }  }, 0..2).perl.say

[10:26] <camelia> rakudo-moar f8f6fe: OUTPUT«(("input" => 0, "asd" => 123), ("input" => 1, "asd" => 123), ("input" => 2, "asd" => 123)).list␤»

[10:26] <moritz> %( ... ).item instead of { }

[10:26] <someanon> oh shee

[10:26] <timotimo> that doesn't create hashes either?

[10:26] * jnthn wonders if it's treated as a bare block

[10:26] <moritz> timotimo: list of parcel

[10:26] <moritz> jnthn: me too

[10:26] <timotimo> could be

[10:26] <someanon> this question for me?

[10:26] <timotimo> { } with $_ inside is a strong sign for "this is a block"

[10:27] <timotimo> someanon: for everybody

[10:27] <jnthn> m: (map { ({ input => $_, asd => 123 }) }, 0..2).perl.say

[10:27] <someanon> ha

[10:27] <camelia> rakudo-moar f8f6fe: OUTPUT«(-> ($_? is parcel) { #`(Block|82458752) ... }, -> ($_? is parcel) { #`(Block|82458816) ... }, -> ($_? is parcel) { #`(Block|82458880) ... }).list␤»

[10:27] <jnthn> Yes, it is.

[10:27] <jnthn> Oh

[10:27] <jnthn> $_ forces the block interpretation

[10:27] <jnthn> That's even spec.

[10:27] <someanon> i saw block

[10:27] <timotimo> right, i seem to recall that

[10:27] <someanon> we need to fix this!

[10:27] <jnthn> Uh

[10:27] <someanon> or

[10:27] <jnthn> Well, it seems like Rakudo is following spec as far as I can see.

[10:28] <someanon> at first i was need to use zip in map

[10:28] <timotimo> m: my @c = map -> $a { { input => $a, asd => 123 }  }, 0..2; say @c.perl

[10:28] <camelia> rakudo-moar f8f6fe: OUTPUT«Array.new({"input" => 0, "asd" => 123}, {"asd" => 123, "input" => 1}, {"input" => 2, "asd" => 123})␤»

[10:28] *** JimmyZ left
[10:28] <someanon> so this hash creation - it is just workaround for zip

[10:28] <someanon> wow

[10:28] <someanon> camelia, good

[10:29] <jnthn> someanon: What's the original problem, out of curiosity?

[10:29] * moritz idly wonders if %{ ... } could be used to force hash and &{...} to force block

[10:29] <someanon> i need somthing like this

[10:30] <someanon> map -> $a, $b {  ...  } <== @a Z @b

[10:30] <moritz> or maybe {% ... } and {& ... } to not give the impression that it de-itemizes

[10:30] <someanon> or maybe zipBy function like in haskell

[10:31] <someanon> it will be greate if perl6 will implement most of haskell list operations

[10:32] <someanon> jnthn, so dat list of hashes it is just workaround for zipBy

[10:32] <jnthn> m: my @a = 1..10; my @b = 'a'..'j'; (@a Z @b).for(-> $a, $b { say "$a $b" })

[10:32] <camelia> rakudo-moar f8f6fe: OUTPUT«1 a␤2 b␤3 c␤4 d␤5 e␤6 f␤7 g␤8 h␤9 i␤10 j␤»

[10:32] <timotimo> m: my @a = <one two three four>; my @b = <eins zwei drei vier>; say (@a Z=> @b).perl

[10:32] <camelia> rakudo-moar f8f6fe: OUTPUT«("one" => "eins", "two" => "zwei", "three" => "drei", "four" => "vier").list␤»

[10:32] <someanon> can for return list?

[10:32] <jnthn> Sure

[10:32] <timotimo> yes, you often have to write "do" before it

[10:33] <jnthn> m: my @a = 1..10; my @b = 'a'..'j'; (@a Z @b).for(-> $a, $b { ($b, $a) }).flat.say

[10:33] <camelia> rakudo-moar f8f6fe: OUTPUT«a 1 b 2 c 3 d 4 e 5 f 6 g 7 h 8 i 9 j 10␤»

[10:33] <someanon> nice!

[10:33] <someanon> and i have one more question

[10:34] *** kaleem_ left
[10:34] <someanon> why can't i do sub (Int :$int-param) { ... }

[10:34] <someanon> ?

[10:34] *** kaleem joined
[10:34] <timotimo> someanon: write "anon sub" or "sub :: (...)"

[10:34] <someanon> no

[10:34] <jnthn> m: sub (Int :$int-param) { }

[10:34] <camelia> rakudo-moar f8f6fe: ( no output )

[10:35] <jnthn> Can you be a bit clearer on what exactly you can't do? :)

[10:35] <someanon> jnthn, you got it?

[10:35] <someanon> i need typed named parameter

[10:35] <someanon> not just typed or named

[10:35] <jnthn> m: sub foo(Int :$int-param) { }; foo(int-param => 42)

[10:35] <camelia> rakudo-moar f8f6fe: ( no output )

[10:35] <jnthn> m: sub foo(Int :$int-param) { }; foo(int-param => 'omg')

[10:35] <camelia> rakudo-moar f8f6fe: OUTPUT«Type check failed in binding $int-param; expected 'Int' but got 'Str'␤  in sub foo at /tmp/rA1ffNPJif:1␤  in block <unit> at /tmp/rA1ffNPJif:1␤␤»

[10:36] <someanon> hm

[10:36] <someanon>  m: sub foo(Int :$int-param=10) {  say $int-param }; foo()

[10:36] <camelia> rakudo-moar f8f6fe: OUTPUT«10␤»

[10:37] <someanon>  m: sub foo(Int :$int-param=10) {  say $int-param }; foo(); foo(123)

[10:37] <camelia> rakudo-moar f8f6fe: OUTPUT«10␤Too many positionals passed; expected 0 arguments but got 1␤  in sub foo at /tmp/xakB9Bcpvn:1␤  in block <unit> at /tmp/xakB9Bcpvn:1␤␤»

[10:37] <someanon>  m: sub foo(Int :$int-param=10) {  say $int-param }; foo(); foo(int-param => 123)

[10:37] <camelia> rakudo-moar f8f6fe: OUTPUT«10␤123␤»

[10:37] <someanon>  m: sub foo(Int :$int-param=10) {  say $int-param }; foo(); foo(:int-param(123))

[10:37] <camelia> rakudo-moar f8f6fe: OUTPUT«10␤123␤»

[10:37] <someanon> hmhmhmh

[10:37] <someanon> what version of your perl6?

[10:38] <jnthn> Note that named params are optional by default... If you wnat foo() to complain, write it as sub foo(Int :$int-param!) { }

[10:38] <someanon> yes, i know

[10:38] <jnthn> someanon: The f8f6fe is the git sha-1 of the running version

[10:38] <someanon> how to get my sha-1?

[10:38] <jnthn> Looks like from yesterday

[10:39] <jnthn> Try --version

[10:39] <someanon> This is perl6 version 2014.09 built on MoarVM version 2014.0

[10:39] <someanon> i already wrote at top

[10:39] <jnthn> Ah, it's a relesae build, so no sha-1

[10:39] <jnthn> But still, a recent one.

[10:39] <timotimo> 2014.0 is so old! ;)

[10:40] <someanon> maybe it is better to use most last?

[10:40] <jnthn> Well, recenter is usually better. but 2014.09 is less than 2 months old.

[10:40] <timotimo> in some ways, development happens very fast and changes between monthly releases are big

[10:40] <someanon> jnthn, timotimo sad that moarvm too old

[10:41] <timotimo> that was a stupid joke

[10:41] <someanon> whats your moarvm version?

[10:41] <timotimo> because the 9 from the very end was cut off

[10:41] <jnthn> someanon: Yes, I think you missed a digit :)

[10:41] <someanon> ah ok

[10:41] <someanon> ok, i have one more question

[10:41] <jnthn> I don't know exactly which version the but is running..but probably a pretty recent one (like, within last days)

[10:42] <timotimo> m: say $*VM<version>.perl

[10:42] <camelia> rakudo-moar f8f6fe: OUTPUT«Failure.new(exception => X::AdHoc.new(payload => "postcircumfix:<\{ }> not defined for type VM"))␤»

[10:42] <someanon> i will try ot make code right away

[10:42] <timotimo> m: say $*VM.perl

[10:42] <camelia> rakudo-moar f8f6fe: OUTPUT«VM.new(config => {"staticdir" => "lib", "nul" => "/dev/null", "ccswitch" => "-c", "versionmajor" => "2014", "shaobjects" => "3rdparty/sha1/sha1.o", "dcobjects" => "", "static_inline" => "static __inline__", "dlobjects" => "", "uvlib" => "3rdparty/libuv/lib…»

[10:42] <timotimo> m: say $*VM.config.keys

[10:42] <camelia> rakudo-moar f8f6fe: OUTPUT«ccdef moarlib ccwarnflags name dlllocal ldrpath cflags moar shaobjects ldimp ldmiscflags dllib auxclean sharedlib lddebugflags cincludes cppswitch prefix ldinstflags ccshared ldlibs tomclean ldusr obj arout osname nul platform ccout ld dllexport ccmiscflag…»

[10:42] <timotimo> so many things in that hash

[10:43] <jnthn> m: say $*VM.config.keys.grep(/ver/)

[10:43] <camelia> rakudo-moar f8f6fe: OUTPUT«osvers versionpatch versionmajor versionminor version␤»

[10:43] <someanon> m: my $a = sub (Num $b) { say $b }; $a(0.1)

[10:43] <camelia> rakudo-moar f8f6fe: OUTPUT«Type check failed in binding $b; expected 'Num' but got 'Rat'␤  in sub  at /tmp/aOQmyBdzox:1␤  in block <unit> at /tmp/aOQmyBdzox:1␤␤»

[10:43] <timotimo> ah

[10:43] <someanon> wow

[10:43] <timotimo> m: say $*VM.config<version>

[10:43] <camelia> rakudo-moar f8f6fe: OUTPUT«2014.10-17-g05b25a6␤»

[10:43] <someanon> do you see bug?

[10:43] <timotimo> someanon: you may want to use Real rather than Num?

[10:43] <someanon> maybe

[10:43] <someanon> m: my $a = sub (Real $b) { say $b }; $a(0.1)

[10:43] <camelia> rakudo-moar f8f6fe: OUTPUT«0.1␤»

[10:43] <someanon> hm

[10:43] <jnthn> Num = floating point

[10:43] <jnthn> m: say 0.1.WHAT

[10:43] <camelia> rakudo-moar f8f6fe: OUTPUT«(Rat)␤»

[10:43] <timotimo> m: sub a(Cool(Num) $b) { say $b.perl }; a(0.1)

[10:44] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/UK16G8u3Nc␤coercive type declarations not yet implemented. Sorry. ␤at /tmp/UK16G8u3Nc:1␤------> [32msub a(Cool(Num)[33m⏏[31m $b) { say $b.perl }; a(0.1)[0m␤»

[10:44] <jnthn> m: say 0.1e0.WHAT

[10:44] <camelia> rakudo-moar f8f6fe: OUTPUT«(Num)␤»

[10:44] <timotimo> m: sub a(Cool as Num $b) { say $b.perl }; a(0.1)

[10:44] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/aGdwVCBBCp␤Missing block␤at /tmp/aGdwVCBBCp:1␤------> [32msub a(Cool as Num [33m⏏[31m$b) { say $b.perl }; a(0.1)[0m␤    expecting any of:␤        statement list␤        prefix or t…»

[10:44] <timotimo> i thought we had that by now

[10:44] <jnthn> 0.1 isn't floating point in Perl 6, but rather a rational number

[10:44] <jnthn> timotimo: Cool $b as Num

[10:44] <timotimo> ah

[10:44] <timotimo> so that's how you spell that

[10:44] <someanon> jnthn, i guessed

[10:44] <jnthn> But yeah, Real or Numeric are the more general numeric types

[10:45] <someanon> Cool means cast?

[10:45] <jnthn> Roles, to be specific.

[10:45] <timotimo> Cool means "things that will cast themselves for you with most methods"

[10:45] <timotimo> m: say String ~~ Cool

[10:45] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/afUlussBP4␤Undeclared name:␤    String used at line 1. Did you mean 'Stringy'?␤␤»

[10:45] <timotimo> m: say Str ~~ Cool

[10:45] <camelia> rakudo-moar f8f6fe: OUTPUT«True␤»

[10:45] <someanon> timotimo, nice

[10:45] <timotimo> so there are methos on Str that make sense only for numbers

[10:45] <timotimo> m: say "100".sin

[10:45] <camelia> rakudo-moar f8f6fe: OUTPUT«-0.506365641109759␤»

[10:46] <timotimo> m: say "100".conj

[10:46] <camelia> rakudo-moar f8f6fe: OUTPUT«100␤»

[10:46] <timotimo> m: say "100+5i".conj

[10:46] <camelia> rakudo-moar f8f6fe: OUTPUT«100-5i␤»

[10:46] <someanon> m: my $a = sub (Array Real @b) { say @b }; $a([0.1, 0.2])

[10:46] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/g7v5Ecg2_g␤A parameter may only have one prefix type constraint␤at /tmp/g7v5Ecg2_g:1␤------> [32mmy $a = sub (Array Real [33m⏏[31m@b) { say @b }; $a([0.1, 0.2])[0m␤    expecting any of…»

[10:46] <someanon> how to make typed array?

[10:46] <timotimo> if you require a parameter to "be Cool", you'll get a value that you can treat as many different things without casting manually

[10:46] <timotimo> write just "Real @b"

[10:47] <timotimo> m: my Real @a; say @a.perl

[10:47] <camelia> rakudo-moar f8f6fe: OUTPUT«Array[Real].new()␤»

[10:47] <timotimo> the "Array of TheTypeGiven" is done for you when you choose the @sigil

[10:50] <someanon> one more question=)

[10:50] <timotimo> sure, go ahead :)

[10:51] <moritz> (but don't use typed arrays, they only cause sorrow)

[10:52] <someanon> moritz, why?

[10:52] <moritz> m: sub f(Int @a) { say @a.perl }; f [1, 2, 3]

[10:52] <camelia> rakudo-moar f8f6fe: OUTPUT«Type check failed in binding @a; expected 'Positional[Int]' but got 'Array'␤  in sub f at /tmp/JcKPHhWHJJ:1␤  in block <unit> at /tmp/JcKPHhWHJJ:1␤␤»

[10:52] <timotimo> correct, the "type check" doesn't implicitly "distribute"

[10:52] <moritz> this fails, because [] just returns an Array, not Array[Int]

[10:52] <jnthn> Well, if you're going to use typed arrays, you need to use them consistently...

[10:52] <someanon>  f(Cold(Int) @a) { say @a.perl }; f [1, 2, 3]

[10:52] <someanon> m: f(Cold(Int) @a) { say @a.perl }; f [1, 2, 3]

[10:52] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/re5FXmeFQE␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/re5FXmeFQE:1␤------> [32mf(Cold(Int) [33m⏏[31m@a) { say @a.perl }; f [1, 2, 3][0m␤    expecting…»

[10:53] <moritz> and this makes working with them quite unpleasant

[10:53] <someanon> m: f(Int @a) { say @a.perl }; f Int([1, 2, 3])

[10:53] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/h9UQTvufUv␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/h9UQTvufUv:1␤------> [32mf(Int [33m⏏[31m@a) { say @a.perl }; f Int([1, 2, 3])[0m␤    expecting …»

[10:53] <timotimo> true ... and in rakudo you don't even get better performance if your stuff is typed thoroughly

[10:53] <jnthn> Well, you do for native types...

[10:53] <timotimo> definitely true

[10:53] <jnthn> But you can't do those on arrays *yet*. :)

[10:53] <timotimo> and with native shaped arrays... yeah!

[10:53] <someanon> i just lazy to validate myself

[10:53] <timotimo> looking forward to that :)

[10:54] <someanon> m: my @a[10;10]

[10:54] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/DnS_cL6_TM␤Shaped variable declarations not yet implemented. Sorry. ␤at /tmp/DnS_cL6_TM:1␤------> [32mmy @a[10;10][33m⏏[31m<EOL>[0m␤»

[10:54] <someanon> =(

[10:54] <someanon> look here

[10:54] <someanon> http://pastebin.com/ZdhqF1EZ

[10:54] <someanon> class declaration

[10:54] <timotimo> jnthn: just to be clear, "Native Shaped Arrays" means both native arrays and shaped arrays and the combination of both?

[10:54] <someanon> do you big constructor

[10:55] <someanon> can i make it less?

[10:55] <timotimo> yes

[10:55] <someanon> *do you see

[10:55] <timotimo> you get a constructor for free when you build a class

[10:55] <timotimo> you can get pretty error messages by setting a default value that'll throw when evaluated

[10:55] <timotimo> like this:

[10:56] <timotimo> m: class Something { has $.required = die "you have to supply the required parameter" }; Something.new

[10:56] <camelia> rakudo-moar f8f6fe: OUTPUT«you have to supply the required parameter␤  in method  at /tmp/XbBbrwslp5:1␤  in block  at src/gen/m-CORE.setting:1000␤  in method BUILDALL at src/gen/m-CORE.setting:955␤  in method bless at /home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.…»

[10:56] <timotimo> m: class Something { has $.required = die "you have to supply the required parameter" }; Something.new(required => "here you go").perl.say

[10:56] <camelia> rakudo-moar f8f6fe: OUTPUT«Something.new(required => "here you go")␤»

[10:56] <timotimo> you don't have to write "is readonly", because that's the default

[10:56] <timotimo> if you write has &.activation-function instead of has $.activation-function, you get the proper type check for free

[10:57] <timotimo> and you can use "where" clauses to do the range checking, too

[10:57] <timotimo> let's see ..

[10:57] <someanon> timotimo, i have one in declaration -> look at Code

[10:58] <timotimo> someanon: well, i'm going to show you how to completely get rid of the 'new' method :)

[10:58] <someanon> yes yes

[10:58] <someanon> that is what i want

[10:58] <timotimo> m: class HasProbability { has Real $.prob where 0..1 = die "give me a probability please" }; HasProbability.new(prob => 0.5).perl.say

[10:58] <camelia> rakudo-moar f8f6fe: OUTPUT«HasProbability.new(prob => 0.5)␤»

[10:58] <someanon> i spend around 3 hours to make this constructor work

[10:58] <timotimo> m: class HasProbability { has Real $.prob where 0..1 = die "give me a probability please" }; HasProbability.new(prob => 1.5).perl.say

[10:58] <camelia> rakudo-moar f8f6fe: OUTPUT«HasProbability.new(prob => 1.5)␤»

[10:59] <timotimo> oh, i seem to recall we don't use these where clauses yet >_<

[10:59] <timotimo> but

[10:59] <someanon> and i'm sure, that there is one more way to that

[10:59] <timotimo> m: subset Probability of Real where 0..1; class HasProbability { has Probability $.prob = die "give me a probability please" }; HasProbability.new(prob => 1.5).perl.say

[10:59] <camelia> rakudo-moar f8f6fe: OUTPUT«Type check failed in assignment to '$!prob'; expected 'Probability' but got 'Rat'␤  in block  at src/gen/m-CORE.setting:972␤  in method BUILDALL at src/gen/m-CORE.setting:955␤  in method bless at /home/camelia/rakudo-inst-1/languages/perl6/runtime/CO…»

[10:59] <timotimo> m: subset Probability of Real where 0..1; class HasProbability { has Probability $.prob = die "give me a probability please" }; HasProbability.new(prob => 0.5).perl.say

[10:59] <camelia> rakudo-moar f8f6fe: OUTPUT«HasProbability.new(prob => 0.5)␤»

[10:59] <timotimo> m: subset Probability of Real where 0..1; class HasProbability { has Probability $.prob = die "give me a probability please" }; HasProbability.new().perl.say

[10:59] <camelia> rakudo-moar f8f6fe: OUTPUT«give me a probability please␤  in method  at /tmp/ATATQPhKLU:1␤  in block  at src/gen/m-CORE.setting:1000␤  in method BUILDALL at src/gen/m-CORE.setting:955␤  in method bless at /home/camelia/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarv…»

[10:59] <timotimo> there we go.

[10:59] <Ulti> is there not a version of slurp that has no arguments like lines?

[10:59] <timotimo> with a subset type you can do that properly

[11:00] <timotimo> Ulti: like "slurp all argfiles"?

[11:00] <timotimo> m: say slurp

[11:00] <camelia> rakudo-moar f8f6fe: OUTPUT«set encoding requires an object with REPR MVMOSHandle␤  in method encoding at src/gen/m-CORE.setting:15837␤  in method slurp-rest at src/gen/m-CORE.setting:15792␤  in sub slurp at src/gen/m-CORE.setting:16540␤  in block <unit> at /tmp/gkbVnMN_RF:1…»

[11:00] <Ulti> yeah

[11:00] <timotimo> oh my

[11:00] <Ulti> yeah thats what I get locally

[11:00] <timotimo> this seems new

[11:00] <Ulti> yeah

[11:00] <timotimo> star: say slurp

[11:00] <camelia> star-{m,p} 2014.09: OUTPUT«Céad slán ag sléibhte maorga Chontae Dhún na nGall␤Agus dhá chéad slán ag an Eireagal ard ina stua os cionn caor is coll;␤Nuair a ghluais mise thart le Loch Dhún Lúich’ go ciúin sa ghleann ina luí␤I mo dhiaidh bhí gleanntáin ghlas’ G…»

[11:00] <Ulti> :'[

[11:00] <Ulti> guess going through helping to improve these perl6 one liners was worth it

[11:01] <timotimo> yes!

[11:01] <timotimo> why we don't have a test for that I do not know

[11:01] <timotimo> we really ought to

[11:01] <Ulti> actually I get a deprecation message posted on the end of that timotimo

[11:02] <someanon> you guys are best

[11:02] <someanon> thanx

[11:02] <Ulti> slurp($handle,...) now going to slurp($path,...)

[11:02] <Ulti> so might be it's calling another form of slurp with a handle and that's been changed

[11:04] *** ggoebel111111119 joined
[11:06] <timotimo> ah

[11:06] <timotimo> i remember about that

[11:06] <timotimo> yeah, we were saying "slurp on an open file handle doesn't make sense"

[11:06] <timotimo> but we didn't think of argfiles yet

[11:06] <timotimo> (at that point)

[11:07] <Ulti> why doesnt slurp on an open file handle make sense? you might want to move past a few bytes then slurp the rest

[11:07] *** ggoebel111111118 left
[11:08] <timotimo> because: does it close the file handle at the end? does it move the file pointer back to where it was if it does not close it?

[11:08] <Ulti> I'd assume it would move the pointer and not close the file

[11:08] <timotimo> well, slurp on a path opens, reads and closes

[11:09] <timotimo> so is that inconsistent? :)

[11:09] <Ulti> yeah because one of them I am handing it a path and expecting a lot more magic

[11:09] <Ulti> dunno

[11:10] <Ulti> also what does slurp do on a socket or a pipe anyway?

[11:10] <timotimo> collapse your world view into a smolding heap of ash

[11:10] <Ulti> :3 Perl6 does that a lot

[11:15] <Ulti> "Failed to seek in filehandle: 29" is what happens when an argfile is a named pipe :S

[11:15] *** telex left
[11:15] <timotimo> yeah, you can't seek ... and we probably shouldn't rely on that

[11:16] <timotimo> if we can't seek, that just means we have to re-allocate our buffer every now and then to make sure the new incoming data fits

[11:16] <Ulti> yeah it explodes in a nasty way rather than saying something kind

[11:16] <Ulti> perl6 -ne 'say "$_ is prime" if $_.Int.is-prime' <( echo 7) 

[11:16] *** telex joined
[11:17] <timotimo> 7 is prime

[11:17] <timotimo> oh, wait

[11:17] <timotimo> that's not what my code does

[11:20] *** Mouq joined
[11:25] *** Mouq left
[11:31] *** bbkr_ joined
[11:55] *** leont joined
[12:02] *** Ugator joined
[12:03] *** beastd joined
[12:04] *** Mso150 left
[12:09] <moritz> Failed to stat in filehandle: no such file or directory

[12:10] <moritz> that's what I get

[12:10] <timotimo> then your shell does something different :)

[12:17] <smls> I get the same error as moritz - both with bash and zsh - using Rakudo+Moar 2014.09.

[12:21] *** JimmyZ joined
[12:21] <timotimo> oh

[12:26] <someanon> what does perl6 have for testing purposes? Only Test module?

[12:26] *** ghostlines left
[12:27] *** ghostlines joined
[12:27] <timotimo> there is Test::Utils or what's it called?

[12:27] <timotimo> oh, that's only inside the spec test suite

[12:27] <timotimo> there's a few modules for testing on modules.perl6.org

[12:27] <someanon> thanx

[12:28] <someanon> m: use Test; ok 1

[12:28] <camelia> rakudo-moar f8f6fe: OUTPUT«ok 1 - ␤»

[12:28] *** raiph joined
[12:28] <timotimo> don't forget plan and/or done

[12:28] <someanon> does perl6 have something similar to perl-doc?

[12:28] <timotimo> we do have p6doc, but it's not as grand as perl-doc yet

[12:29] <someanon> would it have?

[12:31] <someanon> I saw throw function and Exception class

[12:32] <someanon> will the be implemented in Rakudo?

[12:32] <someanon> *they

[12:32] <jnthn> Exception class is

[12:32] <jnthn> throw is a method on exceptions

[12:32] <someanon> and catch and similar things

[12:32] <timotimo> that has been implemented for a very long time already

[12:32] <jnthn> m: try { die 'OH NO I WAS STABBED'; CATCH { default { say 'phew!' } } }

[12:32] <camelia> rakudo-moar f8f6fe: OUTPUT«phew!␤»

[12:33] <someanon> so i should use CATCH to catch now?

[12:33] <jnthn> That's untyped (ad-hoc) exception

[12:33] <jnthn> Yes, and it goes inside the scope where you're catching.

[12:33] <jnthn> Not outside of it

[12:33] <someanon> but if i want outside?

[12:33] <jnthn> and doesn't actually have to be paired with try

[12:34] <someanon> it just shortcut to perl5 eval { .. }; if($@) { } yeah?

[12:34] <timotimo> no

[12:35] <timotimo> at least: i don't think so

[12:35] <someanon> i tried to make custom Exception class

[12:35] <someanon> should i use Exception before?

[12:35] <someanon> m: use Exception;

[12:35] <camelia> rakudo-moar f8f6fe: OUTPUT«===SORRY!===␤Could not find Exception in any of: /home/camelia/rakudo-inst-1/languages/perl6/lib, /home/camelia/rakudo-inst-1/languages/perl6␤»

[12:35] <timotimo> custom exception classes are often favorable

[12:36] *** tinyblak left
[12:36] <timotimo> m: class MyExplosion is Exception { }; die MyExplosion.new; CATCH { say $_.perl }

[12:36] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/9GvRhE9qlp:1␤␤»

[12:36] <someanon> hm

[12:36] <timotimo> or something

[12:36] *** tinyblak joined
[12:36] <timotimo> :P

[12:36] <someanon> i tried yesterday

[12:36] <someanon> it dies

[12:36] <timotimo> m: class MyExplosion is Exception { }; MyExplosion.new.throw; CATCH { say $_.perl }

[12:36] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/sTOAVJxaM5:1␤␤»

[12:36] <someanon> very strange

[12:37] <timotimo> m: class MyExplosion is Exception { }; MyExplosion.new.throw; CATCH { default { say $_.perl } }

[12:37] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/LECbzzpvAo:1␤␤»

[12:37] <timotimo> oh

[12:37] <timotimo> maybe exception handling is a bit weird in the REPL?

[12:37] <someanon>  m: class MyExplosion is Exception { }; MyExplosion.new.throw('babah'); CATCH { say $_ }

[12:37] <camelia> rakudo-moar f8f6fe: OUTPUT«Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at /tmp/4wWgyAS72e:1␤␤»

[12:37] *** kaleem left
[12:38] <jnthn> m: class MyExplosion is Exception { }; MyExplosion.new.throw; CATCH { default { say "caught {$_.WHAT}" } }

[12:38] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/ZSjXAwDwQj:1␤␤»

[12:38] <someanon>  m: class MyExplosion is Exception { }; MyExplosion.new.throw(message => 'babah'); CATCH { say $_ }

[12:38] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/BsZtSjHxQe:1␤␤»

[12:38] <jnthn> m: { class MyExplosion is Exception { }; MyExplosion.new.throw; CATCH { default { say "caught {$_.WHAT}" } } }

[12:38] <camelia> rakudo-moar f8f6fe: OUTPUT«use of uninitialized value of type MyExplosion in string context  in block  at /tmp/cfptdkvQNG:1␤␤caught ␤»

[12:38] <jnthn> m: { class MyExplosion is Exception { }; MyExplosion.new.throw; CATCH { default { say "caught {.^name}" } } }

[12:38] <camelia> rakudo-moar f8f6fe: OUTPUT«caught MyExplosion␤»

[12:38] <someanon> wow

[12:38] <someanon> this like interpolation works now

[12:38] <jnthn> Note you can look for special-case exceptions too

[12:38] <someanon> didn't know

[12:39] <jnthn> m: { class MyExplosion is Exception { }; MyExplosion.new.throw; CATCH { when MyExplosion { say "caught" } } }

[12:39] <camelia> rakudo-moar f8f6fe: OUTPUT«caught␤»

[12:39] <timotimo> outermost scope is a bit weird, eh?

[12:39] <jnthn> m: { class MyExplosion is Exception { }; die 'something else'; CATCH { when MyExplosion { say "caught" } } }

[12:39] <camelia> rakudo-moar f8f6fe: OUTPUT«something else␤  in block <unit> at /tmp/xaY41i_FVo:1␤␤»

[12:39] <jnthn> timotimo: Yeah, seems so...I know that was is ticketed too

[12:40] <someanon> so not working outer CATCH - it is a bug?

[12:40] <jnthn> Yes

[12:41] <someanon>  m: class MyExplosion is Exception { }; MyExplosion.new.throw(message => 'babah'); CATCH { say $_ }

[12:41] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/3khEltLxTC:1␤␤»

[12:41] <someanon>  m: class MyExplosion is Exception { }; MyExplosion.new.throw(message => 'babah'); CATCH { default { say $_ } }

[12:41] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/Nkyh6IRb0J:1␤␤»

[12:41] <timotimo> i suppose we install CATCH handlers on blocks, and if there's no { } around your program there's no block to install the handler on?

[12:42] <timotimo> (random idea)

[12:42] <someanon>  m: {  class MyExplosion is Exception { }; MyExplosion.new.throw(message => 'babah'); CATCH { MyExplosion { say $_ } } }

[12:42] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/KpiZPqulCQ␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)␤at /tmp/KpiZPqulCQ:1␤------> [32message => 'babah'); CATCH { MyExplosion [33m⏏…»

[12:42] <someanon>  m: {  class MyExplosion is Exception { }; MyExplosion.new.throw(message => 'babah'); CATCH { when MyExplosion { say $_ } } }

[12:42] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/t4Cyen83AU:1␤␤»

[12:44] <jnthn> Think the message => needs to go to new

[12:44] <timotimo> yes

[12:44] <someanon>  m: {  class MyExplosion is Exception { }; MyExplosion.new(message => 'babah').throw(); CATCH { when MyExplosion { say $_ } } }

[12:44] <camelia> rakudo-moar f8f6fe: OUTPUT«␤  in block <unit> at /tmp/XwH9KtDXzB:1␤␤»

[12:44] <someanon> nothing

[12:45] <someanon> do you see http://www.perl8.org/

[12:45] <someanon> now it starts to converge

[12:46] <timotimo> m: class MyExplosion is Exception { }; say MyExplosion.^attributes

[12:46] <camelia> rakudo-moar f8f6fe: OUTPUT«Mu $!ex␤»

[12:46] <moritz> m: {  class MyExplosion is Exception { method message() { 'Dead, Jim' } }; MyExplosion.new(message => 'babah').throw(); CATCH { when MyExplosion { say $_ } } }

[12:46] <camelia> rakudo-moar f8f6fe: OUTPUT«Dead, Jim␤  in block <unit> at /tmp/9ataeGRANf:1␤␤»

[12:46] <moritz> someanon: Exception doesn't have an attribute 'message'

[12:46] <timotimo> message is not an attribute by default, you are expected to give your exception meaningful attributes and generate a message from them with a "message" method

[12:47] <someanon> oh, i got

[12:47] <someanon> i saw that attribute in example that i found in google

[12:48] <moritz> someanon: do you still have the link?

[12:48] <moritz> (maybe it's something we can update)

[12:50] <someanon> http://www.perl6.org/archive/rfc/63.html

[12:50] <someanon> i think you can't

[12:50] <someanon> >This file is part of the Perl 6 Archive

[12:50] *** kaleem joined
[12:50] <moritz> I could, but I won't :-)

[12:51] <someanon> haha

[12:51] <someanon> i tried like in example with MyDB

[12:52] <moritz> https://github.com/perl6/perl6.org/blob/master/source/archive/rfc/63.html # here are the sources

[12:52] <someanon> so now it is not special syntax, just Classes on top of die

[12:54] <moritz> yes

[12:54] <moritz> I wasn't creative enough for anything else :-)

[12:56] *** anaeem1_ left
[12:56] <someanon> so classes everywhere now

[12:57] <someanon> i'm not perl6 spec expert, is there something like rich type system like in haskell?

[12:57] <someanon> we have classes now like in java

[12:57] <someanon> so we need types like in haskell

[12:58] <someanon> and currying

[12:58] <someanon> implicit ones

[12:58] <timotimo> we have parameterized roles

[12:58] <timotimo> and type captures

[13:01] <someanon> parameterize roles looks interesting

[13:01] <someanon> type captures means multi keyword?

[13:01] <someanon> *using multi subs

[13:03] <JimmyZ> rfc 88 is so loooooooong

[13:27] *** brrt joined
[13:29] *** kaleem_ joined
[13:29] *** guru joined
[13:29] <daxim> http://arxiv.org/pdf/1302.2837v2.pdf  # Benchmarking Usability and Performance of Multicore Languages   (via hn)

[13:29] *** guru is now known as Guest25891

[13:29] *** Guest25891 is now known as ajr_

[13:30] <jnthn> someanon: No, probably ::T syntax

[13:30] <jnthn> m: sub foo(::T $x) { say "$x is a {T.^name}" }; foo(1); foo('lol')

[13:30] <camelia> rakudo-moar f8f6fe: OUTPUT«1 is a Int␤lol is a Str␤»

[13:31] <someanon> hm

[13:31] <someanon> later in perl5 there was ref

[13:31] <someanon> i can't see any think cool in this

[13:32] <someanon> jnthn, but i found solution for my first question

[13:32] <someanon> m:  map -> $a, $b { say $a~$b }, (1..5 Z 'a'..'e')

[13:32] <camelia> rakudo-moar f8f6fe: OUTPUT«1a␤2b␤3c␤4d␤5e␤»

[13:32] <jnthn> m: say (1..5 Z~ 'a'..'e')

[13:32] <camelia> rakudo-moar f8f6fe: OUTPUT«1a 2b 3c 4d 5e␤»

[13:32] <moritz> you can have that even shorter: .say for 1..5 Z~ 'a'..'e'

[13:32] * moritz too slow

[13:32] <jnthn> m: .say for 1..5 Z~ 'a'..'e'

[13:32] <camelia> rakudo-moar f8f6fe: OUTPUT«1a␤2b␤3c␤4d␤5e␤»

[13:32] <someanon> it is just example

[13:32] <someanon> concat

[13:32] *** kaleem left
[13:33] <someanon> i need to do more complex things

[13:34] <someanon> -> $a, $b - is it sugar for sub ($a, $b) ?

[13:36] <moritz> nearly

[13:36] <smls> m: say (-> $a, $b {...}).WHAT; say (sub ($a, $b) {...}).WHAT

[13:36] <camelia> rakudo-moar f8f6fe: OUTPUT«(Block)␤(Sub)␤»

[13:36] <moritz> the difference is that -> ... introduces a block, and sub a routine

[13:36] <moritz> and blocks are transparent to return()

[13:36] <moritz> m: sub f() { my $block = -> { return 42 }; $block(); return 23 }; say f

[13:36] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[13:37] * moritz notices that's an FAQ

[13:37] <smls> m: say Sub.^mro

[13:37] <camelia> rakudo-moar f8f6fe: OUTPUT«(Sub) (Routine) (Block) (Code) (Any) (Mu)␤»

[13:37] <someanon> wow, cool

[13:39] <someanon> block more generic

[13:39] <someanon> it's logical

[13:44] *** lucas__ joined
[13:45] <smls> Another thing I'm finding more elegant in Perl 6 (compared to Perl 5): Inflecting words when printing output.

[13:45] <smls> m: for 0..2 -> $n { say "Wrote $n line{"s" if $n != 1} so far." }

[13:45] <camelia> rakudo-moar f8f6fe: OUTPUT«Wrote 0 lines so far.␤Wrote 1 line so far.␤Wrote 2 lines so far.␤»

[13:45] <lucas__> m: say yes => True

[13:45] <camelia> rakudo-moar f8f6fe: OUTPUT«Unexpected named parameter 'yes' passed␤  in sub say at src/gen/m-CORE.setting:16447␤  in block <unit> at /tmp/vZ4_m_s3DY:1␤␤»

[13:46] <lucas__> m: my $x = yes => True; say $x

[13:46] <camelia> rakudo-moar f8f6fe: OUTPUT«"yes" => Bool::True␤»

[13:46] <lucas__> m: say :yes;

[13:46] <camelia> rakudo-moar f8f6fe: OUTPUT«Unexpected named parameter 'yes' passed␤  in sub say at src/gen/m-CORE.setting:16447␤  in block <unit> at /tmp/5aN4beHXTN:1␤␤»

[13:47] <someanon> it's almost html templates like interpolation

[13:47] <someanon> smls, 

[13:49] <someanon> smls, ione can just overload coma string constructor so, that it will work on top of Mojo::Template, i guess

[13:50] *** zakharyas joined
[13:50] <smls> It's made possible by the fact that in Perl 6, {...} provides pretty interpolation of expression inside strings (In Perl 5 one can use @{[...]} but that's ugly), and that «if» statements can be used as expressions (the result of which stringifies to "").

[13:51] <smls> You know what would be cool? If the Perl 6 port of Lingua::EN::Inflect would extend the quoting language to allow us to write it along the lines of:

[13:51] <smls> use Lingua::EN::Inflect <:pl>; say qq:pl"Wrote $n line[s] so far."

[13:52] <smls> and it would automatically inflect the marked word based on the preceding interpolated variable...

[13:52] <smls> "$n cat[s] ha[s|ve] a total of {$n * 7} li[fe|ves]."

[13:52] <smls> or maybe:

[13:53] <smls> "$n cat@ has@ a total of {$n * 7} life@."

[13:54] *** ptc_p6 left
[13:56] <lucas__> S32/IO says: sub say(*@text): Before printing, call the .gist method on any non-Str objects. But it doesn't looks to happen if you pass a pair literal.

[13:57] <someanon> i think "cats status:\n\tcount: $n\n\ttotal lives: {$n * 7}\n" is simple and compromise solution

[13:57] <someanon> smls, 

[13:57] <brrt> but we should make perl6 cool, though

[13:58] <smls> I don't like to make compromises when it comes to the user interface

[13:58] <smls> I usually rather accept less elegant code

[14:00] *** lucas__ left
[14:03] <someanon>  smls, your example reminds me php db::simple module

[14:04] <someanon> similar problem, similar solution

[14:04] * [Coke] stares into his coffee mug.

[14:05] <someanon> https://github.com/DmitryKoterov/DbSimple

[14:05] <[Coke]> (http://www.amazon.com/Creature-Cups-CRC-003-Cthulhu15-Cthulhu-15oz/dp/B00GW7L8O2/ref=sr_1_1?ie=UTF8&qid=1415973908&sr=8-1&keywords=cthulhu+coffee+mug)

[14:05] <[Coke]> (it's staring back)

[14:06] <someanon> haha

[14:10] <smls> lucas__: To pass a literal pair to a function, you have to quote the key. Otherwise it's interpreted as a named parameter.

[14:10] *** zakharyas left
[14:10] <moritz> ... or put parens around the pair

[14:18] *** JimmyZ left
[14:21] <colomon> new failures overnight: http://host08.perl6.com:8080/report

[14:23] *** denis_boyun joined
[14:24] *** kaare_ left
[14:28] *** lizmat joined
[14:28] *** cognominal joined
[14:38] *** abraxxa left
[14:41] <cognominal> S03:2458 reads "[...] (except that empty C<$()> means C<< $<?> // Str($/) >>, while empty C<item()> yields C<Failure>)."

[14:41] *** woolfy joined
[14:41] * lizmat is seeing a dark Helsinki city center outside

[14:42] <cognominal> That would mean that $<?> is a short for $/.made

[14:43] <cognominal> but it is still different from S05-regex.pod:2963:C<$()> is a shorthand for C<$($/.made // ~$/)>.

[14:43] <jnthn> lizmat: Glad you made it to the devil's titanic...

[14:44] <cognominal> comments from enlighted minds?

[14:44] <lizmat> well, we arrived at HEL just fine  :-)

[14:45] *** JimmyZ joined
[14:49] <someanon> why can't i break feed chain by new line

[14:49] <someanon> ?

[14:50] <Ulti> am I right in thinking if you wanted a random order for a list this is an ok way to do it? .sort({rand > 0.5})

[14:51] <PerlJam> Ulti: uh ... .pick(*) is way better.

[14:51] <Ulti> in the situation I dont have a variable name to use to get the elems at the same time as doing pick

[14:51] <Ulti> ahh pick(*)

[14:51] <Ulti> cool

[14:52] *** xenoterracide_ joined
[14:52] <PerlJam> someanon: Dunno. Seems like you should be able to.

[14:53] <moritz> pick(*) will a fisher-yates shuffle, which is both efficient and fair

[14:54] <PerlJam> someanon: can you show the code that breaks when you try it?

[14:54] *** xenoterracide_ left
[14:54] *** xenoterracide_ joined
[14:55] <someanon> PerlJam, http://pastebin.com/PDCrbkYw

[14:55] <someanon> PerlJam, do you see two maps?

[14:56] *** synopsebot joined
[14:56] <PerlJam> aye

[14:56] <someanon> this about i ask

[14:57] <someanon> error

[14:57] <someanon> Sorry, do not know how to handle this case of a feed operator yet.

[14:57] <PerlJam> someanon: are you making an artificial neural net?

[14:57] <someanon> yep

[14:57] <PerlJam> cool

[14:57] <someanon> perceptron

[14:58] <someanon> just copy of my another one on haskell

[14:58] <someanon> https://github.com/someanon/fluffy-perceptron

[14:58] <someanon> in perl oop way

[14:59] <someanon> *perl6

[14:59] <masak> someanon: I know what you're problem is

[14:59] <masak> someanon: you have a '}' at the end of a line

[14:59] <someanon> i know it can't handle big data, it just learning for

[14:59] <lizmat> moritz: I'm not sure a gather/take in pick(*) would really constitute a fisher/yates shuffle...

[14:59] <masak> someanon: and that's messing up your statement

[15:00] <someanon> aah

[15:00] <masak> someanon: writing it as '}\' should fix it

[15:00] <someanon> it replaced by ;

[15:00] <someanon> } -> };

[15:00] <masak> yeah, "}\n" means "};\n", kinda

[15:00] <someanon> i read it somethere

[15:00] <masak> see S02 for details.

[15:01] <PerlJam> masak++

[15:01] <arnsholt> Ooh, perceptrons!

[15:01] <masak> having fallen down that hole myself a couple times with feed operators, I needed only glance at the code... :)

[15:02] <masak> we should probably write that down as a FAQ somewhere.

[15:02] <someanon> masak, can u make exception in } -> }; logic for feed operators?

[15:03] <someanon> it is the way expected behavior for feed operator i think

[15:03] *** xenoterracide_ left
[15:05] <someanon> PerlJam, in haskell, i wonder in how i had to construct infinite list of neural network weights that converge to optimal values

[15:05] <masak> someanon: it's all fine if you put the '==>' on the same line as the '}', after it

[15:05] <someanon> PerlJam, so train function is just take first element in this list that satisfy minimal error

[15:06] *** [Sno] left
[15:06] <masak> someanon: I think there should definitely be a good error message for catching such situations, yes.

[15:06] * lizmat wonders whether masak will rakudobug this

[15:07] <masak> I'm busy at $work :/

[15:07] <someanon> masak, not error message but not to replace } to }; if there is feed operator after

[15:07] <someanon> *after whitespaces

[15:07] <masak> someanon: that feels... inconsistent.

[15:07] <someanon> but expected

[15:07] <masak> someanon: and also relies on term lookahead.

[15:08] <masak> token*

[15:08] *** ennnio joined
[15:09] <someanon> you think this can leads to bug in another situations?

[15:09] * lizmat waits for a bit before rakudobugging

[15:10] <masak> someanon: no, in all other situations I like the braces-and-semicolons rule.

[15:10] <someanon> >and also relies on term lookahead

[15:10] <someanon> this means bad?

[15:10] <masak> yeah, we try to be one-pass and avoid lookahead.

[15:10] <masak> doing lookahead for an error message is fine, though.

[15:11] <someanon> i'm not expert in compilation theory so, you right i think

[15:12] <someanon> one of the solution use comma instead feed op

[15:13] *** [Sno] joined
[15:13] <someanon> looks cute, like lodash.js chains in js

[15:14] <masak> :)

[15:14] <masak> that kind of puts the finger on why it fails for '==>': because people like to put it on the next line.

[15:15] <masak> with commas, they probably wouldn't.

[15:15] <masak> we have different preconceptions about different infix operators.

[15:15] <masak> especially the comma.

[15:23] * lizmat goes for some sightseeing&

[15:23] <someanon> i wrote  @.output <== map &.activation-function <== map { [+] @input >>*<< @$_ } <== @.weights;

[15:24] <someanon> got error

[15:24] <someanon> Sorry, do not know how to handle this case of a feed operator yet.

[15:24] <someanon> at lib/Perceptron/Layer.pm6:49

[15:24] <someanon> ------> p { [+] @input >>*<< @$_ } <== @.weights⏏;

[15:24] <someanon> what is wrong?

[15:25] <someanon> masak, 

[15:27] *** kaleem_ left
[15:28] <moritz> someanon: what you're trying to so seems to be not implemented yet

[15:28] <moritz> someanon: likely it can only handle lexical arrays as endpoints

[15:28] <moritz> someanon: not @.weights, which is really a method call

[15:28] <someanon> lvalue

[15:29] <someanon> i got

[15:29] *** tinyblak left
[15:29] *** ajr_ left
[15:30] <someanon> in that way works @.output = map &.activation-function, (map { [+] @input >>*<< @$_ }, @.weights);

[15:30] *** guru joined
[15:30] *** telex left
[15:30] *** guru is now known as Guest35197

[15:31] <someanon> i will left like this

[15:31] <someanon>  49     @.output = map &.activation-function,

[15:31] <someanon>  50                map { [+] @input >>*<< @$_ },

[15:31] <someanon>  51                @.weights;

[15:31] *** tinyblak joined
[15:31] <Ulti> wow the DateTime::TimeZone install o___O

[15:31] <Ulti> I had no idea there were so many locale

[15:32] *** telex joined
[15:33] *** Diederich-away is now known as Diederich

[15:33] *** kjs_ joined
[15:34] *** Guest35197 is now known as ajr_

[15:34] *** kaare_ joined
[15:35] *** Util joined
[15:37] *** rurban1 left
[15:37] <masak> someanon: looks good to me.

[15:37] *** wtw left
[15:37] <masak> someanon: very readable.

[15:37] *** wtw joined
[15:37] <masak> someanon: sorry about the parsing bumps still left on the road, resulting in a less-than-smooth driving experience.

[15:38] <[Coke]> r: for 1900..2100 -> $year { say $year if Date.new($year, 2, 1).day-of-week %% 7; } # rectangular months.

[15:38] <camelia> rakudo-{parrot,moar} f8f6fe: OUTPUT«1903␤1914␤1920␤1925␤1931␤1942␤1948␤1953␤1959␤1970␤1976␤1981␤1987␤1998␤2004␤2009␤2015␤2026␤2032␤2037␤2043␤2054␤2060␤2065␤2071␤2082␤2088␤2093␤2099␤»

[15:38] <someanon> masak, thanks for sorry, thanks for work=)

[15:39] <[Coke]> huh. what's with the ?? after 1998?

[15:39] <moritz> [Coke]: I see no ?? after 1998

[15:39] <[Coke]> doesn't show up in the clogs. must just be me.

[15:40] <moritz> [Coke]: might be an artefact of your client

[15:40] * moritz too slow today

[15:41] <smls> someanon: You don't like the method form of 'map'?

[15:42] <smls> @.output = @.weights.map({ [+] @input >>*<< @$_ }).map(&.activation-function);

[15:42] <someanon> hm, i used to perl5 maps

[15:44] <someanon> smls, maybe i should try

[15:45] <[Coke]> so, anyway, rectangular february coming up. :)

[15:45] <someanon> what is the best way to transpose two dimensional array? My solution is my @transposed-weigths = map { [ @.weights[0..$.output-size; $_] ]  }, 0 .. $.input-size;

[15:46] <FROGGS> Ulti: yeah, it takes ages >.<

[15:47] <moritz> someanon: doesn't Z have the right structure for a transposition?

[15:47] <someanon> moritz, don't know

[15:47] <moritz> m: say (<a b c> Z <1 2 3>).tree.perl

[15:47] <camelia> rakudo-moar f8f6fe: OUTPUT«("a", "1"; "b", "2"; "c", "3").item␤»

[15:47] <someanon> i saw one example in the internets but they not worked

[15:48] <moritz> m: say (<a b c> Z <1 2 3>).tree.map(*.item).perl

[15:48] <camelia> rakudo-moar f8f6fe: OUTPUT«(("a"; "1").item, ("b"; "2").item, ("c"; "3").item).list␤»

[15:48] <moritz> m: say (<a b c> Z <1 2 3>).tree.map([@$_]).perl

[15:48] <camelia> rakudo-moar f8f6fe: OUTPUT«No such method 'count' for invocant of type 'Array'␤  in method reify at src/gen/m-CORE.setting:8253␤  in block  at src/gen/m-CORE.setting:8161␤  in method reify at src/gen/m-CORE.setting:8137␤  in method gimme at src/gen/m-CORE.setting:8648␤  in…»

[15:48] <moritz> m: say (<a b c> Z <1 2 3>).tree.map({[@$_]}).perl

[15:48] <camelia> rakudo-moar f8f6fe: OUTPUT«(["a", "1"], ["b", "2"], ["c", "3"]).list␤»

[15:48] <Ulti> FROGGS: the antarctica time zone file is very interesting reading whilst you wait though :D

[15:49] <someanon> moritz, how it works?

[15:49] <moritz> m: my @orig = [<a b c>], [<d e f>], [1, 2, 3]; say ([Z] @orig).perl

[15:49] <camelia> rakudo-moar f8f6fe: OUTPUT«((["a", "b", "c"],), (["d", "e", "f"],), ([1, 2, 3],)).list␤»

[15:49] <moritz> hm, no

[15:49] <moritz> m: my @orig := (<a b c>, <d e f>, (1, 2, 3)); say ([Z] @orig).perl

[15:49] <camelia> rakudo-moar f8f6fe: OUTPUT«(("a",), ("b",), ("c",), ("d",), ("e",), ("f",), (1,), (2,), (3,)).list␤»

[15:49] <moritz> nope :(

[15:50] <smls> Will the .tree become unnecessary after the GLR?

[15:50] <FROGGS> Ulti: indeed :o)

[15:50] <moritz> smls: I have no idea

[15:50] <someanon> =)

[15:51] *** perltricks joined
[15:51] <JimmyZ> Where is dalek :)

[15:51] <[Coke]> It's a week to the release; good time to double check the changelog.

[15:52] <someanon> moritz, will perl6 have usable typed arrays?

[15:52] <moritz> someanon: I dearly hope so

[15:52] <perltricks> hey are .subst() captures implemented? http://www.perlmonks.org/?node_id=855251

[15:53] <jnthn> m: 'omg'.subst(/(\w)/, { $0.uc }, :g).say

[15:53] <camelia> rakudo-moar f8f6fe: OUTPUT«OMG␤»

[15:53] <jnthn> Sure looks like it...

[15:54] <moritz> m: my $v = "test"; $v ~~ s/(\w)/X/;

[15:54] <camelia> rakudo-moar f8f6fe: ( no output )

[15:54] <moritz> m: my $v = "test"; $v ~~ s/(\w)/X/; say $0

[15:54] <camelia> rakudo-moar f8f6fe: OUTPUT«｢t｣␤␤»

[15:54] <moritz> perltricks: looks like that one is implemented too

[15:55] <masak> we still want for a December release manager.

[15:55] <moritz> I should update my answer

[15:57] <perltricks> jnthn: thanks!

[15:57] <someanon> in haskell where type declaration like [Double] or [[Double]] means list of doubles or list of list of doubles

[15:58] <[Coke]> if we don't get a December manager before the November release, I'll take it. but then someone has to take another month in 2015! ;)

[15:58] <someanon> so u can always know what is in input and output

[16:01] *** brrt left
[16:04] <FROGGS> [Coke]: :P

[16:04] <hoelzro> ahoy #perl6

[16:04] <FROGGS> hi

[16:04] <perltricks> m: my %hex = ('%20' => ' '); 'a%20hard%20life'.subst(/\%<[0..9A..Fa..f]>** 2/, { %hex{$0} }, :g).say

[16:04] <camelia> rakudo-moar f8f6fe: OUTPUT«use of uninitialized value of type Any in string context  in block <unit> at /tmp/neCIdoDuL8:1␤␤use of uninitialized value %hex of type Any in string context  in block <unit> at /tmp/neCIdoDuL8:1␤␤use of uninitialized value of type Any in string co…»

[16:05] <moritz> perltricks: in the closure form, you still need to say -> $/ { ... }

[16:05] <perltricks> think I was missing the capture too

[16:05] <moritz> or

[16:06] <moritz> m: my %hex = ('%20' => ' '); $_ = 'a%20hard%20life'; s['%' (<[0..9A..Fa..f]>** 2)] = %hex{$0}; .say # curious if that works

[16:06] <camelia> rakudo-moar f8f6fe: OUTPUT«use of uninitialized value %hex of type Any in string context  in block <unit> at /tmp/KDTkQIrnbd:1␤␤ahard%20life␤»

[16:06] <timotimo> m: say "foo bar baz. 0xabdf1532".comb(/ <xdigit>+ /).perl

[16:06] <camelia> rakudo-moar f8f6fe: OUTPUT«("f", "ba", "ba", "0", "abdf1532").list␤»

[16:06] <perltricks> m: my %hex = ('%20' => ' '); 'a%20hard%20life'.subst(/(\%<[0..9A..Fa..f]>** 2)/, { %hex{$0} }, :g).say

[16:06] <camelia> rakudo-moar f8f6fe: OUTPUT«a hard life␤»

[16:06] <perltricks> yay

[16:06] <perltricks> and ... my uri decoder is ready for production ;)

[16:06] <timotimo> m: say "f00".unbase(16)

[16:06] <camelia> rakudo-moar f8f6fe: OUTPUT«No such method 'unbase' for invocant of type 'Str'␤  in block <unit> at /tmp/acEGhjzZck:1␤␤»

[16:06] <timotimo> m: say "f00".base(16)

[16:06] <camelia> rakudo-moar f8f6fe: OUTPUT«No such method 'base' for invocant of type 'Str'␤  in block <unit> at /tmp/Kn9bErw5Vr:1␤␤»

[16:07] <timotimo> how do i do this again?

[16:07] <timotimo> oh, right

[16:07] <moritz> m: 'a%20hard%20life'.subst(/\%*<[0..9A..Fa..f]>** 2)/, { :16(~$0).chr }).say

[16:07] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/FJEZPtDmpe␤Unable to parse regex; couldn't find final '/'␤at /tmp/FJEZPtDmpe:1␤------> [32md%20life'.subst(/\%*<[0..9A..Fa..f]>** 2[33m⏏[31m)/, { :16(~$0).chr }).say[0m␤    expecting a…»

[16:07] <timotimo> m: say :16("f00")

[16:07] <camelia> rakudo-moar f8f6fe: OUTPUT«3840␤»

[16:07] <timotimo> a ) too much, moritz 

[16:07] <timotimo> or rather, lacking a ( before the <[

[16:07] <moritz> m: 'a%20hard%20life'.subst(/\%(<[0..9A..Fa..f]>** 2)/, { :16(~$0).chr }).say

[16:07] <camelia> rakudo-moar f8f6fe: OUTPUT«a hard%20life␤»

[16:07] <timotimo> and a :g?

[16:07] <moritz> m: 'a%20hard%20life'.subst(:g, /\%(<[0..9A..Fa..f]>** 2)/, { :16(~$0).chr }).say

[16:07] <camelia> rakudo-moar f8f6fe: OUTPUT«a hard life␤»

[16:07] <moritz> timotimo: yes, thanks

[16:07] <timotimo> :)

[16:08] <moritz> this URI decoder brought to you by timoritz :-)

[16:08] <timotimo> m: 'a%20hard%20life'.subst(:g, /'%' <( <xdigit>** 2/, { :16(~$/).chr }).say

[16:08] <camelia> rakudo-moar f8f6fe: OUTPUT«a% hard% life␤»

[16:08] *** anaeem1_ joined
[16:08] <timotimo> ah, oops :)

[16:09] <timotimo> hmm

[16:09] <timotimo> we have chop to remove a char from the end

[16:09] <timotimo> should we also have nibble tor emove a char from the front? :)

[16:09] <timotimo> m: 'a%20hard%20life'.subst(:g, /\% <xdigit> ** 2/, { :16(~$<xdigit>).chr }).say

[16:09] <camelia> rakudo-moar f8f6fe: OUTPUT«Cannot convert string to number: malformed ':16' style radix number, expecting '>' after the body in ':16<2⏏ 0>' (indicated by ⏏)␤  in method <anon> at src/gen/m-CORE.setting:13720␤  in any find_method_fallback at src/gen/m-Metamodel.nqp:2725␤  i…»

[16:09] <jnthn> .substr(1) :P

[16:09] <timotimo> m: 'a%20hard%20life'.subst(:g, /\% <xdigit> ** 2/, { :16($<xdigit>.join).chr }).say

[16:09] <camelia> rakudo-moar f8f6fe: OUTPUT«a hard life␤»

[16:09] <timotimo> not much prettier :(

[16:10] *** treehug88 joined
[16:11] <hoelzro> this is kind of interesting: https://github.com/github/linguist#overrides

[16:11] <timotimo> oh, helpful!

[16:11] *** denis_boyun left
[16:13] <hoelzro> very!

[16:13] <hoelzro> I wish I had known that months ago =/

[16:14] *** kjs_ left
[16:16] *** treehug8_ joined
[16:17] *** KCL_ joined
[16:18] <perltricks> boom it's done https://github.com/sillymoose/URI-Encode

[16:19] *** treehug88 left
[16:19] <perltricks> how can I add this to the modules list?

[16:19] <Diederich> hah

[16:19] <Diederich> nice

[16:21] *** JimmyZ left
[16:22] <hoelzro> lizmat: I was digging into src/core/Grammar.pm a bit last night and found this awesome method wemusthavethishereotherwiserakudowontcompile

[16:22] <hoelzro> do you think that would be safe to get rid of now?

[16:24] *** kurahaupo joined
[16:25] <someanon> http://rosettacode.org/wiki/Matrix_transposition#Perl_6

[16:27] <Ulti> perltricks I just sent you some extra one liners ;3

[16:27] *** Mouq joined
[16:28] <perltricks> Ulti: thanks!

[16:28] <Ulti> perltricks you need to add your repo to herehttps://github.com/perl6/ecosystem/blob/master/META.list

[16:28] <Ulti> afaik it is that simple

[16:29] <Ulti> you need a META.info file in your repo though

[16:30] <perltricks> Ulti: thanks very much for the PR, you nailed loads of them

[16:32] *** Mouq left
[16:32] <Ulti> is there a nicer way to do DateTime.now.earlier(:14months).earlier(:9days).earlier(:7seconds) ? like just give a list of :14months, :9days, 7seconds

[16:35] <perltricks> only have 31 perl 5 one liners left to convert, hurry before they're gone!

[16:35] <arnsholt> I seem to remember something similar being discussed, but not taken in since it would make ordering of the argument list very important

[16:36] *** anaeem1_ left
[16:37] *** anaeem1_ joined
[16:37] <timotimo> m: say :16(2f).chr

[16:37] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/NOOHvBbP7X␤Missing semicolon.␤at /tmp/NOOHvBbP7X:1␤------> [32msay :16(2[33m⏏[31mf).chr[0m␤    expecting any of:␤        whitespace␤»

[16:37] <timotimo> m: say :16<2f>.chr

[16:37] <camelia> rakudo-moar f8f6fe: OUTPUT«/␤»

[16:38] *** lucas_ joined
[16:38] <timotimo> perltricks: E.g. " " becomes % not %  ← what?

[16:41] <Ulti> arnsholt true

[16:41] <Ulti> but that's still true for chaining the methods?

[16:42] <timotimo> Ulti: yes, but when you have named arguments, you don't get a guarantee for the order

[16:42] <Ulti> even in a list of pairs?

[16:42] <Ulti> or is it magically a hash then

[16:43] <smls> Why do we have all of «DateTime.now» [--> DateTime], «now» [--> instant], «time» [--> Int]? Seems excessive...

[16:43] <timotimo> er, no

[16:43] <timotimo> lists of pairs are lists of course

[16:43] <timotimo> and thus ordered

[16:44] <Ulti> smls I like those :P

[16:44] <lucas_> smls, moritz: Thanks for answering my question!

[16:44] <lucas_> BTW, is this error necessary? The compiler already knows by say()'s signature that it won't be handling any named parameters, doesn't it? Could'nt it just treat it like a normal value and pass it along?

[16:44] <smls> Couldn't  «+now»  replace «time»?

[16:45] <timotimo> m: say now; say time;

[16:45] <camelia> rakudo-moar f8f6fe: OUTPUT«Instant:1415983553.264402␤1415983518␤»

[16:45] <timotimo> m: say now - time

[16:45] <camelia> rakudo-moar f8f6fe: OUTPUT«Instant:35.114134␤»

[16:45] *** sqirrel_ joined
[16:45] <timotimo> now gives you a monotonic clock, time gives you leap-seconds and such

[16:46] *** kaleem joined
[16:47] <lucas_> m: my $x = :foo; say $x

[16:47] <camelia> rakudo-moar f8f6fe: OUTPUT«"foo" => Bool::True␤»

[16:47] <lucas_> m: say :foo

[16:47] <camelia> rakudo-moar f8f6fe: OUTPUT«Unexpected named parameter 'foo' passed␤  in sub say at src/gen/m-CORE.setting:16447␤  in block <unit> at /tmp/DCX9xD2kVC:1␤␤»

[16:47] <lucas_> How do I unpack $x in "say $x" to make it give the same error as in "say :foo"?

[16:50] <jnthn> m: my $x = :foo; say |%$x # mebbe

[16:50] <camelia> rakudo-moar f8f6fe: OUTPUT«Unexpected named parameter 'foo' passed␤  in sub say at src/gen/m-CORE.setting:16447␤  in block <unit> at /tmp/n9eGuxZzDX:1␤␤»

[16:50] <lucas_> jnthn: thanks!!

[16:50] <lucas_> now... is this necessary to happen?

[16:51] <jnthn> What else would you want to have happen?

[16:51] <lucas_> m: say ~:foo

[16:51] <camelia> rakudo-moar f8f6fe: OUTPUT«foo  True␤»

[16:52] *** zakharyas joined
[16:52] <lucas_> well, not an error. since say's signature already says that it doesn't handle named params.

[16:52] <jnthn> The error is precisely because say's signature says it does'nt handle named parameters :)

[16:53] <[Coke]> .seen pmichaud

[16:53] <yoleaux> I saw pmichaud 10 Nov 2014 15:02Z in #perl6: <pmichaud> good morning, #perl6

[16:53] *** kjs_ joined
[16:54] <smls> m: say reduce { $^a.earlier(|$^b) }, (DateTime.now, :14months, :9days, :7seconds)

[16:54] <camelia> rakudo-moar f8f6fe: OUTPUT«2013-09-05T17:54:20Z␤»

[16:54] <smls> ^^ Ulti: Not necessarily nicer, but works... :)

[16:55] *** bjz left
[16:56] <Ulti> yeah that would very much fall into the too clever and less readable section of works :P cool though!

[16:57] *** bjz joined
[17:02] <tony-o> does QAST get executed at runtime?

[17:02] *** ghostlines left
[17:03] <timotimo> QAST gets compiled to the backend-specific bytecode before it is run

[17:05] *** smls left
[17:09] *** Mouq joined
[17:09] <moritz> lucas_: downgrading a named param to a positional one seems to just ask for trouble

[17:10] *** bbkr_ left
[17:11] <tony-o> timotimo: if i'm writing a slang, is QAST the correct path to explore if i want to perform some action at runtime or am i going down the wrong path?

[17:11] <timotimo> you'll have to do a fair bit of QAST, i believe

[17:12] <timotimo> masak is currently throwing macro ideas around, one of the important ideas is that we want to have a more high-level, less backend-dependent AST for macros to use

[17:12] <timotimo> that would probably also be what slangs are expected to use

[17:12] <timotimo> AFK for a bit

[17:18] <lucas_> moritz: thanks. I understand it is safer, but maybe not so much DWIM.

[17:19] <lucas_> With "sub f(:$foo)" or "sub f(*%h)", "f :foo" is ok. With "sub f($x)", "sub f(@a)" or "sub f(*@a)", "f :foo" dies instead of DWIM, which is to insert the pair in the variable.

[17:20] <moritz> lucas_: the problem with "DWIM" is that it depends on the "I"

[17:21] <lucas_> moritz: You are very right :D

[17:30] *** guru joined
[17:30] *** ajr_ left
[17:31] *** guru is now known as Guest29341

[17:32] *** rurban joined
[17:34] *** panchiniak joined
[17:34] *** panchiniak left
[17:35] *** FROGGS left
[17:40] *** Guest29341 left
[17:42] *** ghostlines joined
[17:42] *** lucas_ left
[17:42] *** perltricks left
[17:44] *** fhelmberger left
[17:45] *** fhelmberger joined
[17:46] <someanon> how to write into stderr?

[17:46] <someanon> i googled

[17:46] <moritz> m: $*ERR.say: 42

[17:46] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:46] <moritz> m: note 42

[17:46] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:46] <someanon> only through the method?

[17:47] <someanon> m: say $*ERR: 42

[17:47] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:47] <someanon> m: say $*ERR, 42

[17:47] <camelia> rakudo-moar f8f6fe: OUTPUT«IO::Handle<<STDERR>>(opened, at line 0 / octet 0)42␤»

[17:47] <tony-o> any clue what 'Cannot find method 'package_at_key': no method cache and no .^find_method

[17:47] <someanon> m: say $*ERR 42

[17:47] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Lu7bnq9brM␤Two terms in a row␤at /tmp/Lu7bnq9brM:1␤------> [32msay $*ERR [33m⏏[31m42[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤…»

[17:47] *** KCL_ left
[17:47] <someanon> say $*ERR: 42  -is this sugar  for method call?

[17:47] <jnthn> for convenience there's also note

[17:47] <tony-o> any clue what 'Cannot find method 'package_at_key': no method cache and no .^find_method' means in regards to QAST?  even going off of QAST 'say' examples i'm getting that error in the slang

[17:48] <someanon> i mean can method $obj: 'arg-1';

[17:48] <someanon> ?

[17:48] <someanon> *can i

[17:48] <jnthn> m: class A { method yes($x) { say $x } }; yes A: 42;

[17:48] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:49] <someanon> nice

[17:49] *** fhelmberger left
[17:49] <someanon> m: class A { method yes($x) { say $x } }; my $a = A.new(); yes $a: 42

[17:49] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:49] <someanon> m: class A { method yes($x) { say $x } }; my $a = new A

[17:49] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/NTSv7h798n␤Undeclared routine:␤    new used at line 1 (in Perl 6 please use method call syntax instead)␤␤»

[17:49] <someanon> aha

[17:49] <someanon> m: class A { method yes($x) { say $x } }; my $a = new A:

[17:49] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Uv32vd_mVu␤Two terms in a row␤at /tmp/Uv32vd_mVu:1␤------> [32mthod yes($x) { say $x } }; my $a = new A[33m⏏[31m:[0m␤    expecting any of:␤        postfix␤        infix stopper␤ …»

[17:49] <someanon> new isn't method?

[17:50] <tony-o> A.new

[17:50] <someanon> m: class A { method yes($x) { say $x } }; my $a = new A: ()

[17:50] <camelia> rakudo-moar f8f6fe: OUTPUT«Default constructor for 'A' only takes named arguments␤  in method new at src/gen/m-CORE.setting:931␤  in block <unit> at /tmp/8k8xumzzpd:1␤␤»

[17:50] *** KCL_ joined
[17:50] <someanon> why can i yes A: 42; but cant new A: 42;

[17:50] <tony-o> m: class A { method yes($x) { say $x } }; my A $a = .new;

[17:50] <camelia> rakudo-moar f8f6fe: ( no output )

[17:50] <tony-o> m: class A { method yes($x) { say $x } }; my A $a = .new; yes $a: $a.yes;

[17:50] <camelia> rakudo-moar f8f6fe: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in method yes at /tmp/4IAUAnWNSA:1␤  in block <unit> at /tmp/4IAUAnWNSA:1␤␤»

[17:51] *** sqirrel__ joined
[17:51] <someanon> m: class A { multi method new($arg) { say $arg; self.new() } method yes($x) { say $x } }; my $a = new A: 42

[17:51] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/PUd1Zd8sPS␤Two terms in a row␤at /tmp/PUd1Zd8sPS:1␤------> [32mthod new($arg) { say $arg; self.new() } [33m⏏[31mmethod yes($x) { say $x } }; my $a = new[0m␤    expecting any of:␤    …»

[17:51] <someanon> m: class A { multi method new($arg) { say $arg; self.new() }; method yes($x) { say $x } }; my $a = new A: 42

[17:51] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:51] <someanon> wow

[17:51] *** kurahaupo left
[17:51] <someanon> so i can't call method with two dots if there is no arguments?

[17:52] <tony-o> you don't need the colon if there are no arguments

[17:52] <someanon> m: class A { method yes() { say 42 } }; my $a = A.new(); yes $a

[17:52] *** kurahaupo joined
[17:52] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Elg0GszzDK␤Undeclared routine:␤    yes used at line 1␤␤»

[17:52] <someanon> m: class A { method yes() { say 42 } }; my $a = A.new(); yes $a:

[17:52] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/kAsoOzWix4␤Two terms in a row␤at /tmp/kAsoOzWix4:1␤------> [32m() { say 42 } }; my $a = A.new(); yes $a[33m⏏[31m:[0m␤    expecting any of:␤        postfix␤        infix stopper␤ …»

[17:52] <someanon> m: class A { method yes() { say 42 } }; my $a = A.new(); yes $a: ;

[17:52] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:52] <someanon> ha

[17:52] <tony-o> $a.yes ^^

[17:52] <someanon> m: class A { method yes($x) { say $x } }; my $a = new A: ; yes A: 42

[17:52] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:52] <someanon> m: class A { method yes($x) { say $x } }; my $a = new A: ; yes $a: 42

[17:53] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:53] <someanon> nice syntax perl6:3

[17:53] *** kaleem left
[17:53] <someanon> why do you do two dots method call style?

[17:54] <someanon> why do we need it?

[17:54] <someanon> when we need it?

[17:54] *** kaleem joined
[17:54] *** virtualsue left
[17:54] <[Coke]> "two dots" is "colon"

[17:54] *** sqirrel_ left
[17:54] <someanon> ok colon

[17:55] *** kaleem left
[17:55] <someanon> when colon is good to use?

[17:55] <ugexe> named arguments

[17:56] <jnthn> someanon: I basically never use it :)

[17:56] <jnthn> I sometimes use the $obj.meth: ... form.

[17:56] <hoelzro> I find myself using that a lot

[17:56] <someanon> m: class A { method yes(:$x) { say $x } }; my $a = new A: ; yes A :x(42)

[17:56] <camelia> rakudo-moar f8f6fe: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/BEnthadPf9␤You can't adverb that␤at /tmp/BEnthadPf9:1␤------> [32may $x } }; my $a = new A: ; yes A :x(42)[33m⏏[31m<EOL>[0m␤»

[17:56] <someanon> m: class A { method yes(:$x) { say $x } }; my $a = new A: ; yes A: :x(42)

[17:56] <camelia> rakudo-moar f8f6fe: OUTPUT«42␤»

[17:57] <jnthn> I dont really like the meth obj: args syntax, tbh.

[17:57] <hoelzro> only the parentheses-less form for method calls; never the invocant specifier version

[17:57] <hoelzro> same here

[17:57] *** zakharyas left
[17:58] <someanon> moritz, whats the idea of colon method call style? When it good to use?

[17:58] <ugexe> speaking of: multi method new (XML::Element $xml, *%opts) { self.new(:$xml, |%opts); } whats the point of the : before $xml?

[17:59] <hoelzro> ugexe: it's shorthand for xml => $xml

[17:59] <someanon> named arg

[17:59] <tony-o> timotimo: is QAST being run at compile time?  I'm getting the following error even with just trying to call 'say' with latest nqp/moar: 'Cannot find method 'package_at_key': no method cache and no .^find_method

[17:59] <someanon> this code will not work i guess

[17:59] <hoelzro> http://perlcabal.org/syn/S02.html#Adverbial_Pair_forms

[17:59] <hoelzro> ugexe: ^

[17:59] <someanon> ah

[18:00] <someanon> m: my $x = 10; :$x

[18:00] <camelia> rakudo-moar f8f6fe: ( no output )

[18:00] <ugexe> im confused because the method signature doesn't explicitly take a named argument

[18:00] <someanon> m: my $x = 10; { :$x }

[18:00] <camelia> rakudo-moar f8f6fe: ( no output )

[18:00] <tony-o> QAST: QAST.Op.new(:op('say'), QAST::SVal.new( :value('Hi') ))

[18:00] <someanon> m: my $x = 10; say { :$x }.perl

[18:00] <camelia> rakudo-moar f8f6fe: OUTPUT«{"x" => 10}␤»

[18:00] <someanon> haha

[18:00] <leont> ugexe: yeah, good point

[18:00] <timotimo> tony-o: you need QAST::Op.new

[18:01] <ugexe> someanon: @somearray.map: { code block };

[18:01] <leont> No wait, it does make sense

[18:01] <tony-o> for the SVal?

[18:01] *** pecastro left
[18:01] <tony-o> timotimo: QAST.Op.new(:op('say'), QAST::SVal.new( :value('Hi') ))

[18:01] <jnthn> QAST::Op, not QAST.Op

[18:01] <tony-o> oops - i typed it wrong, i do actually have QAST::Op

[18:01] <someanon> ugexe, just for map/grep/etc functional style methods?

[18:02] <ugexe> someanon: not sure, im fairly new to this too :) Thats just where i've found myself using it

[18:02] *** FROGGS joined
[18:03] <hoelzro> someanon: I find myself using that form for things like @array.push: $element as well

[18:03] <someanon> m: my @a = 1..3; say @a.map({ $_** 2 })

[18:03] <camelia> rakudo-moar f8f6fe: OUTPUT«1 4 9␤»

[18:03] <someanon> m: my @a = 1..3; say @a.map({ $_** 2 }).perl; say @a.map: { $_ ** 2 }; say map { $_ ** 2 }, @a;

[18:03] <camelia> rakudo-moar f8f6fe: OUTPUT«(1, 4, 9).list␤1 4 9␤1 4 9␤»

[18:03] <someanon> m: my @a = 1..3; say @a.map({ $_** 2 }); say @a.map: { $_ ** 2 }; say map { $_ ** 2 }, @a;

[18:03] <camelia> rakudo-moar f8f6fe: OUTPUT«1 4 9␤1 4 9␤1 4 9␤»

[18:04] <ugexe> dont forgoet ==> 

[18:04] <someanon> m: my @a = 1..3; say @a.map({ $_** 2 }) ~~ @a.map: { $_ ** 2 } ~~ map { $_ ** 2 }, @a;

[18:04] <camelia> rakudo-moar f8f6fe: OUTPUT«No such method 'count' for invocant of type 'Bool'␤  in method reify at src/gen/m-CORE.setting:8253␤  in block  at src/gen/m-CORE.setting:8161␤  in method reify at src/gen/m-CORE.setting:8137␤  in method gimme at src/gen/m-CORE.setting:8648␤  in …»

[18:04] <someanon> m: my @a = 1..3; say (@a.map({ $_** 2 })) ~~ (@a.map: { $_ ** 2 }) ~~ (map { $_ ** 2 }, @a);

[18:04] <camelia> rakudo-moar f8f6fe: OUTPUT«False␤»

[18:04] <someanon> not same

[18:04] <tony-o> timotimo: jnthn: https://github.com/tony-o/perl6-slang-sql/blob/master/lib/Slang/SQL.pm6#L22

[18:05] *** rurban left
[18:05] <gtodd> is .comb just slightly different version of .split ?  

[18:05] <gtodd> m: "my whole string".split("")[1,7,9] ; "my whole string".comb[13,5]

[18:05] <camelia> rakudo-moar f8f6fe: ( no output )

[18:05] <jnthn> tony-o: It'd need to be $/.make(QAST::Op.new(...)) I guess

[18:06] <jnthn> tony-o: Or just "make ..."

[18:06] <gtodd> m: say "my whole string".comb[13,5] ;

[18:06] <camelia> rakudo-moar f8f6fe: OUTPUT«n o␤»

[18:06] <jnthn> Otherwise it won't associated it with the match object.

[18:06] <jnthn> gtodd: .comb with args is you telling it what things you want

[18:06] <jnthn> s/args/arg/

[18:06] <jnthn> .split with arg is you telling it what things you don't want

[18:06] <gtodd> ahh ok

[18:06] <gtodd> doh!

[18:07] <gtodd> of course

[18:07] <tony-o> jnthn: those both + the original result in the same error :/ https://gist.github.com/tony-o/aa3f33c5f3f709d32ec3

[18:08] <ugexe> m: my @a = 1..3; say @a.map({ $_** 2 }).perl ~~ (@a.map: { $_ ** 2 }).perl ~~ (map { $_ ** 2 }, @a).perl;

[18:08] <camelia> rakudo-moar f8f6fe: OUTPUT«False␤»

[18:08] <ugexe> m: my @a = 1..3; say @a.map({ $_** 2 }).perl; say (@a.map: { $_ ** 2 }).perl; say (map { $_ ** 2 }, @a).perl;

[18:08] <camelia> rakudo-moar f8f6fe: OUTPUT«(1, 4, 9).list␤(1, 4, 9).list␤(1, 4, 9).list␤»

[18:09] <ugexe> ah

[18:09] <ugexe> m: say [1,2,3] ~~ [1,2,3];

[18:09] <camelia> rakudo-moar f8f6fe: OUTPUT«True␤»

[18:10] <ugexe> m: say [1,2,3] ~~ [1,2,3] ~~ [1,2,3];

[18:10] <camelia> rakudo-moar f8f6fe: OUTPUT«False␤»

[18:10] <ugexe> someanon: ^

[18:10] <timotimo> m: my $foo; 100 R= $foo; say $foo

[18:10] <camelia> rakudo-moar f8f6fe: OUTPUT«100␤»

[18:10] <timotimo> this works <3

[18:11] <ugexe> nice

[18:12] <jnthn> tony-o: Odd. I'm not sure what's going on there...

[18:12] <tony-o> jnthn: the other thing that has been confusing me is that $<sym> is not declared at that point either

[18:14] <tony-o> i talked with mouq a little yesterday and he had me rebuild nqp from source (instead of gen from the rakudo source) and that fixed a few things so i'm on moar with nqp-m at the most recent origin/master version

[18:15] *** guru joined
[18:15] *** kjs_ left
[18:15] *** guru is now known as ajr_

[18:16] *** sqirrel__ left
[18:17] <PerlJam> tony-o: Is this something for Advent?  (an SQL slang is exactly what I was hoping someone would do  :)

[18:17] *** PZt joined
[18:18] <tony-o> PerlJam: it's something for the masses :-) yea i planned to write about it if i can get it to work 

[18:18] <PerlJam> tony-o++

[18:19] *** ennnio left
[18:19] <tony-o> i think it makes sql nicer to work with in the language

[18:19] <tony-o> https://github.com/tony-o/perl6-slang-sql/blob/master/t/01_basic.t

[18:20] <tony-o> that parses fine so far as long as i don't write any QAST 

[18:23] <timotimo> tony-o: why did you write my @a = 5?

[18:24] <tony-o> i want to pass perl6 variables into the syntax

[18:25] <ugexe> but you are storing the value of 5 into the array right?

[18:26] <tony-o> in perl6, yes

[18:26] <timotimo> well, how do you write your QAST?

[18:26] <timotimo> do you set it on the $/ using "make"?

[18:27] <someanon> ugexe, ok

[18:27] <tony-o> i've tried it that way: $/.make(QAST::Op.new(:op('say'), QAST::SVal.new(:value('val'))));

[18:27] <timotimo> make(QAST::Op.new( :op('say'), QAST::SVal.new( :value('Str') ) )); ← this should work like that

[18:28] <tony-o> that produces the error in the gist i posted^^

[18:28] *** dwarring joined
[18:30] <timotimo> hm, how does v5 do it?

[18:31] <timotimo> may need some extra precautions to hllize stuff

[18:31] <tony-o> make QAST::Op.new( :op('call'), :name('&die'), QAST::SVal.new( :value('Unimplemented'), :node($/) ) )

[18:31] <tony-o> ah,, i'll try :node

[18:32] <tony-o> meh, same error

[18:32] <timotimo> :node is for giving errors from the generated low-level code line numbers and stuff

[18:35] <tony-o> maybe a hint, not sure.  if i change the signature to method statement_control:sym<with>($/) #instead of Mu $/ then i get a different error including when the method is empty, v5 has sigs without the Mu specification

[18:35] *** KCL_ left
[18:36] <timotimo> ah

[18:37] <timotimo> sometimes you need to use Mu defined variables because nqp-space objects don't derive from Any

[18:37] <timotimo> and Any is the default 

[18:37] <tony-o> Method 'item' not found for invocant of class 'NQPMatch'

[18:38] <tony-o> but, still, I'm getting the QAST errors with Mu $/

[18:39] * timotimo has 0 experience with slang writing ;(

[18:39] <tony-o> i have 0.01 at this point haha

[18:43] *** virtualsue joined
[18:44] <tony-o> FROGGS: any eggs of knowledge to crack ?

[18:48] *** kjs_ joined
[18:48] *** virtualsue left
[18:48] *** Mso150 joined
[18:51] *** gfldex joined
[18:51] *** Alula left
[18:51] *** virtualsue joined
[18:52] *** Alula joined
[18:52] *** virtualsue left
[18:56] *** telex left
[18:58] *** telex joined
[18:58] *** espadrine` left
[19:02] <arnsholt> Such Python variable model, much annoy, such amaze. Wow!

[19:05] <timotimo> %)

[19:10] *** bartolin left
[19:10] *** oetiker left
[19:12] *** kurahaupo left
[19:12] *** bartolin joined
[19:16] *** kjs_ left
[19:19] <arnsholt> I thought I had a solution to the "for over empty list" problem, but it doesn't generalise to if blocks that define variables >.<

[19:20] *** kjs_ joined
[19:20] <timotimo> god damn it ;(

[19:22] <arnsholt> Yeah. Time to create a GitHub issue about the variable model in general, I think

[19:26] *** ghostlines left
[19:26] *** itz_ joined
[19:26] *** Mouq left
[19:28] *** itz left
[19:52] <FROGGS> tony-o: since $/ is an NQPMatch, you cannot just postcircumfix:<{ }> it...

[19:53] <FROGGS> tony-o: look at atkeyish in Tuxic.pm

[19:55] <timotimo> oh, is that the reason?

[19:55] <timotimo> that's surprisingly simple >_<

[19:56] <FROGGS> I'm not sure what the reason is... I don't know the code or error message yet

[19:57] *** darutoko left
[19:58] *** lucas_ joined
[19:58] <tony-o> FROGGS: does that affect doing a .make from it?

[19:59] <tony-o> from $/

[19:59] <FROGGS> tony-o: probably not

[19:59] <lucas_> m: class A{};class B{};class C{};multi f(A) {"a"};multi f(B) {"bad"};multi f(C) {"cat"}; say (A,B,C).map: {f $_}

[19:59] <camelia> rakudo-moar f8f6fe: OUTPUT«a bad cat␤»

[20:00] <tony-o> FROGGS: i copied your atkeyish and i was getting the variables and i'm parsing pretty well that way, I'm trying to implement the functionality now :-)

[20:00] <FROGGS> tony-o: can you point me to your code?

[20:00] <tony-o> QAST::Op.new (or really any QAST::*.new) is giving me problems

[20:00] <tony-o> https://github.com/tony-o/perl6-slang-sql/blob/master/lib/Slang/SQL.pm6

[20:00] *** Alina-malina left
[20:00] <tony-o> uncomment line 22 and that's what my local repo looks like

[20:01] *** Alina-malina joined
[20:01] <FROGGS> ohh

[20:01] <FROGGS> m: use QAST:from<NQP>

[20:01] <camelia> rakudo-moar f8f6fe: ( no output )

[20:01] <FROGGS> tony-o: try that

[20:02] <tony-o> 🍻🍻

[20:02] <tony-o> how do i buy you beer

[20:02] <FROGGS> :P

[20:03] *** regreg left
[20:03] <tony-o> now i need to figure out how to make that thing actually execute my QAST :-)

[20:07] *** exixt_ is now known as exixt

[20:08] *** BenGoldberg joined
[20:17] *** colomon left
[20:18] <tony-o> jnthn: lol'd at page 51 of your yapceu-jvm paper (ministry of silly walks)

[20:18] *** colomon joined
[20:25] *** lucas_ left
[20:27] *** pecastro joined
[20:27] *** pochi_ left
[20:28] *** anaeem1_ left
[20:28] *** anaeem1_ joined
[20:29] *** raiph left
[20:31] *** kaare_ left
[20:33] *** anaeem1_ left
[20:38] *** kjs_ left
[20:42] <tony-o> FROGGS: jnthn: am i reading this right?  do i need to compile QAST to something in order to run this?

[20:42] <FROGGS> tony-o: no, you don't

[20:43] <tony-o> how do i actually invoke the QAST that i wrote?

[20:43] <FROGGS> you 'make' it, that's all

[20:43] <FROGGS> then it will be part of the AST that gets executed

[20:44] <FROGGS> copy&pasto: https://github.com/tony-o/perl6-slang-sql/blob/master/lib/Slang/SQL.pm6#L33

[20:44] <tony-o> huh?

[20:44] <FROGGS> it should read: %*LANG<MAIN-actions>.HOW.mixin...

[20:45] <tony-o> good catch

[20:45] <FROGGS> :o)

[20:45] <tony-o> dos biers

[20:45] <FROGGS> hehe

[20:45] <tony-o> can i make the Op or do i need to make a CompUnit?

[20:46] <FROGGS> the op should do

[20:46] <FROGGS> do not create a new CompUnit

[20:46] <tony-o> i'm erroring with make Op - P6opaque: no such attribute $!made

[20:46] <FROGGS> tony-o: would be nice if you pushed your changes

[20:47] <tony-o> FROGGS: done

[20:47] <FROGGS> I'd try: ...<with>(Mu $/ is rw)

[20:48] <FROGGS> and perhaps: my Mu $block :=...

[20:48] <tony-o> both changes made, still the same error

[20:48] <FROGGS> let me clone it...

[20:48] <tony-o> it's pushed

[20:52] *** KCL_ joined
[20:52] <FROGGS> that works: $/.'!make'($block);

[20:52] *** psch joined
[20:52] <FROGGS> and the two changes I mentioned before are not needed

[20:53] <psch> hey #perl6 \o

[20:53] <FROGGS> hi psch

[20:53] *** oetiker joined
[20:53] <tony-o> FROGGS: wow, tyvm

[20:53] <FROGGS> tony-o: it is a pleasure :o)

[20:56] *** Ven joined
[20:58] *** Krabbe_ joined
[20:59] <Krabbe_> where are the pps?

[20:59] <psch> i think jvminterop used to work more than it does now

[20:59] <psch> although maybe that's just something on my machine right now, for some reason

[20:59] <psch> https://gist.github.com/peschwa/0158083bc4e5613a6390/e9c954c80af8b7db4d33075659c239ff12785eef this bit used to work but doesn't anymore

[20:59] <psch> FROGGS o/

[21:00] <psch> i am aware that it was still far from what it should be, when it worked

[21:01] <FROGGS> Krabbe_: what is 'pps'?

[21:01] <Krabbe_> i’ve been thinking of changing to meteor.js, because Perl sucks. What are your thoughts?

[21:01] *** anaeem1_ joined
[21:02] *** anaeem1_ left
[21:02] <FROGGS> Krabbe_: that you should perhaps join #meteor.js

[21:03] *** perltricks joined
[21:05] *** Mso150 left
[21:06] *** kjs_ joined
[21:07] *** Ven left
[21:08] <lizmat> FROGGS: fwiw, a CompUnit object for a given path is a singleton

[21:08] <lizmat> in other words, creating a new CompUnit object with the same path, will just give you the original object

[21:09] * Krabbe_ slaps FROGGS around a bit with a large trout

[21:09] <FROGGS> lizmat: are you referring to what we said half an hour ago?

[21:09] *** rindolf left
[21:09] <FROGGS> Krabbe_: :P

[21:09] <lizmat> eh, yes?

[21:09] <FROGGS> lizmat: it was about QAST::CompUnit :o)

[21:09] <lizmat> oops

[21:09] * lizmat shuts up

[21:09] <FROGGS> *g*

[21:10] <lizmat> still catching up on backlog of the past days

[21:10] <lizmat> and keeping an eye on what's going on now

[21:10] <lizmat> (well, half an eye, obviously)

[21:12] <Krabbe_> I had been hoping for more advice… Please note I know the beast (not sure what his nick is)

[21:12] <psch> Krabbe_: fwiw, 'perl sucks' is kinda of a shitty way to ask for advice

[21:13] <FROGGS> Krabbe_: I have no advice... thing is, you usually use javascript and Perl for quite different things

[21:13] <FROGGS> and since I don't know meteor.js well I can't compare in the areas where intersections actually exist

[21:14] <FROGGS> i.e., their templates look pretty much like ours, but that does not mean much

[21:14] <Krabbe_> you guys are the cutest

[21:14] <FROGGS> (I don't know any beast here)

[21:14] <FROGGS> totally, not to mention smartest

[21:14] <lizmat> .oO( woolfy ? )

[21:14] <tony-o> Krabbe_: switching for what reason, what are you doing with meteor|perl?

[21:16] *** anaeem1 joined
[21:17] <PerlJam> .oO( please don't feed the trolls )

[21:17] <tony-o> haha

[21:17] <FROGGS> .oO( please don't <=== the trolls )

[21:17] <FROGGS> ohh, does meteor.js actually have feeds?

[21:18] <BenGoldberg> Is there a troll rss?

[21:19] <Krabbe_> so while we’re making serious cash, you’re going to save a lot of money on condems

[21:20] *** anaeem1 left
[21:21] *** kjs_ left
[21:21] <FROGGS> hehe

[21:21] <Krabbe_> I didn’t mean that. I’m very aware of that people that are coding perl doesn’t know the noun condoms

[21:21] <FROGGS> Krabbe_++

[21:21] <Krabbe_> let me explain what they are

[21:21] <FROGGS> you are funny :o)

[21:21] <BenGoldberg> We use the word prophylactics.

[21:21] <Krabbe_> it’s like

[21:21] <Krabbe_> a sort of birth control

[21:21] <PerlJam> Krabbe_: I think you really wanted something other than #perl6

[21:22] <woolfy> Somebody mentioned beast?  Awooooooo!!!!

[21:22] <FROGGS> ohh noes /o\

[21:22] <Krabbe_> so if you can accept the concept of sexual intercourse between two human people of different sex

[21:22] <FROGGS> somebody left her door open

[21:23] <tony-o> krabbs

[21:24] <Krabbe_> the condoms would be a barrier of pleasure and bringing a child into a world where you would have to explain a perl syntax

[21:24] * colomon wonders if the alleged lack of knowledge of condoms is why so many #perl6ers have children…

[21:24] <Krabbe_> du you guys know the BEAST

[21:25] <Krabbe_> hes very good at tha PERL game

[21:25] <PerlJam> Krabbe_: woolfy?  Yeah, we know her.

[21:25] <FROGGS> Krabbe_: did you just read that in your comic book?

[21:25] <BenGoldberg> Krabbe_, This is the size of condom you wear: http://cds.a9t2h4q7.hwcdn.net/main/store/20090519001/items/media/Wallcoverings/cap_wall/ProductLarge/CAP.jpg

[21:25] <Krabbe_> im seeing BEAST on the side, hes quite a man

[21:26] <Krabbe_> large and a little to the left

[21:26] <FROGGS> Krabbe_: but he has condoms, right?

[21:26] <Krabbe_> and in charge

[21:26] <Krabbe_> well he’s using food film. He’s qiuite the man

[21:27] * woolfy feels a bit silly watching this confusing "discussion"

[21:27] <Krabbe_> do you like onions

[21:27] <BenGoldberg> Oops, my mistake, Krabbe_, that link is the size of condom this "beast" you speak of wears.

[21:27] <Krabbe_> i like onions

[21:27] <Krabbe_> and crap cakes

[21:27] <PerlJam> woolfy: it's the first time I can recall wanting op on #perl6.

[21:28] <Krabbe_> i like the christmas time, its classy

[21:28] <woolfy> PerlJam: ack

[21:29] <tony-o> clAssy

[21:32] <Krabbe_> you guys are redicu*******************

[21:32] <Krabbe_> scuuute

[21:33] * moritz hugs Krabbe_ 

[21:33] * labster hugs moritz

[21:33] <PerlJam> hugme: hug Krabbe_ 

[21:33] * hugme hugs Krabbe_

[21:33] * PerlJam hugs by proxy

[21:34] <labster> Hey, are we still collecting for a new Perl 6 community server?  I can make a donation.

[21:35] <hoelzro> I am also happy to donate

[21:36] <Krabbe_> I love this community. This is my besT way to express it: https://www.youtube.com/watch?v=_xAjt64AoD0 song says it all

[21:37] <ugexe> lol if you wear condoms

[21:39] <PerlJam> Krabbe_: do you have one that features butterflies instead?

[21:42] *** KCL_ left
[21:43] <Krabbe_> Sorry PerJam. In Denmark we mostly do crawl, so this is the best I can do: https://www.youtube.com/watch?v=xwyj5cKMGWk

[21:43] <lizmat> m: my $a = Inf; say $a ~~ Inf; say $a == Inf; say $a === Inf  # jnthn, what would be the best from a performance point of view?

[21:44] <camelia> rakudo-moar 9f76c2: OUTPUT«True␤True␤True␤»

[21:46] <tony-o> FROGGS: what should i be looking at if i want to be able to handle anonmyous variable/values?  IE how do i handle a value of '[1,2,3]' in my match if i want to pass it to a sub?

[21:46] <moritz> perltricks: factorial: perl6 -e 'say [*] 1..5'

[21:47] <perltricks> mortiz: nice, thanks will add it

[21:47] <perltricks> moritz: *I mean moritz

[21:48] <moritz> perltricks: most IRC clients allow you tab-complete nick names

[21:48] <tony-o> should i bind to QAST::Var and then pass that to my sub?

[21:48] <FROGGS> tony-o: I'd guess you just want to pass the .made of that as a positional... but I am not sure I understand the question correctly

[21:48] <FROGGS> tony-o: no, a QAST::Var is for a lexical variable

[21:49] <tony-o> in my syntax i want to say with (1,2,3) do ... but i want to pass '1,2,3' as an array to my sub to actually perform the action

[21:49] <FROGGS> tony-o: what exactly parses the '[1,2,3]' ?

[21:50] <tony-o> FROGGS: i'm wondering how to handle https://github.com/tony-o/perl6-slang-sql/blob/master/t/01_basic.t#L11 that in my QAST

[21:50] <tony-o> https://github.com/tony-o/perl6-slang-sql/blob/master/lib/Slang/SQL.pm6#L32

[21:50] <tony-o> trying to handle it there and pass it to #3 as $args

[21:51] <FROGGS> tony-o: do $args.made instead of line 32

[21:54] <ugexe> $args.Str stringifies the list you expect no?

[21:56] <psch> it stringifies the capture

[21:56] <psch> which i think would be '[1,2,3]'

[22:03] <FROGGS> ugexe: $args is a Match object (NQPMatch in this case), that has an AST attached to its 'made' attribute

[22:05] <FROGGS> and the AST contains usually a list (QAST::Op.new( :op<call>, :name('&infix:<,>') ), with variables (QAST::Vars) or values (QAST::IVal, QAST::SVal, ...)

[22:07] <psch> or more Ops!

[22:08] <vendethiel> o/, #perl6!

[22:08] <psch> vendethiel \o

[22:09] <FROGGS> psch: yes, of course :o)

[22:09] <FROGGS> hi ven

[22:13] *** perltricks left
[22:35] * lizmat just pushed https://github.com/rakudo/rakudo/commit/e2ae40b48eac26fdd3f486b4552b506af38226c2

[22:37] *** raiph joined
[22:37] *** esaym153 joined
[22:38] *** raiph left
[22:40] <vendethiel> lizmat++

[22:41] <vendethiel> At some point, at APW, we talked about how "lately", the core/settings were started to get "unidiomatic" to actually be... fast and usable. 

[22:41] <vendethiel> People mentioned the idea of having an "idiomatic prelude", that'd be slow, but very interesting for people to read and understand p6's power.

[22:41] <vendethiel> Kind of like what rosettacode is

[22:43] *** espadrine` joined
[22:43] * vendethiel 's up for it, because he loves having perl6 core being perl6, eh

[22:44] <vendethiel> lizmat: what's that startup loss from, btw?

[22:44] <lizmat> from changes in moarvm

[22:45] <lizmat> if I recall correctly: some optimization that sometimes failed, has been reverted by timotimo and/or hoelzro

[22:45] <timotimo> hoelzro did, yes

[22:45] <vendethiel> oh

[22:45] <lizmat> bringing rakudo on moar startup time from .21 to .37

[22:45] <timotimo> it's about lazily deserializing something

[22:45] <lizmat> (at least on my machine)

[22:45] <vendethiel> timotimo: https://github.com/MoarVM/MoarVM/commit/c86ee9dc047f5e31d6eee3b88190c00ec10e2acd that might deserve a comment? :)

[22:46] <timotimo> hm?

[22:46] <timotimo> a comment in the source code?

[22:46] <vendethiel> yes

[22:46] *** rurban joined
[22:46] *** rurban left
[22:46] <timotimo> i can do that

[22:46] <timotimo> i just added another little piece of code there anyway

[22:47] <timotimo> i'll put a comment in as well

[22:47] <lizmat> vendethiel: wrt to settings being idiomatic p6 code: that would be nice in an ideal world

[22:47] <vendethiel> lizmat: no no no

[22:47] <vendethiel> lizmat: I mean, have two versions. One we're *shipping*; one we're *showing off*.

[22:47] <lizmat> and *who* would keep those in sync ???

[22:47] <vendethiel> they don't *really* need to be.

[22:47] <vendethiel> Nobody's going to "use" the show-off version, like for the RC tasks

[22:48] <lizmat> also: some places in the settings are real old in P6 time

[22:48] <tony-o> FROGGS: can i pm

[22:48] <FROGGS> tony-o: you can

[22:48] <lizmat> they were from a time when a lot of things weren't as possible or as clear as they are now

[22:53] <psch> jakudo builds too slowly for my fiddle-compile-test cycle :/

[22:53] *** exixt is now known as exixt_

[22:54] <psch> as for a show-off setting, i think rosettacode does that pretty well already, as does the learnxinyminutes

[22:55] <BenGoldberg> Is there any easy (automatic) way of finding how old code is, so it can be reviewed from oldest to newest?

[22:58] <timotimo> well, git blame will give you a date for each line

[22:59] <BenGoldberg> Of course, I realize that "old" doesn't automatically mean "slow" or "bad" ... just that it might be.

[23:00] <timotimo> of course

[23:01] * psch is off to sleep o

[23:01] <timotimo> gnite psch 

[23:02] *** raiph joined
[23:06] *** psch left
[23:08] *** j4janicej is now known as j4jackj

[23:09] *** j4jackj is now known as j4janicej

[23:10] <FROGGS> gnight #perl6

[23:10] *** treehug8_ left
[23:11] <lizmat> gnight FROGGS 

[23:12] * lizmat just committed https://github.com/rakudo/rakudo/commit/f5b0bd903dcdf6c7cb44986f611a3fc2fab25999

[23:12] * lizmat also misses Dalek

[23:14] <vendethiel> .oO( but he's a daaaaalek )

[23:14] <FROGGS> lizmat: I'm not sure that patch is a good idea... if someone implements ACCEPTS for his/her type, it won't get called for the :U case

[23:15] <lizmat> FROGGS:??  how would grep and friends influence ACCEPTS ?

[23:16] <FROGGS> lizmat: foo ~~ Bar will results in Bar.ACCEPTS(foo)

[23:16] <vendethiel> lizmat: class A { method ACCEPTS{} }; [].grep(A)

[23:17] <FROGGS> m: class A { method ACCEPTS(\a) { a == 42 } }; say 42 ~~ A; 21 ~~ A

[23:17] <camelia> rakudo-moar 9f76c2: OUTPUT«True␤»

[23:17] *** j4janicej is now known as JaniceTheGreat

[23:17] <FROGGS> m: class A { method ACCEPTS(\a) { a == 42 } }; say 42 ~~ A; say 21 ~~ A

[23:17] <camelia> rakudo-moar 9f76c2: OUTPUT«True␤False␤»

[23:17] <lizmat> ah, I see what you mean...

[23:17] *** JaniceTheGreat is now known as j4janicej

[23:17] <FROGGS> ~~ it does not just compile to an istype check

[23:18] <lizmat> well, if it is a literal type, it can

[23:18] *** travis-ci joined
[23:18] <travis-ci> Rakudo build errored. Elizabeth Mattijsen 'Make grep/-index/first/-index/last-index(:T) fastr

[23:18] <travis-ci> http://travis-ci.org/rakudo/rakudo/builds/41053151 https://github.com/rakudo/rakudo/compare/e2ae40b48eac...f5b0bd903dcd

[23:18] *** travis-ci left
[23:18] <lizmat> que?

[23:18] * lizmat looks

[23:18] <FROGGS> like truthness is also a hot thing, which can result in a call to .Bool, which makes it hard to spesh

[23:19] <lizmat> so you're saying my other nqp::istype changes are suspect as well ?

[23:19] *** anaeem1 joined
[23:19] <FROGGS> and you can also implement a 'defined' method for your type, which should (but NYI) influence :D and :U

[23:20] <lizmat> travis problem seems unrelated to my commit

[23:20] <FROGGS> lizmat: travis has just noticed that github is downish

[23:20] <FROGGS> ohh, I was meant to be in bed...

[23:21] <lizmat> good night again,  :-)

[23:21] <colomon> o/

[23:24] *** anaeem1 left
[23:25] <tony-o> PerlJam: check out what FROGGS mouq and ugexe helped me get working: https://github.com/tony-o/perl6-slang-sql/blob/master/t/01_basic.t

[23:25] <tony-o> timotimo helped me out too ^

[23:28] <timotimo> nice :)

[23:29] *** araujo left
[23:29] *** araujo joined
[23:30] *** travis-ci joined
[23:30] <travis-ci> Rakudo build passed. Elizabeth Mattijsen 'FROGGS++ pointed out this may be a bad idea

[23:30] <travis-ci> http://travis-ci.org/rakudo/rakudo/builds/41054166 https://github.com/rakudo/rakudo/compare/f5b0bd903dcd...2e37564f2c48

[23:30] *** travis-ci left
[23:33] * lizmat just committed https://github.com/rakudo/rakudo/commit/2e37564f2c48bc45b5dc34f72f2743b26b339f06

[23:43] *** telex left
[23:44] *** telex joined
[23:47] <timotimo> facepalm facepalm facepalm

[23:47] <timotimo> https://gist.github.com/timo/de0ef5d3f5e159117d2b

[23:50] *** JimmyZ joined
[23:52] <lizmat> timotimo: sorry, don't see the facepalm  :-(

[23:52] <timotimo> well

[23:53] <timotimo> the specialized code looks like this:

[23:53] <timotimo> get the argument, get the dispatcher for good measure, unpack the boxed Int from the Bool object

[23:53] <timotimo> then check if it's true or false

[23:53] <timotimo> if it's true, grab a value (i suspect True) from the World

[23:53] *** anaeem1 joined
[23:53] <timotimo> if it's false, grab a different value from the World

[23:53] <timotimo> then the code reconvenes in the last BB

[23:54] <timotimo> where we decontainerize the thing we just got out of the World

[23:54] <timotimo> check if it's true or false

[23:54] <timotimo> make a p6bool from that and return that

[23:55] <lizmat> ah, yes, that seems a bit roundabout  :-)

[23:55] <timotimo> well, yeah

[23:55] *** virtualsue joined
[23:55] <timotimo> the fact that we definitely get a Bool in makes it all that much more ridiculous

[23:56] <timotimo> oh

[23:56] <timotimo> in fact, the objects we get from World are pre-built Int instances

[23:56] <timotimo> multi prefix:<!>(Bool \a) { nqp::p6bool(a ?? 0 !! 1) }

[23:57] <JimmyZ> https://github.com/tony-o/perl6-slang-sql/blob/master/lib/Slang/SQL.pm6#L43   # We don't have a Perl6 yet to do bindkey?

[23:57] <JimmyZ> Perl 6 way..

[23:57] <timotimo> these objects are not perl6 objects

[23:58] *** anaeem1 left
