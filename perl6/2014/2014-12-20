[00:00] *** vendethiel joined
[00:01] *** PZt left
[00:02] *** Ugator left
[00:02] *** jack_rabbit joined
[00:11] *** vendethiel left
[00:11] <tony-o> TimToady: me?

[00:14] *** ptc_p61 left
[00:20] *** gfldex left
[00:25] *** slavik joined
[00:30] *** grettis_ left
[00:35] *** jack_rabbit left
[00:36] * TimToady wasn't referring to you :)

[00:41] <tony-o> good cause that was lost on me

[00:45] *** slavik left
[00:49] *** slavik joined
[00:54] *** Mso150 left
[00:55] *** Mso150 joined
[01:16] *** atroxaper joined
[01:20] *** atroxaper left
[01:29] *** Mso150 left
[01:29] *** vendethiel joined
[01:30] *** PZt joined
[01:31] * raydiak ponders how many combinations of invalid html dwim, while many combinations of valid css don't dwim

[01:52] <dalek> doc: 7788ce7 | raydiak++ | / (2 files):

[01:52] <dalek> doc: Fix a couple validation failures

[01:52] <dalek> doc: review: https://github.com/perl6/doc/commit/7788ce7613

[01:55] *** Ven joined
[01:58] <Ven> hoelzro: not sure how I can the #|{...} value to display of a MAIN?

[02:00] *** BenGoldberg joined
[02:01] <Ven> is there a way to hide a multi MAIN from the list? ha

[02:10] <hoelzro> Ven: sorry, I don't understand

[02:11] <Ven> hoelzro: a MAIN subroutines shows the different "versions" of MAIN. I'm wondering if I can hide some of them from the listing

[02:14] <Ven> hoelzro: Also, I'm trying to print argument help from a MAIN's subroutine

[02:14] <hoelzro> ah ha

[02:15] <hoelzro> well, I think that depends on USAGE, right?

[02:15] <Ven> yes.

[02:17] *** araujo left
[02:17] *** rmgk_ joined
[02:17] *** rmgk left
[02:17] *** rmgk_ is now known as rmgk

[02:17] *** araujo joined
[02:28] *** anaeem1 joined
[02:30] *** anaeem1 left
[02:46] *** Ven left
[03:03] *** doublelel joined
[03:10] <JimmyZ> why I cannot pass positional args to .new?

[03:14] *** araujo left
[03:32] <raydiak> JimmyZ: because it doesn't know what to do with them, for most of the core classes.  you should be able to use them with a .new that actually accepts them though

[03:33] <raydiak> m: say Array.new(1, 2, 3).perl

[03:33] <camelia> rakudo-moar deb1e6: OUTPUT«Array.new(1, 2, 3)␤»

[03:37] *** petercom1and left
[03:37] *** petercommand joined
[03:37] *** petercommand left
[03:37] *** petercommand joined
[03:39] <JimmyZ> raydiak: I'm now using core class ...

[03:41] <raydiak> JimmyZ: can you show us what is not working with a one-liner here or a gist?

[03:43] <JimmyZ> raydiak: https://gist.github.com/zhuomingliang/26e30224f06848908793

[03:48] <raydiak> http://design.perl6.org/S12.html#Construction_and_Initialization

[03:48] <raydiak> "Other than a list of autovivifying type objects, all arguments to bless must be named arguments, not positional."

[03:49] <raydiak> so for BUILD also

[03:49] <raydiak> so if you want .new to take positionals, you define a .new that accepts positionals and turns them into nameds when calling .bless

[03:51] <JimmyZ> oh, I want to avoid nameds completely 

[03:51] *** doublelel left
[03:52] <raydiak> you can define your own method new which takes positionals, but in that method, you must call bless with only named arguments

[03:52] <JimmyZ> :(

[03:53] <raydiak> m: class Foo { has $.x; has $.y; method new ($x, $y) { self.bless: :$x, :$y } }; say Foo.new(1,2).perl

[03:53] <camelia> rakudo-moar deb1e6: OUTPUT«Foo.new(x => 1, y => 2)␤»

[03:57] <raydiak> if you wanted something that looks even more positional, you could make a class which 'does Positional', or inherits from a class which does (e.g. 'class Point is Array'

[03:57] *** noganex_ joined
[03:58] <raydiak> but that's more about being able to subscript it w/[] and so forth, which might not be whaat you're trying to do

[03:58] <JimmyZ> https://gist.github.com/zhuomingliang/26e30224f06848908793  I can't get it work.

[04:00] *** xinming_ joined
[04:01] *** noganex left
[04:01] <raydiak> change 'self.bless($!x + $b.x, $!y + $b.y);' to 'self.bless: :x($!x + $b.x), :y($!y + $b.y);'

[04:02] *** xinming left
[04:04] <JimmyZ> got it, bless is slow...

[04:06] <raydiak> yes, that's why it's often a good idea supposed to reuse objects when possible in hot loops like that, instead of creating a new one every time

[04:06] *** atroxaper joined
[04:07] <raydiak> make add a mutator instead of a constructor, it'll probably be much faster

[04:08] <JimmyZ> raydiak: https://github.com/zhuomingliang/perl6-bench/blob/aa9d7dda34396f87613c545c933d9324f55bc20a/nqp/point_class_add2#L7

[04:09] <raydiak> oh it's a benchmark...nevermind then :)

[04:13] *** atroxaper left
[04:18] *** jack_rabbit joined
[04:20] *** azriel left
[04:23] *** raiph left
[04:26] *** vendethiel left
[04:39] <raydiak> wow yeah, bless is slow...making add a mutator takes the time on my machine from 14.4s to 1.4s...so probably way more than 10x the actual runtime

[04:40] <raydiak> I guess that means our native types and loops are pretty speedy now

[04:43] *** vendethiel joined
[04:43] * raydiak wishes spurious creation/destruction in loops like that could be optimized away in simple cases

[04:46] *** raiph joined
[05:06] *** vendethiel left
[05:11] *** vendethiel joined
[05:29] * raydiak wonders if rakudo couldn't just keep some destroyed objects around for re-use

[05:31] *** erkan left
[05:33] * raydiak wonders why he didn't write Pray with all this in mind very much, and considers recitfying it

[05:33] *** vendethiel left
[05:34] *** erkan joined
[05:34] *** erkan left
[05:34] *** erkan joined
[05:35] *** vendethiel joined
[05:38] *** kaare__ joined
[05:55] *** BenGoldberg left
[05:59] *** atroxaper joined
[06:05] *** atroxaper left
[06:06] *** molaf__ left
[06:07] *** atroxaper joined
[06:30] *** erkan left
[06:32] *** erkan joined
[06:32] *** erkan left
[06:32] *** erkan joined
[06:39] *** vendethiel left
[06:42] *** vendethiel joined
[06:45] *** rindolf joined
[07:00] *** Alina-malina left
[07:01] *** Alina-malina joined
[07:01] *** kaare__ left
[07:02] *** kaare__ joined
[07:03] *** raiph left
[07:09] *** sorear left
[07:09] *** sorear joined
[07:10] *** clkao left
[07:10] *** Exodist left
[07:10] *** Spot__ left
[07:10] *** skarn left
[07:11] *** rindolf left
[07:12] *** lizmat left
[07:12] *** eternaleye left
[07:12] *** jercos left
[07:12] *** ecocode`` joined
[07:12] *** lizmat joined
[07:13] *** atroxaper left
[07:13] *** sjohnson left
[07:13] *** atroxaper joined
[07:13] *** ecocode` left
[07:13] *** Spot__ joined
[07:14] *** jercos joined
[07:15] *** clkao_ joined
[07:16] *** ggherdov left
[07:19] *** Exodist joined
[07:20] *** ggherdov joined
[07:25] *** Sqirrel left
[07:25] *** Sqirrel joined
[07:25] *** lsm-desktop left
[07:27] <raydiak> I can't seem to find any substantial mention of destruction or DESTROY in the spec^Wdesign docs?

[07:29] <JimmyZ> raydiak: could you paste your 1.4s version?

[07:30] <raydiak> okay, better question: is there a way I can make instances of my class do something else when it should get GC'd?

[07:30] <JimmyZ> raydiak: yeah

[07:30] <raydiak> JimmyZ: sure, gimme a sec...but it's arguably not a fair comparison for a benchmark, unless the other languages' versions use mutators too

[07:31] *** eternaleye joined
[07:31] <JimmyZ> raydiak: yeah I know, I use it for testing

[07:31] <JimmyZ> ;)

[07:32] *** eternaleye left
[07:32] *** lsm-desktop joined
[07:32] *** eternaleye joined
[07:33] <JimmyZ> raydiak: submethod DESTROY()

[07:33] *** skarn joined
[07:33] <raydiak> JimmyZ: https://gist.github.com/raydiak/cab66abb2738be47b2b8

[07:34] <raydiak> DESTROY seems to be removed from the syns and referred to as a "fossil" in the commit log

[07:35] <raydiak> so idk if I'm supposed to use some sort of meta stuff or what...

[07:36] <JimmyZ> raydiak: It 's useed in the core though

[07:37] <raydiak> JimmyZ: alright thanks, suppose I'll use it and ask around more later about what happened

[07:38] *** Mso150 joined
[07:40] *** sjohnson joined
[07:41] *** erkan left
[07:44] *** erkan joined
[07:44] *** erkan left
[07:44] *** erkan joined
[07:52] <moritz> \o

[07:52] <raydiak> \o

[08:03] *** dj_goku left
[08:03] *** dj_goku_ joined
[08:05] <timotimo> can while loops with native number counters die already? for loops are optimized to become that exact thing with an automatically native-or-bigint counter variable anyway

[08:08] *** vendethiel left
[08:11] *** gfldex joined
[08:11] <timotimo> (we have jnthn to thank for that)

[08:16] *** Ugator joined
[08:22] *** darutoko joined
[08:22] *** vendethiel joined
[08:22] <timotimo> hmm, FROGGS post is up today

[08:22] <timotimo> i hope he's all right

[08:23] <Ugator> morning #perl6 (-:

[08:23] <Ugator> Im still wondering about the conditional 'andthen' how is this different from a normal concat of commands with ; ? will perl ever execute a next command after the previous failed?

[08:24] <timotimo> m: False andthen say "hello"

[08:24] <camelia> rakudo-moar deb1e6: OUTPUT«hello␤»

[08:24] <timotimo> m: False andthen say $_

[08:24] <camelia> rakudo-moar deb1e6: OUTPUT«Nil␤»

[08:24] <Ugator> what does this mean?

[08:25] *** krunen left
[08:25] <timotimo> the second output is because something is not yet implemented

[08:25] <timotimo> m: Any andthen say "hello"

[08:25] <camelia> rakudo-moar deb1e6: ( no output )

[08:25] <timotimo> m: Any; say "hello"

[08:25] <camelia> rakudo-moar deb1e6: OUTPUT«hello␤»

[08:26] <timotimo> undefined values count as "fail" for the andthen operator

[08:26] <Ugator> ah, thats the bit I didnt get, thanks (:

[08:27] <timotimo> YW :)

[08:27] <timotimo> (i had to look at the synopses myself)

[08:29] <timotimo> OK, i'm going to commute for ~an hour

[08:29] <timotimo> o/

[08:35] <[Coke]> timotimo: wh...oh, it's 3:35 localtime.

[08:36] <raydiak> [Coke]: no no, *local* time is 0:36 :)

[08:38] *** telex left
[08:39] <raydiak> I only half make sense to even myself...that means local time is...bed.  \o

[08:40] *** telex joined
[08:43] *** vendethiel left
[08:47] *** vendethiel joined
[08:48] *** ptc_p6 joined
[08:49] <moritz> it seems that FROGGS++ hasn't written his advent post for today

[08:50] <moritz> I'd like to use tomorrows post by nige++ today, to give him more time

[08:50] <moritz> does that sound sensible?

[08:52] <dalek> rakudo/nom: b5699e3 | lizmat++ | src/core/Any.pm:

[08:52] <dalek> rakudo/nom: Make .end a multi

[08:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b5699e3c67

[08:52] <dalek> rakudo/nom: 23413d3 | lizmat++ | src/core/Cool.pm:

[08:52] <dalek> rakudo/nom: Make .Int a multi

[08:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/23413d3066

[08:52] <dalek> rakudo/nom: a00041d | lizmat++ | src/core/ (4 files):

[08:52] <dalek> rakudo/nom: Add types to signature and make multi

[08:52] <dalek> rakudo/nom: 

[08:52] <dalek> rakudo/nom: Fix several cases where Type.method would give a "cannot access attribute in

[08:52] <dalek> rakudo/nom: a type object": should that happen now, it should give you a "cannot find

[08:52] <dalek> rakudo/nom: candidate", or should just work.

[08:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a00041d9b5

[08:52] *** ecocode`` left
[08:53] <dalek> rakudo/nom: c94e169 | moritz++ | src/core/Temporal.pm:

[08:53] <dalek> rakudo/nom: Update synopsis link to design.perl6.org

[08:53] *** erkan left
[08:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c94e169ad2

[08:55] <dalek> mu: 82e1134 | moritz++ | misc/perl6advent-2014/schedule:

[08:55] <dalek> mu: advent: Switch days 20 and 21

[08:55] <dalek> mu: 

[08:55] <dalek> mu: the post for 21 is already written, the one planned for 20 not;

[08:55] <dalek> mu: and today is the 20th

[08:55] <dalek> mu: review: https://github.com/perl6/mu/commit/82e11348db

[08:56] *** erkan joined
[08:56] <moritz> .tell nige I've published your advent post (scheduled for tomorrow, 21st) today already, because today's post isn't written yet

[08:56] <yoleaux> moritz: I'll pass your message to nige.

[08:56] <moritz> .tell FROGGS I've moved your advent slot from today to tomorrow, to give you another day :-)

[08:56] <yoleaux> moritz: I'll pass your message to FROGGS.

[08:57] <moritz> vendethiel: are you an advent post for the 22nd?

[08:59] <moritz> vendethiel: *writing

[09:02] <JimmyZ> s/Day 20:/Day 20 -/ ?

[09:02] <lizmat> https://quip.com/r69HA9GhGa7J  # The Theory Of Type Hinting by Guido van Rossum

[09:02] <lizmat> it explains "gradual typing"

[09:03] <moritz> JimmyZ: fixed, thanks

[09:04] <JimmyZ> hmm, i didn't see it get updated

[09:05] <dalek> rakudo/newio: 413a2d5 | moritz++ | src/core/Promise.pm:

[09:05] <dalek> rakudo/newio: Make Promise.Bool a multi

[09:05] <dalek> rakudo/newio: 

[09:05] <dalek> rakudo/newio: otherwise "so Promise" dies

[09:05] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/413a2d5078

[09:05] *** dalek left
[09:06] <moritz> JimmyZ: oops, seems I forgot to save

[09:06] *** dalek joined
[09:06] *** ChanServ sets mode: +v dalek

[09:06] *** molaf joined
[09:06] <moritz> lizmat: that theory of type hinting looks thoroughly confusing to me

[09:07] <lizmat> yeah, but that's probably because we don't have the right mindset

[09:07] <moritz> the example is a variable e typed Employee

[09:07] <moritz> and it's OK to assign Any to it

[09:07] <moritz> but it's not OK to assign a string to it

[09:07] <moritz> even though all classes (including String) inherit from Any

[09:08] <moritz> and the first rule is

[09:08] *** FROGGS[mobile] joined
[09:08] <lizmat> yeah.... what can I say

[09:08] <moritz> If t1 is a subclass of t2, t1 is also consistent with t2. (But not the other way around.)

[09:08] <lizmat> Maybe Any is special ?

[09:08] <moritz> lizmat: seems like

[09:08] <moritz> lizmat: anyway, thanks for sharing the link

[09:08] <lizmat> yw  :-)

[09:09] <FROGGS[mobile]> is it a problem that my advent post wont be ready before afternoon? 

[09:10] <lizmat> FROGGS[mobile]: no, because you have another day

[09:10] <moritz> FROGGS[mobile]: no, because I moved your slot to tommorw

[09:10] *** molaf_ joined
[09:10] <moritz> FROGGS[mobile]: and I used the post scheduled for tomorrow (but already written) for today

[09:13] *** FROGGS joined
[09:13] *** molaf left
[09:16] <dalek> roast/newio: c8f613e | lizmat++ | S (5 files):

[09:16] <dalek> roast/newio: Test changes for newio branch

[09:16] <dalek> roast/newio: review: https://github.com/perl6/roast/commit/c8f613ecc6

[09:17] <lizmat> so, the newio branch contains a pretty large number of primitives that are *not* part of the perl6 API

[09:17] <lizmat> but are rakudo specific implementation detail

[09:17] <FROGGS> \o/

[09:17] <yoleaux> 08:56Z <moritz> FROGGS: I've moved your advent slot from today to tomorrow, to give you another day :-)

[09:17] <FROGGS> moritz++

[09:18] <lizmat> but I would still like to write tests for them directly

[09:18] <lizmat> as a sort of sanity test

[09:18] <lizmat> would it be ok if I put those tests in roast nonetheless?

[09:18] <lizmat> clearly marking them as rakudo implementation detail ?

[09:18] * JimmyZ wonders what the newio branch  changes

[09:19] <lizmat> JimmyZ: the API will not change

[09:19] <lizmat> things under the hood will

[09:19] <JimmyZ> but what changed?

[09:19] <lizmat> perhaps the name "newio" was wrong, and "optimizedio" would have been better

[09:19] <lizmat> IO::Path will basically become a role

[09:20] <lizmat> anything using a $!PIO will be a consumer of the PIO role

[09:20] <JimmyZ> Is PIO role a API ? 

[09:20] <lizmat> dir() will (by default) not return IO::Path, but IO::File/Dir/Local objects (which are all consumers of the IO::Path role)

[09:21] <lizmat> well, a rakudo/nqp specific one

[09:21] <JimmyZ> so it's not API that's in specs?

[09:22] <lizmat> nope

[09:22] <lizmat> from a spec point of view, the most important difference is that dir() doesn't return IO::Path objects anymore

[09:22] <lizmat> and .IO returns either a IO::File/Dir/Local or an IOU object

[09:24] <lizmat> from an API point of view, you shouldn't need to worry: all methods will work (or fail appropriately) on all objects

[09:24] <lizmat> you could argue that the new IOU is the old, unopened IO::Handle object

[09:25] <lizmat> goals are: better code maintainabiility (all backend specific code in one place)

[09:25] <lizmat> e.g. all dir() like applications now use an internal sub that is implemented differently for each backend

[09:26] <lizmat> instead of having conditional code sprinkled around

[09:26] <lizmat> the main reason I didn't merge newio yet, is that it still not spectest clean

[09:26] <lizmat> and it still breaks panda  :-(

[09:27] <lizmat> and we can't have that now, can we  :-)

[09:27] * JimmyZ cares more speed :P

[09:27] <lizmat> JimmyZ: that's also happening  :-)

[09:28] <JimmyZ> parrot was 'refactor and refactor and slower and slower' :P

[09:29] <lizmat> eh.... if it's slower, than I did something wrong

[09:30] <lizmat> if anything, I'm trying to rewrite the code in such a way, that it is easier optimizable and inlineable

[09:32] *** vendethiel left
[09:32] *** Isp-sec joined
[09:34] *** spider-mario joined
[09:36] *** erkan left
[09:37] <dsm> what is FILETEST-S?

[09:37] *** vendethiel joined
[09:39] *** erkan joined
[09:39] *** anaeem1 joined
[09:39] <lizmat> it returns the size of a file (given by an absolute path) in number of bytes

[09:39] <lizmat> m: say FILETEST-S('/home/camelia/evalbot')

[09:39] <camelia> rakudo-moar c94e16: OUTPUT«4096␤»

[09:39] <lizmat> it's supposed to be an implementation specific thing

[09:40] <lizmat> m: say 'evalbot'.IO.s

[09:40] <camelia> rakudo-moar c94e16: OUTPUT«'evalbot' is not a regular file while trying to do '.s'␤  in method gist at src/gen/m-CORE.setting:13839␤  in sub say at src/gen/m-CORE.setting:16597␤  in block <unit> at /tmp/wcNZHEDkZW:1␤␤»

[09:40] <dsm> is FILETEST-S function a part of NQP?

[09:40] <lizmat> you could consider it to be that, yes

[09:40] <[Coke]> imo, rakudo impl details should be tested in 'test', not 'spectest'

[09:40] <lizmat> m: say 'test'.IO.s

[09:41] <camelia> rakudo-moar c94e16: OUTPUT«0␤»

[09:42] <dsm> is it a bad practice to use NQP functions directly in Perl 6 applcation?

[09:42] <lizmat> I would say: yes

[09:44] <lizmat> [Coke]: but in sanity test, I cannot use Test.pm  :-(

[09:44] <moritz> lizmat: maybe add a new test directory in rakudo that can use Test.pm?

[09:45] <lizmat> ah, I see that 99-test-basic uses Test.pm

[09:45] <lizmat> well, I guess to test Test.pm

[09:46] <lizmat> so I guess I should be ok in using Test.pm after that has been tested ??

[09:47] <moritz> lizmat: yes

[09:47] <moritz> lizmat: also the days are over where loading a module was a very fragile thing, and often broke

[09:47] <moritz> (I hope :-)

[09:48] <lizmat> I hope so too, but seeing panda break in mysterious ways, makes me a little bit weary  :-)

[09:48] <dalek> rakudo/newio: d1b5249 | lizmat++ | src/core/IO.pm:

[09:48] <dalek> rakudo/newio: Add missing filetest primitives for consistency

[09:48] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/d1b5249979

[09:49] *** anaeem1 left
[09:50] <dalek> rakudo/newio: b7e8ba5 | lizmat++ | t/01-sanity/ (2 files):

[09:50] <dalek> rakudo/newio: Rename "last" test file for post Test.pm tests

[09:50] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/b7e8ba5cab

[09:50] *** rindolf joined
[09:58] *** rurban joined
[10:01] *** vendethiel left
[10:01] *** vendethiel joined
[10:02] <dalek> rakudo/newio: 9eba6f1 | lizmat++ | t/01-sanity/filetests/r (4 files):

[10:02] <dalek> rakudo/newio: Add some empty files for filetests

[10:02] <dalek> rakudo/newio: review: https://github.com/rakudo/rakudo/commit/9eba6f101e

[10:15] <lizmat> errands&

[10:18] *** atroxaper left
[10:19] *** isBEKaml joined
[10:23] *** atroxaper joined
[10:25] <dsm> m: use HTTP::UserAgent :simple; get("http://www.cool-proxy.net/proxies/http_proxy_list/page:1")

[10:25] <camelia> rakudo-moar c94e16: OUTPUT«===SORRY!===␤Could not find HTTP::UserAgent in any of: /home/camelia/rakudo-inst-1/languages/perl6/lib, /home/camelia/rakudo-inst-1/languages/perl6␤»

[10:25] *** vendethiel left
[10:27] *** vendethiel joined
[10:27] *** atroxaper left
[10:28] <dsm> can someone explain this? http://pastebin.com/hPvVzZ4Z

[10:32] <FROGGS> star-m: use HTTP::UserAgent :simple; get("http://www.cool-proxy.net/proxies/http_proxy_list/page:1")

[10:32] <camelia> star-m 2014.09: OUTPUT«===SORRY!===␤Could not find HTTP::UserAgent in any of: /home/camelia/star-2014.09/languages/perl6/lib, /home/camelia/star-2014.09/languages/perl6␤»

[10:32] <FROGGS> ahh, too old

[10:32] *** anaeem1_ joined
[10:33] <FROGGS> star-m: use URI; say URI.new("http://www.cool-proxy.net/proxies/http_proxy_list/page:1")

[10:33] <camelia> star-m 2014.09: OUTPUT«URI.new(grammar => IETF::RFC_Grammar.new(rfc => "rfc3896", grammar => IETF::RFC_Grammar::URI, parse_result => Match.new(orig => "http://www.cool-proxy.net/proxies/http_proxy_list/page:1", from => 0, to => 56, ast => Any, list => ().list, hash => EnumMap.new("U…»

[10:33] <FROGGS> star-m: use URI; say URI.new("http://www.cool-proxy.net/proxies/http_proxy_list/page:1").host

[10:33] <camelia> star-m 2014.09: OUTPUT«www.cool-proxy.net␤»

[10:34] <FROGGS> star-m: use URI; say URI.new("http://www.cool-proxy.net/proxies/http_proxy_list/page:1").port

[10:34] <camelia> star-m 2014.09: OUTPUT«80␤»

[10:34] <FROGGS> star-m: use URI; say URI.new("http://www.cool-proxy.net/proxies/http_proxy_list/page:1").path

[10:34] <camelia> star-m 2014.09: OUTPUT«/proxies/http_proxy_list/page:1␤»

[10:35] *** anaeem1_ left
[10:36] <FROGGS> dsm: I guess that code thinks the :1 is the port: https://github.com/sergot/http-useragent/blob/master/lib/HTTP/UserAgent.pm6#L239

[10:36] <FROGGS> dsm: try page:80

[10:36] <FROGGS> dsm: and the fix would be to let HTTP::UserAgent use URI

[10:36] <FROGGS> sergot: ^^

[10:36] *** smls joined
[10:37] <smls> S17: «The anyof combinator creates a Promise that is kept whenever any of the specified Promises are kept. If the first promise to produce a result is instead broken, then the resulting Promise is also broken.»

[10:37] <smls> ^^ Is that correct?

[10:37] <dsm> awesome

[10:37] <smls> Does this mean that Promise.anyof basically just responds to the *first* promise that finishes (no matter if kept or broken), and ignores the rest?

[10:37] <FROGGS> smash: I don't think so

[10:37] <FROGGS> err smls 

[10:37] <FROGGS> sorry smash 

[10:38] <smls> I would have assumed (like moritz, judging from p6doc) that the promise returned by Promise.anyof is only broken, when *none* of the input promises were kept...

[10:38] <FROGGS> smls: I'd think that the first sentence is right, but not the second

[10:38] <FROGGS> smls: exactly what I am thinking

[10:38] <smls> m: my ($a, $b) = Promise.new xx 2; my $any = Promise.anyof($a, $b); $a.break; $b.keep; sleep 0.1; say $any.status

[10:38] <camelia> rakudo-moar c94e16: OUTPUT«Broken␤»

[10:39] <FROGGS> hmmmm

[10:39] <smls> hmmmm indeed...

[10:39] <lizmat> looking at the code

[10:40] <lizmat> anyof indeed will break as soon as the first breaks, and succeed as soon as the first succeeds

[10:40] <FROGGS> that is not what 'any' implies

[10:40] <smls> If that's intended behavior, shouldn't it be named "first" or "earliest", rather than "any"?

[10:40] *** vendethiel left
[10:40] <lizmat> hmmm...

[10:41] <smls> Also, isn't that inconsistent with .allof?

[10:41] <lizmat> hmmm....

[10:42] <lizmat> m: my $p = Promise.new; my $v = $p.vow; $v.break; $v.keep; say $p.status

[10:42] <camelia> rakudo-moar c94e16: OUTPUT«Too few positionals passed; expected 2 arguments but got 1␤  in method break at src/gen/m-CORE.setting:20779␤  in block <unit> at /tmp/w6VsP1d0yh:1␤␤»

[10:42] <lizmat> m: my $p = Promise.new; my $v = $p.vow; $v.break(666); $v.keep(42); say $p.status

[10:42] <camelia> rakudo-moar c94e16: OUTPUT«Kept␤»

[10:42] <lizmat> hmmm... it appears you can unbreak a vow

[10:44] <masak> good antenoon, #perl6

[10:44] <lizmat> no, looking at it further in the case of anyof

[10:45] <masak> lizmat: I'm surprised a vow can be unbroken. I wonder if there's a use case or a reason for that, or if it's an oversight.

[10:45] <lizmat> masak: I'm not sure either

[10:45] * lizmat really has to go on errands now

[10:45] <lizmat> later&

[10:49] <masak> moritz++ # saving advent by swapping posts

[10:49] *** doublelel joined
[11:06] <masak> is there a working example somewhere of a rule calling a method in a Perl 6 grammar?

[11:07] <timotimo> all i can think of is EXPR, but that's nqp code

[11:08] <masak> yes, I've already found that :)

[11:09] <timotimo> maybe we should build a semantic search tool for the ecosystem

[11:09] <timotimo> kind of like debian code search

[11:10] <masak> I'd settle for a dumb but accurate search tool :P

[11:10] <masak> ah, src/core/Cursor.pm seems to be full of clues.

[11:11] <timotimo> right, a whole lot of the built-in rules are actually methods, right?

[11:11] <masak> the whole expression parser is very method-y.

[11:12] <FROGGS> masak: you call a method just like you call a subrule

[11:12] <timotimo> i think he wants to know how to treat the $/ that comes in

[11:12] <masak> FROGGS: that much is clear.

[11:12] <FROGGS> you can look at ws and _ws for example

[11:12] <masak> ok, will do.

[11:12] <FROGGS> _ws is a method, and ws is a token

[11:13] <masak> is it always thus? a method must eventually bottom out in a rule?

[11:15] <timotimo> don't think so

[11:15] <FROGGS> also, FOREIGN_LANG is a very good example

[11:15] <FROGGS> it even has comments :o)

[11:16] <FROGGS> it builds to be returned cursors, either for NQP or for Perl 6

[11:17] <FROGGS> the only 'rule' for methods that invoked like /<foo>/ is, that they have to return a cursor

[11:17] <FROGGS> that are*

[11:18] <FROGGS> they can return a cursor via returning the result from a token/rule, or they build one, like in FOREIGN_LANG

[11:19] <masak> oh, yes.

[11:20] <masak> FROGGS++

[11:20] <masak> I'm glad I asked. :)

[11:26] *** atroxaper joined
[11:28] *** Alina-malina left
[11:28] *** ptc_p6 left
[11:29] *** Alina-malina joined
[11:29] <dalek> doc: 524ff27 | smls++ | lib/Type/ (2 files):

[11:29] <dalek> doc: Small tweaks and typo corrections for Promise/Channel

[11:29] <dalek> doc: review: https://github.com/perl6/doc/commit/524ff27452

[11:32] *** atroxaper left
[11:37] *** smls left
[11:44] *** mvuets joined
[11:47] *** rurban1 joined
[11:49] <masak> Woodi: regarding the imperative/declarative discussion the other day -- some people claim that the distinction does not make sense, and may even be hurtful or oversimplistic.

[11:49] <masak> but I think the imporant ideal is this: as "natural" as imperative models seem, they have repeatedly turned out to be difficult to scale.

[11:50] <masak> informally, "statefulness gets in the way".

[11:50] <masak> in a number of ways, actually. everything from private details leaking out of their scopes, to the von Neumann bottleneck, to a general inability to see the forest for the trees.

[11:51] <masak> declarative solutions show a way out of that. the focus becomes on the "what", not on the "how". in a sense, the "what" was what we were interested in all along.

[11:51] <xiaomiao> masak: but declarative is hard to get right

[11:52] *** rurban1 left
[11:52] <xiaomiao> with imperative you can always just beat it into the needed shape

[11:52] <sergot> dsm++ FROGGS++ I will fix it

[11:52] <sergot> hi #perl6 o/

[11:52] <masak> \o

[11:53] <masak> xiaomiao: no argument there. and it all depends on the context what you'll actually use.

[11:53] <masak> xiaomiao: keep in mind, even out imperative solutions are fairly advanced these days. OO, used well, gives us a modicum of abstraction and privacy.

[11:57] <xiaomiao> OO has been misused so much

[12:00] <masak> poker has been played badly by so many.

[12:01] <masak> words have been used in less-than-awesome ways so many times.

[12:03] <FROGGS> word

[12:05] *** isBEKaml left
[12:13] *** rurban1 joined
[12:13] *** rurban1 left
[12:18] *** FROGGS left
[12:22] *** Mso150 left
[12:30] *** atroxaper joined
[12:32] *** jack_rabbit left
[12:32] *** erkan left
[12:34] *** jack_rabbit joined
[12:35] *** erkan joined
[12:35] *** erkan left
[12:35] *** erkan joined
[12:35] <xiaomiao> "good idea, bad implementation" 

[12:35] *** atroxaper left
[12:37] *** vendethiel joined
[12:40] *** ptc_p6 joined
[12:50] *** psch joined
[12:55] <masak> it's easy to *think* you've gotten the point of OO, and to run off and use it in a cargo-culting rather than useful way.

[12:58] *** ptc_p6 left
[12:58] <masak> it's easy to stop after "classes, fields, getters and setters" and not move on to SOLID principles, architectural concerns, and design.

[13:00] <vendethiel> masak: if you try to tell CL folks "you've used OO" they'll snicker at you :p

[13:01] *** BenGoldberg joined
[13:02] <dsm> what's the perl6-ish way to get a list of .ords of every single character of string?

[13:02] <masak> m: say "OH HAI".ords

[13:02] <camelia> rakudo-moar c94e16: OUTPUT«79 72 32 72 65 73␤»

[13:03] * masak can't believe he just recommended .ords ;)

[13:03] <masak> vendethiel: I guess there is a sense in which both OO and FP are trying to do the same thing, but going about it in different ways.

[13:04] <masak> vendethiel: certainly the distinctions break down a bit when you start finding mappings between OO things and FP things.

[13:04] * vendethiel mumbles something about "objects being the poor man's closures, and closures being the poor man's objects" to masak

[13:04] <masak> right.

[13:04] <masak> I wanted to say something like that to woolfy yesterday, but was overridden by my determination not to explain closures. :)

[13:06] <dsm> masak: what if I want to convert only [a-z]?

[13:07] <vendethiel> masak: I dunno, OO is like "I'm complicated, must mean I'm good right"

[13:07] <masak> (1) are you sure it's only ASCII?

[13:07] <dsm> sure

[13:07] <masak> m: say "OH HAI".comb(/<[a..z]>/)>>.ord

[13:07] <camelia> rakudo-moar c94e16: OUTPUT«␤»

[13:07] <masak> m: say "OH HAI".comb(/<[a..zA..Z]>/)>>.ord

[13:07] <camelia> rakudo-moar c94e16: OUTPUT«79 72 72 65 73␤»

[13:08] <masak> (2) ^

[13:08] <vendethiel> .oO( I don't even know what .comb() does, but at this point I'm too afraid to ask )

[13:08] <masak> vendethiel: I think one of OO's biggest weaknesses is that it's founded on intuition, not on theory.

[13:08] <dsm> thank you.

[13:08] <masak> vendethiel: $s.comb($rx) gives all (non-overlapping) occurrences of $rx in $s

[13:09] <masak> vendethiel: it's the figure-ground opposite of $s.split($rx)

[13:09] <masak> vendethiel: I use .comb all the time, much of the time without giving it a regex (thus splitting it up into characters)

[13:10] <vendethiel> masak: non-overlapping?

[13:10] <vendethiel> m: say "hello".comb.perl

[13:10] <camelia> rakudo-moar c94e16: OUTPUT«("h", "e", "l", "l", "o").list␤»

[13:10] <masak> m: say "aaaaaa".comb(/aaa/) # two, not four

[13:10] <camelia> rakudo-moar c94e16: OUTPUT«aaa aaa␤»

[13:11] <masak> that's non-overlapping

[13:11] *** ptc_p6 joined
[13:12] <psch> "convert only [a-z]" doesn't mean "leave everything else in place"?

[13:12] <psch> m: say "OH HAI".trans: /(a..zA..Z)/ => { $0.ords } # this doesn't work yet though

[13:12] <camelia> rakudo-moar c94e16: OUTPUT«OH HAI␤»

[13:12] <masak> that's not how you do character classes.

[13:13] <psch> rigth

[13:13] <psch> m: say "OH HAI".trans: /(<[a..zA..Z]>)/ => { $0.ords } # this doesn't work yet though

[13:13] <camelia> rakudo-moar c94e16: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method ords at src/gen/m-CORE.setting:4046␤  in block <unit> at /tmp/HEA8Fp7Pkp:1␤␤»

[13:13] <psch> still not? :/

[13:13] <psch> i feel forgetful

[13:14] <masak> m: say "OH HAI".trans: /<[a..zA..Z]>/ => &ord

[13:14] <camelia> rakudo-moar c94e16: OUTPUT«Too few positionals passed; expected 1 argument but got 0␤  in sub ord at src/gen/m-CORE.setting:4112␤  in method next_substitution at src/gen/m-CORE.setting:7247␤  in method trans at src/gen/m-CORE.setting:7288␤  in block <unit> at /tmp/wGcBOCA4_7…»

[13:15] <masak> that would work, if that feature exists at all.

[13:15] <masak> I'm not sure. hold on, I'll check.

[13:15] <psch> S05-transliteration/trans.t:201

[13:15] <psch> if my spec is up to date or nothing changed

[13:16] <masak> yeah, found it in S05, too.

[13:16] <psch> s/spec/roast/

[13:16] <psch> says we need the block

[13:16] <masak> S05:4553

[13:16] <synopsebot> Link: http://perlcabal.org/syn/S05.html#line_4553

[13:16] <psch> https://github.com/rakudo/rakudo/pull/317

[13:17] <psch> that says i fixed it... :)

[13:17] <psch> although there was a point about runtime generation of grammars for .trans i think

[13:18] <masak> yeah, in a dream future.

[13:25] *** erkan left
[13:27] <psch> m: 6; $x = 123;say $x ~~ tr/1/4/ # this is also fixed in the adverb PR above

[13:27] <camelia> rakudo-moar c94e16: OUTPUT«Type check failed in assignment to '$!before'; expected 'Str' but got 'Int'␤  in block  at src/gen/m-CORE.setting:968␤  in method BUILDALL at src/gen/m-CORE.setting:951␤  in method bless at src/gen/m-CORE.setting:939␤  in method new at src/gen/m-CO…»

[13:27] *** erkan joined
[13:27] <psch> arguably should have had its own commit though

[13:28] *** ptc_p6 left
[13:28] <masak> aye.

[13:28] * masak .oO( not Cool )

[13:29] <psch> m: StrDistance.new(:before(1), :after(2))

[13:29] <camelia> rakudo-moar c94e16: OUTPUT«Type check failed in assignment to '$!before'; expected 'Str' but got 'Int'␤  in block  at src/gen/m-CORE.setting:968␤  in method BUILDALL at src/gen/m-CORE.setting:951␤  in method bless at src/gen/m-CORE.setting:939␤  in method new at src/gen/m-CO…»

[13:30] <psch> hrm, java's Constructor.newInstance() is weird :/

[13:33] *** Ugator left
[13:39] <psch> oh, nvm, the problem was actually that constructor descriptors don't contain the class it's called on 

[13:39] <psch> but obviously we get that as the first arg from the perl6 side

[13:39] <vendethiel> masak: well, I was looking for a screenshot "OO vs FP design principles", but since I can't find it...

[13:39] <vendethiel> masak: "The JVM ecosystem has a rich suite of tools that solve problems that don't exist in Haskell"

[13:41] <masak> and yet, people don't flock around Haskell... :)

[13:42] <vendethiel> hard to flock around something nobody teaches you

[13:42] <masak> that's not precisely what I want to say. hm, more like: that quote makes it sound like Haskell has strictly fewer problems than (languages in) the JVM ecosystem.

[13:42] <masak> could be Haskell is a neater solution. it probably is. but I'm pretty sure there is at least one problem somewhere better solved on the JVM.

[13:43] <vendethiel> okay, let's remove haskell from the equation.

[13:43] <vendethiel> The JVM sucks pretty badly in several different aspect, java being one of them

[13:44] <masak> the JVM shows its age in some ways, I guess.

[13:44] <masak> actually, I don't have that much direct experience with it.

[13:44] <masak> I know a fair bit of Java. I know Java is very limited.

[13:45] <vendethiel> I have hope, though, cause it looks like more and more, people are move off java.

[13:45] <masak> Java picks most of its OO inspiration from Smalltalk, but it does a fairly bad job borrowing the ideas from Smalltalk.

[13:46] <vendethiel> I severely disagree

[13:46] <masak> interesting.

[13:47] <vendethiel> java picks most of its OO from C++, which picked most of its OO from Algol

[13:49] <vendethiel> masak: that's a very loose definition of "OO", however, as self is probably more object-oriented than smalltalk (and it has prototypes instead of classes)

[13:50] *** ptc_p6 joined
[13:52] <vendethiel> masak: to be completly honest, I mostly refuse to use the terms "OO" and "FP" nowadays...

[13:52] <masak> well, they're tags for a lot of other related concepts.

[13:52] <masak> when teaching, it's almost impossible to avoid talking about them.

[13:53] <vendethiel> "tags" seems well-fited

[13:53] <vendethiel> but you can't define them.

[13:54] <masak> "The Tao that can be told is not the eternal Tao; The name that can be named is not the eternal name."

[13:58] *** ptc_p6 left
[14:00] *** erkan left
[14:02] <Woodi> hallo perl6 :)

[14:03] *** erkan joined
[14:03] *** erkan left
[14:03] *** erkan joined
[14:03] <masak> \o, Woodi 

[14:04] <Woodi> but Java get at least one thing good: GUI. C# also. I am a bit mad on Perl community becouse making GUI is relative hard here compared to Java and C#...

[14:05] <Woodi> do Tk was Perls attempt to make universal GUI system that not taked over World ?

[14:07] <Woodi> masak: but declarative part (teoretically) is also easy :) just make a "request" for something: in SQL or in restaurant: tomato soup and bloody steak pleas. and bear and coffe.

[14:07] <vendethiel> Woodi: I disagree. Java didn't get the GUI right, I don't know of a good GUI framework

[14:08] <Woodi> vendethiel: I think Swing is realy usefull and crosplatform stuff

[14:08] <masak> Woodi: 'just make a "request" for something' -- I don't see what point you are trying to make.

[14:08] <vendethiel> Woodi: it looks awful.

[14:09] <masak> Woodi: declarative is not about making requests. it's about establishing properties and relationships. the instructions happen somewhere else.

[14:09] <Woodi> vendethiel: it's cute :)

[14:09] <masak> vendethiel: I used to think Swing looked awful too. but IntelliJ actually looks quite decent on all platforms.

[14:09] <vendethiel> intellij made big big efforts to look decent

[14:10] <masak> then that's what it takes.

[14:10] <vendethiel> they built something else completly on top of swing...

[14:10] <Woodi> masak: so SELECT * FROM table isn't proper declarative thing ?

[14:10] <Woodi> vendethiel: Java is 1991 idea (probably), it cant be perfec thes days :)

[14:11] <vendethiel> ... so let's use something better:)

[14:11] <masak> Woodi: I have no idea what "proper declarative thing" means in your world :)

[14:12] <Woodi> masak: something blurry to fit to the desctiption on Wikipedia :)

[14:12] <masak> anyway, I'm not overly interested in pinning down exactly how declarative SQL is.

[14:14] *** nige joined
[14:15] <Woodi> declarative approach looks 1-level thing: you want something and implementation is just problem of someone else... and this is where imperative part comes in. eg. regular expressions: description of request and result comes out

[14:15] *** jack_rabbit left
[14:16] *** dj_goku_ left
[14:16] <masak> that's a bit like saying "a car is just handing off the problem of walking by foot to someone else".

[14:17] <masak> if you succeed with your declarative slang, not only have you lifted a bit of imperative boilerplate off your shoulders, you've made things so much more readable and accessible that it's a *qualitative* difference rather than a quantitative one.

[14:18] <masak> aka "I'd rather write a 20-line grammar than the underlying 1000-line loops and .substr calls"

[14:19] <masak> a good declarative language allows you to disregard the imperative parts, because *they are not that interesting* to the problem you want to solve.

[14:21] <Woodi> if I understand correctly then I agree with that... all hard work is implementations detail, or someones

[14:22] <Woodi> a bit despotic or bossy thing :)

[14:22] <masak> it's a kind of abstraction on the syntax level, I guess.

[14:22] <masak> it doesn't automatically imply that you delegate all the heavy lifting to *someone else*; just that the implementation behind the scenes is not what we're focusing on.

[14:23] *** atroxaper joined
[14:23] *** dj_goku joined
[14:24] <Woodi> masak: probably I can't find peace until I sure that "request" will be done right :) so I care about teory of implementation :)

[14:24] <Woodi> damn words...

[14:25] <masak> it's admirable that you want to look under the hood. and I'm not arguing against that -- quite the opposite.

[14:25] <masak> but the strength of a declarative approach -- or any mechanism of abstraction, really -- is that at any point, you can "tune out" the parts that have been abstracted away.

[14:26] <masak> human attention/brainpower is often the biggest bottleneck in programming.

[14:26] <Woodi> yes, I started today thinking: Makefile files are declarative or imperative :)

[14:27] <masak> I'd peg them as declarative. they declare the dependencies between tasks.

[14:27] <masak> they don't tell you in which order to run the tasks.

[14:27] <masak> they induce a DAG of tasks. :)

[14:27] *** atroxaper left
[14:30] <Woodi> Makefiles tend to grow and starts to be complicated. maybe new layer of abstraction could help...

[14:31] <masak> you mean, like a Configure.pl ? :)

[14:33] <Woodi> I was thinking about inside Makefile thing... or some UI, still thinking...

[14:33] <masak> Woodi: you remind me of me when I was younger :)

[14:34] <Woodi> but TimToady mentioned makefiles today, was it about NativeCalls maybe ? :)

[14:34] <Woodi> masak: I'm way to young for my age :)

[14:40] *** erkan left
[14:41] <Woodi> .so.X again tripped on NCurse case, which probably have bugged or complicated package on Debian. I wonder what shared libraries should be located on *nixes or *nuxes thes days... a) .so alone usually works; b) do multiarch systems use .so.X ?; c) do we need to support .so.X.Y.Z or more complicated cases ? this can result in loading "first found" library

[14:41] *** nige left
[14:42] *** erkan joined
[14:42] <Woodi> d) do parsing linker scripts is a work for NativeCall or should be done by system ?

[14:47] *** vendethiel left
[14:52] <masak> could someone explain this... grammar oddity to me?

[14:52] <masak> m: grammar G { rule TOP { <term> [<infix> <term>]* }; token term { "T" }; token infix { "+" } }; say ?G.parse("T + T + T")

[14:52] <camelia> rakudo-moar c94e16: OUTPUT«False␤»

[14:52] <masak> m: grammar G { rule TOP { <term> [<infix> <term>]* }; rule term { "T" }; token infix { "+" } }; say ?G.parse("T + T + T")

[14:52] <camelia> rakudo-moar c94e16: OUTPUT«True␤»

[14:53] <masak> I'm pretty sure I haven't discovered a bug or anything (*gasp*).

[14:53] <masak> I just want to make it clear to myself why it matters whether term is a rule or token here.

[14:54] <masak> I know the whitespace rules changed sometime in 2013. maybe I haven't fully internalized the new rules.

[14:55] <masak> m: grammar G { rule TOP { <term> [<infix> <term> <.ws>]* }; token term { "T" }; token infix { "+" } }; say ?G.parse("T + T + T")

[14:55] <camelia> rakudo-moar c94e16: OUTPUT«True␤»

[14:55] <masak> this also works.

[14:55] <psch> masak: http://design.perl6.org/S05.html#line_380

[14:55] * masak reads

[14:56] <psch> turning term into a rule gives you the "<.ws> $ <.ws>" there

[14:56] <masak> doesn't seem applicable. TOP is a rule in both of my first two evals.

[14:56] <masak> and yet the result differs.

[14:56] <masak> try again :)

[14:57] <psch> tokem term vs rule term was the first case, no? :)

[14:57] <masak> yes.

[14:57] <masak> but you're talking about TOP.

[14:57] <psch> no, i'm just referencing an example of the difference between token and rule that uses TOP

[14:57] <masak> I think the paragraph staring with "Specifically, " after that is relevant, though.

[14:58] <masak> aha.

[14:58] <masak> m: grammar G { rule TOP { <term> [<infix> <term>]* }; rule term { "T" }; token infix { "+" } }; say ?G.parse("T + T + T")

[14:58] <camelia> rakudo-moar c94e16: OUTPUT«True␤»

[14:58] <masak> m: grammar G { rule TOP { <term> [<infix> <term>]* }; rule term { "T"}; token infix { "+" } }; say ?G.parse("T + T + T")

[14:58] <camelia> rakudo-moar c94e16: OUTPUT«False␤»

[14:58] <masak> yeah. got it.

[14:59] <masak> the whitespace after the "T" in 'rule term' is significant. that's the difference.

[14:59] <masak> and that's why inserting '<.ws>' after '<term>' helped, too.

[14:59] <masak> ok, confusion resolved.

[15:00] <masak> psch++

[15:03] *** erkan left
[15:07] *** erkan joined
[15:07] *** erkan left
[15:07] *** erkan joined
[15:26] *** doublelel left
[15:29] *** raiph joined
[15:30] * masak has the privilege to remind himself of the workings of an operator precedence parser

[15:33] *** vendethiel joined
[15:40] <sivoais> shouldn't <https://en.wikipedia.org/wiki/Gradual_typing> list Perl 6?

[15:40] <masak> yes.

[15:40] <masak> feel free to add it.

[15:41] <sivoais> will do! \o/

[15:41] *** FROGGS joined
[15:43] * masak finds that many times he writes 'return' instead of 'make' inside action methods

[15:43] <timotimo> but facebook invented gradual typing

[15:43] <masak> was there a reason for not just returning the ast in action methods?

[15:43] <masak> hm, I guess that wouldn't be possible inside {} blocks in rules, tho'

[15:44] <FROGGS> masak: it does not return it, that might be the reason :o)

[15:44] <FROGGS> and there is code that make-s something, and then does other stuff

[15:51] <psch> m: grammar Foo { token TOP { "a"+ } }; class FooActs { method TOP($match) { make "an 'a'" } }; my $a = Foo.parse("aa", :actions(FooActs.new)); say $a.perl 

[15:51] <camelia> rakudo-moar c94e16: OUTPUT«Cannot bind attributes in a type object␤  in sub make at src/gen/m-CORE.setting:13964␤  in method TOP at /tmp/CxSEjGevNH:1␤  in any !reduce at gen/moar/stage2/QRegex.nqp:1241␤  in any !cursor_pass at gen/moar/stage2/QRegex.nqp:1202␤  in regex TOP…»

[15:51] <psch> similarly to the "i want to ~~ regex in an actions method"

[15:53] <psch> m: grammar Foo { token TOP { "a"+ } }; class FooActs { method TOP($match) { my $/ := $match; make "an 'a'" } }; my $a = Foo.parse("aa", :actions(FooActs.new)); say $a.perl 

[15:53] <camelia> rakudo-moar c94e16: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $/␤    at /tmp/1fVZaTwh0z:1␤    ------> [32ms FooActs { method TOP($match) { my $/ :[33m⏏[31m= $match; make "an 'a'" } }; my $a = Foo[0m␤Match.new(orig => "aa", from => 0, to => 2, ast => "a…»

[15:53] *** pecastro joined
[15:53] <psch> ... yeah

[15:55] <psch> action class methods having to be that special feels a bit weird to me, i gotta say

[15:58] *** raiph left
[16:07] *** raiph joined
[16:11] *** zakharyas joined
[16:13] *** atroxaper joined
[16:18] *** broquain1 joined
[16:19] *** pecastro left
[16:19] *** zakharyas left
[16:19] *** atroxaper left
[16:19] *** bjz_ joined
[16:21] *** spider-mario_ joined
[16:22] *** arnsholt_ joined
[16:22] <vendethiel> moritz: backlogging only now

[16:22] *** spider-mario left
[16:22] *** spider-mario_ is now known as spider-mario

[16:23] <vendethiel> moritz: I got a bit stuck in what I wanted to do :(

[16:23] *** bartolin_ joined
[16:23] *** hahainte1net joined
[16:23] *** skaufman_ joined
[16:23] *** bartolin_ left
[16:28] <vendethiel> wait... unless...

[16:28] *** [Sno] left
[16:28] <vendethiel> m: subset File of Str where *.IO.e || die "critical error"; say "foo" ~~ File

[16:28] <camelia> rakudo-moar c94e16: OUTPUT«False␤»

[16:28] <vendethiel> ha :(

[16:29] *** darutoko- joined
[16:30] *** raiph left
[16:30] *** jercos left
[16:30] *** eiro left
[16:30] *** labster left
[16:30] *** DarthGandalf left
[16:30] *** bjz left
[16:30] *** bartolin left
[16:30] *** ribasushi left
[16:30] *** broquaint left
[16:30] *** ribasushi_ joined
[16:30] *** ribasushi_ is now known as ribasushi

[16:31] *** immortal joined
[16:31] *** immortal left
[16:31] *** immortal joined
[16:32] *** isacloud joined
[16:32] *** dj_goku_ joined
[16:33] *** carlin left
[16:33] *** gfldex left
[16:33] *** ruoso_ joined
[16:33] *** japhb_ joined
[16:33] *** clkao__ joined
[16:33] *** ugexe_ joined
[16:34] *** lue left
[16:34] *** prammer_ left
[16:34] *** Spot__ left
[16:34] *** isacloud_ left
[16:34] *** darutoko left
[16:34] *** clkao_ left
[16:34] *** petercommand left
[16:34] *** ugexe left
[16:34] *** Sqirrel left
[16:34] *** kaare__ left
[16:34] *** telex left
[16:34] *** dylanwh left
[16:34] *** nine left
[16:34] *** ruoso left
[16:34] *** integral_ left
[16:34] *** molaf_ left
[16:34] *** slavik left
[16:34] *** japhb left
[16:35] *** isacloud is now known as isacloud_

[16:35] *** clkao__ is now known as clkao_

[16:35] *** gfldex joined
[16:35] *** carlin joined
[16:36] *** dana joined
[16:36] *** Spot__ joined
[16:36] *** btyler_ joined
[16:36] *** dana is now known as Guest68514

[16:37] *** bjz_ left
[16:37] *** dj_goku left
[16:38] *** dagurval joined
[16:38] *** rhr_ joined
[16:39] *** telex joined
[16:40] *** dwarring joined
[16:42] *** skaufman_ left
[16:42] *** Alina-malina left
[16:42] *** Isp-sec left
[16:42] *** noganex_ left
[16:42] *** raydiak left
[16:42] *** colomon left
[16:42] *** yakudza left
[16:42] *** Grrrr left
[16:42] *** Alula left
[16:42] *** anaeem1 joined
[16:43] *** kaare_ joined
[16:43] *** btyler left
[16:43] *** skaufman1 joined
[16:43] *** prime- joined
[16:43] *** felher_ joined
[16:43] *** muraiki left
[16:44] *** Rounin joined
[16:44] *** noganex_ joined
[16:44] *** colomon joined
[16:44] *** yakudza joined
[16:44] *** molaf_ joined
[16:44] *** bjz joined
[16:44] *** jercos joined
[16:45] *** woolfy left
[16:45] *** dalek left
[16:45] *** [TuxCM] left
[16:45] *** timotimo joined
[16:45] *** dalek joined
[16:45] *** woolfy joined
[16:45] *** Vlavv left
[16:45] *** telex left
[16:45] *** ChanServ sets mode: +v dalek

[16:45] *** muraiki joined
[16:45] *** yogan joined
[16:45] *** Celelibi left
[16:45] *** erkan left
[16:45] *** prime left
[16:45] *** nige joined
[16:46] *** integral joined
[16:46] *** slavik joined
[16:46] *** Grrrr joined
[16:46] *** petercommand joined
[16:46] *** prammer joined
[16:46] *** nine joined
[16:46] *** Isp-sec joined
[16:46] *** telex joined
[16:46] *** petercommand is now known as Guest67097

[16:47] *** pnu joined
[16:47] *** DarthGandalf joined
[16:49] *** Vlavv joined
[16:49] *** [TuxCM] joined
[16:50] *** ilogger2 joined
[16:50] *** ChanServ sets mode: +v ilogger2

[16:50] *** isacloud_ joined
[16:50] *** clkao_ joined
[16:50] *** Spot__ joined
[16:51] *** dwarring joined
[16:51] *** Celelibi joined
[16:52] *** pnu joined
[16:53] *** Guest67097 joined
[16:53] *** Guest67097 is now known as petercommand

[16:59] *** synopsebot joined
[16:59] *** dylanwh joined
[17:03] *** Alula joined
[17:04] *** lue joined
[17:05] *** Alina-malina joined
[17:05] *** Alina-malina left
[17:05] *** Alina-malina joined
[17:06] <timotimo> the autogenerated ro and rw accessors do the attribute access indirectly through a string grabbed from a lexical that's put into the closure ...

[17:06] *** dolmen joined
[17:11] <timotimo> i'm not terribly happy about this, but what can i do

[17:11] <timotimo> i don't really want to put an EVAL in there, and i'm not sure if macros will work that early

[17:14] *** anaeem1 joined
[17:16] *** Sqirrel joined
[17:24] *** dolmen left
[17:31] <psch> http://imgur.com/rOVcIup \o/

[17:31] *** Ven joined
[17:32] *** Ven left
[17:35] <psch> as in, shortname constructors work

[17:35] <timotimo> yay

[17:36] *** anaeem1 left
[17:36] <psch> leaving them positional seems like the only sane way to go, too

[17:37] <psch> now there's fields and method resloution order left

[17:37] <psch> at least from what i can see right now

[17:37] <timotimo> :)

[17:37] <timotimo> i'm glad

[17:41] <psch> me too

[17:41] <psch> although i don't actually have a use-case... :)

[17:41] <timotimo> that makes stuff harder, believe me

[17:41] <timotimo> i've had trouble being a good gtk::simple maintainer

[17:45] <psch> yeah, doubly so for maintaining, in my opinion

[17:46] <timotimo> dubly

[17:47] <psch> i mean, just getting this jvm interop stuff working was mostly motivated by "it doesn't work currently", with a side of "but it would be cool if it did"

[17:47] <timotimo> :S

[17:47] <psch> i'm dreading trying to make it fast :P

[17:48] <timotimo> hehe

[17:48] <timotimo> time to become pessimistic about perl6's future :P

[17:48] <psch> a big thing for that is caches for methods and constructors

[17:49] <psch> don't people who want fast perl6 use mvm anyway..? ;)

[17:49] <timotimo> well, yeah, but mvm is also not frighteningly fast

[17:54] <psch> what's the adage? "make it work, make it right, wait for moore's law to make it fast" or something... :)

[17:56] <psch> fwiw, i do know how to make the jvm interop a tad faster for repeated calls to the same method, but i don't think i know where to start to make perl6-j in general fastert

[17:56] <psch> which i guess is more important than having a slightly faster interop - which is only faster when you're always calling the same foreign method

[18:04] *** raiph joined
[18:05] *** ab5tract joined
[18:07] *** atroxaper joined
[18:07] <timotimo> yes

[18:07] <FROGGS[mobile]> psch++

[18:09] <FROGGS[mobile]> psch: btw, it was discussed and decided that it should be :from<Java> instead

[18:09] <FROGGS[mobile]> like it should be :from<C> and not :from<c>

[18:10] <psch> FROGGS[mobile]: that does make sense.  i'll patch the ModuleLoader accordingly

[18:11] <FROGGS[mobile]> please allow the old way with a deprecation message 

[18:11] <psch> hm, not sure how to do that

[18:11] <psch> afaict, we have a hash that holds the argument to :from<> as keys

[18:12] <psch> and the perl6 ModuleLoader loads the corresponding module loader from the value

[18:12] <psch> as in, i'm not sure how to adapt the normal 'is DEPRECATED' way of doing it for that :)

[18:18] <psch> i guess i'll just shove it in an if and comment it with DEPRECATED or somesuch

[18:22] <TimToady> m: grammar G { rule TOP { <term> [<infix> <term> ]* }; token term { "T" }; token infix { "+" } }; say ?G.parse("T + T + T")

[18:22] <camelia> rakudo-moar c94e16: OUTPUT«True␤»

[18:22] <TimToady> masak: that's how I'd've written it

[18:23] <TimToady> well, except I'd really write it like this:

[18:23] <TimToady> m: grammar G { rule TOP { <term> +% <infix> }; token term { "T" }; token infix { "+" } }; say ?G.parse("T + T + T")

[18:23] <camelia> rakudo-moar c94e16: OUTPUT«True␤»

[18:24] <TimToady> Whitespace only matters in the rule, so if you want the rule to control whitespace matching, then you have to pay attention to where the whitespace is in the rule.  That is all.

[18:27] <TimToady> well, I'd probably also throw a ^ in there to allow whitespace after the ^

[18:28] <TimToady> m: grammar G { rule TOP { <term> +% <infix> }; token term { "T" }; token infix { "+" } }; say ?G.parse(" T + T + T")

[18:28] <camelia> rakudo-moar c94e16: OUTPUT«False␤»

[18:28] <TimToady> m: grammar G { rule TOP { ^ <term> +% <infix> }; token term { "T" }; token infix { "+" } }; say ?G.parse(" T + T + T")

[18:28] <camelia> rakudo-moar c94e16: OUTPUT«True␤»

[18:30] <TimToady> it's only the whitespace after actual matchers that matters, so you have to put an actual matcher (^ in this case) to match the leading whitespace

[18:31] *** raydiak joined
[18:31] <FROGGS[mobile]> psch: just nqp::say the deprecation message? 

[18:31] <TimToady> the other oddity of the simplification is that it became useful to clump +% as a mental unit to get whitespace after the left term

[18:32] <TimToady> so I always write it like that, even in tokens

[18:32] <TimToady> (where it doesn't matter)

[18:33] <psch> FROGGS[mobile]: yeah, that's probably what i'd have to do here.  it feels a bit wasteful, considering we have this awesome tool for deprecations...

[18:34] *** ab5tract left
[18:35] <psch> but heck if i know if i even can use it from the ModuleLoader... i'd assume "maybe" :)

[18:39] *** czara joined
[18:41] *** nine joined
[18:43] *** erkan joined
[18:43] *** erkan left
[18:43] *** erkan joined
[18:57] *** czara left
[19:00] *** dakkar joined
[19:00] <raydiak> m: subset Foo of Str|Int; my Foo $foo; say($foo = "foo"); say($foo = 123);

[19:00] <camelia> rakudo-moar c94e16: OUTPUT«foo␤Type check failed in assignment to '$foo'; expected 'Foo' but got 'Int'␤  in block <unit> at /tmp/_VIozDslNT:1␤␤»

[19:00] <masak> TimToady: is it significant that there is whitespace before the +% ?

[19:00] <raydiak> ^^ those should either both work or both fail, shouldn't they? (idk which)

[19:01] <TimToady> masak: no, it is significant that there is whitespace after the <term> :)

[19:01] <TimToady> raydiak: I don't think that's parsing hte way you think it is

[19:02] <raydiak> m: subset Foo of (Str|Int); my Foo $foo; say($foo = "foo"); say($foo = 123);

[19:02] <camelia> rakudo-moar c94e16: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/hJ67ndUwBa␤Missing semicolon.␤at /tmp/hJ67ndUwBa:1␤------> [32msubset Foo of [33m⏏[31m(Str|Int); my Foo $foo; say($foo = "foo"[0m␤    expecting any of:␤        statement list␤     …»

[19:02] <TimToady> you're getting (subset Foo of Str) | Int

[19:02] <raydiak> yeah that's not what I meant :)

[19:02] <TimToady> which ought to complain about useless use of | in a sink context

[19:03] <TimToady> m: 1 | 2

[19:03] <camelia> rakudo-moar c94e16: ( no output )

[19:03] <TimToady> m: 1 | 2; 3

[19:03] <camelia> rakudo-moar c94e16: ( no output )

[19:03] <TimToady> m: 1 + 2; 3

[19:03] <camelia> rakudo-moar c94e16: OUTPUT«WARNINGS:␤Useless use of "+" in expression "1 + 2" in sink context (line 1)␤»

[19:03] <TimToady> like that

[19:03] <TimToady> so a bug of sorts

[19:03] <raydiak> ah

[19:03] <TimToady> anyway, 'of' requires a type name, not an expression

[19:04] *** dakkar left
[19:04] *** dakkar joined
[19:05] <raydiak> I should be using where instead, them?

[19:05] <TimToady> that's an odd parse error in the second case

[19:05] <raydiak> *then

[19:05] <TimToady> yes

[19:05] <TimToady> std: subset Foo of (Str|Int); my Foo $foo; say($foo = "foo"); say($foo = 123);

[19:05] <camelia> std 76ccee1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Invalid type name at /tmp/PINVt1WTMJ line 1:␤------> [32msubset Foo of [33m⏏[31m(Str|Int); my Foo $foo; say($foo = "foo"[0m␤    expecting typename␤Parse failed␤FAILED 00:00 135m␤»

[19:05] <TimToady> that's a much better message

[19:06] <TimToady> I have no idea what rakudo is thinking there...

[19:06] <raydiak> do we have something like deparse?

[19:06] <raydiak> well, I guess if it doesn't compile that wouldn't necessarily help

[19:07] <TimToady> expecting a statement list after 'of' is just completely bogus

[19:08] <TimToady> it probably thinks there's a missing semicolon after 'Foo', but in that case the ⏏ is misplaced

[19:08] *** pmurias joined
[19:08] <pmurias> hi

[19:08] <raydiak> the way I read it, I expects the ; where it found 'of' instead

[19:09] <raydiak> but yeah it'd kinda make more sense to put the cursor where the ; would go, given how it's worded

[19:09] <TimToady> yes, but it should point to the beginning of the thing, not the end

[19:09] <raydiak> \o pmurias 

[19:09] <TimToady> and it should really be committing to the typename after it sees 'of'

[19:10] <TimToady> not backtracking to the 'Foo'

[19:10] <raydiak> ah...I definitely run into inconsistencies with that thing, I kinda use it more like a fuzzy "around here somewhere" clue

[19:10] <TimToady> that's...not what we want...

[19:11] <pmurias> dalek stopped informing about commits?

[19:11] <raydiak> sounds like a whole 'nother group of tests could be written

[19:11] * TimToady was just assuming nobody was committing...

[19:12] <pmurias> TimToady: I just implemented contextual/dynamic variables in nqp-js, and dalek kept silent

[19:13] <pmurias> psch: re making perl6-j is speed the thing that's keeping it from being used? 

[19:14] <pmurias> * psch: is slowness keeping  perl6-js from being used?

[19:16] <psch> pmurias: i'd say startup is one reason, yes.  10 seconds on my machine for 'perl6-j -e1' is too much to use it for the odd script

[19:16] <raydiak> the url for the github hook to dalek changes with the new server...did the nqp-js hook get updated?

[19:16] <pmurias> 10 seconds... :/

[19:17] <psch> pmurias: i don't have any real data though, just the anecdote of myself not using perl6-j for scripting :)

[19:19] <pmurias> why is the startup so slow?

[19:20] <psch> pmurias: probably partly because we're reflecting and writing bytecode quite much

[19:20] <psch> although the jvm in general is said to take a while to get warm i think

[19:22] <psch> i have even less data for that though.  i've read reflections are slow, but org.objectweb.asm is supposedly rather fast

[19:23] <psch> maybe we can get the startup time down by shifting to asm instead of reflect where possible, but those two packages don't really serve the exact same purpose

[19:25] <pmurias> isn't it possible to generate bytecode at compile time?

[19:30] <psch> not in all cases, i don't think

[19:31] <psch> but i'm not exactly sure how it works

[19:31] <psch> m: say *.REPR for Str, Int, Num, Complex # these might all have different REPRs instances on the jvm

[19:31] <camelia> rakudo-moar c94e16: OUTPUT«P6opaque␤P6opaque␤P6opaque␤P6opaque␤»

[19:32] *** denis_boyun_ joined
[19:32] <psch> in my test code for jvm-interop i regularly come across __P6Opaque72__ or similarly spelled

[19:33] <psch> no idea how bad space requirements could get, and we'd likely shift potential performance problems towards the jvm ClassLoaders

[19:34] <psch> keep in mind i haven't really look much at all of that, i've just looked through it a bit to figure out how to implement shortname methods and constructors for interop :)

[19:38] <raydiak> so I was trying to read about object destruction last night, and noticed it isn't really covered in the synopses, and saw DESTROY referred to as a 'fossil' in the commit log

[19:38] <raydiak> so my question is how can I run some code when an object would be GC'd?

[19:39] *** Mso150 joined
[19:40] *** denis_boyun_ left
[19:41] <raydiak> specifically, I want to take the object and stuff it away somewhere else instead of destroying it

[19:44] *** labster joined
[19:47] *** liztormato joined
[19:47] <liztormato> raydiak: afaik, DESTROY is only implemented on Moar

[19:48] <liztormato> Also: there is no guarantee when it will be run

[19:48] <liztormato> The gc decides when, basically

[19:48] *** FROGGS_ joined
[19:49] <liztormato> Please use the LEAVE phaser if you want to be sure when cleanup code gets run

[19:50] *** Sqirrel left
[19:50] <liztormato> That works on all backends

[19:50] *** Mso150 left
[19:51] <raydiak> I was going to try to write a role that implements a bless and DESTROY which re-uses old objects from a cache rather than creating new ones when possible, was the idea

[19:52] <dalek> rakudo/nom: fb9127c | TimToady++ | src/Perl6/Grammar.nqp:

[19:52] <dalek> rakudo/nom: commit to trait mods to avoid misleading messages

[19:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb9127cbd8

[19:52] <TimToady> well, it worked there...

[19:53] <liztormato> raydiak: why would you do that?

[19:54] <raydiak> liztormato: lazy optimization...in simple cases you could just add 'does Reusable' to your class and get a speedup

[19:54] * raydiak waits for ensuing lecture on proper software architecture

[19:55] <liztormato> Not really. It just feels like a premature opt

[19:55] *** user3 joined
[19:56] *** Mso150 joined
[19:56] *** user3 left
[19:56] <raydiak> maybe...was just looking at a benchmark and thinking about how my mental interpreter doesn't create a new data structure for every loop even though that's what the code says...it re-uses one object over and over

[19:57] <raydiak> b/c turning a constructor into a mutator for the benchmark made it more than an order of magnitude faster

[19:57] <raydiak> (which of course made it an unfair benchmark, but that's not the point)

[20:02] *** liztormato left
[20:06] *** liztormato joined
[20:07] *** atroxaper left
[20:08] <TimToady> so...basically you're confusing 'my' with 'state', and wish the computer would too...

[20:09] <moritz> \o

[20:09] <moritz> FROGGS_: how's your advent post coming along?

[20:09] <FROGGS_> moritz: quite well I think

[20:12] * sjn is enjoying the advent posts a lot

[20:12] <liztormato> sjn: o/

[20:13] <sjn> liztormentor|liztormato|liz o/

[20:13] <sjn> :)

[20:13] <liztormato> ;-)

[20:14] <liztormato> It's actually inspired by a Yes album

[20:15] <raydiak> I'm not sure if "confused" applies in this case, unlike most of my thoughts.  it's an intentional modification that I make at compile time when I'm determine to my own satisfaction that logical consistency is uncompromised by the transformation.  isn't that what optimization is, for at least one point of view?

[20:15] <liztormato> I guess so

[20:16] <raydiak> s/I\'m //

[20:16] <sjn> raydiak: your modification could also be a pessimization, even if consistency is perserved. :)

[20:17] * sjn loves dropping into the middle of conversations without having any clue about what they're about

[20:17] <raydiak> unfortunately doing it at compile time is a bit beyond my scope at this time, so I was trying to emulate the idea in the first way that seemed obvious to my limited toolbox

[20:18] * raydiak is a bit fuzzy on the precise meaning of "pessimization" in this context

[20:20] <liztormato> Cost > income

[20:20] <raydiak> if you mean that, done wrong, it could easily be slower than just creating a new object, then sure that's true...so too with many optimizations

[20:21] <raydiak> but don't you think that in a substantial number of cases, popping a ref off an array and filling the properties in could be faster than destroying that object and blessing a new one?

[20:22] <raydiak> seemed kinda obvious to me, but maybe I poorly estimate the relative speed of such operations...???...

[20:27] <liztormato> It's just that I feel you may be confusing / disabling other optimisations that way

[20:27] <liztormato> jnthn would know

[20:27] <raydiak> the way I imagined it initially was a class trait..."is reusable" or whatever, basically as a promise that the object doesn't rely on other external state or meta stuff that would break when used this way

[20:28] <raydiak> so if it's explicitly enabled that way, I wonder if that helps with the problem you're talking about

[20:29] <raydiak> it should be obvious by now that I have a less than complete picture of how the internals work :)

[20:29] <liztormato> Perhaps.  I don't know

[20:40] *** zakharyas joined
[20:43] <masak> g'ah, I still quite can't figure out how to make a method match like a rule... :/

[20:44] <masak> let me see if I can come up with a question specific enough to get me unstuck.

[20:45] *** liztormato left
[20:45] <masak> right, ok. say I want to write a method that's the equivalent of /./ -- it always matches one character. how would that method look? I would need to generate a new cursor with the right values, right?

[20:47] <masak> again, I'm in Perl 6 doing this -- which might mean no-one's done it before.

[20:47] <masak> but it does seem like it should be possible.

[20:48] <vendethiel> masak: I'm not sure I understand what you're trying to do

[20:50] <moritz> m: grammar A { token TOP { <a> }; method a(|c) { say c.perl my \res = /./(self, |c); say res.perl; res } } }; say A.parse('x')

[20:50] <camelia> rakudo-moar fb9127: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/bo1z8qfnss␤Two terms in a row␤at /tmp/bo1z8qfnss:1␤------> [32m TOP { <a> }; method a(|c) { say c.perl [33m⏏[31mmy \res = /./(self, |c); say res.perl; r[0m␤    expecting any of:␤    …»

[20:50] <moritz> m: grammar A { token TOP { <a> }; method a(|c) { say c.perl; my \res = /./(self, |c); say res.perl; res } } }; say A.parse('x')

[20:50] <camelia> rakudo-moar fb9127: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/jMHiKbYZgA␤Unexpected closing bracket␤at /tmp/jMHiKbYZgA:1␤------> [32m = /./(self, |c); say res.perl; res } } [33m⏏[31m}; say A.parse('x')[0m␤»

[20:50] <moritz> m: grammar A { token TOP { <a> }; method a(|c) { say c.perl; my \res = /./(self, |c); say res.perl; res } }; say A.parse('x')

[20:50] <camelia> rakudo-moar fb9127: OUTPUT«Capture.new()␤A.new()␤｢x｣␤ a => ｢x｣␤␤»

[20:50] <masak> moritz++

[20:51] <masak> m: grammar A { token TOP { <a> }; method a { /./(self) } }; say A.parse('x')

[20:51] <camelia> rakudo-moar fb9127: OUTPUT«｢x｣␤ a => ｢x｣␤␤»

[20:51] <masak> moritz: just curious -- why did you feel the need to have |c along for the ride?

[20:51] <masak> seems to work without it.

[20:52] <vendethiel> I have absolutely no idea what's going on here..

[20:52] <masak> seems you can call a regex with a cursor! o.O

[20:52] <masak> at least that's how I read it.

[20:52] <vendethiel> yes, yes...

[20:52] <masak> yes, this will make things immensely simpler.

[20:52] <vendethiel> my mind just got shattered...

[20:53] *** slavik joined
[20:58] <raydiak> regex isa method

[20:59] <raydiak> should be able to wrap it too, I'd guess

[21:02] <FROGGS_> please read: http://perl6advent.wordpress.com/?p=2792&preview=true&preview_id=2792

[21:02] <masak> heh, I think I found a bug in the regex engine :)

[21:03] <masak> m: /+/; say "alive"

[21:03] <camelia> rakudo-moar fb9127: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/MtEpSUUPer␤Quantifier quantifies nothing␤at /tmp/MtEpSUUPer:1␤------> [32m/+[33m⏏[31m/; say "alive"[0m␤    expecting any of:␤        statement list␤        prefix or term␤       …»

[21:03] <masak> m: my $rx = "+"; /<$rx>/; say "alive"

[21:03] <camelia> rakudo-moar fb9127: OUTPUT«Cannot call 'match'; none of these signatures match:␤:(Cool:D: Any $target, *%adverbs)␤  in method Bool at src/gen/m-CORE.setting:14324␤  in block <unit> at /tmp/Ak5EexM_9h:1␤␤»

[21:03] <masak> m: my $rx = "+"; +/<$rx>/; say "alive"

[21:03] <camelia> rakudo-moar fb9127: OUTPUT«WARNINGS:␤Useless use of "+" in expression "+/<$rx>/" in sink context (line 1)␤Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: *%_)␤  in sub prefix:<+> at src/gen/m-CORE.setting:4407␤  in block <unit> at /tmp/3_Rr_Ik0O7:1␤␤»

[21:03] <masak> m: my $rx = "+"; "" ~~ /<$rx>/; say "alive"

[21:03] <camelia> rakudo-moar fb9127: OUTPUT«Memory allocation failed; could not allocate 929136640 bytes␤»

[21:03] <masak> (timeout)

[21:04] * masak submits rakudobug

[21:04] <masak> my assumption here is the /+/ is still a syntax error, even if it happens through an injected regex.

[21:05] <masak> probably doesn't go through the normal syntax checks, for some reason.

[21:06] <FROGGS_> m: say EVAL 'anon regex { + }'

[21:06] <camelia> rakudo-moar fb9127: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling EVAL_0␤Quantifier quantifies nothing␤at EVAL_0:1␤------> [32manon regex { +[33m⏏[31m }[0m␤    expecting any of:␤        scoped declarator␤        new name to be defined␤»

[21:06] <FROGGS_> I think that is what we do to interpolate a string as a regex rule

[21:06] *** ab5tract joined
[21:08] <moritz> m: my $s = ';'; '' ~~ /<$s>/

[21:08] <camelia> rakudo-moar fb9127: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling EVAL_0␤Unrecognized regex metacharacter ; (must be quoted to match literally)␤at EVAL_0:1␤------> [32manon regex { ^[33m⏏[31m;}[0m␤    expecting any of:␤        scoped declarator␤      …»

[21:08] *** atroxaper joined
[21:09] *** erkan left
[21:09] <raydiak> FROGGS_: "your expectations and assumptions when it ones to your test suite" ~~ s/ones/comes/

[21:10] <FROGGS_> raydiak: fixed :o)

[21:10] <raydiak> also, several of the paragraphs have odd-looking breaks before the last sentence

[21:11] <FROGGS_> hmmm, I don't see it

[21:11] *** erkan joined
[21:11] *** erkan left
[21:11] *** erkan joined
[21:11] <moritz> masak: it was my first attempt, so I treid to impose as few constraints as possible

[21:12] <masak> :)

[21:12] <raydiak> FROGGS_: even in the first paragraph, after "end of the day." before "But even when you are a"

[21:12] <masak> hm, follow-up question. how do I indicate a failed match from a method?

[21:13] <masak> I guess I match with a regex that definitely fails

[21:13] <FROGGS_> raydiak: ahh, that was intentional... but I can remove these

[21:13] <masak> like /<!>/

[21:13] <raydiak> FROGGS_: unless those should be separate, in which case a second line break is missing

[21:14] <raydiak> FROGGS_: ah, or maybe just a writing convention I'm unfamiliar with

[21:14] <FROGGS_> raydiak: maybe *g*

[21:14] <FROGGS_> I fixed it anyway

[21:15] <masak> moritz: it doesn't work, it turns out. :/

[21:15] <masak> m: grammar G { regex TOP { <foo> B }; method foo { /A/(self) } }; say ?G.parse("AB")

[21:15] <camelia> rakudo-moar fb9127: OUTPUT«True␤»

[21:15] <masak> hm.

[21:15] *** atroxaper left
[21:16] <moritz> masak: I'm unconvinced :-)

[21:16] <FROGGS_> masak: create a cursor that has a from > to

[21:16] <masak> what am I doing right?

[21:16] <moritz> m: grammar G { method TOP { /<!>/(self) } }; say so G.parse('')

[21:16] <camelia> rakudo-moar fb9127: OUTPUT«False␤»

[21:16] <raydiak> FROGGS_: should bleading (as in bleading my car's brakes) be bleeding (as in blood, the result of cutting)? or is that just U.S. english?

[21:16] <moritz> m: grammar G { method TOP { /<?>/(self) } }; say so G.parse('')

[21:16] <camelia> rakudo-moar fb9127: OUTPUT«True␤»

[21:17] <FROGGS_> raydiak: should be bleeding, ups

[21:19] <moritz> masak: NQPCursorRole has useful methods like !cursor_pass(int $pos, str $name = '', :$backtrack) and !cursor_fail()

[21:19] <masak> yes, but I'm in Perl 6 land...

[21:19] <moritz> masak: but they are all private, so not directly available to Grammar.pm

[21:19] <raydiak> FROGGS_: "flags how that backend was build, and you" ~~ s/build/built/

[21:19] <masak> for some reason, my big grammar is different, and I keep getting "P6opaque: no such attribute '$!pos'"

[21:20] <FROGGS_> m: grammar G { method TOP { self."!cursor_start_cur"() } }; say G.parse('foo')

[21:20] <camelia> rakudo-moar fb9127: OUTPUT«(Any)␤»

[21:20] <FROGGS_> raydiak: fixed

[21:21] *** raiph left
[21:21] <moritz> m: grammar G { method TOP() { say $.target; /<?>/(self) } }; say so G.parse(''')

[21:21] <camelia> rakudo-moar fb9127: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/UIKZDwNcM4␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/UIKZDwNcM4:1␤------> [32mrget; /<?>/(self) } }; say so G.parse(''[33m⏏[31m')[0m␤    expecting a…»

[21:21] <FROGGS_> m: grammar G { method TOP { self."!cursor_pass"(3, '') } }; say G.parse('foo')

[21:21] <camelia> rakudo-moar fb9127: OUTPUT«｢foo｣␤␤»

[21:21] <masak> If the compilation of the string form fails, the error message is converted

[21:21] <masak> to a warning and the assertion fails.

[21:21] <raydiak> FROGGS_: "but besides that everything run cleanly" ~~ s/run/ran/

[21:22] <masak> blargh. paste-o.

[21:22] <masak> m: grammar G { method TOP() { say $.target; /<?>/(self) } }; say so G.parse('')

[21:22] <camelia> rakudo-moar fb9127: OUTPUT«␤True␤»

[21:22] <FROGGS_> dang, I am a legasthenic

[21:22] <masak> m: grammar G { method TOP() { say $.target; /<?>/(self) } }; say so G.parse('OH HAI')

[21:22] <camelia> rakudo-moar fb9127: OUTPUT«OH HAI␤False␤»

[21:22] <masak> m: grammar G { method TOP() { say $.pos; /<?>/(self) } }; say so G.parse('OH HAI')

[21:22] <camelia> rakudo-moar fb9127: OUTPUT«0␤False␤»

[21:22] <masak> wow.

[21:24] <raydiak> FROGGS_: "list of compiler version can grow" ~~ s/version/versions/

[21:24] <FROGGS_> :S

[21:24] <FROGGS_> fixed

[21:27] <masak> FROGGS_: what's the second parameter, $name, good for in method !cursor_pass ?

[21:27] <FROGGS_> m: grammar G { method TOP { self."!cursor_pass"(3, 'baz') } }; say G.parse('foo')

[21:27] <camelia> rakudo-moar fb9127: OUTPUT«｢foo｣␤␤»

[21:27] <FROGGS_> hmmm

[21:28] <FROGGS_> masak: ahh, it will 'reduce' to that name

[21:28] <FROGGS_> so it would call action mathod baz in my example

[21:28] <masak> aha.

[21:28] <FROGGS_> method*

[21:31] <masak> now I'm getting "This representation (Null) does not support positional access".

[21:31] <masak> very interesting.

[21:32] <FROGGS_> hmmm, I never had that with Null

[21:32] <raydiak> FROGGS_: was "doit" intentional? I think that's all, besides a couple grammatical nits but they could be specific to my region and I'm not trying to be pedantic :)

[21:33] <FROGGS_> ohh, hmmm, I think doit is just how I write it accidently :o)

[21:33] <vendethiel> I'd like to find a way to give better error reporting when a MAIN doesn't match

[21:33] <FROGGS_> raydiak: thank you very much

[21:33] *** denis_boyun_ joined
[21:34] <FROGGS_> vendethiel: do you want to list almost matching candidates instead of the full list each time?

[21:34] <raydiak> FROGGS_: you're welcome.  thank you for the great advent article, I enjoyed reading it, look forward to putting your advice to use when tuits allow

[21:35] <FROGGS_> raydiak: thanks for the nice feedback :o)

[21:35] <vendethiel> FROGGS_: my gist https://gist.github.com/vendethiel/32057dc3750fc670937f

[21:36] <vendethiel> FROGGS_: I have two extra "MAIN"s supposedly giving a better error message. But now, the --help lists them as well

[21:36] <dalek> perl6-roast-data: e7c513b | coke++ | / (4 files):

[21:36] <dalek> perl6-roast-data: today (automated commit)

[21:36] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e7c513bfb0

[21:36] <raydiak> and while I'm on the subject, thanks to all the other advent authors this year...I haven't kept up enough lately to give proper feedback each day

[21:38] *** denis_boyun_ left
[21:38] <FROGGS_> vendethiel: I dunno if there is a trait specced that let you hide MAIN candidates...

[21:38] <FROGGS_> but that would certainly help

[21:39] <FROGGS_> and src/core/Main.pm would just need to check for that trait

[21:39] * masak ended up having to call "!reduce" manually to trigger the action method

[21:39] <masak> ...but now it works! o.O

[21:40] <FROGGS_> either that or the gen-usage needs to be improved to show only interesting candidates

[21:40] *** ab5tract left
[21:40] <masak> this is the weirdest code I've written in a while :)

[21:40] <FROGGS_> masak: *g*

[21:41] <FROGGS_> I've written some very decent code for $work that I am very proud of...

[21:41] *** Sqirrel joined
[21:41] <FROGGS_> that is also the reason I am not that active recently

[21:42] <FROGGS_> (the application I wrote is about to outrule a product that is worth 450_000€)

[21:42] <FROGGS_> well, "worth"

[21:42] *** slavik left
[21:43] * moritz wonders if masak++ is doing a user-space macro implementation

[21:45] *** dolmen joined
[21:47] <masak> that would be pretty sweet.

[21:48] <vendethiel> FROGGS_: not sure gen-usage could know the interesting ones

[21:49] * pmurias hopes masak isn't doing a kernel-space marco implementation ;)

[21:49] <FROGGS_> vendethiel: well, I can imagine that you can calc the distance between the input params and the candidates, and if some are very close, then these could be highlighted

[21:49] <vendethiel> FROGGS_: ha, right -- but I just want to plain hide them

[21:50] <FROGGS_> like we propose subs/types for typo'd/unknown things

[21:50] <FROGGS_> vendethiel: invent a trait 'is hidden' or so, spec it and implement it :o)

[21:52] <masak> 'night, #perl6

[21:52] <raydiak> g'night masak 

[21:52] <FROGGS_> gnight masak 

[21:52] *** ab5tract joined
[21:53] *** erkan left
[21:55] *** erkan joined
[21:55] *** erkan left
[21:55] *** erkan joined
[21:57] <lizmat> FROGGS_: s/absense/absence/

[21:57] <FROGGS_> fixed

[21:58] <lizmat> write tests in before hand -> write tests beforehand

[21:58] <lizmat> one problem left: (lose the aside)

[21:59] <FROGGS_> fixed

[22:00] <lizmat> run a particular code  : the "code" feels funny there, I expect "program" would be more correct

[22:00] <lizmat> same with "these test codes"

[22:02] <lizmat> s/achive/achieve/

[22:04] <FROGGS_> fixed

[22:05] <lizmat> FROGGS_: you are aware that we only need to nudge mst to start working on CPAN Testers integration for rakudo Perl 6, right ?

[22:05] <lizmat> (otherwise I have no comments: FROGGS_++ )

[22:05] <FROGGS_> lizmat: as I said earlier I don't believe in a CPAN testers integration

[22:06] <FROGGS_> because P5's infrastructure is quite different from ours, and getting this into cpantesters would take several months/years

[22:07] <FROGGS_> and then we have something we don't have under control, or we have at least no way to change things as we like

[22:07] <lizmat> but it would almost instantly give you a wide set of testers all over the world

[22:07] <lizmat> and all of the associated goodies

[22:07] <FROGGS_> in case the testers would install rakudo

[22:08] <lizmat> not to forget the exposure

[22:08] <lizmat> but anyways, I guess we agree to disagree  :-)

[22:08] <FROGGS_> :o)

[22:08] <lizmat> the future will tell

[22:09] <FROGGS_> I mean, I'd like to hear mst's story about how that actually can work out

[22:09] <FROGGS_> my problem is just that I lack imagination there

[22:09] <FROGGS_> (and knowledge)

[22:09] <lizmat> CPAN Testers have  *lot* of experience and knowledge on how *not* to do things

[22:10] <lizmat> I would hate to see Perl 6 make the same mistakes 

[22:11] <FROGGS_> yes, of course... that's why I want to attend q/a

[22:11] <lizmat> and it will be around the corner  :-)

[22:12] <FROGGS_> but learning from P5 does not imply squishing P6 test results into cpantesters that does not know about different backends nor compiler

[22:12] <FROGGS_> true :o)

[22:12] <lizmat> if that turns out to be a bridge too far, then we can decide not to want to cross it

[22:13] <lizmat> and there is much to be said for dogfooding a test infrastructure framework

[22:13] <lizmat> :-)

[22:13] <FROGGS_> my experience is just that I did not even get near that bridge, because ppl like barbie are too busy to reply to emails

[22:14] <lizmat> .oO( maybe I should send Barbie an email :-)

[22:15] <FROGGS_> nah, I don't need features added for reviewing P5 modules anymore :o)

[22:15] <FROGGS_> the few modules I still maintain are doing well

[22:18] <FROGGS_> would be nice if both of us had tuits for panda/CPAN before q/a

[22:18] <FROGGS_> err, panda/eleven

[22:18] <FROGGS_> or both :o)

[22:20] <lizmat> yes, it would

[22:27] <lizmat> gnight #perl6!

[22:27] <FROGGS_> gnight @all o/

[22:27] <raydiak> g'night lizmat & FROGGS_ 

[22:27] <FROGGS_> see ya raydiak 

[22:35] *** zakharyas left
[22:55] *** dolmen left
[23:01] *** atroxaper joined
[23:08] *** atroxaper left
[23:17] *** erkan left
[23:18] *** dakkar left
[23:19] *** erkan joined
[23:40] *** ab5tract left
[23:40] *** pmurias left
[23:46] *** ninjazach joined
[23:49] *** ab5tract joined
[23:57] *** araujo joined
