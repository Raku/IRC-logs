[00:01] *** dalek left
[00:03] *** dalek joined
[00:03] *** ChanServ sets mode: +v dalek

[00:10] *** ajr_ left
[00:12] *** a3gis joined
[00:13] *** thou left
[00:16] *** tadzik joined
[00:18] <dalek> ecosystem: 5432189 | (Andrew Egeler)++ | META.list:

[00:18] <dalek> ecosystem: Add Net::SMTP

[00:18] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/5432189f2d

[00:22] <Mouq> retupmoca++

[00:23] <retupmoca> Mouq: It's pretty simple right now, but hopefully it will advance quickly

[00:24] *** colomon joined
[00:24] <retupmoca> Of course, what I want now is a module that does SSL or STARTTLS, but I don't know if I'm comfortable taking that on quite yet

[00:28] <Mouq> retupmoca: Heh, I understand that

[00:28] <Mouq> Hopefully I'll have tuits eventually

[00:36] <Mouq> Also, lue, from a few nights ago: https://gist.github.com/lue/9941658#comment-1204497

[00:40] *** hoverboard left
[00:41] *** a3gis left
[01:00] *** virtualsue joined
[01:01] *** klapperl_ joined
[01:03] *** klapperl left
[01:09] *** hoverboard joined
[01:24] *** virtualsue left
[01:37] *** xenoterracide left
[01:38] *** thou joined
[01:44] *** ilbot3 left
[01:46] *** ilbot3 joined
[01:52] *** hoverboard left
[02:03] *** klapperl_ left
[02:05] *** klapperl joined
[02:09] *** xenoterracide joined
[02:10] <lue> Mouq: saw it. I'm having serious doubts that pack/unpack have any use (its only real strength, interchange with lower APIs, isn't *too* hard to do already). I'd like to see what TimToady's thoughts are on the matter.

[02:10] <Mouq> lue: He's talked about it before…

[02:11] <lue> Also, am I the only one getting a X::Undeclared::Symbols when trying to compile perl6-p's setting?

[02:11] <lue> Mouq: really? haven't seen it then.

[02:19] <lue> I only see two routes for (un)pack: first is to not have it, which might annoy some people who like its conciseness, but that leaves open the chance for methods on Buf to do pack-like things ( Buf.push($a, :uint(32)) ?), or...

[02:20] <lue> have a whole 'nother sublang, which as I stated earlier feels like overkill.

[02:20] <geekosaur> there is a lot to be said for erlang's bit syntax...

[02:20] <Mouq> lue: Note that we only implement a shallow subset of the old pack syntax

[02:21] <lue> Mouq: sure, I doubt those BER integers thingys would be very useful :)

[02:22] <Mouq> lue: Well, p5 has sub-tamplates

[02:22] <Mouq> *templates

[02:22] <lue> (the advantage of some PACK lang is that some could extend it to include those BER integers if needed, whereas a pack() method or sub would need to be overriden to do same, if it goes the P5 route.)

[02:23] <Mouq> And has ">" and "<" to indicate byte-order

[02:23] <Mouq> So p5 is already doing one-pass parsing

[02:24] <Mouq> (the templates use the syntax \( ~ \) <TOP> or so)

[02:24] <lue> .oO(    $data ~~ p/<ui32>**4/;    $binfile.read(...) ~~ u/[ 0xFE 0xFF <BE> | 0xFF 0xFE <LE>] ... /    )

[02:24] <Mouq> s/"<TOP>"/"<~~>"/

[02:25] * Mouq wonders how hard it would actually be to get <~~> working

[02:26] <Mouq> p6: say "a[bc[d]]" ~~ / \w+ [ \[ ~ \] <~~> ] /

[02:26] <camelia> niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method assertion:sym<~~> not yet implemented at /tmp/tmpfile line 1:␤------> [32msay "a[bc[d]]" ~~ / \w+ [ \[ ~ \] <~~[33m⏏[31m> ] /[0m␤␤Unhandled exception: Unable to resolve method oplift in typ…»

[02:26] <camelia> ..rakudo-parrot 890878, rakudo-jvm 890878, rakudo-moar 890878: OUTPUT«Nil␤»

[02:27] <lue> Despite my feelings that it's perhaps overkill, the most Perl 6-y option would appear to be a new sublanguage.

[02:27] <lue> (method(s) on Buf is another nice way of doing it methinks)

[02:27] <Mouq> p6: say "a[bc[d]]" ~~ / \w+ [ \[ ~ \] <~~> ]? /

[02:27] <camelia> rakudo-parrot 890878, rakudo-jvm 890878, rakudo-moar 890878: OUTPUT«｢a[bc[d]]｣␤␤»

[02:27] <camelia> ..niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method assertion:sym<~~> not yet implemented at /tmp/tmpfile line 1:␤------> [32msay "a[bc[d]]" ~~ / \w+ [ \[ ~ \] <~~[33m⏏[31m> ]? /[0m␤␤Unhandled exception: Unable to resolve method oplift in ty…»

[02:27] <Mouq> Rakudo++ :D

[02:28] *** kbaker_ left
[02:30] * Mouq looks at http://learnyousomeerlang.com/starting-out-for-real "Bit Syntax!"

[02:30] *** xragnar_ joined
[02:30] *** xragnar is now known as Guest59407

[02:30] *** Guest59407 left
[02:30] *** xragnar_ is now known as xragnar

[02:30] <Mouq> * http://learnyousomeerlang.com/starting-out-for-real#bit-syntax

[02:32] <lue> The problem with this r-p failure is that the supposed diagnostics are all in formats like Int<7740517530316644326>  :/

[02:33] <jercos> Mouq: would make base64 nicer anyway :p

[02:39] <Mouq> The color thing at the link would be helped by Buf(:size) being implemented…

[02:42] <Mouq> That way Erlang's "Color = 16#F09A29.␤Pixel = <<Color:24>>." could be written as "my $color = 0xF09A29;␤my $pixel = Buf.new(:size<24>,$color).size(8)" or something

[02:44] <bcode>  -82

[02:44] <bcode> er sorry :(

[02:44] <bcode> the first thing I say in here and it's a typoed command, what sort of impression that must leave...

[02:46] <lue> .tell TimToady Thinking about pack/unpack, I can't tell if making it a sublang (with unpack easily seen as "binary regex", pack being something else entirely) is preferable, or if we'd rather toss (un)pack and have equivalent operations be done with Bufs (with an additional method or two on Buf as necessary).

[02:46] <yoleaux> lue: I'll pass your message to TimToady.

[02:46] <lue> bcode: don't worry about it :)

[02:47] <bcode> yeah I tend to worry too much about things :) I've been mostly silently observing this channel so far as I think Perl 6 seems really cool, haven't had any time to do a lot with it so far due to IRL stuff though :(

[02:47] <Mouq> Speaking of IRL stuff, I need to sleep

[02:47] <lue> ♞ Mouq o/

[02:48] <bcode> good night :)

[02:48] <Mouq> bcode++ # observation :)

[02:48] <Mouq> o/

[02:52] <dalek> ecosystem: b3e975a | (Andrew Egeler)++ | META.list:

[02:52] <dalek> ecosystem: Add Net::POP3

[02:52] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/b3e975a1c8

[02:57] *** Mouq left
[03:04] *** xenoterracide left
[03:22] <dalek> perl6-most-wanted: 20f79c6 | (Andrew Egeler)++ | most-wanted/modules.md:

[03:22] <dalek> perl6-most-wanted: Add Net::SMTP and Net::POP3

[03:22] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/20f79c64eb

[04:16] *** hoverboard joined
[04:25] *** BenGoldberg left
[04:30] *** SamuraiJack__ joined
[04:33] *** thou left
[04:34] *** Psyche^_ left
[04:35] *** Psyche^ joined
[04:52] *** rurban joined
[04:59] *** bfulgham_ joined
[05:02] *** hoverboard left
[05:07] *** Visarga joined
[05:09] *** Visarga left
[05:26] *** bfulgham_ left
[05:29] <moritz> \o #perl6

[05:34] *** logie__ left
[05:37] <timotimo> o/

[05:42] *** logie joined
[05:46] *** aborazmeh joined
[05:54] *** aborazmeh left
[06:01] *** logie left
[06:02] <lue> I'm randomly guessing this is some missing #?if parrot thing involving threads:    https://gist.github.com/lue/9987997

[06:02] <lue> ♘ #perl6 o/

[06:03] <timotimo> that's my guess, too

[06:03] * timotimo will have a look now

[06:04] <timotimo> yes, the winners method ought to be if'd out

[06:05] <timotimo> that seems to get the compilation going again

[06:05] <timotimo> when it finishes i'll push

[06:07] *** rurban left
[06:08] <timotimo> dang, that wasn't it?

[06:09] <timotimo>   line: Int<-1172359952915819192>

[06:09] <timotimo> yeah thanks

[06:12] <lue> As you can see from my gist, the diagnostics are *super* helpful :)

[06:12] * lue really ♘

[06:13] <moritz> seems like it's happening before the stringification of basic types is set up

[06:13] <moritz> and the one from Any is used

[06:13] <timotimo> that's not so nice. should i try to write up a more daring failsafe for those types?

[06:13] <timotimo> at least for Int? >_>

[06:14] <moritz> for Int and Str at least

[06:15] <moritz> though the *really* interesting information here is in the unk_ hashes

[06:15] <timotimo> yes, but the line number will get us so much closer

[06:15] <moritz> (because that presumably tells us which symbols weren't found)

[06:15] <moritz> aye

[06:15] <timotimo> now i'll just have to figure out where to find that code :P

[06:16] <timotimo> possibly implement a method in Perl6::Compiler?

[06:16] <moritz> it's in World

[06:16] <moritz> and that's where the stuff should go, IMHO

[06:17] <moritz> just git grep for 'Error while compiling'

[06:17] <moritz> method typed_exception

[06:17] <timotimo> ah, yes, world

[06:17] <moritz> maybe a method stringify_safely or so

[06:18] <timotimo> i just had the presence of mind to grep for that

[06:19] <timotimo> hm. how to best figure out if we're getting a "stupid" stringification?

[06:19] <timotimo> except regex matching?

[06:19] <moritz> just always do the safe thing for Str and Int

[06:19] <timotimo> i suppose i could find_method and === against the find method for Any?

[06:19] <timotimo> oh, that would work

[06:20] <moritz> this code path is only triggered when compiling the setting

[06:20] <timotimo> sounds sensible

[06:20] <timotimo> i should be able to just unbox Str and Int and then nqp-stringify those, right?

[06:21] *** kurahaupo joined
[06:22] <timotimo> hmm. and i'll have to ~~ against find_symbol("Str") and "Int" respectively i believe

[06:22] <timotimo> long time i've done anything in World.nqp

[06:25] *** kaare_ joined
[06:28] <timotimo> about to see if it works

[06:30] <timotimo>   line: 17784

[06:30] <timotimo> better than nothing :)

[06:30] <timotimo> but the line in this case is utterly useless, it just points at the very last lise

[06:30] <timotimo> line*

[06:41] <timotimo> hm. inside explain_mystery, "Parcel" should be available, shouldn't it?

[06:41] *** molaf joined
[06:41] <timotimo> it gets called at the end of parsing, so it *should* be there :\

[06:44] <dalek> rakudo/safely_stringify_core_exceptions: 9cc033a | (Timo Paulssen)++ | src/Perl6/World.nqp:

[06:44] <dalek> rakudo/safely_stringify_core_exceptions: attempt to stringify common structures for early comp exceptions

[06:44] <dalek> rakudo/safely_stringify_core_exceptions: 

[06:44] <dalek> rakudo/safely_stringify_core_exceptions: try to give better error messages than "Parcel<-1234134>"

[06:44] <dalek> rakudo/safely_stringify_core_exceptions: during compile-time error reporting when compiling the core setting

[06:44] <dalek> rakudo/safely_stringify_core_exceptions: review: https://github.com/rakudo/rakudo/commit/9cc033a88a

[06:45] <timotimo> if someone would like to figure out why this still gives Parcel<-1394879213847> instead of running my code, that'd be cool. i'm going to be AFK for a while

[06:45] <timotimo> (fixing the underlying problem that causes the exception to happen in the first place would also be appreciated)

[07:08] *** rurban joined
[07:12] *** rurban left
[07:24] *** araujo left
[07:31] *** darutoko joined
[07:35] <moritz> timotimo: if $Str && nqp::istype($target, self.find_symbol(["Str"])) {

[07:36] <moritz> timotimo: that won't work, because Str as a type object is always false

[07:37] <moritz> timotimo: also no need to find_symbol['Str']) again

[07:39] <moritz> timotimo: working on a fix now

[07:39] *** bjz left
[07:39] *** Rotwang joined
[07:39] <lizmat> good *, #perl6!

[07:40] <lizmat> checking out reported breakage now

[07:40] <moritz> \o lizmat 

[07:40] *** bjz joined
[07:40] <lizmat> moritz /o

[07:41] * moritz has to build a new NQP before being able to test his patch

[07:42] *** pdcawley left
[07:44] * lizmat thinks she found the problem

[07:44] <lizmat> .winners() should not exist in parrot, checking ifdeffed version now

[07:48] <dalek> rakudo/nom: 2be444c | (Elizabeth Mattijsen)++ | src/core/List.pm:

[07:48] <dalek> rakudo/nom: .winners should not exist in rakudo-p

[07:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2be444c6f7

[07:48] <lizmat> sorry for the inconvenience

[07:49] <Woodi> hi today :)

[07:49] <Woodi> moritz: you was mentioning some project with JSON messages, what is his name ?

[07:51] <Woodi> also: what is 'actor semantic' ? :)

[07:54] *** medatlantik joined
[07:55] *** xfix left
[07:56] *** xfix joined
[08:02] *** medatlantik left
[08:05] <lizmat> http://en.wikipedia.org/wiki/Actor_model

[08:07] <moritz> Woodi: there's no name yet

[08:08] <moritz> I thought maybe "jirp" (tweet -> chirp, plus J from JSON), but that's already taken :(

[08:08] <dalek> rakudo/safely_stringify_core_exceptions: ef8d7bb | moritz++ | src/Perl6/World.nqp:

[08:08] <dalek> rakudo/safely_stringify_core_exceptions: fix checks for wether type objects are available

[08:08] <dalek> rakudo/safely_stringify_core_exceptions: review: https://github.com/rakudo/rakudo/commit/ef8d7bb5b6

[08:09] *** rurban joined
[08:10] <moritz> timotimo: http://perlpunks.de/paste/show/533fba3b.7ccc.21a that's the error message after my patch

[08:10] <moritz> timotimo: if you like it, feel free to squash-merge into nom

[08:10] <Woodi> moritz: plan is to send views as html and data as json ?

[08:11] *** denis_boyun_ joined
[08:12] *** vendethiel left
[08:13] *** rurban left
[08:14] *** aborazmeh joined
[08:16] *** woodvick joined
[08:18] <moritz> Woodi: the plan is to send data as json, and format strings (for plain text) along

[08:18] *** rindolf joined
[08:19] <moritz> start simple, you know :-)

[08:25] *** woodvick left
[08:29] *** pdcawley joined
[08:35] *** denis_boyun_ left
[08:37] *** denis_boyun joined
[08:39] <Woodi> actually I'm looking for something with fully static web pages presented to the user and only with artticles editors part with login form and js editor. something like jekyl but with edit part for not-devs, wysiwyg, then converted to static html...

[08:57] *** kivutar joined
[08:59] *** dmol joined
[09:05] *** kurahaupo left
[09:05] *** pdcawley left
[09:05] *** kurahaupo joined
[09:05] *** pdcawley joined
[09:06] *** kaare_ left
[09:09] *** rurban joined
[09:12] *** fhelmberger joined
[09:14] *** fhelmberger left
[09:14] *** rurban left
[09:17] *** Rotwang left
[09:18] *** Rotwang joined
[09:20] <jnthn> morning o/

[09:23] <TimToady> \o

[09:23] <yoleaux> 02:46Z <lue> TimToady: Thinking about pack/unpack, I can't tell if making it a sublang (with unpack easily seen as "binary regex", pack being something else entirely) is preferable, or if we'd rather toss (un)pack and have equivalent operations be done with Bufs (with an additional method or two on Buf as necessary).

[09:31] <jnthn> D'oh. Before wondering which changed made the NQP test suite take twice as long...check MVM_SPESH_LOG isn't defined in the env.

[09:31] <lizmat> moin TimToady, jnthn 

[09:31] <TimToady> that makes it sleep like a log, eh?

[09:32] <lizmat> .oO( a very heavy speshial log )

[09:32] <jnthn> TimToady: Well, it makes it write a huge log file, so yeah, pretty much :)

[09:32] <TimToady> well, they let us into the Forbidden City this morning, local

[09:33] <lizmat> jnthn: did you ever envision using winner {} on multiple channels ?

[09:33] <TimToady> not sure if our feet are still attached

[09:34] <jnthn> TimToady: There's a good bit of walking to do there :)

[09:34] * jnthn was lucky enough to go there on a day when the sky was actually blue

[09:34] <TimToady> esp if you do the park and lake to the northa as well

[09:34] <TimToady> it was quite beautiful today

[09:34] *** kurahaupo left
[09:35] <TimToady> we've had really good air most days, or at least not terrible

[09:35] <jnthn> lizmat: Yes, though when I envisioned it it was called select, like in Go. But yes, the point of it is you can be handling a bunch of channels.

[09:35] <lizmat> so how do you handle done @channels ?

[09:35] <lizmat> you cannot simply last on the the first "done"

[09:35] <jnthn> TimToady: ah, that's good. My last trip, the air was pretty awful. The trip before it was better and I saw plenty more ;)

[09:36] <lizmat> but a next iteration may select a "done" of a previously closed channel, so using a counter doesn't work

[09:37] <jnthn> lizmat: I guess you need to maintain a "to check" list.

[09:37] <jnthn> lizmat: And remove those you invoked done on.

[09:37] <sergot> hi! o/

[09:37] <lizmat> jnthn: outside of the winner {} or inside ?

[09:37] <lizmat> winner {} is basically stateless

[09:38] <jnthn> Ah...

[09:38] <jnthn> Yeah, now I see the problem.

[09:38] <lizmat> so it would become the burden of the developer 

[09:38] <jnthn> ugh

[09:38] <lizmat> yes, indeed

[09:38] <jnthn> That isn't the design I was aiming for at all...

[09:38] <jnthn> Hmm.

[09:38] <lizmat> indeed...  it feels to me that winner {} needs some state somehow

[09:38] <lizmat> that would also be good from a performance point of view  :)

[09:39] <jnthn> Well, probably need to put together some use cases...

[09:40] <lizmat>             more @c { @a.push: $:v }

[09:40] <lizmat>             done @c { @a.push: "done $:k"; last if ++$done == 2 }

[09:40] <lizmat> is what I tried to put in a test

[09:40] <lizmat> of course, it doesn't work, as it may end prematurely

[09:40] <lizmat> also, in the current implementation, the $:k on the done {} doesn't make sense, but that's an implementation detail

[09:40] *** aborazmeh left
[09:41] <jnthn> I'm not too enthralled with the named params here either fwiw.

[09:41] <jnthn> Because winner then iiuc needs to do introspection.

[09:41] <lizmat> the more I think about this, using winner {} for both promises and channels and potential mixes

[09:41] <lizmat> is confusing

[09:42] <lizmat> at least in the current spec

[09:42] <jnthn> I'm not so sure. I know we can define a Promise.Channel soundly, so I think the equivalence is good enough.

[09:42] <jnthn> The problem we're seeing here with done is creatable entirely with channels.

[09:43] <lizmat> indeed... but we're using "done" in the Promise context to return a value, and "done" in the Channel context to signify the channel is closed

[09:43] <lizmat> maybe we need to call "more" on the Promise as well ?

[09:44] *** aborazmeh joined
[09:45] <lizmat> trying to write extensive tests for winner {} and .winners, puts my nose deep into these things

[09:45] <lizmat> and it smells  :-)

[09:45] <jnthn> Oh...I'd expect "more" to be always about values, "done" to always be about completion with no interest in a value.

[09:45] <jnthn> Otherwise we can't say that winner on a promise is the same semantically as if you were doing winner on $that_promise.Channel.

[09:45] <jnthn> Which I think we should be able to.

[09:46] <jnthn> But yeah, something is off here.

[09:47] <lizmat> there's actually an error now to do "more" on a Promise

[09:47] <jnthn> ugh

[09:47] <lizmat>             elsif $kind == $WINNER_KIND_MORE && $next ~~ Promise {

[09:47] <lizmat>                 die "Cannot use 'more' on a Promise";

[09:47] <jnthn> But "more" doesn't really convey the right thing on a Promise.

[09:48] <lizmat> ok, let me simmer about this offline some

[09:48] <lizmat> well, yeah...

[09:48] <jnthn> I think the whole construct needs a revisit.

[09:48] <lizmat> indeed, I'm coming to that conclusion as well

[09:49] <lizmat> in a way, I was doing this with .winners, but I guess we need to go deeper

[09:51] *** aborazmeh left
[09:59] *** aborazmeh joined
[10:03] <dalek> roast: 65ddc70 | (Elizabeth Mattijsen)++ | S17-concurrency/winner.t:

[10:03] <dalek> roast: Some more winner {} tests

[10:03] <dalek> roast: 

[10:03] <dalek> roast: Which just show we need something better specced and implemented

[10:03] <dalek> roast: review: https://github.com/perl6/roast/commit/65ddc70fa0

[10:06] *** spider-mario joined
[10:07] <TimToady> how does .winner differ from "race"

[10:07] *** aborazmeh left
[10:07] <TimToady> er, .winners

[10:08] *** Rotwang left
[10:08] * TimToady doesn't like calling all of the finishers "winners", political correctness notwithstanding

[10:08] <lizmat> because .winners returns value from multiple channels / promises

[10:09] <lizmat> and race just changes the order in which an iteration is done

[10:09] <TimToady> still don't much like the name

[10:09] *** denis_boyun left
[10:09] <lizmat> I'm not happy about the name either and open to suggestions  :-)

[10:10] *** aborazmeh joined
[10:10] <lizmat> for a while, I thought about calling it .process

[10:10] * TimToady doesn't have a good name at the moment, but will think about it

[10:10] <lizmat> but that was too generic

[10:10] *** rurban joined
[10:11] *** denis_boyun joined
[10:11] <TimToady> it's a kind of merge in the time dimension

[10:12] *** SamuraiJack__ left
[10:12] <lizmat> with nothing happening simultaneously anymore

[10:12] <lizmat> it's also a serializing of events in time

[10:12] <TimToady> well, that's what races do, determine order of finish

[10:13] <lizmat> oddly enough, "race" is currently specced as "I don't care in which order they finish"

[10:13] <TimToady> welll, in a sense, the race organizers don't care in advance either :)

[10:14] <lizmat> true

[10:14] <TimToady> @dostuff.athon :)

[10:15] <TimToady> and marathons are famous for letting everyone finish

[10:15] <lizmat> athon { } instead of winner { }

[10:15] *** rurban left
[10:15] <TimToady> no, winner is specifically one one

[10:15] <TimToady> that's why it has that name

[10:15] <lizmat> athon {} instead of .winners()

[10:15] <TimToady> to preclude people thinking it's all of them

[10:16] <TimToady> that makes more sense to me

[10:16] <lizmat> so athon { } would return a lazy list of the values it received

[10:16] *** kivutar left
[10:17] *** aborazmeh left
[10:17] * TimToady is not sure it makes sense semantically to mix promise values in with channel values like that, but is open to persuasion

[10:17] *** SamuraiJack__ joined
[10:17] <lizmat> still, if we have athon {}, I'm not sure the use for winner P} would be

[10:17] <TimToady> it feels like a type failure

[10:17] <lizmat> well, that too

[10:18] <TimToady> winner would shoot all the other contestants

[10:18] <lizmat> but you could consider a Promise to be a Channel only returning a single value

[10:18] <TimToady> you could, but then you get mixed up with the promise that a chennel provides, I suspect

[10:19] <lizmat> hmmm..  the Promise a Channel provides?

[10:19] *** aborazmeh joined
[10:20] <spider-mario> hm, on Rakudo 2014.03 on MoarVM, just typing “@x” generates an infinite loop of error messages

[10:20] <TimToady> I suppose we could say that done might or might not provide a final value; I could see some channel algos that would want to work that way

[10:20] <moritz> spider-mario: iirc that was fixed after the release

[10:20] <spider-mario> oh, nice

[10:20] <spider-mario> thanks

[10:21] <TimToady> but there was some reaons I didn't level promises and channels that I'm too tired to recall at the moment

[10:21] <TimToady> might've been a dumb reason, but I did consider it, that much I remember :)

[10:21] <lizmat> :-)

[10:22] <TimToady> well, we need to go find dinner before all the restaurants get even more overfull than they are now...

[10:23] <lizmat> bon appetit!

[10:26] <jnthn> argh

[10:26] <jnthn> uh, ww

[10:26] *** aborazmeh left
[10:35] *** aborazmeh joined
[10:38] *** SamuraiJack__ left
[10:40] <Woodi> winners are like   #pragma omp parallel for  with collecting array being fifo queue ?

[10:50] <lizmat> sounds like it, not sure  :-)

[11:03] <Woodi> such patters: map-paraller_burst-collect probably are common case but rather actorless... and example is to simple to define graph of parallel nodes with topologies... but methink we still not quite think in sequential parallel proces_sess_. something like: BEGIN { start helper, collector, io; }

[11:12] *** aborazmeh left
[11:19] <spider-mario> rakudo star, even with Configure.pl --backends=parrot, appears to build the MoarVM backend when nqp-m is present

[11:20] <spider-mario> well, perhaps not all of it

[11:20] <spider-mario> at least /usr/bin/perl6-m and /usr/languages/perl6/runtime/perl6.moarvm for example

[11:22] <jnthn> Hm, interesting. :)

[11:22] <jnthn> I guesss maybe it doesn't pass a --backend down to Rakudo's Configure

[11:22] <jnthn> spider-mario: Are you talking about the last star release, or if you build one from the current star repo?

[11:22] <spider-mario> 2014.03

[11:23] <jnthn> Ah. I guess that's it, then.

[11:24] <jnthn> The 2014.04 should support backends properly, so should be fixed there...in theory.

[11:25] <spider-mario> ok, thanks :)

[11:25] <spider-mario> I guess I can just grab a patch from the appropriate commit in the meantime, then

[11:28] *** dwarring left
[11:38] <spider-mario> I don’t think it’s fixed

[11:39] <spider-mario> the culprit appears to be line 53 of tools/build/Makefile.in

[11:39] <spider-mario>         cd $(RAKUDO_DIR) && $(PERL) Configure.pl --prefix=$(PREFIX_DIR) && $(MAKE)

[11:40] <spider-mario> (line 53 as of star 2014.03-33-gf79eaed)

[11:40] *** grondilu joined
[11:40] <spider-mario> (commit f79ea)

[11:41] <grondilu> my naive attempt to make a parallel mandelbrot:  https://gist.github.com/grondilu/9990847

[11:41] <spider-mario> the last time this line was touched was back in november

[11:44] <jnthn> Ah, yeah. Looks like it needs patching to pass the backends down.

[11:44] *** mkz left
[11:50] <colomon> grondilu: does that work on moar?

[11:51] <grondilu> colomon: not really.  It does not behave deterministically, for one.

[11:51] *** mkz joined
[11:53] *** ilbot3 left
[11:54] *** ilbot3 joined
[12:00] <colomon> grondilu: does it work on jvm?

[12:00] <colomon> (ie is it naive because of a lack of sophistication or because it doesn't work?)

[12:00] <colomon> (or in other words, what do I need to do to run the script?  ;)

[12:02] <dalek> rakudo/nom: aab600f | (Timo Paulssen)++ | src/Perl6/World.nqp:

[12:02] <dalek> rakudo/nom: Stringify common structures for early comp exceptions

[12:02] <dalek> rakudo/nom: 

[12:02] <dalek> rakudo/nom: try to give better error messages than "Parcel<-1234134>"

[12:02] <dalek> rakudo/nom: during compile-time error reporting when compiling the core setting

[12:02] <dalek> rakudo/nom: 

[12:02] <dalek> rakudo/nom: Contains some small fixups by moritz

[12:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aab600f8df

[12:02] <moritz> timotimo: ok, I was impatient, and squash-merged the branch myself

[12:06] <spider-mario> is MoarVM bytecode architecture-dependant?

[12:06] <grondilu> colomon: it's naive because it's my first attempt and because it's not sophisticated.  I have no idea if it's supposed to work right now on Moar.  But it does seem to run without too much complain.

[12:08] <grondilu> sometimes it interrupts with weird errors like:

[12:08] <grondilu> Unhandled exception: When invoking EXCEPTION, Provided outer frame 0x9632ea0 (MVMStaticFrame postcircumfix:<[ ]>) does not match expected static frame type 0x8b6d510 (MVMStaticFrame )

[12:10] <grondilu>  I say it's weird because it seems to do that in the middle of the drawing.  Though I should check that.

[12:12] *** rurban joined
[12:13] <jnthn> spider-mario: No

[12:13] <spider-mario> ok, thanks.

[12:14] <jnthn> spider-mario: Though the VM itself certainly has its share of porting work to go.

[12:15] <grondilu> colomon: haven't tried on jvm

[12:15] * grondilu does not use the jvm

[12:17] *** rurban left
[12:22] *** d0nk left
[12:22] *** d0nk joined
[12:34] *** ilbot3 left
[12:34] *** ilbot3 joined
[12:38] *** mkz left
[12:40] *** kivutar joined
[12:50] *** baest left
[12:56] *** baest joined
[13:00] *** baest left
[13:01] *** baest joined
[13:03] *** xfix left
[13:05] *** jdv79 joined
[13:05] *** mkz joined
[13:10] <jdv79> where is "#?endif" parsed?

[13:11] *** xfix joined
[13:12] *** baest left
[13:12] <jnthn> tools/build/gen-cat.pl iirc

[13:13] *** rurban joined
[13:14] *** baest joined
[13:14] *** dayangkun_ left
[13:17] *** rurban left
[13:20] *** aborazmeh joined
[13:20] *** xfix left
[13:23] *** xenoterracide joined
[13:23] *** xfix joined
[13:28] *** xfix left
[13:31] *** xfix joined
[13:38] *** mtk left
[13:39] *** hummeleB1 joined
[13:41] *** mtk joined
[13:42] *** colomon left
[13:44] *** grondilu left
[13:45] *** baest left
[13:50] *** baest joined
[13:56] *** baest left
[13:59] *** rurban joined
[14:00] *** baest joined
[14:01] *** mtk left
[14:06] *** mtk joined
[14:06] *** telex left
[14:08] *** telex joined
[14:21] <FROGGS> morning

[14:23] *** logie joined
[14:25] *** vendethiel joined
[14:30] <masak> morning, FROGGS 

[14:33] *** Rotwang joined
[14:37] <dalek> nqp/execname: 44181ad | jonathan++ | src/NQP/Optimizer.nqp:

[14:37] <dalek> nqp/execname: Start recording var decls/usages.

[14:37] <dalek> nqp/execname: review: https://github.com/perl6/nqp/commit/44181ada13

[14:37] <dalek> nqp/execname: d062aa3 | jonathan++ | src/NQP/Optimizer.nqp:

[14:37] <dalek> nqp/execname: Implement lexical => local lowering.

[14:37] <dalek> nqp/execname: review: https://github.com/perl6/nqp/commit/d062aa3ca9

[14:37] <dalek> nqp/execname: a83cec1 | jonathan++ | src/NQP/Optimizer.nqp:

[14:37] <dalek> nqp/execname: Can lower $/ and self also.

[14:37] <dalek> nqp/execname: review: https://github.com/perl6/nqp/commit/a83cec12bc

[14:37] <dalek> nqp/execname: 39e7a00 | jonathan++ | src/NQP/Optimizer.nqp:

[14:37] <dalek> nqp/execname: Fix spello; [Coke]++.

[14:37] <dalek> nqp/execname: review: https://github.com/perl6/nqp/commit/39e7a006bf

[14:37] <dalek> nqp/execname: 4dd7814 | jnthn++ | src/NQP/Optimizer.nqp:

[14:38] <dalek> nqp/execname: Walk default defaults in the optimizer.

[14:38] <dalek> nqp/execname: review: https://github.com/perl6/nqp/commit/4dd78145ff

[14:38] <dalek> nqp/execname: d317008 | jnthn++ | src/vm/jvm/ModuleLoader.nqp:

[14:38] <dalek> nqp/execname: Eliminate epic hack in JVM ModuleLoader.

[14:38] <dalek> nqp/execname: 

[14:38] <dalek> nqp/execname: The optimizer now got clever enough to see through the hack.

[14:38] <dalek> nqp/execname: review: https://github.com/perl6/nqp/commit/d317008d0c

[14:38] <dalek> nqp/execname: dcb3c38 | (Tobias Leich)++ | src/ (2 files):

[14:38] <dalek> nqp/execname: Merge branch 'master' of github.com:perl6/nqp into execname

[14:38] <dalek> nqp/execname: review: https://github.com/perl6/nqp/commit/dcb3c385bf

[14:39] <jnthn> ooh, free karma!

[14:47] <FROGGS> well, almost free :o)

[14:48] <FROGGS> you need to do something in the first place

[14:48] *** gtodd joined
[14:54] <moritz> FROGGS: did you see my note yesterday abot execname?

[14:54] <FROGGS> no, let me backlog

[14:54] <moritz> http://irclog.perlgeek.de/perl6/2014-04-04#i_8543190

[14:57] <FROGGS> moritz: that sounds good

[14:57] <FROGGS> but, do we really want to keep the shell wrappers?

[14:58] <moritz> no idea

[15:00] <gtodd> Is it true a long time ago people were able to get parrot run both perl5 & perl6 

[15:00] <moritz> gtodd: that was always the plan, but it never worked.

[15:00] <gtodd> if so this would me we can haz ponies one day?  i.e. in the spirit of www.poniecode.org 

[15:00] *** kaare_ joined
[15:01] *** zakharyas joined
[15:01] <gtodd> moritz: interesting that it got as far as it did ... parrot seems more capable now than in 2006 

[15:02] <gtodd> so perhaps one day  we can haz 

[15:02] <moritz> not at parrot's current rate of development

[15:02] *** xenoterracide left
[15:03] *** xenoterracide joined
[15:03] <jnthn> More likely to see that happen through one of v5 or some MoarVM-based itnerop project, I'd say.

[15:04] *** pecastro left
[15:05] <moritz> https://www.ohloh.net/p/parrot take a look at the "Activity" section

[15:05] <gtodd> $GIANT_CORPORATE_SPONSOR  ??

[15:06] * moritz manages not to joke about dead horses and dead parrots

[15:06] <FROGGS> *g*

[15:07] <gtodd> hmm well ohloh shows a levelling off ... :-)

[15:07] <FROGGS> moritz: about the runner: I am going to play with embedded mbc bytecode now, and if that works out there would be a nice reason to use this kind of runner

[15:07] <FROGGS> moritz: if not, we can always keep the shell wrapper with a --execname...

[15:08] <jnthn> FROGGS: Note that the shell script runner did have the advantage of easy relocatability. :)

[15:08] <jnthn> FROGGS: 'cus relocating would be "change paths in the shell script"

[15:08] <FROGGS> jnthn: true

[15:09] <FROGGS> but the to create a new nqp-m in another place you'd just create the gen-runner thing again

[15:09] <timotimo> the runner could provide a bit of extra space for the paths and an argument that causes it to read in its own code, re-write the paths and spit out a "relocated" runner :P

[15:10] <FROGGS> O.o

[15:11] <timotimo> you know how zip files can be appended to any file you like and still work properly?

[15:11] <jnthn> 'cus it looks at the end of the file first for the "header", iirc? :)

[15:12] <gtodd> I guess someone needs to convince the people who have budgets for it why sponsoring parrot (and its relatives i.e. rakudo) is cool and will position them to *take over the cloud* 

[15:12] <timotimo> yes and the references from the header are probably relative rather than absolute

[15:12] <gtodd> oops I think I meant "world" not "cloud" .. but cloud sounds cooler so ...

[15:13] *** colomon joined
[15:13] <gtodd> anyway while you guys keep working perl6 keeps getting more and more fun easier and faster to play with so thank you

[15:14] *** MrMeek left
[15:14] *** treehug88 joined
[15:14] *** treehug88 left
[15:15] *** treehug88 joined
[15:16] <timotimo> gtodd: well, you can probably see we're all mostly excited about MoarVM these days, rather than parrot

[15:20] <moritz> FROGGS: instead of reserving space for relocation paths, the fake-executable could know how to extract its payload, and create a new, relocated copy of itself

[15:20] <FROGGS> moritz: what is a "fake-executable" here?

[15:21] <FROGGS> the shell wrapper?

[15:21] <moritz> FROGGS: no, the moar exec + byte code embedded

[15:22] <FROGGS> ahh, but that is not a fake executable for me... but perhaps I just don't know the diff between a fake and a normal executable :o)

[15:23] <timotimo> hah.

[15:25] *** aborazmeh left
[15:30] <timotimo> implementing andthen as well as orelse properly on rakudo doesn't seem terribly hard

[15:30] <timotimo> maybe i'll do that next, just to remove a yellow from the compilers/features comparison matrix :P

[15:32] *** colomon left
[15:34] <timotimo> huh. there already is a "andthen_op" piece of code that at least block-closure-thunk-refs the RHS of each of the andthens

[15:34] <timotimo> that's a good starting point, i'd bet

[15:34] *** IllvilJa left
[15:35] *** raiph joined
[15:36] <timotimo> hm. the spec doesn't say anything about "exception semantics" for andthen

[15:36] *** guru joined
[15:36] *** guru is now known as Guest52690

[15:36] <timotimo> ah, exception semantics only "exist" for orelse

[15:36] * timotimo heads out again for a while

[15:36] *** Guest52690 is now known as ajr_

[15:42] <moritz> timotimo: it sets $! in some weird scope, or something

[15:49] <vendethiel> r: gather { take $a; take |@b; };

[15:49] <camelia> rakudo-jvm aab600: OUTPUT«(timeout)»

[15:49] <camelia> ..rakudo-parrot aab600, rakudo-moar aab600: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Variable '$a' is not declared␤at /tmp/tmpfile:1␤------> [32mgather { take $a[33m⏏[31m; take |@b; };[0m␤    expecting any of:␤        postfix␤»

[15:50] <vendethiel> r: my $a = 1; my @b = (2, 3); say (gather { take $a; take |@b; }).perl;

[15:50] <camelia> rakudo-parrot aab600, rakudo-jvm aab600, rakudo-moar aab600: OUTPUT«(1, (2, 3)).list␤»

[15:50] <vendethiel> r: my $a = 1; my @b = (2, 3); say (gather { take $a; take @b; }).perl;

[15:50] <camelia> rakudo-parrot aab600, rakudo-jvm aab600, rakudo-moar aab600: OUTPUT«(1, 2, 3).list␤»

[15:51] <vendethiel> r: my $a = 1; my @b = (2, 3); say (gather { take $a; take $@b; })[1].perl;

[15:51] <camelia> rakudo-parrot aab600, rakudo-jvm aab600, rakudo-moar aab600: OUTPUT«[2, 3]␤»

[15:56] *** IllvilJa joined
[15:56] *** hoverboard joined
[15:57] *** treehug88 left
[15:57] *** mtk left
[16:07] <timotimo> moritz: only orelse does, andthen doesn't apparently

[16:07] <timotimo> in any case, there ought to be some tests and it seems like there are none

[16:07] <timotimo> or at least none that are linked to the synopses

[16:23] *** pecastro joined
[16:24] * lizmat is back from cycling

[16:25] <lizmat> jnthn: woolfy came up with a better name for winner {} and .winner

[16:25] <lizmat> outcome

[16:25] <lizmat> outcome @p,@c

[16:26] <lizmat> would give you a lazy list with results from promises and channels until all are kept / closed

[16:26] <jnthn> Hmm :)

[16:26] <lizmat> outcome @p,@c { ... }

[16:26] <lizmat> would execute the code whenever a promise was kept / channel produced a value

[16:27] <lizmat> outcome * { done / more }

[16:27] <lizmat> would have the same syntax as now winner {}

[16:27] <lizmat> in this scenario, I don't really see a reason why "winner {}" or .winners() should exist

[16:29] *** thou joined
[16:32] <lizmat> my @a := outcome ...  # turn into an array so you can carry it "around"

[16:33] <lizmat> in that context, I wonder if we could use a special type of array

[16:33] <lizmat> which, when doing something like:

[16:33] <lizmat> for @a { last if $foo }

[16:33] <lizmat> would continue where it left off if you would do a

[16:33] <lizmat> for @a {...}

[16:33] <lizmat> again

[16:36] <lizmat> if so, you could do something like: my @a := outcome { wait 0 { last } }; loop {  do something; for @a { process $_ } }

[16:37] <lizmat> jnthn: does that make sense ?

[16:38] <jnthn> lizmat: Does the array case imply some kind of implicit loop, which winner lacks today?

[16:39] <lizmat> outcome returns a lazy list, so yes

[16:39] <lizmat> winner {} either needs state, or it needs an internal loop

[16:40] <lizmat> the way it is specced now, makes it virtually useless for any multi-promise and/or multi-channel cases

[16:40] <lizmat> s/it/winner {}/

[16:41] <lizmat> as there is a good chance you will see the same promis again and again, unless you remove it from winner {} yourself

[16:41] <lizmat> which is a lot of bookkeeping  :-(

[16:42] <jnthn> yeah, agree.

[16:45] <lizmat> I'll probably test an implementation of outcome {} later tonight, and if it works, spec it, ok?

[16:46] *** denis_boyun_ joined
[16:46] *** denis_boyun left
[16:50] <dalek> roast: 3b5223c | (Elizabeth Mattijsen)++ | S17-concurrency/lock.t:

[16:50] <dalek> roast: Make lock test failure a bit more verbose

[16:50] <dalek> roast: review: https://github.com/perl6/roast/commit/3b5223c891

[16:51] <lizmat> jnthn: see above change

[16:51] <lizmat> about 1 in 15 times I get:

[16:51] <lizmat> not ok 7 - Condition variable worked

[16:51] <lizmat> #      got: 'ale,porter'

[16:51] <lizmat> # expected: 'ale,porter,stout'

[16:51] <lizmat> # log = ale porter stout

[16:52] <raiph> lizmat: note how you used the word "whenever" which I know at least one other person liked

[16:52] *** kurahaupo joined
[16:53] <raiph> whenever * { done / more }

[16:53] *** denis_boyun_ left
[16:53] <lizmat> but that would just be a synonym for "winner", no?

[16:54] <raiph> winner implies one thing

[16:54] <lizmat> and my point is that the current semantics of "winner {}" are not of much use in real life

[16:54] <raiph> whenever (to me) implies, well, whenever something happens

[16:54] *** denis_boyun_ joined
[16:54] <lizmat> which is what "winner {}" now does

[16:55] <raiph> including when there are a series of things that happen

[16:55] <lizmat> my proposal for "outcome" would be something with the syntax of "winner {}" (more or less) with the semantice of .winners()

[16:55] <raiph> you said it yourself: "would execute the code whenever a promise was kept / channel produced a value "

[16:55] <vendethiel> r: say @$@$(1, 2).perl;

[16:56] <camelia> rakudo-parrot aab600, rakudo-jvm aab600, rakudo-moar aab600: OUTPUT«(1, 2).list␤»

[16:56] <timotimo> vendethiel: time for swearword-multigils

[16:56] <raiph> right, i'm bikeshed suggesting "whenever" as an alternate to outcome, not to winner

[16:56] <lizmat> ah, ok

[16:56] <lizmat> whatever  :-)

[16:56] <lizmat> seriously

[16:56] <raiph> heh

[16:56] <vendethiel> r: say @%$%@$(1, 2).perl # trying to spice it up for timotimo

[16:56] <camelia> rakudo-parrot aab600, rakudo-jvm aab600, rakudo-moar aab600: OUTPUT«("1" => 2,).list␤»

[16:56] <lizmat> whenever feels more like a single event handler to me

[16:56] <vendethiel> that'll work.

[16:57] <timotimo> rrrrrr spicy

[16:58] <lizmat> outcome feels more like with a bicycle race, the list of who got in first, second, third all the way to the last

[16:58] <raiph> lizmat: then why did you say "whenever" in explaining "outcome"?

[16:58] <lizmat> it was about the code block specified with outcome @p,@c { ... }

[16:58] <lizmat> another word for "outcome" that I came up with, was "mapathon"

[16:59] <lizmat> because it is basically a map {}

[16:59] <lizmat> with the promises being kept/broken and values from channels becoming part of a lazy list

[17:00] <lizmat> until there were no unPlanned Promises left, and all channels were closed

[17:00] <raiph> k

[17:01] <lizmat> so, just calling "outcome {}" would block in the current thread

[17:01] <retupmoca> Could I get someone to glance at https://github.com/rakudo/rakudo/pull/255 ?

[17:01] <retupmoca> I also have a couple of open pull requests for panda, if someone here has time and a commitbit

[17:02] <raiph> lizmat++ # awesome work on P6 for last year+

[17:03] <xenoterracide> I swear the feature I want in every language more than anything in the world, is making it so that that by default, methods cannot take null/undef parameters.

[17:03] <lizmat> raiph: *blush*  :-)

[17:04] <lizmat> in Perl 6: make sure your methods have the right signature  :-)

[17:04] <retupmoca> xenoterracide: it's not by default, but you can do this:

[17:04] <retupmoca> m: sub foo($x where .defined) { say $x }; foo("ASDF"); foo(Str)

[17:04] <camelia> rakudo-moar aab600: OUTPUT«ASDF␤Constraint type check failed for parameter '$x'␤  in sub foo at /tmp/Kjn2bXKsSD:1␤  in block  at /tmp/Kjn2bXKsSD:1␤␤»

[17:05] <xenoterracide> retupmoca: you can do :D

[17:05] <lizmat> retupmoca: since FROGGS is working in this area, I'm a bit uncertain to merge that PR

[17:05] <xenoterracide> retupmoca: but the most frequent error I see is forgetting to define something and forgetting a null/undef check

[17:06] <lizmat> afk for a few hours&

[17:06] <retupmoca> lizmat: no worries, I'll wait for him to show up / notice the PR

[17:10] <xenoterracide> maybe TimToady would consider making :D the default for method parameters, instead of :U (notes that read only would be nice too but less required). (Only bringing this up because I don't believe it would be impossible for perl6 to change this yet )

[17:13] <vendethiel> r: my $a = 'foo'; say ($a // '?' ~ 'b')

[17:13] <camelia> rakudo-parrot aab600, rakudo-jvm aab600, rakudo-moar aab600: OUTPUT«foo␤»

[17:17] *** denis_boyun___ joined
[17:19] *** denis_boyun_ left
[17:24] *** molaf left
[17:39] *** bjz left
[17:39] *** bjz joined
[17:40] *** pecastro left
[17:54] *** leosik joined
[17:56] <dalek> rakudo/nom: 2de2c9f | (Andrew Egeler)++ | src/core/terms.pm:

[17:56] <dalek> rakudo/nom: Load modules from %CUSTOM_LIB<home> before <site>

[17:56] <dalek> rakudo/nom: 

[17:56] <dalek> rakudo/nom: This way a user can install a local module that will override a

[17:56] <dalek> rakudo/nom: system-installed one

[17:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2de2c9fa5a

[17:56] <dalek> rakudo/nom: a667490 | (Tobias Leich)++ | src/core/terms.pm:

[17:56] <dalek> rakudo/nom: Merge pull request #255 from retupmoca/nom

[17:56] <dalek> rakudo/nom: 

[17:56] <dalek> rakudo/nom: Load modules from %CUSTOM_LIB<home> before <site>

[17:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a667490a14

[18:00] <retupmoca> FROGGS++  # making my itch-scratching official

[18:01] <FROGGS> pleasure :o)

[18:05] *** xinming__ left
[18:06] *** treehug88 joined
[18:07] *** xinming_ joined
[18:10] *** treehug88 left
[18:11] *** hoverboard left
[18:25] *** pecastro joined
[18:26] <timotimo> r: try die "hello there"; say ~$! eq "hello there"

[18:26] <camelia> rakudo-parrot aab600, rakudo-jvm aab600, rakudo-moar aab600: OUTPUT«True␤»

[18:32] <timotimo> r: sub output_error { say $! }; try die "hey"; output_error;

[18:33] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«Nil␤»

[18:33] <timotimo> isn't $! supposed to be dynamic?

[18:36] <moritz> n: sub output_error { say $! }; try die "hey"; output_error

[18:36] <camelia> niecza v24-109-g48a8de3: OUTPUT«(Any)␤»

[18:37] <vendethiel> timotimo: I don't think so (outside the fact it'd be $*!, it'd make CATCH and all be dynamic too)

[18:39] <timotimo> hm

[18:41] <timotimo> so i'll probably have to fiddle around with the blocks that get created if they're not pointy

[18:43] *** leosik left
[18:46] *** rurban left
[18:49] *** darutoko left
[18:54] *** kaare_ left
[18:58] *** xinming_ left
[19:00] *** xinming_ joined
[19:02] <timotimo> r: say 1 // "foo" // say "hi"

[19:03] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«1␤»

[19:03] <timotimo> oh, that does thunk

[19:05] *** LLamaRider joined
[19:06] <dalek> roast: 580f5c1 | (Timo Paulssen)++ | S03-operators/orelse.t:

[19:06] <dalek> roast: a few tests for the orelse operator

[19:06] <dalek> roast: 

[19:06] <dalek> roast: a bit of sanity and then exception semantics.

[19:06] <dalek> roast: review: https://github.com/perl6/roast/commit/580f5c164b

[19:06] <dalek> rakudo/nom: c2cc4fd | (Timo Paulssen)++ | t/spectest.data:

[19:06] <dalek> rakudo/nom: run the new orelse tests

[19:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2cc4fdd04

[19:06] *** molaf joined
[19:12] <timotimo> i see an opportunity for a tiny optimization in rakudo's EXPR; it has a bunch of if/elses in a row that all begin with "!$past &&"

[19:12] <timotimo> i wonder if factoring that $!past out would be worth a lot

[19:13] <timotimo> oh and btw, is there some good document on how to understand how adverbs attach to operators?

[19:13] <timotimo> i seem to recall a not quite simple explanation involving precedence and stuff

[19:13] <timotimo> if there isn't, i may write one up and put it $somewhere

[19:14] <vendethiel> timotimo: please do :)

[19:14] <tadzik> omg, internet

[19:16] <timotimo> tadzik: \o/

[19:16] <timotimo> how are you today?

[19:20] <tadzik> a bit ache-y, but fine aside from that :)

[19:21] <tadzik> I'm like in the middle of a 26 bus ride back home

[19:21] <timotimo> 26 different bus lines?

[19:21] <tadzik> oh, sorry: 26-hour long

[19:21] <moritz> woah

[19:22] <tadzik> I wish I was kidding :P

[19:22] <tadzik> but at least I'm now in a country that actually has internet

[19:22] <vendethiel> r: Any or Int or 1

[19:22] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: ( no output )

[19:22] <vendethiel> r: say Any or Int or 1 # :(

[19:22] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«(Any)␤»

[19:22] *** SamuraiJack__ joined
[19:23] <vendethiel> r: say Any orelse Int orelse 1; say Any // Int // 1;

[19:23] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«(Any)␤1␤»

[19:23] <moritz> r: say (Any or Int or 1)

[19:23] <vendethiel> r: say (Any orelse Int orelse 1); say Any // Int // 1;

[19:23] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«1␤»

[19:23] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«1␤1␤»

[19:23] <moritz> vendethiel: precedence matters :-)

[19:23] <vendethiel> moritz: got it ;)

[19:24] <vendethiel> I just don't understand "orelse" semantics

[19:24] <vendethiel> r: say try die "oh noes" or 1;

[19:24] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«Nil␤»

[19:24] <vendethiel> r: say try die "oh noes" orelse 1;

[19:24] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«Nil␤»

[19:25] <vendethiel> r: say try (die "oh noes" orelse 1);

[19:25] <camelia> rakudo-parrot a66749, rakudo-jvm a66749, rakudo-moar a66749: OUTPUT«Nil␤»

[19:25] <vendethiel> uh yeah it's as a todo right now ;_;.

[19:26] <vendethiel> So basically, `orelse` treats exception like `or` treats falsy values ? I remember looking at synopsis but I didn't get it

[19:29] <tadzik> in the backlog someone said "tadzik is at fault :o"

[19:29] <timotimo> vendethiel: orelse handles "undefined" values

[19:29] <vendethiel> timotimo: how's it different to // ?

[19:29] <timotimo> and passes them to all parameters of the next thing if it's a pointy block, otherwise creates a $! to bind to

[19:29] <timotimo> hm.

[19:30] <timotimo> r: say die "what is going on!" // 1

[19:30] <camelia> rakudo-jvm c2cc4f: OUTPUT«(timeout)»

[19:30] <camelia> ..rakudo-parrot c2cc4f, rakudo-moar c2cc4f: OUTPUT«what is going on!␤  in block  at /tmp/tmpfile:1␤␤»

[19:30] <timotimo> orelse wouldn't sink this exception

[19:30] <vendethiel> timotimo: your tests include a `try`; though

[19:31] <timotimo> it's so that the whole test file doesn't blow up if the exception gets sunk :)

[19:31] <vendethiel> Alrighty. I'm not sure why it's doing `or`'s job too, tho ?

[19:32] <timotimo> you mean it should only go to the next thing if there was a failure?

[19:32] <timotimo> rather than any undefined value?

[19:33] <timotimo> synopsis says "[orelse] Returns the first argument that evaluates successfully (that is, if the result is defined)."

[19:34] <vendethiel> alrighty. That's a bit hard to grasp if you don't connect "successfully" with "without an exception"

[19:34] <timotimo> right.

[19:34] <vendethiel> so, you could add CATCH { fail; } after the `try`s in your last commit test file ?

[19:34] <timotimo> fail?

[19:35] <vendethiel> fail a test

[19:35] <vendethiel> `try { die "oh noes" orelse $result = 1; CATCH { $result = 0; } }; ok $result;`

[19:35] <timotimo> r: use Test; fail "whhyyyyyyyy"

[19:35] <camelia> rakudo-parrot c2cc4f: OUTPUT«whhyyyyyyyy␤current instr.: 'throw' pc 418065 (src/gen/p-CORE.setting.pir:174958) (gen/parrot/CORE.setting:11009)␤called from Sub 'sink' pc 456246 (src/gen/p-CORE.setting.pir:189173) (gen/parrot/CORE.setting:12446)␤called from Sub 'MAIN' pc 379 (sr…»

[19:35] <camelia> ..rakudo-jvm c2cc4f: OUTPUT«Unhandled exception: whhyyyyyyyy␤  in throw (gen/jvm/CORE.setting:11008)␤  in sink (gen/jvm/CORE.setting:12444)␤  in MAIN (gen/jvm/main.nqp:47)␤  in  (gen/jvm/main.nqp:41)␤  in  (gen/jvm/main.nqp)␤␤»

[19:35] <camelia> ..rakudo-moar c2cc4f: OUTPUT«Unhandled exception: whhyyyyyyyy␤   at src/gen/m-CORE.setting:11067  (/home/p6eval/rakudo-inst-1/languages/perl6/runtime/CORE.setting.moarvm:throw:129)␤ from src/gen/m-CORE.setting:12501  (/home/p6eval/rakudo-inst-1/languages/perl6/runtime/CORE.setting…»

[19:35] <timotimo> fail is actually not a Test thing

[19:35] <timotimo> i think you mean flunk or something?

[19:36] <timotimo> r: use Test; flunk "whyyyy"

[19:36] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«not ok 1 - flunk whyyyy␤»

[19:36] <vendethiel> timotimo: yeah :). "carp" :p

[19:36] <vendethiel> (at least I think carp is a perl thingie ?)

[19:36] <timotimo> that's what i use the result thingie for at the moment

[19:36] <timotimo> carp is a perl5 thing at least

[19:37] <vendethiel> timotimo: would the code I posted just before your "r: fail why" work or not ?

[19:37] <vendethiel> (in a 100% rakudo world)

[19:38] <timotimo> i think it would

[19:38] <timotimo> but i don't see why i would have to put the catch in

[19:38] <vendethiel> to check the exception is correctly "stopped"

[19:39] <vendethiel> I'm not saying you should put it, I'm just asking for correct behavior

[19:39] <vendethiel> (check that orelse doesn't rethrow like some mechanics in some languages...)

[19:40] <lue> Couldn't you use something like  dies_ok  ?

[19:41] <vendethiel> wouldn't dies_ok check if it indeed threw an exception ?

[19:41] <timotimo> lives_ok, actually

[19:41] <vendethiel> then yeah

[19:43] <vendethiel> timotimo: wouldn't it make sense to have `lives_ok { die "oh noes" orelse $result = 1 }` ?

[19:43] <timotimo> sounds good to me actually

[19:43] <timotimo> if you'd like to patch it, feel free :)

[19:44] <vendethiel> timotimo: should I patch every try, or only once ?

[19:44] <timotimo> every one of them

[19:44] <timotimo> should result in cleaner code

[19:45] <vendethiel> timotimo: hum, how so?

[19:45] <timotimo> ... it would not?

[19:45] <vendethiel> I'm just thinking of adding `lives_ok ` before each `try`. Not sure why that's cleaner?

[19:45] <vendethiel> well before code blocks

[19:46] <vendethiel> r: use Test; lives_ok { die "oh noes"; }

[19:46] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«not ok 1 - ␤# oh noes␤»

[19:46] <vendethiel> r: use Test; lives_ok { try die "oh noes"; }

[19:46] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«ok 1 - ␤»

[19:46] <vendethiel> timotimo: definitely cleaner code

[19:47] *** rurban joined
[19:47] <vendethiel> timotimo: https://github.com/perl6/roast/pull/39, is that okay ?

[19:48] <timotimo> could you give the lives_ok a little message, too?

[19:50] <vendethiel> r: lives_ok { die "oh noes" orelse ok True, "orelse works!"; }, "orelse sinks exceptions";

[19:50] <camelia> rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Undeclared routines:␤    lives_ok used at line 1␤    ok used at line 1. Did you mean 'on'?␤␤»

[19:50] <camelia> ..rakudo-parrot c2cc4f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Undeclared routines:␤    lives_ok used at line 1␤    ok used at line 1␤␤»

[19:50] <vendethiel> r: use Test; lives_ok { die "oh noes" orelse ok True, "orelse works!"; }, "orelse sinks exceptions";

[19:50] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«not ok 1 - orelse sinks exceptions␤# oh noes␤»

[19:51] *** hoverboard joined
[19:51] *** rurban left
[19:51] <timotimo> oh, something i forgot about

[19:52] <timotimo> this will give variable numbers of tests depending on how it acts

[19:52] <vendethiel> lives_ok should count for 2 tests, basically ?

[19:53] <vendethiel> there's no "plan", though

[19:53] *** pdcawley left
[19:54] *** pdcawley joined
[19:54] <vendethiel> (an exception that sinks is an exception that gets thrown ? "method sink() { $!exception.throw unless $!handled }". Thought it was the opposite, as I'm not sure of the overloaded meanings of "sink")

[19:55] <timotimo> well, there may not be a plan, but diffing runs where something in the middle changes will be *weird*

[19:56] <timotimo> sink basically means something like "doesn't get assigned to a variable or returned"

[19:57] *** raiph left
[19:57] <vendethiel> so the message should be "orelse doesn't sink exception" ?

[19:58] <vendethiel> (I get "sink context" for values; not so much for exceptions)

[20:00] <vendethiel> Well, not sure how to get the correct test count then -- I think there's a way to make a test count as two passed?

[20:00] *** rurban joined
[20:00] <timotimo> hmm. maybe something like "orelse doesn't rethrow exception" would be better?

[20:00] <timotimo> well, the exception causes the "ok" to be skipped

[20:01] <vendethiel> yeah, that I get.

[20:01] <timotimo> the try i had in it before prevented that exact problem :\

[20:02] <vendethiel> I can use the CATCH method I talked about earlier

[20:02] *** zakharyas left
[20:02] <timotimo> hmm, CATCH { flunk "exception rethrown" } ?

[20:03] <vendethiel> flunk just fails instead of being counted as a failed test ?

[20:03] <vendethiel> CATCH { $result = 0 } ? I thought about flunk; but that's one less test if it succeeds as well, no ?

[20:04] <timotimo> i think flunk is like "ok 0"

[20:04] *** rurban left
[20:05] <vendethiel> but that's an `ok` a correct `orelse` will never hit, right ?

[20:07] <timotimo> yes

[20:07] <timotimo> so the correct orelse will reach the "ok $result"

[20:07] <timotimo> and an incorrect one will get the flunk instead

[20:08] <vendethiel> an incorrect orelse will get to the `ok` too, because of the try.

[20:08] <vendethiel> unless you want me to move the try "outside"?

[20:09] <vendethiel> r: use Test; { my $result; try { die "oh noes" orelse $result = 1; CATCH { flunk "test failed!" } }; ok $result, "orelse works"; } # incorrect orelse will get to the `ok`

[20:09] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«not ok 1 - flunk test failed!␤oh noes␤  in block  at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[20:10] <timotimo> the try can be replaced with lives_ok in that case

[20:11] *** SamuraiJack__ left
[20:12] <vendethiel> timotimo: `try { die "oh noes" orelse ok 1; CATCH { flunk "doesn't work" } }` # does it thunk ?

[20:13] <timotimo> orelse is supposed to thunk and i believe it already does in rakudo

[20:13] <vendethiel> so would that work ?

[20:13] <timotimo> because currently it uses the "defor" op internally so far

[20:13] <timotimo> well, if it is wrong in the way that it won't thunk, we'll get an ok in this case :)

[20:14] <timotimo> though it'll show up as a not ok in an earlier test

[20:19] <vendethiel> timotimo: is that implem. okay for you ?

[20:20] <timotimo> i suppose it can be okay

[20:25] <timotimo> so in order to implement the correct thunking for orelse, i copied "make_topic_block_ref" to "make_exception_topic_block_ref", but i need to mix that with make_thunk_ref and then block_closure

[20:26] <timotimo> sadly, make_thunk_ref uses create_simple_code_object, which creates a block without a signature, which is wrong for my purposes

[20:26] <timotimo> a tip on how to avoid code duplication here?

[20:26] <timotimo> can i twiddle the signature later on perhaps?

[20:27] *** LLamaRider left
[20:29] <vendethiel> r: use Test; diag "ok"

[20:29] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«# ok␤»

[20:29] <vendethiel> diag's basically flunk's opposite?

[20:31] <vendethiel> r: try { die "a"; CATCH { say "foo"; } }

[20:31] <timotimo> well ... for some value of opposite

[20:31] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«foo␤a␤  in block  at /tmp/tmpfile:1␤␤»

[20:31] <timotimo> it outputs the text you give it as a TAP-aware comment

[20:31] <vendethiel> r: try { die "a"; CATCH { default { say "foo" } } }

[20:31] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«foo␤»

[20:32] <vendethiel> r: try { die "a" orelse diag("orelse works !"); CATCH { flunk "orelse shouldn't rethrow exceptions" } }

[20:32] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile␤Undeclared routines:␤    diag used at line 1␤    flunk used at line 1. Did you mean 'link'?␤␤»

[20:32] <vendethiel> r: use Test; try { die "a" orelse diag("orelse works !"); CATCH { flunk "orelse shouldn't rethrow exceptions" } }

[20:32] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«not ok 1 - flunk orelse shouldn't rethrow exceptions␤a␤  in block  at /tmp/tmpfile:1␤␤»

[20:32] <vendethiel> timotimo: ^^ basically what I'm getting at

[20:32] <timotimo> diag doesn't count as a passed test

[20:33] <vendethiel> oh yeah, it doesn't call proclaim

[20:33] <vendethiel> I guess I'm looking for "pass"

[20:34] <vendethiel> r: use Test; try { die "a" orelse pass "orelse works !"; CATCH { flunk "orelse shouldn't rethrow exceptions" } }

[20:34] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«not ok 1 - flunk orelse shouldn't rethrow exceptions␤a␤  in block  at /tmp/tmpfile:1␤␤»

[20:34] <timotimo> oh, yes, pass

[20:35] <vendethiel> timotimo: I currently have `{ lives_ok { ... } }`. Should I remove outer brackets or does that make #? comments fail ?

[20:35] *** klapperl_ joined
[20:35] <timotimo> keep them, for that exact reason

[20:36] *** klapperl left
[20:36] <vendethiel> guessed so

[20:37] <vendethiel> r: use Test; class LilStr { method Str { "foo" } }; my $lil = LilStr.new; ok ~$lil eq "foo";

[20:37] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«ok 1 - ␤»

[20:37] *** hoverboard left
[20:37] <vendethiel> r: use Test; class LilStr { method Str { "foo" } }; my $lil = LilStr.new; ok ~$lil eq "foo", "It does work !"

[20:37] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«ok 1 - It does work !␤»

[20:41] <vendethiel> timotimo: updated

[20:43] <timotimo> i *think* it's all right

[20:43] <timotimo> i'll merge it

[20:43] <timotimo> thank you :)

[20:43] <dalek> roast: 2274ac4 | Nami-Doc++ | S03-operators/orelse.t:

[20:43] <dalek> roast: Swap `try`s for `lives_ok`

[20:43] <dalek> roast: review: https://github.com/perl6/roast/commit/2274ac402a

[20:43] <dalek> roast: d90866d | Nami-Doc++ | S03-operators/orelse.t:

[20:43] <dalek> roast: Swap `$result` variables for `try`-`die`-`CATCH`

[20:43] <dalek> roast: review: https://github.com/perl6/roast/commit/d90866d01c

[20:43] <dalek> roast: 57c7c92 | timo++ | S03-operators/orelse.t:

[20:43] <dalek> roast: Merge pull request #39 from Nami-Doc/patch-1

[20:43] <dalek> roast: 

[20:43] <dalek> roast: Swap `try`s for `lives_ok`

[20:43] <dalek> roast: review: https://github.com/perl6/roast/commit/57c7c9268d

[20:43] <vendethiel> thanks ! :)

[20:43] <timotimo> no, thank you! :P

[20:43] * lizmat runs a new spectest

[20:44] *** Ven left
[20:49] <lizmat> not ok 9 - flunk orelse shouldn't rethrow exceptions# TODO orelse exception semantics

[20:49] <lizmat> oh noes!

[20:49] <lizmat>   in block  at t/spec/S03-operators/orelse.rakudo.moar:17

[20:49] <lizmat>   in block  at t/spec/S03-operators/orelse.rakudo.moar:15

[20:49] <lizmat> also: why isn't there a plan in that test-file ?

[20:49] <lizmat> plans are good!

[20:50] * lizmat hopes timotimo watches

[20:51] <timotimo> fair enough

[20:51] <timotimo> so that test file aborts there

[20:51] <timotimo> vendethiel: we need to cause the exception to be considered "handled"

[20:51] *** ajr_ left
[20:52] <lizmat> isn't that just an attribute you can set on the Exception object ?

[20:52] <vendethiel> timotimo: wdym ?

[20:52] <vendethiel> shouldn't get to `CATCH` if `orelse` works, right ? and there's the try ?

[20:54] <timotimo> i need to look closely again :)

[20:55] <timotimo> i was watching a sonic 3 speedrun on the side ~_~

[20:55] <vendethiel> oooh, a speedrun lover :D.

[20:55] <timotimo> if CATCH doesn't have a default { } we have to manually set $!.handled

[20:55] *** flussence joined
[20:55] <vendethiel> then just adding default should do, right ?

[20:57] <vendethiel> r: try { die "rip"; }

[20:57] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: ( no output )

[20:57] <vendethiel> r: try { die "rip"; CATCH {} }

[20:57] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«rip␤  in block  at /tmp/tmpfile:1␤␤»

[20:57] <vendethiel> alrighty.

[20:57] <vendethiel> r: try { die "rip"; CATCH { default {} } }

[20:57] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: ( no output )

[20:57] <timotimo> do you have a commit bit to the roast repo?

[20:57] <timotimo> i'd be fine with you applying that fix directly

[20:57] <vendethiel> I don't

[20:59] <timotimo> i don't have permissions to give, i believe

[21:00] <vendethiel> PR is fine too

[21:00] *** Rotwang left
[21:01] *** rurban joined
[21:01] <timotimo> for now :)

[21:01] <vendethiel> that certainly is motivating.

[21:01] <vendethiel> "whoaw, I'm not only annoying people on IRC now !"

[21:03] <vendethiel> Ask I shall try not to fail. https://github.com/perl6/roast/pull/40

[21:04] <dalek> roast: 5493dc6 | Nami-Doc++ | S03-operators/orelse.t:

[21:04] <dalek> roast: Use `default` to mark exceptions as handled

[21:04] <dalek> roast: review: https://github.com/perl6/roast/commit/5493dc6321

[21:04] <dalek> roast: 9191138 | timo++ | S03-operators/orelse.t:

[21:04] <dalek> roast: Merge pull request #40 from Nami-Doc/patch-2

[21:04] <dalek> roast: 

[21:04] <dalek> roast: Use `default` to mark exceptions as handled (instead of skipping the rest of the test fiile)

[21:04] <dalek> roast: review: https://github.com/perl6/roast/commit/9191138fb9

[21:05] *** rurban left
[21:07] *** pdcawley left
[21:16] *** pippo joined
[21:16] <pippo> Hello #perl6

[21:17] *** spider-mario left
[21:17] <pippo> p6: say "[aaaa]" ~~ / '[' ~ ']' .+/;

[21:17] <camelia> niecza v24-109-g48a8de3: OUTPUT«Unhandled exception: Unable to parse anonymous regex␤Couldn't find final ']'; gave up␤  at /home/p6eval/niecza/lib/CORE.setting line 1536 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2962 (Cursor.FAILGOAL @ 6) ␤  at /tmp/tmpfile l…»

[21:17] <camelia> ..rakudo-jvm c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/jvm/stage2/QRegex.nqp:1146␤  in method ACCEPTS at gen/jvm/CORE.setting:12808␤  in method ACCEPTS at gen/jvm/CORE.setting:798␤  in block  at /tmp/tmpfile:1␤␤»

[21:17] <camelia> ..rakudo-parrot c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/parrot/stage2/QRegex.nqp:1143␤  in regex  at /tmp/tmpfile:1␤  in method ACCEPTS at gen/parrot/CORE.setting:12810␤  in method ACCEPTS at gen/parrot/CORE.setting:794…»

[21:17] <camelia> ..rakudo-moar c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/moar/stage2/QRegex.nqp:1146␤  in method ACCEPTS at src/gen/m-CORE.setting:12865␤  in method ACCEPTS at src/gen/m-CORE.setting:798␤  in block  at /tmp/tmpfile:1␤␤»

[21:20] *** pippo left
[21:20] <FROGGS> p6: say "[aaaa]" ~~ / '[' .+ ']' /;

[21:20] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f, niecza v24-109-g48a8de3: OUTPUT«｢[aaaa]｣␤␤»

[21:21] *** rindolf left
[21:22] *** pippo joined
[21:22] <timotimo> oh, huh?

[21:23] <timotimo> p6: say "[aaaa]" ~~ / '[' ~ ']' (.+) /;

[21:23] <camelia> niecza v24-109-g48a8de3: OUTPUT«Unhandled exception: Unable to parse anonymous regex␤Couldn't find final ']'; gave up␤  at /home/p6eval/niecza/lib/CORE.setting line 1536 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2962 (Cursor.FAILGOAL @ 6) ␤  at /tmp/tmpfile l…»

[21:23] <camelia> ..rakudo-jvm c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/jvm/stage2/QRegex.nqp:1146␤  in method ACCEPTS at gen/jvm/CORE.setting:12808␤  in method ACCEPTS at gen/jvm/CORE.setting:798␤  in block  at /tmp/tmpfile:1␤␤»

[21:23] <camelia> ..rakudo-parrot c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/parrot/stage2/QRegex.nqp:1143␤  in regex  at /tmp/tmpfile:1␤  in method ACCEPTS at gen/parrot/CORE.setting:12810␤  in method ACCEPTS at gen/parrot/CORE.setting:794…»

[21:23] <camelia> ..rakudo-moar c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/moar/stage2/QRegex.nqp:1146␤  in method ACCEPTS at src/gen/m-CORE.setting:12865␤  in method ACCEPTS at src/gen/m-CORE.setting:798␤  in block  at /tmp/tmpfile:1␤␤»

[21:23] <FROGGS> timotimo: that is known

[21:23] <timotimo> oh?

[21:23] <FROGGS> that form does notback of properly

[21:23] <timotimo> ah

[21:23] <FROGGS> s/not/not /

[21:23] <timotimo> it eats the ']' as a .

[21:23] <jnthn> I don't think the ~ form is meant to

[21:24] <pippo> "[a]" ~~ /'[' ~ ']' . /;

[21:24] <FROGGS> m: "[a]" ~~ /'[' ~ ']' . /;

[21:24] <camelia> rakudo-moar c2cc4f: ( no output )

[21:24] <FROGGS> m: say "[a]" ~~ /'[' ~ ']' . /;

[21:24] <camelia> rakudo-moar c2cc4f: OUTPUT«｢[a]｣␤␤»

[21:24] <FROGGS> m: say "[a]" ~~ /'[' ~ ']' .+ /;

[21:24] <camelia> rakudo-moar c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/moar/stage2/QRegex.nqp:1146␤  in method ACCEPTS at src/gen/m-CORE.setting:12865␤  in method ACCEPTS at src/gen/m-CORE.setting:798␤  in block  at /tmp/N4pOHKF1ZV:1␤␤»

[21:24] <lue> I think r-m has far more faith in my computer than most; it was 14 threads when I bothered checking htop how part of my program was going :)

[21:24] <timotimo> m: say "[aaaaa]" ~~ / '[' ~ ']' .+?

[21:24] <camelia> rakudo-moar c2cc4f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/WZRmPuNj5y␤Regex not terminated␤at /tmp/WZRmPuNj5y:1␤------> [32msay "[aaaaa]" ~~ / '[' ~ ']' .+?[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        infix stopper␤   …»

[21:24] <timotimo> m: say "[aaaaa]" ~~ / '[' ~ ']' .+? /

[21:24] <camelia> rakudo-moar c2cc4f: OUTPUT«Unable to parse expression in ; couldn't find final ']' ␤  in any FAILGOAL at gen/moar/stage2/QRegex.nqp:1146␤  in method ACCEPTS at src/gen/m-CORE.setting:12865␤  in method ACCEPTS at src/gen/m-CORE.setting:798␤  in block  at /tmp/6Y2sPHwzvT:1␤␤»

[21:25] <timotimo> even with a frugal quantifier?

[21:26] *** bjz left
[21:26] *** bjz joined
[21:26] <FROGGS> TimToady++ commented on that once, and IIRC it is as jnthn++ says

[21:27] <timotimo> oh hm

[21:27] <timotimo> fair enough

[21:28] <FROGGS> definitely a WAT though :o)

[21:28] <timotimo> you know what we can do?

[21:28] <jnthn> Well, it's designed to help you get good errors when you're *parsing*.

[21:29] <timotimo> we could warn if the regex between the [ and ] is nonspecific enough to eat up the ]

[21:29] <timotimo> and then if we find any "]" exactly one step before the current cursor position

[21:30] <gtodd> I like how rakudo-parrot , rakudo-jvm , rakudo-moar all talk to me when I send code strings to rakudo ... but what is "c2cc4f:"  ?

[21:30] <timotimo> we add a little help text to the error

[21:30] <timotimo> gtodd: it's the commit id of rakudo that was used to compile the evalbot's current revision

[21:30] <gtodd> oh perfect

[21:30] <timotimo> gtodd: if you're interested in doing a little perl5 work, you could implement a function to shorten that part of the message for us

[21:30] <FROGGS> gtodd: see:

[21:30] <FROGGS> <dalek> rakudo/nom: c2cc4fd | (Timo Paulssen)++ | t/spectest.data:

[21:30] <FROGGS> <dalek> rakudo/nom: run the new orelse tests

[21:30] <FROGGS> <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2cc4fdd04

[21:31] <gtodd> I thought it was some strange unicode my irc client was munging

[21:31] * lizmat runs a spectest again

[21:33] *** Mouq joined
[21:34] <lue> I don't suppose there's a $*MAX_THREADS or something where I can say "My computer can only safely do 3 threads here", e.g.   sub intense_func() { $*MAX_THREADS = 3; ... }    ?

[21:34] <Mouq> r: say "abcd[efgh], something[bananas[what, is_up]]" ~~ ms/(\w+[ \[ ~ \] <sub-expr=~~> ]?) *% \, /

[21:34] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«｢abcd[efgh], something[bananas[what, is_up]]｣␤ 0 => ｢abcd[efgh]｣␤  sub-expr => ｢efgh｣␤   0 => ｢efgh｣␤ 0 => ｢something[bananas[what, is_up]]｣␤  sub-expr => ｢bananas[what, is_up]｣␤ …»

[21:35] <timotimo> there is, lue 

[21:35] <timotimo> you can create your own $*SCHEDULER

[21:35] <timotimo> and everything will use that by default

[21:35] *** kurahaupo left
[21:35] <timotimo> the ThreadPoolScheduler has a value you can set for the max number of threads

[21:35] <lizmat> timotimo: looks fine here new

[21:35] <timotimo> lizmat: excellent. lizmat++ vendethiel++

[21:36] <vendethiel> my first karma \o/

[21:36] <timotimo> i'm convinced it won't be your last :)

[21:36] <lue> timotimo: OK, 'cos while running ≈14 subprocesses of perl6-m is cool, it makes my computer stutter a bit, and it would likely be way more painful for perl6-j :)

[21:37] <timotimo> it may be interesting to check out an environment variable for the construction of the "default" scheduler. jnthn?

[21:37] <gtodd> perl6-m perl6-j ... does that mean there's a perl6-r ?

[21:37] <Mouq> gtodd: There's a perl6-p

[21:37] <lizmat> m: $*SCHEDULER = ThreadPoolScheduler.new( max_threads = 4 )

[21:37] <camelia> rakudo-moar c2cc4f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/VuRqN0xoB9␤Preceding context expects a term, but found infix = instead␤at /tmp/VuRqN0xoB9:1␤------> [32m= ThreadPoolScheduler.new( max_threads =[33m⏏[31m 4 )[0m␤»

[21:37] <gtodd> Mouq: p for parrot ...

[21:37] <Mouq> gtodd: Yup

[21:38] <lizmat> m: $*SCHEDULER = ThreadPoolScheduler.new( max_threads => 4 )

[21:38] <camelia> rakudo-moar c2cc4f: ( no output )

[21:38] <lue> I don't suppose there's a way to say "number of cores plus 1" easily, then?

[21:38] <lue> (maybe I could give my script a -j option and let the user take care of it, like make does :P)

[21:39] <lizmat> the code says ":$!max_threads = 16", patches welcome  :-)

[21:39] <Mouq> gtodd: Note that Parrot, JVM, and MoarVM are all run on the same front-end (Rakudo Perl 6), and that we often build Rakudo for multiple backends simultaneously, since the different backends are good for different things

[21:39] <timotimo> i thought it was already doing that, but it turns out it's set to 16 by default

[21:39] <timotimo> that seems a bit high to me

[21:39] <lue> that would explain the ≈14 threads I saw earlier :)

[21:40] <Mouq> So we install to perl6-{m,j,p} to allow for this

[21:40] <timotimo> (and whatever comes first in Configure.pl's --backends flag gets to be "perl6")

[21:40] <lizmat> I guess we could use an environment variable here ?

[21:41] <lizmat> RAKUDO_MAX_THREADS=4 perl6-m foo

[21:41] <lizmat> anyone?

[21:41] <timotimo> +1 from my side

[21:41] <lue> +1

[21:42] <jnthn> Note that the number of threads you want is normally a property of system load, program behavior, etc.

[21:42] <lue> though I wouldn't mind if Perl 6 had a commandline option too/instead...

[21:42] <jnthn> It won't be getting one. I'm reluctant to give it an env var.

[21:43] <gtodd> hmm so if I want to look up docs on compile/run time constants and variables (the equivalent of perldoc perlvars in pumpkin-perl-5) I type "p6doc variables" and ... well I get what I want but I don't know where I am in the documentation ... I seem to be inside a terminal pager .... 

[21:43] <lue> jnthn: yeah, I was doing fine with a 16 thread default until the part that's a bit more computationally expensive :)

[21:43] <jnthn> lue: Right, and 4 is too few if you're doing lots of I/O

[21:44] <jnthn> lue: The scheduler needs to learn to dynamically work out a sane number of threads

[21:44] <Mouq> gtodd: Yeah… You probably want to look at S28, but that doesn't necessarily match the implementation

[21:44] <jnthn> lue: By observing that adding more than a certain number makes things no better.

[21:44] <Mouq> gtodd: Note that p6doc also has a web setup: http://doc.perl6.org/

[21:45] <gtodd> .. (grepping in ps auxww tells me I'm in /home/gtodd/perl6/doc/bin/../lib/variables.pod)  ... the pods don't seem as "structured" as p5

[21:45] <gtodd> Mouq: yeah 

[21:45] <lue> jnthn: In my case, I'm calling perl6-m subprocesses to process Pod6 docs, which is where the "oh, I'm doing a lot of stuff right now" feeling occurred on a 16 thread maximum.

[21:46] <Mouq> synopsebot: ping? S03

[21:46] <lue> synopsebot only triggers on syn:line

[21:46] <Mouq> Oh :P

[21:47] <gtodd> Mouq:  just noting there seems to be none of the structured documentation cues one normally sees in a pod ... yet ... but I guess POD formats have changed for p6 and are not yet complete

[21:47] <dalek> specs: f136000 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[21:47] <dalek> specs: Add "Redeemed" status and .redeem to Promise

[21:47] <dalek> specs: 

[21:47] <dalek> specs: This would be the equivalent of Channel.close.

[21:47] <dalek> specs: review: https://github.com/perl6/specs/commit/f136000164

[21:47] <lue> gtodd: what do you mean?

[21:47] <Mouq> gtodd: Could you be more specific? What's unstructured about what we have? I'd like to improve what we have if possible

[21:47] <jnthn> lizmat: I...doubt that's going to last.

[21:48] * Mouq has never used p6doc, note

[21:48] *** WJB left
[21:48] <lizmat> jnthn: why?

[21:48] <Mouq> So many questions

[21:48] <Mouq> :)

[21:49] <jnthn> lizmat: Well, for one because a promise being kept/broken means it is implicitly "closed" to further values.

[21:49] <lizmat> But I would like a way to mark the Promise as "the value of the Promise has been processed, don't call me again"

[21:50] <lizmat> s/value/result

[21:50] <Mouq> There is a lot of work we need to do with the documentation

[21:50] <timotimo> so basically a back-channel?

[21:50] <Mouq> I suppose I'll start planning out the steps for implementing smls++'s ideas

[21:50] <lue> gtodd: what about the docs are unstructured to you, out of curiosity?

[21:50] <lizmat> the problem with the current Promise is, that you can fetch its .result as many times as you want

[21:51] <timotimo> Mouq: these ideas were mostly the style and layout of the documentation website?

[21:51] <Mouq> timotimo: They implied a cleaner overall structure though

[21:51] <Mouq> timotimo: And this structure could be back-ported to p6doc

[21:52] <lizmat> m: my $p = Promise.new; $p.keep(42); say $p.result; say $p.result

[21:52] <camelia> rakudo-moar c2cc4f: OUTPUT«42␤42␤»

[21:52] <jnthn> lizmat: But...what if multiple things are processing it?

[21:52] <lizmat> well, then don/t .redeem it

[21:52] *** WJB joined
[21:52] <lizmat> use the vow, and only through the .vow, redeem it

[21:52] *** pippo left
[21:53] <lizmat> when you know that all multiple things have processed it

[21:53] <timotimo> i don't see the sense i nthat :\

[21:53] <jnthn> Now the design problems with winner/outcome/wahtever have polluted the well designed promise.

[21:53] <lizmat> it would make winner { } make sens

[21:53] <timotimo> i thought the redemption was the way to signalize completion of processing backwards to the "owner" of the promise

[21:54] <jnthn> lizmat: No, it will just create horrible action that a distance that we'll end up regretting for years aftewrwards.

[21:54] <jnthn> Maybe winner should just be about channels, if it's going to make us ruin Promise like this.

[21:55] <lue> gtodd: are you saying that the files in p6doc aren't organized, or that there aren't consistent sectionings, or...?

[21:55] <jnthn> And we introduce a Promise.Channel coercion if you really want a channel out of a Promise to use with winner.

[21:55] <lizmat> jnthn: I'm not seeing the action at a distance problem, if you could only redeem through the vow

[21:57] <timotimo> lizmat: if you can only redeem promises through the vow, how do you get the information that processing has finished from the consumers?

[21:57] <lizmat> well, then maybe you cannot redeem promises that have been vowed ?

[21:57] <vendethiel> m: my $p = Promise.new; $.keep({ say "hay"; 42 }); say $p.result; say $p.result;

[21:57] <camelia> rakudo-moar c2cc4f: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/lsfOB0Q7Ok␤Variable $.keep used where no 'self' is available␤at /tmp/lsfOB0Q7Ok:1␤------> [32m= Promise.new; $.keep({ say "hay"; 42 })[33m⏏[31m; say $p.result; say $p.result;[0m␤»

[21:58] <timotimo> the only thing i could imagine is Promise.care giving a handler that you can call .forget on and when the last .care has been .forget'd it would redeem ti, but that seems fragile and racy

[21:58] <vendethiel> m: my $p = Promise.new; $p.keep({ say "hay"; 42 }); say $p.result; say $p.result;

[21:58] <camelia> rakudo-moar c2cc4f: OUTPUT«Block.new()␤Block.new()␤»

[21:58] <timotimo> m: my $p = Promise.new; $p.keep({ say "hay"; 42 }); say $p.result.(); say $p.result.();

[21:58] <camelia> rakudo-moar c2cc4f: OUTPUT«hay␤42␤hay␤42␤»

[21:59] <vendethiel> that's to be expected tho.

[21:59] <timotimo> what exactly?

[21:59] <jnthn> lizmat: vow is used by (hopefully) all the internal promise constructors to make sure only they can keep/break.

[22:00] <lizmat> what I was getting to, is a sane behaviour of:

[22:00] <lizmat> loop { winner { done @p { ... } } }

[22:00] <lizmat> where promised that are redeemed, will never match a "done"

[22:00] <lizmat> *promises

[22:01] <vendethiel> timotimo: the double "hay"

[22:01] <lizmat> in other words, a "Redeemed" status would make winner {} sane

[22:01] *** a3gis joined
[22:02] <timotimo> vendethiel: what was your code trying to prove? o_O

[22:02] *** rurban joined
[22:02] <vendethiel> timotimo: I wanted to know if .result would get the block called

[22:02] <timotimo> ah

[22:02] <vendethiel> and if so, whether it'd be called once or twicve

[22:02] <timotimo> now we know :)

[22:03] <lizmat> and in my proposal, if you would do $p.redeem between the two calls

[22:03] <lizmat> the second one would be a noop now

[22:04] <timotimo> yeah, at the moment you'd need to kick them out of the list

[22:04] <lizmat> which is silly bookkeeping

[22:05] <vendethiel> r: try { die "abc"; CATCH { when Str { say "hey" } } }

[22:05] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«abc␤  in block  at /tmp/tmpfile:1␤␤»

[22:05] <lizmat> anyways, I'm almost done with speccing "outcome"

[22:06] <lizmat> jnthn: if you don't like that, we just revert  :-)

[22:06] <timotimo> one way i could imagine this to go is having a lock and calling @promises>>.then({ $lock.protect: { do something } })

[22:06] <vendethiel> r: say "abc" ~~ Str

[22:06] <camelia> rakudo-parrot c2cc4f, rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«True␤»

[22:06] <vendethiel> Not sure why I can't `catch when str` ?

[22:06] <timotimo> that'll do something similar to the winner loop

[22:06] <lizmat> timotimo: locks are evil and shouldn't be visible like that

[22:06] <timotimo> vendethiel: because die will wrap a string up into an X::AdHoc

[22:06] <timotimo> r: try die "oh god what?"; say $!.DUMP

[22:06] <camelia> rakudo-parrot c2cc4f: OUTPUT«X::AdHoc<1>(␤    :payload(▶"oh god what?"),␤    :$!ex(Exception<3>(...))␤)␤»

[22:06] <camelia> ..rakudo-jvm c2cc4f, rakudo-moar c2cc4f: OUTPUT«X::AdHoc<1>(␤    :payload(▶"oh god what?"),␤    :$!ex(BOOTException<3>(...))␤)␤»

[22:07] *** rurban left
[22:07] <timotimo> lizmat: well, in order to serialize stuff ... hmm.

[22:07] <timotimo> well, i suppose you can also .>>then({$my_channel.send($stuff)}) and serialize it that way

[22:07] <timotimo> and then for @$my_chanel { ... }

[22:07] <timotimo> but those are all hacks i'm afraid

[22:08] <dalek> doc: 8b066e3 | Mouq++ | lib/Bag.pod:

[22:08] <dalek> doc: `==` → `===` in Bag.pod

[22:08] <dalek> doc: 

[22:08] <dalek> doc: `==` is numeric comparison. `===` does what we want here.

[22:08] <dalek> doc: review: https://github.com/perl6/doc/commit/8b066e348a

[22:13] *** kivutar left
[22:19] <dalek> specs: a332fbc | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[22:19] <dalek> specs: Spec "outcome/whenever" instead of "winner/done/more"

[22:19] <dalek> specs: 

[22:19] <dalek> specs: For discussion, and for a test implementation.  Please comment / fire on it /

[22:19] <dalek> specs: shoot it down if you think you should.  By no means do I feel this is the

[22:19] <dalek> specs: final thing.  It's just that winner {} currently is *so* broken, we either

[22:19] <dalek> specs: need to fix that, or come up with something else.  This is just my something

[22:19] <dalek> specs: else :-)

[22:19] <dalek> specs: review: https://github.com/perl6/specs/commit/a332fbcb7e

[22:21] <lizmat> hmmm.. maybe done on a Promise should allow you to redeem the promise

[22:21] <lizmat> done $p1 { $_.redeem }

[22:22] <lue> Is it normal for  panda install  on perl6-m to die with    Nil\nNo such method 'get-project' for invocant of type 'Any'    ?

[22:23] <lizmat> perhaps .redeem should be a separate attribute on the Promise

[22:23] <lizmat> simply to mark it as "handled" as it were

[22:24] <timotimo> it could apply a role perhaps

[22:27] <lizmat> mayhap

[22:28] *** kurahaupo joined
[22:29] <vendethiel> lizmat++ # changing "winner" keyword

[22:32] *** kurahaupo left
[22:34] *** araujo joined
[22:36] <lizmat> gnight #perl6!

[22:37] <jnthn> 'night, lizmat 

[22:37] <Mouq> night lizmat!

[22:38] *** kurahaupo joined
[22:39] <timotimo> gnite liz

[22:45] *** kivutar joined
[22:50] <timotimo> r: sub tester(*@args, *%kw) { say (:@args); say (:%kw) }; tester(1, 2, 3) :{ say "hi"; }

[22:50] <camelia> rakudo-moar c2cc4f: OUTPUT«===SORRY!===␤Cannot find method 'has_compile_time_value'␤»

[22:50] <camelia> ..rakudo-parrot c2cc4f, rakudo-jvm c2cc4f: OUTPUT«===SORRY!===␤No such method 'has_compile_time_value' for invocant of type 'NQPMu'␤»

[22:50] <timotimo> so allegedly that is supposed to work? o_O

[22:56] *** kurahaupo left
[23:01] *** colomon joined
[23:03] *** rurban joined
[23:05] *** dmol left
[23:08] *** rurban left
[23:13] <vendethiel> timotimo: as an adverb?

[23:13] *** colomon left
[23:13] <timotimo> This just naturally falls out from the preceding rules because the adverbial block is in operator position, so it modifies the "find operator". (Parens aren't considered an operator.)

[23:13] <timotimo>     find($directory) :{ when not /^\./ }

[23:14] <vendethiel> uhhh

[23:24] *** kurahaupo joined
[23:24] * Mouq doesn't understand

[23:24] <Mouq> r: sub tester(*@args, *%kw) { say (:@args); say (:%kw) }; tester(1, 2, 3) :( 1 )

[23:24] <camelia> rakudo-moar c2cc4f: OUTPUT«===SORRY!===␤Cannot find method 'has_compile_time_value'␤»

[23:24] <camelia> ..rakudo-parrot c2cc4f, rakudo-jvm c2cc4f: OUTPUT«===SORRY!===␤No such method 'has_compile_time_value' for invocant of type 'NQPMu'␤»

[23:24] <Mouq> What is that supposed to do again?

[23:25] <Mouq> What is the "find operator"?

[23:25] <Mouq> std: sub tester(*@args, *%kw) { say (:@args); say (:%kw) }; tester(1, 2, 3) :( 1 )

[23:25] <camelia> std e347792: OUTPUT«ok 00:01 133m␤»

[23:25] <Mouq> n: sub tester(*@args, *%kw) { say (:@args); say (:%kw) }; tester(1, 2, 3) :( 1 )

[23:25] <camelia> niecza v24-109-g48a8de3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method fakesignature not yet implemented at /tmp/bNv5OYe3eo line 1:␤------> [32mgs); say (:%kw) }; tester(1, 2, 3) :( 1 [33m⏏[31m)[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niec…»

[23:25] <Mouq> n: sub tester(*@args, *%kw) { say (:@args); say (:%kw) }; tester(1, 2, 3) :{ True }

[23:25] <camelia> niecza v24-109-g48a8de3: OUTPUT«"args" => (1, 2, 3).list␤"kw" => {"" => { ... }}.hash␤»

[23:26] <Mouq> n: sub tester(*@args, *%kw) { say (:@args); say (:%kw) }; tester(1, 2, 3) :{ say "hi"; }

[23:26] <camelia> niecza v24-109-g48a8de3: OUTPUT«"args" => (1, 2, 3).list␤"kw" => {"" => { ... }}.hash␤»

[23:29] *** BenGoldberg joined
[23:30] <Mouq> std parses tester(1, 2, 3) and :{ True } as two statements in the same statementlist…

[23:30] *** btyler joined
[23:35] *** colomon joined
[23:44] *** denis_boyun___ left
[23:47] *** colomon left
[23:49] *** kivutar left
[23:54] *** colomon joined
[23:56] *** a3gis left
[23:59] <timotimo> Mouq: i think it's in " " because it's actually not a real "operator" per se; it's just a regular sub that gets postcircumfix:<( )>'d

