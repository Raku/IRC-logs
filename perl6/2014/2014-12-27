[00:00] <raydiak> s/supported/less-committal-sounding-word/ :)
[00:04] *** jack_rabbit joined
[00:10] *** raiph joined
[00:13] *** kjs_ left
[00:15] *** hekmek joined
[00:19] *** spider-mario left
[00:28] *** jack_rabbit left
[00:28] <FROGGS_> .tell moritz I updated http://rakudo.org/
[00:28] <+yoleaux> FROGGS_: I'll pass your message to moritz.
[00:28] <FROGGS_> gnight
[00:39] *** jack_rabbit joined
[00:53] *** Tideflat joined
[01:04] *** bjz left
[01:06] *** bjz joined
[01:09] *** pmurias left
[01:11] *** bjz left
[01:12] <vendethiel> "perl6 is like all the cool shit I ever wanted, but felt too dirty to ask, all packaged in one language"
[01:14] *** raiph left
[01:16] *** bjz joined
[01:17] *** jack_rabbit left
[01:20] *** kjs_ joined
[01:22] *** Tideflat left
[01:23] *** kjs_ left
[01:23] *** kjs_ joined
[01:23] *** hekmek left
[01:26] *** bjz left
[01:26] *** kjs_ left
[01:28] *** risou is now known as risou_awy
[01:42] *** jack_rabbit joined
[01:51] *** bjz joined
[02:01] *** jack_rabbit left
[02:20] *** rmgk_ joined
[02:20] *** rmgk left
[02:20] *** rmgk_ is now known as rmgk
[02:27] *** bjz left
[02:31] *** Mso150_m left
[02:31] *** bjz joined
[02:31] *** Mso150_m joined
[02:50] *** Tideflat joined
[03:01] *** isBEKaml left
[03:28] *** aborazmeh joined
[03:43] *** kaare_ joined
[03:46] *** Akagi201_ joined
[03:47] *** Akagi201 left
[03:48] *** noganex_ joined
[03:52] *** noganex left
[04:01] *** bjz left
[04:05] *** Tideflat left
[04:13] <+dalek> rakudo/nom: 7ea485c | TimToady++ | src/core/array_slice.pm:
[04:13] <+dalek> rakudo/nom: allow @a[0,2...*] to work again
[04:13] <+dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7ea485c8a6
[04:15] <+dalek> roast: fe6352e | TimToady++ | S09-subscript/slice.t:
[04:15] <+dalek> roast: add tests for infinite sequence subscripts
[04:15] <+dalek> roast: review: https://github.com/perl6/roast/commit/fe6352efd3
[04:19] *** gfldex left
[04:24] <TimToady> .tell grondilu @a[0,2...*] works again in the latest rakudo
[04:24] <+yoleaux> TimToady: I'll pass your message to grondilu.
[04:37] *** vendethiel left
[04:39] *** vendethiel joined
[04:41] * moritz found out why Digest::MD5 is broken on r-j
[04:41] <+yoleaux> 00:28Z <FROGGS_> moritz: I updated http://rakudo.org/
[04:42] <moritz> perl6-j -e 'my \T = ($_ for ^2); say T' # produces Nil, should not
[04:55] *** Mso150_m left
[04:55] <ugexe_> m: my $anonfactorial = -> Int $n { $n < 2 ?? 1 !! $n * &?BLOCK($n-1) }; # roast / S02-magicals / block.t
[04:55] <+camelia> rakudo-moar 32c6e4: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/HQydlH12HO‚ê§Undeclared routine:‚ê§    &?BLOCK used at line 1‚ê§‚ê§¬ª
[04:56] <ugexe_> did that used to work?
[04:56] *** Mso150_m joined
[04:57] *** isBEKaml joined
[05:02] <TimToady> not that I know of
[05:02] *** adu joined
[05:03] <moritz> $ git grep  '&?BLOCK'
[05:03] <moritz> src/core/Label.pm:        # XXX Register in &?BLOCK.labels when we have &?BLOCK.
[05:03] <moritz> off to sleepa again&
[05:07] *** bjz joined
[05:07] *** Mso150_m_e joined
[05:07] *** Mso150_m left
[05:15] *** mr-foobar left
[05:21] *** vendethiel left
[05:22] *** vendethiel joined
[05:41] *** aborazmeh left
[05:45] <hoelzro> hey Perl 6 folk; just wanted to spread the word that I've updated the Docker image I've been maintaining for Rakudo * to 2014.12: https://registry.hub.docker.com/u/hoelzro/rakudo-star/
[05:46] *** isBEKaml left
[05:52] <adu> hoelzro: nice
[05:53] <adu> I don't understand docket
[05:53] <adu> docker
[05:56] *** Mso150_m_e left
[06:00] *** Mso150 joined
[06:06] <JimmyZ> adu: https://github.com/dokku-alt/dokku-alt
[06:06] <JimmyZ> it's very easy
[06:07] <Timbus> before i set out on my quest in the completely wrong direction I should ask here: should I try implementing sockets via NativeCall, or should I just extend nqp's already existing socket ops?
[06:08] <JimmyZ> I'd + 1 to the later
[06:09] *** bjz left
[06:10] *** BenGoldberg left
[06:11] <Timbus> so, extend the nqp ops? alright
[06:15] *** vendethiel left
[06:17] *** vendethiel joined
[06:22] <adu> JimmyZ: what's paas?
[06:23] <adu> is it a VM?
[06:24] <JimmyZ> consider it's a vm 
[06:25] <JimmyZ> Timbus: yeah, esp async sockect
[06:25] <adu> but I don't understand why Docker has to be linux on linux, why can't I do freebsd on linux, or linux on macosx
[06:27] <Timbus> JimmyZ, isnt that just regular sockets still? i was thinking I could just rewrite  Socket::INET to return a standrd looking IO handle, and then we could work on an async wrapper for all handles
[06:28] <JimmyZ> async has a eventloop
[06:28] <raydiak> adu: b/c as I understand it, it's more like a bsd jail than a vm
[06:28] <Timbus> unless  we for some reason need epoll support or something?
[06:29] <raydiak> adu: wikipedia says: Docker uses resource isolation features of the Linux kernel such as cgroups and kernel namespaces to allow independent "containers" to run within a single Linux instance, avoiding the overhead of starting virtual machines.
[06:30] <geekosaur> so indeed, it's just bsd jails for linux
[06:32] <raydiak> also says something about "additional layer of abstraction and automation"
[06:32] <adu> raydiak: ok, so what are "containers" used for aside from Docker?
[06:34] <adu> it just sounds like docker is the reason for containers, and containers are the reason for docker... but what advantage is there over, say, using apt-get
[06:34] <geekosaur> "container" is kinda a generic term, referring to a general isolation mechanism present in various forms on various OSes
[06:34] <geekosaur> the key word there being "isolation"
[06:34] <raydiak> I think they are mainly used for ease of deployment and isolation purposes, I'd guess
[06:35] <raydiak> basically you would use this where you might otherwise use a vm, but want something which is a much lighter and more performant
[06:35] <geekosaur> if I run something in a container which becomes infected with malware, it is at least more difficult for it to leak out and affect the host or other containers (how much more difficult depends on the level of isolation, which in turn may depend on what bugs are in the isolation mechanism)
[06:38] *** vendethiel left
[06:39] <raydiak> oh yeah security...might be cool if someone made something like qubes os but based on Docker instead of Xen
[06:41] <geekosaur> another use on linux is that even with tools like alien you can't reliably install an rpm on debian or a deb on fedora... but you can run the appropriate distribution in a docker container with little performance penalty and install it there
[06:45] * geekosaur admits that he mostly considers docker to be a lot of hype, considering that it's what IBM has been doing since the 70s, BSD since the 90s, and Solaris for a decade or so...
[06:48] *** mephinet left
[07:15] *** mephinet joined
[07:17] *** telex left
[07:18] *** telex joined
[07:22] *** szabgab joined
[07:22] *** virtualsue joined
[07:23] <szabgab> hi, I was just wondering where should I file  bugs I encounter with Rakudo Star?  Is sending them to rakudobug@perl.org the best way or shall I put them in GitHub Issues?
[07:24] *** [TuxCM] left
[07:24] *** vendethiel joined
[07:26] <JimmyZ> szabgab: depends on whether it's a module or not
[07:26] *** lue left
[07:26] <szabgab> 1) p6doc not working
[07:26] <szabgab> 2) Some installation error
[07:27] <JimmyZ> szabgab: if it's core rakudo bug, that's the former, other put it in related github repo issues
[07:27] <szabgab> 3) -v giving slightly incorrect
[07:27] <szabgab> ok
[07:30] *** lue joined
[07:30] *** gfldex joined
[07:33] *** denis_boyun joined
[07:33] *** szabgab left
[07:33] *** pyrimidine left
[07:34] *** denis_boyun left
[07:34] *** pyrimidine joined
[07:36] *** denis_boyun joined
[07:36] *** [TuxCM] joined
[07:36] *** denis_boyun left
[07:39] *** denis_boyun_ joined
[07:48] *** vendethiel left
[07:52] *** denis_boyun_ left
[07:55] *** darutoko joined
[07:58] *** szabgab joined
[07:58] *** szabgab left
[08:03] <mathw> m: sub foo(Str | Int $x) { 'hi'; } foo(4);
[08:03] <+camelia> rakudo-moar 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/MnT0VZW7oV‚ê§Missing block‚ê§at /tmp/MnT0VZW7oV:1‚ê§------> [32msub foo(Str | [33m‚èè[31mInt $x) { 'hi'; } foo(4);[0m‚ê§¬ª
[08:04] <mathw> Does that not work anymore?
[08:08] <JimmyZ> Did it work?
[08:08] *** sergot_ joined
[08:08] <mathw> I'm sure it was supposed to work
[08:08] <mathw> once
[08:08] <mathw> maybe it never has
[08:08] <JimmyZ> look like we don't have a test?
[08:08] <mathw> not sure if it's still meant to at some point
[08:09] *** sergot left
[08:09] <JimmyZ> m: sub foo($x where Str | Int) { 'hi'; }; foo(4);
[08:09] <+camelia> rakudo-moar 7ea485: ( no output )
[08:10] <JimmyZ> m: sub(Str | Int $x) { 'hi'; }; foo(4);
[08:10] <+camelia> rakudo-moar 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/EobF_5qJew‚ê§Unable to parse expression in argument list; couldn't find final ')' ‚ê§at /tmp/EobF_5qJew:1‚ê§------> [32msub(Str | Int [33m‚èè[31m$x) { 'hi'; }; foo(4);[0m‚ê§    expecting any of:‚Ä¶¬ª
[08:10] <mathw> ooh
[08:10] <JimmyZ> m: sub foo(Str | Int $x) { 'hi'; }; foo(4);
[08:10] <+camelia> rakudo-moar 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/3mkeWTpkWO‚ê§Missing block‚ê§at /tmp/3mkeWTpkWO:1‚ê§------> [32msub foo(Str | [33m‚èè[31mInt $x) { 'hi'; }; foo(4);[0m‚ê§¬ª
[08:10] <JimmyZ> std: sub foo(Str | Int $x) { 'hi'; }; foo(4);
[08:10] <+camelia> std 76ccee1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse signature at /tmp/jU41eJMQNy line 1:‚ê§------> [32msub foo[33m‚èè[31m(Str | Int $x) { 'hi'; }; foo(4);[0m‚ê§Couldn't find final ')'; gave up at /tmp/jU41eJMQNy line 1:‚ê§------> [32msub foo(Str | [33m‚èè[31m‚Ä¶¬ª
[08:11] *** mickcy_ca joined
[08:11] <mathw> perhaps telling that the only refrence I can find to that kind of functionality is on the Wikipedia page
[08:12] <mickcy_ca> Is there anyone online right now who has any experience with NativeCall?
[08:12] <Timbus> if there was, what would you ask
[08:14] <mickcy_ca> I have been investigating the possibility of writing a socket driver for Perl 6 and am wondering if I need to handle the library includes or are they magically detected.
[08:14] <Timbus> what a coincidence
[08:15] <Timbus> i was just looking into doing that
[08:15] <mickcy_ca> Two heads are better than one ... what have you found?
[08:16] <Timbus> well, I was actually looking into implementing the core sockets routines in the VM instead and providing nqp function calls to access them
[08:16] <Timbus> since we already have a few of those
[08:16] <mickcy_ca> That would definitely be a better solution than going the module route.
[08:17] *** virtualsue left
[08:18] <mickcy_ca> Unfortunately, I have no experience with MoarVM or NQP ... but I could be a fervent tester.
[08:20] <Timbus> well nativecall wouldnt be too bad, probably easier to maintain. but yeah might as well build on what we have
[08:20] *** virtualsue joined
[08:20] <Timbus> also: im not an expert at all, but I'm going to try anyway :o)
[08:20] <mathw> a NativeCall-based module wouldn't work too well for people running on the JVM probably
[08:21] <mathw> the long-term better solution is to have the VM do the work
[08:21] *** adu left
[08:21] <Timbus> yea
[08:21] <mathw> that doesn't mean you couldn't write a NativeCall module for what you need right now of course
[08:21] <mickcy_ca> Of course ...
[08:23] <mickcy_ca> Back to my original question ... do I have to handle the include somelibrary.h or does the VM, Perl 6, or NativeCall do some magical thing to detect which library needs to be included?
[08:23] <Timbus> there is no header
[08:24] <Timbus> uh. that is to say, you don't have to use the header, and more correctly cannot use the header
[08:24] <mickcy_ca> And while the perl6 advent is quite informative, it is quite thin on that issue.
[08:24] *** virtualsue left
[08:25] <Timbus> you simply choose the library and declare the function signatures in it. any constants/macros etc you will need to also manually add in
[08:26] <mickcy_ca> If I understand that correctly, I take the header, parse out the function calls, then implement all of the accessors in Perl 6.
[08:27] <Timbus> yes
[08:27] <mickcy_ca> Or at least the function calls that I choose to implement.
[08:27] <Timbus> or write a header2six script and be a hero for everyone :^)
[08:28] <mickcy_ca> That would certainly stretch my abilities.
[08:28] <Timbus> i think that was attempted in the past, but maybe for parrot
[08:28] *** vendethiel joined
[08:33] <JimmyZ> any C expert? how can I pre-define a array? like static int array[]; ..... ; static int array[] = { .... };
[08:34] <Timbus> int[] array = { }
[08:34] <Timbus> wait no
[08:34] <Timbus> you had it
[08:38] *** virtualsue joined
[08:42] <Timbus> JimmyZ, ` const int a[] = {5,6,7}; ` works for me  and compiles with c89 in pedantic mode. is there something I missed?
[08:42] *** rurban joined
[08:43] <JimmyZ> Timbus: I want to prefine it , without init
[08:44] <JimmyZ> static int array[];  void func() { use array; }; static int array[] = { ... }
[08:45] <mickcy_ca> on the header side of things ... anyone know where get socket.h
[08:45] <Timbus> oooh you mean like predeclare
[08:45] <Timbus> /usr/include/sys/socket.h
[08:45] <Timbus> on linux
[08:45] <mickcy_ca> Not there.
[08:45] *** adu joined
[08:45] <mickcy_ca> As in tried that as did not find it.
[08:46] <Timbus> er, hm. which distro
[08:46] <mickcy_ca> Ubuntu 14.10 Gnome.
[08:47] <Timbus> im in 14.04. have you installed the compiler libs
[08:48] <Timbus> build-essential i believe?
[08:48] <mickcy_ca> As far as a header parser ... do you mean walking all dependancies as well?
[08:49] <mickcy_ca> I have build-essential already installed ... looking into other build*
[08:49] <Timbus> wow. if you really want to try it, just start as simple as you can imo.
[08:50] <Timbus> whats in /usr/include/x86_64-linux-gnu/sys/
[08:51] <mickcy_ca> That is where it is.
[08:52] <Timbus> /usr/include/sys/socket.h: symbolic link to `../x86_64-linux-gnu/sys/socket.h' 
[08:52] <Timbus> odd you dont have that =/
[08:52] <mickcy_ca> Checking ...
[08:53] <mickcy_ca> I have /usr/include/sys but only asoundlib.h lives there right now.
[08:55] *** vendethiel left
[08:56] <Timbus> ¬Ø\(¬∞_o)/¬Ø
[08:56] <mickcy_ca> As simple as possible ... use a grammar to parse the file ... 
[08:58] <mickcy_ca> That is the obvious route with Perl 6 ... but what form should the output take for the greatest usability?
[09:01] *** vendethiel joined
[09:01] <Timbus> JimmyZ, i managed to make it not complain if you use extern
[09:02] <Timbus> C99 also seems to allow it how you wrote it, but it complains (but still works).
[09:02] <JimmyZ> But I want to use static ...
[09:03] <Timbus> will extern make it static? :/
[09:03] <JimmyZ> no, extern will make it global
[09:03] <JimmyZ> :(
[09:07] <Timbus> ive tried like every combination haha. can't do it. it needs a size or extern
[09:07] <Timbus> or c99 with pedantic off
[09:07] <Timbus> :[
[09:11] <mickcy_ca> Timbus: do you have any suggestions for *.h processing output, or perhaps the final target should be a Perl 6 class.
[09:11] *** kjs_ joined
[09:11] <mickcy_ca> That is a fully functional wrapper.
[09:11] <mickcy_ca> Maybe not as a class, but as as role.
[09:13] <mickcy_ca> Can you do role Header dose Other_header { .. }+
[09:13] <mickcy_ca> dose .... does.
[09:14] <Timbus> a fully functional wrapper would be a very large task. id start with a simple translator that can just try pulling out #define'd consts and function defs
[09:14] <Timbus> and see what you can add on from there. maybe structs and such
[09:15] <mickcy_ca> I am aware ... I just like to have my end goal formulated prior to starting, so that I tend to make better choices early on and mitigate the effect on some new data that I become aware of.
[09:16] <mickcy_ca> That is how I would start ... definitely.
[09:19] <Timbus> hmm. i think just a module filled with functions and consts is the best result you could ask for. adding roles and classes seems like something youd do manually
[09:20] <Timbus> the d  language had a htod binary that would do that, and also turn macros into functions
[09:21] <mickcy_ca> To make it the most useful, would not the final target best be a fully functional wrapper implemented as a role?
[09:21] <mickcy_ca> That is, especially if dependencies need to be observed.
[09:22] *** ptc_p6 joined
[09:22] <Timbus> ive never thought of a collection of c functions as roles... roles are reused code, sure, but are generally attached to an object?
[09:23] *** araujo left
[09:25] <mickcy_ca> I was more of thinking of exposing a header file to an application programmer without the requirements if inheritance, but thinking a little further on, perhaps a wrapper class would be better.  Use the inheritance model to handle dependencies.
[09:25] *** araujo joined
[09:25] <mickcy_ca> Of course, in the far future.
[09:27] <Timbus> dont forget you dont need the dependencies of a library resolved.. the library is going to do all that. if the header is supposed to import a whole load of other function defs from other headers though, you can certainly just have the module 'use' the other modules
[09:28] <mickcy_ca> And just because a C programmer does not view the C functions as an OO concept, that doesn't mean that a Perl 6 programmer could not use an encapsulated version in an OO fasion.
[09:30] <Timbus> well, yeah. namespaces are important
[09:30] <Timbus> im surprised youre  taking  my offhand suggestion so seriously
[09:30] <mickcy_ca> Why so surprised ... a good idea is as good idea no matter what the source.
[09:41] *** kjs_ left
[09:42] *** kjs_ joined
[09:43] *** makapa joined
[09:46] *** hekmek joined
[09:47] *** [TuxCM] left
[09:51] *** rurban left
[09:52] *** xfix joined
[09:53] *** [TuxCM] joined
[09:56] *** adu left
[09:59] <mickcy_ca> Does anybody have an idea why:
[10:00] <mickcy_ca> token function { extern \s+ ( \w+ ) \s+ ( \w+ ) \s* ('('.+?')') [\s* (.*?)]?';' }
[10:00] <mickcy_ca> Doesn't match
[10:00] <mickcy_ca> extern int socket (int __domain, int __type, int __protocol) __THROW;
[10:01] <mickcy_ca> When I don't include the ';' in the match, it works mostly as I want it to.
[10:01] <Timbus> spaces are significant in token
[10:01] <Timbus> or.. i thought so
[10:02] <mickcy_ca> This matches 
[10:02] <mickcy_ca> token function { extern \s+ ( \w+ ) \s+ ( \w+ ) \s* ('('.+?')') [\s* (.*?)]? }
[10:02] <Timbus> okay, thats rule with sigspace then
[10:03] <Timbus> my bad.
[10:03] <mickcy_ca> Yup.
[10:03] <Timbus> i shoulda read your whole question :p
[10:04] <mickcy_ca> I am just confused why attempting to match the trailing semicolon to exclude it causes the whole expression to fail.
[10:05] <Timbus> ah
[10:05] <Timbus> its not matching __THROW at all
[10:06] <mickcy_ca> my bad ... this is what matches
[10:06] *** vendethiel left
[10:06] <Timbus> but its optional so it doesnt care. but then it wont match the required ;
[10:06] <mickcy_ca> 	token function { extern \s+ ( \w+ ) \s+ ( \w+ ) \s* ('('.+?')') [\s* (.*)]? }
[10:07] <Timbus> in that case, the last match is eating the ;
[10:08] *** vendethiel joined
[10:08] <mickcy_ca> I am aware ... but putting (.*?) or (.+?) in the last position causes it to fail. 
[10:09] <Timbus> use.. uhh however you do 'not ;'
[10:09] <Timbus> <-[;]> or something D;
[10:09] <mickcy_ca> ';' is doing 'not ;' ?
[10:10] *** kjs_ left
[10:10] <Timbus> no, thats what you want..
[10:12] *** makapa left
[10:13] <Timbus> man its hard to search the synopsis for what i want. you basically want to explicitly not capture the last ';' inside the (.*), in perl 5 id use [^;]
[10:14] *** kjs_ joined
[10:14] <mickcy_ca> I saw how to do that someplace ...
[10:15] <Timbus> extern \s+ ( \w+ ) \s+ ( \w+ ) \s* ('('.+?')') [\s* (<-[;]>+)]?';'
[10:16] *** kjs_ left
[10:16] <mickcy_ca> Thanks ... was pulling my hair out doing that.
[10:16] <Timbus> which you could easily simplify?
[10:16] *** ptc_p6 left
[10:16] <Timbus> extern \s+ ( \w+ ) \s+ ( \w+ ) \s* ('('.+?')') (<-[;]>*) ';'
[10:17] <mickcy_ca> I want not to need to strip any leading whitespace later.
[10:19] *** molaf joined
[10:19] <Timbus> put a \s* back in there i guess
[10:20] <mickcy_ca> That works ... and still matches both cases.
[10:22] <Timbus> ooh. youll need a plus after the negative character class, or youll match a zero-width nothing
[10:22] <Timbus> extern \s+ ( \w+ ) \s+ ( \w+ ) \s* ('('.+?')') (<-[;]>+) ';'
[10:22] *** masakq joined
[10:22] <masakq> good antenoon, #perl6
[10:22] *** spider-mario joined
[10:23] <Timbus> thats just a copy paste, forgot to add the extra \s
[10:23] <Timbus> helo masakq
[10:27] *** Sir_Ragnarok left
[10:27] <Timbus> mickcy_ca, ack i forgot to add-- here ill just paste it from my repl:  extern \s+ ( \w+ ) \s+ ( \w+ ) \s* ('('.+?')') \s* (<-[;]>+)? ';'
[10:31] <masakq> Timbus: without having any context really, I strongly suspect you want to (a) test your regexes, and (b) use 'rule' in a few places where you're currently using 'regex' or 'token'.
[10:31] <Timbus> not mine :P
[10:33] <mickcy_ca> masakq: just getting support for mine.
[10:34] <mickcy_ca> masakq: I am attempting to put together a grammar that will eventually fully parse a C header file.
[10:36] <mickcy_ca> See my gist at http://pastebin.com/PwMpwf7W
[10:36] * masakq looks
[10:36] <mickcy_ca> The function token will eventually be a rule in order to parse it fully.
[10:37] <masakq> right. those tokens there probably want to be rules.
[10:37] <masakq> and you probably want to write tests with succeeding and failing inputs.
[10:37] <masakq> gotta go.
[10:37] *** masakq left
[10:39] *** vendethiel- joined
[10:39] *** vendethiel left
[10:55] *** ptc_p6 joined
[10:57] *** bjz joined
[11:01] *** hekmek left
[11:03] *** rindolf joined
[11:05] <+dalek> infrastructure-doc: 6f589e5 | (Konrad Borowski)++ | hosts/hack.p6c.org.pod:
[11:05] <+dalek> infrastructure-doc: Move rakudobrew out of Administration section.
[11:05] <+dalek> infrastructure-doc: 
[11:05] <+dalek> infrastructure-doc: Rakudobrew is available for users, it's not something that only
[11:05] <+dalek> infrastructure-doc: administrators have access to (unlike adding new users and restarting
[11:05] <+dalek> infrastructure-doc: dalek IRC bot).
[11:05] <+dalek> infrastructure-doc: review: https://github.com/perl6/infrastructure-doc/commit/6f589e50c9
[11:10] *** vendethiel joined
[11:10] *** vendethiel- left
[11:10] <+dalek> infrastructure-doc: 416882e | (Konrad Borowski)++ | hosts/hack.p6c.org.pod:
[11:10] <+dalek> infrastructure-doc: Move External Services into Administration section
[11:10] <+dalek> infrastructure-doc: 
[11:10] <+dalek> infrastructure-doc: Services in this section are pretty much global configuration (the user
[11:10] <+dalek> infrastructure-doc: normally shouldn't need to override stuff like DNS or NTP), and the mirror
[11:10] <+dalek> infrastructure-doc: only contains the repositories for various GNU/Linux distributions.
[11:10] <+dalek> infrastructure-doc: review: https://github.com/perl6/infrastructure-doc/commit/416882edf7
[11:13] <mickcy_ca> Anybody want to comment on : http://pastebin.com/UtuCjFSY
[11:14] <xfix> It probably needs to parse more in order to parse complete C header files :-).
[11:14] <xfix> mickcy_ca, but neat.
[11:17] <xfix> mickcy_ca, also, it's worth noting that variable names are optional in definitions.
[11:17] <mickcy_ca> xfix: I am not sure if order of rules / tokens / regex's is actually important to the parse.  This is designed to match on a line by line basis ... Would like to extend it to just eat an entire file to get what I want, but not sure how to do that yet.
[11:17] <xfix> And extern is optional.
[11:18] <xfix> int socket(int, int, int); /* Valid function definition */
[11:18] *** araujo left
[11:18] <mickcy_ca> I am aware that programming C extern is optional, but is it if the sub is getting exported by a library?
[11:19] *** bjz_ joined
[11:19] <xfix> The issue with parsing line-by-line is that sometimes those definitions have multiple lines.
[11:19] <xfix> For example, definition of fprintf from stdio.h.
[11:19] <xfix> extern int fprintf (FILE *__restrict __stream,
[11:19] <xfix>                     const char *__restrict __format, ...);
[11:19] <mickcy_ca> OK ... this brings me back to how to get a grammar to eat an entire file.
[11:21] <moritz> TheGrammar.parsefile($filename)
[11:21] *** bjz left
[11:22] <xfix> Parsing entire header file would be neat, but I'm also not sure if it's feasible.
[11:22] <xfix> (perhaps Clang has API for that, I don't kknow)
[11:23] <mickcy_ca> xfix: If Perl 6 can parse itself with a grammar ... a header file, which is orders of magnitude simpler, is more than possible.
[11:23] <xfix> Yes, okay.
[11:24] <mickcy_ca> When is Clang usually online?
[11:25] <moritz> http://clang.llvm.org/
[11:25] <mickcy_ca> lol, my mistake.
[11:25] <mickcy_ca> Thanks.
[11:26] <xfix> It would be neat if Rakudo supported uint types.
[11:27] <mickcy_ca> It would be ... what is the definition of uint?
[11:27] <xfix> Unsigned.
[11:27] <xfix> uint8 -> unsigned char (assuming that bytes are 8-bit, which is an assumption that Zavolaj appears to do)
[11:28] <xfix> Although lack of unsigned types in JVM may make it more tricky.
[11:29] <xfix> r: 1/0
[11:29] <mickcy_ca> Curios ... aside from the ability to store larger integers ... why uint?
[11:29] <+camelia> rakudo-{parrot,moar} 7ea485: ( no output )
[11:29] <xfix> mickcy_ca, to make use of APIs that accept/return uint.
[11:30] <xfix> (although, I guess that int is close enough, as long the value is not huge enough)
[11:30] <mickcy_ca> xfix: Could one not just define that data type at run time?
[11:30] <xfix> unsigned int some_c_function(unsigned int something)
[11:31] *** Sir_Ragnarok joined
[11:31] <xfix> https://en.wikipedia.org/wiki/Criticism_of_Java#Unsigned_integer_types
[11:31] <mickcy_ca> Anyway ... gotta go to bed ... 04:30 where I am.
[11:32] <xfix> "and the lack of these types prevents direct data interchange between C and Java"
[11:32] <xfix> This is why I want uint. Just for data interchange between C and Perl 6.
[11:32] <mickcy_ca> Makes sens ...
[11:32] <xfix> Also, bitwise operations are more convenient with unsigned types.
[11:32] <mickcy_ca> See can't even type ...
[11:33] <mickcy_ca> Ok.
[11:33] <mickcy_ca> Good night ... logging off
[11:33] *** mickcy_ca left
[11:33] *** pecastro joined
[11:40] *** rurban joined
[11:43] *** bjz_ left
[11:43] *** bjz joined
[11:50] *** zakharyas joined
[11:51] *** rurban1 joined
[11:51] *** rurban1 left
[12:00] *** kjs_ joined
[12:10] *** Alina-malina left
[12:11] *** Alina-malina joined
[12:12] <vendethiel> m: sub q($x --> Bool) {}
[12:12] <+camelia> rakudo-moar 7ea485: ( no output )
[12:12] <vendethiel> m: sub q($x --> Bool) { return 3 }
[12:12] <+camelia> rakudo-moar 7ea485: ( no output )
[12:17] <+dalek> perl6.org: 9194bca | moritz++ | source/documentation/index.html:
[12:17] <+dalek> perl6.org: Label Synopsis also als Design Documents
[12:17] <+dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/9194bcaba4
[12:20] *** spider-mario left
[12:24] *** spider-mario joined
[12:26] *** isBEKaml joined
[12:26] <+dalek> rakudo/newio: 27a9887 | usev6++ | src/Perl6/Grammar.nqp:
[12:26] <+dalek> rakudo/newio: Allow postfix operator called as method after unary postfix hyper operator
[12:26] <+dalek> rakudo/newio: 
[12:26] <+dalek> rakudo/newio: currently something like '(my @a = 1)>>.++' fails, since METAOP_HYPER_CALL is called
[12:26] <+dalek> rakudo/newio: instead of METAOP_HYPER_POSTFIX. Fixes RT #122342.
[12:26] *** dalek left
[12:26] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=122342
[12:27] *** dalek joined
[12:27] *** ChanServ sets mode: +v dalek
[12:27] *** Mso150 left
[12:27] <+dalek> doc: 1b00933 | moritz++ | lib/HomePage.pod:
[12:27] <+dalek> doc: Link to perl6.org/documentation
[12:27] <+dalek> doc: 
[12:27] <+dalek> doc: ... which in turn links to learnxinyminutes and other resources,
[12:27] <+dalek> doc: thus closing #26.
[12:27] <+dalek> doc: 
[12:27] <+dalek> doc: Also change the perlcabal.org link to design.perl6.org
[12:27] <+dalek> doc: review: https://github.com/perl6/doc/commit/1b0093364a
[12:29] *** hekmek joined
[12:33] *** psch joined
[12:33] *** dakkar joined
[12:33] <psch> hi #perl6 \o
[12:43] *** Rounin joined
[12:44] *** zakharyas left
[12:45] *** kjs_ left
[12:46] *** a3gis joined
[12:47] <a3gis> hello! total newbie to p6 here; could someone tell me what "$^0" does? it seems to return one((Any), 0)
[12:47] <a3gis> I was expecting it to behave like a positional argument ($^a, $^b, ...)
[12:48] <psch> m: { say $^0 }("foo")
[12:48] <+camelia> rakudo-moar 7ea485: OUTPUT¬´one((Any), 0)‚ê§¬ª
[12:49] <lizmat> m: say $ ^ 0
[12:49] <+camelia> rakudo-moar 7ea485: OUTPUT¬´one((Any), 0)‚ê§¬ª
[12:50] <a3gis> ooh
[12:50] <psch> i suppose that's implicit state and EXPR somehow
[12:50] <a3gis> so it behaves like an infix
[12:50] <lizmat> ^ = junctive or
[12:50] <lizmat> $ is unnamed scalar
[12:50] <a3gis> alright, makes sense
[12:50] <a3gis> thanks :)
[12:50] <psch> no idea if we want to allow it as placeholder, considering $42 is designed to work
[12:50] <psch> m: my $42 = 42; say $42
[12:50] <+camelia> rakudo-moar 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/1lt5pAiIlg‚ê§Cannot declare a numeric variable‚ê§at /tmp/1lt5pAiIlg:1‚ê§------> [32mmy $42[33m‚èè[31m = 42; say $42[0m‚ê§¬ª
[12:50] <psch> ahh
[12:50] <psch> no, design is out of date it seems :)
[12:51] <psch> wait
[12:51] <psch> $\d+ is match captures
[12:51] <psch> i'm not awake yet :)
[12:52] * lizmat feels we should probably disallow $^\d+ without whitespace
[12:52] *** Theo_ joined
[12:52] <lizmat> to prevent conceptual confusion with $^a
[12:52] <lizmat> errands&
[12:54] <vendethiel> m: say $^0.perl # wtf is that?
[12:54] <+camelia> rakudo-moar 7ea485: OUTPUT¬´one((Any), 0)‚ê§¬ª
[12:54] *** LLamaRider joined
[12:55] <vendethiel> oh, a3gis asked already
[12:56] *** kjs_ joined
[12:56] <itz> https://events.ccc.de/congress/2014/Fahrplan/schedule/0.html
[12:56] <itz> (OT for perl6 but maybe of interest)
[12:57] <dakkar> what's the p6 idiomatic signature for a sub that accepts a string or undef? (single positional parameter)
[12:57] <vendethiel> m: *.say for ^10
[12:57] <+camelia> rakudo-moar 7ea485: OUTPUT¬´===SORRY!===‚ê§P6opaque: no such attribute '$!phasers'‚ê§¬ª
[12:57] <vendethiel> ^ seems pretty LTA
[12:59] <psch> dakkar: depends on how you want it.  you could give it a default value or declare multis
[12:59] <psch> dakkar: or just put it optional
[12:59] <vendethiel>   $version.split('.').map({any(@els[0..(state $)++]) ?? ( (state $)++ ?? 0 !! $_ + 1 ) !! $_}).join('.') <- so now, I can remove the "(state)" part?
[12:59] <dakkar> psch: in p5 I have sub foo { my ($arg)=@_; return '' unless defined $arg; do_stuff }
[13:00] <dakkar> that looks like a multi, then.
[13:00] <dakkar> what the signature to bind to undef? sub foo(undef) ?
[13:00] <dakkar> no
[13:02] * vendethiel waves at a3gis :P
[13:04] <psch> m: multi foo(Str:U $x) { say "undef" }; multi foo(Str:D $x) { say "$x" }; my Str $x = "foo"; foo $x; $x = Nil; foo $x # dakkar 
[13:04] <+camelia> rakudo-moar 7ea485: OUTPUT¬´foo‚ê§undef‚ê§¬ª
[13:04] <dakkar> ah! thank you. where is it in the synopses? I've looking for a while
[13:05] <psch> S12/Abstract vs Concrete types
[13:05] <psch> S12:Abstract vs Concrete types
[13:05] <synopsebot> Link: http://perlcabal.org/syn/S12.html#Abstract_vs_Concrete_types
[13:05] <dakkar> grr. I was looking at the sub/signature syn
[13:05] <vendethiel> moritz++
[13:06] *** isBEKaml_ joined
[13:08] *** tinyblak joined
[13:09] *** isBEKaml left
[13:16] <psch> vendethiel: i think so.  there was a change somewhen about having bare '$' mean 'state $' somewhen...
[13:17] <vendethiel> psch: yes
[13:17] <psch> s:2nd/somewhen//
[13:17] <vendethiel> psch: I've made the change anyhow :)
[13:18] <psch> vendethiel: as for the WhateverCode iteration, that breaks in the optimizer.  from the looks of it optimize_for_range expects a proper block and can't deal with a WhateverCode
[13:19] * lizmat is testing a fix
[13:20] <+dalek> rakudo/nom: c5e7a77 | lizmat++ | src/Perl6/Optimizer.nqp:
[13:20] <+dalek> rakudo/nom: Protect range optimizer from not having a block
[13:20] <+dalek> rakudo/nom: 
[13:20] <+dalek> rakudo/nom: Fixes the LTA error vendethiel++ found: *.say for ^10
[13:20] <+dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c5e7a7783d
[13:20] <lizmat> really errands&
[13:20] <vendethiel> lizmat++ !
[13:21] <psch> lizmat++ 
[13:22] <+dalek> doc: 21e20c1 | moritz++ | lib/ (2 files):
[13:22] <+dalek> doc: Document mkdir as requested in #33 and ¬ß34
[13:22] <+dalek> doc: 
[13:22] <+dalek> doc: also try to make $*CWD better findable
[13:22] <+dalek> doc: review: https://github.com/perl6/doc/commit/21e20c1033
[13:23] *** sergot_ is now known as sergot
[13:25] *** isBEKaml_ is now known as isBEKaml
[13:25] *** isBEKaml left
[13:25] *** isBEKaml joined
[13:29] <psch> m: :2() # RT #112728
[13:29] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=112728
[13:29] <+camelia> rakudo-moar 7ea485: OUTPUT¬´You have confused the number  with the textual representation "";‚ê§if you wanted to render the number in the given base, use $number.base($radix)‚ê§  in block <unit> at /tmp/na_4apNiYp:1‚ê§‚ê§¬ª
[13:29] <psch> std: :2()
[13:29] <+camelia> std 76ccee1: OUTPUT¬´ok 00:00 136m‚ê§¬ª
[13:33] *** vendethiel- joined
[13:34] *** vendethiel left
[13:45] <hahainternet> that is nearly a fantastic error message
[13:45] <hahainternet> although it is a bit anti DWIM
[13:48] <psch> std: my $a; { $^a } # my favorite error to date
[13:48] <+camelia> std 76ccee1: OUTPUT¬´ok 00:00 137m‚ê§¬ª
[13:49] <psch> :/
[13:49] <psch> i forgot
[13:49] <xfix> This is not an error.
[13:49] <psch> oh right
[13:50] <psch> std: { my $a; $^a }
[13:50] <+camelia> std 76ccee1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§$a has already been used as a non-placeholder in the surrounding block,‚ê§  so you will confuse the reader if you suddenly declare $^a here at /tmp/ZZ3HHOBrqD line 1:‚ê§------> [32m{ my $a; [33m‚èè[31m$^a }[0m‚ê§Potential diff‚Ä¶¬ª
[13:50] <psch> that's it :P
[13:51] <xfix> (although, a point can be made in that Perl 6 should allow the user to confuse people who will maintain the code)
[13:52] <psch> std: { $^a; $a }
[13:52] <+camelia> std 76ccee1: OUTPUT¬´ok 00:00 136m‚ê§¬ª
[13:53] <psch> that's what makes the error good there IMO
[13:53] <xfix> My favorite error is something else.
[13:53] <xfix> r: promptt "What's your name? "
[13:53] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[13:53] <+camelia> ..rakudo-moar 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Undeclared routine:‚ê§    promptt used at line 1. Did you mean 'prompt'?‚ê§‚ê§¬ª
[13:53] <xfix> (hm... and Parrot complains about ICU... this is not what I wanted)
[13:53] <xfix> "Did you mean 'prompt'?"
[13:54] <xfix> It tells you what you may have expected, but at the same time, it doesn't automatically replace (DWIM is not always good).
[13:54] <psch> yeah, the levenshtein stuff in the Actions is great.  timotimo++ iirc
[13:58] <xfix> p: 1
[13:58] <+camelia> rakudo-parrot 7ea485: ( no output )
[13:58] <xfix> p: deqwuinfdigner
[13:58] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/naVGGunoku‚ê§Undeclared routine:‚ê§    deqwuinfdigner used at line 1‚ê§‚ê§¬ª
[13:58] <xfix> Hm, and now it complains about undeclared routine.
[13:58] <xfix> p: promptt
[13:58] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[13:59] <xfix> Interesting.
[13:59] <psch> p: ssay
[13:59] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/0Hj6dbg2WS‚ê§Undeclared routine:‚ê§    ssay used at line 1. Did you mean 'say'?‚ê§‚ê§¬ª
[13:59] <psch> p: prampt
[13:59] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/56ma3UMFE0‚ê§Undeclared routine:‚ê§    prampt used at line 1. Did you mean 'prompt'?‚ê§‚ê§¬ª
[14:00] <xfix> Oh well, it's probably better to enable ICU, but why it complains on promptt when it doesn't on prampt.
[14:00] <psch> p: promptd
[14:00] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[14:01] <psch> huh
[14:01] <xfix> r: say $*VM.config<has_icu>
[14:01] <+camelia> rakudo-moar 7ea485: OUTPUT¬´(Any)‚ê§¬ª
[14:01] <+camelia> ..rakudo-parrot 7ea485: OUTPUT¬´0‚ê§¬ª
[14:02] *** aborazmeh joined
[14:03] <psch> p: sayz
[14:03] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CSzNv34T75‚ê§Undeclared routine:‚ê§    sayz used at line 1. Did you mean 'say'?‚ê§‚ê§¬ª
[14:04] <psch> i don't think i want to build parrot to look at that :)
[14:05] <xfix> moritz, can you install libicu-dev on host08.perl6.com?
[14:07] <xfix> But ICU aside... why this only happens only sometimes?
[14:07] * xfix checks
[14:07] <psch> p: prompt
[14:07] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/eUnYe9MELe‚ê§Calling 'prompt' requires arguments (if you meant to operate on $_, please use .prompt or use an explicit invocant or argument)‚ê§    Expected: :(Any $msg)‚ê§at /tmp/eUnYe9MELe:1‚ê§--‚Ä¶¬ª
[14:07] *** LLamaRider left
[14:07] <psch> p: prompt "foo"
[14:07] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´foo¬ª
[14:07] <psch> xfix++
[14:08] <xfix> First of all, this error comes from Parrot VM.
[14:09] <xfix> When is unicode_compose called...
[14:10] <xfix> p: sayd
[14:10] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/xBWlxGbQO5‚ê§Undeclared routine:‚ê§    sayd used at line 1. Did you mean 'say'?‚ê§‚ê§¬ª
[14:10] <xfix> p: promptq
[14:10] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[14:10] <xfix> p: prompq
[14:10] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/OiQDv9aROO‚ê§Undeclared routine:‚ê§    prompq used at line 1. Did you mean 'prompt'?‚ê§‚ê§¬ª
[14:10] <xfix> p: prompqq
[14:10] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[14:11] <xfix> p: sub long-method-name { }; long-method-named
[14:11] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/c_AQcHrpZP‚ê§Undeclared routine:‚ê§    long-method-named used at line 1. Did you mean 'long-method-name'?‚ê§‚ê§¬ª
[14:12] <xfix> p: sub oeinor { }; oeinorr
[14:12] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[14:12] <xfix> p: sub oeinorq { }; oeinorqr
[14:12] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[14:12] <xfix> p: sub oeinorqrdse { }; oeinorqrdser
[14:12] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´===SORRY!===‚ê§no ICU lib loaded‚ê§¬ª
[14:12] <xfix> p: sub oeinorqrdsezxcv { }; oeinorqrdsezxcvr
[14:12] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/NkZaLcZxLF‚ê§Undeclared routine:‚ê§    oeinorqrdsezxcvr used at line 1. Did you mean 'oeinorqrdsezxcv'?‚ê§‚ê§¬ª
[14:12] <xfix> p: sub oeinorqrdsezx { }; oeinorqrdsezxr
[14:12] <+camelia> rakudo-parrot 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/8_NDdoKu8c‚ê§Undeclared routine:‚ê§    oeinorqrdsezxr used at line 1. Did you mean 'oeinorqrdsezx'?‚ê§‚ê§¬ª
[14:12] <xfix> Ok, this is crazy.
[14:12] <xfix> It feels so arbitrary.
[14:13] <xfix> Pretty sure levenshtein is related, but...
[14:14] *** kjs_ left
[14:14] <dakkar> what am I doing wrong? ¬´my ($key,$value) = @($string ~~ m{^ (\w+) '=' (.*) $}) or My::Exception.new.throw¬ª
[14:15] <dakkar> when the $string does not contain a '=', the exception is not thrown‚Ä¶
[14:15] <psch> m: say "a" ~~ /b/ or die "foo"
[14:15] <+camelia> rakudo-moar 7ea485: OUTPUT¬´Nil‚ê§¬ª
[14:15] <psch> m: say "a" ~~ /b/ // die "foo"
[14:15] <+camelia> rakudo-moar 7ea485: OUTPUT¬´foo‚ê§  in block <unit> at /tmp/KenssRjaSw:1‚ê§‚ê§¬ª
[14:15] <psch> dakkar: "or" is truthy, not defined-y
[14:16] <xfix> r: my ($key,$value) = @($string ~~ m{^ (\w+) '=' (.*) $}) or My::Exception.new.throw
[14:16] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Variable '$string' is not declared‚ê§at /tmp/tmpfile:1‚ê§------> [32mmy ($key,$value) = @($string[33m‚èè[31m ~~ m{^ (\w+) '=' (.*) $}) or My::Except[0m‚ê§    expecting any of:‚Ä¶¬ª
[14:16] <dakkar> and a match is always true? even when it does not match?
[14:16] <xfix> r: my ($key,$value) = @("abcd" ~~ m{^ (\w+) '=' (.*) $}) or My::Exception.new.throw
[14:16] <+camelia> rakudo-{parrot,moar} 7ea485: ( no output )
[14:16] <xfix> r: my ($key,$value) = @("abcd" ~~ m{^ (\w+) '=' (.*) $}); print ($key, $value).perl;
[14:16] <psch> m: say Nil or "foo"
[14:16] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´(Bool::False, Any)¬ª
[14:16] <+camelia> rakudo-moar 7ea485: OUTPUT¬´Nil‚ê§¬ª
[14:16] <psch> m: say so Nil
[14:16] <+camelia> rakudo-moar 7ea485: OUTPUT¬´False‚ê§¬ª
[14:16] <xfix> r: print (my ($key,$value) = @("abcd" ~~ m{^ (\w+) '=' (.*) $})).say;
[14:16] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´False (Any)‚ê§True¬ª
[14:17] <xfix> r: print (my ($key,$value) = @("abcd" ~~ m{^ (\w+) '=' (.*) $})).perl.say;
[14:17] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´(Bool::False, Any)‚ê§True¬ª
[14:17] *** kjs_ joined
[14:17] <xfix> r: print (so(my ($key,$value) = @("abcd" ~~ m{^ (\w+) '=' (.*) $}))).perl.say;
[14:17] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´Bool::True‚ê§True¬ª
[14:17] <xfix> Ok, so my ($key, $value) converts False into (False, Any).
[14:17] <xfix> (False, Any) is True.
[14:17] <xfix> Hm...
[14:17] <dakkar> oh ffs
[14:17] <xfix> r: (my ($key,$value) = Nil).perl.say;
[14:17] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´(Any, Any)‚ê§¬ª
[14:18] <xfix> It's silly...
[14:18] <dakkar> a non-matching match in list context is not very false, then :/
[14:18] <xfix> r: (so (my ($key,$value) = Nil)).perl.say;
[14:18] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´Bool::True‚ê§¬ª
[14:19] <xfix> Ok, why Nil is true?
[14:19] <xfix> n: (so (my ($key,$value) = Nil)).perl.say;
[14:19] <+camelia> niecza v24-109-g48a8de3: OUTPUT¬´Potential difficulties:‚ê§  $key is declared but not used at /tmp/LOJbZOAt7O line 1:‚ê§------> [32m(so (my [33m‚èè[31m($key,$value) = Nil)).perl.say;[0m‚ê§  $value is declared but not used at /tmp/LOJbZOAt7O line 1:‚ê§------> [32m(so (my [33m‚èè‚Ä¶¬ª
[14:19] <psch> dakkar: just un-terse it, ¬´if $string ~~ m/pat/ { ($key, $value) = $0, $1 }¬ª
[14:19] <xfix> Right...
[14:19] <xfix> n: (so (my ($key,$value) = Nil)).perl.say; say "$key $value"
[14:19] <+camelia> niecza v24-109-g48a8de3: OUTPUT¬´Bool::True‚ê§Use of uninitialized value in string context‚ê§  at /home/camelia/niecza/lib/CORE.setting line 1389 (warn @ 5) ‚ê§  at /home/camelia/niecza/lib/CORE.setting line 269 (Mu.Str @ 15) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /tmp/RS‚Ä¶¬ª
[14:19] <xfix> n: (so (my ($key,$value) = Nil)).perl.say; if False { say $key + $value }
[14:19] <+camelia> niecza v24-109-g48a8de3: OUTPUT¬´Bool::True‚ê§¬ª
[14:19] <dakkar> psch:  I thought this was Perl :)
[14:19] <xfix> pugs: (so (my ($key,$value) = Nil)).perl.say; if False { say $key + $value }
[14:19] <+camelia> pugs: OUTPUT¬´sh: /home/camelia/.cabal/bin/pugs: No such file or directory‚ê§¬ª
[14:19] * dakkar writes it the verbose way
[14:20] <xfix> xfix@papaya ~> perl -E 'if (my ($key, $value) = undef) {say "abc"}'
[14:20] <xfix> abc
[14:20] <xfix> xfix@papaya ~> perl -E 'if (my ($key, $value) = ()) {say "abc"}'
[14:20] <xfix> nothing
[14:20] <xfix> Okay, why Nil doesn't work the way it should?
[14:20] <psch> xfix: which way should it work?
[14:20] <psch> and () is not Nil
[14:20] <psch> and a list is never Nil
[14:21] <xfix> It's Perl 5 in this case.
[14:21] <psch> oh, right
[14:21] <psch> missed that, sorry
[14:21] <xfix> Nil is absense of value.
[14:22] <xfix> While () in Perl 5 is undef in scalar context, and empty list in list context.
[14:22] <xfix> r: (so (my ($key,$value) = ())).perl.say;
[14:22] <+camelia> rakudo-{parrot,moar} 7ea485: OUTPUT¬´Bool::True‚ê§¬ª
[14:22] <xfix> Come on...
[14:22] <xfix> It shouldn't behave this way (I think).
[14:22] <psch> m: my $x, $y = (); $x.perl.say; $y.perl.say
[14:22] <+camelia> rakudo-moar 7ea485: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/SJ7_funVze‚ê§Variable '$y' is not declared‚ê§at /tmp/SJ7_funVze:1‚ê§------> [32mmy $x, $y[33m‚èè[31m = (); $x.perl.say; $y.perl.say[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª
[14:23] <psch> m: my ($x, $y) = (); $x.perl.say; $y.perl.say
[14:23] <+camelia> rakudo-moar 7ea485: OUTPUT¬´Any‚ê§Any‚ê§¬ª
[14:23] <xfix> I know it's Any.
[14:23] <psch> m: my ($x, $y) = (); ($x, $y).perl.say
[14:23] <+camelia> rakudo-moar 7ea485: OUTPUT¬´(Any, Any)‚ê§¬ª
[14:23] <xfix> my ($x, $y) = () changes into (Any, Any).
[14:23] <psch> and why should that be False?
[14:23] <xfix> Which is IMO wrong.
[14:24] <xfix> psch, because this behavior makes if ($a, $b) = something() { } broken.
[14:24] <xfix> Even if it's intended behavior, it's wrong.
[14:24] *** aborazmeh left
[14:24] *** pecastro left
[14:25] <isBEKaml> m: (so (Nil, Nil)).perl.say
[14:25] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´Bool::True‚ê§¬ª
[14:25] <psch> m: sub foo { Nil, Nil }; my ($a, $b); if ($a, $b) = foo { say "here" }
[14:25] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Function foo needs parens to avoid gobbling block‚ê§at /tmp/HMzLgXvngZ:1‚ê§------> [32ma, $b); if ($a, $b) = foo { say "here" }[33m‚èè[31m<EOL>[0m‚ê§Missing block (apparently taken by 'foo')‚ê§at /tmp/HMzLgXvngZ:1‚ê§---‚Ä¶¬ª
[14:25] <psch> m: sub foo { Nil, Nil }; my ($a, $b); if ($a, $b) = foo() { say "here" }
[14:25] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´here‚ê§¬ª
[14:25] <psch> m: sub foo { () }; my ($a, $b); if ($a, $b) = foo() { say "here" }
[14:25] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´here‚ê§¬ª
[14:25] <psch> i don't know, i wouldn't use if that way ever
[14:26] <psch> because the assignment clearly worked
[14:26] <isBEKaml> xfix: why would that be wrong? Even if it's (Nil, Nil), it's still a populated tuple - it'll return Bool::True
[14:26] <xfix> I'm not saying that (Any, Any) shouldn't be True.
[14:26] <psch> m: sub foo { () }; my ($a, $b); if foo() -> $a, $b { say "here" }
[14:26] <+camelia> rakudo-moar c5e7a7: ( no output )
[14:26] <psch> xfix: that's what you want i think?
[14:26] <xfix> The thing is, my ($x, $y) = () returns (Any, Any), not () or something.
[14:26] <psch> m: sub foo { Nil, Nil }; my ($a, $b); if foo() -> $a, $b { say "here" }
[14:26] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´Too few positionals passed; expected 2 arguments but got 1‚ê§  in block <unit> at /tmp/EtRzCVIq9w:1‚ê§‚ê§¬ª
[14:26] <xfix> Is it specified what = operator returns?
[14:27] <dakkar> let's put it this way: ¬´($a) = @('a' ~~ /b/)¬ª is False, ¬´($a,$b) = @('a' ~~ /b/)¬ª is True
[14:27] <dakkar> that is, at the very least, surprising
[14:27] <dakkar> (especially coming from Perl 5)
[14:27] *** woolfy left
[14:28] <psch> not to me, tbh.  consider ¬´if(x = 5) { }¬ª in e.g. C
[14:28] <psch> i mean, i can see the confusion
[14:28] * dakkar fails to see the parallels
[14:28] <xfix> It behaves differently to Perl 5, for example.
[14:28] <isBEKaml> p: my ($x, $y) = 1,2,3; say $x, " --" , $y;
[14:28] <+camelia> rakudo-parrot c5e7a7: OUTPUT¬´1 --2‚ê§¬ª
[14:28] <psch> yeah, let me clarify
[14:29] <psch> i understand why the behavior seems weird and inconsistent, but i've filed it as "don't do that", which means i'm probably not arguing from the idioms merits, but from prejudice...
[14:29] <xfix> In Ruby: a, b = [] returns []. In Perl 5, ($a, $b) = () returns ().
[14:29] <psch> so i'll better keep out of it
[14:30] <dakkar> oh well :)
[14:30] <xfix> The behavior of returning (Any, Any) is wrong in my opinion.
[14:30] <xfix> Sure, this is what is the value of ($a, $b), but it doesn't appear to be useful in my opinion.
[14:31] <xfix> of ($a, $b) is*
[14:31] <dakkar> anyway, I'm porting from JS to P6 via P5, so my idoms are getting *very* confused :)
[14:32] <isBEKaml> m: ().length.say;
[14:32] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´No such method 'length' for invocant of type 'Parcel'‚ê§Did you mean 'elems', 'chars', 'graphs' or 'codes'?‚ê§  in block <unit> at /tmp/5lIJbE4SN3:1‚ê§‚ê§¬ª
[14:32] <huf> perl5 doesnt *quite* appear to do that :)
[14:32] <isBEKaml> m: ().size.say;
[14:32] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´No such method 'size' for invocant of type 'Parcel'‚ê§  in block <unit> at /tmp/xbTttPqpCZ:1‚ê§‚ê§¬ª
[14:32] <isBEKaml> m: ().elems.say;
[14:32] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´0‚ê§¬ª
[14:32] <isBEKaml> m: my @foo = (); my ($x, $y) = @foo; ($x, $y).perl.say;
[14:32] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(Any, Any)‚ê§¬ª
[14:33] <huf> it looks like the result is the left side in list context and the count of the right side in scalar :)
[14:33] <psch> m: $_ = "a b"; my  ($key, $value) = @(m{^ (\w+) '=' (.*) $}) and $key // $value // die "foo"; say $key, $value # if it has to be terse dakkar :P
[14:33] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´foo‚ê§  in block <unit> at /tmp/4budWaQJZJ:1‚ê§‚ê§¬ª
[14:33] <dakkar> eeeewweeww
[14:33] <isBEKaml> ISTR a discussion around assignment and the comma operator. But I can't recall any specifics there. Anyone?
[14:33] <dakkar> :)
[14:34] <masak> isBEKaml: S03 has a bit about assignment and the comma operator.
[14:34] *** rurban left
[14:34] <isBEKaml> masak: is that where this behaviour is coming from?
[14:35] <xfix> I cannot find anything about return value of ($a, $b) = c anywhere in S03.
[14:35] <masak> what behavior. I haven't backlogged anything.
[14:35] <xfix> ($a, $b) = ()
[14:35] <xfix> What is the return value of that. In my opinion, it should be (), but in Rakudo it's (Any, Any).
[14:35] <masak> there's basically listy assignment and item assignment.
[14:35] <isBEKaml> masak: my ($x, $y) = ();  assings (Any, Any) to those 2
[14:36] <xfix> Yes, ($a, $b) after ($a, $b) = () is without doubt (Any, Any). But what about result of list assignment?
[14:36] <masak> m: my ($x, $y) = (); BEGIN { $x = 5 }; say $x
[14:36] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(Any)‚ê§¬ª
[14:36] <masak> hm, so it does.
[14:36] <xfix> m: say my ($x, $y) = ()
[14:36] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(Any) (Any)‚ê§¬ª
[14:36] <xfix> m: say (my ($x, $y) = ()).perl
[14:36] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(Any, Any)‚ê§¬ª
[14:36] <xfix> m: say (my Int ($x, $y) = ()).perl
[14:36] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(Int, Int)‚ê§¬ª
[14:36] <masak> I think that makes sense, though. the list () ran out of elements, so the rest get Any.
[14:37] <xfix> My reasoning is that the current behavior breaks behavior of if (my ($a, $b) = something) { }
[14:37] <xfix> Which is a perfectly fine Perl 5 idiom.
[14:38] <xfix> In Perl 5, you can write code like:
[14:38] <xfix> if (my ($a, $b) = "ab" =~ /(\w) (\w)/) { say "$a $b" } else { say "Nothing found" }
[14:39] <xfix> Any suggestion how to write this in Perl 6?
[14:40] <+dalek> infrastructure-doc: 6365994 | raiph++ | hosts/hack.p6c.org.pod:
[14:40] <+dalek> infrastructure-doc: Typos
[14:40] <+dalek> infrastructure-doc: review: https://github.com/perl6/infrastructure-doc/commit/6365994a6d
[14:40] <psch> m: if "ab" ~~ /$<a>="a" $<b>="b"/ { say "$<a> $<b>" } else { say "nothing found" } # this is how i would write that case in perl6
[14:40] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´a b‚ê§¬ª
[14:41] <xfix> I guess that's a possiblity..
[14:41] <huf> that doesnt generalize well to non-regex stuff...
[14:41] <psch> yes, i know
[14:41] <psch> general case is unpack syntax, which i keep forgetting
[14:42] *** raiph joined
[14:43] <psch> m: sub something { 1,2,3 }; if something() -> @a [$a, $b, *@c] { say "have $a, $b and @c" }
[14:43] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´have 1, 2 and @c‚ê§¬ª
[14:43] <psch> m: sub something { 1,2,3 }; if something() -> @a [$a, $b, *@c] { say "have $a, $b and @c[]" }
[14:43] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´have 1, 2 and 3‚ê§¬ª
[14:43] <psch> that's the general case
[14:43] <+dalek> doc: 2c39a3b | moritz++ | lib/Type/IO.pod:
[14:43] <+dalek> doc: mkdir: link to exception
[14:43] <+dalek> doc: review: https://github.com/perl6/doc/commit/2c39a3b094
[14:43] <xfix> Hm, looks fine.
[14:43] <psch> @a could've been anon
[14:44] <psch> i.e. just @
[14:44] <xfix>  sub something { 1,2,3 }; if something() -> $a, $b, $c { say "have $a, $b and $c" }
[14:44] <psch> it even generalizes to objects
[14:44] <dakkar> oh, I like that one
[14:44] <xfix> r: sub something { 1,2,3 }; if something() -> $a, $b, $c { say "have $a, $b and $c" }
[14:44] <+camelia> rakudo-parrot c5e7a7: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 3‚ê§  in block <unit> at /tmp/tmpfile:1‚ê§‚ê§¬ª
[14:44] <+camelia> ..rakudo-moar c5e7a7: OUTPUT¬´Too few positionals passed; expected 3 arguments but got 1‚ê§  in block <unit> at /tmp/tmpfile:1‚ê§‚ê§¬ª
[14:44] <xfix> r: sub something { 1,2,3 }; if something() -> @[$a, $b, $c] { say "have $a, $b and $c" }
[14:44] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´have 1, 2 and 3‚ê§¬ª
[14:44] <xfix> Neat.
[14:45] <psch> m: sub foo { a => 1 }; if foo() -> :$key, :$value { say "key $key has value $value " }
[14:45] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´use of uninitialized value $key of type Mu in string context  in block <unit> at /tmp/LSgfk2inbt:1‚ê§‚ê§use of uninitialized value $value of type Mu in string context  in block <unit> at /tmp/LSgfk2inbt:1‚ê§‚ê§key  has value  ‚ê§¬ª
[14:45] * dakkar disappears for a bit
[14:45] <psch> err, somewhat like that... :/
[14:45] <psch> m: sub foo { a => 1 }; if foo() -> :(:$key, :$value) { say "key $key has value $value " }
[14:45] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´use of uninitialized value $key of type Mu in string context  in block <unit> at /tmp/wRMUFpAyfq:1‚ê§‚ê§use of uninitialized value $value of type Mu in string context  in block <unit> at /tmp/wRMUFpAyfq:1‚ê§‚ê§key  has value  ‚ê§¬ª
[14:45] <psch> m: sub foo { a => 1 }; if foo() -> :($key, $value) { say "key $key has value $value " }
[14:45] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´Too few positionals passed; expected 2 arguments but got 0 in sub-signature‚ê§  in block <unit> at /tmp/dhtQqok7U2:1‚ê§‚ê§¬ª
[14:45] <psch> i don't remember :)
[14:46] <psch> m: sub foo { a => 1 }; if foo() -> $(:$key, :$value) { say "key $key has value $value " } # moritz++ for 5-to-6
[14:46] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´key a has value 1 ‚ê§¬ª
[14:46] <vendethiel-> is it possible to commit in a "%" ?
[14:46] <vendethiel-> like, if I matched it one time, never try to backtrack this segment?
[14:46] <isBEKaml> m: sub foo { (a => 1) }; if foo() -> :$key, :$val { say "key : $key, val: $val" }
[14:46] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´use of uninitialized value $key of type Mu in string context  in block <unit> at /tmp/438K38R3tZ:1‚ê§‚ê§use of uninitialized value $val of type Mu in string context  in block <unit> at /tmp/438K38R3tZ:1‚ê§‚ê§key : , val: ‚ê§¬ª
[14:46] <isBEKaml> m: sub foo { (a => 1) }; if foo() -> $key, $val { say "key : $key, val: $val" }
[14:46] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´Too few positionals passed; expected 2 arguments but got 1‚ê§  in block <unit> at /tmp/WhtVRBW6Xp:1‚ê§‚ê§¬ª
[14:46] <psch> vendethiel-: insert a sequence point in the quantified bit?
[14:47] <psch> vendethiel-: not sure if that does what you mean yet, but i think it should
[14:47] <vendethiel-> psch: just [ 'x' :: ] % ',' ?
[14:47] <psch> vendethiel-: i don't know if :: is implemented yet, i'd have tried {}
[14:47] <vendethiel-> oke
[14:48] <isBEKaml> psch: oh, $(PAIR) :-)
[14:49] *** dakkar left
[14:50] * isBEKaml -> out
[14:50] *** isBEKaml left
[14:50] <vendethiel-> can you load a file in the REPL?
[14:51] <vendethiel-> and have its state available
[15:04] *** kjs_ left
[15:09] <timotimo> o/ chaos communication congress
[15:09] *** bjz_ joined
[15:10] *** bjz left
[15:13] <psch> o/ timotimo
[15:16] *** jack_rabbit joined
[15:16] <psch> vendethiel-: i don't think the REPL is up to that currently.  EVAL would allow you to specify the context to put the EVAL'd stuff into, but i think the way the REPL is implemented doesn't fully honor all the package things it should
[15:17] <vendethiel-> yeah
[15:17] <psch> vendethiel-: i am thinking we'd want something like &drop-to-REPL or similar in module-space eventually, maybe even in the SETTING, but that'd need a better REPL
[15:17] <vendethiel-> right-o
[15:19] *** Theo_ left
[15:20] <colomon> hurm, how to determine the common prefix of two strings?
[15:20] <colomon> or N strings, but if I can do the first I can do the latter
[15:21] *** rurban joined
[15:22] <colomon> m: my $a = "hello"; my $b = "hel"; say ($a.comb Z $b.comb).perl
[15:22] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(("h", "h"), ("e", "e"), ("l", "l")).list‚ê§¬ª
[15:22] <colomon> m: my $a = "hello"; my $b = "help"; say ($a.comb Z $b.comb).perl
[15:22] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(("h", "h"), ("e", "e"), ("l", "l"), ("l", "p")).list‚ê§¬ª
[15:23] <colomon> m: my $a = "hello"; my $b = "help"; say ($a.comb Z=> $b.comb) ‚Ä¶ { $_.key ne $_.value }
[15:23] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/MNiJhEWlk_‚ê§Two terms in a row‚ê§at /tmp/MNiJhEWlk_:1‚ê§------> [32m $b = "help"; say ($a.comb Z=> $b.comb) [33m‚èè[31m‚Ä¶ { $_.key ne $_.value }[0m‚ê§    expecting any of:‚ê§        infix stop‚Ä¶¬ª
[15:23] *** skids left
[15:23] <colomon> stupid IRC clinet
[15:25] <psch> colomon: i think you want ...^ 
[15:25] <colomon> psch: yes
[15:25] <colomon> I've got it working locally now. 
[15:25] <colomon> kind of hope there is a better solution.  :)
[15:25] <colomon> my $a = "hello"; my $b = "kelp"; say (($a.comb Z=> $b.comb) ...^ { $_.key ne $_.value 
[15:25] <colomon> argh
[15:26] <colomon> my $a = "hello"; my $b = "kelp"; say (($a.comb Z=> $b.comb) ...^ { $_.key ne $_.value }).map(*.key).join
[15:26] *** mvuets joined
[15:29] *** skids joined
[15:34] *** vendethiel- left
[15:45] <a3gis> hey! another question: is it possible to load a file directly into the perl6 repl? just like ghci "ghci hello.hs"
[15:46] *** kjs_ joined
[15:47] <xfix> a3gis, eval slurp "file"
[15:47] <timotimo> we spell it EVAL now
[15:48] <xfix> EVAL slurp "file"
[15:48] <xfix> Oh right.
[15:48] * masak grumbles
[15:49] <xfix> (I don't understand why Perl in 5.16 introduced evalbytes function)
[15:52] <xfix> r: sub match { 'a' ~~ /(a)/ }; if 'b' ~~ /(b)/ { match; $/.perl.say }
[15:52] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´Match.new(orig => "b", from => 0, to => 1, ast => Any, list => (Match.new(orig => "b", from => 0, to => 1, ast => Any, list => ().list, hash => EnumMap.new()),).list, hash => EnumMap.new())‚ê§¬ª
[15:52] <xfix> pl
[15:52] <xfix> ok*
[15:52] <xfix> r: sub match { 'a' ~~ /(a)/; say $/ }; if 'b' ~~ /(b)/ { match; say $/ }
[15:52] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´ÔΩ¢aÔΩ£‚ê§ 0 => ÔΩ¢aÔΩ£‚ê§‚ê§ÔΩ¢bÔΩ£‚ê§ 0 => ÔΩ¢bÔΩ£‚ê§‚ê§¬ª
[15:54] <skids> r: sub g( --> Nil) { 42; return; } sub f( -->Nil ) { 42 }; g().say; f().say;
[15:54] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Two terms in a row‚ê§at /tmp/tmpfile:1‚ê§------> [32msub g( --> Nil) { 42; return; } [33m‚èè[31msub f( -->Nil ) { 42 }; g().say; f().say[0m‚ê§    expecting any of:‚ê§        i‚Ä¶¬ª
[15:55] <skids> r: sub g( --> Nil) { 42; return; }; sub f( -->Nil ) { 42 }; g().say; f().say;
[15:55] <+camelia> rakudo-parrot c5e7a7: OUTPUT¬´Nil‚ê§Type check failed for return value; expected 'Any' but got 'Int'‚ê§  in block <unit> at /tmp/tmpfile:1‚ê§‚ê§¬ª
[15:55] <+camelia> ..rakudo-moar c5e7a7: OUTPUT¬´Nil‚ê§Type check failed for return value; expected 'Any' but got 'Int'‚ê§  in any return_error at src/vm/moar/Perl6/Ops.nqp:649‚ê§  in block <unit> at /tmp/tmpfile:1‚ê§‚ê§¬ª
[15:56] <skids> Second one should return Nil as well.
[15:58] <xfix> r: sub a() returns False { False }; a # don't do this
[15:58] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Cannot call 'trait_mod:<returns>'; none of these signatures match:‚ê§:(Routine:D $target, Mu:U $type)‚ê§at /tmp/tmpfile:1‚ê§------> ‚ê§¬ª
[16:00] <skids> r: sub a( --> 42) { return }; a().say; # spec says "If the return specification is a definite immutable value" so this should work too.
[16:00] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Missing block‚ê§at /tmp/tmpfile:1‚ê§------> [32msub a( --> [33m‚èè[31m42) { return }; a().say; # spec says "If[0m‚ê§¬ª
[16:03] <skids> Anyway, as of the star release (and a few finagles) the Sum:: module now seems to work mostly on r-m now, and r-j is looking much better than last time I tried.  Also, I added Tiger support.
[16:05] <skids> Hope to play with the new POD features now, anchoring the docs to constructs.
[16:07] <a3gis> xfix: but as a command? I'm trying to bind a shortcut to it in vim to load the current buffer
[16:07] <xfix> a3gis, nope.
[16:08] <a3gis> alright, thanks :)
[16:08] <xfix> There is also -M option, but that can be only used outside of REPL. (perl -MSome::Module to load REPL with Some::Module preloaded)
[16:11] *** mr-foobar joined
[16:13] <a3gis> xfix: actually I can just create a script calling EVAL slurp file and get what I want
[16:16] <TimToady> very backlog, so muchness
[16:20] *** BenGoldberg joined
[16:20] *** jack_rabbit left
[16:50] <TimToady> m: say uint
[16:50] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(uint)‚ê§¬ª
[16:50] * TimToady points out that, while P6 already has a uint type, there's no guarantee that it's the same size that C thinks it is
[16:51] <TimToady> it's very likely to correspond to C's unsigned long (long) type
[16:52] <xfix> m: say uint32
[16:52] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(uint32)‚ê§¬ª
[16:52] <xfix> m: my uint32 $x = 2
[16:52] <+camelia> rakudo-moar c5e7a7: ( no output )
[16:52] <xfix> m: my uint32 $x = 2; say $x
[16:52] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´2‚ê§¬ª
[16:52] <xfix> Hm, okay.
[16:52] <TimToady> because Perl 6 defines 'int' to mean the longest integer that runs at full speed
[16:52] <TimToady> so if we interface to C, we need some explicit Cint and Cuint types, likely
[16:53] <TimToady> or however we decide to spell 'em
[16:53] <TimToady> those spellings are perhaps a bit too prone to freudian slips...
[16:54] <TimToady> could go with _int and _uint I suppose
[16:54] <xfix> NativeCall::long
[16:55] <TimToady> if yer gonna make it that long, you should add a few more on the front :)
[16:57] <TimToady> _int _unsigned_int _long_long  would be fine by me
[16:59] <TimToady> but yeah, a :: form would be more extensible to typedefs, I suppose
[17:00] <jnthn> Yes, I've pondered before that NativeCall should export some sized types matching the local system's idea of sizes.
[17:00] <+yoleaux> 22 Dec 2014 22:16Z <lizmat> jnthn: I'm thinking about prefixing "on-" to all Tap attributes so that you get a better message when e.g. trying to emit on a tap
[17:00] <+yoleaux> 22 Dec 2014 22:18Z <lizmat> jnthn: manufactured case: m: Supply.new.tap.emit(42) # should complain about not having an emit method
[17:00] <+yoleaux> 22 Dec 2014 22:24Z <lizmat> jnthn: http://www.engadget.com/2014/12/22/the-problem-solver-beer-creativity/   # served / available in Copenhagen :-)
[17:01] *** virtualsue left
[17:01] * TimToady wonders if there's any systems out there where gcc and clang disagree on type sizes
[17:01] <TimToady> or any other 'native' C compiler, for that mattter
[17:02] <xfix> I doubt it, considering that such incompatibility would mean that code linked with clang couldn't link to code linked to gcc and back.
[17:02] <TimToady> ss/any systems/any systems we care about/
[17:03] <jnthn> .tell lizmat maybe the problem is that Tap exposes those methods...
[17:03] <+yoleaux> jnthn: I'll pass your message to lizmat.
[17:03] <xfix> The compilers disagree on stuff like vtables and name mangling in C++, but with C, as long there is one platform involved, the compilers are compatible (I think so, at least).
[17:03] <TimToady> jnthn: o/ btw
[17:04] <xfix> The compilers have to be compatible. Would you use a compiler that cannot link to system libraries because the compiler thinks that int is 40-bit, rather than 32-bit.
[17:05] <geekosaur> the compilers agree on those things with c++11, iirc
[17:05] <xfix> There are different calling conventions. For example, on Windows there is alternate __fastcall calling convention on x86 for historical reasons. However, those alternate calling conventions are marked in header files.
[17:05] <geekosaur> c++ standards folks finally figured out that incompatibility was hurting them
[17:06] <jnthn> TimToady: o/
[17:07] * jnthn is doign the train trip between two bits of family, and figured he'd drop by :)
[17:07] <jnthn> *doing
[17:07] <xfix> geekosaur, even then, there are compilers before C++11 fixed stuff.
[17:07] <jnthn> Turns out, UK trains run late too, just like their Swedish friends. :)
[17:08] <geekosaur> xfix: I know only too well...
[17:20] <jnthn> .tell lizmat +1 to Supply.for getting renamed; not entirely sure about from-list but I dont have a better idea. .for *should* exist on an instance of Supply and do .flat.map just as on a List.
[17:20] <+yoleaux> jnthn: I'll pass your message to lizmat.
[17:20] <jnthn> It's kinda funny how List's semantics on various methods is converging on how I implemented them in Supply (that is, don't flatten unless requested). :)
[17:21] <jnthn> .tell lizmat to be clear, I mean .flat and .map in Supply-land, that is, it's still push semantics.
[17:21] <+yoleaux> jnthn: I'll pass your message to lizmat.
[17:23] *** rurban left
[17:25] <moritz> \o jnthn 
[17:27] <jnthn> hi moritz 
[17:27] *** jamadam joined
[17:28] *** raiph left
[17:31] *** jamadam left
[17:37] *** broquain1 joined
[17:37] *** Sir_Ragnarok left
[17:37] *** Sir_Ragnarok joined
[17:37] *** broquaint left
[17:37] *** raiph joined
[17:38] *** colomon left
[17:39] *** colomon joined
[17:41] *** jack_rabbit joined
[17:42] <+dalek> specs: 9b2b9cb | moritz++ | S17-concurrency.pod:
[17:42] <+dalek> specs: S17: supplies are .done(), not .close()d
[17:42] <+dalek> specs: review: https://github.com/perl6/specs/commit/9b2b9cbe60
[17:42] <synopsebot> Link: http://perlcabal.org/syn/S17.html#supplies_are
[17:45] *** Ben_Goldberg joined
[17:47] *** BenGoldberg left
[17:48] *** BenGoldberg joined
[17:50] <moritz> is Blob supposed to be immutable?
[17:50] *** Ben_Goldberg left
[17:51] <jnthn> Yes
[17:51] <moritz> it seems we have a method assign_pos in Blob, which IMHO should go into Buf instead
[17:51] <TimToady> psch: note that {} does not commit, it merely terminates LTM
[17:51] <jnthn> Corect.
[17:51] <jnthn> Not sure how it ended up in Blob...
[17:52] <TimToady> used by the constructor maybe?
[17:52] <moritz> TimToady: no, that uses nqp::bindpos_i
[17:52] <jnthn> Would hope not, that'd be suboptimal...
[17:53] <TimToady> my $blob = Blob.new: 1,2,3; $blob[1] = 42; say $blob
[17:53] <TimToady> m: my $blob = Blob.new: 1,2,3; $blob[1] = 42; say $blob
[17:53] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´Buf:0x<01 2a 03>‚ê§¬ª
[17:53] <TimToady> not very immutable...
[17:53] <xfix> r: r: sub term:<int main(void) { puts("Hello, world!"); return 0; }> { say "Hello, world!" }; int main(void) { puts("Hello, world!"); return 0; }
[17:53] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´Hello, world!‚ê§¬ª
[17:53] <xfix> Neat.
[17:53] <TimToady> and sez its a Buf, not a Blob
[17:53] *** telex left
[17:54] <jnthn> m: my $blob = Blob.new: 1,2,3; $blob[1] = 42; say $blob.WHAT
[17:54] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´(Blob)‚ê§¬ª
[17:54] <jnthn> Well, then it's the .gist that's lying, it seems.
[17:54] *** telex joined
[17:54] <moritz> somebody just moved method gist from Buf to Blob without updating it
[17:54] <jnthn> So that'd want a fix too...
[17:54] * moritz works on it
[17:54] <jnthn> moritz++
[17:55] <b2gills> m: sub foo { (a => 1) }; if foo() -> $[:$key, :$value] { say "key : $key, value : $value" } # isBEKaml: Is this what you were trying to write?
[17:55] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´key : a, value : 1‚ê§¬ª
[17:55] <+dalek> rakudo/nom: 421176c | moritz++ | src/core/io_operators.pm:
[17:55] <+dalek> rakudo/nom: remove unused code for deprecating cwd()
[17:55] <+dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/421176c146
[17:57] <jnthn> -> (:$key, :$value) { ... should probably do as well.
[17:57] *** a3gis left
[17:58] <TimToady> in fact, sigil followed by [] is reserved for shapes
[17:58] <xfix> How to make case insensitive grammar in Perl 6 without saying :i everywhere?
[17:59] <jnthn> I'd just .fc the input :P
[18:00] <jnthn> I'm not aware of any convenient way to make :i the default.
[18:00] <jnthn> And doing a transform on the initial string will be cheaper than checking the alternation everywhere, I suspect.
[18:00] <TimToady> however, note that rakudo is rather weak on .fc, and does :i by comparing to .lc and .uc, ignoring .tc, currently
[18:01] <xfix> If I do 'rule select { :i select <expressions> <from>? <where>? }', does from get case insensitive?
[18:01] <jnthn> No.
[18:01] <xfix> ok
[18:01] <jnthn> It works lexically.
[18:01] <TimToady> one could conceivably have a pragma that word work over an entire grammar
[18:02] *** raiph left
[18:02] <jnthn> TimToady: I thought we got .fc mostly correct? What's missing, ooc?
[18:02] <jnthn> But yes, the :i is dubious.
[18:02] <xfix> Well, I still want to match strings while preserving case. For example, SELECT 'abc';.
[18:02] <xfix> Or SELECT 'ABC';
[18:02] <xfix> They select different strings.
[18:03] <psch> TimToady: commiting is with :: then, as vendethiel- suspected?
[18:03] <TimToady> m: say fc("AbC")
[18:03] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/83IjlkErFD‚ê§Undeclared routine:‚ê§    fc used at line 1. Did you mean 'lc', 'uc', 'tc'?‚ê§‚ê§¬ª
[18:03] <TimToady> yes, and NYI
[18:04] <jnthn> m: say "AbC".fc
[18:04] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´No such method 'fc' for invocant of type 'Str'‚ê§  in block <unit> at /tmp/Syg37KBGO9:1‚ê§‚ê§¬ª
[18:04] <jnthn> Bah
[18:04] <TimToady> that seems 'rather weak' to me... :P
[18:05] <jnthn> I guess it's Moar where I remember wroking on it... :P
[18:07] <TimToady> the word fc doesn't occur inside nqp or Moarvm except in association with file channels or fcntl
[18:08] <+dalek> roast: 7c3299d | peschwa++ | integration/advent2014-day13.t:
[18:08] <+dalek> roast: Insert a missing ^I.
[18:08] <+dalek> roast: review: https://github.com/perl6/roast/commit/7c3299df71
[18:08] <jnthn> :/
[18:08] <jnthn> Then hell knows what I remember. Maybe it was nothing more than "we have the data in the unicode DB"
[18:09] <moritz> you might remember tc and tclc
[18:09] <jnthn> No, those are different...
[18:09] <+dalek> rakudo/nom: 449ea38 | moritz++ | src/core/Buf.pm:
[18:09] <+dalek> rakudo/nom: move assign_pos from Blob to Buf
[18:09] <+dalek> rakudo/nom: 
[18:09] <+dalek> rakudo/nom: Blob is supposed to be immutable
[18:09] <+dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/449ea383d6
[18:09] <+dalek> rakudo/nom: d771fa4 | moritz++ | src/core/Buf.pm:
[18:09] <+dalek> rakudo/nom: Fix Blob.gist
[18:09] <+dalek> rakudo/nom: 
[18:09] <+dalek> rakudo/nom: it used to always return "Buf:...", now returns the type name in front
[18:09] <+dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d771fa4f42
[18:10] <psch> ugh
[18:10] <psch> StackOverflowError in test #10 in man-or-boy.t :/
[18:12] <xfix> r: Perl.new.say
[18:12] <+camelia> rakudo-{parrot,moar} c5e7a7: OUTPUT¬´Perl 6‚ê§¬ª
[18:12] <xfix> What is Perl?
[18:13] <TimToady> the sound of no longer banging your head against the wall
[18:13] <xfix> Oh, I see, it's used for $*PERL.
[18:14] <moritz> m: say $*PERL.VMnames
[18:14] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´moar jvm parrot‚ê§¬ª
[18:14] *** avuserow left
[18:14] <xfix> m: say $*PERL.DISTROnames
[18:14] <+camelia> rakudo-moar c5e7a7: OUTPUT¬´macosx linux freebsd mswin32 openbsd netbsd‚ê§¬ª
[18:14] <xfix> Hm... clearly Rakudo Star is not a Perl distro.
[18:14] *** avuserow joined
[18:15] * TimToady has not idea what those lists are supposed to be for, other than perhaps an impediment to extensibility
[18:15] <TimToady> *no
[18:17] <xfix> Hm, if $*PERL.VMnames shortens MoarVM to moar, then what about shortening JVM to j.
[18:18] <moritz> sounds like a stupid idea.
[18:18] <jnthn> Traveling by train in Britain was also a stupid idea. :/
[18:19] <moritz> jnthn: my impression was that the coach network is better than the train network in GB
[18:20] <jnthn> Depends on the traffic, I guess. :)
[18:20] <jnthn> At least the train has wifi.
[18:20] <jnthn> And at least the place I probably get stuck for over an hour has a pub...
[18:25] <TimToady> you get a free massage on British trains, too
[18:26] <jnthn> Tell me about it...this isn't a smooth ride at all.
[18:30] <moritz> m: Blob[uint32].new(65535).unpack('H')
[18:30] <+camelia> rakudo-moar 421176: ( no output )
[18:31] <moritz> m: say  Blob[uint32].new(65535).unpack('H')
[18:31] <+camelia> rakudo-moar 421176: OUTPUT¬´ffff‚ê§¬ª
[18:31] *** ptc_p6 left
[18:31] <moritz> m: say  Blob[uint64].new(65535).unpack('H')
[18:31] <+camelia> rakudo-moar 421176: OUTPUT¬´ffff‚ê§¬ª
[18:31] <jnthn> Ah well, time to get off this one soon... Will probably be about here a bit more during the next week.
[18:31] <jnthn> o/
[18:31] <moritz> \o
[18:32] <moritz> m: say Blob.new(1, 2, 3, 4).unpack('C4')
[18:32] <+camelia> rakudo-moar 421176: OUTPUT¬´1‚ê§¬ª
[18:32] <moritz> bug, I'd say
[18:36] <moritz> it seems that most templates in unpack ignore quantifier
[18:37] *** Ben_Goldberg joined
[18:40] *** BenGoldberg left
[18:41] <moritz> m: say Blob.new(1, 2, 3, 4).unpack('H A')
[18:41] <+camelia> rakudo-moar 421176: OUTPUT¬´01020304 (Any)‚ê§¬ª
[18:46] * moritz suspects that nobody really used unpack yet
[18:47] * TimToady suspects that nobody really implemented unpack yet :)
[18:47] *** jack_rabbit left
[18:52] <moritz> well, somebody started to implement it, and I thought it was "mostly done"
[18:53] <moritz> using strings for unpacking templates feels kinda arcane
[18:54] *** [Sno] left
[18:54] <moritz> also weird: A4 returns a single string, C4 returns 4 ints
[18:54] <moritz> I wonder if C4 should return a List of 4 ints instead
[18:56] <colomon> is it returning a parcel now?
[18:56] <moritz> no, it simply flattens into the return list
[18:56] <colomon> ah
[18:56] <moritz> well, after my patch. Before my patch, C ignored any quantifier
[18:56] <moritz> and H always assumed H*
[18:57] <xfix> I wonder... / ^ <uint32>**4 <int64>**2 $ /
[18:57] <xfix> Looks less cryptic than unpack, at least.
[18:58] <colomon> moritz++
[18:58] <xfix> (but I guess it's possible to have both pack/unpack and this regex thing as a module)
[18:59] *** Ben_Goldberg left
[18:59] <xfix> (oh, right, you cannot run regexes on Buf)
[19:00] *** molaf left
[19:02] <+dalek> rakudo/nom: 3b9ebdd | moritz++ | src/core/Buf.pm:
[19:02] <+dalek> rakudo/nom: Blob.unpack: pay attention to quantifiers
[19:02] <+dalek> rakudo/nom: 
[19:02] <+dalek> rakudo/nom: like, really.
[19:02] <+dalek> rakudo/nom: Before, some directives like A payed attention, C always extracted one,
[19:02] <+dalek> rakudo/nom: and H always used up the rest of the blob
[19:02] <+dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3b9ebdd45a
[19:03] <TimToady> you're supposed to be able to run regexes on a Buf, but it's NYI
[19:03] <TimToady> (with ASCII-only semantics)
[19:04] <xfix> TimToady, by ASCII only, you mean 8-bit, right? So I could do / \xFF /?
[19:04] <TimToady> yes
[19:04] * moritz decides not to follow up on unpack
[19:04] <TimToady> but √ø is illegal for that
[19:04] <moritz> .u √ø
[19:04] <+yoleaux> U+00FF LATIN SMALL LETTER Y WITH DIAERESIS [Ll] (√ø)
[19:05] <moritz> ... and all I wanted to do was document unpack
[19:06] <xfix> It would be neat to have partially binary string. You know it has ASCII, but you don't know much else. For example, you write a bot that parses IRC messages, and uploads them to the database without charset conversion.
[19:06] <xfix> So you see people saying stuff like PRIVMSG #perl6 :some unreadable blob
[19:06] <TimToady> that's the idea of allowing ASCII and binary matching
[19:08] *** a3gis joined
[19:08] <a3gis> hello; what is the recommended way to install librairies like https://github.com/jnthn/grammar-debugger ?
[19:08] <TimToady> 'course, if we have a utf8 type, we can also have a latin1 type, and casting a Buf to latin1 would allow matching √ø
[19:08] <TimToady> but only if someone champions it
[19:08] <moritz> a3gis: use panda, the module installer bundled with Rakudo Star
[19:09] <moritz> (or you can install panda from git too, once you have a rakudo compiled)
[19:09] <a3gis> moritz: I cloned the rakudo repo directly
[19:09] <TimToady> but I think we should get to NFG first, and define a latin1 buf to simply be NFG as represented in buf8
[19:09] <moritz> a3gis: then 'make install', put install/bin into $PATH, clone the panda repo, cd into it, run 'perl6 bootstrap.pl'
[19:12] <xfix> / ^ [ <[\x00..\x7F]> | <[\xC0..\xDF]> <[\x80..\xBF]> | <[\xE0..\xEF]> <[\x80..\xBF]>**2 | <\xF0..\xF7]> <[\x80..\xBF]>**3 ]* $ /
[19:12] <+dalek> std: f9b7f55 | TimToady++ | STD.pm6:
[19:12] <+dalek> std: do not parse sig (@[$x]) as declaring $x
[19:12] <+dalek> std: 
[19:12] <+dalek> std: The shape notation should not be confused with subsig notation, which
[19:12] <+dalek> std: requires space between any formal variable and the brackets.
[19:12] <+dalek> std: review: https://github.com/perl6/std/commit/f9b7f553ab
[19:13] <TimToady> p6: /^ \0 /
[19:13] <+camelia> rakudo-{parrot,moar} 421176: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tmpfile‚ê§Unrecognized backslash sequence: '\0'‚ê§at /tmp/tmpfile:1‚ê§------> [32m/^ \[33m‚èè[31m0 /[0m‚ê§¬ª
[19:14] <TimToady> n: /^ \0 /
[19:14] <+camelia> niecza v24-109-g48a8de3: ( no output )
[19:14] <a3gis> moritz: brilliant; thanks!
[19:14] <TimToady> that's a surprising oversight...
[19:14] <xfix> std: /\0/
[19:14] <+camelia> std 76ccee1: OUTPUT¬´ok 00:00 135m‚ê§¬ª
[19:16] <xfix> https://github.com/rakudo/rakudo/blob/32c6e44a435ded46ccd4d75d2fce119787fe7352/src/Perl6/Grammar.nqp#L4412
[19:16] <xfix> Hm, it's here.
[19:20] *** hekmek left
[19:23] *** woolfy joined
[19:24] * TimToady suspects that nqp is not actually using that definition; one of the spots where the 'not quite' is showing through
[19:25] *** Mso150 joined
[19:25] *** rindolf left
[19:26] <TimToady> n: say "\cIfoo"
[19:26] <+camelia> niecza v24-109-g48a8de3: OUTPUT¬´        foo‚ê§¬ª
[19:26] <TimToady> m: say "\cIfoo"
[19:26] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/4cKth5eCTJ‚ê§'I' is not a valid number‚ê§at /tmp/4cKth5eCTJ:1‚ê§------> [32msay "\cI[33m‚èè[31mfoo"[0m‚ê§¬ª
[19:28] <+dalek> doc: 8697985 | moritz++ | lib/Type/B (2 files):
[19:28] <+dalek> doc: move Buf docs to Blob
[19:28] <+dalek> doc: 
[19:28] <+dalek> doc: that is where those methods live now
[19:28] <+dalek> doc: review: https://github.com/perl6/doc/commit/8697985eb0
[19:28] <+dalek> doc: 634eac7 | moritz++ | lib/Type/Blob.pod:
[19:28] <+dalek> doc: document Blob.unpack (for #10)
[19:28] <+dalek> doc: review: https://github.com/perl6/doc/commit/634eac7615
[19:30] *** rurban joined
[19:35] <+dalek> doc: 385ba9e | moritz++ | lib/Type/Buf.pod:
[19:35] <+dalek> doc: add stub Buf documentation
[19:35] <+dalek> doc: review: https://github.com/perl6/doc/commit/385ba9e705
[19:36] <masak> jnthn: you're not hallucinating .fc -- but it's not in Perl 6, and has never been, I think.
[19:37] <masak> I remember reading some blog post about it.
[19:37] <masak> it's the thing that should be used instead of .lc (or .uc) for proper case-insensitive string comparison.
[19:38] <TimToady> it's certainly part of Perl 6, just NYI
[19:39] <xfix> r: Real.new
[19:39] <+camelia> rakudo-{parrot,moar} 3b9ebd: ( no output )
[19:40] <xfix> r: Real.new.perl.say
[19:40] <+camelia> rakudo-{parrot,moar} 3b9ebd: OUTPUT¬´Real.new()‚ê§¬ª
[19:40] <TimToady> :P
[19:40] <xfix> Why if I type Real.new in REPL, REPL gets stuck in infinite loop?
[19:41] <xfix> r: Real.new.say
[19:41] <TimToady> because the punned class has no bridge to actual values?
[19:41] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´Memory allocation failed; could not allocate 163840 bytes‚ê§¬ª
[19:41] <+camelia> ..rakudo-parrot 3b9ebd: OUTPUT¬´maximum recursion depth exceeded‚ê§current instr.: 'print_exception' pc 155220 (src/gen/p-CORE.setting.pir:65744) (gen/parrot/CORE.setting:12364)‚ê§called from Sub 'Bridge' pc 323316 (src/gen/p-CORE.setting.pir:134554) (gen/parrot/CORE.setting:4766)‚ê§ca‚Ä¶¬ª
[19:41] <xfix> Ok, so infinite recursion.
[19:42] <TimToady> could probably be handled with a proper stub method in the role
[19:42] <xfix> So I just learned that Buf and Blob are roles, not classes.
[19:42] <TimToady> they just default to uint8 when punned
[19:43] <a3gis> is it possible to have non-whitespace-sensitive rules in a grammar? to avoid insrting <ws>* between each nonterminal
[19:43] <xfix> (also, I miss easy recognization of infinity loops when working on hack... on my PC, fan starts working, but on external server, I hear nothing)
[19:43] <TimToady> a3gis: that's what 'rule' is for
[19:43] <xfix> r: say '2   +2' ~~ rule { (2) (\+) (2) }
[19:44] <+camelia> rakudo-{parrot,moar} 3b9ebd: OUTPUT¬´ÔΩ¢2   +2ÔΩ£‚ê§ 0 => ÔΩ¢2ÔΩ£‚ê§ 1 => ÔΩ¢+ÔΩ£‚ê§ 2 => ÔΩ¢2ÔΩ£‚ê§‚ê§¬ª
[19:44] <TimToady> rule { <foo> <bar> } will automatically provide <.ws> after each matching piece
[19:44] <TimToady> and <ws>* makes no sense, btw
[19:44] <masak> r: say '2   +2' ~~ rule { 2 '+' 2 }
[19:44] <+camelia> rakudo-{parrot,moar} 3b9ebd: OUTPUT¬´ÔΩ¢2   +2ÔΩ£‚ê§‚ê§¬ª
[19:44] <TimToady> ws is already multichar if necessary
[19:44] <masak> <ws>* will most likely put you in an infinite loop.
[19:44] <TimToady> and also allows no whitespace if not between alphanumerics
[19:45] <TimToady> so you don't need the 0 case either
[19:45] <xfix> r: say '22' ~~ rule { (2) (2) } # Nothing matched, because \w
[19:45] <+camelia> rakudo-{parrot,moar} 3b9ebd: OUTPUT¬´Nil‚ê§¬ª
[19:45] <xfix> r: say '++' ~~ rule { (\+) (\+) } # Matched, because \W
[19:45] <+camelia> rakudo-{parrot,moar} 3b9ebd: OUTPUT¬´ÔΩ¢++ÔΩ£‚ê§ 0 => ÔΩ¢+ÔΩ£‚ê§ 1 => ÔΩ¢+ÔΩ£‚ê§‚ê§¬ª
[19:46] <xfix> (of course, if you need more specific matching, you can change ws method)
[19:46] <TimToady> the p6 grammar allows pod as part of ws, for instance
[19:47] <TimToady> and comments
[19:47] <xfix> Yes, many programming languages allow comments between tokens. This is what changing "ws" can be useful for.
[19:47] <a3gis> TimToady: right, thanks!
[19:48] <a3gis> <ws>* because my token <ws> was matching exactly one whitespace
[19:48] <TimToady> shouldn't, if you're using the built-in ws
[19:48] *** FROGGS__ joined
[19:48] <xfix> a3gis, \s
[19:49] <xfix> Or \h, if you only want horizontal whitespace.
[19:49] <TimToady> yes \s* or \h* makes much more sense
[19:49] <xfix> There is also ' ', if you only want to match U+0020 Whitespace.
[19:51] <xfix> (when dealing with Python, it may be a good idea to modify the definition of <ws> to only handle horizontal whitespace, because 2 \n + 2 is something else than 2 + 2)
[19:51] *** FROGGS[tab]_ left
[19:51] <xfix> <.ws>*
[19:52] *** FROGGS_ left
[19:56] <a3gis> xfix: could you take a very quick look at this and tell me if it can be simplified? https://gist.github.com/a3gis/c165ba276bb85bdb07f9
[19:58] <xfix> Well, you could simplify production rule.
[19:59] <xfix> Instead of two rules, just <nonterminal> '::=' <expression>? ';'
[19:59] <xfix> Also, you don't need <ws> rule at beginning.
[19:59] <a3gis>  oh right
[19:59] <a3gis> mmh
[19:59] <a3gis> i tried without it but it wouldn't parse
[20:00] <xfix> Also, there was some way to simplify <factor> [<ws> <factor>]*, but I don't remember what.
[20:00] <xfix> [\w]+ can be simply written as \w+.
[20:01] *** jack_rabbit joined
[20:02] <psch> <factor>+ % <ws>
[20:02] <xfix> yes
[20:02] <xfix> I knew it was something with %, but I didn't exactly remember what.
[20:03] *** FROGGS__ is now known as FROGGS
[20:04] <a3gis> oh sweet
[20:04] <FROGGS> .tell jnthn can you please take a look at that gist? line 28 triggers the shows error (I want to make `do while` work): https://gist.github.com/FROGGS/98e1a97434c3753dc081
[20:04] <+yoleaux> FROGGS: I'll pass your message to jnthn.
[20:04] <a3gis> what is the % doing exactly?
[20:04] <a3gis> is it some generic syntax to interpolate some token between repetitions?
[20:04] <FROGGS> 'x separated by y'
[20:04] <FROGGS> yes
[20:05] <xfix> (I was trying to do <factor> %+ <ws>, but Perl 6 complained)
[20:05] <FROGGS> that's also why % was chosen, because it looks like two identical things separated by another
[20:05] <masak> FROGGS: wow, I had missed that rationale.
[20:06] <FROGGS> and you can have: a+ % b, a* % b, a**1..5 % b, a**{code that gives a range object} % b
[20:06] <masak> FROGGS: my mnemonic was "one or more of X things, *modulo* that Y things go in the middle"
[20:06] <TimToady> but write it as a +% b because that dwims under sigspace
[20:07] <xfix> Mnemonic for ** - mathematically, ho**3 = hohoho
[20:07] <FROGGS> masak: TimToady told me IIRC :o)
[20:07] *** darutoko left
[20:08] <masak> you can even do `a? % b`, but since you can't have a `b` between zero or one thing... :)
[20:08] <TimToady> but if you just want whitespace, use rule { <factor> + } or so
[20:08] <masak> %% would make sense in that context, though.
[20:09] <FROGGS> %% allows a trailing sep?
[20:09] <TimToady> yes
[20:09] <FROGGS> makes sense
[20:09] <TimToady> "it comes out evenly divisible"
[20:10] <masak> ooh :)
[20:10] <masak> Perl 6 makes too much sense sometimes.
[20:11] <FROGGS> it is just beautiful, aye
[20:11] <TimToady> xfix: you do need to match ws at the beginning explicitly, but you can do that by saying rule { ^ <stuff> }
[20:11] <FROGGS> most parts at least :o)
[20:11] <TimToady> since it'll look for <.ws> after the ^
[20:11] <xfix> TimToady, oh, right.
[20:12] <TimToady> In-n-Out run for the hoarded hordes... &
[20:12] <a3gis> oh cool
[20:12] <a3gis> also, what is '¬ª' in 'make $<question>¬ª.ast;'?
[20:12] <a3gis> and is there a non-unicode alternative?
[20:12] <masak> a3gis: >>
[20:12] <a3gis> I assume it's some postfix operator
[20:12] <masak> a3gis: it means "distribute method call .ast over elements"
[20:12] <a3gis> oh
[20:12] <a3gis> so it's map
[20:12] <a3gis> ?
[20:12] <masak> yes, but hyper.
[20:13] <masak> meaning conceptually there's no order of the calls.
[20:13] <masak> though the results retain the order of the original elements.
[20:13] <a3gis> alright
[20:13] <a3gis> is there a neater way to write it than make $<production>>>.ast;  ?
[20:13] <a3gis> it's a bit unreadable
[20:13] <a3gis> (without unicode)
[20:13] <masak> ¬ª
[20:13] <masak> ¬ª is just latin-1 :)
[20:13] <FROGGS> and the reasoning that there is no guaranteed ordering of the calls is that the compiler is allowed to call all in parallel
[20:14] <masak> a3gis: $<production>.map(*.ast) works too
[20:14] *** Sir_Ragnarok left
[20:15] <a3gis> masak: oh yeah that works; thanks!
[20:19] <moritz> stricktly speaking, 'map' is also Unicode
[20:19] <moritz> s/k//
[20:19] <a3gis> moritz: haha right, I should have been more precise :p
[20:20] <masak> it's all Unicode. and if it isn't yet, then just wait a few years.
[20:21] <a3gis> I should have said "something I can easily type on my keyboard"
[20:21] <moritz> compse > >
[20:22] <moritz> *compose
[20:22] * moritz notices that he typos every fifth word or so, and should probably stop typing today
[20:22] <moritz> OTHO, better docs with lots of typos than no docs at all
[20:23] *** denis_boyun_ joined
[20:23] <masak> +1
[20:24] <FROGGS> and btw, communication is not done to fulfil grammar rules... it is done to transfer meaning, and that still works with typos :o)
[20:24] <moritz> ... sometimes
[20:24] <FROGGS> hopefully most of the time I'd say
[20:25] <moritz> there is a certain individual who sometimes joins this channel (and others where I'm in), and he garbles his sentences so much that I often cannot parse them correctly, even after several times
[20:25] <moritz> and I'm not talking about FROGGS++
[20:25] <FROGGS> hehe
[20:25] <FROGGS> moritz: you are so kind :D
[20:28] <raydiak> \o #perl6 afternoon good
[20:28] <FROGGS> hi raydiak, we were just speaking of you...
[20:28] <moritz> m: grammar A is Any { }; say A.^mro
[20:28] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´(A) (Any) (Mu)‚ê§¬ª
[20:28] <FROGGS> (joke :P)
[20:29] <raydiak> hehe nah, not my sentences that are usually garbled, just the content therein :)
[20:31] <masak> my sentences are usually garbled. I'm an amateur garbler.
[20:32] <moritz> m: grammar A { token TOP { .* } }; say ~A.parse('ab', :c(1))
[20:32] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´b‚ê§¬ª
[20:34] *** dakkar joined
[20:35] <raydiak> masak: if you work hard you could go pro and shift careers from tech to law
[20:37] <masak> I'm not sure I'm that into it.
[20:39] <dakkar> for the people who saw me perpelxed a few (6) hours ago: ¬´my ($a,$b) = @( $str ~~ $rx ) or Exception.new.throw¬ª doesn't throw on match failure, but ¬´my ($a,$b) = @( $str ~~ $rx or Exception.new.throw )¬ª works
[20:39] *** denis_boyun_ left
[20:39] * raydiak considers that machine-oriented occupations reward less garbling, while people-oriented ones seem to be the opposite
[20:41] * moritz hated garbling teachers
[20:41] *** Sqirrel joined
[20:45] <sergot> hi o/
[20:46] <raydiak> garbling is a prerequisite for success in acadameia as far as I can tell...by the time you're in far enough to be a teacher, seems like you've either developed your own internal anti-garble mechanisms, or are lost forever, doomed to wander the earth as one of the garbling hordes :)
[20:47] <a3gis> erm sorry, another newbie question. I've a "rule factor { <nonterminal> | <terminal> }" and trying to build an action for it, which should return either the ast for terminal, or for nonterminal
[20:47] <raydiak> \o sergot 
[20:47] <moritz> raydiak: I've met a fair amount of people in academia here in .de, and my impression was that the garbling ratio wasn't hire than in, say, IT
[20:47] <sergot> raydiak: o/
[20:48] <masak> a3gis: `if $<nonterminal> { ... }`, something like that?
[20:48] <moritz> a3gis: make $<terminal> ?? $<terminal>.ast !! $<nonterminal>.ast;
[20:48] <a3gis> masak: oh ok, so there is not shortcut for that
[20:48] <moritz> is it still called make?
[20:48] <masak> or what moritz++ said.
[20:48] *** sirdancealot joined
[20:48] <masak> a3gis: no. sometimes I wish there were.
[20:48] <moritz> a3gis: well, you can also use 'make $/.hash.values[0].ast'
[20:48] <masak> a3gis: occasionally I end up writing my own utility subroutine for things like that.
[20:48] <FROGGS> a3gis: you could do: rule factor { $<thingy>=[ <.nonterminal> | <.terminal> ] } ... method factor($/) { make $<thingy>.ast }
[20:49] <a3gis> also, is there some sort of soaked access in p6? e.g. $x?.y
[20:49] <a3gis> which would only call y is $x is not Any
[20:49] <moritz> $x.?y
[20:49] <a3gis> oh ==>
[20:49] <moritz> which calls y if y is callable
[20:49] <moritz> (which isn't quite the same, but often near enough)
[20:50] <a3gis> what is the best reference for that kind of stuffs in p6 by the way? is there a good tutorial out there? I read the learnxinyminutes
[20:50] <a3gis> I feel a bit guilty harrassing you guys with very basic questions :p
[20:50] <FROGGS> a3gis: never mind, we like to show off :P
[20:50] <moritz> a3gis: it's ok; there's http://doc.perl6.org/type/Match for example
[20:51] <raydiak> moritz: most of the people I've met here who are in IT have already been subjected to the garble-learning part of acadameia
[20:51] <moritz> a3gis: also, https://github.com/perl6/book/ is a bit bitrotten, but the chapters on regexes and grammars should still be mostly fine
[20:52] <moritz> a3gis: http://doc.perl6.org/language.html also points to regex and grammar docs
[20:52] <FROGGS> moritz: and the book teaches terms you can search for later... so I think the book is quite important
[20:52] <moritz> a3gis: ... and all of that is reachable (more or less direct :-) from http://perl6.org/documentation/
[20:52] <moritz> a3gis: ... but do feel free to ask here, and also point out where docs are missing
[20:53] <moritz> or incomprehensible
[20:53] <moritz> in fact, I'm documenting class Grammar right now :-)
[20:53] <a3gis> moritz: yeah I kind of skimmed over all of those, but they all seem to be missing smething :p
[20:53] <a3gis> oh great!
[20:55] <+dalek> doc: 4800dfd | moritz++ | lib/Type/Grammar.pod:
[20:55] <+dalek> doc: document class Grammar
[20:55] <+dalek> doc: review: https://github.com/perl6/doc/commit/4800dfde3f
[20:55] <moritz> a3gis: though that's probably not the missing you're wishing for
[20:55] <raydiak> moritz++
[20:56] <a3gis> moritz: I'll try to write some stuffs once I get my head around the whole thing
[20:56] <moritz> a3gis: looking forward to it!
[20:57] <raydiak> I was playing around with grammars last night, trying to add attributes and .new them with different values...didn't work very well iirc; is stuff like that expected to work without subclassing Grammar?
[20:58] <raydiak> I know it's a weird thing to be doing, I was just kinda wondering why we allow methods and attributes in grammars if they aren't expected to work anyway
[20:58] <moritz> raydiak: writing a 'grammar YourGrammarHere { ... }' automatically subclasses Grammar
[20:58] <raydiak> oh, that makes sense
[20:58] *** pmqs_ joined
[21:00] <raydiak> m: grammar Foo { has $.bar }; Foo.new(:bar<foobar>).bar.say
[21:00] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´foobar‚ê§¬ª
[21:00] * lizmat thinks she has messages
[21:00] <+yoleaux> 17:03Z <jnthn> lizmat: maybe the problem is that Tap exposes those methods...
[21:00] <+yoleaux> 17:20Z <jnthn> lizmat: +1 to Supply.for getting renamed; not entirely sure about from-list but I dont have a better idea. .for *should* exist on an instance of Supply and do .flat.map just as on a List.
[21:00] <+yoleaux> 17:21Z <jnthn> lizmat: to be clear, I mean .flat and .map in Supply-land, that is, it's still push semantics.
[21:00] <raydiak> hm, will have to go back thruogh the bash history and see exactly what wasn't working
[21:00] <raydiak> maybe I was just tired again *shrug*
[21:04] <lizmat> moritz: thanks for eradicating &cwd, I was weary of doing that myself because of potential ecosystem breakage
[21:04] *** kjs_ left
[21:04] <moritz> lizmat: I didn't remove it; just a version of cwd that was in an inner scope, thus not visible outside the setting
[21:05] <moritz> m: say cwd
[21:05] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´"/home/camelia".IO‚ê§Saw 1 call to deprecated code during execution.‚ê§================================================================================‚ê§Sub cwd (from GLOBAL) called at:‚ê§  /tmp/Jmf9qfiLz7, line 1‚ê§Deprecated since v2014.10, will be remo‚Ä¶¬ª
[21:05] <a3gis> https://gist.github.com/a3gis/483ee7268309fc95998a#file-gistfile1-p6-L22
[21:05] <a3gis> why does nonterminal have type Array?
[21:06] <a3gis> $<nonterminal>.ast
[21:07] <moritz> m: say 'ab' ~~ /('a')?/; say $0.^name
[21:07] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´ÔΩ¢aÔΩ£‚ê§ 0 => ÔΩ¢aÔΩ£‚ê§‚ê§Match‚ê§¬ª
[21:07] <moritz> a3gis: what version of rakudo are you using?
[21:07] <a3gis> 2014.12-34-ge861672 
[21:10] <moritz> a3gis: that's not where the error comes from
[21:11] <moritz> a3gis: it comes from line 80, when I run it
[21:11] <moritz> class BNF::Production { has @.nonterminal;
[21:11] <moritz> that's where the Array comes from
[21:11] <moritz> you declared it to be an array :-)
[21:11] *** Mso150_j joined
[21:12] *** kaare_ left
[21:12] *** Mso150 left
[21:12] <a3gis> moritz: oh crap, I meant to make the attribute public but messed up the sigil -->
[21:13] <a3gis> sorry
[21:13] <moritz> a3gis: no problem
[21:13] <moritz> a3gis: parsing BNF with grammar - I like it :-)
[21:13] <a3gis> haha yeah, I thought writing a LL(1) parser generator would be a good exercise to touch different areas of perl6
[21:14] <raydiak> m: grammar G { has $.str; token TOP { $.str }; }; G.new(:str<foo>).parse("foo"); # should this work?
[21:14] <+camelia> rakudo-moar 3b9ebd: ( no output )
[21:14] <raydiak> m: grammar G { has $.str; token TOP { $.str }; }; G.new(:str<foo>).parse("foo").say; 
[21:14] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´(Any)‚ê§¬ª
[21:14] <lizmat> .tell jnthn I don't see how those methods could not be public, unless you want to go all getattr ?
[21:14] <+yoleaux> lizmat: I'll pass your message to jnthn.
[21:15] <TimToady> arg, RT #83952 is just wrong, \cI is supposed to be a tab
[21:15] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=83952
[21:17] <TimToady> someone completely missed the point of matching '?' .. 'Z'
[21:18] <moritz> I've now taught the doc.perl6.org update job to only do something if there was a new commit on master, and run it twice per hour
[21:18] <raydiak> nice
[21:18] <moritz> I guess I should do the same magic on moar update jobs
[21:19] *** FROGGS[tab] joined
[21:25] <+dalek> roast: 8a98e6e | TimToady++ | S02-literals/quoting.t:
[21:25] <+dalek> roast: test control forms of \c
[21:25] <+dalek> roast: review: https://github.com/perl6/roast/commit/8a98e6e3c0
[21:25] <+dalek> mu: 82d3cd8 | moritz++ | util/update-design.perl6.org.sh:
[21:25] <+dalek> mu: skip updates dor design.perl6.org if nothing changed in git
[21:25] <+dalek> mu: review: https://github.com/perl6/mu/commit/82d3cd8f8a
[21:26] <moritz> people will notice I write bash scripts with baby vocabulary only
[21:26] <moritz> style critique welcome
[21:27] *** a3gis left
[21:27] <+dalek> nqp: 77d2a4b | TimToady++ | src/HLL/ (2 files):
[21:27] <+dalek> nqp: \c is suppose to support control codes too
[21:27] <+dalek> nqp: review: https://github.com/perl6/nqp/commit/77d2a4b9a0
[21:28] <TimToady> *supposed
[21:30] <raydiak> (bash scripts with baby vocabulary only)++
[21:31] <+dalek> mu: 569850b | (Konrad Borowski)++ | util/update-design.perl6.org.sh:
[21:31] <+dalek> mu: Use short conditional for fast exit
[21:31] <+dalek> mu: review: https://github.com/perl6/mu/commit/569850ba5d
[21:35] <moritz> xfix++
[21:35] <xfix> (it's bash idiom)
[21:35] <xfix> (also in Perl)
[21:36] <lizmat> TimToady: t/spec/S02-literals/quoting.t is failing compilation atm, maybe an nqp bump is warranted ?
[21:39] *** Rounin left
[21:42] <TimToady> I'm trying to sneak the \0 fix in with the same bump
[21:43] <+dalek> nqp: a760e4e | TimToady++ | src/QRegex/P6Regex/ (2 files):
[21:43] <+dalek> nqp: match \0 in regexland too
[21:43] <+dalek> nqp: review: https://github.com/perl6/nqp/commit/a760e4e608
[21:44] <+dalek> rakudo/nom: ce1e747 | TimToady++ | tools/build/NQP_REVISION:
[21:44] <+dalek> rakudo/nom: bump NQP
[21:44] <+dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce1e747f2c
[21:45] *** xfix left
[21:46] <TimToady> lizmat: that should fix it
[21:46] * lizmat checks
[21:47] *** rurban left
[21:51] *** kjs_ joined
[21:56] *** dakkar left
[21:58] <raydiak> m: grammar G { token TOP { {say self.WHICH} } }; my $g = G.new; say $g.WHICH; $g.parse: "" # ?
[21:58] <+camelia> rakudo-moar 3b9ebd: OUTPUT¬´G|50355888‚ê§G|50356000‚ê§¬ª
[21:59] <TimToady> cursors != grammars
[22:01] <TimToady> in fact, every spot in your parse is a *different* cursor
[22:01] <masak> folks, sergot and I have a little surprise for you.
[22:02] <masak> over the Christmas weekend, we put together a small experimental language.
[22:02] <lizmat> .oO( it was christmas already? )
[22:02] <masak> now we feel it's time to share it and get some early feedback.
[22:03] <masak> this is especially true for people who would like to play around with Qtrees today.
[22:03] <+dalek> ecosystem: c94bef4 | sergot++ | META.list:
[22:03] <+dalek> ecosystem: add 007
[22:03] <+dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/c94bef47a7
[22:03] <masak> please have a look at http://masak.github.io/007/
[22:05] <masak> it's basically a minimal language that is nevertheless big enough to talk about itself.
[22:06] <masak> the tutorial at http://masak.github.io/007/ is a little bit ahead of the language implementation. not a lot.
[22:07] *** mickcy_ca joined
[22:09] <masak> there are plenty of tests. 144 tests by last count.
[22:12] <raydiak> somehow ++ doesn't cut it :)  awesome job sergot & masak, exciting work
[22:12] <mickcy_ca> Does anybody have any idea why http://pastebin.com/pqs0Q1Qa works and http://pastebin.com/1zPHb8dY does not????  The offending portion is ('('.+?')') (matches) vs '('(.+?)')' (fails)
[22:13] <masak> raydiak: well, let's see how much mileage we can get out of it. in the best case, we'll be able to prototype some crazy macro ideas in 007.
[22:14] <masak> raydiak: in the worst case, it was just a fun experiment in minimalism.
[22:15] <mickcy_ca> You can see the diff at http://pastebin.com/diff.php?i=pqs0Q1Qa where line 16, 'change is here' is the matching one.
[22:18] <psch> hrm, $*W.find_symbol gets me DEPRECATED, and calling it with nqp::call does happen, but the Deprecation for :from<java> doesn't show up :/
[22:20] <raydiak> masak: wish I could tell you I had some exciting ideas, but the whole thing makes my head spin every time I try to really grok it (every few days)
[22:21] <masak> raydiak: "it"?
[22:21] <psch> masak++ sergot++
[22:21] <raydiak> masak: macro stuff in general
[22:21] <masak> it is head-spinny, no doubt.
[22:21] <masak> but I think it's slightly easier to understand in 007 than in Perl 6, actually.
[22:27] <masak> 'night, #perl6
[22:29] <mickcy_ca> Never mind about the grammar I posted ... found a solution, but it is ugly.
[22:29] <mickcy_ca> http://pastebin.com/ak4sz7Ca
[22:30] <raydiak> g'night masak
[22:44] <moritz> masak++ # 007
[22:45] <mickcy_ca> Back at regex's again ... I am having difficulty getting the results that I want.
[22:45] <mickcy_ca> This is related to the pastebins that I posted.
[22:46] <mickcy_ca> I want to explicitly match '(' and ')' outside of a capturing group.
[22:47] <psch> m: say "(a)" ~~ token { '(' <-[)]>+ ')' }
[22:47] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(a)ÔΩ£‚ê§‚ê§¬ª
[22:47] <psch> huh
[22:47] <psch> oh the token of course matches everything
[22:47] <psch> m: say "(a)" ~~ m:r{ ^ '(' (<-[)]>+) ')' $ }
[22:47] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(a)ÔΩ£‚ê§ 0 => ÔΩ¢aÔΩ£‚ê§‚ê§¬ª
[22:48] *** mvuets left
[22:48] <psch> :ratchet was no "no backtracking", i think..?
[22:48] <moritz> yes, and token { } enables that
[22:48] <moritz> use regex { } if you want a backtracking regex
[22:49] <psch> moritz: yeah, my confusion was actually not using the capture group in the anon token
[22:49] <mickcy_ca> psch:  that particular syntax is in my last pastebin ... I want '('(.+?)')' to match atcheting 
[22:50] <mickcy_ca> m: say "(a)" ~~ m:r{('('.+?')')}
[22:50] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(a)ÔΩ£‚ê§ 0 => ÔΩ¢(a)ÔΩ£‚ê§‚ê§¬ª
[22:50] <mickcy_ca> Works here ... AAAARRRRGGGHHH
[22:50] <mickcy_ca> Oops wrong one ...
[22:50] <psch> m: say "(a)" ~~ / '(' ~ ')' (.)/ # this also works
[22:50] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(a)ÔΩ£‚ê§ 0 => ÔΩ¢aÔΩ£‚ê§‚ê§¬ª
[22:51] <psch> m: say "(a)" ~~ m:r/ '(' ~ ')' (.)/ # this also works
[22:51] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(a)ÔΩ£‚ê§ 0 => ÔΩ¢aÔΩ£‚ê§‚ê§¬ª
[22:51] <mickcy_ca> Trying to parse on commas ... that is the reason for trying to match with .+?
[22:52] <mickcy_ca>   m: say "(a)" ~~ m:r{'('(.+?)')'}
[22:52] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(a)ÔΩ£‚ê§ 0 => ÔΩ¢aÔΩ£‚ê§‚ê§¬ª
[22:52] <TimToady> m: say "(aa)" ~~ m:r{'('(.+?)')'}
[22:52] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[22:52] <TimToady> that's a bug
[22:53] <TimToady> ? and ! are both supposed to override :r
[22:53] <mickcy_ca> That explains it.
[22:55] *** aborazmeh joined
[22:55] <mickcy_ca> I can replace .+? with \S+  ... that seems to work to tokenize my string.
[22:55] <TimToady> m: say "(aa)" ~~ m:r{'('(.+!)')'}
[22:55] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[22:55] <TimToady> that one should also work
[22:56] <TimToady> except I think what's happening is actually that it's installing a : after the ()
[22:56] <mickcy_ca> say "(aa)" ~~ m:r{'('(\S+)')'}
[22:56] <mickcy_ca> m: say "(aa)" ~~ m:r{'('(.+!)')'}
[22:56] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[22:56] <TimToady> m: say "(aa)" ~~ m:r{'('(.+!):!')'}
[22:56] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[22:56] <mickcy_ca> say "(aa)" ~~ m:r{'('(\S+)')'}
[22:56] <TimToady> m: say "(aa)" ~~ m:r{'('(.+!):?')'}
[22:56] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[22:57] <mickcy_ca> m: say "(aa)" ~~ m:r{'('(\S+)')'}
[22:57] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[22:57] <mickcy_ca> Worked in my string ....
[22:57] *** Ven joined
[22:57] <TimToady> now that one shouldn't match
[22:57] <mickcy_ca> Not sure why it doesn't work on '(aa)'
[22:57] <TimToady> \S matches ) and then can't backtrack
[22:58] <mickcy_ca> Sorry about all of that ... I was experiencing some pasty finger obejibuts
[22:58] <mickcy_ca> Just looked at what matches here ...
[22:59] <mickcy_ca> m: say "(aa)" ~~ m:r{'('(\S+?)')'}
[22:59] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[22:59] <TimToady> it's the automatic marking of every matcher with a : that is preventing it from backtracking into the ()
[23:00] <TimToady> m: say "(aa)" ~~ m:r{'('(.+?)**1')'}
[23:00] <+camelia> rakudo-moar ce1e74: OUTPUT¬´False‚ê§¬ª
[23:01] <mickcy_ca> Regex nightmares.
[23:02] <TimToady> when you use m:r it translates '('(.*?)')' to something like '(': ( .*? ): ')':
[23:03] <TimToady> it's the : after the capture that suppresses backtracking into the .*? when ')' is falsified
[23:03] <mickcy_ca> If I understand correctly, tokens ratchet ... and I am trying to get this into a grammar.
[23:04] <moritz> mickcy_ca: you can use 'regex' instead of 'token', or switch off ratcheting with :!r within a token
[23:05] <TimToady> marking () with : is related to the notion of marking <foo> with a : to prevent backtracking into it, but I'm not entirely sure that was a correct decision back when it was made
[23:05] <TimToady> to be sure, there are WATs with the other behavior as well
[23:06] <TimToady> m: say "(aa)" ~~ m:r{'(' $<foo>=[.+?] ')'}
[23:06] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(aa)ÔΩ£‚ê§ foo => ÔΩ¢aaÔΩ£‚ê§‚ê§¬ª
[23:07] <TimToady> m: say "(aa)" ~~ m:r{'(' $<0>=[.+?] ')'}
[23:07] <+camelia> rakudo-moar ce1e74: OUTPUT¬´ÔΩ¢(aa)ÔΩ£‚ê§ 0 => ÔΩ¢aaÔΩ£‚ê§‚ê§¬ª
[23:07] <TimToady> there's a workaround
[23:07] <TimToady> 'cause it only marks (), not []
[23:08] <moritz> not having followed the whole conversation, is a a reason not to use <-[)]>* ?
[23:10] <TimToady> arguably having to repeat the ) character is a smell
[23:10] <moritz> and also if you want to get error messages, use '(' ~ ')' [ <-[)]>* ]
[23:10] <moritz> yes, I sometimes wondered if we want a primitive or built-in for that
[23:11] *** aborazmeh left
[23:12] *** BenGoldberg joined
[23:13] <mickcy_ca> moritz: The reason for not using <-[)]>* is that I want to tokenize
[23:13] <mickcy_ca> int socket (int __domain, int __type, int __protocol)
[23:13] <TimToady> in STD I think '(' ~ ')' would set $*GOAL to ')', so you could conceivably write '(' ~ ')' [<!before $*GOAL> .] or some such
[23:14] <moritz> mickcy_ca: I don't understand what that means
[23:14] <moritz> mickcy_ca: I know what tokenizing it, and I don't see how it conflicts with using <-[)]>* 
[23:15] <mickcy_ca> I want to get the output...
[23:15] *** virtualsue joined
[23:15] <mickcy_ca> int
[23:15] <mickcy_ca> socket
[23:15] <mickcy_ca> int
[23:15] <mickcy_ca> __domain
[23:15] <mickcy_ca> int
[23:15] <mickcy_ca> __type
[23:15] <mickcy_ca> int
[23:15] <mickcy_ca> __protocol
[23:15] <TimToady> well, .*? doesn't tokenize either
[23:15] <TimToady> you really want a subrule there
[23:15] *** jack_rabbit left
[23:16] <TimToady> much like the p6 grammar looks for <parameters> there
[23:16] <mickcy_ca> I realize that ... i am just at the stage of trying to get the entire contents of the parameter list as a string that I can split up in a subrule.
[23:17] <TimToady> well, a seqence of <parameter>
[23:17] <TimToady> which will break as soon as one of your parameters has () in it
[23:18] <TimToady> like a function pointer, say
[23:18] <mickcy_ca> To tokenize, I would use something to the tune of [(\w+) \s+ (\w+)]*
[23:18] <TimToady> that won't even allow *
[23:19] <TimToady> you really need subrules to stay sane
[23:19] *** jack_rabbit joined
[23:19] <mickcy_ca> Yes, and that is what I had planned for the subrule.
[23:21] <TimToady> you can play fast and loose with ordinary regex, but tokens have to be a bit stricter, or your parse goes off on wild goose chases when you quantify something too general, such as .
[23:22] <mickcy_ca> I guess that I could use (<-[) ]>*)\s*<-[),]>*\s* as a start anyway.
[23:22] <TimToady> or something too strict, such as \w
[23:22] <moritz> well, tokenizing would traditionally keep the parens, but as separate tokens
[23:22] <mickcy_ca> I have noticed that using token the fast and loose way seems to work.
[23:23] <TimToady> at some point the quick and dirty is not as quick as just writing the subrules you want :)
[23:23] <TimToady> well, except it didn't, when you put () around it, which prevented backtracking into it
[23:23] <moritz> but if you just tokenize, you have parse afterwards, and Perl 6 grammars won't help you if you have a custom token stream
[23:23] <mickcy_ca> At least fast a loose sometimes works.
[23:24] <moritz> so it might be more efficient (from a code development perspective) to do proper parsing right away
[23:24] <mickcy_ca> I fully agree with that ... 
[23:25] <TimToady> but we -Ofun around here, so if you want to play with other approaches, we certainly won't stop you :)
[23:25] <TimToady> if that's your idea of fun...
[23:25] <mickcy_ca> Of course ... I realize that.
[23:26] * moritz 's idea of fun is, at this time of day, identical to sleeping
[23:27] <moritz> good night&
[23:27] <psch> g'night moritz \o
[23:27] <mickcy_ca> Nighty night ... late  afternoon here.
[23:27] <TimToady> there's an idea, though here it's more like nap time :)
[23:27] <mickcy_ca> Here too.
[23:27] <TimToady> zzz &
[23:28] <psch> i realized my mistake with DEPRECATED \o/
[23:28] <psch> my branch is not up to nom HEAD, so deprecating with 2014.12 didn't work because i'm on 2014.11...
[23:30] <psch> figuring out how to get Java fields to Perl¬†6 properly is gonna be an appropriate amount of fun as well
[23:30] <psch> the first idea was just generating a method for the adaptor that's named the same as the field, but that's not rw
[23:31] <kjs_> moritz: ping
[23:31] <psch> so now i'm thinking Proxy, but i think that needs some MOP-stuff to work, which i have no clue how to do
[23:57] <colomon> psch: at its most basic, Proxy is very easy to use.
[23:59] <psch> colomon: well, i'll have to generated bytecode for getters and setter inside the adaptor class, and a proxy on the perl6 class that calls those in FETCH and STORE respectively
[23:59] <psch> colomon: the bit i'm stuck with is more the latter, i.e. telling perl6 that instantiating a class :from<Java> means it has to wrap all adaptors that belong to fields with Proxys