[00:01] *** donk joined
[00:04] <dalek> roast: 77b8dc4 | (Elizabeth Mattijsen)++ | S32-list/roll.t:

[00:04] <dalek> roast: Add tests for sanity of .roll on Enums

[00:04] <dalek> roast: review: https://github.com/perl6/roast/commit/77b8dc4892

[00:10] *** woolfy left
[00:14] *** tgt joined
[00:18] *** tgt left
[01:09] *** ssutch joined
[01:14] *** tgt joined
[01:19] *** tgt left
[01:21] *** DEA7TH joined
[01:33] *** hoverboard joined
[01:46] *** woosley joined
[01:52] *** ssutch left
[01:52] *** kurahaupo left
[01:57] *** ssutch joined
[02:04] *** lustlife joined
[02:15] *** tgt joined
[02:20] *** tgt left
[02:26] *** xragnar_ joined
[02:26] *** xragnar left
[02:26] *** xragnar_ is now known as xragnar

[02:30] *** raydiak joined
[02:33] *** raiph left
[02:51] *** klapperl joined
[02:54] *** klapperl_ left
[02:55] *** rurban1 joined
[03:02] *** woosley left
[03:03] *** woosley joined
[03:06] *** ssutch left
[03:10] *** ssutch joined
[03:12] *** xenoterracide left
[03:16] *** ssutch left
[03:16] *** jnap left
[03:16] *** tgt joined
[03:21] *** tgt left
[03:21] *** cognominal left
[03:22] *** cognominal joined
[03:31] *** iolympian joined
[03:35] *** ssutch joined
[03:38] *** xenoterracide joined
[03:45] *** xenoterracide left
[03:45] *** ssutch_ joined
[03:45] *** ssutch left
[03:46] *** jnap joined
[03:47] *** MrMeek joined
[03:51] *** woosley left
[03:51] *** jnap left
[03:55] *** woosley joined
[03:56] *** iolympian left
[04:03] *** colomon joined
[04:05] *** bjz joined
[04:17] *** tgt joined
[04:22] *** tgt left
[04:26] *** colomon left
[04:30] *** colomon joined
[04:33] *** xenoterracide joined
[04:40] *** colomon left
[04:41] *** colomon joined
[04:57] *** xenoterracide left
[04:59] *** sorear left
[05:08] *** DEA7TH left
[05:14] *** BenGoldberg left
[05:17] *** tgt joined
[05:21] *** kaare_ joined
[05:22] *** tgt left
[05:27] *** [Sno] left
[05:43] *** rurban1 left
[05:44] *** thou left
[05:45] *** zby_home joined
[05:56] *** sorear joined
[05:58] *** kaare_ left
[06:03] *** hoverboard left
[06:14] *** stevan_ left
[06:14] *** rurban1 joined
[06:18] *** tgt joined
[06:19] *** rurban1 left
[06:22] *** kaare_ joined
[06:23] *** tgt left
[06:35] *** [Sno] joined
[06:38] *** JimmyZ left
[06:49] *** jnap joined
[06:53] *** jnap left
[07:00] *** Juliet joined
[07:01] *** userperl joined
[07:04] *** userperl left
[07:06] *** Juliet left
[07:10] *** darutoko joined
[07:15] *** rurban1 joined
[07:15] *** dmol joined
[07:20] *** rurban1 left
[07:28] *** FROGGS joined
[07:30] <FROGGS> morning

[07:37] *** IllvilJa joined
[07:48] *** stevan_ joined
[07:49] *** jnap joined
[07:54] *** jnap left
[07:54] *** woolfy joined
[07:58] *** telex left
[07:58] <moritz> \o FROGGS, *

[08:00] *** telex joined
[08:12] *** woolfy left
[08:14] *** denis_boyun joined
[08:16] *** rurban1 joined
[08:21] *** rurban1 left
[08:37] *** SamuraiJack joined
[08:38] *** kaleem joined
[08:44] *** fhelmberger joined
[08:47] *** FROGGS left
[08:50] *** jnap joined
[08:51] *** kurahaupo joined
[08:55] *** jnap left
[08:55] <sergot> morning #perl6! o/

[08:57] <TimToady> good afternoon from beijing

[08:58] *** JimmyZ joined
[09:14] <arnsholt> o/

[09:17] *** rurban1 joined
[09:19] *** rurban2 joined
[09:21] <masak> \o

[09:21] <nwc10> good UFT ambigutity

[09:22] *** rurban1 left
[09:22] <nwc10> gah

[09:22] <nwc10> good UGT ambiguity, #perl6

[09:23] *** rurban2 left
[09:25] *** FROGGS[mobile] joined
[09:28] <corecatcher> Good Morning from hanover

[09:29] <jnthn> UFT? I...won't guess. :P

[09:29] <jnthn> TimToady: Hope the air is more breatheable than when I was last there...

[09:30] <TimToady> well, we can see other buildings :)

[09:30] *** dakkar joined
[09:30] <TimToady> and we have masks for the days we can't :)

[09:30] *** ssutch_ left
[09:31] *** ssutch joined
[09:31] <nwc10> jnthn: it was an innocent typo. Off by one keyboard error

[09:31] <corecatcher> get yourself a pure air resp. mask

[09:35] *** ssutch left
[09:37] <masak> nwc10: I hate it when my Unified Field Theories are ambiguous. so annoying!

[09:39] <moritz> aren't they all, at least by a gauge term? :-)

[09:40] <masak> I'm not savvy enough to gauge that. :)

[09:41] *** virtualsue joined
[09:46] *** rindolf joined
[09:48] * moritz isn't gaugy enough to savy that

[09:51] *** jnap joined
[09:51] * masak .oO( the gaugy agenda )

[09:56] *** jnap left
[09:58] *** ssutch joined
[09:59] *** ssutch left
[10:00] *** ssutch joined
[10:06] *** woosley left
[10:11] *** rindolf left
[10:20] *** rurban1 joined
[10:24] *** rurban1 left
[10:24] *** denis_boyun left
[10:45] *** colomon_ joined
[10:46] *** Ven joined
[10:47] *** colomon left
[10:47] *** colomon_ is now known as colomon

[10:48] <Ven> r: say sort {$^b leg $^a}, (3, 20, 100).pick(*)

[10:48] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«3 20 100␤»

[10:49] <Ven> r: say sort ->$a,$b{$b leg $a}, (3, 20, 100).pick(*)

[10:49] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«3 20 100␤»

[10:49] <Ven> r: say sort {$^a leg $^b}, (3, 20, 100).pick(*)

[10:49] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«100 20 3␤»

[10:49] <Ven> Yeah, that's really surprising ..

[10:50] <jnthn> Why? You used a string comparison operator.

[10:50] *** ClarusCogitatio left
[10:51] *** ClarusCogitatio joined
[10:51] *** ssutch left
[10:52] *** jnap joined
[10:52] <jnthn> leg is string (consistent with le, ge, eq, ne...), <=> is numeric (consistent with <=, >=, ==, !=), and cmp is "figure something out somehow" :)

[10:53] *** rindolf joined
[10:54] *** ClarusCogitatio left
[10:54] *** ClarusCogitatio joined
[10:56] <Ven> jnthn: no, I mean $^ lexicographic ordering

[10:56] <Ven> http://ttjjss.wordpress.com/2010/11/21/perl-6-grammars-%E2%80%93-not-only-for-parsing/ < neat idea

[10:56] *** jnap left
[10:58] <jnthn> Ven: Oh...yeah, that's the point of them :)

[11:00] *** kurahaupo left
[11:03] *** gummy joined
[11:04] *** gummy left
[11:17] *** prammer joined
[11:18] *** virtualsue left
[11:21] *** rurban1 joined
[11:28] *** rurban1 left
[11:29] *** denis_boyun joined
[11:42] <Ven> r: my @x; say ( @x[*-1] :exists).perl

[11:42] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«(Bool::False,)␤»

[11:42] <Ven> r: my @x; say so ( @x[*-1] :exists)

[11:42] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«True␤»

[11:43] * Ven is going through #perl6 archives for some reasons

[11:43] <Ven> r: my @a will begin { say $_.WHAT };

[11:43] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«(Mu)␤»

[11:53] *** jnap joined
[11:53] <Ven> r: my @x; say any True, ( @x[*-1] :exists).perl

[11:53] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«any(True, (Bool::False,))␤»

[11:53] <Ven> r: my @x; say any True, ( @x[*-1] :exists)

[11:53] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«any(True, False)␤»

[11:53] <Ven> r: my @x; say so any ( @x[*-1] :exists) == True

[11:53] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«True␤»

[11:53] <Ven> uh?

[11:53] <Ven> r: my @x; say so (any ( @x[*-1] :exists) == True)

[11:53] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«True␤»

[11:55] <Ven> oh yeah, I'd need a junction to list

[11:55] <Ven> r: my @x; say so (@x[*-1] :exists).grep True

[11:55] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> my @x; say so (@x[*-1] :exists).grep ⏏True␤    expecting any of:␤        …»

[11:55] <Ven> r: my @x; say so (@x[*-1] :exists).grep(True)

[11:55] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«True␤»

[11:55] <Ven> r: my @x; say (@x[*-1] :exists).grep(True).perl

[11:55] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«(Bool::False,).list␤»

[11:56] <Ven> r: say (False,).grep(True).perl;

[11:56] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«(Bool::False,).list␤»

[11:56] <jnthn> say so any ( @x[*-1] :exists) == True # pasres as say so any( ( @x[*-1] :exists) == True )

[11:56] <Ven> I'm pretty surprised.

[11:56] <Ven> why does grepping True in a list of False gives that false ?

[11:56] <Ven> r: say (False,).grep(* == True).perl;

[11:56] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«().list␤»

[11:57] <Ven> r: say False ~~ True

[11:57] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at /tmp/tmpfile:1␤    ------> say False ~~⏏ …»

[11:57] <jnthn> It smartmatches, and...what you just saw. :)

[11:57] <Ven> that's pretty surprising, too...

[11:57] *** jnap left
[11:58] <Ven> I'll take it that smartmatching on False always gives false

[11:58] <Ven> okay, so

[11:58] <Ven> r: my @x; say so (@x[*-1]:exists).grep(* == True)

[11:59] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«False␤»

[11:59] <Ven> am I missing any obvious shortcut to know if *one* elem exists?

[11:59] <jnthn> Yeah, but that's hardly idiomatic.

[11:59] <Ven> Well, obviously

[11:59] <jnthn> r: my @x; say so any(@x[*-1]:exists)

[11:59] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«False␤»

[11:59] <Ven> oh, yeah, any just does the job

[12:00] * Ven reinvents any, but in a less powerful manner.

[12:00] <jnthn> And if you're in a boolean context then the so is implicit

[12:00] <Ven> yeah, that's just to print.

[12:00] <Ven> is any optimized for boolean context ?

[12:00] <jnthn> *nod*

[12:01] <Ven> (stopping after the first True in bool context)

[12:01] <jnthn> yeah; see https://github.com/rakudo/rakudo/blob/nom/src/core/Junction.pm#L10

[12:02] <Ven> jnthn++ # yay !

[12:07] *** AW3i joined
[12:10] *** FROGGS joined
[12:13] *** ggoebel11118 left
[12:13] *** ggoebel11118 joined
[12:17] *** hummeleB1 joined
[12:23] *** rurban1 joined
[12:25] *** brrt joined
[12:25] *** brrt left
[12:26] <FROGGS> jnthn: I have problems to patch perl6_ops.c like in http://irclog.perlgeek.de/perl6/2014-03-27#i_8503522

[12:27] <FROGGS> jnthn: because MVMP6opaque_real_data is about the MVMP6opaqueBody, but do we have a MVMP6opaqueBody there?

[12:27] *** colomon left
[12:28] *** rurban1 left
[12:29] *** skids left
[12:34] <jnthn> FROGGS: No; you can get it with OBJECT_BODY

[12:34] <FROGGS> jnthn: I know, but then I have the replaced body, right?

[12:35] <FROGGS> and what do I do with it? how do I access ->items?

[12:37] <jnthn> ah, I see what you mena.

[12:37] <FROGGS> https://gist.github.com/FROGGS/84550938a264ffd8b457

[12:38] <jnthn> Probably need to get the struct for P6List to be a struct of its body.

[12:38] <FROGGS> explodes too with "this type does not support elems"

[12:38] <jnthn> And then write a macro to make this convenient.

[12:38] <FROGGS> oha

[12:38] *** Ven left
[12:38] <FROGGS> okay, I give it a try

[12:39] <FROGGS> saywerx++ # "like really fucking sucks"

[12:39] <nwc10> like the NOTWORK :-/

[12:39] <nwc10> (for me. I'm on borrowed 4G)

[12:40] <FROGGS> nwc10: i have GSM

[12:40] <FROGGS> >.<

[12:40] <FROGGS> like 9600 baud or so

[12:41] * [Coke] waves blearily from $dayjob

[12:49] <BooK> so I decided I'm going to start learning Perl 6, by writing a module

[12:49] <BooK> where should I start

[12:50] <BinGOs> Acme::Perl6::Is::My::Bitch

[12:50] <[Coke]> no. :P

[12:50] <FROGGS> BooK: choose a module with already existing deps or with just a few deps you'd have to write

[12:50] <tadzik> hahaha

[12:51] <BooK> FROGGS: I was thinking about porting my own Git::Repository from Perl 5

[12:51] <arnsholt> Oooh, that sounds neat

[12:51] <jnthn> That could be interesting :)

[12:51] <arnsholt> What kind of stuff does that module depend on?

[12:51] <FROGGS> http://deps.cpantesters.org/?module=Git%3A%3ARepository;perl=latest

[12:52] <BooK> not much I think

[12:52] <FROGGS> all of the deps are built in into Perl 6 I think

[12:52] <BooK> as I hoped :-)

[12:52] <arnsholt> Yeah, looking at FROGGS' link, mostly file things, looks like

[12:52] <arnsholt> There's File::Find, I guess, but there's a six version of that

[12:53] <nwc10> finally, I have an IP again

[12:53] *** jnap joined
[12:53] <FROGGS> BooK: the next step would be to sketch the API I guess, and then to play around how that might be written nicely

[12:53] <BooK> I wasn't aware that I was using File::Find :-)

[12:54] <BooK> FROGGS: the point of porting is that there's already an API

[12:54] <FROGGS> BooK: okay, next step: done

[12:54] <FROGGS> :o)

[12:54] <FROGGS> at least, the first half

[12:54] <BooK> this is really easy

[12:55] <BooK> up until now, Perl 6 is pretty cool ;-)

[12:55] <arnsholt> BooK: Oh, could very well be. I'm just going off that cpantesters link =)

[12:56] <[Coke]> something from the mojo suite? ;)

[12:56] <BooK> I suppose my main question was more about where to find docs.

[12:56] <BooK> http://doc.perl6.org/ is the probable answer

[12:57] <arnsholt> Yeah, or asking around here. Docs is something of a weak spot, sadly

[12:58] *** jnap left
[12:58] <BooK> We'll see. I might be distracted by some shiny thing at any point, anyway.

[12:59] <sjn> \o

[13:00] <sjn> perl 6 talk in Oslo (at the Uni) in about 2 hours \o/

[13:00] <sjn> come one, come all :)

[13:01] <nwc10> isn't that a bit late notice to book flights? :-/

[13:02] <nwc10> is it being recorded?

[13:03] *** guru joined
[13:04] *** guru is now known as Guest28116

[13:04] *** Guest28116 is now known as ajr_

[13:05] *** Ven joined
[13:10] <tadzik> it's Damian I think, so I doubt it :/

[13:10] *** kbaker joined
[13:10] <cosimo> going there in an hour or so :)

[13:11] *** zakharyas joined
[13:12] <Ven> r: class A { has $.foo; }; my @l = (Any, A.new(:foo<hey>); );  .?foo.say for @l;

[13:12] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«Nil␤hey␤»

[13:12] <Ven> r: class A { has $.foo; }; my @l = (Any, A.new(:foo<hey>); );  .foo.say for @l;

[13:12] <camelia> rakudo-moar 3699aa: OUTPUT«No such method 'foo' for invocant of type 'Any'␤  in method reify at src/gen/m-CORE.setting:7563␤  in method reify at src/gen/m-CORE.setting:7426␤  in method gimme at src/gen/m-CORE.setting:7878␤  in method sink at src/gen/m-CORE.setting:8281␤  i…»

[13:12] <camelia> ..rakudo-jvm 3699aa: OUTPUT«No such method 'foo' for invocant of type 'Any'␤  in method reify at gen/jvm/CORE.setting:7506␤  in method reify at gen/jvm/CORE.setting:7369␤  in method gimme at gen/jvm/CORE.setting:7821␤  in method sink at gen/jvm/CORE.setting:8224␤  in block  …»

[13:12] <camelia> ..rakudo-parrot 3699aa: OUTPUT«No such method 'foo' for invocant of type 'Any'␤  in block  at /tmp/tmpfile:1␤␤»

[13:12] <Ven> Perl6++

[13:12] <Ven> Although I don't remember reading about it :/. Just found it in Junction.pm

[13:19] <Ven> m: for ^1e5 { []; }; say "alive";

[13:19] <camelia> rakudo-moar 3699aa: OUTPUT«(timeout)»

[13:19] *** daniel-s_ joined
[13:19] *** SamuraiJack left
[13:20] <Ven> r: role A[::T]; role B[::T]; role C[::T] does A[T] does B[T]; say "alive";

[13:21] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Too late for semicolon form of role definition␤at /tmp/tmpfile:1␤------> role A[::T]; role B[::T]; ⏏role C[::T] does A[T] does…»

[13:21] <Ven> r: role A[::T] {}; role B[::T] {}; role C[::T] does A[T] does B[T] {}; say "alive";

[13:21] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«alive␤»

[13:21] *** AW3i left
[13:21] *** prevost joined
[13:21] <Ven> r: https://raw.githubusercontent.com/Nami-Doc/Typeclassopedia.pl6/master/lib/Typeclassopedia.pm6

[13:21] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Two terms in a row␤at /tmp/tmpfile:1␤------> https⏏://raw.githubusercontent.com/Nami-Doc/Ty␤    expecting any of:␤    …»

[13:22] <Ven> r: https://gist.github.com/Nami-Doc/c6161cc3b29a1a417b9f

[13:22] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[13:22] <Ven> bu-but

[13:22] <Ven> r: role A[::T] {}; role B[::T] {}; role C[::T] does A[T] does B[T] {}; role D[::T] does C[T] {}; say "alive";

[13:23] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«alive␤»

[13:23] <Ven> r: role A[::T] {}; role B[::T] {}; role C[::T] does A[T] does B[T] {}; role D[::T] does C[T] does X[T] {}; role X[::T] {}; say "alive";

[13:23] <camelia> rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Cannot find method 'parameterize'␤»

[13:23] <camelia> ..rakudo-parrot 3699aa, rakudo-jvm 3699aa: OUTPUT«===SORRY!===␤No such method 'parameterize' for invocant of type 'Perl6::Metamodel::PackageHOW'␤»

[13:24] <Ven> r: role A[::T] {}; role B[::T] {}; role C[::T] does A[T] does B[T] {}; role D[::T] {}; role E[::T] does C[T] does D[T] {}; say "alive";

[13:24] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«alive␤»

[13:24] *** rurban1 joined
[13:25] <Ven> I don't understand why my gist won't do.

[13:25] <Ven> r: role Functor[::T] { };  role Apply[::T] { };  role Semigroup[::T] { }; Comonad[::T] does Functor[T] { };  role Applicative[::T] does Functor[T] does Apply[T] { };  role Monoid[::T] does Semigroup[T] { };  role Category[::T] { }; say "alive";

[13:26] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[13:26] <Ven> r: role Functor[::T] { };  role Apply[::T] { };  role Semigroup[::T] { }; Comonad[::T] does Functor[T] { };  role Applicative[::T] { };  role Monoid[::T] does Semigroup[T] { };  role Category[::T] { }; say "alive";

[13:26] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[13:28] <Ven> r: role Functor[::T] { };  role Apply[::T] { };  role Semigroup[::T] { }; Comonad[::T] does Functor[T] { };  role Applicative[::T] { }; say "alive";

[13:28] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[13:28] <Ven> oh my god, I'm so damn blind.

[13:29] <Ven> r: role Functor[::T] { };  role Apply[::T] { };  role Semigroup[::T] { }; role Comonad[::T] does Functor[T] { };  role Applicative[::T] { }; say "alive";

[13:29] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«alive␤»

[13:29] *** rurban1 left
[13:29] <Ulti> o___O

[13:29] *** PZt left
[13:30] <Ven> and so ...

[13:30] <Ven> r: https://gist.github.com/Nami-Doc/c6161cc3b29a1a417b9f

[13:30] <camelia> rakudo-parrot 3699aa: OUTPUT«Could not instantiate role 'ArrowLoop':␤Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'specialize' pc 22132 (src/gen/perl6-metamodel.pir:10426) (gen/parrot/Metamodel.nqp:2102)␤called from Sub '' pc 27863 (src/gen/per…»

[13:30] <camelia> ..rakudo-jvm 3699aa: OUTPUT«Unhandled exception: Could not instantiate role 'ArrowLoop':␤Not enough positional parameters passed; got 1 but expected 2␤  in specialize (gen/jvm/Metamodel.nqp:2025)␤  in  (gen/jvm/Metamodel.nqp:2465)␤  in  (gen/jvm/Metamodel.nqp:2461)␤  in comp…»

[13:30] <camelia> ..rakudo-moar 3699aa: OUTPUT«Unhandled exception: Could not instantiate role 'ArrowLoop':␤Not enough positional parameters passed; got 1 but expected 2␤   at <unknown>:1  (/home/p6eval/rakudo-inst-1/languages/nqp/lib/Perl6/Metamodel.moarvm:specialize:4294967295)␤ from src/gen/m-…»

[13:31] <Ven> wait, what ?

[13:32] <Ven> r: role Category[::T] { }; role Arrow[::T] does Category[T] { }; role ArrowLoop[::T] does Arrow[T] { }; say "alive";

[13:32] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«alive␤»

[13:32] *** bluescreen10 joined
[13:32] <Ulti> Ven can you give some commentary on what you're upto?

[13:33] <Ulti> for us lesser mortals ;P

[13:33] <Ven> r: I'm trying to get role for that hierarchy http://www.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png

[13:33] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Unable to parse role definition␤at /tmp/tmpfile:1␤------> I'm trying to get role for ⏏that hierarchy http://www.haskell.org/wi…»

[13:33] <Ven> Ulti: ^^

[13:34] <Ulti> okedoke :S

[13:35] <Ven> but rakudo gives me an error on the last line and I can't quite understand why.

[13:39] *** rurban1 joined
[13:40] <PerlJam> Ven: looks like a bug to me.

[13:40] <PerlJam> Ven: are you getting "Could not instantiate role 'ArrowLoop'" ?

[13:41] <Ven> PerlJam: that's what camelio seems to tell me

[13:42] <Ven> PerlJam: that's what camelia seems to tell me # whoops

[13:42] *** dayangkun joined
[13:42] <PerlJam> Ven: put any statement after that last role.  Just a 1; will do.

[13:42] <Ven> r: https://gist.github.com/Nami-Doc/c6161cc3b29a1a417b9f

[13:43] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: ( no output )

[13:43] <Ven> Oh, alright...

[13:43] <Ulti> try a blank line...

[13:43] <Ven> r: role A[::T] {}

[13:43] <camelia> rakudo-parrot 3699aa: OUTPUT«Could not instantiate role 'A':␤Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'specialize' pc 22132 (src/gen/perl6-metamodel.pir:10426) (gen/parrot/Metamodel.nqp:2102)␤called from Sub '' pc 27863 (src/gen/perl6-metam…»

[13:43] <camelia> ..rakudo-moar 3699aa: OUTPUT«Unhandled exception: Could not instantiate role 'A':␤Not enough positional parameters passed; got 1 but expected 2␤   at <unknown>:1  (/home/p6eval/rakudo-inst-1/languages/nqp/lib/Perl6/Metamodel.moarvm:specialize:4294967295)␤ from src/gen/m-Metamode…»

[13:43] <camelia> ..rakudo-jvm 3699aa: OUTPUT«Unhandled exception: Could not instantiate role 'A':␤Not enough positional parameters passed; got 1 but expected 2␤  in specialize (gen/jvm/Metamodel.nqp:2025)␤  in  (gen/jvm/Metamodel.nqp:2465)␤  in  (gen/jvm/Metamodel.nqp:2461)␤  in compose (gen…»

[13:44] <Ven> r: role A[::T] {};

[13:44] <camelia> rakudo-parrot 3699aa: OUTPUT«Could not instantiate role 'A':␤Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'specialize' pc 22132 (src/gen/perl6-metamodel.pir:10426) (gen/parrot/Metamodel.nqp:2102)␤called from Sub '' pc 27863 (src/gen/perl6-metam…»

[13:44] <camelia> ..rakudo-moar 3699aa: OUTPUT«Unhandled exception: Could not instantiate role 'A':␤Not enough positional parameters passed; got 1 but expected 2␤   at <unknown>:1  (/home/p6eval/rakudo-inst-1/languages/nqp/lib/Perl6/Metamodel.moarvm:specialize:4294967295)␤ from src/gen/m-Metamode…»

[13:44] <camelia> ..rakudo-jvm 3699aa: OUTPUT«Unhandled exception: Could not instantiate role 'A':␤Not enough positional parameters passed; got 1 but expected 2␤  in specialize (gen/jvm/Metamodel.nqp:2025)␤  in  (gen/jvm/Metamodel.nqp:2465)␤  in  (gen/jvm/Metamodel.nqp:2461)␤  in compose (gen…»

[13:44] <Ven> Just trying to "display" it

[13:44] *** water joined
[13:44] *** hoverboard joined
[13:45] <PerlJam> At a guess, it's running afoul of trying to return the value of the last statement executed and for some reason rakudo thinks that means pun the role and instantiate it.

[13:45] <Ven> Definitely

[13:47] *** skids joined
[13:51] <Ven> Only thing that's pretty surprising is this

[13:51] <Ven> r: role A[::T] {}; does B[::T] does A[T]; 1;

[13:51] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[13:52] <Ven> I'd expect the "does does" to error or something

[13:52] <JimmyZ> std: role A[::T] {}; does B[::T] does A[T]; 1;

[13:52] <camelia> std 09dda5b: OUTPUT«===SORRY!===␤Undeclared names:␤   'B' used at line 1␤     'T' used at line 1␤Undeclared routine:␤ 'does' used at line 1␤Check failed␤FAILED 00:01 130m␤»

[13:52] <JimmyZ> n: role A[::T] {}; does B[::T] does A[T]; 1;

[13:52] <camelia> niecza v24-109-g48a8de3: OUTPUT«===SORRY!===␤␤GLOBAL::T does not name any package at /tmp/3REaJTHwMV line 1:␤------> role A[::T⏏] {}; does B[::T] does A[T]; 1;␤␤A type must be provided at /tmp/3REaJTHwMV line 1:␤------> role A[…»

[13:53] *** daniel-s_ left
[13:53] *** jnap joined
[13:56] *** virtualsue joined
[13:57] *** water left
[13:58] <PerlJam> Ven: I dunno.   you can say «$some-val does Foo;» and you used to be able to say «class Alpha { does Foo; ... }»   maybe it's some sort of left-over syntax

[13:59] <PerlJam> (I actually don't know if the «also» operator is implemented or not, so maybe you can still do the latter)

[14:00] <Ven> PerlJam: yeah, `blah does Foo` makes sense if `blah` exists

[14:01] <Ven> r: role B {}; class A { also does B };

[14:01] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: ( no output )

[14:02] <Ven> r: class A { if True { method foo() { say "alive"; } } }; A.new.foo

[14:02] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«alive␤»

[14:03] <Ven> r: class A { if False { method foo() { say "alive"; } } }; A.new.foo

[14:03] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«alive␤»

[14:03] <Ven> That

[14:03] <Ven> 's not new under the sun, although I'm not that fond of it, but, going on ...

[14:03] <Ven> r: class A { if False { my $a = 5; method foo() { say "alive" ~ $a; } } }; A.new.foo

[14:03] <camelia> rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«use of uninitialized value of type Any in string context␤alive␤»

[14:03] <camelia> ..rakudo-parrot 3699aa: OUTPUT«use of uninitialized value of type Any in string context  in method foo at /tmp/tmpfile:1␤␤alive␤»

[14:03] <Ven> r: class A { if False { my $a = 5; method foo() { say "alive" ~ $a; } } else { my $a = 6; } }; A.new.foo

[14:03] <camelia> rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«use of uninitialized value of type Any in string context␤alive␤»

[14:03] <camelia> ..rakudo-parrot 3699aa: OUTPUT«use of uninitialized value of type Any in string context  in method foo at /tmp/tmpfile:1␤␤alive␤»

[14:04] <PerlJam> Those are for future Perl 6 obfuscated code contests :)

[14:04] *** [Sno] left
[14:04] <Ven> masak already blogged about this, I believe ...

[14:05] *** [Sno] joined
[14:09] *** thou joined
[14:11] <masak> you're referring to the fourth bullet point of http://strangelyconsistent.org/blog/lexpads-and-why-roles-need-fixups

[14:13] <Ven>  Yep.

[14:14] *** logie joined
[14:15] <Ven> I'd really like this `class { sub { method foo {} } }` stuff getting fixed, looks bad from outside. But we already talked about that.

[14:15] <masak> "getting fixed"? is it still your perception that something is broken in that area?

[14:16] <masak> to me, it's a complete DIHWIDT.

[14:16] <masak> aka "with great hammers comes great thumb-hurt... if you intentionally aim for the thumb".

[14:16] <Ven> masak: to me, it just shows the underlying problem. It's one example of the issue

[14:16] <masak> "the issue"?

[14:16] <Ven> I shouldn't be allowed to shoot myself in the foot

[14:17] <PerlJam> Ven: Perl is not about that.

[14:17] <xfix> This is impossible.

[14:17] <masak> Ven: we mostly don't roll like that.

[14:17] <masak> Ven: Perl 6 gives you enough rope to shoot yourself in the foot.

[14:17] <Ven> masak: not that way.

[14:17] <tadzik> I have no idea what you mean :D

[14:17] <[Coke]> masak: perhaps "to hang yourself by your ankle"?

[14:17] <tadzik> what do you want it to do?

[14:17] <[Coke]> (though I know you did that on porpoise.)

[14:18] <xfix> Perhaps it would be harder to shoot yourself in the foot, but when you do, it would hurt more.

[14:18] <masak> m: class C { method foo { my $x = 42; method bar { say $x } } }; C.bar

[14:18] <camelia> rakudo-moar 3699aa: OUTPUT«(Any)␤»

[14:18] <masak> tadzik: we're talking about ^

[14:18] <Ven> in some languages, I think about ruby, class bodies are executable, so you can actually use `if` to define methods conditionally

[14:18] <tadzik> masak: ah

[14:18] <tadzik> oh please no

[14:18] <tadzik> let's not have this kind of stuff

[14:18] <masak> "this kind of stuff"?

[14:18] <PerlJam> heh

[14:18] <tadzik> conditional methods

[14:19] <Ven> I'm not judging it. I'm saying, it works in Ruby. It parses in perl6, but doesn't do what you think it does.

[14:19] <PerlJam> we already have conditional methods ... just use EVAL

[14:19] <tadzik> I mean, you can do that if you really want to

[14:19] <tadzik> but, no

[14:19] <masak> tadzik: right.

[14:19] *** kaleem left
[14:19] <FROGGS> we have multis, that is pretty much one would need, no?

[14:20] <FROGGS> (and roles)

[14:20] <masak> Ven: if it doesn't do what you think it does, it's because you haven't grok'd the underlying model yet.

[14:20] <Ven> Something that can "Never Do What You Mean" should error out. Not warning (like certain languages like to do ... Only warn on stuff that can never be right ...)

[14:20] <PerlJam> Ven: There's always at least 2 choices.   Perl 6 choose to change what you think

[14:20] <masak> Ven: we don't arbitrarily disallow corner cases we don't like.

[14:20] <masak> Ven: we tried doing that a few times, and we were always surprised by people's use cases.

[14:20] <masak> Ven: we've *had* this discussion at least once.

[14:20] <Ven> We did.

[14:21] <masak> good. I refer you to the backlog. :)

[14:21] <Ven> and that conversation ended with a DIHWIDT.

[14:21] <masak> right.

[14:21] <masak> Ven: to make it clear, you're not even fighting language design here, you're fighting community design.

[14:22] <Ven> I'm fine with having that opinion different, really.

[14:22] <Ven> To me, that's something that can never mean what you think it means, and that's why I think it's bad

[14:22] *** fhelmberger left
[14:23] <PerlJam> Ven: as an aside, once Perl 6 is fully formed, you should be able to write a module that can "correct" these things

[14:23] <Ven> Yes, we talked about that too. "use strict"-like. Not really what I like

[14:24] <moritz> Ven: maybe you'd be more at home in a statically, strictly checked language?

[14:24] <tadzik> yeah

[14:24] <moritz> like ocaml, haskell, the like?

[14:24] <Ven> I am mostly doing haskell, so yeah.

[14:24] <jnthn> Ven: If you realize that declarations are compile time, and that method is a declaration, things get a lot less surprising.

[14:24] *** btyler joined
[14:25] <Ven> I really don't like ocaml, but that's a matter of taste :).

[14:25] <PerlJam> .oO( tastes like chicken? )

[14:25] * moritz hasn't really tried it, just meant it as an example for a strongly checked language

[14:25] <jnthn> .oO( tastes like camel? )

[14:26] <Ven> (actually, I mostly do Scala because I'm not start enough :p)

[14:27] <masak> jnthn: yeah, I suspect this is a matter of Ven's mind not having converged fully with Perl 6's parsing/runtime model.

[14:28] <Ven> No, really not. I understand what's runtime and what's compile-time. Not my point.

[14:29] <masak> I'm sure you understand the distinction, yes.

[14:29] <Ven> My point is, if it doesn't mean what it looks like it means, why doesn't it error out ?

[14:29] <masak> because we don't believe in punishing programmers for using the language creatively.

[14:30] <Ven> "use uncreative"

[14:30] <masak> we believe if we did that, we'd have a poorer language for it.

[14:30] <jnthn> Ven: If you know the language you're reading, it doesn't look like it means something else :P

[14:30] <Ven> I'd like that claim to be backed by an example of a case where it's useful, obviously

[14:30] *** virtualsue left
[14:31] <Ven> it's like, in scala, you can't pattern match on type members (because the JVM does type erasure). It never does what you think it means. Do you think it'd refuse to compile ? no, it merely prints a warning

[14:31] <PerlJam> Ven: Perl can't predict what's in people's heads.

[14:31] <Ven> Can't it ;)

[14:31] <jnthn> Ven: Useful if you want to group together various methods that will share some lexical state, without leaking it to other methods.

[14:32] *** elijah joined
[14:32] <Ven> m: class C { method foo { my $x = 42; method bar { say $x } } }; C.bar

[14:32] <camelia> rakudo-moar 3699aa: OUTPUT«(Any)␤»

[14:32] <Ven> jnthn: ^^ that doesn't seem broken to you ?

[14:32] <jnthn> Ven: No.

[14:32] <moritz> m: class C { method foo { my $x = 42; method bar { say $x } } }; C.foo; C.bar

[14:32] <camelia> rakudo-moar 3699aa: OUTPUT«42␤»

[14:33] *** rurban1 left
[14:33] <jnthn> Ven: It's doing exactly what I'd expect if you put a sub in a sub and call the inner one first.

[14:33] <PerlJam> Ven: sounds like a P6lint is what you want (But don't *really* want because it's a tool outside of the normal compile)

[14:33] <FROGGS> jnthn: I think I've fixed it O.o

[14:33] <PerlJam> er, compiler

[14:33] <jnthn> FROGGS: ooh! :)

[14:34] <Ven> r: sub a { sub b { say 'alive'; } }; b();

[14:34] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Undeclared routine:␤    b used at line 1␤␤»

[14:35] <Ven> Because subs are lexically scoped. Which makes it sane.

[14:35] <Ven> You can't have access to b without running through a first. 

[14:35] <moritz> you can do the same with subs

[14:35] <moritz> m: sub a { our sub b { say 'alive' } }; b()

[14:35] <camelia> rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/MmA26fjPr_␤Undeclared routine:␤    b used at line 1␤␤»

[14:35] <jnthn> sub a { our sub b { say 'alive'; } }; GLOBAL::b();

[14:35] <jnthn> r: ub a { our sub b { say 'alive'; } }; GLOBAL::b();

[14:35] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Undeclared routines:␤    a used at line 1␤    ub used at line 1. Did you mean 'uc'?␤␤»

[14:35] <moritz> m: module Blub;  sub a { our sub b { say 'alive' } }; Blubb::b

[14:35] <camelia> rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Could not find symbol '&b'␤»

[14:36] <moritz> m: module Blub;  sub a { our sub b { say 'alive' } }; Blub::b

[14:36] <camelia> rakudo-moar 3699aa: OUTPUT«alive␤»

[14:36] <jnthn> Right.

[14:36] <moritz> it helps to not misspell the package name :-)

[14:36] <jnthn> :)

[14:37] <Ven> *doesn't like it*

[14:37] <FROGGS> jnthn: one good thing is that I understand the problem, so I'll be able to write a good commit message this time :o)

[14:38] <jnthn> m: class C { method logging($on) { method log($msg) { say $msg if $on } } }; C.log('omg'); C.logging(1); C.log('wtf');

[14:38] <camelia> rakudo-moar 3699aa: OUTPUT«wtf␤»

[14:38] *** prevost left
[14:39] <jnthn> FROGGS: yay

[14:39] <Ven> that's a nice example.

[14:40] <PerlJam> nice enough that we won't have t his discussion again? ;)

[14:40] <Ven> I guess it'd probably do it with a `has` usually, though, but it's a good examp;e

[14:40] <Ven> PerlJam: am I that unpleasant to talk with :p ?

[14:41] <jnthn> You can do it with a has too, but that doesn't cover you if you wanted to have a way to disable the logging accross all instances, for example :)

[14:41] <PerlJam> Ven: nah, it's just tiresome to rehash the same topic with neither side budging  :)

[14:41] <Ven> then a `our`

[14:41] <Ven> PerlJam: I'm budging !

[14:41] *** virtualsue joined
[14:42] *** kaare_ left
[14:42] <FROGGS> nwc10++ # lightning talk in german *g*

[14:42] <Ven> I asked for an example, jnthn gave me a cool example, I'm not 100% convinced **with that example** but it means it can be useful. So yeah, I won't rehash that topic

[14:43] <jnthn> Ven: Right, you could. My point is just that my way let me restrict state to a much narrower scope, which tends to be a positive thing.

[14:43] <Ven> so, it was nice having that discussion, cause I budged :p.

[14:43] <jnthn> FROGGS: Nice! :) 

[14:44] <jnthn> FROGGS: Good job it wasn't me, I learned all my German from food menus and Rammstein... :P

[14:44] <FROGGS> >.<

[14:44] <Ven> "we're all living in america" # trust me I speak german

[14:44] <FROGGS> menus++, rammstein--

[14:45] <jnthn> FROGGS: We're all teenagers once. :)

[14:45] <FROGGS> I was born as an adult :o)

[14:46] <Ven> as somebody in class right now, I concur :D

[14:46] <Ven> (or is it "someome" ? I can't english :/)

[14:46] <FROGGS> bbl, need a charger...

[14:46] *** FROGGS left
[14:46] <[Coke]> jnthn: what, no Eisbrecher?

[14:46] <[Coke]> ... dammit, now that's stuck in my head.

[14:47] <jnthn> [Coke]: 'fraid not...is it worth checking out? :)

[14:47] <moritz> Ven: afaict "someone" and "somebody" are interchangable

[14:48] *** xenoterracide joined
[14:48] * jnthn really should get on wiht $dayjob slides, so later on he can get on with parallel GC moarbug...

[14:48] *** rurban1 joined
[14:49] *** hoverboard left
[14:50] <Ven> moritz++ # ty

[14:52] <masak> someone should write up jnthn++'s example (and the discussion that preceded it) as a blog post.

[14:54] <Ven> Yes, definitely. Even better than backlog ;o)

[14:57] <masak> ok, #perl6. getting on a plane to .cn now -- for the next few weeks, I'll have a time zone of GMT+8.

[14:57] <masak> I think I'll be pretty present, maybe even active, on #perl6.

[14:58] <moritz> masak: visiting TimToady in Beijing? :-)

[14:58] *** hoverboard joined
[14:58] <masak> no, we'll be in different cities :)

[14:59] <PerlJam> masak: have a good trip

[15:01] <japhb> Have a good trip, masak!

[15:01] <yoleaux> 13 Mar 2014 07:54Z <jnthn> japhb: the time related bits, debugging the parallel GC (yay fun :P) and then a whole bunch of safety/hardening.

[15:02] <jnthn> Dammit, 2 weeks after I wrote that I'm still working on all of those...

[15:03] *** kurahaupo joined
[15:11] *** treehug88 joined
[15:15] *** [Sno] left
[15:17] *** hoverboard left
[15:18] *** virtualsue left
[15:21] <dalek> roast: 8f2dcae | moritz++ | S32-str/uc.t:

[15:21] <dalek> roast: fudge case folding test involving ß

[15:21] <dalek> roast: 

[15:21] <dalek> roast: there is already a ticket open for that (RT #121377)

[15:21] <dalek> roast: review: https://github.com/perl6/roast/commit/8f2dcae885

[15:21] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=121377

[15:24] <moritz> where can I find some information about Unicode case folding of ß for https://rt.perl.org/Ticket/Display.html?id=121377 ?

[15:26] <dalek> roast: 32c006f | moritz++ | S32-str/tclc.t:

[15:26] <dalek> roast: moar-fudge another Unicode bug

[15:26] <dalek> roast: review: https://github.com/perl6/roast/commit/32c006fbf3

[15:27] *** raiph joined
[15:34] <Ulti> regarding letting programmers do what they want I still think there should probably be some sort of explosion when I keep attempting to do something dumb like my $k = 3; say 1,$k...10; or even where $k is a literal 3 and its super obvious it will always be a bad plan

[15:34] * Ulti is super dumb when it comes to Perl6

[15:34] <jnthn> m: my $k = 3; say 1,$k...10;

[15:35] <camelia> rakudo-moar 3699aa: OUTPUT«(timeout)»

[15:35] *** Rotwang joined
[15:35] <moritz> Ulti: the problem with this one is that series are much more complex than they look a the surface

[15:35] <Ven> how old is moarvm ?

[15:35] <jnthn> Young. :)

[15:36] <Ulti> moritz: yeah I agree it could be something there is no ability to statically look at

[15:36] <jnthn> Ulti: The other thing is that if we put safety checks in all over, they slow down all the correct code. :)

[15:36] <Ven> "when did Charmelogne die ?" "Between 150 before J.C and 2011". I didn't get any point at that question, sadly.

[15:36] <Ulti> but its problematic that its very easy to accidentally do something that just eats all memory before exiting

[15:36] *** dmol left
[15:36] <jnthn> Ven: It's less than a year since the project became public knowledge.

[15:37] <Ulti> what I would prefer is if I could say the last number is an upper bound with an adverb or something

[15:37] <Ven> jnthn++: really impressive work then :)

[15:37] <jnthn> Ulti: Just write an inequality at the end. With * closure notation it's less code than an adverb would be.

[15:37] <Ulti> k

[15:37] <Ven> m: my $k = 3; say 1,$k... * > 10;

[15:37] <camelia> rakudo-moar 3699aa: OUTPUT«1 3 5 7 9 11␤»

[15:37] <jnthn> Ven: It was developed privately for a bit before that. :)

[15:37] <Ven> m: my $k = 3; say 1,$k...^  * > 10; # probably

[15:38] <camelia> rakudo-moar 3699aa: OUTPUT«1 3 5 7 9␤»

[15:38] <Ven> jnthn: yeah, I got that part -- doesn't make it less good

[15:38] <Ven> I'd love to get niecza back up if I had any knowledge of the CLR

[15:38] <jnthn> Yeah, it's come quite a long way in a short time. But the best is yet to come. :)

[15:40] <Ven> It's all about time

[15:40] <Ulti> maybe I can make a module for Icon syntax for sequences, which is what I really want anyway ;P

[15:40] <Ulti> @list = 1 to 10 by 3;

[15:41] <moritz> Ulti: the ... is implemented in the setting, all in bog-standard Perl 6 :-)

[15:41] *** kivutar joined
[15:41] <Ulti> I'll take a look and play then

[15:41] <timotimo> the only special thing about it is that the grammar emits a call to SEQUENCE when it finds a ...

[15:42] <timotimo> you *should* be able to lexically override SEQUENCE, though

[15:42] <Ulti> I made a gross Perl5 sub for doing it previously

[15:43] <Ven> r: class MyRange { has $.from; has $.to; has $.step = 1; method list { loop (my int $i = $.from; $i < $.to; $i += $.step;) $i; } }; say MyRange(:from(1), :to(5)).list.perl;

[15:43] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Missing block␤at /tmp/tmpfile:1␤------> int $i = $.from; $i < $.to; $i += $.step⏏;) $i; } }; say MyRange(:from(1), :to(5)…»

[15:43] <Ven> r: class MyRange { has $.from; has $.to; has $.step = 1; method list { loop (my $i = $.from; $i < $.to; $i += $.step) $i; } }; say MyRange(:from(1), :to(5)).list.perl;

[15:43] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Missing block␤at /tmp/tmpfile:1␤------> y $i = $.from; $i < $.to; $i += $.step) ⏏$i; } }; say MyRange(:from(1), :to(5)).l…»

[15:43] <jnthn> m: sub infix:<to>($a, $b) { $a..$b }; sub infix:<by>(Range $a, $b) { $a.min, $a.min + $b ...^ * > $a.max }; say 1 to 10 by 3

[15:43] <camelia> rakudo-moar 3699aa: OUTPUT«1 4 7 10␤»

[15:43] <jnthn> Ulti: Have a happy :)

[15:44] * Ven iss trying to do complicated stuff for no reason

[15:44] <jnthn> It's always easy to do something complicated... :)

[15:44] <moritz> Ven: you need curlies after the loop head

[15:44] <Ven> yeah I understood that

[15:44] <Ven> not the least bit as elegant tho.

[15:45] <Ulti> \o/

[15:45] <moritz> jnthn++

[15:45] <Ulti> now it just needs to be core..... >:3

[15:45] <Ven> jnthn++

[15:45] <Ulti> jnthn++

[15:46] *** PZt joined
[15:46] <Ulti> someone needs to implement karma, my P6 emobot is maybe a good candidate

[15:46] <Ulti> that really is cool

[15:46] <moritz> Ulti: I can give you a dump of the IRC logs if you want to retroactively parse the karma

[15:46] <Ven> No please :(

[15:46] <jnthn> .oO( Emobot? When'll he cut a release... )

[15:47] <Ven> Any form of "karma" or "points" often leads to people just fishing for them :(

[15:47] <moritz> Ulti: also, #git uses not just ++ for karma, but also "thanks you", "thanks", "thx" etc.

[15:47] <Ulti> ? emobot lives inside Text::Emotion which is already released ;P

[15:47] <jnthn> Ven-- # complaining :P

[15:47] <Ven> *sob*

[15:47] <moritz> which I find a really nice idea

[15:47] <Ven> Ulti: I think it was a joke with "emo"

[15:47] <Ulti> moritz: yeah that's a good plan

[15:47] <jnthn> aye :)

[15:47] <Ulti> also <<nick>> awesome!

[15:47] <jnthn> Ulti: I should take a look at it...

[15:48] <Ulti> only if you like looking at bad Perl6 code

[15:48] <jnthn> Ulti: I did an Rx example in my .Net course recently where I was doing sentiment analysis on the Twitter live stream.

[15:48] <Ulti> the score is also trivial, needs parts of speech to be better though which is hard

[15:48] <Ven> Perl.rx 

[15:48] <Ulti> jnthn: cool, the data I use is based on Tweets

[15:48] <jnthn> Ulti: And thought it'd be cool to do a Perl 6 port of that uses supplies :)

[15:48] <Ulti> so the vocab has LULZ and stuff

[15:49] <moritz> please include irony detection

[15:49] <moritz> that would be so great!

[15:49] <jnthn> moritz: That'll be easy!

[15:49] <Ulti> jnthn I'd like to see it, both because I'm interested in that topic and I want to see more examples of using supplies

[15:49] <jnthn> Ulti: Yeah. The funniest thing that has happened so far is one guy hacked my demo by tweeting something on the topic I was currently watching/analysing :)

[15:49] <Ulti> :D

[15:49] <jnthn> And since it was the live stream it showed up on the projector within seconds. :D

[15:50] <Ulti> lol

[15:50] <Ulti> trolling finds a way like life

[15:50] <Ulti> maybe I should do all my lecturing from a shared google doc

[15:50] *** hoverboard joined
[15:51] <jnthn> I pointed out after the talk that there's 3 levels of "bad idea": doing a live demo, doing a live demo involving a network, and doing a live demo involving a network and data you've no control over. :)

[15:51] <Ulti> jnth that's a lesson most politicians haven't learnt when they launch websites with live twitter feeds

[15:52] <jnthn> On supplies and taps, though, I have submitted a talk on reactive programming in Perl 6 to 3 workshops. So, I shoudl build some nice thingsby then :)

[15:52] <Ulti> my first ever tweet did JS injection into a tory website replacing the whole site with a giant picture of a cat

[15:52] <jnthn> :D

[15:53] <Ven> Ulti++ # "Mom, let's get a cat for christmas"

[15:53] <Ulti> jnthn are your slides available? or do I have to pay $dayjob to see them?

[15:53] <dalek> roast: 8b6a051 | moritz++ | S32-str/ (2 files):

[15:53] <dalek> roast: fudge some moar tests which already have tickets

[15:53] <dalek> roast: review: https://github.com/perl6/roast/commit/8b6a051d4d

[15:53] <jnthn> Ulti: For the reactive .Net talk? Hmm.

[15:53] <Ulti> also the picture of a cat might have been goatse... I dont recall :3

[15:54] <jnthn> https://github.com/edumentab/rx-examples is the code

[15:54] *** kaare_ joined
[15:54] <Ulti> thats really all I wanted to grok :D

[15:54] <moritz> all you really wanted to grok was the cat picture on goatse?

[15:54] <Ulti> then I can finally make a magical parallel script with Utils regex conversion doodad

[15:54] <Ulti> Util++

[15:55] <Ulti> moritz: jnthn's code :P

[15:55] <raiph> moritz: search for SpecialCasing.txt in http://www.unicode.org/versions/Unicode6.2.0/ch04.pdf

[15:55] <Ulti> thanks jnthn I'll try and do something myself

[15:55] <Ulti> does the bleeding edge version of moar rakudo have these sorts of things?

[15:56] <moritz> raiph: thanks

[15:56] <jnthn> Ulti: No; work ongoing in moar-conc branches.

[15:57] <jnthn> Ulti: I'm working on getting things in shape; last night I discovered we've a problem somewhere with inter-generational roots interacting badly with threads.

[15:58] <jnthn> Ulti: Which is likely to blame for much of the trouble, but I won't know until I nail it.

[16:01] *** denis_boyun left
[16:01] <Ulti> jnthn cool I will keep an eye out, looks like I will be updating the JVM on this computer then :)

[16:02] *** effbiai joined
[16:03] <Ulti> so in general all of the Perl6 parallel stuff is going to be shared memory threading? rather than forking with IPC?

[16:04] <jnthn> Ulti: At a low level, yes, but just because it's a shared memory model doesn't imply that writing code in terms of threads and locks is the way to go.

[16:04] <Ulti> so is memory handled magically for you so long as you stick to Perl6 constructs? or are you going to run into problems with writing?

[16:04] <jnthn> Ulti: The expectation is the typical programmer will work in terms of promises, channels, supplies, etc.

[16:05] * Ulti is typical

[16:05] <Ulti> the last time I did anything with explict threads was in Java and it took me a good week to debug it

[16:05] * jnthn is also typical when it comes to building reliable systems that are multi-threaded :)

[16:05] *** Rotwang left
[16:05] <jnthn> Working directly with locks and threads is like programming assembly language: good to know you can if you must, but hardly ideal.

[16:06] <jnthn> Anyway, at a Perl 6 level, we will make sure you can't explode the VM.

[16:06] <jnthn> However, you can - like in all kinds of programming - get wrong answers.

[16:06] <jnthn> And the way to write answers is doing communication using the provided mechanisms.

[16:07] <jnthn> uh

[16:07] <jnthn> The way to write correct things

[16:07] <jnthn> oh, or to right answers

[16:07] <jnthn> brain fail :)

[16:08] <Ulti> I haven't actually ever done threading with higher level constructs

[16:08] <jnthn> Ah. :)

[16:08] <jnthn> It's nicer ;)

[16:09] <jnthn> Generally it's better to look at the problem and say, "which bits can happen concurrently". Then factor out those pieces. Then you have something suitable to parallelize.

[16:09] <Ulti> yeah like everything I'll just have to do it to get my mind around the new idea

[16:09] * jnthn should find time to write decent docs on this stuff at some point.

[16:09] <Ulti> well your presentations are available unless the syntax has changed loads since the summer

[16:10] <jnthn> The one I did at Nordic Perl Workshop in Nov is the most up to date.

[16:10] <jnthn> And I don't think loads changed since that.

[16:11] <Ulti> quite excited that the day has basically come for what I was waiting on Perl6 for :) it's feature complete for my use case! yay

[16:11] <Ulti> not that I ever used threads in perl5, I use GNU parallel to do everything at the process level

[16:11] <moritz> jnthn: I recently wrote a concurrent, recursive directory reader. My main problem was stopping the program in the end, ie figuring out when to close the channels

[16:12] <moritz> jnthn: https://gist.github.com/moritz/9293475 has the result

[16:12] <moritz> jnthn: any ideas on how to improve that?

[16:13] <moritz> that's lines 27 to 40

[16:13] <jnthn> $counter++ # well, there's a race conditon...

[16:15] <jnthn> moritz: Yeah, I probably can improve on it.

[16:15] <moritz> there is? it's called as callback($_) for $files.list;

[16:15] <moritz> that loooks like a serial iteration to me

[16:16] <timotimo> right, the reader is a separate thread that sucks the individual files out of a channel

[16:16] <jnthn> moritz: oh, you're right :)

[16:16] <jnthn> moritz: yeah, it's fine.

[16:16] <jnthn> I understood it when I got to the bottom :)

[16:17] <Ven> browsing #perl6 history from 2007, quite different names around

[16:18] *** FROGGS[mobile] left
[16:19] * Ven .oO(Perl6 on LLVM)

[16:21] * Ven .oO(au has red bold messages on archives ?)

[16:24] * Ven .oO(method calls used to use ` ?)

[16:24] * timotimo wouldn't know about that

[16:25] <moritz> Ven: I'm pretty sure they didn't

[16:26] <Ven> moritz: http://irclog.perlgeek.de/perl6/2005-12-24#i_-387340 that's why I'm surprised

[16:26] <timotimo> wow 2005

[16:26] <timotimo> i'm not sure pil is actually the same thing as perl6?

[16:27] * Ven couldn't tell

[16:27] * Ven is pretty deep in the rabbit's hole ...

[16:28] <timotimo> that could be some parrot thing actually

[16:28] <jnthn> PIL was Pugs IL, iirc

[16:28] <jnthn> But it's before my time really

[16:28] <timotimo> i wonder what'll be the state in another 10 years

[16:29] <Ven> and who'll be there

[16:30] <timotimo> wow, by that time i'll be *old*

[16:30] <timotimo> and perhaps wise

[16:30] *** [Sno] joined
[16:30] <Ven> I'd almost be 30 :(

[16:30] <timotimo> at least experienced - hopefully

[16:30] <Ven> I *will*, actually

[16:30] <timotimo> hopefully you will be :)

[16:30] <Ven> ugh.

[16:30] <moritz> Ven: looks like some intermediate language, not Perl 6 itself

[16:30] <moritz> oh, jnthn++ was faster

[16:31] <Ven> yeah, this explains that :). jnthn++ # moritz++, too

[16:35] *** FROGGS[mobile] joined
[16:43] *** zakharyas left
[16:48] *** iolympian1 joined
[16:48] *** iolympian1 left
[16:48] <raiph> Ven: do you know about the #perl6 "summary" (http://irclog.perlgeek.de/perl6/2014-03-28/summary) ?

[16:50] <Ven> raiph: oh, I was just wandering around ... Class topic is boring and I don't have anything installed on that computer

[16:52] <raiph> Ven: if you're wandering around the last year+ of #perl6 there's a "summary" that's typically about 10-20% of the lines in the full log

[16:52] <Ven> Once you've finished reading the p6advents and synopsis, there's not that much stuff on perl6 :p

[16:53] <moritz> well, there's 5-to-6, masak's blog

[16:53] <moritz> jnthn's blog

[16:53] <Ven> read, read, read.

[16:54] <moritz> the book draft/WIP

[16:54] <moritz> doc.perl6.org

[16:54] <Ven> read, read :p

[16:54] <moritz> faq.perl6.org (ok, that's short)

[16:54] <Ven> read. That list of links could probably be put up somewhere, though

[16:55] <moritz> like, on perl6.org?

[16:55] <moritz> I'm pretty sure it's all linked there

[16:55] <Ven> You tell me :).

[16:56] <moritz> (maybe not the blogs themselves, but the aggregators)

[16:56] <Ven> there is a "blogs" link, right

[16:57] <raiph> Ven: imo the best overall source is http://planeteria.org/perl6/; and the best of the best is http://jnthn.net, http://perlgeek.de/blog-en/perl-6/, http://strangelyconsistent.org/blog/list-of-posts, and http://doc.perl6.org

[16:57] *** denis_boyun joined
[16:57] <Ven> what is mildew ?

[16:58] <Ven> commute &

[16:58] <moritz> Ven: iirc it was a project by pmurias to take the STD.pm6 parse tree and generate code that would run on SMOP

[16:58] *** kaleem joined
[16:59] <moritz> (and SMOP is a C runtime for the Perl 6 object system, and iirc it inspired 6model and parts of the current MOP)

[16:59] <moritz> both mildew and smop seem to be inactive

[17:00] *** denis_boyun__ joined
[17:01] <jnthn> Yeah, SMOP was one of the 6model inspirations.

[17:02] *** denis_boyun left
[17:02] <jnthn> In some senses, MoarVM could be seen as partly a SMOP descendent, though not in terms of code.

[17:03] *** ajr_ left
[17:05] *** guru joined
[17:05] *** guru is now known as Guest36084

[17:05] *** Guest36084 is now known as ajr_

[17:06] *** kaleem left
[17:09] <japhb> descendent-in-spirit

[17:12] <jnthn> *nod*

[17:12] *** ajr_ left
[17:13] <raiph> jnthn: have you gotten the info you needed about linux equivs of YieldProcessor?

[17:15] *** xinming__ joined
[17:18] *** xinming_ left
[17:19] *** xinming__ left
[17:22] <dalek> roast: 611c2d5 | moritz++ | S32-num/power.t:

[17:22] <dalek> roast: moar-fudge tests with big exponentials

[17:22] <dalek> roast: review: https://github.com/perl6/roast/commit/611c2d56cb

[17:23] <[Coke]> jnthn: eisbrecher is pretty good to my non-german speaking ear. it's more ... club? techno?

[17:24] <moritz> m: say 241025348275725.3352

[17:24] <camelia> rakudo-moar 3699aa: OUTPUT«241025348275725.3352␤»

[17:25] <moritz> m: say 241025348275725.3352 eq '241025348275725.3352'

[17:25] <camelia> rakudo-moar 3699aa: OUTPUT«True␤»

[17:25] *** xinming_ joined
[17:25] <moritz> m: say 241025348275725.3352.Rat eq '241025348275725.3352'

[17:25] *** treehug8_ joined
[17:25] <camelia> rakudo-moar 3699aa: OUTPUT«True␤»

[17:25] <moritz> r: say 241025348275725.3352.Rat.norm.nude

[17:25] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«301281685344656669 1250␤»

[17:26] * PerlJam read Rat.norm.dude

[17:28] *** treehug88 left
[17:29] <jnthn> raiph: The answer, as I feared, seems to be "probe to see what's there" :)

[17:30] <moritz> r: use Test; plan 1; is 241025348275725.3352.Rat.norm.nude, (301281685344656669, 1250), "Rat.Rat yields correct Rat";

[17:30] <jnthn> raiph: But yeah, but some stuff to try.

[17:30] <camelia> rakudo-moar 3699aa: OUTPUT«1..1␤not ok 1 - Rat.Rat yields correct Rat␤#      got: '301281685344656669 1250'␤# expected: '301281685344656640 1250'␤# Looks like you failed 1 tests of 1␤»

[17:30] <camelia> ..rakudo-parrot 3699aa, rakudo-jvm 3699aa: OUTPUT«1..1␤ok 1 - Rat.Rat yields correct Rat␤»

[17:31] <moritz> why the bloody hell does 241025348275725.3352.Rat.norm.nude produce the same output on all backends, but in a test it fails?

[17:31] <moritz> ... on just one backend

[17:34] <jnthn> That's a wtf...

[17:40] *** Psyche^_ joined
[17:41] <moritz> r: say (301281685344656669, 1250).Str

[17:41] <camelia> rakudo-moar 3699aa: OUTPUT«301281685344656640 1250␤»

[17:41] <camelia> ..rakudo-parrot 3699aa, rakudo-jvm 3699aa: OUTPUT«301281685344656669 1250␤»

[17:41] <moritz> r: say 301281685344656669.Str

[17:41] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa: OUTPUT«301281685344656669␤»

[17:41] <camelia> ..rakudo-moar 3699aa: OUTPUT«301281685344656640␤»

[17:41] <moritz> r: say 301281685344656669

[17:41] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa: OUTPUT«301281685344656669␤»

[17:41] <camelia> ..rakudo-moar 3699aa: OUTPUT«301281685344656640␤»

[17:42] <moritz> golf'ed

[17:42] <japhb> r: say 301281685344656669.WHAT

[17:42] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«(Int)␤»

[17:42] <japhb> At least that's agreed upon ...

[17:43] <PerlJam> Works on my local version of perl6-m

[17:44] <moritz> This is perl6 version 2014.03.01-8-g3699aaf built on MoarVM version 2014.03-6-g572c043

[17:44] <PerlJam> This is perl6 version 2014.03.01-7-g68e0948 built on MoarVM version 2014.02-130-g20931e6 

[17:44] *** Psyche^ left
[17:44] <moritz> (on my local machine, where it also fails)

[17:45] <segomos> is there an equiv in p6 to p5's sub meth (&$)  ?

[17:45] <moritz> segomos: no, Perl 6 doesn't have prototypes

[17:45] <PerlJam> segomos: and you don't need them for warping the language.

[17:45] <PerlJam> (and signatures are way more useful)

[17:46] <moritz> m: sub twice(&callback, $value) { callback 2 * $value }; twice {say $^x }, 21

[17:46] <camelia> rakudo-moar 3699aa: OUTPUT«42␤»

[17:47] <segomos> PerlJam: i'm more trying to produce a 'map' like functionality in a scraper

[17:47] <PerlJam> segomos: see moritz :)

[17:47] <moritz> segomos: no need for a prototype in Perl 6, as demonstrated above

[17:47] *** ajr joined
[17:47] <segomos> that's exactly what i just did in my other screen too after you told me no protos :-)

[17:47] <segomos> thanks guys

[17:48] *** ajr is now known as Guest54002

[17:48] *** Guest54002 is now known as ajr_

[17:48] <dalek> roast: 2d56f60 | moritz++ | S32-num/rat.t:

[17:48] <dalek> roast: moar-fudge a test

[17:48] <dalek> roast: review: https://github.com/perl6/roast/commit/2d56f60d8a

[17:50] <moritz> r: say $*EXECUTABLE_NAME

[17:50] <camelia> rakudo-jvm 3699aa: OUTPUT«perl6-j␤»

[17:50] <camelia> ..rakudo-parrot 3699aa: OUTPUT«./rakudo-inst/bin/perl6-p␤»

[17:50] <camelia> ..rakudo-moar 3699aa: OUTPUT«perl6-m␤»

[17:50] *** rurban1 left
[17:50] <moritz> is there a bug open for that already?

[17:51] <moritz> r: say $*EXECUTABLE_NAME.^name

[17:51] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«Str␤»

[17:53] <moritz> ideally we'd have @*PERL_INVOKE which is a list of arguments that can be used to invoke the current Perl 6 compiler/interpreter

[17:53] <moritz> that's what we need in tests

[17:53] *** mls_ is now known as mls

[17:57] *** denisboyun joined
[17:58] *** benabik joined
[17:59] *** benabik left
[17:59] *** denis_boyun__ left
[17:59] *** benabik joined
[18:01] *** dakkar left
[18:02] <dalek> roast: 905aa8e | moritz++ | S32-list/roll.t:

[18:02] <dalek> roast: JVM- and Moar-fudge tests that rely on $*EXECUTABLE_NAME

[18:02] <dalek> roast: review: https://github.com/perl6/roast/commit/905aa8e824

[18:03] <moritz> somehow all of my perl6s barf on t/spec/S15-unicode-information/unimatch-general.t

[18:03] <moritz> parrot says Invalid character for UTF-8 encoding

[18:03] <moritz> JVM says Unrecognized character name AEGEAN NUMBER NINETY THOUSAND

[18:03] <moritz> moar says Invalid code-point U+00FDD0

[18:04] <moritz> git log says lue last touched it

[18:04] <moritz> lue: what did you do? :-)

[18:04] *** treehug8_ left
[18:05] *** denisboyun left
[18:05] <moritz> seems TimToady actually introduced U+FDD0

[18:05] <jnthn> moritz: I think it's HEAD Moar that is unhappy with it, but maybe not MOAR_REVISION one...

[18:05] *** hoverboard left
[18:06] <jnthn> moritz: There are tests elsewhere that fail due to this, I think in S05.

[18:06] <jnthn> moritz: And there are also tests on ord_and_chr.t that *want* such things to explode.

[18:06] *** treehug88 joined
[18:06] <jnthn> So, we can't win :)

[18:06] <jnthn> I don't think both sets of tests can be right :)

[18:06] *** denis_boyun_ joined
[18:08] *** hoverboard joined
[18:11] <moritz> we just need to parameterize behavior by input file name :-)

[18:13] *** vendethiel left
[18:16] *** vendethiel joined
[18:17] *** denis_boyun_ left
[18:18] *** vendethiel left
[18:18] *** denis_boyun_ joined
[18:18] *** vendethiel joined
[18:21] *** denis_boyun__ joined
[18:22] *** rurban1 joined
[18:22] *** denis_boyun_ left
[18:22] *** kurahaupo left
[18:23] *** Ven left
[18:24] *** punter joined
[18:24] *** kaare_ left
[18:24] *** kaare_ joined
[18:26] *** denis_boyun_ joined
[18:27] *** denis_boyun__ left
[18:27] <dalek> rakudo-star-daily: 30a819b | coke++ | log/ (5 files):

[18:27] <dalek> rakudo-star-daily: today (automated commit)

[18:27] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/30a819b7dd

[18:28] <dalek> perl6-roast-data: 8e33eb0 | coke++ | / (6 files):

[18:28] <dalek> perl6-roast-data: today (automated commit)

[18:28] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/8e33eb076b

[18:33] <[Coke]> we need to declare what version of unicode we're testing.

[18:33] <[Coke]> moritz++ 3 less failing rakudo.moar tests.

[18:34] *** AW3i joined
[18:40] *** sjn joined
[18:46] *** ssutch joined
[18:49] *** SamuraiJack joined
[18:53] *** denis_boyun__ joined
[18:55] *** denis_boyun_ left
[18:55] *** treehug88 left
[18:56] *** darutoko left
[18:56] *** treehug88 joined
[18:58] *** kurahaupo joined
[18:59] *** bluescreen100 joined
[19:03] *** bluescreen10 left
[19:03] *** virtualsue joined
[19:06] <hoelzro> I was thinking of sticking syntax-highlighting related stuff in a repo; should I create a syntax repo, or should we have a general "tooling" repo?

[19:06] <hoelzro> or does such a repo already exist?

[19:06] <moritz> hoelzro: misc stuff goes into the mu repo right now, but that's a bit big

[19:07] <moritz> hoelzro: if you want, I can create a perl6/tooling repo

[19:08] <hoelzro> ok

[19:08] <hoelzro> I just might do that

[19:08] <timotimo> rob!

[19:08] <hoelzro> o/ timo!

[19:09] <hoelzro> what's up?

[19:09] <timotimo> greetings

[19:10] <hoelzro> greetings are indeed up =)

[19:11] <jnthn> m: say uc 'greetings' # they are now!

[19:11] <camelia> rakudo-moar 3699aa: OUTPUT«GREETINGS␤»

[19:12] *** denis_boyun_ joined
[19:12] *** denis_boyun__ left
[19:14] <xybre> How is Moar coming along?

[19:14] *** IllvilJa left
[19:15] *** denis_boyun__ joined
[19:17] *** denis_boyun_ left
[19:18] *** rurban joined
[19:19] <PerlJam> xybre: spledidly?

[19:20] <xybre> PerlJam: Thats good enough for me I suppose :)

[19:21] <PerlJam> modulo the spelling error :)

[19:21] <PerlJam> xybre: I tend to use the moar-backed rakudo as my primary perl6 implementation.

[19:22] <lue> http://www.unicode.org/versions/corrigendum9.html    things that expect noncharacters to blow everything up are wrong. (unless I severely misunderstand that corrigendum)

[19:22] <PerlJam> occasionally, I'll use rakudo-jvm when I'm playing with supplies and channels and such 

[19:24] *** rurban left
[19:25] <xybre> PerlJam: ah, I thought it wasn't recommended due to some things being incomplete.

[19:25] <raiph> xybre: i'm curious about your interests, experience, hopes, knowledge of p6, other langs etc.

[19:25] *** denis_boyun_ joined
[19:26] *** denis_boyun__ left
[19:27] *** IllvilJa joined
[19:27] <xybre> raiph: I used perl over 10 years ago, didn't rememeber a lick of it. I found my usual languages to be annoying to write parsers in, so I started playing with Perl6. My main language is Ruby, and I've been getting involved in Rebol, writing my own language, and I've done some Ocaml, Self, Smalltalk, Clojure, and Haskell research lately.

[19:28] <PerlJam> nice

[19:28] <PerlJam> (you sound like one of the regulars already ;)

[19:28] <ssutch> one of us :)

[19:30] *** rurban1 left
[19:30] <lue> moritz, jnthn: the main point of noncharacters is that you have no clue what they'll do if passed to another library or program. You can still use them, but with a healthy dose of caution :) .

[19:30] <xybre> Haha, wow. Most people just look at me like I'm crazy. "was all that real what you just said"

[19:31] <raiph> xybre: i'd say that, compared to the langs you named, the main diffs are that p6 (lang, ecosystem, docs, etc.) is immature (especially that it's slooooow) and that it's been that way for 10 years longer than most folk can stomach

[19:31] *** xenoterracide left
[19:33] <xybre> raiph: Slowness isn't really a concern so long as it makes the job easier of building proof-of-concept parsers quickly and easily. I need to rapidly iterate on parsing and I'm not going to write a bunch of formal definitions to do it. I've already written a couple of parsers in Ruby, but Perl6 (and Rebol) have most of the stuff I had to hand-build (poorly) built in.

[19:35] *** treehug8_ joined
[19:35] *** xenoterracide joined
[19:35] <ssutch> a parser (for the protocol buffer description language) is the first thing i wrote in p6

[19:35] *** kaare_ left
[19:35] <ssutch> https://github.com/samuraisam/p6-pb 

[19:35] *** kurahaupo_mobile joined
[19:36] <raiph> xybre: fwiw, in my time i've lightly explored dozens of interesting langs (lisps incl. clos, smalltalks, vulcan, forths, mls, icon, snobol, linda, beta, etc., etc.) but only professionally coded in assembler, bcpl, perl, javascript

[19:36] <vendethiel> Haskell is cool too with parsec combinators

[19:36] <raiph> xybre: have you seen marpa?

[19:37] *** virtualsue left
[19:37] *** kurahaupo left
[19:37] <xybre> raiph: I research pretty much anything that looks interesting, but I didn't lsit everything because I don't always write real code in everything I encounter. Dylan, NewtonScript, Icon/Unicon, Ada, Beta, etc. 

[19:38] *** treehug88 left
[19:38] <xybre> raiph: I don't believe I've heard of 

[19:38] <xybre> marpa, no.

[19:38] <vendethiel> Dylan++ #cool macros in Dylan.

[19:40] * vendethiel wants to see more macro stuff in Perl6

[19:40] <raiph> xybre: http://jeffreykegler.github.io/Marpa-web-site/

[19:40] * vendethiel .oO(Macro-generating macros, can we do that yet ?)

[19:42] <PerlJam> vendethiel: easy!  Just learn enough to help implement them!  :)

[19:42] <vendethiel> good solution :p.

[19:42] <vendethiel> I need to dwelve into Perl6 internals...

[19:43] <vendethiel> Right after I've finished HoTT, MiniKanren, Mercury's book and my actual macro paper list : https://gist.github.com/Nami-Doc/7133634#meta-programming

[19:44] <xybre> raiph: relevent. Another issue I ran into with most purpose-built parsers is that they suck at being debugged. I'm begining to belive that a generic framework is actually broken by design. 

[19:44] *** rurban joined
[19:44] <xybre> raiph: Although, it also needs to be able to output something that I can use in the language for the compiler too. 

[19:45] *** kurahaupo_mobile is now known as kurahaupo

[19:48] <raiph> xybre: have you tried the grammar tracing module or the rakudo debugger?

[19:48] *** denisboyun joined
[19:49] <moritz> r: (1,2,3,2,2,2,2).BagHash.kv.sort({ .[0] }).perl

[19:49] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: ( no output )

[19:49] *** dwarring joined
[19:49] <moritz> r: say (1,2,3,2,2,2,2).BagHash.kv.sort({ .[0] }).perl

[19:49] <raiph> xybre: output -> lang for the compiler; plz elaborate

[19:49] <camelia> rakudo-jvm 3699aa: OUTPUT«((3, 1), (2, 5), (1, 1))␤»

[19:49] <camelia> ..rakudo-parrot 3699aa, rakudo-moar 3699aa: OUTPUT«((1, 1), (2, 5), (3, 1))␤»

[19:49] *** denis_boyun_ left
[19:49] <xybre> raiph: Yes, Perl6's grammar stuff it's better than most alternatives. 

[19:50] <moritz> r: say (1,2,3,2,2,2,2).BagHash.kv.perl

[19:50] <camelia> rakudo-parrot 3699aa, rakudo-moar 3699aa: OUTPUT«((1, 1), (2, 5), (3, 1)).list␤»

[19:50] <camelia> ..rakudo-jvm 3699aa: OUTPUT«((2, 5), (1, 1), (3, 1)).list␤»

[19:50] *** a3gis joined
[19:50] <moritz> r: say (1,2,3,2,2,2,2).BagHash.kv.tree.sort({ .[0] }).perl

[19:50] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«([1, 1], [2, 5], [3, 1])␤»

[19:51] <xybre> raiph: Output will be opcode. Probably starting with a higher level VM (Parrot?) for the initial version and then moving to a lower level VM or native (LLVM/x86).

[19:51] <vendethiel> (parrot ?)

[19:54] <raiph> xybre: what have you used that's better than p6's grammar stuff? (ignoring p6's immaturity)

[19:54] <dalek> roast: b48a9fb | moritz++ | S02-types/baghash.t:

[19:54] <dalek> roast: baghash.t fixes

[19:54] <dalek> roast: 

[19:54] <dalek> roast: * .kv returns a list of unitemized parcels, so .tree it before sorting

[19:54] <dalek> roast: * do not use # in fudge messages, TAP does not like that

[19:54] <dalek> roast: * fudge for moar

[19:54] <dalek> roast: review: https://github.com/perl6/roast/commit/b48a9fba4c

[19:55] <xybre> raiph: For expressivity? Not much. Rebol's PARSE dialect is pretty great, not quite as powerful from a parsing standpoint, but it feels more flexible to use. My hand-rolled parsers are much better at giving feedback, but are a pain to develop.

[19:55] <PerlJam> xybre: You've used Parsec?

[19:57] <dwarring> lue: I'm responsible for the two nonchar tests https://github.com/perl6/roast/blob/master/S29-conversions/ord_and_chr.t#L157

[19:57] <dwarring> maybe they should be widthdrawn?

[19:58] <xybre> PerlJam: No, I've generally been avoiding parsing with Haskell, maybe its a superstitious thing.

[19:58] <dwarring> saw your link earlier http://www.unicode.org/versions/corrigendum9.html

[19:58] <vendethiel> xybre: really, parsec is great, I'd encourage you to try it out ! Pretty expressive

[19:59] <vendethiel> (scala combinator.parsers is pretty neat too)

[19:59] <lue> dwarring: rather, they should be changed so they see if noncharacters work, because some impls. might think noncharacters should blow up :)

[19:59] <moritz> it seems that now, all of them do

[20:00] <xybre> vendethiel: Haskell's syntax seems a bit over the top. Tutorials all go on about lambda operations and talk a lot of theory without much practical application. Thats a big turn off.

[20:01] <vendethiel> xybre: they talk a lot about abstractions - - not quite the same as theory ;). I know where you're coming from, though

[20:01] <dalek> roast: 48e001a | moritz++ | S04-phasers/enter-leave.t:

[20:01] <dalek> roast: moar-fudge a test, add ticket number

[20:01] <dalek> roast: review: https://github.com/perl6/roast/commit/48e001a6b1

[20:01] <vendethiel> you need some time to get used to Haskell

[20:02] <xybre> vendethiel: Its not as bad as a lot of languages though, which jsut give you the bnf grammar and are like thats all you need to know.

[20:02] <vendethiel> (although I've got https://github.com/Nami-Doc/Typeclassopedia.pl6 heehe)

[20:02] <xybre> the grammar specification is probably the least useful thing to know about a language.

[20:02] <dwarring> lue: ok

[20:04] *** lowpro30 joined
[20:08] <dalek> roast: dc8ff6c | moritz++ | S04-phasers/pre-post.t:

[20:08] <dalek> roast: moar-fudge some phaser tests

[20:08] <dalek> roast: review: https://github.com/perl6/roast/commit/dc8ff6c588

[20:08] <moritz> ok, who fixes the tests?

[20:08] <moritz> (about unassigned or private use characters)

[20:10] <jnthn> dwarring: Having read the Unicode spec thingy, I'm inclined to agree with lue also.

[20:12] <dwarring> .u thumbs up sign

[20:12] <yoleaux> U+1F44D THUMBS UP SIGN [So] (👍)

[20:12] <lue> moritz: I was under the impression that dwarring is handling it.

[20:13] <moritz> lue: I'm not under any kind of impression, until I read a commitment, or even better, commits

[20:14] <vendethiel> .oO(commits are commitments without ments)

[20:14] <raiph> xybre: are you familiar with the term "language oriented programming" (LOP) and systems that claim to deliver benefits for LOP?

[20:15] <dalek> roast: 5394f05 | (David Warring [email@hidden.address] | S29-conversions/ord_and_chr.t:

[20:15] <dalek> roast: reverse nonchar tests (fudged on rakudo for now)

[20:15] <dalek> roast: review: https://github.com/perl6/roast/commit/5394f05db4

[20:15] <dalek> roast: b55f1ae | (David Warring [email@hidden.address] | S0 (3 files):

[20:15] <dalek> roast: Merge branch 'master' of https://github.com/perl6/roast

[20:15] <dalek> roast: review: https://github.com/perl6/roast/commit/b55f1ae82b

[20:16] <dwarring> ^^ hope that looks right (dudged until backends fixed)

[20:16] *** dmol joined
[20:16] * dwarring dudged?

[20:17] <vendethiel> r: sub a(Int) {}; sub foo { a(Bool) }; say "alive";

[20:17] *** lowpro30_ joined
[20:17] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Calling 'a' will never work with argument types (Bool)␤    Expected: :(Int)␤at /tmp/tmpfile:1␤------> sub a(Int) {}; sub foo { ⏏…»

[20:17] <dwarring> afk

[20:17] <vendethiel> Oh perl6 <3333

[20:17] <vendethiel> r: sub a(Int) {}; sub foo { my Bool $var; a($var); }; say "alive";

[20:17] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Calling 'a' will never work with argument types (Bool)␤    Expected: :(Int)␤at /tmp/tmpfile:1␤------> sub a(Int) {}; sub foo { my Bool $…»

[20:18] <vendethiel> I DIDNT EVEN KNOW THAT.

[20:18] <vendethiel> I'm as happy as unwrapping a gift now.

[20:18] <xybre> raiph: nope

[20:19] <vendethiel> r: sub a(Int) {}; sub foo { my Bool|List $var; a($var); }; say "alive";

[20:19] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Type 'Bool' is not declared. Did you mean 'Cool'?␤at /tmp/tmpfile:1␤------> sub a(Int) {}; sub foo { my Bool⏏|List $var; a($var); }; say "alive";␤Malformed…»

[20:19] <moritz> jnthn, dwarring: so should I revert moarvm commit c5f3b5378, "check for invalid code points (jvm port)"?

[20:20] <vendethiel> r: sub a(Int) {}; sub foo { my Bool|String $var; a($var); }; say "alive";

[20:20] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Type 'Bool' is not declared. Did you mean 'Cool'?␤at /tmp/tmpfile:1␤------> sub a(Int) {}; sub foo { my Bool⏏|String $var; a($var); }; say "alive";␤Malform…»

[20:20] <vendethiel> uuh.

[20:20] <moritz> vendethiel: there are no union types; likely it causes a mis-parse

[20:20] <raiph> xybre: the term LOP was coined in the 90s; googles for it can help dig up stuff relevant to what it sounds like you're into; http://en.wikipedia.org/wiki/Language_oriented_programming

[20:21] *** lowpro30 left
[20:21] *** rurban left
[20:21] <vendethiel> oh, I thought it existed. NYI then!

[20:21] <moritz> vendethiel: no NYI. Specced to not work

[20:21] <vendethiel> Union types ? really ? I'm really surprised.

[20:21] *** rurban joined
[20:21] <vendethiel> r: subset Foo where Bool|String; sub a(Foo $) { say "alive"; }

[20:21] <moritz> you can't just bolt on union types on an existing type sytem and have it work magically

[20:21] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Undeclared name:␤    String used at line 1. Did you mean 'Stringy'?␤␤»

[20:22] <vendethiel> moritz: what does that mean?

[20:22] <moritz> vendethiel: what does what mean?

[20:22] <vendethiel> "bolt on union types on an existing type system and have it work magically"

[20:22] <moritz> it means exactly what I wrote

[20:22] <vendethiel> which I don't understand ...

[20:23] <moritz> let me rephrase

[20:23] <vendethiel> I don't expect it to be "type junctions". I thought reading about untagged type unions in the synopsis

[20:23] <jnthn> moritz: That would indeed fix it, I think.

[20:23] *** rurban left
[20:23] <moritz> if you want a language to have union types, it must be really baked in

[20:23] *** rurban joined
[20:23] <moritz> you can write   subset Foo of Any where Bool|Str;

[20:23] <vendethiel> Yeah; I agree with that much - - That's why I said I remember them being in the spec.

[20:23] <moritz> but that's not a real union type

[20:24] *** tauli joined
[20:24] <moritz> so it doesn't participate in multi dispatch as a nominal type, for example

[20:24] <vendethiel> r: sub a(Int|Str) {}; say "alive";

[20:24] <camelia> rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Capture parameter must have a type accepting a Capture␤at /tmp/tmpfile:1␤------> sub a(Int|Str) {}⏏; say "alive";␤    expecting any of:␤        statement list…»

[20:24] <camelia> ..rakudo-parrot 3699aa, rakudo-jvm 3699aa: OUTPUT«alive␤»

[20:25] <moritz> std: sub a(Int|Str) {}; say "alive";

[20:25] <camelia> std 09dda5b: OUTPUT«ok 00:01 127m␤»

[20:25] <vendethiel> but yeah; it seems obvious it's not a nominal type

[20:25] <moritz> std: my Int|Str $x

[20:25] <camelia> std 09dda5b: OUTPUT«===SORRY!===␤Multiple prefix constraints not yet supported at /tmp/RQVvRUbyOc line 1:␤------> my Int⏏|Str $x␤Malformed my at /tmp/RQVvRUbyOc line 1:␤------> my Int⏏|Str $x␤    expecting any of:…»

[20:25] <vendethiel> so isn't it NYI, in the end ?

[20:26] <lue> vendethiel: polymorphic types don't exist. I removed them from S02 myself :) .

[20:26] <moritz> vendethiel: not in the sense that other stuff is NYI

[20:26] <vendethiel> lue: "polymorphic types"?

[20:26] <moritz> vendethiel: more like defered to perl 6.5, if at all

[20:26] <lue> that's what S02 called  Int|Str  .

[20:26] <[Coke]> NYI implies it's spec'd but not in an existing compiler.

[20:27] <vendethiel> [Coke]: yeah, I know that. moritz: alright, fair enough. It's really good enough with subsets.

[20:27] <vendethiel> lue: oh,okay

[20:27] <raiph> vendethiel: have you seen the lang ceylon?

[20:27] <vendethiel> raiph: yes

[20:27] *** rurban1 joined
[20:27] <moritz> gaaah, who cut the moarvm release?

[20:28] *** rurban left
[20:28] <vendethiel> I hate most of the things about it

[20:28] <vendethiel> r: subset Foo where Bool|Str; sub a(Int) {}; sub foo { my Foo $var; a($var); }; say "alive";

[20:28] <camelia> rakudo-parrot 3699aa: OUTPUT«===SORRY!===␤Could not find sub &infix:<|>␤»

[20:28] <camelia> ..rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Cannot invoke null object␤»

[20:28] <camelia> ..rakudo-jvm 3699aa: OUTPUT«===SORRY!===␤java.lang.NullPointerException␤»

[20:28] <moritz> jnthn: please remember to use annotated tags for MoarVM releases

[20:28] <xybre> raiph: thanks I'll check it out

[20:28] <moritz> jnthn: otherwise 'git describe' will ignore it, and it will produce different output form 'git describe --tags'

[20:29] <vendethiel> r: subset Foo of Any where Bool|Str; sub a(Int) {}; sub foo { my Foo $var; a($var); }; say "alive";

[20:29] <camelia> rakudo-parrot 3699aa: OUTPUT«===SORRY!===␤Could not find sub &infix:<|>␤»

[20:29] <camelia> ..rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Cannot invoke null object␤»

[20:29] <camelia> ..rakudo-jvm 3699aa: OUTPUT«===SORRY!===␤java.lang.NullPointerException␤»

[20:29] <jnthn> moritz: ugh...

[20:29] <vendethiel> I'm cool with it anyway.

[20:29] <jnthn> moritz: Yeah, that's an annoying behavior.

[20:29] <vendethiel> Tagged unions > untagged unions

[20:30] <dalek> nqp: 3adc3d7 | moritz++ | tools/build/MOAR_REVISION:

[20:30] <dalek> nqp: bump MoarVM version

[20:30] <dalek> nqp: 

[20:30] <dalek> nqp: to get various bug fixes and improvements

[20:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3adc3d7ce6

[20:30] <moritz> tagged unicorns > untagged unicorns

[20:30] * lue afk

[20:32] <vendethiel> r: class Either { has Left $.left; has Right $.right; has Bool $is-left; multi method new(Left $left) { Either.bless(:$left, :is-left(true)) }; def fmap(&callable) {} }; class Left[::T] { has $.value; multi method new($value) { Left.bless(:$value); } }; class Right[::T] { has $.value; multi method new($value) { Left.bless(:$value); } }; 

[20:32] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Type 'Left' is not declared␤at /tmp/tmpfile:1␤------> class Either { has Left⏏ $.left; has Right $.right; has Bool $is␤Malformed has␤at /tmp/tmpfile:1␤…»

[20:32] <vendethiel> well, it's becoming a bit too long for an IRC message anyway ...

[20:33] <moritz> vendethiel: you can feed gist URLs to camelia

[20:33] *** FROGGS[mobile] left
[20:33] <vendethiel> moritz: yeah, I know # [14:42] <Ven> r: https://gist.github.com/Nami-Doc/c6161cc3b29a1a417b9f

[20:34] <raiph> vendethiel: do you know about /msg camelia m: say 1 # or whatever?

[20:34] <vendethiel> raiph: no - I'll take note :p

[20:34] <vendethiel> I'm pretty spammy

[20:34] <japhb> moritz: 'tagged unicorns' indicates someone found more than one, and tagged them all.  Which is definitely better than not having found any to tag.

[20:35] <raiph> vendethiel: a common practice is to do a /msg camelia m: whatever to golf some issue then sharing the final golf'd version on channel

[20:35] <moritz> japhb: Unicorn tagged as 'found' :-)

[20:36] *** BenGoldberg joined
[20:37] *** Yappo__________8 joined
[20:37] <japhb> Reminds me of some children's book or cartoon or such that has one of the characters coat their home in sticky notes, each one labeling objects with their type: "spoon", "spoon", "fork", "cabinet", "sink" ....

[20:37] *** rurban1 left
[20:40] <vendethiel> r: class A[::T] {};

[20:40] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Unable to parse class definition␤at /tmp/tmpfile:1␤------> class A⏏[::T] {};␤    expecting any of:␤        statement l…»

[20:41] <vendethiel> oh :(.

[20:42] <japhb> vendethiel: Roles can pun into classes.  So just do a parametric role, if that's what you want/

[20:45] *** rurban joined
[20:45] <vendethiel> japhb: how do I pass the type parameter ?

[20:46] <vendethiel> r: role A[::T] {}; class B does A[::UhWhatHere] {};

[20:46] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol UhWhatHere␤»

[20:48] <japhb> r: role A[::T] {}; class B does A[Int] {};

[20:48] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: ( no output )

[20:49] *** SamuraiJack left
[20:49] <japhb> r: role A[::T] {}; class B is A[Int] {};  # Curious if the punning works with this syntax

[20:49] <camelia> rakudo-parrot 3699aa, rakudo-jvm 3699aa, rakudo-moar 3699aa: OUTPUT«===SORRY!=== Error while compiling /tmp/tmpfile␤Cannot call 'trait_mod:<is>'; none of these signatures match:␤:(Mu:U $child, Mu:U $parent)␤:(Mu:U $child, Any :DEPRECATED($DEPRECATED)!)␤:(Mu…»

[20:49] <[Coke]> where do the specs define what ::T does?

[20:49] <[Coke]> I'm looking in S14-roles-and-parametric-types.pod, but it's not clear that ::T there is anything but a placeholder for a "real" value.

[20:50] <vendethiel> parametric type ?

[20:50] <japhb> [Coke]: For a role declaration, it's a parameter.  For a signature, it's a type capture, generally used to say things like "This works one two objects of the same type"

[20:51] <japhb> *works on

[20:51] <vendethiel> so, classes can't be type parametric themselves

[20:51] <[Coke]> japhb: can you point to the spec that says what you just said?

[20:51] <japhb> r: sub foo(::T $a, T $b) { say 'woot' }; foo(1, 3); foo('a', 'b'); foo(1, 'b');

[20:52] <camelia> rakudo-moar 3699aa: OUTPUT«woot␤woot␤cannot stringify this␤  in sub foo at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[20:52] <camelia> ..rakudo-parrot 3699aa: OUTPUT«woot␤woot␤Nominal type check failed for parameter '$b'; expected Int but got Str instead␤  in sub foo at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[20:52] <camelia> ..rakudo-jvm 3699aa: OUTPUT«woot␤woot␤Nominal type check failed for parameter '$b'␤  in sub foo at /tmp/tmpfile:1␤  in block  at /tmp/tmpfile:1␤␤»

[20:52] <japhb> [Coke]: hold on, have to get to the box I have a spec checkout

[20:52] <[Coke]> Danke.

[20:53] <vendethiel> [Coke]: try S12 ?

[20:53] <[Coke]> m: sub foo(::BARF $a, BARF $b) { say 'woot' }; foo(1, 3); foo('a','b'); foo(1, 'b');

[20:53] <camelia> rakudo-moar 3699aa: OUTPUT«woot␤woot␤cannot stringify this␤  in sub foo at /tmp/wNrEu7apCt:1␤  in block  at /tmp/wNrEu7apCt:1␤␤»

[20:53] <[Coke]> p: sub foo(::BARF $a, BARF $b) { say 'woot' }; foo(1, 3); foo('a','b'); foo(1, 'b');

[20:53] <camelia> rakudo-parrot 3699aa: OUTPUT«woot␤woot␤Nominal type check failed for parameter '$b'; expected Int but got Str instead␤  in sub foo at /tmp/r58HY9DY8J:1␤  in block  at /tmp/r58HY9DY8J:1␤␤»

[20:53] <japhb> $ git grep -i 'type capture'

[20:53] <japhb> S06-routines.pod:=head2 En passant type capture

[20:53] <japhb> contents.pod:           En passant type capture

[20:53] <vendethiel> http://perlcabal.org/syn/S12.html#Custom_Meta-objects at the end

[20:54] <japhb> The first one, of course.  :-)

[20:54] <[Coke]> S02:1921

[20:54] <synopsebot> Link: http://perlcabal.org/syn/S02.html#line_1921

[20:55] <[Coke]> Danke.

[20:55] *** rurban left
[20:56] *** benabik left
[21:00] <dalek> nqp: a4eda0b | moritz++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[21:00] <dalek> nqp: Remove now-deprecated validity checks for nqp::chr on the JVM

[21:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a4eda0bcd2

[21:01] <jnthn> ::T is a type capture; in roles, role Foo[...signature here...] { }

[21:01] <jnthn> And so ::T works just like in a signature.

[21:01] <japhb> jnthn: Yeah, that occurred to me right after I sent it.

[21:02] <jnthn> You can even write multiple roles with the same short name and it just multi-dispatches to pick the best one :)

[21:02] <japhb> Especially since I've actually passed normal concrete valued arguments to role instantiations, so I clearly already knew that at some point.  :-)

[21:03] *** woolfy joined
[21:04] *** dayangkun left
[21:07] <vendethiel> how do you call `grammar :: { rule foo<here that kind of stuff> { 'foo' } }`

[21:08] *** skids left
[21:08] <vendethiel> It's often quite hard to search for definitions, etc. How do you lookup what "will" does?

[21:08] <japhb> vendethiel: ETOOMETA.  'call' as in 'name', or 'call' as in 'invoke'?  And if the latter, do you mean the grammar, or the rule?

[21:08] <vendethiel> a rule with a subscript

[21:08] <vendethiel> sorry I'm not clear.

[21:09] <jnthn> adverb

[21:09] <vendethiel> a rule adverb?

[21:10] <raiph> jnthn: a search for YieldProcessor yields zero results on reddit and hypernews. do any of the 12 matching posts on stackexchange help? http://stackoverflow.com/search?q=YieldProcessor

[21:11] *** lowpro30_ left
[21:13] <jnthn> vendethiel: Well, it's part of the name.

[21:14] <vendethiel> jnthn: Alright, noted :). Not sure what difference does it make in the end, but it's cool

[21:14] <jnthn> vendethiel: I guess you're referring to things like rule package_decl:sym<class> { ... } or so

[21:14] <vendethiel> yes

[21:14] <vendethiel> am I that unclear ? damn :s

[21:16] <jnthn> vendethiel: No, it's me, I'm debugging something tricky at the moment and you only have a bit of my attention. Sorry.

[21:16] <vendethiel> I'd much rather let you focus on what you're doing, though :).

[21:17] <jnthn> raiph: They're on topic, just don't tell me anything new. :)

[21:18] *** dayangkun joined
[21:19] <jnthn> raiph: Thanks for looking btw.

[21:19] <jnthn> raiph: I think the answer is "there's no common abstraction for this to be found away from Windows, so just probe to see if you can inline-assembly it"

[21:24] *** rurban joined
[21:25] *** xragnar_ joined
[21:25] *** xragnar left
[21:25] *** xragnar_ is now known as xragnar

[21:26] <BenGoldberg> r: my $a = role A[::T] {}; my $b = $a[Int];

[21:26] <camelia> rakudo-parrot 3699aa: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method Bridge at gen/parrot/CORE.setting:4376␤  in sub infix:<<> at gen/parrot/CORE.setting:4293␤  in sub infix:<<> at gen/parrot/CORE.setting:4137␤  in sub postcircumfix:<[ ]> at g…»

[21:26] <camelia> ..rakudo-moar 3699aa: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method Bridge at src/gen/m-CORE.setting:4372␤  in sub infix:<<> at src/gen/m-CORE.setting:4289␤  in sub infix:<<> at src/gen/m-CORE.setting:4133␤  in sub postcircumfix:<[ ]> at src/ge…»

[21:26] <camelia> ..rakudo-jvm 3699aa: OUTPUT«Cannot look up attributes in a type object␤  in method Bridge at gen/jvm/CORE.setting:4373␤  in sub infix:<<> at gen/jvm/CORE.setting:4289␤  in sub infix:<<> at gen/jvm/CORE.setting:4133␤  in sub postcircumfix:<[ ]> at gen/jvm/CORE.setting:2385␤  …»

[21:27] <BenGoldberg> Very peculiar that jvm produces a different error message.

[21:29] *** a3gis left
[21:39] *** tauli left
[21:50] <dalek> specs: 756c4ce | (Elizabeth Mattijsen)++ | S02-bits.pod:

[21:50] <dalek> specs: Fix left behind "async" (we only do "start" now)

[21:50] <dalek> specs: review: https://github.com/perl6/specs/commit/756c4ceb14

[21:59] *** rurban1 joined
[22:03] *** lustlife left
[22:03] *** rurban left
[22:04] *** bluescreen100 left
[22:06] *** virtualsue joined
[22:07] *** zby_home left
[22:07] <dalek> roast: 71706d4 | moritz++ | S32-num/power.t:

[22:07] <dalek> roast: fix a moar fudge

[22:07] <dalek> roast: review: https://github.com/perl6/roast/commit/71706d4d23

[22:09] *** tgt joined
[22:09] <dalek> roast: aac2968 | moritz++ | S06-macros/quasi-blocks.t:

[22:09] <dalek> roast: another moar fudge

[22:09] <dalek> roast: review: https://github.com/perl6/roast/commit/aac2968614

[22:10] <moritz> still lots of rakudo-m spectest failures

[22:10] *** a3gis joined
[22:10] <moritz> this is frustrating.

[22:10] <jnthn> moritz: Was there ~40 before you started?

[22:14] <moritz> jnthn: dunno

[22:15] *** a3gis left
[22:15] *** kbaker left
[22:15] <dalek> rakudo/nom: 348a16b | moritz++ | tools/build/NQP_REVISION:

[22:15] <dalek> rakudo/nom: bump NQP revision to get some chr() fixes

[22:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/348a16ba10

[22:16] *** cognominal left
[22:18] *** virtualsue left
[22:20] *** cognominal joined
[22:24] *** btyler left
[22:29] *** wbill joined
[22:31] *** wbill left
[22:35] *** jnap left
[22:35] *** treehug8_ left
[22:36] *** jnap joined
[22:37] <timotimo> thank you forbdoing it, moritz

[22:38] *** wbill joined
[22:42] <vendethiel> what's "use MONKEY_TYPING"? enabling `augment`|?

[22:43] *** dmol left
[22:43] *** woolfy left
[22:44] <timotimo> yes

[22:46] *** wbill left
[22:46] *** rindolf left
[22:51] *** logie left
[22:54] *** jnap left
[22:56] *** raiph left
[22:59] <cognominal> and probably a reference to a metaphor créated by Emile Borel   http://en.wikipedia.org/wiki/Infinite_monkey_theorem

[23:03] <cognominal> elsewhere it is called duck typing. Am I wrong?

[23:05] <jnthn> no, duck typing is something else

[23:06] <jnthn> here we're monkeying with tyes

[23:06] <jnthn> *types

[23:07] *** tgt left
[23:08] <cognominal> thx, jnthn++

[23:08] <TimToady> it's called "monkey patching" in rubyland

[23:09] <cognominal> there is even a wp entry :  http://en.wikipedia.org/wiki/Monkey_patch

[23:10] <cognominal> the supposed "etymology" is interesting

[23:18] *** kaare_ joined
[23:20] *** ssutch_ joined
[23:21] <jnthn> o/ TimToady 

[23:22] *** ssutch left
[23:22] <TimToady> \o

[23:22] <jnthn> TimToady: I'm currently merging moar-conc. It doesn't give 100% of the concurrency functionality you've got on JVM, but promises and channels are there. It's the time-based stuff that's still missing.

[23:22] <jnthn> Promise.in(...), Supply.interval(...), etc.

[23:22] <TimToady> cool

[23:23] <vendethiel> jnthn++

[23:23] <jnthn> No promises on how stable it is, though I've been hunting and killing parallel GC bugs in the last evenings...

[23:23] <TimToady> tomorrow's talk is mostly about Open Source, and the Perl meetups are later, so don't need it immediately

[23:23] <vendethiel> is it recorded? 

[23:23] <jnthn> Sure. Well, then you've time to tell me how you break it :P

[23:24] <jnthn> So I can try and fix it in time for the Perl things. :)

[23:24] <TimToady> probably in a live demo :)

[23:24] <jnthn> :P

[23:24] <jnthn> Murphy's law suggests so.

[23:25] <dalek> Heuristic branch merge: pushed 16 commits to nqp by jnthn

[23:26] <dalek> Heuristic branch merge: pushed 30 commits to rakudo/nom by jnthn

[23:26] <jnthn> There we go.

[23:26] <TimToady> \o/

[23:26] <TimToady> jnthn++

[23:30] *** ajr_ left
[23:30] <cognominal> jnthn++

[23:30] *** kaare_ left
[23:37] *** iolympian joined
[23:38] *** iolympian left
[23:47] *** Mouq joined
[23:49] <Mouq> o/

[23:49] <yoleaux> 24 Mar 2014 23:22Z <TimToady> Mouq: yeah, should probably allow :q to \ an opener, and if double angles allow #, it's more because that's how shells work than how Perl works :)

[23:50] *** raiph joined
[23:50] <Mouq> \o/ jnthn++

[23:52] <jnthn> o/ moritz 

[23:52] <jnthn> uh

[23:52] <jnthn> o/ Mouq 

