[00:01] <lue> I should also note that the totally-not-written-by-me-at-all S15 should demonstrate that strings (of characters) in Perl 6 are not quite that analogous to binary streams of data, compared to P5.

[00:01] *** skraito-0x71 joined
[00:01] <grondilu> lue: that's probably because S15 focuses on Str, doesn't it?

[00:01] <skraito-0x71> hey guys

[00:01] <timotimo> hi there

[00:01] <skraito-0x71> what's up

[00:01] <lue> It focuses on Unicode actually, but string types tend to come up there :)

[00:02] <skraito-0x71> how do you declare variable

[00:02] <grondilu> to be precise, it's the Str type which comes up there.

[00:02] <timotimo> skraito-0x71: using the "my" syntax, like "my $shiny_variable = 1234"

[00:02] <skraito-0x71> oh now we should use my ?

[00:02] <grondilu> in other words "strings of text"   ;-)

[00:02] <skraito-0x71> we can't use it without my?

[00:03] <skraito-0x71> let me test it

[00:03] <skraito-0x71> but loop doesn't work

[00:03] *** kivutar joined
[00:03] <diakopter> skraito-0x71: what loop?

[00:04] <skraito-0x71> like loop forever

[00:04] <skraito-0x71> there for (1) { }

[00:04] <skraito-0x71> i try for (1) and for (0) is just loop one time

[00:04] <skraito-0x71> there is logic error there need to be coded again

[00:04] <smls> lue: To me, "string" (in the general sense) is a concept on the same level as, and in fact similar to, "array".

[00:04] <diakopter> for doesn't loop; it iterates

[00:04] <smls> But arrays emphasize random access and treat their elements as self-contained objects that could just as well exists separately from each other...

[00:05] <diakopter> loop loops

[00:05] <smls> ...whereas strings are made up of things that inherently belong together in that order to form a greater whole.

[00:05] *** skraito-0x71 left
[00:05] <lue> smls, grondilu: what you call "string" I call "stream", and what you call "string of character" I call "string" :)

[00:06] <lue> smls, grondilu: P6 agrees with me when it comes to Str, but somehow disagrees with me by making Str into a more array-ish thing.

[00:06] <lue> *with Bufs

[00:06] <smls> I think treating binary data as arrays of unsigned integers (which, if I understand correctly, is what you prefer) is insufficiently generic

[00:07] <smls> "string of bytes" makes no assumption of how the bytes are to be interpreted

[00:07] <smls> or, indeed, if they have an interpretation in their own

[00:07] <smls> (outside of the whole)

[00:08] <lue> smls: yes, but Buf (which is the designated "string of bytes" type) includes a lot of operations and design choices that only make sense with Str, aka "string of characters", to me.

[00:08] <smls> like what?

[00:09] <smls> things like concatenation seem generic enough to me

[00:09] <lue> I specifically want to play with the binary data in a generic fashion, because Perl 6 has no way of playing with it built-in. I don't appreciate string-of-char design choices tainting Bufs in those cases.

[00:09] <grondilu> lue:  if you call a string of characters just "string" and refuse to admit that it is indeed a string of characters, then you abuse the metaphor as you use the word supposed to designate a piece of rope as if it was obvious that it is actually text. 

[00:09] <lue> r: my @a = 1,2,3; my @b = 4,5,6; @a ~= @b; say @a;

[00:09] *** rurban1 joined
[00:09] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«1 2 34 5 6␤»

[00:09] <lue> smls: that shouldn't work for Bufs either, for example.

[00:10] <lue> grondilu: Most everyone (and P6's Str type) says "string" eq "text". I of course admit it's a "string of characters" and have said as much when I needed to be clear, but *you* can't deny how language has morphed "string" to refer to a specific kind of data.

[00:11] <lue> Again, pretend "Str" is actually named "Txt" in Perl 6, maybe then my objections won't be as confusing.

[00:12] <lue> I don't think Buf should be polluted with operators and design choices that are designed to work on Txt-based data.

[00:14] *** rurban1 left
[00:15] *** ajr_ left
[00:15] <smls> lue: Well I don't care much about *names* of concepts

[00:16] <smls> I just thing that Str = "$X of characters", Buf = "$X of bytes" is a coherent analogy

[00:16] <grondilu> but you have to.  I mean, even if we tend to use the word "string" to mean "text", in computer science (https://en.wikipedia.org/wiki/String_(computer_science)), strings are indeed data structure that are not necessarily text:  « A string is generally understood as a data type and is often implemented as an array of bytes (or words) that stores a sequence of elements, *typically* characters, using some character encoding. »

[00:16] <smls> &think

[00:17] <lue> smls: Yes. I'm just frustrated that the concept of "Buf shouldn't be a funny view of text" is being so difficult.

[00:17] <smls> no matter what name you prefer for $X

[00:17] <smls> (and no, I don't think "stream" is the perfect word for it, as it implies data being made available over time)

[00:18] <lue> smls: yeah, "stream" is merely the closest word I'd reach for. I usually don't have a distinct word for it, it's just data.

[00:19] <lue> grondilu: I really don't care about the formal definition of a "string". I care about Buf being given design choices that only make sense, to me, for textual data, like you see in the Str, Uni, etc. types.

[00:19] <grondilu> string is just fine, as long as you don't think that means "text".  "string" means:  "someting that looks like a piece of rope"

[00:19] *** aindilis` joined
[00:19] <lue> I don't feel like saying more, but Perl 6 quite clearly disagrees with you there :) . "string" is "text".

[00:20] <timotimo> but on moarvm strings are ropes

[00:20] <grondilu> lue:  it makes sense only to you but string algorithms are quite important and I'm pretty sure they can be used for other things than text.

[00:20] <grondilu> lue: no, according to Perl 6, "Str" is text.  There's a slight difference.

[00:20] <lue> Str is specifically a sequence of Unicode characters. It can't be used for more than that unless you supersede or augment the class.

[00:21] *** aindilis left
[00:21] <grondilu> I meant that you should be able to use string algorithms with Buf.

[00:22] <grondilu> Because that would make some sense, since they have the same structure.

[00:22] <lue> I will say again, that I don't want Buf to be polluted with design choices that only make sense for Str. That's the thing I feel like arguing about now, not so much the specific meaning of "string"

[00:23] <grondilu> the problem is that the reasons you think the design choices made only sense for Str are related to what you think a string is.

[00:24] <grondilu> using concatenation ~ for instance can be useful with Buf because ~ is heavily used in string algorithms.  And you may very well need string algorithms with Buf.

[00:25] <grondilu> because Buf are strings, just not text.

[00:25] <lue> Array.push() is equivalent. That's how I think when I want to use a binary collection of data.

[00:25] <smls> lue: But why do you feel that concatenation with the concatenation operator is a design choice that only makes sense for a "string-rope-stream-whatever" of characters, and not for a "string-rope-stream-whatever" of bytes?

[00:26] <lue> because I see Buf as a low-level Array-like type, *not* as a generalized stream-thing type.

[00:26] <lue> Remember, I just want open("file", :bin).read($bytes) and similar to give me results in a data type that won't screw me over because I'm thinking with arrays.

[00:27] <grondilu> isn't ther a IO.bytes method?

[00:27] <lue> nope. All binary dealings in IO are with Bufs.

[00:28] <lue> Look at how C++'s iostream objects handle binary data vs. string^Wtext data. That's what I want when I do binary IO.

[00:29] <grondilu> r: say .list.WHAT given my $ = Buf.new: ^10;

[00:29] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«(Array)␤»

[00:30] *** rurban1 joined
[00:33] <smls> It certainly makes sense to have a way to treat binary data as an array of integers, and as grondilu just demo'ed is seems theres is, but I don't agree that it should be the "default" for binary data returned from built-in IO methods.

[00:35] <smls> I think "Buf a.k.a. string of bytes" is a better suited for that, because it makes no assumption about the interpretation of the data. It just says that it has "string/rope/stream-like" structure.

[00:36] <lue> I'm fine with a numerical view of Strs, despite my feelings that it's totally useless, but I either want Buf to act more like array objects because that's what it purports to be, in some way, or for another type to be returned by binary IO, or...

[00:36] <lue> for someone to finally, FINALLY, make native types work in Rakudo, so I can just use Array[int8] and be done with it.

[00:36] *** thou left
[00:37] <grondilu> I agree with smls.  I like how Buf is capable of behaving both as a string and as an array.  Seems compliant to  TIMTOWTDI.

[00:37] <lue> But it isn't! Where's Buf.push(), for instance?

[00:38] <lue> And it should really be called a StrArray if that's what you want :/

[00:38] <grondilu> no, since Str is already used to mean "text"

[00:39] <lue> oh, right, your definition of string.

[00:40] <grondilu> me is beginning to seriously think that "Str" should really be named "Txt"

[00:40] <grondilu> but that would be a lot to ask to the designers :/

[00:43] <lue> People would start asking "how do I use strings in Perl 6?" too. S15 makes it so that P6 doesn't really *need* Str anyway, but getting rid of it would cause too many problems.

[00:43] <grondilu> I do agree.  It would confuse people.

[00:44] *** BenGoldberg left
[00:48] <grondilu> .oO(  role Str { }; class Buf does Str does Array { };  class Txt does Str { }  }    )

[00:49] <lue> You're looking for Stringy I think :)

[00:49] <grondilu> oh there is such a thing indeed

[00:51] *** rurban1 left
[00:51] *** rurban1 joined
[00:55] *** berekuk left
[00:56] *** jnap joined
[01:05] *** smls left
[01:07] *** abnorman left
[01:33] *** abnorman joined
[01:36] *** abnorman left
[01:52] <timotimo> great. now i forgot to stash away the exact numbers of the tests that failed before i did my changes to moarvm

[01:53] <timotimo> cool. my changes get rid of 8 failing tests

[01:53] <timotimo> 12 to go

[02:01] *** jnap left
[02:03] *** benabik joined
[02:03] *** benabik left
[02:07] *** thou joined
[02:08] <timotimo> r: say -5 div 9; say -5 div 10; say -5 div 11;

[02:08] <camelia> rakudo-jvm 263aa0: OUTPUT«-1␤-1␤-1␤»

[02:08] <camelia> ..rakudo-parrot 263aa0: OUTPUT«0␤0␤0␤»

[02:08] <timotimo> ... didn't i just fix this?

[02:10] <timotimo> oh crap. i may have done it the wrong way around :o

[02:10] <timotimo> r: say -5 div $_ for (4..6);

[02:10] <camelia> rakudo-parrot 263aa0: OUTPUT«-1␤-1␤0␤»

[02:10] <camelia> ..rakudo-jvm 263aa0: OUTPUT«-2␤-1␤-1␤»

[02:11] <timotimo> yeah, that's -1 -1 -2 for moarvm now m)

[02:12] *** gcole_ left
[02:13] *** gcole joined
[02:13] <timotimo> r: say -5 div 2; say 5 div 2;

[02:13] <camelia> rakudo-jvm 263aa0: OUTPUT«-3␤2␤»

[02:13] <camelia> ..rakudo-parrot 263aa0: OUTPUT«-2␤2␤»

[02:16] *** gcole_ joined
[02:18] * timotimo doesn't have the brainpower right now to solve this properly, so will hack it in instead later tonight

[02:20] *** gcole left
[02:27] <japhb> That backlog was headache-inducing.

[02:28] <timotimo> because of strings?

[02:28] <japhb> Yeah.

[02:28] <japhb> It felt like there was confusion about "what's been implemented" versus "what's been designed".

[02:29] <timotimo> mhm

[02:30] <japhb> Also, IO wants to work with Buf because it's a *BUFfer*

[02:30] *** raiph joined
[02:30] <timotimo> i did not pay close attention

[02:31] <japhb> It's not a string, though you can encode a Str to a Buf.  It's not an array of numbers, though you can split it on boundaries of 2**n bytes and call it an array of integers if you like.

[02:31] <timotimo> yes, though automatic conversions to Dand from the conconfigured encoding of either the program, scope or file descriptor 

[02:31] <japhb> But really it's just a buffer for opaque data to be exchanged with the OS.

[02:31] <timotimo> would be okay

[02:31] <japhb> Sure, we can sugar it like a donut.  Fine by me (and actually nice, because I like easy things to be easy.)

[02:32] <japhb> But if you want "array of numbers", then you want Array of <numeric type>.  AKA 'my int8 @little-numbers'

[02:33] <japhb> If that doesn't work yet, that's just an implementation problem, not a design defect.

[02:33] <timotimo> well the returned buf could have a default encoding that gets set when you read from a file and used if you did not specify an encoding to use for the specific call

[02:33] <japhb> Using buf8 as a workaround is still a workaround, it's not a design problem with buf8.

[02:33] <timotimo> that way, sincebuff is(?) Cool, it could coerce to Str properly

[02:34] <japhb> r: say buf8.^mro

[02:34] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«(Buf[uint8]) (Any) (Mu)␤»

[02:35] <timotimo> hm, k

[02:35] <japhb> And the reason for ~ being concatenation isn't just because it looks like a lazy S or like a piece of string, but because it connotes sewing together pieces.

[02:36] <timotimo> hehe

[02:37] <japhb> Pulling together multiple OS buffers into one (at least conceptually) doesn't just make sense, it's how you have to do performance-critical IO.  "Scatter-gather"

[02:38] <japhb> Well, not have to in the general case, but for certain common cases, like slapping multiple levels of header or framing onto a piece of data you've already mapped into a memory buffer.

[02:40] <japhb> And "string of things" technically makes sense -- you can consider each thing to be a bead on a string necklace -- but it's confusing.  Just because something has a known meaning in Computer Science literature doesn't mean it was well named.

[02:40] <timotimo> yes

[02:41] <japhb> Applying the conceptual design of string algorithms to other types of conceptually positional data makes sense, but I've always hated that history got baked into the naming there.

[02:41] <timotimo> aye

[02:41] <japhb> They're really sequence searching algorithms.

[02:41] <japhb> Bus stop, afk for a bit &

[02:47] *** logie_ left
[02:53] *** gcole_ left
[02:57] *** gcole joined
[03:01] *** jnap joined
[03:06] *** jnap left
[03:15] *** mavcunha left
[03:20] *** FROGGS[mobile] left
[03:21] *** FROGGS[mobile] joined
[03:23] *** FROGGS[mobile] left
[03:23] *** FROGGS[mobile] joined
[03:25] *** BenGoldberg joined
[03:32] <timotimo> r: say -5 div $_ for (4..6);

[03:32] <camelia> rakudo-parrot 263aa0: OUTPUT«-1␤-1␤0␤»

[03:32] <camelia> ..rakudo-jvm 263aa0: OUTPUT«-2␤-1␤-1␤»

[03:32] <timotimo> why do i constantly do things orwng?!?

[03:32] <jercos> because you're human?

[03:33] <jercos> at least I presume you're not some sort of perl6-based robot.

[03:33] <lue> japhb: considering Buf as an opaque thing really meant to exchange data, rather than manipulate it, feels oddly... right to me. Would clear up how I hate Buf's awkward halfway-ness in relation to Str and arrays.

[03:34] <timotimo> :)

[03:34] <timotimo> if i was a perl6-based robot, i would function even slower than i actually do

[03:35] <timotimo> oh. now i understand what i was doing wrong

[03:35] <timotimo> wow. i'm pretty dumb sometimes

[03:36] *** FROGGS[mobile] left
[03:36] *** FROGGS[mobile] joined
[03:40] *** ponbiki left
[03:58] <lue> r: my $foo = "Foo"; $foo.=subst(/Foo/, "Bar"); say $foo;

[03:58] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«Bar␤»

[04:02] *** jnap joined
[04:04] <lue> Hrm. Rakudo's IO doesn't have :rw, and I'm having no luck in finding a way to overwrite certain bytes in a file. :/

[04:07] *** jnap left
[04:08] <lue> Without, that is, reading the entire file into a Buf. I rather wished I didn't have to do that.

[04:12] *** logie_ joined
[04:24] *** thou left
[04:32] *** preflex_ joined
[04:32] *** ChanServ sets mode: +v preflex_

[04:33] *** preflex left
[04:33] *** preflex_ is now known as preflex

[04:38] *** rurban1 left
[04:39] *** rurban1 joined
[04:53] *** thou joined
[04:53] *** araujo left
[05:29] *** raiph left
[05:46] *** rurban1 left
[05:53] <segomos_> lue: that seems like a common operation that rakudo would handle (not saying you're wrong, it's just odd)

[05:55] <lue> segomos_: The :a (append) mode doesn't let you move where you write to, and :w clears the file before you start writing to it.

[05:55] <lue> I'm just assuming :rw would Do What I Want, because you can't read a cleared file now can you? :)

[06:05] *** ponbiki joined
[06:17] *** rurban1 joined
[06:19] *** raiph joined
[06:20] *** BenGoldberg left
[06:21] *** laidback_01 left
[06:22] *** rurban1 left
[06:34] *** darutoko joined
[06:47] *** ssutch left
[07:03] *** hummeleBop joined
[07:32] *** dmol joined
[08:04] *** raiph_ joined
[08:05] * jnthn waves from l'airport

[08:08] *** hoverboard joined
[08:08] * moritz waves back. Have a good flight!

[08:10] <moritz> p: enum Bla 'A'..'Z';

[08:10] <camelia> rakudo-parrot 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/EHSRXwX9UF␤Undeclared name:␤    Bla used at line 1␤Undeclared routine:␤    enum used at line 1␤␤»

[08:10] <moritz> p: enum Bla ('A'..'Z');

[08:10] <camelia> rakudo-parrot 263aa0: ( no output )

[08:10] <jnthn> std: enum Bla 'A'..'Z';

[08:10] <camelia> std 09dda5b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'Bla' (see line 1) at /tmp/CpE8k8aMB8 line 1:␤------> [32menum Bla[33m⏏[31m 'A'..'Z';[0m␤Two terms in a row at /tmp/CpE8k8aMB8 line 1:␤------> [32menum Bla [33m⏏[31m'A'..'Z';[0m␤…»

[08:10] <jnthn> LTA, std... :)

[08:10] <moritz> backtracking issue, I guess

[08:11] <jnthn> yeah

[08:13] <masak> good morning, #perl6

[08:14] <jnthn> o/ masak

[08:15] <nwc10> good UGT jnthn 

[08:16] <jnthn> o/

[08:18] *** rurban1 joined
[08:19] *** ssutch joined
[08:22] *** eternaleye left
[08:23] *** eternaleye joined
[08:23] *** rurban1 left
[08:26] *** xinming joined
[08:36] <jnthn> Time to go fly...got some way with a hopefully nice thing, though... :)

[08:36] <jnthn> bbl

[08:44] *** thou left
[08:46] *** Woodi joined
[08:47] <FROGGS[mobile]> o/

[09:01] *** raiph_ left
[09:02] *** raiph left
[09:03] <masak> jnthn: if you unexpectedly need to take over the helm, remember that pushing the steering wheel forward causes the plane to descend, and pulling it towards you causes it to ascend.

[09:10] *** uon joined
[09:12] <moritz> why don't they tell you *that* in the pre-flight briefing?

[09:16] *** skids left
[09:20] *** uon1 joined
[09:20] *** uon left
[09:21] *** sqirrel joined
[09:30] *** araujo joined
[09:43] *** berekuk joined
[09:50] *** berekuk left
[09:51] *** berekuk joined
[09:53] *** kaare_ left
[09:54] * masak .oO( "In the unlikely event of having to take control of the aircraft..." )

[09:56] <FROGGS> pull the steering wheel firmly over mouth and nose?

[09:57] *** aindilis` left
[09:59] *** aindilis joined
[10:05] *** uon1 left
[10:11] *** xinming left
[10:11] *** xinming joined
[10:12] *** SamuraiJack joined
[10:17] *** xinming left
[10:18] *** xinming joined
[10:19] <masak> FROGGS: make sure you administer your own steering wheel before you help others.

[10:20] *** denisboyun joined
[10:20] *** berekuk left
[10:30] *** berekuk joined
[10:32] <tadzik> and breath normally

[10:32] *** berekuk left
[10:56] *** xinming left
[10:57] *** xinming joined
[11:06] *** cognominal__ left
[11:09] *** preflex_ joined
[11:09] *** ChanServ sets mode: +v preflex_

[11:09] *** cognominal joined
[11:10] *** preflex left
[11:10] *** preflex_ is now known as preflex

[11:13] *** atroxaper joined
[11:20] *** hoverboard left
[11:20] *** berekuk joined
[11:20] *** FROGGS[mobile] left
[11:21] *** FROGGS[mobile] joined
[11:30] *** sqirrel left
[11:33] *** berekuk left
[11:33] *** FROGGS[mobile] left
[11:34] *** FROGGS[mobile] joined
[11:35] *** pdcawley left
[11:36] *** berekuk joined
[11:54] *** aindilis left
[11:56] <dalek> nqp: 204c5ce | jonathan++ | src/vm/moar/ (12 files):

[11:56] <dalek> nqp: Updates to use MoarVM serialization improvements.

[11:56] <dalek> nqp: review: https://github.com/perl6/nqp/commit/204c5ce5eb

[11:58] *** Piers joined
[11:59] *** spider-mario joined
[12:00] *** rindolf joined
[12:05] *** xinming left
[12:06] *** xinming joined
[12:09] *** berekuk left
[12:12] *** berekuk joined
[12:24] *** pjcj_ left
[12:33] *** psch joined
[12:34] *** Piers left
[12:35] <psch> hi #perl6

[12:39] <masak> hi psch 

[12:43] *** Piers joined
[12:44] *** cognominal left
[12:45] *** cognominal joined
[12:57] <timotimo> hi psch 

[13:01] *** Piers left
[13:03] *** pjcj joined
[13:08] *** berekuk left
[13:10] *** berekuk joined
[13:19] *** Rotwang joined
[13:20] *** kivutar left
[13:24] *** cognominal left
[13:24] *** cognominal joined
[13:30] *** berekuk left
[13:32] <timotimo> so ... what is needed to make for loops always sink?

[13:32] <dalek> perl6-examples: deb3cb6 | (Shlomi Fish)++ | euler/README:

[13:32] <dalek> perl6-examples: Remove trailing space.

[13:32] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/deb3cb67a5

[13:32] <dalek> perl6-examples: 79b721d | (Shlomi Fish)++ | euler/README:

[13:32] <dalek> perl6-examples: Some grammar/spelling/etc. fixes for the README.

[13:32] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/79b721d7e8

[13:32] <dalek> perl6-examples: 25efd58 | (Shlomi Fish)++ | euler/prob188-shlomif.pl:

[13:32] <dalek> perl6-examples: [Euler] Add my solution to Euler #188.

[13:32] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/25efd58870

[13:32] <dalek> perl6-examples: 9c30576 | timo++ | euler/ (2 files):

[13:32] <dalek> perl6-examples: Merge pull request #15 from shlomif/master

[13:32] <dalek> perl6-examples: 

[13:32] <dalek> perl6-examples: Euler: remove trailing space, fix grammar+spelling and add #188 .

[13:32] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/9c305768ce

[13:33] *** treehug88 joined
[13:33] *** berekuk joined
[13:34] * rindolf nuzzles dalek

[13:39] *** rindolf left
[13:41] *** kivutar joined
[13:42] *** rindolf joined
[13:58] *** atroxaper left
[13:58] *** pecastro joined
[14:10] *** Piers joined
[14:22] *** mavcunha joined
[14:24] *** beastd joined
[14:27] *** lue left
[14:28] *** treehug88 left
[14:29] *** Piers left
[14:30] *** berekuk left
[14:30] *** berekuk_ joined
[14:31] *** treehug88 joined
[14:33] *** treehug88 left
[14:35] *** mavcunha left
[14:35] *** berekuk_ left
[14:35] *** FROGGS[mobile] left
[14:35] *** FROGGS[mobile] joined
[14:36] *** berekuk joined
[14:41] *** treehug88 joined
[14:41] *** lue joined
[14:50] *** treehug88 left
[14:50] <masak> hehe. http://xkcd.com/1306/

[14:54] *** rurban1 joined
[14:56] <masak> I'm toying with a DSL, and though it's not finalized yet, the parameters have a $ sigil.

[14:56] <masak> mostly to avoid collisions with other terms in the language.

[14:56] *** berekuk left
[14:56] *** berekuk joined
[14:57] <masak> I could remove the sigils, but then I'd need scoping to disambiguate some things.

[14:58] *** filly left
[15:03] *** berekuk left
[15:09] *** berekuk joined
[15:09] <timotimo> how do you feel about the concept of putting a number, then a sigil, then the name, to reference an exact variable based on lexpad depth? :P

[15:09] <timotimo> sounds like a great feature for languages

[15:09] <timotimo> "even harder to refactor without an IDE than java!"

[15:12] <timotimo> hey, that way you could turn a definition into just "0$foo"

[15:12] <timotimo> actually

[15:12] <timotimo> -1$foo would be the definition and 0$foo is access in the direct sibling scope/lexpad/depth/thingie

[15:12] *** pmurias joined
[15:20] <masak> timotimo: parsing-wise, it feels too close to integer literals.

[15:20] <rindolf> Hi all! How can I add a new method .sum to List to do [+]?

[15:20] *** pjcj left
[15:21] <masak> timotimo: I'd prefer something like $OUTER::foo

[15:21] *** pjcj joined
[15:21] <masak> p: sub sum(@list) { [+] @list }; say (1, 2, 3, 4, 5).&sum

[15:21] <camelia> rakudo-parrot 263aa0: OUTPUT«15␤»

[15:22] <masak> rindolf: ^^ like that.

[15:22] <rindolf> masak: OK, is there anyway I can use ".sum" instead of ".&sum"?

[15:23] <grondilu> MONKEY_TYPING

[15:23] <[Coke]> make it a method instead of a sub.

[15:23] *** pmurias left
[15:23] <grondilu> use MONKEY_TYPING; augment class List { method sum { [+] self } };

[15:24] <masak> p: use MONKEY_TYPING; augment class Parcel { method sum { [+] self } }; say (1, 2, 3).sum

[15:24] <camelia> rakudo-parrot 263aa0: OUTPUT«6␤»

[15:24] *** denisboyun left
[15:24] <rindolf> masak: thanks.

[15:24] <masak> p: method sum(@list:) { [+] @list }; say (1, 2, 3, 4, 5).sum

[15:24] <camelia> rakudo-parrot 263aa0: OUTPUT«Useless declaration of a has-scoped method in mainline (did you mean 'my method sum'?)␤No such method 'sum' for invocant of type 'Parcel'␤  in block  at /tmp/uOtfV109KG:1␤␤»

[15:25] <masak> p: my method sum(@list:) { [+] @list }; say (1, 2, 3, 4, 5).sum

[15:25] <camelia> rakudo-parrot 263aa0: OUTPUT«No such method 'sum' for invocant of type 'Parcel'␤  in block  at /tmp/GtXer0ZZ1F:1␤␤»

[15:25] <masak> [Coke]: nope, that isn't enough :)

[15:25] <rindolf> Also, what is the equivalent of List::MoreUtils::any in Perl 6?

[15:25] <masak> [Coke]: (fortunately)

[15:25] <masak> rindolf: .any.Bool, prehaps?

[15:25] <rindolf> masak: what?

[15:25] <masak> p: say (True, False, False).any

[15:26] <camelia> rakudo-parrot 263aa0: OUTPUT«any(True, False, False)␤»

[15:26] <masak> p: say (True, False, False).any.Bool

[15:26] <camelia> rakudo-parrot 263aa0: OUTPUT«True␤»

[15:26] <rindolf> masak: I want to evaluate and short-circuit a predicate though.

[15:26] <masak> p: say ?(True, False, False).any # works, too

[15:26] <camelia> rakudo-parrot 263aa0: OUTPUT«True␤»

[15:26] <moritz> p: say 'e' eq any <a b c d e>

[15:26] <camelia> rakudo-parrot 263aa0: OUTPUT«any(False, False, False, False, True)␤»

[15:26] <moritz> p: say so 'e' eq any <a b c d e>

[15:26] <camelia> rakudo-parrot 263aa0: OUTPUT«True␤»

[15:26] <masak> rindolf: then just any() a map()

[15:26] <rindolf> masak: ah, will it short circuit?

[15:27] <masak> ...no.

[15:27] <rindolf> masak: oh.

[15:27] <masak> at least I don't know of any optimizer that does that.

[15:27] <rindolf> masak: should it short-circuit?

[15:27] <rindolf> In theory?

[15:27] <masak> it has hyper semantics rather than lazy semantics, so... maybe not.

[15:27] <masak> but it certainly could.

[15:27] <masak> maybe :)

[15:28] <colomon> grep

[15:29] <colomon> but that requires the input list to be lazy to short-circuit

[15:30] <colomon> r: my @a := 1, 1, *+* … *; if @a.grep(* > 20) { say "Worked"; };

[15:30] <camelia> rakudo-parrot 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/lqeT7JrTsu␤Two terms in a row␤at /tmp/lqeT7JrTsu:1␤------> [32mmy @a := 1, 1, *+* [33m⏏[31m… *; if @a.grep(* > 20) { say "Worked"; [0m␤    expecting any of:␤        postfix␤   …»

[15:30] <camelia> ..rakudo-jvm 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/HyOYKcyRDp␤Two terms in a row␤at /tmp/HyOYKcyRDp:1␤------> [32mmy @a := 1, 1, *+* [33m⏏[31m… *; if @a.grep(* > 20) { say "Worked"; [0m␤    expecting any of:␤        postfix␤      …»

[15:32] <masak> rindolf: there's also .first which might serve you here.

[15:32] <colomon> ugh, idiot IRC client is converting … to as single Unicode character.

[15:32] * colomon supposes Rakudo probably should support that

[15:33] <masak> p: if [1..100].first({ $_ > 50 && $_ %% 3 }) -> $value { say "Look, I found $value!" }

[15:33] <colomon> masak: I think grep is preferable in this case.

[15:33] <camelia> rakudo-parrot 263aa0: OUTPUT«Look, I found 51!␤»

[15:33] <masak> p: if [1..100].first({ $_ > 50 && $_ % 10 == 3 }) -> $value { say "Look, I found $value!" }

[15:33] <camelia> rakudo-parrot 263aa0: OUTPUT«Look, I found 53!␤»

[15:33] <colomon> p: if [1..20].first({ $_ > 50 && $_ % 10 == 3 }) -> $value { say "Look, I found $value!" }

[15:33] <masak> colomon: depends if you want the first, or all of the values, I guess.

[15:33] <camelia> rakudo-parrot 263aa0: ( no output )

[15:34] <rindolf> OK, why does this program take such a long time? http://pastie.org/8623862 .

[15:34] <colomon> masak: no, no, when you call .Bool on it, grep only returns whether there was a value

[15:34] <colomon> p: if [-20..20].first({ $_ == 0 }) -> $value { say "Look, I found $value!" }

[15:34] <camelia> rakudo-parrot 263aa0: ( no output )

[15:34] <masak> colomon: in such a scenario, I would use .first to get the short-circuiting.

[15:35] <masak> colomon: yes, semi-predicate problem alert, I know :)

[15:35] <colomon> .grep does short-circuiting in this use AND it doesn't matter whether the value returned is true or no.

[15:36] <colomon> p: if [-20..20].grep({ $_ == 0 }) { say "Look, I found it!" }

[15:36] <camelia> rakudo-parrot 263aa0: OUTPUT«Look, I found it!␤»

[15:36] <colomon> p: if [-20..20].first({ $_ == 0 }) { say "Look, I found it!" }

[15:36] <camelia> rakudo-parrot 263aa0: ( no output )

[15:36] <colomon> p: if *-20..*).grep({ $_ == 0 }) { say "Look, I found it!" }

[15:36] <camelia> rakudo-parrot 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/RrLvk2TdDJ␤Missing block␤at /tmp/RrLvk2TdDJ:1␤------> [32mif *-20..*[33m⏏[31m).grep({ $_ == 0 }) { say "Look, I found[0m␤    expecting any of:␤        postfix␤        parameteriz…»

[15:36] <colomon> p: if (-20..*).grep({ $_ == 0 }) { say "Look, I found it!" }

[15:36] <camelia> rakudo-parrot 263aa0: OUTPUT«Look, I found it!␤»

[15:37] <masak> rindolf: dunno.

[15:37] <masak> rindolf: doesn't look overly inefficient to me.

[15:37] <masak> rindolf: suggest benchmarking :)

[15:38] <masak> colomon: .grep does short-circuiting? I didn't know.

[15:38] <masak> that's nice, then.

[15:38] <colomon> masak: grep is lazy, and List.Bool returns true as soon as it finds the first element of the list

[15:39] *** lue left
[15:41] <rindolf> masak: hmmm... it's pretty slow in Perl 5 too.

[15:41] <rindolf> masak: maybe only the Lisp version was fast.

[15:43] <timotimo> rindolf: you may be interested in [&&]

[15:43] <timotimo> er, i meant [||]

[15:44] <timotimo> i think it will short-circuit, but i'm not sure.

[15:44] <timotimo> r: say [||] 0, 0, 0, False, True, 0, 1

[15:44] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«True␤»

[15:44] <timotimo> r: say [||] 0, 0, 0, False, "aye", 0, 1

[15:44] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«aye␤»

[15:44] <rurban1> rindolf: do have a euler lisp version to test?

[15:44] <rindolf> rurban1: I do.

[15:45] <rurban1> found one on github

[15:45] <rindolf> rurban1: https://bitbucket.org/shlomif/project-euler/src/f8e87cee230143ee4d8cb45052ccb0bbd6444e20/project-euler/23.lisp?at=default - here.

[15:46] <rindolf> It's in Common Lisp.

[15:46] <timotimo> r: say [||] gather loop { my $res = (False, 0, "", $(), True).pick; say $res; $res };

[15:46] <rindolf> But requires the memoize module.

[15:46] *** berekuk left
[15:46] <rurban1> it'2 hashing the intermediate result and rcurry is pretty fast

[15:46] <timotimo> hm, that infiniloops? :(

[15:46] <rurban1> https://github.com/emef/euler/blob/master/23/p23.lisp

[15:46] <camelia> rakudo-jvm 263aa0: OUTPUT«(timeout)␤False␤0␤0␤␤␤True␤False␤␤␤␤0␤0␤True␤␤True␤False␤True␤␤False␤True␤␤0␤␤␤0␤False␤␤␤␤␤0␤True␤False␤0␤0␤False␤0␤0␤False␤0␤␤True␤0␤␤␤␤␤␤␤True␤␤␤0␤…»

[15:46] <camelia> ..rakudo-parrot 263aa0: OUTPUT«(timeout)False␤␤0␤True␤␤True␤False␤␤True␤␤0␤␤False␤0␤True␤␤␤␤True␤␤0␤True␤0␤True␤␤␤␤␤0␤False␤␤␤True␤␤0␤False␤␤False␤0␤␤0␤True␤0␤0␤True␤␤True␤0␤0␤True␤␤0…»

[15:46] * timotimo is not happy about that

[15:47] <timotimo> but yeah, first should do the trick.

[15:48] <rurban1> clisp crashes with a stack overflow in this one :)

[15:49] <masak> colomon: ooh

[15:49] * timotimo clisps rurban1

[15:49] *** berekuk joined
[15:49] <masak> p: if (1 .. 100_000).grep({ $_ %% 10}) { say "found!" }

[15:49] <rurban1> but sbcl is pretty fast indeed, 2.5s time sbcl --script p23.lisp --quit

[15:49] <camelia> rakudo-parrot 263aa0: OUTPUT«found!␤»

[15:50] <masak> colomon: that's nice! :D

[15:50] <masak> colomon++

[15:50] <arnsholt> timotimo: There's no take in your gather

[15:50] <arnsholt> That probably makes a difference =)

[15:52] <rurban1> the lisp version with a typed array has the same speed as the hash or memoized version. 2.5s

[15:54] *** lue joined
[15:55] <arnsholt> Huh, apparently it loops with the take as well...

[15:56] <colomon> rindolf, masak: seems like just is_abundant is very slow?  I'm trying to just calculate the abundant numbers from 1 to 28,123, and it's taking a distressingly long time.

[15:57] <timotimo> arnsholt: oops! :D

[15:57] <timotimo> r: say [||] gather loop { my $res = (False, 0, "", $(), True).pick; say $res; take $res };

[15:57] <timotimo> hm.

[15:58] <camelia> rakudo-jvm 263aa0: OUTPUT«(timeout)0␤True␤␤␤0␤0␤True␤␤False␤False␤True␤␤False␤False␤␤0␤␤0␤␤True␤␤False␤True␤False␤␤␤␤0␤␤␤␤␤0␤True␤␤␤␤0␤␤True␤␤0␤␤0␤0␤False␤True␤True␤␤False␤␤False␤…»

[15:58] <camelia> ..rakudo-parrot 263aa0: OUTPUT«(timeout)True␤True␤False␤False␤True␤␤True␤False␤0␤True␤True␤␤0␤True␤False␤True␤True␤␤False␤␤0␤False␤␤True␤False␤True␤True␤0␤␤␤␤False␤␤␤␤␤␤␤0␤␤␤␤False␤␤False␤␤␤0…»

[15:58] <arnsholt> Looks like [||] might not short circuit properly

[15:58] *** kivutar left
[15:58] *** Psyche^_ joined
[16:00] <timotimo> [...] may not know about the short-circuiting nature of whatever you plug in

[16:01] <arnsholt> I think it's specced to do the right thing, but Rakudo might not implement it yet

[16:01] <timotimo> yup

[16:01] <rindolf> colomon: https://bitbucket.org/shlomif/project-euler/src/667b90132862168fd847b40333eabb03adc306ed/project-euler/23/euler-23-2.pl?at=default - optimised.

[16:01] <timotimo> it would surprise me greatly if it *weren't* specced to DTRT

[16:01] <timotimo> this is a very straight forward case of DTRT at first glance :P

[16:03] <rindolf> I did the divisors_sum in a less braindead manner.

[16:03] *** Psyche^ left
[16:04] *** berekuk left
[16:05] *** berekuk joined
[16:05] <masak> arnsholt, timotimo: nope.

[16:05] <masak> S03:

[16:05] <masak> "Similarly, list-associative operators that have the thunk-izing characteristics of

[16:05] <masak> macros (such as short-circuit operators) lose those macro-like characteristics.

[16:05] <masak> You can say

[16:05] <masak> [||] a(), b(), c(), d()

[16:05] <masak> to return the first true result, but the evaluation of the list is controlled

[16:05] <masak> by the semantics of the list, not the semantics of C<||>."

[16:08] <arnsholt> Oh!

[16:11] <arnsholt> In that case, I recant my previous heresy =)

[16:12] <timotimo> d'aaw

[16:13] <timotimo> well, we have so grep

[16:13] <colomon> rindolf: I'm still looking at the p6 version.  just calculating the adbundant numbers in that range is INCREDIBLY slow.

[16:16] <rindolf> colomon: the Perl 6 version leaves a lot to be desired.

[16:17] <colomon> rindolf: I am working on it.  ;)

[16:17] <rindolf> colomon: you can do it better.

[16:17] <rindolf> colomon: ah, OK.

[16:17] <colomon> rindolf: that I don't know

[16:17] <colomon> I'm playing with ideas right now.

[16:17] *** araujo left
[16:18] *** araujo joined
[16:18] *** araujo left
[16:19] *** araujo joined
[16:19] *** berekuk left
[16:19] <colomon> calculating is-abundant for just 20000..20025 takes 42 seconds in rakudo-jvm

[16:20] *** araujo left
[16:24] *** berekuk joined
[16:25] *** araujo joined
[16:25] <rindolf> https://bitbucket.org/shlomif/project-euler/src/3e29f82dedb0392753c5d65f048333445c968f73/project-euler/23/euler-23-4.pl?at=default - this takes under 3s. :-)

[16:29] * rindolf is away - shower.

[16:31] * colomon is trying to figure out how to quickly find all the divisors of a number in p6

[16:31] *** atroxaper joined
[16:32] <rurban1> under 3s is comparable to common lisp (2.5s) good

[16:32] * colomon doubts he'll get p6 there today

[16:34] <rurban1> rindolf: this needs no external deps: https://github.com/emef/euler/blob/master/23/p23.lisp

[16:34] <rurban1> this neither: https://github.com/howeyc/cl-euler/blob/master/023.lisp (array version)

[16:42] <grondilu> I wonder why is lisp so fast.  I mean, if we make a straightfoward translation of a lisp code into perl, why wouldn't be the translated code as fast?

[16:43] <rurban1> because lisp has a better compiler, data structures and optimizer

[16:44] <rurban1> clisp not so, but sbcl and better lisps for sure

[16:45] <rurban1> clisp is more the perl of the lisps, fast io, numbers but bad data structures and optimizer. and no native code compiler

[16:45] <rurban1> and no threads!

[16:46] *** Piers joined
[16:46] <grondilu> couldn't perl steal lisp's data structures and compiling methods?

[16:47] <geekosaur> not easily

[16:47] <arnsholt> We could, but then it'd be a Lisp rather than Perl =)

[16:50] <japhb> Plus which, Rakudo's performance problem is not lack of skill and knowledge amongst the implementors.  It's lack of *tuits* from same.

[16:50] <japhb> That is happily progressing, but it takes time.

[16:50] *** FROGGS[mobile] left
[16:51] *** FROGGS[mobile] joined
[16:51] * colomon just wrote [*] @factors Z** @bwd;  which makes him very happy

[16:53] *** pjcj left
[16:54] <geekosaur> yes. the likes of SBCL has had years to go from "works" to "fast"

[16:54] <colomon> r: say 28123/2

[16:54] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«14061.5␤»

[16:54] <grondilu> do we still hope that Perl 6 will be lightning fast one day?

[16:55] <colomon> r: say 28123/2/60

[16:55] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«234.358333␤»

[16:55] <masak> grondilu: I know I do.

[16:55] <geekosaur> (well, SBCL has always had a reputation for speed, but that's because the reference implementations were also much slower back then :)

[16:58] <japhb> grondilu: My hope is that it A) makes effective use of concurrency in most of the places the spec allows/suggests it, B) starts quickly enough to be useful for implementing quickie one-shot tools, and C) with proper use of type annotations and possibly other hints, can be fast enough to fill the long-lived process roles that Perl 5, Python, and Ruby do now.

[16:58] <colomon> r: say 28123/7/60

[16:58] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«66.959524␤»

[16:59] <rindolf> What's the best way to implement a vector of bits in Perl 6/Rakudo? Something like vec($buffer, $offset, 1) in Perl 5.

[16:59] <japhb> I do not expect Perl 6 to be as fast as, say, asm.js, but you never know.  Perhaps for particular tasks?

[16:59] <rurban1> grondilu: yes. see p2

[17:00] *** zakharyas joined
[17:00] <grondilu> what worries me though is that Perl 6 is slow even for simple stuff.  I mean, just counting up to 1000 is slow.  I don't understand what slows such a program:  .say for ^1000

[17:00] <japhb> rindolf: In fully-implemented Perl6, 'my bit @array', as I recall.  But that's not implemented in Rakudo.

[17:00] <rindolf> japhb: ah.

[17:01] *** berekuk left
[17:02] <japhb> grondilu: I don't think that's intrinsic.  I think it's "unexplored parts of optimization space, where currently we are using pessimized-but-easier-to-reason-about"

[17:03] *** ajr joined
[17:03] <japhb> grondilu: Try using loop or while instead of for-range, and see how much faster it is.

[17:03] *** beastd left
[17:03] *** ajr is now known as Guest43709

[17:03] <grondilu> I just tried loop (my int $i = 0; $i < 1000; $i = $i + 1) { say $i }

[17:03] <japhb> Unfortunately, the idiomatic version happens to be the least optimized.

[17:03] <grondilu> it's still much slower than Perl 5

[17:04] <arnsholt> There are a lot of things going on behind the scenes

[17:04] <japhb> grondilu: Well yeah, that's not a fair comparison.

[17:04] <arnsholt> Like laziness

[17:05] *** zakharyas left
[17:05] <japhb> I should clarify: Expecting Rakudo to be as fast as perl5 *right now* isn't really fair -- perl5 has had a LOT of optimization, and has simpler semantics to boot.  Expecting it to *one day* be as fast -- that's fair.

[17:06] *** pecastro left
[17:08] *** pecastro joined
[17:10] <rurban1> actually perl5 has not much optimizations. rakudo already has better ones

[17:10] <rindolf> OK, that's it. I've tried to search for a long time for how to write Perl 5-like loop labels (like "last MYLOOP;" or "next MYLOOP;") in Perl 6 and could not find anything. http://perlcabal.org/syn/Differences.html - perhaps it should be added to this.

[17:11] <japhb> r: my $t1 = now; my $i = 0; for ^1000 { $i++ }; my $t2 = now; loop (my $j = 0; $j < 1000; $j++) {}; my $t3 = now; my $k = 0; while $k < 1000 { $k++ }; my $t4 = now; say $i, $j, $k; say $t2 - $t1, $t3 - $t2, $t4 - $t1;

[17:11] <camelia> rakudo-jvm 263aa0: OUTPUT«100010001000␤0.0380.0290.84␤»

[17:11] <camelia> ..rakudo-parrot 263aa0: OUTPUT«100010001000␤0.108054280.03896200.1893130␤»

[17:12] <japhb> r: my $t1 = now; my $i = 0; for ^1000 { $i++ }; my $t2 = now; loop (my $j = 0; $j < 1000; $j++) {}; my $t3 = now; my $k = 0; while $k < 1000 { $k++ }; my $t4 = now; say $i, $j, $k; ($t2 - $t1, $t3 - $t2, $t4 - $t1).join(', ').say;

[17:12] <camelia> rakudo-jvm 263aa0: OUTPUT«100010001000␤0.032, 0.027, 0.086␤»

[17:12] <camelia> ..rakudo-parrot 263aa0: OUTPUT«100010001000␤0.112052, 0.0353488, 0.195029␤»

[17:12] <japhb> The while loop is slow on jvm ... wat?

[17:12] <japhb> Actually, it's slow on both.  Double wat.

[17:13] <japhb> OH!

[17:13] <japhb> Duh, typo

[17:13] <japhb> r: my $t1 = now; my $i = 0; for ^1000 { $i++ }; my $t2 = now; loop (my $j = 0; $j < 1000; $j++) {}; my $t3 = now; my $k = 0; while $k < 1000 { $k++ }; my $t4 = now; say $i, $j, $k; ($t2 - $t1, $t3 - $t2, $t4 - $t3).join(', ').say;

[17:13] <camelia> rakudo-jvm 263aa0: OUTPUT«100010001000␤0.03, 0.028, 0.029␤»

[17:13] <camelia> ..rakudo-parrot 263aa0: OUTPUT«100010001000␤0.1108109, 0.0411369, 0.0422413␤»

[17:13] <japhb> *phew*

[17:15] <japhb> rindolf: top of S04 talks about labels.

[17:15] <rindolf> japhb: OK.

[17:16] <japhb> r: my $max = 10_000; my $t1 = now; my $i = 0; for ^$max { $i++ }; my $t2 = now; loop (my $j = 0; $j < $max; $j++) {}; my $t3 = now; my $k = 0; while $k < $max { $k++ }; my $t4 = now; say $i, $j, $k; ($t2 - $t1, $t3 - $t2, $t4 - $t3).join(', ').say;

[17:16] <camelia> rakudo-jvm 263aa0: OUTPUT«100001000010000␤1.011, 0.168, 0.132␤»

[17:16] <camelia> ..rakudo-parrot 263aa0: OUTPUT«100001000010000␤0.2568166, 0.2904760, 0.26705334␤»

[17:16] <japhb> r: my $max = 100_000; my $t1 = now; my $i = 0; for ^$max { $i++ }; my $t2 = now; loop (my $j = 0; $j < $max; $j++) {}; my $t3 = now; my $k = 0; while $k < $max { $k++ }; my $t4 = now; say $i, $j, $k; ($t2 - $t1, $t3 - $t2, $t4 - $t3).join(', ').say;

[17:16] <camelia> rakudo-jvm 263aa0: OUTPUT«100000100000100000␤0.504, 0.498, 0.498␤»

[17:16] <camelia> ..rakudo-parrot 263aa0: OUTPUT«100000100000100000␤1.96252715, 2.8407922, 2.8942043␤»

[17:17] <rindolf> japhb: http://feather.perl6.nl/syn/S04.html - there doesn't seems to be a meaningful/usable example.

[17:17] <rindolf> Or maybe they are elided?

[17:17] <japhb> rindolf: Line 347 and following.

[17:18] <rindolf> japhb: what is Line 347? In the source?

[17:18] <rindolf> japhb: http://feather.perl6.nl/syn/S04.html - I'm talking about this.

[17:18] <arnsholt> Rakudo doesn't implement loop labels yet, though, does it?

[17:18] <japhb> It basically says next LABEL is sugar for LABEL.next

[17:18] <japhb> synopsebot: S04:347

[17:18] <synopsebot> japhb: Link: http://perlcabal.org/syn/S04.html#line_347

[17:19] <japhb> arnsholt: I don't recall -- I thought someone discussed it a month or two ago, but I dunno if they actually did anything.

[17:19] <rindolf> japhb: OK, I seem to have done it.

[17:20] <FROGGS> I implemented labels for nqp in a branch

[17:20] <rindolf> japhb: http://pastie.org/8624071 - that's my code.

[17:21] <japhb> FROGGS++ # mergeable?

[17:21] *** Guest43709 is now known as ajr_

[17:21] <FROGGS> japhb: reviewable by jnthn :o)

[17:21] <japhb> Ah, heh.  :-)

[17:21] <rindolf> And I'm getting errors: «Undeclared name: INNER used at line 59»

[17:22] <rindolf> I can try wrapping it in a closure and using return.

[17:22] <rindolf> FROGGS++

[17:24] <japhb> BTW, I find it interesting that between 10_000 and 100_000 in that loop test above, the performance profiles of r-j and r-m completely changed.  r-j equalized the performance of all of them, and r-p just made for-range relatively more efficient each time $max increased.

[17:25] <japhb> r: my $max = 1_000_000; my $t1 = now; my $i = 0; for ^$max { $i++ }; my $t2 = now; loop (my $j = 0; $j < $max; $j++) {}; my $t3 = now; my $k = 0; while $k < $max { $k++ }; my $t4 = now; say $i, $j, $k; ($t2 - $t1, $t3 - $t2, $t4 - $t3).join(', ').say;

[17:25] <grondilu> as if parrot had to warm up or something? :)

[17:25] <rindolf> japhb: so what should I do now?

[17:25] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«(timeout)»

[17:26] <japhb> r: my $max = 200_000; my $t1 = now; my $i = 0; for ^$max { $i++ }; my $t2 = now; loop (my $j = 0; $j < $max; $j++) {}; my $t3 = now; my $k = 0; while $k < $max { $k++ }; my $t4 = now; say $i, $j, $k; ($t2 - $t1, $t3 - $t2, $t4 - $t3).join(', ').say;

[17:26] <rindolf> japhb: should I wrap it in a closure and use "return;"?

[17:26] <camelia> rakudo-jvm 263aa0: OUTPUT«200000200000200000␤0.669, 0.901, 1.094␤»

[17:26] <camelia> ..rakudo-parrot 263aa0: OUTPUT«(timeout)»

[17:27] * japhb wonders what the JVM has surmised about for-range

[17:28] *** nebuchadnezzar left
[17:28] *** nebuchadnezzar joined
[17:28] <japhb> rindolf: That's definitely a possibility, though IIRC you take a perf hit from the semantics of return there.

[17:29] <rindolf> japhb: ah.

[17:29] <japhb> But my big question is: Why are you fighting for performance on this?

[17:29] <japhb> Just an intellectual exercise?

[17:29] <rindolf> japhb: I'm not, it's just that I *must* terminate the loop prematurely or I'll keep track of bigger numbers that will skew the results.

[17:30] <japhb> OIC.  Yeah, return from a closure then.

[17:30] *** raiph joined
[17:30] <rindolf> japhb: OK.

[17:31] <timotimo> if we could prove that the loop in for $start..$end will be sunk, we could transform it into a loop instead

[17:32] <timotimo> at optimize-time

[17:32] <timotimo> is that enough analysis?

[17:32] *** raiph left
[17:33] <timotimo> because i think void context is already something we track in the optimizer anyway

[17:33] *** raiph2 joined
[17:33] *** raiph joined
[17:34] <arnsholt> I'd think so, yeah

[17:35] <arnsholt> Modulo shenanigans with pointy blocks, optional arguments and such, possibly

[17:35] <timotimo> things like next/last and FIRST/NEXT/UNDO should Just Work after the transformation, right?

[17:35] *** slavik left
[17:35] <rindolf> r: [ sub { 5+6 }.() ];

[17:35] <camelia> rakudo-jvm 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/DYK50yrMy3␤Two terms in a row␤at /tmp/DYK50yrMy3:1␤------> [32m[ sub { 5+6 }[33m⏏[31m.() ];[0m␤    expecting any of:␤        postfix␤        statement end␤        statement modifi…»

[17:35] <camelia> ..rakudo-parrot 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/5z3dTC6LIp␤Two terms in a row␤at /tmp/5z3dTC6LIp:1␤------> [32m[ sub { 5+6 }[33m⏏[31m.() ];[0m␤    expecting any of:␤        postfix␤        statement end␤        statement mod…»

[17:36] <rindolf> r: [ (sub { 5+6 }).() ];

[17:36] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: ( no output )

[17:36] <rindolf> Hmmm....

[17:36] <timotimo> finding i think there's a ticket about that somewhere actually

[17:36] *** kaare_ joined
[17:36] <timotimo> std: [ sub { 5 + 6 }.() ];

[17:36] <camelia> std 09dda5b: OUTPUT«ok 00:01 127m␤»

[17:36] <timotimo> rakudo is in the wrong here.

[17:37] <rindolf> std: [ sub { 5 + 6 }() ]

[17:37] <camelia> std 09dda5b: OUTPUT«ok 00:01 127m␤»

[17:38] *** treehug88 joined
[17:48] <japhb> rindolf: Looking at http://pastie.org/8624071 again, why are you trying to use loop labels?  The place you want to early exit out of isn't multiply-nested in loops.  You should just be able to 'last;' there.

[17:49] *** slavik joined
[17:49] <timotimo> indeed

[17:49] <japhb> Erm, to be clearer, you aren't trying to last out of multiple levels of loops.

[17:49] <rindolf> japhb: yes, but I always like labels for good measure - http://perl-begin.org/tutorials/bad-elements/#flow-stmts-without-labels ( also see Perl Best Practices ).

[17:49] *** jeffreykegler joined
[17:49] <timotimo> then use the special syntax for loop labels that is already implemented in rakudo

[17:50] <timotimo> #| INNER:

[17:50] <japhb> Heh

[17:50] <timotimo> for ^10 { last; #= INNER\n }

[17:52] <rindolf> Well, I'll wait.

[17:53] <rindolf> Can I (= shlomif on GitHub) get a commit bit for https://github.com/perl6/perl6-examples ?

[17:53] <rindolf> I don't seem to have one.

[17:55] *** denis_boyun joined
[17:57] <colomon> rindolf: I don't seem to have the power to grant one.  :\

[18:01] <rindolf> colomon: OK.

[18:02] <TimToady> I think I added you

[18:02] <TimToady> try it

[18:02] *** kaare_ left
[18:03] <timotimo> TimToady: what's your insight on transforming a for $start..$end into a c-style loop if it's in void context?

[18:04] <TimToady> have to worry about scoping the loop var

[18:04] *** FROGGS[mobile] left
[18:04] *** FROGGS[mobile] joined
[18:04] <timotimo> putting it into the loop(^here^) won't do it properly?

[18:04] <TimToady> nope

[18:04] <timotimo> good to know; would have to make a new lexical scope around it i suppose?

[18:05] <timotimo> i think that is equal to making a QAST::Block at the QAST level

[18:05] *** ssutch left
[18:05] <TimToady> you'd probably need to add an OUTER to any existing OUTER's as well

[18:05] <TimToady> well, maybe not

[18:06] <timotimo> don't think so, the for itself would do that, too

[18:06] <TimToady> well, maybe

[18:06] <timotimo> except of course if it's a postfix-for

[18:07] <TimToady> if you ref $OUTER::OUTER::foo inside the loop, you probably have to add an OUTER

[18:07] *** treehug88 left
[18:07] *** ssutch joined
[18:07] <TimToady> unless we have a way of add invisible outer levels

[18:07] <timotimo> oh, because the loop has *another* { } around the loop body

[18:08] <TimToady> *adding

[18:08] <timotimo> is something like CALLER::OUTER:: allowed?

[18:08] <TimToady> which is more or less what P5 does, but then P5 doesn't have OUTER

[18:09] <TimToady> afk for a bit

[18:13] *** hummeleBop1 joined
[18:13] *** pecastro left
[18:14] *** hummeleBop left
[18:19] <hoelzro> ahoy #perl6

[18:20] <hoelzro> r: my %int-hash{Int}; %int-hash{5}:delete

[18:20] <camelia> rakudo-parrot 263aa0: OUTPUT«Nominal type check failed for parameter 'key'; expected Int but got Str instead␤  in method at_key at gen/parrot/CORE.setting:9101␤  in method delete_key at gen/parrot/CORE.setting:8949␤  in method delete_key at gen/parrot/CORE.setting:8946␤  in …»

[18:20] <camelia> ..rakudo-jvm 263aa0: OUTPUT«Nominal type check failed for parameter 'key'␤  in method delete_key at gen/jvm/CORE.setting:8924␤  in block  at gen/jvm/CORE.setting:1885␤␤»

[18:20] <hoelzro> bug?

[18:20] *** pecastro joined
[18:24] <rindolf> TimToady: thanks! I was added - https://github.com/organizations/perl6/teams/14366

[18:24] <rindolf> TimToady++

[18:24] <dalek> perl6-examples: 2460f31 | (Shlomi Fish)++ | euler/prob023-shlomif.pl:

[18:24] <dalek> perl6-examples: [Euler] Add solution to No. 23.

[18:24] <dalek> perl6-examples: 

[18:24] <dalek> perl6-examples: Slow on rakudo-jvm but it works.

[18:24] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/2460f310dd

[18:27] <timotimo> r: my %foo

[18:27] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: ( no output )

[18:27] <timotimo> er

[18:27] <timotimo> r: my %foo[Int]; say %foo{5}:exists;

[18:27] <camelia> rakudo-jvm 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/y0zEyaq_gl␤Shaped variable declarations not yet implemented. Sorry. ␤at /tmp/y0zEyaq_gl:1␤------> [32mmy %foo[Int][33m⏏[31m; say %foo{5}:exists;[0m␤»

[18:27] <camelia> ..rakudo-parrot 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/FpSv33HIvY␤Shaped variable declarations not yet implemented. Sorry. ␤at /tmp/FpSv33HIvY:1␤------> [32mmy %foo[Int][33m⏏[31m; say %foo{5}:exists;[0m␤»

[18:28] <TimToady> delete_key has an 'as Str', which is an obvious bug

[18:29] <TimToady> it should only coerce to Str on an unshaped array

[18:29] <TimToady> lizmat: ^^

[18:37] *** atroxaper left
[18:41] <rindolf> real    2m55.630s ; user    3m14.125s - wow! Ouch. :-(

[18:41] <rindolf> Let me try it with last.

[18:41] <rindolf> Last with no label .

[18:43] <rindolf> It still consumes 14.4% of my 8 GB RAM. :-(

[18:44] *** thou joined
[18:46] <rindolf> real    3m10.957s ; user    3m32.662s ==> didn't help.

[18:50] <timotimo> sorry to hear that :(

[18:50] <timotimo> i'm also sad about rakudo's performance quite often

[18:52] *** darutoko left
[18:58] *** thou left
[18:59] <japhb> Well, at least there's lots of room for optimization.  Which is to say, it's not like it has reparse-on-every-iteration semantics that would guarantee it slow.

[19:05] <dalek> nqp: fdc0be3 | (Tobias Leich)++ | src/vm/moar/QAST/QASTRegexCompilerMAST.nqp:

[19:05] <dalek> nqp: look up block when rule is <:InSomething>

[19:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fdc0be32b1

[19:08] *** hummeleBop1 left
[19:11] *** thou joined
[19:18] <masak> there's some excellent prior art on optimizing language implementations with the same kind of late-binding characteristics as Perl 6. Strongtalk comes to mind.

[19:19] <masak> the biggest reason Rakudo isn't more optimized is "haven't gotten there yet".

[19:26] <arnsholt> Common Lisp as well

[19:27] <arnsholt> The commercial compilers optimise very well when you tell them enough about the types

[19:28] <timotimo> masak: the main reason seems to be "timo doesn't know how to optimize things" :P

[19:28] <FROGGS> hehe

[19:29] <timotimo> jnthn said he wanted to completely redo the structure of the optimizer before adding more things

[19:29] <timotimo> i understand why he'd want to do that

[19:29] <timotimo> but it means i can't add more optimizations :P

[19:33] <hoelzro> so what exactly is the difference between sub my-sub(Str $param) and sub my-sub($param as Str)?

[19:33] *** hoverboard joined
[19:34] <timotimo> i wish i would have known long ago that local vars are not almost directly equivalent to registers. then i wouldn't have tossed my "turn lexicals into locals" optimizations

[19:34] <hoelzro> I'm guessing the latter accepts Any, but coerces to Str?

[19:34] <timotimo> that's it, yeah

[19:34] <hoelzro> cool

[19:35] *** hoverboard left
[19:35] *** hoverboard joined
[19:35] *** hoverboard left
[19:35] *** hoverboard joined
[19:35] *** psch left
[19:35] *** psch joined
[19:36] <dalek> perl6-examples: ec42eb2 | (Shlomi Fish)++ | euler/prob023-shlomif.pl:

[19:36] <dalek> perl6-examples: Add "use v6;" for good measure.

[19:36] <dalek> perl6-examples: 

[19:36] <dalek> perl6-examples: Make it recognise that it's a Perl 6 program.

[19:36] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/ec42eb279f

[19:38] <hoelzro> hmm

[19:38] <hoelzro> I can't find an example of '$param as Type' in roast

[19:38] *** SamuraiJack left
[19:38] <hoelzro> oh, ack is being lazy

[19:39] <hoelzro> hmm

[19:39] <hoelzro> still no finds

[19:40] *** denis_boyun_ joined
[19:40] * hoelzro is trying to find where that as thing is specc'd

[19:40] * hoelzro .oO( Speck'd )

[19:41] <TimToady> it's de-spec'd in favor of Str(Any)

[19:41] *** denis_boyun left
[19:41] <TimToady> but if you can't differentiate the type of object hashes from string hashes nominally, neither 'as' nor 'Str(Any)' is going to help

[19:42] *** aindilis joined
[19:43] <hoelzro> yeah, I thought this might be a bug I could actually fix

[19:43] <hoelzro> it's starting to look harder =/

[19:43] <TimToady> you'd have to use a conditional inside, not a sig match

[19:43] <TimToady> but isn't object hashhood mixed in?

[19:43] <TimToady> you oughta be able to differentiate in the siggie

[19:44] <hoelzro> I think I have to study the hash source more

[19:44] <hoelzro> it's still fairly Greek to me

[19:44] *** hoverboard left
[19:44] *** hoverboard joined
[19:44] *** hoverboard left
[19:44] *** hoverboard joined
[19:45] <hoelzro> hmm

[19:45] *** FROGGS[mobile] left
[19:45] <hoelzro> I suppose

[19:46] *** FROGGS[mobile] joined
[19:46] <hoelzro> that I could remove the coercion from delete_key

[19:46] <hoelzro> and enforce it in at_key?

[19:46] <hoelzro> hmm

[19:46] <hoelzro> but

[19:46] <hoelzro> then I don't think keys would be properly coerced to strings for non-typed hashes.

[19:47] <[Coke]> moar is going to break 95% today!

[19:48] <hoelzro> whoa

[19:48] <hoelzro> \o/

[19:48] <hoelzro> that's incredible

[19:48] <hoelzro> that's 95% JVM tests, right?

[19:48] *** raiph2 left
[19:48] *** raiph left
[19:49] <colomon> !!!!!

[19:51] <[Coke]> http://www.reddit.com/r/perl6/comments/1uqdim/has_anyone_written_a_grammar_for_ldap_search/

[19:51] <[Coke]> aye.

[19:51] <[Coke]> er, hoelzro: aye

[19:51] <hoelzro> sweet

[19:54] *** treehug88 joined
[19:54] *** denis_boyun_ left
[19:57] *** denisboyun joined
[19:57] <grondilu> better yet would be a parser for ABNF grammar, wouldn't it?

[19:57] *** FROGGS[mobile] left
[19:58] *** FROGGS[mobile] joined
[19:58] <grondilu> (though I'm not sure it's possible)

[19:59] *** hoverboard left
[19:59] *** hoverboard joined
[20:00] *** hoverboard is now known as Guest73665

[20:01] *** Guest73665 left
[20:01] *** Guest73665 joined
[20:01] *** Guest73665 is now known as hoverboard

[20:02] *** hoverboard left
[20:02] *** treehug88 left
[20:03] *** hoverboard joined
[20:03] *** hoverboard left
[20:03] *** hoverboard joined
[20:05] *** moistcherry joined
[20:06] *** Diu joined
[20:09] *** treehug88 joined
[20:11] *** treehug88 left
[20:18] *** moistcherry left
[20:18] *** moistcherry joined
[20:18] *** FROGGS[mobile] left
[20:18] *** FROGGS[mobile] joined
[20:18] *** moistcherry is now known as Guest19701

[20:19] <hoelzro> if I *do* end up fixing this bug (spec tests will be running while I'm at a movie), should I add a regression test to the repo?

[20:29] *** Diu left
[20:29] *** Guest19701 left
[20:30] <hoelzro> hmm

[20:30] <hoelzro> also, would it be a bad idea to add a deprecation warning for '$param as TYPE'?

[20:31] <hoelzro> that's probably something else I could do

[20:35] <TimToady> that'd be cool, even if we don't have coercive types yet

[20:35] <TimToady> and yes, tests are good :)

[20:36] <hoelzro> under Rakudo's repo, or roast's?

[20:36] *** raiph2 joined
[20:36] *** raiph joined
[20:36] <TimToady> they're really the same, so doesn't matter

[20:36] <hoelzro> so Str(Any) doesn't work yet, but $param as Str does?

[20:36] <TimToady> but roast is the direct one

[20:36] <TimToady> yes, but 'as' is going away

[20:36] <hoelzro> ok

[20:36] <hoelzro> good to know

[20:37] <hoelzro> so under roast/integration, or the typed hash tests?

[20:37] <TimToady> we can still use 'as', presuming it'll get translated to Str() when that's implemented

[20:37] <hoelzro> mkay

[20:37] <TimToady> typed hash, I'd think

[20:37] <hoelzro> ok

[20:38] <TimToady> but maybe we don't wanna use 'as' if it's deprecated, or vice versa

[20:38] <TimToady> can always use an explicit conversion inside, but then it's harder to spot where a coercive type is wanted

[20:39] <hoelzro> I thought that, but maybe the deprecation warning can wait until Str(Any) is impl'd

[20:39] <hoelzro> then it's easy to convert

[20:39] <TimToady> is also fine

[20:41] <hoelzro> sweet, my patch compiles

[20:42] <hoelzro> and it passes t!

[20:42] *** zakharyas joined
[20:46] *** smls joined
[20:48] <smls> This may be a stupid question, but why do we need a colon between a method name and its arguments, to call it without parenthesis?

[20:49] <smls> Perl 6:  my @numbers = [1, 2, 3].map: { 10 + $_ };

[20:49] <smls> Ruby:    numbers = [1, 2, 3].map { |x| 10 + x };

[20:49] <smls> ^^ other languages get away without it

[20:51] <TimToady> by not being extensible

[20:51] <TimToady> and by not being self-clocking

[20:52] <TimToady> but mainly, we need to know whether method call wants arguments

[20:53] <TimToady> how do you parse $obj.meth + 1 if you don't know whether the + 1 is an argument to .meth?

[20:54] <hoelzro> regarding Hash.pm: what's the difference between bind_key and STORE_AT_KEY? I take it the former has something to do with containers?

[20:54] <smls> TimToday: But why is this only a problem with methods and not subs?

[20:55] <FROGGS> smls: otherwise we would need to force writing $obj.meth() + 1 when you don't want to pass arguments

[20:55] <rindolf> Good night, everybody - thanks for everything.

[20:55] * hoelzro movie &

[20:55] <japhb> o/ rindolf

[20:56] <japhb> And hoelzro, apparently.

[20:56] *** rindolf left
[20:58] <japhb> r: multi sub infix:<*=>(Int $a is rw, Int $b) { say "Snort!"; $a = $a * $b }; my $foo = 5; say $foo *= 6;

[20:58] <camelia> rakudo-parrot 263aa0, rakudo-jvm 263aa0: OUTPUT«Snort!␤30␤»

[20:59] <TimToady> smls: listops don't generally pretend to be variables, but object attributes do that with great frequency

[20:59] <TimToady> afk &

[21:04] *** takesako left
[21:05] *** clsn_ left
[21:09] *** jeffreykegler left
[21:13] *** raiph2 left
[21:13] *** raiph left
[21:13] *** hoverboard left
[21:19] *** hoverboard joined
[21:19] *** hoverboard left
[21:20] *** hoverboard joined
[21:20] *** hoverboard left
[21:20] *** takesako joined
[21:28] *** rurban1 left
[21:31] <psch> i've definitely been missing something for the last few hours

[21:32] <psch> as i wrote a few days back, i have a find_symbol that find's Exception and subtypes

[21:32] <psch> i can even call .new on those

[21:32] <psch> but when i try to hand arguments to .new i get a nominal type check failure for '$got', which doesn't appear anywhere near where i'm doing things

[21:33] <psch> this is all still the optimizer stuff, which i'm developing a similar sentiment as hoelzro developed to coercive types

[21:33] <psch> *sentiment towards

[21:40] <psch> https://gist.github.com/peschwa/8377306 # if i leave out |%opts in line 48, the exception happens and is thrown

[21:41] <psch> (i'm aware that it probably shouldn't be thrown there, but i'm still inching towards "make it work at all" - although maybe that's part of the problem..?)

[21:41] <masak> psch++ # persistence

[21:42] <FROGGS> psch: what if you $*W.p6ize_recursive the %opts when passing it along?

[21:43] <psch> FROGGS: i'll try that

[21:43] *** treehug88 joined
[21:44] <FROGGS> ummm

[21:44] <psch> the $.got in X::ArgumentMismatch?

[21:44] <FROGGS> no, the lines 25 to 36 do that I think

[21:44] <psch> oh

[21:44] <psch> yeah i added the $.got afterwards thinking "maybe..."

[21:45] <psch> and it's still there but doesn't help

[21:45] <psch> anyway, i'm building with another call to p6ize_recursive, for confirmation 

[21:48] <FROGGS> btw, it always complains about a variable called $got when you pass an argument to a sub or method that is Mu

[21:48] <FROGGS> p: sub test($a) { }; a(Mu)

[21:48] <camelia> rakudo-parrot 263aa0: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/PvOL5kXh_F␤Undeclared routine:␤    a used at line 1␤␤»

[21:48] <FROGGS> p: sub test($a) { }; test(Mu)

[21:48] <camelia> rakudo-parrot 263aa0: OUTPUT«Nominal type check failed for parameter '$a'; expected Any but got Mu instead␤  in sub test at /tmp/SVh7oXQyLf:1␤  in block  at /tmp/SVh7oXQyLf:1␤␤»

[21:48] <FROGGS> ohh, hmmm

[21:49] <FROGGS> maybe the $got only shows up in settings or so

[21:49] <FROGGS> so you can comment more elements of you %opts hash, to see which element is not p6y enough

[21:52] <psch> okay, thanks

[21:52] *** ssutch left
[21:53] *** mtk joined
[21:55] *** ajr_ left
[21:56] *** wooden left
[22:05] *** berekuk joined
[22:06] *** wooden joined
[22:09] *** treehug88 left
[22:11] *** smls left
[22:11] <FROGGS> v5 spectest && sleep ===> gnight &

[22:18] *** telex left
[22:18] <psch> alright, it was $protoguilt

[22:19] <psch> thanks and good night FROGGS 

[22:19] *** berekuk left
[22:19] *** berekuk joined
[22:20] *** telex joined
[22:29] *** PacoAir left
[22:41] *** zakharyas left
[22:42] *** treehug88 joined
[23:01] *** grondilu left
[23:03] *** kaare_ joined
[23:09] *** Piers left
[23:11] *** Piers joined
[23:21] *** treehug88 left
[23:26] *** dmol left
[23:43] *** Rotwang left
[23:47] <masak> the notion of intentionally confusing scalars and one-element containers can be found in category theory.

[23:48] *** araujo left
[23:48] <masak> it's called being "monoidal".

[23:49] <masak> in fact, monoidal categories could more generally be seen as a kind of list flattening.

[23:49] <masak> so ((x, y), z) and (x, (y, z)) end up being equivalent.

[23:53] <masak> this has been your daily category theory. good night, #perl6.

[23:53] <psch> night masak 

