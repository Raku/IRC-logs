[00:00] <lollercopter> m: use nqp; for ^10000 {  my $v = "Hostname=This is a-test"; if $v.starts-with: 'Hostname=' { my $x = nqp::join('_', nqp::split('-', nqp::join('_', nqp::split(' ', nqp::substr($v, 9)))))  }  }; say now - INIT now

[00:00] <camelia> rakudo-moar 10f840: OUTPUT: «0.03849455␤»

[00:01] <lollercopter> m: use nqp; my $v = "Hostname=This is a-test"; for ^10000 {  nqp::index($v, 'Hostname=') || nqp::join('_', nqp::split('-', nqp::join('_', nqp::split(' ', nqp::substr($v, 9)))))  }; say now - INIT now

[00:01] <camelia> rakudo-moar 10f840: OUTPUT: «0.0294379␤»

[00:01] <TEttinger> faster as in speed or faster as in amount of code?

[00:02] <lollercopter> m: use nqp; my $v = "Hostname=This is a-test"; nqp::index($v, 'Hostname=') || nqp::join('_', nqp::split('-', nqp::join('_', nqp::split(' ', nqp::substr($v, 9))))).say

[00:02] <camelia> rakudo-moar 10f840: OUTPUT: «This_is_a_test␤»

[00:02] <TEttinger> I mean, those are definitely better on speed

[00:02] <lollercopter> m: use nqp; my $v = "Hostname=This is a-test"; for ^10000 {  }; say now - INIT now

[00:02] <camelia> rakudo-moar 10f840: OUTPUT: «0.0029200␤»

[00:02] *** Cabanossi left
[00:02] <lollercopter> m: say 2.114/.159

[00:02] <camelia> rakudo-moar 10f840: OUTPUT: «13.295597␤»

[00:03] <lollercopter> m: say 2.114/.027

[00:03] <camelia> rakudo-moar 10f840: OUTPUT: «78.296296␤»

[00:03] <lollercopter> Voldenet: so there. 13x faster if you want it pure perl 6 and 78x faster if you don't mind using nqp

[00:04] *** Cabanossi joined
[00:04] *** zacts joined
[00:04] <lollercopter> Voldenet: getting rid of blocks and regexes are generally a way to speed stuff up

[00:05] <lollercopter> Well, I mean a sure-fire way

[00:06] *** mcmillhj joined
[00:07] * lollercopter crawls back into the hole

[00:07] *** lollercopter left
[00:07] *** araujo joined
[00:10] *** cdg_ joined
[00:11] *** mcmillhj left
[00:14] *** cdg left
[00:14] *** mcmillhj joined
[00:15] *** cdg_ left
[00:19] *** mcmillhj left
[00:20] <Voldenet> Nice! :D

[00:25] *** mcmillhj joined
[00:31] *** mcmillhj left
[00:40] *** cdg joined
[00:40] *** mcmillhj joined
[00:43] *** mr-foobar left
[00:44] *** mr-foobar joined
[00:45] *** cdg left
[00:45] *** mcmillhj left
[00:51] *** mcmillhj joined
[00:56] *** zacts left
[00:57] *** mcmillhj left
[01:02] *** Cabanossi left
[01:02] *** mcmillhj joined
[01:04] *** Cabanossi joined
[01:05] *** zacts joined
[01:13] *** mr-foobar left
[01:15] *** mr-foobar joined
[01:19] *** LeCamarade left
[01:29] *** mcmillhj left
[01:29] *** troys is now known as troys_

[01:43] *** mcmillhj joined
[01:43] *** mr-foobar left
[01:45] *** mr-foobar joined
[01:48] *** mcmillhj left
[01:56] *** troys_ is now known as troys

[01:58] *** mcmillhj joined
[02:03] *** mcmillhj left
[02:10] *** mcmillhj joined
[02:11] *** AlexDaniel left
[02:13] *** mr-foobar left
[02:15] *** mcmillhj left
[02:15] *** cyphase left
[02:16] *** mr-foobar joined
[02:20] *** ctilmes left
[02:20] *** cyphase joined
[02:22] *** noganex_ joined
[02:23] <awwaiid> It was nice seeing some of you at TPC-2017-DC (aka YAPC::NA)!

[02:24] *** noganex left
[02:27] *** mcmillhj joined
[02:31] *** troys is now known as troys_

[02:31] *** mcmillhj left
[02:43] *** mr-foobar left
[02:47] *** mr-foobar joined
[02:51] *** mcmillhj joined
[02:56] *** mcmillhj left
[03:00] *** troys_ is now known as troys

[03:02] *** mcmillhj joined
[03:02] <BenGoldberg> So I've got a hard problem, and it doesn't involve cache invalidation or an off by one error ;)

[03:02] *** Cabanossi left
[03:04] *** Cabanossi joined
[03:05] <BenGoldberg> I'm working on some magic so that you can have class Foo with a repr('CStruct'), with attributes in it which can contain subroutines, which will be properly serialized.

[03:06] <BenGoldberg> I'm leaning towards a syntax of: has $foo is fptr :(int32 $arg --> int32);

[03:07] <BenGoldberg> But, I'm unhappy with the "fptr" name :P

[03:07] *** mcmillhj left
[03:08] <BenGoldberg> Could someone suggest a better name?

[03:12] <samcv> can anybody see any problems with this implementation of recursive directory finder? sub get-dirs (IO::Path:D $path) {

[03:12] <samcv>         my @paths = $path.dir.grep(*.d);

[03:12] <samcv>         if @paths {

[03:12] <samcv>             @paths.append: @paths».&get-dirs($_);

[03:12] <samcv>         }

[03:12] <samcv>         return @paths;

[03:12] <samcv>     }

[03:12] <samcv> crap didn't mean to paste that here... ugh

[03:12] <samcv> meant to paste the link...

[03:13] *** Cabanossi left
[03:13] *** Cabanossi joined
[03:13] <samcv> here it is: https://gist.github.com/samcv/7dade9fb0a93c53497afc91d864d21c7

[03:13] <samcv> i wanted to make it as simple as possible

[03:14] *** mr-foobar left
[03:16] *** mr-foobar joined
[03:18] *** mcmillhj joined
[03:23] *** mcmillhj left
[03:29] *** araraloren joined
[03:31] *** troys is now known as troys_

[03:34] *** mcmillhj joined
[03:40] *** mcmillhj left
[03:42] <llfourn> samcv: you passed $_ to it when you've already passed it implicitly with .&get-dirs

[03:43] <llfourn> (I didn't run the code but I'd hope that's a compile time error)

[03:43] <samcv> it's not

[03:43] <llfourn> :(

[03:43] <samcv> i mean you can pass variables into it. i'm actually going to add more arguments so i'm going to need to make it explicit yes?

[03:44] <samcv> though i guess this is different @dirs.map({&get-dirs($_, :$d)})

[03:44] <llfourn> but it only takes one arg and you've passed $_ twice to it

[03:44] <samcv> but with brackets around it

[03:44] <samcv> ah

[03:44] <samcv> that passes it twice?

[03:44] <llfourn> yeah 

[03:44] <BenGoldberg> This isn't perl5, you don't need the & there.

[03:44] <llfourn> .&foo syntax passed the invocant in as the first argument to the sub

[03:44] <samcv> BenGoldberg, even as a method?

[03:45] <BenGoldberg> Well, maybe as a method, but not in {&get-dirs(...)}

[03:45] <samcv> well yeah. i just altered it from a method

[03:45] <samcv> and didn't delete it.

[03:45] <samcv> nobody was harmed :)

[03:47] <llfourn> @dirs.map(*.&get-dirs(:$d)) # should do it

[03:51] *** mcmillhj joined
[03:55] <samcv> ok turns out it wasn't passing in :$d

[03:55] <samcv> doing it like that...

[03:55] <samcv> or something  @dirs.map({ get-dirs($_; :$d) } ) # Unexpected named argument 'd' passed wtf

[03:56] <llfourn> ^ err was that smicolon meant to be there?

[03:56] *** mcmillhj left
[03:56] <samcv> yes

[03:56] <llfourn> why?

[03:56] <samcv> sorry uploading new version

[03:56] <samcv> ok check again

[03:57] <samcv> because i'm using named arguments

[03:57] <llfourn> hmm

[03:57] <llfourn> I seem to remember something vaguely about semicolons and named arguments

[03:58] <samcv> oh crap i used a semicolon

[03:58] <samcv> sorry i misread semicolon as colon

[03:58] <llfourn> lol

[03:58] <samcv> haha

[03:58] <samcv> i'm going blind!

[03:58] <llfourn> that is an LTA error though

[03:58] <llfourn> but there is some kind of semicolon in pararmeter list syntax

[03:58] <samcv> yeah

[03:58] *** mr-foobar left
[04:00] *** mcmillhj joined
[04:00] <samcv> well it seems to work

[04:01] *** mr-foobar joined
[04:01] <samcv> i get 32326 directories with find and  32414 with perl 6

[04:02] <samcv> not sure why it's different

[04:02] <samcv> at least find returns one '.' but that would make find have one more directory

[04:03] <llfourn> maybe sort and diff the output

[04:05] <samcv> this liessss

[04:05] <samcv> https://docs.perl6.org/routine/flatmap#(List)_method_flatmap the docs page for flatmap

[04:05] <samcv> "invokes uc four times." untrue!

[04:06] <samcv> m: say ((1, 2), <a b>).flatmap({ $a++; uc($_)}).perl; say $a

[04:06] <camelia> rakudo-moar 10f840: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$a' is not declared␤at <tmp>:1␤------> 3say ((1, 2), <a b>).flatmap({ 7⏏5$a++; uc($_)}).perl; say $a␤»

[04:06] <samcv> m: my $a = 0; say ((1, 2), <a b>).flatmap({ $a++; uc($_)}).perl; say $a

[04:06] <camelia> rakudo-moar 10f840: OUTPUT: «("1 2", "A B").Seq␤2␤»

[04:06] <llfourn> yep that's wrong

[04:07] <samcv> map runs 4 times

[04:07] <samcv> flatmap doesn't

[04:07] <samcv> also both have the same output

[04:07] <llfourn> flatmap just does .map then .flat

[04:07] <samcv> so it's the worst example ever

[04:07] <llfourn> yeah .flatmap is considered harmful

[04:07] <samcv> oh wait nvm

[04:07] <samcv> i forgot to reset the value of $a. both of them still do it twice

[04:07] <llfourn> samcv: lol, https://github.com/perl6/doc/issues/851

[04:08] <samcv> and both have the same output. map or flatmap

[04:08] <samcv> for the love of god someone do something!

[04:08] <llfourn> haha

[04:08] * samcv panics and runs around screaming

[04:08] <Voldenet> > sub get-dirs (IO::Path:D $path) { flat gather for $path.dir.grep(*.d) { take $_, get-dirs($_) }}

[04:08] <Voldenet> it's ugly, but it works

[04:08] <samcv> 	smls opened this issue on Aug 21, 2016

[04:09] <samcv> not that ugly

[04:09] <samcv> i wonder how it is speedwise

[04:09] *** mcmillhj left
[04:09] <llfourn> I've never actually gather take

[04:09] <llfourn> always do map/grep

[04:10] <llfourn> actually used*

[04:10] <samcv> it is kinda nice if you want a sequence

[04:10] <samcv> and not all at once

[04:11] <Voldenet> gather take is supposed to be lighter on memory if I reason correctly

[04:11] *** Cabanossi left
[04:11] <llfourn> doesn't map grep produce a lazy seq anyway?

[04:12] <llfourn> or do I have to put lazy in front

[04:12] *** kyan joined
[04:13] *** Cabanossi joined
[04:19] *** khw left
[04:23] <Voldenet> Hm, I believe map grep do produce lazy seq when you give them lazy seq

[04:27] *** wamba joined
[04:28] <BenGoldberg> m: dd map *, grep {1}, ^10;

[04:28] <camelia> rakudo-moar 10f840: OUTPUT: «Cannot resolve caller map(Whatever, Seq); none of these signatures match:␤    (&code, + is raw)␤  in block <unit> at <tmp> line 1␤␤»

[04:28] <llfourn> m: my $a = (^10).map: { .say }; # only runs if it's sunk

[04:28] <camelia> rakudo-moar 10f840: ( no output )

[04:28] <BenGoldberg> m: dd map {$_}, grep {1}, ^10;

[04:28] <camelia> rakudo-moar 10f840: OUTPUT: «(0, 1, 2, 3, 4, 5, 6, 7, 8, 9).Seq␤»

[04:29] <BenGoldberg> m: dd map {say}, grep {1}, ^10;

[04:29] <camelia> rakudo-moar 10f840: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of bare "say"; in Perl 6 please use .say if you meant to call it as a method on $_, or use an explicit invocant or argument, or use &say to refer to the function as a noun␤at <tmp>:1␤--…»

[04:29] <BenGoldberg> m: dd map {.say}, grep {1}, ^10;

[04:29] <camelia> rakudo-moar 10f840: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤(Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True).Seq␤»

[04:29] <llfourn> m: my @a = (^10).map: { .say }; # if it's assigned it probably runs too

[04:29] <camelia> rakudo-moar 10f840: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[04:29] <BenGoldberg> m: my $nosink := map {.say}, grep {1}, ^10; say 'hmm';

[04:29] <camelia> rakudo-moar 10f840: OUTPUT: «hmm␤»

[04:29] <BenGoldberg> m: my $nosink := map {.say}, grep {1}, ^10; say 'hmm'; say $nosink.perl

[04:29] <camelia> rakudo-moar 10f840: OUTPUT: «hmm␤0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤(Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True).Seq␤»

[04:29] <llfourn> m: my @a = lazy (^10).map: { .say }; # but if you put lazy it shouldn't

[04:29] <camelia> rakudo-moar 10f840: ( no output )

[04:32] <Voldenet> my $nosink = map {.say}, grep {1}, ^10; say $nosink.take(5)

[04:32] <Voldenet> m: my $nosink = map {.say}, grep {1}, ^10; say $nosink.take(5)

[04:32] <camelia> rakudo-moar 10f840: OUTPUT: «Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at <tmp> line 1␤␤»

[04:33] <Voldenet> erm

[04:33] <Voldenet> m: my $nosink = map {.say}, grep {1}, ^10; say $nosink.head(5);

[04:33] <camelia> rakudo-moar 10f840: OUTPUT: «0␤1␤2␤3␤4␤(True True True True True)␤»

[04:36] *** mcmillhj joined
[04:38] <Voldenet> in fact

[04:38] <Voldenet> sub get-dirs (IO::Path:D $path) { $path.dir.grep(*.d).deepmap: { $_, get-dirs($_) } }

[04:38] <Voldenet> that would be even better way to do this :D

[04:44] <llfourn> isn't deepmap pointless because dir is only going to give you a an array of paths?

[04:44] *** mcmillhj left
[04:47] *** mcmillhj joined
[04:48] *** raiph joined
[04:48] <Voldenet> hm, get-dirs gives you a lazy sequence of a dir, so deepmap would give you a sequence representing a directories tree

[04:50] <Voldenet> m: sub get-dirs (IO::Path:D $path) { $path.dir.grep(*.d).deepmap({$_, get-dirs($_)}).flat }; say get-dirs(".".IO).elems

[04:50] <camelia> rakudo-moar 10f840: OUTPUT: «Type check failed in binding to parameter '$path'; expected IO::Path but got IO::Path.new(".", :SP...␤  in sub get-dirs at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[04:51] *** mcmillhj left
[04:53] <Voldenet> It works on my box, I guess "no fun allowed" anymore :P

[04:53] *** troys_ is now known as troys

[04:57] *** Cabanossi left
[04:58] *** Cabanossi joined
[05:00] <samcv> ok i'm fi xing flatmap docs right now

[05:02] <Geth> ¦ doc: b90d2f82c6 | (Samantha McVey)++ | doc/Type/List.pod6

[05:02] <Geth> ¦ doc: Provide correct documentation for .flatmap

[05:02] <Geth> ¦ doc: 

[05:02] <Geth> ¦ doc: The previous example's explanation was wrong, and the example

[05:02] <Geth> ¦ doc: had the same result on both .map and .flatmap, making it an

[05:02] <Geth> ¦ doc: even more confusing function.

[05:02] <Geth> ¦ doc: 

[05:02] <Geth> ¦ doc: The documentation now strongly recommends use of .map.flat and

[05:02] <Geth> ¦ doc: recommends to instead using the confusing .flatmap

[05:02] <Geth> ¦ doc: 

[05:02] <samcv> that bug was so old :(

[05:02] <Geth> ¦ doc: Fixes issue #851.

[05:03] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/b90d2f82c6

[05:03] *** mcmillhj joined
[05:03] <samcv> sad!

[05:03] *** troys left
[05:05] <llfourn> samcv++

[05:05] <samcv> i just solved world hunger

[05:05] <samcv> ok maybe nothing that important

[05:05] <samcv> but i feel happy about it

[05:05] <ugexe> m: my $files = -> $p = $*CWD { $p.f ?? $p  !! dir($p)>>.&?BLOCK.Slip }; say $files().map(*.parent).unique;

[05:05] <camelia> rakudo-moar 10f840: OUTPUT: «Failed to get the directory contents of '/home/camelia/.local/share/systemd/user': Failed to open dir: 2␤  in block <unit> at <tmp> line 1␤␤»

[05:06] *** wamba left
[05:07] *** mcmillhj left
[05:13] <Voldenet> uh, getting a list of files and then doing .map(*parent).unique is a very unique way of doing this :)

[05:17] *** pilne left
[05:18] *** roguelazer joined
[05:18] *** mcmillhj joined
[05:19] <Geth> ¦ doc: 286e135bac | (Samantha McVey)++ | doc/Type/Hash.pod6

[05:19] <Geth> ¦ doc: Be more clear about %() being preferred to { } for hash creation

[05:19] <Geth> ¦ doc: 

[05:19] <Geth> ¦ doc: Work on fixing #1380

[05:19] <Geth> ¦ doc: 

[05:19] <Geth> ¦ doc: In addition to more highly recommending %(), we also use less text

[05:19] <Geth> ¦ doc: and make the examples of the pitfalls more clear.

[05:19] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/286e135bac

[05:19] <samcv> this also makes me happier too

[05:23] <BenGoldberg> I would have, instead of 'To assign to a variable without the C<%> sigil', 'To assign a hash to a variable which does not have the C<%> sigil'

[05:23] *** mcmillhj left
[05:24] <samcv> isn't that the same thing?

[05:24] <BenGoldberg> Also, s/Instead, you should use/This would have been avoided if you had used/.

[05:24] <samcv> which does not vs without

[05:24] <samcv> does not have vs without

[05:25] <BenGoldberg> Well, it's almost the same thing, except we're still using a %, just on the right side of the = instead of the left.

[05:25] <Voldenet> ugexe: apparently calling unique on IO doesn't work all that well on my system, but calling it on *.parent.Str works

[05:26] <samcv> Voldenet, did you sort them with eqv?

[05:27] <samcv> .sort(&[eqv]).unique

[05:29] *** mr-foobar left
[05:31] *** mr-foobar joined
[05:31] <Voldenet> .unique(:with(&[eqv])) kind of works, but it's slow

[05:31] <samcv> kind of works? or works but slowly

[05:32] * samcv wonders if we have an eqv candidate for IO::Path

[05:32] <Voldenet> It works, but it's incredibly slow

[05:33] <Voldenet> this takes a blink of an eye > .map(*.parent.Str).unique;

[05:33] <Voldenet> this takes longer than 10s > .map(*.parent).unique(:with(&[eqv]))

[05:33] <samcv> yeah i know it is slow :P

[05:34] <Voldenet> Ah, /eqv/ might not be the operator I was wanting to use

[05:34] <samcv> and does .sort not work?

[05:34] <Voldenet> Nope, see for yourself: my $files = -> $p = $*CWD { $p.f ?? $p  !! dir($p)>>.&?BLOCK.Slip }; .say for $files().map(*.parent).sort.unique;

[05:34] *** mcmillhj joined
[05:34] <samcv> oh you're running unique without sort? does th't work?

[05:35] <Voldenet> The set is pretty much sorted anyway, so there's no need to sort it again :)

[05:35] <samcv> that doesn't work for me

[05:36] <samcv> well i don't think unique even works if thigs are not sorted..

[05:36] <samcv> ah maybe i'm wrong

[05:37] <samcv> that doesn't even run that is

[05:37] <Voldenet> It seems that .unique works right on Str

[05:38] <samcv> Failed to get the directory contents of '/home/samantha/git/rakudo/.nav-marker-rules': Failed to open dir: 2

[05:38] <timotimo> i'd expect unique to work with .WHICH

[05:38] <samcv> why?

[05:39] <samcv> well it does call WHICH

[05:39] <samcv> ah yeah cause it literally is checking if they're the same object period

[05:40] <samcv> but it doesn't work if you have two thinsg which are different objects but have the same contents

[05:40] <samcv> unless it's a Str

[05:40] <samcv> and prolly an Int

[05:40] <samcv> or Rat

[05:40] <samcv> other things no

[05:40] *** mcmillhj left
[05:40] <samcv> m: say dir[0].WHICH

[05:40] <camelia> rakudo-moar 10f840: OUTPUT: «IO::Path|60080000␤»

[05:41] <timotimo> you could of course implement "unique" based on eqv

[05:41] <samcv> m: say dir[0].WHICH; say dir[0].WHICH

[05:41] <camelia> rakudo-moar 10f840: OUTPUT: «IO::Path|43442208␤IO::Path|43442288␤»

[05:41] <timotimo> but that'll blow up run time quadratically

[05:42] <samcv> er maybe you want unique with cmp?

[05:42] <samcv> or uh. would eqv work? since uh. it only gives True or False

[05:42] <samcv> usually you implement unique by sorting and then removing duplicates next to each other

[05:42] <timotimo> you'd have to eqv the new element with every existing element

[05:42] <samcv> yeah

[05:42] <Voldenet> with IO::Path .unique(:as(*.Str)) would work reasonably well

[05:43] <timotimo> that'd be faster, yeah

[05:43] <timotimo> though not everything you can eqv you can cmp

[05:43] <samcv> yep

[05:43] <samcv> Voldenet, that won't work if the CWD is different i would guess right?

[05:43] <Voldenet> Yeah.

[05:43] <timotimo> yeah, it'd have to be :as(*.absolute)

[05:44] *** xtreak joined
[05:44] <Voldenet> well, I'd still rather use: sub get-dirs (IO::Path:D $path) { $path.dir.grep(*.d).deepmap({$_, get-dirs($_)}).flat }

[05:44] <samcv> well that won't find unique paths on/ly ones that refer to the same thing

[05:44] <samcv> since paths store more info than that

[05:44] <samcv> that cuold cause weird bugs? depending?

[05:44] <samcv> not sure

[05:45] <samcv> maybe if you use .Str ever

[05:45] <samcv> i've never used deepmap hm

[05:45] <samcv> how does it differ from map

[05:46] <Voldenet> it's invoked on subsequences as well

[05:47] <Voldenet> and since get-dirs returns a sequence, the map would invoke it recursively

[05:48] <samcv> map works for sub arrays but not subsequences or what? i've never tried to go very deep

[05:50] <Voldenet> m: (1, (2, 3), 4).map({ .say; *+1 })

[05:50] <camelia> rakudo-moar 10f840: OUTPUT: «1␤(2 3)␤4␤»

[05:50] <Voldenet> m: (1, (2, 3), 4).map({ .say; $_ + 1 }).say

[05:50] <camelia> rakudo-moar 10f840: OUTPUT: «1␤(2 3)␤4␤(2 3 5)␤»

[05:50] <Voldenet> not what I'd expect

[05:50] <Voldenet> m: (1, (2, 3), 4).deepmap({ .say; $_ + 1 }).say

[05:50] <camelia> rakudo-moar 10f840: OUTPUT: «1␤2␤3␤4␤(2 (3 4) 5)␤»

[05:50] <Voldenet> better :)

[05:51] <Voldenet> m: (1, ^5, (2, 3), 4).deepmap({ $_ + 1 }).say

[05:51] <camelia> rakudo-moar 10f840: OUTPUT: «(2 (1 2 3 4 5) (3 4) 5)␤»

[05:53] *** travis-ci joined
[05:53] <travis-ci> Doc build errored. Samantha McVey 'Provide correct documentation for .flatmap

[05:53] <travis-ci> https://travis-ci.org/perl6/doc/builds/246458765 https://github.com/perl6/doc/compare/7d9e87c61a5f...b90d2f82c6ff

[05:53] *** travis-ci left
[05:56] *** mr-fooba_ joined
[05:56] *** Cabanossi left
[05:57] *** mr-foobar left
[05:59] *** Cabanossi joined
[05:59] *** xtreak_ joined
[06:02] *** xtreak left
[06:04] <ugexe> m: (1, (^5), ((4,5),), 6).tree(*.self, *.reverse, *.sum).say

[06:04] <camelia> rakudo-moar 10f840: OUTPUT: «(1 (4 3 2 1 0) (9) 6)␤»

[06:05] <Voldenet> what does .tree do?

[06:06] <ugexe> m: (1,(2,3),4).tree(*.self, *.reverse).say; (1,(2,3),4).tree(*.reverse, *.self).say

[06:06] <camelia> rakudo-moar 10f840: OUTPUT: «(1 (3 2) 4)␤(4 (2 3) 1)␤»

[06:07] <ugexe> m: (1,(2,3),(4,(5,6))).tree(*.self, *.self, *.reverse).say;

[06:07] <camelia> rakudo-moar 10f840: OUTPUT: «(1 (2 3) (4 (6 5)))␤»

[06:09] *** travis-ci joined
[06:09] <travis-ci> Doc build errored. Samantha McVey 'Be more clear about %() being preferred to { } for hash creation

[06:09] <travis-ci> https://travis-ci.org/perl6/doc/builds/246461571 https://github.com/perl6/doc/compare/b90d2f82c6ff...286e135bac9d

[06:09] *** travis-ci left
[06:09] *** nbrown joined
[06:09] <samcv> ahh go away travis

[06:11] <samcv> travis is a big meanie. won't even finish building

[06:11] <samcv> though! the cache did work

[06:13] <samcv> we need one build that does highlighting and one that doesn't i think

[06:13] <samcv> but i don't have time for that today

[06:15] *** domidumont joined
[06:19] *** tony-o joined
[06:21] *** domidumont left
[06:21] *** domidumont joined
[06:24] *** mr-fooba_ left
[06:25] *** parv joined
[06:28] *** MasterDuke left
[06:32] *** domidumont left
[06:33] *** domidumont joined
[06:38] *** mr-foobar joined
[06:42] *** jamesaxl joined
[06:42] <jamesaxl> hi

[06:42] <jamesaxl> mst: do you use perl 6?

[06:43] <TEttinger> from what I understand, mst uses some of every language ever comprised. ever heard of Kernel?

[06:45] <jamesaxl> TEttinger: I think that he does not use anything

[06:46] <jamesaxl> TEttinger: how about you?

[06:47] <TEttinger> I do not use perl 6.

[06:47] <jamesaxl> TEttinger: only perl5?

[06:48] <TEttinger> I can write a teensy bit of very simple perl6. my perl5 is limited to regexes.

[06:48] <TEttinger> I'm interested in how perl6's grammars work

[06:48] <TEttinger> I think they are an elegant way of constructing DSLs

[06:50] <jamesaxl> TEttinger: do you think that perl6 can be good in the future?

[06:50] <TEttinger> yes.

[06:51] <TEttinger> I think there are speed issues holding it back currently, but that's addressable by MOAR VM improvements

[06:52] <TEttinger> I think the language itself is phenomenally complex and this makes it hard to attract users

[06:52] <TEttinger> that said, C++ has tons of users and is a very complex language, probably just as much or more so than perl6

[06:53] <TEttinger> things like junctions are brilliant for describing what you mean rather than building complex if-else statements

[06:53] <jamesaxl> TEttinger: and how about modules, I see that perl6 lacks to very important modules.

[06:54] <TEttinger> yeah it lacks tons, but Inline::Perl5 makes it apparently very easy to call perl5 code

[06:55] *** domidumont left
[06:57] <jamesaxl> TEttinger: And how can I share modules of perl6 (I meant my modules)?

[06:58] <TEttinger> I do not use perl 6. but I think CPAN is in the process of changing to accept perl6 as well as perl5

[06:58] <nine> TEttinger: it already does

[06:59] <TEttinger> I yield the floor to nine

[07:00] <jamesaxl> nine: can I upload it use pause?

[07:00] <nine> jamesaxl: indeed, you can :)

[07:01] <nine> You can use mi6 (App::Mi6) for added convenience

[07:03] <jamesaxl> that is nice

[07:03] <nine> zef will find the distro about half an hour or an hour later. The only bit that's missing to my knowledge is listing the module on modules.perl6.org

[07:08] <BenGoldberg> m: package Foo { our proto bar(|) {*}; our multi bar(Int) { 'int' } }; dd Foo::bar(42);

[07:08] <camelia> rakudo-moar 10f840: OUTPUT: «"int"␤»

[07:08] * BenGoldberg wonders if that's considered a bug.

[07:09] <nine> Why would it?

[07:09] <BenGoldberg> m: package Foo { our proto bar(|) {*}; my multi bar(Int) { 'int' } }; dd Foo::bar(42);

[07:09] <camelia> rakudo-moar 10f840: OUTPUT: «"int"␤»

[07:09] * BenGoldberg pasted the wrong version.

[07:10] <BenGoldberg> The 'my' is basically ignored.

[07:13] <nine> BenGoldberg: it's not:

[07:13] <nine> m: package Foo { our proto bar(|) {*}; { my multi bar(Int) { 'int' } } }; dd Foo::bar(42);

[07:13] <camelia> rakudo-moar 10f840: OUTPUT: «Cannot resolve caller bar(Int); Routine does not have any candidates. Is only the proto defined?␤  in block <unit> at <tmp> line 1␤␤»

[07:14] <nine> Foo::bar(42) conceptually calls the proto bar(|) which then calls the appropriate candidate which it does find in it's lexical scope

[07:16] *** mr-foobar left
[07:23] *** bwisti left
[07:23] *** mr-foobar joined
[07:24] *** llfourn_ joined
[07:24] *** llfourn left
[07:26] *** BenGoldberg left
[07:26] *** unclechu left
[07:26] *** xui_nya[m] left
[07:29] *** xui_nya[m] joined
[07:29] *** unclechu joined
[07:32] *** domidumont joined
[07:34] *** zapwai left
[07:39] *** skids left
[07:44] *** domidumont left
[07:45] *** setty1 joined
[07:56] *** xtreak joined
[07:57] *** xtreak__ joined
[07:59] *** xtreak_ left
[08:01] *** xtreak left
[08:08] *** rindolf joined
[08:17] *** parv left
[08:26] *** darutoko joined
[08:27] *** setty1 left
[08:30] <Geth> ¦ ecosystem: d5e94b9211 | (Martin Barth)++ (committed using GitHub Web editor) | META.list

[08:30] <Geth> ¦ ecosystem: Added HTTP-Server-Orgre

[08:30] <Geth> ¦ ecosystem: 

[08:30] <Geth> ¦ ecosystem: Added HTTP-Server-Ogre - just another p6w http server

[08:30] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/d5e94b9211

[08:30] *** ufobat joined
[08:36] *** parv joined
[08:42] *** LeCamarade joined
[09:06] *** xtreak joined
[09:10] *** xtreak__ left
[09:11] *** xtreak_ joined
[09:14] *** parv left
[09:14] *** xtreak left
[09:16] *** ufobat left
[09:25] *** ufobat joined
[09:30] *** lizmat left
[09:33] *** seatek joined
[09:37] *** xtreak_ left
[09:37] *** lizmat joined
[09:38] *** ufobat left
[09:41] *** xtreak joined
[09:49] *** parv joined
[09:55] *** TEttinger left
[09:55] *** parv left
[09:56] *** xtreak left
[10:12] *** MARTIMM joined
[10:30] *** jamesaxl left
[10:32] *** jamesaxl joined
[10:36] *** MARTIMM left
[10:45] *** Sense8 joined
[10:47] *** Sense8 left
[11:00] *** lizmat left
[11:05] *** nhywyll joined
[11:05] *** nhywyll left
[11:06] *** lizmat joined
[11:13] *** setty1 joined
[11:17] *** nhywyll joined
[11:17] *** nhywyll left
[11:28] *** nhywyll joined
[11:28] *** nhywyll left
[11:41] *** nhywyll joined
[11:41] *** nhywyll left
[11:46] *** MasterDuke joined
[11:48] *** AlexDaniel joined
[11:49] *** grondilu left
[12:24] *** robertle joined
[12:28] *** domidumont joined
[12:29] *** kaare_ left
[12:40] *** cpage_ left
[12:42] *** Cabanossi left
[12:45] *** ufobat joined
[12:46] *** Cabanossi joined
[12:48] *** ufobat left
[12:57] *** domidumont left
[12:57] *** nbrown left
[13:00] *** lucasb joined
[13:12] *** domidumont joined
[13:12] *** Cabanossi left
[13:16] *** Cabanossi joined
[13:24] *** user3 joined
[13:24] <user3> why do I have to put a 'my' here 'my Str sub f() {}' while it's not needed in this one 'sub f() of Str {}'

[13:27] *** pilne joined
[13:27] *** wamba joined
[13:31] <masak> user3: that question does not seem to make sense out of the context you're in but have not stated

[13:31] <masak> oh wait, maybe it does

[13:32] <masak> user3: I think the simple answer is "because if you want to specify a type like 'Str', you have to front with a declarator keyword"

[13:32] <masak> whether you make that keyword `my`, or `our`, or `has` or something else, is up to you

[13:33] * masak loses today's Oxford Comma nomination

[13:33] <user3> k

[13:34] <masak> user3: the same answer, but phrased differently, would be "a type like `Str` cannot front a declaration statement like `sub`"

[13:34] <user3> yes, i understand the logic of it

[13:34] <user3> thx

[13:34] <masak> pzh

[13:34] <moritz> or from a different point of view: If it's not part of a declaration, a type name like Str is a term, so the parser expects an operator after it

[13:38] <masak> oh, right

[13:39] <masak> which makes for a nice contrast with e.g. Java, where type names and ordinary terms live in different namespaces

[13:39] <masak> so in Perl 6, the "cost" of the tradeoff is that you need to do `my Str` or `our Str` etc. at the start of declarations

[13:39] <user3> its a good bargain

[13:40] <masak> whereas in Java, it's that you need to do `MyType.class` (to bring a type term from type land to term land) instead of just `MyType`

[13:41] <masak> and it also makes `instanceof` a slightly magical operator :)

[13:41] <masak> (because it has to tell the parser, "hey, the rhs is a type, not a term")

[13:44] *** domidumont left
[13:53] *** cpage_ joined
[13:55] *** user3 left
[14:02] *** BenGoldberg joined
[14:04] *** bwisti joined
[14:10] *** itaylor57 left
[14:19] *** mscha joined
[14:19] <mscha> m: my $p = start { for 1..5 { .say; sleep 1; } }; sleep 2; $p.break;

[14:19] <camelia> rakudo-moar 2a88c2: OUTPUT: «1␤2␤3␤Access denied to keep/break this Promise; already vowed␤  in block <unit> at <tmp> line 1␤␤»

[14:19] <mscha> How do I break a promise (from the “outside”)?

[14:26] <mst> POSIX::_exit(255); # all promises are now broken

[14:26] <TimToady> mst: you can't break a promise unless the inside grants you access to the "vow"

[14:26] <mscha> But what if I don't want to exit, just kill that promise?

[14:27] <TimToady> that's by design

[14:27] <mscha> So in my case, once that promise is running, there's no way to stop it (except by exiting)?

[14:27] <TimToady> I suppose it depends on where the inside put its vow?

[14:28] <TimToady> if it's in an object attribute you can get at it sneakily...

[14:28] <mscha> I tried $p.vow.break, but it wouldn't let me either.

[14:28] <mscha> m: my $p = start { for 1..5 { .say; sleep 1; } }; sleep 2; $p.vow.break;

[14:29] <camelia> rakudo-moar 2a88c2: OUTPUT: «1␤2␤3␤Access denied to keep/break this Promise; already vowed␤  in block <unit> at <tmp> line 1␤␤»

[14:29] *** khw joined
[14:30] <mst> TimToady: how does the inside of the start block gets its vow?

[14:30] * TimToady doesn't remember

[14:31] * TimToady doesn't break many vows...

[14:35] <TimToady> the tests use Promise.new rather than start, so maybe start is doing something weird

[14:37] <MasterDuke> https://docs.perl6.org/type/Promise#method_break mentions that using e.g., start, means you can't break it, so use Promise.new if you want to

[14:39] <mscha> But if you don't use start, how do you (asynchronously) run code?

[14:40] <TimToady> apparently start keeps its vow private, but if you can get the code to throw an exception, it'll break

[14:40] <TimToady> you can always Promise.new yourself

[14:41] <TimToady> look at method start in src/core/Promise.pm

[14:43] * TimToady heads for DCA, LAX, SJC...

[14:46] <mscha> Hmm, okay, so looks like I can't do that ­- breaking a promise from the “outside” when the code in the promise is already running.

[14:46] *** Ven joined
[14:47] *** Ven is now known as Guest80266

[14:48] *** Guest80266 left
[14:51] *** nhywyll joined
[14:54] *** skids joined
[14:56] *** lucasb left
[15:04] *** wamba left
[15:10] *** davido_ joined
[15:14] *** reino4477 joined
[15:15] <reino4477> hey, has anybody created a web app in Perl 6 recently? 

[15:15] *** kyan left
[15:16] <reino4477> i'm trying to understand if its eco system is ready more or less so I can use it for building web apps for myself

[15:16] *** davido_ left
[15:17] <AlexDaniel> reino4477: I think it depends

[15:18] *** davido_ joined
[15:19] <reino4477> https://www.reddit.com/r/perl6/comments/6j7b1q/how_much_is_perl_6_ready_for_web_development_what/

[15:22] <MasterDuke> reino4477: Gabor Szabo is working on a book about it https://www.indiegogo.com/projects/book-web-application-development-in-perl-6-website--2#/

[15:22] <jnthn> fwiw, start and Promise are only related in that start blocks evaluates to a Promise. The start implementation looks something like sub start(&foo) { my $p = Promise.new; my $v = $p.vow; $*SCHEDULER.cue: { $v.keep(foo()); }, :catch({ $v.break($_) }); return $p }

[15:23] *** reino4477 left
[15:24] <jnthn> Thus the vow is taken by start and kept with the result or broken if it throws an exception

[15:24] *** davido_ left
[15:24] *** domidumont joined
[15:25] <jnthn> I don't really get why you'd want to break the Promise from the outside, though. It's not like doing that would cancel the code runing in the Promise, or even prevent it from being schedulered if it wasn't already running.

[15:25] <jnthn> It'd just result in it exploding with a "already kept/broke this Promise" at the end

[15:25] <jnthn> So I guess "what are you trying to achieve" is the righter question :)

[15:27] *** davido_ joined
[15:28] *** kyan joined
[15:44] *** skids left
[15:48] *** Ven joined
[15:49] *** k-man left
[15:49] *** Ven is now known as Guest44526

[15:51] *** kaare_ joined
[15:52] *** nhywyll left
[15:52] *** abraxxa joined
[15:53] <abraxxa> I just built 2017.06 and now use v6c; isn't working any more

[15:53] <abraxxa> when I change it to use v6.c; it works again, did I miss a change there?

[15:55] *** lollercopter joined
[15:56] <lollercopter> abraxxa: it worked only because of a bug. The right thing is v6.c

[15:56] *** k-man joined
[15:56] <abraxxa> lollercopter: I guessed so, thanks!

[15:56] <lollercopter> c: 2017.05 my str $x = '6c'; my num $y = $x; say $y

[15:56] <committable6> lollercopter, ¦2017.05: «6»

[15:56] <lollercopter> c: 2017.06 my str $x = '6c'; my num $y = $x; say $y

[15:56] <committable6> lollercopter, ¦2017.06: «Can't convert '6c' to num: trailing characters␤  in block <unit> at /tmp/inMsBbqJbY line 1␤ «exit code = 1»»

[15:57] <lollercopter> ^ that's the bug that got fixed

[15:57] <abraxxa> do the release notes mention that somewhere? I couldn't find it

[15:58] *** davido_ left
[15:58] <lollercopter> hm

[15:58] <lollercopter> m: dd v6c

[15:58] <camelia> rakudo-moar 2a88c2: OUTPUT: «v6.c␤»

[15:59] <lollercopter> abraxxa: OK, nevermind, it's a new bug :D since v6c works a version literal for v6.c, it should work in `use` too, I think

[15:59] <lollercopter> abraxxa: no, release notes don't mention it

[16:00] *** kaare_ left
[16:00] <abraxxa> ok

[16:01] <lollercopter> I can fix it...

[16:02] *** kaare_ joined
[16:04] <abraxxa> lollercopter++

[16:22] <ugexe> i couldn't think `use v6c;` should work...

[16:22] <ugexe> wouldnt^

[16:23] <lollercopter> ugexe: why not?

[16:24] *** dotness joined
[16:25] <ugexe> m: say v6c cmp v6.c; # i guess it depends on how you feel about .<alpha> being treated different that .<number>

[16:25] <camelia> rakudo-moar 2a88c2: OUTPUT: «Same␤»

[16:26] <lollercopter> it's not about that, Version splits on <alpha>/<digit> boundary, so it's liek the dot is still there

[16:26] <lollercopter> s: Version, 'new', \("6c")

[16:26] <lollercopter> a right, no bot here

[16:26] *** pmurias joined
[16:26] <lollercopter> https://github.com/rakudo/rakudo/blob/2a88c20/src/core/Version.pm#L35

[16:28] <ugexe> well, for one it means that you cant do an extract string match on a version to find an exact matching version. in perl6 land this is trivial to handle, but will tooling outside of perl6?

[16:28] *** andrzejku joined
[16:28] <ugexe> its like "*"

[16:29] <ugexe> where its easy to handle with perl6 tools, but everything else?

[16:29] <lollercopter> Don'

[16:30] <lollercopter> Don't care really it's a version literal. It's even parsed with the version-literal token. So I'd expect version literals to work

[16:30] <lollercopter> It's up to the mystery-tool to learn to work with Perl 6 version literals.

[16:31] <ugexe> the mystery tools are system package managers - apt-get, yum, etc.

[16:32] <lollercopter> Why are system package managers trying to parse a Perl 6 program to figure out version?

[16:33] <ugexe> because you declare dependencies as their `use` strings

[16:33] <ugexe> and people will declare their versions with it

[16:35] <lollercopter> So it can handle `v6.c+` but will choke on `v6c`?

[16:38] <lollercopter> m: use v6.a+

[16:38] <camelia> rakudo-moar 2a88c2: ( no output )

[16:38] <pmurias> having system package managers parse Perl 6 programs to extract 'use statements' doesn't seem very desirable

[16:38] <ugexe> i dont know how they plan on handling v6.c+

[16:38] <ugexe> they dont parse them out, they are declared in the meta data

[16:39] <lollercopter> Well, and we're talking about version literals in source code :/

[16:39] <lollercopter> Feels like an imagined problem a few levels down, whereas specialcasing `use v6` to not accept all version literals is a currently existent issue.

[16:40] *** japhb left
[16:41] *** japhb joined
[16:47] *** iH2O joined
[16:48] *** AlexDaniel left
[16:48] <iH2O> how can I list all files recursively in the current directory. 'dir' has no option for that. what else?

[16:48] <lollercopter> buggable: eco File::Find

[16:48] <buggable> lollercopter, File::Find 'File::Find for Perl 6': https://github.com/tadzik/File-Find 3 other matching results: https://modules.perl6.org/#q=File%3A%3AFind

[16:49] <lollercopter> iH2O: ^

[16:53] <ugexe> m: my $files = -> $p = $*CWD { $p.f ?? $p  !! dir($p)>>.&?BLOCK.Slip }; say $files()

[16:53] <camelia> rakudo-moar 2a88c2: OUTPUT: «Failed to get the directory contents of '/home/camelia/.local/share/systemd/user': Failed to open dir: 2␤  in block <unit> at <tmp> line 1␤␤»

[16:54] <lollercopter> Why reinvent the wheel for a solved problem? Your example has a open file exhaustion bug

[16:54] *** mr-fooba_ joined
[16:56] *** itaylor57 joined
[16:56] *** mr-foobar left
[16:57] <ugexe> its a solution that demonstrates the power of core perl6 in almost less characters than the link to the module. give a man fish, etc

[16:59] <lollercopter> It's not a solution if it has a bug; and a rare to encounter too. You code recurses before exhausing the dir's Seq, and each dir uses a file handle

[17:00] *** Cabanossi left
[17:00] <lollercopter> abraxxa: fix shipped: https://github.com/rakudo/rakudo/commit/fe7ea124cd

[17:00] <lollercopter> \o

[17:00] *** lollercopter left
[17:00] <iH2O> My bash $PATH variable must be lacking something because 'use File::Find;' returns these error messages https://pastebin.com/kfiqPB4X

[17:00] *** Cabanossi joined
[17:01] <mscha> jnthn: re breaking promises, what I'm trying to accomplish is:

[17:01] <mscha> I have a loop that takes long time to finish (about an hour), and I want to show the progress periodically.

[17:01] <mscha> My first attempt is something like: my $t = time; loop { ...; if $verbose && time - $t > 60 { say "progress ..."; $t = time; } }

[17:01] <mscha> But this slows the loop down, obviously.  So I thought: why not in a separate thread?

[17:01] <mscha> Something like: start { sleep 60; say "progress ..."; }; loop { ... }

[17:01] <mscha> This works, and is faster, but it keeps running even after the loop is done.  So, I want to abort the promise.

[17:01] <mscha> So I guess I have to do this from the inside, something like: my $done = False; start { while !$done { sleep 60; say "Progress..."; } }; loop { ... }; $done = True;

[17:02] *** setty1 left
[17:03] <ugexe> http://ugexe.com/create-a-perl6-terminal-progress-bar/

[17:04] <mscha> m: my $done = False; my $i = 0; start { while !$done { sleep 1; say "$i..."; } }; for 1..30 -> $j { $i = $j; sleep 0.1; }; $done = True;

[17:04] <camelia> rakudo-moar 2a88c2: OUTPUT: «10...␤20...␤30...␤»

[17:05] <mscha> ugexe, looks nice!

[17:05] <iH2O> ok

[17:07] <iH2O> thx ugexe, i like your solution better

[17:07] *** Guest44526 left
[17:18] *** iH2O left
[17:22] *** cdg joined
[17:28] <zengargoyle> .ask samcv in the recent `gitb` image, are the colorful >>> indicators of git repo status or just flair?

[17:28] <yoleaux> zengargoyle: I'll pass your message to samcv.

[17:28] <samcv> oh that's just my prompt

[17:28] <yoleaux> 17:28Z <zengargoyle> samcv: in the recent `gitb` image, are the colorful >>> indicators of git repo status or just flair?

[17:28] *** raiph left
[17:29] <samcv> i have zsh in vi mode. they flip the opposite direction when entering command mode

[17:29] <samcv> so that's what they're for

[17:30] <samcv> this doesn't show that feature but shows some other cool things i have set https://cry.nu/files/konsole.webm

[17:30] <mscha> m: sub progress($every, &progress, &done) { start { sleep $every; until done() { progress(); sleep $every; } } }; my $done = False; for 1..30 -> $i { state $p = progress(1, { say $i; }, { $done }); sleep 0.1; }; $done = True;

[17:30] <camelia> rakudo-moar fe7ea1: OUTPUT: «1␤1␤1␤»

[17:31] <mscha> Why doesn't that output something close to 10, 20, 30?

[17:31] <mscha> Isn't { say $i } a closure?

[17:31] <samcv> though it's a little different now, also gives the retrn code of non 0 return processes as well

[17:32] <mscha> m: sub progress($every, &progress, &done) { start { sleep $every; until done() { progress(); sleep $every; } } }; my $done = False; my $i2; for 1..30 -> $i { $i2 = $i; state $p = progress(1, { say $i2; }, { $done }); sleep 0.1; }; $done = True;

[17:32] <camelia> rakudo-moar fe7ea1: OUTPUT: «11␤20␤30␤»

[17:32] <samcv> also i figrued out how to do that fancy git branch, if you have the latest git, or maybe 1 or so versions ago can do it with only one pretty long git command and no extra processing shell code. which is neat

[17:34] <samcv> this was my git branch code https://gist.github.com/samcv/0bf4dcffc3ac2f01b6d43d1f1085c929 which i improved from how it was before, where branch names could be interpreted as regex by sed. 

[17:35] <samcv> ok just added the most recent iteration to the bottom of that gist. which is only one git command :) and same output

[17:35] <samcv> though if you don't wan tthe colors and puting a * by the current branch you can always just do git branch --sort='committerdate' --format=' %(authordate:relative)%09%(refname:short)'

[17:35] <samcv> i also made a version that works with git tag as well

[17:36] <samcv> gonna add that to the gist

[17:37] <jnthn> m: my $p = start { sleep 5 #`(simulate some hard work) }; start { until $p { await Promise.in(1); say 'working' } }; await $p;

[17:37] <camelia> rakudo-moar fe7ea1: OUTPUT: «working␤working␤working␤working␤»

[17:37] <jnthn> mscha: I might write it like that, though last time I wanted some progress thing I ended up writing https://github.com/jnthn/p6-concurrent-progress :)

[17:40] *** Ven joined
[17:40] *** Ven is now known as Guest99479

[17:42] *** zacts left
[17:43] *** setty1 joined
[17:44] *** nhywyll joined
[17:46] *** seatek left
[17:46] *** dotness left
[17:48] <Geth> ¦ doc: 4650bdcd05 | (Jan-Olof Hendig)++ | doc/Type/Str.pod6

[17:48] <Geth> ¦ doc: Fixed a few typos

[17:48] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/4650bdcd05

[17:49] <mscha> jnthn: thanks, looks nice.  I'm still looking for a solution that doesn't involve adding code within the loop, though; but having access to the loop variable i (which seems to be an issue).

[17:49] <samcv> my git tag http://i.imgur.com/24CnCuU.png

[17:49] <samcv> setting added to gist as well

[17:54] *** BenGoldberg left
[17:54] *** mr-foobar joined
[17:56] *** mr-fooba_ left
[17:56] *** setty1 left
[17:56] <zengargoyle> samcv: cool, not sure my brain can handle zsh (much the same way it can't handle emacs, Mac or Windows).

[17:57] <samcv> lol

[17:57] <zengargoyle> images did make me wonder if there's an 'at' syntax module for time specifiaction yet.

[17:57] <samcv> well you don't need zsh to get the cool and useful git functions i wrote :)

[17:57] <samcv> an 'at' spec?

[17:57] <zengargoyle> huggable: eco at

[17:57] <huggable> zengargoyle, nothing found

[17:57] <samcv> huggable: eco eco

[17:57] <huggable> samcv, nothing found

[17:58] <zengargoyle> there *is* an 'at' syntax somwhere...  in some man page or something.  a BNF-ish grammar of sorts.

[17:58] <samcv> no clue what this is about this 'at' syntax

[17:59] <samcv> what is it

[17:59] <zengargoyle> Date::Manip from p5 used to support it, but D::M was really heavy-weight and slowish.

[18:01] <samcv> but what is it

[18:01] <samcv> i have no clue what it is

[18:01] <zengargoyle> at 'now + 20 minutes'

[18:01] *** kyan left
[18:01] <zengargoyle> echo 'reboot' | at 'now + 1h'

[18:01] <samcv> oh the at command

[18:01] *** abraxxa left
[18:01] <samcv> sorry that was not clear

[18:02] <zengargoyle> one-shot scheduler... yah.

[18:02] <zengargoyle> /usr/share/doc/at/timespec

[18:02] <samcv> anyway i gotta go for a bit. ttyl

[18:02] *** raschipi joined
[18:03] <zengargoyle> old co-workers really liked the feature of specifying times like: --from '2 days ago' --until now

[18:04] <zengargoyle> vs using actual YYYYMMDDHHMMSS type spec.

[18:04] <ugexe> m: my $files = -> *@_ { my @d = @_.grep(*.d); grep *.defined, (&?BLOCK(@d.map(*.&dir)) if @d).Slip, @_.grep(*.f).Slip; }; say $files($*CWD); # Voldenet 

[18:04] <ugexe> that should avoid leaving handles open

[18:04] <camelia> rakudo-moar fe7ea1: OUTPUT: «("/home/camelia/perl5/perlbrew/perls/perl-5.20.1/lib/site_perl/5.20.1/x86_64-linux/Moose/Meta/Method/Accessor/Native/Array/Writer.pm".IO "/home/camelia/perl5/perlbrew/perls/perl-5.20.1/lib/site_perl/5.20.1/x86_64-linux/Moose/Meta/Method/Accessor/Native/A…»

[18:05] <andrzejku> hi people

[18:05] <andrzejku> :)

[18:05] *** Guest99479 left
[18:05] <ugexe> kinda sucks the @_.grep(*.d) is needed... `&?BLOCK($_.map(*.&dir)) with @d.grep(*.d)` seems to get stuck calling the `with` block

[18:07] *** raschipi left
[18:07] <zengargoyle> if anybody knows of some module that already does something like the `at` spec for time, lemme know.  otherwise, i think it would be a cool Grammar to play around with.

[18:08] <ugexe> httpbin has a time api that does it, so i imagine there might be such a spec

[18:08] <ugexe> https://now.httpbin.org/when/2%20days%20ago

[18:09] * zengargoyle looks, oh, a website....

[18:11] <ugexe> https://now.httpbin.org/when/100%20years%20in%20the%20future # the error shows its using python's maya

[18:11] <zengargoyle> i abuse `at` a lot for a one-shot batch like thing.  `at now < some.script.sh` does nice almost daemonization and auto-emails results.

[18:12] <geekosaur> system V-style 'at' includes a 'batch' command :)

[18:13] *** Cabanossi left
[18:13] *** Ven_ joined
[18:14] *** kyan joined
[18:14] <zengargoyle> i often do `echo 'notify-send 'time for favorite TV show' | at 19:29` type of things. :P

[18:15] *** Cabanossi joined
[18:17] <zengargoyle> and have a `tt` (tea-timer) function that either does forked `sleep` or `at` just to remind me of things.  it notify-sends and espeak to grab my attention.

[18:17] *** Ven_ left
[18:17] *** zacts joined
[18:18] <Geth> ¦ doc: 7668614d0e | (Jan-Olof Hendig)++ | doc/Type/Str.pod6

[18:18] <Geth> ¦ doc: Added a few formatting fixes

[18:18] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/7668614d0e

[18:19] <zengargoyle> huggable: eco yacc

[18:19] <huggable> zengargoyle, nothing found

[18:20] <zengargoyle> huggable: eco lex

[18:20] <huggable> zengargoyle, nothing found

[18:20] <zengargoyle> huggable: eco bison

[18:20] <huggable> zengargoyle, nothing found

[18:20] <zengargoyle> huggable: eco bnf

[18:20] <huggable> zengargoyle, nothing found

[18:26] *** keylet joined
[18:30] <keylet> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; token foo { . +? }; token bar { "\\\\" .* }; }; say A.parse("test \\\\ lorem ipsum");

[18:30] <camelia> rakudo-moar fe7ea1: OUTPUT: «Nil␤»

[18:30] <keylet> I want to parse "test " as <foo> and "\\\\ lorem ipsum" as <bar>

[18:31] <keylet> how to solve this problem?

[18:32] <MasterDuke> keylet: token foo { 'test' }; token bar { '\\\\ lorem ipsum' }

[18:33] <MasterDuke> keylet: but for non-snarky answer, what restrictions are there?

[18:33] <keylet> it was an example

[18:33] <keylet> so, I want to parse all symbols before "

[18:33] <keylet> so, I want to parse all symbols before "\\\\" as <foo>

[18:34] <keylet> I could use <?before "\\\\">

[18:34] <keylet> but what if there will be no "\\\\"

[18:34] <keylet> ?

[18:34] <keylet> then I'd like to match the whole string as <foo>

[18:34] <keylet> is it possible?

[18:35] <keylet> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; token foo { . + <?before "\\\\"> }; token bar { "\\\\" .* }; }; say A.parse("test \\\\ lorem ipsum");

[18:35] <camelia> rakudo-moar fe7ea1: OUTPUT: «Nil␤»

[18:35] <MasterDuke> token foo { <-[/]>+ } 

[18:36] <MasterDuke> token foo { <-\]>+ } # correct clash

[18:36] <MasterDuke> *slash

[18:36] <keylet> but if <foo> will contain some "\\", but will not contain "\\\\"

[18:36] <keylet> ?

[18:36] <keylet> so, "lorem \\ipsum \\dolor \\\\ sit amet"

[18:36] <keylet> "lorem \\ipsum \\dolor " should be in <foo>

[18:36] <keylet> and "\\\\ sit amet" in <bar>

[18:37] <keylet> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; token foo { . + <?before "\\\\"> }; token bar { "\\\\" .* }; }; say A.subparse("test \\\\ lorem ipsum");

[18:37] <camelia> rakudo-moar fe7ea1: OUTPUT: «#<failed match>␤»

[18:38] <keylet> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; token foo { ..... <?before "\\\\"> }; token bar { "\\\\" .* }; }; say A.subparse("test \\\\ lorem ipsum");

[18:38] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢test \\ lorem ipsum｣␤ foobar => ｢test \\ lorem ipsum｣␤  foo => ｢test ｣␤  bar => ｢\\ lorem ipsum｣␤»

[18:38] <keylet> hmmm.. why it does not want to execute .+ <?before PATTERN>

[18:38] *** travis-ci joined
[18:38] <keylet> ?

[18:38] <travis-ci> Doc build errored. Jan-Olof Hendig 'Fixed a few typos'

[18:38] <travis-ci> https://travis-ci.org/perl6/doc/builds/246599053 https://github.com/perl6/doc/compare/286e135bac9d...4650bdcd0559

[18:38] *** travis-ci left
[18:38] <keylet> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; token foo { . <?before "\\\\"> + }; token bar { "\\\\" .* }; }; say A.subparse("test \\\\ lorem ipsum");

[18:38] <camelia> rakudo-moar fe7ea1: OUTPUT: «#<failed match>␤»

[18:39] <keylet> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; token foo { [ . + ] <?before "\\\\"> }; token bar { "\\\\" .* }; }; say A.subparse("test \\\\ lorem ipsum");

[18:39] <camelia> rakudo-moar fe7ea1: OUTPUT: «#<failed match>␤»

[18:40] *** culb left
[18:45] <zengargoyle> m: my grammar A { rule TOP {<foobar>}; token foobar {<foo>}; token foo {.*}; };say A.parse("test");

[18:45] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢test｣␤ foobar => ｢test｣␤  foo => ｢test｣␤»

[18:45] <zengargoyle> m: my grammar A { rule TOP {<foobar>}; token foobar {<foo>}; token foo {.*?}; };say A.parse("test");

[18:45] <camelia> rakudo-moar fe7ea1: OUTPUT: «Nil␤»

[18:46] *** troys joined
[18:47] <MasterDuke> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; rule foo { [ . + ] <?before "\\\\"> }; token bar { "\\\\" .* }; }; say A.subparse("test \\\\ lorem ipsum");

[18:47] <camelia> rakudo-moar fe7ea1: OUTPUT: «#<failed match>␤»

[18:47] <zengargoyle> tokens don't backtrack and the limit of .*? is nothing, so nothing matches first.  (i think)

[18:47] <MasterDuke> m: grammar A { rule TOP { <foobar> }; token foobar { <foo> <bar>}; rule foo { .+ <?before "\\\\"> }; token bar { "\\\\" .* }; }; say A.subparse("test \\\\ lorem ipsum");

[18:47] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢test \\ lorem ipsum｣␤ foobar => ｢test \\ lorem ipsum｣␤  foo => ｢test ｣␤  bar => ｢\\ lorem ipsum｣␤»

[18:48] *** japhb left
[18:49] <zengargoyle> m: my grammar A { rule TOP { <foobar> }; regex foobar {<foo><bar>}; regex foo { .+? }; token bar { '\\\\' .* }; };say A.parse("test \\\\ lorem ipsum");

[18:49] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢test \\ lorem ipsum｣␤ foobar => ｢test \\ lorem ipsum｣␤  foo => ｢test ｣␤  bar => ｢\\ lorem ipsum｣␤»

[18:50] *** japhb joined
[18:51] <zengargoyle> m: my grammar A { rule TOP { <foobar> }; regex foobar {<foo><bar>}; regex foo { .+? }; token bar { '\' ** 4 .* }; };say A.parse("test \\\\ lorem ipsum");

[18:51] <camelia> rakudo-moar fe7ea1: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in single quotes; couldn't find final "'" ␤at <tmp>:1␤------> 3 };say A.parse("test \\\\ lorem ipsum");7⏏5<EOL>␤    expecting any of:␤        single quotes␤»

[18:57] <zengargoyle> m: my grammar A { rule TOP { <foobar> }; regex foobar {<foo><bar>}; regex foo { .+? }; regex bar { "\\" ** 4 .* }; };say A.parse("test \\\\ lorem ipsum");

[18:57] <camelia> rakudo-moar fe7ea1: OUTPUT: «Nil␤»

[18:57] * zengargoyle grrrr

[18:58] *** kyan left
[19:00] *** keylet left
[19:01] <zengargoyle> m: my $b = Q{\\\\}; say $b;say "test \\\\ lorem ipsum" ~~ rx/ (.*?) (<$b> .*)/;

[19:01] <camelia> rakudo-moar fe7ea1: OUTPUT: «\\\\␤｢test \\ lorem ipsum｣␤ 0 => ｢test ｣␤ 1 => ｢\\ lorem ipsum｣␤»

[19:02] <zengargoyle> m: my $b = Q{\\\\}; say $b;say Q{test \\\\ lorem ipsum} ~~ rx/ (.*?) (<$b> .*)/;

[19:02] <camelia> rakudo-moar fe7ea1: OUTPUT: «\\\\␤｢test \\\\ lorem ipsum｣␤ 0 => ｢test ｣␤ 1 => ｢\\\\ lorem ipsum｣␤»

[19:02] *** iH2O joined
[19:02] <zengargoyle> *aha* quoting hell.

[19:04] <zengargoyle> .ask keylet do you mean \\\\ as in 4 literal \ or "\\\\" as two literal \?  

[19:04] <yoleaux> zengargoyle: I'll pass your message to keylet.

[19:05] * zengargoyle may have been chasing after the wrong thing all along. :/

[19:06] <iH2O> how can I append the listings of dir('mydir1'), dir('mydir2') into an array @a like this:

[19:06] <iH2O> m:  my @a =dir('mydir1'),dir('mydir2')

[19:06] <camelia> rakudo-moar fe7ea1: ( no output )

[19:07] <iH2O> that doesnt work 

[19:08] <zengargoyle> m: |dir('.'),|dir('..')

[19:08] <camelia> rakudo-moar fe7ea1: ( no output )

[19:08] <zengargoyle> m: say |dir('.'),|dir('..')

[19:08] <camelia> rakudo-moar fe7ea1: OUTPUT: «".cpanm".IO".local".IO".npm".IO".perl6".IO".perlbrew".IO".rcc".IO".ssh".IO"Perlito".IO"evalbot".IO"log".IO"nqp-js".IO"p1".IO"p2".IO"perl5".IO"std".IO".bash_history".IO".bashrc".IO"mbox".IO".lesshst".IO"evalbot.log".IO".cpan".IO"dalek-queue".IO"rakudo-m-1…»

[19:08] <iH2O> thx

[19:08] *** travis-ci joined
[19:09] <travis-ci> Doc build errored. Jan-Olof Hendig 'Added a few formatting fixes'

[19:09] <travis-ci> https://travis-ci.org/perl6/doc/builds/246605639 https://github.com/perl6/doc/compare/4650bdcd0559...7668614d0ed7

[19:09] *** travis-ci left
[19:10] <zengargoyle> m: dir('.').Slip,dir('..').Slip

[19:10] <camelia> rakudo-moar fe7ea1: ( no output )

[19:10] <zengargoyle> m: say dir('.').Slip,dir('..').Slip

[19:10] <camelia> rakudo-moar fe7ea1: OUTPUT: «".cpanm".IO".local".IO".npm".IO".perl6".IO".perlbrew".IO".rcc".IO".ssh".IO"Perlito".IO"evalbot".IO"log".IO"nqp-js".IO"p1".IO"p2".IO"perl5".IO"std".IO".bash_history".IO".bashrc".IO"mbox".IO".lesshst".IO"evalbot.log".IO".cpan".IO"dalek-queue".IO"rakudo-m-1…»

[19:11] <iH2O> yes, thats better

[19:11] *** brrt joined
[19:11] *** TEttinger joined
[19:11] <zengargoyle> iH2O: you heed to sorta un-array the arrays to get something other than just 2 arrays.... yeah.

[19:12] <zengargoyle> m: say (dir('.'),dir('..')).flat

[19:12] <camelia> rakudo-moar fe7ea1: OUTPUT: «(".cpanm".IO ".local".IO ".npm".IO ".perl6".IO ".perlbrew".IO ".rcc".IO ".ssh".IO "Perlito".IO "evalbot".IO "log".IO "nqp-js".IO "p1".IO "p2".IO "perl5".IO "std".IO ".bash_history".IO ".bashrc".IO "mbox".IO ".lesshst".IO "evalbot.log".IO ".cpan".IO "dale…»

[19:12] *** andrzejku left
[19:13] * zengargoyle not sure which way is 'best'.

[19:13] <iH2O> i say the first is better

[19:13] <iH2O> because it doesnt create a more complicated temporary structure

[19:14] <zengargoyle> m: my @a = dir('.'); @a.append: dir('..'); say @a;

[19:14] <camelia> rakudo-moar fe7ea1: OUTPUT: «[".cpanm".IO ".local".IO ".npm".IO ".perl6".IO ".perlbrew".IO ".rcc".IO ".ssh".IO "Perlito".IO "evalbot".IO "log".IO "nqp-js".IO "p1".IO "p2".IO "perl5".IO "std".IO ".bash_history".IO ".bashrc".IO "mbox".IO ".lesshst".IO "evalbot.log".IO ".cpan".IO "dale…»

[19:15] *** domidumont left
[19:15] <zengargoyle> i think the .append vs .push has something to do with flat-ing the argument...

[19:16] <zengargoyle> ... if you're like adding more directories to an array not-in-one-go...

[19:17] *** troys is now known as troys_

[19:18] *** lichtkind left
[19:22] *** BenGoldberg joined
[19:29] *** andrzejku joined
[19:31] *** lichtkind joined
[19:39] *** darutoko left
[19:40] *** brrt left
[19:41] *** iH2O left
[19:42] *** zacts left
[19:50] *** seatek joined
[19:50] *** seatek left
[19:51] *** zacts joined
[19:54] *** cdg left
[20:01] <Geth> ¦ doc: 3b409ccf9f | (Jan-Olof Hendig)++ | doc/Type/List.pod6

[20:01] <Geth> ¦ doc: Fixed formatting and some typos

[20:01] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/3b409ccf9f

[20:04] *** AlexDaniel joined
[20:06] *** obfusk_ left
[20:15] *** espadrine joined
[20:23] *** AlexDaniel left
[20:23] *** AlexDaniel joined
[20:32] <zengargoyle> if *anybody* has a good name for a module that does the `at` timespec ... suggestions are welcome... i'm horrible at nameing things.

[20:33] <TEttinger> hoy

[20:33] <TEttinger> ahora

[20:33] <zengargoyle> One of the miseries of life is that everybody names things a little bit wrong. —- Richard P. Feynman

[20:34] <timotimo> just today i held my "surely you're joking mister feynman" book in my hands

[20:34] <TEttinger> I do like that Spanish has two words for what English just has "now" for. IIRC, hoy is like today, and ahora is "at the present moment"

[20:35] <TEttinger> zeitgeist is also a good term in general

[20:35] <geekosaur> 'today' vs. (literally) 'at (this) hour', yes

[20:35] <geekosaur> (or 'to the hour' if you want to be really literal)

[20:35] <TEttinger> at and to are both "a" though?

[20:36] <TEttinger> and it would be a la hora or alhora for to the hour

[20:36] <geekosaur> compare 'today' = 'to (the) day'

[20:36] * zengargoyle went to 'summer camp' for physics at Caltech and had the Feynman lecture books.

[20:36] <TEttinger> mmm.

[20:37] <TEttinger> today may have a weird etymology though, since this is English

[20:37] *** cyphase left
[20:37] <BenGoldberg> Time::Spec::At, perhaps?

[20:37] <zengargoyle> (along with the Tufte books.

[20:37] <geekosaur> older English documents often have it as to-day

[20:38] <zengargoyle> `at` can also do 'yyyy-mm-dd hh:mm:ss' stuff, so the today is a bit iffy.

[20:39] <zengargoyle> and the 'now' is now yyyymmddhhmmss and not really 'today'

[20:42] <pmurias> samcv: what's the difference between the UCD and unicode grant repos?

[20:43] <zengargoyle> `at` has a 'today' token.  so probably covered.  i haven't looked that deeply into the .l and .y files of the acutal parser yet.

[20:43] *** cyphase joined
[20:45] <zengargoyle> and a 'tomorrow' token.  not sure if those resolve to the 'midnight' token or not....

[20:45] <zengargoyle> and there's 'noon' and 'teatime'

[20:46] <zengargoyle> BenGoldberg++ Time::Spec::At is pretty decent.

[20:46] <BenGoldberg> Another possibility is Time::Unix::At.

[20:47] <BenGoldberg> Just in case there's some windows program named At which uses a different spec ;)

[20:47] * BenGoldberg wonders when is teatime.

[20:49] <zengargoyle> echo 'teatime' | at teatime; atq; --> 5       Sat Jun 24 16:00:00 2017 a zen

[20:49] <zengargoyle> 4 o'clock. :P

[20:49] <BenGoldberg> Well, certainly too early for dinner, but a good time for a snack and caffiene :)

[20:51] <zengargoyle> i'll have to search the modules page, i really thought there was some module that did the yacc -> grammar sort of thing...

[20:52] *** travis-ci joined
[20:52] <travis-ci> Doc build errored. Jan-Olof Hendig 'Fixed formatting and some typos'

[20:52] <travis-ci> https://travis-ci.org/perl6/doc/builds/246626653 https://github.com/perl6/doc/compare/7668614d0ed7...3b409ccf9fb9

[20:52] *** travis-ci left
[20:52] *** rindolf left
[20:54] * zengargoyle thinks but anyway a .l and .y transform into grammar and actions sould be a good bit of experimentation nonetheless.

[20:57] *** andrzejku left
[20:58] <zengargoyle> are we (p6) keeping the CamelCase naming for modules?  a part of me crinces at calling `at` 'At'.

[20:59] <zengargoyle> *cringes

[21:02] <zengargoyle> the next question is of course ... to allow \d (unicode Nu and Nd) or just <[0..9]> for digits. :P

[21:02] <TEttinger> telugu!

[21:03] <zengargoyle> at ²pm 

[21:03] <ugexe> App::at

[21:04] <zengargoyle> App:: ?

[21:05] *** nhywyll left
[21:05] <zengargoyle> more of a 'at timespec of sorts' --> DataTime

[21:06] <zengargoyle> rather than a job scheduler

[21:07] <ugexe> AtTime fits with `at`... eg.  lib/AtTime.pm6 and bin/at.pl6

[21:08] <zengargoyle> hehe, App::at -- echo 'teatime' | p6-at '²²pm'

[21:10] <Geth> Swapped META.info → META6.json in 3 dists in https://github.com/perl6/ecosystem/commit/39967a6a0c

[21:11] <zengargoyle> aside from direct `at` usage, i always used Date::Manip from p5 to just allow 'at spec of date/time' as a valid input to CLI programs that wanted a timestamp sort of input.

[21:12] <zengargoyle> e.g. `blocks --between '2 days ago' --and 'now'

[21:14] <zengargoyle> i guess App::At would just depend on Time::Spec::At or whatnot.

[21:15] <zengargoyle> which means we probably need a good `cron` spec for events.

[21:15] <zengargoyle> huggable: eco cron

[21:15] <huggable> zengargoyle, nothing found

[21:16] <zengargoyle> huggable: eco event

[21:16] <huggable> zengargoyle, nothing found

[21:17] <ugexe> is there an easy way to match /$SOME-QUOTE-CHARACTER <string-that-can-contain-escaped-quote-character> $SOME-QUOTE-CHARACTER/ ?

[21:19] *** zapwai joined
[21:21] <moritz> ugexe: '"' ~ '"' [ <-["]>* % '\%' ]

[21:21] <moritz> erm

[21:21] <moritz> ugexe: '"' ~ '"' [ [<-["]>+]* % '\"' ]

[21:21] <moritz> something alog those lines

[21:22] <moritz> '"' ~ '"' [ [<-["\\]>+]* % ['\\' . ] ] # probably more robust

[21:22] *** mscha left
[21:22] <ugexe> should I be able to do $something like `<q>=["'`] ~ $<q>` to handle multiple types of quotes?

[21:24] <moritz> I don't know if ~ works with captures

[21:24] <moritz> but in principle, yes

[21:24] <ugexe> cool thanks!

[21:24] <moritz> and then you have to replace the negative character class with [ <!before $<q>|\\> . ]

[21:25] <zengargoyle> m: my $SQC = '²'; say '²foo²bar²' ~~ m/^<$SQC>(.*?)<$SQC>$/;

[21:25] <camelia> rakudo-moar fe7ea1: OUTPUT: «5===SORRY!5=== Error while compiling /home/camelia/EVAL_0␤Unrecognized regex metacharacter ² (must be quoted to match literally)␤at /home/camelia/EVAL_0:1␤------> 3anon regex {7⏏5 ²}␤»

[21:27] <zengargoyle> m: my $SQC = '\²'; say '²foo²bar²' ~~ m/^<$SQC>(.*?)<$SQC>$/;

[21:27] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢²foo²bar²｣␤ 0 => ｢foo²bar｣␤»

[21:27] <zengargoyle> hrmmm... quotemeta how?

[21:28] <moritz> use $SQC instead of <$SQC> when you want to match it literally

[21:29] <zengargoyle> ah

[21:29] *** wamba joined
[21:31] <zengargoyle> m: my $SQC = '²'; say '²foo²bar²' ~~ m/^{$SQC}(.*?){$SQC}$/;

[21:31] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢²foo²bar²｣␤ 0 => ｢²foo²bar²｣␤»

[21:32] <zengargoyle> m: my $SQC = '²'; say '²foo²bar²' ~~ m/^$SQC(.*?)$SQC$/

[21:32] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢²foo²bar²｣␤ 0 => ｢foo²bar｣␤»

[21:33] <zengargoyle> m: my $SQC = '²'; say '²foo²bar²' ~~ m/^${SQC}(.*?)${SQC}$/;

[21:33] <camelia> rakudo-moar fe7ea1: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of ${SQC}; in Perl 6 please use $SQC␤at <tmp>:1␤------> 3$SQC = '²'; say '²foo²bar²' ~~ m/^${SQC}7⏏5(.*?)${SQC}$/;␤»

[21:34] <zengargoyle> m: my $SQC = '²'; say '²foo²bar²' ~~ m/^$SQC (.*?) $SQC$/;

[21:34] <camelia> rakudo-moar fe7ea1: OUTPUT: «｢²foo²bar²｣␤ 0 => ｢foo²bar｣␤»

[21:34] * zengargoyle guesses that's where the spaces come in...

[21:36] <zengargoyle> p5 brain still fighting me. :)

[21:42] *** Cabanossi left
[21:43] *** S007 joined
[21:45] *** Cabanossi joined
[21:49] *** espadrine left
[21:52] *** zakharyas joined
[21:55] <timotimo> m: sub MAIN('bob') { }; say &MAIN.signature.params[0].constraints[0].perl

[21:55] <camelia> rakudo-moar fe7ea1: OUTPUT: «all("bob")␤Usage:␤  <tmp> bob ␤»

[21:55] <timotimo> why do we put a junction there?

[22:16] <Geth> ¦ doc: 0ba54816cb | (Jan-Olof Hendig)++ | doc/Type/List.pod6

[22:16] <Geth> ¦ doc: Fixed link

[22:16] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/0ba54816cb

[22:20] *** kyan joined
[22:25] *** zapwai left
[22:25] *** danlei joined
[22:26] *** zakharyas left
[22:28] <zengargoyle> timotimo: heh, that's really funny to try in the REPL.  it runs MAIN() and gives an error message. :)

[22:28] <timotimo> yup

[22:28] <timotimo> wait, immediately?

[22:28] <timotimo> that *is* funny

[22:29] *** zapwai joined
[22:31] <zengargoyle> not only that, but puts all('bob') in the command buffer....

[22:32] <zengargoyle> m: multi sub MAIN('bob') { }; multi sub MAIN('joe') { }; say &MAIN.signature.params[0].constraints[0].perl

[22:32] <camelia> rakudo-moar fe7ea1: OUTPUT: «all()␤Usage:␤  <tmp> bob ␤  <tmp> joe ␤»

[22:32] <timotimo> the "command buffer"?

[22:33] <zengargoyle> it's left after my prompt: zen@zim:~/p6/p6-Time-Spec-at$ all()

[22:33] <timotimo> strange!

[22:33] <zengargoyle> and hitting <RETURN> leaves me in what i'm assuming is a define function in bash situation.

[22:34] <zengargoyle> maybe not... adding a { echo } leaves me at '>' prompt. :)

[22:36] <zengargoyle> might be cut-n-paste weirdness in my xterm....

[22:36] <timotimo> oh no! Util was bragging about the "execute stuff out of order in hyper stuff" feature, but it has been axed for performance reasons at some point :S

[22:37] <timotimo> (in the yapc::na talk he gave)

[22:39] <zengargoyle> m: multi sub MAIN('bob') { }; multi sub MAIN('joe') { }; say &MAIN.signature.params[0].constraints[0].perl

[22:39] <camelia> rakudo-moar fe7ea1: OUTPUT: «all()␤Usage:␤  <tmp> bob ␤  <tmp> joe ␤»

[22:40] <zengargoyle> .

[22:41] <zengargoyle> .u ␤

[22:41] <yoleaux> U+2424 SYMBOL FOR NEWLINE [So] (␤)

[22:42] *** pmurias left
[22:43] *** Cabanossi left
[22:43] <zengargoyle> last m: gives Usage:␤  interactive bob␤  interactive joe␤  interactive bob␤  interactive joe␤

[22:43] <zengargoyle> so doubles the output and exits the REPL. :P

[22:45] * zengargoyle guesses REPL is no place to play with &MAIN

[22:45] *** Cabanossi joined
[22:52] *** araraloren left
[22:52] <ugexe> `$<q>=[\'] ~ $<q> [ [[ <!before $<q>|\\> . ]+]* % ['\\' . ] ]` works, but not if I add a second character to $<q>=[...]. I tried using a proto token for ' and " ala `$<sym> ~ $<sym> [ [[ <!before $<sym>|\\> . ]+]* % ['\\' . ] ]` but that doesn't work for some reason :(

[22:52] *** araraloren joined
[22:54] <zengargoyle> m: multi sub MAIN('bob') { }; multi sub MAIN('joe') { }; say &MAIN.signature.params>

[22:54] <camelia> rakudo-moar fe7ea1: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing required term after infix␤at <tmp>:1␤------> 3('joe') { }; say &MAIN.signature.params>7⏏5<EOL>␤    expecting any of:␤        prefix␤        term␤»

[22:54] <zengargoyle> m: multi sub MAIN('bob') { }; multi sub MAIN('joe') { }; say &MAIN.signature.params>>.constraints>>.perl

[22:54] <camelia> rakudo-moar fe7ea1: OUTPUT: «(all())␤Usage:␤  <tmp> bob ␤  <tmp> joe ␤»

[23:04] *** zapwai left
[23:04] *** Ben_Goldberg joined
[23:05] *** BenGoldberg left
[23:05] *** Ben_Goldberg is now known as BenGoldberg

[23:06] *** travis-ci joined
[23:06] <travis-ci> Doc build errored. Jan-Olof Hendig 'Fixed link'

[23:06] <travis-ci> https://travis-ci.org/perl6/doc/builds/246653724 https://github.com/perl6/doc/compare/3b409ccf9fb9...0ba54816cb10

[23:06] *** travis-ci left
[23:15] *** wamba left
[23:24] <Geth> ¦ doc: f441ed3db7 | (Jan-Olof Hendig)++ | doc/Language/nativecall.pod6

[23:24] <Geth> ¦ doc: Added some missing types

[23:24] <Geth> ¦ doc: 

[23:24] <Geth> ¦ doc: Closes #918

[23:24] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/f441ed3db7

[23:28] *** Cabanossi left
[23:30] *** Cabanossi joined
[23:53] *** TimToady left
[23:54] *** zapwai joined
[23:54] *** cog_ left
[23:55] *** TimToady joined
[23:56] *** bwisti left
[23:59] *** bwisti joined
