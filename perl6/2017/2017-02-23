[00:04] *** labster left
[00:07] *** labster joined
[00:11] *** pyrimidine joined
[00:12] *** labster left
[00:12] *** Resol_ joined
[00:15] *** Resol left
[00:15] *** pierre joined
[00:16] *** pyrimidine left
[00:44] *** itcharlie1 left
[00:45] *** nowan joined
[00:51] *** bwisti left
[00:51] *** llfourn joined
[00:56] *** mephinet left
[00:56] *** mephinet joined
[00:56] *** llfourn left
[00:58] *** pyrimidine joined
[01:03] *** cdg left
[01:03] *** itcharlie joined
[01:07] *** itcharlie left
[01:07] *** Actualeyes joined
[01:14] <SmokeMachine> Does it make sense that as we have Inline::Perl5 (for example) to run perl5 code, we have a perl5 zef's plugin to install perl5 modules from cpan (I sad perl5 as example, could be python, java, or any language) (I thought that because I was trying to use a python lib with Inline::Python but I had no idea how to install a python library... and wandered that

[01:14] <SmokeMachine> would be great to just do something like: zef install --from-python docker (Docker was that python lib)

[01:15] <SmokeMachine> ugexe: tony-o: do you think that makes sense? ^^

[01:16] <cale2> SmokeMachine: would it just alias `pip install` ?

[01:17] <tony-o> i'm curious of the same cale2

[01:17] <SmokeMachine> cale2: I don't know... maybe?

[01:17] <cale2> well, you can install cpan modules with zef, right?

[01:17] <tony-o> not sure how that'd work with cpan, though.  just use whatever the defaults are?

[01:18] <cale2> if you install perl5 modules with zef, does it alias `cpanm` ?

[01:18] *** ufobat_ left
[01:19] <SmokeMachine> Maybe it could install on a different directory that would only be used by inline::* (I'm sorry, I'm just wondering...)

[01:21] *** mcsnolte left
[01:21] <ugexe> you can do this now the rough way with Build.pm. alternatively a plugin that is just an adapter to Menlo:from<Perl5>

[01:22] <SmokeMachine> That would make sense to be done?

[01:25] <cale2> I'm confused about all of the cpan integration with zef. Is it talking about the Perl5 cpan? Or is it talking about a yet-to-be-built perl6 cpan?

[01:27] <ugexe> its talking about the perl6 distributions on cpan

[01:30] <tony-o> SmokeMachine: i don't know if a universal package installer is the next logical step for installers or not.  it can certainly be done, it hasn't really been needed much before this

[01:31] <tony-o> at least i haven't seen that need from where i'm sitting

[01:34] <cale2> My favorite tooling is Mix in Elixir

[01:35] <cale2> it doesn't lock you in like golang, but it provides everything you could possible want. And a nice plugin system that allow extra stuff for frameworks and whatnot

[01:36] <SmokeMachine> I just think that would make sense once we can run libs of another languages inside your perl6 code... that would make you "do not leave perl6" even when installing those libs...

[01:37] <SmokeMachine> But I'm not sure if it would worth

[01:38] *** llfourn joined
[01:38] <cale2> SmokeMachine: Isn't the ability to run other languages inside Perl6 a stopgap? I mean, the Python and Perl5 interpreters are faster than Rakudo. So it's not like it's a long term thing. Feels more like a "get people up and running quickly" thing

[01:44] <SmokeMachine> cale2: (Sorry, what means stopgap?) I'm not sure if it's just up and running quickly thing... there's Inline::* in perl5 too...

[01:45] *** pyrimidine left
[01:46] <SmokeMachine> cale2: for example, in my case I was trying to use a python lib because it doesn't exist in perl6 and I just wanted to prototype what I was thinking...

[01:46] <cale2> what library?

[01:47] <SmokeMachine> a Docker client...

[01:47] <cale2> I often wonder how these libraries are created. OpenCV, Selenium, Docker... They have to bind to something... 

[01:48] <cale2> So does the OpenCV team write their code in C, then all the other languages like Python, Node, Ruby write bindings to the C code?

[01:48] <SmokeMachine> https://docker-py.readthedocs.io/en/stable/

[01:49] <SmokeMachine> On Docker case, it's a rest API through a unix socket...

[01:49] <cale2> Ah, so there could be a Perl6 SDK no prob

[01:50] <SmokeMachine> Not the unix socket yet...

[01:50] <SmokeMachine> And that's not done yet... so I can't prototype right now...

[01:52] <cale2> what's different between unix sockets and tcp sockets?

[01:52] <SmokeMachine> IMHO that's the great thing about Inline::*... if that doesn't exists in perl6 yet, doesn't matter! Use another language to prove your point, and if you prove that, write it in "the right way"...

[01:53] <SmokeMachine> cale2: unix sockets aren't from network that's a special case of memory files...

[01:54] <cale2> ah, yes... how the hell does a person "create" a socket in Perl6 

[01:54] <cale2> it's got to be done in Rakudo, no?

[01:54] <tony-o> m: IO::Socket.new

[01:54] <camelia> rakudo-moar 90dfdf: OUTPUT: «IO::Socket is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method new at src/RESTRICTED.setting line 32␤  in block <unit> at <tmp> line 1␤␤»

[01:55] <cale2> But a new type of socket

[01:55] <cale2> like a new socket protocol

[01:56] <cale2> IO::Socket::IPC.new

[01:57] <lucs> What's texas notation for the infinity symbol?

[01:58] *** pierre left
[01:59] <ugexe> m: class IO::Socket::Foo does IO::Socket { method recv { "..." } }; say IO::Socket::Foo ~~ IO::Socket; say IO::Socket::Foo.new.recv

[01:59] <camelia> rakudo-moar 90dfdf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤IO::Socket is not composable, so IO::Socket::Foo cannot compose it␤at <tmp>:1␤»

[02:02] *** pierre joined
[02:07] *** risou_awy joined
[02:07] *** risou_awy is now known as risou

[02:08] <IOninja> lucs: Inf and -Inf

[02:08] <IOninja> lucs: they're all up in here: https://docs.perl6.org/language/unicode_texas.html

[02:09] <IOninja> m: .Num.say for 1/0, -1/0

[02:09] <camelia> rakudo-moar 90dfdf: OUTPUT: «Inf␤-Inf␤»

[02:09] <IOninja> *trollface* :)

[02:10] *** labster joined
[02:10] *** risou left
[02:10] *** risou_awy joined
[02:10] *** risou_awy is now known as risou

[02:11] *** aborazmeh joined
[02:11] *** aborazmeh left
[02:11] *** aborazmeh joined
[02:12] *** risou left
[02:12] *** risou_awy joined
[02:12] *** risou_awy is now known as risou

[02:14] <lucs> Inf, got it, thanks.

[02:20] *** romrador left
[02:23] *** cdg joined
[02:28] *** kalkin- left
[02:28] *** kalkin- joined
[02:29] *** Sqirrel left
[02:38] *** Sqirrel joined
[02:43] *** cdg left
[02:44] *** cale2 left
[02:45] *** AlexDaniel left
[02:48] <ZzZombo> I broke something:

[02:48] <ZzZombo> m: my token eol { \h* [\w+\n || \n] <ws>* };say "asd\n    dsa\n" ~~ /<eol>/

[02:48] <ZzZombo> :S

[02:48] <IOninja> .ask [Coke] how detailed should the grant report be? Is this more to ensure I'm doing *something* or do people want to know all the details of what I did? In these three verbosity options, which is most preferred? https://gist.github.com/zoffixznet/90cb2497ff35893020d07bc5e7b40b89

[02:48] <yoleaux> IOninja: I'll pass your message to [Coke].

[02:48] <camelia> rakudo-moar 90dfdf: OUTPUT: «(timeout)»

[02:49] <IOninja> ZzZombo: "zero or more" tokens keeps matching on and on 

[02:49] <IOninja> m: my token eol { \h* [\w+\n || \n] <ws> };say "asd\n    dsa\n" ~~ /<eol>/

[02:49] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢asd␤    ｣␤ eol => ｢asd␤    ｣␤  ws => ｢    ｣␤»

[02:49] *** nightfrog left
[02:50] <ZzZombo> okay, but originally I wanted to see if recursive regexes work, seems they don't.

[02:50] <ZzZombo> m: my token eol { \h* [\w+\n || \n] <eol>* };say "asd\n    dsa\n" ~~ /<eol>/

[02:50] <camelia> rakudo-moar 90dfdf: OUTPUT: «No such method 'eol' for invocant of type 'Cursor'␤  in regex eol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[02:51] *** nightfrog joined
[02:51] <ZzZombo> m: my token eol { [\h* [\w+\n || \n]]+ };say "asd\n    dsa\n" ~~ /<eol>/

[02:51] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢asd␤    dsa␤｣␤ eol => ｢asd␤    dsa␤｣␤»

[02:51] <IOninja> m: say grammar { token eol { \h* [\w+\n || \n] <eol>* } }.parse: "asd\n    dsa\n", :rule<eol>

[02:51] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢asd␤    dsa␤｣␤ eol => ｢    dsa␤｣␤»

[02:52] <IOninja> They work fine.

[02:52] <ZzZombo> ah, thanks.

[02:52] *** mr_ron left
[02:53] <IOninja> (no idea why standalone version doesn't)

[02:55] <IOninja> q|"zero or more" tokens keeps matching on and on| <-- guess not quite accurate, since <eol>* works fine. But it's something in that area. There's a ticket with a long explanation on this topic somewhere, but I'm failing to find it on perl6.fail

[02:56] <IOninja> m: say grammar { token TOP { <x>+ }; token x { .+ } }.parse: 'x'

[02:56] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢x｣␤ x => ｢x｣␤»

[02:56] <IOninja> m: say grammar { token TOP { <x>+ }; token x { .* } }.parse: 'x'

[02:57] <camelia> rakudo-moar 90dfdf: OUTPUT: «(timeout)»

[02:57] <IOninja> Ah. Infinite repetition of a token that can match without advancing the cursor position is what the hang is at

[02:59] <ZzZombo> hey, IOninja, can I somehow make the following tokens:

[02:59] <ZzZombo> proto rule directive {*}

[02:59] <ZzZombo> 	token directive:sym<include> { '#include'\h+<value> }

[03:00] <ZzZombo> 	token directive:sym<base> { '#base'\h+<value> }

[03:00] <ZzZombo> trigger first on the '#' and then only match either 'base' or 'include'? I don't qute like that I repeat the triggering '#' in all places.

[03:00] <IOninja> token pref { '#' }; and then use <pref> inside the directives is what I'd do

[03:00] <IOninja> or <.pref>

[03:01] <IOninja> (non-capturing version)

[03:01] <IOninja> would be nice to stuff such stuff into the proto, but it'll complain

[03:01] <IOninja> m: grammar { proto token TOP { '#' * }; token TOP:sym<meow> { .+ } }.parse: 'x'

[03:01] <camelia> rakudo-moar 90dfdf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Proto regex body must be {*} (or <*> or <...>, which are deprecated)␤at <tmp>:1␤------> 3grammar { proto token 7⏏5TOP { '#' * }; token TOP:sym<meow> { .+ ␤»

[03:02] <IOninja> wonder if it's just NYI or there's some blocker for making that work

[03:02] <ZzZombo> Yeah, I was quite surprised protos can't be used in such way.

[03:05] *** mr_ron joined
[03:12] *** cdg joined
[03:16] *** itcharlie1 joined
[03:16] *** ChoHag left
[03:18] *** cdg left
[03:19] *** cdg joined
[03:27] *** noganex_ joined
[03:29] *** cdg left
[03:29] *** xtreak joined
[03:29] *** noganex left
[03:30] *** cdg joined
[03:37] *** pyrimidine joined
[03:42] *** pyrimidine left
[03:42] <sammers> hi #perl6

[04:01] *** mcmillhj joined
[04:08] *** agentzh left
[04:09] <ugexe> m: say grammar { token TOP { <directive> };  token directive { "#" <.directive-name> }; proto token directive-name {*}; token directive-name:sym<include> { <sym>\h+.* };  token directive-name:sym<base> { <sym>\h+.* } }.parse: "#include\tasdn"

[04:09] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢#include  asdn｣␤ directive => ｢#include   asdn｣␤»

[04:09] *** cibs left
[04:10] <ugexe> not quite, but something like that

[04:11] *** cibs joined
[04:11] <ZzZombo> yeah, I just put '#'<directive> directly into the rule, an your directive-name is just directive in my code.

[04:12] *** solarbunny left
[04:13] *** xtreak left
[04:16] *** xtreak joined
[04:20] *** solarbunny joined
[04:21] *** Tonik joined
[04:22] *** girafe joined
[04:23] *** itcharlie1 left
[04:25] *** pierre left
[04:26] *** Tonik left
[04:28] *** agentzh joined
[04:36] *** mr_ron left
[04:41] *** mcmillhj left
[04:43] <ZzZombo> GG Github search, searching for "keyvalue" in ValveSoftware/source-sdk-2013 yeilds nothing, but a bit of navigating and I found this: https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/tier1/KeyValues.cpp.

[04:47] *** khw left
[04:51] *** agentzh left
[04:52] *** pierre joined
[04:55] *** Cabanoss- joined
[04:57] *** pierre left
[04:59] *** Cabanossi left
[04:59] *** Cabanoss- is now known as Cabanossi

[05:14] *** yadzi joined
[05:16] *** cdg_ joined
[05:19] *** cdg left
[05:19] *** wamba1 joined
[05:28] *** pyrimidine joined
[05:32] *** pyrimidine left
[05:33] *** mcmillhj joined
[05:33] *** pyrimidine joined
[05:37] *** mcmillhj left
[05:37] *** pyrimidine left
[05:41] *** eythian left
[05:41] *** eythian_ joined
[05:42] <TimToady> IOninja: it would have to be '#' {*} anyway, since bare * is a valid quantifier

[05:43] *** aborazmeh left
[05:44] <TimToady> m: my token eol { \h* [\w+\n || \n] <eol>* };say "asd\n    dsa\n" ~~ /<eol>/

[05:44] <camelia> rakudo-moar 90dfdf: OUTPUT: «No such method 'eol' for invocant of type 'Cursor'␤  in regex eol at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[05:44] <TimToady> m: my token eol { \h* [\w+\n || \n] <&eol>* };say "asd\n    dsa\n" ~~ /<eol>/

[05:44] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢asd␤    dsa␤｣␤ eol => ｢asd␤    dsa␤｣␤»

[05:44] <TimToady> I thought the form without & used to work at one time, hmm...

[05:45] <TimToady> ZzZombo: ^^^

[05:45] <ZzZombo> thank you

[05:46] <TimToady> dinner &

[05:51] *** curan joined
[06:04] *** rurban joined
[06:07] *** cyphase left
[06:08] *** bwisti joined
[06:08] *** pierre joined
[06:11] *** llfourn left
[06:12] *** cyphase joined
[06:12] *** pierre left
[06:14] *** hartenfels joined
[06:22] *** ufobat_ joined
[06:34] *** pyrimidine joined
[06:37] *** hartenfels1 joined
[06:39] *** hartenfels left
[06:39] *** hartenfels1 is now known as hartenfels

[06:41] *** wamba1 left
[06:42] *** cibs left
[06:43] *** labster left
[06:43] *** cibs joined
[06:50] *** RabidGravy joined
[07:04] *** agentzh joined
[07:06] *** cibs left
[07:08] *** cibs joined
[07:08] *** agentzh left
[07:08] *** llfourn joined
[07:08] *** cgfbee left
[07:13] *** llfourn left
[07:14] *** labster joined
[07:19] *** cgfbee joined
[07:26] *** wamba1 joined
[07:27] *** cibs left
[07:27] *** kaare_ left
[07:28] *** Sqirrel left
[07:28] *** cibs joined
[07:31] *** AlexDaniel joined
[07:31] *** darutoko joined
[07:33] *** cschwenz joined
[07:35] <gfldex> [Coke]: do you remember in what method IO::Handle did throw? If it's just one we could mix in a role with a methods that does nothing and could drop the dep again.

[07:35] *** Sqirrel joined
[07:36] *** faraco joined
[07:36] <faraco> howdy

[07:38] <cschwenz> as MoarVM, Rakudo, Rakudo Star, and NQP are under the Artistic License 2.0… am i correct in stating Perl 6 is under the Artistic License 2.0?

[07:41] <gfldex> cschwenz: it means that one compiler that implements Perl 6 is released under the terms of that license. The language itself is an abstract concept.

[07:45] <cschwenz> okay, fair enough.  just wanting to get licensing of my perl6 code correct to mitigate license mismatches and the resulting addition mental workload around "can i use this thing?" (for example, consider a Perl 6 project which uses AGPL3)

[07:45] *** eythian_ is now known as eythian

[07:48] *** bwisti left
[07:49] *** TEttinger left
[07:49] *** abraxxa joined
[07:52] *** bolangi left
[07:53] *** kaare_ joined
[07:55] <ZzZombo> how can I declare a hash in a class of some type?

[07:55] <gfldex> m: class C { has %.h }; dd C.new

[07:55] <camelia> rakudo-moar 90dfdf: OUTPUT: «C.new(h => {})␤»

[07:56] <gfldex> ZzZombo: your question does not compute

[07:56] <gfldex> do you want to type on the class, the hash keys or the hash values?

[07:56] <ZzZombo> maybe I wasn't clear enough, I mean the hash should have a type constraint of,say String:D;

[07:57] <ZzZombo> hash values

[07:57] <gfldex> m: class C { has %.h of Int }; dd C.new

[07:57] <camelia> rakudo-moar 90dfdf: OUTPUT: «C.new(h => (my Int %))␤»

[07:57] <gfldex> m: class C { has Int %.h }; dd C.new

[07:57] <camelia> rakudo-moar 90dfdf: OUTPUT: «C.new(h => (my Int %))␤»

[07:58] <gfldex> https://docs.perl6.org/type/Hash#Constraint_value_types

[07:58] <ZzZombo> since you mentioned it, how can you constrain the type of keys?

[07:59] <gfldex> m: class C { has %.h{Int} }; dd C.new

[07:59] <camelia> rakudo-moar 90dfdf: OUTPUT: «C.new(h => (my Any %{Int}))␤»

[07:59] <gfldex> it's not really a constrain on the keys tho. It actually specialises the Hash itself.

[08:00] <ZzZombo> is there any difference?

[08:00] <cschwenz> does the specialization survive a .clone ?

[08:02] <gfldex> m: my %h{Int}; dd %h; my \h = %h.clone; dd h;

[08:02] <camelia> rakudo-moar 90dfdf: OUTPUT: «Hash[Any,Int] %h = (my Any %{Int})␤(my Any %{Int})␤»

[08:05] *** dakkar joined
[08:09] *** llfourn joined
[08:10] <gfldex> ZzZombo: see https://github.com/rakudo/rakudo/blob/nom/src/core/Hash.pm#L454

[08:14] *** xtreak left
[08:14] *** llfourn left
[08:17] *** xtreak joined
[08:17] *** xinming_ joined
[08:20] *** xinming left
[08:20] *** faraco left
[08:21] *** zakharyas joined
[08:26] *** rindolf joined
[08:28] *** Qwerasd joined
[08:28] *** ChoHag joined
[08:41] <Qwerasd> Can someone explain to me why 'print [0..5] ~ "\n"' prints '0 1 2 3 4 5'~"\n" whereas 'say [0..5]' prints '[0 1 2 3 4 5]'~"\n"

[08:42] <moritz> Qwerasd: say() uses .gist to convert its arguments to strings

[08:42] <moritz> and .gist is optimized for human consumption, whereas perl uses .Str, which is optimized for computer consumption, roughly speaking

[08:43] <Qwerasd> I'm relatively new to perl6 -- that's an understatement I just brew installed it, I decided to give it a try after years of perl5 and seeing that perl6 code looks much more readable.

[08:44] <ZzZombo> m: my token string { '"'~'"' <( [\N | \\<[\\ " n t]>]* )> || <-[\s { } "]>+ };say '"GameInfo"' ~~ /<string>/

[08:44] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢GameInfo｣␤ string => ｢GameInfo｣␤»

[08:45] <ZzZombo> how come this works fine here, but my grammar fails at the very first token that is exactly "GameInfo"?

[08:45] <moritz> hard to tell without seeing your grammar

[08:46] <moritz> have you tried removing the <( and )> ?

[08:46] <ZzZombo> currently I shrunk it down to "token TOP { [<string><.ws>?]* }"

[08:47] <ZzZombo> and it still fails miserably.

[08:47] <Qwerasd> The whole suffixing functions with .func thing is very javascript looking. I.E. .list, .gist, .Str, etc.

[08:47] <moritz> we call them methods

[08:47] <ZzZombo> and the file I tried to parse starts exactly with "GameInfo"

[08:47] <Qwerasd> Ah.

[08:47] <ZzZombo> complete with the quotes.

[08:50] <Qwerasd> Well, in javascript the suffixed functions are part of a prototype I.E. 'String.prototype.append = function() { }'. How do methods work in perl6? Is it similar to javascript's style or does it still have the same philosophy of perl5's very -- well, variable variable types?

[08:51] *** wamba1 left
[08:51] <moritz> Qwerasd: Perl 6 has a meta object protocol, and a default class-based OO implementation

[08:51] <moritz> (but not only supporting classes, also roles, subset types, enums etc.)

[08:52] <Qwerasd> Can you dumb it down for a poor tired soul? I'm quite literally tired, it's 4 in the morning for me haha.

[08:52] *** kyan left
[08:52] <Qwerasd> Expand "meta object protocol", I get the rest except that.

[08:53] <zengargoyle> hey, any Perl6 peeps going to SCALE 15x (the Southern California Linux Expo)?  i'll be at the Los Angeles Perlmongers booth for a bit hopefully doing a bit of Perl promotion...

[08:53] <Qwerasd> God knows perl needs promotion, it's the internet's punching bag -- language-wise.

[08:54] * zengargoyle of course most P6 seem to be on the other side of the world, but you never know.... :P

[08:55] <Qwerasd> I do like the way perl 6 is syntaxed, it looks a lot like javascript.

[08:55] <moritz> ZzZombo: the problem might be that a grammar always wants to match the string completely, but using <( and )> inside a regex limits the extend of the match

[08:56] <moritz> Qwerasd: Perl 6 has classes, pretty much like python, except with a more declarative syntax

[08:56] <ZzZombo> huh, I've been using them in that particular rule for two days, only now it started to misfire.

[08:57] <moritz> then maybe that hyposis is wrong

[08:57] <moritz> so, what changed?

[08:57] <Qwerasd> I'll just look up some examples of perl 6 OO and let my brain marinate.

[08:57] <ZzZombo> well, I've rewrote all other rules, pretty much only that.

[08:57] <ZzZombo> that is, the string rule wasn't touched.

[08:58] <Qwerasd> I like the naming of the "WHAT" method.

[08:59] <Qwerasd> I also like the even further non-enforcement of using parens.

[09:00] *** astj left
[09:00] <ZzZombo> m: my token string { '"'~'"' ([\N | \\<[\\ " n t]>]*) || (<-[\s { } "]>+) };say '"GameInfo"' ~~ /<string>/

[09:00] <camelia> rakudo-moar 90dfdf: OUTPUT: «｢GameInfo｣␤ string => ｢GameInfo｣␤  0 => ｢GameInfo｣␤»

[09:00] <ZzZombo> WTF, this version still fails locally.

[09:00] *** astj joined
[09:00] *** jonas1 joined
[09:02] <ZzZombo> Qwerasd: I like pretty much everything but classes. Classes in P6 are too awkward for me.

[09:02] <Qwerasd> They're too simplified, ZzZ

[09:02] <ZzZombo> yea, that.

[09:03] <ZzZombo> I hoped for an quality improvement over P5, but was disappointed. Why basically implemented Moo(se) in core.

[09:04] <ZzZombo> They*

[09:04] <Qwerasd> If the way they are implemented was syntactic sugar, and a more perl 5-like way was still available I'd like that.

[09:05] <Qwerasd> The way they have them doesn't allow for stranger objects, like perl 5 does (at least that's not apparent on the surface from what I can see)

[09:05] <jnthn> Moose was in the first place inspired muchly by Perl 6's OO design.

[09:05] <gfldex> Qwerasd: we allow any degree of strangeness

[09:05] <Qwerasd> *most* objects in perl5 are just glorified hashes, but the keyword there is most.

[09:07] <gfldex> m: class C { method FALLBACK(|c) { say "WAAAAA HAAA HAAA HAAA" } }; my $c = C.new; $c.be-sane-now

[09:07] <camelia> rakudo-moar 90dfdf: OUTPUT: «WAAAAA HAAA HAAA HAAA␤»

[09:07] <Qwerasd> I mean, you could write a perl 5 style object in perl 6.

[09:07] <Qwerasd> By just writing an initializer.

[09:08] <gfldex> you could do that woth a slang. It would be silly but can be done.

[09:08] <Qwerasd> is FALLBACK called if an unknown method is used?

[09:08] <gfldex> yes

[09:08] *** llfourn joined
[09:09] <Qwerasd> Is perl6 code very easy to debug, it seems like it really doesn't like erroring.

[09:09] <gfldex> or better, if FALLBACK is defined, it becomes the dispatcher for objects of that class

[09:10] <Qwerasd> Reword that, I didn't understand what that meant.

[09:10] <gfldex> it's a lot easier to debug, mostly because any Perl 6 program will have less bugs to start with

[09:10] <Qwerasd> Haha

[09:10] <gfldex> then, most mistakes can be caught earlier with type checks

[09:11] <Qwerasd> So perl6 is very heavily typed then.

[09:11] <gfldex> and there is a debugger and tracer for grammars, and as such, for regex

[09:11] <Qwerasd> Whereas the typing in perl5 is much more obfuse

[09:11] <gfldex> not really

[09:11] <gfldex> it is heavily typed but most of the time it uses the default type Any

[09:11] <gfldex> that you don't need to type

[09:12] <gfldex> see https://gfldex.wordpress.com/2015/11/28/perl-6-is-a-code-generator/

[09:12] *** agentzh joined
[09:13] *** llfourn left
[09:13] <gfldex> there are plenty of buildin types and most of you debugging consists of .WHAT.say

[09:14] <Qwerasd> So I don't suppose any monster constructions like @$$ArrayRefRef would be seen in perl6

[09:14] *** Lucas_One joined
[09:14] <gfldex> no, references are the default and Any and Cool take care of most type casts for you

[09:15] *** cibs left
[09:15] <Qwerasd> Saying "Any and Cool" doesn't help, I've no idea anything about Any and Cool.

[09:16] <gfldex> see https://docs.perl6.org/language/typesystem#Definition_of_a_Perl_6_Type

[09:16] *** agentzh left
[09:16] <arnsholt> Any is the root of the standard type hierarchy

[09:16] <arnsholt> So an class you define will be a subclass of Any

[09:16] *** cibs joined
[09:16] <gfldex> Mu is the root but Any is the default parent of any class

[09:16] <arnsholt> (There are some types that don't inherit from Any, like junctions, but that's fairly esoteric)

[09:17] <arnsholt> Cool is the type that handles most of the Perly dwimminess of converting between integer and string representations and such

[09:17] <arnsholt> (Because those objects are cool with it =)

[09:18] <Qwerasd> There are a lot of very unique operators in perl 6

[09:18] <Qwerasd> that have very bizzare names, making it so unless you know what the operators do, it's hard to make heads or tails of some snippets of code.

[09:19] <gfldex> they are not uniq at all, you can find them in other languages as well. We do use uniq names for them tho, to make reading code possible without having to keep track of the type of every variable.

[09:19] *** chee is now known as need

[09:19] *** need is now known as chee

[09:20] <Qwerasd> I mean, having stuff like "has $.myVar is rw" unless you know what it does makes no sense to read.

[09:20] <gfldex> that is true for any feature of any language

[09:21] <Qwerasd> Yes, but most languages have similar operators.

[09:21] <gfldex> what sucks

[09:21] <Qwerasd> I think maybe perl 6 is a little too concise, but that's just a surface level impression.

[09:22] <gfldex> we got +| as the bitwise or operator, other languages us the same operator for bitwise and logic operations

[09:22] <Qwerasd> bitwise OR is always always ||

[09:22] <Qwerasd> | **

[09:22] <gfldex> so you need to keep track of the type of both operands

[09:22] <Qwerasd> not ||

[09:22] <gfldex> if you are unlucky you got an automatic type cast where you don't want one

[09:23] <gfldex> those bugs can be nasty to track down

[09:23] <gfldex> that's an entire class of bugs that don't exist in Perl 6

[09:23] <Qwerasd> | OR, ^ XOR, & AND, and NOT is a bit nonstandard, it changes between languages

[09:25] <arnsholt> How often do you actually need bitwise logic in Perl though?

[09:25] <gfldex> since it's slow as fuck, we don't need it at all right now :)

[09:25] <arnsholt> Those operators were taking up valuable real-estate, so Larry decided to move the bitwise stuff to less prominent ops, so that more useful things could take stuff like | and &

[09:26] <Qwerasd> You're talking to a guy currently working on a CPU emulator that emulates the generic bitwise logic.

[09:26] <gfldex> we got operators for you!

[09:27] <Qwerasd> Haha, well, I'm writing it in javascript.

[09:29] <arnsholt> Well, in that case if it really bothers you to use the default operators, you can always redefine it:

[09:29] <arnsholt> m: multi infix:<|>($a, $b) { $a +| $b }; say 1 | 2

[09:29] <camelia> rakudo-moar 90dfdf: OUTPUT: «3␤»

[09:30] <gfldex> m: sub infix:<∨>(\a, \b){a +| b}; say (123 ∨ 456);

[09:30] <camelia> rakudo-moar 90dfdf: OUTPUT: «507␤»

[09:30] <Qwerasd> '.say for [1..100]; say "Poof!"' This is a fun challenge to try to code golf.

[09:33] <cosimo> 1

[09:33] <Qwerasd> 1 what?

[09:34] <arnsholt> m: .say for [1..100]; say "Poof!"

[09:34] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤52␤53…»

[09:34] <Qwerasd> It on seperate lines prints the numbers from 1 to 100 and then "Poof!"

[09:35] *** cdg_ left
[09:35] <Qwerasd> even better '.say for [1..100, "Poof!"]'

[09:35] <Qwerasd> o

[09:36] <Qwerasd> that doesn't work in perl6

[09:36] *** lukaramu joined
[09:36] <arnsholt> m: .say for |(1..5), "Poof";

[09:36] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤2␤3␤4␤5␤Poof␤»

[09:37] <Qwerasd> '.say for [1..100].push("Poof!");' there

[09:37] <arnsholt> List flattening is different in Perl 6

[09:37] <Qwerasd> ah I see

[09:39] <Qwerasd> That's probably the shortest out of all langs I've tried this in, then, '.say for |(1..100),"Poof!";'

[09:39] <Qwerasd> only, 27 chars

[09:41] <Qwerasd> in perl5 it's 'print $_."\n" for @{[1..100,"Poof!"]}' which is significantly longer

[09:43] <arnsholt> No need to do the @{[]} shenanigans, though

[09:43] <Qwerasd> Try it without,

[09:44] <arnsholt> 1..100, "Poof!" works fine on its own in my Perl

[09:44] <arnsholt> Or rather 1..5

[09:44] <arnsholt> Because I'm lazy

[09:44] <Qwerasd> ah right, I don't need the [] around it

[09:44] <Qwerasd> that's my mistake

[09:44] <arnsholt> And on 5.12 and later there's say

[09:44] <Qwerasd> I thought of an interesting code golf, for 1..100 print $_ factorial

[09:44] <arnsholt> perl -E 'say for 1..5,"Poof!"'

[09:46] <moritz> m: say [*] 1..$_ for 1..20

[09:46] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤2␤6␤24␤120␤720␤5040␤40320␤362880␤3628800␤39916800␤479001600␤6227020800␤87178291200␤1307674368000␤20922789888000␤355687428096000␤6402373705728000␤121645100408832000␤2432902008176640000␤»

[09:46] <Qwerasd> Impressive

[09:48] <moritz> m: say[*] 1..$_ for 1..20

[09:48] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Use of non-subscript brackets after "say" where postfix is expected; please use whitespace before any arguments␤at <tmp>:1␤------> 3say7⏏5[*] 1..$_ for 1..20␤    expecting any of:␤        arg…»

[09:48] <moritz> m: say [*]1..$_ for 1..20

[09:48] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say [*]7⏏051..$_ for 1..20␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement mod…»

[09:49] <Qwerasd> m: say [*] 1.. for 1..10

[09:49] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    for used at line 1␤␤»

[09:49] *** robertle left
[09:49] <Qwerasd> m: say [*] 1..  for 1..10

[09:49] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    for used at line 1␤␤»

[09:49] <moritz> m: .say for [\*] 1..10

[09:49] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤2␤6␤24␤120␤720␤5040␤40320␤362880␤3628800␤»

[09:50] <Qwerasd> m: .say for [\+} 1..10

[09:50] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Prefix + requires an argument, but no valid term found␤at <tmp>:1␤------> 3.say for [\+7⏏5} 1..10␤    expecting any of:␤        prefix␤»

[09:50] <Qwerasd> oops

[09:50] <Qwerasd> m: .say for [\+] 1..10

[09:50] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤3␤6␤10␤15␤21␤28␤36␤45␤55␤»

[09:51] <Qwerasd> triangle numbers.

[09:51] <Qwerasd> m: .say for [\/] 1..10

[09:51] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤0.5␤0.166667␤0.041667␤0.008333␤0.001389␤0.000198␤0.000025␤0.0000028␤0.00000028␤»

[09:51] <moritz> more general, reduce with intermediate results

[09:52] <jnthn> It's deliberate that [\ looks like a triangle, fwiw :)

[09:53] <Qwerasd> moritz: is that a challenge, I don't understand what the challenge is if it is, and if it's an explanation of something I still don't understand.

[09:55] <Qwerasd> m: .say for [\+|] 1..10

[09:55] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤3␤3␤7␤7␤7␤7␤15␤15␤15␤»

[09:55] <Qwerasd> Woah, that's like, all sorts of binary.

[09:55] <Qwerasd> m: .say for [\+^] 1..10

[09:55] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤3␤0␤4␤1␤7␤0␤8␤1␤11␤»

[09:56] <Qwerasd> That is also very binary, who'd'a thunk?

[09:56] *** cibs left
[09:57] <Qwerasd> m: .say for [\+&] 1..10

[09:57] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[09:58] <Qwerasd> Well that one was obvious

[09:58] *** cibs joined
[09:58] <Qwerasd> m: .say for [\^] 1..10

[09:58] <camelia> rakudo-moar 1811b8: OUTPUT: «one(1)␤one(1, 2)␤one(1, 2, 3)␤one(1, 2, 3, 4)␤one(1, 2, 3, 4, 5)␤one(1, 2, 3, 4, 5, 6)␤one(1, 2, 3, 4, 5, 6, 7)␤one(1, 2, 3, 4, 5, 6, 7, 8)␤one(1, 2, 3, 4, 5, 6, 7, 8, 9)␤one(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)␤»

[09:58] <Qwerasd> What does the ^ operator do in perl6, I shoulda figured that out beforehand.

[09:59] <timotimo> it creates a "one" junction

[09:59] <timotimo> like | creates an "any" junction and & creates an "all" junction

[09:59] <Qwerasd> What are junctions?

[09:59] <Qwerasd> m: .say for [\**] 1..10

[09:59] <timotimo> think of them as superpositions of values

[09:59] <camelia> rakudo-moar 1811b8: OUTPUT: «(timeout)10␤3486784401␤»

[10:00] <timotimo> m: say "yay" if any(1, 2, 3) >= 3;

[10:00] <camelia> rakudo-moar 1811b8: OUTPUT: «yay␤»

[10:00] <timotimo> m: say "yay" if all(2, 3, 4) >= 3;

[10:00] <camelia> rakudo-moar 1811b8: ( no output )

[10:00] <timotimo> m: say "yay" if one(2, 3, 4) > 3;

[10:00] <camelia> rakudo-moar 1811b8: OUTPUT: «yay␤»

[10:01] <Qwerasd> K

[10:01] <Qwerasd> Why did it have so much trouble with exponents?

[10:01] <Qwerasd> It hit a numeric overflow and then didn't know how to handle it is my guess since when I ran it in my terminal it hit a numeric overflow.

[10:02] <moritz> Qwerasd: because exponentiation is right-associative, and [\**] respects that

[10:02] <Qwerasd> mmmm

[10:02] <moritz> so a**b**c is actually a**(b**c)

[10:04] <timotimo> but ... how

[10:04] <timotimo> 1 ** 2 ** 3 ** 4 is just 1?

[10:04] <timotimo> oh

[10:04] <timotimo> right associative

[10:04] <timotimo> you already said that

[10:07] <Qwerasd> the docs.perl6.org is much... brighter than perldoc...

[10:07] <gfldex> that's to indicate your future :->

[10:08] <timotimo> is it because links are blue instead of black?

[10:09] <ZzZombo> is there a more generic way to express [\n || $] in grammar? That is, end of line/input, but advancing past newlines if possible.

[10:09] <Qwerasd> It's because the background is FFFFFF white instea of grey

[10:09] *** Sqirrel left
[10:09] <Qwerasd> No shorthand if else in perl6? I tried $x?trueResult():falseResult()

[10:09] *** llfourn joined
[10:10] <timotimo> it's spelled ?? !!

[10:10] <gfldex> m: say Ture ?? 'oi‽' !! 'naaa'

[10:10] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Expected a term, but found either infix ?? or redundant prefix ?␤  (to suppress this message, please use a space like ? ?)␤at <tmp>:1␤------> 3say Ture ??7⏏5 'oi‽' !! 'naaa'␤»

[10:10] <Qwerasd> weird

[10:10] <Qwerasd> ture

[10:11] <gfldex> m: say (True ?? 'oi‽' !! 'naaa');

[10:11] <camelia> rakudo-moar 1811b8: OUTPUT: «oi‽␤»

[10:11] <jnthn> m: say True ?? 'oi‽' !! 'naaa'

[10:11] <camelia> rakudo-moar 1811b8: OUTPUT: «oi‽␤»

[10:11] *** CIAvash joined
[10:12] <Qwerasd> m: say False ?? '∆' !! 'π'

[10:12] <camelia> rakudo-moar 1811b8: OUTPUT: «π␤»

[10:14] <timotimo> bisectable6: say 4.9999999999999999 ~~ 1..^5

[10:14] <bisectable6> timotimo, On both starting points (old=2015.12 new=1811b80) the exit code is 0 and the output is identical as well

[10:14] <bisectable6> timotimo, Output on both points: False

[10:14] *** llfourn left
[10:14] <timotimo> apparently we've always been comparing Rat by turning them into .Num first

[10:15] <ZzZombo> why does Grammar::Trace not show non named parts of regex matching?

[10:15] <ZzZombo> it it possible to enable that?

[10:15] <ZzZombo> is it*

[10:19] <Qwerasd> me: True|False ?? say "yo"

[10:19] <Qwerasd> me: True||False ?? say "yo"

[10:19] <Qwerasd> no me, haha

[10:19] <Qwerasd> m: True|False ?? say "yo"

[10:19] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused: Found ?? but no !!␤at <tmp>:1␤------> 3True|False ?? say "yo"7⏏5<EOL>␤    expecting any of:␤        postfix␤»

[10:19] <Qwerasd> m: say True|False ??"yo" !! ""

[10:19] <camelia> rakudo-moar 1811b8: OUTPUT: «yo␤»

[10:24] <Qwerasd> 'say (!($_%3) ?? "Fizz"~(!($_%5) ?? "Buzz" !! "") !! (!($_%5) ?? "Buzz" !! $_)) for 1..25' Y'all should try to code golf this.

[10:25] <ZzZombo> ===SORRY!===

[10:25] <ZzZombo> Type check failed in binding to assignval; expected Grammar::VDF::Key-Value:D but got Array

[10:26] <ZzZombo> Any way to get the source of the error? Isn't it supposed to output that by default, like camelia does?

[10:29] *** Ven joined
[10:29] <Ven> m: my $a = 0; my $b = 0; $a := $b;

[10:29] <camelia> rakudo-moar 1811b8: ( no output )

[10:30] <Ven> star: my $a = 0; my $b = 0; $a := $b;

[10:30] <camelia> star-m 2016.10: ( no output )

[10:30] <Qwerasd> Anyone going to code golf that I put?

[10:31] <Ven> This doesn't work in the REPL.

[10:31] <Ven> I guess this is because of how the REPL does frames. Not sure if this is worth reporting?

[10:33] <jnthn> Ven: How does it fail?

[10:33] *** llfourn joined
[10:33] <Qwerasd> I codegolfed it a little bit. 'say (!($_%3)??"Fizz"!!"")~(!($_%5)??"Buzz"!!"")~(($_%3&$_%5)??$_!!"") for 1..25'

[10:34] <Ven> jnthn: ===SORRY!=== Error while compiling: Cannot use bind operator with this left-hand side ------> $a := $b⏏;

[10:35] <Ven> Qwerasd: `!($_%3)` is `$_%%3`

[10:35] <Qwerasd> ooo, useful

[10:36] <Qwerasd> 'say ($_%%3??"Fizz"!!"")~($_%%5??"Buzz"!!"")~($_%3&$_%5??$_!!"") for 1..25'

[10:37] <timotimo> ooooh it's a ven!

[10:37] <timotimo> the ven diagram now has ven's circle overlapping with #perl6's circle :P

[10:37] <Ven> timotimo: hi timo, how is your timo doing?

[10:38] <timotimo> my timo's okay

[10:38] <jnthn> Ven: Hm, think that one already is reported :)

[10:38] <Ven> jnthn: alright, thanks. I know there are well-known bugs in the REPL-and-scoping-aren't-friends category

[10:39] <timotimo> yeah ;(

[10:39] <ZzZombo> !!!

[10:40] <timotimo> XXX

[10:40] <ZzZombo> type constraining values in hash breaks .push and .append, that's the cause of the error.

[10:40] <ZzZombo> what do :(

[10:41] <Ven> Qwerasd: "{"Fizz"if $_%%3}{"Buzz"if $_%%5}" is golfier

[10:41] <Qwerasd> Where is the $_ if neither?

[10:42] <timotimo> ZzZombo: it seems like your code was trying to autovivify an array inside your array

[10:42] <Qwerasd> also will that work for the FizzBuzz ?

[10:42] <Ven> Qwerasd: here's my golf: say "{"Fizz"if $_%%3}{"Buzz"if $_%%5}"||$_ for 1..25

[10:42] <timotimo> ZzZombo: compare this:

[10:42] <Qwerasd> impressive, ven

[10:42] <timotimo> m: my @foo; @foo[1][2] = 99; dd @foo

[10:42] <camelia> rakudo-moar 1811b8: OUTPUT: «Array @foo = [Any, [Any, Any, 99]]␤»

[10:43] <ZzZombo> no exactly, .push turned a key into array because of a duplicate name.

[10:43] <ZzZombo> not*

[10:43] <Ven> Qwerasd: I'm fond of PPCG, though b2gills usually outgolfs my Perl 6 answers :). (or outspeeds me)

[10:43] <ZzZombo> well, tried to turn.

[10:43] <timotimo> right, so it's like this:

[10:43] <timotimo> m: my %stuff; %stuff<hello> = "hi"; %stuff.push("hello" => 99); dd %stuff

[10:43] <camelia> rakudo-moar 1811b8: OUTPUT: «Hash %stuff = {:hello($["hi", 99])}␤»

[10:45] <ZzZombo> well, more like my Int:D %hash ...

[10:45] <Ven> D:

[10:45] *** mcmillhj joined
[10:45] <Ven> `use InvertedTypeSmiley;`

[10:48] <gfldex> Ven did you mean "ᗡ:"?

[10:48] <Qwerasd> Lol

[10:48] <Ven> gfldex: I obviously did, thanks. :)

[10:48] <gfldex> http://www.twiki.org/cgi-bin/view/Blog/BlogEntry201211x1

[10:48] *** Qwerasd left
[10:49] *** mcmillhj left
[10:57] <gfldex> m: ⸵9ʌ ǝsn

[10:57] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Bogus statement␤at <tmp>:1␤------> 3<BOL>7⏏5⸵9ʌ ǝsn␤    expecting any of:␤        prefix␤        term␤»

[10:57] <gfldex> looks like Rakudo wont work in Australia

[10:59] <ZzZombo> YAY

[10:59] <ZzZombo> Almost done

[11:00] <ZzZombo> Now, where do I apply for contributing a module?

[11:00] <gfldex> ZzZombo: see https://github.com/perl6/ecosystem/

[11:01] <gfldex> ZzZombo: I found it good advice to use travis before commiting to the ecosystem

[11:02] <ZzZombo> what's that? All I know it always reports that "doc build errored".

[11:02] <gfldex> travis uses container magic to test stuff in a clean install

[11:02] <gfldex> if you forgot to provide deps in the META* it will tell you

[11:02] <ZzZombo> Do I have to install anything for that?

[11:02] <gfldex> no

[11:03] <gfldex> it fetches stuff from github for you

[11:03] <gfldex> and you sign in with your github account

[11:03] <ZzZombo> well then, I could look into it.

[11:03] <gfldex> https://travis-ci.org/

[11:04] <gfldex> you may want to steal the .travis.yml form some other project

[11:06] *** cdg joined
[11:07] <ZzZombo> Is there some way to automatically change type of a variable as appropriate so it would first try float, int and then finally leave it as a string?

[11:07] <ZzZombo> I want parsed values to be stored in "native" form, and only use string as a last resort. I guess I could just process them again though.

[11:07] *** cschwenz left
[11:08] *** labster left
[11:09] <jnthn> Does val maybe do what you want?

[11:09] <IOninja> m: try {.Numeric} andthen .^name.say orelse .^name.say val('42e5').Numeric

[11:09] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ic} andthen .^name.say orelse .^name.say7⏏5 val('42e5').Numeric␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤  …»

[11:09] <IOninja> m: try {.Numeric} andthen .^name.say orelse .^name.say with val '42e5'

[11:09] <camelia> rakudo-moar 1811b8: OUTPUT: «Slip␤»

[11:09] <IOninja> bah

[11:09] <IOninja> stupid bug

[11:10] <jnthn> m: say val("42").WHAT

[11:10] <camelia> rakudo-moar 1811b8: OUTPUT: «(IntStr)␤»

[11:10] <jnthn> m: say val("4.22").WHAT

[11:10] <camelia> rakudo-moar 1811b8: OUTPUT: «(RatStr)␤»

[11:10] <jnthn> m: say val("not a number").WHAT

[11:10] <camelia> rakudo-moar 1811b8: OUTPUT: «(Str)␤»

[11:10] <ZzZombo> nice!

[11:10] <IOninja> m: $_ ~~ Numeric ?? .Numeric.^name.say !! .^name.say with val '42e5'

[11:10] <camelia> rakudo-moar 1811b8: OUTPUT: «Num␤»

[11:10] <ZzZombo> thanks!

[11:10] <IOninja> m: $_ ~~ Numeric ?? .Numeric.^name.say !! .^name.say with val 'blah'

[11:10] <camelia> rakudo-moar 1811b8: OUTPUT: «Str␤»

[11:10] *** cdg left
[11:11] <Ven> IOninja: why are you coercing if it's already a Numeric?

[11:11] <IOninja> ZzZombo: basically you get an allomorph. You can leave it as is, or call .Numeric on it to get the number.

[11:11] <Ven> m: .Numeric.^name.say with val 'blah'

[11:11] <camelia> rakudo-moar 1811b8: OUTPUT: «Failure␤»

[11:11] <Ven> m: .Numeric.^name.say orelse "oops" with val 'blah'

[11:11] <camelia> rakudo-moar 1811b8: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "oops" in sink context (line 1)␤Failure␤»

[11:11] <Ven> m: (.Numeric.^name // "oops").say with val 'blah'

[11:11] <camelia> rakudo-moar 1811b8: OUTPUT: «Failure␤»

[11:11] <Ven> m: (.Numeric.^name orelse "oops").say with val 'blah'

[11:11] <camelia> rakudo-moar 1811b8: OUTPUT: «Failure␤»

[11:11] <Ven> sigh.

[11:12] <IOninja> don't use .^name

[11:12] <Ven> yeah, it's too late

[11:12] <IOninja> I'm coercing because you don't always want to deal with an allomorph

[11:12] <Ven> m: say val('h') ~~ Numeric; say val('1') ~~ Numeric;

[11:12] <camelia> rakudo-moar 1811b8: OUTPUT: «False␤True␤»

[11:12] <Ven> alright

[11:12] <IOninja> m: bag(42, <42>).keys.elems.say

[11:12] <camelia> rakudo-moar 1811b8: OUTPUT: «2␤»

[11:13] <IOninja> And the Slip in my first eval is the Empty given by `andthen`... actually not even a bug

[11:13] *** risou is now known as risou_awy

[11:13] <IOninja> m: try {.Numeric} andthen .^name.say or .^name.say with val '42e5'

[11:13] <camelia> rakudo-moar 1811b8: OUTPUT: «NumStr␤»

[11:13] <IOninja> m: try {.Numeric} andthen .^name.say or .^name.say with val 'foo'

[11:13] <camelia> rakudo-moar 1811b8: OUTPUT: «Str␤»

[11:14] <Ven> m: .Numeric andthen .^name.say orelse .^name.say with val 'foo'

[11:14] <camelia> rakudo-moar 1811b8: OUTPUT: «Slip␤»

[11:14] <Ven> m: .Numeric andthen .^name.say orelse .^name.say with val '1234'

[11:14] <camelia> rakudo-moar 1811b8: OUTPUT: «Int␤»

[11:14] *** risou_awy is now known as risou

[11:14] <Ven> m: val('abc').Numeric.^name.say

[11:14] <camelia> rakudo-moar 1811b8: OUTPUT: «Failure␤»

[11:15] <Ven> m: with val('foo').Numeric { .Numeric.^name.say } else { .^name.say }

[11:15] <camelia> rakudo-moar 1811b8: OUTPUT: «Failure␤»

[11:15] <Ven> I guess you're not supposed to chain andthen/orelse like that. Or maybe use notandthen...

[11:16] <Ven> m: (Failure.new andthen 1).^name.say

[11:16] <camelia> rakudo-moar 1811b8: OUTPUT: «Slip␤»

[11:16] <Ven> aye...

[11:16] <IOninja> well you get Empty in orelse.

[11:16] <IOninja> You can chain if you like, but you get an updated $_ not the original

[11:16] <IOninja> There is a bug with chaining though ATM: https://rt.perl.org/Ticket/Display.html?id=130798#ticket-history

[11:16] <Ven> m: say Slip.new orelse 1

[11:16] <camelia> rakudo-moar 1811b8: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (line 1)␤()␤»

[11:17] <ZzZombo> make $_ ~~ Numeric ?? .Numeric !! .Str with val ~$<string>[0];

[11:17] <ZzZombo> works like charm.

[11:17] <Ven> m: say (Slip.new orelse 1)

[11:17] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤»

[11:17] <IOninja> m: say (Empty orelse 1)

[11:17] <camelia> rakudo-moar 1811b8: OUTPUT: «1␤»

[11:17] <IOninja> there's a hack to make that work, but it ain't good anough

[11:18] <Ven> m: say ((.Numeric andthen .^name) orelse .^name) with val '1234'

[11:18] <camelia> rakudo-moar 1811b8: OUTPUT: «Int␤»

[11:18] <Ven> m: say ((.Numeric andthen .^name) orelse .^name) with val 'foo'

[11:18] <camelia> rakudo-moar 1811b8: OUTPUT: «Slip␤»

[11:18] <ZzZombo> stop fucking with my brain, please... that's too much Perl for me D:

[11:18] <IOninja> the failed andthen returns an Empty and you're calling .^name on it in your orelse

[11:18] <Ven> yeah you get the andthen's Slip :P.

[11:18] <IOninja> ZzZombo: you have to put a dollar in the swear jar.

[11:19] <ZzZombo> $dollar.give

[11:19] <Ven> my last readings of design documents predate andthen/orelse being implemented, and Slip/Empty existing, so I'm not sure.

[11:20] <Ven> > Returns the first argument whose evaluation indicates failure (that is, if the result is undefined).

[11:20] *** xtreak left
[11:20] <Ven> m: say Empty.defined; say (Empty andthen 1);

[11:20] <camelia> rakudo-moar 1811b8: OUTPUT: «False␤-> ;; $_ is raw { #`(Block|31254472) ... }␤»

[11:21] <Ven> m: say Empty.defined; say (Slip.new andthen 1);

[11:21] <camelia> rakudo-moar 1811b8: OUTPUT: «False␤-> ;; $_ is raw { #`(Block|31357720) ... }␤»

[11:21] <Ven> m: say Empty.defined; say (Failure.new andthen 1);

[11:21] <camelia> rakudo-moar 1811b8: OUTPUT: «False␤()␤»

[11:22] <Ven> so it's not returning the first !.defined argument...:P

[11:22] <IOninja> The Block thing is the bug I linked to. Basically you get a thunk as a block and the trick is: how do you figure out when it's a thunk and when it's user's block? The Empty and chaining messes up argument positions, so you get block returned

[11:22] <IOninja> Ven: it isn't. Not sure what you're reading. I thought I fixed the docs for that...

[11:23] <IOninja> barring the bug, it returns Empty

[11:23] <Ven> My bad, I'm reading the design documents. Where can I read up on why this was changed?

[11:23] <Ven> I remember mis-implementing andthen ~2 years ago along with timotimo :P.

[11:24] <timotimo> yeah, we did that very well

[11:24] <IOninja> postfix with/without compile to andthen/notendthen; to make them flatten properly they return Empty.

[11:24] <Ven> well, I misunderstood what was supposed to happen, and you helped me implement the wrong semantics timotimo++

[11:24] <IOninja> IMO that's a mistake, but TimToady ruled I was wrong :}

[11:24] <timotimo> %)

[11:24] <IOninja> s: &infix:<orelse>

[11:24] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/1811b80/src/core/operators.pm#L658

[11:24] <Ven> .oO( I don't know why you'd want to do that, but since it's Perl 6, it'll be easy nonetheless )

[11:25] <IOninja> Ven: there's some notes in the commit message: https://github.com/rakudo/rakudo/commit/287af6a37e00ad595425b2e63065d0ecdb5e1c92

[11:25] <IOninja> And that fix isn't good enough, hence https://rt.perl.org/Ticket/Display.html?id=130798#ticket-history

[11:25] <Ven> .oO( Perl 6 makes it easy to implement wrong things, so you can figure out where everything went awry quicker )

[11:26] <IOninja> I'm guessing the thunky blocks have annotations or something up on them or we can add them, so then we can look at them and just execute the thunks before returning them

[11:26] <Ven> IOninja: I see. thanks.

[11:26] <IOninja> And the problem will go away

[11:26] *** cibs left
[11:26] <Ven> I'm not overly surprised an heuristic would get a corner case wrong. I'm not sure on the difference between notandthen and orelse now, though...

[11:27] *** mcmillhj joined
[11:28] *** cibs joined
[11:29] <IOninja> Ven: notandthen aborts on the first .defined arg (returns empty); orelse returns it instead.

[11:30] <IOninja> m: Int notandthen "hi".say; Int orelse "hi".say

[11:30] <camelia> rakudo-moar 1811b8: OUTPUT: «hi␤hi␤»

[11:30] <IOninja> m: 42 notandthen "hi".say; 42 orelse "hi".say

[11:30] <camelia> rakudo-moar 1811b8: OUTPUT: «hi␤»

[11:30] *** risou is now known as risou_awy

[11:31] <IOninja> m: 42 notandthen "hi-notandthen".say; 42 orelse "hi-orelse".say

[11:31] <camelia> rakudo-moar 1811b8: OUTPUT: «hi-notandthen␤»

[11:31] <IOninja> doh

[11:32] *** mcmillhj left
[11:32] <IOninja> m: "hi-notandthen".say without 42

[11:32] <camelia> rakudo-moar 1811b8: ( no output )

[11:32] * IOninja don't get it

[11:33] <IOninja>  m: 42 notandthen "hi-notandthen".say notandthen "meow".say;

[11:33] <camelia> rakudo-moar 1811b8: OUTPUT: «hi-notandthen␤meow␤»

[11:33] <IOninja> don't get thunked properly?

[11:33] * IOninja & # work

[11:34] <IOninja> there ain't no tests for notandthen, so... it doesn't really exist in the language :P

[11:34] *** pyrimidine left
[11:35] *** xtreak joined
[11:40] *** xtreak left
[11:41] *** AlexDaniel left
[11:42] *** bjz joined
[11:46] <IOninja> m: my $x; my $y; my @a = ($x notandthen $y notandthen 'all systems are reset and ready to go'); my @b = ($x orelse $y orelse 'all systems are dead, using backup value'); dd [@a, @b]

[11:46] <camelia> rakudo-moar 1811b8: OUTPUT: «[["all systems are reset and ready to go"], ["all systems are dead, using backup value"]]␤»

[11:46] <IOninja> m: my $x = 42; my $y = 72; my @a = ($x notandthen $y notandthen 'all systems are reset and ready to go'); my @b = ($x orelse $y orelse 'all systems are dead, using backup value'); dd [@a, @b]

[11:46] <camelia> rakudo-moar 1811b8: OUTPUT: «[[], [42]]␤»

[11:46] <IOninja> There. Example that actually works.

[11:46] <IOninja> with notandthen you're checking stuff's undefined. with orelse you're trying to find the first defined thing

[11:48] *** cdg joined
[11:56] <IOninja> m: dd (42 notandthen "hi".say notandthen "meow".say)

[11:56] <camelia> rakudo-moar 1811b8: OUTPUT: «hi␤meow␤Empty␤»

[11:56] <IOninja> m: dd (Int andthen "hi".say andthen "meow".say)

[11:56] <camelia> rakudo-moar 1811b8: OUTPUT: «Empty␤»

[11:56] <IOninja> Don't see wtf is going on. Both use the same O config and their code is identical except one uses if .defined and other unless .defined :/

[11:58] <sammers> hi #perl6

[11:58] <IOninja> oh... missing it on this line methinks: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L6328

[11:59] <IOninja> \o

[12:00] *** konobi left
[12:00] <sammers> does iterating an array of hashes supposed to iterate over each pair if there is a single hash?

[12:00] <sammers> m: my @a = [%{ a => 'b', c => 'd'}]; my $i = 0; @a.map: -> %h { say $i; say %h.perl; $i++ }

[12:00] <camelia> rakudo-moar 1811b8: OUTPUT: «0␤:a("b")␤1␤:c("d")␤»

[12:01] <sammers> compared to the array having multiple hashes...

[12:01] <timotimo> well, your literal there is just an array of pairs

[12:01] <sammers> m: my @a = [%{ a => 'b', c => 'd'}, %{ e => 'f', g => 'h' }]; my $i = 0; @a.map: -> %h { say $i; say %h.perl; $i++ } 

[12:01] <camelia> rakudo-moar 1811b8: OUTPUT: «0␤{:a("b"), :c("d")}␤1␤{:e("f"), :g("h")}␤»

[12:01] <timotimo> single-arg rule there

[12:01] *** mcmillhj joined
[12:01] <timotimo> your [ ] is iterating over the contents

[12:01] <timotimo> m: dd [[[[[[[1]]]]]]]

[12:01] <camelia> rakudo-moar 1811b8: OUTPUT: «[1]␤»

[12:01] <sammers> ok

[12:01] <IOninja> m: my @a = [%{ a => 'b', c => 'd'},]; my $i = 0; @a.map: -> %h { say $i; say %h.perl; $i++ }

[12:01] <timotimo> m: dd [[[[[[[1],],],],],],]

[12:01] <camelia> rakudo-moar 1811b8: OUTPUT: «0␤{:a("b"), :c("d")}␤»

[12:01] <camelia> rakudo-moar 1811b8: OUTPUT: «[[[[[[[1],],],],],],]␤»

[12:02] <IOninja> m: my @a = %{ a => 'b', c => 'd'}; my $i = 0; @a.map: -> %h { say $i; say %h.perl; $i++ }

[12:02] <camelia> rakudo-moar 1811b8: OUTPUT: «0␤:a("b")␤1␤:c("d")␤»

[12:02] <IOninja> m: my @a = %{ a => 'b', c => 'd'},; my $i = 0; @a.map: -> %h { say $i; say %h.perl; $i++ }

[12:02] <camelia> rakudo-moar 1811b8: OUTPUT: «0␤{:a("b"), :c("d")}␤»

[12:02] <IOninja> No need for the []

[12:04] <sammers> why does it behave differently though? why not just treat the single hash inside the array as one iteration? 

[12:04] <timotimo> which exact one are we talking about right now?

[12:04] <sammers> I guess, I expect a single hash in an array to behave the same as multiple hashes in an array 

[12:05] *** bjz left
[12:05] <timotimo> you're not building a hash inside an array, though

[12:05] <timotimo> you're asking for the hash to be iterated and the result of it to make up the contents of the array

[12:05] <timotimo> that was introduced so that you could do stuff like [<foo bar baz>]

[12:05] <timotimo> m: dd [<foo bar baz>]

[12:05] <camelia> rakudo-moar 1811b8: OUTPUT: «["foo", "bar", "baz"]␤»

[12:05] <timotimo> m: dd [<foo bar baz>,]

[12:05] <camelia> rakudo-moar 1811b8: OUTPUT: «[("foo", "bar", "baz"),]␤»

[12:05] <sammers> hmm, ok, so how should I create a List / array of hashes?

[12:06] <timotimo> you can just push each hash into the array for example

[12:06] *** mcmillhj left
[12:06] <timotimo> or create the list with a map or for loop

[12:06] <sammers> m: my @a = [%{ a => 'b', c => 'd'}, %{ e => 'f', g => 'h' }]; my $i = 0; @a.map: -> %h { say $i; say %h.perl; $i++ } 

[12:06] <camelia> rakudo-moar 1811b8: OUTPUT: «0␤{:a("b"), :c("d")}␤1␤{:e("f"), :g("h")}␤»

[12:06] <sammers> so that is a list of hashes, right?

[12:06] <IOninja> sammers: just add a comma if you wrote just one hash

[12:06] <timotimo> yup

[12:06] <sammers> ok, so always append the comma?

[12:06] <timotimo> yup

[12:06] <sammers> ok, thanks

[12:06] <sammers> that clears that up

[12:07] <jnthn> The way I think of it is that we iterate the top-level thing inside of [...]

[12:07] <jnthn> (And anywhere else following this "single arg rule")

[12:07] <jnthn> [%h] # iterates %h itself

[12:07] *** bjz joined
[12:07] <jnthn> [%h,] # iterates the 1-element list containing %h

[12:08] <sammers> ok, that is good to know... thanks.

[12:08] <jnthn> Also worth noting that , is what constructs lists in Perl 6, not parens.

[12:08] <timotimo> why do we have a core.d btw?

[12:08] <timotimo> is that still a thing? or is it just left-overs in my local checkout?

[12:08] <jnthn> timotimo: It's a thing :)

[12:09] <IOninja> timotimo: a thing. v6.d.PREVIEW with nonblocking await and react

[12:09] <sammers> ok, unrelated question, is it possible to call a sub from a string? so instead of passing its name around like &foo, I want to pass it around quoted, "foo", then call it someowhere else.

[12:09] <IOninja> m: use v6.d.PREVIEW; say &await.file

[12:09] <camelia> rakudo-moar 1811b8: OUTPUT: «SETTING::src/core.d/await.pm␤»

[12:09] <sammers> jnthn, thanks, that is very good to know

[12:09] <IOninja> m: ::('&say')('meow'(

[12:09] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> 3::('&say')('meow'(7⏏5<EOL>␤    expecting any of:␤        argument list␤»

[12:09] <timotimo> oh! .d

[12:09] <IOninja> m: ::('&say')('meow')

[12:09] <camelia> rakudo-moar 1811b8: OUTPUT: «meow␤»

[12:09] <IOninja> sammers: ^

[12:09] <timotimo> that's "version d", not "the same thing as /etc/init.d"

[12:10] <jnthn> m: my $sub = "abs"; say &::($sub)(-42)

[12:10] <camelia> rakudo-moar 1811b8: OUTPUT: «42␤»

[12:10] <jnthn> timotimo: haha, never thought of that pun :P

[12:10] * timotimo has an initial draft fix for 4.999999999999999 cmp 5 =:= Same

[12:10] <sammers> IOninja, jnthn: thanks... that is what I was looking for.

[12:11] <jnthn> Lunch time for me :)

[12:11] <jnthn> bbl

[12:11] *** bjz_ joined
[12:14] *** bjz left
[12:15] *** mcmillhj joined
[12:16] <timotimo> m: say 4.999999999999999 cmp 5.0

[12:16] <camelia> rakudo-moar 1811b8: OUTPUT: «Less␤»

[12:16] <timotimo> god damn it

[12:16] <timotimo> my fix was in the wrong place :)

[12:17] <timotimo> s: &infix:<cmp> \(Rat:D, Int:D)

[12:17] <timotimo> s: &infix:<cmp>, \(Rat:D, Int:D)

[12:17] *** wamba1 joined
[12:17] <SourceBaby> timotimo, Something's wrong: ␤ERR: ===SORRY!=== Error while compiling -e␤Unable to parse expression in argument list; couldn't find final ')' ␤at -e:6␤------>     put sourcery( &infix:<cmp><HERE> \(Rat:D, Int:D) )[1];␤    expecting any of:␤        infix␤        infix stopper␤

[12:17] <SourceBaby> timotimo, Sauce is at https://github.com/rakudo/rakudo/blob/1811b80/src/core/Order.pm#L10

[12:17] *** llfourn left
[12:17] <timotimo> oh jesus

[12:18] <timotimo> s: &infix:<cmp>, \(4.99999999999999999, 5)

[12:18] <SourceBaby> timotimo, Sauce is at https://github.com/rakudo/rakudo/blob/1811b80/src/core/Order.pm#L30

[12:18] <timotimo> that scared me for a moment

[12:18] <timotimo> ugh, it goes via .Bridge there

[12:19] <IOninja> but... the current result is right?

[12:19] <ZzZombo> can somebody expand https://docs.perl6.org/routine/val and add it into the search index?

[12:19] *** mcmillhj left
[12:19] <IOninja> Do they get converted to Nums?

[12:20] <timotimo> yup

[12:20] <timotimo> the .Bridge result

[12:20] <IOninja> ahh :(

[12:20] <timotimo> m: say 4.999999999999999 cmp 5

[12:20] <camelia> rakudo-moar 1811b8: OUTPUT: «Less␤»

[12:20] <timotimo> um...

[12:20] <timotimo> m: 4.999999999999999 ~~ 1..^5

[12:20] <camelia> rakudo-moar 1811b8: ( no output )

[12:20] <timotimo> m: say 4.999999999999999 ~~ 1..^5

[12:20] <camelia> rakudo-moar 1811b8: OUTPUT: «True␤»

[12:20] <timotimo> m: say 4.999999999999999 cmp 5

[12:20] <camelia> rakudo-moar 1811b8: OUTPUT: «Less␤»

[12:20] <IOninja> you'd figure there'd be a Rat Int candidate that can compare it correctly

[12:20] <timotimo> ... what?!

[12:21] *** llfourn joined
[12:21] <IOninja> Well, that result is right :)

[12:22] <timotimo> i copypasted the wrong one :)

[12:22] <timotimo> m: 4.9999999999999999 cmp 5

[12:22] <camelia> rakudo-moar 1811b8: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "cmp" in expression "4.9999999999999999 cmp 5" in sink context (line 1)␤»

[12:22] <timotimo> m: say 4.9999999999999999 cmp 5

[12:22] <camelia> rakudo-moar 1811b8: OUTPUT: «Same␤»

[12:22] <timotimo> there we go.

[12:22] <IOninja> m: dd 4.999999999999999.Bridge

[12:22] <camelia> rakudo-moar 1811b8: OUTPUT: «5e0␤»

[12:22] <timotimo> it does work properly with the cmp 5.0 one where both are Rat

[12:23] <timotimo> but how is that possible?

[12:23] <timotimo> because that one just calls .Num on both ends

[12:23] <IOninja> we can add a Rat/Int, Int/Rat candidates

[12:23] <IOninja> and do proper comparison without loss of precision

[12:23] <timotimo> m: given 4.9999999999999999 { say .Bridge; say .Num }

[12:23] <camelia> rakudo-moar 1811b8: OUTPUT: «5␤5␤»

[12:23] <IOninja> I meam Rational, not Rat

[12:25] <IOninja> hell, it'd just be Rational(Int) { callwith... }

[12:25] <IOninja> s: &infix:<cmp>, \(4.99999999999999999, 5.0)

[12:25] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/1811b80/src/core/operators.pm#L50

[12:26] <IOninja> :S

[12:26] * IOninja expected more....

[12:26] <timotimo> oh, hold on

[12:27] <timotimo> i was also comparing things with my local patch

[12:27] <ZzZombo> why does https://docs.perl6.org/routine/Numeric actually refer to Numeric.log?

[12:27] <timotimo> haha, that's funny

[12:27] <timotimo> (also: wrong)

[12:27] <ZzZombo> dis not :( I wanna see it

[12:28] <timotimo> it's not supposed to be a routine at all

[12:28] <timotimo> https://docs.perl6.org/type/Numeric

[12:28] <timotimo> you want dis

[12:28] <ZzZombo> well, I want RatStr.Numeric, I guess.

[12:30] <ZzZombo> huh

[12:30] <ZzZombo> https://docs.perl6.org/routine/Str

[12:30] <ZzZombo> same story

[12:30] <IOninja> ZzZomvo, it just returns it as a number, the Ray

[12:30] <IOninja> ZzZomvo, it just returns it as a number, the Rat

[12:30] <timotimo> could be every single method of Str is competing to become routine/Classname

[12:30] <timotimo> routine/Str i mean

[12:30] <ZzZombo> there must be a fundamental error in the docs

[12:30] <IOninja> s: &infix:<<<=>>>, \(4.99999999999999999, 5.0)

[12:30] <SourceBaby> IOninja, Something's wrong: ␤ERR: ===SORRY!=== Error while compiling -e␤Preceding context expects a term, but found infix , instead␤at -e:6␤------>     put sourcery( &infix:<<<=>>>,<HERE> \(4.99999999999999999, 5.0) )[1];␤

[12:31] <IOninja> can someone type that with proper fancy quotes?

[12:31] <ZzZombo> what is :$val-or-fail in val?

[12:31] <timotimo> sure

[12:31] <timotimo> s: &infix:['<<=>>'], \(4.99999999999999999, 5.0)

[12:31] <SourceBaby> timotimo, Something's wrong: ␤ERR: ===SORRY!=== Error while compiling -e␤Missing << or >>␤at -e:1␤------> <<=><HERE>>␤    expecting any of:␤        infix␤        infix stopper␤

[12:31] <timotimo> :o

[12:31] <IOninja> ZzZombo: it'll explode for non-numbers

[12:31] <timotimo> s: &infix:«<=>», \(4.99999999999999999, 5.0)

[12:31] <timotimo> that's the one you mean i presume

[12:31] <IOninja> timotimo, I wanna look at <=>

[12:31] <IOninja> yey

[12:31] <IOninja> Thanks

[12:31] <SourceBaby> timotimo, Sauce is at https://github.com/rakudo/rakudo/blob/1811b80/src/core/Rat.pm#L289

[12:31] <timotimo> wow, that took a while, didn't it?

[12:32] <timotimo> s: &infix:['<=>'], \(4.99999999999999999, 5.0)

[12:32] <SourceBaby> timotimo, Sauce is at https://github.com/rakudo/rakudo/blob/1811b80/src/core/Rat.pm#L289

[12:32] <timotimo> so ... how come the ['<<=>>'] one is exploding? :o

[12:32] <IOninja> what sort of op is that?

[12:32] <timotimo> it's not an op

[12:32] <timotimo> but how does it explode inside the ' ' quotes?

[12:33] <IOninja> Well, Rational cmp Rational should be using <=> not call cmp on .Nums

[12:33] *** pyrimidine joined
[12:33] <timotimo> oh, is it that easy?

[12:33] <IOninja> I'd think so

[12:33] <timotimo> cool

[12:33] <timotimo> patch away! ;)

[12:34] <IOninja> and add Rational/Rational(Int) and Rational(Int) Rational candidates, so we use proper precision in those cases too

[12:34] <IOninja> Will do in 3.5 hours :)

[12:34] <ZzZombo> why can't you do my Int(Str) $x?

[12:34] <timotimo> nice

[12:35] <timotimo> coercive types (currently) only work as parameters

[12:35] <timotimo> because then we have a single spot where we can/should code-gen the coercion

[12:44] *** mcmillhj joined
[12:45] <IOninja> I meant Rat(Int); there ain't no .Rational method

[12:47] *** sena_kun joined
[12:48] *** aborazmeh joined
[12:48] *** aborazmeh left
[12:48] *** aborazmeh joined
[12:49] *** mcmillhj left
[12:49] <ZzZombo> hey, can I in my actions class don't distinguish different branches of a protorule:

[12:49] <ZzZombo> proto token directive {*}

[12:49] <ZzZombo> 	token directive:sym<include> { 'include' <.hws> <value> }

[12:49] <ZzZombo> 	token directive:sym<base> { 'base' <.hws> <value> }

[12:49] <ZzZombo> and simply use one method for all that simply stores them in an array instead of doing something as a more complete class would do?

[12:50] <timotimo> it uses only one method, yeah

[12:50] *** CIAvash left
[12:50] <timotimo> wait

[12:50] <timotimo> i'm confusing things right now, aren't i?

[12:50] <jnthn> Yeah, it'd call two separate methods there

[12:51] <jnthn> I'd perhaps factor it differently

[12:51] *** shlomif joined
[12:51] <arnsholt> Yeah, either you'll have to have two action methods, or merge the two rules into "token directive { [include | base] <.hws> <value> }"

[12:51] <jnthn> token directive { <directive-name> <.hws> <value> }

[12:52] <jnthn> token directive-name { < include base > }

[12:52] <jnthn> Or so

[12:52] <arnsholt> Yeah, I like that last one

[12:52] *** rindolf left
[12:52] *** shlomif is now known as rindolf

[12:53] <jnthn> fwiw, the main reason I'd tend to pick protoregexes over an alternation is because I want different action methods.

[12:53] <arnsholt> Then directive-name's AST can be the class to use for the directive AST node, and directive can instantiate it a la "$<directive-name>.ast.new(value => $<value>.ast)"

[12:53] <jnthn> That or because I want tthe set to be extensible in a subclass

[12:53] <ZzZombo> but then each class that would actually handle includes and other directives would have to do branching itself, and in more complex cases there could be a fair number more of them to handle.

[12:54] <jnthn> An, then proto token directive-name { * } and then token directive-name:sym<include> { <sym> } etc. might do it

[12:55] <timotimo> watching an strace of the CounterMutexSingleton with --num_threads=90000 is amusing

[12:55] <ZzZombo> An?

[12:55] <timotimo> oh, ww

[12:55] <arnsholt> s/Ah/An/ # I think

[12:55] <jnthn> Ah, yes :-)

[12:55] <arnsholt> Or rather, the inverse >.<

[12:55] <arnsholt> Muphry's law strikes again

[12:56] <jnthn> :-)

[12:57] *** aborazmeh left
[12:59] <ZzZombo> jnthn: but that's basically that I have right now. Hey, can I at least make something like:

[12:59] <ZzZombo> method directive($/) { $!directives.push($<directive>.made)}

[12:59] <ZzZombo> method directive:sym<include>=directive;

[12:59] <ZzZombo> method directive:sym<base>=directive;

[12:59] *** risou_awy is now known as risou

[13:01] <jnthn> Well, can just factor it out: Well, method !directive($/) { ... }; method directive:sym<include>($/) { self!directive($/) }

[13:01] <jnthn> s:2nd/Well,//

[13:02] <jnthn> Or do a meta-programming thing

[13:03] <jnthn> BEGIN { for <include base> { ::?CLASS.^add_method("directive:sym<$_>", method ($/) { ... }) } } inside of the class

[13:05] <IOninja> Is BEGIN required? I figured the body runs at compile time...

[13:05] <ZzZombo> in Perl5 that would be just

[13:05] <ZzZombo> ...

[13:05] <ZzZombo> our &x=&method

[13:05] <ZzZombo> isn't there something like that?

[13:06] <IOninja> Perl 5 ain't got methods :)

[13:06] <IOninja> You can assign callables the same way tho

[13:07] <IOninja> m: my &x = Str.^lookup: 'say'; x 'meows'

[13:07] <camelia> rakudo-moar 1811b8: OUTPUT: «meows␤»

[13:07] <Ven> .ask zoffix https://twitter.com/zoffix/status/834074966274482177 why `(my \n = $++)` vs `(state $n)++`?

[13:07] <yoleaux> Ven: I'll pass your message to zoffix.

[13:07] <jnthn> IOninja: Yes, it's required; in Perl 6 classes are constructed at BEGIN time

[13:08] <jnthn> IOninja: If you do otherwise then you'll end up with a module that won't precomp well

[13:08] <IOninja> Ven: was trying different things with $ at first and at the end didn't think of changing it to state

[13:08] <IOninja> jnthn: thanks.

[13:08] <ZzZombo> m: class A { method x { say 'X\'d' } our &y=&x };A.new.y

[13:08] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Bogus statement␤at <tmp>:1␤------> 3class A { method x { say 'X\'d' } o7⏏5ur &y=&x };A.new.y␤    expecting any of:␤        whitespace␤»

[13:09] <ZzZombo> m: class A { method x { say 'X\'d' }; our &y=&x };A.new.y

[13:09] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    x used at line 1␤␤»

[13:09] <IOninja> ZzZombo: mhm, that won't work. You've just added a sub, not a method.

[13:09] *** hartenfels left
[13:09] <IOninja> It works in perl 5 because methods are just subs

[13:09] <jnthn> Methods are added (only) via .^add_method

[13:09] <jnthn> And live in the meta-object

[13:09] <jnthn> Not in the package

[13:09] <jnthn> Packages are orthoganol to method dispatch in Perl 6.

[13:10] <timotimo> welllllll, you can also add methods by wrapping .^find_method :P

[13:10] <arnsholt> Yeah. Perl 6 objects and Perl 5 objects are very different

[13:11] *** ChoHag left
[13:13] *** agentzh joined
[13:13] *** Hor|zon joined
[13:14] *** Hor|zon_ joined
[13:15] *** bjz joined
[13:16] *** bjz_ left
[13:16] *** risou is now known as risou_awy

[13:16] <ZzZombo> wat

[13:16] <ZzZombo> m: class A { method x { say 'X\'d' }};BEGIN A.^add_method('y',&A.x);A.new.y

[13:16] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Illegally post-declared type:␤    A used at line 1␤␤»

[13:17] <IOninja> ZzZombo: use ::?CLASS instead of A

[13:17] <IOninja> And &A.x isn't what you think it is.

[13:17] <ZzZombo> <camelia> rakudo-moar 1811b8: OUTPUT: «===SORRY!=== Error while compiling <tmp>␤No such symbol '::?CLASS'␤

[13:17] <sena_kun> hi folks.

[13:18] *** agentzh left
[13:18] <moritz> hi sena_kun 

[13:18] <moritz> you likely want a.^add_method('alias', A.^find_method('old_name'))

[13:18] <moritz> (to ZzZombo)

[13:19] <IOninja> ZzZombo: you've messed up closing brace

[13:19] <jnthn> And put the BEGIN inside of the class body

[13:19] <IOninja> m: class A { method x { say 'X\'d' }; BEGIN ::?CLASS.^add_method('y', ::?CLASS.^lookup: 'x') }; A.new.y

[13:19] <camelia> rakudo-moar 1811b8: OUTPUT: «X'd␤»

[13:19] *** aborazmeh joined
[13:19] *** aborazmeh left
[13:19] *** aborazmeh joined
[13:20] <IOninja> m: class A { method x { say 'X\'d' }; BEGIN A.^add_method('y', A.^lookup: 'x') }; A.new.y

[13:20] <camelia> rakudo-moar 1811b8: OUTPUT: «X'd␤»

[13:20] <IOninja> Well, and A works too, but ::?CLASS is bettah

[13:20] <ZzZombo> m: class A { method x { say 'X\'d' }; BEGIN {my $x=::?CLASS.^lookup: 'x';::?CLASS.^add_method('y', $x) }; A.new.y

[13:20] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3::?CLASS.^add_method('y', $x) }; A.new.y7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»

[13:21] <ZzZombo> m: class A { method x { say 'X\'d' }; BEGIN {my $x=::?CLASS.^lookup: 'x';::?CLASS.^add_method('y', $x) }}; A.new.y

[13:21] <camelia> rakudo-moar 1811b8: OUTPUT: «X'd␤»

[13:21] <sena_kun> today I have a stupid question that was answered here many times for sure, but I didn't note the answer, unfortunately. I'm trying to write a test for roast. I have roast repo. I'm trying to test my changes with: "./fudgeandrun path-to-test.t". But I got an error about Test::Util instead, that is inside of packages/Test/Util.pm. What is the correct way to run a single test file?

[13:21] <ZzZombo> but why does &A.x does't work?

[13:22] <ZzZombo> not*

[13:22] <jnthn> &A means "the subroutine A", .x is calling a method on it

[13:22] <IOninja> sena_kun: you run it from rakudo's repo where it's located in t/spec

[13:22] <sena_kun> IOninja, argh. why.

[13:23] <IOninja> sena_kun: I guess because 99.99999% of the time the tests are run by rakudo devs, not by someone just checking out the roast repo.

[13:23] <ZzZombo> so what is the right way?

[13:23] <moritz> sena_kun: because the test suite needs to make assumptions about paths

[13:23] <IOninja> sena_kun: it should be possible to make the tests invocation-location-agnostic, but hasn't been done.

[13:23] <IOninja> huggable: FindBin

[13:24] <huggable> IOninja, use lib $*PROGRAM.parent.parent.child("lib").Str; # finds lib/ for scripts in bin/ or t/

[13:24] <moritz> and even if possible, I'm not sure that's a good idea

[13:24] <IOninja> moritz: how come?

[13:24] <IOninja> other than it being more work

[13:24] <moritz> because then we require new implementations to implement a whole lot of extra stuff before they can start running those tests

[13:24] <sena_kun> Um, okay. Thanks for the explanation, now I'll remember it better.

[13:24] <IOninja> Ah. Fair enough.

[13:26] <moritz> I'd be surprised if the FindBin trick would work with a two-year old rakudo

[13:26] <IOninja> sena_kun: you may wanna point that out to mr_ron (I think). They've been working on moving fudgeandrun to roast. Probably possible to make fudgeandrun change the dir to make all the paths work out as if they were run from a ../../

[13:26] <IOninja> or something or other.

[13:27] <IOninja> .seen mr_ron

[13:27] <yoleaux> I saw mr_ron 31 Jan 2017 22:47Z in #perl6: <mr_ron> Warning on mixed | and || and related documentation needs https://github.com/perl6/doc/issues/1141

[13:27] <IOninja> Yeah, that's the right nick.

[13:28] <[Coke]> .seen IOninja 

[13:28] <yoleaux> 02:48Z <IOninja> [Coke]: how detailed should the grant report be? Is this more to ensure I'm doing *something* or do people want to know all the details of what I did? In these three verbosity options, which is most preferred? https://gist.github.com/zoffixznet/90cb2497ff35893020d07bc5e7b40b89

[13:28] <yoleaux> I saw IOninja 13:27Z in #perl6: <IOninja> Yeah, that's the right nick.

[13:28] <sena_kun> IOninja, I just thought that he worked exactly on this type of issues and assumed it was solved.

[13:28] <IOninja> ZzZombo: the right way is what your last eval with .^lookup; there are several other ways to find the method too, like .^find_method and .^can

[13:28] <[Coke]> gfldex: pretty sure it was an nqp level error with no backtrace.

[13:29] *** mcmillhj joined
[13:29] <IOninja> sena_kun: in your case adding PERL6LIB=packages/ likely will make it work

[13:29] <IOninja> But roast as a whole makes other assumtions about locations of axuliary files, I believe

[13:32] *** lukiramu joined
[13:33] * IOninja &

[13:33] *** ChoHag joined
[13:34] *** mcmillhj left
[13:35] <moritz> last I looked, the fact that roast made assumptions about such paths was also documented in roast's README

[13:35] <sena_kun> with "PERL6LIB=packages/ ./fudgeandrun file" it doesn't work either. Anyway, I'll just use "make spectest" from rakudo repo root, I guess.

[13:35] <moritz> which, of course, noody bothers to read.

[13:35] <IOninja> sena_kun: don't; it takes ages to run. Use t/fudgeandrun from rakudo repo

[13:35] *** lukaramu left
[13:35] <IOninja> t/fudgeandrun t/spec/blah/blah.t

[13:35] <moritz> or make t/sepc/path/to/file

[13:36] <sena_kun> Ah, it was in t folder. Thanks!

[13:37] <[Coke]> IOninja: I've seen all three levels of detail; If you can give the detail in [1], I for one would appreciate it.

[13:37] <IOninja> [Coke]: will do.

[13:57] *** mcmillhj joined
[13:57] *** hartenfels joined
[14:03] *** bjz left
[14:04] *** aborazmeh left
[14:09] <ZzZombo> what the hell, Perl:

[14:09] <ZzZombo> method walk(Grammar::VDF::Section:D :$start=$.root,Callable:D &section_code={;},Callable:D &kv_code={;})

[14:09] <ZzZombo> Cannot put optional positional parameter &section_code after variadic parameters

[14:10] <Geth> ¦ doc: bf93d3d9be | Cale++ | doc/Language/haskell-to-p6.pod6

[14:10] <Geth> ¦ doc: add gather/take examples

[14:10] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/bf93d3d9be

[14:11] *** itaipu joined
[14:11] <ZzZombo> "Long Names

[14:11] <ZzZombo> To exclude certain parameters from being considered in multiple dispatch, separate them with a double semi-colon."

[14:11] <ZzZombo> w-what?

[14:12] <moritz> multi f($x ;; $y) { ... }

[14:12] <moritz> only $x's type is considered in multi dispatch

[14:12] <ZzZombo> but... why "Long Names"??

[14:13] <moritz> the signature is part of the long name of a candidate

[14:14] *** committable6 left
[14:20] <ZzZombo> so why :$start is considered variadic? I've refreshed my knowledge of variadic arguments, it certainly isn't declared like *%slurp.

[14:21] <moritz> named args are optional by default

[14:21] *** skids joined
[14:22] <ZzZombo> so?.. named and positional are completely indepedent as far as the ordering (w/o referring to previous arguments) is concerned, aren't they?

[14:23] <moritz> they are

[14:23] <moritz> but doesn't a variable number of named args still makes a routine varidadic?

[14:24] <IOninja> Then why does it matter if you put them before positionals in a signature?

[14:24] <ZzZombo> but there is NO variance

[14:26] <moritz> ZzZombo: there isn't?

[14:26] <moritz> ZzZombo: a named being present or not is variance

[14:26] <moritz> IOninja: I think it's one of the places where Perl 6 tries to be prescriptive

[14:26] <ZzZombo> eh? it has got a default value, so in my book it means it's present all the tme

[14:26] *** committable6 joined
[14:26] *** ChanServ sets mode: +v committable6

[14:27] <ZzZombo> now if Perl does have a strange view of things...

[14:27] <moritz> the *argument* isn't present allt he time

[14:27] <moritz> the *paramater* always has a value, sure

[14:27] <IOninja> m: sub (:$x!, $y) {}

[14:27] <camelia> rakudo-moar 1811b8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot put required parameter $y after variadic parameters␤at <tmp>:1␤------> 3sub (:$x!, $y7⏏5) {}␤    expecting any of:␤        constraint␤»

[14:27] <moritz> but variadic (in my understanding) means variable number of *arguments*

[14:28] <moritz> IOninja: that's LTA

[14:28] <IOninja> this feels more like a bug in the code that looks for variadic positionals

[14:28] <IOninja> rather than prescriptive 

[14:28] <IOninja> ¯\_(ツ)_/¯

[14:28] <moritz> I dimly recall another rule requiring positional before named, but my memory on that is fuzzy

[14:29] <IOninja> but it's been that way since before 2014.01

[14:31] <sena_kun> https://github.com/perl6/roast/pull/244 closes https://rt.perl.org/Public/Bug/Display.html?id=130712.

[14:31] <ZzZombo> wait, how do I make a routine accept anything Callable? I get mysterious errors like "Type check failed in binding to &section_code; expected Callable[Callable] but got Block (-> ;; $_? is raw { #`...)".

[14:33] <moritz> &code

[14:33] <moritz> in the signature

[14:33] *** sammers left
[14:35] *** ChoHag left
[14:35] <IOninja> Callable $foo also works.

[14:36] <IOninja> m: -> Callable & {}(&say)

[14:36] <camelia> rakudo-moar 1811b8: OUTPUT: «Type check failed in binding to <anon>; expected Callable[Callable] but got Sub (sub say (| is raw) { ...)␤  in block <unit> at <tmp> line 1␤␤»

[14:36] <IOninja> You doubled up the Callable...

[14:36] <arnsholt> And Callable $foo is equivalent to &foo, no?

[14:37] <IOninja> m: say :(Callable $foo) eqv :(&foo)

[14:37] <camelia> rakudo-moar 1811b8: OUTPUT: «False␤»

[14:37] <IOninja> I think so...

[14:37] <arnsholt> Failing due to &foo and $foo, possibly

[14:37] <arnsholt> ?

[14:37] <IOninja> I think so.

[14:39] <IOninja> m: say :(Callable $foo) ~~ :(&foo)

[14:39] <camelia> rakudo-moar 1811b8: OUTPUT: «True␤»

[14:41] <IOninja> There's also this bug; dunno if such not-really-Callable-callables are produced in user code tho: https://rt.perl.org/Ticket/Display.html?id=128905#ticket-history

[14:41] *** itaipu left
[14:42] *** ChoHag joined
[14:44] *** lichtkind_ joined
[14:46] *** sammers joined
[14:47] *** lichtkind__ left
[14:50] *** itaipu joined
[14:52] *** yadzi left
[14:58] <IOninja> m: %*ENV<RAKUDO_EXCEPTIONS_HANDLER>='Meows'; class Exceptions::Meows { method process ($e) {say "daum, boy; yer code's broke as 'ell"; 0}}; EVAL 'sub () is return 42 {}'

[14:58] <camelia> rakudo-moar 1811b8: OUTPUT: «daum, boy; yer code's broke as 'ell␤»

[14:59] <IOninja> (re testing for text of error in roast) Even with rakudo you can alter error output.

[14:59] *** curan left
[15:00] <IOninja> There's prolly plenty of tests that do test, but it just feels wrong to have those on the same level as all the other tests.

[15:00] *** risou_awy is now known as risou

[15:01] <IOninja> and we can always move them from rakudo to roast; going the other way is much harder.

[15:02] <sena_kun> IOninja, athemerge was a bit faster than I though, since I didn't change X::AdHoc to Exception yet. :)

[15:02] <sena_kun> *the merge

[15:03] <IOninja> sena_kun: it's fine there, I think. If we do add a more detailed exception, we can just change the test to test for it. In roast, we can't just change tests willi-nilly

[15:03] <sena_kun> IOninja, well then.

[15:04] *** wamba1 left
[15:04] *** ChoHag left
[15:06] *** wamba1 joined
[15:09] *** llfourn left
[15:10] *** salv0 left
[15:11] *** gregf_ left
[15:11] *** pmurias joined
[15:12] <pmurias> SmokeMachine: it would make sense to have our module installer install Perl 5 (and other language) models if they are dependencies of Perl 6 modules

[15:17] *** risou is now known as risou_awy

[15:21] *** ChoHag joined
[15:21] *** gregf_ joined
[15:22] *** wamba1 left
[15:22] <[Coke]> pmurias: There are many ways to install p5 modules, we shouldn't get involved.

[15:27] *** bwisti joined
[15:32] *** rurban left
[15:34] <moritz> also, what if we depend on python modules through Inline::Python?

[15:34] <moritz> or any other language, through another Inline:: module?

[15:34] *** pyrimidine left
[15:34] *** pyrimidine joined
[15:35] *** hartenfels left
[15:40] *** pyrimidine left
[15:42] <IOninja> we could get involved on `zef`'s level. e.g.: it'd offer a plugin and user can set it to run  `cpanm -vn Module::Name` for any Perl 5 deps.

[15:42] <IOninja> Someone would set it up to do something else.

[15:43] <IOninja> Make it automatically install all the deps instead of my having to do all that stuff myself. Seems useful.

[15:44] <[Coke]> -1 from me.

[15:45] <IOninja> ¯\_(ツ)_/¯ don't use the plugin.

[15:45] <IOninja> Seems entirely a user-space choice.

[15:45] <perigrin> where do you draw the line? 

[15:45] <IOninja> We don't. We don't have control over it.

[15:45] <IOninja> I could churn out an installer that looks for `depends-apt-get` key in META file and runs `sudo apt-get get blah blah` on that.

[15:46] <perigrin> What about c-level deps?

[15:46] <IOninja> See above.

[15:46] <perigrin> So ... unless the author thought to put depends-pacman people on arch can't do anything?

[15:47] <IOninja> They'd have to install manually, just like now, yes.

[15:47] <IOninja> Or I could churn out an installer that figures that stuff out for arch

[15:47] <IOninja> Don't even need to churn out an installer.... zef is pluggable; 'd just write a plugin that does that

[15:51] <ZzZombo> m: say $_ for () orelse say 'LUL';

[15:51] <camelia> rakudo-moar c550dd: ( no output )

[15:51] <ZzZombo> m: say $_ orelse say 'LUL' for ();

[15:51] <camelia> rakudo-moar c550dd: ( no output )

[15:51] <IOninja> say returns True

[15:51] <ZzZombo> :(

[15:52] <IOninja> um

[15:52] <IOninja> m: dd (say $_ for ())

[15:52] <camelia> rakudo-moar c550dd: OUTPUT: «()␤»

[15:52] *** pyrimidine joined
[15:52] <IOninja> m: dd (say $_ for ()).defined

[15:52] <camelia> rakudo-moar c550dd: OUTPUT: «Bool::True␤»

[15:52] <IOninja> the thing returns an empty list which is defined, I think is more correct here :)

[15:52] <IOninja> m: say $_ for () or say 'LUL';

[15:52] <camelia> rakudo-moar c550dd: OUTPUT: «LUL␤True␤»

[15:53] <gfldex> m: my &nay = &say but False; dd so &nay

[15:53] <camelia> rakudo-moar c550dd: OUTPUT: «Bool $val = Bool::False␤»

[15:53] <IOninja> ohh that's how it does it. weird

[15:54] <ZzZombo> m: say $_ for (1) or say 'LUL';

[15:54] <camelia> rakudo-moar c550dd: OUTPUT: «1␤»

[15:54] <IOninja> I don't follow it actually. `or` and `orelse` end up parsed differenly? The `or` gives the result to `say` but `orelse` thunks it or something?

[15:55] <IOninja> m: say $_ for () andthen say 'LUL';

[15:55] <camelia> rakudo-moar c550dd: OUTPUT: «LUL␤True␤»

[15:55] <IOninja> ...

[15:55] <IOninja> m: say Empty

[15:55] <camelia> rakudo-moar c550dd: OUTPUT: «()␤»

[15:55] <IOninja> don't get it

[15:56] <IOninja> m: (say $_) for () or say 'LUL';

[15:56] <camelia> rakudo-moar c550dd: OUTPUT: «LUL␤True␤»

[15:56] <IOninja> m: (say $_) for () orelse say 'LUL';

[15:56] <camelia> rakudo-moar c550dd: ( no output )

[15:56] <IOninja> oh

[15:56] *** llfourn joined
[15:56] <IOninja> m: (say $_) for (() orelse say 'LUL');

[15:56] <camelia> rakudo-moar c550dd: ( no output )

[15:56] <IOninja> m: (say $_) for (() or say 'LUL');

[15:56] <camelia> rakudo-moar c550dd: OUTPUT: «LUL␤True␤»

[15:56] <IOninja> That's how it parses.

[15:57] <IOninja> I get it \o/

[15:57] <IOninja> m: ().defined.say

[15:57] <camelia> rakudo-moar c550dd: OUTPUT: «True␤»

[15:57] <IOninja> m: () orelse say 'wat'

[15:57] <camelia> rakudo-moar c550dd: ( no output )

[15:57] <IOninja> m: ().self orelse say 'wat'

[15:57] <camelia> rakudo-moar c550dd: ( no output )

[15:57] <IOninja> what gives?

[15:58] <IOninja> oh nevermind

[15:58] <IOninja> bah

[15:58] <IOninja> Hacking time \o/

[15:58] *** risou_awy is now known as risou

[15:59] *** wamba joined
[16:00] *** ChoHag left
[16:01] *** llfourn left
[16:01] *** pyrimidine left
[16:02] *** ChoHag joined
[16:05] <ZzZombo> m: say $_ for (1) or say 'LUL';

[16:05] <camelia> rakudo-moar c550dd: OUTPUT: «1␤»

[16:05] <ZzZombo> why the hell

[16:05] <ZzZombo> (say "$indent\t$_.name()\t=>\t$_.value()" for ($section.keys.all-values)) or say '<none>';

[16:05] <ZzZombo> then doesn't work, complaining I used up Seq?

[16:05] <ZzZombo> ugh

[16:05] <ZzZombo> I meant

[16:05] <ZzZombo> say "$indent\t$_.name()\t=>\t$_.value()" for ($section.keys.all-values) or say '<none>';

[16:05] <ZzZombo> with the braces it works.

[16:06] *** wamba left
[16:07] <IOninja> .cache it?

[16:07] *** wamba joined
[16:08] <ZzZombo> that's not the point, it's that after embracing the expression it works again.

[16:08] <IOninja> No idea what you mean by embracing

[16:09] <IOninja> Any idea what this is for? https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L7061-L7064

[16:09] <ZzZombo> uh

[16:09] <ZzZombo> <ZzZombo> with the braces it works.

[16:09] <IOninja> notanthen is missing from the list but I don't know what it does.

[16:09] <ZzZombo> literally said it above

[16:09] <IOninja> ZzZombo: saw it; don't know what you mean.

[16:09] <ZzZombo> (say "$indent\t$_.name()\t=>\t$_.value()" for ($section.keys.all-values)) or say '<none>';

[16:10] <ZzZombo> vs

[16:10] <ZzZombo> say "$indent\t$_.name()\t=>\t$_.value()" for ($section.keys.all-values) or say '<none>';

[16:10] <IOninja> ...those are parentheses :/

[16:10] <perlpilot> round brackets  ;)

[16:11] <IOninja> and yeah, makes sense. In the first case you're consuming the seq to find out if it's true or not and then consuming it second time to iterate over it; in the second case you only iterate over it and use the result of `for` in the conditional

[16:11] <moritz> without the parenthesis, EXPR for A or B evaluates A twice

[16:11] <moritz> once for the "or" and once for the "for"

[16:11] <moritz> and you can't consume a Seq twice

[16:11] <ZzZombo> well then, makes sense.

[16:11] <ZzZombo> thanks

[16:12] *** ggoebel left
[16:12] <IOninja> s: &METAOP_TEST_ASSIGN

[16:12] <IOninja> s: &METAOP_ASSIGN

[16:13] <SourceBaby> IOninja, Something's wrong: ␤ERR: ===SORRY!=== Error while compiling -e␤Undeclared name:␤    METAOP_TEST_ASSIGN used at line 6␤␤

[16:13] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/c550dd7/src/core/metaops.pm#L2

[16:13] <IOninja> huh

[16:14] <IOninja> s: &METAOP_TEST_ASSIGN:<andthen>

[16:14] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/c550dd7/src/core/metaops.pm#L9

[16:15] <IOninja> What's this stuff's for?

[16:15] <IOninja> Like what's with these special cases for all these ops? (and I see <or> and <and> are missing :/)

[16:16] <IOninja> oh

[16:16] <IOninja> m: my $x = 42; $x andthen= 72; say $x

[16:16] <camelia> rakudo-moar c550dd: OUTPUT: «72␤»

[16:16] <IOninja> m: my $x = 42; $x and= 72; say $x

[16:16] <camelia> rakudo-moar c550dd: OUTPUT: «72␤»

[16:17] <IOninja> mhm, that's the METAOP_TEST_ASSIGN stuff

[16:17] <IOninja> .... now I wonder if the missing <or> and <and> is an error :|

[16:18] *** parisba left
[16:18] * IOninja moves this soliloquy to #perl6-dev

[16:19] *** committable6 left
[16:19] <IOninja> but the answer is yes :D

[16:19] <IOninja> What's up with commitable? Something's making it stall.

[16:20] *** parisba joined
[16:21] *** ChoHag left
[16:21] *** committable6 joined
[16:21] *** ChanServ sets mode: +v committable6

[16:22] *** committable6 left
[16:22] *** committable6 joined
[16:22] *** ChanServ sets mode: +v committable6

[16:30] <[Coke]> so, this code is failing in examples-compilation (but only when running all the tests. running just the one file, it works fine)

[16:30] <[Coke]> class IO::Socket::INET does IO::Socket {}

[16:30] <[Coke]> dies with:

[16:30] <[Coke]> No appropriate parametric role variant available for '<anon|140234519215376>::IO::Socket'

[16:30] <[Coke]> m: class IO::Socket::INET does IO::Socket {}

[16:30] <camelia> rakudo-moar c550dd: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤IO::Socket is not composable, so IO::Socket::INET cannot compose it␤at <tmp>:1␤»

[16:31] <[Coke]> m: if False { class:: { class IO::Socket::INET does IO::Socket {} }}

[16:31] <camelia> rakudo-moar c550dd: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤IO::Socket is not composable, so IO::Socket::INET cannot compose it␤at <tmp>:1␤»

[16:31] <SmokeMachine> pmurias: as Inline::* for example? do you think that install Inline::Python, for example, should install python?

[16:31] <IOninja> m: class IO::Socket {}; class IO::Socket::INET does IO::Socket {} 

[16:31] <camelia> rakudo-moar c550dd: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of symbol 'IO::Socket::INET'␤at <tmp>:1␤------> 3; class IO::Socket::INET does IO::Socket7⏏5 {}␤»

[16:32] <IOninja> weird eh?

[16:32] <IOninja> m: role IO::Socket {}; class IO::Socket::INET does IO::Socket {} 

[16:32] <camelia> rakudo-moar c550dd: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of symbol 'IO::Socket::INET'␤at <tmp>:1␤------> 3; class IO::Socket::INET does IO::Socket7⏏5 {}␤»

[16:32] *** cale2 joined
[16:35] <cale2> not sure what the ideal oauth1 implementation would be. in an effort to keep it as simple as possible, this is what I dreamed up in the readme https://github.com/WildYorkies/perl6-oauth1/blob/master/README.md

[16:35] *** pyrimidine joined
[16:35] *** kurahaupo joined
[16:35] <cale2> make an unsigned request, then sign it (which adds the authorization header), then send it off

[16:36] <[Coke]> IOninja: I think I'll skip it for now. unskipping skipped tests can be a project at some point.

[16:38] <Geth> ¦ doc: 7ac8ab13f9 | (Will "Coke" Coleda)++ | doc/Language/grammars.pod6

[16:38] <Geth> ¦ doc: remove trailing whitespace

[16:38] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/7ac8ab13f9

[16:38] <Geth> ¦ doc: 4576bd8474 | (Will "Coke" Coleda)++ | doc/Language/haskell-to-p6.pod6

[16:38] <Geth> ¦ doc: remove trailing whitespace

[16:38] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/4576bd8474

[16:38] <Geth> ¦ doc: 00d98337d5 | (Will "Coke" Coleda)++ | doc/Type/IO/Socket/INET.pod6

[16:38] <Geth> ¦ doc: Don't test this signature

[16:38] <Geth> ¦ doc: 

[16:38] <Geth> ¦ doc: Fails xt/examples-compilation.t (when running all files, but not

[16:38] <Geth> ¦ doc: when run for the one pod file its in)

[16:38] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/00d98337d5

[16:40] *** ggoebel joined
[16:46] *** kurahaupo left
[16:53] *** mcmillhj left
[16:54] *** abraxxa left
[16:57] *** llfourn joined
[16:59] *** itaipu left
[17:02] *** llfourn left
[17:03] *** Qwerasd joined
[17:06] *** AlexDaniel joined
[17:08] *** ChoHag joined
[17:08] <IOninja> m: say 42 xor 5

[17:08] <camelia> rakudo-moar e0a9cf: OUTPUT: «42␤»

[17:08] <IOninja> don't seem to be documented

[17:09] <IOninja> It doesn't thunk anything, right? `$x xor say "hi"` will always say hi?

[17:09] <IOninja> s: &infix:<xor>

[17:09] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/c550dd7/src/core/Bool.pm#L142

[17:09] <b2gills> .tell Ven I'll tell you the same thing I'm sure I told Hotkeys, if you want me to delay answering Code Golfs I will

[17:09] <yoleaux> b2gills: I'll pass your message to Ven.

[17:10] *** zakharyas left
[17:10] <IOninja> ah

[17:11] <IOninja> wait..

[17:11] <IOninja> m: say (42 xor 5)

[17:11] <camelia> rakudo-moar e0a9cf: OUTPUT: «Nil␤»

[17:11] <IOninja> m: say (42 xor say "hi")

[17:11] <camelia> rakudo-moar e0a9cf: OUTPUT: «hi␤Nil␤»

[17:11] <IOninja> yeah, guess it'll always say hi when just two args are given

[17:12] <b2gills> say (42 xor 5 xor say 'hi')

[17:12] <b2gills> m: say (42 xor 5 xor say 'hi')

[17:12] <camelia> rakudo-moar e0a9cf: OUTPUT: «Nil␤»

[17:12] <IOninja> I was asking 'cause I see `xor=` form isn't made to thunk

[17:12] <IOninja> And I guess in that form you can only give two args?

[17:13] <IOninja> m: my $x; $x xor= say "hi"; # supposed to always say hi, right?

[17:13] <camelia> rakudo-moar e0a9cf: OUTPUT: «hi␤»

[17:13] <b2gills> I can't think of a way it could get more than 2 args without creating your own QAST nodes

[17:13] <IOninja> cool

[17:14] <AlexDaniel> xor :O

[17:15] *** risou is now known as risou_awy

[17:15] <IOninja> AlexDaniel: something's wrong with commitable. Pinged out twice today, though the process was still running. Rest of the gang was fine.

[17:15] <IOninja> I mean... while no one (I think?) was using it.

[17:16] *** committable6 left
[17:16] <AlexDaniel> hmmmmm

[17:17] <b2gills> m: sub infix:<Zxor> (\l is rw,\r){ my \r= [xor] l,|r;r??r!!l}; $_ = 5; $_ Zxor= 0,0,0; .say

[17:17] <camelia> rakudo-moar e0a9cf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Can only use 'is rw' on a scalar ('$' sigil) parameter␤at <tmp>:1␤»

[17:17] <AlexDaniel> doesn't get back online

[17:17] <b2gills> m: sub infix:<Zxor> (\l,\r){ my \r= [xor] l,|r;r??r!!l}; $_ = 5; $_ Zxor= 0,0,0; .say

[17:17] <camelia> rakudo-moar e0a9cf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of symbol 'r'␤at <tmp>:1␤------> 3sub infix:<Zxor> (\l,\r){ my \r7⏏5= [xor] l,|r;r??r!!l}; $_ = 5; $_ Zxor= ␤    expecting any of:␤        new term to be defined␤»

[17:17] <AlexDaniel> my best guess would be that it is this server issue again

[17:17] <AlexDaniel> (freenode server issue I mean)

[17:17] <b2gills> m: sub infix:<Zxor> (\l,\r){ my \a= [xor] l,|r;a??a!!l}; $_ = 5; $_ Zxor= 0,0,0; .say

[17:17] <camelia> rakudo-moar e0a9cf: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 0 in sink context (lines 1, 1, 1, 1)␤5␤»

[17:17] <b2gills> m: sub infix:<Zxor> (\l,\r){ my \a= [xor] l,|r;a??a!!l}; $_ = 5; $_ Zxor= (0,0,0); .say

[17:17] <camelia> rakudo-moar e0a9cf: OUTPUT: «5␤»

[17:18] *** cschwenz joined
[17:18] <AlexDaniel> yea, sometimes it gets stuck on “Attempting to connect to server”

[17:19] *** committable6 joined
[17:19] *** ChanServ sets mode: +v committable6

[17:19] <AlexDaniel> all bots are on wilhelm.freenode.net, but committable is on leguin.freenode.net

[17:19] <AlexDaniel> could be the issue? I don't know…

[17:20] <AlexDaniel> but I'm hoping it will fix itself :)

[17:20] <AlexDaniel> committable6: be a good bot like evalable, or no meat for you :P

[17:20] <committable6> AlexDaniel, ¦«be»: Cannot find this revision (did you mean “all”?)

[17:22] *** itcharlie joined
[17:24] <IOninja> heh, it was Zoffix who added multi sub infix:<cmp>(Rational:D \a, Rational:D \b) candidate and made it a.Num cmp b.Num

[17:25] <IOninja> It replicated old behaviour instead of Doing The Obviously Righter Thing -_-

[17:25] *** pyrimidine left
[17:26] *** pyrimidine joined
[17:28] <cale2> m: say [or] (false, false, false, false)

[17:28] <camelia> rakudo-moar e0a9cf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    false used at line 1␤␤»

[17:28] <Ven> b2gills: Don't worry, I know Jelly/CJam/Pyth and a few others, I have plenty to golf from :)

[17:28] <yoleaux> 17:09Z <b2gills> Ven: I'll tell you the same thing I'm sure I told Hotkeys, if you want me to delay answering Code Golfs I will

[17:28] <AlexDaniel> cale2: False

[17:28] <cale2> m: say [or] (False, False, False, False)

[17:28] <camelia> rakudo-moar e0a9cf: OUTPUT: «False␤»

[17:29] <cale2> m: say [or] (False, False, True, False)

[17:29] <camelia> rakudo-moar e0a9cf: OUTPUT: «True␤»

[17:29] <AlexDaniel> I don't think you need parens there

[17:29] <cale2> m: say [or] False, False, True, False

[17:29] <camelia> rakudo-moar e0a9cf: OUTPUT: «True␤»

[17:29] <AlexDaniel> u: false

[17:29] <unicodable6> AlexDaniel, Found nothing!

[17:29] <AlexDaniel> u: boolean

[17:30] <unicodable6> AlexDaniel, Found nothing!

[17:30] <AlexDaniel> u: truth

[17:30] <unicodable6> AlexDaniel, U+4DFC HEXAGRAM FOR INNER TRUTH [So] (䷼)

[17:30] <AlexDaniel> :S

[17:30] *** pyrimidine left
[17:30] <cale2> m: say any False, False, True, False

[17:30] <camelia> rakudo-moar 3e88c4: OUTPUT: «any(False, False, True, False)␤»

[17:31] <cale2> m: say so any False, False, True, False

[17:31] <camelia> rakudo-moar 3e88c4: OUTPUT: «True␤»

[17:31] <cale2> need to read up on what "so" does

[17:31] <cale2> m: say do any False, False, True, False

[17:31] <camelia> rakudo-moar 3e88c4: OUTPUT: «any(False, False, True, False)␤»

[17:31] <AlexDaniel> cale2: it's just .Bool

[17:31] <AlexDaniel> or prefix ?

[17:31] <cale2> why doesn't `any` evaluate right away? it just constructs a junctino?

[17:32] <IOninja> cale2: because... that's what any does.

[17:32] <IOninja> It constructs a Junction.

[17:32] *** dustinm`_ left
[17:32] <Qwerasd> m: say so ^(False, False, True, False)

[17:32] <camelia> rakudo-moar 3e88c4: OUTPUT: «True␤»

[17:32] <cale2> any and all are both Junction constructors. 

[17:32] <cale2> What about Junction.new

[17:33] <AlexDaniel> cale2: as well as & | ^

[17:33] <IOninja> cale2: If you like long-winded code, sure, you can use Junction.new :)

[17:33] <AlexDaniel> which are just other ways of saying all any one

[17:33] <Qwerasd> m: say so none(False, False, True, False)

[17:33] <camelia> rakudo-moar 3e88c4: OUTPUT: «False␤»

[17:33] *** pyrimidine joined
[17:33] <Qwerasd> m: say so none(False, False, False)

[17:33] <camelia> rakudo-moar 3e88c4: OUTPUT: «True␤»

[17:33] <Qwerasd> Junctions are weird, but they look useful.

[17:34] <IOninja> https://perl6.party/post/Perl-6-Schrodinger-Certified-Junctions

[17:34] <cale2> I think I prefer the [or] and [and] operators instead :D

[17:34] <cale2> more explicit

[17:34] <timotimo> it's far from the same thing

[17:34] <timotimo> m: my Junction $vals = any(1, 2, 3, 4); $vals **= 2; say $vals == 16

[17:34] <camelia> rakudo-moar 3e88c4: OUTPUT: «any(False, False, False, True)␤»

[17:34] <timotimo> m: my Junction $vals = any(1, 2, 3, 4); $vals **= 2; dd $vals

[17:34] <camelia> rakudo-moar 3e88c4: OUTPUT: «Junction $vals = any(1, 4, 9, 16)␤»

[17:35] <timotimo> see how it distributes the **= over all values in the junction?

[17:35] <IOninja> Most common use is to shorten expressions: $x eq 'foo'|'bar'|'ber'

[17:35] <Qwerasd> Yeah an any junctions the way I understand it looks like a list that distributed operations over itself.

[17:36] <Qwerasd> $x eq ^('foo', 'bar', 'baz')

[17:36] <Qwerasd> it's longer tho

[17:36] <Qwerasd> and less clear.

[17:36] <IOninja> than $x eq 'foo' or $x eq 'bar' or $x eq 'ber'?

[17:36] <cale2> the [+] thing is like a fold in a functional language. Or reduce, rather

[17:37] <cale2> junctions, are sort of like folds and reduce too, though, right?

[17:37] <samcv> we use sha1 for modules right? https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html

[17:37] <samcv> or is it sha256?

[17:37] <IOninja> Qwerasd: the ^('foo', 'bar', 'baz') thing is wrong. That's the Range construction op

[17:37] <AlexDaniel> I think the coolest thing with Junctions is that you can shove them into places where no junction was expected, and it will work just fine

[17:37] <IOninja> m: dd ^('foo', 'bar', 'baz')

[17:37] <camelia> rakudo-moar 3e88c4: OUTPUT: «^3␤»

[17:37] <IOninja> m: dd eager ^('foo', 'bar', 'baz')

[17:37] <camelia> rakudo-moar 3e88c4: OUTPUT: «(0, 1, 2)␤»

[17:38] <timotimo> AFKBBL

[17:38] <IOninja> BBQ

[17:38] *** pyrimidine left
[17:39] <IOninja> samcv: sha1. That article don't matter to us, since we're not using it to crypt stuff.

[17:39] <Qwerasd> Wait then would it be ^[] instead of ^() or am I just crazy?

[17:39] <IOninja> Qwerasd: neither.

[17:39] <Qwerasd> Then I'm just crazy.

[17:39] <samcv> well would only matter if somebody got it into @INC? or would have to be in our specific library folder

[17:39] <IOninja> Qwerasd: 'a' ^ 'b'; the Junction op is the prefix op

[17:40] <Qwerasd> Is there a way to define infix methods?

[17:40] <IOninja> dammit

[17:40] <IOninja> Qwerasd: I meant, Junction is the *infix* op, whereas ^[] ^() is the *prefix* op, which is the Range constructor

[17:40] <Qwerasd> Ye I got that.

[17:40] <IOninja> Qwerasd: infix... methods. Not sure what you mean. You can define infix *ops*

[17:40] <Qwerasd> It's a bit confusing, the information density in perl6 is higher than other languages.

[17:41] <IOninja> m: sub infix:<♥> { "$^a loves $^b" }; say 'me' ♥ 'Perl 6'

[17:41] <camelia> rakudo-moar 3e88c4: OUTPUT: «me loves Perl 6␤»

[17:41] <IOninja> Qwerasd: mhm, a bit. But there's a lot of consistency, so once you start noticing patterns, it's a bit easier to take it all in.

[17:41] <Qwerasd> Yeah

[17:42] <Qwerasd> The whole infix and prefix ops being different think threw me off

[17:42] <IOninja> Like 'foo' ~ 'bar' is string concatenation... +$foo coerces $foo to Numeric... So what's the op to coerse something to Str? ... it's prefix ~

[17:43] *** dustinm` joined
[17:43] <IOninja> Qwerasd: the useful rule to remember there is Perl 6 expects an op after a term and two terms in a row is an error. So stuff like `$x ++ $y` may look really weird (and not something you see in real code) but with that rule in mind, it's clear that that is $x + (+$y)

[17:43] <Qwerasd> ~$foo

[17:43] <Qwerasd> right?

[17:43] <IOninja> Yeah

[17:44] <IOninja> m: $foo = class { method Str { 'wooo Imma string now, yo' } }.new; say ~$foo

[17:44] <camelia> rakudo-moar 3e88c4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$foo' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5$foo = class { method Str { 'wooo Imma s␤»

[17:44] <IOninja> m: my $foo = class { method Str { 'wooo Imma string now, yo' } }.new; say ~$foo

[17:44] <camelia> rakudo-moar 3e88c4: OUTPUT: «wooo Imma string now, yo␤»

[17:45] <wamba> m: my $a = Failure.new; $a.defined; say ($a and True ); .say without $a;  say ( $a andthen True );

[17:45] <camelia> rakudo-moar 3e88c4: OUTPUT: «(HANDLED) Failed␤␤(HANDLED) Failed␤␤()␤»

[17:45] *** st_elmo joined
[17:46] *** jonas1 left
[17:46] <IOninja> wamba: calling .defined or .Bool on Failure marks it as hangled.

[17:46] *** rurban joined
[17:46] <IOninja> and makes it non-explosive

[17:46] <IOninja> and without calls .defined and `and` calls .bool

[17:46] <IOninja> *.Bool

[17:47] <Qwerasd> m: my %hash = "Foo" => "Bar", "Biz" => "Baz"; say %hash«Foo»

[17:47] <camelia> rakudo-moar 3e88c4: OUTPUT: «Bar␤»

[17:47] *** rurban1 joined
[17:47] <Qwerasd> I find it funny that «» gets turned to {}, seems like a weird thing to include in a language.

[17:48] <wamba>  IOninja: Ok, but why "andthen" not return Failure but Slip?

[17:49] <IOninja> Qwerasd: not really equivalent.

[17:49] <b2gills> postcircumfix: «…» gets turned into postcircumfix: { Q:qq:ww'…' }

[17:50] <b2gills> circumfix: «…» gets turned into Q:qq:ww'…'

[17:50] <IOninja> Qwerasd: here's a long explanation on the difference: https://rt.perl.org/Ticket/Display.html?id=130827#txn-1449761

[17:50] <Qwerasd> I see, reading furhter in the perl 6 docs, I see it quotes its arguments

[17:50] <Qwerasd> further*

[17:50] *** agentzh joined
[17:51] <b2gills> notice that it quotes it exactly the same as the circumfix version

[17:51] *** rurban left
[17:51] <IOninja> wamba: it returns Empty if any of the arguments aren't defined. This is so it can be used inside lists. Postfix `with` compiles to `andthen` under the hood, for example

[17:53] *** pyrimidine joined
[17:54] <IOninja> m: multi x (:$foo!) { say "here" }; multi x (:$bar!) { say "there" }; my $foo; my $bar = 42; x |($foo andthen :$foo), |($bar andthen :$bar)

[17:54] <camelia> rakudo-moar 3e88c4: OUTPUT: «there␤»

[17:54] <IOninja> m: multi x (:$foo!) { say "here" }; multi x (:$bar!) { say "there" }; my $foo = 42; my $bar; x |($foo andthen :$foo), |($bar andthen :$bar)

[17:54] <camelia> rakudo-moar 3e88c4: OUTPUT: «here␤»

[17:54] <IOninja> ^ one example.

[17:56] <wamba> IOninja:  Could you show me useful example which use this behaviour?

[17:57] <TimToady> makes more sense in a list comprehension

[17:57] <IOninja> wamba: one's above.

[17:58] *** yadzi joined
[17:58] *** yadzi left
[17:58] *** llfourn joined
[17:58] <wamba> IOninja: thank you, 

[17:59] <IOninja> m: dd 4.99999999999999999999999.FatRat

[17:59] <camelia> rakudo-moar 3e88c4: OUTPUT: «FatRat.new(499999999999999999999999, 99999999999999991611392)␤»

[17:59] <Qwerasd> what does dd do?

[17:59] <IOninja> Seems off? kinda expected a 1 with zeros in the denominator

[18:00] <IOninja> Qwerasd: dumps stuff: https://docs.perl6.org/programs/01-debugging#Dumper_function_dd

[18:03] <TimToady> m: dd <4.99999999999999999999999>.FatRat

[18:03] <camelia> rakudo-moar 3e88c4: OUTPUT: «FatRat.new(499999999999999999999999, 100000000000000000000000)␤»

[18:03] <Qwerasd> wait if ~$foo forces $foo into a string, it seems like what should happen is $_~$foo

[18:03] *** llfourn left
[18:03] <Qwerasd> m: my $foo = 10; "bar"; say ~$foo

[18:03] <camelia> rakudo-moar 3e88c4: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "bar" in sink context (line 1)␤10␤»

[18:04] *** llfourn joined
[18:04] <TimToady> IOninja: bare 4.99999999999999999999999 turns into a Rat before you FatRat it

[18:04] <IOninja> m: say 499999999999999999999999 ~~ UInt64

[18:04] <camelia> rakudo-moar 3e88c4: OUTPUT: «False␤»

[18:05] <IOninja> Oh, tis too big

[18:05] <Qwerasd> m: my $foo = 10; say ~$foo; say $_

[18:05] <camelia> rakudo-moar 3e88c4: OUTPUT: «10␤(Any)␤»

[18:05] <IOninja> m: dd WHAT <4.99999999999999999999999>

[18:05] <camelia> rakudo-moar 3e88c4: OUTPUT: «RatStr␤»

[18:05] <IOninja> TimToady: and that one doesn't?

[18:05] <IOninja> s: RatStr, 'FatRat', \|()

[18:05] *** dakkar left
[18:05] <IOninja> s: RatStr, 'FatRat', \()

[18:05] <TimToady> FatRat knows to use the Str part

[18:05] <SourceBaby> IOninja, Something's wrong: ␤ERR: Could not find candidate that can do \(())␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 29␤  in block <unit> at -e line 6␤␤

[18:05] <SourceBaby> IOninja, Something's wrong: ␤ERR: Could not find candidate that can do \()␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 29␤  in block <unit> at -e line 6␤␤

[18:05] <IOninja> Ah :) nice

[18:06] <IOninja> TimToady++ thanks.

[18:06] <TimToady> m: dd '4.99999999999999999999999'.FatRat

[18:06] <camelia> rakudo-moar 3e88c4: OUTPUT: «No such method 'FatRat' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»

[18:06] <TimToady> arguably that should work too

[18:06] <IOninja> m: dd [.Num, .Int, .Rat] with '4.99999999999999999999999'

[18:06] <camelia> rakudo-moar 3e88c4: OUTPUT: «[5e0, 4, <499999999999999999999999/100000000000000000000000>]␤»

[18:06] <IOninja> will add

[18:08] <TimToady> m: say 100000000000000000000000.msb

[18:08] <camelia> rakudo-moar 3e88c4: OUTPUT: «76␤»

[18:08] <TimToady> hmm

[18:08] <TimToady> that's odd

[18:08] <IOninja> s: '', 'Rat', \()

[18:08] <TimToady> m: say '4.99999999999999999999999'.Rat.WHAT

[18:08] <camelia> rakudo-moar 3e88c4: OUTPUT: «(Rat)␤»

[18:09] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/e0a9cf6/src/core/Cool.pm#L258

[18:09] *** llfourn left
[18:09] <IOninja> m: say 4.99999999999999999999999 <=> 5

[18:09] <camelia> rakudo-moar 3e88c4: OUTPUT: «More␤»

[18:09] <IOninja> y u wrong

[18:09] *** andrzejku joined
[18:10] <TimToady> how did dd get a denom of 100000000000000000000000 out of a .Rat?

[18:11] <IOninja> m: dd val('4.99999999999999999999999', :val-or-fail)

[18:11] <camelia> rakudo-moar 3e88c4: OUTPUT: «<499999999999999999999999/100000000000000000000000>␤»

[18:11] <IOninja> s: &val, \('4.99999999999999999999999', :val-or-fail)

[18:11] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/e0a9cf6/src/core/allomorphs.pm#L131

[18:11] <TimToady> but it's after a .Rat

[18:12] *** Qwerasd left
[18:12] <IOninja> the return from val about is a Rat too, and the ''.Rat is ''.Numeric.Rat is val('', :val-or-fail).Rat

[18:13] <IOninja> m: dd Rat.new: 499999999999999999999999, 100000000000000000000000

[18:13] <camelia> rakudo-moar 3e88c4: OUTPUT: «<499999999999999999999999/100000000000000000000000>␤»

[18:14] <IOninja> And I guess that's that cause

[18:14] <TimToady> that kinda violates the Rat invariant...

[18:15] <TimToady> but maybe it's okay, since it's not sticky through Rat ops

[18:15] <IOninja> Should it throw or return a FatRat or Num?

[18:15] *** risou_awy is now known as risou

[18:16] *** tomaw left
[18:16] *** tomaw joined
[18:16] <TimToady> but if it does actually store a FatRat under Rat, then if we ever actually make the denom a UInt64, it's gonna break

[18:16] <pmurias> SmokeMachine: installing python itself seems a stretch, but having the user able to tell zef 'install python modules using this' seems desirable

[18:17] <TimToady> or a uint64

[18:18] <IOninja> m: say 4.99999999999999999999999 <=> 5.0

[18:18] <camelia> rakudo-moar 3e88c4: OUTPUT: «More␤»

[18:18] <TimToady> but if it accidentally a 100000000000000000000000 in there, then .FatRat y u no workie?

[18:18] <IOninja> m: say 4.99999999999999999999999.norm <=> 5.0.norm

[18:18] <camelia> rakudo-moar 3e88c4: OUTPUT: «More␤»

[18:18] <IOninja> m: say 4.99999999999999999999999.nude

[18:18] <camelia> rakudo-moar 3e88c4: OUTPUT: «(499999999999999999999999 99999999999999991611392)␤»

[18:19] <TimToady> m: say 99999999999999991611392.msb

[18:19] <camelia> rakudo-moar 3e88c4: OUTPUT: «76␤»

[18:19] <TimToady> still >64 bits, and wrong to boot

[18:20] <IOninja> yikes

[18:20] <IOninja> Don't really get why it gives More tho

[18:20] <TimToady> maybe any literal Rat that exceeds 64-bit denom should automatically turn into a RatStr?

[18:20] <IOninja> Why not into a FatRat?

[18:21] <TimToady> because FatRats are contagious

[18:21] <IOninja> Ah

[18:21] <TimToady> m: say <4.99999999999999999999999> <=> 5.0

[18:21] <camelia> rakudo-moar 3e88c4: OUTPUT: «Less␤»

[18:21] <IOninja> ...

[18:22] <IOninja> s: &infix:«<=>», \(<4.99999999999999999999999>, 5.0)

[18:22] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/3e88c41/src/core/Rat.pm#L289

[18:22] <IOninja> s: &infix:«<=>», \(4.99999999999999999999999, 5.0)

[18:22] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/3e88c41/src/core/Rat.pm#L289

[18:22] <IOninja> heh

[18:22] <IOninja> m: say <4.99999999999999999999999>.nude

[18:22] <camelia> rakudo-moar 3e88c4: OUTPUT: «(499999999999999999999999 100000000000000000000000)␤»

[18:23] <IOninja> Ah, k, now I finally get why it gives Less.

[18:23] <TimToady> m: say <4.99999999999999999999999>.Numeric.WHAT

[18:23] <camelia> rakudo-moar 3e88c4: OUTPUT: «(Rat)␤»

[18:25] <IOninja> m: say FatRat.new(0, 0) <=> Inf

[18:25] <camelia> rakudo-moar 3e88c4: OUTPUT: «Nil␤»

[18:25] <IOninja> m: say <0/0> <=> Inf

[18:25] <camelia> rakudo-moar 3e88c4: OUTPUT: «Nil␤»

[18:25] *** cschwenz left
[18:25] <IOninja> cute...

[18:28] <IOninja> Hm... "https://github.com/rakudo/rakudo/blob/3e88c41/src/core/Num.pm#L390

[18:28] <IOninja> Hm... "Here we treat NaN as undefined": https://github.com/rakudo/rakudo/blob/3e88c41/src/core/Num.pm#L390

[18:28] <IOninja> and giving a weird result in return?

[18:29] <IOninja> can't compare a NaN or something.

[18:29] <IOninja> m: say 4.999999999999999999 cmp 5.0

[18:29] <camelia> rakudo-moar 3e88c4: OUTPUT: «Same␤»

[18:29] <IOninja> well, I got a fix for that but it breaks <0/0> cmp Inf comparison 

[18:29] <IOninja> m: say <0/0> cmp Inf

[18:29] <camelia> rakudo-moar 3e88c4: OUTPUT: «More␤»

[18:30] <IOninja> guess it's IEEE time again, but I'm out of non-IO tuits for the day.

[18:30] <IOninja> Will finish it off tomorrow

[18:31] *** Actualeyes left
[18:32] <IOninja> .oO( a.isNaN || b.isNaN ?? a cmp b !! a <=> b )

[18:32] *** risou is now known as risou_awy

[18:35] <IOninja> infiniloop \o/

[18:35] <IOninja> .oO( a.isNaN || b.isNaN ?? a.Num cmp b.Num !! a <=> b ... I guess)

[18:43] *** eroux left
[18:48] *** Actualeyes joined
[18:53] *** Actualeyes left
[18:59] <IOninja> for Cool.FatRat, I'm adding self.Numeric.FatRat... which I *hope* does the right thing for all the Cools?

[19:00] *** mcsnolte joined
[19:00] <IOninja> m: dd Duration.new: 4.99999999999999999999999

[19:00] <camelia> rakudo-moar 9e8ecb: OUTPUT: «Duration.new(<499999999999999999999999/99999999999999991611392>)␤»

[19:00] <IOninja> m: dd Duration.new: <4.99999999999999999999999>

[19:01] <camelia> rakudo-moar 9e8ecb: OUTPUT: «Duration.new(<499999999999999999999999/100000000000000000000000>)␤»

[19:01] <IOninja> m: dd Duration.new(<4.99999999999999999999999>).Numeric.FatRat

[19:01] <camelia> rakudo-moar 9e8ecb: OUTPUT: «No such method 'FatRat' for invocant of type 'Duration'␤  in block <unit> at <tmp> line 1␤␤»

[19:01] <IOninja> ummm

[19:01] <IOninja> m: dd Duration.new(<4.99999999999999999999999>).Rat

[19:01] <camelia> rakudo-moar 9e8ecb: OUTPUT: «<499999999999999999999999/100000000000000000000000>␤»

[19:02] <IOninja> s: Duration.new(<4.99999999999999999999999>), 'Rat', \()

[19:02] <SourceBaby> IOninja, Sauce is at https://github.com/rakudo/rakudo/blob/3e88c41/src/core/Duration.pm#L8

[19:02] <IOninja> s: Duration.new(<4.99999999999999999999999>), 'FatRat', \()

[19:02] <SourceBaby> IOninja, Something's wrong: ␤ERR: Could not find candidate that can do \()␤  in sub sourcery at /home/zoffix/services/lib/CoreHackers-Sourcery/lib/CoreHackers/Sourcery.pm6 (CoreHackers::Sourcery) line 29␤  in block <unit> at -e line 6␤␤

[19:02] <IOninja> I see -_-

[19:02] <IOninja> Deep does the rabbit... I mean fat rat... hole goes.

[19:03] <IOninja> m: say Duration ~~ Numeric

[19:03] <camelia> rakudo-moar 9e8ecb: OUTPUT: «True␤»

[19:03] <IOninja> So Numeric ain't providing .Numeric method.

[19:04] *** darutoko left
[19:04] <IOninja> .. or .FatRat method :\

[19:05] *** llfourn joined
[19:05] <IOninja> oh wait, it does have Numeric. nm

[19:05] <IOninja> time to take a break for today with this :)

[19:07] *** cdg left
[19:07] *** eroux joined
[19:07] <MasterDuke> m: say "groß".fc; say "groß" ~~ /:i gross /

[19:07] <camelia> rakudo-moar 9e8ecb: OUTPUT: «gross␤Nil␤»

[19:08] <MasterDuke> should ^^^ match?

[19:08] *** rurban1 left
[19:08] <IOninja> hehe

[19:08] <IOninja> It does!

[19:08] <IOninja> m: say "groß".fc; say "groß".fc ~~ /:i gross /

[19:08] <camelia> rakudo-moar 9e8ecb: OUTPUT: «gross␤｢gross｣␤»

[19:09] <IOninja> m: say "groß".fc; say "groß".fc ~~ /:i groß /

[19:09] <camelia> rakudo-moar 9e8ecb: OUTPUT: «gross␤Nil␤»

[19:09] <IOninja> awww

[19:09] *** rurban joined
[19:09] *** rurban left
[19:09] <MasterDuke> ha, yeah, that's what i was trying to show

[19:09] <MasterDuke> IOninja++

[19:10] *** llfourn left
[19:10] <IOninja> There's this ticket: https://rt.perl.org/Ticket/Display.html?id=126793#ticket-history

[19:10] <IOninja> Well, I dunno if you're meant to use .fc on the string in that case.

[19:10] <MasterDuke> m: say "groß".fc; say "groß" ~~ /:i groß /

[19:10] <camelia> rakudo-moar 9e8ecb: OUTPUT: «gross␤｢groß｣␤»

[19:11] <MasterDuke> doh

[19:11] <IOninja> m: say "groß".fc ~~ / gross /

[19:11] <camelia> rakudo-moar 9e8ecb: OUTPUT: «｢gross｣␤»

[19:11] <IOninja> m: say "groß" ~~ / groß /

[19:11] <camelia> rakudo-moar 9e8ecb: OUTPUT: «｢groß｣␤»

[19:12] <IOninja> like, it matches without even the :i thing

[19:12] <MasterDuke> well yeah

[19:13] <IOninja> works fine in Perl 5

[19:13] <IOninja> so yeah, a bug :)

[19:13] *** yadzi joined
[19:13] *** breinbaas left
[19:14] *** ChoHag left
[19:15] *** mcmillhj joined
[19:15] <IOninja> m: say 4.999999999999999999 cmp 5.0

[19:15] <camelia> rakudo-moar 9e8ecb: OUTPUT: «Less␤»

[19:15] <IOninja> m: 42 notandthen say "hi"

[19:15] <camelia> rakudo-moar 9e8ecb: ( no output )

[19:15] <IOninja> yey

[19:18] *** eroux left
[19:19] <IOninja> samcv: oh, sorry, I thought it was the old sha1 one article.

[19:20] <IOninja> ehehehe, well, it got a website, a trendy name, and a logo: https://shattered.io/ gotta a serious vuln :P

[19:21] <timotimo> 𐄹yolo

[19:23] *** Actualeyes joined
[19:26] *** TEttinger joined
[19:29] *** cdg joined
[19:32] <geekosaur> like nobody saw that coming. sha1's been deprecated for a reason

[19:32] <IOninja> :)

[19:32] *** yadzi left
[19:34] *** cdg left
[19:35] *** mcmillhj left
[19:35] *** raiph left
[19:38] *** mcmillhj joined
[19:42] *** mcmillhj left
[19:43] *** andrzejku left
[19:44] *** andrzejku joined
[19:46] *** andrzejku left
[19:47] *** bjz joined
[19:48] *** Actualeyes left
[19:49] *** espadrine joined
[19:50] *** andrzejku joined
[19:51] *** mcmillhj joined
[19:55] *** pyrimidine left
[19:55] *** pyrimidine joined
[19:55] *** mcmillhj left
[20:00] *** pyrimidine left
[20:03] *** rumble joined
[20:05] *** Qwerasd joined
[20:05] *** mcmillhj joined
[20:06] *** noganex_ left
[20:06] *** llfourn joined
[20:07] *** grumble left
[20:07] *** rumble is now known as grumble

[20:09] *** ggoebel left
[20:09] *** mcmillhj left
[20:10] *** mcmillhj joined
[20:11] <IOninja> Any cool way to find all core types that are Cool?

[20:12] <IOninja> Using grep -FR 'is Cool' ATM... hoping I got 'em all that way

[20:13] <SmokeMachine> IOninja: not cool, but: https://github.com/FCO/Test-Fuzz/blob/master/lib/Test/Fuzz/Generator.pm6#L19

[20:14] <gfldex> IOninja: you could adapt perl6-doc/util/list-missing-methods.p6

[20:14] <IOninja> I got Instant, List, Map, Range, Complex, Str, Rat, Nil, Match, Num, StrDistance, Seq, IO::Path, Duration

[20:14] <IOninja> oh, right

[20:14] <IOninja> SmokeMachine++ thanks

[20:14] *** llfourn left
[20:16] *** risou_awy is now known as risou

[20:16] <IOninja> m: CORE::.keys.grep(* ne 'IterationEnd').map({CORE::{$_}}).grep({!.DEFINITE and $_ ~~ Cool}).unique.say

[20:16] <camelia> rakudo-moar 9e8ecb: OUTPUT: «((Slip) (PromiseStatus) (StringyEnumeration) (Distribution) (int16) Nil (Setty) (FileChangeEvent) (UInt64) (Rational) (RatStr) (uint64) (Numeric) (Instant) (byte) (Bool) (Associative) (Iterator) (uint32) (ProtocolFamily) (Rat) (Enumeration) (Blob[uint16]…»

[20:17] <IOninja> umm hehe

[20:19] <IOninja> m: my byte $x = 42; say $x

[20:19] <camelia> rakudo-moar 9e8ecb: OUTPUT: «42␤»

[20:19] <IOninja> TIL we have that

[20:20] <MasterDuke> m: my byte $x = 256; say $x

[20:20] <camelia> rakudo-moar 9e8ecb: OUTPUT: «0␤»

[20:20] <MasterDuke> m: my byte $x = 255; say $x

[20:20] <camelia> rakudo-moar 9e8ecb: OUTPUT: «255␤»

[20:21] <moritz> m: say byte.^name

[20:21] <camelia> rakudo-moar 9e8ecb: OUTPUT: «byte␤»

[20:21] <moritz> I kinda expected that to spit back uint8 at us :-)

[20:22] *** rindolf left
[20:22] *** Actualeyes joined
[20:22] <MasterDuke> m: say byte.^mro

[20:22] <camelia> rakudo-moar 9e8ecb: OUTPUT: «((byte) (Int) (Cool) (Any) (Mu))␤»

[20:24] <gfldex> IOninja: run this in the docs root https://gist.github.com/a73657f6d5dd9d34a4a27467b6050003

[20:24] *** noganex joined
[20:25] *** breinbaas joined
[20:25] <IOninja> gfldex: seems busted. I see Positional in the results.

[20:26] <IOninja> But I guess to make my original question more precise: I want just the types that have `is Cool` not their subclasses.

[20:26] <gfldex> IOninja: sorry, silly me

[20:26] <IOninja> And using grep I found them to be: Instant, List, Map, Range, Complex, Str, Rat, Nil, Match, Num, StrDistance, Seq, IO::Path, Duration

[20:26] <gfldex> IOninja: then just grep type-graph.txt

[20:27] <IOninja> + Int

[20:27] <IOninja> + FatRat

[20:28] <IOninja> gfldex++ thanks

[20:29] <gfldex> https://gist.github.com/gfldex/bd0e2e1aa5eb02386e1601f056953fbc

[20:29] <gfldex> that gist actually works

[20:32] <gfldex> The type graph in the docs only shows direct decendents, I wonder if we should list all.

[20:33] *** risou is now known as risou_awy

[20:34] <IOninja> I think the htmlify.p6 does a check to see whether a routine belongs to the class it's documented in, right?

[20:34] *** st_elmo left
[20:35] <IOninja> Seems busted for roles. Numeric is documented to provide a .Rat method: https://docs.perl6.org/routine/Rat but it actually doesn't https://github.com/rakudo/rakudo/blob/nom/src/core/Numeric.pm#L4-L30

[20:35] <moritz> if so, I certainly didn't put that in

[20:37] *** ggoebel joined
[20:37] <IOninja> " felher committed with moritz on Jul 6, 2012"

[20:37] <moritz> huh?

[20:37] <IOninja> Well, the docs for Numeric.Rat. Not the bustification of htmlify.p6

[20:37] <moritz> oh

[20:38] <IOninja> I recall when we were trying to add some method to docs it was complaining about it, and the cause was because the sub or op was defined in Str.pm but we documented it in Cool.pm or something or other

[20:39] *** itaipu joined
[20:39] <IOninja> I'll fix the Rat/FatRat docs tonight or tomorrow. Haven't checked if any other methods are similarly incorrectly documented.

[20:39] <IOninja> I meant .Rat/.FatRat for all types and roles

[20:42] <IOninja> Here's the code that complains about it: https://github.com/perl6/doc/blob/master/htmlify.p6#L633-L646

[20:45] <moritz> but that just tries to parse the doc block to see if it's a method or a sub

[20:45] <moritz> not whether it actually exists in the class or role you're documenting

[20:46] <moritz> the last part of the error message is a bit confusing though

[20:47] <IOninja> I think I added it

[20:47] <IOninja> with a useless commit message: https://github.com/perl6/doc/commit/e5ef1d0b1e77c4ba3d4a56334ad90561360335b2

[20:48] <IOninja> At least there's a date...

[20:48] * IOninja checks IRC logs

[20:49] <Geth> ¦ doc/WildYorkies-patch-1: d399c960e2 | Cale++ | lib/Pod/Htmlify.pm6

[20:49] <Geth> ¦ doc/WildYorkies-patch-1: change return-ifs to switch

[20:49] <Geth> ¦ doc/WildYorkies-patch-1: review: https://github.com/perl6/doc/commit/d399c960e2

[20:49] *** Actualeyes left
[20:50] <Geth> ¦ doc: WildYorkies++ created pull request #1214: change return-ifs to switch

[20:50] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/1214

[20:50] <IOninja> umm... gotta relocate.

[20:51] <IOninja> I remember samcv was trying to document something and the build was failing and that was because routine was defined in Str (or Cool) but she was documenting it in Cool (or Str). Don't see off hand in the log where that event occurs http://irclog.perlgeek.de/perl6/2016-12-09

[20:51] <IOninja> Might be previous day

[20:51] * IOninja &

[20:57] <[Coke]> I am surprised if that was an actual build fail. huh

[20:58] <andrzejku> the perl6 nativecall

[20:58] <andrzejku> are really hard to understand

[20:58] <Geth> ¦ doc/WildYorkies-patch-2: 8db2bcbc1d | Cale++ | lib/Pod/Convenience.pm6

[20:58] <Geth> ¦ doc/WildYorkies-patch-2: change else-if to given/when switch

[20:58] <Geth> ¦ doc/WildYorkies-patch-2: review: https://github.com/perl6/doc/commit/8db2bcbc1d

[20:58] <Geth> ¦ doc: WildYorkies++ created pull request #1215: change else-if to given/when switch

[20:58] <Geth> ¦ doc: review: https://github.com/perl6/doc/pull/1215

[21:01] <Geth> ¦ doc: a9a6a83d98 | (Brad Gilbert)++ | doc/Language/haskell-to-p6.pod6

[21:01] <Geth> ¦ doc: map and grep for list comprehensions

[21:01] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/a9a6a83d98

[21:02] *** rurban joined
[21:05] <Geth> ¦ doc: 9bb3ae7355 | (Brad Gilbert)++ | doc/Language/haskell-to-p6.pod6

[21:05] <Geth> ¦ doc: clean up cruft from tuples example

[21:05] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9bb3ae7355

[21:05] *** Actualeyes joined
[21:06] *** Qwerasd left
[21:10] *** llfourn joined
[21:14] *** bjz left
[21:16] *** llfourn left
[21:16] *** cdg joined
[21:16] <IOninja> cale2, it's not mandatory to use `given` with `when`

[21:17] <cale2> ah... good to know

[21:18] <IOninja> m: for ^10 { when *.is-prime { "tis prime".say }; when * %% 2 { "tis even".say }; "this number sucks".say }

[21:18] <camelia> rakudo-moar 9e8ecb: OUTPUT: «tis even␤this number sucks␤tis prime␤tis prime␤tis even␤tis prime␤tis even␤tis prime␤tis even␤this number sucks␤»

[21:19] <Geth> ¦ doc/WildYorkies-patch-2: 5a5a507b29 | Cale++ | lib/Pod/Convenience.pm6

[21:19] <Geth> ¦ doc/WildYorkies-patch-2: get rid of given and alias

[21:19] <Geth> ¦ doc/WildYorkies-patch-2: review: https://github.com/perl6/doc/commit/5a5a507b29

[21:19] *** itaipu left
[21:20] *** itaipu joined
[21:22] <cale2> so there's no real "switch block". There's just chains of when

[21:22] <AlexDaniel> kinda

[21:22] <IOninja> mhm

[21:23] <AlexDaniel> m: default { say ‘well… ok!’ }

[21:23] <camelia> rakudo-moar 9e8ecb: OUTPUT: «well… ok!␤»

[21:23] <cale2> `when` is basically the same as `if` except `when` automatically smartmatches and passes item to anon variable

[21:23] <IOninja> `given` is just a handy way to alias stuff to $_

[21:23] <moritz> `when` also short-circuits to avoid a second match

[21:23] <gfldex> cale2: proceed and succeed require a given block

[21:23] <IOninja> cale2, and block form `when` also shortcuircuits

[21:23] <moritz> m: given 1 { when True { say 1 }; when True { say 2 } }

[21:23] <camelia> rakudo-moar 9e8ecb: OUTPUT: «Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at <tmp>:1␤    ------> 3given 1 { when 7⏏5True { say 1 }; when True { say 2 } }␤    Smartmat…»

[21:23] <IOninja> Do they?

[21:23] <IOninja> Weird

[21:23] <moritz> m: given 1 { when 1 { say 1 }; when Int { say 2 } }

[21:23] <camelia> rakudo-moar 9e8ecb: OUTPUT: «1␤»

[21:24] <moritz> DWIM etc

[21:24] <AlexDaniel> m: when Any { say ‘:O’ }; default { say ‘well… ok!’ }

[21:24] <camelia> rakudo-moar 9e8ecb: OUTPUT: «:O␤»

[21:24] <AlexDaniel> m: default { say ‘well… ok!’ }; when Any { say ‘:O’ }

[21:24] <camelia> rakudo-moar 9e8ecb: OUTPUT: «well… ok!␤»

[21:24] <AlexDaniel> hmm…

[21:25] <cale2> default is just an alias for `when True` right?

[21:25] <moritz> m: given 1 { default { say 1 }; say 2 }

[21:25] <camelia> rakudo-moar 9e8ecb: OUTPUT: «1␤»

[21:26] <gfldex> m: when so True { proceed }

[21:26] <camelia> rakudo-moar 9e8ecb: ( no output )

[21:26] <moritz> cale2: looks like it, yes

[21:26] <IOninja> m: proceed

[21:26] <camelia> rakudo-moar 9e8ecb: OUTPUT: «proceed without when clause␤  in block <unit> at <tmp> line 1␤␤»

[21:26] <IOninja> m: when 42 { proceed }

[21:26] <camelia> rakudo-moar 9e8ecb: ( no output )

[21:26] <AlexDaniel> so default has to be the last one always?

[21:26] <IOninja> gdflex, seems it don't?

[21:27] <gfldex> indeed

[21:27] <tony-o> m: given 1 { default { 'def'.say; }; when 1 { '1'.say; }; };

[21:27] <camelia> rakudo-moar 9e8ecb: OUTPUT: «def␤»

[21:27] <cale2> m: when 42 ~~ Any { say "hi"; proceed; } say "bye";

[21:27] <camelia> rakudo-moar 9e8ecb: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3when 42 ~~ Any { say "hi"; proceed; }7⏏5 say "bye";␤»

[21:27] <cale2> m: when 42 ~~ Any { say "hi"; proceed; }; say "bye";

[21:27] <camelia> rakudo-moar 9e8ecb: OUTPUT: «hi␤bye␤»

[21:27] <IOninja> AlexDaniel, yup and I recall there being a ticket asking that we warn when it isn't

[21:27] <cale2> proceed just needs when, not given

[21:28] <AlexDaniel> #RT 129025

[21:28] <AlexDaniel> RT #129025

[21:28] <synopsebot6> Link:  https://rt.perl.org/rt3//Public/Bug/Display.html?id=129025

[21:29] *** girafe left
[21:30] *** andrzejku left
[21:30] *** bolo58249 joined
[21:31] *** hankache joined
[21:32] *** robertle joined
[21:33] *** labster joined
[21:35] <bolo58249> hello. I'm wondering if Perl 6 is a good first language to learn. Any opinions from experienced multi-linguists would be appreciated! Thanks.

[21:35] <hankache> hola #perl6

[21:35] <cale2> hola 

[21:36] <gfldex> bolo58249: the language itself is fine as a first language, the ecosystem and resources for double beginners are not (IMHO)

[21:36] <AlexDaniel> bolo58249: just try it and see if it works for you?

[21:36] <b2gills> I think in the future when there are better docs, or you have a good teacher, it could be a good first language

[21:36] <AlexDaniel> b2gills: when was the last time you looked at the docs? :P

[21:37] <cale2> bolo58249: learning Perl6 will expose you to the whole world of programming. Not just one paradigm

[21:37] <gfldex> our tutorials are very lacking

[21:37] <bolo58249> what are "double beginners"?

[21:37] *** gregf_ left
[21:37] <b2gills> The docs are good if you already have a logical mind, or already know another similar language

[21:37] <gfldex> beginners of Perl 6 and programming

[21:37] <cale2> https://library.oreilly.com/book/0636920065883/think-perl-6/toc

[21:37] <cale2> read this and try it out :)

[21:37] <bolo58249> ok thanks

[21:38] <hankache> bolo58249 check out perl6intro.com I hope it helps.

[21:38] <gfldex> a tripple beginner would also not know how a computer works

[21:38] <b2gills> A good way to learn it currently is to ask questions here (using a paste bin)

[21:38] <gfldex> and a quadruple beginner would not know how to use a computer

[21:39] <AlexDaniel> .oO( WHAT THE HELL IS COMPUTER ?! http://www.poorlydrawnlines.com/comic/naive-dramatic/ )

[21:40] <b2gills> A computer is obviously a person who computes numbers, duh.

[21:41] <IOninja> :)

[21:41] <geekosaur> hey, used to be true

[21:41] <AlexDaniel> when was the last time somebody used this word with that meaning?

[21:42] <geekosaur> 40s?

[21:42] <geekosaur> ish

[21:42] <geekosaur> and what we call "computer" was "calculator"/"calculating machine"

[21:43] <geekosaur> (this is also why "pocket calculator", from which we've dropped the "pocket")

[21:44] <bolo58249> the women doing the math in that new nasa movie were called "computers" I think

[21:44] *** ChoHag joined
[21:45] <geekosaur> yeh, ws thinking there are likely to be areas (government being a likely one) where it held out into the 50s or even 60s

[21:45] <geekosaur> I should rephrase that from government to military probably

[21:46] <gfldex> most companies didn't have computer well into the 70s

[21:46] <gfldex> to pricy

[21:47] <bolo58249> then they brought in the IBM machine to "compute" the trip to the moon and the ladies programmed it with FORTRAN

[21:47] <IOninja> What new NASA movie?

[21:47] <gfldex> when I was a wee boy the accountant in my dads firm used something like this https://www.technikum29.de/shared/photos/rechnertechnik/olivetti-logos27-2.jpg

[21:47] <bolo58249> I think it was called "Hidden Figures"

[21:47] <gfldex> made a hell of a noise

[21:48] <bolo58249> About some of the women who did the maths on the moon landing project.

[21:48] <AlexDaniel> .oO( not that people are completely silent… )

[21:49] <gfldex> the machine made the noise, not the lady

[21:49] *** ufobat_ left
[21:56] <cale2> how long does travis ci take?

[21:56] <cale2> a while

[21:56] *** pyrimidine joined
[21:59] <b2gills> travis ci is a commercial product and they use the otherwise unused time to test open source projects

[22:00] *** hankache left
[22:01] *** pyrimidine left
[22:01] *** pyrimidine joined
[22:02] *** itaipu left
[22:04] <gfldex> cale2: there are no binary packages available for rakudo, so the bulk of the 6 min is used to build the compiler

[22:05] <gfldex> actually we do have bin packages, we just don't use them in travis

[22:06] *** pyrimidine left
[22:08] <cale2> moritz: messaged my friend about your book cover

[22:09] <cale2> doing an interpretation of camelia would be a hell of a challenge.

[22:09] *** pyrimidine joined
[22:09] <cale2> "make a book cover for a technical programming book. but tie in this cartoon butterfly to your design"

[22:10] *** RabidGravy left
[22:12] *** llfourn joined
[22:12] *** skids left
[22:13] <cale2> Perhaps a butterfly riding on the back of a camel towards a large CRT monitor on the horizon

[22:13] *** pyrimidine left
[22:13] <timotimo> a butterfly lifting a camel, perhaps

[22:14] <gfldex> i would prefer a butterfly feeding from the flower of the tree of knowledge :->

[22:14] <timotimo> so a blooming apple tree?

[22:14] <gfldex> they never said what tree it actually is in the bible

[22:15] <gfldex> well, it says: the tree of knowledge of good and evil

[22:15] <cale2> well, "by example" sort of indicates a journey is about to take place, right?

[22:15] <gfldex> not sure if apple trees have such knowledge

[22:16] <cale2> if you really want a memorable cover, get someone that typically draws concert posters to do it

[22:16] <gfldex> i my experience examples are mostly stationary

[22:17] *** llfourn left
[22:17] *** risou_awy is now known as risou

[22:18] <cale2> but you write the examples together over time

[22:20] <gfldex> if you write the examples while in a train or bus, then yes, it's a jouney

[22:21] <gfldex> in the natural languages I use mixing "work" and "journey" don't mix well

[22:22] <cale2> haha

[22:22] <lizmat> https://news.ycombinator.com/item?id=13715048  # no mention of Perl 6 books (yet)  :-(

[22:23] <cale2> a lot of the No Starch Press python books have a snake doing random things: https://www.nostarch.com/inventwithpython https://www.nostarch.com/pythoncrashcourse

[22:23] <gfldex> the problem with illustrations on programming books is that pretty much anything on the topic is either an abstract concept or a written symbols. Both are pretty hard to turn into sweet pictures.

[22:24] <gfldex> may be the reason why o'reilly tends to put unrelated animals on their covers

[22:25] <cale2> I think it's just meant to grab attention, right? All the o'reilly animals are sort of their "brand". You instantly know its an oreilly book

[22:25] *** atweiden-air joined
[22:26] <gfldex> lizmat: that list is missing Higher-Order Perl, so they don't know what they are talking about anyways :->

[22:26] <lizmat> yeeah, and it's missing Beginning Perl as well, as pointed out in the comment

[22:26] <lizmat> still...

[22:26] <gfldex> cale2: that's certainly the result, but may not have been the intention

[22:29] *** sena_kun left
[22:29] <El_Che> "Practical mod_perl" <-- whut?

[22:29] <gfldex> wow, he put the whole Higher-Order Perl book up for download as a pdf

[22:31] <atweiden-air> with parameterized roles `role ABC[Bool:D $si, 'A', 'B']` and `role ABC[Bool:D $si, 'Y']`

[22:31] <atweiden-air> is it possible to grep the array `my ABC:D @roles` for `ABC[True, *@]` so as to ignore the variable length Str components of the ABC role params?

[22:31] *** itaipu joined
[22:32] <atweiden-air> i know i can .grep(ABC[True, Str]|ABC[True, Str, Str])

[22:34] *** risou is now known as risou_awy

[22:34] <gfldex> atweiden-air: you could use an empty class as a base type for both roles

[22:35] <cale2> Perl 6 by Example: The Perl of Great Price

[22:35] *** mcmillhj left
[22:35] *** mcmillhj joined
[22:36] <atweiden-air> maybe it can be solved with macro

[22:37] *** Voldenet left
[22:37] *** cibs left
[22:37] <gfldex> atweiden-air: it can for sure be solved without a macro. The code example you provided is a bit thin tho.

[22:38] <atweiden-air> gfldex: http://ix.io/nJB

[22:39] *** cibs joined
[22:39] <atweiden-air> gfldex: am using Mode:D $.mode is required attribute currently

[22:40] <atweiden-air> instead of having $mode in the role params

[22:40] *** mcmillhj left
[22:40] *** cdg left
[22:42] *** Voldenet joined
[22:42] *** Voldenet left
[22:42] *** Voldenet joined
[22:42] <IOninja> oh, didn't realize the 4.99999999999 cmp 5 thing was a ticket...

[22:43] <IOninja> https://rt.perl.org/Ticket/Display.html?id=130845#txn-1449958

[22:44] <IOninja> My reading of it tell me the OP is expecting 4.99999999999999999999999999999999999999 ~~ 0..^5 to give True as well, but that won't be the case

[22:44] <gfldex> atweiden-air: you get exactly what you ask for, .gist is just to stupid to handle autopunned roles properly.

[22:44] <lizmat> IOninja: why won't that be the case>

[22:45] <lizmat> ?

[22:45] <IOninja> m: dd 4.99999999999999999999999999999999999999

[22:45] <camelia> rakudo-moar 9e8ecb: OUTPUT: «<499999999999999999999999999999999999999/99999999999999997748809823456034029568>␤»

[22:45] <IOninja> lizmat: because of that ^

[22:45] <IOninja> I'm not entirely clear what are we supposed to do for Rats whose parts are >64bit. 

[22:46] <gfldex> atweiden-air: or better, it's not clever enough to show a role with no attributes

[22:46] *** khw joined
[22:46] <atweiden-air> gfldex: .gist isn't the problem. i would just prefer if the grep could look more like `@sectional-inline.grep(SectionalInline[FINN, *@]).say;`

[22:46] <timotimo> well, if you don't ask for a FatRat, you're in the wrong there anyway

[22:46] <lizmat> m: 499999999999999999999999999999999999999/99999999999999997748809823456034029568  # indeed

[22:46] <camelia> rakudo-moar 9e8ecb: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "/" in expression "499999999999999999999999999999999999999/99999999999999997748809823456034029568" in sink context (line 1)␤»

[22:46] <gfldex> atweiden-air: you are not doing anything with the role parameters, so there is no reason to keep them around

[22:46] <lizmat> m: say 499999999999999999999999999999999999999/99999999999999997748809823456034029568  # indeed

[22:46] <camelia> rakudo-moar 9e8ecb: OUTPUT: «5␤»

[22:47] <IOninja> TimToady: why is it bad that FatRat is infectious? So is Num. Seems making a FatRat when we can't fit stuff into a Rat is a DWIM.

[22:47] <gfldex> atweiden-air: there is no way to do that because roles don't exist at runtime and a slurpy is a runtime construct

[22:48] <gfldex> atweiden-air: anything you think is a role at runtime is actually a class of the same name that remebers that it's a autopunned role

[22:48] <gfldex> atweiden-air: and classes don't exist at runtime either

[22:48] <gfldex> atweiden-air: and yes, that makes sense :)

[22:48] <IOninja> TimToady mentioned returning a RatStr for such Rats; I'm a bit fuzzy on how that's meant to work. Is that like a non-infectious FatRat?

[22:50] *** kurahaupo joined
[22:50] <IOninja> Oh, OK, I think I get why infectious FatRats are bad. You basically have this giant thing when you probably don't care about all of that precision in most cases.

[22:52] * IOninja will give returning a RatStr idea a go sometime in next few days

[22:52] <timotimo> wow, holy jesus

[22:52] <IOninja> ?

[22:52] <timotimo> https://www.tbray.org/ongoing/When/201x/2014/03/05/RFC7159-JSON - there's details here that i had never heard of

[22:53] <IOninja> heh

[22:54] <IOninja> u lie. I recall pointing out the RFC in the Issue about failing to parse non-objects in top level

[22:54] <timotimo> yeah, but i didn't realize the ecma one was rushed out because of panic and such

[22:54] <timotimo> i knew of the rfc

[22:54] <IOninja> Ah

[22:54] <timotimo> i just assumed "because ecma standardises javascript, they are the authority on Json, too"

[22:56] <timotimo> we might want to put tests into our json modules that handle what happens when an "object" has multiple entries for the same keys

[22:58] <timotimo> oh

[22:58] <timotimo> ... normalization for keys ...

[23:01] *** mcmillhj joined
[23:03] *** kurahaupo left
[23:03] *** kurahaupo joined
[23:04] *** Ven left
[23:05] *** cale2 left
[23:06] *** mcmillhj left
[23:09] *** atweiden-air left
[23:12] *** wamba left
[23:13] *** llfourn joined
[23:14] <Geth> ¦ doc: 9403489786 | (Wenzel P. P. Peppmeyer)++ | doc/Language/typesystem.pod6

[23:14] <Geth> ¦ doc: Even if the heading says "class" it's not about classes but about the

[23:14] <Geth> ¦ doc: 

[23:14] <Geth> ¦ doc: these are the Perl 6 docs, not a CS text book.

[23:14] <Geth> ¦ doc: 

[23:14] <Geth> ¦ doc: This is my first shot at explaining what the declarator actually does.

[23:14] <Geth> ¦ doc: I'm not overly happy with the wording, improvements are welcome.

[23:14] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9403489786

[23:15] <gfldex> IOninja: seams like Geth did something odd to the commit message above

[23:16] <timotimo> "but about the"?

[23:16] <timotimo> it didn't do something odd

[23:17] <timotimo> you're just not supposed to have a multi-line first-line :)

[23:17] *** bolo58249 left
[23:18] *** llfourn left
[23:20] <gfldex> but but but long text is long!

[23:22] *** Geth left
[23:22] *** Geth joined
[23:22] *** ChanServ sets mode: +v Geth

[23:22] <Geth> ¦ doc: 9403489786 | (Wenzel P. P. Peppmeyer)++ | doc/Language/typesystem.pod6

[23:22] <Geth> ¦ doc: Even if the heading says "class" it's not about classes but about the

[23:22] <Geth> ¦ doc: 

[23:22] <Geth> ¦ doc: type declarator called class, hence the heading right above it. Also,

[23:22] <Geth> ¦ doc: these are the Perl 6 docs, not a CS text book.

[23:22] <Geth> ¦ doc: 

[23:22] <Geth> ¦ doc: This is my first shot at explaining what the declarator actually does.

[23:22] <Geth> ¦ doc: I'm not overly happy with the wording, improvements are welcome.

[23:22] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9403489786

[23:23] <IOninja> gfldex: Thanks. Fixed.

[23:23] *** itaipu left
[23:26] *** itcharlie left
[23:29] *** bwisti left
[23:30] *** rurban1 joined
[23:32] *** rurban left
[23:38] *** lep_ joined
[23:39] *** lep-delete left
[23:40] *** skids joined
[23:40] *** itaipu joined
[23:40] *** bwisti joined
[23:45] *** risou_awy is now known as risou

[23:46] *** Actualeyes left
[23:48] *** cdg joined
[23:53] *** cibs left
[23:54] *** travis-ci joined
[23:54] <travis-ci> Doc build errored. Cale 'change return-ifs to switch'

[23:54] <travis-ci> https://travis-ci.org/perl6/doc/builds/204737635 https://github.com/perl6/doc/commit/d399c960e25a

[23:54] *** travis-ci left
[23:54] *** cibs joined
