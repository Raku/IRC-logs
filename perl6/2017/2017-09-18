[00:00] <geekosaur> suppose it doesn;t atter that much given we want a file on /dev/null anyway

[00:00] <geekosaur> also it just occurred to me this may not be very windows portable (although I'm not sure how much so ncurses itself is)

[00:01] <azawawi> windows and ncurses... never heard of it

[00:03] <geekosaur> there is definitely a port. I'm not sure how well (or even if)  it handles newterm

[00:04] <azawawi> PDCurses?

[00:04] <geekosaur> on all versions of windows before the win10 'creators update', ansi escapes are not enough, you have to make device control calls

[00:05] *** Cabanossi left
[00:06] <azawawi> http://invisible-island.net/ncurses/ncurses.faq.html#setvbuf_once # interesting

[00:07] *** Cabanossi joined
[00:07] <geekosaur> the buffering issue here is the one with perl 6 filehandles, not C. unless moarvm (or libuv?) is failing to atexit()

[00:08] <geekosaur> however this specific issue is that, when the ncurses tests are run under prove, it outputs terminal control sequences that prove chokes on

[00:09] <geekosaur> and the buffering issue obscured that because they weren't being output

[00:09] *** headcase joined
[00:09] <geekosaur> except... it's C buffering, not perl's. so now I am confused.

[00:10] *** kerframil joined
[00:10] <azawawi> im even more confused :)

[00:11] <azawawi> AlexDaniel: just testing it again on a perl6 alpine docker and it is working on latest and 2017.07

[00:11] <azawawi> s/testing/tested/

[00:11] * azawawi sleepy :)

[00:12] <AlexDaniel> azawawi: it will work on all releases

[00:12] <AlexDaniel> it didn't work between 2017.08 and 2017.09 :)

[00:13] <AlexDaniel> *somewhere* between :)

[00:13] <azawawi> :)

[00:13] *** headcase left
[00:13] * azawawi off to sleep :)

[00:14] <AlexDaniel> well, between 4b02b8aad and 9073a4dc7

[00:14] *** azawawi left
[00:16] *** audiatorix joined
[00:17] <audiatorix> Is there any way to see how many items are left in a Channel without dequeueing them? Is a Channel even the correct thing to be using (I want a thread-safe queue, and a channel is described as that)

[00:18] <AlexDaniel> audiatorix: why do you want to know how many items are there?

[00:20] *** nattefrost left
[00:20] <audiatorix> I am implementing a logging system, and I'd like to (but don't have to, if it's really too much trouble) report how many lines are left after reading some of it

[00:20] *** headcase joined
[00:28] *** headcase left
[00:33] *** headcase joined
[00:34] <AlexDaniel> audiatorix: makes sense

[00:35] <AlexDaniel> audiatorix: maybe you can wrap a Channel into your own class, and use atomic ints to track the number of elements

[00:36] *** Cabanossi left
[00:37] *** Cabanossi joined
[00:37] *** margeas left
[00:38] *** headcase left
[00:39] *** audiatorix left
[00:45] *** headcase joined
[00:49] *** headcase left
[00:54] *** TimToady left
[00:56] *** TimToady joined
[01:06] *** Cabanossi left
[01:07] *** Cabanossi joined
[01:21] *** HoboWithAShotgun left
[01:26] *** headcase joined
[01:27] *** Ven`` joined
[01:35] *** headcase_ joined
[01:36] *** Ven`` left
[01:38] *** headcase left
[01:39] *** headcase_ left
[01:41] *** headcase joined
[01:42] *** uruwi joined
[01:42] <uruwi> hello

[01:43] <uruwi> I need help – how do I create a regex dynamically?

[01:43] <skids> From a string?

[01:43] <uruwi> I want to divide a string into parts that are from a user-provided set of strings

[01:44] <skids> Are the user strings rx or just patterns?

[01:44] <uruwi> e. g. "si^ul" -> ["s", "i^u", "l"] given that the user specified that all three of those strings were in the alphabet

[01:44] <AlexDaniel> what about / @alphabet / ?

[01:45] <skids> It's just an array interpolation.

[01:45] <AlexDaniel> yes, but why is that not enough?

[01:45] <uruwi> Nope, that's not enough

[01:45] <uruwi> p6: my @a = ["hi", "people"]; say /@a/

[01:45] <camelia> rakudo-moar ce12e4: OUTPUT: «/@a/␤»

[01:46] *** ilbot3 left
[01:46] <uruwi> p6: my @a = ["hi", "people"]; say "hi" ~~ /@a/

[01:46] <camelia> rakudo-moar ce12e4: OUTPUT: «｢hi｣␤»

[01:46] <uruwi> oh wait

[01:46] <uruwi> what

[01:46] <uruwi> p6: sub f { my @a = ["hi", "people"]; return /@a/ }; "hi" ~~ f

[01:46] <camelia> rakudo-moar ce12e4: ( no output )

[01:46] <uruwi> p6: sub f { my @a = ["hi", "people"]; return /@a/ }; say "hi" ~~ f

[01:46] <camelia> rakudo-moar ce12e4: OUTPUT: «｢hi｣␤»

[01:46] <uruwi> p6: sub f { my @a = ["hi", "people"]; return /@a/ }; say "hipeoplehi".comb(f)

[01:46] <camelia> rakudo-moar ce12e4: OUTPUT: «(hi people hi)␤»

[01:47] <uruwi> p6: sub f { my @a = ["hi", "people"]; return /@a/ }; if True {say "hipeoplehi".comb(f) }

[01:47] <camelia> rakudo-moar ce12e4: OUTPUT: «(hi people hi)␤»

[01:47] <uruwi> p6: sub f { my @a = ["hi", "people"]; return /@a/ }; sub g { say "hipeoplehi".comb(f) }; g

[01:47] <camelia> rakudo-moar ce12e4: OUTPUT: «(hi people hi)␤»

[01:48] <uruwi> okay I think I fixed it

[01:48] <uruwi> thanks anyway!

[01:49] <AlexDaniel> :)

[01:49] *** zakharyas joined
[01:49] <MasterDuke> uruwi: if you need more complicated regex interpolation, you can use <{...code...}> and the result of running the code is interpolated into the regex

[01:50] *** Cabanossi left
[01:50] <AlexDaniel> MasterDuke: are you sure that it's the right description?

[01:51] <AlexDaniel> from that block right there you return a Str I think

[01:51] <AlexDaniel> and then the Str is EVALed

[01:51] <AlexDaniel> inside an anonymous regex

[01:51] <AlexDaniel> that's how I understand it… I may be wrong

[01:51] <AlexDaniel> so technically it's useless

[01:52] <AlexDaniel> because you probably return a Str with some arbitrary data which is then EVAL-ed

[01:52] <AlexDaniel> or am I wrong?

[01:52] <MasterDuke> yeah, that's probably more correct, but the simple use case i think works like i said

[01:52] *** Cabanossi joined
[01:53] <AlexDaniel> well… works except when it doesn't :)

[01:53] <MasterDuke> m: say "a1b2c3" ~~ /a <{"hobo".chars - "hob".chars}> b/

[01:53] <camelia> rakudo-moar ce12e4: OUTPUT: «｢a1b｣␤»

[01:53] <AlexDaniel> m: say "a1b2c3" ~~ /a <("hobo".chars - "hob".chars)> b/

[01:53] <camelia> rakudo-moar ce12e4: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at <tmp>:1␤------> 3say "a1b2c3" ~~ /a <("hobo".chars7⏏5 - "hob".chars)> b/␤Unable to parse regex; couldn't find final '/'␤at <tmp>:1␤------> 3sa…»

[01:54] <AlexDaniel> m: say "a1b2c3" ~~ /a $("hobo".chars - "hob".chars) b/

[01:54] <camelia> rakudo-moar ce12e4: OUTPUT: «｢a1b｣␤»

[01:54] <AlexDaniel> look! No EVAL and still works

[01:54] *** ilbot3 joined
[01:54] *** ChanServ sets mode: +v ilbot3

[01:54] *** headcase left
[01:55] <skids> There are some security restrictions on it, so you cannot run more closures or jump parsing.  See S05-interpolation/regex-in-variable.t

[01:55] <uruwi> is there a simple way to lexicographically compare two lists?

[01:55] <uruwi> I could write it myself, but I don't want to write something complicated when there's a simpler way

[01:56] <AlexDaniel> skids: I'm not saying that it's insecure, I'm saying that it simply doesn't work due to syntax errors in EVAL-ed code :)

[01:57] <AlexDaniel> uruwi: hmmm what about ~~ ?

[01:57] <AlexDaniel> m: say (‘foo’, ‘bar’) ~~ (‘foo’, ‘bar’)

[01:57] <camelia> rakudo-moar ce12e4: OUTPUT: «True␤»

[01:57] <AlexDaniel> m: say (‘foo’, ‘bar’) ~~ (‘foo’, ‘beer’)

[01:57] <camelia> rakudo-moar ce12e4: OUTPUT: «False␤»

[01:57] <uruwi> I mean less/equal/greater.

[01:59] *** headcase joined
[02:00] <AlexDaniel> m: say (‘foo’, ‘bar’) cmp (‘foo’, ‘bar’) # any ideas on what this does?

[02:00] <camelia> rakudo-moar ce12e4: OUTPUT: «Same␤»

[02:01] <uruwi> m: say (1, 2, 3) cmp (3, 2, 1)

[02:01] <camelia> rakudo-moar ce12e4: OUTPUT: «Less␤»

[02:02] <uruwi> oh thanks

[02:02] <AlexDaniel> m: say (4, 3) cmp (3, 2, 1)

[02:02] <camelia> rakudo-moar ce12e4: OUTPUT: «More␤»

[02:02] <uruwi> I didn't know that cmp could be used on lists

[02:03] <AlexDaniel> I still don't quite understand how it works

[02:04] <AlexDaniel> does it fall back to a.Stringy cmp b.Stringy ?

[02:04] *** noganex_ joined
[02:04] <AlexDaniel> uruwi: I don't think it does what you want

[02:04] <skids> multi sub infix:<cmp>(@a, @b) { (@a Zcmp @b).first(&prefix:<?>) || @a <=> @b }

[02:05] <uruwi> hmm

[02:06] *** noganex left
[02:09] *** headcase_ joined
[02:12] *** wamba left
[02:12] *** headcase left
[02:13] *** _28_ria left
[02:17] *** _28_ria joined
[02:22] *** headcase joined
[02:23] *** ipatrol joined
[02:25] *** headcase_ left
[02:36] *** Cabanossi left
[02:37] *** marciogm left
[02:37] *** Cabanossi joined
[02:39] <Aaronepower> Is there an easy to test Hashs and have the difference printed out.

[02:39] <Aaronepower> ?*

[02:40] <Aaronepower> By test I mean using the `Test` module.

[02:40] *** eliasr left
[02:44] *** pilne left
[02:45] <ipatrol> What is the name for the behavior where sub(object) automatically calls sub.object() ?

[02:45] <ipatrol> *object.sub()

[02:48] *** wamba joined
[02:54] <sjn> ipatrol: are you thinking about perl5's indirect object notation?

[02:55] <ipatrol> no, I'm thinking about how split(pattern, str) calls str.split(pattern)

[02:57] *** mr-foobar left
[02:57] <sjn> oh, it's made into a method call?

[02:58] <ipatrol> appears to be how it works

[02:59] *** uruwi left
[02:59] *** uruwi joined
[03:02] *** uruwi left
[03:06] *** Cabanossi left
[03:07] *** Cabanossi joined
[03:12] *** dj_goku joined
[03:17] *** skids left
[03:19] *** headcase_ joined
[03:22] *** headcase left
[03:29] *** skids joined
[03:33] *** Cabanossi left
[03:34] *** aaa123 joined
[03:35] <aaa123> Can anyone explain to me why this doesn't work with Bailador? https://gist.github.com/anonymous/73417fc11d1e270189a0d24e8c64adeb

[03:35] <aaa123> It used to work

[03:36] *** Cabanossi joined
[03:37] *** u-ou- joined
[03:47] <MasterDuke> aaa123: i don't know Bailador, so probably can't help, but it might be useful to run your script with --ll-exception (so the backtrace shows anything in rakudo's internals)

[03:48] <MasterDuke> and also paste the output of perl6 --version

[03:51] <aaa123> MasterDuke: https://gist.github.com/anonymous/acb00941de0710daf36e2a34b9ad6467

[03:53] *** Khisanth left
[03:59] *** skids left
[03:59] <MasterDuke> hm, i don't know AUTOGEN, and i gotta get some sleep, but your perl6 is some random commit. using rakudobrew? maybe trying upgrading to 2017.09 (just released today) or 2017.08

[04:00] *** headcase_ left
[04:01] *** headcase joined
[04:01] <MasterDuke> sorry i couldn't be more help, you might have better luck earlier in the day tomorrow (a lot of people in the channel are in europe)

[04:02] <aaa123> tyvm

[04:08] *** Khisanth joined
[04:09] *** headcase left
[04:09] *** wamba left
[04:13] *** kannan joined
[04:15] *** kannan left
[04:18] *** headcase joined
[04:22] *** ipatrol left
[04:27] *** headcase left
[04:29] *** headcase joined
[04:34] *** headcase left
[04:34] *** Cabanossi left
[04:36] *** Cabanossi joined
[04:36] *** u-ou- left
[04:41] *** u-ou- joined
[04:44] *** aborazmeh joined
[04:44] *** aborazmeh left
[04:44] *** aborazmeh joined
[04:56] *** HoboWithAShotgun joined
[04:58] <teatime> oh nice, release day

[04:59] *** u-ou- left
[05:04] <AlexDaniel> teatime: I didn't sleep yet, but mostly it was yesterday :)

[05:04] *** u-ou- joined
[05:05] <AlexDaniel> good ** everyone o/

[05:09] *** AlexDaniel left
[05:10] *** kyan left
[05:10] <moritz> \o *

[05:11] <u-ou-> greet $_ for @channel;

[05:25] *** headcase joined
[05:25] *** u-ou- left
[05:28] <aaa123> https://gist.github.com/anonymous/73417fc11d1e270189a0d24e8c64adeb

[05:28] <aaa123> Still having this problem

[05:28] <aaa123> updated my perl6 too

[05:33] *** headcase left
[05:37] *** nadim joined
[05:37] *** xtreak joined
[05:46] *** kerframil left
[05:49] *** headcase joined
[05:49] *** knobo joined
[05:50] *** Justchecking joined
[05:51] *** u-ou- joined
[05:53] *** bwisti joined
[05:53] *** WhiskyRyan joined
[05:54] *** headcase left
[05:54] *** WhiskyRyan left
[05:55] *** Justchecking left
[05:56] *** headcase joined
[06:02] *** khw left
[06:04] *** Cabanossi left
[06:05] *** headcase left
[06:05] *** u-ou- left
[06:06] *** Cabanossi joined
[06:07] *** u-ou- joined
[06:09] *** headcase joined
[06:10] *** domidumont joined
[06:18] *** headcase left
[06:26] *** headcase joined
[06:30] *** cuonglm joined
[06:35] *** headcase left
[06:35] *** aborazmeh left
[06:37] *** u-ou- left
[06:38] *** u-ou- joined
[06:43] *** HoboWithAShotgun left
[06:44] *** domidumont left
[06:54] *** headcase joined
[06:58] *** u-ou- left
[06:58] *** headcase left
[07:00] *** wamba joined
[07:02] *** pecastro left
[07:04] *** aaa123 left
[07:05] *** headcase joined
[07:05] *** jonas1 joined
[07:07] *** u-ou- joined
[07:09] *** headcase left
[07:12] *** LanceW joined
[07:14] *** headcase joined
[07:14] *** cgfbee joined
[07:18] *** u-ou- left
[07:18] *** headcase left
[07:19] *** headcase joined
[07:23] *** headcase left
[07:24] *** pecastro joined
[07:25] *** u-ou- joined
[07:32] *** headcase joined
[07:34] *** headcase_ joined
[07:37] *** headcase left
[07:38] *** headcase_ left
[07:38] *** headcase joined
[07:39] *** u-ou- left
[07:40] *** headcase left
[07:46] *** jcallen left
[07:46] *** jcallen joined
[07:48] *** kaare__ left
[07:50] *** Cabanossi left
[07:51] *** chens joined
[07:51] *** Cabanossi joined
[07:53] *** knobo left
[07:56] *** _28_ria left
[07:58] *** LanceW left
[08:01] *** headcase joined
[08:04] *** dakkar joined
[08:05] *** headcase left
[08:06] *** sproctor joined
[08:06] *** xtreak left
[08:07] *** xtreak joined
[08:08] *** mtj_ left
[08:11] *** xtreak left
[08:12] *** okl joined
[08:14] *** nattefrost joined
[08:15] *** rindolf joined
[08:19] <gfldex> jnthn++ # for having a plan to optimise all the things

[08:21] *** headcase joined
[08:25] *** headcase left
[08:25] *** virtualsue joined
[08:25] *** robertle joined
[08:26] *** chens left
[08:31] *** LanceW joined
[08:31] *** okl left
[08:31] *** headcase joined
[08:32] *** xtreak joined
[08:35] *** Cabanossi left
[08:35] *** headcase left
[08:36] *** headcase joined
[08:36] *** Cabanossi joined
[08:40] *** headcase left
[08:41] *** headcase joined
[08:42] *** knobo joined
[08:45] *** mtj_ joined
[08:45] *** headcase left
[08:47] *** piojo joined
[08:51] *** headcase joined
[08:51] *** piojo is now known as piojo_

[08:52] *** piojo_ is now known as piojo

[08:55] *** _28_ria joined
[08:55] *** headcase left
[08:56] <piojo> Is there a perl6 framework/plugin that's well-suited to provide a REST api but not web pages?

[08:59] <jnthn> It's still a fairly young project, but http://cro.services/ was designed for building services primarily.

[09:00] <piojo> I'm wondering whether perl6 would be a reasonable choice for a game server--single player, it'll mostly just track player data, but there will be some complex algorithms where using a nice programming language would be beneficial

[09:00] <jnthn> Supports JSON message body parsing/serialization out of the box, tries to make it easy to give correct HTTP error codes, etc.

[09:00] <piojo> jnthn: thanks, I'll have a look at cro

[09:00] *** LanceW left
[09:01] *** headcase joined
[09:10] *** headcase left
[09:11] *** darutoko joined
[09:14] *** _28_ria left
[09:20] *** zakharyas left
[09:20] *** zakharyas joined
[09:25] *** zakharyas left
[09:27] *** llfourn left
[09:31] *** headcase joined
[09:34] *** Cabanossi left
[09:35] *** headcase left
[09:36] *** Cabanossi joined
[09:36] *** headcase joined
[09:38] *** kaare__ joined
[09:38] *** xtreak left
[09:38] *** xtreak joined
[09:40] *** ChoHag joined
[09:41] *** headcase left
[09:43] *** xtreak left
[09:44] *** headcase joined
[09:49] *** headcase left
[09:51] *** knobo left
[09:54] *** headcase joined
[09:56] *** konsolebox left
[09:57] *** margeas joined
[09:58] *** headcase left
[09:59] *** headcase joined
[10:02] *** wamba left
[10:02] *** konsolebox joined
[10:03] *** headcase left
[10:10] *** headcase joined
[10:12] *** xtreak joined
[10:14] *** headcase left
[10:23] *** piojo left
[10:27] *** perlawhirl joined
[10:32] <Zoffix> weird. GitHub no longer highlights ```perl6 code blocks at all? https://github.com/perl6/roast/pull/324#issuecomment-330181835

[10:32] *** TEttinger left
[10:33] *** Cabanossi left
[10:34] *** headcase joined
[10:36] *** Cabanossi joined
[10:37] *** xui_nya[m] left
[10:37] *** Matthew[m] left
[10:37] *** peteretep joined
[10:38] <peteretep> Hi

[10:38] <peteretep> I have perl6.guru, perl6.guide, and perl6.io available to good homes

[10:38] <peteretep> (for free, obv)

[10:38] <lizmat> peteretep: argh, should have answered you sooner

[10:38] <lizmat> :-)

[10:39] <peteretep> lizmat: You still get first dibs on them, I'm sure :)

[10:39] <lizmat> I'll take them

[10:39] *** headcase left
[10:39] <peteretep> k. /me looks into how to do the transfer

[10:39] *** levex left
[10:40] *** xui_nya[m] joined
[10:40] <peteretep> I think you need to request from your existing host, and then I need to give you the codes

[10:40] <peteretep> s/host/registrar/

[10:41] <lizmat> well, I don't have a registrar for those domains, afaik

[10:41] <lizmat> TLD's I meabn

[10:41] <lizmat> *mean  (sigh)

[10:41] *** Matthew[m] joined
[10:41] *** knobo joined
[10:42] *** cuonglm left
[10:42] <peteretep> Who did you register dijkmat.nl with?

[10:42] <lizmat> the only one possible: sidn.nl

[10:42] <peteretep> ah

[10:42] <lizmat> but they don't do .guru, .guide, .io afaik

[10:42] <peteretep> If you create an account at Gandi.net, they can be transferred to you there

[10:42] <lizmat> ok, Gandi I'm on

[10:42] <peteretep> Highly recommend gandi.net

[10:43] <lizmat> yeah, use that for almost all of our other domains

[10:43] <lizmat> k, lemme look into that

[10:43] <lizmat> am about to be less available in the coming hours because of $work, and then the P6W, so maybe tomorrow, ok?

[10:45] *** Levex joined
[10:46] *** Levex is now known as Guest80729

[10:46] <peteretep> for sure, no rush

[10:51] *** f3ew joined
[10:51] *** cosimo left
[10:52] *** headcase joined
[10:53] <Zoffix> lulz... I made a haiku https://www.reddit.com/r/perl6/comments/70ojde/the_rakudo_book_project/dn5vzn2/

[10:54] * Zoffix would be happier if knew why is everyone so obsessed with haikus

[10:59] *** cosimo joined
[11:00] <jeek> Zoffix needs to chill. Haikus aren't worth the cycles. Go take a nice nap.

[11:05] *** headcase_ joined
[11:05] *** Cabanossi left
[11:06] *** headcase left
[11:06] *** Cabanossi joined
[11:07] *** xtreak left
[11:07] *** xtreak joined
[11:09] *** headcase_ left
[11:09] *** headcase joined
[11:10] <Zoffix> :)

[11:12] *** piojo joined
[11:12] * Zoffix reads haiku wikipedia

[11:13] <Zoffix> ends with 5 or 3 sylables. I don't get how that haiku bot got more than two sylables from "Perl 6"

[11:14] <piojo> perl is a funny word

[11:14] <piojo> it sounds weird if you either try to stick it into one syllable, or if you try to split it into two

[11:15] *** headcase left
[11:16] *** lizmat left
[11:17] *** lizmat joined
[11:19] *** headcase joined
[11:24] *** leont joined
[11:27] *** wamba joined
[11:28] *** headcase left
[11:30] *** cosimo left
[11:31] *** headcase joined
[11:32] *** cosimo joined
[11:32] <perlawhirl> Zoffix: perl-6-smi-ley-face ?

[11:33] <Zoffix> Ahhh

[11:33] <perlawhirl> i'm guessing... i dunno how that bot counts syllables.

[11:34] * perlawhirl wonders if WordNet DB has a syllable count

[11:39] *** xtreak left
[11:40] *** xtreak joined
[11:40] *** headcase left
[11:41] *** headcase joined
[11:42] *** xtreak left
[11:43] *** xtreak joined
[11:45] *** headcase left
[11:49] *** wamba left
[11:52] *** ShalokShalom_ joined
[11:54] *** ShalokShalom left
[12:00] *** AlexDaniel joined
[12:01] *** headcase joined
[12:03] *** Zoffix left
[12:03] *** Zoffix joined
[12:04] *** buggable left
[12:10] *** headcase left
[12:10] *** headcase joined
[12:13] <Aaronepower> When writing tests what is the best way for comparing hashs and printing what was different from the expected hash from the actual hash?

[12:14] <Zoffix> is-deeply() will test it, but as for printing exactly what was different… I'm not aware if we have such a module yet

[12:15] *** headcase left
[12:17] *** konsolebox left
[12:25] *** perlpilot joined
[12:25] *** konsolebox joined
[12:25] <Aaronepower> Zoffix: Thanks

[12:25] *** HoboWithAShotgun joined
[12:28] <Aaronepower> Zoffix: I'm trying to make a function that prints the diff, but I'm getting a "Cannot convert string to number" error on the if statement. https://paste.rs/7qN

[12:30] <Zoffix> Aaronepower: == and != are numeric operators. Did you mean eq to compare strings?

[12:31] *** headcase joined
[12:31] <weabot> or ~~ for some black magic to happen that'll probably give you the comparison you want

[12:32] *** buggable joined
[12:32] *** ChanServ sets mode: +v buggable

[12:33] <Zoffix> It won't necessarily be the comparison you want. "foo" ~~ Str would give True, even though the values differ

[12:33] *** buggable left
[12:34] <Aaronepower> Zoffix: Well why does `'10' == 5` not cause an error? I just want to compare the two variables if one is string and one is number it is just false.

[12:34] <Zoffix> Aaronepower: because '10' gets converted to a number, but not all strings can be converted to numbers, hence the error you're getting

[12:35] <leont> the == operator numifies

[12:35] <Zoffix> Aaronepower: `eqv` op is a fair shot for what you want. Though even it won't compare everything (e.g. lazy lists cause it to throw0

[12:35] *** headcase left
[12:36] * Zoffix &

[12:39] *** xtreak left
[12:41] *** headcase joined
[12:43] *** xtreak joined
[12:43] *** xtreak left
[12:46] *** headcase left
[12:50] *** Cabanossi left
[12:50] *** yadzi joined
[12:51] *** headcase joined
[12:51] *** Cabanossi joined
[12:51] *** headcase_ joined
[12:54] *** albongo left
[12:55] *** headcase left
[12:59] *** ShalokShalom_ is now known as ShalokShalom

[13:01] *** headcase_ left
[13:02] *** mcmillhj joined
[13:05] *** headcase joined
[13:08] *** wamba joined
[13:10] *** headcase left
[13:11] *** buggable joined
[13:11] *** buggable left
[13:12] *** headcase joined
[13:16] *** headcase left
[13:18] *** headcase joined
[13:20] *** buggable joined
[13:20] *** headcase left
[13:21] *** headcase joined
[13:23] *** buggable left
[13:25] <wictory[m]> Is it possible to compile a perl6 program into a .moarvm to speed up start time?

[13:26] <Zoffix> wictory[m]: not at the moment. Though modules are already pre-compiled, so just shove everything into a module

[13:26] <moritz> wictory[m]: my last info on that was that you can only precompile modules

[13:26] <moritz> so if you change the main script to   use TheModule; TheModule::run() or so, you nearly have the same benefits

[13:27] <jnthn> And you can put a MAIN into a module and export it too

[13:28] *** mcmillhj left
[13:28] <wictory[m]> 👍 I will check it out, thanks!

[13:28] *** mcmillhj joined
[13:30] *** headcase left
[13:42] *** gregf_ left
[13:43] *** pecastro left
[13:43] *** mcmillhj left
[13:44] *** mcmillhj joined
[13:48] <timotimo> http://input.fontbureau.com/info/ - this seems nice

[13:49] *** bwisti left
[13:50] *** headcase joined
[13:51] *** headcase left
[13:52] <Zoffix> .oO( surely misaligned lines being harder to read aren't a worthy tradeoff for spotting typos in repeated duplicate lines of data)

[13:54] *** okl joined
[13:58] *** okl left
[14:01] <jast> Input has proportional and monospace variants, so you can choose

[14:02] <timotimo> Zoffix: don't really have an opinion on that suggestion

[14:02] <timotimo> https://github.com/Bailador/Bailador/pull/264 - btw

[14:04] <Aaronepower> What is the difference between these two? https://paste.rs/LKb

[14:05] *** Cabanossi left
[14:06] <Zoffix> Yeah, I saw it has monospace, but the example about spotting typos is so ridiculously convoluted

[14:06] *** Cabanossi joined
[14:08] <perlpilot> Aaronepower: the expected thingy looks like a Hash, the got thing looks like a List to me.

[14:08] <Zoffix> Aaronepower: looks like one is an object hash and the other is a scalarized list of pairs

[14:09] <Zoffix> m: my %h := :{ :amount(71.0328), :items("grated parmesan"), :unit("ml") }; dd %h

[14:09] <camelia> rakudo-moar 9190a3: OUTPUT: «:{:amount(71.0328), :items("grated parmesan"), :unit("ml")}␤»

[14:09] <Zoffix> m: my %h := :{ :amount(71.0328), :items("grated parmesan"), :unit("ml") }; dd $(%h.List)

[14:09] <camelia> rakudo-moar 9190a3: OUTPUT: «$(:items("grated parmesan"), :amount(71.0328), :unit("ml"))␤»

[14:09] <Zoffix> yup

[14:09] <Aaronepower> Zoffix: How do I make the second a Hash? `.Hash` doesn't seem to work.

[14:10] <perlpilot> m: dd $(:items("grated parmesan"), :amount(71.0328), :unit("ml")).hash

[14:10] <camelia> rakudo-moar 9190a3: OUTPUT: «Hash % = {:amount(71.0328), :items("grated parmesan"), :unit("ml")}␤»

[14:11] <Zoffix> m: my %h := :{ :amount(71.0328), :items("grated parmesan"), :unit("ml") }; dd Hash[Mu,Any].new: |$(%h.List)

[14:11] <camelia> rakudo-moar 9190a3: OUTPUT: «:{:amount(71.0328), :items("grated parmesan"), :unit("ml")}␤»

[14:11] *** pecastro joined
[14:12] <Zoffix> m: my %h := :{ :amount(71.0328), :items("grated parmesan"), :unit("ml") }; dd Hash[Mu,Any].new: $(%h.List)<>

[14:12] <camelia> rakudo-moar 9190a3: OUTPUT: «:{:amount(71.0328), :items("grated parmesan"), :unit("ml")}␤»

[14:13] <Zoffix> (first version slips it in, the second one just deconts)

[14:14] <Aaronepower> m: :{ hello => 'world' }

[14:14] <camelia> rakudo-moar 9190a3: ( no output )

[14:14] <Aaronepower> m: my $m = :{ hello => 'world' }; $m

[14:14] <camelia> rakudo-moar 9190a3: OUTPUT: «WARNINGS for <tmp>:␤Useless use of $m in sink context (line 1)␤»

[14:15] <Aaronepower> m: my $m = :{ hello => 'world' }; $m.say;

[14:15] <camelia> rakudo-moar 9190a3: OUTPUT: «{hello => world}␤»

[14:15] *** nattefrost left
[14:16] <Aaronepower> Zoffix: What is the difference between `${}` and `:{}`?

[14:16] <Zoffix> Aaronepower: ${} where?

[14:17] <Zoffix> :{} is an object Hash, ${} is a regular one in scalar container

[14:17] *** albongo joined
[14:17] <Aaronepower> Zoffix: https://paste.rs/SVu

[14:17] <Zoffix> Aaronepower: yeah, what I said above

[14:18] <Aaronepower> Zoffix: I don't understand the difference, and how do I convert?

[14:18] <Zoffix> hm, looks like object hashes don't show their containerization

[14:19] <Zoffix> m: my %h := :{:42a}; my $h = %h; dd %h; dd $h

[14:19] <camelia> rakudo-moar 9190a3: OUTPUT: «:{:a(42)}␤Hash[Mu,Any] $h = :{:a(42)}␤»

[14:19] <Zoffix> m: my %h := :{:42a}; my $h = %h; dd %h.perl; dd $h.perl

[14:19] <camelia> rakudo-moar 9190a3: OUTPUT: «":\{:a(42)}"␤":\{:a(42)}"␤»

[14:19] <Zoffix> m: my %h := Hash[Int,Str].new: "a" => 42; my $h = %h; dd %h.perl; dd $h.perl

[14:19] <camelia> rakudo-moar 9190a3: OUTPUT: «"(my Int \%\{Str} = :a(42))"␤"(my Int \%\{Str} = :a(42))"␤»

[14:20] <Zoffix> Aaronepower: normal Hashes have Str as keys and Mu as values. You can change those defaults and use an "object hash". So, for example, you could have Mu as keys and only Ints as values

[14:21] <Aaronepower> Zoffix: Everything I'm using is a normal hash. I never intentionally tried to make it something else.

[14:21] <Zoffix> Aaronepower: and hashes are Iterable, if you write `for %some-hash { .say }` it'll iterate over its pairs, but if you shove it into a scalar container, it'll be thought of as a single item and `for $some-hash { .say }` in that case will iterate over just the hash itself 

[14:22] <Zoffix> Aaronepower: well, above you're writing  :{ } which creates an object hash. Did you mean to use { }?

[14:23] *** headcase joined
[14:23] *** albongo left
[14:24] <Aaronepower> Zoffix: Apparently. Thanks!

[14:29] *** headcase left
[14:33] *** HoboWithAShotgun left
[14:35] *** Cabanossi left
[14:36] *** headcase joined
[14:36] *** Cabanossi joined
[14:40] *** headcase left
[14:45] *** erratum joined
[14:46] *** Guest80729 is now known as levex

[14:46] *** levex left
[14:46] *** levex joined
[14:48] *** skids joined
[14:49] *** khw joined
[14:51] *** Celelibi left
[14:51] <robertle> is there a way to use one regex in another? I want  something like my $expr1 = /'ofen'|'rohr'/; $input ~~ /$expr1 | $expr2 / , basically the ability to reuse configurable sub-expressing in my matchers. note that the sub-expression has "|" in it, I can of course reuse literal matches easily...

[14:51] *** st_elmo joined
[14:52] <timotimo> robertle: you may want to try protoregexes?

[14:52] <jnthn> Easiest way from where you are now: /<$expr1> | <$expr2>/

[14:52] *** headcase joined
[14:53] <jnthn> But if you regex expr1 { ofen|rohr }; ... /<&expr1> | <&expr2>/ it'll perform better

[14:54] *** HoboWithAShotgun joined
[14:55] <robertle> eh, that is quite cool! thanks!

[14:55] <robertle> need to understand what < and > really do in a regex though, apparently my view was a bit simplisitc...

[14:56] <skids> They pop you into the "extensible regex" syntax.

[14:57] <skids> So... they do lots of things.

[14:57] *** headcase left
[14:58] <jnthn> You can tell what by the char immediately after the < though :)

[14:59] *** headcase joined
[15:05] *** Cabanossi left
[15:06] <robertle> hmm, that seems to work with scalar variables as in m/<$test>/, but not if it's e.g. a hash lookup m/$test{$key}/, gives Unable to parse expression in metachar:sym<assert>; couldn't find final '>'

[15:06] *** Cabanossi joined
[15:07] <robertle> which isn't really a problem for me, i's probably clearer to put these into well-names variables anyway, but it feels a bit odd

[15:08] *** headcase left
[15:08] <jnthn> You'd have to write it as <{ $test{$key} }> for that to work out

[15:10] <robertle> right!

[15:11] <Aaronepower> In grammar's, is there any way to say that every proto token has to be whole word?

[15:12] <perlpilot> Aaronepower: what do you mean by "whole word"?

[15:13] <perlpilot> Aaronepower: I suppose you could make your proto match  « {*} » if that's what you want.

[15:13] <Aaronepower> perlpilot: As if I have a token that matches 'g' it can't match against 'good'.

[15:13] <Aaronepower> As in if*

[15:14] <Aaronepower> perlpilot: What does that do?

[15:14] *** nadim left
[15:16] <Zoffix> perlpilot: I don't think regexes in protos are implemented yet

[15:16] <perlpilot> oh, could be.

[15:17] <Zoffix> m: say grammar { token TOP { .+? <foo> .+ }; proto token foo { «{*}» }; token foo:sym<meow> { \d+ } }.parse: "a123bc|456|abc"}

[15:17] <camelia> rakudo-moar a845ac: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Proto regex body must be {*} (or <*> or <...>, which are deprecated)␤at <tmp>:1␤------> 3token TOP { .+? <foo> .+ }; proto token 7⏏5foo { «{*}» }; token foo:sym<meow> { \d+␤»

[15:18] <skids> Aaronepower: g<|w> maybe?  Depending on your definition of a "word"

[15:19] <Aaronepower> My solution was to just have group where there has to be whitespace after the proto token. `<foo> [<bar> <.ws>]? <baz>`

[15:20] *** nadim joined
[15:20] <Zoffix> nadim: FWIW DDT was failing install earlier today; something about a missing dep Terminal::Print or something

[15:21] <perlpilot> Aaronepower: If you didn't want to consume the whitespace, you could match a word boundary instead.  I dunno if that's important to you or not.

[15:21] *** buggable joined
[15:21] *** ChanServ sets mode: +v buggable

[15:23] <perlpilot> oh, skids already said that ... I need to stop going back and forth between windows.

[15:23] *** buggable left
[15:23] *** buggable joined
[15:23] *** ChanServ sets mode: +v buggable

[15:23] *** Geth_ left
[15:24] *** Geth_ joined
[15:24] *** ChanServ sets mode: +v Geth_

[15:26] *** Geth_ left
[15:27] *** piojo left
[15:27] *** Geth_ joined
[15:28] *** ChanServ sets mode: +v Geth_

[15:28] *** Geth_ left
[15:28] *** ruoso___ joined
[15:28] *** bdmatatu joined
[15:29] *** Geth_ joined
[15:29] *** ChanServ sets mode: +v Geth_

[15:29] *** cschwenz joined
[15:29] *** Geth_ left
[15:30] *** Geth_ joined
[15:30] *** ChanServ sets mode: +v Geth_

[15:31] *** HoboWithAShotgun left
[15:32] *** knobo left
[15:33] *** headcase joined
[15:36] *** Celelibi joined
[15:37] *** nadim left
[15:40] *** llfourn joined
[15:43] *** bdmatatu left
[15:44] *** buggable left
[15:44] *** buggable joined
[15:44] *** ChanServ sets mode: +v buggable

[15:44] *** buggable left
[15:45] <cschwenz> In https://gist.github.com/cschwenz/6edf195c04dde8e067c6985527e6e7d9 , why do the first and third regex work but the second and fourth regex fail to match?  The only difference between the first and second regex is the inclusion of capturing parens (and likewise for the third and fourth regex).

[15:50] *** buggable joined
[15:50] *** ChanServ sets mode: +v buggable

[15:50] *** buggable left
[15:51] *** buggable joined
[15:51] *** ChanServ sets mode: +v buggable

[15:51] *** albongo joined
[15:56] <Zoffix> cschwenz: weird :/

[15:56] <cschwenz> yeah!  :-(

[15:56] *** Xliff left
[15:56] <cschwenz> i am at a complete loss as to why i'm getting the results i am.

[15:57] <Zoffix> Perhaps a bug that has to do with accessing a capture from whithin a capture. If I change [ $1 ] to [ '1234567' ] both regexes match

[15:57] *** Xliff joined
[15:58] <Zoffix> Yup

[15:58] <Zoffix> m: say "11" ~~ /(\d)[$0]/

[15:58] <camelia> rakudo-moar 48a84d: OUTPUT: «｢11｣␤ 0 => ｢1｣␤»

[15:58] <Zoffix> m: say "11" ~~ /(\d)([$0])/

[15:58] <camelia> rakudo-moar 48a84d: OUTPUT: «Nil␤»

[15:58] <Zoffix> bisect: say "11" ~~ /(\d)([$0])/

[15:58] <bisectable6> Zoffix, On both starting points (old=2015.12 new=48a84d6) the exit code is 0 and the output is identical as well

[15:58] <bisectable6> Zoffix, Output on both points: «Nil»

[15:58] * Zoffix files it

[15:58] <cschwenz> Zoffix++ :-)

[15:59] <Zoffix> m: say "11" ~~ /(\d) {} :my $o = $0; ([$o])/

[15:59] <camelia> rakudo-moar 48a84d: OUTPUT: «｢11｣␤ 0 => ｢1｣␤ 1 => ｢1｣␤»

[15:59] <Zoffix> ^ potential workaround

[15:59] <lizmat> http://vienna.pm.org/perl_6_jonathan_grant.html  # whee!

[15:59] <cschwenz> are you okay with me checking that gist test in to the rakudo repo?

[16:01] <Zoffix> cschwenz: perhaps roast is a better location?

[16:01] <Zoffix> github.com/perl6/roast

[16:01] <cschwenz> ah, that would be better

[16:02] <Zoffix> Filed the ticket: https://rt.perl.org/Ticket/Display.html?id=132120

[16:02] <Zoffix> Vienna.pm++

[16:02] <cschwenz> will put that test into roast after i get home.

[16:02] <Zoffix> Thanks

[16:02] <cschwenz> Vienna.pm++  :-D

[16:07] <virtualsue> :-)

[16:08] *** cschwenz left
[16:08] <El_Che> yeah vienna

[16:14] *** darutoko- joined
[16:15] *** robertle left
[16:17] *** darutoko left
[16:27] *** headcase left
[16:28] *** headcase joined
[16:30] <perlpilot> cschwenz: I changed the third grouping in your second if statement to be ( :my $x = $1; [ $x ]**2..* ) and the match succeeds, but the values are off.  Feels like $0 and friends aren't always getting reset properly in the presence of backtracking.

[16:31] *** dakkar left
[16:32] <jnthn> Each (...) is a new Match object, and backreferences are talking about that

[16:33] <jnthn> So in /(\d)([$0])/ that $0 would be talking about a $0 inside of the current (...), not a level up

[16:33] <Zoffix> Oh wow.

[16:33] <perlpilot> er ...

[16:33] *** sproctor left
[16:34] *** headcase left
[16:34] <perlpilot> I guess that's an implication, I never ran across.

[16:34] <jnthn> m: say 'abc' ~~ /(.(.(.)))/

[16:34] <camelia> rakudo-moar 48a84d: OUTPUT: «｢abc｣␤ 0 => ｢abc｣␤  0 => ｢bc｣␤   0 => ｢c｣␤»

[16:34] <jnthn> m: say 'abc' ~~ /(.(.(.)))/.perl

[16:34] <camelia> rakudo-moar 48a84d: OUTPUT: «False␤»

[16:34] <jnthn> d'oh :)

[16:34] *** skids left
[16:34] <jnthn> well, I guess it's sorta clear from the gist

[16:35] <Zoffix> Yeah

[16:35] <jnthn> Just less so when it's not spread over multiple lines to see the indentation.

[16:35] <jnthn> And yeah, this is one of the places "nested matches form a tree" pops up a bit surprisingly

[16:35] <moritz> btw if you have more than one group, it might be time to use named captures

[16:36] *** headcase joined
[16:36] <Zoffix> .tell cschwenz I was wrong, it's not a bug: https://irclog.perlgeek.de/perl6/2017-09-18#i_15181692

[16:36] <yoleaux> Zoffix: I'll pass your message to cschwenz.

[16:37] *** Ven`` joined
[16:37] *** telex left
[16:38] <Zoffix> Is there a way to refer to outer match?

[16:38] *** telex joined
[16:39] <timotimo> if there were more compact syntax for the "outer match object", that'd be nice

[16:39] <timotimo> since you also can't work around it with named captures either

[16:39] <Zoffix> timotimo: what's the less compact way?

[16:39] <jnthn> Zoffix: Not that I know of, though you could assign it into a variable

[16:39] <timotimo> the one already seen

[16:40] <Zoffix> jnthn: thanks

[16:40] *** headcase left
[16:40] <lizmat> m: $/ = 42; { dd OUTER::<$/> }    # less compact way would be OUTER::<$/>[0]

[16:40] <camelia> rakudo-moar 48a84d: OUTPUT: «Int $/ = 42␤»

[16:40] <timotimo> i don't think you can refer to OUTER from within a regex

[16:41] <lizmat> why not?  It's all code, isn't it?  or is there more than one level ?

[16:42] <moritz> I've tried CALLER and CALLERS in regexes, they work there

[16:42] <lizmat> ah, you're saying that a grouping is *not* a new frame ?

[16:42] <jnthn> I think OUTER would work but you'd have to force the updating of $/ first, iirc

[16:43] <lizmat> dinner&

[16:43] <timotimo> m: say "hi hi" ~~ / (\w+) \s ( $OUTER::0 ) /

[16:43] <camelia> rakudo-moar 48a84d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$OUTER' is not declared␤at <tmp>:1␤------> 3say "hi hi" ~~ / (\w+) \s ( 7⏏5$OUTER::0 ) /␤»

[16:44] <timotimo> but how ...

[16:45] *** skids joined
[16:46] <jnthn> m: say "hi hi" ~~ / (\w+) \s ( "$OUTER::<$/>[0]" ) /

[16:46] <camelia> rakudo-moar 48a84d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$OUTER' is not declared␤at <tmp>:1␤------> 3say "hi hi" ~~ / (\w+) \s ( "7⏏5$OUTER::<$/>[0]" ) /␤»

[16:47] <jnthn> m: say "hi hi" ~~ / (\w+) \s ( $(OUTER::<$/>[0]) ) /

[16:47] <camelia> rakudo-moar 48a84d: OUTPUT: «Nil␤»

[16:47] <jnthn> m: say "hi hi" ~~ / (\w+) \s {} ( $(OUTER::<$/>[0]) ) /

[16:47] <camelia> rakudo-moar 48a84d: OUTPUT: «Nil␤»

[16:47] <jnthn> m: say "hi hi" ~~ / (\w+) \s {} ( $(CALLER::<$/>[0]) ) /

[16:47] <camelia> rakudo-moar 48a84d: OUTPUT: «Nil␤»

[16:48] <jnthn> Apparently not like this...

[16:48] <Zoffix> Wouldn't that stuff reference all the things from where the regex is compiled rather than a nested thing/

[16:49] <jnthn> ah, maybe

[16:49] <jnthn> In that it's a thunk

[16:49] <jnthn> Rather than a block

[16:50] <timotimo> and i even forgot to put the {} in there even though you specifically pointed it out

[16:52] *** robertle joined
[16:54] * jnthn away for a bit

[16:55] *** skids left
[16:55] <Geth> ¦ doc: 647b342e4f | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Language/regexes.pod6

[16:55] <Geth> ¦ doc: Show a way to reference a capture from within a capture

[16:55] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/647b342e4f

[16:56] *** avalenn left
[16:57] <timotimo> Zoffix: is it supposed to end in "using var"?

[16:58] <Geth> ¦ doc: f1a329c16a | lefth++ (committed by Zoffix Znet) | doc/Language/regexes.pod6

[16:58] <Geth> ¦ doc: Make the "Regexes" page also searchable as "Regular Expressions". (#1563)

[16:58] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/f1a329c16a

[16:59] <Zoffix> Oh, whoops. That part wasn't supposed to get in at all, but I guess GitHub still keeps your changes after you refresh the page :/

[16:59] * Zoffix deletes

[16:59] *** mr-foobar joined
[16:59] <timotimo> ah

[17:00] <Geth> ¦ doc: 755967d6cf | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Language/regexes.pod6

[17:00] <Geth> ¦ doc: Delete accidentally committed text

[17:00] <Geth> ¦ doc: 

[17:00] <Geth> ¦ doc: This content was moved into a more appropriate section

[17:00] <Geth> ¦ doc: in https://github.com/perl6/doc/commit/647b342e4f

[17:00] <Geth> ¦ doc: and wasn't supposed to be committed

[17:00] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/755967d6cf

[17:02] *** Ven`` left
[17:03] *** Ven`` joined
[17:11] *** wamba left
[17:12] *** Ven`` left
[17:13] *** pyrimidine joined
[17:15] <[Coke]> aaand, I just used $this ~ "that" in a p5 module at work today. blah.

[17:17] *** Skarsnik joined
[17:23] *** travis-ci joined
[17:23] <travis-ci> Doc build passed. lefth 'Make the "Regexes" page also searchable as "Regular Expressions". (#1563)'

[17:23] <travis-ci> https://travis-ci.org/perl6/doc/builds/276942978 https://github.com/perl6/doc/compare/647b342e4fe8...f1a329c16a90

[17:23] *** travis-ci left
[17:24] <sjn> wow, cool that vienna.pm++ is sponsoring jnthn :D

[17:24] *** travis-ci joined
[17:24] <travis-ci> Doc build passed. Zoffix Znet 'Show a way to reference a capture from within a capture'

[17:24] <travis-ci> https://travis-ci.org/perl6/doc/builds/276941990 https://github.com/perl6/doc/compare/7f12deab88ac...647b342e4fe8

[17:24] *** travis-ci left
[17:25] *** nadim joined
[17:25] *** buggable left
[17:26] *** buggable joined
[17:26] *** ChanServ sets mode: +v buggable

[17:27] <Xliff> Yikes! I can understand the reasoning behind "say "11" ~~ /(\d) {} :my $c = $0; ($c)/;", but that syntax is horrendous.

[17:27] <Xliff> It's nice to know how to do that, however.

[17:27] <Xliff> Zoffy++

[17:28] <Xliff> m: say "11" ~~ /(\d) {} :my $c = $0; ($c)/;

[17:28] <camelia> rakudo-moar 476741: OUTPUT: «｢11｣␤ 0 => ｢1｣␤ 1 => ｢1｣␤»

[17:28] <Zoffix> Syntax? It's just a variable assignment :\

[17:28] *** pyrimidine left
[17:29] <Xliff> Yeah, but for some reason my mind wants to put the code inside the brackets.

[17:29] <Xliff> And the :my is throwing me off.

[17:29] *** pyrimidine joined
[17:29] <Xliff> I guess my brain just wants the code to be set off somehow from the rest of the regex.

[17:30] <Zoffix> Code is part of regex :)

[17:31] <Xliff> say "11" ~~ /(\d) <<my $c = $0;>> ($c)/; # Where << and >> can be anything. Helps me distinguish between code and regex.

[17:31] <Zoffix> m: my $*c; say "11" ~~ /(\d) { $*c = $0 } ($*c)/;

[17:31] <camelia> rakudo-moar 476741: OUTPUT: «｢11｣␤ 0 => ｢1｣␤ 1 => ｢1｣␤»

[17:31] <Zoffix> :)

[17:31] <Xliff> Zoffix: BETTER! ;)

[17:32] <Xliff> Thanks.

[17:32] *** erdic joined
[17:32] <Xliff> So that has to be a $* var, though? # $* == dynamic

[17:33] <Zoffix> m: my $c; say "11" ~~ /(\d) { $c = $0 } ($c)/;

[17:33] <camelia> rakudo-moar 476741: OUTPUT: «｢11｣␤ 0 => ｢1｣␤ 1 => ｢1｣␤»

[17:33] <Zoffix> Yeah, I guess it don't have to be dynamic :)

[17:33] <Xliff> lol

[17:33] <Xliff> Thanks.

[17:33] *** pyrimidine left
[17:34] <Zoffix> m: say "11" ~~ /(\d) { PROCESS::<$c> = $0 } ($*c)/;

[17:34] <camelia> rakudo-moar 476741: OUTPUT: «｢11｣␤ 0 => ｢1｣␤ 1 => ｢1｣␤»

[17:34] *** Cabanossi left
[17:34] *** buggable left
[17:35] *** pyrimidine joined
[17:36] *** Cabanossi joined
[17:36] <timotimo> m: say "hi hi" ~~ /(\w+) $1=[$0]/

[17:36] <camelia> rakudo-moar 476741: OUTPUT: «Nil␤»

[17:36] <timotimo> m: say "hi hi" ~~ /(\w+) \s+ $1=[$0]/

[17:36] <camelia> rakudo-moar 476741: OUTPUT: «｢hi hi｣␤ 0 => ｢hi｣␤ 1 => ｢hi｣␤»

[17:36] <timotimo> hey look

[17:36] *** pyrimidine left
[17:36] <timotimo> you can get around needing ( ) with this neat trick

[17:36] <Zoffix> hah

[17:36] <timotimo> Zoffix: wanna include that in the docs, too?

[17:37] <Zoffix> Is it actually a supported and tested method?

[17:37] *** pyrimidine joined
[17:37] <timotimo> hm, i can imagine problems with more ( ) after that

[17:37] <Zoffix> I mean, being able to write to $\d variables

[17:37] <timotimo> m: say "hi hi ho" ~~ /(\w+) \s+ $1=[$0] \s+ (\w+)/

[17:37] <camelia> rakudo-moar 476741: OUTPUT: «｢hi hi ho｣␤ 0 => ｢hi｣␤ 1 => ｢hi｣␤ 2 => ｢ho｣␤»

[17:37] <timotimo> whoa, it totally works, wtf this is awesome

[17:37] <Zoffix> m: say "hi hi ho" ~~ /(\w+) \s+ $10=[$0] \s+ (\w+)/

[17:37] <camelia> rakudo-moar 476741: OUTPUT: «｢hi hi ho｣␤ 0 => ｢hi｣␤ 10 => ｢hi｣␤ 11 => ｢ho｣␤»

[17:37] <Xliff> Oooh!

[17:37] <Xliff> timotimo++

[17:38] <Zoffix> m: say "hi hi ho" ~~ /(\w+) \s+ $10=[$0] \s+ (\w+)/; dd $/.list

[17:38] <camelia> rakudo-moar 476741: OUTPUT: «｢hi hi ho｣␤ 0 => ｢hi｣␤ 10 => ｢hi｣␤ 11 => ｢ho｣␤(Match.new(list => (), made => Any, pos => 2, hash => Map.new(()), orig => "hi hi ho", from => 0), Mu, Mu, Mu, Mu, Mu, Mu, Mu, Mu, Mu, Match.new(list => (), made => Any, pos => 5, hash…»

[17:38] <Zoffix> scary

[17:38] <grondilu> Hello, if I define &infix:<cmp> for a class, can I rely on &infix:[<=] and cie to use it? 

[17:38] <timotimo> m: say "hi" ~~ / $100000000=(\w+) /

[17:39] <camelia> rakudo-moar 476741: OUTPUT: «(timeout)»

[17:39] <Xliff> timotimo: Now that... I dunno

[17:39] <Zoffix> grondilu: no, it won't even be in the scope

[17:39] *** pyrimidine left
[17:39] *** pyrimidi_ joined
[17:40] <Zoffix> m: say "hi" ~~ / $10000000000000000000000000000000000000000000000000000000000000=(\w+) /

[17:40] <camelia> rakudo-moar 476741: OUTPUT: «｢hi｣␤ -6917529027641081856 => ｢hi｣␤»

[17:40] <Zoffix> m: say "hi" ~~ / $10000000000000000000000000000000000000000000000000000000000000=(\w) (.)/

[17:40] <camelia> rakudo-moar 476741: OUTPUT: «｢hi｣␤ -6917529027641081856 => ｢h｣␤ 0 => ｢i｣␤»

[17:40] <grondilu> &infix:[<=>] then?

[17:40] <timotimo> aaahahahaha

[17:40] *** pyrimidi_ left
[17:40] *** pyrimidine joined
[17:40] <Xliff> OK. That's buggered

[17:40] <Zoffix> grondilu: none of them. Your custom operator will be available only in the lexical scope

[17:40] <timotimo> might be something in output only, not in the data structuer itself?

[17:41] <grondilu> Zoffix: I don't mind staying in the lexical scope

[17:41] <Zoffix> grondilu: that's one of the problems with your idea, I mean. But I don't think there's any guarantees that core ops will definitelly use other core ops

[17:41] <Zoffix> grondilu: but it won't be in the lexical scope of the &infix:[<=] and the rest

[17:41] *** nadim left
[17:42] <grondilu> m: class A {}; multi infix:[<=>](A, A) { Same }; say A.new <= A.new

[17:42] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot override infix operator '=', as it is a special form handled directly by the compiler␤at <tmp>:1␤------> 3class A {}; multi infix:[<=>]7⏏5(A, A) { Same }; say A.new <= A.new␤»

[17:42] <grondilu> ??

[17:42] <grondilu> m: class A {}; multi infix:<<<=>>>(A, A) { Same }; say A.new <= A.new

[17:42] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3class A {}; multi infix:<<<=>>7⏏5>(A, A) { Same }; say A.new <= A.new␤    expecting any of:␤        new name to be defined␤»

[17:43] *** Skarsnik_ joined
[17:43] <grondilu> m: class A {}; multi infix:«<=>»(A, A) { Same }; say A.new <= A.new

[17:43] <camelia> rakudo-moar 476741: OUTPUT: «Cannot resolve caller Real(A: ); none of these signatures match:␤    (Mu:U \v: *%_)␤  in block <unit> at <tmp> line 1␤␤»

[17:43] <timotimo> grondilu: the problem is that operators declared in the setting will only look at their own lexical scope, which is the outer scope to your program

[17:43] <timotimo> at some point we want to have core things to look at the caller's scope to find custom implementations

[17:44] <grondilu> :/

[17:44] <grondilu> why isn't &[<=] just defined as $^a <=> $^b ~~ Less   ?

[17:45] <timotimo> i'd imagine performance issues

[17:45] <grondilu> or rather { $^a <=> $^b ~~ Less|Same } or something like that

[17:45] <grondilu> o_O

[17:45] <Zoffix> Filed the regex capture thing as https://rt.perl.org/Ticket/Display.html?id=132121

[17:46] <Zoffix> grondilu: also, there's no current way to define it like that

[17:46] *** Skarsnik left
[17:46] <Zoffix> It needs special compiler parsing to support chaining

[17:46] <moritz> because wa want rakudo to run, not crawl :-)

[17:46] <grondilu> oh there is that indeed

[17:46] <Zoffix> :)

[17:46] <moritz> s/wa/we/

[17:47] <timotimo> wait, what's the problem with chaining with that implementation?

[17:47] <grondilu> that makes creating Numeric types a pain, though.

[17:47] <Zoffix> timotimo: you can chain only one op, so you can't define a userland op that works with, say,   42 <= 5 == 7 >= 6

[17:48] <Zoffix> You can only chain as 42 <= 5 <= 7 <= 6

[17:48] <timotimo> oh, really?

[17:48] <Zoffix> Yeah

[17:48] <timotimo> m: say 1 <= 5 > 3

[17:48] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[17:48] <timotimo> m: say 1 <= 5 > 10

[17:48] <camelia> rakudo-moar 476741: OUTPUT: «False␤»

[17:48] <timotimo> looks like it totally works

[17:48] <AlexDaniel> timotimo: now create a userland op that does the same

[17:48] <Zoffix> ^ that works because it has special compiler stuff

[17:48] <timotimo> m: say 1 <= 5 == 5 > 3 < 99

[17:48] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[17:48] <timotimo> oh, is that the problem, okay

[17:48] <Zoffix> You can't make your own ops that work that way by just defining subs

[17:49] <Zoffix> Yet

[17:49] <timotimo> but the core could still implement these subs to go off of cmp - not that it helps you tremendously

[17:49] <AlexDaniel> timotimo: it's also one of the reasons we finally got ≤ ≥ ≠

[17:49] <Zoffix> I know TimToady++ was mentining we want to make it possible to do in userland

[17:49] <Zoffix> *mentioning

[17:49] <Zoffix> timotimo: ah yeah, I guess it could :)

[17:49] <Zoffix> But still, there's a performance issue :)

[17:50] <timotimo> and it'll still not get cmp from your programs scope

[17:50] <grondilu> ideally shouldn't the core be indistiguishable from userland?

[17:50] <Zoffix> s: &infix:«<=», \(1, 2)

[17:50] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/476741e77/src/core/Int.pm#L358

[17:50] <El_Che> timotimo: wouldn't it need to remove nqp for that?

[17:50] <timotimo> El_Che: how do you mean?

[17:51] <Zoffix> grondilu: ideally yes, but performance is our current biggest enemy. It's hard to argue for support of nicer custom user-land numerics in exchange for everything that's currently slow to be massively slower

[17:51] *** nadim joined
[17:51] * timotimo imagines a register-comparison-op ...

[17:52] <El_Che> I mean that a lot of stuff is done in nqp for performance, while the user-land (as in ops created by the user) normally won't use that

[17:52] <Zoffix> grondilu: I know someone in the past mentioned the golden goal is for rakudo to be just written in pure Rakudo, with all the optimizers doing the legwork to make it fast. Dunno if that was just a dream or is actually achievable :)

[17:52] <grondilu> well, I disagree but I concede I'm biased since I'm working on custom numeric types 

[17:52] <El_Che> (maybe I am missing the point, haven't read the backlog)

[17:52] *** andrzejku joined
[17:52] *** pyrimidine left
[17:52] <timotimo> El_Che: well, the core would implement <= as a call to cmp and checking the return values of that

[17:52] *** pyrimidine joined
[17:52] <El_Che> timotimo: ah, I see

[17:53] <timotimo> there's the possibility for moarvm to be much smarter after inlining things

[17:53] <El_Che> timotimo: would that mean an extra layer of indirection with speed consequences?

[17:53] <timotimo> so that the code of <= could be effectively the same as the more optimized version

[17:53] <Zoffix> What would a call to cmp be implemented as? :)

[17:54] <timotimo> however we implement cmp right now

[17:54] <timotimo> or do we implement cmp as using the other ops?

[17:54] <grondilu> yeah, cmp could be the base other operators use

[17:54] <Zoffix> cmp is for strings though, innit?

[17:54] <Zoffix> So why is <= using it?

[17:54] <timotimo> isn't cmp the one about before and after?

[17:55] <timotimo> strings is leg

[17:55] <grondilu> yeah I meant <=>

[17:55] <Zoffix> Ah, right. OK

[17:55] <Zoffix> s: &infix:<cmp>, \(1, 2)

[17:55] <SourceBaby> Zoffix, Sauce is at https://github.com/rakudo/rakudo/blob/476741e77/src/core/Order.pm#L46

[17:55] <grondilu> basically the ones that return an Order should be used to define the ones that return a Bool

[17:55] <timotimo> aye

[17:56] <timotimo> once moar's spesh gets clever enough in some of the ops it could figure out how these comparisons against the Order enums work

[17:56] <timotimo> i'd imagine spesh would want to be able to split tails of code in two at a merge point

[17:57] <grondilu> does that have to be on optimization level?

[17:57] <timotimo> how do you mean?

[17:57] <grondilu> spesh is optimization, isn't it?

[17:57] <Zoffix> Yes

[17:57] <timotimo> yes

[17:57] <grondilu> couldn't it be in the core?

[17:57] <timotimo> spesh is a run-time optimization thing

[17:58] <timotimo> oh, i suppose we can also just put optimized versions of <= and friends into the multi dispatch cache

[17:58] <timotimo> unless the user code is derived from the existing types we optimize for

[17:58] *** pyrimidine left
[17:59] *** pyrimidine joined
[17:59] <grondilu> meh, it just seems to me that defining both the Order ones and the Bool ones creates redundancy and makes customizing hard.

[17:59] <timotimo> you mean <= should become a macro that turns into something using <=> immediately?

[18:00] <grondilu> maybe, dunno

[18:00] <timotimo> that'll also automatically give you the user's scope, but only if the user code uses it directly and not hoping some other functions from other scopes to use it properly, too

[18:00] <timotimo> that could lull users into a false sense of security

[18:01] <Zoffix> m: use nqp; sub ORDER(int $i) { nqp::iseq_i($i,0) ?? Same !! nqp::islt_i($i,0) ?? Less !! More }; sub infix:<zcmp> { ORDER(nqp::cmp_I(nqp::decont($^a), nqp::decont($^b))) }; sub infix:<zold> { nqp::p6bool(nqp::isle_I(nqp::decont($^a), nqp::decont($^b))) }; sub infix:<zless> { nqp::p6bool(nqp::isle_i(($^a zcmp $^b), 0)) }; for ^500_000 { $ = rand.Int zless rand.Int }; say now - INIT now

[18:01] <camelia> rakudo-moar 476741: OUTPUT: «0.935390␤»

[18:01] <grondilu> I don't get the problem with scopes here.

[18:01] <Zoffix> m: use nqp; sub ORDER(int $i) { nqp::iseq_i($i,0) ?? Same !! nqp::islt_i($i,0) ?? Less !! More }; sub infix:<zcmp> { ORDER(nqp::cmp_I(nqp::decont($^a), nqp::decont($^b))) }; sub infix:<zold> { nqp::p6bool(nqp::isle_I(nqp::decont($^a), nqp::decont($^b))) }; sub infix:<zless> { nqp::p6bool(nqp::isle_i(($^a zcmp $^b), 0)) }; for ^500_000 { $ = rand.Int zold rand.Int }; say now - INIT now

[18:01] <camelia> rakudo-moar 476741: OUTPUT: «0.7523957␤»

[18:01] <Zoffix> m: say .93/.75

[18:01] <camelia> rakudo-moar 476741: OUTPUT: «1.24␤»

[18:02] <Zoffix> grondilu: so basically if <= were implemented in terms of `cmp` with our current optimizers that'd make <= about 25% slower

[18:02] <grondilu> if you ask me I'd tell you it's worth it

[18:02] <Zoffix> hehe

[18:02] * Zoffix goes for "definitely not"

[18:02] <Zoffix> grondilu: it still won't pick up your custom `cmp` ops, so I don't really see the benefit

[18:03] <grondilu> why wouldn't it?

[18:03] <Zoffix> because it's not in scope

[18:03] <grondilu> oh, I think I understand

[18:03] <grondilu> there has to be a clever OOP way to do this.

[18:04] <Zoffix> There's a hack to make it work, yeah

[18:04] <timotimo> operators are about the lexical language

[18:04] <Zoffix> m: multi core-op1 { say 42 }; multi core-cmp { core-op1 }; { multi core-op1 { say 70 }; core-cmp }

[18:04] <camelia> rakudo-moar 476741: OUTPUT: «42␤»

[18:05] <grondilu> make <=> virtual, have <=, <, > and >= us it, and implement <=> concretly in the main scope?

[18:05] <Zoffix> grondilu: ^ there's the scoping issue illustrated. The "core-cmp" sub only sees the first "core-op1"; the second one is not in its lexical scope and that's the one you're redifining it from ujserland

[18:05] <timotimo> m: multi core-op1 { say 42 }; multi core-cmp { CALLER::&core-op1() }; { multi core-op1 { say 70 }; core-cmp }

[18:05] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed lookup of ::&core-op1; please use ::('&core-op1'), ::{'&core-op1'}, or ::<&core-op1>␤at <tmp>:1␤------> 3-op1 { say 42 }; multi core-cmp { CALLER7⏏5::&core-op1() }; { multi core-op1 { sa…»

[18:05] <timotimo> m: multi core-op1 { say 42 }; multi core-cmp { CALLER::('&core-op1')() }; { multi core-op1 { say 70 }; core-cmp }

[18:05] <camelia> rakudo-moar 476741: OUTPUT: «Ambiguous call to 'core-op1'; these signatures all match:␤:()␤:()␤  in sub core-cmp at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:06] <timotimo> this is one proposed solution

[18:06] <timotimo> though probably with CLIENT instead of CALLER there

[18:06] <AlexDaniel> I feel like doing something…

[18:06] <Zoffix> timotimo: so all core ops would call CALLER:: ?

[18:06] <Zoffix> or CLIENT rather

[18:06] * AlexDaniel looks at https://github.com/perl6/whateverable/issues/40

[18:07] <timotimo> probably. and yes, that's really, really bad for performance, i imagine

[18:07] * timotimo AFKBBL

[18:08] *** nadim left
[18:08] *** headcase joined
[18:08] *** espadrine joined
[18:08] <grondilu> anyway, right now, if I want to overload &[<=], &[>=], &[>] and &[<], I have to define them all?

[18:08] <grondilu> instead of just defining &[<=>]?

[18:09] <Zoffix> m: class MyObj {}; sub install-it { CORE::<&infix:<eqv>>.add_dispatchee(multi sub infix:<eqv>(MyObj $l, MyObj $r --> Bool) { dd "w00t" }) }; insatll-it; say MyObj eqv MyObj

[18:09] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    insatll-it used at line 1. Did you mean 'install-it'?␤␤»

[18:09] <Zoffix> m: class MyObj {}; sub install-it { CORE::<&infix:<eqv>>.add_dispatchee(multi sub infix:<eqv>(MyObj $l, MyObj $r --> Bool) { dd "w00t" }) }; install-it; say MyObj eqv MyObj

[18:09] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[18:09] <Zoffix> huggable: extend core op :is: Hacking and (probably) unsupported way to extend core ops so they are seen even outside lexical scope: class MyObj {}; sub install-it { CORE::<&infix:<eqv>>.add_dispatchee(multi sub infix:<eqv>(MyObj $l, MyObj $r --> Bool) { dd "w00t" }) }; install-it; say MyObj eqv MyObj

[18:09] <huggable> Zoffix, Added extend core op as Hacking and (probably) unsupported way to extend core ops so they are seen even outside lexical scope: class MyObj {}; sub install-it { CORE::<&infix:<eqv>>.add_dispatchee(multi sub infix:<eqv>(MyObj $l, MyObj $r --> Bool) { dd "w00t" }) }; install-it; say MyObj eqv MyObj

[18:10] <Zoffix> grondilu: well, recall the thing I mentioned that you can't make ops like <= and > currently

[18:10] <timotimo> the ruby folks don't have a problem with this kind of thing at all! nor the javascript folks

[18:10] <grondilu> even if I don't mind that they won't be chaining?

[18:11] <timotimo> you might not mind, but your users probably will?

[18:11] <grondilu> :/

[18:11] <grondilu> anyway, let me tell you that's LTA

[18:12] <grondilu> performance is nice, but I don't see it as an excuse for that

[18:12] *** headcase left
[18:12] <Zoffix> grondilu: performance is basically the only thing everyone ever talks about when they give reasons why they can't use Rakudo in production

[18:13] <grondilu> is it still true though?  Performance has made great progress lately. Isn't it enough now?

[18:13] <moritz> no

[18:13] <perlpilot> grondilu: no.

[18:13] <Zoffix> And $10,000 or more has been spent this year by sponsors to improve it. Saying "it's not an excuse" is a bit off the mark

[18:13] <Zoffix> m: class Obj {}; multi infix:«<» (Obj, $) { "got it" }; say Obj < 42

[18:13] <camelia> rakudo-moar 476741: OUTPUT: «got it␤»

[18:13] <Zoffix> m: class Obj {}; multi infix:«<» (Obj, $) { "got it" }; say Obj < 42 < 72

[18:13] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[18:14] *** headcase joined
[18:15] <timotimo> it's definitely not enough from my perspective as well

[18:15] <Zoffix> m: class Obj { method Str { "Obj" } }; sub infix:«<» is assoc("list") { "got it [@_[]]" }; say Obj < 42 < 70

[18:15] <camelia> rakudo-moar 476741: OUTPUT: «got it [42 70]␤»

[18:16] * Zoffix squints

[18:16] <Zoffix> Where did Obj go? :/

[18:17] <Zoffix> m: class Obj { method Str { "Obj" } }; sub infix:«zf» (*@a) is assoc("list") { ["got it", @a].perl }; say Obj zf 42 zf 70

[18:17] <camelia> rakudo-moar 476741: OUTPUT: «["got it", [Obj, 42, 70]]␤»

[18:17] <Zoffix> m: class Obj { method Str { "Obj" } }; sub infix:«<» (*@a) is assoc("list") { ["got it", @a].perl }; say Obj < 42 < 70

[18:17] <camelia> rakudo-moar 476741: OUTPUT: «["got it", [42, 70]]␤»

[18:17] <Skarsnik_> yep, too slow x)

[18:17] *** Skarsnik_ is now known as Skarsnik

[18:18] <Zoffix> Looks like the specialness of < interferes even there

[18:18] <Zoffix> grondilu: ^ so yeah, there's some options, but doesn't look like the work well

[18:19] <Zoffix> You could probably do a slang (which is unsupported and not unspecced ATM)

[18:19] *** headcase left
[18:19] <Zoffix> s/not //;

[18:20] <grondilu> can I at least hope it will be fixed *eventually*?

[18:20] <Zoffix> Yeah, probably :)

[18:20] *** headcase joined
[18:20] <grondilu> so I guess meanwhile I will manually define the four infixes :/

[18:20] <Zoffix> I know TimToady mentioned we do want to make it possible to define ops like < in userland and from then I guess it'll mean our core `<` won't be magically special anymore

[18:21] <perlpilot> m: "foofoo" ~~ / (foo) $10=[$0] /; say $/.elems;  # I wonder if this will surprise people too?

[18:21] <camelia> rakudo-moar 476741: OUTPUT: «11␤»

[18:21] <perlpilot> (sorry, just looking through scroolback)

[18:22] * grondilu suddenly realizes he will need the chaining behavior

[18:22] <moritz> m: sub infix:<smaller>($a, $b) is assoc<chained> { $a < $b }; say 1 smaller 2

[18:22] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[18:22] <moritz> m: sub infix:<smaller>($a, $b) is assoc<chained> { $a < $b }; say 1 smaller 2 smaller 3

[18:22] <camelia> rakudo-moar 476741: OUTPUT: «False␤»

[18:22] <Zoffix> You can chain same ops.

[18:22] <Zoffix> You can't chain differring

[18:23] <moritz> didn't seem to work here

[18:24] *** headcase left
[18:24] *** pyrimidine left
[18:24] *** headcase joined
[18:25] *** wamba joined
[18:25] <Zoffix> It's "chain" not "chained", according to docs, but it don't work either

[18:25] * grondilu has to wake up early tmrw so goes to sleep

[18:26] *** grondilu left
[18:26] <Zoffix> mc: m: sub infix:<smaller> is assoc<chain> { dd @_ }; say 1 smaller 2 smaller 3

[18:26] <committable6> Zoffix, ¦2015.12: «[2, 3]␤[1, Any]␤Nil»

[18:27] *** pyrimidine joined
[18:29] <Zoffix> Oh, I think that's what is *meant* to work, but doesn't without compiler's specialness of adding <O(%chaining)> thing

[18:31] *** albongo left
[18:33] <moritz> m: infix:<smaller> is assoc<chain> is equviv(&infix:<==>) { dd @_ }; say 1 smaller 2 smaller 3

[18:33] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3infix:<smaller> is assoc<chain>7⏏5 is equviv(&infix:<==>) { dd @_ }; say 1␤    expecting any of:␤        infix␤        infix stopper␤        postfix…»

[18:33] <moritz> m: infix:<smaller>(@_) is assoc<chain> is equviv(&infix:<==>) { dd @_ }; say 1 smaller 2 smaller 3

[18:33] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use placeholder parameter @_ outside of a sub or block␤at <tmp>:1␤------> 3infix:<smaller>(@_7⏏5) is assoc<chain> is equviv(&infix:<==>)␤»

[18:33] <moritz> m: sub infix:<smaller>(@_) is assoc<chain> is equviv(&infix:<==>) { dd @_ }; say 1 smaller 2 smaller 3

[18:33] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Can't use unknown trait 'is equviv' in a sub+{precedence} declaration.␤at <tmp>:1␤    expecting any of:␤        rw raw hidden-from-backtrace hidden-from-USAGE␤        pure default DEPRECATED inlina…»

[18:33] <moritz> m: sub infix:<smaller>(@_) is assoc<chain> is equiv(&infix:<==>) { dd @_ }; say 1 smaller 2 smaller 3

[18:33] <camelia> rakudo-moar 476741: OUTPUT: «Too many positionals passed; expected 1 argument but got 2␤  in sub infix:<smaller> at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[18:33] <moritz> m: sub infix:<smaller>(*@_) is assoc<chain> is equiv(&infix:<==>) { dd @_ }; say 1 smaller 2 smaller 3

[18:33] <camelia> rakudo-moar 476741: OUTPUT: «[1, 2]␤Nil␤»

[18:34] <Skarsnik> infix<piko>(Any, List) and infix(Any, Any) to have working junction I think?

[18:35] <Zoffix> m: sub infix:<smaller>(*@_) is assoc<list> is equiv(&infix:<==>) { dd @_ }; say 1 smaller 2 smaller 3

[18:35] <camelia> rakudo-moar 476741: OUTPUT: «[1, 2]␤Nil␤»

[18:35] <Zoffix> huh

[18:35] <Zoffix> m: sub infix:<smaller>(*@_) is assoc<list> { dd @_ }; say 1 smaller 2 smaller 3

[18:35] <camelia> rakudo-moar 476741: OUTPUT: «[1, 2, 3]␤Nil␤»

[18:35] <Zoffix> is equiv copies other crap and overrides assoc

[18:35] <Zoffix> m: sub infix:<smaller>(*@_) is assoc<list> { [<] @_ }; say 1 smaller 2 smaller 3

[18:35] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[18:35] <Zoffix> ^ and that's a way to cheatsy-chain (works only with same ops)

[18:37] <Skarsnik> m: sub infix<smaller>(Int $a, Int $b) { $a < $b}; sub infix<smaller>(Int $a, List $b) {dd $a}; say 1 smaller 2 smaller 3;

[18:37] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub infix7⏏5<smaller>(Int $a, Int $b) { $a < $b}; su␤    expecting any of:␤        new name to be defined␤»

[18:37] <Skarsnik> m: sub infix:<smaller>(Int $a, Int $b) { $a < $b}; sub infix:<smaller>(Int $a, List $b) {dd $a}; say 1 smaller 2 smaller 3;

[18:37] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of routine 'infix:<smaller>' (did you mean to declare a multi-sub?)␤at <tmp>:1␤------> 3infix:<smaller>(Int $a, List $b) {dd $a}7⏏5; say 1 smaller 2 smaller 3;␤    expecting any o…»

[18:37] <Skarsnik> m: sub infix:<smaller>(Int $a, Int $b) { $a < $b}; multi sub infix:<smaller>(Int $a, List $b) {dd $a}; say 1 smaller 2 smaller 3;

[18:37] <camelia> rakudo-moar 476741: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of routine 'infix:<smaller>' (did you mean to declare a multi-sub?)␤at <tmp>:1␤------> 3infix:<smaller>(Int $a, List $b) {dd $a}7⏏5; say 1 smaller 2 smaller 3;␤    expecting any o…»

[18:37] <Skarsnik> m: multi sub infix:<smaller>(Int $a, Int $b) { $a < $b}; multi sub infix:<smaller>(Int $a, List $b) {dd $a}; say 1 smaller 2 smaller 3;

[18:37] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[18:38] <Skarsnik> m: multi sub infix:<smaller>(Int $a, Int $b) { $a < $b}; multi sub infix:<smaller>(Int $a, List $b) {dd $a}; say 1 smaller 2 | 3;

[18:38] <camelia> rakudo-moar 476741: OUTPUT: «any(True, 3)␤»

[18:39] *** nadim joined
[18:42] <Zoffix> m: BEGIN { $?LANG.refine_slang('MAIN', role { token infix:sym«smaller» { <sym> <O('prec', 'm=', 'assoc', 'left', 'dba', 'chaining', 'iffy', 1, 'diffy', 1, 'pasttype', 'chain')> } } )}; sub infix:<smaller> { $^a < $^b }; say 1 smaller 2 smaller 3

[18:42] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[18:42] <Zoffix> :)

[18:43] <Zoffix> .tell grondilu this uses non-standard features (slangs), but it makes chained ops work, I think: BEGIN { $?LANG.refine_slang('MAIN', role { token infix:sym«smaller» { <sym> <O('prec', 'm=', 'assoc', 'left', 'dba', 'chaining', 'iffy', 1, 'diffy', 1, 'pasttype', 'chain')> } } )}; sub infix:<smaller> { $^a < $^b }; say 1 smaller 2 smaller 3

[18:43] <yoleaux> Zoffix: I'll pass your message to grondilu.

[18:43] *** haxmeister left
[18:43] <Skarsnik> m: BEGIN { $?LANG.refine_slang('MAIN', role { token infix:sym«smaller» { <sym> <O('prec', 'm=', 'assoc', 'left', 'dba', 'chaining', 'iffy', 1, 'diffy', 1, 'pasttype', 'chain')> } } )}; sub infix:<smaller> { $^a < $^b }; say 1 smaller 2 > 0

[18:43] <camelia> rakudo-moar 476741: OUTPUT: «True␤»

[18:44] <Skarsnik> m: BEGIN { $?LANG.refine_slang('MAIN', role { token infix:sym«smaller» { <sym> <O('prec', 'm=', 'assoc', 'left', 'dba', 'chaining', 'iffy', 1, 'diffy', 1, 'pasttype', 'chain')> } } )}; sub infix:<smaller> { $^a < $^b }; say 1 smaller 2 > 3

[18:44] <camelia> rakudo-moar 476741: OUTPUT: «False␤»

[18:46] *** buggable joined
[18:46] *** ChanServ sets mode: +v buggable

[18:46] *** cschwenz joined
[18:49] <Geth> ¦ whateverable: 45293f8473 | (Aleks-Daniel Jakimenko-Aleksejev)++ | bin/Squashable.p6

[18:49] <Geth> ¦ whateverable: Ignore strong formatting

[18:49] <Geth> ¦ whateverable: 

[18:49] <Geth> ¦ whateverable: Not all dates may have a poster, and some dates may be simply in bold.

[18:49] <Geth> ¦ whateverable: review: https://github.com/perl6/whateverable/commit/45293f8473

[18:49] <Geth> ¦ whateverable: 054a5f0041 | (Sylvain Colinet)++ (committed by Aleks-Daniel Jakimenko-Aleksejev) | bin/Nativecallable.p6

[18:49] <Geth> ¦ whateverable: Some changes

[18:49] <Geth> ¦ whateverable: 

[18:49] <Geth> ¦ whateverable: Committing whatever we have live.

[18:49] *** bisectable6 left
[18:49] *** unicodable6 left
[18:49] *** squashable6 left
[18:49] *** benchable6 left
[18:49] *** committable6 left
[18:49] *** bloatable6 left
[18:49] *** coverable6 left
[18:49] *** evalable6 left
[18:49] *** releasable6 left
[18:49] *** quotable6 left
[18:49] <Geth> ¦ whateverable: review: https://github.com/perl6/whateverable/commit/054a5f0041

[18:49] *** statisfiable6 left
[18:49] *** greppable6 left
[18:49] *** nativecallable6 left
[18:50] <Zoffix> Botacalypse

[18:50] <cschwenz> .botsnack

[18:50] <synopsebot6> om nom nom

[18:50] <yoleaux> :D

[18:50] <yoleaux> 16:36Z <Zoffix> cschwenz: I was wrong, it's not a bug: https://irclog.perlgeek.de/perl6/2017-09-18#i_15181692

[18:50] *** jonas1 left
[18:51] <cschwenz> aha, thanks Zoffix and jnthn

[18:51] <Skarsnik> Oh yeah i changed stuff x)

[18:51] <Zoffix> And workaround is basically just saving the capture into a variable before going inside the capture (last paragraph in this section: https://docs.perl6.org/language/regexes#Capture_numbers )

[18:53] *** andrzejku left
[18:54] *** cschwenz left
[18:55] *** committable6 joined
[18:55] *** ChanServ sets mode: +v committable6

[18:55] *** bloatable6 joined
[18:55] *** ChanServ sets mode: +v bloatable6

[18:55] *** coverable6 joined
[18:55] *** nativecallable6 joined
[18:55] *** quotable6 joined
[18:55] *** greppable6 joined
[18:55] *** ChanServ sets mode: +v greppable6

[18:55] *** releasable6 joined
[18:55] *** ChanServ sets mode: +v releasable6

[18:55] *** bisectable6 joined
[18:55] *** unicodable6 joined
[18:55] *** squashable6 joined
[18:55] *** evalable6 joined
[18:55] *** benchable6 joined
[18:55] *** statisfiable6 joined
[18:55] *** pyrimidine left
[18:56] *** nadim left
[18:58] *** headcase left
[18:59] *** jonas1 joined
[18:59] *** rindolf left
[19:01] *** headcase joined
[19:02] *** rindolf joined
[19:03] *** yadzi left
[19:03] *** st_elmo left
[19:06] <AlexDaniel> ⚠

[19:06] <AlexDaniel> oops

[19:07] *** nadim joined
[19:07] *** itaipu joined
[19:08] <AlexDaniel> ⚠ Rakudo SQUASHathon 2017-10-07 https://github.com/rakudo/rakudo/wiki/Monthly-Bug-Squash-Day

[19:09] *** skids joined
[19:10] *** Rawriful joined
[19:12] *** erikas joined
[19:13] *** erikas left
[19:19] *** jonas1 left
[19:26] *** darutoko- left
[19:33] *** albongo joined
[19:34] *** Cabanossi left
[19:36] *** Cabanossi joined
[19:38] *** xinming_ joined
[19:39] *** cschwenz joined
[19:41] *** xinming left
[19:42] *** eliasr joined
[19:45] *** espadrine left
[19:54] *** st_elmo joined
[19:54] *** st_elmo left
[19:54] *** okl joined
[19:55] *** cschwenz left
[20:00] *** cono left
[20:03] *** pyrimidine joined
[20:05] *** Cabanossi left
[20:06] *** Cabanossi joined
[20:07] <gfldex> looks like I was right to golf httpd: https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html

[20:09] *** Cabanossi left
[20:09] <timotimo> oh crap

[20:10] *** Cabanossi joined
[20:12] <mspo> gdonald: you found that?

[20:12] <mspo> anyway nice one

[20:13] <gfldex> wasn't me who found that

[20:13] <gfldex> but that's clearly a bug that exists because of bloat

[20:13] <gfldex> my first reaction was: Who the hell would need that feature?

[20:14] <mspo> OPTIONS + Limit?

[20:14] <mspo> apache must support OPTIONS because it's http

[20:14] <gfldex> options + limits and the ability to overrule that locally in any .htaccess

[20:15] <gfldex> what makes that writeable to folk who don't got root

[20:15] <mspo> firefox does options requests as a part of CORS/preflight

[20:15] <mspo> gdonald: .htaccess/<Directory> scope is a very misunderstood feature of apache :)

[20:15] <mspo> gfldex: ^^

[20:16] <mspo> anyway being super feature rich and crazy flexible is what makes apache so amazing

[20:31] *** okl left
[20:35] *** Cabanossi left
[20:35] *** rindolf left
[20:36] *** Cabanossi joined
[20:36] *** TEttinger joined
[20:40] *** setty1 left
[20:49] *** audiatorix joined
[21:00] *** mr-foobar left
[21:02] *** mr-foobar joined
[21:04] *** itaipu left
[21:05] *** headcase left
[21:05] *** Cabanossi left
[21:06] *** Cabanossi joined
[21:09] *** albongo left
[21:11] *** albongo joined
[21:16] *** headcase joined
[21:16] *** headcase left
[21:17] *** headcase joined
[21:18] *** headcase left
[21:25] *** mcmillhj left
[21:25] *** Skarsnik left
[21:30] *** audiatorix left
[21:31] *** itaylor57 left
[21:41] <lizmat> and yet another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/09/18/2017-38-color-me-booked/

[21:44] *** knobo joined
[21:45] *** headcase joined
[21:47] <Juerd> lizmat: Thanks :)

[21:47] *** |oLa| left
[21:48] <El_Che> ah crap, I missed the new rakudo release. I'll release linux pkgs tomorrow

[21:48] <timotimo> cool, El_Che++

[21:48] <timotimo> that'll still be plenty fast :)

[21:49] <El_Che> hehe

[21:50] *** headcase left
[21:53] *** Rawriful left
[21:54] *** headcase joined
[21:57] *** knobo left
[21:59] *** pecastro left
[22:01] *** itaylor57 joined
[22:02] *** headcase left
[22:03] *** wamba left
[22:05] <Geth> ¦ doc: 3101569f05 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Programs/00-running.pod6

[22:05] <Geth> ¦ doc: List new scheduler debug vars

[22:05] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/3101569f05

[22:06] *** pecastro joined
[22:12] <jnthn> Zoffix++

[22:16] *** robertle left
[22:17] * lizmat calls it a night

[22:17] <timotimo> gnite lizmat 

[22:17] *** headcase joined
[22:18] *** pecastro left
[22:19] *** skids left
[22:22] *** headcase left
[22:28] *** mr-foobar left
[22:30] *** mr-foobar joined
[22:32] *** leont left
[22:37] *** Celelibi left
[22:41] *** Celelibi joined
[22:42] *** skids joined
[22:46] <Zoffix> .tell tadzik shot a small PR at you :) https://github.com/tadzik/Terminal-ANSIColor

[22:46] <yoleaux> Zoffix: I'll pass your message to tadzik.

[22:46] <tadzik> yolo!

[22:46] <yoleaux> 22:46Z <Zoffix> tadzik: shot a small PR at you :) https://github.com/tadzik/Terminal-ANSIColor

[22:46] <tadzik> thanks yolo

[22:46] <Zoffix> Sucks that GitHub doesn't highlight Rakudo code blocks for some reason :/

[22:46] <Zoffix> tadzik++ thanks

[22:47] <Zoffix> tadzik: oh wait, I forget a version bump :) https://github.com/tadzik/Terminal-ANSIColor/pull/14

[22:47] <tadzik> there's moar outstanding PRs :o

[22:47] <tadzik> perl6 day is overdue

[22:48] <Zoffix> :)

[22:48] <tadzik> //o\

[22:48] <tadzik> gottem

[22:48] <Zoffix> m: ｢ /o\ ｣.flip.say

[22:48] <camelia> rakudo-moar da5c36: OUTPUT: « \o/ ␤»

[22:48] <tadzik> Zoffix++; thanks for making things better!

[22:49] <Zoffix> :)

[22:49] <tadzik> ...aand I can't believe this works

[22:49] <japhb> BTW, if you're using Terminal-ANSIColor coloring at high volume, it pays to cache the color escapes for anything but RGB mode; see https://github.com/ab5tract/Terminal-Print/blob/master/lib/Terminal/Print/Grid.pm6#L8 for an example.

[22:49] *** imcsk8 joined
[22:50] *** Cabanossi left
[22:51] <tadzik> hmm

[22:51] <tadzik> is there a standarized memoization I can use for color(), colored() etc these days?

[22:51] *** Cabanossi joined
[22:51] <tadzik> (also: yay or nay for colour(), coloured() etc aliases? :P)

[22:52] <japhb> Nay if it was my module, but it's yours.  ;-)

[22:54] <japhb> tadzik: You might lose more performance by trying *not* to cache RGB values than you'd gain by doing it there.  There was a significant cost just to be calling color() or colored(), when I really just wanted to pull from local cache on the caller side if it's available.

[22:57] <tadzik> right

[22:57] *** cpage_ left
[22:58] *** mr-foobar left
[23:03] *** mr-foobar joined
[23:03] *** margeas left
[23:04] <AlexDaniel> .

[23:11] *** bisectable6 left
[23:11] *** unicodable6 left
[23:11] *** squashable6 left
[23:11] *** benchable6 left
[23:11] *** committable6 left
[23:11] *** bloatable6 left
[23:11] *** coverable6 left
[23:11] *** evalable6 left
[23:11] *** releasable6 left
[23:11] *** quotable6 left
[23:11] *** statisfiable6 left
[23:11] *** greppable6 left
[23:11] *** nativecallable6 left
[23:13] *** pecastro joined
[23:17] *** coverable6 joined
[23:17] *** ChanServ sets mode: +v coverable6

[23:17] *** quotable6 joined
[23:17] *** nativecallable6 joined
[23:17] *** ChanServ sets mode: +v nativecallable6

[23:18] *** committable6 joined
[23:18] *** ChanServ sets mode: +v committable6

[23:18] *** greppable6 joined
[23:18] *** releasable6 joined
[23:18] *** bloatable6 joined
[23:18] *** bisectable6 joined
[23:18] *** ChanServ sets mode: +v bisectable6

[23:18] *** evalable6 joined
[23:18] *** ChanServ sets mode: +v evalable6

[23:18] *** statisfiable6 joined
[23:18] *** unicodable6 joined
[23:18] *** squashable6 joined
[23:18] *** benchable6 joined
[23:19] *** greppable6 left
[23:19] *** committable6 left
[23:19] *** greppable6 joined
[23:19] *** ChanServ sets mode: +v greppable6

[23:19] *** committable6 joined
[23:27] *** cpage_ joined
[23:30] *** mr-foobar left
[23:31] *** cpage_ left
[23:33] *** mr-foobar joined
[23:34] <AlexDaniel> how can I get --version string from code?

[23:35] *** Cabanossi left
[23:35] <AlexDaniel> I know there's $*PERL and $*VM but how do I get output identical to --version?

[23:36] <MasterDuke> say 

[23:36] <evalable6> MasterDuke, rakudo-moar da5c36c13: OUTPUT: «(exit code 1) 04===SORRY!04===␤Argument to "say" seems to be malformed␤at /t…»

[23:36] <evalable6> MasterDuke, Full output: https://gist.github.com/073359bc6651eaf75dd9b59b0f8e8224

[23:36] <MasterDuke> say $*PERL.compiler.version

[23:36] <evalable6> MasterDuke, rakudo-moar da5c36c13: OUTPUT: «v2017.09.27.gda.5.c.36.c.13»

[23:36] *** Cabanossi joined
[23:38] *** adu joined
[23:39] <MasterDuke> hm, guess that's not quite it either

[23:41] <Zoffix> It's built here: https://github.com/rakudo/rakudo/blob/nom/tools/build/gen-version.pl#L9-L40

[23:52] *** pecastro left
[23:52] *** pecastro joined
[23:53] *** headcase joined
[23:53] *** cpage_ joined
[23:57] *** headcase left
[23:59] *** mr-foobar left
