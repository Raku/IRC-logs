[00:00] *** lizmat joined
[00:02] *** Actualeyes joined
[00:03] *** rindolf left
[00:07] *** kurahaupo joined
[00:10] *** lizmat left
[00:17] *** rindolf joined
[00:18] *** mr-foobar left
[00:22] *** mr-foobar joined
[00:33] *** AlexDaniel left
[00:33] <tbrowder> .tell dwarring Font::AFM, version 1.24.1 works great now!

[00:33] <yoleaux> tbrowder: I'll pass your message to dwarring.

[00:37] *** kst`` is now known as kst

[00:38] *** Cabanossi left
[00:39] *** Cabanossi joined
[00:58] *** BenGoldberg joined
[01:01] *** raschipi joined
[01:06] *** Cabanossi left
[01:08] *** Cabanossi joined
[01:12] *** amerlyq left
[01:19] *** mr-foobar left
[01:22] *** mr-foobar joined
[01:25] *** PerlJam joined
[01:31] <BenGoldberg> m: use NativeCall; my \compar_t = Callable but role :: { method sub_signature { :(Pointer,Pointer --> int) } };

[01:31] <yoleaux> 06:22 EDT <Zoffix> BenGoldberg: `===SORRY!===␤QAST::Block with cuid 1 has not appeared` is a bug and users should never see errors about QAST stuff. In this case, it looks a lot like the error you get when you try to use whatevercode in chained ops, like `5 < *.abs <7`   Do you got any of that in your module?

[01:31] <camelia> rakudo-moar ef9872: OUTPUT: «X::Method::NotFound exception produced no message␤  in block <unit> at <tmp> line 1␤␤»

[01:35] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359

[01:35] <camelia> rakudo-moar ef9872: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a constant␤at <tmp>:22␤Exception details:␤  Could not find symbol '&Callback'␤    in block  at <tmp> line 22␤␤»

[01:37] *** Actualeyes left
[01:39] <BenGoldberg> m: https://gist.github.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359

[01:39] <camelia> rakudo-moar ef9872: OUTPUT: «===SORRY!===␤QAST::Block with cuid 9 has not appeared␤»

[01:40] *** cdg joined
[01:40] <BenGoldberg> .tell Zoffix There is no whatever-anything in the code: https://gist.github.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359

[01:40] <yoleaux> BenGoldberg: I'll pass your message to Zoffix.

[01:40] <MasterDuke> BenGoldberg: fyi, the message you should have gotten from your first attempt was `No such method 'mixin' for invocant of type 'Perl6::Metamodel::ParametricRoleGroupHOW'`

[01:46] *** ilbot3 left
[01:47] *** ilbot3 joined
[01:47] *** ChanServ sets mode: +v ilbot3

[01:48] *** mr-foobar left
[01:50] <BenGoldberg> Clearly my code is tickling a lot of bugs.

[01:51] <BenGoldberg> Should I rakudobug camelia producing that '...produced no message...' error?

[01:51] *** mr-foobar joined
[01:53] <BenGoldberg> m: my \foo = Callable but role :: { };

[01:53] <camelia> rakudo-moar ef9872: OUTPUT: «X::Method::NotFound exception produced no message␤  in block <unit> at <tmp> line 1␤␤»

[01:54] *** cioran89 joined
[01:57] *** Zapwai\lettuce left
[01:58] <BenGoldberg> Ok, another rakudobug sent.

[02:04] *** rindolf left
[02:16] <MasterDuke> bisectable6: my \foo = Callable but role :: { };

[02:16] <bisectable6> MasterDuke, Bisecting by output (old=2015.12 new=aa36842) because on both starting points the exit code is 1

[02:16] <bisectable6> MasterDuke, bisect log: https://gist.github.com/c4326d71b14fe555e35b1f3c79f18b26

[02:16] <bisectable6> MasterDuke, (2016-09-27) https://github.com/rakudo/rakudo/commit/222d16b0b94911fdedb06ee6ad817d0f14b9c05c

[02:16] <MasterDuke> bisectable6: old=2016.10 my \foo = Callable but role :: { };

[02:16] <bisectable6> MasterDuke, Bisecting by output (old=2016.10 new=aa36842) because on both starting points the exit code is 1

[02:17] <bisectable6> MasterDuke, bisect log: https://gist.github.com/8e0c9ae50773c16451222dbb30500c68

[02:17] <bisectable6> MasterDuke, (2017-06-01) https://github.com/rakudo/rakudo/commit/c81b7a4b1a1f8a5c0d7c96cdd63a763cb5fd2068

[02:24] *** MasterDuke left
[02:25] *** MasterDuke joined
[02:25] *** cdg left
[02:28] *** aborazmeh joined
[02:28] *** aborazmeh left
[02:28] *** aborazmeh joined
[02:34] *** titsuki_ left
[02:48] *** noganex_ joined
[02:50] *** curt_ left
[02:51] *** aborazmeh left
[02:51] *** noganex left
[02:59] *** Ben_Goldberg joined
[02:59] *** BenGoldberg left
[02:59] *** Ben_Goldberg is now known as BenGoldberg

[03:00] *** aborazmeh joined
[03:00] *** aborazmeh left
[03:00] *** aborazmeh joined
[03:04] *** Cabanossi left
[03:07] *** Cabanossi joined
[03:11] <BenGoldberg> bisectable6, https://gist.github.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359

[03:12] <BenGoldberg> bisectable6: https://gist.github.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359

[03:12] <bisectable6> BenGoldberg, It looks like a URL, but mime type is ‘text/html; charset=utf-8’ while I was expecting something with ‘text/plain’ or ‘perl’ in it. I can only understand raw links, sorry.

[03:12] <BenGoldberg> bisectable6: https://gist.githubusercontent.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359/raw/2dfc63bd6c88c97980f673fa09778102f3a993a7/Callback-fail.pl

[03:12] <bisectable6> BenGoldberg, Successfully fetched the code from the provided URL.

[03:12] <bisectable6> BenGoldberg, Bisecting by output (old=2015.12 new=61ecfd5) because on both starting points the exit code is 1

[03:13] <bisectable6> BenGoldberg, bisect log: https://gist.github.com/5b6fa52548a25ae0cd6d0531f58f77eb

[03:13] <bisectable6> BenGoldberg, (2015-12-25) https://github.com/rakudo/rakudo/commit/07fecb52eb1fd07397659f19a5cf36dc61f84053

[03:13] <bisectable6> BenGoldberg, The result looks a bit unrealistic, doesn't it? Most probably the output is different on every commit (e.g. ｢bisect: say rand｣)

[03:18] <BenGoldberg> Silly bot, it's different on every commit because memory is being corrupted somehow.  Probably.

[03:19] <BenGoldberg> j: say 'alive';

[03:19] <camelia> rakudo-jvm 61ecfd: OUTPUT: «alive␤»

[03:19] <BenGoldberg> j: https://gist.github.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359

[03:19] <camelia> rakudo-jvm 61ecfd: ( no output )

[03:20] <BenGoldberg> wtf?  When I /msg-ed camelia, it errored with: rakudo-jvm 61ecfd: OUTPUT: «java.nio.file.NoSuchFileException: blib/Perl6/BOOTSTRAP.jar␤  in <anon> (gen/jvm/ModuleLoader.nqp:88)␤  in load_module (gen/jvm/ModuleLoader.nqp:75)␤  in <anon> (gen/jvm/CORE.setting)␤  in <anon> (gen/jvm/ModuleLoader.nqp:253)␤  in load_setting …»

[03:21] <BenGoldberg> j: https://gist.github.com/BenGoldberg1/d0764293ed61d1635056ed549f4bc359

[03:21] <camelia> rakudo-jvm 61ecfd: OUTPUT: «java.nio.file.NoSuchFileException: blib/Perl6/BOOTSTRAP.jar␤  in <anon> (gen/jvm/ModuleLoader.nqp:88)␤  in load_module (gen/jvm/ModuleLoader.nqp:75)␤  in <anon> (gen/jvm/CORE.setting)␤  in <anon> (gen/jvm/ModuleLoader.nqp:253)␤  in load_setting …»

[03:33] <zengargo1le> BenGoldberg: do the bots understand the gist url that isn't pointing to the raw blob?

[03:36] *** Cabanossi left
[03:37] *** Cabanossi joined
[03:44] <raschipi> zengargo1le: No, they complain it isn't raw text.

[03:45] *** khw left
[03:49] <Geth> ¦ ecosystem: e110a287cf | (Zoffix Znet)++ (committed using GitHub Web editor) | META.list

[03:49] <Geth> ¦ ecosystem: Add Proc::Q to ecosystem

[03:49] <Geth> ¦ ecosystem: 

[03:49] <Geth> ¦ ecosystem: "Queue up and run a herd of Procs": https://github.com/zoffixznet/perl6-Proc-Q

[03:49] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/e110a287cf

[03:50] *** troys_ is now known as troys

[04:06] *** klapperl_ joined
[04:07] *** klapperl left
[04:10] *** aborazmeh left
[04:18] <pilne> as someone who used to heal in world of warcraft.. herding procs made me think of herding cats, lol.

[04:19] *** mr-foobar left
[04:19] <BenGoldberg> You can get procs to all move in the same direction, or at least work on the same task.  Cats, not so much.

[04:20] <pilne> believe me... if i had a nickle for every time i communicated "get your fucking ass out of the fucking fire" in one way or another on that game... i'd be rich enough to be unknown

[04:20] *** mr-foobar joined
[04:23] <raschipi> The usual problem with procs is the exact opposite: they do EXACTLY what you told them to do.

[04:24] <pilne> yeah, computers are funny like that

[04:24] <raschipi> Most of the time, it's the wrong thing. We call it a bug.

[04:24] <pilne> unless you are treading into "undefined behavior" territory

[04:25] <raschipi> There's not 'undefined behavior' for CPU, everything comes down to that at some point.

[04:25] <geekosaur> ob F0 0F C7 C8

[04:26] <geekosaur> (CPUs have bugs too. also ancient CPUs often didn't control what unassigned opcodes did at all...)

[04:27] <pilne> yeup

[04:27] <pilne> ahhhhh the good old days

[04:27] <raschipi> Well, those are defined... by the silicon. The docs and specs might not mention it, but the silicon will do something deterministic.

[04:28] <raschipi> Well, interrupts aren't deterministic. And the interaction in the bus too.

[04:28] <geekosaur> "deterministic" but often based on the exact stepping. and you couldn't even query that (no such thing as CPUID back then)

[04:28] <raschipi> "Which core get's to the varible first" isn't deterministic.

[04:29] <BenGoldberg> Also, there are such things as hardware random number generators.  What numbers such a generator will produce, are generally the opposite of deterministic.

[04:30] <geekosaur> (also at some point this just turne into trolling...)

[04:30] <geekosaur> *turns

[04:30] * zengargo1le has wondered why hardware RNG aren't common in everything.  if a dongle can do it why not have it already built in?

[04:31] <pilne> paranoia

[04:31] <raschipi> Well, almost every IO device will act as a RNG. When there's no dedicated RNG, Linux uses almost all IO it can measure to generate entropy, for example.

[04:31] <raschipi> zengargo1le: Every TPM module comes with one. You can also turn the sound card into one if you have no other use for it.

[04:33] <zengargo1le> i'm thinking of those things that catch cosmic particles hitting one side or the other of some sort of detector type of thing.  does TPM use that sort of thing?

[04:35] * zengargo1le just notices my nick got whacked at some point.

[04:35] *** zengargo1le is now known as zengargoyle

[04:35] *** Cabanossi left
[04:37] *** Cabanossi joined
[04:38] <raschipi> zengargoyle: They use a quantum source of entropy: the noise at the base of a reverse biased transistor. It fluctuates randomly because electrons will tunnel through the gap.

[04:42] <zengargoyle> ah, cool.

[04:45] <zengargoyle> may have to read up on that.  guess it's still a slow stream of entropy or we would no longer have PRNG at all?

[04:48] *** BenGoldberg left
[04:50] *** mr-foobar left
[04:52] *** mr-foobar joined
[05:01] <raschipi> If you need more, just use more transistors. Transistors are what chips have in abundance.

[05:05] <TEttinger> zengargoyle: intel has a hardware RNG on many of their processors but several linux and/or BSD distros have stopped using it out of concern that it may be intentionally flawed

[05:05] <fatguy> how can i get package and method name from caller ? let say i call method print-it("bla"). from my origin class i need to know where the caller is

[05:06] <TEttinger> https://en.wikipedia.org/wiki/RdRand

[05:17] *** fatguy left
[05:20] *** Cabanossi left
[05:20] *** mr-foobar left
[05:20] <zengargoyle> TEttinger++

[05:22] <Geth> ¦ doc: 4f2611be57 | (Samantha McVey)++ | doc/Type/Str.pod6

[05:22] <Geth> ¦ doc: .subst: give examples on how to use captures

[05:22] <Geth> ¦ doc: 

[05:22] <Geth> ¦ doc: Hopefully this will help others out, as it is somewhat counterintuitive.

[05:22] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/4f2611be57

[05:22] <samcv> ok. i finally got fed up and added this to the docs XD

[05:22] <zengargoyle> rand came up a few days ago and my grep led me to believe that it boils down to libtommath (a bunch of math routines for primes and such) which uses arc4something() or rand() depending on availability.

[05:22] <samcv> because i always forgot it

[05:22] *** Cabanossi joined
[05:22] *** mr-foobar joined
[05:22] <samcv> yeah something like that zengargoyle 

[05:25] <zengargoyle> it all seems to still be a good entropy seed to some crypto generator (re-seeded at intervals by some logic) vs some actual true endless fast fount of random bits. :)

[05:26] <samcv> so good then?

[05:26] *** pilne left
[05:27] <zengargoyle> good enough for my Lotto number picks.

[05:27] <samcv> you may know more about the intricacies of random number generating than i do

[05:28] <TEttinger> man, that's what I've been up to lately

[05:29] <TEttinger> I have a pretty fast 64-bit one now with what seems to be decent quality but a lousy period for its amount of state (128 bits)

[05:29] <TEttinger> 2 to the 65 period probably, no lower than 2 to the 64

[05:30] <TEttinger> well, pretty fast for software as in "twice as fast as an LCG, at least with the JVM's weird optimization properties"

[05:32] <zengargoyle> TEttinger: you may know more about the intricacies of random number generating than i do  :P

[05:36] <TEttinger> this stuff is fun for me. I have a system set up to repeatedly generate random 24-bit numbers and use them as colors, like here http://i.imgur.com/fpn0Wrq.png

[05:36] <TEttinger> if there's a flaw, it's pretty easy to pick up, also in black/white http://i.imgur.com/4biF98x.png

[05:38] <TEttinger> this series tested various intentionally flawed RNGs http://i.imgur.com/4H5VXcP.jpg

[05:38] <samcv> i still don't know why .grep(:v ) is the same as default

[05:38] <samcv> v

[05:38] <samcv> Only return the matched elements (same as not specifying any named parameter at all).

[05:39] <samcv> where all greps always have grep -v is reversed

[05:39] <samcv> only return non-matching

[05:39] <samcv> so i guess you need :!v ?

[05:39] <zengargoyle> worst magic-eye ever. 

[05:39] <samcv> still odd

[05:39] <TEttinger> hehe

[05:41] <hobbs> :!v is definitely a face

[05:41] <hobbs> with a pencil up its nose, possibly

[05:43] <zengargoyle> pencil balanced on pursed lips about to fall.

[05:46] *** Actualeyes joined
[05:49] *** mr-foobar left
[05:51] *** mr-foobar joined
[05:52] *** wamba joined
[05:58] *** troys is now known as troys_

[05:59] *** araraloren_ joined
[06:03] *** araraloren left
[06:05] *** webart left
[06:07] *** grondilu joined
[06:09] *** grondilu_ left
[06:09] *** atta left
[06:09] *** atta joined
[06:14] <zengargoyle> is there a better list of bots/commands than found on https://perl6.org/community/irc?  

[06:15] <samcv> see all the users that have voice

[06:15] <samcv> those are bots

[06:16] <samcv> so i have `my (%hash, @array) = myfunction; sub myfunction { return %hash, @array }

[06:16] <samcv> i get Odd number of elements found where hash initializer expected:

[06:16] <samcv> it works fine when i only have it return a hash

[06:16] <samcv> so i guess those are somehow coming together.. ack reminds me of perl 5 horrors i've experienced

[06:18] <samcv> i think actually it's `return %hash, @array.sort.unique` so it's likely returning a sequence. that could be what's causing this

[06:18] <samcv> though using .list doesn't improve the situation

[06:19] <zengargoyle> i'd try .Array but it's just a guess.

[06:19] <samcv> that's not a method :P

[06:19] <samcv> err. wait it is

[06:19] <samcv> heh. let me try it

[06:19] <zengargoyle> m: (1,2,3).Array

[06:19] <camelia> rakudo-moar 61ecfd: ( no output )

[06:20] <zengargoyle> m: (1,2,3).Array.say

[06:20] <camelia> rakudo-moar 61ecfd: OUTPUT: «[1 2 3]␤»

[06:20] <samcv> ok now something really weird happened

[06:20] <samcv> eek. well i'll be back in like 20 mins or so

[06:20] *** nadim joined
[06:22] * zengargoyle tends to slap on a .Array whenever some error pops up (esp. Seq errors).  gah, i think i haven't wrapped my head around Seq yet.

[06:28] <raschipi> zengargoyle: That's almost the appropriate way of doing it, but there's an specific method to do it: .cache (https://docs.perl6.org/routine/cache)

[06:30] <zengargoyle> heh

[06:30] <zengargoyle>  method cache(--> TODO)

[06:32] *** webart joined
[06:32] <zengargoyle> guess this is more relevant: method cache(PositionalBindFailover:D: --> List:D)

[06:33] <raschipi> The lower section explains what it does: turns an iterator into a list. Just don't call it on infinite or ver long lazy lists. It will eat all of your memory. P6 doesn't do it automatically because it can't know which lists will grow to much and turn out impossible to fit into memory.

[06:33] <raschipi> Even if you got infinite memory, it will take infinite time to fill it up.

[06:34] <zengargoyle> yeah, favorite recent bug-fix was along the lines of "no longer segfaults, will consume all available memory instead" :)

[06:35] <zengargoyle> just like you told it to.

[06:36] *** Cabanossi left
[06:37] *** Cabanossi joined
[06:39] <raschipi> Seqs are annoying sometimes, but they are very useful. The GC can reap the part that was already dealt with and allow much bigger problems to fit into memory.

[06:39] <raschipi> Easier than having to do it by hand.

[06:39] <zengargoyle> other than the almost always "X is Y% faster when Z"

[06:40] <nine> m: sub func { my %h = a => 1, b => 2; my @a = 1, 2, 3; return %h, @a}; my (%h, @a) := func; say %h; say @a;

[06:40] <camelia> rakudo-moar 61ecfd: OUTPUT: «{a => 1, b => 2}␤[1 2 3]␤»

[06:40] <nine> samcv: ^^^

[06:40] <zengargoyle> true, i'm just not used to lazy stuff.

[06:41] <zengargoyle> and it tends to bite me in the a** all the time.

[06:42] <TEttinger> abs

[06:42] <TEttinger> muscular abdominal muscles

[06:42] <zengargoyle> nine: is it the bind?

[06:43] <zengargoyle> m: sub func { my %h = a => 1, b => 2; my @a = 1, 2, 3; return %h, @a}; my (%h, @a) = unc; say %h; say @a;

[06:43] <camelia> rakudo-moar 61ecfd: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    unc used at line 1. Did you mean 'uc', 'func'?␤␤»

[06:43] <zengargoyle> m: sub func { my %h = a => 1, b => 2; my @a = 1, 2, 3; return %h, @a}; my (%h, @a) = func; say %h; say @a;

[06:43] <camelia> rakudo-moar 61ecfd: OUTPUT: «Odd number of elements found where hash initializer expected:␤Found 5 (implicit) elements:␤Last element seen: $[1, 2, 3]␤  in block <unit> at <tmp> line 1␤␤»

[06:45] <zengargoyle> guess so. bind is another thing that i haven't quite internalized yet.

[06:46] * zengargoyle expected the = to work

[06:50] <nine> zengargoyle: yes

[06:51] <nine> Collections like hashes and arrays are slurpy on assignment. That's why the hash tries to gobble the array and complains.

[06:52] <zengargoyle> m: sub func { my %h = a => 1, b => 2; my @a = 1, 2, 3, 4; return %h, @a}; my (%h, @a) = func; say %h; say @a;

[06:52] <camelia> rakudo-moar 61ecfd: OUTPUT: «Odd number of elements found where hash initializer expected:␤Found 5 (implicit) elements:␤Last element seen: $[1, 2, 3, 4]␤  in block <unit> at <tmp> line 1␤␤»

[06:53] <zengargoyle> m: sub func { my %h = a => 1, b => 2; my @a = 1, 2, 3, 4; return %h, @a}; my (%h) = func; say %h;

[06:53] <camelia> rakudo-moar 61ecfd: OUTPUT: «Odd number of elements found where hash initializer expected:␤Found 5 (implicit) elements:␤Last element seen: $[1, 2, 3, 4]␤  in block <unit> at <tmp> line 1␤␤»

[06:53] <raschipi> m: my @a = 1, 2, 3, 4; my %h = @a; say %h;

[06:53] <camelia> rakudo-moar 61ecfd: OUTPUT: «{1 => 2, 3 => 4}␤»

[06:53] <raschipi> m: my @a = 1, 2, 3, 4, 5; my %h = @a; say %h;

[06:53] <camelia> rakudo-moar 61ecfd: OUTPUT: «Odd number of elements found where hash initializer expected:␤Found 5 (implicit) elements:␤Last element seen: 5␤  in block <unit> at <tmp> line 1␤␤»

[06:53] *** wamba left
[06:54] <nine> Itemized array coming from the "return" vs. plain array.

[06:55] <zengargoyle> i was guessing the pairs prime the return to expect pairs and the array mucked things up

[06:55] <zengargoyle> but guess not.

[06:56] <nine> The error message actually tells it quite clearly: Last element seen: $[1, 2, 3, 4]

[06:57] <zengargoyle> ah

[06:57] <zengargoyle> m: my %h = 1 => 2, 3, 4; say %h

[06:57] <camelia> rakudo-moar 61ecfd: OUTPUT: «{1 => 2, 3 => 4}␤»

[06:57] <zengargoyle> m: my %h = 1 => 2, [3, 4]; say %h

[06:57] <camelia> rakudo-moar 61ecfd: OUTPUT: «Odd number of elements found where hash initializer expected:␤Found 3 (implicit) elements:␤Last element seen: $[3, 4]␤  in block <unit> at <tmp> line 1␤␤»

[06:57] <raschipi> m: my %h := 1 => 2, [3, 4]; say %h

[06:57] <camelia> rakudo-moar 61ecfd: OUTPUT: «Type check failed in binding; expected Associative but got List ($(1 => 2, [3, 4]))␤  in block <unit> at <tmp> line 1␤␤»

[06:59] <raschipi> This last one is a type check failure, which means we're violating a promise we made to the compiler.

[06:59] <zengargoyle> why is the hash not also itemized?  

[07:00] *** darutoko- joined
[07:01] <zengargoyle> why is %h not { a => 1, b => 2 } => [ 1, 2, 3 ]

[07:05] <raschipi> P6 doesn't mangle structures like that, it keeps everything tidy.

[07:06] <raschipi> Lists don't end um mixed or flatened.

[07:07] <zengargoyle> then it seems (%h,@a) = (%x,@y) should work.

[07:08] <raschipi> Asignement calls a method on the object in the righ hand side, and hash doesn't know what to do with a odd-numbered list.

[07:08] <raschipi> On the left hand, even.

[07:10] <zengargoyle> m: my ($h, @a) = ( { a => 'b' }, 1 ); say $h; say @a;

[07:10] <camelia> rakudo-moar 61ecfd: OUTPUT: «{a => b}␤[1]␤»

[07:10] <nine> zengargoyle: the sad truth is that hashes are flattened more easily than lists. Feels like a bit of an oversight during the GLR.

[07:11] <zengargoyle> m: my ($h, @a) = ( { a => 'b' }, [1,2,3] ); say $h; say @a;

[07:11] <camelia> rakudo-moar 61ecfd: OUTPUT: «{a => b}␤[[1 2 3]]␤»

[07:11] <zengargoyle> nine: gotcha

[07:14] <raschipi> Is 6.d the opportunity to fix that?

[07:16] <zengargoyle> hopefully only if they can keep 6.c vs 6.d semantics about the same way p5 only changes if asking for the new stuff.

[07:16] * zengargoyle still miffed that { use 6.c; ...old-code...} didn't fix my IO breakage.

[07:17] <raschipi> I think the idea is to keep everything that asks for 6.c at the top working.

[07:17] <zengargoyle> but not that miffed.

[07:17] <nine> The idea is good but object orientation puts a severe limit on that

[07:18] <zengargoyle> yeah, best effort is fine by me no matter my complaining. :)

[07:18] <raschipi> Use 6.c inside a block could help with syntax changes, but the objects have global state.

[07:19] <nine> It's downright trivial to have the compiler bind to the right await sub depending on the language version. But methods are late bound. It doesn't at all depend on the caller of which method is found but on the object the method is called on.

[07:19] <raschipi> Their dispatch tables are global.

[07:19] *** lizmat joined
[07:20] <zengargoyle> yeah,IO is a thing unto itself.

[07:21] <raschipi> zengargoyle: Doesn't have anything to do with IO, :) . It would be the same for any object.

[07:23] <zengargoyle> just breaks my ask for 6.c get 6.c expectations and maybe future compatibility.  p5 did the same thing around 5.10 or so bringing about all of the 'experimental' and 'feature' stuff.

[07:24] <zengargoyle> how much legacy do you want to support with minimal tweak of asking for the old behavior?

[07:24] <raschipi> You have to keep in mind that these versions are for the language, for the syntax, but that the breaking changes were made in a library.

[07:25] <raschipi> The way to fix that would be to create objects with multiple interfaces.

[07:26] <raschipi> Adding a :old-model adverb to IO or something. But then, standard handles already start instantiated.

[07:26] <zengargoyle> eh, my breakage was simple IO.  but point taken, the boundry is fuzzy.

[07:28] <raschipi> It's like the difference between GCC and LibC.

[07:28] <nine> Would be all doable. But what the heck should happen if 6.d code passes an IO::Path object to 6.c code?

[07:28] <zengargoyle> and it was really just like one line of testing code.

[07:29] <raschipi> nine: croak

[07:30] <zengargoyle> hehe, you can wrap a Python interpreter's object in a p6 object.  nothing is impossible!   (just not worth it)

[07:30] <zengargoyle> and i'd rather the effort be spent elsewhere ATM anyway.

[07:31] * zengargoyle just musing on how awesome it would be if it actually did do that thing.

[07:34] <nine> Actually it should even be possible for a method to ask for its caller's language version. This is Perl 6 after all ;) It just would be quite bad for performance and for maintainability of the code...

[07:35] <raschipi> nine: I see where the problem is now, the 6.c and 6.d code are from different authors.

[07:36] <raschipi> And these methods are intermingled in with the operating system and represent things people just expect to be there. It wouldn't be so hard if people had to set up their IO instead of just using it.

[07:37] <zengargoyle> yeah, i give wide berth when you hit IO or some other systemy thing vs just high-level syntax.

[07:42] <zengargoyle> i hope things settle down by 6.e or 6.f where it becomes "if it worked it still does" (most likely).

[07:44] <raschipi> The good news is that the same companies that are paying for P6 development are the ones paying for P5 development, so they will want the same guarantees eventually.

[07:45] <nine> Well IO was an area that lagged behind the rest of the setting when we released 6.c. There was bound to be some changes.

[07:50] *** Cabanossi left
[07:52] *** Cabanossi joined
[08:02] *** zengargoyle is now known as zengargoyle_

[08:14] *** araraloren_ is now known as araraloren

[08:19] *** mr-foobar left
[08:22] *** mr-foobar joined
[08:28] *** setty1 joined
[08:31] *** parv joined
[08:47] <El_Che> for Spanish speakers, the Madrid Perl Workshop has live streaming: https://www.youtube.com/watch?v=JDOykNlrJ5k&feature=youtu.be (There seems to be 1 on englis hat 15h CET: http://madrid.pm.org/workshop/page/talks/kritika-io.html#top)

[08:47] *** raschipi left
[08:49] *** mr-foobar left
[08:51] *** mr-foobar joined
[08:59] *** TEttinger left
[09:11] *** pminten joined
[09:12] *** rindolf joined
[09:13] <pminten> hi, is it possible to define a custom character class?

[09:13] <pminten>     <:L + :N + :P + :S - :Z - [(),=:.~?"%]>

[09:13] <pminten> I want to reuse that

[09:14] <pminten> because I have a regex / <$that - :Lu> $that * /

[09:14] <rightfold> You can define a custom regex and then use that regex within another regex

[09:15] <rightfold> Oh I'm not sure you can do that

[09:16] <pminten> yeah, the regex including doesn't work inside char classes so I can't use the set operations

[09:17] *** TimToady left
[09:19] *** TimToady joined
[09:20] *** mr-foobar left
[09:21] *** mr-foobar joined
[09:22] *** AlexDaniel joined
[09:36] *** setty1 left
[09:39] *** setty1 joined
[09:40] *** kyan left
[09:44] *** vimal2012 joined
[09:51] <samcv> is this supposed to work? https://a.uguu.se/kYCTenCQkEMF_Screenshot_20170603_024931.png

[09:51] <samcv> and if so why. cause it does work. returning itself on initialization

[09:53] <hobbs> don't see why it wouldn't

[09:53] *** lizmat left
[09:53] <samcv> m: my $a = foo; sub foo { $a = 100; return $a }; say $a;

[09:53] <camelia> rakudo-moar 61ecfd: OUTPUT: «100␤»

[09:54] <hobbs> it's unnecessary (either the function should have its own lexical, or if it's going to assign to an outer one, it doesn't have to also return it)

[09:54] <hobbs> but it's the same effect as my %pnamecode; make-name-alias-hash(...); %pnamecode = %pnamecode;

[09:54] <samcv> i never declare it inside the sub though

[09:55] <samcv> so it must use the outer one

[09:55] <hobbs> yes

[09:57] <samcv> m: my $a = foo; sub foo { $a = 100; return 10 }; say $a

[09:57] <camelia> rakudo-moar 61ecfd: OUTPUT: «10␤»

[09:57] <samcv> though this also works too

[09:57] <hobbs> which is in-scope, it hasn't been assigned to yet (because make-name-alias-hash hasn't returned yet ;) but it's still usable as a container, same as if it didn't have an initialization at all.

[09:58] <hobbs> I don't know if it's guaranteed, but it's the behavior I'd expect

[09:58] <samcv> anyway thanks for helping me underertasd it

[09:58] <hobbs> then when the assignment part of the initialization does complete, it effectively does nothing

[10:04] *** avalenn_ left
[10:06] <hobbs> the equivalent code in perl 5 would behave the same, FWIW, so my expectations are already set ;)

[10:06] *** pminten left
[10:09] *** robertle left
[10:20] *** lizmat joined
[10:28] <nine> The declaration of $a happens at compile time, so during compilation of sub foo, it's already known. So indeed foo refers to the container named '$a'. When _running_ the assignment, first sub foo is called, which already assigns to $a and then returns a value which again gets assigned to $a

[10:43] *** dogbert17_ joined
[10:45] *** dogbert11 left
[10:47] *** parv left
[10:49] *** mr-foobar left
[10:53] *** mr-foobar joined
[10:57] *** vimal2012 left
[10:57] *** vimal2012 joined
[10:59] <vimal2012> What is the practical use of sigilless variable?  Why would one want to use sigilless variable over sigilled one?

[11:06] <llfourn> vimal2012: I think sometimes it's a decent way to indicate that you don't want to have a variable with a container

[11:06] <llfourn> or more simply is read only

[11:06] <llfourn> m: my \foo = "foo"; foo = "bar";

[11:06] <camelia> rakudo-moar 61ecfd: OUTPUT: «Cannot modify an immutable Str (foo)␤  in block <unit> at <tmp> line 1␤␤»

[11:07] <llfourn> so it tells the reader that you aren't going to modify the variable after declaration

[11:08] <llfourn> unless there's a particular reason you want to point that I wouldn't use them

[11:13] <jnthn> They're also useful in the cases where you don't want to enforce any kind of context

[11:15] <jnthn> my \matching = $fh.lines.grep(&condition).map(&operation); for matching { } # Will iterate the lazy pipeline, discarding values, so using little memory on a large file

[11:15] <jnthn> my $matching = $fh.lines.grep(&condition).map(&operation); for $matching { } # Only does one iteration, because $ means item

[11:16] <jnthn> my @matching = $fh.lines.grep(&condition).map(&operation); for @matching { } # assignment is mostly eager, so will store all the matching lines in @matching before doing the iteration

[11:16] <jnthn> This means if you're constructing lazy processing pipelines they are also a pretty good choice.

[11:19] *** curt_ joined
[11:20] *** Cabanossi left
[11:20] *** mr-foobar left
[11:22] *** Cabanossi joined
[11:23] *** MARTIMM joined
[11:25] <MARTIMM> m:sub s (Str :$str) {say $str.WHAT};s('1')

[11:25] <evalable6> MARTIMM, rakudo-moar 61ecfd511: OUTPUT: «(exit code 1) Too many positionals passed; expected 0 arguments but got 1␤  in sub s at /tmp/GVw_XG8kbF line 1␤  in block <unit> at /tmp/GVw_XG8kbF line 1␤»

[11:25] *** mr-foobar joined
[11:27] <MARTIMM> m: sub s (Str :$str) {say $str.WHAT}; s('1');

[11:27] <camelia> rakudo-moar 61ecfd: OUTPUT: «Too many positionals passed; expected 0 arguments but got 1␤  in sub s at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:28] <jnthn> :$str is a named argument

[11:29] <araraloren> m:sub s (Str :$str) {say $str.WHAT};s(a => '1')

[11:29] <evalable6> araraloren, rakudo-moar 61ecfd511: OUTPUT: «(exit code 1) Unexpected named argument 'a' passed␤  in sub s at /tmp/EuwaLPG4p_ line 1␤  in block <unit> at /tmp/EuwaLPG4p_ line 1␤»

[11:29] <MARTIMM> m: sub s (Str :$str) {say $str.WHAT}; s(:str<1>);

[11:29] <camelia> rakudo-moar 61ecfd: OUTPUT: «(IntStr)␤»

[11:29] <araraloren> m:sub s (Str :$str) {say $str.WHAT};s(str => '1')

[11:29] <evalable6> araraloren, rakudo-moar 61ecfd511: OUTPUT: «(Str)»

[11:29] *** TeamBlast left
[11:30] <MARTIMM> @jnthn: thanks, why is it IntStr and not Str

[11:30] <araraloren> m: sub s (Str :$str) {say $str.WHAT};s(str => 1)

[11:30] <camelia> rakudo-moar 61ecfd: OUTPUT: «Type check failed in binding to parameter '$str'; expected Str but got Int (1)␤  in sub s at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:30] <araraloren> m: say <1>.WHAT

[11:30] <camelia> rakudo-moar 61ecfd: OUTPUT: «(IntStr)␤»

[11:30] <jnthn> Because <...> applies val(...) to each of the things it parses

[11:31] <araraloren> m: say '1'.WHAT

[11:31] <camelia> rakudo-moar 61ecfd: OUTPUT: «(Str)␤»

[11:31] <araraloren> It's different things

[11:31] *** TeamBlast joined
[11:35] <MARTIMM> @jnthn: looked up val sub and is undertandable that the result of val is IntStr. But I still don't get it when it assigns to Str that the type of tha variable is changed from Str into IntStr. It should coerce

[11:35] <araraloren> m: say <1> ~~ Str;

[11:35] <camelia> rakudo-moar 61ecfd: OUTPUT: «True␤»

[11:36] <araraloren> IntStr is a Str 

[11:36] <jnthn> MARTIMM: Types in Perl 6 are constraints, not coercions.

[11:36] <MARTIMM> m: IntStr ~~ Str

[11:36] <camelia> rakudo-moar 61ecfd: ( no output )

[11:36] <jnthn> m: say IntStr.^mro

[11:36] <camelia> rakudo-moar 61ecfd: OUTPUT: «((IntStr) (Int) (Str) (Cool) (Any) (Mu))␤»

[11:36] <MARTIMM> m: say IntStr ~~ Str

[11:36] <camelia> rakudo-moar 61ecfd: OUTPUT: «True␤»

[11:36] <MARTIMM> m: say Str ~~ IntStr

[11:36] <camelia> rakudo-moar 61ecfd: OUTPUT: «False␤»

[11:37] <jnthn> IntStr inherits from both Int and Str. The point of this is it can be passed to code that wants a Str or wants an Int

[11:39] *** curt_ left
[11:40] <araraloren> m: sub f(IntStr :$is) { say $is.WHAT; }; try { f(is => "1"); CATCH { say ":("; }; }; f(is => IntStr.new(10, "1"));

[11:40] <camelia> rakudo-moar 61ecfd: OUTPUT: «:(␤Type check failed in binding to parameter '$is'; expected IntStr but got Str ("1")␤  in sub f at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:40] <araraloren> m: sub f(IntStr :$is) { say $is.WHAT; }; f(is => IntStr.new(10, "1"));

[11:40] <camelia> rakudo-moar 61ecfd: OUTPUT: «(IntStr)␤»

[11:40] <araraloren> Oh, It's a error not a exception .

[11:41] <jnthn> lunch; bbl

[11:42] *** ctilmes joined
[11:42] *** vimal2012 left
[11:43] <Geth> ¦ doc: 62137859de | (Jan-Olof Hendig)++ | doc/Language/traps.pod6

[11:43] <Geth> ¦ doc: Changed incorrect mention of nextsame to callsame. jnthn++

[11:43] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/62137859de

[11:50] *** mr-foobar left
[11:51] *** Cabanossi left
[11:52] *** Cabanossi joined
[11:54] *** mr-foobar joined
[12:09] <rightfold> The syntax highlighting for Perl 6 makes Vim extremely slow.

[12:10] <rightfold> Am I using an old version? I am using the version that ships with Vim.

[12:10] <rightfold> What should I upgrade to?

[12:13] <El_Che> https://github.com/vim-perl/vim-perl

[12:13] <rightfold> Should I install https://github.com/vim-perl/vim-perl6?

[12:13] <El_Che> that the latest version

[12:14] <El_Che> not slow at all on Ubuntu 16.04 and 17.04

[12:14] <rightfold> I find this repository confusing.

[12:14] <rightfold> "Support for Perl 5 and Perl 6 in Vim"

[12:14] <rightfold> "This is the aggregation of all the various Perl-related syntax and helper files for Perl 5. For Perl 6 files, please see vim-perl6."

[12:15] <El_Che> rightfold: this are the notes of my vim setup: https://nxadm.wordpress.com/2016/08/21/vim-as-a-perl-6-editor/

[12:16] <rightfold> So I do not have to "see vim-perl6"?

[12:16] <El_Che> I haven't had time to work on synastic-perl6, but it works as is

[12:16] <El_Che> rightfold: no

[12:16] <rightfold> OK

[12:16] <rightfold> Thanks

[12:16] <El_Che> just clone it and you're good to go

[12:17] <El_Che> rightfold: on a kind-of-related not, atom is nowaways pretty good for perl6

[12:17] *** Actualeyes left
[12:18] <rightfold> I don't want to use Atom.

[12:19] <El_Che> sure, just fyi

[12:20] <rightfold> Thanks :P

[12:21] *** aborazmeh joined
[12:21] *** aborazmeh left
[12:21] *** aborazmeh joined
[12:26] <rightfold> Oh I should probably install Perl 6 too lol

[12:26] <rightfold> Gonna be difficult testing my code otherwise

[12:35] <araraloren> I prefer emacs :)

[12:36] <rightfold> m: '-'.IO.spurt('karate')

[12:36] <camelia> rakudo-moar 77d3c5: OUTPUT: «karate»

[12:36] *** Cabanossi left
[12:36] <rightfold> m: '-'.IO.slurp

[12:36] <camelia> rakudo-moar 77d3c5: OUTPUT: «No such method 'decode' for invocant of type 'Str'. Did you mean 'encode'?␤  in block <unit> at <tmp> line 1␤␤»

[12:36] <rightfold> Is '-' only stdout, not stdin?

[12:37] *** Cabanossi joined
[12:41] *** CacoS joined
[12:41] <timotimo> rightfold: i've experienced problems when there were comments and it'd make vim hang basically indefinitely m(

[12:42] <zengargoyle_> rightfold: have you ever checked out nvim?  i switched way back when because it was faster at syntax highlighting and checking than vim (around the 7.0 era).

[12:44] <rightfold> oh '-'.IO.lines works, but '-'.IO.slurp doesn't

[12:44] <zengargoyle_> it was the whole async thing that i think maybe vim 8 does now, highlighting, make/perltidy/perlcritic on write, etc. are threads so no delays.

[12:45] <rightfold> I don't use any code analysis or building features in Vim

[12:45] <rightfold> My setup is a tiling window manager where one of the terminals houses a file watcher that does the analysis and building

[12:45] <rightfold> It is less distracting than constantly moving frames and squiggly lines and popups

[12:49] <zengargoyle_> gotcha, nvim still seemed to do highlighting faster or at least in a way that didn't interfere with typing.  depends on whether your issue is with slowness or with flakey highlighting as a whole.

[12:49] *** geekosaur left
[12:50] <zengargoyle_> i do the notify test thing too, but floating stacked windows rule. :P

[12:51] * zengargoyle_ needs to check out vim 8 again but hasn't had any problem and only smoother experience from nvim.

[12:52] *** geekosaur joined
[12:52] *** kaare_ left
[12:57] *** khw joined
[12:59] * zengargoyle_ wonders if Damien Conway has a set of perl6 vim doodads.  some of his p5 vim doodads are freakin' awesome.

[13:02] <El_Che> rightfold: I have pkgs available if you run Ubuntu, Debian, Centos or Fedora: https://github.com/nxadm/rakudo-pkg/releases/

[13:03] <zengargoyle_> El_Che: does atom have vim bindings?  i have really been meaning to actually try it for various reasons.

[13:07] <El_Che> zengargoyle_: there are some plugins

[13:10] <zengargoyle_> heh, El_Che i recognize your blog styling... so i've probably read a few of your posts here and there. :)

[13:12] <Geth> ¦ doc: b72d7cbcd1 | (Zoffix Znet)++ | doc/Language/operators.pod6

[13:12] <Geth> ¦ doc: Improve `orelse` docs

[13:12] <Geth> ¦ doc: 

[13:12] <Geth> ¦ doc: - More details on what happens to the last arg

[13:12] <Geth> ¦ doc: - More details on the expected Callables

[13:12] <Geth> ¦ doc: - Add tip this is a useful Failure handler

[13:12] <Geth> ¦ doc: - Add code examples

[13:12] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/b72d7cbcd1

[13:17] <Geth> ¦ doc: 7c2d4a5b34 | (Zoffix Znet)++ | doc/Language/operators.pod6

[13:17] <Geth> ¦ doc: Improve `andthen` docs

[13:17] <Geth> ¦ doc: 

[13:17] <Geth> ¦ doc: - Add more info on what happens to the last arg

[13:17] <Geth> ¦ doc: - Add info on the expected Callable

[13:17] <Geth> ¦ doc: - Add a tip that this op is handy for handling Failures

[13:17] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/7c2d4a5b34

[13:19] <rightfold> With vim-perl it's still slow

[13:20] *** mr-foobar left
[13:23] *** mr-foobar joined
[13:24] *** rindolf left
[13:24] *** titsuki joined
[13:26] *** domidumont joined
[13:35] *** Cabanossi left
[13:36] *** mst left
[13:36] *** mst joined
[13:37] *** Cabanossi joined
[13:37] *** mcmillhj joined
[13:47] <Geth> ¦ doc: 945ae9b4a7 | (Zoffix Znet)++ | doc/Language/operators.pod6

[13:47] <Geth> ¦ doc: Link to &defined from andthen docs

[13:47] <Geth> ¦ doc: 

[13:47] <Geth> ¦ doc: To make it clearer what it checks for

[13:47] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/945ae9b4a7

[13:49] *** aborazmeh left
[13:51] *** domidumont left
[13:55] <MasterDuke> c: all '-'.IO.slurp

[13:57] *** committable6 left
[14:00] *** committable6 joined
[14:00] *** ChanServ sets mode: +v committable6

[14:01] <Voldenet> MasterDuke: $*IN.slurp would probably work too

[14:02] *** sergot joined
[14:03] <MasterDuke> yeah, that works. but '-'.IO.slurp has changed over time

[14:04] *** pilne joined
[14:05] *** setty1 left
[14:06] *** jameslenz left
[14:07] *** jameslenz joined
[14:11] *** aborazmeh joined
[14:11] *** aborazmeh left
[14:11] *** aborazmeh joined
[14:12] *** bisectable6 left
[14:12] *** bisectable6 joined
[14:12] *** ChanServ sets mode: +v bisectable6

[14:15] *** grondilu left
[14:15] <rightfold> I have multi MAIN(IO(Cool) $in = '/dev/stdin', IO(Cool) :$out = '/dev/stdout') now :)

[14:15] *** grondilu joined
[14:15] <rightfold> Instead of '-'

[14:20] <MasterDuke> rightfold: it used to work. i pinged a coupe people in #perl6-dev about it

[14:20] <rightfold> ok :)

[14:20] <MasterDuke> c: 2017.03,2017.04.3 say '-'.IO.slurp

[14:20] <committable6> MasterDuke, https://gist.github.com/3fe6aa0ced80a9a57c749e0cc63b324d

[14:21] <rightfold> Does this bot use random emoji for stdin?

[14:21] <MasterDuke> it just has a selection of letters, numbers, unicode chars, etc

[14:22] <rightfold> ok :)

[14:23] <MasterDuke> https://github.com/perl6/whateverable/blob/master/stdin

[14:23] <rightfold> ah static

[14:23] <Voldenet> Eh, i hate to maintain my own, local git repo with opinionated patches, because of situations when the patches collide with my opinionated changes :<

[14:24] <Voldenet> s/patches/official patches/

[14:24] <MARTIMM> Back again, I'm a slow learner, I understand what jnthn have said before about following

[14:25] <MasterDuke> rightfold: looks like there aren't any tests in roast for reading from '-' as stdin. you could add some...

[14:25] <MARTIMM> <1>.WHATm: 

[14:25] <rightfold> oy vey, I'll take a look

[14:25] <MARTIMM> m: say <1>.WHAT

[14:25] <camelia> rakudo-moar 64e898: OUTPUT: «(IntStr)␤»

[14:25] <rightfold> I also couldn't find docs about '-'.IO

[14:25] <MARTIMM> m: say '1'.WHAT

[14:25] <camelia> rakudo-moar 64e898: OUTPUT: «(Str)␤»

[14:25] <rightfold> stdin nor stdout

[14:26] <Voldenet> rightfold: well, - is just a file in unix

[14:26] <Voldenet> that's stdin

[14:26] <Voldenet> > ls | cat -

[14:26] <rightfold> TIL

[14:26] <MasterDuke> rightfold: heh, could also add docs...

[14:26] <rightfold> I thought programs just special-cased it

[14:26] <rightfold> "stat -" works :v

[14:27] <araraloren> MARTIMM++ :)

[14:27] <rightfold> https://unix.stackexchange.com/a/16364/5130

[14:27] <rightfold> Voldenet: ^

[14:28] * MasterDuke is now afk to turn over a garden. yay

[14:28] <Voldenet> rightfold: oh wow, so it's only special-cased almost everywhere :D

[14:28] *** Khisanth left
[14:28] <Voldenet> (in fact I've never had any problems with using that as stdin, so I assumed it's a kernel thingie)

[14:29] <MARTIMM> analoren: thing is that I don't understand the following

[14:29] <MARTIMM> my Str $s = <1>

[14:29] <MARTIMM> say $s.WHAT

[14:29] <evalable6> MARTIMM, rakudo-moar 64e898f9b: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/VoC3HkhBcR␤Variable '$s' is not declared␤at /tmp/VoC3HkhBcR:1␤------> 03say 08⏏04$s.WHAT»

[14:29] <Voldenet> I'd still use $*IN.slurp though, easier to reason about

[14:29] <MARTIMM> my Str $s = <1>; $s.WHAT

[14:30] <MARTIMM> my Str $s = <1>; say $s.WHAT

[14:30] <MARTIMM> m: my Str $s = <1>; say $s.WHAT

[14:30] <camelia> rakudo-moar 64e898: OUTPUT: «(IntStr)␤»

[14:30] <rightfold> Voldenet: the '-' is user input

[14:30] <moritz> m: say $*IN.IO === $*IN

[14:30] <camelia> rakudo-moar 64e898: OUTPUT: «False␤»

[14:30] <rightfold> m: $*IN.IO.perl.say

[14:30] <camelia> rakudo-moar 64e898: OUTPUT: «IO::Special.new(what => "<STDIN>")␤»

[14:30] *** crocodileG joined
[14:30] <MARTIMM> ok, took me awhile, but there it is; $s became IntStr and not Str

[14:31] <araraloren> MARTIMM, it's like parameter constraint 

[14:32] <MARTIMM> I'll have to look that one up. can you give a pointer?

[14:32] <araraloren> Because `<1>` is IntStr, you just make a container hold `<1>`

[14:32] <araraloren> Str is a type constraint

[14:33] <araraloren> m: my $s = <1>; say $s.WHAT;

[14:33] <camelia> rakudo-moar 64e898: OUTPUT: «(IntStr)␤»

[14:33] <araraloren> m: my Int $s = <1>; say $s.WHAT;

[14:33] <camelia> rakudo-moar 64e898: OUTPUT: «(IntStr)␤»

[14:33] <araraloren> m: my Mu $s = <1>; say $s.WHAT;

[14:33] <camelia> rakudo-moar 64e898: OUTPUT: «(IntStr)␤»

[14:34] <MARTIMM> So a type does not have a meaning here in this case I suppose

[14:34] <araraloren> MARTIMM, have you read this : https://docs.perl6.org/language/containers ?

[14:34] <araraloren> m: my Hash $s = <1>; say $s.WHAT;

[14:34] <camelia> rakudo-moar 64e898: OUTPUT: «Type check failed in assignment to $s; expected Hash but got IntStr (IntStr.new(1, "1"))␤  in block <unit> at <tmp> line 1␤␤»

[14:35] <araraloren> It has mean

[14:35] <MARTIMM> I have to reread that section, thanks for the pointer

[14:35] *** Cabanossi left
[14:37] *** Cabanossi joined
[14:42] *** Khisanth joined
[14:46] *** crocodileG left
[14:53] *** MARTIMM left
[15:01] *** rindolf joined
[15:06] *** johnd_perl6 joined
[15:07] <johnd_perl6> p6: say foobar

[15:07] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    foobar used at line 1␤␤»

[15:07] <johnd_perl6> p6:say "foobar";

[15:07] <johnd_perl6> p6: say 3;

[15:07] <camelia> rakudo-moar 64e898: OUTPUT: «3␤»

[15:08] <johnd_perl6> p6: say 'foobar';

[15:08] <camelia> rakudo-moar 64e898: OUTPUT: «foobar␤»

[15:09] <Voldenet> p6: say '/etc/passwd'.IO.slurp

[15:09] <camelia> rakudo-moar 64e898: OUTPUT: «bin:x:1:1:bin:/bin:/bin/bash␤daemon:x:2:2:Daemon:/sbin:/bin/bash␤ftp:x:40:49:FTP account:/srv/ftp:/bin/bash␤games:x:12:100:Games account:/var/games:/bin/bash␤lp:x:4:7:Printing daemon:/var/spool/lpd:/bin/bash␤mail:x:8:12:Mailer daemon:/var/spool…»

[15:09] <Voldenet> ┐(´～`；)┌ 

[15:10] <johnd_perl6> p6:my @fibonnaci = 1, 1, {^$a + ^$b} ... *;

[15:10] <Geth> ¦ doc: a2d1733296 | (Zoffix Znet)++ | doc/Language/operators.pod6

[15:10] <Geth> ¦ doc: Use C<> for code in text

[15:10] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/a2d1733296

[15:10] <johnd_perl6> p6: say @fibonacci[6];

[15:10] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@fibonacci' is not declared␤at <tmp>:1␤------> 3say 7⏏5@fibonacci[6];␤»

[15:10] <Geth> ¦ doc: 5ff8befec3 | (Zoffix Znet)++ | doc/Language/operators.pod6

[15:10] <Geth> ¦ doc: Document notandthen

[15:10] <Geth> ¦ doc: 

[15:10] <Geth> ¦ doc: I refuse to play your Chinese Food mind games!

[15:10] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/5ff8befec3

[15:11] <Voldenet> p6: my @fib = 1, 1, * + * ... Inf; say @fib[6];

[15:11] <camelia> rakudo-moar 64e898: OUTPUT: «13␤»

[15:11] <Voldenet> but actually

[15:11] <Voldenet> p6: my @fib = 0, 1, * + * ... Inf; say @fib[6];

[15:11] <camelia> rakudo-moar 64e898: OUTPUT: «8␤»

[15:11] <johnd_perl6> p6: my @fib = 1, 1, {^$a + ^$b} ... *; say @fib[6]

[15:11] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$a' is not declared␤at <tmp>:1␤------> 3my @fib = 1, 1, {^7⏏5$a + ^$b} ... *; say @fib[6]␤»

[15:12] *** kaare_ joined
[15:12] <johnd_perl6> p6: my @fib = 1, 1, {$^a + $^b} ... *; say @fib[6];

[15:12] <camelia> rakudo-moar 64e898: OUTPUT: «13␤»

[15:13] <johnd_perl6> p6: my @fib = 1, 1, {$^a + $^b} ... *; say @fib[16];

[15:13] <camelia> rakudo-moar 64e898: OUTPUT: «1597␤»

[15:13] <johnd_perl6> p6: my @fib = 1, 1, {$^a + $^b} ... *; say @fib[600];

[15:13] <camelia> rakudo-moar 64e898: OUTPUT: «178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601␤»

[15:13] <Voldenet> ;D

[15:13] <Voldenet> unexpectably fast

[15:15] <johnd_perl6> p6: my @fib = 1, 1, {$^a + $^b} ... *; say @fib[6000];

[15:15] <camelia> rakudo-moar 64e898: OUTPUT: «61002008991510192252609003226598130375096219309442191900486835682890258650986409694193881623806381048629260422531750253466153164177574080996385252429749849585194794556451960621753647848629512663287296069734572044312365909202383479412709492273520813220543…»

[15:16] <johnd_perl6> say 'woah';

[15:16] <evalable6> johnd_perl6, rakudo-moar 64e898f9b: OUTPUT: «woah»

[15:16] *** troys_ is now known as troys

[15:18] *** AlexDani` joined
[15:20] *** mr-foobar left
[15:21] *** johnd_perl6 left
[15:21] *** AlexDaniel left
[15:22] <rightfold> El_Che: I have to actually use vim-perl6

[15:22] <rightfold> vim-perl does not include Perl 6

[15:22] *** mr-foobar joined
[15:25] <Geth> ¦ doc: 56367baa91 | (Jan-Olof Hendig)++ | doc/Language/regexes.pod6

[15:25] <Geth> ¦ doc: Fixed a slightly broken code example. timotimo++

[15:25] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/56367baa91

[15:27] *** wamba joined
[15:29] *** aborazmeh left
[15:31] *** ccntrq left
[15:34] *** ccntrq joined
[15:36] <mst> rightfold: different programming languages tend to have different plugins, yes.

[15:36] <mst> vim-python also does not include perl6 :)

[15:37] *** BenGoldberg joined
[15:37] *** zacts left
[15:50] <rightfold> Voldenet: the typical slowness in fib examples is due to recomputation

[15:50] <rightfold> Just adding numbers, even if they are big, is not slow

[15:51] *** robertle joined
[15:55] *** fatguy joined
[15:58] *** zacts joined
[15:59] <rightfold> m: sub fib($n) { $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }; say fib(20)

[15:59] <camelia> rakudo-moar 64e898: OUTPUT: «10946␤»

[15:59] <rightfold> m: sub fib($n) { $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }; say fib(600)

[15:59] <camelia> rakudo-moar 64e898: OUTPUT: «(timeout)»

[16:02] <rightfold> m: sub fib($n) { state %ns; unless %ns{$n} { %ns{$n} = $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }; %ns{$n} }; say fib(600)

[16:02] <camelia> rakudo-moar 64e898: OUTPUT: «178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601␤»

[16:03] <rightfold> 🤓

[16:03] <BenGoldberg> m: sub fib($n) is cached { $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }; say fib(600)

[16:03] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Use of the 'is cached' trait is experimental; please 'use experimental :cached'␤at <tmp>:1␤»

[16:04] <BenGoldberg> m: use experimental :cached; sub fib($n) is cached { $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }; say fib(600)

[16:04] <camelia> rakudo-moar 64e898: OUTPUT: «178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601␤»

[16:04] <araraloren> m: constant f = sub fib($n) { state %ns; unless %ns{$n} { %ns{$n} = $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }; %ns{$n} }(600); say f;

[16:04] <camelia> rakudo-moar 64e898: OUTPUT: «178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601␤»

[16:05] <araraloren> m: constant f = sub fib($n) { $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }(600); say f;

[16:05] <araraloren> :(

[16:05] <camelia> rakudo-moar 64e898: OUTPUT: «(timeout)»

[16:05] <BenGoldberg> m: sub fib($n) { (state %){$n} //= $n < 2 ?? 1 !! fib($n - 1) + fib($n - 2) }; say fib(600)

[16:05] <camelia> rakudo-moar 64e898: OUTPUT: «178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601␤»

[16:07] <rightfold> Dat syntax

[16:07] <BenGoldberg> m: sub fib($n) { (state @ := 1, 1, *+* ...^ *)[$n] }; say fib(600)

[16:07] <camelia> rakudo-moar 64e898: OUTPUT: «Cannot resolve caller postcircumfix:<[ ]>(Mu, Int); none of these signatures match:␤    (\SELF, Any:U $type, |c is raw)␤    (\SELF, int $pos)␤    (\SELF, int $pos, Mu \assignee)␤    (\SELF, int $pos, Mu :$BIND! is raw)␤    (\SELF, int $pos, :$d…»

[16:07] <rightfold> m: my $;

[16:07] <camelia> rakudo-moar 64e898: ( no output )

[16:07] <rightfold> m: my $ = 42;

[16:07] <camelia> rakudo-moar 64e898: ( no output )

[16:07] <rightfold> m: my $ = 42; say $;

[16:07] <camelia> rakudo-moar 64e898: OUTPUT: «(Any)␤»

[16:07] <rightfold> Lol

[16:07] <rightfold> m: say @;

[16:07] <TimToady> that's two different anonymous vars

[16:07] <camelia> rakudo-moar 64e898: OUTPUT: «[]␤»

[16:07] <BenGoldberg> Each anonymous variable is distinct.

[16:08] <rightfold> Ah ok

[16:08] <rightfold> Cooliosis

[16:08] <araraloren> m:  constant f = (1, 1, * + * ... *)[600]; say f

[16:08] <camelia> rakudo-moar 64e898: OUTPUT: «178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601␤»

[16:08] <TimToady> m: say $++, $-- for 1..10

[16:08] <camelia> rakudo-moar 64e898: OUTPUT: «00␤1-1␤2-2␤3-3␤4-4␤5-5␤6-6␤7-7␤8-8␤9-9␤»

[16:09] <TimToady> m: say (1,1,&[+]...*)[600]

[16:09] <camelia> rakudo-moar 64e898: OUTPUT: «178684461669052552311410692812805706249615844217278044703496837914086683543763273909969771627106004287604844670397177991379601␤»

[16:09] <araraloren> Even they are in same scope ?

[16:09] <BenGoldberg> Yes.

[16:09] <araraloren> m: say $++; say $++;

[16:09] <camelia> rakudo-moar 64e898: OUTPUT: «0␤0␤»

[16:09] <TimToady> each $ is like (state $)

[16:10] <TimToady> m: say (state $)++, (state $)-- for 1..10

[16:10] <camelia> rakudo-moar 64e898: OUTPUT: «00␤1-1␤2-2␤3-3␤4-4␤5-5␤6-6␤7-7␤8-8␤9-9␤»

[16:10] <araraloren> oh

[16:10] <TimToady> that was construed to be much more useful than anonymous 'my' vars :)

[16:10] <rightfold> m: say (my $)++ for 1..10;

[16:10] <camelia> rakudo-moar 64e898: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[16:11] <Geth> ¦ ecosystem: 0294679ce9 | (Gabor Szabo)++ | META.list

[16:11] <Geth> ¦ ecosystem: Bailador use 'main' as it's release branch

[16:11] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/0294679ce9

[16:11] <TimToady> m: sub foo () { say $++ }; foo() for 1..10

[16:11] <camelia> rakudo-moar 64e898: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[16:11] <TimToady> m: sub foo () { say (my $)++ }; foo() for 1..10

[16:11] <camelia> rakudo-moar 64e898: OUTPUT: «0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[16:11] <TimToady> there's the difference

[16:12] <araraloren> Oh, I see

[16:12] *** Herby_ left
[16:21] *** mr-foobar left
[16:22] *** mr-foobar joined
[16:27] *** kaare__ joined
[16:28] *** kaare_ left
[16:31] <rightfold> Is the my hoisted to the top of the function?

[16:32] <rightfold> m: for ^10 { say $++ }

[16:32] <camelia> rakudo-moar 64e898: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[16:32] <rightfold> m: for ^10 { say (my $)++ }

[16:32] <camelia> rakudo-moar 64e898: OUTPUT: «0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[16:32] *** kaare__ is now known as kaare_

[16:32] <rightfold> m: say (my $)++ for ^10;

[16:32] <camelia> rakudo-moar 64e898: OUTPUT: «0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[16:33] <rightfold> m: my $x = $_ for ^10; say $x

[16:33] <camelia> rakudo-moar 64e898: OUTPUT: «9␤»

[16:33] <rightfold> extremely interesting

[16:33] <moritz> does anybody know the publication dates of "Perl 6 at a Glance" and "Migrating to Perl 6"? (Andrew's books)

[16:34] <moritz> rightfold: scopes are delimited by curly braces. No curlies means it's visible in the whole compunit (here file)

[16:35] <moritz> ah, migrating to perl 6 is only available for preorder right now

[16:43] <rightfold> moritz: ok

[16:43] *** CacoS left
[16:43] <rightfold> m: my $x = $_ for ^0; say $x

[16:43] <camelia> rakudo-moar 64e898: OUTPUT: «(Any)␤»

[16:48] *** pmurias joined
[16:50] *** mr-foobar left
[16:53] *** mr-foobar joined
[16:54] *** zakharyas joined
[17:05] *** Cabanossi left
[17:07] *** Cabanossi joined
[17:15] *** domidumont joined
[17:27] *** fatguy left
[17:29] <Geth> ¦ doc: 5ff9a68825 | (Zoffix Znet)++ | 3 files

[17:29] <Geth> ¦ doc: Make xtest pass

[17:29] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/5ff9a68825

[17:29] <Geth> ¦ doc: 9bf4e37b02 | (Zoffix Znet)++ | xt/code.pws

[17:29] <Geth> ¦ doc: Remove from wordlist accidentally added incorrect word

[17:29] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/9bf4e37b02

[17:32] <rightfold> What was the syntax to set the type smiley of the receiver? I can't find it.

[17:33] <rightfold> oh, method foo(T:D: ...)

[17:34] *** AlexDani` is now known as AlexDaniel

[17:39] *** zakharyas left
[17:41] *** troys is now known as troys_

[17:42] *** LeCamarade left
[17:52] <Voldenet> rightfold: I know, It's possible to implement it somehow saner

[17:52] <Voldenet> sub fib($i) { my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(100);

[17:52] <Voldenet> m: sub fib($i) { my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(100);

[17:52] <camelia> rakudo-moar 64e898: OUTPUT: «Cannot resolve caller postfix:<-->(Int); the following candidates␤match the type but require mutable arguments:␤    (Mu:D $a is rw)␤    (Int:D $a is rw)␤␤The following do not match for other reasons:␤    (Bool:D $a is rw)␤    (Bool:U $a is …»

[17:52] <Voldenet> wut

[17:54] <Voldenet> m: sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(100);

[17:54] <camelia> rakudo-moar 64e898: OUTPUT: «354224848179261915075␤»

[17:54] *** mcmillhj left
[17:55] <Voldenet> the good point is C implementability

[17:57] *** TEttinger joined
[17:58] <Voldenet> ...and better performance compared to list ;P

[18:07] <Voldenet> m: sub x($i){ .say while $i-- }; x(5);

[18:07] <camelia> rakudo-moar 64e898: OUTPUT: «Cannot resolve caller postfix:<-->(Int); the following candidates␤match the type but require mutable arguments:␤    (Mu:D $a is rw)␤    (Int:D $a is rw)␤␤The following do not match for other reasons:␤    (Bool:D $a is rw)␤    (Bool:U $a is …»

[18:07] <Voldenet> hmm, don't you think it's kind of insane you can't do this?

[18:08] <Voldenet> m: sub x($i is copy){ .say while $i-- }; x(5);

[18:08] <camelia> rakudo-moar 64e898: OUTPUT: «(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤»

[18:12] <moritz> not really

[18:15] <Voldenet> I wouldn't mind if some types were copied by default, but I guess I understand the logic

[18:15] *** pmurias left
[18:16] <moritz> m: sub x($i is copy){ say $i while $i-- }; x(5);

[18:16] <camelia> rakudo-moar 64e898: OUTPUT: «4␤3␤2␤1␤0␤»

[18:16] <Voldenet> oh, I didn't mean the say

[18:16] <Voldenet> i meant the /is copy/ for Int

[18:17] *** pmurias joined
[18:18] <moritz> I find the "is copy" to be good documentation that $i isn't constant within the sub

[18:18] <moritz> (given that paramaters are usually constant)

[18:18] <Voldenet> hm, unless they're instance of a class, they're mutable then :)

[18:19] <moritz> most everything is an instance of a class in Perl 6

[18:20] *** espadrine_ joined
[18:21] *** mr-foobar left
[18:21] *** araraloren_ joined
[18:22] *** mr-foobar joined
[18:23] *** araralonre__ joined
[18:24] *** araraloren left
[18:26] *** araraloren_ left
[18:34] *** kaare__ joined
[18:34] *** kaare_ left
[18:36] *** Cabanossi left
[18:37] *** Cabanossi joined
[18:40] *** jameslenz left
[18:48] *** holyghost joined
[18:52] <timotimo> classes are instances of a class, too

[18:57] *** kaare__ is now known as kaare_

[19:05] *** kaare__ joined
[19:06] *** kaare_ left
[19:10] <pmurias> Voldenet: it's not the Int that's being copied it's the variable

[19:11] <Voldenet> well, apparently it's the box

[19:11] <Voldenet> in which case it makes sense

[19:13] *** rindolf left
[19:28] *** domidumont left
[19:36] *** CacoS joined
[19:37] <Voldenet> ouch, I just compared p6's fib implementation I just pasted to C implementation

[19:38] <timotimo> and it's faster? no way :P

[19:39] <Voldenet> it's .02s vs 1.4s-faster

[19:39] <Voldenet> sure, I'd expect some overhead, but that's scary

[19:39] <timotimo> how does the sequence operator compare?

[19:39] <Voldenet> ~2s-ish

[19:39] <timotimo> m: say (1, 1, *+* ... *)[100]

[19:39] <camelia> rakudo-moar 64e898: OUTPUT: «573147844013817084101␤»

[19:39] <timotimo> how man

[19:39] <timotimo> how many-th number?

[19:40] <timotimo> i bet doing it without an array would make it a bunch faster

[19:40] <Voldenet> 1e5

[19:40] <timotimo> m: say (1, 1, *+* ... *)[1e5].msb

[19:40] <camelia> rakudo-moar 64e898: OUTPUT: «69423␤»

[19:40] <timotimo> how do you do it in C?

[19:40] <Voldenet> http://ix.io/we6

[19:41] <timotimo> ah, the gmp one

[19:42] <timotimo> bench: compare HEAD sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1000); ||| m: sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v.ASSIGN-POS($i%3, @v.AT-POS(($i+1)%3) + @v.AT-POS(($i+2)%3) }; @v[0] }; say fib(100);

[19:42] <benchable6> timotimo, starting to benchmark the 1 given commit

[19:42] *** raschipi joined
[19:42] <benchable6> timotimo, ¦HEAD: «04===SORRY!04=== Error while compiling -e␤Unable to parse expression in argument list; couldn't find final ')' ␤at -e:1␤------> 03.AT-POS(($i+1)%3) + @v.AT-POS(($i+2)%3) 08⏏04}; @v[0] }; say fib(100); } ; my $b = Be»

[19:43] <timotimo> whoops

[19:43] <MasterDuke> timotimo: also, you need the give the subs different names

[19:43] <timotimo> bench: compare HEAD sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1000); ||| m: sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v.ASSIGN-POS($i%3, @v.AT-POS(($i+1)%3) + @v.AT-POS(($i+2)%3)) }; @v[0] }; say fib(100);

[19:43] <benchable6> timotimo, starting to benchmark the 1 given commit

[19:43] <benchable6> timotimo, https://gist.github.com/bf49f3d01f0d955770404ad6a2396f3d

[19:43] *** darutoko- left
[19:44] <MasterDuke> huh, at least i thought you did

[19:44] <timotimo> bench: compare HEAD sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1000); ||| m: sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v.ASSIGN-POS($i%3, @v.AT-POS(($i+1)%3) + @v.AT-POS(($i+2)%3)) }; @v[0] }; say fib(1000);

[19:44] <benchable6> timotimo, starting to benchmark the 1 given commit

[19:44] <benchable6> timotimo, https://gist.github.com/bcd2007a19bec85532a7df9a90446536

[19:44] <timotimo> interesting, hardly any difference

[19:44] <Voldenet> oh wow

[19:44] <timotimo> the benchmark difference above was comparing 100 vs 1000

[19:44] <Voldenet> actually printing this to console takes +.300ms

[19:45] <timotimo> a third of a milisecond?

[19:45] <Voldenet> so i guess building a Str

[19:45] <Voldenet> erm

[19:45] <Voldenet> +.300s

[19:46] <Voldenet> I guess building a string representation out of a bigint isn't the fastest operation

[19:46] <timotimo> bench: compare HEAD sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1000); ||| sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; fib(1000);

[19:46] <benchable6> timotimo, starting to benchmark the 1 given commit

[19:46] <benchable6> timotimo, https://gist.github.com/3fc5343428c1eefc0bb532e7d4e724f4

[19:46] <timotimo> only a quarter of time to print it for the 1000th number

[19:48] <timotimo> with 1e5 the value is very similar

[19:48] <timotimo> oh, heh

[19:49] *** zapwai joined
[19:49] <timotimo> when you use 1e5 instead of 1e5.Int, you'll be turning 1e5 into an Int every single step of the way

[19:49] <timotimo> i.e. 1e5 times

[19:50] <Voldenet> Oh, wow.

[19:51] <timotimo> that change alone gets me from 2.5 to 2.0 seconds

[19:51] <Voldenet> > sub fib { my ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1e5);

[19:51] <Voldenet> real    0m1.421s

[19:52] <Voldenet> > sub fib { my int ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1e5.Int);

[19:52] <Voldenet> real    0m0.825s

[19:52] <Voldenet> that's amazing

[19:53] <timotimo> yeah, a native int for $i makes it a whole bunch faster, too

[19:53] <timotimo> 0.8s by leaving out the "say" as well

[19:53] *** cyphase left
[19:54] <Voldenet> well, so the 'deadly slow' points are pretty much obvious by now

[19:54] <timotimo> impressively, 20% of time spent in GC now

[19:55] <Voldenet> hmm, I guess it allocates 10k+3 Int objects

[19:55] <timotimo> i don't understand why, but the four most expensive frames all don't get jitted

[19:57] <timotimo> aha

[19:58] <timotimo> hmpf. bails on one of the param ops

[19:59] *** cyphase joined
[20:00] <timotimo> hm. we really do spend 43% of time in a bigint add function

[20:00] <timotimo> like, MVM_bigint_add

[20:00] <timotimo> and in mp_add and s_mp_add of course

[20:01] <timotimo> eew, mp_grow takes up 17% of time. i wonder if we're doing something silly to start with very small bigints even though we know we're adding two very large ones?

[20:01] <timotimo> 15% in mp_clear, too

[20:02] <timotimo> that's potentially the big time loss inside GC

[20:03] <timotimo> so yeah, as long as we can't figure out that we could allocate these int objects on the stack (which is very hard to prove here, i bet) we'll be spending around this amount of time to do this calculation

[20:04] <timotimo> might be able to halve it, but not /10 or /100

[20:05] <timotimo> 5% of time spent in the interpreter itself, so not very much to gain from jitting either

[20:08] *** cdg joined
[20:09] <Voldenet> I wonder if there would be any difference if I implemented it differently

[20:10] *** cdg left
[20:10] *** kaare__ is now known as kaare_

[20:10] <Voldenet> bench: compare HEAD sub fib { my int ($t) = @_; my ($a, $b) = (0, 1); while $t-- { ($a, $b) = ($b, $a + $b) }; $a }; say fib(1e4.Int); ||| sub fib { my int ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1e4.Int);

[20:10] <benchable6> Voldenet, starting to benchmark the 1 given commit

[20:10] *** cdg joined
[20:10] <benchable6> Voldenet, https://gist.github.com/f3949ef696df31189359d6f220bfcbf8

[20:11] *** zakharyas joined
[20:11] <rightfold> m: sub f(--> Str:D) { }

[20:11] <camelia> rakudo-moar 64e898: ( no output )

[20:11] <Voldenet> not the direction I wanted to take

[20:11] <rightfold> m: sub f(--> Str:D) { }; f()

[20:11] <camelia> rakudo-moar 64e898: ( no output )

[20:12] <timotimo> hm, i think assignment like that is extremely slow right now

[20:12] <rightfold> Why is this not an error?

[20:12] <timotimo> ($a, $b) = (...)

[20:12] <timotimo> rightfold: Nil goes through all returns, because it's Failure

[20:12] <rightfold> oh ok

[20:17] *** araraloren_ joined
[20:18] <Voldenet> hmm, using ugly temp variable made it a lot faster, but not comparably to array implementation

[20:18] <timotimo> oh? the array one was still faster?

[20:19] <Voldenet> bench: compare HEAD sub fib { my int ($t) = @_; my ($a, $b, $tmp) = (0, 1); while $t-- { $tmp = $a; $a = $b; $b = $tmp + $b }; $a }; say fib(1e4.Int); ||| sub fib { my int ($i) = @_; my @v = [1,1,1]; @v[$i%3] = 0; while $i-- { @v[$i%3] = @v[($i+1)%3] + @v[($i+2)%3] }; @v[0] }; say fib(1e4.Int);

[20:19] <benchable6> Voldenet, starting to benchmark the 1 given commit

[20:19] <benchable6> Voldenet, https://gist.github.com/0045622a45648304a8d2d96d665292b5

[20:20] <timotimo> huh, it's twice as fast

[20:20] *** araralonre__ left
[20:21] *** mr-foobar left
[20:21] <Voldenet> ah, right, I forgot to use "say"

[20:21] <Voldenet> magic word that makes it a lot slower

[20:22] <timotimo> i see output in both, though?

[20:22] <Voldenet> (the array version is actually slower)

[20:22] <timotimo> ah, you had the say only in the temp-var-one

[20:25] *** mr-foobar joined
[20:32] *** zacts left
[20:35] *** Cabanossi left
[20:37] *** Cabanossi joined
[20:38] *** zacts joined
[20:39] *** Cabanossi left
[20:39] *** Ben_Goldberg joined
[20:39] *** BenGoldberg left
[20:39] *** Ben_Goldberg is now known as BenGoldberg

[20:39] *** Cabanossi joined
[20:40] *** lizmat left
[20:40] *** jameslenz joined
[20:40] *** zakharyas left
[20:41] *** Cabanossi left
[20:41] *** Cabanossi joined
[20:45] *** jameslenz left
[20:47] *** jameslenz joined
[20:50] <Geth> ¦ ecosystem: 9b6ea9d0d1 | (Zoffix Znet)++ (committed using GitHub Web editor) | META.list

[20:50] <Geth> ¦ ecosystem: Add WhereList to ecosystem

[20:50] <Geth> ¦ ecosystem: 

[20:50] <Geth> ¦ ecosystem: "Simpler `where` constraints for items of lists":

[20:50] <Geth> ¦ ecosystem: https://github.com/zoffixznet/perl6-WhereList

[20:50] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/9b6ea9d0d1

[20:50] *** lizmat joined
[20:55] *** lizmat left
[20:58] *** zapwai left
[20:59] *** yqt joined
[21:00] *** cdg_ joined
[21:02] *** cdg left
[21:05] *** Some-body_ joined
[21:05] *** DarthGandalf left
[21:05] *** Cabanossi left
[21:05] *** vcv left
[21:06] *** Some-body_ is now known as DarthGandalf

[21:07] *** Cabanossi joined
[21:09] <pilne> have i not dug deep enough into perl6 yet, or does it not do the "context" based things like perl5 (i.e. my $a = @array setting $a to the length of @array)?

[21:10] <timotimo> that is correct

[21:10] <timotimo> you have to +@array or @array.elems

[21:10] <mst> the removal of wantarray() from perl6 makes me very happy.

[21:11] <pilne> i will miss it somewhat, but not enough to feel remorse.

[21:11] <pilne> (the $a=@array)

[21:11] <timotimo> you can now put arrays into $foo vars without \-ing them

[21:11] <pilne> yeup!

[21:12] <pilne> much more useful than saving a few keystrokes

[21:12] <pilne> that's one thing i've noticed, i type a bit more "per thing" in perl6, but i type a lot less overall

[21:12] <pilne> and, unless i'm trying to golf, the code is almost not needing comments

[21:13] <pilne> (i still comment my stuff, because it's the right way to do things in my book, but it is nice regardless).

[21:13] <timotimo> yeah, no comments needed for [>>+>>] at all :D

[21:13] <pilne> the [] idea is fantastic though

[21:13] <pilne> i'll have to put "shaking larry wall's hand" on my bucket list.

[21:16] <Xliff> [>>+>>] _ O_o

[21:16] <Xliff> <sarcasm>No. We don need no steeking comments!</sarcasm>

[21:17] <timotimo> damn commies :)

[21:17] <Xliff> timotimo: Will you explain what that piece of line noise is?

[21:17] <pilne> [>>+>>][<<+<<]

[21:18] <timotimo> well, if you have [>>+>>] @a, @b, @c, it'll pretend you wrote @a >>+>> @b >>+>> @c

[21:18] * Xliff pulls what's left of his hair.

[21:18] <Xliff> Yeah. [] is good.

[21:18] <Xliff> But that operator is unfamiliar.

[21:18] <pilne> and... just because i haven't seen it,  what is >>+>>

[21:18] <Xliff> ^^ SEE!

[21:18] <pilne> something to do with hyper?

[21:18] <timotimo> yeah

[21:18] <Xliff> Oh got please no...

[21:19] <Xliff> Wah!

[21:19] <Xliff> So »+» is a thing, too?

[21:19] <timotimo> yup

[21:19] <raschipi> m: say (1, 2, 3, 4) »~» <a b>;

[21:19] <camelia> rakudo-moar 64e898: OUTPUT: «(1a 2b 3a 4b)␤»

[21:19] <Xliff> So. Hyper addition, then?

[21:19] <pilne> hyper and race are neat, i never thought it would be something to have the choice of keeping or not keeping order when doing something in parallel.

[21:19] <timotimo> you put >> or << on either side of an infix operator and it'll distribute; you hold the pointy end against things you want to allow to grow, you hold the blunt end against things you require to only be run over once

[21:20] <raschipi> m: say (1, 2, 3, 4) »~» (5, 6);

[21:20] <camelia> rakudo-moar 64e898: OUTPUT: «(15 26 35 46)␤»

[21:20] <pilne> see, that would be a decent chunk of code otherwise....

[21:20] <raschipi> m: say (1, 2, 3, 4) »+» (5, 6);

[21:20] <camelia> rakudo-moar 64e898: OUTPUT: «(6 8 8 10)␤»

[21:21] <Xliff> \o/

[21:21] <Xliff> Wait.

[21:21] <Xliff> \O/

[21:21] <raschipi> That's (1+5, 2+6, 3+5, 4+6)

[21:21] <Xliff> One of those was made famous by Mccauley Caulkin

[21:22] <pilne> lol

[21:22] <pilne> i think i'm going to find a useful way to make \O/ an operator

[21:22] <Xliff> kk. So 'tis a new fangled thang that I had not caught in the change logs.

[21:22] <Xliff> pilne: I. DARE. YOU!!!

[21:22] <pilne> it might take a few revision cycles!

[21:22] <Xliff> ];->

[21:23] <raschipi> This example from the docs is fun:

[21:23] <raschipi> m: my $neighbors = ((-1, 0), (0, -1), (0, 1), (1, 0)); my $p = (2, 3); say $neighbors »>>+<<» ($p, *);

[21:23] <camelia> rakudo-moar 64e898: OUTPUT: «((1 3) (2 2) (2 4) (3 3))␤»

[21:24] <raschipi> Try that without comments.

[21:24] * Xliff faints.

[21:24] <Geth> ¦ doc: 5dfae24189 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Language/operators.pod6

[21:24] <Geth> ¦ doc: Swap .&fail to fail $_

[21:24] <Geth> ¦ doc: 

[21:24] <Geth> ¦ doc: At least ATM, the former doesn't actually throw CX::Return exception

[21:24] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/5dfae24189

[21:24] <pilne> so basically >><< is the "distribution" operator.

[21:26] *** yqt left
[21:26] <raschipi> m: say (1, 2, 3, 4) «+» (5, 6);

[21:26] <camelia> rakudo-moar 64e898: OUTPUT: «(6 8 8 10)␤»

[21:27] <raschipi> m: say (1, 2, 3, 4) «+« (5, 6);

[21:27] <camelia> rakudo-moar 64e898: OUTPUT: «(6 8)␤»

[21:27] <raschipi> m: say (1..*) «+« (5, 6);

[21:27] <camelia> rakudo-moar 64e898: OUTPUT: «(6 8)␤»

[21:27] <raschipi> m: say (1..*) «+« (5, 6, 7);

[21:27] <camelia> rakudo-moar 64e898: OUTPUT: «(6 8 10)␤»

[21:33] *** cdg_ left
[21:34] *** Herby_ joined
[21:34] <Herby_> o/

[21:34] <raschipi> m: say (1..*) »+« (5, 6);

[21:34] <camelia> rakudo-moar 64e898: OUTPUT: «List on left side of hyperop of infix:<+> is known to be infinite␤  in block <unit> at <tmp> line 1␤␤»

[21:35] <raschipi> Why doesn't that return an infinite list?

[21:35] <timotimo> because infinite lists have to be lazy

[21:35] <timotimo> and lazy is literally the opposite of hyper

[21:35] <timotimo> also, it'd have to complain that Inf != 2

[21:35] <BenGoldberg> m: say (1, 2, 3, 4) »+« (5, 6);

[21:35] <camelia> rakudo-moar 64e898: OUTPUT: «Lists on either side of non-dwimmy hyperop of infix:<+> are not of the same length␤left: 4 elements, right: 2 elements␤  in block <unit> at <tmp> line 1␤␤»

[21:36] <raschipi> Thanks timotimo++

[21:36] <BenGoldberg> Like that ^ but "Inf" instead of "4".

[21:36] <timotimo> m: say (1..*) Z+ (|(5, 6) xx *)

[21:36] <camelia> rakudo-moar 64e898: OUTPUT: «(...)␤»

[21:36] <timotimo> m: say ((1..*) Z+ (|(5, 6) xx *))[^20]

[21:36] <camelia> rakudo-moar 64e898: OUTPUT: «(6 8 8 10 10 12 12 14 14 16 16 18 18 20 20 22 22 24 24 26)␤»

[21:37] <BenGoldberg> m: say ((1..*) Z~ (|(<a b>) xx *))[^20]

[21:37] <camelia> rakudo-moar 64e898: OUTPUT: «(1a 2b 3a 4b 5a 6b 7a 8b 9a 10b 11a 12b 13a 14b 15a 16b 17a 18b 19a 20b)␤»

[21:37] <timotimo> Z is able to give you a lazy list

[21:38] <raschipi> That solves it.

[21:38] <timotimo> but there's no control on it for "how do you handle one list being shorter than the other?" it'll just always stop when one list is expended

[21:38] <raschipi> That's why you make both infinite.

[21:39] <timotimo> yup

[21:39] <timotimo> it's easy to forget, though, and can lead to data loss

[21:39] <timotimo> we used to not run all test files when we had harness6 with multiple test_jobs, because it was creating batches with Z or something

[21:43] *** CacoS left
[21:48] *** espadrine_ left
[21:50] *** lizmat joined
[22:00] <Herby_> I just discovered the p6 module File::Find

[22:00] <Herby_> https://github.com/tadzik/File-Find

[22:01] <Herby_> I'm trying to utilize the second example, to lazily return retuls

[22:01] <Herby_> results

[22:01] <Herby_> so I have:  my $list = find(dir => 'foo')

[22:01] <timotimo> that was example code from before the GLR i'd say

[22:01] <Herby_> hmm

[22:01] <timotimo> m: my @foo = 1..*; say @foo[^100]

[22:01] <camelia> rakudo-moar 64e898: OUTPUT: «(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 8…»

[22:02] <timotimo> that used to lose you lazyness

[22:02] <timotimo> List assignment is eager in Perl 6, so if you assign find() result to an array, the elements will be copied and the laziness will be spoiled. For a proper lazy list, assign a result to a scalar value (see SYNOPSIS).

[22:02] <timotimo> ^- that's from the "caveats" section at the bottom and it's no longer true

[22:02] *** nadim left
[22:03] <Herby_> ok. as someone who doesn't have a great understanding of lazy/eager, how should I utilize File::Find if I want to do it lazily?

[22:04] <timotimo> i wonder if the module needs any adjustments for GLR stuff

[22:04] <Herby_> the lib/File description on that link I posted says:  Update to post-GLR semantics

[22:04] <Herby_> not sure if that means its needs updating, or was updated

[22:04] <timotimo> ah, nice

[22:05] <timotimo> that's the commit description (well, the title at least) of the last commit that touched the file in question

[22:05] <timotimo> if you click the title it gives you the whole commit including the rest of the description and what exact changes there were

[22:05] <Herby_> ahh ok

[22:06] *** Cabanossi left
[22:07] *** Cabanossi joined
[22:08] <Herby_> if I do follow that lazy example, how do I print each item on it's own line?

[22:08] <Herby_> my $list = find(dir => 'foo');

[22:08] <Herby_>  for $list -> $file { say $file }

[22:08] <Herby_> that just prints it as one blob

[22:08] <Herby_> so i'm guessing i'm missing something

[22:09] <timotimo> yup, that's because "for $something" will only ever give you a single iteration

[22:09] <timotimo> you'll want "for @$list" or have the find stuff in a @ variable to begin with

[22:09] <Herby_> ah ok

[22:09] <Herby_> thanks

[22:09] <timotimo> this is part of the "single-arg-rule semantics" we've introduced with the GLR

[22:10] <timotimo> for things that behave single-arg-ruley, you'll get iteration of the outermost thing unless it's in a scalar container

[22:10] <timotimo> so "for @foo" will give you each entry directly inside @foo, "for (@foo,)" will give you just @foo once

[22:10] <Herby_> that makes sense

[22:11] <timotimo> m: my $foo = Slip.new(1, 2, 3); for $foo -> $thing { say "thing is $thing" }

[22:11] <camelia> rakudo-moar 64e898: OUTPUT: «thing is 1␤thing is 2␤thing is 3␤»

[22:11] <timotimo> unless it's slippy, i suppose

[22:13] <Herby_> : say BagHash.new.categorize-list: { gather { take 'largish' if $_ >5; take .is-prime ?? 'prime' || 'non-prime'; }, ^10

[22:13] <Herby_> m: say BagHash.new.categorize-list: { gather { take 'largish' if $_ >5; take .is-prime ?? 'prime' || 'non-prime'; }, ^10

[22:13] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused: Found ?? but no !!␤at <tmp>:1␤------> 3take .is-prime ?? 'prime' || 'non-prime'7⏏5; }, ^10␤»

[22:14] <Herby_> m: say BagHash.new.categorize-list: { gather { take 'largish' if $_ >5; take .is-prime ?? 'prime' !! 'non-prime'; }, ^10

[22:14] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3-prime ?? 'prime' !! 'non-prime'; }, ^107⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»

[22:14] <Herby_> m: say BagHash.new.categorize-list: { gather { take 'largish' if $_ >5; take .is-prime ?? 'prime' !! 'non-prime'; }, ^10;

[22:14] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3prime ?? 'prime' !! 'non-prime'; }, ^10;7⏏5<EOL>␤»

[22:14] <Herby_> hm

[22:14] <timotimo> that { } around the gather/take may be wrong here

[22:14] <Herby_> https://docs.perl6.org/routine/categorize-list

[22:15] <Herby_> trying to copy that first example

[22:15] <timotimo> oooh

[22:15] <timotimo> of course

[22:15] <Herby_> recently discovered categorize-list and it might be perfect for what i'm trying to do

[22:16] <timotimo> you can also use categorize instead of categorize-list

[22:16] <MasterDuke> Herby_: you're missing a '}'

[22:17] <Herby_> m: say BagHash.new.categorize-list: { gather { take 'largish' if $_ >5; take .is-prime ?? 'prime' !! 'non-prime'; } }, ^10;

[22:17] <camelia> rakudo-moar 64e898: OUTPUT: «BagHash.new(largish(4), non-prime(6), prime(4))␤»

[22:17] <Herby_> :)

[22:17] <timotimo> that's better

[22:17] <Herby_> timotimo: i'll take a look at categorize

[22:18] <Herby_> m: say % .categorize-list: {

[22:18] <camelia> rakudo-moar 64e898: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3say % .categorize-list: {7⏏5<EOL>␤»

[22:18] <Herby_>  gather {

[22:18] <Herby_>  take 'prime' if .is-prime;

[22:18] <Herby_>  take 'largish' if $_ > 5;

[22:18] <Herby_>  take $_ %% 2 ?? 'even' !! 'odd';

[22:18] <timotimo> the difference is that categorize doesn't give you the opportunity to decide what kind of object comes out

[22:18] <Herby_>  }

[22:18] <Herby_> }, ^10;

[22:18] <Herby_> gah, i'll leave it alone

[22:18] <Herby_> gotcha

[22:19] <timotimo> feel free to open a private chat with camelia

[22:19] <Herby_> i have a list of files, and i just want to categorize them into either type A or type B

[22:19] <Herby_> will do

[22:19] <timotimo> oh

[22:19] <timotimo> in that case you may want classify instead :)

[22:20] <timotimo> classify is for when you have a single category every single value fits into

[22:20] <timotimo> categorize is for when you have multiple categories that individual values might fall into

[22:20] <timotimo> i.e. you can have values that are both largish and prime

[22:21] <Herby_> ah ok

[22:21] <timotimo> so a single value may show up in both the largish list and the prime list

[22:21] <Herby_> ok, yeah these files are either A or B, not both. classify sounds like its what I want

[23:08] *** Exodist left
[23:09] *** Exodist joined
[23:09] *** wamba left
[23:13] *** grumble left
[23:14] *** grumble joined
[23:14] *** grumble left
[23:16] *** grumble joined
[23:29] *** BenGoldberg left
[23:31] *** Rawriful joined
[23:37] <rightfold> m: role R { method Str() { 'hidden!' } }; my $i = 2; $i but R; say $i.Str

[23:37] <camelia> rakudo-moar 64e898: OUTPUT: «2␤»

[23:37] <rightfold> m: role R { method Str() { 'hidden!' } }; my $i = 2; ($i but R).WHAT.perl.say

[23:37] <camelia> rakudo-moar 64e898: OUTPUT: «Int+{R}␤»

[23:38] <rightfold> Ah it creates a wrapper

[23:38] <rightfold> Cool

[23:38] <timotimo> "but" makes a copy

[23:38] <timotimo> well, a clone

[23:38] <timotimo> m: role R { method Str() { 'hidden!' } }; my $i = 2; say ($i but R).Str; say $i.Str

[23:38] <camelia> rakudo-moar 64e898: OUTPUT: «hidden!␤2␤»

[23:38] <rightfold> Does it not reference the original object?

[23:39] <timotimo> nope. though the clone is shallow

[23:40] <rightfold> Ok

[23:40] <rightfold> Is does the same as but + reassignment?

[23:40] <timotimo> m: class Foo { has @.array }; role Bar { method lol { say "oooh" } }; my $orig = Foo.new; $orig.array[2] = "yo"; my $clone = $orig but Bar; $clone.lol; $orig.array.say; $clone.array[1] = "woop"; $orig.array.say

[23:40] <camelia> rakudo-moar 64e898: OUTPUT: «oooh␤[(Any) (Any) yo]␤[(Any) woop yo]␤»

[23:40] <timotimo> no, it mutates the original object

[23:41] <timotimo> so whatever variables refered to the object will now refer to the changed object as well

[23:41] <rightfold> :(

[23:41] <timotimo> gotta go get some sleeps

[23:41] <timotimo> have a good one!

[23:42] <Herby_> o/

[23:42] <Herby_> i've come to realize that I am absolutely terrible at naming items in my code

[23:42] <Herby_> worst namer ever

[23:43] <rightfold> m: role R { method Str() { 'hidden!' } }; class C { has $.a }; my $x = C.new(a => 1); $x does R; say $x.WHAT

[23:43] <camelia> rakudo-moar 64e898: OUTPUT: «(C+{R})␤»

[23:44] <Xliff> say 4.is-prime

[23:44] <evalable6> Xliff, rakudo-moar 64e898f9b: OUTPUT: «False»

[23:44] <rightfold> m: role R { method Str() { 'hidden!' } }; my $x = 1; $x does R; say $x.WHAT

[23:44] <camelia> rakudo-moar 64e898: OUTPUT: «(Int+{R})␤»

[23:44] <Xliff> m: say BagHash.new.categorize-list: { gather { take 'largish' if $_ >5; take .is-prime ?? 'prime' !! 'non-prime'; } }, ^10;

[23:44] <camelia> rakudo-moar 64e898: OUTPUT: «BagHash.new(largish(4), non-prime(6), prime(4))␤»

[23:45] <Xliff> That math doesn't look right.

[23:45] <Xliff> 4 is not prime, for example.

[23:46] <raschipi> m: (^10).grep({.is-prime})

[23:46] <camelia> rakudo-moar 64e898: ( no output )

[23:46] <raschipi> m: say (^10).grep({.is-prime})

[23:46] <camelia> rakudo-moar 64e898: OUTPUT: «(2 3 5 7)␤»

[23:46] <raschipi> 4 primes in ^10, it's the right answer.

[23:47] <raschipi> m: say (^10).grep({$_ >5})

[23:47] <camelia> rakudo-moar 64e898: OUTPUT: «(6 7 8 9)␤»

[23:48] <Xliff> Ooh. I am interpreting the code incorrectly.

[23:49] <raschipi> m: say Hash.new.categorize-list: { gather { take 'largish' if $_ >5; take .is-prime ?? 'prime' !! 'non-prime'; } }, ^10;

[23:49] <camelia> rakudo-moar 64e898: OUTPUT: «{largish => [6 7 8 9], non-prime => [0 1 4 6 8 9], prime => [2 3 5 7]}␤»

[23:52] <rightfold> m: 42.^rebless(Str).say

[23:52] <camelia> rakudo-moar 64e898: OUTPUT: «X::Method::NotFound exception produced no message␤  in block <unit> at <tmp> line 1␤␤»

[23:53] *** pmurias left
[23:58] <raschipi> rightfold: Up to no good, I see...

[23:59] <MasterDuke> that error message will be fixed after the next NQP bump

