[00:00] <timotimo> "such an old version" is a bit extreme for 2016.11, but still

[00:00] <Geth_> ¦ gtk-simple: b66db46864 | (Timo Paulssen)++ | .travis.yml

[00:00] <Geth_> ¦ gtk-simple: bump lowest rakudo version for zef compatibility

[00:00] <Geth_> ¦ gtk-simple: review: https://github.com/perl6/gtk-simple/commit/b66db46864

[00:00] <timotimo> let's see how that goes

[00:01] <timotimo> when i've found a working version i'll also bump appveyor

[00:02] <timotimo> oh, huh. that's not clever ...

[00:02] <timotimo> our travis script for rakudo does "make test" then "make install"

[00:02] <timotimo> but if the core setting step explodes, it'll try to do the core setting again

[00:03] <timotimo> which on the jvm version takes almost 400 seconds (on travis, that is)

[00:08] <Geth_> ¦ gtk-simple: a6938136dc | (Timo Paulssen)++ | .travis.yml

[00:08] <Geth_> ¦ gtk-simple: bump lowest rakudo version for zef compatibility

[00:08] <Geth_> ¦ gtk-simple: review: https://github.com/perl6/gtk-simple/commit/a6938136dc

[00:08] <timotimo> .o( i hope it's .01 and not .1 )

[00:09] <benjikun> timotimo: I appreciate you doing all of this just because I brought it up lol

[00:09] <timotimo> well, the CI is hardly useful if nobody looks if it succeeds or fails to build

[00:09] <TEttinger> I think it's also just important that stuff works :)

[00:11] <timotimo> the tests in gtk-simple hardly do anything ;_;

[00:12] *** El_Che left
[00:12] *** El_Che_ joined
[00:12] <timotimo> anyway, looks like 2017.01 is new enough for zef

[00:12] <timotimo> i wonder if zef should warn for earlier versions?

[00:13] <ugexe> its rakudo, not zef that is broke

[00:13] <timotimo> of course

[00:13] *** MilkmanDan left
[00:13] <timotimo> but it'd be helpful if zef said "hey btw this rakudo is too old yo"

[00:14] <timotimo> rather than the ominous and unhelpful "expected 2 parameters but got 1"

[00:14] *** MilkmanDan joined
[00:14] *** mr-foobar left
[00:14] *** someuser left
[00:14] <timotimo> wait, i said it's new enough but it hadn't even built rakudo yet, how was it supposed to maybe-fail

[00:14] <timotimo> yeah, there it goes

[00:14] <timotimo> ugexe: you happen to know which rakudo version fixed this problem?

[00:15] *** someuser joined
[00:15] <Geth_> ¦ gtk-simple: d50c5dc437 | (Timo Paulssen)++ | .travis.yml

[00:15] <Geth_> ¦ gtk-simple: bump lowest rakudo version for zef compatibility

[00:15] <Geth_> ¦ gtk-simple: review: https://github.com/perl6/gtk-simple/commit/d50c5dc437

[00:15] <ugexe> clone zef for around the same time of your rakudo version if you want to use old rakudo

[00:15] <timotimo> hm, right

[00:15] <timotimo> actually, rakudobrew should do that

[00:16] <benjikun> timotimo: How early did you have to claim timo on github for it not to be taken

[00:16] <timotimo> (actually actually, maybe don't use rakudobrew on travis)

[00:16] <timotimo> good question, let's see if my very first commit is there

[00:16] <ugexe> rakudobrew wont do that

[00:17] <ugexe> it could grep the git log or something to do it, but it doesnt

[00:17] <timotimo> benjikun: i already had it in december 2008 it looks like

[00:17] <timotimo> well, yeah

[00:17] <benjikun> I call my cat timo sometimes

[00:17] <benjikun> his name is Timothy

[00:17] <timotimo> i bet it's a good cat

[00:17] <benjikun> it sure is

[00:19] <timotimo> there's commits on github from march 2008 but i can't actually tell when i created the github account

[00:19] <timotimo> i.e. if i made these commits off of github and later (maybe much later) pushed them there

[00:20] <benjikun> hmm

[00:21] <timotimo> but i expect around that time to be correct

[00:21] <timotimo> github wasn't very big when i got on

[00:21] <benjikun> I'm honestly thinking about making and using a private repo thingy

[00:22] <benjikun> and abandoning my github

[00:22] <ugexe> any module that spawns procs in its Build.pm should require minimum 2017.07 imo

[00:22] <timotimo> ah is that what causes the problem in gtk-simple?

[00:23] <ugexe> probably not the one you are seeing, it usually is prone to deadlocks

[00:24] <timotimo> oh, ouch

[00:24] <Geth_> ¦ gtk-simple: df15c903af | (Timo Paulssen)++ | 2 files

[00:24] <Geth_> ¦ gtk-simple: bump the "old rakudo" version by a lot

[00:24] <Geth_> ¦ gtk-simple: 

[00:24] <Geth_> ¦ gtk-simple: to benefit from zef fixes and such

[00:24] <Geth_> ¦ gtk-simple: review: https://github.com/perl6/gtk-simple/commit/df15c903af

[00:30] *** Cabanossi left
[00:32] *** mscha joined
[00:32] <mscha> m: my %h{num}; %h{1e0} = 42;

[00:32] <camelia> rakudo-moar 51e59e: OUTPUT: «Type check failed in binding to parameter 'key'; expected num but got Num (1e0)␤  in block <unit> at <tmp> line 1␤␤»

[00:32] *** Cabanossi joined
[00:33] <mscha> What's the point of allowing %hash{num} if you can't put anything in it?

[00:33] <ugexe> m: my %h{num}; %h{num} = 1;

[00:33] <camelia> rakudo-moar 51e59e: ( no output )

[00:34] <mscha> OK, you can put a type object in it.  Very useful...  :-)

[00:34] <ugexe> killer language feature

[00:35] <geekosaur> this is more a shortcoming in our handling of boxing/unboxing numbers

[00:35] <geekosaur> (I should say Num vs. num; things like Int vs. int work, mostly)

[00:36] <ugexe> looks liek it gets coerced

[00:36] <ugexe> m: use nqp; my %h{num}; %h{nqp::unbox_n(1e0)} = 1;

[00:36] <camelia> rakudo-moar 51e59e: OUTPUT: «Type check failed in binding to parameter 'key'; expected num but got Num (1e0)␤  in block <unit> at <tmp> line 1␤␤»

[00:36] *** itaipu left
[00:40] <timotimo> yup, we're notg ood at that one yet

[00:40] <geekosaur> actually that's also an LTA error on top of being wrong

[00:40] <geekosaur> well, on top of being LTA behavior

[00:53] <timotimo> japhb: i just tried tris.p6 (tris di pasta?); fantastic! japhb++

[00:53] <timotimo> looking forward to being able to use arrow keys and such

[00:58] *** Erroneous_ joined
[01:03] *** BenGoldberg left
[01:17] <japhb> timotimo: Yeah, now that I can get the individual codepoints reliably, I can start decoding key escape sequences.  :-)

[01:25] <timotimo> don't forget to kick out the comment about libuv and threads

[01:25] <timotimo> and i expect you don't have to open /dev/tty

[01:31] <benjikun> How hard would it be to implement an ssh client in perl6

[01:33] *** Zor joined
[01:38] <timotimo> well, there's already a libssh binding that does async i/o

[01:45] *** ilbot3 left
[01:45] *** Cabanossi left
[01:48] *** Cabanossi joined
[01:49] <zengargoyle> i seem to remember an article on RSA (or some other encryption) that had quite minimal p6 by using all of the expmod() and prime built-in mathy things.

[01:50] <TEttinger> expmod?

[01:50] <TEttinger> exponent in a modular arithmetic field?

[01:51] <zengargoyle> something like e**x mod n but yeah, but not the obvious simple math thing.

[01:52] *** ilbot3 joined
[01:52] *** ChanServ sets mode: +v ilbot3

[01:54] <timotimo> yeah, there's algorithms for expmod that perform a whole lot better than exponentiating and then modding

[01:54] <timotimo> both in terms of speed and memory usage

[02:00] <timotimo> bedtime

[02:07] *** vendethiel joined
[02:15] *** bjz joined
[02:29] *** araraloren joined
[02:35] *** M-Illandan joined
[02:45] *** Cabanossi left
[02:45] <SmokeMachine> m: say "bla:ble".split: /:/

[02:45] <camelia> rakudo-moar 51e59e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unrecognized regex metacharacter : (must be quoted to match literally)␤at <tmp>:1␤------> 3say "bla:ble".split: /:7⏏5/␤    expecting any of:␤        argument list␤        term␤»

[02:46] <SmokeMachine> m: say "bla:ble".split: /":"/

[02:46] <camelia> rakudo-moar 51e59e: OUTPUT: «(bla ble)␤»

[02:46] <SmokeMachine> :)

[02:48] *** Cabanossi joined
[02:55] *** noganex_ joined
[02:58] *** noganex left
[03:05] *** Zor left
[03:17] <araraloren> morning

[03:18] <araraloren> String is faster than regex

[03:18] *** Erroneous_ left
[03:20] *** rubio_terra left
[03:21] <SmokeMachine> araraloren: yes, but my real case is /\s* ":" \s*/

[03:27] <araraloren> SmokeMachine, I test it, split with ":" the trim is faster than split by regex

[03:27] <araraloren> s/the/then/

[03:28] *** Cabanossi left
[03:31] *** Cabanossi joined
[03:32] *** bjz left
[03:36] *** skids joined
[03:39] *** bjz joined
[03:46] <araraloren> .tell andrzejku After we add the run configuration, it was working!

[03:46] <yoleaux> araraloren: I'll pass your message to andrzejku.

[03:47] <araraloren> .tell andrzejku Though it has a different with what  we thought .

[03:47] <yoleaux> araraloren: I'll pass your message to andrzejku.

[04:00] *** itaipu joined
[04:14] *** ryu0 joined
[04:16] *** itaipu left
[04:23] *** mscha left
[04:29] *** Cabanossi left
[04:31] *** Cabanossi joined
[04:44] <jeromelanteri> hello all

[04:44] <jeromelanteri> with Git::Wrapper, how to get any unsucces/errors/failed things who should happen eventually ?

[04:50] <araraloren> catch exception ?

[04:56] <jeromelanteri> araraloren, there is no exception to catch... command is send, then... i hope to have with this module a kind of "success" variable... 

[04:57] <jeromelanteri> an other one question, i have many modules <add remove modify install uninstall update> and some sub functgions had same name: <all_repos repo_from_group, etc...>

[04:57] <jeromelanteri> then there is conflicts the way i do declare things... our sub all_repos($things) is export(:MANDATORY) {...} 

[04:58] <jeromelanteri> from there, i can call: add::all_repos(my_things);

[04:58] <jeromelanteri> i want to be able to call modules by there own name, and keep same names functions without have problems... it should be possible correct ? but how to ?

[05:09] <araraloren> jeromelanteri, do you mean, call $whatmode:add_repos(...) ?

[05:09] <araraloren> s/mode/module/

[05:11] <geekosaur> I am not understanding the question here

[05:12] * geekosaur is guessing all those uses of "module" should be "method"?

[05:12] <araraloren> jeromelanteri, I check Git::Wrapper source code,  and I think it has no something like **success** , even not handle error message

[05:13] <geekosaur> in which case: a method call has an invocant, a sub doesn't.

[05:13] <geekosaur> $foo.method_here(...)

[05:13] <geekosaur> vs. some_sub_here

[05:13] <geekosaur> er, some_sub_here(...)

[05:14] *** ilbot3 left
[05:16] <geekosaur> if you actually mean modules, giving them names like add or remove is a really bad idea because yes, it conflicts. I'm not sure it even makes sense to split modules that way...

[05:17] <geekosaur> but if somehow it does, a namespace prefix is likely a good idea. use Foo::add; Foo::add::somesub(...);

[05:17] <geekosaur> also you should be aware that lowercase module names are reserved for pragmas

[05:18] *** ilbot3 joined
[05:18] *** ChanServ sets mode: +v ilbot3

[05:18] <geekosaur> (as are all-uppercase names)

[05:19] <ryu0> I have experience mostly with traditional unix languages (C, Awk, Shell), with C being the one I have the most experience with. I have been looking for a language to supplement these, but I have no prior experience with Perl. Would Perl be a good fit for me? If so, why might it be?

[05:19] <geekosaur> for example, "use fatal;" in a scope causes all Failures (delayed exceptions that throw if used without testing/defusing them first) to become normal exceptions

[05:21] <geekosaur> ryu0, with that background perl 5 is likely the better fit... but it's always good to expand your horizons

[05:21] <araraloren> ryu0, here is Perl 6, Perl 5 is borrow many idea from C Awk Shell 

[05:21] <ryu0> geekosaur: why? i was thinking perl6 might be more in line with what i'm wanting to do.

[05:22] <geekosaur> and these days it's hard to get by without experience in *some* OO language. (perl 5 and python don't really count, their OO is baling wire and chewing gum, aside from p5's Moose which instead s painfully slow)

[05:22] <ryu0> I have also dabbled in functional languages, but wasn't too thrilled with them.

[05:22] <ryu0> Mostly their syntax was weird.

[05:22] <araraloren> Perl 6 is actually modern language

[05:22] <ryu0> Lisp in particular.

[05:23] <araraloren> with multi programming form

[05:23] <geekosaur> lisp certainly takes some getting used to. there are functional languages that aren't Lisp/Scheme or ML family, though; take a look at scala.

[05:23] <ryu0> I actually liked the SML variant of ML.

[05:23] <ryu0> Was easier to relate to.

[05:25] <ryu0> I also tried Go, so I do have some experience with OO constructs.

[05:25] <ryu0> C++ is something i've also had to use at points.

[05:26] <jeromelanteri> araraloren, geekosaur yes, i'm talking about modules, so, sub function, not method class object nor instance things.

[05:27] <jeromelanteri> unit module a; our sub blabla() is export(/MANDATORY) { } // use a; a:blabla(); works, but if i have:

[05:28] <jeromelanteri> unit module b; our sub blabla() is export(:MANDATORY) {} // use a; use b; a::blabla() (error... two functions has the same name)

[05:28] <geekosaur> don't use all-lowercase module names; they are reserved for use as pragmas. (and a few internals modules that you proably don't want to mess with)

[05:29] <geekosaur> also, you are basically asking for that when you export the names; you are telling perl 6 to pull those names into your namespace.

[05:29] <geekosaur> although qualified *should* work.

[05:29] <geekosaur> since they're "our"

[05:30] <jeromelanteri> geekosaur, ok

[05:30] <jeromelanteri> so actually, what can be the solution ?

[05:31] <jeromelanteri> if i remove "our", i can no more call A::blabla();

[05:31] *** benjikun left
[05:38] <geekosaur> I am still not understanding

[05:38] <geekosaur> you want to force multiple declaration? what is supposed to happen?

[05:38] <geekosaur> I mean, you are basically creating an impossible situation and saying that you think it is the correct way to do things

[05:39] <geekosaur> you are exporting with forced import suns with the same name from multiple modules

[05:39] <geekosaur> the result will be Cannot import symbol &foo from Bb, because it already exists in this lexical scope

[05:40] <geekosaur> either don't export and use qualified names, or export with a tag so users can choose to import or not as needed

[05:40] <jeromelanteri> geekosaur, each function is embeded inside a module...

[05:40] <geekosaur> if I kill the is export(:MANDATORY) then I can call Aa::foo and Bb::foo with no problem

[05:41] <jeromelanteri> it can have a function in module A same name that an other one function in module B

[05:41] <geekosaur> if you force export with is export(:MANDATORY) then it cannot *import* two modules doing so with the same name into the same scope

[05:41] <jeromelanteri> then call by A::bla(); B::bla(); for make this works ? why impossible ? it should be possible by the fact they are embeded in different modules...

[05:41] <geekosaur> that does work

[05:42] <geekosaur> what does not work is "use"ing both of those, because they both try to define bla() *in the module that "use"s them*

[05:42] <geekosaur> because you said is export(:MANDATORY)

[05:42] <jeromelanteri> geekosaur, so just remove is export(:MANDATORY) should do the job i want ?

[05:42] <geekosaur> yes

[05:43] <geekosaur> you don't need to export them, you made them "our"

[05:43] *** pilne left
[05:43] <jeromelanteri> geekosaur, oh ok, fine...

[05:43] <jeromelanteri> so export is for put them in the scope with a kind of tag (:MANDATORY is the default one)

[05:44] <jeromelanteri> geekosaur, thank you

[05:44] <geekosaur> export is to make them appear as if they were defined in the module that "use"s them

[05:44] <jeromelanteri> ok

[05:44] *** khw left
[05:44] <geekosaur> you can see why this is a problem if you do that to functions with the same name in two different "use"d module

[05:44] *** Cabanossi left
[05:45] <jeromelanteri> so yes, definitly, by call module name, i absolutly no need is export

[05:45] <geekosaur> you could put them on some other tag so people can choose to import them into their namespace, if they know it won't cause a problem, by specifying that tag

[05:45] <geekosaur> use Foo :IMPORTS; # or some such

[05:45] <jeromelanteri> geekosaur, ho yes, that should be an other one solution

[05:45] <geekosaur> then you can choose which one gets to use the unqualified names

[05:46] <jeromelanteri> but then, is use A :Tag_A; use B :Tag_B with modules contain some same named functions... it should not works same or it should works ?

[05:46] <geekosaur> that would fail

[05:46] *** Cabanossi joined
[05:46] <jeromelanteri> ok, well understand

[05:47] <jeromelanteri> it just call by a tag functions to export in the scop of the actual module use them...

[05:47] <geekosaur> Haskell imports work the way you want, but it comes with other behaviors that surprise people

[05:47] <jeromelanteri> yes

[05:47] <geekosaur> there's no nice way to do things so it all somehow "just works"; *something* will be annoying

[05:48] <jeromelanteri> geekosaur, you may be able to understand (if you want also) that this objection doesn't care  about the fact i am not english and my vocabulary is limited...

[05:48] <jeromelanteri> geekosaur, but do what you want, and thank you for your help.

[05:49] <geekosaur> I had noticed (you seem to be translating some French idioms that don't quite work in English)

[05:49] <geekosaur> sadly my French is not very good

[05:50] <jeromelanteri> yes, i'm french

[05:50] <araraloren> jeromelanteri, you can show him the module code

[05:50] <jeromelanteri> i will not hurt you the day you will try to write french and not find the precise best words for explain your problem, don't worry.

[05:51] <jeromelanteri> araraloren, yes i can: https://bitbucket.org/jerome___/vimplugger/src

[05:51] <jeromelanteri> all modules actually... i'm going to just remove all export things

[05:51] <geekosaur> I'm not complaining, just noting.

[05:51] <jeromelanteri> geekosaur, nop

[05:52] <araraloren> Actually , I think Module.method is not bad thing

[05:52] <jeromelanteri> what is "module.method" ? i thank that method is not module, but class method

[05:52] <jeromelanteri> module.function and class.method.. isn't it ?

[05:54] <geekosaur> I would expect module.method to look for methods defined on a Module

[05:56] <geekosaur> araraloren, I think you wanted :: not .

[05:56] <jeromelanteri> geekosaur, i didn't no it was possible... i always thinki (so i just start learning perl6 one week an half ago) that method is not module but for class... or maybe all file finished by .pm6 is a module... also if there is class inside. 

[05:56] <jeromelanteri> s/no/know

[05:57] <geekosaur> a module (and other things that subclass Package, like Class) is an object like anything else, with methods. but introspection doesn't seem to work :/

[05:57] <jeromelanteri> well..; that makes me confuse actually.

[05:58] <geekosaur> m: module A {}; .say for A.^methods

[05:58] <camelia> rakudo-moar 51e59e: OUTPUT: «No such method 'methods' for invocant of type 'Perl6::Metamodel::ModuleHOW'␤  in block <unit> at <tmp> line 1␤␤»

[05:58] <geekosaur> the MOP for Module is incomplete :/

[05:58] <geekosaur> module A {}; say A.WHAT

[05:58] <jeromelanteri> :)

[05:59] <geekosaur> er

[05:59] <geekosaur> m: module A {}; say A.WHAT

[05:59] <camelia> rakudo-moar 51e59e: OUTPUT: «(A)␤»

[05:59] <geekosaur> m: module A {}; say A.HOW

[05:59] <camelia> rakudo-moar 51e59e: OUTPUT: «Perl6::Metamodel::ModuleHOW.new␤»

[05:59] <ryu0> geekosaur: So then why might I want to use Perl6? I don't have much of an opinion about either major version of Perl.

[06:00] <jeromelanteri> so sub is for declaration of module.method in perl6 speaking "nice" ?

[06:02] <geekosaur> ryu0, I'm not really the right prson to ask.. especially right no when the only reason I'm still up is someone set off the fire alarms (it's "all clear" but they're still making it impossible to sleep...)

[06:02] <geekosaur> also apparently I can't type... oy

[06:02] <ryu0> Ok.

[06:03] <jeromelanteri> geekosaur, you taold something interesant about pragmas and modules names conventions...

[06:03] <jeromelanteri> what is a pragmas ?

[06:04] <jeromelanteri> do i need then to move files modules names in same convention (upper case for first letter) ?

[06:06] <geekosaur> to the second, yes

[06:06] <jeromelanteri> also, i have a files names datas.pm6 who doesn't contain a module, but a class... do i need to do same with this class name and the datas.pm6 file ?

[06:07] <jeromelanteri> ok, move modules files names to uv first letter, and declare them same convention... and for the class inside the datas.pm6 file ? same ?

[06:07] <geekosaur> classes are the same way, yes.

[06:07] <jeromelanteri> ok

[06:07] <jeromelanteri> thank you

[06:07] <jeromelanteri> and a link for explain pragmas ?

[06:07] <geekosaur> as for pragmas, they're generally instructions to change the compiler / language's behavior in the current scope

[06:07] <geekosaur> https://docs.perl6.org/language/pragmas

[06:08] <geekosaur> so, for example, ``` use lib "/usr/lib/ourstuff"; ``` tells perl 6 to look for modules in the specified directory as well as the usual places

[06:09] <geekosaur> ```use fatal;``` turns delayed exceptions ("Failure") into normal exceptions

[06:09] <jeromelanteri> ok

[06:09] <jeromelanteri> it is kind of modules reserved then ?

[06:09] <araraloren> geekosaur, yeah, class module, or class

[06:10] <zengargoyle> hehe...

[06:11] <geekosaur> so all-lowercase module names are reserved, all-uppercase module names are reserved (generally to enable dangerous things)

[06:14] <araraloren> If I have a sample.pm6, do I have to declare module with: unit module sample;

[06:14] <araraloren> or the `sample` can be other thing else ?

[06:14] <geekosaur> "unit module" is just a way to save on braces

[06:14] <geekosaur> oh. they have to match, yes

[06:14] <araraloren> So when I `use sample;` what the sample mean ?

[06:15] <araraloren> mean the filename ?

[06:15] <geekosaur> when it sees that, it has to go out and look for a file with that name.

[06:15] <geekosaur> it can't ask something if there is some file somewhere that contains a perl 6 module definition

[06:15] <geekosaur> (at least, not if you want it to actually run today...)

[06:16] <zengargoyle> jeromelanteri: remember i said that you try too hard with export and easy single name modules like 'check', 'install', 'add'?  it would go easier if you did VimPlugin::Check, VimPlugin::Install, VimPlugin::Add and then made it easy after it works.

[06:16] <geekosaur> I suggested that earlier, actually

[06:16] <geekosaur> not sure if it was understood

[06:17] <geekosaur> araraloren, so when it sees 'use module Foo;' it checks a number of standard places (which you can add to with a ```use lib 'wherever'```; pragma) for files named Foo.pm6 or Foo.pm

[06:17] <zengargoyle> geekosaur: i made a repo with mostly decent distro standards but jeromelanteri didn't wan't to even look ATM.

[06:18] <jeromelanteri> zengargoyle, yes, i miss understood this part.

[06:18] <zengargoyle> it is convention that most people do not break, so nobody knows how to not do it that way.. :)

[06:18] <araraloren> geekosaur, oh, it make sense, thanks

[06:18] <jeromelanteri> zengargoyle, so not VimPlugin, but Add::function_name ...

[06:19] <zengargoyle> better, but what if you ever write another program with 'Add' modules?

[06:19] <geekosaur> someday it might be interesting to have object filesystems where e.g. perl 6 could register a handler with it to let it respond to "find a perl 6 module named Foo". but currently nothing knows how to use such things, unless you count the simplified forms built into various GUIs (windows explorer, os x finder, gnome/kde/whatever, etc.)

[06:20] <jeromelanteri> zengargoyle, an other one programm with Add module should not be mixed in the same lib... but ok, i understand what you mean.

[06:20] <zengargoyle> you can not easily have two different Add or Check modules, but you can easily have VimPlugin::Add and VimPlugin::Check.

[06:21] <jeromelanteri> zengargoyle, look at my code, i do modify it... i think there is no VimPlugger::things...

[06:21] <geekosaur> jeromelanteri, maybe more to the point: someday you may want to use a program that wants to use Add from both

[06:21] <zengargoyle> yeah, if you don't realy want to make a module you can install, or ever mix parts of different projects together... short Add will do. :P

[06:21] <geekosaur> let's say you have a git library with Add::whatever, and a vim library with Add::whatever, and at some point you want to use them to add git integration to your vim setup

[06:21] <geekosaur> "oops"

[06:22] *** statisfiable6 left
[06:24] <zengargoyle> jeromelanteri: i know is feels a bit bad to have SomeLong::Name::For::A::Module, but that almost always works, and there are ways to do short name after module is finished.

[06:25] <jeromelanteri> zengargoyle, that also was my idea... or i missunderstand you. Could you please look at my code for be sure ?

[06:26] <geekosaur> m: module ReallyLongAnnoyingName { our sub foo { say "foo!" } }; constant RLN = ReallyLongAnnoyingName; RLN::foo;

[06:26] <camelia> rakudo-moar 51e59e: OUTPUT: «foo!␤»

[06:26] *** darutoko joined
[06:27] <zengargoyle> m: module ReallyLongAnnoyingName { our sub foo { say "foo!" } }; my \foo = ReallyLongAnnoyingName::foo; foo;

[06:27] <camelia> rakudo-moar 51e59e: OUTPUT: «WARNINGS for <tmp>:␤Useless use of foo symbol in sink context (line 1)␤foo!␤»

[06:27] <geekosaur> (this, btw, is one reason why modules are objects)

[06:27] <zengargoyle> heh

[06:27] <geekosaur> hrm. that's LTA

[06:27] <zengargoyle> m: module ReallyLongAnnoyingName { our sub foo { say "foo!" } }; my &foo =&ReallyLongAnnoyingName::foo; foo;

[06:27] <camelia> rakudo-moar 51e59e: OUTPUT: «foo!␤»

[06:27] <zengargoyle> m: module ReallyLongAnnoyingName { our sub foo { say "foo!" } }; my \foo =&ReallyLongAnnoyingName::foo; foo;

[06:27] <camelia> rakudo-moar 51e59e: OUTPUT: «WARNINGS for <tmp>:␤Useless use of foo symbol in sink context (line 1)␤»

[06:28] <zengargoyle> guess sigil matters in assignment.

[06:29] *** wamba joined
[06:29] <geekosaur> actually...

[06:29] <geekosaur> m: module ReallyLongAnnoyingName { our sub foo { say "foo!" } }; my \foo = ReallyLongAnnoyingName::foo; say "bar"; foo;

[06:29] <camelia> rakudo-moar 51e59e: OUTPUT: «WARNINGS for <tmp>:␤Useless use of foo symbol in sink context (line 1)␤foo!␤bar␤»

[06:29] <geekosaur> see what it did there?

[06:30] <jeromelanteri> zengargoyle, geekosaur the idea is not to be annoying, but to give a name that make understand what it is supposed to do... then other coming (and me to) should be able to understand what the function want to do.

[06:30] <geekosaur> oh, I know.

[06:31] <jeromelanteri> but sure... i can change names by LongAnnoyingName => A. It should quickly become unreadable.

[06:31] <geekosaur> er. that wasn't a response to you

[06:31] <zengargoyle> call vs name for hot using &Really....

[06:31] <geekosaur> m: module ReallyLongAnnoyingName { our sub foo { say "foo!" } }; my \foo = &ReallyLongAnnoyingName::foo; say "bar"; foo();

[06:31] <camelia> rakudo-moar 51e59e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '&foo' is not declared␤at <tmp>:1␤------> 3ReallyLongAnnoyingName::foo; say "bar"; 7⏏5foo();␤»

[06:31] <zengargoyle> because no &

[06:31] <geekosaur> yeh

[06:31] <zengargoyle> but i sorta thought my \foo = &R... would maybe work.

[06:31] <geekosaur> m: module ReallyLongAnnoyingName { our sub foo { say "foo!" } }; my \foo = &ReallyLongAnnoyingName::foo; say "bar"; foo.();

[06:31] <camelia> rakudo-moar 51e59e: OUTPUT: «bar␤foo!␤»

[06:31] <zengargoyle> thought that was basically a bind.

[06:32] <geekosaur> it is. but a bare simple term like "foo" is special cased

[06:32] <zengargoyle> ah. *nods*

[06:33] <geekosaur> so you need the parens, but then it explodes because that too is a special case (specifically looks for & sigil), so have to use .()

[06:33] <jeromelanteri> wel.. all is updated on bitbucket. And now it works fine.

[06:33] <jeromelanteri> thank you

[06:33] <geekosaur> every DWIM has a WAT, etc.

[06:33] <zengargoyle> jeromelanteri: i will look later... 

[06:34] <zengargoyle> my brain still hurts from Git::Wrapper :P

[06:35] <jeromelanteri> zengargoyle, it is not an obligation. But i think we were speaking about the same idea but your example seems to talk about my code without read it (so it makes me strange i xas not sure to well understand what you mean). Git::Wrapper was a real good fix for me...

[06:36] <jeromelanteri> Gt::Wrapper doesn't have any success "getter"... so i have to do something for read if clone things worked or not... it will be complicate i think.

[06:36] <jeromelanteri> it oesn't have any error getter to...

[06:36] <jeromelanteri> in perl5 RPC things has scucces catch...

[06:36] <jeromelanteri> success

[06:38] <zengargoyle> does p6 have the same thing as some p6 Exporter modules where use Foo bar => { -as => 'baz' }; or similar makes &baz = &Foo::bar ?

[06:39] <araraloren> The namespace is not a easy thing can better control, like c++, you must not define a function already exists in **std**

[06:39] <zengargoyle> jeromelanteri: yes, i need to pull code again before looking.

[06:39] <araraloren> EXPORT ?

[06:41] <zengargoyle> jeromelanteri: and yeah, Git::Wrapper i don't think is a *good* module.  captures stderr and throws it away, doesn't check system() return codes, just assumes it works and returns stdout.

[06:42] <jeromelanteri> zengargoyle, but then use "run" do the same job... i not well understand the interest of Git::Wrapper if it can not do that. Maybe it will grow on this way ?

[06:42] <zengargoyle> somebody needed it and did the thing that worked and kept going with original problem. :P

[06:42] *** raiph left
[06:43] <zengargoyle> i have done worse myself. :)

[06:43] <jeromelanteri> zengargoyle, if i wasn't so nOObs i would add some features...

[06:43] <zengargoyle> i have done better myself. :)

[06:43] <jeromelanteri> actually, i can not i think. 

[06:44] <jeromelanteri> zengargoyle, please... do it now...

[06:44] *** Cabanossi left
[06:44] <jeromelanteri> i promise i will put your name in the title of my poor nOObs bitbucket repo...

[06:45] <zengargoyle> i did a lot of Wrapper at last $WORK.  but don't know p6 run/shell stuff that well yet.

[06:46] <jeromelanteri> (crying)

[06:46] <zengargoyle> (sometimes the CLI program that is Wrapped doesn't even have decent error or return code.... )

[06:46] <jeromelanteri> i failed to find some situations for git...

[06:46] *** Cabanossi joined
[06:47] <jeromelanteri> the idea is to check repo exist (that is ok... Validate), and also to tell if clone/pull requests success or not

[06:48] <jeromelanteri> (i said that is ok... but i'm not so sure in all situation of url that has been given)

[06:49] *** espadrine joined
[06:51] <zengargoyle> i have not used git in an automatic way.  always more manual and seeing errors and 'not working' was an OK thing for me.

[06:51] <zengargoyle> so i do not know git error code or failure mode that well.  usually a typo or internet is broken :)

[06:52] <jeromelanteri> same

[06:53] *** skids left
[07:02] <araraloren> That Git::Wrapper has a little problem in META6.json 

[07:03] *** abraxxa joined
[07:04] *** rindolf joined
[07:05] <zengargoyle> araraloren: what is the problem?  i have another pull-request for not working when precompiled.  (so jeromelanteri is using a patched Git::Wrapper anyway).

[07:06] <araraloren> the provides 

[07:06] <jeromelanteri> zengargoyle, merged with master

[07:06] <jeromelanteri> used also the perlpilot one

[07:07] <jeromelanteri> (but this should not make problems)

[07:07] <jeromelanteri> wich branch are you in ?

[07:07] <zengargoyle> oh, cool.  i didn't see a github email. :)

[07:07] <jeromelanteri> because it is not github... it is bitbucket

[07:08] *** abraxxa left
[07:08] <jeromelanteri> zengargoyle, but... if you want to push on it, you are welcome

[07:08] <zengargoyle> jeromelanteri: we are missing communication. :)

[07:09] <zengargoyle> araraloren and i were talking about  source:     git://github.com/nicqrocks/p6-Git-Wrapper.git

[07:09] <jeromelanteri> yes

[07:09] <zengargoyle> i think.   that is not bitbucket....

[07:09] <jeromelanteri> i do speak about this one in my README to

[07:11] <jeromelanteri> araraloren, normally, if you read all the content of my readme file, you should find the solution by do things i explain. (but if not, tell me and i will correct my README file for be more clear)

[07:11] *** setty1 joined
[07:11] <jeromelanteri> zengargoyle, ho well ... we cross speaking different things.

[07:12] <jeromelanteri> i do coding in the same time than...

[07:12] <zengargoyle> when i pull or clone i only get master branch.

[07:12] <zengargoyle> of your bitbucket.

[07:12] <araraloren> zengargoyle, yeah https://github.com/nicqrocks/p6-Git-Wrapper/blob/master/META6.json 

[07:13] <zengargoyle> guess i need to maybe look at bitbucket api to learn branch names to pull.

[07:13] <jeromelanteri> zengargoyle, perfect... actually, there is only master branch

[07:13] <zengargoyle> araraloren: what is the problem with the provides section.

[07:14] <jeromelanteri> zengargoyle, you no need to pull Git::Wrapper branch, this branch is merged back in master now.

[07:14] <jeromelanteri> and bitbucket is same cxommand as git (so github same).

[07:14] <araraloren> so the module is the file name. Can a file provide three module /

[07:14] <araraloren> ?

[07:15] <zengargoyle> a file can provide 3 classes.

[07:15] <jeromelanteri> araraloren, now you touch why i don't like to speak about module for a class...

[07:15] <jeromelanteri> class/module... not the same.

[07:16] <jeromelanteri> then why for me, method is about class (not module).

[07:16] <araraloren> I don't think it's class

[07:17] <araraloren> In the provides section, include all the namespaces provided by your distribution and that you wish to be installed, only module files that are explicitly included here will be installed and available with use or require in other programs.

[07:17] <araraloren> This is what the document said

[07:17] <jeromelanteri> a class can be instanciate (i don't know if this english word is correct also), but module can not.

[07:17] <zengargoyle> i *think* once it's compiled, a class is a CompUnit.  it makes little difference where on the filesystem they were before being compiled.

[07:17] <araraloren> **namespaces **

[07:19] <jeromelanteri> araraloren, so why and when use class instead of module ? class is definitly for create objects to be instanciate, not modules.

[07:19] <jeromelanteri> concept is definitly not the same

[07:19] <araraloren> you use a module, import name

[07:19] <araraloren> not use a name

[07:20] *** holyghost joined
[07:20] <jeromelanteri> ???

[07:21] <araraloren> an exported class is a name, a variable is name. 

[07:21] <araraloren> this is something in symbol table

[07:23] <araraloren> m: module A { our $e is export; }; say ::.keys; import A; say ::.keys;

[07:23] <camelia> rakudo-moar 51e59e: OUTPUT: «($=pod $_ $/ A !UNIT_MARKER $e $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤($=pod $_ $/ A !UNIT_MARKER $e $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤»

[07:23] <araraloren> m: module A { our $e is export; }; say ::.keys;

[07:23] <camelia> rakudo-moar 51e59e: OUTPUT: «($=pod $_ $/ A !UNIT_MARKER $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤»

[07:23] <araraloren> say the $e in ::.keys

[07:23] <evalable6> araraloren, rakudo-moar 51e59eeb5: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/n3NtbyZ2L7␤Variable '$e' is not declared␤at /tmp/n3NtbyZ2L7:1␤------> 03say the 08⏏04$e in ::.keys»

[07:23] <araraloren> see

[07:24] <araraloren> m: module A { class Want {} is export; }; say ::.keys;

[07:24] <camelia> rakudo-moar 51e59e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3module A { class Want {}7⏏5 is export; }; say ::.keys;␤    expecting any of:␤        infix␤        infix stopper…»

[07:24] <jeromelanteri> araraloren, a variable is an object... defined by a class object.

[07:25] <araraloren> m: module A { class Want is export {}; }; say ::.keys;

[07:25] <camelia> rakudo-moar 51e59e: OUTPUT: «($=pod $_ $/ A !UNIT_MARKER $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤»

[07:25] <araraloren> m: module A { class Want is export {}; }; import A; say ::.keys;

[07:25] <camelia> rakudo-moar 51e59e: OUTPUT: «($=pod Want $_ $/ A !UNIT_MARKER $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤»

[07:26] <jeromelanteri> and again, a module is not a class, a class is not a module.

[07:26] <jeromelanteri> they have some name yes... everything has a name. Do they are the same ?

[07:26] <araraloren> I mean the name in symbol table. When you reference a class or variable, it was search that **name** in the symbol table.

[07:26] <araraloren> so the provides is not correct

[07:26] <zengargoyle> m: module A { class Want is export {}; }; say ::.keys; say ::A::Want.WHAT;

[07:26] <camelia> rakudo-moar 51e59e: OUTPUT: «($=pod $_ $/ A !UNIT_MARKER $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤(Want)␤»

[07:27] <jeromelanteri> araraloren, yes sure, but what i mean is that call moduyle everything is not clear.

[07:27] <araraloren> you mean you don't know what the module provides ?

[07:28] <jeromelanteri> same, a variable is define has a specific object class.. but you call it a variable, not a class. my Str $x; is a variable defined by class Str...

[07:28] <jeromelanteri> araraloren, no, nevermind.

[07:28] <zengargoyle> m: module A { class Want is export {}; }; say ::.keys; say ::A::Want.new.WHAT;

[07:28] <camelia> rakudo-moar 51e59e: OUTPUT: «($=pod $_ $/ A !UNIT_MARKER $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤(Want)␤»

[07:28] <zengargoyle> m: module A { class Want is export {}; }; say ::.keys; say ::A::Want.new.WHAT; say Want.new.WHAT;

[07:28] <camelia> rakudo-moar 51e59e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    Want used at line 1␤␤»

[07:29] <zengargoyle> m: module A { class Want is export {}; }; say ::.keys; say ::A::Want.new.WHAT; say ::Want.new.WHAT;

[07:29] <camelia> rakudo-moar 51e59e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤No such symbol 'Want'␤at <tmp>:1␤------> 3keys; say ::A::Want.new.WHAT; say ::Want7⏏5.new.WHAT;␤»

[07:29] <jeromelanteri> zengargoyle, ...oO...

[07:31] <zengargoyle> m: module A { class Want is export {}; }; import A; say ::.keys; say ::A::Want.new.WHAT; say ::Want.new.WHAT;

[07:31] <camelia> rakudo-moar 51e59e: OUTPUT: «($=pod Want $_ $/ A !UNIT_MARKER $=finish EXPORT $! ::?PACKAGE GLOBALish $¢ $?PACKAGE)␤(Want)␤(Want)␤»

[07:31] * zengargoyle missed the import part.

[07:31] <jeromelanteri> sure, a module can contain a class... a class can not contain  a module... and you not use module and class for do same things. It is not the design pattern idea of "what is a class" and "what is a module".

[07:32] <jeromelanteri> that is also why a file can not contain more than one module (due to fact that it needs to follox name of his file also), but can contain many class...

[07:33] <zengargoyle> i usually don't export class.

[07:33] <jeromelanteri> there is conceptual idea about what a class is for and what a module is for... but sure, after, you can use class or module for other things, but it will not be a powerfull design pattern.

[07:33] *** kaare__ joined
[07:34] <zengargoyle> m: module A { class Want is export {}; class Dont {}; }; import A; say A::Dont.new.WHAT;

[07:34] <camelia> rakudo-moar 51e59e: OUTPUT: «(Dont)␤»

[07:34] <jeromelanteri> and that is not specific for perl6 or other OO language... it is same for all OO langage.

[07:34] <zengargoyle> class in module is to save typing -ish

[07:34] <jeromelanteri> yes

[07:34] <zengargoyle> m: class A::Want is export {}; class A::Dont {}; }; say A::Dont.new.WHAT;

[07:34] <camelia> rakudo-moar 51e59e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3A::Want is export {}; class A::Dont {}; 7⏏5}; say A::Dont.new.WHAT;␤»

[07:34] <jeromelanteri> save an object you use specifically with this module

[07:34] <zengargoyle> m: class A::Want {}; class A::Dont {}; }; say A::Dont.new.WHAT;

[07:34] <camelia> rakudo-moar 51e59e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3class A::Want {}; class A::Dont {}; 7⏏5}; say A::Dont.new.WHAT;␤»

[07:35] <zengargoyle> m: class A::Want {}; class A::Dont {}; say A::Dont.new.WHAT;

[07:35] <camelia> rakudo-moar 51e59e: OUTPUT: «(Dont)␤»

[07:35] <jeromelanteri> araraloren, you get it ?

[07:36] <zengargoyle> m: module A { class A::Want is export {}; class A::Dont {}; }; import A; say A::Dont.new.WHAT;

[07:36] <camelia> rakudo-moar 51e59e: OUTPUT: «(Dont)␤»

[07:36] <zengargoyle> and it's smart....

[07:37] <zengargoyle> m: module A { class A::Want is export {}; class A::Dont {}; }; import A; say A::Dont.new.WHAT; say A::A::Dont.WHAT;

[07:37] <camelia> rakudo-moar 51e59e: OUTPUT: «(Dont)␤Could not find symbol '&Dont'␤  in block <unit> at <tmp> line 1␤␤»

[07:37] *** kaare_ left
[07:39] <araraloren> no I don't mean the module you declare in a .pm6 or whatever file

[07:40] <araraloren> I mean the module what we `use module;`

[07:40] <araraloren> use

[07:40] *** kaare__ left
[07:41] <jeromelanteri> there is also this problem about declare or define...i used to make things with C++...

[07:41] *** kaare__ joined
[07:42] <jeromelanteri> araraloren, i understand what you mean... do you understand what i mean to ?

[07:42] <zengargoyle> if i understood correctly, when using a filesystem CUR like with -Ilib or 'use "lib"' then the name of the file (minus extension and :: ized) is used to find the module.

[07:42] <araraloren> a little..

[07:42] <jeromelanteri> talk about module for a class make things confuse more than clear (this resume what i mean)

[07:43] <zengargoyle> unless there is a META that has that information like when using -I. in a distribution directory, then it used information from META.

[07:44] <zengargoyle> whan looking in other system CUR, it is just the name of the thing.  there's no filesystem file name information left once it has been compiled and in CUR.

[07:44] <zengargoyle> anyways, it's really complicated compared to perl 5 :)

[07:45] *** holyghost_ joined
[07:45] *** Cabanossi left
[07:45] <jeromelanteri> so in perl6, if i well understand, "use" is a kind of concept macro command for ("import" +" load")... ? And it can depend of a context (use lib // use Something => what is inside ?//).

[07:45] <araraloren> it's like c++, use a namespace, import some class or variable you declare

[07:45] <zengargoyle> maybe module all get loaded at once so you don't use each of them individually?

[07:46] <araraloren> jeromelanteri, you have to read document carefully 

[07:46] <jeromelanteri> ok

[07:46] <araraloren> https://docs.perl6.org/language/modules#use

[07:46] <jeromelanteri> araraloren, actually, i have many problem to well understand document sometimes... it needs maybe some more examples

[07:46] <zengargoyle> jeromelanteri: yes, at lest use == need + import

[07:46] *** Cabanossi joined
[07:46] <jeromelanteri> zengargoyle, that what i understood to.

[07:48] <jeromelanteri> araraloren, also, when you asked if a file can contain many modules, i'm not sure you read that doc so carrefully (or maybe same me, sometime you not reeally understand this doc).

[07:48] *** holyghost left
[07:49] <araraloren> Hmm, don't use **module** is better solution, it's a CompUnit

[07:49] <araraloren> but, everyone call them module

[07:49] <zengargoyle> araraloren: did you look that up?

[07:49] <jeromelanteri> i like to use module when his concept is good for what i need... and then, i call it a module.

[07:50] <zengargoyle> i just guessed that might be true, i don't really know.

[07:50] <zengargoyle> but it makes sense if true.

[07:54] *** wamba left
[07:57] <araraloren> yeah, I read it 

[07:57] <zengargoyle> i usually make a distribution and write tests so i don't think about many details.  if test works, i'm right!

[07:57] <araraloren> I often read document, I was not familiar with Perl's thinking 

[07:57] <zengargoyle> araraloren: cool, now i know. :)

[07:58] <zengargoyle> aka think like Larry. :)

[07:59] <araraloren> yeah

[08:00] <jeromelanteri> module/class is not specific to perl6. It is specific to OO languages. Like MVC is not specific to one GUI or web coding... it is a large concept of design pattern to use.

[08:02] <zengargoyle> i do not know many other languages well enough, and fear thinking perl 6 uses the same word to mean the same thing.

[08:03] <zengargoyle> they might be using 'module' wrong! :P

[08:04] <jeromelanteri> zengargoyle, i think you will be interested by read some book about algorythm and design pattern things. That is large concept of programmation. I mean... that is very funny also to read that kind of books.

[08:05] <zengargoyle> i have, but mostly back in C days... not really module/class as a keyword in development.

[08:05] <jeromelanteri> the first time i read that... OMG! it is like i realize the interest of "concept" things of algorythms.

[08:06] <jeromelanteri> and then... rewrite most of my codes again. For me, it was like... open the light inside my dirty room... after that, i wanted to clean my room.

[08:07] <jeromelanteri> i nbever see that was so dirty.

[08:07] <zengargoyle> i guess a module is one .o file with many symbols in it.  but a .c of many classes without a 'module' would be many .o files with only a single symbol.

[08:07] <jeromelanteri> yes

[08:10] <araraloren> I know what you mean the module. But perl6 also has a keyword module, it's confused anyway

[08:11] <jeromelanteri> that's it.

[08:14] <zengargoyle> now i'm maybe remembering when it was 'module Foo;' like perl 5 and was changed to 'unit module Foo;' to make a distintion that it was the whole file.....

[08:16] <zengargoyle> where you could have multiple 'package Foo;' 'package Bar;' in same file without the 'package Foo { }  package Bar { }' scope syntax.

[08:22] *** setty1 left
[08:23] *** nadim joined
[08:28] *** ChoHag left
[08:29] <jeromelanteri> zengargoyle, actually, the machine langage (and you know that if you like asm) talk only about registers for memories, or events, or CPU unit, or mounted interfaces, adress, then command jump, branch, set, ref (some MISC proc  have only 35 commands...). But conceptuels langages (and that is the power of OO and functionnal langages) is for make sesn relatively of what we know allready in our life. It is like a human interface 

[08:29] <jeromelanteri> langage for make code readable and also for make it DRY and KISS.

[08:30] <jeromelanteri> i wascurious of perl because of the conceptor is a linguist.

[08:44] *** Cabanossi left
[08:45] *** holyghost_ left
[08:46] *** Cabanossi joined
[08:47] <zengargoyle> jeromelanteri: continue later, i must sleep. :)  bon nuit.

[08:48] <zengargoyle> je pense mon francais est tres mal. :P

[08:54] *** Cabanossi left
[08:55] *** Cabanossi joined
[09:24] <jeromelanteri> zengargoyle, il est compréhensible, bonne nuit l'homme.

[09:24] *** brrt joined
[09:29] *** andrzejku joined
[09:30] <andrzejku> ls

[09:30] <yoleaux> 03:46Z <araraloren> andrzejku: After we add the run configuration, it was working!

[09:30] <yoleaux> 03:47Z <araraloren> andrzejku: Though it has a different with what  we thought .

[09:44] *** Cabanossi left
[09:47] *** Cabanossi joined
[09:57] *** brrt left
[09:58] *** andrzejku left
[10:03] *** wamba joined
[10:24] <jeromelanteri> an other one module who print nothing (and also... from README file copy/pasted...). No error, but also no nothing. module is Text::Table::List  https://github.com/supernovus/perl6-text-table-list

[10:25] *** TEttinger left
[10:44] *** bjz left
[10:48] *** bjz joined
[10:53] *** Aaronepower left
[10:57] *** espadrine left
[11:06] *** kaare__ left
[11:20] <gfldex> travis fails to build rakudo for me, could anyone check please?

[11:27] *** Aaronepower joined
[11:30] *** pharv left
[11:33] *** espadrine joined
[11:34] *** andrzejku joined
[11:40] *** Rawriful joined
[11:41] <gfldex> rakudo fails to build locally too

[11:41] *** _cronus joined
[11:42] <_cronus> hello, I am having trouble installing bailador

[11:42] <gfldex> samcv: could you unbreak rakudo please?

[11:43] <_cronus> when I run zef install Bailador it stops after failing some tests

[11:43] <gfldex> _cronus: rakudo itself is broken right now

[11:44] <_cronus> gfldex: does the previous version still work?

[11:45] <gfldex> _cronus: 51e59eeb5e48917ed3e825947989f91a219ce2cc should work

[11:45] <jeromelanteri> gfldex, what is travis ? a kind of docker ?

[11:45] <gfldex> jeromelanteri: it's an automatic build system that is triggered by github commits

[11:45] <jeromelanteri> ok

[11:46] *** bjz_ joined
[11:46] <timotimo> i'll look into the rakudo breakage right now

[11:47] <jeromelanteri> _cronus, i see that there is a specific channel on IRC for bailador

[11:48] *** bjz left
[11:48] <jeromelanteri> http://bailador.net/ they are talking about "bailador stack channel (maybe not IRC)

[11:48] <_cronus> gfldex: i'm using rakudo-star-2017.07 which is older

[11:51] <_cronus> jeromelanteri: thanks

[11:54] <timotimo> i do have a fix, but i'll test it first

[11:54] <tadzik> yeah, it's a Slack channel

[11:56] *** HoboWithShotgun joined
[11:56] <HoboWithShotgun> can i tell the .perl method not to recurse into objects?

[11:58] <HoboWithShotgun> you know, like $Data::Dumper::Maxdepth in P5

[11:59] <timotimo> no, .perl is a bit dumber than that

[11:59] <timotimo> what's your use case?

[11:59] <timotimo> perl has detection for circular references, for example

[12:00] *** Cabanossi left
[12:00] <timotimo> m: my $a = []; $a.push($a); $a.push($a); say $a.perl

[12:00] <camelia> rakudo-moar 51e59e: OUTPUT: «((my @Array_77166080) = $[@Array_77166080, @Array_77166080])␤»

[12:00] <timotimo> so if that's the problem, no problem :)

[12:00] <HoboWithShotgun> debugging. i am not sure what is in the array of xml::element objects, so i call .perl on it. but that produces thousands of lines of output cause these things are all interconnected by their parent properies

[12:01] *** brrt joined
[12:01] <HoboWithShotgun> and .perl happily follows each reference

[12:01] *** Cabanossi joined
[12:01] <timotimo> also

[12:01] <timotimo> perl6 -e 'my @foo; @foo[0][0][0][0][0] = "hi"; @foo[0][1] = "hi"; @foo[1] = "bye"; say @foo.tree(*.self, *.self, *.self, { [] }).perl;'

[12:01] <timotimo> er

[12:02] <timotimo> m: my @foo; @foo[0][0][0][0][0] = "hi"; @foo[0][1] = "hi"; @foo[1] = "bye"; say @foo.tree(*.self, *.self, *.self, { [] }).perl;

[12:02] <camelia> rakudo-moar 51e59e: OUTPUT: «((([],).Seq, "hi").Seq, "bye").Seq␤»

[12:02] <timotimo> m: my @foo; @foo[0][0][0][0][0] = "hi"; @foo[0][1] = "hi"; @foo[1] = "bye"; say @foo.perl;

[12:02] <camelia> rakudo-moar 51e59e: OUTPUT: «[[[[["hi"],],], "hi"], "bye"]␤»

[12:02] <timotimo> .tree can help you here

[12:07] *** nattefrost joined
[12:08] *** Rawriful left
[12:08] *** Rawriful joined
[12:08] *** Rawriful left
[12:13] *** avalenn left
[12:15] <jeromelanteri> is there any ncurses kind of perl6 module(s) for forme questions tags ?

[12:16] <jeromelanteri> i see module use ncurses for table print, menu choose (very nice one)... but if i want to ask wuestion with ncurse ?

[12:16] <jeromelanteri> questions

[12:18] <timotimo> honestly, i'd just use zenity or any of the similar programs

[12:18] <timotimo> or Text::Print, that's powerful and cool

[12:19] <timotimo> though tbh i've only looked at the examples, i haven't used it myself yet

[12:19] <timotimo> and without the raw input branch it might not yet have great input, come to think of it

[12:19] <timotimo> okay forget i said anything until in a week or so

[12:26] *** andrzejku left
[12:30] <HoboWithShotgun> m: (1,2,3).map(*.WHAT)

[12:30] <camelia> rakudo-moar e051dd: OUTPUT: «Cannot resolve caller map(List: Whatever); none of these signatures match:␤    ($: Hash \h, *%_)␤    (\SELF: &block;; :$label, :$item, *%_)␤    (HyperIterable:D $: &block;; :$label, *%_)␤  in block <unit> at <tmp> line 1␤␤»

[12:30] <HoboWithShotgun> why is that?

[12:31] *** kaare__ joined
[12:32] *** itaipu joined
[12:32] *** andrzejku joined
[12:40] *** someuser left
[12:43] <araraloren> m:say (1,2,3).map(*.&WHAT)

[12:43] <evalable6> araraloren, rakudo-moar e051dd2de: OUTPUT: «((Int) (Int) (Int))»

[12:44] *** brrt left
[12:44] *** brrt joined
[12:46] *** brrt left
[12:49] *** itaipu left
[12:53] *** andrzejku left
[12:54] *** clarkema joined
[12:57] <timotimo> .WHAT is a little macro-ish

[12:57] <timotimo> when you do *.WHAT you get Whatever instead of a whatever code curried to call .WHAT on something

[12:57] <timotimo> m: say *.WHAT

[12:57] <camelia> rakudo-moar e051dd: OUTPUT: «(Whatever)␤»

[12:57] <timotimo> m: say *.foo

[12:57] <camelia> rakudo-moar e051dd: OUTPUT: «{ ... }␤»

[12:57] <timotimo> that's the difference

[12:59] *** Cabanossi left
[13:00] <HoboWithShotgun> excuses. WHAT should give me the type object as advertised.

[13:00] <HoboWithShotgun> this language is far from production ready

[13:00] *** mr-foobar joined
[13:01] <HoboWithShotgun> i am trying to get a simple script working and i constantly hit walls like this

[13:01] <timotimo> i don't think *.WHAT will be "fixed"

[13:01] *** Cabanossi joined
[13:01] <timotimo> and .WHAT does give you the type object

[13:02] <timotimo> *.WHAT gives you the type object for Whatever

[13:02] <timotimo> m: say (* - 1).WHAT

[13:02] <camelia> rakudo-moar e051dd: OUTPUT: «(WhateverCode)␤»

[13:02] <timotimo> here the * - 1 gets curried as you expect, and .WHAT doesn't, so this time you get WhateverCode instead

[13:02] <HoboWithShotgun> but thats not what it should do. if *.foo executes foo on the current list element

[13:03] <timotimo> upper-case things are all special

[13:03] <HoboWithShotgun> then *.WHAT should execute WHAT on the fucking list element and not the *

[13:04] <HoboWithShotgun> fine, then how would i do what i want to do?

[13:07] *** _cronus left
[13:08] *** stmuk_ joined
[13:10] *** stmuk left
[13:10] *** Aaronepower left
[13:10] *** nadim left
[13:10] *** nadim joined
[13:11] <jeromelanteri> timotimo, text::print ? where ?

[13:11] <jeromelanteri> zenity ?

[13:13] *** mr-foobar left
[13:16] <timotimo> not text::print, sorry

[13:16] <jeromelanteri> ok

[13:16] <jeromelanteri> i really like ncurses lib use, it make nice terminal print

[13:18] <jeromelanteri> timotimo, instead, which command could add 1000 lines in the terminal ?

[13:18] *** Aaronepower joined
[13:18] <timotimo> "add 1000 lines"?

[13:19] <jeromelanteri> for (1..1000)-> { run: "echo"}; ??

[13:19] <jeromelanteri> timotimo, yes, for wash the prompt

[13:19] <timotimo> m: <foo bar baz 100>.map(*.^name).perl.say

[13:19] <camelia> rakudo-moar e051dd: OUTPUT: «("Str", "Str", "Str", "IntStr").Seq␤»

[13:19] <timotimo> HoboWithShotgun: how do you like this?

[13:19] <jeromelanteri> because if i use mix of ncurse and actual prompter, it is very dirty

[13:19] <timotimo> or do you need the actual type object to call methods on it?

[13:20] *** mr-foobar joined
[13:20] <timotimo> why would you "run echo" instead of "say"?

[13:20] <jeromelanteri> timotimo, i don't  know... because i'm stupid sometimes...

[13:23] *** Skarsnik joined
[13:25] *** nadim left
[13:30] *** zakharyas joined
[13:31] <Skarsnik> Hello

[13:31] <timotimo> don't worry jeromelanteri :)

[13:31] <araraloren> HoboWithShotgun, I show the code to you

[13:31] <araraloren> m:say (1,2,3).map(*.&WHAT)

[13:31] <evalable6> araraloren, rakudo-moar e051dd2de: OUTPUT: «((Int) (Int) (Int))»

[13:31] <jeromelanteri> timotimo, i'm not. We can all be stupid sometimes. this is not a big problem when we know that.

[13:32] <araraloren> Skarsnik, hi

[13:36] <HoboWithShotgun> araraloren: if i do that, i get no output

[13:37] <HoboWithShotgun> as i said. walls everywhere. i gonna do this in perl5 instead

[13:37] <araraloren> HoboWithShotgun, you have to print them use say or print

[13:37] <HoboWithShotgun> tx for listening

[13:37] *** HoboWithShotgun left
[13:38] <jeromelanteri> he looks like not happy...

[13:38] <jeromelanteri> :)

[13:38] <araraloren> haha

[13:38] <araraloren> yeah

[13:39] * araraloren hear nothing, I hear nothing

[13:39] <jeromelanteri> he choose an adapted pseudo also... very funny.

[13:45] *** zakharyas left
[13:49] *** zakharyas joined
[13:49] *** mr-foobar left
[14:14] *** Cabanossi left
[14:16] *** Cabanossi joined
[14:18] *** bjz_ left
[14:18] *** BenGoldberg joined
[14:22] *** bjz joined
[14:31] *** cdg joined
[14:41] *** bjz left
[14:41] *** holyghost_ joined
[14:45] <ugexe> someone putting (1,2,3).map(*.WHAT) in production code, since it was brought up, would not speak highly of that person

[14:45] *** holyghost_ left
[14:47] <ugexe> if you don't want to bother learning the less basic parts of the language just use block form of map: (1,2,3).map({ .WHAT })

[14:52] <BenGoldberg> m: say *.WHAT

[14:52] <camelia> rakudo-moar e051dd: OUTPUT: «(Whatever)␤»

[14:53] <BenGoldberg> m: say *+1

[14:53] <camelia> rakudo-moar e051dd: OUTPUT: «{ ... }␤»

[14:54] <BenGoldberg> m: say *.HOW

[14:54] <camelia> rakudo-moar e051dd: OUTPUT: «Perl6::Metamodel::ClassHOW.new␤»

[14:54] <BenGoldberg> m: say *.WHY

[14:54] <camelia> rakudo-moar e051dd: OUTPUT: «{ ... }␤»

[15:00] *** nadim joined
[15:02] *** smls joined
[15:04] <smls> m: grammar A { has $.a;  token TOP { {say $.a} } };  A.new(a => 42).parse("");

[15:04] <camelia> rakudo-moar e051dd: OUTPUT: «(Any)␤»

[15:05] <smls> ^^ Is using *instances* of grammar classes with class attributes meant to work?

[15:08] <smls> bisectable6:  grammar A { has $.a;  token TOP { {say $.a} } };  A.new(a => 42).parse("");

[15:08] <bisectable6> smls, On both starting points (old=2015.12 new=e051dd2) the exit code is 0 and the output is identical as well

[15:08] <bisectable6> smls, Output on both points: «(Any)»

[15:13] *** zakharyas left
[15:13] <ugexe> m: role Foo { has $.a; method a { $!a } }; grammar A does Foo { token TOP { {say $.a} } };  A.new(a => 42).parse(""); # seems broke, this should work at the very least

[15:13] <camelia> rakudo-moar e051dd: OUTPUT: «(Any)␤»

[15:13] *** nadim left
[15:14] *** Cabanossi left
[15:14] *** nadim joined
[15:15] *** khw joined
[15:16] *** Cabanossi joined
[15:25] *** Aaronepower left
[15:25] *** Rawriful joined
[15:26] *** hoelzro_ left
[15:26] *** huggable left
[15:26] *** hobbs left
[15:26] *** buggable left
[15:26] *** NeuralAnomaly left
[15:26] *** ZofBot left
[15:26] *** plicease_ left
[15:26] *** Geth_ left
[15:26] *** hobbs joined
[15:26] *** hobbs left
[15:26] *** hobbs joined
[15:27] *** leego joined
[15:27] *** Geth___ joined
[15:27] *** ChanServ sets mode: +v Geth___

[15:27] *** buggable joined
[15:27] *** ChanServ sets mode: +v buggable

[15:27] *** plicease joined
[15:36] *** cdg left
[15:36] <jnthn> smls: They work in so far as that being how a Cursor stores its own internal state. However, each rule gets a cursor of its own, meaning a fresh instance is made per token that is entered

[15:37] <jnthn> So the instance inside of token TOP is not the one that .parse was called on

[15:37] *** popov_ joined
[15:37] <smls> ok

[15:50] *** Aaronepower joined
[15:51] *** Aaronepower left
[15:53] *** BenGoldberg left
[15:56] *** BenGoldberg joined
[15:57] *** clarkema left
[15:57] *** BenGoldberg left
[16:03] *** mr-foobar joined
[16:03] *** clarkema joined
[16:06] *** Aaronepower joined
[16:07] *** BenGoldberg joined
[16:09] *** andrzejku joined
[16:12] *** Aaronepower left
[16:14] *** Cabanossi left
[16:16] *** Cabanossi joined
[16:21] *** Aaronepower joined
[16:25] *** pharv joined
[16:25] *** Aaronepower left
[16:30] *** bjz joined
[16:33] *** araraloren left
[16:37] *** Cabanossi left
[16:38] *** bjz left
[16:38] *** khw left
[16:41] *** Cabanossi joined
[16:46] *** nattefrost left
[16:52] *** leego is now known as leedo

[16:52] *** Cabanossi left
[16:52] *** bjz joined
[16:54] *** Cabanossi joined
[16:55] *** skids joined
[17:01] *** popov_ left
[17:02] <japhb> jnthn, timotimo: Not only is raw tty input seeming stable, as timotimo guessed, it doesn't need the fd reopen hack to force the input stream onto the processing thread anymore.  Thank you, jnthn++!

[17:03] <japhb> Of course, now this means I need to wade back into the battle with decoding escape codes for arrow and function keys ....

[17:09] *** bjz left
[17:12] *** zakharyas joined
[17:15] *** JJ_ joined
[17:15] <JJ_> Hi there

[17:17] <japhb> JJ_: Hello!  Did you have a question, or just saying hi?

[17:17] <JJ_> For the time being, just hi and lurking for a while...

[17:18] <japhb> It tends to be a little slower on the weekends, so don't be surprised if you don't hear much at times.

[17:18] <JJ_> :-)

[17:19] <JJ_> I'm getting kind of crazy, of all things, looping over an array

[17:19] <JJ_> Got this array in JSON

[17:19] <JJ_> https://github.com/JJ/perl6em/blob/master/utils/urls-with-short.json

[17:20] <JJ_> Gobble it up:  my $json = $urls-file.IO.slurp();     my $decoded = from-json $json;

[17:20] <JJ_> $decoded.elems returns 39. So far so good.

[17:20] <JJ_> but then  for $decoded -> $u assigns the whole array to $u in the first iteration.

[17:21] <JJ_> Any idea? This is probably pretty stupid, I know, but I can't figure it out.

[17:21] <JJ_> I've worked around it by using .keys, which for some reason works OK.

[17:22] <timotimo> you want to for @$decoded or for $decoded.list

[17:22] <timotimo> it's in a scalar container, the semantics of scalar containers are "a single thing"

[17:23] <timotimo> alternatively you could assign to @decoded instead of $decoded

[17:23] <JJ_> I tried that, didn't work. Let me check again.

[17:23] <JJ_> Yep, does not work. It @decoded.elems returns 1

[17:25] <timotimo> oh, heh

[17:25] <JJ_> OK, I think I got it

[17:25] <timotimo> sorry about that, you'd have to either bind with := or put @(...)

[17:25] <timotimo> because there's still the scalar container

[17:25] <timotimo> it treats it the same way as

[17:25] <JJ_>     my @urls = @(from-json $json);

[17:26] <timotimo> m: my @foo = $(1, 2, 3); say @foo.elems; say @foo[0].elems

[17:26] <camelia> rakudo-moar e051dd: OUTPUT: «1␤3␤»

[17:26] <timotimo> m: my @foo := $(1, 2, 3); say @foo.elems; say @foo[0].elems

[17:26] <camelia> rakudo-moar e051dd: OUTPUT: «3␤1␤»

[17:26] <JJ_> The problem seems to be from-json returns in scalar context. So you have to change it to Array context.

[17:26] <timotimo> aye

[17:26] *** bjz joined
[17:26] <JJ_> Thanks!

[17:26] <timotimo> though context isn't the right word

[17:26] <timotimo> in perl6 context works the other way around from perl5 and earlier

[17:27] <JJ_> Yep, it's perl5ish

[17:27] <JJ_> sorry.

[17:27] <timotimo> no problem

[17:27] <timotimo> m: use LWP::Simple; LWP::Simple.get: https://raw.githubusercontent.com/JJ/perl6em/master/utils/urls-with-short.json

[17:27] <camelia> rakudo-moar e051dd: OUTPUT: «===SORRY!===␤Could not find LWP::Simple at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-2/share/perl6/site␤    /home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-2/share/perl6␤    CompUnit:…»

[17:27] <timotimo> er

[17:27] <timotimo> star: use LWP::Simple; LWP::Simple.get: https://raw.githubusercontent.com/JJ/perl6em/master/utils/urls-with-short.json

[17:27] <camelia> star-m 2016.10: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3use LWP::Simple; LWP::Simple.get: https:7⏏5//raw.githubusercontent.com/JJ/perl6em/m␤    expecting any of:␤        colon pair␤»

[17:28] <timotimo> star: use LWP::Simple; LWP::Simple.get: "https://raw.githubusercontent.com/JJ/perl6em/master/utils/urls-with-short.json"

[17:28] <camelia> star-m 2016.10: OUTPUT: «501 Protocol scheme 'https' is only supported if IO::Socket::SSL is installed <URL:https://raw.githubusercontent.com/JJ/perl6em/master/utils/urls-with-short.json>␤␤  in method request_shell at /home/camelia/star-2016.10/share/perl6/site/sources/2A99795C7…»

[17:28] <timotimo> oh wow that's 2016.10?

[17:28] <timotimo> nine: can we get that up to date?

[17:28] *** andrzejku left
[17:29] *** smls left
[17:30] *** clarkema left
[17:37] *** andrzejku joined
[17:41] *** zakharyas left
[17:48] *** andrzejku left
[18:03] *** nhywyll joined
[18:18] *** jaldhar_ left
[18:19] *** jaldhar_ joined
[18:25] *** setty1 joined
[18:38] <moritz> I'm on it

[18:46] *** klapperl joined
[18:54] *** pharv left
[18:59] *** domidumont joined
[19:01] *** domidumont left
[19:02] *** ZofBot joined
[19:02] *** ChanServ sets mode: +v ZofBot

[19:03] *** huggable joined
[19:03] *** ChanServ sets mode: +v huggable

[19:04] *** NeuralAnomaly joined
[19:04] *** ChanServ sets mode: +v NeuralAnomaly

[19:05] *** darutoko left
[19:05] <JJ_> What do you people use for debugging?

[19:05] <JJ_> I'm stuck with the old say this dd that

[19:06] *** dwarring joined
[19:08] * moritz too

[19:08] <moritz> which I tend to do in all languages I program in

[19:09] <JJ_> but still

[19:09] <JJ_> breakpoints help. 

[19:10] <JJ_> the old "x" in the perl5 debugger was a nice way of having formatted variables printed.

[19:10] <JJ_> So there's no better alternative in perl6, right?

[19:10] <moritz> you can install Debugger::UI::CommandLine (if it works right now), and then use perl6-debug-m instead perl6-m to start your code

[19:11] <JJ_> That's a big if

[19:11] *** kaare__ is now known as kaare_

[19:11] <moritz> star: say 42 # for timotimo 

[19:11] <camelia> star-m 2017.07: OUTPUT: «42␤»

[19:12] <JJ_> @moritz it apparently works, thanks for the suggestion

[19:13] <moritz> \o/

[19:14] *** Cabanossi left
[19:16] *** Cabanossi joined
[19:21] *** hankache joined
[19:26] *** andrzejku joined
[19:27] *** bjz left
[19:33] <JJ_> Now regex stuff

[19:34] <JJ_>  $text = "[captura](https://una.captura) y [otra](https://capt.ura)"

[19:34] <JJ_>  $text ~~ /\] \( (http <-[ ) ]> +?) \) / returns https://una.captura

[19:35] <JJ_> Now

[19:35] <JJ_> $text ~~ m:global/\] \( (http <-[ ) ]> +?) \) /

[19:35] <JJ_> returns ](https://una.captura)

[19:35] <JJ_> So the global switch makes it forget the grouping parentheses?

[19:35] <timotimo> moritz: perfect! <3

[19:36] <JJ_> um

[19:36] <moritz> JJ_: I don't see any grouping parenthesis in your regex

[19:36] <JJ_> right before http and after ?

[19:37] <moritz> oh right

[19:37] <JJ_> they actually work... without the global switch

[19:37] <moritz> m: my $text = "[captura](https://una.captura) y [otra](https://capt.ura)"; for $text ~~ /\] \( (http <-[ ) ]> +?) \) / -> $/ { say $0 }

[19:37] <camelia> rakudo-moar e051dd: OUTPUT: «Nil␤»

[19:38] <JJ_> m: my $text = "[captura](https://una.captura) y [otra](https://capt.ura)"; for $text ~~ m:g/\] \( (http <-[ ) ]> +?) \) / -> $/ { say $0 }

[19:38] <camelia> rakudo-moar e051dd: OUTPUT: «｢https://una.captura｣␤｢https://capt.ura｣␤»

[19:38] <JJ_> um

[19:39] <moritz> that looks right, now?

[19:39] <moritz> s/now/no/

[19:39] <JJ_> looks totally right

[19:40] <moritz> it returns a list of matches, and in each match, the [0] element matched the URL

[19:40] <moritz> m: my $text = "[captura](https://una.captura) y [otra](https://capt.ura)"; say $text ~~ m:g/\] \( (http <-[ ) ]> +?) \) /

[19:40] <camelia> rakudo-moar e051dd: OUTPUT: «(｢](https://una.captura)｣␤ 0 => ｢https://una.captura｣ ｢](https://capt.ura)｣␤ 0 => ｢https://capt.ura｣)␤»

[19:40] <moritz> same thing, but since the list delimiter is not explicit, it's easier to lose track of what's going on

[19:41] <geekosaur> looks ot me like they stringified the match object, losing the information they actually wanted

[19:41] <moritz> btw I'm currently working on https://leanpub.com/perl6regex :-)

[19:41] <moritz> explaining "token" and "rule" right now

[19:42] <JJ_> Good luck!

[19:46] <moritz> thanks

[19:47] *** JJ_ left
[19:51] <zengargoyle> m:  my $text = "[captura](https://una.captura) y [otra](https://capt.ura)"; $text ~~ m:g/\] \( (http <-[ ) ]> +?) \) /; say ~$_.[0] for $/[];

[19:51] <camelia> rakudo-moar 4db230: OUTPUT: «https://una.captura␤https://capt.ura␤»

[19:51] <zengargoyle> man $/ is so bizzare to get my head around... :)

[19:52] <moritz> read my book!

[19:52] <moritz> I hope it explains it well

[19:52] <moritz> if not, tell me, and I'll do my best to improve the descirption

[19:52] <zengargoyle> hehe, i do need to re-start reading.

[19:54] *** pharv joined
[20:00] <zengargoyle> moritz: i sorta started waiting for chapter contents to settle down because going back and tracking additions gave me too much deja vu. :)

[20:03] * zengargoyle needs to up my game on viewing diff of prose.

[20:05] <moritz> zengargoyle: I understand, no problem

[20:07] *** TEttinger joined
[20:19] *** rindolf left
[20:24] *** Skarsnik left
[20:24] *** skids1 joined
[20:24] *** itaipu joined
[20:26] *** skids left
[20:33] *** andrzejku left
[20:33] *** dwarring left
[20:36] *** skids joined
[20:39] *** skids1 left
[20:50] *** deep-book-gk_ joined
[20:50] *** bjz joined
[20:53] *** deep-book-gk_ left
[20:55] *** itaylor57 left
[20:55] *** itaylor57 joined
[20:59] *** dct joined
[21:01] *** Cabanossi left
[21:01] *** cog_ left
[21:02] *** Cabanossi joined
[21:06] *** lizmat left
[21:09] *** lizmat joined
[21:15] *** dct left
[21:23] *** hankache left
[21:26] *** hythm_ joined
[21:29] *** rindolf joined
[21:32] *** wamba left
[21:32] <hythm_> hello perl6, I would like to start learning web development in perl6, is there a resource, documentation or book I can read?

[21:33] <timotimo> gabor szabo is writing a book about bailador (and since he started, development around bailador picked up a few more volunteers)

[21:38] <timotimo> japhb: did you know that with Terminal::Print $p.indices -> [$x, $y] is almost twice as slow as flat $p.indices -> $x, $y?

[21:41] <timotimo> though of course the API is fixed so can't just change what it returns

[21:41] <hythm_> just checked it, I would like to crowdfund to help, since the book will be released in December, are there other resources to learn from now (as I want to start soon), or may be the book offer a draft version if helped with crowndfunding it!

[21:42] <timotimo> you already know a fair bit about perl6 itself, right?

[21:42] <timotimo> i think i've seen you in here a bunch of times

[21:43] <hythm_> yes I know the basics, but I'm tatally new to web development

[21:43] <ryu0> Not even HTML/CSS experience?

[21:43] <hythm_> s/totaly/totally/

[21:44] <hythm_> yes I know HTML and CSS

[21:45] *** Cabanossi left
[21:46] *** Cabanossi joined
[21:47] <hythm_> but I don't have experience creating web app with API and nice UI, and that is my next goal,

[21:49] <timotimo> i somehow managed to segfault the tris example :|

[21:50] *** bjz left
[21:51] <zengargoyle> .ask jeromelanteri could you add an example my_pl6.yml file to your repo?

[21:51] <yoleaux> zengargoyle: I'll pass your message to jeromelanteri.

[21:55] <hythm_> Actually, I just got a draft version from the book with a few chapters to start with.  Awesome!

[21:56] <zengargoyle> .ask jeromelanteri or you could email me zengargoyle at gmail.com if my_pl6.yml is sensitive data....

[21:56] <yoleaux> zengargoyle: I'll pass your message to jeromelanteri.

[22:00] *** rindolf left
[22:01] *** andrzejku joined
[22:02] <nadim> japhb: did you get my message?

[22:03] *** andrzejku left
[22:06] *** Hotkeys joined
[22:06] <nadim> hi, I am wondering (there may be an example I misssed) if it is possible to pass arguments to a pointy block that does not declare parameters. something like @a = { ;}, {;} ; and then iterate through the array an call the blocks with arguments.

[22:08] <timotimo> blocks, as opposed to methods, don't slurp up all nameds by default

[22:08] <timotimo> m: my &foo = {;}; say &foo.signature

[22:08] <camelia> rakudo-moar 0c19f5: OUTPUT: «(;; $_? is raw)␤»

[22:08] <timotimo> blocks without signatures take a single optional argument

[22:09] <nadim> hmm, which one? hand how are they called?

[22:09] <timotimo> a single optional positional argument

[22:10] <timotimo> i.e. you can call the blocks with &block() or with &block(42)

[22:10] <nadim> I want to avoid writing sub ($a, $b){ ;} if I can write {;} only

[22:10] <timotimo> then you can use $^a, $^b inside the { }

[22:10] <nadim> adnd 42 gets in $_, right?

[22:10] <timotimo> yes

[22:11] <timotimo> if you want to avoid writing "sub", you can give a pointy block a signature

[22:11] <timotimo> -> $a, $b { }

[22:11] *** hythm_ left
[22:11] <nadim> and call it like: &foo(1, 2) ?

[22:11] <nadim> or five the parameters after?

[22:12] <nadim> -> $s, $b {}(1, 2)

[22:12] <nadim> s/five/give/

[22:12] <timotimo> m: -> $a, $b { say "hi $a, $b!" }(99, 42)

[22:12] <camelia> rakudo-moar 0c19f5: OUTPUT: «hi 99, 42!␤»

[22:12] <timotimo> you can, yes

[22:13] <nadim> can a reference be used later to do that or does it have to be inline as the example above?

[22:13] <timotimo> of course you can put a pointy block into a variable

[22:13] <ilmari> m: my $s = -> $a, $b { say $^a + $^b }; $s->(1,2)

[22:13] <camelia> rakudo-moar 0c19f5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Redeclaration of symbol '$^a' as a placeholder parameter␤at <tmp>:1␤------> 3my $s = -> $a, $b { say $^a7⏏5 + $^b }; $s->(1,2)␤»

[22:13] <ilmari> m: my $s = -> $a, $b { say $a + $b }; $s->(1,2)

[22:13] <camelia> rakudo-moar 0c19f5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of ->(), ->{} or ->[] as postfix dereferencer; in Perl 6 please use .(), .[] or .{} to deref, or whitespace to delimit a pointy block␤at <tmp>:1␤------> 3my $s = -> $a, $b { say $a + $…»

[22:13] <timotimo> or pass a pointy block as a parameter to something else without a variable in the middle

[22:14] <ilmari> m: my $s = -> $a, $b { say $a + $b }; $s(1,2)

[22:14] <camelia> rakudo-moar 0c19f5: OUTPUT: «3␤»

[22:14] <ilmari> m: my $s = { $^a + $^b }; $s(1,2)  # look ma, no pointy!

[22:14] <camelia> rakudo-moar 0c19f5: ( no output )

[22:14] <ilmari> m: my $s = { say $^a + $^b }; $s(1,2)  # look ma, no pointy!

[22:14] <camelia> rakudo-moar 0c19f5: OUTPUT: «3␤»

[22:14] *** |oLa| joined
[22:16] <nadim> I guess that's the closes one can come

[22:16] <nadim> In P5 I made variables "appear in context", practical to make thing look magic.

[22:16] *** El_Che_ left
[22:17] <timotimo> well, you can use dynamic variables

[22:17] <geekosaur> suppose you could do somethng "clever" with $*vars

[22:17] <geekosaur> that

[22:17] <nadim> I have an interfacethat is going to take a lot of subs, I need to make it as typing-less as possible

[22:18] <nadim> geekosaur: do tell, even if it is just to learn something and not use it

[22:18] <timotimo> like you can declare $*foo, $*bar, $*baz, $*quux where you call these blocks and every block can decide which of those they want to use by just refering to them like that

[22:18] <geekosaur> I basically said what timotimo did

[22:19] <nadim> ok, what's the mechanism behind them? 

[22:19] *** espadrine left
[22:19] <timotimo> m: my @blocks = { say "nothing" }, { say "foo is $*foo" }, { say "foo and quux: $*foo, $*quux" }; for @blocks -> &block { my $*foo = "this is foo"; my $*bar = "and bar"; my $*quux = "quux here"; &block() }

[22:19] <camelia> rakudo-moar 0c19f5: OUTPUT: «nothing␤foo is this is foo␤foo and quux: this is foo, quux here␤»

[22:19] <nadim> their reason to exist, except for being cool

[22:19] *** |oLa| left
[22:19] <geekosaur> because sometimes you need a variable that depends on the dynamic call stack instead of lexical

[22:19] <timotimo> dynamic variables have "dynamic scope", which means whatever is called by the function that defines it (or a function that is called by that, and so on) has access to it

[22:19] <geekosaur> in perl 5 you do this with local()

[22:20] <geekosaur> lisp variables are generally dynamic

[22:20] <timotimo> and you can "override" or "shadow" dynamic variables from further up the stack by defining them in your function

[22:20] <geekosaur> and in Haskell this is MonadReader's local

[22:21] <nadim> so I now have 4 ways to do what I want!, land of plenty.

[22:21] <nadim> is it possible to type a block?

[22:22] <timotimo> yes

[22:22] <timotimo> you can have a restriction on the return type or the signature

[22:22] <geekosaur> that's what timotimo was saying about -> with a signature

[22:22] <nadim> and what can be done with a typed block? parameters wise

[22:22] <nadim> I mean typing like assigning a class to it

[22:22] <timotimo> https://docs.perl6.org/syntax/Constraining%20signatures%20of%20Callables#class_Signature on this very unwieldily-named page there's examples for what to put into your sub signatures

[22:23] <timotimo> if i understand right what you mean by "typed"

[22:23] <nadim> thank yo both for the tips and the link

[22:24] * nadim saves this QA session

[22:24] <timotimo> can you elaborate a bit more what you want to achieve?

[22:24] <nadim> sure

[22:24] <timotimo> with the typing, i mean

[22:24] <timotimo> i can sort of guess what you want in general

[22:25] <nadim> I have lines that look like this :flat(Hash, sub ($s, $depth){$s ~~ Array, 5}, sub ($s, $depth){$s ~~ Int}, ....)

[22:26] <nadim> the subs are user defined, and a pain to type

[22:27] <nadim> I can provide some sugar for common cases but when the user wants to add something special then he needs to type all the boilerplate, I'd like to avoid that, as I am the user too

[22:27] *** nhywyll left
[22:27] <nadim>  :flat(Hash, {$_ ~~ Array, 5}, {$_ ~~ Int}, ....) looks a bit better

[22:28] <timotimo> i'm not sure how these blocks work exactly

[22:28] <timotimo> it checks the thing against a type and returns a True or False and also optionally a number?

[22:28] <nadim> yes

[22:29] <nadim> I's like to pass more than one variable but for the sake of the dicussion let's say I pass only one

[22:29] <timotimo> another thing you could do is have like (Array) => 5 meaning "if it smart matches against Array, expand it if it's below 5 levels down" or whatever

[22:29] <nadim> I pass a type and the sub tells me if it should be flattened or not

[22:30] <timotimo> OK, and the number?

[22:30] <nadim> let me paste an example

[22:31] *** pharv left
[22:31] <nadim> https://nopaste.linux-dev.org/?1160205

[22:32] <nadim> :flat flattens, if you have an Array then all it's elements are put on the same line or multiple lines depending on the teminal depth

[22:32] <timotimo> what's the 10 doing there off to the side?

[22:32] <nadim> the number says, puts 5 entries in a colums, followed by another colum of 5 entries, ...

[22:32] <timotimo> oh

[22:32] <timotimo> that's the 11th thing in the one to its left

[22:33] *** gregf_ left
[22:34] <nadim> the 11th entry contains an array of 10 entries which is itself flattened and columnized

[22:34] <timotimo> right

[22:36] <nadim> data is $ds = $([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], {:a(IntStr.new(1, "1")), :b(IntStr.new(2, "2"))})

[22:37] <nadim> which is pretty easy to read in dd because it is short and all number are consecutive, with mixed number it becomes impossible 

[22:37] *** rindolf joined
[22:39] <timotimo> yeah

[22:40] <nadim> http://imgur.com/Hfhiouw

[22:40] <timotimo> still don't understand what the flag parameters do exactly

[22:41] <nadim> Data::Dump::Tree renders all the data vertically

[22:42] <nadim> :flat tell ddt to take a specific entry or type, or depth, and render it horizontally

[22:43] <timotimo> and how exactly does that work?

[22:43] <nadim> the arguments to :flat tells it what to do. and if, on top of telling it if an entry should be flattened or not, it can also say that it wants columns

[22:44] <timotimo> that's the number you return?

[22:46] <nadim> the details? :flat installs a sub_elements post filter, then an element is going to be displayed the filter is called and rather that return a list of sub elements it returns a Horizontal object that is the representatio of the sub elements, that is obtained by running a sub renderer. the sub rendere returns the rendering lines, the Horizontal object re-arranges the lines horizontally and in columns too.

[22:46] <nadim> the number that is returned is the amount of lines in a colum.

[22:47] <timotimo> OK

[22:48] <nadim> so it would be, for example, be possible to say "a specific element needs to be rendered in columns" something like :flat({$_ === $my_big_array, 10})

[22:49] <timotimo> ah, sure

[22:49] <nadim> actually one can already say :flat(($my_big_array, 5)). but I want a generic mechanism via subs

[22:49] <timotimo> right

[22:50] <nadim> the nice things with subs is that it can decide dynamically to leave it in vertical rendering, horizontal or columnar based on the element itself

[22:50] <timotimo> of course

[22:52] *** rindolf left
[22:53] <nadim> what I like is that it is not even 100 lines of code, and I have a very fluffy style

[22:54] <timotimo> japhb: you know how i told you flat and -> $x, $y makes things 2x faster? no, actually, it makes things completely wrong :)

[22:59] <timotimo> japhb: however, if i take @alphabet.roll(*), put it into my @alphseq, and use @alphseq.shift in place of @alphabet.roll, it gets about 1.8x faster

[22:59] <timotimo> m: say 2.9 / 5.7

[22:59] <camelia> rakudo-moar 0c19f5: OUTPUT: «0.508772␤»

[23:00] <timotimo> m: say 2.9 R/ 5.7

[23:00] <camelia> rakudo-moar 0c19f5: OUTPUT: «1.965517␤»

[23:00] <timotimo> wow, much closer to 2x than i thought 

[23:02] *** BenGoldberg left
[23:04] <nadim> is there a shortcut to set a Bool variable to True or False, ie not writting $var = True

[23:05] <timotimo> if the bool variable has an "is default", you can assign Nil

[23:05] <timotimo> that's 1 shorter than True or False

[23:06] <timotimo> m: my $boo = False; $foo or= 1; say $foo.perl

[23:06] <camelia> rakudo-moar 0c19f5: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$foo' is not declared. Did you mean '$boo'?␤at <tmp>:1␤------> 3my $boo = False; 7⏏5$foo or= 1; say $foo.perl␤»

[23:06] <timotimo> m: my $boo = False; $boo or= 1; say $boo.perl

[23:06] <camelia> rakudo-moar 0c19f5: OUTPUT: «1␤»

[23:06] <timotimo> nah, that doesn't turn it into a bool for you

[23:09] <skids> m: my Bool $a; $a++; $a.say; $a++; $a.say; $a--; $a.say; $a--; $a.say;

[23:09] <camelia> rakudo-moar 0c19f5: OUTPUT: «True␤True␤False␤False␤»

[23:09] <timotimo> japhb: but changing (1..5).roll and (1..6).roll to a shift on an infinite roll doesn't make it any faster

[23:09] <timotimo> ooh, good thinking, skids 

[23:09] *** CIAvash[m] left
[23:09] *** mack[m] left
[23:09] *** tadzik left
[23:09] *** mienaikage left
[23:09] *** Matthew[m] left
[23:09] *** tyil[m] left
[23:10] *** ugjka left
[23:10] *** unclechu left
[23:10] *** M-Illandan left
[23:10] *** xui_nya[m] left
[23:10] *** wictory[m] left
[23:12] *** ugjka joined
[23:13] <nadim> indeed shorte and it works well with the $a++ use to make things true

[23:14] *** ilmari[m] left
[23:15] *** Cabanossi left
[23:16] *** Cabanossi joined
[23:19] <timotimo> you could have prefix:<⊥> (or suffix) and the one in the other direction

[23:19] <timotimo> to truthify and falsify variables

[23:19] <timotimo> u: ⊥

[23:19] <unicodable6> timotimo, U+22A5 UP TACK [Sm] (⊥)

[23:19] <timotimo> u: DOWN TACK

[23:19] <unicodable6> timotimo, U+02D5 MODIFIER LETTER DOWN TACK [Sk] (˕)

[23:19] <unicodable6> timotimo, U+031E COMBINING DOWN TACK BELOW [Mn] ( ̞)

[23:19] <unicodable6> timotimo, 12 characters in total: https://gist.github.com/66d3f6d27f28205ccde0de6fcca19259

[23:19] *** samb1 left
[23:19] <timotimo> ⊤ is the other one

[23:20] *** itaipu left
[23:31] *** samb1 joined
[23:34] *** setty1 left
[23:37] *** mienaikage joined
[23:40] *** tzekid left
[23:41] *** cog_ joined
[23:45] <Geth> ¦ doc: aa912b4b19 | (Will "Coke" Coleda)++ | 2 files

[23:45] <Geth> ¦ doc: fixup PseudoStash docs

[23:45] <Geth> ¦ doc: 

[23:45] <Geth> ¦ doc: (whitespace, spelling, grammar)

[23:45] <Geth> ¦ doc: review: https://github.com/perl6/doc/commit/aa912b4b19

[23:45] *** ilmari[m] joined
[23:45] *** tyil[m] joined
[23:45] *** unclechu joined
[23:45] *** Matthew[m] joined
[23:45] *** M-Illandan joined
[23:45] *** mack[m] joined
[23:45] *** tadzik joined
[23:45] *** wictory[m] joined
[23:45] *** Cabanossi left
[23:45] *** xui_nya[m] joined
[23:45] *** CIAvash[m] joined
[23:46] *** Cabanossi joined
[23:57] *** El_Che joined
[23:58] *** Rawriful left
