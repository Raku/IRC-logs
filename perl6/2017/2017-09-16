[00:00] *** mcmillhj joined
[00:03] *** orac1e_ left
[00:05] *** mcmillhj left
[00:16] *** mcmillhj joined
[00:22] *** mcmillhj left
[00:38] *** headcase joined
[00:42] *** headcase left
[00:43] *** titsuki joined
[00:45] *** entonian joined
[00:47] *** skids left
[00:49] *** grondilu joined
[00:50] <grondilu> m: say Set().total

[00:50] <camelia> rakudo-moar ce95e1: OUTPUT: «No such method 'total' for invocant of type 'Set(Any)'␤  in block <unit> at <tmp> line 1␤␤»

[00:50] * grondilu was expecting 0

[00:51] *** skids joined
[00:53] *** aborazmeh joined
[00:53] *** aborazmeh left
[00:53] *** aborazmeh joined
[00:55] *** ufobat left
[00:59] *** entonian left
[01:06] *** wamba left
[01:15] *** headcase joined
[01:17] *** wander4096 joined
[01:18] <wander4096> need some help >_<

[01:18] <wander4096> what's the difference between method and subroutine in perl 6 docs

[01:20] *** headcase left
[01:20] <geekosaur> methods are called on objects; subs are just called

[01:21] <geekosaur> m: class A { method a { say 'in A::a' } }; sub b { say 'in b' }; my A $x .= new; $x.a; b();

[01:21] <camelia> rakudo-moar ce95e1: OUTPUT: «in A::a␤in b␤»

[01:22] <wander4096> I think so, but see it docs `routine isa` which can be only(?) used as sth.isa(...)

[01:23] *** dj_goku joined
[01:23] *** dj_goku left
[01:23] *** dj_goku joined
[01:24] *** headcase joined
[01:25] <geekosaur> but the proto says 'multi method isa'

[01:26] *** dj_goku_ left
[01:27] <geekosaur> "routine" is a superclass for both subs and methods (and, quietly, it's possible to call a method as a sub by marking the invocant explicitly)

[01:27] <geekosaur> m: my Int $a = 5; say isa($a: 'Int')

[01:27] <camelia> rakudo-moar ce95e1: OUTPUT: «True␤»

[01:28] <geekosaur> the colon there is an invocant marker

[01:28] *** headcase left
[01:29] *** llfourn joined
[01:29] *** headcase joined
[01:32] *** headcase_ joined
[01:33] *** headcase left
[01:34] *** BenGoldberg joined
[01:36] *** headcase_ left
[01:40] <wander4096> ok, so `Str(42:)` can't work but `isa(42: Int)` works, `method Str` and `routine isa`

[01:45] *** ilbot3 left
[01:51] *** davidfetter left
[01:54] *** markmont joined
[01:54] *** ilbot3 joined
[01:54] *** ChanServ sets mode: +v ilbot3

[01:54] *** wander4096 left
[01:57] *** cuonglm joined
[02:00] *** wander4096 joined
[02:01] *** piojo joined
[02:01] *** markmont left
[02:05] *** markmont joined
[02:06] <BenGoldberg> m: sub foo { dd callframe(1).code.name }; (sub { foo() }).();

[02:06] <camelia> rakudo-moar ce95e1: OUTPUT: «""␤»

[02:07] *** noganex_ joined
[02:10] *** noganex left
[02:17] <wander4096> m: say "test"

[02:17] <camelia> rakudo-moar ce95e1: OUTPUT: «test␤»

[02:18] *** headcase joined
[02:20] *** AlexDaniel left
[02:20] *** ipatrol joined
[02:21] <ipatrol> if I interpolate one regex into another with <$regex>, how are the groups in the substituted regex addressed?

[02:22] *** headcase left
[02:22] *** wander4096_ joined
[02:23] <ipatrol> m: my $reg = /(.)(.)(.)/; my $mat = "abcdefg" ~~ /<$reg>(.)/; say $mat.gist;

[02:23] <camelia> rakudo-moar ce95e1: OUTPUT: «｢abcd｣␤ 0 => ｢d｣␤»

[02:23] <ipatrol> m: my $reg = /(.)(.)(.)/; my $mat = "abcdefg" ~~ /<$reg>(.)/; say $0;

[02:23] <camelia> rakudo-moar ce95e1: OUTPUT: «｢d｣␤»

[02:24] *** wander4096 left
[02:24] <ipatrol> m: my $reg = /(.)(.)(.)/; my $mat = "abcdefg" ~~ /(<$reg>)(.)/; say $/;

[02:25] <camelia> rakudo-moar ce95e1: OUTPUT: «｢abcd｣␤ 0 => ｢abc｣␤ 1 => ｢d｣␤»

[02:25] <ipatrol> m: my $reg = /(.)(.)(.)/; my $mat = "abcdefg" ~~ /(<$reg>)(.)/; say $/[0];

[02:25] <camelia> rakudo-moar ce95e1: OUTPUT: «｢abc｣␤»

[02:25] <ipatrol> m: my $reg = /(.)(.)(.)/; my $mat = "abcdefg" ~~ /(<reg>)(.)/; say $/[0];

[02:25] <camelia> rakudo-moar ce95e1: OUTPUT: «No such method 'reg' for invocant of type 'Match'␤  in block <unit> at <tmp> line 1␤␤»

[02:25] <ipatrol> doesn't preserve it

[02:26] *** AlexDaniel joined
[02:27] <ipatrol> m: my regex reg {(.)(.)(.)}; my $mat = "abcdefg" ~~ /(<reg>)(.)/; say $/.gist;

[02:27] <camelia> rakudo-moar ce95e1: OUTPUT: «｢abcd｣␤ 0 => ｢abc｣␤  reg => ｢abc｣␤   0 => ｢a｣␤   1 => ｢b｣␤   2 => ｢c｣␤ 1 => ｢d｣␤»

[02:29] *** llfourn left
[02:31] *** headcase joined
[02:34] *** cdg joined
[02:39] *** cdg left
[02:42] *** greppable6 left
[02:42] *** greppable6 joined
[02:42] *** ChanServ sets mode: +v greppable6

[02:49] *** Todd joined
[02:52] <Todd> Hi All.  "Once Upon A time", I found a reference in the documentation as to what the variables were is you wanted to force the issue: Int64, StrD, etc..  I thought I had written it down, but can't find it if I did.  I found https://docs.perl6.org/language/variables but it does not go into the the types of forced variables

[02:53] <ipatrol> m: my $reg = /(.)(.)(.)/; my $mat = "abcdefg" ~~ /$reg(.)/; say $mat.gist;

[02:53] <camelia> rakudo-moar ce95e1: OUTPUT: «｢abcd｣␤ 0 => ｢d｣␤»

[02:54] <b2gills> m: my $reg = /(.)(.)(.)/; my $mat = "abcdefg" ~~ /$<reg> = $reg(.)/; say $mat.gist;

[02:54] <camelia> rakudo-moar ce95e1: OUTPUT: «｢abcd｣␤ reg => ｢abc｣␤  0 => ｢a｣␤  1 => ｢b｣␤  2 => ｢c｣␤ 0 => ｢d｣␤»

[02:59] <ipatrol> b2gills: thanks, though I actually found another way of doing what I wanted

[03:07] <Todd> In `method getc(IO::Handle:D: --> Str:D)`  what does the "D" stand for in "Handle"?  Never undefined?

[03:20] <Todd> got to go

[03:20] *** Todd left
[03:22] *** Cabanossi left
[03:24] *** Cabanossi joined
[03:35] *** mst is now known as ninjastealthcat

[03:35] *** ninjastealthcat is now known as mst

[03:37] *** Cabanossi left
[03:38] *** Cabanossi joined
[03:51] <ipatrol> m: say 'cat'.end;

[03:51] <camelia> rakudo-moar ce95e1: OUTPUT: «0␤»

[03:52] <ipatrol> m: say 'cat'.first;

[03:52] <camelia> rakudo-moar ce95e1: OUTPUT: «cat␤»

[03:53] <ipatrol> m: 'cat'split('').last;

[03:53] <camelia> rakudo-moar ce95e1: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3'cat'7⏏5split('').last;␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        state…»

[03:53] *** Ven`` joined
[03:54] <ipatrol> m: 'cat'split('').tail;

[03:54] <camelia> rakudo-moar ce95e1: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3'cat'7⏏5split('').tail;␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        state…»

[03:54] *** vendethiel- left
[03:54] <ipatrol> m: 'cat'.split('').tail;

[03:54] <camelia> rakudo-moar ce95e1: ( no output )

[03:54] <ipatrol> m: 'cat'.split('').last;

[03:54] <camelia> rakudo-moar ce95e1: OUTPUT: «No such method 'last' for invocant of type 'Seq'. Did you mean any of these?␤    Hash␤    List␤    Rat␤    flat␤␤  in block <unit> at <tmp> line 1␤␤»

[03:55] <ipatrol> m: 'cat'.split('').List.tail;

[03:55] <camelia> rakudo-moar ce95e1: ( no output )

[03:55] <ipatrol> m: 'cat'.split('')[*-1];

[03:55] <camelia> rakudo-moar ce95e1: ( no output )

[03:56] <ipatrol> m: 'cat'.split('').eager[*-1];

[03:56] <camelia> rakudo-moar ce95e1: ( no output )

[03:56] <ipatrol> m: say 'cat'.split('').eager[*-1];

[03:56] <camelia> rakudo-moar ce95e1: OUTPUT: «␤»

[03:57] <ipatrol> m: say 'cat'.split('', :no-empty).eager[*-1];

[03:57] <camelia> rakudo-moar ce95e1: OUTPUT: «␤»

[03:57] <ipatrol> m: say 'cat'.split('', :skip-empty).eager[*-1];

[03:57] <camelia> rakudo-moar ce95e1: OUTPUT: «t␤»

[03:57] <ipatrol> m: say 'cat'.split('', :skip-empty).tail;

[03:57] <camelia> rakudo-moar ce95e1: OUTPUT: «t␤»

[03:57] *** wander4096_ left
[03:57] <ipatrol> m: say 'cat'.tail;

[03:57] <camelia> rakudo-moar ce95e1: OUTPUT: «cat␤»

[04:04] *** AlexDaniel left
[04:04] *** headcase_ joined
[04:06] *** headcase left
[04:11] *** virtualsue left
[04:16] *** imcsk8 left
[04:16] *** imcsk8 joined
[04:16] *** virtualsue joined
[04:19] *** dogbert17 joined
[04:19] *** khw left
[04:20] *** lizmat_ joined
[04:21] *** AlexDaniel joined
[04:21] *** moritz left
[04:22] *** lizmat left
[04:22] *** dogbert17_ left
[04:22] *** protium left
[04:23] *** moritz joined
[04:24] *** Exodist left
[04:25] *** Exodist joined
[04:25] *** eater left
[04:26] *** shadowpaste left
[04:28] *** eater joined
[04:28] *** protium joined
[04:31] *** shadowpaste joined
[04:37] *** ipatrol left
[04:42] *** cuonglm left
[04:45] *** xtreak joined
[04:48] *** ShalokShalom joined
[04:48] *** ShalokShalom left
[04:55] *** cdg joined
[04:59] *** AlexDaniel left
[05:00] *** cdg left
[05:08] *** wander4096 joined
[05:10] *** skids left
[05:19] *** ShalokShalom joined
[05:21] *** xtreak left
[05:21] *** xtreak_ joined
[05:33] <wander4096> what is the word "invocant" means? i'm from china and difficult to understand it

[05:34] <wander4096> the word is here and there, every time puzzle me

[05:36] <TEttinger> "One who calls upon or invokes." I don't know the specific meaning in perl 6, but it would normally be something that is calling something else (probably a method)

[05:37] <piojo> ‎wander4096‎: do you know C and C++ (or C++ and function objects or boost)?

[05:38] <piojo> perl methods are like class functions in these environments: the invisible first function argument (usually ignored) is the caller--usually the class object

[05:38] <piojo> this is the invocant

[05:39] <piojo> But I don't think the invocant is always an object of that class, but almost always

[05:39] <piojo> and within the method, you can use "self" to refer to the invocant.

[05:40] <wander4096> emmmm...

[05:40] <piojo> (call its other methods, mostly)

[05:40] <wander4096> sounds more like in Python

[05:40] <piojo> I don't know that much Python, but I think it's like this in most object oriented languages

[05:41] *** virtualsue left
[05:41] *** BenGoldberg left
[05:43] <wander4096> thx, maybe i got it :)

[05:45] *** virtualsue joined
[05:46] <piojo> wander4096: you're welcome. BTW, the invocant can be a class instance or the class itself, corresponding to Foo.new.Func versus Foo.Func

[05:46] *** espadrine joined
[05:48] *** cdg joined
[05:48] <piojo> and it's not called "caller" because "caller" means the caller *scope* in perl

[05:50] <wander4096> so it is. the latter i know it for the first time.

[05:50] *** nige left
[05:52] *** cdg left
[05:53] *** headcase_ left
[05:56] *** headcase joined
[05:57] *** nadim joined
[05:58] *** headcase_ joined
[05:58] <masak> wander4096: when you do `$something.method()`, the object that's in $something gets bound as the invocant of the method call (and can be accessed as `self` inside that call)

[05:59] <masak> wander4096: you're right in that Perl culture is quite unique in using that word :)

[06:00] *** aborazmeh left
[06:02] *** headcase left
[06:04] <wander4096> this question occurs when distinguish `method does` from `method isa`

[06:04] <wander4096> and i wonder if a role does `Mu`

[06:04] <wander4096> m: Callable.does(Mu)

[06:04] <camelia> rakudo-moar ce95e1: ( no output )

[06:04] <wander4096> m: say Callable.does(Mu)

[06:04] <camelia> rakudo-moar ce95e1: OUTPUT: «True␤»

[06:05] <wander4096> but in the type graph, i can't find something like the root of roles

[06:05] <wander4096> so how can Callable does Mu?

[06:06] <wander4096> even

[06:06] <wander4096> m: say Callable.isa(Mu)

[06:06] <camelia> rakudo-moar ce95e1: OUTPUT: «True␤»

[06:06] *** headcase_ left
[06:08] *** wamba joined
[06:15] *** headcase joined
[06:18] *** lizmat_ is now known as lizmat

[06:18] *** zacts joined
[06:20] *** headcase left
[06:20] *** Cabanossi left
[06:21] *** headcase joined
[06:23] *** telex left
[06:23] *** Cabanossi joined
[06:30] *** setty1 joined
[06:30] *** headcase left
[06:31] *** headcase joined
[06:31] <piojo> The docs for .does() and .isa() don't mention each other

[06:31] <piojo> but in each case, the docs say it's equivalent to `~~`

[06:31] <piojo> funny.

[06:34] * piojo files a doc bug/suggestion

[06:35] *** telex joined
[06:38] *** headcase left
[06:48] *** headcase joined
[06:52] <wander4096> em, how to "files a doc bug/suggestion"?

[06:56] <piojo> wander4096: start the message with "/me "

[06:57] *** headcase left
[06:58] *** headcase joined
[07:03] *** headcase left
[07:03] <wander4096> is there a manual about chatroom robot?

[07:12] <piojo> I just found this: https://github.com/perl6/whateverable/wiki

[07:12] *** headcase joined
[07:12] <piojo> and this mentions a few more that aren't listed there (aren't part of the "whateverable" project): https://github.com/perl6/doc/issues/711

[07:16] *** headcase left
[07:18] *** darutoko joined
[07:20] *** headcase joined
[07:23] *** cuonglm joined
[07:25] *** domidumont joined
[07:25] *** headcase left
[07:28] *** headcase joined
[07:29] *** domidumont left
[07:29] *** xtreak_ left
[07:30] *** domidumont joined
[07:32] *** cdg joined
[07:34] *** xtreak joined
[07:35] *** Cabanossi left
[07:36] *** cdg left
[07:37] *** headcase left
[07:38] *** Cabanossi joined
[07:38] *** headcase joined
[07:41] *** konsolebox left
[07:42] *** headcase left
[07:46] *** ChoHag joined
[07:48] *** xtreak left
[07:48] *** xtreak joined
[07:52] *** konsolebox joined
[07:53] *** xtreak left
[08:02] *** ChoHag left
[08:03] *** penguin_ joined
[08:05] *** penguin_ left
[08:05] *** cdg joined
[08:06] *** cdg left
[08:07] *** cdg joined
[08:10] *** headcase joined
[08:11] *** cdg left
[08:13] *** domidumont left
[08:14] *** headcase left
[08:17] *** simonm left
[08:18] *** Terry__ joined
[08:27] *** headcase joined
[08:30] *** xtreak joined
[08:32] *** cuonglm left
[08:32] *** headcase left
[08:36] *** Cabanossi left
[08:38] *** Cabanossi joined
[08:52] *** darutoko left
[08:54] *** headcase joined
[08:58] *** headcase left
[08:58] *** headcase joined
[09:01] *** darutoko joined
[09:03] *** headcase left
[09:08] *** headcase joined
[09:09] *** wander4096 left
[09:12] *** headcase left
[09:15] *** cdg joined
[09:17] *** leont joined
[09:18] *** headcase joined
[09:20] *** cdg left
[09:21] *** Cabanossi left
[09:23] *** Cabanossi joined
[09:23] *** Terry__ left
[09:27] *** headcase left
[09:28] *** headcase joined
[09:41] *** headcase left
[09:42] *** piojo left
[09:43] *** wander4096 joined
[09:43] *** piojo joined
[09:46] *** ufobat joined
[09:47] *** headcase joined
[09:51] *** headcase left
[09:53] *** llfourn joined
[09:59] *** headcase joined
[10:02] *** ufobat_ joined
[10:03] *** ufobat___ joined
[10:03] *** zakharyas joined
[10:03] *** headcase left
[10:05] *** sena_kun joined
[10:05] *** ufobat left
[10:06] <sena_kun> [Coke], ping.

[10:06] *** orac1e_ joined
[10:06] *** ufobat_ left
[10:08] *** headcase joined
[10:18] *** headcase left
[10:20] *** headcase joined
[10:21] *** Cabanossi left
[10:22] *** headcase left
[10:23] *** Cabanossi joined
[10:29] *** TEttinger left
[10:33] *** leont left
[10:34] *** headcase joined
[10:34] *** zakharyas1 joined
[10:42] *** headcase left
[10:53] *** leont joined
[10:54] *** headcase joined
[10:56] *** Skarsnik joined
[10:58] *** leont left
[10:59] *** xtreak left
[10:59] *** zakharyas1 left
[11:02] *** xtreak joined
[11:02] *** margeas joined
[11:03] *** headcase left
[11:04] *** headcase joined
[11:09] *** orac1e_ left
[11:13] *** headcase left
[11:14] *** headcase joined
[11:18] *** HoboWithAShotgun joined
[11:20] <HoboWithAShotgun> m: $_ = chr(12); .say; s/{chr(12)}/x/; .say;

[11:20] <camelia> rakudo-moar c3a71a: OUTPUT: «␤x␤»

[11:20] <yoleaux> 15 Sep 2017 17:55Z <Zoffix> HoboWithAShotgun: managed to make it work without parens (and slurpy slurps the things): multi postfix:<°> { $^a }; multi prefix:<△> (*@things) is looser(&[,]) { class Triangle { has $.things; method beta { $!things.perl.uc } }.new: :@things }; .beta.say with △ α => 75°, c => 3, b => 3

[11:21] <HoboWithAShotgun> m: $_ = chr(65); .say; s/{chr(65)}/x/; .say;

[11:21] <camelia> rakudo-moar c3a71a: OUTPUT: «A␤xA␤»

[11:21] *** nadim left
[11:21] <HoboWithAShotgun> i thought i can have code blocks anywhere

[11:23] *** headcase left
[11:24] *** headcase joined
[11:30] <HoboWithAShotgun> m: $_ = chr(65); .say; s/ {return chr(65)} /x/; .say;

[11:30] <camelia> rakudo-moar c3a71a: OUTPUT: «A␤Attempt to return outside of any Routine␤  in regex  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[11:31] *** cdg joined
[11:33] *** headcase left
[11:34] *** virtualsue left
[11:36] *** virtualsue joined
[11:37] *** headcase joined
[11:39] *** cdg left
[11:44] *** xtreak left
[11:45] <HoboWithAShotgun> m: my @a = 3, (if 0 { 2 }), 1; say @a.elems

[11:45] <camelia> rakudo-moar c3a71a: OUTPUT: «2␤»

[11:45] <HoboWithAShotgun> interesting. i would have expected 3

[11:45] <timo> the result of a non-executed if is () aka Empty

[11:46] <timo> that flattens away in list assignment

[11:46] *** headcase left
[11:49] <HoboWithAShotgun> so there is a value produced, it just happens to be of type Empty. So, 0 ?? 2 !! Empty should be the equivalent

[11:50] <HoboWithAShotgun> m: my @a = 3, 0 ?? 2 !! Empty, 1; say @a.elems

[11:50] <camelia> rakudo-moar c3a71a: OUTPUT: «2␤»

[11:50] <HoboWithAShotgun> heh

[11:51] *** ShalokShalom_ joined
[11:52] <HoboWithAShotgun> but i have skimmed the control flow and regex docs now, i still don't know what s/{something}/does/; and why it seems to match the beginning of a string

[11:52] *** eliasr joined
[11:54] <HoboWithAShotgun> i figured it'd execute "something" and replace its return value, but it doesn't

[11:54] *** headcase joined
[11:54] <piojo> timo: it seems that Empty is |(), not ()

[11:54] *** ShalokShalom left
[11:55] <piojo> and I'm also interested to know how (if 0 {}) becomes Empty

[11:55] <piojo> obviously () is empty, but not Empty (not a slip)

[11:56] <piojo> so how does putting some x inside -- (x) -- cause perl6 to turn it into a slip?

[11:56] <MasterDuke_> HoboWithAShotgun: {something} just executes, <{something}> interpolates the result of executing it into the regex

[11:56] <timo> oh, right, it must be a slip

[11:56] <timo> good catch

[11:57] <piojo> perl really isn't like other languages... the way it parses things makes me smile but stretches my brain.

[11:58] *** headcase left
[12:00] <piojo> Actually, I think I know how that case works: grouping paretheses are ignored, after they serve their purpose, so `(code...)` is not the same as`()`, because the latter is not for grouping, and it can't be just dropped by the compiler.

[12:00] <piojo> so `(code)` can be turned into a slip because it's actually equivalent to `code`, not list(`code`)

[12:01] <piojo> ("turned into a slip" == evaluated and returns something that is a slip)

[12:01] <timo> m: say ()

[12:01] <camelia> rakudo-moar c3a71a: OUTPUT: «()␤»

[12:01] <timo> m: say ().perl

[12:01] <camelia> rakudo-moar c3a71a: OUTPUT: «()␤»

[12:01] <timo> gee thanks %)

[12:01] <timo> m: say ().^name

[12:01] <camelia> rakudo-moar c3a71a: OUTPUT: «List␤»

[12:01] <piojo> m: say (42).perl

[12:01] <camelia> rakudo-moar c3a71a: OUTPUT: «42␤»

[12:01] <piojo> m: say ().perl

[12:01] <camelia> rakudo-moar c3a71a: OUTPUT: «()␤»

[12:02] <timo> yeah, the comma is normally what causes a list to be created, except if the parens are completely empty (and not in a place where they would be an argument list)

[12:02] <piojo> so () is only kept when it doesn't serve a semantic purpose

[12:02] <MasterDuke_> m: say (42,).perl

[12:02] <camelia> rakudo-moar c3a71a: OUTPUT: «(42,)␤»

[12:02] <piojo> but you know what gets me? this:

[12:02] <piojo> m: say <hi>.perl

[12:02] <camelia> rakudo-moar c3a71a: OUTPUT: «"hi"␤»

[12:02] <moritz> m: say <hi>.^name

[12:02] <camelia> rakudo-moar c3a71a: OUTPUT: «Str␤»

[12:03] *** headcase joined
[12:04] <piojo> m: dd <hello world>,

[12:04] <camelia> rakudo-moar c3a71a: OUTPUT: «("hello", "world")␤»

[12:04] <piojo> so with a comma, it doesn't matter whether there's just one word, or more

[12:04] <piojo> except it's awkward to do that in an argument list

[12:04] *** ShalokShalom_ is now known as ShalokShalom

[12:05] <piojo> m: say <hello>,, ('world',)

[12:05] <camelia> rakudo-moar c3a71a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix , instead␤at <tmp>:1␤------> 3say <hello>,,7⏏5 ('world',)␤»

[12:05] <piojo> m: say (<hello>,), ('world',)

[12:05] <camelia> rakudo-moar c3a71a: OUTPUT: «(hello)(world)␤»

[12:05] <piojo> awkward ways to make lists :P

[12:07] <timo> corner cases everywhere!

[12:08] <jnthn> m: say @('hello'), @('world') # arguably prettier than trailing ,

[12:08] <camelia> rakudo-moar c3a71a: OUTPUT: «(hello)(world)␤»

[12:08] *** headcase_ joined
[12:08] <piojo> jnthn: I like that, thanks. I'll try to remember that

[12:08] <piojo> m: dd @<hello>

[12:08] <camelia> rakudo-moar c3a71a: OUTPUT: «(Nil,)␤»

[12:08] <timo> haha

[12:08] * piojo shrugs

[12:08] <timo> that's a postcircumfix there

[12:09] <timo> kind of like %foo<bar baz>

[12:09] <jnthn> Is it?

[12:09] <jnthn> I thought it was the match object access sytnax

[12:09] <timo> right, it should complain about @ not having hash access

[12:09] <jnthn> Usually used as $<named-arg>

[12:09] <timo> oh, right!

[12:09] <timo> it is

[12:09] <timo> i thought of an anonymous state var

[12:09] <jnthn> m: dd @'hello'

[12:09] <camelia> rakudo-moar c3a71a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Name must begin with alphabetic character␤at <tmp>:1␤------> 3dd @7⏏5'hello'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        st…»

[12:09] <piojo> oh, I've seen % and @ used with no variable name before, and I wondered what that was

[12:09] <jnthn> m: dd @"hello"

[12:09] <camelia> rakudo-moar c3a71a: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Name must begin with alphabetic character␤at <tmp>:1␤------> 3dd @7⏏5"hello"␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        st…»

[12:10] <jnthn> Yeah, figured one'd not get away with that :)

[12:11] <moritz> m: /a b+/

[12:11] <camelia> rakudo-moar c3a71a: OUTPUT: «Potential difficulties:␤    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)␤    at <tmp>:1␤    ------> 3/a7⏏5 b+/␤»

[12:11] <piojo> so is @<hello> really the match object? Is this a way to access / <hello>* / ?

[12:11] <moritz> I'm kinda annoyed by this warning; the quantifier after the second atom makes the whitespace very sensible

[12:12] <HoboWithAShotgun> MasterDuke_: thanks, yet what does <{}> do? where is that documented?

[12:12] *** headcase left
[12:13] <piojo> m: 'a b c' ~~ m/<match>=(.*)/; say @<match>.perl

[12:13] <camelia> rakudo-moar c3a71a: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter = (must be quoted to match literally)␤at <tmp>:1␤------> 3'a b c' ~~ m/<match>7⏏5=(.*)/; say @<match>.perl␤Couldn't find terminator / (corresponding / was at line 1)␤at <tmp>:1␤------>…»

[12:13] <piojo> m: 'a b c' ~~ m/ <match>=(.*) /; say @<match>.perl

[12:13] <camelia> rakudo-moar c3a71a: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter = (must be quoted to match literally)␤at <tmp>:1␤------> 3'a b c' ~~ m/ <match>7⏏5=(.*) /; say @<match>.perl␤Couldn't find terminator / (corresponding / was at line 1)␤at <tmp>:1␤-----…»

[12:13] <moritz> piojo: should be $<match>=

[12:13] *** kaare_ left
[12:13] <piojo> moritz: thanks!

[12:14] <piojo> m: 'a b c' ~~ m/ $<match>=(.*) /; say @<match>.perl

[12:14] <camelia> rakudo-moar c3a71a: OUTPUT: «()␤»

[12:14] <piojo> m: 'a b c' ~~ m/ $<match>=(.*) /; say $<match>.perl

[12:14] <camelia> rakudo-moar c3a71a: OUTPUT: «Match.new(list => (), made => Any, pos => 5, hash => Map.new(()), orig => "a b c", from => 0)␤»

[12:14] <piojo> jnthn: so @<foo> isn't the match object, it seems

[12:14] <MasterDuke_> HoboWithAShotgun: don't know where it's documented

[12:16] <MasterDuke_> m: say "a1b2c3" ~~ /a <{"hobo".chars - "hob".chars}> b/

[12:16] <camelia> rakudo-moar c3a71a: OUTPUT: «｢a1b｣␤»

[12:16] <MasterDuke_> m: say "a1b2c3" ~~ /a <{"hobowithashotgun".chars - "hob".chars}> b/

[12:16] <camelia> rakudo-moar c3a71a: OUTPUT: «Nil␤»

[12:17] <jnthn> piojo: heh, wow, I thought t was...

[12:18] <piojo> jnthn: the test wasn't rigorous, though. a better test would have a named match group with a quantifier

[12:18] <teatime> just wanna say:  the fact that even you guys can't always remember the special vars / funny symbols, gives me hope 

[12:19] <jnthn> huh, the AST seems to agree with me

[12:19] <jnthn>                     - QAST::Op(callmethod list) <sunk> :statement_id<?>

[12:19] <jnthn>                       - QAST::Op(call &postcircumfix:<{ }>)  <foo>

[12:19] <jnthn>                         - QAST::Var(lexical $/) 

[12:19] <jnthn>                         - QAST::WVal(Str)  foo

[12:20] <jnthn> @<foo> desugars to $/{'foo'}.list

[12:20] <piojo> jnthn: you were right

[12:20] <piojo> m: grammar G { token TOP { <match>* }; token match { . } }; G.parse('foo'); dd @<match>

[12:20] <camelia> rakudo-moar c3a71a: OUTPUT: «[Match.new(list => (), made => Any, pos => 1, hash => Map.new(()), orig => "foo", from => 0), Match.new(list => (), made => Any, pos => 2, hash => Map.new(()), orig => "foo", from => 1), Match.new(list => (), made => Any, pos => 3, hash => Map.new(()), o…»

[12:21] <piojo> my other example must have failed because of details about when the array part of the match is assigned to.

[12:21] *** armin left
[12:21] <timo> one day we'll totally build that desuger module/function

[12:22] <jnthn> m: "aaa" ~~ /[$<foo>=a]+/; say @<foo>

[12:22] <camelia> rakudo-moar c3a71a: OUTPUT: «[｢a｣ ｢a｣ ｢a｣]␤»

[12:23] <piojo> If you have a certain $/ in local scope, does @<...> come along for the ride just as $<...> ?

[12:24] <timo> they are literally just syntax shortcuts to calling postcircumfix:<{ }> on $/

[12:24] <timo> (and in the case of @< > and %< > also calling .list or .hash on them)

[12:25] <piojo> timo: oh, thanks.

[12:25] <piojo> though I have to assume that's merely _almost_ true

[12:25] <timo> ah?

[12:25] <piojo> because that doesn't explain why @<match> is not populated, when in the same code has $<match> containing a value

[12:26] <piojo> m: 'a b c' ~~ m/ $<match>=(.*) /; say $<match>.perl; say @<match>.perl

[12:26] <camelia> rakudo-moar c3a71a: OUTPUT: «Match.new(list => (), made => Any, pos => 5, hash => Map.new(()), orig => "a b c", from => 0)␤()␤»

[12:26] <timo> oh

[12:26] <timo> of course you get the .list of the thing

[12:26] *** cognominal left
[12:26] <piojo> haha

[12:26] <timo> and the list => () part from the Match is what you get here

[12:26] <piojo> oh

[12:26] <piojo> oh, so .list isn't like list()

[12:26] <piojo> sorry, should have realized

[12:27] <piojo> I've been confusing myself about that, recently. this goes a long way toward clearing up some things I've been puzzling about, like when hash(...) gives a different result than (...).hash

[12:27] <timo> it gets more interesting when the $<foo>=... is actually captured multiple times

[12:28] *** headcase_ left
[12:28] *** Skarsnik_ joined
[12:28] <timo> like jnthn showed above with the "aaa" match

[12:28] <piojo> yeah

[12:28] <piojo> I know that's gonna be useful

[12:28] <piojo> I've wondered in the past about how to address when a match should be an array that might have 0 or 1 value(s). This is probably applicable

[12:30] *** domidumont joined
[12:30] <piojo> though I think @($<match>) would also solve that problem

[12:30] <timo> for "0 or 1 matches" you can decide between using "?" where you'll get a Nil or a single value, or using ** 0..1, where you'll always get a list

[12:30] <timo> m: "" ~~ / "a"* /; say $/.perl

[12:30] <camelia> rakudo-moar c3a71a: OUTPUT: «Match.new(list => (), made => Any, pos => 0, hash => Map.new(()), orig => "", from => 0)␤»

[12:30] <timo> m: "a" ~~ / "a"* /; say $/.perl

[12:30] <camelia> rakudo-moar c3a71a: OUTPUT: «Match.new(list => (), made => Any, pos => 1, hash => Map.new(()), orig => "a", from => 0)␤»

[12:30] <piojo> timo: that's good to know

[12:30] <piojo> I actually meant *, though

[12:30] <piojo> I wasn't sure the engine would give me a list if there's 1 match

[12:30] <timo> oh, that wasn't interesting at all

[12:31] <timo> m: "a" ~~ / ("a")* /; say $/.perl

[12:31] <camelia> rakudo-moar c3a71a: OUTPUT: «Match.new(list => ([Match.new(list => (), made => Any, pos => 1, hash => Map.new(()), orig => "a", from => 0)],), made => Any, pos => 1, hash => Map.new(()), orig => "a", from => 0)␤»

[12:31] <piojo> I suppose it will. my code was buggy enough that I'm not sure I got to that point

[12:31] <timo> there it is

[12:31] *** Skarsnik left
[12:32] <piojo> m: 'a' ~~ / [ $<a>='a']* /; say $<a>.elems

[12:32] <camelia> rakudo-moar c3a71a: OUTPUT: «1␤»

[12:33] <piojo> sorry, that's the newbie version :)

[12:34] <piojo> uh-oh, I'm remembering more details

[12:34] <teatime> timo: are you also timotimo ?

[12:35] *** cognominal joined
[12:36] <piojo> m: 'aa' ~~ / $<match>=a | [ $<match>=a ]* /; say $<match>.elems

[12:36] <camelia> rakudo-moar c3a71a: OUTPUT: «2␤»

[12:36] <piojo> m: 'aa' ~~ / $<match>=a || [ $<match>=a ]* /; say $<match>.elems

[12:36] <camelia> rakudo-moar c3a71a: OUTPUT: «1␤»

[12:36] <piojo> m: 'aa' ~~ / $<match>=a /; say $<match>.elems

[12:36] <camelia> rakudo-moar c3a71a: OUTPUT: «0␤»

[12:36] <piojo> haha

[12:37] <piojo> It's definitely smarter than I expected

[12:38] *** cognominal left
[12:39] <timo> teatime: i am

[12:39] *** timo is now known as timotimo

[12:39] <timotimo> sorry for the confusion

[12:39] <piojo> teatime: who will you be in an hour?

[12:39] <timotimo> who will you be when the irc drops?

[12:39] <piojo> I mean, if you're teatime now.

[12:40] <teatime> so, tea is lovely nearly any time.  and, it's all kinds of different times around the globe.  I assert that any time is teatime :)

[12:41] <piojo> excellent answer :)

[12:41] <teatime> timotimo: no worries, just curious / trying to keep up w/ "faces".

[12:41] *** cognominal joined
[12:41] <teatime> I do not at all understand why    'aa' ~~ / $<match>=a /; say $<match>.elems    -->    0

[12:42] <teatime> hrm, it is a Match though, not a Str like I was thinking.

[12:42] <timotimo> because the .elems goes at the .list part i'd expect

[12:42] *** _28_ria left
[12:42] *** nadim joined
[12:42] <piojo> so the more interesting question is how the .list part gets populated

[12:43] <teatime> "Returns the number of positional elements in the Capture."  aha, gotcha.

[12:43] <piojo> I think it's populated permissively, if there could *possibly* be anything in the list, then that thing is put in

[12:44] <piojo> m: 'aa' ~~ / $<match>=a || $<match>=a /; say $<match>.elems

[12:44] *** _28_ria joined
[12:44] <camelia> rakudo-moar c3a71a: OUTPUT: «0␤»

[12:44] *** Ven`` left
[12:44] *** llfourn left
[12:44] *** HoboWithAShotgun left
[12:44] *** Ven`` joined
[12:44] <piojo> yep, that's how it looks. if it sees any value being populated by the *, +, or {x}, or {x..x} quantifiers, it will be treated as belonging to a list, even if that match-codepath is not true (doesn't match)

[12:50] * teatime finally gets it.

[12:58] *** pmurias_ joined
[12:59] *** pmurias joined
[12:59] <pmurias> or backends where there are really only 32bit integers do we want to emulate 8,16bit behavior for int16, int8 etc.?

[13:01] *** headcase joined
[13:02] <moritz> I think so, yes

[13:02] <moritz> there are some algorithms (like hash sums / message digests) where the wrapping is mandatory

[13:03] <moritz> but maybe wait for somebody elses opinion

[13:03] *** zakharyas left
[13:05] *** headcase left
[13:05] * pmurias dislikes doing language design choices

[13:06] <pmurias> too much questions where there are arguments for both choices ;)

[13:09] *** MasterDuke_ left
[13:09] <teatime> <stdint.h> -> uint16_t is *exactly* 16 bits wide.  it would surprise me if I used a type called "int16" and it was actually ≥16 rather ==16 bits wide.

[13:10] *** headcase joined
[13:11] *** domidumont left
[13:13] <hahainternet> teatime: hope you don't put things in structs ;)

[13:14] <piojo> ‎hahainternet‎: it would be nice if we could put things in structs

[13:14] <hahainternet> piojo: i thought nativecall padded correctly

[13:14] <piojo> I reimplemented a clever file duplicate finding algorithm in perl, and it kept running out of memory and choking

[13:15] <piojo> I mean, not structs for native calls, but structs for perl

[13:15] <hahainternet> i don't see why that's a problem, p6 has native types

[13:15] <piojo> objects with a known memory layout and size

[13:16] <piojo> I haven't explored that yet--actually, I wasn't planning to port it to perl6 until it's faster

[13:16] <piojo> perl6 seems quite slow for filesystem operations

[13:16] <teatime> I need to deep-dive into the nativecall stuff at some point... it's a mystery to me how it (that is, the ecosystem libs that wrap shared libs) can work reliably.

[13:16] <hahainternet> it's quite slow in general, but that's not really a criticism given how much work has gone into it so far

[13:17] <hahainternet> piojo: i would say though, treating memory as an on-demand, virtually allocatable, balloonable pool is a naive approach and you should implement a fixed size pool in your code

[13:17] <hahainternet> but that's arguably also pre-optimisation

[13:17] <hahainternet> and i know many people who prefer the Lambda approach

[13:17] *** headcase left
[13:17] *** headcase_ joined
[13:17] <teatime> like, it's way easier to successfully make one of those wrappers than should be possible, or something.

[13:18] <hahainternet> teatime: C calling conventions are pretty straightforward

[13:18] <piojo> ‎hahainternet‎: I'm not sure what you mean. But my (perl5) code is all perl objects and code. The memory I'm running out of is because for example a perl int is a lot bigger than 32 bytes.

[13:19] <hahainternet> piojo: imagine trying to write this same algorithm on a system that was severely memory constrained

[13:19] <hahainternet> say a megabyte or two

[13:19] <hahainternet> instead of creating arbitrary objects and adding to a list or similar

[13:19] <piojo> but even if all the memory usage were equivalent to native bytes, it would still be a tight squeeze, so I converted it to use sqlite, which is probably the right path, given that the size increases with the count of files examined

[13:19] <piojo> hahainternet: yeah, that agrees with what I eventually decided

[13:20] <hahainternet> you would statically allocate an area of memory and reuse it consistently

[13:20] <hahainternet> sqlite is a decent approach depending on your index requirements

[13:20] <piojo> hahainternet: the algorithm requires remembering some data for every file examined

[13:20] <hahainternet> i would usually hesitate to mention this, but you could consider memcached

[13:20] <hahainternet> piojo: right, but how much it can remember depends on your system

[13:20] <hahainternet> and if you simply blindly allocate objects and store them, you'll never know if your script can work on a system or not without trying it

[13:21] <hahainternet> anyway i'm not saying you should go away and go statically allocating

[13:21] <piojo> hahainternet: it has to remember all of it. and yes, you're right, that can't possibly work, but there's not a better way, other than ridiculous hacks that would require lots of extra I/O because information was purged from memory

[13:22] <piojo> so a database is necessary if the script is going to run on all systems.

[13:22] <hahainternet> piojo: so make the extra IO more efficient, learn about r/b trees etc (depending on your balancing requirements)

[13:22] <hahainternet> anyway i'm not trying to suggest you've done anythign wrong or bad

[13:22] <hahainternet> just saying that strategy is not going to be a winner even if you have 10x more RAM, because its memory requirement is set by the size of the challenge

[13:22] <hahainternet> you should aim to design your software so that its memory requirement is as static as possible no matter the input set size

[13:23] <hahainternet> memcached/sqlite are excellent options there

[13:23] *** headcase joined
[13:23] <piojo> some algorithms are O(n) in memory usage--I believe file duplicate checking falls into that category

[13:24] <piojo> at a minimum, you need to memorize the size of each file

[13:24] <piojo> *duplicate file finding, not just checking

[13:24] <hahainternet> i can think of smaller algorithms

[13:24] <hahainternet> hash the file, store the first nibble

[13:24] <hahainternet> there's always going to be options

[13:24] <hahainternet> it's more of a question for your use case what's appropriate

[13:24] <piojo> that's stil O(n), just a smaller n

[13:24] <hahainternet> i just wanted to point out that if you're OOMing on perl5, no language will fix that explosion

[13:25] <hahainternet> piojo: big-o is a complexity class

[13:25] <hahainternet> a multi-stage algorithm is not the same

[13:25] <piojo> It's still O(n), even if there are 3-4 passes over the input data

[13:26] <hahainternet> i suppose technically if you're using big enough ints that the file size certainly fits inside

[13:26] *** headcase_ left
[13:26] <hahainternet> but the size of your result is actually known, vs 'a big number'

[13:26] <moritz> .oO( O(4n) )

[13:28] <hahainternet> piojo: you can easily think of this in a different way

[13:28] <piojo> hahainternet: basically, I agree with you, it might be acceptable to write programs that will run fine "unless you try to run it on more than 30 million files", as long as that limitation is documented

[13:28] <hahainternet> take the length of your files, int divide it

[13:28] <hahainternet> (by 2)

[13:28] <piojo> but it would hurt my pride to write one that chokes with a much smaller limit

[13:28] <hahainternet> now you need only store which of the two categories the file is in

[13:28] <hahainternet> two whole bits :p

[13:29] <hahainternet> and yeah piojo that is quite common with an awful lot of tools

[13:29] <hahainternet> but it's also a very common mistake i see, especially in my own code :)

[13:32] <piojo> hahainternet: that's clever, but in the case I tried, it wouldn't have helped because almost every file had at least one duplicate, so pre-passes saved IO (by comparing inodes) but didn't really reduce the amount of stuff that had to be remembered so much

[13:32] *** headcase left
[13:33] <hahainternet> piojo: it's just a hash :p

[13:33] <hahainternet> but yeah there are plenty of techniques

[13:33] <hahainternet> it's up to you to choose what works best for your use case

[13:33] <piojo> hahainternet: actually, I'm not sure I understand. are you talking about dividing divide and conquor, based on categorizing the size?

[13:33] <hahainternet> yeah if you have 30 million files, and you store if the length is odd or even, you need 30 million bits total

[13:33] <hahainternet> and that bisects your set to approximately 15 million files

[13:33] <hahainternet> so next pass you now have 2 bits per file to play with

[13:33] <piojo> plus the size of the filenames, which is the real killer

[13:33] <hahainternet> then 4 bits

[13:33] <hahainternet> then 8 bits

[13:34] <hahainternet> piojo: sort them, use bit # in memory to be file #

[13:34] <hahainternet> there are lots and lots of techniques for this, i don't want to imply you've done anything wrong though

[13:34] <piojo> I thought about that, but decided it wouldn't help enough :)

[13:34] <piojo> I'm sure you have a lot of great ideas I haven't thought of

[13:35] <piojo> but I divided the acceptable memory usage by the number of files and found even perfect optimizations wouldn't be enough, except one--

[13:35] <piojo> it ended up not working out, but in c++ (not perl) I would have been able to store the filenames in a trie, with each node representing a directory (or the basename)

[13:36] <piojo> I tried it in perl but it used even more memory than just storing each fname as a full string. Because of overhead for variables, I think

[13:36] <hahainternet> well you can do that in perl, but yeah memory usage

[13:36] <pmurias> hmm, is there a way to determine which multi variant is called?

[13:37] *** nadim left
[13:38] <hahainternet> piojo: just out of interest, can you give me some actual numbers

[13:38] <hahainternet> like you have 4 billion files

[13:38] <hahainternet> and 200mb memory

[13:38] <piojo> hahainternet: if I recall, it was 5 billion files. 8 GB ram, with half taken up by other programs that were running

[13:38] <hahainternet> yeah that's quite difficult, no matter how efficient

[13:39] <piojo> some long filenames. lots of hard links because it was a backup disk. Slow frustrating I/O, so that had to be as efficient as possible

[13:39] <hahainternet> oh, this smells like a mailserver backup usign rsync

[13:39] <hahainternet> how far am i off the mark?

[13:39] <piojo> just a personal backup with rsync :)

[13:39] <hahainternet> 5 billion files, crikey

[13:40] <piojo> I don't know where they all came from

[13:40] <hahainternet> anyhow i'd do some sort of component analysis there, because short of using the technique of a 2 bit hash and repeated passes

[13:40] <piojo> oh, I think there probably was a mail directory in there somewhere

[13:40] <hahainternet> the next stage after that is to make your hash function more perfect

[13:40] <hahainternet> that is, you identify the type of test that is most likely to split your set up into a small 'potential match' set

[13:40] <piojo> I borrowed the algorithm from fslint, but modified it to be smart about repeated inodes

[13:40] <hahainternet> microsoft have an interesting paper on perfect hash functions

[13:41] <hahainternet> i think what you'd want is kinda the opposite

[13:42] <piojo> the hash doesn't need to be that fast, because it's not run very often--first pass gets sizes, then sorts. next pass makes sure the inode hasn't been seen yet (this is my change) and gets a checksum of the first kilobyte. next pass does a full checksum

[13:43] <hahainternet> i see the thought, and doing a size pass is a good idea if it fits in memory

[13:43] <piojo> I should really get around to publishing that on cpan. I need to clean it up and find out what the coding standards for publication are...

[13:43] <hahainternet> but the 'hash' is just a consistent reduction of your data into a smaller space

[13:43] <hahainternet> a perfect hash embodies the minimum set required to identify a member uniquely

[13:43] *** headcase joined
[13:44] <hahainternet> you kinda want the opposite, the shortest hash required to identify a minimum set

[13:44] <hahainternet> right i'm gonna go deal with some irl things, i'm sorry i can't be of any direct help piojo 

[13:44] <hahainternet> but fun chat :)

[13:44] <piojo> hahainternet: yeah, good talking to you!

[13:44] <hahainternet> plus there's always people here willing to help out with perl, and you should play with 6 regardless

[13:44] <hahainternet> because it's absurdly fun, -Ofun don't you know

[13:44] <piojo> yeah, I like it a lot

[13:45] <piojo> but I'm not gonna wait for rakudo to scan 5 billion files 3 times

[13:45] <hahainternet> why not? do it and profile it

[13:45] <timotimo> maybe only with 5 thousand files

[13:45] <hahainternet> then you're providing useful data on what's really slow as heck

[13:45] <teatime> warning: perl6 is known to the state of california to be addictive.

[13:45] <piojo> If that's useful, we could start smaller

[13:45] <hahainternet> you kids and your » symbols

[13:45] <piojo> a directory walk is significantly slower in perl6 than perl5

[13:46] *** raschipi joined
[13:46] <piojo> though threading speeds it up to be just 50% slower

[13:46] <piojo> (err, that's for a type of full-text search, not just a directory walk)

[13:47] <piojo> I'm also comparing apples to oranges, since my perl5 version is using the cygwin perl5, which is far faster than the windows perl5

[13:48] *** Rawriful joined
[13:51] <raschipi> 💩💩💩

[13:52] *** HoboWithAShotgun joined
[13:54] <HoboWithAShotgun> allright. how can it be an operator behaves differntly depending on wether i import it from a module or wether it is in the program itself

[13:55] *** Rawriful left
[13:55] <raschipi> HoboWithAShotgun: How so?

[13:57] *** Rawriful joined
[13:58] *** nadim joined
[13:58] <HoboWithAShotgun> apparently a precedence issue

[14:00] <HoboWithAShotgun> consider, https://hastebin.com/ixomivepoh.pl

[14:01] *** lustlife joined
[14:01] * raschipi considers

[14:03] <raschipi> Are you sure the other code declares itself looser than the comma?

[14:03] <HoboWithAShotgun> i am sure the code is identical

[14:04] <raschipi> Does anyone know a way to introspect the precedence of an operator?

[14:04] *** imcsk8 left
[14:04] *** knobo joined
[14:04] *** headcase_ joined
[14:04] *** wander4096 left
[14:06] *** headcase left
[14:08] *** MasterDuke joined
[14:09] <timotimo> m: say &infix:<,>.pred

[14:09] <camelia> rakudo-moar c3a71a: OUTPUT: «No such method 'pred' for invocant of type 'Sub+{<anon|63427424>}+{Precedence}'. Did you mean any of these?␤    grep␤    prec␤    tree␤␤  in block <unit> at <tmp> line 1␤␤»

[14:09] <timotimo> m: say &infix:<,>.precedence

[14:09] <camelia> rakudo-moar c3a71a: OUTPUT: «No such method 'precedence' for invocant of type 'Sub+{<anon|63427424>}+{Precedence}'␤  in block <unit> at <tmp> line 1␤␤»

[14:09] <timotimo> m: say &infix:<,>.prec

[14:09] <camelia> rakudo-moar c3a71a: OUTPUT: «{assoc => list, prec => g=}␤»

[14:09] <timotimo> there we go

[14:10] *** lancew joined
[14:11] *** lancew left
[14:11] <raschipi> Thanks, timotimo.

[14:11] <raschipi> HoboWithAShotgun: Can you run that method in your code?

[14:13] *** AlexDaniel joined
[14:15] *** vendethiel- joined
[14:15] <HoboWithAShotgun> it says {} for the op in the script file and {prec => v=} for the imported one

[14:16] <HoboWithAShotgun> so, yes. the precedence is different

[14:16] *** knobo left
[14:16] *** Ven`` left
[14:17] <raschipi> Are you sure it's calling the correct multi?

[14:18] <HoboWithAShotgun> yes, as seen in the output. there is no third one

[14:18] *** skids joined
[14:18] *** headcase joined
[14:19] <HoboWithAShotgun> i put together a minimal case and see if that persists. if so i gonna file a bug

[14:19] *** ufobat___ left
[14:20] <raschipi> HoboWithAShotgun: I think you hit RT #128042

[14:20] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=128042

[14:21] *** dogbert2 joined
[14:21] *** headcase_ left
[14:22] *** KDr2__ joined
[14:24] <HoboWithAShotgun> uh, nice and the fix right there

[14:26] *** dogbert2 left
[14:32] *** ufobat___ joined
[14:37] *** setty1 left
[14:48] *** rindolf joined
[14:50] *** skids left
[14:50] *** Skarsnik joined
[14:50] *** MasterDuke left
[14:51] *** bisectable6 left
[14:51] *** unicodable6 left
[14:51] *** squashable6 left
[14:51] *** benchable6 left
[14:51] *** committable6 left
[14:51] *** bloatable6 left
[14:51] *** coverable6 left
[14:51] *** evalable6 left
[14:51] *** releasable6 left
[14:51] *** greppable6 left
[14:51] *** quotable6 left
[14:51] *** statisfiable6 left
[14:51] *** nativecallable6 left
[14:52] *** MasterDuke joined
[14:53] *** vike left
[14:53] *** Skarsnik_ left
[14:55] *** bloatable6 joined
[14:55] *** ChanServ sets mode: +v bloatable6

[14:55] *** coverable6 joined
[14:55] *** nativecallable6 joined
[14:55] *** ChanServ sets mode: +v coverable6

[14:55] *** ChanServ sets mode: +v nativecallable6

[14:55] *** releasable6 joined
[14:55] *** quotable6 joined
[14:55] *** evalable6 joined
[14:55] *** ChanServ sets mode: +v evalable6

[14:55] *** bisectable6 joined
[14:55] *** committable6 joined
[14:55] *** ChanServ sets mode: +v bisectable6

[14:55] *** ChanServ sets mode: +v committable6

[14:55] *** greppable6 joined
[14:56] *** unicodable6 joined
[14:56] *** ChanServ sets mode: +v unicodable6

[14:56] *** benchable6 joined
[14:56] *** statisfiable6 joined
[14:56] *** squashable6 joined
[14:56] *** ChanServ sets mode: +v squashable6

[15:02] *** vike joined
[15:06] *** headcase left
[15:07] *** Actualeyes left
[15:09] <raschipi> Tidal bots.

[15:14] <HoboWithAShotgun> how do i introspect the parameters to a sub within the sub via introspection. I know I must get ahold of the routine object of the mehod but how

[15:18] *** MasterDuke left
[15:19] <HoboWithAShotgun> that's all i can find in the docs: "Introspection on subroutines is provided via Routine."

[15:20] <HoboWithAShotgun> yes, tyvm. that doesn't tell me how to get an instance of it

[15:22] <jnthn> &?ROUTINE

[15:24] <HoboWithAShotgun> doesn't work within the routine. maybe that's xy. i have a sub with various named arguments and i want to access those via a hash

[15:25] <moritz> HoboWithAShotgun: just declare the signature with *%named or so

[15:26] <moritz> m: sub foo(*%named) { say %named.keys.sort.list.perl }; foo a => 2, :b, :c(34);

[15:26] <camelia> rakudo-moar e6a695: OUTPUT: «("a", "b", "c")␤»

[15:26] <HoboWithAShotgun> i know. but i want to keep the explicitly named arguments

[15:29] <ugexe> is passing an action class + supply to a JSON grammar a kind of streaming json parser if the action class emits its first level objects from the action class?

[15:30] <moritz> HoboWithAShotgun: you can have both with a subsignature

[15:30] *** headcase joined
[15:30] <moritz> m: sub foo(*%named (:$a, Int :$b) ) { say $b; say %named.keys }; foo b => 42;

[15:30] <camelia> rakudo-moar e6a695: OUTPUT: «42␤(b)␤»

[15:31] <weabot> What's the best way to use a long-lived thread that I basically want to use as a different process sharing the same address space?

[15:31] <weabot> is the Thread class more reliable for this than promises?

[15:33] *** headcase_ joined
[15:34] *** headcase left
[15:36] *** Cabanossi left
[15:37] <moritz> weabot: what reliability issues are you having with promises?

[15:37] *** headcase_ left
[15:37] <weabot> they hang after a bit, I'll make an example real quick

[15:38] *** Cabanossi joined
[15:38] *** kaare_ joined
[15:39] *** rindolf left
[15:42] <jnthn> How many are you creating? If lots of them, it's possible you're running into the thread pool size limit (which you can increase)

[15:43] <weabot> I'm creating them with Promise.start, appending the return value to an array that's cleaned when another function sees that the promise is kept, I make sure that the amount of promises I have stays under 10

[15:43] <weabot> well, I call .Bool on each promise and delete the entry if it shows True

[15:43] *** nadim left
[15:45] *** rindolf joined
[15:47] <weabot> alright here it is https://p.teknik.io/L88yU

[15:47] <weabot> on my end this prints 1 and 2, and eventually stops

[15:47] <weabot> there is no 0

[15:47] <weabot> I'm sure I'm doing something wrong, but this is generally what happens in my program

[15:48] <weabot> it starts, and after a few instructions it hangs

[15:48] *** headcase joined
[15:49] <sena_kun> weabot, it prints 2 infinitely for me.

[15:49] <weabot> what OS are you on?

[15:49] <weabot> and version

[15:49] <sena_kun> linux, 2017.08-108-g760530a52 built on MoarVM version 2017.08.1-150-g0b81969db

[15:50] <weabot> interesting, I'll try it on linux

[15:50] *** MasterDuke joined
[15:50] <weabot> yup, only prints 2 on linux

[15:51] <weabot> on 2017.07

[15:51] <weabot> but it eventually stops

[15:52] *** headcase left
[15:53] <weabot> now here's something

[15:54] *** headcase joined
[15:54] <weabot> if I call them all individually without a loop, they all print before stopping

[15:58] *** headcase left
[15:59] <piojo> weabot: for me on linux it prints 1 and 2

[16:00] <piojo> but my version is 

[16:00] <piojo> sub t($i) {

[16:00] <piojo> 	while (True) {

[16:00] <piojo> 		print($i);

[16:00] <piojo> 	}

[16:00] <piojo> }

[16:00] <piojo> sub MAIN() {

[16:00] <piojo> 	loop (my $i = 0; $i < 2; $i++) {

[16:00] <piojo> 		Promise.start({t($i)});

[16:00] <piojo> 	}

[16:00] <piojo> 	t($i);

[16:00] <piojo> 	# Not reached

[16:00] <piojo> 	return 0;

[16:00] <piojo> }

[16:00] <piojo> err, sorry about that

[16:00] <piojo> two clipboards!

[16:00] <piojo> my version is 2017.08-96-ge5a600997 built on MoarVM version 2017.08.1-135-ge86428d4

[16:01] <piojo> whoa, I ran it again and it only printed 2.

[16:01] *** zakharyas joined
[16:03] <piojo> is $i is being copied in the closure rather than aliased? because my guess is the variable is being copied only when the function call happens

[16:03] *** headcase joined
[16:04] <piojo> and if the function call occurs after the loop has already gotten to i=1 or i=2, then the function's value of $i will be frozen at that point

[16:04] <piojo> so the "22222222" behavior happens if all the iterations of the loop happen before the thread pool actually lets the threads long enough that they can get to the t() function call.

[16:05] <piojo> *before the thread pool lets the threads run long enough to get to the t() function call

[16:06] <piojo> (which means this is unexpected but not a bug. c# had the same issue, but they decided to change the language behavior because it was so damn counter-intuitive)

[16:06] <weabot> hmm

[16:06] <weabot> the bug is that the threads just stop printing anything after not too long for me

[16:06] <piojo> I bet if you make a copy of $i within the loop body, you get 0, 1, and 2

[16:06] <weabot> but let's see

[16:07] <piojo> weabot: isn't that just the program finishing?

[16:07] <weabot> nope, the command line doesn't return, I have to SIGINT

[16:07] <weabot> and I tried to do this

[16:07] <weabot>         my $done = Promise.allof(@promises);

[16:07] <weabot>         await $done;

[16:07] <weabot> no returns

[16:07] <piojo> weabot: oh, sorry, of course you're right. it also hangs for me. I had a dumb (actually an "it's my bedtime") moment

[16:07] *** headcase left
[16:08] <piojo> but I tested and was right about the "2222222" issue

[16:08] <weabot> hmm

[16:08] *** MasterDuke left
[16:08] *** zakharyas left
[16:08] <weabot> but when I use .ACCEPTS on t instead of putting it in a block, it only prints 0

[16:08] *** Sgeo_ left
[16:08] *** MasterDuke joined
[16:09] *** headcase joined
[16:09] <piojo> weabot: sorry, I'm not familiar with what that is

[16:09] *** MasterDuke left
[16:09] *** Sgeo joined
[16:10] <weabot> https://docs.perl6.org/type/Code#method_ACCEPTS

[16:10] <weabot> it lets you pass arguments

[16:11] *** lustlife left
[16:12] <piojo> changing it to &t.ACCEPTS($i) ? when I run that, I just get "22222222"

[16:13] <weabot> I only had 000

[16:13] *** HoboWithAShotgun left
[16:13] <weabot> anyway, here's what strange

[16:13] <piojo> I think on my computer, it causes the code to take longer to run

[16:13] <weabot> putting $i into another variable made it run forever

[16:13] <weabot> let me try again

[16:13] <piojo> oh, that is strange! It didn't do that fo rme

[16:13] *** headcase left
[16:14] <weabot> yep, it looks like it's gone for good

[16:14] <weabot> I have no clue why

[16:14] *** headcase joined
[16:16] <piojo> oh, and when it hangs, it's using 100% cpu. I wonder if it's deadlocked?

[16:16] <weabot> that's what I was thinking

[16:16] <piojo> I've gotta go to bed. sorry I didn't have an answer for the more buggy part of this test case. 

[16:17] <weabot> but on 2017.07 both on linux and macOS, setting $i in another variable lets it go on forever

[16:17] <weabot> I'm clueless

[16:17] <weabot> anyhow, good nigth piojo 

[16:17] <weabot> night*

[16:17] <piojo> night. It's too bad I'm not patient enough to stick around to hear the answer, if there is one. :D

[16:18] <weabot> yeah, I'm not sure we'll have them

[16:18] *** headcase left
[16:18] <weabot> if anything this way we'll figure out workarounds and write bug reports

[16:19] <Skarsnik> ping jnthn x)

[16:23] *** ritre joined
[16:23] *** virtualsue left
[16:30] *** KDr2__ left
[16:35] *** Cabanossi left
[16:37] *** ufobat___ left
[16:38] *** Cabanossi joined
[16:42] *** leont joined
[16:42] *** domidumont joined
[16:46] *** piojo left
[17:05] *** domidumont left
[17:05] *** Cabanossi left
[17:06] *** HoboWithAShotgun joined
[17:08] *** Cabanossi joined
[17:12] *** leont left
[17:13] *** raschipi left
[17:18] *** rindolf left
[17:23] *** rindolf joined
[17:28] *** HoboWithAShotgun left
[17:28] *** Skarsnik_ joined
[17:30] *** headcase joined
[17:31] *** ipatrol joined
[17:32] *** Skarsnik left
[17:32] <ipatrol> Can a module declared inline access variables from outside itself?

[17:33] *** domidumont joined
[17:33] *** headcase_ joined
[17:35] *** headcase left
[17:37] <ipatrol> m: my $foo = 'cat'; module Bar {sub foobar {say $foo;}} import Bar 'foobar'; foobar();

[17:37] <camelia> rakudo-moar bdbb7e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3at'; module Bar {sub foobar {say $foo;}}7⏏5 import Bar 'foobar'; foobar();␤    expecting any of:␤        infix␤   …»

[17:37] *** Cabanossi left
[17:37] <ipatrol> m: my $foo = 'cat'; module Bar {sub foobar() {say $foo;}} import Bar 'foobar'; foobar();

[17:37] <camelia> rakudo-moar bdbb7e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3'; module Bar {sub foobar() {say $foo;}}7⏏5 import Bar 'foobar'; foobar();␤    expecting any of:␤        infix␤   …»

[17:38] *** headcase_ left
[17:38] <ipatrol> m: my $foo = 'cat'; my module Bar {sub foobar() {say $foo;};}; import Bar 'foobar'; foobar();

[17:38] <camelia> rakudo-moar bdbb7e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    foobar used at line 1␤␤»

[17:38] *** Cabanossi joined
[17:38] *** grondilu left
[17:38] <ipatrol> m: my $foo = 'cat'; my module Bar {sub foobar() {say $foo;};}; import Bar 'foobar'; Bar::foobar();

[17:38] <camelia> rakudo-moar bdbb7e: OUTPUT: «Could not find symbol '&foobar'␤  in block <unit> at <tmp> line 1␤␤»

[17:38] <ipatrol> m: my $foo = 'cat'; my module Bar {our sub foobar() {say $foo;};}; import Bar 'foobar'; Bar::foobar();

[17:38] <camelia> rakudo-moar bdbb7e: OUTPUT: «cat␤»

[17:39] <ipatrol> m: my $foo = 'cat'; my module Bar {our sub foobar() {say $foo;};}; Bar::foobar();

[17:39] <camelia> rakudo-moar bdbb7e: OUTPUT: «cat␤»

[17:39] <ipatrol> m: my $foo = 'cat'; module Bar {our sub foobar() {say $foo;};}; Bar::foobar();

[17:39] <camelia> rakudo-moar bdbb7e: OUTPUT: «cat␤»

[17:40] <ipatrol> m: my $foo = 'cat'; module Bar {my $baz = 'nap'; our sub foobar() {say "$foo$baz";};}; Bar::foobar();

[17:40] <camelia> rakudo-moar bdbb7e: OUTPUT: «catnap␤»

[17:47] *** zakharyas joined
[17:49] *** karthyk joined
[17:51] *** pecastro left
[17:54] *** Skarsnik_ is now known as Skarsnik

[18:06] *** Cabanossi left
[18:08] *** Cabanossi joined
[18:13] *** leont joined
[18:16] *** headcase joined
[18:23] *** HoboWithAShotgun joined
[18:26] *** headcase_ joined
[18:29] *** headcase left
[18:29] *** knobo joined
[18:30] *** pecastro joined
[18:30] *** leont left
[18:36] *** knobo left
[18:38] *** leedo left
[18:39] *** leedo joined
[18:39] *** headcase_ left
[18:43] *** nadim joined
[18:44] *** headcase joined
[18:48] *** headcase left
[18:50] *** nadim left
[18:57] <HoboWithAShotgun> m:class Bar { method bar { die "a b c"; } }; throws-like { Bar.new().bar }, Exception, "test3", message => /a \s b/; # ok 

[18:57] <evalable6> HoboWithAShotgun, rakudo-moar bdbb7e4ac: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/OvmH1EDAz3␤Undeclared routine:␤    throws-like used at line 1␤»

[18:57] <HoboWithAShotgun> m:use Test; class Bar { method bar { die "a b c"; } }; throws-like { Bar.new().bar }, Exception, "test3", message => /a \s b/; # ok 

[18:57] <evalable6> HoboWithAShotgun, rakudo-moar bdbb7e4ac: OUTPUT: «    1..3␤    ok 1 - code dies␤    ok 2 - right exception type (Exception)␤    ok 3 - .message matches /a \s b/␤ok 1 - test3»

[18:58] <HoboWithAShotgun> m:use Test; class Bar { method bar { die "a b c"; } }; throws-like { Bar.new().bar }, Exception, "test3", message => m:s/a b/;

[18:58] <evalable6> HoboWithAShotgun, rakudo-moar bdbb7e4ac: OUTPUT: «(exit code 1) Use of uninitialized value of type Any in string context.␤Methods .^name, .p…»

[18:58] <evalable6> HoboWithAShotgun, Full output: https://gist.github.com/00b35084df73b2cc62099b1abf326612

[18:59] <HoboWithAShotgun> m: use Test; class Bar { method bar { die "a b c"; } }; throws-like { Bar.new().bar }, Exception, "test4", message => m:s/a b/;

[18:59] <camelia> rakudo-moar bdbb7e: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤    1..3␤    ok 1 - code dies␤    ok 2 - right exception type (Exception)␤    not ok 3 - .messa…»

[18:59] *** kaare__ joined
[19:00] <HoboWithAShotgun> strange. on my perl6 this does something different. also wrong, but different

[19:02] *** kaare_ left
[19:02] <HoboWithAShotgun> scratch that, i misread

[19:03] *** zakharyas left
[19:03] <HoboWithAShotgun> so, why does the second test fail? message => /a \s b/ and message => m:s/a b/ should be equivalent

[19:03] <HoboWithAShotgun> shouldn't they

[19:06] *** zakharyas joined
[19:07] <geekosaur> HoboWithAShotgun, the m// executes immediately

[19:07] <geekosaur> it is not a value, it is performed and its result is made the value associated with the key 'message'

[19:08] <HoboWithAShotgun> i see. 

[19:08] <ipatrol> use rx instead of m

[19:08] *** zakharyas left
[19:08] <geekosaur> ^

[19:09] *** headcase joined
[19:10] *** zakharyas joined
[19:11] *** pecastro left
[19:12] *** headcase_ joined
[19:12] *** headcase_ left
[19:13] <ipatrol> I have managed to condense virtually the entire system of verb conjugations in Japanese, into 150 lines of code, whitespace included.

[19:13] *** headcase left
[19:14] *** okl joined
[19:16] *** nadim joined
[19:16] <moritz> ipatrol: you scare me

[19:19] <HoboWithAShotgun> pff. i am not scared. i am panicking :)

[19:19] <HoboWithAShotgun> can i express this a bit shorter? $_ ~~ %_ && %_{$_}.defined

[19:20] <moritz> why not just %_{$_}.defined ?

[19:21] *** domidumont left
[19:21] <HoboWithAShotgun> good question. i figured that would throw an error

[19:22] <HoboWithAShotgun> since i cannot know if $_ is an existing key

[19:22] <Skarsnik> %_{$_}:exists?

[19:23] <ugexe> that includes undefined values

[19:23] *** darutoko left
[19:24] <ipatrol> moritz: why do I scare you?

[19:33] *** pecastro joined
[19:34] *** zakharyas1 joined
[19:35] *** zakharyas left
[19:35] *** zakharyas joined
[19:35] *** Cabanossi left
[19:36] *** zakharyas1 left
[19:38] *** Cabanossi joined
[19:39] *** headcase joined
[19:40] *** zakharyas left
[19:40] <ipatrol> I think I can knock out all the polite forms in another 50 lines or so

[19:43] *** headcase left
[19:44] *** HoboWithAShotgun left
[19:48] *** headcase joined
[19:54] *** ritre left
[19:57] *** headcase left
[19:59] *** headcase joined
[20:00] *** sena_kun left
[20:02] *** wamba left
[20:02] *** TEttinger joined
[20:02] *** headcase left
[20:03] *** headcase joined
[20:07] *** itaipu joined
[20:07] *** setty1 joined
[20:07] *** headcase left
[20:07] *** wamba joined
[20:15] <gfldex> lolibloggedalittle: https://gfldex.wordpress.com/2017/09/16/the-siege-can-continue/

[20:17] <timotimo> hehe

[20:18] *** eliasr left
[20:18] <ipatrol> can't see the whole line in my browser for some reason

[20:23] *** itaipu left
[20:29] *** rindolf left
[20:31] *** leont joined
[20:35] *** Cabanossi left
[20:38] *** Cabanossi joined
[20:42] *** domidumont joined
[20:42] *** itaipu joined
[20:46] <AlexDaniel> gfldex: hehe :D

[20:49] *** domidumont left
[20:49] *** nadim left
[20:51] *** dwarring left
[20:52] <ipatrol> Actually, I was able to code the polite conjugations in only 22 lines, plus a couple of functions defined earlier

[20:52] *** anosh joined
[20:59] *** headcase joined
[21:02] <ipatrol> https://gist.github.com/anonymous/d81236310178bc27c2ed58d6f2208e72

[21:03] *** mr-foobar left
[21:04] *** mr-foobar joined
[21:04] *** headcase left
[21:06] *** Cabanossi left
[21:08] *** Cabanossi joined
[21:18] *** leont left
[21:19] *** leont joined
[21:20] <unclechu> hey guys, could someone explain me how i've got `-2.44929359829471e-16` by `sin(pi * 2)` instead of zero?

[21:22] <timotimo> we use floating point numbers for trigonometry functions

[21:22] <timotimo> you'll get the same result from, for example, python

[21:22] <geekosaur> floating point is inherently inaccurate

[21:23] <geekosaur> or at least a similar but still nonzero one, unless something is specifically checking or you limit output precision

[21:25] <TEttinger> also, no way to store the exact value of pi

[21:26] <TEttinger> you could store it symbolically, but then it's just the symbol pi and needs special treatment

[21:26] <TEttinger> e-16 means it's very small though

[21:26] <ipatrol> you could store a routine that computes pi to arbitrary precision

[21:27] <TEttinger> can you pass an arbitrary precision number to sin()?

[21:27] <ipatrol> TEttinger: depends on how it's implemented

[21:27] *** headcase joined
[21:27] <ipatrol> unclechu: the thing is, Perl 6 is not a CAS.

[21:27] <TEttinger> in perl 6, thatis

[21:28] *** headcase left
[21:28] <unclechu> thanks

[21:29] <geekosaur> http://floating-point-gui.de/

[21:29] <TEttinger> I'm guessing there's a convenient way to compare within some epsilon

[21:30] <ipatrol> TEttinger: I think =~= does that

[21:30] <sjn> m: say sin(π * 2) =~= 0

[21:30] <camelia> rakudo-moar 24d6c6: OUTPUT: «True␤»

[21:30] <TEttinger> nice

[21:31] <ipatrol> the epsilon it uses is $*TOLERANCE

[21:31] <TEttinger> say sin(π / 2.0) =~= 1

[21:31] <evalable6> TEttinger, rakudo-moar 24d6c66f3: OUTPUT: «True»

[21:31] <ipatrol> m: say $*TOLERANCE;

[21:31] <camelia> rakudo-moar 24d6c6: OUTPUT: «1e-15␤»

[21:32] <TEttinger> huh, evalable6 took over there, thanks evalable6

[21:32] <gfldex> m: say sin(π / 2.0) ≅ 1

[21:32] <camelia> rakudo-moar 24d6c6: OUTPUT: «True␤»

[21:32] <ipatrol> I'm not sure what semantics assign which bot to which statement

[21:33] <TEttinger> I think m: goes to camelia always, not sure how evalable6 figured out I pasted code

[21:33] *** headcase joined
[21:33] <ipatrol> TEttinger: probably using the `say`

[21:33] <TEttinger> say say

[21:33] <ipatrol> say 'Happy';

[21:33] <evalable6> ipatrol, rakudo-moar 24d6c66f3: OUTPUT: «Happy»

[21:33] <TEttinger> say say 0;

[21:33] <evalable6> TEttinger, rakudo-moar 24d6c66f3: OUTPUT: «0␤True»

[21:34] <gfldex> another ENODOC

[21:34] *** mr-foobar left
[21:34] <ipatrol> It might try to evaluate everything of that form, and just remain silent if it gets a syntax error

[21:35] <ipatrol> say <STDIN>;

[21:35] <evalable6> ipatrol, rakudo-moar 24d6c66f3: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/sQEiG4Wrx7␤Unsuppo…»

[21:35] <evalable6> ipatrol, Full output: https://gist.github.com/c45dab4405f075bc744b1d52e4da1365

[21:35] <ipatrol> nopu

[21:36] <ipatrol> say <STDIN>

[21:36] <evalable6> ipatrol, rakudo-moar 24d6c66f3: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/jufkdMXG5H␤Unsuppo…»

[21:36] <evalable6> ipatrol, Full output: https://gist.github.com/1857f7551593864e64c0103f78166eaa

[21:36] <ipatrol> no idea then

[21:37] *** mr-foobar joined
[21:37] <geekosaur> evalable6 takes lines that it thinks "look like" perl 6 code. but it ignores anything specifically directed to another bot with a prefix

[21:38] *** headcase left
[21:39] *** nadim joined
[21:39] *** headcase joined
[21:41] *** leont left
[21:43] <AlexDaniel> say you start your message with “say”, it shouldn't eval, right?

[21:43] <AlexDaniel> ;)

[21:43] <AlexDaniel> because magic

[21:44] <ipatrol> say "I just wanna run"

[21:44] <evalable6> ipatrol, rakudo-moar 24d6c66f3: OUTPUT: «I just wanna run»

[21:44] <AlexDaniel> actually, evalable calculates the ratio of non-\w characters in a message, and if there are too many, then it's probably code

[21:44] <ipatrol> say I saw a man say "desu"

[21:45] <AlexDaniel> ^ here we have more regular letters, so maybe it's not code

[21:45] <AlexDaniel> say I saw a man say "d““e”s”u"

[21:45] <ipatrol> say <I> saw <a> man? !say "desu"

[21:45] <evalable6> ipatrol, rakudo-moar 24d6c66f3: OUTPUT: «(exit code 1) 04===SORRY!04=== Error while compiling /tmp/GSzSnIPyV2␤Two ter…»

[21:45] <evalable6> ipatrol, Full output: https://gist.github.com/dec2122d6d5583a29bac76ef5c2297c7

[21:45] <AlexDaniel> well, you get the idea :) fun stuff

[21:46] <AlexDaniel> https://github.com/perl6/whateverable/blob/daeee06e3eb1a85068b587961c52924f1ca024d6/bin/Evalable.p6#L42-L54

[21:46] <AlexDaniel> ^ code that does it

[21:47] <AlexDaniel> and here's what does the trick: $0.chars / $0.comb(/<-alpha -space>/) ≤ 10

[21:48] *** headcase left
[21:50] <ipatrol> so it only works on "say", intentionally omits "say I", omits anything that ends in a period, question mark, or exclamation point, automatically operates on `say I "..."`, and otherwise requires a word/nonword ratio of 10 or less

[21:50] <ipatrol> * automatically operates on `say "..."`

[21:53] *** headcase joined
[21:57] *** headcase left
[21:59] *** Skarsnik_ joined
[21:59] *** headcase joined
[22:00] *** pecastro left
[22:02] *** Skarsnik left
[22:02] *** pmurias left
[22:02] *** pmurias_ left
[22:03] *** headcase left
[22:03] *** mr-foobar left
[22:04] *** mr-foobar joined
[22:07] *** headcase joined
[22:08] *** setty1 left
[22:10] *** Skarsnik_ left
[22:19] *** pecastro joined
[22:20] *** Cabanossi left
[22:23] *** Cabanossi joined
[22:24] *** headcase left
[22:27] *** MasterDuke joined
[22:30] *** erdic left
[22:35] *** pecastro left
[22:36] *** nadim left
[22:42] *** okl left
[22:53] *** espadrine left
[22:54] <Geth> ¦ whateverable: a9d9697df2 | (Aleks-Daniel Jakimenko-Aleksejev)++ | bin/Evalable.p6

[22:54] <Geth> ¦ whateverable: Add ELI5 description for code detection

[22:54] <Geth> ¦ whateverable: 

[22:54] <Geth> ¦ whateverable: ipatrol++

[22:54] <Geth> ¦ whateverable: review: https://github.com/perl6/whateverable/commit/a9d9697df2

[22:54] <AlexDaniel> ipatrol: thanks :) ↑

[22:57] <Geth> ¦ whateverable: 1e5270241c | (Aleks-Daniel Jakimenko-Aleksejev)++ | bin/Evalable.p6

[22:57] <Geth> ¦ whateverable: Explain how we got there

[22:57] <Geth> ¦ whateverable: review: https://github.com/perl6/whateverable/commit/1e5270241c

[23:01] <timotimo> i think i found a tiny buglet in the permutations iterator

[23:01] <timotimo> it uses $b, which is a lexical in the outer scope, inside the iterator class

[23:01] <timotimo> since classes aren't closures, that'll give bogus values after the first use

[23:03] <MasterDuke> can you show an example where it breaks?

[23:05] *** khw joined
[23:07] <timotimo> doesn't look like i can

[23:08] *** MatrixDaniel is now known as AelxDnaiel

[23:09] *** pecastro joined
[23:13] *** headcase joined
[23:17] *** headcase left
[23:18] *** grondilu joined
[23:19] <grondilu> in S14 I read I should be able to do '$fido does Wag($tail)' but I can't get it to work.

[23:20] <grondilu> m: role Dog { has $.tail }; my $dog does Dog($)

[23:20] <camelia> rakudo-moar 24d6c6: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in typename; couldn't find final ')'␤at <tmp>:1␤------> 3le Dog { has $.tail }; my $dog does Dog(7⏏5$)␤»

[23:20] <grondilu> m: role Wag { has $.tail }; say class Dog does Wag($) {}.new

[23:20] <camelia> rakudo-moar 24d6c6: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in typename; couldn't find final ')'␤at <tmp>:1␤------> 3 { has $.tail }; say class Dog does Wag(7⏏5$) {}.new␤»

[23:21] <grondilu> m: role Wag { has $.tail }; say class Dog does Wag(my $tail) {}.new

[23:21] <camelia> rakudo-moar 24d6c6: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in typename; couldn't find final ')'␤at <tmp>:1␤------> 3 { has $.tail }; say class Dog does Wag(7⏏5my $tail) {}.new␤»

[23:21] <grondilu> what am I missing?

[23:21] *** Rawriful left
[23:21] <timotimo> grondilu: don't think that's a thing we have

[23:22] <timotimo> there's only parametric roles

[23:22] *** headcase joined
[23:23] <jnthn> grondilu: Confusing does trait with does infix, and iirc it's only `but` that does that magic anyway

[23:24] <timotimo> oooooh, *that*

[23:24] <grondilu> A role applied with "does" may be parameterized with an initializer in

[23:24] <grondilu>        parentheses, but only if the role supplies exactly one attribute to the

[23:24] <grondilu>        mixin class

[23:25] <grondilu> meh, *

[23:26] <jnthn> Maybe the synopses is unclear. I wrote chunks of it, sorry if so. But I at least know what it's meant to mean, and that certainly only is talking about the infix.

[23:27] <grondilu> I tried the infix too though

[23:28] <grondilu> m: role Dog { has $.tail }; my $dog; $dog does Dog($)

[23:28] <camelia> rakudo-moar 24d6c6: OUTPUT: «Unexpected named argument 'value' passed␤  in block <unit> at <tmp> line 1␤␤»

[23:28] <jnthn> Yeah, I'm a bit confused in that I was sure that only applied to `but`

[23:28] <grondilu> m: role Dog { has $.tail }; my $dog; $dog but Dog($)

[23:28] <camelia> rakudo-moar 24d6c6: OUTPUT: «Unexpected named argument 'value' passed␤  in block <unit> at <tmp> line 1␤␤»

[23:28] <jnthn> m: role Dog { has $.tail }; my $dog; $dog but Dog('foo')

[23:28] <camelia> rakudo-moar 24d6c6: OUTPUT: «Unexpected named argument 'value' passed␤  in block <unit> at <tmp> line 1␤␤»

[23:28] <jnthn> oh!

[23:28] <jnthn> Of course

[23:29] <jnthn> A mixin has to be into an object

[23:29] <jnthn> m: role Dog { has $.tail }; my $dog = Any.new; $dog but Dog('foo')

[23:29] <camelia> rakudo-moar 24d6c6: ( no output )

[23:29] <jnthn> m: role Dog { has $.tail }; my $dog = Any.new; $dog does Dog('foo')

[23:29] <camelia> rakudo-moar 24d6c6: ( no output )

[23:29] <grondilu> ok

[23:29] <jnthn> Error reporting should be better there.

[23:29] <grondilu> it actually makes sense

[23:29] <jnthn> And yeah, it's right about it working on does, it seems

[23:30] <jnthn> Guess it can :)

[23:31] *** margeas left
[23:34] *** benchable6 left
[23:35] *** benchable6 joined
[23:40] *** headcase left
[23:46] *** raschipi joined
[23:52] *** headcase joined
[23:53] *** headcase left
[23:58] *** headcase joined
