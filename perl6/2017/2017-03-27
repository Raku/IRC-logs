[00:00] <agentzh> otherwise we have to stick with $!foo for all those containers for optimal perforance.

[00:00] <agentzh> *performance

[00:00] *** lukaramu_ left
[00:00] <agentzh> because the compiler cannot generally avoid array/hash copying with the semantics dictate so.

[00:01] <raschipi> The semantics don't dictate that at all.

[00:01] <agentzh> i mean the default semantics in new() for @.foo and %.bar.

[00:01] <raschipi> I said above, it's possible to pass things as copies, or to alias them, both ro and rw.

[00:01] <agentzh> it's a value copying instead of binding.

[00:02] <raschipi> Well, the default signature for 'new' is made to enforce a bit of hygiene. Especially because there are modules that use simple classes to do parallel computation.

[00:03] <agentzh> yes, you said that. my point is that writing a generic custom version of new() would require MOP which might void any performance benefits if the compiler is not smart enough to optimize that away and writing specialized version of new() for every class is too much a burden for p6 programmers.

[00:04] <agentzh> that's why i'm proposing the `if ref` attribute trait.

[00:04] <raschipi> It doesn't require messing with the MOP. Just write a class and inherit from that. Can be done directly.

[00:04] <raschipi> You don't need to change Mu's new. Write a new one.

[00:04] <agentzh> but it need to know what attributes each class has and which are containers and etc.

[00:04] <agentzh> *needs

[00:04] <raschipi> And then inheritance makes sure every other class get's it.

[00:05] <raschipi> Look at how the existing Mu's new does it.

[00:05] <raschipi> It can build any object, doesn't it?

[00:06] <agentzh> mind to give me a hint on which rakudo file i should look at? ;)

[00:06] <raschipi> It uses named parameters for it. If you put a parameter that doesn't exist, it will fail because of missing parameter.

[00:08] <agentzh> i see it only contains a single call: nqp::invokewithcapture(nqp::findmethod(self, 'bless'), nqp::usecapture())

[00:08] <agentzh> am i looking at the right place?

[00:08] <raschipi> https://github.com/rakudo/rakudo/blob/nom/src/core/Mu.pm

[00:09] <agentzh> seems like most of the logic is in BUILDALL, right?

[00:09] <agentzh> nqp stuff all over that method.

[00:10] <agentzh> raschipi: i cannot use nqp in my p6 code. so what's my new() method will look like then?

[00:10] <agentzh> *what

[00:12] <agentzh> speaking of all those nqp::* calls which seem to construct some kind of AST structure, maybe you guys can use some macro language to make that Mu.pm file look much nicer?

[00:13] <agentzh> like Haskell's QuasiQuote.

[00:13] <MasterDuke> agentzh: may be relevant, quote from timotimo over in #moarvm today, "in the future, we'll actually generate a proper code object for executing the buildplan. i tried to do that already, but i got quite mysterious errors"

[00:13] <agentzh> MasterDuke: oh, that sounds very interesting.

[00:13] <MasterDuke> we were talking about it, but for completely different reasons

[00:13] <MasterDuke> (than you are)

[00:13] <agentzh> k

[00:14] <agentzh> MasterDuke: so what's your opinion on my "is ref" proposal?

[00:14] <agentzh> just want to know if it's a horrible idea.

[00:14] <agentzh> :)

[00:15] <raschipi> MasterDuke: Macros is comming, but it's complicated and will take time.

[00:15] <MasterDuke> agentzh: i'm afraid i don't know enough (about OO, P6's MOP, etc) to even have an opinion

[00:15] <agentzh> raschipi: oh really?

[00:15] <raschipi> We want something as powerful as Lisp has.

[00:15] <agentzh> raschipi: sweet! where can i find the design doc?

[00:15] *** pmurias left
[00:15] <MasterDuke> agentzh: i'd mention it over in #perl6-dev to jnthn and lizmat, see what they have to say

[00:15] <agentzh> MasterDuke: okay, thank you all the same.

[00:15] <raschipi> People think Lisp has modifiable syntax as Perl6 has, but it's all macros.

[00:16] <agentzh> MasterDuke: sounds cool.

[00:16] <agentzh> thanks!

[00:16] <MasterDuke> agentzh: pretty much all the macro work is being done by masak, in his 007 repo

[00:16] <agentzh> url?

[00:16] <raschipi> agentzh: I don't know enough to help you more, you'll need to ask again some other time. I was just helping you understand what's going on.

[00:16] <agentzh> raschipi: thank you.

[00:16] <raschipi> np

[00:17] <MasterDuke> https://github.com/masak/007

[00:20] <MasterDuke> agentzh: it might be nice to see a couple line example of what you have to do now, and what it would look like with your new trait

[00:22] <raschipi> Anyway, "new" is hygienic by design. Monitors and Actors (https://github.com/jnthn/oo-monitors, https://github.com/jnthn/oo-actors) need it and it's important to make those easier to use than to avoid a few copies.

[00:23] *** rburkholder left
[00:24] <raschipi> Anyway, how many objects are you building?

[00:24] *** TimToady left
[00:24] <raschipi> Aren't you making premature optimization? Have you measured the time it takes to copy the Arrays to be significant?

[00:25] <agentzh> raschipi: i'm building a compiler

[00:25] <agentzh> so there is a lot of objects (for AST nodes)

[00:25] *** TimToady joined
[00:25] <agentzh> we'd like to reuse the Array objects already allocated by the parser in the AST nodes.

[00:26] <agentzh> instead of doing copy and new allocations.

[00:26] <agentzh> there's a lot of such things which can not be ignored.

[00:26] <raschipi> Why do you need another compiler?

[00:26] <agentzh> the overhead of dynamic allocations and data copying already outweight the overhead of parsing itself.

[00:27] <agentzh> not general purpose compilers, but DSL compilers for high performance web gateways.

[00:27] <agentzh> used by CDN and ISP vendors.

[00:27] <raschipi> Write a grammar and be done with it.

[00:28] <agentzh> it has to be an optimizing compiler.

[00:28] <agentzh> so an AST is a must.

[00:28] <raschipi> The grammar will giv you the AST.

[00:29] <agentzh> not the one we really need.

[00:29] <agentzh> the algorithms are complicated.

[00:29] <raschipi> Write a grammar that builds the AST you need.

[00:29] <agentzh> OO makes the AST much more useful.

[00:30] <raschipi> Yeah, make the grammar build the AST with objects.

[00:30] <agentzh> otherwise i'll end up with a lot of similar but different "copying rules" as found in a typical Haskell based compiler.

[00:30] <raschipi> The Grammar calls arbitrary code when it matches, make that return objects.

[00:31] <agentzh> raschipi: perl 6's grammar engine is not so optimal due to its aggressive allocations of $/ Match objects.

[00:31] <agentzh> so we are using our own much faster grammar engine instead.

[00:32] <raschipi> I guess it would be more time-efficient to make Perl6's engine work better than writing another one.

[00:32] <raschipi> Because you'll have others helping you.

[00:33] <raschipi> Instead of fighting the language, work with it.

[00:33] <hobbs> where are you getting the idea that it's not already written?

[00:34] *** aborazmeh joined
[00:34] *** aborazmeh left
[00:34] *** aborazmeh joined
[00:34] *** cpage_ left
[00:34] <agentzh> raschipi: our engine is already 30x faster with real world input than rakudo's one since it's much simpler. it would be much harder to get similar speedup in rakudo.

[00:35] <agentzh> but anyway, thank you for your suggestion.

[00:36] <agentzh> it's a much simpler grammar engine, using the rule syntax of Damion's Parse::RecDescent and Ingy dot Net's Pegex.

[00:36] <agentzh> instead of supporting the perl 6 regex syntax.

[00:36] <agentzh> the latter is much more complicated.

[00:36] <agentzh> (and also much more powerful, of course)

[00:37] <raschipi> The idea is to make the grammar engine capable of doing all of this work. It's not there yet.

[00:37] <agentzh> well, anyway, we'll try implementing the "is ref" trait in our own perl 6 dialect compiler, fanlang, and see how it goes.

[00:38] <agentzh> fanlang is already mature enough to be used to build a DSL compiler.

[00:39] <raschipi> Nice. Make sure to bring any improvements you make to #Perl6-dev to take maintenece off your back (if it's accepted).

[00:40] <agentzh> raschipi: already dropped a note in #perl6-dev. thanks for the reminder.

[00:40] <raschipi> I guess you'll be rewriting "new" anyway, since it will have to know about "is ref" attributes.

[00:41] <agentzh> well, it would be inside the compiler.

[00:41] <agentzh> instead of on the language level.

[00:42] <raschipi> "new" isn't at the language level. It's a normal method.

[00:42] <agentzh> i know, it's different in our own perl 6 dialect :)

[00:45] *** cpage_ joined
[00:46] <raschipi> They were discussing how people have problems because they took shortucts by using libuv and now direct access to STDOUT and STDIN was mangled when using NativeCall. Perl6 has to be fast but can't just define "new" as sytax like that, because people would be confused when trying to redefine it.

[00:47] <raschipi> Anyway, they make it easy to do it if you want.

[00:50] *** cpage_ left
[01:25] *** Cabanossi left
[01:28] *** Cabanossi joined
[01:30] <raschipi> agentzh: How is the name of your project? People always come and ask for big projects in Perl6, so yours is a good example.

[01:34] *** cyphase joined
[01:37] <AlexDaniel> raschipi: fanlang?

[01:37] <raschipi> That's his slang, and what about the web-scale DSL compiler?

[01:45] *** ilbot3 left
[01:47] *** kent\n joined
[01:48] *** ilbot3 joined
[01:48] *** ChanServ sets mode: +v ilbot3

[01:51] <agentzh> raschipi: the largest p6 project i wrote is called edgelang-p6, 8K LOC. it's not open sourced though.

[01:51] <agentzh> and my perl 6 dialect compiler is called fanlang, the compiler itself is written in perl 5, and it's also not open sourced yet.

[01:51] <raschipi> There's a guy running a radio statio with 100K just of public released code.

[01:52] * agentzh wonders who long it would take to compile that p6 project.

[01:52] <AlexDaniel> agentzh: this sounds very interesting

[01:53] <agentzh> AlexDaniel: thanks

[01:53] <AlexDaniel> … but it will be even more interesting once I see the code :)

[01:53] <agentzh> AlexDaniel: we'll sell licenses of the fanlang compiler as part of our OpenResty Edge product.

[01:53] <AlexDaniel> ouch…

[01:54] <agentzh> and we'd like to provide free personal licenses to official perl 6 team members.

[01:54] <AlexDaniel> 🤷

[01:54] <MasterDuke> well, i don't think it's 100k in one project, but 100k lines in many modules, though most of which were inspired by his needs

[01:54] <agentzh> MasterDuke: then that makes much more sense, otherwise it won't be debuggable with rakudo :)

[01:54] <agentzh> mine is a single program.

[01:55] <agentzh> and 8K already makes it not debuggable with rakudo on my top-spec mid-2015 macbook pro 15 inch laptop.

[01:55] <agentzh> *8K LOC

[01:55] <agentzh> so i only managed to make my edgelang-p6 project compile with rakudo, but never pass the test suite.

[01:56] <raschipi> Putting things in modules gets them pre-compiled.

[01:56] <MasterDuke> rakudo itself is 52k, and that takes 90s to compile on my machine

[01:56] <agentzh> raschipi: precompiling is still too slow.

[01:57] <agentzh> i tried everything.

[01:57] <agentzh> the fastest approach is to concatenate all the pm6 files into a single p6 script.

[01:57] <agentzh> that's the fastest.

[01:57] <agentzh> much faster than a typical incremental compilation using .precomp.

[01:57] <AlexDaniel> MasterDuke: huh! Wait what? If you run “make”, it takes only 90s?

[01:57] <agentzh> but still taking 6 sec.

[01:58] <raschipi> It's by design: https://www.xkcd.com/303/

[01:58] <MasterDuke> AlexDaniel: the compiling CORE.setting part does. a full make is longer

[01:58] <AlexDaniel> ah, okay

[01:59] <agentzh> lol

[01:59] <agentzh> raschipi: that picture is fun.

[01:59] *** wamba joined
[02:00] <llfourn> agentzh: I just tested spitsh precomp. It takes 14s :<

[02:00] <agentzh> so we quickly ported our edgelang-p6 over to our perl 6 dialect, fanlang.

[02:00] <agentzh> it's finally passed the whole test suite of edgelang-p5.

[02:02] <agentzh> llfourn: ouch.

[02:03] <llfourn> It doesn't bother me so much. A bit like the XKCD. I need time to think inbetween changes and sip my drink.

[02:03] <llfourn> it runs fast enough at runtime that it doesn't bother me

[02:04] <llfourn> although it's still slow at runtime because I'm not able to precomp my spit code yet :\

[02:04] <llfourn> but once i can it should be < 1s to compile a shell script from spit code.

[02:06] <raschipi> Languages that compile ahead of time usually just assume they can take as much time as they want, programmers don't mind it.

[02:07] <raschipi> Perl5 had to compile fast, P6 not so.

[02:08] <llfourn> yep!. Though I wouldn't complain we were able to shave a 50% off the compile time.

[02:09] <raschipi> llfourn: It will actually get longer as time goes on, because more will be added to the optimizer.

[02:11] <agentzh> llfourn: when i'm debugging problems, i need instant feedback for every single change i make :)

[02:11] <agentzh> it's all about interactions, not much thinking needed in between.

[02:11] <agentzh> just edit, run test, edit, run test.

[02:11] <agentzh> quick small cycles.

[02:11] <agentzh> test driven development :)

[02:11] <llfourn> raschipi: hopefully nqp->moar becomes fater to account for some of that :)

[02:12] <agentzh> without this, we cannot build fanlang from scratch to the current shape in just 4 months.

[02:12] <agentzh> fortunately perl compiles very fast.

[02:12] <agentzh> *perl 5

[02:12] <agentzh> some bugs are very deep and obscure

[02:13] <agentzh> *were

[02:13] <raschipi> I guess it could be configurable, like a -O0 would be fast.

[02:13] <agentzh> nope, i tried, it's not really faster.

[02:13] <agentzh> maybe a little bit.

[02:13] <agentzh> the optimizer is never the bottleneck for me.

[02:13] <raschipi> Yeah, it could be made faster, I mean.

[02:13] <MasterDuke> TimToady has said he's going to work on the grammar engine soonish, that should help speed up compiling

[02:14] <agentzh> raschipi: got it.

[02:15] <MasterDuke> agentzh: and i'm with you on the tiny change, compile, tiny change, compile loop

[02:15] <raschipi> Let's hope Timtoady can make it fast enough so that it could solve agentzh use case.

[02:16] <raschipi> Instead of having to write a new parser, get one fast enough from the start.

[02:17] <llfourn> agentzh said that fanlang will be able to parse itself soon I think so i guess that won't be of concern.

[02:17] <llfourn> but it sure would help me!

[02:17] <llfourn> though I've learned to have longer edit cycles

[02:18] <TimToady> one has to backlog sometime :)

[02:18] <TimToady> but yeah, there's plenty we can do to get the parser faster

[02:19] <raschipi> TimToady: do you have an opinion about the "is ref" idea agentzh had above?

[02:20] <TimToady> haven't had a chance to backlog yet :)

[02:20] <TimToady> will look at it tomorrow

[02:20] <llfourn> (I hopefully convinced agentzh to change it to is raw)

[02:20] <MasterDuke> TimToady: also some more discussion about it in #perl6-dev

[02:20] <raschipi> I don't like "ref" too, P6 doesn't have references.

[02:21] <TimToady> well, or everything is a ref...

[02:21] <raschipi> When everything is a reference, nothing is a reference.

[02:21] <b2gills> The code to add a `is ref` (or `is raw`) to Rakudo is basically the same as it would be in a module

[02:21] <raschipi> It would be very confusing to have something being called a reference when every other thing is a reference too.

[02:22] <llfourn> b2gills: yeah we had this conversation in #perl6-dev. it definetly belongs in a module first.

[02:24] <b2gills> m: say +&trait_mod:<is>.candidates

[02:24] <camelia> rakudo-moar fa9aa4: OUTPUT: «59␤»

[02:25] <b2gills> llfourn: I backlogged there first

[02:25] * TimToady is too brainfogged to backlog tonight

[02:26] <TimToady> been kind of a tough week, what with one thing or another, and sunday is supposed to be a day of rest in my religion :)

[02:27] <llfourn> TimToady: rest well :)

[02:28] <BenGoldberg> The Sabbath is the day of rest for a few major religions ... now if only we could all agree on what day of the week it was ;)

[02:28] <MasterDuke> or even what rest is

[02:28] <llfourn> the simplest solution is to just make all of them.

[02:28] <TimToady> which day is not the important ting

[02:28] <TimToady> *th

[02:28] <llfourn> make it all of them*

[02:28] <BenGoldberg> llfourn++ ;)

[02:28] <TimToady> :)

[02:29] <hobbs> llfourn: that's what the robots-taking-our-jobs is for

[02:30] <agentzh> llfourn: yeah, i now think `is raw` is better given that we already have it in signatures.

[02:30] <BenGoldberg> Once upon a time, you were supposed to do this thing called "recreation" ... which *originally* meant studying creation.

[02:30] <agentzh> TimToady: ingy dot net is now working with me on our perl 6 dialect compiler! :D

[02:31] <agentzh> TimToady: it's his full time job now *grin*

[02:31] <llfourn> hopefully the society these busy robots create leave us something to do :)

[02:31] <agentzh> TimToady: and it's also mine ;)

[02:32] <TimToady> the more, the merrier  :)

[02:32] <agentzh> lol, definitely.

[02:32] <agentzh> our team has 5 engineers now.

[02:32] <agentzh> all working on perl 6 or writing in perl 6.

[02:32] <agentzh> or both!

[02:33] <agentzh> the 6th one is joining us tomorrow.

[02:33] <agentzh> *grin*

[02:33] <skids> note "has $.foo is rw" and "method new ($foo is rw)" do not do the same thing.

[02:34] <agentzh> skids: yeah, i was aware of that.

[02:34] <agentzh> just arguing for "symmetry".

[02:34] <agentzh> like in quantum mechanics.

[02:35] <b2gills> Is the regex design of Funlang more similar to regexes in Perl 5 or Perl 6, or to BNF/ANTLR

[02:35] <agentzh> b2gills: right now, we use damion's Parse::RecDescent's rule syntax with the perl 5 regex syntax.

[02:35] <agentzh> it's a mixture.

[02:35] <agentzh> like in Damion's CPAN module.

[02:35] <agentzh> we also employ Ingy dot Net's Pegex's + and - notations into the mix.

[02:36] <agentzh> they are handy.

[02:36] <agentzh> we have a complete tested fanlang program here: https://github.com/agentzh/perl-parsing-library-benchmark/blob/master/calc.fan

[02:36] <agentzh> for arith calculator.

[02:36] <agentzh> and a typical benchmark result is here: https://github.com/agentzh/perl-parsing-library-benchmark#typical-benchmark-results

[02:37] <agentzh> comparing to rakudo/pegex/parse::recdescent/etc

[02:37] *** obfusk left
[02:37] <agentzh> the largest fanlang program we are currently building is a full fledged DSL compiler called edgelang for CDN/gateway platforms.

[02:38] <agentzh> the edgelang compiler in fanlang currently has ~8K LOC.

[02:38] <agentzh> still hacking on it.

[02:38] *** obfusk joined
[02:39] <raschipi> So you have a program that is compiled by edgeland that is compiled by fanlang that is compiled by Perl5?

[02:39] <agentzh> haha, yes.

[02:39] <raschipi> does fanlang passes roast?

[02:40] <agentzh> edgelang-fan test suite in action: https://pbs.twimg.com/media/C70tjqLVMAMi3QC.jpg:large

[02:40] <b2gills> and Perl 5 is compiled by C

[02:40] <agentzh> note the first step is "fan -c bin/edgelang.fan"

[02:40] <llfourn> there is no way it could pass roast

[02:40] <agentzh> the fan utility is a perl 5 compiler that compiles fanlang into lua.

[02:40] <llfourn> does fanlang have :=?

[02:40] <agentzh> then we use perl to test the resulting lua program.

[02:40] <agentzh> llfourn: yes!

[02:41] <llfourn> cool.

[02:41] <TimToady> roast is about doing it right before we do it fast; it will be interesting to see if the two efforts ever converge...

[02:41] <agentzh> TimToady: yeah, maybe.

[02:41] <agentzh> TimToady: we've been using rakudo as a reference impl in fanlang's test scaffold.

[02:42] <raschipi> have you tried to run roast to see how much can it do?

[02:42] *** noganex joined
[02:42] <agentzh> raschipi: hope, since it requires Test.pm to fully work.

[02:42] <agentzh> *Test.pm6

[02:42] <llfourn> agentzh: you don't have a Test.fan yet :^)?

[02:42] <agentzh> we'll write our own fudge script to port the roast test cases over to fanlang's test scaffold, maybe.

[02:43] <agentzh> we are using TestML in fanlang's test suite

[02:43] <b2gills> You could rig up a minimal test.pm for some of the simpler tests

[02:43] <llfourn> agentzh: for spit I wrote Test.spt https://github.com/spitsh/spitsh/blob/master/resources/core-lib/Test.spt

[02:44] <raschipi> So, you do test driven development for fan, but not in fan?

[02:45] *** noganex_ left
[02:45] <b2gills> It would be helpful to know which tests accidentally implementation specific

[02:47] *** agentzh left
[02:47] *** agentzh joined
[02:53] *** wamba left
[02:56] <raschipi> We should actually take the depedency ROAST has on Test.pm, not ask people to reimplement it.

[02:57] <raschipi> Ship a simple one.

[03:02] *** gdonald left
[03:03] *** gdonald joined
[03:10] *** Cabanossi left
[03:11] *** Cabanossi joined
[03:24] *** vendethiel- joined
[03:25] *** vendethiel left
[03:28] *** BenGoldberg left
[03:29] *** khw left
[03:34] *** xtreak joined
[03:55] *** Cabanossi left
[03:56] *** Cabanossi joined
[03:58] *** mr-foobar left
[04:03] *** AlexDaniel left
[04:12] *** raschipi left
[04:42] *** cpage_ joined
[04:49] *** aborazmeh left
[04:49] <agentzh> b2gills: yeah, maybe. will try to find a summer intern student to do that for us.

[04:49] <agentzh> we use Perl 6's Test::Base/TestML to drive our perl 6 test suite.

[04:49] <agentzh> it does not need a Test.fan at all.

[04:49] <agentzh> and much nicer to work with.

[04:51] <agentzh> something like this: https://gist.github.com/agentzh/5154642d55a6727c653858849b0698cf

[04:51] <agentzh> sorry, i mean Perl 5's Test::Base/TestML

[04:55] *** Cabanossi left
[04:57] *** Cabanossi joined
[05:01] *** curan joined
[05:01] <llfourn> agentzh: I'm a *fan* of having the test suite of a language written in the language itself.

[05:01] *** ChoHag left
[05:02] <llfourn> even when you get it to bootstrap itself it will still need p5 to run the test suite.

[05:05] <agentzh> llfourn: not really, the author of Test::Base and TestML will soon re-implement TestML in fanlang.

[05:05] <agentzh> the test suite should be declarative and data driven, it does not matter what language is used to implement it.

[05:05] <agentzh> and we can still use only one language when it's bootstrapped.

[05:05] <agentzh> it's just not so relevant.

[05:06] <agentzh> TestML is a DSL

[05:06] <agentzh> the implementation languages of the test scaffold does not really mater.

[05:06] <agentzh> that's the beauty of it.

[05:06] <agentzh> you have the freedom to use anything to test anything else.

[05:07] <llfourn> *nods*

[05:07] <agentzh> it's a burden to require a Test.pm6 or Test.fan when the compiler were just started and only supported basic functions and operators.

[05:07] <agentzh> even a simplified one is a burden since you have to add support for modules and use to the compiler.

[05:07] <agentzh> which is not trivial.

[05:07] <agentzh> fanlang got its module and compunit support just in last month IIRC.

[05:08] *** xinming left
[05:08] <llfourn> that's true. With spitsh I just included builtin &ok, &is etc in the core

[05:08] <llfourn> until I had built a basic module system.

[05:13] <agentzh> the TestML approach follows the "test the simplest thing that could possibly work" guideline.

[05:15] <agentzh> and you can test everything easily from outside, from stdout output, stderr output, to process exit code and command-line options.

[05:15] <agentzh> everything.

[05:15] *** mr-foobar joined
[05:15] <agentzh> these are kinda hard or requires special tricks to test inside the user program being tested.

[05:16] <llfourn> is each test starting a new compilation?

[05:16] <agentzh> yes

[05:16] <agentzh> that's isolation

[05:17] <agentzh> to minimize unrelated stuff.

[05:17] <llfourn> I guess that's preferable sometimes :)

[05:17] *** mr-fooba_ joined
[05:18] <agentzh> well, fanlang compiles fast anyway :)

[05:18] <llfourn> but I quite often find bugs because tests that shouldn't affect each other end up doing just that.

[05:18] *** mr-fooba_ left
[05:19] <agentzh> llfourn: well, you can merge them together in the test scaffold. it's all data.

[05:19] <agentzh> not code.

[05:19] <agentzh> so you have all the freedom to shuffle, to combine, to run in a different ways.

[05:19] <agentzh> you have choices.

[05:19] <llfourn> yeah that's handy

[05:19] *** mr-foobar left
[05:20] <agentzh> thanks to data driven testing :)

[05:20] *** mr-foobar joined
[05:20] <agentzh> you can also run a single test block in isolation by adding a --- ONLY section to it.

[05:21] <agentzh> it's very handy for debugging test failures.

[05:21] <agentzh> no need to comment out anything in the same file.

[05:21] *** mr-foobar left
[05:21] <agentzh> and do not need to worry about unnecessary side effects of previous test cases.

[05:21] <agentzh> since every test block (or test case) is self-contained and standalone.

[05:22] <llfourn> I definitely see the advantage of that :)

[05:22] <agentzh> we've also been using the same approach to test our nginx C modules and lua libraries: https://openresty.gitbooks.io/programming-openresty/content/testing/

[05:22] <agentzh> just in case you are interested.

[05:22] <agentzh> it can be used to test *anything*.

[05:22] <agentzh> i really like it.

[05:23] *** mr-foobar joined
[05:23] <llfourn> thanks, will check it out.

[05:25] *** Cabanossi left
[05:25] *** cyphase left
[05:26] *** jsoo joined
[05:27] *** domidumont joined
[05:27] *** Cabanossi joined
[05:28] *** jsoo left
[05:29] *** xtreak left
[05:29] *** xtreak joined
[05:29] *** cpage_ left
[05:30] *** cpage_ joined
[05:31] *** mr-foobar left
[05:32] *** mr-foobar joined
[05:32] *** xtreak left
[05:32] *** xtreak joined
[05:33] *** mr-foobar left
[05:33] *** domidumont left
[05:34] *** mr-foobar joined
[05:34] *** mr-foobar left
[05:39] *** mr-foobar joined
[05:40] *** mr-foobar left
[05:44] *** tojo joined
[05:45] *** mr-foobar joined
[05:47] *** cyphase joined
[05:48] *** mr-foobar left
[05:49] *** mr-foobar joined
[05:51] *** RabidGravy joined
[05:51] *** cyphase left
[05:52] *** mr-foobar left
[05:53] *** gdonald left
[05:54] *** gdonald joined
[05:57] *** wamba joined
[05:59] *** skids left
[06:00] *** cpage_ left
[06:03] *** mr-foobar joined
[06:11] *** Cabanossi left
[06:12] *** Cabanossi joined
[06:12] <RabidGravy> Boom!

[06:14] *** domidumont joined
[06:25] *** mr-foobar left
[06:25] *** mr-foobar joined
[06:25] *** mr-foobar left
[06:26] <Woodi> yo :)

[06:27] <Woodi> agentzh: i think would be nice if you include all features nqp have. maybe someone will port rakudo onto fun lang :)

[06:28] <samcv> hi Woodi 

[06:28] *** astj_ joined
[06:28] *** astj left
[06:30] *** mr-foobar joined
[06:30] *** eroux left
[06:31] *** mr-foobar left
[06:31] <Woodi> agentzh: also: I think your current attitude is not quite good for busines: we don't care about you, we just care what we can take from you and we saying that pretty loud :)  remember who yours future users can be :) also as commercial entity you should donate to the community, at least expertise :)

[06:31] <Woodi> hallo samcv :)

[06:34] *** mr-foobar joined
[06:35] *** darutoko joined
[06:35] *** mr-foobar left
[06:35] *** mr-foobar joined
[06:36] *** mr-foobar left
[06:38] *** xinming joined
[06:41] *** kyan joined
[06:43] *** mr-foobar joined
[06:53] *** mr-foobar left
[06:53] *** mr-fooba_ joined
[07:01] *** koki1 left
[07:01] *** koki joined
[07:02] <samcv> wooooo i got ignorecase working

[07:02] <samcv> for ligatures. \o/

[07:02] <samcv> with regex at least

[07:03] <samcv> passes all the ignorecase.t tests :)

[07:04] *** xtreak left
[07:05] *** cpage_ joined
[07:06] *** mr-fooba_ left
[07:06] *** TEttinger left
[07:06] *** mr-foobar joined
[07:07] *** mr-foobar left
[07:07] *** mr-foobar joined
[07:08] *** mr-foobar left
[07:08] <samcv> exciting :) it will actually work properly finally. and when i do it right will hopefully make it faster too. at least that's the plan

[07:09] *** mr-foobar joined
[07:16] *** mr-foobar left
[07:16] *** mr-foobar joined
[07:21] *** mr-foobar left
[07:22] *** mr-foobar joined
[07:23] *** mr-foobar left
[07:25] *** Cabanossi left
[07:27] *** Cabanossi joined
[07:27] *** mr-foobar joined
[07:28] *** mr-foobar left
[07:28] *** jsoo joined
[07:28] *** mr-foobar joined
[07:29] *** mr-foobar left
[07:31] *** jsoo left
[07:31] *** sunnavy joined
[07:37] *** mr-foobar joined
[07:38] *** mr-foobar left
[07:38] *** mr-foobar joined
[07:38] <llfourn> samcv++ #faster

[07:39] <samcv> at least it now works properly. but won't commit until it's as fast as it was before

[07:39] <samcv> need to program a faster version of MVM_string_index_ignore_case

[07:41] <samcv> pretty fancy to have working expanding characters working though

[07:41] <samcv> atm only works at the very start of a string

[07:41] <samcv> m: say 'ﬆ' ~~ m:i/st/

[07:41] <camelia> rakudo-moar fa9aa4: OUTPUT: «｢ﬆ｣␤»

[07:41] <samcv> but if it's anywhere else it doesn't find it

[07:42] <llfourn> to me it's actually rather amazing that that works at all.

[07:43] <samcv> heh. :) that is one of the things i've been working on

[07:43] *** wamba left
[07:44] <Woodi> s/amazing/crazy/g ;)

[07:44] <samcv> it is a little tricky when some codepoints can be longer than others :P

[07:44] <samcv> but also awesome

[07:44] *** zakharyas joined
[07:45] *** bjz joined
[07:45] <llfourn> m: say "ﬆ" ~~ m/ST|st|sT|St/ # is this meant to work?

[07:45] <camelia> rakudo-moar fa9aa4: OUTPUT: «False␤»

[07:45] <samcv> some combinations of codepoints make up one grapheme. some graphemes can make up combinations of graphems when casefolded

[07:45] <samcv> :P

[07:45] <samcv> no llfourn only when you do ignorecase

[07:46] <samcv> m: say "ﬆ" ~~ m:i/ST/

[07:46] <camelia> rakudo-moar fa9aa4: OUTPUT: «｢ﬆ｣␤»

[07:46] <llfourn> so a case is more than just uppercase and lowercase but there is also ligature case?

[07:46] <samcv> uh

[07:46] <samcv> wel lowercase of ﬆ is ﬆ. but foldcase of ﬆ is st

[07:47] <llfourn> ah "foldcase".

[07:47] <samcv> some even can be 1 codepoint to 3 codepoints

[07:47] <llfourn> I am so glad that there are people brave enough to tackle this for me :D

[07:49] <samcv> yes, i hope my work can save other people time and effort and things just magically work :)

[07:49] *** mr-foobar left
[07:49] <Woodi> samcv: any chance automatic translation between languages be added ? that's only one thing that left after universal charset :)

[07:49] *** mr-foobar joined
[07:50] <samcv> this is my Grant proposal which will be published soon https://gist.github.com/samcv/121351d79e4b46a56e7c3efa3a7980b3

[07:50] *** mr-foobar left
[07:52] <samcv> also i think if i fully implement Unicode collation algorithm 'ﬆ' will also sort with 'st'

[07:52] <samcv> which is also ridiculous XD

[07:52] <Woodi> samcv++ :)

[07:52] <samcv> atm it passes all the unicode collation tests which are made up of single and not multiple codepoints. 

[07:53] <chansen_> Nice!

[07:54] *** mr-foobar joined
[07:55] *** abraxxa joined
[07:55] *** mr-foobar left
[07:59] *** espadrine joined
[08:01] *** koki left
[08:02] *** kybr left
[08:05] *** spider-mario left
[08:06] *** spider-mario joined
[08:11] *** robertle left
[08:11] <samcv> be back soon

[08:14] *** dakkar joined
[08:16] *** xtreak joined
[08:19] *** mr-foobar joined
[08:20] *** espadrine left
[08:25] *** Cabanossi left
[08:25] *** zakharyas left
[08:27] *** Cabanossi joined
[08:30] *** salva left
[08:31] *** wamba joined
[08:33] *** xtreak left
[08:38] <bolangi> I can remove the paragraphs from the wiki. Can someone else check if its still present in the Compile -h output?

[08:44] *** gdonald left
[08:44] <bolangi> oh, sorry

[08:44] *** gdonald joined
[08:50] *** mxco86 joined
[08:51] *** mr-foobar left
[08:54] *** mr-foobar joined
[08:54] *** Cabanossi left
[08:57] *** Cabanossi joined
[09:10] *** rindolf joined
[09:17] *** llfourn left
[09:25] *** Cabanossi left
[09:25] *** parv joined
[09:27] *** Cabanossi joined
[09:32] *** bjz left
[09:32] <Geth> ¦ ecosystem: bd1b37a6a0 | (Alexey Melezhik)++ | META.list

[09:32] <Geth> ¦ ecosystem: Update META.list

[09:32] <Geth> ¦ ecosystem: 

[09:32] <Geth> ¦ ecosystem: sparrowdo-sparrow-update canonical name for META file

[09:32] <Geth> ¦ ecosystem: review: https://github.com/perl6/ecosystem/commit/bd1b37a6a0

[09:33] *** zakharyas joined
[09:34] *** bjz joined
[09:36] *** kyan left
[09:37] *** xtreak joined
[09:38] *** xtreak left
[09:41] *** kybr joined
[09:43] *** lukaramu joined
[09:48] *** wamba left
[09:49] *** ugjka left
[09:52] *** ugjka joined
[09:53] *** wamba joined
[09:57] *** xtreak joined
[10:13] *** koki joined
[10:30] *** labster left
[10:38] *** xtreak left
[10:38] *** xtreak joined
[10:40] *** bjz_ joined
[10:41] *** bjz left
[10:45] *** xtreak left
[10:51] *** llfourn joined
[10:55] *** Cabanossi left
[10:56] *** Cabanossi joined
[11:02] *** xtreak joined
[11:02] *** rindolf left
[11:05] *** rindolf joined
[11:27] *** cosimo left
[11:31] *** xtreak left
[11:33] *** xtreak joined
[11:34] *** xtreak left
[11:38] *** AndyDee joined
[11:38] *** abraxxa left
[11:39] *** abraxxa joined
[11:40] *** Cabanossi left
[11:42] *** Cabanossi joined
[11:50] *** lukaramu_ joined
[11:52] *** Khisanth left
[11:53] *** lukaramu left
[11:58] *** Loops joined
[11:58] *** movl joined
[11:58] *** wamba left
[11:58] <Loops> Hi there, does anyone know what the forced-bool operator "so" is named for?  

[11:59] *** andrzejku joined
[11:59] <andrzejku> hi :)

[12:01] <jnthn> Loops: It's just the English word "so"; in phrases like "is that so?" you could pretty much replace the "so" with "true" :)

[12:01] *** wamba joined
[12:03] <andrzejku> jnthn: nice to see you

[12:03] <Loops> jnthn: thanks.  i find it a bit awkward, but i'll quickly forget about my feelings and get used to it i'm sure  (i'm fine with "ff" heh).  Thanks :-)

[12:03] *** cosimo joined
[12:04] <jnthn> Loops: Yeah, I found it the same at first, but it feels fairly natural by now. :)

[12:04] <jnthn> andrzejku: hi

[12:06] <parv> andrzejku, whenver I read your user id, "adjkerntz" pops up immediately (followed by re-reading of the user id)

[12:06] *** Khisanth joined
[12:06] <parv> adjkerntz: https://www.freebsd.org/cgi/man.cgi?query=adjkerntz&manpath=FreeBSD+11.0-RELEASE&arch=default&format=html

[12:10] <andrzejku> :)

[12:10] <andrzejku> jnthn: i got question fo ryou

[12:10] <andrzejku> jnthn: where do you learn how to write vm?

[12:10] <andrzejku> some books manuals

[12:15] <jnthn> andrzejku: Partly from courses when I was at university, partly by looking at existing VMs to see how they worked. Learned a good bit about GC from The GC Handbook (second edition).

[12:15] *** Wanderer68 joined
[12:15] <andrzejku> jnthn: huh I didn't have such courses have you one for example?

[12:17] <jnthn> andrzejku: The compiler courses - at least when I took them - went into the JVM some.

[12:17] *** raschipi joined
[12:18] <andrzejku> okay thnks :)

[12:18] <jnthn> The courses I took were http://www.cl.cam.ac.uk/teaching/1617/CompConstr/ and http://www.cl.cam.ac.uk/teaching/1617/OptComp/ - but years ago, they probably changed quite a bit. But think they post slides still

[12:18] <lizmat> https://www.amazon.com/Garbage-Collection-Handbook-Management-Algorithms/dp/1420082795   # the book

[12:20] <jnthn> Also I was lucky enough to be lectured on concurrency by one of the leading folks on lock-free algorithms, so I got a decent grounding in concurrency also :)

[12:20] <jnthn> Well, lock free data structures probably describes the work more accurately

[12:22] *** lichtkind__ is now known as lichtkind

[12:23] <jnthn> VMs are a bit like compilers in so far as you have to get really used to thinking about programs that work with programs, or, perhaps, get used to thinking about code as just another form of data.

[12:23] <lichtkind> jnthn if you need anything im still at university and am somewhat close to our compiler prof

[12:24] *** Cabanossi left
[12:24] <jnthn> As with compilers, trees and graphs show up all over the place.

[12:26] <lichtkind> jnthn and btw my mother send me somehting interesting about the castle you live under i can resent if you like

[12:27] *** Cabanossi joined
[12:27] <jnthn> lichtkind: Hm, interesting...well, it's nice to be able to tell visiting family something about it :)

[12:27] * lizmat has finished the P6W for now, but will be afk for the next 10 hours or so: will update to the latest news and post then

[12:27] <lichtkind> oh i forgot i was in czech :)

[12:28] <lichtkind> jnthn but i can translate it was not that much beside pictures

[12:28] <jnthn> lichtkind: Well, I can try to decode it, though my vocab is still on the small side :)

[12:39] *** perlpilot left
[12:40] *** sufrostico joined
[12:40] *** sufrostico left
[12:40] *** sufrostico joined
[12:41] <lichtkind> jnthn, no proplem i can skim it, you have to decode bugs all the time

[12:47] *** perlpilot joined
[12:50] <raschipi> Whay doesn't this: https://perlgeek.de/blog-en/perl-6/2017-013-inline-python-stacked.html appear in http://pl6anet.org/ ?

[12:51] <moritz> there seem to be a problem with pl6anet.org; the weekly news posts my lizmat++ didn't show up either

[12:53] *** mcmillhj joined
[12:54] *** cosimo left
[12:55] *** cosimo joined
[12:55] *** cosimo left
[12:56] *** cosimo joined
[12:58] *** chsanch joined
[13:00] <chsanch> Hi, I've managed to compile perl6 in the CHIP just activating a swap file :)

[13:01] *** cdg joined
[13:02] *** AlexDaniel joined
[13:02] *** cdg left
[13:03] *** cdg joined
[13:05] *** parv left
[13:06] <raschipi> chsanch: write a paper or a blogpost about it and bring us a link!

[13:11] <chsanch> raschipi: sure

[13:12] <raschipi> Also post it on #moarvm

[13:19] *** pmurias joined
[13:22] *** bjz_ left
[13:23] *** aborazmeh joined
[13:23] *** aborazmeh left
[13:23] *** aborazmeh joined
[13:27] *** itaipu joined
[13:29] *** tojo left
[13:29] *** Sound joined
[13:36] *** lukaramu__ joined
[13:37] *** cog_ joined
[13:38] *** cognominal left
[13:40] *** lukaramu_ left
[13:41] *** Cabanossi left
[13:42] *** Cabanossi joined
[13:48] *** aborazmeh left
[13:51] *** curan left
[13:51] *** wamba left
[13:55] *** wamba joined
[13:58] *** itaipu left
[14:07] *** gdonald left
[14:07] *** cdg_ joined
[14:07] *** gdonald joined
[14:07] *** cdg left
[14:12] *** vendethiel joined
[14:13] *** vendethiel- left
[14:15] *** itaipu joined
[14:16] <tyil> are there frameworks to make a json api in perl 6 yet?

[14:19] <raschipi> tyil: have a look https://modules.perl6.org/#q=json

[14:19] *** kurahaupo__ joined
[14:20] *** itaipu left
[14:20] <[Coke]> eco: json

[14:20] <[Coke]> buggable: eco json

[14:20] <buggable> [Coke], Found 21 results: JSON::Tiny, App::jsonv, JSON::RPC, JSON::JWT, JSON::Pretty. See https://modules.perl6.org/#q=json

[14:20] <tyil> plenty of modules to take care of the json part, but I was hoping for a complete framework, that also handles the database (using an ORM for instance) and routing

[14:20] <[Coke]> (same url)

[14:21] <[Coke]> buggable: eco DB

[14:21] <buggable> [Coke], Found 9 results: DB::Model::Easy, BSON, MongoDB, DBIish, DB::ORM::Quicky. See https://modules.perl6.org/#q=DB

[14:21] <[Coke]> (that said, it's quite possible we don't have quite what you're looking for yet) - you can always use Inline::Perl5 for glue

[14:22] <tyil> I might try my hand at assembling it myself, but as I have next to no p6 experience yet it would possibly be better if someone made something for it already, and this seemed the best place to ask

[14:23] <tyil> at fosdem 2016 there was a talk about a p5 web framework, maybe that was ported to p6, but I dont rememer the name of the fw anymore

[14:26] *** Cabanossi left
[14:26] *** itaipu joined
[14:26] <raschipi> Perl6 webframework is called bailador

[14:26] <raschipi> buggable: eco bailador

[14:26] <buggable> raschipi, Found 5 results: Bailador, Bailador::Dev::AutoRestarter, Bailador::Plugin::Static, Bailador::Plugin::AssetPack::SASS, Bailador::Template::Mojo::Extended. See https://modules.perl6.org/#q=bailador

[14:27] *** Cabanossi joined
[14:27] <tyil> awesome, I'll look into that, I can apply one of the json modules if needs be to do that little bit

[14:28] <tyil> ofc, if anyone knows of other frameworks available, feel free to poke me so I can compare them 

[14:29] <raschipi> buggable: eco prancer

[14:29] <buggable> raschipi, Nothing found

[14:29] <raschipi> another: https://github.com/drforr/perl6-App-prancer

[14:30] <raschipi> and another: https://github.com/masak/web

[14:33] <tyil> nice

[14:38] *** obfusk_ joined
[14:38] *** obfusk left
[14:44] <ugexe> http://ugexe.com/hello-web-with-puree-perl-6/ # tony-o's hiker (and blog post)

[14:45] <tyil> too bad that last site is behind cf

[14:46] *** lighttrr joined
[14:47] <ugexe> whats wrong? I thought I turned off all the "protections"

[14:47] <SmokeMachine> I don't know if someone is interested, but Im playing building a script that uses zef and does something like nom does for node... does anyone think its interesting? if someone would like to critic: https://github.com/FCO/6pm

[14:47] <tyil> apparently not

[14:48] <tyil> besides, even without the "protections", cf causes more harm than anything else

[14:51] *** Sound left
[14:55] *** Cabanossi left
[14:57] *** Cabanossi joined
[14:59] *** wamba left
[15:05] *** chsanch left
[15:10] *** lighttrr left
[15:10] *** geekosaur left
[15:11] *** geekosaur joined
[15:21] *** zakharyas left
[15:21] *** lighttrr joined
[15:21] *** sufrostico left
[15:23] *** sufrostico joined
[15:31] *** Loops left
[15:32] *** gregf_ joined
[15:37] *** geekosaur left
[15:39] *** geekosaur joined
[15:41] *** skids joined
[15:42] *** domidumont left
[15:43] *** itaipu left
[15:50] *** alimon joined
[15:51] *** lighttrr left
[15:59] *** abraxxa left
[16:03] *** khw joined
[16:07] *** geekosaur left
[16:07] *** skids left
[16:08] *** geekosaur joined
[16:08] *** geekosaur left
[16:10] *** itaipu joined
[16:10] *** geekosaur joined
[16:12] *** geekosaur left
[16:13] *** geekosaur joined
[16:13] *** sufrostico left
[16:15] *** sufrostico joined
[16:15] *** geekosaur left
[16:17] *** geekosaur joined
[16:19] *** geekosaur left
[16:19] *** geekosaur joined
[16:25] *** setty1 joined
[16:26] *** geekosaur left
[16:27] <SmokeMachine> m: say sub (*@a ($)) {}.arity # shouldn't be 1?

[16:27] <camelia> rakudo-moar 5ca924: OUTPUT: «0␤»

[16:28] *** geekosaur joined
[16:30] <TimToady> the fact that it lets you put a destructure on a slurpy is probably an oversight

[16:32] <SmokeMachine> m: say sub (*@a ($)) {}.()

[16:32] <camelia> rakudo-moar 5ca924: OUTPUT: «Too few positionals passed; expected 1 argument but got 0 in sub-signature of parameter @a␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:33] *** pochi left
[16:34] <SmokeMachine> TimToady: sorry, I didn't get it...

[16:35] *** lighttrr joined
[16:36] *** pochi joined
[16:39] <gfldex> m: say sub (*@a ($)) {}.(Empty)

[16:39] <camelia> rakudo-moar 5ca924: OUTPUT: «Too few positionals passed; expected 1 argument but got 0 in sub-signature of parameter @a␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:40] <gfldex> SmokeMachine: it's a bit of a contradiction

[16:40] <SmokeMachine> m: say sub (*@a ($)) {}.([])

[16:40] <camelia> rakudo-moar 5ca924: OUTPUT: «Too few positionals passed; expected 1 argument but got 0 in sub-signature of parameter @a␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[16:40] <SmokeMachine> m: say sub (*@a ($)) {}.([1])

[16:40] <camelia> rakudo-moar 5ca924: OUTPUT: «Nil␤»

[16:41] <AlexDaniel> huh what

[16:41] <AlexDaniel> ah… nvm

[16:42] <SmokeMachine> AlexDaniel: yes, nvm... sorry!

[16:42] <SmokeMachine> no! nem!

[16:42] <SmokeMachine> npm

[16:42] <AlexDaniel> m: sub (*@a ($x, $y, *@b)) { say $x; say $y; say @b}(42, 24, 50, 51, 52)

[16:42] <camelia> rakudo-moar 5ca924: OUTPUT: «42␤24␤[50 51 52]␤»

[16:43] <AlexDaniel> TimToady: is it actually an oversight?

[16:44] *** lighttrr left
[16:44] <AlexDaniel> m: sub (+@a ($x, $y, *@b)) { say $x; say $y; say @b}(42, 24, 50, 51, 52)

[16:44] <camelia> rakudo-moar 5ca924: OUTPUT: «42␤24␤[50 51 52]␤»

[16:44] <AlexDaniel> m: sub (+@a ($x, $y, *@b)) { say $x; say $y; say @b}([42, 24, 50, 51, 52])

[16:44] <camelia> rakudo-moar 5ca924: OUTPUT: «42␤24␤[50 51 52]␤»

[16:45] <AlexDaniel> looks like a feature to me :)

[16:46] <AlexDaniel> SmokeMachine: the arity seems to come from the argument itself, not its destructure

[16:47] *** itaipu left
[16:47] <AlexDaniel> and that kinda makes sense

[16:47] <agentzh> Woodi: please do not assume we are takers. that's just ridiculous. you have no idea how much we contribute to the open source community in the last decade.

[16:47] <agentzh> Woodi: and i contributed a lot of my time to perl 6 community 10 years ago.

[16:47] <agentzh> and i also created several bug reports to rakudo.

[16:47] <agentzh> just recently

[16:48] <agentzh> and we actively share what we like and what we don't like here about our use of rakudo.

[16:48] <SmokeMachine> AlexDaniel: I mean: npm (the node package manager)

[16:48] <agentzh> Sahme

[16:48] <AlexDaniel> huh?

[16:49] <AlexDaniel> agentzh: don't take it too close to your heart. We are happy to have you around :)

[16:49] <agentzh> Woodi: you are in no position in judge us.

[16:49] <agentzh> AlexDaniel: thanks

[16:50] *** alphah left
[16:51] <AlexDaniel> agentzh: to be honest, I was also a bit disappointed when I heard that this stuff is going to be closed (mostly). It's kinda natural to be sad about it. Still cool though.

[16:56] *** dakkar left
[17:10] *** sufrostico left
[17:12] <agentzh> AlexDaniel: well, we may open source fanlang at some point. the company just does not want to open source it now since the company is just started.

[17:13] *** sufrostico joined
[17:13] *** robertle joined
[17:13] <agentzh> we have to make a living first, then we can have the resources to better support open source in a sustainable way.

[17:14] <agentzh> like decades, i hope :)

[17:14] <timotimo> bench: compare HEAD so "hello how are you today?".contains("hello" & "u t") for ^1000 ||| my $target = "hello how are you today?"; so $target.contains("hello") && $target.contains("u t") for ^1000

[17:14] <benchable6> timotimo, starting to benchmark the 1 given commit

[17:14] <benchable6> timotimo, https://gist.github.com/4219eadfc16b1f9096dc25dadc7f07ab

[17:16] *** zakharyas joined
[17:19] <SmokeMachine> my %a = a => {b => 1}; say %a{"a","a";"b"}; say %a{"a","a";"b"}:exists # would it return True, True?

[17:19] <SmokeMachine> m: my %a = a => {b => 1}; say %a{"a","a";"b"}; say %a{"a","a";"b"}:exists # would it return True, True?

[17:19] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 1)␤False␤»

[17:21] <SmokeMachine> *should

[17:22] <timotimo> hm, i'd expect it to return more than one value in any case

[17:23] <SmokeMachine> timotimo: do you mean its not a bug? https://rt.perl.org/Public/Bug/Display.html?id=130947#ticket-history

[17:23] *** agentzh left
[17:23] *** sufrostico left
[17:24] <SmokeMachine> m: my %a = a => {b => 1}; say %a{"a";"b"}.perl # <- timotimo: i mean: should it return a list (1,) or only 1 result: 1?

[17:24] <camelia> rakudo-moar 5ca924: OUTPUT: «(1,)␤»

[17:24] <timotimo> ah, that's different

[17:24] <timotimo> that ought to be only one value, i guess

[17:24] *** Cabanossi left
[17:25] <timotimo> i haven't used slices with multidim hashes yet 

[17:25] <SmokeMachine> timotimo: ok! that's what Im trying to fix... 

[17:25] <SmokeMachine> timotimo: while I was looking that I saw the :exists case...

[17:26] <SmokeMachine> m: my %a = a => {b => 1}; say %a{"a","a";"b"}; say %a{"a","a";"b"}:exists # I think False is wrong... but should it return True or (True, True)?

[17:26] <camelia> rakudo-moar 5ca924: OUTPUT: «(1 1)␤False␤»

[17:26] <timotimo> i'll be AFK for a bit now, though

[17:27] <timotimo> i think it ought to return False, False?

[17:27] *** sufrostico joined
[17:27] *** Cabanossi joined
[17:27] <timotimo> isn't what you have there the equiv of (%a{"a", "a"}:exists, %a{"b"}:exists)?

[17:27] <timotimo> or am i confusing , and ;?

[17:27] <SmokeMachine> confusing, I think...

[17:27] <timotimo> ; is to make a list-of-lists, and each of these entries ought to be one "path"?

[17:28] <SmokeMachine> %a{"a", "a"; "b"} == %a<a><b>, %a<a><b>   ?

[17:29] *** itaipu joined
[17:29] <AlexDaniel> timotimo: yup, junctions are known to be… extremely slow…

[17:30] <timotimo>  a little bit :)

[17:30] <AlexDaniel> yea, just 27 times

[17:32] *** wamba joined
[17:33] <AlexDaniel> bench: compare 2015.12 so "hello how are you today?".contains("hello" & "u t") for ^1000 ||| my $target = "hello how are you today?"; so $target.contains("hello") && $target.contains("u t") for ^1000

[17:33] <benchable6> AlexDaniel, starting to benchmark the 1 given commit

[17:33] <benchable6> AlexDaniel, https://gist.github.com/43635f98e94d3f3b794ea7c8dae6c974

[17:33] <AlexDaniel> really? That much faster?

[17:33] <AlexDaniel> bench: 2015.12,HEAD so "hello how are you today?".contains("hello" & "u t") for ^1000

[17:33] <benchable6> AlexDaniel, starting to benchmark the 2 given commits

[17:33] <benchable6> AlexDaniel, benchmarked the given commits, now zooming in on performance differences

[17:34] <AlexDaniel> bench: 2015.12,HEAD my $target = "hello how are you today?"; so $target.contains("hello") && $target.contains("u t") for ^1000

[17:34] <benchable6> AlexDaniel, starting to benchmark the 2 given commits

[17:34] <benchable6> AlexDaniel, https://gist.github.com/9483b4cc1fee2feec6c3e1a30026886b

[17:34] <benchable6> AlexDaniel, benchmarked the given commits, now zooming in on performance differences

[17:34] <benchable6> AlexDaniel, ¦2015.12: «0.1168» ¦HEAD: «0.1121»

[17:37] <AlexDaniel> MasterDuke: why does it say 0.0253s when you “compare”, but 0.1121s otherwise?

[17:38] <AlexDaniel> MasterDuke: or 0.0094s even

[17:46] *** TeamBlast left
[17:47] *** TeamBlast joined
[17:49] *** domidumont joined
[17:51] *** itaipu left
[18:02] *** g0d355__ joined
[18:04] *** bstahlman joined
[18:04] <bstahlman> Can anyone explain this statement from the Control Flow section of the docs?

[18:04] <bstahlman> There is one other feature a when has that if doesn't: the when's boolean context test defaults to $_ ~~ while the if's does not. That has an effect on how one uses the X in the when block without a value for $_ (it's Any in that case and Any smart matches on True: Any ~~ True yields True)

[18:05] <bstahlman> What's confusing me is the bit about "$_". With `when $a { ... }`, how does $_ enter into it?

[18:05] <bstahlman> I would have assumed that was short for $a ~~ True or something like that.

[18:05] <bstahlman> And the topic isn't automatically changed for an if or when, is it?

[18:08] *** zakharyas left
[18:10] <timotimo> "when $foo" will test the current topic against $foo using a smart match

[18:11] <bstahlman> Ah! But if doesn't work that way, right?

[18:11] <bstahlman> It's just doing a Boolean coercion of the condition?

[18:12] <timotimo> yup

[18:12] <bstahlman> So then how does `when so $a` work? Is it coercing to Boolean, then comparing with $_?

[18:13] <timotimo> it smart matches against a boolean; smart match against False always fails, smart match against True always succeeds

[18:13] <bstahlman> Iow, does use of when always imply having set $_ to something beforehand?

[18:13] <timotimo> it's basically a way to ignore the $_

[18:13] <AlexDaniel> bstahlman: yes

[18:13] <timotimo> not always, though

[18:14] <bstahlman> timotimo: What's a way to ignore the $_? Using `so`?

[18:14] <timotimo> when you use something that evaluates to True or False, you can ignore setting $_

[18:14] <AlexDaniel> what's the use of “when” if you having something random in $_?

[18:14] <timotimo> it will succeed at the end of the inner block

[18:14] <AlexDaniel> mhm… sounds like an interesting way of obfuscation

[18:14] <timotimo> m: given "hello" { if $_ ~~ /e/ { say "e!" }; if $_ ~~ /l/ { say "l!" }; }

[18:14] <camelia> rakudo-moar 5ca924: OUTPUT: «e!␤l!␤»

[18:15] <bstahlman> timotimo: Ah. So IIUC, if the condition is a Boolean, the rule for evaluation is different: i.e., compares with True rather than comparing with $_?

[18:15] <timotimo> m: given "hello" { when /e/ { say "e!" }; when /l/ { say "l!" }; }

[18:15] <camelia> rakudo-moar 5ca924: OUTPUT: «e!␤»

[18:15] <timotimo> ^- see how the second one doesn't print "l!"?

[18:15] <timotimo> bstahlman: no, the rule for evaluation is the same: "use smart match"

[18:15] <timotimo> it's just that smart matching anything against True always results in True, and False always False

[18:17] <bstahlman> timotimo: Can you expand on "smart matching anything against True"? Are you referring to "Any" or just anything in the literal sense. To be explicit... `when $a` := ? and `when so $a` := ?

[18:17] <AlexDaniel> m: say 42 ~~ True

[18:17] <camelia> rakudo-moar 5ca924: OUTPUT: «Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at <tmp>:1␤    ------> 3say 42 ~~ 7⏏5True␤True␤»

[18:17] <bstahlman> I.e., how would those expand?

[18:17] <timotimo> no, literally any value ever

[18:18] <AlexDaniel> m: say 42 ~~ False

[18:18] <camelia> rakudo-moar 5ca924: OUTPUT: «Potential difficulties:␤    Smartmatch against False always fails; if you mean to test the topic for truthiness, use :!so or *.not or !* instead␤    at <tmp>:1␤    ------> 3say 42 ~~ 7⏏5False␤False␤»

[18:18] <timotimo> that's also why it gives you that warning there

[18:18] <bstahlman> So False ~~ True is True?

[18:18] <timotimo> yes

[18:19] <bstahlman> Ok. So what does `when so $a` expand to if I'm going to write it out as a standard boolean conditional?

[18:19] <bstahlman> Same question for `when $a`...

[18:19] <timotimo> when so $a is the same as if $_ ~~ (so $a) { ...; succeed }

[18:19] <timotimo> when $a is the same as if $_ ~~ $a { ...; succeed }

[18:20] <AlexDaniel> s: &infix:<~~>, \(False, True)

[18:20] <timotimo> that's not where you'll find it

[18:20] <AlexDaniel> huh

[18:20] <bstahlman> And in both cases, $_ is whatever it was (e.g., as set by a given) - there's no automatic topicalization going on?

[18:20] <timotimo> s: True, ".ACCEPTS", \(Any)

[18:20] <AlexDaniel> the bot is simply not here

[18:20] <timotimo> yes, when doesn't topicalize

[18:21] <timotimo> oh, ok

[18:21] <bstahlman> Ok. Thanks. I'll play around with that in the REPL to be sure I understood.

[18:21] <timotimo>     Bool.^add_multi_method('ACCEPTS', my multi method ACCEPTS(Bool:D: Mu \topic ) { self });

[18:22] <timotimo> i.e. True.ACCEPTS(...) will always return self, i.e. True

[18:22] <timotimo> and same for False.ACCEPTS

[18:23] <bstahlman> Ah. I think I see now what you mean about `so` providing a way to ignore $_. `when so $a` equals `$_ ~~ (so $a)`, but if $a coerces to True, the rule you mentioned earlier regarding smartmatch with True renders $_ a "dont' care".

[18:24] <AlexDaniel> yea

[18:24] <timotimo> right

[18:24] <bstahlman> timotimo: Great. Thanks for your patience...

[18:24] <timotimo> np

[18:24] *** cdg_ left
[18:28] <AlexDaniel> say 42 ~~ True

[18:28] <AlexDaniel> m: say 42 ~~ True

[18:28] <camelia> rakudo-moar 5ca924: OUTPUT: «Potential difficulties:␤    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead␤    at <tmp>:1␤    ------> 3say 42 ~~ 7⏏5True␤True␤»

[18:28] <AlexDaniel> m: say 42 [~~] True

[18:28] <camelia> rakudo-moar 5ca924: OUTPUT: «True␤»

[18:29] <AlexDaniel> I guess [] is not always a no-op…

[18:30] *** darutoko left
[18:34] *** TEttinger joined
[18:41] *** espadrine joined
[18:42] *** labster joined
[18:46] *** bstahlman left
[18:46] *** skids joined
[18:47] *** labster left
[18:49] *** labster joined
[18:55] *** ZofBot joined
[18:55] *** ChanServ sets mode: +v ZofBot

[19:08] *** evalable6 left
[19:11] *** Cabanossi left
[19:11] *** r3m left
[19:12] *** Cabanossi joined
[19:14] *** r3m joined
[19:15] *** Sound joined
[19:21] *** labster left
[19:24] *** damnlie_ joined
[19:26] *** labster joined
[19:27] *** domidumont left
[19:28] *** isacloud joined
[19:29] *** Wanderer68 left
[19:32] *** MilkmanDan left
[19:32] *** MilkmanDan joined
[19:36] *** gdonald left
[19:36] *** gdonald joined
[19:38] *** peteretep joined
[19:39] *** ugexe joined
[19:39] *** Tonik joined
[19:47] *** BuildTheRobots joined
[19:48] *** bjz joined
[19:49] *** mrsolo joined
[19:50] *** ggherdov joined
[19:50] *** olinkl joined
[19:54] *** Sound left
[19:54] *** Cabanossi left
[19:55] *** labster left
[19:56] *** setty1 left
[19:57] *** Cabanossi joined
[20:03] *** cdg joined
[20:11] *** g0d355__ left
[20:12] *** vendethiel left
[20:12] *** kivutar joined
[20:12] *** vendethiel joined
[20:15] <timotimo> RabidGravy: can i ask you about test failure in JSON::Unmarshal?

[20:16] <timotimo> oh, that must be about the Associative role thing with 1 vs 2 parameters?

[20:16] <RabidGravy> you might

[20:16] <timotimo> is it known to be broken on rakudo 2016.11?

[20:17] <RabidGravy> it was broken until yesterday :)

[20:17] *** kivutar left
[20:17] <timotimo> oh, did you just add these tests?

[20:18] <RabidGravy> the test isn't merged yet afaik

[20:18] <timotimo> huh

[20:18] <RabidGravy> oh in JSON::Class it is

[20:18] <timotimo> OK, that explains it

[20:19] <timotimo> food's warmed up!

[20:19] <timotimo> bbl

[20:19] <RabidGravy> maybe I should TODO that

[20:19] <RabidGravy> :)

[20:21] <RabidGravy> specifically it was https://github.com/rakudo/rakudo/commit/a6ba994d3988114ab8ae7519d75f1e9a58dc366f that fixed it

[20:21] *** andrzejk_ joined
[20:26] *** raschipi left
[20:28] <timotimo> huh, moar doesn't seem to build under windows at the moment?

[20:28] *** sufrostico left
[20:30] <timotimo> i see it

[20:30] *** sufrostico joined
[20:35] *** sufrostico left
[20:39] *** robertle left
[20:41] *** Ven joined
[20:41] *** Ven is now known as Guest82746

[20:44] *** pmurias left
[20:45] *** pmurias joined
[20:46] *** sufrostico joined
[20:50] *** Tonik left
[20:50] *** andrzejk_ left
[20:51] *** wamba left
[20:54] *** lichtkind_ joined
[20:55] *** Cabanossi left
[20:55] *** labster joined
[20:57] *** Cabanossi joined
[20:57] *** lichtkind left
[20:59] *** donaldh joined
[21:07] *** Guest82746 left
[21:13] *** RabidGravy left
[21:14] *** bjz left
[21:16] *** donaldh left
[21:16] *** donaldh joined
[21:18] *** Ven_ joined
[21:26] *** Ven_ left
[21:26] *** Ven_ joined
[21:27] *** mcmillhj left
[21:28] *** Ven_ left
[21:34] *** alphah joined
[21:43] *** gdonald left
[21:43] *** gdonald joined
[21:55] *** Cabanossi left
[21:57] *** Cabanossi joined
[21:57] *** mcmillhj joined
[22:03] *** mcmillhj left
[22:06] <sjn> hey, is there a way to detect wether my function is running in void context?

[22:07] *** donaldh left
[22:09] *** dct joined
[22:09] <lizmat> have it return an object which has a .sink method

[22:10] <lizmat> m: class A { method sink() { say "sunk" } }; A.new

[22:10] <camelia> rakudo-moar 5ca924: OUTPUT: «sunk␤»

[22:11] *** Sound joined
[22:11] *** mcmillhj joined
[22:14] <AlexDaniel> m: role SinkExploder { method sink() { die "sunk" } }; sub foo { return 42 does SinkExploder }; my $x = foo; say $x

[22:14] <camelia> rakudo-moar 5ca924: OUTPUT: «42␤»

[22:14] <AlexDaniel> m: role SinkExploder { method sink() { die "sunk" } }; sub foo { return 42 does SinkExploder }; foo

[22:14] <camelia> rakudo-moar 5ca924: OUTPUT: «sunk␤  in method sink at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»

[22:14] *** vendethiel left
[22:15] *** vendethiel joined
[22:16] *** espadrine left
[22:16] *** mcmillhj left
[22:16] <lizmat> and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/03/27/2017-13-ios-not-the-same/

[22:17] <sjn> yay!

[22:19] <Voldenet> Nice!

[22:20] <Voldenet> Hm, are strings in perl6 immutable?

[22:21] <samcv> Voldenet, from an implementation sense? pretty sure yes

[22:21] <samcv> even though they pretend not to be

[22:21] <Voldenet> well thought so

[22:22] <Voldenet> I think perl5 used realloc, so I wasn't sure

[22:23] <AlexDaniel> m: my $x = ‘hello world’; $x.substr-rw(3, 6) = ‘boom!’; say $x

[22:23] <camelia> rakudo-moar 5ca924: OUTPUT: «helboom!ld␤»

[22:24] <AlexDaniel> (doesn't really answer the question, just something to note)

[22:24] <timotimo> yeah, that's just the container being mutable

[22:24] <samcv> yep

[22:24] <timotimo> m: my $x := 'hello world'; $x.substr-rw(3, 6) = 'boom!'; say $x

[22:24] <camelia> rakudo-moar 5ca924: OUTPUT: «Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»

[22:25] *** mcmillhj joined
[22:25] <samcv> m: my $string = 'bleh'; say $string.WHERE; $string ~~ s/h/g/; say $string.WHERE

[22:25] <camelia> rakudo-moar 5ca924: OUTPUT: «140486725436112␤140486726685920␤»

[22:25] <Voldenet> my $y = my $x = ‘hello world’; $x.substr-rw(3, 6) = ‘boom!’; say $x ~ $y

[22:25] <Voldenet> m: my $y = my $x = ‘hello world’; $x.substr-rw(3, 6) = ‘boom!’; say $x ~ $y

[22:25] <camelia> rakudo-moar 5ca924: OUTPUT: «helboom!ldhello world␤»

[22:26] <Voldenet> so yeah, they're pretty much immutable

[22:28] <Voldenet> but i wonder if...

[22:28] <Voldenet> m: my $y = my $x = 'hi world'; say $y.WHERE ~ $x.WHERE

[22:28] <camelia> rakudo-moar 5ca924: OUTPUT: «140155216494432140155216494432␤»

[22:28] <Voldenet> nice, quite nice

[22:29] *** mcmillhj left
[22:30] <Voldenet> perl5 would use 2 different scalars for that, but would keep the first scalar for replacement

[22:30] <Voldenet> but immutable strings is probably a better approach

[22:33] <Voldenet> m: my $y = 'hi world'; my $x = 'hi world'; say ($y.WHERE, $x.WHERE)

[22:33] <camelia> rakudo-moar 5ca924: OUTPUT: «(140611713187152 140611713187152)␤»

[22:33] <Voldenet> whoa, they are interned, even

[22:37] <Voldenet> I wonder if...

[22:37] <Voldenet> m: my $y = "hi world"; say $y.WHERE; use nqp; nqp::force_gc(); my $x = "hi world"; say $x.WHERE

[22:37] <camelia> rakudo-moar 5ca924: OUTPUT: «140380117780016␤140380089870712␤»

[22:38] <Voldenet> Whoa, that's a nice out there

[22:38] <Voldenet> s/nice/nice magic/

[22:38] <Voldenet> :)

[22:41] *** mcmillhj joined
[22:42] *** Voldenet left
[22:43] <timotimo> m: my $y = "hi world"; say nqp::where(nqp::unbox_s($y)); use nqp; nqp::force_gc(); my $x = "hi world"; say nqp::where(nqp::unbox_s($x))

[22:43] <camelia> rakudo-moar 5ca924: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not find nqp::unbox_s, did you forget 'use nqp;' ?␤at <tmp>:1␤------> 3 world"; say nqp::where(nqp::unbox_s($y)7⏏5); use nqp; nqp::force_gc(); my $x = "hi␤»

[22:44] <timotimo> m: use nqp; my $y = "hi world"; say nqp::where(nqp::unbox_s($y)); nqp::force_gc(); my $x = "hi world"; say nqp::where(nqp::unbox_s($x))

[22:44] <camelia> rakudo-moar 5ca924: OUTPUT: «139939163687688␤139939136173792␤»

[22:44] <timotimo> mhm mhm

[22:46] *** mcmillhj left
[22:47] *** Voldenet joined
[22:47] *** Voldenet left
[22:47] *** Voldenet joined
[22:50] *** kurahaupo__ left
[22:51] *** mcmillhj joined
[22:54] *** Cabanossi left
[22:56] *** mcmillhj left
[22:57] *** Cabanossi joined
[22:59] <Voldenet> oh wait, are they really?

[22:59] <Voldenet> m: my $y = ~Date.today(); say $y.WHERE; my $x = ~Date.today(); say $x.WHERE

[22:59] <camelia> rakudo-moar 5ca924: OUTPUT: «140523248789384␤140523248877112␤»

[22:59] <Voldenet> meh, not really

[23:00] *** lukaramu__ left
[23:06] <samcv> timotimo, there's a forcegc :P

[23:08] *** mcmillhj joined
[23:12] *** mcmillhj left
[23:13] *** dct left
[23:15] *** BenGoldberg joined
[23:16] *** rindolf left
[23:16] *** pmurias left
[23:17] <Voldenet> Can I somehow do strings pooling with perl6? I'd rather use no objects where I could use just use some C logic, but I'd rather not actually write C logic for strings... (it's very arcane usage, so probably not)

[23:17] *** Sound left
[23:20] <Voldenet> I believe it would improve efficiency when dealing with moderate amounts of recurring strings (which happens in most apps, like when you fetch usernames from db or parse some /proc), but I'm not sure

[23:22] *** cdg left
[23:26] *** vendethiel- joined
[23:26] *** vendethiel left
[23:28] *** nbrown joined
[23:29] *** mcmillhj joined
[23:30] <timotimo> you're looking at the memory location of Str objects, but they just box str objects

[23:30] <timotimo> i.e. you can mix in roles and such into the Str objects

[23:31] <timotimo> you don't want to pool that in the general case

[23:31] <timotimo> but str objects that come from literal source code are shared already

[23:34] *** mcmillhj left
[23:37] <Voldenet> yeah, well - java and .net are doing something like keeping /some/ of the strings inside of the runtime, I think

[23:39] <Voldenet> i'm not sure how cost-efficient is that, but it could be very memory/gc-efficient in edge cases

[23:44] <timotimo> well, the str is definitely immutable

[23:44] <timotimo> because it doesn't know how mixins work :P

[23:45] *** mcmillhj joined
[23:46] <BenGoldberg> So you want some sort of Str.intern method?

[23:47] <Voldenet> Hm, it might be as nice as dangerous, not sure which path is better tbh

[23:48] <timotimo> you can definitely just stash your strings into a hash

[23:49] <Voldenet> Yeah, but it wouldn't get to near-native performance

[23:49] <Voldenet> in fact, java's way of doing pooling was quite inefficient, so it had to be built into the runtime

[23:49] <Voldenet> (because of how the jvm works)

[23:50] *** mcmillhj left
[23:50] <BenGoldberg> m: my $s = SetHash.new; $s<foo> = True; say $s<foo>:k;

[23:50] <camelia> rakudo-moar 5ca924: OUTPUT: «foo␤»

[23:51] <BenGoldberg> m: my $s = SetHash.new; $s<foo> = True; say ($s<foo>:k) === ($s<foo>:k);

[23:51] <camelia> rakudo-moar 5ca924: OUTPUT: «True␤»

[23:51] <BenGoldberg> m: my $s = SetHash.new; $s<foo> = True; say ($s<foo>:k) === ("foo");

[23:51] <camelia> rakudo-moar 5ca924: OUTPUT: «True␤»

[23:52] <Voldenet> hm, isn't that compile-time optimization?

[23:52] <Voldenet> :P

[23:52] <BenGoldberg> m: my $s = SetHash.new; $s<foo> = True; say ($s<foo>:k) =:= ("fo"~"o");

[23:52] <camelia> rakudo-moar 5ca924: OUTPUT: «False␤»

[23:52] <BenGoldberg> m: my $s = SetHash.new; $s<foo> = True; say ($s<foo>:k) =:= ("foo");

[23:52] <camelia> rakudo-moar 5ca924: OUTPUT: «True␤»

[23:53] <Voldenet> also, how would one return the string from that was used as hash key and free the other?

[23:54] <BenGoldberg> Something like:

[23:55] <BenGoldberg> m: sub intern-string(\foo) { state $strings = SetHash.new; $s{foo} = True; return $s{foo}:k };

[23:55] <camelia> rakudo-moar 5ca924: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$s' is not declared␤at <tmp>:1␤------> 3g(\foo) { state $strings = SetHash.new; 7⏏5$s{foo} = True; return $s{foo}:k };␤»

[23:55] <BenGoldberg> m: sub intern-string(\foo) { state $strings = SetHash.new; $strings{foo} = True; return $strings{foo}:k };

[23:55] <camelia> rakudo-moar 5ca924: ( no output )

[23:56] <BenGoldberg> m: sub intern-string(\foo) { state $strings = SetHash.new; $strings{foo} = True; return $strings{foo}:k }; say intern-string("foo").WHERE, intern-string("f"~"oo").WHERE

[23:56] <camelia> rakudo-moar 5ca924: OUTPUT: «140167891523432140167891810840␤»

[23:56] <BenGoldberg> m: sub intern-string(\foo) { state $strings = SetHash.new; $strings{foo} = True; return $strings{foo}:k }; .say for intern-string("foo").WHERE, intern-string("f"~"oo").WHERE

[23:56] <camelia> rakudo-moar 5ca924: OUTPUT: «140089719443928␤140089719754848␤»

[23:56] <BenGoldberg> oops.

[23:56] <Voldenet> :P

[23:56] <BenGoldberg> Hmm...

[23:56] <Voldenet> it'd be not that tricky to set up in C

[23:56] <BenGoldberg> m: sub intern-string(\foo) is raw { state $strings = SetHash.new; $strings{foo} = True; return $strings{foo}:k }; .say for intern-string("foo").WHERE, intern-string("f"~"oo").WHERE

[23:56] <camelia> rakudo-moar 5ca924: OUTPUT: «139724666723192␤139724667034016␤»

[23:57] * BenGoldberg shrugs.

[23:58] <BenGoldberg> Anyway, if you've got strings which you *know* have been interned, then one convenient thing you can do is avoid string-equality comparisons, and only do object (or pointer) equality comparisons.

[23:58] *** nbrown left
[23:59] <Voldenet> m: sub try-intern { state $s = SetHash.new; $s<^a> ?? $s<$^a> !! $s<$^a> = $^a }; try-intern($_).WHERE.say for ("foo", "fo"~"o");

[23:59] <camelia> rakudo-moar 5ca924: OUTPUT: «24243016␤24243016␤»

[23:59] <Voldenet> that's more like it :)

[23:59] <BenGoldberg> Voldenet++

