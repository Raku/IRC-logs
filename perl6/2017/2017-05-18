[00:00] *** dustinm` left
[00:00] *** Cabanossi joined
[00:04] *** dustinm` joined
[00:06] <skids> o/

[00:07] *** Actualeyes joined
[00:07] <curt_> AlexDaniel: https://github.com/grondilu/libdigest-perl6/issues/18

[00:08] <AlexDaniel> oh

[00:08] *** cyphase left
[00:08] <AlexDaniel> did notice

[00:08] <AlexDaniel> didn't*

[00:13] * skids wonders if any bigint libs have extensive 2s compliment guts.

[00:15] *** khw left
[00:16] <skids> Someone was working on better uint handling in MoarVM, wasn't there?  I have to hack around negative uints quite often.

[00:17] <AlexDaniel> u: chess

[00:17] <unicodable6> AlexDaniel, U+2654 WHITE CHESS KING [So] (‚ôî)

[00:17] <unicodable6> AlexDaniel, U+2655 WHITE CHESS QUEEN [So] (‚ôï)

[00:17] <unicodable6> AlexDaniel, 12 characters in total: https://gist.github.com/62ae66d4189ee14ba2198ce5828f3989

[00:18] <skids> Is the other color RED or BLACK?

[00:19] <skids> u: KNIGHT

[00:19] <unicodable6> skids, U+265E BLACK CHESS KNIGHT [So] (‚ôû)

[00:19] <unicodable6> skids, U+2658 WHITE CHESS KNIGHT [So] (‚ôò)

[00:19] <unicodable6> skids, 6 characters in total: https://gist.github.com/7464e87366755316acf04e5683890ad6

[00:19] <skids> Heh.  The white one looks much blacker to me :-)

[00:24] <TimToady> which one looks darker depends on how many times I type Alt-I

[00:28] <lookatme> morning ~~

[00:33] * BenGoldberg whines, I don't have Alt-I -- I have to rely on a browser bookmarklet to invert things.

[00:36] <BenGoldberg> Speaking of unicode chess pieces, see: http://1kchess.an3.es/play-level-2k

[00:44] *** araujo joined
[00:45] *** araujo left
[00:45] *** araujo joined
[00:48] *** itaipu left
[00:54] *** AlexDaniel left
[01:00] *** mcmillhj_ left
[01:00] *** mcmillhj left
[01:04] *** beginner left
[01:06] *** Chillance left
[01:12] *** mcmillhj joined
[01:12] *** mcmillhj_ joined
[01:16] *** aborazmeh joined
[01:16] *** aborazmeh left
[01:16] *** aborazmeh joined
[01:16] *** mcmillhj_ left
[01:17] *** mcmillhj left
[01:18] *** skids left
[01:20] *** skids joined
[01:22] *** curt_ left
[01:24] *** mcmillhj_ joined
[01:24] *** mcmillhj joined
[01:29] *** skids left
[01:32] *** itaipu joined
[01:33] *** skids joined
[01:33] *** dj_goku joined
[01:38] *** dj_goku left
[01:39] *** skids left
[01:42] *** labster left
[01:45] *** ilbot3 left
[01:46] *** kurahaupo left
[01:48] *** kurahaupo joined
[01:48] *** ilbot3 joined
[01:48] *** ChanServ sets mode: +v ilbot3

[01:49] *** kurahaupo left
[01:49] *** kurahaupo joined
[01:49] *** skids joined
[01:51] *** kurahaupo left
[01:52] *** kurahaupo joined
[01:53] <awwaiid> 7+ talks on Perl6 at TPC-2017-DC! http://www.perlconference.us/tpc-2017-dc/talks/ . Hope to see LOTS of you there!

[01:54] *** skids left
[01:55] <awwaiid> We should get some rakudo hack time going. I really enjoyed meeting up with hoelzro at Strange Loop last year to do some slight REPL hacking :)

[01:58] *** MasterDuke_ is now known as MasterDuke

[01:58] *** itaipu left
[02:02] <MasterDuke> i hope to make it to TPC-DC

[02:03] <japhb> *sigh*  I'll be in DC for the first time in *decades* that very week -- on vacation with my family.  Had no idea there was going to be a TPC there.

[02:04] <MasterDuke> .tell skids i have been playing around with making MoarVM's uint support a little better, but it's not really my strong suit. feel free to jump in and help out!

[02:04] <yoleaux> MasterDuke: I'll pass your message to skids.

[02:08] *** colomon left
[02:08] *** noganex joined
[02:11] *** noganex_ left
[02:18] *** skids joined
[02:24] *** mcmillhj_ left
[02:24] *** mcmillhj left
[02:31] *** ribasushi left
[02:36] *** ribasushi joined
[02:37] *** njmurphy joined
[02:43] *** colomon joined
[02:50] *** cyphase joined
[02:55] *** colomon left
[02:58] *** Cabanossi left
[02:59] *** njmurphy left
[03:01] *** Cabanossi joined
[03:03] *** KDr2_c joined
[03:06] *** colomon joined
[03:09] *** cgfbee left
[03:13] *** zapwai left
[03:15] *** dj_goku joined
[03:15] *** dj_goku left
[03:15] *** dj_goku joined
[03:22] *** mcmillhj joined
[03:22] *** mcmillhj_ joined
[03:25] *** cyphase left
[03:27] *** mcmillhj_ left
[03:27] *** mcmillhj left
[03:28] *** Cabanossi left
[03:29] *** Cabanossi joined
[03:30] *** cyphase joined
[03:32] *** cgfbee joined
[03:35] *** mcmillhj joined
[03:36] *** mcmillhj_ joined
[03:37] *** aborazmeh left
[03:55] *** khw joined
[03:57] *** Cabanossi left
[03:59] *** Cabanossi joined
[04:00] *** BenGoldberg left
[04:09] *** mcmillhj left
[04:09] *** mcmillhj_ left
[04:43] *** Cabanossi left
[04:44] *** Cabanossi joined
[04:56] <grondilu> m: say grammar { rule TOP { ^ <ident> | <ident>\[<ident>\] $ }.parse: "foo[bar]"

[04:56] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> 3<ident>\[<ident>\] $ }.parse: "foo[bar]"7‚èè5<EOL>‚ê§    expecting any of:‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifier loop‚ê§¬ª

[04:56] <yoleaux> 17 May 2017 23:28Z <AlexDaniel> grondilu: Some sha tests are failing when installing Digest, perhaps worth taking a look

[04:57] <grondilu> m: say grammar { rule TOP { ^ <ident> | <ident>\[<ident>\] $ } }.parse: "foo[bar]"

[04:57] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´ÔΩ¢foo[bar]ÔΩ£‚ê§ ident => ÔΩ¢fooÔΩ£‚ê§ ident => ÔΩ¢barÔΩ£‚ê§¬ª

[04:57] <grondilu> m: say ?grammar { rule TOP { ^ <ident> | <ident>\[<ident>\] $ } }.parse: "foo[bar]"

[04:57] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´True‚ê§¬ª

[04:57] <grondilu> m: say grammar { rule TOP { ^ <a=ident> | <b=ident>\[<ident>\] $ } }.parse: "foo[bar]"

[04:57] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´Nil‚ê§¬ª

[04:57] <grondilu> how comes naming captures makes the parse fail??

[04:59] <grondilu> m: say "foo[bar]" ~~ / <a=ident> | <b=ident>\[<ident>\] /

[04:59] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´ÔΩ¢fooÔΩ£‚ê§ ident => ÔΩ¢fooÔΩ£‚ê§ a => ÔΩ¢fooÔΩ£‚ê§¬ª

[04:59] <grondilu> :/

[05:06] *** curan joined
[05:08] *** alphah joined
[05:12] *** lowbro joined
[05:12] *** lowbro left
[05:12] *** lowbro joined
[05:18] *** khw left
[05:21] <Geth> ¬¶ doc: antquinonez++ created pull request #1313: remove duplicate word

[05:21] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/pull/1313

[05:28] *** Cabanossi left
[05:29] *** Cabanossi joined
[05:31] *** alphah left
[05:34] *** xtreak joined
[05:46] <Geth> ¬¶ doc: 75102c5f16 | (Antonio Quinonez)++ (committed by Moritz Lenz) | doc/Language/grammars.pod6

[05:46] <Geth> ¬¶ doc: remove duplicate word

[05:46] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/75102c5f16

[05:49] *** domidumont joined
[05:51] *** ufobat joined
[05:53] *** lookatme left
[05:54] *** lookatme joined
[05:54] *** domidumont left
[05:55] *** domidumont joined
[05:55] *** CIAvash joined
[05:58] *** nadim joined
[05:58] *** domidumont1 joined
[06:02] *** nadim left
[06:02] *** domidumont left
[06:07] *** KDr2_c is now known as KDr2

[06:12] *** wamba joined
[06:18] *** mcmillhj joined
[06:20] *** rindolf joined
[06:23] *** mcmillhj left
[06:25] *** trnh left
[06:33] *** noub joined
[06:34] <noub> hi, somebody speak russian?

[06:39] <noub> can somebody help with \n and \r\n in grammars? i have file with \r\n lines containing \n

[06:40] *** domidumont1 left
[06:41] <noub> how say: 'can take \n, but not \r\n' in token?

[06:41] <noub> not sequence \r\n?

[06:42] <moritz> m: say "\na\r\n".perl

[06:42] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´"\na\r\n"‚ê§¬ª

[06:42] <lookatme> noub, 

[06:42] <lookatme> read file in binary mode

[06:42] * moritz thought rn became one grapheme

[06:42] <moritz> m: say "\r\n".chars

[06:42] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´1‚ê§¬ª

[06:42] <lookatme> or \r\n will convert to \n automate

[06:42] <moritz> hm, seems like it does

[06:43] <moritz> m: say so "\r\n" ~~ /^\n$/

[06:43] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´True‚ê§¬ª

[06:43] *** xtreak left
[06:43] <moritz> m: say so "\r\n" ~~ /^\c[LINE FEED]$/

[06:43] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´False‚ê§¬ª

[06:43] <moritz> m: say so "\n" ~~ /^\c[LINE FEED]$/

[06:43] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´True‚ê§¬ª

[06:43] *** xtreak joined
[06:43] <moritz> noub: match \c[LINE FEED] for the single \n

[06:45] <noub> i think this is not really problem if it will convert to \n if i can take to token string between "Descr=" and \' \' or \" \" or without and to comma

[06:46] <noub> something like { "Descr=" (<quotation-multiline-text-with-commas> | <multiline-text-without-commas> ) }

[06:47] <noub> if text between \"\", than could contain '""'

[06:48] <noub> i need comething like in CSV-example, but more complex

[06:48] <moritz> you can model that as   / \" ~ \" [ <-["]>+ | '""' ]* /

[06:49] <noub> moritz: thx, i'll try this

[06:50] *** xtreak_ joined
[06:50] *** darutoko joined
[06:50] *** mcmillhj joined
[06:50] *** xtreak left
[06:53] *** xtreak_ left
[06:54] *** xtreak joined
[06:55] *** mcmillhj left
[06:56] *** jsimonet joined
[06:59] *** lowbro left
[07:00] *** xtreak left
[07:00] *** xtreak_ joined
[07:07] <nine> Now that's a nice view from a conference location: http://niner.name/pictures/2017-05-18%20-%20Security%20Summit/Wien.jpg

[07:08] *** domidumont joined
[07:09] *** xtreak joined
[07:09] *** xtreak_ left
[07:12] <lookatme> nine, where is this ?

[07:12] *** Cabanossi left
[07:14] *** Cabanossi joined
[07:15] <nine> lookatme: Security Summit 2017 in Vienna at http://www.thirty-five.at/

[07:16] <lookatme> oh, thanks

[07:20] *** wamba left
[07:21] <Voldenet> How to say "parse as int or use 0" in perl6?

[07:21] <Voldenet> m: sub ($n) { try { CATCH { return 0 }; return $n.Int*2 } }("a").say

[07:21] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´0‚ê§¬ª

[07:21] <moritz> m: sub maybe-int(Str $x) { $x.Int // 0 }; say ('abc', 42).map: &maybe-int

[07:21] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´Type check failed in binding to parameter '$x'; expected Str but got Int (42)‚ê§  in sub maybe-int at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:21] <Voldenet> m: sub ($n) { try { CATCH { return 0 }; return $n.Int*2 } }(2).say

[07:21] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´4‚ê§¬ª

[07:22] <moritz> m: sub maybe-int(Str $x) { $x.Int // 0 }; say ('abc', '42').map: &maybe-int

[07:22] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´(0 42)‚ê§¬ª

[07:22] <moritz> you don't need try/CATCH because .Int returns a Failure

[07:22] <Voldenet> ah, a failure is not like an exception

[07:22] <Voldenet> say ('abc', '42').map: { .Int // 0 }

[07:22] <evalable6> Voldenet, rakudo-moar f3f99b3ac: OUTPUT: ¬´(0 42)¬ª

[07:23] <Voldenet> i forgot m:... but it still worked :D

[07:23] <moritz> magical realism!

[07:26] <lookatme> How about .?Int // 0

[07:26] <lookatme> m: sub f($x) { $x.?Int // 0; }; f(class F {}.new());

[07:26] <camelia> rakudo-moar f3f99b: ( no output )

[07:26] <lookatme> m: sub f($x) { $x.?Int // 0; }; say f(class F {}.new());

[07:26] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´0‚ê§¬ª

[07:27] <moritz> m: sub f($x) { $x.Int // 0; }; say f(class F {}.new());

[07:27] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´No such method 'Int' for invocant of type 'F'‚ê§  in sub f at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[07:27] <moritz> it really depends on what you / Voldenet want :-)

[07:27] <lookatme> em.

[07:29] *** skids left
[07:29] <moritz> the "parse as" seemed to imply to me that the basis was a Str. I might be wrong, of course

[07:29] <Voldenet> yeah, it's string

[07:29] <Voldenet> actually they're all Cool

[07:29] <Voldenet> because it's a shell script

[07:30] <lookatme> If it's all string, .Int would be work fine

[07:31] *** noub left
[07:35] *** xinming_ joined
[07:38] *** xinming left
[07:38] *** xtreak left
[07:38] *** xtreak_ joined
[07:40] *** zacts left
[07:44] *** rindolf left
[07:46] *** zakharyas joined
[07:47] <Voldenet> How do I say "if all elements in a Seq are equal"

[07:47] <Voldenet> m: my @f = [1, 1, 2, 1]; say(@f.grep({ @f[0] !~~ $_ }).elems == 0)

[07:47] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´False‚ê§¬ª

[07:47] <Voldenet> m: my @f = [1, 1, 1, 1]; say(@f.grep({ @f[0] !~~ $_ }).elems == 0)

[07:47] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´True‚ê§¬ª

[07:47] <Voldenet> kind of works, but the syntax... erm

[07:51] <Voldenet> not to mention that smart match will invoke the Callable

[07:51] <Voldenet> and I certainly don't want that

[07:51] *** ab6tract joined
[07:51] <ab6tract> Voldenet: you could use a bag

[07:51] <Voldenet> m: my &fn = { $^a; }; my &fn2 = { $^b; }; my @f = [&fn, &fn2, &fn, &fn]; say(@f.grep({ @f[0] !~~ $_ }).elems == 0)

[07:51] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´True‚ê§¬ª

[07:52] <ab6tract> m: my @f = [ 1 xx 5]; say so @f.Bag.keys == 1

[07:52] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´True‚ê§¬ª

[07:52] <ab6tract> m: my @f = [ 1 xx 5, 2]; say so @f.Bag.keys == 1

[07:52] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´False‚ê§¬ª

[07:52] <Voldenet> Most certainly

[07:53] <ab6tract> not sure how applicable it is for Seqs, though..

[07:53] *** zacts joined
[07:56] <ab6tract> m: my @f = [&fn, &fn2, &fn, &fn]; say so @f.Bag.keys == 1

[07:56] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routines:‚ê§    fn used at line 1. Did you mean 'fc'?‚ê§    fn2 used at line 1‚ê§‚ê§¬ª

[07:56] <ab6tract> m: my &fn = { $^a; }; my &fn2 = { $^b; }; my @f = [&fn, &fn2, &fn, &fn]; say so @f.Bag.keys == 1

[07:56] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´False‚ê§¬ª

[07:56] <ab6tract> Voldenet: hope it helps

[07:58] <ab6tract> m: my &fn = { $^a; }; my &fn2 = { $^b; }; my @f = [&fn, &fn, &fn]; say so @f.Set.keys == 1

[07:58] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´True‚ê§¬ª

[07:58] <ab6tract> set of course works too

[08:02] *** rindolf joined
[08:04] *** jonas2 joined
[08:08] *** parv joined
[08:12] *** Cabanossi left
[08:13] <Voldenet> I tried to make some piece of code that'd figure out how to transform one list into another and made this horrible piece of code:

[08:13] <Voldenet> http://ix.io/u6J

[08:14] *** dakkar joined
[08:14] <Voldenet> > echo -e "a A\nb B\nc C\nd\ne" | perl6 transform.p6

[08:14] *** Cabanossi joined
[08:14] <Voldenet> it's just for practice, got any suggestions or syntaxes i should've used?

[08:20] <masak> Voldenet: it's a matter of taste, but I tend to do smaller things and more pure transformations inside of a .map

[08:21] <masak> Voldenet: so I'd be tempted to have that entire loop as a `for lines() { ...; push @fns, $ret }` instead

[08:21] <masak> or, I guess, if you wanted to be fancy, `gather for lines() { ...; take $ret }`

[08:21] <masak> but I realize I hardly ever use `gather` anymore

[08:21] <masak> I should blog about that :)

[08:22] <Voldenet> I tend to use a lot of .map because it can be optimized later ;)

[08:22] <Voldenet> map here can even work in parallel most of the time, which would help if I turned a transformation functions into service calls

[08:25] <lookatme> gather take would be faster than map

[08:25] <Voldenet> Oh, really? :O

[08:27] <lookatme> And `{}()` is clear enough, no need enclosed with `()` 

[08:27] <lookatme> I mean line 19 - 23

[08:27] <Voldenet> Oh, right.

[08:27] <Voldenet> hm, can gather take be parallelised later?

[08:28] <masak> I think both `for` and `map` could have a `hyper` or `race` added in front...

[08:28] <masak> might be wrong, though

[08:30] <Voldenet> yeah, lines().hyper and @t.race would work

[08:31] *** lowbro joined
[08:31] *** lowbro left
[08:31] *** lowbro joined
[08:31] <Voldenet> (because in the first case I'd need the order preserved)

[08:31] <lookatme> masak, Is `gather take` automate paralleled ?

[08:32] <Voldenet> m: my @x = gather { for 1..10 { take start { sleep($_/10); $_ }}}; say await @x

[08:32] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´(1 2 3 4 5 6 7 8 9 10)‚ê§¬ª

[08:33] <masak> lookatme: no

[08:33] <Voldenet> one could do this

[08:34] <lookatme> oh, seem like **faster** is depend on situation

[08:35] <lookatme> but `gather take` can make lazy list

[08:38] <Voldenet> well, the .grep.Set will make full evaluation anyway

[08:38] <Voldenet> so there's no reason to make it a lazy list

[08:39] <Voldenet> with lazy eval, i'd probably use .cache anyway, which destroys the point

[08:39] <Voldenet> (I guess lazy approach could use less memory though)

[08:40] <Voldenet> (...but would cost performance, so it's a tradeoff, if my intuition isn't wrong)

[08:48] <lookatme> em, yeah, lazy list has its advantage, but not  suitable for every case

[08:49] <eater> building on freebsd is slow :(

[08:50] <lookatme> rakudo is slow?

[08:51] <eater> nah

[08:52] <lookatme> oh .

[08:52] *** progr1c joined
[08:53] *** cdc joined
[08:55] *** progr1c left
[09:00] *** ChoHag left
[09:00] *** bjz joined
[09:09] *** bjz left
[09:11] <tadzik> Zoffix: oh, when. Asap, I guess, so it can be useful for the cpan transition

[09:14] *** g4 joined
[09:18] *** bjz joined
[09:23] *** lookatme left
[09:29] *** lizmat left
[09:32] *** TEttinger left
[09:35] *** xtreak joined
[09:37] *** xtreak_ left
[09:38] *** itaipu joined
[09:40] *** xtreak left
[09:43] *** xtreak joined
[09:49] *** marcovorg joined
[09:49] *** kurahaupo_ joined
[09:52] *** wamba joined
[09:56] <grondilu> How do I parse an algebraic expression with a grammar?  I've tried several times, and never quite succeeded :(   My last attempt:  https://gist.github.com/grondilu/09e443f28f322432752543d7eeb55677

[10:04] *** lowbro left
[10:06] *** lizmat joined
[10:07] *** ChoHag joined
[10:07] *** xtreak_ joined
[10:07] *** xtreak left
[10:18] *** kurahaupo_ left
[10:18] *** aborazmeh joined
[10:18] *** aborazmeh left
[10:18] *** aborazmeh joined
[10:19] *** cyphase left
[10:23] *** cyphase joined
[10:23] *** aborazmeh left
[10:24] *** parv left
[10:40] *** aborazmeh joined
[10:40] *** aborazmeh left
[10:40] *** aborazmeh joined
[10:47] *** Zoffix joined
[10:48] <Zoffix> grondilu: you could look at "EXPR" parser in nqp.

[10:48] <Zoffix> There might even be a way to use it in Perl 6

[10:48] <Zoffix> m: use QAST:from<NQP>; say grammar Mathy is HLL::Grammar { token TOP { <EXPR> } }.parse: '2+2'

[10:48] <camelia> rakudo-moar f3f99b: OUTPUT: ¬´===SORRY!===‚ê§Cannot find method 'submethod_table' on object of type NQPClassHOW‚ê§¬ª

[10:48] <Zoffix> which isn't this I guess...

[10:50] <Zoffix> grondilu: also: https://en.wikipedia.org/wiki/Shunting-yard_algorithm

[10:58] *** curan left
[11:04] *** Zoffix left
[11:09] *** itaipu left
[11:12] *** Cabanossi left
[11:14] *** Cabanossi joined
[11:18] *** wamba left
[11:19] *** bjz_ joined
[11:19] *** bjz left
[11:29] *** KDr2 left
[11:30] *** eyck left
[11:41] *** eyck joined
[11:43] <Voldenet> hm, is it even possible with perl's parser?

[11:44] <Voldenet> (the a+b+c case)

[11:45] *** curt_ joined
[11:45] <Voldenet> because "expr -> binary | unary | '(' expr ')', binary -> expr '+' expr" is left-recursive

[11:48] <Voldenet> even easier "expr -> expr '+' expr | '(' expr ')' | digit"

[11:50] *** aborazmeh left
[11:51] <masak> Voldenet: I tend to rewrite left-recursive stuff as using the `%` metaoperator

[11:52] <masak> so `expr -> expr '+' expr` would become something like `rule add-expr { <mult-expr>+ % "+" }`

[11:52] <grondilu> .tell Zoffix thanks! I used one of the external links to write this:  https://gist.github.com/f1b52ab99dcfd503b09ef6041e641531

[11:52] <yoleaux> grondilu: I'll pass your message to Zoffix.

[11:53] <Voldenet> hmm, any info on this?

[11:53] <Voldenet> https://docs.perl6.org/language/grammars doesn't even contain any %

[11:54] <Voldenet> ah, /language/regexes does

[11:54] *** bjz_ left
[11:55] *** bjz joined
[12:00] <Voldenet> hm, but how does it actually help

[12:00] <Voldenet> m: say grammar Algebra { rule TOP { ^^ <expr> $$ }; rule expr { '(' <expr> ')' | <expr>+ % '+' | '1' }}.parse("1+1");

[12:00] <Voldenet> yeah, it's recursive

[12:00] *** wamba joined
[12:00] <camelia> rakudo-moar e89ba8: OUTPUT: ¬´(timeout)¬ª

[12:00] *** kurahaupo left
[12:00] *** kurahaupo joined
[12:03] *** Zoffix joined
[12:03] <Zoffix> m: say 1+2+3

[12:03] <camelia> rakudo-moar e89ba8: OUTPUT: ¬´6‚ê§¬ª

[12:03] <Zoffix> See, it's possible :)

[12:03] <Voldenet> Oh I know it's possible. :P

[12:03] <Voldenet> I just know how to do this using perl6 grammars

[12:03] <Voldenet> s/know/don't know/

[12:03] <Voldenet> slight difference ;)

[12:03] <Zoffix> Perl 6 parses itself using a perl6 grammar (pretty much)

[12:05] <grondilu> maybe it does but if so it's quite convoluted

[12:06] *** kurahaupo left
[12:06] *** kurahaupo joined
[12:08] <Zoffix> Sure. You can setup your own precendence and stuff; all handled by it

[12:08] <Zoffix> Like this: https://github.com/perl7/perl7/blob/master/src/perl7.nqp#L112-L116

[12:08] <Zoffix> m: say grammar Algebra { rule TOP { ^^ <expr> $$ }; regex expr { "(" <expr> ")" || \d+ || <expr>+ % "+" }}.parse("1+1");

[12:08] <camelia> rakudo-moar e89ba8: OUTPUT: ¬´ÔΩ¢1+1ÔΩ£‚ê§ expr => ÔΩ¢1+1ÔΩ£‚ê§  expr => ÔΩ¢1ÔΩ£‚ê§  expr => ÔΩ¢1ÔΩ£‚ê§¬ª

[12:09] <Voldenet> Ah, right, | is longest alternation

[12:09] <Voldenet> no wonder it just finds them all, :D

[12:11] *** lowbro joined
[12:11] *** lowbro left
[12:11] *** lowbro joined
[12:13] *** Zoffix left
[12:14] <Voldenet> hmm, what happens if...

[12:14] <Voldenet> m: say grammar Algebra { rule TOP { ^^ <expr> $$ }; regex expr { "(" <expr> ")" || \d+ || <expr>+ % "+" }}.parse("test");

[12:15] <camelia> rakudo-moar e89ba8: OUTPUT: ¬´(timeout)¬ª

[12:15] <Voldenet> ah, the flavours of recursive

[12:15] <grondilu> yeah if it does not find, it keeps searching

[12:16] <grondilu> (or so I think)

[12:16] <Voldenet> m: say grammar Algebra { rule TOP { ^^ <expr> $$ }; regex expr { "(" <expr> ")" || \d+ || <invalid> || <expr>+ % "+" }; invalid { <-[\d]>+ }}.parse("test");

[12:16] <camelia> rakudo-moar e89ba8: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Missing required term after infix‚ê§at <tmp>:1‚ê§------> 3 || <expr>+ % "+" }; invalid { <-[\d]>+ 7‚èè5}}.parse("test");‚ê§    expecting any of:‚ê§        prefix‚ê§        term‚ê§¬ª

[12:17] <Voldenet> m: say grammar Algebra { rule TOP { ^^ <expr> $$ }; regex expr { "(" <expr> ")" || \d+ || <invalid> || <expr>+ % "+" }; regex invalid { <-[\d]>+ }}.parse("test");

[12:17] <camelia> rakudo-moar e89ba8: OUTPUT: ¬´ÔΩ¢testÔΩ£‚ê§ expr => ÔΩ¢testÔΩ£‚ê§  invalid => ÔΩ¢testÔΩ£‚ê§¬ª

[12:18] <Voldenet> Now I guess I know how one could write that, but it sounds like a convoluted pain.

[12:19] *** CIAvash left
[12:19] *** dj_goku left
[12:21] <Voldenet> Can one use LR parser instead? :)

[12:24] *** raschipi joined
[12:25] <Voldenet> meh, nevermind

[12:27] <Voldenet> I guess it's a funny exercise in writing grammars, teaches one how to see it as a code more :)

[12:28] <[Coke]> Some simple doc tickets if someone wants to help out: https://github.com/perl6/doc/issues/1312 https://github.com/perl6/doc/issues/1311

[12:41] <Geth> ¬¶ doc: 662da2d416 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Language/testing.pod6

[12:41] <Geth> ¬¶ doc: Fix #1312

[12:41] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/662da2d416

[12:41] <Geth> ¬¶ doc: 5a39a32693 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Language/io-guide.pod6

[12:41] <Geth> ¬¶ doc: Fix #1312

[12:41] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/5a39a32693

[12:43] <Geth> ¬¶ doc: a970484899 | (Zoffix Znet)++ (committed using GitHub Web editor) | xt/words.pws

[12:43] <Geth> ¬¶ doc: Add CatHandle to words

[12:43] <Geth> ¬¶ doc: 

[12:43] <Geth> ¬¶ doc: Fixes #1311

[12:43] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/a970484899

[12:43] <Geth> ¬¶ doc: e5b9bce3b4 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Language/io-guide.pod6

[12:43] <Geth> ¬¶ doc: Fix typos

[12:43] <Geth> ¬¶ doc: 

[12:43] <Geth> ¬¶ doc: Fixes #1311

[12:43] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/e5b9bce3b4

[12:48] <dogbert11> so #1311 was fixed twice :)

[12:49] *** bjz left
[12:51] *** dj_goku joined
[12:51] *** dj_goku left
[12:51] *** dj_goku joined
[12:59] <[Coke]> zoffix++

[13:02] *** mcmillhj_ joined
[13:02] *** mcmillhj joined
[13:09] *** mcmillhj_ left
[13:09] *** mcmillhj left
[13:14] *** xtreak_ left
[13:15] *** xtreak joined
[13:15] *** xtreak left
[13:15] *** khw joined
[13:15] *** xtreak joined
[13:17] *** lizmat left
[13:18] *** cdg joined
[13:25] *** wamba left
[13:30] *** mcmillhj joined
[13:31] *** mcmillhj_ joined
[13:47] *** kurahaupo left
[13:47] *** kurahaupo joined
[13:51] *** aborazmeh joined
[13:51] *** aborazmeh left
[13:51] *** aborazmeh joined
[13:55] *** xtreak left
[14:07] *** aborazmeh left
[14:08] *** jonas2 left
[14:18] *** ab6tract left
[14:23] *** itaipu joined
[14:32] *** domidumont left
[14:36] *** wamba joined
[14:36] *** AndyDee left
[14:36] *** Dee22 joined
[14:38] *** Dee22 left
[14:39] *** AndyDee joined
[14:39] *** yuit5 joined
[14:41] *** AndyDee left
[14:41] *** Dee22 joined
[14:43] *** Dee22 left
[14:43] *** Dee22 joined
[14:44] *** Cabanossi left
[14:44] *** Cabanossi joined
[14:45] *** Dee22 left
[14:45] *** Dee22 joined
[14:46] *** st_elmo joined
[14:46] *** imcsk8 left
[14:54] *** imcsk8 joined
[14:56] *** lowbro left
[15:01] *** dct joined
[15:14] *** ChoHag left
[15:16] <moritz> https://en.wikipedia.org/wiki/Multiocular_O a nice Unicode trivia

[15:19] <timotimo> beautiful

[15:19] <timotimo> ÍôÆ

[15:20] <moritz> .u ÍôÆ

[15:20] <yoleaux> U+A66E CYRILLIC LETTER MULTIOCULAR O [Lo] (ÍôÆ)

[15:20] <moritz> and my terminal font even renders it

[15:20] <moritz> for just one word.

[15:21] *** AlexDani` joined
[15:21] *** domidumont joined
[15:21] *** AlexDani` is now known as AlexDaniel

[15:21] <AlexDaniel> unidump: ÍôÆ

[15:21] <unicodable6> AlexDaniel, https://gist.github.com/9b1155fc92f073eff128ffa23dfdd15b

[15:23] <AlexDaniel> m: my $ÍôÆ = 7; say ‚Äòo‚Äô x ÍôÆ

[15:23] <camelia> rakudo-moar 541597: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    ÍôÆ used at line 1‚ê§‚ê§¬ª

[15:23] <AlexDaniel> m: my $ÍôÆ = 7; say ‚Äòo‚Äô x $ÍôÆ

[15:23] <camelia> rakudo-moar 541597: OUTPUT: ¬´ooooooo‚ê§¬ª

[15:23] <AlexDaniel> m: my \ÍôÆ = 7; say ‚Äòo‚Äô x ÍôÆ

[15:23] <camelia> rakudo-moar 541597: OUTPUT: ¬´ooooooo‚ê§¬ª

[15:24] <timotimo> that's so fantastic

[15:24] <AlexDaniel> someone has to draw a spider using this thing for eyes

[15:26] <AlexDaniel> unidump: Íô≠

[15:26] <unicodable6> AlexDaniel, https://gist.github.com/dfda0400aa3adfaa57d9ec23f5fa5f75

[15:26] <AlexDaniel> m: say ‚ÄòÍô≠‚Äô.uc

[15:26] <camelia> rakudo-moar 541597: OUTPUT: ¬´Íô¨‚ê§¬ª

[15:27] <eater> < > is so nice to define commands

[15:27] <AlexDaniel> m: ‚ÄòÍô´‚Äô.uc.say

[15:27] <camelia> rakudo-moar 541597: OUTPUT: ¬´Íô™‚ê§¬ª

[15:27] <AlexDaniel> they definitely had some fetish for eyes and letter O

[15:27] <AlexDaniel> eater: hm. What do you mean exactly?

[15:28] <AlexDaniel> u: ocular

[15:28] <unicodable6> AlexDaniel, U+A669 CYRILLIC SMALL LETTER MONOCULAR O [Ll] (Íô©)

[15:28] <unicodable6> AlexDaniel, U+A668 CYRILLIC CAPITAL LETTER MONOCULAR O [Lu] (Íô®)

[15:28] <unicodable6> AlexDaniel, 7 characters in total: https://gist.github.com/6123d01a50062de0883c871825f81153

[15:28] <moritz> ¬ªÍôÆ¬´

[15:29] *** Rawriful joined
[15:30] <AlexDaniel> ¬ªÍôÆÃã¬´

[15:30] <eater> AlexDaniel: Proc::Async.new(<rm -rf /vagrant>)

[15:31] <eater> I was typing it like ["rm", "]

[15:31] *** yuit5 left
[15:31] <eater> *["rm", "-rf", "/vagrant"]

[15:31] <AlexDaniel> eater: alright, yes. But be careful when you use ¬´¬ª or <<>>

[15:31] <eater> Why so?

[15:32] <AlexDaniel> m: my $x = ‚Äòmy folder‚Äô; dd ¬´rm -rf $x¬ª

[15:32] <camelia> rakudo-moar 541597: OUTPUT: ¬´("rm", "-rf", "my", "folder")‚ê§¬ª

[15:32] <AlexDaniel> m: my $x = ‚Äòmy folder‚Äô; dd ¬´rm -rf "$x"¬ª

[15:32] <camelia> rakudo-moar 541597: OUTPUT: ¬´("rm", "-rf", "my folder")‚ê§¬ª

[15:33] <AlexDaniel> a little bit similar to what you'd do in a shell

[15:33] <eater> AlexDaniel: https://github.com/PostCocoon/P6-SystemPackageManager/blob/master/lib/SystemPackageManager/xbps.pm6#L28

[15:33] <eater> this is what Im doing currently

[15:34] <eater> it's a slurpy parameter and flattens the arrays together

[15:34] <AlexDaniel> that's probably alright :)

[15:34] <AlexDaniel> in whateverable project I always use stuff like ["rm", "-rf", "/vagrant"] :)

[15:36] <ugexe> if you trust the input it doesn't really matter, since it can just as well delete all the files using perl6 IO

[15:37] <eater> but < > doesn't parse anything right? it's just "rm -rf /vagrant".words or am I wrong?

[15:37] <ugexe> you are right

[15:37] <timotimo> right, for example:

[15:37] <eater> \o/

[15:38] <timotimo> m: say <foo\ bar>

[15:38] <camelia> rakudo-moar 541597: OUTPUT: ¬´(foo\ bar)‚ê§¬ª

[15:38] <timotimo> m: say <foo\ bar>.perl

[15:38] <camelia> rakudo-moar 541597: OUTPUT: ¬´("foo\\", "bar")‚ê§¬ª

[15:39] <AlexDaniel> eater: I'm not sure how ‚Äòxbps-install‚Äô works, but most likely you need ‚Äò--‚Äô

[15:39] <AlexDaniel> that is, cmd(<xbps-install -y -->, $packages)

[15:40] <eater> good call!

[15:40] <eater> thanks AlexDaniel 

[15:42] <AlexDaniel> (otherwise you may run into issues if one of your packages starts with ‚Äò-‚Äô‚Ä¶ probably not going to happen, but still)

[15:42] <eater> yeah :D

[15:42] <eater> the integration tests for this project are gonna be fun

[15:42] <eater> spawning vagrant boxes

[15:43] *** itaipu left
[15:44] *** cpage_ left
[15:44] *** cpage__ joined
[15:45] *** dct left
[15:48] <hahainternet> so i asked a question yesterday i'm just going to blatently repeat today, using something like 'regex whatever { <@listoftokens>}' in a grammar doesn't seem to backtrack, i'm presuming because the regex only ever matches the first of the list and won't try alternatives

[15:48] <hahainternet> can anyone provide advice on debugging and/or programmatically adding a bunch of sym tokens so i can distinguish but group them?

[15:52] <AlexDaniel> m: my @a = <aa a c>; say ‚Äòab‚Äô ~~ /<@a>‚Äòb‚Äô/

[15:52] <camelia> rakudo-moar 541597: OUTPUT: ¬´ÔΩ¢abÔΩ£‚ê§¬ª

[15:54] <AlexDaniel> m: my @a = <aa a c>; say ‚Äòab‚Äô ~~ /<@a> {say ‚Äòhere‚Äô} ‚Äòb‚Äô/

[15:54] <camelia> rakudo-moar 541597: OUTPUT: ¬´here‚ê§ÔΩ¢abÔΩ£‚ê§¬ª

[15:54] <AlexDaniel> hm, not sure

[16:00] <hahainternet> yeah i don't quite understand the internal workings

[16:03] *** itaipu joined
[16:05] *** kyclark joined
[16:06] <grondilu> when using the "%" modifier in a regex, is it possible to capture the separator?

[16:06] <timotimo> yup

[16:07] *** domidumont1 joined
[16:07] <grondilu> m: say "foo,bar" ~~ /<ident>+ % $<sep> = <[,;]>/; say $<sep>

[16:07] <camelia> rakudo-moar 541597: OUTPUT: ¬´ÔΩ¢foo,barÔΩ£‚ê§ ident => ÔΩ¢fooÔΩ£‚ê§ sep => ÔΩ¢,ÔΩ£‚ê§ ident => ÔΩ¢barÔΩ£‚ê§[ÔΩ¢,ÔΩ£]‚ê§¬ª

[16:07] <grondilu> m: "foo,bar" ~~ /<ident>+ % $<sep> = <[,;]>/; say $<sep>

[16:07] <camelia> rakudo-moar 541597: OUTPUT: ¬´[ÔΩ¢,ÔΩ£]‚ê§¬ª

[16:07] <grondilu> nice

[16:07] <timotimo> m: say "a,b.c|d!e" ~~ / <ident>+ % $sep=<[,.|!]> /

[16:07] <camelia> rakudo-moar 541597: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Variable '$sep' is not declared‚ê§at <tmp>:1‚ê§------> 3say "a,b.c|d!e" ~~ / <ident>+ % 7‚èè5$sep=<[,.|!]> /‚ê§¬ª

[16:07] <timotimo> m: say "a,b.c|d!e" ~~ / <ident>+ % $<sep>=<[,.|!]> /

[16:07] <camelia> rakudo-moar 541597: OUTPUT: ¬´ÔΩ¢a,b.c|d!eÔΩ£‚ê§ ident => ÔΩ¢aÔΩ£‚ê§ sep => ÔΩ¢,ÔΩ£‚ê§ ident => ÔΩ¢bÔΩ£‚ê§ sep => ÔΩ¢.ÔΩ£‚ê§ ident => ÔΩ¢cÔΩ£‚ê§ sep => ÔΩ¢|ÔΩ£‚ê§ ident => ÔΩ¢dÔΩ£‚ê§ sep => ÔΩ¢!ÔΩ£‚ê§ ident => ÔΩ¢eÔΩ£‚ê§¬ª

[16:08] *** nadim joined
[16:08] *** mcmillhj left
[16:09] *** mcmillhj_ left
[16:09] *** domidumont left
[16:09] <jnthn> hahainternet: tokens are just methods, so it should be possible to build up a grammar (or role to mix into a grammar) using .^add_method('foo:sym<bar>', token { <$bar> })

[16:10] <hahainternet> jnthn: roger, having said that, that is rather ugly and i'm not sure if it's explained well in the docs that things will behave this way

[16:10] <hahainternet> i don't even know if what i described is the actual cause

[16:10] <hahainternet> however, regardless, thanks for the answer, i'll do that :)

[16:11] <jnthn> I'm pretty sure that <@foo> isn't something that can be backtracked in to

[16:11] <jnthn> 'cus I've a good idea of the contortions that would be required to make that work :P

[16:11] <hahainternet> well that's none of my business as i don't know the contortions

[16:12] <hahainternet> but i just mean i was surprised by the behaviour until i thought about it

[16:12] <hahainternet> and it'd be nice to add as a caveat somewhere

[16:12] <hahainternet> i should file bugs i know :(

[16:13] <jnthn> I meant "can't be backtracked into" more in the "in the current implementation" sense, more than in the "impossible to do ever" sense.

[16:13] *** mcmillhj joined
[16:13] <jnthn> But yeah, a mention in the docs that you can't backtrack into it would be good

[16:13] *** mcmillhj_ joined
[16:13] <jnthn> Laziest way is to just file a link to this chat in the irclog :P

[16:14] <timotimo> what's the difference between <@foo> and just @foo?

[16:15] <jnthn> Same as between <$foo> and $foo

[16:15] <jnthn> (EVAL-y behavior)

[16:16] <timotimo> ah so you could have a list of pieces of regex and it'd be put into like an alteration

[16:16] <timotimo> bbiab

[16:16] * grondilu created a "Symbolic" repo for formal calculus in Perl 6.  https://github.com/grondilu/Symbolic

[16:17] <grondilu> ^oviously that's very ambitious so I don't know if I'll be able to make it any useful, but if anyone is interested, check it out.

[16:17] *** beginner joined
[16:17] <hahainternet> i guess all i needed was just @tokenlist then

[16:17] <hahainternet> as my tokens were all plaintext, no regex incorporation

[16:17] <hahainternet> but i think adding methods is the smartest option to make it backtrackable

[16:22] *** mcmillhj left
[16:22] *** mcmillhj_ left
[16:31] *** mcmillhj joined
[16:31] *** mcmillhj_ joined
[16:31] *** AlexDaniel left
[16:32] <timotimo> so numpy has a "nanmin" function that gives you the smallest number in an array ignoring NaN

[16:32] <timotimo> perl6 doesn't need that because apparently NaN is never min-er than another number

[16:32] <timotimo> however

[16:32] <timotimo> a NaN inside a list that you pass to max will dominate

[16:33] <hahainternet> jnthn: hmm, using ^add_method doesn't actually seem to work, i'll simplify my code into a test case

[16:34] *** skids joined
[16:35] *** itaipu left
[16:35] *** mcmillhj_ left
[16:35] *** mcmillhj left
[16:36] <ugexe> did you ^compose or whatever after?

[16:36] <timotimo> https://twitter.com/FakeUnicode/status/865218074525392896 <3

[16:36] *** ChoHag joined
[16:36] <hahainternet> ugexe: i did not

[16:39] <hahainternet> it doesn't seem to make a difference, i'm a bit out of my depth here though

[16:40] <ugexe> m: my $foo = role :: { .^add_method("foo", method { say 1 }); }.new; $foo.foo

[16:40] <camelia> rakudo-moar 541597: OUTPUT: ¬´1‚ê§¬ª

[16:40] <ugexe> m: my $foo = class :: { .^add_method("foo", method { say 1 }); }.new; $foo.foo

[16:40] <camelia> rakudo-moar 541597: OUTPUT: ¬´No such method 'foo' for invocant of type '<anon|71032176>'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[16:40] <hahainternet> ugexe: i'm actually using it to add tokens to a grammar, if that makes any difference

[16:40] <ugexe> works as a punned role

[16:42] *** Cabanossi left
[16:42] *** lizmat joined
[16:44] *** mcmillhj joined
[16:44] *** mcmillhj_ joined
[16:44] *** Dee22 left
[16:44] *** Cabanossi joined
[16:49] *** mcmillhj_ left
[16:49] *** mcmillhj left
[16:52] *** dakkar left
[16:56] *** mcmillhj_ joined
[16:56] *** mcmillhj joined
[16:57] *** xinming_ left
[17:00] *** domidumont joined
[17:00] *** kyclark left
[17:03] *** domidumont1 left
[17:07] <hythm> Hi #perl6. are there required modules needed before getting perl6-debug-m working? I installed perl6 by running:

[17:07] <hythm> git clone https://github.com/tadzik/rakudobrew ~/.rakudobrew; cd ~/.rakudobrew; ^Ckudobrew build moar; rakudobrew build zef; zef install linenoise; zef install Grammar::Debugger

[17:08] <hythm> but for some reason I get this error when I lunch perl6-debug-m: Non ast passed to WANTED: NQPMu

[17:08] <timotimo> sorry, perl6-debug-m is b0rked at the moment ;(

[17:08] *** setty1 joined
[17:09] <timotimo> Grammar::Debugger is something different, though. you use that by putting a use statement into your code

[17:09] <hythm> hmm, Thanks timotimo. 

[17:10] <raschipi> Bork bork bork.

[17:10] <hythm> Yeah Grammar::Debugger is not working for me. this gist has the error and also the output of installing perl6:

[17:10] <hythm> https://gist.github.com/alphah77/9535aeefec2a76ec1164075f4e1e30a9

[17:15] <hythm> so basically if I added use Grammar::Debugger to the code, it throws error when try to parse TOP regex.

[17:15] *** raschipi left
[17:21] *** setty1 left
[17:30] <hythm> looks like I will have to troubleshoot a grammar issue manually, which i know it will be difficult :D

[17:36] *** _kristian joined
[17:39] *** mr-foobar left
[17:39] *** lizmat left
[17:43] *** Cabanossi left
[17:44] *** grondilu left
[17:45] *** Cabanossi joined
[17:45] *** robertle joined
[17:54] *** Zoffix joined
[17:55] <Zoffix> hythm: which rakudo version are you using? Recall what I mentioned: 2017.03 rakudo might now have the issues you're experiencing. Did you try using that version? Also, none of these issues will get fixed if we don't know about them, so it's in your own best interest to report them.

[17:55] <Zoffix> huggable: rakudobug

[17:55] <huggable> Zoffix, Report bugs by emailing to [email@hidden.address]
[17:56] * Zoffix gets jealous of hythm's 48.192s parse time...

[17:56] <Zoffix> Usually ~70s on my boxes :(

[17:57] *** Ven joined
[17:57] <Zoffix> m: say (70-48.192)*(97*1.5)

[17:57] <camelia> rakudo-moar 541597: OUTPUT: ¬´3173.064‚ê§¬ª

[17:58] *** Ven is now known as Guest50345

[17:58] <Zoffix> would save me ~1hr of time a month

[18:03] <hythm> Zoffix, I tried 2017.03 but there is no difference. I want to report the bug, but I don't know what to report. I made simple programm has simple Grammar and Grammar::Debugger worked fine. So I'm trying to see if this is really a bug or I have something wrong in my code

[18:03] <hythm> this is a gaming laptop :P

[18:05] <Zoffix> hythm: "Cannot invoke this object (REPR: Null; VMNull)" error is not very useful to users, so there's a good chance it can be improved even if it's a problem with your code. "Non ast passed to WANTED: NQPMu" is a definite bug and users should never see such errors

[18:05] <hythm> I will report a bug and mention this error I get "Cannot invoke this object (REPR: Null; VMNull)", if that is sufficant

[18:06] <hythm> alright, I will report that then

[18:06] <Zoffix> What to report: instructions for how to reproduce the issue on someone else's computer; so which versions of software/OS you're using and what code you ran

[18:06] <hythm> noted

[18:06] *** setty1 joined
[18:11] *** Chillance joined
[18:12] *** Cabanossi left
[18:13] *** _kristian left
[18:14] *** mr-foobar joined
[18:14] <TimToady> Voldenet: I'm surprised nobody mentioned reduction operators, since things like bags always have to run a sequence to completion, but a reduction can short circuit, even on an infinite list

[18:14] * TimToady checks...

[18:14] *** Cabanossi joined
[18:14] <TimToady> m: say [==] 1...*

[18:14] <camelia> rakudo-moar 541597: OUTPUT: ¬´False‚ê§¬ª

[18:14] <TimToady> yup

[18:14] *** Guest50345 left
[18:15] *** _kristian joined
[18:16] <Zoffix> neat

[18:16] *** Ven_ joined
[18:18] <Voldenet> TimToady: nice, how do I do that with functions?

[18:18] <Voldenet> erm Callable

[18:19] <Zoffix> [[&callable]]

[18:19] <Zoffix> m: say [==] 1, 1, 1, |(1...*)

[18:19] <Zoffix> This hang tho

[18:19] <Zoffix> Ah

[18:19] <Zoffix> m: say [==] 1, 1, 1, |(1, 2, 3...*)

[18:20] *** setty1 left
[18:20] <camelia> rakudo-moar 541597: OUTPUT: ¬´(timeout)¬ª

[18:20] <camelia> rakudo-moar 541597: OUTPUT: ¬´(timeout)¬ª

[18:20] <Voldenet> m: my $i = 0; my &a = { }; my @b = (^5).map({ &a }); say [~~] @b

[18:20] <camelia> rakudo-moar 541597: OUTPUT: ¬´Type check failed in assignment to &a; expected Callable but got Hash (${})‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[18:20] <Zoffix> Actually no, the first one was right

[18:20] <Voldenet> m: my $i = 0; my &a = { $_ }; my @b = (^5).map({ &a }); say [~~] @b

[18:20] <camelia> rakudo-moar 541597: OUTPUT: ¬´True‚ê§¬ª

[18:20] *** trnh joined
[18:20] *** trnh left
[18:20] *** trnh joined
[18:20] <Voldenet> hm, the real problem is that it evaluates the method during ~~ operation

[18:21] *** Ven_ left
[18:22] *** cdg left
[18:22] <TimToady> you want to test that you have the same function?  then you'd use [===] for identity

[18:23] <Voldenet> mmm, === feels so js-y :P

[18:23] <TimToady> m: say [===] &sin, &sin, &sin

[18:23] <camelia> rakudo-moar 541597: OUTPUT: ¬´True‚ê§¬ª

[18:23] <TimToady> m: say [===] &sin, &sin, &cos

[18:23] <camelia> rakudo-moar 541597: OUTPUT: ¬´False‚ê§¬ª

[18:23] <Zoffix> m: say [==] (1, 1, 1, |(1...*))

[18:23] <camelia> rakudo-moar 541597: OUTPUT: ¬´False‚ê§¬ª

[18:24] <TimToady> yes, arglist slip is not lazy

[18:24] <Zoffix> Ah. I see

[18:25] * TimToady doesn't give a rip whether something seems js-y or not; we designed our various equality operators by our own selves

[18:26] <Voldenet> I still find it moderately funny, because it's identity operator in js as well :-)

[18:26] <Voldenet> not that I don't like familiarity

[18:26] <TimToady> convergent evolution, and all that :)

[18:27] <Zoffix> yeah, JS got `use strict` and soon (already?) will get the /s switch for regexes, like Perl 5

[18:28] <TimToady> mebbe they'll borrow Perl 6 regexes in another 15 years or so...

[18:28] <Zoffix> :)

[18:29] <Voldenet> js is a serious and modern language now, it has classes

[18:30] *** pmurias joined
[18:31] <pmurias> Voldenet: the classes in js despite being mostly syntax sugar do make a big difference

[18:31] *** Zoffix left
[18:32] <Voldenet> actually, if I were to choose the important feature in JS, i'd pick async and promises

[18:32] *** Ven_ joined
[18:32] <Voldenet> it greatly improved quality of most code

[18:34] <Voldenet> and one could argue that anything above C and its structs is syntax sugar ;)

[18:34] <Voldenet> because you're just implicitly passing objects

[18:35] <timotimo> but that's only run-time

[18:36] <timotimo> at compile time you're free to stack on as much as you want

[18:36] <hythm> Zoffix: Reported the issue I get https://rt.perl.org/Public/Bug/Display.html?id=131326

[18:54] *** alphah joined
[18:58] *** Ven_ left
[18:58] *** Ven joined
[18:58] *** Ven is now known as Guest74863

[19:02] *** Guest74863 left
[19:04] *** AlexDaniel joined
[19:05] *** Ven_ joined
[19:16] *** darutoko left
[19:19] *** lizmat joined
[19:20] *** zacts left
[19:21] *** iH2O joined
[19:27] *** domidumont left
[19:34] *** alphah left
[19:35] *** zacts joined
[19:37] *** _kristian left
[19:38] *** lizmat left
[19:38] *** _kristian joined
[19:43] *** Ven_ left
[19:43] *** Ven_ joined
[19:47] *** iH2O left
[19:47] *** wamba left
[19:47] *** trnh left
[19:49] *** mcmillhj_ left
[19:49] *** mcmillhj left
[19:56] *** mcmillhj joined
[19:57] *** mcmillhj_ joined
[20:06] *** wamba joined
[20:07] *** cdg joined
[20:07] *** espadrine joined
[20:12] *** Cabanossi left
[20:14] *** Cabanossi joined
[20:24] *** xinming joined
[20:25] *** al2o3-cr joined
[20:27] *** setty1 joined
[20:30] *** Ven_ left
[20:31] *** mr-foobar left
[20:31] *** Ven joined
[20:31] *** Ven is now known as Guest71934

[20:34] *** st_elmo left
[20:35] *** Guest71934 left
[20:38] *** Ven_ joined
[20:43] *** Ven_ left
[20:43] *** Cabanossi left
[20:44] *** Cabanossi joined
[20:45] *** setty1 left
[20:45] *** Ven_ joined
[20:45] *** bjz joined
[20:47] *** Praise left
[20:47] *** Praise joined
[20:47] *** Praise left
[20:47] *** Praise joined
[20:50] *** Ven_ left
[20:50] <robertle> ugexe: travis may need updating now that rakudobrew does not build panda anymore...

[20:51] <ugexe> why?

[20:51] *** Ven_ joined
[20:51] <ugexe> users write their own .travis.yml

[20:52] <jnthn> I think the Perl 6 language support docs on Travis may still mention panda

[20:52] <jnthn> https://docs.travis-ci.com/user/languages/perl6/

[20:52] <tadzik> they should perhaps mention to not rely on master but rather on a specific tag

[20:52] <tadzik> (or commit)

[20:53] <robertle> right, sorry!

[20:53] <jnthn> It looks like there's a link at the top to fork/fix the page

[20:54] <robertle> I was under the (wrong) impression that the part inclusing panda is part of the basioc perl6 stuff rather then my custom bit...

[20:56] <robertle> tony-o: I have updated my version derived from your "pluggable" again, suports the lexical "require" now: https://github.com/robertlemmen/perl6-pluggable

[20:57] *** zakharyas left
[20:57] *** al2o3-cr left
[20:58] *** Ven_ left
[21:00] *** yqt joined
[21:02] *** user3 joined
[21:08] <ugexe> hehe you beat me by a few minutes robertle... im getting slow

[21:09] <robertle> beer helps :)

[21:11] <user3> why can't I compile this to MoarVM byte code:  perl6 --target=mbc -e "say 'Hello, world'"

[21:11] <user3> I get the error message: "Cannot dump this object; no dump method"

[21:11] *** skids left
[21:12] <user3> I've done the basic installation for rakudo Moar

[21:12] <jnthn> It needs an output file, since it's a bunch of binary, so it decides not to dump it on your terminal

[21:12] <timotimo> user3: you have to --target=foobar.moarvm

[21:13] <timotimo> or, wait

[21:13] <timotimo> --output=foobar.moarvm

[21:13] <jnthn> --output=foo.moarvm

[21:13] <timotimo> and then you can dump that with moar --dump foobar.moarvm

[21:14] *** Cabanossi left
[21:14] <jnthn> Yeah, worth noting that compiling a script is only really a debugging aid; only modules are usefully usable in compiled form (so far, at least)

[21:14] *** Cabanossi joined
[21:15] <jnthn> And you don't need to do that manually, it's handled automatically

[21:15] <awwaiid> japhb: you should come by and say hi :)

[21:15] <ugexe> put your script in a module, and have your script just be `use My::Script` to compile scripts

[21:17] <ugexe> ya know we already use wrappers around installed scripts... there is no reason we don't just use those wrappers as the perl6 entry point and do that automatically on install

[21:18] <jnthn> Only caveat is that a MAIN needs an is export sticking on it

[21:18] *** TEttinger joined
[21:19] <ugexe> hmm no way to import them explicitly?

[21:21] <jnthn> At Perl 6 level not a way to import things that aren't exported. But yeah, the whole import mechanism works by being given the UNIT of the imported thing, which is normally just used to find EXPORT, EXPORTHOW and friends.

[21:21] <jnthn> But of course &MAIN could be dug out of it :)

[21:23] <timotimo> hm, it's not lexical-only?

[21:24] <timotimo> well, i guess top-level lexicals would show up in the module itself perhaps?

[21:24] <jnthn> timotimo: UNIT is the top-level lexical scope

[21:25] <jnthn> And on being loaded a module stashes that somewhere the module loader can get at it

[21:25] <jnthn> Which is how EXPORT and GLOBALish and friends are located

[21:26] *** skids joined
[21:27] <timotimo> ah, i see

[21:29] *** cdg left
[21:30] <user3> ok so I did this: perl6 --target=mbc --output=foobar.moarvm -e "put 'hello, world'"

[21:30] <user3> And this: moar --dump foobar.moarvm > foobar.mbc

[21:30] <user3> Then I tried "moar foobar.mbc"  I get the error message "Unhandled exception: Bytecode stream corrupt (missing magic string)"

[21:30] <user3> I also tried "moar foobar.moarvm" I get the error message "Unhandled exception: While looking for 'ModuleLoader.moarvm': no such file or directory at <unknown>:1  (foobar.moarvm:<dependencies+deserialize>)"

[21:30] <timotimo> oh, no

[21:31] <timotimo> i thought you wanted to dump the contents of the moarvm file

[21:31] *** cdg joined
[21:31] <user3> i just want to compile the code a bit to improve performance

[21:31] <timotimo> you will have to invoke the code with the perl6 script or at least steal the commandline flags it uses

[21:31] <timotimo> in that case, do it like jnthn and ugexe suggested

[21:31] <timotimo> put everything into modules because these get precompiled for you automatically

[21:31] *** nadim left
[21:32] <timotimo> then just have a "program" that does "use MyApp::Entrypoint" or whatever you call that module

[21:32] <ugexe> all of your MAINs have to be in one module

[21:33] <ugexe> user3: https://github.com/ugexe/zef/blob/master/bin/zef and https://github.com/ugexe/zef/blob/master/lib/Zef/CLI.pm6

[21:34] <robertle> jnthn: in your latest blog post re funding, what does "non-blocking await" mean? isn't blocking the whole point of await?

[21:37] *** dct joined
[21:39] <Voldenet> robertle: await actually yields continuation

[21:39] <Voldenet> non-blocking, that is

[21:39] <Voldenet> and blocking await probably does some magic with a thread

[21:39] <Voldenet> while capturing the thread in the process

[21:40] <Voldenet> (actually I'm not sure how await could be blocking, but probably because it takes a thread)

[21:40] <jnthn> I thought I'd written this up somewhere but I don't find it

[21:41] <hythm> m: class A { multi method a(Str :$b) { say "First" }; multi method a() { say "Second" } }; A.new.a # (named arg) Why dispatch to first method

[21:41] <robertle> not sure I understand: my current thread calls await on a promise, which will block until the promise is kept/broken. right? that's the point, isn't it?

[21:41] <camelia> rakudo-moar 541597: OUTPUT: ¬´First‚ê§¬ª

[21:41] <jnthn> Anyways, the Perl 6.c semantics - for lack of time to do anything better - is that await will use a condition variable

[21:41] <robertle> makes sense

[21:41] <hythm> m: class A { multi method a(Str $b) { say "First" }; multi method a() { say "Second" } }; A.new.a

[21:41] <camelia> rakudo-moar 541597: OUTPUT: ¬´Second‚ê§¬ª

[21:42] <jnthn> This "works", but it means that a real OS thread is blocked

[21:42] <Voldenet> hythm: named arguments are optional, but

[21:42] <Voldenet> m: class A { multi method a(Str:D :$b) { say "First" }; multi method a() { say "Second" } }; A.new.a # (named arg) Why dispatch to first method

[21:42] <camelia> rakudo-moar 541597: OUTPUT: ¬´Second‚ê§¬ª

[21:42] <Voldenet> m: class A { multi method a(Str:D :$b) { say "First" }; multi method a() { say "Second" } }; A.new.a("x") # (named arg) Why dispatch to first method

[21:42] <camelia> rakudo-moar 541597: OUTPUT: ¬´Cannot resolve caller a(A: Str); none of these signatures match:‚ê§    (A $: Str:D :$b, *%_)‚ê§    (A $: *%_)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[21:43] <Voldenet> m: class A { multi method a(Str:D :$b) { say "First" }; multi method a() { say "Second" } }; A.new.a(:b("x")) # (named arg) Why dispatch to first method

[21:43] <camelia> rakudo-moar 541597: OUTPUT: ¬´First‚ê§¬ª

[21:43] <timotimo> m: await do for ^64 { start { sleep 0.1 } }; say now - INIT now

[21:43] <camelia> rakudo-moar 541597: OUTPUT: ¬´0.4066006‚ê§¬ª

[21:43] *** mcmillhj left
[21:43] *** mcmillhj_ left
[21:43] <timotimo> m: use v6.d.PREVIEW; await do for ^64 { start { sleep 0.1 } }; say now - INIT now

[21:43] <camelia> rakudo-moar 541597: OUTPUT: ¬´0.40641964‚ê§¬ª

[21:43] <timotimo> huh?

[21:43] <robertle> jnthn: but if you change that then the real OS thread after the await could be a different than the one before the call, right?

[21:43] <jnthn> The idea behind non-blocking await is that, when an `await` takes place on the thread pool, we instead take a continuation

[21:43] <Geth> ¬¶ ecosystem: 335cd23715 | (Curt Tilmes)++ | META.list

[21:43] <Geth> ¬¶ ecosystem: Move LibYAML repo to yaml github

[21:43] <Geth> ¬¶ ecosystem: review: https://github.com/perl6/ecosystem/commit/335cd23715

[21:43] <jnthn> And then, when the thing awaited on is done, the continuation is scheduled on the thread pool

[21:44] <robertle> ok, so even the perl thread could be a different one after the await?

[21:44] <jnthn> robertle: Yes, that is an upshot, which is why non-blocking await is being brought in as part of 6.d

[21:45] <jnthn> Note that this only happens on threads managed by the thread pool

[21:45] *** skids left
[21:45] <Voldenet> robertle: that's the whole point of await

[21:45] <jnthn> And if you're using a thread pool you already don't know what thread the code will run on

[21:45] <robertle> understood now. sounds cool, but also potentially a bit surprising. you don't usually expect th thread that runs your code to change ...

[21:45] <hythm> Voldenet yes I needed the define smiley :D. Thanks 

[21:45] <Voldenet> hythm: (;

[21:46] <jnthn> If you are doing something where you really need more control, and work with `Thread` directly, or if you `await` in the main program thread, then you'll get the same semantics as today

[21:46] <Voldenet> jnthn: does perl have something like AsyncLocal?

[21:48] <jnthn> Voldenet: A dynamic variable will work out for that

[21:49] <jnthn> A key difference between await in Perl 6 and await in C#, even once the non-blocking stuff happens, is that the a continuation is taken involving the whole call stack between the place that does the `await` and the thread pool

[21:49] <jnthn> Whereas in C# it's a pre-rotuine code transform

[21:49] <jnthn> *per-routine

[21:50] <jnthn> That's why there's no equivalent to `async`; we don't need one

[21:50] <jnthn> Or, arguably, the equivalent is `start` :)

[21:50] <robertle> continuations are an internal-only thing in perl6, right? I can't create a continuation in perl6 code?

[21:50] <jnthn> Correct

[21:50] <jnthn> gather/take uses them also

[21:50] *** alimon left
[21:51] <Voldenet> You technically could write your own version of await by wrapping it

[21:51] <Voldenet> and then decorating the result

[21:51] <jnthn> gather/take is also an exmaple of something where various languages have a "yield" feature that transforms a routine at compilation, whereas in Perl 6 you don't need to do that

[21:51] *** espadrine left
[21:52] <robertle> I played with gather/take, but you can't use that across threads. continuing a continuation in another thread is quite cool!

[21:52] <robertle> if you could do that in your own code...

[21:53] *** user3 left
[21:54] *** dct left
[21:54] <jnthn> A `start` block will capture the dynamic variables in scope at the point it was taken

[21:54] <Voldenet> robertle: you can kind of use gather take across threads

[21:54] <robertle> Voldenet: how? I tried that a bit...

[21:55] <jnthn> m: my $*x = 1; await start { $*x++; await Promise.in(1); $*x++ }; say $*x

[21:55] <camelia> rakudo-moar 541597: OUTPUT: ¬´3‚ê§¬ª

[21:55] <jnthn> So I figure ^^ gets you the AsyncLocal style functionality

[21:55] <Voldenet> m: @x = gather { for ^10 -> $v { take start { $v*2 } }; say await @x

[21:55] <camelia> rakudo-moar 541597: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Variable '@x' is not declared‚ê§at <tmp>:1‚ê§------> 3<BOL>7‚èè5@x = gather { for ^10 -> $v { take start‚ê§¬ª

[21:55] <Voldenet> m: my @x = gather { for ^10 -> $v { take start { $v*2 } }; say await @x

[21:55] <camelia> rakudo-moar 541597: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> 3$v { take start { $v*2 } }; say await @x7‚èè5<EOL>‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        stateme‚Ä¶¬ª

[21:55] <Voldenet> m: my @x = gather { for ^10 -> $v { take start { $v*2 } }}; say await @x

[21:55] <camelia> rakudo-moar 541597: OUTPUT: ¬´(0 2 4 6 8 10 12 14 16 18)‚ê§¬ª

[21:55] <jnthn> Voldenet: There you're just taking a bunch of Promise objects, so all the threading happens outside of the gather/take.

[21:56] <jnthn> (Which is fine and useful)

[21:56] <jnthn> But yeah, gather/take is not intended for concurrent use

[21:56] <jnthn> The iterator pattern is inherently synchronous.

[21:56] <robertle> yeah, and shifting the promise across thread boiundarioes seems to await on it (right??)

[21:57] <jnthn> A Promise is just a data structure

[21:57] *** Cabanossi left
[21:57] <jnthn> And await is just an operation that means "continue with the stuff after this point once the Promise is done"

[21:57] <jnthn> await actually can work on a Channel and a Supply too

[21:58] <jnthn> This lot was special cased

[21:58] <jnthn> In 6.d, instead `await` accepts anything that does the `Awaitable` role

[21:58] <robertle> jnthn: but that's what you are changing: it's no longer just waiting...

[21:58] <jnthn> (6.d.PREVIEW, I should say)

[21:59] <jnthn> Opening the doors to folks making their own things usable with await too :)

[21:59] <timotimo> it's the best kind of waiting

[21:59] <Voldenet> the best kind of waiting is fire-and-forget

[21:59] *** Cabanossi joined
[21:59] <Voldenet> ;)

[22:00] <Voldenet> m: start { say "i'm confident this will surely work" }

[22:00] <camelia> rakudo-moar 541597: ( no output )

[22:00] <Voldenet> ;-)

[22:00] <jnthn> robertle: What's changing is that await will not always mean "blocking an OS-level thread"

[22:01] <jnthn> robertle: At the end of the day, that's just a means to an end, the end being that the code after the await continues when the result is available.

[22:01] <Voldenet> eh, but why 'not always' instead of 'never'? :)

[22:01] <timotimo> the OS-level threads were already being pre-empted :P

[22:01] <timotimo> which is kind of like a continuation being taken and resumed

[22:01] <jnthn> Voldenet: No; the non-blocking behavior of await only applies if you're running code in the thread pool

[22:02] <Voldenet> ah, right, because if you're running your own thread... you're running your own thread

[22:02] <jnthn> Voldenet: This is an effort to let people who want tighter control over what thread they're on to have it, but not have to totally throw away using higher-level things like await

[22:04] <jnthn> Occasionally - like when writing native bindings - it's really important to have control over that.

[22:04] <timotimo> oh yes

[22:04] *** lizmat joined
[22:05] <jnthn> The most recent case I had was writing the SSH::LibSSH binding, where I have a single thread interacting with it, essentially running an "event loop"

[22:06] *** _kristian left
[22:06] <Voldenet> well, a lot of things have to use event loop, like renderers

[22:06] *** dct joined
[22:06] <Voldenet> + they must really have their own thread, so it's understandable

[22:06] <jnthn> Yeah, GUI stuff is also good at caring

[22:06] *** rindolf left
[22:07] <jnthn> Final note: besides the Awaitable role, there's also an Awaiter role

[22:08] <jnthn> Meaning that we should be able to do stuff like "if I call await on a GUI thread, it will make sure the result is marshalled back to the UI thread after"

[22:08] <jnthn> A bit like .Net's SynchronizationContext

[22:08] <Voldenet> and .ConfigureAwait(false)

[22:08] <Voldenet> right?

[22:08] <jnthn> Related to that, yes

[22:09] * jnthn should go and get some sleep...

[22:09] <timotimo> good rest, jnthn :)

[22:09] <Voldenet> gn

[22:09] <jnthn> 'night

[22:10] *** Actualeyes left
[22:13] *** ufobat left
[22:15] *** bjz left
[22:15] *** bjz_ joined
[22:15] *** _kristian joined
[22:20] *** mcmillhj joined
[22:20] *** mcmillhj_ joined
[22:22] *** ChoHag left
[22:23] *** dct left
[22:23] *** bjz_ left
[22:24] *** Actualeyes joined
[22:26] *** mcmillhj_ left
[22:26] *** mcmillhj left
[22:30] *** ChoHag joined
[22:30] <hythm> I would like to call multi methods without args,and the dispatching need to happen from withing the parameters, would this be a bad practice? example to clarify:

[22:31] <hythm> m: class A { has $.var; multi method a(Str :$s = $!var ) { say "First" }; multi method a(Any :$s = $!var) { say "Second" } }; A.new(var => "string").a;

[22:31] <camelia> rakudo-moar 541597: OUTPUT: ¬´First‚ê§¬ª

[22:31] <hythm> m: class A { has $.var; multi method a(Str :$s = $!var ) { say "First" }; multi method a(Any :$s = $!var) { say "Second" } }; A.new.a;

[22:31] <camelia> rakudo-moar 541597: OUTPUT: ¬´Second‚ê§¬ª

[22:35] *** wamba left
[22:36] *** pmurias left
[22:36] *** mcmillhj_ joined
[22:36] *** mcmillhj joined
[22:38] <Voldenet> this doesn't look like a bad practice, just a bit convoluted

[22:39] <Voldenet> + depends on actual use case

[22:40] *** yqt left
[22:41] *** mcmillhj_ left
[22:41] *** mcmillhj left
[22:46] <hythm> If it will be convoluted and might give problems later I think I will not proceed this way, my intention was to keep the scripts under bin* cleaner(for example caliing methods as "$obj.method-name; instead of $obj.method-name(arg 1=> "a",...)  and hide most of the work in lib/*,in program executable, and I wanted to hide most of the work under lib/*

[22:47] *** go|dfish left
[22:51] <timotimo> hythm: you can have the invocant as a parameter by putting it before a : and you should be able to put a "where" constraint on it

[22:52] <timotimo> m: class A { has $.var; multi method a(A $ where { .var ~~ Str }) { say "is string" }; multi method a(A $ where { .var ~~ Int }) { say "is int" } }; A.new(var => "hi").a; A.new(var => 99).a

[22:52] <camelia> rakudo-moar 541597: OUTPUT: ¬´Cannot resolve caller a(A.new(var => "hi"): ); none of these signatures match:‚ê§    (A $: A $ where { ... }, *%_)‚ê§    (A $: A $ where { ... }, *%_)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:52] <timotimo> actually, a subsignature could work here

[22:53] *** mcmillhj_ joined
[22:53] *** mcmillhj joined
[22:53] <timotimo> m: class A { has $.var; multi method a(A $self(Str :$var)) { say "is string" }; multi method a(A $self(Int :$var)) { say "is int" } }; A.new(var => "hi").a; A.new(var => 99).a

[22:53] <camelia> rakudo-moar 541597: OUTPUT: ¬´5===SORRY!5===‚ê§Shape declaration with () is reserved;‚ê§  please use whitespace if you meant a subsignature for unpacking,‚ê§  or use the :() form if you meant to add signature info to the function's type‚ê§at <tmp>:1‚ê§------> 3ss A { has $.var; ‚Ä¶¬ª

[22:53] <timotimo> m: class A { has $.var; multi method a(A $self (Str :$var)) { say "is string" }; multi method a(A $self (Int :$var)) { say "is int" } }; A.new(var => "hi").a; A.new(var => 99).a

[22:53] <camelia> rakudo-moar 541597: OUTPUT: ¬´Cannot resolve caller a(A: ); none of these signatures match:‚ê§    (A $: A $self (Str :$var), *%_)‚ê§    (A $: A $self (Int :$var), *%_)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:53] <timotimo> m: class A { has $.var }; say A.new.Capture.perl

[22:53] <camelia> rakudo-moar 541597: OUTPUT: ¬´\(:var(Any))‚ê§¬ª

[22:54] <timotimo> haha

[22:54] <timotimo> i forgot the :

[22:54] <hythm> lol

[22:54] <timotimo> m: class A { has $.var; multi method a(A $self (Str :$var):) { say "is string" }; multi method a(A $self (Int :$var):) { say "is int" } }; A.new(var => "hi").a; A.new(var => 99).a

[22:54] <camelia> rakudo-moar 541597: OUTPUT: ¬´is string‚ê§is int‚ê§¬ª

[22:54] <timotimo> i forgot the : in the example with "where", too

[22:55] *** kyan joined
[22:55] <hythm> I understood what you mean, gonna test that on my code timotimo

[22:55] <timotimo> m: class A { has $.var; multi method a(A $ where { $_.var ~~ Str }:) { say "is string" }; multi method a(A $ where { .var ~~ Int }:) { say "is int" } }; A.new(var => "hi").a; A.new(var => 99).a

[22:55] <camelia> rakudo-moar 541597: OUTPUT: ¬´is string‚ê§is int‚ê§¬ª

[22:55] <timotimo> there you go

[22:55] <timotimo> works with one way, as well as the other

[22:55] <hythm> perfect :) Thank you

[22:56] *** nebuchadnezzar left
[22:57] *** nebuchadnezzar joined
[22:57] *** mcmillhj_ left
[22:57] *** mcmillhj left
[23:10] <Geth> ¬¶ doc: b6076e3d53 | (Robert Lemmen)++ | doc/Language/operators.pod6

[23:10] <Geth> ¬¶ doc: add ~ operator for Buf

[23:10] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/b6076e3d53

[23:13] *** marcovorg is now known as margeas

[23:13] *** mcmillhj joined
[23:13] *** mcmillhj_ joined
[23:18] *** mcmillhj_ left
[23:18] *** mcmillhj left
[23:22] *** cpage__ left
[23:22] *** Rawriful left
[23:24] *** cpage_ joined
[23:29] *** Chillance left
[23:32] *** mcmillhj joined
[23:32] *** cdg left
[23:36] *** mcmillhj left
[23:42] *** Cabanossi left
[23:44] *** Cabanossi joined
[23:48] *** cpage_ left
[23:50] *** mcmillhj joined
[23:50] *** mcmillhj_ joined
[23:52] *** Coleoid joined
[23:52] *** skids joined
[23:54] *** mcmillhj_ left
[23:55] *** mcmillhj left
[23:58] *** skids left
