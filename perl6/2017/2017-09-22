[00:00] <AlexDaniel> Juerd: yea. If they want to keep opening issues, then perhaps they should also write code to resolve some of them

[00:00] <Juerd> They are beautifully labeled, though.

[00:00] *** cdg joined
[00:01] <AlexDaniel> I'm running out of colors :)

[00:01] <Juerd> Doesn't matter, it looks very professional

[00:02] *** Cabanossi left
[00:03] *** Cabanossi joined
[00:03] *** wamba joined
[00:04] *** cdg_ left
[00:05] *** cdg left
[00:17] <Geth> ¬¶ whateverable: 9a8b269474 | (Aleks-Daniel Jakimenko-Aleksejev)++ | t/lib/Testable.pm6

[00:17] <Geth> ¬¶ whateverable: Add missing mkdir

[00:17] <Geth> ¬¶ whateverable: 

[00:17] <Geth> ¬¶ whateverable: In case it does not exist yet (e.g. fresh install).

[00:17] <Geth> ¬¶ whateverable: review: https://github.com/perl6/whateverable/commit/9a8b269474

[00:17] <Geth> ¬¶ whateverable: d5fc45d357 | (Aleks-Daniel Jakimenko-Aleksejev)++ | t/lib/Testable.pm6

[00:17] <Geth> ¬¶ whateverable: Use consistent logfile names

[00:17] <Geth> ¬¶ whateverable: 

[00:17] <Geth> ¬¶ whateverable: We use filenames like ‚Äúunicodable_2017-09-19_0117.log‚Äù for regular log

[00:17] <Geth> ¬¶ whateverable: files, so let's use a similar format for other files (this format may

[00:17] <Geth> ¬¶ whateverable: be LTA, but consistency first).

[00:17] <Geth> ¬¶ whateverable: review: https://github.com/perl6/whateverable/commit/d5fc45d357

[00:22] <AlexDaniel> Juerd: well, if you like it‚Ä¶ maybe you can help? üòç

[00:24] <Zoffix> AlexDaniel: do you remember what you meant here by "Bools aren't tested"? https://rt.perl.org/Ticket/Display.html?id=130976#txn-1453512

[00:24] <AlexDaniel> Juerd: I can give you ssh access to the machine with bots and do a quick tutorial on how to hack them

[00:26] <AlexDaniel> Zoffix: okay‚Ä¶ hmmm‚Ä¶ I think I see

[00:26] <AlexDaniel> Zoffix: I was talking about things like a => True and a => False

[00:26] <AlexDaniel> whether this comment makes sense or not I'm not sure

[00:27] <AlexDaniel> but that's what I meant

[00:27] <Zoffix> ok

[00:27] <AlexDaniel> m: say (a=>False,3).perl

[00:27] <camelia> rakudo-moar 045ef4: OUTPUT: ¬´(:!a, 3)‚ê§¬ª

[00:27] <AlexDaniel> m: say (a=>True,3).perl

[00:27] <camelia> rakudo-moar 045ef4: OUTPUT: ¬´(:a, 3)‚ê§¬ª

[00:27] <AlexDaniel> m: say (:!a,3).perl

[00:27] <camelia> rakudo-moar 045ef4: OUTPUT: ¬´(:!a, 3)‚ê§¬ª

[00:27] <AlexDaniel> m: say (:a,3).perl

[00:27] <camelia> rakudo-moar 045ef4: OUTPUT: ¬´(:a, 3)‚ê§¬ª

[00:28] *** kyan joined
[00:28] <AlexDaniel> Zoffix: I guess this includes :a and :!a which is what the OP is about

[00:29] <Juerd> AlexDaniel: Thanks for the offer. Unfortunately I can't.

[00:29] <Juerd> I'm afraid basically all I get around to, regarding Perl 6, is reading the weeklies.

[00:30] <kyan> Zoffix: Sorry to bother you again, but I was wondering, when you mentioned earlier that '`$fail === "f"` is better written as `$fail eq "f"`', I noticed that the suggested version gives a warning if $fail is not defined (it's an optional parameter). Should I test and conditionally explicitly set it to "" if it's unset, and then use eq?

[00:32] <Zoffix> kyan: I'd just set the default to an empty string:  sub foo ($fail = "") {}

[00:32] <Zoffix> kyan: basically `===` is an object identity test, while `eq` tests stringy equality

[00:32] <kyan> Zoffix: Ah, cool, thanks!

[00:32] <Zoffix> kyan: will $fail only ever have one value? If so, I'd just have it as a bool named parameter

[00:33] <kyan> (different copies of the same string are the same object?)

[00:33] <Zoffix> m: sub foo (:$fail) { if $fail { say "has fail" } else { say "no fail" }; foo :fail; foo

[00:33] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> 3} else { say "no fail" }; foo :fail; foo7‚èè5<EOL>‚ê§    expecting any of:‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifier loop‚ê§¬ª

[00:33] <Zoffix> m: sub foo (:$fail) { if $fail { say "has fail" } else { say "no fail" } }; foo :fail; foo

[00:33] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´has fail‚ê§no fail‚ê§¬ª

[00:33] <kyan> ...That's a good idea I hadn't thought of. The bash "everything is a string" philosophy is thoroughly embedded in me, it seems

[00:33] <kyan> Thanks! :)

[00:34] <Zoffix> kyan: yeah, they are, but the intent of the test is less clear with `===` because all ideomatic code would use `eq` for stringy equality

[00:35] <Zoffix> m: say "foo" === "foobar".substr: 0, 3

[00:35] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´True‚ê§¬ª

[00:35] <kyan> cool.

[00:35] <Juerd> Most of the time when you get 42, and you wanted "42", you just want to continue because it'll stringify as "42" just fine.

[00:36] *** geekosaur left
[00:36] *** pilne joined
[00:36] <kyan> If I declare the param as Str $foo, it will get mad at the caller if it gives it a number, though, right?

[00:37] <Zoffix> kyan: right

[00:37] <Juerd> Yes, but you could declare it as Str() $foo, and it'll happily coerce things for you

[00:38] <Juerd> Whether you'd want to do that depends on the use case. If you're just going to display the string, you probably don't really care about type safety. If you're going to build JSON from it, you might.

[00:38] <kyan> Mm, I see. Cool, thanks!

[00:43] *** geekosaur joined
[00:43] <AlexDaniel> Juerd: That's OK, thanks anyway :)

[00:43] *** troys is now known as troys_

[00:47] <AlexDaniel> Juerd: FWIW I'd love to see you during the squashathon (in two weeks). Nowadays I don't have lots of time too, but squashathons are fun

[00:48] <AlexDaniel> Juerd: (pssst, there's free virtual pizza)

[00:58] *** skids left
[00:58] *** cognominal left
[00:59] *** cognominal joined
[01:02] *** mcmillhj left
[01:02] *** skids joined
[01:21] *** geekosaur left
[01:29] *** geekosaur joined
[01:35] *** itaipu joined
[01:48] *** ilbot3 left
[01:49] *** eliasr left
[01:52] *** astj left
[01:53] *** astj joined
[01:53] *** rngoodn joined
[01:53] *** astj left
[01:53] *** astj joined
[01:54] *** ilbot3 joined
[01:54] *** ChanServ sets mode: +v ilbot3

[02:00] *** astj left
[02:01] *** astj joined
[02:02] *** Cabanossi left
[02:03] *** Cabanossi joined
[02:04] *** astj left
[02:05] <skids> .tell Zoffix fail.rakudo.party seems to list some "deleted" tickets, e.g. 131808

[02:05] <yoleaux> skids: I'll pass your message to Zoffix.

[02:06] *** astj joined
[02:08] *** astj left
[02:09] *** astj joined
[02:11] *** astj left
[02:11] *** astj joined
[02:14] <AlexDaniel> .tell MasterDuke I think you were interested in this stuff: https://github.com/rakudo/rakudo/pull/1168

[02:14] <yoleaux> AlexDaniel: I'll pass your message to MasterDuke.

[02:29] *** AlexDani` joined
[02:31] *** AlexDaniel left
[02:32] *** astj left
[02:33] *** zakharyas joined
[02:43] *** cpage_ left
[02:43] *** geekosaur left
[02:44] *** cpage_ joined
[02:44] *** geekosaur joined
[02:45] *** rngoodn left
[02:47] <skids> r-j: class A { has str $.x; method BUILD(:$!x) { } }; say A.new(:x<foo>).x

[02:47] <camelia> rakudo-jvm c3a71a: OUTPUT: ¬´Error while reading '/home/camelia/p6eval-token': No such file or directory at /home/camelia/rakudo-j-inst/bin/eval-client.pl line 10.‚ê§¬ª

[02:47] *** Cabanossi left
[02:48] *** Cabanossi joined
[02:57] *** noganex joined
[03:00] *** noganex_ left
[03:07] <MasterDuke> AlexDani`: thanks, i hadn't seen that

[03:07] <yoleaux> 02:14Z <AlexDaniel> MasterDuke: I think you were interested in this stuff: https://github.com/rakudo/rakudo/pull/1168

[03:07] *** AlexDani` is now known as AlexDaniel

[03:07] *** rngoodn joined
[03:08] *** skids left
[03:13] *** itaipu left
[03:14] *** piojo joined
[03:14] *** piojo_ left
[03:20] *** itaipu joined
[03:22] *** pilne left
[03:27] *** itaipu left
[03:30] *** Cabanossi left
[03:32] *** Cabanossi joined
[03:34] *** astj joined
[03:38] *** troys_ is now known as troys

[03:48] *** tardisx joined
[03:48] *** astj left
[03:49] *** astj joined
[03:49] *** astj left
[03:49] *** astj joined
[03:59] *** khw left
[04:04] *** aborazmeh joined
[04:04] *** BenGoldberg left
[04:05] *** aborazmeh left
[04:05] *** aborazmeh joined
[04:10] *** rngoodn left
[04:13] *** rngoodn joined
[04:23] *** cdg joined
[04:28] *** AlexDaniel left
[04:28] *** cdg left
[04:43] *** troys is now known as troys_

[04:44] *** astj left
[04:44] *** astj joined
[04:45] *** astj left
[04:45] *** astj joined
[04:46] *** Cabanossi left
[04:47] *** astj left
[04:47] *** Cabanossi joined
[04:55] *** llfourn joined
[04:57] *** mr-fooba_ joined
[04:59] *** astj joined
[04:59] *** mr-foobar left
[05:00] *** troys_ is now known as troys

[05:14] *** knobo joined
[05:19] *** ufobat joined
[05:24] *** vendethiel- joined
[05:25] *** Ven`` left
[05:35] *** kyan left
[05:37] *** troys left
[05:39] *** rngoodn left
[05:43] *** wamba left
[05:45] *** Cabanossi left
[05:47] *** Cabanossi joined
[05:53] *** cpage_ left
[05:59] *** andrzejku left
[06:02] *** domidumont joined
[06:08] *** domidumont left
[06:08] *** domidumont joined
[06:15] *** nadim joined
[06:18] <grondilu> m: for <foo>.Mix.pairs X <bar>.Mix.pairs -> ($a, $b) { say "$a, $b" }

[06:18] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´Too few positionals passed to ''; expected 2 arguments but got 0 in sub-signature‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[06:18] *** eliv joined
[06:18] <grondilu> ^not sure what I'm doing wrong here

[06:18] <grondilu> m: for <foo>.Mix.pairs X <bar>.Mix.pairs -> $a, $b { say "$a, $b" }

[06:18] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´Too few positionals passed; expected 2 arguments but got 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[06:18] *** eliv left
[06:20] *** andrzejku joined
[06:31] *** darutoko joined
[06:35] *** wamba joined
[06:39] *** cdg joined
[06:41] *** eliv joined
[06:42] *** eliv left
[06:43] <grondilu> m: for :a X :b -> ($i, $j) { say "$i $j" }

[06:43] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´Too few positionals passed to ''; expected 2 arguments but got 0 in sub-signature‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[06:43] *** robertle left
[06:43] <grondilu> m: for :a X :b -> $i, $j { say "$i $j" }

[06:43] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´Too few positionals passed; expected 2 arguments but got 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[06:43] <grondilu> wth

[06:44] <grondilu> m: for <a> X <b> -> ($i, $j) { say "$i $j" }

[06:44] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´a b‚ê§¬ª

[06:44] *** cdg left
[06:44] <moritz> I guess X doesn't expect named arguments, but rather positional ones

[06:44] <grondilu> m: for (:a,) X (:b,) -> $i, $j { say "$i $j" }

[06:44] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´Too few positionals passed; expected 2 arguments but got 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[06:44] <grondilu> m: for (:a,) X (:b,) -> ($i, $j) { say "$i $j" }

[06:44] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´Too few positionals passed to ''; expected 2 arguments but got 0 in sub-signature‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[06:45] *** aborazmeh left
[06:45] <grondilu> m: for [:a] X [:b] -> ($i, $j) { say "$i $j" }

[06:45] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´Too few positionals passed to ''; expected 2 arguments but got 0 in sub-signature‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[06:45] <grondilu> jeez

[06:46] <grondilu> m: for $:a X $:b -> ($i, $j) { say "$i $j" }

[06:46] <camelia> rakudo-moar 3da62d: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Cannot use placeholder parameter $:a outside of a sub or block‚ê§at <tmp>:1‚ê§------> 3for $:a7‚èè5 X $:b -> ($i, $j) { say "$i $j" }‚ê§¬ª

[06:46] <grondilu> meh

[06:46] *** cpage_ joined
[06:47] *** ken2 joined
[06:48] *** eliv joined
[06:51] *** araujo left
[06:52] *** piojo left
[06:53] *** araujo joined
[06:53] *** araujo left
[06:53] *** araujo joined
[06:54] *** raschipi joined
[06:54] *** nadim left
[07:03] *** setty1 joined
[07:12] *** llfourn_ joined
[07:15] *** llfourn left
[07:24] *** rindolf joined
[07:33] *** ponbiki left
[07:34] *** ponbiki joined
[07:46] *** Cabanossi left
[07:47] *** Cabanossi joined
[07:56] *** Ven`` joined
[07:56] *** vendethiel- left
[08:01] *** imcsk8 left
[08:01] *** imcsk8 joined
[08:04] *** mithaldu_ left
[08:04] *** leont joined
[08:04] *** Praise left
[08:04] *** jantore left
[08:04] *** mithaldu_ joined
[08:04] *** tony-o left
[08:05] *** jantore joined
[08:05] *** awwaiid left
[08:05] *** wamba left
[08:05] *** huf left
[08:05] *** Praise joined
[08:05] *** Praise left
[08:05] *** Praise joined
[08:05] *** wamba joined
[08:06] *** mtj_ left
[08:06] *** gfldex left
[08:06] *** huf joined
[08:06] *** gfldex joined
[08:06] *** xinming left
[08:06] *** tokik left
[08:06] *** tony-o joined
[08:06] *** awwaiid joined
[08:07] *** ChoHag left
[08:07] *** raschipi left
[08:08] *** tokik joined
[08:08] *** aindilis left
[08:08] *** ChoHag joined
[08:08] *** jcallen_ joined
[08:08] *** jcallen left
[08:11] *** aindilis joined
[08:14] *** xinming joined
[08:20] *** mtj_ joined
[08:24] *** vendethiel- joined
[08:25] *** Ven`` left
[08:25] *** fluca1978 joined
[08:26] <fluca1978> I have a doubt about "is rw" class member access: class Foo { has $.bar is rw; }

[08:26] <tyil> has `set()` from Bailador changed?

[08:27] <fluca1978> Foo.new.bar = 'Hello'; is this an lvalue method call or a variable access?

[08:27] <moritz> Foo.new.bar returns a so-called "container"

[08:27] <moritz> and = assigns a value to it

[08:28] <moritz> which only works if method bar returns a writable container

[08:28] <moritz> (and container sits between variable (which is a syntactic element) and the value)

[08:29] <fluca1978> moritz: so it is like a container is a reference to the variable within the object instance, something alike?

[08:30] <moritz> fluca1978: it's the other way round

[08:30] <moritz> a variable contains a reference to a container

[08:30] *** leont left
[08:30] <moritz> and when you assign to a variable, you update the value that's stored in the container

[08:31] <fluca1978> moritz: therefore "bar" points (allow me the term) to a container, and each time Foo::bar is called such container is returned. the variable therefore is a kind of refence itself, right?

[08:32] <moritz> fluca1978: yes

[08:32] <moritz> (with the small caveat that the method isn't Foo::bar; that would be a subroutine)

[08:33] <ufobat> tyil, nope, do you have any problems?

[08:33] <fluca1978> moritz: is this true only for classes variables or for any variable in Perl 6?

[08:34] <moritz> fluca1978: for all variables

[08:34] <tyil> ufobat: set() doesnt seem to actually set anything in my latest script, yet it works as expected in an older project of mine

[08:34] <tyil> if I `set("host", "127.1")` it still hosts on 0.0.0.0

[08:35] <fluca1978> moritz:thanks a lot

[08:36] <tyil> ufobat: also, trying to set `config.host = "127.1"` results in undeclared routine

[08:37] <tyil> (yes, I have `use Bailador`)

[08:37] <ufobat> [~/.workspace/p6/Bailador] - [Fr Sep 22, 10:37]

[08:37] <ufobat> ‚îî‚îÄ[$] <git:(dev*)> perl6 -Ilib -e 'use Bailador; set("host", "127.1.2.3"); dd config.host'

[08:37] <ufobat> Str $!host = "127.1.2.3"

[08:38] <ufobat> do you have a older version installed? i tested it against "dev"

[08:38] <ufobat> i also tested it against 0.0.12

[08:40] *** cdg joined
[08:40] *** robertle joined
[08:42] <tyil> I though I was on 0.0.12 too, zef upgrade Bailador seems to fail with "o such method 'dist' for invocant of type 'Any'. Did you mean any of these?"

[08:43] <ufobat> --verbose, maybe?

[08:44] *** cdg left
[08:45] <tyil> that doesnt give more output than before

[08:45] <tyil> just some suggestions and a backtrace

[08:46] <ufobat> does the backtrace help? i dont know what's wrong :(

[08:46] <tyil> idk either

[08:47] <tyil> I'll try a zef install --force Bailador see if that helps anything

[08:47] <tyil> ===> Fetching [FAIL]: Bailador:ver('0.0.12') from git://github.com/Bailador/Bailador.git

[08:47] <tyil> welp

[08:50] <ufobat> i dont know how verions and github work, Bailador is also on cpan. on my box zef takes it from there

[08:50] <ufobat> ===> Found: Bailador:ver<0.0.12> [via Zef::Repository::Ecosystems<cpan>]

[08:50] *** fluca1978 left
[08:58] <tyil> ugh, I'll take a look at it again at a later date

[09:13] *** lowbro joined
[09:13] *** lowbro left
[09:13] *** lowbro joined
[09:25] *** piojo joined
[09:28] *** gfldex_work joined
[09:31] *** eliasr joined
[09:32] *** gfldex_work left
[09:44] *** wamba left
[09:46] *** Cabanossi left
[09:47] *** Cabanossi joined
[09:52] *** dustinm` left
[09:56] *** wamba joined
[09:57] *** dustinm` joined
[09:59] *** margeas joined
[10:01] *** TEttinger left
[10:07] *** zakharyas left
[10:07] *** zakharyas joined
[10:08] *** astj left
[10:11] *** zakharyas left
[10:17] <Zoffix> .

[10:17] <yoleaux> 02:05Z <skids> Zoffix: fail.rakudo.party seems to list some "deleted" tickets, e.g. 131808

[10:17] <Zoffix> yes it does

[10:19] *** hkaimenas joined
[10:19] <Zoffix> RT's API doesn't report deletions as status changes, so unless you fetch the thousand+ of tickets (slow as hell), you keep the deleted

[10:25] <Zoffix> (and yes, there's a way to toss deletions by, say, fetching the 1000+ tickets every 24 hours, but I haven't had the time to code that: https://github.com/zoffixznet/r6 )

[10:36] *** jonas1 joined
[10:40] <mspo> did 09 come out?

[10:41] <mspo> rakudo.org has stalled in blog posts

[10:42] <mspo> oh maybe not

[10:43] <Zoffix> mspo: yes, but compiler releases are only announced on the compiler mailing list. There's no .09 Rakudo Star

[10:43] <mspo> oh there's a moar 09.1

[10:43] <Zoffix> huggable: debs

[10:43] <huggable> Zoffix, CentOS, Debian, Fedora and Ubuntu Rakudo packages: https://github.com/nxadm/rakudo-pkg/releases

[10:51] <Zoffix> huggable: star

[10:51] <huggable> Zoffix, Estimated Rakudo Star releases for 2017: .01, .04, .07 & .10

[11:00] *** eliv left
[11:01] *** itaipu joined
[11:03] *** eliv joined
[11:14] *** skids joined
[11:18] *** hkaimenas left
[11:20] *** skids left
[11:21] *** wamba left
[11:23] *** piojo left
[11:26] *** rgrau joined
[11:31] *** Cabanossi left
[11:32] *** Cabanossi joined
[11:34] *** cdg joined
[11:39] *** cdg left
[11:48] *** vendethiel- left
[11:48] *** llfourn_ left
[11:52] *** ShalokShalom_ joined
[11:53] *** domidumont left
[11:54] *** domidumont joined
[11:55] *** ShalokShalom left
[11:59] *** ken2 left
[12:01] *** ken2 joined
[12:07] *** eliv left
[12:07] *** eliv joined
[12:10] *** eliv left
[12:11] *** eliv joined
[12:12] *** piojo joined
[12:24] *** rngoodn joined
[12:25] *** wamba joined
[12:30] *** Cabanossi left
[12:32] *** Cabanossi joined
[12:35] *** n0tjack joined
[12:37] <n0tjack> We're having a mini idiom showcase in our language nerd channel at work ... what's the prettiest and most idiomatic way to express the volume of a N-ball in Perl6? That is, pi^(n/2) / gamma(n/2 - 1) where gamma is the generalized factorial?

[12:42] <DrForr> Well, Gamma(1/2-n)=(pi**1/2)/((n**-1/2)*(n!) and of course Gamma(1/2)=pi**(1/2)

[12:45] *** ken2 left
[12:45] *** ken1 joined
[12:45] <TimToady> see also https://rosettacode.org/wiki/Gamma_function#Perl_6

[12:45] <n0tjack> oh,  nice

[12:45] <n0tjack> just what I needed, thanks guys

[12:48] <n0tjack> TimToady: what's with the constants in that function? Just for faster convergence? Why not a closed form function?

[12:50] <TimToady> rakudo doesn't always do things quite at the right time for that yet

[12:51] *** eliv left
[12:51] *** ken1 is now known as thunktone

[12:52] *** reu left
[12:53] <n0tjack> does p6 have a polynomial application function which takes a series of coefficients and produces the sum of the product of those coefficients with successively greater powers of a value, or should I roll my own with [+] and Z* ? 

[12:53] *** wamba left
[12:54] <DrForr> Maybe polymod does what you're after?

[12:55] <TimToady> that's the other direction

[12:55] <timotimo> so polyproduct :)

[12:55] <perlpilot> There's http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation#Perl_6

[12:57] <TimToady> m: say :10[4,3,2,1]

[12:57] <camelia> rakudo-moar d8890a: OUTPUT: ¬´4321‚ê§¬ª

[12:57] <TimToady> maybe that, or the function under it

[12:57] *** cdg joined
[12:59] <n0tjack> whoa, [o] is cool

[12:59] <n0tjack> never thought of that

[13:00] <perlpilot> Maybe someone needs to write a short-ish "Perl¬†6 for Mathematicians" or something

[13:00] <perlpilot> :-)

[13:00] <TimToady> I guess the underlying function as the un-pretty name of &UNBASE_BRACKET

[13:00] <TimToady> *has

[13:02] *** skids joined
[13:02] *** ShalokShalom_ is now known as ShalokShalom

[13:04] *** cdg_ joined
[13:04] *** HoboWithAShotgun joined
[13:05] <HoboWithAShotgun> good afternoon you lovely people

[13:06] <Zoffix> \o

[13:07] <n0tjack> perlpilot: I think a Perl6 module for generating OEIS sequences, including recipes and idioms for common patterns is a worthwhile exercise

[13:08] *** cdg left
[13:08] <n0tjack> I may never get around to it

[13:08] <n0tjack> but it's a neat idea

[13:09] *** geekosaur left
[13:10] <HoboWithAShotgun> the docs say this would be nyi

[13:10] <HoboWithAShotgun> m: my &s = sub (Int $a where * < 0) { say $a; }; &s(-1);

[13:10] <camelia> rakudo-moar d8890a: OUTPUT: ¬´-1‚ê§¬ª

[13:10] <timotimo> what part of it?

[13:11] <HoboWithAShotgun> https://docs.perl6.org/type/Callable

[13:11] <HoboWithAShotgun> the anonymous signature

[13:11] <HoboWithAShotgun> or closure with signature

[13:11] <Zoffix> HoboWithAShotgun: the one with `my &f:(Int)` parts?

[13:11] <HoboWithAShotgun> yup

[13:12] <Zoffix> m: my &s:(Int) = sub (Int{ say $a; }; &s(-1);

[13:12] <camelia> rakudo-moar d8890a: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§You can't adverb &s‚ê§at <tmp>:1‚ê§------> 3my &s:(Int)7‚èè5 = sub (Int{ say $a; }; &s(-1);‚ê§¬ª

[13:12] *** mcmillhj joined
[13:12] <HoboWithAShotgun> nevermind i overlooked the :(Int) part 

[13:12] <HoboWithAShotgun> :-/

[13:16] *** mr-foobar joined
[13:17] *** mr-fooba_ left
[13:17] <Geth> ¬¶ doc: 3ecad59a15 | (Zoffix Znet)++ (committed using GitHub Web editor) | doc/Type/IO/Socket/INET.pod6

[13:17] <Geth> ¬¶ doc: Use constants for sock family

[13:17] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/3ecad59a15

[13:19] *** geekosaur joined
[13:20] <Zoffix> .oO( üéú üéù We‚ÄîAre‚ÄîFaaaamilyyyy )

[13:21] <DrForr> Hopefully the package name isn't ClothesDryer.

[13:22] <Zoffix> huh, PF_INET isn't a constant, it's an enum, yet they're constants here: https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Socket/INET.pm#L3-L18

[13:22] * Zoffix bets there's a duplicate set of enums somewhere

[13:23] <Zoffix> Yup :( https://github.com/rakudo/rakudo/blob/nom/src/core/IO.pm#L11-L17

[13:23] <eater> those are also wrong D:

[13:27] *** gregf_ left
[13:27] <HoboWithAShotgun> i just learned that say 2.&g.&f; and say f( g(3) ); is equivalent, but why? i mean the functions clearly are not methods of some Int

[13:28] <HoboWithAShotgun> 2 and 2, not 2 and 3

[13:28] <Zoffix> HoboWithAShotgun: $foo.&g($bar) is equivalent to g($foo, $bar)

[13:29] <moritz> it's just a syntactic construct to invoke a subroutine

[13:29] <Zoffix> (more or less; there seem to be differences that mess with the Failures; there's a ticket for it)

[13:29] <HoboWithAShotgun> ah, i see. 

[13:30] <HoboWithAShotgun> m: class foo { sub bar( $self ) { $self.baz }; sub baz { say "hi" } }; foo.new.bar;

[13:30] <camelia> rakudo-moar d8890a: OUTPUT: ¬´No such method 'bar' for invocant of type 'foo'‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[13:31] <HoboWithAShotgun> allright, but assuming the dot would resolve then this would work

[13:32] <Zoffix> HoboWithAShotgun: subs are lexical by default. Also, you're missing the `&`

[13:32] <Zoffix> m: class foo { our sub bar( $self ) { $self.baz }; sub baz { say "hi" } }; foo.new.&bar;

[13:32] <camelia> rakudo-moar 73aeee: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    bar used at line 1. Did you mean 'VAR', 'bag'?‚ê§‚ê§¬ª

[13:32] <Zoffix> hmmm

[13:32] <Zoffix> oh

[13:33] <Zoffix> Well, not oh, but I see `&` is also missing on baz... Weird it's saying bar is undeclared tho

[13:33] *** reu joined
[13:34] <Zoffix> m: class foo { sub bar( $self ) is export { $self.&baz }; sub baz ($) { say "hi" } }; import foo; foo.new.&bar;

[13:34] <camelia> rakudo-moar 73aeee: OUTPUT: ¬´hi‚ê§¬ª

[13:34] <Zoffix> hm, there's something I don't understand about symbols :/

[13:34] <HoboWithAShotgun> dont bother. this was just to see wether i got that first argument thing right in my head

[13:34] <Zoffix> I still want to know what I missing :)

[13:35] <Zoffix> m: class { our sub foo { 42.say } }; foo

[13:35] <camelia> rakudo-moar 73aeee: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    foo used at line 1‚ê§‚ê§¬ª

[13:35] <Zoffix> I thought `our` would make `foo` available where I'm calling it

[13:36] <Zoffix> m: class Foo { our sub foo { 42.say } }; Foo::foo

[13:36] <camelia> rakudo-moar 73aeee: OUTPUT: ¬´42‚ê§¬ª

[13:36] <Zoffix> There's the missing piece :D

[13:36] <moritz> m: class { our sub foo { 42.say }.WHO

[13:36] <camelia> rakudo-moar 73aeee: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> 3class { our sub foo { 42.say }.WHO7‚èè5<EOL>‚ê§    expecting any of:‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifier loop‚ê§¬ª

[13:36] <moritz> m: class { our sub foo { 42.say }}.WHO

[13:36] <camelia> rakudo-moar 73aeee: ( no output )

[13:36] <moritz> m: class { our sub foo { 42.say }}.WHO<&foo>

[13:36] <Zoffix> m: class Foo { our sub bar( $self ) { $self.&baz }; sub baz ($) { say "hi" } }; Foo.new.&Foo::bar;

[13:36] <camelia> rakudo-moar 73aeee: ( no output )

[13:36] <camelia> rakudo-moar 73aeee: OUTPUT: ¬´hi‚ê§¬ª

[13:36] <moritz> m: class { our sub foo { 42.say }}.WHO<&foo>()

[13:36] <camelia> rakudo-moar 73aeee: OUTPUT: ¬´42‚ê§¬ª

[13:36] <Zoffix> :)

[13:36] <moritz> that's how you can call an our-sub from an anonymous package

[13:37] <Zoffix> Neat

[13:37] <moritz> though why anybody would put an our-sub into an anon class is anybody's guess :-)

[13:37] <HoboWithAShotgun> nevertheless it is covered

[13:38] <HoboWithAShotgun> which probably tells us something

[13:39] <moritz> that jnthn++ designed the types and package table system really well? :-)

[13:39] <HoboWithAShotgun> this pony tailed late hippy, yeah

[13:39] <HoboWithAShotgun> i love his talks

[13:41] *** mephinet joined
[13:41] *** piojo left
[13:41] <HoboWithAShotgun> when he talks, there is this hint of pride in his voice, yet he is too humble to show it :-)

[13:41] <HoboWithAShotgun> fully i mean

[13:42] *** mr-fooba_ joined
[13:42] *** piojo joined
[13:43] *** mr-foobar left
[13:44] <HoboWithAShotgun> speaking of talks, did you guys watch damians "three little words"?

[13:45] *** Cabanossi left
[13:47] *** Cabanossi joined
[13:59] *** HoboWithAShotgun left
[14:01] *** thunktone left
[14:03] *** thunktone joined
[14:21] *** itaylor57 left
[14:21] *** HoboWithAShotgun joined
[14:21] *** itaylor57 joined
[14:28] *** nekomune joined
[14:30] *** geekosaur left
[14:31] *** Cabanossi left
[14:31] *** lowbro left
[14:32] *** khw joined
[14:32] *** wander4096 joined
[14:32] *** Cabanossi joined
[14:35] <wander4096> can i just compile p6-code but not execute it?

[14:35] <wander4096> like when works on java, it is separated into `javac` and `java`

[14:36] <wander4096> i want to do `rakudo-c`, not the whole `perl6 ...`

[14:37] *** geekosaur joined
[14:40] <DrForr> You might be able to use --target= in order to just do the precompile.

[14:41] <DrForr> I don't see any other options in the main perl6 binary, though there's also a -o that might aid in things.

[14:41] <wander4096> i try this command `perl6 main.p6 --target=jvm`

[14:41] <wander4096> it just runs the code

[14:42] *** piojo left
[14:42] <wander4096> no files look like bytecode file generated

[14:42] <DrForr> Right, --target accepts a compilation stage, probably not the VM to compile against.

[14:42] <jnthn> I'd have to be --target=jar --output=SomeFile.jar I guess

[14:43] <jnthn> Though I don't know if it will produce something that will run directly

[14:44] <wander4096> it seems that -o option has no effect

[14:44] *** piojo joined
[14:45] <wander4096> run `perl6 main.p6 -o=main` but file `main` wasn't generated

[14:46] <DrForr> That may not be the intent of the -o option, I was simply reading the output of 'perl6 -h'.

[14:46] *** HoboWithAShotgun left
[15:01] *** Cabanossi left
[15:02] *** Cabanossi joined
[15:02] *** cdg_ left
[15:03] *** Sgeo_ joined
[15:03] *** cdg joined
[15:05] *** Sgeo left
[15:06] *** cdg_ joined
[15:06] <nekomune> i'm having trouble figuring out how i can pass an array as an argument to a function expecting a NativeCall Pointer argument.

[15:07] <nekomune> is there a way I can reference this array through a pointer?

[15:08] *** cdg left
[15:09] *** troys joined
[15:12] *** wander4096 left
[15:13] *** mcmillhj left
[15:14] <ugexe> wander4096: its `perl6-j --target=jar --output=SomeFile.jar main.p6`. but you still need a perl6 entry point to run it i believe

[15:17] <ugexe> before you were running your main.p6 script and passing the script itself the -o=main

[15:37] <Zoffix> nekomune: don't know anything about NativeCall, but I see a section on Arrays in the docs. Perhaps that'll be of help: https://docs.perl6.org/language/nativecall#Arrays

[15:37] *** mcmillhj joined
[15:40] <nekomune> Zoffix: If I use NativeCall's CArray instead, I would still get something like: expected NativeCall::Types::Pointer but got Array ($[NativeCall::Types::...)

[15:40] <Zoffix> No idea, sorry.

[15:41] <nekomune> np, i'll still try to figure this out.

[15:42] *** Aaronepower joined
[15:42] <nekomune> I've seen https://docs.perl6.org/language/nativecall#Basic_use_of_Pointers as well, but it only goes into dealing with pointers returned from a native call.

[15:42] <nekomune> there's even a helper function 'nativecast'

[15:42] <nekomune> but not much about the other way around...

[15:43] *** gregf_ joined
[15:43] <Aaronepower> Hello, is there a way to use Grammars? Like call another grammar as part of a rule?

[15:43] <Aaronepower> re use*

[15:47] *** eliv joined
[15:48] *** geekosaur left
[15:48] *** cdg_ left
[15:49] *** domidumont left
[15:49] *** cdg_ joined
[15:49] *** geekosaur joined
[15:49] *** cdg_ left
[15:49] <perlpilot> m: grammar A { token foo { "foo" } };  grammar B { token TOP { <A::foo> } }; say B.parse("foo");

[15:49] <camelia> rakudo-moar f58ac9: OUTPUT: ¬´ÔΩ¢fooÔΩ£‚ê§ A::foo => ÔΩ¢fooÔΩ£‚ê§¬ª

[15:49] *** cdg_ joined
[15:50] *** cdg__ joined
[15:50] *** geekosaur left
[15:50] <Zoffix> They're just classes. All the same benefits apply. You can even mix in roles

[15:51] <Zoffix> m: role A { token foo { "foo" } };  grammar B does A { token TOP { <foo> } }; say B.parse("foo");

[15:51] <camelia> rakudo-moar c46de0: OUTPUT: ¬´ÔΩ¢fooÔΩ£‚ê§ foo => ÔΩ¢fooÔΩ£‚ê§¬ª

[15:51] *** geekosaur joined
[15:52] <Aaronepower> Sorry I think I wasn't clear. I don't want to use methods from another grammar I want to call the whole grammar.

[15:52] <Aaronepower> m: grammar A { token foo { "foo" } };  grammar B { token TOP { <A> } }; say B.parse("foo");

[15:53] <camelia> rakudo-moar c46de0: OUTPUT: ¬´No such method 'A' for invocant of type 'B'‚ê§  in regex TOP at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[15:53] *** jonas1 left
[15:53] *** cdg_ left
[15:54] <Zoffix> Aaronepower: just use the entry token instead of <A> (so, it'd be <A::TOP> for common case)

[15:54] <perlpilot> m: grammar A { token TOP { "foo" } }; grammar B { token TOP { <A::TOP> } }; say B.parse("foo");

[15:54] <camelia> rakudo-moar c46de0: OUTPUT: ¬´ÔΩ¢fooÔΩ£‚ê§ A::TOP => ÔΩ¢fooÔΩ£‚ê§¬ª

[15:55] <Zoffix> .parse just uses TOP as default; it's changeable

[15:55] <Zoffix> m: grammar B { token meows { "foo" } }; say B.parse: "foo", :rule<meows>;

[15:55] <camelia> rakudo-moar c46de0: OUTPUT: ¬´ÔΩ¢fooÔΩ£‚ê§¬ª

[15:55] <perlpilot> Aaronepower: so ... why do you want to 'call the whole grammar' from within a rule of another grammar?

[15:56] <Aaronepower> perlpilot: Because I want to call A on it's own as well.

[15:59] *** astj joined
[15:59] *** troys is now known as troys_

[16:00] *** Cabanossi left
[16:01] *** geekosaur left
[16:01] *** nadim joined
[16:01] *** robertle left
[16:02] *** Cabanossi joined
[16:03] *** astj left
[16:04] *** eliv left
[16:07] <Aaronepower> Is there a way to concat hashs? Like `{foo => 1} + {bar => 2} = {foo => 1, bar => 2}`?

[16:07] *** geekosaur joined
[16:08] <perlpilot> Aaronepower: what do you want to happen with same-named keys ?

[16:09] <Aaronepower> perlpilot: Can't happen in my case.

[16:09] <Aaronepower> As in there will never be a conflict.

[16:10] <perlpilot> m: my %h = foo => 24; my %g = bar => 42;  say %h.push(%g);

[16:10] <camelia> rakudo-moar c46de0: OUTPUT: ¬´{bar => 42, foo => 24}‚ê§¬ª

[16:10] <perlpilot> m: my %h = foo => 24, bar => 87; my %g = bar => 42;  say %h.push(%g);

[16:10] <camelia> rakudo-moar c46de0: OUTPUT: ¬´{bar => [87 42], foo => 24}‚ê§¬ª

[16:10] <perlpilot> (note what happens if there are dups)

[16:12] *** roguelazer left
[16:14] *** HoboWithAShotgun joined
[16:14] <perlpilot> Aaronepower: I suppose I should have mentioned the simpler:   %x = %h, %g;   #  :-)

[16:14] *** roguelazer joined
[16:14] <perlpilot> m: my %h = foo => 24, bar => 87; my %g = bar => 42; my %x = %h, %g;  say %h

[16:14] <camelia> rakudo-moar c46de0: OUTPUT: ¬´{bar => 87, foo => 24}‚ê§¬ª

[16:14] <perlpilot> m: my %h = foo => 24, bar => 87; my %g = bar => 42; my %x = %h, %g;  say %x

[16:14] <camelia> rakudo-moar c46de0: OUTPUT: ¬´{bar => 42, foo => 24}‚ê§¬ª

[16:16] <hythm> Hello, I'm trying to use IoC module in another module, but I get Undeclared routine when I' try to use IoC routine. Here is a gist, What I'm doing wrong? https://gist.github.com/hythm7/aabc37aa540b30f71025d2834380e86f

[16:17] *** troys_ is now known as troys

[16:19] <perlpilot> hythm: A::IoC doesn't automatically export routines from IoC;

[16:19] <Aaronepower> Zoffix: How would I call the Actions object on that grammar?

[16:20] <hythm> perlpilot: is there a way I can tell A::I0C to export them, or it has to be exported in IoC module at first?

[16:20] <hythm> s/0/o/

[16:21] <perlpilot> hythm: there's https://docs.perl6.org/language/modules#index-entry-sub_EXPORT

[16:21] *** piojo left
[16:21] *** Sgeo_ left
[16:22] *** jameslenz joined
[16:22] <hythm> Thanks perlpilot, checking that

[16:27] <perlpilot> hythm: you'll probably have to change lib-A-IoC.pm to no longer use `unit`.

[16:28] *** Aaronepower left
[16:28] *** Aaronepower joined
[16:28] <perlpilot> hythm: something like:  use IoC; sub EXPORT { %(IoC::EXPORT::DEFAULT::); } module A::IoC { sub setup-ioc is export {} }

[16:28] * perlpilot is having a sloooow day today

[16:29] *** thunktone left
[16:30] *** thunktone joined
[16:31] <Aaronepower> How do you call The Actions object on Grammar inside another grammar? `grammar Foo { token TOP { foo } } class FooActions { method TOP($/) { 1 } } grammar Bar {token TOP { <Foo::TOP> } } class BarActions { method TOP { make $<Foo::TOP>.made } }`

[16:31] <hythm> perlpilot: That worked great, thanks.

[16:31] *** domidumont joined
[16:32] *** ufobat left
[16:33] <grondilu> m: say Inf ~~ Num; say Inf ~~ Int

[16:33] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§False‚ê§¬ª

[16:33] <grondilu> :/

[16:33] <Aaronepower> How could have it so `Bar.parse("foo", actions => BarActions).made` returns 1?

[16:33] <Aaronepower> grondilu: Inf is a Float no?

[16:33] * grondilu wanted to extend an integer index to infinity with Inf, but learnt that Inf is not an Int 

[16:33] <grondilu> Aaronepower: apparently

[16:34] *** astronavt joined
[16:34] <grondilu> I suppose it's the IEEE-754 (IIRC) floating point value or something

[16:34] <Aaronepower> grondilu: An Int can only go up to 2147483647.

[16:35] <grondilu> I don't think so

[16:35] <grondilu> no in Perl 6

[16:35] <grondilu> *not

[16:35] <grondilu> an Int is not an int

[16:35] <Zoffix> Inf is a Num

[16:35] <Zoffix> Yeah, we follow IEEE 754-2008 (with some parts yet to be stuffed into 6.d language release)

[16:35] <perlpilot> Aaronepower: I don't think that you do.  At least not without calling Foo.parse(‚Ä¶)   You'd have to have the Bar grammar slurp up enough of its input to feed to Foo though.

[16:36] <Zoffix> m: say 0/0

[16:36] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Attempt to divide by zero using div‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[16:36] <grondilu> m: say 1/0

[16:36] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Attempt to divide 1 by zero using div‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[16:36] <Zoffix> m: .Num.say for 1/0, -1/0, 0/0

[16:36] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Inf‚ê§-Inf‚ê§NaN‚ê§¬ª

[16:36] <Zoffix> You need Num view to get IEEE semantics

[16:36] <Aaronepower> perlpilot: Is there no way to pass $<Foo::TOP> to FooActions?

[16:37] <grondilu> Kind of annoying I can't have a version of Inf that is Int :/

[16:37] <Aaronepower> perlpilot: Like in BarActions

[16:37] <grondilu> it would have been elegant in my code

[16:38] *** mcmillhj left
[16:38] <grondilu> m: say Inf.Int

[16:38] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Cannot coerce Inf to an Int‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[16:38] <grondilu> :P

[16:39] <Aaronepower> grondilu: It wouldn't really make sense though, as Int isn't supposed to represent entire spectrum of numbers.

[16:39] <Zoffix> Yeah. There might be something borne out of it in 6.* release, but last we thought of making Inf an Int and a Num it sounded like a bad idea

[16:39] <grondilu> Aaronepower: it could though, couldn't it?

[16:40] <Zoffix> There are lots of places where an arg could be Int number OR an * (Inf) and just because of that extra condition you can't use a native int (well, without multi dispatch)

[16:40] <Zoffix> Well, not can't, but it's extra hassle and extra lost CPU cycles

[16:41] <Aaronepower> grondilu: In the same way that an Int could hold floating point numbers. Int implies a lot about how the number works and how to add and sub from it.

[16:42] <grondilu> I suppose I may create a subset of Real

[16:42] <grondilu> m: subset Intish of Real where { $_ ~~ Int or $_ ~~ Inf }

[16:42] <camelia> rakudo-moar c46de0: ( no output )

[16:42] <perlpilot> Aaronepower: If you were using roles, you could compose the Foo role into the Bar grammar and FooActions role into the BarActions class. 

[16:42] <grondilu> m: subset Intish of Real where { $_ ~~ Int or $_ ~~ Inf }; say Inf ~~ Intish

[16:42] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§¬ª

[16:43] * grondilu is not too happy about the name "Intish" though

[16:43] <perlpilot> Aaronepower: and to use Foo stand-alone you'd have to make a FooOnly grammar and a FooActionsOnly class that are empty except for composing the roles

[16:44] <thunktone> Surely you could call it "Integer" if you want?

[16:44] <Aaronepower> perlpilot: But Is there no way of saying something like `FooActions.new($<Foo::TOP>)` in the BarActions method?

[16:44] <grondilu> m: say Inf ~~ Real # just checking

[16:44] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§¬ª

[16:44] <grondilu> thunktone: yeah, "Integer" should do

[16:45] <Zoffix> m: say Int.Range

[16:45] <camelia> rakudo-moar c46de0: OUTPUT: ¬´-Inf^..^Inf‚ê§¬ª

[16:46] *** robertle joined
[16:46] <Zoffix> m: say int.Range

[16:46] <camelia> rakudo-moar c46de0: OUTPUT: ¬´-9223372036854775808..9223372036854775807‚ê§¬ª

[16:47] <thunktone> So Int goes up to infinity minus one?

[16:47] <perlpilot> Aaronepower: I can't think of one, but my brain power isn't very reliable today for some reason  :)

[16:47] *** AlexDaniel joined
[16:48] <Zoffix> thunktone: no, it goes up to infinity without including infinity itself

[16:48] <Zoffix> m: say Inf - 1; # "minus one" is still infinity

[16:48] *** AlexDaniel left
[16:48] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Inf‚ê§¬ª

[16:49] <Zoffix> m: say eager 1.3..^2.5; # the ^ means exclude the endpoint, not minus one, even for non-Inf

[16:49] <camelia> rakudo-moar c46de0: OUTPUT: ¬´(1.3 2.3)‚ê§¬ª

[16:50] <Zoffix> You know what would be a good use for that .Bridge method? It takes an arg and returns appropriate matching arg

[16:50] <Zoffix> m: class InfI is Num is Int { method Bridge { 42 }  }; say 0e0 + InfI

[16:50] <camelia> rakudo-moar c46de0: OUTPUT: ¬´42‚ê§¬ª

[16:50] <Zoffix> m: class InfI is Num is Int { method Bridge { 42 }  }; say 0 + InfI

[16:50] <camelia> rakudo-moar c46de0: OUTPUT: ¬´42‚ê§¬ª

[16:50] <Zoffix> Like here, it'd receive 0 or 0e0 and return appropriate value

[16:50] *** AlexDaniel joined
[16:52] *** lichtkind joined
[16:52] <grondilu> m: subset Int‚àû of Real where { $_ ~~ Int or $_ ~~ Inf }

[16:52] <camelia> rakudo-moar c46de0: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Bogus postfix‚ê§at <tmp>:1‚ê§------> 3subset Int7‚èè5‚àû of Real where { $_ ~~ Int or $_ ~~ Inf‚ê§    expecting any of:‚ê§        infix‚ê§        infix stopper‚ê§        postfix‚ê§        statement end‚Ä¶¬ª

[16:52] * grondilu thought Int‚àû would be an allowed identifier for some reason

[16:53] <Zoffix> m: sub infix:<+> { &CORE::infix:<+>($^a, $^b.Bridge: $a) };  class InfI is Num is Int { method Bridge($v) { $v ~~ Int ?? int.Range.max !! Inf }  }; say 0e0 + InfI

[16:53] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Inf‚ê§¬ª

[16:53] <Zoffix> m: sub infix:<+> { &CORE::infix:<+>($^a, $^b.Bridge: $a) };  class InfI is Num is Int { method Bridge($v) { $v ~~ Int ?? int.Range.max !! Inf }  }; say 0 + InfI

[16:53] <camelia> rakudo-moar c46de0: OUTPUT: ¬´9223372036854775807‚ê§¬ª

[16:53] <Zoffix> Like that

[16:53] <Zoffix> ‚àû is not a valid identifier

[16:53] <Zoffix> u: ‚àû

[16:53] <unicodable6> Zoffix, U+221E INFINITY [Sm] (‚àû)

[16:54] <Zoffix> Need a Lu Ll Nd - or '

[16:54] <grondilu> ol

[16:54] <grondilu> *ok

[16:54] <grondilu> wasn't it used as an alias for Inf, though?

[16:54] <grondilu> m: say ‚àû

[16:54] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Inf‚ê§¬ª

[16:55] <Zoffix> Yeah, it's just converted to Inf by the grammar. It's not an idenfier-based term

[16:55] <grondilu> ok

[16:56] <grondilu> wasn't there a junction-style form for types?

[16:56] <Zoffix> m: my \term:<Int‚àû> = subset :: of Real where { $_ ~~ Int or $_ ~~ Inf }; say ‚àû ~~ Int‚àû; say 42 ~~ Int‚àû; say 0e0 ~~ Int‚àû

[16:56] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§True‚ê§False‚ê§¬ª

[16:56] <grondilu> m: say 13 ~~ Int|Inf

[16:56] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§¬ª

[16:56] <grondilu> m: say Inf ~~ Int|Inf

[16:56] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§¬ª

[16:56] <grondilu> m: say pi ~~ Int|Inf

[16:56] <camelia> rakudo-moar c46de0: OUTPUT: ¬´False‚ê§¬ª

[16:56] <Zoffix> m: my \term:<Int‚àû> = subset :: of Real where Int|Inf; say ‚àû ~~ Int‚àû; say 42 ~~ Int‚àû; say 0e0 ~~ Int‚àû

[16:56] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§True‚ê§False‚ê§¬ª

[16:56] <grondilu> m: my Int|Inf $

[16:56] <camelia> rakudo-moar c46de0: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Malformed my‚ê§at <tmp>:1‚ê§------> 3my Int7‚èè5|Inf $‚ê§¬ª

[16:57] <Zoffix> m: my $ where Int|Inf

[16:57] <camelia> rakudo-moar c46de0: ( no output )

[16:57] <grondilu> that could do

[16:57] *** AlexDani` joined
[16:58] <grondilu> that's actually pretty much as simple as I could have hoped

[16:58] *** mcmillhj joined
[16:59] *** AlexDaniel left
[17:04] <grondilu> m: role Foo[Int $sign where -1|1] {}; class :: does Foo[1] {}.new

[17:04] <camelia> rakudo-moar c46de0: ( no output )

[17:05] <grondilu> m: role Foo[Int $sign where -1|1] {}; say class :: does Foo[1] {}.new

[17:05] <camelia> rakudo-moar c46de0: OUTPUT: ¬´<anon|79109168>.new‚ê§¬ª

[17:05] <grondilu> hum, can't reproduce an error here

[17:05] <grondilu> m: role Foo[Int $sign where -1|1] {}; say class :: does Foo[pi] {}.new

[17:05] <camelia> rakudo-moar c46de0: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§No appropriate parametric role variant available for 'Foo'‚ê§at <tmp>:1‚ê§¬ª

[17:06] <grondilu> nvm

[17:07] *** AlexDani` left
[17:11] *** leont joined
[17:11] <Zoffix> m: my \term:<Int‚àû> = subset :: of Real where { $_ ~~ Int or $_ ~~ Inf }; sub (Int‚àû) {}(42) # can't actually use a term as a type constraint

[17:11] <camelia> rakudo-moar c46de0: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§A parameter may only have one prefix type constraint‚ê§at <tmp>:1‚ê§------> 3re { $_ ~~ Int or $_ ~~ Inf }; sub (Int‚àû7‚èè5) {}(42) # can't actually use a term as ‚ê§¬ª

[17:12] <Zoffix> m: my \term:<Int‚àû> = * ~~ Inf|Int; say ‚àû ~~ Int‚àû; say 42 ~~ Int‚àû; say 0e0 ~~ Int‚àû # and for this usecase it could well be just a Callabler

[17:12] <camelia> rakudo-moar c46de0: OUTPUT: ¬´True‚ê§True‚ê§False‚ê§¬ª

[17:22] <Aaronepower> What's the perl way to convert a hash to named arguments?

[17:22] <Aaronepower> perl6*

[17:22] <jnthn> |

[17:23] <Zoffix> m: my %h = :42a, :70b; { dd [ $:a, $:b ] }( |%h  )

[17:23] <camelia> rakudo-moar c46de0: OUTPUT: ¬´[42, 70]‚ê§¬ª

[17:24] *** dogbert11 joined
[17:27] <Zoffix> m: grammar A { token TOP { "A" } }; class A-A { method TOP($/) { make 42 } }; class B-B { method TOP($_) { .make: "Meow {.<A::TOP>.made}"  } }; grammar B { token TOP { {$/.set_actions: A-A } <A::TOP>  { $/.set_actions: B-B } "B" } }.parse(:actions(B-B), "AB").made.say

[17:27] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Meow 42‚ê§¬ª

[17:27] <Zoffix> Aaronepower: ^ .set_actions is not part of the language, but the above seems to do what you want

[17:28] <Aaronepower> Zoffix: thanks!

[17:29] *** troys is now known as troys_

[17:30] *** a3r0 left
[17:32] *** wamba joined
[17:33] *** aindilis left
[17:34] *** aindilis joined
[17:36] *** Sgeo joined
[17:36] <HoboWithAShotgun> m: my $s = supply { for 1 .. 3 { sleep(2); emit($_); } }; react { whenever $s -> $x { say $x; } }

[17:36] <camelia> rakudo-moar c46de0: OUTPUT: ¬´1‚ê§2‚ê§3‚ê§¬ª

[17:37] <HoboWithAShotgun> also on the shell this has no output for 6 seconds, then dumps all values at once

[17:39] <HoboWithAShotgun> why isn't the output coming in two second intervals?

[17:40] <HoboWithAShotgun> hey jnthn++ i just watched your talk about parallelism and concurreny

[17:40] *** a3r0 joined
[17:42] <timotimo> HoboWithAShotgun: the whenever only starts once the supply block has finished running

[17:43] <Aaronepower> How do you get a value from a hash with a variable?

[17:43] <Zoffix> m: my %h = :42a; my $v = 'a'; say %h{$v}

[17:43] <camelia> rakudo-moar c46de0: OUTPUT: ¬´42‚ê§¬ª

[17:43] <Aaronepower> Zoffix: cheers!

[17:43] <Zoffix> %h<foo> is just a shortcut for %h{'foo'}

[17:44] <Zoffix> %h<foo> is just a shortcut for %h{<foo>} # more accurately, since it does allomorphs

[17:44] <timotimo> and %h<foo bar> is short for %h{'foo', 'bar'}, which is also important

[17:44] <timotimo> (but including the allomorph thing)

[17:45] <Zoffix> m: my %h := :{ <42> => "allomorph", 42 => "Int", "42" => "Str" }; say %h<42>; say %h{42}; say %h{"42"}; say %h{<42>}

[17:45] <camelia> rakudo-moar c46de0: OUTPUT: ¬´allomorph‚ê§Int‚ê§Str‚ê§allomorph‚ê§¬ª

[17:47] <Aaronepower> Is there a way to refer an outer `$_` from an inner for loop?

[17:47] <Zoffix> (don't matter much for regular hashes, I suppose; only for Setties/Baggies/Object hashes)

[17:47] <Zoffix> Aaronepower: rewrite to not need it :) Also, $OUTER::_ or something

[17:48] <Zoffix> m: with 42 {  say $OUTER::_ for ^3 }

[17:48] <camelia> rakudo-moar c46de0: OUTPUT: ¬´42‚ê§42‚ê§42‚ê§¬ª

[17:48] <Zoffix> m: with 42 {  say "$_:$OUTER::_" for ^3 }

[17:48] <camelia> rakudo-moar c46de0: OUTPUT: ¬´0:42‚ê§1:42‚ê§2:42‚ê§¬ª

[17:49] <Zoffix> m: with 42 {  say "$_:$^hehehe" for ^3 }

[17:49] <camelia> rakudo-moar c46de0: OUTPUT: ¬´0:42‚ê§1:42‚ê§2:42‚ê§¬ª

[17:49] <Zoffix> ^_^

[17:52] <Aaronepower> Zoffix: cheers

[17:53] *** cdg joined
[17:54] *** leont left
[17:55] *** andrzejku_ joined
[17:56] <thunktone> Is there any way to add to the end of the autogenerated "Usage" message without erasing the generated part?

[17:56] <thunktone> I can't seem to access $?USAGE at all

[17:57] <Zoffix> I think it's NYI

[17:57] *** cdg__ left
[17:58] <Zoffix> hm, actually I see it being set.... hm

[17:58] *** cdg left
[17:58] <thunktone> It is producing output, I just can't access it within the program.

[18:00] <Zoffix> m: use nqp; sub MAIN ($a) { }; sub USAGE { say nqp::getlexcaller(q|$?USAGE|) ~ "moaaaar stuff" }

[18:00] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Usage:‚ê§  <tmp> <a> moaaaar stuff‚ê§¬ª

[18:00] *** leont joined
[18:00] <Zoffix> thunktone: you could use this in the meantime, though `nqp` is not standard language or supported. I'll poke at it right now and see to it that $?USAGE is available from userland

[18:00] *** Cabanossi left
[18:01] <thunktone> thanks

[18:02] *** Cabanossi joined
[18:06] *** a3r0 left
[18:07] *** leont left
[18:10] *** leont joined
[18:15] <HoboWithAShotgun> how do i get out of a whenever Supply.interval(1) -> $v { } block, so the reacting block returns and the program continues

[18:15] <HoboWithAShotgun> i can die, but that can't be it, right?

[18:16] <jnthn> done

[18:16] <yoleaux> 17:26Z <dogbert11> jnthn: wrt the failing syntax.t test, got this after several attempts: https://gist.github.com/dogbert17/d018b0f6f57f01f0726b6c0f734d0dbc

[18:17] <jnthn> m: react whenever Supply.interval(0.2) { .say; done if $++ == 5 }

[18:17] <camelia> rakudo-moar c46de0: OUTPUT: ¬´0‚ê§1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§¬ª

[18:17] <jnthn> m: react whenever Supply.interval(0.2) { .say; done if $++ == 5 }; say "afterwards"

[18:17] <camelia> rakudo-moar c46de0: OUTPUT: ¬´0‚ê§1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§afterwards‚ê§¬ª

[18:17] <HoboWithAShotgun> yay :)

[18:19] *** leont left
[18:21] <Zoffix> So what are "compile time variables"?

[18:21] <Zoffix> Or more to the point: why is $?USAGE a compile time variable

[18:22] <Zoffix> m: use nqp; sub MAIN ($a) { }; sub USAGE { BEGIN say nqp::getlexcaller(q|$?USAGE|) ~ "moaaaar stuff" }

[18:22] <camelia> rakudo-moar c46de0: OUTPUT: ¬´Use of uninitialized value of type Any in string context.‚ê§Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.‚ê§moaaaar stuff‚ê§  in code  at <tmp> line 1‚ê§¬ª

[18:22] <Zoffix> I "fixed" it, but it's not compile time and I don't get why we need to pay for generation of usage messages if we don't even know if we'll ever need 'em

[18:24] *** a3r0 joined
[18:24] * Zoffix moves this to #perl6-dev

[18:25] *** espadrine joined
[18:38] *** nightfrog left
[18:38] *** Rawriful joined
[18:39] <Zoffix> thunktone: it might take awhile to fix it actually. Some design issues are blocking it currently: https://github.com/rakudo/rakudo/commit/bbedf18d3c

[18:41] *** thunktone left
[18:41] *** domidumont left
[18:43] *** thunktone joined
[18:45] *** Cabanossi left
[18:47] *** Cabanossi joined
[18:48] *** AlexDaniel joined
[19:02] *** mcmillhj left
[19:06] <weabot> is there a way to import a file from the path as with #include "path/to/header.h" in C?

[19:06] <weabot> to just import existing subroutines from it

[19:06] *** mcmillhj joined
[19:07] <Zoffix> weabot: try:     EVALFILE 'path/to/header.h'

[19:08] <Zoffix> weabot: nevermind, it runs in its own "scope", so not like #include

[19:08] <weabot> that only returns a single structure from the file doesn't it?

[19:08] <Zoffix> As far as I understand, it's like 'path/to/header.h'.IO.slurp.EVAL

[19:09] <weabot> hmm

[19:09] <Zoffix> But I just tried it with `sub foo {}` in the file and it doesn't become available in the program

[19:10] <Zoffix> m: 'sub foo { say "hi" }'.EVAL; foo

[19:10] <camelia> rakudo-moar c46de0: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    foo used at line 1‚ê§‚ê§¬ª

[19:10] <Zoffix> m: 'our sub foo { say "hi" }'.EVAL; foo

[19:10] <camelia> rakudo-moar c46de0: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Undeclared routine:‚ê§    foo used at line 1‚ê§‚ê§¬ª

[19:10] *** astj joined
[19:14] *** astj left
[19:16] *** pecastro left
[19:26] *** darutoko left
[19:27] *** pecastro joined
[19:31] *** grondilu left
[19:39] *** krunen left
[19:39] *** krunen_ is now known as krunen

[19:46] *** TEttinger joined
[19:52] *** Aaronepower left
[19:56] *** eliasr left
[19:56] *** astronavt left
[20:09] *** cdg joined
[20:10] *** mcmillhj left
[20:17] *** LanceW joined
[20:22] *** mcmillhj joined
[20:23] *** AlexDaniel left
[20:27] *** mcmillhj left
[20:32] *** andrzejku_ left
[20:32] *** lichtkind left
[20:35] *** pecastro left
[20:39] *** mcmillhj joined
[20:41] *** Ven`` joined
[20:41] *** pecastro joined
[20:42] *** itaipu left
[20:43] *** mcmillhj left
[20:51] *** LanceW left
[20:52] *** |oLa| left
[20:52] *** mcmillhj joined
[20:57] *** mcmillhj left
[21:03] *** Rawriful left
[21:05] *** Rawriful joined
[21:07] *** troys_ is now known as troys

[21:09] *** skids left
[21:18] *** setty1 left
[21:18] *** itaipu joined
[21:29] *** perlpilot left
[21:30] *** rgrau left
[21:45] *** Cabanossi left
[21:47] *** Cabanossi joined
[21:55] *** astj joined
[21:59] *** astj left
[22:03] *** zoli__ joined
[22:04] <zoli__> (1..5).say

[22:04] <zoli__> (1..5).join

[22:04] <geekosaur> "m: "

[22:05] <zoli__> wondering why .say (or .perl) returns 1..5, but join (and reduce...) returns what I expect (12345)

[22:06] <geekosaur> m: (1..5).WHAT.say

[22:06] <camelia> rakudo-moar ffd179: OUTPUT: ¬´(Range)‚ê§¬ª

[22:06] <zoli__> ah, so it is a range, but just not expanded; thanks

[22:06] <geekosaur> join and reduce operate on lists/arrays, so trigger conversion

[22:07] <Zoffix> m: say eager 1..5

[22:07] <camelia> rakudo-moar ffd179: OUTPUT: ¬´(1 2 3 4 5)‚ê§¬ª

[22:07] <zoli__> just starting with perl6; I'll have to use WHAT more

[22:07] <geekosaur> m: (1..5).list.say

[22:07] <camelia> rakudo-moar ffd179: OUTPUT: ¬´(1 2 3 4 5)‚ê§¬ª

[22:07] <Zoffix> zoli__: use .^name instead. .WHAT returns a type object, while .^name returns the string with the actual name

[22:08] <zoli__> m: (1..5).name

[22:08] <camelia> rakudo-moar ffd179: OUTPUT: ¬´No such method 'name' for invocant of type 'Range'. Did you mean any of these?‚ê§    none‚ê§    note‚ê§    race‚ê§    take‚ê§‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:08] <Zoffix> It's .^name not .name

[22:08] <zoli__> m: (1..5).^name

[22:08] <camelia> rakudo-moar ffd179: ( no output )

[22:08] <zoli__> m: (1..5).^name.say

[22:08] <camelia> rakudo-moar ffd179: OUTPUT: ¬´Range‚ê§¬ª

[22:08] <zoli__> cool, thanks Zoffix and geekosaur

[22:09] <Zoffix> $foo.^bar is short for $foo.HOW.bar($foo); it's a method call on the object's metaobject

[22:09] <gfldex> m: LABEL: for 1..3 {}; say LABEL.WHAT

[22:09] <camelia> rakudo-moar ffd179: OUTPUT: ¬´(Label)‚ê§¬ª

[22:09] <gfldex> m: LABEL: for 1..3 {}; say &LABEL.WHAT

[22:09] <camelia> rakudo-moar ffd179: OUTPUT: ¬´Nil‚ê§¬ª

[22:09] <gfldex> o.0

[22:10] <gfldex> what the heck is an &-sigiled Label and why is it Nil?

[22:11] <Zoffix> m: constant foo = 42; say &foo

[22:11] <camelia> rakudo-moar ffd179: OUTPUT: ¬´Nil‚ê§¬ª

[22:11] <Zoffix> mc: constant foo = 42; say &foo

[22:11] <committable6> Zoffix, ¬¶2015.12: ¬´Nil¬ª

[22:11] <Zoffix> Ah, `foo` with a `&` coercer

[22:11] <Zoffix> m: say &42

[22:11] <camelia> rakudo-moar ffd179: OUTPUT: ¬´Nil‚ê§¬ª

[22:13] <Zoffix> m: say &&&&&&&&&&&&&&&&&&&&&&&&&&@@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[22:13] <camelia> rakudo-moar ffd179: OUTPUT: ¬´()‚ê§¬ª

[22:13] <Zoffix> m: constant $z = 42; say &$z

[22:13] <camelia> rakudo-moar ffd179: OUTPUT: ¬´42‚ê§¬ª

[22:14] <Zoffix> m: constant z = 42; say &z

[22:14] <camelia> rakudo-moar ffd179: OUTPUT: ¬´Nil‚ê§¬ª

[22:14] <Zoffix> inconsistent

[22:14] <Zoffix> m: constant z = 42; say &(z)

[22:14] <camelia> rakudo-moar ffd179: OUTPUT: ¬´42‚ê§¬ª

[22:15] *** troys is now known as troys_

[22:16] *** zoli__ left
[22:18] <Zoffix> Filed as https://rt.perl.org/Ticket/Display.html?id=132146

[22:18] *** itaipu left
[22:19] *** espadrine left
[22:25] <Geth> ¬¶ doc: 1382193d15 | (Will "Coke" Coleda)++ | doc/Language/5to6-nutshell.pod6

[22:25] <Geth> ¬¶ doc: 'Taint there.

[22:25] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/1382193d15

[22:25] <Geth> ¬¶ doc: e5f5dd96bd | (Will "Coke" Coleda)++ | 2 files

[22:25] <Geth> ¬¶ doc: whitespace

[22:25] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/e5f5dd96bd

[22:25] <Geth> ¬¶ doc: 2ac4c00de3 | (Will "Coke" Coleda)++ | 2 files

[22:25] <Geth> ¬¶ doc: Fix code samples

[22:25] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/2ac4c00de3

[22:26] *** Aaronepower joined
[22:26] *** troys_ is now known as troys

[22:30] *** mcmillhj joined
[22:31] *** Cabanossi left
[22:32] <Aaronepower> How would I with a Grammar get everything up to two certain words preserving those words to be parsed by the next rules? Here's what I tried so far: "Hello World BREAK Foo Bar STOP" code: `grammar Foo { rule TOP { <text> <foo> <bar> } rule foo { 'BREAK' <text> } rule bar { 'STOP' <text> } rule text { .+ <?before 'BREAK'> | <?before 'STOP'>} }`

[22:32] *** Cabanossi joined
[22:34] *** mcmillhj left
[22:36] *** nightfrog joined
[22:36] *** vike left
[22:37] *** cdg left
[22:38] *** vike joined
[22:38] *** vike left
[22:38] *** cdg joined
[22:44] *** skids joined
[22:45] <timotimo> Aaronepower: are you intending for the .+ in the rule text to only be allowed before a "BREAK"?

[22:45] <timotimo> because the | puts the .+ and <?before BREAK> on one side of the alteration and only <?before STOP> on the othe

[22:45] *** mcmillhj joined
[22:46] *** AlexDaniel joined
[22:46] <Aaronepower> timotimo: No I just want all the items before "BREAK", and allow for BREAK to be used by the grammar for rules after this one.

[22:47] *** thunktone left
[22:49] *** HoboWithAShotgun left
[22:50] *** mcmillhj left
[22:51] <timotimo> right, that should work

[22:51] <timotimo> i'd expect you can also use )> before the BREAK | STOP part

[22:52] <timotimo> will still have to put [ ] around the break/stop part, though

[22:52] <[Coke]> Readline erroring out trying to install on mac, using a readline from macports.

[22:54] <[Coke]> ah, https://github.com/drforr/perl6-readline/issues/12

[22:55] *** rindolf left
[22:57] <Aaronepower> timotimo: I'm sorry I don't understand. I just that code doesn't work https://paste.rs/dAF You're saying it is?

[22:57] <Aaronepower> just said*

[22:59] <Aaronepower> timotimo: Here's the updated version. https://paste.rs/spX

[22:59] <timotimo> well, that can't work

[22:59] <timotimo> it expects a text after STOP

[22:59] <timotimo> so there has to be more text and another BREAK or STOP there

[23:00] *** robertle left
[23:00] <Aaronepower> timotimo: https://paste.rs/WTc

[23:00] <timotimo> that looks more correct

[23:00] <timotimo> what i generally find is whitespace stuff is difficult

[23:01] <timotimo> that often screws me over when i use "rule"

[23:01] *** vike joined
[23:01] <Aaronepower> So what I'm expecting is essentially three <text> rules like `[Hello World]` `[Foo Bar]` `[Real Talk]`

[23:01] <timotimo> i'll grab the code and try it out locally

[23:01] *** mcmillhj joined
[23:02] <timotimo> oh

[23:02] <timotimo> you have another problem

[23:03] <timotimo> the text rule matches everything until the last BREAK

[23:03] <timotimo> then not problematic, since rule does do backtracking

[23:03] <timotimo> making it .+? instead of .+ makes it parse for me

[23:04] <Aaronepower> timotimo: Can you show me that code as just changing it from `.+` to `.+>

[23:04] <timotimo> hold on, something's not right

[23:04] <Aaronepower> `.+?` did not work.

[23:06] <timotimo> yes, bear with me for another moment

[23:07] *** mcmillhj left
[23:08] <timotimo> ah, yes

[23:08] <timotimo> you're not consuming the last BREAK or STOP

[23:08] <timotimo> so you successfully match, but you don't match up until the end of the source text

[23:08] <timotimo> .parse will consider that a failure

[23:08] <timotimo> if you use .subparse instead, that won't force beginning-to-end match, and thus will succeed

[23:09] *** cdg left
[23:09] <Aaronepower> timotimo: Nope, changing it to subparse just gives me `#<failed match>`

[23:09] <timotimo> m: https://paste.rs/J4Y

[23:09] <camelia> rakudo-moar ffd179: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Confused‚ê§at <tmp>:1‚ê§------> 3https:7‚èè5//paste.rs/J4Y‚ê§    expecting any of:‚ê§        colon pair‚ê§¬ª

[23:09] <timotimo> aaw

[23:09] <timotimo> anyway, my working code is at that address

[23:11] <Aaronepower> timotimo: Is there no way to have that functionality with parse?

[23:11] <timotimo> sure

[23:11] <timotimo> just gotta eat up the final BREAK or STOP in the TOP rule

[23:12] <Aaronepower> timotimo: So `<text> BREAK <foo> STOP <bar>`?

[23:12] <timotimo> no, more like <text> <foo> <bar> [ BREAK | STOP ]

[23:13] <timotimo> if you want it to accept strings that don't end in break or stop, you have to also accept $ as an alternative to BREAK or STOP in the text rule

[23:13] <timotimo> though if your input data is really this simple, can i interest you in the awesome and versatile tool that is .split?

[23:14] <timotimo> m: "Hello World BREAK Foo Bar STOP Real Talk".split(["BREAK", "STOP"], :k).perl.say

[23:14] <camelia> rakudo-moar ffd179: OUTPUT: ¬´("Hello World ", 0, " Foo Bar ", 1, " Real Talk").Seq‚ê§¬ª

[23:14] <timotimo> m: "Hello World BREAK Foo Bar STOP Real Talk".split(["BREAK", "STOP"], :v).perl.say

[23:14] <camelia> rakudo-moar ffd179: OUTPUT: ¬´("Hello World ", "BREAK", " Foo Bar ", "STOP", " Real Talk").Seq‚ê§¬ª

[23:14] <Aaronepower> timotimo: Hang on. You added a `BREAK` to the end. That isn't how my input will look. It won't have BREAK at the end.

[23:14] <timotimo> ok, i'll put the necessary modification in and paste agai

[23:14] <timotimo> nhttps://paste.rs/6ES

[23:14] <timotimo> oops

[23:15] <timotimo> https://paste.rs/6ES

[23:15] <Aaronepower> timotimo: Okay, thank you for your time.

[23:19] <timotimo> sure

[23:19] <timotimo> i don't grammar terribly often, so it was a good opportunity to freshen up

[23:25] *** mcmillhj joined
[23:29] *** mcmillhj left
[23:37] *** troys is now known as troys_

[23:38] *** wamba left
[23:46] *** Cabanossi left
[23:47] *** Cabanossi joined
[23:54] *** BenGoldberg joined
