[00:01] *** mcmillhj joined
[00:01] *** cpage_ joined
[00:04] *** rindolf left
[00:05] *** araujo joined
[00:06] *** mcmillhj left
[00:06] <Geth> ¬¶ doc: antquinonez++ created pull request #1336: Fix broken link, Perl 6 nbsp issue

[00:06] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/pull/1336

[00:19] *** AlexDaniel left
[00:34] *** Sound joined
[00:47] *** mcmillhj joined
[00:47] *** kurahaupo__ left
[00:48] *** kurahaupo joined
[00:48] <Geth> ¬¶ doc: a43667a050 | (Antonio Quinonez)++ (committed by Zoffix Znet) | doc/Language/performance.pod6

[00:48] <Geth> ¬¶ doc: Fix broken link, Perl 6 nbsp issue (#1336)

[00:48] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/a43667a050

[00:50] *** Cabanossi left
[00:50] *** kurahaupo_ joined
[00:51] *** kurahaupo_ left
[00:51] *** Cabanossi joined
[00:51] *** kurahaupo_ joined
[00:52] *** mcmillhj left
[00:52] *** kurahaupo left
[00:55] *** kurahaupo_ left
[00:55] *** kurahaupo joined
[00:56] *** imcsk8 left
[00:56] *** imcsk8_ joined
[00:57] *** kurahaupo_ joined
[00:59] *** kurahaupo left
[01:03] *** mcmillhj joined
[01:03] *** geekosaur left
[01:06] *** geekosaur joined
[01:09] *** mcmillhj left
[01:10] *** Sound left
[01:14] *** dj_goku joined
[01:14] *** dj_goku left
[01:14] *** dj_goku joined
[01:17] *** cdg joined
[01:20] *** dj_goku left
[01:26] *** cdg left
[01:26] *** cdg joined
[01:28] <bioduds> Hello, friends

[01:28] <bioduds> I'm trying to find bitwise operations documentation link

[01:29] <bioduds> not finding, can you please point me where?

[01:31] *** Actualeyes joined
[01:37] <Juerd> bioduds: At https://docs.perl6.org/ type "bitwise" to get a list of suggestions

[01:37] <Juerd> There doesn't seem to be a document detailing this specifically.

[01:39] <bioduds> thank you very much juerd

[01:39] <bioduds> yes, I need to rotate, xor and a few others

[01:42] *** mcmillhj joined
[01:43] <bioduds> I found shift

[01:43] <bioduds> instead of << is +<

[01:43] <bioduds> >> is +>

[01:44] <bioduds> xor I found too

[01:44] <bioduds> thanks

[01:44] *** ilbot3 left
[01:47] *** mcmillhj left
[01:48] *** ilbot3 joined
[01:48] *** ChanServ sets mode: +v ilbot3

[01:48] <Juerd> bioduds: All the numeric bitwise operators begin with +

[01:51] *** mcmillhj joined
[01:56] *** mcmillhj left
[02:06] *** Sgeo left
[02:07] <bioduds> great, thanks, juerd :^)

[02:07] *** Sgeo joined
[02:12] *** cpage_ left
[02:15] *** mcmillhj joined
[02:15] *** cpage_ joined
[02:20] *** mcmillhj left
[02:30] <BenGoldberg> m: sub foo(&arg (int32 --> num64)) { say 'ok'; pi };  constant Bar = &foo.signature.params[0]; sub baz(Bar $cb) { $cb.() };  baz(&foo);

[02:30] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´Type check failed in binding to parameter '$cb'; expected Parameter but got Sub (sub foo (&arg (int32 ...)‚ê§  in sub baz at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[02:31] *** mcmillhj joined
[02:33] <BenGoldberg> m: sub foo(&arg (int32 --> num64)) { say 'ok' };  constant Bar = &foo.signature.params[0].type; sub baz(Bar $cb) { $cb.(12) };  baz(&foo);

[02:33] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´Type check failed in binding to parameter '&arg'; expected Callable but got Int (12)‚ê§  in sub foo at <tmp> line 1‚ê§  in sub baz at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[02:34] *** Cabanossi left
[02:35] *** finanalyst joined
[02:35] <BenGoldberg> m: sub foo(&arg (int32 --> num64)) { say 'ok' };  constant Bar = &foo.signature.params[0].type; sub baz(Bar $cb) {};  baz(sub (Str) {});

[02:35] <camelia> rakudo-moar ec51e7: ( no output )

[02:35] <BenGoldberg> m: sub foo(&arg (int32 --> num64)) { say 'ok' };  constant Bar = &foo.signature.params[0].type; sub baz(Bar $cb) {}; dd &baz.signature;

[02:35] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´:(Callable $cb)‚ê§¬ª

[02:36] *** mcmillhj left
[02:36] *** Cabanossi joined
[02:36] * BenGoldberg frowns.

[02:39] *** cdg left
[02:42] *** cyphase left
[02:46] <pilne> ?

[02:47] *** mcmillhj joined
[02:47] *** pilne left
[02:48] *** cyphase joined
[02:54] *** mcmillhj left
[02:57] *** noganex_ joined
[02:59] *** noganex left
[03:03] *** dj_goku joined
[03:03] *** dj_goku left
[03:03] *** dj_goku joined
[03:06] *** mcmillhj joined
[03:08] *** dj_goku left
[03:12] *** mcmillhj left
[03:14] *** khw left
[03:16] *** xinming left
[03:17] *** xinming joined
[03:19] *** curt_ left
[03:19] *** Cabanossi left
[03:20] *** Cabanoss- joined
[03:21] *** Cabanoss- is now known as Cabanossi

[03:41] *** mcmillhj joined
[03:41] *** Herby_ left
[03:46] *** mcmillhj left
[03:47] *** Cabanossi left
[03:50] *** luis joined
[03:50] *** Cabanossi joined
[03:50] *** aborazmeh joined
[03:50] *** aborazmeh left
[03:50] *** aborazmeh joined
[03:56] *** zoll joined
[04:00] *** zoll left
[04:00] *** mcmillhj joined
[04:02] *** KDr2 joined
[04:05] *** mcmillhj left
[04:05] *** xiaoyafeng joined
[04:07] <xiaoyafeng> hello, i found perl6 can deal: (2-sqrt(3))*(2+sqrt(3)) correctly

[04:08] <xiaoyafeng> but it can't deal my $m; ($m - $m)

[04:09] <xiaoyafeng> it throws Malformed initializer

[04:10] *** zoll joined
[04:10] <zengargoyle> m: my $m = 0; say ($m - $m);

[04:10] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´0‚ê§¬ª

[04:12] <xiaoyafeng> but if I don't know what $m is firstly

[04:12] <xiaoyafeng> I don't want pass a value to $m firstly

[04:12] <zengargoyle> exactly, how can you subtract and unknown from an unknown.

[04:13] <xiaoyafeng> I just know $m is a rational value

[04:13] <zengargoyle> but if it has no initial value, how can you subtract it from itself?

[04:14] <xiaoyafeng> $m could be any value

[04:14] <xiaoyafeng> $m - $m  is 0

[04:16] <zengargoyle> an uninitialized Rat is basically the Rat type value and not an actual Rat since it doesn't actually have a value.

[04:16] <zengargoyle> m: my Rat $m; say $m.WHAT; say ($m-$m); say ($m-$m).WHAT;

[04:16] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´(Rat)‚ê§Cannot look up attributes in a Rat type object‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[04:18] *** Cabanossi left
[04:20] <xiaoyafeng> so it there a way to initial a rat, but not actually pass a value?

[04:20] *** Cabanossi joined
[04:20] <zengargoyle> i was trying to remember that bit :)

[04:22] <hobbs> $x - $x == 0 isn't *quite* an identity on Rat, Rat supports NaNs

[04:22] <zengargoyle> but i think it applies more to say an array of Rats or a subclass type of thing.

[04:23] <zengargoyle> and wherever you're defining 'my $x' in the first place why not 'my $x = 0.0'?

[04:24] <hobbs> but even leaving that aside, I don't think you can do what you want :)

[04:24] <zengargoyle> or it would be more typing than just assigning the default value with '= 0.0' yoursef.

[04:26] <xiaoyafeng> I think it's more like a logic problem, I mean when I declare a Rat, it should be initialized. no matter what I pass to.

[04:28] <xiaoyafeng> I thought perl6 can handle it because it has lazy evaluation

[04:28] <zengargoyle> that's where i think you could possibly subclass Rat into MyRat or something and have it default to a value.

[04:30] <zengargoyle> and hobbs comment ... which would you choose for default?  0.0 or NaN??

[04:31] <xiaoyafeng> hmmm,  that's a idea....

[04:31] <hobbs> well my point was that there's a value that makes ($m - $m) == 0 false, so it's not correct to replace it with true for a truly unknown $m

[04:31] <xiaoyafeng> !!

[04:31] <xiaoyafeng> $m = NaN; $m- $m is equal to NaN

[04:32] <hobbs> yes

[04:32] <xiaoyafeng> maybe I have to set default value is 0.0?

[04:32] <hobbs> you could, but I would be tempted to say that whatever you're doing it for, is wrong :)

[04:33] <xiaoyafeng> yes, it's not what I want

[04:34] <zengargoyle> welcome to Perl6, "I reject your design and substitute my own." :P

[04:35] <xiaoyafeng> :P

[04:37] <zengargoyle> m: my Rat $m .= new; say ($m.Rat - $m.Rat);

[04:37] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´0‚ê§¬ª

[04:37] <zengargoyle> m: my Rat $m .= new; say ($m - $m);

[04:37] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´0‚ê§¬ª

[04:38] <xiaoyafeng> great!

[04:38] <zengargoyle> without an initializer it's a type-object, with initializer it's whatever you initialize with, with .=new it's the default value (if any)?/???????

[04:39] <hobbs> m: my Rat $m .= new; say $m.perl

[04:39] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´0.0‚ê§¬ª

[04:40] <xiaoyafeng> defalut value still is 0.... ;)

[04:42] <zengargoyle> probabbly boils dow to which of 0, NaN, -NaN?, Inf, -Inf would DWIM. :)

[04:44] <zengargoyle> and the Int vs Rat vs Num vs Numeric or whatever where some are as big as you can think and some are CPU floating point but everything has a 0.

[04:51] *** dj_goku joined
[04:51] *** dj_goku left
[04:51] *** dj_goku joined
[04:55] *** zengargoyle left
[04:56] *** dj_goku left
[04:56] *** zoll left
[04:57] *** zengargoyle joined
[04:59] *** llfourn joined
[05:00] *** astj joined
[05:00] *** astj_ left
[05:01] *** resol joined
[05:03] *** samcv left
[05:03] *** Cabanossi left
[05:04] *** samcv joined
[05:05] *** Cabanossi joined
[05:10] *** skids left
[05:19] *** mcmillhj joined
[05:20] *** xiaoyafeng left
[05:24] *** mcmillhj left
[05:34] *** Cabanossi left
[05:34] *** geekosaur left
[05:35] *** Cabanossi joined
[05:36] *** geekosaur joined
[05:46] *** xtreak joined
[05:56] *** zapwai left
[06:02] *** ufobat joined
[06:03] *** Cabanossi left
[06:05] *** Cabanossi joined
[06:07] *** mcmillhj joined
[06:08] *** aborazmeh left
[06:12] *** mcmillhj left
[06:21] *** Cabanossi left
[06:23] *** Cabanossi joined
[06:23] *** mcmillhj joined
[06:28] *** mcmillhj left
[06:28] *** resol left
[06:33] *** Actualeyes left
[06:35] *** parv joined
[06:39] *** mcmillhj joined
[06:39] *** dj_goku joined
[06:39] *** dj_goku left
[06:39] *** dj_goku joined
[06:44] *** dj_goku left
[06:47] *** mcmillhj left
[06:49] *** Actualeyes joined
[06:51] *** darutoko joined
[06:55] *** CacoS joined
[06:57] *** domidumont joined
[07:01] *** domidumont left
[07:02] *** domidumont joined
[07:06] *** Cabanossi left
[07:08] *** kurahaupo joined
[07:08] *** kurahaupo left
[07:08] *** darutoko- joined
[07:08] *** kurahaupo joined
[07:09] *** Cabanossi joined
[07:11] *** darutoko left
[07:11] *** kurahaupo_ left
[07:12] *** kurahaupo_ joined
[07:12] *** kurahaupo left
[07:21] *** kurahaupo joined
[07:21] *** kurahaupo left
[07:22] *** kurahaupo joined
[07:23] *** BenGoldberg left
[07:24] *** kurahaupo_ left
[07:26] *** kurahaupo left
[07:26] *** kurahaupo joined
[07:30] *** kurahaupo_ joined
[07:30] *** kurahaupo_ left
[07:31] *** kurahaupo_ joined
[07:33] *** kurahaupo left
[07:33] *** robertle left
[07:33] *** pmurias joined
[07:34] *** kurahaupo joined
[07:35] *** kurahaupo left
[07:36] *** kurahaupo_ left
[07:36] *** kurahaupo__ joined
[07:48] *** domidumont left
[07:49] *** darutoko joined
[07:52] *** darutoko- left
[07:55] *** mcmillhj joined
[07:57] *** lowbro joined
[08:00] *** darutoko left
[08:01] *** mcmillhj left
[08:01] *** simonm left
[08:06] *** zakharyas joined
[08:06] *** Cabanossi left
[08:09] *** xtreak left
[08:09] *** Cabanossi joined
[08:10] *** xtreak joined
[08:11] *** mcmillhj joined
[08:13] *** xtreak left
[08:13] *** xtreak joined
[08:15] *** cdg joined
[08:16] *** mcmillhj left
[08:18] *** nadim joined
[08:21] *** g4 joined
[08:21] *** g4 left
[08:21] *** g4 joined
[08:23] *** bacek_ left
[08:23] *** bacek_ joined
[08:27] *** dj_goku joined
[08:27] *** dj_goku left
[08:27] *** dj_goku joined
[08:27] *** mcmillhj joined
[08:32] *** dj_goku left
[08:34] *** mcmillhj left
[08:41] *** rindolf joined
[08:47] *** mcmillhj joined
[08:52] *** mcmillhj left
[08:53] *** Cabanossi left
[08:53] *** cpage_ left
[08:54] *** Cabanossi joined
[08:56] *** imcsk8_ left
[08:56] *** Cabanossi left
[08:56] *** Cabanossi joined
[08:57] *** Cabanossi left
[08:59] *** Cabanossi joined
[09:00] *** Cabanossi left
[09:02] *** Cabanossi joined
[09:03] *** mcmillhj joined
[09:06] *** xtreak left
[09:06] *** xtreak joined
[09:06] *** robertle joined
[09:11] *** mcmillhj left
[09:13] *** imcsk8 joined
[09:13] *** cdg_ joined
[09:15] *** cdg left
[09:21] *** xtreak left
[09:22] *** xtreak joined
[09:26] *** xtreak left
[09:26] <avalenn> m: my $matcher = regex  {'c' .*}; 'abcd' ~~ /'c' .*/ ; say $/ ; for 1 {'bcde' ~~ $matcher; say $/ ;}

[09:26] <camelia> rakudo-moar ec51e7: OUTPUT: ¬´ÔΩ¢cdÔΩ£‚ê§ÔΩ¢cdeÔΩ£‚ê§¬ª

[09:27] <Geth> ¬¶ specs: 5c9262e200 | (Stefan Seifert)++ | S22-package-format.pod

[09:27] <Geth> ¬¶ specs: Uniquify headlines in S22 to work around a rendering bug in design.perl6.org

[09:27] <Geth> ¬¶ specs: 

[09:27] <Geth> ¬¶ specs: The renderer seems to add the contents of the completely separate "bin"

[09:27] <Geth> ¬¶ specs: sections.

[09:27] <Geth> ¬¶ specs: review: https://github.com/perl6/specs/commit/5c9262e200

[09:27] *** xtreak joined
[09:30] *** cdg_ left
[09:32] *** cyphase left
[09:37] *** cyphase joined
[09:39] *** itaylor57 left
[09:46] <finanalyst> trying to debug, but perl6-debug is not recognised. tried perl6-debug-m but Debugger::UI::CommandLine not recognised. tried "zef install Debugger::UI::CommandLine" and get 'entity not recognised'.

[09:46] <finanalyst> how to debug?

[09:48] <finanalyst> forget above. Typo in terminal.

[09:49] <finanalyst> But standard info on debugging says: type perl6-debug, but that does not work

[09:57] <avalenn> m: my $matcher = regex  {'c' .*}; 'abcd' ~~ /'c' .*/ ; say $/ ; for 1 {'bcde' ~~ $matcher; say $/ ;}

[09:57] <camelia> rakudo-moar 25d043: OUTPUT: ¬´ÔΩ¢cdÔΩ£‚ê§ÔΩ¢cdeÔΩ£‚ê§¬ª

[09:58] *** cpage_ joined
[10:02] <moritz> finanalyst: define "does not work"

[10:03] <moritz> oh, never mind

[10:03] <moritz> finanalyst: one thing you could try is cloning https://github.com/jnthn/rakudo-debugger and in the clone to "zef install ."

[10:10] <zengargoyle> i think that's what i'll miss from Task::Star, a few common things you're going to want pretty soon after install in one simple 'zef install Task::Whatever'.

[10:13] <zengargoyle> and sorta thinking of debian apt where auto-installed dependencies are different than requested packages.  if ever there's a zef command to remove something and the things that it used that aren't used by anything else but that you actually use all the time in one-liners or just have come to expect to be available.

[10:13] *** finanalyst left
[10:15] *** dj_goku joined
[10:18] <zengargoyle> maybe a Task::MyFavs which really just reads your ~/.myfavs.txt and installs them. :)

[10:19] <zengargoyle> or like the p5 Task::BeLike:: namespace.

[10:21] *** dj_goku left
[10:29] *** AlexDaniel joined
[10:31] <stmuk> a Task::Meteor which just had docs and debuggers might be easy to maintain

[10:32] <nadim> m: my $j = 1 | 'a' | True ; my $s = set (1, 'a', True, $j) ; dd $s

[10:32] <camelia> rakudo-moar f2fca0: OUTPUT: ¬´Set $s = set(1,"a",any(1, "a", Bool::True),Bool::True)‚ê§¬ª

[10:33] *** gregf_ joined
[10:33] <nadim> am I wrong or is dd displaying the elements in the wrong order? 

[10:34] <nadim> I am expecting 1, a, True, and then the junctpion

[10:35] <zengargoyle> pretty sure Sets are un-ordered

[10:35] <moritz> junctions aren't ordered

[10:35] <moritz> and sets too, right

[10:35] <nadim> ok

[10:36] <zengargoyle> i'm also pondering writing some p5 that groks p6 stuff (modules mostly) because i miss bash tab completion types of things.

[10:37] <zengargoyle> like perldod <TAB> <TAB> is a nice way to browse installed modules for documentation.

[10:37] <zengargoyle> s/dod/doc/

[10:38] <nadim> sets and junctions are not the most fun things to dump; so far Data::Dump::Tree does not support them, could anyone point to where dd or gist handle them? maybe I get an idea there.

[10:38] <zengargoyle> and i'm on dsl so all the network stuff + p6 still a bit slow .... sorta stars to drive me a bit batty every so often.

[10:38] <moritz> nadim: dd seems to handle them in the example you gave above, no?

[10:39] <nadim> yes it does, Data::Dump::Tree does not and I'd like to have a look at how dd does it

[10:41] * zengargoyle really wants to bust out a 'use the source nadim' but it's not 5/25 anymore.

[10:45] <zengargoyle> get the rakudo src and start looking: src/core/Any.pm line 590:sub dd(|) {

[10:45] <moritz> and I guess it ends up calling .perl

[10:49] *** zakharyas1 joined
[10:51] *** marcovorg joined
[10:52] <zengargoyle> yeah, dd is like 18 lines but does use nqp but otherwise not that complicated.

[10:59] *** astj left
[11:00] *** astj joined
[11:02] *** xtreak left
[11:05] *** astj left
[11:06] *** kurahaupo__ left
[11:06] *** kurahaupo joined
[11:08] *** astj joined
[11:10] *** bjz joined
[11:16] *** zakharyas1 left
[11:20] *** parv left
[11:22] *** Cabanossi left
[11:24] *** zakharyas left
[11:24] *** Cabanossi joined
[11:25] *** zakharyas joined
[11:27] *** zakharyas1 joined
[11:30] *** zakharyas left
[11:31] *** KDr2 left
[11:36] *** gdonald left
[11:40] *** Cabanossi left
[11:40] *** Cabanossi joined
[11:42] <nebuchadnezzar> interesting that http://perl6maven.com/interactive-perl6 does not speak about ‚Äú@‚Äù and ‚Äú%‚Äù sigils and use only ‚Äú$‚Äù

[11:44] *** CacoS left
[11:45] <AlexDaniel> nebuchadnezzar: yea, weird. But you are free to do that if that's what you're into :)

[11:45] <AlexDaniel> you'll still have to use @ sometimes

[11:45] <AlexDaniel> m: my $x = [‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòc‚Äô]; for @$x { .say }

[11:45] <camelia> rakudo-moar f2fca0: OUTPUT: ¬´a‚ê§b‚ê§c‚ê§¬ª

[11:45] <AlexDaniel> m: my $x = [‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòc‚Äô]; for $x { .say }

[11:46] <camelia> rakudo-moar f2fca0: OUTPUT: ¬´[a b c]‚ê§¬ª

[11:46] <AlexDaniel> well‚Ä¶ or any other way

[11:46] <AlexDaniel> m: my $x = [‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòc‚Äô]; for $x.list { .say }

[11:46] <camelia> rakudo-moar f2fca0: OUTPUT: ¬´a‚ê§b‚ê§c‚ê§¬ª

[11:51] *** astj left
[11:57] *** bjz left
[11:57] <zengargoyle> at least it's not my \x 'cause python is cool and sigils are noise.

[11:58] <El_Che> moritz: how is the book going?

[11:58] *** xtreak joined
[11:59] *** raschipi joined
[12:02] *** unixms joined
[12:04] *** dj_goku joined
[12:04] *** dj_goku left
[12:04] *** dj_goku joined
[12:05] *** araraloren joined
[12:05] *** wamba joined
[12:08] *** astj joined
[12:09] *** dj_goku left
[12:09] *** unixms left
[12:10] <araraloren> afternoon

[12:12] <raschipi> hi araraloren 

[12:13] <araraloren> hi raschipi :)

[12:13] *** eliv joined
[12:14] *** Zoffix joined
[12:15] *** bjz joined
[12:16] *** mcmillhj joined
[12:16] *** sufrosti1o left
[12:16] <Zoffix> FWIW, hashes, sets, bags, and mixes are unordered only in list "view". If you print or .perl them they *are* ordered (if you ignore the current bug where sets aren't)

[12:16] *** sufrostico left
[12:17] *** sufrosti2o left
[12:18] *** domidumont joined
[12:18] <raschipi> Yeah, they call .sort before printing

[12:20] *** mcmillhj left
[12:22] <araraloren> ?_?

[12:24] <zengargoyle> araraloren: i guess Zoffix is talking about the previous discussion of how dd prints things out.

[12:25] *** fatguy joined
[12:26] <Zoffix> That's the only recent discussion involving hashes and ordering :/

[12:27] * zengargoyle assuming araraloren's ?_? was from just joining.

[12:28] <Zoffix> What stood out more to me in the maven article aren't the sigils but the excessive use of .WHAT as a means to inspect the type. It's not really a versatile or reliable way, as I explained in a comment: https://www.reddit.com/r/perl/comments/6dfj2g/perl_6_interactive_shell_values_in_variables/di2g70s/

[12:28] <araraloren> It's better to be consistent, why not sort it .

[12:29] <[Coke]> if you want it sorted, why not sort it explicitly?

[12:30] <Zoffix> [Coke]: why sort it explicitly if we can sort it for the user?

[12:30] <[Coke]> because sorting ain't free.

[12:30] *** curt_ joined
[12:30] <[Coke]> but I don't have a strong objection.

[12:31] * zengargoyle also suprised that set and other like things do sort on .perl

[12:31] <raschipi> The article also uses the { } hash contructor, but the recommended way is the %( ) constructor

[12:31] <zengargoyle> or *supposed* to

[12:31] <Zoffix> [Coke]: if you worry about such minute things, listify your hash and print it unordered

[12:31] <Zoffix> Most humans would prefer their ouput not randomized willy-nilly

[12:32] <Zoffix> Ah, finally found the ticket. And the ordering was TimToady's ruling: https://rt.perl.org/Ticket/Display.html?id=131244#ticket-history

[12:32] <fatguy> i got 'Cannot find method 'setlang' on object of type Perl6::HookGrammar' when running perl6-debug-m using Rakudo v2017.04.3, any idea?

[12:32] <raschipi> So, .Str doesn't guarantee the order?

[12:32] <Zoffix> fatguy: perl6-debug-m is bitrotten. There's a way to fix the setlang thing (I think it's fixed on HEAD alreadY), but there are more problems

[12:33] <Zoffix> raschipi: it does

[12:33] <Zoffix> And is: https://github.com/rakudo/rakudo/blob/f2fca0c/src/core/Map.pm#L48

[12:33] <fatguy> Zoffix: thanks!

[12:34] * zengargoyle bows to authority. :P

[12:34] *** domidumont left
[12:35] <Zoffix> \o

[12:35] *** Zoffix left
[12:35] <raschipi> I agree that the quick and easy methods should do the right thing. Anyone wanting better performance can squeeze it themselves.

[12:35] <araraloren> Em, Actually for me, anyway that behavior should be clear in document .

[12:36] <araraloren> Then that's fine.

[12:36] *** Sound joined
[12:36] <zengargoyle> but guess if the machine doesn't care reading it back in, if it's human readable, tend to do the easy human thing.

[12:37] <zengargoyle> i feel scary ghosts of when p5 started randomizing hash order and things broke.

[12:38] <zengargoyle> but .gist and .perl aren't the same as .list so it's all good.

[12:38] <bioduds> hello friend

[12:38] <bioduds> hello friends

[12:38] <AlexDaniel> o/

[12:39] <bioduds> I'm currently translating a .c algorithm to perl6

[12:39] <bioduds> could you guys help me with this part here?

[12:39] <bioduds> what would be the equivalent in perl6 for this: memcpy( ( void * ) ( S->buf + left ), ( void * ) in, fill );

[12:39] <araraloren> ~~ yeah, What's the problem

[12:40] <bioduds> a simple assignment?

[12:40] <zengargoyle> what is fill ?

[12:40] <araraloren> void* => Pointer[void], size_t => size_t

[12:41] <bioduds> fill is an Int

[12:41] <araraloren> Have you read this ?

[12:41] <araraloren> https://docs.perl6.org/language/nativecall#Typed_Pointers

[12:41] <araraloren> The NativeCall document 

[12:42] <zengargoyle> what is this in plain copy(src, dst)?

[12:42] <bioduds> let me see if I understood

[12:42] <bioduds> I would have construct the c in the perl and it would execute

[12:43] <bioduds> right?

[12:43] <bioduds> copy is a perl funcion?

[12:44] <bioduds> function?

[12:44] <bioduds> if it is I guess it is what I want

[12:44] <araraloren> It's for file copy.

[12:45] <araraloren> copy(srcfile, destfile)

[12:45] <perlpilot> bioduds: could you put the C code somewhere everyone can see?

[12:45] <zengargoyle> i'm unsure whether you're trying to call nativecall type stuff (actually calling out to a C .so library) or just messing with a buffer of bytes in perl.

[12:45] <bioduds> I could do, for instance: copy( $s512.buf + $left, $in, $fill ); 

[12:45] <araraloren> yeah. We dont's know what yuor plan. 

[12:45] <perlpilot> bioduds: also, Perl doesn't really have a low-level memcpy() operation.

[12:45] <bioduds> yes, here is the link

[12:46] <bioduds> https://github.com/veorq/BLAKE/blob/master/blake512.c line 94

[12:46] <bioduds> I'm implementing this algorithm in perl6

[12:46] <[Coke]> I had assumed not a slavish copy of the low level with nativecall, but a "pure perl" approach was the question.

[12:46] *** xtreak left
[12:47] <perlpilot> bioduds: if you want to copy chunks of memory around, that feels like you want to be manipulating either a Buf

[12:47] <araraloren> Oh, Then you probably don't need NativeCall

[12:47] <bioduds> I am first making a raw copy as close as it can get

[12:47] <bioduds> yes araraloren probably

[12:47] <perlpilot> s/either//

[12:47] <bioduds> that is quite my question

[12:47] <bioduds> I can simply assign the value?

[12:47] <araraloren> bioduds, you can use a `Buf` as a buffer

[12:48] <bioduds> in order to copy the binary data?

[12:48] <araraloren> Yeah

[12:48] <bioduds> ok, I'll try that approach

[12:48] <bioduds> thanks araraloren

[12:49] <araraloren> Buf: Mutable buffer for binary data

[12:49] <araraloren> The document said that: https://docs.perl6.org/type/Buf

[12:50] <moritz> El_Che: it's going quite well; I'll probably hand in the final[tm] manuscript this month

[12:51] <[Coke]> moritz++

[12:51] <El_Che> moritz: glad to hear it

[12:52] *** xtreak joined
[12:54] *** mcmillhj joined
[12:55] *** yqt joined
[12:57] *** fatguy left
[12:58] *** ugjka is now known as ugjkatest

[12:58] *** ugjkatest is now known as ugjka

[13:00] <moritz> [ptc]++ is doing some final proof-reading

[13:00] <moritz> and I'm hoping for a contribution by TimToady++ as well :-)

[13:01] <perlpilot> moritz: congrats on the near completion of your book  :)

[13:02] *** finanalyst joined
[13:02] <bioduds> noobie question: is there casting in Perl6?

[13:02] <bioduds> like (int)var for instance

[13:02] <moritz> $var.Int

[13:02] <bioduds> oh, thanks moritz

[13:02] <moritz> m: say "42".Int.perl

[13:02] <camelia> rakudo-moar f2fca0: OUTPUT: ¬´42‚ê§¬ª

[13:05] *** ugjka is now known as ugjkatest

[13:05] *** ugjkatest is now known as ugjka

[13:05] <araraloren> m: say "23".Int

[13:05] <camelia> rakudo-moar f2fca0: OUTPUT: ¬´23‚ê§¬ª

[13:05] *** xtreak left
[13:07] *** kyan left
[13:10] <zengargoyle> bioduds: it sounds like you want to read some bytes from fileA and some bytes from fileB and overwrite the bytes from fileB into the bytes from fileA at +offset from the beginning of the bytes of fileA and then maybe write them back out?

[13:13] <El_Che> Hi, I wrote a blog post about the lib ecosystem (and CPAN). I don't want to troll, so comments welcome: https://gist.github.com/nxadm/1b62f7d341a0afaa9b73b787b8ad19a2

[13:17] *** cdg joined
[13:23] <raschipi> El_Che: I think the testing and the good documentation aspects come from CPAN, actually. Perl6 is going to have CPAN-Testers support, and the module front-page in CPAN being the POD includded in the module will lead people to do the same things as P5 devs did.

[13:24] <El_Che> raschipi: eventually, yes

[13:24] <El_Che> (I agree, maybe I need to clarify that)

[13:24] <El_Che> the point is that's not enough

[13:25] <raschipi> It also didn't happen imediatelly for P5. Polishing things take time.

[13:25] <El_Che> yes, that's what I think

[13:25] <El_Che> brb

[13:25] <El_Che> coffee break

[13:25] <El_Che> colleages at my door

[13:25] <raschipi> Let me get one too.

[13:27] *** mspo joined
[13:36] <finanalyst> moritz: are you still online?

[13:39] <finanalyst> moritz: I recently installed the latest raduko using rakudobrew. I tried 'perl6-debug'. error 'no such file'. In .rakudobrew/bin directory, I found perl6-debug-m, but not perl6-debug

[13:40] <finanalyst> Hence perl6-debug does not work

[13:41] <araraloren> It's no perl6-debug, I think

[13:41] <finanalyst> I tried perl6-debug-m, after installing jnthn's debugging module. But I get an 'ast' error. 

[13:41] <finanalyst> araraloren: seems so. But then where is perl6-debug?

[13:42] <raschipi> perl6-debug-m is bitrotten

[13:42] <araraloren> I dont' know, I install Perl6 from source, there no perl6-debug in **bin** directory

[13:43] <raschipi> the name of the command is perl6-debug-m but it doesn't work

[13:44] <moritz> finanalyst: the 'ast' error is probably the most interesting part

[13:44] <moritz> if there's no bug report yet for that, might be worth opening one

[13:44] <finanalyst> last version of rakudo had a perl6-debug executable

[13:47] <finanalyst> moritz: https://pastebin.com/Kb5Q0B4p

[13:48] <finanalyst> doesnt seem interesting error message to me.

[13:50] <masak> has anyone else been confused by the fact that in the Perl world, we tend to talk about "parameters"/"arguments", but in many other communities (especially in CS), they're "formal parameters"/"actual parameters" ?

[13:52] <perlpilot> masak: not confused, but obviously noticed the difference

[13:52] *** dj_goku joined
[13:52] *** dj_goku left
[13:52] *** dj_goku joined
[13:52] <finanalyst> moritz: I get exactly the same error for any program, even say 'hello world;

[13:52] <finanalyst> 'hello world';

[13:52] <perlpilot> though I remember the parameters/arguments distinction from C too

[13:54] <moritz> finanalyst: then, as raschipi has said, the debugger seems to be bitrotten

[13:54] <finanalyst> so no debugger :(

[13:57] *** dj_goku left
[13:59] <zengargoyle> LOL

[13:59] <zengargoyle> m: my Buf $dst .= new(1..10); my Buf $src .= new(15,15); my $foo = $dst.contents.Array; my $bar = $src.contents.Array; splice $foo, 4, $bar.elems, $bar; $dst = Buf.new($foo); say $dst;

[13:59] <camelia> rakudo-moar 41bb13: OUTPUT: ¬´Buf:0x<01 02 03 04 0f 0f 07 08 09 0a>‚ê§¬ª

[14:00] *** khw joined
[14:01] <zengargoyle> for want of splice or substr-rw on Buf

[14:02] <zengargoyle> bioduds: that's my memcpy :P

[14:09] *** lostinfog joined
[14:09] *** lostinfog left
[14:11] *** skids joined
[14:15] *** pmurias left
[14:15] <zengargoyle> masak: i recently stumbled over argument/parameter for a moment.  but with defaults and casting and pass-by-value it sorta makes sense that they're two differnt things besides formal/actual.

[14:15] <zengargoyle> arguments are what you send, parameters are what you get

[14:15] <masak> zengargoyle: I think the difference is literally only in naming

[14:16] <masak> I mean, I agree with you because I also use the word "arguments"

[14:16] <masak> but... the people who call them "actual parameters" just have a different way to spell "arguments" :)

[14:17] <zengargoyle> i can see that but might then drop the 'formal' part.

[14:17] <jnthn> I found the Perl 6 one stuck in my head a lot better. :)

[14:18] <jnthn> In general though, using "parameters" or "arguments" handwavily works a huge amount of the time because the context makes it obvious :)

[14:20] *** kurahaupo_ joined
[14:20] <zengargoyle> i mostly forget which is which.

[14:22] <raschipi> Go by the definition of parameter: "A parameter, generally, is any characteristic that can help in defining or classifying a particular system".¬†"Argument" doesn't mean that.

[14:23] <zengargoyle> which side of the system are you looking from?

[14:24] <zengargoyle> the caller or the callee

[14:25] <raschipi> And arguments here are close to the mathematical definition, which is the input for a function.

[14:26] <raschipi> The argument of a function is the independent variable.

[14:32] *** kurahaupo_ left
[14:40] *** alimon left
[14:40] <bioduds> thanks friends

[14:42] <curt_> m: class A { multi method new(Rat $x) {};  multi method new(Int $x) {} };  A.new('this');

[14:42] <camelia> rakudo-moar 5e3fbc: OUTPUT: ¬´Default constructor for 'A' only takes named arguments‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[14:42] <curt_> That message is correct, but doesn't really nail the problem that I'm calling the constructor with incorrect positional arguments.

[14:43] *** Zoffix joined
[14:43] <Zoffix>  m: class A { proto method new (|) {}; multi method new(Rat $x) {};  multi method new(Int $x) {} };  A.new('this');

[14:43] <camelia> rakudo-moar 5e3fbc: ( no output )

[14:43] <Zoffix> reaally

[14:44] <jnthn> haha

[14:44] <Zoffix> Why doesn't it explode?

[14:44] <jnthn> That proto doesn't delegate to the candidates :)

[14:44] <Zoffix> Ah LOL

[14:44] <Zoffix>  m: class A { proto method new (|) {*}; multi method new(Rat $x) {};  multi method new(Int $x) {} };  A.new('this');

[14:44] <camelia> rakudo-moar 5e3fbc: OUTPUT: ¬´Cannot resolve caller new(A: Str); none of these signatures match:‚ê§    (A $: Rat $x, *%_)‚ê§    (A $: Int $x, *%_)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[14:44] <Zoffix> There :)

[14:44] <Zoffix> curt_: ^ without the proto you get the proto that also has the Mu.new candidates, so they end up handling the case and give wrongish error

[14:46] <curt_> I still want to allow Mu.new with named args.  I should still make a proto method new?

[14:47] <Zoffix> curt_: ah, I would just make a candidate that takes nameds

[14:48] <MasterDuke> zengargoyle: Buf does have splice

[14:48] <curt_> Zoffix: thanks

[14:48] <MasterDuke> m: my Buf $dst .= new(1..10); dd $dst; my Buf $src .= new(15,15); $dst.splice(2, 0, $src[3..5]); dd $dst;

[14:48] <camelia> rakudo-moar 5e3fbc: OUTPUT: ¬´Buf $dst = Buf.new(1,2,3,4,5,6,7,8,9,10)‚ê§Buf $dst = Buf.new(1,2,0,0,0,3,4,5,6,7,8,9,10)‚ê§¬ª

[14:48] <Zoffix>  m: class A { has $.bar; proto method new (|) {*}; multi method new(Rat $x) {};  multi method new(Int $x) {}; multi method new(*%_) { self.bless: |%_ };  dd A.new('this'); dd A.new: :42bar

[14:48] <camelia> rakudo-moar 5e3fbc: OUTPUT: ¬´5===SORRY!5=== Error while compiling <tmp>‚ê§Missing block‚ê§at <tmp>:1‚ê§------> 3_ };  dd A.new('this'); dd A.new: :42bar7‚èè5<EOL>‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        stateme‚Ä¶¬ª

[14:48] <Zoffix>  m: class A { has $.bar; proto method new (|) {*}; multi method new(Rat $x) {};  multi method new(Int $x) {}; multi method new(*%_) { self.bless: |%_ } };  dd A.new('this'); dd A.new: :42bar

[14:48] <camelia> rakudo-moar 5e3fbc: OUTPUT: ¬´Cannot resolve caller new(A: Str); none of these signatures match:‚ê§    (A $: Rat $x, *%_)‚ê§    (A $: Int $x, *%_)‚ê§    (A $: *%_)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[14:49] <Zoffix>  m: class A { has $.bar; proto method new (|) {*}; multi method new(Rat $x) {};  multi method new(Int $x) {}; multi method new(*%_) { self.bless: |%_ } }; dd A.new: :42bar

[14:49] <camelia> rakudo-moar 5e3fbc: OUTPUT: ¬´A.new(bar => 42)‚ê§¬ª

[14:49] <Zoffix> curt_: ^ that seems to do the trick

[14:50] <zengargoyle> MasterDuke: frak me

[14:50] <zengargoyle> i think i got lost somewhere when splice returned the spliced bit and went on a long chase.

[14:51] <Zoffix> BTW, it's Buf.splice isn't documented: https://docs.perl6.org/routine/splice

[14:52] <Zoffix> Oh, and basically untested: https://perl6.wtf/SETTING__src_core_Buf_pm.coverage.html#L503

[14:52] <zengargoyle> that may be it.  i *did* look at what docs said and tried anyway and figured it just wasn't the thing i wanted.

[14:53] <zengargoyle> and did WTF Buf are so crippled to not support almost obvious thing!

[14:53] *** Sound left
[14:53] <zengargoyle> lol

[14:53] <Zoffix> There's also subbuf-rw(

[14:54] <zengargoyle> tried that to.

[14:54] *** Zoffix left
[14:54] <zengargoyle> oh, maybe not.. but sorta tried subst* stuff.

[14:54] * zengargoyle now blames docs. :P

[14:54] <curt_> Module UUID uses .roll() to generate 16 bytes of randomness to make globally unique UUIDs  Is that suitable high quality randomness?

[15:02] *** alimon joined
[15:10] *** bjz left
[15:11] *** fatguy joined
[15:11] *** bjz joined
[15:12] *** eliv left
[15:15] *** eliv joined
[15:15] <zengargoyle> curt_: i'd guess it used /dev/urandom (or equiv on your system).

[15:16] <curt_> That's the question -- does it always use /dev/urandom, or does it take a seed from that and use a pseudo-random generator subsequently

[15:16] <El_Che> raschipi: thx for the input

[15:19] <raschipi> -- /dev/random and /dev/urandom both use a pseudo-random generator.

[15:20] <zengargoyle> curt_: i tried grepping nqp/MoarVM/rakudo and it looks to me like it relies on libtommath.... https://github.com/libtom/libtommath ... probably for a variety of mathy stuff.  quick look seems to imply /dev/urandom-like or provie your own PRNG.  there's also some mention of ARC4 so maybe a seed and a crypto generator.

[15:21] *** bjz left
[15:22] <zengargoyle> i'd guess it's at that point where we rely on some porable 3rd party libraries to do the cross platform heavy lifting.

[15:24] <curt_> ok thanks

[15:25] <zengargoyle> maybe ask in perl6-dev or reddit or somewhere... i too would like a more qualified answer since .roll() picks my lotto numbers. :)

[15:27] *** unixms joined
[15:27] <curt_> I trust it and honestly believe it will work fine and make perfectly good UUIDs.  But I'm making bindings for libuuid anyway, just for fun.  ;-)

[15:27] <Geth> ¬¶ doc: antquinonez++ created pull request #1337: Edits to performance.pod6

[15:27] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/pull/1337

[15:28] *** g4 left
[15:30] *** ufobat left
[15:31] <araraloren> Cool! Making a module, study from it, get fun from it :)

[15:33] <zengargoyle> curt_: tommath uses arc4random() or rand() depending on platform support.  

[15:34] <raschipi> libuuid also has support to generating a lot of UUIDs.

[15:36] *** devmikey joined
[15:37] <curt_> The linux kernel will also make good UUIDs for you `cat /proc/sys/kernel/random/uuid`

[15:37] <zengargoyle> and linux has an arc4.ko kernel module... so.. i'm sorta guessing it boils down to platfrom best available....

[15:37] <araraloren> UUID has 5 version the wiki said.

[15:39] <araraloren> Night, gotta sleep now. Zzz o/

[15:39] *** araraloren left
[15:40] *** dj_goku joined
[15:40] *** dj_goku left
[15:40] *** dj_goku joined
[15:42] *** hythm left
[15:45] *** dj_goku left
[15:47] *** hythm joined
[15:48] *** cdg left
[15:54] *** unixms_ joined
[15:55] <unixms_> logout

[15:55] *** unixms_ left
[15:55] *** unixms_ joined
[15:57] *** unixms_ left
[15:58] *** unixms_ joined
[15:59] *** unixms_ left
[15:59] *** unixms_ joined
[15:59] <Geth> ¬¶ doc: 68be3615a6 | (Steve Mynott)++ | doc/Type/Promise.pod6

[15:59] <Geth> ¬¶ doc: the the -> the

[15:59] <Geth> ¬¶ doc: review: https://github.com/perl6/doc/commit/68be3615a6

[16:00] *** unixms_ left
[16:00] *** zakharyas1 left
[16:09] *** unixms left
[16:10] <Geth> ¬¶ ecosystem: 91a61347ed | (Curt Tilmes)++ | META.list

[16:10] <Geth> ¬¶ ecosystem: Add LibUUID

[16:10] <Geth> ¬¶ ecosystem: 

[16:10] <Geth> ¬¶ ecosystem: See https://github.com/CurtTilmes/perl6-libuuid

[16:10] <Geth> ¬¶ ecosystem: review: https://github.com/perl6/ecosystem/commit/91a61347ed

[16:11] *** mcmillhj left
[16:11] *** mcmillhj joined
[16:16] *** finanalyst left
[16:17] *** Actualeyes left
[16:21] *** travis-ci joined
[16:21] <travis-ci> Doc build errored. Steve Mynott 'the the -> the'

[16:21] <travis-ci> https://travis-ci.org/perl6/doc/builds/236429410 https://github.com/perl6/doc/compare/a43667a050a8...68be3615a6b6

[16:21] *** travis-ci left
[16:21] *** lowbro left
[16:22] *** setty1 joined
[16:28] <stmuk> not my fault!

[16:29] <stmuk> IO::String fail 

[16:29] *** eliv left
[16:39] *** brrt joined
[16:41] *** Actualeyes joined
[16:45] *** itaylor57 joined
[16:46] *** robertle left
[16:56] *** Sound joined
[16:59] *** domidumont joined
[17:12] *** brrt left
[17:17] *** robertle joined
[17:21] *** wamba left
[17:26] *** raschipi left
[17:26] *** fatguy left
[17:27] *** fatguy joined
[17:28] *** dj_goku joined
[17:28] *** dj_goku left
[17:28] *** dj_goku joined
[17:28] *** camelia left
[17:29] *** camelia joined
[17:30] *** ChanServ sets mode: +v camelia

[17:34] *** dj_goku left
[17:34] <fatguy> how to do "a01" .. "a11" range correctly in p6 ?

[17:35] <AlexDaniel> m: .say for ‚Äòa01‚Äô, *.succ ‚Ä¶ ‚Äòa11‚Äô

[17:35] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´a01‚ê§a02‚ê§a03‚ê§a04‚ê§a05‚ê§a06‚ê§a07‚ê§a08‚ê§a09‚ê§a10‚ê§a11‚ê§¬ª

[17:35] <MasterDuke> m: say "a01", "a02" ... "a11"

[17:35] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(a01 a02 a03 a04 a05 a06 a07 a08 a09 a10 a11)‚ê§¬ª

[17:39] *** ChoHag left
[17:41] <fatguy> thanks! why it can't be implemented as simple as in p5 ?

[17:41] <fatguy> what is this -> *.succ 

[17:42] <perlpilot> I'm curious why 'a01' ... 'a11' doesn't work.  I thought the default *was* to use *.succ

[17:43] <hahainternet> how is it simpler in perl5?

[17:43] <perlpilot> fatguy: *.succ is the same thing as { $_.succ }   and .succ is a method that generates the "successor" to the object it is used upon

[17:43] <[Coke]> .. != ...

[17:44] <perlpilot> m: say "a01".succ;  # a02 is the successor to a01

[17:44] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´a02‚ê§¬ª

[17:46] <[Coke]> hahainternet: you don't need to say "a02" or it's equiv. as they did in the examples above, IIRC.

[17:46] <fatguy> hahainternet: in p5 we can just do 'a01'..'a11'

[17:46] <[Coke]> *its

[17:46] <fatguy> perlpilot: thanks !

[17:47] *** japhb joined
[17:47] <hahainternet> i'm surprised that works correctly in 5 but not in 6

[17:47] <hahainternet> probably the only case i've ever seen!

[17:47] <fatguy> me too !

[17:48] <hahainternet> it's probably a bug (probably)

[17:48] <perlpilot> P5 overloads .. quite a bit, P6 tries to keep it simpler.

[17:48] <perlpilot> but still ....

[17:48] <hahainternet> ‚Ä¶

[17:48] <perlpilot> m: .say for "a01" ... "a11";  # this has to be a bug

[17:48] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´a01‚ê§a11‚ê§¬ª

[17:49] *** sufrostico joined
[17:50] <MasterDuke> m: .say for "a" ... "d"

[17:50] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´a‚ê§b‚ê§c‚ê§d‚ê§¬ª

[17:50] *** Zoffix joined
[17:50] <Zoffix> perlpilot: it moves each char individually, so 0 goes to 1 and it's done

[17:50] <MasterDuke> i think ... can only figure out from two terms in the very trivial cases

[17:50] * Zoffix is looking into IO::String failurage

[17:51] <MasterDuke> m: .say for "a01" ... "a15"

[17:51] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´a01‚ê§a02‚ê§a03‚ê§a04‚ê§a05‚ê§a11‚ê§a12‚ê§a13‚ê§a14‚ê§a15‚ê§¬ª

[17:51] *** brrt joined
[17:52] <Zoffix> 1->5 for 0; 1->5 for 1; it's done

[17:52] <MasterDuke> m: .say for "a01" ... "a21"

[17:52] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´a01‚ê§a11‚ê§a21‚ê§¬ª

[17:52] <Zoffix> m: say ("foo000.txt" ... "foo999.txt").head: 10

[17:52] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(foo000.txt foo001.txt foo002.txt foo003.txt foo004.txt foo005.txt foo006.txt foo007.txt foo008.txt foo009.txt)‚ê§¬ª

[17:52] <Zoffix> ^ usecase

[17:54] <Zoffix> fatguy: it probably could, but it's the case of many volunteers working on this at different times. The string range is kinda iffy, though TimToady seems to grok it well

[17:54] <perlpilot> That's saying more about the semantics of *.succ than anything else I think

[17:55] <Zoffix> mhm

[17:55] <perlpilot> as I understand it, if there's a single item on the LHS, it uses *.succ to obtain the next item and compare with the RHS.   In this instance, I think it doesn't do that.

[17:55] <perlpilot> m: "a01".succ.say

[17:55] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´a02‚ê§¬ª

[17:55] *** bacek_ left
[17:55] <AlexDaniel> perlpilot: I'm shocked as well

[17:56] *** bacek_ joined
[17:56] <Zoffix> perlpilot: it's more involved.

[17:56] <AlexDaniel> I decided to stay away from stringy ranges, it's just better this way for my mental health

[17:56] <AlexDaniel> (or sequences)

[17:56] <Zoffix> I still have "read SEQUENCE source and document all cases" on my todo list. I'm sure there is nice and simple overall picture.

[17:57] <Zoffix> Sure, it's easy to poke random crap into the machine and be "socked" at the result :)

[17:57] <Zoffix> s: &SEQUENCE

[17:57] <Zoffix> 334 lines it is: https://github.com/rakudo/rakudo/blob/95b4e5d/src/core/operators.pm#L112-L436

[17:58] <Zoffix> Looking at all that nested bracing, feels like it could be made faster with a bit of nqp glue :)

[17:58] <AlexDaniel> it's easy to read the source, understand it and then use this unpredictable crap in your code. I'd much rather not.

[17:58] <Zoffix> pfft

[17:59] <AlexDaniel> on a slightly related note, RT #129131

[17:59] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=129131

[17:59] <Zoffix> tl;dr

[17:59] <Zoffix> wonder if I agree with ticket-Zoffix tho :P

[18:00] <AlexDaniel> tl;dr ‚ÄúAgreed, that's weird. I'm unsure why it's counting down and is indeed "too smart" for what I'd expect it to do.‚Äù

[18:00] <AlexDaniel> basically summarizes the whole thing, even though it wasn't said about the whole thing

[18:00] <fatguy> m: say ("node01abc" ... "node19abc").head: 11

[18:00] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(node01abc node02abc node03abc node04abc node05abc node06abc node07abc node08abc node09abc node11abc node12abc)‚ê§¬ª

[18:00] <Zoffix> boo; all this waiting and doc build still fails on latest rakudo

[18:01] <Zoffix> AlexDaniel: I think current Zoffix thinks we should burn string Ranges with fire, then split Range to int and non-int and that would be nice :)

[18:02] <AlexDaniel> Zoffix: can you elaborate on the ‚Äúsplit Range to int and non-int‚Äù part?

[18:03] *** cygx joined
[18:03] <Zoffix> AlexDaniel: basically we have ~18 conditionals checking if the range $!is-int: https://github.com/rakudo/rakudo/blob/nom/src/core/Range.pm

[18:03] <perlpilot> AlexDaniel: strings are split up into sections and each section is incremented independently.

[18:03] <Zoffix> So feels like it's aching to split up into int and non-int range and get rid of those conditionals

[18:04] *** travis-ci joined
[18:04] <travis-ci> Doc build errored. Steve Mynott 'the the -> the'

[18:04] <travis-ci> https://travis-ci.org/perl6/doc/builds/236429410 https://github.com/perl6/doc/compare/a43667a050a8...68be3615a6b6

[18:04] *** travis-ci left
[18:04] <AlexDaniel> by ‚Äúint‚Äù do you mean numeric? :)

[18:04] <Zoffix> No

[18:04] <AlexDaniel> okay

[18:04] <Zoffix> m: dd (1..10).is-int

[18:04] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Bool::True‚ê§¬ª

[18:04] <cygx> another surprise (at least to me): ranges *normally* don't go backwards, eg

[18:04] *** nadim left
[18:04] <cygx> m: say @("9".."1")

[18:04] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´()‚ê§¬ª

[18:04] <Zoffix> ^ by int I mean all ranges that return True for .is-int

[18:04] <cygx> they do if you have two chars:

[18:05] <cygx> m: say @("09".."11")

[18:05] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(09 08 07 06 05 04 03 02 01 19 18 17 16 15 14 13 12 11)‚ê§¬ª

[18:05] <Zoffix> cygx: IIRC that case gets passed on to `...`

[18:05] <AlexDaniel> m: dd (0..‚àû).is-int

[18:05] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Bool::False‚ê§¬ª

[18:06] <AlexDaniel> Zoffix: well, I'll take that

[18:07] <cygx> looks to me like an unbalanced WAT to DWIM ratio

[18:07] <Zoffix> There's another surprise in Ranges BTW

[18:08] <Zoffix> m: say (2e200 .. 2e300)[^10]

[18:08] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(2e+200 2e+200 2e+200 2e+200 2e+200 2e+200 2e+200 2e+200 2e+200 2e+200)‚ê§¬ª

[18:08] <Zoffix> :)

[18:08] <AlexDaniel> the only DWIM about it is ‚Äúha, I can generate filenames!‚Äù

[18:08] <Zoffix> There's more weird cases there were you start excluding the end point and stuff

[18:08] <cygx> only if you do so very carefully

[18:08] <cygx> m: say @("01".."20")

[18:08] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(01 00 11 10 21 20)‚ê§¬ª

[18:09] <AlexDaniel> and some of this shit is just flat out wrong

[18:09] <Zoffix> Oh, and I don't know offhand the codepoints, but there are infinite loops inside certain ranges, because a codepoint further down the range normalizes to an earlier codepoint, so it keeps looping in that area when you try to reify it

[18:09] <AlexDaniel> m: say (0..-‚àû).reverse[^10]

[18:09] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf)‚ê§¬ª

[18:09] <Zoffix> AlexDaniel: and what's right?

[18:10] <Zoffix> That's just a bug

[18:10] <Zoffix> Also, we seem to be talking about .. and ... interchangeably

[18:10] <AlexDaniel> you're right, you're right

[18:11] <AlexDaniel> that said, I wouldn't be wrong to say that most people will expect them to behave more or less similarly

[18:11] <Zoffix> Yeah, it's in my todo list

[18:11] <Zoffix> Along with "Fix Inf..Inf and Inf...Inf producing infinite seqs" "Also fix .minmax for (Inf..-Inf).minmax.say giving Inf, -Inf" and "Also fix (1..Inf).int-bounds; that makes [+] 1..* fail weirdly"

[18:11] *** Sound left
[18:12] <Zoffix> m: dd [+] 1..*

[18:12] *** Sound joined
[18:12] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´(timeout)WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:‚ê§Cannot coerce Inf to an Int‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[18:13] <MasterDuke> heh. a case of TMI

[18:13] <AlexDaniel> TMI?

[18:13] <MasterDuke> too much information

[18:14] <MasterDuke> "Cannot coerce Inf to an Int‚ê§  in block <unit> at <tmp> line 1" was useful, but the rest wasn't

[18:16] <Zoffix> would be cool if zef's `look` command carried over your ENV :/

[18:17] *** inokenty left
[18:22] <Zoffix> looks like IO::String got quite busted out with the encoding refactor; 'cause it relies on .lines being implemented in terms of .get

[18:23] <Zoffix> Gonna make an IO::UFO module soonish, so people could use it to make custom handles instead of hacking up everything or relying on specific configuration of guts...

[18:25] <Zoffix> also has a bug "my $x = IO::String.new: :buffer("hello-world"); say $x.get" "No such method 'key' for invocant of type 'Num'"

[18:30] <AlexDaniel> oh‚Ä¶ I just realized‚Ä¶

[18:30] <AlexDaniel> that you can .reverse string ranges too

[18:30] * AlexDaniel nnnnNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOooooooooooooooooooooooooo

[18:32] <mst> AlexDaniel is haunted!

[18:32] *** dwarring joined
[18:34] <AlexDaniel> well, the whole .reverse thing is broken

[18:36] *** khw left
[18:36] <Zoffix> m: sub foo($lines? is copy) { $lines = Inf if not $lines.DEFINITE or $lines === *; dd $lines }; foo 42

[18:36] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Num $lines = Inf‚ê§¬ª

[18:36] * Zoffix makes a face

[18:36] <Zoffix> Ah, I see

[18:36] <Zoffix> m: sub foo($lines? is copy) { $lines = Inf if not $lines.DEFINITE or $lines === Whatever; dd $lines }; foo 42

[18:36] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Int $lines = 42‚ê§¬ª

[18:36] * Zoffix is too used to nqp::istype() :)

[18:38] <Zoffix> still not it... now do I do nqp::istype($foo, Whatever)?

[18:39] <Zoffix> m: sub foo($lines? is copy) { $lines = Inf if not $lines.DEFINITE or $lines ~~ Whatever; dd $lines }; foo *

[18:39] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Num $lines = Inf‚ê§¬ª

[18:39] <Zoffix> m: sub foo($lines? is copy) { $lines = Inf if not $lines.DEFINITE or $lines ~~ Whatever; dd $lines }; foo 42

[18:39] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Int $lines = 42‚ê§¬ª

[18:39] <Zoffix> k

[18:39] *** cygx left
[18:44] *** khw joined
[18:51] <Zoffix> ugh... Fixed the two IO::String bugs, but hit on Rakudo bug >_<

[18:51] <Zoffix> m: my $p = :42a; say $p ~~ Inf

[18:51] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Cannot resolve caller Numeric(Pair: ); none of these signatures match:‚ê§    (Mu:U \v: *%_)‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[18:51] <Zoffix> c'mon, bruh

[18:56] <Zoffix> .tell hoelzro Sent you a PR fixing a couple of bugs; an old one in .get() and a new one in .lines due to latest Rakudo encoding refactor no longer using .get for .lines; https://github.com/hoelzro/p6-io-string/pull/8

[18:56] <yoleaux> Zoffix: I'll pass your message to hoelzro.

[18:56] <Zoffix> ^ that fixes the doc build

[18:56] *** dct joined
[18:56] * Zoffix flies away into the sun, cape flapping in the wind

[18:56] *** Zoffix left
[18:58] *** brrt left
[19:00] *** pilne joined
[19:01] *** ChoHag joined
[19:01] <dwarring> p6: "tst.txt".IO.spurt([~] 'a' .. 'z'); my $ioh = "tst.txt".IO.open(:r); say $ioh.read(4); $ioh.seek(1, SeekFromCurrent); say $ioh.read(4);

[19:01] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Blob[uint8]:0x<61 62 63 64>‚ê§Blob[uint8]:0x<>‚ê§¬ª

[19:02] <dwarring> bisect: "tst.txt".IO.spurt([~] 'a' .. 'z'); my $ioh = "tst.txt".IO.open(:r); say $ioh.read(4); $ioh.seek(1, SeekFromCurrent); say $ioh.read(4);

[19:02] <bisectable6> dwarring, Bisecting by output (old=2015.12 new=95b4e5d) because on both starting points the exit code is 0

[19:05] *** jeek left
[19:06] <MasterDuke> AlexDaniel: ^^^

[19:07] *** bisectable6 left
[19:08] <dwarring> anyway, nothing returned from second read after seekFromCurrent

[19:08] <dwarring> Recent regression. I'll put in an RT

[19:12] *** bisectable6 joined
[19:12] *** ChanServ sets mode: +v bisectable6

[19:14] <AlexDaniel> blargh

[19:14] <AlexDaniel> again?

[19:15] <AlexDaniel> bisect: "tst.txt".IO.spurt([~] 'a' .. 'z'); my $ioh = "tst.txt".IO.open(:r); say $ioh.read(4); $ioh.seek(1, SeekFromCurrent); say $ioh.read(4);

[19:15] <bisectable6> AlexDaniel, Bisecting by output (old=2015.12 new=95b4e5d) because on both starting points the exit code is 0

[19:15] <bisectable6> AlexDaniel, bisect log: https://gist.github.com/1b6f1bdabefa1cb13338451abceea153

[19:15] <bisectable6> AlexDaniel, (2017-05-25) https://github.com/rakudo/rakudo/commit/93f46451c9d5e44063b05b5597b8678133f8f22e

[19:15] <AlexDaniel> dwarring: ‚Üë ?

[19:16] *** rindolf left
[19:17] *** dj_goku joined
[19:17] *** dj_goku left
[19:17] *** dj_goku joined
[19:17] *** domidumont left
[19:19] *** alimon left
[19:20] *** Zoffix joined
[19:20] <Zoffix> dwarring: you're missing :bin on open

[19:21] <Zoffix> dwarring: oh wait, I think .read is still supposed to work in non-bin mode under new encoding paradigm

[19:21] * Zoffix looks

[19:21] <Zoffix> dwarring: yeah. Will fix in ~3 hours. In the meantime, you can open in `:bin` mode to workaround it

[19:21] *** dj_goku left
[19:22] <Zoffix> m: "tst.txt".IO.spurt([~] 'a' .. 'z'); my $ioh = "tst.txt".IO.open(:r, :bin); say $ioh.read(4); $ioh.seek(1, SeekFromCurrent); say $ioh.read(4);

[19:22] <camelia> rakudo-moar 95b4e5: OUTPUT: ¬´Buf[uint8]:0x<61 62 63 64>‚ê§Buf[uint8]:0x<66 67 68 69>‚ê§¬ª

[19:22] <dwarring> Zoffix: thanks

[19:23] <dwarring> Zoffix: RT #131376

[19:23] <synopsebot6> Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131376

[19:24] * Zoffix clicks Take

[19:24] *** brrt joined
[19:25] <AlexDaniel> dwarring: thanks for reporting the bug :)

[19:25] * AlexDaniel slaps bisectable

[19:25] <dwarring> AlexDaniel: yw

[19:26] <Zoffix> Yeah, dwarring++ fast reporting, considering this refactor went in like 4 hours ago :)

[19:27] * dwarring builds in the morning

[19:27] <Zoffix> At least I hope I can fix it... The whole seek-non-bin-handle chunk is missing: https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Handle.pm#L482-L488

[19:28] <dwarring> adding :bin works for me

[19:28] <Zoffix> Ah, OK now I get it.

[19:28] * Zoffix will fix in ~3 hourts

[19:28] <AlexDaniel> .oO( in ‚âà3 hurts )

[19:29] <Zoffix> Also Zoffix-- # wrote crappy seek tests

[19:30] <moritz> Zoffix++ # writing seek tests at all

[19:32] <AlexDaniel> whateverables-- for being stupid bots and not writing any tests at all

[19:33] *** dct left
[19:34] *** alimon joined
[19:36] *** stmuk_ joined
[19:38] *** stmuk left
[19:40] *** cdg joined
[19:42] *** dct joined
[19:47] *** jeek joined
[19:51] <tony-o> ingy: that thing is probably very bitrotted - i can take a look at it on sunday

[20:01] <robertle> tony-o: not sure you got my message the other day: travis seems to work ok against my pluggable branch, so you probably only need to press the button on https://travis-ci.org/tony-o/perl6-pluggable and yours will too

[20:12] <Zoffix> When does END in a module, in relation to program that loads it and other modules?

[20:13] <moritz> last-loaded first, IIRC

[20:14] <Zoffix> Ok

[20:15] <Zoffix> Gonna make a Promise::AutoAwait that automatically awaits (non-blockingly) sunk Promises. Was pondering the possible explosions of my awaiting for them in END

[20:16] <moritz> http://shop.oreilly.com/product/0636920065883.do Think Perl 6 now available!

[20:17] <Zoffix> w00t

[20:18] <Zoffix> So many books we got... I thought it was already available there long time ago; am I thinking of different book?

[20:18] <brrt> moritz++

[20:20] <moritz> Zoffix: it was available for a preview of the first $N chapters (where $N around 8 or 12 or so)

[20:20] <Zoffix> Ahhh

[20:20] *** brrt left
[20:20] <moritz> brrt: I didn't do much :-)

[20:21] <moritz> (just a bit of proof-reading, and dropping a link now and then)

[20:22] *** brrt joined
[20:23] *** cdg left
[20:23] *** cdg joined
[20:29] *** brrt left
[20:29] *** kaare__ left
[20:29] *** kaare__ joined
[20:34] *** xiaomiao left
[20:35] *** mcmillhj left
[20:37] *** xiaomiao joined
[20:41] *** devmikey left
[20:44] <tinita> Zoffix: btw,this is what I ended up with: https://github.com/yaml/yaml-perl6/blob/master-new/lib/YAML/Loader.pm6

[20:48] *** alimon left
[20:49] <Zoffix> hehe, well, I'm glad I don't have to maintain all that pushing and popping :)

[20:49] *** mcmillhj joined
[20:49] <tinita> Zoffix: suggestions welcome =)

[20:50] <Zoffix> m: for 0, 2 ‚Ä¶ 12 { .say }

[20:50] <camelia> rakudo-moar 43b03f: OUTPUT: ¬´0‚ê§2‚ê§4‚ê§6‚ê§8‚ê§10‚ê§12‚ê§¬ª

[20:50] <Zoffix> Another way to write that loop(...;...; $i += 2) thing

[20:50] <tinita> cool, thanks

[20:51] <tinita> i was trying to do:

[20:51] <Zoffix> tinita: no suggestions :) it'd require underatanding what that code is doing... and maybe current way is the best. I don't know :)

[20:51] <Zoffix> *understanding

[20:51] <tinita> %$hash = @$array; # perl5

[20:51] <Zoffix> $hash = $array.Hash # perl 6

[20:51] <tinita> is there a way in perl 6 for this?

[20:52] * tinita trying

[20:52] <tinita> well

[20:52] <Zoffix> I think $hash = %$arrau will work too

[20:52] <tinita> i think i tried something like that

[20:52] <tinita> the problem is, the $hash then changes

[20:52] <tinita> but i have a "reference" to it somewhere else

[20:52] <Zoffix> Ahh

[20:52] <tinita> because YAML has anchors/aliases

[20:53] <Zoffix> Unsure offhand of a way

[20:53] *** mcmillhj left
[20:54] <tinita> Zoffix: can I use $i in that for loop somehow?

[20:54] * tinita reads the docs...

[20:54] *** brrt joined
[20:55] <Zoffix> m: for 0, 2 ‚Ä¶ 12 -> $i { $i.say }

[20:55] <camelia> rakudo-moar 43b03f: OUTPUT: ¬´0‚ê§2‚ê§4‚ê§6‚ê§8‚ê§10‚ê§12‚ê§¬ª

[20:55] <Zoffix> It's just a block. You can give it any signature

[20:56] <Zoffix> m: for 0, 2 ‚Ä¶ 14 -> $i, $j { [$i, $j].say }

[20:56] <camelia> rakudo-moar 43b03f: OUTPUT: ¬´[0 2]‚ê§[4 6]‚ê§[8 10]‚ê§[12 14]‚ê§¬ª

[20:56] <tinita> ok, thanks. loop isn't working yet, though

[20:56] <tinita> for 0, 2 .. $array.elems -> $i {

[20:56] *** mcmillhj joined
[20:57] <Zoffix> tinita: it's three dots

[20:57] *** skids left
[20:58] <Zoffix> Or unicode elipsis: ‚Ä¶

[20:58] *** jast left
[20:58] <Zoffix> Right now you're looping over two items; 0 and Range from 2 to $array.elems

[20:59] <Zoffix> .. creates Range object; ... (or ‚Ä¶) creates a Seq object

[20:59] <tinita> hm, i get warnings now, still trying to figure out...

[20:59] *** jast joined
[21:00] <tinita> ah, elems -1

[21:00] <tinita> for 0, 2 ... $array.elems - 1 -> $i {

[21:00] <tinita> Zoffix: thanks

[21:00] <Zoffix> oops, sorry :)

[21:00] <Zoffix> m: for 0, 2 ‚Ä¶^ 12 -> $i { $i.say }

[21:00] <camelia> rakudo-moar 43b03f: OUTPUT: ¬´0‚ê§2‚ê§4‚ê§6‚ê§8‚ê§10‚ê§¬ª

[21:00] <tinita> np =)

[21:00] <Zoffix> You can also use ‚Ä¶^ to exclude end point

[21:01] <tinita> tests succeed \o/

[21:01] *** ChoHag left
[21:01] *** mcmillhj left
[21:03] *** setty1 left
[21:05] *** dj_goku joined
[21:05] *** cpage_ left
[21:10] *** dj_goku left
[21:12] *** mcmillhj joined
[21:13] *** mr-foobar left
[21:16] *** yqt left
[21:17] *** mcmillhj left
[21:19] *** cpage_ joined
[21:21] *** brrt left
[21:29] *** bwisti left
[21:36] *** Sound left
[21:48] * ingy waves

[21:50] <Zoffix> \o

[22:09] *** cbd_ joined
[22:09] <cbd_> subset question: I want to define a subset of Int arrays that only have two elements

[22:09] <cbd_> how is it done?!?

[22:10] <Zoffix> cbd_: typed Int arrays or just arrays containing Int objects?

[22:10] <cbd_> I'm not sure I understand the difference

[22:11] <cbd_> If I were to say: my Int @arr = (1,2) which is that?

[22:11] <Zoffix> Typed

[22:11] <Zoffix> m: subset Foo of Array where {.all ~~ Int and .elems == 2}; my Foo $a = [2, 3];

[22:11] <camelia> rakudo-moar b6c9e8: ( no output )

[22:14] <Zoffix> ^ that one isn't typed

[22:14] <Zoffix> m: subset Foo of Array[Int] where .elems == 2; my Foo $a = Array[Int].new: 2, 3;

[22:14] <camelia> rakudo-moar b6c9e8: ( no output )

[22:15] <Zoffix> ^ that one is, but as you can see, you need to do more work to create one when you're assigning stuff to it

[22:15] <cbd_> That first example you gave gives an error when I run it

[22:15] <cbd_> Cannot modify an immutable Int

[22:15] <Zoffix> cbd_: what's your perl6 version?

[22:15] <cbd_> ah wait...

[22:16] <cbd_> my fault

[22:19] <cbd_> Though I am not sure I see the distinction between the two different forms

[22:19] <cbd_> Both restrict to an array of two Int objects?

[22:21] <Zoffix> cdg: unsure. I think one is a compile-type check and the other is runtime check.

[22:22] *** cpage_ left
[22:25] *** bpmedley joined
[22:25] <cbd_> The latter is the compile-time check?

[22:25] *** cdg left
[22:26] <Zoffix> The typed one is a compile-type check (I don't really know; I'm no expert)

[22:26] <cbd_> sure

[22:29] <cbd_> well thank you for helping out

[22:29] <Zoffix> Any time.

[22:30] *** cbd_ left
[22:31] *** skids joined
[22:31] <lizmat> m: my Int @a[2]   # an Int array of 2 elements ?

[22:31] <camelia> rakudo-moar b6c9e8: ( no output )

[22:32] <Zoffix> Oh :( didn't think of that one >_<

[22:33] <lizmat> m: my Int @a[3]; sub a(@b where *.shape eqv (2,)) { say "foo" }; a @a

[22:33] <camelia> rakudo-moar b6c9e8: OUTPUT: ¬´Constraint type check failed in binding to parameter '@b'; expected anonymous constraint to be met but got Array[Int] (Array[Int].new(:shape...)‚ê§  in sub a at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:33] <lizmat> m: my Int @a[2]; sub a(@b where *.shape eqv (2,)) { say "foo" }; a @a

[22:33] <camelia> rakudo-moar b6c9e8: OUTPUT: ¬´foo‚ê§¬ª

[22:34] *** bjz joined
[22:34] * lizmat goes to bed

[22:40] <KotH> good evening

[22:40] <KotH> has anyone ever done something as crazy as using perl6 as an embedded language in an other application?

[22:41] <KotH> if so, where can i get the codez? ;-)

[22:41] <jnthn> m: my Int @a[2]; sub a(@b[2]) { }; a @a

[22:41] <camelia> rakudo-moar b6c9e8: ( no output )

[22:41] <jnthn> m: my Int @a[3]; sub a(@b[2]) { }; a @a

[22:41] <camelia> rakudo-moar b6c9e8: OUTPUT: ¬´Constraint type check failed in binding to parameter '@b[2]'; expected anonymous constraint to be met but got Array[Int] (Array[Int].new(:shape...)‚ê§  in sub a at <tmp> line 1‚ê§  in block <unit> at <tmp> line 1‚ê§‚ê§¬ª

[22:41] <jnthn> lizmat: You can get that with a lot less typing ;)

[22:42] <jnthn> KotH: Presumably the person who did the Inline::Perl6 module for Perl 5 (which embeds Perl 6 in Perl 5) was crazy enough :)

[22:43] <KotH> ah! didnt think about that one

[22:43] <KotH> thanks!

[22:48] *** wamba joined
[22:53] *** dj_goku joined
[22:53] *** dj_goku left
[22:53] *** dj_goku joined
[22:54] <KotH> jnthn: hmm.. if i understand the code correctly, it works by running perl6 in which it runs perl5 code and uses the callbacks into perl6 to run perl6 code from perl5 ..... not exactly what i was looking for

[22:55] <jnthn> KotH: Yeah, it actually gets a lot of code re-use that way

[22:55] <jnthn> KotH: But the general principle is about right

[22:56] <jnthn> You run a Perl 6 program that registers callbacks via. NativeCall, which you can then call from your native code to trigger stuff to happen in Perl 6

[22:56] <ingy> Isn't Inline::Perl6 ancient?

[22:57] <KotH> jnthn: but doesnt really work if main() needs to be that other application

[22:57] <jnthn> KotH: In the Perl 5 case, main() is Perl 5

[22:58] <jnthn> Uh, in the Inline::Perl6 case even

[22:58] <KotH> hmm.. then i dont get how it works ^^'

[22:58] *** dj_goku left
[22:58] <jnthn> ingy: Only if Octover 2016 is ancient ;)

[22:58] <jnthn> *October

[22:59] <ingy> I thought it was more 2006 :)

[23:01] <jnthn> Dunno, mebbe the name got repurposed or something

[23:02] <jnthn> KotH: I think it hangs off the `moar` executable of MoarVM really just calling a bunch of functions in libmoar to set up the VM and get it to run something, to instead at a convenient point run some Perl 6 code instead.

[23:04] <jnthn> https://metacpan.org/source/NINE/Inline-Perl6-0.08/Perl6.xs#L84 # here is where it injects the script to run

[23:05] *** cpage_ joined
[23:08] <KotH> jnthn: yeah.. i overlooked Perl6.xs which does replicate part of MoarVM's main()

[23:11] *** Actualeyes left
[23:18] <KotH> thanks a lot!

[23:20] *** dct left
[23:22] <jnthn> np, good luck :)

[23:24] *** Actualeyes joined
[23:34] *** PerlJam joined
[23:55] <Zoffix> m: with '/tmp/foo99'.IO { .spurt: "meowsmeows"; with .open { .read: 4; .seek: 1, SeekFromCurrent; say .read: 4 } } 

[23:55] <camelia> rakudo-moar 094e77: OUTPUT: ¬´Buf[uint8]:0x<6d 65 6f 77>‚ê§¬ª

[23:55] <Zoffix> dwarring: ^ that's fixed now

[23:55] <Zoffix> \o

[23:55] *** Zoffix left
