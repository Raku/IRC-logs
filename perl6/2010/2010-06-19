[00:00] *** ash__ joined
[00:01] <masonkramer> I'm not quite following.  The module that requested what?  The module that requested the registration of a CANDO, or the module that asked $foo whether it 'bars'?

[00:01] <pugssvn> r31371 | sorear++ | [viv] Allow arguments to be passed to emitters.  Use this to start assembling the viv --psq declaration system. 

[00:02] <sorear> masonkramer: the latter

[00:02] <sorear> our import system is designed to stop action at a distance... even the good kind

[00:04] <masonkramer> What other module would need to know that $foo.bars?  

[00:06] *** ash__ left
[00:06] *** supernovus joined
[00:08] <masonkramer> Wait.  So if I'm in package Foo; I can't do this: $foo.baz.bars, if Baz::bars() is a CANDO multi?

[00:09] <masonkramer> or $self.baz.bars more likely

[00:09] <sorear> That's not what I mean

[00:09] <sorear> If you're in package Foo, you can do Bar::x

[00:09] <sorear> If you're in package Baz, you can do Bar::x, BUT IT CALLS CANDO AGAIN EVEN IF CANDO INSTALLED A SYMBOL!

[00:10] <sorear> because the symbol tables are not shared between different importations of the same module

[00:10] <sorear> this is harmful if you're using CANDO for, uh, automatic loading

[00:10] <sorear> if you're using it for something else it's not so bad

[00:11] <masonkramer> OHHhhhhh.

[00:11] <masonkramer> That's bad!

[00:12] <masonkramer> but couldn't they be installed via the metaclass at runtime?

[00:13] <masonkramer> something like...  multi CANDO { ... blah blah ... $self->meta->add_method sub { ... }} 

[00:14] <sorear> that only works if CANDO is in a class

[00:18] <masonkramer> Gah.

[00:20] *** snarkyboojum joined
[00:22] *** supernovus left
[00:32] *** fridim_ joined
[00:36] *** xabbu42_ joined
[00:36] *** xabbu42 left
[00:36] *** xabbu42_ is now known as xabbu42

[00:36] *** christine left
[00:40] *** masonkramer_ joined
[00:40] *** masonkramer left
[00:40] *** masonkramer_ is now known as masonkramer

[00:41] <TimToady> well, there are various ways of making CANDO work on functions, some of which off more opportunity for pessimalization than others

[00:42] *** christine joined
[00:42] <TimToady> one possibility that is fairly innocuous is to register one or more packages as failovers if a function isn't found in in the standard lexical search.

[00:42] <TimToady> this preserves the efficiency of everything coming out of CORE, at the expense of not allowing you to shadow any existing lexical names

[00:43] <TimToady> or one could call functions directly out of the CANDO'd package using a specific notation, if you want to bypass any lexical names

[00:44] *** meppl left
[00:44] <TimToady> but importing a CANDO doesn't even necessarily have to involve a named package, just register the package to fail over to, which could be anonymous

[00:45] <Wolfman2000> ...anyone know when masak is planning on coming back? I want to show him a non perl project I've been improving in case my web development skills are still needed for a Perl 6 project

[00:46] <TimToady> and then the CANDO can presumably install names into said package to cache callables; presumably the package's names would be examined before CANDO, or it won't help

[00:48] <TimToady> Wolfman2000: he is likely to be sleeping right now, given his timezone

[00:48] <Wolfman2000> ...right. worldwide channel, I never remember which time zone is which

[00:51] *** fridim_ left
[00:51] *** Rincewind left
[00:51] *** sorear left
[00:52] *** sorear joined
[00:53] <TimToady> sorear: re binding to dynamic vars, it seems like it would be permissible from the standpoint of knowing where the variable name is stored, since lookup of necessity must find the lexpad in question (in the absence of caching)

[00:53] <TimToady> however, we need to make some promises to the optimizer here, at least for readonly variables

[00:54] <TimToady> if a dynamic variable is initialized with ::=, I think this implies that such variables are only for conveying values downward, much like env vars are mere string values

[00:55] <TimToady> for other dynamic variables, the variable itself is the "value" being passed down, so that it can be an lvalue, and perhaps also a bvalue

[00:56] *** JimmyZ joined
[00:56] <TimToady> if there's some good reason for restricting dynavars to lvalues and disallow bvalues, I'd be okay with that, I think

[00:57] <TimToady> so ::= vars can cache values lower in the call tree, while other's can only cache the location to avoid chasing up the callframes at least

[00:59] *** Schwern left
[01:00] <TimToady> so I could be persuaded that we need an 'is bindable' on a dynamic variable to keep it "soft"

[01:07] *** JimmyZ left
[01:11] *** TiMBuS joined
[01:14] <k23z__> so what's up ?

[01:16] *** xabbu42_ joined
[01:16] *** xabbu42 left
[01:16] *** xabbu42_ is now known as xabbu42

[01:20] <Tene> TimToady: any examples of lists degenerating to single values?

[01:21] <TimToady> sure, just a sec

[01:22] <TimToady> here's one from earlier today

[01:22] <TimToady> rakudo: my %h; %h.push: { a => 1, b => 2, c => 1}.invert; say %h.perl

[01:22] <p6eval> rakudo 92e914: OUTPUT«{"2" => "b", "1" => ["c", "a"]}␤»

[01:22] <TimToady> the value might or might not be an array, but you can iterate any of the values

[01:23] <Tene> Thanks. :)

[01:27] <TimToady> jnthn, pmichaud: take must decontainerize by default just as return from a non-rw function does

[01:28] <TimToady> in fact, since rw-ness is an attribute of the function, not the return statement, I'd be tempted to do similarly for gather

[01:28] <TimToady> and say that rw-ness is an option on the gather, not on the take

[01:29] <TimToady> gather-rw { ... take $x ... } or some such

[01:29] <k23z__> what's up with Perl6 recently ?

[01:29] *** xabbu42 left
[01:29] <k23z__> is CGI working yet ?

[01:29] *** xabbu42 joined
[01:29] <k23z__> how 'bout any web stuff ? how 'bout sockets ?

[01:29] <k23z__> how 'bout pipes/fifos ?

[01:29] <TimToady> yes, but most of the people who are familiar with that are asleep right now

[01:30] <k23z__> hmm , would that be masak ?

[01:30] <snarkyboojum> k23z__: web/sockets/CGI stuff is working

[01:30] <k23z__> snarkyboojum: last time I been here and asked that(1-2 months ago) it was broke, it's nice to know it's working now

[01:30] <k23z__> snarkyboojum: have you played with that part ?

[01:31] <snarkyboojum> k23z__: I've played with sockets and http::client etc, not so much CGI or web

[01:31] <snarkyboojum> k23z__: just wrote a little identi.ca command line client using http::client with basic auth etc :)

[01:32] <k23z__> snarkyboojum: can I haz some looks ?

[01:32] <k23z__> snarkyboojum: have you gots them githubz ?

[01:32] <snarkyboojum> uses http://github.com/snarkyboojum/denter, http://github.com/snarkyboojum/http-client, http://github.com/snarkyboojum/Perl6-MIME-Base64

[01:33] <snarkyboojum> that http-client is a forked version of carlins original to do basic auth

[01:35] <snarkyboojum> k23z__: jnthn recently put together a demo using perl 6 and CGI from perl 5 (using blizkozt) for the kiev hackathon (I think) - I'll see if I can find that post

[01:35] <snarkyboojum> k23z__: also supernovus has just put up his SCGI library on proto

[01:36] <snarkyboojum> k23z__: and then there's masak's web etc ;) (not sure if that's running on master atm)

[01:37] <k23z__> stuff seems to be getting together

[01:38] <snarkyboojum> k23z__: "stuff" is definitely getting quite useable :)

[01:39] *** ajs1 joined
[01:39] <snarkyboojum> k23z__: re Perl 6/FakeDBI/JSON::Tiny/CGI/blizkost -> http://pivo.jnthn.net/

[01:41] *** ajs2 joined
[01:42] *** ajs left
[01:43] *** ajs1 left
[01:48] *** eternaleye joined
[01:50] <snarkyboojum> you'll notice Fat Yak from Sydney :P very nice beer for hot summer days :)

[01:53] <Wolfman2000> masak is the expert on the Perl 6 web activities. I myself know only...1/200th as much really.

[01:53] <Wolfman2000> k23z__: ^^

[01:57] *** patspam left
[01:58] <snarkyboojum> k23z__: just tried web and doesn't look like it's running on master yet

[02:04] <snarkyboojum> k23z__: but tene or masak could tell you more about that :)

[02:04] *** ajs2 is now known as ajs

[02:05] *** whiteknight left
[02:09] *** gfx joined
[02:11] <snarkyboojum> would be awesome to have proto linking off to another page giving an indicator if test suites for modules pass on current rakudo and/or general working status

[02:18] *** fridim_ joined
[02:18] *** xabbu42_ joined
[02:18] *** xabbu42 left
[02:18] *** xabbu42_ is now known as xabbu42

[02:24] <pugssvn> r31372 | lwall++ | [S06] spec processing of rw vs de-containerized return values 

[02:25] <pmichaud> TimToady: (decontainerize)  noted

[02:25] <pmichaud> didn't know that had to happen for non-rw functions too, but that's certainly doable

[02:25] *** plobsing joined
[02:26] <TimToady> I think uniformly defaulting to value returns is sane

[02:26] *** ab5tract left
[02:27] <TimToady> rakudo: my $x = 1; sub foo () { $x }; foo() = 2; say $x

[02:27] <p6eval> rakudo 92e914: OUTPUT«2␤»

[02:27] <TimToady> this should not allow assignment

[02:28] *** xabbu42_ joined
[02:28] *** xabbu42 left
[02:28] *** xabbu42_ is now known as xabbu42

[02:28] <TimToady> rakudo: my $x = 1; sub foo () { 1 }; foo() = 2; say $x

[02:28] <p6eval> rakudo 92e914: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/vcLYLM87An␤»

[02:28] <TimToady> should act more like that

[02:29] <TimToady> except we can probably carp at compile time

[02:29] *** Visitor99 joined
[02:29] <sorear> TimToady: What I'm thinking of is that, if contextuals are bvalues, "my $x ::= 1" can still be changed in called methods

[02:30] <sorear> Which seems to defeat much of the purpose

[02:30] <TimToady> that would also have to be special cased where the optimizer hasn't already "valueized" it

[02:31] <TimToady> basically, anywhere we say the optimizer is allowed to assume such-and-so, we should not let people get away with it when it doesn't

[02:31] <TimToady> (if possible)

[02:31] <TimToady> or it should be officially specced as erroneous

[02:32] <sorear> Do we expect the number of "The optimizer is allowed to assume such-and-so" to increase much?

[02:32] <sorear> I find that quite a few intuitively obvious such things don't seem to be mentioned anywhere

[02:35] *** Schwern joined
[02:36] * TimToady expects that the specs will continue to be filled out with stuff that is "intuitively obvious but needs to be documented anyway"

[02:37] <TimToady> feel free to make a list

[02:40] *** Visitor99 left
[02:40] *** Visitor99 joined
[02:47] <sorear> thanks, I'll start keeping one

[02:47] <sorear> on a completely unrelated note

[02:47] <sorear> when a block is entered, how does Perl 6 know what to clone

[02:47] <sorear> ?

[02:55] <pugssvn> r31373 | lwall++ | [S03] explain more about the relationship of hypers with lazy infinitude 

[02:56] *** justatheory left
[02:57] <TimToady> in the absence of eval, the compilation already knows what external lexicals have been referenced

[02:57] <TimToady> and I speculated about evals earlier today

[02:58] <TimToady> std: my $x; {{{{ $x; my $x }}}} # middle $x creates alias in inner pad

[02:58] <p6eval> std 31372: OUTPUT«===SORRY!===␤Lexical symbol '$x' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as OUTER::OUTER::OUTER::OUTER::<$x>␤  before you can unambiguously declare a new '$x' in this scope at /tmp/ioYAVnzP4M line

[02:58] <p6eval> ..…

[03:06] <sorear> right

[03:06] <colomon> TimToady: just looking at the hyper / lazy change.  Is that actually workable?

[03:06] <sorear> normally, I imagine closure cloning as being something that happens when the closure expression is evaluated

[03:06] <colomon> It's not clear to me how to figure out how to DWIM without knowing the length of the lists in advance.

[03:06] <sorear> but that doesn't work in Perl 6, because the closure expression is evaluated at BEGIN time and the result installed into the protolexpad, for "sub"

[03:07] <sorear> so I'm back to not really knowing what should happen

[03:08] <TimToady> colomon: as it says, it depends on the data structure

[03:15] <colomon> hmmm... okay, I've worked out how to handle the dwimmy cases with lazy lists for input.  I guess the non-dwimmy case is obvious, though it really sits in my craw that doing it this way, we can only report an error after doing all the calculations.

[03:21] *** ciphertext joined
[03:23] *** Schwern left
[03:27] <sorear> rakudo: my &foo; say &foo.WHAT;

[03:27] <p6eval> rakudo 92e914: OUTPUT«Any()␤»

[03:28] <sorear> rakudo: my &foo; say VAR(&foo).WHAT;

[03:28] <p6eval> rakudo 92e914: OUTPUT«Could not find sub &VAR␤  in main program body at line 11:/tmp/HyAEvgXOha␤»

[03:28] <sorear> rakudo: my &foo; say &foo.VAR.WHAT;

[03:28] <p6eval> rakudo 92e914: OUTPUT«Method 'VAR' not found for invocant of class ''␤  in main program body at line 11:/tmp/WeuPSvdg9C␤»

[03:44] <pugssvn> r31374 | sorear++ | [viv-psq] Translate declarations of $@& variables 

[03:45] *** agentzh joined
[04:05] *** envi^home joined
[04:17] *** diakopter sets mode: +o sorear

[04:22] *** porco joined
[04:22] *** agentzh left
[04:25] <diakopter> sorear: WOW

[04:25] <diakopter> r31374.  excellent

[04:25] *** redicaps joined
[04:25] <diakopter> Dictionary[str,$type]

[04:25] <diakopter> super-cool

[04:27] *** porco left
[04:27] * diakopter experiences yet another Chrome (dev channel) fail

[04:29] <sorear> WOW?  that was a tiny step

[04:30] <sorear> right now I'm trying to do subs

[04:30] <sorear> the hard part /here/ is that, in order to correctly call a sub (STD uses named and optional params), I need to know its signature

[04:31] <sorear> so I need to hack Actions to save the name -> definition mapping

[04:31] <sorear> and you, how goes grammars?

[04:32] *** tedv left
[04:40] *** [mark] joined
[04:40] *** fridim_ left
[04:46] <diakopter> no progress other than while sleeping. I have the whole weekend, though.

[04:50] <diakopter> r31374 is WOW b/c it's exactly as I imagined it. ;)

[04:51] <diakopter> (effectively, I mean)

[04:51] <diakopter> hrm, it seems perlesque evalbot is still broken

[04:59] *** Guest23195 joined
[05:01] *** xabbu42_ joined
[05:01] *** xabbu42 left
[05:01] *** xabbu42_ is now known as xabbu42

[05:12] *** xabbu42_ joined
[05:12] *** xabbu42 left
[05:12] *** xabbu42_ is now known as xabbu42

[05:32] *** macdaddy left
[05:34] <sorear> ugh.  this is not being very easy

[05:37] *** orafu left
[05:37] *** orafu joined
[05:45] <sorear> TimToady: a little help here?  How could I go about adding a position -> $*CURPAD mapping to Actions output?

[05:55] *** Rincewind joined
[05:57] *** Schwern joined
[06:00] *** fridim_ joined
[06:04] *** redicaps left
[06:04] *** redicaps joined
[06:11] *** ciphertext left
[06:12] <TimToady> well, the <.newpad> is called at about the start, and at the end is typically something like <.checkyada> or <.getsig> or <.getdecl>

[06:13] *** Schwern left
[06:16] *** Visitor99 left
[06:20] *** redicaps left
[06:20] *** xabbu42_ joined
[06:20] *** xabbu42 left
[06:20] *** xabbu42_ is now known as xabbu42

[06:28] *** Schwern joined
[06:35] <sorear> TimToady: how would I translate that into data structures?

[06:37] *** ejs joined
[06:37] *** Schwern left
[06:50] *** gfx left
[07:01] <pmichaud> phenny: tell jnthn draft blog post at http://www.pmichaud.com/sandbox/blog-1.html .  Comments welcomed, I'll review in the morning (about 12h00 utc) and post sometime after that.

[07:01] <phenny> pmichaud: I'll pass that on when jnthn is around.

[07:01] <pmichaud> phenny: tell moritz_ draft blog post at http://www.pmichaud.com/sandbox/blog-1.html .  Comments welcomed, I'll review in the morning (about 12h00 utc) and post sometime after that.

[07:01] <phenny> pmichaud: I'll pass that on when moritz_ is around.

[07:02] <pmichaud> (others are welcome to comment also :)

[07:02] <pmichaud> off to sleep

[07:04] *** xabbu42_ joined
[07:04] *** xabbu42 left
[07:04] *** xabbu42_ is now known as xabbu42

[07:17] *** Schwern joined
[07:17] *** M_o_C joined
[07:25] *** Schwern left
[07:32] *** molaf joined
[07:35] *** xabbu42_ joined
[07:35] *** xabbu42 left
[07:35] *** xabbu42_ is now known as xabbu42

[07:44] * sorear tries something

[07:46] *** tadzik joined
[07:50] *** Su-Shee joined
[07:50] *** ciphertext joined
[07:52] *** eternaleye left
[07:53] *** PZt left
[07:54] *** xabbu42_ joined
[07:54] *** xabbu42 left
[07:54] *** xabbu42_ is now known as xabbu42

[08:01] *** PZt joined
[08:04] *** Schwern joined
[08:12] *** plobsing left
[08:12] *** jedai joined
[08:16] *** ejs left
[08:17] <mberends> good morning

[08:20] <sorear> hello

[08:21] <pugssvn> r31375 | sorear++ | [STD] A first wild cut at attaching pads to the syntax tree 

[08:21] <pugssvn> r31375 | [viv] Include full symbol tables in store files

[08:23] *** bbkr left
[08:23] *** bbkr joined
[08:28] *** Rincewind is now known as Ross

[08:28] *** Ross left
[08:28] *** Ross joined
[08:33] *** xabbu42_ joined
[08:33] *** xabbu42 left
[08:33] *** xabbu42_ is now known as xabbu42

[08:42] *** Schwern left
[08:44] *** azert0x joined
[08:44] *** azert0x left
[08:44] *** azert0x joined
[08:45] *** am0c__ is now known as am0c

[08:55] *** xabbu42 left
[09:14] <jnthn> morning, #perl6

[09:14] <phenny> jnthn: 07:01Z <pmichaud> tell jnthn draft blog post at http://www.pmichaud.com/sandbox/blog-1.html .  Comments welcomed, I'll review in the morning (about 12h00 utc) and post sometime after that.

[09:17] *** ciphertext left
[09:24] *** TiMBuS left
[09:28] <jnthn> TimToady: (decontainerize) that sounds pretty sane

[09:30] <jnthn> TimToady: Less sure on the new bunch of -rw variants of things, but maybe that's OK too.

[09:34] *** fridim_ left
[09:37] *** redicaps joined
[09:40] *** Mowah left
[09:43] *** am0c left
[09:45] <moritz_> good morning

[09:45] <phenny> moritz_: 07:01Z <pmichaud> tell moritz_ draft blog post at http://www.pmichaud.com/sandbox/blog-1.html .  Comments welcomed, I'll review in the morning (about 12h00 utc) and post sometime after that.

[09:45] <moritz_> thanks phenny 

[09:45] *** Mowah joined
[09:47] <moritz_> phenny: tell pmichaud +1 to the blog post

[09:47] <phenny> moritz_: I'll pass that on when pmichaud is around.

[10:02] <moritz_> rakudo: say (*-3).signature.perl

[10:02] <p6eval> rakudo 92e914: OUTPUT«:(;; Mu $x)␤»

[10:02] <moritz_> rakudo: say (*-3).signature.arity

[10:02] <p6eval> rakudo 92e914: OUTPUT«Method 'arity' not found for invocant of class 'Signature'␤  in main program body at line 11:/tmp/3lnhooWaUi␤»

[10:09] *** azert0x left
[10:11] <moritz_> rakudo: class A { multi method b($x where { 0 } ) { } }; A.new.b(4)

[10:11] <p6eval> rakudo 92e914: OUTPUT«No candidates found to invoke␤  in main program body at line 11:/tmp/jdOpy6exrT␤»

[10:13] * moritz_ submits rakudobug about LTA error message

[10:19] *** meppl joined
[10:41] *** azert0x joined
[10:48] *** azert0x left
[10:53] *** azert0x joined
[10:55] *** Trashlord left
[10:57] *** TiMBuS joined
[11:01] *** whiteknight joined
[11:03] *** pjcj left
[11:03] *** pjcj joined
[11:10] *** Trashlord joined
[11:17] *** clintongormley joined
[11:19] *** pmurias joined
[11:21] *** tadzik left
[11:33] <colomon> alpha: say 1 == 1 + 0i

[11:33] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[11:34] <colomon> rakudo: say 1 == 1 + 0i

[11:34] <p6eval> rakudo 92e914: OUTPUT«0␤»

[11:34] <colomon> doh!

[11:36] *** tadzik joined
[11:38] <jnthn> pmichaud: For when you has an awake:

[11:38] <jnthn> our sub foo() { return ['a'], ['b'], ['c']; }

[11:38] <jnthn> my (@a, @b, @c) = foo(); say @a; say @b; say @c;

[11:38] <jnthn> a b c

[11:38] <jnthn> Rather than a, b and c on lines of their own. Is this correct - it's not what I expected?

[11:38] *** ab5tract joined
[11:40] <jnthn> ah, more succinct

[11:40] <jnthn> rakudo: my @a = 1,2; my @b = 3,4; (@a, @b) = (@b, @a); say @a; say @b;

[11:40] <p6eval> rakudo 92e914: OUTPUT«3 4 1 2␤␤»

[11:43] <TiMBuS> rakudo: my @a = 1,2; my @b = 3,4; (@a, @b) = (@b, @a); say @a;

[11:43] <p6eval> rakudo 92e914: OUTPUT«3 4 1 2␤»

[11:43] <TiMBuS> er

[11:43] <jnthn> TiMBuS: Yes, surprised me too.

[11:44] <colomon> actually, that's what I'd expect.

[11:44] <jnthn> It's what I'd expect in Perl *5*.

[11:44] <TiMBuS> oh i get it now

[11:44] <jnthn> I thought that was changed in Perl 6.

[11:47] <redicaps> Hello Perl6

[11:47] <redicaps> woosley@woosley-laptop:~$ ./rakudo/perl6

[11:47] <redicaps> Null PMC access in find_method('new_class')

[11:47] <redicaps> current instr.: '' pc -1 ((unknown file):-1) (:5876)

[11:47] <redicaps> Segmentation fault

[11:48] <redicaps> why this is happening? 

[11:50] <jnthn> redicaps: Did you make install?

[11:50] <jnthn> You need to do that before calling Rakudo from another directory.

[11:50] <redicaps> no

[11:50] <redicaps> Oh, I see

[11:54] <redicaps> rakudo:  my ($a,$b) = "test".split("d"); say $a; $b.split(" ");

[11:54] <p6eval> rakudo 92e914: OUTPUT«test␤Method 'split' not found for invocant of class 'Failure'␤  in main program body at line 11:/tmp/GrJUDg3j5s␤»

[11:55] <redicaps> The error message looks so strange.

[12:04] <jnthn> I'm not sure that's quite right...

[12:04] <jnthn> rakudo: say Failure ~~ Cool

[12:04] <p6eval> rakudo 92e914: OUTPUT«0␤»

[12:05] <jnthn> rakudo: say Failure ~~ Any

[12:05] <p6eval> rakudo 92e914: OUTPUT«1␤»

[12:05] <jnthn> Maybe Failure should be Cool.

[12:05] *** tomaw left
[12:06] *** arthur-- left
[12:07] *** tomaw joined
[12:07] <redicaps> It is quit confusing for a beginner to debug what is wrong with the code.

[12:19] *** mmcleric joined
[12:19] *** arthur-- joined
[12:19] <jnthn> redicaps: Well, I half suspect you shouldn't have had anything to debug (e.g. Rakudo should have treated it as an empty string).

[12:21] *** k23z__ left
[12:24] *** M_o_C left
[12:26] <redicaps>  jnthn:   I do think it should be undefined or something more explicit. It is really hard the understand what is class Failure or Cool

[12:26] *** redicaps left
[12:29] *** redicaps joined
[12:36] <jnthn> A Failure object is undefined. There's no single "undef" in Perl 6 as in Perl 5, though.

[12:40] *** masonkramer left
[12:40] *** masonkramer joined
[12:40] <pmichaud> good morning, #perl6

[12:40] <phenny> pmichaud: 09:47Z <moritz_> tell pmichaud +1 to the blog post

[12:41] <jnthn> morning, pmichaud 

[12:41] <pmichaud> my (@a, @b, @c) = foo(); say @a; say @b; say @c;

[12:41] <pmichaud> puts everything into @a

[12:42] <jnthn> pmichaud: :-(

[12:42] <pmichaud> it's still a list assignment, and the array container slurps the entire list.

[12:42] <jnthn> So (@a, @b) = (@b, @a) cannot be used to swap around two arrays?

[12:42] <pmichaud> not as far as I know

[12:43] <jnthn> I'm sure that was spec once.

[12:43] <jnthn> But maybe not now.

[12:43] <pmichaud> yes, I remember that also.

[12:43] <jnthn> Ah, OK.

[12:43] <TiMBuS> what about :=

[12:43] <jnthn> my (@a, @b, @c) := foo(); # does of course work ;-)

[12:43] <jnthn> TiMBuS: I tested it. It does the right thing.

[12:44] <pmichaud> is    :(@a, @b) := (@b, @a)    still valid?

[12:44] <jnthn> pmichaud: mberends++ has a couple of comments on the blog post, but is afk for 5-10 mins or so

[12:44] <pmichaud> okay, reading backlog

[12:44] <jnthn> pmichaud: Yes but it does nothing without a declarator, iirc.

[12:44] <jnthn> pmichaud: ah, he didn't write them on channel I think

[12:44] <jnthn> pmichaud: More wanted to discuss

[12:45] <jnthn> If you can hold on for 5-10 mins he'll be back :-)

[12:45] <pmichaud> jnthn: right, I'm reading backlog to pass the time while waiting for mberends++ comments :)

[12:45] <jnthn> Ah, OK :-)

[12:45] <pmichaud> (sorry, I wasn't clear on that.  your statement was clear :)

[12:46] * jnthn tries to fix postcircumfix in Role to deal with just expecting one argument that may be a Parcel

[12:46] <jnthn> (postcircumfix:<[ ]>, that is)

[12:47] <pmichaud> Parcel or Positional?

[12:48] <pmichaud> (the argument, that is)

[12:48] <pmichaud> what use case are you looking at?

[12:48] <jnthn> pmichaud: Actually it's...ugly. :-(

[12:48] <jnthn> Hmm

[12:48] <jnthn> role Foo[$x, $y] { ... }

[12:48] <jnthn> Foo[4, 5].new

[12:49] <jnthn> I wonder if we should really be parsing that as a bog standard postcircumfix.

[12:49] * jnthn checks STD

[12:50] <jnthn> Ah no

[12:50] <jnthn> oh

[12:51] <jnthn> STD is inconsistent

[12:51] <jnthn> module_name parses

[12:51] <jnthn> [ <?before '['> :dba('generic role') '[' ~ ']' <arglist> ]?

[12:52] <pmichaud> that looks right to me

[12:52] <jnthn> but in typename

[12:52] <jnthn>         # parametric type?

[12:52] <jnthn>         <.unsp>? [ <?before '['> <param=.postcircumfix> ]?

[12:52] <jnthn> it parses postcircumfix there

[12:52] <pmichaud> hmmm.

[12:53] <jnthn> It should be one way or the other

[12:53] <jnthn> Not different.

[12:53] <jnthn> And I think it should be <arglist>

[12:53] <jnthn> Because they're really arguments to go into a multiple dispatch.

[12:53] <pmichaud> if it actls more like a signature bind, then <arglist>

[12:53] <jnthn> To select which role to do.

[12:53] <jnthn> Yeah, quite

[12:53] <jnthn> But

[12:54] <jnthn> std: role Foo[::T] { }; 

[12:54] <p6eval> std 31375: OUTPUT«ok 00:01 112m␤»

[12:54] <jnthn> std: role Foo[::T] { }; Foo of Int

[12:54] <p6eval> std 31375: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/VMOAqZBLuK line 1:␤------> role Foo[::T] { }; Foo ⏏of Int␤    expecting any of:␤  bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse failed␤FAILED 00:01 112m␤»

[12:54] <jnthn> We currently don't parse a typename as a term

[12:54] <jnthn> Meaning that Foo[Int] won't get parsed by the typename rule

[12:54] <jnthn> But as a standard postcircumfix on Foo

[12:55] <pmichaud> checking

[12:55] <pmichaud> I'm surprised typename isn't parsed as a term.  What is it parsed as?

[12:55] <jnthn> (where we === both Rakudo and STD, afaict)

[12:55] <jnthn> We parse typename in various places

[12:55] <pmichaud> as in, my $a = Int  ?

[12:55] <pmichaud> that seems to me to have to be a term *somehow*

[12:56] <jnthn> That parses by term:name

[12:56] <jnthn> Ah

[12:56] <jnthn> term:name does have some extras we don't have in Rakudo though

[12:56] <jnthn>             :dba('type parameter')

[12:56] <jnthn>             <.unsp>? [ <?before '['> <postcircumfix> ]?

[12:57] <pmichaud> right

[12:57] <pmichaud> there ya go :)

[12:57] <jnthn> Again, postcircumfix that wants to be arglist

[12:57] <jnthn> I guess being able to write

[12:57] <jnthn> Crate of Beer.new

[12:57] <jnthn> And have that mean like (Crate of Beer).new

[12:57] <jnthn> Is visually odd.

[12:57] <jnthn> And thus why we don't just have typename as a term.

[12:58] <pmichaud> right -- terms tend to not want spaces

[12:58] <pmichaud> (unless made into a pill somehow)

[12:58] <jnthn> C# allows such a thing and I always find it really odd looking.

[12:58] <jnthn> var foo = new Blah().some_method();

[12:59] <jnthn> Which is

[12:59] <jnthn> var foo = (new Blah()).some_method();

[12:59] <jnthn> But it groups wrong visually.

[12:59] <jnthn> perl6++ for not doing that one :-)

[12:59] <pmichaud> I mean, some terms can have spaces -- like declarators -- but if you want to perform an operation on them you generally have to paren them

[12:59] <jnthn> *nod*

[13:00] <pmichaud> anyway, if Role[<mumble>]  is meant to act like a signature bind, then I'd say it should indeed be arglist

[13:01] <jnthn> OK, thank

[13:01] <jnthn> Changing it to be that in Rakudo

[13:01] <pmichaud> there could be an argument that postcircumfix:<[ ]>  should act like a signature bind.

[13:01] <jnthn> Then hopefully we can have roles with multiple parameters working again. :-)

[13:01] <pmichaud> (as we had it before this last refactor)

[13:01] <jnthn> I could argue that RoleName[...] should never call postcircumfix:<[ ]>

[13:01] <pmichaud> it just seemed much simpler with a single argument.

[13:02] <jnthn> But is actually just syntax for a parametric type

[13:02] <colomon> errr... is there a problem with sleep.t?

[13:02] <jnthn> I slept fine.

[13:02] <pmichaud> the question is whether     my $x = role ... ;   $x[3, 4]     should work

[13:02] <jnthn> pmichaud: Yeah

[13:02] <pmichaud> if yes, then it's not syntactic

[13:02] <jnthn> pmichaud: Perhaps

[13:03] <jnthn> pmichaud: But then

[13:03] <jnthn> pmichaud: eeeewwww

[13:03] <jnthn> pmichaud: 'cus that's going to pass one arg. :-/

[13:03] <jnthn> Oh, I know

[13:03] <jnthn> I'll translate the forms that parse an arglist to the "real" method that does the finding of the correct role

[13:04] <jnthn> And then have postcircumfix:<[ ]> accept one arg and flatten it out as needed.

[13:04] <pmichaud> just to be clear, I'm not really opposed to switching postcircumfix:<[ ]>  back to acting like a multi-arg sig

[13:04] <jnthn> I'm agnostic on that.

[13:04] <pmichaud> maybe we should ask TimToady++ how he thinks of it

[13:04] <jnthn> Remember that postcircumfix:<( )> is defined as taking one arg.

[13:05] <jnthn> So actually one arg is consistent.

[13:05] <pmichaud> oh, if postcircumfix:<( )>  takes a single arg, that answers it.

[13:05] <jnthn> Well

[13:05] <jnthn> I had it as many and ruoso really wanted it as one (a Capture), which I came around to agree with after a while. :-)

[13:06] <jnthn> Especially after realizing that unpacking syntax meant that actually getting the args was an extra set of parens away.

[13:06] <pmichaud> my reasons for wanting postcircumfix:<[ ]>  to be single arg somewhat went away after I add .at_pos and .at_key

[13:06] <pmichaud> *added

[13:06] <jnthn> imo, let's keep them 1. I'll make an arity-1 postcircumfix for non-syntactic usages of roles.

[13:07] <jnthn> And I'll treat the ones we parse syntactically as signatures and work them slightly differently.

[13:07] <jnthn> er, as arglists

[13:07] <pmichaud> okay.  it shouldn't be hard to switch if we need to do so.

[13:07] <jnthn> Quite.

[13:08] <jnthn> pmichaud: A heads up - we seem to have a growing population of RT tickets about parsing issues involving "keywords".

[13:08] <pmichaud> jnthn: okay, excellent.  I still want to do an RT review -- planned to do that thu and/or yesterday but got very sidetracked :-|

[13:08] <jnthn> The latest one is the all too odd

[13:08] <jnthn> has Str $.method is rw;

[13:09] <jnthn> rakudo: class C { has Str $.method is rw; }

[13:09] <p6eval> rakudo 92e914:  ( no output )

[13:09] <jnthn> oh

[13:09] <jnthn> it's not the decl

[13:09] <jnthn> rakudo: class C { has Str $.method is rw; }; C.new( method => 'GET' );

[13:09] <p6eval> rakudo 92e914: OUTPUT«===SORRY!===␤Malformed method at line 11, near "=> 'GET' )"␤»

[13:09] <jnthn> That one.

[13:09] <jnthn> Seems we may sometimes over-commit.

[13:10] <pmichaud> std: class C { has Str $.method is rw; };  C.new( method => 'GET' );

[13:10] <p6eval> std 31375: OUTPUT«ok 00:01 112m␤»

[13:10] <pmichaud> yes -- STD gets it right by LTM.

[13:10] <pmichaud> at least I think that's how it does it.

[13:10] <jnthn> Ah, OK

[13:10] * pmichaud looks.

[13:10] <jnthn> I was wondering if it wasn't a manifestation of that backtracking bug we also currently have.

[13:11] <pmichaud> shouldn't be

[13:11] <jnthn> OK

[13:11] <pmichaud> the backtracking bug comes into play when you have a single rule where you need multiple successes of the rule before you can find the success of the match

[13:11] <pmichaud> let me track that down to make sure, though.

[13:12] <pmichaud> because I'm not sure it's LTM at work here.

[13:12] <jnthn> pmichaud: We have other such issues too

[13:12] <jnthn> rakudo: sub Quack { say "ok" }; Quack()

[13:12] <p6eval> rakudo 92e914: OUTPUT«ok␤»

[13:12] <jnthn> rakudo: sub Quack { say "ok" }; Quack

[13:12] <p6eval> rakudo 92e914: OUTPUT«===SORRY!===␤Confused at line 11, near "Quack"␤»

[13:13] <pmichaud> that one definitely feels more like backtracking bug.

[13:13] <jnthn> Which again looks to me suspiciously like over-commital.

[13:13] <moritz_> that's what prevented me from implementing adverbs on s///

[13:13] <jnthn> Well, method could be too

[13:13] <pmichaud> right

[13:13] <pmichaud> so perhaps that is what is happening.

[13:13] <mberends> hi pmichaud, there were just two words in the blog that looked LTA to me from a PR perspective: vaporware and shame. I'd suggest disappointment for the latter, not too sure about the former. "incomplete" doesn't quite do it, maybe the sentence needs re-structuring to eliminate the evidence or the status word. Other than that, the post looks spot on.

[13:16] <pmichaud> mberends: working

[13:17] <pmichaud> "disappointment" isn't quite right either

[13:17] <pmichaud> I agree with avoiding "shame"

[13:17] *** rv2733 joined
[13:17] <pmichaud> I changed the previous part to read:

[13:17] <pmichaud> and that some will undoubtedly cite this delay as yet more "evidence"

[13:17] <pmichaud> that we'll never see a release of Perl 6.

[13:18] <pmichaud> reworded that again just now

[13:18] <mberends> ok. s/shame/harm/ ?

[13:18] <pmichaud> harm is definitely closer

[13:18] <mberends> setback

[13:18] <pmichaud> how about this...

[13:19] <pmichaud> "But given the 

[13:19] <pmichaud> circumstances, I think we feel that we do less damage by missing

[13:19] <pmichaud> the target by a month than we do by releasing something less than

[13:19] <pmichaud> our vision.

[13:19] <pmichaud> ...still not quite right.

[13:19] <mberends> damage is too svere

[13:19] <pmichaud> agreed.

[13:20] <pmichaud> aha

[13:20] <moritz_> that we do a better job by...

[13:20] <pmichaud> "But given the 

[13:20] <pmichaud> circumstances, I think we feel that serve the cause better by

[13:20] <pmichaud> missing our target by a month than we would by releasing something

[13:20] <pmichaud> less than our vision.

[13:21] <pmichaud> ...that's closer.

[13:21] <mberends> +1 to that, and to moritz_++

[13:21] <jnthn> We're true believers in The Cause!

[13:21] <pmichaud> changed "the cause" to "our cause"

[13:21] <mberends> the cause is a bit cult-y

[13:21] <jnthn> :-)

[13:21] <moritz_> "something considerably less than our vision"

[13:21] <pmichaud> I could go either way on considerably

[13:22] * moritz_ too

[13:22] <pmichaud> I don't want it to sound too much like we'll have to work super-hard to make a July release.

[13:22] <jnthn> considerably may suggest that we have still too much to do

[13:22] <jnthn> er, still have

[13:22] <jnthn> :-)

[13:23] <pmichaud> instead of "our cause", perhaps "the future" or "Perl 6" ?

[13:23] <mberends> +1 the latter

[13:23] <pmichaud> aha

[13:23] <pmichaud> yes

[13:23] <pmichaud> now changed

[13:23] <pmichaud> "But given the 

[13:23] <pmichaud> circumstances, I think we feel that we promote Perl 6 better by

[13:23] <pmichaud> missing our target by a month than we would by releasing something

[13:23] <pmichaud> less than our vision.

[13:24] <pmichaud> and maybe even get rid of the 6.

[13:25] <mberends> and s/missing our target/reaching our target delayed/

[13:25] <pmichaud> delaying our target

[13:25] <mberends> ok

[13:25] <pmichaud> delaying the release

[13:26] <pmichaud> moving the release target

[13:26] <mberends> release date

[13:26] <pmichaud> +1

[13:26] <mberends> wfm

[13:27] <pmichaud> excellent, thank you.

[13:27] <pmichaud> any other comments?

[13:27] <pmichaud> (from anyone?)

[13:27] <pmichaud> can the post wait another couple of hours?

[13:27] * mberends likes, anyway. sure :)

[13:27] <pmichaud> (I have to run some important errands soon, would rather wait a bit more for additional comments than post now)

[13:28] <jnthn> Aye, can wait a little longer

[13:28] <pmichaud> I plan to post this to use.perl and rakudo.org ... seem reasonable?  does it need to go anywhere else?  p6c?

[13:28] <jnthn> Gives more people time to think of anything.

[13:28] <jnthn> pmichaud: I assume your use.perl.org journal is aggregated on Planet Perl 6?

[13:29] <pmichaud> jnthn: it is.

[13:29] <jnthn> OK, then sounds good.

[13:29] <jnthn> Could also twit it.

[13:29] <pmichaud> oh, that's a really good idea.

[13:29] <jnthn> er, tweet

[13:29] <moritz_> :-)

[13:29] <pmichaud> we'll do that then also.

[13:29] <jnthn> .oO( you should see how I write the past tense! )

[13:29] <pmichaud> okay, I need to run off for a bit, hope to be back short-ish

[13:31] <jnthn> It may be walk and noms time here in a little bit too :-)

[13:35] *** rv2733 left
[13:41] *** foodoo joined
[13:49] <moritz_> SVG::Plot now has support for simple xy (point) plots

[13:52] *** tri1 joined
[13:56] <colomon> \o/

[13:58] <moritz_> work on xy (lines) now

[14:02] <colomon> wow, just had my second hang in the test suite this morning.

[14:03] <colomon> My simple anti-patch must have really borked things up.

[14:04] * moritz_ knows anti-pasti, but not anti-patches :-)

[14:04] <moritz_> xy lines plot "work"

[14:05] <moritz_> http://moritz.faui2k3.org/tmp/circle.svg

[14:06] <moritz_> parametric plot x = sin(t), y1 = cos(t), y2 = 2 cos(t)

[14:07] <colomon> nice

[14:11] *** tri1 left
[14:12] *** Trashlord left
[14:14] *** Trashlord joined
[14:18] *** foodoo left
[14:22] *** redicaps left
[14:31] <moritz_> time to integrate and plot a linear model... let's hope it works

[14:31] <moritz_> if it does, I'll have something nice to blog about

[14:33] *** mmcleric left
[14:34] <moritz_> /o\ doesn't work

[14:41] <moritz_> \o/ works

[14:42] <moritz_> it's glacial

[14:42] *** snarkyboojum left
[14:44] *** mmcleric joined
[14:45] *** mmcleric left
[14:45] *** snarkyboojum joined
[14:46] *** mmcleric joined
[14:47] <moritz_> a minute to integrate a simple model with two variables from 0 to 5 seconds

[14:49] <arnsholt> Is the syntax for accessing a var $bar in package Foo like Perl 5: $Foo::bar?

[14:50] <moritz_> yes

[14:50] <arnsholt> Goodie

[14:51] <pmichaud> good re-morning, #perl6

[14:52] <jnthn> re-good morning, pm

[14:53] <moritz_> re-good re-morning, pm :-)

[14:57] * jnthn spectests the parametric role type name cleanups/fixes and heads for noms with mberends++

[14:57] <mmcleric> hi jnthn and everyone, do you have more challenging tasks for me? :)

[14:57] <pmichaud> mmcleric: finish the Rakudo implementation.  By Monday.  :)

[14:57] <mmcleric> if you don't remember my nick, i'm the guy from hackaton in Kiev from last week :)

[14:57] * moritz_ is glad he isn't the only one being asked for challenges :-)

[14:58] <jnthn> Привет, mmcleric :-)

[14:58] <mmcleric> привет :)

[14:58] <jnthn> Yes, I remember. :-)

[14:58] <mmcleric> it's too late for my patch for series operator, colomon fixed it already

[14:58] <colomon> sorry about that.

[14:59] <mmcleric> :D

[14:59] *** kensanata joined
[14:59] <jnthn> mmcleric: Depends how challenging you fancy. ;-)

[14:59] <jnthn> mmcleric: I can point you at something though.

[14:59] <jnthn> mmcleric: At the moment we can do things like:

[15:00] <mmcleric> i don't mind doing some research, even it'll be too hard for me, at least i'll get used to codebase

[15:00] <jnthn> rakudo: my $x = * + 1; say $x.WHAT 

[15:00] <p6eval> rakudo 92e914: OUTPUT«Block()␤»

[15:00] <jnthn> You'll see it's made a closure

[15:00] <jnthn> rakudo: my $x = * + 1; say $x(2)

[15:00] <p6eval> rakudo 92e914: OUTPUT«3␤»

[15:00] <jnthn> And you get arity 2 closures from

[15:00] <jnthn> rakudo: my $x = * + *; say $x(2,40)

[15:00] <p6eval> rakudo 92e914: OUTPUT«42␤»

[15:00] <moritz_> \o/ the answer

[15:01] <jnthn> That all works nicely. It's a compile time transform

[15:01] <mmcleric> yeah, i remember this from your talk

[15:01] <jnthn> See whatever_curry in Actions.pm

[15:01] <jnthn> OK

[15:01] <jnthn> Trouble is

[15:01] <jnthn> my $x = * + * + *; say $x.WHAT

[15:01] <jnthn> rakudo: my $x = * + * + *; say $x.WHAT

[15:01] <p6eval> rakudo 92e914: OUTPUT«Block()␤»

[15:01] <jnthn> ..

[15:01] *** am0c joined
[15:01] <moritz_> rakudo: my $x = * + * + *; say $(1, 2, 3)

[15:01] <p6eval> rakudo 92e914: OUTPUT«123␤»

[15:01] <moritz_> rakudo: my $x = * + * + *; say $x(1, 2, 3)

[15:01] <p6eval> rakudo 92e914: OUTPUT«Too many positional parameters passed; got 3 but expected 1␤  in <anon> at line 1:/tmp/R8nc9ffvy0␤  in main program body at line 11:/tmp/R8nc9ffvy0␤»

[15:02] <jnthn> Right, it's broken. :-)

[15:02] <moritz_> something's very wrong with it

[15:02] <jnthn> moritz_: it's just nyi

[15:02] <colomon> it's perfectly sensibly wrong.

[15:02] <moritz_> yes, that's what's wrong with it

[15:02] <jnthn> mmcleric: Anyway, we need to handle the case where you have 

[15:02] <colomon> you'll find it's { $^a + $^b } + $_

[15:02] <jnthn> (already curried thing) op thing

[15:02] <colomon> or something like that.

[15:03] <jnthn> colomon: Right

[15:03] <moritz_> also

[15:03] <moritz_> rakudo: say (1 + * + 2).(39)

[15:03] <p6eval> rakudo 92e914: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤  in 'Cool::Numeric' at line 1550:CORE.setting␤  in 'Cool::Numeric' at line 1551:CORE.setting␤  in 'infix:<+>' at line 5822:CORE.setting␤  in main program body at line 11:/tmp/R3wRMi3Uvl␤»

[15:03] <jnthn> moritz_: Ah, that's what I was trying to trigger before.

[15:03] <moritz_> it makes { 1 + $^a } + 2

[15:03] <jnthn> Anyway, same underlying cause.

[15:03] <mmcleric> ok, i see

[15:04] <mmcleric> is there RT ticket(s)?

[15:04] <jnthn> At the moment we tag with .returns('Whatever')

[15:04] *** whiteknight left
[15:04] <jnthn> mmcleric: I'm not sure, but there are fudged tests.

[15:04] <jnthn> S02-builtin_data_types/whatever.t

[15:05] <jnthn> mmcleric: What I suggest is that we tag the things we make inside whatever_curry as :returns('WhateverCode')

[15:05] <jnthn> And then add cases that look for those and "deal with them"

[15:05] <jnthn> It's fine if the transform * + * + * actually comes out as the equivalent to

[15:06] <jnthn> ({ $^a + $^b}($^a, $^b) + $^c }

[15:06] <jnthn> That is, you make a block that's arity 3

[15:06] <jnthn> And invokes the nested whatever block with two of them

[15:06] <jnthn> Though of course it may only have been arity 1

[15:06] <jnthn> Anyway, once done it should be able to go as many levels deep as needed

[15:07] <jnthn> It's a bit fiddly

[15:07] <colomon> it's a great task.  :)

[15:07] <moritz_> indeed

[15:07] <jnthn> But perl6 --target=past will be a huge help in seeing what ASTs you are building.

[15:07] <jnthn> Off hand, I don't know what the cleanest way is.

[15:07] <jnthn> But it's fairly self-contained and would be lovely to get done. :-)

[15:08] <mmcleric> ok, i guess i understand the problem

[15:08] <jnthn> (should be able to do it all with changes in whatever_curry)

[15:08] * moritz_ discovered that he had the setups of his derivatives backwards in Math::Model :/

[15:08] <jnthn> :-)

[15:08] <jnthn> mmcleric++

[15:09] <mmcleric> --target=past don't work for me

[15:09] <mmcleric> --target=pir does

[15:09] <moritz_> mmcleric: it doesn't work with -e

[15:09] <moritz_> mmcleric: it should work with a file, or interactively

[15:09] <mmcleric> oh, ok

[15:10] <moritz_> echo '1+2' | ./perl6 --target=past

[15:10] <mmcleric> wow, that's a lot of code :)

[15:11] <moritz_> much of it is initialization, which you can ignore

[15:12] <jnthn> OK, afk for a bit 

[15:12] <jnthn> (and mberends too :-))

[15:12] *** justatheory joined
[15:18] *** skids joined
[15:18] *** justatheory left
[15:19] *** \shade\ left
[15:25] *** Mowah left
[15:25] *** shade__ joined
[15:40] *** gfldex left
[15:41] *** gfldex joined
[15:43] *** snarkyboojum left
[15:52] <cosimo> FakeDBI's fetchrow_arrayref() and fetchrow_hashref() work!

[15:55] <cosimo> is there something resembling '$|' in rakudo?

[15:55] <cosimo> unbuffer output in some way?

[15:56] *** snarkyboojum joined
[15:57] <TimToady> $*OUT.autoflush = 1, but I don't know if it's implemented

[15:57] * TimToady has restarted his brane and it is slowly warming up to operating temperature

[15:58] *** Mowah joined
[16:00] <moritz_> rakudo: class A { has %.h; method e($x) { %.h.exists($x) } }; say A.new(:h{ b => c}).e

[16:00] <p6eval> rakudo 92e914: OUTPUT«Could not find sub &c␤  in main program body at line 11:/tmp/S_nmbXgxIl␤»

[16:00] <moritz_> rakudo: class A { has %.h; method e($x) { %.h.exists($x) } }; say A.new(:h{ b => 3}).e

[16:00] <p6eval> rakudo 92e914: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'A::e' at line 11:/tmp/TX9J54eU5T␤  in main program body at line 11:/tmp/TX9J54eU5T␤»

[16:01] <moritz_> rakudo: class A { has %.h; method e($x) { %!h.exists($x) } }; say A.new(:h{ b => 3}).e

[16:01] <p6eval> rakudo 92e914: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'A::e' at line 11:/tmp/0TX_NTemMV␤  in main program body at line 11:/tmp/0TX_NTemMV␤»

[16:01] <moritz_> rakudo: class A { has %.h; method e($x) { %!h.exists($x) } }; say A.new(:h{ b => 3}).e('b')

[16:01] <p6eval> rakudo 92e914: OUTPUT«1␤»

[16:01] * moritz_ should really read the error message

[16:01] <moritz_> rakudo: class A { has %.h; method e($x) { %.h.exists($x) } }; say A.new(:h{ b => 3}).e('b')

[16:01] <p6eval> rakudo 92e914: OUTPUT«1␤»

[16:02] <moritz_> a closure inside a method should have access to attributes, right?

[16:03] <TimToady> rakudo: $*OUT.autoflush = 1; print "Okay so far..."; exit(0)

[16:03] <p6eval> rakudo 92e914: OUTPUT«Method 'autoflush' not found for invocant of class 'IO'␤  in main program body at line 11:/tmp/aTwf0NvAet␤»

[16:03] <cosimo> TimToady: mmh...

[16:04] <TimToady> that might be LHF for someone, and it's certainly going to stay regardless of any spec rewrite

[16:04] <moritz_> not so LHF if you consider that rakudo doesn't have proper lvalue routines yet

[16:04] <moritz_> hm, maybe still LHF :-)

[16:06] <TimToady> well, more like it doesn't have proper rvalue routines yet, hence the recent spec tweak

[16:06] <moritz_> erm, yes

[16:11] <moritz_> rakudo: class A { has %!h; method bug { say ({ $_ => %!h{$_} }).WHAT } }; A.new.bug

[16:11] <p6eval> rakudo 92e914: OUTPUT«Hash()␤»

[16:15] *** arthur-- left
[16:15] <TimToady> yes, presumably the closure closes over self

[16:16] <moritz_> \o/ sanity

[16:16] <moritz_> I have a weird mixture of methods and closures (to be used as callbacks) here

[16:17] *** arthur-- joined
[16:18] <moritz_> rakudo: say [].WHICH

[16:18] <p6eval> rakudo 92e914: OUTPUT«60308592␤»

[16:19] <TimToady> alternately, self is always really $*SELF internally...hmm...

[16:19] <TimToady> nah

[16:19] <moritz_> that sounds crazy

[16:19] <moritz_> more than usual :-)

[16:19] <TimToady> brane is still not all the warmed up, so still in free association mode :)

[16:20] <TimToady> I *am* crazier than usual this time of day

[16:21] <TimToady> but you know, the only way to fake omniscience is to explore as many distinct hypothetical realities as possible

[16:22] <moritz_> ... which sometimes leads you into dark corners. Understood.

[16:23] <TimToady> I got there by speculating on what the actual name of 'self' is in the lexpad

[16:24] <TimToady> we don't just want 'self', since that would seem to make it a subroutine

[16:24] <moritz_> 'self', maybe?

[16:24] <TimToady> or a type, or something constantish

[16:25] *** [mark] left
[16:25] <TimToady> so I was speculatin' about alternate twigils

[16:25] <TimToady> $?SELF is wrong because it's not compile time

[16:28] <TimToady> I suppose $!SELF is the most obvious name, though it would have to be special-cased not to be sent to the Responder Interface

[16:29] <TimToady> or something too ugly to use, like $__INVOCANT__

[16:30] <TimToady> but maybe 'self' is okay, the fact that it's not a function is really only a parser issue

[16:31] <moritz_> if it were a function, it would have the & sigil in the lexpad

[16:31] <TimToady> yes, more like a type or a constant name

[16:31] <TimToady> and parsed the same as those

[16:32] <TimToady> self is more like a temporary constant, which we've been calling readonly

[16:33] <TimToady> maybe we should have a better way to declare those

[16:35] *** lue joined
[16:35] <TimToady> my readonly self = $?CURPAD.slot(0);

[16:35] <TimToady> though come to think of it, $?CURPAD isn't compile-time constant either

[16:35] <lue> o hello o/

[16:35] <TimToady> since CURPAD needs to know its current clone

[16:35] <TimToady> I guess that's really MY::

[16:37] <moritz_> the good news is that refactoring Math::Model to make it more correct made it about twice as fast

[16:37] <TimToady> and $?CURPAD is the static name hash

[16:37] <moritz_> the bad news is that it gives wrong results now :(

[16:38] * moritz_ waits for TimToady to invoke MJD

[16:38] <TimToady> heh, I was just looking it up :)

[16:38] <TimToady> but yes, you know which one

[16:40] <TimToady> but arguably, all these blazing fast YACCish parsers are in the same danger :P

[16:42] <TimToady> where "the wrong answer" is defined as "This is your brain on Xtran.  No more questions."

[16:42] <lue> .oO(I don't get it. My blazing-fast P6 interpreter say 2+2 is 5)

[16:43] <lue> rakudo: say (2 + 2) ~~ 5

[16:43] <p6eval> rakudo 92e914: OUTPUT«0␤»

[16:45] <moritz_> cosimo: $*OUT.autoflush implemented... I'm curious if it makes any difference for you, because it seems to be the default on my box anyway

[16:46] <TimToady> you're not confusing it with line-buffering, are you?

[16:47] *** ashleydev joined
[16:47] <moritz_> I am, I fear

[16:47] <TimToady> rakudo: print "Okay so far..."; exit(0)

[16:47] <p6eval> rakudo 92e914: OUTPUT«Okay so far...»

[16:47] <TimToady> ooh, it does seem to be the default

[16:47] <TimToady> or wait

[16:47] <TimToady> rakudo: print "Okay so far..."; die "oops"

[16:47] <p6eval> rakudo 92e914: OUTPUT«Okay so far...oops␤  in main program body at line 11:/tmp/kS58YBYNQr␤»

[16:48] <TimToady> hmm, any way to kill my process without getting POSIX exit?

[16:48] <TimToady> anyone have any coredump bugs handy?

[16:49] <TimToady> ah, I know

[16:49] <moritz_> rakudo: print "Okay so far"; %(); 

[16:49] <p6eval> rakudo 92e914: OUTPUT«Okay so far»

[16:49] <TimToady> rakudo: print "Okay so far..."; sleep 9999

[16:49] <dalek> rakudo: f236549 | moritz++ | src/core/IO.pm:

[16:49] <dalek> rakudo: IO.autoflush

[16:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f236549628d6455e7e679559daf103df423036fe

[16:49] <p6eval> rakudo 92e914: OUTPUT«Okay so far...»

[16:49] <TimToady> maybe print is autoflushing by default

[16:51] *** kensanata left
[16:52] <moritz_> the parrot documentation doesn't mention it

[16:54] <TimToady> parrot only has it in t/configure

[16:54] <TimToady> (and t/postconfigure)

[16:55] <pmichaud> good almost-afternoon, #perl6

[16:55] <TimToady> and rakudo only mentions it in the <obs('$|') message

[16:55] <pmichaud> any last-minute comments on my blog announcement before I post?

[16:56] *** Ross left
[16:56] <TimToady> where is it?

[16:57] *** Ross joined
[16:57] <pmichaud> http://pmichaud.com/sandbox/blog-1.html

[16:59] *** hercynium left
[17:00] <TimToady> looks fine to me

[17:00] <pmichaud> excellent.  time to post, then :)

[17:03] *** ashleydev left
[17:04] *** Trashlord left
[17:04] <pmichaud> http://use.perl.org/~pmichaud/journal/40407

[17:05] *** Trashlord joined
[17:06] <TimToady> when rakudo does mixins, does it check to see if the role is already mixed in, and not bother to make a new anonymous class?

[17:06] <pmichaud> yes, I belive so.

[17:06] <pmichaud> *believe

[17:06] <TimToady> (I'm thinking of this in relation to mixing in constraints to parameter containers)

[17:07] <TimToady> so if you bind, and don't change the constraints, you don't have to indirect, but if the constraints change, the container you get is derived by mixin-ish-ness

[17:09] <TimToady> assuming here that the container is in the active lexpad (whatever you call it), and can be of different type than the same parameter in other lexpads

[17:09] <TimToady> how were you calling the static vs dynamic lexpads again?

[17:10] <pmichaud> in Parrot, the static lexpad is a LexInfo, and a dynamic lexpad is a LexPad

[17:10] <TimToady> 'k

[17:11] <pmichaud> LexInfo is the compile-time scheme of what goes into the lexpad, and LexPad is the thing that maps symbols to the call-frame registers

[17:11] <TimToady> works for me, though of course STD is calling all the Infos 'pads'

[17:11] <pmichaud> as far as binding and constraints, I had already planned that we would derive new container constraints

[17:12] <pmichaud> (and avoid doing so when we could detect that they weren't needed)

[17:12] <pmichaud> I don't remember if it occurred to me to try mixin roles for this, but that seems to fit well

[17:13] <pmichaud> the current chain-of-indirects is more "get something to work" than "make it efficient"  :)

[17:14] <pmichaud> at least for constraints, one simple approach was to create an all() junction of the container's constraints and the constraints of whatever is being bound

[17:14] <pmichaud> and then hope that the junction constructor would be smart enough to remove duplications

[17:14] <pmichaud> (and testing a constraint remains a smart match against the junction)

[17:14] <pmichaud> (blog also posted to rakudo.org)

[17:16] <pmichaud> afk for a bit, ph call

[17:16] *** Mowah left
[17:17] *** Mowah joined
[17:28] <lue> afk

[17:35] <TimToady> sorear: I want to ban the word "pad" from the compiler, and reserve it for the active pads (and maybe protopad) only

[17:35] <TimToady> so CURPAD -> CURLEX or some such

[17:35] <pmichaud> +2

[17:35] <TimToady> let me know when it's not going to step on your work

[17:36] <TimToady> or you can do it yourself

[17:37] <TimToady> note, I'll be flying to OH overnight, so if I disappear in mid afternoon, you'll know why

[17:37] <pmichaud> I'll be flying tomorrow

[17:40] <TimToady> when are you getting in?

[17:40] <TimToady> ish

[17:43] <TimToady> (taken private)

[17:43] *** Schwern joined
[17:44] *** Trashlord left
[17:52] *** dukeleto joined
[17:54] <pmichaud> I'm arriving 15h10

[17:55] <pmichaud> (unless I get delayed somewhere)

[18:04] <pugssvn> r31376 | lwall++ | [S10] define how CANDO works with respect to lexically-scoped function name searches 

[18:07] <TimToady> oops s/b OUR::($somefunc)()

[18:09] <IllvilJa> Wooo! Our princess got married today!  Let's call the next release of Rakudo 'Love' to celebrate that :-).

[18:09] <IllvilJa> (oops, I'm probably a closet royalist ;-) )

[18:11] <pugssvn> r31377 | lwall++ | [S10] fix thinkos and bad writing 

[18:13] *** Visitor99 joined
[18:15] *** Trashlord joined
[18:23] *** Schwern left
[18:28] *** Schwern joined
[18:38] *** itz joined
[18:41] *** eternaleye joined
[18:42] * moritz_ TeX-infected. Just tried to use % as a comment character in Perl 6

[18:42] *** molaf left
[18:43] <tadzik> :)

[18:47] <moritz_> \o/ I've fixed Math::Model *and* retained most of the speed benefit

[18:47] <Tene> perl6: say 'lazy junctions?' if 9 ~~ any(1,3 ... *);

[18:48] <p6eval> rakudo f23654:  ( no output )

[18:48] <p6eval> ..elf 31377: OUTPUT«Parse error in: /tmp/nMfGpGFhee␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say 'lazy junctions?' if 9 ~~ ␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[18:48] <p6eval> ..STD_red…

[18:48] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected ";"␤    at /tmp/lv8EnK2CLJ line 1, column 45␤»

[18:48] <Tene> perl6: say 'lazy junctions?' if 9 ~~ any(1,3 ... 15);

[18:48] <p6eval> rakudo f23654: OUTPUT«lazy junctions?␤»

[18:48] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "15"␤    expecting operator, ":" or ")"␤    at /tmp/olDDus7Eu2 line 1, column 43␤»

[18:48] <p6eval> ..elf 31377: OUTPUT«Parse error in: /tmp/Yx1bgGf7jk␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say 'lazy junctions?' if 9 ~~ ␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[18:48] <p6eval> ..STD_red…

[18:48] <TimToady> nobody but rakudo is going to have any clue about ...

[18:52] *** dakkar joined
[19:01] <lue> hello

[19:04] *** cono left
[19:06] *** cono joined
[19:07] <lue> pmichaud: how's variable refactor going?

[19:07] <lue> I'd like to help, it just sounds… big.

[19:08] *** tadzik is now known as yoda

[19:08] *** yoda is now known as tadzik

[19:10] *** PacoLinux left
[19:13] <sorear> TimToady: It won't step on anything now

[19:16] *** patrickas left
[19:16] *** patrickas joined
[19:19] <sorear> TimToady: consider sub foo { my $x; sub bar { $x }; }

[19:19] <sorear> at BEGIN time, a Sub object is created and bound to &bar in foo's protopad

[19:19] <sorear> I get that

[19:20] <sorear> when foo is entered, how does Perl 6 know that &bar needs to be cloned?

[19:20] *** jaldhar left
[19:23] *** gabiruh left
[19:26] <sorear> contrast: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &note).pick } }

[19:26] <sorear> now, to clone &bar and bind its OUTER:: to foo's pad would be wrong

[19:26] <sorear> how does the cloner distinguish these cases?

[19:41] *** plobsing joined
[19:41] <lue> error: Entry 'src/Perl6/Grammar.pm' not uptodate. Cannot merge.

[19:41] <lue> what git command can I use to resolve this?

[19:42] <tadzik> git pull?

[19:42] <tadzik> I guess

[19:42] <tadzik> but, what situation?

[19:43] <lue> I git pulled, and that happened.

[19:43] <moritz_> lue: git checkout src/Perl6/Grammar.pm # will throw away local changes

[19:44] <lue> OK. [I only changed one little thing that made custom circumfix ops not parsefail, but still fail]

[19:45] <moritz_> if you want to keep it, commit it before pulling

[19:45] <lue> I don't, because it doesn't get much closer, only prevents the ===SORRY!=== from happening.

[19:48] *** lue left
[19:48] *** lue joined
[19:49] *** patrickas left
[19:50] *** patrickas joined
[19:50] <TimToady> snaptesting the pad->lex brainwash...

[19:52] *** hercynium joined
[19:53] *** Visitor99 left
[19:54] <TimToady> sorear: in the latter case, cloning is obviated by the fact that neither &say nor &note can reference $x lexically, I suspect

[19:55] <TimToady> and a closure that references no external lexvars is just an anonymous function

[19:55] *** ashleydev joined
[19:56] <TimToady> or maybe one just notices that any lexvars are from a different scope

[19:56] <TimToady> it would be interesting to see what pugs makes of it.

[19:56] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &note).pick } }

[19:56] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ")."␤    expecting "::" or signature value␤    Variable "&note" requires predeclaration or explicit package name␤    at /tmp/3JN656YetV line 1, column 55␤»

[19:57] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &print).pick } }

[19:57] <p6eval> pugs:  ( no output )

[19:57] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &print).pick } }; bar("foo")

[19:57] <p6eval> pugs: OUTPUT«*** No such subroutine: "&bar"␤    at /tmp/kNIxtgr7lw line 1, column 68 - line 2, column 1␤»

[19:57] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &print).pick }; bar("foo") };

[19:57] <p6eval> pugs:  ( no output )

[19:58] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &print).pick } }; my $b = foo(); $b("foo")

[19:58] <p6eval> pugs: OUTPUT«foo␤»

[19:58] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &print).pick } }; my $b = foo(); $b("foo")

[19:58] <p6eval> pugs: OUTPUT«foo␤»

[19:58] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &print).pick } }; my $b = foo(); $b("foo")

[19:58] <p6eval> pugs: OUTPUT«foo␤»

[19:58] <cosimo> moritz_: I'm trying autoflush

[19:58] <TimToady> pugs: sub foo { my $x; my &bar; BEGIN { &bar := (&say, &print).[1] } }; my $b = foo(); $b("foo")

[19:58] <p6eval> pugs: OUTPUT«foo»

[19:59] <TimToady> sorear: however pugs is doing this is likely to be very close to correct

[19:59] <TimToady> fsdo correct

[19:59] *** envi^home left
[19:59] *** kensanata joined
[20:01] <pugssvn> r31378 | lwall++ | [STDeco] banish the word "pad" when referring to static lex info 

[20:05] *** Psyche^ joined
[20:05] <pugssvn> r31379 | jnthn++ | [t/spec] Fudge two tests that Rakudo was passing bogusly. 

[20:06] <TimToady> there should be a mark that says "don't autounfudge"...

[20:08] <jnthn> TimToady: It's OK, I'm about to commit a patch that makes them fail. ;-)

[20:08] *** Patterner left
[20:08] *** Psyche^ is now known as Patterner

[20:10] <dalek> rakudo: dd6bda0 | jonathan++ | src/ (3 files):

[20:10] <dalek> rakudo: Some updates to parametric role parameter handling, bringing us in line with 

[20:10] <dalek> rakudo: current postcircumfix:<[ ]> handling, parsing a couple more cases of parametric 

[20:10] <dalek> rakudo: types to bring us more in line with STD and fixing at least one RT ticket along 

[20:10] <dalek> rakudo: the way.

[20:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/dd6bda05d6a0b0582575e3b65a38467479bff304

[20:13] <pugssvn> r31380 | jnthn++ | [t/spec] Add a test for RT#75822 and correct another test so we can un-todo it. 

[20:15] <cosimo> moritz_: it doesn't seem to make any difference for me too

[20:15] <cosimo> moritz_: autoflush, that is

[20:20] <sorear> TimToady: What if I do sub foo { my &bar; my $x; BEGIN { &bar := [ [ [ sub () { $x } ] ] ]; }; } 

[20:20] <sorear> Does Perl 6 have to deeply scan all graphs referenced from the protopad?

[20:20] <sorear> s/&bar/$bar/

[20:21] <cosimo> myself: interesting. FakeDBI startup cost is pretty huge, but after that it's fast

[20:21] <cosimo> like 10s for 'use FakeDBI'

[20:22] <jnthn> cosimo: I suspect that comes down drastically once we [can]? pre-compile it.

[20:22] <sorear> the Rakudo parser/compiler is currently *very* slow

[20:23] <sorear> about 10 lines per second

[20:23] <sorear> how long is FakeDBI.pm?

[20:23] <tadzik> literally?

[20:23] <jnthn> I don't think it's as bad as 10 lines per second.

[20:23] <jnthn> At least, it sure ain't here...

[20:24] <jnthn> It sure wants to be much faster though.

[20:24] <sorear> core.pm is 4000 lines, it takes about 400 seconds to get through that compile step here

[20:24] <sorear> it might be a non-linear thing

[20:27] <lue> pmichaud: ping

[20:27] <tadzik> oh, by the way. I was talking to a fellow Perlist some time ago, I told him about rakudo and Perl 6, and his was curious about GC. He said GC in Perl 5 sucks, for circular references will never be freed, and he was curious how it looks in Perl 6. I guess that's not really an issue as everything is a reference, but how does it look like now?

[20:28] <sorear> perl 6 does not spec a GC, but it doesn't spec the lack of one, either

[20:28] <sorear> rakudo has a real GC

[20:28] <sorear> not a fake GC that can be tricked with cycles

[20:29] <sorear> Mildew/SMOP has a fake GC, but that's because transparent integration with Perl 5.x was a major design goal

[20:29] <tadzik> I see. Is Rakudo's work, or Parrot itself?

[20:29] <sorear> Parrot

[20:29] <sorear> I don't know about the memory management strategies of the others

[20:30] <mberends> Su-Shee: ping

[20:31] <mberends> zavolaj now has a new working examples/postgresqlclient.p6

[20:33] <dalek> rakudo: 406d85f | jonathan++ |  (2 files):

[20:33] <dalek> rakudo: Apply patch from cognominal++ to implement Capture.perl.

[20:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/406d85f4cdcd61b78f1e6023da1f41f5658f479d

[20:48] <moritz_> rakudo: say sign(-3)

[20:48] <p6eval> rakudo 406d85: OUTPUT«-1␤»

[20:48] <diakopter> moritz_: any clue what broke the p6eval target?

[20:49] <diakopter> perlesque target

[20:49] <moritz_> diakopter: does it need any additional perl modules?

[20:49] <diakopter> it's not perl

[20:49] <moritz_> diakopter: I switched to a perl 5.12.1 because STD.pm needs that

[20:49] <diakopter> it doesn't use perl

[20:49] <moritz_> then i have no idea

[20:50] <diakopter> oh, you killed the one in my screen

[20:50] <moritz_> yes, couldn't get at the error message otherwise :(

[20:50] <moritz_> I can terminate mine if you want

[20:50] <diakopter> no

[20:50] <diakopter> well

[20:50] <diakopter> let's have it tee somewhere

[20:51] <diakopter> then it can run in either :)

[20:51] <moritz_> ok

[20:51] *** p6eval left
[20:51] <diakopter> but first

[20:51] <diakopter> add this to its $PATH

[20:51] <diakopter> oh

[20:52] <moritz_> which path?

[20:52] <diakopter> is /usr/local/bin not in its $PATH ?

[20:52] <diakopter> the evalbot's

[20:52] <diakopter> (it's where mono's installed)

[20:52] <moritz_> I've removed it, because that's where the new, confusing perl was

[20:52] <moritz_> but I think it's OK to add at the end

[20:52] <moritz_> doing that now...

[20:52] <diakopter> oh good :)

[20:52] *** p6eval joined
[20:52] <moritz_> it's now tee'ing to ~/evalbot.log

[20:52] <diakopter> cool

[20:53] <moritz_> I've put it into run.sh

[20:53] <diakopter> yay; it works'

[20:53] <diakopter> perlesque: say('hi')

[20:53] <p6eval> perlesque: OUTPUT«hi␤»

[20:53] <moritz_> \o/

[20:53] <diakopter> thanks

[20:53] <moritz_> sorry for breaking your stuff

[20:53] <diakopter> now if only it would log what ircname sent which comand

[20:54] *** arthur-- left
[20:54] <moritz_> shouldn't be hard to do

[20:54] <diakopter> pesky malicious ircfolks have frozen it b4

[20:54] <diakopter> and snooped

[20:55] <moritz_> it's in $e->who

[20:55] <diakopter> WARNING:  ALL P6EVAL INTERACTIONS ARE LOGGED. ANY ILLEGAL ACTIVIES WILL BE PROSECUTED TO THE FULLEST EXTENT OF THE APPLICABLE LAW

[20:55] <diakopter> heh

[20:56] <moritz_> OFFENDERS WILL BE SHOT AFTER TRIAL

[20:56] <jnthn> rakudo : $bank.rob();

[20:58] <lue> rakudo 406d85: OUTPUT«===SORRY!===␤Amount to rob not specified.»

[21:00] <pugssvn> r31381 | moritz++ | [evalbot] try to log who was speaking 

[21:01] *** p6eval left
[21:01] *** p6eval joined
[21:01] <lue> .oO(trial may be avoided under the Impatience Act of 2010.)

[21:01] <moritz_> rakudo: say 'test'

[21:01] *** diakopter is now known as imadoofus

[21:01] <p6eval> rakudo 406d85: OUTPUT«test␤»

[21:01] *** imadoofus is now known as diakopter

[21:02] *** Schwern left
[21:02] *** M_o_C joined
[21:03] <moritz_> not that easy, of course :(

[21:04] *** tadzik left
[21:05] *** p6eval left
[21:05] *** p6eval joined
[21:05] <pugssvn> r31382 | moritz++ | [evalbot] log channel 

[21:05] <lue> Is this log publicly accessible, by any chance?

[21:06] <moritz_> nope

[21:06] <moritz_> except that part that's accssible via the public IRC logs

[21:06] *** shade__ is now known as \shade\

[21:07] *** p6eval left
[21:07] *** p6eval joined
[21:07] <lue> .oO(chmod 773 p6eval) # hope that's right

[21:08] <pugssvn> r31383 | moritz++ | [evalbot] it might help not to use the same lexical name twice 

[21:08] <moritz_> rakudo: say 'another test'

[21:08] <p6eval> rakudo 406d85: OUTPUT«another test␤»

[21:08] <moritz_> diakopter: there you go

[21:08] <diakopter> thanks :D

[21:09] <moritz_> Math::Model is progressing nicely, but it would profit from a faster compiler :-)

[21:10] <diakopter> does it use features unique to Perl 6 (other than syntax sugar)?

[21:10] <moritz_> not really

[21:11] <moritz_> the only thing where Perl 6 makes it *really* nicer than perl 5 is named arguments and signature introspection

[21:11] <moritz_> you can say things like

[21:11] <moritz_> math => { $:volume * $:density }

[21:11] <moritz_> and Math::Model introspects the signature of that block, and thus finds on which other variables it depends on

[21:15] <moritz_> the first prototype was in perl 5 years ago, but back then I had only rough ideas how the code should look like

[21:17] *** proller left
[21:18] <lue> Just out of curiousity, how far along is P6 for web applications?

[21:18] *** proller joined
[21:18] <moritz_> there's Web.pm

[21:18] <moritz_> but last time I looked it only worked on alpha, not on rakudo master

[21:20] *** mmcleric left
[21:20] <lue> Alright, I came across Wolfram Alpha, and then I got thinking about something like it, but FOSS and in P6 :)

[21:23] <moritz_> the web part is the easiest if you want to re-invent wolfram alpha

[21:24] <moritz_> the computer algebra system behind it is a bit harder

[21:24] <sorear> moritz_: is Math::Model some kind of reactive programming system?

[21:25] <lue> I've had the idea for a while for this meta-search type thing, and label it The Hitchhiker's Guide or some such :)

[21:25] <moritz_> sorear: I'm not sure what you mean with "reactive", but it's not interactive

[21:26] *** mmcleric joined
[21:26] <moritz_> sorear: it lets you write a system of ordinary differential equations in a rather natural way, and re-writes it for you to fit into Math::RungeKutta

[21:26] <moritz_> then it integrates it, and generates a graph from it (with SVG::Plot)

[21:27] <moritz_> I plan to blog about it soonish

[21:27] <moritz_> http://github.com/moritz/Math-Model/blob/master/scratch.pl is an example of such a model

[21:28] <moritz_> it describes a spring with air drag

[21:31] <moritz_> anyway, bed

[21:33] *** Su-Shee left
[21:33] <lue> afk

[21:36] *** synth joined
[21:38] *** proller left
[21:38] *** proller joined
[21:41] *** clintongormley left
[21:47] *** PacoLinux joined
[22:08] <sorear> moritz_: Ah, I see

[22:14] *** skangas joined
[22:19] *** xenoterracide joined
[22:19] <xenoterracide> perlbot book

[22:19] <xenoterracide> !book

[22:19] <xenoterracide> hmm

[22:19] <sorear> there isn't one.

[22:19] <sorear> try git://github.com/perl6/book.git

[22:20] <xenoterracide> that's what I was looking for

[22:20] *** Guest23195 left
[22:20] <jnthn> sorearbot++

[22:21] * xenoterracide find it odd that you have to have perl5 to build the perl6 book

[22:21] <xenoterracide> oh well

[22:21] <sorear> why?

[22:21] <sorear> perl5 is a fine language, and quite a bit more polished than rakudo

[22:21] <xenoterracide> right

[22:21] <xenoterracide> just saying

[22:21] <xenoterracide> anyways I'm gonna add the repo to http://stackoverflow.com/questions/194812/list-of-freely-available-programming-books

[22:23] <xenoterracide> is the name of the book actually going to be perl 6?

[22:25] *** xenoterracide left
[22:30] *** ash__ joined
[22:37] *** rv2733 joined
[22:47] *** arthur-_ joined
[22:49] *** mmcleric left
[22:49] *** Ross left
[22:52] <dalek> csmeta: r336 | diakopter++ | trunk/Sprixel/t/grammar2.t:

[22:52] <dalek> csmeta: [perlesque] adding another (empty-ish) test, prepping for more grammar work.

[22:52] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=336

[22:53] *** dakkar left
[22:55] *** arthur-_ left
[22:58] <lue> ohai

[22:58] *** pmurias left
[23:03] <jnthn> hellue!

[23:03] *** M_o_C left
[23:09] *** Sarten-X left
[23:15] *** Schwern joined
[23:17] *** Sarten-X joined
[23:17] * lue is attempting to learn Octave

[23:24] *** ash__ left
[23:28] <pugssvn> r31384 | jnthn++ | [t/spec] Fudge S12-attribute/delegation.t for Rakudo master. 

[23:38] <diakopter> TimToady: I need some CHECK time guidance

[23:39] <TimToady> have to leave soon, but if it's quick...

[23:40] <diakopter> likely not quick. :) only large architecture challenges

[23:40] <diakopter> trying to figure out where to wedge CHECK time

[23:41] <diakopter> and scarily suspecting this has something to do with the circularity saw

[23:41] <TimToady> CHECK is at the end of every compilation unit, including BEGIN and eval, but when I say CHECK time I mean the special time at the end of the main comp unit

[23:42] <TimToady> and every setting has its own CHECK too

[23:42] *** kensanata left
[23:43] * diakopter sudden flash of insight/recall of my previous insight

[23:43] <TimToady> but I suspect that every CHECK except the main one knows it's not the time to do app-wide optimization

[23:43] <TimToady> it's similar to the decision of whether to call MAIN

[23:44] *** mberends left
[23:44] <TimToady> except that's at the end of first main execution, instead of end of main compilation

[23:45] <TimToady> minor checks are for things like undefined subs

[23:45] <TimToady> std: BEGIN { foo() }; sub foo {}

[23:45] <p6eval> std 31378: OUTPUT«Can't locate object method "load_pad" via package "STD::P6" at STD.pm line 62221.␤FAILED 00:00 97m␤»

[23:45] <TimToady> er, oops

[23:45] <diakopter> I need to remember that I need to treat the whole program (incl compiler) like it's all one big interpreter-interpreter(-interpreter), and any compiled forms are just serialized/thawable states of that interpreter.

[23:45] <diakopter> remember==keep in mind

[23:45] <TimToady> I suspect something wasn't cleanly rebuilt

[23:45] <diakopter> the rebuild has `make clean`

[23:46] <TimToady> nothing should be calling load_pad anymore

[23:46] <TimToady> should be calling load_lex

[23:47] <diakopter> hm

[23:47] <TimToady> maybe needs a make reboot

[23:47] <TimToady> except stage0 seems consistent in calling and supplying load_pad

[23:47] <diakopter> hee

[23:47] <TimToady> so there's some kind of crossover

[23:48] <diakopter> I thought clean was stronger than reboot

[23:49] <diakopter> sorear: summon

[23:49] <diakopter> someone needs to invent Configure scripts

[23:50] *** dual left
[23:53] <pugssvn> r31385 | jnthn++ | [t/spec] Reviewed S14-role/parameterized-mixin.t. We got away with mixing into the type object in alpha, but not so in master - that's probably just not right since it'd affect all copies of it. So assigned a value that we'll mix in to. Re-fudged a bit. Added a comment about some

[23:53] <pugssvn> ..tests that are probably wrong. 

[23:54] *** dual joined
[23:55] <dalek> rakudo: edb8be9 | jonathan++ |  (2 files):

[23:55] <dalek> rakudo: Apply first cut of handles method generator. Patch courtesy of maard++.

[23:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/edb8be9f1b843c33526d0769fcc149273c633067

[23:55] <dalek> rakudo: 478bde3 | jonathan++ | src/ (4 files):

[23:55] <dalek> rakudo: Get handles wired up and working. Patch mostly by maard++ with a few tweaks from 

[23:55] <dalek> rakudo: me.

[23:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/478bde3e1469946d6a4171b2a378f6bf128b51d9

[23:55] <dalek> rakudo: 884561f | jonathan++ | src/glue/handles.pm:

[23:55] <dalek> rakudo: Fix a thinko and whitespace.

[23:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/884561fc6f186f97300a577903ae6cdd8ff44ea2

[23:55] <dalek> rakudo: aa427c4 | jonathan++ | t/spectest.data:

[23:55] <dalek> rakudo: Turn on S12-attributes/delegation.t.

[23:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/aa427c478de069347d2d280995efd08e12b32ff5

[23:56] <pugssvn> r31386 | jnthn++ | [t/spec] Unfudge a use of handles in the advent tests. 

[23:58] <pugssvn> r31387 | lwall++ | [stage0] reboot, add NULL.lex 

[23:59] <diakopter> ok.

