[00:00] <diakopter> sigh

[00:00] <sorear> jnthn: that's parsed differently, using |

[00:00] <jnthn> sorear: Ah.

[00:00] <jnthn> Then...meh.

[00:00] <jnthn> Could always be semantically wrong, of course.

[00:01] <jnthn> (STD mostly does syntax)

[00:01] <jnthn> Maybe the intention is that you can write the traits before the sub.

[00:01] <jnthn> gah

[00:01] <jnthn> before the signature

[00:01] <jnthn> or either side of it

[00:01] <jnthn> And the compiler should check you don't have more than one signature.

[00:02] <jnthn> I hate to imagine what Rakudo does if you feed it such a construction.

[00:02] <diakopter> std: method foo ()()()()()() { }

[00:02] <p6eval> std 30827: OUTPUT«ok 00:01 112m␤»

[00:02] <jnthn> rakudo: sub foo ($x) ($y) { }

[00:02] <diakopter> rakudo: method foo ()()()()()() { }

[00:02] <p6eval> rakudo 475d1c: OUTPUT«Confused at line 11, near "sub foo ($"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[00:02] <p6eval> rakudo 475d1c: OUTPUT«Malformed method at line 11, near "foo ()()()"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[00:02] <jnthn> :-)

[00:02] <diakopter> rakudo: method foo ()()() { }

[00:02] <p6eval> rakudo 475d1c: OUTPUT«Malformed method at line 11, near "foo ()()()"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[00:02] <diakopter> rakudo: method foo ()() { }

[00:02] <p6eval> rakudo 475d1c: OUTPUT«Malformed method at line 11, near "foo ()() {"␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[00:02] <diakopter> k

[00:02] *** demond left
[00:02] <jnthn> I think Rakudo doesn't pay too much attention to STD there. :-)

[00:03] <jnthn> (e.g. does something a bit simpler, including just looking for one sig)

[00:06] *** Sarten-X joined
[00:10] *** constant left
[00:10] *** kolibrie left
[00:10] *** yinyin joined
[00:10] <diakopter> phenny: tell pmurias I made it so return type is optional on constructors

[00:10] <phenny> diakopter: I'll pass that on when pmurias is around.

[00:10] *** constant joined
[00:10] *** christine joined
[00:10] *** hudnix joined
[00:10] *** kolibrie joined
[00:10] *** literal joined
[00:10] *** jnthn joined
[00:10] *** zamolxes joined
[00:10] *** card.freenode.net sets mode: +o jnthn

[00:11] *** BrowserUk joined
[00:11] *** BrowserUk left
[00:12] *** jnthn left
[00:12] *** jnthn joined
[00:16] <jnthn> oh noes, my donought!

[00:19] *** diakopter sets mode: +o jnthn

[00:19] <diakopter> jnthn: yer up late

[00:19] <jnthn> diakopter: My sleep has been...odd...of late.

[00:19] <lue> He's giving up

[00:20] <diakopter> the ghost?

[00:20] <jnthn> Sheesh, can't I keep it a little longer? It was only just pentecost!

[00:20] <lue> He gave up sleeping a night or two ago as well. He said he gave up.

[00:21] <jnthn> lue: I meant that particular night, not in general. ;-)

[00:21] <jnthn> oh yay, the spectest run in nearly done.

[00:21] <lue> I'm shining microwaves into the sky. With any luck, they'll hit reflectors on the moon, and just possibly hit you and maybe, if there is enough strength left, do something to you.

[00:22] <lue> like make you sleepy

[00:22] <diakopter> nobody ROFLd at my mention of Prov 26:4-5

[00:23] <jnthn> I suspect it may be more that it seems to have got quite suddently hotter and humider in the last several days here.

[00:23] <diakopter> the other day, when speaking of juxtapositions

[00:23] <lue> I didn't catch it, sorry.

[00:23] <diakopter> I mean, it wasn't funny, just appropriate.

[00:24] <diakopter> sigh.  communication fail (by me).  Time for me to give up.  Too much coding fail today

[00:24] <jnthn> diakopter: I only just bothered to look it up. :-)

[00:24] <lue> what could the element Perlium do? hhmmm....

[00:25] <jnthn> Patches ahoy! \o/

[00:25] * jnthn finally actually wrote some code

[00:26] <dalek> csmeta: r298 | diakopter++ | trunk/Sprixel/ (6 files):

[00:26] <dalek> csmeta: [perlesque] add perl6/ src folder (for the Perl 6 implementation named Sprixel,

[00:26] <dalek> csmeta: written in Perlesque).

[00:26] <dalek> csmeta: Make return type on constructor method declarations optional.

[00:26] <dalek> csmeta: Add a test for ++pmurias problem case, with a single-assignment correction to

[00:26] <dalek> csmeta: make it parse correctly. ;)

[00:26] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=298

[00:26] <jnthn> dalek: That wasn't the patch I was looking for.

[00:26] <jnthn> ;-)

[00:26] <jnthn> A cool one though it was.

[00:29] <lue> (EXPLAIN!)

[00:29] <jnthn> rakudo: role A { method foo { self.Str } }; say A.foo

[00:29] <p6eval> rakudo 475d1c: OUTPUT«A()<0x34accc0>␤»

[00:30] <dalek> rakudo: 4293e07 | jonathan++ | src/Perl6/Actions.pm:

[00:30] <dalek> rakudo: Implement auto-currying at compile time of infix, prefix and postfix operators. 

[00:30] <dalek> rakudo: Also factors a little code out that we can share/re-use to make the block 

[00:30] <dalek> rakudo: construction a little less ugly.

[00:30] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4293e0722d05267accd66fe6ce312bee1f7a3e22

[00:30] <dalek> rakudo: b0ec2da | jonathan++ | src/Perl6/ (2 files):

[00:30] <dalek> rakudo: Give Perl6::Compiler::Signature a nicer constructor, to allow neater code in the 

[00:30] <dalek> rakudo: actions etc.

[00:30] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b0ec2dab63ab248aecd88a271a9705cf008af0a1

[00:30] <dalek> rakudo: 06a4af5 | jonathan++ | src/Perl6/Compiler/Parameter.pm:

[00:30] <dalek> rakudo: Give Perl6::Compiler::Parameter a better constructor so we can write cleaner 

[00:30] <dalek> rakudo: code in the actions to set up sigs.

[00:30] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/06a4af548182629bc018a92fab5cf987a8ff691f

[00:30] <dalek> rakudo: edb448f | jonathan++ | src/Perl6/Actions.pm:

[00:31] <lue> what is it with the seemingly random version numbers in git? Is it a checksum of some sort.

[00:31] <pmichaud> lue: they're sha-1 hashes

[00:32] <pmichaud> lue: they're designed to be globally unique across repositories

[00:32] <pmichaud> (at least, across repositories that are likely to be borrowing commits from each other :-)

[00:32] <sorear> they are the recursive SHA-1 of the entire history of every file in the repository

[00:32] <jnthn> pmichaud: I did some cleanup of the code we use to make signatures for blocks.

[00:32] <pmichaud> jnthn: +1!

[00:32] <jnthn> pmichaud: Hopefully that makes things feel a bit less messy. :-)

[00:32] <pmichaud> jnthn: my work on closures in the next couple of days will greatly thank you

[00:32] <sorear> pmichaud: well, when git breaks, you get a consolation prize of a SHA-1 collision.  Isn't there a substantial cash prize for those?

[00:33] <jnthn> pmichaud: There's likely a bit more possible.

[00:33] <pmichaud> unless, of course, you've made it harder, in which case you will hear cursing coming from the western hemisphere

[00:33] <jnthn> pmichaud: Nah, just gave Signature and Parameter sane constructors.

[00:34] <pmichaud> jnthn: that sounds very good

[00:35] <jnthn> :-)

[00:35] <jnthn> pmichaud: Auto-currying seems to work nicely, we'll see what falls out from it.

[00:35] <jnthn> It's one thing off moritz_++'s wish list for R*. :-)

[00:35] <dalek> csmeta: r299 | diakopter++ | trunk/Sprixel/Main.cs:

[00:35] <dalek> csmeta: [perlesque] for the billionth time, remove debugging mode flag.

[00:35] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=299

[00:35] <pmichaud> jnthn: once again I'm truly amazed at the speed with which you're able to add features to R*.  I think I was once that fast also, but seem to have slowed down over the past couple of years... :-|

[00:37] *** justatheory joined
[00:37] <lue> jnthn: stop coding that fast! Your fingers can't take prolonged periods in speeds greater than c

[00:38] <jnthn> pmichaud: Well, in this case all the primitives I had to do stuff atop of were pretty solid, which decidedly helps. :-)

[00:39] * diakopter likes solid primitives too

[00:39] <jnthn> pmichaud: One random thought to run by you for a knee-jerk reaction.

[00:39] <pmichaud> most of the solid primitives I have tend to be regular polyhedra

[00:39] <lue> [I keep polychora around the house]

[00:39] <diakopter> oh my

[00:39] * pmichaud puts on his knee-pads

[00:40] <jnthn> pmichaud: How would you feel about trying to elimiate the majority of our use of loadinit in favor of the phasers impl?

[00:40] <jnthn> pmichaud: loadinit is causing us...nasty problems...I think.

[00:41] <jnthn> pmichaud: Especially it's dealings with leixcal scope.

[00:41] <pmichaud> ...thinking...

[00:41] <jnthn> pmichaud: Alternatively, we need to be able to put stuff in outer lexpads at loadinit time and have them still be there.

[00:41] <jnthn> Cases that hurt now:

[00:41] <pmichaud> well, that's the real problem, isn't it?

[00:41] <sorear> what we *need* is protolexpads

[00:41] <jnthn> my class Foo { }; our class Bar is Foo { } # oh noes.

[00:42] <jnthn> This explodes now and I don't have a good way to fix it.

[00:42] <jnthn> Because right now, my class Foo gets installed into the lexpad just like we install subs, etc.

[00:42] <pmichaud> protolexpads would help, or we need a way to invoke a sub such that we keep the lexpad that has already been created for it

[00:42] <jnthn> Whereas our Bar gets set up in the loadinit

[00:42] <jnthn> Which happens...before Foo

[00:42] <pmichaud> instead of creating a new one

[00:43] <pmichaud> anyway, I have two knee-jerk reactions

[00:43] <pmichaud> (1) making things happen more like BEGIN brings us closer to the right way of doing things (i.e., I'd think that using phasers is better than :loadinit)

[00:44] <pmichaud> (2) I don't see that moving :loadinit to phasers really solves the problem (but perhaps you've thought of something I haven't there)

[00:45] <jnthn> pmichaud: You may be right on (2). At least it's not the only thing that will need doing.

[00:45] <jnthn> pmichaud: Maybe I should spend the tuits on protolexpad-ish stuff instead.

[00:45] <pmichaud> the problem is really Parrot's model of lexpads

[00:46] <jnthn> Aye, it's not quite what we want.

[00:46] <pmichaud> from a Parrot perspective, the symbol Foo doesn't get bound until the scope containing Foo is invoked

[00:46] <pmichaud> i.e., the lexpad entry for Foo doesn't exist until the outer scope is invoked

[00:47] <pmichaud> it's easier to imagine with something like:

[00:47] <pmichaud> sub xyz() {  my class Foo { };  our class Bar is Foo { } }

[00:47] <jnthn> Well, it affects the mainline too

[00:48] <jnthn> But yes, that's pretty much it.

[00:48] <pmichaud> the mainline is just another scope, yes.

[00:48] <pmichaud> and from a Parrot perspective, the lexical symbols in the mainline don't really exist before the mainline is invoked

[00:48] <sorear> in a perl6 model, lexpads are cloned

[00:48] <sorear> we can do that with a custom lexinfo

[00:48] <sorear> I think

[00:49] <jnthn> sorear: Last time I worked through what it might take, I think I maybe ended up with us needing a custom Sub too, but it may be avoidable.

[00:49] <pmichaud> let me look again

[00:49] <pmichaud> just a sec

[00:49] <jnthn> I'd *really* like to see if we couldn't put this mess to bed at least somewhat ahead of R* though. It's kinda...embarassing.

[00:49] <pmichaud> Personally, I'm not too concerned if one can't mix lexical and packaged scoped classes in R*

[00:50] <pmichaud> maybe I should be... but I'm not.

[00:50] <jnthn> pmichaud: I didn't mean that specific example. I meant the whole plethora of issues.

[00:50] <jnthn> like

[00:50] <jnthn> rakudo: my role Foo { method lol { say 42 } }; Foo.lol # fine

[00:50] <p6eval> rakudo edb448: OUTPUT«42␤»

[00:50] <jnthn> rakudo: our role Foo { method lol { say 42 } }; Foo.lol # not

[00:50] <p6eval> rakudo edb448: OUTPUT«42␤»

[00:50] <jnthn> ...oh.

[00:51] <jnthn> oh, I know what's not

[00:51] <spinclad> would one want a wall to prevent such mixed times, or delay class Bar till Foo is ready?

[00:51] <pugssvn> r30828 | sorear++ | [viv] Implement basic signature translation 

[00:51] <jnthn> rakudo: role Foo { method lol { say 42 } }; class Bar does Foo { }; Bar.lol

[00:51] <p6eval> rakudo edb448: OUTPUT«Could not find sub &say␤current instr.: 'lol' pc 563 (EVAL_1:217)␤»

[00:51] <jnthn> That one.

[00:51] <pmichaud> technically, Foo can be ready at BEGIN time also, as long as we have a way to bind it into the lexpad at runtime

[00:52] *** plobsing joined
[00:52] <jnthn> This happens because when you do a role, it has to go and clone the role body.

[00:52] <jnthn> And thus its methods

[00:52] <jnthn> (for type parameters to be captured)

[00:52] <jnthn> And if that happens from within a callchain involving loadinit, we appear to be in a mess.

[00:53] <jnthn> pmichaud: Yes, that would be ideal.

[00:53] *** whiteknight left
[00:54] * lue can only hope to aspire to your level of knowledge of rakudo/perl6 someday.

[00:55] <jnthn> lue: Needs time, minor loss of sanity, beer and hanging around here soaking up the knowledge of @other. :-)

[00:55] *** jaldhar joined
[00:55] <spinclad> lue: you need not just hope; you may fully aspire

[00:55] <pmichaud> sorear: custom lexinfo is a good idea... we'd also need custom lexpads

[00:55] <jnthn> (Or tht's how I did it. :-))

[00:56] <jnthn> The only reason I think we may be able to get away with Sub also being custom is that lexpad when created gets the lexinfo.

[00:56] <lue> [and a well-detailed spec :P]

[00:56] <jnthn> If we can hang the "pernament stuff" in the lexinfo perhaps...

[00:56] <jnthn> ...then the lexpad on creation and copy those things into itself.

[00:56] <jnthn> s/and/can/

[00:56] <pmichaud> well, the Sub doesn't actually use the lexinfo directly -- it just passes the lexinfo to the lexpad when it's created

[00:56] <jnthn> pmichaud: Yes.

[00:57] <pmichaud> so, it'd have to be a custom lexpad to be able to do something different with the custom lexinfo

[00:57] <jnthn> pmichaud: My worry was more that we'd need something to trigger the clone of the stuff we already knew.

[00:57] <pmichaud> oh, I think that would just be  OurLexPad.new that does that

[00:57] <pmichaud> i.e., our custom LexPad would have a custom init_pmc

[00:57] <jnthn> pmichaud: But I suspect between a custom lexinfo and custom lexpad, we don't need a custom sub.

[00:58] <pmichaud> it would be tricky because the LexPad doesn't learn about its context until a subsequent step after it's been created

[00:58] <pmichaud> so we'd have to create the LexPad, and then trigger any cloning as part of the set_pointer

[00:59] <pmichaud> i.e., when we attach a context to the LexPad, *then* it could start populating the context with the items from the LexInfo

[00:59] <pmichaud>         if (!PMC_IS_NULL(sub->lex_info)) {

[00:59] <pmichaud>             Parrot_pcc_set_lex_pad(INTERP, context, Parrot_pmc_new_init(INTERP,

[00:59] <pmichaud>                     Parrot_get_ctx_HLL_type(INTERP, enum_class_LexPad),

[00:59] <pmichaud>                     sub->lex_info));

[00:59] <pmichaud>             VTABLE_set_pointer(INTERP, Parrot_pcc_get_lex_pad(INTERP, context), context);

[00:59] <pmichaud>         }

[00:59] <sorear> lue: try aspiring to my level of understanding

[00:59] <jnthn> pmichaud: ah yes

[00:59] <jnthn> But that's do-able.

[01:00] <jnthn> If messy.

[01:00] <pmichaud> not sure I'd want to do this for R*, though.

[01:00] <pmichaud> tough call.

[01:00] <jnthn> Worth prototyping in a branch perhaps?

[01:00] <pmichaud> were you able to move our existing BEGINs to phasers yet?

[01:00] <jnthn> No, that's high on my todo list.

[01:01] <pmichaud> or does this affect that directly?

[01:01] <jnthn> No, it's not related to that.

[01:01] <pmichaud> I think I'd want to see BEGINs as true phasers first.

[01:01] <jnthn> I brought this up because I just ran into it yet again.

[01:01] <jnthn> In a sense, the proto lex pad thing may well be the real fix we need

[01:01] <jnthn> And doing everything else as phasers could come later

[01:01] <jnthn> I'm not sure.

[01:01] <pmichaud> I think moving BEGIN to be phasers will tell us a lot, though.

[01:02] <jnthn> Aye.

[01:02] <jnthn> I can hack on that tomorrow, most probably.

[01:02] <jnthn> Fancied doing something shiny today. :-)

[01:02] <pmichaud> given the repl stuff I just worked on, lexical handling is high in my mind at the moment

[01:02] <pmichaud> so I think a day to stew on it might give me some real clues

[01:02] <jnthn> Sure

[01:02] <jnthn> I'm not after an immediate answer; it's just something that's been bugging me.

[01:02] <pmichaud> especially since I'm excited that I was able to hack lexpad yesterday :)

[01:03] <jnthn> ;-)

[01:03] <pmichaud> I'm a little curious about how custom LexInfos work as dynpmcs, though.

[01:04] <pmichaud> I mean, if Parrot loads a .pbc before rakudo itself has been loaded...... 

[01:04] <pugssvn> r30829 | qiuhw++ | [t/spec] test .subst with :samecase while using block as the replacement. 

[01:04] <pmichaud> does it know how to go back and patch up the LexInfos?

[01:04] <pmichaud> (for the subs it has already loaded...?)

[01:05] * lue is upgrading Fedora, random logout probable. [IIUC]

[01:06] <jnthn> pmichaud: I suspect...not.

[01:06] <jnthn> pmichaud: In theory though the PBC should contain references to the library.

[01:06] <jnthn> (the dynpmc library, that is)

[01:06] <pmichaud> yeah, it just feels weird

[01:07] <pmichaud> there's also always the possibility that we don't need a custom LexInfo... just a custom LexPad with better set_pointer vtable

[01:07] <jnthn> Where would it find The Existing Stuff?

[01:07] <pmichaud> i.e., at the point of the set_pointer the custom LexPad should have enough information around that we could look up the protolexpad information from wherever we want, not just a LexInfo

[01:07] <jnthn> Ah, I see.

[01:07] <pmichaud> it could be a property on a sub

[01:08] <jnthn> Hm

[01:08] <jnthn> Yeah

[01:08] <pmichaud> which we still put in place via :loadinit or a BEGIN phaser or something

[01:08] <jnthn> Heh

[01:08] <jnthn> You know

[01:08] <pmichaud> btw, ultimately phasers are registered using :loadinit, so we don't ever truly eliminate them)

[01:08] <jnthn> If we combine your cheat discovered yesterday

[01:09] <jnthn> Then we can stick at hash in for the lexpad at the start of the phaser

[01:09] <jnthn> Do all the stuff with lexical set up

[01:09] <jnthn> And stash the hash.

[01:09] <jnthn> (as our proto lexpad info)

[01:09] <pmichaud> heh

[01:09] <pmichaud> seems easier to just create the hash, though.

[01:09] <pmichaud> it's also trivially easy to go ahead and a normal lexpad, and then grab a copy

[01:09] <jnthn> May be.

[01:09] <pmichaud> which is what the repl does now anyway

[01:09] <jnthn> True

[01:10] <jnthn> Seems we have various possibilities, anyway.

[01:10] <pmichaud> oh!!!!!

[01:10] <pmichaud> muwahahahaha

[01:10] * pmichaud grabs his Damian horns

[01:10] <jnthn> rakudo: my role Drinking { method go-to-bar() { say "glug" } }; my role Gymnastics { method go-to-bar() { say "ouch" } }; my class DrunkGymnast does Gymnastics does Drinking { method go-to-bar() { self.Gymnastics::go-to-bar() } }; DrunkGymnast.new.go-to-bar

[01:10] <p6eval> rakudo edb448: OUTPUT«Null PMC access in find_method('ACCEPTS')␤current instr.: '!dispatch_::' pc 765 (src/glue/dispatch.pir:266)␤»

[01:10] <jnthn> Fixed that one locally :-)

[01:10] <pmichaud> jnthn: try this on for size.... :-)

[01:11] <pmichaud> we create a custom LexPad

[01:11] <pmichaud> the first time a lexpad is created for a sub, it also stores itself as a property on the sub

[01:12] <pmichaud> so that the first lexpad created ends up being the protolexpad for all of the ones that come after it

[01:13] <jnthn> ooh

[01:13] <pmichaud> note that any :loadinit+:outer subs will force a lexpad to be created in the outer sub

[01:13] <jnthn> Yes, indeedy.

[01:13] <pmichaud> (before it's invoked)

[01:13] <jnthn> That sounds rather promising.

[01:13] <jnthn> And rather uninvasive.

[01:14] *** jhuni left
[01:15] <sorear> pmichaud: how would that interact with something like BEGIN { #`(outer has a lexpad now) }; my $x;

[01:15] <pmichaud> sorear: I'd need to think about it a bit more

[01:15] <jnthn> BEGIN is a bit more difficult in that we have to do it at parse time.

[01:15] <pmichaud> but from a Parrot perspective, such a BEGIN wouldn't really have an :outer

[01:16] <jnthn> Right.

[01:16] <pmichaud> so *really* what we might want is the ability for BEGIN to work in a set of lexpads, and then at CHECK time the first thing we do is attach those lexpads to the actual subs

[01:17] *** jhuni joined
[01:17] <spinclad> in  my $x; BEGIN { ... $x ... }  # while this is paradoxical in time, isn't $x found in :outer?

[01:17] <pmichaud> spinclad: yes, it is.

[01:18] <jnthn> spinclad: There isn't an outer yet at parse time though

[01:18] <jnthn> Not a runtime outer anyway

[01:18] <pmichaud> spinclad: the point is that we can't talk about a lexical $x because the Parrot sub containing $x doesn't exist yet.  In fact, at that point we don't even have a complete AST for the sub.

[01:18] <spinclad> agreed, not a runtime one

[01:18] <pmichaud> jnthn: maybe instead of protolexpads we really want proto-contexts.

[01:19] <pmichaud> so that when a BEGIN runs, it gets a "protocontext" in which to run that we later convert to a real context

[01:19] <jnthn> Hmm

[01:19] <pmichaud> and the protocontext just has a normal hash for its lexpad

[01:19] <jnthn> What do you mean by "context"

[01:19] <jnthn> ?

[01:19] <spinclad> sure; what we have is the compiler's dream of the runtime structure...

[01:20] <jnthn> As in, related to the Parrot Context PMC?

[01:20] <pmichaud> context as in something that looks and acts like .... right.

[01:20] <spinclad> (re not even complete AST)

[01:20] <pmichaud> because technical a BEGIN block never needs an :outer

[01:20] <pmichaud> *technically

[01:20] <pmichaud> I mean, all :BEGIN blocks could easily be .lexical(0)

[01:21] <jnthn> If they flatly have storage in themselves for all outer lexicals, and then we can keep hold of those, I guess it can work.

[01:21] <jnthn> (and we then go and stick them into the real lexpads when we have them)

[01:21] <pmichaud> right

[01:21] <jnthn> A cunning solution.

[01:21] <jnthn> Probably fun to implement. ;-)

[01:23] <pmichaud> essentially, we end up with an outer structure that is parallel to the one that subs construct at compile time

[01:23] <pmichaud> i.e., a compile-time view of the lexical state

[01:24] <pmichaud> and then at CHECK time, we map the compile-time view onto the actual subs

[01:24] <jnthn> *nod*

[01:24] <jnthn> I think that could well work.

[01:24] <jnthn> Don't know that we need that piece for R*

[01:24] <pmichaud> right

[01:24] <jnthn> But I'm reassured to have a plan for it that sounds feasible. :-)

[01:24] <TimToady> hah, you've found a bug in STD.

[01:24] <TimToady> std: BEGIN { foo() }; sub foo {...}

[01:24] <pmichaud> anyway, I think the first step is to see how far we get by thinking of our current :loadinit steps as BEGIN blocks

[01:24] <p6eval> std 30828: OUTPUT«ok 00:01 114m␤»

[01:24] <jnthn> pmichaud: *nod*

[01:25] <pmichaud> and for that I'd say the first step is to convert existing BEGIN blocks to use phasers :)

[01:25] <jnthn> Yeah, someone should do that!

[01:25] <jnthn> oh, wait

[01:25] <jnthn> :-)

[01:25] <pmichaud> :-)

[01:25] <dalek> csmeta: r300 | diakopter++ | trunk/Sprixel/ (6 files):

[01:25] <dalek> csmeta: [perlesque] mark some terminal patterns as deterministic

[01:25] <dalek> csmeta: make Die(string msg) actually used by the parser

[01:25] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=300

[01:25] <pmichaud> anyway, excellent notion.  I'll let it stew in my head for a day or so and see what else falls out from it.

[01:25] <jnthn> Just spectesting a fix to a minor lexical role issue. :-)

[01:26] <pmichaud> but I do think we could massively clean up some of our initialization with such a model.

[01:26] <jnthn> Doing lexical roles and classes shook out...a lot...of places that we made assumptions about type names being in name spaces.

[01:26] <pmichaud> (not to mention make it even more portable in the future)

[01:26] <jnthn> *packages

[01:26] <jnthn> Yeah, it could. It would also save us some repeated work

[01:26] <pmichaud> yes, I knew that type names being in packages was a technical debt with accruing interest

[01:26] <jnthn> And let us actually get variable traits right in the future.

[01:27] <jnthn> Well, I think I've muchly paid off said debt now. :-)

[01:27] <pmichaud> but we really didn't have the pieces in place to be able to avoid it, at least not in my view of things

[01:27] <jnthn> Until doing lexical roles/classes, it was kinda hard to test how we were doing on it too.

[01:28] <pmichaud> exactly.

[01:28] <jnthn> BTW

[01:28] <jnthn> I think we essentially have lexical import together now

[01:28] <jnthn> At least, nobody has complained about import aside from tagged imports being missing, which are a seperate issue.

[01:28] <jnthn> Think we can mark lexical import as done in the ROADMAP?

[01:29] <pmichaud> I'm a little wary of looking at lexical import.  It's one of those that I fear I'll look at and say "omg, it needs a refactor."

[01:29] <jnthn> pmichaud: It's implemented in NQP at least. :-)

[01:29] <pmichaud> oh, that makes me feel much better then.

[01:29] <jnthn> Rather than a load of PIR.

[01:30] <pmichaud> anyway, I'm fine with marking it as done if you think it's working well enough.  (And I suspect it is.)

[01:30] <jnthn> See the stuff in src/Perl6/Module/*.pm when you want to review that area, btw

[01:30] <jnthn> We have basic stuff for versioned/auth'd modules

[01:31] <jnthn> Thanks to (Copenhagen Hackathon)++

[01:31] <sorear> Yay, I'm not the only one who writes code pmichaud dreads reading

[01:31] <pmichaud> I'm likely to leave it alone until I either run across a problem that deals with it or someone else points out a difficult bug involving it :)

[01:32] <pmichaud> sorear: actually, your code (and bkeeler's)  made me realize I need to slightly re-think my role here

[01:32] <pmichaud> (and in a good way)

[01:32] <sorear> What do you consider to be your role?

[01:32] <pmichaud> well, there are several

[01:33] <pmichaud> but the part I think needs reconsidering is that a large part of my job may in fact be refactoring code that others submit

[01:33] <pmichaud> as opposed to always generating new code for new capabilities

[01:34] <pmichaud> large projects need code cleaners, and perhaps I should target myself at that activity

[01:34] <diakopter> TimToady: see http://twitter.com/timbunce/status/14790377860

[01:36] <pmichaud> at any rate, I hope my refactors of the patches aren't being viewed entirely as rejections of the original patch or that the work wasn't valued/valuable

[01:36] <pmichaud> because it was

[01:36] <pmichaud> very valuable, that is

[01:37] <jnthn> Nice clarification. ;-)

[01:38] <pmichaud> yes, I'm struggling here to get the correct nuances out

[01:38] <jnthn> pmichaud: So long as that role is also -Ofun for you, or an -Ofun balance can be found for it, though, +1. :-)

[01:39] <jnthn> pmichaud: Your sense of what is likely to cause us problems down the line is usually pretty spot on.

[01:39] <pmichaud> jnthn: well, the role rethink is part of a larger evolution, also

[01:39] <pmichaud> we're rapidly moving from a situation where there are a small number of heavy code contributors to a large number of them

[01:39] <pmichaud> for which I'm very thankful, but I'm guessing that means more of my energy should be on code management and review 

[01:40] <pmichaud> I am truly impressed at the code that this team is producing

[01:40] *** lue joined
[01:40] * jnthn is also very, very happy to see the team growing.

[01:40] <lue> what did I miss? Something about a growing team?

[01:41] <pmichaud> I mean, the fact that bkeeler++ came up with not just one, but two implementations for variable interpolation in regexes is... very encouraging.

[01:41] <pmichaud> (and impressive)

[01:41] <jnthn> Indeed.

[01:43] <pmichaud> what I need to figure out how to do is to get feedback to such contributors in a way that (1) enables them to do more of the refactor themselves, (2) feel the just recognition and reward for the effort they put forth, and (3) encourages them to do more

[01:43] <pmichaud> I think in these last situations I didn't do so well on these three points, which is what I'm looking to improve

[01:46] *** orafu left
[01:46] <jnthn> I guess in a sense, they're all trickier than Just Fixing The Code. But they're also all important in order to grow the team.

[01:47] <pmichaud> right.  in bkeeler's case, I felt it was important to Just Fix the Code

[01:47] <pmichaud> (because it was in nqp and rakudo trunk, and had implications for other code)

[01:47] *** jbwiv left
[01:47] <pmichaud> and I totally understand that he would be frustrated with me being delayed in getting useful feedback to him

[01:48] <pmichaud> anyway, I'm looking for a better balance, yes.

[01:49] <jnthn> pmichaud++

[01:51] <pugssvn> r30830 | jnthn++ | [t/spec] Test for a just-fixed Rakudo bug involving lexical roles and some calling syntax. 

[01:52] *** cdarroch left
[01:53] *** ash__ joined
[01:53] *** isBEKaml left
[01:53] *** ash__ left
[01:54] *** ash__ joined
[01:55] <dalek> rakudo: 972ae69 | jonathan++ | docs/ROADMAP:

[01:55] <dalek> rakudo: We've been able to import module symbols into current lexical scope for a while, 

[01:55] <dalek> rakudo: and nobody has complained it's epicly broke, so mark it as done.

[01:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/972ae6922da75e7257a8223b2e362eca9d802702

[01:55] <dalek> rakudo: 982e8e3 | jonathan++ | src/Perl6/Actions.pm:

[01:55] <dalek> rakudo: Fix $obj.Foo::bar in the case that Foo is lexically scoped.

[01:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/982e8e38aaaff9bf8cb53f393595a7254ac9dae2

[01:56] <jnthn> Another "must have" ticked off in the ROADMAP.

[01:56] <jnthn> And with the REPL we'll have another one. :-)

[01:56] <jnthn> Anyways, I should attempt sleep.

[01:56] <jnthn> night o/

[01:56] <lue> gnight o/

[01:58] *** meppl left
[02:00] <diakopter> I assume this was already mentioned here: http://www.oreillygmt.co.uk/2010/05/damian-conway-on-perl-and-its-future.html

[02:01] *** felipe left
[02:02] <diakopter> "Perl 6.0, which is itself still six to twelve months away."  what?

[02:02] <Eevee> diakopter: christmas?

[02:03] <diakopter> I really have no idea where he gets that idea

[02:06] <sorear> this is Damian we're talking about

[02:07] <diakopter> I was referring to that quote, yes.

[02:07] <lue> afk

[02:09] <diakopter> sorear: if I read between the lines correctly, I must not be familiar with the Damian reputation..?

[02:09] <pugssvn> r30831 | sorear++ | [viv] Implement named, defaulting, and contextual parameters 

[02:09] <sorear> diakopter: he's one of the original Perl 6 prime movers, and even more optimistic/crazy/etc than TimToady

[02:10] <diakopter> I was aware of the first part of that; I didn't realize TimToady was optimistic/crazy/etc :)

[02:10] *** diakopter sets mode: +o sorear

[02:14] <sorear> has anyone tried requesting ownership of #perl6 from Freenode?

[02:14] <diakopter> someone on #freenode said that pmichaud did a while ago, but that person wouldn't give details on the status of that application; he/she said we should ask pmichaud

[02:18] *** [mark] joined
[02:29] <pugssvn> r30832 | sorear++ | [viv] Improve formatting of output blockoids 

[02:34] <pmichaud> I did that back in January, yes.

[02:34] <pmichaud> I've never gotten any sort of responses to my request.

[02:34] <pmichaud> I think you have to be optimistic to be able to work on Perl 6.  :-)

[02:34] <pmichaud> pessimists need not apply.

[02:41] *** sorear left
[02:42] *** sorear joined
[02:43] <colomon> jnthn++

[02:52] <colomon> pmichaud++ # rethinking

[02:53] <colomon> rakudo: say (1, 2, * * (* + 1) ... 1000).perl

[02:53] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[02:53] <colomon> whoops.

[02:53] <colomon> rakudo: say (1, 2, * * * ... 1000).perl

[02:53] <p6eval> rakudo 982e8e: OUTPUT«(1, 2, 2, 4, 8, 32, 256)␤»

[02:54] * colomon to bed

[02:54] <diakopter> rakudo: say (1, 1000000000, * * * ... 1000).perl

[02:54] <p6eval> rakudo 982e8e: OUTPUT«(1, 1000000000, 1000000000, 1e+18, 1e+27, 1e+45, 1e+72, 1e+117, 1e+189, 1e+306, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, {???} ... ???)␤»

[02:55] <diakopter> urk

[02:55] <diakopter> rakudo: say (1, 1001, * * * ... 1000).perl

[02:55] <p6eval> rakudo 982e8e: OUTPUT«(1, 1001, 1001, 1002001, 1003003001, 1.005010010005e+15, 1.00802805607006e+24, 1.01307828671629e+39, 1.0212113360054e+63, 1.03456703065561e+102, 1.05651157956295e+165, 1.09303204772171e+267, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf,

[02:55] <p6eval> ..Inf, I…

[02:57] <diakopter> rakudo: say (1, 1e238, * * * ... Inf).perl # this seems wrong

[02:57] <p6eval> rakudo 982e8e: OUTPUT«(1, 1e+238, 1e+238, Inf)␤»

[02:57] *** simcop2387 joined
[03:05] <pugssvn> r30833 | sorear++ | [viv] Implement $*endsym (crudely) 

[03:05] *** eternaleye joined
[03:08] *** felipe joined
[03:10] <diakopter> implemented a hybrid of let/cc and longjmp

[03:11] <sorear> TimToady: Is the "is binary" etc stuff in STD.pm6 actually used for anything currently?

[03:15] <pugssvn> r30834 | sorear++ | [viv] Fix symbol escaping 

[03:17] <TimToady> sorear: nope, fossil

[03:17] * sorear feels like $*endsym ought to be $?endsym

[03:18] <sorear> and <sym> should NOT be valid in subrules

[03:24] <TimToady> but a proto might need to make sure its specific subrule has it

[03:25] <TimToady> but whatever, as long as it works :)

[03:26] <diakopter> perlesquel: my $e = sub (FrameBase $f-->int) { say(1); longjmp($f); say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[03:26] <p6eval> perlesquel: OUTPUT«1␤3␤4␤real 0.05␤user 0.03␤sys 0.00␤»

[03:26] <diakopter> whee

[03:26] <dalek> csmeta: r301 | diakopter++ | trunk/Sprixel/ (4 files):

[03:26] <dalek> csmeta: [perlesque] implemented a hybrid of let/cc (expressed by the keyword "_cc") and

[03:26] <dalek> csmeta: a builtin non-local jump - longjmp(frame)

[03:26] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=301

[03:27] <TimToady> sorear++ may well have viv all ready for you by the time diakopter++ needs it \o/

[03:28] * diakopter snicker

[03:28] <sorear> TimToady: I'm a bit confused by <?before blah blah blah>

[03:29] <sorear> How does that differ from <before blah blah blah> or <?blah blah blah> ?

[03:29] <TimToady> #1 would bind to $<before>

[03:29] <sorear> What would #1 bind?

[03:29] <TimToady> #2 only works if blah is an assertion

[03:29] <TimToady> always nothing, I think

[03:30] <diakopter> oh waitz, my eggzample is hrong. zback du dee drrahing boord

[03:31] <diakopter> it should output 1␤4␤

[03:31] <sorear> I see.

[03:35] <sorear> TimToady: Don't get too excited, I'm only 4% through STD.pm6

[03:37] <TimToady> it always speeds up :)

[03:41] <TimToady> I haven't tried to pass anything up out of a before directly--it might or might not work by now

[03:41] <TimToady> but due to buginess in that path in earlier versions, I usually get info out by setting a :my $x defined earlier

[03:44] * sorear wonders if a pure "Perl 6" Cursor/LazyMap would be unacceptably slow

[03:45] <TimToady> as soon as you're done with viv -5, we can find out whether it can at least run as fast as it currently does :)

[03:45] <TimToady> assuming that most everything in pm5 can be backtranslated to pm6

[03:45] <diakopter> oh hee; found my bug

[03:46] <TimToady> that viv -5 will turn into something closely resembling the original 5

[03:46] * diakopter thinks about buginess

[03:47] <TimToady> that's assuming that viv -5 can easily do better at translating embedded regexes, esp if marked :P5  :)

[03:47] <TimToady> s/better/better than gimme5/

[03:48] <TimToady> once viv -5 works, we'll probably freeze the current STD.pm6 as STD_stage_0.pm6 and then start refining the stage 1 STD.pm6 to be more Perl Sixy

[03:49] <diakopter> whee

[03:49] <sorear> Actually, I was planning to freeze the then-current STD.pmc as boot/STD.pmc and then rm gimme5 with much rejoicing

[03:50] <diakopter> tomato, potato

[03:51] <TimToady> I think we should probably save the bootstrap path for a while just for safety and testing regression, but eventually we can kick it out from under completely as we gain confidence in the new stage

[03:51] <TimToady> and in case we want to make a systematic change to boot/STD.pmc

[03:53] <TimToady> but on the other side, we can presumably always get it back from svn if we really need it

[03:55] <diakopter> even the downiest of pinions can perish

[03:56] *** lue left
[03:56] <pugssvn> r30835 | sorear++ | [viv] Implement <before>, <after>, and related assertion forms 

[03:58] *** Khisanth left
[04:01] *** Khisanth joined
[04:01] *** tedv left
[04:06] <pugssvn> r30836 | sorear++ | [viv] Implement <?foo> and <!foo> 

[04:06] *** lue joined
[04:07] *** xinming joined
[04:12] <diakopter> it was an off-by-one-ish error

[04:12] <diakopter> har

[04:13] <sorear> TimToady: What is the scoping procedure for $MAYBACKTRACK?

[04:13] <sorear> I'm not understanding its dataflow

[04:15] *** agentzh joined
[04:15] <diakopter> perlesquel: my $e = sub (FrameBase $f-->int) { say(1); longjmp($f); say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[04:15] <p6eval> perlesquel: OUTPUT«1␤4␤real 0.05␤user 0.05␤sys 0.01␤»

[04:16] <dalek> csmeta: r302 | diakopter++ | trunk/Sprixel/ (3 files):

[04:16] <dalek> csmeta: [perlesque] regular continuations.

[04:16] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=302

[04:16] *** ash__ left
[04:17] <diakopter> I guess technically longjmp($f) could sound like goto($f)

[04:17] *** ash__ joined
[04:20] <diakopter> I suspect perlesque has far too much control flow now.

[04:20] *** drbean_ joined
[04:20] <dalek> csmeta: r303 | diakopter++ | trunk/Sprixel/t/parse_bug2.t:

[04:20] <dalek> csmeta: [perlesque] fix parse_bug2.t

[04:20] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=303

[04:21] <diakopter> phenny: tell pmurias try this:  my $e = sub (FrameBase $f-->int) { say(1); longjmp($f); say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[04:21] <phenny> diakopter: I'll pass that on when pmurias is around.

[04:22] <diakopter> late_dinner&

[04:23] *** kst` joined
[04:23] *** drbean left
[04:23] *** XaeroOne joined
[04:24] <diakopter> TimToady: LOL http://twitter.com/migueldeicaza/status/14811536038

[04:24] *** kst left
[04:25] <TimToady> sorear: $MAYBACKTRACK is true if any subtree could produce multiple cursors due to non-ratcheting or explicit greedy or eager markers

[04:25] <TimToady> it basically pessimizes all the nested ifs outward from there into lazymaps

[04:26] <diakopter> (is what I guessed too. sprixel's grammar engine has the same construct)

[04:26] <diakopter> really_late_dinner&

[04:27] <TimToady> Sometimes I wish I could write as well as people think I write too...

[04:27] <sorear> Ok, viv is completely wrong then

[04:28] <pugssvn> r30837 | sorear++ | [viv] Implement \x and zero-width punctuational assertions 

[04:29] <sorear> in the last hour I have gotten 1 further line into STD.pm6

[04:29] <sorear> I hope it gets easier soon ;)

[04:29] <TimToady> lol dalmations

[04:29] <TimToady> when you get to about 40%, you're nearly done

[04:29] <TimToady> but yeah, it does tend to go in fits and starts

[04:30] <sorear> dalmations?

[04:30] <TimToady> yes, lol of them.

[04:34] *** sav_ joined
[04:34] <dalek> nqp-rx: f60fcfe | plobsing++ | src/ (5 files):

[04:34] <dalek> nqp-rx: fix with respect to ops_massacre parrot branch

[04:34] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/f60fcfe701c1c024faf49cf134041d3a3a3be9ba

[04:37] *** sav_ left
[04:39] <sorear> TimToady: what is gimme5:656 doing?

[04:39] <sorear> I can't find the code it looks like it should generate in STD.pm5

[04:41] <TimToady> it's a fossil from before we used <O()>

[04:42] <TimToady> we used to use some fake mixinish types to set operator characteristics, but it was pretty bogus, and pmichaud++ came up with the <O()> method instead, which is more better

[04:43] <pugssvn> r30838 | sorear++ | [viv] Correctly use $*MAYBACKTRACK 

[04:50] <TimToady> basically, that code is never used because STD doesn't have --> in any signatures

[04:50] <TimToady> if no -->, $pkg is never set

[04:52] <pugssvn> r30839 | sorear++ | [viv] Implement character classes 

[04:56] <pugssvn> r30840 | sorear++ | [viv] Implement <?> and <!> (the degenerate forms) 

[04:57] <sorear> down to line 303 "regex stdstopper"

[04:57] <sorear> this'll be a tricky one

[04:58] <TimToady> ah yes, your first alternation :)

[04:58] <sorear> I actually implemented alternation a while ago

[04:58] <sorear> it's the declaration and code block that (somewhat) scare me

[04:59] <TimToady> ah yes, I see now that nofun has one earlier

[04:59] <sorear>     :my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists;

[04:59] <sorear> erm.

[04:59] <sorear> does the my @stub = do anything at all?

[05:01] <TimToady> no, it's just for the side effect, hence the name, but I was trying to get it as early as possible and as fast as possible, as a microoptimization

[05:02] <TimToady> the :my is pretty straightforward though, just do the un6 equivalents, and drop straight into the output

[05:03] <sorear> it looks like gimme5 enforces C89 declaration rules

[05:03] <TimToady> well, it ain't K&R

[05:04] <TimToady> but yeah, gimme5 isn't very flexible there

[05:04] <TimToady> viv can probably do better

[05:06] <TimToady> fortunately, as in p6, 'my' in p5 doesn't have to be at the statement level

[05:06] <TimToady> though p5 will get upset at a ; inside parens

[05:06] <TimToady> std: (42;)

[05:06] <p6eval> std 30840: OUTPUT«ok 00:01 114m␤»

[05:06] <TimToady> and p6 won't :)

[05:09] <sorear> why does RE_sequence bubble RE_decl nodes to the front?

[05:09] <TimToady> and the block is pretty trival, it just un6's and wraps itself in a do {}

[05:09] *** XaeroOne left
[05:11] <TimToady> I don't think it bubbles, it just assumes they're first

[05:12] <TimToady> but it pulls them off because it wants to process the sequence in reverse order, I think

[05:12] <TimToady> or wants to have the capability to, within an <?after ...>

[05:22] * allbery_b reads the discussion about eqv and finds humself wondering if it's supposed to be the Solve The Halting Porblem operator

[05:23] <allbery_b> also, I've been spending altogether too much time trying to write p6 regexen in perl5.8 :)

[05:23] <TimToady> even gimme5 requires 5.10 to do that.  :)

[05:24] <TimToady> and mostly only by ignoring 5.10 regexes :)

[05:24] * sorear blinks

[05:24] <TimToady> it really mostly uses 5.10 so that we get // and switches and say

[05:26] <TimToady> but I don't think any program has stressed p5's lexical scoping and closures more than STD.pm5 has  :)

[05:27] <TimToady> and p5 remains rock solid in that regard \o/

[05:27] <allbery_b> most notable acomplishment there so far is managing to get macports 5.8.9's regexp engine to dump core by using (?{}) to simulate some p6-isms

[05:27] <pugssvn> r30841 | sorear++ | [viv] Implement regex embedded declarations 

[05:27] * sorear mumbles something about a small world

[05:27] <allbery_b> heh

[05:28] <TimToady> Damian's talk about writing a p6-like grammar in p5 talks alot about the many issues of (?{}) in p5

[05:28] <sorear> link?

[05:29] <allbery_b> I just bet, after my experience

[05:29] <TimToady> dunno, Damian tends not to put his talks online

[05:29] <sorear> hmm.  RE_block is big and scary.

[05:29] <allbery_b> sad

[05:31] <TimToady> sorear: the front part is working around the stupidity of un6(), which can't know how to put a ; on the end of a given {} construct like p5 needs

[05:31] *** kaare joined
[05:32] *** kaare is now known as Guest9589

[05:32] <sorear> where does p5 need ; ?

[05:32] <allbery_b> anonymous subs?

[05:33] <allbery_b> anonymous hashes?

[05:34] *** kel__ joined
[05:34] <sorear> What about the \bmake\b thing?

[05:35] <TimToady> apparently it's parsed more like a do {} than like a for {}

[05:36] <TimToady> so it needs a ; if there's another statement after

[05:36] <TimToady> or did, maybe they've fixed that now in recent p5

[05:37] <TimToady> hmm, no, it works with 5.10.0

[05:37] * TimToady scratches head

[05:37] <TimToady> maybe you can just ignore that part

[05:38] <TimToady> the rest of it is just accounting for the difference between {}, <{}>, <?{}>, etc

[05:39] <TimToady> maybe I was using a 5.9 that needed the ;

[05:39] <TimToady> anyway, seems to be a fossiloid

[05:42] <pugssvn> r30842 | sorear++ | [viv] Implement embedded blocks 

[05:42] <sorear> huh

[05:42] <sorear> pugssvn spoke before svn ci returned to shell

[05:42] <TimToady> happens sometimes

[05:53] <sorear> Does :dba scope to the whole regex, or is it lexical?

[05:55] <sorear> looks like "whole"

[05:57] *** TiMBuS joined
[05:57] <TimToady> suppose to be lexical

[05:57] <TimToady> *d

[05:58] <TimToady> shouldn't really leak from a []

[05:58] <pugssvn> r30843 | sorear++ | [viv] Implement :dba 

[05:59] <TimToady> note that %adverbs is lexical, supposedly

[05:59] * diakopter feels like staying awake just to watch the sorear++ commits

[06:00] <pragma_> Are are there double-pluses in the names?

[06:00] <pragma_> Why...

[06:00] <diakopter> heh

[06:00] <diakopter> hugme: karma sorear 

[06:00] <diakopter> hugme: @karma sorear 

[06:00] <diakopter> phenny: karma sorear 

[06:00] <diakopter> gehenna these bots

[06:01] * pragma_ slowly backs away and disappears.

[06:01] <diakopter> pragma_: I forget how to get the karma

[06:01] <sorear> buubot: karma sorear

[06:01] <buubot> sorear: sorear has karma of 126    sorear: k23z__ wanted you to know: hey, come to #galoistheory when you get back, we're rallying up forces to do something  

[06:01] <pugssvn> r30844 | lwall++ | [STD] each BEGIN or use needs to explain its own mysteries 

[06:02] <diakopter> buubot: karma diakopter

[06:02] <buubot> diakopter: diakopter has karma of 397      

[06:02] <diakopter> diakopter--

[06:02] <diakopter> buubot: karma diakopter

[06:02] <buubot> diakopter: diakopter has karma of 396      

[06:02] <diakopter> buubot: karma jnthn

[06:02] <buubot> diakopter: jnthn has karma of 839      

[06:02] <diakopter> buubot: karma lwall

[06:02] <buubot> diakopter: lwall has karma of 665      

[06:02] <TimToady> oh oh

[06:02] <diakopter> lwall++

[06:02] <TimToady> lwall++

[06:02] <diakopter> heh

[06:02] <TimToady> whew!

[06:03] <TimToady> don't you dare :)

[06:03] <sorear> buubot: karma TimToady

[06:03] <buubot> sorear: TimToady has karma of 230      

[06:03] <TimToady> course, if it were smarter, it wouldn't let me karma lwall

[06:04] <TimToady> a singularly unproductive personage, given how long he's been hanging out here

[06:04] <TimToady> buubot: karma larry

[06:04] <buubot> TimToady: larry has karma of       

[06:05] <TimToady> heh

[06:05] *** uniejo joined
[06:05] <TimToady> I guess I only used to get that when the specs were on perl.org

[06:05] <diakopter> buubot got rebooted a month or two ago I think

[06:05] <buubot> diakopter: Couldn't match input.

[06:09] <diakopter> ok, now, how to translate these scheme call/cc examples to perlesque...

[06:10] <sorear> stdstopper translated successfully

[06:10] <pugssvn> r30845 | sorear++ | [viv] Implement brackets 

[06:11] <sorear> great, now I'm up to regex_infix__S_Tilde

[06:12] <sorear> which I never *really* understood to begin with

[06:12] <sorear> (morename)

[06:13] <diakopter> std: / ~ /

[06:13] <p6eval> std 30842: OUTPUT«===SORRY!===␤Null pattern not allowed at /tmp/OW6buOvLw2 line 1:␤------> / ⏏~ /␤Parse failed␤FAILED 00:01 111m␤»

[06:13] <pragma_> colors and unicode!  the goggles do nothing!

[06:14] <diakopter> lol.

[06:14] <TimToady> the ~ requires something before and two somethings after

[06:15] <moritz_> good morning

[06:15] <TimToady> sorear: btw, the code for that changed in gimme5 today

[06:16] <TimToady> since it now wants to set up the goal as a <stopper> if it's not a standard stopper

[06:16] <TimToady> moritz_: it'll be morning here in less than an hour :)

[06:17] <moritz_> TimToady: good ahead-of-time morning to you, then :-)

[06:17] <moritz_> can't sleep?

[06:17] <TimToady> I'm often up till midnightish

[06:18] <moritz_> ah, I thought you meant sun rise time or so with morning

[06:18] <TimToady> I'm in ca.us

[06:18] <moritz_> I know, but I don't keep track of time zones so well yet :-)

[06:19] <TimToady> this one's a bit further away than merry olde england

[06:21] <moritz_> rakudo: say 1

[06:21] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:21] <sorear> mberends: why leave rs?

[06:21] <moritz_> rakudo: say (*/*).(4, 2)

[06:21] <p6eval> rakudo 982e8e: OUTPUT«2␤»

[06:22] <moritz_> jnthn++

[06:25] <TimToady> rakudo: say ( * X=> * )(<a b c>, (1,2,3)).perl

[06:25] <p6eval> rakudo 982e8e: OUTPUT«invoke() not implemented in class 'GatherIterator'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[06:25] <TimToady> rakudo: say ( * !% * )(4,2)

[06:25] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:26] <TimToady> rakudo: say ( * !% * )(5,2)

[06:26] <p6eval> rakudo 982e8e: OUTPUT«0␤»

[06:26] <TimToady> rakudo: say ( * !< * )(5,2)

[06:26] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:26] <TimToady> \o/

[06:26] <TimToady> rakudo: say ( * ![<=] * )(5,2)

[06:26] <p6eval> rakudo 982e8e: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1971 (ext/nqp-rx/src/stage0/Regex-s0.pir:1050)␤»

[06:26] <TimToady> heh

[06:28] <TimToady> rakudo: say ( * »*« * )([1,2,3],[2,3,4]).Str

[06:28] <p6eval> rakudo 982e8e: OUTPUT«2 6 12␤»

[06:28] <TimToady> \o/

[06:28] <diakopter> rakudo: say (*)(5,2)

[06:28] <p6eval> rakudo 982e8e: OUTPUT«!whatever_dispatch_helper␤»

[06:28] <moritz_> rakudo: say (* + 3).signature.perl

[06:28] <p6eval> rakudo 982e8e: OUTPUT«:(;; Mu $x)␤»

[06:28] <moritz_> rakudo: say (* + 3).(4, 5)

[06:28] <p6eval> rakudo 982e8e: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: '_block46' pc 312 (EVAL_1:126)␤»

[06:29] *** isBEKaml joined
[06:29] <moritz_> diakopter: should (*)(5, 2) give a similar message?

[06:29] <TimToady> * is not a closure at all

[06:29] <moritz_> so that should complate that Whatever is not invocable?

[06:29] <moritz_> *complain

[06:30] <sorear> what happens is that it gets treated as *.postcircumfix<( )>(5,2)

[06:30] <sorear> rakudo: say (*)(5,2)(*+*)

[06:30] <p6eval> rakudo 982e8e: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Block'␤current instr.: '!whatever_dispatch_helper' pc 278 (src/glue/dispatch.pir:23)␤»

[06:31] <sorear> invoking a non-invocable is rewritten into a method call

[06:31] <moritz_> afk

[06:31] <sorear> our method dispatcher treats Whatever specially

[06:31] <TimToady> *.method should also be handled in the compiler

[06:31] <isBEKaml> hey, do we have native types like 'int', 'buf' ? 

[06:32] <sorear> not quite

[06:32] *** jjore joined
[06:32] <TimToady> diakopter does :)

[06:32] <TimToady> well, int anyway

[06:32] <sorear> TimToady: ~ is parsed as Just Another Infix.  Is this correct?

[06:32] <diakopter> yes, all those

[06:33] <isBEKaml> rakudo: enum somenum <a b c d e>; e.WHAT.perl.say; ## S12 says this should be lowercase int

[06:33] <p6eval> rakudo 982e8e: OUTPUT«Int␤»

[06:33] <sorear> hmm, it's also parsed at a lower prec than juxtaposition

[06:33] <diakopter> perlesquel: say(int64)

[06:33] <p6eval> perlesquel: OUTPUT«System.Int64␤real 0.09␤user 0.05␤sys 0.01␤»

[06:34] <isBEKaml> oh, perlesque has it. :)

[06:34] <diakopter> bigints too

[06:35] <diakopter> Complex64, if I just flip a switch here

[06:35] <TimToady> sorear: yes, but that's all negotiable

[06:35] <diakopter> I think.

[06:38] <isBEKaml> diakopter: Well, I have not used C# at all. 

[06:38] <TimToady> sorear: in a sense, the operator is really the ~ plus the goal atom

[06:38] <isBEKaml> I'm looking at the source code hosted in google code repos. 

[06:38] <diakopter> isBEKaml: yeah but, you don't need C#; you just need perlesque

[06:38] <diakopter> mostly.

[06:39] <TimToady> sorear: in another sense, ~ is a prefix that swaps the next two atoms around

[06:40] <TimToady> so we could also parse it as a mere term

[06:41] *** justatheory left
[06:42] <diakopter> where is the api for buf defined

[06:42] <sorear> We could also parse it as a ternary op (syntax change needed)

[06:42] <TimToady> well, of course, ??!! is just parsed as an infix, go figure...

[06:43] <TimToady> as long as the parser is left in a correct state for what comes after, it doesn't much matter

[06:43] <sorear> My main issue is that STD generates the wrong AST for it

[06:44] <sorear> a b ~ c d   should be a [b ~ c d]    not [a b] ~ [c d]

[06:44] * sorear writes some fragile reassociation code

[06:45] <TimToady> well, can we make it tigher than juxtaposition?  hmm

[06:46] <TimToady> quant_atom_list sees pretty watertight, unfortunately

[06:46] <TimToady> and we're not actually treating juxtaposition as an operator...

[06:47] * sorear thinks that, two weeks ago, '(' <~ <EXPR> ~> ')' would have been less of a shock to read

[06:47] <TimToady> that kinda argues for treating ~ <atom> <atom> as a macroish term

[06:48] <TimToady> I like seeing the brackets close together though

[06:48] <TimToady> got spoiled by seeing 'between' in Haskell

[06:48] <isBEKaml> TimToady: S12 enums section:1731,1732. What's Fri.so and Sun.so supposed to do? 

[06:49] <TimToady> especially if <EXPR> is something more complicated in [...]

[06:49] * diakopter growls at "the run-time system (presumably Parrot) is compiled in" in S09

[06:49] <isBEKaml> rakudo: enum somenum <a b c d e>; say e.so;

[06:49] <p6eval> rakudo 982e8e: OUTPUT«Method 'so' not found for invocant of class 'Integer'␤current instr.: '_block18' pc 29 (EVAL_2:0)␤»

[06:50] <TimToady> isBEKaml: your line numbers seem off...

[06:50] <isBEKaml> TimToady: Odd, I'm seeing them here in the pod. Wait, lemme svn up it. 

[06:50] <isBEKaml> TimToady: that's latest. 

[06:51] <TimToady> oh, nevermind, I went to 1371 :)

[06:51] <TimToady> 'so' used to be 'true', and is the opposite of 'not'

[06:51] <TimToady> rakudo: say so 42

[06:51] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:51] <TimToady> rakudo: say 42.so

[06:51] <p6eval> rakudo 982e8e: OUTPUT«Method 'so' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[06:51] <TimToady> NYI I guess

[06:51] <TimToady> rakudo: say 42.not

[06:51] <p6eval> rakudo 982e8e: OUTPUT«Method 'not' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[06:52] <TimToady> rakudo: say not so so so 0

[06:52] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:52] <TimToady> rakudo: say so True

[06:52] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:53] <TimToady> rakudo: say so Same

[06:53] <p6eval> rakudo 982e8e: OUTPUT«Could not find sub &Same␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[06:53] <TimToady> rakudo: say so Increase

[06:53] <p6eval> rakudo 982e8e: OUTPUT«Could not find sub &Increase␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[06:53] <TimToady> rakudo: say so Increasing

[06:53] <p6eval> rakudo 982e8e: OUTPUT«Could not find sub &Increasing␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[06:53] <TimToady> rakudo: say so Order

[06:53] <p6eval> rakudo 982e8e: OUTPUT«Could not find sub &Order␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[06:53] <TimToady> ah well

[06:54] <isBEKaml> TimToady: so so is used to check against existence of objects like defined() ?

[06:54] <sorear> should ~ be paying attention to the opener?

[06:54] <TimToady> rakudo: say so Order::Same

[06:54] <p6eval> rakudo 982e8e: OUTPUT«Can not find sub Order::Same␤current instr.: 'perl6;Perl6Exception;throw' pc 15859 (src/builtins/Regex.pir:18)␤»

[06:54] <TimToady> sorear: not really, except perhaps to make sure there is one

[06:55] <isBEKaml> TimToady: I don't know if Same, Increase, Increasing, Order are objects/classes. So, I'm guessing here if so <something> checks like defined() ? 

[06:55] <diakopter> rakudo: say so so &1

[06:55] <p6eval> rakudo 982e8e: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 11814 (src/builtins/Any.pir:54)␤»

[06:55] <diakopter> rakudo: say so so 1

[06:55] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:55] <diakopter> oh

[06:55] <isBEKaml> rakudo: say defined(42); 

[06:55] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:56] <TimToady> rakudo: say defined(0)

[06:56] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:56] <TimToady> rakudo: say so(0)

[06:56] <p6eval> rakudo 982e8e: OUTPUT«0␤»

[06:56] <TimToady> rakudo: say !!(0)

[06:56] <p6eval> rakudo 982e8e: OUTPUT«0␤»

[06:56] <TimToady> same thing

[06:56] <moritz_> just different precedence

[06:56] <TimToady> rakudo: say ?42

[06:56] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:57] <TimToady> rakudo: say !?42 === not so 42

[06:57] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[06:57] <isBEKaml> TimToady++ ## I see now, though I don't see where I could use them. 

[06:58] <TimToady> say "True" if .so;

[06:58] <TimToady> except method is NYI

[06:58] <moritz_> isn't the method form called .Bool?

[06:59] <TimToady> then what's .not?

[06:59] <moritz_> !.Bool? :-)

[06:59] <TimToady> say 42 ~~ :!Bool

[07:00] <TimToady> rakudo: say 42 ~~ :!Bool

[07:00] <p6eval> rakudo 982e8e: OUTPUT«0␤»

[07:00] <sorear> TimToady: should it ever be using .balanced?

[07:00] <TimToady> rakudo: say 0 ~~ :!Bool

[07:00] <p6eval> rakudo 982e8e: OUTPUT«1␤»

[07:01] <TimToady> sorear: depends on whether it's a quote form that has to count brackets, but for expressions that's handled by normal recursion

[07:02] <TimToady> quotes use <starter><stopper> for balanced, but circumfixes can just be recognized anywhere a term is expected in normal code

[07:02] <TimToady> so we don't generally need <starter>

[07:03] <sorear> What is the point of meta ':' and extra?

[07:03] <sorear> Is the token after ~ always a literal?

[07:04] <moritz_> doesn't need to be, iirc

[07:04] <dalek> csmeta: r304 | diakopter++ | trunk/Sprixel/src/ (2 files):

[07:04] <dalek> csmeta: [perlesque] add buf8 (buf), buf16, buf32, buf64

[07:04] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=304

[07:04] <TimToady> and when we do need starter, we can do it by passing the balanced lang into the nibbler, as the quote rules do

[07:04] <moritz_> rakudo: say 'abba' ~~ / . ~ . [b+]/

[07:04] <TimToady> yes, the goal must be a literal currently

[07:04] <p6eval> rakudo 982e8e: OUTPUT«abba␤»

[07:04] <moritz_> TimToady: by spec or by STD.pm6 usage?

[07:04] <TimToady> I don't remember why I hung it off the : meta

[07:06] <TimToady> the spec for ~ is a little bit fossily

[07:06] <TimToady> but doesn't require a literal

[07:06] <TimToady> however, $*GOAL is expected to be a string of some sort, which could, I suppose, be the regex that matches if it's not a literal

[07:07] <TimToady> at least we don't expect $*GOAL to be the actual thing matched anymore

[07:07] <sorear> could it be a compiled regex fragment?

[07:07] <TimToady> well, except that gimme5 currently sets up the <stopper> using the goal string...

[07:07] <TimToady> but that's just current implementation

[07:08] <TimToady> we don't use it to match anything anymore, so it's not meaning to compile it

[07:08] <TimToady> *ful

[07:08] * sorear implements it badly for now.

[07:08] <TimToady> \o/

[07:08] <moritz_> ok

[07:08] <moritz_> seminar canceled, now I got up early for now reason

[07:09] <dalek> csmeta: r305 | diakopter++ | trunk/Sprixel/src/Types/buf.cs:

[07:09] <dalek> csmeta: [perlesque] I guess the bufs need constructors

[07:09] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=305

[07:09] <dalek> csmeta: r306 | diakopter++ | trunk/Sprixel/src/Types/buf.cs:

[07:09] <dalek> csmeta: [perlesque] oops

[07:09] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=306

[07:09] <TimToady> oops, it's tomorrow already, by accident

[07:09] <moritz_> suddenly.

[07:09] <TimToady> the shock of it has made me sleepy

[07:10] <TimToady> so I'd probably better wander off, considering I have to drive to SoCal tomorrow with a vanful of teens...

[07:10] <TimToady> er, today

[07:10] <sorear> where, and which teens?

[07:10] <moritz_> good night

[07:10] <diakopter> lol

[07:10] <TimToady> church quiz team

[07:11] <isBEKaml> 'night, TimToady !

[07:11] <TimToady> they won at the district level, so now they're going to regionals

[07:11] <diakopter> wait timtoady to see the buf8 of capacity 1,000,000,000

[07:11] <TimToady> std: BEGIN { foo() }; sub foo {...}

[07:11] <p6eval> std 30845: OUTPUT«===SORRY!===␤Undeclared routine:␤      'foo' used at line 1␤Check failed␤FAILED 00:01 114m␤»

[07:12] <TimToady> that's better

[07:12] <sorear> TimToady: At the end of a construct which uses a modified language, how does $¢ get turned back into a normal cursor?

[07:12] <TimToady> std: sub foo {...}; BEGIN { foo() }

[07:12] <p6eval> std 30845: OUTPUT«ok 00:01 111m␤»

[07:13] <sorear> currently, I'm talking about ~

[07:13] <moritz_> rakudo: say ((3+ *) * 2).(2)

[07:13] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[07:13] <TimToady> std: foo(); BEGIN { 42; }; sub foo {...}

[07:13] <p6eval> std 30845: OUTPUT«ok 00:01 111m␤»

[07:13] <moritz_> rakudo: say ((3+ *) * *).(4, 2)

[07:13] <p6eval> rakudo 982e8e: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: '_block46' pc 312 (EVAL_1:126)␤»

[07:14] <TimToady> sorear: it's reblessed by _BRACKET or _BRACKETr

[07:14] <TimToady> :lang used to do a cursor_fresh, which is why we lost the old bindings

[07:15] <TimToady> now it just reblesses into the new language, and re-unblesses on scope exit

[07:15] <isBEKaml> moritz_: currying? that's in ? \o/

[07:15] <TimToady> alternately, BRACKET could have copies bindings up into the old $self

[07:15] <isBEKaml> rakudo: say (3 + *).(42);

[07:15] <moritz_> isBEKaml: at least the direct case

[07:15] <p6eval> rakudo 982e8e: OUTPUT«45␤»

[07:15] <TimToady> and that may yet turn out to be corrector from an immutable Cursor viewpoint

[07:15] <TimToady> *correcter

[07:15] <TimToady> night all

[07:15] <TimToady> zzz &

[07:16] <isBEKaml> rakudo: say ((3 + *) * *).(42).(5);

[07:16] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[07:16] <isBEKaml> rakudo: say ((3 + *) * *).(42,5);

[07:16] <p6eval> rakudo 982e8e: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: '_block46' pc 312 (EVAL_1:126)␤»

[07:16] <moritz_> rakudo: say (1 + *).WHAT

[07:16] <p6eval> rakudo 982e8e: OUTPUT«Block()␤»

[07:16] <moritz_> rakudo: say (1 / *).WHAT

[07:16] <isBEKaml> rakudo: say ((3 + *) * *).(5);

[07:16] <p6eval> rakudo 982e8e: OUTPUT«Block()␤»

[07:16] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[07:17] <isBEKaml> precedence doesn't seem to work.. 

[07:17] <moritz_> nesting doesn't work

[07:17] <moritz_> (1+*) returns a Block

[07:17] <isBEKaml> rakudo: say (3 + * * *).(42,5)

[07:17] <moritz_> instead of a WhateverCode

[07:17] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[07:17] <moritz_> same issue

[07:17] <isBEKaml> rakudo: say (* + 3  * *).(42,5)

[07:17] <p6eval> rakudo 982e8e: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: '_block46' pc 312 (EVAL_1:126)␤»

[07:18] <isBEKaml> rakudo: say (* + 3  - *).(42,5)

[07:18] <p6eval> rakudo 982e8e: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: '_block46' pc 312 (EVAL_1:23128766)␤»

[07:18] *** viklund joined
[07:18] <isBEKaml> that's supposed to WhateverCode ? 

[07:18] <isBEKaml> *be

[07:19] <moritz_> yes

[07:19] <moritz_> and that should curry just like * itself

[07:23] <diakopter> perlesquel: my $b = buf8.new(); $b[100000000] = 1; say($b.Count); say($b.Size);

[07:23] <p6eval> perlesquel: OUTPUT«100000001␤134217728␤real 1.90␤user 1.42␤sys 0.46␤»

[07:23] <dalek> csmeta: r307 | diakopter++ | trunk/Sprixel/ (2 files):

[07:23] <dalek> csmeta: [perlesque] make buf8, buf16, buf32, buf64 work.  Add Size getter

[07:23] <dalek> csmeta: (capacity/memory used)

[07:23] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=307

[07:23] <isBEKaml> moritz_: should * + num work the same as num + * ? I have seen * + * work, though. 

[07:24] <moritz_> rakudo: say (3 + *).(5)

[07:24] <p6eval> rakudo 982e8e: OUTPUT«8␤»

[07:24] <moritz_> works fine, and should

[07:24] <isBEKaml> rakudo: say (* + *).(4,2); say (* + 5).(5); 

[07:24] <p6eval> rakudo 982e8e: OUTPUT«6␤10␤»

[07:25] <isBEKaml> So that's indeed a Block() issue. Numifying a Block is indecent! ;)

[07:25] <moritz_> right :-)

[07:27] <diakopter> perlesquel: my $b = buf16.new(); $b[1000000] = 1; say($b.Count); say($b.Size);

[07:27] <p6eval> perlesquel: OUTPUT«1000001␤2097152␤real 1.61␤user 0.03␤sys 0.03␤»

[07:27] <pugssvn> r30846 | sorear++ | [viv] Implement ~ syntax 

[07:28] <diakopter> perlesque: my $b = buf16.new(); $b[10000000] = 1; say($b.Count); say($b.Size);

[07:28] <p6eval> perlesque: OUTPUT«10000001␤33554432␤»

[07:28] <sorear> 11%

[07:28] <diakopter> perlesquel: my $b = buf16.new(); $b[10000000] = 1; say($b.Count); say($b.Size);

[07:28] <p6eval> perlesquel: OUTPUT«10000001␤33554432␤real 0.37␤user 0.22␤sys 0.13␤»

[07:28] <diakopter> sorear: that's very impressive. you'll win fer sure.  FTW

[07:30] <isBEKaml> rakudo: say (3 * *).(42); 

[07:30] <p6eval> rakudo 982e8e: OUTPUT«126␤»

[07:31] <pugssvn> r30847 | sorear++ | [viv] Make method sigs optional 

[07:32] <moritz_> diakopter: I'm curious, do you have a plan for hiding the C# methods from userland at some point? another indirection layer?

[07:39] <isBEKaml> rakudo: enum somenum <a b c d e>; my somenum $temp = 3; say $temp.key; 

[07:39] <p6eval> rakudo 982e8e: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 18373 (src/builtins/Junction.pir:373)␤»

[07:39] <isBEKaml> o.O (NYI ? )

[07:39] <moritz_> rakudo: enum somenum <a b c d e>; my somenum $temp = d; say $temp

[07:39] <p6eval> rakudo 982e8e: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 18373 (src/builtins/Junction.pir:373)␤»

[07:39] <isBEKaml> std: enum somenum <a b c d e>; my somenum $temp = 3; say $temp.key; 

[07:39] <p6eval> std 30846: OUTPUT«ok 00:01 116m␤»

[07:40] <moritz_> STD doesn't do type checks

[07:40] <isBEKaml> oh, bug? 

[07:40] <sorear> no

[07:40] <sorear> Perl6 type checks (notionally) happen at run time

[07:40] <sorear> STD doesn't do run time

[07:41] <isBEKaml> not in std, I was asking about Rakudo.

[07:41] <moritz_> yes, bug

[07:41] <mathw> Morning

[07:41] <moritz_> asigning an element element (ie d) should work

[07:41] * moritz_ submits rakudobug

[07:42] <isBEKaml> I think, so should assigning a value and getting the corresponding key. 

[07:42] <moritz_> not sure; might need a coercio

[07:42] <moritz_> n

[07:42] <moritz_> just like my Int = "3" is an error too

[07:43] <diakopter> moritz_: no, b/c perlesque isn't the real userland :D

[07:43] <isBEKaml> but, somenum::d would throw Int

[07:44] <moritz_> diakopter: but the plan is to write a compiler at some point that targets perlesque, right?

[07:44] <moritz_> isBEKaml: I'd assume it returns something more than an Int

[07:45] <isBEKaml> diakopter: I was curious too, If I didn't need C#, atleast I should need a runtime, right? 

[07:45] <diakopter> moritz_: yes in the actual Perl 6 compiler (Sprixel, written in perlesque and targetting perlesque) it'll do all its own dispatch and at least one boxing/abstraction layer on everything

[07:45] <isBEKaml> rakudo: enum somenum <a b c d e>; somenum::d.WHAT.perl.say; 

[07:45] <moritz_> diakopter: ok, that's what I wanted to know

[07:45] <p6eval> rakudo 982e8e: OUTPUT«Int␤»

[07:45] <moritz_> diakopter: thanks

[07:45] <diakopter> moritz_: :D

[07:45] <moritz_> isBEKaml: that might be the reason it doesn't work

[07:46] <diakopter> basically it'll be just like rakudo on parrot in that sense.  lots and lots of dispatching and wrappers and translators

[07:46] *** Sarten-X left
[07:46] <moritz_> :(

[07:46] <diakopter> heh

[07:46] <moritz_> it's those parts that make rakudo complicated

[07:47] <moritz_> I've been digging into several parts of the rakudo guts to try to fix bugs and/or add features

[07:47] <diakopter> I'm fairly sure Perl 6 necessitates such depth

[07:47] *** ejs joined
[07:47] <moritz_> and I found that it's always complicated when there's a mismatch between Perl 6 and parrot

[07:47] <moritz_> example: iterators

[07:48] <isBEKaml> rakudo: enum Somenum <a b c d e>; Somenum::d.WHAT.perl.say; enum somenum <a b c d e>; somenum::d.WHAT.perl.say; ## S12 says first should return Int while second native type (int).

[07:48] <p6eval> rakudo 982e8e: OUTPUT«Contextual $*PKGDECL not found␤current instr.: 'perl6;Perl6;Grammar;add_my_name' pc 44311 (src/gen/perl6-grammar.pir:79)␤»

[07:48] <isBEKaml> I was asking about that sometime ago.. 

[07:48] <diakopter> perlesque has an advantage there, since it supports reified continuations, as of tonight.

[07:48] <diakopter> (the perlesque code generated by a compiler to represent an iterator could use them, I mean)

[07:49] <diakopter> moritz_: would you like to see an example?

[07:50] <moritz_> diakopter: yes please

[07:50] <diakopter> perlesque: my $e = sub (FrameBase $f-->int) { say(1); longjmp($f); say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[07:50] <p6eval> perlesque: OUTPUT«1␤4␤»

[07:50] <diakopter> you could call that  "call/cc of int"

[07:51] <diakopter> perlesquel: my $e = sub (FrameBase $f-->int) { say(1); longjmp($f); say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[07:51] <p6eval> perlesquel: OUTPUT«1␤4␤real 0.05␤user 0.03␤sys 0.00␤»

[07:51] <diakopter> (without the stage0,1 steps)

[07:51] *** XaeroOne joined
[07:51] *** awwaiid left
[07:52] <diakopter> $e is the sub that jumps back into the frame that saved its own continuation

[07:52] <moritz_> takes some time to read and grok :-)

[07:52] *** alanhaggai left
[07:53] <diakopter> to actually emulate Scheme call/cc, the frame would need casting to IReturn_System_Int32, so that its Return slot (an int) could be mutated (assigned) in whatever sub wanted to set it

[07:54] <diakopter> which is just fine, I just haven't implemented casting/coercion

[07:54] <sorear> moritz_: the logbot has lapsed in #rakudosketch

[07:55] <moritz_> sorear: it parted, because we're now in #phasers instead of #rakudosketch

[07:55] <sorear> I thought that was a temporary thing

[07:55] <sorear> #rakudosketch is now registered, anyway

[07:56] <sorear> you have +o

[07:56] <diakopter> hee

[07:56] <diakopter> bed&

[08:00] <isBEKaml> rakudo: enum One <a b c d e>; say One::d.WHAT.perl; enum Two <a b c d e>; Two.d.WHAT.perl.say; 

[08:00] <p6eval> rakudo 982e8e: OUTPUT«Contextual $*PKGDECL not found␤current instr.: 'perl6;Perl6;Grammar;add_my_name' pc 44311 (src/gen/perl6-grammar.pir:79)␤»

[08:01] <isBEKaml> :(

[08:02] *** JimmyZ joined
[08:03] <JimmyZ> wow, rakudosketch is back!

[08:04] *** ejs left
[08:06] <pugssvn> r30848 | sorear++ | [viv] Add an error-recovery procedure 

[08:06] <isBEKaml> moritz_: the above is right? 

[08:06] *** awwaiid joined
[08:07] <moritz_> isBEKaml: I have no idea

[08:07] <moritz_> for sure it's a LTA error

[08:08] <isBEKaml> http://rt.perl.org/rt3/Ticket/Display.html?id=72696

[08:08] <isBEKaml> I think it's related to this. Was this fixed at some point of time? 

[08:08] *** ejs joined
[08:09] <moritz_> nope

[08:09] <isBEKaml> rakudo: enum One <a b c d e>;  enum Two <a b c d e>; say &d; 

[08:09] <p6eval> rakudo 982e8e: OUTPUT«Contextual $*PKGDECL not found␤current instr.: 'perl6;Perl6;Grammar;add_my_name' pc 44311 (src/gen/perl6-grammar.pir:79)␤»

[08:11] * isBEKaml submits rakudobug

[08:12] *** Ross^ joined
[08:16] <isBEKaml> moritz_: do I add it to the above ticket or create a new one? 

[08:16] <moritz_> add it

[08:17] *** dakkar joined
[08:17] <sorear> diakopter: With my shiny new error recovery mechanism, 265 statements in STD.pm6 contain untranslatable terms

[08:18] <sorear> (this doesn't count terms for which the translation is wrong, sadly)

[08:20] <moritz_> it's probably not easy to generate such a count automatically

[08:29] <pugssvn> r30849 | sorear++ | [viv] Implement <?{ FOO }> and related assertions 

[08:31] <cognominal> rakudo: say Code.does(Abstraction)

[08:31] <p6eval> rakudo 982e8e: OUTPUT«0␤»

[08:32] <sorear> hmm.  STD.pm6 uses multi dispatch for tweaks ...

[08:35] <cognominal> say :a.does(Pair)

[08:35] <cognominal> rakudo: say :a.does(Pair)

[08:35] <p6eval> rakudo 982e8e: OUTPUT«0␤»

[08:35] <cognominal> I am probably doing some abvious mistake.

[08:35] <cognominal> STD: say :a.does(Pair)

[08:36] <cognominal> std: say :a.does(Pair)

[08:36] <p6eval> std 30848: OUTPUT«ok 00:01 114m␤»

[08:37] <cognominal> std: say 0

[08:37] <p6eval> std 30848: OUTPUT«ok 00:01 111m␤»

[08:37] <moritz_> it's just a syntax checker

[08:37] <cognominal> std: say 1

[08:37] <p6eval> std 30848: OUTPUT«ok 00:01 111m␤»

[08:37] <cognominal> thx, I forgot that

[08:56] *** Ross^ left
[09:06] *** plobsing left
[09:08] *** clintongormley joined
[09:14] <pugssvn> r30850 | sorear++ | [viv] Add support for argument quantifiers, refactor parameter 

[09:19] *** jferrero joined
[09:19] *** pmurias joined
[09:19] <pugssvn> r30851 | sorear++ | [viv] Allow parameters with multiple names 

[09:22] *** bacek joined
[09:24] <pugssvn> r30852 | sorear++ | [viv] Implement slurpy parameters 

[09:33] <pugssvn> r30853 | sorear++ | [viv] Implement multiple dispatch 

[09:34] <sorear> down to 175 untranslatable terms

[09:35] <sorear> I love the way that viv is actually faster than gimme5

[09:35] <sorear> (assuming STD.pmc is precompiled to Storable)

[09:36] <pugssvn> r30854 | sorear++ | [viv] Oops.  Forgot an initializer 

[09:36] <sorear> I mean 148

[09:39] <sorear> I mean 120

[09:40] <pugssvn> r30855 | sorear++ | [viv] Another missing initializer 

[09:40] *** masak joined
[09:40] <masak> oh hai, #perl6!

[09:40] <mberends> \o

[09:40] <moritz_> oh hai masak

[09:40] <sorear> hello

[09:41] <moritz_> rakudo: my $x = *; say ($x + 3).(5)

[09:41] <p6eval> rakudo 982e8e: OUTPUT«Use of uninitalized value in numeric context␤invoke() not implemented in class 'Float'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:41] <masak> how lovely to see you all today.

[09:41] <mberends> :-) it's mutual

[09:42] *** mberends sets mode: +o masak

[09:42] * sorear sleeps

[09:42] <moritz_> good night

[09:43] *** IllvilJa joined
[09:44] *** cli_ joined
[09:50] <isBEKaml> masak: hi! 

[09:50] <masak> isBEKaml! hi!

[09:50] <moritz_> http://watz.nerd2nerd.org/ubuntu.png it seems that Ubuntu doesn't recommend it its own products (at least the 64bit versions)

[09:51] <moritz_> which is at the same time both sad, and has some encouraging honesty

[09:52] <cognominal> \o

[09:54] <mberends> ubuntu recommends 32 bit for beginners to use 3rd party binary software compatibility, that's all

[09:54] <cognominal> how long 64bit x86 processors have been around?  what a shame?  or is that it is more memory hungry?

[09:54] *** yinyin left
[09:55] <moritz_> on 64 bit debian I didn't have serious problems with 3rd party binary software

[09:55] <isBEKaml> I believe that's mainly for binary compatiblity and ubuntu's mainly targeted at newbies to Linux. 

[09:56] <isBEKaml> oh, what mberends++ said. :)

[09:56] <mberends> maybe things like Adobe apps and plugins, JRE, Windows NDIS drivers

[09:56] <moritz_> flash, skype, Mathematica, matlab worked fine (though I had to install some 32bit wrapper libs for skype - but that's easy to avoid if you provide 64bit packages that depend on the ia32-libs)

[09:56] <moritz_> mberends: ah, the last point might be the most important one

[09:56] <moritz_> the ndis wrapper

[09:57] <moritz_> Java and adobe reader also worked fine for me 64bit linux

[09:57] <mberends> beginners -> 32 bit, power users -> 64 bit

[10:00] <moritz_> anyway, I just found it amusing

[10:00] <moritz_> Mathematica has both dynamic and lexical scoping

[10:01] <moritz_> but instead of prefixing each variable with an indicator lex vs. dynamic, the scope is prefixed (Block vs. Module in Mathematicaspeak)

[10:04] *** cli_ left
[10:05] *** cowyn joined
[10:05] *** masonkramer joined
[10:07] *** masonkramer left
[10:08] <mberends> moritz_: the rakudo branches split-setting and split-gen-setting-2 seem outdated today, shall we remove them? Any new such work would be better off starting from scratch.

[10:09] <JimmyZ> and also *string branch

[10:10] <moritz_> mberends: wfm

[10:11] *** cowyn left
[10:11] <mberends> ok, will do those three

[10:13] *** cowyn joined
[10:22] *** IllvilJa left
[10:35] *** am0c joined
[10:38] *** arthur-_ joined
[10:42] *** arthur-_ left
[10:43] *** JimmyZ left
[10:51] *** Ross^ joined
[10:52] *** agentzh left
[10:53] <pugssvn> r30856 | pmurias++ | [mildew] added simplified method to AST::Assign 

[10:53] <pugssvn> r30857 | pmurias++ | [mildew] all the pretty print the ast backends are handled by DumpAST 

[10:54] <pugssvn> r30858 | pmurias++ | [mildew] add missing file for the m0ld frontend 

[10:54] <pugssvn> r30859 | pmurias++ | [mildew] modify the way backends are handled 

[11:13] *** Sarten-X joined
[11:26] *** sorear left
[11:40] *** am0c left
[11:52] *** sorear joined
[11:55] *** am0c joined
[11:55] *** am0c left
[11:58] <cognominal> timtoady,  can hyperwhatever closures be call to self?  I know, it is designed for multidimensional stuff but I am still living in flatland and see no harm here

[12:00] *** envi^home joined
[12:00] * jnthn just noticed the cheating versions of the + and - for Whatever were left in operators.pm

[12:01] * jnthn removes 'em.

[12:01] <colomon> my beautiful little ops, removed... sob.  ;)

[12:01] <jnthn> moritz_: my $x = *; (* + 2) # that should not build a closure.

[12:01] *** kst` left
[12:01] <jnthn> gah

[12:01] <jnthn> moritz_: my $x = *; ($x + 2) # that should not build a closure.

[12:01] <colomon> you mean ($x + 2)

[12:01] <jnthn> that one :-)

[12:02] <jnthn> It's syntactic.

[12:02] <moritz_> wfm

[12:02] *** takadonet joined
[12:02] <jnthn> colomon: Yeah, I was like...huh...why'd it build it...then remembered...oh, those cheats. :-)

[12:02] <pugssvn> r30860 | pmurias++ | [mildew] update dependencies 

[12:02] <pugssvn> r30861 | pmurias++ | [mildew] fix bug with simplified, add debuging aids to bin/mildew 

[12:02] <takadonet> morning all

[12:02] <moritz_> as long as (* + 3) * 4 builds one eventuallye

[12:02] <moritz_> s/e$//

[12:02] <jnthn> It does now.

[12:02] <jnthn> rakudo: say ((* + 3) * 4).WHAT

[12:02] <moritz_> rakudo: say ((* + 3) * 4).(2)

[12:02] <cognominal> rakudo: say (* * *).(*,*)  # what it does today?

[12:02] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[12:03] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[12:03] *** krr joined
[12:03] <p6eval> rakudo 982e8e: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[12:03] <jnthn> Ah, OK.

[12:03] <jnthn> Oh, hmm

[12:03] *** pmurias left
[12:03] <jnthn> cognominal: That makes little sense.

[12:03] <cognominal> I know :)

[12:03] <moritz_> it multiplies to Whatever-stars

[12:04] <moritz_> and currently probably curries over *.Numeric

[12:04] <cognominal> but it compiles, I am just curious how it blows in the dispatcher

[12:04] <moritz_> whic returns a Block

[12:04] <colomon> "curries over *.Numeric" ?

[12:04] <moritz_> infix:<*>(Any, Any)   calls .Numeric on its arguments

[12:04] <moritz_> that produces two closures

[12:04] <moritz_> and it then tries to multiply those two closures

[12:04] <cognominal> jnthn, I am just like that, I enjoy breaking my toys.

[12:05] <colomon> moritz_: errr....

[12:05] <moritz_> ending up with multiplying two closures

[12:05] <moritz_> rakudo: say (*.Numeric).WHAT

[12:05] <p6eval> rakudo 982e8e: OUTPUT«Block()␤»

[12:05] <moritz_> rakudo: my $x = *; say ($x.Numeric).WHAT

[12:05] <p6eval> rakudo 982e8e: OUTPUT«Use of uninitalized value in numeric context␤Int()␤»

[12:05] <colomon> yes, but in this case that's the equivalent of the second one there.

[12:05] <moritz_> hm, no

[12:05] <moritz_> ok, I retract my explanation

[12:06] <colomon> rakudo: my $x = *; say $x * $x

[12:06] *** XaeroOne left
[12:06] <p6eval> rakudo 982e8e: OUTPUT«Use of uninitalized value in numeric context␤Use of uninitalized value in numeric context␤0␤»

[12:08] <pmichaud> good morning, #perl6

[12:08] <jnthn> o/ pmichaud 

[12:08] *** betterworld left
[12:08] <cognominal> o/ pmichaud

[12:08] <moritz_> \o

[12:10] <takadonet> o/

[12:11] <colomon> \o

[12:12] <masak> o/

[12:12] <moritz_> .oO( we make quite a funny picture here in #perl6 :-)

[12:16] *** XaeroOne joined
[12:16] <masak> build fail: http://gist.github.com/415736

[12:17] <masak> that's latest Rakudo on latest Parrot, not using --gen-parrot.

[12:17] <masak> note the suspicious warning on line 5.

[12:18] <masak> any ideas what's wrong? it worked yesterday.

[12:18] <moritz_> ops_massacre branch merge?

[12:19] <masak> if that's in between, then yes, probably.

[12:19] <masak> building with recommended Parrot now.

[12:20] <moritz_> looks like a typical not-yet-loaded dynop

[12:20] *** uniejo left
[12:22] <jnthn> Aye, almost certainly that

[12:22] <pmichaud> probably the file io dynops

[12:23] * moritz_ investigates

[12:23] <moritz_> hopefully fixable with a few .loadlib lines

[12:23] <jnthn> moritz_: If that's all it is, then most probably yes. :-)

[12:29] <masak> the build works with Parrot r47022.

[12:34] <masak> rakudo: my class A {}; our class B is A {} # via jnthn++

[12:34] <moritz_> weird

[12:34] <p6eval> rakudo 982e8e: OUTPUT«Lexical 'A' not found␤current instr.: 'perl6;B;!class_init_11' pc 476 (EVAL_1:212)␤»

[12:34] * masak submits rakudobug

[12:34] <moritz_> I've added a .loadlib 'io_ops'

[12:34] <moritz_> and I still get syntax errors for printerr

[12:35] <moritz_> but when I write a small pir file that only consist of that .loadlib, a .main routine and printerr 'foo', it works like a charm

[12:36] *** drbean_ left
[12:39] <jnthn> Where did you add the .loadlib?

[12:40] <moritz_> in src/Perl6/Compiler.pir

[12:40] <moritz_> the problem is that the .loadlib fails, silently of course

[12:40] *** Ross^ left
[12:40] <moritz_> I guess the dynops aren't installed

[12:41] *** XaeroOne left
[12:41] *** XaeroOne joined
[12:46] <jnthn> sarcasm win :-)

[12:46] <jnthn> moritz_++

[12:46] <moritz_> :-)

[12:47] <moritz_> actually I tried to resists, at first

[12:47] <jnthn> ;-)

[12:47] <moritz_> and then decided that it's such a WTF to fail silently that it warrants a bit evilness

[12:47] <jnthn> Yeah, I've been tripped up by that too many times too, and surely mentioned it before.

[12:47] <jnthn> Long-standing fail.

[12:48] *** jferrero left
[12:49] <pmichaud> TT #437

[12:49] <jnthn> "not added to ... <file with generated in its name>" o.O

[12:50] <jnthn> Oh joy, $dayjob today is tracking down where a character encoding mixup is happening.

[12:50] <moritz_> guess who reported it back then :-) (the loadlib thing..)

[12:55] *** Ross joined
[12:55] *** rgrau joined
[12:56] *** ruoso joined
[12:57] <pmichaud> moritz_: yes, I noticed that also (TT #437 author :-)

[12:59] *** gbacon joined
[12:59] * pmichaud is once again annoyed at how many ways we have to introspect information in Parrot

[12:59] <pmichaud> and worse, there's little consistency

[12:59] <pmichaud> actually, I'll take the rant to #parrot :-)

[13:00] *** Xaero joined
[13:02] *** XaeroOne left
[13:04] <jnthn> pmichaud: It'd only be preaching to the choir here. :-) :-)

[13:05] *** Xaero left
[13:05] *** XaeroOne joined
[13:07] *** christine left
[13:07] *** christine joined
[13:14] *** ejs left
[13:15] *** ash__ left
[13:19] *** [mark] left
[13:20] *** XaeroOne left
[13:20] *** XaeroOne joined
[13:25] *** kel__ left
[13:27] *** [Coke] joined
[13:31] *** Guest9589 left
[13:37] *** Xaero joined
[13:37] *** XaeroOne left
[13:39] *** am0c joined
[13:41] *** plainhao joined
[13:47] *** ruoso left
[13:49] *** patspam joined
[13:53] <dalek> rakudo: e40ee42 | Coke++ |  (2 files):

[13:53] <dalek> rakudo: track the move of some ops to dynamic op libraries, bumping parrot revision.

[13:53] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e40ee425f7db25a12b671e2aac283386d1f3116c

[13:56] *** drbean joined
[13:56] *** alester joined
[14:02] *** ruoso joined
[14:04] *** JimmyZ joined
[14:08] <ajs> As promised, I've thrown my URI module up on github. It's currently floating in /ajslib in a clone of rakudo at http://github.com/ajs/rakudo/tree/ajslib-URI/ajslib/

[14:08] *** PerlJam is now known as rakudo

[14:09] <ajs> Should I be writing docs in POD or is there something that can read P6 POD yet?

[14:09] *** rakudo is now known as PerlJam

[14:09] <moritz_> nothing that can read the P6 according to newest spec

[14:09] <ajs> ok thanks

[14:09] <jnthn> ajs: Nice! :-)

[14:10] <moritz_> method scheme_path() { gather do { take <URI scheme> } }

[14:11] *** SmokeMachine joined
[14:11] <ajs> yes?

[14:11] <moritz_> that could just be   method scheme_path() { return |<URI scheme> }

[14:11] <moritz_> or without the vertical bar probably

[14:12] <moritz_> I don't quite understand why you want to return a list of two strings, though

[14:12] <ajs> it's that way for consistency with other methods that return a list of multiple lists. When I tried return [ <a b c>, <d e f> ] it got flattened

[14:12] <moritz_> ah

[14:12] <ajs> So it's not the right long-term solution

[14:13] <moritz_> just looks curious :-)

[14:13] <ajs> it does ineed!

[14:13] <ajs> indeed even

[14:13] <ajs> anyway. off to the paying job. Docs will be written tonight

[14:14] <moritz_> ajs++

[14:15] *** BrowserUk joined
[14:28] *** kaare joined
[14:29] *** kaare is now known as Guest37008

[14:30] *** JimmyZ_ joined
[14:33] *** JimmyZ left
[14:33] *** JimmyZ_ is now known as JimmyZ

[14:36] *** takadonet left
[14:43] <diakopter> moritz_: 

[14:43] <diakopter> _ilbot2 to #rakudosketch ?

[14:47] *** plobsing joined
[14:53] <masak> sorear++ # your work on viv alone makes backlogging worth it!

[15:02] *** betterworld joined
[15:02] *** plobsing left
[15:02] *** am0c left
[15:09] *** JimmyZ left
[15:14] <masak> I find the meme that one programming language or other can inflict irrevocable mental damage to a programmer seriously quaint, even outdated. what's potentially damaging is sticking to one language, any language, and not exploring other languages at all.

[15:15] <mathw> Yes

[15:15] <mathw> I don't believe I've been scarred for life by starting off in BASIC

[15:15] <mathw> Admittedly that might be because I deliberately abandoned everything I learned about program structure, but...

[15:16] <mathw> The trick to avoiding that kind of thing is to learn the idioms for every new language and paradigm

[15:16] <jnthn> I started out with BASIC too :-)

[15:16] <masak> me too.

[15:16] <jnthn> Maybe we're all just damaged in the same way then. ;-)

[15:16] <mathw> lol

[15:16] <mathw> But I successfully learned Haskell...

[15:16] <mathw> which is about as un-BASIC as you can get

[15:16] <masak> jnthn: if so, I'm blissfully proud of being damaged.

[15:17] <mathw> well except maybe Prolog, because a world where your code can all run backwards is definitely for the deranged

[15:17] <masak> actually, I feel I learned a lot from BASIC. it was mostly Turbo Basic and QBasic, so I guess it's not the flavor Dijkstra raged against.

[15:17] <mathw> no

[15:17] <masak> fairly little PEEKing and POKEing, overall.

[15:17] *** am0c joined
[15:17] <mathw> I did BBC BASIC, which had named procedures and functions

[15:17] *** ash__ joined
[15:18] <mathw> so I very seldom used GOTO or GOSUB after I learned about them

[15:18] <masak> mathw: regexps are no less deranged than Prolog.

[15:18] <mathw> masak: true

[15:18] <mathw> I didn't say Prolog was *bad* :)

[15:18] <mathw> It's quite fun, actually

[15:18] *** ash__ left
[15:19] <mathw> I used to love how you can use a list append to generate all possible splits of a list

[15:19] <mathw> evaluation by unification

[15:19] <jnthn> My primary school had a BBC micro, so BBC BASIC was there I started. A little later, my family got a PC at home, and I hacked in QBasic for a while, and later Visual Basic. Then we Got The Internetz At Home (they were small in those days ;-)) and I discovered Perl...and C.

[15:19] <mathw> and non-deterministic results

[15:19] <mathw> lots of fun

[15:19] <masak> mathw: that's one reason I'm looking forward to 'temp' and 'let', by the way. they will unleash the last little part of insanity in regex control flow :P

[15:19] *** Xaero left
[15:20] * mathw did BBC BASIC -> FORTRAN -> Pascal -> Object Pascal -> C -> C++ -> Java -> PHP -> Perl -> Haskell -> Prolog -> C# -> Python -> Boo, but would no longer claim to be competent in all of them

[15:21] <mathw> And I'm only really fluent with C++ and Perl these days

[15:21] <mathw> Must do more Haskell

[15:22] <mathw> Oh I dabbled in QBasic and Visual Basic at one point as well

[15:22] <mathw> And even some JavaScript

[15:22] * mathw -> home

[15:24] *** justatheory joined
[15:26] * masak did BASIC -> Pascal -> crappy C++ -> Java -> Perl -> Haskell. or something. I'm not proficient in many of those.

[15:29] <jnthn> I had a Pascal and a C book in each hand at the bookshop and could only afford one, and I thought Pascal syntax looked ugly, so I got the C one. :-)

[15:30] <masak> lol

[15:30] <jnthn> C has turned out to be useful. :-)

[15:31] * isBEKaml did BASIC so long ago that he can't remember anything more than REM, LET and PRINT. :)

[15:32] * [Coke] misses playing WUMPUS.BAS on parrot.

[15:32] * PerlJam taught himself C by translating C programs back and forth

[15:32] <masak> isBEKaml: that's complete in some sense, I guess. :)

[15:32] <jnthn> QBasic had a lovely PLAY built-in where you could describe musical notes and it'd play little tunes. :-)

[15:32] <PerlJam> (from/to pascal)

[15:33] <masak> jnthn: Turbo Basic too!

[15:33] <jnthn> Oh, cool!

[15:33] <jnthn> .oO( Perl 6 modules I should(n't?) write )

[15:34] *** ruoso left
[15:35] <isBEKaml> masak: lol, when I saw Wargames recently, the odd teletype fonts and free password texts somehow reminded of my days with BASIC and BLOCK LETTERS. :)

[15:36] <masak> I agree with _why. it's somewhat of a lost age, that created a lot of intrepid programmers for the 'right reasons'. http://www.advogato.org/article/671.html

[15:38] *** rgrau[1] left
[15:45] *** BrowserUk left
[15:47] *** ajs1 joined
[15:50] <cognominal> jnthn, seeing this, would you have learnt FORTH :  http://vividpicture.com/aleks/atari/forth.jpg

[15:50] <cognominal> Zardoz FORTH :)

[15:51] *** ruoso joined
[15:54] *** XaeroOne joined
[15:57] <jnthn> cognominal: Phwoar!

[15:59] <TimToady> rakudo: say 2 [*] 3;

[15:59] <p6eval> rakudo e40ee4: OUTPUT«Confused at line 11, near "say 2 [*] "␤current instr.: 'perl6;HLL;Grammar;panic' pc 528 (ext/nqp-rx/src/stage0/HLL-s0.pir:348)␤»

[15:59] <TimToady> that would be LHF for anyone with parser skilz

[15:59] <TimToady> then we could write * [*] *

[16:01] <masak> what was the semantics of `2 [*] 3` again? I only remember it was something I didn't expect.

[16:01] <jnthn> masak: Same as 2 * 3 :-)

[16:02] <masak> oh right.

[16:02] <diakopter> I started out in BASIC too

[16:02] <masak> well, in the case of 3 being a list of one element, it does what I expect :P

[16:02] *** meppl joined
[16:02] <masak> anyone here didn't start out in BASIC?

[16:02] <isBEKaml> But, isn't [*] an infix on a list  ? 

[16:03] <diakopter> QBASIC and then TI-BASIC

[16:03] <TimToady> S03:4580 is stated very carefully

[16:03] <allbery_b> TRS-80 Level II BASIC, shortly followed by Z80 assembly language :)

[16:04] <allbery_b> <-- cruft

[16:05] <TimToady> isBEKaml: to answer your question specifically, only in term position

[16:05] <TimToady> and term position never expects infixes

[16:05] <TimToady> so the [op] form is special there

[16:06] <TimToady> and you can't drop the [] there because S03:4582 is only about where an infix is expected

[16:07] *** REPLeffect joined
[16:07] <TimToady> in essence, [op] is a no-op metaoperator, but we give it reduction meaning if used where a term is expected

[16:08] <isBEKaml> TimToady: I'm looking S03, meta ops more carefully now. So, @a [op] @b, we need brackets. But when doing $a [op] $b, we may _optionally_ use brackets ? 

[16:08] <TimToady> no

[16:08] *** XaeroOne left
[16:08] <TimToady> it's always optional in infix position

[16:09] <TimToady> it's only required if you use it as a listop

[16:09] <cognominal> LHF?

[16:09] <cognominal> Left Handed Form?

[16:09] <TimToady> Low Hanging Fruit

[16:09] <cognominal> :)

[16:10] <TimToady> so [] is required in [*] 1..$n

[16:10] <TimToady> because there's nothing before it to make it expect an infix

[16:11] <isBEKaml> TimToady: ah, i was wrong in using @a [op] @b, it should have been [op] @b. TimToady++

[16:11] <allbery_b> btw, the scariest anti-FORTH argument I've ever seen was the source code to Conference Tree :)

[16:11] *** Su-Shee joined
[16:17] <diakopter> masak: did you see I got buf8/16/32/64 working

[16:18] <diakopter> now they just need an api

[16:18] <masak> diakopter: I did. cool! let's talk more about that.

[16:18] <diakopter> they can grow only to half your available contiguous ram, since resizing is done by copying

[16:19] <diakopter> perlesquel: my $b = buf8.new(); $b[100000000] = 1; say($b.Count); say($b.Size);

[16:19] <p6eval> perlesquel: OUTPUT«100000001␤134217728␤real 2.83␤user 1.61␤sys 0.13␤»

[16:20] <diakopter> bleh

[16:20] *** gbacon left
[16:22] <TimToady> is there any support for uint2 strings for compact genomics?

[16:23] <TimToady> .oO(EnumStr)

[16:24] <TimToady> well, more likely Buf[DNA-Base]

[16:25] <diakopter> not yet, but it's a smoShiftiness

[16:25] <diakopter> perlesque: my $b = buf8.new(); $b[100000000] = 256; $b[99999999] = 256; say($b.Count); say($b.Size); say($b[99999999])

[16:25] <masak> sometimes you'd like to encode any()-junctions of bases too, because of insufficient information.

[16:25] <sorear> TimToady: did you get my pm on elsif?

[16:25] <p6eval> perlesque: OUTPUT«System.InvalidCastException: Cannot convert type from 'System.Int32' to 'System.Byte'␤  at TriAxis.RunSharp.Conversion+Invalid.Emit (TriAxis.RunSharp.CodeGen g, System.Type from, System.Type to) [0x00000] in <filename unknown>:0 ␤  at TriAxis.RunSharp.CodeGen.Convert

[16:25] <p6eval> ..(TriAxis.RunSh…

[16:25] <TimToady> yes

[16:25] *** BrowserUk joined
[16:26] <diakopter> hm, I wonder why it could convert the int 0

[16:26] <diakopter> maybe it's special-cased

[16:26] <diakopter> or int 1

[16:26] <diakopter> weird.

[16:26] *** cdarroch joined
[16:26] *** cdarroch left
[16:26] *** cdarroch joined
[16:26] <diakopter> System.Byte is uint8

[16:26] <mberends> perlesque: my $b = buf8.new(); $b[100000000] = 255; $b[99999999] = 255; say($b.Count); say($b.Size); say($b[99999999])

[16:27] <p6eval> perlesque: OUTPUT«100000001␤134217728␤255␤»

[16:27] <diakopter> oh lol.

[16:27] <diakopter> oh yeah. runsharp does find the smallest in which it can fit it

[16:27] <TimToady> lol pounds of fun  # South Pacific allusion

[16:28] <diakopter> mberends++ mberends++ mberends++ mberends++ mberends++ mberends++ mberends++ mberends++ 

[16:28] <mberends> heh, just for an off-by-one

[16:29] <diakopter> I seem to have a lot of those.

[16:29] <TimToady> that's because you're pushing the boundary conditions

[16:32] <masak> :P

[16:32] * diakopter thinks about uint1 and uint2

[16:40] <diakopter> perlesque: my $bb = System::Collections::Specialized::BitVector32.new(0); my $s1 = System::Collections::Specialized::BitVector32.CreateSection(6); my $s2 = System::Collections::Specialized::BitVector32.CreateSection(3, $s1); $bb[$s2] = 3; say($bb[$s1]); say($bb[$s2]); say($bb); 

[16:40] <p6eval> perlesque: OUTPUT«0␤3␤BitVector32{00000000000000000000000000011000}␤»

[16:43] <diakopter> masak: BitVector32 can be wrapped by a class that can set up a compact array of BitVector32s

[16:44] *** wilx joined
[16:44] <diakopter> to store uint1 and uint2 compactly

[16:44] <masak> diakopter: ok; nice.

[16:44] *** pmurias joined
[16:44] <diakopter> pmurias: say smth

[16:45] <diakopter> pmurias: hi

[16:46] <pmurias> diakopter: hi

[16:46] <phenny> pmurias: 26 May 17:06Z <diakopter> tell pmurias no I don't know what's wrong with that bug; I recently slowed down my rate of deluding myself into thinking I have more round tuits than I actually have...

[16:46] <phenny> pmurias: 26 May 23:53Z <diakopter> tell pmurias I looked at http://paste.lisp.org/display/100307 and it doesn't work just b/c of the non-working expression parser - my $poss = self.positionals; $poss.Add($pos); # works

[16:46] <phenny> pmurias: 00:10Z <diakopter> tell pmurias I made it so return type is optional on constructors

[16:46] <phenny> pmurias: 04:21Z <diakopter> tell pmurias try this:  my $e = sub (FrameBase $f-->int) { say(1); longjmp($f); say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[16:46] <pmurias> diakopter: when adding features you should add tests that check they work

[16:47] <diakopter> yeah yeah :P

[16:47] <diakopter> oh... do they not work?

[16:48] <pmurias> that we will see

[16:48] <diakopter> heh

[16:50] *** dj_goku left
[16:50] <pmurias> untested things generally don't

[16:50] <diakopter> pmurias: well, you'll need to infer the semantics of _cc and longjmp, as I've written them

[16:50] <diakopter> perlesquel: my $e = sub (FrameBase $f-->int) { say(1); longjmp($f); say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[16:50] <p6eval> perlesquel: OUTPUT«1␤4␤real 0.05␤user 0.05␤sys 0.01␤»

[16:52] <pmurias> longjump?

[16:53] *** PZt joined
[16:53] <pmurias> i'm not sure longjump is the right name for the thing that invokes the continuation

[16:53] <pmurias> diakopter: would it be difficult to use $f()?

[16:54] <diakopter> hrm

[16:54] <diakopter> I suppose not

[16:54] <diakopter> $f would have to be a FrameBase, obviously

[16:54] <pmurias> longjump is parsed as a function call?

[16:54] <TimToady> but $f() looks like it returns

[16:55] <TimToady> if the semantics are really $f.goto

[16:55] <diakopter> yes

[16:55] <diakopter> goto $f   would work too

[16:55] <TimToady> then $f() would be a disservice to the reader

[16:56] <diakopter> since the parser is type-checking as it parses, it can do all sorts of fancy analysis like that

[16:56] *** bluescreen joined
[16:57] *** bluescreen is now known as Guest17566

[16:57] <diakopter> $f.goto()   could work too

[16:58] * diakopter waits for consensus

[16:59] <pmurias> $f.goto seems ok

[16:59] *** ruoso left
[17:00] <diakopter> it would need "special-cased/formed" in the parser (just like longjmp), but that's ok

[17:00] <TimToady> then prefix is probably slightly preferred

[17:00] <diakopter> goto $f  ?

[17:00] <TimToady> replace_my_reality_with $f

[17:01] <TimToady> :)

[17:01] <TimToady> really $f

[17:01] <diakopter> I tried to think through implementing an iterator using such continuations, and my brain got all squiggly

[17:01] <TimToady> backtrack $f

[17:02] <diakopter> it'd be much easier to just use closures as state machines.

[17:02] <pmurias> invoke-continuation $f

[17:02] *** TiMBuS left
[17:02] <TimToady> continue $f

[17:02] <sorear> I /love/ the 25 second turnaround with ./viv -5 --thaw STD.store

[17:03] <TimToady> \o/

[17:03] * diakopter curious how big is STD.store

[17:03] <pmurias> sorear: that skips the parsing?

[17:03] <sorear> diakopter: 11MB

[17:03] <sorear> pmurias: yes

[17:03] <diakopter> cool

[17:03] <masak> enter $f

[17:04] <TimToady> I-mean't $f

[17:04] <diakopter> I like goto $f  since it's a "non-local goto"

[17:04] <TimToady> er, s/'//

[17:04] <isBEKaml> rakudo: say (* * 3 * 4).(42); 

[17:04] <p6eval> rakudo e40ee4: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[17:04] <pugssvn> r30862 | sorear++ | [viv] Kill $self->SUPER::re_ast in favor of RE constructors, some smart. 

[17:04] <diakopter> though backtrack connotes, too. also  fallback

[17:04] <TimToady> goto $f seems fine to me

[17:05] <masak> TimToady: do you really have an "n't" button? where is it?

[17:05] *** Chillance joined
[17:05] <TimToady> actually, I have to type a sequence to get that character

[17:06] <masak> I think I know less from reading that answer :P

[17:06] <diakopter> ooo negative communication

[17:07] <TimToady> your reality has been replaced with a matrix

[17:07] <allbery_b> finger macros suck :)

[17:07] <TimToady> :)

[17:07] <TimToady> for some reason I find it very hard to type the word "per"

[17:09] <masak> just type 'superfluous' and trim the word down. :)

[17:09] <TimToady> yes, but that l doesn't seem to want to trim

[17:10] <pugssvn> r30863 | sorear++ | [viv] NIH Carp::Always in a dynamic scope to avoid the syntax error problems 

[17:10] <allbery_b> .oO { ltrim() doesn't operate on the right }

[17:11] *** dakkar left
[17:11] <TimToady> rofl

[17:11] <TimToady> that was ofl

[17:12] <diakopter> lofl

[17:12] <diakopter> (but)

[17:13] <pugssvn> r30864 | sorear++ | [viv] Fix previous commit 

[17:20] <TimToady> the DM has decided you're really lofl good

[17:21] *** isBEKaml left
[17:26] <diakopter> pmurias: ok I changed it to use  goto $f  syntax

[17:28] * [Coke] ponders a meta-op sigil instead of bracing.

[17:29] <dalek> csmeta: r308 | diakopter++ | trunk/Sprixel/ (3 files):

[17:29] <dalek> csmeta: [perlesque] change continuation-continue syntax to use the goto prefix

[17:29] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=308

[17:29] <diakopter> perlesquel: my $e = sub (FrameBase $f-->int) { say(1); goto $f; say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[17:29] <p6eval> perlesquel: OUTPUT«1␤4␤real 0.05␤user 0.05␤sys 0.00␤»

[17:34] <pugssvn> r30865 | sorear++ | [viv] Implement $var in regexes 

[17:34] <sorear> down to 91

[17:35] <masak> \o/

[17:38] *** patrickas joined
[17:41] <[Coke]> 91..?

[17:41] <diakopter> 91 vast nodes remaining?

[17:42] <sorear> yes

[17:42] <sorear> not 91 *types*, but 91 untranslatable nodes in STD.pm6

[17:43] <sorear> TimToady: for your bug queue - $<foo>=<bar> is misparsed, the RHS is left *as text* in the AST

[17:43] <[Coke]> vast?

[17:43] <[Coke]> five-ast?

[17:43] <sorear> viv's AST for STD parses

[17:44] <[Coke]> danke. (I had googled but got nothing. =-)

[17:45] <masak> rakudo: class A { has @.contents handles <elems> }; say A.new(:contents(1, 2, 3)).elems

[17:45] <p6eval> rakudo e40ee4: OUTPUT«1␤»

[17:45] * masak submits rakudobug

[17:46] *** gbacon joined
[17:47] <jnthn> masak: handles nyi

[17:47] <masak> it used to be i :(

[17:48] <masak> until further notice, I consider *all* regressions bugs.

[17:48] <masak> there is code out in the app cheese that uses handles.

[17:50] <masak> hm, perhaps an example with a method not already in Any would be better... :)

[17:51] <masak> rakudo: class A { has $str handles <uc> }; say A.new.uc

[17:51] <p6eval> rakudo e40ee4: OUTPUT«Method 'uc' not found for invocant of class 'A'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:53] <Tene> rakudo: say "foo".uc

[17:53] <p6eval> rakudo e40ee4: OUTPUT«FOO␤»

[17:53] <Tene> rakudo: class A { has $str handles <uc> }; say A.new(:str("omg cats")).uc

[17:53] <p6eval> rakudo e40ee4: OUTPUT«Method 'uc' not found for invocant of class 'A'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:53] <Tene> 'k

[17:54] *** envi^home left
[18:05] <diakopter> I blaughed http://diakopter.blogspot.com/2010/05/perlesque-obtains-reified-continuations.html

[18:05] *** ShaneC joined
[18:05] *** ShaneC left
[18:06] <masak> diakopter++ # blol!

[18:07] <pugssvn> r30866 | sorear++ | [viv] Implement :i 

[18:08] *** BrowserUk left
[18:08] *** BrowserUk joined
[18:08] <awwaiid> laughed because the last paragraph indicates that they implemented plain coroutines rather than fully reifiable continuations?

[18:08] <awwaiid> (er... blaught)

[18:09] <diakopter> oh :(

[18:09] <diakopter> they == me

[18:09] <awwaiid> well it sounds awefully cool anyway, don't get me wrong :)

[18:10] <diakopter> actually though, that's fixable, by creating a Continuation type that holds a FrameBase and an int representing the instruction pointer

[18:10] <diakopter> the locals in the stack frame are obviously still the same "lexpad" though

[18:10] <diakopter> hm, maybe I should do that

[18:12] <diakopter> awwaiid: there can be more than "instance" of a coroutine, right?

[18:13] <awwaiid> yes, many instances, but you can only use each one twice and you can't clone one to make another

[18:13] <awwaiid> er

[18:13] <awwaiid> you can only use each one once :)

[18:13] <awwaiid> each time you invoke it, it can get a little further, but when you re-invoke it it just does that -- gets further. no starting over.

[18:13] <diakopter> what would it mean to clone one?

[18:13] <pmurias> diakopter: how are the continuations in perlesque different from normal noes?

[18:14] <awwaiid> cloning would let you  "start over" at the same point in the continuation

[18:14] <diakopter> oh

[18:14] <diakopter> pmurias: b/c they're not cloned as awwaiid is describing

[18:14] <diakopter> they can be, though

[18:14] <TimToady> think of it as a fancy closure that, when you call it, also installs its dynamic scope

[18:15] <awwaiid> and hence clonable subroutines, in my view, are equivalent of normal (full) continuations

[18:15] <awwaiid> er, s/subroutines/coroutines/

[18:15] <awwaiid> man, typeo city today

[18:16] <pmurias> diakopter: forgot to backlog enought to find the blogpost

[18:16] <TimToady> but differs from $c = {...} closure insofar as $c only snapshots the lexical scope, not the dynamic scope

[18:16] <diakopter> .Instruction is already an accessible field of each FrameBase.  if I just add a Clone method (abstract/overriden) to FrameBase, I could make the cloning up to the user code

[18:16] <pugssvn> r30867 | pmurias++ | [mildew] expand test 

[18:16] <diakopter> the compiler can trivially generate each frame class' Clone method

[18:17] <pugssvn> r30868 | pmurias++ | [mildew] handle \n inside m0ld string literals 

[18:17] <awwaiid> sounds cool to me :)

[18:19] <diakopter> perlesque: my $e = sub (FrameBase $f-->int) { say(1); say('Instruction: ' ~ ($f.Instruction)); goto $f; say(2); return 1}; sub callcc(Callable[:(FrameBase-->int)] $func, FrameBase $frame --> int) { $func($frame); say(3); return 1 }; callcc($e, _cc); say(4);

[18:19] <p6eval> perlesque: OUTPUT«1␤Instruction: 3␤4␤»

[18:20] <diakopter> so, in order to capture a "full continuation", one would do: _cc.Clone()

[18:21] <diakopter> as far as the lexpad locals, reference types (word size slots) are copied trivially, and value types (word size or bigger) are block-copied trivially

[18:21] <diakopter> and of course the instruction pointer is copied

[18:22] <diakopter> also arguments

[18:22] <awwaiid> probably there is someone more into proper language who can advise you better than I on the way to say it, but yes, sounds good, especially the instruction pointer bit :)

[18:26] <diakopter> this also means that _cc can go back to being proper Perl 6, which was "frame"

[18:26] <diakopter> I think.

[18:27] <pugssvn> r30869 | pmurias++ | [mildew] converting an empty block to SSA form works 

[18:28] <pmurias> diakopter: seem to be exactly the same way we planned to implement full continuations on smop

[18:28] <pugssvn> r30870 | sorear++ | [viv] Implement :lang 

[18:28] <pmurias> * seems

[18:29] <sorear> 45...

[18:30] <sorear> pmurias: does smop run with the P6 stack on the C stack?

[18:36] * diakopter guesses so

[18:36] * diakopter but is not certain

[18:37] <pmurias> sorear: smops keeps it's own stack

[18:37] <pugssvn> r30871 | sorear++ | [viv] Implement :s and :!s 

[18:37] * sorear is confused how this "polymorphic eval" thing works

[18:38] <diakopter> pmurias: smop uses a trampoline?

[18:39] *** alester_ joined
[18:40] *** alester_ left
[18:40] *** alester left
[18:41] <diakopter> Edit:  awwaiid pointed out that these are coroutines, not full-blown continuations, since they aren't cloned.  So I'm adding to FrameBase an abstract .Clone() method that will be generated by the compiler, so that a cloned continuation can be restarted from where it was originally captured (or cloned again). :)

[18:42] *** alester joined
[18:43] *** eternaleye left
[18:44] <awwaiid> "since they aren't cloned" should be more like "since they aren't cloneable"

[18:44] <awwaiid> lovely

[18:47] <pmurias> diakopter: yes

[18:47] * moritz_ back

[18:51] *** plainhao left
[18:56] <pugssvn> r30872 | sorear++ | [viv] Implement () 

[18:56] <sorear> 10...

[18:58] *** IllvilJa joined
[18:59] *** wilx left
[18:59] *** Trashlord left
[18:59] *** wilx joined
[19:02] <patrickas> how do I get the current script name in perl6 ? 

[19:02] <moritz_> rakudo: say $*PROGRAM_NAME

[19:02] <p6eval> rakudo e40ee4: OUTPUT«/tmp/ItL7C63EYG␤»

[19:03] <patrickas> thanks moritz_!

[19:04] *** Trashlord joined
[19:05] <pugssvn> r30873 | sorear++ | [viv] Skip sigspace in ~ reassociation (this really wants to be done in the parser) 

[19:05] <sorear> 6...

[19:06] <sorear>     token special_variable:sym['$<'] {

[19:06] <sorear> TimToady: How does that parse?  The symbol is a Seq object?

[19:09] <TimToady> no, it's just exactly the same as :sym<$\<>

[19:09] <sjohnson> hi TimToady 

[19:10] <TimToady> or looking at the other way, all symbols are sequence objects, but most are degenerate sequences of 1

[19:10] <TimToady> a circumfix is either < ( ) > or ['(',')']

[19:10] <TimToady> but they mean the same thing

[19:11] *** stephenlb joined
[19:13] <sorear> I see

[19:17] <pugssvn> r30874 | sorear++ | [viv] Implement :sym['x'] form 

[19:18] <TimToady> we used to allow ('(',')') but :() is now reserved for sigs, so we avoid :sym() too

[19:20] <dalek> csmeta: r309 | diakopter++ | trunk/Sprixel/src/Grammar/Grammar.cs:

[19:20] <dalek> csmeta: [perlesque] implement barebones .Clone method generators

[19:20] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=309

[19:24] <pugssvn> r30875 | sorear++ | [viv] Implement < a b c > form 

[19:27] *** patrickas left
[19:29] <pugssvn> r30876 | sorear++ | [viv] Implement :r (wrongishly) 

[19:29] <sorear> ok, we're down to 1 die during STD.pm6 conversion

[19:29] <diakopter> whee!

[19:29] <sorear> and it's a STD misparse which I've already sent to TimToady

[19:30] <sorear> (<a>: <b> is treated as three atoms)

[19:30] <moritz_> this is Perl 6; workarounds are allowed :-)

[19:30] <masak> s/allowed/required/

[19:30] <diakopter> s/required/definitive/

[19:30] <masak> the place where theory meets practice has a high density of workarounds :)

[19:31] <sorear> the ratchet handling is rather confused too.  I need to refactor this

[19:32] <moritz_> what is <a>: <b> supposed to mean?

[19:32] <Su-Shee> new best practices concept: "programming by teasing" - work around features instead of actually using them. 

[19:33] <sorear> moritz_: don't allow backtracking into <a>

[19:33] <moritz_> sorear: and how is that different from <a> : <b> ?

[19:33] <masak> Su-Shee: it's worked on me :)

[19:33] <Su-Shee> masak: it'll found a totally new school and style. 

[19:33] <moritz_> "don't allow backtracking into anything on the left"?

[19:33] <sorear> moritz_: it's not

[19:33] <masak> teasism.

[19:33] <moritz_> so what's wrong with parsing it as three tokens?

[19:34] <sorear> : should parse like a quantifier

[19:34] <sorear> it's always attached to the atom on its immediate left

[19:34] <sorear> <a> <b> : <c>

[19:34] <sorear> : only affects <b>

[19:34] <moritz_> huh, I didn't know that

[19:34] <moritz_> so if <c> fails, <a> is allowed to backtrack?

[19:34] <Su-Shee> masak: also known as "feature foreplay".

[19:35] <sorear> yes

[19:35] * moritz_ recently wrote an email without using the letter "a". It was tough.

[19:35] <sorear> <a> <b> :: <c>  ~~   [<a> <b>]: <c>

[19:36] <moritz_> ah

[19:36] <masak> Su-Shee: feels more like 'feature diet'...

[19:36] <moritz_> has ::: a similarly nice equivalence?

[19:39] <Su-Shee> masak: which is essentially the same thing.. pleasure of anticipiation or feeding hunger by dieting.. so it's feature foreplay - sparing the joy of using the actual feature until the last moment. ;)

[19:39] <Su-Shee> (well, when it's actually there ;)

[19:39] <Su-Shee> (hence the name the joy of six. ;)

[19:40] <masak> this is an intriguing topic. I wish I had more to say about it. :)

[19:40] <Su-Shee> we leave the rest to the mind. ;)

[19:40] <masak> foreplay is mostly in the mind, so that's appropriate, I guess.

[19:41] <moritz_> Su-Shee: would you write a short manifesto for thejoyofsix.org? :-)

[19:41] <TimToady> well, :: really means to commit to this LTM match these days

[19:41] <masak> perhaps renaming the early adopter phase into 'the foreplay phase' would attract many more interested people... :>

[19:42] *** kst joined
[19:42] <moritz_> :-)

[19:42] <masak> but, alas, that too might be promising too much... :P

[19:43] <sorear> TimToady: oh?

[19:43] <masak> TimToady: does S05 reflect that?

[19:43] <diakopter> hm

[19:43] <moritz_> does that mean "if this LTM branch fails, the whole LTM fails"?

[19:44] <jnthn> masak: Shouold we produce a Swedish translation of "the joy of six"? ;-)

[19:45] <moritz_> and since LTM spans named rules transitively, can cause calling subrurles to fail immediately?

[19:45] <masak> jnthn: I see what you're alluding to. that's not a bug, it's a feature. :) us Swedes get to say 'sex' a lot more often than other people. :)

[19:46] <TimToady> moritz_: nod, nod

[19:46] <jnthn> masak: I've reached the point where I can count in Swedish and keep a straight face now. :-)

[19:47] <moritz_> jnthn: actually in German it's similar: 6 = sechs, but pronounced basically the same as "sex"

[19:47] <TimToady> moritz_: but it is not yet specced

[19:47] <moritz_> which is why I sometimes seem to say "Perl sex" :-)

[19:47] <masak> it's like that in Latin too.

[19:47] <Su-Shee> moritz_: how long? couple of sentences?

[19:47] <moritz_> Su-Shee: yes

[19:48] <Su-Shee> done if a few secs. ;)

[19:48] <TimToady> there's a placeholder ::> in my mind for the old 'then' interpretaion, but that is negotiable

[19:48] <TimToady> STD doesn't use it anywhere

[19:48] <sorear> ::> is in gimme5...

[19:49] <dalek> csmeta: r310 | diakopter++ | trunk/Sprixel/ (4 files):

[19:49] <dalek> csmeta: [perlesque] enable copying of locals & arguments for stack frames' generated

[19:49] <dalek> csmeta: .Clone methods

[19:49] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=310

[19:49] <TimToady> arguably, :: and ::: are a bit backwards from a scoping point of view, since :: will typically commit to more than just the current rule

[19:49] <TimToady> but it could also be less than

[19:49] <TimToady> from a huffman point of view, it's correct as it is

[19:50] <jnthn> masak: Closely related, my Swedish teacher informed me that nummer has a meaning besides "number" too. :-)

[19:50] <moritz_> isn't ::: mostly a fossile from pre-proto-rule times?

[19:50] <jnthn> At least in local dialect. :-)

[19:50] <[particle]> will prefix:[!] apply to :: and :::?

[19:50] <TimToady> no

[19:51] <[particle]> phew

[19:51] <moritz_> (or maybe I'm messing that up in mind)

[19:51] <TimToady> there are still times you might want to commit to the current rule

[19:51] <[particle]> oh, that could have been a moritz no, probably was.

[19:51] <jnthn> masak: I've since been told to use räknar to be on the safe side. :-)

[19:51] *** kloeri joined
[19:52] *** mquin joined
[19:52] *** mquin left
[19:52] <moritz_> STD.pm6 uses ::: only once (and mentions it another time in order to parse it)

[19:53] <masak> jnthn: 'nummer' is a slang euphemism, yes. but it seems slightly dated to me. 'räkna' is a verb, so you can't use it instead of the noun 'nummer'. :)

[19:54] <jnthn> masak: Aww.

[19:54] <jnthn> Can't believe I'm not being taught the shiny new euphenisms. :-)

[19:54] <masak> we can remedy that.

[19:55] <masak> just saying I don't hear 'nummer' that often in its non-safe meaning.

[19:55] <Su-Shee> moritz_: http://sushee.no-ip.org/joyofsix.txt first .. draft. ;)

[19:58] <masak> Su-Shee: I'm not tired of waiting. :) maybe rephrase it to something containing 'giddy with anticipation'? :)

[19:58] <dalek> csmeta: r311 | diakopter++ | trunk/Sprixel/src/Perlesque/Declarations.cs:

[19:58] <dalek> csmeta: [perlesque] clone named locals in stack frames' .Clone methods

[19:58] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=311

[19:59] <masak> Su-Shee: s/but just/than just by/

[19:59] <TimToady> sorear: test a patch to parse : as a quantifier

[20:00] <TimToady> with the added benefit of carping if there's no atom to the left

[20:00] <Su-Shee> masak: added/corrected :)

[20:00] <masak> Su-Shee: I like the general tone of the text. we need more playful stuff of this kind. Su-Shee++

[20:00] *** colomon left
[20:01] <masak> Su-Shee: two subsequent paragraphs start with 'But '. suggest changing sencond one to 'Granted, ' or 'You know, ' or 'Certainly, '. :)

[20:01] <Su-Shee> ah, good, yes.

[20:02] <masak> I wonder if the final line shouldn't be a footnote in small print on the site. just to get out of the http://www.xkcd.com/541/ dilemma :)

[20:03] <Su-Shee> "it's also true though that certain things just can't be ..." I've got now.

[20:03] <masak> worksforme.

[20:04] *** patspam1 joined
[20:05] <Su-Shee> I've recently started to work with a haskell book by o'reilly - they also know how to construct a good myth. ;) the foreword goes like this "well noone knew haskell but a few and they avoided success at all costs".. ;)

[20:06] * moritz_ saved a copy locally; will try to set up a website over the weekend

[20:06] <Su-Shee> moritz_: reload, moved the corrected version to the url.

[20:06] <diakopter> Su-Shee: so the hook is that the reader is being inducted into an elite society, an inner circle

[20:06] <masak> moritz_: release early, and the rest of us will help! :)

[20:07] <moritz_> masak: that's my hope

[20:07] <Su-Shee> diakopter: essentially yes. slackware does the same thing.

[20:07] <moritz_> masak: I'm not good designing websites, least of all joyful websites

[20:07] <moritz_> Su-Shee: which book? "Real world haskell?"

[20:07] <Su-Shee> if perl always gets the highest level of "users satisfied with their programming language", slackware gets the same for distributions

[20:07] <Su-Shee> moritz_: yes.

[20:08] *** IllvilJa left
[20:08] <moritz_> I have that at home too, somehow got distracted after chapter 4 or so

[20:08] <moritz_> but I do plan to read the rest of it too

[20:08] <Su-Shee> it's a really good book. more dense and detailed than "practical lisp" but the same approach.

[20:09] <moritz_> and one day I'll beat GHC's type checker, and actually write a useful haskell program that *runs*

[20:09] <Su-Shee> the haskell book also got the mixture of high level academics "that's the proper way" and real world every-day coding and fun right.

[20:09] <moritz_> agreed (from what I've read so far)

[20:10] <Su-Shee> I'm still somewhat sad that pugs went to sleep. 

[20:10] <Tene> Su-Shee: sad enough for you to work on it?

[20:10] <Su-Shee> Tene: I would if I knew even the slightest bit haskell. (hence the book.)

[20:12] <Su-Shee> also, work is in my way. I managed to write exactly one class in 5 months. for a presentation as a comparison to moose.

[20:14] *** Guest17566 left
[20:14] *** SmokeMachine left
[20:14] <pugssvn> r30877 | lwall++ | [STD] parse : as a quantmod requiring previous atom, but give different error if missing 

[20:15] <masak> for what it's worth, I've also been thinking about reviving Pugs. but presently my Haskell-fu is too weak.

[20:15] <TimToady> O'reilly should start a new series: Haskell Feet First

[20:16] <[particle]> masak: do you need more things to do??!?!!

[20:16] <diakopter> Perl 6 Bowels First

[20:17] <masak> [particle]: no. :)

[20:17] <Su-Shee> moritz_: oh, also at least one perl 6 special interest subject now got its title, I'd say: "safer six" (perl 6 security ;)

[20:18] <Tene> masak: why thinking about reviving pugs exactly?

[20:18] <TimToady> $ six

[20:18] <TimToady> The program 'six' is currently not installed.  You can install it by typing:

[20:18] <TimToady> sudo apt-get install gambc

[20:18] <TimToady> aww

[20:18] <[particle]> بيرل 6 الذيل الأول

[20:19] <masak> Tene: it was once the furthest-along implementation. if it were active again, it might grow to be an equal to Rakudo in some respects.

[20:19] <diakopter> awwaiid: I finished .Clone, it seems.

[20:19] <TimToady> tell me that doesn't say Kama Sutra...

[20:20] <masak> Su-Shee: there's also hobby programming, in the form of 'casual six'...

[20:20] <Su-Shee> masak: *hahaha* :)

[20:20] <[particle]> perl 6 tail first

[20:20] <Su-Shee> "perl 6 books? yeah right over there in the adult section.." ;)

[20:21] <TimToady> malware is of course sixual abuse

[20:21] <Su-Shee> *hehehe* :)

[20:21] <masak> "Perl 6 took long to get there, but what a finish!"

[20:22] * diakopter about to deop everyone

[20:23] <dalek> csmeta: r312 | diakopter++ | trunk/Sprixel/src/Grammar/Grammar.cs:

[20:23] <dalek> csmeta: [perlesque] finish Continuation (FrameBase)'s .Clone method (for full

[20:23] <dalek> csmeta: continuation support as well as coroutines).

[20:23] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=312

[20:23] <jnthn> "Perl 6 - it's coming!"

[20:24] <jnthn> .oO( ...I almost submitted a talk with a title like that... )

[20:24] <Su-Shee> .oO(we're never ever going to make it into schools.. ;)

[20:24] * jnthn founds a Perl 6 training company called SixEd

[20:25] <Tene> Title for a talk about migrating to p6, "Trans-sixual Perl"

[20:25] <Tene> and then you can work in "pre-op" and "post-op"

[20:25] <masak> lots of six-related puns today. almost as if there has been something pent-up... :)

[20:25] <TimToady> s/proto/toys/

[20:25] <diakopter> std: superset superset of superset

[20:25] <p6eval> std 30876: OUTPUT«===SORRY!===␤Undeclared routines:␤     'of' used at line 1␤      'superset' used at line 1,1,1␤Check failed␤FAILED 00:01 114m␤»

[20:25] <Su-Shee> working with perl5 in 6 is metro-six then? 

[20:25] *** Guest17566 joined
[20:26] <masak> Guest37008: you wouldn't believe what we're talking about!

[20:26] <masak> oops, wrong guest.

[20:26] <diakopter> as long as you're home bysix

[20:26] <TimToady> you have a six sense of humor

[20:26] <jnthn> Guest17566: Ignore masak, it's just a bot

[20:26] <jnthn> ;-)

[20:27] <Su-Shee> *hihi* :)

[20:27] <masak> Guest17566: I am a bot. but I'm still nicer than purl.

[20:27] *** Ross left
[20:27] <saaki> heh

[20:29] <moritz_> lol

[20:29] <moritz_> at least in your safe mode, masak

[20:29] <masak> ;)

[20:30] <diakopter> I was gonna say. is there a CPAN distribution named protection?

[20:31] <masak> moritz_: you reminded me on this: http://bash.org/?10739

[20:31] <masak> s/on/of/

[20:32] *** ethel joined
[20:37] *** SmokeMachine joined
[20:44] <masak> so who should I talk to if I would like dalek to publish commits to the 'buf' branch of Rakudo? Infinoid? diakopter?

[20:46] <jnthn> masak: How long lived will that branch be?

[20:46] <jnthn> masak: That is, will there be another one shortly after this one is merged in with a different name?

[20:47] *** jhuni left
[20:47] <masak> jnthn: quite probably. hm.

[20:48] <jnthn> Could always just get all commits on any branch reported.

[20:48] <Tene> you could just keep re-using the same names.

[20:48] <diakopter>  masak me

[20:48] <diakopter> masak: me

[20:48] * Tene masaks diakopter.

[20:49] <diakopter> OUCH

[20:49] <masak> OUCH

[20:49] <masak> diakopter: is it difficult? can I help?

[20:49] <diakopter> no I'm almost finished.

[20:49] <masak> \o/

[20:49] *** mikehh_ joined
[20:50] <[Coke]> http://nopaste.snit.ch/20667

[20:50] <masak> Tene: nuking the branch and creating a new one is fine, unless there are people downstream pulling.

[20:50] <[Coke]> ww.

[20:50] <masak> [Coke]: thanks!

[20:50] <[Coke]> de nada.

[20:53] <jnthn> [Coke]: Isn't there some string builder PMC that'd make that a bunch more efficient?

[20:53] <[Coke]> jnthn: already covered in #parrot.

[20:54] <masak> [Coke]++ jnthn++

[20:54] <[Coke]> just s/String/StringBuilder/, then $S0 = sb at the end.

[20:54] *** mikehh_ is now known as mikehh

[20:54] <jnthn> OK, great. :-)

[20:54] *** dalek joined
[20:55] <[Coke]> dalek on parrot just reports all branch, btw. it's easier.

[20:55] *** Su-Shee left
[20:58] <[Coke]> masak, would you like a slightly updated sample, or are you good?

[20:58] *** _3coder joined
[20:58] <masak> [Coke]: I'm good, thanks.

[21:04] <masak> how do I turn the Parrot string I get back from the Q:PIR into a Perl 6 Str?

[21:05] <[Coke]> hurm. does $foo = Q:PIR { .... %r = $S0} work?

[21:05] <masak> it rewards my with a Null PMC access.

[21:06] <masak> granted, I returned the value directly rather than put it in a variable? would that make a difference?

[21:06] <masak> s/\?/./

[21:06] <mberends> masak: try prefixing it with a ~

[21:06] *** krr left
[21:06] <masak> mberends: just compiling such an attempt :P

[21:06] <[Coke]> ah, then you don't need to cast it in the PIR, either. (you can just hand back the StringBuilder, and ~ should DTRT.)

[21:06] <jnthn> masak: Feel free to paste it with its Perl 6 surroundings. :-)

[21:07] <masak> moritz_: why was Cool made into a class rather than a role? was it so that we could write 'class MyClass is Cool'? :)

[21:07] * [Coke] ponders installing haskell later.

[21:07] <masak> jnthn: sure thing. adding ~ didn't work :/

[21:12] *** _3coder left
[21:13] <masak> jnthn, [Coke]: storing it in a variable first miraculously worked! \o/

[21:13] <jnthn> \o/

[21:13] * jnthn afk for a little bit

[21:13] *** whiteknight joined
[21:17] *** stephenlb left
[21:23] *** justatheory left
[21:24] <masak> jnthn: my devious plan of using find_lex to pull in the list of Ints from the attr didn't work. the error I get is `shift_integer() not implemented in class 'ParrotIter'`. what's the 'correct way' to loop through a set of ints from a p6 attribute?

[21:28] *** Guest17566 left
[21:31] *** whiteknight left
[21:37] *** SmokeMachine left
[21:40] *** gbacon left
[21:41] *** arthur-_ joined
[21:43] *** lisppaste3 joined
[21:47] *** arthur-_ left
[21:51] <dalek> csmeta: r313 | diakopter++ | trunk/Sprixel/ (2 files):

[21:51] <dalek> csmeta: [perlesque] clone Caller also :)

[21:51] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=313

[21:52] <masak> time to switch off for the day.

[21:52] <masak> today, I got Str.encode working again, and almost got Buf.decode working :)

[21:52] <masak> a promising start.

[21:52] *** Guest37008 left
[21:52] <masak> will blog about it tomorrow.

[21:53] <masak> 'night.

[21:53] *** masak left
[22:01] <jnthn> phenny: tell masak at the moment easiest to shift a PMC and then $I0 = $P0 it. We could implement shift_integer and shift_string in ParrotIter though.

[22:01] <phenny> jnthn: I'll pass that on when masak is around.

[22:05] *** eternaleye joined
[22:12] <TimToady> offline for about 8 hr...

[22:12] <TimToady> &

[22:13] <jnthn> o/

[22:20] *** pmurias left
[22:25] *** patspam1 left
[22:28] *** jhuni joined
[22:53] *** whiteknight joined
[22:58] <BrowserUk> ?

[23:00] *** Psyche^ joined
[23:03] *** pugssvn left
[23:03] *** pmichaud left
[23:03] *** dalek left
[23:03] *** PerlJam left
[23:04] *** Patterner left
[23:04] *** Psyche^ is now known as Patterner

[23:04] *** hugme left
[23:05] *** PerlJam joined
[23:06] *** dalek joined
[23:06] *** eternaleye left
[23:10] *** hatseflats joined
[23:10] *** Juerd joined
[23:10] *** pmichaud joined
[23:14] <sorear> Should : terminate LTM?

[23:14] *** _buno_ joined
[23:15] *** _buno_ left
[23:15] *** pugssvn joined
[23:17] <diakopter> sorear: no

[23:18] *** eternaleye joined
[23:18] *** eternaleye left
[23:18] *** eternaleye joined
[23:21] *** cognominal joined
[23:21] *** cognominal_ joined
[23:21] *** cognominal left
[23:25] *** cognominal_ left
[23:25] *** cognominal joined
[23:26] *** cognominal left
[23:26] *** cognominal joined
[23:28] <sjohnson> ... hi

[23:28] <jnthn> Jag har en öl. Let's see if I can do any little thing in Rakudo before I sleep. :-)

[23:29] <jnthn> sjohnson: hi!

[23:30] <sjohnson> jnthn: hello, other-windows-desktop-user-like-myself

[23:30] <jnthn> :-)

[23:31] <sjohnson> others exist u

[23:31] <sjohnson> oops

[23:31] <sjohnson> i meant to say, others like us are seeming to do a lot of good things.  like the GnuWin32 project, and msysgit.. which i recently tried

[23:31] <sjohnson> which comes with its own win32 compile of perl, under the target name of "msys" which is cute

[23:32] <sjohnson> the one i use though says MSWin32-x64-multi-thread.. from strawberry perl.  </rant>

[23:34] <jnthn> I've mostly stuck with the ActiveState one on my dev box, mostly because Parrot pulls compiler hints from Perl configuration, and they build with the same compiler I use to build Rakudo.

[23:34] <jnthn> oh crap...don't say the Parrot folks broke the build. :-/

[23:34] <sorear> Does the end of an alternation terminate LTM?

[23:35] <sorear> jnthn: they did, and they fixed it too!

[23:35] <sorear> apparently they still have commit bits

[23:35] <jnthn> sorear: On Windows?

[23:35] <sorear> Or, in other words, 'aab' ~~ / [ a | aa ]: ab /

[23:35] * jnthn goes to read the commit log

[23:37] <jnthn> ah, seems that a commit touched the problem file

[23:37] * jnthn svn ups and crosses his fingers

[23:37] <diakopter> try double-crossing them

[23:38] *** rgrau left
[23:38] <diakopter> sorear: it terminates ltm for that alternation, but not for any parent ltm alternations

[23:39] * diakopter retracts... not enough throughput to think through it properly atm

[23:41] <sjohnson> ot question:  has anyone here tried doing atmel chip (or similar) programming using Perl instead of C?

[23:50] <sorear> that's.... not very OT

[23:50] <sorear> the Perl 5 VM is over 1MB of executable code

[23:50] <sorear> how big is your atmel chip?

[23:53] <[Coke]> jnthn: was it fixed?

[23:53] <jnthn> [Coke]: yes

[23:53] <[Coke]> <whew>

[23:53] <jnthn> [Coke]: Will commit the bump after spectest

[23:54] <jnthn> [Coke]: Some mess up involving inconsistent linkage and platform_interface.h 

[23:54] <sorear> How about this?

[23:54] <sorear> regex x { a || aa }; regex y { ab }; token z { <x> <y> }

[23:54] <sorear> erm

[23:55] <sorear> regex x { aa || a }; regex y { ab }; token z { <x> <y> }; "aab" =~ /<z>/

[23:55] <sorear> S05 is ambiguous

[23:55] <sjohnson> sorear: sorry didnt see you wrote back.  i was thinking of small things.. maybe like 256k.

[23:55] <sorear> then Perl (5) is not going to work for you

[23:55] <sjohnson> but the computer i'd use would be a modern one, so if it's easier to write a programmer thing in perl than C, then i'd rather do that

[23:55] <sorear> Perl 4 might

[23:55] <sorear> Perl 6 probably will

[23:55] <jnthn> sorear: I'm not convinced that would match.

[23:56] <sorear> jnthn: S05 states that ratcheting contexts cut after quantifiers and alternations

[23:56] <sjohnson> sorear: oh sorry, i kind of meant.. like.  use perl as the language, to burn 30k worth of data, to a flash chip

[23:56] <jnthn> sorear: Since in token z there's an implicit cut after each thingy

[23:56] <sjohnson> not put perl on the chip

[23:56] <sjohnson> ... unless that isn't what you meant either :(

[23:56] <jnthn> So IIUC it'd cut after <x> which is then committed to aa

[23:56] <sorear> jnthn: it's not clear on whether ratcheting contexts cut after any other token

[23:56] <sjohnson> if it has access to the serial ports, wouldn't perl 5 work?

[23:56] <jnthn> Maybe I've got it wrong though. I'm the wrong person to ask really, but that's what I'd expect.

[23:56] <sorear> which matters for assertions

[23:56] <jnthn> Aye

[23:56] <jnthn> I'm going more on experience and feeling than knowledge. ;-)

[23:57] <sorear> I'm really too much of a rules lawyer for P6

[23:58] *** stephenlb joined
[23:59] <jnthn> Nah; having people help us get the spec clear is a Good Thing. :-)

