[00:00] <sorear> TimToady: don't typical phone OSes mmap all files?

[00:01] <sorear> I've got this idea for a data structure that might work well here - it's the bastard child of a B+ tree and an inversion list, tuned to a node size of the P4 cache line (64 bytes) :>

[00:01] <pmichaud> (Will make negative subscripts fail.)

[00:04] *** solarion left
[00:04] *** solarion joined
[00:05] *** masonkramer_ joined
[00:06] <pugssvn> r31278 | sorear++ | [dfa/Cursor] Implement protoregexes 

[00:08] <sorear> TimToady: What are the FILE and NAME fields of lexers used for?

[00:08] *** sorear sets mode: +o diakopter

[00:09] <TimToady> FILE is the name of the cache file, iirc

[00:09] <sorear> Yeah, I see that, but AFAICT it's a dead store.

[00:10] *** macdaddy left
[00:12] <TimToady> could well be; we've gone through many iterations of caching

[00:12] <TimToady> and name just remembers the key under which we are stored

[00:12] <TimToady> more for debugging than anything

[00:18] <pugssvn> r31279 | sorear++ | [dfa/Cursor] Disconnect the old regex LTM; establish full control in the hands of NFA 

[00:19] <TimToady> ooey!

[00:21] * diakopter curiuos about speed diffs

[00:21] <diakopter> curious

[00:21] <diakopter> sorear: can I kick off the std rebuild on p6eval early?

[00:22] <sorear> no

[00:22] <diakopter> k

[00:22] <sorear> [dfa/Cursor]

[00:22] <sorear> I'm still workign in a branch

[00:22] <diakopter> oh

[00:22] <sorear> and a lot of features need to be forward ported

[00:22] <diakopter> didn't realize it was a branch

[00:22] <sorear> right now I'm adding \s

[00:24] <TimToady> plus he only just removed the comparison instrumentation

[00:24] *** lest_away is now known as lestrrat

[00:24] <TimToady> so speed was not easily measurable before

[00:24] <sorear> there are enough ambiguities in the handling of fate chains that it wasn't doing anything useful

[00:25] <sorear> What's \s in unicode props?

[00:25] <sorear> Space/Y ?

[00:26] * diakopter working on adding grammar/token/rule/regex keywords to perlesque

[00:28] <TimToady> dunno, the long names were invented after I hacked unicde into p5

[00:33] *** skids joined
[00:36] * diakopter longs for sixperl minutes

[00:40] *** masonkramer left
[00:40] *** masonkramer__ joined
[00:40] *** masonkramer__ is now known as masonkramer

[00:41] <snarkyboojum> oh yeah, there haven't been sixperl minutes for ages

[00:42] *** whiteknight left
[00:43] <sorear> \x0d is considered \h?

[00:44] <TimToady> it moves the carriage to the left :)

[00:44] <TimToady> so yeah

[00:46] *** ciphertext left
[00:46] *** snarkyboojum left
[00:47] <TimToady> and VT is matched by \v, but \v won't get you one :)

[00:49] <pugssvn> r31280 | sorear++ | [dfa/Cursor] Implement backslash escapes for character classes 

[00:54] *** mikehh left
[00:54] *** mikehh joined
[00:57] <pugssvn> r31281 | sorear++ | [dfa/Cursor] Implement before and after zero-width assertions 

[00:57] <sorear> I've switched to testing on STD.pmc... ws_0 is now correctly DFAed

[00:59] <TimToady> hopefully you find more bugs in the old stuff than the new stuff :)

[00:59] <TimToady> dinner &

[01:11] *** arthur-- left
[01:13] *** arthur-- joined
[01:15] *** Chillance left
[01:15] <dalek> csmeta: r333 | diakopter++ | trunk/Sprixel/ (5 files):

[01:15] <dalek> csmeta: [perlesque] add the first declarative (via API) grammar test.  syntax to follow.

[01:15] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=333

[01:19] <diakopter> perlesque: say(IO::File.ReadAllText("../../t/grammar1.t"))

[01:19] <p6eval> perlesque: OUTPUT«say('1..1');

[01:19] <p6eval> ..return Either.D…

[01:19] <diakopter> erm

[01:21] <diakopter> perlesque: use "../../t/grammar1.t"

[01:21] <p6eval> perlesque: OUTPUT«1..1␤ok 1␤»

[01:21] <diakopter> perlesquel: use "../../t/grammar1.t"

[01:21] <p6eval> perlesquel: OUTPUT«1..1␤ok 1␤real 0.30␤user 0.28␤sys 0.02␤»

[01:21] <diakopter> perlesquel: use "../../t/grammar1.t"

[01:21] <p6eval> perlesquel: OUTPUT«1..1␤ok 1␤real 0.32␤user 0.30␤sys 0.01␤»

[01:21] <diakopter> hm

[01:25] <sorear> cute.  how does it work?

[01:26] <diakopter> see grammar1.t ..

[01:26] <diakopter> working on adding the inline-code thing

[01:26] <sorear> yeah, I'm looking at grammar1.t

[01:27] <sorear> but it doesn't look like assemblies are getting generated much

[01:27] <diakopter> it should've emitted a Foo.exe

[01:27] <sorear> hmm.

[01:27] <sorear> ok.

[01:28] <sorear> ISTR something in the .NET docs about needing to use a nonsaved assembly to reference stuff from the current one?

[01:28] <diakopter> o wait

[01:28] <diakopter> odd

[01:29] <diakopter> it put the perlesque parser in Foo.exe

[01:29] <diakopter> looking..

[01:29] <diakopter> oh; lol

[01:29] <diakopter> no it didn't

[01:29] <diakopter> I have some non-re-entrant static/globals I need to fix

[01:30] <diakopter> namely it emitted a totally superfluous N0,000-entry jumptable/switch-case block

[01:31] <diakopter> sorear: I'll clean up the API so it's actually sane

[01:31] <diakopter> it's currently, um, not.

[01:32] <diakopter> afk&

[01:52] <sorear> hmm.  I'm generating a LTM automaton for <opener>

[01:52] <sorear> I suspect this is not right.

[01:53] <colomon> pmichaud: ping?

[01:53] <pmichaud> colomon: pong

[01:54] <colomon> rakudo: my @a = 1; @a.push({ 'a' => 3, 'b' => 4 }); say @a.perl

[01:54] <p6eval> rakudo 272191: OUTPUT«[1, {"b" => 4, "a" => 3}]␤»

[01:54] *** jaldhar joined
[01:54] <colomon> huh.

[01:54] <colomon> sorry, may have called you too early on this one.

[01:54] <pmichaud> np :)

[01:54] <colomon> I'm trying to get hyper.t working.

[01:55] <pmichaud> +1

[01:55] <colomon> my local version makes it to test 160 with no fails, then trips up over a mixed array / hash test

[01:55] <pmichaud> I've just been implementing lazy splices :)

[01:55] <colomon> oooooooo +1

[01:55] <colomon> getting ["1a", "b" => "3b", "a" => "2b", "4c"]

[01:56] <colomon> should be getting ["1a", {"b" => "3b", "a" => "2b"}, "4c"]

[01:56] <pmichaud> what line is test 160?

[01:56] <colomon> I figured it must be a push issue, but maybe not.

[01:56] <colomon> 532

[01:57] <pmichaud> mine must be different numbers

[01:57] <sorear> TimToady: What NFA should be generated for ^, ^^, $, $$?

[01:58] <pmichaud> oooh, splice.t passes!

[01:58] <colomon> \o/

[01:58] *** plobsing joined
[01:58] <colomon> I think the source of the problem is probably (from hyper on arrays):

[01:58] <colomon>         if Associative.ACCEPTS($l) || Associative.ACCEPTS($r) {

[01:58] <colomon>             @result.push(hyper(&op, $l, $r, :$dwim-left, :$dwim-right));

[01:58] <pugssvn> r31282 | sorear++ | [dfa/Cursor] Anonymous character classes, some special methods 

[01:58] <pmichaud> that hyper doesn't look like it's likely to return an item

[01:59] <pmichaud> so yes, the result will flatten.

[01:59] <colomon> at what point?

[02:00] <pmichaud> rakudo:  my @a = 1,2,3;   my @b = 5, 6;  @a.push(@b);  say @a.perl;

[02:00] <p6eval> rakudo 272191: OUTPUT«[1, 2, 3, 5, 6]␤»

[02:00] <pmichaud> @b is flattening, so each element of @b gets added to @a

[02:00] <pmichaud> the hyper() function seems very likely to return a flattening object

[02:01] <pmichaud> such that each element returned by hyper gets flattened into @result

[02:01] <colomon> it's supposed to preserve structure, not flatten.

[02:01] <pmichaud> I'd need to see the test itself to be able to trace it better.

[02:02] <pmichaud> if it needs to preserve structure, then you might not want to be using .push (which tends to flatten)

[02:02] <colomon> search on "hash in array - result array is the correct length"

[02:02] <colomon> what could be used instead of push?

[02:03] <pmichaud> not sure, but in general things like push, array assignment, etc. aren't conducive to preserving structure

[02:03] <pmichaud> generally you want to keep things from going into variables.

[02:03] <pmichaud>     my @r = @a <<~>> @b;

[02:03] <pmichaud>     is +@r, 3, 'hash in array - result array is the correct length';

[02:03] <pmichaud> this one?

[02:04] <colomon> It's that block

[02:04] <colomon> it's all one logical test

[02:04] <pmichaud> I need to read the latest on hypers

[02:05] <colomon> I'm not sure that particular behavior is spec'd yet, discussed it with TimToady last week.

[02:06] <pmichaud> well, I see that the first element should be "1a", and the last element should be "4c"

[02:06] <pmichaud> I'm not sure what that middle element should be.

[02:06] <colomon> rakudo: say ((1, { a => 2, b => 3 }, 4) <<~>> <a b c>).perl

[02:06] <p6eval> rakudo 272191: OUTPUT«["1a", {"a" => "2b", "b" => "3b"}, "4c"]␤»

[02:07] <colomon> that is, it's  { a => 2, b => 3 } <<~>> b

[02:08] <pmichaud> what would you expect from...

[02:09] <pmichaud> my @a = (2,3);    say ((1, @a, 4) <<~>> <a b c>).perl

[02:09] <pmichaud> ?

[02:09] <pmichaud> oh, nm, that's not a good example.

[02:10] <pmichaud> my $a = [2,3];    say ((1, @a, 4) <<~>> <a b c>).perl

[02:10] <pmichaud> arggh

[02:10] <pmichaud> my $a = [2,3];    say ((1, $a, 4) <<~>> <a b c>).perl

[02:10] <colomon> rakudo: my $a = [2,3];    say ((1, $a, 4) <<~>> <a b c>).per

[02:10] <p6eval> rakudo 272191: OUTPUT«Method 'per' not found for invocant of class 'Array'␤  in main program body at line 11:/tmp/TPzcfDudDF␤»

[02:10] <colomon> rakudo: my $a = [2,3];    say ((1, $a, 4) <<~>> <a b c>).perl

[02:10] <p6eval> rakudo 272191: OUTPUT«["1a", ["2b", "3b"], "4c"]␤»

[02:10] <colomon> faster than typing in the result, but yeah, that's what I expected.

[02:11] <pmichaud> and then

[02:11] *** patspam joined
[02:11] <pmichaud> rakudo:  my @a = 2,3;  say ((1, @a, 4) <<~>> <a b c>).perl

[02:11] <p6eval> rakudo 272191: OUTPUT«["1a", "2b", "3c", "4a"]␤»

[02:11] <pmichaud> hmmmm.

[02:11] <pmichaud> trying adding .item after your hyper()

[02:11] <pmichaud> that might work.

[02:12] <colomon> testing

[02:12] <pmichaud> but that might have the effect of itemizing things that weren't items in the original list.

[02:13] <pugssvn> r31283 | sorear++ | [dfa/Cursor] Zero-width assertion metacharacters are now treated as nulls at LTM 

[02:14] <pmichaud> aha

[02:14] <pmichaud> my suggestion would be use .map instead of for in the hyper helper

[02:14] <pmichaud> and avoid putting things into @result

[02:15] <pmichaud> that way things remain parcelized properly instead of being forced into item or flattened

[02:15] * pmichaud scribbles

[02:15] <pmichaud> we can get back to using for() once we have it set up to translate to .map

[02:16] <colomon> ooooo, interesting

[02:17] <colomon> .item makes the test pass, for what it is worth.

[02:17] <pmichaud> can go with .item for now.  It might make other flatten-y things fail.

[02:18] <pugssvn> r31284 | sorear++ | [dfa/Cursor] RE_double 

[02:18] <colomon> up to 218 passing hyper tests, and I think another .item will fix the next failure.

[02:18] <sorear> I now have STD itself minimally functional on dfa/Cursor

[02:19] <pmichaud> http://nopaste.snit.ch/21280   # avoiding @result array, for colomon++.   Also makes the hyper results lazy.  :)

[02:20] <pmichaud> there might be better ways to do this, too.

[02:20] <pmichaud> but in general, for any type of operator (especially pipelines) it's best to avoid containerizing things if at all possible.

[02:20] <pmichaud> because putting something in a container tends to say something about how it behaves.

[02:21] <colomon> hmmm.... worth changing?  I've got hyper.t 100% passing with @result version at the moment.

[02:21] <pmichaud> if it's working, don't change it.

[02:21] <pmichaud> or, better stated:  commit a working version, and then if you want to play with the other one that's up to you :)

[02:21] <colomon> let me check it in like this, with a note about your suggestion.  

[02:21] <colomon> yeah.  :)

[02:22] <pmichaud> but if you look at the core methods I write you'll see that I tend to want to avoid sticking things into variables

[02:22] <pmichaud> (variables also tend to make values stick around longer)

[02:22] <pmichaud> in this example, for example,  if the result of the hyper is being consumed by an iterator, all of the previous values end up sticking around in the @results array even though we don't use them

[02:23] <pmichaud> thus   (@a <<~>> @b).map(...)   

[02:24] <pmichaud> map will lazily request items from hyper(), but after map processes each they end up staying around in the @results array (because it's bound)

[02:24] <pmichaud> well, more to the point, using @results means that the whole hyper() thing isn't at all lazy.  it eagerly computes all of the results, and then keeps all of them around as long as any are being used.

[02:25] * pmichaud kicks himself off the soapbox.  :)

[02:26] <pmichaud> someday as I'm doing code reviews I'll undoubtedly note places where things aren't written lazily that ought to be :)

[02:26] *** skangas joined
[02:26] <colomon> +1 to a general lazy approach, but of course hyper isn't supposed to be lazy.  :)

[02:26] <lue> afk

[02:26] <pmichaud> ah, yes, if hyper isn't lazy then it doesn't matter :)

[02:27] <colomon> I'm not sure there's any reason we shouldn't make it lazy at the moment, but in the long run...

[02:27] <pmichaud> and I'm still fond of the notion that our hypers should do things out-of-sequence.

[02:27] <colomon> +1 out-of-sequence

[02:28] <pmichaud> maybe when I get tired of other stuff I'll randomize hyper() a bit.  :-)

[02:29] <pmichaud> can the repeating-array sub be rewritten as    @a xx *  at some point...?

[02:29] <colomon> pmichaud: I think so.

[02:30] <colomon> there was a good reason to do it as repeating-array, but I don't remember why now.

[02:30] <colomon> munch($n) is in place already, right?

[02:30] <pmichaud> well, previously &infix:<xx>  probably didn't know how to preserve parcels

[02:31] <pmichaud> but now it probably can :-)

[02:31] <pmichaud> oh, I guess not yet.  :-|

[02:32] <pmichaud> rakudo:  say ((1,2,3) xx 4).perl

[02:32] <p6eval> rakudo 272191: OUTPUT«[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]␤»

[02:32] <pmichaud> that looks wrongish.

[02:32] <colomon> I dunno

[02:32] <colomon> I think I'd worry about the 

[02:33] <colomon> rakudo: say ([1, 2, 3] xx 4).perl

[02:33] <p6eval> rakudo 272191: OUTPUT«[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]␤»

[02:33] <colomon> case

[02:33] <colomon> I mean, in the hyper context.

[02:33] <pmichaud> right

[02:34] <pmichaud> anyway, list branch seems to behave same as rakudo at the moment.

[02:34] *** ciphertext joined
[02:35] *** Targhan_ left
[02:35] <pmichaud> ah, yes, &infix:<xx> is also doing the @results array trick

[02:35] <pmichaud> fixing.

[02:35] *** Wolfman2000 joined
[02:35] *** ggoebel left
[02:36] <pmichaud> our multi infix:<xx>(Mu \$item, $n) { (1..$n).map( { $item } )

[02:36] <pmichaud> }

[02:36] <pmichaud> .... and now it's lazy.  :)

[02:36] <colomon> \o/

[02:37] <colomon> ah, if it wasn't lazy, that's definitely why I wasn't using it there!

[02:37] <colomon> though of course it doesn't necessarily explain why I didn't just make it lazy.

[02:37] <pmichaud> would've been hard to make it lazy prior to the branch.

[02:37] <pmichaud> I suppose it could've been done with gather/take

[02:38] <pmichaud> I tend to prefer using map for laziness these days :)

[02:39] <colomon> map++

[02:39] <pmichaud> > say ((1,2,3) xx 5).perl

[02:39] <pmichaud> ((1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3))

[02:39] <pmichaud> and it's no longer flattening the parcels.  :)

[02:41] <colomon> is ^* okay?

[02:41] <colomon> (errr... not that you used it here!)

[02:41] <pmichaud> I don't know.  Right now a lot of the *'s are being turned into closures 

[02:41] <pmichaud> for example, I tried   (1,2,3) xx *   and it thinks it's a Block

[02:41] <colomon> ouch.

[02:41] <pmichaud> so we need a Whatever version too I guess.

[02:41] <colomon> I can fix that.

[02:41] <pmichaud> I just pushed my version.

[02:42] <colomon> heh, having trouble getting caught up here.  :)

[02:42] <pmichaud> I'll be taking a short break in just a bit

[02:42] <pmichaud> also running a full spectest run to see what else needs fixing.

[02:43] <colomon> pmichaud: actually, we just need to modify the list of exclusions to the Whatever closure code.

[02:43] <colomon> *exceptions

[02:43] <pmichaud> okay, that works too.

[02:43] <colomon> I'll have to poke around to remember how to do it, but it's not hard.

[02:44] <colomon> rakudo: say (1 ..^ *).perl

[02:44] <p6eval> rakudo 272191: OUTPUT«{ ... }␤»

[02:44] <colomon> embarrassing, can't believe I forgot to check that.

[02:45] <colomon> fixing

[02:47] <colomon> rakudo: say (^*).perl

[02:47] <p6eval> rakudo 272191: OUTPUT«{ ... }␤»

[02:47] <colomon> rakudo: say (^10).perl

[02:47] <p6eval> rakudo 272191: OUTPUT«0..^10␤»

[02:49] <pugssvn> r31285 | sorear++ | [dfa/Cursor] First cut of implementing all remaining RE_xxx 

[02:55] *** pronik` joined
[02:58] *** pronik left
[03:03] *** [mark] joined
[03:10] *** skids left
[03:12] *** masonkramer_ left
[03:13] <sorear> much as I am enamored with the idea of compiling NFAs down to optimal machine code, statically, I'm starting to think lazy might work better after all...

[03:14] *** meppel joined
[03:17] *** meppl left
[03:20] <pugssvn> r31286 | colomon++ | Test that Range operators with Whatevers are not mistakingly turned into closures. 

[03:26] *** patspam left
[03:39] <TimToady> sorear: traditionally, edges get extra constraints that are tested for 0-width assertions, but you can just ignore them and let LTM backoff handle the constraint failure for now

[03:40] <TimToady> sorear: the nice thing about lazy is that it tends to cache the states you'll need next time you see the same thing, since there's usually an amount of redundancy

[03:40] <TimToady> it also saves you from exponential state space to make it data driven

[03:41] *** JimmyZ joined
[03:41] <TimToady> however, some hotspot analysis could make it worthwhile to compile some of 'em down to the metal

[03:44] *** mikehh left
[03:45] <sorear> just what I needed, /more/ complexity in edges

[03:45] <sorear> it's bad enough that they have to be able to represent arbitrary Boolean functions of Unicode properties

[03:45] <sorear> Perl 5 is really not ideal at managing complicated graphy data structures

[03:46] <TimToady> anyway, you can ignore the 0-widths with (I believe) the same semantics

[03:46] *** mikehh joined
[03:47] <TimToady> assuming we aren't trying to solve the Halting Problem with our engine

[03:48] <TimToady> we certainly don't make a lot of use of anchors in grammars, so I don't think we lose much by letting the grammar do the tests instead

[03:48] <TimToady> general regex might be dicier though

[03:49] <TimToady> some 0-width assertions can be emulated, such as looking for non-\w after »

[03:50] <TimToady> trick there is not to count the next character in LTM unless it would be matched otherwise

[03:51] <TimToady> but you'd really like to run your machine just by looking at things with width

[03:53] <TimToady> I wonder how much syntax relief you'd get writing it in P6 and translating it...

[03:54] *** Schwern joined
[03:55] <sorear> yay, now I've gotten to the "bugs without backtraces" stage

[03:56] <sorear> $lang is not predeclared at STD.pm6 line 96

[03:59] <TimToady> is it still breaking ties in the same order as the old LTMer?

[04:01] <sorear> no

[04:01] <sorear> that's next... after I figure out how that worked

[04:02] <TimToady> some of what the old LTM calculated on the fly can actually be determined in advance, such as how many literal chars there are on the front

[04:03] *** lestrrat is now known as lest_away

[04:03] <TimToady> we can probably pre-gen a Schwartzian comparison string that is just used to sort equal-length cohorts

[04:03] *** lest_away is now known as lestrrat

[04:04] <sorear> I think nfastar is broken, anyway

[04:04] <TimToady> instead of push a flat list you might want to push @[][] where the first ix is token length

[04:04] <sorear> I'm translating character classes wrong too

[04:05] <sorear> I have <[ \s ]> matching 's'

[04:05] <TimToady> then it's easy to sort the longest set lazily, and you never have to sort the shorter cohorts you don't use unless relex requests it

[04:05] <sorear> What do you mean by @[][] where the first ix is token length ?

[04:06] <sorear> What's relex?

[04:06] <TimToady> when it fails a longer token match in the parser, it comes back and looks for the next "shortest" token, or one that lost in the tie sorter

[04:07] <TimToady> @candidates[$ltm_length][@order_pushed]

[04:08] <TimToady> if you look at the old anonymous sub returned by gen, it actually had a three level, @candidates[$ltm_length][$literal_len][$push_order]

[04:08] <TimToady> but as I say, the literal length doesn't need to be there

[04:09] <TimToady> if @candidates[] top level is indexed by LTM length, then all the candidates at that length can be sorted by a predefined comparsion string that encodes longest literal match, order of declaration

[04:10] <sorear> the current run engine does push @fates, @{ $dfanode->[0] }; every iteration, then pop @fates in the returned sub

[04:10] <TimToady> basically, tie-breakers 2..5 at S05:45

[04:10] <sorear> so the order of fate return on a given dfa node is controlled by the dfa generator

[04:11] <TimToady> hmm, and a dfa state can represent more than one position, eh?

[04:11] <TimToady> hmm

[04:11] <TimToady> well, but we know the position in the buffer

[04:12] <TimToady> so there is only one current token length

[04:12] <TimToady> that's the first index of the candidates, and you push all those fates in there

[04:12] <sorear> the trick is that fates are added to the fate pool in order of increasing high water

[04:12] <sorear> which is the same as the order of increasing token length

[04:12] <TimToady> but you don't necessarily have to have sorted all those fates in advance

[04:12] <TimToady> it can be done lazily, is what I'm saying

[04:12] <sorear> so when we pull from the end, we always get the longest token first

[04:13] <TimToady> sure, but what about ties?

[04:13] <TimToady> that's what 2-5 are for in S05:45

[04:14] <TimToady> either the fates are presorted in that order, or post-sorted

[04:14] <TimToady> if we can presort them, then your current approach is fine

[04:14] <sorear> tiebreaking will be done by sorting the fates in _nfa_to_dfa

[04:14] <sorear> #2 can be done by adding extra info to the fates

[04:14] <sorear> a literal length field

[04:14] <TimToady> yes, almost did that myself

[04:15] <TimToady> so if you can presort them, that's probably best, especially if the particular fate-set gets reused

[04:15] <sorear> #3 and #4 fall out of stable ordering for free

[04:15] <sorear> NFA nodes are added in the order of RE_ast nodes

[04:15] <TimToady> maybe, or can be forced with a sort key

[04:16] <sorear> I don't really understand #5 but it probably falls out from the same logic, if augmented definitions go on ends of lists

[04:16] <sorear> what, precisely, constitutes a literal prefix?

[04:17] <TimToady> an exact character, possibly with canonicalization

[04:17] <TimToady> so abc\w\w\w is 3

[04:17] <TimToady> and maybe :i abc

[04:17] <TimToady> w

[04:17] <TimToady> :i abc\w\w\w

[04:17] <TimToady> but not abc<[de]>

[04:18] <TimToady> that's still 3

[04:18] <sorear> what about ab[d|e] ?

[04:18] <sorear> what about :!s a b c ?

[04:18] <TimToady> that's 2

[04:18] <sorear> what about "a""b""c"?

[04:18] <TimToady> those are both 3

[04:18] <sorear> what about token x { abc }   f <x> ?

[04:19] <TimToady> that's 4

[04:19] <sorear> a b [c] ?

[04:19] <TimToady> looks like 3

[04:22] <TimToady> gets a little dicey with a quantified literal / abc? /

[04:22] <TimToady> the current engine might actually put that either into [2] or [3]

[04:22] <TimToady> dunno exactly

[04:23] <TimToady> I could argue it should just be counted as 2

[04:24] <TimToady> would like to keep the definition statically discernable without data

[04:24] <TimToady> but the idea is to privilege 'print' over \w+

[04:25] <TimToady> does this make some sense to you?

[04:27] <TimToady> btw, when #5 says 'uses' it means 'use statements', not 'usages'

[04:27] <szabgab> rakudo: (5...1).perl.say

[04:27] <p6eval> rakudo 272191: OUTPUT«(5, 4, 3, 2, 1)␤»

[04:27] <szabgab> rakudo: (5...^1).perl.say

[04:27] <p6eval> rakudo 272191: OUTPUT«(5, 4, 3, 2, 1, 0, 0)␤»

[04:27] <TimToady> "How many use statements did we traverse to get to the definition?"

[04:28] <szabgab> the former is nice, the latter seem a bit double negative?

[04:28] <TimToady> it's being parsed as 5 ... ^1 I think

[04:28] <TimToady> rather than 5 ...^ 1

[04:28] <szabgab> rakudo: (5 ... ^1).perl.say

[04:28] <p6eval> rakudo 272191: OUTPUT«(5, 4, 3, 2, 1, 0, 0)␤»

[04:28] <szabgab> rakudo: (5 ...^ 1).perl.say

[04:28] <TimToady> though it still shouldn't give two 0's

[04:28] <p6eval> rakudo 272191: OUTPUT«(5, 4, 3, 2, 1, 0, 0)␤»

[04:29] <TimToady> rakudo: (5 [...^] 1).perl.say

[04:29] <p6eval> rakudo 272191: OUTPUT«===SORRY!===␤Unable to parse infixish, couldn't find final ']' at line 11␤»

[04:29] <TimToady> rakudo: (5 [...]^ 1).perl.say

[04:29] <p6eval> rakudo 272191: OUTPUT«(5, 4, 3, 2, 1, 0, 0)␤»

[04:29] <szabgab> what should be the difference between  5 ...^ 1  and 5 ... ^1  ?

[04:29] <TimToady> yes, it doesn't know ...^ yet

[04:30] <TimToady> the first should make 5...2 and the second 5 ... 0

[04:30] <szabgab> ok

[04:31] <sorear> yes, it makes sense

[04:32] <sorear> offtopic: In what ways is rakudo superior to pugs?

[04:32] <TimToady> pugs: say 5...0

[04:32] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "0"␤    expecting operator, ":", "," or term postfix␤    at /tmp/nqgOiM3aqI line 1, column 9␤»

[04:32] <PerlJam> sorear: it's got an active developer community

[04:33] <sorear> PerlJam: does pugs need a developer community?  Every time I've run a perl6:, pugs is on top of the pack

[04:33] <TimToady> rakudo actually does lazy lists

[04:33] <pmichaud> ...and soon it will even do them well.  :)

[04:33] <TimToady> it's much more developed on hyperoperators

[04:33] <TimToady> er, metaoperators

[04:34] <TimToady> and much better at regexen

[04:34] <ciphertext> szabgab: related http://rt.perl.org/rt3/Ticket/Display.html?id=75674

[04:34] <TimToady> pugs sent most of its regexen off to P5 to evaluate

[04:35] *** Visitor99 joined
[04:35] <sorear> I see.

[04:35] * sorear wonders what <[a..w]> means

[04:36] <TimToady> std: /<[a..\w]>/

[04:36] <p6eval> std 31286: OUTPUT«ok 00:01 109m␤»

[04:36] <TimToady> hmm

[04:36] <TimToady> I thought that would give an error

[04:36] <TimToady> std: /<[\w..a]>/

[04:36] <p6eval> std 31286: OUTPUT«ok 00:01 109m␤»

[04:39] <TimToady> std: /<[..a]>/

[04:39] <p6eval> std 31286: OUTPUT«[31m===[0mSORRY![31m===[0m␤Range missing start character on the left at /tmp/zo6bBIX1B5 line 1:␤------> [32m/<[..[33m⏏[31ma]>/[0m␤Check failed␤FAILED 00:01 105m␤»

[04:39] <TimToady> std: /<[a..]>/

[04:39] <p6eval> std 31286: OUTPUT«[31m===[0mSORRY![31m===[0m␤Range missing stop character on the right at /tmp/dF8MX70_fG line 1:␤------> [32m/<[a..[33m⏏[31m]>/[0m␤Check failed␤FAILED 00:01 105m␤»

[04:39] <pugssvn> r31287 | sorear++ | [dfa/Cursor] Fix $var crash, handle \s and \w in character classes correctly 

[04:40] <TimToady> and \d?

[04:41] <sorear> \d is not used in STD.pm6; also, I'd like to gut the whole thing

[04:41] <sorear> RE_ast currently has to reparse character classes

[04:41] <sorear> not good

[04:41] <TimToady> nod

[04:49] <pugssvn> r31288 | sorear++ | [dfa/Cursor] Debug information as fates are added to the fate pool 

[04:49] <sorear> according to the automaton for statement_0, "" can be the prefix for alts 2, 4, and 5

[04:49] <sorear> this seems wrong

[04:50] <sorear> well, 5 makes sense, but not 4

[04:50] <sorear> and *probably* not 2

[04:51] <TimToady> 4 makes sense if <stopper> is <!>

[04:53] <TimToady> I don't know offhand what's making 2 nullable

[04:53] <TimToady> unless perhaps termish isn't getting promoted to EXPR

[04:54] <sorear> "foomoo" ~~ / $<foo>=(foo) | $<id>=(...) [ .. » . ] /;  # ???

[04:54] <sorear> er

[04:55] <sorear> "foomoo" ~~ / $<foo>=(foo) | $<id>=(...) [ .. » . ]? /;  # ???

[04:55] <TimToady> term:miscbad is nullable

[04:56] <sorear> ah

[04:56] <pmichaud> down to 368 failing tests in list branch

[04:56] <sorear> OK, my current issue is bad tiebreaking

[04:57] <sorear> r31288 allows me to see that "my" is being fated as a term:name

[04:58] *** mjk left
[04:58] <pugssvn> r31289 | pmichaud++ | [t/spec] Change a reduce.t test to work slightly better in list branch. 

[04:59] <TimToady> yes, 'my' is tiebroken on declaration order currently

[04:59] <TimToady> that's why term:name is pretty far down

[05:00] <TimToady>     # bare identifier without parens also handled here if no other rule parses it

[05:00] <TimToady> tiebreaker #4

[05:03] <sorear> dfa/ currently tiebreaks on reverse declaration order :/

[05:03] <sorear> OH!

[05:04] <sorear> That's why you have __S_\d\d\d

[05:04] <TimToady> I think the old LTM managed to do #1..#4

[05:04] <TimToady> yes, those are for #4 within protos

[05:04] <TimToady> other than that, they're pretty useless

[05:06] <TimToady> it would be nicer to just know the position where a rule was declared in each file, and sort on that, presumably by some kind of introspectoin

[05:06] <TimToady> but p5 isn't terribly good at that

[05:07] <TimToady> and \d\d\d is an arbitrary limit of 1000 functions, which is bogus too

[05:11] *** snarkyboojum joined
[05:15] *** kaare joined
[05:15] *** kaare is now known as Guest71658

[05:15] <sorear> TimToady: What does 'use' have to do with monkey patching?  (#5)

[05:16] <sorear> If a grammar is subclassed, and a subclass provides a new multi token with the same long name, is the original one still used?

[05:16] *** meppel left
[05:17] <TimToady> I don't remember my chain of reasoning, other than there was some way monkey patching could make it fall through the cracks of the other rules

[05:17] <TimToady> certainly the subclass's name hides the superclasses

[05:18] <TimToady> I wouldn't worry about it for now

[05:18] <TimToady> #5 that is

[05:19] <TimToady> oh, I remember.  suppose a class comes from two different files due to augmentation; you can't use #4 in that case

[05:21] <TimToady> that probably implies a #6, two equally distant use-chains use the earlier use first

[05:25] <TimToady> otoh, I suppose it could be argued that an augmentation should take precedence over the basic class

[05:25] *** supernovus joined
[05:30] <sorear> what does "use" have to do with it first?

[05:30] <sorear> s/first/though/

[05:31] <supernovus> Well, having been working on a day-job that doesn't involve Perl 6, I seem to have missed a few great commits. IO::Socket::INET works again, and along with it, the SCGI library. Now that it works on the master branch again, how would I go about adding it to proto's projects.list?

[05:32] <TimToady> if you use something, it's presumably something more basic, so "use" distance is a proxy for genericity

[05:33] <TimToady> and in general we want the more specific rule to take precedence

[05:34] <TimToady> hmm, actually, 'my' should be taking precedence by longest literal token (2) over the <ident> of term:name, which is 0 literal chars

[05:34] <TimToady> so that one is broken by #2

[05:34] <TimToady> not by #4 as I surmised earlier

[05:35] <sorear> well, use doesn't have to be involved at all

[05:35] <snarkyboojum> supernovus: get someone with commit access to the proto repo on github to add it to projects.list

[05:35] <sorear> what if you're augmenting GLOBAL::something

[05:36] <sorear> I would combine #4 and #5 into "all remaining ties are broken in the logical order of compilation"

[05:36] <sorear> or equivalently "the order the rules were added to the alternation or class"

[05:36] <TimToady> which is insane, when two different used files both use something else

[05:37] *** orafu left
[05:37] <TimToady> or we could be like the C folks and just throw up our hands :)

[05:37] *** orafu joined
[05:38] <TimToady> and logical order of compilation puts used code in front of using code, which is backwards at least some of the time

[05:38] <snarkyboojum> supernovus: and if you add tests in a t/ directory you'll get another badge when it goes up on proto.perl6.org :)

[05:39] <supernovus> snarkyboojum: Sounds like a good idea. I see you made the last commit (to that file from the looks of it). I still have to figure out how to write tests that don't involve setting up a web server with an SCGI module loaded... 

[05:40] <snarkyboojum> supernovus: good point re tests - also, if you put your module in a lib/ directory, you can get ufo to generate a Makefile for you (if you want to do it that way)

[05:42] <TimToady> perhaps augment can have some way of marking its new methods as "unshifted" rather than "pushed" so they're logically in front of that particular class's methods

[05:42] *** Visitor99 left
[05:44] *** Meldrake_ left
[05:44] <supernovus> snarkyboojum: Sounds good. I have moved SCGI.pm into a lib/ folder. I shouldn't need proto.deps as it has no external dependencies.

[05:45] <TimToady> almost makes you want to change #4 to latest one wins, then everything would be more consistent

[05:49] <supernovus> Anyway, the SCGI can be found at http://github.com/supernovus/SCGI  Not sure if anyone is really interested in it, but it is MUCH faster than trying to call Perl 6 scripts through traditional CGI.

[05:52] <TimToady> <sorear> S05 and Cursor slightly disagree on how to handle zero-width positive lookahead assertions

[05:53] <TimToady> Cursor is correct, the handling of <?before foo> has nothing to do with where it is in a rule

[05:53] <TimToady> <?before foo> is the same as 'foo' {}

[05:53] <TimToady> as far as lexing is concerned

[05:54] <sorear> ok.

[05:54] <sorear> what about <ww> == <?before \w> <?after \w>

[05:54] <TimToady> equiv to \w

[05:55] <TimToady> lookbehinds are ignored, as are negative lookaheads

[05:55] <TimToady> in any case, the after if after a before, so would be ignored anyway

[05:55] <TimToady> s/if/is/

[05:57] <TimToady> since the <?before> terminates the declarative area after itself

[05:58] <snarkyboojum> supernovus: ufo will generate a default make rule to compile your module to *.pir and test targets etc - just tried it locally on your project and work well :)

[05:58] <TimToady> (the others are simply transparent to LTM, and do not terminate the declarative area)

[05:58] <TimToady> they're just extra constraints to be checked afterwards

[05:58] <sorear> does » turn into [ \W | $ ] {} ?

[06:00] <supernovus> snarkyboojum: cool, I haven't tried ufo yet, but will definitely be adding it to my toolkit. :-)

[06:00] <TimToady> I'm inclined to think not

[06:00] <TimToady> probably best to leave it transparent too

[06:03] <TimToady> in general \w* will pick the rule that doesn't match » anyway if there's more \w after

[06:03] <snarkyboojum> supernovus: I've added your module to proto.. I'm sure masak won't mind :)

[06:04] <supernovus> I still have an interesting bug related to pre-compiling into .pir files. I have a certain library that compiles fine if the rest of the libraries are .pm, but bails out with a blockoid error if you pre-compile the other libraries.

[06:04] <supernovus> snarkyboojum: thanks! 

[06:05] <snarkyboojum> supernovus++ :)

[06:05] <supernovus> snarkyboojum: I have a few other projects, but none of them have been fully weened from the 'alpha' branch yet...

[06:05] <TimToady> it's also possible we should differentiate <?before foo> into two constructs, one of which is transparent like other 0-width, and the other of which is instruction to ltm that doesn't have to be rematched at parse time

[06:05] <snarkyboojum> supernovus: I think there's quite a few projects listed in proto that aren't running against master (well there used to be)

[06:06] <snarkyboojum> supernovus: I'm sure masak can give you a commit bit to proto anyway so you can add them as you see fit :)

[06:06] <TimToady> <?ltm foo> or some such would finish off the current token, and always say "true" later since it knows it matches already

[06:07] <sorear> as I'm currently doing this, [foo]+ is counted as a literal prefix length of 3

[06:07] <sorear> since it's getting desugared to foo[foo]*

[06:07] <TimToady> there's a good argument for that interpretation too

[06:08] <TimToady> I'm fine with that

[06:09] *** justatheory left
[06:11] <TimToady> splitting <?before> is probably a bad idea really

[06:11] <TimToady> the whole point of the strange rules is to hide the transition from declarative to procedural most of the time

[06:12] <TimToady> and you can always write <!!before> to get the transparent assertion

[06:12] <moritz_> good morning

[06:12] <TimToady> o/

[06:14] <sorear> currently I have the nontransparent form for <?foo>, <before <foo>>, and <?before <foo>>

[06:14] <sorear> because viv optimizes them all to the same code

[06:17] <TimToady> is fine for LTM

[06:18] *** uniejo joined
[06:19] *** uniejo left
[06:30] <supernovus> I think it's time for bed. Have a good night/day everyone!

[06:31] *** supernovus left
[06:34] *** mjk joined
[06:35] *** Zapelius joined
[06:37] *** Guest14600 joined
[06:38] <sorear> I should probably do something about DFA nodes which list the same fate several tiems

[06:41] *** Guest14600 left
[06:41] *** Mowah joined
[06:41] *** Su-Shee joined
[06:51] *** uniejo joined
[06:54] <sorear> I seem to have broken something; EXPR__PEEK isn't getting generated

[07:09] * moritz_ is happy at the TODO passed in S32-list/map.t in rakudo's list branch

[07:10] <pmichaud> yeah, I pretty much have everything S29 and up working now.

[07:11] <Tene> :D

[07:12] <pmichaud> where "working" means "passing tests", but perhaps not completely efficiently or correctly

[07:14] <szabgab> rakudo: if "ac" eq "de"|"ef" { say 1 }

[07:14] <p6eval> rakudo 272191:  ( no output )

[07:14] <szabgab> in a junction of strings the " are just too noisy

[07:14] <pmichaud> if "ac" eq any(<de ef>) { # maybe }

[07:14] <szabgab> is there a way to write that nicer?   

[07:14] <szabgab> rakudo: if "ac" eq any(<de ef>) { say 1 }

[07:14] <p6eval> rakudo 272191:  ( no output )

[07:14] <szabgab> rakudo: if "de" eq any(<de ef>) { say 1 }

[07:15] <p6eval> rakudo 272191: OUTPUT«1␤»

[07:15] <szabgab> hmm

[07:15] <sorear> to process a NFA with 3000 nodes (termish!), it needs ~5 minutes

[07:15] <pmichaud> if "de" eq <de ef>.any { say 1 }

[07:15] <sorear> I'm definitely making this lazy

[07:16] *** am0c joined
[07:19] <Su-Shee> juppdideldi. good morning everyone! :)

[07:26] *** JimmyZ left
[07:28] <pmichaud> down to 167 failing tests.

[07:29] <pugssvn> r31290 | sorear++ | [dfa/Cursor] Implement the EXPR/termish hack in a more robust place.  Implement tiebreaker rules #2, #3, and #4.  Add diagnostics for runaway DFA generation. 

[07:31] *** mjk left
[07:34] <pugssvn> r31291 | pmichaud++ | [t/spec]:  Fudge and correct some tests based on list branch work. 

[07:34] *** pronik` left
[07:34] *** wallberg joined
[07:35] <sorear> after 25 minutes, statementlist_0 DFA has reached 4650/10000 nodes

[07:35] <sorear> needs more lazy.

[07:38] <sorear> one thing I've been thinking about is that the NFA generation *itself* could potentially be lazy

[07:38] <sorear> that means no AUTOLEXgen

[07:38] *** plobsing left
[07:46] <szabgab> junctions just drive me crazy

[07:46] <szabgab> rakudo: if 1 eq any(<1 2 3>) { say 1 }

[07:46] <p6eval> rakudo 272191: OUTPUT«1␤»

[07:46] <szabgab> rakudo: if 4 eq any(<1 2 3>) { say 1 }

[07:46] <p6eval> rakudo 272191:  ( no output )

[07:46] <szabgab> rakudo: if 4 ne any(<1 2 3>) { say 1 }

[07:46] <p6eval> rakudo 272191: OUTPUT«1␤»

[07:46] <szabgab> rakudo: if 1 ne any(<1 2 3>) { say 1 }

[07:46] <p6eval> rakudo 272191:  ( no output )

[07:47] <pmichaud> rakudo currently has ne implemented not according to spec (recent spec change)

[07:47] *** sdo_ left
[07:47] <szabgab> interesting, that's not what I saw in my REPL

[07:47] <pmichaud> in the future,   1 ne any(<1 2 3>)   will be equivalent to   !(1 eq any<1 2 3>)

[07:48] <pmichaud> rakudo:  if !(1 eq any(<1 2 3>)) { say 1 }

[07:48] <p6eval> rakudo 272191:  ( no output )

[07:48] <pmichaud> yes, I'm not sure what the local rakudo is doing there.

[07:48] <szabgab> it seems to do that now in the evalbot

[07:48] <szabgab> rakudo:  if (1 ne any(<1 2 3>)) { say 1 }

[07:48] <p6eval> rakudo 272191:  ( no output )

[07:49] <pmichaud> maybe rakudo's already been fixed :-)

[07:49] <szabgab> rakudo:  say 1 ne any(<1 2 3>)

[07:49] <p6eval> rakudo 272191: OUTPUT«0␤»

[07:50] <szabgab> rakudo:  say 4 eq any(<1 2 3>)

[07:50] <p6eval> rakudo 272191: OUTPUT«any(Bool::False)␤»

[07:50] <szabgab> rakudo:  say !(1 eq any(<1 2 3>))

[07:50] <p6eval> rakudo 272191: OUTPUT«0␤»

[07:50] <szabgab> I guess that should bee Bool::False ?

[07:50] <pmichaud> yes.

[07:51] <szabgab> oh I am so proud of myself now, I understood something, :)

[07:51] *** azawawi joined
[07:51] <azawawi> std: say "Hello";

[07:52] <p6eval> std 31290: OUTPUT«ok 00:01 107m␤»

[07:52] <azawawi> std: use v6; my $x = Mu; $x.say;

[07:52] <p6eval> std 31290: OUTPUT«ok 00:01 105m␤»

[07:53] <mathw> Morning

[07:55] *** gfx joined
[07:57] *** azawawi left
[08:06] *** wallberg left
[08:06] <Tene> morning!

[08:08] <mathw> Hey Tene

[08:14] <sorear> 1 hour of CPU time and only up to 20,000 nodes.

[08:15] <sorear> in other news, I now have a workable design for lazy NFA building

[08:17] <pugssvn> r31292 | pmichaud++ | More rakudo list-branch related updates. 

[08:19] <ciphertext> rakudo: say (^5)[0];

[08:19] <p6eval> rakudo 272191: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Range'␤  in main program body at line 1␤»

[08:19] <pmichaud> needs test, needs fixing.

[08:20] <ciphertext> in the list branch, that returns "maximum recursion depth exceeded"

[08:21] <pmichaud> yes, needs fixing :)

[08:21] <pmichaud> fixing now.

[08:21] <mathw> pmichaud++

[08:27] *** dakkar joined
[08:29] <pmichaud> > say (^5)[1,2,0]

[08:29] <pmichaud> 120

[08:30] <pmichaud> pushed as 5202fa7 (into list branch)

[08:30] *** sorear left
[08:31] *** rob-_- joined
[08:31] *** sorear joined
[08:31] <pmichaud> ...but apparently it broke a bunch of other stuff.

[08:33] <pmichaud> (not the range fix, but the other "fix" I threw in there as well)

[08:33] <Tene> yay, breaking!

[08:35] <pmichaud> pushed as 50b982a

[08:36] <pmichaud> okay, time for sleep here

[08:36] *** am0c left
[08:47] <pugssvn> r31293 | sorear++ | [dfa/Cursor] Sketch of a design for the lazy NFA generator 

[08:48] <cosimo> AWESOME

[08:48] *** jhuni left
[08:48] <cosimo> just got perl6 to connect to a MySQL database! \o/

[08:48] <cosimo> mberends: FakeDBI works for me, yea!

[08:50] <arnsholt> Cool

[08:50] *** am0c joined
[08:53] <Su-Shee> cosimo: shiny. what else did you use? :)

[08:54] <szabgab> rakudo: class Abcd { method y() {} }; Abcd.y();

[08:54] <p6eval> rakudo 272191:  ( no output )

[08:54] <cosimo> Su-Shee: zavolaj

[08:54] *** rob-_- left
[08:54] <szabgab> rakudo: class Abcd { method y() {} }; say Abcd.y();

[08:54] <p6eval> rakudo 272191: OUTPUT«Null PMC access in type()␤  in main program body at line 11:/tmp/5iKbK2u6oD␤»

[08:55] <cosimo> NativeCall.{pir,pm6}

[08:55] <cosimo> and FakeDBI/DBD

[08:55] <szabgab> cosimo, you do seriously crazy stuff!

[08:56] <Su-Shee> cosimo: hopefully, I'll have some more methods finished by the end of the week. 

[08:56] <Su-Shee> or at least one. ;)

[08:56] <cosimo> Su-Shee: maybe you meant what methods? just connect for now, and DROP TABLE.. the test scripts basically :) 

[08:57] <Su-Shee> cosimo: use something else and tell us how it went. :)

[08:57] <cosimo> szabgab: i don't understand

[08:58] <cosimo> Su-Shee: I was stuck on compiling/installing NativeCall. Now that that is done, I can try something else...

[08:58] <moritz_> szabgab: that's a known bug (that empty statement list return parrot Null PMC, not Nil)

[08:58] <szabgab> cosimo, just appreciation

[08:58] *** rob-_- joined
[08:58] <cosimo> szabgab: not doing anything special really, but thanks

[08:59] <snarkyboojum> rakudo: class Abcd { method y() {...} }; say Abcd.y();

[08:59] <p6eval> rakudo 272191:  ( no output )

[09:00] <Su-Shee> cosimo: I think, I just threw the pm6 module into @*INC. (~/.perl6/lib)

[09:02] <moritz_> http://img267.imageshack.us/img267/2687/booka4.pdf

[09:03] <moritz_> that's what pronik++ did to the book... awesome

[09:03] <snarkyboojum> moritz_: yeah - looks v. nice :)

[09:04] <Su-Shee> ery clean and readable.

[09:04] <arnsholt> Nice. I like the sans serif for headers and such

[09:04] <Su-Shee> uhm, very. 

[09:05] <pmichaud> list branch down to 146 failing tests

[09:05] <sorear> TimToady: azawawi in #padre wants E-numbers in STD.pm6 error messages... opinions?

[09:05] <moritz_> I think the last consensus was that we'll standardize printf formats for error messages

[09:06] <moritz_> and make them available in the exception object

[09:06] <moritz_> so that one can rely on those for i18n, catching certain expressions etc.

[09:06] <Su-Shee> hrgh, I need a rakudo in the office.

[09:06] <sorear> he's hacking on an IDE autofixer

[09:07] <snarkyboojum> pmichaud++ that's about 400 errors less than several hours ago :O

[09:07] <arnsholt> Su-Shee: I'm spectesting an office Rakudo right now =D

[09:07] <arnsholt> Not sure I'll get to use it though

[09:08] <Su-Shee> arnsholt: I need a perl6 in reach, otherwise I don't feel safe. ;)

[09:08] <arnsholt> Yeah, that's more or less my reasoning as well

[09:09] <Su-Shee> also, I have to transfer some data from one db into another in 2 weeks and I want to do it with rakudo and fakedbi I've just decided. 

[09:09] <arnsholt> Make sure to write it up afterwards =)

[09:10] <Su-Shee> I reserved the entire july for "evaluating future frameworks and technologies" :)

[09:11] <moritz_> wow, seems like a nice job if you can do that :-)

[09:11] <moritz_> (that said, currently my whole job consists of evaluating future technologies, and maybe invent some of my own :-)

[09:11] <Su-Shee> moritz_: well there is the other side of the medal - the perl 5 code I have to enhance, debug and extend. ;)

[09:12] *** samlh joined
[09:12] <Su-Shee> moritz_: no, it's really simple -> company is commited to perl -> someone has to have an eye on perl's future in terms of moose and perl 6 -> I'm pressuring and prodding that we actually do that for real and not just say "yes, let's have a look into new things."

[09:13] <Su-Shee> also this f**** code has to be rewritten entirely and I'm not willing to old school bless 5 my ass off by hand for the next version. 

[09:14] <pmichaud> just fixed a bug that recovered another 56 tests, so down to 90ish.

[09:15] <moritz_> pmichaud: Match.pair uses    take $key => $value

[09:15] *** gfx left
[09:15] <samlh> moritz_: re book, the code on page 55 and a couple other pages looks messed up

[09:15] <moritz_> pmichaud: and the resulting list contains a a Capture of Pair, not a Pair directly

[09:15] <szabgab> rakudo: my $x = Mu; $x = "3$x"; say $x.perl; say $x ~~ Mu;

[09:15] <p6eval> rakudo 272191: OUTPUT«"3Mu()"␤1␤»

[09:15] <szabgab> rakudo: my $x = Mu; $x = "3$x"; say $x.perl; say $x.defined

[09:15] <p6eval> rakudo 272191: OUTPUT«"3Mu()"␤1␤»

[09:15] <moritz_> samlh: yes, it still has a few rough spots

[09:16] <moritz_> pmichaud: is that correct/expected?

[09:16] <moritz_> and if yes, how do I lazily return a List of Pair objects?

[09:16] <pmichaud> moritz_: which method is this?

[09:17] <moritz_> pmichaud: Match.caps

[09:17] <pmichaud> try to write it without storing in @caps

[09:17] <pmichaud> anytime you store the results in an array, it's non-lazy

[09:18] <pmichaud> (i.e., @caps)

[09:18] <moritz_> uh right

[09:18] <pmichaud> looking.

[09:18] <moritz_> it's not going to be lazy anyway, since I need to sort

[09:18] <moritz_> so there's no need for gather/take really

[09:18] <pmichaud> well, storing in an array also has the effect of itemizing the elements

[09:19] <pmichaud> which means they no longer flatten

[09:20] <pmichaud> I think X=> isn't quite working right, or that could be shortened

[09:20] <pmichaud> i.e.,:

[09:21] <pmichaud>     if $p.value ~~ Array { ($p.key X=> $_).map( { take $_ } ) }

[09:21] <arnsholt> Has anyone tried to write something along the lines of perl6doc yet?

[09:22] *** lestrrat is now known as lest_away

[09:22] <pmichaud> didn't get that quite right

[09:22] <pmichaud> anyway

[09:22] <pmichaud> moritz_: you probably want some flat() or .flat in there

[09:23] <moritz_> pmichaud: I'm trying a very simple version that uses @caps.push

[09:23] <mathw> 'no need for gather/take' - maybe not for laziness, but it makes for some very nice coding patterns even if you're eager

[09:23] <moritz_> since I need to sort by .from anyway

[09:24] <moritz_> hm

[09:24] <sorear> arnsholt: there's App::Grok.  go ask literal if ey would add a --skip-ambient-code option

[09:24] <moritz_> mathw: agreed

[09:26] <moritz_> seems to work

[09:26] <moritz_> now the only problem left in .caps is that it's returning a Parcel, not a List

[09:26] <moritz_> but I think that's OK too

[09:27] <moritz_> we should really test that it returns something Positional

[09:27] <moritz_> and leave it to the implementation to return the most-suitable Positional type

[09:27] <pmichaud> Parcel is often more correct than List.

[09:27] <pmichaud> (and there's some speculation that Parcel may in fact be ~~ List)

[09:30] *** wallberg joined
[09:31] <arnsholt> sorear: Thanks!

[09:31] <pmichaud> what I ended up with:

[09:31] <pmichaud> (self.list.pairs, self.hash.pairs).map( { .value ~~ Array ?? .key X=> .value.list !! $_ }).sort( { .value.from } );

[09:32] <arnsholt> Even though a Perl 6 documentation reader written in Perl 5 is a bit sad =)

[09:33] <pmichaud> actually don't need .list on .value there -- we already know it's a list.

[09:33] <pmichaud> ah, but we might need to de-itemize it

[09:33] <pmichaud> so need .list

[09:34] *** am0c left
[09:34] <pmichaud> another better-formatted version:  http://nopaste.snit.ch/21288

[09:34] <pmichaud> anyway, I'm not sure that X=> is working quite right yet.

[09:35] <pmichaud> and might want a .flat before the .sort

[09:36] <ciphertext> does anybody know what  (1,1...5) should return?  currently it's an infinite list of 1's.

[09:36] <mathw> arnsholt: then port it

[09:36] <mathw> arnsholt: could be fun, and would give Rakudo a good workout

[09:38] <arnsholt> mathw: Well, I -am- thinking about it =)

[09:39] <arnsholt> Is literal == cpan:hinrik?

[09:40] *** samlh left
[09:40] <Tene> ciphertext: S03 doesn't *quite* say what should happen, but almost does.

[09:40] *** gbacon joined
[09:40] <Tene> "For intuited numeric generators that don't involve geometric sign changes, all values are assumed to be monotonically increasing or decreasing, as determined by the (up to) three values used above; if a supplied limit value is on the "wrong" side of the first of those values, Nil is returned, even though the limit value never matches, and never falls between two generated values."

[09:42] <Tene> ciphertext: I'd recomment an addition to the spec after this para: "If $ab == $bc and $ab is not zero, then we deduce an arithmetic progression determined by the function *+$ab. If $ab is zero, and the three values look like numbers, then the function is *+0. If they do not look like numbers, then the function selected is either *.succ or *.pred  depending on whether $b cmp $c appears to be Increasing or Decreasing. If cmp returns Same then an ...

[09:42] <Tene> ... identity function is assumed."

[09:43] *** tadzik joined
[09:43] <Tene> or by the other

[09:44] <Tene> ciphertext: So, it should probably return Nil, according to the spec.

[09:44] <ciphertext> Tene: that's what I was leaning towards. thanks

[09:46] <cognominal> rakudo:   say gather for 1 { take 1,2,3 }

[09:46] <p6eval> rakudo 272191: OUTPUT«too many positional arguments: 3 passed, 1 expected␤  in 'say' at line 1␤  in 'say' at line 4724:CORE.setting␤  in main program body at line 11:/tmp/81DBCiqTuF␤»

[09:46] <cognominal> is there a reason why take accepts only one argument?

[09:46] *** zamolxes left
[09:48] <moritz_> not really

[09:48] <Tene> I expect that the behavior of what that would mean isn't specified.

[09:48] <moritz_> it should take a raw capture, and pass that on

[09:48] <Tene> Sounds reasonable.

[09:48] <pugssvn> r31294 | sorear++ | [dfa/Cursor] Implement lazy DFA generation.  Time to parse a Stash.pm6 from >>1 hour to 6 seconds 

[09:48] <sorear> one of the most effective optimizations I've ever done.

[09:48] *** zamolxes joined
[09:49] <colomon> sorear++

[09:50] <pmichaud> > say gather for 1 { take (1,2,3) }

[09:50] <pmichaud> 123

[09:50] <moritz_> that's not the same

[09:50] <moritz_> take (1, 2, 3) vs take 1, 2, 3

[09:50] <pmichaud> yes, I know.

[09:51] <pmichaud> take should have the same signature as return

[09:51] <cognominal> should I masak that? I mean, file a bug?

[09:52] <moritz_> yes, please

[09:52] <pmichaud> src/builtins/control.pir, line 220

[09:52] <pmichaud>     .param pmc value

[09:52] <pmichaud> should be

[09:52] <pmichaud>     .param pmc value :slurpy

[09:53] <pmichaud> and then do the same processing as in &return above

[09:54] <pmichaud> in many ways, both &return and &take are the same, what differs is the type of exception thrown.

[09:54] <mathw> hah 'should I masak that' :)

[09:55] <moritz_> so... return doesn't treat its argument list lazily?

[09:55] <pmichaud> okay, I'm definitely doing sleep for a bit.  bbiaw

[09:55] <moritz_> good night

[09:55] <pmichaud> sure, it's lazy

[09:55] <moritz_>     $I0 = elements retvals

[09:55] <pmichaud> :slurpy just means that all of the arguments are captured into an RPA

[09:56] <pmichaud> it's an RPA, not a Parcel or List

[09:56] <moritz_> that doesn't look very lazy to me

[09:56] <moritz_> ok

[09:56] <pmichaud> it's saying how many things are in the RPA.  That doesn't do any flattening.

[09:56] <pmichaud> for example, if I have

[09:56] <pmichaud>     return  3, @a, %h, @b[4,5]

[09:56] <pmichaud> then the number of elements in retvals will be 4

[09:57] <pmichaud> (an Int, an Array, a Hash, and a Parcel)

[09:57] <moritz_> so it's quite different from the from a slurpy in Perl 6 signature

[09:57] <moritz_> s

[09:57] <pmichaud> yes

[09:57] <pmichaud> it's much more like a slurpy in p5

[09:57] <pmichaud> but no, Parrot doesn't have natively lazy or flattening structures :)

[09:58] <mathw> which makes sense really :)

[09:58] <pmichaud> only 90 tests to go

[09:58] <mathw> I thought you'd gone to bed, pmichaud

[09:58] <pmichaud> whoever fixes S12-introspection/methods.t  will gain another 35 tests :)

[09:59] <pmichaud> mathw: I'm having too much fun cleaning up bugs :)

[09:59] <mathw> Fair enough :)

[09:59] <pmichaud> and I think this test may be wrong:

[09:59] <pmichaud> S02-builtin_data_types/array_extending.t 19 - join on extended array

[10:00] <pmichaud> (test #19 in array_extending.t)

[10:00] <pmichaud> if anyone wants to look at that, that'd be great.

[10:00] <pmichaud> okay, I'm gone

[10:00] <pmichaud> later

[10:01] <mathw> bye!

[10:03] <sorear> Will 'list' be able to add any entirely new tests?

[10:03] <moritz_> not sure

[10:04] <pugssvn> r31295 | sorear++ | [dfa/Cursor] Fix a little fossillized bug 

[10:14] <moritz_> pmichaud: I think S02-builtin_data_types/array_extending.t 19 - join on extended array  looks fine; I don't think our arrays are specced to be sparse

[10:16] <pugssvn> r31296 | moritz++ | [t/spec] be less strict about return types from $/.caps and .chunks 

[10:18] *** gbacon left
[10:19] <Tene> how to run spectest in parallel?

[10:20] *** tadzik left
[10:20] * sorear is reading ECMA-335 "Common language infracstructur"

[10:20] <Tene> ah, TEST_JOBS=4

[10:22] *** tadzik joined
[10:23] <cognominal> rakudo:  say  <  .. . > >>~~>>  :d

[10:24] <p6eval> rakudo 272191: OUTPUT«11␤»

[10:24] <cognominal> rakudo:  say  <  .. . > ~~  :d

[10:24] <p6eval> rakudo 272191: OUTPUT«Method 'd' not found for invocant of class 'Parcel'␤  in 'Enum::ACCEPTS' at line 4577:CORE.setting␤  in 'infix:<~~>' at line 347:CORE.setting␤  in main program body at line 11:/tmp/t5_MpJg3oj␤»

[10:25] <cognominal> hum, I thought it would return if either any or all elements matched in the list.

[10:27] <moritz_> well, that's exactly the problem - any or all?

[10:27] <cognominal> Also I naively expected that, in list context,  ~~ with a Positional in the left would act as a grep.

[10:27] <moritz_> which is why we force any() or all() from the user

[10:28] <cognominal> rakudo:  say  all( <  .. . > ) ~~  :d

[10:28] <p6eval> rakudo 272191: OUTPUT«all(Bool::True)␤»

[10:33] *** azawawi joined
[10:34] <cognominal> that leads to the problem of error messages, an helpful error message in term of ACCEPTS  would not so helpful

[10:35] <ciphertext> rakudo: say (*..5).WHAT;

[10:35] <p6eval> rakudo 272191: OUTPUT«Range()␤»

[10:36] <azawawi> sorear: ping

[10:36] <azawawi> hi moritz_ 

[10:40] <pugssvn> r31297 | sorear++ | [dfa/Cursor] Tiebreak in favor of the _longest_ literal prefix... 

[10:40] <ciphertext> rakudo: my @a = 1..5; say @a[0..*];

[10:40] <p6eval> rakudo 272191:  ( no output )

[10:41] <sorear> azawawi: pong

[10:48] <sorear> TimToady: I may have found a bug in STD.pm6... look at mod_internal:oops, it has a literal prefix of length 1, look at mod_internal:sym<:i>, 0, dfa/Cursor tiebreaks in favor of oops...

[10:48] * sorear -> sleep

[10:54] *** ggoebel joined
[11:01] *** xabbu42 joined
[11:05] *** azert0x joined
[11:06] *** broquaint left
[11:09] *** rgrau_ joined
[11:18] *** rv2733 joined
[11:18] <moritz_> hi azawawi 

[11:20] *** rv2733 left
[11:25] <moritz_> rakudo: my $x = 3; repeat { $x++ } until $x > 5; say $x

[11:25] <p6eval> rakudo 272191: OUTPUT«6␤»

[11:33] *** azawawi left
[11:37] *** TiMBuS joined
[11:37] *** envi^home joined
[11:43] *** [Coke] joined
[11:44] *** xabbu42_ joined
[11:44] *** xabbu42 left
[11:44] *** xabbu42_ is now known as xabbu42

[11:44] *** arthur-- left
[11:45] *** am0c joined
[11:55] *** rob-_- left
[11:56] <takadonet> morning all

[11:59] *** rob-_- joined
[12:00] *** arthur-- joined
[12:02] <szabgab> my $fh = open 'README', :r; for $fh.get -> $line { say $line }

[12:02] <szabgab> only reads the first line

[12:02] <szabgab> for lines('README') -> $line { say $line }

[12:03] <szabgab> worked

[12:03] *** bluescreen joined
[12:03] <moritz_> for $fh.lines -> ...

[12:03] <moritz_> .get is one item only

[12:03] <szabgab> what does .get do ?

[12:03] *** bluescreen is now known as Guest37981

[12:03] <szabgab> my $fh = open 'README', :r; while (my $line = $fh.get) { say $line }

[12:03] <szabgab> also just one line

[12:04] <moritz_> that's dangerous

[12:04] <moritz_> because i autochomps

[12:04] <moritz_> *it

[12:04] <szabgab> which one?

[12:04] <moritz_> so if i's an empty line or zero, the loop terminates

[12:05] <szabgab> .lines autochomps as I can see

[12:05] <moritz_> both .get and .lines

[12:05] <szabgab> ok

[12:05] <szabgab> aha

[12:05] <szabgab> so it won't work as in p5

[12:05] <moritz_> so while (my $line= $fh.get) is not nice

[12:05] <moritz_> right

[12:05] *** [Coke] left
[12:06] *** dual left
[12:06] <szabgab> my $fh = open 'README', :r; while (my $line = $fh.get).defined { say $line }

[12:06] <szabgab> worked :)

[12:06] <moritz_> that's so p5

[12:06] * szabgab hides

[12:06] <szabgab> but that helped understanding

[12:07] <szabgab> for lines('README') -> $line { say $line }

[12:07] <szabgab> looks the best so far

[12:07] <moritz_> aye

[12:07] *** [Coke] joined
[12:08] <Su-Shee> hm, say for lines('README')? :) 

[12:08] <moritz_> .say please

[12:08] <szabgab> when opening a file do we now check return values? as in    if my $fh = open 'README', :r { ... }  ?

[12:08] <tadzik> btw, is there any neat while(<>) equivalent in Perl 6?

[12:09] <moritz_> szabgab: the paradigm is not to check the return value

[12:09] <szabgab> or we just let it die (or not)

[12:09] <moritz_> szabgab: but just use it, and it will die if used and the open did't work

[12:09] <Su-Shee> tadzik: readlines or getlines or something for starters. 

[12:09] <moritz_> though it might not yet throw the right exception in rakudo

[12:15] <colomon> wait, does that mean open or die doesn't work anymore?

[12:18] <moritz_> I think it should still work, but it should be redundant

[12:19] <moritz_> btw I have a fix for .match with :g and :nth in the list branch

[12:19] <moritz_> spectesting now

[12:20] *** rob-_- left
[12:20] <colomon> moritz_: I just pushed a fix for that.

[12:20] * moritz_ too slow

[12:21] <moritz_> actually I fixed before lunch, and forgot to  spectest an push

[12:21] <colomon> doh!  sorry about that.

[12:22] <moritz_> my own fault entirely

[12:23] <moritz_> I did't about it before, so you couldn't have known

[12:23] *** skids joined
[12:24] <moritz_> s/missing verb/talk/ :-)

[12:25] *** rob-_- joined
[12:27] *** mjk joined
[12:27] <colomon> http://gist.github.com/440594 is my list of failing tests (pre-match fix)

[12:27] <moritz_> colomon: your fix is nicer than mine

[12:27] <colomon> seems like main-usage.t (for instance) is probably just lagging behind the master branch?

[12:27] <colomon> thank you.

[12:28] <moritz_> when was the last merge from trunk?

[12:28] *** xabbu42_ joined
[12:28] *** xabbu42 left
[12:28] *** xabbu42_ is now known as xabbu42

[12:28] <colomon> hmmm, just seven hours ago?

[12:29] <moritz_> then it's something else

[12:29] <colomon> well, bother.  so much for that theory.

[12:30] <colomon> Can you take a look at that one?  I think you know that stuff infinitely better than I do.

[12:30] <moritz_> will do

[12:31] *** [Coke] left
[12:31] <moritz_> might not be able to do it now, I'm in a meeting

[12:32] <colomon> no worries

[12:32] *** xabbu42_ joined
[12:32] *** xabbu42 left
[12:32] *** xabbu42_ is now known as xabbu42

[12:34] <moritz_> seems like a flattening problem in MAIN_HELPER

[12:39] *** masonkramer left
[12:40] *** masonkramer joined
[12:44] *** clintongormley joined
[12:44] *** mjk left
[12:48] <colomon> .trans bugs seem to be yet another Range issue.  :(

[12:48] <colomon> obviously the Range tests are less than great.

[12:48] <colomon> I've already got improved ones I'm not pushing since I think they won't work in master.

[12:49] * moritz_ ponders a github branch of the spectests for list

[12:50] *** pmurias joined
[12:50] <pmurias> hi

[12:50] <tadzik> hi

[12:50] <pmurias> tadzik: which city in Poland are you from?

[12:50] <tadzik> Warsaw

[12:51] <tadzik> well, near Warsaw, but you wouldn't probably recognise Izabelin anyway :)

[12:51] * pmurias studies in Wroclaw

[12:52] *** dlm joined
[12:52] <dlm> perl6: 3+3

[12:52] <p6eval> elf 31297, pugs, rakudo 272191:  ( no output )

[12:52] <dlm> perl6: 3+3.perl

[12:52] <p6eval> elf 31297, pugs, rakudo 272191:  ( no output )

[12:52] <dlm> perl6: 3+3.perl.say

[12:52] <p6eval> elf 31297, pugs, rakudo 272191: OUTPUT«3␤»

[12:52] <dlm> perl6: (3+3).perl.say

[12:52] <p6eval> elf 31297, pugs, rakudo 272191: OUTPUT«6␤»

[12:52] <moritz_> wow, all three agree

[12:53] <dlm> perl6: (3 div 3).perl.say

[12:53] <p6eval> rakudo 272191: OUTPUT«1␤»

[12:53] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "div"␤    expecting operator or ")"␤    at /tmp/18o_S0iUeC line 1, column 4␤»

[12:53] <p6eval> ..elf 31297: OUTPUT«Undefined subroutine &GLOBAL::infix_div called at (eval 124) line 3.␤ at ./elf_h line 5881␤»

[12:53] *** dual joined
[12:54] <pmurias> would it be possible to take elf out of the evalbot?

[12:54] <dlm> perl6: (3..*).perl.say

[12:55] <p6eval> elf 31297: OUTPUT«Undefined subroutine &GLOBAL::whatever called at (eval 126) line 3.␤ at ./elf_h line 5881␤»

[12:55] <p6eval> ..pugs:  ( no output )

[12:55] <p6eval> ..rakudo 272191: OUTPUT«3..*␤»

[12:55] <moritz_> pmurias: sure, should be a simple patch

[12:55] <moritz_> mildew: say (1..3).perl

[12:55] *** sorear left
[12:56] <p6eval> mildew: OUTPUT«Can't open perl script "mildew": No such file or directory␤»

[12:56] *** sorear joined
[12:56] <dlm> perl6: sub x(Whatever $x) { say $x.perl } x(*)

[12:58] <p6eval> rakudo 272191:  ( no output )

[12:58] <p6eval> ..pugs: OUTPUT«\Inf␤»

[12:58] <p6eval> ..elf 31297: OUTPUT«syntax error at (eval 130) line 3, near "(sub x"␤"my" variable $Call::Api can't be in a package at (eval 130) line 3, near "($Call::Api"␤syntax error at (eval 130) line 6, near ")}"␤ at ./elf_h line 5881␤»

[12:59] <colomon> rakudo: sub x(Whatever $x) { say $x.perl }; x(*)

[12:59] <moritz_> I think there's a ticket for that in RT

[12:59] *** perlygatekeeper joined
[12:59] <colomon> k.

[12:59] <p6eval> rakudo 272191: OUTPUT«!whatever_dispatch_helper␤»

[13:00] <colomon> errr, except it works.  :)

[13:00] <moritz_> rakudo: sub f($x) { say $x.WHAT }; f *

[13:01] <moritz_> slooow

[13:01] <p6eval> rakudo 272191: OUTPUT«Whatever()␤»

[13:02] <huf> .oO(say $x.WHAT.AGAIN) (i know it's old...)

[13:02] <cono> rakudo: %*VM.perl.say

[13:05] <p6eval> rakudo 272191:  ( no output )

[13:06] <cono> %*VM removed?

[13:06] <moritz_> rakudo: say %*VM<config><revision>

[13:07] <p6eval> rakudo 272191: OUTPUT«47640␤»

[13:07] <cono> ah :)

[13:09] <cono> moritz_: in REPL I have: Method 'postcircumfix:<{ }>' not found for invocant of class 'Failure'

[13:09] <cono> but perl6 -e 'say %*VM<config><revision>' works fine

[13:09] <moritz_> huh

[13:09] <moritz_> please submit  rakudobug

[13:10] <cono> ok, thanks )

[13:10] *** xabbu42 left
[13:10] *** xabbu42 joined
[13:11] <tadzik> rakudo: {"hash" => {"three" => "four", "one" => "two"}, "foo" => "bar"}.say

[13:11] <p6eval> rakudo 272191:  ( no output )

[13:11] <tadzik> oh you. Works for me

[13:12] <moritz_> seems like the load on that server is too high

[13:12] <cono> rakudo: ("hash" => ("three" => "four", "one" => "two"), "foo" => "bar").perl.say

[13:12] <p6eval> rakudo 272191: OUTPUT«("hash" => ("three" => "four", "one" => "two"), "foo" => "bar")␤»

[13:13] <moritz_> one of the pugs processes hang

[13:13] <moritz_> don't know why the CPU time limit didn't work :(

[13:13] <tadzik> rakudo: my $x = 5; $x.say.WHAT

[13:13] <p6eval> rakudo 272191: OUTPUT«5␤»

[13:14] <tadzik> what does WHAT do in this case?

[13:14] <moritz_> it returns the type object of the return value of say

[13:14] <moritz_> in void context

[13:14] <moritz_> so it has no effect

[13:14] <tadzik> mhm

[13:14] <tadzik> rakudo: my $x = 5; $x.say.WHAT.say

[13:14] <p6eval> rakudo 272191: OUTPUT«5␤Bool()␤»

[13:16] <colomon> Okay, Range works better, and so trans.t works again (on list)

[13:17] <moritz_> \o/

[13:18] <mathw> rakudo: enum Alignment <top middle bottom>; my Alignment $a = Alignment::top; $a.WHAT.say;

[13:19] <p6eval> rakudo 272191: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/CJvSM8MB8Q␤»

[13:19] <pugssvn> r31298 | pmurias++ | [smop] changed %mold to %yeast 

[13:19] *** Guest71658 left
[13:20] *** JimmyZ joined
[13:22] *** JimmyZ left
[13:22] <Zapelius> any progress on this one ? http://rt.perl.org/rt3//Public/Bug/Display.html?id=74078

[13:23] *** JimmyZ joined
[13:23] <colomon> rakudo: role Animal { method speak() { say "Blah"; } }; role

[13:23] <colomon> Canine does Animal { method speak() { say "Howl"; }}; class Dog does

[13:23] <colomon> Canine { }; Dog.new.speak

[13:23] <p6eval> rakudo 272191: OUTPUT«===SORRY!===␤Malformed package declaration at line 11, near ""␤»

[13:23] <colomon> rakudo: role work { method x {say 'hello'}}; class me does work {}; me.new.x()

[13:23] <p6eval> rakudo 272191: OUTPUT«Could not find sub &say␤  in 'x' at line 11:/tmp/aE2qOewgnJ␤  in main program body at line 11:/tmp/aE2qOewgnJ␤»

[13:23] <Zapelius> it's kind of nasty to have lines like << our &bug_sprintf = &sprintf;  >> :)

[13:23] <colomon> no resolution, anyway.  :(

[13:28] *** sawyer_ left
[13:34] *** gbacon joined
[13:34] *** sdvsdvsdv joined
[13:35] *** arthur-- left
[13:38] *** cdarroch joined
[13:38] *** cdarroch left
[13:38] *** cdarroch joined
[13:38] *** uniejo left
[13:39] *** sawyer_ joined
[13:40] *** araujo left
[13:41] *** araujo joined
[13:42] *** araujo left
[13:57] *** wallberg left
[13:59] *** Zapelius left
[14:09] *** Guest23195 joined
[14:13] <pmichaud> good morning, #perl6

[14:13] <colomon> o/

[14:13] <colomon> you're awake already?!

[14:14] <colomon> I figured we wouldn't see you for another six hours or so....

[14:16] *** rob-_- left
[14:16] <pmichaud> I'm awake already.  :-)

[14:17] <pmichaud> I want to finish the branch.  :-)

[14:17] <moritz_> does parallel dispatch and Z=> work in the branch?

[14:17] <pmichaud> 10:14 <moritz_> pmichaud: I think S02-builtin_data_types/array_extending.t 19 - join on extended array  looks fine; I don't think our arrays are specced to be sparse

[14:17] <pmichaud> I agree, arrays aren't sparse.

[14:17] <pmichaud> So, with

[14:18] <pmichaud> my @a;   @a[2] = 'x';   say @a.join(':');    

[14:18] *** plobsing joined
[14:18] <pmichaud> I would expect that to be the same as @a[0] ~ ':' ~ @a[1] ~ ':' ~ @a[2] 

[14:19] <pmichaud> and then question then becomes, what are the values of @a[0] and @a[1]?  ;-)

[14:19] <[particle]> Nil

[14:19] <moritz_> Any

[14:19] <pmichaud> ...and how does Any stringify?

[14:19] <pmichaud> rakudo;  say Any

[14:19] <pmichaud> rakudo:  say Any

[14:19] <p6eval> rakudo 272191: OUTPUT«Any()␤»

[14:20] <pmichaud> so I would expect   "Any():Any():x"   as the result.

[14:20] <moritz_> pmichaud: it ~es to '', and .Stres to Any

[14:20] <pmichaud> okay.

[14:20] <[particle]> rakudo: say Any.Str

[14:20] <p6eval> rakudo 272191: OUTPUT«Any()<0x23b4c70>␤»

[14:20] <moritz_> it needs the Stringy vs. Str distinction for type objects

[14:20] <colomon> pmichaud: I'm running spectest (well, test_summary.pl) on the latest, unless you or moritz_ have very recent changes

[14:20] <pmichaud> colomon: I'm about to do the same.  :0

[14:21] <pmichaud> :)

[14:21] * moritz_ hasn't

[14:21] <moritz_> since we don't have that distinction yet, I'd be fine with regressing on that test

[14:21] <colomon> moritz_++ and I fixed a number of things while you were sleeping.  :)

[14:21] <pmichaud> colomon: this is what I was hoping for :)

[14:21] <pmichaud> moritz_: I agree, we'll regress.

[14:21] <colomon> pmichaud: still plenty to go, of course. 

[14:22] <pmichaud> I think there were only 90 failing tests when I went to sleep a few hours ago

[14:22] <pmurias> diakopter: hi

[14:23] <colomon> pmichaud: that count doesn't actually get entire files that fail, does it?

[14:23] <pmichaud> colomon: well, it does if it can.

[14:23] <pmichaud> i.e., if it doesn't have 'plan *'

[14:23] <colomon> I'll have a current error list in a couple of minutes (it's currently testing cotanh.t)

[14:24] <colomon> A number of the remaining issues seem to involve junctions.

[14:24] <pmichaud> excellent.  I know there's a bug with list assignment that is affecting S06-parameters

[14:24] <pmichaud> yeah, I'm not quite sure what's up with junctions yet

[14:25] *** ash__ joined
[14:26] <pmichaud> afk for a short bit

[14:30] *** macdaddy joined
[14:32] <colomon> http://gist.github.com/440780

[14:32] <colomon> (failures)

[14:32] *** xabbu42_ joined
[14:32] *** xabbu42 left
[14:32] *** xabbu42_ is now known as xabbu42

[14:32] <colomon> 31 by count, but it looks like that includes about seven files without plans.

[14:34] <[particle]> yeah, i count 31 too

[14:34] <colomon> one of those files is range-iterator.t, which is completely 100% wrong in the new system.

[14:34] <colomon> just going to disable it.

[14:34] <lue> hai

[14:35] <colomon> o/

[14:35] <moritz_> if it's wrong, delete it

[14:35] <dlm> perl6: Nil.say

[14:35] <p6eval> pugs: OUTPUT«*** No such subroutine: "&Nil"␤    at /tmp/5nYZ8f6OGd line 1, column 1 - line 2, column 1␤»

[14:35] <p6eval> ..elf 31298: OUTPUT«Can't locate object method "say" via package "Nil" (perhaps you forgot to load "Nil"?) at (eval 122) line 3.␤ at ./elf_h line 5881␤»

[14:35] <p6eval> ..rakudo 272191: OUTPUT«␤»

[14:35] <dlm> perl6: Nil().say

[14:35] <p6eval> elf 31298: OUTPUT«Undefined subroutine &GLOBAL::circumfix_N_32_41 called at (eval 123) line 3.␤ at ./elf_h line 5881␤»

[14:35] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&Nil"␤    at /tmp/0k7XPUjT_6 line 1, column 1 - line 2, column 1␤»

[14:35] <p6eval> ..rakudo 272191: OUTPUT«␤»

[14:35] <dlm> perl6: say Nil

[14:35] <p6eval> pugs: OUTPUT«*** No such subroutine: "&Nil"␤    at /tmp/XMMEZB0Wb6 line 1, column 5 - line 2, column 1␤»

[14:35] <p6eval> ..elf 31298: OUTPUT«Nil␤»

[14:35] <p6eval> ..rakudo 272191: OUTPUT«␤»

[14:36] <dlm> perl6: say perl 3

[14:36] <p6eval> elf 31298: OUTPUT«Undefined subroutine &GLOBAL::perl called at (eval 123) line 3.␤ at ./elf_h line 5881␤»

[14:36] <p6eval> ..rakudo 272191: OUTPUT«Could not find sub &perl␤  in main program body at line 11:/tmp/K4EqJ0eh3Y␤»

[14:36] <p6eval> ..pugs: OUTPUT«3␤»

[14:36] <dlm> perl6: say 3.perl

[14:36] <p6eval> elf 31298, pugs, rakudo 272191: OUTPUT«3␤»

[14:36] <colomon> moritz_: well, at some point someone should probably go in and re-write it.  but the Spec hasn't finalized yet...

[14:36] <dlm> rakudo: say 3 + Nil

[14:36] <p6eval> rakudo 272191: OUTPUT«3␤»

[14:37] <dlm> rakudo: say(3 + Nil)

[14:37] <p6eval> rakudo 272191: OUTPUT«3␤»

[14:37] <dlm> rakudo: say(3 * Nil)

[14:37] <p6eval> rakudo 272191: OUTPUT«0␤»

[14:37] <dlm> rakudo: say(3 * Nil.Num)

[14:37] <p6eval> rakudo 272191: OUTPUT«0␤»

[14:37] <dlm> rakudo: say Nil.Num.perl

[14:37] <p6eval> rakudo 272191: OUTPUT«0␤»

[14:38] <dlm> rakudo: say Nil.WHAT

[14:38] <p6eval> rakudo 272191: OUTPUT«Parcel()␤»

[14:38] <dlm> rakudo: say *.WHAT

[14:38] <p6eval> rakudo 272191: OUTPUT«Whatever()␤»

[14:42] *** xabbu42_ joined
[14:42] *** xabbu42 left
[14:42] *** xabbu42_ is now known as xabbu42

[14:42] <moritz_> $ ./perl6 -e 'sub x { my @a = 4, 5; return @a, 6 }; my (@b, $x) = x(); say @b.perl'

[14:42] <moritz_> [[4, 5, 6]]

[14:43] <moritz_> I think it's not a new bug

[14:44] <pmichaud> if it's not a new bug, that makes me feel better then :)

[14:44] <pmichaud> (because it should be an easier fix)

[14:44] <moritz_> I think I know what's wrong with MAIN/USAGE

[14:45] <moritz_> it assumes that %hash isn't flattening in return() argument lists

[14:47] *** thebird joined
[14:47] *** thebird left
[14:48] <moritz_> push fixed

[14:49] <moritz_> one failing test remaining in there

[14:49] <moritz_> uhm

[14:50] <moritz_> that might be failing due to debug output to STDERR, which Test::Util captures :-)

[14:52] <moritz_> bingo

[14:52] *** thebird joined
[14:52] <moritz_> all tests pass

[14:52] <moritz_> without further changes

[14:52] <moritz_> so my commit message was a lie

[14:54] *** plobsing left
[14:54] <moritz_> so, 7 failures down

[14:54] <colomon> \o/

[14:56] <moritz_> cross.t seems a junction infinite recursion

[14:57] <pmichaud> .oO( cross is using junctions? )

[14:57] <moritz_> the tests

[14:57] *** ash__ left
[14:57] <moritz_> ok 15 - all @list1 X<= @list2

[14:57] <moritz_> is the one before the loop

[14:57] <pmichaud> I'm looking at junctions now.

[14:58] <moritz_> the test that loops is

[14:58] <moritz_> ok ( ? [|] 1, 2 X<= 0, 3),     '[|] @l1 X<= @l2';

[15:00] <colomon> ambitious test.  :)

[15:00] <cono> anyone here booked my one hotel galilei for yapsi already?

[15:00] <moritz_> precdence issue?

[15:00] <moritz_> > say ? [|] (1, 2 X<= 0, 3).perl

[15:00] <colomon> moritz_: seems unlikely, grammar hasn't changed, has it?

[15:00] <moritz_> 1

[15:00] <moritz_> colomon: I mean in the test... even then it still exhibits a rakudo bug wrt autothreading

[15:01] <moritz_> > [|] 1

[15:01] <moritz_> 1

[15:01] <moritz_> > [|] 1, 2

[15:01] <moritz_> maximum recursion depth exceeded

[15:01] <colomon> moritz_++

[15:02] *** thebird left
[15:02] <colomon> rakudo: say [|] 1, 2

[15:02] *** thebird joined
[15:02] <p6eval> rakudo 272191: OUTPUT«any(1, 2)␤»

[15:02] <pmichaud> that's either a reduce or a junction bug.

[15:02] <pmichaud> (unless we short-circuit [|] to any)

[15:03] <colomon> reduce seems to be working in general and junctions have known issues...  ;)

[15:03] <pmichaud> sure, I agree

[15:03] <pmichaud> just didn't want the other path to be unobserved :)

[15:03] <colomon> indeed.

[15:03] <colomon> let me dump what I'm looking at here, then I'll take a look at that.

[15:03] <colomon> called from Sub '!postcircumfix:<[ ]>' pc 11868 (src/gen/RoleToInstanceApplier.pir:142)

[15:03] <colomon> called from Sub 'postcircumfix:<[ ]>' pc 404238 (src/gen/core.pir:35506) (CORE.setting:1074)

[15:04] <pmichaud> ah

[15:04] <pmichaud> anytime postcircumfixes are involved, it often means that it's being called on something that isn't p6opaque

[15:04] <colomon> is the infinite recursion I'm seeing, doing @x.unshift(2), where my Int @x.

[15:04] <colomon> (in a typed arrays.t test)

[15:04] <moritz_> and S03-junctions/misc.t aborts with "Method 'map' not found for invocant of class 'ResizablePMCArray'"

[15:05] <pmichaud> in this case, I think the problem is that postcircumfix:<[ ]>  is being called on the $.eigenstates attribute of the junction, which is a RPA

[15:05] <pmichaud> ("this case" == both what colomon++ and moritz++ observed)

[15:05] <pmichaud> I suppose the easiest thing to do would be to promote $.eigenstates to a Parcel.

[15:06] <pmichaud> that would make.... a lot of sense.

[15:07] <pmichaud> in src/builtins/Junction.pir, line 77

[15:07] <pmichaud> add

[15:07] <pmichaud>     eigenstates = '&infix:<,>'(eigenstates :flat)

[15:08] <pmichaud> right before the setattribute

[15:08] <pmichaud> and then see if that fixes anything

[15:09] * moritz_ would kinda expect the fix to go into the uniq_helper

[15:09] <pmichaud> sometimes uniq_helper isn't called.

[15:09] <pmichaud> see the 'if' condition a few lines earlier.

[15:10] <moritz_> right

[15:10] * moritz_ tries

[15:11] <pmichaud> I wonder how it is that method 'new' knows that eigenstates is already an RPA, though.

[15:12] <pmichaud> that seems bogus.

[15:12] <pmichaud> oh!

[15:12] <pmichaud> it is bogus.

[15:12] <colomon> fail.

[15:12] *** ash__ joined
[15:12] <colomon> flattened parameters must be a hash or array

[15:12] <colomon> current instr.: 'perl6;Junction;new' pc 17316 (src/builtins/Exception.pir:93)

[15:12] <colomon> called from Sub 'infix:<^>' pc 348420 (src/gen/core.pir:0) (CORE.setting:392)

[15:12] <pmichaud> right

[15:13] <pmichaud> that whole Junction construction logic needs a serious rework.

[15:13] <colomon> that's running t/spec/S03-junctions/misc.t

[15:13] <pmichaud> it makes quite a few bad assumptions.

[15:13] <pmichaud> for one, it prevents   Junction.new()  from being called with multiple positional arguments

[15:15] * moritz_ tests if adding :slurpy to eigenstates helps

[15:15] <pmichaud> that will just cause other issues, alas

[15:15] <pmichaud> because then the eigenstates will end up being an array of (unflattened) lists

[15:16] <pmichaud> it's a non-trivial change to fix this

[15:16] <pmichaud> I'll work on Junctions real quick -- I can get to the list assignment bug in a bit

[15:17] *** xabbu42_ joined
[15:17] *** xabbu42 left
[15:17] *** xabbu42_ is now known as xabbu42

[15:26] * pmichaud tries running his fixes

[15:28] *** constant left
[15:29] *** pmurias left
[15:31] <pmichaud> aha

[15:31] <pmichaud> with that fix, S03-junctions/misc.t passes

[15:32] <colomon> \o/

[15:32] <pmichaud> pushed as 5e523b1

[15:32] *** constant joined
[15:32] *** constant left
[15:32] *** constant joined
[15:35] <colomon> errr... why does yapc::na have a kilt vendor coming?  

[15:36] <colomon> I mean, I've nothing against it, but I expected that at the Highland games I'm going to on Saturday, not the Perl conference next week.  :)

[15:36] <pmichaud> there are quite a few attendees who like to wear kilts :)

[15:37] <[particle]> utilikilt pulled out

[15:37] <[particle]> or we could have had seattle kilts at yapc

[15:37] <colomon> my wife just informed me that if I'm going to get a kilt, it has to be a real one, no utilikilts allowed.

[15:37] <pmichaud> http://yapc2010.com/yn2010/wiki?node=Utilikilts

[15:38] <pmichaud> (to judge the level of interest :)

[15:41] *** Ross joined
[15:43] *** justatheory joined
[15:44] *** PacoLinux left
[15:45] <TimToady> do we need a .lazypush, or is .push already lazy?

[15:45] *** PacoLinux joined
[15:45] <pmichaud> it's lazy.

[15:45] *** xabbu42_ joined
[15:45] *** xabbu42 left
[15:45] *** xabbu42_ is now known as xabbu42

[15:45] <pmichaud> in the Rakudo implementation, it's lazy.

[15:45] <pmichaud> (the new one)

[15:45] <pmichaud> so is splice :-)

[15:46] <pmichaud> (splice is lazy after   $offset or $offset+$size elements)

[15:48] *** Gothmog_ left
[15:48] <colomon> can we do @a, @b if @a and @b are lazy?

[15:48] <pmichaud> you mean make a parcel of @a and @b?

[15:48] <TimToady> okay, so we can initialize the lazy part of any array with: my @x.push: 1...*

[15:48] <colomon> pmichaud: a flat parcel, I mean.  

[15:48] <pmichaud> well, I'm testing lazy push now and it doesn't seem to be working.

[15:49] <pmichaud> It's supposed to be lazy, at any rate.  I don't see any blockers to that.

[15:49] <pmichaud> colomon:  sure

[15:50] <pmichaud> TimToady: yes, that makes sense to me

[15:50] <pmichaud> oh, wait

[15:50] <pmichaud> we might want a lazy push

[15:50] <pmichaud> right now     @a.push(@b)   eagerly evaluates @b

[15:51] <pmichaud> because we don't want subsequent changes to @b to show up in @a

[15:51] <pmichaud> I suppose we could try to make   @a.push(lazy @b)  work somehow

[15:51] <TimToady> but you can't overcome the eagerness with @a.push(lazy @b), hence the need for a different method

[15:52] <TimToady> I don't see how it can work

[15:52] <colomon> if we just pushed the iterator, wouldn't it automatically not reflect subsequent changes to @b?

[15:52] <pmichaud> okay

[15:52] <pmichaud> colomon: it still gets eagerly evaluated by the .push

[15:52] <colomon> oh, not if we are iterating an Array @b.

[15:52] *** literal left
[15:53] <pmichaud> TimToady: yeah, I can see why it won't work.

[15:53] <TimToady> @a.queue(@b)

[15:53] *** Gothmog_ joined
[15:53] <TimToady> @a.cue(@b)

[15:53] <pmichaud> anyway, the splicing is non-lazy for the same reason.

[15:53] <moritz_> @a <<== @b

[15:53] <pmichaud> my *Lists* have lazy push and splice, but *Array* does not.

[15:54] <TimToady> @a.push vs @a.lean :)

[15:54] <pmichaud> my @a := List.new.push(1...*);   # initializes lazy part

[15:54] <TimToady> perhaps push should always imply eager, and we use something else when we want to be less pushy

[15:55] <TimToady> $x.queue $x.spec $x.add $x.connect $x.extend ...

[15:56] <TimToady> p5 programmers will certainly expect .push to be eager

[15:56] <TimToady> $x.more

[15:57] <TimToady> $x.cont

[15:57] <pmichaud> .lazypush really isn't so bad :)

[15:57] <pmichaud> it's at least explicit :)

[15:57] <colomon> @a ,= @b

[15:58] <TimToady> .feed

[15:58] <Juerd> push :lazy not an option?

[15:59] <TimToady> my @a <== 1...*

[15:59] *** araujo joined
[15:59] <TimToady> possibly with .feed underneath

[16:00] <TimToady> @a.feed: 1..*

[16:01] <TimToady> seems to read pretty well, and feeds are known to be lazy/async-ish

[16:01] *** JimmyZ left
[16:02] <pmichaud> Something gives me a twinge about .feed, but I'm okay with it

[16:03] <PerlJam> $news.feed

[16:03] *** sdvsdvsdv left
[16:03] <TimToady> @a.fed: 1...*

[16:04] <TimToady> makes it somewhat subjunctive

[16:04] <PerlJam> TimToady: hey, can you answer a language question for me?  (or at least take a stab at it)

[16:04] <TimToady> sure, it just won't be correct

[16:05] *** am0c left
[16:06] <PerlJam> TimToady: maybe it's not so much a language question ... but you know how some people say "deaf" when they're trying to pronounce the word "death" ... I was wondering if there is an equivalent of "mispronunciation but the message comes across anyway" in perl

[16:07] <TimToady> .oO(twoo wuv...)

[16:08] <TimToady> most of our dwimmery is semantic, such as Cool

[16:08] <TimToady> and, of course, a written language doesn't have phonology

[16:09] <TimToady> about the closest we come is gently correcting a P5 accent

[16:09] <TimToady> std: my @foo; say $foo[1]

[16:09] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $foo is not predeclared (did you mean @foo?) at /tmp/Zs6bpBHkde line 1:␤------> [32mmy @foo; say $foo[33m⏏[31m[1][0m␤Check failed␤FAILED 00:01 108m␤»

[16:10] <TimToady> but we don't try to keep running

[16:10] <PerlJam> ah. okay.  

[16:10] *** azert0x left
[16:10] <TimToady> std: /[a-z]/

[16:10] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Invalid regex metacharacter (must be quoted to match literally) at /tmp/ZjugtU1J4O line 1:␤------> [32m/[a-[33m⏏[31mz]/[0m␤Potential difficulties:␤  [a-z] appears to be an old-school character class; please use <[a..z]> if you mean a character

[16:10] <p6eval> ..cla…

[16:11] <TimToady> so it's doing accent guessing, but pragmatically speaking that results in diagnostics rather than execution

[16:12] <PerlJam> right.

[16:12] <TimToady> std: say Int.new(42)

[16:12] <p6eval> std 31298: OUTPUT«ok 00:01 104m␤»

[16:12] <TimToady> std: say new Int(42)

[16:12] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of C++ constructor syntax; in Perl 6 please use method call syntax at /tmp/lBZtNvyiN8 line 1:␤------> [32msay new Int[33m⏏[31m(42)[0m␤Parse failed␤FAILED 00:01 104m␤»

[16:12] <TimToady> std: say new Int: 42

[16:13] <p6eval> std 31298: OUTPUT«ok 00:01 106m␤»

[16:13] <PerlJam> I was thinking this morning that Perl is big enough that there has to be some instances where people have code that accidentally executes properly even though they didn't say the right words.

[16:13] <PerlJam> but I guess that's how @foo[1] worked in Perl 5 too

[16:14] <PerlJam> er, works  :)

[16:15] <TimToady> I suppose if we detect that an input file is in Latin-1 instead of UTF-8 and autotranslate, that's like pervasively compensating for an accent

[16:16] <TimToady> accent compensation requires the detection of consistent inconsistency

[16:16] <PerlJam> in a way perhaps I'm just describing a specific form of dwimmery

[16:17] *** meppl joined
[16:18] *** sdvsdvsdv joined
[16:18] *** literal joined
[16:19] <lue> .oO(now, what needs doing in the rakudo world today?)

[16:19] *** hercynium left
[16:19] *** am0c joined
[16:21] *** pmurias joined
[16:23] *** xabbu42_ joined
[16:23] *** xabbu42 left
[16:23] *** xabbu42_ is now known as xabbu42

[16:25] *** pyrimidine joined
[16:27] *** gbacon left
[16:27] <tadzik> What is the reason of rakudo/parrot slowness today? Is this the side-effect of being in-development? I've seen the post on perl6-users ML complaining about that, but just adding numbers 1..1000 takes almost 20 seconds in Perl6 (about 0 on Perl 5)

[16:28] <Tene> tadzik: Pretty much.  The focus has been on completeness and correctness so far, with very little focus on performance.

[16:29] * jnthn made it home o/

[16:29] <Tene> yay!

[16:29] <colomon> \o/

[16:30] <lue> :D

[16:31] <tadzik> Tene: I see. But isn't it like rakudo is generating PIR for parrot and then parrot runs this low-level stuff itself, or does it work somewhat another way?

[16:31] <jnthn> I loved Kiev, but I must say the temperature here in Sweden is rather more to my liking.

[16:32] <pmichaud> tadzik: it's a large number of reasons for the slowness.  We have a lot of additional type checking and dispatch overhead that takes place that P5 doesn't have to contend with.

[16:32] <pmichaud> Also, P5 has had many years of optimization, we're really just starting.

[16:32] <pmichaud> yes, rakudo generates PIR for Parrot, but it's an awful lot of PIR at the moment.

[16:32] <tadzik> I see

[16:33] <pmichaud> lue: I think we're mostly working on getting the list branch merged today.  I think we're down to ~30 failing tests.

[16:33] <pmichaud> jnthn: \o/  welcome home

[16:33] <jnthn> pmichaud: Thanks :-)

[16:34] <lue> ah

[16:35] <jnthn> pmichaud: Down to 30?! 

[16:36] <jnthn> pmichaud++ # and probably some others ++ too :-)

[16:36] <pmichaud> ah, but I just broke something.

[16:37] <pmichaud> so back to 251 failing tests

[16:37] <pmichaud> (most of that is from an aborted test file)

[16:37] <pmichaud> jnthn: I know we're sub-100.

[16:38] <pmichaud> what is going to be fun (and what I'm really looking forward to) is reviewing and closing rt tickets and todo/skipped tests

[16:38] <pmichaud> I'll probably spend a day on that before I tackle closures.  Also gives the compiler a day to settle down for tomorrow's release.

[16:38] <pmichaud> (also going to write a blog post)

[16:39] <jnthn> pmichaud: OK, good plan.

[16:39] <pmichaud> if I have

[16:40] <pmichaud> ($a, $b, $c) = (1, 2)

[16:40] <pmichaud> what should happen with $c ?

[16:40] <pmichaud> more generally, if I have

[16:40] <pmichaud> ($a, $b, $c) = @x;

[16:40] <pmichaud> what should happen if @x has less than three elements?

[16:41] *** pmurias left
[16:41] <lue> I think, for my ($a, $b $c) = (1,2), $c would be left alone, as if you did my $c [don't know what the spec says though]

[16:41] <TimToady> same as $c = ()

[16:41] * jnthn guessed Nil

[16:42] <pmichaud> okay, no warning or anything like that?

[16:42] <jnthn> iirc, Nil is now defined as () ?

[16:42] <TimToady> yes

[16:43] <pmichaud> jnthn: my ($a, $, $b)   ends up generating a parcel  with ($a, *, $b)   ??

[16:45] <jnthn> pmichaud: Correct.

[16:45] <pmichaud> that seems wrongish

[16:46] <pmichaud> I would've expected an anonymous scalar variable

[16:46] <jnthn> pmichaud: Well, assigning to * throws away the value.

[16:46] <pmichaud> so would assigning to an anonymous scalar container :-)

[16:46] <jnthn> I think there may be another reason it's *...thinking...

[16:46] <TimToady> my $x := my ($a, $, $b)[1]

[16:46] <pmichaud> I'd also be concerned ... right

[16:47] <pmichaud> (my ($a, $, $b))[1]   # should be Any or Mu, not *

[16:48] <pmichaud> also, having   my ($a, @, $b)   would seem to dtwt

[16:48] <jnthn> pmichaud: Oooh, I know why.

[16:48] <TimToady> I was wondering earlier today whether vars should be born Cool instead of Any

[16:48] <jnthn> pmichaud: We used to emit an anonymous scalar.

[16:48] <jnthn> Then Parrot started whining "oh ffs you have two .lex '$', $Pxxx".

[16:49] <pmichaud> oh, then it's not anonymous.  :)

[16:49] <jnthn> Yeah

[16:49] <pmichaud> I'm thinking we should create the viviself portion and not bind it to a name.

[16:49] <pmichaud> but otherwise it acts like a normal scalar container.

[16:49] <jnthn> Looking at it, I think I shoved * in to get us able to actually build against Parrot again.

[16:49] <jnthn> Line 154 onwards, src/Perl6/Compiler/Signature.pm

[16:49] <jnthn> You should be able to change it there and have it work out.

[16:50] <pmichaud> okay.

[16:50] <colomon> http://gist.github.com/440780 -- updated list branch error list

[16:50] <jnthn> I'm not sure if I had other reasons for *

[16:50] <pmichaud> I'll leave it on the todo list... I have to get whatever assignment working anyway.

[16:50] <jnthn> But I suspect it was "oh noes, Parrot just broke Rakudo again" at a point where I didn't have a lot of time on my hands and we needed a fix.

[16:51] <pmichaud> ooc, does * always act like an item?

[16:51] <TimToady> it seems the "everything must have a name" meme is rather entrenched into Parrot at various levels

[16:51] <pmichaud> (sounds like the answer ought to be "no", since * is "whatever")

[16:52] <jnthn> TimToady: When I first re-did a bunch of the object system I had it divorced from the class registry quite nicely.

[16:52] <jnthn> TimToady: Then allison went and reassociated them again. :-|

[16:52] <jnthn> Yet another of the design decisions I made right and was overruled on.

[16:53] <jnthn> </hubris>

[16:53] <jnthn> (and a little irritation too...)

[16:53] <TimToady> "namespaces" == "packages" is the same kind of NameThink

[16:53] <jnthn> Yeah, that's been deeper baked in.

[16:54] <pmichaud> not to mention the fact that the PMC type is "NameSpace".  Why the capital 'S'?

[16:54] <pmichaud> I guess it's  "name space", but I never see it written that way.

[16:54] <pmichaud> "namespace" has no space.  :)

[16:56] <TimToady> parrot would be in much better shape if they adopted the model that everything is born anonymous, and names are always created by poking a ref into a random namespace (and I *don't* mean package)

[16:56] <TimToady> but they made the P5 mistake, only harder

[16:57] *** supernovus joined
[16:57] <jnthn> TimToady: Right, which is what I tried to do with classes.

[17:03] *** gbacon joined
[17:06] *** thebird left
[17:09] *** TiMBuS left
[17:13] *** supernovus left
[17:17] *** dakkar left
[17:19] *** frooh left
[17:19] <[particle]> the parrot team hates the NameSpace design and implementation

[17:20] <[particle]> does that make anyone feel any better?

[17:21] <lue> (hrm, where are custom circumfix operators defined?)

[17:21] *** xabbu42_ joined
[17:21] *** xabbu42 left
[17:21] *** xabbu42_ is now known as xabbu42

[17:21] <lue> as in, the ability to make them.

[17:22] <pmichaud> jnthn: ping

[17:22] <jnthn> pmichaud: pong

[17:23] <moritz_> that was a decent round trip time

[17:23] <pmichaud> is there a way from PIR that I can easily determine if a potential call will find a matching multimethod?

[17:23] <jnthn> pmichaud: .cando

[17:23] <pmichaud> ....on a foreign object.  :-)

[17:23] <moritz_> implemented during that awesome hackathin

[17:23] <jnthn> pmichaud: oh tssssk

[17:24] <jnthn> pmichaud: Well, that's rather harder.

[17:24] <pmichaud> let me rephrase the question

[17:24] <jnthn> pmichaud: I think we cna though.

[17:24] <pmichaud> I have a foreign object, like a hash.

[17:24] <jnthn> pmichaud: Can you give me a step back on what you're wanting to do?

[17:24] *** envi^home left
[17:24] <pmichaud> I want to know if any of the methods defined in Associative will bind to the argument I currently have.

[17:25] <pmichaud> (if not, then I'm going to do something else)

[17:25] <jnthn> pmichaud: But didn't you say all of Associative is in the setting now?

[17:25] <jnthn> pmichaud: Wait, what's foreign?

[17:25] <pmichaud> like a Parrot Hash

[17:25] <jnthn> pmichaud: The multisub?

[17:25] <jnthn> Or the arguments?

[17:25] <pmichaud> the invocant

[17:25] <jnthn> Ah.

[17:26] <jnthn> Let me think a moment, I think the answer is "yes, there's a way"

[17:26] <pmichaud> let me phrase it a different way, then

[17:26] <pmichaud> can I .cando on Associative (from PIR)?

[17:26] <jnthn> .cando is a method on a Routine, not a class/role.

[17:26] <pmichaud> okay

[17:27] <pmichaud> can I look up the multisub from Associative and use .cando on it?

[17:27] <jnthn> So I guess there's a particular method?

[17:27] <jnthn> Yes.

[17:27] <pmichaud> perfect.

[17:27] <pmichaud>     $P0 = get_hll_global ['Associative[::T]'], 'postcircumfix:<{ }>'

[17:27] <pmichaud> $I0 = $P0.cando(args)

[17:27] <jnthn> If you put it in the namespace, yes

[17:27] <jnthn> *but* :-(

[17:27] <pmichaud> it's in the namespace

[17:27] <pmichaud> (we use this now.)

[17:27] <jnthn> We have a problem at the moment.

[17:27] <jnthn> (more)

[17:28] <jnthn> .cando currently doesn't work on Multi, even though Multi ~~ Routine and it's defined in Routine. :-(

[17:28] <jnthn> The reason is that we type-map Multi to Perl6MultiSub

[17:28] <jnthn> But at the moment, methods added during augment aren't getting shoved thorugh to the Parrot namespace for the mapped PMC.

[17:29] <pmichaud> that's actually okay

[17:29] <pmichaud> there's no augmenting taking place here.

[17:29] <jnthn> There is. :-(

[17:29] <jnthn> We augment Routine { method cando ... }

[17:29] <pmichaud> ohhhhh

[17:29] <jnthn> Yeah. :-|

[17:29] <pmichaud> can I do a method lookup on Associative?

[17:30] <jnthn> It won't do quite what you want.

[17:30] <pmichaud> okay.

[17:30] <jnthn> If you find_method on a role, then it needs to pun the role.

[17:30] <jnthn> So it hands back the "punner"

[17:30] <pmichaud> isn't there something that does that already?

[17:30] <jnthn> That's for Parrot's find_method

[17:30] <jnthn> You can of course do .^methods on the role.

[17:31] <jnthn> And pull it out of there.

[17:31] <pmichaud> that's a hash?

[17:31] <pmichaud> rakudo:  say Associative.^methods

[17:31] <p6eval> rakudo 272191: OUTPUT«postcircumfix:<{ }>of␤»

[17:31] <jnthn> A list iirc

[17:31] <jnthn> (per spec)

[17:31] * lue is on a quest to find the code that allows custom/overloading operators

[17:31] <pmichaud> rakudo:  say Associative.^methods.perl

[17:31] <p6eval> rakudo 272191: OUTPUT«Method 'perl' not found for invocant of class 'ResizablePMCArray'␤  in main program body at line 11:/tmp/Z2O9_kkFKv␤»

[17:31] <jnthn> Eww.

[17:31] <pmichaud> yeah, list.

[17:32] <jnthn> But yes, it's a list.

[17:32] <pmichaud> needs to become a Parcel.

[17:32] <pmichaud> anyway

[17:32] <pmichaud> so, I can't really use .^methods to find it by name

[17:32] <jnthn> You can, you just gotta go through a list.

[17:32] <jnthn> Which is hardly efficient. :-(

[17:32] <jnthn> I do wonder if we should spec a :name argument to .^methods

[17:32] <pmichaud> it's okay, this is for foreign objects

[17:33] <jnthn> Like we have for .WALK

[17:33] <pmichaud> it's okay if it's not terribly efficient.  What we're describing will undoubtedly end up being more efficient than what we have now.

[17:33] <pmichaud> and foreign objects "you get what you ask for"

[17:33] <pmichaud> also, once I find it, I could probably cache the result

[17:33] <jnthn> True.

[17:33] <jnthn> Whatever you do, please don't go looking at the Parrot class though.

[17:34] <pmichaud> I try to never do that.

[17:34] <jnthn> OK, good. :-)

[17:34] <pmichaud> this refactor is systematically eliminating our use and reliance on Parrot objects, except for RPA

[17:34] <jnthn> I'm really trying to ween us off that.

[17:34] <pmichaud> (we won't complete it anytime soon, but we're a lot closer)

[17:34] <pmichaud> okay, I'm being called to lunch

[17:35] <jnthn> I want to swap out pretty much all of the meta-model internals in the not too distant future, and having everything using the metamodel rather than poking into guts is a big help. :-)

[17:35] <pmichaud> so, answer is to use Associative.^methods to find the postcircumfix method, cache that, and then use .cando on the method to see if it will bind

[17:35] <jnthn> pmichaud: OK - catch me later if you need some more hints.

[17:35] <pmichaud> I like that answer a lot better than what we have now.

[17:35] <jnthn> pmichaud: Yes, correct. Let me see if I can fix up .cando so it actually works on Multi.

[17:35] <pmichaud> no rush.. right now I just need something that works.

[17:35] <jnthn> pmichaud: Well, it won't quite work without a hack at the moment. :-/

[17:36] <jnthn> e.g. you can $P0 = find_method type_object_of_multi, 'cando' of course.

[17:36] <jnthn> We should probably just instantiate Multi rather than Perl6MultiSub though.

[17:36] <pmichaud> ohhhh!

[17:36] <pmichaud> I have an easier answer

[17:36] <pmichaud> muuuuch easier

[17:37] <pmichaud> the methods defined in associative are finite and known

[17:37] <pmichaud> there's only, like, two

[17:37] <pmichaud> so I can just do my own checking of args via .does

[17:37] <pmichaud> (or .ACCEPTS)

[17:37] <pmichaud> I think the only one I need to check is   .does(Positional)

[17:38] <pmichaud> I'll do that.

[17:39] <jnthn> OK. :-)

[17:39] <jnthn> (I'm gonna try and fix .cando on multis anyway now though.)

[17:40] <lue> I think my finding skills are broken :/

[17:41] *** justatheory left
[17:41] <arnsholt> I'm thinking of writing a fuzzer (or rather, fuzzer generator) for Perl 6 grammars, but would like to solicit some opinions on how to approach the problem

[17:41] *** felipe left
[17:41] <diakopter> arnsholt: sure

[17:42] <arnsholt> Up front I can see two possible approaches to do this:

[17:42] <arnsholt> 1) Write my own grammar and use that. Pro: low entry cost, easy to keep track of (at first at least); Con: I'd essentially be writing yet another Perl 6 grammar

[17:43] <arnsholt> 2) Use Perl6::Grammar (or possibly the Grammar grammar from NQP) with custom action methods. Pro: Excellent coverage; Con: Higher entry cost, harder to get a handle on

[17:43] <diakopter> do you want a false negative fuzzer of a false positive fuzzer

[17:43] <diakopter> (-generator)

[17:44] <arnsholt> Good question, actually

[17:45] <arnsholt> Both would certainly be useful

[17:45] <diakopter> one that creates a tool for testing the backend (to see whether the grammar is actually correct in the first place), or ...

[17:46] <diakopter> one that assumes the grammar is correct and tries to break the parser that was generated from the grammar to see if it will accept invalid inputs or otherwise give an unexpected response from a slightly-invalid/degenerate input

[17:46] <arnsholt> The second is what gave me the idea in the first place

[17:47] <diakopter> yeah, that's the one crackers use

[17:47] *** justatheory_ joined
[17:47] <diakopter> but one that tests for input-permutation coverage is also quite useful

[17:48] <arnsholt> Indeed

[17:49] <arnsholt> At any rate, my question is: which of the two approaches looks the most sensible to you guys?

[17:49] <arnsholt> (A third option would be if there was information about the grammar's rules available at runtime, but I don't think that's the case)

[17:49] <diakopter> I wrote one (of the first type above) that does a breadth-first search (shortest/emptiest alternations first) of the grammar, but also exploring all the edge cases of repetitions.

[17:50] <diakopter> ... with a limit on left recursion

[17:50] *** rv2733 joined
[17:51] <arnsholt> Sounds sensible

[17:52] <lue> Can someone help me find where the code that allows custom operators (infix, circumfix, etc.) is? I think I'm not grepping the right search terms...

[17:54] <ash__> lue: what do you mean? like how they are defined? 

[17:55] *** justatheory_ left
[17:55] <lue> yes. Where does this work:    multi sub infix:<+> . . .

[17:56] <lue> where *is the code that makes* this work, sorry

[17:56] *** Guest37981 left
[17:56] *** xabbu42_ joined
[17:56] *** xabbu42 left
[17:56] *** xabbu42_ is now known as xabbu42

[17:56] <diakopter> arnsholt: I'd use the 2nd approach, but using STD and viv

[17:59] *** pronik` joined
[17:59] *** jferrero joined
[17:59] <ash__> lue: well i know its based off of the sub name all ops are really just subs in perl 6

[18:00] <ash__> sub infix:<+> can be called by saying '4 + 3' or infix:<+>(4, 3) 

[18:00] <ash__> rakudo: say infix:<+>(4, 3)

[18:00] <p6eval> rakudo 272191: OUTPUT«7␤»

[18:01] <ash__> i think it probably is expanding, for instance, infix ops into the full sub name "infix:<sym>" 

[18:02] <arnsholt> diakopter: STD and viv is certainly an even better idea. Thanks!

[18:02] <lue> I actually looked into pmc/Perl6MultiSub.pmc , and that didn't help :D It's hard to find where the magic happens.

[18:02] <arnsholt> lue: The magic is in Perl6::Actions, IIRC

[18:03] <arnsholt> Custom operators are recognised at parse time, and code is generated to handle it

[18:03] <jnthn> lue: It'll be in the actions.pm I think.

[18:04] <jnthn> lue: Unless you mean adding new custom operators, in which case that's in grammar.pm, somewhere near the bottom iirc.

[18:04] <lue> I looked in both those files (using grep). Hm, let's check again.

[18:04] <lue> (I'm trying to get circumfixes working, IIUC)

[18:07] *** pronik` is now known as pronik

[18:07] <jnthn> lue: Well, you'll only find it if you grep for the right thing ;-)

[18:07] <lue> :D Apparently, I've been grepping for 'operators' when grepping 'ops' would've gotten me to the bottom of Grammar.pm :D

[18:08] <jnthn> Oh, you just found it

[18:08] <jnthn> I was gonna tell you to grep for gen_op_if_needed ;-)

[18:10] <lue> Now I can start from there and find out why circumfix is the most miserable failure of the entire family :)

[18:10] *** am0c left
[18:11] <lue> rakudo: multi sub circumfix:<[ ]>(Complex $a) { $a.re;}; say [3]; say [1+2i];

[18:11] <p6eval> rakudo 272191: OUTPUT«No applicable candidates found to dispatch to for 'circumfix:<[ ]>'. Available candidates are:␤:(Complex $a)␤␤  in main program body at line 11:/tmp/lSgPvQQazs␤»

[18:11] *** Guest37981 joined
[18:12] <lue> rakudo: say [3];

[18:12] <p6eval> rakudo 272191: OUTPUT«3␤»

[18:12] <lue> now THAT is interesting...

[18:13] <PerlJam> what is?

[18:13] *** patrickas joined
[18:14] <pmichaud> currently circumfix:<[ ]>  is defined in the builtins, so it can't be multied/overloaded yet

[18:14] <lue> that fact that redefing [ ] thru multi sub completely wipes its original functionality

[18:14] *** xabbu42_ joined
[18:14] *** xabbu42 left
[18:14] *** xabbu42_ is now known as xabbu42

[18:14] <lue> is it because it's in builtins, or because the custom circumfix code just doesn't work?

[18:15] <pmichaud> builtins

[18:15] <jnthn> I think it's a Rakudo bug.

[18:15] <pmichaud> see if you can define a different circumfix

[18:15] *** tadzik left
[18:15] <jnthn> I know that's NYI in terms of the parsing side of things. :-)

[18:15] <PerlJam> rakudo: multi sub circumfix:<[ ]>(Complex $a) { "woot" } ; say [2i]

[18:15] <p6eval> rakudo 272191: OUTPUT«woot␤»

[18:16] <PerlJam> looks like it works modulo the multi issue

[18:16] <jnthn> PerlJam: Yeah, the multi issue is the bug I ment.

[18:16] <jnthn> *mant

[18:16] <pmichaud> and circumfix:<[ ]>  is pretty fundamental -- not sure that we can easily move it into setting just yet.

[18:16] <jnthn> oh ffs, I'm off to buy the pizza I very obviously need.

[18:16] <jnthn> *meant

[18:16] <jnthn> :-)

[18:17] <lue> Meponders... could the space in, say, circumfix:<` `> be the issue?

[18:17] <pmichaud> shouldn't be.

[18:17] *** alester joined
[18:17] <lue> After all, it *is* wrong for other types of operators. Hmm

[18:18] <pmichaud> rakudo:  multi sub circumfix:<` `>(Complex $a) { "xyz" };  say `2i`

[18:18] <p6eval> rakudo 272191: OUTPUT«error:imcc:syntax error, unexpected '\n'␤  in file 'EVAL_1' line 866166138␤===SORRY!===␤syntax error ... somewhere␤»

[18:18] <pmichaud> that looks like a rakudo bug

[18:18] <pmichaud> like it's not recognizing the need to create a new circumfix: token.

[18:18] <jnthn> pmichaud: NYI...

[18:18] <jnthn> pmichaud: It's still in the ROADMAP

[18:19] <jnthn> lue: It may just be a case of some hacking in that gen_op_if_needed method.

[18:20] <lue> That's what I'm looking at. The one time $opname is used is to generate a piece of the $parse variable, which is where the spaces came into mind.

[18:20] <lue> jnthn: pizza travels fast in your neck of the woods, no? :)

[18:20] <pmichaud> .oO( wouldn't it be jnthn++ that travelled fast?  )

[18:21] <lue> Depends. It could be he stays in place and the rest of the universe moves around him :)

[18:21] <PerlJam> or ... he could have invented a time machine!

[18:21] *** sunnavy joined
[18:21] <lue> I would have grown one ;)

[18:22] <jnthn> pmichaud: Actually, jnthn just forgets where he puts his keys fast :-)

[18:22] <jnthn> Found 'em...really going now. :-)

[18:23] <PerlJam> jnthn++ (fail fast)

[18:23] <PerlJam> :-)

[18:23] <lue> rakudo: multi sub circumfix:<``>($a) { say $a;} ` 3 `

[18:23] <p6eval> rakudo 272191: OUTPUT«error:imcc:syntax error, unexpected '\n'␤  in file 'EVAL_1' line 58␤===SORRY!===␤syntax error ... somewhere␤»

[18:23] <lue> rakudo: multi sub circumfix:<``>($a) { say $a;}; ` 3 `

[18:23] <p6eval> rakudo 272191: OUTPUT«error:imcc:syntax error, unexpected '\n'␤  in file 'EVAL_1' line 58␤===SORRY!===␤syntax error ... somewhere␤»

[18:24] <lue> I think the space between the start and end is required. If that's the case, there's obviously a different problem.

[18:25] <PerlJam> interesting ... I just ran my perl6 binary from inside src/builtins and it said: Null PMC access in find_method('new_class')

[18:25] <lue> OH! Should there be a default precedence for circumfix?

[18:26] <PerlJam> http://gist.github.com/441074 

[18:26] <PerlJam> seems to work fine in other dirs.

[18:26] <pmichaud> for aggregates, is there a way to retrieve an element from the aggregate by key/index that isn't postcircumfix:<{ }> ?

[18:26] <pmichaud> and if not, could we define one?

[18:26] <PerlJam> pmichaud: you mean like an alternate method name?

[18:27] <pmichaud> PerlJam: yes, exactly.

[18:27] *** dju left
[18:27] <lue> what would the default precedence for circumfix be? /me gets exicted and hopes the spec is willing to part with info.

[18:27] <pmichaud> but that only handles single item lookups

[18:27] *** dju joined
[18:27] <pmichaud> lue: I'd expect it to be term precedence, myself.

[18:28] <pmichaud> it would be really really helpful if the postcircumfix operators could be defined in terms of a simpler, non-postcircumfix method

[18:28] <pmichaud> (a class could still overload postcircumfix if it wants to do something special)

[18:28] <lue> well, because $prec appears to be unset for circumfix

[18:29] <PerlJam> what would be the damage in using .index() for that purpose on aggregates?

[18:29] <lue> i.e if you define an infix, then  $prec := '%additive';

[18:29] <pmichaud> is there already a .index method somewhere?  Would we be punning?

[18:29] <pmichaud> lue:  '%term', I think.

[18:29] <lue> OK. trying...

[18:30] <pmichaud> ah, Rakudo doesn't define a %term

[18:30] <pmichaud> so that's not it.

[18:31] <pmichaud> doesn't appear to be an \.index already.

[18:31] *** xabbu42 left
[18:31] <lue> ah! (^C ^C)

[18:31] *** xabbu42 joined
[18:32] <pmichaud> maybe .at

[18:32] <pmichaud> maybe .elem($key)

[18:32] <PerlJam> @foo.at(5),  %bar.at('key') ?

[18:33] <pmichaud> PerlJam: yeah, something like that.

[18:33] <PerlJam> I guess @foo.at('blah') too?

[18:33] * lue is looking at list of operators defined @ top of Grammar.pm

[18:33] <pmichaud> .elem is bad, because .elems doesn't give back a list of .elem

[18:34] <pmichaud> it's okay for it to be de-huffman, as it won't be commonly used

[18:34] <[particle]> i think that means it's properly huffmanized if it's long

[18:35] <PerlJam> @foo.at('blah') doesn't jibe with being "simpler" perhaps

[18:35] <PerlJam> @foo.thing_at_position(5);  # :-)

[18:36] <pmichaud> ah, that's a good point, I also need to distinguish positional and associative

[18:36] <pmichaud> (for match objects and captures)

[18:36] <pmichaud> so it can't be the same for both.

[18:36] *** xabbu42_ joined
[18:36] *** xabbu42 left
[18:36] *** xabbu42_ is now known as xabbu42

[18:37] <PerlJam> .at_index()  .at_key() 

[18:38] <pmichaud> at_position, since it's "Positional"

[18:38] <pmichaud> but I could go with index

[18:38] <PerlJam> index feels PDLy

[18:38] <pmichaud> I'll go with those for now.

[18:38] <pmichaud> it simplifies a ton of stuff.

[18:38] <lue> it's not a method postfix, is it?

[18:38] <pmichaud> might even enable us to get rid of the "!postcircumfix" helper methods.

[18:39] <pmichaud> lue: you mean circumfix, or what I'm talking about?

[18:39] <pmichaud> maybe .at_pos and .at_key  (so they're the same length :-)

[18:40] <lue> circumfix.

[18:40] <pmichaud> looking

[18:40] <lue> term does seem the best candidate, but that (obviously) won't work /me scratches imaginary Unix Beard

[18:40] <pmichaud> lue: use %term and add it to Perl6::Grammar

[18:40] <pmichaud> that will be close to STD.pm6

[18:41] <PerlJam> .at_pos & .at_key definitely then :)

[18:41] <pmichaud> Just before the line that reads

[18:41] <pmichaud>     Perl6::Grammar.O(':prec<y=>, :assoc<unary>', '%methodcall');

[18:41] <pmichaud> add

[18:41] <pmichaud>     Perl6::Grammar.O(':prec<z=>', '%term');

[18:41] <lue> arigato.

[18:41] <pmichaud> then you can use that as the precedence.

[18:42] <pmichaud> oh, I can't get rid of the helpers entirely

[18:42] <pmichaud> but it does simplify them a lot

[18:42] <pmichaud> okay

[18:42] <PerlJam> pmichaud: the order of those declarations doesn't matter does it?  (precedence)

[18:42] <pmichaud> PerlJam: only for code readability

[18:42] <pmichaud> operationally, no, it doesn't matter

[18:42] <PerlJam> okay.  

[18:42] <pmichaud> it was just the easy way to say where it should be located :)

[18:43] <pmichaud> (and also show the pattern)

[18:43] <pmichaud> small break, bbiab

[18:44] *** Mowah left
[18:44] *** xabbu42_ joined
[18:44] *** xabbu42 left
[18:44] *** xabbu42_ is now known as xabbu42

[18:50] *** patrickas left
[18:51] *** [Coke] joined
[18:52] *** lue left
[18:55] *** lue joined
[18:55] *** ab5tract joined
[18:55] <lue> > multi sub circumfix:<☃ ☄>($a) { Regex.new(<$a>); }; say ("3" ~ ☃<digit>+☄)

[18:56] <lue> Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1

[18:56] <lue> > multi sub circumfix:<Ω Ω>($a) { say $a;}; Ω3Ω

[18:56] <lue> Confused at line 1, near "\x{ce}\x{a9}3\x{ce}\x{a9}\n"

[18:56] <lue> now the problem is what the default precedence should be... (it seems)

[18:58] <lue> afk a bit for nomming, and then Part II in this problem.

[19:00] * jnthn back

[19:01] <Tene> hallo, jnthn_pizza

[19:01] <jnthn> omnomnom

[19:01] <PerlJam> I could use some more food myself.  My lunch wasn't quite enough

[19:02] *** bjarneh joined
[19:02] *** foodoo joined
[19:02] <jnthn> ...

[19:02] <jnthn> :-)

[19:04] *** cono left
[19:05] <pmichaud> I -definitely- like this new factoring for associative/positional better

[19:05] <pmichaud> Very clean.

[19:05] <pmichaud> also, the two follow the same pattern.

[19:06] <jnthn> \o/

[19:06] <pmichaud> now if only the tests will pass... :-P

[19:06] *** cono joined
[19:10] *** Mowah joined
[19:11] *** hercynium joined
[19:11] *** masak joined
[19:11] <masak> ahoy, #perl6!

[19:12] <pmichaud> is  %hash<>  really a zen slice?

[19:12] <pmichaud> I would think it'd be more like   %hash{()}

[19:12] <pmichaud> which isn't a zen slize

[19:12] <foodoo> perl6: say hello masak

[19:12] <pmichaud> *slice

[19:12] <p6eval> pugs: OUTPUT«*** No such subroutine: "&hello"␤    at /tmp/80gUh7q3kj line 1, column 5 - line 2, column 1␤»

[19:12] <p6eval> ..elf 31298: OUTPUT«Undefined subroutine &GLOBAL::masak called at (eval 124) line 3.␤ at ./elf_h line 5881␤»

[19:12] <p6eval> ..rakudo 272191: OUTPUT«Could not find sub &masak␤  in main program body at line 11:/tmp/uHpt4NZOxS␤»

[19:13] <masak> interesting that pugs looks for &hello first...

[19:13] <masak> or maybe it has a sub &masak :P

[19:13] <foodoo> perl6: say "hello masak"

[19:13] <p6eval> elf 31298, pugs, rakudo 272191: OUTPUT«hello masak␤»

[19:13] <pmichaud> I'll make %hash<> a zen slice for now... but I'm not sure that's really right.  :)

[19:14] <[particle]> i think that people would expect %hash<> to be a zen slice, because they'll be using <> a lot when writing hashes

[19:14] <jnthn> pmichaud: I'd thought it was one.

[19:14] <PerlJam> indeed

[19:14] <masak> pugs: our sub g { our sub f($g) {} }; f g

[19:14] <p6eval> pugs:  ( no output )

[19:14] <PerlJam> me too

[19:14] <jnthn> masak: ahoj!

[19:14] <[particle]> however, there's something to using the canonical postcircumfix for a zen slice

[19:14] <masak> pmichaud: I've never thought about it, but it sounds right.

[19:15] <masak> [particle]: oh, that one *must* be a zen slice.

[19:15] <PerlJam> pmichaud: S03:4900

[19:15] <masak> [particle]: the question was whether .<> was also.

[19:15] <[particle]> for an array... will people do @array<> ?

[19:15] <[particle]> masak: yes, i mean *only* the canonical postcircumfix, sorry

[19:16] <[particle]> it's zen, it should truly be nothing

[19:16] <masak> [particle]: @array<> will only work on those special arrays in S09.

[19:16] <pmichaud> PerlJam: S03:4900 doesn't seem relevant .... how does the line read?

[19:17] <pmichaud> ah, :4921 has it.

[19:17] <pmichaud> thanks.

[19:17] <PerlJam> ah, my copy must be out of date a little

[19:17] <PerlJam> (or yours)

[19:18] <masak> (or both)

[19:18] <[particle]> so, you'll have to write <()> in order to get that, just as you'll have to write {()} or [()]

[19:18] <PerlJam> no, mine is defintely out of date (updating now :)

[19:18] <jnthn> erm, <()> would be {'()'}, no?

[19:19] <[particle]> heh, yeah, it would

[19:19] * [particle] is rusty

[19:19] <jnthn> :-)

[19:20] <Tene> "zen slice"?

[19:20] * PerlJam squirts some oil on [particle] so that he doesn't squeak

[19:20] <masak> Tene: so, a *syntactically* empty slice means "everything". that's the zen.

[19:21] <Tene> ah

[19:21] <masak> Tene: the big emphasis on "syntactically" is that this doesn't yield everything: my @a = (); my @b = 1, 2, 3; @b[@a]

[19:21] <Tene> right

[19:21] <masak> it did once. around New Year 2008. :)

[19:21] <masak> guess who found that bug. :P

[19:22] <Tene> was it... you?

[19:22] <masak> ...yes.

[19:22] <Tene> Oh.  I guess I guessed right.

[19:22] <masak> you answerd like a true Bayesian.

[19:23] <Tene> I am not a member of the bayesian conspiracy.

[19:23] <masak> s/d/ed/

[19:23] <masak> I'm still undecided. to me, it feels like one of those "sides of coin" issues.

[19:24] <Tene> What's your prior for that decision?

[19:25] <masak> dunno. life, I guess.

[19:25] <Tene> :)

[19:27] <masak> cognominal: lol at "should I masak that?". I'm currently seeking a worldwide patent on "Reporting shortcomings, infelicities and/or possible improvements in digital computer applications."

[19:28] <cognominal> :)

[19:28] <masak> I'm glad someone is already respecting that patent.

[19:29] <Tene> masak: I recently encountered the idea of "US Patent #1 is not a patent for a time machine" as evidence against anyone ever creating a time machine.

[19:29] <masak> uh.

[19:30] <masak> strangely, I might even agree. but I'd like to see the proof.

[19:30] *** xabbu42 left
[19:30] *** xabbu42 joined
[19:31] <Tene> Not proof, just a suggestive idea inspiring a board game: http://www.cheapass.com/products/boardgames/cag034.html

[19:32] <masak> nice!

[19:32] <masak> yes, I think I grok the idea now. I'm a bit slow today. :)

[19:34] *** Mowah left
[19:34] <colomon> ah, cheapass games....  :)

[19:35] <literal> arnsholt: yes

[19:35] <masak> I'm running spectests now. Release Day tomorrow. the release guide says I should encourage people to update the ChangeLog and the ROADMAP.

[19:35] * masak looks encouraging

[19:35] <masak> :)

[19:37] <pmichaud> masak: do you want me to hold off on merging the list branch to trunk, or try to get it in before the release?

[19:37] <pmichaud> (all spectests will pass before merging to master)

[19:37] <pmichaud> I'm in favor of getting this merged.  :)

[19:38] <masak> by all means, merge.

[19:38] <pmichaud> okay.  I'm hoping to have that done by tonight, but it might be late tonight.  When were you planning to cut the release?

[19:38] <masak> tomorrow.

[19:38] <pmichaud> when tomorrow?  ;-)

[19:38] <pmichaud> (your "tomorrow" is sometimes offset from mine :)

[19:39] <masak> my guess is at around 20:00 UTC.

[19:39] <pmichaud> oh, excellent.

[19:39] <pmichaud> so, about this time tomorrow then.  No problem.

[19:39] <pmichaud> If I don't have the list stuff merged by around 08:00 UTC I'm not likely to try to merge before release.

[19:39] <masak> ok.

[19:40] <pmichaud> oh, we may also end up swapping "Atlanta"  and "Kiev".

[19:40] <dalek> grok: a1d008e | (Hinrik Örn Sigurðsson)++ |  (2 files):

[19:40] <dalek> grok: Remove Module::Install::AuthorTests

[19:40] <dalek> grok: review: http://github.com/hinrik/grok/commit/a1d008e93dfd0aba6f43be2c7ca5b5bf86f1f254

[19:40] <dalek> grok: f16ad94 | (Hinrik Örn Sigurðsson)++ |  (9 files):

[19:40] <dalek> grok: Bump version to 0.20

[19:40] <dalek> grok: review: http://github.com/hinrik/grok/commit/f16ad94d71a143bee48d510f2bad94fa56ea280d

[19:40] <dalek> grok: a99c023 | (Hinrik Örn Sigurðsson)++ |  (15 files):

[19:40] <dalek> grok: Add -U/--update to download latest versions of documents from the web

[19:40] <dalek> grok: review: http://github.com/hinrik/grok/commit/a99c023f829e320caf354815f657d58d8875888c

[19:40] <dalek> grok: eca6538 | (Hinrik Örn Sigurðsson)++ |  (9 files):

[19:40] <dalek> grok: Bump version to 0.21

[19:40] <dalek> grok: review: http://github.com/hinrik/grok/commit/eca65387293d0b5423cd162620b0d28fbc304a5e

[19:40] <pmichaud> anyway, I'll take care of that today.

[19:40] <literal> is dalek's source in pugs svn?

[19:41] <literal> its output can be made much more concise

[19:41] <masak> literal: ISTR it's on github.

[19:41] *** frew joined
[19:41] *** frew left
[19:41] <pmichaud> literal: what would you do to make it more concise?  I kind of like it as it is.

[19:42] *** patspam joined
[19:42] <PerlJam> he could shorten the URLs

[19:42] <literal> I'll show you

[19:43] <masak> PerlJam: using an URL shortener on -every- github URL reported on-channel feels... a bit wasteful. :/

[19:44] <masak> s/an/a/

[19:44] <literal> pmichaud: http://paste.scsys.co.uk/44927

[19:44] <pmichaud> literal: I don't like that.  I like having the urls easily clickable in my window.

[19:44] <PerlJam> masak: just contemplating what could be done to make the output more concise.  I'm not saying it's a good idea :)

[19:44] <literal> pmichaud: it is easily clickable there

[19:44] <pmichaud> and I like seeing the full commit messages.

[19:44] <literal> the compare url gives you a list of all the commits

[19:45] <literal> and shows you a complete diff

[19:45] <literal> e.g. see http://github.com/hailo/hailo/compare/34d7f7c...b617711

[19:45] <pmichaud> oh, that might work.

[19:45] <pmichaud> what about full commit messages?

[19:45] <literal> that could be added

[19:46] <PerlJam> and looking at the existing messages I suppose the SHA1 prefix is a little redundant if we also give the URL

[19:46] *** masak left
[19:46] <pmichaud> anyway, as long as the urls are present in some easily clickable form, I'm not opposed too strongly.

[19:46] <pmichaud> yay, all hash tests pass in the new design!

[19:46] *** masak joined
[19:47] <PerlJam> that was quickish

[19:47] <PerlJam> (quicker than I was expecting anyway)

[19:47] <pmichaud> that's how "right" the design is :)

[19:47] <sorear> What is elf and why do we want to remove it from the evalbot?

[19:47] <literal> hm, http://github.com/cmaujean/dalek, "Nothing to see here yet. Move along."

[19:48] <PerlJam> who wants to remove elf?

[19:48] <PerlJam> does someone have something against Ronnie James Dio?

[19:48] <pmichaud> sorear: http://svn.pugscode.org/pugs/misc/elf/README

[19:48] <literal> sorear: by the way, you can try upgrading to grok 0.21 and doing grok --update

[19:49] <literal> http://nix.is/grok-0.21.tar.gz # in case it's not on CPAN yet

[19:50] *** Mowah joined
[19:50] *** foodoo left
[19:51] <colomon> rakudo: say 2 == (2 + 0i)

[19:51] <p6eval> rakudo 272191: OUTPUT«0␤»

[19:51] <colomon> rakudo: say (2 + 0i) == (2 + 0i)

[19:51] <p6eval> rakudo 272191: OUTPUT«1␤»

[19:52] <masak> rakudo: say (2 + 0i) == 2

[19:52] <p6eval> rakudo 272191: OUTPUT«0␤»

[19:53] <masak> at least it's reflexive.

[19:56] <sorear> literal: How hard would it be to make grok DTRT when fed Perl6 source?  I mean, discarding ambient code and not try to format it as pod

[19:58] <masak> jnthn, pmichaud: after having read jnthn++'s blog post, I also want to change the name of tomorrow's release to "Kiev". can I do it right away?

[19:58] <masak> alternatively, we'll name it "Wasabi" :P

[19:59] <pmichaud> masak: I need to check with the person who requested (and paid for) Atlanta

[19:59] <pmichaud> (paid at a TPF auction)

[20:00] <TimToady> phone

[20:00] <pmichaud> I'll check now.

[20:00] <masak> ok.

[20:00] <jnthn> masak: :P

[20:00] <jnthn> masak: Yes, that will probably forever remain as one of the most memorable things I've ever drunk. :-)

[20:02] * masak googles for 'Wasabi Vodka'. planetsix.perl.org is in third place :P

[20:03] <sorear> TimToady: ping

[20:03] * jnthn feels a weird sense of achievement 

[20:03] <TimToady> pong

[20:03] <sorear> TimToady: I think I've uncovered a STD bug; mod_internal:sym<:i> starts with $<sym>=[':i' | ':ignorecase'], which is a literal prefix of 0

[20:04] <sorear> should be [':i'['gnorecase']?], yes/no?

[20:04] *** Psyche^ joined
[20:04] <TimToady> hmm

[20:06] <TimToady> either that, or we do token splitting in such cases, both of which end up with the same fate

[20:06] <literal> sorear: hm, I guess Perl6::Perldoc would need to be updated to handle it

[20:06] <TimToady> but your solution is fine for now

[20:06] <TimToady> or we just go ahead and let it be 0, and rely on normal LTM

[20:08] <literal> sorear: can you point me to a p6 file with Pod which shows the problem?

[20:08] *** Patterner left
[20:08] *** Psyche^ is now known as Patterner

[20:08] <lue> ohai

[20:08] <sorear> TimToady: the problem with relying on normal LTM is that mod_internal:oops has a prefix length of 1

[20:08] <sorear> and wins

[20:09] <masak> lue: \o

[20:09] <lue> methinks I have a problem with precedence...

[20:09] <sorear> (yes, dfa/Cursor has parsed enough of STD to reach a :i and die)

[20:10] <sorear> literal: no, because chicken and egg.  there's no tool that can extract pod from perl6 so nobody puts pod in perl6

[20:10] <masak> sorear: that's only 90% true :)

[20:10] <sorear> poor mockup: http://pastie.org/1007472

[20:13] <lue> what does the N in the precedence chart in S03 stand for?

[20:13] *** mikehh left
[20:13] <moritz_> the precedences are enummerated alphabetically

[20:14] <moritz_> so it stands for "after L and before M" :-)

[20:14] <TimToady> sorear: that should be solved by starting oops with {}

[20:14] <masak> lue: "no associativity"

[20:15] <masak> lue: in other words, not using parentheses in `$a op $b op $c` is illegal for such an op.

[20:15] <lue> Ok.

[20:15] <moritz_> oh, I thought you meant the prec levels in STD.pm

[20:15] * moritz_ too tired for proper reading

[20:16] <lue> Problem is, some things marked N in S03 have associativity in the Grammar.

[20:16] <lue> i.e.   Perl6::Grammar.O(':prec<x=>, :assoc<unary>', '%autoincrement');

[20:16] <masak> lue: could you exemplify with a well-placed p6eval call?

[20:16] <moritz_> lue: unary operators are special in that regard

[20:16] <lue> I'm trying to figure out why my circumfix fix is not quite working.

[20:17] <masak> whoa. proto has a version number, and I didn't even know. :P

[20:17] <moritz_> there are no two sane ways to parse +~$thing

[20:17] <moritz_> (+~)$thing doesn't make sense

[20:18] * [particle] would be pleased if all modules included in R* had version numbers and authorities

[20:18] <lue> thanks to pmichaud, I place a line specifying %term , but w/o any associativity [I guess I don't know much. Just trying to fix it]

[20:18] <moritz_> only +(~$thing) 

[20:18] <lue> masak: did you see the results of what I've done so far?

[20:18] <masak> moritz_: I'm still surprised 'unary' counts as an associativity. PGE has no such exception.

[20:19] <moritz_> somhow Match.postcircumfix:<{ }> is b0rked in 'list' branch

[20:19] *** sorear left
[20:19] <masak> lue: no, what should I be looking for?

[20:19] *** Mowah left
[20:19] <lue> > multi sub circumfix:<☃ ☄>($a) { Regex.new(<$a>); }; say ("3" ~ ☃<digit>+☄)

[20:19] <lue> Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1

[20:19] *** sorear joined
[20:20] <lue> I got closer, there's no parse error now :)

[20:20] <TimToady> std: multi sub circumfix:<☃ ☄>($a) { Regex.new(<$a>); }; say ("3" ~ ☃<digit>+☄)

[20:20] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/UsasH1RrZF line 1:␤------> [32mRegex.new(<$a>); }; say ("3" ~ ☃<digit>+[33m⏏[31m☄)[0m␤Parse failed␤FAILED 00:01 113m␤»

[20:20] <lue> I think the precedence is screwing it up though.

[20:20] <TimToady> there *should* be a parse error :)

[20:21] <lue> > multi sub circumfix:<Ω Ω>($a) { say $a;}; Ω3Ω

[20:21] <lue> Confused at line 1, near "\x{ce}\x{a9}3\x{ce}\x{a9}\n"

[20:21] <TimToady> circumfixes are not quotes

[20:21] <TimToady> std: multi sub circumfix:<Ω Ω>($a) { say $a;}; Ω3Ω

[20:21] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'Ω3Ω' used at line 1␤Check failed␤FAILED 00:01 109m␤»

[20:21] *** jrtayloriv joined
[20:21] <TimToady> std: multi sub circumfix:<Ω Ω>($a) { say $a;}; Ω 3 Ω

[20:21] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/L3aKEKXlAL line 1:␤------> [32msub circumfix:<Ω Ω>($a) { say $a;}; Ω 3 [33m⏏[31mΩ[0m␤    expecting any of:␤  bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse failed␤FAILED 00:01 110m␤»

[20:22] *** [Coke] left
[20:22] *** [Coke] joined
[20:22] <lue> well, at least I got rid of the part where it didn't understand what a custom circumfix was :)

[20:22] <TimToady> can't really use alphanumerics for circumfixes, since they're ambiguous with normal names

[20:22] *** justatheory joined
[20:23] <lue> I thought it was, just needing spaces.

[20:23] <TimToady> std: multi sub circumfix:<` `>($a) { say $a;}; `3`

[20:23] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/1TbcOKRuc5 line 1:␤------> [32mi sub circumfix:<` `>($a) { say $a;}; `3[33m⏏[31m`[0m␤    expecting any of:␤        POST␤   bracketed infix␤    infix or meta-infix␤      postfix␤        postfix_prefix_meta_operator␤      

[20:23] <p6eval> ..statement modifier loop␤Parse failed␤FA…

[20:23] *** xabbu42 left
[20:23] *** xabbu42 joined
[20:23] <TimToady> and that's a known bug in STD :)

[20:24] <masak> TimToady: huh? why can't normal names be used in circumfixes, when they can in infix operators?

[20:24] <lue> Confused at line 1, near "`3`\n" is what I get with what you put up, TimToady

[20:24] <sorear> TTIAR?

[20:24] <TimToady> because we have term:ident, but not infix:ident

[20:25] <masak> lue: did you catch the "circumfixes are not quotes" part that TimToady said?

[20:25] <lue> yes.

[20:25] <TimToady> no, the bug in STD is confusion between starters and stoppers

[20:25] <masak> lue: goodie. just checking.

[20:25] <TimToady> probably due to cursor reuse

[20:26] <lue> I don't necessarily see why it's relevant, but I caught it, and can infer what he means :)

[20:26] <lue> while you're here TimToady, circumfixes *are* terms, are they not?

[20:27] <TimToady> yes, they're terms on the outside, but EXPR on the inside

[20:28] <masak> lue: it's relevant, because <digit>+ in your code isn't valid Perl 6.

[20:28] <lue> I meant for it to be a regex.

[20:28] <masak> lue: and if a circumfix doesn't quote... then you've written something invalid.

[20:29] <TimToady> you might have meant that, but the parser can't read your mind

[20:31] <lue> seems like it needs to be more than just simply adding a definition for %term then…

[20:32] <TimToady> std: multi sub circumfix:<｢ ｣>($a) { say $a;}; ｢3｣

[20:33] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/5Cb0diuN6F line 1:␤------> [32mi sub circumfix:<｢ ｣>($a) { say $a;}; ｢3[33m⏏[31m｣[0m␤    expecting any of:␤        POST␤   bracketed infix␤  infix or meta-infix␤       postfix␤ postfix_prefix_meta_operator␤       statement

[20:33] <p6eval> ..modifier loop␤Parse failed␤FA…

[20:33] <TimToady> hmm

[20:34] <pugssvn> r31299 | sorear++ | [dfa/Cursor] When a subregex which generates nontrivial fates is quantified, the fates must be discarded, as the runtime quantifier cannot know how to correctly route them. 

[20:34] <rokoteko> circumfix? really? why not just lhs-fix + rhs-fix ?

[20:36] <szabgab> rakudo: my $c = [["name", 42], ["verbatim", "abc"]]; say $c[0].perl; for $c -> $x { say "z", $x.perl }

[20:36] <p6eval> rakudo 272191: OUTPUT«["name", 42]␤z[["name", 42], ["verbatim", "abc"]]␤»

[20:37] <szabgab> so I thought $z is an array here

[20:37] <masak> rokoteko: because there's no such thing as lhs-fix and rhs-fix? :)

[20:37] <pugssvn> r31300 | sorear++ | [STD] Don't rely on old-Cursor's buggy token splitting in mod_internal 

[20:37] <szabgab> $c I mean

[20:37] <masak> rokoteko: seriously, I don't see how they could be made to work the same as a circumfix. the latter imposes precedence.

[20:37] <szabgab> as $c[0] works

[20:37] <masak> just like parens do.

[20:37] <szabgab> but how can I loop over the elements?

[20:37] <lue> because for lhs-fix and rhs-fix you'd still have to tell it the matching delimiter.

[20:39] <szabgab> rakudo: my $c = [["name", 42], ["verbatim", "abc"]]; say $c[0].perl; say $c.elems

[20:39] <p6eval> rakudo 272191: OUTPUT«["name", 42]␤2␤»

[20:40] <szabgab> rakudo: my $c = [["name", 42], ["verbatim", "abc"]]; say $c[0].perl; for 0..say $c.elems-1 -> $i { say $c[$i] }

[20:40] <p6eval> rakudo 272191: OUTPUT«["name", 42]␤1␤name 42␤verbatim abc␤»

[20:40] <TimToady> std: ( 42 ]

[20:40] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse parenthesized expression at /tmp/pz3mwLMlZS line 1:␤------> [32m<BOL>[33m⏏[31m( 42 ][0m␤Couldn't find final ')'; gave up at /tmp/pz3mwLMlZS line 1:␤------> [32m( 42 [33m⏏[31m][0m␤    expecting statement modifier loop␤Parse

[20:40] <p6eval> ..fail…

[20:41] <lue> so interval notation isn't standard to the core it seems :)

[20:41] <masak> szabgab: I usually do `for $c.list -> $x { ... }`

[20:41] <szabgab> rakudo: my $c = [["name", 42], ["verbatim", "abc"]]; for $c.list -> $x { say $x.perl }

[20:41] <p6eval> rakudo 272191: OUTPUT«["name", 42]␤["verbatim", "abc"]␤»

[20:41] <rokoteko> lhs-fix and rhs-fix maybe you'd like to call the beforefix, afterfix.. as opposite to prefix and postfix, but they have to come in pairs.

[20:41] <szabgab> masak, thanks

[20:42] <TimToady> rokoteko: what does that buy you?

[20:42] <rokoteko> masak: circumfix sounds more silly to me.

[20:42] <TimToady> we don't care if things sound silly here

[20:43] * masak says "Mu"!

[20:44] <lue> <JOKE> .oO(twigil sounds silly. Let's call it secondarygil) </JOKE>

[20:44] <rokoteko> TimToady: sub beforefix<`> ( "bread" ); sub afterfix<􏿽xB4> ( "milk" ); `rokoteko.buys()􏿽xB4

[20:45] <rokoteko> I buy bread an milk!

[20:45] <TimToady> how do you know they go together?

[20:45] <TimToady> circumfixes have to match

[20:45] <TimToady> std: ( 42 ]

[20:45] <p6eval> std 31298: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse parenthesized expression at /tmp/s4GEMsNW8k line 1:␤------> [32m<BOL>[33m⏏[31m( 42 ][0m␤Couldn't find final ')'; gave up at /tmp/s4GEMsNW8k line 1:␤------> [32m( 42 [33m⏏[31m][0m␤    expecting statement modifier loop␤Parse

[20:45] <p6eval> ..fail…

[20:45] <rokoteko> TimToady: well, you obviously don't know that with circumfix either.

[20:45] <lue> that's what I was wondering. You'd have to state that anyway. Circumfix makes it easy.

[20:45] <TimToady> yes, we do!!!

[20:45] <masak> yes, exactly.

[20:45] <TimToady> or we couldn't give that error message there

[20:46] <szabgab> rakudo: (1,2,3).map(-> $x { say $x } );

[20:46] <masak> ¡¡¡yes, we do!!!

[20:46] <p6eval> rakudo 272191:  ( no output )

[20:46] <szabgab> hmm, this works in the REPL

[20:46] <jnthn> circum means "around"; circumfixes are things that go around other things. The name seems pretty fitting to me. :-)

[20:46] <szabgab> printing both 1 2 3 and 1 1 1

[20:46] <jnthn> szabgab: The REPL probably sinks it.

[20:46] <lue> It might not be english, but hey.

[20:47] <masak> lue: it's Latin. :)

[20:47] <jnthn> lue: There's plenty of words with that prefix that made it into English.

[20:47] * lue is reminded of the quest to find a word for %_

[20:47] <jnthn> circumference, circumscribe, circumsize...

[20:47] <masak> lue: "Holy Grail"? :P

[20:47] <szabgab> jnthn, just don't go there ...

[20:47] <lue> I meant the whole word circumfix

[20:48] <rokoteko> TimToady: I dunno. maybe the programmer should be responsible for choosing the before- and afterfix operators, in such way that there is no afterfix in between.

[20:48] <lue> QUICK! Give me a pronoun describing a hash like structure. Any language!

[20:48] <szabgab> זוג

[20:48] <rokoteko> to *me* circumfix sounded like silly (which I now have learnt that is not possible on this channel). :)

[20:49] <PerlJam> lue: %_

[20:49] <lue> szabgab: you broke the continuity with RTL! That's Cool! :)

[20:49] <lue> any *natural* language :)

[20:49] <szabgab> it actually looks much better in had writing where the word pair looks symmetric

[20:50] <lue> .u ג

[20:50] <phenny> U+05D2 HEBREW LETTER GIMEL (ג)

[20:50] <lue> ah, hebrew.

[20:50] <masak> S03-operators/range-basic.rakudo fails over here. lots of TODO passes, for some reason. http://gist.github.com/441245

[20:51] <colomon> "over here"?

[20:52] <Util> masak: same here (03-operators/{assign,range-basic} FAIL, lots of TODO passing)

[20:52] <jnthn> colomon: Yeah, over there, somewhere to my north east, the test is failing. ;-)

[20:52] <Util> (Max OS X 10.5)

[20:52] <rokoteko> anyhow. to me sub circumfix <'> ( foo() ); sounds more difficult to parse than a after- and beforefix, becuase in the former you cant blame the programmer for not thinking which pairs to choose. :)

[20:52] <Util> s/Max/Mac/

[20:52] <lue> Maybe masak was referring to his location IPv4 space...

[20:52] <colomon> probably my fault, I know I've got a custom range-basic running okay here.

[20:52] <TimToady> rokoteko: I'm curious as to why you think circumfix sounds silly.  it's all perfectly good Latin roots, used in their appropriate meanings

[20:53] <rokoteko> or s/blame/trust/ and s/not// :)

[20:53] <colomon> I was more curious about which branch of rakudo...

[20:53] <TimToady> or is it just that all neologisms sound silly to you?

[20:53] <lue> that's not how circumfix works.

[20:53] <rokoteko> TimToady: should I look up neologism or are you planning to explain before I think of my answer?

[20:54] <TimToady> a "coined" word

[20:54] <rokoteko> as in coins have two sides?

[20:54] <lue> A word that's not standard but used anyway. 'Bling' used to be one, I believe.

[20:54] <lue> It's a new word.

[20:54] <rokoteko> ahh. then I have nothing against circumfix as a word.

[20:55] <lue> .oO( sub circumfix:<' '>($parameter) { say $parameter; }; )

[20:56] <rokoteko> it's probably how I have taught me neurons. easier to gasp the idea of anti-postfix and anti-prefix vs the opposites than infix vs circumfix. how on earth would you use circumfix in practise?

[20:56] *** bjarneh left
[20:56] <masak> my productivity index is at 0 today, it seems. that's what I get for getting fresh air all day. I'll try sleeping for a few hours and then returning. see you, #perl6.

[20:56] *** masak left
[20:56] <rokoteko> I find it very hard to grasp how to chain if it's always the same char at both ends.

[20:56] *** bjarneh joined
[20:56] <lue> We use them for things like ( ), [ ], and { }

[20:56] *** sorear left
[20:57] <lue> doesn't always need to be the same character :)

[20:58] *** sorear joined
[20:58] * PerlJam wonders what chaining has to do with it

[20:59] *** whiteknight joined
[20:59] <pmichaud> back to hacking

[21:00] <pmichaud> jnthn: I didn't mention yet, but the new Associative refactoring is awesome (and clean)

[21:00] *** jrtayloriv left
[21:01] <rokoteko> I was thinking in the lines of: "a (circumfix b) circumfix c d"  .. where the circumfix op is "circumfix" :) 

[21:02] <jnthn> pmichaud: :-)

[21:02] <lue> You should never need to do that, unless b) is a string.

[21:02] <jnthn> pmichaud: Meanwhile, s/Perl6MultiSub/Multi/...is fail. :/

[21:02] * jnthn digs into why

[21:03] <rokoteko> lue: ah. ok.

[21:03] <rokoteko> maybe I should spend some time reading the synopses instead of asking weird questions here. :)

[21:03] *** xabbu42_ joined
[21:03] *** xabbu42 left
[21:03] *** xabbu42_ is now known as xabbu42

[21:03] <pmichaud> jnthn: I don't need that feature at all now, fwiw.

[21:04] <pmichaud> I found an even cleaner mechanism than what I was looking at earlier.  :)

[21:04] <lue> if it were a string, it wouldn't matter. Then It would look like a (circumfix "b)" circumfix c d)

[21:05] <rokoteko> Anyhow, cool to hear that perl6 has circumfix! :) that was something new for today.

[21:05] <szabgab> some Rakudo code question:

[21:05] <szabgab> I see pir::open__PSS mentioned 3 times in the src/ tree of Rakudo, one is the definition of open() and two other places, should the two other places actually use the open() function??

[21:06] *** diakopter sets mode: +o sorear

[21:08] *** diakopter left
[21:08] <jnthn> pmichaud: I know, it was high on my "fix this" list anyway

[21:09] *** diakopter joined
[21:09] <jnthn> pmichaud: So can have .cando work on multis, so an RT can be resolved. :-)

[21:09] <pmichaud> okay.

[21:09] *** sorear sets mode: +o diakopter

[21:09] <pmichaud> szabgab: I think I would prefer that, yes.

[21:10] <dalek> book: 11a5774 | chromatic++ | src/preface.pod:

[21:10] <dalek> book: Edited preface; left in one author note.

[21:10] <dalek> book: review: http://github.com/perl6/book/commit/11a57749faf09e167208043ad911e4e01f9cf376

[21:10] <dalek> book: 2535b58 | chromatic++ | src/basics.pod:

[21:10] <dalek> book: Edited basics chapter, leaving one author note.

[21:10] <dalek> book: review: http://github.com/perl6/book/commit/2535b58c728547b295b2d10ff2f9a14aa01ba952

[21:11] <szabgab> pmichaud, then I'll try to do that tomorrow as my first attempt at rakudo itself

[21:11] <pmichaud> szabgab: woo hoo!

[21:11] *** rv2733 left
[21:11] <lue> The worst part is that circumfix is bothering me enough to make me want to fix it, but I don't know enough to do so without a _lot_ of help. :)

[21:11] <pmichaud> szabgab++

[21:12] <szabgab> is the RT submission critical or a push request on my github fork is sufficient for patches?

[21:12] <szabgab> or maybe pull request.

[21:13] <lue> afk

[21:15] <pmichaud> szabgab: I haven't been able to make pull requests (github's fork queue) work well for me, so we've gone with patch emails

[21:15] <pmichaud> or you can send us the pull request information directly in an email or ticket

[21:15] <pmichaud> or catch someone here to do it

[21:16] <pmichaud> but I personally find github's fork queue to be "not understandable or usable."  (Maybe someone can give me a tutorial sometime about how it's supposed to work.)

[21:16] <PerlJam> or just give szabgab commit access :)

[21:16] <szabgab> ok, let me first try to make the change and then I catch someone to see how to do it to make it easy for tou

[21:17] <szabgab> PerlJam, I don't want to run around with open scissors 

[21:17] <szabgab> but thanks :)

[21:17] <pmichaud> phenny: tell masak  it's official, tomorrow's release is "Kiev"

[21:17] <phenny> pmichaud: I'll pass that on when masak is around.

[21:17] <dalek> rakudo: c9ee2eb | pmichaud++ | docs/release_guide.pod:

[21:17] <dalek> rakudo: June release is now "Kiev", July release is "Atlanta".

[21:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c9ee2eb12bb35d5b0e399faadf6dba6b5fa1f888

[21:18] <jnthn> \o/

[21:18] *** xabbu42_ joined
[21:18] *** xabbu42 left
[21:18] *** xabbu42_ is now known as xabbu42

[21:18] <szabgab> anyway,  night &

[21:19] <Tene> szabgab: really, the pir::open in open() should instead make a new Filehandle and call its 'open' method.

[21:19] <Tene> szabgab: ah, g'night

[21:23] *** Guest23195 left
[21:24] *** felipe joined
[21:31] *** clintongormley left
[21:31] *** Su-Shee left
[21:32] *** silug left
[21:36] *** xabbu42_ joined
[21:36] *** xabbu42 left
[21:36] *** xabbu42_ is now known as xabbu42

[21:38] *** Guest37981 left
[21:43] *** xabbu42_ joined
[21:43] *** xabbu42 left
[21:43] *** xabbu42_ is now known as xabbu42

[22:02] *** hercynium left
[22:04] *** sdvsdvsdv left
[22:06] *** xabbu42_ joined
[22:06] *** xabbu42 left
[22:06] *** xabbu42_ is now known as xabbu42

[22:07] *** sdvsdvsdv joined
[22:08] *** pyrimidine left
[22:10] *** bjarneh left
[22:10] *** kda joined
[22:12] <pugssvn> r31301 | sorear++ | [dfa/Cursor] Rearrange quantifier handling to avoid NFA node population explosions 

[22:17] <diakopter> r31301 :)

[22:19] <sorear> it's not even a palindrome

[22:19] *** ewilhelm joined
[22:21] <sorear> variable_2 generates over 1500 dfa nodes

[22:21] <sorear> *nfa

[22:21] <sorear> this needs investigating

[22:25] <sorear> desigilname itself makes >300, most with only epsilons

[22:28] *** hudnix left
[22:28] *** macdaddy left
[22:29] <skids> http://www.abrij.org/~bri/camelia_ifs.svg <--- you'll need opera.  Or the adobe SVG+SMIL plugin.

[22:29] <skids> And a lot of cpu cycles.

[22:30] *** literal left
[22:32] *** literal joined
[22:32] *** literal left
[22:33] *** literal joined
[22:34] *** macdaddy joined
[22:36] *** Ross left
[22:38] *** tedv joined
[22:41] *** skids left
[22:49] <pugssvn> r31302 | sorear++ | [dfa/Cursor] Fix handling of imperative nodes in nfaopt and nfastar 

[22:51] *** xabbu42_ joined
[22:51] *** xabbu42 left
[22:51] *** xabbu42_ is now known as xabbu42

[22:54] <sorear> \o/

[22:55] <sorear> dfa/Cursor just successfully and without misparsings bootstrapped STD.pm6

[22:55] <sorear> and in 10 seconds less than the old Cursor, before I've even started microoptimizing

[22:58] *** Transformer joined
[23:00] *** Transformer left
[23:03] *** broquaint joined
[23:05] * sorear runs the profiler and opts to optimize a bit before the mergeback

[23:11] *** xabbu42_ joined
[23:11] *** xabbu42 left
[23:11] *** xabbu42_ is now known as xabbu42

[23:13] *** Transformer joined
[23:16] *** Transformer left
[23:18] *** broquaint left
[23:19] <sorear> the annoying thing about NYTProf is that it makes your program 10x slower

[23:19] <sorear> not good if it's too slow

[23:19] <sorear> I'd love to see a proper low-overhead Perl profiler

[23:19] <sorear> maybe with parrot and ponie we'll get one.

[23:20] *** xabbu42_ joined
[23:20] *** xabbu42 left
[23:20] *** xabbu42_ is now known as xabbu42

[23:28] <Tene> is ponie not-dead now?

[23:29] *** patspam left
[23:30] <jnthn> Aanyone know if anything happened recently that may have resulted in Rakudo's spectests no longer running in parallel for me?

[23:30] <jnthn> It makes things...epicly slower. :/

[23:31] <Tene> jnthn: I successfully ran spectests in parallel in the list branch last night.

[23:31] <Tene> I'll update master right now and try

[23:31] <Tene> updating parrot...

[23:34] <Tene> updating rakudo...

[23:34] *** snarkyboojum left
[23:35] *** yinyin joined
[23:37] <sorear> Tene: One ponie is dead

[23:37] <Tene> spectesting...

[23:37] <Tene> sorear: is there another one?

[23:37] <TimToady> sorear: 10 sec less is about what I expected from old NYTProf

[23:37] <TimToady> and \o/ too

[23:37] <sorear> jnthn: Rakudo spectests are no longer parralel by default, because it hoses newbies with small computers

[23:38] <sorear> Tene: TimToady has used "ponie" to refer to what STD_P5.pm6 is going to become

[23:39] <TimToady> I did?

[23:39] <sorear> I thought you did

[23:39] <jnthn> sorear: :/

[23:40] <jnthn> sorear: Any idea off hand how one re-instates it locally?

[23:40] *** xabbu42_ joined
[23:40] *** xabbu42 left
[23:40] *** xabbu42_ is now known as xabbu42

[23:41] <sorear> look in scrollback, someone asked the same thing

[23:41] <Tene> jnthn: TEST_JOBS=4 make spectest

[23:41] <Tene> is what I'm using

[23:41] <jnthn> Thanks, I'll work out how to win32-ify that. :-)

[23:41] *** mikehh joined
[23:41] <sorear> make spectest TEST_JOBS=4

[23:41] <sorear> ?

[23:42] <Tene> sorear: what did it use previously?  if you only have one cpu, did it still do parallel?

[23:42] *** gbacon left
[23:42] <sorear> Tene: yes

[23:42] <sorear> and 3

[23:43] <Tene> Oh.  I can understand the problem.

[23:44] <jnthn> Ah...yes, spawing 3 in parallel on a single-processor box is unfriendly.

[23:44] <sorear> especially if you have less than the needed 3*150 MB ram

[23:44] <sorear> as expected, NFA generation is very high up for time used parsing 2 + 2

[23:45] <sorear> unexpectedly, Class::MOP is actually at the top of the list

[23:46] *** mberends left
[23:46] <TimToady> is that with uncached lexers?

[23:46] <Tene> 150MB is down from several months ago, yes?  I seem to remember ~400MB once... or was that for compiling?

[23:47] <TimToady> looking up all the methods to PEEK can be expensive

[23:49] <Tene> jnthn: get parallel testing working for you?  Just finished for me on my laptop, but I don't know if these test failures are normal or not.

[23:49] <Tene> Files=456, Tests=32404, 601 wallclock secs (15.42 usr  1.93 sys + 1860.99 cusr 49.96 csys = 1928.30 CPU)

[23:50] <jnthn> Tene: No, got bogged down in debugging something.

[23:51] *** xabbu42_ joined
[23:51] *** xabbu42 left
[23:51] *** xabbu42_ is now known as xabbu42

[23:52] <sorear> TimToady: yes; I'm hoping to get rid of the on-disk lexer cache

[23:53] *** jferrero left
[23:55] <mikehh> rakudo (c9ee2eb) builds on parrot r47666 - make test PASS, spectest_smolder -> #34441 (pugs r31302) FAIL - Ubuntu 10.04 i386 (g++ with --optimize)

[23:55] <pmichaud> finally found the problem with S03-metaop/cross.t

[23:56] <Tene> I saw an infinite loop back and forth between junction.bool and failure.bool, but it looked like the stack trace was missing something there, or otherwise inaccurate.

[23:57] <pmichaud> the junction ended up storing a reference back to itself.

[23:58] <pmichaud> i.e.,    $result = &infix:<|>($result, $value)

[23:58] <pmichaud> the junction wasn't properly dereferencing the $result container, and therefore was keeping a reference to $result instead of its value

[23:58] <pmichaud> so then when you tried to use it... infinite loop :-|

[23:59] <Tene> ah

[23:59] <pmichaud> (parallel testing)  -  I think I'd be in favor of having a parallel test target

[23:59] <pmichaud> make jtest  or something

[23:59] <sorear> TimToady: have you considered making DEBUG a constant, so if DEBUG & DEBUG::foo lines can be optimized out by the constant folder?

