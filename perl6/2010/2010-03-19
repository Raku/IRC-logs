[00:00] <colomon> TimToady: hypers either extend or die, depending.

[00:00] <TimToady> yeah

[00:00] <colomon> zip always stops when the shorter list runs out.

[00:00] <TimToady> right

[00:00] <jnthn> kinda sorta :-)

[00:00] <jnthn> colomon: For now for installing the generated meta-op subs just I suggest try

[00:01] <sorear> hello all

[00:01] <jnthn> PAST::Op.new( :pasttype('bind'), PAST::Var.new( :name($opsubname), :scope('package') ), ...the assuming call thingy... )

[00:01] <jnthn> sorear: oh hai

[00:01] <colomon> sorear: o/

[00:01] <sorear> in other news, #parrot has decided that parrot-nqp needing 1600MB to compile Rakudo is "probably a bug"

[00:02] <jnthn> "probably" :-)

[00:02] <TimToady> 多分

[00:02] <jnthn> sorear: Did they decide anything on your patch to unblock blizkost progress?

[00:04] <sorear> I haven't pressed on yet

[00:04] <jnthn> TimToady: heh, the second char looks like a walking coathanger.

[00:04] <sorear> I finished the patch at 3am and immediately fell asleep

[00:04] <jnthn> Oh hey, I did that with a patch yesterday too :-)

[00:04] <TimToady> it's actually "eight" and "sword"

[00:05] <TimToady> so it means "part", as in the bits you end up with when you hack something up

[00:05] <TimToady> the first one means "many"

[00:05] <jnthn> Ah, cool :-)

[00:05] <TimToady> "many parts" means roughly, 9 times out of 10

[00:05] <colomon> jnthn: I'm guessing I just can't call .assuming directly in Actions.pm?

[00:05] <jnthn> colomon: no, you need something like

[00:06] <jnthn> PAST::Op.new( :pasttype('callmethod'), :name('assuming'), ...node that looks up &callwith..., ...node that looks up &infix:<worreva>...)

[00:07] <jnthn> TimToady: It uses 1600MB 9 times out of 10, and doesn't 1 time out of 10 because it segfaults? :-)

[00:08] <bkeeler> No wonder poor lue struggles with his old powerbook

[00:08] <jnthn> Aye

[00:08] <lue> I has 384 MiB :/

[00:08] <colomon> jnthn: would node that looks up &callwith be 

[00:08] <colomon> PAST::Var.new( :name('&callwith'), 

[00:08] <colomon>                                          :scope('package') )

[00:09] <jnthn> Most likely

[00:09] <jnthn> Yes

[00:09] <lue> Ooh! Bold text! How'd you do that, colomon?

[00:09] *** hanekomu_ left
[00:09] <colomon> I'm not sure.

[00:10] <colomon> I think I must have hit something here that turned on bold.  command b, I guess

[00:10] <jnthn> colomon: oh

[00:10] <bkeeler> oooh

[00:10] <colomon> oh?

[00:10] <jnthn> colomon: No, actually not quite that

[00:10] <jnthn> colomon: Do it like &callwith normally works

[00:10] <bkeeler> can has italics too

[00:10] <jnthn> colomon: run perl6 --target=past

[00:10] <jnthn> Then type &callwith and hit enter to see it

[00:10] <jnthn> But basically

[00:11] <jnthn> PAST::Op.new( :pirop('find_sub_not_null__Ps'), '&callwith' )

[00:11] <colomon> that was a spectacular amount of pir that just flashed by.

[00:12] <jnthn> --target=past, not --target=pir :-) :-)

[00:12] <TimToady> std: I can has red

[00:12] <p6eval> std 30125: OUTPUT«===SORRY!===␤Malformed has at /tmp/tdsIqcplWU line 1:␤------> I can has ⏏red␤    expecting any of:␤       scoped declarator␤        typename␤FAILED 00:01 107m␤»

[00:12] <colomon>             [1] => PMC 'PAST;Stmts'  {

[00:12] <colomon>                 <pos> => 0

[00:12] <colomon>                 <source> => \past

[00:12] <colomon>                 [0] => PMC 'PAST;Op'  {

[00:12] <colomon>                     <pirop> => "find_sub_not_null__Ps"

[00:12] <colomon>                     [0] => "&callwith"

[00:12] <colomon>                 }

[00:12] <colomon>             }

[00:12] <TimToady> bbl &

[00:12] <jnthn> Basically, find_sub_not_null looks in lexpads first, and then after that the package

[00:12] <jnthn> TimToady: o/

[00:12] *** alester joined
[00:13] <jnthn> colomon: Also, callwith will work on user defined ops if you change the lookups of the ops used with Z and X meta-ops to use that instead of the PAST::Var way.

[00:13] <jnthn> Probably.

[00:13] <jnthn> :-)_

[00:13] *** rhr_ joined
[00:14] <colomon> jnthn: do I need that for the inner op sub name as well, or just for &callwith

[00:14] <colomon> ?

[00:14] * colomon wonders if that was what was wrong with X and Z and user-defined ops....

[00:14] <lue> How's the situation on memory usage?

[00:14] <colomon> lue: #parrot is working on it.

[00:15] <lue> ah. ok.

[00:15] <jnthn> colomon: The inner one if you want to fix user defiend ops (and be correct going into the future)

[00:15] <sorear> 10:55 <@darbelo> Are we leaking memory again?

[00:15] <sorear> 10:57 <@particle> i imagine so, can you see a need to use 670MB during a  compile?

[00:15] <sorear> 11:01 <@Coke> particle: it's several THOUSAND lines of nqp.

[00:16] <sorear> 11:11 <@Coke> whoops. that was 1600M on a parrot-nqp invocation, not the parrot  invocation that builds core.pir

[00:16] <sorear> 11:12 <@Coke> (though that too is now up past 1600M)

[00:16] <sorear> 11:37 <@japhb> OK, >1600 MB to compile one NQP file is just crazy.  Sounds like  we need chromatic++'s Mad Leak Huntin' Skillz (tm)

[00:16] *** quietfanatic left
[00:16] <sorear> I think that covers the important cross section of #parrot

[00:16] <colomon> jnthn: now making....

[00:17] <lue> Are you sure it's FREENODE's #parrot? There were only 4 people there, including me (now 3)

[00:18] *** Patterner left
[00:18] <sorear> I never said it was

[00:18] <sorear> It's MAGNET's #parrot

[00:18] <japhb> lue: MAGnet.

[00:18] <sorear> aka irc.perl.org

[00:18] <lue> ah. ok.

[00:18] <sorear> aaka irc.parrot.org

[00:18] <sorear> and it was magnet before either project existed in its modern form

[00:19] *** snarkyboojum_ joined
[00:21] * lue is going to check MAGnet's #perl6 (if there is one)

[00:21] *** snarkyboojum left
[00:21] *** snarkyboojum_ is now known as snarkyboojum

[00:22] <jnthn> sorear: Looking over the Parrot log, I think the point of your patch wasn't grokked properly...

[00:24] <colomon> jnthn: any hints on debugging?

[00:26] <jnthn> colomon: That's...general. :-) Did I miss some context? :-)

[00:26] <jnthn> colomon: What's the problem you get?

[00:26] <colomon> blast, there was supposed to be a paste with it.

[00:26] <jnthn> Oh. :-)

[00:27] <colomon> http://gist.github.com/337095

[00:28] * jnthn looks sadly at his expired beer

[00:28] <jnthn> ...and the nopaste.

[00:28] <sjohnson> drink it anyway!

[00:28] <colomon> $opsub is what is being being, so I think it is right.

[00:29] <colomon> I don't have any mental tools for debugging this sort of thing, I fear...

[00:29] <jnthn> colomon: Where do you stick the code that gets generated here?

[00:29] <lue> jnthn: hit F5 :P

[00:29] <jnthn> sjohnson: no, no, I was more referring to the fact that the bottle is empty. :-)

[00:30] <jnthn> lue: OH IF ONLY that worked!

[00:30] <jnthn> :-)

[00:30] <jnthn> colomon: Can you paste me the full --target=pir for that program?

[00:30] <colomon> jnthn: ummm... nowhere?

[00:30] <jnthn> (for say 1, 2 X~ 'a', 'b'; )

[00:30] <jnthn> nowhere?

[00:30] * jnthn is...confused :-)

[00:30] <colomon> jnthn: I've updated the gist to have more context for the code.

[00:31] <jnthn> Can I see the diff too? It's probably easier to just see what you have.

[00:31] <jnthn> Thanks.

[00:31] <jnthn> yes, that works too

[00:31] <colomon> could it just be I need to add make before the first PAST?

[00:31] <jnthn> That sounds wrong-ish

[00:31] <bkeeler> How do I "unbox" a PMC into a string?

[00:31] <jnthn> bkeeler: Context?

[00:31] *** snarkyboojum_ joined
[00:32] <colomon> oh, I see, I'll get you the --target=pir in a sec.

[00:32] *** snarkyboojum left
[00:32] *** snarkyboojum_ is now known as snarkyboojum

[00:32] <jnthn> bkeeler: (There's more than one answer, it depends what you're doing.)

[00:32] <bkeeler> I'm trying to implement that 'variable in a regex thing'

[00:32] * colomon is recompiling to try a different trick with Z...

[00:32] <bkeeler> And it's generating

[00:32] <bkeeler>     find_lex $P33, "$foo"

[00:32] <bkeeler>     length $I10, $P33

[00:32] <jnthn> And that explodes? :-)

[00:33] <jnthn> What does the code that generates this look like?

[00:33] <bkeeler> it splodes, yes

[00:33] <jnthn> (esp the length call)

[00:33] <jnthn> :pirop('length') ?

[00:33] <bkeeler> Well, I take the PAST::Var node that comes back from the variable parse

[00:33] <bkeeler> And bundle it up in a PAST::Regex node

[00:34] <bkeeler> The Regex PAST->POST thing wants it to be a pir string I think

[00:34] <jnthn> bkeeler: Please can you paste the little bit of code that's doing that?

[00:34] *** yinyin joined
[00:34] <bkeeler>     method metachar:sym<p6var>($/) {

[00:34] <bkeeler>         make PAST::Regex.new( 

[00:34] <jnthn> I think I know the answer, but want to see what you have rather than send you on a false trail :-)

[00:34] <bkeeler>             $<variable>.ast,

[00:34] <bkeeler>             :pasttype('literal')

[00:34] <bkeeler>         );

[00:34] <bkeeler>     }

[00:35] <jnthn> OK, I think that stands a chance of working with one tweak... :-)

[00:35] <jnthn> Change $<variable>.ast

[00:35] <jnthn> to 

[00:35] *** Psyche^ joined
[00:35] *** Psyche^ is now known as Patterner

[00:35] <jnthn> PAST::Op.new( :pirop('set__SP'), $<variable>.ast )

[00:35] <bkeeler> Also see http://github.com/perl6/nqp-rx/blob/master/src/PAST/Compiler-Regex.pir lines 670 ish

[00:35] <jnthn> oops

[00:35] <jnthn> PAST::Op.new( :pirop('set SP'), $<variable>.ast )

[00:35] <jnthn> That one

[00:35] <bkeeler> Thanks

[00:35] <jnthn> Hopefully that works.

[00:36] <jnthn> It'll lead to the expression that gets fed to PAST::Regex having a S register anyway

[00:36] <jnthn> And hopefully it all works from there on in.

[00:36] <bkeeler> Trying...

[00:36] * jnthn is glad he can help @other write code even if he isn't tonight :-)

[00:37] <bkeeler> The long-term leverage effect of teaching others is worth a lot

[00:37] <bkeeler> jnthn++

[00:37] <colomon> jnthn++ indeed!

[00:37] <lue> .oO($_ means "it". What does @_ and %_ mean?)

[00:38] <lue> jnthn++++++++++++++

[00:38] <bkeeler> Is there a bot that keeps track of all the ++?

[00:38] <jnthn> There...was.

[00:39] <jnthn> karma jnthn

[00:39] <jnthn> @karma jnthn

[00:39] <colomon> jnthn: FYI: switching to the find_sub_not_null__Ps thing made the old code for Zop work with user-defined ops.

[00:39] <jnthn> ...there's not now. :-(

[00:39] <jnthn> colomon: \o/

[00:39] <snarkyboojum> jnthn's karma probably exceeded the size of int, so the bot crashed :P

[00:39] <jnthn> colomon: I figured it probably would. I'd debugged it, just not got a fix. Great that you did! :-)

[00:39] <japhb> lue: @_ is 'them'

[00:40] *** Patterner left
[00:40] *** cdarroch_ left
[00:40] <lue> then what is the english language equivalent of %_ ? (TimToady, that's your cue to help!)

[00:40] <colomon> http://gist.github.com/337095 now has the --target=pir output too.

[00:41] <jnthn> colomon: oh.

[00:41] <jnthn> You're essentially making a bunch of PAST...and then throwing it away.

[00:42] <jnthn> So it never makes it to the PIR

[00:42] <jnthn> PAST::Op.new( :pasttype('bind'), ... ) and all the stuff beneath it is in void context

[00:42] <colomon> so.... add "make"

[00:42] <colomon> ?

[00:42] <colomon> or                     @BLOCK[0].loadinit.push(

[00:42] <colomon> ?

[00:42] <jnthn> The second.

[00:43] <jnthn> make means "this is the PAST I want to produce for the bit of code I just parsed"

[00:43] <jnthn> The thing you want to do at the point you see it in the code is look it up though.

[00:43] <jnthn> The code to generate it needs to be run at load/init time.

[00:44] <jnthn> So needs to be stashed away somewhere else, and the loadinit of the current block is *maybe* OK

[00:44] <colomon> trying that...

[00:44] <jnthn> It'll work for now.

[00:45] <jnthn> We'll re-visit it a bit later, I have a feeling that it'll be wrong in some cases.

[00:45] <bkeeler> Is there a way to do 'perl6 --target=pir', tweak the pir, then run it?

[00:46] <jnthn> kinda

[00:46] *** Psyche^ joined
[00:46] *** Psyche^ is now known as Patterner

[00:47] <jnthn> You'd need to add some "loader" code at the top to load_bytecode 'perl6.pbc' I guess

[00:47] <jnthn> Then you'd run it with parrot executable, not perl6 one.

[00:47] <jnthn> It is possible, though.

[00:47] <lue> does --target "compile" perl6 code?

[00:48] <jnthn> Yes

[00:49] <jnthn> Basically it says "rather than running this code, stop at <this stage>"

[00:49] <jnthn> It normally goes through those stages anyway on the way to running.

[00:50] <lue> perl6 --control-parrot --parrot-target="machinecode"

[00:51] <jnthn> Sadly, NYI. :-)

[00:52] <lue> I can't wait to compile P6 scripts!

[00:53] <bkeeler> It would be really nice if you could just do './perl6 foo.pir' and have it DTRT

[00:54] <colomon> http://gist.github.com/337095 now has the latest error.  :(

[00:55] <jnthn> colomon: can you perl6 -e it so there's a stacktrace?

[00:55] <jnthn> (want to see where the NPMCA happens)

[00:56] <colomon> how do you -e it?

[00:56] <jnthn> perl6 -e "say 1, 2 X~ 'a', 'b';"

[00:56] <jnthn> Then it should say a little more than "Null PMC Access"

[00:57] <colomon> Null PMC access in clone()

[00:57] <colomon> current instr.: '&callwith' pc 17300 (src/builtins/Capture.pir:123)

[00:57] <colomon> called from Sub 'perl6;Code;assuming_helper' pc 12743 (src/builtins/Str.pir:38)

[00:57] <colomon> can past more if you need it.

[00:57] *** lestrrat is now known as lest_away

[00:57] *** hercynium joined
[00:57] <jnthn> colomon: argh, you copied my FAIL!

[00:57] <jnthn> &callwith

[00:57] <jnthn> Shoudl be &crosswith :-) :-)

[00:57] <colomon> doh!

[00:57] <jnthn> Group failing!

[00:57] <lue> .oO(every error should begin with DON'T PANIC!)

[00:57] <colomon> I actually kept on wanting to make it "callwidth"

[00:58] <jnthn> bkeeler: Are you wanting to do this with Rakudo code or NQP code, by the way?

[00:58] <bkeeler> Rakudo

[00:58] <jnthn> OK

[00:59] <jnthn> One other thing that can work is a "cheat"

[00:59] <jnthn> Put the code in a sub and mark it is export

[00:59] <jnthn> or just actually make it "our"

[00:59] <jnthn> put it in a PIR file

[00:59] <jnthn> then "need name_of_pir_file;"

[00:59] <jnthn> or use maybe

[00:59] <jnthn> (if you do the is export route)

[00:59] <jnthn> That way is easier, since the Perl 6 environment is already set up

[00:59] <jnthn> So it's just like loading a pre-compiled module.

[01:00] <lue> there's still the array pairs/exists to do, right? If so, any place where those two would be described in detail (besides S32, it's not in detail there)

[01:00] <bkeeler> Ahh nice one

[01:00] <jnthn> lue: See the existing tests perhaps.

[01:00] <jnthn> Or the existing imeplemntation

[01:00] <jnthn> alpha did them both

[01:00] <lue> that's what I did (tests). Just hoping it was specced.

[01:01] <jnthn> Feel free to patch the spec too ;-)

[01:01] <lue> rakudo: my Pair $a=3,4; say $a

[01:01] <p6eval> rakudo 1e9aa0: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 16934 (src/builtins/Junction.pir:399)␤»

[01:01] <jnthn> 3 => 4

[01:01] <snarkyboojum> how do I use the exists pir op in Array.pm? This doesn't work http://paste.lisp.org/display/96589

[01:01] <snarkyboojum> :)

[01:01] <lue> Oh yeah! I keep on forgetting :)

[01:01] <lue> SNARKYBOOJUM! :D

[01:02] <jnthn> snarkyboojum: Oh...ouch

[01:02] <snarkyboojum> there's bugs in that code anyway :)

[01:02] <snarkyboojum> heh

[01:02] * snarkyboojum is a newbie remember :)

[01:02] <snarkyboojum> i.e. I don't know what I'm doing heh

[01:02] <jnthn> snarkyboojum: try pir::exists__PPP(self, $index)

[01:02] <snarkyboojum> jnthn: ok - thanks :)

[01:02] <jnthn> But keyed ops and pir::foo don't always go together. :-(

[01:03] <bkeeler> ./perl6 'need foo.pir';  <- gives Unable to open filehandle from path 'need foo.pir'

[01:03] <jnthn> keyed ops are this wonderful thing when hand-writing PIR code, and a horrible thing for writing compilers

[01:03] <jnthn> bkeeler: remove the .pir

[01:03] <bkeeler> Bah, need -e

[01:03] <jnthn> bkeeler: it's implicit

[01:03] <colomon> > say 1, 2 X~ 'a', 'b';

[01:03] <colomon> 1a1b2a2b

[01:03] <colomon> jnthn++

[01:03] * snarkyboojum write that down for a time when he'll understand it :)

[01:03] <snarkyboojum> jnthn: thanks

[01:03] <jnthn> snarkyboojum: Sorry, was just having a Parrot design whine. :-)

[01:03] <lue> snarky: I only yelled because of your impeccable timing cocering array.exists :)

[01:03] <bkeeler> Unable to find module 'foo'

[01:03] <bkeeler> Does it look in '.'?

[01:04] <jnthn> yeah but for .pm

[01:04] *** takadonet joined
[01:04] <jnthn> touch foo.pm

[01:04] <snarkyboojum> lue: let's get em done today :)

[01:04] <jnthn> it'll ignore it if the .pir is there

[01:04] <colomon> > say 1, 2 RX~ 'a', 'b';

[01:04] <colomon> No applicable candidates found to dispatch to for 'crosswith'. Available candidates are:

[01:04] <colomon> :(&op, Iterable $a-iterable, Iterable $b-iterable)

[01:04] <bkeeler> Perfect, thanks

[01:04] <jnthn> Though this trick won't work forever :-)

[01:05] <snarkyboojum> battery about to die.. bbl :)

[01:05] <jnthn> kk o/

[01:05] <jnthn> colomon: Aww.

[01:05] <colomon> jnthn: I'll bet R thinks it has a scalar on both sides, or something like that.

[01:05] <lue> I guess Rakudo/Parrot knows not to cross the beams :P

[01:05] <jnthn> Oh, may be that.

[01:06] <lue> (couldn't resist)

[01:06] <jnthn> lol

[01:06] <jnthn> colomon: How's R implemented?

[01:06] <jnthn> Perl 6 sub or PIR?

[01:06] <colomon> PIR

[01:06] <jnthn> ah

[01:06] <colomon> though I was just thinking it would be easy to re-implement it on the new X model.

[01:06] <jnthn> That means it's not premature context enforcization then.

[01:07] <jnthn> Yeah

[01:07] <jnthn> Can you nopaste the PIR for that one?

[01:07] <jnthn> I'm curious

[01:07] <jnthn> It may be something easy

[01:08] <jnthn> colomon: oh

[01:08] <jnthn> :-/

[01:08] <jnthn> I think assuming needs a fix.

[01:08] <colomon> did you find metaops.pir?

[01:08] <jnthn> colomon: YOu know the signature of crosswith?

[01:09] <jnthn> Can you s/&/$/ on the first arg and try it?

[01:09] <jnthn> If that makes it work, it means assuming is broken.

[01:09] *** snarkyboojum left
[01:09] <colomon> ok, trying...

[01:10] <colomon> PIR for reverse is in metaops.pir, as I tried to say above -- that's easier than pasting.  :)

[01:10] <jnthn> Holland has awesome symphonic metal bands. :-)

[01:10] <jnthn> (off-topic random thought :-))

[01:11] <jnthn> colomon: If you write it in Perl 6, it may be wise to have the signature as (\$a, \$b)

[01:11] <jnthn> So you don't enforce any context.

[01:11] <colomon> reverse, you mean?

[01:12] <jnthn> Yes

[01:12] <lue> Oh those happen all the time jnthn. Especially in planets orbiting the red dwarf Op.

[01:12] <colomon> it would have to be (&op, \$a, \$b), right?

[01:12] <jnthn> Correct.

[01:14] <colomon> jnthn: changing &op to $op did not help:

[01:14] <colomon> > say 1, 2 RX~ 'a', 'b';

[01:14] <colomon> No applicable candidates found to dispatch to for 'crosswith'. Available candidates are:

[01:14] <colomon> :(Any $op, Iterable $a-iterable, Iterable $b-iterable)

[01:14] <jnthn> Aww.

[01:15] <colomon> oh, hey I see.

[01:15] <jnthn> assuming is still wrong, I think

[01:15] <colomon> Z~ is list_infix

[01:15] *** justatheory joined
[01:15] <colomon> RZ~ is item_assignment

[01:16] <colomon> so it just gets the two scalars on either side, which aren't Iterable.

[01:16] <colomon> so, that brings up my other big meta issue.

[01:16] <colomon> how do I mean Rop (for instance) get the precedence of op?

[01:17] <jnthn> Oh!

[01:17] <jnthn> So does: say (1, 2) RX~ ('a', 'b') # work, for example?

[01:18] *** agentzh joined
[01:19] *** aesop_ left
[01:19] <colomon> > say (1, 2) RX~ ('a', 'b')

[01:19] <colomon> a1a2b1b2

[01:19] <jnthn> \o/

[01:19] <jnthn> OK, good.

[01:20] <jnthn> So we're down to a precedence issue, essentially.

[01:20] <colomon> yes.

[01:20] <jnthn> We'll need to deal with transparent precedence with hypers anyway, Ithink.

[01:20] <colomon> imo

[01:20] <jnthn> Yeah, I concur that's what it is.

[01:20] <colomon> and we need to deal with it for R already.

[01:20] <jnthn> Right.

[01:20] <colomon> I've been meaning to write tests to show it is broken.  :)

[01:21] <jnthn> It'll take a little effort to fix that, I think.

[01:21] <jnthn> Twiddling our O

[01:21] <jnthn> (as in <O(...)>

[01:21] <colomon> it just never occurred to me that precedence could also control how many arguments you get .

[01:21] <colomon> right, it's very simple in STD

[01:21] <jnthn> :-)

[01:22] <jnthn> Once we figure out how to map that incantation from STD to Rakudo (which I hope won't be too hard, twiddle away if you like) it should be easy enough.

[01:22] <colomon> $<O> = $<infixish><O>;

[01:22] <jnthn> If you := it, then it may just work.

[01:22] <colomon> that's the STD version!

[01:22] <jnthn> But I'm not convinced.

[01:22] <jnthn> Yeah

[01:22] <jnthn> It may just work in Rakudo with s/=/:=/

[01:22] <bkeeler> Gah.  There's a bug in the regex code.  Sooooo clode

[01:23] <jnthn> If it does, awesome.

[01:23] <jnthn> bkeeler: aww :-(

[01:23] <jnthn> I really, really need to sleep in 5 mins or so

[01:23] <lue> .oO(how many kinds of operators are there? Like hyperoperators, metaoperators...)

[01:23] <jnthn> lue: Infinitely many ;-)

[01:23] <colomon> lue: hyperoperators are a kind of metaoperators.

[01:23] <jnthn> But only finitely many meta-operators

[01:23] <jnthn> Well

[01:24] <jnthn> Depending how you look at it

[01:24] <jnthn> :-)

[01:24] <colomon> jnthn: understood about the sleep.

[01:24] <colomon> I need to get ready for the RPG convention next week.

[01:24] *** eternaleye joined
[01:24] <colomon> :)

[01:24] <jnthn> Nice :-)

[01:25] *** sorear joined
[01:25] *** snarkyboojum joined
[01:25] <lue> bah. I want to name a sun in this galaxy/universe of ours Op. I want to make sure it has the correct number of orbiting planets :)

[01:26] *** lest_away is now known as lestrrat

[01:28] <lue> hello snarky o/

[01:28] <snarkyboojum> lue: hello!

[01:29] <colomon> > say 4 R- 3;

[01:29] <colomon> too few positional arguments: 1 passed, 2 (or more) expected

[01:29] <colomon> that's with the precedence patch from STD.  :(

[01:29] <lue> STD--

[01:29] <snarkyboojum> my playing with rakudo definitely appears to be a process of natural selection :)

[01:29] <lue> (jk)

[01:29] <colomon> whoops, except I forgot to switch it to :=

[01:29] <lue> STD++

[01:30] <jnthn> OK, sleep for me.

[01:30] <jnthn> I wish you all happy hacking! :-)

[01:30] <snarkyboojum> nightio

[01:30] <jnthn> Have fun 

[01:30] <lue> goodnight jnthn! o/

[01:30] <jnthn> night o/

[01:30] <sorear> jnthn: I'll... have you help me convince others tommorrow then.

[01:30] <sorear> (I thought you were a Parrot core dev?)

[01:30] <jnthn> sorear: I...used to be.

[01:30] <lue> ...about what?

[01:30] <jnthn> I still have my commit bit, but I'd rather get consensus. :-)

[01:30] <colomon> with := it fails to compile.  :(

[01:31] <colomon> night, jnthn++

[01:31] <sorear> jnthn: Politics?

[01:31] <lue> rakudo: my $a=3; $a :=$b; say $b

[01:31] <p6eval> rakudo 1e9aa0: OUTPUT«Symbol '$b' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[01:31] <lue> rakudo: my $a=3; my $b := $a; say $b

[01:31] <jnthn> colomon: Did you copy double {{ or just single? use single if so

[01:31] <p6eval> rakudo 1e9aa0: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 16934 (src/builtins/Junction.pir:399)␤»

[01:31] <lue> colomon: there's your problem! NYI!

[01:32] <jnthn> sorear: Well, just throwing in a patch people are uneasy about - even if I think it should go in - is kinda bad form without discussing it first.

[01:32] <sorear> jnthn: are you on the parrot list?

[01:32] <jnthn> Yes

[01:32] <jnthn> I try and read the bits I think matter

[01:32] <jnthn> Feel free to make a post there

[01:32] <sorear> jnthn: I meant wrt "used to be a core dev"

[01:32] <colomon> I didn't copy { } at all.  Trying that now.

[01:32] <jnthn> Then I can reply to it

[01:32] <jnthn> sorear: No, I meant in terms of "actively committing lots of stuff to Parrot" :-)

[01:32] <jnthn> I still patch it now and then.

[01:34] <jnthn> sorear: Anyway, I'd pitch it as, "the Parrot interface to dlopen is incomplete, and Blizkost development - which in turn matters for Rakudo * - has just hit upon the incompleteness. This patch adds a way - with platform abstractions - to expose the functionality we need to make progress."

[01:35] <lue> afk

[01:36] <jnthn> To me that makes it pretty clear that the thing the patch is aiming for is needed. Beyond that, folks I guess can look at the patch and say it's going the wrong way about it (though it looked sane to me).

[01:36] <jnthn> But "we're not going to have a complete interface to loading native libraries because only one thing needs it now" is kinda silly to me.

[01:36] <TimToady> alpha: say ('*' Xx 1..5) X~ "\n"

[01:37] <p6eval> alpha 30e0ed: OUTPUT«*␤**␤***␤****␤*****␤␤»

[01:37] <colomon> > say 4 R- 5

[01:37] <colomon> Null PMC access in get_string_keyed()

[01:37] <colomon> that's with

[01:37] <colomon> token infix_prefix_meta_operator:sym<R> { <sym> { $<O> := $<infixish><O> } }

[01:37] <jnthn> oh

[01:37] <colomon> errr... though where can it even it infixish, now that I look at it?

[01:37] <jnthn> erm...I guess our infix_prefix_meta_operator looks rather different to STDs

[01:38] <colomon>     token infix_prefix_meta_operator:sym<R> {

[01:38] <colomon>         <sym> {} <infixish(1)>

[01:38] <colomon>         <.can_meta($<infixish>, "reverse the args of")>

[01:38] <colomon>         <?{ $<O> = $<infixish><O>; }>

[01:38] <colomon>     }

[01:38] <colomon> yes.

[01:38] <jnthn> OK

[01:38] <colomon> (that's STD's)

[01:38] <jnthn> Hmm

[01:38] <colomon> I don't see why we can't switch over to something more like that version?

[01:38] <jnthn> That may well be worth a try.

[01:39] <TimToady> your version never actually matches the infix

[01:39] <colomon> what is the {} after <sym> intended to do there?

[01:39] <jnthn> I think mark end of LTM?

[01:39] *** eternaleye left
[01:39] <TimToady> correct

[01:39] <TimToady> it's faster than using ::

[01:39] * colomon desperately needs to beef up his perl 6 regex skills...

[01:39] <jnthn> oh

[01:39] <TimToady> because :: implies a bunch of lazymaps

[01:40] <jnthn> | <OPER=infix_prefix_meta_operator> <infixish>

[01:40] <jnthn> heh

[01:40] <jnthn> that's how we do it now

[01:40] <colomon> right.

[01:40] <colomon> .oO(I did that...)

[01:40] <jnthn> .oO( it's hard to go to bed with all this Rakudo! )

[01:40] *** eternaleye joined
[01:40] <bkeeler> Stay up!

[01:40] *** jaldhar joined
[01:41] <jnthn> I'm rather confused what the <OPER=...> is all about...

[01:41] <astrojp> Is this pacakge the correct one to install for the ICU library? 'libicu40' I'm using Ubuntu, trying to build Rakudo.

[01:41] <TimToady> is that the fakey LTM?

[01:42] <bkeeler> > my $foo = 'it'; say "zomgitworks" ~~ /zomg $foo works/

[01:42] <bkeeler> zomgitworks

[01:42] <jnthn> oh, I think it's redundant

[01:42] <jnthn> bkeeler: omg!

[01:42] <jnthn> \o/

[01:42] <colomon> jnthn: that would be me trying to imitate what was going on two lines before.

[01:42] <colomon> bkeeler++  \o/

[01:42] <bkeeler> Regex engine bug = FIXT

[01:42] <jnthn> colomon: OK, no worries

[01:42] <jnthn> bkeeler++ bkeeler++

[01:43] <bkeeler> Rakudo feature = IMPLEMENTED

[01:43] <jnthn> Wow, another priority 1 ROADMAP item falls. :-)

[01:44] <bkeeler> So who can commit to nqp-rx in the asbence of pm?

[01:44] <jnthn> colomon: Maybe try doing the { $<O> ... } thingy in infixish after | <OPER=infix_prefix_meta_operator> <infixish>

[01:44] <jnthn> oh

[01:44] <jnthn> but that'll get it wrong for ops that don't want transparent

[01:44] <jnthn> :-(

[01:44] <jnthn> I think we're gonna have to refactor to be more STD-ish.

[01:44] <colomon> it's okay, I'll do a bit of a reorganization to look more like std

[01:44] <colomon> right.

[01:44] <jnthn> bkeeler: Good question.

[01:44] <colomon> :)

[01:45] <bkeeler> perlpilot has the last commit there so he can at least

[01:45] <jnthn> I wonder if I can...

[01:45] <jnthn> bkeeler: The other issue is that nqp-rx then somehow needs to be re-integrated into the Parrot tree and then we get it for Rakudo through that.

[01:46] <jnthn> bkeeler: And...I'm not sure who knows that part. Is your patch somewhere on github (e.g. do you have your own clone)?

[01:46] <bkeeler> jnthn: Yeah, I guess that's up to the parrot folks to pull it

[01:46] <bkeeler> Yeah, I do

[01:46] <jnthn> Well, pmichaud normally pushed it iirc.

[01:46] <jnthn> OK

[01:46] <jnthn> I'll try and look into that tomorrow.

[01:47] <jnthn> I actually don't know the procedure off hand.

[01:47] <TimToady> I wonder how close you guys are to just being able to run STD straight up...  :)

[01:47] <jnthn> TimToady: Getting closer every day, it seems.

[01:47] *** jql joined
[01:47] <jnthn> It will be Very Cool. :-)

[01:47] <jnthn> OK, I really, really will sleep now!

[01:48] <astrojp> cool, it's already installed.

[01:48] <TimToady> nighty night

[01:48] <jnthn> night all, awesome hacking \o/ 

[01:48] <jnthn> o/

[01:48] <colomon> o\

[01:49] <bkeeler> G'night!

[01:52] *** Raugturi joined
[01:53] *** Raugturi left
[01:56] <bkeeler> Spec tests pass!  yay, I didn't break anything

[01:57] <bkeeler> I need a break I think

[01:57] <bkeeler> TODO list:  1) nom 2) watch last night's Daily Show/Colbert 3) Practice my Bach and 4) more hacking!

[01:58] <bkeeler> laterz.......

[02:02] *** y0ngbin joined
[02:07] *** aesop_ joined
[02:07] *** aesop_ is now known as aesop

[02:08] <colomon> wow, switching <infixish> from inside <infixish> to inside the infix_prefix_meta_operator tokens is a huge fail.  no idea why.

[02:08] <colomon> "Null PMC access in get_pmc_keyed()" during the build

[02:12] *** stephenlb left
[02:18] *** xomas left
[02:27] *** wknight8111 left
[02:33] <snarkyboojum> std: my @a = <1 2 3>; say @a[1]:exists;

[02:33] <p6eval> std 30125: OUTPUT«ok 00:01 108m␤»

[02:34] *** justatheory left
[02:35] <snarkyboojum> std: my @a = <1 2 3>; say @a[1] :exists;

[02:35] <p6eval> std 30125: OUTPUT«ok 00:01 107m␤»

[02:35] <snarkyboojum> std: my @a = <1 2 3>; say @a[1] exists;

[02:35] <p6eval> std 30125: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/OpEtQdug7f line 1:␤------> my @a = <1 2 3>; say @a[1] ⏏exists;␤    expecting any of:␤     bracketed infix␤  infix or meta-infix␤      statement modifier loop␤FAILED 00:01 107m␤»

[02:35] <snarkyboojum> std: my @a = <1 2 3>; say @a.exists(0);

[02:35] <p6eval> std 30125: OUTPUT«ok 00:01 107m␤»

[02:38] *** justatheory joined
[02:43] *** astrojp left
[02:49] <colomon> jnthn: fail on redoing grammar to be more like STD.  and reverting back to the old code, it turns out we don't pass cross-metaop.t with the changes in place.  looks like this one might actually be an assuming bug?  anyway, will try to hunt down next time I get a chance, but tomorrow looks MEGA busy.

[02:53] *** alester left
[03:05] <snarkyboojum> rakudo: my int $i = 5;

[03:05] <p6eval> rakudo 1e9aa0: OUTPUT«Malformed my at line 11, near "int $i = 5"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[03:05] <snarkyboojum> rakudo: my Int $i = 5;

[03:05] <p6eval> rakudo 1e9aa0:  ( no output )

[03:05] <snarkyboojum> alpha: my int $i = 5;

[03:06] <p6eval> alpha 30e0ed: OUTPUT«Malformed declaration at line 10, near "int $i = 5"␤in Main (file <unknown>, line <unknown>)␤»

[03:06] <snarkyboojum> std: my int $i = 5;

[03:06] <p6eval> std 30125: OUTPUT«ok 00:01 108m␤»

[03:07] <lue> hello again!

[03:14] <snarkyboojum> hi lue

[03:14] <snarkyboojum> I'm having fun trying to get exists going ;)

[03:17] <snarkyboojum> how do I create a parrot int from rakudo - i.e. result in something that does $I0 = 5 in PIR

[03:18] *** justatheory left
[03:23] *** justatheory joined
[03:27] *** sorear left
[03:27] <lue> I do not know (busy watching DW on the intertubes...)

[03:28] *** [synth] left
[03:29] <snarkyboojum> alpha: my @a = <a b c>; say (@a.exists(1)).WHAT

[03:29] <p6eval> alpha 30e0ed: OUTPUT«Bool()␤»

[03:29] *** synth joined
[03:33] <snarkyboojum> rakudo: my Int $i = 0; say $i;

[03:33] <p6eval> rakudo 1e9aa0: OUTPUT«0␤»

[03:33] <snarkyboojum> rakudo: my Int $i = 0; say $i.WHAT;

[03:33] <p6eval> rakudo 1e9aa0: OUTPUT«Int()␤»

[03:34] <snarkyboojum> rakudo: my Int $i = 0; say $i.WHAT.^parents;

[03:34] <p6eval> rakudo 1e9aa0: OUTPUT«Any()Mu()␤»

[03:36] *** sorear joined
[03:39] *** agentzh left
[03:54] *** envi^home joined
[04:00] <spinclad> phenny, karma STD 

[04:01] <spinclad> hugme, help

[04:01] <hugme> spinclad: (add $who to $project | list projects | show $project | hug $nickname | tweet $twittername $message )

[04:03] *** obra left
[04:06] *** obra joined
[04:10] <lue> HUGME'S BACK!

[04:10] <lue> hugme: hug me

[04:10] * hugme hugs lue

[04:10] <lue> YES!

[04:12] * sorear hugs lue too

[04:12] <lue> hugme: hug sorear

[04:12] * hugme hugs sorear and blushes

[04:12] <lue> hugme: hug TimToady

[04:12] * hugme hugs TimToady

[04:12] <lue> hugme: hug hugme

[04:12] * hugme hugs hugme

[04:13] <lue> glad it's back :D

[04:13] <lue> afk

[04:17] *** alester joined
[04:35] *** patt joined
[04:50] *** patt left
[05:15] *** snarkyboojum left
[05:15] *** jhuni joined
[05:25] *** TimToady sets mode: +vvv buubot dalek hugme

[05:25] *** TimToady sets mode: +vv ilogger2 IRSeekBot

[05:25] *** TimToady sets mode: +vv p6eval phenny

[05:28] *** quietfanatic joined
[05:29] *** Guest39075 is now known as Trashlord

[05:29] *** Trashlord left
[05:29] *** Trashlord joined
[05:31] * araujo wonders if there is some regexp wizard here

[05:32] <araujo> or unix one ... looking for a command to give the common code between two files

[05:32] <araujo> any idea?

[05:32] *** vamped joined
[05:37] <vamped> well, i've never used it before, but there is a "diff" command in linux. -i ignore case... see man page

[05:37] <vamped> also commands: cmp, comm

[05:38] <vamped> araujo: i think comm is what you may want to try first

[05:38] *** vamped left
[05:39] <sorear> see also cpd

[05:39] *** uniejo joined
[05:41] *** clkao_ joined
[05:42] * sorear wonders what vamped is doing to connect in such an unusual way

[05:42] *** clkao_ is now known as clkao

[05:47] *** araujo left
[05:50] *** ShaneC left
[05:51] *** araujo joined
[05:52] *** justatheory left
[06:02] *** mberends joined
[06:19] <mberends> rakudo: BEGIN { say "beginning"; }; say "main";

[06:19] <p6eval> rakudo 1e9aa0: OUTPUT«main␤»

[06:21] <mberends> alpha: BEGIN { say "beginning"; }; say "main";

[06:21] <p6eval> alpha 30e0ed: OUTPUT«beginning␤main␤»

[06:23] <uniejo> rakudo: say "main"; INIT { say "init" }

[06:23] <p6eval> rakudo 1e9aa0: OUTPUT«init␤main␤»

[06:23] *** xinming joined
[06:24] <mberends> uniejo: thanks, I'll try that in proto right now :-)

[06:25] <mberends> hmm, it's not early enough for this: BEGIN { @*INC.unshift('lib'); }

[06:26] * mberends thinks of a workaround using the Perl 5 part

[06:31] *** uniejo left
[06:37] *** yinyin left
[06:54] *** yinyin joined
[06:56] *** kaare joined
[06:57] *** kaare is now known as Guest44199

[07:01] *** Guest44199 left
[07:11] *** cotto left
[07:15] *** agentzh joined
[07:15] <mathw> bah

[07:15] <mathw> Form doesn't compile with master :(

[07:15] <araujo> mm...

[07:15] <mathw> it's not giving me happy error messages

[07:15] <araujo> comm seems what I wanted .. but not giving the right results it seems

[07:16] <mberends> mathw: I know the feeling.. proto is in the same state

[07:17] <moritz_> good morning

[07:17] <mberends> welcome back moritz_

[07:18] <mathw> it's also failing to tell me accurately which file it's got a problem with

[07:20] *** uniejo joined
[07:22] <mathw> rakudo: my @a = "1", "2", "3"; @a.map: *.chars;

[07:22] <p6eval> rakudo 1e9aa0:  ( no output )

[07:22] <mathw> rakudo: my @a = "1", "2", "3"; [+] @a.map: *.chars;

[07:22] <p6eval> rakudo 1e9aa0: OUTPUT«Confused at line 11, near "[+] @a.map"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[07:22] <mathw> rakudo: my @a = "1", "2", "3"; my $r = [+] @a.map: *.chars;

[07:22] <p6eval> rakudo 1e9aa0: OUTPUT«Confused at line 11, near "my $r = [+"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[07:22] <mathw> ahah

[07:22] <mathw> rakudo: my @a = "1", "2", "3"; my $r = [+] @a.map: { .chars };

[07:22] <p6eval> rakudo 1e9aa0: OUTPUT«Confused at line 11, near "my $r = [+"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[07:22] <moritz_> rakudo: say [+] 1, 2, 3

[07:22] <p6eval> rakudo 1e9aa0: OUTPUT«Confused at line 11, near "say [+] 1,"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[07:23] <moritz_> there you go, reduce meta-op not yet implemented

[07:23] <mathw> lovely

[07:23] <mathw> I use that quite extensively in this one file

[07:23] * moritz_ too

[07:23] <moritz_> alpha: my @a = "1", "2", "3"; say [+] @a.map: *.chars;

[07:23] <p6eval> alpha 30e0ed: OUTPUT«3␤»

[07:23] <mathw> yeah it used to work

[07:24] *** finanalyst joined
[07:25] <mathw> urgh

[07:25] <mathw> for loops are so clumsy

[07:26] <moritz_> rakudo: say (1, 2, 3).reduce: &infix:<+>

[07:26] <p6eval> rakudo 1e9aa0: OUTPUT«6␤»

[07:26] *** cotto joined
[07:26] <mathw> ooh

[07:28] <finanalyst> Yesterday I saw a rakudo release announcement on the perl developer list, but nothing on the perl6-language list. Was that an error, or do I have a problem receiving p6l?

[07:29] <mathw> I didn't see a rakudo announcement on p6l either

[07:30] <mberends> getting the announcements out everywhere is, strangely enough, harder than producing a technically sound release. Also, there are strange delays in some of the messaging systems.

[07:31] *** Chillance left
[07:32] <finanalyst> a) relief! its not my spam system, which has been trashing excessively recently. b) i noted that traffic on p6l has been quite low recently.

[07:32] <mathw> oooh damn

[07:32] <mathw> named enums

[07:32] <mathw> we don't have named enums yet do we

[07:33] <mathw> Form uses them quite extensively

[07:33] <mathw> I will have to wait...

[07:33] <mathw> in the mean time, I should go to work

[07:33] *** alester left
[07:43] *** kaare joined
[07:43] *** kaare is now known as Guest11603

[07:45] *** envi^home left
[07:53] *** cotto left
[07:55] *** fridim joined
[07:58] *** mberends left
[07:59] *** drbean joined
[08:02] *** iblechbot joined
[08:05] *** fridim left
[08:07] *** drbean_ joined
[08:07] *** drbean left
[08:17] *** mberends joined
[08:22] *** drbean_ left
[08:25] *** riffraff joined
[08:30] *** drbean joined
[08:36] *** drbean left
[08:37] *** drbean joined
[08:38] *** am0c joined
[08:40] *** Su-Shee joined
[08:46] *** IllvilJa joined
[08:48] *** hanekomu_ joined
[08:55] <colomon> o/

[08:55] <mathw> o/

[09:02] * colomon is completely mystified by his cross-metaops.t fails.

[09:07] *** payload1 left
[09:10] * mathw is weeping for named enums

[09:10] *** lestrrat is now known as lest_away

[09:12] *** payload joined
[09:18] *** payload left
[09:20] *** payload joined
[09:27] *** Sarten-X left
[09:28] *** Sarten-X joined
[09:30] *** payload1 joined
[09:30] *** payload left
[09:31] *** yinyin left
[09:33] *** clintongormley joined
[09:37] <colomon> mathw: work is underway on named enums.  masak++

[09:38] <mathw> I know, but I needed them two hours ago!

[09:39] <mathw> It's quite a shock to come up against the regressions like that

[09:46] *** y0ngbin left
[09:49] *** iblechbot left
[09:51] *** payload1 left
[10:01] *** payload joined
[10:03] *** smash_ joined
[10:03] <smash_> hello everyone

[10:04] <mberends> hi smash_, well done on the Copenhagen release!

[10:06] <smash_> mberends: thank you, many complaints already ?

[10:08] <mberends> no, we can cause plenty of new ones and blame ourselves

[10:10] *** payload left
[10:16] *** dre joined
[10:17] *** payload joined
[10:17] *** dre left
[10:17] *** dre_dre joined
[10:18] *** dre_dre left
[10:18] *** bkeeler left
[10:31] *** snarkyboojum joined
[10:34] *** agentzh left
[10:41] *** payload left
[10:46] *** bkeeler joined
[10:48] *** Yanz joined
[10:49] *** Yanz is now known as Yanzie

[10:49] <Yanzie> Hello, I run backtrack 4 final, does  Perl come pre-installed on this?

[10:50] *** xomas joined
[10:54] *** Yanzie left
[10:56] <snarkyboojum> Yanzie: Perl 5 may

[10:57] <snarkyboojum> oops helps to reply to people still in the room

[11:00] *** payload joined
[11:01] *** hanekomu_ left
[11:01] *** am0c left
[11:02] *** am0c joined
[11:19] *** masak joined
[11:34] *** ilogger2 joined
[11:35] *** payload joined
[11:37] *** fda314925 joined
[11:44] *** payload left
[11:47] *** payload joined
[11:49] *** envi^home joined
[11:52] <masak> snarkyboojum: it strikes me that if we'd implemented the 'go' sub as a multi, the mistakes I made would never have had a chance to creep in. :)

[11:52] <snarkyboojum> masak: aye

[11:52] <masak> I'll write up a patch for that.

[11:53] <snarkyboojum> has similar thoughts when banging it out the first time.. but thought "I'll just keep it simple and make it work" :)

[11:53] <snarkyboojum> cool

[11:53] <snarkyboojum> s/has/had/

[11:53] <masak> nod.

[11:53] <colomon> jnthn: nope, I've done no patching yet.

[11:54] <masak> it actually becomes simpler now, because the if cases melt away.

[11:55] <jnthn> (multi dispatch)++ :-)

[11:55] <snarkyboojum> multi rocks :)

[11:55] <colomon> jnthn: I figured I'd do the improved action version of Xop and Zop, and then when that didn't work I gave up and collapsed into bed.

[11:55] <snarkyboojum> kinda reminds me of my first year uni days learning pattern matching in Haskell (kinda)

[11:56] <snarkyboojum> even tho I'm sure it's very different ;P

[11:57] <jnthn> colomon: Ah, fair enough.

[11:57] <colomon> I'll take a stab at it right now, because it's a dead cinch I'm not getting a big project done today.

[11:58] * colomon has 3 estimators visiting the house from 3 different moving companies today, plus closing on selling our house.

[11:59] <jnthn> Wow!

[12:01] <colomon> first guy should be here any moment (8am our time)

[12:10] *** nihiliad joined
[12:24] *** frettled left
[12:39] <snarkyboojum> masak: the multi subs are beautiful :)

[12:39] <masak> :)

[12:40] <dalek> rakudo: 9affb78 | (Solomon Foster)++ | src/Perl6/Actions.pm:

[12:40] <dalek> rakudo: Better internal op lookup for Xop and Zop.

[12:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9affb78498eefde2e6ed291c853d16a3c5fe5977

[12:41] <takadonet> are we passing more tests now then we did before the merge of ng branch?

[12:41] <colomon> nope

[12:42] <colomon> but we're getting back about 1000 tests a week at the moment.

[12:44] <masak> wow.

[12:44] <[particle]> HA!  "is there a production release date?"  hilarious.

[12:46] <jnthn> If somebody wants to have everlasting fame for winning back some thousand or so tests, there's some more in S05-mass

[12:46] <jnthn> If somebody wants to write a P5Regex compiler that targets PAST::Regex we can start to handle :perl5 adverb again to ;-) ;-)

[12:46] <jnthn> *too

[12:47] <masak> sounds like fun.

[12:47] <jnthn> YAY VICTIM!

[12:47] <[particle]> ...there's a sucker born every minute.

[12:47] <jnthn> er, volunteer.

[12:47] <jnthn> :-)

[12:47] <masak> I don't know what you're talking about :)

[12:51] <masak> TimToady: [backlog] I think I would expect hyperops to mirror the precedences of their corresponding inner ops, yes.

[12:51] <masak> TimToady: but I wouldn't mind being forced to parenthesize there too, on the grounds that I'm doing something very advanced and should be a bit careful/clear with what I'm doing.

[12:52] *** nacho joined
[12:54] *** [synth] joined
[12:56] <colomon> masak: thing is, we need to be able to get the base op precedence for Rop, so by the time we get around to hyperop it should be a solved problem.

[12:57] <masak> colomon: well, the thing TimToady is arguing for is >>+<< et al having list infix precedence, and then *another*, inner, precedence besides that.

[12:57] *** iblechbot joined
[12:58] <masak> I'm considering signing up for a GSoC project -- building a static analyzer for Perl 6.

[12:59] <jnthn> That sounds interesting.

[12:59] <jnthn> masak: What you try and do it within an existing compiler?

[12:59] <masak> jnthn: depends on whether you consider Yapsi to exist or not yet. :)

[13:00] <jnthn> masak: I'm willing to mentor a static analyzer for Rakudo project (it's easier to mentor someone else to do it than write it myself... :-))

[13:00] <masak> jnthn: I do plan to make Yapsi extremely modular, working in different passes which can be plugged into STD.pm, or Rakudo, etc.

[13:00] <masak> jnthn: cool! I hadn't considered doing it for Rakudo. will explore a little.

[13:01] <masak> that's probably a better idea than starting totally afresh.

[13:01] <jnthn> masak: Well, part of the reason e.g. Perl6::Compiler::Signature and Perl6::Compiler::Package and its subclasses exist was in anticipation of helping to do that kind of thing in the future.

[13:01] <masak> oh, nice.

[13:02] <masak> rakudo: class A { method f() {} }; A::f

[13:02] <p6eval> rakudo 1e9aa0: OUTPUT«Null PMC access in invoke()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:02] * masak submits rakudobug

[13:03] <masak> rakudo: class A {}; A::f

[13:03] <p6eval> rakudo 1e9aa0: OUTPUT«Null PMC access in invoke()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:03] <masak> rakudo: A::f # :)

[13:03] <p6eval> rakudo 1e9aa0: OUTPUT«Null PMC access in invoke()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:03] <jnthn> masak: erm

[13:03] <jnthn> NPMCA is wrong

[13:03] <jnthn> But not finding f is correct.

[13:04] <jnthn> So those lot are all the same bug.

[13:04] <masak> hence just one 'masak submits rakudobug' :)

[13:04] <masak> the rest was just golfing.

[13:04] <jnthn> OK, just wanted to make sure you hadn't taken them as two seperate issues. :-)

[13:04] <masak> the system is very simple. :)

[13:04] <jnthn> rakudo: Some::thing()

[13:04] <p6eval> rakudo 1e9aa0: OUTPUT«Null PMC access in invoke()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:04] <jnthn> alpha: Some::thing()

[13:04] <masak> one 'masak submits rakudobug', one rakudobug.

[13:04] <p6eval> alpha 30e0ed: OUTPUT«invoke() not implemented in class 'Undef'␤in Main (file <unknown>, line <unknown>)␤»

[13:05] <jnthn> Ah. Exact same problem as we had before.

[13:05] <jnthn> Or near enough.

[13:05] * jnthn should really try and fix that one.

[13:05] <jnthn> Then I write a blog post called "A farcical fix" :-D

[13:05] <masak> 哈哈

[13:06] <masak> so, how do I get the method object for a method foo in class A?

[13:07] <jnthn> can

[13:07] <jnthn> rakudo: class Foo { method lol { say "rofl" } }; my $x = Foo.can('lol'); $x(Foo)

[13:07] <p6eval> rakudo 1e9aa0: OUTPUT«rofl␤»

[13:07] <masak> really?

[13:08] <jnthn> YA RLY

[13:08] <masak> that's the idiom?

[13:08] <masak> I can accept it, I'm just...surprised.

[13:08] <jnthn> If you want to write Foo::lol you shoudl mark the method "our"

[13:08] <masak> I thought there was a way involving '::'

[13:08] <masak> ok.

[13:08] <jnthn> But Rakudo doesn't support that yet.

[13:08] <masak> rakudo: package A { sub f { say "OH HAI" } }; A::f

[13:08] <p6eval> rakudo 1e9aa0: OUTPUT«OH HAI␤»

[13:08] <jnthn> ...erm. I'm not sure that's quite right either. :-/

[13:08] <jnthn> Aren't subs lexically scoped?

[13:09] <masak> it does seem strange considering what you just said.

[13:09] <jnthn> Right

[13:09] <jnthn> I think that's a bug.

[13:09] * masak submits rakudobug

[13:09] <jnthn> I'm rather surprised that worked.

[13:09] <masak> so are the rest of us :P

[13:09] <jnthn> methods have "has" scope by default.

[13:09] <m6locks> :P

[13:09] <jnthn> Yes, but even knowing the guts I'm surprised. :-)

[13:10] <masak> knowing the guts is just distracting when finding bugs :)

[13:10] <jnthn> Strangely, it helps with fixing them. :-P

[13:11] <jnthn> yay lunch!

[13:12] <masak> rakudo: my @a = 1,2,3,4; my @b = 3,4,5,6; my @c = grep { $_ === any(@a) }, @b; say @c.perl

[13:12] <p6eval> rakudo 1e9aa0: OUTPUT«[]␤»

[13:12] <masak> have I misunderstood what === does?

[13:12] <masak> (again)

[13:13] <jnthn> It looks like you're expecting === to auto-thread. I'm not convinced it does.

[13:13] <masak> oh!

[13:13] <masak> that might be it.

[13:13] * masak rewrites

[13:14] <jnthn> the first thing === does is "is this the same type"

[13:16] <masak> it makes sense that === doesn't autothread, I think.

[13:16] <masak> though it could sometimes be useful to have an operator that did.

[13:20] <jnthn> There's plenty of operators that do. :-P

[13:20] *** Woody2143 left
[13:20] <jnthn> Maybe @a ~~ *,$_,* would do what you want

[13:20] <jnthn> I think it ===s 

[13:21] <masak> orly I thought it ~~d.

[13:32] *** cognominal joined
[13:33] <snarkyboojum> rakudo: my @a = <a b c>; my $b = @a; say @a === $b

[13:33] <p6eval> rakudo 9affb7: OUTPUT«1␤»

[13:34] <snarkyboojum> rakudo: my @a = <a b c>; my @b := @a; say @a === @b

[13:34] <p6eval> rakudo 9affb7: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 16934 (src/builtins/Junction.pir:399)␤»

[13:34] <snarkyboojum> cool message :)

[13:34] <snarkyboojum> alpha: my @a = <a b c>; my @b := @a; say @a === @b

[13:34] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[13:35] <masak> "we're awesome while you wait..." :)

[13:35] <snarkyboojum> heh

[13:37] *** ajardan joined
[13:37] <ajardan> heya

[13:38] <ajardan> I'm trying to install ilbot on one of our servers, with no luck, it is aking for an IrcLog.pm module :)

[13:38] *** jpzork joined
[13:39] <ajardan> any ideas where can I get it, or what's wrong

[13:39] <snarkyboojum> ajardan: http://github.com/moritz/ilbot/tree/master/lib/ might help?

[13:40] <ajardan> hmm, I hae it in lib folder too...

[13:41] <masak> rakudo: return True if 1

[13:41] <p6eval> rakudo 9affb7: OUTPUT«Missing block at line 11, near ""␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[13:41] * masak submits rakudobug

[13:45] <ajardan> snarkyboojum, any ideas why it doesn't see the lib ?

[13:46] *** arthur-_ joined
[13:52] <masak> rakudo: return for 1,2,3

[13:52] <p6eval> rakudo 9affb7: OUTPUT«Could not find non-existent sub &for␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:52] <masak> I recognize this bug.

[13:52] <colomon> it's return, isn't it?

[13:53] <masak> it's parsing.

[13:53] <colomon> rakudo: .say for 1, 2, 3

[13:53] <p6eval> rakudo 9affb7: OUTPUT«1␤2␤3␤»

[13:53] <colomon> it's parsing return.  :)

[13:53] <colomon> rakudo: return if True;

[13:53] <p6eval> rakudo 9affb7: OUTPUT«Could not find non-existent sub &if␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:53] <jnthn> Another nice post http://use.perl.org/~jhuni/journal/

[13:53] <jnthn> masak: It's the way return is parsed.

[13:55] <masak> future-proof URL: http://use.perl.org/~jhuni/journal/40253

[13:55] <jnthn> oops, yes

[13:55] <jnthn> :-)

[13:55] <masak> I guess it's the way listops interact with statement modifiers in the parser.

[13:56] <jnthn> It's actually more than return isn't being parsed as a list op atm.

[13:56] <jnthn> But iirc as a statement control

[13:56] <jnthn> It's a bit annoying to fix since calling return isn't like calling pretty much anything else

[13:56] <jnthn> And I didn't work out a clean way to handle that yet.

[13:57] <jnthn> (Granted, I didn't spent much time on it either... :-))

[14:00] *** wasy joined
[14:02] *** payload1 joined
[14:02] *** payload left
[14:03] *** alester joined
[14:07] *** payload1 left
[14:28] *** MAK_ joined
[14:29] <MAK_> While installing a new release of rakudo and parrot will I have to clean up the existing one and then install or can I install on the existing one itself?

[14:29] <MAK_> I am installing on windows

[14:30] <finanalyst> i havent been able to spend much time here recently. I noticed 'alpha' as an evaluation bot. What is alpha? 

[14:30] <masak> MAK_: perhaps jnthn++ can help you. he's on Windows too.

[14:31] <masak> finanalyst: 'alpha' is the name given to the branch that was called 'master' before 'ng' became 'master' in late January.

[14:31] <finanalyst> ahhh. Thanks

[14:31] <masak> i.e. 'the old Rakudo'.

[14:31] <MAK_> masak : I will try out few things myself let me see if it works out

[14:31] <jnthn> masak: How did you do it before?

[14:32] <jnthn> Just perl Configure.pl --gen-parrot and then make?

[14:32] <jnthn> er

[14:32] <finanalyst> how long before new Rakudo catches up to alpha?

[14:32] <jnthn> MAK_: ^ that was for you :-)

[14:32] <jnthn> MAK_: Or do you use the binaries?

[14:32] <MAK_> I am building from source, will try out as you suggested

[14:32] <masak> finanalyst: depends on the exactness of the criterion 'catches up'.

[14:32] <jnthn> MAK_: Then it should be fairly self contained

[14:32] <masak> finanalyst: in some respects, it already does more. the regressions are quickly filled in.

[14:33] <MAK_> okies ;)

[14:33] <jnthn> Just build the new one in a new folder and there should be no interference between them. :-)

[14:33] <masak> finanalyst: some things might take a long time before they're back in place.

[14:33] <jnthn> finanalyst: What masak said. Depends what aspects you care about. In many places master is a lot more advanced than alpha ever was.

[14:33] <finanalyst> what is the status of Rakudo * ?

[14:33] *** unobe joined
[14:34] <jnthn> finanalyst: A bit delayed, due to recent events, though not epicly so.

[14:35] <finanalyst> perl6: my $x='a'; my $y='abc'; say ?($x ~~ $y)

[14:35] <p6eval> rakudo 9affb7: OUTPUT«0␤»

[14:35] <p6eval> ..elf 30125, pugs: OUTPUT«␤»

[14:35] <finanalyst> perl6: my $x='a'; my $y='abc'; say ?($y ~~ $x)

[14:35] <p6eval> rakudo 9affb7: OUTPUT«0␤»

[14:35] <p6eval> ..elf 30125, pugs: OUTPUT«␤»

[14:36] <masak> finanalyst: if you're expecting substr or regex matching out of that, your expectations are off :)

[14:36] <finanalyst> regex matching, and yes I have probably forgotten the proper syntax.

[14:37] <masak> finanalyst: it's /abc/ for regexes.

[14:37] <finanalyst> perl6: my $x='a'; my $y='abc'; say ?($y ~~ /$x/)

[14:37] <p6eval> elf 30125: OUTPUT«1␤»

[14:37] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.14/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[14:37] <p6eval> ..rakudo 9affb7: OUTPUT«0␤»

[14:37] <MAK_> Will doing a --gen-parrot pick up the latest parrot release?

[14:37] <masak> finanalyst: that wouldn't cut it either.

[14:37] <masak> finanalyst: you'd just get the literal string 'abc' inside the regex.

[14:37] <jnthn> masak: I think that should work.

[14:37] <mathw> MAK_: It'll get the Parrot which Rakudo currently requires

[14:37] <MAK_> ok

[14:37] <jnthn> masak: no, $x

[14:37] <masak> oh right.

[14:37] <mathw> MAK_: This may be more recent than the last release.

[14:37] <masak> finanalyst: nevermind. that should work.

[14:38] <MAK_> hmmm.... actually seems like parrot doesnt release tarballs

[14:38] <jnthn> finanalyst: The variable in regex case doesn't quite work yet *but* bkeeler++ wrote a patch last night to make it do so, we just didn't get it in yet. :-)

[14:38] <MAK_> like rakudo

[14:38] <finanalyst> perl6: my $x='a'; my $y='abc'; say ?($y ~~ /{$x}/)

[14:38] <MAK_> so Im getting the svn installer to get use the --gen-parrot option

[14:38] <p6eval> elf 30125: OUTPUT«No viable candidate for call to multimethod prefix__63() at (eval 127) line 5␤ at ./elf_h line 5881␤»

[14:38] <p6eval> ..rakudo 9affb7: OUTPUT«1␤»

[14:38] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.14/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[14:39] <jnthn> MAK_: They do, but it's still just all around easier to use --gen-parrot

[14:40] <finanalyst> Still regexes with variables can be made to work now, which is definitely a long way.

[14:40] <jnthn> finanalyst: I'm not convinced that's working for the reason you expect it to, fwiw.

[14:41] <finanalyst> How about lazy evaluation?

[14:41] <jnthn> finanalyst: Coming along in master. :-)

[14:41] <finanalyst> excellent.

[14:41] <jnthn> rakudo: (1..*).map({ $_ ** 2 }).batch(20).perl.say

[14:41] <p6eval> rakudo 9affb7: OUTPUT«(1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400)␤»

[14:43] <finanalyst> if i read in from a file, will rakudo pull in the whole file, or execute lazily?

[14:44] <colomon> If you use .lines, it is lazy

[14:47] <jnthn> for $fh.lines -> $current-line { ... } # for example

[14:48] <colomon> Except "for" itself isn't lazy at the moment, is it?  

[14:49] <mathw> I didn't think "for" was supposed to be lazy

[14:49] <mathw> the point is that .lines doesn't read the entire file at the start of the loop

[14:50] <colomon> mathw: in theory, "for" is lazy, unless it is executed eagerly (like in sink context)

[14:50] <colomon> in practice, I'm pretty sure "for" gathers all the elements to be looped on before it starts looping.  So it will read the entire file at the moment.

[14:51] <mathw> you mean something different by 'for is lazy' than I do

[14:51] <jnthn> for is essentially just sugar for map

[14:52] <jnthn> (which is also eager in sink context)

[14:52] <colomon> though again, in practice at the minute they are completely different implementations.  

[14:53] <colomon> rakudo: for gather loop (my $i = 0; $i < 10; i++) { say "blue $i"; my $j = $i; take $j; } { say "green $_";}

[14:53] <p6eval> rakudo 9affb7: OUTPUT«blue 0␤Could not find non-existent sub &i␤current instr.: '_block47' pc 377 (EVAL_1:155)␤»

[14:53] <colomon> rakudo: for gather loop (my $i = 0; $i < 10; $i++) { say "blue $i"; my $j = $i; take $j; } { say "green $_";}

[14:53] <p6eval> rakudo 9affb7: OUTPUT«blue 0␤blue 1␤blue 2␤blue 3␤blue 4␤blue 5␤blue 6␤blue 7␤blue 8␤blue 9␤green 0␤green 1␤green 2␤green 3␤green 4␤green 5␤green 6␤green 7␤green 8␤green 9␤»

[14:53] <mathw> if I say for @a { something } I'd expect it to loop through every element of @a right there and then, which, if @a itself was lazy, would cause @a to be fully evaluated. That doesn't fit in anything in my head that says 'for is lazy'

[14:54] <mathw> map, on the other hand, I might expect to defer until the result array is evaluated

[14:54] <mathw> (in fact I would, because I learned map in Haskell originally :))

[14:55] <colomon> mathw: unfortunately for your expectations, for and map are supposed to be identical

[14:55] *** cotto joined
[14:56] <jnthn> ...wow...

[14:57] <mathw> but for doesn't have a result array

[14:57] <mathw> or anything to grab onto and say evaluate it

[14:57] <jnthn> cotto: the one set of curlies followed right away by another looks odd. :-)

[14:57] <colomon> mathw: it's supposed to have

[14:57] *** ruoso joined
[14:57] <mathw> whaa

[14:57] <colomon> rakudo: map({ say "green $_";}, gather loop (my $i = 0; $i < 10; i++) { say "blue $i"; my $j = $i; take $j; })

[14:57] <cotto> jnthn, on the wiki?

[14:57] <masak> gotta go now. I just pushed a surprise for you. something I worked on last night. :)

[14:57] <p6eval> rakudo 9affb7:  ( no output )

[14:57] <jnthn> mathw: Both for *and* map evaluate eagerly

[14:58] <masak> please bikeshed while I'm away :)

[14:58] <colomon> rakudo: map({ say "green $_";}, gather loop (my $i = 0; $i < 10; i++) { say "blue $i"; my $j = $i; take $j; }).eager

[14:58] <p6eval> rakudo 9affb7: OUTPUT«blue 0␤green 0␤Could not find non-existent sub &i␤current instr.: '_block65' pc 454 (EVAL_1:187)␤»

[14:58] <jnthn> mathw: in sink context

[14:58] <colomon> rakudo: map({ say "green $_";}, gather loop (my $i = 0; $i < 10; $i++) { say "blue $i"; my $j = $i; take $j; }).eager

[14:58] <jnthn> mathw: And lazily if the result is being used.

[14:58] <p6eval> rakudo 9affb7: OUTPUT«blue 0␤green 0␤blue 1␤green 1␤blue 2␤green 2␤blue 3␤green 3␤blue 4␤green 4␤blue 5␤green 5␤blue 6␤green 6␤blue 7␤green 7␤blue 8␤green 8␤blue 9␤green 9␤»

[14:58] <mathw> jnthn: so an ordinary for loop is in sink context?

[14:58] <cotto> nm.  automiscomplete

[14:58] <dalek> rakudo: c05da93 | masak++ |  (2 files):

[14:58] <dalek> rakudo: [Set.pm] new class in core

[14:58] <dalek> rakudo: It currently does union, intersection and set difference. It contains methods

[14:58] <dalek> rakudo: for checking subset and superset relationships. There are two sets of ops for

[14:58] <dalek> rakudo: the above: one unicode set and one 'Texas' parenthesized set. This is all a

[14:58] <dalek> rakudo: bit above and beyond the current spec, but quite close to what I envision for

[14:58] <dalek> rakudo: core.

[14:58] <jnthn> Yes

[14:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c05da93cc378a188c6dcc800c00d06e9b8f3eb74

[14:58] <colomon> and there is the current different between for and map.

[14:58] <colomon> masak: \o/

[14:58] <jnthn> masak++!!

[14:58] <mathw> phenny: tell masak I'm disappointed that wasn't named enums

[14:58] <phenny> mathw: I'll pass that on when masak is around.

[14:59] <jnthn> mathw: aww!

[14:59] *** jpzork left
[14:59] <mathw> jnthn: I need named enums for Form.pm

[14:59] <mathw> and I'm in the mood for form hacking

[15:00] <jnthn> Ah.

[15:00] <mathw> And I don't really care what the current difference between for and map is, I want to make sure I understand what the spec is

[15:00] <jnthn> The spec is that they're not different.

[15:01] <colomon> well, their syntax is slightly different, obviously.  :)

[15:01] <mathw> obviously

[15:01] <jnthn> Well, yes. :-P

[15:02] *** MAK_ left
[15:02] <mathw> The key is probably checking up on what sink context actually is

[15:02] <mathw> Because I have only a vague idea

[15:02] <jnthn> mathw: Read sink as void perhaps.

[15:02] <mathw> rakudo: for 1, 2 { say "sink context for loop?" }

[15:02] <p6eval> rakudo 9affb7: OUTPUT«sink context for loop?␤sink context for loop?␤»

[15:02] <colomon> The important point to their current difference is that if you say "for $fh.lines", it will read the entire file before processing them.  Whereas if you use map, it won't.

[15:03] <mathw> colomon: but that, to me, is clearly an implementation fault

[15:05] <colomon> clearly it is a major implementation fault.  until it is fixed, it needs to be pointed out to people, lest they innocently cause themselves serious trouble.

[15:06] <mathw> as long as my sudden paranoia about the intended behaviour of for loops goes away, I can live with it

[15:06] <jnthn> colomon: Wonder how hard it would be to tweak for to akshually use map

[15:06] <jnthn> colomon: But always just .eager at the end of the lot for now

[15:06] <mathw> I don't, after all, expect Rakudo to be usable in any kind of real code at the moment

[15:06] <colomon> jnthn: probably not bad, but ... oooo, right.

[15:06] <jnthn> colomon: It'd lazily evaluate the iterator then at least

[15:06] <jnthn> colomon: oh, I remember why it's hard :-/

[15:06] <jnthn> colomon: next/last/etc

[15:07] <mathw> jnthn: I thought that might be why

[15:07] <colomon> jnthn: right, mapping for to map plus... oh, damn, you're right.  :(

[15:07] <mathw> also what about for @a -> $x, $y { } - that doesn't fit very well in map's model either

[15:07] <colomon> mathw: sure it does

[15:07] <jnthn> How so?

[15:07] <mathw> or does map support that

[15:07] <mathw> I just realised there's no reason why it shouldn't

[15:08] <colomon> rakudo: (1...30).map(-> $a, $b { say $a * $b }).eager

[15:08] <p6eval> rakudo 9affb7: OUTPUT«2␤12␤30␤56␤90␤132␤182␤240␤306␤380␤462␤552␤650␤756␤870␤»

[15:08] <jnthn> rakudo: (1,2,3,4).map(-> $x, $y { say $x + $y }).eager

[15:08] <p6eval> rakudo 9affb7: OUTPUT«3␤7␤»

[15:08] <jnthn> heh, colomon++ beat me to it ;-)

[15:08] <colomon> ;)

[15:09] <mathw> that's a disadvantage of thinking of map from the Haskell viewpoint

[15:09] <colomon> I have to admit, it hurts my brain to think about next/last/etc in map.  

[15:09] <mathw> because that's strictly one element at a time

[15:12] <colomon> rakudo: for 1...* -> $a { say $a; last if $a > 10; }

[15:13] <p6eval> rakudo 9affb7:  ( no output )

[15:13] <colomon> rakudo: (1...*).map( -> $a { say $a; last if $a > 10; }).eager

[15:13] <p6eval> rakudo 9affb7: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤Warning␤Null PMC access in isa_pmc()␤current instr.: 'perl6;Iterator;eager' pc 10741 (src/builtins/Role.pir:143)␤»

[15:13] <colomon> ha!

[15:13] <colomon> that's one way to exit a potentially infinite loop....

[15:14] <jnthn> fejl!

[15:15] <mathw> map is going to need last/next/etc

[15:15] <mathw> hmmm

[15:16] <jnthn> Think it's just exception handlers being added into map implementation

[15:16] <colomon> we also need FIRST, etc.

[15:16] <colomon> seems like coming up with a unified model might not be too hard?

[15:17] <jnthn> Maybe no

[15:17] <jnthn> *not

[15:17] * jnthn is not so awesome at thinking about control-flowy matters

[15:19] *** MAK_ joined
[15:19] <MAK_> Which are the first docs one must read to gte started with perl 6

[15:20] <MAK_> *get*

[15:20] <mathw> jnthn: it sounds like a unified model is definitely desirable

[15:20] <mathw> the more I think about it, the more similarity I see

[15:21] <mathw> and there's no harm in map being able to handle control flow exceptions of appropriate kinds, and the phasers... probably.

[15:22] <MAK_> Why does building parrot eat away so much memory?

[15:24] *** ruoso left
[15:26] <jnthn> MAK_: Building Parrot, or building Rakudo?

[15:26] <jnthn> MAK_: If you know Perl 5 already, then moritz++ has a very good 5 to 6 series.

[15:26] <MAK_> perl Configure.pl --gen-parrot eats away memory

[15:27] <MAK_> One more thing.... for the end user parrot and rakudo are the same

[15:30] <MAK_> Computer almost hangs during the build process

[15:33] <jnthn> Yes, both a resource-intensive to compile.

[15:34] <jnthn> The Parrot team are looking into why compiling Rakudo is so resource heavy and last I heard had an understanding of why and an idea of how to fix it.

[15:34] <TimToady>  /e

[15:35] <jnthn> TimToady: Right, they're evaluating the situation. :-)

[15:35] <TimToady> e/

[15:36] *** MAK_ left
[15:41] <mathw> jnthn: woo

[15:41] <TimToady> I'm back to thinking that hypers should stay transparent for now, because eager semantics kinda imply that they're more OO than listy.

[15:43] <TimToady> and if you *do* have lists, you probably want X or Z anyway

[15:43] <jnthn> If you want parallel processing, you'd also use hypers, even if you had lists, I guess.

[15:44] <TimToady> also, I envisage many mathematicians will just want to say "use autohyper" and wrap «op» automatically

[15:44] <jnthn> autohyper?

[15:44] <TimToady> so that $a + $b always means $a «+» $b

[15:45] <TimToady> (as in APL)

[15:45] <jnthn> What a disgusting module. :-)

[15:45] <TimToady> but then we still want to keep Perl precedence, and not throw it all out like APL does.  :)

[15:46] <TimToady> (though that wouldn't be an issue with subprecedence either)

[15:46] <TimToady> but anyway, having looked over all the hyper uses in *.t, I think we'll leave it as is for now, that is, transparent

[15:47] <jnthn> +1

[15:47] <TimToady> the fact that there are hyper prefix/postfix also indicates that they really only work on items

[15:47] <TimToady> but it was worth considering

[15:47] <TimToady> and it would also be trivial for someone to add Hop to get the other semantics :)

[15:50] <jnthn> True. :-)

[15:50] <jnthn> Ah, the wonders of an easily extensible grammar. :-)

[15:51] *** ajardan left
[15:52] <TimToady> it does make me wonder, though whether putting transparent metas like R and S into upper case is a small design mistake

[15:53] <jnthn> In what sense?

[15:53] <TimToady> and that the uppercase should perhaps be reserved for list infixes

[15:53] <jnthn> Oh, I see.

[15:53] <jnthn> Hmm

[15:53] <TimToady> so that people don't generalize falsely from X and Z to R and S

[15:54] <jnthn> Worth considering.

[15:54] <TimToady> I can also argue it the other way, of course, that (say) r and s don't stand out, and are likelier to cause collisions

[15:55] <TimToady> alternately, one could steal more symbolic metas, like ! and = do already

[15:55] <mathw> are there any symbols left?

[15:56] * mathw looks at his keyboard and finds only £ and €

[15:56] <TimToady> not many new ones, but if any of the existing ones can be seen as a degenerate case, we can use that

[15:56] <TimToady> like X is a degenerate Xop

[15:57] <TimToady> one could, for example, imagine reusing , as a prefix to mean S

[15:58] <mathw> well, it has connotations of sequentialness

[15:58] <mathw> sequentiality?

[15:58] <TimToady> and if we hadn't done [\op] then \op could be reversed

[15:59] <jnthn> c

[15:59] <TimToady> even || could do as "short circuit" in a pinch

[16:00] <TimToady> or &&op

[16:00] <jnthn> because it's like you curl the args around

[16:00] <jnthn> :-)

[16:00] <jnthn> (for R )

[16:00] <jnthn> :-)

[16:00] <TimToady> well, but has same problem as r

[16:00] <TimToady> cmp

[16:01] <mathw> ccmp

[16:01] <mathw> hmm

[16:01] <mathw> so rename cmp...

[16:01] <TimToady> rename it to...Xmp

[16:01] <jnthn> Aye

[16:01] <TimToady> oh wait...

[16:01] <mathw> call it fred

[16:02] <jnthn> Yeah, I think discussion of the cop proposal should be arrested.

[16:02] * mathw is supplier of handcuffs to the pun police

[16:03] <TimToady> though I guess, techinically, the symbolic ops are also potentially ambiguous with other symbolics in the same way

[16:03] <mathw> very true

[16:03] <mathw> but I don't like the idea of lowercase letters as metaops, on the surface, because the uppercasing makes it stand out

[16:03] <mathw> I think it does need to be uppercase or a symbol

[16:04] <jnthn> I don't think the lower cases gain (people don't make bad analogy) is worth the lower case loss (not distinctive).

[16:04] <TimToady> or some standard delim

[16:04] <TimToady> r:op s:op for example

[16:04] <mathw> that might work

[16:04] <mathw> I don't know if the parser would like it, but r:op has pleasant connotations with regexp modifiers

[16:04] <TimToady> r./  r-/  ...

[16:05] <TimToady> but the colon is looking the wrong way

[16:05] * mathw turns his colon upside down... and it's the same. damn.

[16:05] <TimToady> r^op r!op

[16:05] <mathw> r!!=

[16:05] <TimToady> all prefix metas end in ! and ! is a degenerate case?

[16:06] <TimToady> nah

[16:06] <jnthn> TimToady: It may be that "uppercase = meta-op" is a more useful general guide than "uppercase = meta-op which parses as a list infix"

[16:06] <TimToady> still a lot to be said for uppercase

[16:07] <mathw> maybe it means the Z needs a different name

[16:07] <TimToady> nod, just thinking through all the issues

[16:07] <TimToady> but X is also list infix

[16:07] <jnthn> Aye. There's no standalone R or S.

[16:07] <TimToady> and I love X and Z for their visuals

[16:08] <mathw> yeah

[16:08] <jnthn> Same.

[16:08] <mathw> I can't say it ever confused me that we have Xop and X

[16:08] <mathw> maybe I never thought about it

[16:08] <mathw> and I can't think now

[16:08] <mathw> it's too close to the end of the working day

[16:08] <mathw> good luck

[16:09] *** SmokeMachine joined
[16:13] *** SmokeMachine left
[16:19] *** astrojp joined
[16:21] *** Chillance joined
[16:23] <TimToady> actually, I could argue \ for sequential, since [\op] reports the intermediate (sequential) results

[16:24] <TimToady> and maybe ` for reversed

[16:26] <TimToady> or ` is our metadelim and s`op and r`op

[16:26] <TimToady> or s\op and r\op

[16:28] <TimToady> I dunno, if we go that route I'm still inclined to do something that is visually small, s.op s_op s`op s^op

[16:28] <TimToady> but something to be said for sticking to single chars too

[16:29] <TimToady> ,op for sequential and `op for reversed as a pleasing, if semantically false, symmetry

[16:29] <TimToady> *has a

[16:32] <TimToady> comma won't really work though--too likely to get false metas if people are golfing the spaces out

[16:32] <TimToady> so I think the single chars have to be ` for reverse and \ for sequential, if we go with single chars

[16:33] <TimToady> it's kind of a pity that `

[16:33] <TimToady> that ~ is taken already

[16:34] <TimToady> I suppose a case could be made for %cmp as a reversed cmp

[16:34] <TimToady> but that's too ambiguous with %, which is not a degenerate case

[16:34] <TimToady> so %= is bad

[16:36] <TimToady> okay, here's another thought: R and S could turn into postfix metas like = somehow

[16:39] <TimToady> that seems intrinsically more difficult to analyze for ambiguity, however

[16:39] *** unobe left
[16:40] *** unobe joined
[16:42] *** drbean joined
[16:44] <TimToady> otoh, backformation from [\op] seems to indicate that $a \op $b should return ($a, $a op $b)

[16:45] <TimToady> I wonder if there's any practical use for that...

[16:46] <TimToady> I'm afraid I've exceeded my quota of impossible things before breakfast...

[16:52] *** envi^home left
[16:53] <TimToady> interestingly, though, it appears we have no current operators that begin with r

[16:53] <TimToady> so rcmp isn't so bad

[16:53] <TimToady> esp if you're canadian

[16:54] <jnthn> EARRESTPUNTOOEARLY

[16:54] <m6locks> ror

[16:55] *** cdarroch joined
[16:55] *** cdarroch left
[16:55] *** cdarroch joined
[16:55] <TimToady> and there are also no infixes that begin with s currently

[16:55] <TimToady> so maybe r and s are fine

[16:56] *** envi^home joined
[16:56] <jnthn> not as visually distinctive though.

[16:56] <jnthn> req vs Req

[16:57] <TimToady> can always say r[eq] if it bothers you

[16:57] <jnthn> huh? and type 2 more characters?!

[16:57] <jnthn> ;-)

[16:58] <TimToady> another consideration is whether we want to encourage user-defined metas to be uppercase regardless of precedence policy

[16:58] <TimToady> much to be said for that, too

[17:00] <TimToady> if we have a very small arbitrary list of metaops to memorize the precedence of, it's not so very terrible

[17:00] <TimToady> I guess we'll leave it as is for now.  I do like the visual R and S as a kind of punch between the eyes.

[17:01] <TimToady> but we had to do the analysis :)

[17:01] <TimToady> so we can at least say "we thought about it" down the road

[17:02] *** unobe left
[17:02] *** quietfanatic joined
[17:03] *** unobe joined
[17:06] *** distrachan joined
[17:07] *** distrachan left
[17:07] *** dual joined
[17:08] <TimToady> R and S are arguably easier to look up, too

[17:08] *** payload joined
[17:08] <TimToady> (than punctuation)

[17:12] * colomon is scared by what he just saw of the backlog....  and also no longer a homeowner!

[17:12] *** cls_bsd left
[17:13] <TimToady> hugme: hug colomon 

[17:13] * hugme hugs colomon

[17:16] *** payload left
[17:18] *** stuart02 joined
[17:20] *** stuart02 left
[17:21] <colomon> TimToady: user-defined metaops?!

[17:21] <TimToady> p6 is supposed to be extensible

[17:22] <TimToady> and to the extent that it is, we want to encourage people to do it consistently and unambiguously

[17:22] <colomon> bless you, sir

[17:22] <TimToady> I try to be nice to homeless people occasionally.

[17:23] <m6locks> lol

[17:23] <TimToady> btw, === and eqv are supposed to autothread

[17:23] <TimToady> if that makes life harder for the implementation of junctions, too bad.

[17:25] <colomon> TimToady: please sir, do you have any spare changes?

[17:25] <colomon> we take both svn and git here...

[17:27] * colomon is strongly in favor of R and S, for what it is worth.

[17:27] <TimToady> in that case, you don't really want any changes...

[17:28] <colomon> You could give them to me and I'll put them to good use.... ;)

[17:34] *** M_o_C joined
[17:36] <quietfanatic> .oO(clearly we ned a Jop metaop for non-autothreading on junctions...)

[17:37] *** cls_bsd joined
[17:38] * jnthn back

[17:39] <colomon> \o/

[17:42] * jnthn is happy with the "keep them as R and S" outcome, but the whole discussion was interesting and very worth having. :-)

[17:46] <colomon> I hadn't known that user-defined metaops were on the table.  I'm curious what the syntax will be, or if the user will have to hack the grammar directly....

[17:46] *** ggoebel joined
[17:47] *** envi^home left
[17:47] <jnthn> colomon: anywhere there is a proto regex, it's an invitation "oh hai extend me"

[17:47] <jnthn> Yes, you would probably have to subclass the grammar

[17:48] <jnthn> Or some "slang" - I don't know exactly how those look :-)

[17:51] *** unobe left
[17:51] *** unobe joined
[17:52] <pugssvn> r30126 | lwall++ | [S03] clarify that nearly all normal operators autothread, including === and eqv 

[17:53] <TimToady> colomon: what jnthn++ said

[17:54] <TimToady> just because it's possible doesn't mean we have to make it easy

[17:55] <TimToady> otoh, the current metaops are really just sugar for higher-order functions, so not that hard, conceptually

[17:56] <TimToady> "higher-order functions" always sounds so high-falutin', like they're somehow socially superior to normal functions

[17:57] <TimToady> maybe we should just call them metafunctions

[18:00] <TimToady> jnthn: (still backlogging) if return can't be a normal function, then something's wrong with our ability to bind a raw parcel and pass it along

[18:00] <jnthn> "functions that take arguments are also functions"

[18:00] <jnthn> TimToady: Then there is something wrong with that. :-)

[18:00] <jnthn> TimToady: The problem is this:

[18:00] <jnthn> foo 1, 2, a => 3;

[18:01] <jnthn> We at compile time (hand-waving a bit at the Parrot mapping) transform that into a capture.

[18:01] <jnthn> And invoke foo

[18:01] <jnthn> And the binder unpacks it.

[18:01] <jnthn> So by runtime there's no Parcel to be seen.

[18:01] <jnthn> For return we don't want that.

[18:01] *** Psyche^ joined
[18:01] <jnthn> And we can't re-construct a Parcel from a Capture since we've lost ordering information.

[18:02] <TimToady> I've always argued to keep that info around somehow

[18:02] <TimToady> I think of Capture as a Parcel with an index :)

[18:02] <jnthn> It...sort of maybe is...kinda...

[18:02] <TimToady> alternately, if there's a return proto, we could pay attention to it's sig

[18:02] <TimToady> *its

[18:03] <jnthn> What would such a sig look like?

[18:03] <TimToady> and know not to capturize

[18:03] <jnthn> That detail aside I'm open to such a solution though.

[18:03] <jnthn> Especially since I can just cheat on spotting return for now.

[18:04] <jnthn> And fill out the full implementation later.

[18:04] <TimToady> looks like |$foo should be that

[18:05] *** SmokeMachine joined
[18:05] <jnthn> I don't think so.

[18:05] <jnthn> |$foo makes a Capture

[18:05] <jnthn> And puts it in $foo

[18:05] *** Psyche^ is now known as Patterner

[18:05] <TimToady> what diff if it makes it a Parcel?

[18:05] <jnthn> (In fact, it makes a snapshot of the current capture depending where it appears in the signature)

[18:05] <TimToady> to use it as a subsequent capture, you have to use | on it again

[18:06] <jnthn> |$foo # Parcel in $foo

[18:06] <jnthn> ||$foo # Capture in $foo 

[18:06] <jnthn> ;-)

[18:06] <TimToady> there certainly has to be some way to grab a raw parcel

[18:06] <jnthn> The thing is that |$foo at the moment is more than just "the capture that was passed" though

[18:07] <jnthn> It's got that whole snapshot nature about it.

[18:07] <TimToady> \| or |\ maybe

[18:07] <jnthn> That'd probably be a nightmare for the Parcel equivalent. :-/

[18:07] <jnthn> I like \|

[18:07] <jnthn> It's going to be written *very* rarely.

[18:08] <jnthn> Can we conservatively say that if you write \| in a signature, that is the _only_ thing you can write in it?

[18:08] <TimToady> sure

[18:08] <jnthn> The thought of doing otherwise gives me indigestion. :-)

[18:09] <jnthn> OK, spec'ing something like that would seem to give us a way to resolve the issue.

[18:09] <TimToady> consider that there will be something of that nature in the sig, even if it doesn't end up \|

[18:10] <jnthn> OK. The syntax is almost certainly not a big deal to adapt.

[18:10] <TimToady> one could almost argue that sigless does that, and you have to get the parcel from @_

[18:10] <jnthn> Please no.

[18:10] <TimToady> I said "almost"  :)

[18:10] <jnthn> sub foo { }; foo(1); # I really like that this errors

[18:10] <jnthn> :-)

[18:10] <TimToady> er, it shouldn't

[18:11] <TimToady> oh, I see how it does

[18:11] <TimToady> nevermind

[18:12] <jnthn> .oO( phew! )

[18:12] <TimToady> it requires the user to mention @_ to get p5 semantics

[18:12] <jnthn> *nod*

[18:12] <TimToady> forgot we did that

[18:13] * TimToady <- loose cannon mode today

[18:13] <TimToady> you'd think it was a friday...

[18:13] *** frettled joined
[18:14] <frettled> Good localtime from Maspalomas, Gran Canaria.  :)

[18:15] <jnthn> frettled: Warm? :-)

[18:16] <frettled> jnthn: yes!  We have fine-grained sand (dust, really) from Sahara now, it's almost like a baker's oven.

[18:16] <[particle]> it's a friday?

[18:16] <[particle]> huzzah!

[18:17] <colomon> that means no moving cost estimators coming over for two days!  (of course, there's one in the other room at the moment...)

[18:25] <jnthn> frettled: Must make a nice chance from the cold. :-)

[18:26] <frettled> jnthn: absolutely, it's wonderful!

[18:26] <jnthn> :-)

[18:26] *** pyrimidine joined
[18:26] <frettled> I missed the Iron Man deadline, though, but right now I don't care too much.  ;)

[18:37] <colomon> frettled: oh no!  if they ever update the statuses again, you'll drop!

[18:38] <frettled> colomon: heh :)

[18:38] <colomon> I mean, it's only be six months, right?

[18:38] <frettled> I don't have the faintest clue

[18:38] *** Khisanth joined
[18:39] *** mberends joined
[18:39] * frettled idles again.  :)

[18:39] *** pmurias joined
[18:41] <colomon> frettled: I'm pretty sure someone posted that a month or so ago (that they'd looked at the directory timestamps for the Ironman status images, and the newest was in October).

[18:44] *** ShaneC joined
[18:45] <colomon> not ok 3 - X** works

[18:45] <colomon> #      got: GatherIterator.new()

[18:45] <colomon> # expected: (1, 1, 4, 16, 9, 81)

[18:45] <jnthn> grr

[18:46] <colomon> what I don't get is -- aren't they all GatherIterators?

[18:46] <jnthn> Depends if something somewhere ends up packaging the iterator into something else first

[18:46] <colomon> In fact, it's just different forms of calling the crosswith

[18:47] <jnthn> My impression is that we should never really be returning an iterator directly...

[18:47] <jnthn> But maybe that's wrong.

[18:47] <colomon> we're just doing gather / take -- it returns what it returns.

[18:48] <jnthn> gather gives back a GatherIterator, yes

[18:48] <jnthn> That's what I'm questioning.

[18:48] <jnthn> Whenever we see a XIterator, it feels like a bit of guts just leaked. :-/

[18:49] <colomon> that's sort of a side problem here, though.  :)

[18:50] <colomon> (I mean, I'd like to get the final iterator / list structure in place too...)

[18:52] <jnthn> rakudo: sub foo() { gather { for 1..10 { take $_ } }; say foo(); say foo().perl;

[18:52] <p6eval> rakudo c05da9: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[18:52] <jnthn> rakudo: sub foo() { gather { for 1..10 { take $_ } } }; say foo(); say foo().perl;

[18:52] <p6eval> rakudo c05da9: OUTPUT«12345678910␤GatherIterator.new()␤»

[18:53] <jnthn> The tests that do .perl I guess end up with GatherIterator

[18:53] <jnthn> I guess maybe the tests should explicitly stringify before calling is?

[18:53] <jnthn> I'm not sure that .perl should end up iterating the iterator, maybe it's OK to leak there.

[18:54] <colomon> not ok 3 - X** works

[18:54] <colomon> #      got: "0 0 1 0 0 0"

[18:54] <colomon> # expected: "1 1 4 16 9 81"

[18:54] <colomon> is what I get when I stringify both sides?!?

[18:55] <colomon> > say (1, 2, 3 X** 2, 4).eager.perl

[18:55] <colomon> (1, 1, 4, 16, 9, 81)

[18:56] *** fglock joined
[18:56] <colomon> I have not had enough sleep to deal with this...

[18:57] <colomon> or enough scotch...

[18:57] <jnthn> :-)

[18:57] <jnthn> The 0 0 1... is bizzare.

[18:57] <jnthn> rakudo: say ~(1, 2, 3 X** 2, 4)

[18:57] <p6eval> rakudo c05da9: OUTPUT«1 1 4 16 9 81␤»

[18:58] <colomon> doubt it will show up there, is this is my local hack of the code, the way we were doing it last night again.

[18:58] <jnthn> ah, ok

[18:58] <colomon> I just tried adding a say to crosswith.  recompiling now...

[18:59] *** Psyche^ joined
[19:00] <fglock> hi

[19:01] <colomon> o/

[19:02] <jnthn> o/

[19:02] <jnthn> ooh, dinner time

[19:02] <jnthn> \o/

[19:02] <fglock> I'm preparing a Perlito release

[19:02] <fglock> just finishing some extra tests

[19:03] *** Patterner left
[19:03] *** Psyche^ is now known as Patterner

[19:04] <colomon> just now looking at Set.pm -- little does masak realize that .uniq is using Hash internally, so using an Array and .uniq instead of a Hash has very little advantage at the moment....

[19:04] <jnthn> Oh.

[19:05] <fglock> the Perlito Go backend is now bootstrapped - it's an important milestone to me :)

[19:05] <jnthn> fglock: How is Go as a backend?

[19:05] <colomon> 1 op 2 = 0

[19:05] <colomon> 1 op 4 = 0

[19:05] <colomon> 2 op 2 = 1

[19:05] <colomon> 2 op 4 = 0

[19:05] <colomon> 3 op 2 = 0

[19:05] <colomon> 3 op 4 = 0

[19:05] <colomon> not ok 3 - X** works

[19:05] <colomon> #      got: "0 0 1 0 0 0"

[19:05] <colomon> # expected: "1 1 4 16 9 81"

[19:05] <colomon> '

[19:05] <colomon> !!!!

[19:06] <fglock> it is currently 2x slower than the Perl5 backend - but there is some space for optimizing

[19:08] <fglock> it is stable enough, the compiler is about 1MB of Go code and seems to work well

[19:08] <pyrimidine> jnthn, bkeeler: did the 'variable in regex' stuff work out? Thinking about ab.using it to get .trans running again

[19:08] *** drbean left
[19:08] *** drbean joined
[19:09] <fglock> jnthn: I think I've read in a blog that you planned to work in a .net implementation?

[19:09] <fglock> some time ago

[19:10] <fglock> not sure if it was you, sorry

[19:10] <jnthn> fglock: I'm planning work on Rakudo coming multi-backend, and .Net is probably the most likely first additional backend (we'll keep targetting Parrot too of course)

[19:10] <jnthn> That's after Rakudo * though.

[19:11] <jnthn> I want to re-do object layout and some of the meta-model low level things along with that.

[19:12] <fglock> btw, I'm trying to make Perlito runnable in Parrot

[19:12] <fglock> it should work, since Perlito is a subset of perl6

[19:12] <fglock> but I'm getting some problems

[19:12] <jnthn> Is it an NQP-sized subset?

[19:12] <fglock> hmm - it's a different subset

[19:12] <jnthn> OK.

[19:13] <jnthn> What specific issues are you running into?

[19:13] <fglock> I've implemented a desugaring backend, that should run everywhere

[19:13] <fglock> I'm recompiling the latest rakudo right now, I'll try again and see how it goes

[19:14] <jnthn> OK

[19:14] <fglock> (done)

[19:14] <fglock> ah, not yet - that was the configure part

[19:15] <fglock> re: dinner time - we can talk later :)

[19:15] <jnthn> fglock: Dinner time is actually more the start of a process. :-)

[19:15] <fglock> ok

[19:15] <jnthn> fglock: I didn't quite make it past the "what shall I cook" phase yet. :-)

[19:16] <colomon> jnthn: so in addition to (possible) gather iterator issues, we've also got some kind of "you looked up what operator?" problems going on....

[19:16] <colomon> rakudo: say 1 ** 4

[19:16] <p6eval> rakudo c05da9: OUTPUT«1␤»

[19:16] <jnthn> colomon: :-/

[19:16] <colomon> 1 op 4 = 0

[19:17] <colomon> where op is what crosswith is getting when I do X**

[19:17] <jnthn> add a say op

[19:17] <colomon> will that work?!

[19:17] <jnthn> Should.

[19:17] <fglock> rakudo: my $c = 1; sub x { if $x { 3 } else { 4 } }; x()   # does 'if' return a value?

[19:17] <jnthn> rakudo: say &infix:<**>

[19:17] <p6eval> rakudo c05da9: OUTPUT«Symbol '$x' not predeclared in x␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[19:17] <p6eval> rakudo c05da9: OUTPUT«infix:<**>␤»

[19:17] *** bbkr joined
[19:18] <fglock> rakudo: my $c = 1; sub x { if $c { 3 } else { 4 } }; x() 

[19:18] <p6eval> rakudo c05da9:  ( no output )

[19:18] <jnthn> my $c = 1; sub x { if $c { 3 } else { 4 } }; say x()

[19:18] <jnthn> rakudo: my $c = 1; sub x { if $c { 3 } else { 4 } }; say x()

[19:18] <p6eval> rakudo c05da9: OUTPUT«3␤»

[19:18] <fglock> ok - thanks

[19:18] * jnthn settles on vindaloo o/

[19:18] <jnthn> kitchen time!

[19:19] <bbkr> rakudo: BEGIN { say "BEGIN phaser works"} INIT { say "INIT phaser works" }

[19:19] <p6eval> rakudo c05da9: OUTPUT«Confused at line 11, near "BEGIN { sa"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[19:19] <fglock> looking up 'vindaloo'

[19:19] *** mberends left
[19:19] <bbkr> rakudo: BEGIN { say "BEGIN phaser works"};

[19:19] <p6eval> rakudo c05da9:  ( no output )

[19:19] <bbkr> bug?

[19:19] <jnthn> bbkr: The BEGIN phaser...doesn't work.

[19:19] <jnthn> bbkr: Yeah, it's on my hit list, if nobody beats me to it.

[19:20] <bbkr> thanks for the info :)

[19:20] <fglock> ah, it's actually portuguese origin food :)

[19:21] <fglock> it works better if prepared in advance

[19:21] *** unobe left
[19:21] <colomon> infix:<==>

[19:22] <colomon> 1 op 4 = 0

[19:22] *** unobe joined
[19:22] <colomon> rthat's from X**   :\

[19:22] <jnthn> er. wtf

[19:23] <jnthn> OH

[19:23] <jnthn> YOu know how I said assuming might be broken?

[19:23] <jnthn> :-(

[19:24] <jnthn> ...it's more broken that I had energy to notice last night...

[19:24] <jnthn>     .const 'Sub' curried = 'assuming_helper'

[19:24] <jnthn>     capture_lex curried

[19:24] <jnthn>     .return (curried)

[19:24] <jnthn> EPIC FEJL

[19:24] <jnthn> colomon: Locate that bit of code in Code.pir

[19:24] <jnthn> colomon: change the capture_lex line to

[19:24] <jnthn> curried = newclosure curried

[19:28] *** unobe left
[19:28] <bbkr> I have an idea. If executed file is *.t then it should prepend 'lib' to @*INC by default. That will save a lot of typing in every test file.

[19:29] <fglock> jnthn: perl6 says ":= binding of variables not yet implemented"

[19:29] <fglock> Perlito says "infix<=> not implemented"

[19:29] <fglock> :P

[19:30] <jnthn> lol

[19:30] <fglock> I think they will be incompatible for a while

[19:30] <jnthn> fglock: I hope we can restore binding in the not too distant future.

[19:31] <colomon> jnthn: trying  (was called away for a diaper change back there...)

[19:34] <colomon> jnthn: so what's the diff between capture_lex and newclosure

[19:34] <colomon> I mean, besides the fact the latter works!  \o/

[19:35] <pmurias> fglock: hi

[19:35] <pmurias> fglock: where does the perlito code live?

[19:35] <jnthn> colomon: capture_lex = just associate the current lexical scope with this block of code as its outer

[19:35] <jnthn> colomon: newclosure clones and then does it to the clone

[19:35] <pmurias> fglock: ah, it's a new name for mp6

[19:35] <jnthn> Well, clones something...not the whole bytecode or anything

[19:35] <fglock> pmurias: github, fglock/Perlito

[19:36] <colomon> ah.  So we were getting the operator for later invocations of crosswith, eh?

[19:36] <jnthn> colomon: So basically assuming wasn't making a closure, so you got the...right.

[19:36] <jnthn> :-)

[19:36] <pmurias> fglock: why did you move out of the pugs repo?

[19:37] <fglock> pmurias: nferraz suggested moving, and git is shinier - but I think in the end it is more difficult for contributors

[19:38] <pmurias> i use git-svn to work on mildew

[19:39] <fglock> re name - mp6 is too generic, there are several "miniperl6"

[19:40] <colomon> jnthn: just realized the reason we were seeing GatherIterator in the test output is that the iterator was empty!

[19:41] <colomon>     my $test = $got eq $expected;

[19:41] <colomon>     proclaim(?$test, $desc);

[19:41] <colomon>     if !$test {

[19:41] <colomon> By the time you've gotten that far, $got (the iterator we pass in) is already empty...

[19:42] <jnthn> oh!

[19:42] <colomon> so if the test is correct, no worries, but if the test fails, you see a gatheriterator there.

[19:43] <fglock> (reading about mildew) how is return() special?

[19:44] <pmurias> special? it throws a control exception

[19:45] <pmurias> fglock: what are you reading?

[19:45] <fglock> http://www.perlfoundation.org/perl6/index.cgi?mildew

[19:46] <colomon> jnthn: running spec tests on Xop change, if everything works will duplicate it in Zop and check in (maybe with a bit of cleanup as well).

[19:46] <colomon> however, there may be a nap somewhere in that schedule...

[19:46] <pmurias> fglock: $foo = &return;$foo(123) returns from a routine

[19:48] <fglock> nice :)

[19:48] <fglock> return is also an exception in Perlito-Go - but I replaced the function with a macro just today

[19:49] *** simcop2387 joined
[19:49] <fglock> I wonder if "$foo = &return;" would be an error if return is a macro in some implementation

[19:51] <jnthn> colomon: cool

[19:53] *** M_o_C left
[19:54] <pmurias> fglock: it seems to be specced as a function

[19:54] <pmurias> fglock: i'm adding while to Perlito

[19:55] <TimToady> std: BEGIN { say "BEGIN phaser works"} INIT { say "INIT phaser works" }

[19:55] <TimToady> er...

[19:56] <p6eval> std 30126: OUTPUT«===SORRY!===␤Missing semicolon or comma after block at /tmp/oFK3vUO8oD line 1:␤------> BEGIN { say "BEGIN phaser works"} ⏏INIT { say "INIT phaser works" }␤    expecting any of:␤ bracketed infix␤  infix or meta-infix␤      statement modifier

[19:56] <p6eval> ..loop␤FAILE…

[19:56] <pmurias> TimToady: my $foo = &return;$foo(123) is legal?

[19:56] <fglock> pmurias: how are you doing it? I was wondering about some tricks with closures, to avoid reimplementing at each backend

[19:56] <TimToady> it should be, if we make a Parcel recoverable from a Capture

[19:57] <TimToady> or don't pre-capturize an indirect parcel

[19:57] <TimToady> jnthn and I were just discussing that earlier today

[19:57] <TimToady> and inventing a \|$parcel to grab the raw parcel without capturizing

[19:58] <TimToady> (or that reparcelizes a capture)

[19:58] *** am0c joined
[19:59] <TimToady> I tend to view a capture as a parcel with a positional and a hash index into the real parcel arguments

[20:02] <pmurias> fglock: i plan to fill in the While class

[20:03] <fglock> I mean, if you implement it as an ast macro, then it will work for all backends. Implementing at the emitter level requires working out each backend.

[20:05] <pugssvn> r30127 | lwall++ | [STD] don't assume missing block punctuation is always semi or comma 

[20:06] <pmurias> fglock: a while could be translated into recursion... but that seems to produce inefficent code

[20:06] <pmurias> fglock: how do i recompile mp6?

[20:08] <fglock> hmm - there are several ways - I think the most efficient is:

[20:08] <fglock> perl util-perl5/make.pl -Cast-perl5 && rm -rf libast-perl5 && mv libast-perl5-new libast-perl5   # create an ast-cache

[20:09] <fglock> perl util-perl5/make.pl -Cperl5

[20:09] *** bacek joined
[20:10] *** bacek left
[20:10] <fglock> this will create a lib5-new, which you can rename to lib5

[20:10] *** bacek joined
[20:10] *** bacek left
[20:11] <fglock> there are some instructions in README for the other backends

[20:11] *** simcop2387 left
[20:11] *** mantovani left
[20:11] *** ingy left
[20:11] *** solarion left
[20:11] *** arnsholt left
[20:11] *** doublec left
[20:11] *** Lorn left
[20:11] *** hanekomu left
[20:11] *** f00li5h left
[20:11] *** pugssvn left
[20:11] *** literal left
[20:11] *** p6eval left
[20:11] *** revdiablo left
[20:11] *** baest left
[20:11] *** mdxi left
[20:11] *** betterworld left
[20:12] *** arnsholt joined
[20:13] *** unobe joined
[20:13] <pmurias> fglock: what's the plan/roadmap for perlito?

[20:14] <unobe> \exit

[20:14] *** unobe left
[20:14] *** solarion joined
[20:15] *** cotto_work joined
[20:15] *** huf_ joined
[20:15] *** japhb joined
[20:15] *** hicx174 joined
[20:15] *** betterworld joined
[20:15] *** silug joined
[20:15] *** allbery_b joined
[20:15] *** tylerni7 joined
[20:15] *** yahooooo joined
[20:15] *** doublec joined
[20:15] *** Lorn joined
[20:15] *** hanekomu joined
[20:15] *** f00li5h joined
[20:15] *** pugssvn joined
[20:15] *** literal joined
[20:15] *** p6eval joined
[20:15] *** revdiablo joined
[20:15] *** baest joined
[20:15] *** mdxi joined
[20:15] *** barjavel.freenode.net sets mode: +v p6eval

[20:15] *** ingy joined
[20:15] *** mantovani joined
[20:16] <fglock> pmurias: Perlito is "done", because it doesn't try to be complete

[20:17] <fglock> the initial roadmap is complete

[20:19] <fglock> there are some things I'd like to experiment with, like static-type optimizations and threads in Go and Lisp

[20:20] <fglock> and write a better regex engine

[20:20] *** nacho left
[20:21] *** nacho joined
[20:21] <fglock> and at some point, Rakudo should be able to execute Perlito code directly

[20:21] *** dalek joined
[20:24] <fglock> and KindaPerl6 should be runnable in plain Perlito again - but that's a different project

[20:28] *** bacek joined
[20:30] *** justatheory joined
[20:36] <pugssvn> r30128 | lwall++ | [S06] spec the \| parcel parameter syntax 

[20:37] *** nacho left
[20:42] <fglock> pmurias: why do you ask for a plan?

[20:45] <pmurias> fglock: what do you intend perlito to become. grow it into a fully fledged Perl 6 implemanation, a limited and fast and usable one or just experiment with a lot of backends

[20:46] <fglock> currently it's going in the "limited and fast and usable" direction

[20:48] <fglock> there is a core that works everywhere, and then each backend has it's own special features

[20:49] *** hanekomu_ joined
[20:50] *** iblechbot left
[20:51] <jnthn> bkeeler: ping

[20:51] *** nacho joined
[20:56] *** ggoebel left
[20:56] <fglock> pmurias: "usable" is the hard part right now

[20:57] *** nacho left
[20:57] *** fridim joined
[20:58] *** pyrimidine left
[21:00] <pmurias> fglock: having an easy way to recompile mp6 would be usefull

[21:00] <pmurias> recompiling only the files that changed

[21:02] <fglock> the ast cache is meant to help; static backends do need to recompile everything, unless there is some complex dll infrastructure

[21:03] <pmurias> fglock: the p5 backend doesn't

[21:03] <pmurias> fglock: one bug i noticed is that 1 < 2; loops

[21:03] <pmurias> * hangs up

[21:04] <fglock> you can recompile a single file with mp6.pl

[21:04] <fglock> looking

[21:05] <fglock> perl mp6.pl -Cperl5 lib/....pm > tmp.pm && cp tmp.pm lib5/...pm

[21:07] <fglock> pmurias: '<' is just not implemented

[21:07] <pmurias> fglock: got the while working for the perl5 backend

[21:08] <fglock> cool :)

[21:09] <pmurias> can i have a commit bit? ;)

[21:09] <fglock> yes - let me find how 

[21:10] <pmurias> Admin > Add Another Colaborator

[21:10] <fglock> done

[21:23] <pmurias> fglock: comitted

[21:24] <fglock> thanks!

[21:25] <pmurias> there are some files in perl5 which are missing from the repo should i add them?

[21:25] <fglock> 3 backends to fix...

[21:25] <fglock> in lib5? yes, please

[21:28] <pmurias> rm: cannot remove `libast-perl5-new': No such file or directory when running the tests for -Bgo

[21:28] <pmurias> and hangs on t/01-sanity.t

[21:28] <pmurias> sorry my error

[21:28] <fglock> what happened?

[21:29] <pmurias> a missing ' in the shell ;)

[21:32] * pmurias installs go

[21:32] <jnthn> colomon: BTW, figured out what the OPER means.

[21:32] <jnthn> It's the thingy that the operator precednece parser looks for the O magical hash in.

[21:33] <jnthn> (and thus the precedence info)

[21:34] *** ggoebel joined
[21:36] *** ggoebel left
[21:38] <pmurias> fglock: does prove -e "perl mp6.pl -Bjs" work for you?

[21:40] *** rv2733 joined
[21:42] <fglock> yes, it works - which javascript do you have?

[21:42] <colomon> jnthn: maybe that explains my fail last night when I tried to change the grammar -- I think that was the very first thing I removed.  ;)

[21:42] <pmurias> i get an't use string ("0") as an ARRAY ref while "strict refs" in use at /home/pawel/Perlito/lib5/MiniPerl6/Javascript/Emitter.pm line 23.

[21:42] <pmurias> t/01-sanity.t .............. 

[21:42] <pmurias> Dubious, test returned 255 (wstat 65280, 0xff00)

[21:42] <jnthn> colomon: Heh, it's not like I knew what they did until a few moments ago too. :_)

[21:43] <colomon> and yes, I've been napping almost continuously since I said "I think I might nap."

[21:43] <colomon> spectest passed, so time to get patching further...

[21:43] <jnthn> \o/

[21:44] *** Sarten-X joined
[21:44] <jnthn> colomon: I think I also figured out how to do the NQP bootstrap thing and update the Parrot one too.

[21:44] <colomon> jnthn: I don't remember exactly what you were trying to do there, but \o/ 

[21:45] <colomon> ;)

[21:45] <jnthn> colomon: Well, it means I actually know (in theory) the process we need to go through in order to patch NQP. :-)

[21:45] <jnthn> Which is kinda Good To Know. :-)

[21:45] <colomon> :)

[21:45] <fglock> pmurias: did you recompile lib5? I'll recompile here, maybe I get the error

[21:46] <pmurias> fglock: i recompiled it yes

[21:46] <fglock> ok

[21:49] <fglock> pmurias: I can reproduce the error

[21:49] <fglock> can't

[21:49] *** jhuni joined
[21:51] <fglock> does this fail too? $ perl mp6.pl -Cjs t/01-sanity.t

[21:52] *** wknight8111 joined
[21:53] <fglock> running a perltidy'ed lib5/MiniPerl6/Javascript/Emitter.pm will help finding the error position

[21:54] <fglock> (running util-perl5/bootstrap-perl5.sh here, just to be sure)

[21:55] <jnthn> Ouch...gen_core.pm really takes some time these days :-/

[21:55] <fglock> jnthn: is there a description of the new rakudo regex internals somewhere?

[21:56] <fglock> maybe in the source code

[21:58] <jnthn> fglock: Not beyond the README and then intros to various source code files, as far as I know.

[21:58] <jnthn> fglock: It's all in the nqp-rx repository

[21:59] <jnthn> fglock: The basic overview though is that it's bootstrapped, so the regex parser is written in Perl 6 regex.

[21:59] <jnthn> fglock: And it generates PAST::Regex nodes

[21:59] <jnthn> that is, it falls into the general AST structure that everything else does.

[22:00] <jnthn> colomon: I'm attempting to put my new found knowledge of the OPP to good use. :-)

[22:00] <colomon> :)

[22:01] <jnthn> rakudo: say (1,2,3).reduce(&infix:<+>)

[22:01] <p6eval> rakudo c05da9: OUTPUT«6␤»

[22:01] <jnthn> rakudo: say reduce(&infix:<+>, [1,2,3])

[22:01] <p6eval> rakudo c05da9: OUTPUT«Could not find non-existent sub &reduce␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:01] <jnthn> awww!

[22:03] <colomon> Hmmm... trying to remember why I didn't implement that...

[22:03] <jnthn> colomon: Should it exist?

[22:04] <colomon> I think so.  I think there was a complication when I tried to do it.

[22:04] <jnthn> OK

[22:04] <jnthn> I...may try it... ;-)

[22:04] <colomon> it's in the spectest, at any rate.

[22:04] <colomon> go jnthn go!

[22:06] * colomon is hoping there is nom in his near future...

[22:08] *** bacek left
[22:08] <pmurias> fglock: an't use string ("0") as an ARRAY ref while "strict refs" in use at /home/pawel/Perlito/lib5/MiniPerl6/Javascript/Emitter.pm line 23.

[22:08] <pmurias> t/01-sanity.t .............. 

[22:08] <pmurias> sorry

[22:08] <pmurias> Dubious, test returned 255 (wstat 65280, 0xff00)

[22:08] <pmurias> fglock: (@$pos).>>emit_javascript causes the error

[22:09] <pmurias> with @{@{ $pos }} being in the emitted file

[22:09] <fglock> looking here

[22:10] <fglock> I see the wrong code here - but why does it work for me?

[22:12] <colomon> jnthn: these compiles really are getting painful now, aren't they?

[22:12] *** nihiliad left
[22:12] <pmurias> perl6: my $a := [1,2,3];my $c = 0;for $a -> $b {$c += $b};

[22:12] <colomon> jnthn: wonder if there's some sort of O(N^2) issue in there we're just now getting large enough to really trigger...

[22:12] <p6eval> elf 30128: OUTPUT«Unknown rule: infix_postfix_meta_operator:=␤It needs to be added to ast_handlers.␤ at ./elf_h line 2850␤»

[22:12] <p6eval> ..rakudo c05da9: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 16934 (src/builtins/Junction.pir:399)␤»

[22:12] <p6eval> ..pugs:  ( no output )

[22:13] <pmurias> pugs: my $a := [1,2,3];my $c = 0;for $a -> $b {$c += $b};say $c;

[22:13] <p6eval> pugs: OUTPUT«6␤»

[22:13] <pmurias> pugs: my $a := [1,2,3];my $c = 0;for @$a -> $b {$c += $b};say $c;

[22:13] <p6eval> pugs: OUTPUT«6␤»

[22:14] <jnthn> colomon: It may be that

[22:14] <jnthn> colomon: It may inadvertantly be masak++'s set class.

[22:14] <jnthn> colomon: afaik it's the first thing that uses chars outside of latin-1

[22:14] <jnthn> (in the setting)

[22:15] <jnthn> colomon: And I think there's transcoding to latin-1 if it determines it can get away with it

[22:15] <jnthn> Or something.

[22:15] <jnthn> Otherwise we hit the UTF-8 codepath and it's horribly slow

[22:15] <jnthn> My recollection is hazy, but if that is the issue...well...it sucks.

[22:15] <jnthn> But it's possible.

[22:16] <jnthn> DAMM I hate this website!

[22:16] <jnthn> http://www.sj.se/messages/error/general.form?exception=java.lang.NullPointerException

[22:16] <jnthn> ...

[22:16] <fglock> pmurias: I found the bug in the perl5 emitter "hyper"

[22:17] <fglock> fixing - but I wonder why my perl doesn't say anything about it (v5.8.8)

[22:18] <pmurias> isn't the solution to change @$pos.>> to $pos.>>?

[22:19] <colomon> jnthn: I was wondering if it might be O(N^2) in memory -- that might be the sort of thing you'd miss for a long time and then get slammed hard by once it got big enough.

[22:19] <colomon> jnthn: which isn't to say I know of any flaws in your theory.  ;)

[22:20] <pmurias> perl6: say [1,2,3].>>perl.perl

[22:20] <p6eval> pugs: OUTPUT«("1", "2", "3")␤»

[22:20] <p6eval> ..rakudo c05da9: OUTPUT«Confused at line 11, near "say [1,2,3"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[22:20] <p6eval> ..elf 30128: OUTPUT«Parse error in: /tmp/2uYGAUieiI␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say [1,2,3].>>perl.perl␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[22:20] <p6eval> ..STD_red/std.rb…

[22:21] *** Teratogen joined
[22:22] <Teratogen> when is Perl 6 gonna be released, dammit

[22:22] <fglock> pmurias: I'd rather have explicit conversions for now, to keep the implementation simpler - but the current impl is missing the test for the '@' sigil (see For impl)

[22:22] <colomon> jnthn: spectest in progress here with full Xop and Zop changes, but I'm going to be gone a-nomming by the time it's done, I fear.  Will push when I return.

[22:23] <Teratogen> when is Perl 6 gonna be released, dammit

[22:23] <TimToady> Teratogen: depends on how many of us impatient people hack on it.

[22:23] <TimToady> we want it worse than you do

[22:24] <Teratogen> is anyone actually using Perl 6 in a real project?

[22:24] <sjohnson> Teratogen: you can use rakudo now anyways

[22:24] <sjohnson> and yes

[22:24] <fglock> (at p5 emitter line 330)

[22:24] *** snarkyboojum joined
[22:24] <sjohnson> few guys are writing cute games in perl 6

[22:24] <sjohnson> a few*

[22:26] <sjohnson> perl 5 is still pretty handy

[22:27] <jnthn> colomon: OK, cool. :-)

[22:28] *** SmokeMachine left
[22:28] *** pmurias left
[22:36] <jnthn> ffs. In the time I've spent screwing around with the swedish railways website, seeing it fail in various ways and still not having managed to buy a ticket, I could have walked to the station, got the ticket, gone for a beer and come home and still had time to spare. :-/

[22:37] <jnthn> The barrier for "ready for production" is apparently very, very low.

[22:39] <pugssvn> r30129 | lwall++ | [STD] missing punctuation message should point to before any whitespace 

[22:40] *** ggoebel joined
[22:40] <TimToady> jnthn: I specced your \| for you so we can haz a prototype for return

[22:40] <TimToady> s/prototype/signature/

[22:40] <jnthn> TimToady: I noticed.

[22:40] <jnthn> TimToady: Thanks. :-)

[22:41] <jnthn> TimToady: I may even get to sorting return out this evening

[22:41] <TimToady> if necessary, we can require predeclaration on that one, I suppose

[22:41] <jnthn> Cool

[22:41] * jnthn is currently distracted hacking on Shiny Stuff.

[22:41] <jnthn> :-)

[22:42] <jnthn> And pondering Russia.

[22:42] * jnthn has an invite and is very tempted.

[22:44] *** ggoebel left
[22:45] *** snarkyboojum left
[22:45] *** ggoebel joined
[22:45] <sjohnson> i think my boss is starting to realize that Perl is a pretty big deal as of late

[22:46] *** ggoebel left
[22:46] <sjohnson> i have been using PHP to slurp up binmode STDOUT from perl stuff i write a lot lately

[22:47] *** REPLeffect joined
[22:48] * fglock .oO( Perlito in PHP? )

[22:50] <jnthn> colomon: Not compiling Set.pm does appear to get us a win. I suspect it is that UTF8 parsing is dog slow.

[22:53] *** REPLeffect left
[22:54] <TimToady> first think STD does is unpack('U*') to an integer array  :)

[22:55] <TimToady> (though it also uses the string still for some testing)

[22:55] <jnthn> Yeah...don't think we quite want to re-do a strings implementation as well. :-)

[22:55] <TimToady> UTF8 will suck out your soul

[22:55] <jnthn> Rakudo already swaps out half of Parrot. ;-)

[22:56] <jnthn> (OK, I exagerate. A bit.)

[22:56] *** snarkyboojum joined
[22:56] <TimToady> and parrot is already committed to switching to NFG

[22:56] <jnthn> Yes.

[22:56] <jnthn> Quite.

[22:56] * jnthn wonders when that happens...

[22:57] <jnthn> oh yay

[22:57] <jnthn> > say [+] 1,2,3;

[22:57] <jnthn> # generating for +

[22:57] <jnthn> 6

[22:57] <TimToady> \o/

[22:57] <jnthn> Now to find out if I broke the parser. :-)

[22:57] <jnthn> Though if it compiled the setting, it can't be too broke.

[22:57] <mathw> \o/

[22:58] <jnthn> > say [].WHAT

[22:58] <jnthn> Array()

[22:58] <jnthn> > say [1].WHAT

[22:58] <jnthn> Array()

[22:58] <jnthn> > say [+1].WHAT

[22:58] <jnthn> Array()

[22:58] <jnthn> Well, it can't be so bad

[22:58] <jnthn> :-)

[22:59] <mathw> looking good

[22:59] <jnthn> > say [-] 1,2,3

[22:59] <jnthn> -4

[22:59] <jnthn> > say [R-] 1,2,3

[22:59] <jnthn> 2

[23:01] <fglock> pmurias: the hyper-op problem is fixed 

[23:01] <jnthn> .oO( need to fix Rakudo's hyper-op problem too... :-) )

[23:06] <sorear> jnthn: How do I easily share code between PMCs?

[23:06] *** REPLeffect joined
[23:07] <sorear> I may be killing p5Invocation, but Sub, Scalar, and Interpreter all need to do PCC<->P5Stack copying

[23:09] *** quietfanatic left
[23:09] <jnthn> sorear: When I needed that, I just popped it in a .c file, created a .h, #include'd that in the PMCs, and make sure it got linked in to perl6_group.dll

[23:09] <jnthn> (blizkost_group.dll in your case)

[23:10] <jnthn> sorear: I think that's what we do with bind.c in Rakudo.

[23:12] *** rv2733 left
[23:15] <lue> Hello!

[23:15] *** xomas joined
[23:15] *** xomas left
[23:15] *** xomas joined
[23:21] <jnthn> lue: oh hai

[23:24] <pugssvn> r30130 | lwall++ | [S03] document that R does not change associativity 

[23:25] *** cotto left
[23:25] <jnthn> wknight8111: About?

[23:26] <sorear> jnthn: Ick at not being able to use 'make headerizer'.

[23:26] <Teratogen> when is Perl 6 gonna be released, dammit

[23:26] <lue> who knows?

[23:26] <dalek> rakudo: 53ace9a | jonathan++ | src/ (3 files):

[23:26] <dalek> rakudo: First cut of reduce ops. Don't handle the triangle case yet (but it's an uncomment and some LHF away for some enterprising soul).

[23:26] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/53ace9a064e1cc8cfdb532a03d46296b2886052f

[23:27] * snarkyboojum only just got the Rakudo *, Rakudo Whatever connection :)

[23:27] <wknight8111> jnthn: pong?

[23:27] * jnthn wonders if Teratogen is just a bot that asks that question every so often, to motivate the Perl 6 devs to stay hard at work :-)

[23:27] <TimToady> could be

[23:28] <jnthn> wknight8111: I just managed to catch a slightly bewildering segfault in Parrot.

[23:28] <TimToady> if so, it's just slowing us down, so should be kicked

[23:28] <wknight8111> jnthn: orly? details?

[23:28] <lue> snarkyboojum: unintentional pun

[23:28] <jnthn> wknight8111: Sketchy, it only happens some of the time too

[23:28] <Teratogen> I am not a damned bot!

[23:28] <wknight8111> (typing with baby asleep in one arm. brevity.)

[23:28] <snarkyboojum> lue: unintentional?

[23:29] <TimToady> then listen to our answers, dammit!

[23:29] <sjohnson> Teratogen: yeah, it's not ready for production use yet, and there is no set deadline

[23:29] <jnthn> wknight8111: but when it does, it's trying to clone an Exception PMC

[23:29] <jnthn> wknight8111: Which falls back to the default freeze it then thaw it code

[23:29] <wknight8111> I dont know if Excption supports any of that

[23:30] <jnthn> wknight8111: Well, it's in an Object PMC that gets cloned

[23:30] <TimToady> Teratogen: the only requirement is that it is a convergent process; as long as that holds, the answer is "Soon enough."

[23:30] <jnthn> And thus it ends up being cloned itself.

[23:30] <jnthn> wknight8111: Rather than us trying to directly do it. :-)

[23:30] <jnthn> wknight8111: Anyway, I'm not sure how related to Exception it is.

[23:30] <wknight8111> inherits from Exception?

[23:31] <sjohnson> Teratogen: it will be ready when your heart is ready for it

[23:31] <jnthn> Guess so.

[23:31] <wknight8111> or delegates?

[23:31] <TimToady> hugme: hug Teratogen Real Hard

[23:31] * hugme hugs Teratogen Real Hard

[23:31] <jnthn> wknight8111: Hard to tell immediately from the C debugger ;-)

[23:31] <wknight8111> ok

[23:32] <jnthn> wknight8111: The really odd thing is this. It *looks* like the ImageIO's ->todo pointer which gets init'd to an RPA somehow has a NULL address in ->VTABLE->push_pmc

[23:32] <wknight8111> urg.

[23:32] <jnthn> Yes, that's what makes me think this isn't specific to Exception in any way.

[23:33] <jnthn> I checked the ImageIO's mark routine, and that it's set for custom marking, in case GC is happening at some point during this.

[23:33] <Teratogen> I guess what I want to ask is, when will Perl 6 be ready to do serious production work?

[23:33] <jnthn> The ImageIO PMC is only referenced on the stack if GC happesn at that point.

[23:33] <jnthn> But I thought Parrot could handle those cases fine, so I ain't sure it's just that.

[23:33] <sorear> Teratogen: Perl 6 was released years ago, it's actually a pretty good language now.  The library situation sucks, but you can help fix that!

[23:34] <sorear> Teratogen: People are using it in production now.  Not many of them, but some.

[23:34] <sjohnson> Teratogen: probably 2-12 months ?

[23:34] <sjohnson> maybe less?

[23:34] <TimToady> really depends on your definition of "serious"

[23:34] <TimToady> I wouldn't use it for designing airliners just yet.

[23:34] <jnthn> wknight8111: Anyway, thought I'd mention it in case you had any memories of debugging in that area. :-)

[23:35] <jnthn> wknight8111: It's rather hard to formulate a decent ticket on it.

[23:35] <jnthn> I only get it one run in 5 or so under the debugger.

[23:36] <wknight8111> jnthn: it sounds similar to a bug we had in the past

[23:36] <wknight8111> the imageIO was getting prematurely collected and recycled

[23:36] <wknight8111> because the ->todo shoulb be set in the init routine

[23:37] <jnthn> Yeah, I see it should be. And walking up the call stack, I don't see why it woulnd't be.

[23:37] <jnthn> 2 frames up is:

[23:37] <jnthn>     PMC *image = Parrot_pmc_new(interp, enum_class_ImageIO);

[23:37] <jnthn>     VTABLE_set_pmc(interp, image, pmc);

[23:37] <jnthn>     return VTABLE_get_string(interp, image);

[23:37] <TimToady> Teratogen: Rakudo * (and successors) is intended for serious early adopter production, so that we will have some confidence that we can lock down a 6.0.0 api we can stick with over the long haul

[23:38] <jnthn> And it's that image PMC that's seeing to lose its ->todo, or have its ->todo collected.

[23:38] <wknight8111> yeah, so thats probably it

[23:39] <TimToady> but early adopters will understand that we can still break things to fix things before 6.0.0

[23:39] <jnthn> wknight8111: It does occur to me seperately, that every time we have to go thorugh freeze/thaw default clone implementation, it's hideously expensive compared to the PMC knowing how to clone itself.

[23:40] <jnthn> wknight8111: It may be interesting to see how often it gets hit.

[23:40] <TimToady> esp if you can clone value bits by merely copying a ref

[23:40] <wknight8111> yes

[23:40] <Teratogen> ok

[23:40] <jnthn> wknight8111: Actually I'm curious...

[23:41] <jnthn> wknight8111: I'll try it now and try and get a feel for how often it is. :-)

[23:41] <TimToady> Teratogen: as I said at the top; we're more impatient about this than you are :)

[23:41] <wknight8111> okay, thanks

[23:41] <Teratogen> I'd love to start writing Perl 6 modules

[23:41] <jnthn> TimToady: Yes, indeed. And freeze/thaw allocates some PMCs to do its work too, so it's lose all around.

[23:42] <TimToady> you can now, if you don't mind 'em bitrotting occasionally

[23:42] *** nihiliad joined
[23:42] <TimToady> the STD parser is a Perl 6 module that I've been working on for years now

[23:42] *** cotto joined
[23:43] <fglock> Perlito 4.0: http://github.com/fglock/Perlito/tree/7f0ac392dfcf04d390ebefe5f4274bb37cbd7b6e

[23:43] <fglock> pmurias++ # thanks for testing

[23:44] <wknight8111> jnthn: if you see it again, take a backtrace. I'd like to see it

[23:44] *** dual left
[23:44] <jnthn> wknight8111: Will try and do so.

[23:44] <wknight8111> if the PMC is not anchored anywhere, and the optimized build keeps it off the stack for long enough, it could be getting collected

[23:44] <wknight8111> thanks

[23:45] *** dual joined
[23:45] <jnthn> wknight8111: We actually end up hitting the default freeze/thaw even in "say 42"

[23:45] <jnthn> Twice.

[23:45] <lue> STD.pm: the hopeful end-result of any decent P6 implementation :)

[23:45] <wknight8111> ouch

[23:46] <wknight8111> jnthn: we definitely need to avoid that

[23:46] <jnthn> let me dump the PMC type id too

[23:46] <wknight8111> I think we've recently decided that clone should be shallow by default, so it's going to have different semantics from freeze/thaw anyway

[23:46] <wknight8111> please do!

[23:46] <jnthn> wknight8111: is it SELF->vtable->id ?

[23:47] <jnthn> oh no, it's base_type, ain't it...

[23:47] <wknight8111> pmc->vtable->base_type

[23:48] <wknight8111> pmc->vtable->whoami may be more informative (that's the string name of the type)

[23:48] <jnthn> it's OK, an ID is easy enough to look up too

[23:48] <jnthn> Mostly I want to see if it's all the same one or a whole mixture.

[23:49] <jnthn> All the same

[23:49] <jnthn> Always 6

[23:49] <jnthn> (Exception)

[23:53] <colomon> you got reduce ops up!?!

[23:54] <jnthn> colomon: Yeah

[23:54] <jnthn> rakudo: say [*] 1..10

[23:54] <p6eval> rakudo 53ace9: OUTPUT«3628800␤»

[23:54] <colomon> \o/

[23:54] <jnthn> rakudo: multi postfix:<!>($n) { [*] 1..$n }

[23:55] <colomon> except for the part where I have to recompile and retest...  ;)

[23:55] <p6eval> rakudo 53ace9:  ( no output )

[23:55] <jnthn> rakudo: multi postfix:<!>($n) { [*] 1..$n }; say 5!

[23:55] <p6eval> rakudo 53ace9: OUTPUT«120␤»

[23:55] <jnthn> colomon: Did you re-structure infixish to be more stdish?

[23:55] <jnthn> :-)

[23:56] * jnthn looks forward to colomon++'s patch too

[23:56] <jnthn> colomon: I think we can probably have hyper ops pretty soonish too.

[23:56] <sorear> woah!!!!

[23:56] <sorear> reduce AND custom infix?

[23:57] <sorear> colomon++

[23:57] <jnthn> sorear: custom postfix. :-)

[23:57] <sorear> er

[23:57] <sorear> right

[23:57] <sorear> either way.

[23:57] <jnthn> Custom prefixes and infixes do also work.

[23:58] <sorear> But not (post)circumfixes?

[23:58] <jnthn> You can override the existing ones.

[23:58] <jnthn> (postcircumfixes that is)

[23:58] <jnthn> Well

[23:58] <jnthn> You can do like

[23:58] <jnthn> method postcircumfix:<( )>($c) { ... }

[23:59] <jnthn> If you want to be able to override invocation

[23:59] <jnthn> And [ ] and { } are also possible. :-)

[23:59] <jnthn> I think custom ones (and circumfixes) would perhaps count as things you have to do with slangs. Maybe.

[23:59] <sorear> Slangs?

