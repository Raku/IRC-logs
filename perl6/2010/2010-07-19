[00:00] *** Patterner left
[00:00] *** Psyche^ is now known as Patterner

[00:01] *** xabbu42 left
[00:12] <dalek> book: a174b35 | duff++ | src/operators.pod:

[00:12] <dalek> book: fix description of 3-way comparators noticed by ineol++

[00:12] <dalek> book: review: http://github.com/perl6/book/commit/a174b35024d40c267f640fb56d1dd22fb4510568

[00:13] *** timbunce joined
[00:15] <sorear> hello timbunce

[00:17] *** timbunce_ joined
[00:18] * timbunce_ waves at sorear from a hotel somewhere near Newark NJ

[00:19] *** timbunce left
[00:19] *** timbunce_ is now known as timbunce

[00:21] *** skids left
[00:24] *** LionMade0fLions joined
[00:26] *** skids joined
[00:28] <pmichaud> sorear: (constant space) depends on how/where it gets evaluated

[00:28] <pmichaud> certainly 0, *+1 ... 10000  itself is constant space.

[00:28] *** TiMBuS left
[00:29] <sorear> pmichaud: how many ways are there to evaluate &reducewith?

[00:29] <pmichaud> sorear: oh, that part

[00:30] <pmichaud> seems to me that reducewith should grab its elements and munch them as needed

[00:30] <sorear> how?

[00:30] <pmichaud> looking

[00:30] <sorear> I'm not necessarily asking about Rakudo

[00:31] <sorear> just general hints for how to make a Perl 6 implementation

[00:31] <sorear> I understand you recently redesigned the lazy list / streaming computation system

[00:31] <pmichaud> right

[00:31] <pmichaud> and in that respect, rakudo ought to be fairly typical

[00:31] <pmichaud> &reducewith in Rakudo shifts values off of the list

[00:31] <pmichaud> so that tends to keep it in constant space

[00:31] <pmichaud> (since the earlier values get gc'd)

[00:32] <sorear> How does [+] @foo  avoid destroying @foo?

[00:32] <pmichaud> because the argument to &reducewith is a slurpy array, and that slurpy array is what gets shifted

[00:32] <pmichaud> not @foo itself.

[00:33] <TimToady> tylercurtis: the main difference of $x? and *$y is that $x must be a separate argument, while $y is just the first/next argument from the flattened variadic argument list; foo(@bar) would put @bar into $x but @bar[0] into $y

[00:34] <TimToady> oh, I see you got there

[00:35] <pmichaud> TimToady: have plans for Tue?  I'm going to hang out somewhere and hack (possibly OCC, but open to other suggestions)

[00:36] <TimToady> I will still be madly writing my talk for Thu

[00:36] <pmichaud> got a theme/topic yet?

[00:36] <TimToady> I think so :)

[00:36] <pmichaud> excellent.  :)

[00:36] *** nbrown joined
[00:36] <TimToady> it's about being disruptive...

[00:37] <pmichaud> I very much look forward to seeing it

[00:37] <tylercurtis> TimToady: so *$y will take the next element from even a non-interpolated list?

[00:37] <TimToady> and will have a devil on one shoulder and an angel on the other, played by Aron and Glo

[00:37] <sorear> rakudo: sub foo(@x) { say @x.WHAT }; foo(1)

[00:37] <p6eval> rakudo cd64dd: OUTPUT«Nominal type check failed for parameter '@x'; expected Positional but got Int instead␤  in 'foo' at line 22:/tmp/oQK_7BKAYV␤  in main program body at line 22:/tmp/oQK_7BKAYV␤»

[00:37] <sorear> bad rakudo

[00:37] <pmichaud> TimToady: oh, that should be *excellent!*

[00:37] <pmichaud> ..."bad rakudo"?

[00:38] <TimToady> tylercurtis: it puts the rest of the args into interpolation mode, so no, unless you use it inside []

[00:38] <sorear> pmichaud: I think that should have succeeded; putting 1 into list context ought to have made a one-item list

[00:38] <sorear> ?

[00:38] <pmichaud> sorear: I'm pretty certain that @ doesn't automatically listify its argument.  Otherwise anything would bind.

[00:38] <tylercurtis> TimToady: I don't think I understand what "foo(@bar) would put @bar into $x but @bar[0] into $y" means, then.

[00:39] <pmichaud> sorear: or, another way of saying what you just said is that Any does Positional

[00:39] <TimToady> if the sig was sub foo($x?, *@z), foo(@bar) is in item context, and ends up in $x only

[00:40] <pmichaud> notably:    my @a := 1;  # should fail, not automatically listify the Int

[00:40] <sorear> rakudo: say 1[0]

[00:40] <p6eval> rakudo cd64dd: OUTPUT«1␤»

[00:40] <sorear> Any *does* do Positional

[00:40] <TimToady> with sub foo(*$y, *@z), foo(@bar) distributes the first arg to $y and the rest to @z

[00:40] <pmichaud> no, Any has postcircumfix:<[ ]>

[00:40] <pmichaud> just because something has postcircumfix:<[ ]>  doesn't mean it has to ~~ Positional

[00:40] <TimToady> because in that case the @bar is in the flattened part of the argument list

[00:41] <pmichaud> (TimToady is perfectly free to correct me here :-)

[00:41] <sorear> How does postcircumfix:<[ ]> contextualization work?

[00:41] <sorear> I imagine it's something like .Positional.[0]

[00:41] <pmichaud> ...contextualization?  I don't understand the question.

[00:42] <tylercurtis> TimToady: ah.

[00:42] <pmichaud> at the moment, Positional implies the ability to be bound to an @-sigiled variable, and the existence of an "at_pos" method.  It doesn't imply much more than that.

[00:42] <sorear> As I understand it, .[0] on Any means something like .list.[0]

[00:43] <pmichaud> that's what ultimately happens, yes.

[00:43] <sorear> also: how my @x = 1 and my @x = 1, 2 both work

[00:43] <sorear> the 1 is promoted to a list.  somehow.

[00:43] <pmichaud> because it's a "list assignment"

[00:43] <sorear> this is the part that I'm stuck on

[00:43] *** rgrau__ left
[00:43] <pmichaud> (yes, I know, = isn't assignment there.  but it works without the 'my')

[00:43] <pmichaud> @x = 1;   # list assignment

[00:43] <pmichaud> @x = 1, 2;  # list assignment

[00:43] <pmichaud> list assignment puts it rhs into list context

[00:44] <sorear> Yes

[00:44] <TimToady> flat context, even

[00:44] <sorear> List context

[00:44] <sorear> I'm trying to get you to tell me how list context works

[00:44] <pmichaud> right, flat context  (TimToady++)

[00:44] <pmichaud> flat context just calls .flat, essentially.

[00:44] <sorear> What does .flat return?

[00:45] <pmichaud> a list that flattens any parcels and Iterables

[00:45] <sorear> What's a list?

[00:45] <TimToady> I think he wants to know more about how the cursors work inside

[00:45] <pmichaud> (Iterables that aren't marked as non-flattening, that is)

[00:46] <pmichaud> A list has reified and non-reified elements

[00:46] <sorear> Let's say I'm going to implement list assignment

[00:46] <sorear> I call .flat on the RHS

[00:46] <sorear> I get a "list"

[00:46] <sorear> what properties does a "list" have and what can I do with it?

[00:46] <pmichaud> so, that list has reified and non-reified elements

[00:46] <pmichaud> you can shift values from the list

[00:46] <sorear> is it a List?  a Positional?  an Iterable?  something else entirely?

[00:47] <pmichaud> in Rakudo, it's a List.

[00:47] <pmichaud> List does Positional

[00:47] <pmichaud> List isa Iterable

[00:47] <TimToady> it's a list that has had a flattening iterator substituted for the imaginary part

[00:47] <pmichaud> (Iterable could be a role -- we have it as a class for now)

[00:48] <TimToady> a slice on the other hand would have a slicing iterator on the imaginary part

[00:48] <sorear> @x = @y

[00:48] <pmichaud> List has a private method that says "reify at least the first n elements"

[00:48] <sorear> 1. flat(@y)

[00:48] *** azert0x left
[00:48] <sorear> 2. flat notices that @y is a flattenable Iterable and calls @y.flat

[00:49] *** ineol joined
[00:49] <sorear> 3. Array.flat constructs a List which will lazily clone the array in its iteration

[00:49] <sorear> 4. List assignment receives the list, and iterates over it, assigning to @x

[00:49] <sorear> ?

[00:49] <pmichaud> I'm not sure about @2

[00:49] <pmichaud> er #2

[00:49] <TimToady> I think that's just the usual function -> method mapping

[00:50] <pmichaud> &flat tends to want to iterate its Parcel argument

[00:50] *** whiteknight left
[00:50] <tylercurtis> rakudo: say $*OUT: 1, 2, 3;

[00:50] <p6eval> rakudo cd64dd: OUTPUT«===SORRY!===␤Confused at line 22, near "say $*OUT:"␤»

[00:50] <TimToady> std: say $*OUT: 1, 2, 3;

[00:50] <pmichaud> (&flat takes a slurpy, that is)

[00:50] <p6eval> std 31756: OUTPUT«ok 00:01 115m␤»

[00:51] *** hsb left
[00:51] <TimToady> tylercurtis: rakudo doesn't implement that syntax yet

[00:51] <pmichaud> anyway,  &flat constructs a list that knows it's to flatten out any flattening-Iterables it encounters

[00:52] <TimToady> anyway, the important step is #3

[00:52] <tylercurtis> TimToady: I didn't think so, but I wanted to check.

[00:52] *** hsb joined
[00:52] <pmichaud> in that process, it ends up asking @a for a List that it can iterate over

[00:52] <pmichaud> and the List that @a returns ends up reifying the elements of @a

[00:52] <pmichaud> it doesn't actually clone the values, because we want the actual elements of @a, not clones.

[00:53] <pmichaud> i.e.,  @a.list  should give me @a[0], @a[1], @a[2] (the containers), and not just cloned instances of the values.

[00:53] <pmichaud> in particular so that   map {...}, @a;   can actually manipulate the values of @a

[00:54] <TimToady> or for, if bound rw

[00:54] <pmichaud> right

[00:54] <pmichaud> (for and map are soon to be synonymous in Rakudo)

[00:54] <pmichaud> s/synonymous/isomorphic)

[00:55] <TimToady> Sink me!  -- the Scarlet Pimpernel

[00:55] <sorear> Can I get away with not having an Iterable?

[00:56] <pmichaud> Iterable is how Rakudo knows that something flattens in flattening context

[00:56] <TimToady> I don't see how

[00:56] <pmichaud> I suppose there are other ways to do it, but that seemed easiest.

[00:56] <TimToady> you need something that distinguishes objects that have structure from those that don't

[00:56] <sorear> rakudo's check for flattening is, iiuc, isa(Iterable) && !hasprop("scalar")

[00:56] <pmichaud> sorear: correct.

[00:56] <TimToady> how 1 knows it's a list of one element is because it's *not* Iterable

[00:57] <sorear> niecza's check for flattening is currently hasprop("flattens")

[00:57] <TimToady> flattening is not a property of the object

[00:57] <TimToady> it's a property of the arg in the argument list

[00:57] <TimToady> flatten*able* is different from flatten*ing*

[00:57] <pmichaud> I decided it was easier to mark things that don't flatten than to mark the things that do

[00:57] <pmichaud> for example, Ranges flatten.

[00:58] <pmichaud> Lists flatten.

[00:58] <pmichaud> Arrays flatten.

[00:58] <pmichaud> etc.

[00:58] <TimToady> they *can* flatten

[00:58] <sorear> TimToady: hasprop() here refers to the container, not the value

[00:58] <TimToady> jnthn++ and I were discussing this the other night; flattening is most naturally a mark on the argument slot in a capture that disappears the moment it is bound along with the capture

[00:58] <sorear> you can have flattening and non-flattening refs to values

[00:59] <TimToady> the fact that foo(@a) can flatten @a should not carry through if it happens to have bound it to a $x

[00:59] <pmichaud> TimToady: that somewhat requires the construction of an actual Capture on each call, which Rakudo avoids at the moment.

[01:00] <sorear> TimToady: you also need to have an explicit flattens bit on procedure returns

[01:00] <TimToady> it only has to be constructed if there's anything that actually requires flattening

[01:00] <sorear> TimToady: sub { [1, 2] } and sub { my @x = 1, 2; @x  } are not at all the same

[01:00] <pmichaud> ..which means you have to know the things that can flatten

[01:00] <TimToady> well, that's "decontainerizing" in my mind rather than flattening

[01:00] <sorear> pmichaud: basically, what I'm wondering is if "has a .flat override" can serve the role of "does Iterable"

[01:01] <TimToady> dinner &

[01:01] <pmichaud> sorear: possibly.  That doesn't fit well in my mental model at the moment.

[01:02] <sorear> pmichaud: what motivated the change from coroutine iterators to lazy tree iterators?

[01:02] <pmichaud> I don't quite understand "coroutine iterators"

[01:03] <sorear> the old, mutable iterators were coroutines?

[01:03] <pmichaud> only gather/take, afaik

[01:03] <pmichaud> (and it's still a coroutine)

[01:03] <pmichaud> the primary motivation for the change were issues with bound versus non-bound lists

[01:04] <pmichaud> also, previous versions of the spec had List as immutable, where it turns out it really doesn't want to be.

[01:04] *** sorear sets mode: +vvo IRSeekBot p6eval tylercurtis

[01:08] *** meppl left
[01:09] <sorear> Should there be a difference in behavior between @x.flat and @x.item.flat?

[01:09] <pmichaud> I would think not.

[01:10] <pmichaud> however, there is a difference between   &flat(@x)  and &flat(@x.item)

[01:10] <pmichaud> (at least as rakudo has it)

[01:15] <pmichaud> TimToady: (for when you return)  -- I'm not sure that I see that we can easily divorce flattening from types and say it's merely a property of the capture (more)

[01:15] <pmichaud> if I have a sub abc(*@_) { ... }    and it's called as     abc(1, @xyz, foo())

[01:16] <pmichaud> while I can definitely know that @xyz should be flattening, it's not easy to know about the return value of foo()

[01:16] <sorear> pmichaud: 20:00 <@sorear> TimToady: you also need to have an explicit flattens bit on  procedure returns

[01:16] <pmichaud> sorear: right

[01:17] <pmichaud> but that still means we have to inspect the value being returned

[01:17] <tylercurtis> rakudo: say "foo\nbar\nbaz".lines

[01:17] *** felliott joined
[01:17] <p6eval> rakudo f55fb0: OUTPUT«Method 'lines' not found for invocant of class 'Str'␤  in main program body at line 22:/tmp/YOy_VEAP0j␤»

[01:18] <sorear> niecza would inspect the lvalue being returned, not the object itself

[01:18] *** felliott left
[01:18] <sorear> well.  time to implement lists.

[01:18] <pmichaud> what if it's not an lvalue, though?

[01:18] <pmichaud> sub foo() { return 1..5; }

[01:18] <pmichaud> sub foo() { gather for @list { ... } }

[01:18] <sorear> I'm using the C99 definition of lvalue

[01:19] <pmichaud> I guess I'm not familiar with that definition.

[01:19] <sorear> "locator" value

[01:19] <sorear> aka a container reference

[01:19] *** felliott joined
[01:19] <sorear> which may or may not be writablew

[01:20] <pmichaud> 1..5 doesn't have a container, though.

[01:20] <pmichaud> (unless you count the Capture that holds it)

[01:20] <sorear> in niecza right now, everything logically has a container

[01:20] <pmichaud> that's possible and possibly reasonable :)

[01:21] <pmichaud> technically every value in Rakudo has a container (PMC) also.

[01:21] <pmichaud> but I'm not sure it's the same meaning :)

[01:23] *** f00li5h left
[01:24] *** f00li5h joined
[01:24] <pmichaud> 01:00 <sorear> pmichaud: basically, what I'm wondering is if "has a .flat override" can serve the role of "does Iterable"

[01:24] <pmichaud> the more I think about it, the more I think this doesn't quite work.

[01:25] <pmichaud> not exactly sure why.

[01:25] <sorear> flat, in rakudo:

[01:25] <sorear>  for each argument:

[01:25] *** f00li5h left
[01:25] *** f00li5h joined
[01:25] <pmichaud> But flattening tends to be a property of a List, not of the things in the list.

[01:25] <sorear>   if isa(Iterable) && !hasprop("scalar"):

[01:25] <sorear>    add thing.iterator to the list

[01:25] <sorear>   else:

[01:25] <sorear>   add thing to the list

[01:26] <sorear> my proposed flat:

[01:26] <pmichaud> there's two different lists there

[01:26] <sorear>  for each argument:

[01:26] <sorear>   if hasprop("flattens"):

[01:26] <sorear>    add thing.flat to the list

[01:26] <sorear>   else:

[01:26] <sorear>   add thing to the list

[01:26] <sorear> ?

[01:26] <sorear> two lists?

[01:26] <pmichaud> yes

[01:26] <sorear> input and output?

[01:27] <pmichaud> for rakudo, the iterator gets added to the "@!rest" list, while a non-flattening thing gets added to the "@!items" list.

[01:28] <sorear> In how much detail is the Iterator, Iterable, and List API specced?

[01:28] <pmichaud> I have a grant to write up Rakudo's version of it.

[01:28] <pmichaud> (and let those become S07/S08)

[01:28] *** timbunce left
[01:28] <pmichaud> s/grant/grant proposal/

[01:28] <pmichaud> what currently exists in S07 and S08 are basically Wrong.

[01:28] <pmichaud> some things need updating in S02 also.

[01:29] <pmichaud> none of that is likely to occur before the 29th, though.

[01:29] <pmichaud> (for what I hope are obvious reasons :-)

[01:29] <sorear> I'll just make up something

[01:29] <sorear> I can fix it later

[01:30] <pmichaud> sorear: so, you would have Ranges and Lists have a .flattens property?

[01:30] <pmichaud> (in their "native" not-in-item-context sense)

[01:32] <pmichaud> also, with

[01:32] <pmichaud> 01:26 <sorear>   if hasprop("flattens"):

[01:32] <pmichaud> 01:26 <sorear>    add thing.flat to the list

[01:32] <pmichaud> would thing.flat return something that doesn't have the "flattens" property?

[01:36] * pmichaud wanders off for a bit.

[01:43] *** aubreyja joined
[01:46] <sorear> pmichaud: no.

[01:46] <sorear> Range would not have a flattens property

[01:46] <sorear> flattens is a property of the lvalue, not of the object itself

[01:47] <sorear> sub infix:<..>($min, $max) { @( Range.new(:$min, :$max) ) } # @() sets the flatten bit in the returned lvalue

[01:47] <sorear> sub infix:<..>($min, $max) { my @r := Range.new(:$min, :$max); @r } # or maybe this, if @() is too cloney

[01:48] <sorear> going way, way back to the first example:

[01:49] <sorear> inside the dynamic scope of &reducewith(&:[+], 0, *+1 ... 10000), there exists a $callframe such that $callframe.args.[1] is the list

[01:49] <sorear> does this hold a reference to the beginning of the iterator chain and thereby force the evaluation to take O(n) space?

[01:55] *** ineol left
[01:58] *** Limbic_Region left
[02:09] *** ashleydev left
[02:14] *** agentzh joined
[02:17] *** hercynium joined
[02:20] <pmichaud> sorear: parenthesize that for me.

[02:20] <pmichaud> I think of it as   &reducewith(&:[+], (0, *+1 ... 10000))

[02:21] <pmichaud> at any rate,   args.[1]  is indeed the list returned from the series operator

[02:21] <pmichaud> and it holds an iterator that is responsible for producing the elements of the list

[02:21] <pmichaud> as we shift items off that list, it remains O(n) space

[02:24] <pmichaud> 01:47 <sorear> sub infix:<..>($min, $max) { @( Range.new(:$min, :$max) ) } # @() sets the flatten bit in the returned lvalue

[02:25] <pmichaud> that feels wrongish.  I think that @(...) should generally translate into a .list call, which should return a List or something that can be shifted

[02:26] <pmichaud> in particular,  I suspect that     my $x = 3..4;  and   my $x = @(3..4)   should be diferent.

[02:26] <pmichaud> *different

[02:27] <sorear> yeah, which is why I had the second version

[02:27] <sorear> .list.shift never affects the original, right?

[02:27] <pmichaud> that seems a bit better, although I'm not keen on binding values prematurely.

[02:27] <sorear> "binding values"?

[02:28] <pmichaud> it can affect the original if the original returned self in response to .list

[02:28] <pmichaud> .list doesn't (yet) require a clone

[02:29] <sorear> does .flat require a clone?

[02:29] <pmichaud> no

[02:29] <pmichaud> @array.flat   is probably the same as @array.list, since an array is already flattened.

[02:29] <sorear> does binding to a slurpy parameter require a clone?

[02:29] <pmichaud> I don't think we ever bind to a slurpy parameter.

[02:30] <pmichaud> or, if we do, we're binding a capture or parcel, and not the thing in the capture/parcel

[02:31] <sorear> &reducewith(&:[+], (0, *+1 ... 10000))

[02:31] <sorear> args.[1] is a List object created by infix:<...>

[02:31] <sorear> like any List object, it remembers values as they are iterated

[02:31] <pmichaud> sure, but shifting eliminates the first value

[02:32] <sorear> &reducewith can't shift values off the passed list, because then [+] @foo would screw things up

[02:32] <pmichaud> sure it can.

[02:32] <sorear> how?

[02:32] <pmichaud> @foo isn't the List

[02:32] <pmichaud> the signature for &reducewith is    &reducewith(&how, @*args)

[02:32] <pmichaud> er, *@args

[02:32] <pmichaud> @args is the thing that is shifted, not @foo

[02:33] <pmichaud> (and @args is not @foo)

[02:33] <pmichaud> in particular,    [+] @foo, 1, 2, 3

[02:33] <sorear> you just reintroduced the memory leak

[02:33] <pmichaud> no

[02:33] <sorear> because if @args is shifted, then (0, *+1 ... 10000) now has to retain prior values!

[02:33] <pmichaud> in that case, @foo is a *bound array*, so the values have to be remembered.

[02:34] <pmichaud> why does (0, *+1 ... 10000) have to remember prior values?

[02:34] <pmichaud> you're not being precise enough.

[02:34] <sorear> because it's a List and we're not shifting stuff off it

[02:34] <pmichaud> we are shifting stuff off of it.

[02:34] <pmichaud> I did say we were shifting @args

[02:35] <sorear> 21:32 <@pmichaud> @args is the thing that is shifted, not @foo

[02:35] <pmichaud> right

[02:35] <sorear> @args is not "it"

[02:35] <pmichaud> that's what I said.

[02:35] <pmichaud> as I said, you're not being precise enough.  :-)

[02:35] <pmichaud> with (0, *+1 ... 10000)  there is no @foo

[02:35] <pmichaud> so, start again.  :-)

[02:36] <sorear> infix:<...> returns a List

[02:36] <pmichaud> correct

[02:36] <sorear> let's call it @foo

[02:36] <pmichaud> no

[02:36] <sorear> for the sake of it having a name

[02:36] <pmichaud> that would bind it

[02:36] <pmichaud> if you want to give it a name, call it $foo

[02:36] <sorear> precision please.  what's binding.

[02:37] <pmichaud> @foo tends to imply array-ness which isn't what I want here.

[02:37] <pmichaud> okay, let's do it this way.

[02:37] <pmichaud> my @foo := (0, *+1 ... 10000)

[02:37] <pmichaud> good enough?

[02:37] <pmichaud> @foo is a List.

[02:37] <sorear> ok.

[02:37] <pmichaud> but it's a temporary, it's not in the outer scope at all

[02:38] <pmichaud> @foo is just the temporary name we're using to describe it here -- it's not an actual entry in the lexpad

[02:38] <sorear> sure

[02:38] <pmichaud> okay

[02:38] <pmichaud> so, we then have   [+] @foo

[02:38] <pmichaud> &reducewith gets called, and   @args ends up with  @foo as its only element

[02:39] <pmichaud> okay so far?

[02:39] <sorear> Why doesn't @args end up with 10k elements?

[02:39] <pmichaud> because slurpy arguments are lazy

[02:39] <pmichaud> sorry

[02:39] <pmichaud> slurpy parameters are lazy

[02:40] <sorear> So, @args ends up with no elements + an iterator that reads from @foo[$i++] ?

[02:40] <pmichaud> in rakudo,  @args ends up with an empty @!items and @!rest holds @foo

[02:41] <sorear> @!rest is for lazy flattening without the overhead of iterators?

[02:41] <pmichaud> @!rest holds everything that hasn't been reified yet

[02:41] <pmichaud> @!rest is the "lazy" portion of a list

[02:41] <pmichaud> @!items is the "already evaluated" portion of a list

[02:42] <sorear> ok.  I think I follow.

[02:42] <pmichaud> a List consists of the things that have already been reified, and the things yet to be reified

[02:42] <sorear> and the "things yet to be reified" is a low-level-array of Iterable/

[02:42] <sorear> ?

[02:43] <pmichaud> it's a low-level array of elements.  they don't have to be Iterables

[02:43] <pmichaud> in   [+]  @foo, 1, 2, 3

[02:43] <pmichaud> 1, 2, and 3  are in @!rest

[02:43] <sorear> are non-iterables treated as 1-item iterables in @!rest?

[02:43] *** colomon joined
[02:43] <pmichaud> non-iterables are treated as items

[02:43] <pmichaud> they automatically go to the @!items portion when needed

[02:43] <sorear> ok

[02:43] <sorear> I follow

[02:43] <pmichaud> (i.e., they don't iterate or flatten)

[02:44] <pmichaud> better is to say that they don't interpolate

[02:45] <pmichaud> should I continue with the example, or is it clearer now how this remains constant space?

[02:45] <sorear> continue

[02:45] <pmichaud> okay

[02:45] <pmichaud> so, @args has @foo as its single-element @!rest

[02:45] <pmichaud> we ask @args for a value via @args.shift

[02:45] <pmichaud> @args in turn knows that it needs to reify one value

[02:45] <pmichaud> (and it has none in @!items)

[02:45] <pmichaud> so it looks at its @!rest and finds @foo

[02:46] <pmichaud> @foo can interpolate (is Iterable), so it asks @foo for an Iterator

[02:46] <pmichaud> it then asks that Iterator to reify a value

[02:46] <pmichaud> and replaces @foo in @!rest with the value+Iterator

[02:46] <pmichaud> (I skipped a couple of steps there, but that's essentially what happens)

[02:46] <pmichaud> it then moves the value into @!items

[02:47] <pmichaud> and now having 1 item, is able to shift+return that item

[02:47] <pmichaud> leaving only one element (the iterator) in @!rest

[02:47] <pmichaud> the original @foo is now gone -- all we have left is the iterator.

[02:47] <sorear> except that the Capture holds a reference to the original @foo

[02:48] <sorear> and the CallFrame holds a reference to the Capture

[02:48] <pmichaud> ...except that Rakudo doesn't build an explicit capture in this instance

[02:48] <pmichaud> but let me think about that a second.

[02:49] <pmichaud> actually, it's okay that there's a reference to the original @foo

[02:49] <sorear> S06:2668

[02:49] <pmichaud> it's still just a List

[02:49] <pmichaud> it's not holding a reference to an Iterator

[02:49] <pmichaud> well, that's maybe not quite true either.

[02:49] <sorear> Let me try a slightly different example

[02:49] <pmichaud> hmmm.

[02:49] <sorear> [+] $*IN.lines

[02:50] <sorear> $*IN.lines has to save what it's already read in case somebody decides to do callframe(&reducewith).args.[1].[42] ?

[02:51] <pmichaud> I don't read it that way.

[02:51] <pmichaud> at any point in time,   .[42]  means "42 lines from the current line position"

[02:52] <pmichaud> it doesn't have to mean  "42 from the beginning"

[02:52] <pmichaud> because .lines is explicitly lazy and explicitly discards lines ones read

[02:52] <pmichaud> *once

[02:53] <pmichaud> my best example would be

[02:53] <pmichaud> (and it's not a great one)

[02:53] <pmichaud> actually, I don't have a good example.

[02:53] <pmichaud> anyway,  I'd argue that   .[42] would end up reading and throwing away 42 lines in the middle

[02:53] <sorear> so, ultimately, what you're saying is that series Lists and file read Lists only expect to be iterated over once and don't store iterated values.

[02:54] *** Potatohead joined
[02:54] <pmichaud> right.  it's binding to a symbol or container that starts to cause things to be remembered.

[02:54] <pmichaud> where "appearing in another list" doesn't count as such a binding

[02:54] <sorear> what does binding have to do with this?

[02:55] <sorear> how does a List know that it's been bound to something?

[02:55] <pmichaud> sub abc(@a) { ... };    abc (0, *+1 ... 10000)

[02:55] <pmichaud> in this instance, @a is bound to the list

[02:55] <pmichaud> and so   referencing  @a[42]  causes @a[0..41]  to be reified and remembered

[02:56] <pmichaud> (as well as @a[42], of course)

[02:57] <pmichaud> and with

[02:57] <pmichaud> abc $*IN.lines

[02:57] <pmichaud> referencing @a[42]  does cause lines 0 through 41 to be remembered in @a

[02:58] <pmichaud> (dealing with bound versus unbound lists is what made lists/iterators so difficult to begin with)

[03:01] *** justatheory left
[03:06] <pmichaud> afk # walk, then regex backtracking work

[03:13] *** aubreyja left
[03:20] *** skids left
[03:22] <Potatohead> exit

[03:22] *** Potatohead left
[03:23] *** [synth] left
[03:31] <jnthn> sub foo(@x) { say @x.WHAT }; foo(1) # yes, this should fail. If not, you couldn't mulit-dispatch by sigil.

[03:42] <pmichaud> jnthn++

[03:44] *** shakesoda left
[03:45] <pmichaud> hmm.  something broke after 07-14 that is causing a lot of tests to be skipped or ignored by the test_summary.pl script :-(

[03:45] * pmichaud wonders if it's connected to his settings work.

[03:46] <jnthn> settings?

[03:46] <pmichaud> yes, the refactoring of BEGIN/END/INIT/etc.

[03:46] <pmichaud> I'm seeing lots of errors about not being able to find &done_testing

[03:47] <pmichaud> which would be the case if END blocks aren't lexically nested in their proper scope anymore :-|

[03:47] <jnthn> hmm

[03:47] <jnthn> Yeah, possibly.

[03:47] <jnthn> Well, I'd get the regex fix worried about first. :-)

[03:47] <pmichaud> I'm more likely to suspect the switch to YOU_ARE_HERE in the phasers

[03:47] <jnthn> That's got a tighter ship date.

[03:47] <pmichaud> yes, I'll do regexes first :)

[03:47] <jnthn> Yeah, but you switched that out again, no?

[03:47] <pmichaud> I thought I did.

[03:47] <jnthn> I thought you did. :-)

[03:48] <jnthn> 'cus I was like...all grr about it. :-)

[03:49] <pmichaud> yeah, it looks like the problems began when the phasers implementation changed

[03:49] <pmichaud> and whatever I fixed didn't completely fix it back

[03:50] <pmichaud> (my fixes didn't show up until the 16th; the tests on the 17th 00h00 CDT would be the first with my changes)

[03:50] <pmichaud> anyway, it's pretty clear that END blocks can't use YOU_ARE_HERE as their outer scope.  :-)

[03:51] <jnthn> Yes, true.

[03:51] <jnthn> rakudo: END { say 42 }

[03:51] <p6eval> rakudo f55fb0: OUTPUT«42␤»

[03:51] <pmichaud> rakudo:  sub foo { say 42 };   END { foo; }

[03:51] <p6eval> rakudo f55fb0: OUTPUT«42␤»

[03:51] <pmichaud> hmmmm.

[03:51] <jnthn> rakudo: my $x = 42; END { say $x }

[03:51] <p6eval> rakudo f55fb0: OUTPUT«42␤»

[03:51] <pmichaud> maybe it has something to do with being in Test.pm

[03:52] <jnthn> rakudo: use Test; END { plan 42 }

[03:52] <p6eval> rakudo f55fb0: OUTPUT«1..42␤# Looks like you planned 42 tests, but ran 0␤»

[03:52] <pmichaud> weird.

[03:52] <jnthn> rakudo: use Test; END { done_testin; }

[03:52] <p6eval> rakudo f55fb0: OUTPUT«Could not find sub &done_testin␤current instr.: '_block92' pc 347 (EVAL_8:156) (/tmp/gLye6ASKra:22)␤»

[03:52] <jnthn> hm

[03:52] <jnthn> oh!

[03:52] <jnthn> rakudo: use Test; END { done_testing; }

[03:52] <p6eval> rakudo f55fb0: OUTPUT«1..0␤»

[03:52] <pmichaud> rakudo:  use Test;  ok 1, 'test 1';

[03:52] <jnthn> rakudo: use Test; done_testing;

[03:52] <p6eval> rakudo f55fb0: OUTPUT«ok 1 - test 1␤»

[03:52] <p6eval> rakudo f55fb0: OUTPUT«1..0␤»

[03:53] * sorear back

[03:53] <sorear> pmichaud: So, basically, unbound lists cheat and produce iterators that don't remember values, because if you were going to use them more than once you'd bind them.  Yes?

[03:53] <ingy> sorear: are you going to oscon?

[03:53] <sorear> no

[03:54] <pmichaud> sorear: more precisely, iterators work like cursors

[03:54] <pmichaud> we produce iterators but then throw them away after they're consumed

[03:54] <pmichaud> but if one the things was bound, we end up remembering the chain

[03:54] <pmichaud> (because iterators are conceptually immutable)

[03:55] <pmichaud> this is also a case where 0..10000 may end up being more efficient than  0, *+1 ... 10000

[03:55] <sorear> So there isn't actually special handling of binding - it just works out that an unbound list has its head forgotten.

[03:56] <pmichaud> the sequence operator may result in remembering all of the reified values (because of the handle to the original List for the series), whereas RangeIter can produce an Iterator and immediately forget it

[03:56] <pmichaud> er, Range can produce a RangeIter and immediately forget it

[03:57] <sorear> and .lines lists are Something Completely Different?

[03:57] <pmichaud> well, in Rakudo we end up implementing that with gather/take anyway

[03:57] <pmichaud> and it just seems to dtrt so far.

[03:58] * sorear conceptually imagines that -all- iterators are made with gather/take

[03:58] <pmichaud> it's very likely that rakudo's implementation needs more tweaking, but I'm fairly certain the underlying design is the right one.

[03:58] <pmichaud> I've looked at that, but I think doing everything with gather/take ends up being a bit inefficient, and may lead to the "remember all values" problem you've observed here.

[03:58] <pmichaud> I could be wrong in that opinion, however.

[03:59] <pmichaud> anyway, rakudo makes heavy use of gather/take, yes.

[04:00] <sorear> gather/take has controlled the design of niecza from day 1

[04:00] <sorear> global CPS :(

[04:01] <pmichaud> anyway, having written and re-written lists, arrays, and flattening about five times over in the course of Rakudo and Perl 6, I know there are far more wrong ways to do it than there are right ones.  :-)

[04:02] <pmichaud> (most of the rewrites are due to spec changes prompted by the previous rewrite :-)

[04:02] <pmichaud> s/most/all/   # actually

[04:03] *** cogno joined
[04:04] <pmichaud> jnthn: I think there may have been a server or communications error when running the tests after 07-16, so I'm trying to re-run them now

[04:04] <pmichaud> (that's a good background task, so I'll see if anything comes up as a result)

[04:04] <pmichaud> anyway, afk for now

[04:04] <jnthn> OK.

[04:05] * jnthn is around unless/until he decides he needs a nap.

[04:09] <tylercurtis> rakudo: use MONKEY_TYPING; augment class Mu { method pretty { self.perl } }; (1..5).pretty.print # Ah the joys of augment.

[04:09] <p6eval> rakudo f55fb0: OUTPUT«1..5»

[04:11] <jnthn> lol :-)

[04:12] <jnthn> ETOOCUTE

[04:18] <tylercurtis> jnthn: a little. :) On the other hand, I think I am going to start using .pretty if I want to provide both a concise stringification for supplying to automated things and a more convenient to read stringification for display to people.

[04:18] *** TiMBuS joined
[04:19] <jnthn> :-)

[04:25] *** tedv left
[04:27] *** justatheory joined
[04:40] <sorear> rakudo: my $x = (0, 1, *+* ... *); say $x.WHAT

[04:40] <p6eval> rakudo f55fb0: OUTPUT«List()␤»

[04:41] <sorear> pmichaud: It seems as though List, Parcel, Seq, and Array have a great deal in common, only differing in mutability and whether they flatten insides.  Is this correct?

[04:42] * diakopter throws a dart on the yes board

[04:43] <sorear> Should I give them a common superclass or anything like that?

[04:47] *** TiMBuS left
[04:48] *** cognomore joined
[04:49] <tylercurtis> rakudo: my @a = 4, 5, 6; @a.unshift(1, 2, 3); say @a;

[04:49] <p6eval> rakudo f55fb0: OUTPUT«123456␤»

[05:08] *** TiMBuS joined
[05:08] *** justatheory left
[05:23] *** Sarten-X left
[05:29] *** snarkyboojum joined
[05:48] *** snarkyboojum left
[05:48] *** au|zzz is now known as au|irc

[06:02] *** Sarten-X joined
[06:08] *** uniejo joined
[06:08] *** tylercurtis left
[06:24] <moritz_> std: for 0 { when ARRAY {} }

[06:24] <p6eval> std 31756: OUTPUT«[31m===[0mSORRY![31m===[0m␤Function 'ARRAY' needs parens to avoid gobbling block at /tmp/0sk3dEL_aB line 1:␤------> [32mfor 0 { when ARRAY[33m⏏[31m {} }[0m␤Missing block (apparently gobbled by 'ARRAY') at /tmp/0sk3dEL_aB line 1:␤------> [32mfor 0 { when ARRAY

[06:24] <p6eval> ..{}[33m⏏[31m…

[06:31] <sorear> rakudo: say Iterator ~~ Iterable

[06:31] <p6eval> rakudo f55fb0: OUTPUT«1␤»

[06:31] <sorear> rakudo: say Iterator.^methods(:local).Str

[06:31] <p6eval> rakudo f55fb0: OUTPUT«infinite list␤»

[06:31] <sorear> haha.

[06:31] <sorear> rakudo: say Iterator.^parents.Str

[06:32] <p6eval> rakudo f55fb0: OUTPUT«Iterable() Cool() Any() Mu()␤»

[06:32] <sorear> rakudo: say Iterable.^methods(:local).Str

[06:32] <p6eval> rakudo f55fb0: OUTPUT«item Num elems fmt Str Int list␤»

[06:32] <sorear> rakudo: say Iterable.^attributes(:local).Str

[06:32] <p6eval> rakudo f55fb0: OUTPUT«␤»

[06:32] <sorear> rakudo: say Iterator.^attributes(:local).Str

[06:32] <p6eval> rakudo f55fb0: OUTPUT«␤»

[06:33] <sorear> rakudo: say Seq.^parents.Str

[06:33] <p6eval> rakudo f55fb0: OUTPUT«List() Iterable() Cool() Any() Mu()␤»

[06:33] <sorear> rakudo: say Array.^parents.Str

[06:33] <p6eval> rakudo f55fb0: OUTPUT«List() Iterable() Cool() Any() Mu()␤»

[06:33] <sorear> rakudo: say Parcel.^parents.Str

[06:33] <p6eval> rakudo f55fb0: OUTPUT«Iterable() Cool() Any() Mu()␤»

[06:48] <moritz_> that's a whole new interpretation of "use the source, Luke" :-)

[06:49] <moritz_> rakudo: say 'abc'.split(/b/).[0].trans('a' => 'b')

[06:49] <p6eval> rakudo f55fb0:  ( no output )

[06:49] <moritz_> rakudo: say 'a'.trans('a' => 'b')

[06:49] <p6eval> rakudo f55fb0: OUTPUT«b␤»

[06:56] <moritz_> jnthn: http://rt.perl.org/rt3/Ticket/Display.html?id=76140 produces a clean spectest run, and generally seems to work nicely

[07:06] *** pmurias joined
[07:09] *** meppl joined
[07:13] *** PZt left
[07:13] <sorear> moritz_: well I figure if I do it here pmichaud can leap out of the shadows and go "oh, that's wrong, don't copy that"

[07:14] <moritz_> :-)

[07:14] <sorear> (because, as we all know, pmichaud never sleeps)

[07:15] <moritz_> a bit like au|irc :-)

[07:16] <au|irc> :) I do keep a very regular sleeping pattern now... 9pm~7am CST

[07:16] * au|irc is, in many aspects, re-formed

[07:17] <sorear> My sleeping pattern would be very regular if I lived in Melbourne

[07:17] <moritz_> :-)

[07:17] *** tomaw left
[07:18] * au|irc is working on translating the single most difficult-to-translate paragraph in masak++'s post

[07:18] *** plobsing left
[07:18] <au|irc> ("How is mug re-formed?" / They need to do way instain Jon Orwant. / Who harms 5 mugs that cannot frigth back! / My pary are with the cleaner.)

[07:19] *** pmurias left
[07:21] *** tomaw joined
[07:22] *** eternaleye left
[07:23] <au|irc> ...whew, done. the subsequent ones look so much easier by comparison :)

[07:25] <sorear> for the record not all english natives get how is mug re-formed

[07:25] *** daxim joined
[07:25] *** Mowah joined
[07:26] <daxim> decided to put #perl6 into autojoin after masak's latest blag

[07:26] *** baest joined
[07:27] <sorear> daxim: Hello!

[07:27] <daxim> 'lo

[07:27] *** pmurias joined
[07:27] * sorear is less than twice as old as Perl 6 D:

[07:28] <au|irc> sorear: *nod* but it wouldn't be as fun if the translation doesn't carry over all the dadais subtext :)

[07:28] <au|irc> *dadaist

[07:28] * sorear is in the set :(

[07:30] * mathw waves hello to daxim

[07:30] <phenny> mathw: 18 Jul 21:35Z <masak> tell mathw that ufo is now fixed. thank you for reporting. mathw++

[07:30] <mathw> phenny: tell masak Excellent news. Now can you fix my freezer, and nested modules?

[07:30] <phenny> mathw: I'll pass that on when masak is around.

[07:32] * mathw waves hello to everyone else, too

[07:40] *** gfx joined
[07:49] * pmurias uploaded mildew and smop to CPAN

[07:49] <dalek> niecza: c607ffc | autrijus++ | setting:

[07:49] <dalek> niecza: * setting: Make "&say" return True.

[07:49] <dalek> niecza: review: http://github.com/sorear/niecza/commit/c607ffc33da2046207e3af309c1a99db35819b58

[07:50] <szabgab> good localtime

[07:50] <au|irc> greetings szabgab.

[07:51] <szabgab> is there any wayin the REPL to run an external perl6 ?  something better than        run 'perl6 name.p6'   ?

[07:51] <szabgab> so I won't have to also type perl6 there?

[07:51] <szabgab> and not setting the sh-bang either

[07:52] <moritz_> rakudo: say $*EXECUTABLE_NAME

[07:52] <p6eval> rakudo f55fb0: OUTPUT«../p/bin/perl6␤»

[07:52] <moritz_> rakudo: say $*PROGRAM_NAME

[07:52] <p6eval> rakudo f55fb0: OUTPUT«/tmp/6Mf98f6zMa␤»

[07:52] <moritz_> (will be useless on the REPL)

[07:52] <au|irc> eval slurp("name.p6")

[07:52] <moritz_> au|irc: but that's in the context of the current REPL, not separate

[07:53] <au|irc> ah. indeed

[07:53] <pmurias> szabgab: why is perl6 name.p6 bad?

[07:54] <szabgab> pmurias: just too much typing :)

[07:54] <szabgab> but I see it is still the shortest

[07:55] <pmurias> szabgab: you could have a p6 shell alias

[07:55] <pmurias> so it would be p6 name.p6

[07:55] <sorear> woah!

[07:56] <sorear> autrijus++ blindingly fast learner

[07:56] <au|irc> thank you, though I have no idea why dalek reports my id as autrijus.

[07:56] <au|irc> seeing how my github id is audreyt :)

[07:56] <au|irc> I don't mind either way though, seeing my nickname is now a common prefix of the two...

[07:56] <pmurias> why is your irc nick au|irc?

[07:56] <szabgab> oh au|irc that's you :)

[07:56] <moritz_> au|irc: dalek uses parrot's CREDITS file to map email addresses to nicks

[07:57] <au|irc> ahh.

[07:57] * au|irc searchs for a parrot commit bit password

[07:57] <au|irc> moritz_: or maybe just change that to "au" for me, thx, seeing you probably have a commit bit :)

[07:57] <moritz_> au|irc: will do

[07:58] <szabgab> au|irc: I was wondering if au|irc is an Australian IRC junction or what

[07:58] <au|irc> I'd be /nick au if not a certain Samuel Paragreen took that name :)

[07:58] *** cogno left
[07:58] <moritz_> au|irc: since parrot has moved to a trac based svn authentication, you probably don't have a commit bit, unless you took care to get one

[07:58] <au|irc> moritz_: ah. I don't, then.

[07:59] <au|irc> sorear: so, statement_prefix__S_do. is that simply a (prog ...)esque chain in Niecza::Actions?

[08:00] <au|irc> sorear: my motivation being I'd like (in the repl) turn any expression into "say do { ... } "

[08:00] <au|irc> bringing it on par with rakudo and pugs's repl

[08:00] *** mberends joined
[08:01] <moritz_> rakudo's repl checks tell(STDOUT) before and after a REPL line, and only prints if it stays the same

[08:01] <au|irc> nice! 

[08:01] <au|irc> that's handy as it keeps the lexical environment around

[08:02] <au|irc> would be cool to add that to niecza too...

[08:02] <sorear> statement_prefix__S_do can probably actually just be a no-op

[08:02] *** pmurias_ joined
[08:02] <sorear> the (prog)ish generation is already handled in statementlist

[08:02] *** pmurias left
[08:03] <sorear> keeping the lexical environment around - yes, it would be awesome, but it also seems very hard to do before the bootstrap ;)

[08:03] *** pmurias_ is now known as pmurias

[08:03] <pmurias> is any one brave enough to try cpanm Mildew-Setting-SMOP?

[08:03] <pmurias> * anyone

[08:04] <moritz_> it probably takes a few hours before it propagates to my CPAN mirror

[08:05] <au|irc> # cpanm http://pause.cpan.org/incoming/Mildew-Setting-SMOP-0.01.tar.gz

[08:05] <au|irc> needs a prereq at # cpanm http://pause.cpan.org/incoming/Mildew-0.02.tar.gz

[08:07] *** tadzik joined
[08:08] *** mberends left
[08:08] <pmurias> au|irc: thanks a typo in dist.ini

[08:08] *** jferrero joined
[08:09] <au|irc> np... wouldn't it be nice if cpanm has -j.

[08:09] <au|irc> cannot open unicode maps from ./lib . : No such file or directory

[08:09] <au|irc> BEGIN failed--compilation aborted at /home/au/perl5/perlbrew/perls/perl-5.13.2/lib/site_perl/5.13.2/CursorBase.pm line 1881.

[08:09] <sorear> au|irc: there's a bit of a subtlety you missed.  Internally I'm still using a stack machine to evaluate CgOp nodes, and it's currently the user's responsibility to keep track of whether a CgOp pushes 1 or 0 itmes

[08:09] <sorear> a Q:CgOp (since it's a term) needs to push 1 item

[08:09] <sorear> which is why I sometimes use (prog XXX (null Variable))

[08:10] <au|irc> ah ok

[08:10] <pmurias> au|irc: when does that error happen?

[08:11] <au|irc> sorear: the (null Variable) was preventing "say say 1" to run.. so iiuc you're saying that line can be removed

[08:11] <au|irc> so simply a rawscall following by (box Bool (bool 1)) ?

[08:11] <au|irc> pmurias: in Build.PL time... tracking

[08:12] <moritz_> pmurias: I get that error when I run 'make' in src/perl6/

[08:12] <moritz_> locally, with a perl 5.10.0

[08:12] <sorear> au|irc: yes.

[08:13] <sorear> once packages are working it can just be ) }; Bool::True }

[08:13] <au|irc> yup

[08:13] <pmurias> if a release is unauthorized will cpanm install it?

[08:14] *** sorear sets mode: +opmris au|irc

[08:14] *** ChanServ sets mode: -s
 
[08:14] <dalek> niecza: 009a2f2 | autrijus++ | setting:

[08:14] <dalek> niecza: * Since we return Bool::True already, there is no need to interleave a (null 

[08:14] <dalek> niecza: Variable).

[08:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/009a2f2bd12eb1f51b457a9a0bc8ce5c40095ae1

[08:14] <au|irc> pmurias: it did install STD-0.01 just fine

[08:14] <au|irc> it seems it's not finding the sharedir'd uniprops

[08:15] <au|irc> maybe you're looking for dist_dir('Perl6-STD')

[08:15] <au|irc> and the distname is 'STD'?

[08:15] <au|irc> (that's in CursorBase.pm)

[08:15] *** sorear sets mode: -pmri
 
[08:15] *** pmurias left
[08:15] *** FardadJalili joined
[08:16] <BinGOs> >:)

[08:16] *** pmurias joined
[08:16] <pmurias> au|irc: thanks

[08:16] <pmurias> that's the bug

[08:16] <au|irc> pmurias: yup. and then mangle.pl

[08:16] *** sorear sets mode: +o pmurias

[08:16] <au|irc> it's in lib, but as a .pl, so it wasn't installed by M::B

[08:16] *** zulon joined
[08:17] <au|irc> maybe inline it somehow? (not sure)

[08:17] <pmurias> changing mangle.pl to Mangle.pm would work

[08:17] <moritz_> or encapsulate into a .pm?

[08:17] <moritz_> right

[08:17] <au|irc> yea

[08:18] <pmurias> au|irc: 5.13.2 is installed from the git repo

[08:18] <pmurias> ?

[08:19] <au|irc> from cpan, I think

[08:19] <au|irc> via perlbrew

[08:19] *** dalek left
[08:19] *** dalek joined
[08:19] <sorear> with luck, this will make dalek pick up on au

[08:20] *** sorear sets mode: +v dalek

[08:20] <au|irc> whee

[08:20] <pmurias> works

[08:20] <au|irc> cuul. then there's NULL.lex

[08:20] <pmurias> sorear: is the current STD working?

[08:20] <pmurias> the one in src/perl6

[08:20] <sorear> yes

[08:21] <pmurias> make fails when trying to comple stage1 here

[08:23] <pmurias> sorear: still the same error with git clean -f -d

[08:24] <au|irc> pmurias: a simple solution in Build.PL of STD

[08:24] <au|irc>   'pm_files' => {map { $_ => $_ } <lib/*> },

[08:24] <au|irc> put it in the m_b_ args and it'll install the .lex and .pl into require() path

[08:24] <moritz_> pmurias: after git clean -xdf the first make failed, the second time I ran make I got much further (and still running)

[08:24] <sorear> pmurias: that's easy, it's not even in git

[08:25] <pmurias> sorear: it is

[08:25] <moritz_> seems to have compiled successfully

[08:25] <pmurias> i use git-svn

[08:28] <au|irc> pmurias: Mildew/Backend/C/So.pm said "Can't locate SMOP.pm" - another missing dep?

[08:28] <pmurias> http://pastie.org/1050089 the errors from STD i get

[08:29] <pmurias> au|irc: yes

[08:29] <au|irc> k, will wait till another round of Build.PL pm_files fix and SMOP.pm depfix and retest then :)

[08:30] *** FardadJalili left
[08:31] <pmurias> the dependency is already fixed in the repo, but i have to figure out why STD doesn't build before releasing a new set of packages

[08:31] <sorear> Is $!foo and @!foo the same thing in different contexts?

[08:31] <pmurias> yes

[08:33] *** dakkar joined
[08:34] <pmurias> moritz_: so you don't get any errors when running make in HEAD in src/perl6?

[08:34] <moritz_> pmurias: I didn't get any errors the second time I ran make

[08:35] <pmurias> viv works?

[08:35] * pmurias checks with a fresh perl

[08:39] *** xabbu42 joined
[08:39] *** PZt joined
[08:43] <dalek> niecza: 4393c69 | au++ | Niecza/Actions.pm:

[08:43] <dalek> niecza: * Implement "do" as a no-op.

[08:43] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4393c69653cdfef8aa10695f87858158f93157af

[08:43] <dalek> niecza: e0fe1c3 | au++ | niecza_eval:

[08:43] <dalek> niecza: * Make the niecza_eval REPL a calculator by wrapping "say do {...}" around each 

[08:43] <dalek> niecza: line. :-)

[08:43] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e0fe1c3a5beec1368384766fe6bdc7e4543e2dc1

[08:45] <cxreg> au|irc: "au" pronounced "gold", I presume? :)

[08:46] <au|irc> cxreg: you can say so :)

[08:46] <au|irc> sorear: so by "no-op" I assumed something like " $M->{_ast} = $M->{blast}{_ast}{do} ", but that seems to discard the lexenv

[08:47] <sorear> oh. right. the lexenv.

[08:47] <sorear> look at circumfix__S_Cur_Ly

[08:47] <sorear> bare blocks, do, not too different

[08:47] <au|irc> yup

[08:48] <au|irc> and since {} is optional after do iirc (unlike perl5) I'll drop it from repl for now

[08:48] <mathw> "au" is also the Lojban attitudinal indicator for 'desire'

[08:49] <au|irc> that's a good association too...

[08:49] <sorear> would you be offended if I just kept thinking "Audrey"

[08:50] <dalek> niecza: 40c53d0 | au++ | niecza_eval:

[08:50] <dalek> niecza: * Drop the bare-{} form after "do" for repl so we don't create an extra lexenv.

[08:50] <dalek> niecza: review: http://github.com/sorear/niecza/commit/40c53d0a2176234d45132379bfc2e1f8617ae8e5

[08:50] <au|irc> sorear: it's considerably difficult for me to be offended :)

[08:50] <au|irc> "australia" would be fine too

[08:52] <au|irc> (and audrey is my legal name on passport, fwiw. I just wanted a shorter nickname than _why. *smile*)

[08:53] <sorear> "legal name on passport" != "name which is, under any circumstances, at all acceptable to use"

[08:54] <sorear> well

[08:55] <au|irc> let's just say I typecasted into Whatever :)

[08:55] <sorear> I guess it depends on how old the passport is

[08:55] <au|irc> it's new as of, like, a couple months ago.

[08:55] <sorear> a lot of trans people I know are very touchy on the subject of old records

[08:55] <au|irc> yeah. I worked with monomorphic restriction for a year or so too

[08:56] <dalek> niecza: 1070301 | au++ | niecza_eval:

[08:56] <dalek> niecza: * Do not evaluate comments and blank lines in repl.

[08:56] <dalek> niecza: review: http://github.com/sorear/niecza/commit/10703016d1e1928bf6636a847fb0b1ff13340053

[08:56] <dalek> niecza: 0924b28 | sorear++ | setting:

[08:56] <dalek> niecza: Start sketching out List implementation

[08:56] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0924b28efb67c5562cd2ee632664fb3c1258c486

[08:56] <dalek> niecza: 5ea3202 | sorear++ |  (2 files):

[08:56] <dalek> niecza: Implement $!foo syntax

[08:56] <dalek> niecza: review: http://github.com/sorear/niecza/commit/5ea3202ccb94a5b10604091b4c002afa82f9f183

[08:56] <sorear> hey, it worked

[08:56] <au|irc> :D

[08:57] <cxreg> you guys are going to surpass rakudo at this rate :D

[08:58] <au|irc> just to set expectations, I was taking a short break from day job because my MacBookPro's disk failed :)

[08:58] <au|irc> so in all likelyhood I'll be back dayjobbing in a couple days

[08:58] <sorear> well, I was the one who added lexicals to the rakudo repl in the first place...

[08:59] *** xinming left
[08:59] <sorear> For a long time I thought lurking in #perl6 *was* TimToady's dayjob

[08:59] <au|irc> lol

[09:08] <dalek> niecza: c4f132b | au++ | Niecza/Actions.pm:

[09:08] <dalek> niecza: * Correctly handle lexicals in do {...} syntax.

[09:08] <dalek> niecza: review: http://github.com/sorear/niecza/commit/c4f132b1998778a5b24d404f3ae2998c341350c4

[09:08] *** gfx left
[09:12] * au|irc dives back to translation, since an anniversary post missed by a day wouldn't be very anniversary...

[09:12] *** user_4923 joined
[09:12] *** au|irc is now known as au|dive

[09:12] *** user_4923 left
[09:14] <szabgab> could somone with enough powers update http://www.rakudo.org/community   and add a linkto http://webchat.freenode.net/?channels=perl6   for those who don'tyet use IRC?

[09:26] <sorear> wait, wait, what

[09:26] <sorear>  + c4f132b...9fe76f1 master -> master (forced update)

[09:26] <sorear> I DID NOT USE -f

[09:26] <dalek> niecza: 9fe76f1 | sorear++ |  (4 files):

[09:26] <dalek> niecza: Implement macros && || // andthen and orelse or.  Special block behavior of 

[09:26] <dalek> niecza: andthen/orelse NYI.

[09:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9fe76f199a38dea8ba33acb2097e0333f6d9b9ff

[09:27] <sorear> au|dive: ?

[09:27] <au|dive> no idea what happend

[09:27] *** au|dive is now known as au|irc

[09:28] <au|irc> probably you had an alias to push -f or something...

[09:28] <sorear> yep, au's latest commit no longer exists

[09:28] <au|irc> it's ok, I gcp'ed it back

[09:28] <au|irc> alias gcp='git cherry-pick -x'

[09:28] <au|irc> # handy

[09:29] <au|irc> alias gpu='git pull --rebase && git push' # also hady

[09:29] <au|irc> *handy

[09:31] <sorear> doesn't seem to be anything force-related in ~/.gitcofnig or .git/config

[09:32] <dalek> niecza: d9a9c18 | au++ | Niecza/Actions.pm:

[09:32] <dalek> niecza: * Correctly handle lexicals in do {...} syntax.

[09:32] <dalek> niecza: (cherry picked from commit c4f132b1998778a5b24d404f3ae2998c341350c4)

[09:32] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d9a9c18f5f668544527252dd27e22a7b4a29e497

[09:35] *** zulon left
[09:35] <pmichaud> au|irc: It's very nice to see you here again.  :-)

[09:36] <au|irc> pmichaud: heya. *hugs* :)

[09:37] <pmichaud> *hugs*

[09:38] <dalek> niecza: 886a992 | sorear++ | test.pl:

[09:38] <dalek> niecza: tests for au++ 's do hacking

[09:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/886a992077afd152d598faea6f6300cc2f403d9a

[09:38] <dalek> nqp-rx: 7b1280f | pmichaud++ | src/ (3 files):

[09:38] <dalek> nqp-rx: Add backtrack indicators to Cursor, Regex "pass" nodes.

[09:38] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/7b1280f9bed6aec230d334fcf5dd2d317a4ce732

[09:38] <dalek> nqp-rx: eb16d23 | pmichaud++ | src/ (2 files):

[09:38] <dalek> nqp-rx: Initial version of backtracking.  Adds Cursor.next and helper methods to restart 

[09:38] <dalek> nqp-rx: match from a given Cursor.

[09:38] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/eb16d23de5e2e44ac619da611d710bcca656d450

[09:38] <dalek> nqp-rx: b796e3d | pmichaud++ | src/Regex/Cursor.pir:

[09:38] <dalek> nqp-rx: Be more robust about backtracking into failed/nonbacktracking cursors.

[09:38] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/b796e3d7dab74cee608e3e3e571f9f773b1088ab

[09:38] <dalek> nqp-rx: a1c5ce3 | pmichaud++ | src/ (2 files):

[09:39] <dalek> nqp-rx: Add backtracking into subrule code.  Split !cursor_next from Cursor.next .

[09:39] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/a1c5ce3baead01a2d53fce9d5c887c84f6e49ad7

[09:39] <dalek> nqp-rx: c2c2fbe | pmichaud++ | src/PAST/Compiler-Regex.pir:

[09:39] <dalek> nqp-rx: Eliminate (unsaved) uniquereg used for markers in greedy/ratchet quantifier.

[09:39] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/c2c2fbe25a48b8b3fb25bddf378fb391c4954d9b

[09:39] <dalek> nqp-rx: 7b0bf98 | pmichaud++ | src/PAST/Compiler-Regex.pir:

[09:39] <dalek> nqp-rx: Make sure uniquereg for frugal quantifiers is reset properly if re-entering 

[09:39] <dalek> nqp-rx: subroutine.

[09:39] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/7b0bf98e14aeeb50c76e0274ffc93b380e77b7dd

[09:39] <dalek> nqp-rx: cf03cdb | pmichaud++ | build/PARROT_REVISION:

[09:39] <dalek> nqp-rx: Bump PARROT_REVISION.

[09:39] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/cf03cdb70126451407e4af201fd095c5556f2399

[09:39] <dalek> nqp-rx: 6aedfc2 | pmichaud++ | src/stage0/ (4 files):

[09:39] <dalek> nqp-rx: Update bootstrap.

[09:39] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/6aedfc201c03ad4f547732298c940ce2822aa669

[09:40] <dalek> rakudo: 9005478 | pmichaud++ | build/PARROT_REVISION:

[09:40] <dalek> rakudo: Bump PARROT_REVISION to get regex backtracking fixes from nqp-rx.  Fixes RT 

[09:40] <dalek> rakudo: #73608.

[09:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9005478267083d6a04e31a93a2dcffc2acea22cb

[09:43] <pmichaud> that's probably enough for one evening.. time for sleep :-)

[09:43] <moritz_> \o/

[09:43] <moritz_> pmichaud++

[09:43] <moritz_> good night

[09:43] <moritz_> rakudo: use Test;  grammar A { token hi { hi } };  ok   A.parse( 'hi',

[09:43] <p6eval> rakudo f55fb0: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[09:43] <moritz_> rakudo: use Test;  grammar A { token hi { hi } };  ok   A.parse( 'hi', :rule<hi>) eq 'hi',  "Grammar.parse: :rule<somerule>"

[09:43] <p6eval> rakudo f55fb0: OUTPUT«ok 1 - Grammar.parse: :rule<somerule>␤»

[09:44] <au|irc> g'♘ pmichaud++ :)

[09:45] *** envi^home joined
[09:49] <cxreg> sorear: if you prefix a refspec with + in git, it means the same as push -f.  maybe you did that?

[09:54] *** zulon joined
[09:54] <sorear> cxreg: I did "git push".  Perhaps I set up autotargetting wrong.

[09:58] <sorear> push = +refs/heads/*:refs/heads/*

[10:01] *** xinming joined
[10:03] *** Meldrake joined
[10:04] <dalek> niecza: c54ea1e | sorear++ | CodeGen.pm:

[10:04] <dalek> niecza: More robust handling of types

[10:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/c54ea1ef51119d16b46ef826b99ff10c804c3d3e

[10:04] <dalek> niecza: fcee377 | sorear++ | setting:

[10:04] <dalek> niecza: Flesh out LLArray more

[10:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/fcee3770cf38e045f4e4b2af8c875c9ddabde9fa

[10:10] *** timbunce joined
[10:13] *** i__ joined
[10:13] *** Mowah left
[10:15] *** zulon left
[10:15] *** timbunce left
[10:22] <cognominal> thx, moritz++ for the feedback on the use of  C<ok> in Test.

[10:24] <moritz_> you're welcome

[10:24] *** au|irc is now known as au|afk|dinner

[10:24] <moritz_> cognominal: did you add the test to any spectest files yet?

[10:24] *** Leonidas joined
[10:24] <cognominal> nope

[10:25] *** pmurias left
[10:28] *** synth joined
[10:30] <moritz_> btw I've just fixed the master branch of proto to work with current rakudo

[10:30] <moritz_> if you find any new breakages, please let me know

[10:33] <sorear> I thought proto was abandoned?

[10:33] <moritz_> well, it's abandoned as long as nobody works on it

[10:33] <moritz_> but until pls is declared the successor officially, I'm inclined to keep proto working

[10:34] <daxim> is there a factbot here?

[10:34] <moritz_> don't know, at least not a spammy one :-)

[10:37] *** Sarten-X left
[10:41] *** pmurias joined
[10:45] <sorear> what.

[10:45] <sorear> how did this work on the first try.

[10:46] <dalek> niecza: 325388d | sorear++ | setting:

[10:46] <dalek> niecza: Implement List.elems, List.Bool, List.shift

[10:46] <dalek> niecza: review: http://github.com/sorear/niecza/commit/325388d4fa4e91734280e6dd87bc9ec824a0318d

[10:46] <dalek> niecza: 4ad1567 | sorear++ | Kernel.cs:

[10:46] <dalek> niecza: No need to coerce on list binding after all

[10:46] <sorear> lists in niecza just got their first user-facing manifestation

[10:46] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4ad1567d7de4e29740a4a9b87fe87cd9c5dbb957

[10:46] <dalek> niecza: fe2b2ab | sorear++ |  (6 files):

[10:46] <dalek> niecza: Implement slurpy parameters

[10:46] <dalek> niecza: review: http://github.com/sorear/niecza/commit/fe2b2ab55bba12ae9e9c66cb629696adc6b60763

[10:47] <sorear> can't say my @x *just* yet

[10:48] * sorear -> sleep

[11:03] *** Whoop joined
[11:03] <jnthn> moritz_: In the Nested * patch, pir::exists($last, 'returns') is my main object to it. Should be more like pir::defined($last.returns)

[11:04] <jnthn> moritz_: Other than that, I was fairly happy with the patch before, and just hadn't gotten around to rebasing. 

[11:05] <jnthn> With the tweak I mentioned above and if it passes the tests and seems to work, +1 to apply.

[11:05] <jnthn> also, pmichaud++ # backtracking fixes! :-)

[11:06] *** azert0x joined
[11:06] *** agentzh left
[11:15] *** Whoop left
[11:17] *** TimToady joined
[11:23] <colomon> jnthn: any fixes to operators in modules over the weekend?

[11:24] *** cognomore left
[11:27] *** cognomore joined
[11:29] <moritz_> btw masak++'s excellent blog post is still around top 20 on hackernws, and #6 on reddit/programming

[11:29] <daxim> wow

[11:30] <jnthn> colomon: 'fraid not

[11:30] <colomon> :(

[11:30] <jnthn> colomon: Is there a ticket?

[11:30] <colomon> not one made by me....

[11:33] <moritz_> rakudo: say $*VM<config><version>

[11:33] <p6eval> rakudo 900547: OUTPUT«Any()␤»

[11:33] <moritz_> rakudo: say $*VM<config><VERSION>

[11:33] <p6eval> rakudo 900547: OUTPUT«2.5.0␤»

[11:34] *** zulon joined
[11:36] *** snarkyboojum joined
[11:38] *** clintongormley joined
[11:43] <dalek> rakudo: 8d8114f | moritz++ | src/Perl6/Compiler.pir:

[11:43] <dalek> rakudo: print parrot version in --version output, and athe revision only if != 0

[11:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8d8114fa7bec532798da7004b864e349e437d874

[11:48] *** zulon left
[11:49] *** zulon joined
[11:51] *** krakan joined
[11:52] <moritz_> jnthn: thanks. I've changed the exists to defined, and now I'm spectesting a last time before pushin

[11:52] <moritz_> g

[11:54] <jnthn> moritz_++

[11:54] <jnthn> mmcleric++

[11:54] <moritz_> mmcleric++

[11:54] <moritz_> maybe I should add him to CREDITS too

[11:54] <jnthn> Yes, pzhlst. :-)

[11:58] <sorear> can't sleep.  niecza calls.

[11:59] <tadzik> rakudo: my junction $x = 3 | 5; my $a = 3; say 'ok' if $a == $x

[11:59] <tadzik> shouldn't that work?

[11:59] <p6eval> rakudo 900547: OUTPUT«===SORRY!===␤Malformed my at line 22, near "junction $"␤»

[11:59] *** sorear sets mode: +o TimToady

[11:59] <jnthn> tadzik: Junction

[12:00] <tadzik> moritz_: you have a typo in your Perl 5 to 6 then

[12:00] <tadzik> jnthn: thank you

[12:00] <moritz_> tadzik: ah, the spec called it 'junction' at some point, I should udpate it

[12:00] <sorear> rakudo: class Foo { }; say Foo.new ~~ Foo.new;

[12:00] <p6eval> rakudo 900547: OUTPUT«0␤»

[12:00] <jnthn> Well, there was a pondering at one point that it should be a lowercase type, but thankfully it never caught on.

[12:02] <tadzik> rakudo: say 'ok' if [1, 2, 3] == all(3, 2, 1) # what's wrong here?

[12:02] <p6eval> rakudo 900547:  ( no output )

[12:02] <moritz_> tadzik: == does numeric comparison

[12:02] <tadzik> eq then?

[12:02] <moritz_> tadzik: and an array in numeric context evalutes to the number of arguments

[12:03] <moritz_> and 3 == all(1, 2, 3) is False

[12:03] <tadzik> ah. How should it be, then?

[12:03] <moritz_> what do you want to achieve?

[12:03] <tadzik> find the use for all

[12:04] <moritz_> grep *>2 & *<10, @list;

[12:04] *** skids joined
[12:04] <moritz_> grep /president/&/Obama/, @people;

[12:04] <jnthn> tadzik: if all(@test-scores) > 60 { say "Everybody passed!" } # for example

[12:04] <tadzik> I see

[12:06] <TiMBuS> moritz_, would that not pull two values from @list at a time?

[12:06] <sorear> We have a Type type!?  S03:3543

[12:06] <moritz_> TiMBuS: no, it's a single test

[12:06] <moritz_> sorear: just because it's in S03 doesn't mean it's a good idea :-)

[12:07] <snarkyboojum> rakudo: say "yep" if all(1,2,3) == any(1,2,3,4,5)

[12:07] <p6eval> rakudo 900547: OUTPUT«yep␤»

[12:07] <moritz_> sorear: I guess it should be Any:U  or Any:U where { .WHAT === $_ }

[12:07] <sorear> moritz_: I am very, very conflicted on whether Foo isa Foo or Foo isa Class is better

[12:09] *** Sarten-X joined
[12:09] <jnthn> Oh, the infamous Class type. :-)

[12:09] <sorear> based on my current reading of that table, I'd say that 3 ~~ Int is false

[12:09] <jnthn> Well, best way to check if what you have is a class is probably what moritz++ wrote and if you want to be really sure then add .HOW ~~ ClassHOW

[12:09] <sorear> which is totally awesome

[12:10] <jnthn> sorear: er

[12:10] <jnthn> sorear: Maybe read it differently. ;-)

[12:10] *** masonkramer joined
[12:10] <moritz_> sorear: I guess that 'Type' in that sense is a bit meta. You can't define smart-matching semantics through smart-matching, after all :-)

[12:10] <sorear> jnthn: if Type is a subset of Any, then it is less specific than a subclass of Any

[12:11] <sorear> jnthn: so the Numeric rule takes precedence

[12:11] <moritz_> (should be Mu probably, not Any, sorry for that)

[12:11] <jnthn> sorear: Type is probably being used in a meta-y sense here.

[12:12] <sorear> jnthn: how meta-y?

[12:12] <jnthn> std: Type

[12:12] <p6eval> std 31766: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤ 'Type' used at line 1␤Check failed␤FAILED 00:01 114m␤»

[12:12] <jnthn> That meta-y.

[12:14] <sorear> rakudo: say "foo" ~~ Str

[12:14] <p6eval> rakudo 900547: OUTPUT«1␤»

[12:14] <sorear> rakudo: say Str.ACCEPTS("foo")

[12:14] <p6eval> rakudo 900547: OUTPUT«1␤»

[12:15] <sorear> How is that implemented?

[12:15] <sorear> I'm looking at Str.pir +28

[12:15] <moritz_> sorear: it's probably implemented in PCT somwhere

[12:16] <moritz_> sorear: parrot r47873 touches that code, it seems

[12:16] <jnthn> sorear: The type-object in Rakudo ATM is the object + a mix-in that provides an ACCEPTS method that does an isa check.

[12:17] <jnthn> But it should probably really work by Mu having a proto method ACCEPTS and a ACCEPTS(Mu:U $inv:) candidate, and all other ACCEPTS methods being only :D

[12:17] <jnthn> (the :D there is syntax, not smiley)

[12:19] <jnthn> Of course, they all gotta be multi ACCEPTS then

[12:19] <jnthn> *multi method ACCEPTS

[12:19] <moritz_> jnthn: I don't think so, otherwise user-defined ACCEPTS methods are too fragile

[12:19] <jnthn> Which raises the slight issue of needing to multi-dispatch to type check, but multi-dispatch needs to go by type, so...

[12:19] <jnthn> moritz_: Well, thus the "should method invocants default to :D" discussions that occasionally come up.

[12:20] <mathw> What does :D mean?

[12:20] <jnthn> The object must be happy

[12:20] <daxim> grin

[12:20] <jnthn> er, defined

[12:20] <moritz_> Int:D are all the defined integers

[12:20] <sorear> I think that I'll just put a .defined check into infix:<~~>

[12:20] <moritz_> so the Int type object doesn't match Int:D

[12:20] <moritz_> sorear: I think that's a reasonable first approximation

[12:21] * sorear is extremely uncomfortable with type objects.  Also loves them.

[12:21] <jnthn> moritz_: But anyway, yes, it's fragile in that sense.

[12:21] <jnthn> I'm currently quite undecided if when I re-do the Rakudo meta-model I try to drop the "type object = object + mixin" thing or not.

[12:22] <sorear> jnthn: for the record, I'm planning to *add* that when I re-do the niecza meta-model

[12:22] <mathw> Oh nifty

[12:22] <mathw> Didn't know about that

[12:22] <moritz_> mathw: it's NYI in rakudo, so I regularly forget about it

[12:23] <mathw> I think I must've missed that part of the spec

[12:23] <sorear> jnthn: method foo() { $!x } # If the type object is a separate true-type, then it's possible to generate two versions of this method, neither of which has to make a definedness test

[12:23] <mathw> which is not surprising, I've missed lots of it

[12:23] <jnthn> sorear: Another implementation declaring it a sane approach besides Rakudo would go a long way to making it a viable way forward.

[12:23] <mathw> I should print it out and read it at bedtime...

[12:25] <sorear> mathw: AIUI, there's a standing contract with O'Reilly and S** is the drafts of what will become Programming Perl (6)

[12:26] <moritz_> sorear: not quite

[12:27] <mathw> there is a contract for that book, but S** is not the draft form

[12:27] <mathw> as I understand it

[12:27] <moritz_> sorear: the S** numbers are take from the chapter numbers of Programming Perl, but they are under the AL2

[12:27] <mathw> S** would make a pretty dull book anyway

[12:27] <mathw> they're not really written the right way

[12:28] <moritz_> mathw: the 'Using Perl 6' book will not published by O'Reilly, fwiw

[12:28] <mathw> moritz_: I know that

[12:28] <moritz_> but Onyx Neon Press

[12:28] <mathw> I thought there was a 'Programming Perl 6' one with O'Reilly

[12:29] <moritz_> there was talk about it; but I don't think it shares code with S\d\d

[12:30] *** salv0 joined
[12:30] <cognominal>   my @a = [1]; my @b ::= @a;  @b[0]=4;   @a[0] = 'z' ; say @b.perl  # jnthn, I would like an operator that bind @b to the container originally bound to @a.  := has a different semantic

[12:30] <cognominal> rakudo:  my @a = [1]; my @b ::= @a;  @b[0]=4;   @a[0] = 'z' ; say @b.perl 

[12:30] <p6eval> rakudo 900547: OUTPUT«["z"]␤»

[12:30] <mathw> no, I don't think any book does, S** would make a terrible book

[12:30] <mathw> But I should still read them anyway

[12:31] <cognominal> I would like rakudo to output  [4] here

[12:31] <moritz_> then use =

[12:31] <moritz_> rakudo:  my @a = [1]; my @b ::= @a;  @b[0]=4;   @a[0] = 'z'

[12:32] <p6eval> rakudo 900547:  ( no output )

[12:32] <moritz_> rakudo:  my @a = [1]; my @b = @a;  @b[0]=4;   @a[0] = 'z'; say @b.perl

[12:32] <p6eval> rakudo 900547: OUTPUT«[4]␤»

[12:32] <cognominal> by = does a copy

[12:33] <cognominal> *but

[12:33] <moritz_> if you want maintain two separate containers, you have to copy

[12:33] <cognominal> I just want to bind to the original array

[12:33] <moritz_> that's what you do :-)

[12:33] <salv0> rakudo: my Int @a = 5; say @a[0]

[12:33] <p6eval> rakudo 900547: OUTPUT«maximum recursion depth exceeded␤  in 'at_pos' at line 1␤  in 'at_pos' at line 7:CORE.setting␤  in 'Any::postcircumfix:<[ ]>' at line 1624:CORE.setting␤  in 'at_pos' at line 5:CORE.setting␤  in 'at_pos' at line 7:CORE.setting␤  in 'Any::postcircumfix:<[ ]>' at line

[12:33] <p6eval> ..1624:CORE.settin…

[12:33] <moritz_> that's bad.

[12:34] <tadzik> that's weird

[12:34] <salv0> yes, should typed arrays be already working?

[12:34] <tadzik> but works for me, in REPL

[12:35] <cognominal> rakudo:  my (@a, @b);   @a = [ 1];  @b = @a;  say @b.WHERE, @a.WHERE

[12:35] <p6eval> rakudo 900547: OUTPUT«140127680140128064␤»

[12:35] <tadzik> and even not in repl

[12:35] <cognominal> rakudo:  my (@a, @b);   @a = [ 1];  @b = @a;  say @b.WHERE, " ", @a.WHERE

[12:35] <p6eval> rakudo 900547: OUTPUT«140589488 140589872␤»

[12:35] <sorear> didn't I explain this yesterday?

[12:35] <moritz_> salv0: yes, at least the basics

[12:35] <jnthn> Huh...I thought that worked... :/

[12:36] <moritz_> @a = [1]; generates a nested array

[12:36] <moritz_> jnthn: works here too

[12:36] <sorear> std: False ~~ True

[12:36] <p6eval> std 31766: OUTPUT«Potential difficulties:␤  Smartmatch against True always matches; if you mean to test the topic for␤    truthiness, please use :so or *.so or ?* instead at /tmp/4qYrtEObcI line 1:␤------> [32mFalse ~~ True[33m⏏[31m<EOL>[0m␤ok 00:01 116m␤»

[12:36] <sorear> std: ok False ~~ True

[12:36] <p6eval> std 31766: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'ok' used at line 1␤Potential difficulties:␤  Smartmatch against True always matches; if you mean to test the topic for␤    truthiness, please use :so or *.so or ?* instead at /tmp/QDxoxyyxFa line 1:␤------> [32mok False ~~

[12:36] <p6eval> ..True…

[12:37] <sorear> oh

[12:37] <cognominal> do you understand, the need for the operator I am talking about?

[12:37] <sorear> bad error message

[12:37] <moritz_> cognominal: no

[12:38] <sorear> cognominal: As I have explained several times, the operator you are talking about is spelled ':=' and NYI in rakudo

[12:38] <sorear> NYCI

[12:38] <sorear> You don't need to ask us to add it.

[12:38] <sorear> We're already failing spectests for it.

[12:40] <cognominal> I think there are two different operators, making two variable name synonymous, which the current behavior of :=  et what I ask for. I am not sure what the spec says.

[12:40] <cognominal> s/et/and/

[12:40] <cognominal> acking to see the spectests...

[12:47] *** masonkramer left
[12:48] <dalek> niecza: 84a4c6b | sorear++ |  (2 files):

[12:48] <dalek> niecza: Fix Sub.HOW.  Implement smart matching.

[12:48] <dalek> niecza: review: http://github.com/sorear/niecza/commit/84a4c6bdace6c1830b48e77ec57b7319e3ff3b56

[12:57] *** bluescreen joined
[12:58] *** bluescreen is now known as Guest21067

[12:58] *** kidd joined
[12:58] *** kidd is now known as rgrau_

[13:03] *** jferrero left
[13:08] *** Guest21067 left
[13:08] *** Guest21067 joined
[13:13] *** au|afk|dinner is now known as au|zzz

[13:14] *** Guest21067 left
[13:15] <tadzik> can someone show me an example of dying with something more sophisticated than a string? $_.WHAT in CATCH is Exception(), but what special features does it have?

[13:16] <moritz_> rakudo: try { die { a=> 1, b => 2 } }; say $!<a>

[13:16] <p6eval> rakudo 8d8114:  ( no output )

[13:16] <moritz_> huh

[13:18] *** slavik joined
[13:20] *** takadonet joined
[13:20] <takadonet> morning all

[13:21] <moritz_> hi takadonet 

[13:21] <takadonet> moritz_: how are u?

[13:22] <moritz_> rakudo: try { die { a=> 1, b => 2 } }; say $!.payload.<a>

[13:22] <p6eval> rakudo 8d8114: OUTPUT«Null PMC access in can()␤  in main program body at line 1␤»

[13:22] <moritz_> takadonet: fine, thank you

[13:22] <snarkyboojum> rakudo: try { die; CATCH {foo} } # core dump here

[13:22] * mathw smells a NYI

[13:22] <moritz_> what about yourself?

[13:22] <p6eval> rakudo 8d8114:  ( no output )

[13:22] <takadonet> busy as hell but good

[13:24] *** pmurias left
[13:28] *** Trashlord left
[13:29] *** tadzik left
[13:31] *** Guest21067 joined
[13:31] *** Trashlord joined
[13:36] *** Guest21067 left
[13:43] *** tadzik joined
[13:43] *** zulon left
[13:45] <tadzik> so what about this exceptions, NYI?

[13:45] <moritz_> mostly NYI

[13:49] *** felliott left
[13:51] *** uniejo left
[13:52] *** JimmyZ joined
[13:53] *** macroron joined
[13:54] *** Guest21067 joined
[13:56] *** pmurias joined
[13:56] *** snarkyboojum left
[13:56] *** tylercurtis joined
[13:57] *** perlygatekeeper joined
[14:01] <pmichaud> good morning, #perl6

[14:01] <moritz_> good morning pmichaud, saviour of the regex engine :-)

[14:01] <moritz_> now mathw++ doesn't have an excuse for slacking on Form.pm development :-)

[14:02] <pmichaud> I'm still curious to know if it really works in general.  :-)

[14:02] <moritz_> an advent calendar test passed

[14:02] <pmichaud> not nearly enough tests for backtracking into subrules and subpatterns :-)

[14:02] <mathw> Yes I do

[14:02] <mathw> nested modules are broken!

[14:02] <pmichaud> oh!  advent calendar test passing is good for me.

[14:02] <moritz_> mathw: but workaroundable

[14:02] *** plainhao joined
[14:02] <mathw> but I can fix the parse tree construction

[14:02] <tadzik> will #31 come before Rakudo Star?

[14:02] <mathw> moritz_: yes, because I like restructuring my modules, oh yes. Oh very yes.

[14:03] <pmichaud> #31 is Thursday.

[14:03] <mathw> I think I'm going to strip it back a bit and start with something smaller

[14:03] <pmichaud> Rakudo Star is a week from Thursday.

[14:03] <pmichaud> (so yes)

[14:03] <tadzik> yeah, but it will happen, right? :)

[14:03] <mathw> the sheer quantity of errors is quite depressing

[14:03] <moritz_> tadzik: Rakudo Star will use the #31 compiler release

[14:03] <tadzik> oh, ok

[14:03] <moritz_> (afaict)

[14:03] <pmichaud> (yes)

[14:03] <tadzik> so this week will be polishing blizkost, zawolaj, proto and stuff?

[14:03] <pmichaud> tadzik: generally, yes.

[14:04] <moritz_> speaking of which... has anybody tested blizkost recently?

[14:06] <pmichaud> ooooh, perl6 screencast!

[14:06] <pmichaud> http://szabgab.com/blog/2010/07/1279584453.html

[14:06] <pmichaud> szabgab++

[14:07] <tadzik> hah. I love it how now, when I want a calculator, launch `perl6` instead of `python` or `irb`

[14:07] <tadzik> the little things that make you happy

[14:07] <jnthn> pmichaud: Oh, Thursday's compiler release becomes R*? :S

[14:07] *** alester joined
[14:07] <[Coke]> WHAT?

[14:07] <[Coke]> (EVER)

[14:07] <jnthn> pmichaud: As in, the compiler that goes into R*

[14:08] * jnthn had expected we'd have time for last fixes in the week between the two...

[14:08] <pmichaud> jnthn: we might.

[14:09] <pmichaud> I'd prefer that we use a released compiler for R*, but if there's a really important fix we can perhaps change that.

[14:10] <jnthn> Not sure why using a released compiler matters, tbh. In many ways, it's just what was in master on the right date of the month, plus some attempt to make sure we've no failing tests. :-)

[14:10] <jnthn> Anyway, we'll see.

[14:10] <pmichaud> ...because I expect distributions to generally build from compiler releases (and not necessarily the most recent one)

[14:10] * [Coke] is wishing he did not accidentally volunteer to do both releases this week.

[14:11] <pmichaud> [Coke]: we can probably find another release manager for rakudo if you want.

[14:11] <[Coke]> I'll be fine. =-)

[14:11] <pmichaud> okay. (and yes, you will.  rakudo releases are Easy)

[14:11] <jnthn> pmichaud: Well, yes, there is that case of setting precedent.

[14:12] <pmichaud> jnthn: like you, I'm more interested in higher quality release than precedent.

[14:12] <jnthn> pmichaud: Aye, this time around I think that's more the focus.

[14:12] <pmichaud> but I had been hoping to use the released compiler, and spend the week polishing the other pieces

[14:12] <jnthn> pmichaud: *nod*

[14:12] <jnthn> pmichaud: I just rather suspect that in polishing the other pieces we'll find we need to tweak soemthing in Rakudo.

[14:13] <daxim> pugs: class Pony { has @.fur is ro = <soft freckled>; has $name is rw; } my Pony $jifty = Pony.new(:name<Jifty>); say $jifty.fur; say $jifty.perl;

[14:13] <p6eval> pugs: OUTPUT«softfreckled␤\Pony.new(("fur" => ["soft", "freckled"]), ("name" => "Jifty"))␤»

[14:13] <pmichaud> jnthn: aye to that.

[14:13] <jnthn> pmichaud: I'd be happy to be proved wrong, but I'm not quite optimistic enough ;-)

[14:13] <daxim> when is it okay to leave out the twigils in the class definition?

[14:13] <tylercurtis> daxim: when it's a private attribute, iirc.

[14:13] <jnthn> daxim: has $foo is like has $!foo with $foo just being an alias to $!foo

[14:14] <jnthn> daxim: In a sense, $!foo serves as nice documentation and lets things line up more neatly when there's other $.foo decls (which also get an accessor method generated)

[14:14] <daxim> define alias in this context

[14:14] <jnthn> The compiler says "oh, I see $foo" and re-writes it as $!foo

[14:14] <daxim> okay

[14:14] <moritz_> two names for the same thing

[14:14] <jnthn> (within the class body)

[14:14] <dalek> rakudo: 40c6ec7 | (Вячеслав Матюхин)++ | src/Perl6/Actions.pm:

[14:14] <dalek> rakudo: Implement nested Whatever-currying

[14:14] <dalek> rakudo: chaned pir::exist to defined, to not rely on the underlying data structure too

[14:14] <dalek> rakudo: much (suggested by jnthn++, conducted by moritz).

[14:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/40c6ec787b8fcd54a9e59ad09a1ad00536b4557a

[14:14] <dalek> rakudo: cf5f19a | moritz++ | CREDITS:

[14:14] *** dalek left
[14:15] *** dalek joined
[14:15] <jnthn> Self-exterminated!

[14:15] <jnthn> mmcleric++ \o/

[14:15] <moritz_> indeed

[14:15] <moritz_> mmcleric++

[14:16] <jnthn> moritz_: There's probably some tickets we can close thanks to that. :-)

[14:16] <jnthn> moritz_: And no doubt tests to unfudge. :-)

[14:16] <moritz_> autounfudge finds quite a few things that work now and haven't worked before

[14:17] <moritz_> we need more mad hackers :-)

[14:18] <jnthn> We should have a Rakudo hackathon at YAPC::Russia next year. :-)

[14:19] <moritz_> yes, please do :-)

[14:20] <pmichaud> Pm's "challenge of the week"

[14:20] <pmichaud> http://github.com/pmichaud/io-prompter

[14:20] <pmichaud> (1)  make sure it works with Rakudo master

[14:20] <pmichaud> (2)  make it into a real proto/pls module

[14:20] <pmichaud> (neither of these may be a real challenge :-)

[14:21] *** baest left
[14:22] <jnthn> omg damian code!

[14:22] * jnthn drops what he's working on

[14:22] <cognominal> rakudo:  * = *

[14:22] <pmichaud> scary: http://github.com/pmichaud/io-prompter/blob/master/demo_IO_Prompter_promptloop.p6

[14:22] <p6eval> rakudo 8d8114:  ( no output )

[14:22] *** justatheory joined
[14:22] <moritz_> uhm, all these 'of Bool' declarations look scary

[14:22] <pmichaud> scarier: http://github.com/pmichaud/io-prompter/blob/master/demo_IO_Prompter_promptloop_type_constraint.p6

[14:23] <moritz_> is there any reason not to use Bool $thing?

[14:23] <jnthn> pmichaud: heh "ould probably replace this with 'does'ing an anonymous role]." ==> they weren't implemented back then. They Are Now.

[14:24] <pmichaud> jnthn: yes

[14:24] <pmichaud> moritz_: I'm guessing Damian preferred the "of Bool" form for some reason.

[14:26] <jnthn> heh, you know some code is awesome when you see "gather for &block.signature.params -> $param {" :-)

[14:26] <pmichaud> you know Rakudo is awesome when that Actually Works.  :-)

[14:26] <jnthn> ;-)

[14:26] <pmichaud> forks, pull requests welcomed.

[14:27] <moritz_> indeed. You should all write some Perl 6 modules at some point

[14:27] *** tadzik left
[14:27] <moritz_> just to get the user's perspective from time to time, first hand

[14:28] *** justatheory left
[14:29] <jnthn> moritz_: I did.

[14:29] <jnthn> moritz_: I pushed to it only 2 days ago, even. ;-)

[14:30] <jnthn> Trouble is, now I've written one, I want to write more. :-)

[14:30] <jnthn> "trouble" :-)

[14:30] <moritz_> OH NOEZ

[14:31] * pmichaud suspects he should probably pack for his trip to PDX sometime soon.

[14:34] *** i__ left
[14:35] <moritz_> rakudo: class A { has $.b = my $foo = 42; method x { say $foo } } A.new.x

[14:35] <p6eval> rakudo 8d8114: OUTPUT«===SORRY!===␤Confused at line 22, near "class A { "␤»

[14:35] <moritz_> rakudo: class A { has $.b = my $foo = 42; method x { say $foo } }; A.new.x

[14:35] <p6eval> rakudo 8d8114: OUTPUT«42␤»

[14:36] <moritz_> used to be RT #73368

[14:36] *** JimmyZ left
[14:36] <jnthn> moritz_: oh nice

[14:36] <jnthn> moritz_: I fixed a related bug recently

[14:36] *** zulon joined
[14:36] <jnthn> I bet the fix dealt with this issue too

[14:36] <jnthn> Bonus win.

[14:37] <tylercurtis> rakudo: class A { has $.b = my $foo = 42; method x { say $foo } }; A.new.x; A.new.b.say;

[14:37] * colomon must not allow himself to be distracted by Damian code.

[14:37] <p6eval> rakudo 8d8114: OUTPUT«42␤42␤»

[14:37] <tylercurtis> rakudo: class A { has $.b = my $foo = 42; method x { say $foo } };  my A $a .=new; $a.x; $a.b.say; $a.b = 5; a.x; $a.b.say

[14:37] <p6eval> rakudo 8d8114: OUTPUT«42␤42␤Cannot modify readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/tNlFIp32vX␤»

[14:38] <moritz_> jnthn: there's a windows-related skip in S16-filehandles/unlink.t (search for WINDOWS in captial letters) - could you please check if that's still required?

[14:38] <tylercurtis> rakudo: class A { has $.b is rw = my $foo = 42; method x { say $foo } };  my A $a .=new; $a.x; $a.b.say; $a.b = 5; a.x; $a.b.say

[14:38] <p6eval> rakudo 8d8114: OUTPUT«42␤42␤Could not find sub &a␤  in main program body at line 22:/tmp/6hjSjgzxLS␤»

[14:38] <tylercurtis> rakudo: class A { has $.b is rw = my $foo = 42; method x { say $foo } };  my A $a .=new; $a.x; $a.b.say; $a.b = 5; $a.x; $a.b.say

[14:38] <jnthn> moritz_: Can do - just need to deal with about 5 other things going on at once here first. :-)

[14:38] <p6eval> rakudo 8d8114: OUTPUT«42␤42␤42␤5␤»

[14:38] <moritz_> jnthn: sure, no hurry

[14:39] <moritz_> jnthn: if the test passes, just remove the skip - it passes on linux too

[14:45] <moritz_> pmichaud: some new unfudges in S05-mass/recursive.t... should be enough test coverage to close the backtracking ticket

[14:46] <pmichaud> moritz_: +1!

[14:49] <moritz_> closed.

[14:50] <moritz_> feather3 is down, which is why we don't get any notification from pugs_svn

[14:50] <moritz_> (as announced by Juerd++)

[14:53] <pmichaud> afk for a bit # packing

[15:01] <cono> rakudo: class AD { method a { say "Hello" }; }; class BD { has AD $.Y is rw; }; my BD $x = .new; $x.Y.a

[15:01] <p6eval> rakudo cf5f19: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/vbHiiznDlc␤»

[15:02] <cono> rakudo: class AD { method a { say "Hello" }; }; class BD { has AD $.Y is rw; }; my BD $x .= new; $x.Y.a

[15:02] <p6eval> rakudo cf5f19: OUTPUT«Method 'a' not found for invocant of class ''␤  in main program body at line 22:/tmp/Va23iGJD5T␤»

[15:03] <cono> rakudo: class AD { method a { say "Hello" }; }; class BD { has AD $.Y is rw; }; my BD $x .= new; $x.Y .= new; $x.Y.a

[15:03] <moritz_> rakudo: class AD { method a { say "Hello" }; }; class BD { has AD $.Y = AD.new }; BD.new.Y.y

[15:03] <p6eval> rakudo cf5f19: OUTPUT«Method 'a' not found for invocant of class 'Any'␤  in main program body at line 22:/tmp/asnu_UXDnp␤»

[15:03] <p6eval> rakudo cf5f19: OUTPUT«Method 'y' not found for invocant of class 'AD'␤  in main program body at line 22:/tmp/zC_T7IE5fg␤»

[15:03] <cono> why Any ?

[15:04] <jnthn> rakudo: class A { has Int $.x }; say A.new.x

[15:05] *** snarkyboojum joined
[15:05] <p6eval> rakudo cf5f19: OUTPUT«Any()␤»

[15:05] <moritz_> typed attributes NYI/broken

[15:05] <jnthn> cono: Because I never finished the patch I started writing in Kiev. :-(

[15:05] <cono> :/

[15:05] <jnthn> I think I did all the refactors leading up this this.

[15:05] <jnthn> And just never quite finished it. D'oh.

[15:06] *** [particle] left
[15:07] *** [particle] joined
[15:07] <cono> ok, try another way :)

[15:09] *** pmurias left
[15:13] *** masak joined
[15:13] <masak> oh hai, #perl6!

[15:13] <phenny> masak: 07:30Z <mathw> tell masak Excellent news. Now can you fix my freezer, and nested modules?

[15:13] <colomon> o/

[15:13] <moritz_> oh hai masak

[15:13] <masak> hugme: hug mathw :)

[15:13] * hugme hugs mathw

[15:13] <moritz_> masak: backtracking into captures is waiting for you to break it :-)

[15:14] <tylercurtis> moritz_: what are you working on today? Want to help me finish updating Squaak? :)

[15:14] <masak> moritz_: oh wow!

[15:14] <tylercurtis> Hi, masak.

[15:14] <masak> 106 comments on Reddit and 45 comments on HN! \o/

[15:14] <masak> tylercurtis: greetings.

[15:14] <moritz_> tylercurtis: mostly $work stuff, and tonight I have a .pm meeting, so I fear I won't be of much help :(

[15:15] <tylercurtis> moritz_: alright. I'll try to drag someone else into it, then. :)

[15:16] *** [particle] left
[15:16] *** justatheory joined
[15:18] *** justatheory left
[15:19] * [Coke] wonders why moritz bothers arguing with trolls.

[15:19] <[Coke]> (reading a perlmonks thread.)

[15:19] <cono> rakudo: class A {method h {say "hai"}}; class B {has $.type is rw; method new { $.type = A.new }}; my B $x .= new

[15:20] <p6eval> rakudo cf5f19: OUTPUT«Type objects are abstract and have no attributes, but you tried to access $!type␤  in 'B::new' at line 70␤  in main program body at line 22:/tmp/_VCJaDDiIs␤»

[15:20] *** [particle] joined
[15:20] <szabgab> rakudo: my @x = <a b "c d">; say @x.perl

[15:20] <p6eval> rakudo cf5f19: OUTPUT«["a", "b", "\"c", "d\""]␤»

[15:21] <szabgab> rakudo: my @x = <a b "c d">; say @x.elems

[15:21] <cono> Why object is abstract?

[15:21] <p6eval> rakudo cf5f19: OUTPUT«4␤»

[15:21] <masak> [Coke]: url?

[15:21] <szabgab> shouldn't that be 3 elements?

[15:21] <[Coke]> masak: already closed it.

[15:22] <masak> ok.

[15:22] <[Coke]> I have no idea if it was even a new thread. =-)

[15:22] <moritz_> [Coke]: sometimes I'm not wise enough

[15:22] <masak> trolls are often very good at prompting replies.

[15:22] <moritz_> right; those that aren't good aren't noticed

[15:23] <[Coke]> especially if it's an anonymous troll^Wmonk. Clearly they don't want a /discussion/

[15:23] <[Coke]> but, keep fighting the good fight. maybe it'll work. =-)

[15:23] <moritz_> [Coke]: it's not about convincing the troll. But if anybody who reads along is convinced, it's worth the effort

[15:24] <masak> wow, this is so cool! http://pugs.blogs.com/pugs/2010/07/perl-6-%E5%8D%81%E5%91%A8%E5%B9%B4%E6%85%B6-%E5%89%8D%E8%A8%80-%E4%BA%94%E4%B9%8B%E4%B8%80.html

[15:24] <masak> au|irc++

[15:24] <moritz_> part 1 of 5. wow.

[15:24] <masak> reading traditional characters is tough going...

[15:27] <jnthn> masak: oh wow, the mug puns have got translated! \o/

[15:27] * [Coke] fed that through google translate back into english. was readable. =-)

[15:27] <[particle]> wrestled?

[15:28] <masak> jnthn: 「杯比怎麼昇出來的？」 -- "how is mug re-formed?" :P

[15:28] <pmichaud> is it worth reading the comments in reddit/HN?

[15:28] <masak> pmichaud: they're like most such threads. a couple of gems among a lot of unnecessary meanness.

[15:28] <moritz_> notreally

[15:30] <masak> I don't know why, but I get the feeling that it's mostly Python and Ruby people who write "Perl -- who uses that nowadays?".

[15:30] <jnthn> masak: lol

[15:30] * [Coke] does a search for "perl6" on reddit and finds nothing.

[15:30] <jnthn> Python and Ruby. Who'll use those when Perl 6 is released? ;-)

[15:30] <masak> [Coke]: http://www.reddit.com/r/programming/comments/cqysn/10_years_perl_6_project_history_and_personal/

[15:30] <moritz_> [Coke]: http://www.reddit.com/r/programming/comments/cqysn/10_years_perl_6_project_history_and_personal/

[15:30] <moritz_> :-)

[15:30] <moritz_> I usually spell it 'Perl 6' (with space)

[15:31] <moritz_> except in domain names :-)

[15:31] * [Coke] wonders why that doesn't show up here:

[15:31] <[Coke]> http://www.reddit.com/search?q=perl6&sort=new

[15:31] <[Coke]> ah.

[15:31] <masak> jnthn: I thought Python and Ruby users had already stopped using Python and Ruby, just like all Perl 5 users stopped using Perl 5 when Perl 6 was announced, 10 years ago.

[15:32] <jnthn> masak: Oh yeah, sill me, I forgot.

[15:32] <jnthn> :P

[15:32] * masak thought jnthn didn't like sill

[15:33] <jnthn> EWWWW! :O

[15:33] <jnthn> *silly

[15:33] <masak> :D

[15:34] <masak> "Camelia, the Perl 6 spokesbug, is adorable" -- http://twitter.com/thatmattbone/status/18877789703

[15:34] <masak> love it or hate it. no middle ground.

[15:34] <[Coke]> masak: sure there is. I'm apathetic.

[15:35] <[particle]> you're old, your opinions don't matter.

[15:35] <[Coke]> perl6.org is blocked by the GE corporate firewall, btw.

[15:35] <masak> that's not a ground, that's lack of ground. :)

[15:35] <masak> [Coke]: as gambling, right?

[15:35] <[Coke]> masak: doesn't tell you.

[15:35] <[particle]> no, wait, maybe it's because you're bald.

[15:35] <[particle]> it's been so long since i've cared, it doesn't matter why they don't matter anymore :P

[15:36] <[Coke]> [particle]: it's a lifestyle choice. don't be a hater.

[15:36] <[Coke]> masak: (and I cannot request an unblock as I iza contractor.)

[15:37] <masak> [Coke]: you'll simply have to do your butterfly watching outside of work. :)

[15:37] <masak> [Coke]: and pray that we don't put anything useful on that site...

[15:38] * moritz_ doesn't plan to

[15:40] *** zulon left
[15:44] *** Mowah joined
[15:50] *** dolmen__ joined
[15:50] <masak> "Marc Andreessen will tell you with a straight face that he expects Mosaic Communications's Mosaic to become the world's standard interface to electronic information." -- wow that is the best quote I've read in a long time. it's from http://www.wired.com/wired/archive/2.10/mosaic.html

[15:50] <dolmen__> rakudo: for 1,2,3 -> $x { $x.say }

[15:50] <p6eval> rakudo cf5f19: OUTPUT«1␤2␤3␤»

[15:51] <dolmen__> rakudo: for 1,2,3 -> $x { LAST { $x.say } }

[15:51] <p6eval> rakudo cf5f19: OUTPUT«Could not find sub &LAST␤  in main program body at line 22:/tmp/nXF_RJ5Zy4␤»

[15:51] <masak> dolmen__: NYI

[15:51] <masak> dolmen__: but it would print "3\n", yes.

[15:51] <dolmen__> masak: just read your blog post

[15:51] <masak> :_

[15:51] <masak> :)

[15:52] <dolmen__> rakudo: for 1,2,3 -> $x { LAST { $x.say } $x++; LAST { $x.say }  }

[15:52] <p6eval> rakudo cf5f19: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[15:52] <masak> still NYI :)

[15:52] <dolmen__> rakudo: for 1,2,3 -> $x { LAST { $x.say }; $x++; LAST { $x.say }  }

[15:52] <p6eval> rakudo cf5f19: OUTPUT«Could not find sub &LAST␤  in main program body at line 22:/tmp/T9wWvclljm␤»

[15:52] <masak> and you always need ; after } in a one-liner.

[15:53] <moritz_> or phrased differently, you always need ;, only after }\n it's not necesasry

[15:53] <dolmen__> are multiple LAST phasers allowed?

[15:53] <moritz_> I think so

[15:53] <masak> they are.

[15:53] <masak> they execute in order.

[15:54] <masak> may sound silly to allow them, until you start thinking of macros.

[15:54] <moritz_> if I have   my $x = ( 3; LAST { 4 } }.(), what's $x?

[15:54] <pmichaud> (Mosaic becomes world's standard interface)   I suspect that quote was the equivalent of painting a big red-and-white-striped target on his butt and waving it in Microsoft's face saying "nyeah nyeah nyeah".

[15:54] <masak> moritz_: 3, I'd say.

[15:55] <dolmen__> @moritz: LAST is only allowed in a loop, isn't it?

[15:55] <masak> dolmen__: I was thinking the same.

[15:55] <moritz_> dolmen__: modulo that :-)

[15:55] <moritz_> my $x = do for 1 { 3; LAST { 4 } };

[15:55] <masak> dolmen__: but he's actually not making a new block here, so it could be in a loop :)

[15:55] <masak> moritz_: hm.

[15:55] <dolmen__> moritz: s/LAST/LEAVE/ and your code will be valid

[15:55] <colomon> rakudo: for 1...5 { FIRST { say "hello"; }; say $_; };

[15:56] <masak> I think it's valid as it is.

[15:56] <p6eval> rakudo cf5f19: OUTPUT«Could not find sub &FIRST␤  in main program body at line 22:/tmp/vBhQxUv0mN␤»

[15:56] <masak> heh, more people expecting Rakudo to have FIRST/LAST... :P

[15:56] <masak> stay tuned for the next release of Yapsi! \o/

[15:56] <pmichaud> +1 to adding "nyi" messages to FIRST/LAST/NEXT in rakudo.  :-)

[15:57] <pmichaud> (which I'll do a bit later after I'm done packing and other trip-arranging sorts of things)

[15:57] <dolmen__> masak: no, more people reading about LAST/FIRST because a guy is advertising about it

[15:57] <colomon> masak: I was just hoping it got implemented while I wasn't looking.

[15:57] <[Coke]> colomon;you can close your eyes when you type "git push". that'll count.

[15:58] <colomon> [Coke]: if I had an idea how to implement it, it would have been done months ago.  there are plenty of core methods where FIRST would come in handy...

[15:58] <pmichaud> colomon: oh, why didn't you say so?  ;-)

[15:59] * masak has an idea how to implement it

[15:59] <pmichaud> I know how to implement it also.  :-)

[15:59] <jnthn> If I drink some beer I can maybe work one out too. :-)

[15:59] <dolmen__> LAST is the hard one

[15:59] *** cono left
[15:59] *** cono joined
[15:59] <colomon> pmichaud: because there are still plenty of Rakudo problems that cannot be worked around with two extra lines of code.  :)

[16:00] <mathw> pmichaud++

[16:00] <pmichaud> anyway, I hope to convert 'for' to 'map' in the next couple of days (i.e., tomorrow), so I can probably do FIRST as part of that.

[16:00] <colomon> damn.  now that I think about it, maybe I actually have a notion how to implement it too.  colomon--

[16:00] <masak> moritz_: now I think it's 4. :)

[16:00] <mathw> Form now passes all of its 01 test file, which was all failing due to the parse backtracking

[16:00] <masak> mathw: \o/

[16:00] <masak> pmichaud++

[16:00] <pmichaud> mathw: \o/

[16:01] <pmichaud> I can only say that getting backtracking to work was about exactly as difficult as I had expected it to be.  

[16:01] <mathw> now I have to get around RT#74426

[16:01] <pmichaud> which is much different from most of the other things I've worked on the past couple of months :-|

[16:01] <moritz_> pmichaud: http://nopaste.snit.ch/22120 like that?

[16:01] <szabgab> rakudo my @x = 1..Inf; say @x.elems

[16:01] <pmichaud> moritz_: +1

[16:01] <szabgab> rakudo: my @x = 1..Inf; say @x.elems

[16:01] <p6eval> rakudo cf5f19: OUTPUT«Inf␤»

[16:01] <szabgab> rakudo++

[16:02] <pmichaud> :-)

[16:02] <szabgab> rakudo: my @x = 1..^Inf; say @x.elems

[16:02] <p6eval> rakudo cf5f19: OUTPUT«Inf␤»

[16:02] <szabgab> ;)

[16:02] <masak> rakudo: my @x = 1..Inf, 1..Inf; say @x.elems

[16:02] <p6eval> rakudo cf5f19: OUTPUT«Inf␤»

[16:02] <masak> \o/

[16:02] <moritz_> rakudo++ does correct math with some cardinal numbers :-)

[16:03] <pmichaud> szabgab: outstanding job on the screencast, btw

[16:03] <moritz_> agreed. I liked it.

[16:03] <pmichaud> I'm wanting to do some of my own  (got the camera and microphone for it a couple of weeks ago, but ENOTUITS)

[16:03] <dolmen__> rakudo: (-Inf..Inf).elems.say

[16:03] <mathw> pmichaud: It's always nice to estimate something correctly isn't it. Shame it's so difficult.

[16:03] <p6eval> rakudo cf5f19: OUTPUT«Inf␤»

[16:03] *** rlb3 left
[16:04] <pmichaud> mathw: in some sense I was a little surprised, because I knew there was a chance that backtracking would involve some major rework

[16:04] <dolmen__> rakudo: (-Inf..^-Inf).elems.say

[16:04] <p6eval> rakudo cf5f19: OUTPUT«0␤»

[16:04] <mathw> pmichaud: I'm very glad it didn't

[16:04] <moritz_> pmichaud: bring that microphone to YAPC::EU, maybe we can do some short interviews with all the Rakudo hackers

[16:04] <moritz_> well, all those that will be present

[16:04] <pmichaud> moritz_: it's a little cheapy-lapel style microphone

[16:04] <jnthn> ooh, good idea. :-)

[16:04] <pmichaud> but yes, I can bring a mic to yapc::eu, or arrange to have one present.

[16:04] <pmichaud> (a good mic)

[16:05] <mathw> ooh

[16:05] <dalek> rakudo: 2f4733e | moritz++ | src/Perl6/Grammar.pm:

[16:05] <dalek> rakudo: implement NYI messages for six different phasers

[16:05] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2f4733ea8a42294ed2a23c2e09eb067c0eb2c4ea

[16:05] <mathw> I think I just tried to add something to a Failure

[16:05] <moritz_> ./perl6 -e 'FIRST { say 2 }'

[16:05] <moritz_> ===SORRY!===

[16:05] <moritz_> FIRST phaser not yet implemented at line 1, near ""

[16:05] <masak> the message "Perl 6. 10 years. Rakudo Star. Will it shine or fail?" is being retweeted a lot right now.

[16:06] <moritz_> with appropriate link(s), I hope?

[16:06] <masak> with a link to the anniversary post.

[16:06] <jnthn> rakudo: sub shine { fail }; say shine.WHAT

[16:06] <p6eval> rakudo cf5f19: OUTPUT«Failure()␤»

[16:06] <jnthn> Yes, Rakudo * will fail.

[16:06] <dolmen__> masak++

[16:06] * moritz_ calls it a day

[16:07] <mathw> jnthn++

[16:07] <masak> rakudo: class A { method day { say "OH HAI" } }; class It { method A { A.new } }; It.A.day

[16:07] <p6eval> rakudo cf5f19: OUTPUT«OH HAI␤»

[16:08] <mathw> \o/ t/03-textformatting.t also now passes

[16:08] *** eternaleye joined
[16:08] <PerlJam> masak: the problem with the succeed/fail dichotomy is everyone has different ideas of "success"

[16:09] <mathw> PerlJam: you're absolutely correct

[16:09] <masak> PerlJam: the problem with people who don't care enough is that they don't give you high enough bandwidth to communicate that.

[16:09] <pmichaud> Rakudo Star will have many failures, but I suspect it will succeed at its primary purpose.

[16:10] *** coutume joined
[16:10] <masak> ...widening the user base?

[16:10] <pmichaud> and increasing the bug reports

[16:10] <masak> ...getting more feedback into the system?

[16:10] <pmichaud> getting more feedback, yes.

[16:10] <tylercurtis> Rakudo * is definitely going to be shiny. There's even a star in the name. Whether it succeeds is a different question.

[16:11] <pmichaud> the only way Rakudo Star fails is if Perl 6 becomes a dead language.

[16:11] <dolmen__> pmichaud: +1

[16:11] <masak> pmichaud: I like those odds. :)

[16:12] <[particle]> :=

[16:12] <dolmen__> the world needs Perl 6, it hasn't just realised yet

[16:12] *** ruoso joined
[16:12] <cxreg> the buzz is really growing, i think R* will be significant

[16:13] <mathw> rakudo: say Rat ~~um

[16:13] <mathw> rakudo: say Rat ~~ Num

[16:13] <p6eval> rakudo cf5f19: OUTPUT«Could not find sub &um␤  in main program body at line 22:/tmp/iytRq27TIK␤»

[16:13] <p6eval> rakudo cf5f19: OUTPUT«0␤»

[16:13] <mathw> what's the parent of Num and Rat then? Why isn't Rat a Num?

[16:13] <PerlJam> rakudo: say Num ~~ Rat

[16:13] <tylercurtis> rakudo: say Rat ~~ Real

[16:13] <masak> mathw: so, Num means "real number", more than numeric.

[16:13] <p6eval> rakudo cf5f19: OUTPUT«0␤»

[16:13] <p6eval> rakudo cf5f19: OUTPUT«1␤»

[16:14] <masak> mathw: we, it means "floating-point number", I mean.

[16:14] <masak> s/we/er/

[16:14] * mathw changes the type constraint from Num to Real

[16:14] <jnthn> rakudo: say Int ~~ Num

[16:14] <p6eval> rakudo cf5f19: OUTPUT«1␤»

[16:15] <jnthn> die die die!

[16:15] <tylercurtis> rakudo:  sub Rakudo ($what) { (class { method shine { True; } }).new; }; say Rakudo(*).shine;

[16:15] <mathw> Int isn't a Num?

[16:15] <p6eval> rakudo cf5f19: OUTPUT«1␤»

[16:15] <jnthn> mathw: Not any more

[16:15] <jnthn> It's a Numeric

[16:15] <mathw> oooh

[16:15] <mathw> maybe that's what I want here actually

[16:15] <jnthn> And we go to quite a length to make Int pretend it's a Num.

[16:15] <jnthn> Almost certain it shouldn't be these days though.

[16:15] <tylercurtis> mathw: If you don't want Complexes, you probably want Real.

[16:16] <daxim> news://alt.wesley.die.die.die

[16:16] <mathw> tylercurtis: I'm going to want Complex eventually, but not today...

[16:17] <dolmen__> rakudo: say Num ~~ Numeric

[16:17] <p6eval> rakudo cf5f19: OUTPUT«1␤»

[16:17] <dolmen__> rakudo: say Numeric ~~ Num

[16:17] <p6eval> rakudo cf5f19: OUTPUT«0␤»

[16:18] <dolmen__> so what is Numeric?

[16:18] <jnthn> A role done by all numbery-ish types

[16:18] *** envi^home left
[16:19] <tylercurtis> dolmen__: http://perlcabal.org/syn/S32/Numeric.html#Numeric

[16:19] <dolmen__> tylercurtis: thx

[16:19] *** tadzik joined
[16:22] * masak submits "Int ~~ Num" rakudobug

[16:23] <dolmen__> rakudo: Rat(1, 0.25).denominator.say

[16:23] <p6eval> rakudo cf5f19: OUTPUT«Could not find sub &Rat␤  in main program body at line 22:/tmp/JauyXSMxcI␤»

[16:23] <dolmen__> rakudo: Rat.new(1, 0.25).denominator.say

[16:23] <p6eval> rakudo cf5f19: OUTPUT«too many positional arguments: 3 passed, 1 expected␤  in main program body at line 22:/tmp/sSJOjHu82l␤»

[16:24] <dolmen__> rakudo: Rat.new(1, 2).denominator.say

[16:24] <p6eval> rakudo cf5f19: OUTPUT«2␤»

[16:24] <dolmen__> rakudo: Rat.new(1, 0.75).denominator.say

[16:24] <p6eval> rakudo cf5f19: OUTPUT«too many positional arguments: 3 passed, 1 expected␤  in main program body at line 22:/tmp/IqUaO2xRTI␤»

[16:25] <dolmen__> rakudo: Rat.new(1, Num.new(0.75)).denominator.say

[16:25] <p6eval> rakudo cf5f19: OUTPUT«too many positional arguments: 3 passed, 1 expected␤  in main program body at line 22:/tmp/Y2tJnrrHf9␤»

[16:25] <dolmen__> rakudo: Rat.new(1, 2.5).denominator.say

[16:25] <p6eval> rakudo cf5f19: OUTPUT«too many positional arguments: 3 passed, 1 expected␤  in main program body at line 22:/tmp/1qD2SKcZNL␤»

[16:25] <dolmen__> rakudo: Rat.new(1.5, 2).denominator.say

[16:25] <p6eval> rakudo cf5f19: OUTPUT«too many positional arguments: 3 passed, 1 expected␤  in main program body at line 22:/tmp/JteXcmg2CY␤»

[16:26] *** Mowah left
[16:26] *** sftp left
[16:26] <tylercurtis> looks like Rat needs a "multi method new(Mu $n, Mu $d) { die 'You can't create a Rat with non-Int values, you lunatic!'; }".

[16:27] * mathw pushes some fixes to Form.pm

[16:27] <mathw> needs a module restructure to get the rest working I think

[16:28] <mathw> or a Rakudo fix :)

[16:28] * dolmen__ leaves to go home

[16:28] * dolmen__ is leaving to go home

[16:29] <tylercurtis> masak: want something to work on today?

[16:29] <masak> tylercurtis: Squaak tutorial? :)

[16:29] <tylercurtis> masak: How'd you guess? :P

[16:29] * masak backlogs

[16:30] <pmichaud> .oO(  S26  )

[16:30] <jnthn> masak: How's your work in the Buf going? :-)

[16:30] <masak> tylercurtis: I would, but I have deadlines on my own... I can offer my assistance as far as proofing goes, but I think I need actual tuits for things like enums in Rakudo, the GSoC work, and the book.

[16:30] <masak> tylercurtis: you see, people are already reminding me :P

[16:30] <masak> nom &

[16:31] <jnthn> .oO( Maybe I shoulda phrased it better :P )

[16:31] *** tadzik left
[16:32] <mathw> \o/ Buf

[16:32] <mathw> \o/ Enums

[16:32] *** felliott joined
[16:33] <tylercurtis> masak: alright. :) I'll eventually either finish it up by myself or find someone who's not too busy to drag into it.

[16:33] *** ceco joined
[16:33] <mathw> masak: I did things on form!!

[16:34] *** felliott left
[16:34] *** dolmen__ left
[16:34] *** coutume left
[16:34] <jnthn> mathw++

[16:35] *** ceco left
[16:35] <mathw> it now entirely passes three whole test files!

[16:35] <mathw> I think all the rest are down to the nested module/package/whatever bug

[16:35] <mathw> in that it just can't find stuff

[16:36] <mathw> important stuff like the actions class :)

[16:37] <PerlJam> mathw: Add Form.pm to http://wiki.github.com/rakudo/rakudo/whats-going-into-rakudo   :-)

[16:38] *** zulon joined
[16:38] *** sftp joined
[16:41] <mathw> PerlJam: well I suppose it can go into *, it's got a usable subset of functionality

[16:41] <mathw> needs documentation though

[16:41] * mathw makes a note... write documentation

[16:41] * mathw makes another note... make it work properly in current rakudo and damn the purity of the module structure, can always change it back later

[16:42] *** zulon left
[16:42] <PerlJam> mathw++ 

[16:43] <mathw> ...but not right now

[16:43] <mathw> I want to do it without an aikido class happening in the middle

[16:49] *** tomaw left
[16:50] *** IllvilJa left
[16:52] *** tomaw joined
[16:52] *** molaf joined
[16:52] *** cdarroch joined
[16:52] *** cdarroch left
[16:52] *** cdarroch joined
[16:57] *** HarryS left
[16:58] *** HarryS joined
[16:58] *** HarryS is now known as Guest5115

[16:59] *** donpdonp joined
[17:00] *** dakkar left
[17:01] *** Guest5115 left
[17:06] *** HarryS joined
[17:07] *** daxim left
[17:13] *** snarkyboojum left
[17:14] *** molaf left
[17:19] *** TiMBuS left
[17:24] *** cono left
[17:35] *** cono joined
[17:38] <masak> mathw: kudos!

[17:38] <masak> mathw: yes, make it work in current Rakudo. add '# RAKUDO' comments with RT numbers attached, to remind you to make things better when it's possible.

[17:46] <jnthn> ooh, moritz_ went and put in the ROADMAP a list of our biggest awesomeness lackages with regards to errors. :-)

[17:46] <masak> moritz_++

[17:47] <masak> pmichaud: sorry I've failed to get back to you about S26. attempting to make amends now.

[17:47] <pmichaud> masak: no problem, and no rush.  I won't be able to act on it for a couple of days anyway (and perhaps not until friday afternoon)

[17:47] <masak> nodnod

[17:47] <pmichaud> I just figured that if others were after your tuits I'd get my bid in as well.  :-)

[17:48] <pmichaud> you'll note it took me over a week to get IO::Prompter posted somewhere for people to look at :)

[17:48] <masak> then I'll deprioritize it, and look at book/enums for a while before turning back to GSoC/Buf/IO.

[17:48] <pmichaud> wfm

[17:49] <jnthn> masak: ooh, you're going to enumhack?

[17:49] <masak> best case, yes.

[17:49] <masak> I want them that badly. :)

[17:49] <jnthn> :)

[17:49] <masak> or rather, I consider having more than we currently have important enough for R* to want to hack on it myself.

[17:50] <colomon> rakudo: say (1, 1, * + 2 * * ... 100).perl

[17:50] <p6eval> rakudo 2f4733: OUTPUT«(1, 1, 3, 7, 17, 41, 99)␤»

[17:50] <colomon> \o/

[17:50] <jnthn> colomon: Does that sequence have a name? :-)

[17:50] <colomon> fib-like-series-which-quickly-tests-nested-Whatever-currying?  ;)

[17:51] <jnthn> Oh yeah, I remember that from my school days now. ;-)

[17:52] <colomon> rakudo: say (1, 1, 1, * + * + * ... 100).perl

[17:52] <masak> jnthn: http://www.research.att.com/~njas/sequences/A001333

[17:52] <p6eval> rakudo 2f4733: OUTPUT«(1, 1, 1, 3, 5, 9, 17, 31, 57)␤»

[17:52] <colomon> that's tribonacci according to Wikipedia.

[17:52] <masak> "Numerators of continued fraction convergents to sqrt(2)."

[17:52] *** sundar joined
[17:53] <colomon> masak: crazy!

[17:53] <masak> I love that search engine.

[17:53] <colomon> http://en.wikipedia.org/wiki/Pell_number

[17:54] <colomon> oh, slightly different.

[17:55] <masak> rakudo: class Quill {}; Quill.new; say "alive"

[17:56] <p6eval> rakudo 2f4733: OUTPUT«===SORRY!===␤Confused at line 22, near "Quill.new;"␤»

[17:56] * masak cries softly

[17:56] <frettled> killing me softly with this code

[17:56] <masak> am I to understand that types starting with Q is a post-R* concern?

[17:56] <pmichaud> no

[17:56] <masak> it seems we got all the rest of the alphabet working :P

[17:56] <pmichaud> it's just a bug nobody's fixed yet.

[17:57] <masak> what's the procedure for marking it Pretty Darn Important?

[17:57] <colomon> rakudo: say ((0, 1, * + 2 * * ... *) Z/ (1, 2, * + 2 * * ... *)).munch(10).perl

[17:57] <p6eval> rakudo 2f4733: OUTPUT«(1/1, 1/1, 1/1, 1/1, 1/1, 1/1, 1/1, 1/1, 1/1, 1/1)␤»

[17:57] <colomon> arrrrgh!

[17:58] <masak> The Castle Arggghhhhh?

[17:58] <colomon> I was dictating.

[17:59] <pmichaud> masak: tbh, I don't know why that doesn't parse.

[17:59] <masak> pmichaud: related to Q:PIR et al, no?

[17:59] <masak> pmichaud: http://rt.perl.org/rt3/Ticket/Display.html?id=74338

[17:59] * cxreg writes: use MONKEY_TYPING; augment class Array { method lines { self.join("n") } };

[17:59] <pmichaud> masak: that's what I would normally think, but I don't see it in the grammar

[17:59] <pmichaud> token quote:sym<Q>     { 'Q'   >> <![(]> <.ws> <quote_EXPR> }

[18:00] <pmichaud> the >> would seem to prevent it from being treated as Q

[18:00] <masak> cxreg: a bit confusing, since 'lines' already means, 'all the lines from a file/IO' in Perl 6.

[18:00] <pmichaud> rakudo:   say "Quill" ~~ / 'Q' >> .* /;

[18:00] <p6eval> rakudo 2f4733: OUTPUT«␤»

[18:00] <cxreg> masak: i know, i was thinking the reverse :/

[18:00] <colomon> rakudo: say (1 / 1, 3 / 2, -> $a, $b { ($a.numerator + 2 * $b.numerator) / ($a.denominator + 2 * $b.denominator) } ... *).munch(10).perl

[18:00] <tylercurtis> rakudo: say "a\nb\nc".lines;

[18:01] <p6eval> rakudo 2f4733: OUTPUT«(1/1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378)␤»

[18:01] <p6eval> rakudo 2f4733: OUTPUT«Method 'lines' not found for invocant of class 'Str'␤  in main program body at line 22:/tmp/rCRu0RfXjx␤»

[18:01] <colomon> rakudo: say 3363/2378

[18:01] <p6eval> rakudo 2f4733: OUTPUT«1.41421362489487␤»

[18:01] <masak> tylercurtis: you want .comb(/\N/)

[18:01] <masak> er, .comb(/\N+/)

[18:01] <colomon> I thought lines had been re-defined to work on strings?

[18:02] <masak> rakudo: say "a\nb\nc".comb(/\N+/).perl

[18:02] <p6eval> rakudo 2f4733: OUTPUT«("a", "b", "c")␤»

[18:02] <colomon> rakudo: say sqrt(2)

[18:02] <masak> colomon: oh, that sounds familiar. I won't say more then until I've re-checked the spec.

[18:02] <p6eval> rakudo 2f4733: OUTPUT«1.4142135623731␤»

[18:02] *** Trashlord left
[18:02] <tylercurtis> masak: according to spec, .lines should work.

[18:02] <masak> oh, ok.

[18:02] <colomon> rakudo may be lagging.

[18:03] <tylercurtis> http://perlcabal.org/syn/S32/Str.html "our List multi method lines ( Str $input: Int $limit = Inf ) is export"

[18:03] <pmichaud> tylercurtis: that's a recent spec change -- Rakudo hasn't caught up yet.

[18:05] <tylercurtis> pmichaud: it looks fairly simple. If I don't forget, I'll submit a patch once I finish with Squaak.

[18:05] <pmichaud> tylercurtis: wfm!

[18:12] <[Coke]> rakudo: (1,1, {$^a + $^b} ..100).perl.say

[18:12] <p6eval> rakudo 2f4733: OUTPUT«(1, 1, { ... }..100)␤»

[18:12] <[Coke]> rakudo: (1,1, $^a + $^b ..100).perl.say

[18:12] <p6eval> rakudo 2f4733: OUTPUT«Lexical '$a' not found␤  in main program body at line 2:/tmp/ssnoDPhh5H␤»

[18:12] <colomon> [Coke]: you want ..., not ..

[18:12] <colomon> unless you're trying to be eeeeeeevil

[18:12] <[Coke]> rakudo: (1,1, $^a + $^b ...100).perl.say

[18:12] <p6eval> rakudo 2f4733: OUTPUT«Lexical '$a' not found␤  in main program body at line 2:/tmp/iyDyeWaB2P␤»

[18:13] <[Coke]> rakudo: (1,1, {$^a + $^b} ...100).perl.say

[18:13] <p6eval> rakudo 2f4733: OUTPUT«(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89)␤»

[18:13] <pmichaud> masak: (Q bug)  that one looks to be a little deep.  nqp-rx has the same issue.

[18:13] <masak> oh right, it does.

[18:13] <masak> if there's any way I can help...

[18:14] <masak> the poker hand example contains a subtype called Quad.

[18:14] <masak> I'll see what besides that bug prevents the poker hand example from working properly.

[18:14] <pmichaud> after trying (and correctly failing) the term:<quote> subrule, it never tries  term:<name> for some reason.

[18:14] <masak> ISTR [Coke] got a version of it working on Rakudo.

[18:15] <masak> pmichaud: so, some bug in the grammar-engine part of nqp-rx?

[18:15] <pmichaud> masak: that's how it looks at the moment.

[18:15] * ingy is off to oscon

[18:16] <masak> sounds enticing, but I'm not too sure I'd be successful in isolating and fixing the problem. I'm still not too well-versed in nqp-rx development.

[18:16] <masak> I should be, but I'm not.

[18:16] <[Coke]> rakudo: (2, 4,  * * * ...1024).perl.say

[18:16] <p6eval> rakudo 2f4733: OUTPUT«(2, 4, 8, 32, 256)␤»

[18:16] <masak> pmichaud: is there a document somewhere outlining how to re-bootstrap nqp-rx?

[18:16] <pmichaud> docs/bootstrapping.pod

[18:17] <masak> oh, excellent.

[18:17] <[Coke]> that's a CRAZY PLACE TO PUT THAT DOCUMENT!

[18:17] <masak> pmichaud++

[18:17] <[Coke]> </alester>

[18:17] <pmichaud> [Coke]: I agree -- we should've called it  "lib/THIS_IS_NOT_THE_BOOTSTRAPPING_DOCS.pod"

[18:22] * masak builds nqp-rx

[18:23] *** dakkar joined
[18:23] *** pmurias joined
[18:24] <pmurias> ruoso, hi

[18:26] <pmichaud> masak: I think I found it.

[18:26] <masak> yay

[18:26] * PerlJam randomly guesses that it was a bizarre interaction with LTM and a token rule.

[18:27] <pmichaud> actually, I think the protoregex may be giving up a bit early

[18:27] <pmichaud> i.e., it's an incorrect goto

[18:28] <masak> 不適切なに行く!

[18:28] *** IllvilJa joined
[18:28] <pmichaud> yes, that appears to be it.  pmichaud--

[18:28] <pmichaud> copy-pasta error

[18:29] <masak> pmichaud: I have a ++ for you once it's fixed. :)

[18:29] <jnthn> (putting pasta in the copier)--

[18:30] <jnthn> Aha! 1 out of 4!

[18:30] * jnthn starts to strike down the LTA errors moritz_++ flagged up as important

[18:31] <PerlJam> Smite them jnthn++!  Smite them!  :)

[18:32] <pmichaud> pmichaud@plum:~/nqp-rx$ ./nqp

[18:32] <pmichaud> > class Quill { };  Quill.new;  say('alive');

[18:32] <pmichaud> alive

[18:32] * PerlJam is full of problems and no solutions today and so feeling very unproductive  :(

[18:32] <pmichaud> PerlJam:  ...and yet a person like you would be R*'s primary target

[18:32] <pmichaud> :-)

[18:33] <masak> pmichaud++

[18:33] <pmichaud> now to run lots of tests

[18:34] <jnthn> ergh, I just wrote one patch I like lots and one I hate

[18:34] * jnthn ponders

[18:34] <pmurias> ruoso: i release mildew and smop on CPAN today

[18:34] <masak> jnthn: merge them, and it'll be a patch you'd go "meh" about :P

[18:34] <jnthn> masak: :P

[18:34] <PerlJam> masak++

[18:35] <[Coke]> I was just trying to explain Whatever to a perl5 programmer and failed miserable. sadly the book has no reference to Whatever yet for me to cheat and fall back to.

[18:35] <tylercurtis> pmurias++ ooh... did that involve making STD more convenient to use?

[18:36] <pmurias> what do you mean by more convenient

[18:37] <pmurias> ?

[18:37] <arnsholt> Arglebargle!

[18:37] <arnsholt> blogs.perl.org returning 500 when I save my entry is no fun >.<

[18:37] <pmurias> it's installable, but the executables a user might try to use are not in the dist

[18:38] <[particle]> whatever is a dwimmy term

[18:38] <pmurias> tylercurtis, but there isn't a reason why they can't if you people specify what they need

[18:38] *** mmcleric joined
[18:38] <masak> arnsholt: the term 'argle-bargle' goes all the way back to 1872, according to Merriam-Webster. I didn't learn it until just a moment ago. :)

[18:38] <arnsholt> ORLY? Fun =D

[18:38] <masak> arnsholt: did you lose the post?

[18:38] <tylercurtis> pmurias: frankly, I don't remember what my inconveniences were last time I tried, other than the hard-coding of the path to perl, but I think au|zzz++ fixed that.

[18:39] <arnsholt> No, thankfully Opera saves form data in case you want to go back to the form

[18:39] <pmurias> tylercurtis, what do you want to use STD for?

[18:39] <masak> arnsholt: you shouldn't write important stuff in web browser forms. it limits the soul.

[18:39] <arnsholt> True, true

[18:39] <masak> use a real editor!

[18:40] <masak> :)

[18:40] <arnsholt> Yeah. Anyways, it's up now (http://blogs.perl.org/users/arne_skjaerholt/2010/07/the-joys-of-backtracking-1.html)

[18:40] <[particle]> like vimperator?

[18:40] <masak> [particle]: arglebargle!

[18:40] <arnsholt> Now I just need to figure out what I want for dinner. Sushi or crêpes...

[18:41] <pmichaud> why not both?  ;-P

[18:41] <masak> crushi!

[18:41] <arnsholt> [particle]: I want to try vimperator, but I'm an Opera man =)

[18:41] <arnsholt> Crushi sounds... interesting, to say the least ^^

[18:41] <arnsholt> But I had sushi for lunch, so I think it'll be crêpes

[18:42] <tylercurtis> pmurias: Bennu. My I'll-eventually-get-around-to-supporting-more-than-"my $a = 5; say 5;" Perl 6 to LLVM compiler. Which currently uses Yapsi's parser but eventually, I'll probably want to switch over to using STD, since the stuff a Perl 6 interpreter in Perl 6 will want to implement early on and the stuff a native-code-ish compiler will want to implement early on doesn't seem like particularly overlapping sets. :)

[18:42] <arnsholt> Crêpes has the advantage of cidre as well...

[18:42] <masak> arnsholt: in my YAPC::EU talk about parsers, I want to say that regexes and Prolog live in the same control-flow paradigm. do you agree?

[18:42] <dalek> nqp-rx: 5725781 | pmichaud++ |  (2 files):

[18:42] <dalek> nqp-rx: Fix protoregex bug with classnames beginning with Q.

[18:42] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/57257818cd7630b987e606e1c38dbe3181049bce

[18:42] <dalek> nqp-rx: 11cd811 | pmichaud++ | src/stage0/ (4 files):

[18:42] <dalek> nqp-rx: Update bootstrap.

[18:42] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/11cd81140dad7f313921489e23f7cea7bd37ae5b

[18:43] <pmurias> tylercurtis, mberends started writting a Perl 6 to LLVM compiler

[18:43] <[particle]> ooh, a local sushi place here has an awesome roll wrapped in a crepe

[18:43] <arnsholt> masak: Absolutely. Writing parsers is very intuitive in Prolog, since so many of the concepts that are hairy to get right in imperative languages are built into the language

[18:43] <pmichaud> this does not look good:  http://twitter.com/oscon/status/18932923628

[18:43] <arnsholt> Unification and backtracking play well with parsing

[18:44] <[Coke]> arnsholt: 'twould be helpful to have a link to whatever "parrotlog" is.

[18:44] <jnthn> omnomnom wireless

[18:44] <masak> arnsholt: I wonder what unification translates to in the regex world...

[18:44] <[Coke]> ah. guessing prolog on parrot.

[18:44] *** lue left
[18:44] <pmurias> masak, local?

[18:44] <pmichaud> and, of course, the conference hasn't really started yet.

[18:45] <arnsholt> [Coke]: It's my Prolog on Parrot project. See (almost) all the other posts on that blog, and http://github.com/arnsholt/parrotlog

[18:45] <pmurias> arnsholt, what's a prolog usefull for?

[18:45] <masak> pmurias: oy, you'd have to elaborate that point. I'm guessing it's a tentative answer to my question, but I don't see what you're referring to.

[18:45] <arnsholt> masak: Good question =)

[18:45] <[particle]> don't the oscon attendees know the world cup is over?

[18:46] <tylercurtis> phenny: ask mberends pmurias tells me you started work on a Perl 6 to LLVM compiler at some point. How far did you get? Still working on it at all? Is it available somewhere?

[18:46] <phenny> tylercurtis: I'll pass that on when mberends is around.

[18:46] <pmurias> vill

[18:46] *** macroron left
[18:46] <arnsholt> pmurias: Good question, to some degree. I for one just find the language appealing (the concepts are quite cool)

[18:46] * masak tries to think of a pun somewhere between "world bup" and "smashed cup"

[18:46] <arnsholt> The backtracking and unification are quite useful for certain things as well

[18:46] <[Coke]> pmichaud++ #that's been bugging me for some time.

[18:47] <pmurias> masak, unification in prolog is a bit like assignment

[18:47] <pmichaud> locally

[18:47] <pmichaud> pmichaud@plum:~/rakudo$ ./perl6

[18:47] <pmichaud> > class Quill { };  Quill.new;  say 'alive';

[18:47] <pmichaud> alive

[18:47] <pmichaud> > 

[18:47] <masak> pmurias: ah, yes. maybe it's like Perl 6's "let"?

[18:47] <masak> pmichaud: \o/

[18:47] <pmurias> only it gets reverted on backtracking (that's why it's like perl5 local)

[18:47] <pmurias> masak, plus it has pattern matching thrown in

[18:47] <masak> doubt 'local' would revert on backtracking.

[18:47] <arnsholt> Unification isn't really assignment though. Remember that Prolog is declarative

[18:47] <masak> it's the whole point of 'let', though.

[18:48] <pmurias> arnsholt, in theory

[18:48] <tylercurtis> pmurias++ thanks, I'll have to look at that. 

[18:48] <pmichaud> pushed as cd2d123

[18:48] <pmurias> with cut and taking in account performance it tends to be highly imperative

[18:48] <arnsholt> True. I think of it more like a constraint "these two somethings have to have the same structure"

[18:49] <[Coke]> pmichaud: anything else planned to squeeze into nqp-rx in parrot before the release?

[18:49] <arnsholt> nom &

[18:49] <dalek> rakudo: cd2d123 | pmichaud++ | build/PARROT_REVISION:

[18:49] <dalek> rakudo: Bump PARROT_REVISION to get fix for Q-named classes.  Fixes RT #74276.

[18:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cd2d1234e2c16edf081bdfd8d286860852744fa7

[18:49] <masak> pmichaud++

[18:50] <pmichaud> [Coke]: the only thing I can think of that might want fixing is escapes in enumerated character lists, like  <[\x00..\xff]>.   But I doubt that's going to happen before tomorrow.

[18:51] <pmichaud> [Coke]: at any rate, I don't have anything else I plan to squeeze into nqp-rx, unless I find something on the plane tonight.

[18:51] <[Coke]> hokay. ping me if you need me to hold the release.

[18:51] <pmichaud> will do.

[18:51] <[Coke]> ... because I'll be doing it late anyway, that probably won't matter. =-)

[18:51] <pmichaud> any estimate on time-of-day for release?

[18:53] <jnthn> nom shop &

[18:53] <[Coke]> pmichaud: probably after 10pm eastern.

[18:53] <masak> would anyone like to add http://github.com/pmichaud/io-prompter to pls's poc-projects.list ?

[18:54] <pmichaud> [Coke]: okay, wfm.  I should be able to give plenty of notice if I think we need a hold.  But a hold is very unlikely at this point.

[18:54] <[Coke]> rogerroger.

[18:54] <pmichaud> I'm sure io-prompter needs some love, too.

[18:55] <pmichaud> I'd be fine if someone forked it to work on it and let pls point there.  :-)

[18:55] <pmichaud> or pull requests are welcomed.

[18:56] <[Coke]> pmichaud: ... did you just ask for PULL REQUESTS? ;)

[18:56] <pmurias> tylercurtis, what do you need for your perl 6 to llvm compiler? if you were intrested in making it a mildew backend i could help with that

[18:56] <pmichaud> [Coke]: yes, that's a small enough project that I think I could figure it out.

[18:56] <masak> there are some instances of '*>0' in the demos. that works, but would look nicer with some spacing-out, IMHO.

[18:57] <pmichaud> yeah,  '*>0'  looks like a cyclops that just had a finger poked in its eye.

[18:57] <masak> :P

[18:58] <pmichaud> [Coke]: besides, chromatic++ has spoken favorably of github's fork queue (iirc), so I'm thinking it must have some merit after all.

[18:58] <masak> hah, it's alpha code :P

[18:59] * masak feels better now about Druid, November, and a few other projects

[18:59] <pmichaud> yes

[18:59] <pmichaud> didn't I mention that IO::Prompter currently only runs with alpha?

[18:59] <pmichaud> I told Damian that someone would likely bring it up-to-date to master :)

[18:59] <masak> oh my God, it's full of comments!

[18:59] <sorear> good * #perl6

[19:00] <masak> TheDamian++

[19:00] *** stkowski joined
[19:00] <sorear> pmichaud: Is Rakudo's lack of Parcel ~~ Associative a NYI or specfossil?

[19:00] <pmurias> solarion, hi

[19:00] <pmurias> sorear, hi

[19:00] <pmichaud> I suspect specfossil.  I don't think Parcel ~~ Associative

[19:00] <masak> yes, someone should adopt IO::Prompter.

[19:01] <pmichaud> I'll adopt it on Wednesday if nobody beats me to it :)

[19:01] <tylercurtis> pmurias: I'm not really familiar enough with mildew to know what that would involve or whether the result would be in line with my goals for Bennu(exploring the ability to compile Perl 6 to native code, compact structs/arrays, native types, and also playing around with the object system from the P&W paper).

[19:01] <pmurias> P&W?

[19:02] <tylercurtis> pmurias: http://tinyurl.com/23dfwut or http://piumarta.com/software/cola/objmodel2.pdf for the original pdf.

[19:03] <ruoso> pmichaud, sorear, Parcel !~ Associative... it's the Capture that implements the Associative 

[19:03] <pmichaud> ruoso: I agree.

[19:03] <ruoso> TimToady said so some day here in IRC

[19:04] *** ashleydev joined
[19:05] <pmichaud> I keep thinking I'm forgetting something for my trip.... :-(

[19:06] <PerlJam> pmichaud: as long as it's not something you have to spend significant energy recreating, you'll be fine :)

[19:06] <sorear> ruoso: how does Parcel remember the difference between (1,:a<b>) and (1,(:a<b>))?  They make different captures

[19:10] <ruoso> (1,(:a<b>)) contains another level of parcels

[19:10] <pmichaud> ruoso: not under current spec.

[19:10] <ruoso> in fact, if you turn (1,(:a<b>)) into a capture, it turns it into two positionals

[19:10] <ruoso> pmichaud, ok... I might be outdated... what changed?

[19:11] <pmichaud> infix:<,> creates a parcel

[19:11] <pmichaud> parens don't create a parcel

[19:11] <ruoso> ok... that is not new... it was a brain failure on my part...

[19:11] <ruoso> but it does make some difference, 

[19:11] <ruoso> otherwise (1,:a<b>) and (1,(:a<b>)) would be different

[19:11] <ruoso> *wouldn't

[19:11] <ruoso> and they are

[19:11] <pmichaud> ruoso: agreed -- there some spec sloppiness there.

[19:12] <ruoso> I think at some point it was accepted that (1,(:a<b>)) was a special construct

[19:12] <ruoso> I mean... having extra parens

[19:12] <jnthn> We could handle it syntactically.

[19:12] <sorear> yes

[19:12] <sorear> it's syntactic

[19:12] <ruoso>  ((((1)))),2) is not the same as (1,2)

[19:12] <jnthn> But that relies on us promoting parcels to captures syntactic.

[19:12] <sorear> but that's not my point

[19:13] <jnthn> Which is fine

[19:13] <sorear> I said "how remembers" not "how parses"

[19:13] <sorear> Parcel ~~ List, it doesn'

[19:13] <ruoso> jnthn, I think that has been widely accepted 

[19:13] <jnthn> sorear: Well, you probably needn't construct the parcel

[19:13] <sorear> t have bits for "unpackable :<>"

[19:13] <jnthn> sorear: Jsut go straight fo the capture.

[19:13] <sorear> OK

[19:13] <jnthn> gah, typing

[19:13] <jnthn> That's what Rakudo does

[19:13] *** fglock joined
[19:13] <pmichaud> jnthn: can one always go straight for the capture?

[19:13] <jnthn> No point making something you're only going to throw away.

[19:13] <ruoso> fglock, howdy fglock... long time no see....

[19:13] <jnthn> pmichaud: I don't know any situation where not.

[19:13] <pmichaud> (1, (:a<b>)).Capture

[19:14] <fglock> ruoso: hi!

[19:14] <jnthn> pmichaud: If you do that, you've constructed a Parcel and coerced it.

[19:14] <jnthn> pmichaud: That's going to have a named arg

[19:14] <ruoso> pmichaud, jnthn, you can go straight for the capture when it's sintatically known that is being used as a  Capture

[19:14] <tylercurtis> pmurias: really the only thing I'm blocking on is tuits. Once GSoC is over, I expect to be able to get around to designing a more LLVM-suitable intermediate format, cleaning up my codegen, switching over to STD, etc. I'll have to remember to look at the CPAN dist for Mildew when it comes to that last one. At that point I might have some actual concrete questions for you.

[19:15] <jnthn> pmichaud: My point was more than if a call, you know you're compiling a call, so you never emit code that builds a Parcel and coerces it. Just emit code that creates the (correct) Capture.

[19:15] <jnthn> *more that if you have

[19:15] <pmichaud> jnthn: yes, I know that part.

[19:15] <pmichaud> I'm just wondering if it works in general.

[19:15] <sorear> jnthn: calls are easy! I'm talking about Parcel objects

[19:15] <jnthn> sorear: you mean if you have a Parcel, and later .Capture it?

[19:15] <sorear> (1, (:a<b>)).Capture # This should have 2 positionals.  How is this implemented?

[19:15] <ruoso> Parcels remember how they were built in terms of the syntax

[19:15] <jnthn> sorear: It won't.

[19:15] <jnthn> That's just crazy.

[19:16] <ruoso> jnthn, it will have 2 positionals... yes... 

[19:16] <jnthn> ruoso: nO.

[19:16] <jnthn> *No

[19:16] <ruoso> it's how you send a pair as the second argument

[19:16] <jnthn> That's insane.

[19:16] <ruoso> (it has been so in the spec for a long time)

[19:16] <jnthn> ruoso: It's a special syntactic construct in the case we have a call.

[19:16] <jnthn> ruoso: That may be, but I really don't think it holds up.

[19:16] <pmichaud> jnthn is saying that arglist and semilist are different from normal expressions

[19:16] <ruoso> I see... I see....

[19:17] <jnthn> Otherwise our Parcel objects need to carry around a bunch of extra meta-data.

[19:17] <ruoso> but I'm pretty sure that was the intention

[19:17] <fglock> rakudo: my @a = []; my %h = {}; say @a.perl, " ", %h.perl

[19:17] <p6eval> rakudo 2f4733: OUTPUT«[[]] {}␤»

[19:18] *** mmcleric left
[19:18] *** felliott joined
[19:18] <pmurias> fglock, hi

[19:18] <pmurias> tylercurtis, what's your gsoc project?

[19:18] <pmichaud> hmmm

[19:18] <jnthn> ruoso: Perhaps so, but it feels...so wrong.

[19:18] <pmichaud> I'm thinking   my %h = {}  should've blown up.

[19:18] <fglock> pmurias: hi! I saw the cpan release announce

[19:19] * pmurias hopes the tarballs work on other peoples boxes

[19:19] <ruoso> jnthn, I think the idea is that it should be easily optimizeable depending ont he situation

[19:19] <fglock> pmichaud: it seems a little odd that the hash assignment works, but the array assignment does something different

[19:19] <dalek> rakudo: 21d67d5 | jonathan++ | src/Perl6/BacktracePrinter.pm:

[19:19] <dalek> rakudo: Instead of starting to make a list of 'ignore this frame' for the backtrace 

[19:19] <dalek> rakudo: printer, we'll instead just have an annotation to mark a frame as invisible for 

[19:19] <dalek> rakudo: its purposes. Then it's just one thing to check.

[19:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/21d67d5f89f45deaa96e676af0002e05e97a15d1

[19:19] <dalek> rakudo: b62db16 | jonathan++ | src/builtins/control.pir:

[19:19] <dalek> rakudo: Mark die and warn as being invisible to the backtrace printer.

[19:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b62db16f9a1b7e5c6eaa901d1585957329ee81b8

[19:19] <dalek> rakudo: c0df20c | jonathan++ | src/metamodel/Attribute.nqp:

[19:19] <dalek> rakudo: Mark attribute accessors as invisible frames so the errors give the line number 

[19:19] <dalek> rakudo: where we tried to access the attribute, not some useless one.

[19:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c0df20c023151abc8c764b78a8cfb9a60857ef47

[19:19] <masak> pmichaud: I agree that it should probably blow up.

[19:19] <jnthn> fglock: It's more like the array assignment is correct, I think.

[19:20] <pmurias> ruoso, so the next thing  would be packaging the p5 interop as SMOP::P5::Interop

[19:20] <masak> fglock: the array assignment is the co... what pmichaud++ said.

[19:20] <pmurias> ?

[19:20] <fglock> rakudo: my @a = [123]; my %h = {a => 123}; say @a.perl, " ", %h.perl

[19:20] <tylercurtis> pmurias: PAST optimizations for Parrot. Well, now, it works for anything that's a descendant of Parrot captures, but PAST(and to a lesser extent, POST) is the primary focus.

[19:20] <p6eval> rakudo 2f4733: OUTPUT«[[123]] {"a" => 123}␤»

[19:20] <jnthn> Dinner time, another moritz_ LTA ticket later afterwards. :-)

[19:20] <fglock> nice - thanks!

[19:21] <pmurias> fglock, you're now working on a python backend for perlito?

[19:22] <fglock> pmurias: I'm curious about the cpan upload, I'll take a look later

[19:22] <fglock> pmurias: it's now released as Perlito 5.0

[19:22] <ruoso> pmurias, hmmm... isn't the SMOP cpan release missing?

[19:22] <fglock> it is bootstrapped in Python

[19:22] * pmurias checks

[19:22] *** plainhao left
[19:23] * pmurias reboots to type dzil release

[19:25] <pmurias> ruoso, strange i have a pause indexer report in my mail inbox

[19:25] <ruoso> ok.. it might be just the cpan mirrors...

[19:25] <ruoso> your cpan home doesn't have a SMOP releas

[19:25] <fglock> hmm - I was happy with @a = [] and %h = {} ...

[19:26] <ruoso> fglock, my @a = (); is what you meant

[19:26] <pmurias> ruoso: http://www.cpan.org/modules/by-authors/id/P/PM/PMURIAS/SMOP-0.3.tar.gz

[19:26] <perigrin> since I don't feel comfortable speaking for the Perl6 community, if someone who does can give me some feed back on 

[19:26] <fglock> yes, but miniperl6 doesn't implement lists

[19:26] <perigrin> http://skitch.com/perigrin/dpg6t/fullscreen

[19:26] <perigrin> I would like to hand them out at OSCON.

[19:27] <fglock> I'll need something like @([])

[19:27] <ruoso> fglock, well... my $a = []; also does what you mean

[19:27] *** pmurias left
[19:27] <pmichaud> rakudo:  my @a = @([]);  say @a.perl;

[19:27] <p6eval> rakudo 2f4733: OUTPUT«[]␤»

[19:27] <fglock> yup

[19:28] <ruoso> rakudo: my @a = [].list(); #wild guess

[19:28] *** cono left
[19:28] <p6eval> rakudo 2f4733:  ( no output )

[19:28] <pmichaud> perigrin: I'd like some of those cards :)

[19:28] <ruoso> rakudo: my @a = [].list(); say @a.perl #wild guess

[19:28] <p6eval> rakudo 2f4733: OUTPUT«[]␤»

[19:29] <ruoso> perigrin, it's cute... 

[19:29] <fglock> my @a = @([123]); say @a.perl

[19:29] <pmichaud> I saw earlier versions of the cards at yapc::na

[19:29] <fglock> list() is not the same as @()

[19:29] *** pmurias joined
[19:29] <pmichaud> so the others I have say something like '2Q 2010'

[19:30] <ruoso> pmurias, ok... the cpan mirror I'm seeing is out-of-sync... but the cpan shell finds it

[19:30] <perigrin> pmichaud: if you're here I can get you some hot off the press

[19:30] <pmichaud> perigrin: I'll be there tonight at 23h00 :-)

[19:30] <perigrin> as soon as I find a press 

[19:30] <pmichaud> so can I grab some tomorrow or Wed?

[19:30] <perigrin> yep

[19:30] <pmichaud> \o/

[19:30] <perigrin> they'll be at the TPF booth if you're kosher with them

[19:30] <pmurias> ruoso: cpan shell? you don't use cpanm?

[19:30] <pmichaud> Very much so.

[19:31] *** hercynium left
[19:31] <perigrin> sweet

[19:31] <ruoso> pmurias, I'm slow at changes ;)

[19:32] <perigrin> pmichaud: I think the Q2 2010 cards were before y'all set the July 29th date ... if you'd like I can revert back to Q2 but it looks reasonably like you'll hit your deadline :)

[19:32] <mathw> Eveniniggle

[19:32] <pmichaud> perigrin: right, I understand about the Q2 2010.  Missing that date is entirely my fault :-)

[19:32] <perigrin> you can't control health issues 

[19:32] <pmichaud> I like the July 29, 2010 date very much.  And yes, we'll hit it.

[19:33] <pmichaud> I just also like that I have some cards that have the earlier date :)

[19:33] <perigrin> :)

[19:33] <pmurias> ruoso: so how's the installation going?

[19:33] <ruoso> fine... I got lots of "v-string in use/require non-portable at..."

[19:34] <ruoso> but that's just warnings

[19:35] <pmurias> that warning was removed in newer perls

[19:35] <ruoso> "cannot open unicode maps from ./lib . : Arquivo ou diretório não encontrado" 

[19:35] <pmurias> as it's a "you are using modern syntax" warnings

[19:35] <ruoso> that breaks at Mildew::Setting::SMOP install

[19:35] <pmurias> that's bad

[19:35] <pmurias> STD-0.01?

[19:36] <ruoso> er...  "Arquivo ou diretório não encontrado" means "file not found"

[19:36] <arnsholt> Archive or directory not found, I think

[19:36] <pmurias> i've seen that warning before

[19:36] <pmurias> error

[19:36] <ruoso> perl -MSTD -E 'say $STD::VERSION' fails as well

[19:37] <fglock> rakudo: my $x; say $x

[19:37] <p6eval> rakudo 2f4733: OUTPUT«Any()␤»

[19:37] <ruoso> pmurias, STD 0.01, yes...

[19:37] <pmurias> STD-0.02 is the right one

[19:38] <fglock> hmm - it used to be an empty string

[19:38] <ruoso> oh... ok...

[19:38] <pmurias> audreyt (now au) fixed that bug

[19:38] <ruoso> it's not indexed yet, it seems... 

[19:38] <ruoso> I'll grab the newest version by hand then

[19:38] <pmichaud> well, time to afk and head in the general direction of the airport

[19:38] *** ive joined
[19:39] <ruoso> pmurias, hmm... STD-0.02 is an ** UNAUTHORIZED RELEASE **

[19:39] <ruoso> that's why the client got 0.01 

[19:39] <pmurias> STD-0.01 is one two

[19:39] <pmurias> * too

[19:40] <pmurias> ** UNAUTHORIZED RELEASE ** is a warning that we are using the STD package name

[19:41] <pmurias> and it's used by something else

[19:42] <pmurias> http://search.cpan.org/~azawawi/Syntax-Highlight-Perl6-0.81/ likely

[19:42] <ruoso> hmm... it's probably a good idea talking to azawawi to fix it... 

[19:42] <ruoso> otherwise the installation fails

[19:43] * jnthn back

[19:43] <jnthn> pmurias: Safe flight! :-)

[19:43] <pmurias> s/pmurias/pmichaud/

[19:44] <pmurias> ruoso: STD-0.01 is an UNAUTHORIZED RELEASE too

[19:44] <jnthn> perigrin: Those look nice. :-)

[19:44] <pmurias> ruoso: but we surely should have an ugly warning on our module

[19:44] <pmurias> * shouldn't

[19:45] <pmurias> ruoso: did STD-0.02 help?

[19:46] <ruoso> yes... 

[19:46] *** mberends joined
[19:46] <ruoso> having the entire setting in a single file makes the build faster?

[19:47] <pmurias> there was a bit of tricky inter dependencies that i solve by having it all in a big file

[19:47] <pmurias> ruoso: i think it makes the build slower

[19:48] <pmurias> as something wrong is going on in mildew when compiling the setting

[19:48] <ruoso> alright... it's not very problematic...

[19:48] <ruoso> ok... I have mildew working now...

[19:48] <ruoso> from CPAN...

[19:48] <ruoso> that's awesome

[19:48] <ruoso> pmurias, now P5 interop...

[19:49] <ruoso> which whould probably include the p5 module for using smop as well

[19:49] <mathw> Are yo usupposed to be able to have a class called A inside a module called A?

[19:49] <ruoso> mathw, yes... but then you have A::A

[19:52] <jnthn> mathw: Rakudo is generally not clueful about nested packages.

[19:52] <sorear> pmurias: what did the mail you got from the CPAN Indexer say?

[19:52] <ruoso> pmurias, and after p5 interop... "use v6-mildew"

[19:52] <mathw> jnthn: I'm well aware of that :)

[19:53] <PerlJam> I thought classes and modules and packages all shared the same namespace

[19:53] <ruoso> PerlJam, they do...

[19:53] <ruoso> he said A inside A

[19:53] <ruoso> then it's A::A

[19:53] <PerlJam> oh, I seemed to have skipped "insize"

[19:53] <PerlJam> er, "inside"

[19:54] <mathw> :)

[19:54] <ruoso> pmurias, one question... does the SMOP.pm module depends on the p5 interop features?

[19:54] <pmurias> fglock: if we would like to support multiple backends for v6 what would be the best way to do that?

[19:54] <ruoso> or can it be one-way at first?

[19:55] <pmurias> ruoso: you mean the old SMOP module

[19:55] <ruoso> pmurias, yes... the "use SMOP objects in p5" one

[19:55] <ruoso> or is that outdated?

[19:55] <pmurias> by p5 interop features you mean the p5 module in smop

[19:55] *** cono joined
[19:55] <ruoso> pmurias, yes

[19:56] <pmurias> ruoso: i think it's been warped into a helper thing for doing eval_perl5

[19:56] <fglock> pmurias: maybe possible to - use v6-alpha 'backend_name';

[19:56] *** hanekomu_9 joined
[19:56] <fglock> or an env setting

[19:57] <pmurias> fglock: what i meant more is to support use v6-mildew

[19:57] *** sundar left
[19:58] <fglock> yes - we need to split v6.pm / Pugs::Compiler::Perl6, and then allow a way to specify the backend

[19:59] <pmurias> v6.pm could delegate the import call to v6::alpha or v6::mildew

[19:59] *** pyrimidine joined
[19:59] <pmurias> or v6-perlito

[19:59] <pmurias> * v6::perlito

[19:59] <fglock> there is no import call, if I remember

[19:59] <fglock> it generates a .pmc and executes that

[20:00] <fglock> you need to specify the backend before compilation...

[20:00] <pmurias> Module::CompileV6 has an import sub

[20:00] <ruoso> what pmurias meant was to take what's currently in v6.pm and move to v6::alpha

[20:00] <fglock> so probably an env variable

[20:01] <ruoso> then have v6.pm simply choosing the appropriate backend

[20:01] <ruoso> by the v6-something like

[20:01] <fglock> yes - I wonder how to do that

[20:01] <pmurias> backend meaning the compiler here

[20:01] <pmurias> ruoso: would it make sense for mildew to use .pmc files?

[20:02] <ruoso> pmurias, yes... considering we can build a .so with the code and load it

[20:02] <ruoso> we would build a .so and the .pmc to load the .so

[20:02] <pmurias> why do we need the .pmc

[20:02] <pmurias> ?

[20:03] <ruoso> to avoid having to decide anything in runtime

[20:04] <fglock> pmurias: I think Module::CompileV6 is only used for cpan install

[20:05] <fglock> hmm - can't find v6-alpha in pugs/

[20:08] <ruoso> pmurias, where is that list of spectests mildew-smop supports?

[20:11] <fglock> pmurias: the code change probably should be in v6::pmc_compile()

[20:14] <fglock> sleep &

[20:15] <mathw> argh

[20:15] <mathw> I don't seem to be able to use a class in another module at the moment

[20:15] <mathw> not even a module inside another module

[20:15] *** fglock left
[20:15] <mathw> :(

[20:16] <mathw> still a nested package I suppose

[20:16] <mathw> Is that on the list for R*?

[20:17] <tylercurtis> rakudo: module A { module B { sub f { say 1; } } }; A::B::f;

[20:17] <p6eval> rakudo 2f4733: OUTPUT«Can not find sub A::B::f␤  in main program body at line 1␤»

[20:18] <tylercurtis> rakudo: module A { module B { sub f { say 1; } } }; A::B;

[20:18] <p6eval> rakudo 2f4733: OUTPUT«Can not find sub A::B␤  in main program body at line 1␤»

[20:18] <mathw> yup, see, broken

[20:18] <tylercurtis> rakudo: module A { our module B { sub f { say 1; } } }; A::B::f;

[20:18] <p6eval> rakudo 2f4733: OUTPUT«Can not find sub A::B::f␤  in main program body at line 1␤»

[20:18] <tylercurtis> rakudo: module A { our module B { our sub f { say 1; } } }; A::B::f;

[20:18] <p6eval> rakudo 2f4733: OUTPUT«Can not find sub A::B::f␤  in main program body at line 1␤»

[20:19] <tylercurtis> rakudo: module A { module B { sub f { say 1; } } }; B::f;

[20:19] <p6eval> rakudo 2f4733: OUTPUT«Can not find sub B::f␤  in main program body at line 1␤»

[20:19] <jnthn> mathw: Probably not

[20:19] <jnthn> mathw: I don't want to hack it in 

[20:19] <jnthn> mathw: alpha always had an awkward handling of it that never quite worked.

[20:19] <mathw> aaawww

[20:20] <mathw> that's going to bite a lot of people unfortunately

[20:20] <mathw> now how could I do Form without that

[20:20] <jnthn> You can still declare class A { ... }; class A::B { ... } I think?

[20:20] <tylercurtis> jnthn: Yes.

[20:20] <jnthn> Just not nesting like class A { class B { ... } ... }

[20:21] <jnthn> So it's "just" a little code shuffling.

[20:21] <mathw> umm

[20:21] <mathw> inside a module??

[20:21] <tylercurtis> And pain if you rely on lexicals from module A in B.

[20:21] <jnthn> tylercurtis: True

[20:21] * mathw could just smash everything together in one .pm file he supposes

[20:21] *** donpdonp left
[20:22] <mathw> woo

[20:22] <mathw> module A; class A::B {} lets me use A::B outside the module

[20:22] <mathw> that's all I need

[20:24] <tylercurtis> mathw: Why do you have a Form::Actions module at http://github.com/mattw/form/blob/master/lib/Form/Actions.pm that just contains a FormActions class? Why not just have a Form::Actions class?

[20:25] <mathw> eh?

[20:25] *** justatheory joined
[20:26] <tylercurtis> mathw: You have a module Form::Actions declaration at the top of the file, but all the file contains is a FormActions class. Same for Form::Grammar and grammar Format in lib/Form/Grammar.pm

[20:27] <mathw> yes

[20:28] <moritz_> that was probably from back-in-the-days when :: in class names had several problems

[20:28] <mathw> I don't understand what the problem is

[20:28] <mathw> Or what an alternative would be

[20:29] <mathw> But I am quite tired at the moment

[20:29] <mathw> so my brain isn't really functioning at full speed

[20:30] <moritz_> just that in a file Foo/Bar.pm, you usually expect class Foo::Bar, not class FooBar

[20:30] <mathw> but Foo/Bar.pm is the module Foo::Bar

[20:30] <tylercurtis> mathw: or the class.

[20:31] <mathw> ...

[20:31] <mathw> oh

[20:31] <mathw> see I told you I'm tired

[20:31] <tylercurtis> mathw: Or even nothing related to Foo::Bar except that that "use Foo::Bar" is the way to load it.

[20:32] <tylercurtis> But that last one might be a little impolite.

[20:32] <mathw> it would be surprising

[20:33] <mathw> I'm already polluting namespaces like crazy to work around the nested modules lack

[20:33] <mathw> makes me feel slightly dirty

[20:33] <mathw> although the coat of sweat and mat dust from aikido is helping

[20:34] *** dual left
[20:34] <tylercurtis> So, for those files, you can fix the problems with nested modules by just doing "class Form::Actions;" or "class Form::Actions::FormActions;" for Form/Actions.pm and "grammar Form::Grammar;" or "grammar Form::Grammar::Format" for Form/Grammar.pm

[20:34] <masak> rakudo: perl6 -e '(for 1 {}).WHAT'

[20:34] <p6eval> rakudo 2f4733: OUTPUT«===SORRY!===␤Confused at line 22, near "perl6 -e '"␤»

[20:34] <masak> arglebargle.

[20:35] <masak> rakudo: for 1 {}).WHAT

[20:35] <p6eval> rakudo 2f4733: OUTPUT«===SORRY!===␤Confused at line 22, near ").WHAT"␤»

[20:35] <masak> :(

[20:35] <masak> rakudo: (for 1 {}).WHAT

[20:35] <p6eval> rakudo 2f4733:  ( no output )

[20:35] <masak> rakudo: say (for 1 {}).WHAT

[20:35] <p6eval> rakudo 2f4733: OUTPUT«ParrotIter()␤»

[20:35] <masak> someone seems to have cast a "-10 dexterity" spell on me.

[20:35] <moritz_> rakudo: say (for 1 { }) ~~ Nil

[20:35] <p6eval> rakudo 2f4733: OUTPUT«1␤»

[20:36] <masak> rakudo: say (for 1 {}).perl

[20:36] <p6eval> rakudo 2f4733: OUTPUT«()␤»

[20:36] <masak> in my view, we can close http://rt.perl.org/rt3//Public/Bug/Display.html?id=70888

[20:36] *** dual joined
[20:36] * mathw is really liking ufo right now

[20:36] <masak> I'm surprised that we're seeing something called "ParrotIter" here, but the original bug is gone.

[20:37] <jnthn> masak: It should be List in the end

[20:37] <jnthn> I guess

[20:37] <tylercurtis> mathw: for Form/Field.pm, you could either replace each "our class Field {...}" and such with "class Form::Field::Field {...}" or separate them into Form/Field/Whatever.pm and have Form/Field.pm just "use" the Form::Field::Field and such.

[20:37] <jnthn> masak: Should get fixed "for free" when we switch for to map

[20:37] <moritz_> masak: feel free. We have sufficient test coverage for using the return value of empty statements

[20:37] <moritz_> jnthn: not Parcel?

[20:37] * masak closes bug

[20:38] <jnthn> rakudo: (1,2,3).map(1 + *).WHAT.say

[20:38] <p6eval> rakudo 2f4733: OUTPUT«List()␤»

[20:38] <jnthn> moritz_: Rakudo says not ;-)

[20:38] <moritz_> jnthn: I believe it (but not you!) :-)

[20:39] <masak> rakudo: sub foo { for 1,2,3 {} }; say foo.WHAT

[20:39] <jnthn> moritz_: I has a fix for a second of your LTAs. :-)

[20:39] <p6eval> rakudo 2f4733: OUTPUT«ParrotIter()␤»

[20:40] <jnthn> moritz_: Might be able to pick off a third one tonight too.

[20:40] <moritz_> \o

[20:40] <moritz_> though my main concert wrt error message is this:

[20:40] <moritz_> rakudo: 1 1

[20:40] <p6eval> rakudo 2f4733: OUTPUT«===SORRY!===␤Confused at line 22, near "1 1"␤»

[20:41] <moritz_> std: 1 1

[20:41] <p6eval> std 31767: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/7ySXdbImNs line 1:␤------> [32m1 [33m⏏[31m1[0m␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse failed␤FAILED 00:01 115m␤»

[20:41] <moritz_> rakudo: }

[20:41] <p6eval> rakudo 2f4733: OUTPUT«===SORRY!===␤Confused at line 22, near "}"␤»

[20:41] <moritz_> std: }

[20:41] <p6eval> std 31767: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/7NnHfvRdie line 1:␤------> [32m<BOL>[33m⏏[31m}[0m␤    expecting statement list␤Parse failed␤FAILED 00:01 112m␤»

[20:41] <moritz_> he, also confused :-)

[20:41] <jnthn> lol

[20:41] <jnthn> Well, we can only do so much. :-)

[20:41] <moritz_> anyway, the OPP doesn't really emit awesome error messages

[20:41] <jnthn> No

[20:42] <moritz_> like "two terms in a row", or "found infix where prefix or term expected" or so

[20:42] <masak> whoz OPP?

[20:42] <moritz_> operator precedence parser

[20:42] *** jnthn sets mode: +o masak

[20:42] <jnthn> masak's OPP!

[20:42] * masak is OPP o/

[20:42] <moritz_> btw our current level of spam is so low that we don't need to be ops here all around

[20:43] *** moritz_ sets mode: -o moritz_

[20:43] <[Coke]> jnthn: that is so not what "OPP" means. :P

[20:43] <[Coke]> at least, not the OPPs with which I am down.

[20:43] <masak> rakudo: sub foo($b) { $b == 42 }; subset FortyTwo of Int where &foo; say 42 ~~ FortyTwo

[20:43] <p6eval> rakudo 2f4733: OUTPUT«Could not find sub &foo␤  in <anon> at line 1:/tmp/NRenBwYA6C␤  in 'Block::ACCEPTS' at line 5401:CORE.setting␤  in 'ACCEPTS' at line 988:CORE.setting␤  in 'infix:<~~>' at line 397:CORE.setting␤  in main program body at line 22:/tmp/NRenBwYA6C␤»

[20:43] <masak> hm.

[20:44] <masak> rakudo: our sub foo($b) { $b == 42 }; subset FortyTwo of Int where &foo; say 42 ~~ FortyTwo

[20:44] <p6eval> rakudo 2f4733: OUTPUT«1␤»

[20:44] *** Martin___ joined
[20:44] <masak> rakudo: our sub foo($a, $b) { $b == 42 }; subset FortyTwo of Int where &foo.assuming(0); say 42 ~~ FortyTwo

[20:44] <jnthn> [Coke]: You down with this OPP? http://www.youtube.com/watch?v=qmuFlaFYdgE

[20:44] <p6eval> rakudo 2f4733: OUTPUT«0␤»

[20:44] <masak> heh. now it doesn't die, but it gives the wrong answer...

[20:45] * masak adds that to http://rt.perl.org/rt3/Ticket/Display.html?id=70890

[20:45] <jnthn> masak: "progress" :-)

[20:45] <masak> jnthn: yes, even sans quotes. jnthn++

[20:45] <jnthn> I'm a tad curious why it does nee work.

[20:46] <jnthn> masak: oh er

[20:46] <Juerd> feather3 is back

[20:46] <Juerd> Enjoy :)

[20:46] <masak> jnthn: insight?

[20:46] <masak> Juerd++

[20:46] <jnthn> masak: It...might be putting that assuming call into a block.

[20:46] <jnthn> or thunk

[20:46] *** timbunce joined
[20:46] <jnthn> And doing it each time.

[20:46] <moritz_> Juerd: uhm, did you log in?

[20:47] <jnthn> our sub foo($a, $b) { $b == 42 }; subset FortyTwo of Int where &foo.assuming(0); say 42 ~~ FortyTwo; say 42 ~~ FortyTwo;

[20:47] <Juerd> moritz_: No

[20:47] <masak> Juerd: huh. http://november-wiki.org/ is still alive. how'd that happen? :)

[20:47] <jnthn> rakudo: our sub foo($a, $b) { $b == 42 }; subset FortyTwo of Int where &foo.assuming(0); say 42 ~~ FortyTwo; say 42 ~~ FortyTwo;

[20:47] <moritz_> ah, the old fun: PTY allocation request failed on channel 0

[20:47] <p6eval> rakudo 2f4733: OUTPUT«0␤0␤»

[20:47] <Juerd> masak: That's feather1

[20:47] <jnthn> Hmm, maybe not or I'd expect an error

[20:47] <jnthn> Oh

[20:47] <masak> ahahah

[20:47] <jnthn> unless it's arity 0

[20:47] <Juerd> masak: Ooh, nice errors

[20:47] <Juerd> I'll upgrade udev :)

[20:47] <jnthn> rakudo: our sub foo($a, $b) { say "unicorn!!! \o/"; $b == 42 }; subset FortyTwo of Int where &foo.assuming(0); say 42 ~~ FortyTwo; say 42 ~~ FortyTwo;

[20:48] <p6eval> rakudo 2f4733: OUTPUT«===SORRY!===␤Unrecognized backslash sequence: '\o' at line 22, near "/\"; $b == "␤»

[20:48] <masak> Juerd: guessing you meant moritz_.

[20:48] <jnthn> ...fail

[20:48] <jnthn> rakudo: our sub foo($a, $b) { say 'unicorn!!! \o/'; $b == 42 }; subset FortyTwo of Int where &foo.assuming(0); say 42 ~~ FortyTwo; say 42 ~~ FortyTwo;

[20:48] <Juerd> masak: Yes, tabfail.

[20:48] <p6eval> rakudo 2f4733: OUTPUT«0␤0␤»

[20:48] <jnthn> Nope, it never calls it.

[20:48] <jnthn> oh well

[20:48] <jnthn> Oh!!

[20:48] <jnthn> masak: I bet it's that assuming doesn't return something that isa Block

[20:49] <jnthn> masak: bugs. lots of bugs.

[20:49] <mathw> hmm

[20:49] <jnthn> masak: I also just spied a spectest that fails if you'd made that a my sub too...

[20:49] <mathw> slightly wrong, that

[20:49] <mathw> oooooh

[20:50] * masak adds all this to the ticket

[20:50] <mathw> the {*} #= key thing doesn't work anymore does it

[20:50] <moritz_> it works, but it's gone from the spec

[20:50] * jnthn needs a little typing break, bbiab

[20:50] <masak> mathw: don't use it :)

[20:50] <mathw> well it's looking to me like it doesn't

[20:50] <mathw> masak: Form already did use it

[20:50] <masak> mathw: well, stop using it :P

[20:50] <mathw> wasn't looking to rewrite without it today...

[20:50] <mathw> but it does look like it's stopped working

[20:50] <masak> don't think of it as a rewrite. think of it as a correction. :)

[20:51] <mathw> action methods are short one parameter where that parameter happens

[20:51] <jnthn> mathw: Are you sure that the problem isn't just the impicit call at the end of the block also happens?

[20:51] <jnthn> mathw: That is, you get one more call than you expected?

[20:51] <mathw> oh

[20:51] <mathw> maybe

[20:51] <jnthn> worth checkin'

[20:51] <mathw> I don't think I fix that nay differently though

[20:52] <mathw> unless I add an overload which doesn't do anything

[20:52] <Juerd> moritz_: Fixed

[20:52] <jnthn> Make the parameter optional and check if it's defined

[20:52] * jnthn really afk for typing break

[20:52] <mathw> oh good plan

[20:52] <mathw> go have your break

[20:52] <moritz_> Juerd++

[20:52] <moritz_> works

[20:54] *** pugssvn joined
[20:54] <pugssvn> r31757 | pmurias++ | [mildew] renamed AST:: to Mildew::AST 

[20:54] <pugssvn> r31758 | pmurias++ | [mildew] [smop] tweaks to get $VERSION correct 

[20:54] <pugssvn> r31759 | pmurias++ | [mildew-setting-smop] fix a typo in dist.ini 

[20:54] <pugssvn> r31760 | pmurias++ | [STD] fix a bug found by au++ 

[20:54] <pugssvn> r31761 | pmichaud++ | [t/spec]:  fudge a test in try.t due to reverting exception handler in Parrot 

[20:54] <pugssvn> r31762 | audreyt++ | * Now that we have STD.pm on CPAN, ensure "make" always works with the inplace STD.pm. 

[20:54] <pugssvn> r31763 | audreyt++ | * Remove the the unneeded "-w" in try5_post's #! line. 

[20:54] <pugssvn> r31763 | * Make ./tryfile use the inplace STD.pmc too.

[20:54] <pugssvn> r31764 | pmurias++ | [mildew][smop][STD] 

[20:54] <pugssvn> r31764 | bump version

[20:54] <pugssvn> r31764 | fix mangle.pl installating (found and fixed by au++)

[20:54] <pugssvn> r31764 | update mildew to use {YOU_ARE_HERE}

[20:55] <pugssvn> r31765 | audreyt++ | * Add the same inplace-STD.pmc guard to the main executables. 

[20:55] <pugssvn> r31766 | audreyt++ | * Note the changed path of std_hilite/STD_syntax_highlight in README. 

[20:55] <pugssvn> r31767 | moritz++ | [t/spec] unfudge tests for rakudo: Whatever-currying, backtracking into named subrules, and lexical fixes 

[20:57] *** Martin___ left
[20:58] <moritz_> rakudo: {nextsame}()

[20:58] <p6eval> rakudo c0df20: OUTPUT«Null PMC access in clone()␤  in <anon> at line 1␤  in main program body at line 22:/tmp/gO8swde_Tp␤»

[21:00] *** lue joined
[21:01] <mathw> okay weird stuff happening

[21:01] <pugssvn> r31768 | moritz++ | [t/spec] fudge wrap.t for rakudo, and simplify a bit 

[21:01] <mathw> going to have to look at this again tomorrow

[21:01] <mathw> goodnight!

[21:02] <masak> mathw++ # goodnight!

[21:04] *** ashleydev left
[21:05] <pugssvn> r31769 | moritz++ | [t/spec] fudge mixed_multi_dimensional.t for rakudo 

[21:06] *** ashleydev joined
[21:09] *** xabbu42 left
[21:10] <dalek> rakudo: 981e44e | moritz++ | t/spectest.data:

[21:10] <dalek> rakudo: run two more test files

[21:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/981e44e550ac82ccb15ac6915baf23f2c5f54fda

[21:10] <pugssvn> r31770 | moritz++ | [t/spec] test for RT #74276, names starting with Q 

[21:11] *** xabbu42 joined
[21:12] <masak> ok, first thing the poker example is failing at is printing the names of the enums.

[21:13] <masak> rakudo: enum E <a b c>; say b

[21:13] <p6eval> rakudo c0df20: OUTPUT«1␤»

[21:13] <masak> what if I want it to print 'b'?

[21:13] <masak> me consults spec.

[21:13] <masak> er,

[21:13] <moritz_> then you need to conform to the spec :-)

[21:13] * masak consults spec

[21:13] <masak> right, it says that nowadays, doesn't it?

[21:14] *** grew joined
[21:17] <masak> b.key seems to be what I want.

[21:17] <masak> so, the next question seems to be: what's an enum object?

[21:18] <masak> std: enum Day { "Sun", "Mon", "Tue" }

[21:18] <p6eval> std 31768: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'Day' (see line 1) at /tmp/YUDK394xHc line 1:␤------> [32menum Day[33m⏏[31m { "Sun", "Mon", "Tue" }[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at

[21:18] <p6eval> ../tmp/YUDK39…

[21:18] <masak> TimToady: ^

[21:18] <masak> TimToady: could easily be less LTA for people who think {} are OK for enums.

[21:19] <moritz_> std: s :g /1/1/

[21:19] <p6eval> std 31768: OUTPUT«ok 00:01 115m␤»

[21:19] <moritz_> std: my $g = 1; s :$g /1/1/

[21:19] <p6eval> std 31768: OUTPUT«[31m===[0mSORRY![31m===[0m␤Colons may not be used to delimit quoting constructs at /tmp/dYSAx5qxKS line 1:␤------> [32mmy $g = 1; s :[33m⏏[31m$g /1/1/[0m␤    expecting colon pair (restricted)␤Parse failed␤FAILED 00:01 117m␤»

[21:21] *** pmurias left
[21:21] *** [particle] left
[21:22] <masak> no, that does not appear to be the question. the question seems to be: what is it that 'b' yields, that has all these nice properties?

[21:24] <tylercurtis> std: enum Foo { "Bar", "Baz", "Gimle" }

[21:24] <p6eval> std 31768: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'Foo' (see line 1) at /tmp/J9a5aI9caH line 1:␤------> [32menum Foo[33m⏏[31m { "Bar", "Baz", "Gimle" }[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at

[21:24] <p6eval> ../tmp/J9a5…

[21:25] <masak> it needs to be an instance of an anon class subclassed from Int, and with its own .Str, .key, .value, .kv methods, among others.

[21:25] <PerlJam> masak: b isa E

[21:25] <masak> PerlJam: right.

[21:25] <masak> but also b isa Int.

[21:26] *** [particle] joined
[21:27] <moritz_> \o/ it seems that pmichaud++'s last nqp-rx fix also made it possible to parse s:g///

[21:27] <moritz_> but currently I haz teh dumb, and can't figure out the action methods

[21:27] <moritz_> ah well, tomorrow

[21:28] <colomon> \o/

[21:28] <masak> \o/

[21:28] * colomon haz teh dumb and tired

[21:28] <masak> jaffa4 will be so happy!

[21:28] <moritz_> yeah, tired too

[21:29] <moritz_> oh, it seems nqp-rx doesn't like $0

[21:29] <moritz_> nqp: say($0)

[21:29] <p6eval> nqp: OUTPUT«Confused at line 1, near "say($0)"␤current instr.: 'parrot;HLL;Grammar;panic' pc 552 (src/cheats/hll-grammar.pir:205)␤»

[21:29] <colomon> nqp: say($/[0])

[21:29] <p6eval> nqp: OUTPUT«Symbol '$/' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:109)␤»

[21:29] *** hercynium joined
[21:29] <masak> rakudo: class E {}; sub b { return (class :: is Int is E { method key { "b" } }).new }; say b() ~~ E; say b() ~~ Int; say b.key.perl

[21:29] <moritz_> better

[21:29] <p6eval> rakudo c0df20: OUTPUT«1␤1␤"b"␤»

[21:30] <masak> jnthn: I need to do this in the enum thingy. do you think it's easy? :)

[21:30] <moritz_> just use the cool meta object API

[21:30] <colomon> cons!  That's the name of the old perl 5 make replacement I was trying to think of the other day....

[21:31] <masak> moritz_: do I need to? all I need to do is create that subclass.

[21:31] <masak> hm, maybe I can do all this in pure Perl 6.

[21:31] * masak looks at the enums source

[21:31] <tylercurtis> masak: don't forget about Str valued enums. :)

[21:32] <masak> tylercurtis: oh, this is just an example :)

[21:32] <masak> tylercurtis: think of Int as a parameter here.

[21:32] <moritz_> masak: you don't need to create that subclass, but you need to emit code that creates the subclas

[21:32] <masak> moritz_: right.

[21:32] <masak> jnthn: I need to emit code that creates that subclass. :P

[21:35] * moritz_ is so > < close to a hacky :g implementation

[21:37] <masak> I distrust any kind of measurement 

[21:37] <masak> which depends on my font size. :P

[21:37] <moritz_> ./perl6 -e 'my $x = "foo"; $x ~~ s:g/o/u/; say $x'

[21:37] <moritz_> ===SORRY!===

[21:37] <moritz_> undefined identifier 'Capture'

[21:37] <moritz_> ah well, not as close as I thought :-)

[21:37] <masak> besides, '> <' looks like Cartman's eyes when he's mad. :)

[21:38] *** Guest21067 left
[21:40] <tylercurtis> rakudo: class Quox {has $.nu; } my Quox $q .= new(:nu<5>); $q.nu.say;

[21:40] <p6eval> rakudo c0df20: OUTPUT«===SORRY!===␤Confused at line 22, near "class Quox"␤»

[21:41] <masak> tylercurtis: };

[21:41] <tylercurtis> rakudo: class Quox {has $.nu; }; my Quox $q .= new(:nu<5>); $q.nu.say;

[21:41] <p6eval> rakudo c0df20: OUTPUT«5␤»

[21:41] <tylercurtis> masak: oops. I left out the ; after the class.

[21:41] <moritz_> rakudo: quox

[21:41] <p6eval> rakudo c0df20: OUTPUT«Could not find sub &quox␤  in main program body at line 22:/tmp/7KTBT0xLP1␤»

[21:41] <moritz_> note that it's not "confused" anymore

[21:42] <masak> \o/

[21:43] <PerlJam> moritz_: sure it is, watch ...

[21:43] <PerlJam> rakudo: class Q {}; Q.new   #  ;-)

[21:43] <p6eval> rakudo c0df20: OUTPUT«===SORRY!===␤Confused at line 22, near "Q.new   # "␤»

[21:43] <masak> hm.

[21:43] <masak> bug or not?

[21:44] <masak> std: class Q {}; Q.new

[21:44] <PerlJam> rakudo: class R {}; R.new;

[21:44] *** tadzik joined
[21:44] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Couldn't find terminator . at /tmp/_3dydyElgX line 1 (EOF):␤------> [32mclass Q {}; Q.new[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 114m␤»

[21:44] <p6eval> rakudo c0df20:  ( no output )

[21:44] <PerlJam> rakudo: class S {}; S.new;

[21:44] <masak> ah. no bug.

[21:44] <p6eval> rakudo c0df20:  ( no output )

[21:44] <PerlJam> rakudo: class Z {}; Z.new;

[21:44] <p6eval> rakudo c0df20:  ( no output )

[21:44] *** ash_ joined
[21:45] <tylercurtis> std: class 'foo' { }

[21:45] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse class definition at /tmp/jLLDJP9dOE line 1:␤------> [32mclass [33m⏏[31m'foo' { }[0m␤    expecting any of:␤  name␤   trait␤Parse failed␤FAILED 00:01 113m␤»

[21:45] <tylercurtis> std: class "foo" { }

[21:45] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse class definition at /tmp/7ikPWoeIh7 line 1:␤------> [32mclass [33m⏏[31m"foo" { }[0m␤    expecting any of:␤  name␤   trait␤Parse failed␤FAILED 00:01 113m␤»

[21:46] <tylercurtis> std: class Q {foo} { }

[21:46] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/L5w6rPj7Kx line 1:␤------> [32mclass Q {foo} [33m⏏[31m{ }[0m␤    expecting infix or meta-infix␤Undeclared routine:␤ 'foo' used at line

[21:46] <p6eval> ..1␤Pars…

[21:46] <PerlJam> It's a bug in both STD and Rakudo IMHO

[21:46] <moritz_> why?

[21:47] <tylercurtis> Why shouldn't Q be valid as a class name?

[21:47] <masak> PerlJam: you start the quote with 'Q.' and never end with a '.'

[21:47] *** stkowski left
[21:47] <masak> tylercurtis: it *is* a valid class name.

[21:47] <tylercurtis> std: class Q { }

[21:47] <p6eval> std 31770: OUTPUT«ok 00:01 114m␤»

[21:47] <tylercurtis> ....

[21:47] * tylercurtis thought he had done that.

[21:47] <tylercurtis> Ah. Right.

[21:48] <masak> :)

[21:48] <tylercurtis> rakudo: class Q { }

[21:48] <PerlJam> masak: Sure ... how do I make a new Q though?

[21:48] <p6eval> rakudo c0df20:  ( no output )

[21:48] <masak> PerlJam: you have to be creative.

[21:48] <tylercurtis> rakudo: class Q { }; ::Q.new;

[21:48] <p6eval> rakudo c0df20:  ( no output )

[21:48] <tylercurtis> rakudo: class Q { }; ::Q.new; say 'alive'

[21:48] <p6eval> rakudo c0df20: OUTPUT«alive␤»

[21:48] <PerlJam> I guess it's more of a LTA error message than a bug per se

[21:48] <masak> rakudo: class Q {}; say eval('Q').new

[21:48] <p6eval> rakudo c0df20: OUTPUT«Q()<0x8451070>␤»

[21:49] <masak> PerlJam: yes.

[21:49] <tylercurtis> PerlJam: do something that will prevent it being parsed as a quote. 

[21:49] <tylercurtis> rakudo: class Q { }; ::Q.new.perl.say;

[21:49] <p6eval> rakudo c0df20: OUTPUT«Q.new()␤»

[21:49] <masak> PerlJam: do we need an error message for people who happen to create a class Q? :)

[21:49] <masak> maybe we do...

[21:49] <tylercurtis> masak: a warning, perhaps.

[21:50] <PerlJam> rakudo:  class q {}; class qq {};   # there are others  :)

[21:50] <p6eval> rakudo c0df20:  ( no output )

[21:51] <tylercurtis> class s { }; s.new;

[21:51] <tylercurtis> rakudo: class s { }; s.new;

[21:51] <p6eval> rakudo c0df20:  ( no output )

[21:51] <tylercurtis> rakudo: class s { }; s.new.perl.say;

[21:51] <p6eval> rakudo c0df20: OUTPUT«s.new()␤»

[21:52] <PerlJam> or we accept that these are minor edge cases that should be rare in practice (except for obfuscation contests)

[21:52] <tylercurtis> rakudo: class q { }; q.new.perl.say;

[21:53] <p6eval> rakudo c0df20: OUTPUT«===SORRY!===␤Confused at line 22, near "q.new.perl"␤»

[21:53] <PerlJam> std: class q {}; q.new;

[21:53] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Couldn't find terminator . at /tmp/0jhDoqQBPo line 1 (EOF):␤------> [32mclass q {}; q.new;[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 114m␤»

[21:53] * jnthn back

[21:53] <PerlJam> (just making sure std dies like I thought)

[21:53] <tylercurtis> std: class s {}; s.new;

[21:53] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Regex missing terminator (or semicolon must be quoted?) at /tmp/qsXACV5nDS line 1 (EOF):␤------> [32mclass s {}; s.new;[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 116m␤»

[21:54] <tylercurtis> s.new shouldn't work but does in Rakudo.

[21:54] <jnthn> masak: pong

[21:54] <jnthn> masak: "How is class formed?" :-)

[21:54] <masak> jnthn: yes. :)

[21:54] <jnthn> masak: I'd imagined more that you'd form a role and mix it into the enum value.

[21:55] <masak> hm, that's probably better.

[21:55] <jnthn> masak: Anyway, for forming class glace over Test::Mock since it does that

[21:55] <jnthn> For role, see operators.pm

[21:55] <masak> sounds great. will do.

[21:55] <jnthn> masak: line 155

[21:55] <huf> q\ .new; seems to work, why? :)

[21:55] <masak> huf: 

[21:56] <masak> huf++

[21:56] <huf> breaks up the q.. construct?

[21:56] <PerlJam> unspace is our friend :)

[21:56] <tylercurtis> std: class q { }; q\ new;

[21:56] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Whitespace is required between alphanumeric tokens at /tmp/20HrJwQHzL line 1:␤------> [32mclass q { }; q\ ne[33m⏏[31mw;[0m␤Undeclared routine:␤     'w' used at line 1␤Check failed␤FAILED 00:02 116m␤»

[21:56] <tylercurtis> std: class q { }; q\ .new;

[21:56] <p6eval> std 31770: OUTPUT«ok 00:01 114m␤»

[21:57] <jnthn> masak: Mixing a role into the enum values maybe ain't too hard, anyway.s

[21:57] <masak> jnthn: this feels very hopeful right now.

[21:57] *** pyrimidine left
[21:58] <jnthn> \o/

[21:58] <masak> jnthn: mind if I change the $do-it-to-me vars to $doee right away? :P

[21:59] <jnthn> :P

[21:59] <jnthn> masak: Isn't doee a bad spelling of the Dutch for "goodbye"? :-)

[22:00] <masak> no, it's a perfectly good made-up English word.

[22:01] <jnthn> Ah, apparently the orrect spelling is "doei"

[22:01] *** justatheory left
[22:01] *** drbean left
[22:02] <tadzik> oh. How does eval() work in Perl 6? After the code is compiled to .pbc, is it compiled by rakudo again?

[22:02] *** ruoso left
[22:03] <dalek> rakudo: 0b12127 | masak++ | src/core/operators.pm:

[22:03] <dalek> rakudo: [operators.pm] changed parameter name

[22:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0b12127ac482251495a0d58d45e1ba1a0bc002f9

[22:03] <jnthn> tadzik: It just compiles the string inside the eval

[22:04] <Tene> tadzik: The compiled pbc has a string constant (or code to generate a string), and then at runtime, the generated code calls back into the compiler again, passing it the string as input.

[22:04] <jnthn> Well, the string passed to eval

[22:04] <tadzik> So, using eval, it's impossible to use the compiled code without having rakudo around?

[22:04] *** dakkar left
[22:05] <jnthn> tadzik: It is anyway really, give you also need all the built-ins etc.

[22:05] <jnthn> *given

[22:06] <jnthn> But yes, technically we could separate out the two and have some eval-less Rakudo that was smaller.

[22:06] <tadzik> oh well, it's impossible to compile the Perl 6 code so it would be usable with bare parrot, w/o rakudo?

[22:07] *** xabbu42 left
[22:07] *** payload joined
[22:07] *** skids left
[22:07] <jnthn> tadzik: To some degree yes because you still need all the built-in types, the signature binder, multi-dispatcher, etc, which are part of Rakudo, not part of Parrot.

[22:07] <tadzik> mhm

[22:11] <masak> 'night, #perl6

[22:11] *** masak left
[22:15] <tadzik> I feel like porting something to Perl 6. Even if it would be Acme::Meow

[22:17] <jnthn> Go for it! :-)

[22:17] <Tene> tadzik: Do it!

[22:17] <tadzik> I thought about something more sophisticated :)

[22:17] <tadzik> But well, will Acme::Meow get into proto? :P

[22:18] <jnthn> If lolsql did... :P

[22:18] <tadzik> ;)

[22:18] <tadzik> let's see

[22:20] *** justatheory joined
[22:21] <tadzik> erm, is <3 a valid variable name?

[22:21] <tadzik> maybe I won't rewrite it line-by-line :)

[22:21] <arnsholt> std: my $<3;

[22:22] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Whitespace required before < operator at /tmp/LCSQYcdM_G line 1:␤------> [32mmy $<[33m⏏[31m3;[0m␤    expecting escape␤Parse failed␤FAILED 00:01 115m␤»

[22:22] <tylercurtis> std: class Foo { has $.<3; }

[22:22] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed has at /tmp/BOoVKoHCuM line 1:␤------> [32mclass Foo { has $[33m⏏[31m.<3; }[0m␤    expecting twigil␤Parse failed␤FAILED 00:01 115m␤»

[22:23] <huf> std: class Foo { has $.❥ }

[22:23] <tylercurtis> .u heart

[22:23] <phenny> U+2766 FLORAL HEART (❦)

[22:24] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed has at /tmp/qfjYLTnVsi line 1:␤------> [32mclass Foo { has $[33m⏏[31m.❥ }[0m␤    expecting twigil␤Parse failed␤FAILED 00:01 115m␤»

[22:24] <huf> wut

[22:27] <tylercurtis> rakudo: say ('❥' ~~ /<alpha>/).Bool # huf;

[22:27] <p6eval> rakudo c0df20: OUTPUT«0␤»

[22:27] <huf> oh of course

[22:28] <tylercurtis> tadzik: you could use $!_❥. :)

[22:28] <tadzik> :P

[22:31] <tylercurtis> Although I don't think there's a unicode character for ^_^.

[22:31] *** justatheory left
[22:32] *** justatheory joined
[22:32] *** au|zzz is now known as au|irc

[22:32] <au|irc> tylercurtis: 〠 is close :)

[22:32] <lue> ohai o/

[22:32] <lue> .u 〠

[22:32] <phenny> U+3020 POSTAL MARK FACE (〠)

[22:34] <tylercurtis> tadzik: nevermind, that wouldn't work.

[22:34] <tylercurtis> rakudo: my $_❥;

[22:34] <p6eval> rakudo c0df20: OUTPUT«===SORRY!===␤Redeclaration of symbol $_ at line 22, near "\u2765;"␤»

[22:35] <tylercurtis> std: my $_❥;

[22:35] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/lFzrTHbq5x line 1:␤------> [32mmy $_[33m⏏[31m❥;[0m␤    expecting any of:␤    POST␤   bracketed infix␤    constraint␤     infix or meta-infix␤        postfix␤        postfix_prefix_meta_operator␤       shape definition␤      

[22:35] <p6eval> ..statement modifier loop␤   trait␤Other potent…

[22:35] <tadzik> hmm

[22:35] <tadzik> http://search.cpan.org/~foolish/Acme-Meow-0.01/lib/Acme/Meow.pm#milk_-_give_milk_to_a_kitty.

[22:35] <tadzik> „if not called directly on a kitty, $_ will be checked for a kitty;” Is there a way to do this in Perl 6?

[22:38] *** clintongormley left
[22:39] *** Alias left
[22:40] <jnthn> std: "foo" ~~ /(foo)/; say "$0a"

[22:40] <p6eval> std 31770: OUTPUT«ok 00:01 119m␤»

[22:40] *** justatheory left
[22:41] <au|irc> rakudo: say my $ପ = my $ෆ = my $Ꙭ  = 1;

[22:41] <p6eval> rakudo c0df20: OUTPUT«===SORRY!===␤Malformed my at line 22, near "$\ua66c  = 1;"␤»

[22:41] <au|irc> rakudo: my $ପ ; my $ෆ ;

[22:41] <p6eval> rakudo c0df20:  ( no output )

[22:42] <au|irc> weird. the $Ꙭ form worked on github checkout.

[22:42] *** snarkyboojum joined
[22:43] *** justatheory joined
[22:43] <tadzik> hmm, does perl6 -c work for you?

[22:44] *** nbrown left
[22:44] <tylercurtis> tadzik: I'm not sure.

[22:45] <tylercurtis> tadzik: although even if it's possible, it's somewhat un-Perl-6-ish.

[22:45] <tylercurtis> tadzik: if you want to give milk to the kitty in $_ you can do ".milk"

[22:46] <tadzik> tylercurtis: I was thinking if it's possible to emulate the Perl 5 behaviour, from inside the class

[22:46] <tylercurtis> rakudo: class Meow { method milk { say 'Kitty likes milk'; } }; Meow.new.milk; 

[22:46] <p6eval> rakudo c0df20: OUTPUT«Kitty likes milk␤»

[22:47] <tadzik> hmm

[22:47] <tadzik> I must be doing something wrong

[22:48] <tylercurtis> rakudo: class Meow { our method method milk ($self = $_:) { say 'Kitty likes milk'; } }; Meow.new.milk; 

[22:48] <p6eval> rakudo c0df20: OUTPUT«===SORRY!===␤Malformed method at line 22, near "method mil"␤»

[22:48] <tylercurtis> rakudo: class Meow { method milk { say 'Kitty likes milk'; } }; $_ = Meow.new; .milk

[22:48] <p6eval> rakudo c0df20: OUTPUT«Kitty likes milk␤»

[22:50] *** tadzik1 joined
[22:50] <tadzik1> I was having so much fun I didn't notice my battery dying :)

[22:51] <tadzik1> anyway, here's my code: http://wklej.org/id/366612/

[22:52] *** tadzik left
[22:52] <tadzik1> now use Acme::Meow; and my $c = Acme::Meow.new gives me "Can not find sub Acme::Meow". What am I doing wrong?

[22:53] <au|irc> "class Acme::Meow"?

[22:53] *** ive left
[22:53] <tylercurtis> tadzik1: that creates a class Me...what au|irc said.

[22:53] <tadzik1> oh, probably

[22:54] <tadzik1> yay, it works :)

[22:55] <tylercurtis> Hmm... a friend of mine wrote his first Perl 5 scripts today. He had some problems he said should be fixed in Perl 6. "it was too easy / user friendly took most of the challenge out of doing anything" "i didn't have to hunt for obscure functions or libaries really not cool.." lol

[22:56] * au|irc is tempted to golf "self.is_sleeping" to "$.is_sleeping" (they are synonyms)...

[22:56] <au|irc> ...but I guess the explicit method form reads more clearly

[22:57] <jnthn> au|irc: Think they're not quite synonyms - iirc the latter enforces item context.

[22:58] <au|irc> which, the if() will do anyway

[22:58] <au|irc> but yeah, they're not synonyms always :)

[22:59] <jnthn> Ah, OK, I hadn't go to reading the code that supplied the context yet. :-)

[22:59] * jnthn is on a bug hunt

[22:59] <au|irc> rock on :D

[22:59] <tadzik1> just let me finish, then patches will be welcome :

[22:59] <tadzik1> :)

[23:00] <tadzik1> (is there a chance that it would be the first module completely ported from Perl 5 to Perl 6? :P)

[23:01] <jnthn> Anyone got opinions on what "$0a" would do?

[23:02] <jnthn> At the moment in Rakudo, it dies with a very unhelpful error. I can make it do better things but should it...

[23:02] <jnthn> * Die?

[23:02] <jnthn> * Not interpolate?

[23:02] <jnthn> * Be like "{$0}a"

[23:02] <jnthn> ?

[23:04] *** meppl left
[23:05] * Juerd will remove /home/*/.ccache from feather1

[23:06] *** japhb left
[23:06] <Juerd> http://juerd.nl/i/817cfe0661546f4fd40c7af7a91f1180.png  # It doesn't remove old files by itself :)

[23:08] <tylercurtis> tadzik1: should  the kitty's status be '=-_-=' when $!love is greater than 5 or when it's less?

[23:08] <tadzik1> tylercurtis: I find it weird, but the Perl 5 version shows this bored face when $!love is > 5

[23:08] <tadzik1> we can change it though, then we will have happier and loved kitties in Perl 6

[23:08] *** tadzik1 is now known as tadzik

[23:09] <au|irc> jnthn: "{$0}a" is least surprise imvho

[23:09] <tylercurtis> tadzik: everyone's happier in Perl 6 :) even kitties.

[23:09] <tadzik> yeah, that's the way to go :)

[23:09] <tadzik> we're breaking compatibility anyway ;)

[23:10] <tadzik> I'll write some tests and push it to GH :)

[23:10] <jnthn> au|irc: I just found I have some discrepancies with STD.pm, trying to sync up with those to see what happens too. :-)

[23:13] <tadzik> how do I run tests? I tried 'prove --exec perl6 -r t' like in Advent Calendar, but it's not aware of lib/ then

[23:14] <tylercurtis> tadzik: add lib/ to your PERL6LIB.

[23:14] <au|irc> jnthn: std parses that as "{$0}a" via LTM...

[23:15] <tadzik> yeah, works

[23:17] <jnthn> au|irc: Ah, I was wondering which way STD got it as OK. Thanks.

[23:17] <au|irc> glad to help :)

[23:20] *** japhb joined
[23:22] <tadzik> rakudo: /=-_-=/.WHAT.say

[23:22] <p6eval> rakudo 0b1212: OUTPUT«===SORRY!===␤Confused at line 22, near "/=-_-=/.WH"␤»

[23:22] <tadzik> what needs to be escaped here?

[23:22] <tadzik> = and -, ok

[23:22] <jnthn> do you want to match those chars literally?

[23:23] <jnthn> /'=-_-='/ is probably neatest if so

[23:23] <tadzik> well, I need to check if a string contains =-_-=

[23:23] *** whiteknight joined
[23:23] <tadzik> and thought about smart mathing

[23:23] <tadzik> oh, great

[23:23] <tadzik> but…

[23:23] <tadzik> rakudo: say 'ok' if /'=-_-='/ ~~ "=-_-="

[23:23] <p6eval> rakudo 0b1212:  ( no output )

[23:24] <au|irc> rakudo: say 'ok' if "=-_-=" ~~ /'=-_-='/

[23:24] <p6eval> rakudo 0b1212: OUTPUT«ok␤»

[23:24] <tadzik> oh

[23:24] <jnthn> Smart-match doesn't commute.

[23:25] <au|irc> RHS dominates

[23:25] <jnthn> It prefers to work from home.

[23:25] <au|irc> ahh so ~~ stands for the telecommuting wires

[23:26] * jnthn saves that mnemonic for when he's next teaching Perl 6

[23:30] <tadzik> rakudo: class foo { method bar { 'asd' } }; my $a = foo.new; $a.can('bar')

[23:30] <p6eval> rakudo 0b1212:  ( no output )

[23:30] <tadzik> ===SORRY!===

[23:30] <tadzik> get_string() not implemented in class 'P6Invocation'

[23:30] <tadzik> why so?

[23:32] <jnthn> P6Invocation ain't meant to leak out

[23:33] <tadzik> bug?

[23:33] <au|irc> rakudo: class foo { method bar { 'asd' } }; my $a = foo.new; sau 

[23:34] <p6eval> rakudo 0b1212: OUTPUT«Could not find sub &sau␤  in main program body at line 22:/tmp/XyveGSBtUG␤»

[23:34] <au|irc> rakudo: class foo { method bar { 'asd' } }; my $a = foo.new; say 'ok' if $a.can('bar')

[23:34] <p6eval> rakudo 0b1212: OUTPUT«ok␤»

[23:34] <tadzik> duh

[23:34] <au|irc> so boolean context works, just not string

[23:35] <jnthn> *nod*

[23:35] <jnthn> Ah, I remember now...I didn't fix the "list of methods" return part of it 'cus lists were still in flux at that point.

[23:35] <jnthn> And didn't get to re-visit it since.

[23:36] <jnthn> ETOOMUCHTODO

[23:36] <au|irc> it's ok. *writes to [email@hidden.address]
[23:37] *** rgrau_ left
[23:37] <tadzik> http://github.com/tadzik/Acme-Meow-perl6

[23:37] <tadzik> :)

[23:38] <au|irc> tadzik++

[23:38] <tadzik> my first module ever

[23:38] <jnthn> au|irc: Thanks. :)

[23:38] <au|irc> tadzik: many more to come, surely :D

[23:38] <tadzik> au|irc: thanks :)

[23:38] <tadzik> I hope so :)

[23:38] *** bkeeler left
[23:39] <jnthn> Tssk. So I've now brought Rakudo's grammar closer to STD in a couple of ways (though now I gotta face the spectests)...but sadly it didn't make the "$0a" case any better.

[23:39] <jnthn> rakudo: say $

[23:39] <tadzik> I was talking about Perl 6 on today's local Perl workshop, guys were pretty excited. We're planning to celebrate rakudo star on the next friday, maybe we will port something more significant then ;)

[23:39] <p6eval> rakudo 0b1212: OUTPUT«===SORRY!===␤Confused at line 22, near "say $"␤»

[23:39] <jnthn> At least that's gonna have a decent error now

[23:39] <jnthn> std: say $

[23:39] <p6eval> std 31770: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name at /tmp/5FOKEYBFOm line 1:␤------> [32msay [33m⏏[31m$[0m␤Confused at /tmp/5FOKEYBFOm line 1:␤------> [32msay $[33m⏏[31m<EOL>[0m␤    expecting twigil␤Other potential difficulties:␤  Unsupported use of

[23:39] <p6eval> ..b…

[23:51] *** _mpu left
[23:56] *** Psyche^ joined
