[00:00] <Limbic_Region> ;-)

[00:00] <TimToady> yowsers, not even my browser has the \o/ character...

[00:00] <rjbs> TimToady: It's one of the new Unicode 6 Emoji, I believe.

[00:00] <rjbs> TimToady: You know about PILE OF POO, right?

[00:01] <rjbs> I've been waiting for someone to write a PILE OF POO operator for p6... but then we'd end up with hyperpoo -- but maybe a poo-reduce would help with that problem.

[00:01] <TimToady> Limbic_Region: http://rosettacode.org/wiki/Pattern_matching is really about red-black trees

[00:01] * Limbic_Region chuckles and steps AFK &

[00:02] <Limbic_Region> TimToady - I am looking at AVLs, red-black trees, etc - all of the self-balancing binary trees

[00:02] <TimToady> that's a problem with rosettacode; it's not well indexed by what you really want to look up

[00:02] <TimToady> in fact, an implementation of red-black could be very useful in P6

[00:03] <Limbic_Region> TimToady - have you seen http://eternallyconfuzzled.com/jsw_home.aspx

[00:03] <sjohnson> what's baby C?  sounds cute

[00:03] <Limbic_Region> all of the source is C, but the commentary is very understandable

[00:04] <Limbic_Region> I tend to implement based on plain english explanations anyway

[00:04] <Limbic_Region> and now I really must go AFK &

[00:04] <sorear> has anyone played with NDP for Perl 6?

[00:04] <TimToady> Natural Data Processing?

[00:04] <sorear> nested data parallelism

[00:05] <TimToady> please leave a pointer, I have to go too.

[00:05] <TimToady> afk &

[00:05] * sjohnson learns baby C

[00:07] <flussence> I want to learn C some day, but I don't want to learn autotools...

[00:07] *** jferrero left
[00:07] *** leprevost joined
[00:08] <flussence> actually I'd prefer D first, it looks nice

[00:11] <sjohnson> get 2nd ed K&R C book

[00:11] <sjohnson> and kiss autotools goodbye!

[00:15] *** lichtkind left
[00:15] *** aloha joined
[00:30] *** patspam left
[00:35] *** justatheory left
[00:45] *** leprevost left
[00:54] <colomon> red-black trees, eh?

[01:00] *** justatheory joined
[01:25] *** risou joined
[01:27] *** leprevost joined
[01:30] *** aindilis joined
[01:35] <ash_> my only problem with D is they took everything in every other language and threw it into C++ and renamed it D, but it just has a HUGE amount of reserved words and stuff, but they aren't really what i would call organized as as thought out as they could be

[01:35] <ash_> there is only so much you can tack on before you need to reconsider your overall design 

[01:35] *** fod left
[01:40] *** meppl left
[01:46] *** Chillance joined
[01:55] *** qw3rty joined
[01:57] *** Limbic_Region left
[02:03] <qw3rty> hi

[02:04] *** kid51 joined
[02:05] <qw3rty> i'm still thinking about the fraction problem i posted here yesterday:    for 1..60 -> $n { say "n=$n"; for 1..$n { $n %% $^a ?? say "\t$a/" ~ $n/$a !! 0 } }

[02:05] *** astinus left
[02:05] <qw3rty> it generates fractions with the condition that numerator * denominator are equal to $n

[02:06] <qw3rty> i saw that you can put constrained data types.... how could i do that program with constraints? (using "where", etc)

[02:07] <ash_> rakudo: sub f($a where { $a > 10 }) { say $a }; f 15; f 10;

[02:07] <p6eval> rakudo a820a4: OUTPUT«15␤Constraint type check failed for parameter '$a'␤  in 'f' at line 22:/tmp/oIh6f50G5L␤  in main program body at line 22:/tmp/oIh6f50G5L␤»

[02:08] <ash_> first one passes, the 2nd complains about the constraint 

[02:08] *** astinus joined
[02:09] <ash_> constraints don't have to be where clauses though

[02:09] <ash_> rakudo: multi f(Int $a) { say "Int" }; multi f(Str $a) { say "Str" }; f 1; f 'a';

[02:09] <p6eval> rakudo a820a4: OUTPUT«Int␤Str␤»

[02:10] <ash_> those are constraints that are based off of type

[02:11] <qw3rty> rakudo: sub f($a, $b, $c where {$a * $b == $c}){ say "$a/$b" }; f(2,5,10)

[02:11] <ash_> rakudo: say <a b c>[1..2]

[02:11] <p6eval> rakudo a820a4: OUTPUT«2/5␤»

[02:11] <p6eval> rakudo a820a4: OUTPUT«bc␤»

[02:12] *** astinus left
[02:13] <qw3rty> rakudo: sub f($a, $b, $c where {$a * $b == $c}){ say "$a/$b" }; f(2,5,11)

[02:13] <p6eval> rakudo a820a4: OUTPUT«Constraint type check failed for parameter '$c'␤  in 'f' at line 22:/tmp/kKFmll5TzE␤  in main program body at line 22:/tmp/kKFmll5TzE␤»

[02:13] *** astinus joined
[02:13] <qw3rty> cool 8)

[02:16] <ash_> so what were you trying to do again?

[02:17] *** leprevost left
[02:17] <qw3rty> http://irclog.perlgeek.de/perl6/2010-09-23#i_2855389

[02:17] <qw3rty> that

[02:18] *** astinus left
[02:18] <qw3rty> but taking advantage of everything perl6 has to offer :)

[02:18] <qw3rty> of which i know little... 

[02:19] <qw3rty> yet

[02:19] *** astinus joined
[02:19] *** astinus left
[02:19] *** astinus joined
[02:20] *** kid51 left
[02:20] *** cdarroch left
[02:21] <qw3rty> mmm the link does not seem to work... well, there is the problem:

[02:21] <qw3rty> here's the original problem for the line i posted "Create an ordered list of fractions which product of the numerator and denominator equals a specific integer n.

[02:21] <qw3rty>  ex: n=60

[02:21] <qw3rty>  1/60, 2/30, 3/20, 4/15, 5/12, etc....

[02:21] <qw3rty>  then do it with a list of integers."

[02:22] *** ggoebel joined
[02:24] *** astinus left
[02:24] *** astinus joined
[02:27] <ash_> rakudo: sub fn($n) { for 1..$n -> $a { for 1..$a -> $b { say "$b/$a" if $a * $b == $n } } }; fn(60);

[02:27] <p6eval> rakudo a820a4: OUTPUT«(timeout)␤4/15␤3/20␤2/30␤»

[02:28] <ash_> that doesn't seem optimal

[02:28] <ash_> but it does give the correct answer 

[02:28] <ash_> if you run it on your local machine it won't time out 

[02:28] <ash_> rakudo: sub fn($n) { for ^$n -> $a { for ^$a -> $b { say "$b/$a" if $a * $b == $n } } }; fn(60);

[02:28] <p6eval> rakudo a820a4: OUTPUT«(timeout)␤4/15␤3/20␤2/30␤»

[02:30] <qw3rty> ok i'll try it

[02:30] *** synth left
[02:31] *** rgrau_ left
[02:31] <ash_> sub fn($n) { for ^$n -> $a { for ^$a -> $b { say "$b/$a\n$a/$b" if $a * $b == $n } } }; fn(60);

[02:32] <ash_> rakudo: sub fn($n) { for ^$n -> $a { for ^$a -> $b { say "$b/$a\n$a/$b" if $a * $b == $n } } }; fn(60);

[02:32] <p6eval> rakudo a820a4: OUTPUT«(timeout)␤5/12␤12/5␤4/15␤15/4␤3/20␤20/3␤2/30␤30/2␤»

[02:33] <ash_> sub fn($n) { for 1..$n -> $a { for 1..$a -> $b { say "$b/$a" if $a * $b == $n } } }; fn(60);

[02:33] <ash_> hmm

[02:33] <ash_> you cant do ^$n because that skips $n, so you do need 1..$n

[02:33] <ash_> i still think its checking some of those cases more than once

[02:33] <ash_> which means its sub optimal 

[02:35] *** astinus left
[02:35] <ash_> rakudo: sub fn($n) { for ($n.sqrt.floor)..$n -> $a { for 1..$a -> $b { say "$b/$a" if $a * $b == $n } } }; fn(60);

[02:35] <p6eval> rakudo a820a4: OUTPUT«(timeout)␤4/15␤3/20␤2/30␤»

[02:35] <ash_> there, that doesn't check as many cases with repeats 

[02:35] <ash_> still i bet you can do better

[02:36] *** astinus joined
[02:37] *** synth joined
[02:38] *** leprevost joined
[02:44] <qw3rty> mmm can i make a construct like "@num=1..60; @denom=1..60; ... ; where any(@num) * one(@denom) == 60" ... ? 

[02:46] <ash_> rakudo: sub fn($n) { map { ($n/$_) ~ "/$_"  }, grep { $n %% $^a }, 1..(60.sqrt.ceiling) }; fn 60

[02:46] <p6eval> rakudo a820a4:  ( no output )

[02:46] <ash_> rakudo: sub fn($n) { map { ($n/$_) ~ "/$_"  }, grep { $n %% $^a }, 1..(60.sqrt.ceiling) }; say fn(60)

[02:46] <p6eval> rakudo a820a4: OUTPUT«60/130/220/315/412/510/6␤»

[02:46] <ash_> rakudo: sub fn($n) { map { ($n/$_) ~ "/$_"  }, grep { $n %% $^a }, 1..(60.sqrt.ceiling) }; say ~fn(60)

[02:46] *** astinus_ joined
[02:46] *** nymacro joined
[02:46] <p6eval> rakudo a820a4: OUTPUT«60/1 30/2 20/3 15/4 12/5 10/6␤»

[02:46] *** astinus left
[02:46] <ash_> that doesn't do hardly any re-calculating

[02:46] <qw3rty> hehe,... cool

[02:47] <ash_> i can't think of how to get it more effective than that... 

[02:47] <ash_> if you need the other half of the list (the 1/60, etc...) you can just take the list and flip it

[02:48] <qw3rty> thanks... i will study that line :)

[02:48] <ash_> rakudo: sub fn($n) { map { ($n/$_) ~ "/$_"  }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; say ~fn(60)

[02:48] <p6eval> rakudo a820a4: OUTPUT«60/1 30/2 20/3 15/4 12/5 10/6␤»

[02:48] <ash_> hehe, thats a bit smaller, change 1.. to ^ 

[02:48] <ash_> ^ is up to in perl6

[02:48] <ash_> rakudo: say ^60

[02:48] <p6eval> rakudo a820a4: OUTPUT«01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859␤»

[02:48] <ash_> if you use it as a prefix to a numeric that is 

[02:49] <ash_> you only have to check up to the sqrt of N in your chase, anything beyond that won't matter or will have one of those values in it already 

[02:49] <ash_> hence the $n.sqrt.ceiling 

[02:50] <ash_> sqrt of 60 is 7.something so i only check 0...7, find which ones divide evenly into 60, then those are either numerators or denominators for your list of ratios

[02:50] <ash_> fractions, whatever you want to call them

[02:51] <ash_> that gives you half the list, one sec, i'll find the other half of it real fast

[02:53] *** justatheory left
[02:54] <ash_> rakudo: sub fn($n) { map { ($n/$_),  ($_/$n) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; { (.numerator ~ '/~ .denominator).say } for fn(60)

[02:54] <p6eval> rakudo a820a4: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[02:55] *** astinus_ left
[02:56] <ash_> rakudo: sub fn($n) { map { ($n/$_ ~"/$_"),  ("$_/" ~ $n/$_) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; .say for @(fn(60));

[02:56] <p6eval> rakudo a820a4: OUTPUT«60/1␤1/60␤30/2␤2/30␤20/3␤3/20␤15/4␤4/15␤12/5␤5/12␤10/6␤6/10␤»

[02:56] *** stkowski left
[02:56] <ash_> that gives you both sides, if you want them sorted i can do that too 

[02:58] <qw3rty> i still dont understand "map" completely, the 3rd parameter ... is that like a "for" in c?

[02:59] *** ggoebel left
[02:59] <ash_> ya

[02:59] <ash_> rakudo: map *.say, 1...5

[03:00] <p6eval> rakudo a820a4: OUTPUT«No candidates found to invoke for method 'map' on object of type 'Array'; available candidates have signatures:␤:(Mu : &block;; *%_)␤␤  in 'map' at line 1758:CORE.setting␤  in main program body at line 22:/tmp/wvrwYDNU6v␤»

[03:00] <ash_> lol

[03:00] <ash_> rakudo: map { .say }, <a b c>

[03:00] <p6eval> rakudo a820a4:  ( no output )

[03:00] <ash_> i am fail right now geeze

[03:01] <ash_> rakudo: map { .say }, <a b c>

[03:01] <p6eval> rakudo a820a4:  ( no output )

[03:01] <ash_> http://try.rakudo.org/?input=map%20{%20.say%20},%20%3Ca%20b%20c%3E

[03:01] <ash_> try that

[03:02] <ash_> map takes a block and a list as params, it applies the block to the list and collects the results 

[03:02] <ash_> rakudo: say map * + 1, 1 ... 3

[03:02] <qw3rty> mmm... "Bool::True" ??

[03:02] <p6eval> rakudo a820a4: OUTPUT«No candidates found to invoke for method 'map' on object of type 'Array'; available candidates have signatures:␤:(Mu : &block;; *%_)␤␤  in 'map' at line 1758:CORE.setting␤  in main program body at line 22:/tmp/u97xtySAV7␤»

[03:02] <ash_> map doesn't like whatevercode

[03:03] <ash_> rakudo: say ~map { $_ + 1 }, 1..4

[03:03] <p6eval> rakudo a820a4: OUTPUT«2 3 4 5␤»

[03:04] <ash_> that took 1, 2, 3, 4 and added one, then collected the results, so you end up with an array that contains (2, 3, 4, 5)

[03:05] <ash_> whatever the block returns, the map collects the result 

[03:06] <ash_> it printed Bool::True because say returned True in the sample i made up (with <a b c>) 

[03:06] <qw3rty> my @list = map { .say }, <a b c d>; @list.perl.say;

[03:06] *** Guest7724 joined
[03:06] <qw3rty> rakudo: my @list = map { .say }, <a b c d>; @list.perl.say;

[03:06] <p6eval> rakudo a820a4: OUTPUT«a␤b␤c␤d␤[Bool::True, Bool::True, Bool::True, Bool::True]␤»

[03:07] <qw3rty> well now i got something to experiment with, thanks ash 4 your patience

[03:07] <qw3rty> good night!

[03:07] <qw3rty> p6 is amazing :)

[03:07] <ash_> rakudo: my @list = map { $_ + 1 }, 3..4; say ~@list;

[03:08] <p6eval> rakudo a820a4: OUTPUT«4 5␤»

[03:08] <qw3rty> my @list = map { .say }, <a b c d>; @list.perl.say;

[03:09] <qw3rty> my @list = map { $_ ~ '-' }, <a b c d>; @list.perl.say;

[03:09] <qw3rty> rakudo: my @list = map { $_ ~ '-' }, <a b c d>; @list.perl.say;

[03:09] <p6eval> rakudo a820a4: OUTPUT«["a-", "b-", "c-", "d-"]␤»

[03:09] <qw3rty> rakudo: my @list = map {  ~$_  }, <a b c d>; @list.perl.say;

[03:10] <p6eval> rakudo a820a4: OUTPUT«["a", "b", "c", "d"]␤»

[03:10] <ash_> functional programmers will use map in most places you have a for loop

[03:10] <qw3rty> rakudo: my @list = map { +$_ }, <1 2 3 4>; @list.perl.say;

[03:10] *** Guest7724 left
[03:10] <p6eval> rakudo a820a4: OUTPUT«[1, 2, 3, 4]␤»

[03:10] <qw3rty> rakudo: my @list = map { $_ }, <1 2 3 4>; @list.perl.say;

[03:10] <p6eval> rakudo a820a4: OUTPUT«["1", "2", "3", "4"]␤»

[03:11] <ash_> prefix:<+> will convert stuff to a number

[03:11] <ash_> rakudo: my @a = <a b c>; say +@a; # on an array, its the length 

[03:12] <ash_> or number of elements in the array

[03:12] <p6eval> rakudo a820a4: OUTPUT«3␤»

[03:12] <ash_> rakudo: say (+"1.23").WHAT # converted the string to an Num 

[03:12] <p6eval> rakudo a820a4: OUTPUT«Num()␤»

[03:13] <ash_> rakudo: sub postfix:<!> (Int $a) { [*] 1..$a }; say 5! 

[03:13] <p6eval> rakudo a820a4: OUTPUT«120␤»

[03:13] <ash_> btw, thats how you can add new operators to perl6, like that is the factorial operator

[03:14] <qw3rty> oh yes i saw that in a screencast

[03:15] <qw3rty> well... is late here got to go sleeping...

[03:15] <qw3rty> thanks for all again, bye!

[03:15] *** qw3rty left
[03:36] *** ash_ left
[03:43] *** astinus joined
[03:48] *** astinus left
[03:57] *** dduncan joined
[03:57] *** dduncan left
[03:59] *** DemoFreak left
[03:59] *** envi^home joined
[04:05] *** DemoFreak joined
[04:08] *** astinus_ joined
[04:08] *** astinus_ left
[04:08] *** astinus_ joined
[04:12] *** astinus_ left
[04:12] *** astinus_ joined
[04:17] *** astinus_ left
[04:24] *** astinus_ joined
[04:24] *** astinus_ left
[04:24] *** astinus_ joined
[04:34] *** alester joined
[04:35] *** Raynes left
[04:46] <shortcircuit> TimToady: I'm hoping to use Semantic MediaWiki to be able to do better indexing (based on, e.g. ideas invoked explicitly and implicitly in a task description), but that's going to have to wait until we resolve SMW performance issues. :-|

[04:47] *** flatwhatson joined
[04:48] *** Raynes joined
[04:51] *** rgrau_ joined
[04:53] *** rgrau_ left
[04:53] *** rgrau_` joined
[05:11] *** IllvilJa left
[05:11] *** leprevost left
[05:20] *** alester left
[05:22] *** Su-Shee joined
[05:22] <sorear> good * #perl6

[05:27] <sorear> Juerd: ping

[05:45] *** plobsing left
[05:58] *** kaare joined
[05:58] *** kaare is now known as Guest41340

[06:09] *** nymacro left
[06:18] *** kjeldahl joined
[06:19] *** wtw joined
[06:28] *** dual left
[06:30] <moritz_> good morning

[06:30] <sorear> hello moritz_ 

[06:32] <dalek> roast: 885149f | moritz++ | S02-builtin_data_types/bool.t:

[06:32] <dalek> roast: [bool.t] test stringification more precisely

[06:32] <dalek> roast: review: http://github.com/perl6/roast/commit/885149f5b0de839f939b557c488db6ccd409908c

[06:35] <sorear> Do [+] and [\+] guarantee a specific order of execution?

[06:35] <dalek> rakudo: 5e7b432 | moritz++ | build/PARROT_REVISION:

[06:35] <dalek> rakudo: bump PARROT_REVISION for testing

[06:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5e7b4321d00eab5d7ca852075286ad731d256feb

[06:43] <moritz_> sorear: I'm curious, how can [\+] work without order of execution?

[06:47] *** aindilis left
[06:48] *** Intensity left
[06:48] *** aindilis joined
[06:49] *** mberends joined
[06:49] *** jaldhar left
[06:49] *** jaldhar joined
[06:51] *** Intensity joined
[06:51] <sorear> moritz_: suboptimally - on a sequential machine

[06:54] * moritz_ thinks he never met a machine where out-of-order-execution would make it any faster

[06:56] *** cotto joined
[06:56] <sorear> [\+] ^($big**2) = my @a = ^($big**2); my @b = @a.natatime($big); my @c = [+]<<@b; my @d = [\+]<<@b; return @c <<+>> @d;  # look, O(sqrt N) [\+] on a machine with O(sqrt N) processors; I think there's also an O(log^2 N) recursive version

[06:56] *** btrace joined
[06:58] <dalek> 6model: 12f5afe | mberends++ | java/compiler/ (6 files):

[06:58] <dalek> 6model: [java/compiler] incomplete set of files very similar to dotnet/compiler

[06:58] <dalek> 6model: review: http://github.com/jnthn/6model/commit/12f5afe91e90c47f836abdeffdb7307b102843aa

[06:58] * moritz_ doesn't understand at all

[06:58] <btrace> hi,every

[06:58] <moritz_> http://coolnamehere.com/geekery/rakudo/index.html is quite nice

[06:59] <btrace> ?

[06:59] <dukeleto> btrace: howdy

[07:00] <sorear> Hello btrace

[07:00] <btrace> how can i get perl6' source?

[07:01] <dukeleto> btrace: it is on github

[07:01] <dukeleto> btrace: http:/github.com/perl6

[07:01] <dukeleto> btrace: http://github.com/perl6 rather

[07:01] <btrace> o ,thx~

[07:02] <sorear> moritz_: [\+] (@a, @b) === (([\+] @a), (([\+] @b) »+» ([+] @a))) # Do you follow this identity

[07:03] <moritz_> sorear: yes

[07:03] <dukeleto> btrace: http://github.com/rakudo/star

[07:03] <moritz_> sorear: but to me that's more additions than a straight evaluation

[07:03] <dukeleto> btrace: that is where you can find a stable release of Rakudo Perl 6

[07:04] <moritz_> btrace: http://rakudo.org/how-to-get-rakudo

[07:04] <sorear> moritz_: more additions, sure, but I've cut the dependency chain in half

[07:04] <dukeleto> btrace: http://github.com/rakudo/star/downloads <-- if you don't want to use git

[07:04] <moritz_> there is not single "perl6" compiler, but several (just like there are multiple C and Fortran compilers). Rakudo is one of them.

[07:04] <sorear> moritz_: if I have two processors, I can do the LHS and RHS in parallel

[07:05] <btrace> thanks a lot~

[07:05] <moritz_> sorear: and after that you still have to do the »+» [+] @a  operator, which is just as expensive as doing the second half of the additional normally

[07:06] <sorear> moritz_: »+» spreads over arbitrarily many processors very easily

[07:07] <moritz_> sorear: if you can prove that all infix:<+> multis in scope are associative, I think you're free to change the order of execution

[07:08] *** btrace left
[07:08] <sorear> moritz_: that's basically my question

[07:09] <sorear> moritz_: are [+] and [\+] aggregate operations that Perl 6 is allowed to assume are associative and side-effect-free?

[07:09] *** cotto left
[07:09] <moritz_> no

[07:10] *** cotto joined
[07:10] *** jaldhar left
[07:11] *** aindilis left
[07:11] *** sftp left
[07:11] *** yahooooo7 left
[07:12] *** Ross joined
[07:12] *** Ross left
[07:12] *** Ross joined
[07:13] *** yahooooo joined
[07:14] *** DemoFreak left
[07:14] *** DemoFreak joined
[07:15] *** aindilis joined
[07:16] *** [particle] joined
[07:17] *** PacoLinux left
[07:20] *** M_o_C joined
[07:21] *** perigrin joined
[07:22] *** cotto left
[07:24] *** Ross left
[07:24] *** Ross joined
[07:26] *** jhuni left
[07:34] *** nymacro joined
[07:35] *** cotto joined
[07:37] *** M_o_C left
[07:41] *** fod joined
[07:59] *** wamba joined
[08:06] *** cognominal left
[08:06] *** s1n left
[08:09] *** s1n joined
[08:15] *** IllvilJa joined
[08:36] *** Benzino joined
[08:37] *** satyavvd joined
[08:39] *** cognominal joined
[08:44] *** Benzino left
[08:46] *** Benzino joined
[08:49] <Juerd> sorear: pong

[08:50] <sorear> Juerd: several people on #parrot have been pining for a community server to run irc bots, other minor things on

[08:50] <sorear> should I refer them to you?

[08:51] <sorear> (whiteknight and bacek at least)

[08:53] *** tadzik joined
[09:01] *** Guest6471 joined
[09:01] *** Guest41340 left
[09:02] *** Benzino left
[09:02] *** dakkar joined
[09:02] *** Ross left
[09:03] *** kaare joined
[09:03] *** kaare is now known as Guest72792

[09:05] <moritz_> rakudo: say 1 - 0.9**3

[09:05] <p6eval> rakudo 5e7b43: OUTPUT«0.271␤»

[09:05] <Juerd> sorear: Definitely; it sounds exactly like a job for feather

[09:06] <Juerd> sorear: And feathers goals specifically include Parrot as well as Perl 6.

[09:06] <Juerd> First line of the motd:

[09:06] <Juerd> - This box is for Perl 6 development. This includes Parrot, and Pugs, and IRC,

[09:07] *** pmurias joined
[09:08] <sorear> hello pmurias

[09:08] <pmurias> sorear: hi

[09:08] <phenny> pmurias: 22 Sep 22:38Z <sorear> ask pmurias Does Mildew-Setting-SMOP normally require >3GB to build?  It's failing both locally and on feather1 with ENOMEM during the gcc call (so not an infinite allocation bug in our code)

[09:08] *** Guest6471 left
[09:08] <pmurias> hmm

[09:08] <sorear> possible gcc 4.4 just doesn't like 170kloc, 7MB source files?

[09:09] <pmurias> maybe

[09:10] <pmurias> i'll try to build that and see how much memory it takes on machine

[09:10] <sorear> anyways, I've gotten TO the gcc step

[09:10] <sorear> which I think is a good sign :)

[09:11] <moritz_> sorear: re GCC not liking big source files, I kinda doubt that. It has to compile itself, and since it recursively follows all includes, it is quite huge itself

[09:11] <sorear> (most of the issues were from 1. STD warns about unused function arguments now 2. 'viv' is no longer installed in @PERL5LIB)

[09:11] <pmurias> so how did you deal with 2?

[09:12] <sorear> I changed it to just 'use STD'

[09:12] *** oyse joined
[09:13] <sorear> and patched up a couple places where we were relying on viv's definitions

[09:13] <pmurias> sorear: i could try to switch from gcc to emitting llvm code

[09:13] <pmurias> s/code/IL/

[09:14] *** Benzino joined
[09:14] <sorear> moritz_: cpp output = 23MB, impressive number of casts

[09:15] <pmurias> `i have gcc 4.4.4

[09:16] <pmurias> and i don't think it takes very long to compile stuff

[09:16] <pmurias> compared to what i think is the SSA transform in mildew

[09:18] <sorear> well, not necessary "it takes a long time", but it needs a LOT of memory

[09:19] <pmurias> what could solve that?

[09:20] <sorear> ~sorear/public_html/offending{,_cpp}.c

[09:20] <sorear> on feather1

[09:20] <pmurias> having the compiler output spit out into separate files

[09:20] <sorear> if anyone wants to look at the files

[09:20] * pmurias looks

[09:21] <sorear> that's the larger of the two

[09:22] <pmurias> sorear: permission denied on the offending.c one

[09:22] <sorear> fixed

[09:24] <pmurias> the files to look as expected

[09:24] <pmurias> * the file seems to look as i would expect it to

[09:25] <pmurias> sorear: all the ops are translated into C statements so the file is quite big

[09:28] *** tadzik left
[09:28] *** IllvilJa left
[09:29] *** proller joined
[09:29] *** proller_ joined
[09:29] *** proller left
[09:31] <pmurias> sorear: gcc took 700m here

[09:31] <pmurias> sorear: but it took much longer than i expected

[09:32] *** rindolf joined
[09:32] <rindolf> Hi all.

[09:33] <rindolf> moritz_: http://perlgeek.de/blog-en/perl-5-to-6/09-comparing-and-matching.writeback - you have some POD junk at the end of the post. ("=for").

[09:33] <sorear> pmurias: what version?

[09:34] <moritz_> rindolf: thanks, I'll look into it

[09:34] <sorear> also, compile options

[09:34] <rindolf> moritz_: you're welcome.

[09:35] <rindolf> moritz_: also - you say that "The comments on this blog post have been disabled; the comment form below will not work." - in that case, you should not put the form in the page at all.

[09:35] <pmurias> sorear: gcc 4.4.4

[09:35] <moritz_> rindolf: I know; but I haven't got around to hacking conditionals into the template system

[09:37] <rindolf> moritz_: what kind of templating system are you using?

[09:37] <rindolf> moritz_: why didn't you use Template Toolkit?

[09:38] <moritz_> rindolf: it's a hacked blosxom blog. The default is the built-in s/(\$\w+)/eval $1/g  or so template hack

[09:39] <moritz_> rindolf: and I'm not a fan of Template Toolkit, for that matter

[09:39] <pmurias> sorear: how can i get the compile options?

[09:39] <sorear> not sure

[09:39] <sorear> haven't touched that

[09:40] <pmurias> gcc trying to optimise code more on feather could cause the problem

[09:40] <pmurias> but i'm not sure how to check that

[09:42] *** daxim joined
[09:42] <rindolf> moritz_: there's some POD junk here too - http://perlgeek.de/blog-en/perl-5-to-6/10-containers-and-values.writeback

[09:42] <moritz_> rindolf: I'm going through all the documents now

[09:42] <rindolf> moritz_: ah, OK.

[09:42] <moritz_> rindolf: seems that POD needs a newline before =for, and I wasn't aware of that

[09:42] <rindolf> moritz_: ah.

[09:44] <sorear> moritz_: according to perlpod, POD tools that require the blank line are working off an obsolete spec

[09:45] <moritz_> sorear: I haven't updated my POD parser in quite some time, so that might well be the case

[09:45] <rindolf> moritz_: http://perlgeek.de/blog-en/perl-5-to-6/10-where-we-are-now.writeback - "not very exiting" should be "not very exciting"

[09:46] <rindolf> moritz_: also "I'll write about lazy list" ==> s/$/s/

[09:47] <rindolf> moritz_: "exicting" there should be "exciting".

[09:48] <pmurias> sorear: do you want to use mildew for anything, or are you just repairing the damage STD changes caused? (i was planning on playing with perlito today but can try to fix that problem if it's blocking you)

[09:50] <moritz_> huh, I don't seem to have the source for 10-where-we-are-now in my repo :/

[09:50] <sorear> pmurias: the latter

[09:51] <sorear> pmurias: since I caused the STD changes selfishly, I thought it only right

[09:51] <moritz_> rindolf++

[09:52] <rindolf> moritz_: thanks. :-)

[09:53] *** rindolf left
[09:53] <moritz_> the POD mess is now gone

[09:57] <pmurias> sorear: if you commit your changes i can finish up the fix later on

[09:57] *** kensanata joined
[10:02] *** Benzino left
[10:02] <sorear> pmurias: long since committed

[10:02] * sorear out

[10:03] *** timbunce joined
[10:06] *** nymacro left
[10:26] *** dolmen joined
[10:27] *** dolmen is now known as Guest67249

[10:33] *** tadzik joined
[10:35] *** Su-Shee left
[10:36] *** kensanata left
[10:44] *** nymacro joined
[10:46] *** snearch joined
[11:03] *** pmurias left
[11:09] *** wamba left
[11:19] *** Italian_Plumber joined
[11:33] *** jaldhar joined
[11:34] *** Kodi joined
[11:41] *** Mirell joined
[11:46] *** Ross joined
[11:46] *** Ross left
[11:46] *** Ross joined
[11:51] *** Ross left
[12:03] *** Ross joined
[12:03] *** Ross left
[12:03] *** Ross joined
[12:11] *** Guest67249 left
[12:11] <moritz_> std: require Foo;

[12:11] <p6eval> std : OUTPUT«ok 00:01 115m␤»

[12:11] <moritz_> stdbug

[12:12] *** satyavvd left
[12:13] <moritz_> oh, not so

[12:13] <moritz_> moritzbug

[12:14] <gfldex> is it selffixing?

[12:14] <moritz_> no, I have to do it manually

[12:14] <gfldex> :->

[12:14] <moritz_> rakudo: use Test <plan ok>;

[12:15] <p6eval> rakudo 5e7b43: OUTPUT«===SORRY!===␤Confused at line 22, near "use Test <"␤»

[12:16] *** patspam joined
[12:21] *** masak joined
[12:21] * masak performs a 360 degree greeting

[12:21] * moritz_ returns it with a 2pi greeting

[12:22] *** ruoso joined
[12:23] *** juju joined
[12:24] <masak> I thought of doing a steradian greeting, but I don't know if I can manage it in Earth's gravitation well.

[12:24] <masak> s/gravitation/gravitational/

[12:25] <moritz_> I'm sure you can, in first (and second and third order) approximation :-)

[12:25] <juju> hi. Is there someone in here is involved in the perl6.org website ?

[12:25] <moritz_> yes

[12:26] <juju> well the "viv" STD-based reference parser used by various other compilers link is dead

[12:26] <masak> oh! thanks, juju++

[12:26] <juju> bye !

[12:27] <masak> bye :)

[12:27] *** juju left
[12:27] <moritz_> damn, didn't stay long enough to get a commit bit :-)

[12:28] *** bluescreen joined
[12:29] <masak> oh, didn't think of the commit bit thing.

[12:29] <masak> masak--

[12:29] <moritz_> hugme still can't add people to the 'perl6' team :(

[12:29] <moritz_> organizations don't have an API yet on github :(

[12:30] <Raynes> They still haven't even completed the gist API. :(

[12:31] <Raynes> Or the gist API documentation. If there is a meaningful difference.

[12:31] *** icwiener joined
[12:34] *** xabbu42 joined
[12:39] <moritz_> std: require Foo; Foo.WHAT

[12:39] <p6eval> std : OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤      'Foo' used at line 1␤Check failed␤FAILED 00:02 115m␤»

[12:41] *** kjeldahl_ joined
[12:48] <flussence> is there anything along the lines of "(namespace Foo { ... }).^methods"?

[12:49] <daxim> rakudo: NaN.WHAT # joke of the day

[12:49] <p6eval> rakudo 5e7b43:  ( no output )

[12:49] <daxim> qua?

[12:49] <flussence> rakudo: say NaN.WHAT

[12:49] <daxim> ah right

[12:49] <p6eval> rakudo 5e7b43: OUTPUT«Num()␤»

[12:49] <flussence> blame the IEEE for that one

[12:50] *** stepnem left
[12:52] *** drbean joined
[12:53] <moritz_> moritz@trudi:~/rakudo>echo 'module TestModule { our sub greetz { say 42 } }' >  TestModule.pm

[12:53] <moritz_> moritz@trudi:~/rakudo>./perl6 -e 'require TestModule; TestModule::greetz'

[12:53] <moritz_> 42

[12:55] *** Kodi left
[12:56] *** rgrau_` left
[12:57] <tadzik> yay, require works?

[12:57] <moritz_> locally

[12:57] <moritz_> the simplest form of require, that is :-)

[12:58] <tadzik> can you pass a string to it?

[12:58] <moritz_> not yet

[12:58] <moritz_> but should be not too hard to do

[12:59] <moritz_> ... at least I hope so :-)

[13:00] <tadzik> that will make another (third)Warsaw Perl Monger happy :)

[13:03] <moritz_> I've now overriden the 'require' branch on github with my changes

[13:04] <tadzik> oh, by the way. What can I do with P6 grammars so it will tell in which line of input there's a syntax error?

[13:04] <moritz_> there's no automated way yet :(

[13:04] <tadzik> and what is the way?

[13:05] <moritz_> die $/.pos

[13:05] <tadzik> or, how Rakudo/STD does it?

[13:05] <PerlJam> tadzik: count the lines :)

[13:05] <moritz_> and then count the lines up to that position

[13:05] <tadzik> PerlJam: :) moritz_, in actions?

[13:05] <moritz_> tadzik: wherever you determine the parse error

[13:06] <tadzik> I thought grammars determine them

[13:06] <tadzik> well, themselves

[13:06] <moritz_> token force_foo { <foo> || { die $/.pos } }

[13:06] <tadzik> mhm

[13:06] <moritz_> 15:04 < moritz_> there's no automated way yet :(

[13:06] <tadzik> is there a hope for an automated way?

[13:06] <moritz_> <aragon>There's always hope!</aragon>

[13:09] <masak> these two tweets were so absurd that I thought the tweeter was a bot at first: http://twitter.com/brianrue/status/25378535881 http://twitter.com/brianrue/status/25378574647

[13:09] <masak> but seems not.

[13:09] <tadzik> wat

[13:09] <rjbs> Odd!

[13:10] <PerlJam> tough job market.  Maybe his cab driver is a perl 6 hacker  :)

[13:10] <masak> 哈哈

[13:10] <tadzik> (:

[13:12] <masak> moritz_++ # Rakudo release

[13:13] <moritz_> thanks

[13:13] <pmichaud> moritz_++

[13:14] <masak> TimToady: re '[+/]' meaning 'reverse [\+] reverse'. I'm unable to decide if I think that is utterly brilliant or completely bonkers. :) which probably means we should try it.

[13:14] <moritz_> please don't

[13:14] <pmichaud> ...what does that mean?!

[13:15] <masak> :)

[13:16] <masak> rakudo: say (<a b c d e> Zxx 0,1,0,1,0) # via TimToady, backlog

[13:16] <masak> rakudo: say (<a b c d e> Zxx 0,1,0,1,0).Str

[13:16] <p6eval> rakudo 5e7b43: OUTPUT«bd␤»

[13:16] <p6eval> rakudo 5e7b43: OUTPUT«e e␤»

[13:16] * masak submits rakudobug

[13:17] <pmichaud> looks like a variation of the take bug again

[13:17] <masak> aye.

[13:18] *** Patterner left
[13:19] <pmichaud> rakudo:  say (<a b c d e>)[(0,1,0,1,0).pairs.grep(?*).keys].Str  # just curious

[13:19] <p6eval> rakudo 5e7b43: OUTPUT«a b c d e␤»

[13:19] <pmichaud> rakudo:  say (0,1,0,1,0).pairs.perl

[13:19] <p6eval> rakudo 5e7b43: OUTPUT«(0 => 0, 1 => 1, 2 => 0, 3 => 1, 4 => 0)␤»

[13:20] <pmichaud> rakudo:  say (0,1,0,1,0).pairs.grep(?*).perl

[13:20] <p6eval> rakudo 5e7b43: OUTPUT«(0 => 0, 1 => 1, 2 => 0, 3 => 1, 4 => 0)␤»

[13:20] <pmichaud> rakudo:  say (<a b c d e>)[(0,1,0,1,0).pairs.grep(.value).keys].Str  # just curious

[13:20] <p6eval> rakudo 5e7b43: OUTPUT«Method 'value' not found for invocant of class ''␤  in main program body at line 22:/tmp/6cX1LeMToc␤»

[13:20] <pmichaud> rakudo:  say (<a b c d e>)[(0,1,0,1,0).pairs.grep(*.value).keys].Str  # just curious

[13:20] <moritz_> rakudo: say 'abc' ~~ / foo <alpha>? || <alpha> /; say $<alpha>.WHAT

[13:20] <p6eval> rakudo 5e7b43: OUTPUT«a␤Array()␤»

[13:20] <p6eval> rakudo 5e7b43: OUTPUT«a b␤»

[13:20] <moritz_> is that correct?

[13:21] <pmichaud> looks right to me.

[13:21] <moritz_> I kinda thougth that alternations reset match counting

[13:21] <moritz_> so I expected the second branch to have a not-quantified $<alpha> match

[13:21] <pmichaud> if a capture is quantified in any alternative, it's quantified in all.

[13:21] <moritz_> ok.

[13:23] <pmichaud> S05:3242

[13:24] <pmichaud> oh, but there's a counter-example later on

[13:24] <pmichaud> hmmmm

[13:26] <moritz_> ./perl6 -e 'require "TestModule"; TestModule::greetz'

[13:26] <moritz_> 42

[13:26] <tadzik> yay

[13:26] <moritz_> hm, maybe that's wrong

[13:26] <moritz_> in perl 5, the require STRING form expects a file name, not a module name

[13:27] *** Kodi joined
[13:27] <tadzik> maybe it'll be good to change it

[13:27] * moritz_ curses under his breath

[13:27] <moritz_> S11 says filename

[13:27] <tadzik> mhm

[13:28] <Kodi> Is IO-Socket-INET.t (or rather, IO-Socket-INET.rakudo) failing for anybody else?

[13:28] <phenny> Kodi: 22 Sep 17:10Z <moritz_> tell Kodi to please wait with merging until after the release on Thursday

[13:28] * moritz_ wonders if a filename shouldn't require a :filename adverb or so

[13:28] <moritz_> Kodi: I had one failure in my last test run

[13:29] <pmichaud> moritz_: you may be correct that it's a bug (the <alpha> example)

[13:29] <moritz_> (btw http://smolder.parrot.org/app/projects/smoke_reports/5 can answer such questions for you too)

[13:29] <pmichaud> I don't know why I'm remembering it as being the other way.

[13:29] *** Psyche^ joined
[13:29] *** Psyche^ is now known as Patterner

[13:30] <moritz_> Kodi: but it's not always failing here

[13:30] *** PacoLinux joined
[13:30] <Kodi> moritz_: It consistently fails here. Also, Rakudo is eating enormous amounts of memory, which might be the cause.

[13:31] <moritz_> Kodi: maybe related to recent parrot GC changes

[13:31] <Kodi> Sounds likely.

[13:31] <Kodi> I think I'll delay merging perl6scalar-cleanup until this is sorted out.

[13:32] <PerlJam> pmichaud: where's the counter-example in S05?

[13:32] <moritz_> Kodi: are you on parrot HEAD?

[13:32] <Kodi> The latest PARROT_REVISION, whichever SVN revision that is.

[13:33] <moritz_> that's pretty new, yes

[13:33] * masak submits moritz_' question that pmichaud thinks maybe is a bug

[13:33] <pmichaud> PerlJam: S05:3289

[13:34] *** astrojp left
[13:34] <Kodi> Parrot HEAD is about 20 revisions ahead at the moment.

[13:34] *** Guest72792 left
[13:34] <pmichaud> rakudo:  'abc' ~~ / (a) xy | (.)+ /;   say $0.WHAT;

[13:34] <p6eval> rakudo 5e7b43: OUTPUT«Array()␤»

[13:35] <pmichaud> rakudo:  'abc' ~~ / (a) .. | (.)+ /;   say $0.WHAT;

[13:35] <p6eval> rakudo 5e7b43: OUTPUT«Array()␤»

[13:35] <PerlJam> pmichaud: that shows a non-quantified <file> in each branch of the alternation, ergo no array.

[13:35] <pmichaud> oh, right.

[13:35] <pmichaud> *whew*

[13:36] <pmichaud> PerlJam: thanks for correcting my misreading of that.  I should probably get a Dr Pepper or something to wake up.  :)

[13:37] *** plainhao joined
[13:38] <masak> so, no bug.

[13:38] * masak un-submits

[13:45] *** xabbu42 left
[13:49] *** stepnem joined
[13:52] *** molaf joined
[13:54] <masak> tadzik: [backlog] it's ".comb" because "comb for" means "go through and keep what you're interested in" -- "chop" sounds destructive, and indeed it is.

[13:55] *** IllvilJa joined
[13:55] *** PacoLinux left
[13:55] *** ash____ joined
[13:58] *** jaldhar left
[13:58] *** Kodi left
[13:59] <jnthn> o/

[13:59] *** jaldhar joined
[14:00] <ash____> http://try.rakudo.org/?input=sub%20fn($n)%20{%20map%20{%20($n/$_%20~%22/$_%22),%20(%22$_/%22%20~%20$n/$_)%20},%20grep%20{%20$n%20%%%20$^a%20},%20^($n.sqrt.ceiling)%20};%20.say%20for%20@(fn(60)); 

[14:00] <ash____> anyone know any faster ways of doing that? 

[14:01] <tadzik> I can't copy that :)

[14:01] *** ash____ is now known as ash_gti

[14:01] <ash_gti> rakudo: sub fn($n) { map { ($n/$_ ~"/$_"),  ("$_/" ~ $n/$_) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; .say for @(fn(60));

[14:01] <p6eval> rakudo 5e7b43: OUTPUT«60/1␤1/60␤30/2␤2/30␤20/3␤3/20␤15/4␤4/15␤12/5␤5/12␤10/6␤6/10␤»

[14:01] <ash_gti> rakudo: sub fn($n) { map { ($n/$_ ~"/$_"),  ("$_/" ~ $n/$_) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; say ~fn(60);

[14:01] <p6eval> rakudo 5e7b43: OUTPUT«60/1 1/60 30/2 2/30 20/3 3/20 15/4 4/15 12/5 5/12 10/6 6/10␤»

[14:02] <ash_gti> also, is there a way to print a Rat so it shows up as Numerator/Denominator? 

[14:03] <ash_gti> rakudo: say (1/2).Rat; # always seem to be decimals 

[14:03] <p6eval> rakudo 5e7b43: OUTPUT«0.5␤»

[14:03] <ash_gti> rakudo: say (1/2).^methods(:local); 

[14:03] <p6eval> rakudo 5e7b43:

[14:03] <p6eval> ..OUTPUT«newnudeperlBridgeBoolRatNumsuccpredACCEPTSRealIntComplexStrrealsisNaNabsexplnsqrtrootssignfloorceilingtruncateroundcisunpolarrandsinasincosacostanatansecaseccosecacoseccotanacotansinhasinhcoshacoshtanhatanhsechasechcosechacosechcotanhacotanhatan2Numericloglog10to-radiansfrom-radian…

[14:03] <tadzik> rakudo: (1/2).Str.say

[14:03] <p6eval> rakudo 5e7b43: OUTPUT«0.5␤»

[14:03] <masak> rakudo: say (1/2).nude.perl

[14:03] <tadzik> ash_gti: ↑

[14:03] <tadzik> oh, noes

[14:03] <p6eval> rakudo 5e7b43: OUTPUT«(1, 2)␤»

[14:03] <tadzik> hrm

[14:03] <tadzik> rakudo: (1/2).perl

[14:04] <tadzik> rakudo: (1/2).perl.say

[14:04] <tadzik> -_-

[14:04] <p6eval> rakudo 5e7b43:  ( no output )

[14:04] <p6eval> rakudo 5e7b43: OUTPUT«1/2␤»

[14:04] *** xabbu42 joined
[14:04] <masak> rakudo: say (1/2).nude.perl # just do this

[14:04] <tadzik> nah

[14:04] <p6eval> rakudo 5e7b43: OUTPUT«(1, 2)␤»

[14:04] *** xabbu42 left
[14:04] *** xabbu42_ joined
[14:04] <masak> jnthn: \o

[14:05] <ash_gti> rakudo: sub fn($n) { map { ($n/$_),  ($n/$_) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; .nude.perl.say for @(fn(60).sort);

[14:05] <p6eval> rakudo 5e7b43: OUTPUT«(10, 1)␤(10, 1)␤(12, 1)␤(12, 1)␤(15, 1)␤(15, 1)␤(20, 1)␤(20, 1)␤(30, 1)␤(30, 1)␤(60, 1)␤(60, 1)␤»

[14:07] *** frodwith joined
[14:07] <ash_gti> rakudo: sub fn($n) { map { (($n/$_)/$_),  ($_/($n/$_) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; .nude.perl.say for @(fn(60).sort);

[14:07] <p6eval> rakudo 5e7b43: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[14:07] <ash_gti> rakudo: sub fn($n) { map { (($n/$_)/$_),  ($_/($n/$_)) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; .nude.perl.say for @(fn(60).sort);

[14:07] <p6eval> rakudo 5e7b43: OUTPUT«(5, 3)␤(3, 5)␤(15, 1)␤(1, 15)␤(12, 5)␤(5, 12)␤(15, 4)␤(4, 15)␤(20, 3)␤(3, 20)␤(60, 1)␤(1, 60)␤»

[14:08] <ash_gti> rakudo: sub fn($n) { map { (($n/$_)/$_),  ($_/($n/$_)) }, grep { $n %% $^a }, ^($n.sqrt.ceiling) }; .nude.perl.say for @(fn(60).flat.sort);

[14:08] *** snearch left
[14:08] <p6eval> rakudo 5e7b43: OUTPUT«(1, 60)␤(1, 15)␤(3, 20)␤(4, 15)␤(5, 12)␤(3, 5)␤(5, 3)␤(12, 5)␤(15, 4)␤(20, 3)␤(15, 1)␤(60, 1)␤»

[14:08] <ash_gti> there, thats what i was looking for 

[14:08] <ash_gti> still curious if it can be any faster

[14:13] *** PacoLinux joined
[14:15] <jnthn> masak: o/

[14:19] *** Mowah joined
[14:20] *** Holy_Cow joined
[14:20] <flussence> ash_gti: the list's symmetrical, so you can skip half the divides and do something fancy with .reverse

[14:20] *** mberends left
[14:20] <flussence> (not sure if it'd be faster though...)

[14:20] <ash_gti> well, i already add everything twice with the map 

[14:22] *** arnsholt left
[14:27] <flussence> wait... is that last output correct? I'm not sure what it's meant to do

[14:30] <ash_gti> the last output is correct, its supposed to: "Create an ordered list of fractions which product of the numerator and denominator equals a specific integer n."

[14:30] <flussence> (1, 15) for 60?

[14:30] <ash_gti> that got simplified  

[14:31] <flussence> oh

[14:31] <ash_gti> i think... one sec

[14:31] <flussence> yeah, that makes sense

[14:31] <ash_gti> ya, that was 2/30 

[14:32] <ash_gti> simplified to 1/15 

[14:32] <flussence> I wonder if there's a way to prevent that...

[14:32] <moritz_> if you want to prevent it, don't use Rats

[14:32] <moritz_> but for example Pair objects, or two-element lists

[14:33] <ash_gti> a pair object sounds easy enough 

[14:33] <ash_gti> can you sort pair objects? 

[14:34] <masak> moritz_: [backlog] wasn't there talk about an 'is associative' trait at some point?

[14:34] <moritz_> ash_gti: sure

[14:35] <moritz_> masak: yes, there was talk. There's always talk. :-)

[14:35] <masak> moritz_: I mean, mightn't it still be a good idea. then your "no" in the backlog as a reply to sorear's question could, it appears, be qualified.

[14:35] *** leprevost joined
[14:35] <ash_gti> although, it would probably be better to make the list in the right order the first time, and not have to sort it...

[14:36] <masak> s:1st/\./?/

[14:37] <moritz_> rakudo: say (3 => 4, 0 => 3, 0 => 2, 3 => 2).sort.perl

[14:37] <p6eval> rakudo 5e7b43: OUTPUT«(0 => 2, 0 => 3, 3 => 2, 3 => 4)␤»

[14:37] <moritz_> sorts on key first, then on value

[14:39] * masak stumbles over http://c2.com/cgi/wiki?SufficientlySmartCompiler -- and realized he uses the phrase fairly often

[14:39] *** wtw left
[14:41] <moritz_> masak: actually here you use "sufficiently smart lint utility" or so quite often :-)

[14:41] <masak> aye.

[14:42] <masak> I guess jnthn is working on raising the intelligence of Rakudo right now.

[14:42] <jnthn> Actually right now I'm snacking on a chokladbollar...

[14:42] <masak> :D

[14:42] <masak> but I really do think it's realistic to build a smart lint utility on top of STD.

[14:43] <ash_gti> what about a smarter repl? 

[14:43] <jnthn> But yes, I expect making a bunch more stuff available at compile time (which I will be doing) will mean that we can do a lot more checks. :-)

[14:43] <ash_gti> that lets you do: if true { \n 

[14:43] <jnthn> .oO( and a lot more Slovaks...don't want them feeling left out... :-) )

[14:44] <jnthn> I expect detecting my Int $x = 'wtf'; will be easily detectable and whineaboutable, for example.

[14:44] <jnthn> s/detecting /

[14:46] <moritz_> that's kinda hard to do at the moment :/

[14:46] *** justatheory joined
[14:47] <jnthn> Right.

[14:47] <jnthn> Thus why stuff must change.

[14:51] <masak> ash_gti: I think that's a nice goal.

[14:51] <ash_gti> i guess a smarter repl needs knowledge of what terminates a statement

[14:53] <masak> and that's HLL-specific, and the REPL (I think) is outside of Rakudo and in PCT/nqp-rx.

[14:53] <masak> it's approximately the same problem as with command-line option handling.

[14:56] *** ggoebel joined
[14:57] <colomon> ash_gti: not sure if this is clear in the above or not:

[14:57] <colomon> rakudo: say (1/2).perl

[14:57] <p6eval> rakudo 5e7b43: OUTPUT«1/2␤»

[14:58] <colomon> also

[14:58] <colomon> rakudo: say (0, 1/60 ... 1).perl

[14:58] <p6eval> rakudo 5e7b43: OUTPUT«(0, 1/60, 1/30, 1/20, 1/15, 1/12, 1/10, 7/60, 2/15, 3/20, 1/6, 11/60, 1/5, 13/60, 7/30, 1/4, 4/15, 17/60, 3/10, 19/60, 1/3, 7/20, 11/30, 23/60, 2/5, 5/12, 13/30, 9/20, 7/15, 29/60, 1/2, 31/60, 8/15, 11/20, 17/30, 7/12, 3/5, 37/60, 19/30, 13/20, 2/3, 41/60, 7/10, 43/60, 11/15,

[14:58] <p6eval> ..3/4, …

[14:59] *** sftp joined
[15:00] <colomon> rakudo: say (0, 1/30 ... 1).perl # ought to fit, I think

[15:01] <p6eval> rakudo 5e7b43: OUTPUT«(0, 1/30, 1/15, 1/10, 2/15, 1/6, 1/5, 7/30, 4/15, 3/10, 1/3, 11/30, 2/5, 13/30, 7/15, 1/2, 8/15, 17/30, 3/5, 19/30, 2/3, 7/10, 11/15, 23/30, 4/5, 5/6, 13/15, 9/10, 14/15, 29/30, 1/1)␤»

[15:05] *** dual joined
[15:07] *** amkrankruleuen joined
[15:07] <ash_gti> colomon: ya, i figured out how to print rat's properly now 

[15:08] <colomon> ash_gti++

[15:09] *** Mowah left
[15:11] * colomon is frustrated at how much more work printing out a simple message is in C++.  :(

[15:12] *** leprevost left
[15:12] <colomon> I mean, "<< endl" is twice as many characters as "say"!

[15:13] <tadzik> "\n" is shorter

[15:14] <ash_gti> you still need to << "\n" 

[15:15] <ash_gti> although, endl isn't always what you want, since it flushes the buffer too 

[15:15] <nymacro> colomon: not to mention that if you don't want to import the std namespace, it is even more ;)

[15:15] *** risou left
[15:16] <colomon> nymacro: excellent point.

[15:16] <colomon> ash_gti: flushing the buffer is always what I want when I'm debugging.  :)

[15:17] <colomon> nymacro: I think I got so sick of typing std::endl that I imported just endl into my namespace.  :)

[15:20] <jnthn> o/, bbl

[15:28] *** mantovani left
[15:28] <hudnix> rakudo: (0,5 ... 10).perl.say; (0,5 ... 11).perl.say

[15:28] *** mantovani joined
[15:28] <p6eval> rakudo 5e7b43: OUTPUT«(timeout))␤»

[15:28] *** mantovani left
[15:29] <hudnix> rakudo: (0,5 ... 10).perl.say

[15:29] <p6eval> rakudo 5e7b43: OUTPUT«(0, 5, 10)␤»

[15:29] <hudnix> rakudo: (0,5 ... 11).perl.say

[15:29] <p6eval> rakudo 5e7b43: OUTPUT«(timeout)»

[15:29] <colomon> hudnix: 0, 5 ... 11 is an infinite sequence in the latest standard

[15:29] *** mantovani joined
[15:29] <colomon> s/standard/spec/

[15:30] <colomon> you have to hit the ending condition of the sequence exactly.

[15:30] <hudnix> ok

[15:30] <colomon> rakudo: (0, 5 ... * > 10).perl.say

[15:30] <p6eval> rakudo 5e7b43: OUTPUT«(0, 5, 10, 15)␤»

[15:30] <colomon> rakudo: (0, 5 ... * >= 10).perl.say

[15:30] <p6eval> rakudo 5e7b43: OUTPUT«(0, 5, 10)␤»

[15:31] <colomon> rakudo: (0, 5 ...^ * >= 11).perl.say

[15:31] <p6eval> rakudo 5e7b43: OUTPUT«(0, 5, 10)␤»

[15:31] <colomon> rakudo: (0, 5.5 ...^ * >= 11).perl.say

[15:31] <p6eval> rakudo 5e7b43: OUTPUT«(0, 11/2)␤»

[15:32] <hudnix> what does the ^ do?

[15:32] <colomon> ugh.  cold medicine messing with my brainz.  

[15:32] <masak> hudnix: excludes the final value of the sequence.

[15:33] <masak> rakudo: say 1..10; say 1..^10;

[15:33] <p6eval> rakudo 5e7b43: OUTPUT«12345678910␤123456789␤»

[15:33] <colomon> basically, the right-hand side is a test

[15:33] <colomon> when the test is true for the current value of the sequence, a ... sequence returns that last value

[15:33] <colomon> (and then ends)

[15:33] <colomon> and a ...^ sequence doesn't return it, but does end.

[15:33] <colomon> rakudo: (0, 1 ... 10).perl.say

[15:34] <p6eval> rakudo 5e7b43: OUTPUT«(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)␤»

[15:34] <colomon> rakudo: (0, 1 ...^ 10).perl.say

[15:34] <p6eval> rakudo 5e7b43: OUTPUT«(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)␤»

[15:34] <colomon> rakudo: (0, 1 ... * > 10).perl.say

[15:34] <p6eval> rakudo 5e7b43: OUTPUT«(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)␤»

[15:34] *** oyse left
[15:34] <colomon> rakudo: (0, 1 ...^ * > 10).perl.say

[15:34] <p6eval> rakudo 5e7b43: OUTPUT«(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)␤»

[15:36] <colomon> rakudo: (0, 1.5 ... * > 10).perl.say

[15:36] <p6eval> rakudo 5e7b43: OUTPUT«(0, 3/2, 3/1, 9/2, 6/1, 15/2, 9/1, 21/2)␤»

[15:36] <colomon> rakudo: (0, 1.5 ...^ * > 10).perl.say

[15:37] <p6eval> rakudo 5e7b43: OUTPUT«(0, 3/2, 3/1, 9/2, 6/1, 15/2, 9/1)␤»

[15:38] <sjn> quick question: what methods do I use to find out what signature a method has?

[15:38] *** snearch joined
[15:39] *** snearch left
[15:39] *** snearch joined
[15:39] *** rgrau_` joined
[15:39] <nymacro> sjn: &sub.signatures

[15:40] <moritz_> rakudo: sub foo($a, :$b){}; say &foo.signature.perl

[15:40] <p6eval> rakudo 5e7b43: OUTPUT«:(Any $a, Any :b($b))␤»

[15:40] <TimToady> but you can't necessarily name a method with &sub

[15:41] <nymacro> It wasn't meant in the literal sense :P

[15:41] *** patspam left
[15:41] <TimToady> by you

[15:41] <TimToady> I think sjn meant a literal method

[15:42] <TimToady> in which case &sub is unlikely to work directly

[15:42] <nymacro> my bad, I should have been clearer

[15:42] *** patspam joined
[15:42] <hudnix> rakudo: class A{method a($a,:$b){}};A.^can('a').signature.perl.say

[15:43] <p6eval> rakudo 5e7b43: OUTPUT«Method 'signature' not found for invocant of class 'P6Invocation'␤  in main program body at line 22:/tmp/qpWKnKDkqf␤»

[15:43] <TimToady> sorry, it's still too early here, and I'm cross...  :)

[15:43] <hudnix> rakudo: class A{method a($a,:$b){}};A.^can('a').perl.say

[15:43] <sjn> rakudo: say round.signature.perl

[15:43] <p6eval> rakudo 5e7b43: OUTPUT«Method 'perl' not found for invocant of class 'P6Invocation'␤  in main program body at line 22:/tmp/7Vb2uNNOBH␤»

[15:43] <p6eval> rakudo 5e7b43: OUTPUT«Not enough positional parameters passed; got 0 but expected between 1 and 2␤  in 'round' at line 1979:CORE.setting␤  in main program body at line 22:/tmp/rKG_mshfo6␤»

[15:43] *** rgrau_` left
[15:43] <hudnix> rakudo: class A{method a($a,:$b){}};A.^can('a').WHAT.say

[15:44] <p6eval> rakudo 5e7b43: OUTPUT«Method 'WHAT' not found for invocant of class 'P6Invocation'␤  in main program body at line 22:/tmp/DMPJzOQh8D␤»

[15:44] <hudnix> rakudo: class A{method a($a,:$b){}};A.^can('a')

[15:44] <p6eval> rakudo 5e7b43:  ( no output )

[15:44] <TimToady> or maybe I'm just grumpy, which is a more normal state of things...

[15:44] <hudnix> rakudo: class A{method a($a,:$b){say "hi"}};A.^can('a').()

[15:44] <p6eval> rakudo 5e7b43: OUTPUT«Not enough positional parameters passed; got 0 but expected 2␤  in 'A::a' at line 22:/tmp/USnTLi1ydM␤  in main program body at line 22:/tmp/USnTLi1ydM␤»

[15:45] <hudnix> rakudo: class A{method a($a,:$b){say "hi"}};A.^can('a').(1,:b)

[15:45] <p6eval> rakudo 5e7b43: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'A::a' at line 22:/tmp/bwcG_XDmGS␤  in main program body at line 22:/tmp/bwcG_XDmGS␤»

[15:45] <sjn> ok, so what's the "simple" way of just exploring Perl 6 using introspection methods?

[15:46] <TimToady> it's not supposed to be simple :)

[15:46] <sjn> aw :-\

[15:46] <TimToady> if it were simple, people would cheat...

[15:47] * sjn wishes exploration would be simple :-)

[15:47] <TimToady> but yeah, it'd be nice to be able to browse it

[15:47] <sjn> rakudo: say "somestring".methods

[15:47] <p6eval> rakudo 5e7b43: OUTPUT«Method 'methods' not found for invocant of class 'Str'␤  in main program body at line 22:/tmp/itjnngoeAb␤»

[15:47] <hudnix> rakudo: class A{method a($a){}}; A.can('a')

[15:47] <TimToady> use .^methods

[15:47] <p6eval> rakudo 5e7b43:  ( no output )

[15:47] <sjn> rakudo: say "somestring".^methods

[15:48] <p6eval> rakudo 5e7b43:

[15:48] <p6eval> ..OUTPUT«ACCEPTSperlpredsuccWHICHBoolStrencodeNumericRealIntRatNumabsexploglog10sqrtrootsto-radiansfrom-radiansfloorceilingroundtruncatesigncisunpolarchrrandsincostanseccoseccotansinhcoshtanhsechcosechcotanhasinacosatanatan2asecacosecacotanasinhacoshatanhasechacosechacotanhbytescapitalizech…

[15:48] <sjn> right

[15:48] <TimToady> then stringify somehow to get whitespace

[15:48] <sjn> rakudo: say "somestring".^methods.perl

[15:48] <p6eval> rakudo 5e7b43: OUTPUT«[{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ...

[15:48] <p6eval> ..}, { …

[15:48] <TimToady> and use :local to omit Cool methods

[15:48] <TimToady> but think Cool and Any should be omitted by default

[15:48] <sjn> rakudo: say "somestring".^methods(:local).perl # ?

[15:48] <p6eval> rakudo 5e7b43: OUTPUT«[{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }]␤»

[15:49] * sjn is confused

[15:49] <TimToady> rakudo doesn't know how to stringify closures

[15:50] <TimToady> *perlify

[15:51] <masak> it gets the curlies right :)

[15:51] <sjn> rakudo: say "somestring".^methods(:local).join(" ")

[15:51] <p6eval> rakudo 5e7b43: OUTPUT«ACCEPTS perl pred succ WHICH Bool Str encode␤»

[15:51] <sjn> rakudo: say round.^methods(:local).join(" ")

[15:51] <p6eval> rakudo 5e7b43: OUTPUT«Not enough positional parameters passed; got 0 but expected between 1 and 2␤  in 'round' at line 1979:CORE.setting␤  in main program body at line 22:/tmp/vIM9aPYZMQ␤»

[15:51] <moritz_> TimToady: S11 says that require <EXPR>; takes the expression as file name (and not module name). Do you think it's still a good idea?

[15:51] *** rrgau_ joined
[15:51] <TimToady> no

[15:52] <sjn> rakudo: say round(1,2).^methods(:local).join(" ")

[15:52] <p6eval> rakudo 5e7b43: OUTPUT«perl pred succ WHICH Str Bridge Int Rat Num sign ACCEPTS Real Bool Complex reals isNaN abs exp ln sqrt roots floor ceiling truncate round cis unpolar rand sin asin cos acos tan atan sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech

[15:52] <p6eval> ..cotanh…

[15:52] <moritz_> TimToady: that's good, because implementing  it as a module name is easier for now :-)

[15:52] *** nymacro left
[15:52] <TimToady> that being said, a module name is unlikely to contain a '.'

[15:52] <flussence> rakudo: my @x = "something".^methods(:local); say ~(@x Z=> @x.perl);

[15:52] <p6eval> rakudo 5e7b43: OUTPUT«ACCEPTS    [{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }]␤»

[15:53] <flussence> ack.

[15:53] *** LionMadeOfLions left
[15:54] <sjn> would it be sensible to ignore signature checks when one is playing around with introspection?

[15:54] <TimToady> sjn: .Str or ~ is a shorter way to do that join

[15:54] <sjn> rakudo: say round.^methods(:local).Str

[15:54] <p6eval> rakudo 5e7b43: OUTPUT«Not enough positional parameters passed; got 0 but expected between 1 and 2␤  in 'round' at line 1979:CORE.setting␤  in main program body at line 22:/tmp/u5HF9mqUfz␤»

[15:54] <masak> sjn: why do you start by calling &round?

[15:54] <masak> sjn: seems like that's not what you wnat.

[15:54] <PerlJam> TimToady: Just reading the last few minutes of conversation, switching require's behavior based on the presence of a '.' sounds a little too magical to me right now.

[15:54] <masak> s/wnat/want/

[15:55] <sjn> masak: I'm using round as "the method I'd like to found out more about"

[15:55] <PerlJam> masak: he only wants the round methods, not the square ones or those of other shapes

[15:55] <TimToady> but you used it as a verb, not as anoun

[15:55] <masak> sjn: I think you mean &round

[15:55] <masak> sjn: without the sigil, it's a call.

[15:55] <sjn> rakudo: say &round.^methods(:local).Str

[15:55] <p6eval> rakudo 5e7b43: OUTPUT«candidates multi name␤»

[15:55] <flussence> rakudo: my @x = "something".^methods(:local); say ~(@x.Str Z=> @x.perl);

[15:55] <p6eval> rakudo 5e7b43: OUTPUT«ACCEPTS perl pred succ WHICH Bool Str encode       [{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }]␤»

[15:55] <flussence> oh.

[15:55] <sjn> right

[15:55] <flussence> rakudo: my @x = "something".^methods(:local); say ~(@x».Str Z=> @x».perl);

[15:56] <p6eval> rakudo 5e7b43: OUTPUT«get_attr_str() not implemented in class 'Sub'␤  in main program body at line 1␤»

[15:56] <PerlJam> rakudo: say &round.signature.perl

[15:56] <p6eval> rakudo 5e7b43: OUTPUT«get_attr_str() not implemented in class 'Perl6MultiSub'␤  in main program body at line 1␤»

[15:56] <flussence> rakudo: my @x = "something".^methods(:local); say ~(@x».Str Z=> @x.perl);

[15:56] <p6eval> rakudo 5e7b43: OUTPUT«get_attr_str() not implemented in class 'Sub'␤  in main program body at line 1␤»

[15:56] <flussence> :/

[15:56] *** masak left
[15:56] *** masak joined
[15:57] <sjn> seems just "playing around" isn't as easy as it could be :-\

[15:57] <PerlJam> If I were wishing for things, I'd wish that not so much parrot bleeds through to Perl 6.

[15:57] <masak> sjn: we're very open to suggestion for how to make it easier.

[15:58] *** kjeldahl left
[15:58] *** rindolf joined
[15:59] <sjn> well, my (rather naïve) stab at this would be to start looking for an easy way to list available methods, then a way to describe a method in any sensible way

[15:59] <sjn> with those two, I'd be able to explore and learn everything

[15:59] <PerlJam> sjn: seems you've got the first.

[16:00] <moritz_> for the second, we need Pod and .WHY methods

[16:00] <sjn> rakudo: say &round.^methods(:local).Str

[16:00] <p6eval> rakudo 5e7b43: OUTPUT«candidates multi name␤»

[16:00] <sjn> yeah, the first one is ok, although I'd live the defaults to be simpler :)

[16:01] <sjn> (if possible)

[16:01] <masak> sjn: sounds like you could benefit from briefing through S32, as well.

[16:01] <PerlJam> sjn: you'd like :local to be default?

[16:01] <sjn> PerlJam: perhaps?

[16:01] <TimToady> local should not be the default

[16:01] <PerlJam> sjn: I'm wondering what other "defaults" you're referring to.

[16:01] <TimToady> something in the middle should be the default

[16:01] <sjn> middle is fine too

[16:02] <TimToady> everything out to Cool or Any is a fine default, I think

[16:02] <sjn> PerlJam: "defaults" as in "what I get when I don't add any extra arguments"

[16:02] <PerlJam> "".^methods(:middle).Str

[16:02] <PerlJam> :)

[16:02] <masak> I'm wary-ish about special-casing Cool and Any in that way.

[16:02] <TimToady> in some sense, the real 'base' type is the first type derived from Cool or Any

[16:03] <TimToady> anything outside that is "linguistic" methods

[16:03] <PerlJam> .^methods(:base) ?

[16:03] <TimToady> that is, methods that are defined across the language to be somewhat coercive

[16:03] <PerlJam> .^methods(:up-level(2)) ?

[16:03] <sjn> what's the ^ for again?

[16:03] <rokoteko> what is the most important thing to know about perl6 type system?

[16:03] <PerlJam> rokoteko: it's not done yet :)

[16:03] <rokoteko> Haha :)

[16:04] <PerlJam> (whatever "done" means)

[16:04] <TimToady> rokoteko: the most important thing to realize is that it's there mostly to help with multiple dispatch

[16:04] *** jaldhar left
[16:04] <sjn> Here's my use case: Tell a kid "look, you can learn Perl 6 just by exploring the language in the REPL"

[16:04] <masak> sjn: here it's for accessing the MOP.

[16:05] <ash_gti> masak: btw, do you want to help write tutorials for try.rakudo.org? :P

[16:05] <rokoteko> TimToady: well if you are answering, you could go with top 10 most important things as well.

[16:05] <masak> sjn: but ^ in general has many meanings.

[16:05] <masak> sjn: most are related to "up", though :)

[16:05] *** cotto left
[16:05] <TimToady> most of them mean "within the domain of"

[16:05] <sjn> ...and then proceed to show 1 or 2 methods that are simple, non-magical, with sane defaults

[16:05] <ash_gti> rakudo: say "foo".HOW.methods(:local) 

[16:05] <p6eval> rakudo 5e7b43: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤  in main program body at line 22:/tmp/QIsaL4ytTJ␤»

[16:05] <ash_gti> oops

[16:05] <masak> ash_gti: I'm a tad overbooked at present. but I'd be happy to review and give suggestions.

[16:05] *** patspam1 joined
[16:05] *** patspam left
[16:05] <sjn> masak: MOP is a good enough answer for me, thanks :)

[16:05] <TimToady> .HOW requires the first arg to be a repeat of "foo"

[16:06] <ash_gti> rakudo: say ~"Foo".HOW.methods(Str, :local)

[16:06] <TimToady> which is one of the reasons we have the .^ shortcut

[16:06] <p6eval> rakudo 5e7b43: OUTPUT«ACCEPTS perl pred succ WHICH Bool Str encode␤»

[16:06] *** meppl joined
[16:06] <ash_gti> rakudo: say ~"Foo".^methods(:local); 

[16:06] <p6eval> rakudo 5e7b43: OUTPUT«ACCEPTS perl pred succ WHICH Bool Str encode␤»

[16:06] <PerlJam> TimToady: I don't think I've ever understand that particular thing.

[16:06] <ash_gti> sjn: those are two ways of doing the same thing 

[16:06] <PerlJam> er, s/understand/understood/

[16:07] <sjn> ash_gti: ah, ok, thanks :)

[16:07] <rokoteko> TimToady: is there any big 'reason' behind the type system as in haskell related to category theory? .. Not necessarily to mathmeatics of course, it would be foolish to expect that. :)

[16:07] <TimToady> you're switching the method call to a different object, so the invocant doesn't tell the system the original object

[16:08] <TimToady> rokoteko: on that level most of the coolness is just cargo culted. we talk about Mu as the top type, and Nil as the bottom type, but it's not really rigorous

[16:08] <sjn> ash_gti: although the topic I'm trying to raise here is more of a pedagogical type than a implementation details-related one

[16:08] <ash_gti> masak: if you have a moment, does my outline look okay http://github.com/moritz/try.rakudo.org/blob/master/frontend/public/js/chapters/index.js 

[16:08] <rokoteko> TimToady: ahh. Im not aware what bottom type means.

[16:09] <TimToady> then Perl 6's type system is probably good enough for you :)

[16:10] <masak> ash_gti: looks inspirational. best of luck.

[16:11] <ash_gti> isn't multi-dispatch mostly a tool for LTM?

[16:11] <rokoteko> No, I mean if Im planning of using this type system one day (in productio), Id be more comfortable doing it if I understand what it really does does.

[16:11] *** Lorn joined
[16:12] *** tomaw joined
[16:12] <ash_gti> what part's confuse you? it supports traditional and prototype inheritance, it supports roles (traits from smalltalk, or categories from objc, or modules from ruby), its very flexible 

[16:12] <rokoteko> so the most important thing to know it's not done yet. ok Im getting PerlJam. :)

[16:12] <rokoteko> PerlJam++

[16:13] *** snearch left
[16:13] *** alester joined
[16:17] <moritz_> ash_gti: looking now

[16:19] <moritz_> ... at least if github responds at some point :-)

[16:20] <ash_gti> its been slow for me too in the last few days

[16:20] <ash_gti> wonder whats up

[16:20] <moritz_> ash_gti: depending on how much you talk about regexes in Chapter 2, diving into Grammars with no exhaustive chapter on regexes might be confusing

[16:20] <moritz_> ash_gti: apart from that, it looks pretty good

[16:21] <ash_gti> i think i need to change chapter 1 

[16:21] <ash_gti> i don't know if i should get into list ops early

[16:21] *** wallberg joined
[16:21] <ash_gti> i thought they a nice feature of perl6, but i think they could get confusing if your just getting your feet wet

[16:21] <moritz_> probably better to do it as part of chapter 3

[16:21] <ash_gti> which is what chapter 1 should be about, i think 

[16:22] <moritz_> maybe Chapter 0 - Teasers

[16:22] <moritz_> with a few nice examples :-)

[16:23] <ash_gti> 1, 1, * + * ... 21 :P 

[16:23] <ash_gti> since calculating fib is really important for programmers 

[16:25] <moritz_> rakudo: say (35, 25, *-* ... 0)[*-2]

[16:25] <p6eval> rakudo 5e7b43: OUTPUT«(timeout)»

[16:25] <moritz_> rakudo: say (35, 25, *%* ... 0)[*-2]

[16:25] <p6eval> rakudo 5e7b43: OUTPUT«5␤»

[16:25] * moritz_ can't remember his own inventions

[16:26] <moritz_> GCD with serie^Wsequence operator

[16:27] <ash_gti> does rakudo support tcp/udp yet? 

[16:27] <moritz_> tcp yes

[16:27] <rokoteko> ok. what does 'rakudo' mean in this context?

[16:28] <moritz_> rokoteko: it's the name of a Perl 6 compiler

[16:28] <rokoteko> the modules provided within rakudo installation package?

[16:28] <rokoteko> so the perl6 *compiler* does support tcp but not udp?!?!

[16:28] <moritz_> currently, yes

[16:28] <rokoteko> ok. I hear you.

[16:28] <rokoteko> what are the reasons?

[16:29] <moritz_> nobody implemented udp support yet

[16:29] <rokoteko> to what?

[16:29] * moritz_ doesn't understand the question

[16:30] *** cotto joined
[16:30] <masak> heh. 'for () { ... }' doesn't work in Perl 5, but 'for (()) { ... }' does. I guess the outer parens are part of the form somehow.

[16:30] <rokoteko> so what I have learnt this far is that perl 6 compiler doesnt support udp, but it supports tcp. I havent understood why?

[16:30] <moritz_> masak: they are

[16:30] <moritz_> 18:29 < moritz_> nobody implemented udp support yet

[16:31] <masak> ok, makes sense.

[16:31] <rokoteko> moritz_: Ill drop it for tonight. thank for all the effort you took on the subject. :)

[16:31] * moritz_ sees no reason for dropping. It just hasn't been done yet, that's all.

[16:32] <rokoteko> I thinkg perl6 compiler vs some osi layer stack are orthogonal.

[16:32] <moritz_> rokoteko: it's just that some libraries are part of language

[16:32] <moritz_> rokoteko: so they are included in the compiler

[16:33] <moritz_> and nobody has written UDP libraries that rakudo could include and ship

[16:33] <rokoteko> in which language should this udp support be implemented?

[16:34] <rokoteko> parrot? perl6? c?

[16:34] <moritz_> anything you can use in Rakudo: as a parrot PMC (mostly written in C), PIR, NQP, Perl 6

[16:34] <moritz_> masak: funny detail: perl -wE 'for $a qw(foo bar baz) { say $a }'

[16:34] <rokoteko> so in which language was the TCP stack implemented with?

[16:34] <moritz_> masak: works in Perl 5 without parens (but is deprecated)

[16:34] <masak> moritz_: aye, MJD blogged about that once.

[16:34] <PerlJam> rokoteko: IMHO, in general, the higher level you can get, the better (i.e. favor NQP over PIR or C if you can)

[16:35] <florz> rokoteko: linux' tcp stack was implemented in C

[16:35] <moritz_> rokoteko: it's a Perl 6 wrapper around a parrot socket PMC, which uses the POSIX API under the hood

[16:35] <moritz_> "it's wrappers all the way down"

[16:36] <ash_gti> NCI means you can probably not have to drop into C to implement UDP, you might even be able to stay in NQP or perl6

[16:36] <rokoteko> The overhead just blinds me.

[16:36] <moritz_> you get reusability in return

[16:36] <rokoteko> I see many times?

[16:37] * moritz_ doesn't know what rokoteko sees :-)

[16:37] <rokoteko> or in which colors!

[16:38] <rokoteko> anyhow. I just had some trouble understanding why isnt UDP "implemented in the compiler" .. I still dont completely get it, but I dont have to do that right now. :) So thanks everyone for explanation.

[16:39] <moritz_> rokoteko: just remember that not all parts of a compiler are concerned with transforming source code into bytecode

[16:39] <ash_gti> at some point it becomes a runtime dependency, most socket communication is runtime not compile time

[16:41] <rokoteko> ash_gti: yes. but I was told that "udp doesn't work" because it is "not implemented in the compiler"

[16:41] <moritz_> yes, and that's true.

[16:41] <rokoteko> oh wait. I was supposed to let this go. :)

[16:41] <moritz_> the libraries are part of the compiler

[16:41] <moritz_> there's no UDP library, so it's not implemented in the compiler

[16:42] <flussence> there's always "use NativeCall;"

[16:42] *** masak left
[16:42] <flussence> then you can get someone else to do all the network stuff for you and use their libs instead :D

[16:42] <ash_gti> someone could implement it outside the compiler though, i don't see any reason why it has to be implemented in the core lib, it will probably eventually make it into the core lib, but it doesn't seem to my anyway to be a required feature of the compiler 

[16:42] <rokoteko> please, let's talk about something more interesting. anyone mind explaining as much they can about   my $x = @list;  vs  my @x = @list;  vs  my $x := @list; ... and  vs my @x := @list   ..?

[16:43] <ash_gti> = is copy assignment

[16:43] <ash_gti> := will bind 2 vars to point to the same thing 

[16:43] <flussence> $x = @list is like $x = [@list] in perl5, except you don't have to bother dereferencing it

[16:43] <ash_gti> rakudo: my $a = 1; my $b = $a; $a = 2; say $b; 

[16:43] <flussence> or something like that

[16:43] <moritz_> flussence: more like $x = \@list in Perl 5

[16:43] <p6eval> rakudo 5e7b43: OUTPUT«1␤»

[16:43] <moritz_> flussence: [...] copies

[16:44] <ash_gti> rakudo: my $a = 1; my $b := $a; $a = 2; say $b;

[16:44] <p6eval> rakudo 5e7b43: OUTPUT«2␤»

[16:45] *** perlygatekeeper joined
[16:46] <rokoteko> Hmmm. ok. that makes sence. I just once heard said that there are no references in perl6.

[16:46] <moritz_> that's kind of a marketing lie

[16:46] <flussence> rakudo: say ~(*.name => *.perl for 'a'.^methods(:local))

[16:46] <dalek> specs: c7808c3 | TimToady++ | unknown:

[16:46] <p6eval> rakudo 5e7b43: OUTPUT«===SORRY!===␤set_number_native() not implemented in class 'Num'␤»

[16:46] <dalek> specs: introspection excludes Cool and Any by default

[16:46] <dalek> specs: 

[16:46] <dalek> specs: Methods at the level of Cool and Any are language-defined methods

[16:46] <dalek> specs: more than they are exclusive methods of a specific type, so should

[16:46] <dalek> specs: be excluded from the user's view by default.

[16:46] <dalek> specs: review: http://github.com/perl6/specs/commit/c7808c3a12f8abf33c44d3b8667985cba3aa4c3b

[16:46] <moritz_> in Perl 6, nearly everything is a reference

[16:46] *** wallberg left
[16:48] <rokoteko> eval: my @arr = <a 1 b 2>; my %hash := @arr; say @arr.perl ~ " vs " ~ %hash.perl

[16:48] <PerlJam> rokoteko: what it really means is that you don't have to think about references in Perl 6.  They are largely (if not completely) transparent.

[16:48] <moritz_> %hash := @arr should be a type check failure

[16:49] <moritz_> it's not yet in Rakudo, which is a known bug

[16:49] <rokoteko> moritz_: where I could learn more about this?

[16:50] <rokoteko> link to synopsis etc is what Im looking for :)

[16:50] <flussence> rakudo: say ('a'.^methods(:local).map: -> $a { $a.name => $a }).perl

[16:50] <p6eval> rakudo 5e7b43: OUTPUT«("ACCEPTS" => { ... }, "perl" => { ... }, "pred" => { ... }, "succ" => { ... }, "WHICH" => { ... }, "Bool" => { ... }, "Str" => { ... }, "encode" => { ... })␤»

[16:50] <moritz_> http://perlgeek.de/en/article/5-to-6 has a short section about it

[16:50] <flussence> there we go.

[16:50] <moritz_> and I think S03

[16:50] <rokoteko> rakudo: my @arr = <a 1 b 2>; my %hash := @arr; say @arr.perl ~ " vs " ~ %hash.perl

[16:50] <p6eval> rakudo 5e7b43: OUTPUT«["a", "1", "b", "2"] vs ["a", "1", "b", "2"]␤»

[16:50] <flussence> not as short as I'd like however

[16:50] <rokoteko> Ahh. Wrong bot.

[16:50] <moritz_> why wrong bot?

[16:51] <flussence> std?

[16:51] <moritz_> std only does syntax checking

[16:51] <rokoteko> moritz_: earlier I prefex it with "eval:" not "rakudo:" ?

[16:51] <flussence> oh 

[16:51] <flussence> p6eval

[16:51] <moritz_> right, that didn't do anything

[16:51] <ash_gti> std: my $a = 5;

[16:51] <p6eval> std : OUTPUT«ok 00:03 117m␤»

[16:51] <flussence> wait,

[16:51] <flussence> you want "perl6:"

[16:51] * flussence still hasn't woken up today

[16:52] <moritz_> well, perl6: just runs both pugs and rakudo

[16:52] <ash_gti> perl6: say 1;

[16:52] <moritz_> pugs: my @a = <1 2 3>; my %h = @a; say %h.perl

[16:52] <p6eval> pugs, rakudo 5e7b43: OUTPUT«1␤»

[16:52] <p6eval> pugs: OUTPUT«*** Odd number of elements found where hash expected: VList [VStr "1",VStr "2",VStr "3"]␤    at /tmp/PgZNtrBGGT line 1, column 18-28␤»

[16:52] <moritz_> pugs doesn't do type checking yet

[16:53] <moritz_> s/yet//

[16:53] <rokoteko> pugs:  my @arr = <a 1 b 2>; my %hash := @arr; say @arr.perl ~ " vs " ~ %hash.perl

[16:53] <p6eval> pugs: OUTPUT«["a", "1", "b", "2"] vs ["a", "1", "b", "2"]␤»

[16:53] <flussence> rakudo: my @a = <a 1 b 2 quack>; my %h := @a; say @a.perl; say %h.perl;

[16:54] <p6eval> rakudo 5e7b43: OUTPUT«["a", "1", "b", "2", "quack"]␤["a", "1", "b", "2", "quack"]␤»

[16:54] <flussence> that looks wrong.

[16:54] *** cdarroch joined
[16:54] *** cdarroch left
[16:54] *** cdarroch joined
[16:54] <moritz_> flussence: right; should be a type error, as mentioned above

[16:54] <flussence> rakudo: my @a = <a 1 b 2 quack>; my %h := @a; say %h.WHAT

[16:54] <p6eval> rakudo 5e7b43: OUTPUT«Array()␤»

[16:55] <flussence> ouch.

[16:55] <ash_gti> o.0

[16:56] <rokoteko>  rakudo: my @a = <a 1 b 2 quack>; my %h := @a; my %x := %h; say %x.WHAT

[16:56] <ash_gti> std: my @a = <a 1 b 2 quack>; my %h := @a; say %h.WHAT

[16:56] <p6eval> rakudo 5e7b43: OUTPUT«Array()␤»

[16:56] <p6eval> std : OUTPUT«ok 00:01 118m␤»

[16:56] <dalek> roast: ef86bef | moritz++ | S03-se (10 files):

[16:56] <dalek> roast: [sequence] is the new series

[16:56] <dalek> roast: review: http://github.com/perl6/roast/commit/ef86bef352d19689ee4eee980ffc976fbedca9ba

[16:56] *** dakkar left
[16:57] <rokoteko> rakudo: my @a = <a 1 b 2 quack>; my %h := @a; my %x := %h; say %x.WHAT

[16:58] <p6eval> rakudo 5e7b43: OUTPUT«Array()␤»

[17:00] <moritz_> TimToady: S11 seems to imply that 'require Foo'; stubs a 'Foo' lexpad entry into the current scope; std doesn't. Which one should I believe?

[17:01] <moritz_> also

[17:01] <moritz_>     require "/home/non/Sense.pm" <common @horse>;

[17:01] <moritz_> looks scarily like two arbitrary terms in a row

[17:04] *** wamba joined
[17:06] <ash_gti> TimToady: does the new spec change mean it skips Cool and Any or it stops at Cool or Any?

[17:06] *** sjn left
[17:06] <moritz_> this whole 'require' thing looks like badly ported from Perl 5

[17:09] *** sjn joined
[17:09] <dalek> rakudo: c94bfe1 | moritz++ | src/Perl6/Grammar.pm:

[17:09] <dalek> rakudo: parse require

[17:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c94bfe1e40619461b738830735cc59dc7d41e005

[17:09] <dalek> rakudo: b3efa7a | moritz++ | src/Perl6/Actions.pm:

[17:09] <dalek> rakudo: implement argumentless form of require

[17:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b3efa7a74647512f7ed9b648fd76cfea43b25771

[17:09] <dalek> rakudo: 7b21bf1 | moritz++ | src/Perl6/ (2 files):

[17:09] <dalek> rakudo: implement require EXPR;

[17:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7b21bf137f8c1592f0edd98fdd4df4e91bd73162

[17:09] <dalek> rakudo: 82ebb54 | moritz++ | t/spectest.data:

[17:09] <dalek> rakudo: [t/spectest.data] track file name changes in roast

[17:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/82ebb545e88c8b754b35f31b59002efdd4d2d7fd

[17:10] <moritz_> require "string" <import list>; # evaluates "string" at run time, and <import list> at compile time

[17:10] <moritz_> that's quite confusing

[17:12] <moritz_> so, require needs a redesign, but I have no idea how the redisgn might look like

[17:12] <moritz_> ideas welcome.

[17:12] <flussence> does require have a verbose form, like module names?

[17:12] <moritz_> flussence: what do you mean?

[17:12] <flussence> require Module:file<"string">:import<x y z>; or something like that

[17:13] <flussence> where I guess :file<> would override the default search path

[17:13] <TimToady> moritz_: believe the spec on require; that particular form is nyi in std, apparently.  or maybe nli...

[17:14] <moritz_> std: require Foo <$x>; $x

[17:14] <p6eval> std : OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $x is not predeclared at /tmp/CpiEgfgdUe line 1:␤------> [32mrequire Foo <$x[33m⏏[31m>; $x[0m␤Bogus term at /tmp/CpiEgfgdUe line 1:␤------> [32mrequire Foo <$x>[33m⏏[31m; $x[0m␤Parse failed␤FAILED 00:01 117m␤»

[17:14] <moritz_> right, NYI

[17:14] <TimToady> or NLI

[17:14] <TimToady> :)

[17:14] <moritz_> where L = ?

[17:14] <TimToady> ash_gti: stops at Cool or Any

[17:15] <ash_gti> okay, just curious 

[17:15] <TimToady> no longer implemented :/

[17:16] <moritz_> I thought "Not Likely to by Implemented" :-)

[17:16] <TimToady> ah, getting aced out on LTM

[17:17] <moritz_> uhm, did STD try to interpolate $x into the <> quote?

[17:17] <TimToady> shouldn't be getting aced out, though...

[17:17] <TimToady> it parsed it as a listop rather than as a package_declarator, for some reason

[17:20] <moritz_> should I bother p6l about the require thing?

[17:21] <TimToady> why?

[17:21] <tadzik> http://wklej.org/id/392982/ -- what am I missing? . is in INC, it says

[17:21] <flussence> .oO( require Foo:in<../lib/ ./>:for<import1 import2>; )

[17:21] <ash_gti> TimToady: with .^methods(:excl(Foo)); would that skip foo or stop at foo? Assuming your inheritance was Bar -> Foo -> Baz and you invoked .^methods on Baz 

[17:21] <TimToady> :excl doesn't take an argument

[17:22] <moritz_> TimToady: because I'm looking for ways to rethink or improve require(), and I don't have any good ideas

[17:22] <TimToady> it's just short for "exclusive"

[17:22] <ash_gti> oh

[17:22] <ash_gti> okay, sorry, misunderstood its purpose, i get it now 

[17:22] <moritz_> wait... can't we just stub the lexicals with 'need'?

[17:23] <TimToady> not if the module doesn't exist yet

[17:23] <TimToady> require doesn't commit to that

[17:23] <TimToady> "assume there will be a module named Foo by the time you run this, and define these variables that will come from it then"

[17:23] <tadzik> or, what am I missing this time? http://wklej.org/id/392983/

[17:24] <moritz_> tadzik: you need 'our sub foo', and then call m1::foo

[17:25] <tadzik> moritz_: doesn't 'is export' make foo visible?

[17:25] <moritz_> tadzik: no, it just marks it for exporting

[17:25] <moritz_> tadzik: but since importing is done into the lexical pad, and the lexical pad is immutable at run time, you can't import at run time

[17:26] <tadzik> ah

[17:26] <moritz_> which is why the second form  require m1 <foo>;  exists

[17:26] <moritz_> which stubs the &foo entry in the lexpad at compile time

[17:26] <moritz_> and then binds at runtime

[17:26] <moritz_> (but that form is NYI)

[17:27] <tadzik> so how do I call a function if I have a module name in string? Through eval?

[17:27] <tadzik> I have to 'require $str; $str::foo()'?

[17:28] <moritz_> TimToady: my complaints with the current require specs are 1) the 'require "string" <importlist>' is two terms in a row (with no sufficient special-casing of the first term) and 2) that it has two arguments, the first evaluated at run time, the second at compile time. I think that's very confusing

[17:28] <moritz_> tadzik: require $str <foo>; foo; # once it's implemented

[17:28] <tadzik> oh, ok

[17:29] <TimToady> moritz_: it's not a function; declarators cheat on TTIAR all over the place

[17:30] <moritz_> TimToady: that works for me, if we have precise rules of what is allowed as one of the terms

[17:30] <moritz_> and S11 is very vague on that

[17:30] <TimToady> we will as soon as I fix STD

[17:30] <moritz_> ok

[17:31] * moritz_ fears a fix that can't easily be ported to rakudo

[17:31] <TimToady> it's the same syntax as use, more or less

[17:32] <moritz_> use doesn't allow strings as first term though

[17:33] <TimToady> that's the less part :)

[17:34] <moritz_> right :-)

[17:34] <moritz_> that's the one I worried about from the start

[17:34] * ash_gti hand wavey magic

[17:35] *** patspam joined
[17:35] <TimToady> shower &

[17:36] *** envi^home left
[17:37] <moritz_> std: Foo::Bar

[17:37] *** patspam1 left
[17:37] <p6eval> std : OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤      'Foo::Bar' used at line 1␤Check failed␤FAILED 00:02 114m␤»

[17:37] *** wamba left
[17:38] *** rrgau_ left
[17:39] *** rrgau_ joined
[17:41] *** stkowski joined
[17:42] *** rrgau_` joined
[17:42] <dalek> roast: e9774db | moritz++ | S11-modules/require.t:

[17:42] <dalek> roast: basic tests for require

[17:42] <dalek> roast: review: http://github.com/perl6/roast/commit/e9774db45b4d2dd9ecab08a5ba97c374b935a8cf

[17:44] *** rrgau_ left
[17:45] * moritz_ feels unusually productive

[17:46] <colomon> moritz_++

[17:46] <dalek> rakudo: 107cc16 | moritz++ | t/spectest.data:

[17:46] <dalek> rakudo: run tests for require

[17:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/107cc160ce9f4863cce87a4c0fc99336bc3a302c

[17:46] <dalek> rakudo: 13c8a23 | moritz++ | docs/ChangeLog:

[17:46] <dalek> rakudo: [docs] update Changelog with require and Bool stringification

[17:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/13c8a23c3ab39dfa97d6c03fa2e51d203934c684

[17:47] * colomon feels unusually unproductive

[17:49] *** daxim left
[17:55] *** perlygatekeeper left
[18:00] *** perlygatekeeper joined
[18:03] *** Italian_Plumber left
[18:14] *** jest joined
[18:15] *** jest left
[18:15] *** jest joined
[18:15] <jest> hi guys

[18:16] *** mberends joined
[18:16] <jest> I have problem building Using Perl 6

[18:16] <jest> when running make I receive error:

[18:18] <jest> http://pastie.org/1179671

[18:18] <tadzik> oh, I had something similar

[18:19] <jest> When I enter build/ and run 'makeindex UsingPerl6.a4.idx' and then 'make -I ../lib -f ../lib/Makefile' it produces PDF

[18:20] <jest> with the most serious "error" message: Overfull \hbox (171.8775pt too wide) in paragraph at lines 3623--3636

[18:21] <jest> (which is the last table in 11.2 much to wide)

[18:22] <jest> does anyone feel competent to correct the Makefile's makeindex problem?

[18:24] *** M_o_C joined
[18:26] <jest> tadzik: did you find the reason?

[18:26] <tadzik> jest: nope

[18:28] <moritz_> jest: please file a bug report at http://github.com/perl6/book/issues

[18:30] *** ash_gti left
[18:36] *** rlb3 joined
[18:39] *** rlb3 left
[18:39] *** [Coke] joined
[18:40] *** tadzik left
[18:41] *** tadzik joined
[18:45] <patspam> std: 1..2.PARROT

[18:45] <p6eval> std : OUTPUT«ok 00:01 116m␤»

[18:45] <patspam> segfaults for me (after a while)

[18:45] *** stkowski left
[18:53] <TimToady> in rakudo?

[18:53] <TimToady> rakudo: say 2.PARROT

[18:53] <p6eval> rakudo 5e7b43: OUTPUT«Int␤»

[18:54] <TimToady> rakudo: say 1..Int

[18:54] <p6eval> rakudo 5e7b43: OUTPUT«␤»

[18:54] <jest> moritz_: done, http://github.com/perl6/book/issues/issue/20

[18:54] <moritz_> jest++

[18:56] *** jferrero joined
[18:57] <patspam> TimToady: in rakudo star

[18:57] *** timbunce left
[18:58] *** stkowski joined
[19:02] <TimToady> star: say 1..Int

[19:02] <p6eval> star 2010.07: OUTPUT«␤»

[19:03] <TimToady> note that it parses as 1 .. (2.PARROT)

[19:03] *** timbunce joined
[19:17] *** fod left
[19:21] <colomon> std: (1..2).PARROT

[19:22] <p6eval> std : OUTPUT«ok 00:01 117m␤»

[19:22] <colomon> rakudo: say (1..2).PARROT

[19:22] <p6eval> rakudo 13c8a2: OUTPUT«Range␤»

[19:26] *** hanekomu_ joined
[19:30] *** plainhao left
[19:31] <patspam> 2.PARROT is ok. 1..(2.PARROT) segfaults

[19:32] <patspam> does this mean I get to submit my first rakudo bug?

[19:34] <colomon> yes

[19:34] <patspam> wooh!

[19:35] <colomon> what platform are you on?

[19:35] <colomon> star: 1..(2.PARROT)

[19:35] <p6eval> star 2010.07:  ( no output )

[19:36] *** ggoebel left
[19:36] <patspam> Ubuntu 10.04

[19:37] <colomon> I can't duplicate it here, but if 1..(2.PARROT) segfaults for you, that's definitely something that needs to be reported.

[19:38] <colomon> (at least, assuming other things on your build work -- can you do (1..2).PARROT?)

[19:40] <patspam> yeah that one works

[19:40] *** mfollett joined
[19:42] *** pyrimidine joined
[19:45] <colomon> do you know how to report a bug?

[19:45] <patspam> following: rakudo.org/submit-a-bug-report

[19:46] <colomon> patspam++ 

[19:46] <colomon> thanks!

[19:48] <colomon> (I mean, thanks for reporting a bug and thereby helping.)

[19:48] <patspam> pleasure!

[19:49] <patspam> gets more interesting.. if you run it as perl6 -e '1..2.PARROT' it does nothing (including not segfaulting). whereas if you put a "say" in there, it spews numbers onto the screen

[19:49] <patspam> for a while, until it segfaults

[19:53] <colomon> oooo

[19:53] <colomon> rakudo: say 1..2.PARROT

[19:53] <p6eval> rakudo 13c8a2: OUTPUT«␤»

[19:54] *** timbunce left
[19:54] <colomon> what version of Rakudo are you using?

[19:55] <patspam> "version 2010.07-47-g9fd5eaa built on parrot 2.6.0 r48152"

[19:55] <tadzik> star: say 1..2.PARROT

[19:55] <p6eval> star 2010.07:

[19:55] <p6eval> ..OUTPUT«(timeout)101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130…

[19:55] <patspam> there she blows!

[19:55] *** wallberg joined
[20:00] *** timbunce joined
[20:01] <patspam> bug submitted as #78034

[20:03] *** tadzik left
[20:04] <patspam> btw, I found it while reading the Using Perl 6 book (in preparation for tomorrow's Rakudo Star Study Group via Perl Seminar NY) - so yay for the book

[20:07] <slavik> omg omg omg

[20:07] <slavik> star: say 2 ** 64

[20:07] <p6eval> star 2010.07: OUTPUT«1.84467440737096e+19␤»

[20:07] <slavik> aww :(

[20:07] <slavik> still no bignum

[20:09] <flussence> rakudo: say ('0b1' ~ '0' x 60 ~ '1000').Int === ('0b1' ~ '0' x 60 ~ '1001').Int

[20:09] <p6eval> rakudo 13c8a2: OUTPUT«Bool::True␤»

[20:10] <slavik> huh?

[20:10] <flussence> oh... that adds up to 65

[20:10] <flussence> rakudo: say ('0b1' ~ '0' x 60 ~ '100').Int === ('0b1' ~ '0' x 60 ~ '101').Int

[20:10] <p6eval> rakudo 13c8a2: OUTPUT«Bool::True␤»

[20:11] <flussence> I think those are getting eaten by floating-point underflow somewhere...

[20:17] <colomon> rakudo: say ('0b1' ~ '0' x 60 ~ '101').Int.WHAT

[20:17] <p6eval> rakudo 13c8a2: OUTPUT«Int()␤»

[20:17] <colomon> :\

[20:18] <moritz_> rakudo: say Inf == Inf

[20:18] <p6eval> rakudo 13c8a2: OUTPUT«Bool::True␤»

[20:18] *** Italian_Plumber joined
[20:18] <colomon> rakudo: say ('0b1' ~ '0' x 60 ~ '101').Int

[20:18] <flussence> they come out as -9223372036854775808, which is the same I get for really big numbers in perl5 & php

[20:18] <p6eval> rakudo 13c8a2: OUTPUT«-9223372036854775808␤»

[20:19] <colomon> rakudo: say ('0b1' ~ '0' x 60 ~ '101')

[20:19] <p6eval> rakudo 13c8a2: OUTPUT«0b1000000000000000000000000000000000000000000000000000000000000101␤»

[20:19] <colomon> rakudo: say +('0b1' ~ '0' x 60 ~ '101')

[20:19] *** bluescreen left
[20:19] <p6eval> rakudo 13c8a2: OUTPUT«9.22337203685478e+18␤»

[20:20] <colomon> so this is really a story about converting Nums which are too big to Ints...

[20:21] <flussence> rakudo: say 2**63 + 1

[20:21] <p6eval> rakudo 13c8a2: OUTPUT«9.22337203685478e+18␤»

[20:21] <flussence> rakudo: say (2**63 + 1).Int

[20:21] <p6eval> rakudo 13c8a2: OUTPUT«-9223372036854775808␤»

[20:23] <flussence> eww, chrome's v8 gets it completely wrong.

[20:23] <flussence> Math.pow(2, 63) == 9223372036854776000

[20:25] <mfollett> Where would I find a list of all the things I can call on $obj.HOW at this point in time?

[20:25] *** M_o_C left
[20:26] <moritz_> mfollett: src/metamodel/*HOW.pir

[20:26] <mfollett> moritz_: Thanks!

[20:31] *** Italian_Plumber left
[20:31] *** bluescreen joined
[20:33] *** stkowski left
[20:33] <mfollett> Why do I have to provide an object to add_method when I'm adding a method to a class, e.g.: Dog.HOW.add_method( Dog.new(), 'bark', {say 'woof'})

[20:40] <mfollett> in action:

[20:41] <mfollett> oh, maybe I can't fit that on one line with the declaration of the dog class.

[20:41] <mfollett> rakudo: class Dog {}; Dog.HOW.add_method( 'bark', {say 'woof'})

[20:42] <p6eval> rakudo 13c8a2: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤  in main program body at line 22:/tmp/EdbpJHhtI4␤»

[20:42] <mfollett> class Dog {}; Dog.HOW.add_method( Dog.new(), 'bark', {say 'woof'})

[20:42] <mfollett> oops

[20:42] <mfollett> rakudo: class Dog {}; Dog.HOW.add_method( 'bark', {say 'woof'}); Dog.new.bark()

[20:42] <p6eval> rakudo 13c8a2: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤  in main program body at line 22:/tmp/tyR4YoysU5␤»

[20:43] <mfollett> rakudo: class Dog {}; Dog.HOW.add_method( Dog.new(), 'bark', {say 'woof'}); Dog.new.bark

[20:43] <p6eval> rakudo 13c8a2: OUTPUT«woof␤»

[20:51] <PerlJam> rakudo: class Dog {}; Dog.HOW.add_method( Dog(), 'bark', {say 'woof'}); Dog.new.bark

[20:51] <p6eval> rakudo 13c8a2: OUTPUT«Could not find sub &Dog␤  in main program body at line 22:/tmp/2aJltlhEFf␤»

[20:52] <mfollett> turns out you can do this:

[20:53] <mfollett> rakudo: class Dog{}; Dog.new.HOW.add_method( 'Dog', 'bark', { say 'woof' }); Dog.new.bark

[20:53] <p6eval> rakudo 13c8a2: OUTPUT«woof␤»

[20:54] <mfollett> Why does it need that second parameter though?

[20:54] *** rindolf left
[20:54] *** plobsing joined
[20:57] <mfollett> I guess ClassHOW does not know what class it would be operating on in that case?

[21:07] *** mfollett left
[21:10] *** amkrankruleuen left
[21:16] *** kjeldahl_ left
[21:17] *** jest left
[21:18] *** mfollett joined
[21:21] *** alext_ joined
[21:22] *** patspam left
[21:22] <alext_> hi, can someone point me to the regex grammars tutorial or documentation ?

[21:24] <PerlJam> alext_: There's a book in the works with a chapter on regex and another on grammars at http://github.com/perl6/book

[21:25] *** bluescreen left
[21:25] <alext_> thanks!

[21:25] <PerlJam> alext_: there's also more resources on perl6.org

[21:28] *** Ross left
[21:29] <alext_> perl 6 tutorial on the tpf site in german only 

[21:36] *** pyrimidine left
[21:37] *** patspam joined
[21:42] <dalek> perl6.org: a4d5b66 | perlpilot++ | source/documentation/index.html:

[21:42] <dalek> perl6.org: update the advent calendar

[21:42] <dalek> perl6.org: 

[21:42] <dalek> perl6.org: * change the URL to point to the page that lists all days

[21:42] <dalek> perl6.org: * Add the year in the link in preparation for the 2010 advent season

[21:42] <dalek> perl6.org: review: http://github.com/perl6/perl6.org/commit/a4d5b66cc2256c7068f40d4813429524c9c0530a

[21:47] *** ruoso left
[21:47] *** Chillance left
[21:58] *** timbunce left
[21:59] *** Holy_Cow left
[22:07] *** mikehh joined
[22:11] *** mfollett left
[22:21] *** icwiener left
[22:28] *** thepler left
[22:42] *** hanekomu_ left
[22:43] *** ggoebel joined
[22:43] *** wallberg left
[22:50] *** Italian_Plumber joined
[22:55] <sorear> good * #perl6

[22:55] *** patspam1 joined
[22:57] *** patspam left
[22:59] *** Grrrr left
[23:00] <sorear> PerlJam: You want to see less Parrot in your Perl 6?  Join me ;)

[23:13] <diakopter> star: say &say.WHO.HOW

[23:13] <p6eval> star 2010.07: OUTPUT«Method 'HOW' not found for invocant of class 'Multi'␤  in main program body at line 22:/tmp/gov1vpH_l8␤»

[23:13] *** patspam1 left
[23:19] *** patspam joined
[23:24] <sorear> How is Perl 6 doing on the 'Report' part of the backronym?  I notice we don't have a one-liner for generating a nice table display of Pascal's Triangle

[23:33] <colomon> rakudo: say ([1], -> @a { @a, 0 >>+<< 0, @a } ... *).munch(5).perl

[23:33] <p6eval> rakudo 13c8a2: OUTPUT«([1], (1, 0, 1), (1, 0, 1, 0, 1, 0, 1), (1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1), (1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1))␤»

[23:33] *** kid51 joined
[23:33] <sorear> I don't call that "nice"

[23:33] <colomon> rakudo: say ([1], -> @a { (@a, 0) >>+<< (0, @a) } ... *).munch(5).perl

[23:33] <p6eval> rakudo 13c8a2: OUTPUT«([1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1])␤»

[23:33] <colomon> I don't call it pascal's triangle, either

[23:35] <colomon> rakudo: say ([1], -> @a { (@a, 0) >>+<< (0, @a) } ... *).map({ $_ ~ "\n" }).munch(5).say

[23:35] <p6eval> rakudo 13c8a2: OUTPUT«1␤1 1␤1 2 1␤1 3 3 1␤1 4 6 4 1␤␤Bool::True␤»

[23:35] <colomon> rakudo: say ([1], -> @a { (@a, 0) >>+<< (0, @a) } ... *).map({ $_ ~ "\n" }).munch(5)

[23:35] <p6eval> rakudo 13c8a2: OUTPUT«1␤1 1␤1 2 1␤1 3 3 1␤1 4 6 4 1␤␤»

[23:35] <colomon> rakudo: say ([1], -> @a { (@a, 0) >>+<< (0, @a) } ... *).map({ $_ ~ "\n" }).munch(6)

[23:35] <p6eval> rakudo 13c8a2: OUTPUT«1␤1 1␤1 2 1␤1 3 3 1␤1 4 6 4 1␤1 5 10 10 5 1␤␤»

[23:36] <colomon> dunno if that counts as nice or not

[23:36] <sorear> colomon: I'd like each number in a box of equal width, staggered so the center column is in a constant position, half of boxes in the triangle empty

[23:37] <colomon> is there any language out there wherein that is a one liner?

[23:37] <sorear> There should be!

[23:40] <TimToady> you should really be using Z+, then you don't need the parens

[23:41] * sorear ponders a practical report language for the 21st century

[23:41] <sorear> (we have extraction down)

[23:42] <TimToady> printing pascal's triangle is not "practical" to anyone but a mathematician :)

[23:42] <TimToady> the specific problem of the triangle is that the cells have to be sized by later results

[23:45] <TimToady> but if you abandon cells, we could pretty easily do centering of pre-rendered lines

[23:46] *** ruoso joined
[23:47] <TimToady> or we could just embed TeX...

[23:50] <sorear> tex likes points

[23:50] <sorear> a lot

[23:50] <sorear> embedding nroff might work better

[23:50] <TimToady> hard to find the center character of '20'

[23:50] <TimToady> we need half-spaces :)

[23:51] <TimToady> oh wait, we'll just use the double-wides

[23:52] <TimToady> ２０

[23:53] <sorear> hmm, niecza is going to have issues with my %x; in protopads

[23:53] <sorear> it'll be interesting to ensure that class Hash; is defined first

[23:53] * sorear thinks double-wide ASCII chars are silly

[23:54] <TimToady> sure, but you'll note it lets you center a digit

[23:54] <TimToady> pity it's probably in a different font face...

[23:55] <TimToady> also a pity it doesn't actually give you generalized half-spacing :)

[23:56] <TimToady> unless you count double-spacing as normal, of course

