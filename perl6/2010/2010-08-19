[00:00] <TimToady> not yet

[00:01] *** Psyche^ joined
[00:01] <sorear> svn has some stupid feature where, after a checkin, . is out of date

[00:02] <s_mosher> ok, thanks for the help

[00:04] *** Patterner left
[00:04] *** Psyche^ is now known as Patterner

[00:06] * lue wishes he could use Perl6 instead of Javascript to code webpages.

[00:12] <Juerd> I don't do complex stuff in webpages, and javascript+jquery suffices for me :)

[00:14] <sjohnson> lue: you are not a lone.  don't tell diakopter that though

[00:14] <sjohnson> :)

[00:14] <sjohnson> alone*

[00:14] <sjohnson> rakudoscript

[00:14] <sjohnson> would be a great day for mankind's achievement

[00:15] *** lestrrat is now known as lest_away

[00:18] <lue> I use javascript for, say, making navigation updating easy. And it's been a while. Perl 6 has scarred my feelings for Javascript.

[00:21] <lue> .oO(I just want to type <script type="text/perl6"> and be done with it. Instead, I have to relearn something I'll never bother with beyond the internet.)

[00:21] <diakopter> wait, there's something beyond the internet?

[00:23] <lue> .oO[ then again, that would mean browsers would be forced to interpret Perl 6. Which isn't a bad thing, of course :) ]

[00:26] <lue> Although there are Perl 6 coded things for the web (like November), so there is hope...

[00:31] <lue> rakudo: say "tardis".pick(*)

[00:31] <p6eval> rakudo 56c846: OUTPUT«tardis␤»

[00:32] <lue> oh, let me guess, it doesn't treat that as an array of characters?

[00:33] <pugssvn> r32056 | sorear++ | [STD-dist] Follow all changes to STD, automatically extract version from svn, and add my email. 

[00:33] <sjohnson> best example of javascript difficulty is doing heredoc's in it

[00:33] <sjohnson> it's like pulling teeth

[00:34] <lue> rakudo: say "tardis".split('').pick(*)

[00:34] <p6eval> rakudo 56c846: OUTPUT«rdsiat␤»

[00:34] <lue> rakudo: say ("tardis".split('').pick(*) xx 3)

[00:35] <p6eval> rakudo 56c846: OUTPUT«atirsdatirsdatirsd␤»

[00:35] <lue> rakudo: say "tardis".split('').pick(*)

[00:35] *** tbourdon_ left
[00:35] <p6eval> rakudo 56c846: OUTPUT«itasdr␤»

[00:36] <tylercurtis> rakudo: say "tardis".comb.pick(*)

[00:36] <p6eval> rakudo 56c846: OUTPUT«rsatdi␤»

[00:36] *** tylercurtis left
[00:38] <sorear> std: 2+2

[00:38] <p6eval> std 32055: OUTPUT«ok 00:01 116m␤»

[00:40] <sorear> STD 32056 has been sent to CPAN

[00:40] <sorear> (but with the wrong version number, svn--)

[00:44] *** mulander joined
[00:44] *** rgrau joined
[00:54] *** jaldhar joined
[01:00] <sorear> STD is now indexed on CPAN

[01:14] *** dju joined
[01:17] *** dju left
[01:19] *** drbean joined
[01:20] *** dju joined
[01:22] *** dju left
[01:29] *** dju joined
[01:30] *** isBEKaml_ left
[01:30] *** am0c_ joined
[01:30] *** am0c_ is now known as am0c

[01:32] *** am0c left
[01:34] *** dju left
[01:34] *** dju joined
[01:38] *** dju left
[01:38] *** dju joined
[01:39] *** jaldhar left
[01:47] *** justatheory joined
[01:48] *** hewei joined
[01:53] *** justatheory left
[01:54] *** hewei left
[01:56] *** s_mosher left
[01:59] *** Clem_Chong joined
[02:04] *** whiteknight left
[02:06] *** redicaps joined
[02:10] *** getpwnam joined
[02:11] *** araujo joined
[02:15] *** lest_away is now known as lestrrat

[02:16] *** getpwnam left
[02:29] *** rgrau_ joined
[02:29] *** rgrau left
[02:31] *** azert0x left
[02:46] *** rgrau__ joined
[02:46] *** rgrau__ left
[02:46] *** rgrau_ left
[02:49] *** tylercurtis joined
[02:52] *** constant joined
[02:52] *** constant left
[02:52] *** constant joined
[03:01] *** jaldhar joined
[03:07] *** melte joined
[03:14] <dalek> niecza: d8781ea | sorear++ | STD_REVISION:

[03:14] <dalek> niecza: 32053 -> 32055 for Windows fixes

[03:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d8781ea88c98279a2d79f40fc0234209c591f2d7

[03:14] <dalek> niecza: 9a33e36 | sorear++ | / (3 files):

[03:14] <dalek> niecza: Integrate Niecza and STD level module metadata

[03:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9a33e36b6bd8358c2016c2aefa1705a61269d370

[03:14] <dalek> niecza: 2e8433a | sorear++ | / (6 files):

[03:14] <dalek> niecza: Store generated code in build/

[03:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2e8433abf5c13e00ee1afcda607eb4167f2e4782

[03:14] <dalek> niecza: f71920f | sorear++ | / (31 files):

[03:14] <dalek> niecza: build -> obj, move perl5 compiler parts to src/

[03:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/f71920f5366bee7e095e32931225196846e58d4a

[03:31] *** redicaps left
[03:38] *** Clem_Chong left
[03:44] *** redicaps joined
[03:56] <ingy> hi

[03:56] <ingy> how do you tell a grammar rule not to backtrack before this point?

[03:57] <ingy> ie, this token is a match, if something past it fails, stop and fail.

[03:57] <tylercurtis> ::, I think.

[03:57] <tylercurtis> http://perlcabal.org/syn/S05.html#Backtracking_control

[03:59] <ingy> tylercurtis: yeah I'm reading that already, but not taking much away.

[04:00] <rcfox> It is kind of hard to read.

[04:00] <ingy> so this: [ if :: not | ify ]

[04:00] <ingy> 'if' is just a pattern?

[04:01] <tylercurtis> Right.

[04:01] <tylercurtis> Although that's probably a bad example, since ify would beat if on LTM, I think.

[04:01] <ingy> could be: [ xx :: yy | zz ]

[04:01] <ingy> what is ify?

[04:01] <tylercurtis> The same as "ify"

[04:02] <ingy> i mean, is ify a perl 6 command?

[04:02] <ingy> not in the grammar but in real life

[04:03] <tylercurtis> Not that I'm aware of.

[04:04] <ingy> anyway :: works for me as a syntax. I'm not sure I fully grok the semantics. nor how it compares to the ::: or the :

[04:05] <ingy> anyway, it's a start

[04:05] <ingy> I'll read the tests when I have morning brain power...

[04:06] <ingy> I'm about halfway through being able to compile a pegex grammar with pegex itself

[04:06] <ingy> I wrote a bootstrapping parser/compiler

[04:06] *** wooden joined
[04:06] *** wooden left
[04:06] *** wooden joined
[04:06] <sorear> ingy: if you want the entire match to fail, use <commit>

[04:06] <ingy> so now I am building a suite of tests that make sure the two match

[04:07] *** achromic left
[04:07] <ingy> sorear: <commit> is a special rule name?

[04:08] <sorear> ingy: yes, it's predefined.  no, you can override it, it's just a method like anything else.

[04:08] <tylercurtis> ingy: well, if you had regex a { [ [ if :: foo | something ]  | something else ] }, it could still backtrack into the something else part. But if you had ::: instead, the whole rule would fail. I think.

[04:08] <ingy> pegex would use <COMMIT> as uppercase is the namespacing between user defined and language defined....

[04:09] <sorear> <commit> in perl6 is no more magical than &die

[04:09] <sorear> it hooks into runtime functions, but it's itself quite ordinary

[04:09] <ingy> yeah, I get it. I just don't like the namespacing the perl 6 uses. requires to much special knowledge

[04:10] *** [Coke] joined
[04:10] <ingy> and doesn't seem future proof thoughtful...

[04:11] <[Coke]> .

[04:11] <ingy> although that seems to be the perl6 attitude.

[04:11] <ingy> it's done when we say it is.

[04:11] <ingy> unless we decide it's not.

[04:11] <ingy> :)

[04:12] *** achromic joined
[04:12] <ingy> tylercurtis: i'll copy your example to a local file and look in the morning.

[04:12] <ingy> to tired and cranky

[04:12] <ingy> can't you tell? ;)

[04:12] <ingy> too

[04:15] <tylercurtis> I don't think there's really much risk of clashes. If code has a <foo> subrule call in a grammar, that means that there must be a a foo defined somewhere in its MRO. So, if a <foo> predefined subrule gets added, it just gets added in Grammar(or is it Cursor?). The defined one in the grammar still takes precedence. The only problem is that it can be confusing to read.

[04:21] *** go|dfish joined
[04:21] <ingy> tylercurtis: nod. TestML uses the UPPER vs lower namespacing, and it plays out well, so I'm trying adopting it for pegex

[04:22] <ingy> i think it makes easier grokking,

[04:35] <sorear> Namespacing is great for a fairly static language

[04:35] <sorear> Old-school Perl used foo() for system functions and &foo() for user ones

[04:35] *** macroron joined
[04:36] <sorear> But once you start building up a culture of extension, the distinction between system functions and library functions becomes less important, and so people like to call them the same

[04:41] <ingy> sorear: that's a good point...

[04:41] <dukeleto> How does one put something into boolean context in Perl 6?

[04:41] <[Coke]> dukeleto: ?what

[04:41] <ingy> star: say Bool(42)

[04:41] <p6eval> star 2010.07: OUTPUT«Could not find sub &Bool␤  in main program body at line 22:/tmp/JPREEoQwVF␤»

[04:41] <[Coke]> star: say ?42

[04:41] <tylercurtis> star: say 42.Bool

[04:42] <p6eval> star 2010.07: OUTPUT«1␤»

[04:42] <dukeleto> thanks!

[04:42] <ingy> dukeleto: tmtowtdiaalowtdiw

[04:43] <ingy> (and at least one way to do it wrong)

[04:43] <rcfox> Does .ast work for Matches?

[04:43] <rcfox> I keep getting Any()

[04:43] <tylercurtis> rcfox: are you sure you're using &make?

[04:43] <rcfox> What?

[04:44] <rcfox> rakudo: my $a = 'test' ~~ /(t(.*)t)/; say $a.ast;

[04:44] <p6eval> rakudo 56c846: OUTPUT«Any()␤»

[04:44] <tylercurtis> That's correct.

[04:44] <rcfox> What is &make?

[04:45] <ingy> it puts things in the ast

[04:45] <ingy> that's all I know...

[04:45] <rcfox> Oh.

[04:46] <tylercurtis> rakudo: grammar Foo { token TOP { abc } }; class Foo::Actions { method TOP($/) { make ~$/; } }; say Foo.parse(:actions(Foo::Actions.new), 'abc')).ast

[04:46] <p6eval> rakudo 56c846: OUTPUT«===SORRY!===␤Confused at line 22, near ").ast"␤»

[04:46] <tylercurtis> rakudo: grammar Foo { token TOP { abc } }; class Foo::Actions { method TOP($/) { make ~$/; } }; say Foo.parse(:actions(Foo::Actions.new), 'abc').ast

[04:46] <p6eval> rakudo 56c846: OUTPUT«abc␤»

[04:46] <tylercurtis> rakudo: grammar Foo { token TOP { abc } }; class Foo::Actions { method TOP($/) { make 5; } }; say Foo.parse(:actions(Foo::Actions.new), 'abc').ast

[04:46] <p6eval> rakudo 56c846: OUTPUT«5␤»

[04:47] <rcfox> Where is this documented?

[04:47] <tylercurtis> http://perlcabal.org/syn/S05.html#Match_objects

[04:49] <rcfox> And the actions thing?

[04:50] <rcfox> I saw something about it in the grammar section, but it's just like "Oh, and here you pass a reference to actions."

[04:50] <rcfox> No information about what they are or how to use them...

[04:50] <tylercurtis> hmm... I don't see anything in the spec describing it.

[04:51] <dukeleto> sorear: i added a test to PL/Parrot that shows off Perl 6 grammars : http://github.com/leto/plparrot/commit/804ec6110391a6d65788de682280321581c18d7d

[04:51] <dukeleto> tylercurtis: is it described in the Squaak tutorial ?

[04:51] <tylercurtis> dukeleto: Well, it's definitely demonstrated in it, but I don't remember if it explains in detail how they work.

[04:52] <tylercurtis> rcfox: http://perl6advent.wordpress.com/2009/12/21/day-21-grammars-and-actions/

[04:52] <dukeleto> tylercurtis: that might be something nice to add

[04:53] *** melte left
[04:54] <rcfox> Hm, thanks.

[04:54] *** melte joined
[05:10] <pugssvn> r32057 | pmichaud++ | [t/spec]:  Update some Nil-related tests for undefined Nil. 

[05:12] <pugssvn> r32058 | pmichaud++ | [t/spec]:  Fudge some Nil-related tests. 

[05:22] *** mutewit joined
[05:32] *** Clem_Chong joined
[05:32] *** blogometer left
[05:33] <Clem_Chong> evalbot usage:'perl6:say hello;'

[05:34] <Clem_Chong> perl6:say hello;

[05:35] <tylercurtis> You want perl6: say 'foo', although I'd recommend just doing star: say 'foo' or rakudo: say 'foo'. perl6: is a bit noisy.

[05:37] *** macroron left
[05:37] <Clem_Chong> perl6:say 'foo';

[05:37] <tylercurtis> You need a space there after the colon, I think.

[05:38] <Clem_Chong> perl6: say 'foo';

[05:38] <p6eval> pugs, rakudo 56c846: OUTPUT«foo␤»

[05:38] <Clem_Chong> :(

[05:38] <rcfox> Clem_Chong: Darn, it works.

[05:38] <tylercurtis> Well, it seems perl6: has been trimmed down a little.

[05:39] <rcfox> How can I add another argument to the .ast method signatures?

[05:40] <Clem_Chong> Ok,don't play that,I find you perl guy's code is smart,how can you do that?

[05:40] <rcfox> method foo($/, $bar) gives me this when I try to call $/<foo>.ast(3): 'Not enough positional parameters passed; got 2 but expected 3'

[05:42] <rcfox> I'd like to be able to pass along the node depth.

[05:44] <mathw> o/

[05:46] <dukeleto> has anybody done any kind of SHA implementation in Perl 6?

[05:47] <sorear> rcfox: ast is just a variable, it doesn't call methods at all

[05:47] *** [Coke] left
[05:49] <sorear> Clem_Chong: I'm terrible with pronouns.  How can I do what?

[05:55] *** wtw joined
[05:59] *** kaare joined
[05:59] *** kaare is now known as Guest2438

[06:00] <dalek> rakudo: 7530af5 | mathw++ | docs/ChangeLog:

[06:00] <dalek> rakudo: Update ChangeLog for 2010.08 release.

[06:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7530af51235df6c47d34843bee97ce1d3140d726

[06:00] <dalek> rakudo: f1b8aca | mathw++ | docs/announce/2010.08:

[06:00] <dalek> rakudo: Finish release announcement for 2010.08.

[06:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f1b8aca2039804d393b44903406960591dcebd10

[06:00] <dalek> rakudo: 99a4e24 | mathw++ | docs/release_guide.pod:

[06:00] <dalek> rakudo: Update release guide with 2010.08 release.

[06:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/99a4e24d0705a485ce2c6ba6a1ddd47280705a10

[06:03] *** drbean left
[06:12] *** uniejo joined
[06:25] <dalek> niecza: b82b1c8 | sorear++ | / (16 files):

[06:25] <dalek> niecza: Move Perl6 runtime library code to lib/

[06:25] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b82b1c86a3834fb192daedbd8545b5db46a1c163

[06:25] <dalek> niecza: 14af68a | sorear++ | / (2 files):

[06:25] <dalek> niecza: Allow niecza to be used from outside the source tree

[06:25] <dalek> niecza: 

[06:25] <dalek> niecza: It's not installable, but you can symlink it into $PATH and it will be able to

[06:25] <dalek> niecza: find the standard libraries and support code.

[06:25] <dalek> niecza: review: http://github.com/sorear/niecza/commit/14af68aeb75a1ca46b4abc3c86cef956ebd473cc

[06:30] *** wooden left
[06:31] *** wooden joined
[06:31] *** wooden left
[06:34] *** drbean joined
[06:36] *** wooden joined
[06:36] *** wooden left
[06:36] *** wooden joined
[06:50] *** Guest2438 is now known as kaare_

[06:52] *** tylercurtis left
[06:54] *** mberends left
[07:04] *** tylercurtis joined
[07:05] <sorear> I wonder if I should commit a copy of the compiled Niecza grammar

[07:16] *** tylercurtis left
[07:17] *** wtw left
[07:17] *** wtw joined
[07:21] *** timbunce joined
[07:43] *** _madmax_ left
[08:00] *** mulander left
[08:02] *** flatwhatson left
[08:02] *** sftp left
[08:02] *** cotto_work left
[08:02] *** drbean left
[08:02] *** mmmpork left
[08:02] *** timbunce left
[08:02] *** uniejo left
[08:02] *** kaare_ left
[08:02] *** simcop2387 left
[08:02] *** krunen_ left
[08:02] *** go|dfish left
[08:02] *** [particle] left
[08:02] *** pugssvn left
[08:02] *** PerlJam left
[08:02] *** wooden left
[08:02] *** constant left
[08:02] *** Grrrr left
[08:02] *** NOTevil left
[08:02] *** hsb left
[08:02] *** melte left
[08:02] *** ruoso left
[08:02] *** hercynium left
[08:02] *** daemon left
[08:02] *** PZt left
[08:02] *** shade_ left
[08:19] *** xinming_ left
[08:20] *** xinming joined
[08:24] *** thebird joined
[08:35] *** dakkar joined
[08:38] *** _madmax_ joined
[08:41] *** [synth] joined
[08:42] *** synth left
[08:46] *** betterworld joined
[08:48] *** snearch joined
[08:48] *** melte joined
[08:48] *** ruoso joined
[08:48] *** hercynium joined
[08:48] *** daemon joined
[08:48] *** PZt joined
[08:48] *** jdv79 joined
[08:48] *** TiMBuS joined
[08:48] *** astinus joined
[08:48] *** treed joined
[08:48] *** timdemkowsky joined
[08:48] *** patch joined
[08:48] *** breinbaas joined
[08:48] *** frooh joined
[08:51] *** mulander joined
[08:56] *** f00li5h joined
[08:57] *** sunnavy_ joined
[08:57] *** krakan_ joined
[08:57] *** f00li5h left
[08:57] *** f00li5h joined
[08:58] *** pjcj_ joined
[08:58] *** hillu_ joined
[09:03] *** HarryS left
[09:03] *** japhb left
[09:03] *** BinGOs left
[09:03] *** shelling_lab left
[09:03] *** mulander left
[09:03] *** snearch left
[09:03] *** melte left
[09:03] *** ruoso left
[09:03] *** hercynium left
[09:03] *** daemon left
[09:03] *** PZt left
[09:03] *** jdv79 left
[09:03] *** TiMBuS left
[09:03] *** astinus left
[09:03] *** timdemkowsky left
[09:03] *** breinbaas left
[09:03] *** frooh left
[09:03] *** patch left
[09:03] *** treed left
[09:03] *** betterworld left
[09:03] *** wtw left
[09:03] *** dju left
[09:03] *** pnu left
[09:03] *** Util left
[09:03] *** cozmic left
[09:03] *** ascent_ left
[09:03] *** spacebat left
[09:03] *** kirillm left
[09:03] *** jjore left
[09:03] *** shabble left
[09:03] *** Getty left
[09:03] *** Gothmog_ left
[09:03] *** cono left
[09:03] *** dalek left
[09:03] *** _sri left
[09:03] *** Bucciarati left
[09:03] *** mathw left
[09:03] *** lestrrat left
[09:03] *** frodwith left
[09:03] *** m6locks left
[09:12] *** Trashlord joined
[09:12] *** betterworld joined
[09:12] *** wtw joined
[09:12] *** dju joined
[09:12] *** cozmic joined
[09:12] *** pnu joined
[09:12] *** Util joined
[09:12] *** avuserow joined
[09:12] *** mantovani joined
[09:12] *** itz joined
[09:12] *** barika joined
[09:12] *** stepnem joined
[09:12] *** jettero joined
[09:12] *** jnthn joined
[09:12] *** nperez joined
[09:12] *** spq1 joined
[09:12] *** tomaw joined
[09:12] *** ascent_ joined
[09:12] *** kirillm joined
[09:12] *** spacebat joined
[09:12] *** shabble joined
[09:12] *** Getty joined
[09:12] *** jjore joined
[09:12] *** Gothmog_ joined
[09:13] *** cono joined
[09:13] *** proller_ joined
[09:13] *** cottoo joined
[09:13] *** nadim joined
[09:13] *** thepler joined
[09:13] *** _sri joined
[09:13] *** Bucciarati joined
[09:13] *** mathw joined
[09:13] *** lestrrat joined
[09:13] *** m6locks joined
[09:13] *** frodwith joined
[09:14] *** slavik joined
[09:14] *** snearch joined
[09:14] *** melte joined
[09:14] *** ruoso joined
[09:14] *** hercynium joined
[09:14] *** daemon joined
[09:14] *** PZt joined
[09:14] *** jdv79 joined
[09:14] *** TiMBuS joined
[09:14] *** astinus joined
[09:14] *** treed joined
[09:14] *** timdemkowsky joined
[09:14] *** patch joined
[09:14] *** breinbaas joined
[09:14] *** frooh joined
[09:14] *** Trashlord is now known as Guest41392

[09:14] *** HarryS joined
[09:14] *** mulander joined
[09:14] *** Guest41392 left
[09:14] *** betterworld left
[09:14] *** wtw left
[09:14] *** dju left
[09:14] *** pnu left
[09:14] *** Util left
[09:14] *** avuserow left
[09:14] *** mantovani left
[09:14] *** cozmic left
[09:14] *** itz left
[09:14] *** barika left
[09:14] *** stepnem left
[09:14] *** jettero left
[09:14] *** jnthn left
[09:14] *** nperez left
[09:14] *** spq1 left
[09:14] *** tomaw left
[09:14] *** ascent_ left
[09:14] *** spacebat left
[09:14] *** kirillm left
[09:14] *** jjore left
[09:14] *** shabble left
[09:14] *** Getty left
[09:14] *** Gothmog_ left
[09:14] *** HarryS left
[09:14] *** mulander left
[09:14] *** slavik left
[09:14] *** snearch left
[09:14] *** melte left
[09:14] *** ruoso left
[09:14] *** hercynium left
[09:14] *** daemon left
[09:14] *** PZt left
[09:14] *** jdv79 left
[09:14] *** TiMBuS left
[09:14] *** astinus left
[09:14] *** timdemkowsky left
[09:14] *** breinbaas left
[09:14] *** frooh left
[09:14] *** patch left
[09:14] *** treed left
[09:15] *** cono left
[09:15] *** proller_ left
[09:15] *** cottoo left
[09:15] *** nadim left
[09:15] *** thepler left
[09:15] *** _sri left
[09:15] *** Bucciarati left
[09:15] *** mathw left
[09:15] *** lestrrat left
[09:15] *** frodwith left
[09:15] *** m6locks left
[09:17] *** japhb joined
[09:17] *** mulander joined
[09:17] *** frooh joined
[09:17] *** breinbaas joined
[09:17] *** patch joined
[09:17] *** timdemkowsky joined
[09:17] *** treed joined
[09:17] *** astinus joined
[09:17] *** TiMBuS joined
[09:17] *** jdv79 joined
[09:17] *** PZt joined
[09:17] *** daemon joined
[09:17] *** hercynium joined
[09:17] *** ruoso joined
[09:17] *** melte joined
[09:17] *** snearch joined
[09:17] *** slavik joined
[09:17] *** frodwith joined
[09:17] *** m6locks joined
[09:17] *** lestrrat joined
[09:17] *** mathw joined
[09:17] *** Bucciarati joined
[09:17] *** _sri joined
[09:17] *** thepler joined
[09:17] *** nadim joined
[09:17] *** cottoo joined
[09:17] *** proller_ joined
[09:17] *** cono joined
[09:17] *** Guest41392 joined
[09:17] *** betterworld joined
[09:17] *** wtw joined
[09:17] *** dju joined
[09:17] *** cozmic joined
[09:17] *** pnu joined
[09:17] *** Util joined
[09:17] *** avuserow joined
[09:17] *** mantovani joined
[09:17] *** itz joined
[09:17] *** barika joined
[09:17] *** stepnem joined
[09:17] *** jettero joined
[09:17] *** jnthn joined
[09:17] *** nperez joined
[09:17] *** spq1 joined
[09:17] *** tomaw joined
[09:17] *** ascent_ joined
[09:17] *** kirillm joined
[09:17] *** spacebat joined
[09:17] *** shabble joined
[09:17] *** Getty joined
[09:17] *** jjore joined
[09:17] *** Gothmog_ joined
[09:18] *** eternale1e joined
[09:18] *** nine_ joined
[09:18] *** Helios- joined
[09:18] *** uniejo joined
[09:18] *** kaare_ joined
[09:19] *** [particle] joined
[09:19] *** pugssvn joined
[09:19] *** PerlJam joined
[09:19] *** osfameron joined
[09:19] *** takadonet joined
[09:19] *** bbkr joined
[09:19] *** pochi joined
[09:19] *** cosimo joined
[09:19] *** gabiruh joined
[09:19] *** perigrin joined
[09:19] *** _ilbot2 joined
[09:19] *** Sanitoeter joined
[09:19] *** PacoLinux joined
[09:19] *** xiaolongxia joined
[09:19] *** yahooooo joined
[09:19] *** card.freenode.net sets mode: +vv pugssvn _ilbot2

[09:20] *** HarryS joined
[09:20] *** go|dfish joined
[09:20] *** simcop2387 joined
[09:20] *** krunen_ joined
[09:20] *** au|irc joined
[09:20] *** lucs joined
[09:20] *** kst joined
[09:20] *** rbuels joined
[09:20] *** Sarten-X2 joined
[09:20] *** draxil joined
[09:20] *** Woody2143 joined
[09:20] *** dalek joined
[09:20] *** jedai_ joined
[09:20] *** flatwhatson joined
[09:20] *** sftp joined
[09:20] *** gfldex joined
[09:20] *** moritz_ joined
[09:20] *** thebird is now known as 84XAATGC2

[09:21] *** thebird joined
[09:21] *** Lorn joined
[09:21] *** daxim joined
[09:21] *** foodoo joined
[09:21] *** wooden joined
[09:21] *** constant joined
[09:21] *** Grrrr joined
[09:21] *** NOTevil joined
[09:21] *** hsb joined
[09:21] *** literal joined
[09:21] *** avar joined
[09:21] *** IllvilJa joined
[09:21] *** kolibrie_ joined
[09:21] *** cognominal joined
[09:21] *** felliott__ joined
[09:21] *** robinsmidsrod joined
[09:21] *** Snowclone joined
[09:21] *** Maddingue joined
[09:21] *** shelling_lab joined
[09:21] *** drbean joined
[09:21] *** mmmpork joined
[09:21] *** huf joined
[09:21] *** x3nU joined
[09:21] *** phenny joined
[09:21] *** renormalist joined
[09:21] *** aesop joined
[09:21] *** rokoteko joined
[09:21] *** card.freenode.net sets mode: +v phenny

[09:21] *** cotto_work joined
[09:21] *** WAA3OEL joined
[09:21] *** Guest41392 left
[09:21] *** betterworld left
[09:21] *** wtw left
[09:21] *** dju left
[09:21] *** pnu left
[09:21] *** Util left
[09:21] *** avuserow left
[09:21] *** mantovani left
[09:21] *** cozmic left
[09:21] *** itz left
[09:21] *** barika left
[09:21] *** stepnem left
[09:21] *** jettero left
[09:21] *** jnthn left
[09:21] *** nperez left
[09:21] *** spq1 left
[09:21] *** tomaw left
[09:21] *** ascent_ left
[09:21] *** spacebat left
[09:21] *** kirillm left
[09:21] *** jjore left
[09:21] *** shabble left
[09:21] *** Getty left
[09:21] *** Gothmog_ left
[09:21] *** shelling_lab left
[09:21] *** drbean left
[09:21] *** mmmpork left
[09:21] *** huf left
[09:21] *** x3nU left
[09:21] *** phenny left
[09:21] *** renormalist left
[09:21] *** aesop left
[09:21] *** rokoteko left
[09:21] *** thebird left
[09:21] *** Lorn left
[09:21] *** daxim left
[09:21] *** foodoo left
[09:21] *** wooden left
[09:21] *** constant left
[09:21] *** Grrrr left
[09:21] *** NOTevil left
[09:21] *** hsb left
[09:21] *** literal left
[09:21] *** avar left
[09:21] *** IllvilJa left
[09:21] *** kolibrie_ left
[09:21] *** cognominal left
[09:21] *** felliott__ left
[09:21] *** Snowclone left
[09:21] *** robinsmidsrod left
[09:21] *** Maddingue left
[09:21] *** cotto_work left
[09:21] *** dalek left
[09:22] *** jedai_ left
[09:22] *** flatwhatson left
[09:22] *** sftp left
[09:22] *** gfldex left
[09:22] *** moritz_ left
[09:22] *** simcop2387 left
[09:22] *** krunen_ left
[09:22] *** go|dfish left
[09:22] *** au|irc left
[09:22] *** lucs left
[09:22] *** kst left
[09:22] *** rbuels left
[09:22] *** Sarten-X2 left
[09:22] *** Woody2143 left
[09:22] *** draxil left
[09:22] *** [particle] left
[09:22] *** pugssvn left
[09:22] *** PerlJam left
[09:22] *** takadonet left
[09:22] *** bbkr left
[09:22] *** pochi left
[09:22] *** cosimo left
[09:22] *** gabiruh left
[09:22] *** perigrin left
[09:22] *** _ilbot2 left
[09:22] *** osfameron left
[09:22] *** Sanitoeter left
[09:22] *** PacoLinux left
[09:22] *** xiaolongxia left
[09:22] *** yahooooo left
[09:22] *** uniejo left
[09:22] *** kaare_ left
[09:22] *** HarryS left
[09:22] *** mulander left
[09:22] *** japhb left
[09:22] *** slavik left
[09:22] *** snearch left
[09:22] *** melte left
[09:22] *** ruoso left
[09:22] *** hercynium left
[09:22] *** daemon left
[09:22] *** PZt left
[09:22] *** jdv79 left
[09:22] *** TiMBuS left
[09:22] *** astinus left
[09:22] *** timdemkowsky left
[09:22] *** breinbaas left
[09:22] *** frooh left
[09:22] *** patch left
[09:22] *** treed left
[09:22] *** cono left
[09:22] *** proller_ left
[09:22] *** cottoo left
[09:22] *** nadim left
[09:22] *** thepler left
[09:22] *** _sri left
[09:22] *** Bucciarati left
[09:22] *** mathw left
[09:22] *** lestrrat left
[09:22] *** frodwith left
[09:22] *** m6locks left
[09:23] *** cls_bsd_ joined
[09:26] *** Tene left
[09:29] *** 84XAATGC2 left
[09:29] *** cls_bsd_ is now known as cls_bsd

[09:29] *** szabgab left
[09:29] *** grew left
[09:31] *** araujo left
[09:35] *** wamba joined
[09:35] *** meteorjay joined
[09:35] *** szabgab joined
[09:35] *** buubot joined
[09:35] *** BinGOs joined
[09:35] *** c9s joined
[09:35] *** grew_ joined
[09:35] *** rhr_ joined
[09:35] *** TimToady_ joined
[09:35] *** WAA3OEL joined
[09:35] *** cotto_work joined
[09:35] *** rokoteko joined
[09:35] *** aesop joined
[09:35] *** renormalist joined
[09:35] *** phenny joined
[09:35] *** x3nU joined
[09:35] *** huf joined
[09:35] *** mmmpork joined
[09:35] *** shelling_lab joined
[09:35] *** Maddingue joined
[09:35] *** Snowclone joined
[09:35] *** robinsmidsrod joined
[09:35] *** felliott__ joined
[09:35] *** cognominal joined
[09:35] *** kolibrie_ joined
[09:35] *** IllvilJa joined
[09:35] *** avar joined
[09:35] *** literal joined
[09:35] *** hsb joined
[09:35] *** NOTevil joined
[09:35] *** Grrrr joined
[09:35] *** constant joined
[09:35] *** wooden joined
[09:35] *** foodoo joined
[09:35] *** daxim joined
[09:35] *** Lorn joined
[09:35] *** thebird joined
[09:35] *** moritz_ joined
[09:35] *** gfldex joined
[09:35] *** sftp joined
[09:35] *** flatwhatson joined
[09:35] *** jedai_ joined
[09:35] *** dalek joined
[09:35] *** Woody2143 joined
[09:35] *** draxil joined
[09:35] *** Sarten-X2 joined
[09:35] *** rbuels joined
[09:35] *** card.freenode.net sets mode: +v phenny

[09:35] *** kst joined
[09:35] *** lucs joined
[09:35] *** au|irc joined
[09:35] *** krunen_ joined
[09:35] *** simcop2387 joined
[09:35] *** go|dfish joined
[09:35] *** HarryS joined
[09:35] *** yahooooo joined
[09:35] *** xiaolongxia joined
[09:35] *** PacoLinux joined
[09:35] *** Sanitoeter joined
[09:35] *** _ilbot2 joined
[09:35] *** perigrin joined
[09:35] *** gabiruh joined
[09:35] *** cosimo joined
[09:35] *** pochi joined
[09:35] *** bbkr joined
[09:35] *** takadonet joined
[09:35] *** osfameron joined
[09:35] *** PerlJam joined
[09:35] *** pugssvn joined
[09:35] *** [particle] joined
[09:35] *** kaare_ joined
[09:35] *** uniejo joined
[09:35] *** japhb joined
[09:35] *** mulander joined
[09:35] *** frooh joined
[09:35] *** breinbaas joined
[09:35] *** patch joined
[09:35] *** timdemkowsky joined
[09:35] *** treed joined
[09:35] *** astinus joined
[09:35] *** TiMBuS joined
[09:35] *** jdv79 joined
[09:35] *** PZt joined
[09:35] *** daemon joined
[09:35] *** hercynium joined
[09:35] *** ruoso joined
[09:35] *** melte joined
[09:35] *** snearch joined
[09:35] *** slavik joined
[09:35] *** frodwith joined
[09:35] *** m6locks joined
[09:35] *** lestrrat joined
[09:35] *** mathw joined
[09:35] *** Bucciarati joined
[09:35] *** _sri joined
[09:35] *** card.freenode.net sets mode: +vv _ilbot2 pugssvn

[09:35] *** thepler joined
[09:35] *** nadim joined
[09:35] *** cottoo joined
[09:35] *** proller_ joined
[09:35] *** cono joined
[09:35] *** Guest41392 joined
[09:35] *** betterworld joined
[09:35] *** wtw joined
[09:35] *** dju joined
[09:35] *** cozmic joined
[09:35] *** pnu joined
[09:35] *** Util joined
[09:35] *** avuserow joined
[09:35] *** mantovani joined
[09:35] *** itz joined
[09:35] *** barika joined
[09:35] *** stepnem joined
[09:35] *** jettero joined
[09:35] *** jnthn joined
[09:35] *** nperez joined
[09:35] *** spq1 joined
[09:35] *** tomaw joined
[09:35] *** ascent_ joined
[09:35] *** kirillm joined
[09:35] *** spacebat joined
[09:35] *** shabble joined
[09:35] *** Getty joined
[09:35] *** jjore joined
[09:35] *** Gothmog_ joined
[09:36] *** araujo joined
[09:36] *** ChanServ sets mode: +v dalek

[09:36] *** HarryS is now known as Guest197

[09:37] *** masak joined
[09:37] *** BinGOs left
[09:37] *** BinGOs joined
[09:37] <masak> oh hai, #perl6!

[09:37] <sorear> Hi masak!

[09:37] <moritz_> oh hai masak

[09:37] <frettled> Don't jump the shark, masak!

[09:37] <moritz_> seems we have bad net weather

[09:37] <Juerd> Where's the forecast?

[09:38] <masak> frettled: I've never grokked that expression.

[09:38] <moritz_> Juerd: netsplits and tcplightning

[09:38] <frettled> masak: http://en.wikipedia.org/wiki/Jumping_the_shark

[09:39] <masak> thank you.

[09:39] <frettled> masak: I understand it intellectually, but as I haven't seen the show they refer to, it remains a distant connection for me, too.

[09:40] <masak> wow. a TV show where they actually jumped an actual shark.

[09:40] <frettled> :)

[09:40] <daxim> blow your mind:  http://tvtropes.org/pmwiki/pmwiki.php/Main/JumpingTheShark  (careful, wiki crack)

[09:45] *** Guest197 left
[09:45] *** HarryS joined
[09:47] *** pnate joined
[09:52] *** redicaps left
[09:54] *** redicaps joined
[09:54] *** redicaps left
[09:54] <jnthn> oh morning

[09:54] <sorear> hello jnthn 

[09:54] <moritz_> \o

[09:55] <dalek> niecza: affeabf | sorear++ | src/ (3 files):

[09:55] <dalek> niecza: Embed transitive dependency info in metadata

[09:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/affeabf57a298016341fa52683e42ee9df38f077

[09:55] <dalek> niecza: 94a7784 | sorear++ | / (7 files):

[09:55] <dalek> niecza: Disallow compiling modules by file name

[09:55] <dalek> niecza: 

[09:55] <dalek> niecza: The important case always starts with a module name, and it's much simpler if

[09:55] <dalek> niecza: we always start with one.

[09:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/94a7784450c363849b3f48520ca1ed105df8bc07

[09:55] <dalek> niecza: 7a02246 | sorear++ | src/CompilerDriver.pm:

[09:55] <dalek> niecza: Implement automatic compilation of imported modules

[09:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/7a022465f46aa808744b7c6ea6d9a30d78e89803

[09:55] <masak> sorear++ # STD on CPAN

[09:55] <moritz_> jnthn: would you like to have 6model commits reported here?

[09:55] <masak> sorear: how come viv isn't marked executable?

[09:56] *** M_o_C joined
[09:57] <jnthn> moritz_: I don't mind either way - as the note on the repo says, it's meant to be temporary.

[09:57] <sorear> masak: 1, I don't understand that aspect of the toolchain

[09:57] <sorear> 2, I didn't see an easy way to make it marked

[09:57] <jnthn> moritz_: If people are interested in seeing what's going on there, then I've no objections.

[09:58] <sorear> 3, It wouldn't work anyway

[09:58] <sorear> viv needs a large amount of rethinking before it's usable as a tool in $PATH

[09:58] <masak> sorear: fair enough. just wondering. in the best of worlds, it might even be installed as a 'binary' somewhere.

[09:58] <masak> oh, ok.

[09:59] <sorear> for some reason pmurias insists on using require 'viv'; to load the STD module

[09:59] <sorear> I keep trying to tell him that "use STD" will work just as well

[09:59] <masak> aye

[10:00] <sorear> masak: In case you missed it, STD's been on CPAN for a while; I just pushed a new version

[10:04] <masak> I was dimly aware it's been there for a while. but I don't think I've ++'d you for it :)

[10:05] <sorear> You shouldn't have.  It's all pmurias++ fault

[10:05] <masak> pmurias++

[10:05] <sorear> also GSoC++

[10:08] <sorear> hmm, not having any way to access terminal input puts a real crimp on what little demos I can do

[10:08] *** dalek left
[10:08] *** dalek joined
[10:09] *** ChanServ sets mode: +v dalek

[10:09] <masak> sorear: the install of STD seemed to have gone fine, but when I use it I get this: http://gist.github.com/537522

[10:10] <sorear> masak: the installable version of STD only comes with one setting, NULL

[10:10] <sorear> (this is one of the issues I need to understand to make a usable installed viv)

[10:11] *** Clem_Chong_ joined
[10:11] <masak> I don't see what 'only comes with one setting, NULL' would mean in this case, or how it relates to my error.

[10:11] *** Clem_Chong_ left
[10:13] <masak> ooh, today is Rakudo release day!

[10:13] *** Clem_Chong left
[10:13] <frettled> \o/

[10:13] <masak> ...and I still haven't been able to track down why Parrot doesn't like my enums patch... :(

[10:14] *** dalek left
[10:14] *** dalek joined
[10:14] *** ChanServ sets mode: +v dalek

[10:15] <sorear> masak: :$setting = 'CORE'

[10:16] <sorear> masak: you need to pass , setting => "NULL" to use an installed STD if it's not embedded in a context that can provide a CORE

[10:17] <masak> pass setting => "NULL" to STD->parsefile?

[10:17] <sorear> yes

[10:18] <masak> and if I want the setting?

[10:18] <sorear> 1. locate a copy of CORE.setting into .

[10:19] <sorear> 2. modify it as you see fit (optional)

[10:19] <sorear> 3. STD->parsefile("CORE.setting", setting => "NULL")

[10:19] <sorear> 4. use STD->parse as you see fit (but you can't chdir)

[10:21] <masak> should be enough for me.

[10:21] <masak> thanks.

[10:23] <sorear> Hah.  The .net framework's ReadLine method documents a specific error to be thrown if there are more than Int32.MaxValue characters in the next line

[10:24] <jnthn> masak: http://github.com/rakudo/rakudo/commit/83b2cdfa64becdef052417962cc114e38f5920d8 - in the changes to Str.pm, aren't you missing a goto after line 39?

[10:25] <masak> jnthn: looking

[10:26] <masak> jnthn: yes.

[10:26] <masak> jnthn: fixing.

[10:26] <jnthn> no prizes for guessing what I'm working on. :P

[10:27] <masak> :)

[10:27] <masak> jnthn: (I'm assuming since things are in a git repo, it's OK to modify my contributed code even before my GSoC work has been approved. it won't be part of what I send in, of course.)

[10:28] <jnthn> masak: Yes

[10:28] <jnthn> masak: I'll be filing this in the next 10 mins or so anyway.

[10:28] <masak> Imma let this build finish, then I will push a fix.

[10:29] <masak> pushed.

[10:30] <masak> lunch &

[10:31] <dalek> rakudo: 5b08f4e | masak++ | src/core/Str.pm:

[10:31] <dalek> rakudo: [core/Str] added missing goto in PIR

[10:31] <dalek> rakudo: 

[10:31] <dalek> rakudo: Discovered by jnthn++.

[10:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5b08f4e8e1402479bc111e13defaeab381b45987

[10:39] *** ruoso left
[10:39] <sorear> std: gather take my $l while ($l = self.get).defined;

[10:39] <p6eval> std 32058: OUTPUT«ok 00:01 119m␤»

[10:40] *** achromic left
[10:48] <sorear> niecza: 

[10:48] <p6eval> niecza 14af68a:  ( no output )

[10:51] <dalek> niecza: 4770bf5 | sorear++ | lib/ (2 files):

[10:51] <dalek> niecza: Add $*IN, .lines, .slurp, .get, .getc

[10:51] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4770bf5d1ad6d00437f11ba2e817503ccd7179ca

[10:51] * sorear out

[11:00] *** pmurias joined
[11:01] *** meppl joined
[11:01] *** M_o_C left
[11:09] *** Fuad joined
[11:12] *** lestrrat is now known as lest_away

[11:14] <masak> rakudo: my $foo = "HAI"; say q"OH $foo"

[11:14] <p6eval> rakudo 5b08f4: OUTPUT«OH $foo␤»

[11:14] <masak> :)

[11:14] <Fuad> masak :)

[11:14] <Fuad> hello

[11:14] <Fuad> how are you?

[11:14] <masak> Fuad: hi!

[11:14] <masak> Fuad: now that you're here, I'm excellent!

[11:14] <masak> Fuad: how are you? :)

[11:14] * masak and Fuad privmsg

[11:14] <Fuad> im great my friend thanks

[11:15] <Fuad> i forgot my nickname pass

[11:15] <Fuad> go to help they help

[11:15] <Fuad> sent my pass to email

[11:15] <masak> \o/

[11:15] <Fuad> :)

[11:15] <Fuad> [15:59] -NickServ- Last seen  : Jun 20 17:25:55 2009 (1 year, 8 weeks, 3 days, 17:34:18 ago)

[11:15] <Fuad> before army

[11:15] <Fuad> :)

[11:17] <masak> I'm so glad you survived.

[11:17] <Fuad> thank you my bro

[11:25] *** pmurias left
[11:32] *** [Coke] joined
[11:36] *** rgrau joined
[11:46] <takadonet> morning all

[11:48] <masak> takadonet: \o

[11:59] *** envi^home joined
[12:01] *** Fuad left
[12:05] *** rgrau_ joined
[12:06] *** rgrau left
[12:21] *** azert0x joined
[12:23] *** TiMBuS left
[12:23] *** TiMBuS joined
[12:24] *** azert0x_ joined
[12:25] *** azert0x left
[12:29] *** drbean joined
[12:30] *** rgrau_ left
[12:30] *** rgrau_ joined
[12:35] *** patrickas joined
[12:36] *** NiiHiiL joined
[12:36] *** ruoso joined
[12:40] *** jaldhar left
[12:41] *** Guest41392 left
[12:41] *** Trashlord joined
[12:41] *** jfried left
[12:43] *** jaldhar joined
[12:46] *** jferrero joined
[12:47] <jferrero> rakudo: say <A C> X <G T>

[12:47] <p6eval> rakudo 5b08f4: OUTPUT«AGATCGCT␤»

[12:48] <jferrero> rakudo: say <A C T G> X <A C T G>

[12:48] <p6eval> rakudo 5b08f4: OUTPUT«AAACATAGCACCCTCGTATCTTTGGAGCGTGG␤»

[12:49] <masak> rakudo: say <A C T G>.pick(30, :replace)

[12:49] <p6eval> rakudo 5b08f4: OUTPUT«CTGGATTCCGCTGCCGGTACACGAGTGGCT␤»

[12:51] *** xinming left
[12:52] *** xinming joined
[12:56] <jferrero> masak: What is the join() equivalent at Perl v6?

[12:57] <masak> rakudo: say join '|', <a b c>

[12:57] <p6eval> rakudo 5b08f4: OUTPUT«a|b|c␤»

[12:57] <masak> it's the same, if you want.

[12:57] <jferrero> Ok

[12:57] <masak> there's also a method form.

[12:57] <masak> rakudo: say <a b c>.join('|')

[12:57] <p6eval> rakudo 5b08f4: OUTPUT«a|b|c␤»

[12:57] <jferrero> rakudo: say join '-', <A C T G> X <A C T G>

[12:57] <p6eval> rakudo 5b08f4: OUTPUT«␤»

[12:57] <masak> jferrero: precedence.

[12:58] <masak> rakudo: say join '-', (<A C T G> X <A C T G>)

[12:58] <p6eval> rakudo 5b08f4: OUTPUT«A-A-A-C-A-T-A-G-C-A-C-C-C-T-C-G-T-A-T-C-T-T-T-G-G-A-G-C-G-T-G-G␤»

[12:58] <jferrero> 10x, masak 

[12:58] <jferrero> OOps

[12:58] <jferrero> no

[12:58] <masak> you're "w11come"

[12:58] <jferrero> I need pairs of permutations

[12:58] *** tadzik joined
[12:59] <bbkr> rakudo: say join '-', (<A C T G> X <A C T G> X <A C T G>) # checking if it's implemented

[12:59] <p6eval> rakudo 5b08f4: OUTPUT«No applicable candidates found to dispatch to for 'infix:<X>'. Available candidates are:␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/HTeh2GJGVk␤»

[12:59] <moritz_> rakudo: say (<A C T G> X=> <A C T G>).perl

[12:59] <p6eval> rakudo 5b08f4: OUTPUT«("A" => "A", "A" => "C", "A" => "T", "A" => "G", "C" => "A", "C" => "C", "C" => "T", "C" => "G", "T" => "A", "T" => "C", "T" => "T", "T" => "G", "G" => "A", "G" => "C", "G" => "T", "G" => "G")␤»

[12:59] <moritz_> better?

[13:00] <jferrero> Sorry... I need: AA-AC-AT-AG ...

[13:00] <masak> a mere &map away :)

[13:00] <moritz_> rakudo: say (<A C T G> X~ <A C T G>).join('-')

[13:00] <p6eval> rakudo 5b08f4: OUTPUT«AA-AC-AT-AG-CA-CC-CT-CG-TA-TC-TT-TG-GA-GC-GT-GG␤»

[13:00] <jferrero> Ole!

[13:00] <moritz_> masak: don't forget we have these meta operators... :-)

[13:01] <masak> moritz_++

[13:02] <jferrero> Thanks, moritz_ && masak 

[13:03] * masak .oO( I'm lucky moritz_ evaluates to a true value... )

[13:03] <tadzik> :)

[13:03] <jferrero> hahaha

[13:03] <jferrero> :)

[13:07] *** blogometer joined
[13:09] *** orafu left
[13:09] *** orafu joined
[13:12] *** Holy_Cow joined
[13:14] *** lest_away is now known as lestrrat

[13:14] <bbkr> rakudo: sub infix:<M>(Int, Int) {666}; (<1 2> XM <1 0>).perl.say # known bug?

[13:14] <p6eval> rakudo 5b08f4: OUTPUT«===SORRY!===␤Could not find sub &infix:<M>␤»

[13:14] <cognominal> do meta operators work on methylated chains?  :)

[13:15] *** kaare_ left
[13:17] *** pnate left
[13:24] <moritz_> bbkr: yes; currently only works with 'our' operator subs

[13:24] <moritz_> needs lift

[13:25] <bbkr> moritz_++

[13:25] *** jferrero left
[13:28] *** NiiHiiL left
[13:30] *** snearch left
[13:35] *** javs joined
[13:41] *** burmas joined
[13:44] *** pmurias joined
[13:44] <pmurias> ruoso: hi

[13:44] *** Guest23195 joined
[13:44] *** _madmax_ left
[13:45] *** takadonet left
[13:48] *** Fuad joined
[13:48] *** takadonet joined
[13:48] <pmurias> ruoso: did you evaluate my GSoC project?

[13:51] <ruoso> hi pmurias 

[13:51] <ruoso> yes... I did...

[13:52] <ruoso> yes... I gave you a pass ;)

[13:52] <masak> \o/

[13:52] *** pmurias left
[13:52] <moritz_> \o/

[13:52] <ruoso> in fact, when I looked at the original proposal I was impressed as how close the actual work was to the initial plan

[13:52] <Fuad> )

[13:53] <pmichaud> good morning, #perl6

[13:53] <pmichaud> rakudo:  say Nil.defined   # checking

[13:53] *** uniejo left
[13:53] <p6eval> rakudo 5b08f4: OUTPUT«1␤»

[13:53] <pmichaud> :-(

[13:54] <masak> "Day 2673: woke up. Nil is still defined. dang"

[13:54] <pmichaud> I thought I undefined it last night.

[13:54] *** pmurias joined
[13:55] <pmichaud> pmichaud@plum:~/rakudo$ ./perl6

[13:55] <pmichaud> > say Nil.defined

[13:55] <pmichaud> 0

[13:55] <masak> "local variations may occur"

[13:55] <moritz_> pmichaud: ship it

[13:55] <pmichaud> # Your branch is ahead of 'origin/master' by 1 commit.

[13:55] <moritz_> pmichaud: erm, I mean, push it, let mathw++ ship it :-)

[13:55] <pmichaud> oh.

[13:55] <masak> :)

[13:55] <pmichaud> looks like I didn't push.

[13:55] <pmichaud> (was tired last night)

[13:55] <masak> that's becoming a bit of a theme, isn't it?

[13:56] <pmichaud> pushed.

[13:56] <masak> pmichaud++

[13:56] <pmichaud> (theme)  being tired at night?  yes.  :-P

[13:56] <moritz_> pmichaud: don't forget to push chagned tests, if any?

[13:56] <pmichaud> I know that I did commit those.

[13:56] <masak> those just need the committing :)

[13:57] <moritz_> masak: ... unless you use git-svn

[13:57] <masak> right-o.

[13:57] <masak> which I should.

[13:57] <pmichaud> r32057 and r32058

[13:57] <dalek> rakudo: 3f0bfbb | pmichaud++ | src/ (4 files):

[13:57] <dalek> rakudo: Switch Nil to be an undefined Parcel constant.

[13:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3f0bfbb48591e763f331a5f7fccc3f91ce12759e

[13:57] <dalek> rakudo: 1f5a79f | pmichaud++ | / (4 files):

[13:57] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[13:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1f5a79f8d6651a95ac1286ccf4c06ee31b4ef0d7

[13:58] <masak> nono, you should 'git pull --rebase' :S

[13:59] <masak> then you won't get those ugly unnecessary merge commits.

[13:59] <masak> it's as if you were developing in a branch all the time.

[13:59] * moritz_ has a script called 'update-stuff' which chdirs do a couple of project folders, and calls 'git pull --rebase' or 'svn up' in them

[14:01] <masak> I'm with Linus on when to merge and when to rebase: http://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html

[14:01] <masak> (short story, almost always rebase)

[14:01] <moritz_> unless there's a reason for you to tell the world you did a merge

[14:01] <moritz_> like, a branch that broke things inbetween

[14:02] <masak> right.

[14:02] * pmichaud reads Linus' note

[14:02] <masak> merge is a safe, but often unnecessary default.

[14:02] <Fuad> moritz_: no way

[14:04] <moritz_> Fuad: context?

[14:04] * masak was wondering about that, too

[14:05] <pmichaud> Hmmm... I don't get from Linus' message to "use git pull --rebase".

[14:05] <x3nU> how do i build rakudo to certain directory?

[14:05] <x3nU> (rakudo star ofc)

[14:05] <moritz_> pmichaud: that's the "clean" part

[14:05] *** wtw left
[14:05] <pmichaud> x3nU:  --prefix=<installdir>   on Configure.pl

[14:06] <x3nU> thanks

[14:06] <moritz_> pmichaud: there's no need to expose your merging commits when git pull'ed instead of git pull --rebase'd

[14:06] *** Fuad left
[14:06] <masak> pmichaud: 'git pull --rebase' is just a shortcut command to follow the general advice in that post.

[14:06] <masak> pmichaud: there are other ways not to cause merges.

[14:07] *** drbean left
[14:07] * PerlJam sets git config branch.autosetuprebase always

[14:08] <PerlJam> of course, I also have a "pullr" alias for "pull --rebase"

[14:08] <masak> ooh

[14:10] *** azert0x_ left
[14:13] <masak> pmichaud: I submitted the enums segfault as a parrotbug. http://trac.parrot.org/parrot/ticket/1746 -- as opposed to one month ago, there are now repeatable conditions for triggering the segfault.

[14:14] <pmichaud> masak: yes, I just saw the ticket

[14:14] <pmichaud> good choice

[14:15] <masak> hope it'll lead to some unstuckness.

[14:15] <moritz_> you usually get that when you troll #parrot enough :-)

[14:17] <masak> is that a specific, second-person singular 'you', or the general pronoun which is synonymous with 'one'? :)

[14:17] <moritz_> the latter

[14:17] <[particle]> one usually gets that when you troll #parrot

[14:17] <masak> oh, ok :)

[14:17] <masak> [particle]: lol

[14:18] * moritz_ apologizes for the amibguties in the English language

[14:18] <[particle]> what would puns be without ambiguities?

[14:19] <masak> you don't need to apologise for ambiguities you didn't create. :)

[14:19] <[particle]> s/you/one/

[14:19] <moritz_> [particle]: puns don't require ambiguities at all

[14:19] <moritz_> similarity is enough

[14:19] <PerlJam> I thought ambiguity was a feature

[14:19] * pmichaud notices that the core of ambiguities is "gui".   Hmmmmmmm.

[14:20] <[particle]> some do, but they're better spoken than read

[14:20] <masak> "You don't have to be ambiguous to be a pun here... but it helps!"

[14:20] <moritz_> or phrased another way, ambiguity is not a pundamental problem :-)

[14:21] <masak> pmichaud: in Mandarin, 鬼 GUI3 means "devil". ":)

[14:21] <masak> moritz_++

[14:21] <PerlJam> masak: so ... ambiguity is a two handed devil?

[14:21] <pmichaud> rakudo:  say Nil.defined  # yet?

[14:21] <p6eval> rakudo 5b08f4: OUTPUT«1␤»

[14:21] <pmichaud> :-(

[14:22] <tadzik> 0 here :)

[14:22] <masak> "Day 2673, later: Nil is still defined. dang"

[14:22] <moritz_> 15 */2 * * *              perl /home/p6eval/rebuild-rakudo.pl  >> /home/p6eval/rakudo-build.log 2>&1

[14:22] <moritz_> so the rebuild should be running

[14:22] <pmichaud> The future is here, it's just unevenly distributed.

[14:22] <moritz_> (server clock is in UTC)

[14:23] <moritz_> rakudo: say Nil.defined

[14:23] <p6eval> rakudo 5b08f4: OUTPUT«1␤»

[14:23] <tadzik> (:

[14:23] <moritz_> uhm. Something went wrong, it seems

[14:23] <masak> something undefined went wrong...

[14:24] <moritz_> Confused.

[14:24] <moritz_> why does it rebuild parrot? it should have a sufficient version available already

[14:24] <mathw> Could somebody please look at ChangeLog and 2010.08 announcement and fix things they discover are wrong about new features/changes/anything else?

[14:24] <moritz_> seems the rebuild script is a bit broken

[14:24] <mathw> I've probably got something wrong in there

[14:25] <masak> of course, in Mandarin 'gui' could also mean 'noble', 'turtle', 'silicon', or 'salmon'.

[14:25] <masak> mathw: looking

[14:26] <jnthn> masak: Wow. Another upside to not liking fish is that I won't accidentally order devil in a Chinese restaurant. :-)

[14:26] <PerlJam> nor turtle

[14:26] <moritz_> + smartmatch against True or False is now an error

[14:27] <moritz_> that's more of a bug than a feature, fwiw

[14:27] <moritz_> it should just warn

[14:27] <jnthn> mathw: Taking a look

[14:27] <mathw> moritz_: the commit said it should be a .worry later

[14:27] <moritz_> but the ChangeLog looks good

[14:27] <mathw> I think it was .worry

[14:27] <mathw> but it's definitely an error right now

[14:27] <mathw> unless the comments are wrong :)

[14:28] <mathw> in which case it's ALL SOMEONE ELSE'S FAULT

[14:28] <moritz_> rakudo: say 1 ~~ True

[14:28] <p6eval> rakudo 5b08f4: OUTPUT«===SORRY!===␤Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead at line 22, near " True"␤»

[14:28] <moritz_> hm

[14:29] <moritz_> Carl Masäk, Jonathan Worthington, Bruce Gray, Patrick Abi Salloum,

[14:29] <moritz_> isn't that wrong? :-)

[14:29] <pmichaud> the point is that someone shouldn't be smart matching against True/False

[14:29] <moritz_> Mäsak instead?

[14:29] <moritz_> pmichaud: yes. And still it's wrong to die.

[14:29] <pmichaud> right.  but die is better than no warning at all.

[14:30] <jnthn> moritz_: Something doens't look quite right there. :-)

[14:30] *** burmas left
[14:31] <mathw> forgive me, I was asleep

[14:31] <jnthn> and it was an excellent

[14:31] <jnthn> location for hackathon and planning the next states of Rakudo

[14:31] <jnthn> development.

[14:31] <jnthn> "a hackathon"

[14:31] <alester> I should probably update the Perl code in http://xoa.petdance.com/Songs_in_code into Perl 6.

[14:31] <jnthn> "next stages"

[14:31] <jnthn> ?

[14:32] <jnthn> Or phases ;-)

[14:32] <moritz_> phasers!

[14:33] <dalek> rakudo: ee31f3d | moritz++ | docs/announce/2010.08:

[14:33] <dalek> rakudo: [announce] those diacritics are easy to mis-remember :-)

[14:33] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ee31f3d9a9e9408c36e05744c1166707ea74381c

[14:34] <jnthn> It's direly critical to get 'em right.

[14:34] <mathw> groan

[14:34] <masak> I almost never get them wrong. don't see what the fuss is all about. :)

[14:34] *** pyrimidine joined
[14:34] <mathw> 'almost never'

[14:34] <mathw> for your own name?

[14:34] <masak> ok, so never.

[14:34] *** pmurias left
[14:35] <masak> I meant to cushion the blow a little. :)

[14:36] <mathw> meh

[14:37] <mathw> I can't even spell my own name some days

[14:37] <mathw> and it doesn't have any diacritics or anything in it

[14:37] <masak> mathw: I read the release announcement. it looks good to me.

[14:37] <mathw> \o/

[14:37] <mathw> especially now moritz++ fixed it

[14:37] <mathw> I'll bundle up a tarball this evening

[14:39] *** azert0x joined
[14:39] <dalek> rakudo: 4f1dee5 | pmichaud++ | docs/announce/2010.08:

[14:39] <dalek> rakudo: Add note about Nil now being undefined.

[14:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4f1dee534da9942293afb94059895d7a74a94906

[14:39] <dalek> rakudo: 90637b6 | jnthn++ | docs/announce/2010.08:

[14:39] <dalek> rakudo: Tiny tiny tweakies.

[14:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/90637b66e61b44da794ecbee4b3918c7af1060f9

[14:43] *** rgrau__ joined
[14:44] *** rgrau_ left
[14:44] *** rgrau__ is now known as rgrau

[14:46] <pmichaud> rakudo:  say Nil.defined;

[14:46] <p6eval> rakudo 90637b: OUTPUT«(timeout)»

[14:47] <moritz_> rakudo:  say Nil.defined;

[14:47] <masak> the excitement is unbearable!

[14:47] <p6eval> rakudo 90637b: OUTPUT«(timeout)»

[14:47] <moritz_> 14:26:21 up 309 days, 2 min,  0 users,  load average: 2.27, 1.45, 1.07

[14:47] <pmichaud> Looks like it's impossible to undefine Nil.  Change the spec.  :-P

[14:47] <masak> nooooo

[14:47] <moritz_> that's not too bad with 4 CPUs

[14:48] *** foodoo left
[14:51] <moritz_> rakudo: say Nil.defined

[14:51] <p6eval> rakudo 90637b: OUTPUT«0␤»

[14:51] <moritz_> \o/

[14:51] <pmichaud> \o/

[14:51] <masak> \o/

[14:51] <moritz_> rakudo: say ().defined

[14:51] <p6eval> rakudo 90637b: OUTPUT«1␤»

[14:51] <pmichaud> \o/

[14:51] <masak> \o/

[14:51] <moritz_> rakudo: {}.().defined

[14:51] <colomon> \o/

[14:51] <p6eval> rakudo 90637b: OUTPUT«invoke() not implemented in class ''␤  in main program body at line 22:/tmp/G5dkZGZSTS␤»

[14:51] <masak> moritz_: that's a hash.

[14:51] <moritz_> rakudo: {;}.().defined

[14:52] <p6eval> rakudo 90637b:  ( no output )

[14:52] <moritz_> masak: I figured

[14:52] <pmichaud> rakudo:  sub xyz { };   xyz().defined.say

[14:52] <moritz_> rakudo: print {;}.().defined

[14:52] <p6eval> rakudo 90637b: OUTPUT«0␤»

[14:52] <p6eval> rakudo 90637b: OUTPUT«0»

[14:52] <pmichaud> rakudo:  sub xyz { return; };  xyz().defined.say

[14:52] <p6eval> rakudo 90637b: OUTPUT«0␤»

[14:52] <masak> rakudo: say (class {}).?foo.defined

[14:52] <pmichaud> rakudo:  sub xyz { return(); };  xyz().defined.say

[14:52] <p6eval> rakudo 90637b: OUTPUT«0␤»

[14:52] <masak> \o/

[14:52] <pmichaud> rakudo:  sub xyz { return (); };  xyz().defined.say

[14:52] <p6eval> rakudo 90637b: OUTPUT«1␤»

[14:53] <pmichaud> looks good to me.  :-)

[14:53] <moritz_> and it seems to work. Frabolous

[14:53] <masak> Twicked!

[14:53] <jnthn> rakudo: my $x; say ($x.?lol-i-am-nonexistant).defined

[14:54] <p6eval> rakudo 90637b: OUTPUT«0␤»

[14:54] <jnthn> \o/

[14:54] <jnthn> pmichaud++

[14:54] <masak> TimToady_++

[14:54] <jnthn> Yes, TimToady_++ too

[14:54] <jnthn> I'm happy we've ended up^W^Wnow swung this way. :-) :-)

[14:55] <pmichaud> rakudo:  sub xyz { };  say xyz() ~~ Nil;

[14:55] <p6eval> rakudo 90637b: OUTPUT«1␤»

[14:55] <masak> "Perl 6 spec: we're happy we've now swung this way"

[14:55] <pmichaud> hugme tweet rakudoperl  Nil is now undefined. #perl6

[14:55] * hugme hugs pmichaud; tweet delivered

[14:55] <masak> rakudo: say Nil ~~ Nil

[14:56] <p6eval> rakudo 90637b: OUTPUT«1␤»

[14:56] <masak> rakudo: say Nill ** 2 ~~ Nil

[14:56] <p6eval> rakudo 90637b: OUTPUT«===SORRY!===␤HyperWhatever (**) not yet implemented at line 22, near " 2 ~~ Nil"␤»

[14:56] <masak> oops.

[14:56] <moritz_> rakudo: say () ~~ Nil

[14:56] <masak> rakudo: say Nil ** 2 ~~ Nil

[14:56] <p6eval> rakudo 90637b: OUTPUT«0␤»

[14:56] <moritz_> rakudo: Nil ~~ ()

[14:56] <p6eval> rakudo 90637b:  ( no output )

[14:56] <moritz_> rakudo: say Nil ~~ ()

[14:56] <p6eval> rakudo 90637b: OUTPUT«1␤»

[14:56] <masak> \o/

[14:57] <Juerd> HyperWhatever is an interesting name

[14:57] <masak> "Nil: an empty Parcel with pieces of flair"

[14:57] <pmichaud> actually, Rakudo implements it as a type.  :-)

[14:57] <masak> yeah, but the truth is so boring. :)

[14:57] <pmichaud> that may end up being wrong, but Nil seems to act more like a type than not-a-type

[14:58] <pmichaud> more precisely, Nil seems to act more like a type object than anything else :)

[14:58] * Juerd finds "type object" hard to grok

[14:59] <masak> Juerd: we just need to work more on the 'grok' tool, then :)

[14:59] <pmichaud> Juerd: it's the object that represents the type

[14:59] *** redicaps joined
[14:59] *** redicaps left
[14:59] <pmichaud> or I suppose it's "an object that represents a type"

[14:59] <Juerd> I know what it is but it's too abstract

[14:59] <pmichaud> I think "abstract" is what it's designed for :-P

[15:00] <PerlJam> Juerd: http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html  

[15:00] <PerlJam> :-)

[15:00] <Juerd> PerlJam: Thanks, I'll read that

[15:00] <jnthn> Juerd: The implementation of it turns out to be quite straightforward if you get the right factoring, fwiw. :-)

[15:01] *** pyrimidine left
[15:01] *** pyrimidine joined
[15:03] *** justatheory joined
[15:03] *** justatheory left
[15:04] *** justatheory joined
[15:05] <moritz_> Is the implementation concrete? :-)

[15:07] <szbalint> It seems solid. :)

[15:08] <jnthn> moritz_: Yes, but it's still setting. :-)

[15:10] <pmichaud> ...what to work on today...?

[15:11] <moritz_> pmichaud: nulling temporaries in PCT generated code

[15:11] <moritz_> pmichaud: or splitting the setting

[15:11] <colomon> pmichaud: two quick questions: what's the state of your series refactor?

[15:12] <colomon> pmichaud: and what would it take to redo the gather iterator ala the range iterator?

[15:16] *** justatheory left
[15:20] <masak> rakudo: class A {}; grammar G is A { regex TOP { foo } }; G.parse("foo")

[15:20] <p6eval> rakudo 90637b: OUTPUT«Method 'parse' not found for invocant of class ''␤  in main program body at line 22:/tmp/uV6YGgoaqT␤»

[15:20] <masak> I know, that's a bit of "doctor, it hurts when I do this"...

[15:22] <moritz_> masak: I'd say it's a bug. 'grammar' should add Grammar to the list of its parents, unless one of the explicit parents is Grammar already

[15:22] <moritz_> at least I think that's what it should do.

[15:22] <masak> oh, good.

[15:22] * masak submits rakudobug

[15:23] <moritz_> and I know where to fix it

[15:24] <moritz_> src/metamodel/GrammarHow.pir around line 41

[15:24] <jnthn> :-)

[15:24] <jnthn> Yes, that's HOW.

[15:24] <moritz_> MEH

[15:24] <masak> YOW

[15:25] <moritz_> if it were written in Perl 6, I'd say  if none(@parents>>.isa(Grammar)) { $P0.add_parent(Grammar, $P0) }

[15:26] <jnthn> It'll be written in NQP at some point.

[15:26] <masak> that's pretty.

[15:26] <masak> or 'unless any(...)'

[15:26] <moritz_> jnthn: how hard would it be to rewrite it now?

[15:27] <moritz_> (no, I don't want to do it before the release... )

[15:27] *** azert0x left
[15:28] <jnthn> moritz_: Probably quite easy.

[15:29] <jnthn> Though a bit messy, since for now you'd still need pir::foo I guess

[15:32] <pmichaud> 15:11 <colomon> pmichaud: two quick questions: what's the state of your series refactor?

[15:33] <pmichaud> I abandoned it for now.  I think I'm going to wait for the spec to settle down there a bit.

[15:33] *** azert0x joined
[15:33] <pmichaud> patrickas++ has some improvements for series, and I'm thinking those can be applied at some point.

[15:33] <pmichaud> 15:12 <colomon> pmichaud: and what would it take to redo the gather iterator ala the range iterator?

[15:33] <TimToady_> yes, the default behavior for stringy ... is likely to take into account the endpoint

[15:34] *** risou joined
[15:34] <pmichaud> afaict, the gather iterator is about what it should be...  I'm not sure how it would be "re-done" like the range iterator.

[15:34] <colomon> patrickas also has been working on a series refactor, too, with a bit of help from me.  But it doesn't seem like a very big win so far.

[15:34] <pmichaud> colomon: I think the spec for series itself needs a bit of a cleanup.  it feels... contradictory at times.

[15:35] <pmichaud> I could probably come up with a revised draft

[15:35] <pmichaud> not changing any of the core semantics, just how it's described

[15:35] * cognominal discovers the inspect opcode

[15:35] <pmichaud> 15:11 <moritz_> pmichaud: or splitting the setting

[15:35] <colomon> pmichaud: for gather, I was thinking of something like returning multiple results at a time.  I'm suspicious it's a big drag on Rakudo's timing at the moment.  but don't have anything like proof.

[15:35] *** meppl left
[15:35] *** rgrau_ joined
[15:35] <pmichaud> colomon: I suspect gather needs to be as lazy as possible.

[15:36] <colomon> pmichaud: as for series, yeah, the spec is somewhat painful at the moment.

[15:36] * cognominal almost said "/me inspects the discover opcode"

[15:36] <moritz_> rakudo: say Grammar.isa(Grammar)

[15:36] <p6eval> rakudo 90637b: OUTPUT«1␤»

[15:36] <pmichaud> 15:11 <moritz_> pmichaud: or splitting the setting

[15:36] <pmichaud> moritz_: I've worked on that a bit, but it's definitely non-trivial.

[15:37] *** rgrau left
[15:37] <pmichaud> also, at the moment core.pm is my primary compilation benchmark, so I'm thinking I'll want to keep it as-is for another week or so while I try to improve parsing/compiling speed overall.

[15:37] <colomon> pmichaud: perhaps a better approach might be to look at removing use of gather from some of the core functionality, then?  I might play around with a few simple things just to see what sort of difference it makes.

[15:38] <pmichaud> colomon: that can work (more)

[15:38] <colomon> pmichaud: I'm particularly thinking of IO.lines at the moment.

[15:38] <pmichaud> colomon: well, that's another one that wants strict laziness, though.

[15:38] *** pmurias joined
[15:38] <pmurias> ruoso: ping

[15:39] <jnthn> cognominal: Don't get too into it. :-)

[15:39] *** perlygatekeeper joined
[15:39] <colomon> pmichaud: huh?  I'd think exactly the opposite, isn't the internal file buffer likely to be loading more than one line at a time anyway?

[15:39] <jnthn> cognominal: Anything you write that depends on it now is likely to break when the new meta-model stuff lands.

[15:39] <TimToady_> lines doesn't want strict laziness; that would be death for performance

[15:39] <pmichaud> colomon: well, if you're going to have the IO object do buffering, then yes.

[15:40] <jnthn> cognominal: And the info is already available through .^foo methods anyway.

[15:40] <pmichaud> TimToady_: what about

[15:40] <pmurias> lue, sjohnson: perlito has a js backend, with a (fair) bit of hacking it could be made usefull enough to avoid having to write js

[15:40] <moritz_> colomon: depends on wether we allow .get after an aborted .lines() iteration

[15:40] <pmichaud>     for $IO.lines { ... }

[15:40] *** takadonet left
[15:40] <pmichaud> where there's a 'last' in the loop

[15:40] <TimToady_> the abstraction isn't supposed to leak batchiness

[15:40] <TimToady_> you can reify ahead of time

[15:41] <pmichaud> right, so the IO object can batch up some lines, but its iterator has to deliver/consume them lazily

[15:41] <pmichaud> in that case, there can indeed be some batching going on

[15:41] *** achromic joined
[15:42] <TimToady_> the IO object *is* the iterator in this case, meseemeth

[15:42] <colomon> the idea that you might do $IO.lines, only get part of the lines, and then expect $IO.get to return the next one seems very wrong to me.

[15:42] <TimToady_> it doesn't have to clone an iterator like an array does

[15:42] <pmichaud> TimToady_: that can work also, yes.

[15:43] <TimToady_> in any case, if you want that, we can pessimize declaratively

[15:43] *** takadonet joined
[15:43] <TimToady_> or at least openly

[15:43] <TimToady_> IO objects should have methods to tweak these things

[15:44] <TimToady_> but the default on input needs to be blazing fast

[15:44] <pmichaud> colomon: it's pretty clear (to me at least)  that  

[15:44] <pmichaud>     for lines() { ... }

[15:44] <pmichaud> needs to be such that lines() doesn't consume all of the input

[15:45] <pmichaud> otherwise we won't be using 'for' to iterate IO

[15:47] <moritz_> wow. I wrote about 15 lines of PIR, and didn't even get a compiler error

[15:47] <moritz_> and it didn't error out either

[15:47] * moritz_ scared of himself

[15:47] <colomon> when you say, "consume" do you mean actually or logically?  I'm certainly not proposing to read the entire file when you call .lines.  But I am proposing that if you call $IO.lines, you should not no longer expect $IO.get to give you something meaningful.  It seems to me you shouldn't expect to mix the two.

[15:47] <pmichaud> colomon: I'm disagreeing with your proposal.  (more)

[15:48] <TimToady_> I think $IO.get can be consistent, but the file pointer won't

[15:48] <pmichaud>     # read file until we see '-----'

[15:48] <pmichaud>     for lines() { last if $_ eq '-----'; }

[15:48] <pmichaud>     # should be able to do $*ARGFILES.get here

[15:48] <TimToady_> a get should work after that

[15:48] *** tadzik left
[15:49] <TimToady_> both constructs are just shifting (and rebatching at need)

[15:49] <pmichaud> agreed.

[15:49] <pmichaud> that's what I mean when I say that "lines()" needs to be "lazy"

[15:49] <TimToady_> so it's shift that needs to be low overhead

[15:49] <TimToady_> in p5, shift just bumps the front pointer of the array and returns the bumpee

[15:49] <pmichaud> lines() can't logically consume all of the input from the IO object when it's invoked

[15:50] <TimToady_> since it could be infinite

[15:50] <pmichaud> shift can be low-overhead when the internal iterators batch things up, yes.

[15:50] <pmichaud> I'm thinking of adding an argument to .reify  to say "please reify at least $n elements"

[15:50] <wolverian> do we have a lines().take-until('------')? :)

[15:50] <pmichaud> (if you can)

[15:50] * TimToady_ tries to think of uses for lines on /dev/random

[15:50] <wolverian> (or * eq '------')

[15:51] <TimToady_> where reify * means "you pick a good batch size"

[15:51] * PerlJam wonders if we somehow get tail for free now

[15:51] <TimToady_> this is something the source is likelier to have a good idea of than the sink

[15:52] *** tylercurtis joined
[15:52] <TimToady_> and in the case of decoding a buffer, the size might actually vary

[15:52] <pmichaud> wolverian: lines().map({ last when '-----' })   # maybe

[15:53] <wolverian> pmichaud: but haskell has takeUntil (and takeWhile), so surely we should too. :)

[15:53] <TimToady_> just so they aren't spelled like that, shudder...

[15:53] <PerlJam> wolverian: perhaps that's part of Haskell::Utils 

[15:53] <wolverian> TimToady_: I used take-until. maybe that's not as bad...

[15:54] <TimToady_> well, take is wrong in Perlland as well

[15:54] <colomon> So is this legal?  for $IO.lines -> $line { $i++; $IO.get if $line ~~ /blueberry/; }

[15:54] <wolverian> PerlJam: I guess it depends on how important lists are.

[15:54] <pmichaud> colomon: iiuc, yes, that's legal.

[15:55] <pmichaud> replace $IO with  $*IN and you'll see why :-)

[15:55] <pmichaud> (although arguably the $*IN case might want to be a 'while' anyway)

[15:55] <colomon> I dunno.  My gut feeling is that is a terrible idea.

[15:55] <Juerd> So "lines" is the plural of "get"?

[15:56] <Juerd> :P

[15:56] <colomon> It's not like using $IO.get explicitly all the time is terribly hard.

[15:56] <Juerd> i.e. Why isn't .get called .line? :)

[15:56] <moritz_> I have a patch for the grammar A is NonGrammar { } thing. It doesn't break anything. Sadly it doesn't seem to fix anything either :(

[15:56] <pmichaud> colomon: rewrite what you just wrote using .get, then.

[15:56] <colomon> while my $line = $IO.get {  $i++; $IO.get if $line ~~ /blueberry/; }

[15:57] <pmichaud> what if $I0.get returns "" ?

[15:57] <pmichaud> then the loop fails early.

[15:57] <moritz_> then you're screwed :-)

[15:57] <wolverian> that looks positively five-ish :)

[15:57] <TimToady_> which is why p5 didn't autochomp

[15:57] *** pyrimidine_ joined
[15:57] <colomon> and of course, there's the other way

[15:58] <moritz_> I thought p5 rewrote that internally to  while (defined my $line = ...) ?

[15:58] <TimToady_> a workaround to a hack :)

[15:58] <moritz_> evil compiler magic and all

[15:58] *** McFist joined
[15:59] <colomon> my $lines = $IO.lines; while defined my $line = $lines.shift { $i++; $lines.shift if $line ~~ /blueberry/; }

[15:59] <pmichaud> we've struggled pretty consistently to say "if you want to iterate something, use 'for'" -- it would be sad if we then had to add "but not file I/O".

[15:59] *** blogometer left
[15:59] <colomon> but you don't use for if you might want to use more than one thing in for list at once.

[16:00] <pmichaud> I don't follow that.

[16:00] <TimToady_> metoo

[16:00] <McFist> just found out that parameters in subs are read-only by default, is that true? seems very unthoughtful to me

[16:00] <colomon> there's no for @a { $i++; magically skip next element of @a if $_ %% 3; }

[16:01] <PerlJam> McFist: why?

[16:01] <colomon> (or at least, there's nothing like that I'm aware of.)

[16:01] <pmichaud> colomon: right, but @a isn't being "consumed", either.

[16:01] <[particle]> for @something -> $x, $y { if $x < 3 say $y else unshift @something, $y }

[16:01] *** pyrimidine left
[16:01] *** pyrimidine_ is now known as pyrimidine

[16:01] <wolverian> next :twice; 

[16:01] <pmichaud> colomon: I mean, @a still has its values when the list is done.

[16:01] <TimToady_> McFist: default copy semantics are higher overhead

[16:01] <[particle]> ^^pseudocode

[16:02] <colomon> gotta go, but still not at all happy with this.

[16:02] <pmichaud> colomon: understood.  I'm just following the language spec (as I understand it).

[16:02] <McFist> TimToady_: true, but that problem could be fixed by "$a is rw" if the programmer cares about that (on modern processors esp.)

[16:02] <pmichaud> colomon: for changes, you'll have to talk to the One Who Torments Implementors.

[16:03] <TimToady_> next if $prev %% 3

[16:03] <McFist> PerlJam: just seems more natural, in my experience

[16:03] <masak> McFist: the problem *is* fixed that way. I'm not sure I see what you're arguing against.

[16:03] <PerlJam> McFist: you always utilize $_[$n] in Perl 5?

[16:03] <pmichaud> masak: I think McFist wants the default to be 'is copy'

[16:03] <McFist> PerlJam: very rarely, why?

[16:04] <McFist> NO!

[16:04] <PerlJam> McFist: because that's what it sounds to me like you're asking for.

[16:04] <McFist> i've read that the default is "is copy", and asked if that's true

[16:04] <pmichaud> the default is "is readonly"

[16:04] <McFist> ups sorry

[16:04] <McFist> yes, I want the default "is copy", sorry again

[16:04] <masak> McFist: making the conservative option (in time as well as side effects) the default seems right to me.

[16:04] <pmichaud> "is copy" means more runtime overhead

[16:05] <McFist> pmichaud: yes, but that can be sured by "is rw"

[16:05] <McFist> cured, even

[16:05] <PerlJam> (side-effect free code)++

[16:05] <pmichaud> McFist: we'd like the defaults to be fast

[16:05] <pmichaud> not only that, but "readonly" is a safer default

[16:05] <patrickas> pmichaud: speaking of "is copy" i got rid of the "is copy" in the series refactor :-)

[16:06] <masak> we'd also like to make a sane cultural choice the default.

[16:06] <pmichaud> if you're going to write to a parameter, you should declare what sort of 'write' you want to be doing.

[16:06] <TimToady_> when someone says "$param = 42", we force people to think about whether they mean "rw" or "copy"

[16:06] <TimToady_> otherwise we'll have people assuming the wrong one all the time

[16:06] <McFist> i can't argue about the speed, but the sane cultural choice seems to me "is rw"

[16:07] <pmichaud> ouch

[16:07] <TimToady_> eh? Fortran semantics?  no way

[16:07] <pmichaud> that means you can inadvertently be modifying the caller's arguments

[16:07] <masak> no thanks.

[16:07] <pmichaud> that's not a good default.

[16:07] <McFist> well, I'm being misunderstood, not caller aguments in @_ style

[16:07] <McFist> just not readonly

[16:07] <pmichaud> that's what "is rw" means.

[16:07] <McFist> not necessarily

[16:07] <masak> but this is all a moot point, because programmers who want that default are quite welcome to set it with a pragma.

[16:08] <pmichaud> ("is rw" == caller arguments can be modified)

[16:08] <PerlJam> McFist: so you do want "is copy"?

[16:08] <McFist> PerlJam: I guess so

[16:08] <PerlJam> McFist: same as sub foo { my ($alpha,$beta) = @_; ... }  in perl 5/

[16:08] <PerlJam> ?

[16:08] <McFist> unless there's no saner behavior , something between copying the scalar always and, well, not copying it

[16:08] <[particle]> what about "is dangerous"?

[16:09] <McFist> PerlJam: yes, like that

[16:09] <McFist> and without modifying the caller's args

[16:09] <McFist> without $_[$a]++ that can backfire

[16:10] <TimToady_> we already gave two reasons why 'is copy' isn't the best default

[16:10] <McFist> I mean, I buy the speed argument and buy $_[$n] argument, but default readonly seems an overkill

[16:10] <PerlJam> McFist: uh oh ... you're pushing the wrong buttons now ... How is "is ro" overkill?  Explain that.

[16:10] <TimToady_> we want to know what the programmer means by "$param = 42", not just guess

[16:10] <moritz_> action at a distance is evil.

[16:11] <moritz_> it's a good idea to make the programmer declare it if he wants it

[16:12] <McFist> I mean, semantic overkill - I just want sub f($a){f($a--)} to figure automatically that $a stays on the stack

[16:12] <pmichaud> o_O

[16:12] <TimToady_> what if the intent was to change the caller's parameter?

[16:12] <TimToady_> s/parameter/argument/

[16:12] <TiMBuS> is ref

[16:12] <moritz_> McFist: maybe you want to program in Forth instead?

[16:12] <pmichaud> why would you do $a-- there?

[16:12] <moritz_> if you care about the stack

[16:12] <McFist> TimToady_: which not happens often, then I guess a special "is" flag suffice? like, "is i_want_to_modify_caller" ? :)

[16:12] <masak> the code analyzer that I haven't written yet also wants the default to be 'is readonly'.

[16:13] *** smash_ joined
[16:13] <smash_> hello everyone

[16:13] <[particle]> that's not a very strong argument, masak

[16:13] <PerlJam> McFist: I  think you're in the camp of "wants readonly but doesn't know it yet"  :)

[16:13] <McFist> pmichaud: just an illustration, c-style if you want

[16:13] <pmichaud> "is i_want_to_modify_caller"   already has a flag, it's  "is rw"

[16:14] <masak> [particle]: no, because it caters to the computer rather than to the user. but it's worth remembering.

[16:14] <masak> [particle]: were the default 'is rw', there'd be lots of actions-at-distances that I might not be able to rule out.

[16:14] <huf> but... but... default is readonly caters to the user too ;)

[16:14] <McFist> pmichaud: can be there such "is rw" that, well, just rw, and doesn't modify the caller?

[16:14] <moritz_> McFist: if you use recursion, you probably just want  sub f($x) { f($x-1) } instead

[16:14] <huf> McFist: is copy?

[16:14] <pmichaud> McFist: there is... it's "is copy"

[16:14] <PerlJam> McFist: wait ... sanity check: do you also want variables to be auto-declared per scope (i.e. get rid of "my")  ?

[16:14] <masak> huf: right. but it does so by being a bit strict.

[16:14] <huf> masak: bondage is good!

[16:15] <McFist> PerlJam: no, why?

[16:15] <masak> huf: in this case, it leads to some good things.

[16:15] <huf> masak: especially as perl always leaves a loophole open ;)

[16:15] *** blogometer joined
[16:15] <huf> so you're never truly bound

[16:15] <McFist> moritz_: not the best example, pls don't mind recursion

[16:15] <masak> huf: there's always a 'safe word'?

[16:15] <masak> :)

[16:15] <huf> ;) yeah

[16:15] <PerlJam> McFist: because it's another area where people think the "saner default" is to do something implicit rather than explicit.

[16:16] <PerlJam> McFist: those people would be wrong  :)

[16:16] <McFist> yeah, but

[16:16] <McFist> do I undrestand correctly that the only argument agains default "is copy" is runtime overhead?

[16:16] <jnthn> Not at all

[16:16] <TimToady_> no

[16:16] <PerlJam> McFist: nope

[16:16] <TimToady_> we want to know what the programmer means by "$param = 42", not just guess

[16:17] <TimToady_> that's the other argument

[16:17] <McFist> TimToady_: why? and who're we here?

[16:17] <[particle]> repeat that a few more times.

[16:17] <TimToady_> we want to know what the programmer means by "$param = 42", not just guess

[16:17] <McFist> sorry I didn't get that from 1st time

[16:17] <moritz_> we want to know what the programmer means by "$param = 42", not just guess

[16:17] <PerlJam> heh

[16:17] <moritz_> (maybe it helps if more people say it? :-)

[16:17] <masak> we want to know what the programmer means by "$param = 42", not just guess

[16:18] <McFist> moritz_: do you really think so?

[16:18] <pmichaud> 16:06 <pmichaud> if you're going to write to a parameter, you should declare what sort of 'write' you want to be doing.

[16:18] <TimToady_> "we" is anyone or anything who cares

[16:18] <moritz_> McFist: indeed

[16:18] *** justatheory joined
[16:18] <TimToady_> but esp the compiler

[16:18] <moritz_> and the test suite maintainer

[16:18] <jnthn> Or anyone trying to ready/understand the code.

[16:18] <jnthn> *rad

[16:18] <jnthn> *read

[16:18] <TimToady_> and the language designer, who often uses "we" to mean "I"  :)

[16:19] * masak tries to rad some of his code sometimes

[16:19] <McFist> well, ok , you want it but why??

[16:19] <PerlJam> TimToady_: link him to your doc on natural language principles.  (I don't have it handy or know it right off)

[16:19] <moritz_> McFist: do you want to understand code you read?

[16:19] <PerlJam> :)

[16:19] <TimToady_> well, there are two reasons, and you're turning into a troll

[16:19] *** risou_ joined
[16:20] *** McFist left
[16:20] <rokoteko> pmichaud: mind if I am a bit nosy. "I'm not really after all of the people who program in Perl 5 and are happy with it" .. why not? 

[16:20] <masak> McFist: please be more specific than 'why??' that sounds like you didn't understand the last ten minutes of conversation at all.

[16:20] *** McFist joined
[16:20] <McFist> sorry

[16:20] <masak> McFist: please be more specific than 'why??' that sounds like you didn't understand the last ten minutes of conversation at all.

[16:20] <PerlJam> ah, found it.

[16:20] <moritz_> rokoteko: I'm not pmichaud... but going for people who are happy with their current programming language

[16:20] <McFist> sorry if I look like trolling, I'm not

[16:20] <moritz_> ... is just inefficient

[16:20] <PerlJam> McFist: Language design is hard. See http://www.wall.org/~larry/natural.html

[16:21] <McFist> it's hard to answer 5 people in parallel )

[16:21] *** justatheory left
[16:21] *** risou left
[16:21] <rokoteko> moritz_: Erm. But it's perl. So you are one of those people who think that perl5 and perl6 are completely different languages?

[16:21] <moritz_> rokoteko: it's much easier to convince people who are searching for something better

[16:21] <pmurias> McFist: the reason "is readonly" is the default is that we want to protect people against accidently modifing the variable

[16:21] <rokoteko> moritz_: if you are happy with perl5, you cant be excited about perl6?

[16:21] <moritz_> rokoteko: no. I think they are different languagages, and both are perl

[16:21] <pmichaud> rokoteko: because if I say to myself "how do I make Perl 6 successful", I see that I can either try to convert Perl 5 programmers, or I can go after people who don't yet program or don't yet program in Perl

[16:22] <McFist> masak: well to be more precise: "why we (e.g. compiler if I understand Larry correctly here) what to know what programmer means by $x = 42"?

[16:22] <pmurias> * modifiying

[16:22] <pmichaud> I think the latter group is where the bigger win is

[16:22] <McFist> PerlJam: thanks

[16:22] <pmichaud> McFist: no, not the compiler

[16:22] <PerlJam> McFist: the compiler wants to know so that it can generate the appropriate instructions

[16:22] <masak> McFist: because depending on what you mean, the assignment could either affect or not affect the caller environment.

[16:22] <moritz_> rokoteko: sure. I got excited about Perl 6 when I was a Perl 5 programmer, and liked it. But there's not much to win if you try to convince die-hard p5 fans like Abigail

[16:22] <PerlJam> McFist: the humans want to know so that they can have a reasonable chance at understanding the program

[16:23] <masak> McFist: with 'is copy', it doesn't affect the caller, with 'is rw' it does.

[16:23] <pmichaud> the compiler could figure it out.  it's the other people reading the code that we want to clarify for

[16:23] <McFist> pmichaud: well, but who then, the design team? 

[16:23] <pmichaud> McFist: other programmers

[16:23] <McFist> pmichaud:programmers like in "fellow programmers" or the perl6 design team?

[16:23] <TimToady_> pmichaud: I don't think the compiler can figure that out in many cases

[16:23] <moritz_> rokoteko: or die-hard fans of any programming language. Either they are amazed by what they see of Perl 6, or not. If not, leave them alone. You won't make them happy by intruding their language choice

[16:23] <PerlJam> McFist: Perl 6 programmers.

[16:24] <rokoteko> pmichaud: hm. interesting point. Im not that familiar with marketing.

[16:24] <pmichaud> rokoteko: it's part of being a "disruptive technology"  (more)

[16:24] <PerlJam> McFist: programmers in general too, but they'll have a tougher time at it if they don't already know perl :)

[16:24] <moritz_> and you won't make yourself happy either, because they'll keep comparing p6 to their old love, and moan that things are different

[16:24] <TimToady_> however, to the first approximation, the sample of Perl 6 programmers we have is the design team :)

[16:24] <McFist> well I do :)

[16:25] <TimToady_> rakudo star is all about trying to broaden that sample

[16:25] <PerlJam> moritz_: Love isn't a zero-sum game.  You can make more of it.  It's too bad people treat it otherwise sometimes. :(

[16:25] <pmichaud> rokoteko: disruptive technologies often start out by targeting "markets" that the existing technologies ignore or discount

[16:26] <pmichaud> rokoteko: or, I can put it another way (more)

[16:26] <McFist> well, I didn't buy the second argument then "we want to know what programmer means by $x = 42", because perl5 could do that without default readonly

[16:26] <moritz_> PerlJam: yeah, but love != die-hard fanboyism

[16:26] <rokoteko> pmichaud: nods. well (to me) your post just made perl6 sound like perl5 for dummies. ;)

[16:26] <pmichaud> rokoteko: which is larger -- the base of programmers that exists today, or all of the yet-to-be-programmers that will come up in the next 20-30 years?

[16:26] <tylercurtis> McFist: that's because in Perl 5, you can't have readonly parameters.

[16:26] <TimToady_> McFist: only by forcing the user to make a copy

[16:26] <moritz_> McFist: perl5 doesn't have parameters

[16:26] <McFist> true

[16:26] <moritz_> so $param = 42 never occurs in p5

[16:26] <patrickas> rakudo: my @a=1,2,3,4,5,6; say @a[*-3 .. *-1];

[16:26] <McFist> also true

[16:26] <moritz_> unless you copied to it first

[16:26] <p6eval> rakudo 90637b: OUTPUT«4111111111111111␤»

[16:27] <McFist> but wouldn't it be great if it would in perl6?

[16:27] <moritz_> patrickas: that's curious :-)

[16:27] <pmichaud> rokoteko: (perl 5 for dummies) -- I can see how that could be inferred from the post.  It's not that Perl 6 is dumber -- it's just cleaner.

[16:27] <pmurias> McFist: you can still do my $foo = @_[0] if you want

[16:27] <huf> McFist: what would be the advantge of making the default harder to reason about with no gain at all?

[16:27] <rokoteko> pmichaud: I was just curious about your point and you gave a relatively good explanation. but as it was perlmonks, maybe you could've added all this yadadada there also. :)

[16:27] <McFist> pmurias: yeah, but it's not cool )

[16:27] <pmichaud> rokoteko: I still can :-)

[16:28] <patrickas> moritz_ yea ... in all cases what's the right way to take the last n items of an array ?

[16:28] <TimToady_> in this case, Perl 6 has chosen cleanliness and speed over a minor convenience

[16:28] <pmichaud> The gain that McFist is after (I think) is that he doesn't have to write 'is copy' in order to modify a local copy of a parameter.

[16:28] <McFist> huf: compatibility with c-infected brains, mine included :)

[16:28] <moritz_> patrickas: I don't know

[16:28] <jnthn> I'm looking at this discussion and thinking, if we make the default something else, what do we gain? We make the code a bit less obvious for the programmer, we make it harder to analyze and understand a sub-routine in isolation (loss for the programmer and the compiler) and we move further away from functional programming ideals too.

[16:28] <huf> McFist: perl isnt c, end of discussion :)))

[16:29] <McFist> pmichaud: yes, thanks, also true

[16:29] <huf> pmichaud: oh, right ;)

[16:29] <moritz_> patrickas: I think *-3..*-1 is supposed to work, but I can see why it doesn't work in the current spec

[16:29] <tylercurtis> McFist: suppose you start working with an existing codebase, and you see a function like "sub foo ($a) { a; bunch; of; stuff; so; that; you; can; no; longer; see; the; signature; $a++; do-something-with($a); }" And you see the $a++ bit.

[16:29] <moritz_> and another reason why it doesn't work in rakudo

[16:29] <tylercurtis> What does it do?

[16:29] <jnthn> Yes, you might end up writing your code a bit differently due to the default being readonly.

[16:29] <jnthn> I'm not convinced that'll make for worse code though.

[16:29] <TimToady_> I wonder if * + * could default the second arg to the first

[16:30] <pmurias> tylercurtis: but you would have to look up to the signature regardless of the default

[16:30] <McFist> tylercurtis: hmm I think I'd expect that $a is on stack and doesnt modify the caller -- isn't it natural?

[16:30] <moritz_> TimToady_: that would make my starry obfu work again. Great idea :-)

[16:30] <jnthn> After all, the parameter name is the name for the thingy you expect to be passed as an argument.

[16:30] <rokoteko> pmichaud: okie. just wanted to make this clear for me as I atleast somehow managed to interpret that post wrong. thanks for your time and all the effort you are doing for perl (6). :)

[16:30] <moritz_> McFist: forget the stack when you're talking about Perl 6

[16:30] <McFist> moritz_: why?

[16:30] <moritz_> McFist: because there is no stack.

[16:30] <jnthn> If you manipulate it in some way, you probably have a different thing and should probably stick it in a container with a more appropriate name.

[16:31] <pmichaud> rokoteko: you're welcome

[16:31] <pmichaud> rokoteko: and thanks for your question; I'll see if I can clarify my comments more in the future (and the post as well if I think of how to do it)

[16:31] <moritz_> McFist: Rakudo is based on CPS (because parrot is based on it). There are signatures and parcels for passing arguments. No stack.

[16:32] <jnthn> s/parcels/captures/

[16:32] <moritz_> erm, right

[16:32] <rokoteko> pmichaud: I dont mind. I can always ask here. and maybe Im the only one who feels this way. :) I feel Im not the majority. ;)

[16:32] <McFist> moritz_: how does the recursion work then?

[16:32] <moritz_> McFist: just like any other function call, really

[16:33] <PerlJam> TimToady_: if you did that, would that also affect N-ary whatevers like  * + * + * + *   ?

[16:33] <masak> I'm against * + * being of variable arity, because it would create hard-to-track-down odd behaviours in closures. Do Not Want.

[16:33] <moritz_> McFist: see http://de.wikipedia.org/wiki/Continuation-passing_style

[16:33] <McFist> moritz_: thanks, I know what cps is

[16:33] <jnthn> masak: I'm inclined to think it's a tad too clever too...

[16:33] <moritz_> McFist: then what's the problem with recusion?

[16:33] <pmurias> moritz_: isn't what you describe a form of a stack

[16:33] <McFist> and I don't know german anyway )

[16:33] <TimToady_> it's not an argument stack

[16:34] <McFist> aha

[16:34] <TimToady_> it's a context stack

[16:34] <pmichaud> rokoteko: (not majority) sure, but I can still try to tune my delivery a bit.  at any rate, thanks again for your question, it's very helpful.

[16:34] <TimToady_> to be sure, a callframe is likely to have a pointer to its arguments

[16:34] <moritz_> pmurias: no, it's more of a general graph

[16:35] <McFist> hm well anyway, stack or not, I'd expect $a++ modifies only the memory visible to the current function run, not the caller

[16:35] <tylercurtis> McFist: even if you specifically ask for modifying the caller?

[16:35] <moritz_> McFist: then be glad that in Perl 6, it doesn't modify what the caller sees

[16:35] <McFist> tylercurtis: no, of course

[16:35] <McFist> I'd consider "is rw" a dangerous thing, as it is in perl5

[16:36] <McFist> but we're talking about defaults

[16:36] <moritz_> rakudo: sub f($x) { $x++ }; my $a = 5; try { f($a) }; say $a

[16:36] <p6eval> rakudo 90637b: OUTPUT«5␤»

[16:36] <moritz_> look, it didn't modify $a

[16:36] <moritz_> isn't that great?

[16:36] <pmurias> moritz_: isn't the default readonly?

[16:36] <moritz_> pmurias: yes

[16:36] <TiMBuS> implement 'is cow', everyone wins (except pmichaud who has to implement it)

[16:37] <TiMBuS> :3

[16:37] <McFist> moritz_: wait, how could $x++ work if it is readonly? I'm confused

[16:37] <pmurias> McFist: how often do you modify the argument?

[16:37] <PerlJam> TimToady_: if "is cow" isn't specced, that should probably happen first :)

[16:37] <moritz_> McFist: it threw and exception

[16:37] <McFist> aah

[16:37] <PerlJam> McFist: note the try block

[16:37] <McFist> yes

[16:38] <McFist> "is cow"++

[16:38] <TimToady_> cows are overrated

[16:38] <PerlJam> TiMBuS: er ... see what I just erroneously said to TimToady_ 

[16:38] <moritz_> Mu!

[16:38] <TiMBuS> heh i saw

[16:38] <McFist> (default "is cow") even more ++

[16:38] <PerlJam> TimToady_: at least they don't have GILs

[16:38] * moritz_ -> afk

[16:39] <McFist> pmurias: not often, but when I do it given the unpleasant feeling if it's readonly

[16:39] <McFist> gives

[16:39] <jdv79> the signatures/captures aren't really going to be used for compiler optimizations are they?  just saw jnthn's EU talk.

[16:40] <jnthn> jdv79: Huh? Of course they're useful information for the compiler.

[16:40] <jdv79> you gave an example of using they to transform trees - constant folding...

[16:40] <jnthn> jdv79: We might be able to statically work out which candidate a multi-dispatch shoudl go to at compile time and save going thorugh the multi-dispatcher, for example.

[16:40] <TimToady_> there's another more fundamental reason for readonly, which is that Perl 6 is trying to bias programming more in the direction of side-effect-free FP

[16:40] <jdv79> *them

[16:40] <jnthn> jdv79: Oh

[16:41] <jnthn> jdv79: Sorry, mis-grokked what you meant. :-)

[16:41] <McFist> TimToady_: that's a much better argument that a vague and totalitarian "we want to control $x = 42" :)

[16:41] <McFist> than

[16:41] <jnthn> jdv79: I've no idea if we'd actually write it that way. You do want to match stuff in trees though at some level.

[16:41] <jnthn> jdv79: I mean, PAST is really the tree form that the compiler users.

[16:41] <jnthn> jdv79: So the example was realistic in that sense.

[16:41] <jnthn> (where the compiler = Rakudo)

[16:42] <TimToady_> well, language designers have to think on many levels at once, and you were asking on a more detailed level, so it took a while to generalize in my head

[16:42] <McFist> I might even like that level, at least

[16:42] <TimToady_> most of these design decisions are made for many reasons, not all of which are easy to articulate

[16:42] *** cozmic left
[16:42] <PerlJam> I think this is the first time I've seen anyone imply that TimToady_ is totalitarian.

[16:43] <PerlJam> It's like I'm in the twilight zone or something  :)

[16:43] <jdv79> i found it surprising but interesting

[16:43] <McFist> oh please don't paint me che guevara, alright? :)

[16:44] <McFist> sorry if that offended anyone though

[16:44] <TimToady_> certainly not me

[16:45] <jnthn> jdv79: I guess it depends how efficient we could make it.

[16:45] <masak> PerlJam: I've seen it on Reddit as well. it was absurd there as well.

[16:45] <PerlJam> McFist: Any other language design issues you'd like to discuss? :-)

[16:45] <TimToady_> I already know I'm vague and totalitarian :)

[16:45] <TiMBuS> TimToady_, is making a copy not free of side effects?? just curious

[16:45] <McFist> PerlJam: i'm leaving already, thanks for the hospitality

[16:45] <jnthn> jdv79: fwiw, PAST nodes are already represented as Captures.

[16:45] <jnthn> jdv79: So it may not be such a bad fit.

[16:47] <PerlJam> TiMBuS: sure, but at the expense of always copying.  Would you rather it be side-effect free and only those who need copying pay the cost?

[16:47] <PerlJam> (and only pay it where they need it)

[16:47] *** cozmic joined
[16:49] <TiMBuS> PerlJam, of course, but that goes back to the overhead issue more than side effects. anyway i was just legitimately curious about whether copying cured side effects or not

[16:50] <PerlJam> TiMBuS: aye.

[16:50] <masak> http://ostatic.com/blog/is-perl-6-imminent-and-does-anybody-care

[16:51] <masak> "Just when many were set to write Perl off, it may surprise people once again."

[16:51] <TimToady_> in pure FP, nothing is mutable, so it doesn't matter if you copy or not

[16:51] <PerlJam> masak: a funny (to me at least) quote from there is "Wall himself seemed to imply that a finished version might be available by Christmas."   :-)

[16:51] <pmichaud> masak: iirc, Tim O'Reilly said a similar thing at his OSCON keynote a few years ago :) :)

[16:52] <masak> PerlJam: :D

[16:52] <masak> pmichaud: it's becoming truer by each year!

[16:52] <pmichaud> I'm still waiting for another blog post where someone writes "nobody cares about Perl 6" so that I can reply "I care."  :-)

[16:52] <jnthn> masak: Love the comments... "C# and Java nerds are running scared. Perl 6 will destroy themb."

[16:52] <masak> RAWR

[16:52] <jnthn> masak: But I'm a Perl 6 *and* C# nerd. Do I destory myself? ;-)

[16:53] <PerlJam> pmichaud: Tim O'Reilly said that TimToady could "see around corners".   I'm still wondering how he can do that :)

[16:53] <masak> jnthn: no, it's more of a 50% destroys 50% situation :P

[16:53] <pmichaud> jnthn: Yes.  By definition if you care about both you've already destroyed yourself.  :)

[16:53] <masak> PerlJam: using LTM, probably.

[16:53] <jnthn> :P

[16:53] <pmichaud> PerlJam: it has to do with immortality.

[16:54] <masak> great. I try to go home, and suddenly it's Silly Hour.

[16:54] <pmichaud> PerlJam: immortality also implies the ability to send things back from the future, I think.

[16:54] <PerlJam> nothing is new under the sun?

[16:54] <tylercurtis> jnthn: Wait until you finish the new metamodel, at least. :P

[16:54] <masak> in FP, everything is immortal.

[16:54] <masak> PerlJam: nowadays, it's "nothing new under the oracle".

[16:54] <rokoteko> moritz_: sorry I didn't answer you as pmichaud happened to respond to me and I got caught up with that. But I dunno about the Abigail situation, but that is seriously an Extreme case. There's no reason to compare anyone mortal (like me) to Abigail. :) Anyhow. I think Abigail might also get interested (if not yet) what you are doing, when perl6 shows its power. ie. do what you used to did with perl5, just as easily, and we offer all this more.

[16:55] <pmichaud> PerlJam: and right now, everything under the Sun is likely to get you sued for patent infringement :-P

[16:55] <masak> rokoteko: tl;dr :)

[16:56] *** squeeky joined
[16:56] <squeeky> rahhh.

[16:56] <masak> squeeky! \o/

[16:57] <McFist> well anyway people if you consider "is cow" that'd be really great

[16:57] * McFist afk

[16:57] <rokoteko> personally Im bit confused about what is different between my $bar = &foo;   and   my $bar := &foo;  .. to me it would be easier if there was only one only one syntax for everything but many different ways of using the syntax. :)

[16:57] <rokoteko> masak: tl;dr ?

[16:57] <squeeky> masak: I'm not back for good reasons.

[16:57] <squeeky> the Configure.pl issues sprung up again. le sigh.

[16:57] <masak> :/

[16:58] <jnthn> tylercurtis: Is it more terrifying that I chose to write to prototype in C#? :-)

[16:58] <jnthn> .oO( Maybe the metamodel will destory me. o_O )

[16:58] <masak> rokoteko: on reddit-like sites, that's an expression meaning "too long, didn't read". I meant to imply that your line of IRC was, er, longish. :)

[16:59] <squeeky> Wow, tl;dr is about 7 years old now. First showed up on SomethingAwful.

[16:59] <rokoteko> masak: ahh. it was a long while ago that I was supposed to response. :)

[16:59] <masak> nom &

[16:59] *** masak left
[17:00] <tylercurtis> jnthn: as long as it ends up back on Parrot, $_ !~~ :terrifying.

[17:01] <jnthn> tylercurtis: Oh yes, it will. :-)

[17:01] *** envi^home left
[17:02] <pmichaud> rokoteko: a more accurate statement of my comment would be something like "I don't need to target Perl 5 programmers, because they already know Perl is beautiful.  They'll start migrating to Perl 6 when it's ready for them, and even if they don't ever migrate, that's great -- they're still following the Perl philosophy.  The bigger impact is on all those yet-to-be-programmers who someday will be looking for a programming language to use, and Perl 6 can h

[17:02] * tylercurtis is tempted to attempt to write a Parrot runtime for it in Winxed or something now that he has more free time.

[17:02] <tylercurtis> :)

[17:03] <TimToady_> .oO(Perl 6 can h)?

[17:03] <pmichaud> can hopefully  attract them."

[17:03] <pmichaud> (must've gotten cut off)

[17:04] *** kuzuha joined
[17:04] <pmichaud> lunchtime here, then $otherjob

[17:05] <pmichaud> then I think I'll do some more profiling for a bit

[17:05] <pmichaud> any word on the release eta?

[17:05] *** kuzuha_ left
[17:06] <jnthn> pmichaud: I think mathw++ said he'd cut the tarball this evening.

[17:06] <jnthn> pmichaud: As in, UK evening.

[17:06] <jnthn> It'd only be 6:13pm there ATM so not quite evening yet :-)

[17:06] <pmichaud> okay, wfm.

[17:06] <gfldex> Somebody will have to save all those PHP dudes. Perl 6 is gonna do that. :)

[17:06] <pmichaud> I'll bbl

[17:09] *** bla123 joined
[17:10] *** justatheory joined
[17:11] <rokoteko> pmichaud: well that was a *bit* better. but to add to this again; why the extensive use of "I" ? I thought the butterfly logo was the spokesbug for perl6?

[17:11] *** dakkar left
[17:12] <pmichaud> rokoteko: oh, because I'm only talking about my motivations for Perl 6.  I don't speak for the language (yet?)

[17:12] <pmichaud> Perhaps I do speak for the language and don't realize it yet :)

[17:12] <rokoteko> pmichaud: :)

[17:13] <PerlJam> pmichaud: you speak quite well for the language at conferences from what I've seen :)

[17:14] <moritz_> rakudo: class A { }; say pir::typeof__SP(A)

[17:14] <p6eval> rakudo 90637b: OUTPUT«A␤»

[17:18] <rokoteko> hmm.. so is there any difference between my $foo := &bar;  ..vs..  my $foo = &bar; ?

[17:19] <gfldex> it's a different operator

[17:19] <gfldex> so if somebody did magic with either operator, it will be different for sure :)

[17:19] <rokoteko> nothing else?

[17:19] <moritz_> rokoteko: yes, binding makes $foo read-only

[17:20] <tylercurtis> star: my &foo = -> $x { say $x }; my $bar = &foo; &foo = -> $x { say -$x; }; $bar(5)

[17:21] <p6eval> star 2010.07: OUTPUT«5␤»

[17:21] <tylercurtis> star: my &foo = -> $x { say $x }; my $bar := &foo; &foo = -> $x { say -$x; }; $bar(5)

[17:21] <p6eval> star 2010.07: OUTPUT«-5␤»

[17:21] <rokoteko> ok. I kinda understand the point. I wonder mainly wondering why .WHICH for both returned the same.

[17:21] *** ash_ joined
[17:21] <rokoteko> but to get to the point, why I wondered about this...

[17:21] <patrickas> rakudo: say (1,2, *+*+* ... 20)

[17:21] <p6eval> rakudo 90637b: OUTPUT«12»

[17:22] <rokoteko> rakudo: sub foo (Int $x) { 1 .. $x }; push my @arr, &foo.assuming($_) for 2..5; say join ", ", @arr[2].()

[17:22] <p6eval> rakudo 90637b: OUTPUT«1, 2, 3, 4␤»

[17:22] <rokoteko> how would you do this using the read-onlyness of  :=  ?

[17:22] <jnthn> With my $foo = &bar; you have a scalar container which now holds a code object.

[17:23] <jnthn> With my $foo := &bar; the $foo symbol directly references the code object.

[17:23] <jnthn> And you don't have the container.

[17:23] <jnthn> iiuc.

[17:23] *** Italian_Plumber joined
[17:25] <moritz_> jnthn: could you please take a look at http://nopaste.snit.ch/22909 ?

[17:25] *** bla123 left
[17:25] <moritz_> I tested it with 

[17:25] <moritz_> ./perl6 -e 'class A { }; grammar B is A is Array { method TOP { "foo" } }; say A ~~ Grammar'

[17:25] <moritz_> and it's false

[17:25] <moritz_> and the debugging output says that both parent classes are 'Class'

[17:25] <rokoteko> jnthn: ok. but shouldnt $foo.WHICH be different for the former and latter? or what Im missing here?

[17:25] <moritz_> that's what the typeof  returns

[17:26] <moritz_> rokoteko: .WHICH on a scalar acts on the object, not the container

[17:27] <rokoteko> moritz_: ahh. how can I make it act on the container? 

[17:27] <jnthn> moritz_: YOu just discovered what happens when you don't have type objects...

[17:27] <rokoteko> rakudo: my &bar = { 1 }; my &foo1 = &bar; my &foo2 := &bar; say &bar.WHICH ~ "/" ~ &foo1.WHICH ~ "/" ~ &foo2.WHICH

[17:27] <p6eval> rakudo 90637b: OUTPUT«124312272/124312272/124312272␤»

[17:28] <jnthn> rokoteko: VAR($a).WHICH I guess

[17:28] *** thebird left
[17:28] <rokoteko> moritz_: the above example doesn't act on scalar... what's happening there?

[17:28] <pmurias> tylercurtis: what's winxed?

[17:29] *** justatheory left
[17:29] <moritz_> rokoteko: .WHICH acts on the object; the object is &bar every time.

[17:29] <ash_> pmurias: winxed is a language based off javascript for parrot, see http://code.google.com/p/winxed/ its by NotFound++ 

[17:29] <rokoteko> rakudo: my &bar = { 1 }; my $foo1 = &bar; my $foo2 := &bar; say &bar.WHICH ~ "/" ~ VAR($foo1).WHICH ~ "/" ~ VAR($foo2).WHICH

[17:29] <p6eval> rakudo 90637b: OUTPUT«Could not find sub &VAR␤  in main program body at line 22:/tmp/gyUzUEPAfD␤»

[17:30] <rokoteko> NYI?

[17:30] <moritz_> seems like

[17:30] <moritz_> jnthn: is there an easy(-ish) fix?

[17:30] <rokoteko> ok. Then it's obviously the wrong time trying to figure this out. :)

[17:31] <jnthn> moritz_: Ah, yes

[17:32] <jnthn> moritz_: (sorry, took me a moment to realize the easy way :-))

[17:32] <jnthn> moritz_: Get the Parrot class object associated with Grammar

[17:32] <jnthn> And then use eq_addr

[17:32] *** buzzlightyear joined
[17:32] <jnthn> To see if they're the same thing.

[17:33] <jnthn> moritz_: Let me know if you need more details on how to do that.

[17:33] <moritz_> jnthn: ah, but I want to also consider the parent's parent

[17:33] <jnthn> Oh...hm

[17:33] <jnthn> oh

[17:33] <moritz_> jnthn: so I'd end up re-implementing isa, no?

[17:34] <jnthn> moritz_: No, you can get Parrot to tell you the MRO I guess

[17:34] <jnthn> inspect with "all_parents" to get that

[17:34] <jnthn> Then you just have to look through that.

[17:34] <moritz_> I'll try that, thanks

[17:34] <jnthn> moritz_: You're might be getting and inkling of why I'm re-doing the meta-model stuff. :-)

[17:34] *** risou_ left
[17:35] <moritz_> :-)

[17:38] <jnthn> yowser I has a hungry

[17:38] * jnthn takes a nombreak

[17:41] *** buzzlightyear left
[17:51] <pmichaud> http://www.perlmonks.org/?node_id=856089   # not news, but maybe interesting to others

[17:52] <pmichaud> afk, lunch

[17:53] *** Trashlord left
[17:55] *** pyrimidine left
[17:55] *** pyrimidine joined
[17:56] *** Trashlord joined
[17:57] *** cotto_work left
[17:57] *** pyrimidine_ joined
[17:57] *** Holy_Cow left
[17:58] *** Holy_Cow joined
[17:59] *** pmurias left
[17:59] *** pyrimidine left
[17:59] *** pyrimidine_ is now known as pyrimidine

[18:01] *** daxim left
[18:04] *** cotto_work joined
[18:04] <Exodist> Hmm. C pisses me off, I think I will switch to implementing Oyster-Perl6 on Go.

[18:04] <Exodist> (good excuse to learn Go as well)

[18:06] *** pyrimidine is now known as py[tab]

[18:09] *** araujo left
[18:09] *** araujo joined
[18:11] *** tadzik joined
[18:15] *** mberends joined
[18:15] *** patrickas left
[18:16] *** Mowah joined
[18:20] *** djburiedalive joined
[18:21] *** djburiedalive left
[18:24] <sorear> good * #perl6

[18:24] *** stephenlb joined
[18:25] *** stephenlb left
[18:26] *** stephenlb joined
[18:26] <tadzik> good evening

[18:26] <sorear> niecza: use Test; ok True, "can load modules from p6eval"

[18:26] <p6eval> niecza 4770bf5: OUTPUT«(timeout)»

[18:27] <sorear> niecza: use Test; ok True, "can load modules from p6eval"

[18:27] <p6eval> niecza 4770bf5: OUTPUT«ok 1 - can load modules from p6eval␤»

[18:27] * sorear needs to make niecza faster :/

[18:28] <moritz_> jnthn: hm, doesn't work with all_parents either

[18:28] *** Mowah left
[18:29] *** alester left
[18:30] *** alester joined
[18:31] <sorear> moritz_: just add Grammar to the end of the list, C3 will DTRT

[18:31] <sorear> (unconditionally)

[18:32] <moritz_> wow. Then I don't understand C3 correctly

[18:32] <sorear> also, why shouldn't grammar Foo is Any work

[18:32] <sorear> class Foo is Mu works

[18:33] <moritz_> because class != grammar

[18:38] *** eternale1e is now known as eternaleye

[18:43] *** mantovani left
[18:44] *** mantovani joined
[18:46] *** blogometer_ joined
[18:47] *** blogometer left
[18:47] *** blogometer_ is now known as blogometer

[18:47] *** Trashlord left
[18:49] <colomon> pmichaud, TimToady_: does the strict laziness requirement for .lines imply that basically every normal filter method must also be strictly lazy?  For instance, .grep.

[18:49] <colomon> My backscroll here doesn't go far enough, but someone suggested something like $IO.lines.take-until('------')

[18:50] <colomon> could that then simply be $IO.lines.grep('--------').shift ?

[18:50] *** Trashlord joined
[18:51] <moritz_> (fwiw, http://irclog.perlgeek.de/perl6/today has nearly infinite backscroll :-)

[18:51] <colomon> moritz_: yeah, but I have nearly infinite laziness.

[18:52] <ash_> colomon: dont worry, thats a virtue i hear in these parts

[18:53] * PerlJam wonders if anyone has specced .first

[18:53] <sorear> .[0] is shorter

[18:53] <[Coke]> you mean .car?

[18:53] <sorear> and it's .head anyway

[18:54] *** blogometer left
[18:54] <colomon> .head versus .car religious war!

[18:54] <phenny> Can't connect to http://versus .car religious

[18:55] <ash_> isn't just [0] shorter than .[0]?

[18:55] <moritz_> .head http://sudokugarden.de/

[18:55] <phenny> moritz_: 200, text/html, utf-8

[18:55] <colomon> PerlJam: yup, .first is in there and does exactly what I want in this case.

[18:56] <colomon> but I think .grep makes the point clearer.

[18:56] <ash_> rakudo: my @a = 1..3; say @a.first; # NYI ?

[18:56] <p6eval> rakudo 90637b: OUTPUT«No candidates found to invoke for method 'first' on object of type 'Array'; available candidates have signatures:␤:(Mu : Mu $test;; *%_)␤␤  in main program body at line 22:/tmp/1cnSc6QSEi␤»

[18:56] <ash_> rakudo: my @a = 1..3; say @a.first 1;

[18:56] *** pmurias joined
[18:56] <p6eval> rakudo 90637b: OUTPUT«===SORRY!===␤Confused at line 22, near "say @a.fir"␤»

[18:56] <pmurias> ruoso: ping

[18:56] <colomon> rakudo: my @a = 1..3; say @a.first(* %% 2)

[18:56] <p6eval> rakudo 90637b: OUTPUT«2␤»

[18:57] <ash_> ah

[18:57] <ash_> rakudo: my @a = 1..6; say @a.first(* %% 2), ' ', @a.grep(* %% 2).shift;

[18:57] <p6eval> rakudo 90637b: OUTPUT«2 2␤»

[18:57] <pmurias> Exodist: what is Oyster-Perl6?

[18:58] <sorear> pmurias: hi

[18:58] <pmurias> sorear: hi

[18:58] <sorear> pmurias: why do you use require "viv"

[18:59] <pmurias> don't remember

[18:59] <pmurias> i can try to stop using that and check if anything breaks

[18:59] * sorear plans to move viv out of @INC at some point, at which point that will pick up an old version

[19:00] <pmurias> viv defines some VAST::* classes

[19:00] <PerlJam> rakudo: my @a = 'a'..'z';  say @a.rotate(13);

[19:00] <p6eval> rakudo 90637b: OUTPUT«nopqrstuvwxyzabcdefghijklm␤»

[19:00] *** masak joined
[19:01] <pmurias> sorear: Actions autogenerates missing ones

[19:01] *** Italian_Plumber left
[19:01] <Exodist> pmichaud, http://github.com/exodist/Oyster

[19:01] <masak> moritz_: 'nearly infinite' is a bit of an exaggeration... :)

[19:01] <masak> Exodist: oh hai.

[19:01] <pmurias> sorear: but all of them inherit from VAST::Base

[19:01] * pmichaud assumes that was meant for pmurias.

[19:01] <Exodist> oops, sorry pmichaud, that was for pmurias

[19:02] <Exodist> damn tab completion in xchat

[19:02] <masak> Exodist: happens to everyone in here :)

[19:02] <masak> Exodist: we're both implementing self-hosting Perl 6 implementations. perhaps you saw my email.

[19:02] <Exodist> I did, didn't I respond?

[19:02] * masak checks

[19:03] <masak> nope. :)

[19:03] <Exodist> oh, oops

[19:03] <moritz_> masak: well, it goes back a million line... that's quite close to infinity, for a backscroll

[19:03] <masak> Exodist: forgot to push, like pmichaud? :P

[19:03] <Exodist> masak, what lang is yours in?

[19:03] <masak> Exodist: Perl 6.

[19:03] <masak> hence the 'self-hosting'.

[19:03] * pmichaud assumes that "self-hosting Perl6" means "written in Perl 6"  :-P

[19:03] <masak> Exodist: I've yet to see much Perl 6 in your self-hosting impl. :P

[19:03] <diakopter> P-:

[19:04] <Exodist> lol, I mean your bootstrapping stuff.

[19:04] <masak> Exodist: oh, that.

[19:04] <Exodist> is it gonna be rakudo-strapped?

[19:04] <moritz_> akshually it's 1.9mio lines in #perl6

[19:04] <masak> it *is* Rakudo-strapped.

[19:04] <masak> doesn't compile/run itself yet.

[19:04] <masak> doesn't by quite a bit, akshually.

[19:05] <pmurias> Exodist: re Perl6-Go, perlito has a Go backend

[19:05] * diakopter whistles "These Rakudos are made for walkin'"

[19:05] *** jaldhar left
[19:05] <masak> diakopter: if Nike makes a shoe named "Rakudo", we're either hosed, or golden.

[19:05] <Exodist> pmurias, ah, I was thinking of switching cause C is so stressful.

[19:06] <Exodist> Go has a lot of things already just done for me.

[19:06] <masak> Exodist: from what I've seen of your commits, your project has more of a bottom-up approach, and Yapsi has more of a top-down approach.

[19:07] <Exodist> masak, yeah, trouth is I am most interested in implementing tha grammar engine.

[19:07] <Exodist> cause it seems fun

[19:07] <masak> Exodist: aye, that's why in my email I linked you to my Perl 6 implementation of a Perl 6 grammar engine.

[19:08] <masak> it *was* quite fun to write.

[19:08] <masak> so far I've given three talks about it. :)

[19:08] *** rokoteko left
[19:09] <moritz_> talk-driven design!

[19:10] <masak> moritz_: most of the development took place before the talks, though. :)

[19:10] * jnthn was there at The First Talk

[19:10] <masak> between the first and the second talks I finally figgered out how to do backtracking right.

[19:10] <masak> backtracking is clearly the fun part.

[19:10] <jnthn> Actually, I think I've seen all three...

[19:12] <moritz_> rakudo: use fatal; open('nonexistant')

[19:12] <p6eval> rakudo 90637b: OUTPUT«Operation not permitted in safe mode␤  in 'Safe::forbidden' at line 2:/tmp/UWF_orMPCL␤  in main program body at line 22:/tmp/UWF_orMPCL␤»

[19:12] <moritz_> works locally

[19:13] <pmurias> sorear: dropping use viv seems to be mostly adding some VAST classes to viv

[19:13] <moritz_> oh, it's always fatal

[19:13] <masak> jnthn: you might be the only one who has been to all three :)

[19:14] * moritz_ thinks masak also has been to all three

[19:14] * masak is not so sure himself

[19:15] <masak> Exodist: anyway, I guess my point is this: if you ever want to discuss the finer points of bootstrapping a Perl 6 implementations, feel free to ping me :)

[19:15] <TimToady_> .oO(it's not really a "Perl 6 grammar" unless it does transitive LTM...mutter...mutter...grumble)

[19:16] <jnthn> masak: I saw you at all of them. :P

[19:16] <Exodist> masak, thanks will do.

[19:16] <masak> jnthn: might've been one of my clones. :P

[19:16] * PerlJam wonders if soon it will be some sort of rite of passage to implement Perl 6

[19:16] <moritz_> TimToady_: just because you're the language desiger doesn't mean people listen to you :-)

[19:16] <jnthn> o_O

[19:16] <masak> TimToady_: I still haven't entirely ruled out trying to go against pmichaud++'s recommendation and refactor GGE into an LTM-y engine.

[19:17] <jdv79> transitive LTM sounds a bit painful

[19:17] <Exodist> TimToady_, My goal is for mine to completely meet the spec, I just have to decide to stay in C or switch it to go.

[19:17] <moritz_> just need to construct a DFA, or something similar

[19:17] <moritz_> "just"

[19:17] <masak> Exodist: what a coincidence, that's the goal for my implementation as well! o.O

[19:18] <Exodist> wait, whats the diff between ltm and transative ltm?

[19:18] *** meppl joined
[19:18] <masak> Exodist: ok, so do you know about ltm?

[19:18] <Exodist> masak, yes

[19:18] <pugssvn> r32059 | moritz++ | [t/spec] tests for RT #71362, $0, $1 etc. work even for $/ := $something 

[19:19] <masak> Exodist: transitive LTM is LTM that doesn't care whether different alternatives are $N levels down in a subrule, as long as they're alternatives in the same alternation.

[19:19] <masak> Exodist: rule foo { <bar> | <baz> }; rule bar { a | b | c }; rule baz { d | e }; rule foo has 5 alternatives.

[19:20] <masak> (that example showcases "transitive", but not "LTM")

[19:21] <sorear> niecza: "fooo" ~~ / foo { say "A" } | fo* { say "B" } /

[19:21] <p6eval> niecza 4770bf5: OUTPUT«B␤»

[19:21] <Exodist> ok, Then what I have been thinking hits that case just fine where it takes longest to depth of alternates.

[19:21] <masak> aye.

[19:21] <masak> and it works correctly with backtracking :)

[19:22] <sorear> Exodist: incidentally, I am also working on a p6 implementation that focuses on the grammar engine

[19:22] <Exodist> sorear, I am following it on github

[19:22] <Exodist> though I have not looked at it to depth.

[19:23] <pugssvn> r32060 | moritz++ | [t/spec] test for RT #66694, redefining methods by augmenting stuff 

[19:23] <masak> "If I didn't believe that, I wouldn't have spent the last decade pouring my heart and soul into it." -- http://www.perlmonks.org/?node_id=855886 by TimToady_ -- wow, for some reason it was refreshing to read that sentence on PerlMonks. TimToady_++

[19:24] <moritz_> rakudo: say 0e999999999999999

[19:24] <p6eval> rakudo 90637b: OUTPUT«NaN␤»

[19:24] <moritz_> "huh"

[19:24] <masak> actually, that whole post is rather warm an fuzzy.

[19:24] <masak> s/an/and/

[19:24] <sorear> It's more accurate than GHC's result

[19:25] <colomon> rakudo: say 0e99999999

[19:25] <moritz_> sorear: what does GHC return?

[19:25] <p6eval> rakudo 90637b: OUTPUT«NaN␤»

[19:25] <colomon> rakudo: say 0e99

[19:25] <p6eval> rakudo 90637b: OUTPUT«0␤»

[19:25] <moritz_> oh. It takes longer. Much longer.

[19:25] <colomon> rakudo: say 0e999

[19:25] <sorear> moritz_: nothing; the parser starts by evaluating 10^999999999999999 as a bignum

[19:25] <p6eval> rakudo 90637b: OUTPUT«NaN␤»

[19:25] <colomon> yeah, that's it all right.  rakudo is evaluating 10^999 before multiplying it by zero.

[19:26] <moritz_> rakudo: say 0e999999999999999 == 0

[19:26] <colomon> rakudo: say 10 ** 999

[19:26] <p6eval> rakudo 90637b: OUTPUT«0␤»

[19:26] <p6eval> rakudo 90637b: OUTPUT«Inf␤»

[19:26] <colomon> rakudo: say Inf * 0

[19:26] <p6eval> rakudo 90637b: OUTPUT«NaN␤»

[19:27] <pugssvn> r32061 | moritz++ | [t/spec] test for RT #70600, 0e9999999 

[19:29] * sorear hacks his copy of STD to increase the error limit from 10 to 10k

[19:29] <[Coke]> TimToady++

[19:30] <sorear> [Coke]: What did he do this time?

[19:30] * [Coke] is merely catching up in backscroll.

[19:30] <[Coke]> ... is there anything in here that monitors karma?

[19:31] <masak> sorear: because you really like errors?

[19:31] <sorear> buubot: karma TimToady

[19:31] <buubot> sorear: TimToady has karma of 312      

[19:31] <sorear> buubot: karma lwall

[19:31] <buubot> sorear: lwall has karma of 801      

[19:31] <masak> buubot: karma karma

[19:31] <buubot> masak: karma has karma of 4      

[19:31] <masak> buubot: karma 4

[19:31] <buubot> masak: 4 has karma of -329      

[19:31] <masak> o.O

[19:31] <masak> buubot: karma -329

[19:31] <buubot> masak: -329 has karma of       

[19:31] <tadzik> :D

[19:32] <masak> buubot: karma

[19:32] <buubot> masak:  has karma of       

[19:32] <masak> ok, we've reached Zen.

[19:32] <tadzik> :D

[19:32] <jnthn> buubot: karma dogma

[19:32] <buubot> jnthn: dogma has karma of 1      

[19:32] <masak> dogma++

[19:32] * masak puts some karma in his dogma

[19:32] <jnthn> EKARMARANOVERDOGMA

[19:32] <[Coke]> <monty python>There is noooooooooooooooooooooooo Perl six</>

[19:33] <masak> [Coke]: was that why you asked whether anything monitors karma? :)

[19:33] <[Coke]> masak: ha! no. just wondering if karming people mattered except warmandfuzzily

[19:35] <masak> I get the feeling that keeping count is mostly incidental to the warm and fuzzy part.

[19:35] <masak> but I might be wrong.

[19:36] * [particle] puts some llama in his karma

[19:36] <TimToady_> karming is more important than karma

[19:36] <mathw> Right

[19:36] <mathw> I've done aikido, I've had fish and chips, I've drunk a ridiculous amount of water and I'm ready to go

[19:36] * masak cheers mathw on

[19:37] <[particle]> well then, what are you doing here? /kick mathw

[19:37] <[Coke]> no programmers were karmed in the release of this software.

[19:37] <tadzik> they must be sad now

[19:37] <masak> sad llama in snow

[19:37] <TimToady_> First of all, do no karm.  --Hoppo Crates

[19:37] <tadzik> sad llama is sad

[19:37] <TimToady_> *Hippo

[19:38] * masak quickly patents the new llama meme

[19:38] <tadzik> I thought Hoppo is a pun

[19:38] <TimToady_> Hippo Hoppo Crates is someone else

[19:38] <masak> I thought his name was Groucho Crates.

[19:38] <[particle]> Harpo Crates

[19:38] <masak> Happy Happy Hippo Crates.

[19:38] <tadzik> Crapo Haters

[19:38] <masak> no wait, that's Hungry Hungry Hippo Crates.

[19:39] <mathw> Is anybody aware of any problems with the release?

[19:39] <colomon> mathw++

[19:39] <tadzik> is anyone aware of the release? :)

[19:39] <TimToady_> is anyone aware at all?

[19:39] <mathw> tadzik: the release hasn't happened yet, I'm about to do it

[19:39] <mathw> But now is the time to yell 'stop!!!'

[19:39] <mathw> but only if there's a reason

[19:39] <masak> mathw: I saw an odd failure in S03-operators/context.rakudo earlier today when spectesting.

[19:39] <tadzik> stop!... oh, ok

[19:40] <mathw> masak: did you fix it?

[19:40] <masak> mathw: of course not.

[19:40] <masak> I promptly forgot about it and moved on with my life.

[19:40] <masak> I'm only remembering it now.

[19:40] <mathw> pfft

[19:40] <mathw> useless

[19:40] <TimToady_> not having released it seems to be the largest problem :)

[19:40] * masak does the sad llama routine

[19:40] <mathw> TimToady_: Well I had to go to aikido, because if the release isn't right I'm going to have to defend myself :)

[19:40] <pmichaud> the context.t failure should be fixed after my delayed push of this morning

[19:41] *** TimToady_ is now known as TimToady

[19:41] <sorear> masak: Quite the opposite, the more I see at once the faster I can get rid of them

[19:41] <[particle]> is your git constipated?

[19:41] <pmichaud> mathw: if something goes wrong with the release, you're in good company :-)

[19:41] <mathw> pmichaud: :)

[19:42] * pmichaud runs a "make spectest" just to check

[19:42] <mathw> I'm almost kicking off a spectest run here

[19:42] <mathw> just waiting for it to build...

[19:42] <masak> fwiw, context.rakudo passes outside of the harness.

[19:42] <mathw> awesome

[19:42] <masak> so probably nothing to worry about.

[19:42] *** py[tab] left
[19:42] <pmichaud> (transitive ltm) -- fwiw, nqp-rx does manage to do transitive ltm in some cases :)

[19:43] <pmichaud> it just doesn't manage it in all of them yet.

[19:43] * mathw does "make spectest"

[19:43] <masak> if it doesn't do all of them, it's Not A Real Perl 6 Grammar Engine.

[19:43] <pmichaud> I don't know that any implementation is truly a Real Perl 6 Grammar Engine yet  :-)

[19:43] <mathw> Isn't that why it's called Not Quite Perl?

[19:43] <masak> that is correct.

[19:44] <masak> no wonder people complain about Perl 6 not being finished yet.

[19:44] <mathw> lol

[19:44] <pmichaud> heh

[19:44] <mathw> oh so we should've called it Bucket then?

[19:44] <masak> because it's... round?

[19:44] <pmichaud> so, while yapsi claims "complete and official",  nqp explicitly claims "not quite" and "not official"

[19:44] <mathw> Everybody say 'boo' for pmichaud's naming

[19:45] <mathw> 1/22 failed in S02-literals/numeric.t

[19:45] <masak> pmichaud: "not quite not official"

[19:46] <pmichaud> yes, I get a numeric.t failure also

[19:46] *** x3nU left
[19:46] <pmichaud> that feels new

[19:46] <mathw> good thing it's not just me

[19:46] *** azert0x left
[19:46] * pmichaud investigates.

[19:46] * mathw watches for other ones

[19:46] <pmichaud> I think it's a new test that was added that needs fudging.

[19:46] <mathw> this is the problem with me doing the release, I have to get other people to fix things :)

[19:47] <pmichaud> aha

[19:47] <pmichaud> #?todo 'RT 70600'

[19:47] <pmichaud> fudge fail

[19:47] <colomon> yup, needs fudge

[19:47] <mathw> OOI, what's the correct way to fudge

[19:48] <pmichaud> should be  #?rakudo todo 'RT 70600'

[19:48] <pugssvn> r32062 | pmichaud++ | [t/spec]:  Fix fudge in S02-literals/numeric.t  

[19:48] <mathw> aaah

[19:49] <pmichaud> to distinguish it from all of the other Perl 6 implementations, where it works already :-)

[19:49] <mathw> I knew fudging was implementation-specific, honest

[19:49] <PerlJam> mathw: the correct way to fudge is to get other people to do it :)

[19:50] <mathw> rofl

[19:50] <mathw> is 'get pmichaud to do it' the answer to everything tonight? :)

[19:50] <pmichaud> fwiw, "release manager" and "delegation" go well together

[19:50] <pmichaud> i.e., the release manager doesn't have to do all of the work; just needs to make sure the release goes out (correctly)

[19:50] <mathw> :)

[19:50] <mathw> I can do that

[19:50] <mathw> been doing a bit of this sort of thing at work lately too

[19:51] <mathw> but people keep changing the spec underneath me there :(

[19:51] <pmichaud> ...releases?

[19:51] <pmichaud> mathw: I know the feeling well.

[19:51] <pmichaud> (changing spec :-)

[19:51] <mathw> yeah, a bit of coordinating everything into a point where we can release it to the QA team or to internal customers or something

[19:52] <mathw> which is great, it's like "hey, why did you put this in what doesn't work? Fix it!"

[19:52] * mathw likes svn blame

[19:53] <mathw> not seen any more failures yet

[19:53] <mathw> forgot how big the spectest is

[19:53] <mathw> probably a lot bigger than it was last time I did one though

[19:55] *** shade_ joined
[19:55] *** prz joined
[19:58] <mathw> S05-modifier/ignorecase.rakudo dubious, test returned 1

[19:58] <tadzik> running various Perl 6 snippets of mine shows that today's Rakudo is from 2 to 20 times faster than 2010.06

[19:58] <pmichaud> \o/

[19:58] <mathw> well the ChangeLog mentions integer performance improvements

[19:58] <mathw> that is very awesome

[19:59] <pmichaud> I knew those delay loops I snuck into the 2010.06 release would prove helpful.  :-P

[19:59] <tadzik> almost everything's 2 times faster, 20 times faster is the code adding integers in a loop :P

[19:59] <tadzik> which is colomon++ and pmichaud++

[19:59] *** x3nU joined
[19:59] <colomon> final improvement is mostly pmichaud++'s.

[20:00] <colomon> oh, and he is particularly responsible for the fact that they're not just integer improvements, any Range iteration should be faster now.

[20:02] <mathw> eeww

[20:02] <mathw> I smell :(

[20:02] <mathw> straight in the bath after the release is done I think!

[20:03] *** Tene joined
[20:04] <PerlJam> mathw: sounds like you have good timing.  aikido, release, bath.  sounds cathartic.

[20:04] <mathw> yeah

[20:04] <mathw> aikido, bath is good enough

[20:04] <mathw> a rakudo release as well is almost unbearable

[20:04] <mathw> :)

[20:05] <pmichaud> only spectest failure I had was numeric.t, which is now working.

[20:05] <mathw> good

[20:05] <moritz_> yeah, I messed up the fudging

[20:05] <mathw> I'm in S32 tests at the moment

[20:06] <mathw> so we're looking good if nothing goes wrong here?

[20:06] <moritz_> sorry about that

[20:06] <mathw> I love how many trig tests there are

[20:06] <tadzik> hmm. Is it possible that a module was working well a month ago and it is not passing tests now?

[20:06] <mathw> yes

[20:06] *** azert0x joined
[20:07] <moritz_> tadzik: yes

[20:07] <ash_> i blame colomon++ for all the trig work, i am sure there are others i am missing though 

[20:07] <mathw> things do change

[20:07] <tadzik> I'm talking about Config::INI, it stopped parsing stuff. Is that expected/normal?

[20:07] <mathw> modules are quite susceptible to breaking iwth changes in Rakudo

[20:07] <moritz_> tadzik: have you removed all stray .pir files?

[20:07] <pmichaud> depends on whether it was relying on any bugs that are now fixed :-)

[20:07] <tadzik> moritz_: will check once again

[20:08] <moritz_> at least that's the most common reason for my modules to fail

[20:08] <mathw> yup

[20:08] <mathw> same here

[20:08] <tadzik> nah, this is something else

[20:09] <tadzik> and I remember it failing when I WAS SMOKE TESTING PERL6 MODULES :)

[20:09] <tadzik> (in case you didn't know/remember yet :))

[20:10] <tadzik> maybe it's time for a new test though

[20:10] <tadzik> before Star

[20:11] *** rjbs joined
[20:11] <rjbs> There's a question that's been nagging me for months, and I finally am going to just ask!

[20:12] *** sjohnson joined
[20:12] <[particle]> (false laziness)--

[20:12] <rjbs> The confusion of {hash} and {sub} is such a huge pain in Perl 5.  I know that it's slightly less of a pain in Perl 6, but I wonder why it wasn't solved more thoroughly.

[20:12] <mathw> right

[20:12] <[particle]> {} always means closure in perl 6

[20:13] <mathw> everybody happy with the release being cut now?

[20:13] <tadzik> yes!

[20:13] <masak> mathw: \o/

[20:13] <moritz_> but sometimes it's run immediatly

[20:13] <moritz_> mathw: +1

[20:13] <pmichaud> [particle]:   my $x = {};   

[20:13] <mathw> right then

[20:13] <moritz_> rjbs: I guess it has to do with not having enough bracing characters

[20:13] <rjbs> This first started to bug me when I read the Perl 6 cheat sheet, which shows %hash{'a'}

[20:13] <masak> pmichaud: I think what [particle] meant was what the spec says: that {} always means closure.

[20:13] <jnthn> rakudo: my $x = {}; say $x.WHAT;

[20:13] <p6eval> rakudo 90637b: OUTPUT«Hash()␤»

[20:14] <masak> pmichaud: some of them might evaporate into hashes, though.

[20:14] <pmichaud> well, the spec is misleading then.  :-)

[20:14] <masak> not really.

[20:14] <pmichaud> or at least quoting that part of the spec is misleading :)

[20:14] <masak> a hash is just a "special case" of a closure :)

[20:14] <x3nU> moritz_: using some strange unicode characters as bracklets would be a "good" idea ;d

[20:14] <masak> not a subclass, but a special case.

[20:14] <rjbs> moritz_: I thought about that, but there seem to be some bracing characters that could have been put to use for hash/closure as opposed to (say) qw.

[20:14] <rjbs> 16:14 <masak> a hash is just a "special case" of a closure :)

[20:14] <pmichaud> my $x = {}.();   

[20:14] <rjbs> ^ Intuition Fail!

[20:14] <mathw> testing the tarball

[20:14] <rjbs> mathw: Good luck!

[20:14] <pmichaud> rakudo: my $x = {}.();

[20:15] <p6eval> rakudo 90637b: OUTPUT«invoke() not implemented in class ''␤  in main program body at line 22:/tmp/5AP2C7WAiF␤»

[20:15] <pmichaud> {} is always a closure.... except when it's not.  :-)

[20:15] <rjbs> Right, and that has been such a source of irritation in Perl 5!  Is it just a "well, we want to stay Perlish"?

[20:15] <masak> rjbs: you may or may not have read http://use.perl.org/~masak/journal/40431 , where I talk a bit about this.

[20:16] <rjbs> Quite possible!

[20:16] <pmichaud> rjbs: I think it's a desire to retain the notion of "anonymous hash"

[20:16] <masak> rjbs: sumamry of that post: the fact that {} was used for both used to bother me in Perl 6, but nowadays I find the rules simple enough to follow, and it bothers me very little.

[20:16] <rjbs> You know, I think I did read that, and I felt unsatisfied. :)

[20:16] <masak> good to know :)

[20:16] <sorear> I for one would not be opposed to a :{} for hashes, {} for closures thing

[20:16] <mathw> it would be nice if there was another set of brackets on the keyboard for that

[20:17] <mathw> but it doesn't really bother me at all for some reason

[20:17] <moritz_> rjbs: I agree the that it's still confusing; however one thing has drastically improved, and that is that you never get a syntax error from soemthing that starts to be parsed as a hash, and then turns out to be a closure

[20:17] <rjbs> pmichaud: Right -- but I wondered why that wasn't (say) < ... >

[20:17] <rjbs> I do agree that it's a huge improvement.

[20:17] <pmichaud> well, < ... >   has a more useful meaning, I think.

[20:18] <pmichaud> I wonder if  %{ ... }   would work for an anonymous hash :-)

[20:18] <PerlJam> not using {} for hash constructionwould have just pushed things too far away from their perl-nature  ;)

[20:18] <moritz_> there's also   hash { ... }

[20:18] <moritz_> just like  sub { ... }

[20:18] <sorear> pmichaud: +1

[20:18] <pmichaud> one could get away with  %( ... )   for building an anonymous hash, but then it's not itemized

[20:18] <pmichaud> hash { ... }   fails, I think.

[20:19] <pmichaud> at least it fails if you're expecting { ... } to be a closure

[20:19] <masak> right, it's 'hash ...'.

[20:19] <moritz_> huh?

[20:19] <ash_> rakudo: my $a = {; }; say $a.WHAT;

[20:19] <p6eval> rakudo 90637b: OUTPUT«Block()␤»

[20:20] <pmichaud> moritz_: 'hash' is just a listop

[20:20] <pugssvn> r32063 | moritz++ | [t/spec] RT #75768, indexing a series with a series. Makes colomon++ unspeakably happy 

[20:20] <pmichaud> it doesn't impose any special interpretation on curlied arguments

[20:21] <rjbs> If I want a closure that returns a pair, I need to say something like: {; 1 => 2 }   ?

[20:21] <rjbs> (or add a return, or whatever)

[20:21] <sorear> Yes

[20:21] <ingy> greetings from boston

[20:21] <colomon> \o/

[20:21] <mathw> oh hai ingy

[20:21] <ash_> rakudo: say ({; a => 2 })().WHAT;

[20:21] <mathw> you're just in time for the release

[20:21] <p6eval> rakudo 90637b: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[20:21] <pmichaud> rakudo:  say { 1=>2; }.WHAT

[20:21] <p6eval> rakudo 90637b: OUTPUT«Hash()␤»

[20:21] <ingy> oh yeah?

[20:22] <pmichaud> hmmmm

[20:22] <ingy> * release or what?

[20:22] <pmichaud> I suspect that ought to be a closure.

[20:22] <sorear> +1 in favor of %(), btw

[20:22] <pmichaud> sorear: what about the flattening behavior?

[20:22] <rjbs> See!  Aren't you glad I came to whine :)

[20:22] <masak> we're always glad when people come to whine.

[20:22] <masak> that means they care.

[20:22] <moritz_> rjbs: yes; it's always good to ask questions

[20:22] <pmichaud> people are whining and dining us all the time :-)

[20:23] <ash_> rakudo:  say ({; 1=>2; }).WHAT, ' ', ({ 1=>2; }).WHAT

[20:23] <p6eval> rakudo 90637b: OUTPUT«Block() Hash()␤»

[20:23] <moritz_> well, there's productive whining, and annoying whining

[20:23] <mathw> THE TARBALL IS UP!

[20:23] <sorear> pmichaud: the only case I've seen where flattening of hashes is an issue is in Array.push, which IMO should be changed to take a (non flattening) parcel now that you can say push: |@list

[20:24] <pmichaud> sorear: my @a = { 1 => 2 };   my @b = %( 1 => 2);

[20:24] <masak> mathw++

[20:24] <sorear> Why are you assigning hashes to arrays in the first place?

[20:24] *** djburiedalive joined
[20:24] <masak> moritz_: just as there's productive dining, and annoying dining :P

[20:24] <pmichaud> I might want an array to contain a hashref

[20:25] <pmichaud> the first gives @a[0] a hash.  The second gives @a[0] a Pair.

[20:25] <mathw> I think I sent it from the right email address, so hopefully the announcement won't bounce off perl6-compiler

[20:25] *** djburiedalive left
[20:25] <pugssvn> r32064 | moritz++ | [t/spec] test for RT #74530, hyper ops and ranges should mix 

[20:25] <ash_> rakudo: ({; a => 1 })().WHAT.say # is a block that returns a pair

[20:25] <p6eval> rakudo 90637b: OUTPUT«Pair()␤»

[20:25] <moritz_> any volunteers for next month's release?

[20:26] <moritz_> mathw++ can tell you how easy it is :-)

[20:26] <pmichaud> rjbs: fwiw, you can always explicitly signify a block with ->

[20:26] <mathw> hee

[20:26] <mathw> that wasn't too bad

[20:26] <pmichaud> rakudo:   say (-> { a => 1 }).WHAT

[20:26] <p6eval> rakudo 90637b: OUTPUT«Block()␤»

[20:26] <rjbs> pmichaud: {; works just as well, doesn't it?

[20:26] <pmichaud> rjbs: sure.

[20:26] <mathw> just kind of nervous

[20:26] <rjbs> It's what I use in P5 and is shorter! :)

[20:26] <mathw> glad the procedure's all sorted out

[20:26] <ash_> pointy blocks let you have arguments though 

[20:27] <pmichaud> well, non-pointies allow that too :-)

[20:27] <ash_> rakudo: my $a = -> Int $foo { say 'int'; };  $a(1); $a('foo'); # but not type checking 

[20:27] <p6eval> rakudo 90637b: OUTPUT«int␤Nominal type check failed for parameter '$foo'; expected Int but got Str instead␤  in <anon> at line 2:/tmp/ZxUDeUZ__i␤  in main program body at line 22:/tmp/ZxUDeUZ__i␤»

[20:28] <ash_> well, you could do your type checking in the block i guess

[20:28] <ash_> but thats no fun 

[20:28] <pmichaud> right, that would be +Ofun I guess.

[20:28] <ash_> is there a way for making an anonymous multi? 

[20:28] <moritz_> rakudo: use Test

[20:28] <p6eval> rakudo 90637b:  ( no output )

[20:29] <masak> rakudo: { die "AAARH!" unless $^a ~~ Str; say $^a }.($_) for "OH LOL", 42

[20:29] <moritz_> ash_: how would you add candidates?

[20:29] <p6eval> rakudo 90637b: OUTPUT«OH LOL␤AAARH!␤  in <anon> at line 22:/tmp/jdqlXX4ya4␤  in main program body at line 22:/tmp/jdqlXX4ya4␤»

[20:29] <ash_> like, anon multi sub Int $a { }, sub Str $a { };  

[20:29] <ash_> moritz_: *scratches head* beats me 

[20:29] <jnthn> No, though folks ask now and then

[20:29] <masak> anonymous multies? that's crazy talk.

[20:29] <mathw> oh by the way

[20:30] <moritz_> with cheating, you can do   do { multi a() { ... }; multi a($x) { .. }; &a }

[20:30] <jnthn> But since they're lexical, you could easily make a sub that constructs and returns anon multis.

[20:30] <mathw> oh ignore me, I just answered my own question

[20:30] <jnthn> Or that.

[20:30] <jnthn> :-)

[20:30] <moritz_> or

[20:30] <mathw> I'm goin gto have some cider instead

[20:30] <masak> maybe create an anon proto, and add variants to it through some method on the routine?

[20:30] <colomon> cider++

[20:30] <moritz_> my $x = anon multi foo() { }; $x.push(anon multi foo($x) { ... })

[20:30] <moritz_> or was it .candidates.push? not sure

[20:31] <moritz_> but we have a method API

[20:31] <moritz_> mathw: I've received your p6c mail, so no problem here

[20:31] <jnthn> Cider. It's like apple beer.

[20:31] <mathw> moritz_: awesome

[20:31] <mathw> all done then

[20:31] * moritz_ -> bed

[20:31] <ash_> multi sub (Int $a) { ... } and sub (Str $a) { ... }; 

[20:32] <jnthn> moritz_: Something like that. But if we give people a way to modify the candidate list dynamically, they'll get a surprised when discovering that the optimizer did stuff 'cus it didn't know about their added candidates.

[20:32] *** javs left
[20:32] <jnthn> Or put another way, we probably only want to allow it with a pragma.

[20:32] <tylercurtis> jnthn: perhaps a trait?

[20:32] <ash_> my $foo = multi sub (Int $a) { ... } and sub (Str $a) { ... }; $foo(1); $foo('a'); 

[20:33] <jnthn> tylercurtis: Well, pragma would be anal. to MONKEY_TYPING

[20:33] <masak> jnthn: please don't abbreviate 'analogous' that way. :/

[20:33] <ash_> std: my $foo = multi sub (Int $a) { ~$a } and sub (Str $a) { +$a }; $foo(1); $foo('a'); 

[20:33] <p6eval> std 32064: OUTPUT«ok 00:01 121m␤»

[20:33] <mathw> yes

[20:33] <mathw> please

[20:34] <jnthn> masak: I couldn't remember if it was an "o" or an "a" after the l :P

[20:34] <jnthn> I concede a spelling mistake woulda been better... :-)

[20:34] <masak> jnthn: either one is better.

[20:34] <masak> jnthn: mnemonic: analog clocks

[20:35] <jnthn> :P

[20:35] <tylercurtis> jnthn: yes, but I think you're more likely to just want to pessimize one multi than all multis in a scope.

[20:35] <ash_> multi sub (Int $a) { ~$a } and sub (Str $a) { +$a } and sub ($a) { 'others' };

[20:35] <jnthn> tylercurtis: Yeah, true.

[20:36] <jnthn> OTOH, you often only want to monkey with a couple of types too...

[20:36] <jnthn> ash_: Did you steal that from ML? :-)

[20:36] <masak> ash_: not sure infix:<and> should be mis-used in that way... outside of a pragma.

[20:36] <ash_> no, i don't know ml 

[20:36] <jnthn> ash_: ah, it uses something like it for 

[20:36] <jnthn> grr

[20:36] <ash_> masak: i know, i was just looking for an infix:<op> that made sense and passed std :P 

[20:36] <jnthn> *for mutually recursive functions

[20:37] <masak> ash_: infix:<|> feels less wrong to me than infix:<and>.

[20:37] <masak> still wouldn't want that functionalirt in core Perl 6, though.

[20:37] <tylercurtis> With MONKEY_TYPING, you still have to specify when a class declaration is supposed to be monkeying around with augment or supersede.

[20:37] <jnthn> True

[20:37] <pmichaud> my $foo = Multi.new( sub (Int $a) { ... }, sub (Str $b) { ... })

[20:37] <masak> ash_: you can already do infix:<|> on routine signatures.

[20:37] <jnthn> oh

[20:38] <jnthn> That's not bad

[20:38] <jnthn> Then we could declare tha Multi is immutable once created.

[20:38] <masak> pmichaud++

[20:38] <ash_> don't take my suggestion to seriously, i was more toying with std 

[20:38] <jnthn> And be happy

[20:38] <masak> std: multi sub foo (Str $a, Int $b) | (Int $a, Str $b) { ... }

[20:38] <pmichaud> or that one can create new multis from existing ones

[20:38] <p6eval> std 32064: OUTPUT«Potential difficulties:␤  $b is declared but not used at /tmp/wBnnRpbog0 line 1:␤------> [32mmulti sub foo (Str $a, Int [33m⏏[31m$b) | (Int $a, Str $b) { ... }[0m␤  $a is declared but not used at /tmp/wBnnRpbog0 line 1:␤------> [32mmulti sub foo (Str [33m⏏[31m$a, Int $b) |

[20:38] <p6eval> ..(…

[20:38] <masak> hrm.

[20:38] <masak> std: multi sub foo (Str $a, Int $b) | (Int $a, Str $b) { say $a, $b; }

[20:38] <pmichaud> i.e., Multi.new could know what to do with other Multis as arguments

[20:38] <p6eval> std 32064: OUTPUT«ok 00:01 122m␤»

[20:39] <ash_> std: multi sub (Str $a, Int $b) | (Int $a, Str $b) { say $a, $b; }

[20:39] <p6eval> std 32064: OUTPUT«ok 00:01 121m␤»

[20:39] <ash_> thats kinda weird though, since there is only one { } block 

[20:39] <ash_> std: multi sub foo (Str $a, Int $b) { say $a, $b; }  | (Int $a, Str $b) { say $a, $b; }

[20:39] <p6eval> std 32064: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/_k2EOa2puT line 1:␤------> [32mStr $a, Int $b) { say $a, $b; }  | (Int [33m⏏[31m$a, Str $b) { say $a, $b; }[0m␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse

[20:39] <p6eval> ..failed␤FAILED 00:0…

[20:40] <ash_> i think Multi.new is the current logical solution, :P 

[20:41] <masak> +1

[20:41] <jnthn> +2

[20:41] <ash_> anyway, back to hacking on the try.rakudo.org backend 

[20:41] <jnthn> \o/

[20:41] <masak> ash_++

[20:41] <tadzik> ash_++

[20:42] <ash_> its a lot hard to manage multiple processes with a single daemon than i originally thought... 

[20:43] <tadzik> ash_: did you thought about keeping a pipe to a REPL instead of writing to a file and executing it?

[20:43] <mathw> process management is horrible

[20:44] <pmichaud> http://gist.github.com/538865  # jnthn, any ideas about how to make this (abridged) codepath faster?

[20:44] <ash_> tadzik: ya, thats the only way to do it properly, i have a POE server that spawns sub processes now, each new connection to the server makes a new subprocess that lasts as long as the session, once the session dies the sub process is killed

[20:44] <ash_> its about 80% done, then i need to test it 

[20:44] <tadzik> awesome!

[20:45] <pmichaud> essentially, that's the code generated for      token ws { <?MARKED('ws')> }

[20:45] <jnthn> pmichaud: Looking.

[20:46] <pmichaud> (I took it from the original "token ws" rule and cut out the parts that aren't on the <?MARKED...> codepath

[20:46] <pmichaud> and of course, by 'faster' I mean 'significantly faster'

[20:47] <sorear> What does <? do?

[20:47] <pmichaud> zero-width positive assertion

[20:47] <pmichaud> invokes the subrule, and passes if the subrule passes

[20:47] <sorear> oh, right, d'oh

[20:47] <pmichaud> (but doesn't consume any characters)

[20:49] <pmichaud> and actually, the code that normally gets executed is only down to the 'debug_401:' label

[20:49] <pmichaud> i.e., we never reach anything after the first .return (rx70_cur)

[20:49] <jnthn> pmichaud: Remind me what the four things taht cursor_start returns are?

[20:50] <pmichaud> a new cursor 

[20:50] <pmichaud> the current position

[20:50] <pmichaud> the target string

[20:50] <pmichaud> I forget what $I10 is -- probably "are we scanning or anchored"  or something like that

[20:50] <jnthn> unused here anyway I guess

[20:50] <pmichaud> right

[20:52] <pmichaud> I might be able to move/postpone the target string setup that takes place at     substr rx70_tgt, rx70_tgt, rx70_off

[20:52] <pmichaud> but I can't see that having a significant impact on execution time.

[20:52] <pmichaud> oh yes,  $I10 is whether we're invoking the rule for the first time or whether we're backtracking into the rule (which we never do in this case)

[20:52] <masak> mathw++ # release announcement on p6c!

[20:52] <pmichaud> mathw++ # excellent -- nice and quick!

[20:53] *** perlygatekeeper1 joined
[20:53] <mathw> I still haven't got it :(

[20:53] <jnthn> pmichaud: What came of the proposal to have the string equal at... op?

[20:53] <mathw> but now it's time for my bath

[20:53] <jnthn> That'd avoid a string header...

[20:53] <mathw> goodnight all

[20:53] <mathw> thanks for the support and assistance

[20:54] <PerlJam> mathw++

[20:54] <jnthn> mathw++ # thanks for doing the release 

[20:54] <pmichaud> jnthn: I tried it in a branch, and it resulted in a <0.1% improvement

[20:54] <jnthn> Wow.

[20:54] <mathw> oh and looking at my schedule... I can do next month as well

[20:54] <pmichaud> it's possible I got that part wrong.

[20:54] <jnthn> That...surprises me a little.

[20:54] <jnthn> But OK.

[20:54] <pmichaud> it surprised me a lot

[20:54] <pmichaud> here's what I'm looking at for this particular case

[20:54] <jnthn> pmichaud: I mean, every run through we're doing ~ 3 method calls.

[20:54] <pmichaud> when I run the parser on NQP/Actions.pm

[20:55] <pmichaud> I get timings that look like

[20:55] <sorear> I'd be very suspicious of that small a result

[20:55] *** perlygatekeeper left
[20:55] <sorear> Wait

[20:55] <sorear> Was substr_eq_at provided in _s_sc_i or only _s_s_i?

[20:55] <jnthn> I figure that !cursor_start, !cursor_pass, !cursor_pos and MARKED don't go making other pricey calls?

[20:55] <pmichaud> jnthn: I've tried to make them as efficient as I could, yes.

[20:55] <jnthn> sorear: It'd generate the SC version unless they went to effort to make it not do so

[20:55] <pmichaud> sorear: I'm suspicious also.

[20:56] <pmichaud> it was  _s_sc_i

[20:56] <pmichaud> anyway

[20:56] <pmichaud> I get

[20:56] <pmichaud> ws                                      :  6700   1.4943  6700   1.4943     0   0.0000

[20:56] <jnthn> pmichaud: Yeah. I mean, without making all the primitives here cheaper, or inlining, it's hard to see what to do.

[20:56] <pmichaud> which tells me that 6700 calls to ws took 1.4943 seconds

[20:56] <jnthn> Ouch

[20:56] <jnthn> That feels...more than it should be.

[20:56] <pmichaud> that includes the cost of debugging and tracing

[20:56] <jnthn> ah, OK

[20:56] <pmichaud> but relatively speaking, that should be constant

[20:57] <jnthn> What % overhead did we get from debugging/tracing, ooc?

[20:57] <pmichaud> more to the point, those 6700 calls to ws took more time than anything else

[20:57] <jnthn> More than any other rule?

[20:57] <pmichaud> yes.... but now I see the problem.

[20:57] <jnthn> Because of the call volume?

[20:57] <pmichaud> the debugging/tracing is likely swamping the noise

[20:57] <pmichaud> right, because of the call volume

[20:57] <jnthn> Or even when you factor it out?

[20:57] <jnthn> OK

[20:57] <pmichaud> I don't know how to factor it out.

[20:57] <jnthn> Well, I mean

[20:58] <jnthn> If you divide the number of calls into the time we spend in ws

[20:58] <tadzik> will there be anyting on p6u and rakudo.org?

[20:58] <jnthn> Is it a relatively expensive rule

[20:58] <dalek> niecza: b284300 | sorear++ | / (2 files):

[20:58] <dalek> niecza: Add an option to generate self-contained executables

[20:58] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b2843009aa80a3b87853b7e926c61ccd44d9d14e

[20:58] <jnthn> Or is it just pure volume?

[20:58] <pmichaud> I'm guessing here it may be just pure volume

[20:58] <jnthn> OK

[20:58] *** ash_ left
[20:58] *** wamba left
[20:59] <jnthn> I mean, we know that method lookup and attribute lookup are going to get cheaper.

[20:59] <pmichaud> if I do the division, I get 0.000222 second per call

[20:59] <jnthn> But that's probably not until October.

[20:59] <pmichaud> (that's including tracing overhead)

[20:59] * jnthn gets curious how MARKED works

[20:59] <pmichaud> it just looks up values in a hash and returns true/false

[20:59] * [particle] wonders what the tracing overhead is

[21:00] <pmichaud> but more to the point, I can look at the trace output itself and determine that 0.000076 seconds for this code path is in ws itself, and not in Marked

[21:00] *** prz left
[21:00] *** ash_ joined
[21:00] <pmichaud> or, put another way, by looking at the trace output, I can see that this code path takes 0.000109 seconds

[21:00] <jnthn> Ah, OK

[21:00] <jnthn> MARKED unconditionally calls debug, fwiw

[21:00] <jnthn> (!cursor_debug)

[21:01] <jnthn> Rather than checking if it should.

[21:01] <pmichaud> ah, you're correct.

[21:01] *** whiteknight joined
[21:01] <pmichaud> anyway, that's unchanged in this thought experiment :-)

[21:01] *** perlygatekeeper1 left
[21:01] <pmichaud> anyway, this code path takes 0.000109 seconds

[21:02] <pmichaud> this is the *optimal* code path -- i.e., we call the <.ws> rule and immediately discover that we're at the end of a <ws> sequence and don't need to check further

[21:02] *** Guest23195 left
[21:02] <jnthn> pmichaud: Also in MARKED and MARKER you might save some runloop overhead using the vivify op

[21:02] <jnthn> or fetch

[21:02] <jnthn> Whichever one it was

[21:02] <jnthn> For the global %!MARKED

[21:03] <jnthn> er

[21:03] <jnthn> %!MARKHASH

[21:03] <jnthn> pmichaud: Could that become an attribute in the future?

[21:03] <pmichaud> sure, or a dynlex

[21:03] <pmichaud> more likely a dynlex, it's per-compilation-unit.

[21:03] <jnthn> attributes we're going to be able to lookup by index, I expect

[21:03] <pmichaud> STD has it as a dynamic var.

[21:03] <jnthn> dynlexes are EWW for performance 'cus you have to go chasing down the lexpads for 'em.

[21:03] <pmichaud> so we're a little constrained.

[21:04] <jnthn> That doesn't make it a good idea.

[21:04] <pmichaud> I might be able to optimize it into an attribute, yes.

[21:04] <jnthn> Is the rest of ws maybe the more expensive bit?

[21:04] <pmichaud> no, I can time the execution of *this* codepath.

[21:05] <jnthn> $P1 = self.'pos'() # where's this defined, oc?

[21:05] <jnthn> *ooc

[21:05] <pmichaud> 'pos' is a method on the cursor object.

[21:05] <pmichaud> you're straying from my question, though.

[21:06] <jnthn> pmichaud: aye, I'm just trying to grok the bigger picture here

[21:07] *** justatheory joined
[21:08] <pmichaud> what I'm seeing is that exclusive of the calls to MARKER, this codepath requires 0.000072 seconds per execution

[21:08] <jnthn> rakudo: say  0.000072 / 0.000109

[21:08] <p6eval> rakudo 90637b: OUTPUT«0.660550458715596␤»

[21:09] <pmichaud> more to the point:

[21:09] <jnthn> So we spend 66% of our time in the stuff other than int he call to MARKED?

[21:09] <pmichaud> rakudo:  0.000072 * 6700

[21:09] <p6eval> rakudo 90637b:  ( no output )

[21:09] <pmichaud> rakudo:  say 0.000072 * 6700

[21:09] <p6eval> rakudo 90637b: OUTPUT«0.4824␤»

[21:10] <pmichaud> that's debug-inclusive time, of course, but more to the point, the overall (debug) time needed to process the file was 10.5 seconds

[21:10] <pmichaud> so fully 0.5 seconds (5%) of the time was spent in this codepath

[21:11] <pmichaud> (I'm rounding a bit there)

[21:11] <pmichaud> rakudo:  say 0.4824 / 10.6

[21:11] <p6eval> rakudo 90637b: OUTPUT«0.0455094339622642␤»

[21:11] <pmichaud> 4.5% 

[21:11] <pmichaud> in this codepath, *exclusive* of the call to MARKED

[21:12] <pmichaud> the calls to MARKED added another 0.24 seconds on top of this

[21:12] *** ash_ left
[21:12] <pmichaud> 20:59  * [particle] wonders what the tracing overhead is

[21:12] <jnthn> pmichaud: substr rx70_tgt, rx70_tgt, rx70_off # we don't seem to use this in the code MARKED code path?

[21:12] <pmichaud> jnthn: right -- as I said, I could potentially delay that

[21:13] <pmichaud> i.e., to do that only when we're about to do an operation that requires inspecting the target

[21:13] <pmichaud> (i.e., when we don't follow this codebath)

[21:13] <pmichaud> *codepath

[21:13] <pmichaud> I'm just thinking that can't be a significant part of the overhead.

[21:13] <jnthn> I can't imagine asking for a string's length is expensive either, though.

[21:14] <pmichaud> yes, that should be almost instantaneous, since we keep the length around

[21:14] <jnthn> Right.

[21:14] <jnthn> And the rest is just integer comparrisions and branches, which should also be almost instantaneous.

[21:14] <jnthn> Well, and assings and so on, but still, all just integer arithmetic

[21:14] <jnthn> *assigns

[21:14] <pmichaud> okay

[21:15] <pmichaud> I think that answers my questions a bit (more)

[21:15] *** ruoso left
[21:15] <pmichaud> I'll go back and double-check the remaining methods that we call to see if they're slowing things down

[21:16] <pmichaud> but unless there's something there that's unnecessarily slow, it looks like the bulk of the time is method call overhead, and the only real option for improving this is to avoid method calls as much as possible (even if it violates encapsulation)

[21:17] <pmichaud> ...or wait for method call times to improve :)

[21:17] <pmichaud> here's an example trace:

[21:18] <pmichaud> 1282248378.766728 19/0 START    ws

[21:18] <pmichaud> 1282248378.766764 19/0 START    MARKED name=ws

[21:18] <pmichaud> 1282248378.766801 19/0 PASS     MARKED

[21:18] <pmichaud> 1282248378.766837 19/0 PASS     ws at pos=19

[21:18] <jnthn> pmichaud: Thing is, every time we do !cursor_start, we do $P0 = lang.'HOW'() which in turn goes and does a hash lookup

[21:18] * sorear has a 389K Hello.exe which runs in 1.56 seconds, does anyone care?

[21:18] <pmichaud> sorear: sounds about as fast as rakudo!  :-)

[21:19] <jnthn> pmichaud: That's going to end up being a dynop that does a pointer follow and an index and is done.

[21:19] <pmichaud> jnthn: ultimately, that's probably going to end up having to be   self.'new'()  though

[21:19] <jnthn> pmichaud: That's just one place where we're paying for P6object layering on Parrot's object model today rather than being "natively" implemented.

[21:19] <pmichaud> or something .'new'()

[21:19] <sorear> pmichaud: but rakudo doesn't have a --gen-app Hello.exe option. :)

[21:19] <jnthn> pmichaud: Ultimately you won't want it written in PIR.

[21:20] <jnthn> pmichaud: Because hard-coded integer v-table offsets will be a nightmare headache. ;-)

[21:20] <[particle]> all it does is say "hello, world!", but you can change the grammar at runtime.

[21:20] <[particle]> :)

[21:20] <pmichaud> jnthn: well, sure.  My point is that Cursor creation is going to need to go through the standard build sequence.

[21:20] <jdv79> i thought the reason to use parrot's implementation was to make it more inter-language friendly, no?

[21:20] <jnthn> pmichaud: Oh, I totally agree.

[21:20] <pmichaud> if that's faster, then \o/

[21:20] <jnthn> pmichaud: The point is I think that sequence can be fast.

[21:20] <pmichaud> I very much look forward to it :)

[21:21] <jnthn> Anyway, I think we're drowning in overhead there rather than doing anything inherently inefficeint.

[21:21] <jnthn> Having a JIT to churn through those integer ops would be wonderful too of course.

[21:22] <jnthn> But I suspect the real overhead is in dispatch-y stuff.

[21:22] <pmichaud> any suggestions how I could improve the lang.'HOW'() create-an-object part?

[21:22] <pmichaud> i.e., would it be a Win to avoid that call altogether somehow?

[21:22] <jnthn> Don't think we have a way without breaking encapsulation of P6object right now.

[21:22] <jnthn> Well, wait

[21:23] <pmichaud> I don't mind if we break P6object encapsulation, if it's a big enough Win.

[21:23] <jnthn>     $P0 = lang.'HOW'()

[21:23] <jnthn>     parrotclass = getattribute $P0, 'parrotclass'

[21:23] <jnthn>     cur = new parrotclass

[21:23] <jnthn> Oh...grr...no

[21:23] <jnthn> hnag on, let me check something

[21:24] <masak> hey, it never struck me before: DESTROYALL submethods will usually be called with little or no memory left.

[21:24] <pmichaud> .sub 'HOW' :method :nsentry $P0 = typeof self $P1 = getprop 'metaclass', $P0 .return ($P1)

[21:24] <masak> (from a discussion on #parrot)

[21:24] <pmichaud> .end

[21:24] <pmichaud> looks like .'HOW' is fairly efficient already. 

[21:25] <jnthn> pmichaud: It is, it's just the overhead of having to do a method call.

[21:25] <jnthn> pmichaud: And a hash lookup

[21:25] <pmichaud> maybe worth inlining here, since !cursor_start gets called An Awful Lot?

[21:25] <jnthn> pmichaud: Rahter than having it a pointer or so away

[21:25] <jnthn> pmichaud: Well, it'd save a method call and thus a Context PMC for every time we call !cursor_start

[21:26] <pmichaud> okay.

[21:26] <pmichaud> I'll look into that also.

[21:26] <jnthn> pmichaud: Though this will end up as a dynop "get_how" or some such.

[21:26] <pmichaud> At the moment I'm surprised at how much method call overhead seems to dominate parsing.

[21:26] <[particle]> jnthn, pmichaud:  is there a timeline on when a new parrot mop might be done? one of the cardinal folks is wondering, since the object model is where they're hung up

[21:26] <pmichaud> I would've expected the parsing itself to be more costly.

[21:26] <jnthn> Just about all the calls we ever make are on the invocant though?

[21:27] <pmichaud> I don't understand the question.

[21:27] <[particle]> they can't subclass parrot;Class

[21:27] <pmichaud> [particle]: oct/nov, I think.

[21:27] <jnthn> [particle]: Aiming for Oct.

[21:27] <pmichaud> jnthn: if you're asking if most of the calls are on self, then no.

[21:28] <jnthn> pmichaud: Oh?

[21:28] <pmichaud> most of them are on the cursor object returned by !cursor_start

[21:28] <jnthn> pmichaud: How much can we statically know about the type of that?

[21:28] <pmichaud> very little.

[21:28] <jnthn> oh damm. :-(

[21:28] <jnthn> That sucks.

[21:28] <pmichaud> in general we can probably assume that it's the same type as self, though.

[21:29] <jnthn> Yeah, but it's knowing when we can't...

[21:29] <treed> also, jnthn I am here too

[21:29] <treed> er, [particle] 

[21:29] <pmichaud> cursor_start expects to return the same type of cursor as the invocant

[21:29] <pmichaud> and only does otherwise if :lang is specified

[21:29] <pmichaud> and since we know that :lang isn't being specified here, we could assume 'self'

[21:29] <[particle]> oh, look at that :)

[21:29] <jnthn> Aha

[21:30] <treed> (and highlighted on "cardinal")

[21:30] <jnthn> pmichaud: OK. The short story is, the more we know about the type of the thing we're calling on, the more likely we can dispatch it by v-table lookup.

[21:30] <pmichaud> jnthn: got it.

[21:30] <jnthn> pmichaud: That is, the model I'm designing actually takes gradual typing seriously.

[21:30] <tadzik> treed: you are the Ruby on Parrot guy?

[21:30] <treed> More or less.

[21:30] <jnthn> pmichaud: And deeply.

[21:30] <jnthn> pmichaud: Same for representation polymorphism.

[21:30] <treed> I haven't done much lately, due to being blocked on the object model.

[21:30] <Tene> tadzik: He's the last guy to work on it.  Before him, it was me.

[21:31] <treed> There are some others who've worked on it too.

[21:31] <tadzik> I see. Anything new in it? It didn't work last time I took a look

[21:32] <jnthn> treed: I'm very hopeful that what I'm working on will give you the flexibility to implement the model you need.

[21:32] <jnthn> treed: In a sense, if it doesn't, I've got it wrong.

[21:32] <treed> Heh.

[21:32] <jnthn> *I'll have got it...

[21:32] *** patrickas joined
[21:32] <treed> If you want to chat sometime about how the Ruby object model works, let me know.

[21:32] <pmichaud> jnthn: thanks for the review -- it helps a ton.

[21:32] <jnthn> Yes, that would be helpful.

[21:32] <jnthn> pmichaud: Really? I didn't feel so helpful. :-)

[21:32] <jnthn> pmichaud: Or at least, didn't have a good "this is how" answer. :-)

[21:33] <pmichaud> I was more looking for confirmation that I wasn't overlooking an obvious expensive step.

[21:33] *** drbean joined
[21:33] <jnthn> pmichaud: cursor_start does a lot of shuffling stuff around that is just more pricey than it really should be ATM.

[21:34] <jnthn> pmichaud: It's not that it's badly written so far as I can tell.

[21:34] <pmichaud> well, it's just binding attributes for the most part.

[21:34] <jnthn> pmichaud: Just the primitives it's built on.

[21:34] <jnthn> Right

[21:34] <sorear> treed: I however would love to hear about more object models.

[21:34] <jnthn> treed: Yes, that'd be good to know.

[21:35] <Tene> treed: I'm also interested in being around for that conversation.

[21:35] * tylercurtis also.

[21:35] <Tene> It's storytime with treed!

[21:35] <jnthn> :-)

[21:35] * pmichaud grabs milk and cookies.

[21:35] * jnthn grabs beer...what's new... ;-)

[21:35] <treed> Heh.

[21:36] <treed> So every ruby object is an instance of an anonymous class, called its eigenclass.

[21:36] * masak grabs an object. have something concrete to refer to during the story.

[21:36] <treed> Which is derived from what you thought you said to derive the object from.

[21:36] <masak> treed: one unique eigenclass per object?

[21:37] <masak> by the way, are we allowed to interrupt? :)

[21:37] <treed> just a sec

[21:37] <treed> (work calls)

[21:38] <treed> And, yeah, one unique eigenclass per object.

[21:38] <treed> IIRC eigen- means self-

[21:38] <sorear> So, "hello world"

[21:39] <sorear> That's a string object?

[21:39] <masak> ja, eigen- means self-

[21:39] <sorear> And it has an eigenclass, which is not shared with any other string in the system?

[21:39] <treed> I think so, although I suspect that eigenclasses may not actually be created until used.

[21:39] * sorear knows essentially nothing about Ruby-the-language

[21:40] <treed> You can add methods to any given object.

[21:40] <treed> ANd when you do, they're added to the eigenclass.

[21:40] <treed> It would surprise me if the eigenclass actually existed until that point.

[21:40] <sorear> so it's essentially a prototype OO system?

[21:40] <treed> (I was going to implement it like that. Creating it on the fly as needed.)

[21:40] <treed> Kinda, yeah.

[21:41] <treed> So each class also has a metaclass, which is where class methods and data go.

[21:41] <jnthn> treed: http://www.klankboomklang.com/2007/09/21/the-singleton-class/ suggests that it's done lazily

[21:41] <masak> so, eigenclass != metaclass in Ruby?

[21:41] <sorear> Can you give an example of a simple user-defined class?

[21:41] <treed> class Foo

[21:41] <treed> def bar

[21:41] <treed> puts 'hi'

[21:41] <treed> end

[21:42] <treed> masak: Nope.

[21:42] <masak> they're the same?

[21:42] <treed> http://ruby-doc.org/ruby-1.9/classes/Class.html

[21:42] <treed> Er.

[21:42] <masak> rakudo: class Foo { method bar { say 'hi' } }; Foo.new.bar

[21:42] <treed> that was an agreeing nope.

[21:42] <p6eval> rakudo 90637b: OUTPUT«hi␤»

[21:42] <masak> aha.

[21:42] <treed> That has a diagram of classes and metaclasses at the basic level

[21:42] <treed> so each class has a metaclass and a superclass.

[21:42] <treed> And metaclasses have superclasses of their own.

[21:43] <treed> Ultimately leading to BasicObject.

[21:43] <treed> (Which is new in 1.9)

[21:43] <tylercurtis> Do metaclasses also have metaclasses?

[21:43] <treed> Nope.

[21:44] <jnthn> Oh no, no strange loops. :-)

[21:44] <jnthn> masak will be disappointed. :-)

[21:44] <treed> Heh.

[21:44] <masak> 'the buck stops here'.

[21:44] <Tene> Aren't metaclasses instances of Class?

[21:44] <treed> Yes.

[21:44] <Tene> So they just all have the same metaclass (Class)

[21:44] <masak> jnthn: I'm used to being disappointed in that way. most systems are depressingly non-loopy.

[21:44] <treed> Ultimately.

[21:45] <Tene> Yeah, from that document, "All metaclasses are instances of the class `Class’. "

[21:45] <treed> So, then I guess they could have a metaclass.

[21:45] <treed> In that way.

[21:45] <treed> Agh.

[21:45] <treed> Yeah.

[21:46] <treed> So, now imagine this, only for each thing, I also have to have a parrot thing.

[21:46] <Tene> I don't know that that's any more or less meta-

[21:46] <sorear> treed: How many addressable objects does your class statement create?

[21:46] <treed> And you understand why I got stuck on complication.

[21:46] <treed> sorear: Hm.

[21:46] <treed> Addressable?

[21:46] <sorear> The class, the metaclass, the class' eigenclass, the metaclass' eigenclass, ...?

[21:46] <sorear> can be assigned to a variable

[21:46] <treed> two, I think

[21:47] <treed> You can't assign an eigenclass to a variable.

[21:47] <sorear> more objects could be created behind the scenes

[21:47] <treed> Sure.

[21:47] <treed> The class is addressable, and the metaclass, via Class.class

[21:47] <masak> the eigenclass isn't first-class? :)

[21:47] <treed> Heh.

[21:47] <treed> Most people never even realize that it exists. :-P

[21:47] <treed> I've certainly never used it.

[21:48] <treed> I didn't even know about it until I started working on Cardinal.

[21:48] <masak> man, we should demote junctions before people start realizing that they exist... :)

[21:48] <sorear> btw I'm planning to make junctions non-addressable in Niecza, at least to start

[21:48] <Tene> sorear: eigenclasses aren't made until you try to define instance-specific behavior.

[21:49] <sorear> in Rakudo, class Foo { } creates two addressable objects - Foo (aka Foo.WHAT) and Foo.HOW

[21:49] <Tene> So just defining a class doesn't create any eigenclasses.

[21:49] <sorear> also Foo.WHO, but that's not really part of the object system

[21:49] <jnthn> Tene: That correlates nicely with what I'm reading.

[21:49] <treed> Yeah, I think that's also the case with Ruby.

[21:49] <treed> You get a class placed in a namespace

[21:49] <sorear> (Foo.WHO is the name of the implicit namespace created to hold our variables inside the class body)

[21:50] <treed> and the metaclass which is accessible via Class.class

[21:50] <jnthn> treed: If you like, when I get further along, I could maybe take a crack at an implementation of the core of this.

[21:50] <treed> I don't think it creates anything else until you use the eigenclass.

[21:50] <treed> jnthn: That'd be neat.

[21:50] <Tene> So how do you define class methods in ruby?

[21:50] <masak> treed: non-related question. sometimes I read on Twitter that people think that Ruby is the actual Perl 6. what is your view on this?

[21:50] <treed> I'm so burned out on getting it to work.

[21:50] <jnthn> treed: It'd be an interesting model test.

[21:50] <treed> class Foo

[21:50] <treed>  def Foo.class_method

[21:50] *** whiteknight left
[21:50] <treed>  end

[21:50] <treed> end

[21:50] <treed> masak: Drugs?

[21:50] <masak> treed: :D

[21:50] <jnthn> treed: Yes, I can imagine this is hard to model with current Parrot.

[21:50] <masak> treed++

[21:51] <treed> I kinda view Ruby as a hybrid between Python and Perl.

[21:51] <tylercurtis> Doesn't def self.class_method work also inside the class?

[21:51] <Tene> jnthn:  it wouldn't be so bad if you could instantiate subclasses of Class

[21:51] <jnthn> treed: I very much hope to make things better.

[21:51] <treed> But it's definitely more Pythonic than Perlish.

[21:51] <masak> I'll answer that next time. "I'm sorry, but are you high?"

[21:51] <treed> jnthn: The code exists on github in a branch if you want to see my current attempt.

[21:51] <treed> It's... ugly.

[21:51] <jnthn> Tene: Yes, classes ended up less first-class in Parrot that I'd kinda hoped.

[21:51] <treed> tylercurtis: I think so, yeah.

[21:51] <Tene> I was rather disappointed when I noticed that.

[21:52] <masak> treed: the use of special vars is quite Perlish. but it isn't used much in modern Ruby, it seems.

[21:52] <jnthn> treed: Depends if it does the right thing or will just confuse me. ;-)

[21:52] <treed> Heh.

[21:52] <Tene> Fixing the class restrictions on the exception workins was pretty easy, but I haven't merged that branch yet.

[21:52] <Tene> That branch merge has been pending for... five months?

[21:52] <treed> http://github.com/cardinal/cardinal/blob/iss41/src/builtins/classes.pir

[21:52] <treed> I think that's the core of the nastiness.

[21:53] <jnthn> treed: Are you using PCT for implementing this?

[21:53] <treed> I ... think so?

[21:53] <masak> (also from #parrot) seems one of the few places where 'reverse iterators' are used is in BUILDALL. maybe the only place. we should perhaps think of moving away from that solution, so that reverse iterators can be deprecated.

[21:53] *** pmurias left
[21:53] <treed> It's just the standard parrot set.

[21:53] <jnthn> treed: Yes, you are

[21:53] <treed> P6 rules for grammar, NQP for actions, and PIR for writing libs

[21:53] <Tene> jnthn: I never got it migrated to nqp-rx

[21:53] <jnthn> treed: Though not nqp-rx

[21:53] <treed> Ah, yeah.

[21:53] <jnthn> Tene: Right.

[21:53] <jnthn> Tene: That may be helpful.

[21:53] <treed> Was there ever a guide written for that.

[21:54] <jnthn> Tene: I'll be putting the new MOP-y stuff in nqp-rx.

[21:54] <tylercurtis> The Squaak tutorial's up-to-date now.

[21:54] <masak> yay

[21:54] <treed> By "that" I mean converting from nqp to nqp-rx.

[21:54] <sorear> treed: Sounds like the Rakudo and Ruby metamodels are quite similar

[21:54] <treed> sorear: I never really grokked the Rakudo model.

[21:54] <treed> I ended up excising P6object because it didn't seem to do what I wanted.

[21:55] <treed> And had weird bugs.

[21:55] <sorear> treed: Rakudo doesn't have eigenclasses, but an object's class pointer is mutable

[21:55] <Tene> sorear: Rakudo doesn't so much have class-only methods.

[21:55] <sorear> So you can get the same effect by deriving an anonymous class and setting it as the object's class

[21:55] <Tene> iiuc, you can't define a method that you can call on Foo, but not on instances of Foo

[21:56] <sorear> Tene: type objects are the big difference, yes

[21:56] <masak> Tene: there's :D and :U, though.

[21:56] <masak> Tene: (only spec so far, not in Rakudo)

[21:56] <sorear> :D and :U suck.

[21:56] <masak> no, :U suck! (SCNR)

[21:56] <Tene> :D and :U seemed... hackish, to me, I guess.

[21:56] <masak> I also have mixed feelings about them.

[21:56] <sorear> and very, very ugly

[21:57] <jnthn> I found them quite nice.

[21:57] <jnthn> Just an adverb to the type name.

[21:57] <masak> I might change my mind after I've tried them in practice.

[21:57] <jnthn> *find

[21:57] <jnthn> masak: You shoudln't have to write them much...

[21:58] <masak> no, :U shouldn't have to write them much!

[21:58] <jnthn> Then :Don't complain! :D

[21:58] <masak> :P

[21:58] <sorear> Over in Moose-land, Str:D is spelled Str

[21:58] <jnthn> No, we don't have that one.

[21:58] <sorear> If you want Maybe[Str], you have to say so

[21:58] <sorear> much better huffman, IMO

[21:58] * masak likes Maybe[Str]

[21:58] *** Holy_Cow left
[21:59] <masak> unfortunately, I don't see how that'd mesh with type objects...

[21:59] <jnthn> Heh. I don't think type objects are going away any time soon. :P

[21:59] <masak> right. :U

[21:59] *** _madmax_ joined
[21:59] <jnthn> .oO( :U is a really difficult facial expression to form )

[22:00] <masak> :∩

[22:00] <sorear> there's an interesting cheat in Moose, initial values are excempt from type constraints

[22:00] <sorear> it would make my Int $x = foo(); work, at least

[22:00] <jnthn> masak: Oh noes, what have I set off... :P

[22:01] <masak> :d

[22:02] <Tene> :D

[22:02] <Tene> yay puns :D

[22:02] <Tene> D: oh no puns

[22:03] <jnthn> Is that punctuation?

[22:03] <sorear> Now for the part where I add if ($M->isa('STD::Regex')) checks to every single backslash__S_foo action method

[22:03] * masak groans

[22:03] <Tene> emoticons.  ":D" is happy, "D:" is upset.

[22:03] <sorear> (:

[22:05] <sbp> ‿̈

[22:05] <treed> Whoa it's sbp.

[22:06] <treed> Small world.

[22:06] <sbp> yup!

[22:06] <[particle]> someone else highlighting "cardinal"?

[22:06] <sbp> I crack Unicode jokes on #perl6

[22:06] <treed> Huh?

[22:06] <sjohnson> y0

[22:06] <sbp> it's what I do

[22:06] <treed> sbp isn't cardinal-related

[22:06] <masak> sjohnson: hi! \o/

[22:06] <[particle]> wrong world

[22:07] <sorear> sbp?

[22:07] <sjohnson> yo masak hows life

[22:08] <sorear> treed: fwiw, I got to Perl 6 by following overlapping circles from #nethack

[22:08] <sbp> sup sorear?

[22:08] <sorear> sbp: me without context as to "Whoa it's sbp"

[22:08] <sbp> treed has been on one of my channels for years and years

[22:08] <sbp> Tene too

[22:08] <masak> sjohnson: life is being suspiciously kind and generous. how's with you?

[22:09] <sjohnson> works a bit boring today, but seeing new things that p6 can do usually cheers me up

[22:10] <masak> sjohnson: allow me to cheer you up, then :)

[22:10] <masak> rakudo: say Nil.defined # amazing, isn't it? :)

[22:11] <p6eval> rakudo 90637b: OUTPUT«0␤»

[22:11] <masak> \o/

[22:11] <sjohnson> yeah i remember i was playing around with defined back then

[22:11] <sjohnson> err, back a while ago.  i gotta be careful with hashes

[22:11] <sjohnson> rakudo: my %hash; say defined(%hash)

[22:11] <p6eval> rakudo 90637b: OUTPUT«1␤»

[22:12] <sjohnson> rakudo: my @list; say defined(@list)

[22:12] <masak> rakudo: say 42.?foo // "Ints don't have a .foo method, silly! :)"

[22:12] <p6eval> rakudo 90637b: OUTPUT«1␤»

[22:12] <p6eval> rakudo 90637b: OUTPUT«Ints don't have a .foo method, silly! :)␤»

[22:12] <masak> sjohnson: there's discussion about @list being undefined also.

[22:12] <sjohnson> interesting...

[22:12] * sjohnson pays attention

[22:12] <sjohnson> （　｀ー´）

[22:13] <sorear> .u ー

[22:13] <phenny> U+30FC KATAKANA-HIRAGANA PROLONGED SOUND MARK (ー)

[22:15] *** stephenlb left
[22:16] <squeeky> ( ﾟ ヮﾟ)

[22:17] <masak> sjohnson: there's a long ticket about it on RT. when I last showed it to pmichaud, he said that arrays and hashes will probably end up being undefined before use.

[22:17] <masak> sjohnson: I suspect that it was my bitching about it not being that way that led TimToady to spec :D and :U.

[22:18] <masak> so maybe we can implement undefined Arrays and Hashes, close the ticket, unspec :D and :U, and live happily ever after :)

[22:19] *** drbean left
[22:20] <jnthn> masak: If you unspec those, you still leave other problems that they solve behind.

[22:20] *** tadzik left
[22:21] <masak> jnthn: Foo $x where *.defined

[22:21] <masak> jnthn: Bar $x where !*.defined

[22:21] <jnthn> masak: I'm thinking more than :D and :U may be meaningful in a specail sense to the mult-dispatcher.

[22:21] <jnthn> masak: Remember ACCEPTS is one method we'd want to distinguish this way.

[22:22] <jnthn> masak: And Str

[22:22] <masak> right.

[22:22] <jnthn> We don't want every call to those falling back to a subset dispatch.

[22:22] *** stephenlb joined
[22:22] <jnthn> :D and :U may well be different too.

[22:22] <jnthn> That is, they may *really* mean "is a type object" and "is not a type object" rather than any higher level idea of what defined means.

[22:23] <jnthn> (Very speculatory.)

[22:23] <jnthn> So then it's not just ugly sugar for where *.defined :-)

[22:28] <masak> if they really mean 'is a type object', I could see more use for them.

[22:29] <masak> rakudo: say Int.WHICH; say Int.clone.WHICH;

[22:29] <p6eval> rakudo 90637b: OUTPUT«91674640␤91674640␤»

[22:29] <jnthn> masak: Would them meaning that feel objectional to you as a user?

[22:30] <jnthn> (To me as an implementor, that feels very helpful.)

[22:30] <masak> jnthn: it kinda feels right.

[22:30] <masak> jnthn: it makes me feel better than them just meaning 'defined' and 'undefined'.

[22:30] <masak> don't know why.

[22:30] * masak sleeps

[22:30] <masak> 'night, #perl6

[22:30] <jnthn> night o/

[22:30] *** masak left
[22:34] *** patrickas left
[22:38] <sorear> Tene: Why do you care about waltman?

[22:38] *** blogometer joined
[22:39] <Tene> sorear: I mostly don't.

[22:39] <Tene> I care at least a little bit about bring up less-false counterpoints to the uninformed anger.

[22:49] <cognominal> A perl5 question. I want to convert a python extension to a Perl extensions. It seems that python has the equivalent of SV* but that any struct with starts with the fisrt fields of this SV equivalent can benefits from the garbage collecting while there only predefined SV derivative type. What is the way out?

[22:49] <cognominal> s/with/which/

[22:50] <blogometer> I'm using felixge Node MySQL. Does it have mute button?

[22:50] <blogometer> A lot of debugging messages.

[22:51] <blogometer> Oh, wrong window.

[22:51] <cognominal> I thought that defining a new magic could work but it seems that all the magics are predefined : switches everywere?

[22:51] <blogometer> Sorry.

[22:54] <sorear> cognominal: you need to use 'ext' magic; in order to make sure you have your own magic, compare the vtable address

[22:54] <sorear> cognominal: also, the correct channel for hardcore Perl5VM hacking is #p5p on irc.perl.org

[22:55] <cognominal> agreed but I knew that someone knowledgeable would help me here

[22:56] <cognominal> thx

[22:56] <sorear> see XS::Object::Magic on CPAN

[23:01] *** _madmax_ left
[23:02] <cognominal> sorear++  # that's sounds what I want.

[23:08] *** blogometer is now known as _bigeasy

[23:08] *** _bigeasy is now known as big_easy

[23:08] *** big_easy is now known as bigsleazy

[23:09] <sorear> Oh, great.  I just noticed there are actually THREE sets of backslash: rules.

[23:09] *** bigsleazy is now known as blogometer

[23:10] *** patrickas joined
[23:11] *** kensanata joined
[23:11] <sorear> rakudo: say 1 ~~ /\w/

[23:11] <p6eval> rakudo 90637b: OUTPUT«1␤»

[23:12] *** lestrrat is now known as lest_away

[23:14] <patrickas> rakudo: (<a b>, { .succ } ... * ).[^3].map(.perl).say

[23:14] <p6eval> rakudo 90637b: OUTPUT«No candidates found to invoke for method 'map' on object of type 'Parcel'; available candidates have signatures:␤:(Mu : &block;; *%_)␤:(Mu : %block;; *%_)␤␤  in main program body at line 22:/tmp/kGZNEzCpLT␤»

[23:14] <patrickas> rakudo: (<a b>, { .succ } ... * ).[^3].join(', ').say

[23:14] <p6eval> rakudo 90637b: OUTPUT«a, b, c␤»

[23:15] <patrickas> should the fist element returned be 'a' or <a b> ? 

[23:17] <sorear> a

[23:17] <sorear> <a b> means "a", "b"

[23:18] <squeeky> <cheap fast good>

[23:18] *** jferrero joined
[23:18] <patrickas> i know ... but does it flattem?

[23:18] <lue> rakudo: say 1 «=« [1,2,3]

[23:18] <sorear> yes

[23:18] <p6eval> rakudo 90637b: OUTPUT«1␤Cannot modify readonly value␤  in '&infix:<=>' at line 1␤  in <anon> at line 204:CORE.setting␤  in 'hyper' at line 1␤  in 'hyper' at line 211:CORE.setting␤  in main program body at line 1␤»

[23:18] <sorear> , always flattens

[23:18] <jnthn> rakudo: say <cheap fast good>.pick(2)

[23:18] <p6eval> rakudo 90637b: OUTPUT«cheapfast␤»

[23:19] <patrickas> rakudo: (<a b> , 'c').perl.say

[23:19] <p6eval> rakudo 90637b: OUTPUT«(("a", "b"), "c")␤»

[23:19] <patrickas> rakudo: (<a b> , 'c').elems.say

[23:19] <p6eval> rakudo 90637b: OUTPUT«3␤»

[23:19] <sorear> .perl is kinda special

[23:19] <jnthn> In the first, note it's never been promoted from a Parcel

[23:19] <sorear> it ignores all flattening information in what it sees

[23:19] <jnthn> Nothing enforced flattening context

[23:19] <jnthn> .elems enforces it

[23:19] <Tene> rakudo: (['a', 'b'], 'c').elems.say

[23:19] <p6eval> rakudo 90637b: OUTPUT«2␤»

[23:20] <Tene> rakudo: (['a', 'b'], 'c').perl.say

[23:20] <p6eval> rakudo 90637b: OUTPUT«(["a", "b"], "c")␤»

[23:20] <lue> rakudo: say 1 «==« [1,2,3]

[23:20] <p6eval> rakudo 90637b: OUTPUT«100␤»

[23:20] <Tene> See the difference?

[23:20] <lue> rakudo: say (1 «==« [1,2,3]).perl

[23:20] <p6eval> rakudo 90637b: OUTPUT«[Bool::True, Bool::False, Bool::False]␤»

[23:20] *** hudnix joined
[23:20] <patrickas> how can I explicitely promote form a parcel ?

[23:22] <patrickas> in other words

[23:22] <patrickas> somewheer in my code I am doing: my $args = @lhs.iterator.list

[23:23] <patrickas> and it seems $args when I read from $args it "seems" I am getting <a b> as  first element

[23:23] <jnthn> patrickas: Anything that puts it in context would do that.

[23:23] <jnthn> Oh, hmm

[23:24] <rgrau_> rakudo: ([<a b>], { .succ } ... * ).[^3].join(', ').say

[23:24] <p6eval> rakudo 90637b: OUTPUT«a b, a c, a d␤»

[23:24] <jnthn> rakudo: ('a', 'b', { .succ } ... * ).[^3].join(', ').say

[23:24] <p6eval> rakudo 90637b: OUTPUT«a, b, c␤»

[23:24] <jnthn> rakudo: (<a b>, { .succ } ... * ).[^3].join(', ').say

[23:24] <p6eval> rakudo 90637b: OUTPUT«a, b, c␤»

[23:25] <patrickas> the current series operator works fine

[23:25] <patrickas> I am refactoring it

[23:25] <jnthn> Ah, OK

[23:25] <patrickas> and this is the only test not pasing in MY code

[23:25] <jnthn> patrickas: How are you handling the LHS

[23:25] <jnthn> ?

[23:25] <jnthn> .flat will put something in flattening context.

[23:26] <patrickas> I'll try that

[23:26] *** justatheory left
[23:29] <lue> rakudo: my @a = (1 «==« [1,2,3]); say ( [+] @a )

[23:29] <p6eval> rakudo 90637b: OUTPUT«1␤»

[23:30] <lue> rakudo: my @a = (1 «==« [1,2,1]); say ( [+] @a )

[23:30] <p6eval> rakudo 90637b: OUTPUT«2␤»

[23:30] *** _madmax_ joined
[23:31] <lue> am I the only one who can't run rakudo with the latest PARROT_REVISION ?

[23:32] <patrickas> in all cases is it a bug ?

[23:33] <Tene> my parrot_revision is 48547 the last time I rebuilt

[23:33] <patrickas> I am handling @lhs like this

[23:33] <patrickas> our multi sub infix:<...>(@lhs, Whatever) {my $args = @lhs.iterator.list; say $args.elems,@lhs.elems;} ; (<a b>, 'c' ... * );

[23:33] <Tene> has it been updated since that?

[23:33] <patrickas> rakudo: our multi sub infix:<...>(@lhs, Whatever) {my $args = @lhs.iterator.list; say $args.elems,@lhs.elems;} ; (<a b>, 'c' ... * );

[23:33] <p6eval> rakudo 90637b: OUTPUT«23␤»

[23:33] <patrickas> should that ^^ output 33 ?

[23:33] <lue> parrot revision 48559 here

[23:34] <jnthn> patrickas: If you're putting a list in a scalar then I guess you're itemizing it.

[23:34] <lue> it's a parrot error concerning PackFile_unpack    (wondering if it anyone else has this problem)

[23:35] <jnthn> lue: That's normally a result of having left-over PBC files from an older Parrot.

[23:35] <sorear> PackFile_unpack errors are never bugs

[23:36] <sorear> it just means you forgot to rebuild

[23:36] <lue> I'm pretty sure I ran  perl Configure.pl --gen parrot ; make ; make install  like always

[23:36] <patrickas> ok i'll work around by explicitly .flat-ing

[23:37] <lue> [doing so again to make sure]

[23:37] <patrickas> rebuild, spectest and hope for the best

[23:39] <patrickas> what's funny is that the tests was for someting else (testing a block with arity 1) ... and it was the only one that caught my non flattenign bug!

[23:39] *** bluescreen joined
[23:40] *** bluescreen is now known as Guest82885

[23:40] <jnthn> We need more tests. ;-)

[23:41] <lue> .oO(would standardized tests be easier for a Perl 6 implementation?)

[23:41] <sorear> lue: you forgot the git clean -dfx

[23:43] <lue> just ran it. It's funny, I never had to do that before.

[23:48] <patrickas> PASS \o/

[23:48] <jnthn> patrickas: \o/

[23:48] *** jferrero left
[23:48] <sorear> std: / \X[23,34,46] /

[23:48] <p6eval> std 32064: OUTPUT«ok 00:01 116m␤»

[23:49] <sorear> I wonder what that means.,

[23:50] <squeeky> TAP 2.0 needs to mandate the 4 stages of test: PASS \o/, FAIL /o/, UNKNOWN |o_ and NA /o

[23:50] <treed> I don't get the UNKNOWN

[23:50] <treed> Is that like raising hand to ask a question

[23:51] <squeeky> treed: .... think YMCA.

[23:52] <Tene> I don't get FAIL

[23:52] <squeeky> think I'll just go and facepalm in my sleep.

[23:53] <patrickas> night all

[23:53] *** patrickas left
[23:54] <[Coke]> perl Configure.pl --gen-parrot does NOT remove the old parrot build. this can cause trouble on some revision updates.

