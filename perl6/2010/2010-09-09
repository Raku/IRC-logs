[00:00] *** Psyche^ joined
[00:00] *** Psyche^ is now known as Patterner

[00:07] <lichtkind> good night

[00:09] *** nimiezko left
[00:11] *** lucas_ joined
[00:14] *** nimiezko joined
[00:16] <lucas_> hi everyone

[00:16] <lucas_> why we dont get diffs anymore in commit messages in perl6-language?

[00:16] <lucas_> is it because of the recent pugs respository move?

[00:18] <colomon> lucas_: yes, exactly

[00:19] *** risou joined
[00:19] <TimToady> please read the discussion there

[00:23] <TimToady> (there meaning p6l)

[00:23] <TimToady> it is, alas, under the subject: remove some some duplicate words words

[00:24] *** jferrero left
[00:25] *** plobsing joined
[00:30] <lucas_> oh, now I see... sorry, missed. thanks!

[00:30] *** cognominal left
[00:31] *** Helios left
[00:34] *** ascent_ left
[00:35] *** Helios joined
[00:35] *** ascent_ joined
[00:36] *** risou_ joined
[00:38] <lucas_> the first thing that came to my mind was:

[00:38] <lucas_> "let's use some rss2email program"

[00:38] <sjohnson> cool

[00:38] <lucas_> but the RSS entries doesn't contain the diffs either

[00:39] *** risou left
[00:45] *** cognominal joined
[00:49] <dukeleto> Finaly Summary of GSoC 2010: http://leto.net/dukeleto.pl/2010/09/google-summer-of-code-2010-final-summary.html 

[00:51] *** jaldhar joined
[00:56] *** QinGW joined
[01:00] *** Helios left
[01:01] *** tylercurtis joined
[01:04] *** Helios joined
[01:06] *** felipe left
[01:10] *** Chillance left
[01:12] *** jaldhar left
[01:22] *** lichtkind left
[01:29] *** Sarten-X joined
[01:35] *** Eevee left
[01:39] *** Eevee joined
[01:39] *** lucas_ left
[01:43] *** mfollett joined
[02:03] *** stepnem left
[02:05] <dalek> rakudo: 859f2d9 | colomon++ | src/core/Iterable.pm:

[02:05] <dalek> rakudo: Add Iterable.Numeric so that Arrays (and other Iterable types) numify to Int rather than to Num.

[02:05] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/859f2d9afe0b60a9f1616803c2c1b8651ba6296e

[02:09] *** whiteknight left
[02:09] *** stepnem joined
[02:14] *** mfollett left
[02:27] *** jaldhar joined
[02:30] <nimiezko> How can I use List role methods (get...) ?

[02:31] *** justatheory joined
[02:33] <nimiezko> rakudo: my @list = 1..10 ; my $it <== @list ; 

[02:33] <p6eval> rakudo 780732: OUTPUT«Method 'push' not found for invocant of class ''␤  in main program body at line 22:/tmp/oStMvx79sP␤»

[02:34] <colomon> rakudo: my @array = 1..10; my $list = @array.list; say $list.shift; say $list.shift

[02:34] <p6eval> rakudo 780732: OUTPUT«1␤2␤»

[02:34] <colomon> I'm not familiar with get in this context...

[02:37] <nimiezko> I search a non-destructive way to go through an array (i.e. without shifting)

[02:37] <colomon> rakudo: my @array = 1..10; my $list = @array.list; say $list.shift; say $list.shift; say @array.perl

[02:38] <p6eval> rakudo 780732: OUTPUT«1␤2␤[3, 4, 5, 6, 7, 8, 9, 10]␤»

[02:38] <colomon> rakudo: my @array = 1..10; my $list = @array.list.iterator; say $list.shift; say $list.shift; say @array.perl

[02:38] <p6eval> rakudo 780732: OUTPUT«Method 'shift' not found for invocant of class 'ListIter'␤  in main program body at line 22:/tmp/PjHLEsVFKK␤»

[02:38] <colomon> rakudo: my @array = 1..10; my $list = @array.list.iterator.list; say $list.shift; say $list.shift; say @array.perl

[02:38] <p6eval> rakudo 780732: OUTPUT«1␤2␤[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]␤»

[02:39] <colomon> that's kind of round about, I'm sure there's a better way I'm not thinking of.

[02:39] <nimiezko> rakudo: my @array = 1..10; my $list = @array.list; say $list.shift; say $list.shift ; say $list.perl ; say $list.get ;

[02:39] <p6eval> rakudo 780732: OUTPUT«1␤2␤[3, 4, 5, 6, 7, 8, 9, 10]␤Method 'get' not found for invocant of class 'Array'␤  in main program body at line 22:/tmp/BDqWM6jI_e␤»

[02:40] <nimiezko> colomon: could you explain the ".list.iterator.list" to a newbie ?

[02:40] <colomon> actually, it's probably overkill ... one moment.

[02:41] <colomon> rakudo: my @array = 1..10; my $list = @array.iterator.list; say $list.shift; say $list.shift; say @array.perl

[02:41] <p6eval> rakudo 780732: OUTPUT«1␤2␤[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]␤»

[02:41] <colomon> there we go.

[02:41] <colomon> so @array.iterator.list is all you need.

[02:42] <colomon> basically, .iterator gives you a non-destructive iterator into @array.

[02:42] <colomon> and then .list builds a new List object using it.

[02:42] *** alester joined
[02:42] <colomon> So when you do the shifts, they destroy $list but not @array.

[02:43] <nimiezko> thanks

[02:43] <colomon> no prob.

[02:43] <colomon> of course, depending on what you are doing, there are probably easier ways to iterate over an array.

[02:44] <colomon> as long as you don't want quite that detailed control over that iteration.

[02:44] <colomon> like   for @array -> $a { whatever }

[02:44] <colomon> but I presume you are looking for greater control?

[02:44] <nimiezko> presume well

[02:45] <nimiezko> my get should be on a distinct sub

[02:46] <colomon> I'm not sure I understand you?

[02:47] <nimiezko> Not sure I express myself clearly

[02:47] <nimiezko> I have a sub which actually receive an array and shift over it

[02:47] <colomon> ah!

[02:48] <nimiezko> but at the end (after various execution of this sub) I need the initial array

[02:48] *** masonkramer joined
[02:48] *** masonkramer left
[02:50] <colomon> The @array.iterator.list should work for you there, I think.

[02:50] <colomon> I've got to go to bed now.  Good luck!

[02:51] <nimiezko> Good night ! Will get some sleep too.

[02:58] *** Alias joined
[03:06] *** yrgd left
[03:07] *** mfollett joined
[03:18] *** karb joined
[03:36] *** risou joined
[03:39] *** risou_ left
[03:46] *** hercynium left
[03:52] *** arnsholt joined
[03:56] *** lue joined
[03:57] <lue> hello o/

[04:03] *** Bzek joined
[04:11] <tylercurtis> \o, lue.

[04:11] *** nimiezko left
[04:11] *** arnsholt left
[04:12] *** plobsing left
[04:20] *** Bzek left
[04:24] <mfollett> probably a dumb question, but does the order of subroutine traits matter?

[04:25] <tylercurtis> mfollett: Potentially.

[04:25] <tylercurtis> Or, at least, I think so.

[04:27] <mfollett> ok

[04:27] <tylercurtis> For example, I suspect that a "returns" trait, if supplied, on a NCI function using Zavolaj's "is native(...)" trait needs to precede the is native.

[04:28] <mfollett> whee is is native defined?

[04:28] <tylercurtis> http://github.com/jnthn/zavolaj/

[04:29] <mfollett> oh, cool

[04:33] *** arnsholt joined
[04:34] *** lamstyle left
[04:36] *** lamstyle joined
[05:00] *** redicaps joined
[05:00] *** redicaps left
[05:08] <mfollett> what is the proper syntax for exporting a subroutine?

[05:08] <tylercurtis> "sub foo () is export {...}"

[05:09] <mfollett> hmm… I thought I tried that…

[05:09] <tylercurtis> Rakudo might require the sub to be our right now, but I'm not sure.

[05:09] <tylercurtis> If so, "our sub foo () is export {...}"

[05:10] <mfollett> yep, that solved it, thanks! tylercurtis++

[05:14] *** Guest23195 joined
[05:15] <diakopter> phenny: ask TimToady in S06, You can get the current routine name by calling &?ROUTINE.name. Outside of any sub declaration, this call returns failure.    But please can .name also be a method on a callframe object?

[05:15] <phenny> diakopter: I'll pass that on when TimToady is around.

[05:16] <diakopter> or would that be too much unbounded dynamism

[05:19] *** masak joined
[05:19] <masak> oh hai, #perl6!

[05:19] <phenny> masak: 08 Sep 22:32Z <moritz_> ask masak if there's a good reason to keep the 'buf' branch on github around

[05:19] <masak> no. deleting.

[05:19] *** sftp joined
[05:20] *** sftp_ left
[05:20] <masak> ah; seems to have already been done.

[05:26] *** alester left
[05:28] *** mberends left
[05:30] <masak> wow. got talk evaluations for my two YAPC talks. agree with every single word written by the evaluators, both the 'worked well' ones and the 'could be improved' ones. sppoky. :)

[05:30] *** Axius joined
[05:30] <masak> at least I seem to be in touch with my evaluators. :P

[05:32] *** stepnem left
[05:35] *** dju joined
[05:36] *** stepnem joined
[05:38] *** dju left
[05:39] *** dju joined
[05:41] *** mfollett left
[05:47] *** cj joined
[05:55] *** karb left
[06:00] <masak> use.perl.org shuts down posting? http://twitter.com/briandfoy_perl/status/23952060808

[06:01] <masak> wow, seems I will need to migrate sooner than I thought.

[06:02] <masak> not sure how many p6ers are still using use.perl.org -- I can only think of pmichaud and lichtkind right now.

[06:08] *** wtw joined
[06:15] *** Axius left
[06:19] <masak> rakudo: sub f($x, $y) { say $x }; my &g = &f.assuming(5); g

[06:19] <p6eval> rakudo 859f2d: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'f' at line 22:/tmp/5kFnLGh79b␤  in main program body at line 1␤»

[06:20] <masak> ok, one could argue that the numbers should be 0 and 1, respectively, and that the function should be g.

[06:20] <masak> but fair enough, not necessarily a bug.

[06:21] <masak> this, however:

[06:21] <masak> rakudo: class A { our method f($x: $y) { say $x } }; my $a = A.new; my &g = &A::f.assuming( x => $a ); g

[06:21] <p6eval> rakudo 859f2d: OUTPUT«Not enough positional parameters passed; got 0 but expected 2␤  in 'A::f' at line 22:/tmp/K0sd4n9Bcu␤  in main program body at line 1␤»

[06:21] * masak submits rakudobug

[06:23] *** uniejo joined
[06:24] <masak> I never have liked, and probably never will like the fact that the invocant is counted among the positional parameters. but I'm willing to write that off as a hard-to-fix Parrot idiosyncracy.

[06:24] <masak> but the 0 there is wrong. we are passing in one of the two arguments.

[06:25] <masak> can't have it both ways :)

[06:26] <tylercurtis> masak: doesn't .&foo rely on the invocant being the first positional parameter?

[06:27] <masak> yes, and I accept that there's such a mapping going on, both explicitly and implicitly.

[06:27] *** cjk101010 joined
[06:27] <masak> I just don't consider it least-surprise to count it in the error messages.

[06:27] <masak> at least not without explanation.

[06:28] <masak> rakudo: class A { our method f($x: $y) { say $x } }; my $a = A.new; my &g = &A::f.assuming( y => 42 ); g

[06:28] <p6eval> rakudo 859f2d: OUTPUT«Not enough positional parameters passed; got 0 but expected 2␤  in 'A::f' at line 22:/tmp/GfiOmli8GZ␤  in main program body at line 1␤»

[06:29] <masak> rakudo: class A { our method f($x: $y, $z) { say $x } }; my $a = A.new; my &g = &A::f.assuming( y => 42, z => 5 ); g

[06:29] <p6eval> rakudo 859f2d: OUTPUT«Not enough positional parameters passed; got 0 but expected 3␤  in 'A::f' at line 22:/tmp/aMuTAgvwyz␤  in main program body at line 1␤»

[06:29] <masak> seems it always gives 0.

[06:29] <sorear> good * #perl6

[06:30] <sorear> TimToady: temp is not the use case !

[06:30] <masak> *, sorear.

[06:33] <sorear> seen pmurias

[06:33] <aloha> Sorry, I haven't seen pmurias.

[06:37] *** risou_ joined
[06:40] <TimToady> sorear: what do you call http://irclog.perlgeek.de/perl6/2010-09-02#i_2775222 then?

[06:40] <phenny> TimToady: 05:15Z <diakopter> ask TimToady in S06, You can get the current routine name by calling &?ROUTINE.name. Outside of any sub declaration, this call returns failure.    But please can .name also be a method on a callframe object?

[06:40] *** kjeldahl joined
[06:40] *** risou left
[06:41] <masak> ash_: massive kudos on try.rakudo.org! it's wonderful! ash_++

[06:45] <TimToady> latest addition: http://rosettacode.org/wiki/Matrix_multiplication#Perl_6

[06:45] <masak> There's no Rakudo 2010.09

[06:45] <TimToady> tried to write it entirely without an @p, but, something kept flattening my inner arrays

[06:45] <masak> unless you're calling from the future :)

[06:45] <TimToady> there's no Rakudo Star in 09

[06:46] <TimToady> there's a Rakudo

[06:46] <masak> there is?

[06:46] <masak> did I miss the release?

[06:46] *** stepnem left
[06:46] <TimToady> usually called HEAD

[06:46] <sorear> TimToady: I call it a test case.  It could be put into t/spec to enforce or reject my interpretation

[06:46] <masak> we count differently, then.

[06:46] <sorear> The *use* case is to simplify the compiler

[06:46] <TimToady> I've been known to have my little idiosyncracies

[06:47] *** sftp left
[06:47] *** sftp joined
[06:47] <masak> anyway, nice code.

[06:47] <TimToady> it was mostly to make the P5 code look bad.  :)

[06:47] <masak> looking forward to the @p-less variant :)

[06:48] *** kjeldahl_ joined
[06:48] <masak> "TimToady: aiming to make P5 code look bad since 2000" :)

[06:50] *** stepnem joined
[06:51] <sorear> right now niecza takes 1.6 ms per element on for @arr -> $x { }

[06:51] <sorear> I think this can be improved

[06:56] <masak> rakudo: my @a=<a a a>;my @b=<b b b>;for (@a »,« @b) »,« @a -> $a, $b, $c {say "$a $b $c"}

[06:56] <p6eval> rakudo 859f2d: OUTPUT«Sorry, sides are of uneven length and not dwimmy.␤  in 'hyper' at line 179:CORE.setting␤  in main program body at line 1␤»

[06:56] <masak> rakudo: my @a=<a a a>;my @b=<b b b>;for (@a >>,<< @b) >>,<< @a -> $a, $b, $c {say "$a $b $c"}

[06:56] <p6eval> rakudo 859f2d: OUTPUT«Sorry, sides are of uneven length and not dwimmy.␤  in 'hyper' at line 179:CORE.setting␤  in main program body at line 1␤»

[06:57] <masak> <TimToady> that looks like a bug

[06:57] * masak submits rakudobug

[06:59] * moritz_ doesn't understandwhy

[06:59] <moritz_> @a »,« @b return a list that's twice as long as @a

[06:59] <moritz_> so the error message is fine

[07:00] <masak> there's no trickery with Parcels going on, then?

[07:00] <moritz_> without the parens, one could argue about list associativity

[07:01] *** amkrankruleuen left
[07:02] <masak> if there's list associativity, the parens shouldn't matter...

[07:02] <TimToady> there's no list context for @a »,« @b, so it should produce a structure of parcels of the same length

[07:02] *** amkrankruleuen joined
[07:02] <TimToady> hyperops aren't listy like zips

[07:04] <sorear> spot the error in the following definition of map, which I just wrote for niecza

[07:04] <sorear> method map($f) { gather for @(self) { take $f($_) } }

[07:06] <masak> sorear: doesn't handle blocks with exotic signatures?

[07:06] <sorear> masak: It's much simpler than that.

[07:09] * masak gives up

[07:09] <tylercurtis> Is your for written in terms of map?

[07:09] * tylercurtis really doubts that's it.

[07:09] <sorear> bingo

[07:10] *** justatheory left
[07:10] <sorear> for is (modulo void-context cheats) simply .map

[07:10] *** justatheory joined
[07:10] *** justatheory left
[07:11] *** stepnem left
[07:16] *** stepnem joined
[07:17] <masak> could we rename perl6/specs to perl6/spec before it's too late? :/

[07:19] <TimToady> a specification generally consists of many specifications; I don't care one way or the other

[07:20] <TimToady> I do think the documents in question specify more than one thing

[07:21] <masak> I wouldn't have mentioned it again, except I saw in the backlog that pmichaud also kept expecting it to be 'spec'.

[07:23] <masak> so the tally thus far is some people who don't care either way, and two people who want it to be 'spec'.

[07:23] <sorear> count me in don't care

[07:23] <masak> some + 1 = some :)

[07:24] * sorear mumbles something about a heap paradox

[07:24] <masak> not really a paradox; heap access will just get slower with each addition :P

[07:26] <moritz_> phenny: ask colomon could you maybe change http://github.com/colomon/List-Utils/blob/master/lib/List/Utils.pm#L57 to do a ~~ Numeric test instead? or !~~ Positional maybe?

[07:26] <phenny> moritz_: I'll pass that on when colomon is around.

[07:30] *** foodoo joined
[07:36] <masak> [backlog] "The quick brown cow jumped over the lazy moon"

[07:38] <moritz_> rakudo: my %h; %h.push: "The quick brown cow jumped over the lazy moon".comb.classify({$_}); say %h.elems

[07:38] <p6eval> rakudo 859f2d: OUTPUT«24␤»

[07:39] <sorear> (1,(2,(3,4),5),6).join("|")  ==>  6|2|3|4|5|1

[07:40] <masak> moritz_: that one counts spaces as well, though.

[07:47] <moritz_> rakudo: say "The quick brown cow jumped over the lazy moon".comb(/\w/).classify({.lc}).elems

[07:47] <TimToady> rakudo: Set.new("The quick brown cow jumped over the lazy moon".comb(/\w/)).elems

[07:47] <p6eval> rakudo 859f2d: OUTPUT«22␤»

[07:47] <p6eval> rakudo 859f2d:  ( no output )

[07:49] <TimToady> rakudo: say Set.new("The quick brown cow jumped over the lazy moon".lc.comb(/\w/)).elems

[07:49] <p6eval> rakudo 859f2d: OUTPUT«22␤»

[07:49] <masak> &

[07:50] <TimToady> oddly, + doesn't work on a Set

[07:55] <sorear> Any reason not to delete 'perlsix'?

[07:59] *** Axius joined
[07:59] <dalek> niecza: e093ea4 | sorear++ | / (4 files):

[07:59] <dalek> niecza: Bring iterator API a little closer to Rakudo

[07:59] <dalek> niecza: 

[07:59] <dalek> niecza: Removes 40 lines of code and doubles array iteration speed...

[07:59] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e093ea46552a7715dc1935724fd9f3afb296ea9d

[08:03] *** Axius left
[08:06] *** daxim joined
[08:12] <moritz_> sorear: deleting works for me

[08:12] *** amkrankruleuen left
[08:13] *** amkrankruleuen joined
[08:14] <mathw> sorear: doubling array iteration speed and removing 40 lines of code? Very nice :)

[08:17] <sjohnson> haha

[08:17] <sjohnson> cute sentence

[08:23] <jnthn> morning, #perl6

[08:23] <sorear> done

[08:24] <sorear> hello jnthn 

[08:25] <moritz_> \o

[08:29] <jnthn> masak: The invocant being counted amongst the positional parameters is _not_ a Parrot idiosyncracy. In fact, I've argued against Parrot changing away from it being that in the past. It really is - in a Perl 6 sense - the first positional argument in the Capture. There's nothing special about the invocant really once we've decided what we're going to dispatch to.

[08:29] <sorear> Didn't the invocant used to be magical in Parrot?

[08:29] <moritz_> http://www.morungos.com/node/90 nicea read, and encouraging for us :-)

[08:30] <jnthn> sorear: Maybe way back.

[08:30] <jnthn> sorear: Well, they do flag it a bit differently now but in a thankfully ignorable way.

[08:30] <jnthn> The important thing is that it's not passed out of band.

[08:32] *** amkrankruleuen left
[08:32] *** amkrankruleuen joined
[08:35] *** thebird joined
[08:35] *** proller joined
[08:36] *** dakkar joined
[08:36] * sorear is STILL finding bugs in the low-level code generator

[08:38] <tylercurtis> rakudo: sub forever (*&body) { loop { body; } }; forever { last if rand < .5 }; say "Yay for functions as control structures."

[08:38] <p6eval> rakudo 859f2d: OUTPUT«Yay for functions as control structures.␤»

[08:39] <moritz_> and last() magically works in the custom loop construct!

[08:40] <jnthn> ....what's the * in the signature there?

[08:41] <sorear> slurpy block

[08:41] <moritz_> S06 has some weird magic description of slurpy blocks

[08:41] <moritz_> which is NYI, so it probably has no effect atm

[08:41] <jnthn> I didn't realize they were implemented in Rakudo

[08:41] <jnthn> Ah, OK

[08:41] <jnthn> It silently...works. :-)

[08:42] <sorear> I think that part of the spec is a fossil from before Block became a first-class value

[08:42] <tylercurtis> Good to know that slurpy blocks are NYI.

[08:44] <masak> jnthn: (invocant being a positional) nod, and agree, and such. I'm not proposing any change there. I'm arguing for some recognition in the error message that one of the positionals is kinda special, and that the user might not immediately think of it as a positional.

[08:46] <sorear> The description of slurpy blocks has not been touched in the two years of git history

[08:47] *** dju_ joined
[08:47] <sorear> Where did the synopses live before 68d062f ?

[08:47] *** dju left
[08:47] <sorear> (a 20,615 line insert commit by pmichaud)

[08:47] <moritz_> somewhere on svn.perl.org

[08:48] <moritz_> sorear: note that the specs repo has history going back to 2006, but the files were renamed once

[08:49] <sorear> yes

[08:49] <sorear> I chased through those

[08:49] <moritz_> our Int multi P5emul::Str::p5chomp ( Str *@strings = ($+_) is rw )

[08:49] <sorear> also in late 2009 lwall accidentally deleted S06 and S12

[08:49] * moritz_ slightly amused

[08:49] <dalek> niecza: 8df43ce | sorear++ | / (3 files):

[08:49] <dalek> niecza: Use low-level code for List!fill

[08:49] <dalek> niecza: 

[08:49] <dalek> niecza: 4x speed on iteration microbenchmark, down to 260 us/iter

[08:49] <dalek> niecza: review: http://github.com/sorear/niecza/commit/8df43ce7038b21540e6f6d591e5561064cea5859

[08:50] <moritz_> who needs functions or objects anyway? :-)

[08:50] <masak> those specifications were never among the stable ones anyway. oh wait.

[08:51] <jnthn> hehe

[08:51] <jnthn> masak: If you can think of a good way to be clearer, I'm willing to take/implement suggestions.

[08:51] <masak> jnthn: I'll brainstorm a bit with myself and gist back to you. :)

[08:52] <jnthn> :P

[08:52] <sorear> quadrupling the speed of iterators only speeds up the parser benchmark by ~4%, time to move on

[08:54] *** timbunce joined
[08:58] <mathw> sorear: it's still good!

[08:58] <masak> jnthn: something like this: http://gist.github.com/571607

[09:01] <moritz_> masak: I find that slightly ugly

[09:01] <masak> fair enough.

[09:01] <masak> I'm not entirely satisfied with it myself.

[09:01] <moritz_> masak: I'd rather have a parenthetical remmark (invocants are included in the counts)  or so

[09:01] <moritz_> s/counts/numbers/

[09:02] <masak> as in my second proposal.

[09:02] <masak> I'm fine with that. it should only show up for methods, of course.

[09:03] <moritz_> right

[09:03] <moritz_> masak: then make it 'the invocant*s* included'

[09:04] <moritz_> that way it's clear that it applies to both

[09:05] <jnthn> "methods"

[09:05] <masak> agreed.

[09:05] <jnthn> masak: I think it'd show up where there's a parameter marked as being an invocant

[09:06] <jnthn> masak: I don't think if someone did .^add_method(-> $x, $y, $z { ... }) we'd be able to tell 'em much.

[09:06] <jnthn> Though it wasn't declared as an invocant here

[09:06] <jnthn> *there

[09:06] <jnthn> So it's fine I guess

[09:07] <masak> yes, that's way out in doctor-it-hurts-when-I-do-this land.

[09:08] *** zby__ left
[09:08] *** zby left
[09:08] *** zby joined
[09:19] *** tadzik joined
[09:19] <tadzik> oh hai

[09:19] <masak> \o

[09:20] <tadzik> masak: I'm closer to the feather account :)

[09:20] <Juerd> Yea, sorry about not having noticed your mail :)

[09:20] <tadzik> no worries, happens :)

[09:20] <Juerd> I'm ambivalent about your patience

[09:20] <Juerd> It's laudable that you haven't nagged about it. On the other hand, if you had, you would have had the account already :D

[09:21] <tadzik> I nagged once :)

[09:21] <Juerd> Oh, you did?

[09:21] <tadzik> yeah, some day

[09:21] <Juerd> Oh, er. Sorry then.

[09:21] <Juerd> Anyway, what username do you want?

[09:21] <Juerd> "tadzik"?

[09:21] <tadzik> doesn't matter :) I still fail to compile "ambivalent" in your sentence though :)

[09:21] <tadzik> Juerd: tjs would be nice, as I mailed

[09:22] <tadzik> (few minutes ago)

[09:22] *** amkrankruleuen left
[09:22] <sorear> if you had announced your desire openly you would have gotten it in a couple minutes

[09:22] <Juerd> Ambivalence is having two values.

[09:22] <sorear> feather is a "community administered" server

[09:22] <tadzik> yeah, so I don't get it :)

[09:22] <Juerd> sorear: Oh, no, new accounts go through me :)

[09:22] <jnthn> So 1|2 is an ambivalent junction? :-)

[09:22] <sorear> Juerd: oh, good thing I never found out

[09:23] <moritz_> tadzik: "community administered" means "know whom to nag" :-)

[09:23] <tadzik> . o O ( decentralized nagging )

[09:23] <Juerd> sorear: It's okay if other people do create the accounts, as long as I do receive the official mail requesting it, with all info in it.

[09:24] <Juerd> sorear: And that's where things go wrong. Very few requests contain sufficient information at once :)

[09:24] <Juerd> I need (1) an explicit request for an account, in a sentence, (2) the real name of the applicant (or something that looks like one)  (3) the preferred username

[09:25] <Juerd> And by email, not irc :)

[09:26] <tadzik> well, I didn't see any specs for that, I was just told "poke Juerd" :)

[09:26] <sorear> 14 people from irc have root on feather1

[09:26] <sorear> Juerd: where can I find the rest of the rules like "all account creation through Juerd"?

[09:26] <Juerd> sorear: More. Two know the actual root password :)

[09:26] <Juerd> sorear: In the original mail :)

[09:27] <Juerd> sorear: I'm beginning to become aware that this isn't the most obvious place.

[09:27] <sorear> on most computers I've been at, people who know the root pw tend to wind up in sudoers anyway

[09:28] * sorear hates passwords for most stuff

[09:28] <sorear> machine/machine stuff

[09:29] *** Quadrescence left
[09:29] <Juerd> The two other people who know the root password don't have accounts themselves

[09:29] <tylercurtis> Good night, #perl6. Hopefully, tomorrow, I'll write the barest beginnings of a setting for Bennu. Then work on compiling the bootstrappy ugliness. Once that's done, I can work on actually compiling actual Perl 6 code! So, maybe "say 1;" will work before next weekend. :)

[09:30] <Juerd> It's interesting to see, in /etc/shadow, the jump from $1$ style crypt to $6$

[09:30] <Juerd> The old lines fit on a single screen line

[09:31] <Juerd> For the new ones, the hash itself is 98 characters

[09:32] <sorear> $6$ is what, SHA-256?

[09:32] <tylercurtis> Juerd: ooc, how readily do you give feather accounts?

[09:33] <Juerd> sorear: 512 apparently

[09:33] * sorear wonders how many people here remember crypt()

[09:33] <Juerd> sorear: http://en.wikipedia.org/wiki/Crypt_(Unix)#cite_note-shacrypt-4

[09:33] <Juerd> tylercurtis: What does readily mean, in this context?

[09:33] <sorear> Juerd: wait... I don't think I ever sent you any mail

[09:33] *** jhuni left
[09:34] <Juerd> sorear: You're not in my feather administration either. What the...

[09:34] <sorear> "my feather administration"?

[09:35] <moritz_> I might have given sorear access to feather2, but I'm sure I didn't for feather1

[09:35] <tadzik> no weechat on feather :(

[09:35] <Juerd> sorear: A list of all accounts that I created, with references to the mails

[09:35] <Juerd> sorear: Could you please send me the mail anyway?

[09:35] <moritz_> Warning: Permanently added the RSA host key for IP address '2a02:2308:10::f:1' to the list of known hosts.

[09:35] <sorear> Juerd: sure, what do you need

[09:36] <Juerd> moritz_: Nice, isn't it?

[09:36] <moritz_> \o/

[09:36] <moritz_> Juerd++

[09:36] <Juerd> sorear: See timestamp x:24

[09:36] <Juerd> moritz_: Feather is the second server in our network to get ipv6

[09:36] <moritz_> tadzik: installing weechat now...

[09:36] <sorear> juerd@ feather-minus-feather?

[09:36] <tadzik> moritz_++

[09:36] <Juerd> sorear: [email@hidden.address]
[09:37] *** amkrankruleuen joined
[09:37] <Juerd> (Normally, finding my email address is left as an exercise, but since people find [email@hidden.address] and feather mail has been broken for ages, that doesn't work anymore.)

[09:38] *** jferrero joined
[09:39] <sorear> sent

[09:40] <tylercurtis> Juerd: Better phrased, I was asking essentially whether you give accounts to anyone hacking on Perl6-related things who asks or are more selective.

[09:40] <daxim> ##### voodoo

[09:40] <Juerd> tylercurtis: No, that's exactly the single criterion

[09:40] <sorear> I'm pretty sure I got root on feather1 after complaining about dalek being down one too many times

[09:40] <Juerd> sorear: Thanks for the mail

[09:41] <Juerd> sorear: Your account has its password disabled. Did you do that? :)

[09:41] <Juerd> I don't usually disable passwords for new accounts

[09:41] <sorear> Yes

[09:42] <Juerd> In fact, it's the only password-disabled account on feather, if you don't count system accounts :)

[09:42] <tylercurtis> Juerd: good to know if I convince myself I have any reason to ask for one.

[09:43] <tylercurtis> Anyway, good night, #perl6. Really, this time.

[09:43] <Juerd> tylercurtis: Wanting to try rakudo for a hello world is a good reason.

[09:43] <Juerd> Good night :)

[09:43] <sorear> Juerd: The flip side of this is that I have the only NOPASSWD: unrestricted root sudo

[09:44] *** amkrankruleuen left
[09:44] <Juerd> sorear: I'm not convinced that's good.

[09:44] *** tylercurtis left
[09:44] <Juerd> sorear: I don't really care on feather, but on production machines I disallow the practice.

[09:46] <moritz_> at a first glance, ssh keys + NOPASSWD seems more secure to me than password + password sudo

[09:46] <Juerd> There's no control over whether a user encrypts their keys, and practices good security on their system regarding key agents (e.g. forwarding with gnome keyring's ssh agent means remote servers can do silently allowed automated logins)

[09:46] <Juerd> And this could mean that you can get from nothing to root without any password.

[09:46] <moritz_> that's true

[09:47] <Juerd> On most servers I require a key for logins, and have disabled password logins, and effectively the user password is used only for sudo.

[09:47] <moritz_> .Unable to safely resolve dependencies, try running with --full-resolver. # wow, that never happened to me before

[09:47] <sorear> That's what I would have preferred but couldn't find the knob

[09:47] <Juerd> On feather, there's also e-mail and the protected part of the webserver, that you can't use anymore without your password.

[09:47] <moritz_> that's aptitude output on feather1

[09:48] <Juerd> But feather doesn't have pop3/imap anymore anyway

[09:48] <Juerd> Nobody was using it :)

[09:48] <sorear> Or are you talking about the systemwide knob in /etc/sshd.conf

[09:48] <Juerd> moritz_: Try apt-get instead of aptitude when aptitude fails, and vice versa :)

[09:49] <Juerd> sorear: I usually enforce it system wide, yes.

[09:49] <sorear> /etc/ssh/sshd_config rather

[09:49] <Juerd> sorear: I'm not sure if users can disable password logins for themselves, without disabling their passwords altogether.

[09:49] <moritz_> Juerd: I usually do, it's nice to have the choice :-)

[09:49] *** Chillance joined
[09:49] <moritz_> but it does work with --full-resolver (at least for now)

[09:49] *** amkrankr1leuen joined
[09:49] <moritz_> (and I prefer aptitude, because it logs its actions

[09:53] <sorear> this would be easier if the CPS trampoline didn't thoroughly confuse mono's profiler

[09:59] <moritz_> I can see how that could happen :-)

[10:04] *** QinGW left
[10:09] <jnthn> Makes me glad I didn't do any CPS stuff in 6model. :-)

[10:09] <jnthn> (Don't care too much about modelling control flow at the moment, though, so I can get away with it.)

[10:09] <sorear> aye

[10:10] * sorear needs a metamodel overhaul soon

[10:11] * masak .oO( metasorear object? )

[10:11] *** pugssvn left
[10:12] *** hugme left
[10:12] <sorear> I'll probably save ~25% on parser benchmark runtime by avoiding runtime name lookups for fields

[10:13] *** PerlJam left
[10:13] *** amkrankr1leuen left
[10:14] *** pmichaud left
[10:14] *** pmichaud joined
[10:14] *** Juerd__ joined
[10:14] *** PerlJam joined
[10:15] *** Util_ joined
[10:15] *** Util left
[10:15] *** pugssvn joined
[10:15] *** ChanServ sets mode: +v pugssvn

[10:16] *** Juerd left
[10:16] *** Juerd__ is now known as Juerd

[10:21] *** dukeleto left
[10:22] *** pmichaud left
[10:24] *** PerlJam left
[10:24] *** hatseflats left
[10:24] *** hatseflats joined
[10:28] *** Juerd left
[10:29] *** amkrankruleuen joined
[10:29] *** dukeleto joined
[10:29] *** hatseflats left
[10:29] *** pmichaud joined
[10:29] *** PerlJam joined
[10:30] *** hatseflats joined
[10:34] *** Quadrescence joined
[10:38] *** Zapelius joined
[10:39] *** amkrankruleuen left
[10:39] *** fridim joined
[10:46] *** amkrankruleuen joined
[10:50] *** drbean_ left
[10:53] *** stepnem left
[10:54] *** drbean joined
[10:54] *** stepnem joined
[10:58] *** aCiD2 joined
[10:58] <aCiD2> Does Rakudo have any support for continuations/call-with-cc type stuff?

[10:59] <aCiD2> From what I gather Perl 6 should have it, I wondered if there's anything concrete to play with though

[10:59] *** plainhao joined
[10:59] <masak> aCiD2: have you tried the gather contruct?

[11:00] <aCiD2> I have used that, yea

[11:00] <masak> I think that's the closest you can get in Rakudo at present.

[11:00] <aCiD2> I don't really know what I want to do with continuations yet, so maybe I'm asaking a bad question :)

[11:00] <masak> not at all.

[11:00] <aCiD2> I felt like having a play in the next few evenings. maybe a seaside ish thing, as that's my biggest desire of them

[11:00] <masak> continuations aren't really exposed in Perl 6, though.

[11:01] <masak> I've certainly wished that they were at times.

[11:01] <aCiD2> that's a shame

[11:01] <masak> it's also a design decision.

[11:02] <aCiD2> I was about to ask if it was. So there will never be the "simplicity" (I use that term cautiously on the topic of continuations :)) of call-with-current-continuation in Scheme

[11:02] <masak> well, theoretically someone might provide a module to give you first-class continuations.

[11:05] <aCiD2> but it's never going to part of the language as core

[11:05] <aCiD2> (unless the module got picked up into core, that is)

[11:05] <masak> no, but you're not likely to suffer from the distinction.

[11:05] <masak> unless 'use SomeModule' is hurtful to you somehow.

[11:06] *** thebird left
[11:06] <masak> (which might well be, if you're behind a corporate firewall etc)

[11:06] <aCiD2> in essence no, but that's what they said with perl 5. And now all my modules have to have a stack of use statements before I'm happy with the language ;)

[11:07] <masak> right. that's where the design decisions come in. are continuations core enough?

[11:10] *** amkrankruleuen left
[11:11] *** thebird joined
[11:13] <mathw> That's probably a matter of opinion

[11:13] <mathw> I've never programmed with continuations, but I'm aware they can enable some really cool stuff, but what would be the tradeoff for having them in core, and all that

[11:14] *** Juerd joined
[11:14] <masak> the tradeoff for having them in core would be that you can only faithfully implement Perl 6 on VMs with continuations.

[11:15] *** amkrankruleuen joined
[11:16] *** rhebus joined
[11:16] <mathw> mmm

[11:17] <jnthn> (or you have to do your own CPS atop of that)

[11:17] <jnthn> But yes, it's not a good burden to put on implementors.

[11:18] * mathw feels a "Perl 6 is hard enough already" coming along

[11:18] <jnthn> :P

[11:18] <jnthn> Well. It kinda is. :P

[11:18] <masak> gather postulates, if not full-blown CPS, then at least green threads of some sort.

[11:20] <rhebus> good afternoon

[11:21] <mathw> Hi rhebus

[11:21] <masak> rhebus! \o/

[11:21] *** amkrankruleuen left
[11:21] <rhebus> o/

[11:23] *** Raynes joined
[11:23] <rhebus> i'm thinking of making 99-problems into a dedicated website

[11:24] <rhebus> i think it would be a nice perl6 tutorial

[11:24] <rhebus> which we could point people to for a crash course

[11:24] * masak misses =<> a little

[11:24] <rhebus> i can't promise any action this month though, need to finish my PhD

[11:25] <masak> rhebus: by all means! :)

[11:25] <rhebus> :)

[11:25] <mathw> finishing a PhD

[11:25] <mathw> I find that a very alien concept

[11:25] <rhebus> i don't recommend it

[11:25] <mathw> mine imploded after about 18 months

[11:25] <rhebus> mine ought to have done by all rights

[11:25] <rhebus> but inertia carried me through :)

[11:25] <mathw> some of the lecturers are still missing

[11:26] <rhebus> what was your phd in, criminology? :O

[11:26] <mathw> lol

[11:26] <mathw> dependently typed functional programming

[11:26] <mathw> but I got lost in an algorithm which indicates failure by not returning

[11:26] <masak> awww.

[11:27] <mathw> been running it for four years and it's not returned yet

[11:27] <rhebus> that's... helpful

[11:27] *** cls_bsd_ is now known as cls_bsd

[11:27] <masak> to be fair, one can't know these things beforehand :)

[11:27] <rhebus> one ought to have an idea before one starts though :)

[11:27] <masak> there's a proof somewhere...

[11:27] <mathw> &

[11:27] <rhebus> I discovered recently that the DeathStation 9000 solves the halting problem

[11:29] <rhebus> C++0x compilers are allowed to assume a loop with no extrenally-visible behaviour terminates. which means an infinite loop with no externally visible behaviour invokes undefined behaviour. which means that you can measure if an algorithm terminates by running it on a DS9K and measuring if demons fly out of your nose

[11:32] *** Quadrescence left
[11:33] *** Zapelius left
[11:34] <gfldex> rakudo: my $i = 1; $i = $i++; say $i;

[11:35] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[11:35] <masak> yapsi: my $i = 1; $i = $i++; say $i;

[11:35] <p6eval> yapsi:  ( no output )

[11:35] <masak> :/

[11:36] <gfldex> any demons?

[11:36] <masak> should there be?

[11:36] *** Axius joined
[11:36] <rhebus> does perl6 have a ds9k-compliant implementation?

[11:36] <gfldex> only if p6eval is running in a ds9k

[11:36] <masak> it's imperative programming, not maths. doing $i = $i++ doesn't imply an infinite loop.

[11:37] <rhebus> $i = $i++ is undefined behaviour in many languages, though I don't know about perl 6

[11:37] *** satyavvd joined
[11:37] <rhebus> because it's not defined whether the assignment to $i or the increment of $i takes place first

[11:37] *** amkrankruleuen joined
[11:38] <masak> S03:5062

[11:39] <masak> hm, that's not extremely pertinent.

[11:40] <masak> anyway, I'm pretty sure the semantics of $i = $i++ is nailed down in Perl 6.

[11:40] * moritz_ is pretty sure too

[11:41] <rhebus> the section on Sequence points in S03 doesn't nail it down

[11:41] <moritz_> $i++ is  do { my $tmp = $i; $i.=succ; $tmp}

[11:42] <rhebus> in fact it's pretty explicit under autoincrement precedence: "Also as in C, multiple references to a single mutating object in the same expression may result in undefined behavior unless some explicit sequencing operator is interposed. See "Sequence points"."

[11:42] <rhebus> so unless = provides a sequence point, that nails $i = $i++ as undefined

[11:42] *** Zapelius joined
[11:43] <masak> I disagree.

[11:43] <masak> all that's needed is for the rhs to be fully evaluated before the assignment is made.

[11:43] * moritz_ is pretty sure that item assignment should be a sequence point

[11:43] <masak> and that falls out from precedence.

[11:45] <rhebus> masak: the argument in C is that when i++ is evaluated, the value is guaranteed to be the current value of i, but i is only guaranteed to be incremented "soon" (ie before the next sequence point)

[11:45] <rhebus> so even if i++ is fully evaluated, i may not yet be incremented

[11:45] <masak> rhebus: what moritz_ said about $i++ under the hood.

[11:45] <rhebus> that might be how it's implemented, but it's not what the spec says.

[11:46] <masak> you're right.

[11:46] <rhebus> in particular, there'd be no point in the warning in the spec if moritz_'s definition were universal

[11:46] <rhebus> I am a C language lawyer, this is how I've been trained to think

[11:47] *** Quadrescence joined
[11:47] <rhebus> I don't like relying on the fact that perl's GC is reference-counted, because one of the perldocs explicitly says it may change at a later date. Even though it never will.

[11:48] *** kjeldahl_ left
[11:49] *** envi^home joined
[11:51] * moritz_ thinks that Perl should avoid the pitfalls of undefined behavior wherever possible

[11:51] <rhebus> i think it's somewhat unavoidable with eg junctions

[11:51] <rhebus> but totally avoidable with $i = $i++

[11:51] <masak> it's designed into junctions. don't use them if you want sequence points :)

[11:52] <moritz_> for example in p5, the 'my $x = 1 if 0;' thing is explicitly undefined, and there are questions about it on perlmonks with a frightening regularity

[11:52] <avar> But then you have to define: $i = $i++ + ++$i;

[11:52] <rhebus> avar++

[11:53] <rhebus> i'm not sure how much examples like $i = $i++  or my $x = 1 if 0; matter, they only seem to show up in discussions about sequence poitns

[11:53] <moritz_> junctions have very clear rules about what is defined, and where the compiler has room for optimizations

[11:53] <rhebus> more dangerous are $a +^= $b +^= $a +^= $b and @a[$i] = $i++

[11:53] <avar> It matters in so far that you can optimize things if you leave it undefined.

[11:53] <avar> E.g. what do you do with a tied variable $foo on say "$foo$foo" ?

[11:54] <avar> (there's a discussion about that on perl5-porters)

[11:54] <rhebus> avar: what's the thread title?

[11:54] <avar> "[perl #76438] peephole optimiser could prune more dead code"

[11:55] <avar> Anyway, going with C blindly is also bad, there's a lot of stuff that's undefined in C that was done to appease certain platforms back in the 80s, those platforms are now dead and nobody cares.

[11:55] *** thebird left
[11:55] <rhebus> avar: i couldn't agree more

[11:55] <avar> E.g. NULL not being 0 in all cases, which means you can't memset() memory to 0 and be guaranteed null pointers

[11:56] <avar> But everyone does it these days because in practice it works unless you dust of some 80's hardware

[11:56] *** amkrankruleuen left
[11:57] *** amkrankruleuen joined
[11:57] <avar> E.g. git does that, and hasn't had complaints

[11:58] <rhebus> so the question is, what is important enough to leave undefined, and what is important enough to leave defined?

[11:59] <smash> hello everyone

[11:59] <rhebus> o/

[11:59] <avar> As someone who's implemented sequence points in a C compiler, it probably still matters on modern hardware.

[12:00] <avar> Because you can avoid doing another register lookup for $i

[12:00] <avar> But maybe it doesn't matter enough given all the other bloat in perl6 :)

[12:01] <rhebus> :)

[12:01] <masak> (i) let it be up to implementations to experiment/optimize (ii) discourage users from writing code that is sequence-pointly ambiguous, just 'cus it's a good idea anyway

[12:01] <rhebus> i think Java defined order-of-evaluation of terms to avoid some of these problems

[12:02] <rhebus> masak: does that mean we should spec warnings for sequence point violations? :/

[12:02] <masak> no.

[12:02] <masak> it means that when users write code like that, we tell them why it's bad.

[12:02] <moritz_> that feels more like the task of a lint utility

[12:02] <masak> it's more of a 'community-level warning' :)

[12:03] <rhebus> heh

[12:03] <masak> aye, or lint.

[12:03] <rhebus> or some P6BP book

[12:04] <avar> (i) implies undefined

[12:04] <moritz_> we started a repo with "well thought-out practices"

[12:04] <moritz_> afaict it contains one rule so far :-)

[12:04] <rhebus> avar: it only implies implementation-defined

[12:04] <rhebus> "don't be stupid"

[12:04] <moritz_> but I'm happy with it containing one good rule, instead of many not-so-sound ones

[12:05] <rhebus> or is it "don't be clever"?

[12:05] <moritz_> rhebus: no, much more concrete

[12:05] <moritz_> "use whitespace around infix operators"

[12:05] *** amkrankruleuen left
[12:05] <rhebus> yes that seems reasonable

[12:05] <moritz_> I wonder if should add a second rule

[12:05] <moritz_> "don't base your design on junctions"

[12:05] <masak> :D

[12:05] <moritz_> I'm serious

[12:06] <masak> "don't use junctions if you expect them to be sets"

[12:06] <moritz_> junctions are nice, but beginners overuse them drastically

[12:06] <masak> moritz_: agreed.

[12:06] *** timbunce left
[12:07] <masak> I only use junctions very very locally.

[12:07] <masak> I never store them in variables.

[12:07] <moritz_> I sometimes bind them in signatures

[12:07] <moritz_> for things that expect a smartmatcher

[12:08] <masak> hm, yes.

[12:08] <rhebus> i haven't learned junctions yet

[12:09] <moritz_> that's ok, they aren't very central to Perl 6

[12:09] <masak> well, they're nice in conditionals.

[12:09] <masak> if $a == 3 | 4 | 5

[12:09] <masak> but that's basically all you need to know about them :)

[12:10] <moritz_> unless you start implementing them :-)

[12:10] *** satyavvd left
[12:11] *** amkrankruleuen joined
[12:11] <rhebus> rakudo: say (3|4|5*2).perl

[12:11] <p6eval> rakudo 859f2d: OUTPUT«any(3, 4, 10)␤»

[12:11] <rhebus> rakudo: say ((3|4|5)*2).perl

[12:11] <p6eval> rakudo 859f2d: OUTPUT«any(6, 8, 10)␤»

[12:13] <rhebus> rakudo: say ((3&4|5)*2).perl

[12:13] <p6eval> rakudo 859f2d: OUTPUT«any(all(6, 8), 10)␤»

[12:13] <rhebus> rakudo: say ((3|4&5)*2).perl

[12:13] <takadonet> morning all

[12:13] <p6eval> rakudo 859f2d: OUTPUT«any(6, all(8, 10))␤»

[12:13] <rhebus> afternoon takadonet

[12:16] <moritz_> (to me, the interesting thing was not that the examples above worked, but how they worked)

[12:17] <rhebus> moritz_: in terms of the types and objects generated, or more gritty implementation details than that?

[12:18] *** amkrankruleuen left
[12:19] *** plobsing joined
[12:19] <moritz_> rhebus: in terms of how the (1 | 2) + 3 is re-evaluated as (1 + 3| 2+3)

[12:19] *** amkrankruleuen joined
[12:19] <moritz_> and that it works for user-defined functions too

[12:19] <moritz_> rakudo: sub square($x) { $x * $x }; say square(1|2|3|4)

[12:20] <p6eval> rakudo 859f2d: OUTPUT«any(1, 4, 9, 16)␤»

[12:20] <rhebus> rakudo: say "yes" if 3.all( * > 0, * < 10)

[12:20] <p6eval> rakudo 859f2d: OUTPUT«Too many positional parameters passed; got 3 but expected 1␤  in 'Any::all' at line 1405:CORE.setting␤  in main program body at line 22:/tmp/wBfx8x3RX5␤»

[12:21] <rhebus> is there a way to have a junction of lambdas like that?

[12:22] <moritz_> rakudo: say "yes" if all( * > 0, * < 10).(3)

[12:22] <p6eval> rakudo 859f2d: OUTPUT«yes␤»

[12:22] <moritz_> you need to call your lambdas, too :-)

[12:22] <rhebus> is the dot necessary?

[12:23] <moritz_> no

[12:23] <rhebus> rakudo: say "yes" if all( * > 0, * < 10)(3)

[12:23] <p6eval> rakudo 859f2d: OUTPUT«yes␤»

[12:23] <moritz_> but I like it, because it makes things clearer to me

[12:23] <rhebus> rakudo: say "yes" if 3.&all( * > 0, * < 10)

[12:23] <p6eval> rakudo 859f2d: OUTPUT«yes␤»

[12:23] <rhebus> moritz_: agreed

[12:23] <moritz_> parens can easily be mistaken for grouping

[12:24] <rhebus> wow, perl 6 just does what i mean sometimes

[12:24] <moritz_> when I use subscripting on a longer expression (and not just a variable) I also often use .[1] instead of just [1]

[12:24] <shortcircuit> TimToady: Perl6 has a large number of operators that I'm not familiar with, even with my familiarity with Perl. For example, I don't recognize ^@. Specific examples behind, it might be worthwhile documenting P6 examples as what differentiates them in operators, syntax and flow from P5 examples.

[12:25] <moritz_> rakudo: say (^5).perl

[12:25] <p6eval> rakudo 859f2d: OUTPUT«0..^5␤»

[12:25] <moritz_> rakudo: .say for ^5

[12:25] <p6eval> rakudo 859f2d: OUTPUT«0␤1␤2␤3␤4␤»

[12:28] <rhebus> rakudo: say (^5).WHAT

[12:28] <p6eval> rakudo 859f2d: OUTPUT«Range()␤»

[12:28] <rhebus> why does .WHAT always put brackets after a type?

[12:28] *** amkrankruleuen left
[12:29] <rhebus> rakudo: my @a of Int = (1,2,3); say @a.WHAT

[12:29] <p6eval> rakudo 859f2d: OUTPUT«()␤»

[12:29] <rhebus> huh

[12:29] * masak submits rakudobug

[12:29] *** amkrankruleuen joined
[12:29] <masak> rhebus: in order to distinguish them as stringified type objects, I think.

[12:29] <rhebus> is it possible that they might be parameterised? eg Array(Int)

[12:30] <rhebus> rakudo: my @a of Int = (1,2,3); say @a.perl

[12:30] <masak> probably, but not with that syntax.

[12:30] <p6eval> rakudo 859f2d: OUTPUT«[1, 2, 3]␤»

[12:30] <masak> it's "Array of Int" something.

[12:30] <rhebus> rakudo: my @a = (1,2,3); say @a.WHAT

[12:30] <p6eval> rakudo 859f2d: OUTPUT«Array()␤»

[12:34] <rhebus> masak++ # bug report

[12:34] <masak> :)

[12:34] <masak> rhebus: you're new here :)

[12:34] <rhebus> i don't know what's a bug or not yet

[12:35] *** snearch joined
[12:35] <rhebus> and what's expected but surprising (to me) behaviour

[12:35] <moritz_> rakudo: my Int @a; @a[0] = 2; say @a.of

[12:35] <p6eval> rakudo 859f2d: OUTPUT«maximum recursion depth exceeded␤  in 'at_pos' at line 1␤  in 'at_pos' at line 7:CORE.setting␤  in 'Any::postcircumfix:<[ ]>' at line 1706:CORE.setting␤  in 'at_pos' at line 5:CORE.setting␤  in 'at_pos' at line 7:CORE.setting␤  in 'Any::postcircumfix:<[ ]>' at line

[12:35] <p6eval> ..1706:CORE.settin…

[12:35] <masak> hm.

[12:35] *** bluescreen joined
[12:35] <masak> is that one in RT?

[12:35] <moritz_> rakudo: my Int @a; say @a.of

[12:35] <p6eval> rakudo 859f2d: OUTPUT«Int()␤»

[12:35] <moritz_> masak: there's one for @a.push

[12:35] <moritz_> two actually

[12:35] <masak> ok. sameish.

[12:36] *** amkrankruleuen left
[12:36] *** bluescreen is now known as Guest89164

[12:36] <masak> rhebus: I'll soon be hitting my 1000th rakudobug. also, see http://use.perl.org/~masak/journal/40490

[12:37] <moritz_> masak: you should crawl and save your use.perl.org journal entries

[12:37] <masak> moritz_: I'm on it.

[12:37] <masak> moritz_: I registered a new blog domain today.

[12:38] <moritz_> fwiw, I still have perlblog.org, and not in use

[12:38] <moritz_> although I promised diakopter++ to put it to good use

[12:39] <masak> I have a few plans on my own. :) my hand was forced by the use.perl.org shutdown, but that's probably good.

[12:39] <rhebus> wow, i've only just worked out that ␤ is symbol for newline. It's rendered as two tiny pixelblobs on my machine...

[12:40] <moritz_> .u ␤

[12:40] <phenny> U+2424 SYMBOL FOR NEWLINE (␤)

[12:40] <rhebus> handy

[12:40] <rhebus> .u «

[12:40] <phenny> U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK («)

[12:40] <masak> ✌ <--- handy

[12:40] <rhebus> .u ✌

[12:40] <phenny> U+270C VICTORY HAND (✌)

[12:40] <rhebus> very droll

[12:41] <masak> .u ⼿

[12:41] <phenny> U+2F3F KANGXI RADICAL HAND (⼿)

[12:41] <moritz_> .u ✓

[12:41] <phenny> U+2713 CHECK MARK (✓)

[12:41] <masak> a bit too radical for me...

[12:41] *** amkrankruleuen joined
[12:43] <Sec> I like U+25EF, but can't paste it here.

[12:43] <moritz_> .u 2713

[12:43] <phenny> U+2713 CHECK MARK (✓)

[12:43] <moritz_> .u 25ef

[12:43] <phenny> U+25EF LARGE CIRCLE (◯)

[12:44] <Sec> usefull for printing checklists :)

[12:44] <rhebus> .u 1f4a9

[12:44] <phenny> rhebus: Sorry, no results for '1f4a9'.

[12:45] <rhebus> bah

[12:45] *** timbunce joined
[12:45] *** envi_home2 joined
[12:45] *** Axius_ joined
[12:46] <Sec> ⠎⠑⠒

[12:46] *** envi^home left
[12:46] * moritz_ would like a character that treats the next character as a combining mark, even if it isn't :-)

[12:47] <Sec> moritz: that would so break every tool %-)

[12:47] *** Mowah joined
[12:47] <Sec> (Still, I like that idea)

[12:49] <rhebus> how about a character pair which either ignores or repeats the intervening characters based on some condition?

[12:49] <rhebus> cf [] in brainf*ck

[12:49] <rhebus> lets make unicode turing-complete!

[12:50] *** ash_ left
[12:50] <Alias> And of course, once we've reached THAT point, your registered birth name could be an infectious virus!

[12:50] <moritz_> lol

[12:51] <Alias> Dear "while ( 1 ) { }EOF

[12:54] <rhebus> hehe

[12:55] <rhebus> my non-techie gf just came in and asked why i was chuckling. i tried to explain the joke... it wasn't worth it

[12:55] *** jferrero left
[12:57] <Alias> I imagine she might get the more primitive "Bobby Tables" joke

[12:58] <rhebus> the problem is, if something needs explaining, she will understand it, but she won't find it funny

[12:58] <Alias> true

[12:58] <rhebus> she should just learn programming and be done with it

[12:58] <Alias> Also, the halting problem is extraordinarily boring

[12:58] <Alias> I only got a joke in at all back leveraging the drop table joke :)

[12:59] *** avar left
[13:00] *** tadzik left
[13:04] *** Axius__ joined
[13:04] *** Axius___ joined
[13:07] *** Axius_ left
[13:07] *** Axius left
[13:08] <masak> the people susceptible to halting-problem hacking are long since weeded out by natural selection :)

[13:08] <colomon> rakudo: my @a = 1..5; say (+@a).WHAT; say _^H+@a

[13:08] <phenny> colomon: 07:26Z <moritz_> ask colomon could you maybe change http://github.com/colomon/List-Utils/blob/master/lib/List/Utils.pm#L57 to do a ~~ Numeric test instead? or !~~ Positional maybe?

[13:08] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤Confused at line 22, near "say _\x{7f}+@a"␤»

[13:09] *** Axius__ left
[13:09] <colomon> rakudo: my @a = 1..5; say (+@a).WHAT; say _+@a

[13:09] <colomon> rakudo: my @a = 1..5; say (+@a).WHAT; say +@a

[13:09] *** Axius___ left
[13:09] <p6eval> rakudo 859f2d: OUTPUT«Int()␤Could not find sub &_␤  in main program body at line 22:/tmp/c2o7p4OeFg␤»

[13:09] <p6eval> rakudo 859f2d: OUTPUT«Int()␤5␤»

[13:09] *** Axius joined
[13:09] *** orafu left
[13:09] *** Axius_ joined
[13:09] *** orafu joined
[13:10] *** ash_ joined
[13:11] *** pkkm joined
[13:13] <colomon> is !~~ []   the same as !~~ Positional?

[13:14] * colomon completely fails to understand the List::Utils transpose code.

[13:14] <ash_> rakudo: say [].WHAT

[13:14] <p6eval> rakudo 859f2d: OUTPUT«Array()␤»

[13:14] <colomon> ah, is it specifically checking for the empty Array, then?

[13:15] <ash_> its looking to see if @list is not empty, since @list implied Positional 

[13:15] <ash_> (the param @list) 

[13:15] <ash_> i think

[13:16] <colomon> that seems to make sense

[13:16] <ash_> rakudo: sub f(@a) { say ~@a }; f []; f (); f (1); 

[13:16] <p6eval> rakudo 859f2d: OUTPUT«␤␤Nominal type check failed for parameter '@a'; expected Positional but got Int instead␤  in 'f' at line 22:/tmp/ZVO2iKsBV3␤  in main program body at line 22:/tmp/ZVO2iKsBV3␤»

[13:16] *** Patterner left
[13:17] *** uniejo left
[13:17] *** Psyche^ joined
[13:17] *** Psyche^ is now known as Patterner

[13:17] <ash_> rakudo: sub f(@a) { say @a !~~ [] }; my @b = (); f([]); f(@b); f((1));

[13:17] <p6eval> rakudo 859f2d: OUTPUT«0␤0␤Nominal type check failed for parameter '@a'; expected Positional but got Int instead␤  in 'f' at line 22:/tmp/vYAQSJEumV␤  in main program body at line 22:/tmp/vYAQSJEumV␤»

[13:18] <ash_> rakudo: sub f(@a) { say @a !~~ [] }; my @b = (); f([]); f(@b); f([1]);

[13:18] <p6eval> rakudo 859f2d: OUTPUT«0␤0␤1␤»

[13:18] <ash_> rakudo: say ?[]

[13:18] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[13:18] <ash_> rakudo: say ?[1]

[13:18] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[13:19] <ash_> i think you could just do that, instead of the smartmatch, maybe? /shrug

[13:19] *** Guest23195 left
[13:20] <ash_> rakudo: say [].^methods(:local)

[13:20] <p6eval> rakudo 859f2d: OUTPUT«at_possplicenewperldelete␤»

[13:20] <ash_> rakudo: say [].empty

[13:20] <p6eval> rakudo 859f2d: OUTPUT«Method 'empty' not found for invocant of class 'Array'␤  in main program body at line 22:/tmp/URHamiWfKP␤»

[13:20] <ash_> rakudo: say +[]

[13:20] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[13:20] <masak> ash_: do you want to empty the array, or check if it's empty?

[13:20] <masak> rakudo: say ?[]

[13:20] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[13:21] <moritz_> rakudo: say so []

[13:21] <moritz_> rakudo: say so [0]

[13:21] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[13:21] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[13:21] <ash_> in List::Utils uses @list !~~ [] to check for an empty list, i was thinking you could make that shorter

[13:22] <ash_> rakudo: say ?[1], +[1], ?[], +[] # + or ? seem to do the trick too, 

[13:22] <p6eval> rakudo 859f2d: OUTPUT«1100␤»

[13:22] <masak> !@list checks for emptiness.

[13:23] <ash_> ah

[13:23] <ash_> thats easy too 

[13:23] *** uniejo joined
[13:23] <masak> it's the opposite of ?@list, which checks for non-emptiness :)

[13:24] <masak> of course, nothing is set in stone, and you're permitted to write @list == 0 if you want to emphasize the "no elements" bit for some reason.

[13:24] <moritz_> or not @a.elems

[13:25] * PerlJam finds it hard to believe that List::Utils uses  @list !~~ [] 

[13:25] <ash_> have sockets worked in rakudo yet? 

[13:26] <ash_> http://github.com/colomon/List-Utils/blob/master/lib/List/Utils.pm#L55 

[13:26] <smash> PerlJam: why ?

[13:26] <ash_> it makes sense, just trying to golf it :P 

[13:27] <PerlJam> smash: because that seems crazy in light of simpler mechanisms  :)

[13:27] * moritz_ was more suprirsed about the ~~ Int

[13:27] <PerlJam> I mean, who would think of that first rather than the obvious "array in scalar context" meme?

[13:28] <moritz_> you can simply write   while @list { ... }

[13:28] <smash> PerlJam: maybe there is some obscure reason

[13:28] <moritz_> but @list[0].WHAT.perl ~~ 'Int'  is truely evil

[13:28] <ash_> timtowtdi ?

[13:29] <moritz_> it means it only works for ints, not for other numbers or scalars

[13:29] <smash> moritz_: feel free to rewrite it

[13:29] <smash> the way you want

[13:29] <moritz_> smash: I proposed !~~ Positional, but haven't got around to test it yet

[13:30] <ash_> smash: was there a reason to do ~~ 'Int' ? 

[13:30] <masak> smash: generally, if you're doing .WHAT for non-debugging things, you're on the wrong track.

[13:30] <ash_> i am sure there was, i just don't think i understand it 

[13:30] <masak> smash: the all-caps in .WHAT means "whoa! magic!"

[13:30] <ash_> masak: unless your doing meta programming? maybe? probably not, that still seems bad 

[13:31] <masak> ash_: .WHAT is not the best mechanism for that either...

[13:31] <ash_> ya, that seems like an odd way of doing things 

[13:31] <masak> ash_: here it's used for type checking. just do ~~ Type for that.

[13:31] <moritz_> well, smash++ did the hard parts: the algorithm

[13:31] *** macroron joined
[13:32] <moritz_> now we can fret over the details

[13:32] <masak> indeed. smash++

[13:32] <colomon> I've tested ~~ Numeric here, and it works.

[13:32] <colomon> just haven't had a chance to push it yet.

[13:38] *** Zapelius left
[13:39] *** thebird joined
[13:40] <ash_> is there a way to get a list of classes defined in rakudo? (introspection into world/namespace?) 

[13:41] <ash_> rakudo: say ::.^methods # 

[13:41] *** amkrankruleuen left
[13:41] *** amkrankruleuen joined
[13:41] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[13:41] * masak submits rakudobug

[13:41] <masak> interesting error.

[13:41] <ash_> lol, i didn't expect it to work, but thats not what i expected at all

[13:41] <masak> rakudo: say ::.^foo

[13:42] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[13:42] <ash_> rakudo: say ::.say 

[13:42] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[13:42] <masak> rakudo: say +::

[13:42] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[13:42] <masak> rakudo: say ::

[13:42] <ash_> rakudo: say ::

[13:42] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[13:42] <masak> rakudo: ::

[13:42] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[13:42] <masak> heh.

[13:43] <ash_> well, thats shorter :P 

[13:43] <masak> rakudo: :

[13:43] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤Confused at line 22, near ":"␤»

[13:43] <ash_> rakudo: say GLOBAL.WHAT

[13:43] <p6eval> rakudo 859f2d: OUTPUT«Could not find sub &GLOBAL␤  in main program body at line 22:/tmp/BT2ce1Nu5G␤»

[13:43] <ash_> rakudo: say GLOBAL::say.WHAT 

[13:43] <p6eval> rakudo 859f2d: OUTPUT«Can not find sub GLOBAL::say␤  in main program body at line 1␤»

[13:45] *** azert0x joined
[13:45] *** Holy_Cow joined
[13:45] <ash_> i suppose, i am just curious if you can say, list the subs in a namespace, or list the classes in a namespace, that might be useful 

[13:47] <colomon> smash:  just added you to the List::Utils committers.  

[13:47] <masak> ash_: there are three occurrences of the word 'Stash' in the spec. see those. :/

[13:48] <moritz_> rakudo: my sub foo { }; say callframe().my.keys

[13:48] <p6eval> rakudo 859f2d: OUTPUT«__CANDIDATE_LIST__$!$MAIN&foo$/$_␤»

[13:49] <moritz_> you get the &foo from the current scope

[13:49] <ash_> what about other scopes? like say i wanted to get a list of the classes defined in the Foo namespace? 

[13:49] *** amkrankruleuen left
[13:49] <moritz_> not sure

[13:50] *** uniejo left
[13:51] <pmichaud> GOOD MORNING, #PERL6

[13:51] <pmichaud> oop

[13:51] <pmichaud> s

[13:51] <ash_> rakudo: module F { my sub foo { }; our sub inspect { callframe }; }; say F::inspect;

[13:51] <pmichaud> (caps lock was on?)

[13:51] <p6eval> rakudo 859f2d: OUTPUT«CallFrame()<0x493f780>␤»

[13:52] <ash_> rakudo: module F { my sub foo { }; our sub inspect { callframe }; }; say F::inspect.my;

[13:52] <p6eval> rakudo 859f2d: OUTPUT«$! 17$MAIN 8$/     15$_    13__CANDIDATE_LIST__    1␤»

[13:52] <ash_> rakudo: module F { my sub foo { }; our sub inspect { callframe }; }; say F::inspect.my.keys;

[13:52] <p6eval> rakudo 859f2d: OUTPUT«$/$___CANDIDATE_LIST__$!$MAIN␤»

[13:52] <ash_> interesting, it didn't show foo 

[13:53] <moritz_> because foo is the outer lexpad

[13:53] <moritz_> and not in the inspect sub

[14:01] *** spq1 joined
[14:02] <smash> colomon: thank you, i will delete my List::Utils fork then

[14:03] <colomon> smash: far easier to give you a commit bit than to merge in your changes by hand.  ;)

[14:04] <masak> GOOD MORNING, PMICHAUD :)

[14:04] * ash_ my capslock doesn't work :-( (its remapped to ctrl) 

[14:04] <masak> ditto.

[14:05] <masak> but without the sad smiley :)

[14:05] <ash_> BUT I CANT TALK LIKE THIS (as easily) 

[14:06] <ash_> lol, me on other keyboards is funny, i forget caps locks isn't ctrl by default 

[14:06] <smash> colomon: fair enough  :)

[14:07] *** Axius__ joined
[14:09] *** ash_ left
[14:09] *** Axius left
[14:09] *** Axius_ left
[14:09] <rhebus> when the going gets tough, the tough get their PINKIE FINGERS OUT

[14:10] <pmichaud> 12:37 <moritz_> masak: you should crawl and save your use.perl.org journal entries

[14:10] <pmichaud> is that a simple wget, or is anyone doing something a bit fancier?

[14:12] *** Axius__ left
[14:12] <masak> I'll either base my crawler on wget, or on miyagawa++'s Web::Scraper.

[14:12] <masak> either way, Perl 5.

[14:13] <pmichaud> I guess we lose the comments, or are you planning to scrape those as well?

[14:13] <masak> the latter.

[14:14] <masak> though my new blog won't have hierarchical comments, so I'll have to add "In response to @3"-type annotations.

[14:14] <masak> actually, come to think of it, Web::Scraper is probably a bad fit for this task. I've only been able to get individual values out of it; here I'll need whole DOM subtrees.

[14:15] <masak> maybe some custom TreeBuilder solution will do the trick.

[14:22] *** ash_ joined
[14:34] *** mfollett joined
[14:35] *** wtw left
[14:37] *** foodoo left
[14:45] *** [particle] left
[14:45] *** snearch left
[14:45] *** [particle] joined
[14:50] *** justatheory joined
[14:52] *** aCiD2 left
[15:07] *** patspam joined
[15:10] *** macroron left
[15:19] *** icwiener joined
[15:19] *** icwiener left
[15:19] *** icwiener joined
[15:19] *** felipe joined
[15:20] *** sftp left
[15:21] *** Guest23195 joined
[15:21] *** sftp joined
[15:21] *** Cyrus left
[15:22] *** Cyrus joined
[15:23] *** Cyrus is now known as Guest61068

[15:23] * moritz_ has now mirrored 132M from use.perl.org with a dumb wget -m

[15:23] <masak> ooh

[15:24] <moritz_> but only 30 journal entries from masak++ so far

[15:24] <moritz_> masak: do you happen to know how many you wrote

[15:24] <masak> I think I can find out.

[15:24] <masak> I'm not sure you'll get all comments that way, by the way.

[15:24] <moritz_> I know

[15:25] <masak> I wrote 192 entries.

[15:25] <masak> sorry no, 191 :)

[15:25] <masak> correction, 190 :)

[15:26] <moritz_> thanks

[15:26] <masak> (I grepped the "Delete/Edit Entries" page for "@" characters, and there were two false positives.

[15:26] <masak> )

[15:27] * moritz_ has 140 entries on the perlgeek.de blog

[15:28] <moritz_> I guess the difference is about 2x November :-)

[15:28] *** Guest61068 left
[15:29] <masak> sounds about right :)

[15:43] <masak> moritz_: looking at the list of posts made me realize how easy it'd be to just turn that list into 190 wget invocations. two perl one-liners later, I have all my posts saved. \o/

[15:43] <masak> perl++

[15:43] <bbkr> rakudo: callframe.perl # known_and_NYI or should I report it as TODO? in STD this is valid syntax.

[15:43] <p6eval> rakudo 859f2d: OUTPUT«Method 'perl' not found for invocant of class 'ParrotInterpreter'␤  in <anon> at line 1237:CORE.setting␤  in 'Any::join' at line 1␤  in 'Mu::attribs' at line 1238:CORE.setting␤  in 'Mu::perl' at line 1242:CORE.setting␤  in main program body at line 22:/tmp/cb8i19zxRz␤»

[15:44] <pmichaud> bbkr: it's TODO

[15:44] <masak> pmichaud: it might be nice to know that all that kept me from using the perl6 executable in this case was the lack of -p and -n.

[15:44] <masak> pmichaud: I really miss those. :/

[15:44] <bbkr> pmichaud: but is it already in RT queue? I cannot find it.

[15:45] <pmichaud> bbkr: and I'm not sure that callframe will have a .perl method anyway

[15:45] <pmichaud> at least, not something that gives you a complete serialization of the current call state.

[15:47] <bbkr> pmichaud: I can imagine how hard to implement this would be. but if not - then still error message is LTA.

[15:47] <pmichaud> why?

[15:47] <pmichaud> it's exactly correct.  :)

[15:47] <pmichaud> it's saying the .perl method doesn't exist.  :)

[15:51] <masak> :)

[15:52] <moritz_> adding a method perl() { fail "Can't serialize callframes" } would be pretty easy too

[15:52] <bbkr> pmichaud: because "callframe.WHAT" is "CallFrame" not "ParrotInterpreter". and CallFrame has .perl method.

[15:53] <pmichaud> then callframe.perl should work

[15:53] <pmichaud> does CallFrame have a perl method?

[15:53] *** Ross joined
[15:53] <moritz_> no

[15:53] <pmichaud> I didn't think so. :)

[15:53] <pmichaud> bbkr: why do you claim CallFrame has a .perl method?

[15:53] <bbkr> kudo: CallFrame.new.perl

[15:53] <bbkr> rakudo: CallFrame.new.perl

[15:53] <p6eval> rakudo 859f2d:  ( no output )

[15:54] <pmichaud> rakudo:  say callframe.WHAT;

[15:54] <moritz_> the problem is that callframes can be asked for any information in caller frammes

[15:54] <p6eval> rakudo 859f2d: OUTPUT«CallFrame()␤»

[15:54] <pmichaud> rakudo:  say callframe.perl;

[15:54] <p6eval> rakudo 859f2d: OUTPUT«Method 'perl' not found for invocant of class 'ParrotInterpreter'␤  in <anon> at line 1237:CORE.setting␤  in 'Any::join' at line 1␤  in 'Mu::attribs' at line 1238:CORE.setting␤  in 'Mu::perl' at line 1242:CORE.setting␤  in main program body at line 22:/tmp/gpGpYkiUr1␤»

[15:54] <pmichaud> okay, I'll accept that the error message is wrong here.

[15:54] <moritz_> rakudo: my $x = 3; sub f() { callframe() }; say f().callframe(1).my.<$x>

[15:54] <p6eval> rakudo 859f2d: OUTPUT«Null PMC access in isa_pmc()␤  in '&infix:<=>' at line 1␤  in 'CallFrame::my' at line 7047:CORE.setting␤  in main program body at line 22:/tmp/fbPsP822sC␤»

[15:55] * bbkr reports LTA message in callframe.perl

[15:55] <moritz_> rakudo: say callframe().callframe(1).my.perl

[15:55] <pmichaud> rakudo:  say CallFrame ~~ Any

[15:55] <p6eval> rakudo 859f2d: OUTPUT«Null PMC access in isa_pmc()␤  in '&infix:<=>' at line 1␤  in 'CallFrame::my' at line 7047:CORE.setting␤  in main program body at line 22:/tmp/62V8r4TT0p␤»

[15:55] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[15:56] *** sahadev joined
[15:56] <moritz_> that isa_pmc NPA is new, I think

[15:56] <moritz_> ie it worked when I implemented it, back in the days :-)

[15:56] * masak submits rakudobug

[15:57] <pmichaud> why are we getting a ParrotInterpret...... oh, I see the problem.

[15:57] <pmichaud> The problem isn't with CallFrame.perl, it's with  CallFrame's  $!inter.perl

[15:57] <pmichaud> $!interp.perl

[15:57] <pmichaud> the default .perl is attempting to call .perl on all of the attributes

[15:58] <moritz_> rakudo: say pir::getinterp__p() ~~ Mu

[15:58] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[15:58] <moritz_> rakudo: say pir::getinterp__p() ~~ Any

[15:58] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[15:58] * masak now has all his use.perl.org comments saved locally, too

[15:58] <pmichaud> so, we just need a .perl for CallFrame that does something more reasonable, like fail.  :-)_

[15:58] <masak> :)

[15:59] * moritz_ thinks his next blog post will be about the (non-)sense of "protected" attributes

[16:00] <masak> moritz_: maybe you've been reading the same FQA entries as I have :)

[16:00] <masak> moritz_: that link was great by the way. thanks.

[16:00] <moritz_> masak: actually I haven't read them all

[16:00] <masak> me either. I hand-picked some topics of interest.

[16:00] <moritz_> masak: but I thought about the problem in-depth before after we had some discussions about it here in the channel

[16:02] <masak> looking forward to the post.

[16:04] *** Raynes left
[16:04] *** Raynes joined
[16:09] *** kjeldahl left
[16:10] <bbkr> rakudo: my $f = pir::open__PSS("perl6", "w"); say so pir::istrue__IP($f); # this looks like serious security hole in "safe" mode :(

[16:10] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[16:10] *** patspam left
[16:10] *** kjeldahl joined
[16:10] <bbkr> open is blocked but pir::open not

[16:12] <moritz_> I know; it's a tradeoff

[16:12] <moritz_> I could block all pir:: and Q:PIR{}

[16:12] <moritz_> and would make lots of interesting demonstrations impossible

[16:13] <moritz_> since you need a lot of insider knowledge to exploit it, I hope it happens sufficiently seldom

[16:15] <TimToady> then perhaps you should delete that comment from the log :)

[16:16] <TimToady> BTW, I added explanations to http://rosettacode.org/wiki/Matrix_multiplication#Perl_6 as suggested by shortcircuit++

[16:16] <bbkr> moritz_: I see that try.rakudo.org is protected :) and IRC bot is now indeed used only by P6 developers.

[16:17] <TimToady> is planetsix.perl.org at all related to use.perl.org?

[16:18] * TimToady wonders if it will shut down too...

[16:18] <moritz_> TimToady: no; it just collects some use.perl.org journals

[16:18] <Juerd> Is the past tense in "in Perl 5 this choice had to be made" intentional?

[16:19] <TimToady> it's probably needlessly provocative, thanks

[16:19] <shortcircuit> masak: If my experinces in #perl on FreeNode are any pointer, 'community-level' warnings may be a bad idea. :(

[16:19] *** ruoso joined
[16:19] <Juerd> TimToady: It's interesting how that leaves needed provocation as an option :)

[16:24] *** halharold joined
[16:25] <TimToady> Juerd: Indeed, there's no way around it.  People are often provoked by the suggestion that there might be a gospel that they haven't grokked yet, whether or not it's true.  :)

[16:25] <shortcircuit> TimToady: Nice explanation. Does the X operator work for more than two dimensions?

[16:25] <TimToady> supposed to, but doesn't work in rakudo yet

[16:25] *** halharold left
[16:26] <shortcircuit> Is the order of processing of the first and second ranges specced, or might it vary from implementation to implementation (or run to run), given the same two ranges?

[16:26] <TimToady> perl6: say (<a b> X <c d> X <e f>).perl

[16:26] <p6eval> rakudo 859f2d: OUTPUT«No applicable candidates found to dispatch to for 'infix:<X>'. Available candidates are:␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/30Nzq_CQyn␤»

[16:26] <p6eval> ..pugs: OUTPUT«(("a", "c", "e"), ("a", "c", "f"), ("a", "d", "e"), ("a", "d", "f"), ("b", "c", "e"), ("b", "c", "f"), ("b", "d", "e"), ("b", "d", "f"))␤»

[16:26] <TimToady> specced

[16:26] <ash_> rakudo: my @a = 1, 2, 3; say ^@a;

[16:26] <TimToady> pugs does it right

[16:26] <p6eval> rakudo 859f2d: OUTPUT«012␤»

[16:27] <Juerd> Oh my. [X] will kill computers!

[16:27] <ash_> alpha: say (<a b> X <c d> X <e f>).perl

[16:27] <p6eval> alpha 30e0ed: OUTPUT«["a", "c", "e", "a", "c", "f", "a", "d", "e", "a", "d", "f", "b", "c", "e", "b", "c", "f", "b", "d", "e", "b", "d", "f"]␤»

[16:27] <ash_> is that wrong? 

[16:27] <Juerd> Looks correct.

[16:27] <TimToady> except for the lack of parcels

[16:27] <ash_> it flattened, but i think it produced the right thing 

[16:28] <ash_> alpha could handle @ X @ X @, just hasn't made its way into master

[16:29] <shortcircuit> Ok, last question. How does/will P6 work, as far as multithread? Could a for (or foreach) have its work dispatched to multiple cores (or, conceivably, other processing back-ends)?

[16:30] <TimToady> certainly, any lazy list can be pipelined, and any explicitly parallel operator such as a hyperoperator or junction can be vectorized

[16:30] <shortcircuit> Cool. :)

[16:31] <TimToady> the operations may be done in any order as long as the structure of the results is preserved

[16:38] *** cdarroch joined
[16:38] *** cdarroch left
[16:38] *** cdarroch joined
[16:40] <rhebus> what's the usual extension for a perl 6 module?

[16:40] <ash_> .pm is what i have seen the most

[16:42] *** tylercurtis joined
[16:43] <masak> .pm6 is recognized as an extension too. I tend to use .pm

[16:43] <TimToady> we use .pm6 where there might be Perl 5 modules in the same directory

[16:43] <TimToady> such as in perl6/std

[16:44] *** cjk101010 left
[16:46] *** kcwu left
[16:48] *** am0c^ joined
[16:50] *** am0c^ left
[16:51] *** dakkar left
[16:52] *** icwiener_ joined
[16:52] *** icwiener left
[16:56] <rhebus> rakudo: my %v = Set.new(<a b c>)

[16:56] <p6eval> rakudo 859f2d: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 5004:CORE.setting␤  in main program body at line 22:/tmp/j0wKjmZefu␤»

[16:57] <rhebus> shouldn't I be able to put a Set in a %var?

[16:57] <rhebus> since Set does Associative?

[16:58] *** thebird left
[16:58] <moritz_> yes, I think so

[16:59] <rhebus> should I email rakudobug then?

[16:59] <rhebus> (having first searched...)

[17:00] <moritz_> yes

[17:00] * masak is not sure how to make that work

[17:01] <[Coke]> what would %v look like? a=>1 ... ?

[17:01] <rhebus> a Set is a Hash of Bool

[17:01] <[Coke]> so True instead of 1, then?

[17:01] <moritz_> right

[17:02] <TimToady> well, KeySet is a Hash of Bool; a Set is an Enum of Bool

[17:02] <rhebus> a KeySet is a KeyHash of Bool

[17:03] <TimToady> yeah, that

[17:03] <rhebus> and Enum does Associative too

[17:05] <TimToady> rakudo: my %s := Set.new(<a b c>); say +%s

[17:05] <p6eval> rakudo 859f2d: OUTPUT«Can't take numeric value for object of type Set␤  in 'Any::Numeric' at line 1386:CORE.setting␤  in main program body at line 7072:CORE.setting␤»

[17:07] <rhebus> rakudo: my %s := Set.new(<a b c>); say %s{a}.perl

[17:07] <p6eval> rakudo 859f2d: OUTPUT«Could not find sub &a␤  in main program body at line 22:/tmp/fgQ8k8_nBZ␤»

[17:07] <TimToady> std: my %s := Set.new(<a b c>); say %s{a}.perl

[17:07] <p6eval> std 32123: OUTPUT«===SORRY!===␤Undeclared routine:␤      'a' used at line 1␤Check failed␤FAILED 00:01 119m␤»

[17:07] <rhebus> i'm really confused

[17:07] <TimToady> hmm, thought that had a better message

[17:07] <TimToady> you want %s<a>

[17:07] <rhebus> ooh

[17:07] <rhebus> rakudo: my %s := Set.new(<a b c>); say %s<a>.perl

[17:08] <p6eval> rakudo 859f2d: OUTPUT«Bool::True␤»

[17:08] <rhebus> rakudo: my %s = Set.new(<a b c>); say %s<a>.perl

[17:08] <p6eval> rakudo 859f2d: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 5004:CORE.setting␤  in main program body at line 22:/tmp/xIMeJ8zwEH␤»

[17:08] <moritz_> rakudo doesn't type-check on binding to % and @ variables yet

[17:08] <moritz_> rakudo: my @a := 1; say @a.perl

[17:08] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[17:08] <rhebus> so it works, but for the wrong reason? :)

[17:09] <TimToady> you should be able to bind a Set to %s

[17:09] <moritz_> rhebus: right :-)

[17:09] <TimToady> though I still think prefix:<+> oughta work on a Set

[17:10] * TimToady wonders what role .elems comes from

[17:10] <moritz_> Cool

[17:10] <TimToady> does Elementary...

[17:10] <TimToady> no, wait...

[17:10] <moritz_> or maybe both Positional and Associative

[17:11] <TimToady> anyway, prefix:<+> should probably come for free any time .elems does

[17:12] <rhebus> might there be Positionals/Associatives which don't do .elems?

[17:12] <TimToady> rakudo: say Set.new(<a b c>) + 2

[17:12] <p6eval> rakudo 859f2d: OUTPUT«Can't take numeric value for object of type Set␤  in 'Any::Numeric' at line 1386:CORE.setting␤  in 'infix:<+>' at line 7072:CORE.setting␤  in main program body at line 22:/tmp/OMeqqLT5oE␤»

[17:12] <moritz_> rhebus: there might be some that die if you call .elems

[17:13] <TimToady> a given type can always override

[17:13] <moritz_> rhebus: for example if you implement a network distributed key/value database, it might not be feasible to obtain the number of elements in there

[17:13] <rhebus> yeah, that's the kinda thing I was thinking of

[17:13] <moritz_> but you might want to still do Positional

[17:14] <moritz_> so you just write a method elems { fail "Don't know, sorry" }

[17:14] <TimToady> network transparency is overrated :)

[17:15] <TimToady> it should probably return "whatever"

[17:15] *** am0c^ joined
[17:16] <rhebus> does Positional define elems then?

[17:17] <rhebus> or declare or whatever the terminogoly is

[17:17] *** daxim left
[17:17] * moritz_ still thinks both Positional and Associative should both define it

[17:17] <TimToady> more like Iterable, maybe

[17:19] *** Ross left
[17:20] *** Ross joined
[17:21] <TimToady> rakudo: say ?Set.new()

[17:21] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[17:21] <TimToady> rakudo: say ?Set.new('a')

[17:21] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[17:22] <TimToady> rakudo: say Set.new('a').values

[17:22] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[17:23] *** fglock joined
[17:23] <TimToady> rakudo: my %h = { a => 42 }; say +%h

[17:23] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[17:23] <colomon>  rakudo: my %h = { a => 42 }; say %h ~~ Iterable

[17:23] <TimToady> rakudo: my %h := { a => 42 }; say +%h

[17:24] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[17:24] *** PerlPilot joined
[17:24] *** PerlPilot left
[17:24] <colomon> Iterable does in fact define .elems in Rakudo...

[17:25] <rhebus> rakudo: say Set.new('a').keys

[17:25] <p6eval> rakudo 859f2d: OUTPUT«a␤»

[17:26] *** PerlJam left
[17:27] <TimToady> rakudo: say set('a').keys

[17:27] <p6eval> rakudo 859f2d: OUTPUT«Could not find sub &set␤  in main program body at line 22:/tmp/yFekzOQliZ␤»

[17:27] *** PerlJam joined
[17:29] <TimToady> sets don't have special brackets in math notation, do they...

[17:30] <tylercurtis> { }

[17:30] <TimToady> std: { :a :b :c }

[17:30] <p6eval> std 32123: OUTPUT«ok 00:01 114m␤»

[17:30] <rhebus> S = { x | condition }

[17:31] <pmichaud> currently Rakudo defines Set as

[17:31] <pmichaud> class Set does Associative {

[17:31] <pmichaud> which means it's neither Positional nor Iterable 

[17:31] <TimToady> rakudo: say Set.new(<a b c>)

[17:31] <p6eval> rakudo 859f2d: OUTPUT«Set()<0x25eb9e0>␤»

[17:32] <TimToady> rakudo: say ~Set.new(<a b c>)

[17:32] <p6eval> rakudo 859f2d: OUTPUT«Set()<0x493c380>␤»

[17:32] <TimToady> should just be abc in some order

[17:32] <pmichaud> the current implementation doesn't define Str(ingy) either

[17:32] <TimToady> sets are supposed to enumerate to .keys

[17:33] <pmichaud> I suspect the current implementation needs a significant refactor.

[17:33] <masak> I'm willing to help with that. I wrote the original code.

[17:33] <pmichaud> I should probably do the Hash refactoring first.

[17:33] <ash_> rakudo: :: # fun bug 

[17:33] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[17:34] <TimToady> rakudo: my %set := { :a, :b, :c }; say +%set

[17:34] *** masak left
[17:34] <p6eval> rakudo 859f2d: OUTPUT«3␤»

[17:34] <pmichaud> Rakudo's Set does define .Num, apparently.

[17:34] <TimToady> course, that's really a KeySet

[17:34] <TimToady> how come prefix + can't find it then?

[17:35] <pmichaud> It did find it, didn't it?

[17:35] * pmichaud sees "OUTPUT«3>>"

[17:35] <TimToady> that's not a Set, that's just a Hash

[17:35] <pmichaud> oh.

[17:35] <pmichaud> right

[17:35] <TimToady> I was cheating

[17:35] <TimToady> and misdirecting with the name

[17:35] <pmichaud> Set doesn't define .Numeric, apparently.

[17:35] <pmichaud> and it's not given as Cool.

[17:36] <TimToady> sets probably want to be Any listy

[17:36] <TimToady> <a b c>.set

[17:36] <pmichaud> well, once Set does Positional or Iterable it'll likely get the listy things it's supposed to.

[17:37] <pmichaud> I'm guessing it should be Iterable

[17:37] <pmichaud> so it doesn't bind to @-params

[17:38] <TimToady> it might be cool if we could unambiguously overload {} somehow to do sets right

[17:38] <TimToady> { :a :b :c } is almost there

[17:38] <ingy> pmichaud: who is this Str(ingy) of which you speak?

[17:38] <ingy> my nemesis!

[17:38] <pmichaud> ingy: he's got a lot of characters

[17:38] <TimToady> that's the strange ingy; you're the charmed ingy

[17:39] <ingy> \o/

[17:39] <moritz_> http://github.com/moritz/perlgeek.de/blob/master/source/blog-source-en/perl-6/protected-attributes-make-no-sense.txt # my next blog post, for your consideration

[17:39] <moritz_> I'll go shopping, then re-read and publish

[17:39] <moritz_> if you have any critic or suggestions, I'll backlog

[17:40] <pmichaud> moritz_: those are exactly the sorts of discussions I tend to avoid :)

[17:40] <moritz_> pmichaud: I'm younger than you :-)

[17:41] <TimToady> GET OFF MY LAWN, BOTH OF YOU!!!

[17:41] *** rcfox_ joined
[17:41] *** x3nU_ joined
[17:42] <ash_> are private methods inherited? 

[17:42] *** estrabd_ joined
[17:42] *** zostay_ joined
[17:42] *** au|irc_ joined
[17:42] <ash_> or are there private methods? 

[17:42] <jnthn> Sure

[17:42] <jnthn> They're methods.

[17:42] <jnthn> Use submethods if you don't want inheritance.

[17:42] <TimToady> not only are they not inherited, you can't even name them from outside, unless you're trusted

[17:43] <jnthn> TimToady: If you're trusted by a parent class, you can call them on a subclass, no?

[17:43] <jnthn> TimToady: I hope so otherwise you mix a role in which generates an anonymous subclass and then OH NOES you can't see the private method any more. :-)

[17:43] <moritz_> pmichaud: the foremost reason for this blog post is that people often ask why Perl 6 has no protected methods and attributes, so I wrote something to point them to

[17:43] <TimToady> I don't think private method calls are virtual, but I could be wrong

[17:44] <moritz_> pmichaud: (this is the purpose of about a third of my blog posts)

[17:44] <jnthn> TimToady: Is there a good reason for them not to be?

[17:44] <moritz_> efficiency

[17:45] <TimToady> yes, you have to name the class explicitly to call them.   $obj!THAT::CLASS::method

[17:45] <TimToady> that doesn't mean that $obj can't be a subclass though

[17:45] <TimToady> it just means you're calling a private method as a sub in THAT::CLASS

[17:45] <TimToady> so I think it works the way you want

[17:45] <smash> moritz_: 'You users will be...' typo maybe ?

[17:46] <jnthn> TimToady: ah, ok

[17:46] <jnthn> TimToady: Guess in that case it doesn't matter about the mix-in case then.

[17:46] <jnthn> TimToady: We have been calling them unqualified in Rakudo so far.

[17:46] <jnthn> But that's fixable

[17:46] <jnthn> Is $obj!foo a compile-time error 'cus it's unqualified?

[17:47] <TimToady> unqualified means to call the one in *this* class only

[17:47] <tylercurtis> moritz_: I agree with your post, but I'm doubtful that it will actually convince people.

[17:47] *** x3nU left
[17:47] *** x3nU_ is now known as x3nU

[17:47] *** cj_ joined
[17:47] <TimToady> private method calls are sub dispatched really, and the type of $obj has nothing to do with it

[17:47] <colomon> moritz_: The one thing I can think of in favor of protected is the idea it serves as a sort of warning.  "Yes, if you work at it you can get at this, but it isn't part of the official public interface and therefore is subject to change."

[17:47] *** cj left
[17:47] *** au|irc left
[17:48] <jnthn> TimToady: Ah, that's a quite clear way of putting it.

[17:48] *** estrabd_ left
[17:49] *** estrabd joined
[17:49] <jnthn> moritz_: As a data point, protected is a modifier I use quite rarely in the C# stuff I do at $dayjob.

[17:49] <jnthn> It's certainly the least useful one, in my experience.

[17:49] <jnthn> OTOH, I also avoid building large inheritance hierarchies.

[17:50] <ash_> protected methods are the ones that i think a C++ person would complain about the most, protected methods can be used to hide implementation details from the world but not the subclasses, so if you don't want the world to be able to use something, but you do want subclasses to, then protected is what your after 

[17:50] <tylercurtis> ash_: subclasses are the world, generally.

[17:51] <TimToady> protected only makes sense in a world where you can dictate who can or cannot inherit from you

[17:52] <TimToady> "I, class Foo, being in good health and of sound mind, do bequeeth..."

[17:53] * rhebus -> out

[17:54] <pmichaud> and inheritance becomes a lot more expensive in the U.S. starting in 2011 :)

[17:54] <pmichaud> </obscure-congress-cant-get-its-acts-together>

[17:54] *** rhebus left
[17:54] * TimToady plans to die this year, or not at all.

[17:54] <ash_> i guess, in my mind, the idea that you define a public api doesn't settle well if you have to make a function public that is an implementation detail 

[17:55] <tylercurtis> ash_: if it's an implementation detail, you don't want subclasses getting at it, because anyone can be a subclass.

[17:55] <pmichaud> ash_: the real-world analogy is:  "only those who claim to be my relatives can have access to the vault"

[17:55] <TimToady> perhaps what's really going on here is that we don't have 'trusts Any where * ~~ $?CLASS'

[17:57] <TimToady> saying you trust your kids would presumably allow them to use the $obj!meth notation with a dispatcher that can find a parent classes private method

[17:57] <shortcircuit> And we all know kids shouldn't use meth. ;)

[17:57] <pmichaud> TRUST NO ONE!  STAY OFF OF TIMTOADY'S LAWN!  :-)

[17:57] <TimToady> well, that's more or less what we give ADHD kids

[17:58] <pmichaud> or outside of a rehab clinic:  "KEEP OFF THE GRASS"  :-P

[17:58] <shortcircuit> This whole channel has ADHD. :D

[17:59] <TimToady> there's a meth to our mad

[17:59] <pmichaud> I have AD, HD, DC, AC, and I frequently encounter UV.

[17:59] <TimToady> AM and FM as well

[18:00] <TimToady> or do they encounter you?

[18:00] * tylercurtis keeps trying to come up with justifications for protected (at least in C++) and failing.

[18:00] <diakopter> a GM encountered my VW

[18:00] <ash_> ya, all the C++ reasons for using protected come more from limitations, or the use of generics where a role could provide a better solution 

[18:01] *** Holy_Cow left
[18:01] <PerlJam> ash_: what are the C++ reasons for using protected?

[18:01] <PerlJam> (I never was convinced that "protected" made enough sense in C++)

[18:01] <pmichaud> one often needs protection from their offspring.  :-)

[18:01] <ash_> hiding implementation details from the world but not subclasses 

[18:02] <shortcircuit> IMO, 'protected' makes sense for functions, but not data members.

[18:02] <PerlJam> shortcircuit: why?

[18:02] <tylercurtis> ash_: in what circumstance can the world see your class without being able to subclass it?

[18:03] <TimToady> it is said the Bjarne himself says he would not put protected in now

[18:03] <TimToady> [citation needed]

[18:03] <shortcircuit> PerlJam: My particular use cases tend to involve helper functions.

[18:03] <[particle]> what is this, wikipedia?

[18:03] <TimToady> you never know

[18:03] <pmichaud> "protected considered harmful"  :-)

[18:03] <PerlJam> "TimToady said ..."  Is that a good enough citation? :)

[18:04] <colomon> tylercurtis: there are hacky tricks to make a C++ class "final"

[18:04] <TimToady> "protected considered gullible"

[18:04] <pmichaud> "Even More Language Designer Greatest Mistakes"

[18:04] <ash_> tylercurtis: for instance in C++ Stl, they use _Deque_base in deque as well as list and vector 

[18:04] * pmichaud can imagine a "Top Ten" program on this topic on the Discovery Channel :)

[18:04] <TimToady> me sees titles scrolling upward

[18:04] <ash_> but they had to expose some implementation details so they subclasses could finish filling them in 

[18:05] * PerlJam grabs his copy of "The Design and Evolution of C++" off the shelf to see what Bjarne has to say about protected (if anything)

[18:05] *** patspam joined
[18:05] <TimToady> yours only on CD for $29.95

[18:05] <pmichaud> PerlJam: Hey, gimme my book back!  :-P

[18:05] <PerlJam> pmichaud: this one is *my* book  :)

[18:06] <PerlJam> though I do see 4 or so that are likely yours 

[18:06] <TimToady> I didn't heard that he said that in the book, though...

[18:06] * pmichaud checks his bookshelf... "Oh, you're right.  Here's my copy."

[18:07] <PerlJam> Aha!  Page 301 tells us who we can blame for "protected"

[18:07] * shortcircuit wonders what's slamming his server so hard.

[18:07] <colomon> Mark INton

[18:07] <colomon> Linton

[18:07] <colomon> (also on page 301)

[18:07] <pmichaud> and apparently he banned its use five years later :)

[18:07] <ash_> the government? or is that to common of an answer? 

[18:07] <pmichaud> "they had become a huge source of bugs"

[18:07] <ash_> :P

[18:08] <pmichaud> aha, citation!

[18:08] <TimToady> [citation no longer needed]

[18:08] <pmichaud> "In retrospect, I think that protected is a case where "good arguments" and fashion overcame my better judgement"

[18:08] <colomon> that refers to protected data, as of the writing of this book Bjarne was still in favor of protected member functions.  (page 302)

[18:09] <ash_> protected only makes sense on methods, to me anyway 

[18:09] <ash_> protected data seems weird

[18:09] <pmichaud> ah, yes, in the previous paragraph:  

[18:09] <pmichaud> "I still consider protected a fine way of specify operations for use in derived classes."

[18:10] <TimToady> well, I think we can say that perhaps 'trusts' can be extended somehow someday to wildcard to derived classes, and leave it at that

[18:11] <ash_> trusts Nobody; 

[18:11] <tylercurtis> ash_: I agree with Stroustrup when he says (http://www2.research.att.com/~bs/bs_faq2.html#abstract-class) that those sort of hierarchies(the _Deque_base thing) are bad design.

[18:12] * moritz_ corrects a grammaro noted by masak++, and publishes the blog post

[18:13] <pmichaud> trusts none(Any)  :-P

[18:13] <pmichaud> trusts Any(Nil)  

[18:13] <pmichaud> er,

[18:13] <pmichaud> trusts any(Nil)  

[18:14] <PerlJam> trusts none ()  

[18:14] <PerlJam> :-)

[18:14] <PerlJam> oh, I guess that would be backwards

[18:14] <moritz_> trusts * where False;

[18:14] <TimToady> DERIVATION { use MONKEY_TYPING; augment $?PARENT { trusts $?KID; } }

[18:14] <dukeleto> howdy fine perl6 peeps

[18:14] <pmichaud> dukeleto: what about the rest of us?  ;-)

[18:14] <moritz_> all is fair if you MONKEY_TYPE

[18:15] <tylercurtis> ash_: by the way, lack of roles is no excuse for anything in C++. C++'s weird mishmash of weird kinds of inheritance and template features trivially supports traits(but no renaming or exclusion).

[18:15] <colomon> looking at my $work code, I seem to have used public and private about 5000 times, and protected 34 times.  Given that, I'd certainly be comfortable with just working around the lack of protected in Perl 6.

[18:15] <dukeleto> rakudo: my $g = grammar Foo { rule TOP { \d+ } }; say $g.WHAT

[18:15] <PerlJam> "working around"?!?

[18:15] <p6eval> rakudo 859f2d: OUTPUT«Code()␤»

[18:16] <dukeleto> why is the WHAT of a grammar Code() ?

[18:16] <pmichaud> dukeleto: you're getting the block, not the grammar itself.  possibly a bug.

[18:16] <ash_> rakudo: my $g = grammar { }; say $g.WHAT

[18:16] <p6eval> rakudo 859f2d: OUTPUT«()␤»

[18:16] <pmichaud> rakudo:  my $c = class Foo { ... };  say $c.WHAT;

[18:17] <p6eval> rakudo 859f2d: OUTPUT«error:imcc:syntax error, unexpected ')' (')')␤     in file 'EVAL_10' line 37303565␤===SORRY!===␤syntax error ... somewhere␤»

[18:17] <PerlJam> nice

[18:17] <pmichaud> rakudo:  my $c = class Foo { };  say $c.WHAT;

[18:17] <p6eval> rakudo 859f2d: OUTPUT«Code()␤»

[18:17] <ash_> err, well my grammar was assigned to $g it just doesn't have a name

[18:17] <dukeleto> i see the same behavior when i return a grammar from a function

[18:17] <ash_> rakudo: grammar Foo { }; my $g = Foo; say $g.WHAT;

[18:17] <p6eval> rakudo 859f2d: OUTPUT«Foo()␤»

[18:18] <ash_> rakudo: grammar Foo { }; my $g = Foo; say $g.WHAT, $g ~~ Foo;

[18:18] <pmichaud> dukeleto: for the same reason, likely.  the blocks used for grammars and classes are immediate blocks when used as statement-level context.

[18:18] <p6eval> rakudo 859f2d: OUTPUT«Foo()1␤»

[18:18] <PerlJam> rakudo: my $g = grammar Foo { }; say $g.WHAT;

[18:18] <p6eval> rakudo 859f2d: OUTPUT«Code()␤»

[18:18] <dukeleto> should I submit this as a rakudobug and add a spectest, or am I using things incorrectly?

[18:18] <pmichaud> dukeleto: I'm saying I'm not sure what the spec says (or should say) here.

[18:18] <dukeleto> what else returns Code for it's WHAT?

[18:19] <pmichaud> you could submit it for spec clarification

[18:19] <dukeleto> pmichaud: ok, just trying to clarify :)

[18:19] *** patspam left
[18:19] *** patspam joined
[18:19] <dukeleto> pmichaud: how does one submit something for spec clarification?

[18:19] <ash_> p6 language mailing list? possibly 

[18:19] <dukeleto> TimToady: do you have a ruling on this?

[18:19] <pmichaud> dukeleto: either send to p6l, or send to rt with '[spec]'  in the subject line

[18:19] *** Ross left
[18:20] <pmichaud> (where send to rt == [email@hidden.address]
[18:20] *** Ross joined
[18:21] <dukeleto> does $x.WHAT ever return "Grammar", for some object $x ?

[18:21] <dukeleto> just wondering

[18:22] <moritz_> only if you call Grammar.new()

[18:22] <ash_> rakudo: grammar Foo {}; say Foo.^parents; 

[18:22] <tylercurtis> rakudo: say Grammar.WHAT;

[18:22] <p6eval> rakudo 859f2d: OUTPUT«Grammar()Cursor()Regex::Cursor()Any()Mu()␤»

[18:22] <p6eval> rakudo 859f2d: OUTPUT«Grammar()␤»

[18:22] <moritz_> rakudo: grammar A { }; say A.HOW

[18:22] <p6eval> rakudo 859f2d: OUTPUT«GrammarHOW()␤»

[18:22] <ash_> Foo is a grammar 

[18:22] <ash_> sub-class of 

[18:22] <moritz_> dukeleto: you identify a grammar by  ~~ Grammar

[18:22] <moritz_> dukeleto: Grammar is just a class that all grammars inherit from

[18:22] <ash_> tylercurtis: the main issue in the sample you linked, with the class Shape is all the member's are virtual functions, so making something protected in that context is wrong since it isn't an implementation detail, but if one of those methods did have an implementation, then it could make sense to add protected methods, i'd still argue protected data is wrong though 

[18:23] <tylercurtis> ash_: your example also included protected data.

[18:23] <ash_> how so? 

[18:23] <dukeleto> moritz_: i am hacking on PL/Perl6, and deciding how to marshall return values of Rakudo functions to Postgres datatypes

[18:23] <moritz_> dukeleto: and writing 'grammar A { }' is very nearly the same as 'class A is grammar { }'

[18:24] <ash_> rakudo: class A is grammar { } # just wondering

[18:24] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Routine $r, Any :default($default)!)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤:(Mu $type where ({ ... }), Any

[18:24] <p6eval> ..:rw($rw)…

[18:24] <ash_> rakudo: class A is Grammar { }

[18:24] <moritz_> sorry, is Grammar

[18:24] <p6eval> rakudo 859f2d:  ( no output )

[18:24] <TimToady> seems a bit odd for a class to return code though

[18:24] <tylercurtis> ash_: http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.3/a00702.html includes a protected data member: _M_impl

[18:25] <moritz_> tylercurtis: known (and submitted) bug

[18:25] <moritz_> erm, meant TimToady 

[18:25] <TimToady> arguably should return the .HOW

[18:25] <tylercurtis> Or, is that not required by the standard?

[18:26] <ash_> tylercurtis: i'd image you could factor the protected out

[18:26] <ash_> no, those are implementation details, thats just how libstdc++ decided to implement it

[18:27] <ash_> you don't even have to have a _Deque_base template, the std only defines the deque class 

[18:27] <ash_> s/class/template class/

[18:28] *** jhuni joined
[18:28] <dukeleto> moritz_: (just clarifying) is the Grammar.WHAT == "Code" bug known, or should I submit it for spec clarification ?

[18:29] <moritz_> dukeleto: known

[18:29] <dukeleto> moritz_: cool, thanks :)

[18:30] <dukeleto> moritz_: do spec tests exist for it? I am excited to exercise to commit to the spectests in their new git hom

[18:31] * dukeleto needs more coffee

[18:31] <moritz_> dukeleto: not sure

[18:31] <dukeleto> moritz_: ok, i will look and add some if I don't see any

[18:31] *** patspam left
[18:33] <TimToady> sliding-window looks wrong to me; I think it should take @values (decontainerized) each time, not the individual elements, so as not to prejudge whether the user wants a flat list or a slice list

[18:34] <TimToady> in http://github.com/colomon/List-Utils/blob/master/lib/List/Utils.pm

[18:34] <colomon> ah

[18:35] <colomon> I think I avoided that mostly because I've found flat versus slice to be a troublesome distinction thus far.

[18:36] <colomon> (and it seems like it still remains a major point of discussions between you and pmichaud...)

[18:37] <PerlJam> colomon: but the conservative thing would be to take @values (to maintain structure), and let the user flatten if needed.

[18:37] <TimToady> I don't think this part is in doubt

[18:37] <PerlJam> colomon: because it's really hard to go the other way  :)

[18:38] <TimToady> and you will appreciate it more when slice actually gets implemented, I suspect

[18:39] *** tadzik joined
[18:39] <tadzik> oh hello

[18:41] <colomon> huh.  If I "take @values", all my tests work fine, but the actual generated structures contain a bunch of arrays:

[18:41] <colomon> ([1, 2], [2, 3], [3, 4], [4, 5])

[18:41] *** jhuni left
[18:42] <tadzik> rakudo: class A {}; class B is A {}; # what's wrong with this one?

[18:42] <sorear> right

[18:42] <p6eval> rakudo 859f2d:  ( no output )

[18:42] <tadzik> hrm

[18:42] <tadzik> Illegal redeclaration of symbol 'A' here

[18:42] <sorear> rakudo: my @a = 1,2; my @b = 3,4; say (@a,@b).elems; say (@a,@b).perl;

[18:42] <p6eval> rakudo 859f2d: OUTPUT«4␤([1, 2], [3, 4])␤»

[18:42] <sorear> totally to be expected

[18:43] <TimToady> colomon: maybe take @values.list

[18:43] <pmichaud> colomon: repeat after me:  arrays are not lists.  :-)

[18:43] <pmichaud> well, they are lists, but they're not eqv list :)

[18:43] <TimToady> might make more sense to return slices

[18:43] <pmichaud> anytime you put things into an array, you're flattening and itemizing the contents of the list

[18:44] <pmichaud> fwiw,  take @a[*]   might work.

[18:44] *** patrickas joined
[18:44] <TimToady> wait, this is on a list, nevermind

[18:44] <pmichaud> and   @a[*].Seq is likely to work also.

[18:44] <colomon> pmichaud: "anytime you put things into an array, you're flattening and itemizing the contents of the list" makes no sense to me.

[18:44] <colomon> anytime you put lists into an array?

[18:44] <pmichaud> colomon: yes.

[18:45] <pmichaud> arrays either destroy structure (flattening) or make it concreate (itemizing)

[18:45] <pmichaud> which is why they're not typically appropriate for use internally in list operators

[18:45] <pmichaud> *concreate

[18:45] <pmichaud> *concrete

[18:46] <pmichaud> grrrr

[18:46] <TimToady> maybe @values := list; while take @values[^$n] { @values.munch }

[18:46] <dukeleto> does Rakudo's Code inherit from Parrot's Sub? 

[18:46] <colomon> The code in question is (after TimToady's suggestion) gathering Arrays.

[18:46] <jnthn> dukeleto: No, it has-a

[18:46] <colomon> That appears to be generating exactly what I would want, given only a few quick experiments...

[18:46] <pmichaud> okay.

[18:47] *** CoCo joined
[18:47] *** CoCo left
[18:47] *** CoCol joined
[18:47] <pmichaud> I'm saying that the act of taking things out of @a and putting them into @values is going to impose a new structure on whatever was coming in from @a

[18:48] <colomon> on the other hand, I've certainly no objection to figuring out how to return a List of (something more basic that Array).

[18:48] <TimToady> see mind bind above for an alternative

[18:48] <TimToady> s/mind/my/

[18:48] <colomon> @values := list; (etc)?

[18:48] <colomon> you're suggesting that as a replacement for the entire algorithm?

[18:48] <TimToady> pretty miuch

[18:49] <TimToady> *!i

[18:49] <dukeleto> jnthn: from C, i am seeing that when returning a Grammar, it ISA Sub, not a Code

[18:49] <colomon> will that destroy the @a being passed in?

[18:49] <TimToady> @a is a list, surely

[18:50] <TimToady> or you can force it to be a list, as you do already

[18:50] <dukeleto> jnthn: when using Parrot_PMC_isa(interp,pmc)

[18:51] <pmichaud> my $list = @a.iterator.list;

[18:51] <TimToady> but the whole point of lists is to be destroyed

[18:51] <pmichaud> while $list.elems >= $n {

[18:51] <TimToady> ack no

[18:51] <pmichaud> well, yes, we don't want to use .elems

[18:51] <TimToady> sliding window should work on an infinite list

[18:52] <colomon> yes, infinite lists are important to me.  :)

[18:52] <pmichaud> anyway, it's

[18:52] <TimToady> just let .[^$n] reify what it needs to

[18:52] <colomon> oooh, I need a test on that.

[18:52] <pmichaud> oh, right.

[18:52] <pmichaud> so

[18:52] <pmichaud>     my $list = @a.iterator.list;   # might be shorter someday

[18:53] <TimToady> the doubtful part of my pseudocode is that it would return a False .[^$n]

[18:53] <pmichaud>     gather loop { take $list[^$n]; $list.shift; }

[18:53] <colomon> that's "generate a list based on the iterator for walking across @a", yes?

[18:53] <PerlJam> the window only slides one element at a time?

[18:53] <colomon> aha, yup, current code is broken.  

[18:53] <colomon> PerlJam: yes

[18:53] <jnthn> dukeleto: Yeah, it's just a side-effect of the way we do the code-gen at the moment.

[18:53] <TimToady> how do we catch .[^$n] running off the end?

[18:53] <jnthn> dukeleto: I almost fixed it once, but ran into some other side-issue

[18:54] <pmichaud> TimToady: this is where we need that construct that asks "do you have at least $n elems"  again

[18:54] <jnthn> dukeleto: I'll take care of it when I do the other upcoming OO changes, I expect.

[18:54] <pmichaud> I don't know that we ever solidified its name

[18:54] *** alester joined
[18:54] <jnthn> .icanhas

[18:54] <PerlJam> jnthn: surely that's .icanhaz

[18:54] <pmichaud> we speculated that it could be an argument to .eager

[18:55] <pmichaud> i.e.,   .eager(3)

[18:55] * patrickas is deleting code from the list operator like there is no tomorrow!

[18:55] <TimToady> .eager(3) == 3  ?

[18:55] <pmichaud> yes

[18:55] <TimToady> last unless .eager(3) == 3

[18:55] <jnthn> PerlJam: Or plzcanhaz :-)

[18:55] <pmichaud> but that goes against what we were saying yesterday for .eager as snapshot

[18:56] <TimToady> .force(3) == 3

[18:56] <TimToady> .reify(3) == 3

[18:56] <pmichaud> (well, except that eager would presumably return a snapshot of the 3 elements it eagered)

[18:56] <TimToady> it's very primitive

[18:56] <TimToady> .premunch(3)  :)

[18:56] <pmichaud> (in which case .eager(3) == 3 would work )

[18:56] <dukeleto> jnthn: awesome, thanks for the explanation. i may add some spec tests for it, if there are none

[18:56] <jnthn> dukeleto: Feel free

[18:57] <jnthn> dukeleto: I fixed it for roles and lexical and anon classes

[18:57] <jnthn> I forget what came up when I tried to fix it for package ones

[18:57] <jnthn> It's probably fixable with a little effort

[18:57] <TimToady> so eager is really .eager(*)  # you decide  ?

[18:57] * colomon likes .icanhaz

[18:57] <pmichaud> TimToady: that's what we were speculating, yes :)

[18:57] <jnthn> But I'm going to be tearing the whole thing up and re-doing it in a month or two anyway.

[18:57] <TimToady> it might be worthwhile to keep the concepts apart until we see that they really do unify

[18:58] <pmichaud> TimToady: I'm fine with that ... I just need a name :)

[18:58] <pmichaud> haselems

[18:58] <TimToady> .really(3)  :)

[18:58] <pmichaud> .atleast(3)

[18:58] <TimToady> that implies == 3

[18:58] <colomon> .atleast   +1

[18:59] <TimToady> .atleast(3) == 1 reads funny

[18:59] <TimToady> and has use cases

[18:59] <pmichaud> .gimme(3)

[18:59] <TimToady> gimme is fine

[18:59] <pmichaud> (we speculated .gimme before also :)

[18:59] <pmichaud> it returns the count or the elements?

[18:59] <TimToady> spiral design, hope it's spiraling inward...

[19:00] <TimToady> it guarantees the return number of elements are reified

[19:00] *** rainerschuster joined
[19:00] <pmichaud> okay

[19:00] <pmichaud> so, if it only reified 2, we get back 2

[19:00] <pmichaud> so sliding window becomes

[19:00] <dukeleto> TimToady: i think the design of Perl 6 is a fractal-shaped strange attractor 

[19:00] <pmichaud> my $list = @a.iterator.list;

[19:01] <TimToady> We know Perl 6 is strange, and hope it's an attractor.

[19:01] <pmichaud> gather while $list.gimme($n) >= $n { take $list[^$n]; $list.shift; }

[19:01] <pmichaud> and since $list[^$n] produces a Parcel, it doesn't force itemization.

[19:02] <TimToady> I suppose gimme can return >= than asked for, especially if you ask for *

[19:02] <colomon> errr, isn't * the one case it cannot return >= asked for?

[19:02] <pmichaud> right, I think gimme should report on how many are accounted for.

[19:02] <pmichaud> colomon: you asked for whatever, it can return whatever.  :-)

[19:02] <TimToady> but also arguable that, if you want that, you should say .gimme($n..*)

[19:03] <TimToady> I guess also arguable that .gimme(3) fails if it can't get exactly 3, and .gimme(^4) means the other thing

[19:03] <pmichaud> I don't know that gimme should be discriminating on an exact match

[19:04] <pmichaud> it seems lower-level than that.  I mean, it's hard to undo the reification in the general case

[19:04] <TimToady> nod, just poking

[19:04] <TimToady> hard integers are good at this level

[19:04] <pmichaud> if we start saying "give me exactly 3 or don't do anything"  we start to get in trouble.

[19:04] <TimToady> .negotiate(3)  :)

[19:05] <pmichaud> lol

[19:05] <TimToady> I can give you 1, and throw in a pack of bubblegum.

[19:06] <pmichaud> (on phone for a bit)

[19:06] *** xinming joined
[19:06] <TimToady> lunch for a bit

[19:07] <[particle]> shave and a haircut

[19:07] <TimToady> also, I think these list functions should mostly be built-ins

[19:07] <dukeleto> rakudo: my $g = new Grammar; say $g.WHAT

[19:07] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤Unsupported use of C++ constructor syntax; in Perl 6 please use method call syntax at line 22, near "; say $g.W"␤»

[19:07] <dukeleto> [particle]: you are alive!

[19:07] <patrickas> is (1..* ... 5), (1, 2, 3, 4, 5), '1..* ... 5'; #Locally passes :-)

[19:07] <dukeleto> What does that error about using a "C++ constructor" mean?

[19:07] <[particle]> dukeleto: buried alive, yes

[19:07] <colomon> TimToady: Feel free to consider List::Utils my way of proposing list functions which should be added to the spec.  ;)

[19:08] *** stepnem left
[19:09] <sorear> dukeleto: new Grammar;

[19:10] <ash_> Grammar.new # is probably what you meant

[19:10] <colomon> changes pushed to List::Utils.  

[19:11] *** stepnem joined
[19:11] <sorear> rakudo: my $g = new Grammar:; say $g.WHAT

[19:11] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤Confused at line 22, near "my $g = ne"␤»

[19:13] <dukeleto> ash_: yes, but do you see how the error is reporting later on?

[19:13] *** dual left
[19:14] <ash_> rakudo doesn't understand indirect method calls yet

[19:14] <PerlJam> dukeleto: that's where it realizes there's an error I guess (after parsing the end of the identifier)

[19:14] <ash_> rakudo: sub new { say $_ }; say new Grammar; 

[19:14] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤Unsupported use of C++ constructor syntax; in Perl 6 please use method call syntax at line 22, near ";"␤»

[19:14] <ash_> ummm is that right? 

[19:14] <ash_> does that mean i can't call a sub new? 

[19:15] <tadzik> ETOOCARINGCOMPILER

[19:15] <ash_> std: sub new { say $_ }; say new Grammar;

[19:15] <p6eval> std 32123: OUTPUT«===SORRY!===␤Unsupported use of C++ constructor syntax; in Perl 6 please use method call syntax at /tmp/UWIzC_1zcH line 1:␤------> sub new { say $_ }; say new Grammar⏏;␤Parse failed␤FAILED 00:01 117m␤»

[19:15] <moritz_> colomon: I've got a non-numeric test case for transpose() in List-Utils... do you want a patch? or pull request? or give me commit bit?

[19:15] <moritz_> surprisingly it passes :-)

[19:15] <ash_> well, it would probably be bad practice to have a sub called new, but still 

[19:16] <PerlJam> ash_: I'd call it a bug 

[19:17] <colomon> moritz_: then clearly you need a better non-Numeric test case!

[19:17] <moritz_> is transpose(([<a b c d e>],[<f>],[<g h i>],[<j k>])), ([<a f g j>],[<b h k>],[<c i>],[<d>],[<e>]), "strange matrix with strings";

[19:17] <moritz_> uhm

[19:18] <moritz_> these tests don't actually test the structure at all

[19:18] <colomon> moritz_: you can haz commit bit.

[19:18] <colomon> and do haz.

[19:18] <moritz_> colomon: thanks

[19:19] * colomon is slightly giddy with excitement that people are paying attention to the quick little module he threw together.

[19:19] <colomon> guess I'll just leave the administration / collaborators page open here for a bit...   <whistles quietly>

[19:20] <pmichaud> std: sub new { say $_ };  say new(Grammar);

[19:20] <p6eval> std 32123: OUTPUT«ok 00:01 117m␤»

[19:20] *** IcyBee joined
[19:20] <pmichaud> rakudo:  sub new { say $_ };  say new(Grammar);

[19:20] <p6eval> rakudo 859f2d: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'new' at line 22:/tmp/CT7uq74adr␤  in main program body at line 22:/tmp/CT7uq74adr␤»

[19:21] <PerlJam> colomon: you could just hand out commit bits to everyone you know and then tell people about it after the fact if you want other hackers  :)

[19:21] <pmichaud> rakudo:  sub new($x) { say $x };  say new(Grammar);

[19:21] <p6eval> rakudo 859f2d: OUTPUT«Grammar()␤1␤»

[19:21] <pmichaud> rakudo++

[19:21] <ash_> so, its a paren thing 

[19:21] <pmichaud> you can have a sub called new, you just can't use it as a listop

[19:21] <colomon> PerlJam: ooo, is there a list of p6 people's github ids?  ;)

[19:22] <moritz_> colomon: the 'perl6' team has a long list :-)

[19:22] <pmichaud> I think only owners can see the 'perl6' team list, though?

[19:22] <pmichaud> or those who self-publicize?

[19:22] * moritz_ has no idea

[19:22] *** CoCol left
[19:23] <moritz_> rakudo: sub a($x, $y) { say "$x|$y" }; say 1, 2 Z.&a 3, 4

[19:23] <p6eval> rakudo 859f2d: OUTPUT«===SORRY!===␤Confused at line 22, near "say 1, 2 Z"␤»

[19:24] <Util_> Perhaps CREDITS needs a new field - GitHub ID?

[19:24] <moritz_> +1

[19:24] <colomon> switch context to perl6, teams, perl6 gets a list of a bunch of us... presumably the rakudo committers? 

[19:24] <pmichaud> no, the perl6 list is different from the rakudo list

[19:25] <colomon> ah.

[19:25] <pmichaud> (rakudo is a separate account)

[19:25] <pmichaud> in particular, being added as a rakudo committer requires a cla

[19:25] <pmichaud> but anyone can be added to the perl6 tam

[19:25] <pmichaud> *team

[19:25] <colomon> I thought it odd that there were so many CLAs out there.  

[19:27] <colomon> well, I've added a few of the usual suspects to List::Utils, and anyone else who wants one is more than welcome to ask.

[19:29] *** timbunce left
[19:30] *** dual joined
[19:30] * moritz_ pushed some better tests for transpose()

[19:30] <colomon> moritz_++

[19:32] <moritz_> http://github.com/perl6/perl6.org/pull/1 can I somehow apply this pull request from the web interface?

[19:32] *** IcyBee left
[19:35] <colomon> moritz_: I wasn't able to figure out a way to do that when I tried yesterday.

[19:35] *** timbunce joined
[19:36] <moritz_> colomon: I've now clicked on 'fork queue', and applied the patch itself there

[19:36] <colomon> really?  sweet!

[19:36] <colomon> errr... where's rakudo's authors file?

[19:36] <ash_>  CREDITS?

[19:37] <moritz_> which is LTA, because if there are many commits associated with a pull request, you have to find all of them yourself

[19:37] <colomon> ash_++

[19:38] *** fglock left
[19:39] *** rschuster joined
[19:40] *** rainerschuster left
[19:40] *** rschuster is now known as rainerschuster

[19:43] *** Chillance left
[19:43] *** Chillance joined
[19:47] <moritz_> unsurprisingly, my blog post has attracked lots of disagreement; surprisingly it has attracked quite a few polite and technical comments on the blog itself

[19:47] <dukeleto> moritz_: which post?

[19:48] <moritz_> dukeleto: http://perlgeek.de/blog-en/perl-6/protected-attributes-make-no-sense.writeback

[19:49] <tadzik> I'd rather have only no private than no protected attributes personally

[19:51] <tadzik> but maybe I get it all wrong :)

[19:52] <moritz_> there's no way to get preferences wrong

[19:52] *** stepnem left
[19:53] <tadzik> well, after seeing all the arguments I doubt if I get the whole concept right. Mind a short discussion?

[19:53] <PerlJam> perhaps I'm just stubborn, but I don't buy the commenters arguments.

[19:53] <patrickas> unless you prefer not to have a preference

[19:53] <moritz_> tadzik: I wanted to encourage discussion with my blog :-)

[19:54] *** stepnem joined
[19:54] <moritz_> PerlJam: they see 'protected' as documentation. That I can agree with

[19:54] <PerlJam> moritz_: sure ... except that not everyone sees it that way.

[19:54] *** mantovani left
[19:55] <moritz_> patrickas: it's fine not have a preference for things you know nothing about, IMHO

[19:55] <ash_> its also away to say "this is usable but not by the general public" to, since not every detail has to be made public but some details are better exposed than not exposed 

[19:55] <huf> cant someone add protected if they really want it? :)

[19:55] <tylercurtis> moritz_: but there are things that much more clearly mean the thing they're trying to communicate.

[19:55] <ash_> i am sure there is a way to emulate protected in perl6 

[19:55] <moritz_> tylercurtis: right

[19:55] <PerlJam> ash_: I'm still fishing for "why would you *want* to?"

[19:56] <moritz_> ash_: sure there is. You can always inherit from ClassHOW and add that behaviour

[19:56] <tadzik> moritz_: well, I think the whole inheritance is about code reuse. So instead of copypasting the code from one class to another, you just inherit from it and change what you want to change, or add some stuff. Now if a class has a private attributes, you have no possibility to mangle it, so the only way to achieve what you want to achieve is to actually copypaste the code, which has no sense. Protected 

[19:56] <tadzik> things are something you can mess with, private are behind closed doors

[19:56] *** TiMBuS left
[19:56] <patrickas> moritz_: It was just a silly joke: it is a way to have a wrong preference if your preference is to not have a preference.

[19:56] <tylercurtis> tadzik: we have roles now for code reuse.

[19:57] <tadzik> hmm

[19:57] <PerlJam> patrickas: you can choose not to decide, but you still have made a choice!

[19:57] <PerlJam> :-)

[19:57] <tadzik> so what are classes and their inheritance about then?

[19:57] <moritz_> tadzik: there are several answers to that. First code reuse is only one goal of OO. Another is robustness by encapsulation. I think that protected hurts the latter

[19:58] <moritz_> tadzik: "Now if a class has a private  attributes, you have no possibility to mangle it, so the only  way to achieve what you want to achieve is to actually  copypaste the code, which has no sense

[19:58] <moritz_> "

[19:58] <moritz_> there is another way

[19:58] <moritz_> no

[19:58] <moritz_> just use the public API

[19:58] <moritz_> which should be powerful enough to enable you do to the stuff you want

[19:58] <moritz_> either by using, or by inherting

[19:59] <moritz_> if it's not, you have bad design

[19:59] <PerlJam> moritz_: I think you hit the nail on the head about protected being a hack to work around API shortcomings.

[19:59] <tylercurtis> tadzik: You can, actually, (well, I'm not sure if you portably can yet, but you will be able to eventually) get at private attributes with ugly MOP-code, I think.

[19:59] *** TiMBuS joined
[19:59] <tadzik> mhm. But isn't private this enforced privacy we dislike? Now private is "oh noes, don't touch!" while protected is rather like "well, if you must..."

[20:00] <moritz_> introspecting private attributes is meant for things like "I want to store this on disc. When I load it again, I'll make sure the class code is the same"

[20:01] <moritz_> so that you don't care about what actually is in the attributes, you treat it as opaque data

[20:01] <moritz_> for example in Java you couldn't write a proper ORM wrapper without introspecting private data

[20:02] <PerlJam> Perl 6 has "enforced privacy" where it makes sense.  You can still get at the private thing and twiddle its innards, but you have to work a little to do it.

[20:02] <moritz_> (in Perl 6 you can do that by creating a different representation, once repr polimorphism is implemented)

[20:02] <ash_> no programming language is 100% safe from people messing with the innards 

[20:02] *** ash_ left
[20:03] <PerlJam> private, public, protected is  more like  black, white, and the one shade of grey we, the language designers, think you will ever need.

[20:03] <moritz_> tadzik: the "well, if you must" is exactly the problem. It's the same as "I can't decide if I want this to part of the API" - but since people *will* use it, it *will* become part of the API

[20:03] <PerlJam> Perl recognizes that the language designer isn't the right person to make the decision about which shades of grey the programmers need.

[20:04] *** pmurias joined
[20:05] <tylercurtis> tadzik: regarding what classes are for, I don't really know, other than monkey_typing and {call,next}{same,with}.

[20:06] <PerlJam> moritz_: Perhaps it's a mechanism of deferral?  I don't know about other languages, but at least with C++ protected means something like "I can't decide right now, so I'll err on the side of private and let subclassers figure out how to make it public-ish if needed"

[20:07] <moritz_> PerlJam: except that protected really means "I erro on the side of public", because the outside world can subclass

[20:07] <PerlJam> (otherwise it's private-ish one level down and really private beyond that)

[20:07] <sorear> "Perl [5] wants you to stay out of your living room because you weren't invited, not because it has a shotgun".

[20:07] <sorear> I still think leading underscores are perfectly adequate privacy

[20:07] <moritz_> PerlJam: and that misconception (that you think it's private, but it's not) is what makes it so dangerous

[20:08] <PerlJam> moritz_: it *is* private for the grandchildren  :)

[20:08] <moritz_> sorear: me too :-)

[20:08] <moritz_> PerlJam: unless they decide they want it public

[20:09] <PerlJam> moritz_: Still, Darwin hasn't ruled completely against protected yet. 

[20:09] <tadzik> so the overall point will be: Roles Reuse, Classes Encapsulate

[20:10] <PerlJam> tadzik: something like that.

[20:10] <PerlJam> roles are horizontal reuse, classes can be for vertical reuse.

[20:10] <PerlJam> (when you really do have a heirarchy)

[20:10] <tylercurtis> sorear: I disagree because that means that subclasses have to know about your class's private attributes to avoid breaking things.

[20:10] * moritz_ has not yet enough experience with roles to share any wisdom

[20:11] <moritz_> tylercurtis: that's a perl 5 specific problem

[20:12] <moritz_> if you had per-class (and not per class hierarchy) attributes, you could still go with underscore as privacy indicator

[20:14] <tylercurtis> moritz_: Right, but leading underscores alone are problematic.

[20:14] *** pkkm left
[20:14] *** Ross left
[20:15] * sorear plans to implement $!Foo::bar in niecza soon

[20:15] <sorear> right now niecza implements a flat namespace for attributes, but this is causing performance problems

[20:15] <tadzik> plenty of OOP thinking for bedtime. Thanks for different points of view :)

[20:16] <moritz_> tylercurtis: they fall into the "we give you enough rope to shoot yourself" category, thus fit splendid into the Perl niche :-)

[20:16] *** patspam joined
[20:16] <moritz_> tadzik: then my blog post was successful :-)

[20:16] <sorear> "We give you enough rope to build a space elevator"

[20:16] * PerlJam starts constructing a gun out of rope

[20:19] <patrickas> colomon: ping

[20:19] <moritz_> PerlJam: be sure to put it in a repo

[20:20] <tylercurtis> moritz_: True. :) But I think it's a good thing to make it easier to not shoot yourself than to shoot yourself.

[20:20] <colomon> patrickas: pong

[20:22] *** rgrau_ joined
[20:22] <[Coke]> (space elevator) does that make Larry Willy Wonka?

[20:22] <patrickas> the new serires refactor is kind of ready :-)

[20:22] <colomon> \o/

[20:23] <patrickas> it passes the following tests (I just commenetd the the ones tha need changing) http://gist.github.com/570893

[20:23] <patrickas> which I will probably work on  tomorrow

[20:23] <patrickas> most importantly we can now have infinite lists on the lhs

[20:24] <patrickas> both 1..* ... 5 and @fib ... 13 now work

[20:24] <PerlJam> [Coke]: no, TimToady is more like Roald Dahl and pmichaud is Willy Wonka and we're all Charlie.

[20:24] * colomon wouldn't wish being Roald Dahl on anyone...

[20:25] <colomon> patrickas: that's really exciting!

[20:26] <patrickas> colomon: (or anyone else) whenever you have time to review / try it out http://github.com/patrickas/rakudo/tree/series-new-spec

[20:26] *** tadzik left
[20:27] <[Coke]> I'm more like the other grandpa from the second movie, I think. he was grumpy. ;)

[20:27] <patrickas> colomon: I still have not worked on the string and unicode stuff, but honestly who uses thoses ;-)

[20:27] <[Coke]> patrickas++

[20:30] <patrickas> new code is about 35% smaller and a good chunk of the ugly stuff is gone (like returning the series type / having special cases for alternating serires ...)

[20:30] <colomon> patrickas: as I understand it, we no longer need to do the @args stuff for the limited series.

[20:32] <colomon> it should just be something like $current ~~ $limit

[20:32] <patrickas> I still have not removed this part, because we still need it when last elem of LHS is Code

[20:32] <colomon> Code also smartmatches

[20:32] <colomon> unless you're seeing something in the spec I'm not.  (which is certainly possible)

[20:33] <patrickas> actually I did not see it...

[20:33] <patrickas> but we only need it for the case where the limit is something like {$^a +$^b > 100}

[20:34] <patrickas> I think the spec does not mention it but does not forbid it either :-(

[20:34] <colomon> patrickas: but that's my point.  I don't think that's allowed anymore.

[20:34] <colomon> the spec explicitly says "Assuming the next candidate value is in $x and the first element of the right side is in $limit, the two operators are implemented respectively as:

[20:34] <colomon>      ...     last($x) if $x ~~ $limit;

[20:34] <colomon>     ...^    last     if $x ~~ $limit;"

[20:34] <colomon> Limit can be Code, too, but only if it just takes one argument.

[20:35] <colomon> (at least as I understand it)

[20:35] <colomon> I mean, $limit can be Code.

[20:35] <PerlJam> 1, 1, * + * ... * > 53

[20:35] <PerlJam> (e.g.)

[20:35] <colomon> The point here is

[20:35] <colomon> rakudo: 35 ~~ * > 23

[20:35] <p6eval> rakudo 859f2d:  ( no output )

[20:35] <colomon> rakudo: say 35 ~~ * > 23

[20:36] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[20:36] <colomon> rakudo: say 35 ~~ * > 40

[20:36] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[20:36] <colomon> errr...

[20:36] <PerlJam> precedence

[20:36] <colomon> rakudo: say 35 ~~ (* > 20)

[20:36] <p6eval> rakudo 859f2d: OUTPUT«1␤»

[20:36] <colomon> rakudo: say 35 ~~ (* > 40)

[20:36] <p6eval> rakudo 859f2d: OUTPUT«0␤»

[20:36] <colomon> there we go.

[20:36] <patrickas> OK then no problem we just confirm with TimToady and I rip out that part too!

[20:37] <colomon> it should make the end case dead easy.  :)

[20:37] <patrickas> phenny: tell TimToady is 1,2,4 ... {$^a + $^b > 100 } still allowed in the new spec ?

[20:37] <phenny> patrickas: I'll pass that on when TimToady is around.

[20:38] *** rainerschuster left
[20:39] *** Guest89164 left
[20:40] <colomon> fail "Need more than one item on the LHS" if @lhs.elems == 1 && $limit ~~ Code

[20:40] <colomon> how does that work?

[20:41] <sorear> 1 ... &opaque

[20:41] <sorear> what comes after 1?

[20:41] <colomon> 2

[20:41] <patrickas> colomon: you are right

[20:42] <patrickas> int he new spec it says we should .succ

[20:42] <TimToady> patrickas: no, limit is only on next candidate value

[20:42] <phenny> TimToady: 20:37Z <patrickas> tell TimToady is 1,2,4 ... {$^a + $^b > 100 } still allowed in the new spec ?

[20:42] <colomon> also, that one element might be Code

[20:42] <patrickas> I think in the old spec we had to guess if we succ or .pred and we could not do that with one elem

[20:42] <TimToady> if you want to base on more than that, you have to last out of the generator

[20:42] *** LoRe joined
[20:42] <sorear> last?

[20:42] <sorear> it's a loop?

[20:43] <patrickas> Thanks, I'll implement that! (probably later tonight).

[20:43] <patrickas> Gotta run now!

[20:43] <colomon> patrickas: sounds to me like there is a test we need to write, because the tests should have caught that case.

[20:43] *** rainerschuster joined
[20:43] <colomon> rakudo: say 1 ... * > 10

[20:43] <p6eval> rakudo 859f2d: OUTPUT«Need more than one item on the LHS␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in 'infix:<...>' at line 885:CORE.setting␤  in main program body at line 22:/tmp/XbrtieGNBN␤»

[20:43] <colomon> rakudo: say 1 ... (* > 10)

[20:44] <p6eval> rakudo 859f2d: OUTPUT«Need more than one item on the LHS␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in 'infix:<...>' at line 885:CORE.setting␤  in main program body at line 22:/tmp/gU9VCtoGy0␤»

[20:45] <colomon> rakudo: say 1, 2 ... (* > 10)

[20:45] <p6eval> rakudo 859f2d: OUTPUT«␤»

[20:45] <colomon> rakudo: say 1, 2 ... (* < 10)

[20:45] <p6eval> rakudo 859f2d: OUTPUT«123456789␤»

[20:45] <colomon> rakudo: say 1 ... (* < 10)

[20:45] <p6eval> rakudo 859f2d: OUTPUT«Need more than one item on the LHS␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in 'infix:<...>' at line 885:CORE.setting␤  in main program body at line 22:/tmp/zSybVN530x␤»

[20:45] <colomon> rakudo: say { (1..6).pick } ... (* < 10)

[20:45] <p6eval> rakudo 859f2d: OUTPUT«Need more than one item on the LHS␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in 'infix:<...>' at line 885:CORE.setting␤  in main program body at line 22:/tmp/0ilBDgFXBe␤»

[20:46] <patrickas> colomon: i'll fix that later tonight. Gotta run now.

[20:46] <patrickas> bye all

[20:46] *** patrickas left
[20:46] <colomon> o/

[20:48] <pmurias> moritz_: the github pugs repo has all the history?

[20:48] <phenny> pmurias: 30 Aug 01:13Z <sorear> ask pmurias I want to fix Mildew after all the changes I've made to STD-CPAN, but I don't see where to start.

[20:48] <phenny> pmurias: 06 Sep 20:12Z <moritz_> tell pmurias if there are any parts of the pugs/mu repo you want extracted into a separate repo, please let me know

[20:48] <pmurias> sorear: hi

[20:49] *** mantovani joined
[20:51] *** pmurias left
[20:52] *** Guest89164 joined
[21:03] *** whiteknight joined
[21:05] *** CoCol joined
[21:08] *** nimiezko joined
[21:09] <colomon> rakudo: say (1..6).pick ... * < 3

[21:09] <p6eval> rakudo 859f2d: OUTPUT«Need more than one item on the LHS␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in 'infix:<...>' at line 885:CORE.setting␤  in main program body at line 22:/tmp/eKQHYGHRLd␤»

[21:09] <colomon> rakudo: say 1, 2, (1..6).pick ... * < 3

[21:09] <p6eval> rakudo 859f2d: OUTPUT«12␤»

[21:09] <colomon> rakudo: say 1, 2, (1..6).pick ... * > 3

[21:09] <p6eval> rakudo 859f2d: OUTPUT«Unable to figure out pattern of series␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in main program body at line 22:/tmp/HmcSgPNvXm␤»

[21:12] <colomon> rakudo: say 1, 2, (1..6).pick ... (* > 3)

[21:12] <p6eval> rakudo 859f2d: OUTPUT«␤»

[21:12] <colomon> rakudo: say 1, 2, (1..6).pick ... (* < 3)

[21:12] <p6eval> rakudo 859f2d: OUTPUT«12␤»

[21:12] <colomon> rakudo: say 1, 2, (1..6).pick ... (* < 3)

[21:12] <p6eval> rakudo 859f2d: OUTPUT«Unable to figure out pattern of series␤  in 'infix:<eq>' at line 1␤  in '_HELPER_generate-series' at line 849:CORE.setting␤  in 'infix:<...>' at line 871:CORE.setting␤  in main program body at line 22:/tmp/uQxUXtLsRa␤»

[21:13] <colomon> oh!

[21:13] <colomon> rakudo: say 1, 2, { (1..6).pick } ... (* < 3)

[21:13] <p6eval> rakudo 859f2d: OUTPUT«12␤»

[21:13] <colomon> rakudo: say 1, 2, { (1..6).pick } ... (* < 3)

[21:13] <p6eval> rakudo 859f2d: OUTPUT«12122␤»

[21:15] <nimiezko> hello

[21:18] <tylercurtis> phenny: ask pmurias is there's a more up-to-date source of information about SMOP and Mildew than http://www.perlfoundation.org/perl6/index.cgi?smop

[21:18] <phenny> tylercurtis: I'll pass that on when pmurias is around.

[21:20] *** Guest89164 left
[21:21] *** tylercurtis left
[21:23] <sorear> thank you, pmurias, for leaving three minutes after getting a question with only a "hi"

[21:25] <rgrau_> hi, I just read moritz_'s post about protected attributes. Is it also true for methods?

[21:26] *** rhebus joined
[21:29] <sorear> rgrau_: define 'true'

[21:29] <rgrau_> no protected methods

[21:29] <rgrau_> only public and private

[21:34] <rgrau_> I suppose there will be some kind of methods that  will be inherited by subclasses but not accessible from the outside, right?

[21:36] *** ruoso left
[21:37] <rhebus> rgrau_: isn't that what protected means?

[21:38] <rgrau_> yeah, but I don't know if attributes are treated in the same way as methods

[21:40] *** timbunce left
[21:45] <rhebus> in most languages, yes

[21:45] *** patspam left
[21:45] <rhebus> is there a way in perl 6 to have a method overridable but not callable from outside? I think that would cover most use cases of protected

[21:46] <rhebus> overridable or aroundable

[21:47] <TimToady> there's always die unless self.does(::?CLASS)

[21:48] <TimToady> in fact, method foo (MyClass $self: @args) is pretty much the definition of protected

[21:49] <TimToady> so it's really a complete non-argument

[21:50] <TimToady> oh, wait, nevermind

[21:50] <jnthn> TimToady: That doesn't mean it can't...right. :-)

[21:51] <dalek> 6model: f8cf789 | mberends++ | java/ (14 files):

[21:51] <dalek> 6model: [java/runtime] non working interim commit of Metamodel classes

[21:51] <dalek> 6model: review: http://github.com/jnthn/6model/commit/f8cf7896b2aaac7593cb9116715e29fc81a5638e

[21:51] <TimToady> it's more like die unless CALLER:<::?CLASS>.does(::?CLASS)

[21:51] <jnthn> Yeah

[21:51] <jnthn> Was trying to write the same thingy but too tired. :-)

[21:51] <TimToady> obviously I should be taking a nap

[21:52] <jnthn> Same, given I've gotta be at work in $other-city in 7 hours

[21:52] <jnthn> It's so unusual for my sleep schedule that I'd just lay awake though, so I'm opting for little sleep. :-)

[21:55] <rgrau_> :q

[21:55] <rgrau_> oops, sorry

[21:56] *** fridim left
[22:01] *** rainerschuster left
[22:02] *** envi_home2 left
[22:03] *** rhebus left
[22:06] *** nimiezko left
[22:11] *** sahadev left
[22:11] *** kjeldahl left
[22:14] *** arnsholt_ joined
[22:15] *** Mowah left
[22:16] *** mfollett left
[22:20] *** arnsholt left
[22:20] *** mantovani left
[22:20] *** xinming left
[22:20] *** cdarroch left
[22:20] *** cls_bsd left
[22:21] *** mantovani joined
[22:21] *** xinming joined
[22:21] *** cdarroch joined
[22:21] *** cls_bsd joined
[22:22] *** Guest23195 left
[22:37] *** tylercurtis joined
[22:38] *** CoCol left
[22:46] *** yrgd joined
[22:48] *** spq1 left
[22:55] *** azert0x left
[22:58] *** rgrau_ left
[23:01] *** icwiener joined
[23:03] *** mantovani left
[23:03] *** xinming left
[23:03] *** cdarroch left
[23:03] *** cls_bsd left
[23:03] *** mantovani joined
[23:03] *** xinming joined
[23:03] *** cdarroch joined
[23:03] *** cls_bsd joined
[23:05] *** icwiener_ left
[23:08] <sorear> hrm

[23:08] <sorear> druid uses type constraints all over the place

[23:10] *** cdarroch left
[23:13] <TimToady> added the pure functional example to http://rosettacode.org/wiki/Matrix_multiplication#Perl_6

[23:35] *** dju joined
[23:35] *** dju_ left
[23:45] <tylercurtis> The typical way to convert to type Str, for example, is to call the .Str method. What would be the way to convert to Bazzle::Fin? Can you have a method named Bazzle::Fin?

[23:45] <tylercurtis> std: class F { method Bazzle::Fin { 1 } }

[23:45] <p6eval> std 32123: OUTPUT«ok 00:01 115m␤»

[23:46] <tylercurtis> rakudo: class Bazzle::Fin {}; class F { method Bazzle::Fin { Bazzle::Fin.new } }; F.new.Bazzle::Fin.perl.say;

[23:46] <p6eval> rakudo 859f2d: OUTPUT«Method 'ACCEPTS' not found for non-object␤  in main program body at line 22:/tmp/NhZSOdVO5z␤»

[23:52] <pmichaud> tylercurtis: it's likely to be  Bazzle::Fin(F $f)

[23:52] <pmichaud> nyi in Rakudo, of course.  :-|

