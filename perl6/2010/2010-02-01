[00:03] *** Guest24562 left
[00:18] *** justatheory left
[00:18] *** payload left
[00:25] *** ihrd joined
[00:25] *** ihrd left
[00:26] *** rgrau left
[00:28] *** mssm left
[00:28] *** lichtkind left
[00:33] *** lestrrat is now known as lest_away

[00:46] *** colomon left
[00:49] *** nihiliad left
[00:49] *** f00li5h left
[00:49] *** Grrrr left
[00:49] *** f00li5h joined
[00:49] *** arnsholt left
[00:50] *** cotto left
[00:51] *** Grrrr joined
[00:58] *** nihiliad joined
[00:58] *** cotto joined
[01:00] *** arnsholt joined
[01:00] *** jferrero left
[01:10] *** meppl left
[01:12] *** justatheory joined
[01:13] *** LaVolta joined
[01:16] *** hudnix joined
[01:17] *** synth left
[01:20] *** payload joined
[01:23] *** colomon joined
[01:24] *** lest_away is now known as lestrrat

[01:26] *** drbean joined
[01:30] *** yinyin joined
[01:39] *** Chillance left
[01:40] *** brianherman joined
[01:41] *** jaldhar joined
[01:41] <brianherman> is perl 6 finished?

[01:41] *** ascent_ joined
[01:43] <Juerd> brianherman: No

[01:43] <Juerd> brianherman: Is Perl 5 finished? :)

[01:43] <brianherman> oh

[01:43] <brianherman> good point

[01:44] *** lestrrat left
[01:44] <brianherman> maybe i mean is perl 6 stable?

[01:44] <brianherman> the best part of perl 6 is that butterfly

[01:44] <brianherman> that thing is cute

[01:45] <diakopter> brianherman: see http://perl6.org/specification/

[01:46] <diakopter> significant parts of the specification are in flux and/or unimplemented and/or conjectural

[01:47] *** lestrrat joined
[01:52] <zorgnax> what keyboard commands do I have available in the rakudo repl?

[01:53] <zorgnax> the history commands dont work (up down C-p C-n)

[01:56] <colomon> zorgnax: up down works fine for me in the REPL...

[02:05] *** fookyou joined
[02:05] <fookyou> test

[02:06] <zorgnax> I'm not sure whats wrong in my setup then. I just did a git pull and rebuilt it so I know everything is up to date

[02:06] <fookyou> Can anyone unban me from #perl?? I dunno why I'm banned.... Just came to the channel after like months...

[02:06] <colomon> zorgnax: what platform?

[02:07] <zorgnax> ubuntu karmic

[02:08] <diakopter> zorgnax: I think you have to build parrot with readline

[02:09] <diakopter> which I'm not sure rakudo does by default

[02:09] <zorgnax> parrot?

[02:09] <diakopter> afk&

[02:09] <zorgnax> I thought that type of functionality would be in the code for perl6

[02:10] *** fookyou is now known as blahnickblah

[02:11] <colomon> zorgnax: it works for me on OS X and CentOS, with Rakudo built with --gen-parrot.

[02:12] <zorgnax> that's all that I did

[02:15] <diakopter> blahnickblah: this channel really doesn't have much to do with #perl

[02:15] <diakopter> blahnickblah: probably someone else using your IP address/block got banned.

[02:15] <blahnickblah> Yeah, just was hoping.... I love using perl and I'm never on freenode, so I dunno why I'm banned...

[02:15] <blahnickblah> I did refresh my ip recently..... I dunno...

[02:15] <diakopter> use the web interface

[02:16] <diakopter> http://webchat.freenode.net/

[02:16] <diakopter> just be sure not to mention you're banned, or else they'll likely kick you :)

[02:16] <blahnickblah> lol

[02:16] <brianherman> lol

[02:17] <blahnickblah> I'll just change my ip?! Maybe it some range that's banned??

[02:17] <blahnickblah> I don't really care enough tho.... I got my question answered in #ubuntu.... But if I did it's probably a range ban anyways...

[02:18] <blahnickblah> Hows perl6 going anyways??!

[02:18] <blahnickblah> Is it gonna be really different??! 

[02:21] *** alester joined
[02:22] *** jaldhar left
[02:23] *** blahnickblah left
[02:37] *** k23z__ left
[02:38] *** brianherman left
[02:40] *** jaldhar joined
[02:52] *** cognominal left
[03:08] *** agentzh joined
[03:11] <sjohnson> "Is it gonna be really different??!"

[03:11] <sjohnson> elegantly phrased question

[04:03] *** LaVolta left
[04:34] *** alester left
[04:37] *** jaldhar left
[04:40] *** jaldhar joined
[04:45] *** justatheory left
[04:47] *** rekhajos joined
[04:52] *** tuxdna joined
[04:52] *** nihiliad left
[05:08] *** LaVolta joined
[05:20] *** cjk101010 joined
[05:43] *** TiMBuS joined
[05:59] *** gabiruh left
[06:06] *** gabiruh joined
[06:16] *** hcchien joined
[06:16] *** hcchien left
[06:31] *** addicted joined
[06:37] *** addicted left
[06:49] *** agentzh left
[06:51] *** tarbo2 joined
[07:19] *** kaare joined
[07:20] *** kaare is now known as Guest75057

[07:31] *** Su-Shee joined
[07:31] *** LaVolta left
[07:32] <Su-Shee> good morning

[07:32] *** Baggiokwok joined
[07:41] *** agentzh joined
[07:44] *** drbean left
[08:03] *** [particle]1 joined
[08:18] *** iblechbot joined
[08:44] *** rgrau joined
[08:59] *** Baggiokwok left
[09:06] *** dakkar joined
[09:09] *** gfldex joined
[09:12] *** drbean joined
[09:13] <moritz_> good morning

[09:14] *** renormalist|work joined
[09:16] *** mtve joined
[09:22] *** renormalist|work left
[09:23] *** renormalist|work joined
[09:27] <diakopter> hi

[09:28] *** Baggiokwok joined
[09:31] <moritz_> how is it going?

[09:33] <jnthn> morning

[09:34] *** k23z__ joined
[09:34] *** moritz_ sets mode: +ooo jnthn diakopter sjohnson

[09:37] *** colomon2 left
[09:45] *** yinyin left
[09:56] *** yahooooo left
[09:57] *** yahooooo joined
[10:02] *** ejs joined
[10:06] *** ejs left
[10:07] *** drbean left
[10:12] *** ejs joined
[10:19] *** ruoso left
[10:27] *** JimmyZ joined
[10:33] *** JimmyZ left
[10:36] *** agentzh left
[10:39] *** renormalist|work left
[10:39] *** renormalist|work joined
[10:46] *** mathw joined
[10:48] *** patspam left
[10:53] *** mssm joined
[11:01] <colomon> morning

[11:12] *** payload left
[11:20] *** lestrrat is now known as lest_away

[11:23] *** TiMBuS left
[11:25] <sjohnson> hi guys

[11:30] <araujo> hello

[11:30] *** mj41 left
[11:31] *** moritz_ sets mode: +C
 
[11:33] *** mj41 joined
[11:33] *** drbean joined
[11:43] *** payload joined
[11:47] *** payload left
[11:48] *** payload joined
[11:50] *** Woody2143 joined
[11:53] *** payload left
[11:54] *** payload joined
[11:55] *** Baggiokwok left
[11:57] *** payload1 joined
[11:58] *** colomon left
[11:58] *** rekhajos left
[12:00] *** payload left
[12:02] *** colomon joined
[12:02] *** payload1 left
[12:03] *** payload joined
[12:08] *** payload left
[12:10] *** LaVolta joined
[12:13] *** Woody2143 left
[12:17] *** bluescreen joined
[12:21] *** lest_away is now known as lestrrat

[12:22] *** uniejo joined
[12:25] *** iblechbot left
[12:26] *** f00li5h left
[12:26] *** f00li5h joined
[12:33] *** cotto left
[12:39] <colomon> > (1..*).map({ last if $_ > 100; $_.say; }).eager

[12:39] <lambdabot>   <no location info>: parse error on input `{'

[12:40] <colomon> now works perfectly in my local copy of ng1.  :)

[12:41] <jnthn> colomon: Nice!

[12:43] *** payload joined
[12:44] *** meppl joined
[12:45] *** plainhao joined
[12:45] *** k23z__ left
[12:46] *** SmokeMachine joined
[12:46] <colomon> though it only works for numbers, because I don't know the Inf equivalent for, say, strings.  (Actually, range iterators only work for numbers, too, because of the dispatch bug.)

[12:47] <colomon> actually, based on the Range spec, it seems like there needs to be some sort of interface where you can determine the min and max possible values for types you can call succ on.

[12:49] *** cotto joined
[12:58] <colomon> ng: say Inf.WHAET

[12:58] <p6eval> ng 22b55c: OUTPUT«Method 'WHAET' not found for invocant of class 'Float'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[12:58] <colomon> ng: say Inf.WHAT

[12:58] <p6eval> ng 22b55c: OUTPUT«Num()␤»

[12:59] *** mberends joined
[13:07] *** pmurias joined
[13:10] <pmurias> in http://svn.pugscode.org/pugs/misc/camelia.txt in line 21 it should be "or any other"?

[13:11] <moritz_> probably

[13:12] <moritz_> oh wait

[13:12] <moritz_> no

[13:12] <moritz_> I think TimToady really meant "only the language"

[13:18] *** uniejo left
[13:21] *** bluescreen left
[13:21] *** bluescreen joined
[13:23] *** mberends left
[13:29] *** bbkr joined
[13:35] <colomon> ng: say 3 lt 5

[13:35] <p6eval> ng 22b55c: OUTPUT«1␤»

[13:35] <colomon> ng: say 11 lt 5

[13:35] <p6eval> ng 22b55c: OUTPUT«1␤»

[13:35] <colomon> Whoops.

[13:35] <bbkr> hi. why there is no news on rakudo.org about 25th release?

[13:36] <moritz_> colomon: what's "Whoops" about that?

[13:36] <moritz_> colomon: that's how string comparison works

[13:36] <colomon> moritz_: ng's Range is always using string comparison to check Range membership.

[13:36] <moritz_> colomon: ouch

[13:37] <colomon> I think I was thinking that lt and gt went with cmp, not leg.

[13:37] <moritz_> colomon: it should use cmp, which is polymorphic

[13:37] <colomon> moritz_: actually, before and after, which are the cmp equivalents of < and > (or vice versa)

[13:37] <colomon> of course, at least for now before and after are implemented in terms of cmp.  :)

[13:38] <moritz_> bbkr: probably pmichaud++ forgot to put up the notice

[13:38] <colomon> This is why I am always a bit suspicious of TDD: 106 tests for basic Range functionality, but none of them could distinguish between comparing two numbers as strings and comparing two numbers as numbers.

[13:39] <moritz_> this is why I think our test suite is way too small

[13:39] <moritz_> in the end no methodology can replace careful thinking

[13:45] <colomon> moritz_: exactly.

[13:49] *** Woody2143 joined
[13:56] *** pmurias left
[13:57] *** jaldhar left
[13:57] *** hicx174 left
[13:57] *** hicx174 joined
[13:59] *** ignacio_ joined
[14:04] *** uniejo joined
[14:07] *** uniejo left
[14:07] *** uniejo joined
[14:11] *** ruoso joined
[14:12] *** synth joined
[14:14] *** k23z__ joined
[14:19] *** jaldhar joined
[14:25] *** ignacio_ left
[14:25] *** drbean left
[14:25] *** hicx174 left
[14:26] *** [particle]1 left
[14:27] <bbkr> "perl6 -v" on 25th release still returns "Copyright 2006-2009, The Perl Foundation.", year should be changed.

[14:29] <moritz_> bbkr: thanks for the hint, I'll change that

[14:30] *** rgrau` joined
[14:30] *** Baggiokwok joined
[14:32] *** ignacio_ joined
[14:34] *** [particle] joined
[14:34] *** iblechbot joined
[14:36] *** hicx174 joined
[14:38] *** uniejo left
[14:38] *** ignacio_ left
[14:42] *** hicx174 left
[14:42] *** hicx174 joined
[14:45] *** ejs left
[14:49] *** ejs joined
[14:53] *** ignacio_ joined
[14:55] *** Exodist joined
[14:55] *** Guest75057 left
[15:02] *** hicx174 left
[15:02] *** PacoLinux joined
[15:04] *** payload left
[15:22] *** hicx174 joined
[15:24] *** wasy joined
[15:28] <sjohnson> another sleepless night

[15:29] <sjohnson> i generated some python -> clipper code translation using perl.  it is good to use perl again

[15:29] <sjohnson> Perl's slogan should be "Perl... is there anything it can't do?"

[15:30] *** pmurias joined
[15:32] *** Baggiokwok left
[15:33] *** hanekomu joined
[15:34] *** Psyche^ joined
[15:35] *** Psyche^ left
[15:35] *** Patterner left
[15:35] *** Patterner joined
[15:36] *** ejs left
[15:40] *** payload joined
[15:41] *** iblechbot left
[15:42] *** k23z__ left
[15:44] *** jferrero joined
[16:00] <pmichaud> good morning, #perl6

[16:02] *** jaldhar left
[16:04] <pmichaud> colomon: ping

[16:06] <sjohnson> hi

[16:06] *** jaldhar joined
[16:08] *** nihiliad joined
[16:16] *** LaVolta left
[16:18] *** payload left
[16:19] *** payload joined
[16:24] <diakopter> moritz_: going well

[16:26] *** ejs joined
[16:37] <diakopter> TimToady: is there really an S09 rewrite pending?

[16:41] <pmichaud> I'd guess that the recent changes to slice design is likely to spill into S09

[16:41] <pmichaud> so, it's not necessarily a rewrite, as much as "figure out how to get S09 to work with new information regarding slices"

[16:42] <diakopter> oh

[16:43] <pmichaud> (which may well end up in being a rewrite :-)

[16:46] *** justatheory joined
[16:47] *** payload left
[16:55] *** mberends joined
[16:57] <colomon> pmichaud: pong

[16:57] <pmichaud> colomon: for Ranges, I don't think we should be converting Whatever into Inf

[16:57] <pmichaud> I think it should remain as a Whatever

[16:57] <colomon> pmichaud: really?

[16:57] <pmichaud> in particular,   (3..*).perl   should probably return   "3..*"   and not "3..Inf"

[16:57] <colomon> will that work better for non-numeric types?

[16:58] <colomon> ng: say 2 < *

[16:58] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[16:58] <pmichaud> it should work better for non-numeric types, yes.... but it's likely also going to be important for    @a[3..*]   handling

[16:59] <pmichaud> in the places where we do comparisons on a range endpoint, we'll need to explicitly check for Whatever

[16:59] <colomon> okay, can do.

[16:59] <colomon> (I was wondering if there was a shortcut around that.)

[16:59] <pmichaud> note that  2 < *   produces a WhateverCode object

[16:59] <colomon> pmichaud: that's what I thought.

[16:59] <colomon> okay, I can have that for you in a few minutes here, I think.

[17:00] <pmichaud> no problem or rush... just wanted to make that opinion known :-)

[17:02] <colomon> yeah, but it's too fun to put off.

[17:02] <colomon> :)

[17:03] <colomon> Is there a better Whatever check than ~~ ::Whatever?

[17:04] <pmichaud> not that I know of

[17:07] <colomon> ng: my $a = *; say $a.perl

[17:07] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[17:08] <colomon> ng: sub foo($a) { say $a.perl; say $a.WHAT; }; foo(*)

[17:08] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[17:11] *** fda314925 joined
[17:13] <colomon> pmichaud: when I try to pass that Whatever to bless, it balks at it with that same "too few positional arguments" message.

[17:14] <colomon> ng: my $a = *;

[17:14] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[17:14] *** fda314925 left
[17:15] <pmichaud> I'm not sure that Whatever has been implemented in ng/ng1

[17:16] <colomon> pmichaud: it was working when I passed it in using 1..* and Range.new converted it to Inf.

[17:16] <pmichaud> ng:  say Whatever.WHAT;

[17:16] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[17:16] <colomon> Huh.

[17:16] <pmichaud> something looks very wrong with whatever there :-)

[17:17] <pmichaud> it may be that the dispatcher is having trouble dealing with threading

[17:17] <pmichaud> sorry, with whatever-dispatch

[17:17] <colomon> yeah, I thought that was just the message  for when it tried to bind it to a closure and failed. 

[17:17] <colomon> (er, whatever the proper term for that trick is.)

[17:18] <pmichaud> anyway, jnthn++ is probably the person to check with on that

[17:18] <pmichaud> we can leave the Inf/-Inf conversions in place for now so that Range "works", but eventually I think it needs to be the type

[17:18] <colomon> okay, maybe I won't have it for you in a few minutes.  :)

[17:19] <colomon> funny thing is, I think I have the right code for the Whatever version already (at least for iteration) but it is full of fail with that issue.

[17:19] <colomon> (I mean, locally, not the version I checked in.)

[17:21] *** fda314925 joined
[17:21] <spinclad> (question: why doesn't 1..* produce a WhateverCode?) (answer: it's special cased.)  (special case smell?)

[17:22] <colomon> spinclad: why should it?

[17:23] <bbkr> ng: my %h = * => "a"; say %h{"this whatever is fake :P"}

[17:23] <p6eval> ng 22b55c: OUTPUT«Confused at line 1, near "my %h = * "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[17:25] <colomon> spinclad: I guess I see 1..* as being not that different from foo(*)...

[17:25] <spinclad> in @a[0..*] (or should that be @a[0..^*]?) it seems it should act as a WhateverCode, taking @a's limit index as argument.

[17:26] <spinclad> but by itself 0..* is supposed to be 0..Inf ... i don't quite see how that works both ways.

[17:26] <pmichaud> spinclad: yes, but you don't typically want     my @a = 3..*;     to act as though you're creating an array with a WhateverCode object

[17:26] <pmichaud> in the case of @a[0..*]  it's not a WhateverCode, it's a Range.  Trying to make it a WhateverCode will in fact be problematic 

[17:27] <pmichaud> because if @a has 10 elements, then    @a[0..10]   is in fact incorrect

[17:27] <spinclad> right, so i wondered 0..^*

[17:28] <pmichaud> * doesn't mean "last element", it means "whatever"

[17:28] <pmichaud> it's probably a mental mistake to try to make it mean "last element"

[17:28] <pmichaud> (or, more precisely, "index of last element"

[17:29] <pmichaud> let me put it this way

[17:29] <pmichaud> we know that for   @a[3..7]  the postcircumfix:<[...]>  needs to be able to handle an argument of type Range

[17:30] <pmichaud> so _that's_ the point at which we check the Range for any whatevers

[17:30] <spinclad> well... inside an index, if it _is_ a WhateverCode, it's handed ... not 'index of last element', but the one after that, the first past the end.

[17:30] <pmichaud> right

[17:31] <pmichaud> if a WhateverCode is passed as a subscript, then we evaluate the WhateverCode with the length of the array

[17:31] <spinclad> right

[17:33] *** fda314925 left
[17:34] *** araujo left
[17:35] <colomon> rakudo: my @a = 1..10; say @a[*-2]; say @a[{$_ - 2}];

[17:35] <p6eval> rakudo 1d4928: OUTPUT«9␤9␤»

[17:35] <spinclad> (otoh, in @a[0..*], with 0..* a Range, it looks like one iterates the Range until one falls of the end of @a, without complaint. ... )

[17:35] <pmichaud> rakudo would seem to have that wrong.

[17:36] <pmichaud> I'm not sure what the second one should've produced.  Possibly it should have not bound at all (no matching multi)

[17:37] <colomon> I was just exploring what would happen if 1..* was the same as { 1..$_ }

[17:37] <spinclad> ng: my @a = 0..9; say @a[0..*]; say @a[0..100]

[17:37] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[17:37] <spinclad> rakudo: my @a = 0..9; say @a[0..*]; say @a[0..100]

[17:37] <TimToady> note that subscripts are defined to not care if their final range runs off the end, so it doesn't matter what * expands to, as long as it's >= elems -1

[17:37] <p6eval> rakudo 1d4928: OUTPUT«0123456789Use of uninitialized value␤␤0123456789Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of

[17:37] <p6eval> ..uninitializ…

[17:38] <TimToady> that does imply keeping the info around somewhere that the final element of the list is a range

[17:38] <spinclad> hm.. interesting difference there.. 0..* stops on first failure, 0..100 keeps going

[17:39] <spinclad> rakudo: my @a = 0..9; say @a[0..^*]

[17:39] <p6eval> rakudo 1d4928: OUTPUT«0123456789␤»

[17:40] <spinclad> huh.  looks like a WhateverCoded Range to me.

[17:41] <spinclad> (btw, in colomon's example, i think the 9's are correct.

[17:41] <spinclad> )

[17:41] *** ejs left
[17:42] <TimToady> rakudo: my @a = <a b c>; say @a[0..10000];  # supposed to work by current spec

[17:42] <p6eval> rakudo 1d4928: OUTPUT«abcUse of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤Use

[17:42] <p6eval> ..of un…

[17:42] <TimToady> see S09:220

[17:42] <spinclad> heh. works fine.

[17:43] *** k23z__ joined
[17:44] <TimToady> *not* fine if you want to interate down the array one slice at a time and merely return a truncated final element

[17:44] <TimToady> *iterate, even

[17:44] *** k23z__ left
[17:46] <TimToady> and the current policy solves the ..* vs ..^* ambiguity by make it not matter

[17:46] <TimToady> I doubt that part of S09 is going to change, even if the rest does...  :)

[17:47] *** pmurias left
[17:47] *** cjk101010 left
[17:49] *** jferrero left
[17:51] *** iblechbot joined
[17:53] <spinclad> rakudo: (0..*).perl.say

[17:53] <p6eval> rakudo 1d4928: OUTPUT«{ ... }␤»

[17:53] <spinclad> (*-1).perl.say

[17:54] <spinclad> rakudo: (*-1).perl.say

[17:54] <p6eval> rakudo 1d4928: OUTPUT«{ ... }␤»

[17:54] *** fda314925 joined
[17:55] <spinclad> (*-1).WHAT.say

[17:55] *** cjk101010 joined
[17:55] <spinclad> rakudo: (0..*).WHAT.say

[17:55] <p6eval> rakudo 1d4928: OUTPUT«!whatever_closure␤»

[17:56] *** rdice joined
[17:57] *** fda314925 left
[18:01] <spinclad> ok, thanks.  so rakudo trunk _does_ make 0..* a WhateverCode, but that's outdated spec, and should indeed be special cased to Range; and trunk likewise doesn't truncate index ranges per spec.  seems sensible design, even with the small bit of special casing.

[18:02] *** kst joined
[18:03] *** Chillance joined
[18:06] <TimToady> well, it should work even if it does return a WhateverCode, as long as the code in question still returns a recognizable range

[18:06] <TimToady> 'tis the truncation that is the key

[18:09] <spinclad> sure

[18:10] <colomon> Is @a[*..5] also supposed to work?

[18:11] <TimToady> no

[18:11] <colomon> why not?

[18:11] <TimToady> truncation is defined only at the end

[18:11] <TimToady> and 0 isn't that hard to type

[18:12] <spinclad> ... but if 0..* be a WhateverCode, then i think other uses of it like  for 0..* {...}  would fail: no argument given to the WhateverCode

[18:12] *** fda314925 joined
[18:13] <colomon> TimToady: isn't it possible to create a Positional whose index range doesn't start at 0?

[18:13] <TimToady> spinclad: unless the argument defaults to Inf

[18:14] <spinclad> aha...

[18:14] <spinclad> @a[*..*]  # robotic grin

[18:14] <lambdabot> Unknown command, try @list

[18:14] *** ShaneC joined
[18:20] <TimToady> colomon: by current spec, .[] is always 0-base, and you use .{} to get something else

[18:20] *** cdarroch joined
[18:20] *** cdarroch left
[18:20] *** cdarroch joined
[18:20] <colomon> TimToady: ah.  okay.  :)

[18:21] <vorner> TimToady: can't you create multi operator and do something else in it?

[18:21] <TimToady> you can do anything you like, with enough work  :)

[18:22] <TimToady> Perl 6 is designed to mutate into any language you like, even if you're into horror...

[18:22] <vorner> but I guess you would handle all the whatevers in it yourself anyway

[18:23] <TimToady> if it comes down to it, you can always write macros or grammar rules

[18:23] <TimToady> or change out the semantic analysis routimes

[18:25] <TimToady> but yes, multiple dispatch is lexically scope, so you can always override those easily

[18:25] <TimToady> *scoped

[18:26] <vorner> Right, I heard that, I just wondered if the axiom that index is 0-based couldn't hurt somewhere

[18:26] <TimToady> hasn't seemed to hurt C that much :)

[18:27] <TimToady> at some point, one just switches to functions instead of subscripts

[18:28] <vorner> but C doesn't have things like whatevers and so on, any zero-based things are done by programmer who knows if he makes the array something-else based

[18:28] <TimToady> S09 just says that something-else-based just uses .{} instead of .[]

[18:28] <TimToady> .[] implies UInt

[18:29] <TimToady> and the type inferencer can depend on that

[18:29] <colomon> Perl 6 has a  type inferencer?!  Cool!

[18:29] <TimToady> in the abstract...

[18:30] <TimToady> nobody's written it yet

[18:30] <colomon> That probably explains why I've not heard of it.  :)

[18:31] <TimToady> but it's all swept under the carpet of "If the compiler is able to detect that something will fail at run time, it may complain at compile time."

[18:31] <jnthn> We only do it in one place in Rakuod so far. :-)

[18:31] <jnthn> *Rakudo

[18:31] <jnthn> (the case of multi fact(0) { 1 } style things)

[18:32] <colomon> jnthn: so, about ng and Whatever....  :)

[18:32] <TimToady> we do not, however *require* type inference, since that also requires the user to be quite sophisticated to do the meta-type-inference

[18:32] <TimToady> see ML etc.

[18:32] <jnthn> colomon: oh noes, what discussion have I just wondered into from while debugging a memory leak... :-)

[18:33] * colomon has an entire collection of half-read functional programming books for much that reason...

[18:34] <jnthn> colomon: I suspect ng may not know a whole load about Whatever yet.

[18:34] <colomon> jnthn: as you can see from the backlog, it gives "too few positional arguments: 3 passed, 4 (or more) expected" almost anytime you do anything with it other than ~~ ::Whatever.

[18:35] <jnthn> colomon: Oh, maybe bit-rot.

[18:35] <jnthn> That could be easily fixable.

[18:36] <colomon> As pmichaud said, jnthn++.  :)

[18:37] <jnthn> For introducing bitrot? ;-)

[18:37] <TimToady> afk &

[18:37] <jnthn> Wow, I got karma for rotting too. :-)

[18:37] <colomon> for knowing how to fix it...

[18:37] <jnthn> I'll try and fix it in a moment...think I know why $work-app is leaking some gigs...

[18:38] <colomon> cool.

[18:43] *** ignacio_ left
[18:44] *** dakkar left
[18:49] *** SmokeMachine left
[18:56] *** jonasbn joined
[18:58] *** ignacio_ joined
[19:00] *** SmokeMachine joined
[19:00] <colomon> pmichaud: one other thing which keeps worrying me about Iterators.  How does @a.map(-> $a is rw { ... }) work?

[19:02] *** stephenlb joined
[19:03] *** rdice left
[19:09] *** REPLeffect joined
[19:12] *** cognominal joined
[19:14] *** cognominal left
[19:14] *** cognominal joined
[19:14] *** user__ joined
[19:15] *** user__ is now known as dr_df0

[19:16] *** ejs joined
[19:17] <dr_df0> perl6: say 'test'

[19:17] <p6eval> elf 29603, pugs, rakudo 1d4928: OUTPUT«test␤»

[19:17] <jnthn> ng: *

[19:17] <p6eval> ng 22b55c: OUTPUT«sh: ./perl6: No such file or directory␤»

[19:18] <jnthn> colomon: ah, not quite what I thought...gotta go for dinner now...actually seems there is two issues, not just one.

[19:18] <jnthn> erm, there are...

[19:18] <colomon> k.  talk to you later, then.  

[19:18] <jnthn> cu

[19:20] <pmichaud> colomon: @a.map(-> $a is rw { ... })  works because the result of iterating @a is each of the elements of @a

[19:21] <colomon> pmichaud: but how does it work wrt iterators?

[19:21] <diakopter> ng: *

[19:21] <p6eval> ng 22b55c:  ( no output )

[19:21] <colomon> pmichaud: I mean, .get is returning a value, right, not a reference to a value.

[19:22] <pmichaud> colomon: no, .get returns the actual container, not a value

[19:24] *** jaldhar left
[19:24] <pmichaud> afk, lunch

[19:25] *** jaldhar joined
[19:34] *** wasy left
[19:34] *** wasy joined
[19:35] *** wasy left
[19:37] *** wasy joined
[19:48] *** payload joined
[19:49] *** araujo joined
[19:52] *** ignacio_ left
[19:52] *** k23z__ joined
[19:54] *** cotto_work joined
[20:01] *** nihiliad left
[20:06] *** ignacio_ joined
[20:13] *** plainhao left
[20:15] <pugs_svn> r29604 | lwall++ | [S02,S06] continue de-confusing flat and eager 

[20:15] <PerlJam> good day all

[20:15] <colomon> o/

[20:21] *** hercynium left
[20:22] *** cognominal left
[20:29] *** dr_df0 left
[20:34] <pugs_svn> r29605 | lwall++ | [S02,S03,S04] more @@ removal; some s/Capture/Parcel/ cleanup 

[20:35] *** mberends left
[20:35] <Tene> ng: say (*+5).WHAT

[20:35] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[20:35] <Tene> ng: say 1..*

[20:35] <p6eval> ng 22b55c: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤current instr.: 'perl6;Code;new' pc 11858 (src/builtins/Positional.pir:169)␤»

[20:36] <Tene> What part of Perl 6 determines that * with .. is different from * with other operators?

[20:37] <ruoso> TimToady, considering "say flat(<1 2> Z <3 4>)" and "say slice(<1 2> Z <3 4>)"... does a simple "say <1 2> Z <3 4>" still flattens?

[20:37] <ruoso> I'm assuming it does, because the signature of say is "(@items)"

[20:37] <ruoso> sorry...

[20:37] <ruoso> it is (*@items)

[20:38] <ruoso> and I somehow think that slurpy does flatten the result

[20:38] <ruoso> er... not result, the parameters...

[20:38] <pmichaud> (the arguments :-)

[20:39] <pmichaud> I haven't read the updates -- but before all of these latest changes I had been thinking that slice(...)  would remove the flattening behavior of any of its arguments

[20:39] *** cdarroch left
[20:39] <ruoso> right... and flat preserves it

[20:39] <ruoso> so what is the default?

[20:39] <pmichaud> actually, I'd think that flat forces it

[20:39] <ruoso> ah... right... 

[20:39] <pmichaud> there are three levels

[20:39] <Tene> "A C<Parcel>s is normally flattened..." -- typo

[20:39] <pmichaud> flat - forces it

[20:40] <pmichaud> slice - denies it

[20:40] <pmichaud> (list)  -- allows it

[20:40] <pmichaud> where  "it" == "flattening"

[20:40] <ruoso> so "sub say(*@items) {...}" will flatten

[20:40] <pmichaud> if the arguments to @items are flattening arguments

[20:40] <pmichaud> but the result of slice() never flattens

[20:40] <ruoso> or will it still depend on how @items is used?

[20:41] <pmichaud> I need to read latest spec updates

[20:41] <pmichaud> on another topic -- I'm thinking that perhaps we just switch ng1 branch to master within 48 hours

[20:42] <Tene> pmichaud: have a list of topics you'd like to see worked on before then?

[20:42] <pmichaud> anything that currently fails "make spectest"  :-)

[20:42] <Tene> I was planning on looking at * tonight.

[20:42] <pmichaud> but short term, I'd like to bring the iterator stuff up-to-spec with the latest changes

[20:42] <pmichaud> whatever would be good also

[20:42] <pmichaud> but I think looking at * isn't much help before we get closures and thunks fixed.

[20:43] * Tene nods.

[20:43] *** sjohnson sets mode: +o PerlJam

[20:48] *** mberends joined
[20:51] <TimToady> I don't have a sig notation for slice context yet, but it might be **@foo, or maybe something liek *@foo! to make it bind like a positional

[20:51] <TimToady> also considering whether -> args should just default to slurpy always

[20:52] <pmichaud> how strongly are you trying to stick with ASCII for slice notation?

[20:53] <pmichaud> I keep thinking of  

[20:53] <pmichaud> oops

[20:53] <pmichaud> §   as a possibility

[20:53] *** cdarroch joined
[20:53] *** cdarroch left
[20:53] *** cdarroch joined
[20:54] <TimToady> well, we'll come up with some way to be explicit about which kind of binding we want, but how to default -> the other way is a problem

[20:54] <pmichaud> I don't quite see the problem with ->

[20:55] <TimToady> you posed it as Pm-19

[20:56] <TimToady> did you see what I wrote?

[20:56] <pmichaud> yes, but let me re-read

[20:57] <TimToady> it just occurred to me that a 3rd approach was to always make -> assume it's in a slurpy setting unless specifically marked otherwise

[20:57] <pmichaud> I would think that if I want a slice that I'd use  (old notation)   --> @@x

[20:57] *** _ash joined
[20:57] <pmichaud> or, more specifically, if I want a non-flattening item

[20:58] <TimToady> yes, but the question is how the default gets to be flattening?

[20:58] <TimToady> ordinary mandatory positionals don't flatten

[20:58] <pmichaud> true, but there we're binding to a parcel instead of an iterator

[20:59] <pmichaud> in the case of map, we're doing repeated binding against an iterator

[20:59] <TimToady> yes, so the binding has to behave differently than an ordinary call

[20:59] <TimToady> how does the binder know that?

[21:00] <pmichaud> (bad guess) ... because it's against an iterator instead of a standard parcel?

[21:01] <pmichaud> i.e., inside of .map, we'd be doing    &block(|$iterator)    instead of  &block(|(parcel))

[21:01] <TimToady> the ordinary call is also binding against the iterator embedded in the Capture

[21:01] <jnthn> It maybe pretends to. ;-)

[21:02] * jnthn has seen captures as rather more low-levelish thingies. :-)

[21:02] <pmichaud> I think that's still a difference --  a binding against an iterator is different from binding to a capture (that has an iterator)

[21:02] <pmichaud> many times we end up performing operations on objects for which the first step is "get an iterator for this object", and the behavior is different than if we were performing the operation directly on an iterator

[21:02] <jnthn> The capture may be Iterable, which means it can provide an iterator, I'm not sure that means it "has an" iterator (as in $.has)

[21:06] <pmichaud> perhaps what I'm trying to say is that I think that binding to a capture should be a "succeed/fail" sort of thing, while binding to an iterator is the way we think of partial binding (more)

[21:06] <jnthn> Anyway, I'm inclined to agree with pmichaud that I'd prefer to see the two separate.

[21:06] <pmichaud> I also feel like this is relevant to the handling of feeds

[21:06] <jnthn> pmichaud: +1

[21:07] <pmichaud> that what gets passed among feeds are iterators with partial bindings, and not completed captures

[21:07] <TimToady> how does map tell the lambda's binding that it's okay to leave extra args?

[21:08] <jnthn> TimToady: Presumably because you invoke with an iterator rather than a capture, no?

[21:08] <pmichaud> yeah, something like that

[21:08] <jnthn> TimToady: Or are you wanting to distinguish it in a different way?

[21:08] <jnthn> colomon: Locally: 

[21:09] <jnthn> > my $a = *; say $a.WHAT

[21:09] <lambdabot>   <no location info>: parse error on input `='

[21:09] <jnthn> Whatever()

[21:09] <jnthn>  /kick lam...

[21:09] <colomon> \o/

[21:09] <pmichaud> jnthn, colomon:  20:40 <pmichaud> on another topic -- I'm thinking that perhaps we just switch ng1 branch to master within 48 hours

[21:09] <TimToady> okay, I'm binding a signature, $x, $y, $z for something.  How does the binding of $y know whether to call .get or .getitem?

[21:10] * colomon stupidly thought lambdabot's response was what jnthn was getting locally...

[21:10] <TimToady> it might be a simple lambda supplied to a map, or it might be the where-the-rubber-meets the road of an ordinary sub or method

[21:10] <colomon> pmichaud: there have been a couple minor changes on ng since ng1, I think. 

[21:10] <TimToady> this has to distribute over the parameters so each one knows whether to .get or .getitem

[21:11] <pmichaud> colomon: presumably they can be merged into ng1/master also

[21:11] <TimToady> it's not the same throughout the signature

[21:11] <jnthn> TimToady: Wait...huh

[21:11] * jnthn is confused now

[21:11] <TimToady> then don't vote +1 :P

[21:11] <colomon> pmichaud: is there a decent chance we can get spectest back to ng levels before making the switch?  it's sort of too broken for regular hacking at the moment.

[21:12] <pmichaud> colomon: is anyone actively hacking on ng?

[21:12] <colomon> pmichaud: I don't think so.

[21:12] <pmichaud> (whether to call .get or .getitem)  ...this is partially why I prefered it to be always .get  (which acts like .getitem), instead of trying to put flattening directly into the iterator

[21:13] *** payload left
[21:13] <TimToady> then you're re-inventing the iterator inside the binder, I think

[21:13] <pmichaud> then .map would handle flatten-versus-not-flatten in what it passed to the lambda

[21:13] <pmichaud> yes, I recognize this is also problematic

[21:13] <colomon> pmichaud: actually, looks like the only patch ng has that ng1 doesn't is turning on spectests.

[21:13] <TimToady> or inside map

[21:14] <TimToady> I'd like a pure view where a signature is a pattern that matches against a supply of values

[21:14] <TimToady> and each parameter knows whether it's supposed to match a parcel or something smaller

[21:15] <TimToady> I'd like map to not care, so you could map with a block with either kind of parameter

[21:15] <jnthn> TimToady: Well, I thought I understood the issue at that point...either a signature sourced its arguments from a capture and exhausted it, or got them from an iterator and didn't care if there was more.

[21:15] <pmichaud> colomon: so, if nobody is actively hacking on ng, I'm saying we should go ahead and abandon its line of development in favor of ng1

[21:15] <jnthn> pmichaud: oh sh...I just pushed a patch to ng.

[21:15] <pmichaud> jnthn: no biggie

[21:15] <pmichaud> jnthn: I did say "within 48 hours"

[21:15] <jnthn> Feel free to cherry pick.

[21:15] <colomon> pmichaud: no real argument there.... (see jnthn++'s whoops!  :)

[21:16] <pmichaud> and yes, I figure there will be some cherry picking

[21:16] <pmichaud> but I also think we might be at a point where it's worthwhile to commit to ng1 as the new master, even if we're not up to date on spectests

[21:16] <TimToady> something has to iterate through the capture's list

[21:16] <colomon> pmichaud: I do think we need to get things cleaned up a bit before pushing ng1 to mainstream, even if it's just turning off failing spectests.

[21:16] <pmichaud> colomon: I'd be okay with that

[21:17] <pmichaud> TimToady: carrying this line of thinking a bit further... when binding to a capture, we do iterate through the capture's list, but that's a bit different from binding to an iterator

[21:17] <TimToady> why?

[21:17] <pmichaud> if only because we have the "you must exhaust the list" flag turned on.

[21:19] <TimToady> that flag is also the negation of the "you are applying this sig repeatedly and the default binding for each parameter should be slurpy" flag

[21:19] <colomon> pmichaud: how about I make a list of the failing spectests (ie ones that worked in ng but not in ng1), we (or just I?) take a quick look at why they are broken, and turn them off if they can't be easily fixed.  then make getting them working again a priority.

[21:19] <pmichaud> colomon: that's easy enough to do (more)

[21:19] <pmichaud> just do "make spectest" in the ng1 branch.  any tests that are failing, mark with two #'s

[21:20] <pmichaud> the spectest.data file in ng1 was taken from the ng branch, so it already comments out the tests that weren't passing in ng

[21:20] <TimToady> whether you reinvent iterators on a level above iterators or not is relatively immaterial, you have to get the bit in there consistently to all kinds of lambdas

[21:20] <pmichaud> it's not just lambdas, is it?  It's really any signature, right?

[21:21] <TimToady> and like subpatterns, maybe the default for lambda's should be that we are a submatch

[21:21] <colomon> pmichaud: roger.  I'll get on it here.

[21:21] *** cognominal joined
[21:21] <TimToady> and default to get semantics rather than getitem semantics

[21:21] <TimToady> for unmarked parameters

[21:22] <jnthn> Gotta go for a bit.

[21:22] *** charsbar_ joined
[21:23] <pmichaud> I feel like we're making a fundamental mistake in the design of .map

[21:23] <pmichaud> not sure where, but the complexity of the solution feels like we might be asking the wrong question

[21:23] <TimToady> map should be very simple

[21:23] <pmichaud> agreed

[21:24] <TimToady> match a sig, turn it into a parcel, repeat

[21:24] *** charsbar left
[21:24] *** bluescreen left
[21:24] <TimToady> no introspection

[21:24] <pmichaud> is the same true for feed operators?

[21:24] <TimToady> ideally

[21:24] <TimToady> the sig already knows it's a submatch somehow

[21:24] <TimToady> and somehow the cursor is maintained

[21:24] <TimToady> over the input stream

[21:24] *** uniejo joined
[21:25] <pmichaud> well, if we think about it in the subrule context, then the sig is always a partial match, and we carp whenever the outer context determines "oh, you didn't match everything".  I.e., the anchor comes from somewhere external.

[21:25] <colomon> pmichaud: actually, this is definitely a good time to switch ng1 to ng, at least, as I keep on wanting to make lazy tests...

[21:25] <mathw> I haven't been paying attention, ng1?

[21:26] <colomon> mathw: ng1 is a branch of ng with laziness.

[21:26] <pmichaud> mathw: ng1 was a temporary branch I created to experiment with lazy list and iteration 

[21:26] <mathw> ooooh

[21:26] <mathw> cool, thanks

[21:26] <pmichaud> mathw: but it's progressed far enough now that I think we're ready to commit to it

[21:26] <mathw> my attention's definitely been elsewhere lately

[21:26] <TimToady> but lambda don't know whether they're submatches by themselves.  it would be like a submatch not knowing whether it should ratchet

[21:26] <colomon> mathw: for instance, this morning, I temporarily had (1..*).map ... working.

[21:27] <mathw> colomon: that is the most exciting thing I've heard this year

[21:27] <pmichaud> TimToady: yes, I see the problem

[21:27] <pmichaud> and it's that problem that makes me think we're looking at this all wrong

[21:27] <TimToady> if somebody writes -> $x, @y {...} we are in trouble if we assume *$x, *@y if he calls it like a normal sub

[21:28] <TimToady> the alternative is to assume slice binding for map and force explicit flattening

[21:28] <pmichaud> or to require .slice for map if slice binding is wanted

[21:28] <pmichaud> (unless you rejected that option)

[21:29] <TimToady> it's just that p5 programmers will expect flatness

[21:29] <TimToady> otoh other language folks might expect non-flat

[21:29] <TimToady> cuts both ways

[21:29] <pmichaud> right, flatness default, .slice explicitly says "the elements in the input list don't flatten"

[21:30] <pmichaud> so we'd end up with

[21:30] <pmichaud>     (1,2,3 Z 4,5,6).map(-> $a, $b { ... })

[21:30] <pmichaud> and

[21:30] <TimToady> map: -> *$x, *$y {...} to do flattening

[21:30] <pmichaud>     (1,2,3 Z 4,5,6).slice.map(-> $a { ... })

[21:31] <TimToady> and -> $x, $y  would bind slicely like positionals do

[21:31] <TimToady> that is, itemly, parcel at a time

[21:31] <colomon> pmichaud: permission to try to merge ng patches with ng1?

[21:31] <TimToady> if we defaulted it the other way

[21:31] <pmichaud> colomon: you don't need my permission to do it locally, just to push :-)

[21:31] *** cjk101010 left
[21:32] <colomon> pmichaud: sure enough.  :)

[21:32] <TimToady> of course, and people would have to put |foo() into their list to avoid accidental slices

[21:32] <pmichaud> colomon: and if everything works reasonably enough after doing it locally, then just push :0

[21:33] <TimToady> and I still rather suspect that flat lists will be used more than slice lists

[21:33] * colomon might just have fallen in love with git... that was dead easy.

[21:33] <pmichaud> TimToady: right, so I think that .map should result in flat bindings by default

[21:34] <TimToady> which leaves us with the question of how $b knows to do something gettish rather than getitemish

[21:34] <pmichaud> the .slice answer above is that we adjust the input string so that .get results in getitem behavior instead of flatten behavior

[21:35] <TimToady> that doesn't work inside a sig

[21:35] <TimToady> so can't be used to slicify subscripts, for instance

[21:35] <colomon> afk, need to read to the boy for a minute

[21:35] <pmichaud> have a quick example of that?  I'm not sure I follow

[21:36] <TimToady> we can override slurpy with ** or some such, so I'm not worried about that part

[21:36] <pmichaud> (example of slicify subscripts, that is)

[21:37] <TimToady> if postcircumfix:<[]> has a sig containing *@slices, it flattens, but if we turn *@@slices into, say **@slices, then it slices

[21:38] <TimToady> I'm not too worried about the parameters that are explicitly marked

[21:38] <TimToady> but I'd like to be able to choose maps behavior via the signature, not by preprocessing

[21:39] <TimToady> to take a simple case

[21:39] <TimToady> one parameter to map

[21:39] <TimToady> could be either *$x or **$x to explicitly either slurp or slice

[21:39] *** payload joined
[21:39] *** ruoso left
[21:40] <TimToady> the sig is where that info belongs, just as the subpattern is where most of the info should be re ratcheting and such

[21:40] <pmichaud> okay, I follow that last part :)

[21:41] <TimToady> could also be some notation like -> ($x) to indicate "I'm a real sig with a real positional parameter that does getitem"

[21:41] <TimToady> (assuming we work out ambiguity with existing () usage)

[21:42] <TimToady> not necessarily a good assumption

[21:42] *** Su-Shee left
[21:42] <pmichaud> what if someone does    (...).map(&foo)    --   does it make a difference whether &foo was created via a lambda or a sub ?

[21:42] <TimToady> but slicing may be fundamental enough to warrant stealing the notation

[21:43] <diakopter> std: <()><()><()>

[21:43] <p6eval> std 29605: OUTPUT«ok 00:01 105m␤»

[21:43] <TimToady> I'd like it not to make a difference, if possible, which makes me lean toward map somehow telling the signature to default to slurpy for unmarked params

[21:43] <TimToady> including placeholders and $_

[21:43] <pmichaud> I agree that it's better if it doesn't make a difference

[21:44] *** SmokeMachine left
[21:44] <TimToady> hence one of the two solutions in Pm-19

[21:44] <diakopter> std: ->$(){}

[21:44] <p6eval> std 29605: OUTPUT«ok 00:01 106m␤»

[21:44] <TimToady> either rewrite/clone a different sig

[21:44] <TimToady> or rely on some magical cursor applicator to do the right thing with the sig

[21:45] <pmichaud> right now the .count approach is more along the lines of "magical cursor applicator" , I guess.

[21:45] <TimToady> if it can solve the cursor problem at the same time, all the better

[21:45] <pmichaud> that doesn't argue against magical cursor application, just noting where .count falls :-)

[21:45] <TimToady> .count is introspection, and the antithesis of what we're trying to do as pattern matching

[21:46] <TimToady> the sig should decide how much to match, and it may not know in advance

[21:46] <TimToady> just like a subpattern

[21:46] <pmichaud> right

[21:46] <TimToady> sorry to be so adamant on this; wait, no I'm not...  :)

[21:47] *** alester joined
[21:47] <pmichaud> no, I think you're fundamentally correct

[21:47] <pmichaud> I just can't understand it all yet :)

[21:47] <pmichaud> s/can't/don't/  # I guess

[21:47] * TimToady is living proof that someone can be fundamentally correct without understanding it all yet...

[21:47] <pmichaud> and I'm also trying to figure out what to do in the meantime to keep development moving even while we don't have a lot of these fundamental issues resolved

[21:48] <TimToady> well, fundamentally correcter, at least

[21:48] <diakopter> by defintion

[21:48] <pmichaud> one step might be for me to stop asking questions in pm.txt, I suppose :-) :-)

[21:49] <pmichaud> "If you don't want to know the answers... don't ask!"  :-)

[21:49] *** ejs left
[21:49] <diakopter> "if you have to ask, you can't afford it"

[21:50] <TimToady> well, to the first approximation, rakudo can still flatten everything that comes into map until we want to do slices

[21:50] <colomon> > my $a = (1..*); say $a.perl

[21:50] <colomon> 1..!whatever_dispatch_helper

[21:50] <lambdabot>   <no location info>: parse error on input `='

[21:50] <diakopter> (jokingly implying TimToady should anticipate all the questions...)

[21:50] <TimToady> we can delegate it to the sign later when the sig is ready

[21:50] <pmichaud> yeah, I'm thinking that's what we'll likely do

[21:50] <Tene> I don't remember ever seeing anyone here actually use almbdabot on purpose.

[21:50] <Tene> Does anyone object to me kicking it?

[21:51] <TimToady> @karma Tene

[21:51] <lambdabot> Tene has a karma of 70

[21:51] <TimToady> looks like you have enough karma to do that

[21:51] <diakopter> @karma lambdabot 

[21:51] <lambdabot> lambdabot has a karma of 2

[21:51] <TimToady> hah, you win

[21:51] <Tene> Ah, I have seen people askit for karma, yes.

[21:51] <pmichaud> I don't have a use for lambdabot other than as something that increases my annoyance level (and by extension, diminishes -Ofun)

[21:51] <Tene> @karma diakopter

[21:51] <lambdabot> diakopter has a karma of 135

[21:51] <TimToady> phenny: karma Tene

[21:51] <Tene> lambdabot: owner?

[21:52] <diakopter> .karma Tene

[21:52] <pmichaud> for me, keeping track of karma isn't worth the annoyance factor, either.

[21:52] *** lambdabot was kicked by Tene (lambdabot))
[21:52] * colomon just pushed merge plus pmichaud++'s suggestions for 1..* Range -- lazy Range iteration working again in ng1.

[21:52] <TimToady> @foo

[21:52] <diakopter> I would've just quieted it

[21:52] <diakopter> so it doesn't know it's kicked

[21:52] <diakopter> quieted

[21:53] <diakopter> sigh.

[21:53] <diakopter> dalek MIA again

[21:54] *** dalek joined
[21:54] <diakopter> at least it's authenticated

[21:55] <sjohnson> diakopter: how do you quiet it?

[21:55] <diakopter> the irc client on feather (in Europe) connects to freenode through Oregon, but my irc client in Virginia connects to freenode through Germany.

[21:57] <TimToady> I thought we were in planet Houston?

[21:58] <diakopter> that VPS is in Mclean, VA I think

[21:58] <pmichaud> scruffy little planet

[21:58] <diakopter> Langley to be precise

[22:01] <diakopter> er,

[22:01] <diakopter> erm

[22:01] <diakopter> maybe not

[22:01] <TimToady> was always more of a navy guy myself

[22:02] <diakopter> the various geoip dbs differ in knowledge

[22:02] <_ash> > my $a = 1, 2; for $a { say $_.perl }

[22:02] <_ash> Method 'perl' not found for invocant of class 'Seq' # i know its not the proper use of variables, but still an odd error, removing .perl prints $a as expected

[22:02] <_ash> this is on ng1 

[22:03] <pmichaud> just copy the 'perl' method from Array.pm into Seq.pm, and change the brackets to parens

[22:06] <colomon> jnthn++

[22:06] <_ash> so, inside the for loop $a was being referenced by a Seq? (just trying to understand this all) 

[22:06] <pmichaud> keep in mind that  my $a = 1,2;   in Perl 6 doesn't do what you think it does.

[22:07] <pmichaud> (or if it does do what you think it does, then you shouldn't be doing that :-)

[22:08] * PerlJam wonders whose surprise Perl follows for the principle of least surprise.

[22:08] <_ash> hehe, i am probably abusing old ways of doing things, i am sure, or incomplete ways of doing things 

[22:08] <pmichaud> incorrect, in this case.

[22:08] <pmichaud> my $a = 1, 2;   #  likely wrong

[22:08] <_ash> my $a = (1, 2); say $a ~~ Seq;

[22:08] <_ash> 1

[22:09] <pmichaud> At the moment I don't have a simple mechanism in Rakudo to flag   "my $a = 1, 2;"   as an error, or I would do so.

[22:09] <_ash> with or without the ( ) around 1,2 it's still 1

[22:09] <pmichaud> at the moment, spec says that a Parcel in item context becomes a Seq

[22:09] <pmichaud> and assignment to a scalar is doing item context

[22:10] <_ash> std: my $a = 1, 2; say $a ~~ Seq;

[22:10] <p6eval> std 29605: OUTPUT«ok 00:01 108m␤»

[22:10] <_ash> whats happening to $a in the std then? just curious 

[22:10] <pmichaud> it's parsing as

[22:10] <_ash> are they both out of date? 

[22:10] <pmichaud> (my $a = 1), 2;  say $a ~~ Seq;

[22:10] <_ash> ah

[22:11] <pmichaud> and if std were a full compiler, it would probably complain about "useless use of 2 in ... "

[22:11] <_ash> makes sense

[22:11] *** jonasbn left
[22:11] <_ash> okay, i get that 

[22:12] <pmichaud> rakudo (all branches) currently parses   my $a = 1,2;   as    my $a = (1,2);

[22:12] <_ash> its probably gonna be a long time before my nq-nqp is parsing much of this properly if ever

[22:12] <TimToady> it requires = to know whether the sigil on the left was $

[22:13] <TimToady> STD does it with a dynamic variable

[22:13] <TimToady> the trick is to keep a $ from propagating up the left side to far and giving a fake positive

[22:13] <TimToady> *too far

[22:16] *** pmurias joined
[22:19] *** ignacio_ left
[22:19] *** japhb joined
[22:20] <_ash> so... are ( ) lists going to still be immutable? like i should be able to say my @a = (1, 2); push @a, 4; and it give an error since i used ( ) not [ ] ? 

[22:23] <PerlJam> _ash: that would be bizarre.

[22:23] <TimToady> only if you did := instead of =

[22:23] <PerlJam> () is immutable, but an @array is mutable.

[22:24] <TimToady> = pokes copies of values into the array

[22:24] <_ash> ah, okay 

[22:24] <TimToady> we had good reasons for leaving = with p5 semantics and making := something else  :)

[22:25] <diakopter> std: my @a := (1, 2); @a.push 4;

[22:25] <p6eval> std 29605: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/3PdWLj6xzB line 1:␤------> [32mmy @a := (1, 2); @a.push [33m⏏[31m4;[0m␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤      statement modifier loop␤FAILED 00:01 108m␤»

[22:25] <_ash> so, i really need to understand what = vs := vs ::= does 

[22:26] <TimToady> diakopter: methods can't be listops

[22:26] <TimToady> not without a :

[22:26] <PerlJam> diakopter: missing a :

[22:26] <diakopter> oo

[22:26] <pmichaud> ash:  = is assignment.   @a = 1,2,$b;   copies the values from the list into @a

[22:26] <diakopter> I'm so behind.

[22:26] <_ash> i didn't realize = did a copy

[22:27] <pmichaud> if it didn't do a copy, then changes to $b would be reflected in @a

[22:27] <diakopter> and by behind, I mean behind on reading/remembering the spec.

[22:27] <diakopter> (not not keeping up with changes)

[22:27] <_ash> pmichaud: makes sense, i just never realized it till you guys pointed it out 

[22:27] <TimToady> it's only been like that since, oh, about 2004

[22:27] <diakopter> exaclty

[22:28] <TimToady> it will help to remember that $.foo wants to look both like a variable and a method call

[22:28] <diakopter> found out for certain; that VPS is in Equnix in Ashburn, VA

[22:29] <diakopter> and my cubeighbor used to work there.

[22:29] <TimToady> and the default on whether to look for more arguments is different between methods and functions because methods already have one argument, so might well not any more

[22:29] <TimToady> (the one arg being the invocant)

[22:30] <TimToady> ss/not any/not want any/

[22:31] <diakopter> what's ss///

[22:32] <TimToady> s:sigspace

[22:33] <_ash> where is the <ident> regex defined? i haven't found it yet

[22:33] <pmichaud> in nqp

[22:33] <pmichaud> it's part of the regex library of builtins

[22:34] <Tene> -ash: you mean in the Perl 6 specs, yes?

[22:34] <_ash> yeah, i was meaning more in the spec, is there an example of what it recognizes as valid? 

[22:35] <_ash> (was reading S06)

[22:35] <pmichaud> S-5

[22:35] <pmichaud> er, S05

[22:35] <_ash> oops, ya i can't copy paste properly 

[22:37] <pmichaud> no, it doesn't say exactly.  I think it's the standard  "alpha followed by zero or more alnum"  definition, though.

[22:37] <_ash> or _ if i am not mistaken, i just wanted to make sure

[22:37] <Tene> including -_' or not?

[22:37] <pmichaud> _ is generally considered alpha

[22:38] <pmichaud> ident does not include the -'

[22:38] <pmichaud> token ident { <.alpha> \w*

[22:38] <pmichaud> }

[22:38] <diakopter> m:scrabble/any hing/

[22:40] <PerlJam> if ident doesn't contain - or ', then what is the "identifier" regex that does contain those things called?

[22:40] <_ash> \w* i believe 

[22:40] <pmichaud> "identifier"

[22:40] <pmichaud> token identifier { <.ident> [ <.apostrophe> <.ident> ]*

[22:40] <pmichaud> }

[22:43] <_ash> hmm so nqp and rakudo use 2 different definitions of identifier? 

[22:43] <pmichaud> I don't think so

[22:43] <pmichaud> note "ident" versus "identifier"

[22:43] <pmichaud> "ident" is the traditional  alpha + \w*

[22:43] <_ash> well, they both have an ident and an identifier 

[22:43] <pmichaud> "identifier" is the one that includes apostrophe and hyphen

[22:44] <pmichaud> they're supposed to be the same

[22:44] <pmichaud> (nqp and rakudo, that is)

[22:46] <_ash> in nqp its token identifier { <ident> } 

[22:46] <pmichaud> I suspect I just haven't implemented the expanded version yet

[22:47] <PerlJam> That's some LHF for others though :)

[22:47] <_ash> so really its any alphnum + - and ' and unicode? or... 

[22:47] <_ash> is unicode included in alphanum? 

[22:48] <pmichaud> unicode alnums are included in alnum :-)

[22:48] <pmichaud> not all of unicode is alnum

[22:49] <Juerd> Maybe, just maybe, I should remove that highlight on /unicode/ in my irssi.

[22:51] <Juerd> Maybe it's useful to rename either ident or identifier, to avoid confusion. Maybe ident-atom for ident.

[22:52] <pmichaud> that'd be funny, since ident-atom would be the thing that doesn't have the hyphens :)

[22:52] <PerlJam> heh

[22:52] <pmichaud> while identifier has no hyphens in its name but it does in what it matches :-)

[22:52] <Juerd> pmichaud: Funny is so much better than confusing :)

[22:52] <pmichaud> so perhaps identifier should be   ident-with-apostrophes-and-hyphens

[22:53] <PerlJam> so ... ident and ident-ifier ?  :)

[22:53] <_ash> lol

[22:53] <pmichaud> ident-if-i-err

[22:53] <diakopter> ident-with-'apostrophes'-and-hyphens

[22:53] <Juerd> PerlJam: lol

[22:53] <Juerd> diakopter: Invalid

[22:53] <pmichaud> '-  isn't valid, though

[22:53] <pmichaud> nor is -'

[22:53] <diakopter> oh

[22:53] <pmichaud> ident-with-ap'str'phes-and-hyphens

[22:54] <Juerd> I suggested ident-atom because that's how rfc2822 calls things. There's atom, and dot-atom, where dot-atom-text is 1*atext *("." 1*atext)

[22:55] <Juerd> For example, [email@hidden.address] is a valid address while foo..bar@example.org isn't.

[22:55] <Juerd> pmichaud: apo's :)

[22:56] * PerlJam always thinks of apostrophes in a contractive sense, so a really long name is odd in that respect too

[22:56] <Juerd> fakeident, real-ident

[22:56] <Juerd> There's a fakeident in every real one :)

[22:57] <PerlJam> i-d'e'n-t

[22:58] <PerlJam> i-den't

[22:58] <Juerd> Why not? :)

[22:58] *** wasy is now known as wasy_afk

[23:00] <_ash> is there a reason to have both of them? just wondering, i see identifier used a lot but ident not so much

[23:00] <PerlJam> _ash: ou need idents to build an identifier :)

[23:00] <PerlJam> s/ou/you/

[23:01] <Juerd> _ash: identifier uses ident.

[23:01] <_ash> true, but ident doesn't have to be called ident

[23:01] <Juerd> I think it would be better if it were called something else

[23:01] <pmichaud> and the bikeshed doesn't have to be purple.

[23:01] <pmichaud> :-)

[23:02] <_ash> but if you make it purple then you can see it from like a block away 

[23:02] <Juerd> That depends on the shade of purple

[23:02] <_ash> unless your eyes are as bad as mine and you need a new pair of glasses

[23:02] <Juerd> It's okay if the bikeshed is purple, if everything surrounding it has sufficiently contrasting colors.

[23:02] <pmichaud> it also depends on the neighborhood you live i... what Juerd++ said

[23:02] <Juerd> Purple next to navy blue looks horrible

[23:03] <pmichaud> that's why we only store green bikes in the purple bikeshed

[23:03] *** uniejo left
[23:03] <Juerd> Currently there are blue bikes in the purple bikeshed.

[23:03] <Juerd> Well, at least one :)

[23:05] <Tene> I'm still just a little bit grumpy over supporting internal ', but not $a', $a'', etc.

[23:06] <frettled> I think the bikeshed should allow more bikes.  ;)

[23:06] <Juerd> Tene: You've never played golf, have you? :)

[23:06] <_ash> frettled wants new lines and whitespace in his variable names i bet

[23:07] <_ash> my $a␤name = 5; say $a␤; 

[23:08] <frettled> _ash: and Unicode free-for-all and a pony

[23:11] *** mberends left
[23:16] *** iblechbot left
[23:18] *** meppl left
[23:19] *** toddr joined
[23:22] *** mberends joined
[23:22] *** sjn joined
[23:22] <pugs_svn> r29606 | colomon++ | [t/spec] Fudge for ng1. 

[23:29] *** alester left
[23:29] *** payload left
[23:29] *** _ash left
[23:29] *** stephenlb left
[23:30] *** eternaleye joined
[23:30] *** eternaleye left
[23:30] *** eternaleye joined
[23:31] *** stephenlb joined
[23:32] <pugs_svn> r29607 | colomon++ | [t/spec] Fudge for ng1. 

[23:33] *** _ash joined
[23:33] *** alester joined
[23:33] *** alester left
[23:34] *** cotto_work left
[23:34] *** eternaleye left
[23:34] *** payload joined
[23:34] *** cotto_work joined
[23:41] *** eternaleye joined
[23:41] *** eternaleye left
[23:41] *** eternaleye joined
[23:44] <pugs_svn> r29608 | colomon++ | [t/spec] Fudge for ng1. 

[23:46] <colomon> jnthn, pmichaud: any notions why S02-whitespace_and_comments/one-pass-parsing.t fails in ng1?

[23:47] *** eternaleye left
[23:50] *** eternaleye joined
[23:50] *** eternaleye left
[23:50] *** eternaleye joined
[23:51] <colomon> S06-routine-modifiers/scoped-named-subs.t -- test #2 gets () and expects ''.  Seems to me () is probably right, but I don't know how to code that up.

[23:51] <colomon> (For an "is" test, I mean.)

[23:54] *** Chillance left
[23:54] <pugs_svn> r29609 | colomon++ | [t/spec] Fudge for ng1. 

[23:55] *** mberends left
