[00:05] *** araujo left
[00:06] *** tylercurtis joined
[00:07] *** meraxes left
[00:08] * colomon is working on pick / roll, btw

[00:17] *** thundergnat joined
[00:36] *** thowe left
[00:40] *** redicaps joined
[00:40] *** redicaps left
[00:51] *** Guest30046 left
[00:57] *** meraxes joined
[01:01] *** QinGW joined
[01:05] *** Guest30046 joined
[01:05] *** Italian_Plumber left
[01:18] *** molaf left
[01:24] <dalek> rakudo: 39b41ad | colomon++ | src/core/ (4 files):

[01:24] <dalek> rakudo: Split .pick into .pick and .roll.

[01:24] <dalek> rakudo: 

[01:24] <dalek> rakudo: This is a straightforward effort to split the existing code.  There are at least a couple of clear issues with this code, but cleaning them up is probably best left until we have some better tests for these two methods.

[01:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/39b41ad73b2c0888bdee28a59c8a65aacc8f6925

[01:28] <dalek> roast: 91aafc5 | colomon++ | / (3 files):

[01:28] <dalek> roast: [t/spec] Change pick with :replace to roll, deleting entirely one test which no longer made sense.

[01:28] <dalek> roast: review: http://github.com/perl6/roast/commit/91aafc5fc59ce0d0f5d3d255384ed59b23ffc62a

[01:29] *** whiteknight left
[01:32] *** molaf joined
[01:35] *** Guest30046 is now known as meinwald

[01:37] *** felipe left
[01:42] <colomon> rakudo: my @a = 1..10; say ~@a.sort

[01:43] <p6eval> rakudo 323a67: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[01:43] <colomon> rakudo: say ~(1..10)

[01:43] <p6eval> rakudo 323a67: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[01:44] <colomon> rakudo: my @a = 1..10; say ~@a.pick(*).sort

[01:44] <p6eval> rakudo 323a67: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[01:46] *** bluescreen joined
[01:48] *** thundergnat left
[01:51] *** hercynium left
[01:54] *** araujo joined
[02:31] <dalek> rakudo: e682712 | pmichaud++ | src/ (4 files):

[02:31] <dalek> rakudo: Switch C<time> and C<now> to be 0-ary terms.

[02:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e682712b418bcd2aadfc9a9cefdeac427fade722

[02:31] <dalek> rakudo: 4f3d392 | pmichaud++ | src/core/ (4 files):

[02:31] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[02:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4f3d3928ed4e4734ae0422786dd8bd3fa65e454b

[02:37] <dalek> roast: e2e65b2 | pmichaud++ | S29-context/sleep.t:

[02:37] <dalek> roast: [sleep.t]:  C<time> does not allow parens after it.

[02:37] <dalek> roast: review: http://github.com/perl6/roast/commit/e2e65b2720f1a9319692051130c75b2a0662ed98

[02:43] <dalek> roast: a25207b | colomon++ | S (3 files):

[02:43] <dalek> roast: [t/spec] Add about eighty pick and roll tests, including a new S32-list/roll.t file.

[02:43] <dalek> roast: review: http://github.com/perl6/roast/commit/a25207bacf2494e4ab5baba304d61c8179e43d6a

[02:50] <pmichaud> anyone made the cognitive leap from "pick and roll" to basketball yet?  ;-)

[02:54] <\xF0> (basketball reference)++

[02:57] *** jaldhar joined
[02:59] <colomon> pmichaud: not I.

[03:01] *** orafu left
[03:01] *** orafu joined
[03:05] *** bluescreen left
[03:14] <colomon> have another pick / roll patch in spectesting, but will probably go to be before the spectest is done.

[03:14] *** alester joined
[03:17] <pmichaud> to be... or not to be.  that is the question.  :-)

[03:22] *** mantovan1 left
[03:22] <colomon> to bed or not to bed.  that is no question at all.  :)

[03:22] *** mantovani joined
[03:24] <colomon> afk # to sleep, perchance to dream...

[03:39] <dalek> rakudo: 358d728 | pmichaud++ | src/core/metaops.pm:

[03:39] <dalek> rakudo: Add meta-op forms of ?&, ?|, ?^, &&.  Fixes RT #77864.

[03:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/358d728b86884d907c256b6adb3e9d7f4a173c0d

[03:52] *** LaVolta joined
[03:52] <LaVolta> howdy #perl6 :)

[03:53] *** leprevost joined
[04:06] *** leprevost left
[04:23] *** xinming_ joined
[04:23] *** QinGW1 joined
[04:25] *** QinGW left
[04:27] *** xinming left
[04:51] *** envi^home joined
[05:00] *** toebu left
[05:11] *** masak joined
[05:11] <masak> oh hai, #perl6!

[05:11] <phenny> masak: 15 Sep 17:45Z <supernovus> tell masak I will make a branch of ecosystem and add it, unlike proto, I don't have write access to that project to add it directly.

[05:11] <masak> assuming that meant 'fork'.

[05:11] <TimToady> actually, I was thinking of the basketball connection when I said pick-n-roll at http://irclog.perlgeek.de/perl6/2010-09-15#i_2830582

[05:11] <diakopter> pmichaud: truthfully, I saw "split pick into pick and roll" in the irssi scrollback and basketball was the only connotation that came to mind. I'd forgotten what pick meant.

[05:12] <diakopter> I'd forgotten what Perl 6 pick meant, I mean.

[05:14] <TimToady> I wouldn'ta spelled it like that otherwise

[05:14] <diakopter> we used to do something like that in soccer, too...

[05:17] <LaVolta> rakudo: say ((1,2,3,4,5) »-» 1);

[05:17] <p6eval> rakudo 358d72: OUTPUT«01234␤»

[05:17] <TimToady> rakudo: say 1,2,3,4,5 X- 1

[05:17] <p6eval> rakudo 358d72: OUTPUT«01234␤»

[05:17] *** sftp left
[05:18] <TimToady> I think the Xop is clearer when you're actually dealing with lists

[05:18] <TimToady> the hyper form is more useful for items that are data structures

[05:18] <LaVolta> thanks, a new lesson to learn :) ...may be I am abusing it...

[05:19] <LaVolta> Confused at line 1, near "(1,2,3,4) "

[05:19] <LaVolta> question, why I got "Confused at line 1, near "(1,2,3,4) "" after typing: "(1,2,3,4) >>->> 1" at REPL

[05:20] <TimToady> this is reflected in the fact that hypers are of tighter precedence than lists, while X is looser than comma

[05:20] <TimToady> perhaps it was looking for a -> operator to complain about Perl 5?

[05:20] <TimToady> it shouldn't do that in a hyper, probably

[05:21] <TimToady> std: (1,2,3,4) >>->> 1

[05:21] <p6eval> std : OUTPUT«ok 00:01 118m␤»

[05:21] <TimToady> and it's fine with the STD parser

[05:21] <LaVolta> this: "(1,2,3,4)>>->>1" give me: Unsupported use of -> as postfix;

[05:21] <TimToady> rakudo: say (1,2,3,4) >>->> 1

[05:21] <p6eval> rakudo 358d72: OUTPUT«===SORRY!===␤Confused at line 22, near "say (1,2,3"␤»

[05:21] <LaVolta> yeah!

[05:21] <TimToady> ah, no whitespace

[05:22] <TimToady> >> introduces hyper postfixes

[05:22] <TimToady> rakudo: say (1,2,3,4)>>->>1

[05:22] <p6eval> rakudo 358d72: OUTPUT«===SORRY!===␤Unsupported use of -> as postfix; in Perl 6 please use either . to call a method, or whitespace to delimit a pointy block at line 22, near ">1"␤»

[05:22] <TimToady> STD won't like that either

[05:22] <TimToady> in general, Perl 6 assumes you'll usually put whitespace around infixes

[05:22] <TimToady> comma being a major exception

[05:23] <LaVolta> yep...but what about "say (1,2,3,4) >>->> 1", it confuses rakudo

[05:23] <TimToady> but here's another case where the Latin-1 will be handled better

[05:23] <TimToady> std: say (1,2,3,4)»-»1

[05:23] <p6eval> std : OUTPUT«ok 00:01 118m␤»

[05:23] <TimToady> rakudo: say (1,2,3,4)»-»1

[05:24] <p6eval> rakudo 358d72: OUTPUT«0123␤»

[05:24] <TimToady> that's because there is no -» operator

[05:26] <LaVolta> now...my wish for the year become "a fully functional unicode repl"

[05:26] <LaVolta> direct input is the root of all evil...

[05:31] <tylercurtis> The REPL doesn't support Unicode?

[05:33] <TimToady> readline doesn't

[05:36] <LaVolta> :-P, any codepoint also works, though

[05:36] <LaVolta> *and...oops

[05:36] <tylercurtis> rlwrap uses readline, doesn't it?

[05:36] * tylercurtis uses rlwrap for the REPL on his laptop because Parrot doesn't detect his readline.

[05:37] <LaVolta> tylercurtis:  my $t = "测试"; # paste this into your REPL, see what happens

[05:37] <tylercurtis> > my $t = "测试";

[05:37] <tylercurtis> 测试

[05:38] <LaVolta> cool

[05:38] <LaVolta> > my $t = "测试"

[05:38] <LaVolta> æµè¯

[05:39] <LaVolta> this is currently what I got

[05:39] *** cmadsen joined
[05:39] *** cognominal left
[05:41] <LaVolta> in order to get the correct result I have to do this: > my $t = "\x6d4b\x8bd5"

[05:41] <LaVolta> 测试

[05:41] *** cmadsen1 left
[05:41] <tylercurtis> What version of readline do you have? I appear to have 6.0.

[05:42] <LaVolta> /opt/local/lib/libreadline.6.1.dylib (compatibility version 6.0.0, current version 6.1.0)

[05:42] <LaVolta> what? twice?

[05:43] <LaVolta> OSX, btw

[05:44] * tylercurtis is on OS X, as well.

[05:46] * tylercurtis will try to get parrot to recognize his readline so that he can see if it works for him with non-rlwrap readline.

[05:47] * LaVolta gonna a rlwrap a shot

[05:47] <masak> here's a veiled feature request: http://twitter.com/wireghoul/status/24610404820

[05:47] <masak> should I turn that into a TODO rakudobug? :)

[05:48] <TimToady> star: say dir('.')

[05:48] <p6eval> star 2010.07: OUTPUT«Operation not permitted in safe mode␤  in 'Safe::forbidden' at line 2:/tmp/bXsIGVeKSU␤  in main program body at line 22:/tmp/bXsIGVeKSU␤»

[05:48] <TimToady> looks like dir was already there then

[05:48] <masak> oh, it's that one?

[05:49] <masak> I think it was added long before Rakudo Star.

[05:49] * masak checks

[05:49] <masak> aye.

[05:49] * masak responds to @wireghoul

[05:50] * LaVolta hopes one day he can surf more freely

[05:51] <tylercurtis> masak: perldoc -f glob makes it seem like dir wouldn't be quite equivalent, necessarily.

[05:51] <masak> tylercurtis: indeed.

[05:52] <masak> tylercurtis: maybe a case can be made to provide both.

[05:52] <masak> I've had two surprises with &dir already.

[05:52] <masak> (1) it doesn't return the filenames with the path on them. this can be seen as either a feature or a bug, depending.

[05:53] *** cjk101010 joined
[05:53] <TimToady> it's really an opendir/readdir/closedir

[05:53] <masak> (2) it doesn't do the (optional) $test on IO objects, but on filename strings. that's not half as useful as doing it on IO objects.

[05:54] <tylercurtis> LaVolta: looks like it doesn't work if I build Parrot with readline support.

[05:54] <TimToady> I think it was aimed at grepping out /^\./, probably

[05:55] <LaVolta> tylercurtis:  sure...that's why I wanna try rlwrap

[05:56] <LaVolta> btw, rakudo's much faster now, thanks all!

[05:56] <masak> TimToady: aye. the default it none('.', '..')

[05:57] *** satyavvd joined
[05:57] *** dual left
[05:58] <tylercurtis> LaVolta: bad news: it looks like if Parrot was built with readline support, rlwrap does not help (not really surprising, but inconvenient).

[05:59] *** wtw joined
[06:02] *** alester left
[06:03] <LaVolta> tylercurtis:  too bad :(, now i know...

[06:04] <masak> perl6: say chr(194), chr(177)

[06:04] <p6eval> rakudo 358d72: OUTPUT«±␤»

[06:04] <p6eval> ..pugs: OUTPUT«Â±␤»

[06:04] <masak> I'm with pugs on this one.

[06:05] *** uniejo joined
[06:08] <TimToady> I'm with masak on this one.

[06:08] * masak submits rakudobug on this one

[06:09] <masak> perl6: print .chr for <233 186 166 233 171 152>

[06:09] <p6eval> rakudo 358d72: OUTPUT«麦高»

[06:09] <p6eval> ..pugs: OUTPUT«éº¦é«»

[06:09] <masak> clearly rakudo is thinking in bytes, not characters.

[06:09] <TimToady> indeed

[06:10] <LaVolta> masak:  just curious, who is 麦高? sounds like your name...

[06:11] <masak> aye :)

[06:14] *** jedai left
[06:15] *** jedai joined
[06:17] <TimToady> I'm allergic to 麦, but not very afraid of 高.

[06:17] <LaVolta> TimToady:  what is your name in CJK chars?

[06:18] <TimToady> that depends on which language you're speaking :)

[06:18] <LaVolta> lol...

[06:18] *** molaf left
[06:18] <masak> lolese.

[06:19] *** felipe joined
[06:32] <LaVolta> forgive me, but I didn't know that in Perl 5 we can also use < ... > as quote mark... :-P

[06:33] <masak> only after 'qw' :)

[06:33] <moritz_> LaVolta: you can, but it's a glob, so <a *> will not give the same result in perl 5 and 6

[06:34] <masak> oh right!

[06:34] <moritz_> because * will expand to all file names in the current directory

[06:34] <LaVolta> moritz_:  ooooooh!! thanks for the explaination

[06:35] <masak> buubot: eval for (<foo bar baz>) { print $_, "\n" }

[06:35] <buubot> masak: ERROR: Can't locate Text/ParseWords.pm in @INC (@INC contains:) at /usr/lib/perl/5.10/File/Glob.pm line 152.       

[06:35] <masak> buu: ^^

[06:36] <LaVolta> for me, another dark corner....

[06:40] <masak> if there are still dark corners, our Perl is not yet Enlightened enough. :)

[06:43] *** Mowah joined
[06:44] <sorear> good * #perl6

[06:44] <LaVolta> o/ # wave/dance for the first time

[06:45] <masak> \o

[06:47] <sorear> TimToady and masak have names in CJK chars?

[06:48] <sorear> In Perl 5, Scalar has a non-parametric representation

[06:49] <sorear> Int, Str, etc are kept directly in the Scalar, instead of being separate immutable objects

[06:49] <sorear> Scalar of Str, in particular, is actually StringBuffer

[06:50] <sorear> so you can do stuff like my $x = 'a' x 1_000_000; for (1..500_000) { substr($x, int(rand(1000_000)), 1) = 'b' }; in O(N) time

[06:50] <sorear> I wonder if P6 can or should do anything to support that style of code

[06:56] <masak> std: say 5 R. ({$_ * $_})

[06:56] <p6eval> std : OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/Wu_n7VhP7a line 1:␤------> [32msay 5 R. [33m⏏[31m({$_ * $_})[0m␤Parse failed␤FAILED 00:01 116m␤»

[06:57] <masak> overzealous error.

[06:57] <sorear> what should the result be/

[06:57] <masak> 25?

[06:57] <sorear> why?

[06:57] <masak> I think it can be assumed that if I do R. I'm no longer in a Perl 5 mindset :)

[06:58] <masak> sorear: because ({ $_ * $_ }).(5) is 25?

[06:58] <sorear> that isn't &infix:<.>

[06:58] <sorear> that's &postcircumfix:<( )>

[06:58] <sorear> R only reverses infixes

[06:58] <masak> you're right.

[06:59] <masak> good thing I left a savepoint a couple of minutes back.

[06:59] * masak backtracks to it

[07:00] * sorear has a new design for variables in niecza

[07:02] <sorear> masak: I have control flow operators working now :D

[07:07] *** Ross^ joined
[07:07] *** envi^home left
[07:09] <masak> sorear: you mean like 'next' et al?

[07:12] *** patrickas joined
[07:12] *** patrickas left
[07:13] <sorear> yes

[07:13] <sorear> perhaps more importantly, 'return'

[07:14] <sorear> not optimized yet

[07:14] <masak> sorear: nice! maybe Yapsi will have some of those too soon.

[07:16] *** Ross^ left
[07:18] *** tadzik joined
[07:20] <tadzik> colomon: ping

[07:20] *** synth left
[07:34] *** justatheory left
[07:38] *** Guest23195 joined
[07:43] <sorear> agh.  Old plan for variable overhaul, failed, because I'm relying on bvalue aliasing for our

[07:49] <sorear> so I could make normal use of hashes much faster at the expense of horrifically slowing down $Foo::bar

[07:50] <sorear> or I could do what Perl 5 does and add a level of indirection, so Foo::<$bar> would be a (not directly usable as a scalar)

[07:54] <tadzik> phenny: tell colomon I commented your commit on github, I think I see some code redundancy in here

[07:54] <phenny> tadzik: I'll pass that on when colomon is around.

[07:54] <tadzik> phenny: thanks

[07:55] *** tadzik left
[07:55] *** Kodi joined
[08:07] *** jedai left
[08:09] *** jedai joined
[08:12] *** LaVolta left
[08:14] *** wamba joined
[08:15] *** LaVolta joined
[08:18] *** synth joined
[08:23] *** thebird joined
[08:24] *** jedai left
[08:24] <dalek> niecza: ce8c188 | sorear++ | / (11 files):

[08:24] <dalek> niecza: Commit a bunch of misc performance things

[08:24] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ce8c188718763e5d94a823f1fdf246a674a9a4dc

[08:24] <dalek> niecza: b94fd4d | sorear++ | / (4 files):

[08:24] <dalek> niecza: Implement range form of ** quantifier

[08:24] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b94fd4dd097c0757ca97db78103dba58f6ec4540

[08:25] *** tylercurtis left
[08:25] *** jedai joined
[08:25] *** am0c^ joined
[08:29] <dalek> roast: 264f008 | KodiB++ | S02-builtin_data_types/key (3 files):

[08:29] <dalek> roast: Additions, corrections, and reformatting for KeySet, KeyBag, and KeyWeight.

[08:29] <dalek> roast: review: http://github.com/perl6/roast/commit/264f008abcc21c0484d6610ffd2b9e2dd20ec737

[08:34] *** dakkar joined
[08:36] *** jjore_ left
[08:37] *** timbunce joined
[08:38] *** jjore joined
[08:43] <sorear> Does 'when' generate a control exception?

[08:43] *** rindolf joined
[08:44] <masak> the block form does, by default.

[08:44] <masak> the statement modifier doesn't. unless it's Perl 5. :P

[08:44] <sorear> ok.  What exception is generated?  Is it lexotic or dynamic?

[08:51] <jnthn> morning, #perl6

[08:55] <sorear> hello jnthn 

[08:55] *** daxim joined
[08:56] <jnthn> o/ sorear 

[08:56] <masak> rakudo: sub foo() { when 42 { say "OH HAI" }; say "!" }; given 42 { foo }

[08:56] <p6eval> rakudo 358d72: OUTPUT«Use of uninitialized value in numeric context␤!␤»

[08:56] <sorear> rakudo: sub foo() { return 1; }; say foo.WHAT

[08:56] <p6eval> rakudo 358d72: OUTPUT«Int()␤»

[08:56] <masak> rakudo: sub foo($_:) { when 42 { say "OH HAI" }; say "!" }; given 42 { foo($_) }

[08:56] <p6eval> rakudo 358d72: OUTPUT«Lexical 'self' not found␤  in 'foo' at line 22:/tmp/Sezqrvnpe7␤  in main program body at line 22:/tmp/Sezqrvnpe7␤»

[08:56] <sorear> How does this work?

[08:56] *** dju left
[08:56] <masak> rakudo: sub foo($_) { when 42 { say "OH HAI" }; say "!" }; given 42 { foo($_) }

[08:57] <p6eval> rakudo 358d72: OUTPUT«OH HAI␤»

[08:57] <masak> sorear: dynamic, it'd seem.

[08:57] <sorear> Oh, I'm blind, I skipped over builtins/control 28-35

[08:57] <masak> rakudo: sub foo($_) { when 42 { say "OH HAI" }; say "!" }; given 42 { foo($_); say !!" }

[08:57] <p6eval> rakudo 358d72: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[08:57] <masak> rakudo: sub foo($_) { when 42 { say "OH HAI" }; say "!" }; given 42 { foo($_); say "!!" }

[08:57] <p6eval> rakudo 358d72: OUTPUT«OH HAI␤!!␤»

[08:57] <masak> hm.

[08:58] <sorear> masak: rakudo does not implement lexotic control, at all

[08:58] <masak> or purely lexical.

[08:59] <sorear> src/Perl6/Actions.pm line 3280 has this to say about where when jumps to:     # XXX TODO: This isn't quite the right way to check this...

[09:00] <masak> :)

[09:01] *** am0c^ left
[09:01] *** orc joined
[09:03] *** xinming_ is now known as xinming

[09:05] <sorear> jnthn: what should happen if I create 2^30 anonymous types?

[09:06] *** orc left
[09:06] <jnthn> sorear: Go directly to jail. Do not collect £200.

[09:06] <jnthn> :P

[09:07] <jnthn> sorear: I'm using a 64 bit number for STable IDs though, just in case people try such insanity. :)

[09:09] * sorear wonders why jnthn is using GBP

[09:10] <jnthn> sorear: Because I grew up in England and that was what currency we played monopoly in there. :-)

[09:15] <sorear> so I see you've started "parrot"

[09:15] <sorear> I guess that means you know what you're doing, now

[09:16] <jnthn> ...started?

[09:16] <sorear> yeah, 3 days ago

[09:16] <jnthn> sorear: Anyway, I guess somebody *could* overflow the IDs if we just allocate them sequentially.

[09:17] <jnthn> sorear: But, well...I figure there's more than one way of allocating IDs.

[09:17] <jnthn> sorear: But for now probably "use a 64 bit number" will keep us away from problems.

[09:17] <sorear> What is the stuff about int/str/etc box types?

[09:17] <jnthn> At the speed Rakudo currently runs, the heat death of the universe probably happens before somebody creates enough types to hit the limit anyway. :P

[09:18] <jnthn> sorear: In 6model?

[09:18] <sorear> yes

[09:18] <jnthn> sorear: Basically, it's the stuff that handles "I have this native, low-level type and I want an object", and vice versa.

[09:19] <sorear> in niecza, (box TypeName value) is one of the primitives

[09:19] <sorear> so 6model's box is polymorphic on value?

[09:19] <jnthn> 6model has box_int, box_str, box_num and corresponding unbox ones.

[09:20] <sorear> niecza has a LOT more kinds of box

[09:21] <sorear> for instance, Parcel boxes a Variable[]

[09:22] <jnthn> Ah, interesting.

[09:28] <sorear> jnthn: What is the role of a represntation in 6model?

[09:28] *** cls_bsd left
[09:28] *** cls_bsd joined
[09:29] <jnthn> sorear: A representation is responsible for how we represent "stuff" in memory

[09:29] <jnthn> sorear: Where stuff really is object state

[09:30] <jnthn> Some of them are more capable than others.

[09:30] <jnthn> P6opaque will be, I expect, pretty complex ones it's all filled out.

[09:31] <sorear> How much do you want to let reprs vary?

[09:31] <sorear> If I subclass Int and add attributes, how will that work?

[09:32] <jnthn> My current thinking is that Int won't actually use the P6int representation directly.

[09:32] <jnthn> It'll use P6opaque with an attribute that is of type P6int

[09:32] <sorear> P6opaque isn't going to support 'has int $!value'?

[09:32] <jnthn> One thing that's missing from the current repr API - 'cus I didn't work out quite how it should look yet - is a "you can inline me"

[09:33] <jnthn> Yes, it'd have something like that.

[09:34] <jnthn> Int is a slightly awkward example though

[09:34] <jnthn> Since it's meant to also support upgrading to big int

[09:35] <jnthn> Num is a much cleaner one

[09:36] <sorear> Why would Int support upgrading?

[09:36] <sorear> It's not mutable

[09:37] <jnthn> Yeah, "upgrading" is kind of a bad word for it from an implementation standpoint I guess

[09:38] <jnthn> "needs to be capable of using a machine-y int or supporting big int on demand" or something is probably closer, but yes, it's a decision at creation time, not one that changes over its lifetime.

[09:38] <sorear> Does 6model have anything like Perl6Scalar yet?

[09:38] * sorear thinks Int and BigInt would make more sense as separate types

[09:39] <jnthn> sorear: (int and BigInt separate) me too

[09:39] <sorear> or maybe Int; NativeInt is Int; BigInt is Int

[09:39] <jnthn> Or Int is a role, or something

[09:39] <jnthn> (Perl6Scalar) Not yet

[09:39] <jnthn> I wonder if Perl6Scalar really wants to be a parametric role.

[09:40] <jnthn> I've pondered how to do it a bit, but didn't settle on anything yet.

[09:40] <sorear> In niecza I went the opposite route; Perl6Scalar is less than an object

[09:40] <moritz_> jnthn: there's an Integer role

[09:40] <jnthn> Yeah, that's what we currently do in Rakudo, but I'm not sure how well it'll hold up.

[09:40] <sorear> it can pretend to be an object, albeit with a very weird repr, if you poke at it right

[09:40] <jnthn> Yeah

[09:41] <jnthn> Depends if making it a real object blows away performance I guess.

[09:41] <jnthn> moritz_: Oh? OK. :-)

[09:41] <sorear> niecza uses 'abstract GetMO()' in the IP6 base class, rather than a field

[09:42] <sorear> saves a pointer on all the less-than-objects... might be worth reexamining at some point

[09:42] <sorear> also, interfaces are amazingly slow in mono.  changing IP6 from an interface to an abstract class roughly tripled performance

[09:43] <jnthn> I did a similar switch in 6model quite early on, though without benchmarking so I don't know what the win was.

[09:44] <jnthn> I kinda just realized "oh wait, this isn't a place I want the extra cost of an interface call"

[09:44] <jnthn> (They are more costly even on the CLR.)

[09:44] <jnthn> er, the microsoft CLR impl, that is.

[09:45] <sorear> another thing I'm debating is how harshly to avoid inferior runloops

[09:45] <sorear> I suspect that making container FETCH/STORE non-CPS methods would be a considerable win, but then it'd be impossible to use &take in a tied scalar

[09:46] <sorear> (unless I give in to the dark side and use Mono.Tasklets.Continuation)

[09:47] <moritz_> dark side because not portable among CLR implementations?

[09:48] <sorear> yes

[09:48] <moritz_> .oO( Come to the Dark Side, we have cookies! )

[09:49] <jnthn> oh, oops...I need to go to a meeting...

[09:49] <jnthn> bbl

[09:49] <sorear> I've also considered deferring final code generation to runtime and/or using a bytecode interpreter

[09:49] <sorear> however, this would be obviously insane

[09:50] <sorear> (it would probably cut executable sizes by a lot, though!)

[09:50] * sorear wonders if a CLR image is an executable or a fakecutable

[09:51] <dalek> rakudo: cd151f6 | moritz++ | build/Makefile.in:

[09:51] <dalek> rakudo: update spectest_smolder to new smolder.parrot.org server

[09:51] <dalek> rakudo: 

[09:51] <dalek> rakudo: see http://smolder.parrot.org/app/projects/smoke_reports/5 for the reports.

[09:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cd151f65c696c3c4992677a3dfcfbaef81b78551

[09:53] <moritz_> everybody, please update to newest rakudo, reconfigure and run 'make spectest_smolder' (requires the 'curl' command line program)

[10:01] *** rindolf left
[10:06] *** QinGW1 left
[10:11] *** meteorjay joined
[10:14] *** toebu joined
[10:15] *** toebu left
[10:16] *** toebu joined
[10:19] *** tadzik joined
[10:19] <tadzik> hello again

[10:26] *** Kodi left
[10:27] <flussence> mornin'

[10:27] <LaVolta> bye, cat LaVolta > /dev/null

[10:27] *** LaVolta left
[10:30] <flussence> moritz_: I'm running that now. (btw, "make help" doesn't list it, dunno if that was forgotten about)

[10:37] *** avuserow_ left
[10:42] *** jferrero joined
[10:43] *** meppl joined
[10:46] *** avuserow joined
[10:52] <dalek> rakudo: f11a044 | colomon++ | src/core/Range.pm:

[10:52] <dalek> rakudo: Try to clean up Range.pick and Range.roll a bit.

[10:52] <dalek> rakudo: 

[10:52] <dalek> rakudo: Still not completely happy with these, but they work a bit better now...

[10:52] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f11a04449484507234ea8646cacf4d9af009fd11

[10:52] <dalek> rakudo: 142ceba | colomon++ | t/spectest.data:

[10:52] <dalek> rakudo: Add S32-list/roll.t to the list of spectests.

[10:52] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/142cebabaa858e0628533f614d6faab4349d1e00

[10:56] *** Mowah left
[10:59] *** Italian_Plumber joined
[11:00] <dalek> roast: 091d652 | colomon++ | S02-builtin_data_types/range.t:

[11:00] <dalek> roast: [t/spec] Unfudge three tests that work now.

[11:00] <dalek> roast: review: http://github.com/perl6/roast/commit/091d652cef9875d99edae624f2273febda2da838

[11:22] <tadzik> hah, compiling the file with just POD to pir resulted in 139 lines of pir

[11:22] <tadzik> that's what you call „reading between the lines”

[11:22] <toebu> I am playing with Exceptions and CATCH ... I try to create my own exception where I can supply an error number along with the error message ... my perl5 derived ideas of die with an exception object do not seem to work ... any hints ?

[11:23] *** gfx joined
[11:24] *** rgrau joined
[11:27] <tadzik> toebu: I'm afraid you can only die with a string now

[11:29] <moritz_> colomon: btw now that t/spec is a separate repo, there's no need to include [t/spec] in the commit message anymore :-)

[11:30] <toebu> <tadzik> because of implementation limitations ?

[11:32] <tadzik> wow, it looks as if I said that

[11:32] <tadzik> toebu: I think so

[11:33] <toebu> according to docs I should be able todo -- class Bad is Exception {}; die Bad("Error"); and then CATCH { when Bad { ... }}}; ... but this causes rakudo to complain about not knowing sub &Bad ... which seems logical as this is a class and not an object ... 

[11:33] <toebu> is looking at http://perlcabal.org/~azawawi/html/spec/S04-exception-handlers/catch.t.simple.html for inspiration

[11:34] <moritz_> well, probably Bad.new("Error")

[11:34] * moritz_ not sure about the coercion syntax

[11:34] <tadzik> . o O ( File::Glob )

[11:35] * moritz_ plans to work on the user facing part of the exception system soonish

[11:36] <moritz_> I've written a grant application for it, but due to $real-life-uncertainties I hesitate to submit it at the moment

[11:37] <toebu> moritz_ yes when I do Bad.new('msg') it works except that the when Bad { ... }  in the CATCH block does not react ...

[11:38] <toebu> moritz_: glad to hear :-) I am rather fond of using exceptions in my code ... 

[11:41] *** [particle]1 joined
[11:44] *** [particle] left
[11:52] *** mikehh joined
[11:54] *** satyavvd left
[12:02] <colomon> moritz_: but I worked so long to develop the habit of adding [t/spec] !

[12:02] <phenny> colomon: 07:54Z <tadzik> tell colomon I commented your commit on github, I think I see some code redundancy in here

[12:02] <colomon> tadzik: thank you.

[12:03] <tadzik> thank You :)

[12:03] <moritz_> colomon: :-) things change

[12:05] <takadonet> morning all

[12:08] *** cls_bsd left
[12:08] *** cls_bsd joined
[12:17] <dalek> rakudo: 705379c | masak++ | src/core/Instant.pm:

[12:17] <dalek> rakudo: [core/Instant] added 'Real' role as per spec

[12:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/705379c1633f9b2d826d69248f05f803fc329302

[12:18] <masak> rakudo: class Hitchhiker { my $defaultanswer = 0; has $.ans1 = $defaultanswer; has $.ans2 = { $defaultanswer }; has $.ans3 = { { $defaultanswer } }; $defaultanswer = 42; }; say (.ans1, .ans2, .ans3).perl given Hitchhiker.new

[12:18] <p6eval> rakudo cd151f: OUTPUT«(42, { ... }, { ... })␤»

[12:18] <masak> A12 begs to differ.

[12:19] <masak> says it should be (0, 42, { ... })

[12:19] <masak> is A12 right, or have things changed since then?

[12:20] <moritz_> 0 seems wrong

[12:20] <moritz_> because the assignment is run at class construction time

[12:21] <masak> that's why 0 is right, innit?

[12:21] <moritz_> whereas the RHS of has $.ans1 =  is a thunk that's run at object construction time

[12:21] <masak> oh, you mean at the end of the class block.

[12:21] <moritz_> so, it's a bit like  my $x = 3; say $x; INIT {$x = 42 }

[12:21] <moritz_> right

[12:21] <masak> well, A12 talks about an 'is build' trait that's implicit for attribute assignments.

[12:22] <moritz_> I don't think S12 mentions that

[12:23] *** sftp joined
[12:24] <masak> I'll say this for the picture A12 paints up: it feels quite consistent.

[12:24] *** Kodi joined
[12:25] <moritz_> well, the picture in S12 also feels quite consistent :-)

[12:26] <masak> sure, if you realize that the rhs of the attributes are executed at class construction time.

[12:26] <moritz_> s/class/object/

[12:26] <masak> hm.

[12:27] <moritz_> which you need for  has $.x = 5; has $.y = 2 * $.x;  to DWYM

[12:27] <moritz_> right now you can call A.new(x => 10) and have $.y being 20

[12:27] <masak> right, since the second $.x presupposes a defined object.

[12:27] <moritz_> which is quite nice

[12:28] <masak> agreed.

[12:29] <masak> this is not-quite-nice, however:

[12:29] <masak> rakudo: class A { has $.a = 4 }; say A.new.a; class B { has $.b = 4; submethod BUILD {} }; say B.new.b

[12:29] <p6eval> rakudo cd151f: OUTPUT«4␤Any()␤»

[12:29] <masak> the presence of a BUILD submethod prevents defaults from being set.

[12:30] <moritz_> yes. Known and reported. And annoying.

[12:30] <masak> nodnod, nod.

[12:33] *** rindolf joined
[12:37] <toebu> \msg p6eval rakudo: my $x = 'a'; say <<$x a>>.join(',');

[12:38] <toebu>  rakudo cd151f: OUTPUT􏿽xAB$x,a?􏿽xBB

[12:38] <toebu> so rakudo does not understand texas brackets ? right ?

[12:38] <moritz_> seems like, yes

[12:39] <masak> looks like an encoding problem.

[12:39] <masak> insufficient data whether it is in Rakudo, p6eval, or toebu's client.

[12:39] <moritz_> rakudo: my $x = 'a'; say <<$x a>>.join(',');

[12:39] <p6eval> rakudo cd151f: OUTPUT«$x,a␤»

[12:39] <masak> that rules out the first two :P

[12:40] <colomon> what are texas brackets supposed to do in this case?

[12:41] <moritz_> interpolate, then split

[12:42] <masak> oh, what toebu was asking about was the semantics. I see.

[12:42] <masak> right, there's a TODO ticket in RT about that.

[12:43] <moritz_> alpha: my $x = 'a'; say <<$x a>>.join(',');

[12:43] <p6eval> alpha 30e0ed: OUTPUT«a,a␤»

[12:43] <moritz_> pugs: my $x = 'a'; say <<$x a>>.join(',');

[12:43] <p6eval> pugs: OUTPUT«a,a␤»

[12:43] <masak> alpha: my $x = 'a b c'; say <<$x a>>.join(',');

[12:43] <p6eval> alpha 30e0ed: OUTPUT«a b c,a␤»

[12:43] <masak> half right.

[12:44] <moritz_> pugs: my $x = 'a b c'; say <<$x a>>.join(',');

[12:44] <p6eval> pugs: OUTPUT«a,b,c,a␤»

[12:44] <moritz_> pugs++

[12:44] <moritz_> au|irc++

[12:44] <masak> Pugs++

[12:45] *** alester joined
[12:46] <toebu> bows gracefully

[12:48] <toebu> is writing up the perl6 class for LISA and only wants to put in stuff that actuallly works :-) texas quotes sound like a realy cool thing ... 

[12:49] *** gfx left
[12:49] <moritz_> indeed

[12:51] *** patspam joined
[12:55] <rindolf> What are texas quotes?

[12:55] <colomon> rindolf:  <<   and    >>

[12:55] <rindolf> colomon: ah.

[12:55] <rindolf> colomon: aren't they called guillaumes?

[12:55] <Kodi> rindolf: Guillemets, last I heard.

[12:55] <colomon> rindolf:  that's  «  and  »

[12:56] <masak> aka French quotes.

[12:57] <toebu> texas quotes are like the french ones only bigger :-) ... says damian

[12:58] <moritz_> <<...>>

[12:58] <moritz_> see S02

[12:58] <toebu> rakudo: $x = 'a'; say Q:s /$x/; OUTPUT􏿽xAB===SORRY!===?Colons may not be used to delimit quoting constructs at line 22, near ":s /$x/;"?􏿽xBB

[12:58] <p6eval> rakudo 705379: OUTPUT«===SORRY!===␤Colons may not be used to delimit quoting constructs at line 22, near ":s /$x/; O"␤»

[12:59] <moritz_> toebu: that's the unfriendly way of saying "quote adverbs are not yet implemented"

[12:59] <toebu> smile

[13:00] <toebu> guess I should read the disclaimer on the rakudo shrinkwrap a bit more attentively :-)

[13:01] *** rgrau left
[13:01] *** alester left
[13:01] <masak> early adopter beware.

[13:03] <masak> from the bright side, one eventually settles into a use of the implemented features, only occasionally running into new bugs.

[13:04] *** vdrab joined
[13:04] *** cognominal joined
[13:07] *** tadzik left
[13:10] *** am0c joined
[13:11] <flussence> curl: (26) failed creating formpost data

[13:11] <flussence> make: *** [spectest_smolder] Error 26

[13:11] <flussence> :(

[13:11] *** [particle]1 is now known as [particle]

[13:13] <flussence> "make spectest_smolder" gets to the end, but then it explodes; http://gist.github.com/582402

[13:15] <moritz_> flussence: is there a rakudo_test_run.tar.gz file in the rakudo dir?

[13:15] <flussence> nope

[13:16] <moritz_> flussence: which would explain why it failed...

[13:17] *** Patterner left
[13:19] *** jferrero left
[13:21] <Kodi> Could someone review my latest patch? http://rt.perl.org/rt3/Ticket/Display.html?id=77896

[13:25] <moritz_> I fear that it touches too many areas I'm not familiar with

[13:25] <moritz_> I hope that pmichaud or jnthn can do it

[13:28] *** Psyche^ joined
[13:28] *** Psyche^ is now known as Patterner

[13:36] *** jedai left
[13:37] *** wolverian left
[13:38] <PerlJam> Kodi: removing the multi sub infix:<-> in the middle of that patch seems like it doesn't belong.

[13:38] <PerlJam> (src/core/Duration.pm)

[13:44] *** cotto left
[13:48] <Kodi> PerlJam: But otherwise, the test

[13:48] <Kodi> isa_ok $t0 - $d, Instant, 'Instant - Duration ~~ Instant';

[13:48] <Kodi> must fail.

[13:49] <Kodi> (That's from S02-builtin_data_types/instants-and-durations.t.)

[13:51] *** sirhc joined
[13:51] <PerlJam> Kodi: sure ... what I mean is that the Duration fix should be a separate patch/commit

[13:52] <flussence> okay, I've figured out it wanted TAP::Harness::Archive for the tests. Should I bother re-running them?

[13:52] <PerlJam> Kodi: but beyond that, what moritz_ said.  :)

[13:52] <moritz_> flussence: if you have it installed now, yes

[13:52] <flussence> ok then

[13:53] <moritz_> so far we only have two submissions, both from me

[13:53] <Kodi> PerlJam: Oh, I see. Yeah, I agree in spirit, but getting patches into Rakudo usually takes a certain amount of time and effort, so I don't want the overhead of a separate three-line patch.

[13:54] <moritz_> Kodi: a separate three-line patch is more likely to get applied quickly

[13:54] *** daemon left
[13:54] <PerlJam>  moritz_: soon to be one from me if my machine ever finishes.

[13:54] <Kodi> moritz_: Point.

[13:55] *** icwiener joined
[13:57] *** Guest23195 left
[13:57] <gottreu> rakudo: say ~(<not lists>, <parcels are>).reverse

[13:58] <p6eval> rakudo 705379: OUTPUT«parcels are not lists␤»

[13:58] <gottreu> That is correct behavior, right?

[13:58] <moritz_> rakudo: say ~(<not lists>, <parcels are>).flat.reverse

[13:58] <p6eval> rakudo 705379: OUTPUT«are parcels lists not␤»

[13:58] <gottreu> right.  reverse not auto-flattening like join is the correct thing for rakudo to do?

[13:58] <moritz_> sounds about right

[13:59] <moritz_> but I'm not really sure

[14:02] *** icwiener_ joined
[14:02] *** icwiener left
[14:02] <toebu> wonders, how to i use ^attributes to show what attributes a method expects ?

[14:02] <moritz_> you don't

[14:03] <toebu> cry

[14:03] <moritz_> attributes are object data

[14:03] <toebu> hmmm

[14:03] * moritz_ -> afk

[14:04] <toebu> so ^methods will tell me what methods are available, but I can't figure out their argument specs ?

[14:04] <masak> .signature

[14:04] <moritz_> you can ask the methods for .signature for example

[14:04] <toebu> aaah .. tries

[14:09] <toebu> so I do for Mu.^methods -> $m { say $m XXXX ? } ... what would XXX be o get a list of methods with signatures ?

[14:10] <PerlJam> toebu: you probably want $m.signature.perl

[14:10] *** daemon joined
[14:11] <masak> except that doesn't work when it's a Perl6MultiSub, it seems :/

[14:13] <PerlJam> ouch

[14:14] <PerlJam> Hmm. or when it's a Sub either.

[14:15] *** uniejo left
[14:15] <PerlJam> (I just tried toebu's Mu example and it dies on  .defined with "get_attr_str() not implemented in class 'Sub'")

[14:15] <masak> I also got Sub.

[14:15] <masak> when is a method a Sub?

[14:15] <toebu> guess I will limit myself to the $m.name ... that works ... 

[14:15] <PerlJam> when rakudo is confused?

[14:17] <toebu> I guess a methos is a Sub when it is unique 

[14:18] <masak> yes, but should it? I'd prefer it to be, I dunno, a Method.

[14:18] <PerlJam> masak: that's just crazy talk!

[14:19] <toebu> masak: you mean maybe there is a different syntax to be used for this ?

[14:19] *** Kodi left
[14:19] <masak> toebu: no, you're on the right track. just hitting a lot of pain that shouldn't be there in the long run.

[14:20] <toebu> nod

[14:20] <PerlJam> I suppose that this will be a problem for any of the methods that are cheats

[14:20] <PerlJam> ls

[14:20] <toebu> I tried it by defining my own class ... the result was the same

[14:21] <PerlJam> toebu: if you're only interested in the methods defined within your class, make sure you're using ^.methods(:local)

[14:22] <PerlJam> er, .^methods(:local)

[14:22] <toebu> thanks

[14:28] *** thebird left
[14:34] *** yoasif left
[14:38] *** \xF0 left
[14:38] *** wtw left
[14:46] *** meinwald is now known as meinwald5

[14:46] *** meinwald5 is now known as meinwald

[14:49] *** nymacro joined
[14:57] <bbkr> rakudo: class A {sub foo {}}; A.new.^methods(local=>True).perl.say

[14:57] <p6eval> rakudo 705379: OUTPUT«[]␤»

[14:57] <bbkr> rakudo: class A {method foo {}}; A.new.^methods(local=>True).perl.say

[14:57] <p6eval> rakudo 705379: OUTPUT«[{ ... }]␤»

[15:04] *** risou joined
[15:06] <bbkr> rakudo: A.new.HOW.methods.say # bug? Spec says that "The ^ metasyntax is equivalent to .HOW" so I expect it to work like A.new.^methods.say (which works). am I missing something?

[15:06] <p6eval> rakudo 705379: OUTPUT«Could not find sub &A␤  in main program body at line 22:/tmp/RNsUDBugwZ␤»

[15:06] <bbkr> rakudo: class A{}; A.new.HOW.methods.say # bug? Spec says that "The ^ metasyntax is equivalent to .HOW" so I expect it to work like A.new.^methods.say (which works). am I missing something?

[15:07] *** \xF0 joined
[15:07] <p6eval> rakudo 705379: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤  in main program body at line 22:/tmp/jcXYdV_byv␤»

[15:10] <PerlJam> bbkr: no, you're not using HOW appropriately.  It's something like  A.new.HOW(A).methods.say

[15:10] *** thebird joined
[15:10] *** vdrab_ joined
[15:10] <PerlJam> rakudo: class A{}; A.new.HOW(A).methods.say;

[15:10] *** vdrab_ left
[15:10] <p6eval> rakudo 705379: OUTPUT«too many positional arguments: 2 passed, 1 expected␤  in main program body at line 22:/tmp/gFvODF2S70␤»

[15:11] <PerlJam> bbkr: well, it's something like that anyway. 

[15:13] <PerlJam> rakudo: class A{}; A.new.HOW.methods(A).join(" ").say

[15:13] <p6eval> rakudo 705379: OUTPUT«grep none values Numeric elems end all roll Str keys postcircumfix:<[ ]> postcircumfix:<{ }> uniq classify pairs kv one ACCEPTS pick flat any Seq minmax does rotate join can reduce list reverse at_key isa map min max at_pos sort first new Bool say print item WALK defined BUILD

[15:13] <p6eval> ..clon…

[15:13] *** vdrab left
[15:14] <PerlJam> rakudo: class A{};  HOW(A).methods(A).say

[15:14] <p6eval> rakudo 705379: OUTPUT«Could not find sub &HOW␤  in main program body at line 22:/tmp/kuhyfg86P7␤»

[15:15] *** Guest23195 joined
[15:15] <PerlJam> S02:635 or so

[15:15] *** risou left
[15:15] <flussence> it'd be nice if the "too (many|few) positional arguments" error said what method name caused the error...

[15:16] <PerlJam> flussence++

[15:16] <PerlJam> especially since perl6 is more oopy and chained method calls will be more common

[15:16] *** Trashlord left
[15:22] *** rgrau joined
[15:27] *** xinming left
[15:27] *** xinming joined
[15:28] *** rgrau left
[15:28] *** tadzik joined
[15:34] <pmichaud> good morning, #perl6

[15:35] <takadonet> pmichaud: morning

[15:35] <PerlJam> morning pm

[15:35] *** Holy_Cow joined
[15:35] <jnthn> tadzik: $obj.^foo is not just $obj.HOW.foo, it does $obj.HOW.foo($obj)

[15:35] <jnthn> oh, gah

[15:35] <jnthn> bbkr: ^^

[15:35] <jnthn> morning, pmichaud 

[15:36] * jnthn makes a quick trip to the systemka, bbs

[15:36] <bbkr> PerlJam: thanks

[15:37] *** thebird left
[15:38] <masak> morning, pmichaud 

[15:40] <pmichaud> "Perl 6 -- It's more oopy."  -- PerlJam

[15:40] <pmichaud> (does that mean it makes you say "oops" more often? ;-)

[15:40] <PerlJam> all the time

[15:41] <masak> most often on behalf of Rakudo :P

[15:43] <tadzik> why is try.rakudo.org down? :(

[15:44] *** Mowah joined
[15:45] <tadzik> rakudo: say ~(1, 1, *+* ... 400) # how do I do this with the new series specs?

[15:45] <p6eval> rakudo 705379: OUTPUT«(timeout)»

[15:46] <masak> rakudo: say ~(1, 1, *+* ... * >=400)

[15:46] <p6eval> rakudo 705379: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144 233 377 610␤»

[15:46] <masak> rakudo: say ~(1, 1, *+* ...^ * >=400)

[15:46] <p6eval> rakudo 705379: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144 233 377␤»

[15:47] <TimToady> or > if you want the 400

[15:48] <PerlJam> examples like that make me think the ...^ op is going to get a lot more use than I previously thought

[15:49] *** tadzik left
[15:49] <masak> PerlJam: I thought the same after the spec changed to its current configuration.

[15:53] <PerlJam> so ... why smart match for termination rather than inclusion?

[15:54] <TimToady> because ... 42 is a termination match already

[15:54] <TimToady> so it's consistent

[15:55] <pmichaud> I tend to think of series as "1, 2, 3, up to $n"

[15:55] <pmichaud> and "up to" reads more like an 'until' than a 'while'

[15:55] <pmichaud> to me, at any rate.

[15:55] <PerlJam> so you read ... and ...^ both as "up to" ?

[15:55] <pmichaud> ... up to and including

[15:55] <pmichaud> ...^ up to

[15:56] <TimToady> up thru

[15:56] <pmichaud> (and excluding)

[15:58] <TimToady> rakudo: say ~(1, 1, *+* ...^ 400<*)

[15:58] <p6eval> rakudo 705379: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144 233 377␤»

[15:58] <TimToady> rakudo: say ~(1, 1, *+* ...^ 377<*)

[15:58] <p6eval> rakudo 705379: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144 233 377␤»

[15:58] <PerlJam> in any case, I can see a few FAQs on the horizon relating to series

[15:58] <TimToady> yes, it's less dwimmy than it used to be, but more consistent

[15:58] <TimToady> perhaps there's a missing predicate that would help keep things straight

[15:58] <masak> as part of restoring my blog, I end up looking at ancient blog posts. this made me stumble upon the deprecated "string" ~~ SomeGrammar matching syntax. what was the reason for scrapping that, again?

[15:59] <pmichaud> that's a 'does' check.

[15:59] <masak> std: say ~(1, 1, *+* ...^ 400<*)

[15:59] <p6eval> std : OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse quote-words subscript; couldn't find right angle quote at /tmp/Ndwh4Z4sfx line 1:␤------> [32msay ~(1, 1, *+* ...^ 400<[33m⏏[31m*)[0m␤    expecting escape␤Parse failed␤FAILED 00:01 118m␤»

[15:59] <TimToady> heh

[15:59] *** justatheory joined
[15:59] <pmichaud> SomeGrammar is a type object

[15:59] <masak> pmichaud: but, couldn't the grammar metaclass easily override that?

[15:59] <pmichaud> masak: we tried that.... and things get quickly confusing.

[16:00] <masak> oki. that's good enough for me.

[16:00] *** gbacon joined
[16:00] <masak> what about overriding infix:<~~> for grammars, then?

[16:01] <TimToady> how does that help 'when'?

[16:02] <masak> oh. I see what you mean.

[16:02] <pmichaud> in theory,   "string" ~~ SomeGrammar.new  could be made to work, I suppose.

[16:02] <pmichaud> (if it doesn't already)

[16:02] *** Ross^ joined
[16:02] <TimToady> yes, it's grammar objects that do the matching, not grammar types

[16:02] <masak> anyway, just wondering. that syntax was pretty schweet.

[16:03] <TimToady> .parse is just a constructor

[16:03] <PerlJam> "string" ~~ SomeGrammar.parse doesn't seem too bad to me :)

[16:03] <TimToady> .parse($_)

[16:04] <TimToady> and then why not just .parse("string")

[16:04] *** daxim left
[16:05] <TimToady> an argument could be made for a Str.parse(Grammar) form though

[16:05] <TimToady> or .parsewith

[16:06] <pmichaud> don't we already have .match?

[16:06] <pmichaud> or did that disappear somewhere?

[16:06] <TimToady> does that take a grammar argument?

[16:06] <pmichaud> it *could*  :-)

[16:07] <TimToady> and presumably *excludes* type matching...

[16:07] <pmichaud> unless, of course, .matc.... right

[16:07] <pmichaud> anyway, I'd be fine with Cool.parse

[16:07] <pmichaud> (or Str.parse if we want to limit a bit further)

[16:08] *** sahadev joined
[16:11] * jnthn back :-)

[16:11] <PerlJam> how useful would 3.1415.parse(NumberGrammar) be?

[16:11] <jnthn> Hope to get some Perl 6 hacking in this evening. :-)

[16:11] *** araujo left
[16:11] *** Kodi joined
[16:12] *** tadzik joined
[16:12] <TimToady> we should probably limit to Stringy for now

[16:15] *** envi^home joined
[16:16] <masak> TimToady: on p6l. jkpeters_37++ points out a likely thinko in the pick/roll split spec patch.

[16:17] *** alester joined
[16:20] *** cdarroch joined
[16:20] *** cdarroch left
[16:20] *** cdarroch joined
[16:22] <gottreu> TimToady: is .reverse not flattening a Parcel, while .join does correct behaviour?

[16:23] <Kodi> pmichaud: Thanks for your comments. I didn't use .!STORE because infix:<=> ignores .!STORE if the lvalue is scalar. Would you prefer changing that to using my .ASSIGN nonsense?

[16:26] *** Trashlord joined
[16:28] *** thebird joined
[16:31] *** timbunce_ joined
[16:32] *** timbunce left
[16:32] *** timbunce_ is now known as timbunce

[16:34] *** ruoso joined
[16:34] *** molaf joined
[16:39] <pmichaud> Kodi: perhaps.  I need to think a bit more about how that should work.

[16:40] <pmichaud> The real question is knowing how     my $x is Hash;   $x = <something>;   should work

[16:40] <TimToady> rakudo: say (1,2,(3,4)).reverse.perl

[16:41] <p6eval> rakudo 705379: OUTPUT«((3, 4), 2, 1)␤»

[16:41] <jnthn> (speculative) maybe it's something along the lines of having a multi trait_mod:<is>(ContainerDeclarand $c, Mu:U $ctype) { ... }

[16:41] <TimToady> gottreu: yes, I suspect you're right

[16:42] <gottreu> TimToady: I can't be right, I don't know what right or wrong are.

[16:42] <TimToady> :)

[16:43] <Kodi> The idea of making the kind of assignment depend only on the container (as opposed to the sigil) of the lvalue appeals to me.

[16:43] <TimToady> it seems to me that .reverse should flatten like .join

[16:43] <pmichaud> do we have some sort of general rule to know what flattens and what doesn't?  it seems a bit ad-hoc to me.

[16:43] <gottreu> .map doesn't flatten

[16:43] <Kodi> But perhaps that would make list assignment all the more complicated.

[16:44] <dalek> specs: 61e2e1a | TimToady++ | S32-setting-library/Containers.pod:

[16:44] <dalek> specs: copy-paste issues with new roll method

[16:44] <dalek> specs: 

[16:44] <dalek> specs: jkpeters_37++ points out a problem in the new specs for .roll, which

[16:44] <dalek> specs: are now revised for (I hope) more clarity.

[16:44] <dalek> specs: review: http://github.com/perl6/specs/commit/61e2e1a1f54bb0fbefbdd932d95f28f3df2a172e

[16:44] <gottreu> pmichaud: doesn't the synopses say something like "the previous and following material may all be wrong regarding flattening"

[16:44] <PerlJam> Why would some flatten and others not when we can always throw .flat into the mix ?

[16:45] <pmichaud> gottreu: yes, which is why I'm asking if we have some way of making it less wrong :)

[16:45] <gottreu> Does it have to do with context?  Of List vs Array vs Seq vs Parcel ?

[16:45] <pmichaud> gottreu: especially since I'm the one currently charged with updating those parts of the synopses :)

[16:45] <gottreu> pmichaud: OH, i see.

[16:45] <colomon> rakudo: Bool.roll(10).perl.say

[16:46] <p6eval> rakudo 705379: OUTPUT«(Bool::True, Bool::True, Bool::True, Bool::True, Bool::False, Bool::True, Bool::False, Bool::False, Bool::True, Bool::True)␤»

[16:46] <pmichaud> Kodi: making it dependent on the container does have a lot of merit, yes.  That probably requires a huge cleanup of our existing Perl6Scalar usage, though.

[16:47] <jnthn> rakudo: class Rick is Cool { }; Rick.roll(10).perl.say

[16:47] <tadzik> :D

[16:47] <p6eval> rakudo 705379: OUTPUT«(Rick, Rick, Rick, Rick, Rick, Rick, Rick, Rick, Rick, Rick)␤»

[16:48] <PerlJam> jnthn: it would have been an awesome easter egg had that output ('Never', 'gonna', 'give', 'you', 'up' ... )

[16:48] <jnthn> :-)

[16:48] <pmichaud> fsvo "awesome".

[16:49] <pmichaud> maybe someday:

[16:49] <gottreu> fsvo: for some values of?

[16:49] <pmichaud> enum Rick <Never gonna give you up>;   Rick.roll(10).perl.say   :-)

[16:50] <jnthn> rakudo: enum Rick <Never gonna give you up>; Rick.roll(5).perl.say

[16:50] <huf> what's roll()?

[16:50] <p6eval> rakudo 705379: OUTPUT«(, , , , )␤»

[16:50] <jnthn> FAIL.

[16:50] <TimToady> if we want it to remain inconsistent, seems like it might have to do with whether there's a redirection through Any to List, which might (or might not) imply flattening

[16:50] <TimToady> but I'll have to ponder what the correct default or non-default is here

[16:50] <pmichaud> currently Parcel special-cases  .join, .sort, etc   to first do .flat

[16:51] <PerlJam> huf: .roll is like pick, but with replacement

[16:51] <pmichaud> I can do that for .roll and .pick also, but....

[16:51] <pmichaud> "Less memorization of special cases..."  :-)

[16:51] <huf> PerlJam: and for classes it just acts as if the class were a one-element list with its classname in it? or?

[16:51] <Kodi> pmichaud: In the meantime, we don't have any code that depends on !STORE methods of scalar containers being ignored, do we? That would be pretty crazy.

[16:52] <pmichaud> Kodi: Yes, we do.

[16:52] <pmichaud> Kodi: because of:

[16:52] <pmichaud> my $x = [1, 2, 3];   $x = 5;

[16:52] <TimToady> rakudo: say (reverse 1,2,(3,4),5).perl

[16:52] <TimToady> oops

[16:52] <p6eval> rakudo 705379: OUTPUT«(5, 4, 3, 2, 1)␤»

[16:52] <TimToady> then we have to explain that difference instead

[16:52] <pmichaud> the result of that should be that $x is a 5.  We don't want it to go to the Array's !STORE method.

[16:53] <PerlJam> huf: a one element list consisting of a single (undefined) instance of that class

[16:53] <Kodi> But the container of $x doesn't get the !STORE there; its value does. Right? Or am I misunderstanding the true nature of the container-value distinction?

[16:53] <huf> PerlJam: ah, which stringifies to the name, yeah

[16:53] <Kodi> As in, $x might hold an Array, but $x itself it unchanged.

[16:53] <pmichaud> Kodi: at present we don't have a way of attaching methods to (scalar) containers.

[16:54] <pmichaud> whenever a scalar gets a method invocation, it forwards it to its value

[16:54] <TimToady> rakudo: say map *-1, 1,2,(3,4),5

[16:55] <p6eval> rakudo 705379: OUTPUT«01234␤»

[16:55] <Kodi> pmichaud: Oh, bummer.

[16:55] <pmichaud> TimToady: the flattening there is due to the listop (passing the values to a slurpy array)

[16:55] <gottreu> rakudo: (1,2,(3,4),5).map({$_*-1})

[16:56] <p6eval> rakudo 705379:  ( no output )

[16:56] <Kodi> pmichaud: I'm tempted to just use a PMC property instead… which brings us back to square one.

[16:56] <gottreu> rakudo: say (1,2,(3,4),5).map({$_*-1})

[16:56] <p6eval> rakudo 705379: OUTPUT«-1-2-2-5␤»

[16:56] <TimToady> I know, just trying to argue both sides from the viewpoint of the typical programmer as to whether Any-lists are better as flattening

[16:56] <TimToady> where Any-lists are the ones that are "naturally listy" in the language

[16:56] <pmichaud> Kodi: well, assignment can check the type of the target container instead of checking the 'scalar' property.

[16:57] *** thowe joined
[16:57] *** dakkar left
[16:57] <thowe> hello

[16:57] <pmichaud> I have it checking the 'scalar' property now simply because Rakudo's use of the Perl6Scalar type is inconsistent, and I was under a heavy time constraint at the time that I was trying to get lists, iterators, arrays, etc. to work.

[16:57] <PerlJam> TimToady: There's a typical programmer?

[16:57] <pmichaud> PerlJam: Yes.  We keep him in a box.

[16:58] <PerlJam> pmichaud: Did Schroedinger make the box?

[16:58] <pmichaud> PerlJam: I've been too afraid to look inside to find out.

[16:58] <rokoteko> pmichaud: remember to feed him also :(

[16:59] <TimToady> it's a really big box, with several kinds of fast food

[16:59] <gottreu> You don't really keep him there.  You put him in once, and he's just never bothered to leave.

[16:59] <PerlJam> TimToady: anyway, this a case where a programmer coming from lisp and a programmer coming from perl 5 would fall on opposite sides of the fence I think.

[16:59] <pmichaud> ...there's a fence?  ;-)

[17:00] <PerlJam> right through the middle of the box

[17:00] <TimToady> PerlJam: yup

[17:00] <pmichaud> I think the fence should be purple.

[17:00] *** Trashlord left
[17:00] <pmichaud> that way it will match the bikeshed.  :)

[17:00] <gottreu> I think the fence should have an area to chain bikes.

[17:00] <PerlJam> It just looke like a fence ... really it's a bike rack

[17:01] <TimToady> whether flat or slice should be the default is somewhat cultural, and where the default should *be* the default is also debatable

[17:01] <rokoteko> hmm. this is not very clear conversation.. Im puzzled if they fell from the sides they originated from or the sides of each other?

[17:01] * pmichaud exits silliness mode for a while.

[17:01] <TimToady> that's long enough

[17:02] <Kodi> pmichaud: Would it be hard to make scalars avoid forwarding !STORE calls to their values?

[17:02] <PerlJam> TimToady: Perl 6 leans quite a bit farther towards the FP style, so ....  what would guy steele do?  ;)

[17:02] <Kodi> (Or perhaps I should just try it and find out.)

[17:04] *** Trashlord joined
[17:04] <pmichaud> Kodi: just as a general note, I'm not likely to want to apply patches dealing with containers until after I get the Hash refactor done.  I'm very happy that you want to work on it (and encourage more investigation), but there are quite a few other fundamental pieces that need to be cleaned up before I go adding more complexity on top.

[17:04] <pmichaud> here's an example:

[17:05] <pmichaud> rakudo:  my @a;  say @a.defined;

[17:05] *** thebird left
[17:05] <p6eval> rakudo 705379: OUTPUT«1␤»

[17:05] <pmichaud> I'm guessing that should be false.

[17:05] <TimToady> yes

[17:05] <TimToady> due to imlicit = Nil

[17:05] <TimToady> *p

[17:05] *** kjeldahl_ left
[17:05] <pmichaud> So, that implies a lot of fundamental changes to container setup and binding which really want to be ironed out first.

[17:05] * TimToady ponders an illicit Nil

[17:06] <Kodi> pmichaud: I see. Fair enough.

[17:07] <Kodi> pmichaud: I don't suppose you plan on getting hashes to permit non-string keys during this refactor?

[17:07] <pmichaud> Kodi: not during the first refactor, no.  But the second one could do it.

[17:07] <pmichaud> That also depends on Parrot's support for non-string hash keys

[17:07] <PerlJam> "containers" seem to be a very fundamental thing that have been done and redone many times over the years (in parrot and then rakudo)

[17:08] <pmichaud> and before we do that, we probably want to get typed arrays working first, too.

[17:08] <pmichaud> (since they touch on very similar issues)

[17:08] <pmichaud> PerlJam: Yes, they are frequently redone as we discover new corner cases in the spec.

[17:08] *** envi^home left
[17:08] <Kodi> I imagine, actually, that on the Parrot level you'd use a string-keyed hash, the strings being generated by calls to .WHICH.

[17:09] <PerlJam> It seems crazy that we haven't found all of the corners yet

[17:09] <pmichaud> PerlJam: well, the spec has been (is still?) self-inconsistent in some areas, so the corners keep moving.

[17:10] <pmichaud> Consider that we didn't have a 'flat' contextualizer a year ago, and the meaning of 'Nil' has changed a few times, and ....

[17:10] <PerlJam> maybe I'm just falling into the same trap as those people who say/said "They're already got Perl 5; what's taking Perl 6 so long?"

[17:10] <TimToady> the number of corners goes up in proportion to the <mumble> of the number of dimensions

[17:10] <jnthn> It's like finding the corners in a spherical room. :-)

[17:10] <TimToady> more like a Hilbert room.

[17:10] <pmichaud> or inside of a box with indeterminate stat...... oh, I said I was out of silliness mode :)

[17:10] <Kodi> The average programmer must get awfully nauseous in such a rapidly spinning box.

[17:11] <TimToady> pmichaud: that was a long time ago

[17:11] <TimToady> it's not spinning now, it's rolling

[17:11] <pmichaud> TimToady: hard for me to know, all of my clocks are running backward.  :)

[17:11] <PerlJam> TimToady: so, what's the dimensionality of the Perl 6 fractal as currently specced?

[17:11] <TimToady> were you Merlin in a future life?

[17:11] <pmichaud> TimToady: I'm waiting to find out.  :)

[17:12] <ingy> goood morning freaks!

[17:12] <TimToady> PerlJam: before or after you call .flat?

[17:13] <pmichaud> (or if it's done for you implicitly :-)

[17:13] <TimToady> that depends on whether you're the implementor or the user

[17:14] * PerlJam ponders if ingy is just being friendly or if he should worry that *ingy* called #perl6 freaks.

[17:14] <TimToady> it was probably a compliment

[17:14] *** Chillance joined
[17:15] <ingy> PerlJam: pick any 3

[17:16] <ingy> and multiply by 2

[17:16] <PerlJam> woot!  that favors a good outcome  :)

[17:16] *** muixirt joined
[17:16] <moritz_> rakudo: say pick any 3

[17:16] <p6eval> rakudo 705379: OUTPUT«any()␤»

[17:19] <TimToady> rakudo: say (1,2,(3,4),5).map: *-1

[17:19] <p6eval> rakudo 705379: OUTPUT«0114␤»

[17:22] *** colomon left
[17:24] <Kodi> pmichaud: At any rate, you've got your work cut out for you. Is there any way I can help? (I will submit a separate patch for the Duration issue.)

[17:24] <pmichaud> Kodi: good question

[17:25] <pmichaud> I'm trying to decide if it's better for me to tackle the Hash issue first or the container one.

[17:25] <pmichaud> I think probably Hash, since it's a bit more intricate and needs greater refactoring

[17:26] <Kodi> You don't think changing containers will make you need to go back and redo some of what you did for hashes?

[17:26] <pmichaud> not really

[17:26] <pmichaud> handling containers is a lot like the autoviv issue, which I already handled in the case of arrays (so I know what to expect)

[17:27] <pmichaud> when redesigning hashes I can keep that in mind

[17:27] <pmichaud> or, put another way, trying to get containers to work with the existing hash messiness is likely to be much more difficult than it needs to be

[17:27] <pmichaud> something that would _really_ help is to make sure our existing usage of Perl6Scalar is consistent

[17:28] <pmichaud> currently we have ObjectRef and Perl6Scalar

[17:28] <pmichaud> both of them are "reference types" in the sense that they forward methods and other items to an underlying value

[17:28] <pmichaud> Perl6Scalar should be used exclusively for scalar containers.... there may be some places where it gets used as a normal reference, though.

[17:29] <pmichaud> if we could find and eliminate those, that'd be helpful

[17:29] <pmichaud> so, one thing you could do is to see if it's possible to switch assignment so that it tests the target for Perl6Scalar instead of the 'scalar' flag.

[17:29] <Kodi> Right.

[17:29] <pmichaud> and then see what breaks

[17:29] <Kodi> And deal with the fallout.

[17:29] <Kodi> :)

[17:29] <pmichaud> I highly recommend doing all of this in a branch.

[17:30] <Kodi> I would locally, sure, but do you mean that any patch I created to be applied to something other than master?

[17:30] <Kodi> *created would be applied

[17:31] <pmichaud> I can give you a commit bit and you could push your branch(es) to github.  We received your CLA this week.

[17:31] <pmichaud> (yesterday, in fact)

[17:31] <Kodi> Ah. Aha! Very timely.

[17:31] <Kodi> Hmm.

[17:31] <pmichaud> anyone else think Kodi++ should have a commitbit?  ;-)

[17:31] <moritz_> +1

[17:32] <PerlJam>  +2 :)

[17:32] <pmichaud> anyway, it's a big enough change that I'd definitely do it in a branch, and we'll merge it if it looks clean enough.

[17:32] <pmichaud> there's a chance it will get very messy and force changes throughout the codebase... in which case we need to re-evaluate.

[17:33] <pmichaud> (especially since it can impact lists, and flattening, and iterators, and ....)

[17:33] <pmichaud> Kodi: github id?

[17:33] <Kodi> pmichaud: KodiB

[17:33] <pmichaud> Kodi: you now have a commitbit

[17:34] <Kodi> Awesome.

[17:34] <pmichaud> feel free to apply whatever Instant/Duration patches you have -- you're well-proven in that area already

[17:34] <Kodi> Sounds good.

[17:34] <pmichaud> set up a branch for switching scalar assignment and I'll take a look

[17:34] <pmichaud> meanwhile I can work on the hash refactor

[17:36] <Kodi> Is there anything more you can tell me about ObjectRef? Is the idea that it's supposed to serve as a generic reference type in place of Perl6Scalar?

[17:36] *** gottreu left
[17:36] <flussence> whee, test thing finished properly this time

[17:36] <Kodi> Also, why do we have Perl6Scalar instead of the specced Scalar? Different things?

[17:37] <pmichaud> Parrot already has a 'Scalar' PMC type.

[17:37] <PerlJam> flussence: mine locked up my computer for some reason

[17:37] <Kodi> Oh.

[17:37] <pmichaud> whenever we end up with conflicts like that (and they're much rarer now), we prefix with "Perl6" to disambiguate.

[17:38] <pmichaud> (and then we have a way of mapping in the compiler/runtime so that a p6 programmer sees/uses "Scalar")

[17:38] <shortcircuit> What's with the ! following each sigil in http://rosettacode.org/wiki/Execute_Brain****/Perl_6 ?

[17:38] <Kodi> shortcircuit: That's the "private variable" twigil.

[17:38] <pmichaud> shortcircuit: private attributes of instances of the class

[17:38] <PerlJam> shortcircuit: private object attrs

[17:39] <Kodi> shortcircuit: Fancy meeting you here. :)

[17:39] * PerlJam notes that the "sauce" on his pork chops is like 90% olive oil

[17:39] <shortcircuit> Kodi: Heh. Hi. :)

[17:40] *** gottreu joined
[17:41] *** Ross^ left
[17:42] *** patrickas joined
[17:43] <patrickas> good evening ladies , gents and butterflies

[17:46] <masak> good evning, dear sir.

[17:48] <patrickas> masak++ ( There must be something you did worthy of karma since I last spoke to you :-p )

[17:48] <pmichaud> masak++ filed more bug reports.

[17:48] <pmichaud> (That's pretty much a given, I suspect.)

[17:48] <masak> there have been many in the past few days.

[17:48] <pmichaud> I've been working on fixing some of them, too.  :)

[17:49] <masak> pmichaud++ \o/

[17:49] <pmichaud> rakudo:  my $x;  $x ?&= 5;  say $x

[17:49] <p6eval> rakudo 705379: OUTPUT«1␤»

[17:49] <patrickas> for every pmichaud++ we get a bug--

[17:50] <pmichaud> I just filed TT #1793 for the character encoding bug (RT #77888)

[17:51] <moritz_> did anybody file a bug report for the Unicode breakage with latest parrot?

[17:51] <pmichaud> no, but I have a recent spectest

[17:51] <pmichaud> I want to fix the short-circuit failure first, since it's somewhat known/unrelated.

[17:51] <pmichaud> I'll do that right after lunch.

[17:52] <pmichaud> which is now.

[17:52] <pmichaud> bbl

[17:52] <gottreu> May I ask what happened with the pugs svn repo and the plusthree smolder server?

[17:53] <moritz_> no idea about plushtree; seems its maintainer disappeared

[17:53] <moritz_> the pugs repo had to be shut down due to neglected maintenance

[17:54] <moritz_> so we moved it to git, split it up and moved it to github

[17:54] <gottreu> but it was shut down sooner than preferred, no?

[17:54] <moritz_> correct

[17:55] <gottreu> neglected maintenance mean lack of security patches?  and had to take it down because it was a dangerous infected zombie?

[17:56] <moritz_> it means nobody bothered to run 'apt-get update' on the server, responded to high load due to bot spidering the svn web interface etc.

[17:56] * flussence repeats spectest, this time on non-glacial hardware

[17:56] <gottreu> ah...well at least it wasn't trying to eat brains.

[17:58] <flussence> I'd considered trying to install linux on my Wii (ppc) to run this, but I wouldn't get very far on ~80MB of RAM :(

[17:58] <flussence> plus it'd probably catch fire

[18:05] *** amkrankruleuen joined
[18:05] <amkrankruleuen> Hello

[18:06] *** nymacro left
[18:06] *** jedai joined
[18:10] * shortcircuit wonders if anyone wants to take a crack at http://rosettacode.org/wiki/RCRPG/Perl

[18:11] <shortcircuit> That version was something I wrote on a whim while home sick one weekend. I was feeling nostalgic for old BBS games.

[18:13] *** mberends joined
[18:20] <masak> nom &

[18:20] *** masak left
[18:20] *** am0c left
[18:34] *** aesop left
[18:34] *** jaldhar left
[18:36] *** jaldhar joined
[18:37] *** jaldhar left
[18:39] <sorear> good * #perl6

[18:39] <patrickas> o/ sorear

[18:40] *** jaldhar joined
[18:42] <patrickas> since the move of pugs to github make spectest and now make spectest_smolder are giving me errors on win32

[18:43] <patrickas> anyone else seing that ?

[18:45] <sorear> it would help to know which errors you are experiencing

[18:45] *** Italian_Plumber left
[18:47] <gottreu> spectest_smolder still references plusthree, so that should give errors on all platforms

[18:48] <patrickas> the slashes in git command were backwards so I fixed them and the args to curl command don't seem to work, I am just not sure if these are local errors because of something I previously did or something happening with all win32 users and needs correcting in rakudo 

[18:48] *** Italian_Plumber joined
[18:49] <gottreu> what type of win32 environment does rakudo work in?  cygwin?  mingw?  using microsoft tools?

[18:50] *** wamba left
[18:51] <jnthn> Use the MS tools for sure, and I believe MinGW too

[18:51] <jnthn> And perhaps also Cygwin.

[18:52] *** icwiener_ left
[18:52] <gottreu> I have a vbox image with Cygwin, so I'll try that.

[18:54] *** dual joined
[18:55] <PerlJam> my two attempts at make spectest_smolder today have both gotten to t/spec/S03-metaops/reverse.t and just hung.

[18:56] *** Holy_Cow left
[18:56] *** jaldhar left
[18:56] *** Italian_Plumber left
[18:56] *** jaldhar joined
[18:58] <sorear> wow

[18:58] <sorear> p6l was actually useful for once

[18:59] *** timbunce left
[19:00] <flussence> PerlJam: is your system low on RAM at all? reverse.t peaks at 480MB for me, dunno if it's significant

[19:01] <PerlJam> flussence: not at all.  I've got 4 G of ram with about 1.2 G free.

[19:02] *** patrickas left
[19:02] <PerlJam> the first time it got stuck at 15/33, the second 7/33 and just now it's at 23/33 and holding.

[19:03] <flussence> ack, the worst kind of bug...

[19:03] <flussence> does running just the one test on its own work?

[19:04] <PerlJam> dunno yet, I'm about to try it though.

[19:05] *** timbunce joined
[19:07] *** shade\ left
[19:08] <PerlJam> prove --verbose --exec ./perl6 t/spec/S03-metaops/reverse.t  # zips through the tests no problem until the last.  It never outputs anything after "ok 32 - Rop gets the precedence of op"

[19:10] <PerlJam> rakudo:  say ~(10 R... 1, 3)

[19:10] <p6eval> rakudo 705379: OUTPUT«(timeout)»

[19:10] <PerlJam> rakudo: say ~(1,3 ... 10)

[19:11] <p6eval> rakudo 705379: OUTPUT«(timeout)»

[19:11] <PerlJam> well, that would explain it :)

[19:11] *** HarryS joined
[19:11] *** florz left
[19:12] <PerlJam> rakudo: * > 10 R...^ 1,3

[19:12] <p6eval> rakudo 705379:  ( no output )

[19:12] <PerlJam> rakudo: say ~(* > 10 R...^ 1,3)

[19:13] <p6eval> rakudo 705379: OUTPUT«1 3 5 7 9␤»

[19:13] <PerlJam> at least that works.

[19:15] *** shade\ joined
[19:16] <PerlJam> strange.

[19:16] *** HarryS left
[19:17] <PerlJam> rakudo: say ~(0,2 ... 10)

[19:17] <p6eval> rakudo 705379: OUTPUT«0 2 4 6 8 10␤»

[19:17] <PerlJam> rakudo: say ~(1,3 ... 10)

[19:17] <p6eval> rakudo 705379: OUTPUT«(timeout)»

[19:17] <PerlJam> oh!  no, it's not strange.

[19:17] *** florz joined
[19:19] <PerlJam> the accidental infinite list is going to surprise other people than just me  :)

[19:20] <tadzik> couldn't it be the old way? :\

[19:20] <tadzik> rakudo: say ~(1,3 ... * >= 10)

[19:20] <p6eval> rakudo 705379: OUTPUT«1 3 5 7 9 11␤»

[19:21] <tadzik> rakudo: say ~(1,3 ... ^ * >= 10)

[19:21] <p6eval> rakudo 705379: OUTPUT«Can't take numeric value for object of type Whatever␤  in 'Any::Numeric' at line 1367:CORE.setting␤  in 'prefix:<^>' at line 7084:CORE.setting␤  in main program body at line 22:/tmp/3nORv9PH4l␤»

[19:21] <tadzik> ETOOMUCHTYPING

[19:23] *** Kodi left
[19:26] <PerlJam> tadzik: alternatively, we could outlaw the 1 ... 10 form and instead require 1 ... * == 10

[19:27] <PerlJam> (yes, I know, more typing.  I'm just looking for some consistency that isn't likely to trip someone up)

[19:28] <PerlJam> that would also draw a clearer distinction between .. and ...

[19:29] <tadzik> what was the rationale for changing the specs?

[19:30] <PerlJam> and if *that* were the case, it might seem a little more natural to use the trailing closure to be a test for inclusion rather than termination of the series

[19:30] <tadzik> hmm, not bad

[19:31] <tadzik> rakudo: say ~(1, 3, * + 2)

[19:31] <p6eval> rakudo 705379: OUTPUT«1 3 _block126␤»

[19:31] <tadzik> rakudo: say ~(1, 3, * + 2)[^10]

[19:31] <p6eval> rakudo 705379: OUTPUT«1 3 _block126 Any() Any() Any() Any() Any() Any() Any()␤»

[19:31] <tadzik> bleh

[19:31] <tadzik> rakudo: say ~(1, 3, * + 2 ... * > 15)

[19:31] <p6eval> rakudo 705379: OUTPUT«1 3 5 7 9 11 13 15 17␤»

[19:33] *** timbunce left
[19:33] <PerlJam> rakudo: say ~(1, 3, * + 2 ...^ * > 15)

[19:33] <PerlJam> rakudo: say ~(1, 3, * + 2 ...^ * >= 15)

[19:34] <p6eval> rakudo 705379: OUTPUT«1 3 5 7 9 11 13 15␤»

[19:34] <p6eval> rakudo 705379: OUTPUT«1 3 5 7 9 11 13␤»

[19:35] <PerlJam> it seems weird to add characters to the series to shorten the resultant list

[19:38] <pmichaud> 19:29 <tadzik> what was the rationale for changing the specs?

[19:38] <pmichaud> the previous spec had too many special-cases to be clean (or cleanly implemented)

[19:40] <sorear> hello pmichaud

[19:40] <pmichaud> afk, kid pickup

[19:45] *** rindolf left
[19:56] <dalek> rakudo: 760c734 | pmichaud++ | src/cheats/process.pm:

[19:56] <dalek> rakudo: Set default filehandles to unicode encoding.  Resolves RT #77888.

[19:56] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/760c73453bdcdd42a35380b927242414be8554a3

[19:58] <pmichaud> back again

[19:59] *** Holy_Cow joined
[20:01] <sorear> pmichaud: I am thinking that the big thing I need to bait people into a #cpan6sketch meeting is a concrete agenda

[20:02] <TimToady> DON'T PANIC!!!

[20:02] <TimToady> (spec change coming)

[20:03] <TimToady> (mostly terminology)

[20:04] <PerlJam> sorear: working code and questions about the approach might help too.

[20:06] <dalek> specs: b962f00 | TimToady++ | S (5 files):

[20:06] <dalek> specs: refine tree contexts; slice context -> lol context

[20:06] <dalek> specs: 

[20:06] <dalek> specs: The old term "slice context" was too overloaded and imprecise;

[20:06] <dalek> specs: we will now talk about slicing only when discussing multi-argument

[20:06] <dalek> specs: subscript operations.  Various confused levels of treeness may now be

[20:06] <dalek> specs: distinguished with the .tree method, and the list-of-lists type that

[20:06] <dalek> specs: used to be "Slicel" is now "LoL".  The old "slice" contextualizer

[20:06] <dalek> specs: is now "lol", and is more or less equivalent to .tree(*.list).LoL,

[20:06] <dalek> specs: that is do 1 level of tree mapping to list.

[20:06] <dalek> specs: 

[20:06] <dalek> specs: Note these are now lists of List, not of Seq.  That's the only

[20:06] <dalek> specs: substantive change (along with the .tree method).  Almost everything

[20:06] <dalek> specs: else is just refining the terminology.

[20:06] <dalek> specs: review: http://github.com/perl6/specs/commit/b962f00fdcc6e10ad220e50f5ff38545b578cce1

[20:08] *** Ross^ joined
[20:10] <tadzik> so full of lol

[20:10] <PerlJam> TimToady: "refine tree contexts"?  I think the only place they are mentioned is in the edit you just made.

[20:10] *** Eevee left
[20:11] *** Eevee joined
[20:11] *** HarryS joined
[20:11] <TimToady> slice was a kind of tree context

[20:11] <PerlJam> a very narrow tree I guess

[20:12] *** cotto joined
[20:12] *** araujo joined
[20:13] <sorear> Yay.  Maybe now I'll understand the spec well enough to implement it.

[20:13] <TimToady> Fat and Slim

[20:15] <PerlJam> slim jim.

[20:15] <PerlJam> slim tim

[20:15] <PerlJam> toad and tim

[20:16] *** HarryS left
[20:17] <sorear> Why were pick and roll split?

[20:17] <dalek> roast: fd2da7e | pmichaud++ | S03-operators/short-circuit.t:

[20:17] <dalek> roast: Fudge a failing test in short-circuit.t exposed by Parrot Boolean/Integer changes.

[20:17] <dalek> roast: review: http://github.com/perl6/roast/commit/fd2da7e0564f12acc2ada63f0053bbcb1126288b

[20:17] <sorear> What does S32/Containers:232 mean by "normal semantics of returning a Parcel"?

[20:17] <pmichaud> sorear: because .pick(:replace) was too long and they're really two different algorithms underneath.

[20:18] <TimToady> if you say return 1,2,3 it's a Parcel

[20:19] <PerlJam> Is .flat a specialization of .tree effectively?

[20:19] <TimToady> thought about it, but I don't think so

[20:19] <TimToady> it would be confusing in any case

[20:20] <TimToady> but the list of closures supplied to .tree start at level 1, so I'm not sure prefix:<|> can work there

[20:20] <TimToady> I think | is kinda macro-y

[20:21] *** tadzik left
[20:22] <PerlJam> can I ignore (as in "don't touch") items at level N, but start recursing at level M > N  ?

[20:22] <PerlJam> can I turn off recursion?

[20:23] <sorear> How does foo(1,2; 3,4) differ from foo((1,2), (3,4))?

[20:23] <TimToady> you can always supply an identity function at level N

[20:24] <TimToady> the lattern isn't necessarily cast to LoL

[20:24] <TimToady> *latter

[20:24] <sorear> What kind of thing is a LoL?

[20:25] <TimToady> a list of list, in structure

[20:25] <sorear> How does a LoL fit into a capture?

[20:25] <sorear> Is it an item?

[20:25] <TimToady> well a parcel of list, maybe

[20:25] <TimToady> would be nice to have a simple nominal type match for multi-dim subscripts

[20:26] * diakopter 's brain bubbles over

[20:26] *** Guest23195 left
[20:26] <TimToady> I think the new formulation is better, but certainly not perfect

[20:26] <PerlJam> diakopter: That's #perl6 for you ... language design in the raw.

[20:27] <PerlJam> TimToady: aye, I'll agree that it's better.  When the implications sink in, we'll see how good it is  :)

[20:28] *** Ross^ left
[20:28] <pmichaud> s/implications/implementations/  :-)

[20:28] <PerlJam> those too

[20:28] <PerlJam> :-)

[20:28] <PerlJam> we get our implications from the implementation primarily anyway

[20:29] <PerlJam> s/implementation/implementations/

[20:29] <sorear> TimToady: What happens if I put a LoL in a Parcel?

[20:30] *** Ross joined
[20:30] *** Ross left
[20:30] *** Ross joined
[20:30] <slavik> sorear: you'll get one confused UPS delivery man. :)

[20:31] <sorear> so (1,(2,3),4) turns into something like (parcel item,list,item 1 (parcel item,item 2 3) 4)

[20:32] <sorear> what does the Parcel passed into foo(1,2; 3,4) look like?

[20:32] <diakopter> TimToady .picked a LoL of slicel'd Parcels

[20:33] <TimToady> Capture(LoL((1,2),(3,4))) or some such

[20:34] <gottreu> are Arrays never flattened?

[20:34] <TimToady> depends entirely on how they're interpolated

[20:35] <pmichaud> gottreu: flattening isn't entirely a feature of the type -- it's a feature of whatever container is being used

[20:35] <TimToady> @array flattens, $array doesn't

[20:35] <sorear> TimToady: so you're saying that the immediate child of a Capture isn't always a Parcel?

[20:35] <TimToady> never has been

[20:36] <TimToady> A Capture is just a Parcel sorted into positionals and nameds

[20:36] <TimToady> the positionals could be anything

[20:36] <sorear> a LoL occupies how many positional slots?

[20:39] *** muixirt left
[20:39] <TimToady> I think pmichaud++ would prefer it to occupy one

[20:40] <TimToady> not sure how this interacts with ** paramaters though

[20:42] <pmichaud> yes, I was just thinking about that.

[20:42] <sorear> pmichaud thinks that parcels don't contain named arguments

[20:42] <pmichaud> ...he does?

[20:43] * pmichaud wonders if he really thinks that or not.

[20:43] <jnthn> ;-)

[20:43] <gottreu> pmichaud thinks that boxes don't contain named programmers

[20:43] <sorear> I thought I asked and you prefered Rakudo's interpretation over the spec?  oh well

[20:43] <pmichaud> I've been somewhat thinking that ** knows how to unpack a LoL (formerly Slicel) argument.

[20:43] *** araujo left
[20:44] <pmichaud> so in that case,   the LoL would act like a single positional.   But I'm not entirely certain about that.

[20:44] <sorear> sub foo(**@x) { say @x.perl }; foo(1, $moo);  # does it matter if $moo ~~ LoL ?

[20:45] <pmichaud> in that case I'd think no.  I'd think that @x would end up with a single List element

[20:45] <sorear> what about foo($moo)?

[20:45] <pmichaud> same think, since $moo is scalar it shouldn't unpack/flatten.

[20:45] <pmichaud> *thing

[20:46] <sorear> so Slicel, like List, has a scalar/list allomorphism?

[20:46] <sorear> *LoL

[20:46] <pmichaud> just like   sub xyz(*@x) { ... };   xyz($moo)   doesn't try to bind @x to $moo

[20:47] <sorear> is LoL ~~ Positional?  If so, what about my @foo := LoL.new(...); (**@x) := \(@foo) ?

[20:49] <pmichaud> that one is definitely trickier.  In that case I'd think that @x unpacks.... but I'd have to think about that a lot more.

[20:51] <gottreu> what the flattenicity of AoA?  Arrays of arrays?

[20:51] <pmichaud> I tend to think of an Array as being a list of Scalars..... and as such its elements don't unpack without help

[20:52] <TimToady> nothing built-in flattens arrays recursively

[20:52] <pmichaud> where's a steamroller when you need it?  ;-)

[20:52] <pmichaud> $steam.roll;    # er.....

[20:54] <TimToady> .flat(Positional) maybe

[20:54] <TimToady> where .flat defaults to .flat(Parcel)

[20:54] *** cjk101010 left
[20:54] <TimToady> that is, it'd be a smartmatcher that says whether to interpolate the item

[20:55] <TimToady> .flat(*) would probably work too

[20:55] <TimToady> unless we also want to distinguish levels there

[20:55] <TimToady> .flat(*,*,*)  # flatten three levels

[20:56] <PerlJam> flattening 27 levels would be a bit of a pain

[20:56] <TimToady> not at all

[20:56] <TimToady> .flat(* xx 27)

[20:57] <pmichaud> assuming flat expects a **@lol   argument :-)

[20:57] <TimToady> the pain will come when someone wants .tree to do pattern matching as well as coercion

[20:57] <PerlJam> Hmm.  I just realized that I had Whatever partioned into two different things in my head.

[20:57] <PerlJam> (when, in reality, they are, of course, the same thing)

[20:57] <pmichaud> oh, I suppose .flat could just be a plain slurpy array

[20:57] <TimToady> that's how I was thinking of it

[20:58] <PerlJam> TimToady: If you could combine .tree with the existing pattern matching facilities somehow, that would be great.  :)

[20:59] *** colomon joined
[20:59] <TimToady> at some point its better to write out your own multis to visit your tree

[21:01] <TimToady> then it doesn't have to be HOP

[21:02] <TimToady> in fact, lol is unlikely to actually be implemented in terms of .tree

[21:02] <sorear> niecza's actual implementation of flat:  sub flat(*@x) { @x }

[21:05] <gottreu> what is niecza exactly?

[21:05] * colomon likes walking in on a conversation that involves HOP

[21:09] <sorear> gottreu: my implementation of Perl 6

[21:10] <TimToady> now if only we knew what Perl 6 was exactly...

[21:10] <sorear> exactly!

[21:11] *** HarryS joined
[21:11] <TimToady> maybe you should hire someone smarter to do this...

[21:11] <TimToady> oh wait, then we'd end up with Haskell

[21:13] <flussence> the thing with most languages is that you need to be at least as smart as the language designers to use them effectively...

[21:14] <sorear> the only way to really become proficient in a language is to implement it

[21:14] <gottreu> rakudo: say (1,(2,3),4).reverse.perl

[21:14] <p6eval> rakudo 760c73: OUTPUT«(4, (2, 3), 1)␤»

[21:14] <gottreu> star: say (1,(2,3),4).reverse.perl

[21:15] <p6eval> star 2010.07: OUTPUT«[4, 3, 2, 1]␤»

[21:15] <flussence> shouldn't that be 2010.08?

[21:15] <gottreu> so that explains why there's a failing test in integration....it only changed recently-ish

[21:16] <sorear> niecza now has an object serving most of the roles of a GV

[21:16] *** whiteknight joined
[21:16] *** HarryS left
[21:16] <flussence> star: say $*PERL

[21:16] <p6eval> star 2010.07: OUTPUT«name        rakudo␤version    2010.07-47-g9fd5eaa␤␤»

[21:18] <PerlJam> flussence: you generally want the language designers to be way smarter than the users of the language so that there's always new things to discover in the language.  :)

[21:19] <TimToady> I dunno, I'm no smarter than the language designer, and I keep discovering new things...

[21:19] <pmichaud> doesn't that follow PerlJam++'s statement?  ;-)

[21:20] *** supernovus joined
[21:20] <dalek> niecza: 25acd31 | sorear++ | / (4 files):

[21:20] <dalek> niecza: Implement separator form of **

[21:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/25acd314e850bc688731c9cd7e4bee959c971c07

[21:20] <dalek> niecza: 7b5ec9b | sorear++ | / (2 files):

[21:20] <dalek> niecza: New benchmark - += / containers stress test

[21:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/7b5ec9b009da470b96ffbbdeb0324476f5e39829

[21:20] <dalek> niecza: f1ef178 | sorear++ | / (6 files):

[21:20] <dalek> niecza: Make bvalue sharing explicit in stashes

[21:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/f1ef178dd7d608485a6016ac3bf59ed467d46a8a

[21:20] <dalek> niecza: e273644 | sorear++ | src/ (3 files):

[21:20] <dalek> niecza: Use explicit BValue aliasing for 'our'

[21:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e2736441a242bcad3f54bdb91baf65e525a30ef3

[21:21] <flussence> I only figured out *2 days ago* that $self->something() can work in p5 without a blessed $self... :/

[21:21] <supernovus> So, based on a weird error,  I'm guessing for @blah <-> $item { ... } isn't implemented yet (the <-> part that is) ?

[21:22] <pmichaud> rakudo: my @blah = 1..5;  for @blah <-> $item { .say }

[21:22] <p6eval> rakudo 760c73: OUTPUT«===SORRY!===␤Missing block at line 22, near ""␤»

[21:23] <pmichaud> hmmm.

[21:23] *** Ross left
[21:23] <supernovus> yeah, that's the error I got :-)

[21:23] <pmichaud> rakudo: my @blah = 1..5;  for @blah -> $item is rw { .say }

[21:23] <p6eval> rakudo 760c73: OUTPUT«Any()␤Any()␤Any()␤Any()␤Any()␤»

[21:23] <pmichaud> hmmmm

[21:23] <pmichaud> oh

[21:23] <pmichaud> rakudo: my @blah = 1..5;  for @blah -> $item is rw { $item++; $item.say }

[21:23] <p6eval> rakudo 760c73: OUTPUT«2␤3␤4␤5␤6␤»

[21:23] <pmichaud> I'm guessing <-> isn't (syntactically) implemented

[21:24] <jnthn> iirc, it had some parsing issue last time I tried it

[21:24] <jnthn> my $x = <-> $a { $a = 42 }; my $y = 69; $x($y); say $y;

[21:24] <jnthn> rakudo: my $x = <-> $a { $a = 42 }; my $y = 69; $x($y); say $y;

[21:24] <p6eval> rakudo 760c73: OUTPUT«===SORRY!===␤Confused at line 22, near "my $x = <-"␤»

[21:24] <jnthn> Ah, doesn't like it there either...

[21:24] <supernovus> I switched to using the 'is rw' form. As long as there is a way to modify the original value, I don't really care what it looks like :-)

[21:25] *** jdv79 left
[21:25] <jnthn> Maybe the protoregex fix a while back that solved various issues will have unblocked this one too, though.

[21:26] <pmichaud> it very well could have -- as well as a few other fixes

[21:26] *** patspam1 joined
[21:26] <pmichaud> I started looking at it not-too-long-ago but got sidetracked before I could finish

[21:26] *** patspam left
[21:27] * jnthn branches nqp-rx

[21:33] <supernovus> Well, glad to say that 'is rw' is working perfectly :-) My Flower will be growing at the GitHub garden soon, so all the Butterflies can enjoy the Petals.

[21:33] <gottreu> Is p6eval robust?  In that infinite loops or memory leaks won't cause any trouble?

[21:33] <diakopter> eh

[21:33] <diakopter> be careful

[21:33] <gottreu> i have been

[21:33] <flussence> it's got a timeout thing, dunno about memory.

[21:34] <gottreu> My #1 goal at my job is to just not break anything.

[21:34] <flussence> the easiest way to do that is to simply do nothing at work :D

[21:35] <pmichaud> supernovus: did you get your commit bit for ecosystem yet?  github seems to think you have one.

[21:35] <gottreu> The Machines, they like to break themselves.

[21:35] <supernovus> pmichaud: Yeah, moritz_ added me the other day.

[21:45] <gottreu> what should "(1) >>+>> ()" evaluate to?

[21:45] <flussence> I'd guess 1

[21:45] <flussence> rakudo: say (1) »+» ()

[21:45] <gottreu> ack

[21:46] <gottreu> i was about to say "btw, don't try it"

[21:46] <p6eval> rakudo 760c73: OUTPUT«(timeout)»

[21:46] <gottreu> YAY!

[21:46] <flussence> :(

[21:46] <sorear> p6eval has resource limits

[21:46] <sorear> it can't cause much problems for the server

[21:47] <gottreu> so i don't need to be careful then?

[21:47] <sorear> correct

[21:47] <sorear> the sandbox is laughably weak, you could give yourself shell access to [email@hidden.address] with minimal effort

[21:47] <sorear> but why bother

[21:48] <sorear> if you want an acct on feather just ping Juerd ;)

[21:48] <gottreu> heh

[21:49] *** amkrankruleuen left
[21:49] <flussence> rakudo: say +.^methods; say +.^methods.WHAT; # what's with the magic numbers?

[21:50] <p6eval> rakudo 760c73: OUTPUT«60␤0␤»

[21:50] <sorear> if by some miracle you DID manage to make p6eval start eating resourses, despite all the resource limits, there are about 20-30 people in #perl6 with sudo access who can push the kill button

[21:51] *** jdv79 joined
[21:51] *** tylerni7 joined
[21:52] <jnthn> flussence: You numified a list (and got the number of elemets), then a type object (which for some reason seems to numify to 0)

[21:53] <flussence> I've tried other things like .join, but everything I do there returns some number or other...

[21:54] <flussence> Oh, it's just me

[21:54] <flussence> +.^methods is +(.^methods)

[21:55] <flussence> (stupid me thinking I could call methods on operators directly)

[21:55] <jnthn> Oh, I didn't realize that's what you were trying to do. :-)

[21:55] <jnthn> rakudo: say &[+].^methods

[21:55] <p6eval> rakudo 760c73:

[21:55] <p6eval> ..OUTPUT«candidatesnamemultiassumingcandidateswrapcandounwraparitycountACCEPTSnamesignaturereturnsperldoofassumingcallwithStrnewmulticisloglog10sechrandsprintftruncatebytessqrtsinIntasincoshsignasinhabsacosechucceilingunpolarsamecasefloorsubstrasechordRatroundflipsplitmatchacosecacoshwordsN…

[21:57] <dalek> roast: 14f0e95 | KodiB++ | S02-builtin_data_types/instants-and-durations.t:

[21:57] <dalek> roast: Unfudged a test of now being a term.

[21:57] <dalek> roast: review: http://github.com/perl6/roast/commit/14f0e95cb5270cb58fe6848d4bc8e0c7a43dfb77

[21:57] <dalek> roast: a41a669 | KodiB++ | S32-temporal/DateTime-Instant-Duration.t:

[21:57] <dalek> roast: Fixed fouled-up fudge syntax.

[21:57] <dalek> roast: review: http://github.com/perl6/roast/commit/a41a669052db222d4fb07ce832e88fd3435a5522

[22:02] <dalek> roast: e0d9631 | KodiB++ | S02-builtin_data_types/instants-and-durations.t:

[22:02] <dalek> roast: [instants-and-durations.t] Use .perl so as not to require great accuracy from .Str.

[22:02] <dalek> roast: review: http://github.com/perl6/roast/commit/e0d9631300bf0a13addb5340e080cf34c176dc39

[22:06] <dalek> rakudo: aa5896d | KodiB++ | t/spectest.data:

[22:06] <dalek> rakudo: [spectest.data] Added tests for Instants and Durations.

[22:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/aa5896d2baa51df04a33ee9ea2d5137e494f13f5

[22:06] <dalek> rakudo: 529f546 | KodiB++ | src/core/ (2 files):

[22:06] <dalek> rakudo: Made Instant.Str more awesome per RT #77802.

[22:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/529f54622a067e1de4d135aee7c6b4ff9857e057

[22:06] <dalek> rakudo: 3ae665f | KodiB++ | src/core/Duration.pm:

[22:06] <dalek> rakudo: Removed &infix:<->(Real, Duration).

[22:06] <dalek> rakudo: 

[22:06] <dalek> rakudo: It competed with &infix:<->(Instant, Real).

[22:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3ae665f9919f2f459d0164c30f089129316e448a

[22:07] *** sftp left
[22:07] *** Holy_Cow left
[22:10] *** ruoso left
[22:11] *** HarryS joined
[22:11] *** mikehh left
[22:15] *** HarryS left
[22:24] *** meppl left
[22:24] *** sahadev left
[22:24] *** meppl joined
[22:34] <supernovus> Now for some dark magic. Say I have a for loop, like: for @items -> $item is rw but if $item matches a certain rule, I want to delete it from @items. Is this possible? Or do I have to change to a different kind of loop?

[22:36] *** pythonian4000 joined
[22:37] <sorear> you want to use @items = map { ... }, @items

[22:39] <colomon> or @items .= grep { ... }

[22:39] <jnthn> Or @items .= map { ... } # maybe

[22:40] <colomon> (obviously can't change $item with a grep, only delete it)

[22:41] *** Khisanth joined
[22:41] * jnthn -> sleep, EEARLYMEETING

[22:42] <supernovus> I'll look at that. This is a rather unique use-case. I'm parsing a list of elements for different rules. Most of the rules just change the element, but there are some rules like "condition" that actually remove it, and others like "repeat" that replace it with several others. This could be interesting.

[22:44] <colomon> tadzik, PerlJam: The rationale for changing the end of series like that is that the new simplification makes the series termination check a smartmatch.

[22:51] <dalek> niecza: ff40fab | sorear++ | / (2 files):

[22:51] <dalek> niecza: Restore := to macrohood

[22:51] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ff40fab5c307c39972fb317f636220c574ecf629

[22:51] <dalek> niecza: a677838 | sorear++ | / (3 files):

[22:51] <dalek> niecza: A crude bvalue escape analysis

[22:51] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a6778388f6b205b6aa7f9f4c8308d9e891d68635

[22:51] <dalek> niecza: 5205f98 | sorear++ | / (5 files):

[22:51] <dalek> niecza: Treat Variable as read-only

[22:51] <dalek> niecza: 

[22:51] <dalek> niecza: Binding is now implemented by substituting Variable pointers in the appropriate

[22:51] <dalek> niecza: places, most commonly lexpads.

[22:51] <dalek> niecza: review: http://github.com/sorear/niecza/commit/5205f98c6e6bd4f1edc5c85604139e37a8517de5

[23:07] *** cdarroch left
[23:11] *** HarryS joined
[23:13] *** supernovus left
[23:16] *** masonkramer joined
[23:16] *** HarryS left
[23:19] *** patspam1 left
[23:22] *** Italian_Plumber joined
[23:27] *** araujo joined
[23:27] *** araujo left
[23:27] *** araujo joined
[23:40] *** risou joined
[23:44] *** alester left
