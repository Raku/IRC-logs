[00:00] <masak> sorear: which Rakudo doesn't have. :/

[00:06] <jnthn> alpha: say $*CWD

[00:06] <p6eval> alpha 30e0ed: OUTPUT«/home/p6eval/rakudo-alpha␤»

[00:06] *** cono left
[00:06] <jnthn> rakudo: say $*CWD

[00:06] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[00:23] *** bjarneh left
[00:23] *** takadonet joined
[00:24] <takadonet> is anyone here going to ISMB?

[00:24] *** supernovus joined
[00:24] *** lkk- joined
[00:26] <lue> ohai

[00:26] *** tylercurtis left
[00:27] <jnthn> hellue!

[00:27] <masak> well hellue.

[00:28] <lue> if you remember my PIR error, it's really bugging me what's causing it.

[00:28] * masak has no idea which error that was

[00:28] *** supernovus left
[00:29] <lue> Method 'set_candidates' not found for invocant of class 'MultiSub'

[00:29] <lue> current instr.: '' pc 306226 (src/gen/perl6-actions.pir:20664) (CORE.setting:0)

[00:29] <lue> called from Sub 'perl6;Perl6;Compiler;main' pc 290826 (src/gen/perl6-actions.pir:15425)

[00:29] <lue> ...after adding a Q:PIR block to the := operator in the setting.

[00:30] <cognominal> ISMB?

[00:30] <takadonet> cognominal: http://www.iscb.org/ismb2010

[00:31] <lue> I was happy when the error was in a gen/ file. I was overjoyed when pmichaud told me PIR line numbers aren't always true. :)

[00:34] <jnthn> lue: What was in the Q:PIR block?

[00:34] <lue> (one of these days I ought to try compiling rakudo on my computer again)

[00:34] <jnthn> Yes, getting latest Rakudo may be advisable.

[00:34] <jnthn> It improves day by day ;-)

[00:34] <pmichaud> "It's a trap!"

[00:34] <pmichaud> oh, sorry.

[00:35] <jnthn> :P

[00:35] <lue> (just a sec, pasting)

[00:35] <jnthn> pmichaud: I kinda just discovered that writing Perl 6 modules is kinda fun. ;-)

[00:35] <pmichaud> jnthn: I'm looking forward to the same.

[00:35] <pmichaud> I already know what sekrit Perl 6 project I'm going to work on in August.  :-)

[00:35] <pmichaud> (actually I have several)

[00:36] <jnthn> pmichaud: It's odd having spent a couple of years working on Perl 6 compiler stuff, but not really having actually written much Perl 6 outside of the compiler. :-)

[00:36] <lue> erm, apparently it was an outdated copy of 楽土 that's to blame. oops. *_*

[00:36] <pmichaud> jnthn: yes, I agree.

[00:37] <jnthn> Anyway, today I pushed Test::Mock. :-)

[00:37] <jnthn> I only hit upon a closures bug when writing it. ;-)

[00:37] <jnthn> Other than that it Just Worked. \o/

[00:37] <pmichaud> heh

[00:37] <pmichaud> I'M WORKING ON IT!

[00:37] <jnthn> WORK FASTER!

[00:37] <jnthn> ;-0

[00:38] <pmichaud> IT WOULD BE FASTER IF I DIDN"T HAVE TO REFACTOR SO MUCH CODE!

[00:38] <pmichaud> :-D

[00:38] <jnthn> Sorry for writing so much of it. :-)

[00:38] <cognominal> reading S06, what is a multi-invocant?

[00:38] <jnthn> Something the multi-dispatcher cares about when sorting candidates.

[00:38] <takadonet> anyone else having trouble creating PIR files from .pm?

[00:39] <masak> pmichaud: speaking of which, when's the closures refactor going to land? :)

[00:39] * masak hides

[00:39] <pmichaud> masak: I'm hoping tonight.

[00:39] <pmichaud> Seriously.

[00:39] <masak> \o/

[00:39] <masak> Seriously.

[00:39] <takadonet> pmichaud: sweet!

[00:39] <pmichaud> I think it's actually much closer than it might sounds.

[00:39] <pmichaud> *sound

[00:39] <lue> good news, := doesn't die. Bad news, it doesn't work. :D

[00:39] <jnthn> lue: Progress!

[00:40] <lue> maybe it's the parameter definition: (Mu $a, Mu $b)

[00:40] <pmichaud> they definitely need to be parcels

[00:40] <pmichaud> otherwise the containers get stripped

[00:41] <jnthn> Mu \$a, Mu \$b

[00:41] <jnthn> It's the anti-Depeche Mode modifier

[00:41] <jnthn> "Let me see you un-stripped"

[00:42] * pmichaud tells his wife about things being stripped in Perl 6.  She was already amused by the .nude method.  :-)

[00:42] <lue> There's also the part where there is no type/rw checking yet, but I prefer not to have a giant Q:PIR block. :)

[00:42] <lue> .oO(Every language needs swearing and things kids don't need hearing.)

[00:44] *** cotto joined
[00:47] <lue> > my $a = 1; my $b := $a; $b = 99; say $a

[00:47] <lue> 99

[00:47] <lue> \o/    Now to add type-checking and the like :P

[00:49] *** tylercurtis joined
[00:49] *** dduncan joined
[00:54] <lue> perl6: my $a = 3; say $a.VAR.rw

[00:54] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[00:54] <p6eval> ..pugs: OUTPUT«*** No such method in class Int: "&rw"␤    at /tmp/WT1xmBFLKF line 1, column 16 - line 2, column 1␤»

[00:54] <p6eval> ..elf 31539: OUTPUT«Can't call method "VAR" without a package or object reference at (eval 124) line 4.␤ at ./elf_h line 5881␤»

[00:55] <lue> I can't check for rw-ness yet, can I?

[00:55] <pmichaud> you can from PIR

[00:56] <pmichaud> !pir::isnull(pir::getprop__PsP('rw', $target))

[00:56] <lue> I know. Ah well, I'll be sure to un-PIR it when I can. :)

[00:57] <lue> and if that returns 0, it's ro?

[00:59] <pmichaud> if it returns false, yes.

[00:59] <pmichaud> or 0.

[00:59] <pmichaud> (I normally just check for boolean-ness, not for a specific integer value)

[01:00] <lue> Yeah, if it's T/F I usually say 1 or 0.

[01:00] *** dduncan left
[01:01] <pmichaud> except some values of true are not 1.  :-)

[01:02] <masak> pmichaud: so, with jnthn++'s guidance I did a little experiment this evening: I added a &prefix:<?> opcall for the expression in if/elsif/unless/while/repeat. this causes `if 5 but False { say "OH NOES" } else { "as expected" }` to work as expected, but it causes things like `if "this string is true" -> $a { say $a }` to fail.

[01:02] <lue> I know, it's from ye olde days when computers could afford defining a separate Bool type :)

[01:02] <lue> [and the fact that TI-84+SE's still do that, instead of Bools...]

[01:03] * pmichaud once again types "make", somewhat less optimistically than last time.

[01:03] <masak> pmichaud: so the good news is that it broke really few test files. but in retrospect, it's probably not the right approach. right now it feels like there needs to be a way to boolify the expression and leave it unchanged at the same time.

[01:04] <pmichaud> it's not the right approach.

[01:04] <pmichaud> &prefix:<?> should always return True/False, while testing for boolean should allow other values.

[01:04] <masak> right.

[01:05] <pmichaud> we need to get the get_boolean vtable to understand the but-ness

[01:05] <masak> ah.

[01:05] <pmichaud> because that's what is used to test boolean-ness in an if statement.

[01:05] <pmichaud> (and other boolean contexts)

[01:06] *** meppl joined
[01:07] <jnthn> So prefix:<?> needs to call .Bool?

[01:07] <pmichaud> I think it already does that.

[01:07] <pmichaud> get_bool needs to call .Bool

[01:07] <jnthn> Oh!

[01:07] <jnthn> I see

[01:08] <pmichaud> the opcode that gets generated is

[01:08] <pmichaud>     if $P0 label

[01:08] <jnthn> aha

[01:08] <pmichaud> which uses the get_bool vtable

[01:08] <pmichaud> if you change that to

[01:08] <jnthn> OK, so we need a v-table override in Mu

[01:08] <pmichaud> right.

[01:08] <jnthn> k

[01:08] <jnthn> Rozumiem

[01:10] <pmichaud> that might break other stuff... but hopefully not.

[01:11] <pmichaud> should be able to follow whatever pattern exists for get_string, get_integer, etc.

[01:12] <pmichaud> hmmmm, it's already there.

[01:12] <pmichaud> rakudo:  say  (5 but False).Bool

[01:12] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[01:12] <pmichaud> rakudo:  say  (5 but False).WHAT

[01:12] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[01:15] <tylercurtis> that appears to give the right result.

[01:15] <sorear> How does signature equality work?

[01:15] <sorear> I.e. &[+]:(Num,Num)

[01:16] * sorear hopes "intensional"

[01:16] <pmichaud> we discriminate against everyone equally.  :-)

[01:16] <lue> apparently, this doesn't work:

[01:17] <lue> > my @a = 1,2,3; @a[3] := @a[0]; @a[3] = 4; say @a

[01:17] <lue> You cannot bind a variable of type Int() to a variable of type Proxy().

[01:17] <jnthn> sorear: If only it were spec'd. ;-)

[01:17] <pmichaud> shouldn't be any typing there at all, I think.

[01:18] <jnthn> No, there shouldn't.

[01:18] <jnthn> That shoudl work.

[01:18] <lue> It works if I change @a[3] to @a[2].

[01:18] <pmichaud> I suspect some over-eager type checking.

[01:18] <pmichaud> oh

[01:18] <pmichaud> that's actually a not good example to try right now.

[01:19] <pmichaud> does it work if you rebind an element that exists?

[01:19] <pmichaud> as opposed to something that will give you a proxy?

[01:19] <lue> > my @a = 1,2,3; @a[2] := @a[0]; @a[2] = 4; say @a.perl

[01:19] <lue> [4, 2, 4]

[01:19] <pmichaud> Proxy is going away.

[01:19] <pmichaud> as soon as I get autoviv updates installed

[01:19] <pmichaud> which is currently blocking on closures

[01:20] <lue> I just need to unfudge the appropriate tests (all of which I hope to be in t/spec/S03-operators) and make sure nothing special happens.

[01:23] *** wmiksss1 left
[01:26] <pmichaud> jnthn: initial testing with new code looks pretty good.  A lot of my previous failz have gone.

[01:26] <pmichaud> as in, a *lot*

[01:26] <pmichaud> time for dog walk

[01:26] <pmichaud> bbiaw

[01:26] <jnthn> Awesome :-)

[01:27] <jnthn> rakudo: say \(1) eqv \(1)

[01:27] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[01:27] <jnthn> oh schiese es ist kaput

[01:29] <masak> loliblogged! http://use.perl.org/~masak/journal/40434

[01:29] <lue> Nein! Das kanst du nich sagen! (excuse my spelling, It's been a while :) )

[01:30] <jnthn> Excuse mein too ;-)

[01:33] * lue wonders what language the arguments will be in the pls module installer

[01:33] <sorear> I hope English will be an option

[01:34] <lue> [ pls update all    or    pls updayt all   :) ]

[01:34] *** ashleydev left
[01:34] <masak> it'll be 'update' :)

[01:35] <jnthn> pls canhaz web kthnxbai

[01:35] *** masak left
[01:35] <lue> time for someone to start coding the lolspeak language pack then :)

[01:36] *** redicaps joined
[01:36] *** redicaps left
[01:37] <lue> .oO(pls --am-in-ur="/dev" --updaytin-ur=$PERL6_MODULES)

[01:42] <pugssvn> r31540 | jnthn++ | After persuasion from masak++, I add a VICTUALS entry. 

[01:44] <jnthn> sleeptime o/

[01:44] <lue> goodnight

[01:50] *** eternaleye joined
[01:51] *** eternaleye_ left
[01:58] *** meppl left
[02:05] *** hercynium joined
[02:11] *** plobsing left
[02:20] *** orafu joined
[02:21] <sorear> What was the rationale, again, for changing infix:('+') to infix:['+']?

[02:27] <diakopter> to standardize signature

[02:27] <diakopter> I think

[02:30] *** tylerni8 joined
[02:31] *** tylerni8 is now known as tylerni7

[02:31] *** tylerni7 left
[02:31] *** tylerni7 joined
[02:39] <lue> afk

[02:41] *** tylerni7 left
[02:45] *** supernovus joined
[02:46] <supernovus> Well, finally learned how to use 'git rebase'. A patch for the Temporal/Date changes is coming up once the relevant spectests passes 100%

[02:51] *** supernovus left
[02:54] *** tylerni7 joined
[02:54] *** tylerni7 left
[02:54] *** tylerni7 joined
[03:06] *** supernovus joined
[03:08] <supernovus> Well, my Temporal patch has been submitted. I have updated spectests to go along with it, but I don't think I should commit those until the patch has been applied as it would break a few tests in the DateTime.t

[03:17] *** supernovus left
[03:18] <tylercurtis> Is evalbot still broken for rakudo?

[03:18] <tylercurtis> rakudo: say 5;

[03:18] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[03:24] <tylercurtis> Can someone take a look at http://nopaste.snit.ch/21796?hl=on&submit=Format+it! and tell me why it's only matching the "a"?

[03:31] *** TiMBuS joined
[03:32] *** azert0x left
[03:41] <sorear> because it's in a rule

[03:41] <sorear> in a rule, the ' ' after <alpha> eats whitespace

[03:42] <sorear> this includes the \n

[03:42] <sorear> since rules don't backtrack, there's no \n available to act as a separator

[03:45] <tylercurtis> That's what I get for simplifying my example...

[03:52] <tylercurtis> sorear: but you managed to answer my question without even seeing anything close to the actual code. Thanks!

[03:57] *** takadonet left
[03:59] *** lestrrat is now known as lest_away

[04:01] *** lest_away is now known as lestrrat

[04:03] *** lestrrat is now known as lest_away

[04:10] *** rv2733 joined
[04:17] *** ashleydev joined
[04:54] *** alexbobP joined
[04:56] *** plobsing joined
[05:02] * tylercurtis has his super-secret project at the point where it works for a very generous definition of "works".

[05:04] *** envi^home joined
[05:04] <sorear> my super-secret spying skills have found paperwork indicating that you are working on a "PAST Optimization Framewok for Parrot"

[05:04] <sorear> for monkey even!!!

[05:05] <sorear> (wow, nice typo)

[05:07] <tylercurtis> That's my not at all secret project.

[05:10] *** Transformer joined
[05:11] *** Transformer left
[05:23] *** tedv left
[05:29] <sorear> I am thinking that Str.comb, Str.split, and Str.trans are all special cases of a yet-to-be-specced Str.nibble

[05:38] *** clintongormley left
[05:45] *** envi^home left
[05:48] *** envi^home joined
[06:00] *** ash_ joined
[06:36] *** ashleydev left
[06:39] *** ash_ left
[07:18] *** lkk- left
[07:26] *** masak joined
[07:26] <masak> lol awake

[07:35] *** plobsing left
[07:36] <cxreg> sorear: is there a Str.fry yet?

[07:36] *** eternaleye left
[07:39] <tylercurtis> masak: my super-secret project is almost ready to be put on Github(as soon as I decide on a license).

[07:39] <masak> tylercurtis: exciting times.

[07:43] <tylercurtis> Artistic License seems like the obvious one for a Perl project, but the part that reads "provided that you clearly document how it differs from the Standard Version, including, but not limited to, documenting any non-standard features, executables, or modules,"  regarding distributing modified versions makes me a little hesitant.

[07:45] <masak> why?

[07:48] *** Ross joined
[07:50] <tylercurtis> Because I'm not sure what qualifies as "clearly document"ing it. Is the set of diffs and commit history provided by a git repo sufficient? Or does it need to be explicitly written out?(if the latter, that could make forking for minor fixes on github less convenient, especially since if you merge the fork, you wouldn't want to include a file that says "This differs from the standard version of project Foo in the following ways:").

[07:52] <masak> I'm pretty sure that section was written without Github in mind.

[07:53] <masak> you could go with a dual BSD/D&R license. :P http://github.com/indeyets/syck/blob/master/COPYING

[07:59] <tylercurtis> heh. I'm either going to go with the Artistic License or GPL with LGPL for the bits for which that feels appropriate(or just GPL with extra permissions as feels appropriate), I think.

[08:12] <tylercurtis> masak: http://github.com/ekiru/Bennu behold.

[08:13] * masak beholds

[08:13] <masak> whoa.

[08:14] <masak> heh -- a SIC grammar :P

[08:15] <tylercurtis> It doesn't do anything with the environment from the SIC yet(mostly because I was focusing on the SIC output of "say 42;" initially and that didn't require that.

[08:16] <masak> it looks way cool. tylercurtis++

[08:21] <tylercurtis> I'm now tempted to comment on Moritz's old blog post about fake-cutables that you can now have a real executable if you're willing to restrict yourself to a very small subset of Perl 6.

[08:21] <masak> :)

[08:22] * tylercurtis just glanced at Yapsi and noticed that it also doesn't support negative numbers yet.

[08:22] * tylercurtis is glad he doesn't have to add that yet.

[08:22] <masak> well, it doesn't support negative literals. :)

[08:22] <masak> it does support negative numbers.

[08:22] <tylercurtis> True.

[08:23] <masak> I'm thinking I now should provide a delta of SIC changes each month in a file, so that the downstream consumers of it don't go mad from unannounced changes.

[08:26] <tylercurtis> That would be helpful. But it's not something that would be particularly painful to not have(unless you start working on Yapsi much much more often than you seem to so far).

[08:26] <masak> :)

[08:27] <masak> I seem to work in monthly bursts so far.

[08:27] <masak> but I'd recomment targeting monthly releases anyway.

[08:31] <pmichaud> I appear to be down to three failing test files.

[08:32] <masak> \o/

[08:34] *** cuppe_ left
[08:34] *** cuppe left
[08:35] <pmichaud> actually, down to five failing tests.

[08:35] <pmichaud> ...and one I'm willing to regress on.

[08:43] <sorear> If you're willing to restrict your self to a different tiny subset of Perl 6, and can tolerate the completely insane build system, you can also use Niecza to generate "native" executables

[08:43] <sorear> * You get a .exe which is double-clickable on Win7; Users of other OSen will need an interpreter

[08:44] <tylercurtis> sorear: my build system isn't sane either.

[08:46] <sorear> luckily, I have a GSoC student working to improve my build system.

[08:49] <masak> pmichaud: what counts as a closure when it comes to the closure-cloning bug? the test I had to regress on for App::Pls didn't involve any actual Block objects, only the blocks associated with for/given/when/if constructs.

[08:49] * tylercurtis is a GSoC student, but isn't working to improve his own build system yet.

[08:49] <pmichaud> masak: hmmmm.  I wouldn't expect those to have closure issues.

[08:50] <pmichaud> do you have a somewhat golfed example?

[08:50] <masak> pmichaud: I could try and produce one.

[08:52] *** pmurias joined
[08:53] <sorear> phenny: ask TimToady what's the motivation separating sublongname and longname?

[08:53] <phenny> sorear: I'll pass that on when TimToady is around.

[08:53] <pmurias> sorear: am i the GSoC student who is supposed to be improving your build system?

[08:53] <sorear> masak: the blocks in a for are real Block objects

[08:54] <sorear> pmurias: only insofar as I'm suffering from many of the same issues as mildew

[08:55] <pmichaud> sorear: they aren't quite yet real Block closures in Rakudo.  (they will be very soon, t hough.)

[08:55] <sorear> pmichaud: what are they then?  raw parrot Subs?

[08:55] <pmichaud> fairly close to that, yes.

[08:55] *** sorear sets mode: +ooo tylercurtis masak pmurias

[08:56] <pmichaud> they still understand rakudo's signature handling

[08:56] <pmichaud> so they're not completely Parrot-ish

[08:56] <pmurias> sorear: did the Perl6:: prefix get approval?

[08:58] *** pmurias left
[08:58] *** pmurias joined
[08:58] <pmichaud> afk, sleep

[08:58] * pmurias looks at niecza

[09:00] <sorear> pmurias: it's still in the phenny queue, afaik

[09:00] *** sorear sets mode: +o pmurias

[09:01] <sorear> if it /does/ get approved, I'm going to add File::ShareDir support to Cursor, change make dist to spit out an actual Dist::Zilla dist, and throw the whole thing on CPAN

[09:01] <sorear> which will make both of our lives much easier

[09:01] <tylercurtis> sorear++

[09:02] *** ive joined
[09:02] <sorear> if it doesn't get approved I'll have to do something clever, which I haven't figured out yet

[09:05] <pmurias> sorear: why do you want to generate a Dist::Zilla dist?

[09:06] <sorear> because it's a good tool, I'm familiar with it, and it's designed to automatically maintain dists

[09:06] <sorear> if it screws up, I can blame rjbs

[09:07] <pmurias> what i meant shouldn't you write one and make Dist::Zilla do all the generating of files

[09:07] <sorear> the STD build system is moderately insane in its own right

[09:08] <sorear> I don't understand Dist::Zilla at this time well enough to merge them

[09:08] <sorear> also I'm not sure how I'd handle our weird targets

[09:08] * pmurias did some pretty insane things while making SMOP use Dist::Zilla

[09:09] *** orafu left
[09:09] <sorear> I'll have to look at that at some point

[09:09] <sorear> to be fair I haven't done a very good job of understanding SMOP

[09:10] * pmurias didn't look at niecza closely too

[09:11] *** orafu joined
[09:11] <sorear> niecza hasn't existed for nearly as long, and isn't huge and mysterious to me

[09:11] <sorear> (one of these is an objective fact)

[09:11] *** Trashlord left
[09:12] *** tadzik joined
[09:13] <pmurias> sorear: re Perl6:: prefix what are the disadvantages of that?

[09:14] *** Ross left
[09:14] <sorear> API naming issues mostly

[09:14] <sorear> STD is the module's canonical name as mentioned in S05

[09:14] <sorear> STD is the name programmers with a Perl 6 background expect

[09:15] <sorear> programmers with a stronger Perl 5 background, and CPAN, will expect Perl6::STD

[09:15] <pmurias> could we get away with taking STD on cpan?

[09:15] <pragma_> I like bacon.

[09:15] <pmurias> ?

[09:16] <sorear> Maaaayybe

[09:16] *** Ross joined
[09:17] <pmurias> sorear: as the Perl6:: namespace seems to contain dodgy modules trying to emulate perl6 features in perl5

[09:18] <sorear> hmm.  'Cursor' on CPAN is already taken, sort of

[09:19] <sorear> there are a few modules on CPAN that horribly violate naming procedures

[09:19] <Juerd> sorear: There's hardly anything such as a naming procedure

[09:20] <Juerd> The few guidelines were rendered worthless a long time ago. If it was important, "they" should have enforced it.

[09:21] *** Ross left
[09:21] <sorear> There's no enforcement that .tar.gz files should have relative paths, but everybody does it

[09:21] <Juerd> In part because tar strips leading slashes b y default :)

[09:22] <Juerd> And "everybody does it" usually doesn't apply on CPAN, where everyone does something else :)

[09:22] <sorear> 99% of CPAN dists use long, descriptive, hierarchal module names like Parse::RecDescent

[09:23] <sorear> releasing modules with names like Parse seems to be treated as bad form

[09:23] *** Ross joined
[09:23] <masak> aye.

[09:23] <masak> that was one of the criticisms against the module name Web

[09:23] <sorear> maybe I should go ask the #toolchain people for advice

[09:25] <Juerd> masak: I intended Web as a new root namespace, as CGI and HTTP are often very inappropriate

[09:25] <masak> aye.

[09:25] * sorear contemplates "accepted" root namespaces

[09:25] <sorear> DBI comes to mind

[09:26] <Juerd> Big frameworks, in general.

[09:26] <sorear> it's a not-descriptive name for something that has multiple valid conceptions

[09:26] <Juerd> And anything with a non-generic name

[09:26] <Juerd> sorear: But who'd put diseases on cpan? :)

[09:27] <pmurias> Juerd: i plan to put mildew on cpan ;)

[09:28] *** sawyer_ left
[09:28] <sorear> I'm definitely going to move CursorBase, DEBUG, LazyMap, RE_* to Cursor::* and NAME, Stash, Actions to STD::*

[09:28] <sorear> using 30 root namespaces is unacceptable

[09:29] <sorear> Cursor is my biggest concern here...

[09:30] <sorear> it's non-descriptive, it's short, it's ambiguous

[09:30] <sorear> Perl6::Cursor conveys the proper meaning - a Perl 5 implementation of the Perl 6 grammar engine

[09:31] <jnthn> morning o/

[09:31] <pmurias> sorear: does using Cursor make sense outside STD?

[09:32] <sorear> pmurias: yes

[09:33] <sorear> there are still quite a few things in Cursor that really only make sense in the context of STD (the pad saving infrastructure, etc)

[09:33] <sorear> but they can be dead code

[09:34] <sorear> it's possible to translate grammars other than STD and run them without STD.pmc loaded

[09:35] <pugssvn> r31541 | pmurias++ | [mildew] rename SSA to Mildew::SSA 

[09:37] <pmurias> sorear: would it be ok if viv added an "generated code" warning to it's output files

[09:37] *** Su-Shee joined
[09:38] <sorear> yes

[09:38] *** lest_away is now known as lestrrat

[09:38] <sorear> although really the complete lack of indentation and comments should be a clear tell...

[09:38] <pmurias> sorear: i had a few moments of doubt when looking at some files, and i saw someone edit generated PIR so it's better to be save

[09:38] <pmurias> * safe

[09:39] <sorear> I might also add a compatibility interlock of some kind

[09:39] <sorear> die "Version skew - please recompile" if $Perl6::Cursor::VERSION != 32768;

[09:39] <sorear> will need to see if that's workable with our bootstrapping

[09:40] <pmurias> what is 32768 here?

[09:41] <sorear> no, that won't work, nevermind

[09:41] <sorear> a placeholder for a svn rev

[09:41] *** sawyer_ joined
[09:41] * sorear is now very convinced that Perl6::STD::* and Perl6::Cursor::* is correct, awaiting final confirmation from TimToady

[09:43] <pmurias> Perl6::STD::* or just STD::*

[09:43] <sorear> Perl6::STD::*

[09:44] *** meppl joined
[09:48] <masak> mixins are *awesome* for debugging, too.

[09:52] <pmurias> masak: mixins? you mean the poor man's roles ruby has? ;)

[09:53] <sorear> masak: What if I told you that 1 + failure is completely legal?

[09:55] * sorear is campaigning to get this "feature" removed from the spec

[09:55] <pmurias> sorear: what's the result of 1 + failure?

[09:55] <sorear> pmurias: 2

[09:55] <masak> pmurias: I mean doing $object does SomeRole, where SomeRole contains methods with 'callsame' in them.

[09:55] <jnthn> pmurias: role + does (or but) = mix-in

[09:55] <jnthn> ;-)

[09:56] <sorear> Perl 6 enums are treated as subtypes of Int by default

[09:56] <masak> pmurias: that way, I can capture the return value on the way back from the original method, print it, and return it from the wrapper.

[09:56] <sorear> and are usable anywhere an Int is

[09:56] <masak> sorear: aye.

[09:56] <sorear> I would really like to see the coercion become by-explicit-request-only

[09:56] <jnthn> sorear: It is for int

[09:56] <jnthn> Just not for Int

[09:57] <pmurias> masak: so you can see how a particular object is used?

[09:57] <sorear> in Haskell, Char is treated as a 0x10FFFF-valued enumeration, and the enum <-> Int functions are 'ord' and 'chr'

[09:57] <masak> pmurias: yes. basically, it gives arbitrary control over the calls to and return values from methods.

[09:57] <sorear> this is possibly a model worth emulating

[09:58] <tylercurtis> Is it possible for a parameterized role to determine the name of the method the role declares based on the parameter? If so, masak, I have an idea for a wonderful debugging helper mixin: LogResult["method_name"]

[09:58] <masak> tylercurtis: dunno. jnthn++ would. :)

[09:59] <jnthn> tylercurtis: Easier is just to build up a role for that using the meta-model.

[09:59] <masak> tylercurtis: I've had the same idea, for what it's worth. it seemed to abstracted for what I needed.

[09:59] <jnthn> tylercurtis: You could then build a role that logs calls to all methods on an object. :-)

[10:00] <jnthn> (by introspecting it and then building a matching role)

[10:01] <pmurias> sorear: where is the adding + 1 to failure thing specced?

[10:03] <tylercurtis> Anyway, good night, folks. Happy fourth to those others in the US.

[10:04] *** tylercurtis left
[10:05] <sorear> S12:1689, S12:1739

[10:07] <pmurias> are failures enums?

[10:07] <sorear> 'failure' is an enum defined in masak's code

[10:08] <sorear> 'Failure' is a completely unrelated standard type which is not an enum

[10:08] <sorear> enum Result < success failure >;

[10:09] <sorear> well, I haven't actually seen the definition

[10:09] <sorear> but it completely fits masak to think of success first :)

[10:09] <masak> actually, < failure success forced-success > nowadays.

[10:09] <masak> which motivates it not being just a Bool.

[10:12] *** Ross left
[10:17] <sorear> rakudo: say [1].WHAT

[10:17] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[10:19] <masak> TimToady: State of the Onion 4, on 2000-07-19, is listed on Wikipedia as the announcement date of Perl 6. 15 days from now, that's 10 years ago.

[10:19] <masak> TimToady: but when were Jon Orwant's cups thrown? and what happened in the time between that and up to your talk?

[10:20] <masak> s/cups/mugs/

[10:20] * masak wants to celebrate the 10-year anniversary by throwing a mug

[10:20] <masak> not necessarily one of jnthn's, though :)

[10:21] * sorear out.

[10:21] <jnthn> masak: That's OK, you won't be here on the 19th :P

[10:21] <masak> jnthn: :) true.

[10:22] <masak> but it might be the mug-throwing occurred the day before, or several days before.

[10:25] <jnthn> oh noes my mugs!

[10:26] * masak looks at the mug of tea he just finished

[10:26] <jnthn> .oO( if masak smashes a mug do I have to start working on Perl 7? )

[10:26] <masak> I'm going to pop out and... refill my mug. :P

[10:26] <jnthn> :P

[10:26] * jnthn watches nervously

[10:28] <masak> perhaps the release of Rakudo Star should be celebrated with the careful gluing-together of a smashed mug.

[10:29] <masak> "Look! It's leaking a bit, and you must handle it carefully... but you can actually drink from it!"

[10:30] <jnthn> Ooh...can I drink beer from it?

[10:30] <jnthn> ;-)

[10:31] <masak> jnthn: there was a toy constructed language where the noun 'beer' was derived from the verb 'to be'. :) I think you would have liked that.

[10:32] <masak> std: sub foo(*@a1, *@a1) {}

[10:32] <p6eval> std 31541: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable @a1 (see line 1) at /tmp/Op8pLCUWqA line 1:␤------> [32msub foo(*@a1, *[33m⏏[31m@a1) {}[0m␤ok 00:01 112m␤»

[10:32] <masak> std: sub foo(*@a1, *@a2) {}

[10:32] <p6eval> std 31541: OUTPUT«ok 00:01 109m␤»

[10:32] <masak> std: sub foo(*%h1, *%h2) {}

[10:33] <p6eval> std 31541: OUTPUT«ok 00:01 109m␤»

[10:33] <masak> std: sub foo(*@a!) {}

[10:33] <p6eval> std 31541: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse signature at /tmp/QwdHCNmQz5 line 1:␤------> [32msub foo[33m⏏[31m(*@a!) {}[0m␤Couldn't find final ')'; gave up at /tmp/QwdHCNmQz5 line 1:␤------> [32msub foo(*@a[33m⏏[31m!) {}[0m␤    expecting any of:␤     constraint␤    

[10:33] <p6eval> ..param_sep␤        tr…

[10:34] <masak> ...a bit LTA...

[10:36] <jnthn> masak: I am the beer of an amused look. :P

[10:37] * masak .oO( "I am Jack's smirking revenge." )

[10:41] *** rv2733 left
[10:41] *** pmurias left
[10:55] <Juerd> This terminal displays the NL codepoint as a grid of dots. Much cleaner and nicer to read.

[10:56] <masak> seems only Days 10 and 21 of the Perl 6 Advent Calendar have yet to manifest as test files in the spectest suite.

[11:01] <masak> by the way, are the Advent entries kept up-to-date with the changing syntax of Perl 6, based on test failures in the spectest suite?

[11:01] * masak guesses "no"

[11:11] *** ruoso joined
[11:18] <pugssvn> r31542 | masak++ | [S16-filehandles/open.t] removed stale tests 

[11:18] <pugssvn> r31542 | 

[11:18] <pugssvn> r31542 | I doubt very much that the syntax proposed will ever be spec. Nowadays we

[11:18] <pugssvn> r31542 | "redirect" the $*IN, $*OUT and $*ERR streams using binding.

[11:33] <masak> wow -- this talk from 2007 is still mostly up-to-date: http://www252.pair.com/~comdog/Talks/LearningPerl6-NPW2007.pdf

[11:33] <masak> and it looks like a good intro to Perl 6.

[11:34] <masak> (I only found the prefix:<=> to be a fossil.)

[11:40] <masak> LOL: "Over the coming months, we'll see the rest of the Apocalypses, backed up by Exegeses from Damian, and hopefully, eventually, code from Dan and the rest of the team." -- from http://www.perl.com/lpt/a/571

[11:41] *** pmurias joined
[11:45] <dalek> rakudo: 3894c4a | jonathan++ | src/ (2 files):

[11:45] <dalek> rakudo: Move rebless to P6metaclass additions so we can rebless metaclasses, and give 

[11:45] <dalek> rakudo: them a CREATE too. Gets us closer towards mixing into them working, but still 

[11:45] <dalek> rakudo: $other-bug. :-/

[11:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3894c4aa1a2d214eebcd2b385d51e28b25b669f5

[11:45] <dalek> rakudo: 5c25692 | jonathan++ | src/core/IO.pm:

[11:45] <dalek> rakudo: Implement mkdir, chdir and dir (like slurp, but gets list of files).

[11:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5c256921f064b2c4d7871862990ad7d47972c021

[11:46] *** Ross joined
[11:46] <masak> looking at both S16-filehandles/open.t and S16-filehandles/io.t, it seems to me the former should be either incorporated into the latter or removed completely.

[11:54] *** pmurias left
[12:02] *** szbalint joined
[12:21] *** ive left
[12:22] *** clintongormley joined
[12:39] *** mj41 left
[12:41] *** dual left
[12:46] <masak> why does IO::Writeable.write take an Int $bytes as a parameter?

[12:48] <masak> isn't it enough to pass a Buf?

[12:49] *** sawyer_ left
[12:57] *** houghton joined
[12:58] <houghton> could I make a suggestion to the Rakudo Star developers?

[12:58] <houghton> not sure there's anyone listening

[12:58] <houghton> well, here it is: for a while now say hasn't been working in roles

[12:59] <jnthn> At least a couple of us are listening. ;-)

[12:59] <houghton> ok!

[12:59] <jnthn> houghton: Yes, that's a must fix for Rakudo *.

[12:59] <houghton> it seems like it's among the first things someone's going to try out

[12:59] <houghton> ok

[12:59] <houghton> figure it's going to be part of a lot of "hello, world" test programs

[12:59] <jnthn> Quite

[12:59] <jnthn> It needs fixing, it's a bad bug.

[13:00] <houghton> alright, I won't beat the dead horse, then

[13:00] <jnthn> :-)

[13:02] *** sawyer_ joined
[13:05] <pugssvn> r31543 | masak++ | [S32/IO] changed API for C<.read> and C<.write> 

[13:05] <pugssvn> r31543 | 

[13:05] <pugssvn> r31543 | The API looked unnatural and non-Perly, so I changed it to something that made

[13:05] <pugssvn> r31543 | sense. Rather than sending in an Int to indicate how much to write, just let

[13:05] <pugssvn> r31543 | the length of the Buf determine that. (If you want to send a prefix of a Buf,

[13:05] <pugssvn> r31543 | just make a slice -- a more general operation.)

[13:05] <pugssvn> r31543 | 

[13:05] <pugssvn> r31543 | Similarly, rather than having to send in an existing Buf for overwriting in

[13:05] <pugssvn> r31543 | the read method, just return a new Buf. Don't need to return an Int; if we

[13:05] <pugssvn> r31543 | are truly interested in the number of bytes read, we can do $buf.elems.

[13:06] <masak> houghton: here's the ticket number: http://rt.perl.org/rt3/Ticket/Display.html?id=74078

[13:06] <masak> houghton: I heard a rumour that the fixes pmichaud are almost done with might actually fix the say-in-role thingy too.

[13:08] <jnthn> masak: I know pmichaud might feel plural, but... :P

[13:09] <masak> heh :)

[13:09] <masak> grammar fail.

[13:09] <masak> I meant "the fixes pmichaud *be* almost done with". arrr!

[13:11] *** isBEKaml joined
[13:12] <isBEKaml> OHHAI, #perl6! 

[13:12] <masak> isBEKaml: \o

[13:13] <isBEKaml> masak: :)

[13:13] <isBEKaml> I wanted to ask you about the SIC instruction set. :P

[13:13] <masak> go ahead.

[13:15] <isBEKaml> do you have any defined set of instructions for SIC. Well, about that design flaw you pointed out, the SIC code dump showed nowhere that we have new lexpad initialisation. Maybe I could rework the code to redraw the block afresh if we are inside a loop or so. 

[13:15] <masak> I have a hunch that the SIC code needn't change for the blocks to work right.

[13:15] <masak> well, except for one thing, probably.

[13:16] <isBEKaml> me too. I would just like to make sure. 

[13:16] <masak> you know how we have 'main', 'main_1', 'main_1_1' blocks right now?

[13:16] <isBEKaml> yes. 

[13:16] <masak> and the parent-child relationship is actually determined by adding and removing individual _\d suffixes.

[13:17] <isBEKaml> I was thinking I could rework the cheats in block-relationships if we don't have to make SIC changes. 

[13:17] <isBEKaml> the "cheats" :D

[13:17] <masak> yes.

[13:17] <masak> that probably needs to change, and instead be represented in SIC as 'this block is called 'block_\d\d\d', and its parent is 'block_\d\d\d'.

[13:17] <masak> with some appropriate syntax.

[13:18] <masak> the rest of the changes needed are probably restricted to the Yapsi::Runtime.

[13:19] <isBEKaml> right. I was going over how we sicify $/ against various matches, and thought "Well, maybe if we have something definite in the form of SIC instruction set, we could use that. "

[13:19] <isBEKaml> Now, it looks like we don't have to do it. 

[13:20] <isBEKaml> or come up with new SIC instruction set. :P

[13:20] <isBEKaml> Btw, who's using SIC? 

[13:20] <masak> the SIC standard changes gradually all the time. it's not really stable.

[13:21] <masak> the only real "normative" document of it is the switch statement in Yapsi::Runtime.

[13:21] <masak> isBEKaml: tylercurtis++ uses it in http://github.com/ekiru/Bennu, released earlier today.

[13:21] <isBEKaml> "switch" given -when ?

[13:22] <masak> isBEKaml: it's a SIC->LLVM compiler.

[13:22] <masak> yes, given/when are switch statements. :)

[13:22] <isBEKaml> great scott! LLVM? We have gone that far? :)

[13:22] <masak> I was positively surprised too.

[13:22] <isBEKaml> tylercurtis++

[13:23] <isBEKaml> Now we need to worry about stabilising SIC. :P

[13:23] <isBEKaml> Pleasant headache. :)

[13:27] <masak> indeed.

[13:28] <isBEKaml> [backloggin] jnthn added VICTUALS, one of them's Chicken JalFreizi? (Now that's something I recognise - not that I'm vegetarian) :)

[13:28] <masak> he guessed it wouldn't be much of a problem.

[13:28] *** dual joined
[13:29] <isBEKaml> masak: Yes, I guess so. 

[13:30] *** xinming left
[13:30] *** xinming joined
[13:33] <pugssvn> r31544 | masak++ | [t/spec/S16-filehandles/io.t] a few :bin tests for &open 

[13:39] <isBEKaml> masak++ # For forcing jnthn++ to pen down his gastric favourites. :)

[13:40] <masak> isBEKaml: so, when are you putting yourself in VICTUALS?

[13:41] <isBEKaml> masak: Err, I haven't done much. ;)

[13:41] <masak> we all need to eat.

[13:41] <isBEKaml> besides, no one enjoys being on the food plate. :P

[13:42] <masak> isBEKaml: this is about being able to assist a fellow Perl 6 hacker in a crisis. it's serious business. :)

[13:44] *** Ross left
[13:44] <isBEKaml> masak: Alright, granted you know how to persuade. I have yet to hack all day and all night. ;)

[13:45] <masak> it's about being proactive, and not waiting until that happens. :)

[13:46] <masak> I hesitated for far too long before putting myself on that list. in retrospect, I should have done it earlier.

[13:46] <isBEKaml> Alright, I'll add my entry later tonight. :)

[13:47] <masak> \o/

[13:47] *** Ross joined
[13:47] * isBEKaml masak sure knows how to persuade people!

[13:48] <masak> when I snap my fingers, you'll regain consciousness. you won't remember anything from this session.

[13:48] <masak> erm. I mean.

[13:48] * masak snaps fingers

[13:48] <masak> so, anyway. Perl 6 rocks, eh?

[13:49] * isBEKaml woke from a deep slumber. Well, what happened? 

[13:49] <masak> isBEKaml: you missed the Rakudo Star release! o.O

[13:50] <jnthn> It was awesome!

[13:50] <masak> man, yeah.

[13:50] <masak> let's do that again!

[13:50] <jnthn> The Reddit folks LOVED it! Not a single negative comment!

[13:50] <isBEKaml> masak: Rakudo Star? 

[13:50] <masak> isBEKaml: how long have you been asleep?

[13:51] <isBEKaml> masak: Don't know. You tell me. :D

[13:51] * masak gets slightly worried

[13:51] <masak> isBEKaml: ok, so in the year 2000, the Perl 6 effort was started...

[13:52] <masak> www.perl6themovie.com

[13:52] <isBEKaml> ooh, I remember Jon Orwant's epic move of smashing mugs! 

[13:53] <masak> isBEKaml: right. so, what happened then was that a number of increasingly descriptive documents were authored. RFCs, Apocalypses, Exigeses and Synopses.

[13:53] <masak> the Synopses are still being filled in.

[13:53] <isBEKaml> wait, what's the date today? 

[13:53] <isBEKaml> 2056? :O

[13:53] <masak> don't worry, it's only 2016.

[13:53] <masak> erm, 2010. 2010!

[13:54] <isBEKaml> No, wait. It must be 2013 or so.. 

[13:54] <isBEKaml> ah, right. 2010. 2010.  # I must remember that.. 

[13:54] * masak shouldn't be borrowing lue's time machine. far too confusing.

[13:54] *** snuff_ left
[13:54] * isBEKaml thinks if he accidentally stepped into tardis for such disorientation. 

[13:55] * isBEKaml vaguely remembers a movie depicting this disorientation too - Now, what was that? Pandora? No - Pandorum!

[13:57] *** Trashlord joined
[13:58] <isBEKaml> #Perl6 rocks! 

[13:59] <masak> :)

[13:59] <masak> a bit addictive, too.

[14:00] <isBEKaml> yes. addictively addictive. :) #Don't know if that's right, I think it sums up everything meta. :)

[14:00] *** timbunce joined
[14:01] *** houghton left
[14:03] <masak> isBEKaml: if you want to help, you could take the ./proof-of-concept script in the 'pls' branch of http://github.com/masak/proto for a spin. see if it works on your box.

[14:04] <isBEKaml> masak: I already have proto cloned in my box. (I think I have commit access to proto, not sure)

[14:04] <masak> you do.

[14:05] <isBEKaml> masak: how do I switch branches? My gitfu failed me when I typed in `git checkout proto/pls`

[14:07] <masak> 'git checkout pls'

[14:07] *** sawyer_ left
[14:07] <isBEKaml> masak: no, didn't work. tried that too. 

[14:07] <masak> oh wait.

[14:07] <masak> right.

[14:07] <masak> 'git checkout -t origin/pls'

[14:07] <jnthn> git checkout -t origin/pls

[14:07] <masak> :)

[14:08] <jnthn> ('great minds', 'all fools').pick.say ;-)

[14:08] <masak> jnthn: we're lucky p6eval is broke :P

[14:08] <isBEKaml> :)

[14:09] <isBEKaml> broke? as in "no money" ? :P

[14:09] <masak> no, "broke" as in "masak should speak better English".

[14:10] <isBEKaml> :D

[14:10] *** sawyer_ joined
[14:10] <masak> strangely, the expression is "If it ain't broke, don't fix it".

[14:10] <isBEKaml> masak: I see from the source that it used JSON::Tiny and App::Pls. Where do I get them from? 

[14:11] <isBEKaml> ah, lib folder. 

[14:11] <isBEKaml> nm

[14:11] <masak> isBEKaml: 'export PERL6LIB=`pwd`/lib'

[14:11] <isBEKaml> masak: yes. did that. 

[14:13] <masak> isBEKaml: one thing you're welcome to do if you want is to create a 'pls' script in Perl 5, that just delegates (cmdline args and all) to ./proof-of-concept.

[14:14] <masak> when that works, we can put in an "is Rakudo installed?" check, and give nice installation instructions if it ain't, er, isn't.

[14:15] *** sawyer_ left
[14:15] *** sawyer_ joined
[14:15] <isBEKaml> masak: only way I could think of doing it is a system() call. I usually avoid that. 

[14:15] <isBEKaml> delegating to p-o-c, I mean. 

[14:16] <masak> that's fine here.

[14:16] <masak> can even be an &exec call.

[14:17] <isBEKaml> ok. 

[14:19] <masak> I'm also interested in what surprising situations you run into when actually installing projects from the ecosystem. this part is still greatly under-tested.

[14:47] <isBEKaml> masak: we aren't using the p5 proto.pl anymore? the p6installer is now about to be written in p6? 

[14:48] * isBEKaml likes how everything is neatly arranged in namespaces. :)

[14:50] <masak> no, the script that the user actually calls will still be in Perl 5, I think.

[14:50] <masak> this is so that a user without Rakudo installed will get the error message we decide.

[14:51] <arnsholt> In NQP, isn't :foo<bar> and :foo('bar') supposed to be equivalent?

[14:51] <masak> however, the 'proto.pl' was overly complicated; it tried to install its own Parrot/Rakudo, and it did stuff in several steps with config files. most of that will simply not be re-used for pls.

[14:51] <arnsholt> Eh. Never mind. I figured out my own stupidity as I asked the question >.<

[14:51] <isBEKaml> err, I'm thinking along the lines of cpan. it would work only if the user had perl available and installed. 

[14:52] <masak> isBEKaml: I understand. I still prefer a Perl 5 wrapper, for the above reason.

[14:55] <isBEKaml> masak: I think we are trying to do too many things here. Application installation is OS dependent and among Linux distros along, it varies from distro to distro. 

[14:55] <isBEKaml> s/along/alone/

[14:55] <masak> right. we seem to be in agreement, though.

[14:55] <isBEKaml> I think you're aware of that. 

[14:55] <masak> proto tried to install Parrot/Rakudo, pls won't.

[14:56] <masak> it will just print a cute error message if 'perl6' isn't in the $PATH.

[14:57] <isBEKaml> oh, we are in agreement then. 

[15:04] <masak> yeah. pls actually holds back in a few places where proto tried to be a bit too helpful. :)

[15:10] *** mberends left
[15:10] <isBEKaml> yeah, leave all decision making to the user. Stupid computer never decides. :)

[15:19] <masak> walk &

[15:23] * moritz_ back

[15:24] *** timbunce left
[15:33] *** tadzik left
[15:45] <pmichaud> good morning, #perl6

[15:52] <moritz_> good morning pmichaud 

[15:52] *** pmurias joined
[15:55] *** cono joined
[15:59] *** tedv joined
[16:05] *** timbunce joined
[16:08] *** supernovus joined
[16:12] *** ruoso left
[16:15] *** envi^home left
[16:20] *** ashleydev joined
[16:28] <pugssvn> r31545 | moritz++ | [t/spec] rakudo unfudges 

[16:28] *** rv2733 joined
[16:29] <moritz_> so, what's up in the Perl 6 world?

[16:29] *** ashleydev left
[16:33] *** ashleydev joined
[16:33] <pmichaud> I'm still struggling to make Rakudo understand closures.

[16:33] <pmichaud> Right now everything basically works except for methods. 

[16:33] *** eternaleye joined
[16:33] <pmichaud> oh wait

[16:34] <pmichaud> maybe even more than that works now

[16:34] <pmichaud> (running a new spectest right now)

[16:34] <moritz_> sounds like an improvement :-)

[16:34] *** ashleydev left
[16:34] <pmichaud> yes.  Surprisingly, my latest change seems to have resolved all of the S12 and S14 problems.

[16:34] *** jedai_ joined
[16:35] <pmichaud> I've also added a "make quicktest" target in my branch that doesn't run test files marked "#long"  (such as S32-trig and S05-mass/rx.t)

[16:35] <pmichaud> that helps a fair bit :)

[16:36] *** supernovus_ joined
[16:36] <moritz_> we could also move those to the 'stresstest' target

[16:36] <pmichaud> I like that 'spectest'  includes the trig tests

[16:36] <moritz_> I'm kinda worried about having too many confusing targets

[16:36] <pmichaud> and I didn't want to have to maintain yet another spectest.data file with a separate list

[16:37] *** supernovus left
[16:37] *** supernovus_ is now known as supernovus

[16:37] <moritz_> well, you're the boss :-)

[16:38] <pmichaud> I could make the stresstest target also use a '#stress' marker in spectest.data

[16:38] <moritz_> +1 to that

[16:38] <pmichaud> then at least all of the test files would still be in spectest.data, and we'd have a consistent mechanism for selecting sets

[16:39] <moritz_> right, I'd prefer that over our current situation

[16:39] *** Ross left
[16:39] *** Ross joined
[16:45] *** ruoso joined
[16:48] *** hercynium left
[16:59] <pmichaud> stresstest refactor: http://github.com/rakudo/rakudo/commit/0ba07fac9c1949f6dd28a9054dd8d3cb935bf5b6

[17:02] <timbunce> It's odd, and somewhat unhelpful, that "perl6 --version" reports the parrot version not the perl6 version. Is there an easy way to get the perl6 verdsion?

[17:02] <timbunce> or version, even.

[17:02] <pmichaud> timbunce: not yet, although I hope to add that in the next few days.

[17:02] <timbunce> pmichaud: ok, thanks

[17:02] <pmichaud> istr we had a patch that improved this quite a bit.

[17:02] <pmichaud> anyway, I'm going to have it report the version + github modification information

[17:03] <pmichaud> s/github/git/

[17:08] *** pmurias left
[17:13] *** eternaleye left
[17:22] *** supernovus left
[17:31] *** timbunce left
[17:32] *** timbunce joined
[17:39] <frew> rakudo: sub foo($a) { say $a }; foo('frew')

[17:39] <p6eval> rakudo 5c2569: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[17:39] <pmichaud> p6eval broken, I think.

[17:39] <frew> apparently!

[17:40] <frew> well, I was curious if one could do something like...: sub foo: * * 2;

[17:40] <pmichaud> that doesn't look like valid syntax, no.

[17:40] <pmichaud> (if you're trying to define foo)

[17:40] <frew> right

[17:40] <pmichaud> but you can do     my &foo := * * 2;

[17:41] <pmichaud> which basically has the same effect.

[17:41] <frew> neat

[17:41] <pmichaud> := nyi

[17:41] <frew> oh right

[17:41] <pmichaud> so you might need   my &foo = * * 2;

[17:41] <frew> still neat

[17:41] <pmichaud> > my &foo = * * 2;   say foo(5);

[17:41] <pmichaud> 10

[17:41] <frew> very cool

[17:42] *** timbunce left
[17:42] <frew> awesome, and it works as I expect with multiple stars

[17:42] *** rv2733 left
[17:44] *** whiteknight joined
[17:46] *** patrickas joined
[17:49] *** chee joined
[17:58] <chee> is it safe?

[17:58] *** eternaleye joined
[17:59] *** nbrown04 joined
[17:59] *** nbrown04 left
[18:24] * jnthn back

[18:27] <cxreg> is there an "is gd" attribute yet? :)

[18:28] <jnthn> gd? 

[18:28] <dalek> rakudo: 067b67f | jonathan++ | src/binder/bind.c:

[18:28] <dalek> rakudo: Make sure if we have a sub foo(Foo $x?) { } then $x default to a Foo type 

[18:28] <dalek> rakudo: object, not Any.

[18:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/067b67f91869c738afa6ce4b349b664eede9e43a

[18:28] <dalek> rakudo: 6e0cb64 | jonathan++ | src/builtins/Role.pir:

[18:28] <dalek> rakudo: Role type objects need to be undefined (d'oh...)

[18:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6e0cb64a81dcf9eb10eb8f43d30795a4022e11aa

[18:28] <dalek> rakudo: 4be0c42 | jonathan++ | src/ (2 files):

[18:28] <dalek> rakudo: Do type check the invocant of a method.

[18:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4be0c427e2cce1250ecfafc4943dc0297efe1931

[18:28] <dalek> rakudo: c4b7cf4 | jonathan++ | src/Perl6/Compiler/Signature.pm:

[18:28] <dalek> rakudo: Default parameter type should be passed on to sub-signatures.

[18:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c4b7cf426c25168da2cbd6012bc285ee4b0023fc

[18:28] <dalek> rakudo: edade8a | jonathan++ | src/ (2 files):

[18:28] <dalek> rakudo: Parametric variants of roles should also be undefined since they serve as type 

[18:28] <dalek> rakudo: objects.

[18:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/edade8a826ebf4105a3a582d02e3b1219914fd5e

[18:28] <cxreg> jnthn: http://is.gd/

[18:29] <cxreg> i think it's pronounced "is good"

[18:29] <jnthn> our multi trait_mod:<is>($thingy, :$gd!) { ... } # there is now ;-)

[18:29] <cxreg> lol

[18:30] *** TiMBuS left
[18:30] <jnthn> o/ pmichaud :-)

[18:32] <masak> chee: yes.

[18:32] <masak> chee: P.S. is what safe? :)

[18:32] <chee> p6!

[18:33] <masak> chee: ok, so your question is "what are the security aspects of Perl 6 compared to other languages?"

[18:33] <masak> or something.

[18:34] <masak> chee: sorry for rewriting your question, just trying to arrive at what you want to ask. :)

[18:34] <masak> ooh! audreyt++ # http://twitter.com/audreyt/status/17729663670

[18:34] <chee> really I was asking how usable the implementations currently are

[18:35] <masak> chee: Rakudo is the most far along in terms of breadth.

[18:35] <masak> chee: but there will be glitches, so be prepared to submit the odd bug report or so.

[18:36] * cxreg makes a camelia t-shirt for his 3 year old

[18:37] <chee> :D

[18:42] *** whiteknight left
[18:45] <pmichaud> jnthn: ping

[18:46] <jnthn> pmichaud: pong

[18:47] <pmichaud> for roles, does !add_variant expect the static code object or a dynamic (closure) one?

[18:47] <pmichaud> i.e., what needs to be held in !$selector ?

[18:47] <pmichaud> er, $!selector

[18:47] <pmichaud> (overall:  I'm working on getting 'trait_mod:<of>' to work on subs.)

[18:48] <jnthn> pmichaud: It needs to have closure semantics

[18:49] <jnthn> Because it's signautre contains stuff that the methods inside the role would refer to

[18:49] <jnthn> And need to be unique per parameterization of the role.

[18:49] <pmichaud> so to confirm:  when we invoke !add_variant, we're passing whatever the current outer lexical pad happens to be at that point

[18:49] <jnthn> Right

[18:50] <pmichaud> okay.

[18:50] <jnthn> In

[18:50] <jnthn> role Foo[::T] { method foo(T $x) { } }

[18:50] <jnthn> Taht's really compiling do something more like

[18:51] <jnthn> multi Foo(::T) { ...stuff... $r.^add_method('foo', method (T $x) { }); ...stuff... }

[18:51] <jnthn> And that multi candidateis what is being passed to add_variant

[18:51] <jnthn> *candidate is

[18:51] <jnthn> *to

[18:52] <pmichaud> okay, I've switched to pass the dynamic code object, let's see if it works :)

[18:52] <pmichaud> oh, fail.

[18:52] <pmichaud> just a sec

[18:52] <pmichaud> (it didn't fail, because I aborted before it was going to :)

[18:53] <lue> ohai o/

[18:54] <lue> here's an example of me missing the obvious: instead of using ACCEPTS for typechecking, I just compared the WHATs of the objects :)

[18:54] <masak> phenny: ask TimToady could you have a look at this case of the new semantics for multies in an OO hierarchy? jnthn and I have an un-consensus about it.

[18:54] <phenny> masak: I'll pass that on when TimToady is around.

[18:54] <masak> lue: yeah, use infix:<~~>

[18:55] <pmichaud> masak: ...which case?

[18:55] <masak> phenny: tell TimToady -- oh and here's the link http://gist.github.com/463655 :)

[18:55] <phenny> masak: I'll pass that on when TimToady is around.

[18:55] <jnthn> pmichaud: yes, yes, I'm just teasing him about that in meatspace. ;-)

[18:55] * masak is teased :)

[18:55] <masak> "Don't tease me, bro!"

[18:56] <masak> bus &

[18:56] *** masak left
[18:57] <jnthn> Making sure masak gets the bus :-) &

[18:57] <lue> I used $target.WHAT !~~ $source.WHAT . I found why this isn't good here:

[18:57] <lue> > my $a = 3; my $b := $a;

[18:57] <lue> You cannot bind a variable of type Int() to a variable of type Any().

[18:58] <pmichaud> jnthn: okay, switching it to grab a closure didn't work.

[18:58] <pmichaud> I don't quite follow the logic, so let me walk through it again.

[18:58] <pmichaud> !add_variant gets invoked when we create a new role?

[19:02] <sorear> good morning #perl6

[19:03] <pmichaud> oh, I think I might see the problem.  Callable isn't defined in the core.

[19:03] <pmichaud> (so it's probably not being set up properly)

[19:03] <pmichaud> tracing

[19:04] *** cono left
[19:05] <perl6> good morning, sorear

[19:06] *** cono joined
[19:08] *** pmurias joined
[19:10] *** tylercurtis joined
[19:10] <pmichaud> jnthn: ping

[19:12] <lue> now, that I changed the typecheck comparison to ACCEPTS, this obvious flaw happens!

[19:12] <lue> > my @a = <a b c>; my $var = 'd'; @a[1] := $var; say @a[1]

[19:12] <lue> You cannot bind a variable of type Str() to a variable of type Str().

[19:12] <pmichaud> what are you using for the invocant of .ACCEPTS ?

[19:13] <moritz_> you need to use the type object

[19:13] <moritz_> not the actual object

[19:13] <pmichaud> the type of the container

[19:13] <moritz_> because 'a' !~~ 'b'

[19:13] <pmichaud> getprop 'type'

[19:13] <lue> if !$target.ACCEPTS($source)

[19:13] <moritz_> but 'a' ~~ Int'

[19:13] <pmichaud> that won't work.

[19:13] <pmichaud> $target is the _value_ that's currently in the container, not the type of the container

[19:13] <pmichaud> pir::getprop__PsP('type', $target)

[19:14] <lue> $target.WHAT.ACCEPTS won't, work, eh?

[19:14] <pmichaud> no

[19:14] <pmichaud> because if $target currently contains a '3', then $target.WHAT is Str

[19:14] <pmichaud> which has absolutely nothing to do with the typeconstraint on the container itself

[19:15] <pmichaud> if we had VAR() implemented, it would be   VAR($target).type.ACCEPTS    or something like that

[19:15] <lue> so would I use that PIR code and compare it to the $source type aswell, or can I attach an ACCEPTS to that?

[19:16] <pmichaud> no

[19:16] <pmichaud> in the case of $source, you're wanting to verify that the value is of the correct type

[19:16] <pmichaud> you're not wanting to compare the type of $source's container.

[19:16] <lue> pir::getprop__PsP('type', $target) ~~ $source then?

[19:16] <pmichaud> yes, but I would use .ACCEPTS

[19:17] <pmichaud> pir::getprop__PsP('type', $target).ACCEPTS($source)

[19:17] <pmichaud> and you also need to check for the case where 'type' is null

[19:17] <pmichaud> (which implies that no typecheck is needed)

[19:18] <lue> which would only require pir::getprop__PsP('type', $target) ~~ null  , correct?

[19:19] <pmichaud> pir::isnull(pir::getprop__PsP... )

[19:19] <pmichaud> there is no "null" defined in Perl 6.

[19:19] <lue> ah, the wonderful world of PIR :)

[19:19] <pmichaud> at some level, the primitives have to be non-p6.

[19:19] <pmichaud> and binding is definitely a "primitive"

[19:20] <lue> I know, and all this is making me want to help with VAR next :)

[19:20] <lue> .oO(curse you, chain reaction!)

[19:22] <sorear> isBEKaml: "git checkout pls" works in git 1.6.  you really should upgrade

[19:23] * pmichaud tries something semi-radical.

[19:26] * lue Interest Level: 50% :)

[19:30] <pmichaud> I'm seeing if I can move the Callable role out of PIR and into the core setting.  :)

[19:32] <jnthn> pmichaud: back :-)

[19:33] <pmichaud> jnthn: see previous line.  :)

[19:33] <lue> you madman! Ah well, at least the Norweigan Blue is guarding all our PIR... ;)

[19:33] <jnthn> pmichaud: That's probably do-able.

[19:34] <pmichaud> so far it seems to work.  

[19:34] <jnthn> pmichaud: Yes, I imagine it will these days.

[19:34] <pmichaud> it doesn't solve my problem yet, but afaik Callable is the last PIR-based role that we have.

[19:34] <jnthn> Once upon a time, it woulda been awkward. :-)

[19:34] *** timbunce joined
[19:34] *** masak joined
[19:34] <masak> lol wifi in a moving vehicle

[19:34] <pmichaud> I had that on the way back from yapc::na :-)

[19:34] <pmichaud> the airplane had wifi

[19:34] <arnsholt> masak: Wifi-enabled bus?

[19:34] <masak> aye.

[19:35] <jnthn> masak: Happily on your way to Malmö? :-)

[19:35] <jnthn> You should almost be there already :-)

[19:35] <masak> jnthn: by dose is clogged, but I thidk I'll be fide.

[19:35] <jnthn> Aww

[19:36] <lue> "Let's see if I can land this thing in Excel!"

[19:36] <pmurias> sorear: any progress on the prefix?

[19:36] *** masak` joined
[19:36] <jnthn> I hope your Skånecold doesn't last too long. :-)

[19:36] <masak`> thanks again for a pleasant stay.

[19:36] * pmichaud tries to wipe the spec of dirt above the "a" off, fails.

[19:36] <masak`> (spicy food)++

[19:36] <masak`> the cold actually started back in Uppsala, though.

[19:37] <masak`> it was a consequence of the horridly unnatural rectification of the sleeping cycle.

[19:37] <sorear> pmurias: no

[19:37] <jnthn> ...which we've no managed to derectify. :-)

[19:37] <jnthn> *now

[19:37] <jnthn> Ah, so it was a scary Northern cold. Got it.

[19:38] <jnthn> pmichaud: :P

[19:38] *** masak`` joined
[19:38] <sorear> What exactly *is* Callable?

[19:38] <pmichaud> it's the role for things that can be invoked.

[19:38] <pmichaud> the things that bind to a &-sigil

[19:38] <sorear> but &postcircumfix:<( )> isn't a method

[19:38] <pmichaud> doesn't have to be

[19:38] <masak``> bus change &

[19:38] <moritz_> but &foo still has an implicit type constraint

[19:38] *** masak`` left
[19:39] <pmichaud> it's primarily a type constraint, and it provides the 'of' and 'returns' methods.

[19:39] <sorear> ah.

[19:39] <sorear> what's the difference?

[19:39] <pmichaud> just like I'm expecting that postcircumfix:<[ ]>  will move out of Positional and into Any.

[19:39] *** masak left
[19:40] <jnthn> If you write sub foo(&bar) { ... } then you can only pass things that does Callable.

[19:40] <pmichaud> (and the same for postcircumfix:<{ }> and Associative)

[19:40] <sorear> so generally speaking you should implement a postcircumfix:<[ ]> multi if and only if you also does Positional, but there's no actual connection between these two things.

[19:41] <pmichaud> actually, you'll likely implement the 'at_pos' method.

[19:41] <jnthn> ?

[19:41] <pmichaud> trying to use multidispatch to resolve postcircumfix:<[ ]>  across classes and types ends up being very painful.

[19:42] *** masak` left
[19:42] <sorear> where is at_pos specced?

[19:42] <pmichaud> sorear: it's not, I just added it to rakudo (and discussed it with TimToady++ at YAPC)

[19:42] <pmichaud> but it falls along the lines that most operators ought to have a named method equivalent.

[19:43] <pmichaud> anyway, at_pos (tentatively named)  ends up being the method that means "give me a single element out of the aggregate"

[19:43] <pmichaud> and postcircumfix:<[ ]> ends up making appropriate at_pos requests depending on its arguments

[19:45] <sorear> Excellent

[19:46] <sorear> This might be applicable to another of my problemishes

[19:46] <pmichaud> the underlying problem was that defining     method postcircumfix:<[ ]>($x)    in a subclass hid all of the other versions of postcircumfix from the role and superclasses

[19:46] <sorear> namely how to resolve the infinite regress of &postcircumfix:<( )>(&postcircumfix:<( )>, ...)

[19:47] <pmichaud> jnthn: moving Callable to setting ends up doing no further damage than what I already have.  :-)

[19:47] * pmichaud commits it.

[19:47] <jnthn> \o/

[19:47] <pmichaud> I think that means we have no more PIR-based roles.

[19:47] <jnthn> \o/

[19:48] <jnthn> Wow!

[19:48] <lue> \o\ \o/ /o/

[19:48] <jnthn> That's come around sooner than I expected

[19:48] * jnthn is happy

[19:48] <lue> .u happy

[19:48] <phenny> lue: Sorry, no results for 'happy'.

[19:48] <lue> .u smile

[19:48] <phenny> U+2323 SMILE (⌣)

[19:48] <lue> close enough *⌣*

[19:49] <moritz_> .u smiling

[19:49] <phenny> U+263A WHITE SMILING FACE (☺)

[19:49] <pmichaud> as I said, it still doesn't solve my problem, but it at least eliminates a possible source of them.  :0

[19:50] * sorear complains that the "better than Rakudo" bar keeps being moved

[19:50] <pmichaud> apparently I'm wrong.

[19:50] <pmichaud> sorear: get used to moving bars.  :-)

[19:50] <pmichaud> sorear: I've been dealing with a moving target for nearly six years now :)

[19:51] <pmichaud> ohhhh, one left!

[19:51] <pmichaud> Abstraction.

[19:51] <jnthn> .oO( It helps that I know a lot about bars... )

[19:52] <pmichaud> my phone never has enough of them.

[19:52] <lue> what bars?

[19:52] * pmichaud moves Abstraction.

[19:52] * sorear doesn't understand Abstraction

[19:53] <pmichaud> Abstraction is the role for types.

[19:53] <pmichaud> (packages, classes, etc.)

[19:53] <lue> after a spectest w/ latest rakudo, I will post the := code!

[19:54] <sorear> what types?

[19:54] <sorear> metaobjects or protoobjects?

[19:54] <sorear> or something else entirely?

[19:54] <pmichaud> that was a while ago -- look in the spec for Abstraction and I think it's clearer.

[19:55] <sorear>   Abstraction

[19:55] <sorear>         role Abstraction {...}

[19:55] <sorear> that is the totality of the spec for Abstraction.

[19:55] <pmichaud> S02

[19:55] <pmichaud> This C<Abstraction> role implies the

[19:55] <pmichaud> ability to do various symbol table and/or typological manipulations which

[19:55] <pmichaud> may or may not be supported by any given abstraction.  Mostly though it

[19:55] <pmichaud> just means that you want to give some abstraction an official name that

[19:55] <pmichaud> you can then use later in the compilation without any sigil.

[19:56] <tylercurtis> Examples given include "package, module, class, role, grammar, or any other type object, or any immutable value object that can be used as a type"

[19:56] <sorear> but type objects have exactly the same type as their instances

[19:57] <sorear> which means that 1 is also .^does(Abstraction)

[19:57] <moritz_> not quite

[19:57] <pmichaud> type objects might have Abstraction mixed-in.

[19:57] <moritz_> 1 is Int:d

[19:57] <moritz_> and Int type object is Int:u

[19:57] <jnthn> moritz_: D and U iirc

[19:58] <moritz_> uc then :-)

[19:58] <sorear> pmichaud: so Int === 1.WHAT but Abstraction ?

[19:58] <pmichaud> Abstraction might also end up being a subset

[19:58] <sorear> that confuses me

[19:59] <pmichaud> jnthn:

[19:59] <pmichaud> pmichaud@plum:~/rakudo$ ack does_role src/builtins

[19:59] <pmichaud> pmichaud@plum:~/rakudo$ 

[19:59] * jnthn is a tad hazy on Abstraction these days, tbh

[20:01] <pmurias> sorear: if we stopped using Storable how big would the performace penalty be?

[20:01] <jnthn> pmichaud: ?

[20:01] <pmichaud> no more roles defined in PIR.  :-)

[20:02] <lue> \o/

[20:02] <pmichaud> no more base-types needing the "does_role" parameter 

[20:02] <lue> (one of those moments I wish I wasn't restriced to one-line ASCII)

[20:02] <jnthn> pmichaud: src\metamodel\ClassHOW.pir(817)

[20:02] <jnthn> Is where you can rip it out from

[20:02] <jnthn> ;-)

[20:02] <pmichaud> I'll let you do that.  :)

[20:02] <jnthn> OK

[20:03] <pmichaud> besides, whenever I enter "vi src\metamodel\ClassHOW.pir"  into my shell it gives me the wrong file.

[20:03] <pmichaud> :-P

[20:03] <sorear> pmurias: er, what do we even use Storable for anymore?

[20:04] <pmurias> .syml.store files

[20:04] <pmurias> which cache .syml files

[20:04] <lue> pmichaud: your slashes are wrong.

[20:04] <sorear> hmm.  tias

[20:04] <pmichaud> lue: they aren't *my* slashes!!  :)

[20:04] <pmurias> sorear: as $ALL is getting corupted

[20:04] <jnthn> pmichaud: Clearly you need an OS upgrade

[20:04] <jnthn> :P

[20:04] <lue> why did you put in \ when it should be / (according to your shell prompt)?

[20:05] <sorear> for benchmarking this stuff I usually use time ./std -e '2+2'  ten times and average

[20:05] <pmichaud> lue: I was making a snide remark about jnthn++'s choice of OS, which he deftly ju-jitsued into a comment about mine.  :)

[20:05] <sorear> pmurias: you'll need to go to TimToady, I only barely understand $ALL

[20:05] <pmurias> as doing $ALL->{'UNIT'} = 4 changes it in stange ways

[20:05] <pmurias> (sets other keys)

[20:06] <pmichaud> okay, getting rid of all of this role stuff was nice, but I'm still left with my "of" bug.

[20:06] <pmichaud> hmmm.

[20:06] <lue> I'm missing the obvious today. :P

[20:06] <jnthn> pmichaud: Details?

[20:06] <jnthn> pmichaud: or branch name? ;-)

[20:06] *** silug left
[20:06] <pmichaud> jnthn: llsig

[20:07] <pmichaud> it may still be that I'm not sending a cloned method

[20:07] <pmichaud> (but I couldn't see that before because Callable wasn't going through the Role.pm code anyway :-)

[20:08] <pmichaud> testing that now.

[20:08] <pmichaud> the test that I'm working on is t/spec/S12-introspection/methods.t

[20:09] <pmichaud> but I think I've just about got it now.

[20:10] <jnthn> ok

[20:11] <pmichaud> ...nope.  :-(

[20:11] <pmichaud> nopasting my test file.

[20:12] <moritz_> .oO( we had an 'llsig' branch once, last year iir )

[20:12] <jnthn> Yes :-)

[20:12] <lue> when I'm done with spectesting, should I (paste patch|new branch|fork)?

[20:12] <pmichaud> http://gist.github.com/463718

[20:12] <pmichaud> lue:  patch, please.

[20:12] <lue> alright.

[20:13] <lue> (I personally wish to avoid forking if at all possible)

[20:13] <moritz_> git format-patch # and send per e-mail to [email@hidden.address]
[20:13] <pmichaud> if you nopaste the patch, I'll review it quickly here.

[20:14] <lue> yeah, I'm just letting the spectest run, making sure nothing has fallen out of existence :)

[20:15] <jnthn> pmichaud: building llsig

[20:16] <moritz_> is that the branch for fixing closures?

[20:16] <pmichaud> ...and a few other things, as it turns out.

[20:16] <pmichaud> but yes.

[20:16] <moritz_> ...as usual :-)

[20:17] <moritz_> uhm, llsig won't build Test.pir

[20:17] <moritz_> is that known/expected?

[20:17] <pmichaud> it builds on my system.

[20:17] <lue> lemme guess... something about MultiSub and set_candidates [?]

[20:17] <pmichaud> perhaps you have a too-new parrot?

[20:17] <moritz_> /home/moritz/rakudo/parrot_install/bin/parrot  perl6.pbc  --target=pir --output=Test.pir Test.pm

[20:17] <moritz_> Null PMC access in isa_pmc()

[20:17] <moritz_> current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1379 (runtime/parrot/library/P6object.pir:804)

[20:18] <moritz_> pmichaud: it's pretty new, yes

[20:18] <moritz_> r47972

[20:18] <pmichaud> PARROT_REVISION got bumped since I started the branch, I'm not sure if llsig will work with the new Parrot

[20:18] <pmichaud> seems like it shouldn't make a difference

[20:18] <pmichaud> I'll try bumping here and see what I get

[20:18] <jnthn> oh gah, yes

[20:18] <jnthn> I guess I need to downgrade my Parrot

[20:19] <moritz_> Author: jonathan <jonathan@d31e2699-5ff4-0310-a27c-f18f2fbe73fe>

[20:19] <moritz_> Date:   Sat Jul 3 13:26:41 2010 +0000

[20:19] <moritz_> [p6object] Fix a bug so that Foo.HOW.WHAT returns the proto-object for the metaclass as it should, not Foo.

[20:19] <pmichaud> it should've been just the change to p6object, yes?

[20:19] <pmichaud> I'm surprised if that causes Rakudo to not-build.

[20:19] <jnthn> pmichaud: It does.

[20:19] <pmichaud> oh, because you had that workaround.

[20:19] <jnthn> pmichaud: Right.

[20:19] <pmichaud> yes, that's why then.

[20:20] <pmichaud> I could try merging trunk into the branch.

[20:20] <jnthn> And the workaround worked around the thing I fixed in P6object. But workaround + fix = kaboom.

[20:20] <jnthn> pmichaud: Oh, OK - I'll wait then 

[20:20] <jnthn> :-)

[20:20] <pmurias> sorear: niecza goes directly from VAST to CIL?

[20:20] <moritz_> at least the merge is conflict free

[20:20] <moritz_> no idea if the result makes sense...

[20:21] <pmichaud> I get a conflict in Signature.pm

[20:21] <lue> rakudo: my $a = 3; say $a.HOW.WHAT

[20:21] <p6eval> rakudo edade8: OUTPUT«ClassHOW()␤»

[20:22] <tylercurtis> rakudo: use MONKEY_TYPING; augment class Int { method kilo { self * 1000; } } say 5.kilo; say 5.kilo.kilo;

[20:22] <p6eval> rakudo edade8: OUTPUT«===SORRY!===␤Confused at line 11, near "augment cl"␤»

[20:23] <tylercurtis> rakudo: use MONKEY_TYPING; augment class Int { method kilo { self * 1000; } }; say 5.kilo; say 5.kilo.kilo;

[20:23] <p6eval> rakudo edade8: OUTPUT«5000␤Method 'kilo' not found for invocant of class 'Integer'␤  in main program body at line 11:/tmp/xef2uQmjw9␤»

[20:23] <lue> what is MONKEY_TYPING?

[20:23] <pmichaud> augmenting built-in-types after the setting is loaded doesn't get the methods to Parrot native types.

[20:23] <pmichaud> rakudo:  say PARROT(5);

[20:23] <p6eval> rakudo edade8: OUTPUT«Int␤»

[20:23] <pmichaud> but that shouldn't matter here, I guess. 

[20:24] <pmichaud> afk for a moment

[20:24] <tylercurtis> rakudo: use MONKEY_TYPING; augment class Int { method kilo { self * 1000; } }; say 5.WHAT; say 5.kilo.WHAT; say 5.WHAT =:= 5.kilo.WHAT;

[20:24] <p6eval> rakudo edade8: OUTPUT«Int()␤Int()␤1␤»

[20:24] <sorear> pmurias: no

[20:25] <jnthn> pmichaud: Yes, but that can cause us issues in other places

[20:25] <pmichaud> rakudo:  use MONKEY_TYPING; augment class Int { method kilo { self * 1000; } };  say PARROT(5.kilo);

[20:25] <p6eval> rakudo edade8: OUTPUT«Integer␤»

[20:25] <pmichaud> there ya go.

[20:25] <sorear> pmurias: niecza doesn't use VAST at all; it has a custom set of action methods which are called instead of the VAST-builting ones

[20:26] <moritz_> when I merge master into llsig, rakudo builds, but loading Test.pm blows up horribly (with IMCC syntax errors)

[20:26] <pmichaud> I had to fix some stuff in Signature.pm

[20:26] <tylercurtis> lue: You have to "use MONKEY_TYPING;" if you want to augment/supersede global classes.

[20:26] <pmichaud> there may be more.

[20:26] <tylercurtis> See http://perlcabal.org/syn/S12.html#Open_vs_Closed_Classes

[20:27] <lue> ah, thank you.

[20:27] <sorear> pmurias: these action methods build a compiler-specific syntax tree; I use action methods because VAST has lousy support for scope handling

[20:27] <pmichaud> afk, short errand.

[20:27] * moritz_ goes to bed

[20:27] <sorear> by running at compile time I have full access to STD's scope control functions and variables

[20:28] <lue> goodnight mortiz_ o/

[20:28] <sorear> pmurias: the syntax tree (no name yet, but built from Unit, Body, and Op objects) is then walked to produce something kind of like CIL

[20:28] * moritz_ wonders if the order of 'i' and 't' in his name is *really* so hard to rememeber or type

[20:30] <sorear> pmurias: 'CodeGen' provides a bunch of higher level functions which act to produce CIL with proper closure handling, also, convenient shortcuts for a lot of Niecza metamodel operations

[20:30] <sorear> pmurias: 'NIL' is a concrete representation of the CodeGen API

[20:31] <sorear> pmurias: for debugging CodeGen is currently set to generate C#, not CIL directly

[20:31] <pmichaud> moritz_: I always get ti wrong.  :-)

[20:32] <pmichaud> (sigh, git merge conflicts happen so rarely that I always forget what to do to resolve them. :-)

[20:33] <lue> gah! I thought I typed it right. Feel free to blame either fast typing or backwards key response time.

[20:33] <tylercurtis> By the way, pmichaud, here are two relevant RT tickets: http://rt.perl.org/rt3/Public/Bug/Display.html?id=75114 and http://rt.perl.org/rt3/Public/Bug/Display.html?id=76104

[20:33] <pmichaud> okay, pushed merged trunk to llsig

[20:33] <pmichaud> jnthn: ^^^

[20:34] * tylercurtis is now off to a familial event.

[20:34] <pmichaud> the fact that Hash can't be augmented is because it's not really a class (yet)

[20:34] <pmichaud> I'm thinking it probably wants to be one.

[20:35] <pmichaud> I'm not sure how I feel about augmenting Int.

[20:36] *** skangas joined
[20:37] <sorear> I thought Hash was a role

[20:37] <pmichaud> it is a Role, currently.

[20:38] <tylercurtis> Augmenting Int kinda works.

[20:38] <pmichaud> it will work until you run into an Int that is in fact a Parrot Integer and not a Rakudo Int

[20:38] <pmichaud> then the Parrot Integer doesn't know about the augmented methods

[20:38] <tylercurtis> Anyway, as I was saying, off to a familial event. Bye!

[20:39] <pmichaud> bye, tylercurtis 

[20:39] *** tylercurtis left
[20:43] <lue> on S32-trig/sech.t right now...

[20:43] <Tene> fwiw, I really hate monkey patching bullshittery.  I don't really have anything positive to contribute here, just wanted to nonspecifically complain.

[20:44] <pmichaud> in the llsig branch, there's now a "make quicktest" target that skips the long-running tests

[20:44] <pmichaud> (like the trig tests)

[20:45] <lue> I'd like to post the results of the spectest, incase anyone knows when something's more broken. That's the only reason I'm suffering myself :)

[20:48] <sorear> augment is fine when it's being used like a C# "partial class Foo { ... } partial class Foo { ... }"

[20:49] <sorear> rakudo and niecza both use augment in that capacity, to mix low-level and high-level code in a single class

[20:50] <jnthn> pmichaud: Did you merge?

[20:50] <pmichaud> jnthn: yes.

[20:51] <pmichaud> I'm pretty sure I pushed, too.

[20:51] <jnthn> pulled, trying make again :-)

[20:51] <pmichaud> 

[20:51] <pmichaud> wait, I have one more change.

[20:51] <pmichaud> pushed.

[20:51] * jnthn aborts

[20:52] <jnthn> thanks, got it

[20:53] *** Su-Shee left
[20:53] <jnthn> pmichaud: 

[20:54] <jnthn> block_code vs block_closure?

[20:54] <pmichaud> block_code returns the static code object

[20:54] <jnthn> Also, Perl6::Actions::block_ref?

[20:54] <pmichaud> block_closure returns a closure

[20:54] <pmichaud> blockref returns a PAST::Val node that references the block (to prevent generating it again)

[20:56] <pmichaud> there are still a few things that need cleaning up, yes.

[20:56] <ingy> greetings

[20:56] <jnthn> yay I has a build

[20:56] <pmichaud> the old  create_code_object  essentially does the same as block_closure

[20:57] <jnthn> OK, I think I follow them :-)

[20:57] <pmichaud> yeah.  essentially, block_code says "give me the Code object for the static, compile-time version of the block"

[20:57] <ingy> TimToady: as a new P6 dev, is there a good place to list my annoyances with the language? :D

[20:57] <pmichaud> ingy: perl6-language

[20:58] <ingy> a mailing list?

[20:58] <PerlJam> good afternoon #perl6

[20:58] <pmichaud> block_closure says "give me a Code object that captures the current lexical state"

[20:58] <ingy> not in this lifetime ;)

[20:58] <pmichaud> ingy: then you can complain here, I guess.

[20:59] <jnthn> pmichaud: http://gist.github.com/463718 is still your most golfed version of the bug?

[20:59] <ingy> AotD (Annoyance of the Day): error messages with a line # but no file name.

[20:59] <pmichaud> jnthn: yes.

[20:59] <PerlJam> ingy: that sounds more like an implementation annoyance than a language annoyance

[20:59] <pmichaud> ingy: that sounds like an annoyance with Rakudo, not with the language.  :)

[20:59] <jnthn> pmichaud: OK, let's golf further. :-)

[20:59] <ingy> :D

[21:00] <ingy> so I am a rakudo dev?

[21:00] <pmichaud> just keep in mind that "Rakudo" and "Perl 6" are separate things.  :)

[21:00] <jnthn> pmichaud: oh, weird

[21:00] <pmichaud> Rakudo is an implementation of Perl 6.  It's not a reference implementation of Perl 6.

[21:00] <jnthn> sub foo($param) of Num { }

[21:00] <jnthn> say &foo.returns;

[21:00] <jnthn> pmichaud: That works.

[21:01] <pmichaud> jnthn: yes, I think it's a problem in the method initialization code.

[21:01] <lue> spectest results: http://gist.github.com/463757 I don't think anything went wrong though.

[21:01] <lue> (posting patch in a second)

[21:01] <ingy> just keep in mind that I'm a P6 customer trying to do actual good work :)

[21:01] <pmichaud> lue: the arith.t failure is the only one I don't recognize.

[21:01] <ingy> anyway, I got you.

[21:02] *** plobsing joined
[21:02] <pmichaud> ingy: just keep in mind that we're highly paid^W^W volunteers for this.  :-)

[21:02] <jnthn> pmichaud: oh nasty

[21:02] <jnthn> pmichaud: Add "my" before the class

[21:02] <ingy> pmichaud: I am we too :P

[21:02] <jnthn> To make it a lexical class.

[21:03] <pmichaud> oh, it works there.

[21:03] <ingy> I'm trying to get a few ggod modules prepped for the upcoming release

[21:03] <jnthn> pmichaud: Right.

[21:03] <pmichaud> jnthn: so, what distinguishes a lexicalclass from others?

[21:04] <pmichaud> I suspect something needs to be closured or coded that isn't now.

[21:04] <jnthn> pmichaud: our classes get their metaclass stuff run from within a :load :init

[21:04] <jnthn> (the actually thing isn't :load :init itself, but it's called from one)

[21:04] <pmichaud> sure, that makes sense.

[21:04] <jnthn> I'll bet that's at the heart of the problem.

[21:05] <jnthn> lemme check one more thing

[21:06] <jnthn> pmichaud: OK, here's probably what's significant between the two.

[21:06] <jnthn> The trait mod is set up in a :load :init

[21:07] <jnthn> In the "our" case the code that builds the metaclass also runs from a :load :init but *before* the :load :init that sets up the traits.

[21:07] <jnthn> In the "my" case it's the other way around - because we don't do the metaclass building at :load :init time

[21:08] <jnthn> (rightly or wrongly...)

[21:08] <jnthn> $P70 = $P67."!get_code"($P68, $P69)

[21:08] <jnthn> set trait_subject, $P70

[21:08] <ingy> I just skimmed S16 and S32 IO. Is there an easy way to read a file's contents into a string variable?

[21:08] <jnthn> slurp

[21:08] <pmichaud> ingy: my $contents = 'file'.slurp;

[21:08] <jnthn> my $stuff = slurp('file.txt.');

[21:09] *** supernovus joined
[21:09] <ingy> k, thx

[21:09] <ingy> is all this simple stuff in a tutorial?

[21:09] <pmichaud> maybe the book?

[21:09] <ingy> url?

[21:09] <pmichaud> http://github.com/perl6/book/

[21:09] <pmichaud> also perl6.org :-)

[21:11] <lue> hrm, I can't remember how to make a darn patch :/

[21:11] <jnthn> pmichaud: The traits certainly want to be applied to the static thing - which I guess they are being above?

[21:11] <PerlJam> ingy: what are you making?

[21:11] <pmichaud> yes.

[21:11] <pmichaud> get_code is always the static thing.

[21:11] <jnthn>    $P68 = $P65."!get_closure"($P66, $P67, 0)

[21:11] <jnthn>    meta."add_method"(obj, "foo", $P68)

[21:11] <pmichaud> get_closure always builds its Code capture object by cloning the static Code object

[21:11] <jnthn> Ah

[21:12] <jnthn> OK, so the problem is that ATM we're running that !get_closure and doing add_method before we run the !get_code

[21:12] <jnthn> (in the trait application)

[21:12] <pmichaud> is there a reason why class initialization occurs early there?

[21:12] <jnthn> iiuc, somehow we need to stop that

[21:13] <jnthn> Mostly because the :load :init for the enclosing block is what calls the class init.

[21:13] <pmichaud> I think class init likely needs two parts

[21:13] <jnthn> Well, that's the direct reason anyway

[21:13] <pmichaud> one part for creating the class

[21:13] <pmichaud> another part for composing it

[21:13] <jnthn> Where would adding the methods come?

[21:13] <jnthn> Because that's the significant part.

[21:13] <pmichaud> in the composing part

[21:14] <jnthn> oK

[21:14] <jnthn> Well

[21:14] <jnthn> Those are all just method calls on the metaclass

[21:14] <pmichaud> I think we need it that the methods get added after their static parts have been initialized

[21:14] <pmichaud> or....

[21:14] <pmichaud> perhaps the class really wants to be getting the static method objects

[21:14] <jnthn> I guess that's what it gets today.

[21:14] <pmichaud> right now it's getting closures

[21:15] <pmichaud>     $P72 = $P69."!get_closure"($P70, $P71, 0)

[21:15] <pmichaud>     meta."add_method"(obj, "foo", $P72)

[21:15] <jnthn> Sorry

[21:15] <jnthn> s/today/in master/

[21:15] <pmichaud> oh, you meant in m.... right

[21:15] <pmichaud> right, master only has static code objects

[21:15] <jnthn> Right, but if giving those to the methods works...

[21:15] <pmichaud> (which it then clones in response to 'clone')

[21:15] <jnthn> OTOH roles probably need to closure one

[21:15] <pmichaud> let me see if I can get a static code object to work.

[21:15] <jnthn> Anonymous classes...hazy. ;-)

[21:16] *** supernovus left
[21:16] <pmichaud> a-ha

[21:17] <pmichaud> looking

[21:18] <pmichaud>             :name('add_method'),

[21:18] <pmichaud>             $meta_reg, $obj_reg, ~$_, %methods{~$_}<code_ref>

[21:18] <pmichaud> (in Package.pm)

[21:18] <lue> I got git commit, but I can't seem to create the actual patch :/ ....

[21:18] <pmichaud> I've switched that so that <code_ref>  is now the static code object instead of a closure

[21:19] <sorear> lue: missing the command?

[21:19] <lue> yeah, I don't know what to type next.

[21:19] <sorear> git format-patch -1

[21:19] <jnthn> pmichaud: :-)

[21:19] <jnthn> pmichaud: Looks like you found the important bit

[21:20] <lue> ah, I forgot the -1.

[21:20] <pmichaud> well, I think I might have had it as a closure because of something in roles.

[21:20] <jnthn> pmichaud: At the moment Package.pm and Role.pm have too much dupe

[21:20] <pmichaud> so, fixing that might break something else.  We'll see.

[21:20] *** timbunce left
[21:20] <pmichaud> jnthn: and there's now a lot of duplication with "our sub" handling as well.

[21:20] <jnthn> But it does mean you can tweak them to emit methods differently for roles and classes

[21:21] <jnthn> I plan to refactor that lots to be neater

[21:21] <pmichaud> I noticed that install_method now looks a whole lot like what I put in place for our subs.

[21:21] <jnthn> I dates back to when I was first playing with metamodel stuff in ng... :-)

[21:21] <jnthn> *It

[21:21] <pmichaud> Num()Num()

[21:21] <pmichaud> \o/

[21:22] <pmichaud> ...and now t/spec/S12-introspection/methods.t fails only 5 tests instead of 44.

[21:22] <pmichaud> (because it doesn't abort on the 6th test)

[21:22] <pmichaud> cool

[21:22] <pmichaud> I'll do a "make quicktest" to be sure nothing else broke, then look at those.

[21:22] <pmichaud> jnthn++

[21:23] <pmichaud> afk for a moment

[21:24] <jnthn> kk

[21:26] *** timbunce joined
[21:26] <lue> http://gist.github.com/463775    binding patch!

[21:31] <lue> afk

[21:34] <ingy> pmichaud: did you write Test.pm?

[21:36] <sorear> ingy: Test.pm is taken from pugs

[21:36] <sorear> it was probably written by audreyt half a decade ago

[21:36] <ingy> pmichaud: I'm writing a test framework around it, and I can't seem to call Test::plan() (or whatever function) directly

[21:36] <ingy> rakudo: say 42

[21:36] <p6eval> rakudo edade8: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[21:37] <ingy> rakudo: use Test; Test::plan(42);

[21:37] <p6eval> rakudo edade8: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[21:38] <jnthn> ingy: use Test; to import the test subs into your scope

[21:38] <jnthn> ingy: or import Test if it's already use'd.

[21:38] <jnthn> ingy: Subs are lexically scoped by default

[21:38] <jnthn> So unless they are marked "our" you can't actually get at them through the namespace.

[21:38] <jnthn> phenny: tell lue patch looks quite sane; I suspect that wob of Q:PIR may be expressable as just pir::copy__pp($target, pir::new__ppp('ObjectRef', $source))

[21:38] <phenny> jnthn: I'll pass that on when lue is around.

[21:39] <jnthn> lue: d'oh...pir::copy__vvpp($target, pir::new__ppp('ObjectRef', $source))

[21:39] <jnthn> phennty: tell lue d'oh, I meant... pir::copy__vvpp($target, pir::new__ppp('ObjectRef', $source))

[21:39] <jnthn> phenny: tell lue d'oh, I meant... pir::copy__vvpp($target, pir::new__ppp('ObjectRef', $source))

[21:39] <phenny> jnthn: I'll pass that on when lue is around.

[21:39] <jnthn> fail

[21:40] <jnthn> phenny: tell lue oh, and you'll need a final $target to make that the return value

[21:40] <phenny> jnthn: I'll pass that on when lue is around.

[21:41] <ingy> jnthn: I really didn't want to import the test functions. I want to extend Test.pm, but it seems unextendable.

[21:41] <ingy> I really wanted a Test::Builder ala P5

[21:41] <ingy> but that don't exist

[21:41] <pmurias> sorear: have you looked at how mildew works?

[21:41] <pmurias> s/works/is designed/

[21:42] <pmichaud> jnthn: okay, after switching the code to use a static code object, that section passes, but now lots of other tests fail

[21:42] <ingy> well fuck it. I'll try importing for now, and doing it right some other time

[21:42] <pmichaud> ingy: the point of the current Test.pm is to be fairly simplistic.

[21:42] <pmichaud> i.e., we wanted something that fledgling Perl 6 implementations can use even if they don't have all Perl 6 features present

[21:43] <pmichaud> so, creating a class-based Test framework significantly raises the bar for many new P6 implementations

[21:43] <sorear> pmurias: not long

[21:43] <pugssvn> r31546 | pmurias++ | [CursorBase] do the Storable hack in one more place 

[21:43] <pmichaud> jnthn: I think that %methods{$_}<code_ref>  may be too simplistic for the various cases in which it is used.

[21:43] <ingy> pmichaud: but isn't it written in PIR?

[21:44] <pmichaud> ingy: Test.pm?

[21:44] <pmurias> would i'm thinking about is if it would be feasible to merge nieczas and mildew

[21:44] <ingy> what is Test.pir?

[21:44] <pmichaud> that's the post-compiled version of Test.pm

[21:44] <pmichaud> the original source is Test.pm

[21:44] <ingy> I see

[21:44] <jnthn> pmichaud: Maybe

[21:44] *** dju left
[21:44] <jnthn> pmichaud: It was written ont he assumptiong that Perl6::Compiler::Role could emit code to clone it to handle the closure case

[21:45] <timbunce> S14 says "A role may not inherit from a class, but may be composed of other roles." but doesn't give an example. Is it just "role r does X does Y { ... }"?

[21:45] *** dju joined
[21:45] <jnthn> pmichaud: Not that there'd be different methods to call

[21:45] <ingy> pmichaud: I think it would be easy to do a few things to Test.pm that make it extendable, without sacrificing your simplicity

[21:45] <pmichaud> jnthn: I'm thinking that maybe <code_ref> needs to be <block>, and then P::C::* can code or closure it as appropriate.

[21:45] <jnthn> timbunce: Yes

[21:45] <jnthn> pmichaud: That also works.

[21:45] <PerlJam> jnthn, pmichaud: Will a fix for RT#74078 fall out of the some of the recent changes, or is something more required?

[21:45] <pmichaud> ingy:  I'll be happy to consider patches.  :)

[21:45] <jnthn> PerlJam: Not sure yet.

[21:45] <timbunce> jnthn: thanks

[21:45] <pmichaud> PerlJam: I think so, yes.

[21:45] <jnthn> PerlJam: I hope so.

[21:46] <ingy> pmichaud: commit bit? :)

[21:46] <jnthn> I'll believe it when we have it. 

[21:46] <pmichaud> ingy: for a rakudo commit bit, we need a CLA.

[21:46] <jnthn> <== project pessimist

[21:46] <jnthn> ;-)

[21:46] <ingy> pmichaud:  I sent it in but it was returned by the postal service

[21:47] <jnthn> pmichaud: Well, maybe

[21:47] *** mberends joined
[21:47] <ingy> pmichaud: what's your address? I'll send it to you

[21:47] <jnthn> pmichaud: Only if the other needed stuff is available, if any...

[21:47] <sorear> ingy: you can also e-mail scanned CLAs

[21:47] <jnthn> Guess it could be made to work anyway.

[21:48] <pmichaud> jnthn: I think it can work.

[21:48] <jnthn> mberends: o/

[21:48] <pmichaud> there aren't that many places that code_ref is used.

[21:48] <jnthn> No :-)

[21:48] <jnthn> That's the way it's meant to be. :-)

[21:48] <pmichaud> right

[21:48] * sorear tries to figure out how this is at all secure; I can copy-and-paste rectangular areas of B&W images and no-one will ever notice

[21:48] <ingy> sorear: I think I have a scanner. where do I email to?

[21:48] <pmichaud> ingy: you can email to me

[21:48] <pmichaud> [email@hidden.address]
[21:49] <pmichaud> or look at the address in the README file

[21:49] <mberends> o/ jnthn # from Ireland, with two Guiness under the belt. And free Wifi. Dublin++

[21:50] <sorear> Please complete and send a PDF of the signed CLA to [email@hidden.address] or fax a copy of the

[21:50] <sorear> signed CLA to +1-206-299-3492, or send an original signed CLA to:

[21:50] <pmichaud> it still says parrot.org?!?

[21:50] <jnthn> mberends: Nice!

[21:50] *** timbunce left
[21:50] <sorear> pmichaud: what should it say?

[21:50] <jnthn> mberends: With masak++ I found a pizzeria nearby with Starobrno today \o/

[21:51] <sorear> I'm looking at the CLA PDF from parrot.org...

[21:51] <sorear> did rakudo get its own CLA in the last month?

[21:51] <jnthn> mberends: Glad we've both had beer win days

[21:51] <mberends> jnthn: Starobrnno++ as well :-)

[21:51] <pmichaud> rakudo has always had its own CLA

[21:51] <pmichaud> it's Parrot that changed.

[21:52] *** rv2733 joined
[21:52] <pmichaud> i.e., rakudo's cla is an agreement with TPF

[21:54] <pmurias> ingy: ping

[21:54] <pmichaud> http://www.perlfoundation.org/attachment/legal/cla.pdf

[21:54] *** rgrau_ joined
[21:54] <dalek> niecza: 15a77fd | sorear++ |  (3 files):

[21:54] <dalek> niecza: Implement infix operators (harder than it sounded)

[21:54] <dalek> niecza: review: http://github.com/sorear/niecza/commit/15a77fdcaee8e4442f3c8adeb88d911bba2f867b

[21:55] <pmichaud> it's no longer the same CLA that Parrot uses.  When Parrot split off from the rakudo repo ;-)  they grandfathered in the existing TPF CLA holders.

[21:55] <pmichaud> at least for a short while, until people could complete new Parrot Foundation CLAs

[21:55] <pmurias> ingy: is it possible that YAML::XS is returning broken hashes that behave strangely when changed?

[21:56] <pmichaud> jnthn: okay, so why is it that classes want to have code objects while roles want closure objects?

[21:56] <jnthn> pmichaud: Well...

[21:56] <pmurias> found that bug https://rt.cpan.org/Public/Bug/Display.html?id=53278

[21:56] <jnthn> pmichaud: We're kinda working around initialization order in a sense here

[21:57] <pmichaud> I should rephrase my question the other way round then

[21:57] <jnthn> pmichaud: But the answer really is that a class will always be, well, a class.

[21:57] <pmichaud> why is it that roles want closure objects?

[21:57] <jnthn> When you write role Foo { } you aren't really declaring a role under the hood

[21:57] <jnthn> You're declaring a role factoring

[21:57] <jnthn> In this case it can just make the one role but role Foo[::T] { } can make many

[21:58] <jnthn> We don't actually make a role until we need one though

[21:58] <jnthn> That is, until something does the role

[21:58] <jnthn> We could still hit the problem anyway though

[21:58] <jnthn> So...we probably need to fathom the init order bug really.

[21:58] <jnthn> :(

[21:59] <jnthn> And then just give both closures

[21:59] <pmichaud> okay.

[21:59] <pmichaud> actually, I think we want the other way around.

[21:59] <jnthn> Otherwise we're only putting off the bug until later

[21:59] <pmichaud> it's trivial to create a closure from a code object

[21:59] <pmichaud> it's less easy (but still doable) to go the other way

[21:59] <jnthn> Well

[21:59] <jnthn> Unless we give both the static one

[21:59] <jnthn> And the role thingy does the closure-izing.

[22:00] <pmichaud> right

[22:00] <jnthn> That'd also work and it's what happens today

[22:00] <pmichaud> I think I'm going to do that.

[22:00] <jnthn> (the clone in Role.pm is explicit, iirc)

[22:00] <pmichaud> it was, I took it out (it was causing failz)

[22:00] <pmichaud> but I can put it back in now.

[22:00] <pugssvn> r31547 | pmurias++ | [CursorBase] it turned out YAML::XS is broken - work around that 

[22:00] <pmichaud> basically,  method clone() { $!do."!get_closure"() }

[22:00] <jnthn> Dunno if clone is quite what you want  in the new model but maybe :-)

[22:00] <jnthn> oh

[22:01] <jnthn> in that case yes :-)

[22:01] <mberends> jnthn: pivo.jnthn.net already has Dublin and Guinness: "Liquid loaf of bread. Mmmm". Someone was quicker than me :-/  Just had the same in a boat-restaurant moored on the Liffey. Tomorrow after $work I'll have to experience a more original entry :)

[22:01] <pmichaud> (the other reason I wanted things to be attached to the actual subs :-)

[22:01] *** rv2733 left
[22:01] <jnthn> mberends: :-)

[22:02] * jnthn has managed to turn the Perl 6 community into a beer research team o/

[22:02] <jnthn> ooh, the map is starting to get interesting :-D

[22:03] <mberends> the data gathering is even more fun than submitting it :)

[22:04] <jnthn> The problem is remembering to submit the data after gathering it. ;-)

[22:04] <jnthn> bwaha

[22:04] <jnthn> "Baltika

[22:04] <jnthn> Fine but number 7 tastes like sweetcorn"

[22:05] <mberends> :)

[22:05] *** zorgnax joined
[22:06] <jnthn> .oO( wonder when I can re-do travel.jnthn.net in Perl 6 :-) )

[22:07] <mberends> btw, booked an excellent flight Eindhoven <-> Pisa. I'll be at yapc::eu 2-8 August, with @family too :-)

[22:07] <jnthn> ooh, flight

[22:07] <jnthn> I should remember to do that

[22:07] <jnthn> oh unless...

[22:08] *** Ross left
[22:08] <pmichaud> 22:07 <jnthn> ooh, flight

[22:08] <pmichaud> oops, wrong line

[22:08] <sorear> There are enough unpleasant corner cases here that I'm inclined to disallow augment methods from closing over variant lexical scopes

[22:08] <sorear> i.e. augment scopes like a BEGIN

[22:08] <sorear> always sees the protopad

[22:09] <pmichaud> http://maps.google.com/maps/ms?ie=UTF8&hl=en&msa=0&msid=104134443426251355747.000487e6dbeb43ace2209&z=2&iwloc=000487e72726060944e49  # my travels map

[22:09] <jnthn> pmichaud: WHOA!

[22:09] <jnthn> pmichaud: You've had more years than me to work on yours though. :-P

[22:10] <pmichaud> jnthn: true, but I also didn't really start travelling until I was in my late 20s

[22:10] <jnthn> Ah

[22:10] <jnthn> Ooh, you never went to Sweden.

[22:11] <pmichaud> correct, not been to .se yet

[22:11] <pmichaud> and these just list places that were specific target destinations, not generally "places I happened to be while in transit"

[22:11] <pmichaud> so, even though I've been to London airports many times, London isn't listed :)

[22:12] <pmichaud> (same goes for Amsterdam and Frankfurt)

[22:12] <pmichaud> I'm looking forward to adding more markers in the next few weeks :)

[22:12] <jnthn> Aye, if I did mine that way I could list two locations in Texas too. :-)

[22:13] <jnthn> (I only ever connected at Texas airports.)

[22:13] <jnthn> I think it was DFW that had a bar serving Newcastle Brown Ale.

[22:13] <pmichaud> I'm disappointed I didn't get to add a Moscow pin, though.

[22:13] <jnthn> Yeah :-(

[22:14] *** silug joined
[22:14] <jnthn> Maybe we can arrange to hackathon in Moscow at next YAPC::Russia.

[22:14] <jnthn> I'll be there, masak++ is interested too.

[22:14] <pmichaud> oooh, yes.

[22:14] <jnthn> (next spring)

[22:14] <mberends> me too :)

[22:15] <pmichaud> is nordic perl workshop still on for early august?

[22:15] <jnthn> No

[22:15] <jnthn> Until I looked at your Hawaii pins, I hadn't appreciated just how far it is from mainland US

[22:16] <jnthn> pmichaud: It was too close to YAPC::Europe

[22:16] <pmichaud> yes, that's what I thought also.

[22:16] <pmichaud> I get to do that Hawaii flight again in about five days :)

[22:16] <pmichaud> (and add another pin :-)

[22:17] <jnthn> How long is it, ooc?

[22:17] <pmichaud> well, we stop over in phoenix

[22:17] <pmichaud> so, we leave here around noonish, and arrive in Maui around 5pm, and there's a 4-hour time difference

[22:17] <pmichaud> so 9 hours, I think.

[22:17] <jnthn> Uff!

[22:18] <pmichaud> with six kids. :-)

[22:18] <jnthn> ooh, I could come to YAPC::EU by train but I'd arrive Monday evening

[22:18] <jnthn> (but in time for the Tuesday)

[22:19] <jnthn> oh, no I can't

[22:19] <jnthn> sleeper train sold out

[22:19] <mberends> :(

[22:19] <jnthn> Back to the flying plan.

[22:20] <ingy> rakudo: class Foo; my $class = 'Foo'; say $class.new;

[22:20] <p6eval> rakudo edade8: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[22:20] <jnthn> mberends: I'm doing the train back, via a break in Switzerland

[22:20] <ingy> how do I do that? ^^

[22:20] <jnthn> rakudo: class Foo { }; eval('Foo').new

[22:20] <p6eval> rakudo edade8: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[22:21] <pmichaud> rakudo:  class Foo;   my $class = Foo;   say $class.new;

[22:21] <jnthn> oh

[22:21] <p6eval> rakudo edade8: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[22:21] <jnthn> eval bot is broken.

[22:21] <jnthn> Oh, like that too

[22:21] *** Ross joined
[22:21] <jnthn> I thought ingy++ specifically wanted to do it from a string

[22:21] <pmichaud> rakudo:  class Foo { };   my $class = Foo;   say $class.new;

[22:21] <p6eval> rakudo edade8: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[22:21] <ingy> jnthn: correct

[22:21] <pmichaud> from a string one would need to eval, I think.

[22:21] <jnthn> mberends: 8:30am flight O_O

[22:22] <mberends> jnthn: on Monday, or Tuesday?

[22:22] <jnthn> mberends: Monday

[22:22] <mberends> \o/

[22:22] <jnthn> It's to Bologna

[22:22] <jnthn> So then I'll take the train to Pisa

[22:22] <mberends> nvm, trains++

[22:22] <jnthn> There's no direct Copenhagen => Pisa iirc

[22:22] * jnthn checks

[22:23] <jnthn> Wow

[22:23] <jnthn> I can fly with 2 changes from Malmo to Pisa 

[22:24] <jnthn> It only costs £1283

[22:24] * jnthn thinks he'll stick with the Bologna plan :-)

[22:24] <szbalint> heheh. I paid 138EUR for my flight Budapest -> Pisa

[22:25] <pmichaud> so far flights from here have never been low

[22:25] <jnthn> szbalint: Yeah, the one to Bologna from here is in that region.

[22:26] <jnthn> (Too bad that from Bratislava I used to have cheap direct flights to Pisa.)

[22:26] <jnthn> Though crappy Ryanair

[22:26] <jnthn> This time I get SAS. :-)

[22:27] <jnthn> So, we hackathon on the 3rd, yes?

[22:27] <pmichaud> Yes.

[22:27] <jnthn> Excellent

[22:27] <jnthn> So I'll be there from prob mid-afternoon on the 2nd.

[22:27] <szbalint> Yeah, I'll fly wizzair, but that's the only connection from BUD to Pisa sadly...

[22:27] <pmichaud> oh wow, flights on the 3rd are seriously cheap, though.

[22:27] <jnthn> lol...wizz...

[22:28] <jnthn> pmichaud: Hm

[22:28] <jnthn> pmichaud: Thing is I can't stay around after YAPC (e.g. gotta leave on the Sat)

[22:28] <pmichaud> 3rd is too late for me anyway

[22:28] <jnthn> ah yes

[22:28] <jnthn> lag

[22:28] <pmichaud> if I depart here on the 3rd I don't arrive there until the 4th

[22:28] <jnthn> oh

[22:29] <jnthn> Then yes, suggest leaving before that ;-)

[22:29] <pmichaud> there's a cheap fare on the 29th of July, though.  :)

[22:29] <szbalint> Pisa and Firenze is fun

[22:29] <szbalint> do some touristy stuff :)

[22:30] <pmichaud> ugh, none of these flights look good.

[22:31] <jnthn> I'd lean towards spending time in Pisa rather than Florence.

[22:31] <jnthn> ;-)

[22:31] <mberends> (-;

[22:32] <pmichaud> wow, flying back on the 7th seems to be very difficult also.

[22:32] <pmichaud> maybe I should look for other nearby airports :-)

[22:33] <jnthn> pmichaud: To Pisa?

[22:33] <pmichaud> yeah.  

[22:33] <jnthn> pmichaud: Yeah, trouble is the airport is mainly, afaict, served by European budget airlines

[22:33] <pmichaud> right.

[22:34] <jnthn> Florence and Bologna are near.

[22:34] <jnthn> Well

[22:34] <jnthn> Near-ish.

[22:34] <szbalint> yeah, 1.5h by train

[22:34] <szbalint> nothing terrible

[22:34] <jnthn> mberends: Booked mine to Bologna now \o/

[22:34] <pmichaud> 1.5h by train is definitely better than overnight in London

[22:34] <jnthn> It's Italy, the train is probably retardo ;-)

[22:34] <jnthn> But yes, for sure. :-)

[22:35] <mberends> jnthn: \o/

[22:35] <jnthn> mberends: Probably I'll be in Pisa by around 2pm

[22:36] *** patrickas left
[22:38] <mberends> jnthn: my flight arrives PSA 13:45

[22:38] <jnthn> mberends: Staying at $venue?

[22:39] <jnthn> If so, we may even run into each other at the check-in. ;-)

[22:39] <mberends> jnthn: no, Hotel Villa Primavera about 2km away. An easy stroll.

[22:39] <jnthn> ah, ok

[22:41] <jnthn> pmichaud: BTW, sadly we seem to have got a factor of 2 or 3 slower compared to maybe a month or so ago

[22:41] <jnthn> (in master, not just your branch)

[22:41] <jnthn> According to tools/benchmark.pl

[22:42] <pmichaud> jnthn: chromatic++ noticed that as well

[22:42] <jnthn> pmichaud: Could be good to bisect.

[22:42] <jnthn> If it was one thing that did it, anyways.

[22:43] <pmichaud> I'd say it's either the list stuff or else it's something fundamental

[22:43] <pmichaud> but I think it was slow before lists.

[22:43] <jnthn> pmichaud: I'm reluctant to pin it on the lists because we have also slipped heavily on startup time

[22:43] <jnthn> And I can't imagine lists would do that to us.

[22:44] <mberends> otoh, the memory footprint on x86 is agreeably under 100MB for most test scripts. It used to be nearer 200MB.

[22:45] *** eternaleye left
[22:45] <jnthn> Taht's a good thing

[22:45] <pmichaud> chromatic++ speculated it was a lot of isa type checking again.

[22:46] <jnthn> Could be.

[22:47] <pmichaud> he and I discussed that we could take the current O(n**2) algorithm and make it O(n) if we just checked the vtable for matches.

[22:47] <jnthn> "just checked the vtable"?

[22:47] <pmichaud> matches on VTABLE_isa, that is.

[22:48] <pmichaud> currently VTABLE_isa does a VTABLE_isa call on all of the classes listed in the mro list

[22:48] <pmichaud> that ends up adding lots of redundant checks for deeply nested classes

[22:49] <pmichaud> but if we checked to see that a class has the same VTABLE_isa as the one we're currently running, we could skip calling its VTABLE_isa because we know its mro is going to be handled by the current one anyway

[22:49] *** cotto left
[22:49] <pmichaud> and that would convert what is currently O(n**2) to O(n)

[22:50] *** skids left
[22:51] <jnthn> Aha, OK

[22:54] *** rgrau_ left
[22:55] *** mberends left
[23:01] *** skids joined
[23:02] <pmichaud> argggggggh

[23:02] <pmichaud> sometimes <code_ref> is a Perl6MultiSub

[23:02] <pmichaud> and it doesn't really know how to clone its children

[23:02] <jnthn> Yes, for multi-methods

[23:02] <jnthn> Ah

[23:03] <jnthn> I guess at least you know all the candidates going into it.

[23:03] *** pmurias left
[23:04] <pmichaud> I now have a new mantra:  "cloning and copying are evil in Perl 6"

[23:05] <Tene> augment is specced as lexically-scoped, yes?

[23:05] <Tene> Or am I misremembering again?

[23:05] <pmichaud> Tene: no.

[23:06] <pmichaud> in fact, augment is specifically denying lexical scope.

[23:06] <pmichaud> augment means you're modifying the thing in-place.

[23:06] <Tene> 'k

[23:06] *** lestrrat is now known as lest_away

[23:06] <Tene> Is there a lexically-scoped way to wrap a class with a modified class?

[23:07] <pmichaud> my class New is OUTER::New { ... }

[23:07] <pmichaud> maybe.

[23:07] <jnthn> std: my class New is OUTER::New { ... }

[23:07] <p6eval> std 31547: OUTPUT«ok 00:01 111m␤»

[23:07] <pmichaud> (definitely nyi in rakudo :-)

[23:07] <jnthn> Yeah

[23:07] <Tene> 'k

[23:08] <jnthn> pmichaud: I thought multi-sub did clone its candidates.

[23:08] <pmichaud> it calls VTABLE_clone on the RPA

[23:08] <pmichaud> (the unsorted RPA)

[23:09] <pmichaud> which, of course, isn't a deep-copy clone

[23:09] <jnthn> Oh.

[23:09] <jnthn> Yeah, you're right.

[23:10] <pmichaud> so, it never did "cloning".

[23:10] <pmichaud> anyway, cloning is bad, evil.

[23:10] <pmichaud> Perl 6 has taught me the value of immutable data structures more strongly than any other situation I can think of.  

[23:12] <pmichaud> so...... crud.  :-)

[23:14] <pmichaud> so, back to my earlier question....

[23:14] <pmichaud> why is it that roles want closure objects?  1/2 ;-)

[23:16] <jnthn> If it's fine to get the static thing and clone it and that gives a closure, I expect it's fine if it has the static one. I've actually read more of the code now. :-)

[23:16] *** Ross left
[23:17] <jnthn> Or put another way

[23:17] <pmichaud> could the role variant store code objects, and then we clone them when the role gets composed into something else?

[23:17] <jnthn> I think we always want to give the closure, or we always want to give the static one.

[23:17] <pmichaud> I think we always want to give the static one.

[23:17] <jnthn> Taht's not the problem.

[23:17] <jnthn> That's too much cloning

[23:17] <pmichaud> ?

[23:17] <pmichaud> too much cloning?

[23:17] <jnthn> The times we care about it are when we generate a new variant of the role.

[23:18] <jnthn> role Foo[::T] { ... }

[23:18] <pmichaud> okay, so perhaps add_variant should do it?

[23:18] <jnthn> class A does Foo[Int] { ... } # we generate a role

[23:18] <jnthn> class A does Foo[Str] { ... } # we generate another role

[23:18] <jnthn> er, s/A/B/ there

[23:18] <jnthn> class C does Foo[Int] { ... } # we use the role we made for A

[23:18] <pmichaud> right

[23:18] <pmichaud> so, at the point that we generate a role then

[23:19] <jnthn> No

[23:19] <jnthn> (no to add_variant)

[23:19] <jnthn> add_variant is adding a multi candidate

[23:19] <pmichaud> right

[23:19] <jnthn> Not a role

[23:19] <jnthn> The place it wants to go is when we generate the new role

[23:19] *** eternaleye joined
[23:19] <pmichaud> add_variant is when we have  role  XYZ[...]    and another role XYZ[some other]

[23:19] <jnthn> Which is probably where the .^add_method

[23:19] <pmichaud> those are "variants"

[23:19] <jnthn> Correct.

[23:19] <pmichaud> okay, got that.

[23:19] <jnthn> Multi-candidates at the end of the day

[23:20] <pmichaud> then it's !select that creates an actual role (iiuc)?

[23:20] <jnthn> Right

[23:20] <pmichaud> i.e.,   Foo[Int]  is actually calling  Foo.selector(Int)

[23:20] <jnthn> Not quite that

[23:20] <jnthn> It

[23:21] <jnthn> 1) Checks if we already have a role with the parameter Int and just hands that back if so

[23:21] *** skids left
[23:21] <jnthn> 2) Otherwise, does the multi-dispatch to something which generates one and stashes it in its created list

[23:21] <jnthn> There's an $!created (or @!created) that keeps track of those

[23:21] <jnthn> If you want to think of it a bit differently, the call is memoized.

[23:22] <pmichaud> well, let's break this down into code

[23:22] <lue> ohaio o/

[23:22] <phenny> lue: 21:38Z <jnthn> tell lue patch looks quite sane; I suspect that wob of Q:PIR may be expressable as just pir::copy__pp($target, pir::new__ppp('ObjectRef', $source))

[23:22] <phenny> lue: 21:39Z <jnthn> tell lue d'oh, I meant... pir::copy__vvpp($target, pir::new__ppp('ObjectRef', $source))

[23:22] <phenny> lue: 21:40Z <jnthn> tell lue oh, and you'll need a final $target to make that the return value

[23:22] <pmichaud> we want the method to be closured at the point a role is generated

[23:22] <jnthn> pmichaud: $!selector holds a Perl6MultiSub

[23:23] <jnthn> pmichaud: Correct

[23:23] <jnthn> pmichaud: And the code that generates a role is what is emitted by src/Perl6/Compiler/Role.pm

[23:23] <jnthn> All that is in src/builtins/Role.pir is not role generations as such, it's more management and memo-ization.

[23:24] <jnthn> It's the code in the multi-candidate that we run that is building the role

[23:24] <jnthn> (through RoleHOW meta-model calls)

[23:25] <jnthn>     selector = getattribute self, '$!selector'

[23:25] <jnthn>     result = selector(pos_args :flat, name_args :flat :named)

[23:25] <pmichaud> yeah, got that already

[23:25] <jnthn> Are the key lines in src/builtins/Role.pir

[23:25] <jnthn> OK, so that calls something that'll build a role

[23:25] <pmichaud> and then the selector ends up being a function that we generate at compile time

[23:25] <pmichaud> (a multisub of functions that...)

[23:26] <jnthn> pmichaud: No, in !add_variant

[23:26] <jnthn> We generate the functions at compile time yes

[23:26] <jnthn> And emit a call to !add_variant which does push selector, variant

[23:26] <jnthn> And those functions are generated by src/Perl6/Compiler/Role.pm

[23:26] <jnthn> And have the role's signature as their signature, etc

[23:27] <jnthn> Essentially, we're just building a Perl6MultiSub of role factories

[23:28] <pmichaud> it feels like the role factory building code is fairly complex for what is described.  What's the source of the complexity?

[23:28] <jnthn> Which bit seems complex?

[23:28] <jnthn> What's in src/builtins/Role.pir?

[23:28] <pmichaud> the stuff in src/Perl6/Compiler/Role.pm

[23:28] <jnthn> Oh

[23:29] <jnthn> But that's muchly copy-paste from src/Perl6/Compiler/Package.pm

[23:29] <pmichaud> that also, then :-)

[23:29] <jnthn> That's the "I want to tidy this up" from earlier

[23:29] <jnthn> All it's doing is generating a series of calls on the metaclass

[23:29] <jnthn> But it also has some "fun" because the distinctions between our/my/anonymous

[23:29] <jnthn> *of the

[23:29] <pmichaud> sure, so why does Actions.pm need to be aware of Perl6MultiSubs ?

[23:30] <pmichaud> it feels like we could get the package / class / role to manage those

[23:30] <pmichaud> and we just provide a list of methods to be added

[23:30] <jnthn> Because Package.pm and Role.pm are ignorant of them.

[23:30] <jnthn> Yeah, but it felt to me more like doing it in Actions.pm's method_def would be a better factoring (do it in one place)

[23:31] <jnthn> At the end of the day, either of them could be made to do it.

[23:31] <jnthn> It's just the factoring I picked.

[23:31] <pmichaud> except that Actions.pm apparently doesn't have all of the knowledge about closure cloning

[23:33] <jnthn> Well, the overall principle I had been operating on is that multi-dispatch and the object model are things that needn't know anything about each other really

[23:33] <jnthn> Apart from the dispatchers need to play together a bit

[23:33] <jnthn> But that's mostly just a case of delegation.

[23:34] <jnthn> So far, once we're past the Actions, it really is just a case in [Package|Role].pm and the metamodel that it's "just throw in a Method for a Perl6MultiSub of Methods and it's just an opaque invokable thingy"

[23:34] <jnthn> *the case

[23:34] <jnthn> *or a

[23:34] <jnthn> grr

[23:35] <pmichaud> I'm brainstorming a somewhat different factoring

[23:35] <jnthn> We have to care a bit in role composition too I guess, but overall the two are not too muddled at the moment. Sadly, that may well have to change.

[23:35] <jnthn> Well

[23:35] <jnthn> Trouble is

[23:35] <jnthn> The spec went and changed

[23:35] <jnthn> :-(

[23:36] <jnthn> So after a couple of years effort of developing a good mental model of the whole thing and pushing things that way...we're down to needing to re-work a load of stuff.

[23:36] <pmichaud> what I'm thinking of is that I'd like Actions to handle making sure that someone hasn't declared multiple 'only' subs

[23:37] <jnthn> <rant>I'm deeply irritated that I thought I'd got a final call one way and after I implemented it all, it went the other.</rant>

[23:37] <pmichaud> was I the one that made that call, ooc?

[23:37] <jnthn> No

[23:37] <pmichaud> okay.

[23:38] <pmichaud> if I was (or did), then I apologize for that :)

[23:38] <jnthn> I went through how multi-method dispatch worked with TimToady and it was agreed one way

[23:38] <pmichaud> I sympathize, though -- I had the same problem with lists, iterators and arrays.  About five times over.  :-)

[23:38] <jnthn> Yeah :|

[23:38] <pmichaud> anyway, sorry, got called away for a moment

[23:39] <pmichaud> anyway, I'd like Actions to handle making sure that someone hasn't declared multiple 'only' subs

[23:39] <jnthn> Anyway, the message under this is that we *will* have to change the way things are curerntly set up somewhat

[23:39] <pmichaud> and that protos force multis, and stuff like that

[23:39] *** skids joined
[23:39] <pmichaud> but delegate a lot of the multisub creation and management to glue routines

[23:40] <pmichaud> (by series of "add whatever" calls)

[23:40] <jnthn> We could do that.

[23:40] <jnthn> Do compile-time glue routines?

[23:40] <jnthn> *To

[23:40] <pmichaud> not sure yet.

[23:40] *** f00li5h left
[23:40] *** f00li5h joined
[23:40] <pmichaud> it's still pretty nebulous in my head.

[23:41] <jnthn> ooc, is there any reason !get_code and !get_closure couldn't, at some level, be implemented on Perl6MultiSub?

[23:41] <pmichaud> but having seen what had to happen for package-scoped multisubs, and now seeing similar issues for roles/classes, it feels like the current formulation isn't quite right

[23:42] <jnthn> If you want to wrap Perl6MultiSub so it matches the approach for other code objects, I'm very fine with that.

[23:42] <pmichaud> so, '!get_code' on a Perl6MultiSub returns a multi of code objects

[23:42] <pmichaud> ?

[23:42] <pmichaud> and !get_closure' on a Perl6MultiSub returns a multi of closures?

[23:42] <jnthn> Essentially yes.

[23:42] <jnthn> So that we can then treat them no differently to other code objects

[23:42] <pmichaud> that might work.

[23:43] <jnthn> I'm quite keen to keep the "just an invokable thingy" abstraction or even extend it where we can.

[23:43] <pmichaud> yes, I fully agree with that.

[23:43] <pmichaud> it's just their construction that is posing issues.

[23:44] <jnthn> At the end of the day, even when we have the proto-in-control refactor, there's still one thing to talk about.

[23:44] <jnthn> That thing may be magical but it's still one thing that knows how to manage the dispatch.

[23:44] <pmichaud> so, what's the proto-in-control refactor?  I'm way out of date on the spec there.

[23:45] <jnthn> You know how in proto regexes, you always call the proto and then it delegates to the chosen proto-regex?

[23:45] <pmichaud> yeah

[23:45] <jnthn> Same

[23:45] <pmichaud> so, the proto is really the multisub, in effect.

[23:45] <jnthn> We always call the proto and it delegates to the chosen candidate

[23:45] <jnthn> Yeah

[23:45] <jnthn> That isn't the part I dislike fwiw.

[23:45] <jnthn> I quite like that unification.

[23:46] <jnthn> The nasty part is that for multi-methods, the proto has to go looking at the MRO to learn about the other candidates.

[23:46] <jnthn> That is, we lose our delegational model, or at least it loses a lot of its simplicity.

[23:47] <jnthn> Anyway, that's not really relevant here.

[23:47] <pmichaud> I don't quite understand "the proto has to go looking..."

[23:47] <jnthn> At the moment, in the methods table we have something we invoke to do a dispatch.

[23:48] <jnthn> And it is just a collection of candidates from that calss

[23:48] <jnthn> *class

[23:48] <jnthn> If nothing matches, we then go one step up the inheritance hierarchy and try there

[23:48] <pmichaud> oh.

[23:48] <pmichaud> I do understand then.

[23:48] <pmichaud> it really is just like protoregexes

[23:48] <jnthn> The change is that instead it should go and find other things in the inheritance hierarchy.

[23:49] <pmichaud> right, which protoregexes have to do.

[23:49] <jnthn> Yeah which I guess is why TimToady wants to unify it.

[23:49] <pmichaud> I suspect there's a slightly deeper reason than simply "make it all the same"

[23:49] <jnthn> Perhaps

[23:49] <jnthn> No matter how you look at it though, it changes a one-way delegation into a two way relationship.

[23:50] <pmichaud> but at least for protoregexes it's not all that bad -- on first invocation of the protoregex for any given class, we do the scan and cache the methods

[23:50] <jnthn> Well, nextsame is nasty under this

[23:50] <jnthn> as masak++ and I discussed today

[23:50] <jnthn> Without contortions, you'll perhaps visit the same method multiple times.

[23:51] <pmichaud> doesn't it just end up being masak++'s interpretation?

[23:51] <jnthn> If multiple visits is fine with the spec, well, great.

[23:51] <jnthn> I can't imagine that being the case though.

[23:51] <pmichaud> multiple visits?

[23:51] <jnthn> Yes

[23:51] <pmichaud> I thought masak's interpretation was just one visit of each multisub

[23:51] <jnthn> Because you nextsame through all the multi candidates the proto knows about

[23:51] <jnthn> No

[23:51] <jnthn> Well

[23:51] <jnthn> OK

[23:51] <jnthn> That's what he wants

[23:52] <jnthn> OTOH, I want a beer pump in my kitchen. :-)

[23:52] <jnthn> Doesn't mean it's easy to make it happen.

[23:52] <jnthn> :-)

[23:52] <pmichaud> but doesn't this behavior give that result?

[23:52] <jnthn> When you nextsame, you go first through all of the candidates the proto knows about

[23:52] <jnthn> When they are exhausted you go up a step in the inehritance hierarchy

[23:53] <pmichaud> I think the "go up a step" disappears in this model (more)

[23:53] <jnthn> But then the proto at that level knows about some of the methods that the level below also knows about

[23:53] <pmichaud> because the proto already knows about that.

[23:53] <pmichaud> at least, that's what happens if we follow the protoregex model

[23:54] <pmichaud> in protoregexes, it's not that the protoregex is a multi of multis

[23:54] <pmichaud> it's *the* multi

[23:54] <pmichaud> and there's one per class

[23:54] <jnthn> If we're willing to say that nextsame from an only goes walking the inheritance hierarchy since that's the dispatcher you're in, and nextsame in a multi walks the candidates known to the proto, we an go that way.

[23:54] <pmichaud> not one for each time it's defined in the class

[23:54] <pmichaud> one for each class

[23:54] *** Psyche^ joined
[23:55] <jnthn> Sure

[23:55] <jnthn> Well if the last nextsame after you run out of candidates that the proto knows about just fails rather than goes walking the inehritance hierarchy, I guess things get simpler.

[23:56] <pmichaud> since the proto should've have already grabbed all of the candidates, then yes.

[23:56] <jnthn> Yes, but what if there's an only candidate somewhere up the inheritance chain?

[23:57] <jnthn> The proto probably shoudln't incorporate that

[23:57] * pmichaud thinks

[23:57] <jnthn> But equally, a model like we're describing means you can't nextsame to it.

[23:57] <jnthn> I guess if folks have multis and onlys of the same in the same object hierarchy, you could say they're just asking for it. :-)

[23:58] <jnthn> :-)

[23:58] <pmichaud> what does "only" mean in this instance?

[23:58] *** Patterner left
[23:58] *** Psyche^ is now known as Patterner

[23:58] <jnthn> I'd seen it as "we stop our search for multi candidates when we see an only a step"

[23:58] <jnthn> s/ a step//

[23:58] <jnthn> Just like in nested lexical scopes

[23:59] <pmichaud> in nested lexical scopes, how would I get from the only sub to the one it's hiding?

[23:59] <pmichaud> I'd have to use "OUTER::", I guess.

