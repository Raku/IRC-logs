[00:00] <jnthn> I guess so

[00:01] <pmichaud> I'm having trouble distinguishing what makes an "only method" different from a multi method if it still allows inheritance.

[00:01] <pmichaud> (I agree the other interpretation doesn't make sense... so, I'm just confused)

[00:01] <isBEKaml> sorear: I got git1.6.4. Besides, I just git pulled the remote repo and didn't have the branch in my local clone of the repo. 

[00:02] <pmichaud> anyway, I agree this makes things messier in the long run.

[00:02] <jnthn> pmichaud: Well yes, there'll be a bunch of new corner cases to think out.

[00:03] <jnthn> pmichaud: Rather than the ones I've already got used to thinking about. ;-)

[00:03] <pmichaud> in the short run, we'll have to come up with a way to get closures working, and I'm not quite sure where to go from here.

[00:03] <jnthn> Right, that's the important thing.

[00:03] <jnthn> So our current blocking issue is essentially multi / closure interaction?

[00:03] <pmichaud> also, as a side note, I really have only about 3.5 days of good hacking time available before I'm gone for a little over a week.

[00:04] <pmichaud> and autoviv is blocking on closures.

[00:04] <jnthn> Or are we still struggling on methods generally?

[00:04] <pmichaud> methods, primarily.

[00:04] <pmichaud> subs seem to work about as expected.

[00:04] <jnthn> Do we have method problems beyond this traits issue?

[00:04] <pmichaud> I don't know.  I'm able to get down about 4 failing test files

[00:05] <pmichaud> but then the fixes for those cause a bunch of tests to fail.

[00:05] <jnthn> One being the method introspection one, and the other 3 being?

[00:05] <jnthn> (I'm wondering if they boil down to traits issues too)

[00:05] <pmichaud> t/spec/S06-signature/errors.rakudo                           (Wstat: 0 Tests: 9 Failed: 3)

[00:06] <pmichaud> t/spec/S12-introspection/methods.t                           (Wstat: 256 Tests: 5 Failed: 0)

[00:06] <pmichaud> t/spec/S12-methods/default-trait.t                           (Wstat: 0 Tests: 6 Failed: 1)

[00:06] <pmichaud> t/spec/S06-operator-overloading/sub.rakudo                   (Wstat: 0 Tests: 63    .local pmc curried

[00:06] <pmichaud> t/spec/S03-smartmatch/disorganized.rakudo                    (Wstat: 0 Tests: 42 Failed: 2)

[00:06] <pmichaud> those are the fails.

[00:06] <pmichaud> I'm willing to regress the smartmatch one.

[00:06] <jnthn> default-trait.t

[00:07] <jnthn> That one is certainly same cause.

[00:07] <jnthn> (as methods.t)

[00:07] <pmichaud> well, even when I get the   method of()  problem fixed  (which causes lots of other fails), methods.t still doesn't pass completely.

[00:07] <jnthn> S06-signature/errors.rakudo - check these out more - are they real fails?

[00:08] <pmichaud> building, checking.

[00:08] *** isBEKaml left
[00:08] <jnthn> pmichaud: Can you paste me the output of methods.t too - I'd like to know what else fails.

[00:08] <jnthn> oh, I have a built here

[00:08] *** cono left
[00:08] <pmichaud> I didn't apply the patch that gets past the 'of' failure because it causes so many other things to fail.

[00:09] <jnthn> Right

[00:10] <jnthn> Can you recall why we didn't have a loadinit per our class, btw?

[00:10] <jnthn> oh, that probably won't help us anyway though

[00:11] <pmichaud> not only that, but it really shouldn't matter (more)

[00:11] <pmichaud> the things that go into the classes really need to be the static code, because they're compile-time thingies.

[00:11] <jnthn> Yes, true

[00:12] <pmichaud> it's only later that they should start acting like closures.

[00:12] <pmichaud> same for roles, for similar reasons.

[00:13] <jnthn> Yes

[00:13] <pmichaud> I think I need to sit down and make sure I understand what really happens with roles

[00:14] <jnthn> pmichaud: fwiw

[00:15] <jnthn> pmichaud: S12-introspection/methods.t passes everything but .of and .returns tests

[00:15] <jnthn> With what is commited now

[00:15] <pmichaud> right

[00:16] <jnthn> You say a lot failed with the switch to static, but was it mostly looking traceable to broken roles?

[00:16] <pmichaud> mostly, I suspect.

[00:16] <pmichaud> but it was all over the place.

[00:16] <jnthn> Yes, though so are roles :-)

[00:16] <pmichaud> if you'd like to try:

[00:17] <pmichaud> change

[00:17] <pmichaud>         my $code := block_closure(blockref($past), $*METHODTYPE, $multi_flag);

[00:17] <pmichaud> to

[00:17] <pmichaud>         my $code := block_code($past, $*METHODTYPE, $multi_flag);

[00:17] <pmichaud> in Actions.pm:1250

[00:18] <pmichaud> the errors.t failures are just in the error messages

[00:18] <pmichaud> I suspect it's just a breakage in perl6multisub that isn't producing the traces correct

[00:18] <jnthn> Right, I suspected as much

[00:23] <pmichaud> could be dump_signature isn't doing the right thing.

[00:23] <jnthn> pmichaud: eek, it's getting late here

[00:23] <pmichaud> sure

[00:24] <pmichaud> and I likely need a break as well -- I've been struggling with this for too many days now :)

[00:24] <jnthn> pmichaud: I think we'd be better served with me sleeping and digging more tomorrow.

[00:24] <pmichaud> I think you're right that block_closure needs to be block_code above, and that we need to find the source of the other failures.

[00:24] <pmichaud> it just feels more correct-er that what we pass to the builders is a static code object

[00:25] <jnthn> pmichaud: However, here's some golf

[00:25] <jnthn> (this is with your change to Actions.pm applied)

[00:25] <jnthn> > role Foo[::T] { method foo { T } };

[00:25] <jnthn> Foo()

[00:25] <jnthn> > class A does Foo[Int] { }

[00:25] <jnthn> !class_init_23

[00:25] <jnthn> > class B does Foo[Str] { }

[00:25] <jnthn> !class_init_32

[00:25] <jnthn> > say A.foo

[00:25] <jnthn> Str()

[00:25] <jnthn> > say B.foo

[00:25] <jnthn> Str()

[00:25] <jnthn> say A.foo shoulda been Int()

[00:25] <pmichaud> that looks like a closure bug :-)

[00:25] <pmichaud> something isn't be closed that should be.

[00:26] <pmichaud> (which is what I'd expect since we're sending static code objects instead of closure objects)

[00:26] <pmichaud> I think the creation of a closure needs simply be moved to somewhere else.

[00:26] <pmichaud> so, before you go, double-check my understanding of roles

[00:26] <pmichaud> role XYZ[::A] {   }      does two things

[00:26] <pmichaud> 1.  It creates "XYZ" as a master, if it doesn't already exist

[00:27] <pmichaud> 2.  It creates a multisub entry for the list of possible roles in XYZ

[00:27] <pmichaud> later, if something does

[00:27] <pmichaud>     XYZ[Int]

[00:27] <pmichaud> the XYZ master looks to see if it already has something for XYZ[Int], if so -- it returns it.

[00:28] <pmichaud> If not, it then invokes its multisub of possible roles, and the winner there returns the actual role

[00:28] *** lest_away is now known as lestrrat

[00:28] <pmichaud> okay so far?

[00:28] <jnthn> I prefer to say "possible role factories" in that the multi produces and returns a role

[00:28] <jnthn> But yes, you're right so far.

[00:29] <pmichaud> okay

[00:29] <pmichaud> last question, then

[00:29] <pmichaud> when I say     class A does <role> { ... }

[00:29] <pmichaud> how/when/where do the methodsfrom <role> get composed?

[00:29] <jnthn> This is slightly involved; let me walk you through it

[00:30] <jnthn> The code generated from this looks like

[00:30] <jnthn> trait_mod:<does>($the-class-we're-building, <role>)

[00:31] <jnthn> That calls a handler in src/core/traits.pm

[00:31] <jnthn> That boils down to:

[00:31] <jnthn> $target.^add_composable($r);

[00:31] <jnthn> Where $target is the class we're building 

[00:31] <jnthn> add_composable does *not* compose the role at that point

[00:31] <jnthn> (note that it is a method on ClassHOW)

[00:32] <jnthn> It just adds it to its list of roles to compose

[00:32] <pmichaud> ...and those are in $!composees.  got it so far.

[00:32] <jnthn> It also knows when to call !select to generalize a role into is arity-0 variant (this kinda hides every role being parametric from those who don't want to think about parametric roles)

[00:32] <jnthn> OK

[00:33] <jnthn> The very last thing that happesn when we're building a class or a role is a call like

[00:33] <jnthn> $type-obj = $the-class-we're-building.^compose()

[00:33] <jnthn> It's compose that triggers the actual composition process.

[00:33] <jnthn> At this point one of two things happens if we have any composees.

[00:34] <jnthn> If we have just one composee we can compose it right into the class

[00:34] <jnthn> If we have multiple, we build a temporary role and compose all of the others into it first

[00:34] <jnthn> And then apply that one role to the class

[00:34] <jnthn> (This factoring is lifted from Moose, fwiw.)

[00:34] <PerlJam> \\\\\\\

[00:34] <jnthn> That's what all of the RoleToClassApplier and RoleToRoleApplier classes do.

[00:35] <jnthn> In fact, all that the compose method does is delegate to those

[00:35] <jnthn> Note that we do *no* cloning of methods in any of these, and afaict nor shouod we.

[00:36] <jnthn> btw

[00:36] <jnthn> http://gist.github.com/463892

[00:37] <jnthn> Your 1-line change + a 1-line changes from me and we pass the entire S12-introspection/methods.t

[00:37] <jnthn> further

[00:37] <sorear> I'm starting to really hate augment

[00:37] <jnthn> > role Foo[::T] { method foo { T } };

[00:37] <jnthn> Foo()

[00:37] <jnthn> > class A does Foo[Int] { }

[00:37] <jnthn> !class_init_23

[00:37] <jnthn> > class B does Foo[Str] { }

[00:37] <jnthn> !class_init_32

[00:37] <jnthn> > A.new.foo

[00:37] <jnthn> Int()

[00:37] <jnthn> > B.new.foo

[00:37] <jnthn> Str()

[00:38] <pmichaud> jnthn: I tried that earlier and it didn't work for me.  Perhaps I did something else I shouldn't have.

[00:38] <pmichaud> But note that there's no Code.clone currently defined.

[00:38] <pmichaud> I did define one, perhaps I shouldn't have.

[00:38] <jnthn> pmichaud: Heh, perhaps Object.clone does enough...

[00:38] <pmichaud> relying on Object.clone feels fragile to me.

[00:38] <jnthn> Me too

[00:39] <pmichaud> especially because the resulting $!do object won't have any of its properties.

[00:39] <pmichaud> (no $!llsig)

[00:39] <jnthn> not troo iirc

[00:39] <jnthn> I think actually Mu.clone preserves them.

[00:39] <pmichaud> oh.

[00:39] <jnthn> Provided it's an object that you transform_to_p6opaque'd.

[00:40] <pmichaud> I don't see anything in Mu.clone that preserves properties.

[00:40] <jnthn> See P6opaque

[00:41] <pmichaud> oh

[00:41] <pmichaud> it's in the vtable

[00:41] <jnthn> I overrode the Parrot low-level clone

[00:41] <jnthn> Right

[00:41] <jnthn> (yes, I know, I'm evil)

[00:41] <jnthn> S12-methods\default-trait.t ==> pass with this patch too

[00:42] <pmichaud>             /* If it's a sub, we need a separate hash, so copy each property over. */

[00:42] <pmichaud> still true?

[00:42] <pmichaud> my redesigned version assumes that all clones of a sub share the same prophash

[00:42] <jnthn> I think you've made it un-true then. ;-)

[00:43] <pmichaud> in fact, it's highly desirable they do, so that when _any_ sub figures out its $!llsig or other properties they all know it.  :-)

[00:43] <jnthn> oh grr, for some reason it's not running parallel spectets

[00:43] <pmichaud> yes, now you have to explicitly set TEST_JOBS=3

[00:43] <jnthn> Thought I had

[00:43] <jnthn> Not to worry

[00:43] <pmichaud> defaulting to parallel was causing people grief on systems with low memory footprints

[00:44] <jnthn> My beer isn't out yet

[00:44] <sorear> jnthn: my class Foo {}; for ^4 -> $x { my class Bar { method y { $x } }; augment class Foo is Bar { }; }; say Foo.y; # Please rate this on the insane-o-meter

[00:44] <jnthn> sorear: Rakudo is going to say NO if you add a new parent in an augment.

[00:44] <jnthn> It's very low on my priority list to fix.

[00:44] <sorear> jnthn: I'm not hacking rakudo.  I'm trying to get lexical classes right the first time in Niecza.

[00:45] <jnthn> sorear: If you declare it just too evil and I do too, we've two implementations pushing for the spec to say "no way"

[00:45] <lue> pmichaud: so me, right? :P

[00:45] <jnthn> sorear: (right first time) Wow, you have the same optimism about Perl 6 implementation I used to. ;-) ;-)

[00:45] <sorear> jnthn: Isn't infix:<does> basically adding a new parent in an augment?

[00:45] <jnthn> No

[00:46] <sorear> I've been hacking Perl 6 for about two months

[00:46] <jnthn> It's deriving a new subclass, adding the role into it, and re-blessing the object into it.

[00:46] <sorear> I thought that's what infix:<but> did

[00:46] <jnthn> No

[00:46] <jnthn> infix:<but> clones and then does infix:<does> on the clone

[00:46] <jnthn> sorear: fwiw, Rakduo's versions of both are in Perl 6

[00:47] <jnthn> src/core/operators.pm

[00:49] <sorear> jnthn: how about: my class Foo {}; for ^4 -> $x { augment class Foo { method y { $x } }; }; say Foo.y;

[00:50] <pmichaud> I'd expect a composition conflict.

[00:50] <pmichaud> i.e., multiple "method y"

[00:51] <jnthn> I think Rakudo implements my best guess at that :-)

[00:51] <pmichaud> it probably needs a supersede if you really intend to replace the method.

[00:51] <jnthn> and I think it says composition conflict

[00:51] <jnthn> Or similar

[00:52] <pmichaud> i.e.   augment class Foo { supercede method y { $x } }

[00:52] <pmichaud> (but that's just a guess on my part)

[00:52] <jnthn> pmichaud: Into S04 - only that smart-match test regressed from mater so far.

[00:52] <sorear> according to TimToady, augment statements are run at BEGIN time *only*

[00:52] <sorear> and composition for a given 'augment' happens ONCE

[00:52] <jnthn> sorear: Yeah, I backlogged over that and thought...huh. :-)

[00:52] <sorear> "this is the *whole point* of the traits paper"

[00:52] <pmichaud> sorear: in which case that augment happens only once.  :-)

[00:53] <pmichaud> and it should be just fine.

[00:53] <sorear> well, sure

[00:53] <sorear> I understand how to implement this... loosely

[00:53] <pmichaud> jnthn: the fails tended to begin in S05

[00:53] <sorear> the main issue is that a class needs one OUTER:: per point of definition

[00:53] <pmichaud> jnthn: I'm also quicktesting here.

[00:54] <sorear> allowing augments to close over stuff means that classes need multiple outers

[00:54] <sorear> which gets very confusing, especially if the outers have conflicting definitions for a single lexical

[00:55] <sorear> I'm imagining diamondy patterns where a class winds up indirectly inheriting from two different instantiations of the same lexical superclass and *head explode*

[00:55] <pmichaud> sorear: in this particular case, I'm suspecting it's similar to

[00:55] <jnthn> sorear: No, the methods just have the outer of where the augment was

[00:55] <pmichaud> for 1..4 -> $x { our sub foo() { say $x } };   BEGIN { foo() }

[00:56] <sorear> pmichaud: yes, that's my imagination too.

[00:56] <jnthn> pmichaud: S05 ain't looking problemantic for me

[00:56] <jnthn> pmichaud: Into S06 now

[00:56] <pmichaud> in that the $x that &foo sees at the time it's invoked is uninitialized and comes from the static lexpad

[00:57] <pmichaud> jnthn: yes, S05 is okay for me also.

[00:57] <sorear> pmichaud: where did you get the BEGIN from?

[00:57] <pmichaud> jnthn: so, perhaps it was my version of the clone method that was an issue.

[00:57] <sorear> I was imagining it would be for 1..4 -> $x { our sub foo() { say $x } } ; foo()  --> 4

[00:57] <pmichaud> sorear: yes, it would

[00:57] <pmichaud> but as you said (that TimToady said), augment is like a BEGIN

[00:58] *** meppl left
[00:58] <pmichaud> so, the $x that we see is the one that exists before the pointy block ever executes

[00:58] <jnthn> pmichaud: We still have the errors.t one

[00:59] <pmichaud> I still have the operator-overloading sub one

[00:59] <pmichaud> errors.t I'm sure I can fix

[00:59] <pmichaud> so far this is looking raelly good

[00:59] <pmichaud> *really

[01:00] <jnthn> Yes, operator-overlording.t one I have too

[01:00] <jnthn> it's a curious

[01:00] <pmichaud> ohhhhh

[01:00] <pmichaud> I bet I know why my earlier clone failed.

[01:00] <jnthn> pmichaud: eval fail

[01:00] <pmichaud> eval passed here.

[01:00] <jnthn> (for the sub overloading one)

[01:00] <pmichaud> S29-context/eval.t ?

[01:00] <jnthn> no no

[01:01] <pmichaud> oh, there.

[01:01] <jnthn> no

[01:01] <jnthn> t\spec\S06-operator-overloading\sub.rakudo

[01:01] <pmichaud> got it.

[01:01] <jnthn> The test that fails looks like this

[01:01] <jnthn> is eval('sub infix:<+>($a, $b) { 42 }; 5 + 5'), 42, 'infix:<+>($a, $b)';

[01:01] <jnthn> Note that taking that out of the eval works

[01:01] <jnthn> it's only when you put it in an eval that it has a fail

[01:01] <jnthn> Somethings off but I bet it's silly rather than deep.

[01:02] <jnthn> It fails with the error

[01:02] <jnthn> Can not re-declare sub &infix:<+> without declaring it multi at line 1

[01:02] <jnthn> (that's int he failure the eval returns)

[01:04] *** amkrankruleuen joined
[01:04] <amkrankruleuen> Hello!

[01:05] <pmichaud> (overloading error)  I'm willing to regress that one if it's not an easy fix.

[01:05] <pmichaud> jnthn: but yes, with your patch I think we're good-to-go for now.

[01:05] <jnthn> \o/

[01:05] <pmichaud> thank you so much for sticking with it this late :)

[01:06] <jnthn> I *really* want this branch to land. :-)

[01:06] <pmichaud> I'll apply and then work on code cleanups.

[01:06] <jnthn> And $dayjob is pretty light at the moment.

[01:06] <pmichaud> then merge the branch.

[01:06] <pmichaud> we've already merged from trunk, so shouldn't be many problems there.

[01:06] <jnthn> No, shoudln't be any troubles there.

[01:08] <jnthn> pmichaud: !!! :-D

[01:08] <jnthn> > role R { method foo() { say 42 } }; R.foo

[01:08] <jnthn> 42

[01:08] <jnthn> oh but

[01:08] <jnthn> role R { method foo() { say 42 } }; class C does R { }; C.new.foo

[01:09] <jnthn> Doesn't work

[01:09] <jnthn> Damm

[01:09] <jnthn> It's laodinit all over again.

[01:09] <jnthn> Anyway, not a regression

[01:09] <jnthn> Just not yet fixed

[01:09] <pmichaud> oh!

[01:10] <jnthn> Yeah

[01:10] <pmichaud> operator-overload probably puts &infix:<+> into the block's symbol table.

[01:10] <jnthn> Oh

[01:11] <pmichaud> and so the code things it's already been defined.

[01:11] <pmichaud> *thinks

[01:12] <jnthn> Ah!

[01:12] *** zorgnax left
[01:12] <jnthn> Anyway, those aside, I think tests are looking decent.

[01:13] <pmichaud> what part handles operator overloading?

[01:13] <jnthn> It's at the bottom of Grammar.pm, the name escapes me

[01:13] <jnthn> (we gotta do at least some of it in grammar.pm otherwise custom operators break --target=parse)

[01:14] <pmichaud> gen_op_if_needed

[01:14] <jnthn> gen_op_if_needed

[01:14] <jnthn> ah, beat me

[01:14] <jnthn> But I don't see it doing anything the @BLOCK.symbol

[01:15] <pmichaud> me neither

[01:15] <pmichaud> the only way that we get the Can not re-declar message is if the symbol already exists, though.

[01:15] <jnthn> Yes, I don't understand how it's happening 

[01:15] <jnthn> Oh

[01:16] <jnthn> Unless @BLOCK somehow contains stuff from the setting

[01:16] <pmichaud> at that point, @BLOC...... oh.  right.

[01:16] <pmichaud> it might.

[01:16] <pmichaud> because we collect up all of the lexicals.

[01:16] <pmichaud> from the outer contect

[01:16] <jnthn> pmichaud: this is very telling

[01:16] <jnthn> > eval('{ sub infix:<+>($a, $b) { 42 }; 5 + 5 }')

[01:16] <jnthn> 42

[01:16] <pmichaud> although I would've expected that to not be the current block.

[01:16] <pmichaud> right.

[01:16] <jnthn> not extra curlies

[01:16] <jnthn> *note

[01:17] <pmichaud> yes, it's because the outer_context has them already.

[01:17] <jnthn> OK, some needs fixing but not too nasty

[01:18] <pmichaud> that needs a bit of fixing anyway, to better handle the repl

[01:18] <pmichaud> but yes, not hard to fix.

[01:18] <jnthn> I won't be bothered if we regress on that one fwiw.

[01:18] <jnthn> As long as we file an RT about it.

[01:18] <jnthn> Because I doubt it'll hit the app cheese.

[01:18] <pmichaud> I'll see if I can find a better test than just "does the symbol exist"

[01:19] <jnthn> Well, I'm a bit surprised we don't end up with an extra PAST::Block layered in somewhere containing the symbols

[01:19] <jnthn> And the oen that's the main scope of the eval is one inside of that.

[01:19] <pmichaud> right.

[01:19] <sorear> jnthn: Also, I'm playing with drawing a line between protoclasses and classes

[01:19] <pmichaud> I've been thinking that there should be an extra block

[01:20] <sorear> I think I can do all non-'does' composition at compile time

[01:20] <pmichaud> also, at some point I want to switch @BLOCK from a package-scoped variable to a contextual.

[01:20] <pmichaud> so that each compilation unit has its own @*BLOCK

[01:22] <pmichaud> anyway, I think we're good on the closures branch.  Just a few things to clean up.

[01:22] <pmichaud> I need to take doggie out for a walk, so I'll bbiaw (and likely see you tomorrow)

[01:22] *** masonkramer joined
[01:23] <jnthn> pmichaud: OK, I"m going to sleep now. I'm almsot asleep already

[01:23] <jnthn> sorear: Try me on that when I'm concious. ;-)

[01:23] <jnthn> night all o/

[01:26] <diakopter> oo/

[01:42] *** TiMBuS joined
[02:09] <sorear> aaaa it only gets harder

[02:09] * sorear needs to invalidate subclasses when superclasses are modified

[02:09] <sorear> ideally without making "but" leak memory

[02:27] *** agentzh joined
[02:42] *** chee is now known as rlwrap

[02:43] *** rlwrap is now known as chee

[02:43] *** xinming left
[02:56] *** rv2733 joined
[02:58] *** aubreyja joined
[03:02] *** xinming joined
[03:02] <pugssvn> r31548 | putter++ | elf, elfparse, and elf on sbcl, are all happy again. 

[03:02] <pugssvn> r31548 | [elf_h] Fix isa/can/does.

[03:02] <pugssvn> r31548 | [elfparse] Revert r27867 halfbaked changes to std.pm.

[03:02] <pugssvn> r31548 | [on_lisp] Note SBCL 1.0.40 works, but "current" 1.0.29.11.debian doesn't.

[03:08] *** rv2733 left
[03:16] *** duzy joined
[03:18] <duzy> xinming?

[03:25] <xinming> duzy: ?

[03:25] *** aubreyja left
[03:32] *** tylercurtis joined
[03:54] *** buubot left
[03:55] <duzy> xinming: chinese?

[04:00] <xinming> duzy: yes

[04:28] *** chee left
[04:29] *** chee joined
[04:39] *** cotto joined
[04:49] *** buubot joined
[04:55] *** sorear sets mode: +vo buubot tylercurtis

[04:59] <diakopter> o_O elf updated?

[05:02] *** ashleydev joined
[05:02] *** ashleydev left
[05:14] *** christine left
[05:16] *** christine joined
[05:27] <ingy> how do I do 'next OUTER' ?

[05:28] * ingy has been RingTFMs

[05:29] <sorear> what does next OUTER mean?

[05:29] <ingy> next/last to a LABEL

[05:30] <sorear> well you can't just say OUTER

[05:30] <sorear> you need an explicit name

[05:31] <ingy> sigh

[05:31] <ingy> yes, OUTER is my label

[05:31] <sorear> oh

[05:32] <sorear> well in that case, next OUTER

[05:32] <sorear> it's the same as p5

[05:32] <ingy> seems to not compile.

[05:32] <ingy> I'll try again

[05:32] <sorear> std: OUTER: { next OUTER; }

[05:32] <p6eval> std 31548: OUTPUT«ok 00:01 111m␤»

[05:33] *** sftp_ joined
[05:34] *** sftp left
[05:37] <ingy> std: OUTER: for $x -> $y { next OUTER; }

[05:37] <p6eval> std 31548: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $x is not predeclared at /tmp/Ds6yu7yCzA line 1:␤------> [32mOUTER: for $x[33m⏏[31m -> $y { next OUTER; }[0m␤Check failed␤FAILED 00:01 114m␤»

[05:38] <ingy> std: my $x = []; OUTER: for $x -> $y { next OUTER; }

[05:38] <p6eval> std 31548: OUTPUT«ok 00:01 113m␤»

[05:40] <sorear> S04 defines OUTER.next; and next OUTER:; as acceptable variations

[05:40] <sorear> maybe rakudo parses one or the other

[05:40] <sorear> though I'm somewhat doubtful due to the way rakudo currently handles loop control operators

[05:41] *** sftp_ left
[05:41] *** sftp_ joined
[05:44] *** Su-Shee joined
[05:47] <dalek> rakudo: f0cf54e | pmichaud++ | src/Perl6/Actions.pm:

[05:47] <dalek> rakudo: Refactor handling of block references in methods.

[05:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f0cf54e9498bf73f1e893ae328d9cd9b11821620

[05:47] <dalek> rakudo: 0ba07fa | pmichaud++ |  (4 files):

[05:47] <dalek> rakudo: Refactor 'make stresstest' to draw from t/spectest.data, and eliminate 

[05:47] *** dalek left
[05:47] <ingy> sorear: what's the problem with this code (which rakudo fails to parse) http://nopaste.snit.ch/21803

[05:47] <ingy> ?

[05:47] <tylercurtis> Does Rakudo support next? I don't see it in Gramma.pm

[05:47] *** dalek joined
[05:48] <tylercurtis> s/Gramma/Grammar

[05:48] *** szabgab joined
[05:49] <spinclad> (re thidk: shouldd't the -n- in -nk- dedasalise to -gk-?)   # slowly slowly backlogging approaches RealTime

[05:51] <ingy> pmichaud: do you know? (http://nopaste.snit.ch/21803 failure)

[05:53] <PerlJam> ingy: rakudo doesn't do labels yet.

[05:54] <PerlJam> tylercurtis: yes, rakudo understands next.

[05:54] *** uniejo joined
[05:59] <sorear> ingy: rakudo doesn't support controlling any loop other than the innermost one

[05:59] <sorear> doesn't matter about parsing; Rakudo just doesn't have the internal protocols to control a distant loop

[06:01] <pugssvn> r31549 | pmichaud++ | [t/spec]:  Fudge some tests that fail in the closure branch. 

[06:09] <chee> macros.  any implementations got them going on aoy?

[06:11] <PerlJam> chee: don't think so.

[06:11] <chee> D:

[06:12] <sorear> aoy?

[06:12] <PerlJam> as of yet

[06:12] <PerlJam> (that's what I guessed)

[06:22] *** mberends joined
[06:25] *** cono joined
[06:35] <mberends> phenny, tell cxreg your MiniDBD::Pg passes 24 of the 32 common tests, you're welcome to merge when you like.

[06:35] <phenny> mberends: I'll pass that on when cxreg is around.

[06:41] <moritz_> good morning

[06:44] *** tedv left
[06:44] <moritz_> std: my $x; 5; my $x

[06:44] <p6eval> std 31549: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $x (see line 1) at /tmp/rPwNPPjQnz line 1:␤------> [32mmy $x; 5; my $x[33m⏏[31m<EOL>[0m␤ok 00:01 111m␤»

[06:49] <pugssvn> r31550 | moritz++ | [t/spec] unfudges after the "llsig" branch merge 

[06:55] <pugssvn> r31551 | moritz++ | [t/spec] test for RT #71476, invocant type constraint should be checked at method call time 

[06:56] <dalek> rakudo: b3eafbe | moritz++ | t/spectest.data:

[06:56] <dalek> rakudo: we pass the man-or-boy test again, \o/

[06:56] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b3eafbe5d4a83e0277b1809c02106f8d4c9c33c2

[06:57] *** lkk- joined
[06:59] <pugssvn> r31552 | moritz++ | [t/spec] test for RT #69654 - mixing in method with "does" should make those methods show up in introspection 

[07:03] *** timbunce joined
[07:05] *** timbunce left
[07:13] *** mberends left
[07:16] *** mberends joined
[07:28] <moritz_> rakudo: 'a' ~~ /a/; say ($/.orig).rindex('a', 1)

[07:28] <p6eval> rakudo 67ebdc:  ( no output )

[07:28] <moritz_> rakudo: 'foobar' ~~ /a/; say ($/.orig).rindex('a', 1)

[07:28] <p6eval> rakudo 67ebdc:  ( no output )

[07:31] *** Trashlord left
[07:32] *** Schwern left
[07:32] *** Trashlord joined
[07:34] <mberends> moritz_: the ",1" kills it

[07:37] *** Schwern joined
[07:59] *** tadzik joined
[08:00] *** mberends left
[08:01] <mathw> Hah

[08:01] <mathw> Problems at work with floating point numbers

[08:01] <mathw> I found myself thinking 'what we need is Perl 6's Rat type'

[08:01] <arnsholt> That's usually the solution, yeah =)

[08:03] <mathw> unfortunately, rewriting our server software in Perl 6 isn't particularly feasible at the moment

[08:04] <arnsholt> Awwww =)

[08:06] <mathw> We need a working multithreaded solution really

[08:06] <mathw> and some speed :)

[08:06] <mathw> one day, I hope, such things will be eminently possible

[08:06] <mathw> I'm sure they will

[08:10] <arnsholt> Indeed. I look forward to that day like a child to christmas =)

[08:17] *** timbunce joined
[08:20] *** plobsing left
[08:22] *** mberends joined
[08:27] *** Ross joined
[08:27] *** dakkar joined
[08:30] *** masak joined
[08:33] <masak> oh hai, #perl6!

[08:34] <masak> so, closures fixed, eh?

[08:34] <masak> pmichaud++

[08:34] <sorear> chee: check out git://github.com/sorear/rakudo.git

[08:34] <sorear> branch 'topic/macros'

[08:35] <chee> I have a sorear right now

[08:35] <sorear> it's a proof of concept hack I did about three months ago and have no intention of porting to current rakudo

[08:35] <sorear> (I think Rakudo is going to get protolexpads in about a month, which will make macroage *way* easier)

[08:35] <chee> sorear: cool :3  

[08:35] * chee cloning

[08:40] <dalek> rakudo: 5a5d7ef | pmichaud++ |  (2 files):

[08:40] <dalek> rakudo: Rename src/cheats/setup-io.pm to src/cheats/process.pm .

[08:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5a5d7ef3691ddf1db25730ef8b715d3605f41350

[08:40] <dalek> rakudo: 3312298 | pmichaud++ |  (5 files):

[08:40] <dalek> rakudo: Refactor $*IN, $*OUT, $*ERR.  Add $*PERL.  Add --version option.

[08:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/331229881a602c567b05cf75c541254c02b3dc6e

[08:40] <dalek> rakudo: 22578e8 | pmichaud++ | t/spectest.data:

[08:40] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[08:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/22578e87cf497211ba4ca1f4074dcc7677d67877

[08:41] *** timbunce left
[08:41] <sorear> $*PERL?

[08:42] <tylercurtis> "$*PERL            S02   SoftwarePackage # perl version running under"

[08:42] <masak> S02: 'Which Perl I'm running under"

[08:42] <masak> guess that means "which version".

[08:43] <sorear> Er. Right.

[08:43] <sorear> Stupid juxtaposition made me think it was a filehandle.

[08:46] *** thebird joined
[08:49] *** charsbar_ joined
[08:49] *** charsbar left
[08:51] <pmichaud> rakudo:  say $*PERL;  # probably 'not yet'

[08:51] <p6eval> rakudo b3eafb: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;Perl6Role;!select' pc 11403 (src/gen/RoleToClassApplier.pir:591)␤... call repeated 1 times␤»

[08:51] <pmichaud> p6eval still broke?

[08:51] <tylercurtis> rakudo: say 5

[08:51] <p6eval> rakudo b3eafb: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;Perl6Role;!select' pc 11403 (src/gen/RoleToClassApplier.pir:591)␤... call repeated 1 times␤»

[08:51] <masak> aye :/

[08:52] *** orafu left
[08:52] <tylercurtis> It was working about an hour and a half ago.

[08:52] *** orafu joined
[08:53] <pmichaud> pmichaud@plum:~/rakudo$ ./perl6 --version

[08:53] <pmichaud> This is Rakudo Perl 6, version 2010.06-172-g22578e8

[08:53] <pmichaud> Copyright 2008-2010, The Perl Foundation

[08:54] <masak> \o/

[08:54] <masak> pmichaud++

[08:54] <pmichaud> > say $*PERL<name>

[08:54] <pmichaud> rakudo

[08:54] <pmichaud> > say $*PERL<version>

[08:54] <pmichaud> 2010.06-172-g22578e8

[08:55] <masak> is $*PERl a Hash?

[08:55] <pmichaud> it acts like one.

[08:55] <masak> s/l/L/

[08:55] <pmichaud> (yes)

[08:55] <pmichaud> because one is supposed to be able to do things like

[08:55] <pmichaud> given $*PERL {

[08:56] <pmichaud>     when :name<rakudo> :version<...> { ... }

[08:56] <pmichaud> I suppose it could be done with methods also, but using a hash seemed more straightforward for now.

[08:56] <masak> aye.

[08:56] <masak> what does the '172' mean?

[08:57] <pmichaud> 172 commits since the 2010.06 tag

[08:57] <pmichaud> (it's the output of "git describe")

[08:57] <masak> ah, nice.

[08:58] <pmichaud> not sure this will work on windows systems yet, but I figure we'll get patches soon enough.  :-)

[08:58] <masak> I should use that subcommand more to communicate which commit I'm on.

[09:00] <pmichaud> well, I think that's enough work for one day.  Actually for two days.  Actually for four.  :-(

[09:00] <mathw> pmichaud we love you!!

[09:00] <pmichaud> mathw: :-)

[09:01] <pmichaud> well, I'm glad closures are finally working.

[09:01] <mathw> But I've only got -1 minutes to get to a meeting

[09:01] *** lkk- left
[09:01] <mathw> &

[09:03] <dalek> rakudo: d9a5ac0 | pmichaud++ | src/cheats/process.pm:

[09:03] <dalek> rakudo: Change $*PERL<name> to lowercase.  Add $*VM.

[09:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d9a5ac03419aa0efb6131d89951140dd7bb3c90b

[09:04] <pmichaud> time for sleep

[09:04] <pmichaud> bbiaw

[09:04] *** TiMBuS left
[09:15] *** tylercurtis left
[09:16] *** TiMBuS joined
[09:17] *** masak left
[09:18] <sorear> Should distinct instantiations of a lexical class share a HOW?

[09:21] *** envi^home joined
[09:22] *** Ross left
[09:23] *** pmurias joined
[09:23] *** Ross joined
[09:25] <pmurias> ruoso: do you think it would make sense to switch from manipulating $LexicalPrelude to YOU_ARE_HERE?

[09:27] *** Su-Shee left
[09:28] <spinclad> now i've caught up on the backlog, i have to say:  \\\oOo///  what a marathon, what victory!  pmichaud += MANY !

[09:30] *** Trashlord left
[09:32] *** Trashlord joined
[09:35] *** pmurias left
[09:35] *** jedai_ left
[09:40] <sorear> yeah, pmichaud

[09:40] <sorear> my great rival :D

[09:46] *** chee is now known as gcheechee

[09:49] *** gcheechee is now known as chee

[09:55] <sorear> tomorrow I need to extract from jnthn a simpler workable metamodel for classes

[09:56] <sorear> my current system is totally awesome but has lots of complications, like needing weak references

[09:56] *** agentzh left
[09:59] *** whiteknight joined
[10:01] <dalek> niecza: 27fe603 | sorear++ |  (2 files):

[10:01] <dalek> niecza: Add license & credits info

[10:01] <dalek> niecza: review: http://github.com/sorear/niecza/commit/27fe603a28836d84a2f18b10c167e5cc34bfb538

[10:01] <dalek> niecza: 99cd9d8 | sorear++ | notes.pod:

[10:01] <dalek> niecza: Brief note on protoclasses

[10:01] <dalek> niecza: review: http://github.com/sorear/niecza/commit/99cd9d83394af42c98004780ce4400dcae93f15f

[10:01] <dalek> niecza: bab5e87 | sorear++ | setting:

[10:01] <dalek> niecza: A few more notes on our ClassHOW

[10:01] <dalek> niecza: review: http://github.com/sorear/niecza/commit/bab5e87128d451c0d05b14770ca2c91c74d474df

[10:02] *** tadzik left
[10:03] *** masonkramer left
[10:03] *** masonkramer_ joined
[10:03] *** masonkramer_ is now known as masonkramer

[10:08] *** masak joined
[10:09] *** lestrrat is now known as lest_away

[10:13] <masak> > our $a = 42; { say my $a; { say our $a } }

[10:13] <masak> ANy()

[10:13] <masak> 42

[10:13] <masak> 'our' seems to have a bit in common with binding.

[10:17] <hejki> rakudo: our $a = 42; { my $a = 4; say my $a; say our $a; }

[10:17] <p6eval> rakudo b3eafb: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;Perl6Role;!select' pc 11403 (src/gen/RoleToClassApplier.pir:591)␤... call repeated 1 times␤»

[10:17] *** _mpu joined
[10:17] <hejki> ;<

[10:17] <masak> p6eval busted :/

[10:17] <masak> lunch &

[10:28] *** thebird left
[10:28] *** cotto left
[10:28] *** Patterner left
[10:32] <szabgab> jnthn, are your BPW slides online somewhere?

[10:34] *** thebird joined
[10:34] *** cotto joined
[10:34] *** Patterner joined
[10:39] *** Mowah left
[10:48] *** ruoso left
[10:49] <arnsholt> Looking at the NQP code, I see there's a rule statement_mod_loop:sym<for> but no corresponding action. Bug?

[10:51] <arnsholt> Nm. Looks like not

[10:53] <bbkr> rakudo: my Hash $x; $x[1];

[10:53] <p6eval> rakudo d9a5ac: OUTPUT«No applicable candidates found to dispatch to for '_block39745'. Available candidates are:␤:()␤␤  in main program body at line 1␤»

[10:54] *** Mowah joined
[10:54] <arnsholt> bbkr: I think p6eval is broken

[10:55] <bbkr> arnsholt: seems to work, because this is unfixed bug from RT queue :)

[10:55] <bbkr> rakudo: say 0.00000000000000000000

[10:56] <p6eval> rakudo d9a5ac: OUTPUT«0␤»

[10:56] <arnsholt> Oh, goodie

[10:56] <bbkr> rakudo: say 0.00000000000000000000000000000000 # checking http://rt.perl.org/rt3/Ticket/Display.html?id=73236

[10:57] <p6eval> rakudo d9a5ac: OUTPUT«0␤»

[10:57] <bbkr> rakudo: say 0.00000000000000000000000000000000000000000000000000000000000000000000000000 # checking http://rt.perl.org/rt3/Ticket/Display.html?id=73236

[10:57] <p6eval> rakudo d9a5ac: OUTPUT«0␤»

[10:57] <bbkr> fixed :)

[10:59] *** whiteknight left
[11:08] *** Mowah left
[11:13] <masak> bbkr++

[11:17] *** timbunce joined
[11:19] <jnthn> morning 6folk :-)

[11:20] <jnthn> er, afternoon 

[11:20] <jnthn> :-)

[11:20] <jnthn> szabgab: (slides) ENOTYET

[11:20] <masak> jnthn: "morning"! :)

[11:21] <szabgab> jnthn, good <morning afternoon>.pick

[11:21] <szabgab> is your quick sort example available somewhere ?

[11:21] <masak> jnthn: my charger had a packing fail and is still on the floow beside your computer. fortunately, I still have the spare one from Riga, so there's no panic. :)

[11:23] <jnthn> szabgab: I shoved it on the Perl 6 wikipedia page at the weekend

[11:23] <jnthn> Because the previous quicksort example they had for Perl 6 was crappy and boring

[11:23] <jnthn> :-)

[11:23] <jnthn> (masak++'s suggestion)

[11:23] <jnthn> masak: FAIL!

[11:23] <szabgab> jnthn, I'll lookat it

[11:24] <masak> jnthn: yeah, don't know how that happened, really. I blame the vindaloo again.

[11:24] <szabgab> I am gong to have a Perl talk at the next Python  meeting in Tel Aviv and need some hard core ammunition :)

[11:24] <jnthn> pmichaud: Yay, closures landed!

[11:25] <masak> pmichaud++ # again

[11:25] <jnthn> pmichaud++

[11:25] <jnthn> masak: I....struggle to connect the two. :P

[11:25] <jnthn> masak: Next time you come maybe I should tell you that you're only allowed a korma? :P

[11:26] <masak> jnthn: vindaloo -> malaise -> reduced eyesight -> miss charger on floor

[11:26] <masak> jnthn: yeah, korma next time. and no cold. :)

[11:27] *** jedai joined
[11:29] *** Mowah joined
[11:30] * moritz_ back

[11:31] <masak> moritz_! \o/

[11:31] <jnthn> o/ Mowah 

[11:31] <jnthn> er

[11:32] <jnthn> o/ moritz_ 

[11:32] <jnthn> I need a DWIMmier tab key.

[11:32] * masak wonders if there'd be a language where "Mowah" could be the diminutive of "moritz_"

[11:32] <jnthn> masak: Yes, I'm hoping you didn't leave your scary northener cold here.

[11:32] <masak> jnthn: I'm hoping that, too.

[11:33] <jnthn> masak: I've very much caught up on sleep now though :-)

[11:33] <jnthn> So hopefully that'll help. :-)

[11:33] <masak> that's good. Wikipedia says there's three times the risk of infection if you sleep too little.

[11:34] <masak> I... I'm not sure what I did last night counts as "sleep" :)

[11:34] <masak> hm, that came out wrong. :P

[11:34] <masak> I mean, it was more like "sitting up, folding legs in unnatural ways, keeping eyes closed".

[11:36] <masak> if it'd been part of a sleep deprivation torture program, I'd consider it at least moderately successful. :P

[11:36] <jnthn> Oh, I thought you were implying "söt flicka på buss" :P

[11:36] <masak> yeah, I realized it could sound that way.

[11:36] <jnthn> Oh well, at least I needn't be envious. :-)

[11:37] <masak> my seat companion was a girl, actually. but there's no mile-high club for buses.

[11:37] <arnsholt> A bus a mile high would be scary...

[11:37] * jnthn has been over a mile high on a bus

[11:37] <jnthn> Well, above sea level anyway

[11:38] <masak> jnthn: there's still no club, far as I know :P

[11:39] <jnthn> I guess I'll just stick with the "sleepers beneath you club" on the railways then.

[11:39] <masak> :P

[11:41] <pugssvn> r31553 | moritz++ | [t/spec] unfudge tests for Rakudo 

[11:43] <jnthn> pmichaud: --version works right on Windows :-)

[11:43] <jnthn> This is Rakudo Perl 6, version 2010.06-173-gd9a5ac0

[11:43] <jnthn> \o/

[11:45] <moritz_> masak, mberends: I'd like an opinion on http://rt.perl.org/rt3/Ticket/Display.html?id=76376

[11:45] <moritz_> the Date part looks good, execept that I'd prefer to have DateLike in a separate file

[11:46] <masak> I haven't looked at the code yet. I briefly read through the summary.

[11:46] <moritz_> but I only glanced over the code, not done a proper review yet

[11:47] <masak> "- Temporal and Date now use a role called DateLike which contains common methods."

[11:47] <masak> I am unsure what this means, since there's no longer a type "Temporal".

[11:47] <masak> it's just the file that's called that, through sheer inertia.

[11:48] <masak> probably he meant "DateTime and Date".

[11:48] <masak> something feels wrong with calling Date "Datelike". :)

[11:48] *** sftp joined
[11:49] <masak> maybe we should go with STD.pm6's nomenclature and call it Dateish...

[11:49] *** sftp_ left
[11:49] <moritz_> or maybe it should be a lexical role that's not visible to the user code

[11:50] *** chee left
[11:50] <masak> that'd be nice -- but doesn't that presuppose Date and DateTime in the same file?

[11:50] <masak> ISTR that mberends tried the extract-strftime trick and it didn't work. so it would be interesting to hear his views on this.

[11:51] <masak> re new spectests -- why wait until the patch has been applied? we can fudge them in the meantime, or fail the tests for a short while.

[11:52] <moritz_> did he attach the new spectest file?

[11:53] <moritz_> we can always put the file in the pugs repo, but don't run it yet.

[11:53] <masak> he didn't attach the new spectest file.

[11:54] <moritz_> that would be a nice first step :-)

[11:54] <masak> (but there's a one-line addition to spectest.data)

[11:54] <moritz_> yes, I know

[11:54] * masak reviews patch

[11:55] *** orafu left
[11:55] *** orafu joined
[11:55] <masak> so, DateTime::strftime has to be applied as a mixin on every object you'd want to use it on? why isn't it simply flattened in as a role?

[11:56] *** ruoso joined
[11:56] <moritz_> that seems... strange

[11:57] *** jaldhar left
[11:57] <masak> I'm not 100% sure I agree to making the .is-leap, and .days-in-month methods private. I could see external parties using those as class methods without harm and for good reasons.

[11:58] <moritz_> right

[12:00] <masak> the role DateLike has attributes, but they're not declared at the top of the role. I consider that slightly confusing.

[12:01] *** rhr joined
[12:02] <masak> also, I consider it confusing that $.year, $.month and $.day are declared in DateLike, and $.hour, $.minute, $.second are declared in DateTime. but that might just be me. it does save a tiny bit of repetition.

[12:02] *** szbalint left
[12:06] <masak> I don't quite see the use of the :$noassert flag. seems to be a premature optimization of some kind.

[12:08] <masak> end-of-review.

[12:08] <masak> to be fair, maybe "loadable module" implies "mixin". I dunno.

[12:10] *** szbalint joined
[12:15] *** pnu joined
[12:15] *** duzy left
[12:22] *** takadonet joined
[12:22] <takadonet> morning all

[12:23] <masak> takadonet: \o

[12:26] *** envi_home2 joined
[12:26] *** envi^home left
[12:27] <bbkr> rakudo: .say for ('X', '/' ~ * ~ '\'... 8)

[12:27] <p6eval> rakudo d9a5ac: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤»

[12:27] <bbkr> rakudo: .say for ('X', '/' ~ * ~ q{\}... 8)

[12:27] <p6eval> rakudo d9a5ac: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤»

[12:28] *** timbunce left
[12:29] <masak> $ ./yapsi --version

[12:29] <masak> This is Yapsi, revision 2010.07-2-gf2020b2

[12:29] <masak> \o/

[12:32] <cognominal> rakudo: multi sub f(@p, Range $r? ) { say 1 }; multi sub f([], Range $r) { say 2 }; f([], 1..2); multi sub f(@p, Range $r?, Bool :$mod ) { say 1 }; multi sub f([], Range $r) { say 2 }; f([], 1..2);

[12:32] <p6eval> rakudo d9a5ac: OUTPUT«Ambiguous dispatch to multi 'f'. Ambiguous candidates had signatures:␤:(Positional  (), Range $r)␤:(@p, Range $r?, Bool :mod($mod))␤:(Positional  (), Range $r)␤␤  in main program body at line 11:/tmp/Hn_ii95sXs␤»

[12:33] <cognominal> things are getting worse here, I have 3 signatures for 2 functions.

[12:33] <cognominal> oops

[12:33] <cognominal> I am wrong

[12:33] <jnthn> Indeed

[12:33] <jnthn> Rakudo is right here.

[12:34] <jnthn> You really do have two subs with the exact same signautre.

[12:34] <cognominal> rakudo: multi sub f(@p, Range $r? ) { say 1 }; multi sub f([], Range $r) { say 2 }; f([], 1..2); 

[12:34] <p6eval> rakudo d9a5ac: OUTPUT«2␤»

[12:34] <cognominal> rakudo:  multi sub f(@p, Range $r?, Bool :$mod ) { say 1 }; multi sub f([], Range $r) { say 2 }; f([], 1..2);

[12:34] <p6eval> rakudo d9a5ac: OUTPUT«Ambiguous dispatch to multi 'f'. Ambiguous candidates had signatures:␤:(@p, Range $r?, Bool :mod($mod))␤:(Positional  (), Range $r)␤␤  in main program body at line 11:/tmp/hHLa4w_dyb␤»

[12:34] <dalek> yapsi: 513948d | masak++ | yapsi:

[12:34] <dalek> yapsi: [yapsi] implemented --version

[12:34] <dalek> yapsi: Idea shamelessly stolen from Rakudo. pmichaud++

[12:34] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/513948d3b034fa9aea07828a7cbc855ba0e174a2

[12:34] *** zamolxes left
[12:34] *** zamolxes joined
[12:35] <cognominal> I botched the first paste to rakudo.  I still don't understand the behavior on my last paste.

[12:35] <jnthn> cognominal: I do

[12:36] <jnthn> cognominal: Though not quite sure if it's desirable...

[12:36] <jnthn> But I get it's to do with the named param

[12:36] <jnthn> As I've said before, if you're going to want named params to influence dispatch, you need to mark them as required to not end up in that candidate.

[12:37] *** jaldhar joined
[12:38] <masak> jnthn: but how does the addition of a named param cause two non-conflicting candidates to suddenly conflict, as above? :/

[12:38] <masak> I'm definitely not sure that's desirable.

[12:39] <jnthn> masak: I'm not sure if that's the whole story there

[12:39] <masak> that's what I see.

[12:39] <jnthn> Oh, wait...that's all that was added

[12:39] <jnthn> Oh

[12:40] * masak adds that to the ticket

[12:40] <jnthn> I bet it's because it says "oh, there's a named parameter there, so I'd best make sure the signautre is bindable"

[12:40] <jnthn> And then both have constraints

[12:40] <jnthn> Both are satisfied

[12:40] <jnthn> And thus conflict

[12:40] <jnthn> The spec probably wants "first wins" though

[12:40] <jnthn> But I don't like that.

[12:40] <jnthn> Anyway, I'm not especially surprised by the conflict.

[12:41] <mathw> Why wouldn't it amke sure the signature was bindable without the named parameter?

[12:41] <jnthn> mathw: It doesn't have to go and do a full bindability check there

[12:41] <jnthn> mathw: It can go purely on arity and types

[12:42] <jnthn> mathw: It's only when you have where clauses, sub-signatures or named parameters that it then treats bindability as needed for a tie-break.

[12:43] <mathw> okay yes that makes sense

[12:43] <mathw> I was struggling with the idea that adding an optional named param was changing the resolution order in a sense

[12:43] <mathw> but then I realised that of course it can

[12:43] <mathw> because you've changed the signature

[12:44] <mathw> although I'd still kind of expect the [] to cause the two-param version to bind more tightly there

[12:44] *** rgrau_ joined
[12:44] <jnthn> Nope

[12:44] <mathw> but that's an intuitive, non-rigorous thought

[12:44] <jnthn> There's no such thing as a "better constraint"

[12:44] <bbkr> rakudo: .xyz # why it says <invocant of class ''> ? error message seems to be LTA..

[12:44] <p6eval> rakudo d9a5ac: OUTPUT«Method 'xyz' not found for invocant of class ''␤  in main program body at line 11:/tmp/AvLJADWM5C␤»

[12:45] <cognominal> it does not make any sense to me that adding that is in neither signatures creates an ambiguity.

[12:46] <cognominal> I mean, "parameter that was originally in neither signature".

[12:46] <mathw> jnthn: okay but there were no extra constraints

[12:46] <mathw> just a named parameter

[12:46] <jnthn> Argh!

[12:46] <jnthn> That *is* a constraint!!!!

[12:47] <mathw> That's what I was afraid you were going to say

[12:47] <jnthn> I already said it before, but nobody seems to want to believe me. :-)

[12:47] <mathw> well

[12:48] <mathw> I don't understand how it can be a constraint when it's just a parameter

[12:48] <cognominal> I believe you, I just don't feel that behavior is right

[12:48] <cognominal> whatever the specs say.

[12:48] *** sftp left
[12:48] <masak> the presence of a named parameter must be a constraint, yes.

[12:48] <jnthn> mathw: Because named parameters don't participate in multiple dispatch

[12:48] <jnthn> So as soon as you have a named parameter - what masak said.

[12:49] <mathw> Ooooooooooooh

[12:49] <mathw> (see that? that's the sun coming up)

[12:49] <jnthn> The only issue we have with the spec vs Rakudo here is that Rakudo currently tells you about ambiguity when there are constraints

[12:49] <jnthn> Whereas the spec last I checked says "oh just pick the first one" 

[12:50] <jnthn> Where first is this wonderfully fragile thing when you start importing candidates from elsewhere.

[12:50] <mathw> yes

[12:50] <mathw> bound to make some heads explode

[12:50] <jnthn> Not to mention that it means re-ordering your candidates or factoring some of them out to other places and importing them could then change your dispatch.

[12:50] <jnthn> Which imo is just horrible. :-)

[12:51] <jnthn> So I'm hoping the spec will revert to "complain" there

[12:51] <mathw> in cognominal's example above, there is an argument that one of the alternatives matched two constraints instead of just one, and thus would be preferable...

[12:51] <mathw> but the spec places no value on that kind of thing?

[12:51] <jnthn> No

[12:52] <mathw> also, ambiguity bad

[12:52] <mathw> complaining preferable

[12:52] <jnthn> If you really want to say "in event of conflict this one wins", the spec alredy provides an explicit mechanism for that (the is default trait).

[12:52] <jnthn> Rakudo also implements that trait. :-)

[12:53] <mathw> ambiguity without an 'is default' feels like an error

[12:53] <mathw> 'is default' makes me a bit uncomfortable too

[12:53] <mathw> I doubt I'll be using it

[12:53] <jnthn> Yes, I consider it last resort-ish.

[12:53] <jnthn> And hope it won't be used much.

[12:54] <jnthn> What really worries me is that we end up trying to add more rules and complications to the multi-dispatch algorithm.

[12:54] <mathw> maybe we could patch Padre's Perl 6 highlighter to make it come up very big and very red :)

[12:54] <cognominal> the default does not buy me anything here.  I thought I had a way with a program  with 6 multimethods to walk a tree and possibly modify it.

[12:55] <cognominal> multi sub subtree(@a, @path, Range $r?, Bool :$mod?) {  subtree( @a[@path.unshift], $r, $mod)  }

[12:55] <cognominal> multi sub subtree(@a, [], Range $r) { @a.splice( $r.begin, $r.end-$r.begin) }

[12:55] <cognominal> multi sub subtree(@a, [$i]) { @a[i] }

[12:55] <cognominal> multi sub subtree(Str $s, [], Range $r?) { $s.substr($.begin, $r.end - $r.begin )  }

[12:55] <cognominal> multi sub subtree(@a, [$i], Range $r, Bool :$mod) {

[12:55] <cognominal>   my ($s, $e) = ($r.start, $r.end);

[12:55] <cognominal>   @a[$i] = $s == 0 ?? Nil !! $_[0..^$s],  [ $_[$s..$e] ], ( $e == +$_ ?? Nil !! [ $e+1 ..^ +$_ ]);

[12:56] <cognominal> }

[12:56] <cognominal> multi sub subtree(@a, [$i], Range $r, Bool :$mod) {

[12:56] <cognominal>   my ($s, $e) = ($r.start, $r.end);

[12:56] <cognominal>   $_ = @a[$i];

[12:56] <cognominal>   @a[$i] = ( $s == 0 ?? Nil !! $_[0..^$s]),  [ $_[$s..$e] ], ( $e == +$_ ?? Nil !! [ $e+1 ..^ +$_ ]);

[12:56] <cognominal> }

[12:56] <cognominal> use Test;

[12:56] <cognominal> plan *;

[12:56] <cognominal> my @test = "01234567809",  ["01234567809"],  ["0123", ["4567"], "809"];

[12:56] <cognominal> say subtree(@test, [], 1..2)

[12:56] <cognominal> oops

[12:56] <cognominal> soory

[12:56] <cognominal> I meant to paste that :  http://nopaste.gamedev.pl/?id=7656

[12:56] <jnthn> nopaste? ;-)

[12:56] <cognominal> xchat--

[12:56] <jnthn> :-)

[12:56] <cognominal> :(

[12:57] <cognominal> just to show you the kind of thing I try to do.

[12:57] <cognominal> to see if multiple dispatch is appropriate here.

[12:57] *** ash_ joined
[12:58] <jnthn> In there you have two candidates that look identical to me:

[12:58] <jnthn> multi sub subtree(@a, [$i], Range $r, Bool :$mod) {

[12:58] <jnthn> multi sub subtree(@a, [$i], Range $r, Bool :$mod) {

[12:58] <jnthn> (the last two)

[13:00] <mathw> I assume one is for mod=true and one is for mod=false

[13:00] <cognominal> yea, that should be one routine, and it should return the whole tree.

[13:01] <cognominal> I had not really finished wirting it when I had problems with multiple dispatch

[13:01] <jnthn> The thing is that

[13:01] <masak> ooh! "static lexpad" is a wonderful name.

[13:01] <masak> pmichaud++

[13:02] <jnthn> (@a, [], Range $r)

[13:02] <jnthn> And

[13:02] <jnthn> (@a, @path, Range $r?, Bool :$mod?)

[13:02] <jnthn> Both sort to the same level in terms of the arity/type sorting

[13:02] <jnthn> And then both have to be dis-ambiguated on constraints.

[13:03] <jnthn> And there's a case where both match the constraint.

[13:03] <cognominal> I want to walk a tree and possibly modify it by adding a branch depending of the Range.    The range is really position of the string crateed by walking the tree and concatenating the strings.

[13:03] <cognominal> "position in the string".

[13:04] <cognominal> what would be the way out?

[13:05] <masak> EQUESTIONTOOUNSPECIFIC

[13:05] <mathw> Insufficient Chocolate Error. Insert more chocolate to continue.

[13:06] <jnthn> cognominal: You may need to break multi sub subtree(@a, @path, Range $r?, Bool :$mod?) {  subtree( @a[@path.unshift], $r, $mod)  } into a couple of candidates that don't conflict with other things

[13:08] <jnthn> cognominal: e.g. maybe

[13:08] <jnthn> multi sub subtree(@a, @path, Range $r, Bool :$mod!) {  subtree( @a[@path.unshift], $r, $mod)  }

[13:08] <jnthn> multi sub subtree(@a, @path, Range $r) {  subtree( @a[@path.unshift], $r)  }

[13:08] <cognominal> well, I will pass the $mod as lexical in a closure. It will be more elegany anyway.

[13:09] <jnthn> That way, there's no way the two can overlap in a constrainty way and both match

[13:09] <cognominal> but somehow, I don't like multiple dispatch as it is.

[13:09] <cognominal> We will see how people will use it in teal programs.

[13:10] <cognominal> *real

[13:13] <mathw> I'm thinking my mental model of constraints is wrong

[13:14] <cognominal> afk&

[13:18] *** jedai left
[13:26] <jnthn> On a walk to buy bread just now, it occurred to me the heart of it is this: if you are going to have multi candidates that will be dis-ambiguated by constraints, then the constraints should not overlap.

[13:27] *** Lorn left
[13:27] *** mantovani left
[13:33] *** timbunce joined
[13:35] <masak> isBEKaml, tylercurtis, snarkyboojum: I thought a lot about SIC and Yapsi last night; here's a summary of my thoughts. http://gist.github.com/464349

[13:38] *** ive joined
[13:42] *** sftp joined
[13:46] *** Lorn joined
[13:53] *** sftp left
[13:53] *** rhr left
[13:54] *** timbunce left
[13:55] *** timbunce joined
[13:55] *** rhr joined
[13:56] <slavik> jnthn: O.o wha?

[13:56] <slavik> why can't I be smart enough to understand language design? :(

[13:58] <moritz_> http://svok.blogspot.com/2010/07/announcing-perl-5-documentation-team.html 

[14:00] *** amkrankruleuen left
[14:02] <mathw> jnthn: yes maybe that's the right kind of route

[14:02] <mathw> What I'd like to understand is the reason why constraints all sort at the same level

[14:02] <mathw> Is it just too difficult to do them any other way?

[14:04] <jnthn> mathw: Well, how do I order e.g. where { $^n < $limit } and where { $^n %% 2 }?

[14:04] <masak> mathw: perhaps not, but we've toyed with less-than-super-simple resolution algorithms before, and it didn't lead to happiness those times.

[14:04] *** PacoLinux joined
[14:04] <jnthn> The easy example here is

[14:04] <mathw> jnthn: there, indeed, you can't

[14:05] <jnthn> multi foo($x where { $x >= 10) { }

[14:05] <jnthn> multi foo($x where { $x <= 10 }) { }

[14:05] <jnthn> er, missing }

[14:05] <jnthn> Anyway, foo(10) is then ambiguous because the constraints overlap there

[14:05] <mathw> yes

[14:06] <mathw> I'm not arguing that

[14:06] <jnthn> OK, but my point is that cognominal++'s example conflict boiled down to the same kind of issue.

[14:07] <mathw> Which I don't understand

[14:07] <masak> me neither, not at once.

[14:07] <masak> it's easier to see with blocks.

[14:07] <moritz_> what were the constraints?

[14:07] <jnthn> moritz_: In one of them the subsignature

[14:07] <jnthn> moritz_: In the other, the presence of a named parameter

[14:08] <moritz_> I think I remember an RT ticket (which I kinda thought was bogus, but not sure)

[14:08] <mathw> That's what I don't understand, because they're constraints on different parameters

[14:08] *** uniejo left
[14:08] <mathw> well, okay, the named parameter isn't a parameter in that sense

[14:09] <moritz_> rakudo: multi a($x, $y) { }; multi a ($x, $y?) { }; a(1, 2)

[14:09] <p6eval> rakudo d9a5ac: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;Perl6Role;!select' pc 11403 (src/gen/RoleToClassApplier.pir:591)␤... call repeated 1 times␤»

[14:09] <jnthn> ...

[14:09] <moritz_> that's ouch-y

[14:09] <jnthn> rakudo: say "huh"

[14:09] <p6eval> rakudo d9a5ac: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;Perl6Role;!select' pc 11403 (src/gen/RoleToClassApplier.pir:591)␤... call repeated 1 times␤»

[14:09] <mathw> ouch!

[14:09] <jnthn> aww

[14:09] <jnthn> our evalbot is fel again

[14:11] <jnthn> mathw: It's more about the whole set of arguments than you pass. And if you can pass a set of arguments that causes both to match, you're in for a conflict.

[14:12] * mathw has a horrible suspicion that he's trying to think of a solution that's inevitably undecidable

[14:12] <jnthn> :-)

[14:14] <jnthn> mathw: What worries me about trying to make more multi calls be disambiguated is that it probably means making the algorithm more complex, when it's clear that it's already complex enough that it's non-trivial to grok.

[14:15] <moritz_> any disambiguation algorithm will have cases where it doesn't DWYM

[14:15] <jnthn> Right

[14:16] <moritz_> and then it must be understood - jnthn is right here

[14:16] *** MarkSenn joined
[14:16] *** lest_away is now known as lestrrat

[14:17] <jnthn> I guess it's a trade-off. We can try and make multi-dispatch richer and make it less likely that folks will hit a non-DWIM case, but in doing so we also increase the pain of understanding that's going on when people do get to such a situation.

[14:17] *** lestrrat is now known as lest_away

[14:17] <jnthn> And as moritz_++ points out, it's more when than if. :-)

[14:18] <jnthn> At least, if you write enough non-trivial multis. :-)

[14:18] <jnthn> er, *what's going on

[14:19] <mathw> yes

[14:19] <mathw> I think my real surprise was just that named parameters are constraints rather than parameters

[14:20] *** redicaps joined
[14:21] <mathw> Then I was surprised about constraints on different parameters not DWIE

[14:22] <mathw> but thinking about it some more I realise there's a slippery slope there

[14:22] *** takadonet left
[14:22] <mathw> I do not want the system pausing for ten seconds in order to inform me that it can't find a suitable candidate without first solving the halting problem

[14:23] <moritz_> I guess it's just like starting with grammars: it's a relatively new programming concept, and people have to learn to use it. Even people who are otherwise experienced programmers.

[14:23] <mathw> well, grammars were much easier

[14:23] <mathw> once I realised that token and rule were doing strange things I didn't like

[14:23] <mathw> and started just using regex :)

[14:24] <mathw> oh and back in alpha, when backtracking 'worked'

[14:24] <jnthn> mathw: I think deciding something boils down to the halting problem may also be a case of the halting problem. ;-)

[14:24] *** takadonet joined
[14:24] <mathw> jnthn: in some cases, yes

[14:25] <jnthn> Yes, not all :-)

[14:25] <mathw> in fact, there was one case I identified in my attempt to get a PhD which was definitely the halting problem just figuring out if a particular thing was the halting problem...

[14:25] <mathw> that line of enquiry was not profitable for anybody

[14:26] <moritz_> rakudo: say 1

[14:26] * jnthn concentrates on $dayjob for a little bit

[14:26] <p6eval> rakudo d9a5ac: OUTPUT«1␤»

[14:26] <moritz_> rakudo: multi a($x, $y) { }; multi a ($x, $y?) { }; a(1, 2)

[14:26] <p6eval> rakudo d9a5ac: OUTPUT«Ambiguous dispatch to multi 'a'. Ambiguous candidates had signatures:␤:(Any $x, Any $y)␤:(Any $x, Any $y?)␤␤  in main program body at line 11:/tmp/7I_PoGnIjp␤»

[14:26] <mathw> now that is definitely ambiguous

[14:27] <mathw> although I suppose you could say prefer the one that demands two over the one that could have one

[14:28] <mathw> but probably better to say it's just ambiguous, if you wanted one with one parameter just write one with one parameter!

[14:28] <jnthn> mathw: That'd be my leaning, at this point.

[14:28] *** plobsing joined
[14:28] <jnthn> I guess whoever filed the ticket felt otherwise. ;-)

[14:28] <mathw> explaining to people why their variant with the optional parameter never got called would just get silly

[14:29] *** bjarneh joined
[14:30] <mathw> the side of me which carries a big stick says people should choose their multi signatures carefully

[14:32] <cognominal> I critize the current scheme but I can't get a better one...

[14:34] *** takadonet left
[14:34] *** takadonet joined
[14:35] *** Trashlord left
[14:37] *** MarkSenn left
[14:39] *** redicaps left
[14:39] *** takadonet left
[14:40] <masak> std: my $object; $object.**(5)parent; # $object.parent.parent.parent.parent.parent

[14:40] <p6eval> std 31553: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/fgHwp9ci5b line 1:␤------> [32mmy $object; $object.*[33m⏏[31m*(5)parent; # $object.parent.parent.pare[0m␤    expecting dotty method or postfix␤Parse failed␤FAILED 00:01 113m␤»

[14:40] <masak> I know that's now currently allowed syntax... :)

[14:40] <masak> ...but when we have syntax-modifyiing modules, it just might be.

[14:41] <masak> along with an `$object.?**(5)parent` form, too.

[14:43] <mathw> that is...

[14:43] <mathw> definitely best left to syntax-modifying modules

[14:43] *** takadonet joined
[14:43] <masak> :>

[14:43] <mathw> I think your brain's in sideways

[14:44] <masak> no no, admit it, you want that syntax.

[14:44] <jnthn> :P

[14:44] <mathw> no I don't

[14:44] <mathw> I really don't

[14:44] <moritz_> masak: I kinda think that $object.**(5)method is a very dangerous thing

[14:45] <moritz_> because it makes quite some assumptions about the underlying data structure

[14:45] <masak> not sure I see what you mean.

[14:45] <masak> it makes five method calls, that's all.

[14:45] <masak> sure the dispatch might be different in all five cases...

[14:45] <mathw> it's foul

[14:45] <moritz_> and it assumes that the first four all return objects where it makes sense to call .parent on it

[14:45] <mathw> take it away!

[14:46] <mathw> moritz_: well, so does .parent.parent.parent.parent.parent

[14:46] <masak> moritz_: well, the programmer assumes that.

[14:47] <moritz_> .parent.parent.parten.parent.parent is also a bad idea :-)

[14:47] <moritz_> masak: yes, but that syntax encourages these assumptions

[14:47] <masak> moritz_: I'd have that as $thing .= parent for ^5; in today's Perl 6.

[14:48] <mathw> masak that's even eviller

[14:48] <moritz_> masak: which has the advantage of being easily extensible to give better error messages

[14:48] <masak> mathw: there's just no pleasing you... :)

[14:48] <mathw> nope

[14:49] <moritz_> for ^5 { die "OH NOEZ, \$thing can't do .parent at level $_" unless $thing.can('parent');  $thing.=parent; }

[14:49] <moritz_> or better, access the depth in a CATCH block

[14:49] <mathw> of course what you really want to do is just write it in Haskell

[14:49] * mathw runs

[14:49] <jnthn> or use xpath ;-)

[14:50] <mathw> parent $ parent $ parent $ parent $ parent thing

[14:50] <moritz_> but if you do $thing.**(5)parent, and you get an error message, you have quite some "fun" debugging

[14:50] <mathw> jnthn: or have a better API design

[14:50] <mathw> which might be xpath

[14:50] <moritz_> eval '$thing' ~ ('.parent' x 5)

[14:50] <mathw> a lovely scrummy xpath module

[14:50] <moritz_> SCNR

[14:51] <mathw> **($n)method would of course have to expand at the macro stage to .method.method.method etc, hopefully before the compiler checks to see if it's plausible

[14:52] <moritz_> why would it need to be a macro?

[14:54] <mathw> because I can't think of another route by which you could introduce that kind of syntax

[14:54] *** takadonet left
[14:54] <moritz_> a postfixish meta operator?

[14:54] <masak> std: my $thing; $thing.?=parent for ^5;

[14:54] <p6eval> std 31553: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/3KErTEND3F line 1:␤------> [32mmy $thing; $thing.?[33m⏏[31m=parent for ^5;[0m␤    expecting dotty method or postfix␤Parse failed␤FAILED 00:01 110m␤»

[14:55] <masak> std: my $thing; $thing = $thing.?parent for ^5;

[14:55] <p6eval> std 31553: OUTPUT«ok 00:01 110m␤»

[14:56] <masak> ...and afterwards, check for undef.

[14:56] <masak> er, Mu. whatevs.

[14:56] <moritz_> std: 1.=?foo

[14:56] <masak> check if not defined.

[14:56] <p6eval> std 31553: OUTPUT«[31m===[0mSORRY![31m===[0m␤Decimal point must be followed by digit at /tmp/IEgOgks95F line 1:␤------> [32m1.[33m⏏[31m=?foo[0m␤Bogus term at /tmp/IEgOgks95F line 1:␤------> [32m1.=[33m⏏[31m?foo[0m␤    expecting dotty method or postfix␤Parse failed␤FAILED 00:01 108m␤»

[14:56] <moritz_> std: 'bla'.=?foo

[14:56] <p6eval> std 31553: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/1VWVDJ7CT5 line 1:␤------> [32m'bla'.=[33m⏏[31m?foo[0m␤    expecting dotty method or postfix␤Parse failed␤FAILED 00:01 108m␤»

[14:56] <jnthn> moritz_: No. :P

[14:57] <masak> moritz_: probably intentionally not allowed :)

[14:57] <jnthn> They don't combine. :-)

[14:57] <masak> on behalf of my brain, I wish to apologise for coming up with it in the first place. :P

[14:58] <mathw> wouldn't it be .?=

[14:58] <mathw> even though it really is evil

[14:58] <mathw> and you shoudl be ashamed of yourself

[14:58] <moritz_> masak: compensate by answering to my mail on the perl6-workshop list :-)

[14:58] <mathw> &

[14:58] <moritz_> mathw: masak++ tried .?= before

[14:58] *** takadonet joined
[14:58] <masak> right. didn't work either.

[14:59] <masak> moritz_: hokay. :)

[14:59] <pmichaud> good morning, #perl6

[14:59] <masak> pm!!! \o/

[14:59] <moritz_> good morning, mr closure-fix!

[14:59] <pmichaud> ...does it work?  :-)

[15:00] <moritz_> autounfudge found quite some things

[15:00] *** plobsing left
[15:00] <moritz_> rakudo: say [\+] [\+] 1 xx 5

[15:00] <p6eval> rakudo d9a5ac:  ( no output )

[15:01] <moritz_> colomon++ expected this to be fixed by the closure fix too, but he might be wrong

[15:01] <masak> pmichaud: I've re-compiled Rakudo. let me try and rebuild GGE without the closure workarounds. :)

[15:01] <jnthn> morning, pmichaud 

[15:02] <jnthn> pmichaud: Great work on landing the branch! :-D

[15:02] <pmichaud> jnthn: I'm curious if my gen_version.pl stuff works under windows.  (i.e., are you able to build current master branch? )

[15:02] <jnthn> pmichaud: ah, you didn't backlog. Yes, it works.

[15:02] <jnthn> pmichaud: I pasted the output.

[15:02] <jnthn> pmichaud: It looked correct

[15:02] <pmichaud> jnthn: (landing branch) thanks -- it was your fix that got us over the final hurdle.

[15:02] <pmichaud> (reading backlog now)

[15:02] <jnthn> Heh, it was only a one line change. :-)

[15:03] <moritz_> well, the zen master can fix many bugs with one line of change

[15:04] <moritz_> knowning where to change what matters far more than the number of lines involved

[15:04] <moritz_> :-)

[15:04] <jnthn> :-)

[15:04] <jnthn> Aye, but it was one small fix compared to the many pmichaud++ did.

[15:05] * jnthn has fun eliminating locking and replacing it with lock-free stratergies for $dayjob

[15:05] <pmichaud> "A programming language of a thousand features begins with a single patch."   (or something like that)

[15:08] <masak> "An implementation with a thousant RT tickets begins with a single RT ticket." Hm, doesn't quite have that ring to it. :)

[15:08] <moritz_> rakudo: say $*PERL

[15:08] <p6eval> rakudo d9a5ac: OUTPUT«version    2010.06-173-gd9a5ac0␤name rakudo␤␤»

[15:10] <masak> er.

[15:10] <masak> the revision number after 'rakudo' doesn't match the onw in the version value.

[15:11] <pmichaud> ?

[15:12] <moritz_> there's a stray 'g' in there

[15:12] <pmichaud> that comes from git-describe.

[15:12] <pmichaud> it's not part of the revision number.

[15:12] <masak> ah.

[15:12] <masak> and then there's an extra 0.

[15:12] <pmichaud> the revision number is whatever comes after the 'g'

[15:12] <masak> right.

[15:12] <masak> 'g' can't be part of a hex number :)

[15:12] <moritz_> masak: the 0 is an artifact of using different lengths

[15:12] <pmichaud> git sha1's can be shortened to any length (that keeps the unique)

[15:12] <pmichaud> *them

[15:13] <masak> aye.

[15:13] <masak> so, false alarm.

[15:13] <moritz_> p6eval is just a bit more nazi in shortening them :-)

[15:17] * masak squirms and falls silent :)

[15:17] *** cotto left
[15:19] *** tedv joined
[15:25] *** macdaddy joined
[15:25] *** macdaddy is now known as Guest77623

[15:28] <pmichaud> jnthn: ping

[15:28] <jnthn> pmichaud: pong

[15:29] <pmichaud> is there currently a way that we could have methodcalls not de-containerize the invocant?

[15:30] <jnthn> Well, I think we wanted to switch to that as a kind of default...

[15:30] <pmichaud> switch to which?

[15:31] <jnthn> Don't de-containerize

[15:31] <jnthn> Otherwise :($inv is rw: ...) can never work

[15:31] <pmichaud> right

[15:31] <jnthn> Which I think we needed for auto-viv.

[15:31] * masak .oO( Is there a way not to immanentize the eschaton? )

[15:31] <pmichaud> (guess what I'm working on now :)

[15:31] <jnthn> Right

[15:31] <jnthn> I thought up an Awesome Solution to this a while back.

[15:31] <jnthn> I wish I could remember it.

[15:32] <jnthn> We discussed it here so it must be in the logs somewhere. ;-)

[15:32] <pmichaud> what's the reason we de-containerize now?

[15:32] <jnthn> Oh oh oh!

[15:32] <pmichaud> I forget.

[15:32] <jnthn> I know it.

[15:33] <jnthn> We de-containerize because if the thing in the container is a (non-object) PMC then Parrot guts get hugely upset over the wrapper.

[15:33] <jnthn> Since they can't find their attribute data.

[15:33] <jnthn> The answer was to only de-containerize if the thing in the container ended up being something other than an Object or P6opaque.

[15:34] <jnthn> Which is a dirt-cheap check.

[15:34] <jnthn> (check ->vtable->base_type)

[15:37] <pmichaud> I'm having trouble following that.

[15:37] <pmichaud> might be too early here for me.

[15:37] <masak> pmichaud: I got a 'Segmentation fault' when running the GGE tests. don't know yet if it's reproducible; will try running it again.

[15:37] <pmichaud> the problem is that Parrot doesn't know how to deal with objectrefs

[15:38] * jnthn hands pmichaud a Dr Pepper

[15:38] <jnthn> pmichaud: It's not really a "problem" of Parrots

[15:39] <jnthn> pmichaud: A PMC has a data pointer off which hands a C struct holding its attributes

[15:39] <jnthn> When you invoke a method on a PMC, it thus expects to be able to get at its data through the SELF pointer.

[15:39] <jnthn> SELF PMC * pointr that is

[15:40] <jnthn> Trouble is, if we wrapped the invocant, that's an ObjectRef PMC or a Perl6Scalar PMC, not the actual PMC that it expects

[15:40] <jnthn> It just reads into memory it shouldn't and segfaults.

[15:40] <jnthn> *thus

[15:40] <jnthn> Or worse, does something weird. :-)

[15:40] <jnthn> So the reason we de-containerize is so that methods invoked on a PMC that are implemented inside the PMC won't explode that way.

[15:40] <jnthn> However, de-containerizing everywhere is a bit OTT

[15:41] <jnthn> We only need to de-containerize things where this is actually an issue

[15:41] <masak> swimming &

[15:41] <jnthn> Which is basically anything that is not an Object (or in our case P6opaque, since we subclassed Object)

[15:41] *** masak left
[15:41] <pmichaud> by "methods implemented inside the PMC" do you mean the PCCMETHODS ?

[15:41] <jnthn> Correct

[15:41] *** Trashlord joined
[15:42] <pmichaud> I have a bigger question, then.

[15:42] <pmichaud> well, several.

[15:43] <pmichaud> well, I answered one myself.  I was going to ask if perhaps we wanted to somehow exclude such methods from dispatch anyway (e.g., to keep Parrot methods from leaking into our objects)

[15:43] <pmichaud> but the answer is that we don't want to exclude them -- we still want to be able to do dispatch on foreign PMCs

[15:43] <jnthn> Right.

[15:44] <jnthn> Well the problem is in say IO.pm

[15:44] <jnthn> Where we want to make calls on a Parrot IO PMC

[15:44] <pmichaud> right

[15:44] <pmichaud> so, how hard would it be to implement this new behavior?

[15:44] <jnthn> Not hard

[15:45] <pmichaud> also, I wonder if lexical 'self' should also be de-containerized.

[15:45] <jnthn> We want a new decontainerize_invocant dynop

[15:45] <jnthn> And to use that in place of the one that unconditionally does it

[15:45] <jnthn> And that dynop is quite easy to write (5 lines or so...10 at worst)

[15:46] <pmichaud> dynop should be   deref_pmc

[15:46] <pmichaud> or depmcref

[15:46] <pmichaud> "decontainerize_invocant"  is in fact the thing we're *not* doing :-)

[15:46] <jnthn> this is only for invocants

[15:46] <jnthn> well

[15:47] *** TiMBuS left
[15:47] <pmichaud> it's really derefifpmc

[15:47] <jnthn> deref_invocant_if_it_refs_a_pmc

[15:47] <jnthn> ;-)

[15:47] <pmichaud> well, we don't need "invocant" in the name

[15:47] <pmichaud> we may currently only be using it for method-dispatch, but it would work on non-invocanty things also.

[15:48] <pmichaud> derefnonobject

[15:48] <jnthn> true

[15:48] <pmichaud> deref_if_pmc

[15:48] <pmichaud> deref_unless_object

[15:48] <pmichaud> do you want to write it or shall I?

[15:50] <pmichaud> (yes, easy to do)

[15:50] <jnthn> If you can, go ahead.

[15:50] <jnthn> (i need to work on $dayjob bits a little today)

[15:50] *** sftp joined
[15:52] *** isBEKaml joined
[15:57] <pmichaud> http://gist.github.com/464491  # basic opcode for jnthn++

[15:58] <pmichaud> fixing syntax error :-)

[15:58] <jnthn> yes that's what I had in mind

[15:58] <jnthn> though

[15:58] <jnthn>     PMC * val;

[15:58] <jnthn>     val = $2;

[15:58] <jnthn> Why not one line?

[15:58] <jnthn>     PMC * val = $2;

[15:58] <pmichaud> it wasn't that way in the other opcodes  

[15:58] <pmichaud> so I didn't copy it :-)

[15:58] <jnthn> oh.

[15:58] <jnthn> :-)

[15:58] <pmichaud> er, so I copied it.

[16:00] <pmichaud> there are currently some "string_from_literal" calls for P6opaque that I'm also going to factor out

[16:00] <pmichaud> (and cache the type, like we do for p6s_id)

[16:02] <jnthn> +1

[16:06] * TimToady is back home, and starting to feel rested

[16:06] <phenny> TimToady: 03 Jul 22:40Z <sorear> tell TimToady Just to clarify my question from earlier: I only want to rename the Perl 5 modules in STD.  STD.pm6 will be unaltered; viv will contain code to remap STD, Cursor, etc -> Perl6::* (like it already remaps so many renamed Perl6 functions)

[16:06] <phenny> TimToady: 04 Jul 08:53Z <sorear> ask TimToady what's the motivation separating sublongname and longname?

[16:06] <phenny> TimToady: 04 Jul 18:54Z <masak> ask TimToady could you have a look at this case of the new semantics for multies in an OO hierarchy? jnthn and I have an un-consensus about it.

[16:06] <phenny> TimToady: 04 Jul 18:55Z <masak> tell TimToady -- oh and here's the link http://gist.github.com/463655 :)

[16:07] <pmichaud> TimToady: /o

[16:07] <pmichaud> arrgggh

[16:07] <pmichaud> TimToady: o/

[16:07] <TimToady> why did you whack your head? :)

[16:07] <pmichaud> It's just the way I feel lately, I guess.  :)

[16:08] <pmichaud> .oO(   /o ... o/   looks like a *real* multiline comment syntax )

[16:08] <pmichaud>  /o or a multi-line

[16:08] <pmichaud>     bubble thought

[16:08] <pmichaud>   syntax o/

[16:08] <TimToady> the ir clogs seem to not render currently...

[16:10] <TimToady> doesn't like the &larr on line 40...

[16:10] <TimToady> some quick impressions just skimming the last 24 hrs of backlog though

[16:10] <TimToady> sorear: I revised my augment-is-like-BEGIN to say the statements don't run at BEGIIN time

[16:11] <TimToady> on the declarations

[16:11] <TimToady> I think multis don't run more than once; that is, a proto does not automatically fall back to its OUTER unless the proto requests it

[16:12] <pmichaud> jnthn: are string_from_literal calls generally "expensive", either in terms of runtime performance or in creating gc-ables?

[16:13] <TimToady> re STD->Perl6::* that seems fine, if you put it that way :)

[16:15] *** jaldhar left
[16:15] <jnthn> pmichaud: They make a GC-able

[16:15] <jnthn> pmichaud: If the code is hot path, that's bad.

[16:15] <pmichaud> so avoiding them would be a good thing.

[16:16] <pmichaud> like, say, in  bind_llsig  :-)

[16:16] <jnthn> If it's not path, no biggie.

[16:16] <jnthn> er, yes

[16:16] <jnthn> That's hot path

[16:16] <pmichaud> okay

[16:16] <jnthn> Flaming path

[16:16] <pmichaud> agreed

[16:16] <pmichaud> I just wanted to make sure I knew I was really optimizing something there :)

[16:16] <TimToady> I'm assuming masak's multi example has a 'proto' on class A's foo method; it should probably error as it is

[16:17] *** jaldhar joined
[16:17] *** tylercurtis joined
[16:18] <TimToady> that is, it should say "A" and fail on the nextsame, because there is no next candidate

[16:20] *** sawyer_ left
[16:22] *** meppl joined
[16:22] <TimToady> I suspect we are going to say that there are no implicit protos, at least for now.

[16:22] <TimToady> and more importantly, that no multi ever gets called without a proto mediating

[16:23] <TimToady> there's no proto in that example, hence no call to either of the multis

[16:26] <TimToady> and if class A's method foo is marked as proto, it will print "A\nC\nB\n"

[16:26] <TimToady> because the say A is before the nextsame, and protos are no longer last-resort, but a wrapper around the multies

[16:34] *** sawyer_ joined
[16:35] <TimToady> sorear: re sublongname: well, the original motivation was to parse category-based operator names specially, but that may not be important any more; what is still important is allowing :{} as part of the name, since longnames reject :{} extension nowadays

[16:36] <TimToady> we could conceivably factor those out to where <sublongname> is called, and then use longname, I guess

[16:36] <TimToady> in that case category based things like infix:<op> would have to be recognized semantically instead of syntactically

[16:37] <TimToady> it's quite possible that's the right way to go about it

[16:38] *** mberends left
[16:40] <TimToady> btw, restarting my firefox seems to have cleared my ir clog issue

[16:41] <cono> rakudo: say $*VM.perl

[16:41] <p6eval> rakudo d9a5ac: OUTPUT«Cannot substr on a null string␤  in 'Pair::perl' at line 1␤  in <anon> at line 4458:CORE.setting␤  in 'Any::join' at line 1␤  in 'EnumMap::perl' at line 4458:CORE.setting␤  in 'Pair::perl' at line 4220:CORE.setting␤  in <anon> at line 4458:CORE.setting␤  in 'Any::join' at line

[16:41] <p6eval> ..1␤  …

[16:45] <pmichaud> jnthn: The new non-dereference thing appears to work just great.

[16:46] <pmichaud> jnthn++

[16:46] <pmichaud> (spectesting now)

[16:46] <moritz_> rakudo: say %*VM<config>.perl

[16:46] <p6eval> rakudo d9a5ac: OUTPUT«Cannot substr on a null string␤  in 'Pair::perl' at line 1␤  in <anon> at line 4458:CORE.setting␤  in 'Any::join' at line 1␤  in 'EnumMap::perl' at line 4458:CORE.setting␤  in main program body at line 11:/tmp/Jr_xIYk4Oe␤»

[16:46] <moritz_> pmichaud: is there a good reason for $VM not to re-use %*VM<config>?

[16:46] <pmichaud> moritz_: I'm thinking that %*VM should go away.

[16:47] <pmichaud> At the very least, it doesn't belong in glue/run.pir

[16:47] *** hudnix joined
[16:47] <dalek> rakudo: 1e7012c | (Patrick Abi Salloum)++ | src/core/operators.pm:

[16:47] <dalek> rakudo: minor series code refactor

[16:47] <dalek> rakudo: Signed-Off-By: Moritz Lenz [email@hidden.address]
[16:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1e7012c57ed7121d61f1107d7e57f7f881cb2d9e

[16:48] <pmichaud> there's no %*VM listed in the synopses -- we just have $*VM there.

[16:48] <pmichaud> (I suspect synopses changed.)

[16:49] *** Sarten-X joined
[16:55] *** sftp left
[16:57] *** sftp joined
[16:58] *** ashleydev joined
[16:58] <jnthn> pmichaud: Great!

[16:59] *** envi_home2 left
[17:00] *** dakkar left
[17:02] <TimToady> bbl & ~2hr

[17:02] *** sftp left
[17:02] *** envi^home joined
[17:03] *** sftp joined
[17:03] *** isBEKaml left
[17:06] *** envi^home left
[17:12] <pmichaud> jnthn: only a few spectest fails after switching to deref_unless_object .  Some are likely clone-related (fixing now).

[17:12] <pmichaud> others are in the regexes... not sure why those fail but should be an easy fix.

[17:12] <pmichaud> (if 'clone' doesn't already fix them)

[17:13] <pmichaud> ...and with the new deref semantics in place, autoviv looks like it will work just fine.

[17:13] *** sftp left
[17:14] *** sftp joined
[17:17] <cxreg> how come "for [1,2,3] { .say }" produces different output than "[1,2,3].say"?

[17:17] <phenny> cxreg: 06:35Z <mberends> tell cxreg your MiniDBD::Pg passes 24 of the 32 common tests, you're welcome to merge when you like.

[17:17] <cxreg> both print a single line, one with spaces and one without

[17:19] <moritz_> rakudo: (1, 2, 3).say

[17:19] <p6eval> rakudo d9a5ac: OUTPUT«123␤»

[17:19] <moritz_> rakudo: [1, 2, 3].say

[17:19] <p6eval> rakudo d9a5ac: OUTPUT«123␤»

[17:19] <pmichaud>     #?rakudo todo '<!before>'

[17:19] <pmichaud>     is(+('.2 1' ~~ /<!before \.> \d/), 1, '<!before>');

[17:19] <pmichaud>     is +$/.keys, 0, '<!before \\.> does not capture';

[17:19] <moritz_> rakudo: for [1, 2, 3] { .say }

[17:20] <pmichaud> ...huh?

[17:20] <p6eval> rakudo d9a5ac: OUTPUT«1 2 3␤»

[17:20] <moritz_> pmichaud: should probably be <!after \.>

[17:21] <pmichaud> moritz_: I guess we're testing the !, and not the 'before' part?

[17:21] <moritz_> pmichaud: might depend on where these tests are coming from

[17:22] <pmichaud> t/spec/S05-metasyntax/angle-brackets.t

[17:22] <moritz_> then yes

[17:22] <pmichaud> but the second line is odd also.

[17:22] <pmichaud> Rakudo says (and I agree) that $/.keys is 1

[17:22] <pmichaud> sorry

[17:23] <pmichaud> +$/.keys is 1

[17:23] <moritz_> is Match.keys the same as (Match.hash.keys, Match.list.keys).flat

[17:23] <moritz_> ?

[17:23] <pmichaud> I think that we should treat $/ like any other scalar

[17:23] <pmichaud> my $a = 5;   say +$a.keys;

[17:24] <pmichaud> rakudo: my $a = 5;   say +$a.keys;

[17:24] <p6eval> rakudo d9a5ac: OUTPUT«1␤»

[17:24] <moritz_> I think that's not a good idea

[17:24] <pmichaud> and if you want the hash portion or the list portion, you have to explicitly ask for it.

[17:25] <moritz_> I can imagine two sensible reactions: either die, or return both hash and list keys

[17:25] <cxreg> moritz_: so do you think that's expected, or just inconsistent use of whatever perl6's $" is?

[17:25] <szabgab> is there a way to know if a for loop has ended naturally or via a call to   last;   ?

[17:25] <pmichaud> cxreg: what you provided is expected

[17:25] <cxreg> pmichaud: ok, in both cases say() is called once

[17:25] <cxreg> just checking

[17:25] <moritz_> $/.keys always returning 0 would be very surprising

[17:25] <pmichaud> cxreg: yes.  It's the difference between     say [1,2,3]   and [1,2,3].say

[17:26] <moritz_> rakudo: say [1, 2, 3]

[17:26] <pmichaud> moritz_: in that case, I'm okay with fail, yes.

[17:26] <p6eval> rakudo d9a5ac: OUTPUT«1 2 3␤»

[17:26] <pmichaud> anyway, I'm going to todo the test for now.

[17:26] <moritz_> pmichaud: I'd rather prefer the other interpretation, but both are fine

[17:26] <pmichaud> (requesting spec clarification)

[17:26] *** Sarten-X left
[17:26] <moritz_> pmichaud: then please change the test to use .caps

[17:26] <cxreg> pmichaud: i see that theres a difference, but i dont know why :)  i'll rtfs(pec|ource)

[17:26] <moritz_> then it's clear what's meant

[17:27] <pmichaud> moritz_: well, .caps is broken in my branch also, so I need to get it fixed as well :)

[17:27] <moritz_> cxreg: say($thing) converts $thing to a string

[17:27] <pmichaud> but yes, .caps ++

[17:27] <szabgab> good evening everyone!

[17:27] <moritz_> cxreg: which inserts spaces

[17:28] <moritz_> szabgab: good evening. I don't think there's a good answer to your questions, except maybe via a (NYI) CONTROL block setting stuff

[17:29] <pmichaud> shortly one could do   "last $sentinel"   and then check the results for the $sentinel value... or stuff like that.

[17:29] <pmichaud> (nyi, but I hope to implement today or tomorrow)

[17:29] <szabgab> python has this     for ....   else:  thing

[17:29] <pmichaud> szabgab: see "sink"

[17:29] <szabgab> and else executes only if break was not called

[17:29] <szabgab> or maybe if it was

[17:30] <moritz_> szabgab: I thought that checked if there was no iteration, not if it was prematurely aborted?

[17:30] <szabgab> nope, it fires if break was called

[17:30] <moritz_> std: do for 1..3 { } || do { say "OH NOEZ" }

[17:30] <p6eval> std 31553: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/1IB1BtgpfW line 1:␤------> [32mdo for 1..3 { }[33m⏏[31m || do { say "OH NOEZ" }[0m␤    expecting horizontal whitespace␤Parse failed␤FAILED 00:01 113m␤»

[17:31] <moritz_> std: for 1..3 { } || do { say "OH NOEZ" }

[17:31] <p6eval> std 31553: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/9dGlVW6HoZ line 1:␤------> [32mfor 1..3 { }[33m⏏[31m || do { say "OH NOEZ" }[0m␤    expecting horizontal whitespace␤Parse failed␤FAILED 00:01 109m␤»

[17:31] <moritz_> std: for 1..3 { } or do { say "OH NOEZ" }

[17:31] <p6eval> std 31553: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/H31Ws4WgRq line 1:␤------> [32mfor 1..3 { }[33m⏏[31m or do { say "OH NOEZ" }[0m␤    expecting horizontal whitespace␤Parse failed␤FAILED 00:01 109m␤»

[17:31] <moritz_> std: my @a = do for 1..3 { }

[17:31] <p6eval> std 31553: OUTPUT«ok 00:01 111m␤»

[17:31] <szabgab> http://paste.scsys.co.uk/46353

[17:31] <szabgab> that's prime in python

[17:33] <pmichaud> szabgab: if I'm reading that correctly, the 'break' prevents the else, not causes it.

[17:33] <pmichaud> szabgab: if we find a factor, we break (and the 'else' doesn't get invoked)

[17:33] <szabgab> yes, you are right

[17:33] <pmichaud> in perl 6, one would do

[17:35] <pmichaud> for 2..10 -> $n {  for 2..$n -> $x { last 1 if $n %% $x; Nil } || say "$n is prime"; }

[17:35] <pmichaud> might need a paren there

[17:35] <pmichaud> for 2..10 -> $n {  (for 2..$n -> $x { last 1 if $n %% $x; Nil }) || say "$n is prime"; }

[17:35] <szabgab> rakudo: for 2..10 -> $n {  (for 2..$n -> $x { last 1 if $n %% $x; Nil }) || say "$n is prime"; }

[17:35] <pmichaud> actually, the Nil isn't even needed.

[17:36] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤5 is prime␤7 is prime␤»

[17:36] <szabgab> rakudo: for 2..10 -> $n {  (for 2..$n -> $x { last 1 if $n %% $x; }) || say "$n is prime"; }

[17:36] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤5 is prime␤7 is prime␤»

[17:36] <szabgab> nice

[17:36] <pmichaud> I'm surprised that works in rakudo. 

[17:36] <moritz_> if you don't bother about printing which number can be divided by which other, you can also get rid of the inner loop completly, and use a junction

[17:36] <pmichaud> (it probably works "by accident" at the moment)

[17:37] <moritz_> if $n %% none(2..$n.sqrt) { say "$n is prime"; take $n; }

[17:37] <szabgab> rakudo: for 2..16 -> $n {  (for 2..$n -> $x { last 1 if $n %% $x; }) || say "$n is prime"; }

[17:37] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤5 is prime␤7 is prime␤11 is prime␤13 is prime␤»

[17:37] <szabgab> rakudo: for 2..16 -> $n {  (for 2..$n -> $x { last  if $n %% $x; }) || say "$n is prime"; }

[17:37] <moritz_> pmichaud: I've unfudged a whole lot of tests that use the return values of if/for/while/$whatever

[17:37] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤5 is prime␤7 is prime␤11 is prime␤13 is prime␤»

[17:37] <Juerd> Add a sqrt :)

[17:37] <moritz_> pmichaud: so even if it works "accidentally", it won't break accidentally :-)

[17:37] *** Sarten-X joined
[17:37] <pmichaud> anyway, the result of a for loop is the collected results of all of its block executions.

[17:38] <pmichaud> (like a .map)

[17:38] <szabgab> rakudo: for 2..16 -> $n {  (for 2..$n.sqrt -> $x { last  if $n %% $x; }) || say "$n is prime"; }

[17:38] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤4 is prime␤5 is prime␤6 is prime␤7 is prime␤8 is prime␤9 is prime␤11 is prime␤13 is prime␤15 is prime␤»

[17:39] <szabgab> rakudo: 4.sqrt

[17:39] <p6eval> rakudo d9a5ac:  ( no output )

[17:39] <szabgab> rakudo: say 4.sqrt

[17:39] <p6eval> rakudo d9a5ac: OUTPUT«2␤»

[17:39] <moritz_> rakudo: for 2..16 -> $n { say "$n is prime" if $n %% none(2..$n) 0

[17:39] <pmichaud> maybe ($n.sqrt)?  (shouldn't be

[17:39] <p6eval> rakudo d9a5ac: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 11␤»

[17:39] <szabgab> rakudo: for 2..16 -> $n {  (for 2..sqrt $n -> $x { last  if $n %% $x; }) || say "$n is prime"; }

[17:39] <moritz_> rakudo: for 2..16 -> $n { say "$n is prime" if $n %% none(2..$n) }

[17:39] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤4 is prime␤5 is prime␤6 is prime␤7 is prime␤8 is prime␤9 is prime␤11 is prime␤13 is prime␤15 is prime␤»

[17:39] <p6eval> rakudo d9a5ac:  ( no output )

[17:40] <moritz_> rakudo: for 2..16 -> $n { say "$n is prime" if $n %% one(2..$n) }

[17:40] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤5 is prime␤7 is prime␤11 is prime␤13 is prime␤»

[17:40] <pmichaud> afk, lunch & errands

[17:40] <moritz_> every number is divisible by itself, so I need one() instead of none()

[17:41] <ash_> rakudo: for 2..16 -> $n { say "$n is prime" if $n %% none(2..$n.sqrt) } # moritz, i think that is slightly faster

[17:41] <p6eval> rakudo d9a5ac: OUTPUT«2 is prime␤3 is prime␤5 is prime␤7 is prime␤11 is prime␤13 is prime␤»

[17:41] <moritz_> ash_: right

[17:41] <ash_> granted, there is probably another way thats faster than that 

[17:41] <ash_> but still 

[17:41] <Juerd> s/slightly/much/ for big $n

[17:41] *** patspam joined
[17:43] *** clintongormley left
[17:44] *** rgrau_ left
[17:45] <ash_> i like how in math, there are 'industrial strength' prime numbers, since its to computationally expensive to make sure they are really prime, they just check if they are statistically likely to be prime 

[17:46] <ash_> i guess thats not for math, they use real prime numbers, i guess thats more for cryptography

[17:46] <moritz_> well, the strength of a good stochastic prime tests is quite good

[17:46] *** kfo_ joined
[17:46] <moritz_> so good that the probabilty of getting a false positive through cosmic rays while brute-forcing it is higher than the a failure of the statistical test

[17:47] <ash_> is there a shortcut for getting the words of a file that is passed to a perl6 program? 

[17:47] <arnsholt> The joys of stochastic computing ^^

[17:48] <moritz_> ash_: lines».words

[17:48] <ash_> so @*IN.lines>>.words? 

[17:48] <pmichaud> $*IN

[17:48] <moritz_> I actually meant lines».words when I wrote lines».words :-)

[17:48] <moritz_> lines() is like the perl 5 magic <> in list context

[17:48] <ash_> oh, neat

[17:49] <szabgab> btw is there a way to specify the command line args similar to how one can specify params of a sub ?

[17:49] <ash_> it defaults to $*IN? nice

[17:49] <moritz_> szabgab: yes, sub MAIN($mandatory, Bool :$named-option) { ... }

[17:49] <moritz_> rakudo: sub MAIN($mandatory, Bool :$named-option) { ... }

[17:49] <szabgab> ty

[17:49] <p6eval> rakudo d9a5ac: OUTPUT«Usage:␤/tmp/5eZMASNBBm [--named-option] mandatory␤»

[17:49] *** kfo left
[17:50] <moritz_> and it's even implemented!

[17:50] <moritz_> patrickas++

[17:50] * szabgab is rebuilding everything

[17:50] <sorear> good morning #perl6

[17:51] <slavik> morning? it's afternoon :P

[17:51] <szabgab> moritz_, btw I was trying to build the smartlinks on Windows and it blew uo

[17:51] <szabgab> up

[17:51] <moritz_> slavik: it's always morning *somewhere*

[17:51] <tylercurtis> ash_: also, @*IN.slurp.words should work.

[17:52] <slavik> I'm american, my time matters, not yous :P

[17:52] <szabgab> is pugs:util/smartlinks.pl still in use for that ?

[17:52] <slavik> yours*

[17:52] <moritz_> szabgab: yes

[17:52] <szabgab> so in util/version_h.pl it has    my $output = `svn info 2>&1; echo \$?`;

[17:53] <szabgab> any idea why is the echo part there ?

[17:53] <moritz_> I probably cargo-culted it from somewhere

[17:53] <moritz_> should be fine to remove it

[17:53] <szabgab> so I uncargo cult it now :)

[17:53] <moritz_> szabgab++

[17:53] <szabgab> and then see what else I need to change to make it work on my brand new windows machine :)

[17:54] <moritz_> I also get some strange behaviour from it: it says me that all $n smartlinks it finds are broken, but still smart-links them in the synopsis documents

[17:55] <pugssvn> r31554 | szabgab++ | remove cargo cult 

[17:56] *** tadzik joined
[17:56] <szabgab> oh boy, I should have never mentioned it :)

[17:57] <moritz_> szabgab: I don't expect you to fix it, fwiw. It's likely me who broke it :-)

[18:04] *** dakkar joined
[18:19] *** rv2733 joined
[18:26] *** skids left
[18:30] *** skids joined
[18:32] *** arthur-_ joined
[18:40] *** rurban joined
[18:43] *** allbery_b left
[18:44] *** allbery_b joined
[18:44] <allbery_b> oops

[18:45] *** orafu left
[18:46] *** orafu joined
[18:51] *** eternaleye left
[18:53] *** rv2733 left
[18:54] *** arthur-_ left
[18:58] *** eternaleye joined
[18:59] *** FardadJalili joined
[19:02] *** ash_ left
[19:05] *** mikehh joined
[19:05] *** cono left
[19:06] *** ash_ joined
[19:06] *** cono joined
[19:11] *** arthur-_ joined
[19:11] *** arthur-_ left
[19:13] *** clintongormley joined
[19:15] <arnsholt> Making PAST trees has in it the potential of quite inscrutable code methinks ^_^

[19:17] *** whiteknight joined
[19:18] *** lichtkind joined
[19:22] *** FardadJalili left
[19:24] *** skids left
[19:25] *** skids joined
[19:26] *** tylercurtis left
[19:28] <ash_> is perl6 io really slow currently?

[19:29] <arnsholt> Rakudo certainly is kinda slow

[19:29] <arnsholt> What are you using it for?

[19:30] <ash_> ultimately, counting unique words 

[19:31] <ash_> but it seems to be hanging at one point and i can't tell why 

[19:31] <ash_> ah, nevermind i am just being dumb

[19:31] <moritz_> expect it to be 100 to 1000 times slower than Perl 5 atm

[19:35] <ash_> i am not worried about speed, just playing http://stackoverflow.com/questions/3169051/code-golf-word-frequency-chart is what  i am doing 

[19:35] <ash_> in perl6, there are ruby, perl, python, etc... most popular languages have solutions to it, i haven't seen a perl6 though

[19:39] *** Ross left
[19:39] *** Ross joined
[19:42] *** whiteknight left
[19:44] *** meppl left
[19:45] *** mantovani joined
[19:47] <TimToady> the differences between lines and words really bugs me today

[19:47] <mathw> Any differences in particular?

[19:48] <moritz_> TimToady: do you want words() to default to $*ARGFILES, just like lines()?

[19:48] <TimToady> lines("filename") vs words("string with words")

[19:48] <TimToady> it's the Str case that bugs me

[19:49] <TimToady> I don't mind either of them defaulting to IO

[19:49] <TimToady> but I suspect lines("filename") should become lines("filename".IO)

[19:50] <TimToady> and then both words(Str) and lines(Str) just do string splits/combs

[19:51] <TimToady> alternately, IO is Cool enough to retarget string methods to an implicit slurp or cat

[19:51] <TimToady> cat being a lazy slurp in my mind

[19:51] <szabgab> I saw this example several times already   if $x > all(@values) {}     and while it is nice I am not sure this is all that convincing, so it might be faster than if $x > max(@values) but isn't there a better example ?

[19:51] <mathw> Hmm that is an irritating inconsistency

[19:52] <TimToady> szabgab: no, > all can short circuit, while max can't easily

[19:52] <szabgab> yes, so it is faster, I understood that already :)

[19:52] <TimToady> right, maybe I'm not entirely caught up on sleep yet...

[19:53] <szabgab> but I don't think that's a huge gain in small arrays

[19:53] <TimToady> when you say "better example", what kind of an example are you looking for?

[19:53] <szabgab> so while my first reaction was "cool"  I am now going to talk infront of a bunch of Python developers...

[19:55] <szabgab> by "better example" I mean something that even after thinking about it a bit I still think it is a major gain :)

[19:55] <TimToady> well, $min < all(@values) < $max is better

[19:55] <pmichaud> ....except that probably doesn't work in Rakudo atm.

[19:56] * tadzik will be talking about Perl6 on a local Perl workshop

[19:56] <szabgab> all(@values) ~~ regex {}

[19:56] <TimToady> or any(@list1) > all(@list2)

[19:56] <TimToady> that one might do as well with max though

[19:57] <TimToady> if all(@a) == any(@b)

[19:57] <mathw> I also like $needle == any(@haystack)

[19:57] <pmichaud> if any(@list1) == any(@list2)

[19:57] <pmichaud> if  any(@list1) == value

[19:57] <TimToady> arguably we're just doing set theory there

[19:57] <TimToady> so maybe something with none or one

[19:57] <pmichaud> if one(@list) == value

[19:58] <pmichaud> if one(@list) > value

[19:58] <jnthn> pmichaud: Why wouldn't that work in Rakudo ATM?

[19:58] <pmichaud> jnthn: because we don't chain junctions properly.

[19:58] <jnthn> ...chain junctions?

[19:59] <ash_> rakudo: say 1 < 2 < 3

[19:59] <pmichaud> $min < all(@values) < $max   doesn't decompose simply.

[19:59] <p6eval> rakudo 1e7012: OUTPUT«1␤»

[19:59] <jnthn> I figured $min < all(@values) < $max is really like $min < all(@values) && all(@values) < $max

[19:59] <TimToady> rakudo: say [\+] [\+] 1 xx 5

[19:59] <p6eval> rakudo 1e7012:  ( no output )

[19:59] <ash_> rakudo: my @a = 3..5; say 1 < all(@a) < 6;

[19:59] <pmichaud> $min < any(@values) < $max   doesn't work, though.

[19:59] <jnthn> pmichaud: e.g. each part collapses

[19:59] <TimToady> that's still borked

[19:59] <szabgab> the one(@list) > value seems to be already eliminating a lot more code

[19:59] <moritz_> (that's in RT and in some spectests already)

[19:59] <p6eval> rakudo 1e7012: OUTPUT«all(Bool::True)␤»

[20:00] <moritz_> rakudo: say [\+] list([\+] 1 xx 5)

[20:00] <p6eval> rakudo 1e7012:  ( no output )

[20:00] <moritz_> rakudo: say [\+] [[\+] 1 xx 5]

[20:00] <szabgab> I think implementing that would need a sort

[20:00] <pmichaud> consider:    3 < any(1,7) < 5

[20:00] <p6eval> rakudo 1e7012: OUTPUT«1361015␤»

[20:00] <szabgab> or a loop

[20:00] *** tri1 joined
[20:00] <pmichaud> rakudo:   say 3 < any(1,7) < 5;

[20:00] <jnthn> pmichaud: Would be true

[20:00] <p6eval> rakudo 1e7012: OUTPUT«any(Bool::True, Bool::False)␤»

[20:00] <pmichaud> jnthn: would be true?  which of 1 or 7 is between 3 and 5?

[20:01] <ash_> rakudo: say ?(3 < any(1, 7) < 5);

[20:01] <p6eval> rakudo 1e7012: OUTPUT«1␤»

[20:01] <jnthn> pmichaud: Ah, you're expecting the junction to thread through the whole thing?

[20:01] <pmichaud> jnthn: that's what TimToady++ told me once

[20:01] <jnthn> Oh.

[20:01] <TimToady> it's hard

[20:01] <jnthn> OK, rather you than me to implement that one.

[20:01] <pmichaud> rakudo:  my $x = 1|7;   say ?(3 < $x < 7);

[20:01] <p6eval> rakudo 1e7012: OUTPUT«1␤»

[20:02] <pmichaud> rakudo:  my $x = 1|7;   say ?(3 < $x < 5);

[20:02] <p6eval> rakudo 1e7012: OUTPUT«1␤»

[20:02] <TimToady> basically, chained comparisons have to be a single variadic function of args and ops

[20:02] <pmichaud> right.

[20:02] <pmichaud> and rakudo doesn't do that right now.  :-)

[20:02] <pmichaud> rakudo is still doing the old decomposition into the && form

[20:02] <ash_> rakudo: my Str|Int $a = 1; # just curious...

[20:02] <p6eval> rakudo 1e7012: OUTPUT«===SORRY!===␤In "my" declaration, typename Str must be predeclared (or marked as declarative with :: prefix) at line 11, near "|Int $a = "␤»

[20:02] <jnthn> Ah, LTA error.

[20:03] <jnthn> std: my Str|Int $a = 1;

[20:03] <p6eval> std 31554: OUTPUT«[31m===[0mSORRY![31m===[0m␤Multiple prefix constraints not yet supported at /tmp/VVEh2CwsxT line 1:␤------> [32mmy Str[33m⏏[31m|Int $a = 1;[0m␤Malformed my at /tmp/VVEh2CwsxT line 1:␤------> [32mmy Str[33m⏏[31m|Int $a = 1;[0m␤    expecting any of:␤ multi_declarator␤

[20:03] <p6eval> ..sco…

[20:03] <jnthn> STD does better

[20:03] <TimToady> ash_: that form isn't allowed anymore

[20:03] <pmichaud> jnthn: the deref_unless_object mod works great EXCEPT

[20:03] <ash_> oh, thats not? 

[20:03] <TimToady> junctions are too ambiguous in typenames

[20:03] <pmichaud> &CREATE_HASH_FROM_LOW_LEVEL seems to fail when given a parrot;Hash coming back from a match object.

[20:03] <pmichaud> any ideas?

[20:03] <TimToady> note for instances that & is a valid sigil

[20:04] <jnthn> pmichaud: huh, I thought it was meant to take a Parrot Hash and wrap it up in a Perl 6 one.

[20:04] <TimToady> and | is a valid prefix

[20:04] <pmichaud> jnthn: so did I.

[20:04] <pmichaud> it now gives me back some sort of object whose type I'm unable to identify

[20:04] <pmichaud> probably a punned class

[20:04] <jnthn> pmichaud: I fear that may be a case of symptom rather than cause...

[20:04] <jnthn> Oh

[20:04] <pmichaud> er, punned role

[20:04] <jnthn> Maybe

[20:04] <pmichaud> (since Hash is currently a role)

[20:04] <jnthn> But hm

[20:05] <jnthn> Yeah...that ones brining in line with the others.

[20:05] <jnthn> I'm not entirely sure why the change would lead to that.

[20:05] <ash_> TimToady: so, is there a way to represent some sort of union type?

[20:05] <jnthn> When is this happening?

[20:05] <TimToady> ash_: use a subset

[20:05] <jnthn> At startup, or it just causes some test fails?

[20:05] <pmichaud> Match.hash, primarily

[20:05] <TimToady> or perhaps a where in the sig

[20:05] <pmichaud> causes a few test fails, only in S05

[20:06] <TimToady> rakudo: say [+] [1,2,3]  # WRONG

[20:06] <p6eval> rakudo 1e7012: OUTPUT«6␤»

[20:06] <pmichaud> but I can reproduce the problem with Q:PIR also

[20:06] <pmichaud> TimToady: should be 3?

[20:06] <TimToady> yes

[20:06] <pmichaud> okay.

[20:06] <TimToady> [] should never flatten in a listop

[20:06] <pmichaud> I suspect it's a bug in reduce

[20:07] <pmichaud> rakudo:  say + [1,2,3];

[20:07] <p6eval> rakudo 1e7012: OUTPUT«3␤»

[20:07] <ash_> something like:  subset StrOrInt of Mu where { Str($^a) & Int($^a) } ? 

[20:07] <jnthn> self.Regex::Match::hash # this hands back a Parrot Hash?

[20:08] <TimToady> just subset StrOrInt of Mu where Str | Int;

[20:08] <pmichaud> jnthn: yes.

[20:08] <TimToady> what you have coerces

[20:08] <ash_> ah, cool, thanks

[20:08] <jnthn> rakudo: subset StrOrInt where Str|Int; say 42 ~~ StrOrInt; say 'lol' ~~ StrOrInt; say 4.2 ~~ StrOrInt

[20:08] <p6eval> rakudo 1e7012: OUTPUT«1␤1␤0␤»

[20:08] <jnthn> \o/

[20:08] <ash_> neat, it already works too 

[20:09] <ash_> TimToady++ jnthn++ 

[20:09] <jnthn> ash_: That happens sometimes. ;-)

[20:09] <moritz_> jnthn, pmichaud: do you have any examples of how to iterate a (parrot) hash in NQP?

[20:09] <jnthn> pmichaud: OK, color me confused. :-)

[20:09] <pmichaud> jnthn: more to the point, '!dispatch_::'(match_obj, 'hash', Regex::Match)   definitely gives me back a parrot;Hash

[20:09] <jnthn> oh, interesting

[20:10] <pmichaud> and it does that whether match_obj is containerized or not.

[20:10] <pmichaud> let me re-build and re-verify.

[20:10] <jnthn> pmichaud: I wonder if !dispatch_:: is failing to deref and invocant or not

[20:10] <jnthn> OK

[20:10] <jnthn> I've got a feeling you'll need to push this somewhere for me to debug - it's rather hard to guess at.

[20:10] <pmichaud> I tried having it deref the invocant, that didn't seem to help.

[20:11] <pmichaud> okay, I'll push to a branch.

[20:12] <TimToady> sorear: I'm confused by http://irclog.perlgeek.de/perl6/2010-06-25#i_2478565 since proto subs always have an OUTER::

[20:12] <TimToady> moritz_, cognominal: re http://irclog.perlgeek.de/perl6/2010-06-25#i_2479440, every non-parameterized block has an implicit <-> $_ = OUTER::<$_> (or some such), which may be optimized away when we know at compile time there is no argument.

[20:13] <moritz_> wow, you're really far behind on backlog :/

[20:14] <TimToady> alas

[20:14] <jnthn> pmichaud: OK. I need a break, so going for a short walk. bbi15 or so.

[20:15] <pmichaud> jnthn: wfm

[20:15] <TimToady> I'm also bugged by the need for parens in 'for lines() {...}'

[20:15] <pmichaud> branch is 'deref' when you get back.

[20:15] <TimToady> if we made lines and words only work on strings, and defaulted slurp and cat instead

[20:15] <pmichaud> we could bring back  =<>   :-)

[20:15] <TimToady> then it'd be 'for cat.lines {...}'

[20:16] <TimToady> and since lines would be a method, it wouldn't need ()

[20:17] <TimToady> slurp and cat would also be defined in Str to take a string as a filename

[20:17] <TimToady> so "filename".cat or .slurp would work

[20:18] <pmichaud> that feels weird, unless cat changed recently

[20:18] <TimToady> there is no cat yet

[20:18] *** ciphertext left
[20:18] <pmichaud> S32 has one.

[20:19] <pmichaud>  our Cat multi cat( **@list )

[20:19] <TimToady> hmm, so there is

[20:19] *** meppl joined
[20:19] <lue> ohai o/

[20:20] <ingy> greetings

[20:20] <moritz_> I also thought we were moving away from misguided Unix names

[20:20] <TimToady> well, we need some kind of lazy slurp that returns a Cat object

[20:21] <TimToady> .sip or some such

[20:21] *** bjarneh left
[20:21] <lue> what is this Cat object?

[20:21] <TimToady> a lazy string, basically

[20:21] *** bjarneh joined
[20:21] <TimToady> at least until you ask it for .chars

[20:22] <TimToady> we'll need a way to ask, "is this position at the end of the string" without actually requesting the string length

[20:22] <pmichaud> jnthn: found quite a few more clues -- still looking.

[20:23] *** clintongormley left
[20:23] <lue> is $a[$x] == $a[*-1] ? (where $a is the string and $x is any number.)

[20:23] <pmichaud> in some sense we almost want $*ARGFILES to be shorter.

[20:23] <pmichaud> so that one could do:

[20:24] <pmichaud>     for @$*ARGFILES { ... }

[20:24] <pmichaud> without it looking so ugly.  :-)

[20:24] <ingy> is there a nicer test than `grep` to see if an elem is in an array?

[20:24] <TimToady> $elem == any(@array)

[20:24] <pmichaud> ingy: if any(@array) eq $elem

[20:24] <TimToady> or ===, or eqv, or...

[20:24] <ingy> grazi

[20:24] <pmichaud> any(@array) ~~ $elem

[20:25] <pmichaud> (since grep does smartmatching as well)

[20:26] *** ciphertext joined
[20:26] <TimToady> but has lazy tendencies rather than parallel, short-circuit tendencies

[20:28] * ingy is going to ask for a code review after he finishes this testml-pm6 port

[20:28] <TimToady> lue: um, no

[20:28] <ingy> going pretty well, all considered though

[20:28] <pmichaud> jnthn: okay, I think I found it.

[20:30] <pmichaud> it's indeed a problem with !dispatch_:: .

[20:31] <timbunce> java uses multiple dispatch to select a constructor that matches the arguments to new() based on the number and type of positional arguments. Any issues with doing the same for perl6?

[20:31] * timbunce feels uncomfortable trying to interface two languages where I don't know either of them well!

[20:32] <lue> ah well, worth a shot :)

[20:32] <pmichaud> timbunce: works in perl 6, yes.

[20:32] <timbunce> pmichaud: cool, thanks.

[20:32] <pmichaud> timbunce: btw, rakudo now has --version

[20:32] <timbunce> pmichaud: :)

[20:32] <pmichaud> text improvement suggestions welcomed.

[20:32] <pmichaud> pmichaud@plum:~/rakudo$ ./perl6 --version

[20:32] <pmichaud> This is Rakudo Perl 6, version 2010.06-174-g979a34a

[20:32] <pmichaud> Copyright 2008-2010, The Perl Foundation

[20:33] <pmichaud> for monthly releases, the version number is just "mmmm.yy"

[20:33] <pmichaud> for versions obtained via git checkout, you get the git-describe value.

[20:33] <ash_> timbunce: java doesn't do multi-dispatch, btw. It does method selection at compile time so its just overloading, not multi-dispatch 

[20:35] <timbunce> ash_: thanks, my terminology is all over the place. I'm mapping the overloading to perl6 multi-dispatch.

[20:35] <ash_> they are similar, but multi-dispatch happens at runtime not compile-time 

[20:37] <ingy> hi timbunce 

[20:38] <timbunce> I've forgotten which pastebin the channel uses (it's not in the header shown by my irc client)

[20:38] * timbunce waves at ingy

[20:38] <ingy> :)

[20:38] <pmichaud> timbunce: I don't think any of them automatically post to the channel.  

[20:38] <TimToady> though I suppose $string.substr($pos,1) would be "" if $pos were at the end of the cat string

[20:38] <TimToady> so maybe we don't need a special method

[20:38] <pmichaud> so, any pastebin you prefer is fine.

[20:40] <timbunce> Here's an example of what java2perl6 produces at the moment: http://paste.scsys.co.uk/46360 comments welcome. (The particular class shown isn't relevant, I just happen to be using this one as it has lots of constructors.)

[20:41] <moritz_> those should be all 'multi method new(...)'

[20:41] <timbunce> moritz_: ah, good, my first bug report :)

[20:45] <moritz_> timbunce: already reported

[20:45] <moritz_> and there are tests for it too

[20:46] <lue> About ::= "This does the same as :=, then marks any destination parameters as readonly". What are destination parameters here?

[20:46] <ingy> can someone explain this to me please: http://nopaste.snit.ch/21815

[20:46] <pmichaud> lue: targets

[20:46] <moritz_> if you want runnable code, substitute all the non-resolved java::bla type names with Any

[20:46] <pmichaud> lue: it makes the lhs non-rebindable.

[20:47] *** _mpu left
[20:47] <lue> ah, I thought so. destination parameters made me think there was something in one of the variables :)

[20:48] <ash_> $a ::= $b;  $a ::= $c # fails on the ::= $c, right? 

[20:48] <pmichaud> ash_: iiuc, yes.

[20:48] *** sawyer_ left
[20:48] <ingy> why doesn't $p bind to an elem of $pp?

[20:48] *** sawyer_ joined
[20:48] <lue> but ($a is rw) ::= $b; $a ::= $c would work, according to spec (?)

[20:48] <timbunce> moritz_: there's a type-mapping mechanism so you can control the mapping on a per-project basis. Unmapped types get recursed into (by default) so a whole tree of .pm6 files get generated.

[20:49] *** _mpu joined
[20:51] <ash_> ($a is rw) ::= $b; seems like it should fail, IMO, since they mean two different things, either that, or after the ::= is applied $a should be changed to readonly 

[20:52] <lue> "…any destination parameters as readonly (unless the individual parameter overrides this with either the rw trait or the copy trait)"

[20:53] <jnthn> pmichaud: back

[20:53] <jnthn> pmichaud: ah, found it?

[20:55] <lue> std: my $a = 3; my $b = 2; my $c ::= $a; my $c ::= $b;

[20:55] <p6eval> std 31554: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $c (see line 1) at /tmp/bjw_0NdTqZ line 1:␤------> [32my $a = 3; my $b = 2; my $c ::= $a; my $c[33m⏏[31m ::= $b;[0m␤ok 00:01 113m␤»

[20:55] <lue> std: my $a = 3; my $b = 2; my $c ::= $a; $c ::= $b;

[20:55] <p6eval> std 31554: OUTPUT«ok 00:01 110m␤»

[20:55] <lue> O.o

[20:56] * lue thinks he found a STD bug (unless catching that is not STD's job)

[20:57] <pmichaud> STD just checks syntax, I believe.

[20:58] <lue> so STD won't help in finding out if ($a is rw) or ($a is copy) overrides the ro part of ::=

[20:59] <pmichaud> in general I'm not sure it can, since ::= can be a runtime operation

[20:59] <lue> the spec seems to say it has to ...

[21:04] <lue> ah well, let's see if I can implement ::= !

[21:04] *** alexbobP left
[21:04] <pmichaud> do you still have the := patch somewhere that I can review?

[21:05] <lue> ah, lemme update the nopaste.

[21:06] *** tadzik left
[21:12] *** timbunce left
[21:12] *** tri1 left
[21:12] <ingy> if I have $module, $class and $method string variables, how can I load $module, lookup $method and call it (if it exists) on $class?

[21:14] <ingy> I think I got most of it, except the call part

[21:14] <jnthn> you can do e.g. $obj."$method_name"() for that part

[21:15] <ash_> isn't it like ::<$module> to get the module? 

[21:15] <lue> pmichaud: http://gist.github.com/463775

[21:16] <lue> (gah, I hate my computer. What should have taken 2 minutes took me 10 *sob*)

[21:16] *** timbunce joined
[21:17] *** Ross left
[21:18] <eiro> 

[21:18] <lue> how do I revert one file that keeps me from merging (don't need the changes) ?

[21:18] <lue> .u 

[21:18] <phenny> U+0006 (No name found)

[21:19] <pmichaud> lue: git checkout file

[21:19] <pmichaud> works for me

[21:19] <ash_> .u comet 

[21:19] <phenny> U+2604 COMET (☄)

[21:19] <pmichaud> .u snowman

[21:19] <phenny> U+2603 SNOWMAN (☃)

[21:20] <ash_> .u dice

[21:20] <phenny> ash_: Sorry, no results for 'dice'.

[21:20] <ash_> hmmm wonder how you get the die faces 

[21:20] <lue> .u die

[21:20] <phenny> U+2680 DIE FACE-1 (⚀)

[21:20] <ash_> .u die face-2

[21:20] <phenny> U+2681 DIE FACE-2 (⚁)

[21:20] <jnthn> .u live

[21:20] <phenny> jnthn: Sorry, no results for 'live'.

[21:21] <pmichaud> .u fail

[21:21] <jnthn> aw

[21:21] <phenny> pmichaud: Sorry, no results for 'fail'.

[21:21] * lue is still hunting for the blue box unicode character :)

[21:21] <ash_> wrong meaning of die :P 

[21:21] <pmichaud> jnthn: okay, I figured out the problem I think.

[21:21] <jnthn> OK?

[21:21] <jnthn> pmichaud: What was it, ooc?

[21:22] <pmichaud> I have to make sure that the thing I pass to Regex::Match::hash is dereferenced

[21:22] <jnthn> Aha

[21:22] <ash_> rakudo: my $a = 'a b c'; $a.::Str::say

[21:22] <p6eval> rakudo 1e7012: OUTPUT«a b c␤»

[21:22] <pmichaud> but this points out a possible flaw in the "object" test

[21:22] <ash_> ingy: you can use that too, it seems 

[21:22] <pmichaud> because Regex::Match is an Object, but it's derived from Capture

[21:22] <jnthn> Ah

[21:23] <ash_> ingy: $obj.::$module::$method 

[21:23] <jnthn> But that shouldn't really end up being an issue, I thought. :S

[21:23] <sorear> TimToady: Unfortunate collision in terminology.  In that line I was speaking of protosubs by analogy to protopads, nothing to do with MMD

[21:23] <jnthn> Since at the end of the day that's really delegation-y

[21:23] <pmichaud> it does here.

[21:23] <pmichaud> because we end up calling   Capture.hash on the Regex::Match object

[21:23] <pmichaud> and .hash is still a PCCMETHOD

[21:23] <jnthn> Ah

[21:23] <jnthn> OK

[21:24] <ingy> this worked: $class.can($method_name)($class);

[21:24] <ingy> this failed: $class.$method_name();

[21:24] <jnthn> ingy: I said $class."$method_name"()

[21:24] <pmichaud> so, testing the type of the PMC only helps with objectrefs to PMCs.  It doesn't help with objectrefs to subclasses of PMCs

[21:24] <pmichaud> (quotes needed)

[21:25] <ingy> ?!

[21:25] <jnthn> ingy: Without the quotes it means "I have a code object"

[21:25] <pmichaud> $class.$method()   is different from $class."$method"()

[21:25] <pmichaud> the first attempts to apply $method to $class

[21:25] <pmichaud> the second looks up a method named "$method" in the class and invokes that

[21:26] <ingy> I save all these crazy chatlogs. Someday I'll write a book.

[21:26] <ingy> or maybe a chapter in yours :P

[21:27] <pmichaud> jnthn: anyway, I'm not sure the type test is going to work out

[21:27] <jnthn> pmichaud: *sigh* what a pita

[21:27] <pmichaud> it's okay as long as we don't have any PCCMETHODS on subclasses that we want to invoke

[21:27] *** timbunce left
[21:28] <jnthn> Well, guess you can check if there's any PMC parents too.

[21:29] <jnthn> See class.pmc - if it wasn't changed there's a PMC flag that you can test to tell you

[21:29] <jnthn> (no need to consider MRO, just chase the Object PMC's pointer to the Class PMC and a flag check)

[21:30] <jnthn> It's a couple of pointer derefs and a bitwise op, which in the current slow grand scheme of things is a drop in the ocean.

[21:30] <lue> MRO?

[21:30] <jnthn> Method Resolution Order

[21:30] <jnthn> Basically, a list of classes in the order we search them for methods

[21:31] <jnthn> In single inheritance situation, just a list of the parent classes from most to least derived

[21:31] <jnthn> In multiple inheritance, life is complicated :-)

[21:31] <jnthn> But look up C3 for the usually preferred solution.

[21:33] <pmichaud> jnthn: I don't see a flag in class.pmc that would tell us what we want.

[21:33] <jnthn> pmichaud: look for alien, iirc

[21:33] <jnthn> CLASS_has_alien_parents_SET(SELF);

[21:33] <jnthn>                 if (class_check->vtable->base_type != enum_class_Class) {

[21:34] <jnthn>                     /* Found one; that's enough. */

[21:34] <jnthn>                     CLASS_has_alien_parents_SET(SELF);

[21:34] <jnthn>                     break;

[21:34] <jnthn>                 }

[21:34] <pmichaud> okay

[21:34] <lue> .oO(good thing it's not the '50s anymore ;) )

[21:34] <pmichaud> ah, I was looking for "flag"

[21:35] <jnthn> How...sensible. ;-)

[21:36] *** ruoso left
[21:38] <ash_> alien's r in mah codez 

[21:39] <jnthn> ash_: Back then the idea was to have various interoperable "class universes", so languages could have their own class systems, and they'd just delegate when they hit the boundary.

[21:39] <lue> Latest rakudo broke Test.pir somehow, causing not a single test to go ok. There is a new parrot though...

[21:39] <lue> or rather, I upgraded parrot.

[21:40] <ash_> jnthn: makes sense, just an amusing name for it

[21:41] <jnthn> ash_: Well, if it comes from another universe... ;-)

[21:41] <ash_> :P yes, it does seem to do that 

[21:42] <lue> any reason why my Test.pir could be completely broken?

[21:46] <pmichaud> lue: I'm testing locally.

[21:51] <lue> it could be something I did, though.

[21:54] <pmichaud> lue: builds fine here, with PARROT_REVISION

[21:55] <pmichaud> trying again with parrot HEAD

[21:56] <lue> the binding works fine in interactive mode, it's just the tests are failing. every. single. one. Running a test by itself revealed a major PIR error.

[22:00] <pmichaud> afk for a bit

[22:02] <pmichaud> jnthn: ping

[22:03] <lue> here's the PIR error I get, IIUC: http://gist.github.com/464732

[22:03] <pmichaud> jnthn: unping (nm, I figured it out)

[22:03] *** masonkramer left
[22:03] *** masonkramer joined
[22:03] <jnthn> pmichaud: ok :-)

[22:04] <pmichaud> actually, re-ping :)

[22:04] <jnthn> :-)

[22:04] <jnthn> .oO( do I pong or wait for the re-unping? :-) )

[22:04] <pmichaud> actually, un-ping

[22:04] <pmichaud> :)

[22:04] <pmichaud> I'm playing with the notion that we could somehow make our find_method a lot smarter than it is now.

[22:04] <pmichaud> but it's not worth pursuing yet.

[22:04] <lue> [ jnthn: just send a waiting pong :) ]

[22:05] <jnthn> OK

[22:05] <jnthn> Oh, in p6opaque?

[22:05] <pmichaud> (smarter about dealing with PMC types)

[22:05] <jnthn> Yes, we could :-)

[22:05] <jnthn> ...?

[22:05] <pmichaud> not just in p6opaque, but also in objectref

[22:05] <jnthn> ok

[22:05] <pmichaud> i.e., if find_method on an objectref determines that it's a PCC method, then do something useful at that point.

[22:06] <pmichaud> (where I'm not yet certain what "something useful" might be)

[22:07] <jnthn> Me either ;-)

[22:07] <pmichaud> but that generally is where we get into trouble.

[22:08] <pmichaud> if we could solve that, I think we could eliminate our need for descalarref on invocants altogether

[22:08] <jnthn> Well

[22:09] <jnthn> you could go and mess with the current contents of the current call signature ;-)

[22:09] *** ive left
[22:09] <pmichaud> at the point of the find_method, we're not in a call yet, are we?

[22:09] <jnthn> No

[22:09] <jnthn> We're finding the thing to call

[22:09] <pmichaud> right

[22:09] <jnthn> The args may well not have been set up though

[22:09] <jnthn> Though I think they have

[22:09] <jnthn> Oh, in fact I'm quite sure they have

[22:09] <jnthn> We rely on that elsewhere

[22:10] <pmichaud> I thought the find_method was done before the invocation

[22:10] <jnthn> It is

[22:10] <pmichaud> (or the call sig setup)

[22:10] <jnthn> It isn't

[22:10] <jnthn> set up call sig

[22:10] <jnthn> find_method

[22:10] <jnthn> invoke result

[22:10] <pmichaud> oh!

[22:10] <pmichaud> is that newish?

[22:10] <pmichaud> like, since the pcc refactors?

[22:10] <jnthn> I thought it was always that way?

[22:10] <pmichaud> I always thought it was

[22:10] <jnthn> Well actually

[22:10] <pmichaud>     $P0 = find_method invocant, 'method'

[22:10] <jnthn> there is one op

[22:10] <jnthn> callmethod

[22:10] <pmichaud>      $P0(invocant ... )

[22:11] <jnthn> Which calls the find_method vtable and then invokes the result

[22:11] <pmichaud> right

[22:11] <jnthn> But that happens in one Parrot op

[22:11] <pmichaud> and I thought the callsig was done as part of "invoke the result" 

[22:11] <jnthn> So the op that sets up the callsig must come before that.

[22:11] * pmichaud looks

[22:11] *** _mpu left
[22:12] <pmichaud> 0000 new P0, PC9                                        P0=PMCNULL PC9=Key=PMC(0x20b60f0)

[22:13] <pmichaud> 0003 set_args PC2 (3), P0, "/dev/null", "r"	PC2=FixedIntegerArray=PMC(0x20b60b0) P0=FileHandle=PMC(0x2072190)  

[22:13] <pmichaud> 0008 callmethodcc P0, "open"                                        P0=FileHandle=PMC(0x2072190) 

[22:13] <pmichaud> You're right!

[22:13] <pmichaud> oh, but not quite

[22:13] <pmichaud> find_method is the first thing done in the callmethodcc op

[22:13] <pmichaud> which is before the callsig setup

[22:15] <pmichaud> oh well.  I'll have to keep thinking about "something useful"

[22:17] <pmichaud> anyway, I think I have the new branch working now.  All spectests pass -- now just merging to trunk and retesting for safety.

[22:17] <pmichaud> afk for a bit

[22:21] <jnthn> pmichaud: ...before the callsig setup?

[22:22] <jnthn> I thought set_args did that?

[22:26] * ingy just spent 30+ mins debugging something and has a question...

[22:26] <lue> I'm an idiot. I forgot to run `make install' :)

[22:27] <lue> that's why Test.pir failed. *embarrased smile*

[22:28] <ingy> I used module Xxx (containing a class Xxx). when I say my $class = eval('Xxx'); and then if ($class) { ... }; the 'if' is not true

[22:29] <ingy> even though I'm pretty sure $class contains a class object

[22:29] <ingy> ~$class eq 'Xxx()'

[22:29] <jnthn> ingy: Type objects are always undefined

[22:29] <jnthn> ingy: And truth defaults to definedness

[22:30] <jnthn> rakudo: if Int { say "oops" }

[22:30] <p6eval> rakudo 1e7012:  ( no output )

[22:30] <lue> .oO(Oi, ::= isn't even in the setting, and there's a panic coded in its definition in Grammar.pm!)

[22:30] <ash_> jnthn: is there something you can compare it to to see if its a class? 

[22:30] <ingy> does that make sense?

[22:31] <lue> rakudo: if Int ~~ Perl6MultiSub { say "hrm" }

[22:31] <p6eval> rakudo 1e7012: OUTPUT«===SORRY!===␤Missing block at line 11, near ""␤»

[22:31] <jnthn> lue: Multi

[22:31] <ingy> maybe a better question is how do I introspect modules (for things like classes)?

[22:31] <lue> ah.

[22:31] <jnthn> ash_: Not really 

[22:31] * lue goes and implements ::=

[22:32] <ingy> I hate being a newb

[22:32] <jnthn> Looking at the metaclass is more useful probably

[22:32] <jnthn> rakudo: say Int.HOW ~~ ClassHOW

[22:32] <p6eval> rakudo 1e7012: OUTPUT«1␤»

[22:32] <ingy> but at least I'm a newb with an agenda :D

[22:32] <ash_> rakudo: role Foo { }; say Foo ~~ Role 

[22:32] <p6eval> rakudo 1e7012: OUTPUT«1␤»

[22:32] <jnthn> ingy: Introspection is done by looking at the metaclass

[22:32] <ash_> would be cool if there was a Class like there is Role 

[22:32] <ingy> :)

[22:33] *** lest_away is now known as lestrrat

[22:34] <lestrrat> ping: TimToady

[22:34] <jnthn> rakudo: class Foo { method lol { } }; say Foo.^methods(:local)

[22:35] <p6eval> rakudo 1e7012: OUTPUT«lol␤»

[22:36] <ash_> rakudo: module Foo { }; say Foo.HOW.WHAT

[22:36] <p6eval> rakudo 1e7012: OUTPUT«Method 'HOW' not found for non-object␤  in main program body at line 11:/tmp/yPMMlA5L49␤»

[22:36] <ash_> no module how then? 

[22:36] <pmichaud> jnthn: in callmethodcc opcode:

[22:36] <pmichaud>         if (!PMC_IS_NULL(signature))

[22:36] <pmichaud>             Parrot_pcc_set_object(interp, signature, object);

[22:36] <cognominal> when deriving a grammar, how to supress or redefine operators?

[22:36] <pmichaud> so, I guess if signature is already set up....

[22:36] <lue> ingy: I'm still a newb, and I know what that's like :)

[22:36] <cognominal> ... or change their precedence.

[22:37] <pmichaud> afk a bit longer

[22:37] <lue> [it would help if an API/Design Document/etc. existed for rakudo :)]

[22:38] <ingy> lue: :)

[22:39] <jnthn> cognominal: I guess defining a new proto would do that

[22:39] <cognominal> I did not try... just reading specs.

[22:41] <ash_> cognominal: if its a completely custom grammar you'd have to make your own precedence mechanism, i think... 

[22:42] <lue> what would happen in this:    my $a = 2; my ($b is rw); $b ::= $a;

[22:42] <lue> would ::= still make $b made ro?

[22:42] <dalek> rakudo: 979a34a | pmichaud++ | src/ (3 files):

[22:42] <dalek> rakudo: Don't de-reference invocants for Rakudo (non-core-PMC) objects.

[22:42] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/979a34abb39d3dbb5daaf2cf9a8a9bc90ec430eb

[22:42] <dalek> rakudo: ef66ac3 | pmichaud++ | src/core/Match.pm:

[22:42] <dalek> rakudo: Get Match objects to work with objectrefs in methods.

[22:42] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ef66ac35d6f220e8e336b2ebc4cdb04f4d673c35

[22:42] <dalek> rakudo: 22d0c39 | pmichaud++ | src/ (4 files):

[22:42] <dalek> rakudo: Merge branch 'deref'

[22:42] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/22d0c39a91e019d037280290ed739308a345f2f3

[22:43] <cognominal> I was (idly) thinking of deriving a shellish grammar from Perl 6, with conventions to switch back to regular Perl 6 in subexpressions.

[22:43] <ash_> if its the perl6 grammar, you can do (like):   sub postfix:<!> ($x) is equiv(&postfix:<++>) { ... }  to make a new postfix ! with the same precedence as ++ 

[22:43] <lue> std: my $a = 2; my ($b is rw); $b ::= $a;

[22:43] <p6eval> std 31554: OUTPUT«ok 00:01 115m␤»

[22:44] <lue> would $b here stays rw afterwards, or be overriden into ro?

[22:44] <ash_> std: sub postfix:<!> ($x) is equiv<++> { ... } 

[22:44] <p6eval> std 31554: OUTPUT«ok 00:01 112m␤»

[22:44] <ash_> std: my $a; $a is rw; $a is readonly; 

[22:44] <p6eval> std 31554: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/AlJJkNWBi5 line 1:␤------> [32mmy $a; $a [33m⏏[31mis rw; $a is readonly;[0m␤    expecting any of:␤       bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse failed␤FAILED 00:01 111m␤»

[22:45] <ash_> i guess you can't change read/write-ness after the declaration? 

[22:45] <lue> rakudo: my $a; $a is rw;

[22:45] <p6eval> rakudo 1e7012: OUTPUT«===SORRY!===␤Confused at line 11, near "$a is rw;"␤»

[22:45] <lue> rakudo: my $a is rw; $a is readonly;

[22:46] <p6eval> rakudo 1e7012: OUTPUT«===SORRY!===␤Confused at line 11, near "$a is read"␤»

[22:46] <jnthn> Can only apply the traits in a decl

[22:46] <ash_> does ::= imply a trait? 

[22:46] <ash_> (readonly)

[22:47] <lue> but would explicitly defining rw cause ::= to set or not set ro?

[22:47] *** dakkar left
[22:47] <lue> Consider this case: my $a = 2; my ($b is rw); $b ::= $a;

[22:47] <lue> could I do $b ::= $c afterwards?

[22:47] <jnthn> I would expect not

[22:48] <lue> yeah, me too. That makes coding it much easier :P

[22:48] <jnthn> Otherwise ::= is rather less useful as a compiler hint.

[22:50] <lue> what I'm doing (out of laziness), is using := binding, and then setting ro. Is there anything wrong with that?

[22:51] <jnthn> I don't think setting ro would do it

[22:51] <jnthn> It's more about not having rw set

[22:51] <ash_> in S03, when it talks about ::= it says: " Note that the semantics of ::= are virtually identical to the normal binding of arguments to formal subroutine parameters (which also default to readonly)." So i'd just copy how parameters do it 

[22:52] <pmichaud> rakudo takes the position that only those things explicitly marked "rw" are writable.  Everything else is considered readonly and immutable.

[22:52] <pmichaud> I'm fairly certain that's the safer approach.

[22:53] <lue> so, set ro, or leave it alone?

[22:53] <pmichaud> ah, yes, for containers and binding semantics, I've been of the opposite opinion.  A container is assumed rebindable unless marked otherwise.

[22:54] <pmichaud> jnthn: btw, I'm wondering if we could get a bit of a win in bind.c if we deobjectref values before binding them to readonly parameters

[22:55] <pmichaud> but now that I think about it, I'm guessing there might be a case where it doesn't work.

[22:56] <lue> so either pir::setprop to set ro, or pir::delprop to remove rw.

[22:56] <ash_> if the container is rw then ::= seems like it should be the same as := 

[22:56] <lue> (you're making me think rakudo operates on quantum mechanics!)

[22:56] <pmichaud> at one point not too long ago TimToady++ mentioned that he thought that ro parameters should still be rebindable.

[22:57] <pmichaud> perhaps that's changed, but when I specifically asked about it, he said it looked okay.

[22:57] <ash_> so... := and ::= are the same then? 

[22:57] <pmichaud> no

[22:57] <lue> thereby eliminating ::=, right?

[22:57] <pmichaud> thereby meaning that ::= is not the same as parameter binding

[22:57] <ash_> ah, got ya

[22:57] <pmichaud> since something bound with ::= is not rebindable.

[22:58] <lue> should it be ro or !rw then?

[22:58] <pmichaud> we should probably ask for an update first.

[22:58] <pmichaud> or at least a confirmation of parameter rebindability

[22:58] <pmichaud> because that will likely decide which to use.

[22:59] <pmichaud> (being that parameter bindings happen far more frequently than either := or ::=)

[23:00] <lue> .oO(maybe invent rb and nrb traits. [JOKE])

[23:01] <lue> lemme guess, in Rakudo, readonly is not the same as !rw.

[23:01] <pmichaud> it is, at present.

[23:01] <pmichaud> if it's not rw, it's readonly.

[23:01] <pmichaud> but that's for the container itself, not the binding of the container to a symbol

[23:02] <pmichaud> in some sense the two attributes are orthogonal.  one can have a readonly container that can be rebound, or a read/write container that cannot be rebound

[23:02] <lue> maybe we need to differentiate between readonly and immutable, if it has to be.

[23:02] <pmichaud> we need to keep in mind that there's readonly for assignment, and readonly for binding, and they aren't necessarily the same property.

[23:03] <pmichaud> or even directly related.

[23:03] <pmichaud> (TimToady++ of course may say I'm wrong about this, but so far I don't see a required relationship)

[23:04] <lue> then maybe make it easier to differentiate the two.

[23:05] * lue goes and undoes his (very little) work on ::=, considering a good solution won't come soon. :)

[23:09] *** lestrrat is now known as lest_away

[23:12] <sorear> pmichaud: I've already decided that parameters cannot be rebound

[23:12] <sorear> if ::= creates a rebindable binding, then it's useless for TimToady's use cases

[23:13] <pmichaud> sorear: both of those are opposite from what I understand

[23:14] <pmichaud> ::= creates a non-rebindable binding

[23:14] <pmichaud> and parameters can be rebound 

[23:14] <pmichaud> that's the last I heard.

[23:14] <lue> ($a is rw) ::= $b should leave $a rebindable, if I read the spec correctly.

[23:14] <pmichaud> lue: that really makes no sense to me at all.  what part of the spec are you looking at?

[23:15] <lue> S03, on ::=

[23:15] <ash_> S03 says that

[23:15] <ash_> "This does the same as :=, then marks any destination parameters as readonly (unless the individual parameter overrides this with either the rw trait or the copy trait)." 

[23:16] <sorear> pmichaud: ::= creates a non-rebindable binding.  it has to, and I didn't contradict this

[23:16] <pmichaud> right

[23:16] <pmichaud> you said "if ::= creates a rebindable binding..."  I never suggested otherwise.

[23:16] <pmichaud> I never suggested that it did.

[23:17] <sorear> I have a habit of speaking in impossibilities.  It confuses people a lot. :(

[23:17] <pmichaud> ash_: okay, re-reading S03, I see it differently.

[23:18] <lue> I think that ::= binding w/ two Mu's would make a nonrebindable binding, no matter what.

[23:18] <pmichaud> ::= *is* the same as parameter binding.  It binds a variable and removes its rw trait, unless the container being bound explicitly had "is rw" set.

[23:18] <pmichaud> and containers may always be rebound -- there's nothing to prevent rebinding.

[23:19] <lue> so, would  ($a is rw) ::= $b  be the same as  $a is rw; $a ::= $b  ?

[23:20] <pmichaud> lue: well, "is rw" is applied at declaration time, iiuc.

[23:20] <pmichaud> so it would have to be    (my $a is rw) ::= $b;

[23:20] <pmichaud> which would be the same as   my $a is rw;  $a ::= $b;

[23:20] *** rgrau_ joined
[23:20] <lue> yes, of course. I keep leaving those off.

[23:20] <pmichaud> but that's a guess at the moment.

[23:21] <pmichaud> anyway, rereading S03 now I see that ::= talks about the rw-ness of the container, not of the symbol binding.  Sorry for leading folks down a false trail.

[23:21] <lue> Which would mean all of the multi subs for ::= would have to check for an explicitly set rw/copy . (not a difficult thing by any means, so that's not a complaint.)

[23:24] <lue> then, would I pir::setprop for rw or pir::delprop for readonly?

[23:24] <lue> gah! pir::setprop for *readonly*, and vice versa.

[23:24] <pmichaud> pir::delprop, likely.

[23:24] <pmichaud> i.e., you remove any rw property on the container.

[23:25] <lue> alright, I'll go try that.

[23:28] <lue> would a getprop for rw return null if it were not explicitly set?

[23:28] *** skangas left
[23:29] <pmichaud> yes, that's currently what we primarily check for.

[23:30] <lue> I would also have to check for the copy property, see if that's null (I'm assuming)

[23:31] <pmichaud> we don't normally put 'copy' on containers at the moment.

[23:31] <lue> ah. so don't bother checking for it?

[23:31] <pmichaud> we may have to, but presently it's not there.

[23:31] <pmichaud> right now the only properties that need checking are 'scalar' and 'rw', I think.

[23:32] <pmichaud> (at least as far as what other parts of Rakudo have available)

[23:32] <lue> hm, not sure what to do with the result of a scalar check.

[23:33] <pmichaud> if scalar is set, you may need to itemize the source.

[23:33] <pmichaud> not sure about that one yet either.

[23:33] <lue> I think I'll just check for rw then, for now.

[23:34] <pmichaud> small steps are often good.  :)

[23:37] <lue> just to be sure, this check if rw is _not_ explicitly set: pir::isnull(pir::getprop__PsP('rw', $target))

[23:37] <pmichaud> it checks that the container is currently not rw, yes.

[23:38] <lue> and then I delprop the rw property, correct?

[23:38] <pmichaud> correct.

[23:38] <pmichaud> but you can delprop without having to check, too.

[23:38] <pmichaud> it doesn't hurt to delprop a non-existent property.

[23:39] <pmichaud> (at least it shouldn't)

[23:39] <lue> what if rw is explicitly set, though? then according to the spec, it should stay rw.

[23:39] <pmichaud> we don't have a way of handling that yet.

[23:40] <pmichaud> at the moment we don't mark containers with explicitly set "is rw"

[23:40] *** ashleydev left
[23:40] <pmichaud> other than to mark them "rw"

[23:40] <lue> alright, so the conditional doesn't matter at all right now.

[23:40] <pmichaud> correct.

[23:45] <lue> .oO(We keep coding 'till we stop knowing!)

[23:47] <ingy> ZOMG!!!!!!!!!! PERL 6 CAN HAS TESTML!!!!!!!!!!!!

[23:47] <ingy> http://nopaste.snit.ch/21819

[23:47] <ingy> It frickin works!

[23:47] <lue> and after Proxy goes away, I can haz NES emulatr in P6!

[23:47] <ingy> where do I upload this thing??!!

[23:47] <ingy> :)

[23:48] <lue> what's the purpose of Proxy anyway?

[23:48] <pmichaud> lue: Proxy handles the case of      my @a;   @a[4] = 5;

[23:48] <pmichaud> what does @a[4] return?

[23:48] <pmichaud> it has to be something that when assigned to will also do the binding in @a

[23:48] <jnthn> ingy: :D

[23:48] <pmichaud> (this is all about to disappear in about an hour, fwiw)

[23:48] <ingy> pmichaud: Perl 6?

[23:49] <ingy> :'(

[23:49] <pmichaud> Proxy

[23:49] <ingy> :)

[23:49] <jnthn> lol

[23:49] <jnthn> ingy: To get it on modules.perl6.org, normal way is to put it in a github repo (or gitorious) and then get it entered into http://github.com/masak/proto/blob/pls/poc-projects.list

[23:49] <ingy> now I can port JSYNC (with its TestML tests) to P6.

[23:50] <lue> because right now:

[23:50] <ingy> jnthn: http://github.com/ingydotnet/testml-pm6

[23:50] * ingy pushes

[23:51] <sorear> jnthn: Can you explain to me how lexical classes work in Rqakudo?

[23:51] <lue> my @b = (0,1,2); @b[3] := @b[0]; say @b.perl returns (0,1,2)

[23:51] <jnthn> sorear: Given what TimToady mumbled about them being made once at BEGIN time the other day, I suspect "wrongly" :-/

[23:51] <sorear> lue: @b[3] returns my $x := @b[3]; $x;

[23:51] <lue> what's the correct way to call pir::delprop? pir::delprop__Ps didn't work.

[23:52] <sorear> __vPs

[23:52] <sorear> or just pir::delprop

[23:52] <jnthn> sorear: Essentially they work just the same as building an anonymous class and then installing it in the lexpad though.

[23:52] <lue> ah, dankon sorear.

[23:52] <sorear> pmichaud *hates* people who use signatures needlessly

[23:52] <jnthn> pmichaud hates me? :-D

[23:53] <ingy> jnthn: pushed.

[23:53] <jnthn> <- worst offender ;-)

[23:53] <lue> last time I checked, just pir::delprop fails (it's been a while though)

[23:53] * ingy summons masak

[23:54] <jnthn> rakudo: my @c; for 1..5 -> $x { my class foo { method m { $x } }; @c.push(foo); }; @c>>.m>>.say;

[23:54] <p6eval> rakudo 1e7012: OUTPUT«5␤5␤5␤5␤5␤»

[23:54] <jnthn> Meh.

[23:55] *** Psyche^ joined
[23:55] <jnthn> Though

[23:55] <jnthn> rakudo: my @c; for 1..5 -> $x { my class foo { method m { $x } }; @c.push(foo); }; say @c[0] === @c[0] # sanity

[23:55] <p6eval> rakudo 1e7012: OUTPUT«1␤»

[23:55] <jnthn> rakudo: my @c; for 1..5 -> $x { my class foo { method m { $x } }; @c.push(foo); }; say @c[0] === @c[1] # insanity? ;-)

[23:55] <p6eval> rakudo 1e7012: OUTPUT«0␤»

[23:56] <jnthn> iiuTTc, that shoulda said 1 as well and the "all fives" would be right

[23:56] <jnthn> I'm not too sure if that's a good thing though.

[23:56] <ingy> should I bother masak with a pull request?

[23:56] <jnthn> ingy: no, just phenny: tell masak ... him

[23:56] <jnthn> imo

[23:56] <ingy> :)

[23:56] <jnthn> .oO( tomorrow, see masak tell me off for not suggesting the pull request! )

[23:57] <lue> 'cause unless proxy goes away, I'd have to define a 0x10000 size array first, just to bind things o.O

[23:58] <ingy> phenny: tell masak Please register http://github.com/ingydotnet/testml-pm6

[23:58] <phenny> ingy: I'll pass that on when masak is around.

[23:58] <lue> rakudo: say "for those who can't count in hex, 0x10000 is {:16<0x10000>} in decimal";

[23:58] <p6eval> rakudo 1e7012: OUTPUT«for those who can't count in hex, 0x10000 is 65536 in decimal␤»

[23:59] *** Patterner left
[23:59] *** Psyche^ is now known as Patterner

