[00:00] <ingy> I have to say that p6grammars is the AMAZING part of p6. The other stuff is curious...

[00:01] * ingy speaks on behalf of Guido and the entire Python community... Thank you for your grammars!

[00:01] * ingy ducks

[00:05] <lue> I think you'd only have to duck on #python :)

[00:06] <lue> now S03-operators/binding-closures.t and binding-ro.t pass unfudged because of ::= \o/

[00:06] <lue> s/closures/closure/

[00:07] * jnthn -> sleep, night all

[00:07] <ash_> i saw something kinda interesting in python the other day ingy 

[00:08] <lue> goodnight jnthn o/

[00:08] <lue> I need to figure out what the test output means when it gives me numbers for failed tests, considering they aren't exactly number in the test files :)

[00:10] <ash_> ingy: its not grammars, but it is kinda cool, it was called 'yapps' (yet another python parser system) and you can define rules for processing text, somewhat like a grammar, but a bit more limited, just because of the syntax that you end up having to use for it is a bit odd

[00:11] <lue> tomorrow/later I'll have discuss some of the test failures I get and see if it's the code's fault (aka 'bug') or outdated tests.

[00:13] <lue> afk

[00:15] <pmichaud> http://news.perlfoundation.org/2010/07/hague-grant-application-lists.html

[00:15] <pmichaud> comments welcomed.

[00:16] *** lest_away is now known as lestrrat

[00:17] <ash_> is that at all related to the changing of rakudo to use more primitive parrot objects? so method invocation won't require multiple hash lookups? (probably not, right?) 

[00:20] <lue> pmichaud: nice! Looking forward to the results :)

[00:27] <pmichaud> ash_: no.

[00:27] <pmichaud> ash_: it's just that we spent several years trying to understand lists and iterators in Perl 6, and now that we have a working implementation we need to document the results.  :)

[00:27] <pmichaud> (and flesh out the implementation some more)

[00:28] <ash_> got ya

[00:29] <ash_> thats all of the @a = 1, 2 (the lhs and rhs complexities)? does that include any changes to gather/take for writing an iterator? 

[00:29] *** meppl left
[00:30] <ash_> i assume most end users will use gather/take to make iterators, right? 

[00:31] *** PZt left
[00:39] *** rgrau__ joined
[00:40] *** rgrau_ left
[00:48] *** bjarneh left
[00:49] *** bjarneh joined
[00:50] <cognominal> rakudo: say 'ok' if 0 but True

[00:50] <p6eval> rakudo 22d0c3:  ( no output )

[00:51] <cognominal> hum

[00:57] <ash_> i don't think 'but' is working as expected...

[00:57] <ash_>  

[01:02] *** rurban left
[01:02] <cognominal> it is defined in src/core/operators.pm

[01:03] <cognominal> I forgot what the backslashed parameters mean.

[01:09] <cognominal> Jun 30 22:55:34 <jnthn>	It means "apply no context whatsoever to this"

[01:18] <ingy> ash_: are you ashleydev?

[01:25] *** lkk- joined
[01:36] <lichtkind> ingy: congrat to wiki update

[01:36] <lichtkind> ingy: can be the same done for perl 6 wiki?

[01:37] <cognominal> backslash defined indeed in S06:2120 as a equivalent to C<Is parcel>

[01:53] *** supernovus joined
[01:56] *** Transformer joined
[01:58] <pmichaud> perl6: my $x;  say $x ~~ /nothing/;

[01:58] <p6eval> rakudo 22d0c3: OUTPUT«Method 'match' not found for invocant of class ''␤  in 'Regex::ACCEPTS' at line 5213:CORE.setting␤  in 'infix:<~~>' at line 428:CORE.setting␤  in main program body at line 11:/tmp/HfdqO7E2dq␤»

[01:58] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.14/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[01:58] <p6eval> ..elf 31554: OUTPUT«Use of uninitialized value $a in pattern match (m//) at ./elf_h line 5803.␤␤»

[01:58] *** Transformer left
[01:59] <pmichaud> rakudo: my $x;  say $x ~~ /nothing/;

[01:59] <p6eval> rakudo 22d0c3: OUTPUT«Method 'match' not found for invocant of class ''␤  in 'Regex::ACCEPTS' at line 5213:CORE.setting␤  in 'infix:<~~>' at line 428:CORE.setting␤  in main program body at line 11:/tmp/_TE6MVuzw8␤»

[01:59] <pmichaud> anyone have an idea what should happen there?

[02:00] <pmichaud> (1) define .match on Any (instead of just on Cool)

[02:00] <pmichaud> (2) initialize $x to Cool instead of Any

[02:00] <pmichaud> (3) accept this result as correct

[02:00] <pmichaud> (4) other?

[02:08] *** bjarneh left
[02:10] *** agentzh joined
[02:16] *** lichtkind left
[02:18] *** orafu left
[02:25] *** supernovus left
[02:29] *** alester joined
[02:30] *** justatheory joined
[02:32] *** patspam left
[02:33] *** duzy joined
[02:43] *** duzy` joined
[02:46] *** duzy left
[02:52] *** PZt joined
[03:09] *** ashleydev joined
[03:36] <spinclad> pmichaud: i would think (1)

[03:36] <sorear> I am starting th think I'm using the wrong low-level object model

[03:36] <pmichaud> spinclad: aha!  an answer!   

[03:37] * sorear doesn't get Cool

[03:38] *** sorear sets mode: +voo dalek szabgab lue

[03:38] <spinclad> pmichaud: re hague grant: don't know if it's too late for updates, but two wordings looked awkward to me: 

[03:39] <spinclad> (1) 'either in the standard repository for each component'  ('in either of the standard repositories for the components', maybe)

[03:41] <spinclad> (2) 'experience and background for archiving the crucial deliverables' ('achieving', i expect?  _archiving_ doesn't seem a critical task here.)

[03:43] <pmichaud> oops, yes, supposed to be 'achieving'

[03:43] <pmichaud> I'll see if Karen can fix it.

[03:47] <pmichaud> heh

[03:47] <pmichaud> my original text apparently had  "achiving"

[03:47] <pmichaud> so some spell checker apparently switched it for "archiving"

[03:49] <pmichaud> anyway, I left a comment on the proposal explaining the fix.  :-)

[03:55] <pmichaud> locally:

[03:55] <pmichaud> > my $x;  $x[3]<hello>[1] = 'world';  say $x.perl;

[03:55] <pmichaud> [Any, Any, Any, {"hello" => [Any, "world"]}]

[03:55] <spinclad> that'll account for it.  'ambiguous prototype, candidates are: :(Ing[Achie?ve]), :(Ing[Ar?chive])'

[03:55] <sorear> What MRO does Perl 6 use?

[03:56] *** justatheory left
[03:57] <spinclad> C3, as i understand it

[04:00] *** ashleydev left
[04:00] *** ashleydev joined
[04:05] <TimToady> sorear: in http://irclog.perlgeek.de/perl6/2010-07-04#i_2515113 you still seem to be thinking that augment is a BEGIN; in http://irclog.perlgeek.de/perl6/2010-07-03#i_2510057 I said it's not a BEGIN, but a package, really

[04:06] <TimToady> though not well expressed because I was very tired at the time

[04:07] <TimToady> it's only the declarations in the augment that are run at compile time

[04:07] <lue> ohai o/

[04:07] <lue> any interesting conversations while I was gone?

[04:08] <TimToady> I have a hard enough time backlogging for myself

[04:09] <lue> we had a lovely discussion about ::=, did you notice? ::=)

[04:10] <TimToady> ::= is supposed to be just like parameter binding; if they're different, one or the other is probably wrong :)

[04:10] <TimToady> in either case, the readonly-ness is supposed to give the optimizer something to work with

[04:11] <lue> well, for now, it just removes the rw property (in what I've done).

[04:11] <TimToady> removes it from what?

[04:11] <lue> from the target

[04:11] <lue> (after binding of course)

[04:12] <lue> rakudo: my @a = <a b c>; @a.delete(1); say ~@a

[04:12] <p6eval> rakudo 22d0c3: OUTPUT«a Any() c␤»

[04:13] <lue> according to the test I have here for binding, that should be 'a  c', not 'a Any() c'.

[04:14] <TimToady> ~ is supposed to turn an undef into '' (with a warning).  Str is supposed to make Any()

[04:14] <TimToady> but I think rakudo doesn't have Str vs Stringy yet

[04:14] <lue> my @a = <a b c>; my $b = 'e'; @a[1] := $b; @a.delete(1);

[04:14] <lue> there, the test output says it should stay 'e', not turn into Any() like it does.

[04:15] <lue> (it being $b)

[04:15] <ash_> TimToady: pmichaud seemed to think that ::= and parameters were different in that parameters were re-bindable, is ::= supposed to be re-bindable? 

[04:15] <TimToady> that seems right--the delete should only delete from the array

[04:15] <TimToady> is probably parrot PMC damage

[04:16] <TimToady> for the optimizer's sake, we could prohibit rebinding of anything we know has had ::= used on it, likewise for parameters

[04:17] <TimToady> alternately, pessimize any routine that rebinds

[04:17] <lue> but then you get the  my ($a is rw) ::= $b  situation...

[04:17] <TimToady> but rebinding of existing variables is *way* down there on my list of things I feel need to be supported

[04:18] *** Guest77623 left
[04:18] <TimToady> the compiler already treats assignment to a declarator as special; treating ::= as also special is trivial

[04:19] <TimToady> for instance, in state $x = 42; or has $.x = rand; the = is far from a simple assignment

[04:19] <TimToady> for now I'm inclined to say that ::= may be only be applied to a declarator until we understand it better

[04:20] <TimToady> but the whole point of both ro parameter binding and ::= is to let the compiler know we intend to pretend a value is constant over some scope

[04:21] <TimToady> I'm not inclined to break that promise for the dubious gain of rebinding

[04:21] <lue> I think if you want to have a readonly binding you'd be more inclined to to my ($a is readonly) := $b than look up ::= (unless the two are completely different)

[04:21] <TimToady> ::= is syntactic sugar for 'is readonly'

[04:22] *** meppl joined
[04:22] <TimToady> which is the default for params

[04:22] <TimToady> if you use ::= on an 'is rw' you're just screwed up in the head

[04:22] <spinclad> constant pi ::= 22/7   is nicely compact

[04:22] <TimToady> it's erroneous at best

[04:23] <lue> .oO(that's a quote to save for the hall of fame)

[04:23] <TimToady> and we can certainly warn that the either the 'is rw' or the ::= is useless

[04:23] <TimToady> constant pi = 22/7 is fine, no need for ::=

[04:24] <TimToady> ::= is a *run-time* constant

[04:24] <TimToady> the constant declarator measn it's a compile time constant that can never change no how no way

[04:25] <TimToady> also, I remember some confusion in the backlog over the syntactic slot that 'constant' fills

[04:25] <ash_> in S03 ::= says "This does the same as :=, then marks any destination parameters as readonly (unless the individual parameter overrides this with either the rw trait or the copy trait)." does that need to be revised? 

[04:25] <TimToady> it uses to be 'my', but now it's the same as 'sub' or 'subset'

[04:25] <TimToady> so you can have 'my constant'

[04:25] *** Schwern left
[04:25] <TimToady> but not 'constant Int pi = 3'

[04:26] <TimToady> it would have to be 'my Int constant pi = 3' or 'constant pi of Int = 3'

[04:26] <TimToady> std: constant pi of Int = 3

[04:26] <p6eval> std 31554: OUTPUT«ok 00:01 112m␤»

[04:27] <lue> rakudo: constant Int pi = 3

[04:27] <ash_> i think i made that mistaken once, i thought constant could replace the use of 'my' 

[04:27] <p6eval> rakudo 22d0c3: OUTPUT«===SORRY!===␤Confused at line 11, near "constant I"␤»

[04:27] <ash_> i didn't realize they were supposed to be used together

[04:27] <spinclad> std: my Int volatile constant pi = 3

[04:27] <p6eval> std 31554: OUTPUT«[31m===[0mSORRY![31m===[0m␤Multiple prefix constraints not yet supported at /tmp/XeTVQgGcAw line 1:␤------> [32mmy Int [33m⏏[31mvolatile constant pi = 3[0m␤Malformed my at /tmp/XeTVQgGcAw line 1:␤------> [32mmy Int [33m⏏[31mvolatile constant pi = 3[0m␤    expecting any

[04:27] <p6eval> ..…

[04:28] <TimToady> ash_: it used to be in the 'my' slot

[04:28] <TimToady> ash_: yes, S03 is less that adequate on the meaning of ::=

[04:28] <TimToady> spinclad: what in the world is volatile?

[04:28] <spinclad> std: my Int volatile constant pi = (3 today, 4 tomorrow)

[04:28] <p6eval> std 31554: OUTPUT«[31m===[0mSORRY![31m===[0m␤Multiple prefix constraints not yet supported at /tmp/eEgw94nE9T line 1:␤------> [32mmy Int [33m⏏[31mvolatile constant pi = (3 today, 4 tomor[0m␤Malformed my at /tmp/eEgw94nE9T line 1:␤------> [32mmy Int [33m⏏[31mvolatile constant pi = (3

[04:28] <p6eval> ..today…

[04:29] <TimToady> std: volatile

[04:29] <p6eval> std 31554: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'volatile' used at line 1␤Check failed␤FAILED 00:01 107m␤»

[04:29] <TimToady> STD has no clue what you mean

[04:29] <lue> std: my Int Volatile constant pi = 3; # methinks the V is capitalized

[04:29] <p6eval> std 31554: OUTPUT«[31m===[0mSORRY![31m===[0m␤Multiple prefix constraints not yet supported at /tmp/1vXaQjcpjE line 1:␤------> [32mmy Int [33m⏏[31mVolatile constant pi = 3; # methinks the[0m␤Malformed my at /tmp/1vXaQjcpjE line 1:␤------> [32mmy Int [33m⏏[31mVolatile constant pi = 3; #

[04:29] <p6eval> ..met…

[04:29] <TimToady> std: Volatile

[04:29] <p6eval> std 31554: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤ 'Volatile' used at line 1␤Check failed␤FAILED 00:01 107m␤»

[04:29] <ash_> is there such thing as volatile in perl6? 

[04:29] <lue> [it changes from a routine to a name in one Shift!]

[04:30] <TimToady> yes, it's guessing

[04:30] <lue> rakudo: my Int constant pi = (3|4)

[04:30] <p6eval> rakudo 22d0c3: OUTPUT«===SORRY!===␤In "my" declaration, typename Int must be predeclared (or marked as declarative with :: prefix) at line 11, near " constant "␤»

[04:30] <TimToady> o_O

[04:31] <ash_> rakudo: my Int $pi = (3|4); 

[04:31] <spinclad> volatile: a Cism saying you have to consult the location every time; the 'other end' may count your references, or feed you a different value of the constant, or whatever.  used for accessing i/o registers sometimes.

[04:31] <p6eval> rakudo 22d0c3: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/iAVS6OS6Y_␤»

[04:31] <TimToady> I know what volatile means in C, but STD is not implementing C :P

[04:31] <ash_> spinclad: i know what volatile means in C, but it doesn't exist in perl6... 

[04:31] <lue> rakudo: say ((3|4) ~~ Int)

[04:31] <p6eval> rakudo 22d0c3: OUTPUT«0␤»

[04:32] <sorear> it doesn't exist in any other version of Perl, either

[04:32] <ash_> rakudo: subset F where 3|4; my F $pi = 3; 

[04:32] <p6eval> rakudo 22d0c3:  ( no output )

[04:32] <lue> rakudo: say ((3|4) ~~ 3)

[04:32] <p6eval> rakudo 22d0c3: OUTPUT«any(Bool::True, Bool::False)␤»

[04:33] <lue> well, why didn't it say any(Bool::True, Bool::True) when I compared it to Int?

[04:33] <TimToady> bug, maybe

[04:33] <lue> rakudo: say 3 ~~ Int

[04:33] <p6eval> rakudo 22d0c3: OUTPUT«1␤»

[04:33] <TimToady> or the parameter to .ACCEPTS is declared as Mu type

[04:34] <TimToady> rakudo: say 3|4 ~~ Junction

[04:34] <p6eval> rakudo 22d0c3: OUTPUT«1␤»

[04:34] <TimToady> yeah

[04:34] <lue> well, ~~ didn't DWIM for (3|4) ~~ Int …

[04:35] <sorear> it DWIMs for me

[04:35] <TimToady> I can see it both ways, but generally I'd rather optimize it what normal folks will expect, and sorear++ isn't exactly normal

[04:36] <lue> .oO(apparently WPM differs...)

[04:36] <sorear> Pm?

[04:36] <TimToady> there's always (3|4).does(Junction) for the other

[04:36] <lue> What People Mean

[04:37] <lue> WIM would imply I'm unstable :)

[04:37] <TimToady> rakudo: say (3|4).does(Junction)

[04:37] <p6eval> rakudo 22d0c3: OUTPUT«any(0)␤»

[04:37] <sorear> TimToady: Is the stuff in S12 about multiple dispatch and single dispatch being different a fossil now?

[04:37] <TimToady> heh, other way around :)

[04:38] <lue> rakudo: my $a = (3|4); my @a = (3,4); say $a ~~ @a;

[04:38] <p6eval> rakudo 22d0c3: OUTPUT«any(Bool::False)␤»

[04:38] <lue> I broek it :)

[04:40] <sorear> What is the standard Perl 6 MRO?

[04:42] *** kst joined
[04:44] <pmichaud> back

[04:47] <hejki> sorear: C3?

[04:48] <pmichaud> rakudo:  my $x;  $x ~~ /nothing/;

[04:48] <p6eval> rakudo 22d0c3: OUTPUT«Method 'match' not found for invocant of class ''␤  in 'Regex::ACCEPTS' at line 5213:CORE.setting␤  in 'infix:<~~>' at line 428:CORE.setting␤  in main program body at line 11:/tmp/w28gkzETs6␤»

[04:48] <pmichaud> TimToady: any thoughts on ^^^ ?  Should .match be defined on Any?

[04:51] *** ashleydev left
[04:58] *** sftp_ joined
[04:59] *** tedv left
[04:59] *** sftp left
[04:59] <TimToady> we did think about making my $x default to Cool at one point

[05:00] <pmichaud> that feels weird to me for some reason

[05:00] <pmichaud> certainly it would be Cool only in initialization, not in constraint

[05:00] <TimToady> sorear: I'm not sure what you're referring to in S12.

[05:00] <sorear> What exactly is Cool?

[05:01] <pmichaud> Cool is the base type for classes that tend to know how to morph into other Cool objects

[05:01] <pmichaud> so it's where we put common methods like .abs, .sin, etc.

[05:01] <pmichaud> thus  "3".abs  will work, without throwing .abs into Any

[05:03] <TimToady> sorear: but it is still the case that single dispatch and multiple dispatch have nothing to do with each other

[05:03] <sorear> S06:736-757

[05:03] <TimToady> that's not in S12 :0

[05:03] * lue wonders if he should paste his ::= patch

[05:04] <sorear> don't paste anything longer than 3 lines

[05:05] <lue> well, I meant nopaste.

[05:06] <TimToady> that passage in S06 still seems operative to me

[05:07] <TimToady> however, the terminology is a bit old-fashioned

[05:07] <TimToady> the distinction is not between single dispatch and multi dispatch, but between object dispatch and lexical dispatch

[05:08] <TimToady> in either case, we may end up doing multiple dispatch if the target we find is a proto

[05:08] <sorear> what's the difference between an invocant parameter and any other parameter, and why should my implementation care?

[05:08] <TimToady> you mean argument?

[05:09] <TimToady> argument what we call the actual, and reserve "parameter" for the formals

[05:09] <TimToady> function calls are foo($a,$b,$c) and look out the lexical scopes

[05:10] <TimToady> method calls are foo($a: $b,$c) and look up the inheritance chain of $a

[05:10] <TimToady> really early binding vs late binding

[05:11] <TimToady> but there's still a lot of verbiage in the synopses that calls function dispatch "multiple dispatch", and that's inaccurate

[05:12] <TimToady> we only recently clarified that, in the case of both functions and methods, a 'proto' is really just an 'only' that knows how to gather its multi candidates and redispatch

[05:13] <TimToady> so nothing dispatches directly to multis

[05:13] <lue> afk

[05:14] *** cotto joined
[05:14] <TimToady> from the standpoint of the method or sub itself on the called end, it doesn't generally care which dispatcher found them, since they're all just Calleables that can be invoked, and expect self as the first arg

[05:14] <TimToady> so the : form in a singature is really sugar that lets you leave out the first parameter

[05:15] <TimToady> well, other way around, the : says you aren't leaving it out of the signature...

[05:16] <TimToady> there are likely some optimizations involved in knowing it's the invocant, if you can rely on the fact that a particular dispatcher enforces the type of the invocant, you don't have to recheck it

[05:16] <TimToady> (same is true for a multiple dispatch)

[05:17] <sorear> so what that text is really saying is that my $c = \($foo: $bar); cow(|$c)  ===  $foo.cow($bar)

[05:17] <sorear> ?

[05:17] <TimToady> yes

[05:18] <TimToady> it seems the most parsimonious way to allow captures to be fed to both methods and subs

[05:18] <TimToady> otherwise you'd have to go to a lot of work to pull out the invocant and call it differently

[05:19] <TimToady> and it seems the implementation can figure out how to do that itself once and not make the user figure it out

[05:19] <pugssvn> r31555 | pmichaud++ | [t/spec]:  Fudge and fix some tests after autoviv changes. 

[05:20] <TimToady> and as soon as you've interpolated |$c into an argument list you've disabled most of your optimizer knowledge anyway

[05:20] <TimToady> so checking the first arg for "I'm an invocant" is not much more overhead

[05:21] <dalek> rakudo: 08e5b03 | pmichaud++ | src/core/ (2 files):

[05:21] <dalek> rakudo: Move postcircumfix:<[ ]> into Any.

[05:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/08e5b0364dd38af736888f8fa2b5d9633160eaf0

[05:21] <dalek> rakudo: 577a146 | pmichaud++ | src/core/Any-list.pm:

[05:21] <dalek> rakudo: Add first version of Any.at-pos, handling the defined case.

[05:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/577a1466ff99d8818ba83ffae3f58ec83ecdb79b

[05:21] <dalek> rakudo: 06f2d7c | pmichaud++ | src/ (2 files):

[05:21] <dalek> rakudo: Add array autovivification.

[05:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/06f2d7cf0078811989a1cc08c472bcf219360fed

[05:21] <dalek> rakudo: f07a656 | pmichaud++ | src/core/Array.pm:

[05:21] <dalek> rakudo: Add WHENCE-based autoviv to Array.

[05:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f07a656c0bf2965a61e27348fd4343f0bc962ea0

[05:21] <dalek> rakudo: 04a918d | pmichaud++ | src/core/ (3 files):

[05:21] <dalek> rakudo: Move postcircumfix:<{ }> into Any.  Add hash autovivification.

[05:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/04a918d37c9807416f8ce1c81d88f8ad29b97df5

[05:30] *** cls_bsd left
[05:30] <pmichaud> rakudo:  say 1;

[05:30] <p6eval> rakudo 22d0c3: OUTPUT«1␤»

[05:31] * pmichaud waits for p6eval to update.

[05:33] <TimToady> jnthn, pmichaud: re http://irclog.perlgeek.de/perl6/2010-07-04#i_2515564, the spec discusses nested dispatchers at S12:933

[05:34] <pmichaud> TimToady: thanks

[05:35] <pmichaud> I suspect we both need to re-read it :-)

[05:35] <TimToady> and under the new proto model, the proto never looks for more outer or superer methods, since it thinks it's the "right" method already

[05:35] <TimToady> well, unless you used .*method of course

[05:36] <pmichaud> right.  That was my (limited) understanding of the new proto

[05:36] <pmichaud> it's like protoregexes in that respect

[05:36] <TimToady> yes

[05:36] <TimToady> one thing our current protos don't do is limit the candidate list on both ends

[05:36] <TimToady> at least, STD's doesn't

[05:37] <TimToady> it just collects all the protos from the actual type on up, but the proto is also supposed to limit how high up it looks, by current spec

[05:37] <TimToady> so it's the set of methods between the current proto's type and the object's actual type, that are "visible" to both of them

[05:38] <pmichaud> right

[05:38] <TimToady> so take the current of methods from the parents of self.WHAT, and then weed out the ones that don't 'isa' the type of the proto, basically

[05:38] <TimToady> s/of/set of/

[05:40] <TimToady> the current semantics of protoregexes is like putting a proto only in the supermost class; while the current semantics of normal multi methods is like having a proto in every class

[05:41] <TimToady> with the new semantics we can support both extremes as well as anything in the middle

[05:41] <TimToady> same goes for proto subs

[05:42] <TimToady> also, for now, I'm inclined to say that we infer no protos automatically

[05:42] <TimToady> and maybe even that it's illegal to declare a multi outside of the scope of a multi

[05:42] <TimToady> well, we can't know that for the methods, of course...

[05:43] <TimToady> or maybe we can

[05:43] <TimToady> I guess the isa's are relatively static

[05:44] <pmichaud> yeah, it makes initial sense to me

[05:44] <pmichaud> I'll need a couple of days to let it all sink in

[05:44] <pmichaud> plus it's been a bit of a march getting closures and autoviv working :-)

[05:44] <TimToady> on the subject of when you execute package-like blocks, I think that instead of making different blocks run at different times, it's more consistent to say that the all run like packages, and you can COMPOSE or whatever to get things running at special times

[05:44] <pmichaud> agreed.

[05:45] <pmichaud> consistency would be really good to have here.

[05:45] *** TiMBuS joined
[05:46] <pugssvn> r31556 | pmichaud++ | [t/spec]:  Fix pair.t syntax error from previous commit. 

[05:46] <pmichaud> rakudo: say 2;  # still checking

[05:46] <p6eval> rakudo 22d0c3: OUTPUT«2␤»

[05:46] <TimToady> the declarations, of course, always evaluate asap; I mean the normal code in the block

[05:46] <pmichaud> right.

[05:46] <TimToady> this consistency will also make it easier to write other similar block forms with predictable semantics

[05:47] <TimToady> myroles, and myclasses, and mywhateverwehaven'tthoughtofyet

[05:48] <TimToady> I could, of course, be deluding myself, and then I will change my mind, and make the implementors unhappy again...  :)

[05:49] *** sawyer_ left
[05:49] <pmichaud> for all of our grumbling (or at least mine), I have to say that nearly all such changes have been correct.

[05:50] <TimToady> I should really take a cleanup pass on the specs wrt dispatcher nomenclature; I knew when I hacked in the proto change that there was still a lot of fossils there that I was neglecting

[05:51] <TimToady> I'd have felt worse about the dispatcher change if it didn't feel like I was moving anonymous dispatcher code into the protos, and it wasn't really that big a rewrite

[05:51] <pmichaud> I'm hoping/expecting to work on spec rewrites (list/iterator) this next week as well.

[05:52] <TimToady> that'd be good

[05:52] <TimToady> has anyone tested the old double-gather bug to see if the closure change fixed it?

[05:53] <pmichaud> tbh, I don't recall the bug.  :)

[05:53] <pmichaud> but it should be fixed, yes.  :-)

[05:53] <TimToady> like, didn't the double map of a Schwartzian transform trigger it?

[05:53] <TimToady> or something like that

[05:54] <TimToady> using the same construct twice in the same pipeline

[05:54] <TimToady> or maybe it actually has to use the same block

[05:55] <pmichaud> I think it needed to be the same block.  that's far more likely.

[05:55] <pmichaud> rakudo:  sub xyz($x) { -> { say $x } };  my $b = xyz(3);  my $c = xyz(5);  $b();

[05:55] <p6eval> rakudo 22d0c3: OUTPUT«3␤»

[05:56] <pmichaud> that used to fail.

[05:56] <TimToady> \o/

[05:56] <pmichaud> because it wouldn't properly capture the closure.  now it works :)

[05:56] <pmichaud> and all of the other closure-related bugs I could find seem to work now.

[05:56] <pmichaud> anyway, I'm quite comfortable that the new implementation is fundamentally correct :)

[05:56] <TimToady> well, I'm sure we'll exercise closures heavily in the future, so I'm not too concerned that something will slip by

[05:57] *** plobsing joined
[05:57] <TimToady> certainly, if I ever had any doubts about the solidity of P5's closures, it was erased by all the abusive ways I used them in STD/Cursor

[05:58] <pmichaud> I suspect we'll have a few bugs crop up, but I'm comfortable that the underlying model is now sound.

[05:58] <TimToady> yayness

[06:01] *** sawyer_ joined
[06:04] *** cls_bsd joined
[06:05] *** ashleydev joined
[06:07] *** eternaleye left
[06:09] <TimToady> bedness &

[06:11] <pmichaud> rakudo:  say 1;

[06:11] <p6eval> rakudo 22d0c3: OUTPUT«1␤»

[06:11] *** uniejo joined
[06:37] *** araujo left
[06:42] *** rgrau__ left
[06:50] <pugssvn> r31557 | moritz++ | [t/spec] fudge a failing test for rakudo in rat.t 

[06:51] <moritz_> rt is not very responsive right now

[06:52] <pmichaud> rakudo:  say 2;

[06:52] <p6eval> rakudo 04a918: OUTPUT«2␤»

[06:53] <pmichaud> rakudo:  my $a;  $a[2]<abc>[1] = 'hello';  say $a.perl;

[06:53] <p6eval> rakudo 04a918: OUTPUT«[Any, Any, {"abc" => [Any, "hello"]}]␤»

[06:53] <pmichaud> \o/

[06:58] * moritz_ impressed

[06:58] <moritz_> rakudo: my $a; $a<foo>.push: 3; say $a.perl

[06:58] <p6eval> rakudo 04a918: OUTPUT«Method 'push' not found for invocant of class ''␤  in main program body at line 11:/tmp/7LjM_iEoKP␤»

[06:59] <moritz_> rakudo: my $a; push $a<foo>, 3; say $a.perl

[06:59] <p6eval> rakudo 04a918: OUTPUT«Method '!fill' not found for invocant of class ''␤  in 'List::push' at line 2517:CORE.setting␤  in main program body at line 11:/tmp/IbyLjTvJ4S␤»

[07:01] <pmichaud> I'm not sure that Any:U should have a .push yet.

[07:01] <pmichaud> we can certainly add one.

[07:01] * moritz_ is

[07:01] <pmichaud> in the case of   push $a<foo>, 3

[07:01] <pmichaud> I think that will fail to bind.

[07:02] <pmichaud> unless we define a special  push(Any:U, ...)  variant.

[07:03] <moritz_> we probably need to

[07:04] <pmichaud> ...and we don't have :U and :D implemented, afaik.

[07:04] <moritz_> right

[07:30] *** tylercurtis joined
[07:31] <pmichaud> time for sleep here -- bbiaw

[07:32] <m6locks> g'night

[07:33] *** simcop2387 joined
[07:41] *** ashleydev left
[07:43] *** Sanitoeter left
[07:45] *** Ross joined
[07:46] <mathw> Good morning

[08:00] <sorear> TimToady: I thought methods /were/ subs

[08:02] <sorear> oh, bedness.

[08:05] *** Sanitoeter joined
[08:13] *** Ross left
[08:21] *** sftp joined
[08:21] *** tylercurtis left
[08:21] *** sftp_ left
[08:26] <pugssvn> r31558 | moritz++ | [t/spec] fudge can.t for rakudo 

[08:35] <moritz_> rakudo: say 'ab34d5z'.split(/<.before \d>/).perl

[08:35] *** Ross joined
[08:35] <p6eval> rakudo 04a918: OUTPUT«("ab", "", "", "d", "", "z")␤»

[08:35] <moritz_> rakudo: say ''.split('')

[08:35] <moritz_> rakudo: say ''.split('').perl

[08:35] <p6eval> rakudo 04a918: OUTPUT«␤»

[08:35] <p6eval> rakudo 04a918: OUTPUT«("")␤»

[08:36] <moritz_> rakudo: say split('', '').perl

[08:36] <p6eval> rakudo 04a918: OUTPUT«("")␤»

[08:43] *** dakkar joined
[08:43] *** fridim_ joined
[08:50] *** lkk- left
[08:51] *** sawyer_ left
[08:51] *** sawyer_ joined
[08:57] *** _mpu joined
[09:02] *** pmurias joined
[09:02] *** plobsing left
[09:02] <sorear> pmurias: I got the OK from TimToady to move ahead with my STD plans :>

[09:03] *** clintongormley joined
[09:07] *** masak joined
[09:07] <masak> oh hai, #perl6!

[09:07] <phenny> masak: 05 Jul 23:58Z <ingy> tell masak Please register http://github.com/ingydotnet/testml-pm6

[09:08] <sorear> HELLO MASAK!

[09:08] <masak> :)

[09:08] <moritz_> good late morning masak :-)

[09:09] <sorear> (I swore long ago to never use the word "lol".  I have to make it up in other ways.)

[09:09] <moritz_> sorear: you just lost.

[09:09] <masak> moritz_: good late morning. I'm now caught up to sleep after the Lund hackathon. :)

[09:10] <mathw> \o/

[09:10] <mathw> it's masak!!!!

[09:10] <mathw> all my problems are now solved!

[09:10] <masak> sorear: but we use "lol" ironically here, that's different.

[09:10] <masak> mathw: happy to see you too. :)

[09:10] <mathw> I can haz reprodoosibbul bugz?

[09:11] <moritz_> masak: I've just read an article that summarized a scientific article saying that sending children to school later in the morning (8:30am instead of 8:00) improved their performance, and made them happier

[09:11] <masak> I've heard that too, in a BBC documentary.

[09:12] <moritz_> "I've always known and felt it!"

[09:12] <masak> "The Secret Life of Your Body Clock", it was called.

[09:12] <mathw> we went to school for 9am and we were still grumpy

[09:13] <masak> I had a nice-ish arrangement during junior high; the bus trip was fairly long, so one could "sleep in" on the bus.

[09:15] * moritz_ has to use some local government web site to obtain some documents... page load times > 3 minutes...

[09:15] *** eiro joined
[09:16] <pmurias> sorear: great

[09:17] <pmurias> sorear: want me to help with any part of the plans?

[09:18] <sorear> I haven't really been following with the plans

[09:19] *** lestrrat is now known as lest_away

[09:19] <sorear> other than "Google/TPF want you to put Mildew/SMOP on CPAN", "Mildew uses STD", ergo, "Google/TPF wants STD on CPAN"

[09:21] <masak> \o/

[09:21] <pmurias> so as i understand the plan to get STD on CPAN is to rename the STD modules, install the unicode database as a data file and ...?

[09:21] <masak> syllogisms for the win!

[09:22] <moritz_> masak: buf.t has a passing TODO on master... should I unfudge it?

[09:22] <masak> probably. which test is it?

[09:23] <moritz_> Buf ~~ Positional, iirc

[09:23] <masak> oh, certainly.

[09:23] <masak> that must have simply slipped my mind.

[09:23] <pmurias> sorear: i want to help with getting STD on CPAN as you seems to be also interested it that i'm asking if you want help with any part of that

[09:25] <sorear> oh, sorry, I read that completely backward

[09:25] <sorear> as "do you want to help me with..."

[09:26] <sorear> pmurias: rename STD output modules, use better methods for initializing PERL6LIB, look for the compiled setting in PERL6LIB, profit

[09:27] <pmurias> mildew will have it's own setting

[09:28] <pmurias> how do we want to initialize PERL6LIB?

[09:29] <sorear> File::ShareDir + .

[09:29] <sorear> + ./lib

[09:29] <pmurias> lib6 instead of lib?

[09:31] <sorear> I don't think so

[09:31] <sorear> the current trend is to segregate p6 by extension

[09:31] <pmurias> ok

[09:31] <pmurias> if we segregate by extension wouldn't using PERL5LIB be fine

[09:31] <pmurias> ?

[09:32] <sorear> maybe, but $PERL6LIB is before my time

[09:33] <pmurias> PERL6LIB is from before we were using special perl6 extensions

[09:34] <pmurias> PERL6LIB = PERL5LIB + what's defined in the PERL6LIB env var should work

[09:34] *** JimmyZ joined
[09:35] *** envi^home joined
[09:36] <pmurias> maybe with a defined PERL6LIB env var overridding instead of adding

[09:37] <masak> phenny: tell pmichaud that I suppose Rakudo master 2010.06-112-g28762fd is post-closures-merge, yes? well, if I remove the pir::clone workarounds, the tests that failed prior to those workarounds start failing again. :-/

[09:37] <phenny> masak: I'll pass that on when pmichaud is around.

[09:37] <jnthn> morning

[09:37] <pmurias> sorear: that's a minor thing and we can always tweak that later

[09:38] <dalek> niecza: 9dffd3e | sorear++ | Kernel.cs:

[09:38] <dalek> niecza: Push more class system functionality down into the kernel

[09:38] <dalek> niecza: Prototype methods were driving me insane in Perl 6; in the C# layer they're

[09:38] <dalek> niecza: trivial.  MRO implementation started.

[09:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9dffd3ef747d31134e01d0722d23480c2327de7c

[09:38] <masak> jnthn: \o

[09:39] *** lest_away is now known as lestrrat

[09:43] <sorear> hehehehe.

[09:43] * sorear realizes niecza is currently powerful enough for loops - but only over Church numerals

[09:47] * pmurias found and STD bug

[09:47] <sorear> reason ++n why I don't like 0 but True : it will blow up in your face unless somebody - perhaps a completely unrelated module? had done use open 'Int';

[09:47] <sorear> er

[09:47] <sorear> use nonfine

[09:47] <sorear> nonfinal

[09:48] <arnsholt> Something like it is needed though

[09:48] <arnsholt> Sometimes a value that is numerically 0 but booleanly true is what you really want

[09:48] <pmurias> if somebody messes with your Int class  1) he is an idiot 2) you have a problem

[09:49] <sorear> pmurias: not if. unless.

[09:49] <sorear> somebody NEEDS to mess with your Int class for 0 but True to work

[09:49] <jnthn> It doesn't touch the original Int class.

[09:49] <sorear> or you can do it yourself, but forgetting to do it yourself is an easily masked bug

[09:50] <sorear> jnthn: post-CHECK-time subclassability is opt-in

[09:50] * pmurias checks that

[09:51] <jnthn> Classes are open and non-final by default, but may easily be closed

[09:51] <jnthn> or finalized not by themselves but by the entire application

[09:51] <jnthn> So closing is an application wide decision

[09:51] <jnthn> (first 2 lines from S12)

[09:54] <pmurias> sorear: what should canonicalize_name return for CALLER:<$foo>?

[09:56] <sorear> CALLER:<$foo>

[09:57] <sorear> note that CALLER in this context is a syntactic category and has nothing to do with the package

[09:57] <sorear> CALLER:<$foo> is the same form of name as infix:<+>

[09:57] <sorear> and is not at all related to CALLER::<$foo>

[09:57] <sorear> (which, incidentally, is not a name at all)

[10:02] <pmurias> sorear: it returns a list, should the first element be CALLER:: or CALLER

[10:03] <pmurias> i should have asked about CALLER:: :/

[10:03] *** masonkramer left
[10:03] *** masonkramer joined
[10:04] *** thepler left
[10:05] *** thepler joined
[10:05] <masak> sorear: what jnthn said. one doesn't have to explicitly open the Int class.

[10:08] <sorear> pmurias: canonicalize_name should *never* see CALLER::<$foo>

[10:08] <sorear> CALLER::<$foo> is an expression, not a name

[10:08] <sorear> the only name there is CALLER

[10:08] <pugssvn> r31559 | pmurias++ | [STD] fix bug 

[10:08] <sorear> ($package):: is a term representing the pacage hash

[10:09] <sorear> ($hash)<$key> is a postcircumfx

[10:09] <pmurias> sorear: se above bug

[10:09] <pmurias> * see above bugfix

[10:10] <sorear> I said should never see

[10:10] <sorear> which should never be taken as 'never sees'

[10:10] <sorear> code has a habit of not working

[10:17] * sorear out.

[10:19] <moritz_> \o/ I just got a mail that my belatly submitted talk to YAPC::EU has been accepted after all

[10:20] <dalek> niecza: 4281ff6 | sorear++ |  (5 files):

[10:20] <dalek> niecza: Implement method addition metamethods

[10:20] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4281ff62f082f11021e71b1c401d888021e2ddd4

[10:25] <pmurias> moritz_: i understand from that that you'll be at YAPC::EU

[10:26] <moritz_> pmurias: yes. You too?

[10:26] <pmurias> yes

[10:26] <moritz_> \o/

[10:26] <moritz_> finally we meet in person

[10:26] <moritz_> I'll be there from Aug 1 to 6th (have to leave at noon on the 6th)

[10:34] *** agentzh left
[10:38] *** Mowah left
[10:42] *** Mowah joined
[10:42] *** lestrrat is now known as lest_away

[10:59] *** thepler left
[10:59] *** sawyer_ left
[10:59] *** fridim_ left
[10:59] *** thebird left
[11:01] <mathw> moritz_: what's your talk about?

[11:01] *** fridim_ joined
[11:02] <masak> Damian Conway won't attend YAPC::EU due to a death in his family. http://conferences.yapceurope.org/ye2010/news/589

[11:02] *** thepler joined
[11:02] *** sawyer_ joined
[11:02] *** thebird joined
[11:04] <jnthn> masak: Yes, just saw that. Poor Damian. :-(

[11:05] *** thepler left
[11:05] *** sawyer_ left
[11:05] *** thebird left
[11:07] <masak> TimToady: lines($filename.IO) -- +1

[11:08] *** pnu left
[11:08] <jnthn> Cannot decrement constant

[11:08] <jnthn> ;-)

[11:08] <masak> jnthn: TimToady isn't an evalbot :P

[11:09] <jnthn> rakudo: -- +1 # I hope... ;-)

[11:09] <p6eval> rakudo 04a918: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/MSGZBJUnrr␤»

[11:09] <jnthn> Phew :-)

[11:09] <masak> 'assign to' should really be 'decrement', though.

[11:09] <jnthn> That's probably a pain to do

[11:09] <jnthn> But yes, it would be more awesome.

[11:09] <masak> pity.

[11:10] *** thebird joined
[11:10] <jnthn> Well, we could check for the flag in the -- op

[11:10] <jnthn> But then we'd end up re-chekcing it in infix:<=>

[11:10] <jnthn> Which is a bit wasteful

[11:14] <masak> should only need to check it when an error actually occurs, at which point waste isn't an issue.

[11:15] *** Backglass joined
[11:15] *** sawyer_ joined
[11:15] *** thepler joined
[11:16] <Backglass> anyone can help me with a script? please I've been here is 3h and I can not make it work

[11:16] <masak> Backglass: we'll gladly help you with your Perl 6 script.

[11:16] <masak> Backglass: 3h? you just arrived.

[11:17] * masak and Backglass privmsg a bit

[11:21] *** pnu joined
[11:31] <moritz_> mathw: "Perl 6 and the real world" (physical modelling)

[11:31] <jnthn> \o/

[11:33] <masak> [backlog] wait, so you're saing that `3 < any(1, 7) < 5` should be false, because the junction evaluates first both comparisons with 1, and then both with 7?

[11:33] <masak> I must say that makes a whole lot of intuitive sense.

[11:33] <moritz_> somehow the non-zero exit statusses have returned

[11:33] <masak> were they ever gone?

[11:34] <moritz_> mostly

[11:35] <masak> rakudo: say [+] [1,2,3] # bug courtesy of TimToady++

[11:35] <p6eval> rakudo 04a918: OUTPUT«6␤»

[11:35] * masak submits rakudobug

[11:35] <masak> <TimToady> [] should never flatten in a listop

[11:36] <jnthn> masak: I was a bit surprised by it too. It seems there is a sane way to impleemnt it also. Well, sane-ish.

[11:36] <masak> jnthn: somehow it rings similar to the recent thing with != and junctions.

[11:37] <masak> junctions sort of always evaluate outermost.

[11:37] <jnthn> masak: Kinda-ish. :)

[11:37] <masak> even when the syntactical layering indicates otherwise.

[11:37] <jnthn> masak: Basically you promote the whole chained expression to a parameterized block.

[11:37] <masak> oh!

[11:37] <masak> nice.

[11:37] <jnthn> And pass in the operands as arguments.

[11:38] <jnthn> And make sure that the default parameter type is set to Any

[11:38] <jnthn> And then let the dispatcher handle the rest.

[11:38] *** JimmyZ left
[11:38] <jnthn> Yeah, that approach hadn't occurred to me. :-)

[11:39] <moritz_> masak: the [+] [1, 2, 3] bug might be related to http://rt.perl.org/rt3/Ticket/Display.html?id=76110

[11:39] * masak looks

[11:40] <masak> the final question seems to indicate it is.

[11:40] <masak> but I don't immediately see the connection.

[11:40] <moritz_> the connection is that [...] around the inner expression make it work

[11:41] <masak> right.

[11:41] <masak> I'll put this issue in that bug, then.

[11:41] <masak> s/bug/ticket/

[11:49] *** Backglass left
[11:51] <masak> turned out Backglass was a Spanish-speaking programmer who thought he needed regex assistance, but who really needed to be told about HTML::Query. :)

[11:52] <hejki> parsing html manually.. aww

[11:54] *** duzy` left
[11:57] <takadonet> morning all

[11:57] <masak> I had to ask him to stop filtering his Spanish through a translating service. it was easier for me to read in original. :)

[11:57] <masak> takadonet: \o

[12:13] *** bluescreen joined
[12:14] *** bluescreen is now known as Guest51578

[12:20] <masak> rakudo: my $t = 0; sub foo { my @a; my &bar = { say +@a }; unless $t++ { foo; push @a, "OH HAI"; say +@a; bar; } }; foo

[12:20] <p6eval> rakudo 04a918: OUTPUT«1␤1␤»

[12:20] <masak> hm. maybe I do have a too-old rakudo after all.

[12:20] *** Maddingue joined
[12:20] * masak pulls

[12:22] <masak> ah, I was on the buf branch. :)

[12:22] <masak> phenny: tell pmichaud belay that, it's fixed, and I'm just confused. pmichaud++

[12:22] <phenny> masak: I'll pass that on when pmichaud is around.

[12:23] *** Ross left
[12:23] *** Ross joined
[12:25] * jnthn can also remove hacks from Zavolaj and Test::Mock thanks to pmichaud++'s fixes, probably :-)

[12:29] *** ruoso joined
[12:35] *** araujo joined
[12:39] *** araujo left
[12:39] *** araujo joined
[12:41] * mathw puts up a big sign that says 'always check which branch you're on when things go weird'

[12:42] <moritz_> not only which branch, but also which host :-)

[12:44] <mathw> that too :)

[12:44] <mathw> I've done it at work so many times

[12:44] <mathw> 'hang on a sec I wrote a function here yesterday...'

[12:45] * moritz_ can't find it

[12:45] <mathw> inevitably turns out that I'm looking at a release branch when I should be looking at trunk, or something like that

[12:46] <moritz_> in the days before I knew about version control I'd keep several copies of the same project in various stages of completeness

[12:46] <masak> SCM branches are against basic human nature. we should forbid them.

[12:46] <moritz_> with telling names such as 'old', 'new', 'new1', 'even_newer', 'working' etc.

[12:47] <masak> been there, done that.

[12:47] <jnthn> .oO( They should do way instain branches who confuse their masak who cannot git checkout master )

[12:48] <moritz_> I guess you need to go through such a phase to really appreciate SCMs

[12:48] * masak .oO( a masak in arrrrh )

[12:48] *** skangas joined
[12:49] <mathw> I still don't grok git's idea of branching

[12:49] <mathw> but I'll get there eventually

[12:49] <mathw> probably when I use it more regularly

[12:49] <jnthn> moritz_: Seeing a codebase where there were years of commented out code marked "old" with the code below it marked "ny" is also a good way to make one appreciate it...

[12:49] <jnthn> s/ny/new/

[12:50] <moritz_> re s/ny/new/, are you starting to mix up English and Swedish? :-)

[12:50] <masak> mathw: branches are more of an emergent phenomenon in git than an actual "thing". this text might help. http://tom.preston-werner.com/2009/05/19/the-git-parable.html

[12:50] <jnthn> It was a Swedish codebase. All the comments were in Swedish...which made deciphering the mess even more fun. :-)

[12:51] <jnthn> (The same one where they'd marked the end of lots of sections of the code with a comment saying "end"...in Swedish. :-D)

[12:54] <masak> the Broken Window fallacy implies that if code contains one bad thing, it will eventually contain many bad things. so, not too surprising that it was the same codebase. :)

[12:55] <jnthn> Oh, it contained...many many many other bad things too.

[13:10] *** gbacon joined
[13:10] <mathw> masak: That article is awesome! Why didn't I read it before? Why doesn't everybody know about it?

[13:10] <[Coke]> phenn - tell masak - i have a bash prompt hack that shows me the git branch I'm on. want it?

[13:10] *** skids left
[13:10] <masak> [Coke]: I'm right here.

[13:11] <[Coke]> masak - well, i was in backscroll until a second ago. =-)

[13:11] <[Coke]> coke@slurpee ~/sandbox/rakudo (git:master) $

[13:11] <masak> [Coke]: wouldn't help me; I have a bash alias that pulls-and-builds Rakudo for me, independent of the folder I'm in.

[13:11] <[Coke]> coke@slurpee ~/sandbox/parrot (svn:^/branches/html_cleanup) $

[13:11] <masak> [Coke]: I should probably make that alias refuse to build anything but master, though.

[13:12] <[Coke]> masak: hokay.

[13:12] <masak> but thanks.

[13:12] <[Coke]> I did the bash prompt thing for pretty much the same reason, one too many times working on the wrong branch.

[13:14] <arnsholt> [Coke]: I'm interested though =)

[13:15] *** gbacon left
[13:15] <masak> I seldom find myself working on the wrong branch. this is more a question of a leaky abstraction packaged into my bash alias.

[13:15] *** gbacon joined
[13:19] <moritz_> I'm usually only in the wrong branch when somebody sends me a pull request, and thus interrupts my regular workflow

[13:19] <[Coke]> http://nopaste.snit.ch/21831 has the relevant snippets.

[13:21] *** perlygatekeeper joined
[13:22] * jnthn afk for a bit

[13:27] *** tadzik joined
[13:27] *** plainhao joined
[13:29] *** lest_away is now known as lestrrat

[13:31] *** gbacon left
[13:37] *** slavik joined
[13:37] <pmichaud> good morning, #perl6

[13:37] <phenny> pmichaud: 09:37Z <masak> tell pmichaud that I suppose Rakudo master 2010.06-112-g28762fd is post-closures-merge, yes? well, if I remove the pir::clone workarounds, the tests that failed prior to those workarounds start failing again. :-/

[13:37] <phenny> pmichaud: 12:22Z <masak> tell pmichaud belay that, it's fixed, and I'm just confused. pmichaud++

[13:37] <masak> morning, pm!

[13:38] <masak> hm, I do have some new failures in GGE. don't know their cause yet, though.

[13:39] <moritz_> maybe GGE assumes a broken lexicals model? :-)

[13:39] <masak> could be.

[13:40] <masak> that's not wholly impossible when developing something with TDD.

[13:42] <masak> TimToady: classes A and B each have a 'proto foo'. class C is A is B has a 'multi foo'. which proto manages the multi?

[13:45] <masak> I want to express my dissatisfaction about 'an empty body C<{}> is equivalent to C<{nextsame;}>' for proto routines. I see the rationale, but it feels Wrong.

[13:46] <moritz_> agreed

[13:46] <moritz_> adding a noop like Nil; shouldn't change the semantics of a routine

[13:47] <masak> nod

[13:52] <mathw> but you're not, you're replacing an invisible op... :P

[13:52] <mathw> (I agre)

[13:53] <mathw> s/e/ee/

[13:55] * jnthn back

[13:55] <jnthn> hi pmichaud!

[13:55] <jnthn> Nice work on auto-viv. \o/

[13:58] *** tadzik left
[13:58] *** lestrrat is now known as lest_away

[14:02] <masak> there's been work on auto-viv?

[14:02] <masak> I really should finish backlogging...

[14:02] <pmichaud> rakudo:  my $a;   $a[5] = 'hello';   say $a.perl;

[14:02] <p6eval> rakudo 04a918: OUTPUT«[Any, Any, Any, Any, Any, "hello"]␤»

[14:02] <masak> \o/

[14:02] <pmichaud> rakudo:  my $a;  $a[2]<yay>[1] = 'world';  say $a.perl;

[14:02] <masak> pmichaud++

[14:03] <p6eval> rakudo 04a918: OUTPUT«[Any, Any, {"yay" => [Any, "world"]}]␤»

[14:03] <masak> wow.

[14:03] <masak> this changes everything! :)

[14:03] <masak> moritz_: was there a weekly challenge last week? will there be one this week?

[14:04] <moritz_> masak: last week was $*ARGFILES

[14:04] <masak> oh, right.

[14:04] <moritz_> masak: this week: Match.new, if I get around to it (and nobody has better ideas)

[14:04] <masak> ok.

[14:04] <frettled> So you're essentially into match-making now?

[14:04] <moritz_> :-)

[14:05] <pmichaud> right now I'm working on Stringy

[14:05] <frettled> pmichaud++: nice going on autovivification, that looks very nice.

[14:06] * moritz_ still is confused how say() is supposed to work

[14:06] <moritz_> my initial thought was that it calls prefix:~ or .Stringy on the argument

[14:06] <slavik> moritz_: just like print but adds "\n" to the end of the output?

[14:06] <slavik> or ... way too advanced for me

[14:06] *** lest_away is now known as lestrrat

[14:06] <moritz_> and if a Str is returned, it calls .encode

[14:07] <moritz_> and if a Buf is returned, it's printed binary

[14:07] <moritz_> but recently TimToady mentioned that say() calls .Str

[14:07] <moritz_> which I find confusing, because it requires a Str roundtrip for buffers

[14:08] *** uniejo left
[14:09] *** IllvilJa joined
[14:11] *** uniejo joined
[14:13] *** uniejo left
[14:18] <pmichaud> say calls .Str on each of its arguments.

[14:19] <moritz_> so how does it work on buffers?

[14:19] <pmichaud> I don't understand the question.

[14:19] <moritz_> say(Buf.new(123, 0, 255))

[14:20] <pmichaud> wouldn't that just call .Str on the Buf?

[14:20] <moritz_> yes, and that's a problem

[14:20] <moritz_> because Buf.Str might not be defined

[14:20] <pmichaud> then I'd say "you can't do that"

[14:20] <moritz_> that seems very unintuitive

[14:20] <pmichaud> what *should* happen there?

[14:21] <moritz_> it should just write the byes 123, 0 and 255 to STDOUT, followed by a newline

[14:21] <moritz_> why should it be any harder to do IO with binary data?

[14:21] <pmichaud> then why wouldn't Buf.Str return something that can make that happen?

[14:21] <pmichaud> or perhaps print(Buf) is overloaded

[14:22] <moritz_> it doesn't rountrip

[14:22] <moritz_> due to possible ambiguous encodings, NFG and the likes

[14:22] <moritz_> and it's just *WRONG* to convert a blob to Str just to do IO with it

[14:22] <moritz_> it should be the other way round

[14:23] <pmichaud> so, perhaps say invokes some other method that defaults to Str for most objects but does something differently on Buf

[14:23] <moritz_> ...which would be .Stringy, because that's what unifies Str and Buf

[14:24] <pmichaud> okay, that would totally go against my understanding of what Larry has been saying about >str

[14:24] <pmichaud> .Str

[14:24] <moritz_> there's also the possibilty that it calls .encode on the string

[14:25] <moritz_> which defaults to .Str in Any, but in Buf it's a no-op

[14:25] <pmichaud> that seems far more likely, since the IO object has to deal with encoding anyway

[14:25] *** fridim_ left
[14:25] <pmichaud> (I presume you mean .encode on the argument)

[14:26] <moritz_> yes

[14:26] *** plobsing joined
[14:26] <slavik> what's the diff between .Str and .Stringy?

[14:26] <moritz_> that's what we're discussing

[14:27] <slavik> shouldn't .Str do any encoding/decoding?

[14:27] <moritz_> .Str should return a Str

[14:27] <moritz_> which is an encoding independent (and unaware) text string

[14:28] <moritz_> one difference is that on type object, .Str returns TypeName(), and .Stringy returns ''

[14:29] <pmichaud> a bigger difference is junctions

[14:30] <pmichaud> (1|2).Str  returns  "any(1,2)"   while  (1|2).Stringy returns "1"|"2"

[14:31] <slavik> pmichaud: I am confused ...

[14:31] <slavik> (1|2) produces either 1 or 2, right?

[14:31] <slavik> rakudo: say (1|2)

[14:31] <p6eval> rakudo 04a918: OUTPUT«any(1, 2)␤»

[14:31] <moritz_> (1|2) produces a junction of 1 and 2

[14:31] <pmichaud> (rakudo doesn't have it right yet, which is why I'm working on it :-)

[14:32] <slavik> I need to read about junctions :-\

[14:32] <slavik> I don't have it in my right, either :P

[14:33] <masak> on S06:89 -- "When you call any routine (or method, or rule)" -- I thought methods and rules were routines. should that be s/routine/subroutine/ ?

[14:34] <slavik> I think I get junctions

[14:34] <slavik> basically junctions are like lists with a map wrapper when performing operations

[14:34] <slavik> am I sort of getting it?

[14:34] <masak> yes.

[14:34] <pmichaud> I think "or method or rule" is simply there to remind the reader that they are also routines.

[14:34] <slavik> sweet

[14:35] <slavik> this is awesome for search engines

[14:35] <moritz_> slavik: yes. And they do something special in boolean context

[14:35] <moritz_> that is, they collapse

[14:35] <slavik> can junctions be used for regex/grammar?

[14:35] <masak> they're a kind of container, which makes itself transparent in some cases of operators and sub calls.

[14:35] <pmichaud> rakudo:  if "abc" ~~ ( /ABC/ | /abc/ ) { say 'yes' }

[14:35] <p6eval> rakudo 04a918: OUTPUT«yes␤»

[14:36] <pmichaud> rakudo:  if "abc" ~~ ( /a/ & /b/ ) { say 'yes' }

[14:36] <p6eval> rakudo 04a918: OUTPUT«yes␤»

[14:36] <slavik> moritz_: right, as in: if ($article ~~ /junction(keyword1|keyword2/)

[14:36] <slavik> yes, that ...

[14:36] <pmichaud> rakudo:  if "acd" ~~ ( /a/ & /b/ ) { say 'yes' }

[14:36] <slavik> awesomes!

[14:36] <p6eval> rakudo 04a918:  ( no output )

[14:36] <pmichaud> rakudo:  if "acd" ~~ ( /a/ | /b/ ) { say 'yes' }

[14:36] <slavik> basically these will replace maps and for loops on a list of things

[14:36] <p6eval> rakudo 04a918: OUTPUT«yes␤»

[14:36] <pmichaud> slavik: ...but only if at the end you're interested in a boolean result.

[14:37] <slavik> pmichaud: right

[14:37] <slavik> pmichaud: also if I am modifying all of tem

[14:37] <slavik> them*

[14:37] <moritz_> another thing that often replaces map is >>. parallel dispatch

[14:37] <slavik> such as: all(1,2,3,4) * 5

[14:37] <slavik> or something

[14:37] <moritz_> rakudo: say ('a', 'b', 'c')>>.uc.join(", ")

[14:37] <slavik> but wouldn't a junction that doesn't collapse imply parallelization?

[14:37] <p6eval> rakudo 04a918: OUTPUT«A, B, C␤»

[14:38] <slavik> that's neat

[14:38] <slavik> so, once there is production ready Perl6, why would people use any other language?

[14:38] <moritz_> because they still need to learn it

[14:38] <slavik> that's a given

[14:38] <moritz_> and because there's legacy code

[14:39] <slavik> also given

[14:39] <jnthn> and because the first production ready Perl 6 won't run in every environment :-)

[14:39] <moritz_> and because other languages might still be a better choice in some circumstances

[14:39] <moritz_> or be faster

[14:39] <moritz_> or have more libraries

[14:39] <slavik> moritz_: that needs to be fixed ;)

[14:39] *** skids joined
[14:40] <hejki> hehe.. i hope production ready perl6 will be vastly faster than current rakudo :)

[14:40] <slavik> if perl6 can seamlessly use perl5 cpan libraries, I doubt there is a language with significantly more libraries than Perl

[14:40] <slavik> and auto-parallel :D

[14:40] <slavik> would be nice to be able to make rakudo run transparently on a cluster (MPI, hadoop, etc.)

[14:40] <moritz_> hejki: I hope so too

[14:41] <slavik> parallel dispatch across a cluster :D

[14:49] *** patspam joined
[14:53] <TimToady> おはよ、皆様！

[14:54] <slavik> TimToady: Доброе утро!

[14:54] <slavik> I assume the two kanji is 'gazai masu'

[14:54] <slavik> I can read hiragana :)

[14:54] <moritz_> so that's a greeting?

[14:54] <slavik> yes

[14:55] <slavik> wait, which one? what TimToady said or what I said?

[14:55] <TimToady> actually, /ohayo, minasama/ "morning, everyone"

[14:55] <slavik> ahh

[14:55] <slavik> sama? that's ranking us highly ...

[14:55] <TimToady> greetings tend to be politer than usual

[14:56] <slavik> I never knew that

[14:56] <slavik> I should've done linguistics ...

[14:56] <slavik> maybe even be smart enough to write my own programming language

[14:56] <TimToady> if you're leaving your family for the day, you say "ittekimasu" even though the masu is polite, and the rest of the time you use the familiar forms

[14:57] *** pmurias left
[14:59] <masak> Google Translate had it as "I you, everyone!". seems it tries to go by sound for the hiragana.

[14:59] <slavik> that's def 'o-ha-yo' ...

[14:59] <TimToady> I misspelled it

[15:00] <slavik> maybe google was expecting kanji?

[15:00] <TimToady> it should have been あはよう

[15:00] <slavik> oh, long o

[15:00] <masak> ah.

[15:00] <TimToady> or お早う

[15:01] *** rgrau_ joined
[15:02] <masak> one of the better pictographic logograms, if you ask me. :)

[15:02] <masak> it's a sun over a horizon.

[15:02] <masak> "morning"

[15:03] <TimToady> though I'm not sure why the sun has a line across it...

[15:03] <moritz_> that's the horizon? :-)

[15:03] <TimToady> seems like mouth could use the line more than sun could...

[15:03] <masak> TimToady: that line used to be a central spot in a circle.

[15:04] <TimToady> I think we should refactor all the chinese characters

[15:04] <masak> TimToady: and the moon had a vertical line, which stylized as two lines.

[15:04] <masak> er, two horizontal lines.

[15:04] <masak> TimToady: we could call it Hanzi 6. :)

[15:05] *** Backglass joined
[15:05] <masak> Backglass: hi again.

[15:05] * masak and Backglass privmsg

[15:06] <slavik> the nice part of japanese is that the kanji for forest is 2 trees together

[15:06] <slavik> or 3

[15:06] <slavik> same for neighborhood

[15:07] <TimToady> when the trees are thinner, they are bigger

[15:07] <slavik> ?

[15:07] <slavik> that's a first

[15:08] <TimToady> 林 has big trees, and 森 has small trees

[15:08] <TimToady> so "forest" vs "woods"

[15:08] <slavik> lol

[15:08] <masak> slavik: Mandarin has it as 林木, so three trees, but spread over two chars. :)

[15:08] <slavik> I see

[15:10] <masak> Chinese words seem to converge to being bisyllabic.

[15:11] <TimToady> huffmanization

[15:11] *** plobsing left
[15:11] * diakopter backlog fail

[15:12] <diakopter> rakudo closures, FTW, again

[15:12] <moritz_> indeed

[15:12] <moritz_> passes the man-or-boy test again

[15:13] <diakopter> cool

[15:14] <masak> std: { say "OH HAI" for 5..10 } if my $foo == 42 # working around the arbitrary "no loops in conditionals" restriction for statement modifiers :)

[15:14] <p6eval> std 31559: OUTPUT«ok 00:01 114m␤»

[15:14] <masak> so easy!

[15:14] <diakopter> Japanese for "thicket"?

[15:15] <moritz_> should that actually invoke the closure? or do you need a 'do' for that?

[15:16] <TimToady> it should work, but might be clearer with parens instead

[15:17] <masak> moritz_: pmichaud changed a few spectests the other day that claimed it shouldn't invoke the closure, to saying that they should.

[15:17] <moritz_> how convenient :-)

[15:18] <diakopter> rakudo: ( say "OH HAI" for 5..10 ) if my $foo <= 42

[15:18] <p6eval> rakudo 04a918: OUTPUT«Use of uninitialized value in numeric context␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤»

[15:19] <TimToady> std: (((say "hi") if 42) when *) unless /foo/ for lines

[15:19] <p6eval> std 31559: OUTPUT«ok 00:01 111m␤»

[15:19] <jnthn> rakudo: (((say "hi") if 42) when *) unless /and/ for lines

[15:19] <p6eval> rakudo 04a918: OUTPUT«hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤hi␤»

[15:19] <masak> innermost parens unnecessary, no?

[15:19] <jnthn> rakudo: (((say $_) if 42) when *) unless /and/ for lines

[15:20] <p6eval> rakudo 04a918: OUTPUT«Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmitten,␤einem starken Herzen gleich.␤Hast seit frühen Ahnentagen␤hoher Sendung Last getragen,␤vielgeprüftes

[15:20] <p6eval> ..Österr…

[15:20] <jnthn> \o/

[15:20] <TimToady> no, necessary, since 'when' is conditional

[15:20] <diakopter> rakudo: (((say "hi") if 42) when *) unless /./ for lines

[15:20] <p6eval> rakudo 04a918: OUTPUT«hi␤hi␤»

[15:20] *** isBEKaml joined
[15:20] <diakopter> 2 empty lines

[15:21] <jnthn> rakudo: (((say $_) if 42) when *) unless /z/ for lines

[15:21] <p6eval> rakudo 04a918: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmitten,␤Hast seit frühen Ahnentagen␤hoher

[15:21] <p6eval> ..Sendung L…

[15:21] <TimToady> most anthems have plenty of empty lines

[15:21] <jnthn> Lots of z's :-)

[15:21] <jnthn> oh wait

[15:21] <moritz_> lots of non-z's

[15:21] <jnthn> rakudo: (((say $_) if 42) when *) if /z/ for lines

[15:21] <jnthn> :P

[15:21] <p6eval> rakudo 04a918: OUTPUT«Land der Hämmer, zukunftsreich!␤einem starken Herzen gleich.␤»

[15:22] <isBEKaml> :O What is `lines` ?

[15:22] <jnthn> isBEKaml: It's a Perl 6 built-in that returns the lines of the Austrian national anthem.

[15:22] <isBEKaml> easter egg? :P

[15:22] <TimToady> actually, no

[15:23] <TimToady> it's what p6eval hooks up $*IN to

[15:23] <jnthn> :P

[15:23] <TimToady> rakudo: say $*IN.slurp

[15:23] <p6eval> rakudo 04a918: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmitten,␤einem

[15:23] <p6eval> ..stark…

[15:23] <isBEKaml> I see... :D

[15:26] *** ashleydev joined
[15:27] <masak> isBEKaml! \o/

[15:28] <isBEKaml> masak! :)

[15:28] <masak> isBEKaml: did you catch my notes for a SIC refactor?

[15:28] *** Backglass left
[15:29] <isBEKaml> masak: yes, I'm now trying to factor in those as to how I would approach yapsi best. :)

[15:29] <isBEKaml> masak: however, one thing immediately popped out. What of nested-nested-nested-blocks? 

[15:29] <diakopter> rakudo: say $*IN.^methods

[15:29] <p6eval> rakudo 04a918:

[15:29] <p6eval> ..OUTPUT«insprintsayopenprintftcloseslurpeofautoflushlinesgetgetctranssinfliplcp5chopsubstto-radiansabsacotanacosechchompindexceilingcotanhcombunpolartrim-trailingatanordacosevalchoptanhatanhcoseccharsrootsucucfirstsubstrtanlog10from-radianscosfmtbytespredacosecsinhasinhNumericcosechtrimase…

[15:30] <masak> isBEKaml: my plan is this: (1) create a new runtime that runs the example in http://gist.github.com/464349 (2) make the new runtime work with Yapsi's compiler.

[15:30] <masak> isBEKaml: what of them? they're just a chain of lexpads, each with a .parent pointing to the previous one.

[15:30] <masak> rakudo: say <a b c>

[15:31] <p6eval> rakudo 04a918: OUTPUT«abc␤»

[15:31] <masak> rakudo: say [<a b c>]

[15:31] <p6eval> rakudo 04a918: OUTPUT«a b c␤»

[15:32] <masak> ah; of course. lists don't get the prettifying space arrays get, because a list is what you send in when you want to print several things.

[15:32] <isBEKaml> masak: sorry, I was thinking we would expand the list but did not see that it's just chained together. 

[15:32] <TimToady> masak: I try to reserve the word "parent" for packages, and use "outer" for lexpads

[15:32] <masak> TimToady: oops. thanks. fixing.

[15:32] <TimToady> rakudo: -- +1

[15:32] <p6eval> rakudo 04a918: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/1TDSUycS64␤»

[15:32] <TimToady> s/assign to/modify/ and it stays accurate

[15:33] <TimToady> jnthn: ^^^

[15:33] <masak> isBEKaml: and fetching a variable from the great-great-grandouter block just means it does `fetch [-4, $n]`

[15:33] <jnthn> TimToady: ooh, good point

[15:35] <isBEKaml> masak: yes, blame my reading skills. 

[15:35] <masak> isBEKaml: 's ok. I'm happy you're interested.

[15:36] <isBEKaml> masak: "at compile time/run time, and (2) following the .parent" It's still .parent? 

[15:36] <masak> it's .outer now :)

[15:36] <isBEKaml> under changes in the Runtime. 

[15:37] <isBEKaml> masak: "I only have my selfish interests! " :P

[15:40] <TimToady> <masak> TimToady: classes A and B each have a 'proto foo'. class C is A is B has a 'multi foo'. which proto manages the multi?

[15:40] <TimToady> the foo it would find if the protos were onlys after a C3 dispatch

[15:41] <jnthn> TimToady: Are multi methods essentially "invisible" to the method dispatcher?

[15:41] <TimToady> remember protos are really just onlys with extra goodies

[15:41] <TimToady> yes

[15:41] <jnthn> TimToady: That is, it only cares about onlys and protos?

[15:41] <jnthn> OK

[15:41] <masak> TimToady: ok. that (C3) was my guess.

[15:41] <TimToady> only protos know how to dispatch to multis

[15:41] <masak> jnthn: I was going to tell you that this was my conclusion too. :)

[15:41] <TimToady> well, and direct invocation

[15:42] <masak> how does one "directly invoke" a multi?

[15:42] <TimToady> by get a reference to it any way you like

[15:42] *** yves__ left
[15:42] <TimToady> sig qualification, running down a candidate list yourself, etc

[15:42] <spinclad> masak: i'm surprised by the negative indexing for outer level (but that's just push v unshift, or [*-n] )

[15:42] <jnthn> TimToady: On your answer to the duplicate visits question - I get how we avoid them in that nextcame won't throw you up a level. Would .* maybe result in the dupes though?

[15:42] <TimToady> s/get/getting/

[15:43] <masak> what happens if one refers to something by signature, and more than one variant matches the signature?

[15:43] <TimToady> then you get a candidate list, I expect

[15:43] <jnthn> TimToady: oh, I guess not

[15:43] <jnthn> TimToady: Since we go up the tree until we find the controlling proto

[15:43] <TimToady> I think the lower proto blocks downward propagation of the upper set

[15:43] <jnthn> And then delegate to its dispatcher

[15:43] <jnthn> Right

[15:44] <jnthn> OK I start to see how this might not be insane.

[15:44] <masak> spinclad: no, the negative indexing comes from the fact that we take a number of steps "back" from the current block by following .outer links.

[15:44] <TimToady> I think we can define all the candidate sets to be disjoint

[15:44] <jnthn> We're going to break a lot of code by requring people to write "proto"s whenever they want to write a multi.

[15:44] <TimToady> ja

[15:45] <masak> rather that than implicit protos.

[15:46] <jnthn> I figure most protos are going to end up with signatures that are essentially slurpy though

[15:46] <jnthn> Well

[15:46] <TimToady> 'use autoproto'  :)

[15:46] <jnthn> Depends how a proto's signature and a candidate's signature relate to each other

[15:46] <jnthn> TimToady: Do they?

[15:47] <jnthn> TimToady: That is, if I declare a proto's signature as having, say, two positional args, do all the candidates also have to have two positional args?

[15:48] <TimToady> probably, given how we want to use the proto to remap nameds to positionals

[15:48] <TimToady> but maybe it's just erroneous if you do something silly

[15:49] <masak> "Perl 6: just erroneous if you do something silly"

[15:49] <isBEKaml> This might be a silly question - are arguments in protos strictly typed ? (characters and integers are freely interconvertible, how do other types relate to each other? )

[15:49] <TimToady> if you have proto foo ($a,$b) and pass it :a(1), :b(2), then the proto should probably rewrite the capture to (1,2)

[15:50] <masak> isBEKaml: if things are typed, not even strings and integers are interconvertible.

[15:50] <jnthn> Maybe we should require nextwith($a, $b) explicitly in that case?

[15:50] <jnthn> Hmm, maybe not

[15:50] <jnthn> TimToady: The problem that occured to me is that we can't actually write a proto infix:<+>($a, $b) { nextsmae; }

[15:51] *** pyrimidine joined
[15:51] <TimToady> we want the position of the proto to be explicit, but most of the time we want to write the body of the proto implicitly

[15:51] <jnthn> TimToady: Because we have arity-0 and arity-1 versions of the infixes.

[15:51] <isBEKaml> masak: yes, Strings and Integers were never interconvertible. that was just how strictly we're classifying types. 

[15:51] <TimToady> $a?,$b? maybe

[15:51] <jnthn> TimToady: I guess the .ocunt gives you the corect answer

[15:51] <jnthn> .cout, correct 

[15:52] <jnthn> ...count!

[15:52] * jnthn gives his keyboard a disappointed glare

[15:52] <spinclad> .coun't

[15:52] <isBEKaml> .count.drop('n') 

[15:53] <TimToady> isn't the count - n always 0?

[15:53] <spinclad> there's that n't key again

[15:54] <TimToady> sometimes it worksn't

[15:54] <TimToady> oopsn't

[15:54] <TimToady> n'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn't^C

[15:55] <TimToady> it's sticky today

[15:55] <masak> dohn't!

[15:55] <TimToady> where's my acetone?

[15:56] <TimToady> oh wait, I used it to make my coffee...

[15:56] <masak> yuck!

[15:56] <isBEKaml> wait, what? coffee - acetone? 

[15:56] <isBEKaml> :O

[15:56] * spinclad cleans his tea with alcohol instead

[15:59] *** macdaddy joined
[15:59] *** macdaddy is now known as Guest23936

[16:02] <masak> can you ask a package about its 'our' subs?

[16:02] <masak> is there a metamodel for packages?

[16:03] <masak> er, metaobject.

[16:03] <TimToady> std: say GLOBAL::.keys.grep(/^'&'/)

[16:03] <p6eval> std 31559: OUTPUT«ok 00:01 113m␤»

[16:04] <masak> ok.

[16:04] <masak> so... no metaobject? :)

[16:04] <TimToady> std: say $pkg::.keys.grep(/^'&'/)

[16:04] <p6eval> std 31559: OUTPUT«ok 00:01 111m␤»

[16:05] <TimToady> I didn't expect that to work :)

[16:05] <masak> std bug.

[16:05] * TimToady bug

[16:07] <TimToady> I'm not entirely sure how it parsed...

[16:09] *** justatheory joined
[16:10] *** Mowah left
[16:10] <TimToady> oh, morename allows a final :: component, but that's not quite what you want here

[16:11] <TimToady> std: ($foo)::  # probably fails

[16:11] <p6eval> std 31559: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $foo is not predeclared at /tmp/8fHNUxWaAO line 1:␤------> [32m($foo[33m⏏[31m)::  # probably fails[0m␤Confused at /tmp/8fHNUxWaAO line 1:␤------> [32m($foo):[33m⏏[31m:  # probably fails[0m␤    expecting any of:␤  coloncircumfix␤  

[16:11] <p6eval> ..signat…

[16:12] <TimToady> std: $defeat-the-name-checker::

[16:12] <p6eval> std 31559: OUTPUT«ok 00:01 108m␤»

[16:13] <masak> phenny: tell ingy testml-pm6 added; you're now a proto contributor, so the next one you'll be able to add yourself. :)

[16:13] <phenny> masak: I'll pass that on when ingy is around.

[16:13] <masak> rakudo: $foo::

[16:13] <p6eval> rakudo 04a918:  ( no output )

[16:13] <masak> rakudo: $foo::; say "alive"

[16:13] <p6eval> rakudo 04a918: OUTPUT«alive␤»

[16:13] * masak submits rakudobug

[16:14] <TimToady> rakudo: $foo:: = 42; say $foo::;

[16:14] *** patspam left
[16:14] <p6eval> rakudo 04a918: OUTPUT«Null PMC access in getprop()␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/BJHujVYpHX␤»

[16:15] <masak> ok, that goes in the same ticket :)

[16:15] <TimToady> rakudo: $foo::('') = 42; say $foo::('');

[16:15] <p6eval> rakudo 04a918: OUTPUT«===SORRY!===␤Indirect name lookups not yet implemented at line 11, near " = 42; say"␤»

[16:15] *** Khisanth joined
[16:15] * masak upgrades the ticket to a Null PMC access

[16:16] <pmichaud> 15:22 <isBEKaml> :O What is `lines` ?

[16:16] <pmichaud> 15:22 <jnthn> isBEKaml: It's a Perl 6 built-in that returns the lines of the Austrian national anthem.

[16:16] <pmichaud> HAHAHAHAHAHAHAHAHAHAHAHAHA

[16:16] <masak> well, it is. :P

[16:18] <masak> rakudo: say $foo::

[16:18] <p6eval> rakudo 04a918: OUTPUT«Null PMC access in type()␤  in main program body at line 11:/tmp/JQb_fi5YTT␤»

[16:18] <isBEKaml> $:: is global package? 

[16:18] * TimToady will experiment with adding a postfix :: that translates a Mu:U to a Hash

[16:19] <TimToady> :: doesn't imply global in P6

[16:19] <isBEKaml> rakudo: say $::foo

[16:19] <p6eval> rakudo 04a918: OUTPUT«===SORRY!===␤Symbol '$foo' not predeclared in <anonymous> (/tmp/Dg9f306d3_:11)␤»

[16:21] <isBEKaml> anonymous? I see, no global package. 

[16:22] <isBEKaml> isn't GLOBAL meant for explicitly specifying it? or, how do we do that? 

[16:22] <TimToady> yes, GLOBAL:: means the global package

[16:23] <TimToady> we try to discourage its use by dehuffmanizing it

[16:23] <isBEKaml> yes, I'd rather not use it. Just wanted to know. (I hate global variables too)

[16:23] <TimToady> though it is your current package at the start of a file

[16:24] *** IllvilJa left
[16:24] *** cdarroch joined
[16:24] *** cdarroch left
[16:24] *** cdarroch joined
[16:24] *** ashleydev_ joined
[16:26] *** ashleydev left
[16:28] <isBEKaml> danke

[16:29] *** Khisanth left
[16:29] *** ashleydev_ left
[16:31] <TimToady> errands &

[16:37] * isBEKaml finds Google Translate hilariously comical at translation from Hindi to English when translating old hindi songs... 

[16:38] <isBEKaml> but then poetry was never a machine's stronghold.... :D

[16:39] <ash_> isBEKaml: in a lot of cases where you might want to use a global variable, a dynamic variable is acceptable (those are the $*foo kind) 

[16:40] <isBEKaml> ash_: I thought $*foo kind of variables are implicit ones, aren't they? 

[16:40] <ash_> no, $^foo are 

[16:40] <isBEKaml> ash_: as in $*IN, $*OUT and so on.. 

[16:41] <ash_> $*foo is dynamic, as in it looks up scopes till it finds one that matches the name 

[16:41] *** ashleydev joined
[16:41] <ash_> rakudo: sub f { say $*foo }; my $*foo = 5; f; { my $*foo = 6; f; }

[16:41] <p6eval> rakudo 04a918: OUTPUT«5␤6␤»

[16:42] <ash_> $*IN, $*OUT, etc. are dynamic variables

[16:42] <isBEKaml> I could just define them without $*...? 

[16:42] <[Coke]> sub f { say $foo } ; my $foo = 5; f ; {my $foo = 6; f};

[16:42] <[Coke]> rakudo: sub f { say $foo } ; my $foo = 5; f ; {my $foo = 6; f};

[16:42] <p6eval> rakudo 04a918: OUTPUT«5␤5␤»

[16:43] <ash_> see the difference from how [Coke]++ did it?

[16:43] <isBEKaml> yes, I was just typing it out when I hit on the sub f and it dawned on me... :S

[16:43] <ash_> in a lot of cases, when you think you want global, you really want dynamic, but thats not always true, just asying 

[16:43] <ash_> saying* 

[16:43] <masak> what [Coke] did shouldn't compile.

[16:44] <masak> std: sub f { say $foo } ; my $foo = 5; f ; {my $foo = 6; f};

[16:44] <p6eval> std 31559: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $foo is not predeclared at /tmp/f3cd1gPBp7 line 1:␤------> [32msub f { say $foo[33m⏏[31m } ; my $foo = 5; f ; {my $foo = 6; f};[0m␤Check failed␤FAILED 00:01 111m␤»

[16:44] <ash_> yeah, my $foo should be before sub f

[16:44] <masak> known rakudobug.

[16:45] <ash_> std: my $foo = 5; sub f { say $foo } ;  f ; {my $foo = 6; f};

[16:45] <p6eval> std 31559: OUTPUT«ok 00:01 111m␤»

[16:45] <ash_> rakudo: my $foo = 5; sub f { say $foo } ;  f ; {my $foo = 6; f};

[16:45] <p6eval> rakudo 04a918: OUTPUT«5␤5␤»

[16:47] *** ashleydev_ joined
[16:48] <isBEKaml> ash_: right. Given that global variables can be difficult to track, how exactly do dynamic variables resolve this?

[16:49] <isBEKaml> the compiler tries to track the block where this was defined and use them according to the scope. But isn't it actually like global in that sense? 

[16:49] <isBEKaml> rakudo: sub f { say $*foo }; my $*foo = 5; f; { my $*foo = 6; f; } f;

[16:49] <p6eval> rakudo 04a918: OUTPUT«===SORRY!===␤Confused at line 11, near "{ my $*foo"␤»

[16:49] <isBEKaml> rakudo: sub f { say $*foo }; my $*foo = 5; f; { my $*foo = 6; f; }; f;

[16:49] <p6eval> rakudo 04a918: OUTPUT«5␤6␤5␤»

[16:50] <ash_> dynamic variables are based on scope, its looks up the stack frames till it finds a matching variable with that name or a GLOBAL 

[16:50] <isBEKaml> right... I get this now.. 

[16:50] *** ashleydev left
[16:50] <ash_> so, if you change a variable in an inner scope, like $*IN to point to something new and call a function, everyone that tries to write to $*IN gets directed to the new $$*IN 

[16:50] <ash_> instead of the global $*IN 

[16:52] <ash_> s/$$/$/

[16:52] <isBEKaml> TIL about dynamic variables and the difference between global and dynamic variables! :)

[16:52] <ash_> TIL?

[16:53] <isBEKaml> I had never heard of dynamic variables attaching themselves to scopes/blocks until now. 

[16:53] <masak> wow, I just realized I have no idea how the 'state' declarator would be implemented. perhaps someone would like to enlighten me?

[16:53] <isBEKaml> Today I Learned (/me looks at reddit)

[16:53] <jnthn> masak: I did an implementation of that once...

[16:53] *** ashleydev_ left
[16:53] <masak> jnthn: :)

[16:54] <ash_> ah got ya, perl5 has dynamic variables too

[16:54] <jnthn> Wonder if I can remember how I did it. ;-)

[16:54] <arnsholt> isBEKaml: Some Lisps have only dynamic variables. They're a very powerful tool in cases like globals

[16:54] <masak> isBEKaml: the middle third of this post contains a revelation I had about dynamic variables (also known as "contextuals"): http://use.perl.org/~masak/journal/40333

[16:54] <ash_> isBEKaml: in perl5 'local $f' makes $f a dynamic variable 

[16:54] <masak> jnthn: ok, so here's my problem. there's the lexpad and the static lexpad.

[16:55] <masak> jnthn: a 'state' variable needs to survive between invocations of a function, for example.

[16:55] <jnthn> Right, but it doesn't want to live in the static lexpad either really

[16:55] <masak> because you can't change it!

[16:55] <jnthn> That too

[16:55] <isBEKaml> arnsholt: Can you elaborate? I'm learning about FP too and would like more info. :)

[16:55] <jnthn> Also because it's get clozhures rong.

[16:56] <masak> isBEKaml: Perl 1 only had dynamic variables.

[16:56] <masak> jnthn: so, how *is* it done? :)

[16:56] <jnthn> I did it by attaching an extra table on-demand to store the state variables in.

[16:56] <jnthn> iirc attaching to Parrot sub

[16:56] <isBEKaml> ash_: ah, local $foo. I didn't think of them as dynamic variables, just as named variables specific to _this_ block and forget later. 

[16:56] <arnsholt> isBEKaml: The important concepts here are lexical and dynamic scope (see http://en.wikipedia.org/wiki/Lexical_scope#Lexical_versus_dynamic_scoping)

[16:57] <jnthn> And cloning it lost it.

[16:57] <jnthn> Or something like that.

[16:57] <jnthn> Essentially you don't want it to survive over a closure being taken.

[16:57] <arnsholt> Lexical scope is stuff that belongs "textually" with the use of something (variables in this case), while dynamic is resolved via the call chain whenever it's used

[16:57] <isBEKaml> masak: Perl 1 ? 

[16:58] <jnthn> Anyway, I then had a call (or op or something) that was emitted at the start of things with state variables that would restore them from this extra table.

[16:58] <ash_> Common Lips does both static variables and dynamic variables, scheme does only static variables (no dynamic's anymore) 

[16:58] <arnsholt> Dynamic scope is a lot easier to deal with, since you can just walk up your call stack to find stuff, while lexical scope is usually more useful

[16:59] <arnsholt> Emacs Lisp is probably the most common language that only has dynamic variables today

[17:00] *** thebird left
[17:00] <masak> isBEKaml: sorry, I don't understand the question. :)

[17:00] <isBEKaml> <masak> isBEKaml: Perl 1 only had dynamic variables.

[17:00] *** dakkar left
[17:00] <masak> <isBEKaml> masak: Perl 1 ? 

[17:00] <masak> what is it you're asking?

[17:00] <arnsholt> isBEKaml: Perl 1 is simply the first version of Perl TimToady released, way back when

[17:01] <masak> arnsholt++ # understanding the question :)

[17:01] <isBEKaml> Perl 1 *only* had dynamic variables... 

[17:01] <isBEKaml> ? 

[17:01] *** TiMBuS left
[17:01] <masak> isBEKaml: as opposed to both dynamic and lexical ones.

[17:01] <masak> isBEKaml: the my/local separation came later.

[17:01] <isBEKaml> ah, okay..  I got on perl only since 5.8.8. :)

[17:01] <moritz_> 'my' only was introduced in perl 5, iirc

[17:02] <slavik> ooh, speaking of 'my' will types also be allowed as optional?

[17:03] <moritz_> rakudo: my $x = 3; say $x # no typing necessary

[17:03] <isBEKaml> arnsholt: in all the languages that I dealt with (except perl as we know now :) ),  I only had seen lexical and global variables. Thinking of some variables as dynamic is new to me. 

[17:03] <p6eval> rakudo 04a918: OUTPUT«3␤»

[17:04] <isBEKaml> slavik: I guess, here the type is inferred by the compiler. 

[17:04] <isBEKaml> rakudo: my $x = 5; say $x.WHAT; my Int $y = 50; say $y.WHAT; 

[17:04] <p6eval> rakudo 04a918: OUTPUT«Int()␤Int()␤»

[17:04] <slavik> :D

[17:04] <slavik> rakudo: my Number $a=5; say $a.WHAT

[17:04] <p6eval> rakudo 04a918: OUTPUT«===SORRY!===␤In "my" declaration, typename Number must be predeclared (or marked as declarative with :: prefix) at line 11, near " $a=5; say"␤»

[17:05] <ash_> Num

[17:05] <isBEKaml> Num, I htink

[17:05] <slavik> rakudo: my Num $a=5; say $a.WHAT

[17:05] <p6eval> rakudo 04a918: OUTPUT«Int()␤»

[17:05] *** ashleydev joined
[17:05] <slavik> is that supposed to happen?

[17:05] <ash_> rakudo: say 5.^parents 

[17:05] <p6eval> rakudo 04a918: OUTPUT«Cool()Any()Mu()␤»

[17:05] <isBEKaml> All Nums are cool! :D

[17:05] <slavik> parents?! ooh

[17:06] <ash_> slavik: yeah, thats fine, an Int fits in a Num 

[17:06] <slavik> perl6 is getting close to * ;)

[17:06] <moritz_> no, Int ~~ Num is a fossile

[17:06] <slavik> ash_: but I requested a Num ...

[17:06] <ash_> oh, it is? 

[17:06] <slavik> wait, huh?

[17:06] <masak> isBEKaml: I think I'm about to blow your mind, then. :)

[17:06] <isBEKaml> slavik: Int <: Num

[17:06] <masak> alpha: sub foo { state $a = 5; say $a++ }; foo; foo; foo

[17:06] <slavik> moritz_: I lost you there

[17:06] <p6eval> alpha 30e0ed: OUTPUT«5␤6␤7␤»

[17:06] <masak> isBEKaml: what about that? :)

[17:07] <isBEKaml> masak: sure, yeah!

[17:07] <isBEKaml> no, don't tell me yapsi. I just noticed it. :)

[17:07] <ash_> masak: also known as static variables in C :P 

[17:07] <masak> ash_: except that Perl 6 also does cloning :)

[17:07] <ash_> i like the name state though, it fits better 

[17:08] <ash_> rakudo: say 12.0.^parents

[17:08] <p6eval> rakudo 04a918: OUTPUT«Cool()Any()Mu()␤»

[17:08] <isBEKaml> masak: cloning? Shallow or deep ? :P

[17:08] <masak> isBEKaml: shallow, I guess. cloning of the closures.

[17:09] *** tylercurtis joined
[17:13] <isBEKaml> rakudo: my @arr=<a b c d>; @arr.^methods.sort.join(",").say

[17:13] <p6eval> rakudo 04a918:

[17:13] <p6eval> ..OUTPUT«,ACCEPTS,ACCEPTS,BUILD,BUILDALL,Bool,Bool,CREATE,Capture,Capture,Int,Num,Num,Numeric,Numeric,PARROT,REJECTS,Seq,Str,Str,Str,WALK,WHENCE,WHERE,WHICH,abs,acos,acosec,acosech,acosh,acotan,acotanh,all,any,asec,asech,asin,asinh,at_key,at_pos,at_pos,at_pos,atan,atan2,atanh,batch,bless,by…

[17:13] <ash_> alpha: my &a = -> $b { state $a = 3; $a += $b; say $a }; my &b = &a.clone;  a 4; b 3; a 4; b 5;

[17:13] <p6eval> alpha 30e0ed: OUTPUT«7␤6␤11␤11␤»

[17:13] <ash_> wow, that works 

[17:13] <ash_> nifty 

[17:13] <isBEKaml> methods repeated. is that supposed to happen? 

[17:13] <pmichaud> those are multimethods

[17:14] <pmichaud> (so yes)

[17:14] <ash_> cloning the closure copied the state variable 

[17:14] <ash_> rakudo: my @arr = <a b c>; say ~@arr.^methods(:local).sort

[17:14] <p6eval> rakudo 04a918: OUTPUT«at_pos delete new perl splice␤»

[17:15] <isBEKaml> what does ~prefix do? 

[17:15] <isBEKaml> I think I see that one as ~ concat... 

[17:16] <isBEKaml> and I didn't know about :local. P6 blows my mind everyday! :)

[17:18] <isBEKaml> ash_: that was pretty nifty. Closures are cloned as masak++ said.. :)

[17:18] <jnthn> pmichaud: multis flatten?

[17:19] <ash_> isBEKaml: prefix:<~> will stringy whatever its prefixing

[17:19] <jnthn> pmichaud: I think it's more just that the methods are multiple times in the inheritance hierarchy.

[17:19] <isBEKaml> pmichaud: notice the "," starting the output.. 

[17:19] *** dalek left
[17:19] <ash_> rakudo: say ~31.123

[17:19] <pmichaud> jnthn: could be that also.

[17:19] <isBEKaml> a blank method? :D

[17:19] <p6eval> rakudo 04a918: OUTPUT«31.123␤»

[17:19] *** dalek joined
[17:19] <ash_> well, that was a silly example 

[17:19] <jnthn> pmichaud: I've never had multis flattening, fwiw.

[17:19] <pmichaud> right

[17:19] <jnthn> pmichaud: That may have changed when you re-did lists.

[17:19] <ash_> rakudo: my $a = ~1; say $a.WHAT, $a;

[17:19] <pmichaud> my point was simply that there's more than one method of the same name in the set.

[17:19] <p6eval> rakudo 04a918: OUTPUT«Str()1␤»

[17:19] <sorear> good morning #perl6

[17:19] <jnthn> ah, OK

[17:19] <pmichaud> probably shouldn't have said "multi"

[17:19] <jnthn> Then I agree

[17:19] <jnthn> Yes, that's what confused me. :-)

[17:20] <jnthn> o/ sorear 

[17:20] <ash_> prefix:<+> converts something to a number 

[17:20] <isBEKaml> ash_: yes, I was aware of + for numifying things.. 

[17:20] *** Khisanth joined
[17:21] <isBEKaml> no, I'm still aware of infix:<+>!

[17:21] *** gbacon joined
[17:21] <isBEKaml> :P

[17:21] <ash_> ~ on an array will do .join(' ') 

[17:21] <ash_> prefix:<~> that is 

[17:21] <ash_> rakudo: sub postfix:<!> (Int $b) { [*] 1..$b }; say 5!;

[17:21] <p6eval> rakudo 04a918: OUTPUT«120␤»

[17:22] <isBEKaml> ash_: yes, audreyt++ (I think I saw that in a presentation she gave)

[17:22] <masak> jnthn: thinking about it, it seems to me that the 'state' information has to be stored on the Code object.

[17:23] <ash_> isBEKaml: i think its easier to think of variables as prefix:<sym> instead of simply '+' because they can be used in so many different ways. its important to distinguish the differences 

[17:24] <pmichaud> (the dynamic Code object)

[17:24] <masak> aye.

[17:24] <isBEKaml> ash_: right. context is important. 

[17:24] <masak> gosh, I could really talk about variables all day!

[17:26] <isBEKaml> .OUTPUT«,ACCEPTS,ACCEPTS

[17:26] <ash_> my %a = 'a' => 4, '4' => 2; say +%a; # prefix:<+> on arrays and hashes gives you the length 

[17:26] <isBEKaml> the "," before first ACCEPTS - is that right? 

[17:26] <pmichaud> "number of elements"

[17:26] <pmichaud> (there is no 'length' in Perl 6 :-)

[17:26] <ash_> okay, yeah, bad wording there, # of elements 

[17:28] *** patspam joined
[17:28] *** Mowah joined
[17:28] <isBEKaml> okay, so that explains the +@arr -1 idiom. :)

[17:29] <sorear> masak: I'm planning to implement state variables in niecza as anonymous lexicals in OUTER::

[17:29] <masak> sorear: hm, interesting.

[17:30] <ash_> isBEKaml: *-1 is easier to write

[17:30] <ash_> rakudo: my @a = <a b c>; say 'last element is ' ~ @a[*-a];

[17:30] <p6eval> rakudo 04a918: OUTPUT«Could not find sub &a␤  in <anon> at line 11:/tmp/fhoMD4mbZq␤  in 'Any::postcircumfix:<[ ]>' at line 1564:CORE.setting␤  in main program body at line 1␤»

[17:30] <ash_> rakudo: my @a = <a b c>; say 'last element is ' ~ @a[*-1]; # oops 

[17:31] <p6eval> rakudo 04a918: OUTPUT«last element is c␤»

[17:32] <isBEKaml> rakudo: my @a = <a b c d>; for 0 .. +@a -1 -> $i { say @a[$i] }; ## Saw this kind of usage in old pugs code examples. 

[17:32] <p6eval> rakudo 04a918: OUTPUT«a␤b␤c␤d␤»

[17:33] <pmichaud> ick.

[17:33] <ash_> rakudo: my @a = <a b c>; for @a.keys -> $i { say @a[$i] }

[17:33] <pmichaud> new way of doing that:

[17:33] <p6eval> rakudo 04a918: OUTPUT«a␤b␤c␤»

[17:33] <ash_> #is how i'd do it... 

[17:33] <moritz_> only if you actually need $i somewhere else

[17:33] <pmichaud> rakudo:  my @a = <a b c d>;  for ^@a -> $i { say @a[$i] }

[17:33] <moritz_> otherwise you can just iterate @a directly

[17:33] <p6eval> rakudo 04a918: OUTPUT«a␤b␤c␤d␤»

[17:33] <lue> ohai o/

[17:33] <pmichaud> rakudo:  my @a = <a b c d>;  for @a.kv -> $i, $v { say "$i: $v" }

[17:33] *** masak left
[17:33] <ash_> pmichaud++ for being even more awesome in his example 

[17:34] <p6eval> rakudo 04a918: OUTPUT«0: a␤1: b␤2: c␤3: d␤»

[17:34] <moritz_> pmichaud: I actually prefer @a.keys, in case it's a specially shaped array

[17:34] <pmichaud> moritz_: in which case, .kv might be nicer :-)

[17:34] <pmichaud> but yes, TMTOWTDI

[17:34] <isBEKaml> lue: your photo was released today. :P

[17:34] <lue> no it wasn't.

[17:34] *** cinch joined
[17:35] <isBEKaml> Life.U.Everything! 

[17:35] <isBEKaml> http://www.nzherald.co.nz/space/news/article.cfm?c_id=325&objectid=10657065 ## gee.. 

[17:35] <moritz_> rakudo: say 'abc'.list.WHAT

[17:36] <p6eval> rakudo 04a918: OUTPUT«List()␤»

[17:37] <isBEKaml> coming back to that icky example I gave, in that particular file the $i was really needed. moritz_ was right on that. 

[17:38] *** Ross left
[17:38] <isBEKaml> rakudo: my $iter  = 0 ... 5; say $iter.WHAT; 

[17:38] <p6eval> rakudo 04a918: OUTPUT«Int()␤»

[17:38] <isBEKaml> really? 

[17:39] <pmichaud> that's weird.

[17:39] <pmichaud> rakudo:  say (0 ... 5).WHAT;

[17:39] <p6eval> rakudo 04a918: OUTPUT«List()␤»

[17:39] <pmichaud> rakudo:  say (0...5).item.WHAT

[17:39] <isBEKaml> rakudo: my $iter  = 0 ... 5; for ^$iter -> $i { say $i; }

[17:39] <p6eval> rakudo 04a918:  ( no output )

[17:39] <p6eval> rakudo 04a918: OUTPUT«List()␤»

[17:40] <isBEKaml> rakudo: my $iter  = (0 ... 5); for ^$iter -> $i { say $i; }

[17:40] <p6eval> rakudo 04a918: OUTPUT«0␤1␤2␤3␤4␤5␤»

[17:40] <pmichaud> isBEKaml: I'm not sure what you're expecting there.

[17:40] <pmichaud> rakudo:  my $iter = (10 ... 15);   for ^$iter -> $i { say $i; }

[17:40] <p6eval> rakudo 04a918: OUTPUT«0␤1␤2␤3␤4␤5␤»

[17:40] <pmichaud> rakudo:  my $iter = (10 ... 15);  say $iter;

[17:41] <p6eval> rakudo 04a918: OUTPUT«10 11 12 13 14 15␤»

[17:41] <pmichaud> rakudo:  my $iter = (10 ... 15);  say $iter.WHAT;

[17:41] <p6eval> rakudo 04a918: OUTPUT«List()␤»

[17:41] <pmichaud> ohhhh!

[17:41] <pmichaud> okay

[17:41] <pmichaud> I understand.

[17:41] <isBEKaml> Oh... 

[17:41] <pmichaud> my $iter = 10 ... 15

[17:41] <pmichaud> parses as

[17:41] <pmichaud> (my $iter = 10) ... 15

[17:42] <jnthn> That's...surprising.

[17:43] <jnthn> rakudo: my $r = 10 .. 15; say $r.WHAT

[17:43] <isBEKaml> I'm not quite sure I understand ^$iter. It just spews out indexes ? 

[17:43] <pmichaud> Yes.  I'm still not a fan of the item-assignment form of '='

[17:43] <p6eval> rakudo 04a918: OUTPUT«Range()␤»

[17:43] *** cdarroch left
[17:43] <jnthn> I thought .. and ... would have same precedence?

[17:43] <pmichaud> isBEKaml: ^$value  is the same as   0..^$value

[17:43] <pmichaud> jnthn: .. is much higher precedence

[17:43] <pmichaud> isBEKaml: which means "0 up to $value"

[17:43] <lue> is ... higher than = though?

[17:44] <isBEKaml> lue: = seems higher than ...

[17:44] <pmichaud> ... is lower than item assignment, but higher than list assignment

[17:44] <jnthn> pmichaud: Any idea why?

[17:44] <jnthn> Yeah, I can see it in the grammar now.

[17:44] <pmichaud> my @a = 1...5;   # same as   my @a = (1...5);

[17:44] <pmichaud> my $a = 1...5;    # same as    (my $a = 1) ... 5;

[17:44] <jnthn> I was more after rationale for them being different.

[17:45] <pmichaud> jnthn: could be fossil

[17:45] *** cdarroch joined
[17:45] *** cdarroch left
[17:45] *** cdarroch joined
[17:45] <pmichaud> could be so that    my $range = 1..5;  dtrt

[17:45] <jnthn> It feels a bit like a violation of the principle of least surprise. But maybe ... being same as .. would be surprising in other ways...

[17:45] <lue> hrm, feels inconsistent.

[17:45] <jnthn> Oh

[17:45] <pmichaud> yes, having ... higher would be very strange

[17:45] <jnthn> maybe it's that

[17:45] <isBEKaml> I have often seen people interchange ... and .. in p5 code. 

[17:45] <jnthn> 1,2,3 ... *

[17:46] <jnthn> Would it need to be (1,2,3) ... * if it had same prec as .. ?

[17:46] <pmichaud> no

[17:46] <pmichaud> comma is lower

[17:46] <pmichaud> but

[17:46] <jnthn> OK, then I'm out of guesses. :-)

[17:46] <pmichaud>     $a // 3 ... *

[17:46] <lue> rakudo: say (1..5).WHAT; say (1...5).WHAT

[17:46] <p6eval> rakudo 04a918: OUTPUT«Range()␤List()␤»

[17:46] <pugssvn> r31560 | moritz++ | [t/spec] switch split-simple.t to planless testing 

[17:46] <pmichaud> $a ?? 3 !! 5 ... *

[17:46] <isBEKaml> so it feels like a nasty surprise.. :(

[17:47] <pmichaud> it's an interesting question about precedence there.  I wonder how TimToady++ will respond.  :-)

[17:47] <jnthn> pmichaud:  on  $a // 3 ... * I'm not sure how i'd most naturally read that tbh.

[17:47] <pmichaud> jnthn: me either :-)

[17:48] <jnthn> If I was writing it I'd probably write parens for making either meaning lcear.

[17:48] <jnthn> *clear

[17:48] <lue> is // integer division?

[17:48] <jnthn> defined or

[17:48] <jnthn> like || but checks definedness rather than truth

[17:48] <pmichaud> jnthn: only if you recognized it could be unclear, though.  :-)

[17:48] <moritz_> lue: it's defined-or

[17:48] <jnthn> pmichaud: true ;)

[17:48] <lue> (I see it as ($a // 3) ... *)

[17:49] <pmichaud> lue:  what about

[17:49] <pmichaud>     my @x = $a // 3 ... *

[17:49] <pmichaud> ...now how would you see it?

[17:49] <pmichaud> or even better:

[17:49] <pmichaud>     my @x = $a.list // 3 ... *

[17:49] <pmichaud> (although I guess .list would always be defined)

[17:49] * lue --brain > /usr/include/null

[17:50] <pmichaud> or how about:

[17:50] <pmichaud> my @a = @b || 3,5,7 ... *

[17:51] <lue> I think you'd be in a very interesting position to try that w/o parens.

[17:51] *** Ross joined
[17:52] <lue> rakudo: multi sub postcircumfix:<( )>($a, $b) { $a * $b }; say 3(5);

[17:52] <p6eval> rakudo 04a918: OUTPUT«invoke() not implemented in class 'Integer'␤  in main program body at line 11:/tmp/FEN2f9aoHd␤»

[17:52] <isBEKaml> rakudo: my @b; my @a = @b || 3,5,7 ... *; @a.perl.say; 

[17:52] <p6eval> rakudo 04a918:  ( no output )

[17:53] <isBEKaml> rakudo: my @b; my @a = @b // 3,5,7 ... *; @a.perl.say; 

[17:53] <p6eval> rakudo 04a918:  ( no output )

[17:53] <isBEKaml> I guess I'm wrong about defined-or... @b.defined? 

[17:54] <isBEKaml> rakudo: my @b; @b.defined.perl.say;

[17:54] <p6eval> rakudo 04a918: OUTPUT«Bool::True␤»

[17:54] * isBEKaml slaps head.. 

[17:56] <lue> should I give my patch for the beginnings of ::= ? I'm waiting to resolve some failed tests first, though...

[17:58] <lue> in S03-operators/binding-arrays.t, the last test compares to a specific wording in an Exception. I feel that needs to be changed to a simple die_ok

[17:59] <moritz_> lue: most of those tests have a very good reason to check that the exception has something to do with the actual error

[17:59] <moritz_> lue: often it's OK to change the regex, but a simple dies_ok often is not enough

[18:00] <ingy> greetings

[18:00] <phenny> ingy: 16:13Z <masak> tell ingy testml-pm6 added; you're now a proto contributor, so the next one you'll be able to add yourself. :)

[18:00] <lue> The problem I have with checking for the exact wording is that the exact error is usually implementation-dependent.

[18:00] <ingy> phenny: tell masak \o/

[18:00] <phenny> ingy: I'll pass that on when masak is around.

[18:00] <lue> moritz_: what regex? here's the line:   ok $! ~~ Exception, "Can't bind Int to array";

[18:00] *** whiteknight joined
[18:00] <moritz_> lue: yes, it's something that needs to be addressed by standardizing error messages... which the tests do

[18:01] <moritz_> lue: that just checks that $! is an Exception, nothing more

[18:01] <ingy> phenny: tell lichtkind I'll look into it.

[18:01] <phenny> ingy: I'll pass that on when lichtkind is around.

[18:01] <moritz_> lue: the string is a just the test lable passed to ok()

[18:01] <lue> durrh.

[18:01] <lue> .oO(me thtupid) then I'll have to see why it comes out not ok

[18:04] <lue> well, here's why it failed:

[18:04] <lue> > my @a := 1; print @a ~ " "; say @a.WHAT

[18:04] <lue> 1 Int()

[18:05] *** whiteknight left
[18:05] <lue> that ain't good.

[18:05] <moritz_> or in other words, your binding implementation doesn't properly type check

[18:05] <jnthn> It may fwiw also be that my @a; doesn't tag @a with a Positional constraint.

[18:06] <lue> rakudo: my @a; say @a.WHAT

[18:06] <moritz_> lue: what does  my Positional $a; $a := Int; say $a.WHAT; prodcue?

[18:06] <p6eval> rakudo 04a918: OUTPUT«Array()␤»

[18:06] <moritz_> default type != type constraint

[18:07] <lue> > my Positional $a; $a := Int; say $a.WHAT;

[18:07] <lue> You cannot bind a variable of type Int() to a variable of type Positional().

[18:08] <moritz_> that's good

[18:08] <moritz_> if that's the biggest problem, I think the patch is still worth submitting

[18:08] *** eternaleye joined
[18:09] <lue> yeah, I just wanted to make more tests run to make the patch 75.4% more effective :)

[18:10] <moritz_> is  "".split('').elems, 0, q/"".split()/;

[18:10] *** charsbar_ left
[18:11] <moritz_> is  "".split(':').elems, 1, q/"".split(':')/;

[18:11] <moritz_> "huh"

[18:11] *** charsbar joined
[18:11] <moritz_> that's from split.t

[18:12] <moritz_> both blessed by larry, but the first somewhat recent-ish (2009 or so), the second 2006

[18:14] *** dakkar joined
[18:17] <ash_> the second one seems odd... 

[18:17] <ash_> "".split('') makes almost sense that it would be 0 

[18:17] <moritz_> I'm gald I'm not the only one thinking that :-)

[18:17] <moritz_> *glad

[18:17] <ash_> "".split(':').elems, 1 baffles me 

[18:17] <moritz_> the test assumes the result is an string

[18:18] <moritz_> just like "foo".split("bar") returns "foo", ie a one-item list

[18:18] <lue> http://gist.github.com/465734 there is ::=. enjoy! ::=)

[18:19] <pmichaud> lue: needs to return $target

[18:19] <pmichaud> (easiest way is to change that __vPs to __0Ps

[18:19] <moritz_> rakudo: my $x := 3; say $x

[18:19] <pmichaud> afk, fetching lunch

[18:19] <p6eval> rakudo 04a918: OUTPUT«:= binding of variables not yet implemented␤  in 'infix:<:=>' at line 671:CORE.setting␤  in main program body at line 11:/tmp/ixGOhHBraq␤»

[18:19] <lue> alright (stupid signatures...)

[18:19] <moritz_> uhm

[18:19] <pmichaud> didn't review/apply the := patch yet.  I'll do that when I get back.

[18:20] <moritz_> ah

[18:20] <pmichaud> (please don't apply to master before I review it)

[18:20] * moritz_ didn't know ther was a previous patch

[18:20] <moritz_> no worry, wasn't my plan

[18:20] *** envi^home left
[18:22] <lue> gah, repasting. ignore the link above.

[18:23] *** ashleydev_ joined
[18:25] *** ashleydev left
[18:25] *** ashleydev_ is now known as ashleydev

[18:27] <lue> I also have some binding tests to push, but that'll be after the patches have been applied (of course)

[18:32] <lue> http://gist.github.com/465750 there's ::=, with the change suggested by pmichaud

[18:35] *** christine left
[18:37] *** pyrimidine left
[18:39] *** ruoso left
[18:39] *** Trashlord left
[18:39] *** ive joined
[18:43] *** ashleydev_ joined
[18:44] *** ive left
[18:44] *** Mowah left
[18:45] *** ashleydev left
[18:45] *** ashleydev_ is now known as ashleydev

[18:45] *** supernovus joined
[18:46] *** Chillance joined
[18:52] <arnsholt> nqp: my @a := (1,2,3); my @b; @b.push: $_ for @a; say(@b);

[18:52] <p6eval> nqp: OUTPUT«3␤»

[18:52] <arnsholt> Huh.

[18:54] <arnsholt> Oh, my NQP is olded. right

[18:55] *** ruoso joined
[18:55] *** Mowah joined
[18:56] <pmichaud> #phasers today?

[18:59] <lue> phasers?

[19:00] <pmichaud> weekly rakudo meeting

[19:00] <pmichaud> every tuesday (although I forget the exact time)

[19:00] <lue> ah, it's been renamed

[19:01] <pmichaud> it might be delayed today due to world cup :)

[19:01] <lue> Netherlands are winning!

[19:03] <lue> for me, it's noon. (so now)

[19:04] *** cono left
[19:05] *** Mowah left
[19:05] <isBEKaml> lue: too early. It's only 30 mins into play. :)

[19:05] *** cono joined
[19:06] *** pjcj_ left
[19:06] *** ciphertext left
[19:07] *** pjcj joined
[19:11] <dalek> rakudo: e2f3019 | pmichaud++ | src/builtins/assign.pir:

[19:11] <dalek> rakudo: Change "Cannot assign to ..."  to   "Cannot modify ...".  TimToady++

[19:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e2f301981a8498834cdd7c1b80072695f57d690a

[19:11] <dalek> rakudo: 2b2f69c | pmichaud++ | docs/ROADMAP:

[19:11] <dalek> rakudo: Update ROADMAP with completed closures/autoviv items.

[19:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2b2f69c0997a5536a83bd1b33cd649773ae6dcdc

[19:16] *** Mowah joined
[19:17] <dalek> rakudo: 24e05c2 | moritz++ | src/core/Cool-str.pm:

[19:17] <dalek> rakudo: avoid type constraints in sub form of split()

[19:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/24e05c285b88ca7422f999a9a2bdae8d8afa5795

[19:17] <dalek> rakudo: 8aff115 | moritz++ |  (2 files):

[19:17] <dalek> rakudo: fix split() with zero-width matches; also run two more test files

[19:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8aff115c5887e76ad233bab782f4e5817880392a

[19:17] <pugssvn> r31561 | pmichaud++ | Unfudge some passing autoviv tests. 

[19:18] <jnthn> pmichaud: It's half time

[19:18] <jnthn> :-)

[19:18] <[particle]> and what a game!

[19:18] * moritz_ not so impressed

[19:19] <pmichaud> from t/spec/S32-scalar/undef.t

[19:19] <lue> The first goal of the Netherlands was impressive.

[19:19] <pmichaud> #?rakudo 2 skip 'todo: lists, defined, truthness'

[19:19] <pmichaud> is ?(@(Mu,)), Bool::False, '?(@(Mu,)) is false';

[19:19] <pmichaud> is ?(list(Mu,)), Bool::False, '?(@(Mu,)) is false';

[19:19] <jnthn> lue: Aye

[19:19] <arnsholt> I only saw the last 15 minutes of the half, but that last goal was epic

[19:19] <pmichaud> shouldn't those be true?

[19:19] * jnthn hopes Netherlands win it

[19:19] * isBEKaml guesses moritz_ is waiting for Germany's game to start... :)

[19:19] <moritz_> pmichaud: I agree

[19:19] <jnthn> pmichaud: I'd hope so

[19:19] <lue> Netherlands v. Germany would be exciting :)

[19:19] <moritz_> jnthn: mee too

[19:19] <TimToady> looks like someone was confusing Mu with Nil

[19:20] <pmichaud> should I change it to Nil, or change the result to True?

[19:20] <moritz_> isBEKaml: if the Netherlands continue to play like it does now, and Germany continues to play as they did on Saturday, .nl doesn't stand a chance

[19:20] <TimToady> do it both ways, and we get more tests :)

[19:20] <pmichaud> ah, there's a url

[19:20] <moritz_> pmichaud: both :-)

[19:20] <lue> .oO(Being half-German, I of course wish Germany to win)

[19:21] <isBEKaml> moritz_: I'm okay either way as long as it's a good contest!

[19:21] <moritz_> same here too

[19:22] <jnthn> .oO( Netherlands have stroopwafels and a speical somebody. Germany has awesome beer and currywurst. Hard choices! )

[19:22] <pmichaud> also, should it be testing flat() instead of list()?

[19:22] <jnthn> pmichaud: #phasers if it happens on time would be in 8 mins or so :-)

[19:23] <pmichaud> Seems to me that list(Nil,)  might be non-null (re-reading spec)

[19:23] <lue> jnthn: we also haz pretzels and other great bread product!

[19:23] <pmichaud> rakudo:  say list(Nil,).elems

[19:23] <lue> .oO(real pretzels, not the stupid cracker-thing they sell in stores)

[19:23] <p6eval> rakudo 04a918: OUTPUT«1␤»

[19:24] <pmichaud> rakudo:  say flat(Nil,).elems

[19:24] <jnthn> lue: That too

[19:24] <p6eval> rakudo 04a918: OUTPUT«0␤»

[19:24] *** buubot left
[19:24] <jnthn> lue: And mountains. :-)

[19:24] *** buu left
[19:24] <pmichaud> lue: do you have a url or ticket # for your := patch?

[19:24] <tylercurtis> lue: Are the real ones the soft kind?

[19:25] <lue> yes.

[19:25] * tylercurtis can now pretend to dislike the other kind because they're inauthentic. :)

[19:26] *** clochette joined
[19:26] <[particle]> the kind you can make a ham and cheese sandwich with

[19:27] *** patspam left
[19:27] <lue> := binding (2nd patch there to replace Q:PIR block):  http://gist.github.com/463775

[19:27] *** clochette left
[19:28] <lue> the hard little ones are still OK, but nothing like a _real_ pretzel.

[19:29] *** Mowah left
[19:29] *** plainhao left
[19:30] <TimToady> .^methods should probably be returning the longnames of multi methods

[19:30] <pmichaud> lue: why does the patch have "cannot bind to a readonly variable?"

[19:31] *** Guest23936 left
[19:31] <lue> rakudo: my ($a is readonly) = 3; $a = 2;

[19:31] *** f00li5h left
[19:31] <p6eval> rakudo 04a918: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 1␤»

[19:31] <lue> something like that. I could be wrong of course.

[19:31] <pmichaud> assignment isn't the same as binding

[19:32] <TimToady> rakudo: my $a is readonly = 3;

[19:32] <moritz_> #phasers?

[19:32] <p6eval> rakudo 04a918: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/sMk6BXr42m␤»

[19:32] <lue> yeah, I thought if the variable was set readonly, then it can't be modified anymore.

[19:32] <TimToady> that should work

[19:32] <pmichaud> lue: I think it can still be rebound.

[19:32] <TimToady> assignment to a declarator is not assignment :)

[19:33] <pmichaud> pir::copy__vvpp($target, pir::new__ppp('ObjectRef', $source));

[19:33] <pmichaud> has to be wrong.

[19:33] <pmichaud> should be pir::copy__vPP(...)

[19:34] <lue> (well, I coded := before that talk about ::=, so I of course might have done it differently now)

[19:34] *** rv2733 joined
[19:34] <lue> it works, though.

[19:34] *** Mowah joined
[19:34] <lue> .oO(although maybe that could be the cause of some test failures?)

[19:36] <ash_> some people in here are really good with git, right? I am having a weird issue when i try to merge upstream.... i thought you could do "git remote update; git merge remotename/remotebranch" to update your current branch to an upstream branch, but that's acting like a noop.. 

[19:37] *** christine joined
[19:37] <moritz_> ash_: if it's a noop, then remotename/remotebranch has the same commits as the current branch

[19:38] *** ashleydev_ joined
[19:38] <ash_> bit doing "git checkout remotename/remotebranch; git log" gives a different set of commits than the current' branches log 

[19:38] *** macdaddy joined
[19:39] *** macdaddy is now known as Guest99304

[19:40] *** rhr left
[19:40] <moritz_> ash_: just in different order, maybe?

[19:40] *** ashleydev left
[19:40] *** ashleydev_ is now known as ashleydev

[19:40] <isBEKaml> maybe in a different order or perhaps you didn't do git fetch ? 

[19:40] *** kensanata joined
[19:41] <ash_> moritz_: no, its like the merge didn't work 

[19:41] <moritz_> what does 'git status' say?

[19:42] <ash_> current, on branch 'gsoc_nci' 

[19:42] *** tri1 joined
[19:42] <isBEKaml> then it looks like there's either nothing to commit or the commit/push worked. 

[19:44] <ash_> when i checkout 'upstream' which is leto/upstream  (leto being leto's parrot mirror on github) it says" Your branch is ahead of 'leto/upstream' by 847 commits." 

[19:45] *** ashleydev_ joined
[19:46] <moritz_> if it were also behind, it would say it diverged

[19:47] <moritz_> so upstream leto/upstream doesn't have any commits that your local branch doesn't have

[19:48] <ash_> hmm, i am confused by this... where did my commits go? :-( 

[19:48] <[particle]> check your git log

[19:49] <moritz_> ash_: in your local branch

[19:49] *** ashleydev left
[19:49] *** ashleydev_ is now known as ashleydev

[19:50] <ash_> git log has my most recent commits

[19:50] <ash_> but i don't see any of the merge's or commits from leto/upstream

[19:51] <isBEKaml> I think that's because you worked on your own local branch. try git pull or git fetch 

[19:52] *** rhr joined
[19:53] <ash_> i have done both, actually i did git remote update which fetch's all remote's 

[19:53] <[particle]> should i expect spectest failures from earlier today?

[19:53] <[particle]> i see a number of S02 and S03 test files with non-zero exit codes

[19:58] *** rokoteko joined
[19:59] *** Mowah left
[20:01] <lue> > my @a = 1,2,3; @a[3] := @a[0]; say @a.perl

[20:01] <lue> [1, 2, 3]

[20:01] <lue> any suggestions as to why this isn't working like it should?

[20:02] <pmichaud> because your := doesn't know about WHENCE.  :-)

[20:02] <supernovus> I never seem to be able to sync my visits with masak. I was thinking of making an updated version of my DateTime/Date modifications based on the feedback from the patch review. My one question is, how should I proceed with the spectest updates? I have a commit bit on the repo, but am not sure what should be comitted first, the test changes or the library changes?

[20:03] *** Mowah joined
[20:03] <lue> how can I learn my code, then?

[20:03] <moritz_> supernovus: first of all nothing stops you from adding new files to the repo

[20:04] <moritz_> supernovus: rakudo doesn't run them by default, so you're on the safe side

[20:04] *** ashleydev left
[20:04] *** hercynium joined
[20:04] *** ashleydev joined
[20:06] <pmichaud> lue: after := has determined that it's safe to perform the binding, it needs to check the target value to see if there's a 'WHENCE' property set.  If so, execute the code store there before performing the copy.

[20:06] <pmichaud> see assign.pir for an example.  :)

[20:06] <pmichaud> (&infix:<=>, that is)

[20:07] *** ive joined
[20:07] *** Kodi joined
[20:07] <supernovus> moritz_: Okay. I want to add a few more tests to them before I commit. As for the patch, I'll submit a new version of it once I've cleaned it up.

[20:07] <moritz_> supernovus++

[20:07] <ash_> ah, moritz_ it seems leto/parrot hasn't been updated since june 20, which was why i didn't see the commits as they are all older than mine, so, yes, i am up to date, i am just silly 

[20:08] <moritz_> ash_: just ping dukeleto to update it

[20:08] <lue> So I must peruse the equalitie, then, to tell my own code to ponder the WHENCE. So be it, m'lud. </oldenglish>

[20:08] <supernovus> I guess the only other question was, the name of the role. It seemed DateLike wasn't exactly liked, and Dateish or something similar was being thrown around as a replacement.

[20:10] <lue> rakudo: my $a = 1; my @b = 2,3; say $a.WHENCE; say @b.WHENCE

[20:10] <p6eval> rakudo 04a918: OUTPUT«␤␤»

[20:13] <Kodi> I suggest Calendrical.

[20:14] <moritz_> Temporal

[20:15] <[particle]> SpaceTimey

[20:15] <Kodi> Question, though. I've been working on DateTime.pm over the past few days and I just learned of this patch. Would it be less work for you guys if I (a) merged it into what I've done or (b) wait until it's been applied to master to submit my own patch?

[20:15] <Kodi>  

[20:16] <supernovus> moritz_: If I go with Temporal, should I rename the current Temporal.pm to DateTime.pm and move the role Temporal into a new Temporal.pm ?

[20:17] <moritz_> supernovus: yes

[20:17] <moritz_> the rename should occur anyway

[20:17] <lue> .oO(TimeyWimey)

[20:18] <supernovus> Kodi: In case we have conflicting modifications, one of us should get a patch committed first, then the other should merge with that and submit the second patch. I have no real preference who should go first.

[20:19] <Kodi> supernovus: Okay, you go first. I'm not done, nor very near to being done.

[20:20] <Kodi> supernovus: I have written some tests of date validation which you might find useful—I guess I'll push those to pugs soon.

[20:20] <lue> pmichaud: that's wizard. I don't have it, and my git is up-to-date!

[20:21] *** tadzik joined
[20:21] *** Mowah left
[20:21] <supernovus> Kodi: Okay, well, I'm going to rename Temporal.pm to DateTime.pm and change the Role name to Temporal. Oh, date validation tests! Those were what I was going to add to test the validation code! Great minds and all that. :)

[20:22] <Kodi> supernovus: :)

[20:22] <pmichaud> lue: are you in a branch?

[20:22] <lue> well, now, it would help if I refreshed the buffer :)

[20:22] *** eternaleye_ joined
[20:22] <lue> [it's always the simple things that catch me]

[20:22] *** eternaleye left
[20:22] <Kodi> supernovus: Are you sure about the name "Temporal"? It's doesn't convey the sense of being about dates (as opposed to times) specifically.

[20:22] <pmichaud> heh

[20:23] <pmichaud> > say [+] [1,2,3]

[20:23] <pmichaud> 1 2 3

[20:23] <moritz_> wtf?

[20:23] <TimToady> yay

[20:23] <pmichaud> a reduce of one element returns that element.

[20:23] <pmichaud> which in this case, is an array.  :-)

[20:23] <pmichaud> so &infix:<+> never gets applied to it.

[20:23] <moritz_> I kinda thought it would do 0 + [1, 2, 3]

[20:23] <moritz_> but that was a fallacy

[20:23] *** Mowah joined
[20:23] <pmichaud> TimToady: is that the result you want/expect?

[20:24] <ash_> how would you get it to do 1 + 2 + 3? [+] |[1,2,3]?

[20:24] <TimToady> well, it's better than the old result :)

[20:24] <pmichaud> ENOTMYQUESTION

[20:24] <pmichaud> :)

[20:24] <pmichaud> yes, it's better.  :-)

[20:24] <supernovus> Kodi: I'm not sure about Temporal. It was just a suggestion from moritz_. Calendrical may be a better choice for naming.

[20:24] <lue> rakudo: say [+] 1,2,3

[20:24] <TimToady> if there is a 1-ary version of the infix, it should call it

[20:24] <p6eval> rakudo 04a918: OUTPUT«6␤»

[20:25] <pmichaud> should there be a 1-ary version of the infix?

[20:25] <moritz_> supernovus: I would also be fine with doing the date validation as class methods in Date

[20:25] <pmichaud> (in this case)

[20:25] <moritz_> supernovus: and call those from DateTime

[20:25] <moritz_> supernovus: which would mean we don't have to dome up with a new role name :-)

[20:25] <pmichaud> should the   default case be both 0-ary and 1-ary?

[20:25] <TimToady> I think we could expect 1-ary + to have the same effect as unary +, and likewise for ~

[20:25] <supernovus> moritz_: I had tried that first, and for some reason it didn't work.

[20:25] <pmichaud> i.e.,  instead of    sub infix:<+>() { 0 }     should we have    sub infix:<+>($x = 0) { $x }

[20:26] <TimToady> +$x

[20:26] <moritz_> supernovus: then it might be worth investigating why it didn't work

[20:26] <supernovus> Oh wait, never mind, I was still working with it when those were subs!

[20:26] <pmichaud> right, +$x

[20:26] <pmichaud> or should it really be two separate multi subs?

[20:26] <pmichaud> (and "multi')

[20:26] <TimToady> well, it needs to be a multi anyway

[20:26] <pmichaud> right

[20:26] <pmichaud> I forgot "multi" above.

[20:26] <TimToady> or you can't handle $x,$y

[20:27] <supernovus> moritz_: I will try your suggestion and get rid of the Role altogether.

[20:27] <TimToady> whatever's faster, if either

[20:27] <TimToady> I think it's kinda cute to write it as a default

[20:27] <pmichaud> the second form, then?

[20:27] <supernovus> It will also solve the augment issue with DateTime::strftime so the whole runtime role composition stuff can go bye-bye.

[20:27] <pmichaud> i.e.,   multi sub infix:<+>($x = 0) { +$x }

[20:27] <pmichaud> I like that.

[20:28] <pmichaud> perhaps all of the defaults should be written that way...?

[20:28] <TimToady> mebbe

[20:28] <pmichaud> it certainly makes reduce easier, because we don't have to do a bindability check.

[20:29] <tylercurtis> Does that mean "[+] [1, 2, 3]" will be "3"?

[20:29] <pmichaud> tylercurtis: yes.

[20:29] <TimToady> yes

[20:29] *** alester left
[20:29] <lue> whence() on L66 (assign.pir) implies that whence recieves something callable.

[20:30] <pmichaud> lue: it does.

[20:30] *** alester joined
[20:30] <pmichaud> lue: it receives the closure that describes how to vivify the target.

[20:30] <lue> ah, so I call whence, and then store like normal (if it applies of course)?

[20:30] <pmichaud> you call whence, and then do what you would've done otherwise.

[20:30] <tylercurtis> If I have an array and want to sum it with this change, what would I do? [+] list([1,2,3])

[20:31] <tylercurtis> ?

[20:31] <pmichaud> tylercurtis: [+]  [1,2,3].list

[20:31] <pmichaud> or

[20:31] <TimToady> if you have an array, you probably are naming it with @

[20:31] <pmichaud> [+]  @([1,2,3])

[20:31] <pmichaud> or

[20:31] <pmichaud> [+] @a

[20:32] <tylercurtis> Oh. So, [+] @a will still work? Great.

[20:32] <pmichaud> right

[20:32] <[particle]> and if my list contains only one item, [1,2,3]

[20:32] <moritz_> for [1,2,3].flat

[20:32] <pmichaud> @a interpolates,  $a and [1,2,3]  don't.

[20:33] <moritz_> s/for/or/

[20:33] *** patspam joined
[20:33] <pmichaud> note that   list([1,2,3])  still has only one element :-)

[20:34] <pugssvn> r31562 | Kodi++ | [t/spec/S32-temporal/DateTime] Corrected and extended. Rakudo should pass all of these once supernovus++'s patch is applied and mine is completed. 

[20:35] *** pragma_ left
[20:35] *** rv2733 left
[20:36] <pmichaud> TimToady: how about something like:    [==] 1  ?   still Bool::True?

[20:37] <lue> is it setup so any operator can function in [] ?

[20:37] <pmichaud> mainly infix operators

[20:37] <TimToady> chain operator imply AND so less than one comparison is always true

[20:37] <pmichaud> okay.

[20:37] <TimToady> since none of the comparisons falsify it

[20:37] <lue> what are those operators called? It's not hyper, or meta....

[20:37] <pmichaud> lue: reduce

[20:38] <pmichaud> or "reduction"

[20:38] <moritz_> and reduction operators are a form of meta operators

[20:38] <pmichaud> TimToady: [%] 1   ?   

[20:38] <TimToady> lue: this is all explained in S03...

[20:38] <pmichaud> "no 1-arg meaning for infix:<%>"  ?

[20:39] <pmichaud> or return the result?

[20:39] <pmichaud> rakudo:   say [%] 1;   # curious

[20:39] <p6eval> rakudo 04a918: OUTPUT«1␤»

[20:39] <pmichaud> oh, yeah.

[20:39] *** tadzik left
[20:39] <pmichaud> rakudo:   say  &infix:<%>(1)

[20:39] <p6eval> rakudo 04a918: OUTPUT«No applicable candidates found to dispatch to for 'infix:<%>'. Available candidates are:␤:()␤:(Int $a, Int $b)␤:(Real $a, Real $b)␤:(Any $a, Any $b)␤␤  in main program body at line 11:/tmp/dUhjHJGu0m␤»

[20:40] *** Kodi left
[20:40] <sorear> non associative operators shouldn't have no-arg meanings...

[20:40] <TimToady> well, [%]() is defined as fail, but by S03:4311 it should probably just return the value in question

[20:41] <sorear> now, %% should be a chaining comparative, and have the normal meaning for chainings

[20:41] <pmichaud> same for [/]

[20:41] <pmichaud> ?

[20:41] *** tri1 left
[20:42] <TimToady> I'm not sure %% should be chaining

[20:42] <lue> for the comparision, I can't just say if $target.WHENCE, right?

[20:42] <pmichaud> lue: you cannot.  it's a property, not a method.

[20:42] <pmichaud> (in rakudo's current impl)

[20:43] <lue> but $target.WHENCE on its own line calls WHENCE, correct?

[20:43] <pmichaud> lue: no.

[20:43] <lue> that would explain the Null PMC...

[20:43] <pmichaud> it's a PMC property, not a method.

[20:43] <TimToady> in fact, %% isn't chaining currently, but multiplicative

[20:44] *** pragma_ joined
[20:44] <pmichaud> eventually when it's really implemented as a role, you might be able to do   ($target.WHENCE).?()

[20:44] <pmichaud> but we're not there yet.

[20:44] *** pragma_ is now known as Guest7606

[20:44] <lue> so how to call it like assign.pir does...

[20:44] <moritz_> like assign.pir does.

[20:44] <moritz_> with getprop

[20:44] <pmichaud> heh

[20:45] <pmichaud> pir::getprop('WHENCE', $tgt).()

[20:45] <lue> ah, dankon.

[20:45] <dalek> rakudo: bbacb74 | util++ | docs/announce/2010.07:

[20:45] <dalek> rakudo: Add release announcement for 2010-07; preliminary version

[20:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/bbacb74a5ab8f15c9cb1d5804d677a4461be8b26

[20:45] <lue> Wait, I don't need the signatures?

[20:45] <lue> (the __PsP stuff)

[20:45] <pmichaud> for some you do.

[20:46] <pmichaud> but PAST knows about getprop, and there's only one sig.

[20:46] <pmichaud> (it never hurts to put the sig, so we tend to do that now)

[20:46] <pmichaud> also, note that lower-case 'p' is never valid in a signature.

[20:46] <pmichaud> (it may still work, but that's by luck and not by design)

[20:47] <[Coke]> nqp: pir::hcf()

[20:47] <p6eval> nqp: OUTPUT«error:imcc:syntax error, unexpected '\n', expecting '('␤     in file 'EVAL_1' line 10␤syntax error ... somewhere␤current instr.: 'parrot;PCT;HLLCompiler;evalpmc' pc 1047 (compilers/pct/src/PCT/HLLCompiler.pir:554)␤»

[20:47] <lue> (the signatures (when I come across a new PIR op I want) always mess me up)

[20:47] * [particle] misses parrot's hcf op

[20:47] <[Coke]> . o O (yes, I know.)

[20:47] * [Coke] does not.

[20:47] <pmichaud> I hope to eliminate the signatures someday.  But it will be nice to know what signatures we actually need.  :-)

[20:49] <lue> well, why not adopt P6's methods of multi subs? I've heard of them, they seem quite nice... :)

[20:49] <lue> (methods in a non-programming sense)

[20:49] <supernovus> gah, make: *** No rule to make target `src/builtins/Abstraction.pir', needed by `src/gen/builtins.pir'.  Stop.

[20:49] <pmichaud> ....and they totally don't map to the underlying virtual machine.

[20:50] <pmichaud> supernovus: re-configure, likely.

[20:50] <moritz_> bah, nqp-rx doesn't build with latest parrot

[20:50] <moritz_> /home/moritz/src/nqp-rx/parrot_install/bin/parrot -o nqp-setting.pbc src/gen/nqp-setting.pir

[20:50] <moritz_> error:imcc:The opcode 'delete_p_i' (delete<2>) was not found. Check the type and number of the arguments in file 'src/gen/nqp-setting.pir' line 86

[20:50] <moritz_> or maybe it's latest NQP-rx that doesn't build

[20:51] <moritz_> not related to parrot at all

[20:51] <supernovus> pmichaud: I did a realclean and re-ran configure, it's compiling now :-)

[20:51] *** rhr left
[20:52] <moritz_> pir::delete__vQi(self, $pos);

[20:52] <moritz_> what is Q?

[20:52] <pmichaud> keyed PMC

[20:52] <pmichaud> looks like it's a not-up-to-date parrot.

[20:52] <pmichaud> i.e., it appears to be using an outdated version of PCT

[20:52] <moritz_> ./parrot_install/bin/parrot_config revision

[20:52] <moritz_> 47426

[20:53] <moritz_> oh indeed

[20:53] <moritz_> that's too old

[20:53] * moritz_ wonders what went wrong in the rebuild process

[20:53] <lue> > my @a = 1,2,3; @a[3] := @a[0]; say @a.perl

[20:53] <lue> [1, 2, 3]

[20:54] <lue> I can (no)paste the new bit of code, if you like.

[20:56] <pmichaud> sure, I'll look.

[20:56] <lue> it's only three lines, so I could paste it right here.

[20:57] <pmichaud> that works too.

[20:57] *** kensanata left
[20:57] *** kensanata joined
[20:57] <lue>     if !pir::isnull(pir::getprop__PsP('WHENCE', $target)) {

[20:57] <lue>         pir::getprop__PsP('WHENCE', $target).();

[20:57] <lue>     }

[20:58] <pmichaud> note that you have to descalarref $target

[20:58] <dalek> nqp-rx: 60e0c27 | moritz++ | src/Regex/P6Regex/Actions.pm:

[20:58] <dalek> nqp-rx: make subrule_alias a method, so that subclasses can reuse it easily

[20:58] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/60e0c27c8817135ea8f8efec51312e30b55cab80

[20:58] <pmichaud> otherwise it's getting the WHENCE property of the container, not of the value.

[20:58] <lue> so pir::descalarref ?

[20:58] <pmichaud> pir::descalarref__PP

[20:59] <lue> ah, and just stick it in place of $target both times? [pir::descalarref__PP($target)]

[20:59] <pmichaud> yes.

[21:00] <[Coke]> btw, I'm pretty sure the goto NEXT() at the end of the op is the default.

[21:00] * [Coke] will double check that later.

[21:01] <pmichaud> [Coke]: you're likely correct -- I'm not sure we ever updated when Parrot made that change.

[21:02] <lue> ( hopefully, at some point I can stop asking so many questions :) )

[21:03] <[Coke]> pmichaud: I'd like some verbiage for Rakudo * in the compiler release this month.

[21:03] <[Coke]> If no one beats me to it, I'll commit something you can fix =-)

[21:03] <pmichaud> [Coke]: I'll make sure to have some there.

[21:03] <dalek> nqp-rx: 04f7885 | moritz++ | src/stage0/ (3 files):

[21:03] <dalek> nqp-rx: update bootstrap files to get latest setting and subrule_alias updates

[21:03] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/04f7885c424a57ecc90d2d0f25ae6cf032ae175e

[21:05] *** pmurias joined
[21:05] <[Coke]> even something like "This is /not/ Rakudo *; see www.rakudo.org" would be minimally required, I think.

[21:05] <pmurias> is it possible to add new lexicals my modifing MY:: at BEGIN time?

[21:06] <moritz_> I thought we had a "this not Rakudo *" in the previous release announcements too

[21:06] <sorear> pmurias: maybe.  the spec is unclear

[21:06] <[Coke]> moritz_: not that I see in the release announces.

[21:06] <[Coke]> s/see/ack/

[21:07] <pmurias> sorear: MY.declare_stub_symbols can add new lexicals

[21:07] <moritz_> [Coke]: right, I don't see it either

[21:08] <sorear> pmurias: that doesn't look very much like standard Perl 6 to me

[21:08] <moritz_> wasn't that in a S11 document at some point?

[21:08] *** ive left
[21:08] <pmurias> it's there still

[21:08] <moritz_> right

[21:08] <lue> > my @a = 1,2,3; @a[3] := @a[0]; say @a.perl ~ ' \o/ \o/ :D'

[21:08] <lue> [1, 2, 3, 1] \o/ \o/ :D

[21:09] * pmurias updates his repo to make sure

[21:09] <moritz_> pmurias: you're right

[21:09] *** Mowah left
[21:09] <pmurias> but it doesn't seem something intended for everyday use

[21:09] <sorear> pmurias: um, that's pseudocode.

[21:10] <moritz_> I don't think it was intentend to be pseudo code

[21:12] <moritz_> -> bed

[21:12] <lue> goodnight o/

[21:13] *** kensanata left
[21:18] <lue> should I generate Yet Another Patch for my changes to := ?

[21:23] *** rhr joined
[21:24] <lue> in any case, it's here: http://gist.github.com/465939

[21:25] *** Guest51578 left
[21:26] <pmurias> YOU_ARE_HERE in the setting creates a snapshot of the lexical scope, how deep is that?

[21:27] *** masak joined
[21:27] <masak> \ӝ/

[21:27] <phenny> masak: 18:00Z <ingy> tell masak \o/

[21:27] <pmurias> do the variables get cloned

[21:27] <masak> dang, missed #phasers. :/

[21:27] <pmurias> ?

[21:27] <pmurias> and how should YOU_ARE_HERE be tested

[21:27] <pmurias> ?

[21:28] <pmichaud> (note that Rakudo's implementation is almost certainly wrong.)

[21:28] <lue> ӝ

[21:28] <pmichaud> (of YOU_ARE_HERE)

[21:28] <lue> .u ӝ

[21:28] <phenny> U+04DD CYRILLIC SMALL LETTER ZHE WITH DIAERESIS (ӝ)

[21:29] <pugssvn> r31563 | novus++ | Preparation for my new patch, and Kodi's upcoming patch. 

[21:29] <jnthn> masak: You're fired!

[21:29] <jnthn> ;-)

[21:29] <masak> :)

[21:29] <masak> sorear: been thinking about the 'state vars as anon lexicals in OUTER::' thing. can't really make it fit together in my head. at the very least, youd need a special case for the outermost scope. (though what a 'state' declaration outside of a routine means, I don't really know.)

[21:30] <lue> afk # and then helping out on slices :)

[21:30] *** skids left
[21:30] <masak> wow, some days I don't like Twitter. the meme going around today is "Is Java 7 the new Perl 6?" :(

[21:31] <supernovus> masak: Well, on the new match there is no more role, and because of that DateTime::strftime is much simpler. Just 'use DateTime::strftime' adds the strftime() method to the DateTime class.

[21:32] <supernovus> s/match/patch/

[21:32] <jnthn> masak: I manage to use Twitter without noticing these. I wonder what we're doing differently. :-)

[21:32] <masak> supernovus: waitwait, how does it do that? MONKEY_PATCHING?

[21:32] *** meppl left
[21:32] <masak> er, _TYPING

[21:33] <masak> jnthn: it could be my live filters for "Perl 6" and "Rakudo"...

[21:33] <supernovus> masak: Currently, yeah. If you know of a better way, I'll use it :-)

[21:33] *** lichtkind joined
[21:33] <lichtkind> masak: hello

[21:33] <phenny> lichtkind: 18:01Z <ingy> tell lichtkind I'll look into it.

[21:33] <masak> supernovus: I'm not 100% comfortable with using that in src/core/...

[21:33] <masak> lichtkind: greetings, child of the light.

[21:34] <lichtkind> ingy: thanks

[21:34] <pmichaud> > say [+] [1,2,3]

[21:34] <pmichaud> 3

[21:34] <pmichaud> > say [-] [1,2,3]

[21:34] <pmichaud> 3

[21:34] <lichtkind> grtz :)

[21:34] <pmichaud> \o/

[21:34] <masak> supernovus: did you see moritz_++'s idea about using a lexical role?

[21:34] <jnthn> masak: Given I don't know what live filters are, that probably explains it. ;-)

[21:34] <supernovus> masak: Which is why DateTime::strftime isn't in src/core anymore ;-)

[21:34] <jnthn> "use" to import a...method?!

[21:34] <masak> jnthn: exactly.

[21:35] <jnthn> With the exceptation that method will be added to something?

[21:35] <masak> jnthn: they don't exist on the webpage. :)

[21:35] <jnthn> Other than a lexpad?

[21:35] <lichtkind> hai jnthn 

[21:35] <jnthn> lichtkind: oh hai

[21:35] <jnthn> lichtkind: Ako sa mas? :-)

[21:35] <supernovus> How do lexical roles work?

[21:36] <masak> rakudo: { role R { method foo { say "OH HAI" } }; class A does R {}; class B does R {} }; A.new.foo; B.new.foo

[21:36] <p6eval> rakudo 8aff11: OUTPUT«Could not find sub &say␤  in 'foo' at line 11:/tmp/vSEPbe8F7o␤  in main program body at line 11:/tmp/vSEPbe8F7o␤»

[21:36] <masak> rakudo: my &_say = &say; { role R { method foo { _say "OH HAI" } }; class A does R {}; class B does R {} }; A.new.foo; B.new.foo

[21:36] <p6eval> rakudo 8aff11: OUTPUT«Could not find sub &_say␤  in 'foo' at line 11:/tmp/H7_Vo02FCK␤  in main program body at line 11:/tmp/H7_Vo02FCK␤»

[21:36] <masak> huh.

[21:36] <masak> rakudo: { my &_say = &say; role R { method foo { _say "OH HAI" } }; class A does R {}; class B does R {} }; A.new.foo; B.new.foo

[21:36] <p6eval> rakudo 8aff11: OUTPUT«Could not find sub &_say␤  in 'foo' at line 11:/tmp/XwDKDxh9Hr␤  in main program body at line 11:/tmp/XwDKDxh9Hr␤»

[21:36] * masak gives up

[21:36] <pmichaud> the problem has to do with when roles get initialized

[21:37] <pmichaud> the methods defined in a role get captured extremely early

[21:37] <masak> supernovus: anyway, they work like that.

[21:37] <jnthn> pmichaud: I hate that problem.

[21:37] <pmichaud> i.e., before &say is initialized.

[21:37] <masak> oh, right!

[21:37] <masak> rakudo: our &_say = &say; { role R { method foo { _say "OH HAI" } }; class A does R {}; class B does R {} }; A.new.foo; B.new.foo

[21:37] <p6eval> rakudo 8aff11: OUTPUT«OH HAI␤OH HAI␤»

[21:37] *** hghgd joined
[21:37] <masak> there we go.

[21:37] <jnthn> pmichaud: I'm still pondering how on earth to fix it though.

[21:38] <pmichaud> jnthn: actually, I'm just thinking about that now.

[21:38] <jnthn> pmichaud: And my best answer still involves doing away with :load :init... :-/

[21:38] <jnthn> And doing everything with phasers.

[21:38] <supernovus> masak: how would that work with an external module being called from a core setting library?

[21:38] <masak> supernovus: no, it was pertaining to the 'DateLike' role.

[21:39] <pmichaud> jnthn: actually, I'm thinking we just need to set_outer on mainline.

[21:39] <masak> supernovus: to avoid sharing it with the outside world.

[21:39] <masak> supernovus: it's a good idea; it was just a bit too visible.

[21:39] <pmichaud> and to do the set_outer when it's being *compiled*, which we currently likely don't do.

[21:39] <supernovus> masak: Ah, well, moritz_ suggested calling the assert-valid-time method as a class method, so there is no more role.

[21:39] <jnthn> pmichaud: hm

[21:39] <jnthn> pmichaud: ah, maybe that could do it.

[21:39] <pmichaud> since I'm going to be looking at that code later tonight anyway, that might be the right fix.

[21:39] <pmichaud> I'll keep it in mind.

[21:39] <jnthn> OK

[21:41] <supernovus> My new patch renames Temporal.pm to DateTime.pm, and just uses the ::Date.assert-valid-date method instead of requiring that hackish role. I still need to work on the DateTime::strftime library to make it more 'right'.

[21:41] *** ashleydev_ joined
[21:42] *** _mpu left
[21:42] <masak> supernovus: one way to avoid the MONKEY_TYPING would be to make the strftime method into a sub.

[21:43] <sorear> masak: state outside a function is completely equivalent to a my, since the anonymous mainline closure is only cloned once

[21:44] <supernovus> masak: I could do that, change DateTime.strftime() into strftime(DateTime $datetime, Str $format)

[21:44] <masak> sorear: ok, so I have 'state $a' in my sub &foo. how does the lexical stored in OUTER:: look?

[21:45] *** ashleydev left
[21:45] *** ashleydev_ is now known as ashleydev

[21:45] <sorear> masak: my $a_UNIQUEID; my sub foo { ... use $a_UNIQUEID instead of $a ... }

[21:45] <masak> supernovus: yes. one thing: all the formatting subs I can think of have the $format parameter first :)

[21:45] <supernovus> masak: No problem.

[21:46] <masak> sorear: and this takes cloning into account how?

[21:46] <sorear> masak: my sub foo is cloned exactly once for every time the outer scope is entered, which is the same times when new $a_UNIQUEIDs are created

[21:47] <sorear> sub acc { sub { ++(state $i) } }  == sub acc { my $i_0; sub { ++$i_0 } }

[21:47] <masak> sorear: I was thinking about `my &bar = &foo.clone`

[21:54] <supernovus> masak: Okay, strftime() is now an exported sub instead of a method.

[21:54] <masak> supernovus++

[21:54] <masak> re #phasers and GSoC reporting: I was meaning to blog about my slight weekend progress on binary IO and Bufs, but 've been distracted by work and sleep since leaving Lund. things are progressing, and I have a course plotted out for how to read/write binary files.

[21:55] <jnthn> \o/

[21:55] <pugssvn> r31564 | novus++ | Changed test, as strftime is now a sub 

[21:55] <ash_> alpha: my &f = -> $a { state $b = 0; $b += $a }; my &g = &f.clone; f 3; say f 4; f 6; say g 0; # g is a clone of f so they have two different state val's

[21:55] <p6eval> alpha 30e0ed: OUTPUT«7␤0␤»

[21:55] <masak> I got a spec change in this weekend; thought it'd be controversial, but have had zero response to it. maybe it didn't hit the repo? :P

[21:55] <jnthn> Yeah, people don't sleep in Lund. Just hacking. :-)

[21:56] <jnthn> masak: Well, I thought it was sane rather than controversial... :-)

[21:56] <masak> yay

[21:56] <jnthn> Though I do remember being tired when I was looking at it, and somehow I mis-read octets as octopus

[21:57] <masak> jnthn: no, it says "octopus". :P

[21:57] <masak> told you it was controversial :P

[21:57] * masak secretly changed the fundamentals of file I/O

[21:58] *** Ross left
[21:58] <lichtkind> masak: what did you do?

[21:58] <jnthn> Well, I guess if each arm had teeth than an octopus would be 8-bite ;-)

[21:58] <masak> jnthn: that'd be one scary octopus.

[21:58] <masak> jnthn: "Jaws VIII". :P

[22:00] *** ruoso left
[22:00] <masak> lichtkind: I changed the API of 'read' and 'write'. when future generations send their children to school, they'll be thinking about me.

[22:01] <lichtkind> masak: :)

[22:01] <masak> basically, the API wasn't OO enough. it suffered from latent C poisoning.

[22:03] <pmurias> masak: which commit was that?

[22:03] <masak> the latest, it seems.

[22:03] *** masonkramer left
[22:04] *** masonkramer joined
[22:04] <masak> r31543

[22:08] <masak> the spec change was basically a consequence of starting to implement IO.read and IO.write, and then going "eew, no!". :)

[22:11] <supernovus> Well, I'm out for the day. I have attached a new patch replacing the old one. Much simpler, and far less evil hackery going on. :-)

[22:11] <masak> \o/

[22:11] <masak> supernovus++

[22:14] <supernovus> Note that some spec tests for DateTime are currently failing as Kodi is also working on DateTime, and hasn't submitted his patch yet. He was waiting for my patch to be merged so that he can merge his changes in.

[22:14] <pmurias> masak: seems sane

[22:15] <masak> pmurias: thanks.

[22:15] <supernovus> Later all!

[22:16] *** supernovus left
[22:16] *** gbacon left
[22:19] *** lichtkind left
[22:19] <masak> with the new 'proto' spec change, multi dispatch is looking a little bit more like I remember it from Clojure.

[22:20] <masak> Clojure also has a... thing which sits in the middle and determines how to dispatch to multis.

[22:20] <pmichaud> TimToady (or others who might know):   why does  token infix:sym<!=>  have a <?before \s> in it?

[22:20] <pmichaud> is that perhaps left over from the prefix:sym<=> days?

[22:21] <sorear> What was prefix:<=>?

[22:21] <pmichaud> that used to be the "iterate" prefix.

[22:21] <pmichaud> (which thankfully we got rid of about 16 months ago)

[22:22] <pmurias> masak: the new multi dispatch is luckilly what mildew was implementing from the start :)

[22:22] *** dakkar left
[22:22] *** ashleydev left
[22:22] <masak> pmurias: how incredibly fortunate! :P

[22:24] *** szabgab left
[22:28] <pmurias> how is YOU_ARE_HERE implemented in rakudo?

[22:28] <pmichaud> pmurias: wrongly.

[22:29] <pmichaud> (it was added while I was out, so I can't say much more than when I last looked at it, it wasn't really right)

[22:29] <pmichaud> it was a good guess, though :)

[22:30] <pmurias> so is taking a .clone of the current lexical scope, putting it somewhere and then when a file is loaded the outermost scope is that lexical scope

[22:30] <pmurias> a ok way to implement that

[22:30] <TimToady> pmichaud: it looks more like a micro-optimization or fossil to me; != is actually recognized at STD.pm6:3403

[22:31] <pmichaud> TimToady: I just tried it locally, my parser tends to get confused with   !=:=

[22:31] <TimToady> if there's a space, we don't have to look for any metops

[22:31] <pmichaud> (which might not be an issue with true LTM)

[22:31] <TimToady> yes, =:= beats = under LTM

[22:31] <TimToady> but ! doesn't participate

[22:31] <pmichaud> unless != matches first, though

[22:32] <TimToady> which it can only do if there's a space after the =

[22:32] <pmichaud> oh, you're saying that   !=:=   gets seen as ! + =:=  before ever looking at !=

[22:32] <pmurias> TimToady: remember the infinite looping i found when trying to use a custom setting, it turned out it's a bug in YAML::XS

[22:32] <TimToady> !=\s never match under LTM

[22:32] <TimToady> *es

[22:33] <pmichaud> right, understood.  thanks.

[22:33] <TimToady> unless there really is a space

[22:33] <TimToady> but it's redundant with the check in <!>

[22:33] <pmichaud> the problem I'm having is that [!=]  ends up being   reduce[]+meta!+infix:<=>

[22:33] <pmichaud> and so it doesn't correctly find &infix:<!=>()

[22:33] <pmichaud> and so it doesn't correctly find &infix:<!=>($a)

[22:34] *** lichtkind joined
[22:34] <pmichaud> because it tries to generate a !+=

[22:34] <pmichaud> anyway, it's a rakudo issue.

[22:34] *** jferrero joined
[22:35] <pmichaud> put another way,   with !=  defined as it is,  the inside of [!=]   gets treated as    not ($a = $b)

[22:35] <pmichaud> instead of being the !== operator.

[22:35] <lichtkind> pmichaud++

[22:36] <pmichaud> (does what I'm saying make any sense?)

[22:36] <TimToady> yes, the '=' inside '!' has to force itself to mean !== instea of not assign

[22:36] <pmichaud> okay.

[22:36] *** vin joined
[22:36] <TimToady> when that works we can entirely get rid of the <!=> rule, really

[22:36] <pmichaud> okay.

[22:36] <pmichaud> that tells me what I need to know.  :-)

[22:37] *** patspam left
[22:38] <pmichaud> although part of me feels like we should be keeping the != rule instead of trying to figure out how to make  ! + =  mean !== .  But I need to think about that some more.

[22:44] *** pjcj left
[22:45] <vin> Is there a releasedate for perl 6?

[22:45] * masak punts this time

[22:47] <TimToady> vin: define perl 6

[22:48] <vin> that installing perl will get you perl6

[22:48] <masak> whoa.

[22:48] <TimToady> as in replace perl 5?

[22:48] <vin> yeah

[22:49] <tylercurtis> Probably sometime after installing Python will get you Python 3, if ever.

[22:49] <TimToady> oh, 'bout 25 years from now

[22:49] <vin> lol

[22:49] <vin> I have to see it as a different branch then?

[22:49] <TimToady> they're currently viewed as sister languages

[22:50] <masak> the little sister is cuter!

[22:50] *** tylercurtis left
[22:51] <TimToady> the younger sister is interested in outcompeting her older sister someday, but the older sister is rather more, er, developed

[22:52] <TimToady> in any case, it's a friendly competition

[22:52] <vin> If I may ask, is there a list of differences between the two? Currently I am developing in perl5 and I would like to make it work in both, if possible

[22:52] <pmichaud> the list of differences is currently several hundred pages long.

[22:53] <pmichaud> (but it's more than just a list -- it's a list plus explanations)

[22:53] <masak> vin: unless you're a master of tricks, you won't get the same mid-sized-to-long piece of code run in both.

[22:53] <vin> too bad...

[22:53] <TimToady> too good...  :)

[22:53] <masak> vin: Perl 6 is sideways incompatible with Perl 5.

[22:54] <vin> Why? It won't help the integration of perl6

[22:54] <masak> it will help the evolution of Perl 6, though.

[22:54] <TimToady> pretty much everywhere Perl 6 is different from Perl 5, it can be viewed as an improvement

[22:54] <masak> just don't tell the Perl 5 people that... :P

[22:55] <TimToady> you'll eventually be able to intermix p5 and p6 in the same program though

[22:55] <pmichaud> it was decided that we needed some backwards incompatibility in order to get the language right.  That turned out to be quite a bit more backwards incompatibility than we original expected, though.

[22:55] <sorear> vin: perl 6's reason for existing is a compatibility reset

[22:55] <TimToady> masak: btw, the mugs were the day before

[22:55] <sorear> perl 5 is stagnating due to the weight of eternal compatibility + design decisions that made sense in 1988

[22:55] <jnthn> mugs? I thought it was just one mug!

[22:55] *** masonkramer left
[22:55] <masak> jnthn: five.

[22:56] <masak> jnthn: only one broke, though.

[22:56] <masak> TimToady: thanks. still time to prepare for an anniversary blog post, then.

[22:56] *** john__ joined
[22:56] <jnthn> masak: Smashing.

[22:56] <pmichaud> are we going to have a mug collector's edition or something?  ;-)

[22:56] <pmichaud> we could put sayings on them that deserve to be broken.

[22:56] <pmichaud> "Perl is dead."

[22:56] <TimToady> I wish I'd collected the broken mug

[22:56] <masak> "Perl 6: breaking mugs and backwards compat since 2000"

[22:57] <pmichaud> lol

[22:57] <pmichaud> yes!

[22:57] * pmichaud fires up photoshop, looks to cafepress

[22:57] <masak> pmichaud: "Quick, hide me! A Perl 6 designer!"

[23:00] <masak> pmichaud: "Perl 6: the greatest language ever to emerge out of the shards of a mug."

[23:00] *** pmurias left
[23:01] <Tene> Should we include a free mug with every copy of parrot, to help budding language developers get started off right?

[23:02] <jnthn> "If you break this mug, people will spend over 10 years designing a new language. Please take care of it."

[23:02] <sbp> the mug, or the new language?

[23:02] <masak> pmichaud: "Just another smug Perl 6 developer." the 's' in 'smug' crossed out.

[23:02] <jnthn> sbp: Either. ;-)

[23:02] <sbp> the mug could be viewed like the fire alarm points. "break mug to activate"

[23:03] <pmichaud> "Break mug in case of language stagnation."

[23:03] <masak> "Perl 6: break mug in case of community fra..." dang, pmichaud faster.

[23:03] <jnthn> "Perl 6. It's Perl 5 with a cupple of improvements."

[23:03] <masak> jnthn: :P

[23:04] <masak> "Does your language come with a cup holder? Perl 6 does."

[23:04] <jnthn> "Don't be a mug! use v6;"

[23:05] <masak> "class Mug { method throw { break; } }"

[23:05] <TimToady> "The best time to have a lucky break is ten years ago."

[23:05] <masak> dang, we got rid of break a couple of iterations ago :P

[23:06] <masak> "class Mug { method throw { succeed; } }"

[23:06] <pmichaud> "Perl 6 mugs -- another lucky break!"

[23:08] <jnthn> "Perl 6. Mugging other languages for features, and cuppling them neatly."

[23:09] <masak> "if $mug === all @shards { say 'We need a break from all the mug puns!' }"

[23:09] <jnthn> I promise not to break the silence with another one.

[23:10] <masak> that's be "I don't promise not to..." :P

[23:10] <masak> s/s/d/

[23:10] *** jferrero left
[23:10] <jnthn> Oh, you can handle it. :P

[23:11] * masak shatters from laughter

[23:11] <TimToady> "Why's Jon throwing donuts?"  --topologist

[23:12] <masak> :P

[23:12] <TimToady> "This is a broken mug.  <mug> This is your brane on broken mugs. <camelia> Any questions?"

[23:15] <masak> after hanging around enough on this channel, I might forget the generally accepted spelling of 'brain'...

[23:16] *** lafille joined
[23:16] *** lafille left
[23:16] <masak> "Perl 6: seeking the holy grail after accidentally smashing it ten years ago."

[23:17] <jnthn> "How is mug re-formed?"

[23:17] <masak> They need to do way instain Jon Orwant.

[23:18] <jnthn> Who harms 5 mugs that cannot frigt back!

[23:19] <pugssvn> r31565 | pmichaud++ | [t/spec]:  Fudge a test for [!==]. 

[23:19] <masak> My pary are with the cleaner.

[23:19] <jnthn> .oO( Perl 6: A language with RRRRRRRRRRRRRRRRRRRRRRRRRRRRR* )

[23:20] <pmichaud> <camelia>  "I was ready for my mug shot 10 years ago."

[23:20] <jnthn> rakudo: 2 RRRRRRRRRRRRRRRRRRRRRRRRRRRRR* 3

[23:20] <p6eval> rakudo bbacb7:  ( no output )

[23:20] <jnthn> rakudo: say 2 RRRRRRRRRRRRRRRRRRRRRRRRRRRRR* 3

[23:20] <p6eval> rakudo bbacb7: OUTPUT«6␤»

[23:20] <masak> jnthn: your mugs are way too wide.

[23:24] <masak> "Perl 6: poculum iacta est."

[23:24] <TimToady> .öÖ(mugsy would be a good name for a Perl 6 implementation)

[23:24] *** sftp left
[23:25] *** sftp joined
[23:25] *** alester left
[23:25] <masak> TimToady: what, there's too few of them? :P

[23:25] *** vin left
[23:26] <masak> vin: ...come back anytime! :)

[23:27] *** alester joined
[23:27] *** alester left
[23:27] *** szabgab joined
[23:30] * sorear decides: sub foo($x) { class { method foo { $x }; }; }; foo(1).HOW === foo(2).HOW

[23:31] *** rgrau_ left
[23:32] *** clintongormley left
[23:35] <TimToady> rakudo: sub foo($x) { class { method foo { $x }; }; }; say foo(1).HOW === foo(2).HOW

[23:35] <p6eval> rakudo bbacb7: OUTPUT«1␤»

[23:35] <lue> ohai

[23:35] <diakopter> iaho

[23:35] <TimToady> rakudo: sub foo($x) { class { method foo { $x }; }; }; say foo(1).WHAT === foo(2).WHAT

[23:35] <p6eval> rakudo bbacb7: OUTPUT«0␤»

[23:35] <TimToady> rakudo++

[23:36] <pmichaud> rakudo:  say [+] [1,2,3];

[23:36] <p6eval> rakudo bbacb7: OUTPUT«6␤»

[23:36] <pmichaud> apprently not updated yet.

[23:36] <pmichaud> ahhh, I forgot to push.

[23:36] <TimToady> I hate it when that happensn't.

[23:36] *** cinch left
[23:37] *** s1n joined
[23:37] *** cdarroch left
[23:38] <lue> TimToady: when it comes to 日本語, do I have to pay much attention to text direction? Some of the phrases I've seen have me worried.

[23:39] * masak .oO( where is all this heading? )

[23:40] <dalek> rakudo: 55acd1d | pmichaud++ | src/ (2 files):

[23:40] <dalek> rakudo: Fix [op] reduction for single argument lists.  While we're at it, perform the 

[23:40] <dalek> rakudo: correct casting as well (e.g., [+] should result in a numeric).

[23:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/55acd1d428f95b6ca938d15d9aec1ce694f3edc3

[23:40] <TimToady> headings are exactly the problem

[23:40] <TimToady> or rather, the signs on stores

[23:40] <lue> (just a question. Maybe a DCC would've been more appropriate)

[23:40] <masak> what about the signs on fetches?

[23:40] <TimToady> many of those are written in "vertical" form with one character per column, which ends up reading right to left

[23:41] <TimToady> the sign on a fetch will be on its bow, so you can tell which way it's going

[23:42] <lue> OK. The 'of' phrases (like 時のオカリナ) make me wonder if it was originally RTL (considering you can read it Time's Ocarina LTR and Ocarina of Time RTL)

[23:42] * diakopter o/ --- ... ---

[23:43] <lue> [I obviously haven't studied much japanese :)]

[23:43] <masak> diakopter: here, grab this mug! oh wait.

[23:43] <diakopter> yeah I got it backwards

[23:44] *** jennyf joined
[23:44] <masak> heh, spelling SOS backwards. hate when that happens.

[23:44] <lue> .oO(it's a palindrome, just like Bolton)  :)

[23:44] <pugssvn> r31566 | Kodi++ | [t/spec/S32-temporal/DateTime] Braino. 

[23:45] *** skangas left
[23:47] *** jennyf left
[23:47] <lue> rakudo: my @a = 1,2,3; @a[3..5] = @a[0..2]; say @a.perl

[23:47] <p6eval> rakudo bbacb7: OUTPUT«[1, 2, 3, 1, 2, 3]␤»

[23:47] <masak> rakudo: my @a = 42; @a[1..3] = @a[0..2]; say @a.perl

[23:47] <p6eval> rakudo bbacb7: OUTPUT«[42, 42, Any, Any]␤»

[23:48] <masak> \o/

[23:48] <lue> rakudo: my $a = 1; my $b := $a;

[23:48] <p6eval> rakudo bbacb7: OUTPUT«:= binding of variables not yet implemented␤  in 'infix:<:=>' at line 671:CORE.setting␤  in main program body at line 11:/tmp/kY_JzbDqGz␤»

[23:50] <lue> (If only I had a commit byte...)

[23:50] <masak> what do you need eight commit bits for? :P

[23:50] <lue> sorry, a commit nybble.

[23:51] <masak> pmichaud++ seems to get by being very productive lately with just one commit bit.

[23:51] <lue> (And if I can't have that, then fine, I'll take a commit byt.)

[23:52] <sorear> lue: japanese is very flexible about character orientation, you can basically write it however you want as long as the characters are right side up

[23:52] <lue> (How about a commit qword?)

[23:52] <masak> lue: in my experience, commit bits are happily handed out to people who have accumulated a list of helpful patches.

[23:53] <masak> lue: so keep up the good work. :)

[23:53] <pmichaud> (and in Rakudo's case, to people who have submitted a CLA)

[23:53] <pmichaud> I had a question come in via email just now; need advice.

[23:53] <lue> well, I've given... 4, about, in the last t2o days.

[23:53] <pmichaud> (more)

[23:53] <pmichaud> I did a presentation at yapc::na, which I'm reprising at yapc::eu, that explains Rakudo Star to the Perl community.

[23:54] <sorear> pmichaud: how did the na version go?

[23:54] <pmichaud> excellent.

[23:54] <pmichaud> at least, I thought it went great.

[23:54] <pmichaud> however, that presentation is really focused to a Perl audience

[23:54] <pmichaud> it focuses on ways in which Rakudo Star is meant to change the concept of "a Perl release".

[23:54] <lue> (CLA = Commit Lending Application?)

[23:54] <pmichaud> the question that came into email now was from someone who wants to give a presentation about "why the Rakudo Star release is important"

[23:55] *** Psyche^ joined
[23:55] <pmichaud> i.e., why would a non-Perl person care about Rakudo Star?

[23:55] <pmichaud> and.... I could use some ideas for answers.  :-)

[23:55] <pmichaud> and I think we want to have something coherent to say before the 29th.  :-)

[23:56] <pmichaud> (and my brane is a bit of tapioca after this past week's commit-fest, so I'm not firing on all cylinders in this respect)

[23:56] <masak> Rakudo Perl will be a good time to jump on the Perl 6 train, for Perl people as well as non-Perl people.

[23:56] <masak> Perl 6 in general makes sense even if you're not a Perl programmer already.

[23:56] <pmichaud> to which the response would likely be  "and what's so great about Perl 6?"

[23:57] <TimToady> well, that's obvious.  :)

[23:57] <Tene> While we've had regular releases and made the code available, it's largely been difficult to get started with and determine the status of anything.  Perl 6 has been a very confusing subject for an outsider, and we haven't had any real message for outsiders before now.

[23:57] <pmichaud> I know we've enumerated it a bit before... I'd like to put it into a short synopsis

[23:57] <pmichaud> (synopsis in the "short text" sense, not the "Perl 6 spec" sense)

[23:58] <diakopter> the synopses need synopses

[23:58] <masak> Perl 6 is a brain-shaped programming language.

[23:58] <Tene> Rakudo Star is that message.  "Here's what we've been hoping to say and communicate to the world.  Here's an accessible, coherent presentation of what we're working on.  Come see."

[23:58] <pmichaud> Tene: I like that approach

[23:58] <lue> Well, AFAIK, it's one of the easiest languages to define new operators and grammar.

[23:58] <lue> It just like any spoken language, in that sense.

[23:58] <masak> Tene: +1

[23:58] <masak> "Rakudo Star. Come and see."

[23:59] *** Patterner left
[23:59] *** Psyche^ is now known as Patterner

