[00:00] *** justatheory left
[00:00] *** Juerd left
[00:03] *** sbp joined
[00:03] *** cono left
[00:04] *** ash___ joined
[00:05] <dalek> niecza: 2aafefe | sorear++ | Niecza/Grammar.pm6:

[00:05] <dalek> niecza: Add a NIL parser.

[00:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2aafefef8af33ee6b767dd7bf0e52863e554852d

[00:07] *** ash_ left
[00:07] *** ash___ is now known as ash_

[00:11] *** justatheory joined
[00:11] *** Juerd joined
[00:11] *** PerlJam joined
[00:11] *** sykes_ joined
[00:11] *** Solarion joined
[00:11] *** sunnavy joined
[00:11] *** jnthn joined
[00:11] *** buu joined
[00:11] *** yves__ joined
[00:11] *** farmer.freenode.net sets mode: +o jnthn

[00:15] *** Ambiguity left
[00:28] *** ash_ left
[00:29] <dalek> niecza: 756f31f | sorear++ |  (7 files):

[00:29] <dalek> niecza: Split Compiler up by classes

[00:29] <dalek> niecza: review: http://github.com/sorear/niecza/commit/756f31f45a752ceb5112f00a33559447431d127d

[00:32] *** PerlPilot joined
[00:33] *** Guest87395 left
[00:37] *** PerlJam left
[00:39] *** songmaster joined
[00:44] *** isBEKaml left
[00:44] *** azert0x left
[00:46] *** azert0x joined
[00:46] *** ash_ joined
[00:48] *** stepnem joined
[00:57] *** masonkramer left
[00:57] *** masonkramer joined
[00:58] *** Sarten-X left
[01:01] *** amkrankruleuen left
[01:07] *** meppl left
[01:09] *** azert0x left
[01:11] *** justatheory left
[01:11] *** Juerd left
[01:11] *** sykes_ left
[01:11] *** Solarion left
[01:11] *** sunnavy left
[01:11] *** jnthn left
[01:11] *** buu left
[01:11] *** yves__ left
[01:15] *** azert0x joined
[01:15] *** azert0x left
[01:15] *** azert0x joined
[01:19] *** synth left
[01:21] *** whiteknight left
[01:22] *** justatheory joined
[01:22] *** Juerd joined
[01:22] *** sykes_ joined
[01:22] *** Solarion joined
[01:22] *** sunnavy joined
[01:22] *** jnthn joined
[01:22] *** buu joined
[01:22] *** yves__ joined
[01:22] *** farmer.freenode.net sets mode: +o jnthn

[01:25] *** azert0x left
[01:30] *** azert0x joined
[01:33] *** synth joined
[01:38] *** sunnavy left
[01:39] *** sunnavy joined
[01:46] *** bjarneh joined
[01:56] *** ashleydev left
[01:57] *** ashleydev joined
[01:57] *** ashleydev left
[02:03] *** synth left
[02:04] *** synth joined
[02:10] *** justatheory left
[02:16] *** synth left
[02:17] *** azert0x left
[02:17] *** agentzh joined
[02:17] *** synth joined
[02:28] *** bjarneh left
[02:33] *** redicaps joined
[02:34] <lue> anyone around to help with a PIR compilation bug? (will post to gist)

[02:36] <redicaps> Hello perl6, what dose $*variable means? Where can I find the documentation for this "*"?

[02:37] *** azert0x joined
[02:37] *** azert0x left
[02:39] <redicaps> Hmmm, I found it,      $*foo       dynamically overridable global variable~~

[02:41] <tylercurtis> redicaps: it's used for the equivalents of many of the special globals in Perl 5.

[02:41] <phenny> tylercurtis: 01 Jul 23:54Z <sorear> tell tylercurtis to address phenny

[02:41] *** Ambiguity joined
[02:42] <redicaps> tylercurtis: Thanks 

[02:44] <sorear> phenny: ask TimToady what $*INVOCANT_IS is for - I thought method calls were exactly the same as sub calls

[02:44] <phenny> sorear: I'll pass that on when TimToady is around.

[02:44] <tylercurtis> There's also $.foo for public accessors of attributes of an object, $!foo for private attributes. $<foo> for the named capture in the match result that's bound to $/($<foo> is equivalent to $/{'foo'}). There's a few others, too.

[02:45] <tylercurtis> http://perlcabal.org/syn/S02.html#Names_and_Variables and scroll down a little bit and you'll find a list.

[02:48] <lue> http://gist.github.com/460851 ‚Äî maybe someone has PIR magic...

[02:50] *** patspam left
[02:51] *** TiMBuS joined
[03:01] <TimToady> sorear: INVOCANT_IS sets $<args><invocant>, which suppresses adding such a call to the mysteries

[03:01] <phenny> TimToady: 01 Jul 13:32Z <sorear> ask TimToady In the interests of pmurias & azawawi wanting to build installs, how would you feel about me moving src/perl6 into the Perl6::STD:: p5 namespace?

[03:01] <phenny> TimToady: 02:44Z <sorear> ask TimToady what $*INVOCANT_IS is for - I thought method calls were exactly the same as sub calls

[03:02] <TimToady> re Perl6::, I'd have to think about it and read the backlog

[03:02] <TimToady> std: foo(1,2,3)

[03:02] *** synth left
[03:02] <p6eval> std 31528: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§      'foo' used at line 1‚ê§Check failed‚ê§FAILED 00:01 113m‚ê§¬ª

[03:02] <TimToady> std: foo(1: 2,3)

[03:02] <p6eval> std 31528: OUTPUT¬´ok 00:01 110m‚ê§¬ª

[03:02] <TimToady> see, no error

[03:03] <TimToady> unfortunately, still don't have time to backlog

[03:05] *** jaldhar joined
[03:05] *** synth joined
[03:09] <sorear> TimToady: What does that syntax mean?

[03:11] <tylercurtis> "If the first positional is followed by a colon instead of a comma, it is marked as the invocant in case it finds itself in a context that cares."

[03:12] <sorear> What does that mean?

[03:12] *** eternaleye left
[03:14] *** azert0x joined
[03:14] <lue> it means you could do, call it either xyzzy($a, $b, $c) or $a.xyzzy($b, $c) [IIRC]

[03:15] *** justatheory joined
[03:16] *** synth left
[03:19] *** bjarneh joined
[03:19] <tylercurtis> sorear: here's a better citation for that http://perlcabal.org/syn/S06.html#Invocant_parameters

[03:21] <tylercurtis> foo(1: 2, 3) is another way of saying 1.foo(2, 3). S06 actually implies that 1.foo(2,3) is actually converted to foo(1: 2, 3) internally.

[03:21] <tylercurtis> If I'm reading it correctly.

[03:22] <ingy> sorear: fyi, the difference between rule, token and regex is in S06, not S05: http://perlcabal.org/syn/S06.html#Subroutines_and_other_code_objects

[03:22] <ingy> I just found it :)

[03:23] *** azert0x left
[03:27] <sorear> ingy: S05:2045 also defines it

[03:33] *** Guest23195 joined
[03:37] *** eternaleye joined
[03:42] <pugssvn> r31529 | sorear++ | [Cursor] Be a little less eager to drop exceptions on the floor 

[03:46] *** synth joined
[03:51] *** stakishi joined
[04:03] <spinclad> masak, arnsholt: re http://gist.github.com/458738, consider .../dud/e and .../dude/f: .../dude will get mkdir'd but not .../dud .  want a &path-prefix not &string-prefix /me thinks.

[04:03] <spinclad> (note: still backlogged, dunno if this was noted already)

[04:05] *** stakishi left
[04:05] <spinclad> (alternatively, just uniquify and mkdir them all.)

[04:13] <dalek> niecza: ea7b75e | sorear++ |  (3 files):

[04:13] <dalek> niecza: Start building the Actions connector

[04:13] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ea7b75edcea3b1db099d72f46e4df94acd95951f

[04:19] <dalek> niecza: 2b08263 | sorear++ |  (2 files):

[04:19] <dalek> niecza: Bring actions up to comp_unit.

[04:19] <dalek> niecza: say("Hello, World") can now be turned into Niecza AST.

[04:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2b082638a1c60b98ece2215b1e2774db7c7f5968

[04:20] *** synth left
[04:29] *** synth joined
[04:33] *** bjarneh left
[04:51] *** perl_babe joined
[04:52] *** perl_babe left
[04:55] <dalek> niecza: 5c415c9 | sorear++ |  (2 files):

[04:55] <dalek> niecza: Translate setting WIP to parsed-Perl6 - parser not yet ready!

[04:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/5c415c9e59e877811f5538db91b5f47fbd37247a

[04:56] <sorear> NIL is officially the ugliest language I've ever designed

[04:57] *** mberends left
[05:02] *** quester_ joined
[05:09] <quester_> .

[05:10] *** ash_ left
[05:10] *** Mowah joined
[05:17] *** lkk- joined
[05:22] <sorear> pmichaud: Do we have any clue yet about how compiler-used helper lexicals should work?  (I know you were complaining about &reducewith not long ago)

[05:26] *** c1sung joined
[05:26] *** synth left
[05:33] *** synth joined
[05:40] *** yinyin joined
[05:47] *** xinming_ is now known as xinming

[05:51] *** songmaster left
[05:54] *** ashleydev joined
[06:00] *** Su-Shee joined
[06:04] *** tylercurtis left
[06:04] *** tylercurtis joined
[06:05] *** uniejo joined
[06:05] *** dual joined
[06:16] *** justatheory left
[06:25] *** synth left
[06:26] *** synth joined
[06:29] *** dimid left
[06:30] *** dimid joined
[06:37] *** justatheory joined
[06:39] *** yinyin left
[06:42] *** justatheory left
[06:45] *** yinyin joined
[06:49] *** agentzh left
[06:52] *** tylercurtis left
[06:53] *** tylercurtis joined
[07:05] <sorear> huh

[07:05] <sorear>         <.obs('Object', 'Mu as the "most universal" object type')>

[07:05] <sorear> What version of Perl had Object?

[07:07] <moritz_> previous Perl 6 iterations

[07:08] <moritz_> like, until a year ago

[07:08] * sorear keeps forgetting he's 10 years late to the part

[07:08] <sorear> y

[07:13] *** redicaps left
[07:13] *** mberends joined
[07:19] <dalek> niecza: 6b89c19 | sorear++ | Niecza/ (2 files):

[07:19] <dalek> niecza: Fix parsing of line-oriented NIL declarations

[07:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/6b89c19aed63d78c0d37061593bbf963701d3363

[07:19] <dalek> niecza: 02b0c15 | sorear++ | Niecza/Actions.pm:

[07:19] <dalek> niecza: Suppress multiple warnings for missing action methods

[07:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/02b0c15034189c4e0f959caa0e748124e5cdb515

[07:19] <dalek> niecza: 1863ead | sorear++ | Niecza/Grammar.pm6:

[07:19] <dalek> niecza: Allow parsing double-quoted strings in NIL

[07:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/1863ead861550df57c878deea176f731cdc10b53

[07:19] <dalek> niecza: 0dc20f4 | sorear++ | Niecza/ (2 files):

[07:19] <dalek> niecza: Assorted action methods; merge num and decint

[07:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0dc20f435c506622744312db4d770972d69dab2b

[07:19] <dalek> niecza: 53e6a3d | sorear++ |  (2 files):

[07:19] <dalek> niecza: Implement yada operator parsing; use sorries for NYI

[07:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/53e6a3d3b6b98cf3c6509455eb1d0d988cb91c99

[07:20] <sorear> maybe if I'm going to use dalek I should make bigger commits, huh?

[07:21] <moritz_> no

[07:23] *** rgrau joined
[07:25] <mathw> One of the joys of git is little, self-contained, sensible commits

[07:29] *** masak joined
[07:29] <masak> oh hai from a bus!

[07:30] <sorear> Hello masak on a bus, hello masak on a plane

[07:30] <masak> tylercurtis: no, I wasn't aware of Lisps handling &eval even when doing native-code compilation. I'd sure like to have it explained to me somtime how that works.

[07:32] *** masak`` joined
[07:32] *** ashleydev left
[07:32] <sorear> all (ok, 99%) &eval means is that you have to bundle a compiler

[07:33] <tylercurtis> indeed.

[07:33] <masak``> so it's native code, but the executable is not really slimmed?

[07:33] <sorear> demand paging ftw

[07:33] <masak``> oh well, as long as it's fast...

[07:34] <sorear> the compiler tends to be in its own shared library anyway

[07:34] <sorear> so it doesn't bloat the executable

[07:34] <tylercurtis> what sorear said.

[07:34] <tylercurtis> I was writing that in a more lengthy way and then he says it much more concisely and clearly.

[07:34] <sorear> and modern operating systems will load shared libraries lazily, one page fault at a time

[07:34] <masak``> tylercurtis: I know, that sorear guy is amazing!

[07:35] <sorear> oh please. :)

[07:35] <mberends> masak``: I wish you a good masakthon!

[07:35] *** masak left
[07:36] *** masak``` joined
[07:36] <masak```> mberends: you mean here on the bus, or when I arrive at jnthn's place? :)

[07:37] <mberends> masak```: both :)

[07:37] <masak```> hm, if I get more backticks than this, I might decide to go dark.

[07:37] <tylercurtis> masak```: masak with no ticks seems to now be available.

[07:38] <masak```> who here could help me set up a Yapsi p6eval target, by the way?

[07:38] *** masak``` is now known as masak

[07:38] * masak .oO( nick with no tick )

[07:39] <masak> I'm guessing either "moritz_" or "diakopter", or both.

[07:40] *** masak`` left
[07:40] <masak> now that we have loops, it suddenly feels worth it to add Yapsi to p6eval.

[07:40] <masak> and then I could do this, and show y'all what needs to be fixed ASAP. :)

[07:41] <masak> yapsi: my $a = 3; while --$a { say my $b; $b = 5 } # prints Any\n5\n, which is wrong

[07:43] <masak> oh, and I can't actually write the comment there, because we don't parse comments :P

[07:46] *** masak` joined
[07:49] *** quester_ left
[07:49] *** agentzh joined
[07:49] *** masak left
[07:53] *** masak` is now known as masak

[08:13] <moritz_> masak: I can help, but probably not this weekend

[08:13] <masak> that's ok. there's no rush.

[08:17] <moritz_> masak: it helps if you write a shell script that git pull's yapsi, and rebuilds it

[08:17] <moritz_> assuming a ~/yapsi/ dir or so

[08:18] <masak> moritz_: it'll need to have access to an 'alpha' executable for the time being. should it use the one that p6eval uses for the 'alpha:' target, or should it get its own?

[08:20] <moritz_> the existing one is fine

[08:20] <masak> ok. I'm just going to assume a path for it; can change it later.

[08:20] <moritz_> ~/rakudo-alpha/perl6

[08:20] <masak> thanks.

[08:21] <moritz_> on second thought, it's probabl ~/rakudo-alpha/parrot_install/bin/perl6

[08:21] <moritz_> but I can symlink if needed

[08:21] <moritz_> get an executable named 'alpha'

[08:22] <masak> it would help slightly, but it's not strictly necessary.

[08:22] <moritz_> ~/rakudo-alpha/parrot_install/bin/alpha 

[08:22] <moritz_> done

[08:22] <masak> thanks :)

[08:24] *** Ross joined
[08:34] *** tadzik joined
[08:36] *** thebird joined
[08:37] <jnthn> masak: oh hai

[08:37] *** masak` joined
[08:37] <jnthn> .oO( the continual wifi fel must really tick masak off )

[08:37] <tylercurtis> masak`: I know I'd be bananas if I relied on SIC being the same between releases, but how must does it change between releases?

[08:37] <masak`> jnthn: :)

[08:37] *** Ross left
[08:38] <masak`> jnthn: not sure a 'fel' can be continual as can a 'fail'... :)

[08:38] <masak`> tylercurtis: unpredictably and depending on current needs.

[08:38] <jnthn> masak`: details details :P

[08:40] *** pmurias joined
[08:40] *** masak left
[08:42] <arnsholt> masak`: Is there something in particular keeping Yapsi from using master?

[08:42] *** dakkar joined
[08:43] <pmurias> sorear: ping

[08:43] *** masak` left
[08:43] <dalek> niecza: 2c4d2c9 | sorear++ |  (3 files):

[08:43] <dalek> niecza: Add many insn: actions; implement labels & fix methods.

[08:43] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2c4d2c930187325338e2d1cb96c751da90110ad8

[08:43] <dalek> niecza: 0df3528 | sorear++ | Niecza/ (2 files):

[08:43] <dalek> niecza: Implement CLONE:, COPY:, and LEXICALS:

[08:43] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0df3528910810ff5aa876421acd27ed2186acf8f

[08:46] <pmurias> sorear: if i'm loading a custom core how do i generate the .lex file?

[08:49] <sorear> (Minor nit: you don't.  .lex files are hand-written; the files you generate are .syml

[08:49] <sorear> )

[08:50] <sorear> I think you need to call STD->parsefile('filename', setting => 'NULL') after making sure the file contains a YOU_ARE_HERE statement

[08:50] <sorear> the parse will spit out a .syml file as a side effect

[08:50] <sorear> this is how CORE.syml is generated

[08:54] <pmurias> so how does ./std CORE.setting know that it should load NULL.lex?

[08:56] <sorear> because std contains a special case for the filename "CORE.setting"

[08:56] *** proller joined
[08:56] <sorear> if you are using a custom setting, you need to make the parsefile call yourself

[08:58] * pmurias writes a script to do that

[08:58] <pmurias> sorear: have you seen hoopl (http://lambda-the-ultimate.org/node/3906)

[09:00] <sorear> I think so

[09:00] *** lkk- left
[09:01] *** tylercurtis left
[09:03] <pmurias> sorear: as both niecza and mildew are written in perl5 it might make sense to port that over to enable writting cool data flow optimalisations

[09:08] *** tadzik left
[09:08] <pmurias> sorear: how can i make STD find my MildewCORE.pm6.syml?

[09:09] <sorear> it needs to be in syml/ under your STD5PREFIX path

[09:09] <sorear> then pass setting => 'MildewCORE' to parse(file)

[09:09] <sorear> iiuc

[09:13] <pmurias> my STD5PREFIX is the src/perl6

[09:13] <pmurias> fixing $other stuff &

[09:20] *** eternaleye left
[09:23] <sorear> How closure-like is the block of a class statement?

[09:25] <jnthn> Very in the case of e.g. an anonymous class

[09:25] <dalek> niecza: 63766d1 | sorear++ | Niecza/Actions.pm:

[09:25] <dalek> niecza: Simplify and rationalize handling of quote-like operators

[09:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/63766d19aff006961daa83eb175f8a765b4d409e

[09:26] <dalek> niecza: 43d684c | sorear++ |  (2 files):

[09:26] <dalek> niecza: Implement a fake type inferencer for methods/fields/indexers

[09:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/43d684cd0f890d43a621bb34be60e8c5681e1a47

[09:26] <dalek> niecza: 8048577 | sorear++ |  (3 files):

[09:26] <dalek> niecza: Implement the rest of the NIL ops

[09:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/8048577bd94a9c9e3e885c20f449f4ff41029a01

[09:26] *** azert0x joined
[09:26] <jnthn> rakudo: my @c; for 1..5 -> $x { @c.push(class { method m { $x } }); }; @x>>.m>>.say 

[09:26] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Symbol '@x' not predeclared in <anonymous> (/tmp/pFxJIJSkun:11)‚ê§¬ª

[09:26] <jnthn> rakudo: my @c; for 1..5 -> $x { @c.push(class { method m { $x } }); }; @c>>.m>>.say 

[09:26] <p6eval> rakudo 3d2cb8: OUTPUT¬´5‚ê§5‚ê§5‚ê§5‚ê§5‚ê§¬ª

[09:26] <jnthn> oh schiese, the closure bug

[09:27] <jnthn> Anyway, if Rakudo didn't have busted closures that should work.

[09:27] <jnthn> (as in, print 1,2,3,4,5)

[09:31] * sorear out

[09:31] *** yinyin left
[09:31] <sorear> this is wonderful, I'm actually feeling productive :>

[09:31] <sorear> but I must sleep now

[09:31] <dalek> niecza: 83fe3c0 | sorear++ |  (2 files):

[09:31] <dalek> niecza: Drop unused and unimplemented signatures

[09:31] <dalek> niecza: review: http://github.com/sorear/niecza/commit/83fe3c03f2ebeb5e3bd56493e1f159de2b3d054d

[09:58] *** cygx joined
[10:04] *** masonkramer_ joined
[10:06] *** masonkramer left
[10:06] *** masonkramer_ is now known as masonkramer

[10:06] <cygx> 	phenny: tell 

[10:06] <cygx> copy + paste fail ;)

[10:08] <cygx> phenny: tell ash_ try.rakudo.org is somewhat functional: hit try.rakudo.org:8090 to create a new session; you can input text and see it displayed twice (most likely only after a manual refresh); copy your sid and insert it at test.html to simulate polling for updates

[10:08] <phenny> cygx: I'll pass that on when ash_ is around.

[10:09] <cygx> phenny: tell ash_ don't create too many sessions, though: the backend currently needs a manual restart to get rid of them

[10:09] <phenny> cygx: I'll pass that on when ash_ is around.

[10:25] *** agentzh left
[10:36] <bbkr> rakudo: say Inf.ceiling ~~ Inf.floor

[10:36] <p6eval> rakudo 3d2cb8: OUTPUT¬´1‚ê§¬ª

[10:36] *** cosimo joined
[10:39] *** ruoso joined
[10:49] *** Chillance joined
[10:51] <pmurias> ruoso: hi

[10:51] <pmurias> ruoso: what would be a good way specifing which SETTING should be used for a given file?

[10:54] *** pnate joined
[11:25] *** mryan joined
[11:26] *** DemoFreak joined
[11:28] *** clintongormley joined
[11:29] <DemoFreak> renormalist: ping :P

[11:30] <mryan> pong :-)

[11:31] <DemoFreak> ;)

[11:36] *** mryan left
[11:41] *** cono joined
[11:44] *** sftp joined
[11:44] *** tadzik joined
[12:23] *** envi^home joined
[12:33] *** timbunce joined
[12:34] <mathw> Afternoon

[12:34] <jnthn> o/ mathw 

[12:36] *** masonkramer left
[12:37] *** masonkramer joined
[12:38] *** pmurias left
[12:39] *** pmurias joined
[12:41] *** mberends left
[12:42] *** envi^home left
[12:42] *** envi^home joined
[12:48] *** literal joined
[12:48] *** zed_ joined
[12:49] *** zed_ left
[12:50] <pmurias> TimToady: ping

[12:51] <mathw> jnthn: hey. What's happening?

[12:53] <pmurias> is the OUTER in the outermost block the outermost block?

[12:57] <TimToady> the outermost block is CORE

[12:58] <TimToady> UNIT::OUTER is SETTING

[12:59] <pmichaud> good morning, #perl6

[13:00] <mathw> o/ pmichaud

[13:01] <colomon> \o

[13:06] <jnthn> mathw: Hot weather.

[13:06] <jnthn> mathw: And getting my appartment tidied a bit in prep for $weekend-hackathon

[13:06] <mathw> cooler here today

[13:06] <mathw> \o/ hackathon

[13:06] <mathw> is it a rakudo hackathon?

[13:06] <pmichaud> jnthn: ooooh, can I come to the hackathon?

[13:07] <jnthn> pmichaud: Of course! ;-)

[13:07] *** sundar joined
[13:08] <jnthn> mathw: I suspect I'll be doing some Rakudo hacking. I also hope to look at pls a bit too, since it's creator will also be at the hackathon. :-)

[13:08] * mathw decides that SSL is too much effort, and everyone should just not have any secrets

[13:08] <pmichaud> ....wow

[13:08] <pmichaud> round trip to CPH, leaving today, is only US$1300

[13:08] <mathw> bargain

[13:09] <jnthn> CPH is only a 45 minute train ride then 5 minute walk to here. ;-)

[13:09] <pmichaud> right

[13:09] <pmichaud> is there a closer airport?  ;-)

[13:09] <mathw> does the flight come with free deep-vein thrombosis?

[13:09] <pmichaud> but I could potentially be in CPH tomorrow at 13h20 :-)

[13:09] <jnthn> Geographically, I believe there is.

[13:10] <jnthn> In terms of time to get from it to my place, probably it'd take longer though.

[13:10] <pmichaud> right

[13:10] <jnthn> Not to mention that last time I checked out where you could get to from Malmo airport, there was 5 flights a week to Iraq and none to the UK...

[13:10] <pmichaud> anyway, interesting to know that it would indeed be possible for me to get there on short notice.  :)

[13:10] <jnthn> Yes :-)

[13:11] <mathw> The modern world

[13:11] <mathw> I still find it odd that I could get up right now, walk down to the railway station and get on a train for London, walk across the station and get a train to Paris.

[13:11] <mathw> Well, I could if my passport hadn't expired

[13:11] <jnthn> mathw: I did Eurostar a week ago today :-)

[13:11] <mathw> I did it once

[13:11] <jnthn> mathw: Though to Brussels rather than Paris.

[13:12] <mathw> in... err... 1999

[13:12] <mathw> and that was to Brussels

[13:12] <jnthn> It's like Paris, but no big tower, noisier and they're not on strike.

[13:12] <jnthn> ;-)

[13:12] <mathw> lol

[13:12] <mathw> I've never been to Paris

[13:12] <mathw> or anywhere else in France, other than passing through on the way to Brussels

[13:12] <mathw> But I liked Brussels

[13:13] * pmichaud did a tour of France in 1998.

[13:13] <jnthn> The things I've enjoyed most in France are (a) meeting the Perl mongers there and (b) that modern art gallery

[13:13] <mathw> Although not as much as I liked Munich

[13:13] <jnthn> er, in Paris

[13:13] <pmichaud> note, not the "Tour de France"

[13:13] <mathw> two people from my office are doing something related to the tour de france

[13:13] <jnthn> mathw: Oh, Munich has excellent beer!

[13:13] <mathw> etape du tour or something like that

[13:13] <mathw> which seem sto involve cycling up two mountains

[13:14] <mathw> sounds painful

[13:14] <mathw> jnthn: so my friends told me

[13:14] <mathw> oh and I liked Stuttgart when I went there for GUADEC

[13:14] <jnthn> Good hearty noms too.

[13:14] <mathw> oh yes

[13:14] <mathw> the noms were excellent

[13:14] * jnthn misses being in Central Europe, but at least will get to holiday there later on this year :-)

[13:15] <mathw> the first night in Munich was the first time I encountered that regional speciality of a large lump of pig cooked in beer, served with potatoes and lard

[13:15] <jnthn> omnomnom

[13:15] <mathw> I can't remember what it's called, but it's GOOOD

[13:17] *** uniejo left
[13:17] * mathw is now hungry again, despite having been to Brown Betty's for lunch

[13:18] <pmurias> TimToady: when using a custom CORE i get a infinite loop when looking &say up

[13:19] <jnthn> mathw: Heh, made me hungry too :-)

[13:20] <pmurias> i'm using STD->parsefile('MildewCORE.setting',settting=>'NULL',tmp_prefix=>'tmp/') to generate it

[13:21] <TimToady> CORE isn't supposed to have an OUTER

[13:22] <pmurias> TimToady: am i generating it right?

[13:27] *** plobsing joined
[13:28] <TimToady> you can look at the generated symbol tables in /syml

[13:30] <TimToady> you probably need to tweak STD.pm6 line 1941

[13:32] <TimToady> it's hardwired to 'CORE'

[13:36] <pmurias> TimToady: keeping the NULL core should be harmless right?

[13:38] <jnthn> pmichaud: How's the closures going?

[13:40] <pmurias> TimToady: changing that line helped but i don't know why

[13:49] *** literal left
[13:50] <cygx> phenny: tell ash_ I added some JS code to poll for new messages/status changes; it's working, but a bit ugly - I need to think about how I want the 'public' interface to look

[13:50] <phenny> cygx: I'll pass that on when ash_ is around.

[13:50] <pmichaud> jnthn: it's going okay

[13:51] <pmichaud> jnthn: when would one not want the signature to be generated lazily?  i.e., under what circumstances do we call create_code_object with $lazy set to zero?

[13:52] *** literal joined
[13:52] *** PerlPilot is now known as PerlJam

[13:55] <jnthn> pmichaud: I think type thunks may not want to be lazily generated

[13:56] <jnthn> I forget if there was actually an issue there

[13:56] <pmichaud> I can see that there might be, if we need a signature before something gets invoked.

[13:56] <jnthn> Yeah

[13:57] <jnthn> I have vague memories of something "interesting" going on there.

[13:57] <jnthn> pmichaud: Looks like we don't for pblocks at the moment

[13:57] <pmichaud> Given that I'm now attaching the lazysig directly to the Parrot sub object instead of the dynamically-created Code wrapper, would you see a big hit from attaching lazysig during the compilation unit's loadinit?

[13:57] <jnthn> pmichaud: But I think there's no good reason for that.

[13:58] <pmichaud> in the case of pblocks, it's because sometimes they're immediate-called and so we don't keep a Code wrapper to generate the sig.

[13:58] <jnthn> pmichaud: If you're doing it from the compilation unit's overall loadinit I think tht's OK

[13:58] <jnthn> pmichaud: oh, that's the one

[13:58] <pmichaud> anyway, I now have it so that one can generate a llsig without needing a Code wrapper.

[13:58] <jnthn> pmichaud: The expense I wanted to avoid was having *loads* of loadinit blocks to invoke

[13:58] <pmichaud> well, we also wanted to avoid creating the signatures

[13:58] <pmichaud> but yes

[13:59] <jnthn> Oh yes, but I meant that's why not to do lazy sig attachment in a laodinit :-)

[13:59] <jnthn> erm, in a loadinit for the block

[13:59] <pmichaud> right

[13:59] <pmichaud> I'm worried about the case of:     BEGIN { foo(); };    our sub foo() { ... }

[14:00] <pmichaud> although I guess in that case the 'our' ends up occurring before the BEGIN.  Maybe.

[14:00] <jnthn> well

[14:00] <jnthn> depends 

[14:01] <jnthn> If we're meant to run BEGIN as soon as we've parsed it (we are) I can't see how that'd work.

[14:01] <pmichaud> oh, that's likely a good point as well.

[14:01] <pmichaud> okay then,    our sub foo() { ... };   BEGIN { foo(); }

[14:01] <pmichaud> we have to make sure that &foo has its signature (lazy or otherwise) attached before the BEGIN block executes.

[14:01] *** JimmyZ joined
[14:02] <pmichaud> but again, I'm guessing the 'our' handling might take care of this already.

[14:02] <jnthn> BEGINs are generally awkward.

[14:02] <pmichaud> regardless, it'll be relatively easy to refactor when/if we get there.

[14:03] <jnthn> Refactoring to get really awesome BEGIN handling, OTOH, is decidedly less easy.

[14:07] *** dual left
[14:10] *** clintongormley left
[14:10] *** literal left
[14:11] <pmichaud> jnthn: I have a question about Actions.pm:3026

[14:11] <pmichaud> oh, wait, it might be a different number in master

[14:11] <pmichaud> (I'm in a branch)

[14:11] <pmichaud> just a sec

[14:11] <pmichaud> Actions.pm:3037

[14:12] <pmurias> TimToady: would adding a null attribute for settings that should be removed (the NULL one), be ok?

[14:12] <jnthn> pmichaud: phone, moment.

[14:12] <pmichaud> jnthn: no rush

[14:12] *** literal joined
[14:15] *** ash_ joined
[14:16] *** mberends joined
[14:16] *** patspam joined
[14:19] *** Ambiguity left
[14:24] <jnthn> my $lazy_name := make_lazy_sig_block($expr<past_block>);

[14:24] <jnthn> pmichaud: That one?

[14:25] <jnthn> pmichaud: That whole chunk of code in where_blockify is dealing with an ordering issue I believe (shoulda commented it as such).

[14:25] <jnthn> pmichaud: Basically, the loadinit can be too late

[14:25] <jnthn> (for where blocks)

[14:26] *** clintongormley joined
[14:26] <jnthn> pmichaud: But if you've done an "always lazy sig, then simplify for immediate blocks" approach then you can probably toss this extra check.

[14:26] <jnthn> And that area can become simpler

[14:26] <jnthn> The problem was that it was not building lazy sigs for the pblocks though

[14:27] <jnthn> And for where we really needed them to beat some ordering issues into submission.

[14:33] *** skids joined
[14:33] <pmichaud> okay, ordering issue tells me a lot

[14:34] <pmichaud> all of that stuff is likely to get a significant refactor/simplification

[14:34] <jnthn> It'd not surprise me if that issue evaporates as a result of your refactors, yes

[14:34] <pmichaud> I'm thinking of combining add_signature and create_code_object

[14:36] *** justatheory joined
[14:37] <pmichaud> actually, immediate blocks end up not needing simplification either :-)

[14:37] <pmichaud> since the lazysig is now attached to the Parrot sub itself and evaluated upon invocation

[14:40] <jnthn> pmichaud: Right, but you build a wrapper for them? Or not?

[14:41] <pmichaud> jnthn: haven't gotten to that part yet :-)

[14:41] <pmichaud> probably won't build a wrapper.

[14:42] *** isBEKaml joined
[14:42] *** sundar left
[14:42] <jnthn> ok

[14:52] *** JimmyZ left
[14:56] *** patspam left
[14:57] *** jaldhar left
[14:57] *** plobsing left
[15:03] *** ashleydev joined
[15:04] *** macdaddy joined
[15:04] *** macdaddy is now known as Guest83880

[15:20] *** pyrimidine joined
[15:26] *** Ross joined
[15:27] *** isBEKaml left
[15:32] *** bbkr joined
[15:35] *** patspam joined
[15:35] *** rv2733 joined
[15:35] *** eternaleye joined
[15:39] *** gbacon joined
[15:52] *** thebird left
[15:54] *** thebird joined
[16:02] *** cygx left
[16:03] *** bbkr left
[16:04] *** bbkr joined
[16:09] *** timbunce left
[16:14] *** bbkr left
[16:14] *** timbunce joined
[16:15] *** bbkr joined
[16:16] *** dual joined
[16:27] *** Guest23195 left
[16:37] *** alester joined
[16:47] <ash_> when you make a sub class, like class Foo is Bar { };  does that call 'compose' in Bar's ClassHOW?

[16:47] <phenny> ash_: 10:08Z <cygx> tell ash_ try.rakudo.org is somewhat functional: hit try.rakudo.org:8090 to create a new session; you can input text and see it displayed twice (most likely only after a manual refresh); copy your sid and insert it at test.html to simulate polling for updates

[16:47] <phenny> ash_: 10:09Z <cygx> tell ash_ don't create too many sessions, though: the backend currently needs a manual restart to get rid of them

[16:47] <phenny> ash_: 13:50Z <cygx> tell ash_ I added some JS code to poll for new messages/status changes; it's working, but a bit ugly - I need to think about how I want the 'public' interface to look

[16:48] <sorear> ash_: no

[16:48] *** Mowah left
[16:48] *** Mowah joined
[16:51] <ash_> does it call ClassHOW's compose? 

[16:51] <sorear> on Foo

[16:53] *** Mowah left
[16:58] *** TiMBuS left
[17:00] <ash_> so, Foo.^compose is called sometime during class Foo is Bar { } ? 

[17:01] *** dakkar left
[17:05] <sorear> in niecza, it's called at the closing brace

[17:05] *** thebird left
[17:06] *** cdarroch joined
[17:06] *** cdarroch left
[17:06] *** cdarroch joined
[17:07] <ash_> rakudo: class Foo { }; class Bar is Foo { method ^compose { say 'yes'; }} 

[17:07] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§A method named 'compose' already exists in class 'P6metaclass'. It may have been supplied by a role.‚ê§¬ª

[17:07] <ash_> sad day oh well, i'll keep trying 

[17:08] <ash_> sorear: if i were to try to add a phaser to roles called COMPOSED that is called when you compose a role into anything, where do you think that would go? 

[17:08] *** Mowah joined
[17:10] <ash_> i think i could add the call to the ^compose method, to fire the phaser 

[17:12] *** tylercurtis joined
[17:15] <PerlJam> ash_++

[17:38] *** meppl joined
[17:41] *** Lorn left
[18:11] *** revdiablo joined
[18:12] <colomon> phenny: tell masak I sent a pull request to LastOfTheCarelessMen last night, and I see he has pulled my changes.  So I think Vector and ABC are now officially ufo-friendly.  Probably still do not work otherwise, alas.

[18:12] <phenny> colomon: I'll pass that on when masak is around.

[18:19] <pmichaud> the signature and closure refactor is becoming painful.  :-|   Not as painful as lists, but still painful.

[18:20] *** Schwern joined
[18:20] <PerlJam> pmichaud: What's painful about it?

[18:20] <pmichaud> the original factoring has lots of dependencies

[18:21] <pmichaud> and a ton has been built on top of those specific dependencies

[18:22] <PerlJam> you're in a maze of twisty passages, all different?  :)

[18:22] <PerlJam> Just think though ... once the refactor is done, the universe will be righter for the next time.

[18:22] <pmichaud> sure, that's the way it usually is.

[18:23] <pmichaud> if it isn't, then there's little point in doing the refactor :)

[18:23] <jnthn> pmichaud: Painful?

[18:23] <PerlJam> pmichaud: but you're not just refactoring ... you're righting the universe :)

[18:24] <pmichaud> jnthn: yeah.  I just get untraceable errors at different points.

[18:24] *** masak joined
[18:24] <masak> \o/

[18:24] <phenny> masak: 18:12Z <colomon> tell masak I sent a pull request to LastOfTheCarelessMen last night, and I see he has pulled my changes.  So I think Vector and ABC are now officially ufo-friendly.  Probably still do not work otherwise, alas.

[18:24] <masak> colomon: progress. nice.

[18:24] <jnthn> pmichaud: Congrats. :/

[18:25] <masak> mberends: just back from a nice Thai meal. we can now say 'elephant' (the name of jnthn's beer) in Thai, tone and all :)

[18:25] * masak backlogs

[18:25] <jnthn> masak: Huh, I didn't remember what tone it was, just that it was a nice beer. -)

[18:25] <jnthn> pmichaud: Specifics?

[18:25] <pmichaud> on phone

[18:25] <masak> jnthn: in Mandarin nomenclature, it was tone 3.

[18:26] <jnthn> ash_: No, .compose does not get called up the hierarchy.

[18:27] <jnthn> ash_: (nor shold it)

[18:27] <jnthn> *should

[18:27] <ash_> okay 

[18:27] <pmichaud> jnthn: it's just when I try to move the sig initialization around, I get "Null PMC" errors.

[18:28] <pmichaud> (and it's not clear where they're coming from)

[18:28] <jnthn> pmichaud: Suggest getting out a C debugger and setting a breakpoint in null.pmc 

[18:28] <jnthn> pmichaud: In case they're coming from the C parts

[18:28] <pmichaud> well, I'm turning on PIR backtraces again to see if it helps.

[18:28] <jnthn> Also worthwhile

[18:28] <jnthn> I usually disable those when debugging guts. :-)

[18:29] <pmichaud> Most of the other refactoring has gone fairly well -- only a little bit of breakage in and around roles at the moment.

[18:29] <ash_> is there a place that is called during inheritance? 

[18:31] <pmichaud> ohhhh, I see the difficulty.  Ickiness.

[18:31] <sorear> hello masak

[18:31] <masak> ash_: that seems to be a frequently-ish asked question.

[18:31] <masak> ash_: I don't think there is.

[18:32] <masak> sorear: hi!

[18:32] <pmichaud> bbiab

[18:32] <jnthn> ash_: No

[18:32] <ash_> masak: well, maybe i can add one, i am trying to prototype a phaser for INHERITED and COMPOSED 

[18:33] <masak> ash_: ah, then it was probably you who asked last time :)

[18:33] <jnthn> ash_: Here's how I'd implement it.

[18:33] <masak> I recall there being talk about those phasers.

[18:33] <ash_> yea, i talked about them

[18:33] <jnthn> ash_: The INHERITED and COMPOSED phasers register with the metaclass.

[18:33] <jnthn> ash_: Then in the .^compose it calls some method to fire the relevant phasers up the hierarchy.

[18:34] <jnthn> (you could put the code in .^compose itself, but factoring it out is a bit neater)

[18:35] <jnthn> rakudo: unlink 'README'

[18:35] <p6eval> rakudo 3d2cb8:  ( no output )

[18:35] <jnthn> ...oops ;-)

[18:36] <sorear> rakudo: say slurp("/etc/passwd")

[18:36] <p6eval> rakudo 3d2cb8:

[18:36] <p6eval> ..OUTPUT¬´root:x:0:0:root:/root:/bin/bash‚ê§daemon:x:1:1:daemon:/usr/sbin:/bin/sh‚ê§bin:x:2:2:bin:/bin:/bin/sh‚ê§sys:x:3:3:sys:/dev:/bin/sh‚ê§sync:x:4:65534:sync:/bin:/bin/sync‚ê§games:x:5:60:games:/usr/games:/bin/sh‚ê§man:x:6:12:man:/var/cache/man:/bin/sh‚ê§lp:x:7:7:lp:/var/spool/lpd:/bin/sh‚ê§mail:x:8:8:m‚Ä¶

[18:36] <jnthn> rakudo: say &unlink.signature

[18:36] <p6eval> rakudo 3d2cb8: OUTPUT¬´Signature()<0x42e3d00>‚ê§¬ª

[18:38] <pmichaud> feels to me as though "INHERITED" and "COMPOSED" should be submethods, not phasers.

[18:38] <pmichaud> something along the lines of BUILD

[18:40] <ash_> well, what would be self for those methods? 

[18:40] <jnthn> That could also work I guess

[18:40] <jnthn> But...what ash_ said.

[18:41] <pmichaud> do you expect them to have a self?

[18:41] <pmichaud> I mean, even as phasers?  What would self be for a phaser?

[18:41] <jnthn> pmichaud: Well, it wouldn't have one

[18:41] <pmichaud> right

[18:41] <masak> http://use.perl.org/~Mark+Leighton+Fisher/journal/40430 # a new perl module!  woot!

[18:41] <ash_> $_ would be the target they are being mixed into 

[18:41] <ash_> I wasn't sure if they'd have a self 

[18:42] <pmichaud> anyway, phaser just feels wrong for some reason.

[18:42] <ash_> maybe I'll just email the language mailing list and think about it a bit more 

[18:42] <jnthn> pmichaud: It kinda fits. It's a block that's run at a special time.

[18:42] <pmichaud> well, technically BUILD is the same :-)

[18:43] <jnthn> Well

[18:43] <jnthn> We can probably agree it should have CAPITALS whatever it is. ;-)

[18:43] <jnthn> BUILD has a fairly obvious invocant though.

[18:43] <pmichaud> anyway, I've noted my discomfort :-)

[18:44] <jnthn> I guess if it's a submethod the invocant is just the type object of the class that we made that inherited from it.

[18:44] <jnthn> It's Liskov-compliant. :-)

[18:46] *** gbacon left
[18:48] <pmichaud> jnthn: so, if I convert all sigs to be lazy would that likely be a win or a lose?

[18:49] <pmichaud> (assuming that we can set up the lazysigs in a single :load :init)

[18:50] <jnthn> pmichaud: Should be fine

[18:50] <jnthn> pmichaud: Perhaps a small win.

[18:51] <pmichaud> well, it's be a win for consistent handling of blocks :)

[18:51] <pmichaud> I'm curious if it's a performance win or lose

[18:51] <jnthn> Well, we gotta build it at some point

[18:51] <jnthn> It's more about when we pay. :-)

[18:51] <jnthn> More at startup, or more later on.

[18:52] <PerlJam> are INHERITED and COMPOSED specced somewhere or is this one of those implementation-first things?

[18:52] <pmichaud> PerlJam: they're speculative.

[18:53] <PerlJam> sure, but are the speculation written anywhere?

[18:53] <pmichaud> http://gist.github.com/461743  # for jnthn++ -- what the lazysig loadinit looks like

[18:53] <pmichaud> PerlJam: no.

[18:53] <ash_> ah, found my old gist http://gist.github.com/392673 from when i last talked about it 

[18:54] <pmichaud> jnthn: so, we end up with one :load :init sub for the entire compilation unit -- inside of that :load :init sub is one setprop instruction for each block in the unit

[18:54] <jnthn> pmichaud: That should be efficient. :-)

[18:54] <pmichaud> the main cost would be that all of the subs would receive prophashes fairly early

[18:55] <jnthn> Right.

[18:55] <jnthn> But if allocating a hash is super expensive, well, we have many bigger problems. ;-)

[18:55] <PerlJam> I don't really have a feel for why you would need to hook into the inheritance mechanism with INHERIT, but it seems to me that COMPOSE would be good for automatic conflict resolution 

[18:55] <PerlJam> sort of a enough-rope kind of thing

[18:56] <pmichaud> we also now have a place where we can do unit-scoped :loadinit things, instead of having to attach them to a block

[18:56] <pmichaud> we may be able to exploit that as well to remove a few :loadinits.

[18:57] <jnthn> Possibly, yes

[18:57] <pmichaud> (can't do it where order-of-initialization matters greatly, or where something needs to be scoped within an outer block)

[18:58] * pmichaud tries the radical "make all sigs lazy" patch

[18:59] *** gbacon joined
[19:01] <ash_> PerlJam: a use for INHERIT i can think of is (for instance) a database ORM that has a class that represents an abstract table might use one so when you subclass it to define your specific table, a callback that is called when the class is inherited would give you the ability to hide a lot more from the end uses, as they wouldn't have to manually register their tables with some object manager 

[19:01] <PerlJam> ash_: if COMPOSE and INHERIT are to be phasers, I don't think they should take parameters, but rather glean everything from the environment somehow.  That seems to be how the other phasers work.

[19:02] <jnthn> That probably suggests they want to be (meta-)?methods.

[19:02] <ash_> yeah 

[19:03] <ash_> thats a good argument against them being phasers

[19:03] <pmichaud> yes, that's the other reason I was thinking more along the lines of submethods.

[19:04] <ash_> i don't remember why i wanted them to be phasers, so... it probably wasn't that big of an issue... 

[19:05] <PerlJam> ash_: I'm not sure I buy your ORM example since even though there are  things you want to happen automatically, you'll also want to be able to customize for the cases where the proper conventions aren't followed.

[19:05] <ash_> ruby on rails ActiveDirectory does it 

[19:05] <PerlJam> ash_: i.e. sometimes you *want* to manually register your tables

[19:06] <ash_> they use the inherited callback to register which objects represent database tables

[19:06] <pmichaud> objects?!  or classes?

[19:06] <ash_> DataMapper does it with what would be effectively COMPOSE 

[19:06] <PerlJam> ash_: but do you really need to hook into "inherit time operations" to do that?

[19:07] <ash_> pmichaud: classes i meant, not specific instances 

[19:07] <PerlJam> ash_: or do you just need to inherit from a class that makes good use of introspection?

[19:08] <ash_> well, the reason they do it that was is you can load the class definitions, then know right after loading them the database table defintions, if you put it in like BUILD then you'd have to instantiate an object for each database table before you'd know  

[19:09] <pmichaud> class submethods could be called at composition time, not at instance creation time, though.

[19:09] <PerlJam> ash_: also, if I remember my rails enough, the things you're talking about are done via ordinary subs (or maybe methods) that happen to execute as the class is being built.  We already  have  that without an INHERIT hook

[19:10] <ash_> the self.inherit hook in ruby executes at the last "end" in a class definition 

[19:11] *** Lorn joined
[19:11] <pmichaud> jnthn: with my latest changes, refactoring suddenly became much less painful again.  :-)

[19:12] <PerlJam> ash_: Hmm. 

[19:12] <jnthn> pmichaud: yay :-)

[19:12] <jnthn> pmichaud: Am hacking on some S12 bits ATM, hopefully should be well clear of what you're working on. :-)

[19:13] <pmichaud> jnthn: I hope so, yes.  As long as you're not dealing with   create_code_object, add_signature, make_block, etc., we should be fine.  :)

[19:13] <jnthn> no no

[19:13] <jnthn> with luck, not even touching Actions.pm :-)

[19:13] <pmichaud> bind?

[19:13] <jnthn> Pondered it then realized...nah

[19:13] <pmichaud> any of the pmc classes?

[19:13] <pmichaud> the dynops?  ;-)

[19:13] <jnthn> pmichaud: No, I'm just re-instating class Foo is rw { ... } implying the attributes are is rw by default

[19:14] *** mantovani joined
[19:14] <jnthn> Should be all in traits.pm and the meta-model if I do it right. ;-)

[19:14] <pmichaud> okay, that might affect things a bit, since attribute initialization is thunk-based.

[19:14] <pmichaud> but probably not.

[19:14] <jnthn> Unlikely.

[19:15] <ash_> PerlJam: I just checked, thats how they used to do it, apparently they don't use the inherit callback in the most recent version, i am not sure how its done now (but back around 2.0 they used the inherit callback) 

[19:15] <ash_> http://github.com/rails/rails/blob/v2.0.1/activerecord/lib/active_record/base.rb#L300

[19:17] <PerlJam> ash_: thanks

[19:18] <PerlJam> ash:  but if it's called just before the last end,  we can already do class Foo { ...  some-func(); }   now.  Is there some advantage to being able to put some-func() anywhere within the class def?

[19:19] <ash_> PerlJam: ah, they just have a special class that they delegate the descendants to now, http://github.com/rails/rails/blob/master/activesupport/lib/active_support/descendants_tracker.rb#L23

[19:20] <ash_> PerlJam: i don't understand what you mean, are you saying, instead of having a callback, just have people put a sub call in the body of the class definition? 

[19:20] <PerlJam> sure

[19:21] <ash_> to me, having an automated way is cleaner but i suppose it results in the same thing

[19:21] <ash_> if people remember to do it

[19:21] <PerlJam> Perl should have enough static information to know the class at that point and have enough introspective ability to look up the inheritance tree

[19:22] <ash_> but this is for looking down the inheritance tree not up 

[19:22] <PerlJam> (and you can already put it anywhere, but I was assuming that it's important to know the method defs that came before it :)

[19:23] <pmichaud> PerlJam: the point is to put the phaser/submethod into the base class, not the derived one.

[19:23] <pmichaud> and it's automatically triggered whenever a new class is derived/composed from it.

[19:23] <pmichaud> (maybe you're accommodating this already; I don't see it though)

[19:24] <lue> ohai

[19:24] <PerlJam> no, I guess I was thinking that the class body would be executed on each instance creation, but that's not the case.

[19:24] <PerlJam> (that's why we have BUILD, etc after all)

[19:24] <ash_> in this particular example, thats useful because you can say "AbastractDatabaseTable.decendants>>definition" and know all of the database tables you need to make

[19:24] <pmichaud> also, you want it to happen at composition time, not at instance creation time.

[19:24] <ash_> my hyper op might be wrong there

[19:24] <jnthn> >>.

[19:24] <pmichaud> ash:  >>.

[19:25] <ash_> ah, yup thought so

[19:25] <ash_> i keep forgetting to do >>. or do .>> for whatever reason 

[19:25] <masak> loliblogged! http://use.perl.org/~masak/journal/40431

[19:25] <jnthn> lol

[19:25] <lue> can anyone mind checking this, and seeing what I got wrong? http://gist.github.com/460851

[19:26] <masak> (kind of a long one today. I was on a bus and got bored.)

[19:26] <masak> has a happy ending, though. :)

[19:26] <jnthn> Glad you were able to keep busy somehow. ;-)

[19:26] <masak> :)

[19:28] <pmichaud> lue: I would put := in with assign.pir

[19:28] <pmichaud> actually, scratch that.

[19:28] <pmichaud> := has to go into the setting.

[19:28] <pmichaud> because there are other entries for := already in the setting.

[19:29] *** patspam left
[19:29] <PerlJam> I guess that's why I asked for a spec ...  I don't really understand INHERIT  :)

[19:29] * lue wonders where the setting is.

[19:29] <pmichaud> src/core/operators.pm

[19:30] <PerlJam> COMPOSE makes some sense though

[19:30] <masak> PerlJam: neither of them are actually in the Spec. :)

[19:30] <ash_> PerlJam: http://gist.github.com/392673 is kinda how i thought it would work

[19:31] <PerlJam> ash_: that illustrates the what, but not so much the when.

[19:31] <ash_> ah good point

[19:32] <lue> ah. well, that's why I was asking about checking for a variables rw-ness using P6! I thought of putting it there. :)

[19:32] <PerlJam> It seems like INHERIT and COMPOSE are just special cases of "class definition time"

[19:33] <PerlJam> and should they fire before or after the body of the class has been processed?

[19:33] <PerlJam> (I'd say before)

[19:34] <masak> std: class A { is Int }

[19:34] <p6eval> std 31529: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§      'is' used at line 1‚ê§Check failed‚ê§FAILED 00:01 111m‚ê§¬ª

[19:34] <pmichaud> masak: nice post.  fwiw, I decided a few days ago that Rakudo's implementation of &circumfix:<{ }> is incorrect, since it assumes hash.

[19:34] <masak> hm, guess one has to specify in the header what the parents of a class are.

[19:34] <masak> pmichaud: sounds like it should assume closure, yes.

[19:35] <masak> at least from the spec.

[19:35] <masak> it's a "closure-until-proven-hash" thing.

[19:35] <pmichaud> masak: if it exists at all.  :-)

[19:35] <lue> I really don't want to fill the entire infix:<:=> sub in the setting with a giant Q:PIR block .oO(all those labels...). Hrm...

[19:35] <pmichaud> but yes, closure-until-proven-hash.

[19:35] <pmichaud> lue: you're doing far more work in := than needs to be done, I think.

[19:35] <masak> pmichaud: in what cases does it not exist at all? :)

[19:36] *** patspam joined
[19:36] <pmichaud> lue: for one, it's not necessary to check on STORE

[19:36] <masak> S12:143. TimToady ^

[19:36] <jnthn> pmichaud: Hmm...

[19:36] <masak> TimToady: either S12 or STD.pm6 should be updated :)

[19:36] <lue> Well, admittedly, I just transcribed most of it from assign.pir....

[19:37] <jnthn> pmichaud: It seems that we don't know how to handle get_pmc_keyed on a Perl 6 Array.

[19:37] <pmichaud> anyway, I think we got rid of the notion of "is Foo" being accepted inside the class body.

[19:37] <jnthn> pmichaud: Can we make it do so?

[19:37] <jnthn> pmichaud: I'm hitting it where NQP code encounters a Perl 6 object and then cries. :-)

[19:37] <jnthn> er, a Perl 6 Array

[19:37] <pmichaud> jnthn: if you just want to have it forward to postcircumfix:<[ ]>, I'm okay with that.

[19:37] <pmichaud> much easier now that postcircumfix:<[ ]>  takes a single argument, too :)

[19:37] <jnthn> pmichaud: Should I do it just for Array for now?

[19:38] <jnthn> pmichaud: Or put it in Mu.pir with the others and see what that does?

[19:38] <pmichaud> you could do it in List.

[19:38] <jnthn> OK

[19:38] <pmichaud> I'm not sure if it'll survive in Mu.

[19:38] <pmichaud> it's very likely to end up in Any.

[19:38] <jnthn> Me either

[19:38] *** pyrimidine left
[19:38] <pmichaud> In fact, I'm thinking that postcircumfix:<[ ]>  in general is likely to move out of Positional and into Any.

[19:40] <ash_> what would Positional imply then? 

[19:40] <pmichaud> bindable to @-sigil

[19:41] <ash_> ah, thats useful

[19:42] <tylercurtis> masak: very awesome paragraph: "Or like me coming to visit you, but instead of leaving my phone number, I activate one half of an entangled-pair portal in your living room and take the other half with me."

[19:43] *** meppl left
[19:44] <pmichaud> masak: speaking of TheDamian, I have a shiny new implementation of IO::Prompt for rakudo that he'd like to contribute to the pool of modules.

[19:44] <masak> pmichaud: nice!

[19:44] <pmichaud> masak: what's the best way for me to go about making that available?  (My proto-fu is very low, although I expect to raise it in the next week)

[19:44] <masak> there's one in there already, I think.

[19:44] <masak> by, hm, omega?

[19:44] <pmichaud> ....probably not like this one.  :)

[19:45] <masak> probably not. :)

[19:45] <masak> but the issue of name collision still arises.

[19:45] <jnthn> :auth<TheDamian>

[19:45] <masak> theoretically, yes.

[19:45] <jnthn> ;-)

[19:45] <jnthn> Rakudo can take it. :P

[19:45] <masak> pls can't, yet.

[19:45] <jnthn> oh pls!

[19:46] <masak> neither can  proto, afaik.

[19:46] <pmichaud> let me see if it's IO::Prompt or IO::Prompter

[19:46] <pmichaud> Damian changed the name of his p5 module to IO::Prompter

[19:46] <pmichaud> so perhaps the p6 module is the same.

[19:46] <masak> that'd help.

[19:46] * masak hopes to have :auth working soon-ish in pls.

[19:47] <pmichaud> IO::Prompter

[19:47] <pmichaud> \o/

[19:47] <masak> \o/

[19:47] * jnthn just gave masak++ a round tuit ;-)

[19:47] <masak> jnthn: tack :P

[19:47] <jnthn> The joy of meatspace

[19:48] <tylercurtis> masak: the mention of "infix:<||>" in the bit on implicit closures shows up as "infix:".

[19:48] <masak> ooh, moritz_++ already redirected proto.perl6.org -> modules.perl6.org \o/

[19:48] <masak> tylercurtis: thanks, fixing.

[19:49] <pmichaud> http://gist.github.com/461824  # a taste of what IO::Prompter can do

[19:49] <masak> tylercurtis++: fixed.

[19:50] <masak> pmichaud: whoa.

[19:50] <pmichaud> so, in this instance it prompts for an amount (must be numeric), a rate (must be 0..1), a term (must be int), and a description (must be non-empty)

[19:50] <pmichaud> when it's able to fill in all of the params, it executes the block.

[19:51] <pmichaud> The prompt says "Enter an amount: ",  "Enter a rate: ",  "Enter a term: ",  etc.

[19:51] <pmichaud> which it gets by introspecting the signature of the block :)

[19:51] <_sri> http://kraih.com/tpf-clean-sri.png # cleaned up

[19:51] <masak> jnthn++ # TheDamian's module rests a lot on siggie introspection

[19:52] <jnthn> So does Zavolaj.

[19:52] <jnthn> ;-)

[19:52] <masak> pmichaud: we just figured out all you just described :P

[19:52] <masak> sri_++ # TPF logo

[19:53] <ash_> jnthn: btw, my nci changes are almost done, so... if those are all figured out then you can build any signature (in theory) with libffi dynamically 

[19:53] <pmichaud> anyway, the module needs cleaning up for rakudo master branch

[19:53] <pmichaud> I guess I'll just stick it in a github repo and see who comes to fork+fix :)

[19:54] * lue gets visions of CPAN6...

[19:54] <pmichaud> now then, let's see how badly I've broken spectests in my branch

[19:55] <jnthn> pmichaud: List.pir:

[19:55] <jnthn> (It's temporarily named "List" to avoid conflict with existing

[19:55] <jnthn> List classes while we convert to the new list model.)

[19:55] <jnthn> Fossil?

[19:55] <pmichaud> fossil.

[19:55] <jnthn> I'll donate it to a museum.

[19:55] <pmichaud> it was temporarily named "Lyst", but then I did :1,$s/Lyst/List/g   :-)

[19:55] <masak> told ya! :)

[19:56] <pmichaud> I still need to go back and add copious comments and documentation to the files.

[19:56] * masak .oO( the hackathon is wonderful, with y'all were here )

[19:56] <pmichaud> who's there?

[19:56] <masak> hm, let's see...

[19:56] <masak> there's jnthn...

[19:56] <masak> and me...

[19:56] <masak> that's it. :)

[19:56] <PerlJam> sounds like that's more than enough  :)

[19:56] <pmichaud> EIWANNABEINEUROPE

[19:57] <pmichaud> reminder:  Rakudo hackathon in Pisa on August 3

[19:57] <masak> ah, a region-dependent error message. :)

[19:57] <ash_> pmichaud: don't we all...

[19:57] <PerlJam> ash_: I don't!

[19:57] <pmichaud> argggh, fails.

[19:57] <pmichaud> I wonder if those are closure fails.

[19:58] * jnthn looks forward to having closure on those

[19:58] <lue> How do I get variables passed to a sub into a Q:PIR block?

[19:58] * masak .oO( come closure... )

[19:58] <PerlJam> lue: find_lex('$var')

[19:58] <lue> ah. dankon.

[19:58] <masak> nedankinde!

[19:58] <ash_> PerlJam: well, europe is the one continent i haven't been to... (and Antartica...) 

[19:58] <jnthn> find_lex '$var'

[19:59] <jnthn> $P0 = find_lex '$var'

[19:59] <PerlJam> yeah, what jnthn said

[19:59] <PerlJam> I never seem to be able to remember specifics

[19:59] <ash_> rakudo: my $a = 3; Q:PIR { .local pmc a‚ê§   a = find_lex '$a' ‚ê§ say a }

[19:59] <p6eval> rakudo 3d2cb8: OUTPUT¬´3‚ê§¬ª

[20:00] *** pmurias left
[20:00] *** Schwern left
[20:00] <masak> rakudo: sub foo { Q:PIR { .local pmc foo‚ê§ foo = find_lex '&foo' ‚ê§ say foo } }; foo()

[20:00] <p6eval> rakudo 3d2cb8: OUTPUT¬´foo‚ê§¬ª

[20:00] <masak> huh.

[20:01] * lue thinks of the day when you can write assignment and binding in pure P6...

[20:02] <masak> lue: you can in Yapsi :)

[20:02] <masak> and in Rakudo alpha.

[20:02] <masak> and in Pugs, probably.

[20:03] <jnthn> rakudo: class Foo { has $!x; has $!x; }

[20:03] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Can not re-declare attribute $!x at line 11, near "; }"‚ê§¬ª

[20:03] <lue> multi sub infix:<=>($a, $b) { $a = $b;};     :)

[20:05] *** Schwern joined
[20:05] <jnthn> rakudo: class Foo { has $.x is readonly; }

[20:05] <p6eval> rakudo 3d2cb8:  ( no output )

[20:05] <lue> grr, same error as before. :(

[20:05] <masak> arnsholt: ping

[20:06] <lue> for some reason, := refuses to be coded. :=(

[20:08] <jnthn> :=(

[20:08] <pmichaud> rakudo:  sub foo($x) { -> { say $x } };  $b = foo(3);  $c = foo(4);  say $b();

[20:08] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Symbol '$b' not predeclared in <anonymous> (/tmp/41FiSL3ERJ:11)‚ê§¬ª

[20:08] <pmichaud> rakudo:  sub foo($x) { -> { say $x } };  my $b = foo(3);  my $c = foo(4);  $b();

[20:08] <p6eval> rakudo 3d2cb8: OUTPUT¬´4‚ê§¬ª

[20:09] <lue> here's the line (in src/gen/perl6-actions.pir) that always causes a failure:

[20:09] <lue>     .const 'Sub' $P7022 = "286_1277921755.74026"

[20:09] <pmichaud> that's not the line causing a failure.

[20:09] <masak> pmichaud: so, when's IO::Prompter coming online?

[20:09] <masak> :)

[20:09] <pmichaud> masak: later tonight, I guess.

[20:09] <masak> \o/

[20:09] <pmichaud> once I've done closing closures.

[20:09] <masak> \\\ooo///

[20:09] <colomon> \o/

[20:10] <jnthn> masak: Shall we stay up and wait for IO::Prompter? ;-)

[20:10] <pmichaud> hint:  "No."

[20:10] <jnthn> ;-)

[20:10] <pmichaud> it may be very late tonight.

[20:10] <masak> jnthn: that's Texan "tonight" o.O

[20:10] <lue> the problem is, it just _happens_ to be in generated files the problem occurs in /o\

[20:10] <masak> jnthn: it's probably later than most other "tonight"s :P

[20:10] <jnthn> And bigger.

[20:10] <lue> (methinks it's not my bind code anymore)

[20:10] <masak> jnthn: and in ASCII.

[20:10] <pmichaud> lue: the line numbers reported for errors in PIR are generally not correct.

[20:11] <lue> that's just *better*! :=)

[20:12] <masak> by the way, for those who are following the pls saga: over Thai food, jnthn++ suggested that I change the build semantics for project dependencies -- right now, things work in lockstep, building everything before running tests, etc. jnthn suggested doing like CPAN: installing all deps before building the dep-ing project.

[20:12] <masak> so I'll refactor pls to do that now, if no-one protests loudly.

[20:13] <lue> well then, you only hear silence from IRC :)

[20:14] <masak> for some definition of 'silence' :)

[20:14] <pmichaud> what if someone other than "no-one" protests?  ;-)

[20:14] *** jnthn is now known as no-one

[20:14] <no-one> I protest!

[20:14] *** no-one is now known as jnthn

[20:14] <pmichaud> proceed if none(@perl6) ~~ *.protests

[20:15] <masak> jnthn: right, I'll just go ahead then.

[20:15] <pmichaud> can I protest later if it doesn't work out?  ;-)

[20:15] <masak> pmichaud: absolutely. :)

[20:16] <masak> pmichaud: wow, junctions, smartmatching *and* a whatever closure. and the brain parses it instantly! scary!

[20:17] *** rv2733 left
[20:18] <jnthn> std: my @perl6; proceed if none(@perl6) ~~ *.protests

[20:18] <p6eval> std 31529: OUTPUT¬´ok 00:01 114m‚ê§¬ª

[20:18] <masak> oh, and 'proceed' too! that's a code flow exception.

[20:18] <pmichaud> :-)

[20:18] <jnthn> Wow, soon most English will be easily translatable to Perl 6.

[20:18] <masak> I know! let's make a poem, and call it "Black P..." oh wait

[20:18] *** timbunce left
[20:19] *** timbunce joined
[20:19] <lue> Perl 6 already has more pronouns than English!

[20:19] <lue> (just look at %_)

[20:19] <dalek> niecza: 1729265 | sorear++ |  (2 files):

[20:19] <dalek> niecza: Implement my class Foo { ... }

[20:19] <dalek> niecza: review: http://github.com/sorear/niecza/commit/17292650cd2cbdaa979df19c745fd0e07aa1ea1e

[20:19] <masak> lue: just like "operators are akin to prepositions", eh? :P

[20:20] <lue> $_ doesn't matter, I'm not one of @_. However, %_'s a good thing.

[20:20] <pmichaud> locally:

[20:20] <pmichaud> > sub foo($x) { -> { say $x } };  my $b = foo(3);  my $c = foo(4);  $b();

[20:20] <pmichaud> 3

[20:21] <jnthn> <3

[20:21] <lue> (oh hell, now what do we call &_ ? aaah! *hair pull*)

[20:21] <pmichaud> mostly I've been refactoring and ripping out code

[20:21] <masak> lue: also, what would you call ::_ ? and $^_ ?

[20:21] <pmichaud> I don't think I added anything new.

[20:21] <lue> .u stop

[20:21] <phenny> U+002E FULL STOP (.)

[20:21] <pmichaud> I love it when fixing bugs makes code smaller.  :-)

[20:21] <lue> .u octogon

[20:21] <phenny> lue: Sorry, no results for 'octogon'.

[20:21] <pmichaud> .u octagon

[20:21] <phenny> pmichaud: Sorry, no results for 'octagon'.

[20:22] <masak> pmichaud++ # apparently removing the right code :)

[20:22] <masak> .u stop in the name of octagon

[20:22] <phenny> masak: Sorry, no results for 'stop in the name of octagon'.

[20:22] <jnthn> If we remove everything, there won't be any bugs, just not yet implemetned stuff.

[20:22] <lue> well of course, that's because you sweep bugs out of the corner, freeing space.

[20:22] <jnthn> ;-)

[20:22] <masak> jnthn: that'd be AWESOME.

[20:22] <lue> .u glome

[20:22] <phenny> lue: Sorry, no results for 'glome'.

[20:22] <masak> jnthn: think of the potential!

[20:23] <jnthn> masak: Like in the early days, when we could boast NO FEATURES!

[20:23] <jnthn> It was so zen!

[20:23] <pmichaud> this is not "sweeping bugs out of the corner".  This is reimagining the world in which bugs simply do not exist in the first place.  :)

[20:23] <masak> jnthn: a fresh start! a... a redesign!

[20:23] <masak> pmichaud: now I'm scared :P

[20:23] <lue> Absolutely nothing in Rakudo comes without surprises! ;)

[20:23] <jnthn> So you re-wrote Rakudo in Newspeak?

[20:23] <pmichaud> lue: that's for sure.  "Null PMC" is nearly always a surprise.

[20:24] <masak> lue: absolutely nothing in Rakudo comes without the lack of multple negations... NOT!

[20:24] <alester> Null PMC droppin' the phat beats.

[20:24] <pmichaud> "nearly nothing..."  :-)

[20:24] <lue> .oO(PMC is P6's version of the devil)

[20:24] <masak> jnthn: Gilead Bracha has a programming language called Newspeak.

[20:24] <lue> "why did my copy of rakudo have to die()? Curse you PMC!!!!"

[20:24] * pmichaud runs a spectest.

[20:25] <masak> s/Gilead/Gilad/

[20:26] <pmichaud> jnthn: what's the purpose of the 'proto' property on Code objects?

[20:26] <jnthn> pmichaud: It's how the multi-dispatcher knows "this is the proto"

[20:26] <jnthn> pmichaud: But protos will change epicly in a bit

[20:26] <pmichaud> could that be done with an attribute instead?

[20:27] <jnthn> Probably - it dates back directly to the days when we din't have wrappers, fwiw.

[20:27] <jnthn> But don't waste tuits on cleaning it up unless it helps you otherwise. (more)

[20:27] <jnthn> spec changes mean protos need to also change a lot.

[20:28] <pmichaud> okay, won't waste the tuits unless I need to then.

[20:28] <jnthn> And be much more than "just a flagged routine"

[20:30] <PerlJam> rakudo doesn't autovivify multi-level data structures yet, does it?   Like  my @a; @a[3][5] = 7;

[20:31] <pmichaud> PerlJam: that's next on my list.

[20:31] <pmichaud> I need closures to work first.

[20:31] <PerlJam> ah, pmichaud++

[20:31] <pmichaud> because those get done by    my $x but WHENCE({ ... })

[20:31] <pmichaud> and that closure in the WHENCE needs to capture the right values.

[20:32] *** bjarneh joined
[20:32] <pmichaud> basically:

[20:33] <pmichaud>     my $x but WHENCE({ self.defined || &infix:<=>(self, Array.new);  pir::set__vQiP(self!fill, $pos, $x); });

[20:33] <pmichaud> which creates the array if needed and then binds the element :-)

[20:34] <lue> (would Ê•ΩÂúü's API outline just about every method in src/  ?)

[20:35] *** Trashlord joined
[20:37] *** Improv joined
[20:38] <jnthn> er, that pir::set ? v?

[20:39] <sorear> void

[20:39] <sorear> std: sub &* { ... } # What does this mean?

[20:39] <p6eval> std 31529: OUTPUT¬´ok 00:01 110m‚ê§¬ª

[20:40] <PerlJam> every time I see pir::foo__xxxxx(...), I wish it were nqp::foo(...) now

[20:40] <lue> .oO(every time I see pir in .pm files, I wish it weren't there) :)

[20:40] <PerlJam> lue++

[20:40] <jnthn> erm, yes, but the set opcode doesn't have a void variant? :S

[20:41] <sorear> it doesn't need one

[20:42] <sorear> set__vQiP resolves to set__p_i_p

[20:42] <Improv> Is this the best place to get some very basic perl6 help? (know p5, starting to learn p6 syntax)

[20:42] <sorear> yes

[20:43] <pmichaud> set__vQiP   translates into    set $P0[$I1], $P2

[20:43] <PerlJam> Improv: certainly

[20:43] <pmichaud> it's "void" because it doesn't allocate a new register for the result.

[20:43] <sorear> pmichaud: is Q new?  I can't find it in my checkout

[20:43] <pmichaud> it's new-ish, yes.  I added it sometime early last week.

[20:43] <jnthn> pmichaud: oooh!!!

[20:44] <jnthn> That was WANT for ages

[20:44] <jnthn> Is it doc'd somewhere?

[20:45] <pmichaud> in the past sources, yes.  :)

[20:45] <Improv> When I do http://fpaste.org/ZQcI/ I get a get_pmc_keyed not implemented in class '' error

[20:45] <pmichaud> Q indicates a keyed pmc, the letter that follows identifies the type of key

[20:45] <Improv> Thing is, I am closely following examples I found on the web

[20:45] <pmichaud> so we also now have   pir::exists__IQi

[20:46] <jnthn> pmichaud: ohawesome :-)

[20:46] <pmichaud> which translates to   $I0 = exists $P1[$I2]

[20:46] <PerlJam> Improv: not sure the "Array of Int" bit is implemented yet.

[20:46] <pmichaud> Array of Int _was_ implemented, but it broke when someone merged in the new list/iterator improvements.

[20:46] <pmichaud> it needs to be fixed again.

[20:47] <Improv> Aha. Good to know.

[20:47] <pmichaud> if you get rid of the "of Int" it will likely work out okay.

[20:47] <PerlJam> Improv: my Int @bar; should work.

[20:47] <pmichaud> fsvo of "work"

[20:47] <PerlJam> oh, maybe not

[20:47] <pmichaud> at the moment I don't believe it actually typechecks the values.

[20:47] <Improv> Actually, providing any type at all causes it to break

[20:47] <PerlJam> my @bar; then  :)

[20:48] <Improv> but removing the type works

[20:48] <pmichaud> correct.

[20:48] * masak makes a voiceless alveolar lateral fricative

[20:48] <masak> lllllhhhhh!

[20:48] <jnthn> Also note that my Array of Int @bar probably doesn't mean what you want it too.

[20:48] <PerlJam> masak: I thought you said it was voicelesS?

[20:48] <Improv> Ok, good to know it's not something stupid I'm doing and is a rough edge in the language

[20:48] <masak> PerlJam: ... ... !

[20:48] <jnthn> masak is decidedly not voiceless :P

[20:48] <pmichaud> rough edge in the implementation, yes.

[20:48] <Improv> jnthn: Oh, does the type of an aggregate apply to all members of the aggregate rather than describe the aggregate itself?

[20:49] <pmichaud> Improv: correct,

[20:49] <pmichaud> so    my Array of Int @bar;   means that @bar contains Arrays of Int

[20:49] <Improv> Gotcha.

[20:49] <pmichaud> (since @bar is already an Array)

[20:49] <pmichaud> while   my Array of Int $bar;   would constrain $bar to being an Array of Ints

[20:49] <PerlJam> Improv: are you aware of the Perl 6 book?

[20:50] <tylercurtis> You can do my @bar is Array of Int for something closer to my Array of Int $bar, right?

[20:50] <Improv> PerlJam: No - wasn't sure the language was at a state yet where it'd be good to buy books about it yet

[20:50] *** ashleydev_ joined
[20:51] <jnthn> Improv: It's just a PDF for now, so no expense or risk to trees. ;-)

[20:51] <jnthn> http://github.com/perl6/book/

[20:51] <Improv> jnthn: Cool - where can I snag that baby?

[20:51] <PerlJam> Improv: it's not a book you buy yet, but it is on github.  You might check it out and give us some feedback from someone who's trying to learn the language.

[20:51] <Improv> Nice, thanks

[20:51] * pmichaud waits for the spectest run to finish....

[20:52] <Improv> I can give you feedback from an experienced-but-weird perl5 programmer :)

[20:52] *** ashleydev left
[20:52] *** ashleydev_ is now known as ashleydev

[20:52] <pmichaud> We like feedback.

[20:52] <jnthn> We like weird.

[20:52] <pmichaud> Some of us even stick microphones directly in front of speakers in order to produce more feedback.

[20:52] <masak> We like Perl 5 programmers!

[20:52] <Improv> Actually it was very jarring needing a space before () in my elsifs

[20:52] <Improv> that is highly irritating

[20:52] <pmichaud> you don't need the parens.

[20:53] <masak> Improv: did you get an informative error message?

[20:53] <pmichaud> it becomes much less irritating when you don't need the parens at all :-)

[20:53] <Improv> Parenths make me happy

[20:53] <masak> Improv: it'll pass :P

[20:53] <pmichaud> you can keep the parens, yes.

[20:53] <masak> Improv: we don't mind forcing people into new habits, but we like to do it nicely if we can :)

[20:53] <Improv> When I don't have the space, it tells me "unable to parse blockoid, couldn't find final '}'

[20:53] <pmichaud> but you do need that space.  Otherwise Perl 6 thinks you're wanting to call the elsif(...) function.

[20:53] <pmichaud> yeah, I need to fix that error message.

[20:54] <masak> std: if 42 { ... } elsif("OH HAI") { ... }

[20:54] <p6eval> std 31529: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Strange text after block (missing comma, semicolon, comment marker?) at /tmp/IxDXST3gPj line 1:‚ê§------> [32mif 42 { ... }[33m‚èè[31m elsif("OH HAI") { ... }[0m‚ê§    expecting statement_control‚ê§Parse failed‚ê§FAILED 00:01 108m‚ê§¬ª

[20:54] <pmichaud> btw, just as a head's up, I'm expecting that we'll have monthly Rakudo Star releases for the first few months after July 29.

[20:54] <Improv> Anyone who would write a function called elsif() is probably making an entry for the obfuscated perl contest

[20:55] <pmichaud> Improv: we just have a general rule that anything immediately followed by parens is a function call.

[20:55] <Improv> That's fair - makes writing the parser easier I'm sure

[20:55] <masak> ...except when it isn't.

[20:55] <Improv> I'll get used to it

[20:55] <pmichaud> writing the parser is basically impossible without it.  :)

[20:55] <PerlJam> Improv: it's not so much about the parser as it is about keeping things regular for the programmer

[20:55] <pmichaud> PerlJam: it's about the parser, too.  :)

[20:55] <Improv> PerlJam: Perl5 was fine without the need for that space

[20:55] <masak> std: sub foo($a) {} # this is not a function call...

[20:55] <p6eval> std 31529: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[20:56] <lue> rakudo: say 3 + #`(comment!) 3

[20:56] <p6eval> rakudo 3d2cb8: OUTPUT¬´6‚ê§¬ª

[20:56] <lue> :D

[20:56] <PerlJam> pmichaud: sure, but the rule is all part of the regularization of Perl that makes it easy for the humans.

[20:56] <PerlJam> er, easier 

[20:56] <Improv> although language features have always been easily confused with method calls in C-family languages

[20:56] <[particle]> perl 5's parser is not sane.

[20:56] <jnthn> ash_: Any work on callbacks in with the NCI goodness? :-)

[20:56] <Improv> particle: True. It is lovable despite that.

[20:57] *** ashleydev left
[20:57] <PerlJam> perhaps I just like to look at Perl 6 through the lens of a human eye rather than a machine eye  ;)

[20:57] <pmichaud> is it just me, or does T::H 3 no longer tell you how many tests you actually failed?

[20:57] <masak> Improv: in many languages, one can do $object #`(note the space here) .method

[20:57] <masak> Improv: not so in Perl 6.

[20:57] <ash_> jnthn: on 64 bit computers it works fine, passes all the nci tests, even compiles rakudo  

[20:57] <ash_> i have a problem on 32 bit computers i am fixing now

[20:57] <Improv> Oh, hey, why doesn't perl6 complain then about if() ? It's only upset about elsif()

[20:57] <masak> rakudo: if()

[20:57] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Missing block at line 11, near ""‚ê§¬ª

[20:57] <pmichaud> Improv: implementation bug.

[20:58] <pmichaud> std:  if()

[20:58] * masak submits rakudobug

[20:58] <p6eval> std 31529: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§      'if' used at line 1‚ê§Check failed‚ê§FAILED 00:01 107m‚ê§¬ª

[20:58] <masak> heh.

[20:58] <Improv> pmichaud: ..... Ok.. somehow this is amusing

[20:58] <masak> another one of those preferably turn-off-able warnings.

[20:58] <pmichaud> masak: sure, you can turn off the warning by declaring if.  :-)

[20:59] <masak> worksforme.

[20:59] <pmichaud> std:  sub if() { "you say so"; };   if();

[20:59] *** javs joined
[20:59] <p6eval> std 31529: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[20:59] <PerlJam> Improv: btw, in case you missed it.  Jul 29.  Rakudo Star.  An early adopter distribution of Perl 6 built on Rakudo

[20:59] <masak> pmichaud: no, I meant if it had warned against if() there.

[20:59] <Improv> Hmm. There are a LOT of code samples on the web with if()

[20:59] * PerlJam blames pugs!

[20:59] <Improv> PerlJam: so maybe it's premature for Redhat to have started shipping perl6?

[21:00] <pmichaud> no, not premature.

[21:00] <pmichaud> open source is all about recognizing that some products get released before their complete.

[21:00] <pmichaud> Rakudo Star falls into that category.

[21:00] <pmichaud> *they're

[21:00] <pmichaud> hmmm... quite a few fails in spectest but overall not too bad.

[21:01] <pmichaud> afk, commuting

[21:01] <pugssvn> r31530 | jnthn++ | [t/spec] Test that is readonly on an attr overrides a class-wide is rw. 

[21:01] <Improv> Umm... so.. I imagine there's little chance of convincing you to .. err.. extend the if() bug so that elsif() works too? ^_^

[21:01] <masak> jnthn: nice!

[21:01] <PerlJam> Improv: very little :)

[21:02] <PerlJam> Improv: so ... you're using a redhat supplied rakudo and didn't build it yourself?

[21:02] <Improv> PerlJam: Yeah - last time I built it myself was maybe a year or so ago and it didn't do a lot

[21:03] <ash_> what version is it? do you know? 

[21:03] <PerlJam> heh, I was just about to ask that

[21:03] <Improv> rakudo-0.0.2010.06_2.5.0.x86_64

[21:03] <masak> Improv: I urge you to try without the parentheses for a week or two, see if you get used to it. mberends said in a talk once that people -- even those who resist at first -- usually come back and say "ok, without is actually nicer"

[21:03] <PerlJam> oh, not too old even

[21:03] <ash_> ah, thats pretty recent, i didn't know people were already distributing packages for it 

[21:03] <sorear> Improv: the parser engine rakudo uses doesn't implement longest-token-takes-precedence lexing very well yet

[21:03] <Improv> PerlJam: They've been dropping new versions into their yum repositories fairly often

[21:03] <PerlJam> redhat++ (for a change)

[21:04] <sorear> \w+( function call is supposed to take precedence over if syntax, always

[21:04] <sorear> Perl5 worked because elsif was a keyword in Perl5

[21:04] <Improv> masak: Not a lot of chance of that - I preferred parentheses in Perl5 fairly often when unnecessary - helps me read my code

[21:04] <masak> Improv: what sorear said. Perl 6 basically has no keywords.

[21:05] <sorear> Perl6 has no keywords and no distinct lexer; the language is specified using a regex

[21:05] <PerlJam> heh

[21:05] <sorear> this makes extending the Perl6 grammar much easier, since you can do it with regexes

[21:05] <masak> Improv: I do that too. but in the case of 'if' statements et al, I prefer to adhere to Perl 6 convention, which is definitely sans parens.

[21:05] <lue> afk

[21:05] <masak> sorear: and not only regexes, but OO regexes! o.O

[21:06] <masak> multi-dispatching inheriting LTM goodness!

[21:06] <Improv> masak: I'll consider it, although given that I am a firm believer in Whitesmiths coding style, I'll probably never fit into Perl6 convention entirely :)

[21:06] <PerlJam> if you read "the language is specified using a regex" and the only regex you've used are non-perl6 that will seem nigh impossible :)

[21:07] <ash_> rakudo: sub if { say 'got ya' }; if(2); 

[21:07] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Missing block at line 11, near ";"‚ê§¬ª

[21:07] <jnthn> ash_: OK, great. Will it allow general callbacks?

[21:07] <jnthn> ash_: 'cus before Parrot only allowed them with certain magic signatures

[21:07] <tylercurtis> PerlJam: which is why it's probably a bad idea to tell Perl 5 programmers that Perl 6's grammar is specified as a regex.

[21:07] <tylercurtis> It might scare them away.

[21:08] <ash_> not yet, with libffi i could allow any signature for callbacks, but for now (and until the end of the GSOC) i am not woking on callbacks just yet 

[21:08] <Improv> Perl5 programmers are not likely to be scared by regexen

[21:08] * PerlJam commute &

[21:09] <tylercurtis> Improv: Not even regexen complicated enough to parse Perl?

[21:09] <jnthn> ash_: OK

[21:09] <sorear> Perl5 programmers are likely to be scared away by the concept of a 4,000 line regex

[21:09] <jnthn> ash_: I think mberends++ would really like them. ;-)

[21:09] <Improv> tylercurtis: Love of regexen is a big part of why Perl5 programmers use perl

[21:09] <jnthn> ash_: Since it opens the way to GUI dev. ;-)

[21:09] *** Su-Shee left
[21:09] <sorear> Personally I'm scared by 1,000 1-line perl5 regexes

[21:10] <ash_> jnthn: ya, i want to get them working, but for now, i am busy enough with the other parts of my GSoC, but they are completely in the realm of possibility, I just don't have time yet to do them 

[21:10] <Improv> That, and being people who like being courted by Scheme and ObjC at the same time ;)

[21:11] * tylercurtis would probably have been terrified if he had realized that Perl 6 is parsed by a regex before learning about Perl 6 regexes.

[21:11] <ash_> sorear: thankfully grammars help that, hopefully one day you won't see 1,00 1-line regexs, just grammars 

[21:11] <tylercurtis> But then, I've not programmed much Perl 5.

[21:11] <Improv> tylercurtis: Did you do much with the /x modifier to regexen?

[21:12] <jnthn> ash_: OK, great.

[21:12] <Improv> If you have to do something very long, /x allowed you to use whitespace and comments in your regex, letting you break it apart and document it

[21:13] <jnthn> Improv: It's the default.

[21:13] <jnthn> ash_: out of interest, what was the other half of your grant beyond NCI?

[21:13] <jnthn> I remember reading it, but my memory is like a sieve. :-)

[21:13] <ash_> a runcore based on the llvm that compiles parrot bytecode into native code or JIT's it 

[21:14] <Improv> Thanks for the help all - I'll take a look at the Perl6 "book", and I'll look forward to that preview release too.

[21:14] <sorear> Google thinks it's possible to write a JIT for Parrot in 1.5 months?

[21:14] <tylercurtis> Improv: I've not done much Perl 5. And outside of rules(where whitespace is turned into \s+(or something similar), Perl 6's regexen allow whitespace by default.

[21:14] <sorear> That's crazy talk.

[21:15] *** Improv left
[21:15] <ash_> sorear: i am not writing the jit, the llvm already has one 

[21:15] <ash_> i just have to translate parrot byte code into llvm byte code, which is not as scary as it sonuds 

[21:15] <ash_> sounds* 

[21:16] <sorear> ash_: llvm provides a IR -> x86 JIT, you need to write a PBC -> IR JIT

[21:16] <sorear> yes that

[21:17] <jnthn> You oculd probably get a good start and a performance win by even being able to JIT branches and leaving everything else to be JITted as a function call to the op sub, mind.

[21:17] <jnthn> And slowly work from there.

[21:18] <sorear> How would just branches help?

[21:18] <sorear> (We are talking about branch_eq et al right?)

[21:18] <[particle]> sorear: google thinks tpf's mentors who voted on the proposal think it's worth funding the opportunity for a student to attempt the project

[21:18] <jnthn> sorear: The control flow is probably the only thing you can't easily just do as function calls.

[21:18] <sorear> phenny: ask TimToady What does sub &* {} mean?

[21:18] <phenny> sorear: I'll pass that on when TimToady is around.

[21:19] <jnthn> Well, maybe that's not totally true, but... :-)

[21:19] <jnthn> It's where I'd start, anyway.

[21:20] *** Schwern left
[21:24] <jnthn> std: sub &* {}

[21:24] <p6eval> std 31530: OUTPUT¬´ok 00:01 110m‚ê§¬ª

[21:24] <jnthn> ew

[21:24] <jnthn> rakudo: sub &* {}

[21:24] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Confused at line 11, near "sub &* {}"‚ê§¬ª

[21:24] <jnthn> So am I. ;)

[21:24] *** tadzik left
[21:27] <pmichaud> back again

[21:27] <jnthn> rakudo: role Foo { }; subset Bar of Foo where 42;

[21:27] <p6eval> rakudo 3d2cb8:  ( no output )

[21:27] <masak> rakudo: role R {}; subset S of R; 1 ~~ S

[21:27] <p6eval> rakudo 3d2cb8: OUTPUT¬´Null PMC access in invoke()‚ê§  in 'ACCEPTS' at line 1‚ê§  in 'infix:<~~>' at line 322:CORE.setting‚ê§  in main program body at line 11:/tmp/cQRWsJjdsN‚ê§¬ª

[21:29] *** ashleydev joined
[21:31] <dalek> rakudo: 4715825 | jonathan++ | src/builtins/List.pir:

[21:31] <dalek> rakudo: Support get_pmc_keyed_int in List so we can has interop with Perl 6 arrays and 

[21:31] <dalek> rakudo: NQP code.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4715825564cb2ba9be5358740e6f166e2a4d8227

[21:31] <dalek> rakudo: ac5e926 | jonathan++ | src/core/traits.pm:

[21:31] <dalek> rakudo: Implement trait_mod:<is> for rw on packages. Not checked for yet.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ac5e92627599694d16e8620499ffc78a536db338

[21:31] <dalek> rakudo: 085fac8 | jonathan++ | src/builtins/List.pir:

[21:31] <dalek> rakudo: Remove a fossil.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/085fac814e66b6a20649039515177e512c05c2af

[21:31] <dalek> rakudo: dbde7cf | jonathan++ | src/metamodel/ClassHOW.pir:

[21:31] <dalek> rakudo: Under-construction class type objects should at least be able to say they're 

[21:31] <dalek> rakudo: undefined.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/dbde7cfb23a7414c6774d117eb776f20ce6454d7

[21:31] <dalek> rakudo: 7dbad1c | jonathan++ | src/Perl6/ (3 files):

[21:31] <dalek> rakudo: Do not assume that lack of is rw on an attribute means no accessor, and 

[21:31] <dalek> rakudo: implement is readonly which always means that. This means we know when nothing 

[21:31] <dalek> rakudo: is specified, and to look to any provided default. Also, a little re-ordering of 

[21:31] <dalek> rakudo: metaclass code gen.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7dbad1c77b6d619e6f571f04b024c34d6bca016f

[21:31] <dalek> rakudo: fdf7bb9 | jonathan++ | src/metamodel/Attribute.nqp:

[21:31] <dalek> rakudo: If the attribute doesn't explicitly have rw or readonly specified, fall back and 

[21:31] <dalek> rakudo: ask the package if it has an interesting default.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fdf7bb948f83871029e41917de81fbed58738d4d

[21:31] <dalek> rakudo: f9e5226 | jonathan++ | src/metamodel/Attribute.nqp:

[21:31] <dalek> rakudo: Unbreak attribute introspection for .rw.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f9e5226f9cdfde5400578c8b5748c572b53dc8cb

[21:31] <dalek> rakudo: 7017d2b | jonathan++ | t/spectest.data:

[21:31] <dalek> rakudo: Turn on S12-class/rw.t.

[21:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7017d2b9ac93e14a5d9af88671563caa4b48cee7

[21:31] <saaki> golly

[21:31] <masak> jnthn++ # commit flood troll!

[21:35] <jnthn> And that's *before* I open a beer!

[21:36] <pmichaud> ooooh, one small fix and a lot of the failing tests are passing again.  :-)

[21:36] <pmichaud> ah, here are some failz

[21:40] *** Patterner left
[21:44] <colomon> woah, that's a lot of patches!

[21:45] *** constant left
[21:50] *** ciphertext joined
[21:50] *** ciphertext_ left
[21:50] *** Psyche^ joined
[21:50] *** Psyche^ is now known as Patterner

[21:52] *** meppl joined
[21:55] *** constant joined
[21:55] *** constant left
[21:55] *** constant joined
[21:59] *** cdarroch left
[22:01] *** Improv joined
[22:01] <Improv> Hey, are there nightly builds of the perl book?

[22:03] *** masonkramer left
[22:03] *** masonkramer joined
[22:04] *** Ross left
[22:05] <Improv> Turns out if I want to have Pod-PseudoPod-LaTeX 1.1x, I need a newer version of Module::Build and if I want that I need to remove Perl itself (yay horrible dependencies)

[22:05] *** Schwern joined
[22:05] <Improv> and I can't build the Perl6 book without that 1.1x version of Pod::PseudoPod::Latex

[22:06] <sorear> Don't use system package managers to install perl modules ever.

[22:06] <Improv> sorear: These were already installed.

[22:07] <Improv> I can't remove Module::Build without removing my Perl5

[22:07] <sorear> Don't remove Module::Build then

[22:07] <sorear> cpan -i Module::Build

[22:07] <Improv> Soooo just overwriting my old one?

[22:07] <sorear> cpan -i Pod::PseudoPod::LaTeX

[22:07] <sorear> no

[22:07] <sorear> cpan installs into /usr/local

[22:08] <tylercurtis> alternately, download one of the released versions of the book.

[22:08] <tylercurtis> http://github.com/perl6/book/downloads

[22:08] <sorear> shadowing your old one, as it were

[22:08] <Improv> That sounds much simpler.

[22:09] <Improv> Ahh, especially given that I get a LaTeX prompt when running make now.

[22:09] <tylercurtis> On a related note, are there still plans for a printed version for Rakudo *?

[22:10] <Improv> err.. a TeX prompt..

[22:11] <Improv> Thanks again. Bon soir.

[22:11] *** Improv left
[22:13] *** gbacon left
[22:16] <masak> tylercurtis: yes, I think so. I don't think the book is ready enough to ship in time for R*, though.

[22:16] *** alester left
[22:22] *** jeir joined
[22:23] *** jeir left
[22:25] <sorear> Niecza is now capable of end-to-end operation

[22:26] <sorear> start with Perl 6 code, run it through a subclass of STD with special glue-coding extensions, convert to niecza-ast with action methods, convert that to C#, compile, run

[22:26] <sorear> all that's left is features

[22:26] <dalek> niecza: 69dbc62 | sorear++ |  (5 files):

[22:26] <dalek> niecza: Implement subs in actions system

[22:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/69dbc62d99d00f57747bb52b0981f1ee5d62dfe5

[22:26] <dalek> niecza: 2f77be0 | sorear++ |  (2 files):

[22:26] <dalek> niecza: Switch Makefile to using the new parser!

[22:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2f77be04e3d8035aedc2f7d8a0334cebfeff8092

[22:27] *** javs left
[22:27] <masak> sorear: wow, cool!

[22:27] <jnthn> Nice :-)

[22:27] <masak> sorear: so, which features will you be focusing on?

[22:28] <sorear> next I'm going for the object system

[22:29] <sorear> 1. unbreak classes 2. implement methods 3. implement single inheritence 4. implement Any, Mu, and Cool

[22:29] <sorear> after that comes numerics (2+2), and control flow

[22:29] <sorear> I'm still behind yapsi in a couple ways...

[22:29] <masak> heh. with the current Yapsi development speed, we might see OO stuff in Yapsi this time next year :)

[22:30] <masak> Yapsi doesn't have 2 + 2 yet either.

[22:30] <masak> I'd love it for Yapsi to have a STD backend.

[22:30] <sorear> s/back/front/?

[22:30] <jnthn> Isn't STD more of a frontend?

[22:30] <tylercurtis> masak: You have if, though. And --.

[22:31] <masak> oh yes. frontend.

[22:31] * masak is so tired he's thinking backwards :)

[22:31] <masak> tylercurtis: the ++, -- and 'say' constructs are faked for now so that there's something to test. they will all be replaced when we have real subcalls.

[22:32] <pmichaud> jnthn: ping

[22:33] <jnthn> pmichaud: p0ng

[22:33] <tylercurtis> masak: I know. But it's something, nevertheless.

[22:34] <masak> tylercurtis: yes, I'm surprised it's come this far, actually. and the PR seems to work well, too :)

[22:34] <masak> 24 downloads in as many hours!

[22:34] <pmichaud> jnthn: can you help me understand the package-scoped code at Perl6/Actions.pm:1138 ?

[22:34] <jnthn> maybe ;-)

[22:34] * jnthn checks

[22:34] <pmichaud> specifically the multi part of it

[22:35] <sorear> masak: hah.  Right now, real subcalls are about /all/ niecza has

[22:35] <jnthn> pmichaud: Starting "# Otherwise, package scoped; add something to loadinit to install them." ?

[22:35] <pmichaud> yes.

[22:36] <sorear> incl. closures, protolexpads

[22:36] <sorear> but no signature binder yet.  you have to drop down into NIL to look at arguments

[22:36] <sorear> sub say { Q:NIL { =[0] @ unwrap:String .plaincall/1:Console.WriteLine null:Variable } }

[22:36] <jnthn> pmichaud: $symbol_holder is in this case holding the block of the package.

[22:37] <jnthn> It's just a PAST::Block

[22:37] <jnthn> pmichaud: We check if it's a multi-sub

[22:37] <jnthn> pmichaud: If it is, we need to tweak the code to add the candidates

[22:38] <jnthn> pmichaud: Essentially we compile to a chain of method calls to a Perl6MultiSub (that each return the P6MS itself) that each add some candidates

[22:38] <jnthn> Was just a neat way to do the code-gen.

[22:38] <tylercurtis> Aww. It turns out that the cperl-mode.el from the pugs repo doesn't actually properly handle Perl 6 POD.

[22:38] *** Patterner left
[22:38] *** eternaleye left
[22:38] *** proller left
[22:38] *** DemoFreak left
[22:38] *** araujo left
[22:38] <jnthn> pmichaud: That's the if $symbol_hoolder...chunk

[22:38] <jnthn> pmichaud: The rest is just installing the symbol

[22:38] *** rjbs joined
[22:39] <rjbs> What's the / twigil for?

[22:39] <tylercurtis> M-x fundamental-mode again I guess.

[22:39] <jnthn> Actually @PACKAGE[0].block is $symbol_holder here...

[22:39] <ash_> rjbs: you mean $/ ? 

[22:39] <jnthn> rjbs: Example? I don't think there is / twigil - do you mean $/

[22:40] <jnthn> In that case $/ is the match object

[22:40] <pmichaud> $past[0] gets special treatment if it's a multi?

[22:40] <jnthn> Right

[22:40] <masak> a / twigil would be awesome :)

[22:40] <jnthn> pmichaud: More specifically

[22:40] <jnthn> pmichaud: It gets special treatment if we already installed multis there

[22:40] <tylercurtis> masak: for what?

[22:40] <masak> tylercurtis: slashing, obviously :)

[22:40] <rjbs> I must mean $/

[22:40] *** dimid left
[22:40] *** Juerd left
[22:40] *** rjbs left
[22:40] *** sykes_ left
[22:40] *** Solarion left
[22:40] *** jnthn left
[22:40] *** buu left
[22:40] *** yves__ left
[22:41] *** m6locks joined
[22:41] *** phenny joined
[22:41] *** cxreg joined
[22:41] *** frodwith joined
[22:41] *** wolverian joined
[22:41] *** Woody2143 joined
[22:41] *** zachy joined
[22:41] *** lest_away joined
[22:41] *** ingy joined
[22:41] *** meteorjay joined
[22:41] *** araujo joined
[22:41] *** proller joined
[22:41] *** DemoFreak joined
[22:41] *** eternaleye joined
[22:41] *** Patterner joined
[22:41] *** rjbs joined
[22:41] *** dimid joined
[22:41] *** Juerd joined
[22:41] *** sykes_ joined
[22:41] *** Solarion joined
[22:41] *** jnthn joined
[22:41] *** buu joined
[22:41] *** yves__ joined
[22:41] *** farmer.freenode.net sets mode: +voo phenny ingy jnthn

[22:41] *** pmichaud_ joined
[22:41] <pmichaud_> jnthn: okay, here's the problem I'm facing.

[22:41] <pmichaud_> If we have:

[22:41] <jnthn> STD can also do that for you if you can get that running

[22:41] <rjbs> hanks!

[22:41] <rjbs> ^T

[22:41] <pmichaud_> package XYZ {

[22:42] <rjbs> I have Rakudo.

[22:42] <pmichaud_>     our sub abc() { ... }

[22:42] <pmichaud_> }

[22:42] <pmichaud_> we have to bind XYZ::&abc twice

[22:42] <pmichaud_> we bind it once at startup, as now

[22:42] <jnthn> &XYZ::abc ?

[22:42] <pmichaud_> we have to bind it again, when the package block executes

[22:42] <jnthn> Oh?

[22:42] <pmichaud_> Yes.

[22:43] <pmichaud_> at the beginning of the package block, all of the nested blocks get recaptured

[22:43] <jnthn> Rationale?

[22:43] <jnthn> Ah.

[22:43] <pmichaud_> and the existing &XYZ::abc will be pointing to the wrong block.

[22:43] <jnthn> Ah...I'm starting to see

[22:44] <pmichaud_> (this is also explicitly mentioned in S04, btw :)

[22:44] <jnthn> So we need to emit two things?

[22:44] <pmichaud_> yeah, something to create the code object at loadinit

[22:44] <pmichaud_> and something to create another one at the beginning of the package block

[22:44] <masak> pmichaud_: where in S04?

[22:44] <pmichaud_> both of them binding to &XYZ::abc when they're created

[22:44] <jnthn> OK

[22:45] <jnthn> Then push the smae thingy onto @BLOCK[0] too?

[22:45] <pmichaud_> yeah

[22:45] <pmichaud_> but I'm not sure how the multi case gets handled.

[22:45] <jnthn> Ah

[22:45] <jnthn> It'd...end up making two Perl6MultiSub objects if you just do that... :S

[22:45] <jnthn> That's perhaps OK though.

[22:46] <pmichaud_> at this point in the code, what exactly is $past ?

[22:46] <jnthn> pmichaud_: Line 1112 is important to understand this.

[22:46] <jnthn> pmichaud_: There's two cases. (more)

[22:47] <jnthn> 1) We never created a Perl6MultiSub. In this case we do what's done starting at 1112

[22:47] <pmichaud_> masak: key text surrounds "At run time, when such a subroutine is cloned, an additional binding is done at clone time to the same symbol table entry that the original was bound to."

[22:47] <rjbs> Aha, $/ is the retval of the last regex match.

[22:47] <masak> pmichaud_: ah, I think I remember that part. it's near the end.

[22:48] <jnthn> 2) We already made one, so we just add the current sub it to the existing PAST node and $past := 0; and then we do nothing later on.

[22:48] <pmichaud_> jnthn: that feels very ouchie.

[22:49] <Tene> I remember having trouble wrapping/replacing a sub from a trait handler a while back.  Not sure if it's relevant to what you're working on, though.  I was trying to implement "is cached".

[22:49] <jnthn> pmichaud_: How so?

[22:49] <pmichaud_> package XYZ {   our multi sub abc() { ... };   our sub def() {  our multi sub abc(Int $x) { ... } } }

[22:50] <jnthn> Yes, that case is exactly what 

[22:50] <jnthn> @BLOCK[0].symbol($name, :scope('package') );

[22:50] <jnthn> Exists to handle.

[22:50] <jnthn> oh dammit

[22:50] <jnthn> $past[0] := PAST::Var.new( :name($name), :scope('package'), :viviself($past[0]) );

[22:50] <jnthn> What ^^ exists to handle

[22:50] <jnthn> Basically, if we already installed a Perl6MultiSub, add the candidates from this block.

[22:51] <jnthn> Otherwise, auto-vivify a new Perl6MultiSub PMC.

[22:51] <jnthn> *vivify

[22:51] <pmichaud_> here's what I don't see.

[22:51] <pmichaud_> when something calls def(), I have to get a new &XYZ::abc

[22:52] <pmichaud_> since that's a Perl6MultiSub, I need to have the MultiSub replace that one element.

[22:52] *** rjbs left
[22:52] <jnthn> How's it meant to know which element?

[22:52] <jnthn> Is it even the same Parrot Sub?

[22:52] <pmichaud_> it's a clone of the Parrot Sub with a new outer context.

[22:53] <jnthn> So how would we link up what it already has with what's meant to replace it?

[22:53] <pmichaud_> it's okay if we rebuild the entire Perl6MultiSub PMC with the new set of subs

[22:53] <jnthn> Or if you're asking "is there an easy way to do that already" then simply, "no"

[22:53] <jnthn> OK, but how'd we know about the rest of them other than this one?

[22:54] <pmichaud_> well, that's what I was curious about here.

[22:54] <jnthn> I mean, I don't see how you can know which candidate you want to "replace"

[22:54] <jnthn> That feels...odd.

[22:54] <pmichaud_> but I can know the set of current candidates

[22:54] <pmichaud_> so I can build a new Perl6MultiSub PMC from that, I think.

[22:55] <jnthn> Yes, but how will you eliminate the one you're "replacing"?

[22:55] <jnthn> Or do you mean you statically known them?

[22:55] * jnthn is a bit confused

[22:55] <pmichaud_> I'm confused to, because I don't understand the MultiSub creation code here.

[22:55] <pmichaud_> *too

[22:56] <pmichaud_> but when we enter def(), we do a capture_lex on its inner abc candidate

[22:56] <jnthn> But capture_lex doesn't make it a different Parrot sub, no?

[22:56] <jnthn> It only changes its outer pointer?

[22:56] <pmichaud_> correct, it doesn't.

[22:56] <jnthn> So why does the Perl6MultiSub need updating?

[22:56] <pmichaud_> because the Perl6MultiSub references a Code object

[22:57] <pmichaud_> and that Code object contains a copy of the abc(Int) sub that was in existence at compile time.

[22:57] <jnthn> Right, which references the Parrot Sub which goet capture_lex'd?

[22:57] <pmichaud_> Code objects no long reference the actual parrot sub.  They have to reference copies.

[22:57] *** timbunce left
[22:57] <pmichaud_> *no longer

[22:57] <jnthn> OK, but why are they different Parrot Subs?

[22:57] <jnthn> Oh

[22:57] <jnthn> They *always* make a copy on creation?

[22:57] <pmichaud_> yes.

[22:57] <pmichaud_> that's really what Code.new() means.

[22:57] <jnthn> oh ouch

[22:57] <pmichaud_> it means "take a closure"

[22:57] <jnthn> OK, *now* I understand why you're finding this painful.

[22:58] <jnthn> I hadn't really appreciated that you'd changed that.

[22:58] <pmichaud_> yes, I started out by trying to copy Code objects, but then I realized "Wait.  Code.new() really means 'capture a closure'."

[22:58] <pmichaud_> it all works _great_ except for this one case.

[22:58] <jnthn> The current multi creation code doesn't really help you out here.

[22:59] <jnthn> It relies on the assumption that's now broken.

[22:59] *** pmichaud_ left
[22:59] <jnthn> ...was it something I said?

[22:59] <pmichaud> I'm still here -- that was my netsplit shadow.

[22:59] <jnthn> oh!

[22:59] <jnthn> I didn't think I'd been that offensive. ;-)

[23:00] <jnthn> Honestly though, I think we need to re-think the multi creation in light of this rather than trying to patch up what we have.

[23:01] *** Schwern left
[23:01] <jnthn> As for how to do this...

[23:01] <jnthn> First, a question. Do we *only* have problems with package-scoped multis?

[23:01] <jnthn> (lexically scoped ones work OK in the new model?)

[23:02] *** pmichaud1 joined
[23:02] <pmichaud1> argggggh

[23:03] *** Juerd left
[23:03] *** dalek left
[23:03] *** PerlJam left
[23:03] <jnthn> feather fail?

[23:03] <pmichaud1> yes, everything but package-scoped subs seems to work.

[23:03] <pmichaud1> yes, feather fail.

[23:03] <jnthn> OK

[23:03] *** pmichaud left
[23:04] <jnthn> pmichaud1: Do you have any way at all to know that two Parrot subs today originally were cloned from the same Parrot sub?

[23:04] *** hugme left
[23:04] <pmichaud1> I can certainly put one in place.

[23:04] <jnthn> The real tricky thing here is that we can't just re-build the multi.

[23:04] *** Util left
[23:04] *** pugssvn left
[23:04] <jnthn> Because we need to update *part* of it.

[23:04] <jnthn> e.g. some of the subs

[23:05] <jnthn> And without having a unique way to identify them, that's kinda hard.

[23:05] <pmichaud1> if the multi knew all of the (original) Parrot subs that were used to create it, could it rebuild from that?

[23:05] <jnthn> Only if it can link them back to the things it has now

[23:05] <jnthn> Something feels very messy here though.

[23:05] <pmichaud1> oh

[23:05] <pmichaud1> I think I know the answer.

[23:06] <pmichaud1> actually, I'm certain this is wrong, but it might work for now.

[23:06] <jnthn> I mean, we can probably find a way to pick through the candidates and swap out some of them

[23:06] <jnthn> But...ew. :-)

[23:06] <pmichaud1> I don't understand "link them back to the things it has now"

[23:06] <pmichaud1> you mean to the code objects it has now?

[23:06] <jnthn> pmichaud1: Are you envisioning that we already ahve a Perl6MultiSub set up and we want to update some of the Code objects in it?

[23:07] <jnthn> That is, some of its candidates?

[23:07] <jnthn> With the capture_lex'd ones we have at the moment?

[23:07] <pmichaud1> let's back up a second

[23:08] <pmichaud1> let's say that I have

[23:08] <jnthn> That's probably a good idea. :-)

[23:08] <pmichaud1> my $x = &multi_sub;

[23:09] <pmichaud1> and then a bit later I invoke XYZ::def, which causes a new &multisub candidate to appear (i.e., it has to replace one of the originals)

[23:09] <pmichaud1> I'm pretty sure that $x has to continue to refer to the old set.

[23:09] <pmichaud1> which means that the symbol &multisub has to be bound to a new Perl6MultiSub object.

[23:10] <pmichaud1> we get at that behavior one of two ways

[23:11] <pmichaud1> either we recognize whenever &multisub is being used in an rvalue context, and take a clone of it then

[23:11] <pmichaud1> or we have &multisub be rebound to a new set whenever one of its candidates change

[23:11] <pmichaud1> *changes

[23:11] <pmichaud1> (more)

[23:12] <pmichaud1> so far, we've been fairly successfully avoiding the "copy on rvalue/assignment" behavior for nearly everything

[23:12] <pmichaud1> i.e., assignment simply involves changing a pointer to an immutable value

[23:14] <jnthn> (sorry, masak and I were distracted translating beer cans...reading :-))

[23:14] <pmichaud1> and what I have now will work fine with package-scoped subs as well

[23:14] <pmichaud1> i.e.,  if I have   my $y = &package_sub;

[23:14] <pmichaud1> and then later we invoke a scope that rebinds &package_sub,   $y still successfully captures the old closure.

[23:15] <jnthn> Yes

[23:15] <jnthn> But will the re-binding find all the candidates?

[23:15] <jnthn> I guess yes, it can.

[23:15] <pmichaud1> let me look at the code a second further

[23:15] <jnthn> *nod*

[23:15] <pmichaud1> I really think I need to understand the chain

[23:15] <jnthn> OK

[23:15] <jnthn> Let me try and be a bit clearer

[23:16] <jnthn> There are really 3 cases

[23:16] <jnthn> 1) We never encountered a multi in this package anywhere yet. In this case we need a new Perl6MultiSub.

[23:17] <jnthn> 2) We have encountered it, but not in this block - maybe due to package augmentation introducing new subs. We bundle the candidates together for this block, but then add them to the existing candidate. This what the lookup handles with that PAST::Var (and the vivify handles case 1).

[23:17] *** dalek joined
[23:17] *** pugssvn joined
[23:18] <jnthn> 3) We've encountred other multi candidates in the package block we're compiling, so we just add them to the existing PAST node, which we stuck in .symbol

[23:18] <jnthn> Those are the three cases. 

[23:18] <jnthn> Note when I say "in this block" I mean the package block.

[23:18] <jnthn> The other "fun" we hit is

[23:19] <jnthn> package foo { multi x() { }; }; augment package foo { multi x($y) { } };

[23:19] <jnthn> That's what (2) is

[23:20] *** dalek left
[23:20] <pmichaud1> ..and that's what 

[23:20] <pmichaud1>                     $past[0] := PAST::Var.new( :name($name), :scope('package'), :viviself($past[0]) );

[23:20] <pmichaud1> handles?

[23:20] <jnthn> Precisely.

[23:20] *** Util joined
[23:21] <jnthn> $past[0] holds a PAST node that instnantiates Perl6MultiSub

[23:21] <pmichaud1> I understand that this converts $past[0] into a package-scoped variable lookup

[23:21] *** dalek joined
[23:21] <pmichaud1> I don't see where it's previous value gets joined with the existing MultiSub

[23:21] <jnthn> :viviself($past[0])

[23:21] <jnthn> Oh

[23:21] <pmichaud1> if there's an existing MultiSub, the :viviself doesn't get used.

[23:21] *** PerlJam joined
[23:21] <jnthn>                 $past := PAST::Op.new(

[23:21] <jnthn>                     :pasttype('callmethod'),

[23:21] <jnthn>                     :name('set_candidates'),

[23:21] <jnthn>                     PAST::Op.new( :inline('    %r = new ["Perl6MultiSub"]') ),

[23:22] <jnthn>                     $past

[23:22] <jnthn>                 );

[23:22] <jnthn> set_candidates actually adds to the existing candidate set.

[23:22] <jnthn> Rather than replaces it.

[23:22] <jnthn> So if it finds a Perl6MultiSub that already has candidates, it will add these candidates to it.

[23:22] <pmichaud1> ah, and this is why rebuilding is problematic.

[23:22] <jnthn> Right.

[23:23] <pmichaud1> okay, the problem becomes simple then.

[23:23] <jnthn> Thus why I think we need to re-think this a bit.

[23:23] <jnthn> Just keep in mind that the augment case also has to be handled too.

[23:23] <pmichaud1> no problem.

[23:23] <jnthn> OK

[23:23] <pmichaud1> the key to finding subroutine uniqueness is :subid

[23:23] *** bjarneh left
[23:23] <jnthn> Do we has that at runtime?

[23:23] <jnthn> (I forget.)

[23:24] <jnthn> If so then yes, it's easy.

[23:24] <pmichaud1> so we modify set_candidates (which is really "add_candidates") so that it replaces any entity that has the same subid as whatever we're adding.

[23:24] *** bjarneh joined
[23:24] <pmichaud1> Yes, subid is a property of the Sub.

[23:24] <pmichaud1> and clones have the same subid.

[23:24] <jnthn> Then it's easy.

[23:24] *** bjarneh left
[23:24] <pmichaud1> (this is how phasers work, btw, to make sure that we don't re-execute the same phaser more than once)

[23:25] <jnthn> OK

[23:26] <pmichaud1> ...but even better than replacing

[23:26] <pmichaud1> we can make MultiSub "immutable"

[23:26] <jnthn> And it makes a new one.

[23:26] <pmichaud1> so that set_candidates returns a new MultiSub with the changes

[23:26] <pmichaud1> right.

[23:26] <jnthn> wfm

[23:26] <pmichaud1> I don't know if it's worth looking into, but I suspect it also means we could eliminate a lot of multi-construction code in the compiler.

[23:27] <jnthn> Possibly

[23:27] <pmichaud1> i.e., we wouldn't need to keep track of $symbol<multis>

[23:27] <pmichaud1> whenever we encounter a new multi, we just call the add_candidate method and rebind.

[23:27] <jnthn> It's worth doing that bit just for generating better code, imo

[23:27] <pmichaud1> "better code" in the sense of "less runtime expense"?

[23:27] <jnthn> Right

[23:27] <jnthn> And shorter

[23:28] <pmichaud1> but this would also eliminate the augment problem.  :-)

[23:28] <jnthn> We don't have one today afaik. ;-)

[23:28] <pmichaud1> so maybe we do it within a block, but don't worry so much about the case of across blocks

[23:28] <jnthn> Right

[23:28] <jnthn> Oh, we don't try that today

[23:28] <jnthn> Well, we try within a package

[23:29] <jnthn> But not over augmented ones

[23:29] <jnthn> Anyway, I think we know the way forward.

[23:29] <pmichaud1> correct.  I think I can get it from here.

[23:30] <jnthn> OK

[23:30] <jnthn> The Perl6MultiSub hacking should be simple

[23:30] <pmichaud1> ...and this will mean that things like   my $x = &multisub;  will work properly too :-)

[23:30] <jnthn> There's some really fun code in there but none of it is what you have to change. ;-)

[23:31] <jnthn> Yes, seems win all around. Hopefully. :-)

[23:32] <pmichaud1> this model of closure handling is sooooo much cleaner than anything we've had previously.

[23:32] <jnthn> :D

[23:35] *** azert0x left
[23:35] <sorear> BEGIN { %foo{now} } := 2;  # What should I do in response to this?

[23:35] *** Juerd joined
[23:36] <jnthn> weep

[23:37] <pmichaud1> jnthn: I might need to switch the $symbol_holder to be block-scoped instead of package-scoped (just like lexicals)

[23:37] *** ashleydev left
[23:37] <pugssvn> r31531 | jnthn++ | [t/spec] Bring a spectest in line with latest method scoping spec. 

[23:37] <jnthn> pmichaud1: OK

[23:37] <jnthn> pmichaud1: If you're doing that just kill symbol_holder

[23:37] <pmichaud1> it will simplify things a lot, and I don't think there's a huge win to be had worrying about 'our multis'  nested below the package scope

[23:37] <jnthn> since it'll always be the smae thing.

[23:38] <jnthn> pmichaud1: Yes, in most cases they're in the same block.

[23:39] <pmichaud1> If we try to do it across the package, then I have to manage the creation of Code objects (which is currently block scoped, to correspond with closure creation)

[23:39] <pmichaud1> so it's easier to manage the multis across the block as well.

[23:39] <pmichaud1> s/across/within/

[23:40] <pmichaud1> afk, dinner

[23:40] <jnthn> *nod*

[23:46] *** ashleydev joined
[23:54] *** Psyche^ joined
[23:58] *** Patterner left
[23:58] *** Psyche^ is now known as Patterner

[23:58] *** masak left
