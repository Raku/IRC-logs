[00:00] *** nihiliad left
[00:00] *** fridim_ left
[00:09] *** pmurias left
[00:19] *** jferrero left
[00:21] *** payload joined
[00:25] *** rgrau left
[00:33] *** drbean joined
[00:34] *** uniejo joined
[00:44] *** ShaneC left
[00:46] *** ShaneC joined
[00:47] *** ihrd joined
[00:47] *** ihrd left
[00:48] *** pnate left
[00:58] *** patspam joined
[01:04] *** cognominal left
[01:05] *** yinyin joined
[01:06] *** cognominal joined
[01:08] *** Chillance left
[01:11] *** dugg left
[01:11] *** justatheory left
[01:21] *** mssm left
[01:23] *** [particle] joined
[01:34] *** meppl left
[01:41] <lichtkind> good night

[01:42] *** lichtkind left
[01:45] *** hercynium left
[01:47] *** justatheory joined
[01:47] *** lestrrat is now known as lest_away

[01:49] *** justatheory left
[01:50] *** cdarroch left
[01:55] *** sjn left
[01:56] *** uniejo left
[01:57] *** nihiliad joined
[02:02] *** sjn joined
[02:10] *** fcahoon joined
[02:10] *** cognominal left
[02:11] *** cognominal joined
[02:14] *** ash_ joined
[02:23] *** agentzh joined
[02:42] *** lest_away is now known as lestrrat

[02:46] *** fcahoon left
[02:48] *** colomon left
[02:49] *** lestrrat is now known as lest_away

[02:55] *** lest_away is now known as lestrrat

[03:01] *** ShaneC left
[03:02] *** colomon joined
[03:15] *** agentzh left
[03:18] *** dalek left
[03:23] *** dalek joined
[03:27] <colomon> github done?

[03:28] <colomon> *down

[03:33] <diakopter> oh?

[03:34] *** dalek left
[03:36] *** cxreg left
[03:36] *** cxreg joined
[03:38] <colomon> I haven't been able to pull or see the commit list on the web for ten minutes now.

[03:39] <colomon> oh hey, that worked last time.

[03:39] *** dalek joined
[03:39] <colomon> and there are commits since I last checked, too.  \o/

[03:41] *** sjohnson sets mode: +oo diakopter colomon

[03:44] *** jaldhar joined
[03:45] <colomon> jnthn++  # ng1 over 3000 tests running again.

[03:48] * colomon is wondering if we should have Seq.reverse which returns a lazy list, and Iterator.reverse which returns a Seq...

[03:51] <sjohnson> colomon: hi

[03:52] <colomon> 'ello

[03:52] <sjohnson> how's it going?

[03:52] <colomon> pretty good.  about ready for bed here.

[03:53] <colomon> lots of changes to ng1 one today!

[03:53] <colomon> how're you doing?

[03:54] <sjohnson> pretty good

[03:54] <sjohnson> really stoked about perl

[03:54] <sjohnson> makes my life at work so much easier

[03:54] <sjohnson> i wish i had learned it 10 years ago

[03:54] <sjohnson> been using perl for 2 years

[03:54] <colomon> It has frequently been a life-saver for me over the years.

[03:54] <sjohnson> it's the WD-40 of programming languages

[03:55] <sjohnson> over 2000 uses!

[03:55] <colomon> :)

[03:57] <eternaleye> colomon: The only way I can think of for that not to be the case (re Seq and Iterator reversing) is if Iterator has a '.end' method, returning a bindirectional iterator already at the end of the lazy list

[03:57] <eternaleye> *bidirectional

[03:57] <eternaleye> Which has .succ and .pred swapped

[03:58] *** k23z__ left
[03:58] <colomon> eternaleye: I don't think we have any framework for that yet, but it's a nice idea.

[03:59] <colomon> Right now reverse takes an Iterator and builds an array, adding each new element from the Iterator to the front of the array.

[03:59] <eternaleye> The problem is that it only works on non-infinite lists - the ones that are infinite, which are the primary ue case, have an unknown end

[04:00] <eternaleye> The Iterator.reverse -> Seq is more general

[04:00] <colomon> how can you possibly reverse a generic infinite list?

[04:01] <colomon> oh, wait, think I read you wrong there.

[04:01] <pugs_svn> r29637 | lwall++ | [CORE] catch up with some name changes 

[04:01] <eternaleye> colomon: You can't, Im thinking more like my @foo = (1, 2, bar(), 7).reverse, because bar() is assumed to be an infinite list for the purposes of laziness

[04:04] <colomon> I think we're talking past each other a bit here.  (Or at least, I'm confused.)

[04:05] <colomon> If you have a list, you have to step through all of its values to reverse it.  In which case you have to do something equivalent to creating an Array.  (I mean, I guess you could do it on the stack, but that would be ugly ugly ugly.)

[04:05] <colomon> That's our current .reverse method.

[04:08] <colomon> What I was pondering was that it might be useful to also support reversing a Seq by gathering its elements in reverse.  Because you can't reverse a Seq without instantiating all of its values, and once you realize you've got to do that you can use elems and just read off the Seq backwards.

[04:13] *** eternaleye left
[04:15] <lisppaste3> colomon pasted "Suggested approach to Seq.reverse" at http://paste.lisp.org/display/94333

[04:18] * colomon is off to bed...

[04:19] <sjohnson> cya

[04:20] *** eternaleye joined
[04:22] *** sundar joined
[04:22] <eternaleye> colomon: Yes. I thought of an optimization of Iterator.reverse where each iterator caches its endpoint, to be returned from .reverse. I then realized that Perl 6 only creates iterators where lists are explicitly lazy or infinite, and infinite lists have no endpoint to cache.

[04:24] *** LaVolta joined
[04:33] *** bob__ joined
[04:33] <bob__> hi

[04:34] <bob__> any1 there?

[04:34] *** bob__ left
[04:37] *** perlman25 joined
[04:37] <perlman25> helllo is any1 there?

[04:38] <perlman25> i have a perl 6 snowman here

[04:38] <perlman25> use v6;     my $height = @*ARGS[0] // 31;  my $width = $height;  my $max_iterations = 50;     my $upper-right = -2 + (5/4)i;  my $lower-left = 1/2 - (5/4)i;     sub mandel(Complex $c) {      my $z = 0i;      for ^$max_iterations {          $z = $z * $z + $c;          return 1 if ($z.abs > 2);      }      return 0;  }     sub subdivide($low, $high, $count) {      (^$count).map({ $low + ($_ / ($count - 1)) * ($high - $low) });  }  

[04:39] *** perlman25 left
[04:40] <spinclad> yes, i've seen that.  you say it's yours?

[04:41] <spinclad> loses a bit in line-length limiting.

[04:42] <spinclad> *ircline-length limiting

[04:42] *** alester joined
[04:46] *** ash_ left
[04:51] *** alester left
[04:51] *** ihrd1 joined
[04:56] *** nihiliad left
[04:59] *** drbean left
[05:00] *** ihrd1 left
[05:07] *** cognominal left
[05:27] *** stephenlb left
[06:38] *** REPLeffect left
[06:40] *** REPLeffect joined
[07:13] *** Su-Shee joined
[07:16] <Su-Shee> good morning

[07:24] *** REPLeffect left
[07:25] *** REPLeffect joined
[07:38] *** Baggiokwok joined
[07:46] *** LaVolta left
[07:59] *** kaare joined
[08:00] *** drbean joined
[08:00] *** kaare is now known as Guest46644

[08:01] *** dual left
[08:03] *** jferrero joined
[08:08] *** dual joined
[08:08] *** Baggiokwok left
[08:32] *** agentzh joined
[08:39] *** mssm joined
[08:39] *** agentzh left
[08:41] <moritz_> good morning

[08:50] *** payload left
[08:52] <mathw> Good morning moritz_

[09:01] *** tuxdna left
[09:03] *** payload joined
[09:04] *** payload left
[09:04] *** payload1 joined
[09:06] *** payload1 left
[09:06] *** payload joined
[09:08] *** szabgab left
[09:08] *** riffraff joined
[09:18] *** tuxdna joined
[09:32] *** quester joined
[09:33] *** agentzh joined
[09:36] *** eternaleye left
[09:42] *** dr_df0 joined
[09:43] *** drbean left
[09:44] *** eternaleye joined
[09:50] *** payload left
[09:58] *** yinyin left
[10:19] <jnthn> oh morning

[10:19] *** fridim_ joined
[10:20] *** payload joined
[10:20] <mathw> oh hai jnthn

[10:23] * jnthn has a couple of errands this morning and Slovak class this afternoon, but is pretty confident he'll have Perl 6 time later on in the day. o/

[10:26] <mathw> \o/

[10:26] <mathw> and Slovak class is important

[10:27] * moritz_ is glad that jnthn++ comes to the hackathon in Copenhangen, and hopes that pmichaud++ does that too

[10:28] <mathw> That does look like fun

[10:30] <arnsholt> When is the Copenhagen thing again?

[10:30] <moritz_> first weekend in March, iirc

[10:30] <jnthn> Yes.

[10:30] <jnthn> moritz_: You are going to be there, yes?

[10:31] <jnthn> oh, yes, the email said so...

[10:31] * jnthn pours more coffee down his throat

[10:39] *** dakkar joined
[10:40] *** cosimo left
[10:40] *** cosimo joined
[11:00] *** masak joined
[11:00] <masak> oh hai, #perl6.

[11:04] *** frettled sets mode: +o masak

[11:04] *** frettled sets mode: +o arnsholt

[11:04] <frettled> good noon

[11:14] <arnsholt> 'lo

[11:15] *** dr_df0 left
[11:18] *** lestrrat is now known as lest_away

[11:19] *** drbean joined
[11:19] *** dr_df0 joined
[11:20] *** agentzh left
[11:21] *** macae joined
[11:22] *** payload left
[11:24] *** dr_df0 left
[11:44] <colomon> o/

[11:45] *** xinming_ left
[11:46] *** xinming joined
[11:50] *** tuxdna left
[11:50] <masak> we have a winner of 1 Internet already: http://lastofthecarelessmen.blogspot.com/2010/02/binary-tree.html

[11:51] * masak is always confused as to what to call lastofthecarelessmen on IRC

[11:52] <masak> I'm not focused enough yet to help debug the problems in that code. maybe later today.

[11:52] * jnthn back from @morning-errand

[11:52] <masak> jnthn: \o

[11:52] <jnthn> masak: Hi! :-)

[11:53] <masak> however, the '%mode<LEFT> = Hash' is an idiom I've never seem before. not sure you can do that.

[11:53] <colomon> masak: Don't think that's the complete script from E02.  Maybe half an internet?  :)

[11:53] <jnthn> Taht looks odd.

[11:53] <jnthn> That's sticking the Hash type object into the hash.

[11:53] <masak> colomon: agreed. half an internet. the half with all the lolcats. :)

[11:53] <jnthn> Which you can do I guess, but I doubt it's quite what's wanted.

[11:53] <masak> jnthn: 'xactly.

[11:53] <colomon> Hash is an undefined object of type Hash, right?

[11:54] <moritz_> right

[11:54] <jnthn> masak: We're withholding the one with all the FAILs until there's a full solution? :-)

[11:54] <masak> jnthn: I think that's only fair :)

[11:54] *** lest_away is now known as lestrrat

[11:54] <colomon> original code uses undef there...

[11:55] <colomon> must be his attempt to do a modern perl 6 equivalent.

[11:55] <jnthn> Oh. Well, a proto-object in a sense is just a typed undef.

[11:56] * moritz_ likes it

[11:57] *** tuxdna joined
[11:57] <masak> I think I'd put a well-named sentinel object in that place.

[11:57] <masak> NOTHINGHERE

[11:57] <masak> THESEARENOTTHENODESYOU'RELOOKINGFOR

[11:58] <colomon> But for the recursive tree structure to work, doesn't it has to be typed Hash?

[11:59] <moritz_> depends on how you do the recursion

[11:59] <moritz_> you can also just don't insert anything

[11:59] <moritz_> if the algorithms work appropriately

[11:59] <colomon> sure.

[11:59] *** dr_df0 joined
[12:08] *** SmokeMachine joined
[12:08] *** dr_df0 left
[12:10] *** dr_df0 joined
[12:13] *** payload joined
[12:17] *** meteorjay joined
[12:22] *** Baggiokwok joined
[12:22] *** xomas left
[12:23] *** bluescreen joined
[12:25] *** bluescreen left
[12:25] *** bluescreen joined
[12:26] *** xomas_ joined
[12:26] *** xomas_ left
[12:26] *** xomas_ joined
[12:27] *** payload left
[12:27] *** payload joined
[12:31] *** payload left
[12:32] *** Baggiokwok left
[12:38] *** quester left
[12:52] *** xomas_ is now known as xomas

[12:54] *** orafu left
[12:55] *** orafu joined
[12:57] *** Baggiokwok joined
[13:04] *** Baggiokwok left
[13:08] *** ignacio_ joined
[13:09] *** patspam left
[13:09] <takadonet> morning all

[13:12] <masak> good morning to you, takadonet.

[13:12] <takadonet> masak: how are you doing?

[13:13] <masak> takadonet: I'm in a warm, well-lit room, my belly is full of lunch, I'm writing Perl 6 and I don't have a worry in the world. pretty good. :)

[13:13] <masak> takadonet: and you?

[13:14] <mathw> masak

[13:14] <mathw> I hate you :P

[13:14] <masak> :)

[13:15] <masak> mathw: you're probably making more money than I am, too. :P

[13:15] <mathw> yeah probably

[13:15] <masak> mathw: I'm only working 50% so that I can spend more time on things like Perl 6.

[13:15] <mathw> but I bet you're not having to deal with colleagues trampling all over your code

[13:16] <masak> mathw: no, but that's just because I've put fear in them by making them think my code is really good. :)

[13:16] <masak> they wouldn't dare trample all over it.

[13:16] <takadonet> masak: Good, going to be teaching perl and bioperl to a new co worker in a hour and then back to working on my huge perl 5 project

[13:17] <masak> takadonet: sounds agreeable.

[13:17] *** ejs joined
[13:18] <mathw> Sounds agreeable indeed

[13:18] <mathw> I just polished off some work, so I'm feeling good about that

[13:18] <mathw> Despite some lingering irritation

[13:18] <takadonet> masak: I love working on this project even if there is over half a million lines of Perl 5 code

[13:18] <mathw> And I am probably going to spend the afternoon looking at dtrace-related things

[13:18] <mathw> Which will be a nice change

[13:19] <mathw> takadonet: wow, that's big

[13:19] <takadonet> mathw: My group is modifying this: http://www.cebitec.uni-bielefeld.de/groups/brf/software/gendb_info/wiki.html 

[13:34] <masak> rakudo: sub foo(%a) {}; foo(Mu)

[13:34] <p6eval> rakudo 1d4928: OUTPUT«'a' is not a valid sprintf format␤in Main (file <unknown>, line <unknown>)␤»

[13:34] <moritz_> wow

[13:34] <colomon> :)

[13:35] <masak> rakudo: sub foo(%a) {}; foo(Object)

[13:35] <p6eval> rakudo 1d4928: OUTPUT«'a' is not a valid sprintf format␤in Main (file <unknown>, line <unknown>)␤»

[13:35] * masak submits rakudobug

[13:36] <masak> it looks vaguely familiar, but I'm not sure I've reported it before...

[13:37] <masak> rakudo: sub foo(%a) {}; foo(Array)

[13:37] <p6eval> rakudo 1d4928: OUTPUT«'a' is not a valid sprintf format␤in Main (file <unknown>, line <unknown>)␤»

[13:37] <masak> rakudo: sub foo(%a) {}; foo(Hash)

[13:37] <p6eval> rakudo 1d4928:  ( no output )

[13:38] <jnthn> rakudo: sub foo(%d) {}; foo(Hash)

[13:38] <p6eval> rakudo 1d4928:  ( no output )

[13:39] <jnthn> Bad jnthn, no cookie.

[13:39] <masak> rakudo: sub foo(%s) {}; foo(Array)

[13:39] * jnthn -> Slovak, will patch that later. <embarassed look>

[13:39] <p6eval> rakudo 1d4928:  ( no output )

[13:39] <masak> hahah!

[13:39] * masak half-understands the problem

[13:43] <colomon> wait, is the problem that the error message tries to include %a in it?

[13:44] <masak> yep.

[13:44] <masak> and it sends that string to a sprintf call.

[13:44] <colomon> cute

[13:44] <moritz_> so it interpolates someting into an sprintf format? :-)

[13:44] <masak> SF++ has a more finished bintree version now: http://lastofthecarelessmen.blogspot.com/2010/02/binary-tree-almost-complete-script.html

[13:45] <masak> I also wrote one, and it works: http://gist.github.com/294621

[13:45] <masak> maybe I'll do a writeup on mine, as well.

[13:45] <masak> SF's version is closer to the E02 one. mine takes a few liberties.

[13:46] <masak> I think I aimed for (my version of) Perl 6 idiomaticity.

[13:51] <mathw> that kind of experimentation is valuable

[13:51] <mathw> since we're still trying to figure out what the Perl 6 idioms are

[13:51] <colomon> masak++ # fixing the bits SF left off

[13:51] <masak> I understand now what SF did with Hash.

[13:51] <masak> colomon: actually, I started from scratch. haven't looked much at SF's code yet.

[13:51] <masak> it'll be interesting to do a comparison.

[13:52] <masak> I'm especially glad I got the trait working. I didn't think I would be able to.

[13:52] * masak looks at SF's code

[13:52] <colomon> I think SF's version of the initial insert is nicer than yours.  And you've got the found and prompt stuff, which he left off altogether.

[13:52] <masak> ah, he didn't get traits working yet. :)

[13:52] <mathw> I spent a little time playing with traits when they were first implemented in Rakudo, they're pretty straightforward I thought

[13:53] <colomon> masak: you seem to have wandered further from the original with "show", but I like your version better.

[13:53] <masak> colomon: our versions of &insert are almost identical.

[13:53] *** ignacio_ left
[13:54] <masak> colomon: yeah, the E02 version of &show was silly. it would have written the numbers together.

[13:54] <masak> .perl is much nicer. and gather/take falls out as a consequence.

[13:55] *** Lorn left
[13:55] <masak> oh right, and I really didn't want to use statement-modifying if and unless the way E02 did it in &show. PBP even advises against that.

[13:56] <masak> sure, it makes for less repetition, but it also makes the code tougher to reason about.

[13:56] *** Lorn joined
[13:56] *** wanradt joined
[13:57] <colomon> masak: oooo, I hadn't noticed the gather / take -ness of show.  But in that case, it shouldn't be show anymore, should it?

[13:57] *** ignacio_ joined
[13:57] <masak> perhaps not.

[13:57] <masak> there is some prior art to calling 'stringify' 'show'. :)

[13:57] <masak> Haskell does it, for example.

[13:58] <colomon> What you've actually done is implemented a slightly screwy iterator for the binary tree.

[13:58] <masak> aye.

[13:58] <masak> I have a slight aversion to subroutines that print stuff rather than returning the stuff in question as a value.

[13:59] <colomon> ooo, makes me wish ng1 were working a bit better.  what a fine implementation you could do there!

[13:59] <masak> heh :)

[14:00] <masak> SF++'s use of .pick(20) is more idiomatic than mine. I didn't think of that.

[14:00] <masak> I see SF also settled on making $root into %root. :)

[14:01] <colomon> you make the tree a class, and then you implement .list(Traversal $method = in-order), which does a gather and then calls your show function.

[14:01] <masak> but he's fairly inconsistent between $tree, Hash $tree and %tree in the subroutine parameters.

[14:01] *** payload joined
[14:01] *** drbean left
[14:02] <masak> both SF and I hit on the 'enum' idea. it was quite obvious, I guess.

[14:02] <colomon> the original is just plain silly there.

[14:02] <masak> it was before enums existed.

[14:02] <masak> things get silly without them. :)

[14:02] <colomon> it should have been enough reason to invent them.  :)

[14:03] *** jferrero left
[14:03] <masak> SF: no, $ARGS prompts('Search? ') is definitely dead. note that there is an implicit 'is' there, and that implicitness is also dead. TimToady conjectures in E02 that it'd be $ARGS.prompt or something like that. but I don't think that's in the spec.

[14:05] <masak> SF: yeah, a class would perhaps be the next logical step both for your code and mine.

[14:13] <colomon> masak: you'd better blog your version.  :)

[14:13] <masak> colomon: I'm on it. :)

[14:13] * colomon keeps on thinking he should start a blog on wordpress, given how smoothly things went for the Advent calendar...

[14:14] <masak> colomon: give it a provocative name, like "The Revenge of Perl 6"

[14:14] <moritz_> Perl 6 Strikes Back

[14:14] <masak> or "Perl 6 can has your cookie, and eat it, too!"

[14:14] <masak> s/hash/haz/

[14:15] <masak> erm. :/

[14:15] <Juerd> s/eat/eats/

[14:15] <masak> thx.

[14:15] <Juerd> s/your/ur/

[14:15] *** pmurias joined
[14:16] <colomon> Perl 6: Ultimate Power

[14:17] <masak> that's not provocative, that's just hubristic :)

[14:17] <masak> Perl 6: Ultimate Power to Destroy You and Your Dog

[14:18] <Juerd> Perl 6: Our Perl is better than yours

[14:18] <masak> haha

[14:18] <Juerd> *That's* provocative

[14:18] <masak> Perl 6: Don't tell the Perl 5 Guys, But We're 1000% Better

[14:19] <Juerd> Perl 6: No matter what they say, 6 > 5

[14:19] <masak> Juerd: you're good at this!

[14:20] <Juerd> Just take everything from the "Perl 6 is not going to replace Perl 5"-theory and invert it

[14:20] <masak> Perl 6: Is Going To Replace Perl 5

[14:20] <masak> you're right!

[14:20] <masak> wow.

[14:20] <Juerd> Perl 6: One Perl to rule them all

[14:21] <masak> I feel bad for laughing at each of these.

[14:21] <Juerd> Hehe

[14:21] <Juerd> I still have that t-shirt, s:g/5/6/, but I can't wear it anymore :P

[14:21] <masak> :)

[14:22] <masak> Perl 6: The Next Version of Perl 5, Which Is, Like, So Old Now

[14:23] *** cognominal joined
[14:23] <moritz_> Perl 6: Removing the Technical Debt from Perl

[14:23] <masak> Perl 6: Perl 5, Done Right

[14:24] *** Woody2143 left
[14:24] *** he_ left
[14:24] <Juerd> Perl 6: The Perl is dead, long live the Perl

[14:24] <[particle]> Perl 6: Perl 6, Not Done

[14:25] <Juerd> [particle]: :)

[14:25] *** moritz_ sets mode: +oo Juerd [particle]

[14:25] <Juerd> Perl 6: EMWTDI

[14:26] <masak> Perl 6: It's Been, What, 10 years?

[14:26] <[particle]> Perl 6: Nil; Perl 5: undef

[14:26] <[particle]> ...but who's keeping score...

[14:27] <Juerd> masak: Great slogan :)

[14:27] <Juerd> But...

[14:27] <masak> :)

[14:27] <Juerd> Perl 5: It's been what, 23 years?

[14:28] <moritz_> Perl 6 - Do You Abandon a 10-Year Old Because She's Not Yet Production Ready?

[14:28] <Juerd> s/5/5.$current/

[14:28] <Juerd> moritz_: Lovely :)

[14:28] <Juerd> moritz_: Can I tweet that? :)

[14:28] <moritz_> Juerd: sure

[14:28] <[particle]> in soviet russia you do!

[14:28] <Juerd> moritz_: Do you use twitter?

[14:29] <moritz_> Juerd: only via hugme :-)

[14:29] <masak> [particle]: in Soviet Russia, a not-yet production-ready 10 year old abandons YOU!

[14:29] <[particle]> you're welcome for the setup, masak :)

[14:29] <masak> LHF :)

[14:30] *** iblechbot joined
[14:30] <[particle]> Perl Six: two terms in a row

[14:31] <moritz_> unless Perl is a listop :-)

[14:31] <masak> of course it's a listop :)

[14:32] * [particle] 's cpu fan is stuck on high... gotta reboot *sigh*

[14:33] *** [particle] left
[14:37] *** [particle] joined
[14:39] *** tomaw left
[14:40] *** tomaw joined
[14:41] *** ignacio_ left
[14:44] *** Guest46644 left
[14:46] <colomon> woah, stopped to play some music for my boy and you guys really went to town on the unusable blog titles...  :)

[14:47] <masak> loliblogged! http://use.perl.org/~masak/journal/40159

[14:51] <colomon> masak++ # good post

[14:51] <masak> a dank.

[14:53] *** mssm left
[14:53] <colomon> Hmm.... is there any reason we shouldn't move ng1 to ng today?  (Other than maybe making it master instead.)

[14:53] <masak> it's just names :)

[14:54] <colomon> seems like ng1 is more-or-less as capable as ng at this point, and I can't imagine any point to further hacking on ng.

[14:54] <colomon> but, for instance, dalek reports ng commits but not ng1 commits.  :)

[14:54] <moritz_> and ng is tracked by dalek :-)

[14:54] <colomon> jinx!

[14:55] *** ignacio_ joined
[14:55] <colomon> I think tracking alone is a good enough reason to do it, having a tangible on #perl6 trace of changes is a Good Thing.

[14:55] <masak> nod.

[14:55] <masak> +1

[14:56] *** wanradt left
[14:57] *** wanradt joined
[14:59] *** wasy_afk is now known as wasy

[15:03] *** dr_df0 left
[15:06] *** wanradt left
[15:06] *** wanradt joined
[15:09] <masak> by the way, the Perl 6 Advent Calendar is in the Long Tail phase now. we've stabilized at 150 +/- 100 hits a day to the blog as a whole.

[15:10] <masak> the 'Grammars and Actions' post is the most popular every day. :) Tene++

[15:11] <masak> anyway, if the 150-a-day keeps up, then 20 weeks of Long Tail is more significant than 1 slashdotting. :)

[15:12] *** nihiliad joined
[15:14] *** forrest joined
[15:15] *** [particle] left
[15:16] <forrest> anyone know of a good online article about the history of perl6 (so far)?

[15:16] *** mssm joined
[15:17] <masak> forrest: no, but if you stay around, I'm sure we can patch the history together for you, at least approximately.

[15:17] <sjohnson> forrest: wikipedia is decent

[15:18] <sjohnson> forrest: http://en.wikipedia.org/wiki/Perl

[15:18] <masak> forrest: there's also a 2006 Google Video talk by audreyt that covers the history to an extent.

[15:19] <masak> sjohnson: hi! I saw in the backlog that you addressed me two days ago, but I had already left.

[15:19] <sjohnson> no worries just was saying hi

[15:19] <masak> yeah. still. :) hi.

[15:19] <forrest> masak: can you find a link to that video?

[15:20] *** rv2733 joined
[15:21] <sjohnson> forrest: just search for it on youtube

[15:21] <sjohnson> or google

[15:22] <forrest> this one? http://video.google.com/videoplay?docid=-3876155376103839772#

[15:22] *** k23z__ joined
[15:22] *** [particle] joined
[15:24] * jnthn is back

[15:25] <colomon> o/

[15:27] <masak> forrest: yes, that one. she gives one milestone per year, up to 2006 or so.

[15:27] <sjohnson> i wonder what she is up to these days

[15:27] <masak> forrest: but at the time of that talk, Pugs was the predominant implementation. nowadays, Rakudo is.

[15:28] <masak> and the evolution of Rakudo starts in 2005 or so with PGE, then PCT and nqp, and that started giving visible results in late 2007.

[15:28] <masak> 2008 was a year of lots of functionality being added, and 2009 was the year of lots of Perl 6 projects.

[15:30] *** Psyche^ joined
[15:31] <masak> the big event in 2010 will be the merging of ng, and the subsequent features that are then possible. :)

[15:31] <moritz_> let's give it a catchy name... Rakudo * ?

[15:31] <colomon> lazy!

[15:31] <masak> and then the April/Q2 release, which will tell the world... yeah.

[15:34] *** Patterner left
[15:34] *** Psyche^ is now known as Patterner

[15:34] <forrest> i'm supposed to find "news articles" for my dynamic languages class tomorrow and i found a couple of perl6 things

[15:35] <forrest> i got the announcement of the latest rakudo perl development release, "Minneapolis" ... which is cool because that's where I am

[15:36] <forrest> the basic message i'm telling the class is "perl 6 lives!"

[15:37] <masak> forrest: then it might interest you to know about how Perl 6 combines static and dynamic features.

[15:37] <forrest> yes!

[15:37] <masak> audreyt talks about about that too, in the latter part of that same talk.

[15:37] <masak> but let's summarize it for you :)

[15:38] <masak> ok, so variable declaration. in Perl 6 (as in Perl 5), you can do 'my $var;' and then just put anything in it.

[15:38] <forrest> ok

[15:38] <masak> you can also do 'my Int $var' and have the compiler/runtime err out if you deviate from your own restriction.

[15:39] <forrest> nice

[15:39] <masak> so typing is optional.

[15:40] <masak> the same for function and method signatures.

[15:40] <masak> rakudo: sub foo(Int $a) {}; foo("OH HAI")

[15:40] <p6eval> rakudo 1d4928: OUTPUT«Nominal type check failed for parameter '$a'; expected Int but got Str instead␤in Main (file src/gen_setting.pm, line 324)␤»

[15:40] <masak> rakudo: sub foo($a) { say $a }; foo("OH HAI"); foo(42)

[15:41] <p6eval> rakudo 1d4928: OUTPUT«OH HAI␤42␤»

[15:41] <masak> the point is that you can add and subtract typing as you like.

[15:41] <jnthn> masak: heh. Whenever I see a rakudo: line typed by you I automatically try to spot why the output below it is wrong these days. :-)

[15:41] <masak> jnthn: Pavlov did have a point, then :P

[15:41] <jnthn> Then I realized you're demonstrating stuff and was like...phew. :-)

[15:41] <forrest> if you have real method signatures, then can you have ... oh what do you call it, more than one method of the same name with different type arguments.

[15:42] <jnthn> jnthn: Why does that name ring a bell?

[15:42] * masak groans

[15:42] <masak> forrest: aye, multi methods.

[15:42] <moritz_> forrest: mutli dispatch

[15:42] <masak> let's demo that, too.

[15:42] <forrest> you guys rock

[15:43] <masak> rakudo: multi sub foo(Str $a) { say "It's a Str!" }; multi sub foo(Int $a) { say "It's an Int" }; foo(42); foo("OH HAI")

[15:43] <p6eval> rakudo 1d4928: OUTPUT«It's an Int␤It's a Str!␤»

[15:43] <forrest> so multi is a keyword?

[15:43] <moritz_> aye

[15:44] <masak> in the sense that anything in Perl 6 is a keyword :)

[15:45] <masak> rakudo: multi sub bar($a, Str $b) {}; multi sub bar(Str $a, $b) {}; bar("OH", "HAI")

[15:45] <p6eval> rakudo 1d4928: OUTPUT«Ambiguous dispatch to multi 'bar'. Ambiguous candidates had signatures:␤:(Any $a, Str $b)␤:(Str $a, Any $b)␤in Main (file <unknown>, line <unknown>)␤»

[15:46] <masak> many of the run-time binding errors will be catchable at compile time as our compilers evolve.

[15:48] <forrest> say, is there some gee-whizzical "press release" type document about rakudo * I could show?

[15:48] *** alester joined
[15:49] <masak> there's pmichaud++'s blog post.

[15:50] <masak> http://use.perl.org/~pmichaud/journal/39411

[15:51] *** Grant-himself joined
[15:52] <forrest> yeah, that's great, because everyone wants to know "is it done yet?"

[15:52] <masak> I don't. :)

[15:52] <masak> I want to know "can I do cool stuff with it yet?"

[15:52] <masak> whether it's at 100% is fairly irrelevant to me.

[15:53] <forrest> well, everyone who's only vaguely heard that perl 6 is coming one day, and doesn't know any more than that, i mean

[15:53] <forrest> which is the audience i'm addressing

[15:53] <mathw> yeah that's the continual thing we keep trying to rectify

[15:53] <mathw> one person at a time

[15:53] <masak> Perl 6 is here already.

[15:53] <masak> just not all of it, and not in a form which will appeal to everyone.

[15:53] <masak> yet.

[15:53] <mathw> yes

[15:53] <mathw> I kind of need it to run faster

[15:54] <masak> indeed.

[15:54] <masak> much faster.

[15:54] <Tene> masak: someone is translating p6advent posts into japanese, did you see?

[15:54] <Tene> http://d.hatena.ne.jp/uasi/20100114/1263480626

[15:54] <mathw> wow

[15:54] <masak> Tene: yeah, I've been following it and even complimenting the blogger.

[15:54] <mathw> that's awesome

[15:55] <Tene> ah, that's who that is.

[15:55] <masak> but it's slowed down in the last few weeks, I think.

[15:56] *** Grant-himself left
[15:57] <masak> overall, I'm getting vibes through Twitter that Japanese have a generally positive view of Perl 6.

[15:58] * jnthn found it a friendly place to give a Perl 6 talk :-)

[16:00] *** nihiliad left
[16:01] * masak bound 'it' to 'Twitter' before falling back on 'Japan' :)

[16:01] <jnthn> masak: I meant Japan. :-)

[16:02] <jnthn> masak: But nice to know that you consider Twitter a narrower candidate than Japan. :-)

[16:02] <masak> :)

[16:05] * mathw gets a warm fuzzy feeling for a place of such wonderfully geeky humour

[16:05] *** dugg joined
[16:05] <masak> that's been a consistent trait of #perl6 at least since 2005.

[16:06] <masak> I have a small collection of geeky jokes from in here, such as people using CSS to describe the frames of their glasses. :)

[16:07] *** rv2734 joined
[16:08] *** rv2734 left
[16:09] *** Chillance joined
[16:09] *** ruoso joined
[16:10] *** rv2735 joined
[16:10] *** rv2735 left
[16:17] *** ejs left
[16:18] *** PacoLinux left
[16:27] *** hercynium joined
[16:31] *** Woody2143 joined
[16:33] *** cotto_working joined
[16:36] *** cotto_w0rk left
[16:38] *** cotto_working left
[16:46] *** ejs joined
[16:46] *** PacoLinux joined
[16:46] *** [particle] left
[16:54] <masak> you people should try this one-liner at home: perl6 -e 'for ^32->$y {for ^32 {print $_?&$y??" "!!"*"};say ""}'

[16:54] *** cotto_working joined
[16:54] *** justatheory joined
[16:57] <pmurias> masak: what's the penalty for passing that to the evalbot? :)

[16:58] <masak> pmurias: only that it won't be very pretty :)

[16:58] <jnthn> damm, ng won't run it!

[16:58] <masak> yet another short-term goal, then :)

[16:58] *** rv2733 left
[17:02] *** wanradt left
[17:03] *** masak left
[17:03] <colomon> wait, why won't ng run that?

[17:03] <colomon> oh, ng.

[17:04] <colomon> hmm....

[17:04] *** wanradt joined
[17:04] *** [particle] joined
[17:06] <colomon> how is $_?&$y supposed to parse?

[17:06] <jnthn> $_ ?& $y

[17:06] <jnthn> Where ?& is an operator.

[17:07] <colomon> bool and?

[17:07] <jnthn> iirc

[17:07] <colomon> boolean bitwise and

[17:08] <colomon> probably not implemented in ng / ng1 yet?

[17:08] <colomon> btw, jnthn, I vote for moving ng1 to ng today.

[17:08] *** rgrau joined
[17:10] <jnthn> colomon: wfm, no benefit to having both.

[17:10] <jnthn> I'm doing current dev in ng1

[17:10] <colomon> I don't think anyone's working in ng.

[17:10] <colomon> And ng gets dalek reports, etc.

[17:10] <jnthn> Right.

[17:11] <jnthn> Has my vote too.

[17:11] <colomon> Do you know how to do the switch?  should we wait for pmichaud to pitch in?

[17:11] <jnthn> No, my git-fu is weak.

[17:11] <colomon> (I believe I could probably merge all ng1's changes into ng, but I'm not sure that's the right way to do it.)

[17:13] <colomon> btw, ng1 handles everything in that one-liner but the ?&, I'm pretty sure.

[17:13] <colomon> I had thought "for" didn't work yet, but it seems to work like a charm for this.

[17:14] *** cognominal left
[17:14] <jnthn> Oh

[17:14] <jnthn> I thought ranges didn't work in ng1 yet.

[17:14] <jnthn> and ^32

[17:14] <colomon> :)

[17:14] <jnthn> Cool :-)

[17:15] <jnthn> ?& should be easy.

[17:15] <colomon> > for ^5 { $_.say }

[17:15] <colomon> 0

[17:15] <colomon> 1

[17:15] <colomon> 2

[17:15] <colomon> 3

[17:15] <colomon> 4

[17:15] <jnthn> \o/

[17:15] <colomon> agreed on ?&

[17:15] <Tene> colomon: personally, I'd just merge any extra changes from ng since the branch into ng1, and then delete the ng branch.

[17:16] <Tene> You could try a merge first, and if it's trivial, that's fine.

[17:16] <colomon> Tene: I already did that merge.  (Unless someone has done in ng more since I did it.)

[17:16] <colomon> but I think we'd like the "working" branch to end up named ng.

[17:17] <Tene> colomon: if ng has been merged into ng1, then a merge from ng1 into ng should be a no-op.

[17:17] <colomon> could we just merge everything back to ng, and then delete ng1, maybe?

[17:17] <Tene> So, go ahead.

[17:17] <Tene> colomon: That sounds great to me.

[17:17] <jnthn> colomon: Sounds good.

[17:17] <colomon> I will give it a try, then.

[17:18] <jnthn> colomon++

[17:19] <colomon> git merge origin/ng1 was fast-forward.

[17:19] <colomon> now building....

[17:20] <Tene> if it's fast-forward, then there are no changes.

[17:20] <colomon> Tene: yeah, I just like to run spectest to be sure I've made a working system.  :)

[17:20] <Tene> a rebuild doesn't hurt, but isn't necessary.

[17:20] <Tene> Sure, good habit.

[17:21] <colomon> not least since I managed to completely bork ng(1?) for about 12 hours a week or two ago with a commit I was sure couldn't cause problems, and so didn't test.  :)

[17:21] <colomon> luckily no one else was actually working on it that day, so I was the first person to note the problem, too.

[17:21] *** ejs left
[17:23] <colomon> make test passes

[17:26] *** araujo left
[17:27] <colomon> make spectest passes

[17:27] <colomon> pushing

[17:27] <colomon> okay, looks like ng is now lazy.

[17:28] <jnthn> \o/

[17:28] <colomon> so how do we rope off ng1 so there is no further development there?

[17:30] <colomon> > for (^5).map({$_*$_}) { $_.say }

[17:30] <colomon> 0

[17:30] <colomon> 1

[17:30] <dalek> rakudo/ng: 533672f | (Solomon Foster)++ | t/spectest.data:

[17:30] <dalek> rakudo/ng: Turn back on join.t.

[17:30] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/533672fb1925bd96dcf29598b1dbf440b582176c

[17:30] <dalek> rakudo/ng: 380ff4a | (Solomon Foster)++ |  (2 files):

[17:30] <dalek> rakudo/ng: Merge branch 'ng1' of [email@hidden.address] into ng1

[17:30] <colomon> 4

[17:30] <colomon> 9

[17:30] <colomon> 16

[17:30] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/380ff4ad95706dd58da5894aeeb3c3fb0c0ed61c

[17:30] <dalek> rakudo/ng: 20f54dd | jonathan++ | src/Perl6/ (2 files):

[17:30] <dalek> rakudo/ng: Fix up my ($a, $b) again, with a little refactoring of the way we handle symbol registration. This also fudges in multisig, though we don't actually parse multiple signatures just yet.

[17:30] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/20f54ddc5bb87759f17f63a708fd0e151cfb75eb

[17:30] <dalek> rakudo/ng: c55ec79 | jonathan++ | src/Perl6/Grammar.pm:

[17:30] <dalek> rakudo/ng: A little re-ordering, to account for not doing LTM just yet.

[17:30] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/c55ec79b18cd91790b31554f9d665259ff1f09e5

[17:30] <dalek> rakudo/ng: ab294a0 | jonathan++ |  (4 files):

[17:30] <dalek> rakudo/ng: A few role tweaks to help us pass more tests.

[17:30] <colomon> wow, that all didn't cause a flood?  :)

[17:30] <colomon> spoke too soon, I guess.

[17:31] <jnthn> :-)

[17:31] <jnthn> colomon: Not sure you can do much besides delete the branch, but again, weak git-fu. :-)

[17:35] *** payload left
[17:39] *** k23z__ left
[17:41] <PerlJam> greetings alll

[17:41] <PerlJam> s/ll/l/

[17:42] <colomon> o/

[17:42] <colomon> acid test:

[17:42] <colomon> ng: for ^5 { $_.say }

[17:42] <p6eval> ng 58d896: OUTPUT«0..^5␤»

[17:42] <colomon> ack, it hasn't rebuilt yet.  

[17:43] <Tene> colomon: just delete the branch

[17:43] <colomon> Tene: how?

[17:43] <Tene> git push origin :ng1

[17:43] <colomon> done.

[17:44] * colomon feels like that was too easy....

[17:44] <colomon> and now "git pull" from my ng1 build complains bitterly.  seems like it worked!

[17:44] <colomon> Tene++ # for knowing how to get stuff done

[17:45] <PerlJam> How goes #perl6 today?

[17:46] <colomon> PerlJam: we just merged working laziness (aka ng1) into the ng branch.

[17:46] <sjohnson> great

[17:46] <PerlJam> cool.

[17:46] <colomon> So it's a fine day for #perl6, IMO.

[17:47] <PerlJam> I may have time to play with rakudo tonight too.

[17:47] <colomon> ng: for ^5 { $_.say }

[17:47] <p6eval> ng 58d896: OUTPUT«0..^5␤»

[17:47] <colomon> how does p6eval know when to rebuild?

[17:47] <PerlJam> colomon: I think it happens every 15 or 30 min via cron

[17:48] <colomon> Okay, then I just need to learn patience.

[17:48] <PerlJam> (it always seems to have trouble around the top and bottom of the hour anyway)

[17:53] *** cognominal joined
[17:54] *** meteorjay left
[17:55] <Tene> colomon: feel free to ask me for git help whenever you like.

[17:57] <colomon> Tene: thank you.

[17:59] *** simcop2387 left
[18:04] *** dakkar left
[18:05] *** ruoso left
[18:05] <TimToady> std: for ^32->$y {for ^32 {print $_?&$y??" "!!"*"};say ""}

[18:05] <p6eval> std 29637: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of -> to call a method; in Perl 6 please use . at /tmp/WlT2bndFnE line 1:␤------> [32mfor ^32->[33m⏏[31m$y {for ^32 {print $_?&$y??" "!!"*"};say[0m␤FAILED 00:01 108m␤»

[18:06] *** simcop2387 joined
[18:06] <jnthn> TimToady: stdbug or Rakudo being too liberal?

[18:06] <TimToady> the latter

[18:07] <TimToady> but the message should probably mention the other thing

[18:07] <jnthn> The other thing being?

[18:07] <jnthn> Some whitespace needed?

[18:07] <TimToady> "or put space before the ->"

[18:08] <jnthn> Is that only required so we can give the warning about -> being 5think?

[18:08] <jnthn> Or am I missing something else?

[18:08] <TimToady> there's a general policy of requiring whitespace between a term and a lambda

[18:08] <jnthn> OK.

[18:08] <colomon> ng: for ^5 { $_.say }

[18:08] <p6eval> ng b0a176: OUTPUT«0␤1␤2␤3␤4␤»

[18:08] <jnthn> wfm.

[18:09] <colomon> \o/

[18:09] <TimToady> std: for ^5{ $_.say }

[18:09] <p6eval> std 29637: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/8ueEqF2QbI line 1 (EOF):␤------> [32mfor ^5{ $_.say }[33m⏏[31m<EOL>[0m␤    expecting any of:␤ POST␤   postfix␤  postfix_prefix_meta_operator␤FAILED 00:01 107m␤»

[18:09] <jnthn> ng: for 1..* { .say; exit if $_ > 10 }

[18:10] <p6eval> ng b0a176:  ( no output )

[18:10] <jnthn> ng: for 1..10 { .say; exit if $_ > 10 }

[18:10] <p6eval> ng b0a176: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[18:10] <jnthn> ng: for ^10000000 { .say; exit if $_ > 10 }

[18:10] <colomon> oh, for may not be lazy yet.

[18:10] <p6eval> ng b0a176:  ( no output )

[18:10] <jnthn> Oh.

[18:10] <jnthn> OK. :-)

[18:11] <jnthn> OK, cooking, eating, then Rakudoing.

[18:11] <TimToady> laters

[18:11] <colomon> ng: (1..*).map({ .say; exit if $_ > 10 }).eager

[18:11] <p6eval> ng b0a176: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤Could not find non-existent sub &exit␤current instr.: '_block27' pc 143 (EVAL_1:53)␤»

[18:12] <TimToady> void context is supposed to be eager

[18:12] <TimToady> er, *sink* context, ahem

[18:12] <colomon> TimToady: yes, but it isn't yet.

[18:13] <TimToady> ng: eager (1..*).map: { .say; last when 10 }

[18:13] <p6eval> ng b0a176: OUTPUT«Missing block at line 1, near "}"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[18:13] <TimToady> std: eager (1..*).map: { .say; last when 10 }

[18:13] <p6eval> std 29637: OUTPUT«ok 00:01 106m␤»

[18:13] <colomon> ng: (1..*).map: { .say; last when 10 }.eager

[18:13] <p6eval> ng b0a176: OUTPUT«Missing block at line 1, near "}.eager"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[18:14] <colomon> yeah, I don't think the "last when" construct works yet, either.

[18:14] <TimToady> ah, thinks when is a statement, I think

[18:14] <colomon> ng: (1..*).map: { .say; last if $_ > 10; }.eager

[18:14] <p6eval> ng b0a176: OUTPUT«Method 'eager' not found for invocant of class 'Block'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[18:14] <colomon> ng: (1..*).map({ .say; last if $_ > 10; }).eager

[18:14] <TimToady> that's also supposed to work, via a quaint hack

[18:14] <p6eval> ng b0a176: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤Warning␤Null PMC access in isa_pmc()␤current instr.: 'perl6;Iterator;eager' pc 9685 (src/gen/RoleToInstanceApplier.pir:387)␤»

[18:15] <colomon> clearly we don't have full STD working yet.  :)

[18:15] * TimToady will go shower and see if it's working by the time he comes back &

[18:16] <colomon> ng: (1..*).map({ .say; last if $_ > 10; }).perl.say

[18:16] <p6eval> ng b0a176: OUTPUT«Method 'perl' not found for invocant of class 'MapIterator'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[18:16] <colomon> hmm, thought we had that working now.

[18:17] <colomon> well, except for the whole part where I have no clue what .perl should actually do in that case.  :)

[18:18] *** fridim_ left
[18:18] <colomon> ng: (1..*).map({ .say; last if $_ > 10; }).join(' ').say

[18:18] <p6eval> ng b0a176: OUTPUT«sh: ./perl6: No such file or directory␤»

[18:20] <colomon> jnthn: you working on adding ?& or should I take a stab at it?

[18:20] *** ruoso joined
[18:22] *** stephenlb joined
[18:23] *** payload joined
[18:25] *** k23z__ joined
[18:25] *** am0c joined
[18:30] *** cdarroch joined
[18:30] *** cdarroch left
[18:30] *** cdarroch joined
[18:31] *** fridim_ joined
[18:31] *** xomas left
[18:33] *** xomas_ joined
[18:33] *** xomas_ left
[18:33] *** xomas_ joined
[18:33] *** meppl joined
[18:34] *** xomas_ is now known as xomas

[18:39] <Tene> TimToady: what exactly is supposed to be catching the 'last' exception in that case?  map?

[18:44] <colomon> Tene: if map and for are supposed to be exactly equivalent, it has to be map, doesn't it?

[18:44] * Tene nods.

[18:44] <Tene> colomon: are there tests for next/last/redo in map?

[18:45] <Tene> If you can get those in, I can add support for them

[18:45] <colomon> Tene: darned if I know.

[18:45] <Tene> when life settles down, at least.

[18:45] *** pmurias left
[18:46] <colomon> Hmmm... actually, map.t doesn't even work at the moment.

[18:48] *** cognominal left
[18:48] *** cognominal joined
[18:49] *** hercynium left
[19:11] *** jonasbn joined
[19:19] *** mikehh left
[19:20] *** mikehh joined
[19:27] *** eternaleye left
[19:29] *** hercynium joined
[19:29] <colomon> isne is is not equal in parrot?

[19:29] *** wanradt left
[19:30] <Tene> yes

[19:30] * jnthn back

[19:31] <jnthn> colomon: Go for ?& :-)

[19:31] <colomon> jnthn: already am, the isne was about trying to understand how master handles ?&  :)

[19:32] *** stephenlb left
[19:32] <colomon> band is obviously binary and... I'm not clear on why isne is also needed, unless it's converting the result to a Bool.

[19:37] <jnthn> make spectest in ng is a tad noisy

[19:37] <jnthn> Though mostly because of TODO passed

[19:38] <jnthn> colomon: Let me take a peek.

[19:39] <jnthn> It's not creating a Bool, but that's the sentiment, I think.

[19:40] <jnthn> multi infix:<?&>($a, $b) { ?pir::band__III($a, $b) } # or some such

[19:40] <jnthn> Would probably do the right thing.

[19:44] *** stephenlb joined
[19:48] <colomon> jnthn: the TODO passed thing is a big loop where some of the cases succeed and some fail. 

[19:48] <colomon> so really it's a cry for attention.  :)

[19:49] *** nihiliad joined
[19:52] <colomon> jnthn: looks like your suggested ?& works beautifully (on my first four simple tests).

[19:53] *** ruoso left
[19:53] <jnthn> colomon: Yay

[19:53] <jnthn> colomon: Erm. Turns out I git checkout ng'd but forgot to pull.

[19:53] <jnthn> So the tests maybe ain't so bad.

[19:53] <colomon> looking for tests for ?& right now...

[19:54] <jnthn> colomon: May as well put in the related ones while you're on it. ;-)

[19:54] <colomon> wow, I think our tests for that are officially pathetic.

[19:55] <colomon> jnthn: I was afraid someone would say that.  ;)

[19:56] *** hercynium left
[19:57] <colomon> Test file also describes it as "logical AND", which doesn't seem right to me, and the tests never do anything bitwise-y with it.  :(

[19:57] <jnthn> awww

[19:57] <jnthn> And there we were thinking we'd win some back.

[19:58] <colomon> Well, maybe.

[19:58] <colomon> I think I'm going to move the boolean bitwise tests to a file of their own, add needed tests, and make it all work.

[19:58] <colomon> or at least, that's my business plan for the moment.  :)

[19:59] <jnthn> Go for it.

[19:59] <jnthn> I'm going to fix my Foo $x .= new first of all.

[20:00] <colomon> masak++'s one-liner from this morning now works on my local copy.  :)

[20:00] <jnthn> Yay!

[20:01] <colomon> At least, I assume that was the output he was looking for...

[20:01] <lisppaste3> colomon pasted "masak's one-liner in (colomon's local) ng" at http://paste.lisp.org/display/94375

[20:02] <jnthn> Oh, it's one of them thingy fracal trianges things!!

[20:05] *** jaldhar left
[20:07] <colomon> Sierpinski triangles, something like that?

[20:07] <jnthn> Yes, that's the name I was failing to find. :-)

[20:09] <colomon> Did I actually spell it right?  That was completely off the cuff, and I'm not a good speller...

[20:10] <colomon> \o/

[20:10] <jnthn> It looks rightish. :-)

[20:10] <jnthn> yes, it is...just google'd it :-)

[20:10] <jnthn> masak++ for the example. :-)

[20:11] <pugs_svn> r29638 | lwall++ | [STD] spruce up error message on -> in postfix position 

[20:13] <pugs_svn> r29639 | colomon++ |  

[20:14] *** clintongormley joined
[20:14] <pugs_svn> r29640 | colomon++ | [t/spec] Rename to better name. 

[20:17] *** arnsholt_ joined
[20:17] *** arnsholt left
[20:17] *** k23z___ joined
[20:18] *** buubot left
[20:18] *** buu left
[20:19] *** k23z__ left
[20:20] <dalek> rakudo/ng: 1516520 | (Solomon Foster)++ | t/spectest.data:

[20:20] <dalek> rakudo/ng: Turn on new boolean-bitwise.t.

[20:20] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/15165203eaac02ce10afa281fdb83e9775c3912c

[20:20] *** buu joined
[20:21] <pugs_svn> r29641 | colomon++ | [t/spec] Remove tests moved to boolean-bitwise.t. 

[20:22] <colomon> errr, what happened to the actual patch?

[20:22] *** buubot joined
[20:23] <colomon> There we go.

[20:24] <colomon> (come on, dalek...)

[20:25] *** mssm left
[20:26] <dalek> rakudo/ng: 17dd439 | (Solomon Foster)++ | src/ (2 files):

[20:26] <dalek> rakudo/ng: Add boolean bitwise operators ?|, ?&, and ?^.

[20:26] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/17dd43902eea5eb79677f0c52e99534ee188d03c

[20:27] <colomon> So that's 20 tests we've got back.

[20:28] *** bluescreen left
[20:28] <jnthn> Yay.

[20:35] <pugs_svn> r29642 | colomon++ | [t/spec] Add a few tests which actually test the "bitwise" part of the boolean bitwise operators. 

[20:36] <colomon> and 8 new tests.  :)

[20:37] <colomon> Of course, those are the dangerous tests: the tests added by the person who added the feature.  If I don't understand what the feature is actually meant to do, then I probably got both the test and the feature wrong.  :)

[20:38] *** nadim__ left
[20:38] *** mssm joined
[20:40] *** bluescreen joined
[20:41] *** nadim joined
[20:45] <TimToady> wrong tests are better than no tests, because they'll eventually provide feedback when another implementation does them right and fails :)

[20:46] <TimToady> and it's arguably more important for everyone to do it wrong the same way than to do it several different ways

[20:49] <jnthn> colomon: Yay. Think I mighta got us my Foo $x .= new working again.

[20:49] <colomon> \o/

[20:49] <jnthn> Need to spectest.

[20:49] <jnthn> (doing so)

[20:49] <jnthn> We win back at least one integration test.

[20:49] <jnthn> Maybe more. Will see.

[20:50] *** riffraff left
[20:50] *** gabiruh left
[20:51] *** gabiruh joined
[20:52] <jnthn> yup, tests look good.

[20:52] *** araujo joined
[20:53] <colomon> \o/

[20:53] <jnthn> pushing

[20:54] <TimToady> is ng now what was ng1?

[20:55] <colomon> TimToady: yes.

[20:55] <colomon> we merged them and deleted ng1 earlier today.

[20:55] <TimToady> I kinda skimmed that part while I still wasn't awake...

[20:55] <jnthn> :-)

[20:56] <colomon> That's why we were trying lazy list tests on ng: this afternoon.  :)

[20:57] <TimToady> now we just rename rakudo to rakudo/stable, and rakudo/ng to rakudo, and then we can engage the masakbot again

[20:57] *** cdarroch left
[20:58] <frettled> Yes, kill -CONT masakbot

[20:59] *** macae left
[21:00] <dalek> rakudo/ng: 7b0a0ba | jonathan++ | src/Perl6/Actions.pm:

[21:00] <dalek> rakudo/ng: Fix init of typed variables; my Monkey $martin .= new; now works again.

[21:00] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/7b0a0ba0a546476fea7a193360ed20b6934770b1

[21:00] <dalek> rakudo/ng: a230972 | jonathan++ | t/spectest.data:

[21:00] <dalek> rakudo/ng: integration/method-calls-and-instantiation.t passes again.

[21:00] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/a230972877d19e837fbf0df81e9bfd9f41de4955

[21:02] <jnthn> We're one (the last) test off passing S12-methods/instance.t again.

[21:04] *** meteorjay joined
[21:05] <jnthn> std: class A { method m($:) { } }

[21:05] <p6eval> std 29642: OUTPUT«ok 00:01 109m␤»

[21:05] <jnthn> std: class A { method m(::T $:) { } }

[21:05] <p6eval> std 29642: OUTPUT«ok 00:01 108m␤»

[21:05] <jnthn> std: sub foo($:) { }

[21:05] <p6eval> std 29642: OUTPUT«ok 00:01 106m␤»

[21:07] <jnthn> std: sub foo($a:) { }

[21:07] <p6eval> std 29642: OUTPUT«ok 00:01 106m␤»

[21:07] <jnthn> std: sub foo($a: $b) { }

[21:07] <p6eval> std 29642: OUTPUT«ok 00:01 106m␤»

[21:09] *** k23z___ left
[21:09] <jnthn> TimToady: In Rakudo we end up parsing this as $ (as a sigil) then : (as a twigil) and an empty name. Is STD also?

[21:09] *** k23z__ joined
[21:10] <jnthn> ah

[21:10] <jnthn> I think not on closer inspection.

[21:11] <jnthn> Oh, actually...changed my mind again.

[21:11] <jnthn> I think it is. :-)

[21:12] <jnthn> TimToady: We have a test that seems to expect that method m(::T $:) { } will parse as capturing the type of the invocant into T and the $ just being a placeholder variable.

[21:13] <jnthn> Changing the test to method m(::T $ :) { } makes it pass

[21:14] * colomon suspects the smiley is why it works.  ;)

[21:16] <jnthn> ;-)

[21:17] <jnthn> colomon: An answer gets us a 26-test-long test file back. :-)

[21:17] <jnthn> Including one passing TODO.

[21:18] <TimToady> STD is parsing it as an anonymous $ following by invocant marker, as determinable by viv -e

[21:18] *** SmokeMachine left
[21:19] *** lichtkind joined
[21:20] <jnthn> TimToady: OK. I'm happy that's the outcome, but I'm struggling to understand why.

[21:20] <jnthn> TimToady: Or more to the point, where we differ from STD that causes it.

[21:20] <jnthn> TimToady: Or put another way, why does:

[21:20] <jnthn>         | <sigil> <twigil>?

[21:20] <TimToady> there are lookaheads in twigil:<:> etc

[21:20] <TimToady> token twigil:sym<:> { <sym> <?before \w> }

[21:21] <jnthn> Oh!

[21:21] <jnthn> It had totally not occurred to me to look there.

[21:21] <jnthn> TimToady++ # thanks

[21:22] <jnthn> oh, our twigil rule is not even broken out into protoregexes yet.

[21:24] * jnthn hopes doing so doesn't cause any issues...

[21:25] * Tene driving home from work now.  hopefully rakudohacking tonight sometime.

[21:29] *** lisppaste3 left
[21:29] <jnthn> Yay. Well, two more passing test files again. :-)

[21:30] <colomon> \o/

[21:31] *** bluescreen left
[21:33] *** bluescreen joined
[21:34] <dalek> rakudo/ng: e0004fe | jonathan++ | src/Perl6/Grammar.pm:

[21:34] <dalek> rakudo/ng: Break twigil out into protoregex and add missing lookaheads to fix some wrong parsing.

[21:34] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/e0004fe29f4eb7dd157dc721e0095d7ca4285a5e

[21:34] <dalek> rakudo/ng: e36d988 | jonathan++ | t/spectest.data:

[21:34] <dalek> rakudo/ng: Two more test files from S12-methods that we can run again now.

[21:34] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/e36d988af27b6bf4b2f0cd4e71b779f7d7c20d3e

[21:36] <colomon> jnthn: is that <?before mean that ^ and : are only twigils if they are followed by a letter (presumably the start of a variable name?)?

[21:36] <jnthn> colomon: Correct.

[21:36] <colomon> cool.

[21:36] * jnthn tries to catch up on Pair/Enum/EnumMap/Hash and work out the relationships.

[21:37] *** lisppaste3 joined
[21:38] *** ihrd joined
[21:38] *** ihrd left
[21:45] <jnthn> OK, so looks like :a constructs a Pair rather than an Enum

[21:45] <jnthn> TimToady: Is there any relationship type wise between Enum and Pair, and between EnumMap and Hash?

[21:46] * colomon wonders why he has been messing around with random operators when he knows that Range still has some big issues that need fixing.

[21:46] <jnthn> TimToady: Like Pair ~~ Enum and EnumMap ~~ Hash?

[21:46] <jnthn> erm

[21:46] <jnthn> Hash ~~ EnumMap I meant]

[21:46] <jnthn> That is, a Hash is an EnumMap + mutable.

[21:47] *** dugg left
[21:48] *** clintongormley left
[21:51] <TimToady> sounds reasonable

[21:52] <TimToady> a nap sounds reasonable too

[21:52] <TimToady> zzz &

[21:53] <colomon> a nap always sounds reasonable.

[21:55] * jnthn tentatively starts on EnumMap and Hash

[22:00] <colomon> Hrm.  If an operator can do $a min $b min $c, is that two calls to min or one call with an Array argument?

[22:01] <jnthn> colomon: one. It's list associative.

[22:02] <colomon> (btw, tests for min and max operators seem very very weak.)

[22:02] <colomon> What's the signature for implementing that?

[22:03] <jnthn> iirc just slurpy

[22:03] <jnthn> multi infix:<min>(*@args) { ... }

[22:03] <colomon> any chance that works in ng?

[22:04] *** jonasbn left
[22:04] *** bluescreen left
[22:05] <jnthn> erm

[22:05] <jnthn> Not sure because of the list changes

[22:05] * colomon is trying right now...

[22:05] <jnthn> but it did at some point

[22:05] <jnthn> ng: sub foo(*@args) { for @args { .say } }; foo(1,2); foo(1,2,3,4);

[22:05] <p6eval> ng e36d98: OUTPUT«1␤2␤1␤2␤3␤4␤»

[22:05] <jnthn> Apparently it works :)

[22:06] <colomon> woah, looks like it works for operators, too!

[22:06] <jnthn> Nice. :-)

[22:06] <jnthn> We can haz min and max ops. :-)

[22:06] <jnthn> Akshually

[22:07] <jnthn> There's an S06-multi test that tries to override the default implementation of that op and fails 'cus it's not there

[22:07] <colomon> of course, now I need to implement min on a list to make that work....  :)

[22:07] <jnthn> So we may win that one back too.

[22:08] <colomon> oh, chaining them does not yet work in ng.

[22:08] <colomon> our multi infix:<min>(*@args) { @args.perl.say; }

[22:08] <colomon> > say 4 min 6 min 60

[22:08] <colomon> [4, 6]

[22:08] <colomon> [1, 60]

[22:09] <jnthn> colomon: oh, maybe just needs a little tweak in Grammar.pm - lemme check.

[22:09] <jnthn> oh

[22:09] <jnthn> is it defined in the grammar?

[22:09] <colomon> min?

[22:09] <jnthn> yeah

[22:09] <colomon> it is in my copy.

[22:09] <colomon> give me a sec, I'll check it in.

[22:10] <jnthn> Did you add it?

[22:10] <jnthn> Oh, OK

[22:10] <colomon> pushed.

[22:10] <colomon> I think.

[22:10] <colomon> Yes.

[22:10] <jnthn> colomon: oh, we have a discrepancy against STD

[22:10] <jnthn> Rakudo has:

[22:10] <jnthn>     Perl6::Grammar.O(':prec<l=>, :assoc<left>',  '%tight_and');

[22:10] <jnthn>     Perl6::Grammar.O(':prec<k=>, :assoc<left>',  '%tight_or');

[22:11] <jnthn> STD says :assoc<list> for both of those.

[22:14] <dalek> rakudo/ng: 6bc10e4 | (Solomon Foster)++ | src/ (2 files):

[22:14] <dalek> rakudo/ng: Quick implementations of infix:<min> and infix:<max> (using before and after).

[22:14] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/6bc10e46745276c30c15f814ffeec408dcfa8771

[22:15] <colomon> jnthn: should we just try changing them to list and see what blows up?

[22:15] <jnthn> colomon: Yes.

[22:16] <jnthn> colomon: I'm not sure if their being different to STD is just mistake or something else.

[22:16] <colomon> might be something as simple as list wasn't ready to go when they were added.

[22:16] <jnthn> Maybe

[22:16] <jnthn> It may also be deeper - this is the precedence level of && and ||

[22:17] <colomon> ooo, does it need to short-circuit then?

[22:18] <jnthn> colomon: min no.

[22:18] <colomon> ng: (1, 2, 3, 4).perl.say

[22:18] <p6eval> ng e36d98: OUTPUT«sh: ./perl6: No such file or directory␤»

[22:18] <jnthn> afaik.

[22:19] <jnthn> colomon: but && and || do some special stuff to achieve that

[22:19] <colomon> jnthn: but && and || do, right?

[22:19] *** Su-Shee left
[22:19] <jnthn> colomon: I have a slight fear that they maybe are assoc<left> in Rakudo at the moment to make that work. But, well, try it. :-)

[22:19] <jnthn> If it doesn't work, then you can probably undo it and the add :assoc<list> to min and max individually.

[22:19] <colomon> I would, except I'm poking around with "list".min at the moment.

[22:19] <colomon> okay, I'll put that on hold and try.

[22:20] <jnthn> Too many things to poke at. :-)

[22:20] <colomon> target-rich environment.

[22:22] <colomon> okay, it compiles with tight-or as list.

[22:22] <colomon> make test okay.

[22:22] <jnthn> OK, if spectest passes too, we're probably fine then :-)

[22:23] * jnthn reads through some of the lazy list code for the first time

[22:24] *** pmurias joined
[22:24] <colomon> spectest passes!

[22:24] <jnthn> \o/

[22:24] <colomon> and it works with min.

[22:25] <jnthn> Cool.

[22:25] <colomon> of course, min doesn't work yet, but it's the principle of the thing.

[22:25] <jnthn> Right.

[22:25] <jnthn> If @list.min can be made to work, then min should be easyish from there.

[22:25] *** am0c left
[22:25] <jnthn> well, hopefully trivial I guess :-)

[22:25] <colomon> right.

[22:26] <jnthn> colomon: You wouldn't happen to remember from the discussions of late what type a slice hands back, would you?

[22:26] <colomon> I keep backing arguments out of the min prototype, hopefully sooner or later it will work without a Null PMC.  :)

[22:26] <colomon> nope, slices just tend to go over my head so far.

[22:26] <jnthn> Ah, OK, no worries then.

[22:26] <jnthn> hmm...wonder if any of it works...

[22:27] <colomon> come to think of it, so do parcels.  :)

[22:27] <jnthn> ng: my @x = 1,2,3,4; say @x[2] # I guess this works

[22:27] <p6eval> ng 6bc10e: OUTPUT«3␤»

[22:27] <jnthn> ng: my @x = 1,2,3,4; say @x[1,2] # and this?

[22:27] <p6eval> ng 6bc10e: OUTPUT«No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'␤current instr.: '!postcircumfix:<[ ]>' pc 291187 (src/gen/core.pir:34871)␤»

[22:27] <jnthn> Ah

[22:29] <jnthn> I'll not worry about that case for Hash too then :-)

[22:29] <colomon> oh, right, if I'd thought a moment I could have told you it didn't work yet there.  :)

[22:29] <colomon> I thought you were looking for ideal rather than actual. 

[22:29] <jnthn> colomon: I'm curious, but it's not pressing yet.

[22:29] <colomon> so how do you write a multi-type min function?

[22:29] <colomon> I can use "before" for the sorting, but I'm not sure how to get things started.

[22:30] <colomon> ng: say 4 before Mu;

[22:30] <p6eval> ng 6bc10e: OUTPUT«Nominal type check failed for parameter '$b'; expected Num but got Mu instead␤current instr.: '&infix:<cmp>' pc 215151 (src/gen/core.pir:6161)␤»

[22:30] <colomon> ng: say 4 before Num

[22:30] <p6eval> ng 6bc10e: OUTPUT«0␤»

[22:30] <jnthn> colomon: Hmm...maybe see master for how it does it?

[22:30] <colomon> I'm assuming the FIRST phaser doesn't work yet in ng?

[22:31] <jnthn> Maybe not, no.

[22:31] <jnthn> Probably not, in fact.

[22:31] *** saschi left
[22:32] <jnthn> ng: my @x = 1,2,3; say @s.WHAT

[22:32] <p6eval> ng 6bc10e: OUTPUT«Symbol '@s' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)␤»

[22:32] <jnthn> ng: my @x = 1,2,3; say @x.WHAT

[22:32] <p6eval> ng 6bc10e: OUTPUT«Null PMC access in elements()␤current instr.: 'perl6;SeqIter;get' pc 11801 (src/builtins/Callable.pir:36)␤»

[22:32] <colomon> they do it by shifting the first value off the list, but I'm not sure if that makes sense with a lazy list.

[22:33] <jnthn> ...oh.

[22:33] <jnthn> colomon: If you're going to find the min, you'll have to go through the whole lot anyway.

[22:33] <jnthn> colomon: So not sure laziness matters so much here.

[22:33] <colomon> sure it does.

[22:34] <colomon> if I make it into a Seq, the whole thing will have to be stored in memory at once.

[22:34] <colomon> with laziness you never need more than two elements at a time.

[22:34] <jnthn> Ah, I see.

[22:35] <colomon> on the other hand, shift ought to be trivial for a lazy list; it's exactly the same as .get.

[22:35] <colomon> so maybe it will work here.

[22:36] * colomon is terribly tempted to implement it using low-level iterator functions...

[22:36] *** patspam joined
[22:36] <colomon> gack, I don't know.

[22:37] <colomon> okay, this will be ugly, but it will work.

[22:37] <spinclad> shift once, then use a for?

[22:38] <colomon> spinclad: except I'm implementing it on Any, and that's definitely NOT what you want if the type is actually Array.

[22:38] <jnthn> Yes, shift feels wrong-ish.

[22:38] <jnthn> Because you'd mutabe the array.

[22:38] <colomon> I'm just going to use a special boolean flag.  crude and smacking of C, but it will work.

[22:38] <jnthn> *mutate

[22:39] *** fridim_ left
[22:41] <colomon> works!

[22:41] <jnthn> yay

[22:41] <jnthn> Don't think I'm going to mangae to get Hash working tonight.

[22:42] <spinclad> method min (*$first, *@rest) {...}

[22:43] <colomon> spinclad: can you define a method so that the invocant gets split into two arguments ?!?

[22:44] <jnthn> Not quite like that.

[22:44] <colomon> oh brill!

[22:44] <colomon> > say 3 min -3 min 4 min 1

[22:44] <colomon> hello

[22:44] <colomon> -3

[22:44] <spinclad> method min ((*$first, *@rest):) {...}   # sure?

[22:44] <colomon> the "hello" was my test to see that infix:<min> was only called once.

[22:44] <jnthn> method min([$first, *@rest]:) { ... } # should do it

[22:45] <jnthn> Probably not yet in ng though.

[22:45] <jnthn> (things don't know how to turn into a capture yet)

[22:45] <colomon> !!!!

[22:46] <colomon> sweetness, that's cool.

[22:46] *** ignacio_ left
[22:48] <jnthn> OK, enough for me tonight.

[22:48] <jnthn> I'll return to the hash tomorrow.

[22:50] <colomon> I've got to be off soon as well, dinner and then Malinky in concert.

[22:51] *** pmurias left
[22:51] <colomon> If someone wants to write some tests for min and max, that would be cool, so ....

[22:51] <colomon> bloody heck, forgot to run spectest before pushing.

[22:51] <colomon> one day I will learn.

[22:54] <dalek> rakudo/ng: 135ace1 | (Solomon Foster)++ | src/Perl6/Grammar.pm:

[22:54] <dalek> rakudo/ng: Make "tight_or" list associative rather than left.

[22:54] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/135ace1f22cd815b6409d07b4802af58ba5fe0bc

[22:54] <dalek> rakudo/ng: 8aa3b7a | (Solomon Foster)++ | src/core/ (2 files):

[22:54] <dalek> rakudo/ng: Add a simple versions of Any.min and Any.max, and use them to implement re-implement infix:<min> and infix:<max> as list associative operators.

[22:54] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/8aa3b7a49f41feca95953b2665d3aa37ae024ab1

[22:54] <colomon> luckily all the standard tests pass anyway.

[23:00] *** pmurias joined
[23:00] *** forrest left
[23:03] *** wasy is now known as wasy_afk

[23:06] <lichtkind> jnthn: ping

[23:12] <jnthn> lichtkind: pong

[23:16] *** pnu left
[23:16] *** pnu joined
[23:28] *** Chillance left
[23:28] *** Chillance joined
[23:28] <TimToady> ng: say [*]

[23:28] <p6eval> ng 8aa3b7: OUTPUT«!whatever_dispatch_helper␤»

[23:28] <TimToady> ng: say [*]()

[23:28] <p6eval> ng 8aa3b7: OUTPUT«invoke() not implemented in class 'Array'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:28] *** iblechbot left
[23:29] *** old_gray_bear joined
[23:29] <jnthn> TimToady: Suspect Array is a bit quirky still.

[23:29] <jnthn> TimToady: And also Whatever, though I think I know what's wrong with that.

[23:29] <TimToady> that's a reduce op

[23:30] <TimToady> it should return 1

[23:31] <TimToady> rakudo: say [*]()

[23:31] <p6eval> rakudo 1d4928: OUTPUT«1␤»

[23:31] <TimToady> rakudo: say [min]()

[23:31] <p6eval> rakudo 1d4928: OUTPUT«Use of uninitialized value␤␤»

[23:31] *** old_gray_bear left
[23:32] <jnthn> TimToady: Heh. My mental parser is evidently missing as much as ng's. :-)

[23:32] <TimToady> and that one is supposed to return +Inf

[23:33] <TimToady> ng: say [min]()

[23:33] <p6eval> ng 8aa3b7: OUTPUT«Could not find non-existent sub &min␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:33] <jnthn> TimToady: Aye. We just don't parse reductions yet.

[23:34] <TimToady> need reduction redactions :)

[23:37] <diakopter> and reduction reductions

[23:39] <diakopter> std: [[]][]

[23:40] <p6eval> std 29642: OUTPUT«ok 00:01 106m␤»

[23:48] *** nihiliad left
[23:52] *** mberends left
[23:54] <TimToady> std: [[ ] ][ [ ][ ]][[ [[ ] ][ [ ]]][[[ ] ][[[ ][ ]][ ][ [ ]][ ][ ][ ]][ ][ ][ ][[ ] ][ [ ]][ ][[ ] ][ [ ][ ]]][ [[ ] ]]]

[23:55] <p6eval> std 29642: OUTPUT«ok 00:01 107m␤»

