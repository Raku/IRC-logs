[00:00] <mberends> is the Rakudo release waiting for another Parrot update? r44147 seems to be 2.1.0

[00:02] <jnthn> mberends: Note quite sure what we're waiting on right now...

[00:02] <chromatic> The tarball's ready to go any time.

[00:03] <chromatic> We're not bumping Parrot HEAD to 2.1.1 because 2.1.1 is 2.1.0 plus a single patch plus a version upgrade.

[00:03] <jnthn> OK.

[00:03] <frettled> chromatic: nice blog comment, BTW

[00:03] <chromatic> Thanks.

[00:04] <frettled> The source file I snarfed that code from isn't _completely_ filled with horrors, it has _some_ sense.  Like, it works as intended.  :)

[00:05] <chromatic> That's worth something... but you start finding these little annoyances and you start to question much of the rest of the code.

[00:05] *** frettled sets mode: +ooo chromatic colomon mberends

[00:05] <frettled> yep

[00:06] <frettled> My upcoming themes are about excessive use of parentheses for the purpose of avoiding knowledge about operator precedence, and then error/result checking.  :)

[00:07] <frettled> «Nah, it's not necessary to check whether the database query went okay before continuing, the database is almost never down.»

[00:07] * frettled tears his hair in despair.

[00:08] <colomon> BTW, my last spectest run (pre- jnthn's slurpy hash opt) took 547 wallclock secs on my MBP.

[00:08] *** snarkyboojum_ joined
[00:08] <frettled> That's PDQ.

[00:09] <jnthn> colomon: Yeah, those kinda times start to get a lot more manageable.

[00:09] <chromatic> jnthn, is that a cache of constant strings I see in the binder?

[00:10] <colomon> now if we could just have this level of optimization on about five more days between now and April...

[00:10] *** payload joined
[00:12] <jnthn> chromatic: Can't use CONST_STRING in there, so faking it out.

[00:12] <jnthn> chromatic: Unless you know of a better approach?

[00:12] *** snarkyboojum left
[00:12] *** snarkyboojum_ is now known as snarkyboojum

[00:17] *** cj__ is now known as cj

[00:21] *** JoWie left
[00:22] <pugs_svn> r29779 | lichtkind++ | updated my talk, smaller reduced pictures, more content 

[00:23] *** xinming_ left
[00:26] <colomon> oh, hey, I just remembered what I wanted to try...

[00:29] <chromatic> No, just looking at all of the string_new_literal() calls and their results.

[00:30] <jnthn> chromatic: Yeah, lots of garbage?

[00:31] <jnthn> chromatic: Do we win much by caching 'em?

[00:31] <chromatic> I'll try that in a bit.

[00:31] * jnthn reckons probably not even a percent or two.

[00:31] <jnthn> OK.

[00:33] *** jferrero left
[00:38] *** rgrau left
[00:39] *** jferrero joined
[00:43] *** nihiliad left
[00:43] <dalek> rakudo/master: e4cdb5b | (Martin Berends)++ |  (2 files):

[00:43] <dalek> rakudo/master: [build/PARROT_REVISION] tentatively set to 44147 2.1.0

[00:43] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/e4cdb5b38c98cc820f8f08992ae5d0444547be56

[00:51] <mberends> testing --gen-parrot with the tarball made with Parrot r44147, looks good

[00:52] <jnthn> \o/

[00:54] <pmichaud> (PARROT_REVISION) let me check the svn history a bit

[00:54] <pmichaud> btw, latest spectest run on my notebook was 8m58

[00:55] *** lue joined
[00:55] <pmichaud> (still non-parallel)

[00:55] <mberends> about 11min here (well .nl akshually)

[00:55] *** colomon left
[00:57] <jnthn> pmichaud: Wow, that's shattered the ten minute mark nicely then. :-)

[00:57] <pmichaud> the 2.1.1 tag is officially r44149, so we should probably use it.

[00:58] <pmichaud> so, set PARROT_REVISION to 44149 2.1.0

[00:59] <pmichaud> (I'm okay with leaving it as 44147, also -- 44148 and 44149 are basically documentation updates)

[00:59] <lue> I wonder, is the ability to use modules from other languages (eg. Python) a purely らくど / Parrot thing?

[00:59] <pmichaud> lue: we don't know yet.

[00:59] <pmichaud> lue:  I would hope that we could make it work on other platforms eventually.

[01:00] <mberends> pmichaud: but then the Parrot version is 2.1.0, not 2.1.1 (with r44147 at least)

[01:00] <pmichaud> it doesn't really matter.  2.1.1 doesn't ever really appear in trunk.

[01:00] <lue> I would like it to be part of the official spec aswell. Even if it isn't, it's great (no more reinventing the wheel, ever :D)

[01:01] <pmichaud> lue: the spec defines the hooks for using modules from other languages.  The details are (as yet) left up to individual implementations.

[01:01] <pmichaud> lue: additional detail by the spec would be very premature at this point.

[01:03] <lue> Same way teaching a 7-year old how to walk would be premature </sarcasm>

[01:03] *** quietfanatic joined
[01:05] <mberends> pmichaud: I'm validating the r44147 / 2.1.0 tarball atm, another bump for the doc updates does not seem worth a re-start

[01:06] <pmichaud> lue: don't make the mistake that the specification precedes the implementation :)

[01:06] <pmichaud> that's generally not how development works.

[01:07] <lue> It sure saves you from being creative, though :)

[01:07] <pmichaud> s/saves/prevents/

[01:07] <pmichaud> the specification really can't (and shouldn't) anticipate the issues that are likely to arise in a real implementation

[01:08] <pmichaud> so what we need to do is have implementations explore the design space, and then codify the best answers as part of the spec

[01:08] <lue> ...like implementation (the process)? :)

[01:08] <pmichaud> this is the way most open source development occurs.  It's certainly the case that Internet standards are formed that way  (implementations precede specification)

[01:08] *** colomon joined
[01:09] <lue> *note to self* invent XYZZY protocol for internet

[01:10] <mberends> lue: as in, the Waterfall development model was always intended to show how *not* to do it

[01:10] <pmichaud> mberends: wfm

[01:10] * lue not a good place for a note to one's self.

[01:10] <pmichaud> mberends: I agree to whatever you decide for the PARROT_REVISION stuff.

[01:11] *** snarkyboojum left
[01:11] <chromatic> jnthn, 1.466% performance improvement.

[01:11] <chromatic> Not huge.

[01:12] <jnthn> chromatic: I'll take it.

[01:12] <mberends> the built-from-tarball Rakudo is working perfectly, will do the git tag and upload shortly

[01:12] <chromatic> I can probably get you to 1.8%.

[01:13] <pmichaud> mberends++

[01:13] * lue Hey, anyone want to use the Swazi emalangeni currency? (its abbreviation is pl)

[01:13] <jnthn> mberends: Nice :-)

[01:13] <pmichaud> interestingly, this release announcement doesn't say how much of the spectest suite we pass.  (I think that's probably okay for this release.)

[01:14] <jnthn> ;-)

[01:14] <pmichaud> the numbers I have are significantly off anyway

[01:15] <mberends> I hope that in a few minutes I can delegate release_guide step 13 to @you, "Publish the release announcement..." because I have no blog-fu

[01:16] <pmichaud> sure, I'll do the release announcement if nobody else picks it up.  :)

[01:16] <pmichaud> I'm all in favor of encouraging delegation :)

[01:17] <pmichaud> ("oh wait, I'm supposed to be delegating to others -- not letting them delegate to me!")

[01:17] *** meppl left
[01:17] * pmichaud updates Test::Harness on his laptop to see what sort of results he gets with parallel test runs

[01:19] <lue> alpha: my @you="mberends","pmichaud","jnthn","lue","TimToady","noo"; say "The order of delegation is as follows:"; say @you;

[01:19] <p6eval> alpha 30e0ed: OUTPUT«The order of delegation is as follows:␤mberendspmichaudjnthnlueTimToadynoo␤»

[01:20] <pmichaud> alpha:  my @you = <mberends pmichaud jnthn lue TimToady noo>;  say "The order of delegation is {@you.pick(*)}";

[01:20] <p6eval> alpha 30e0ed: OUTPUT«The order of delegation is TimToady lue jnthn noo pmichaud mberends␤»

[01:20] <pmichaud> *snicker*

[01:20] <pmichaud> that's an interesting ordering.  :)

[01:21] <mberends> suits me ;)

[01:21] <jnthn> Somehow I preferred lue's answer. ;-)

[01:22] <lue> alpha: my @you="mberends","pmichaud","jnthn","lue","TimToady","noo"; say "The order of delegation is as follows:"; say @you[1];

[01:22] <p6eval> alpha 30e0ed: OUTPUT«The order of delegation is as follows:␤pmichaud␤»

[01:22] <lue> :D

[01:22] <pmichaud> D'oh!

[01:24] <lue> alpha: my $TimToady=True; say "Alpha, do you prefer Mr. Wall over everyone else? {$TimToady}"

[01:24] <p6eval> alpha 30e0ed: OUTPUT«Alpha, do you prefer Mr. Wall over everyone else? 1␤»

[01:25] <colomon> rakudo: my @you="mberends","pmichaud","jnthn","lue","TimToady","noo"; say "The order of delegation is as follows:"; say @you.pick(*, :replace).batch(10).join(' ');

[01:25] <p6eval> rakudo e4cdb5: OUTPUT«The order of delegation is as follows:␤No candidates found to invoke␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[01:25] <colomon> drat

[01:25] <jnthn> fail

[01:25] <lue> try alpha, then pugs, then ng.

[01:27] <lue> alpha: my @you="mberends","pmichaud","jnthn","lue","TimToady","noo"; say "The order of delegation is as follows:"; say @you.pick(*, :replace).batch(10).join(' ');

[01:27] <p6eval> alpha 30e0ed: OUTPUT«The order of delegation is as follows:␤Infinite lazy pick not implemented␤in method »

[01:28] <lue> Aowww! colomon! :)

[01:29] <lue> pugs: my @you="mberends","pmichaud","jnthn","lue","TimToady","noo"; say "The order of delegation is as follows:"; say @you.pick(*, :replace).batch(10).join(' ');

[01:29] <p6eval> pugs: OUTPUT«The order of delegation is as follows:␤*** No compatible multi variant found: "&pick"␤    at /tmp/GIbwTiQNgU line 1, column 113-155␤»

[01:29] <pmichaud> mmmmm

[01:29] <lue> I liked alpha the best.

[01:29] <pmichaud> on my notebook, parallel spectest completes in 5m30

[01:29] <pmichaud> *wow*

[01:29] <jnthn> The interesting thing is that we must have sped up overall.

[01:30] <jnthn> In terms of pure method and sub dispatch speeds, we were once a bit faster in alpha (not now though).

[01:35] <lue> alpha: use rakudo; say "wow, it worked.";

[01:35] <p6eval> alpha 30e0ed: OUTPUT«Can't find ./rakudo in @*INC␤in Main (file <unknown>, line <unknown>)␤»

[01:35] <pmichaud> afk for a while

[01:35] <colomon> I just finished a stupidish comparison

[01:36] <colomon> If you copy master's spectest to alpha, it runs in 913 wallclock on my system.

[01:36] <colomon> That's versus 547 for my current master build.

[01:36] <colomon> My guess is most of that is probably in trig, but still, not bad.

[01:36] <jnthn> Really not bad.

[01:37] <colomon> particularly considering a number of the test files don't exist in alpha, or error out very quickly.

[01:38] *** avar left
[01:38] <jnthn> Quite.

[01:39] <lue> Verily.

[01:39] <lue> Therefore... Ergo

[01:39] <jnthn> I may re-write the multi-dispatch cache next week.

[01:40] <jnthn> See what time I got and what other tempting things there are to hack on.

[01:40] *** ihrd joined
[01:40] <colomon> I think I'll take a stab at properly implementing .pick, and maybe try to get ... more in line with TimToady++'s crazy schemes.

[01:41] <jnthn> Those would both be great things to do.

[01:41] <jnthn> Getting .sort / .min / .max back in the next week would also be a very cool thing.

[01:42] <colomon> jnthn: we have at least stupid versions of .min and .max right now, I think.

[01:42] <jnthn> Ah, OK

[01:42] <jnthn> I plan to continue general triage/re-enabling of S12 and S14 tests too.

[01:43] <quietfanatic> What is 'alpha'? Is it the p6-on-p5 thing?

[01:43] <colomon> rakudo: say (5...1).max

[01:43] <p6eval> rakudo e4cdb5: OUTPUT«5␤»

[01:43] <jnthn> quietfanatic: alpha = what we renmaed old master to.

[01:43] <colomon> quietfanatic: alpha is the old version of Rakudo.

[01:43] <quietfanatic> oh, huh

[01:44] <jnthn> quietfanatic: It's just a branch that holds Rakudo before we made the ng branch be master.

[01:44] <colomon> rakudo: say (5...1).max({ -$^a <=> -$^b })

[01:44] <p6eval> rakudo e4cdb5: OUTPUT«1␤»

[01:44] <quietfanatic> Okay, I get it now

[01:44] *** ihrd left
[01:44] <lue> basically, my %development = {master => alpha, ng => master}

[01:45] <lue> #to abuse the term "hash"

[01:46] <colomon> rakudo: say (5...12).max({ $^a leg $^b });

[01:46] <jnthn> .oO( better than actually abusing hash )

[01:46] <p6eval> rakudo e4cdb5: OUTPUT«9␤»

[01:46] <colomon> rakudo: say (5...12).min({ $^a leg $^b })

[01:46] <p6eval> rakudo e4cdb5: OUTPUT«10␤»

[01:47] <colomon> I think I tried to get .min and .max working well enough to pass minmax.t, and failed.  But they mostly work.

[01:49] <jnthn> rakudo: class Drink { has $.name; has $.price }; my @bar = Drink.new(name => 'beer', price => 1.10), Drink.new(name => 'wine', price => 2.50); my $cheapest = @bar.cheapest({$_.price}); say $cheapest.name;

[01:49] <p6eval> rakudo e4cdb5: OUTPUT«Method 'cheapest' not found for invocant of class 'Array'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[01:49] <jnthn> rakudo: class Drink { has $.name; has $.price }; my @bar = Drink.new(name => 'beer', price => 1.10), Drink.new(name => 'wine', price => 2.50); my $cheapest = @bar.min({$_.price}); say $cheapest.name;

[01:49] <p6eval> rakudo e4cdb5: OUTPUT«Too many positional parameters passed; got 2 but expected between 0 and 1␤current instr.: '_block83' pc 679 (EVAL_1:234)␤»

[01:49] <jnthn> rakudo: class Drink { has $.name; has $.price }; my @bar = Drink.new(name => 'beer', price => 1.10), Drink.new(name => 'wine', price => 2.50); my $cheapest = @bar.min({$^x.price}); say $cheapest.name;

[01:50] <p6eval> rakudo e4cdb5: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: '_block83' pc 679 (EVAL_1:234)␤»

[01:50] <jnthn> Ah, not that form yet.

[01:51] <colomon> Hmmm... I remember that form now, but I don't actually see it in the spec?

[01:52] <colomon> nor is it tested in minmax.t, as far as I can see.

[01:52] <colomon> Seems like it would be pretty easy to implement, though...

[01:53] <colomon> did we actually release?  when can we start checking in changes again?  ;)

[01:54] <mberends> no, just testing, testing the tarball

[01:55] <colomon> just as well, I have a lot of other stuff I should be working on.  

[01:55] *** avarab joined
[01:56] <coke> Ok. Parrot 2.1.1 is released.

[01:56] <mberends> the tarball (using 2.1.0) should be uploaded in just a few minutes

[01:57] <lichtkind> great

[01:57] <lichtkind> conrats to you all

[01:57] <colomon> coke: Thank you again for this rush job rescue.

[01:57] <jnthn> coke: Indeed.

[01:57] <jnthn> :-)

[01:58] <jnthn> Wow. Rakudo did well today. :-)

[01:58] <colomon> :)

[01:59] <jnthn> OK, 3am, I guess I should consider getting a little sleep :-)

[01:59] <colomon> seems like a good plan.

[02:00] <coke> jnthn, colomon; glad to help. cutting a release is now pretty braindead.

[02:00] <coke> chromatic++ for the bugfix.

[02:00] <lue> goodnight, jnthn. (Wow, I wish I were in Europe. Then I wouldn't be up when you guys aren't) :)

[02:01] <jnthn> Yeah, Europe is The Awesome!

[02:01] <jnthn> ;-)

[02:01] <colomon> poor lue, having to suffer along with me, pmichaud, and TimToady...

[02:02] *** jferrero left
[02:02] <jnthn> lol

[02:02] <jnthn> Anyways...

[02:02] <jnthn> dobru noc o/

[02:02] <colomon> good night.

[02:03] *** ShaneC left
[02:03] <lue> goodnight o/ o/ o/ o/ (see, I'm a crowd of people :D )

[02:05] <lue> making the novelty P6 16 month calendar... thinking I should make jnthn a month name (uncapitalized, of course)

[02:06] *** avarab is now known as avar

[02:07] <quietfanatic> rakudo: class X {method x (*@_) {say @_} }; X.new.x(5)

[02:07] <p6eval> rakudo e4cdb5: OUTPUT«Placeholder variables cannot be used in a method at line 11, near "}; X.new.x"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[02:07] <quietfanatic> There's an error for ya

[02:11] <colomon> rakudo: class X {method x () {say @_} }; X.new.x(5)

[02:11] <p6eval> rakudo e4cdb5: OUTPUT«Placeholder variables cannot be used in a method at line 11, near "}; X.new.x"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[02:14] *** [particle] left
[02:14] *** [particle] joined
[02:16] *** pugs_svn left
[02:17] *** PerlJam left
[02:17] *** dukeleto left
[02:17] *** coke left
[02:18] *** Juerd left
[02:18] *** dalek left
[02:18] *** jnthn left
[02:18] *** hatseflats left
[02:18] *** pmichaud left
[02:19] <lue>  /o\ timeout alert! Run for cover! Achtung! timeout alert! /o\

[02:19] *** jnthn joined
[02:19] *** hatseflats joined
[02:19] *** dukeleto joined
[02:20] *** pugs_svn joined
[02:33] *** coke joined
[02:35] *** avar left
[02:38] *** pnate joined
[02:38] <lue> hello?

[02:39] *** mhsparks left
[02:40] <bkeeler> hello!

[02:42] <lue> hello!

[02:42] <colomon> hello!

[02:42] <bkeeler> Sure gets quiet when those noisy euros go to bed eh?

[02:43] *** avarab joined
[02:44] *** mhsparks joined
[02:44] <lue> (again, with gusto) HELLO!

[02:44] <bkeeler> HELLLLOOOOOO...LLOOOO...OOOoo.....oooo.......

[02:45] *** avarab is now known as avar

[02:45] <lue> (huff, huff) HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH

[02:45] <lue> EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEe

[02:45] <lue> LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

[02:45] <lue> OOOOOOOOOOOOOOOOOOOOOOOOOOO

[02:49] <colomon> rakudo: say +"hello"

[02:49] <p6eval> rakudo e4cdb5: OUTPUT«0␤»

[02:50] *** alinbsp left
[02:51] <lue> rakudo: say hello to the class; that's okay, take your time; say hello!;

[02:51] <p6eval> rakudo e4cdb5: OUTPUT«Confused at line 11, near "say hello "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[02:51] <lue> darn, I thought it was an english language interpreter. :)

[02:53] *** justatheory left
[03:02] *** lichtkind left
[03:06] *** mberends left
[03:17] *** cdarroch left
[03:20] *** mssm left
[03:23] <coke> goooooooooooooooooooooodnight everybody.

[03:23] *** coke left
[03:26] <chromatic> Wow, the spectests are 25% faster than they were last time I checked (after a couple of optimizations).

[03:26] <chromatic> 5m 35s for me, with 5 parallel jobs.

[03:27] <Trashlord> cool

[03:27] <colomon> chromatic: is that additional optimizations of yours, or what jnthn++ was working on earlier?

[03:28] <chromatic> Both, but mostly jnthns.

[03:28] <chromatic> I also have a Parrot patch to reduce the number of constants in PBC.

[03:28] <colomon> \o/

[03:30] *** pnate left
[03:34] <chromatic> The cut-down trig tests are 17.271% faster.

[03:35] *** mberends joined
[03:35] *** pnate joined
[03:36] <colomon> nice.

[03:37] <mberends> ok, the 2010.02 release tarball is uploaded. It required re-booting to something with Flash to do the Github upload, something a bit foreign to a Linux user.

[03:38] <colomon> \o/ and ick.

[03:43] *** snarkyboojum joined
[03:43] *** stephenlb left
[03:44] <mberends> updated http://en.wikipedia.org/wiki/Rakudo_Perl as per release guide

[03:46] <mberends> that's the release done, apart from @you copying the release announcement to rakudo.org, perl6.org etc

[03:59] *** wknight8111 left
[04:05] <lue> Hey... how come everyone's here when I'm not? :(

[04:06] <mberends> everybody went over there, only you and I are here

[04:07] <lue> where's there?

[04:07] <mberends> dunno. otherwise I might go myself

[04:08] <snarkyboojum> if I run the spectest how do I interpret the timing results? i.e. do I look at the wallclock secs or..

[04:08] <lue> The least they could do is mark themselves away... (see my gripe yesterday @ about this time in the backlogs)

[04:09] <mberends> snarkyboojum: yes, wallclock times. They came down a lot today.

[04:09] <snarkyboojum> 547 on my lappy

[04:10] * snarkyboojum does a bit of reading about wallclock time :)

[04:10] * lue enquires snarkyboojum about the bandersnatches lately :D

[04:10] <snarkyboojum> banderwahh? :)

[04:10] <mberends> lue: asking these people to all do something is like trying to herd cats, and they're distributed globally

[04:11] <snarkyboojum> oh :)

[04:11] <bkeeler> my bandersnatches have been a bit frumious lately

[04:11] <colomon> I suspect wallclock time is literal, and therefore not the best measure of time, but it's fine for getting the general notion of progress... which was good today!

[04:12] <snarkyboojum> nice to see it maxing out both my cores

[04:13] <colomon> and hopefully not maxing out your ram.  :)

[04:13] <snarkyboojum> ~90% user and 10% system - b00m!

[04:13] <snarkyboojum> plenty of ram left

[04:15] <lue> snarkyboojum: Lewis Carrol's Hunting of the Snark.

[04:16] <snarkyboojum> lue: aye :) (bit slow in the afternoon heat here)

[04:16] <mberends> afk & # sleep

[04:16] <lue> Good thing I don't vanish upon seeing boojums.

[04:16] <snarkyboojum> heh indeedy

[04:17] * lue is continuing work on the P6 novelty calendar system...

[04:19] * lue discovers Linux Action Show! and is now hoping it's streamed in Ogg/Theora

[04:23] <snarkyboojum> lue: checked Linux Outlaws out?

[04:23] <lue> no, ne'er heard of it (I rarely look for videos. So few are in Ogg AND I've an old PowerBook to boot)

[04:24] <snarkyboojum> oh, LA is just a podcast

[04:24] <snarkyboojum> LO even

[04:25] <lue> I just hope it streams in OGG, then I have a fighting chance :)

[04:25] *** drbean left
[04:25] *** drbean joined
[04:26] <lue> They ought to use an HTML5 player as well (I can't use flash (don't want to) )

[04:28] * snarkyboojum finds the idea of a video show on Linux quite amusing - the fake background is hilarious :)

[04:30] <lue> Have they ever used the TARDIS as a background? Or how about an ASCII art picture of Linus Torvalds/Larry Wall/etc ?

[04:30] <snarkyboojum> 563 wallclock secs on that run of the spectest

[04:30] <snarkyboojum> or perhaps a collage of o'reilly animals :P

[04:33] <lue> .u £

[04:33] <phenny> U+00A3 POUND SIGN (£)

[04:35] <lue> Perl6 goal #1: execute at superluminal speeds.

[04:36] <snarkyboojum> I noticed I could send rakudo into apoplexy if I do > say 'a' .. '£'

[04:36] <snarkyboojum> never returns...

[04:42] <lue> alpha: say 'a' .. '£'

[04:42] <p6eval> alpha 30e0ed: OUTPUT«abcdefghijklmnopqrstuvwxyz␤»

[04:42] <lue> hee hee

[04:43] <snarkyboojum> I didn't want to try it here with the rakudo eval bot (or whatever it's called)

[04:47] <lue> then I will

[04:47] <lue> rakudo: say 'a' .. '£'

[04:47] <p6eval> rakudo 8fdc94:  ( no output )

[04:48] <snarkyboojum> oh it timesout :P

[04:49] <snarkyboojum> rakudo: say ('a'..'£').WHAT

[04:49] <p6eval> rakudo 8fdc94: OUTPUT«Range()␤»

[04:51] *** Guna joined
[04:51] <lue> alpha: say ord('a')

[04:51] <p6eval> alpha 30e0ed: OUTPUT«97␤»

[04:52] <lue> alpha: say ord('£')

[04:52] <p6eval> alpha 30e0ed: OUTPUT«163␤»

[04:52] <lue> that range (if I were to implement it) should print every ascii character from 97 to 163

[04:54] <lue> s/ascii/unicode/

[04:54] *** gfx joined
[04:59] <snarkyboojum> rakudo: say ('a' .. '£').to

[04:59] <p6eval> rakudo 8fdc94: OUTPUT«£␤»

[04:59] <snarkyboojum> rakudo: say ('a' .. '£').from

[04:59] <p6eval> rakudo 8fdc94: OUTPUT«a␤»

[05:03] <lue> rakudo: say 'a' ... '£'

[05:03] <p6eval> rakudo 8fdc94:  ( no output )

[05:07] <snarkyboojum> rakudo: say ord('£')

[05:07] <p6eval> rakudo 8fdc94: OUTPUT«163␤»

[05:08] *** lue left
[05:20] <snarkyboojum> ah, it never gets to '£' because it's going to 'z' then 'aa' then 'zz' then 'aaa'  and so on

[05:21] <snarkyboojum> rakudo: say 'aaa' after '£'

[05:21] <p6eval> rakudo 8fdc94: OUTPUT«0␤»

[05:45] *** justatheory joined
[05:47] *** pmichaud joined
[05:47] <pmichaud> hmmm

[05:47] <pmichaud> why do I keep getting bumped from #perl6?

[05:52] <chromatic> Sir, we require gentlemen to wear jackets.

[05:53] <pmichaud> yes, but what does that have to do with me?  ;-)

[05:53] <chromatic> You're scaring the lobsters?

[06:00] <spinclad> (net turbulence around feather?)

[06:00] <spinclad> (ruffled feathers)

[06:01] <pmichaud> no, I'm only being kicked from #perl6 -- I'm still connected to feather, and to other irc channels on freenode

[06:01] <bkeeler> Ahhh, glass of beer, warm dog curled up on my toes, Ashkenazy playing chopin, learning cool new stuff... does life get any better?

[06:03] <spinclad> dunno then... backlog shows a bunch of timeouts from feather, most of whom came right back but not you.

[06:05] <spinclad> probably the lobsters, then, as c said

[06:05] <pmichaud> weird.

[06:07] *** vamped joined
[06:27] *** pppppppeeeeeeeee joined
[06:27] *** pppppppeeeeeeeee left
[06:36] *** nbrown left
[06:37] *** nbrown joined
[06:37] *** xinming joined
[06:51] <snarkyboojum> rakudo: say 'z'.succ

[06:51] <p6eval> rakudo 8fdc94: OUTPUT«aa␤»

[06:59] *** justatheory left
[07:01] *** kaare joined
[07:02] *** kaare is now known as Guest99436

[07:17] *** uniejo joined
[07:24] *** Su-Shee joined
[07:25] <Su-Shee> good morning

[07:29] <spinclad> good dark of night, Su-Shee 

[07:30] *** justatheory joined
[07:34] *** justatheory left
[07:47] *** mssm joined
[08:16] <snarkyboojum> alpha: say 'a'.succ

[08:16] <p6eval> alpha 30e0ed: OUTPUT«b␤»

[08:16] <snarkyboojum> alpha: say 'z'.succ

[08:16] <p6eval> alpha 30e0ed: OUTPUT«aa␤»

[08:18] *** tewk joined
[08:18] <snarkyboojum> alpha: 'aa' after 'z'

[08:18] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "after 'z'"␤in Main (file <unknown>, line <unknown>)␤»

[08:22] *** iblechbot joined
[08:22] <moritz_> good morning

[08:25] <vamped> guten Morgan

[08:37] *** alinbsp joined
[08:46] *** Chillance joined
[08:49] <colomon> o/

[08:52] <mathw> o/

[08:57] <mberends> o/

[09:00] <mberends> moritz_: the 2010.02 release is all done, apart from mailing the the docs/announce/2010.02 file to the mailing lists, and blogging, because I'm not active in those spheres. Would you be able to do that final bit?

[09:01] <moritz_> mberends: surewilldo

[09:01] <mberends> thanks moritz_ :)

[09:01] <vamped> alpha: say (^10).pick(*)

[09:01] <p6eval> alpha 30e0ed: OUTPUT«9260785314␤»

[09:02] <vamped> rakudo: say (^10).pick(*)

[09:02] <p6eval> rakudo 8fdc94: OUTPUT«No candidates found to invoke␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:02] <vamped> Is this considered a bug, or NYI ? (and how does one tell?)

[09:02] <colomon> vamped: only no argument .pick implemented so far

[09:03] <colomon> if I get time from $work, that's one of my goals for today.

[09:03] <colomon> rakudo: say (^10).pick

[09:03] <p6eval> rakudo 8fdc94: OUTPUT«3␤»

[09:04] <vamped> good luck implementing that

[09:04] *** Guna left
[09:05] <moritz_> mail to p6a sent

[09:05] <mberends> :)

[09:05] <colomon> I don't think it will be too bad.  there's a decent finite implementation in alpha to crib from, and the infinite form is easy

[09:05] <colomon> moritz_++

[09:05] <colomon> mberends++

[09:06] <mberends> (teamwork)++

[09:07] <moritz_> http://rakudo.org/node/64 and now blogged

[09:07] <moritz_> indeed mberends++ for the release

[09:07] * mberends blushes and bows

[09:12] * mathw looks at pick and finds it to be interesting

[09:16] <colomon> mathw: are you looking at the spec, or the commented out implementation in Any-list.pm?

[09:16] <mathw> implementation

[09:17] <colomon> I don't remember what didn't work that got me to comment it out...

[09:17] <mathw> the replacing version looks sane

[09:17] <mathw> I haven't tried actually running it :)

[09:18] <colomon> something wasn't working, else I wouldn't have fallen back to the 0-arg version.  :)

[09:19] <colomon> but then, it's been a couple of weeks since then, a lot has happened!

[09:21] <colomon> hmmm... compiles

[09:21] <colomon> > say (1..20).pick(5, :replace)

[09:21] <colomon> 7101763

[09:21] <colomon> > say (1..20).pick(*, :replace).batch(10)

[09:21] <colomon> Method 'Num' not found for invocant of class 'Block'

[09:24] <colomon> ah, $num ~~ Whatever isn't working.

[09:27] <mathw> interesting

[09:27] <mathw> you could enable the non-Whatever form though

[09:29] <colomon> or I could keep fighting with it.  :)

[09:31] *** fridim_ joined
[09:31] <moritz_> the Whatever non-replace one should be implemented with a Fisher-Yates shuffle

[09:31] <moritz_> it's a common case that deserves a fast algorithm

[09:32] <colomon> reference please?

[09:32] <vamped> http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle

[09:33] <moritz_> http://en.wikipedia.org/wiki/Fisher–Yates_shuffle

[09:33] * moritz_ too slow

[09:33] *** moritz_ sets mode: +oo colomon vamped

[09:33] <vamped> sorry to steal your topic, lol

[09:33] <moritz_> no problem :-)

[09:34] *** payload left
[09:36] <colomon> > say (1..20).pick(*, :replace).batch(20).perl

[09:36] <colomon> (17, 12, 10, 7, 16, 2, 2, 8, 5, 12, 2, 13, 7, 3, 3, 17, 14, 1, 2, 16)

[09:36] *** iblechbot left
[09:39] <colomon> > say (1..20).pick(*).batch(30).perl

[09:39] <colomon> (13, 4, 6, 3, 20, 9, 10, 5, 1, 18, 8, 12, 17, 7, 2, 19, 15, 16, 14, 11)

[09:40] <colomon> okay, I appear to have all the basic forms working now.  I'll take a look at F-Y once the tests pass.

[09:40] <mathw> \o/

[09:40] <vamped> thanks colomon.

[09:41] <vamped>  F-Y s looks interesting moritz. I'll have to finish reading after sleep. 'night all.

[09:41] <colomon> night.

[09:41] <moritz_> 'night

[09:41] *** vamped left
[09:42] *** mssm left
[09:42] <mathw> I like how the Wikipedia article gives numerous incorrect implementations which are subject to modulo bias, then doesn't bother explaining what that is or how to fix it until after the pen-and-paper working section

[09:43] <mathw> I suppose I could tweak the article a bit, but it's only been an hour since breakfast

[09:45] <frettled> mathw: How about now, it's been an hour and two minutes since breakfast!

[09:45] <frettled> Good TOD, BTW.

[09:45] <colomon> ok ?(@array.pick eq any <a b c d>), "pick works on arrays";

[09:46] <colomon> Method 'Str' not found for invocant of class 'Junction'

[09:46] <moritz_> so it doesn't autothread

[09:46] <moritz_> but coerces to Str

[09:46] <colomon> seems like.

[09:46] <colomon> I don't think I'm up for fixing that right now.

[09:46] <colomon> In fact, I've got the boy back in bed, so I should be off to bed myself.

[09:47] <colomon> Is it okay to check new code into Rakudo again (post-release)?

[09:47] <moritz_> sleep well

[09:47] <colomon> I see the release has been tagged...

[09:47] <moritz_> aye

[09:52] *** ihrd joined
[09:52] *** ihrd left
[09:58] <colomon> !!!!!

[09:59] <colomon> spectest down to 475 wallclock secs

[09:59] <colomon> chromatic++

[09:59] <colomon> .pick pushed, time for sleep

[09:59] * moritz_ must have missed something - what did chromatic++ do?

[09:59] <chromatic> jnthn had a lot to do with that too.

[10:12] *** fridim_ left
[10:14] <frettled> /o\ OMG OMG OMG this code sucks.  :(  $var = `cat filenamehiddendeepsomewhere | grep STRING`;

[10:16] <itz> is there a canonical and maintained perl6 cheatsheet in any repos now? (http://perlmonks.org/?node_id=238031)  I thought it used to be in pugs

[10:22] <moritz_> no

[10:26] *** orafu left
[10:26] *** orafu joined
[10:27] *** gfx left
[10:39] <moritz_> there must be a cheat sheet somewhere, but it's surely outdate

[10:42] *** chromatic left
[10:46] *** fridim_ joined
[10:47] *** masak joined
[10:48] <masak> oh hai, #perl6!

[10:51] <moritz_> [o]

[10:52] * masak tries to translate that smiley to a human stance, and fails :)

[10:53] <masak> moritz_: did someone shut you into the box in Schrödinger's lab?

[10:53] <masak> I'd open it, but I'm afraid of the state I'd find you in.

[10:54] <moritz_> the box is made by a crazy firebird database on one side, and DBD::InterBase on the other

[10:54] <masak> huh.

[10:54] <masak> boxed in by db stuff.

[10:56] *** mssm joined
[10:58] <moritz_> cut -d '/' -f 5 < dbs | while read i; do echo "drop database $i" | mysql -u $user -p$password -h $host; done

[10:58] <moritz_> I can't help but feel some grim satisfacton while running this command :-)

[11:08] * mathw found a pesky deadlock!

[11:14] <masak> today's topic: OT :)

[11:17] * moritz_ locks the OT topic dead

[11:17] <jnthn> oh hai

[11:18] <masak> lolitsjnthn

[11:19] <jnthn> yayitsmasak

[11:20] <jnthn> ooh, yay. chromatic++ did The String Thing for the extra bonus performance win. :-)

[11:20] <masak> chromatic++

[11:21] *** meppl joined
[11:21] * jnthn loves how in the last 8 commits, six of them were performance enhancements. :-)

[11:26] <masak> rakudo: class X {method x (*@_) {say @_} }; X.new.x(5)

[11:26] <p6eval> rakudo 3704a2: OUTPUT«Placeholder variables cannot be used in a method at line 11, near "}; X.new.x"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[11:26] <masak> whoz op with that?

[11:28] <moritz_> b0rkaged

[11:28] <jnthn> masak: Probably it's being a bit over-eager.

[11:29] <moritz_> rakudo: class X {method x {say @_} }; X.new.x(5)

[11:29] <p6eval> rakudo 3704a2: OUTPUT«Placeholder variables cannot be used in a method at line 11, near "}; X.new.x"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[11:29] <jnthn> masak: The "we has @_ and we're in a method so cry" check probably wants to also check "is @_ defined already".

[11:29] <jnthn> And not worry about it if so.

[11:29] * masak submits rakudobug

[11:29] <masak> quietfanatic++ for discovering it

[11:41] *** gfx joined
[11:42] <jnthn> lol

[11:42] <jnthn> "is this the satnav operator" :-)

[11:42] <jnthn> Some days, p6l is really worth reading. :-)

[11:43] <masak> yeah, that one was excellent.

[11:44] *** fridim_ left
[11:48] <masak> I give up. I'm down to one inexplicable step, but that one is *really* inexplicable. I don't grok Deutsch's algorithm. :( http://en.wikipedia.org/wiki/Deutsch–Jozsa_algorithm

[11:49] <mathw> your tweet about it suggests it's quantum

[11:49] <mathw> therefore

[11:49] <mathw> HEAD ASPLODE

[11:51] <masak> mathw: I'm working on removing exactly that irrational fear of QC :)

[11:51] <masak> mathw: there's really no magic involved, just an L2-norm instead of an L1-norm.

[11:51] <jnthn> Already sounds like magic. :-)

[11:52] <masak> nono, it's easy! really!

[11:52] <masak> what we observe are still ordinary probabilities between 0 and 1.

[11:52] <jnthn> :-)

[11:52] <masak> but they're caused by underlying values which can be negative or complex.

[11:53] <masak> thus, when they're added together, they sometimes cancel out, unlike ordinary probabilities.

[11:53] <masak> this explains all the quantum weirdness.

[11:53] <masak> I just wish I understood how :P

[11:57] <mathw> I'm going to worry about it when there's a quantum computer I might want to program

[11:58] <mathw> Conventional computers are bad enough!

[12:00] <masak> mathw: for some reason, that reminds me of the people who say they're not going to check out Perl 6 when until there's a production implementation :)

[12:01] <masak> &

[12:01] <mathw> well that's silly

[12:01] <mathw> although if they don't have time, that's fair enough

[12:01] <mathw> but nobody's even entirely sure if we can build a quantum computer yet

[12:02] <mathw> although it will be handy to have had people thinking about how to program them at such time that it's accomplished, so that they can be used straight away :)

[12:02] <mathw> I just don't think one of those people needs to be me

[12:03] <masak> still sounds pretty analogous to me :P

[12:03] <masak> & (really)

[12:15] *** kraih_sri left
[12:15] *** kraih_sri joined
[12:15] * mberends is with mathw on the quantum computer thing

[12:17] *** mssm left
[12:19] *** Trashlord left
[12:20] <colomon> o/

[12:21] <colomon> afk # son started crying just as I hit enter there.

[12:22] *** mssm joined
[12:24] *** macae joined
[12:24] *** nbrown left
[12:25] *** nbrown joined
[12:25] *** hanekomu joined
[12:25] *** hanekomu left
[12:39] *** riffraff joined
[12:48] *** payload joined
[12:57] * colomon is starting to intensely hate pick.t

[13:02] *** gfx left
[13:03] <moritz_> why is that?

[13:03] <colomon> I'm suspicious you could write a pick function that always returned the first element in the list you pass it, and still pass pick.t...

[13:03] <masak> mathw, mberends: if I eventually grok the Deutsch algorithm, I will implement it in Perl 6 and blog about it.

[13:03] <colomon> It tests a zillion things which we can't do which aren't pick related, but is very stupid about its actual pick tests, as nearly as I can tell.

[13:04] <moritz_> colomon: I hope it at least tests that @list.pick(*) returns each item once?

[13:04] <colomon> yes, once.

[13:05] *** ignacio_ joined
[13:07] <colomon> There's one test which tests that you don't get the elements back in the same order.

[13:07] <masak> you might.

[13:07] <colomon> but we can't use it now because it uses xx

[13:08] <colomon> masak: yeah, I know.

[13:08] *** jferrero joined
[13:08] <masak> colomon: so it's kind of a crappy test.

[13:09] <colomon> masak: it tries ten shuffles in a row and asserts they are not equal to the source array ten times in a row.

[13:09] <moritz_> it would be great to have some tests for minimal entropy for both rand() and pick

[13:09] <moritz_> but that would require significant effort, and probably also quite some run time

[13:09] <masak> colomon: that sounds familiar. I think I've seen that file sometime.

[13:09] <moritz_> because it would be a statistical test

[13:10] <jnthn> colomon: heh, so it randomly fails? :-)

[13:10] <colomon> moritz_: there actually is a skipped test like that in rand.t

[13:10] <colomon> jnthn: failure should be very unlikely.

[13:10] <jnthn> Well, probably.

[13:10] <jnthn> ;-)

[13:10] <moritz_> jnthn: a test is allowed to fail randomly is the likelyhood is small enough

[13:10] <moritz_> like those statistical prime tests

[13:10] <colomon> but looking at them again, I think returning source list in reverse sorted order probably passes every test they have.

[13:10] <jnthn> :-)

[13:11] <moritz_> there chances of failure are smaller than that cosmic rays influence the result of your computation

[13:11] <moritz_> colomon: then it should not be compared to the original list, but to the first shuffle result

[13:11] <jnthn> During a high level of solar flare activity or a low one?

[13:11] <jnthn> :-)

[13:11] <jnthn> Anyway, yes, point taken. ;_)

[13:11] *** moritz_ sets mode: +o jnthn

[13:12] <moritz_> "in statistic mean"

[13:13] <colomon> my bigger complaint, though, is that the test also depends on junctions autothreading, hashes listifying, sort, xx, and gather / take.

[13:14] <colomon> so here I'm hoping for a nice test file that can let me know if I've got the (not yet done) port to Fisher/Yates correct.

[13:14] <colomon> and what I've got is a test file that will take weeks before we can get it working correctly, and doesn't really test shuffling to any great extent.

[13:16] <moritz_> I understand you complaints, yes

[13:17] <masak> colomon: that's a very valid complaint.

[13:18] <masak> heh. I've started on my E03 implementation. I can't help noting that alpha has :e and :s, but not :r and :w... :)

[13:18] * colomon admits his best thoughts for testing shuffles involve [<] and [>], also complicated ops which are NYI

[13:20] <masak> it's always possible to explain high-level, sugary operations and tests in terms of lower levels and more primitive components.

[13:20] <masak> fwiw, that's what I've spent the last year-and-a-half doing :P

[13:21] <moritz_> sub is_sorted(@a) { @a eq @a.sort };

[13:22] <moritz_> that's rather close to [<=]

[13:22] <masak> moritz_++

[13:22] <colomon> but relies on sort and is relatively slow.  :)

[13:23] <colomon> Probably better just to revert to C programming tricks... 

[13:25] <colomon> sub checknotall(@a is copy, $code) { my $last = @a.unshift; for @a { return true if $code($last, $_); $last = $_; }

[13:25] <colomon> something like that

[13:25] <colomon> er, with a return False at the end.

[13:29] *** meppl left
[13:29] *** IllvilJa left
[13:41] *** pausenclown joined
[13:42] <masak> hm, there's no way to open a file for reading-and-writing in alpha, is there?

[13:43] <masak> the PIR routine in src/builtins/io.pir seems to suggest that an :r adverb overrides a :w adverb. and there's no :rw adverb.

[13:43] <mberends> ugh :(

[13:43] *** athenot joined
[13:44] * masak submits rakudo-TODO RT ticket about that

[13:44] *** xabbu42 joined
[13:44] <jnthn> It was pretty much copied from master, afaik.

[13:45] <mberends> generally to make use of :rw, you would need seek() and a binary mode as well

[13:45] <masak> jnthn: not checked ng/master yet. just assuming it hasn't been fixed :)

[13:45] <masak> IO needs love in Rakudo.

[13:45] <masak> as does everything to do with binary modes.

[13:46] <mberends> how long does it take to get one's head around perl6.ops and the binder?

[13:46] <masak> depends on the stretchability of the head :P

[13:47] <pmichaud> good morning, #perl6

[13:47] <pausenclown> rakudo: "123" ~~ /  <[ a..z ]> ::: { fail "ugh" } /

[13:47] <mberends> the last 20% of docs/compiler_overview.pod is overrunning its 80% of the time

[13:47] <p6eval> rakudo 3704a2: OUTPUT«::: not yet implemented at line 11, near " { fail \"u"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[13:47] <mberends> goodday pmichaud

[13:47] <pausenclown> hi

[13:48] <masak> good morning, pmichaud.

[13:48] <colomon> o/

[13:48] <jnthn> mberends: The binder is fairly straightforwardish, imo.

[13:48] <jnthn> mberends: Well commented, at least. :-)

[13:48] <pausenclown> rakudo: "123" ~~ /  <[ a..z ]> { fail "ugh" } /; say $!

[13:48] <p6eval> rakudo 3704a2: OUTPUT«Mu()␤»

[13:49] <pausenclown> mmh

[13:49] <mberends> jnthn++ the comments are good, at a low level, but lack some overview

[13:49] <masak> pausenclown: that's a bug, you figure?

[13:50] <masak> pausenclown: want to submit it to RT?

[13:50] <pmichaud> ...why is that a bug?

[13:50] <pausenclown> i don't know it's a bug or not.

[13:50] <masak> pausenclown: the pmichaud reply seems to imply it's not :)

[13:51] <mberends> jnthn: your blog article makes it *look* easy, http://use.perl.org/~JonathanWorthington/journal/39772

[13:51] <masak> so, where *would* the 'ugh' end up?

[13:51] <pmichaud> we never reach the 'ugh'

[13:51] *** _johnz joined
[13:51] <masak> oh!

[13:51] <masak> of course. :P

[13:51] <pausenclown> rakudo: "123" ~~ /  [ <[ a..z ]> || { fail "ugh" } ] /; say $!

[13:52] <p6eval> rakudo 3704a2: OUTPUT«Mu()␤»

[13:52] <pmichaud> okay, that's more of a bug :)

[13:52] <masak> pausenclown: shall you or I submit it?

[13:52] <pmichaud> ooc, what *should* happen there?

[13:52] <pausenclown> I'm just toying around

[13:52] <masak> pausenclown++

[13:53] *** johnz left
[13:53] <masak> pausenclown: still. it's a new discovery.

[13:53] <pmichaud> does fail set $! ?

[13:53] <masak> not that I know.

[13:53] <pausenclown> The Exexgesis says it should.

[13:53] <pmichaud> heh

[13:53] <pausenclown> S05

[13:53] <masak> that's a synopsis.

[13:53] <pmichaud> Exegesis tend to be waaaaay out of date.

[13:54] <masak> indeed.

[13:54] *** moritz_ sets mode: +ooo pmichaud masak pausenclown

[13:54] <pausenclown> That they tell me now

[13:54] <pmichaud> I can't find any instance of $! in S05.

[13:54] <jnthn> mberends: Maybe the best way is to consider a signature, and then work through what the code would do.

[13:54] <masak> pmichaud: where, according to you, would the 'ugh' end up?

[13:54] <pausenclown> my bad

[13:55] <moritz_> I've asked TimToady where parsing error message (like from fail or from ~ ) end up

[13:55] <pausenclown> rakudo: "123" ~~ /  [ <[ a..z ]> || { fail "ugh" } ] /; say $/

[13:55] <pmichaud> masak: I have no idea, actually, thus my question :)

[13:55] <p6eval> rakudo 3704a2:  ( no output )

[13:55] <jnthn> fail is like a return.

[13:55] <moritz_> and so far I haven't got an understandable answer

[13:55] <jnthn> afaik

[13:55] <pmichaud> what jnthn++ said.

[13:55] <pmichaud> fail returns an object that throws an exception when it's used.

[13:55] <jnthn> Given we're only in a closure, it probably causes us to fall out of the entire regex.

[13:55] * masak considers all the ambient confusion a bug and submits that

[13:55] <pmichaud> actually, I think we might fall out of the surrounding sub.

[13:56] <jnthn> Well, other question: is an anonymous regex and a named regex different?

[13:56] <pmichaud> because a regex is more like a block than a sub in this case.

[13:56] <jnthn> Yeah

[13:56] <jnthn> Probably fall from surrounding sub here.

[13:56] <pmichaud> that might be the case... but I'm not certain of that either.  :)

[13:56] <jnthn> Whether if that'd been a regex { ... } though...

[13:56] <pausenclown> "The call to fail causes the match to fail at that point, and sets an associated error message that would subsequently appear in the $! error variable (and which would also be accessible as part of $0)."

[13:57] <jnthn> pausenclown: Where's that from?

[13:57] <pausenclown> http://dev.perl.org/perl6/doc/design/exe/E05.html

[13:57] <jnthn> Oh

[13:57] <jnthn> It begins with an E

[13:57] <pmichaud> E05 also says...

[13:57] <jnthn> ...a lot of other out of date stuff.

[13:57] <jnthn> ;-)

[13:57] <pmichaud> [Update: Please note that this was written several years ago, and

[13:57] <pmichaud> a number of things have changed since then.  Rather than changing

[13:57] <pmichaud> the original document, we'll be inserting "Update" notes like this

[13:57] <pmichaud> one to tell you where the design has since evolved.  (For the better,

[13:57] <pmichaud> we hope).  In any event, for the latest Perl 6 design (or to figure out

[13:57] <pausenclown> granted. what should i read instead_

[13:57] <pmichaud> any cryptic remarks below) you should read the Synopses, which are kept

[13:57] <pmichaud> very much more up-to-date than either the Apocalypses or Exegeses.]

[13:58] <masak> Exx are so out-of-date. that's why they're so interesting!

[13:58] <mberends> jnthn: I'll do that in a little while. Right now I'm in the Makefile, figuring out what language perl6.ops is written in: "It's C, Jim, but not as we know it" ;) OPS2C must be the clue...

[13:59] <pausenclown> The Synopsys is too short/sparse for my taste

[13:59] <masak> pausenclown: then you might try moritz_++'s stuff.

[13:59] <moritz_> or the book

[13:59] <moritz_> but it's not very complete yet

[13:59] <masak> or the Advent Calendar.

[13:59] <moritz_> or perl6.org - it links to all that stuff

[14:00] <jnthn> mberends: It's preprocessed by Parrot into a .c file.

[14:00] <jnthn> mberends: er

[14:00] *** jferrero left
[14:00] <jnthn> mberends: By a Parrot build tool.

[14:01] <mberends> by build/ops2c.pl

[14:01] <jnthn> yup

[14:01] <jnthn> It is basically C

[14:01] <mberends> 98% C

[14:01] <jnthn> Wrapped up in op bodies

[14:01] <jnthn> And $1 style thingies which just refer to registers.

[14:01] <mberends> 2% riddle/mystery/enigma

[14:02] <moritz_> "just enough syntactic sugar for confusion"

[14:02] <mberends> heh. yes :)

[14:02] <jnthn> ;-)

[14:04] <pausenclown> damn. i just burned my bolognese

[14:05] *** cognominal joined
[14:06] *** cognominal left
[14:07] *** _johnz left
[14:07] *** johnz joined
[14:08] <pmichaud> did the release announcement go out?

[14:08] *** cognominal joined
[14:08] <pausenclown> alpha: say "abc" ~~ m/a(bc){my $foo = $0}/

[14:08] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "{my $foo ="␤in Main (file <unknown>, line <unknown>)␤»

[14:08] <mberends> pmichaud: moritz_++ did it for us

[14:09] <pausenclown> ok, this is straight from the synopsis =)

[14:09] <pmichaud> okay -- it doesn't appear to have landed in my email yet.

[14:09] <masak> but I didn't see any email on p6c or p6u.

[14:09] <colomon> pmichaud: I thought moritz_++ did it at about 4am EST.

[14:09] <mberends> delegation fail

[14:09] <pausenclown> Is this closure thing implemented at all?

[14:09] <pmichaud> pausenclown: alpha doesn't know how to do closures in regexes -- that's strictly in the new version

[14:09] <jnthn> rakudo: say "abc" ~~ m/a(bc){my $foo = $0}/

[14:10] <pausenclown> The one which has been announced

[14:10] <p6eval> rakudo 3704a2: OUTPUT«abc␤»

[14:10] <pausenclown> ?

[14:10] <moritz_> pmichaud: I've sent the mail to p6a, but it seems to hang in the moderation filter

[14:10] <pmichaud> moritz_: okay, just wanted to make sure someone had taken care of it.  :)  moritz_++

[14:10] <pmichaud> pausenclown: yes, the one that was just released 

[14:11] <pausenclown> Nothing to see at PM

[14:11] <mberends> I had tried that too, to p6l p6a p6c and p6u and assumed they were rejected by some filter

[14:12] *** alinbsp left
[14:12] <pausenclown> whats this /p6./ thing about_

[14:13] <moritz_> pausenclown: short for perl6-{user,announce,compiler,language} mailing lists

[14:13] <mberends> pausenclown: http://dev.perl.org/perl6/lists/

[14:13] <pausenclown> .oO( damn acer kezboard )

[14:13] <pausenclown> ah. thanks

[14:13] <moritz_> mberends: nooow, link to http://perl6.org/community/ :-)

[14:14] * mberends re-programs

[14:19] <pmichaud> we really _should_ update the dev.perl.org/perl6 pages somehow.  :-|

[14:20] <mberends> they were updated recently, this is the result ;-)

[14:20] <moritz_> it is updated in many ways already, and much better than half a year ago

[14:20] * mberends bashes head against moritz_

[14:21] * moritz_ runs away (not related to mberends' head bashing)

[14:21] <pausenclown> helmet, anyone?

[14:22] <mberends> yes, please!

[14:23] <masak> $fh.get(4) still gets me four lines from the filehandle $fh, no?

[14:24] <jnthn> pmichaud++ # glad you agreed on find_name

[14:25] <pausenclown> so,,, then $fh.get(*) should slurp, no?

[14:25] <pausenclown> gawd, i hate this laptop

[14:26] <masak> pausenclown: yes, but there's also $fh.lines() which does that.

[14:27] <mberends> masak: http://perlcabal.org/syn/S32/IO.html does not seem to spec an arg for $fh.get(), it seems to default to 1 line

[14:27] <pmichaud> jnthn: the whole reason "find_sub_not_null" was created was because it was important to preserve the existing semantics of "find_name".  :)

[14:27] <masak> mberends: so... is it $fh.lines(4), then?

[14:28] <mberends> yes

[14:28] <masak> kthx

[14:29] <jnthn> pmichaud: Right.

[14:29] <jnthn> pmichaud: I just feared that thread was starting to get a little traction and figured it was time to step in with a "no don't do it" :-)

[14:30] <pmichaud> jnthn: I mentioend in the conference call last week that I was a bit concerned that many changes were being proposed (and prototyped) for Parrot that were likely to cause problems, but that I didn't want to put myself in the role of "Parrot history cop"

[14:31] *** makkksimal joined
[14:31] <jnthn> pmichaud: I haven't been watching it at all really... :-/

[14:31] *** uniejo left
[14:36] *** Guest99436 left
[14:40] <pausenclown> lunch!

[14:41] <pugs_svn> r29780 | duff++ | [S03] minor typos 

[14:42] *** PerlJam joined
[14:43] <masak> no &seek and no &truncate in Rakudo... :/

[14:44] <PerlJam> TimToady: I'm not sure what you were trying to say at S03:1855 .  It looks like s/arrange// is warranted, but "as long as you return it as a list value" seems odd to me in a different way.

[14:45] *** IllvilJa joined
[14:46] <masak> if I have a filehandle open for reading, can I close it and re-open the same filehandle for writing instead?

[14:46] <masak> if not, does the filehandle store and expose which file path it is a filehandle of?

[14:47] <masak> since I'm assuming the answer to both these questions re Rakudo is 'no', I'm asking re Perl 6.

[14:48] *** Trashlord joined
[14:50] <masak> alpha: my @ = 1, 2, 3

[14:50] <p6eval> alpha 30e0ed: OUTPUT«Malformed declaration at line 10, near "@ = 1, 2, "␤in Main (file <unknown>, line <unknown>)␤»

[14:50] <masak> rakudo: my @ = 1, 2, 3

[14:50] <p6eval> rakudo 3704a2: OUTPUT«Malformed my at line 11, near "@ = 1, 2, "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[14:50] * masak submits rakudobug

[14:52] <pausenclown> whad did you expect here, masak? I mean, the array has no nam

[14:52] <pausenclown> e

[14:52] <masak> pausenclown: :)

[14:52] <pmichaud> std:  my @ = 1, 2, 3

[14:52] <p6eval> std 29779: OUTPUT«ok 00:01 109m␤»

[14:52] <masak> pausenclown: what pmichaud/STD.pm said.

[14:53] <masak> rakudo: my % = foo => 1, bar => 2

[14:53] <p6eval> rakudo 3704a2: OUTPUT«Malformed my at line 11, near "% = foo =>"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[14:53] <masak> rakudo: my $ = 'OH HAI'

[14:53] <pausenclown> std:  my @ = 1, 2, 3; say  @[1]

[14:53] <p6eval> rakudo 3704a2: OUTPUT«Malformed my at line 11, near "$ = 'OH HA"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[14:53] <p6eval> std 29779: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name at /tmp/GjxufXToMv line 1:␤------> [32mmy @ = 1, 2, 3; say  @[33m⏏[31m[1][0m␤    expecting twigil␤FAILED 00:01 107m␤»

[14:53] <mberends> masak: a filehandle that you close is not a filehandle any more. Your next open() would create a new filehandle. Filehandles cannot tell you what their filepath is, the language would have to cache that, which would be a performance hit for the programs that don't ask for it.

[14:54] <masak> mberends: thanks for the explanation. here's why I'm wondering: http://dev.perl.org/perl6/doc/design/exe/E03.html

[14:54] <masak> mberends: that program, interrupted by out-of-date updates as it is, does its business by passing filehandles between subroutines.

[14:54] <masak> mberends: that makes sense when there's &seek and &truncate, but not so much so without them :/

[14:55] <masak> mberends: so I think I'll be forced to pass the filepath around instead.

[14:55] <colomon> What the heck is that program supposed to be doing, anyway?

[14:55] <mberends> yes. the Unix system interface has a reopen(), I think, to change modes

[14:56] <masak> colomon: show off lots of operators :P

[14:56] *** ruoso joined
[14:56] <masak> colomon: (yes, the use case is "a bit" forced.)

[14:57] <masak> pausenclown: when you declare '$', '@' or '%', you're basically throwing data into a hole.

[14:58] <masak> pausenclown: its primary use is in sub/method sugnatures when you need to declare a param, but don't want to use it.

[14:59] <mberends> masak: absolutely needs seek() and truncate(). And if the file encoding is utf-8, the implementation will crawl :(

[14:59] <masak> o.O

[15:00] <masak> mberends: I've seen seek-like algorithms for utf8 that are quite fast, though. very little overhead.

[15:00] <mberends> that gives us a glimmer of hope :)

[15:01] <jnthn> I suspect you won't open a binary file as utf-8. :-)

[15:01] <masak> mberends: found it! :) http://www.daemonology.net/blog/2008-06-05-faster-utf8-strlen.html

[15:01] *** SmokeMachine joined
[15:01] <mberends> jnthn: no, alpha choked on favicon files in HTTP::Daemon after utf-8 was enforced

[15:02] <masak> we had encoding problems in November for a while. viklund++ did an excellent job at solving them.

[15:02] <pausenclown> jnthn: what if u want to read a file backwards?

[15:03] <masak> s/solving/working around/

[15:03] <PerlJam> pausenclown: that's crazy talk!  :)

[15:03] <masak> pausenclown: read it forwards, and do .flip on the result :)

[15:03] <pausenclown> it is not

[15:04] <masak> pausenclown: ¿uʍop ǝpısdn ǝןıɟ ɐ pɐǝɹ oʇ ʇuɐʍ noʎ ɟı ʇɐɥʍ

[15:04] <pausenclown> now, that is crazy talk.

[15:05] <PerlJam> masak++

[15:05] <pausenclown> nice trick, though.

[15:05] * masak bows

[15:07] <mberends> masak: impressive utf-8 handlers! I think Objective-C and OSX string libraries implement something like that. I had ideas of doing similar things for native utf-8 in vill, before TimToady++ talked me out of it. Applying it to files would still crawl, however :(

[15:07] <jnthn> .oO( Str.^add_method('mirror_text', ...) )

[15:08] <masak> mberends: yes. I guess it's still O(n) rather than O(1). :/

[15:08] <mberends> yep

[15:08] <masak> jnthn: I guess one shouldn't be able to do that without MONKEY_TYPING enabled?

[15:09] <mberends> masak: thanks for the utf-8 ideas though, it may be worth reconsidering for vill :)

[15:10] <masak> mberends: you're welcome. I'm glad I found it. Google++

[15:13] <pausenclown> time to play some crossfire (http://crossfire.z8games.com/). come and get me =)

[15:13] <jnthn> masak: You probably can't augment.

[15:14] <jnthn> masak: You can likely do meta-model things though.

[15:14] <jnthn> masak: They're just method calls after all.

[15:14] <PerlJam> weird.

[15:14] <masak> pausenclown: Perl 6 is my online game :)

[15:15] <PerlJam> masak: who's winning? ;)

[15:17] *** pausenclown left
[15:21] <masak> PerlJam: everyone :)

[15:21] <masak> (duh)

[15:21] <masak> rakudo: rand()

[15:21] <p6eval> rakudo 3704a2: OUTPUT«Unsupported use of rand(); in Perl 6 please use rand at line 11, near "()"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[15:21] <masak> std: rand()

[15:21] <p6eval> std 29780: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of rand(); in Perl 6 please use rand at /tmp/u95Z6iRUXu line 1:␤------> [32mrand[33m⏏[31m()[0m␤FAILED 00:01 107m␤»

[15:22] <masak> rakudo: my $a = rand until $a > .5; say $a

[15:22] <p6eval> rakudo 3704a2: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[15:22] <masak> alpha: my $a = rand until $a > .5; say $a

[15:22] <p6eval> alpha 30e0ed: OUTPUT«Null PMC access in can()␤in Main (file <unknown>, line <unknown>)␤»

[15:22] <masak> std: my $a = rand until $a > .5; say $a

[15:22] <jnthn> Hey look, one less NPMCA!

[15:22] <p6eval> std 29780: OUTPUT«ok 00:01 107m␤»

[15:22] <masak> jnthn: :)

[15:22] * masak submits rakudobug

[15:22] <jnthn> hmm, yeha

[15:23] <makkksimal> ?eval 1+1

[15:23] <jnthn> Wait, should until evaluate the loop once always?

[15:23] <masak> jnthn: that would actually make the error make sense...

[15:23] * jnthn checks the spec

[15:23] <jnthn> masak: Right, that's why I was asking.

[15:23] * masak stands down rakudobug alert

[15:23] <jnthn> I mean, I'd expect it from my $a = rand while $a <= .5;

[15:24] <masak> nod.

[15:24] <masak> you're right.

[15:24] <jnthn> It's a bug if until is spec'd to evaluate once first, anyways...just not sure if it is. :-)

[15:25] <jnthn> BTW, one of the big refactorings in ng was to handle things like that in a way that'd hopefully avoid NPMCA.

[15:25] <jnthn> rakudo: sub foo($x where { $x == $y }, $y) { }; foo(1,2) # doesn't NPMCA either now :-)

[15:25] <p6eval> rakudo 3704a2: OUTPUT«No applicable candidates found to dispatch to for 'infix:<==>'␤current instr.: '_block51' pc 434 (EVAL_1:170)␤»

[15:25] <masak> jnthn: no, 'until' is '!while'.

[15:25] <jnthn> masak: Ah, ok

[15:25] <jnthn> Then error makes sense I guess.

[15:25] <masak> aye.

[15:26] * masak submits a LTA rakudobug for that last one :)

[15:26] <masak> std: sub foo($x where { $x == $y }, $y) { }

[15:26] <p6eval> std 29780: OUTPUT«Potential difficulties:␤  Variable $y is not predeclared at /tmp/1c7JszfEht line 1:␤------> [32msub foo($x where { $x == $y[33m⏏[31m }, $y) { }[0m␤ok 00:01 110m␤»

[15:26] <masak> that's a lot better.

[15:28] <jnthn> Yeah

[15:28] <jnthn> But NPMCA woulda been worse

[15:30] <masak> yeah :)

[15:35] * colomon is suffering SAN loss from $work.

[15:37] <moritz_> when that happens you're happy if you have your source code in git and not svn on the server :-)

[15:39] *** justatheory joined
[15:42] <colomon> Here's what's happening, just in case it suggests something useful, because I'm utterly boggled.

[15:43] <colomon> For $work, I ship C++ code to customers.  Apparently a customer complained to some of the folks I work with that we had non-virtual destructors on many classes, and requested that we add them to adhere to their source code conventions.

[15:44] <colomon> So I added a bunch, with no difficulties but perhaps microscopically less efficient code due to unneeded vtables. 

[15:44] <colomon> That is, no difficulties on OS X.

[15:45] <colomon> I just tried a Windows build with the now-virtual destructors, and I'm getting an endless stream of pop up messages informing me the program must be aborted because these destructors could not be found.

[15:45] <colomon> Now, the destructors in question existed before the change.  All that's different is they are virtual.  And if they can't be found, they shouldn't be linking in the first place, as far as I can see.

[15:46] <bkeeler> Some artifact of a previous build confusing things perhaps?  

[15:46] <colomon> and suddenly I have an overwhelming urge to just revert the patch that added all the virtuals...

[15:46] *** nihiliad joined
[15:46] <colomon> Nope, I .... 

[15:46] <colomon> hmmm.  I did a clean build, sort of.  Maybe I should try harder on that front?

[15:47] <bkeeler> Can't hurt

[15:47] <colomon> bkeeler++ # good idea

[15:47] <jnthn> Maybe if you've a VM runner handy, try a build/run on one of those too.

[15:47] <bkeeler> Remove all vestiges of any installed .dlls too

[15:48] <jnthn> So you know it's clean.

[15:48] <bkeeler> If in doubt reinstall Windows ;)

[15:52] *** Psyche^ joined
[15:53] *** Patterner left
[15:53] *** Psyche^ is now known as Patterner

[15:55] *** snarkyboojum left
[15:56] *** pmurias joined
[15:57] *** rv2733 joined
[15:57] *** dual left
[15:58] *** SmokeMachine left
[15:58] *** riffraff left
[15:59] *** riffraff joined
[16:02] *** jferrero joined
[16:09] *** rgrau joined
[16:13] *** mssm left
[16:14] *** riffraff left
[16:25] *** SmokeMachine joined
[16:40] <colomon> Hmmm... after a complete rebuild of my $work code, I get a completely different linking error.  Progress, I guess. bkeeler++, jnthn++

[16:41] <bkeeler> hehe, good to hear

[16:46] *** am0c left
[16:55] <masak> E03 has the most contrived program I've ever seen.

[17:01] <mberends> are you working on making a running version of it?

[17:05] <masak> mberends: eventually.

[17:05] <masak> mberends: first I just want to translate it to modern Perl 6.

[17:06] <mberends> masak: interesting. E03 could do with updating.

[17:06] <bkeeler> any emacs users here?  Just wondering if there's a cperl mode with perl6 support that's more recent than the one in the pugs repo...

[17:06] <masak> mberends: SF already has a blog post about it. want me to paste the URL?

[17:07] <mberends> yes please!

[17:07] <masak> http://lastofthecarelessmen.blogspot.com/2010/02/e03-first-stab.html

[17:07] <masak> I don't want to look at it yet :)

[17:08] <mberends> SF is already up to date with s/master/alpha/ :)

[17:08] <masak> SF++

[17:13] *** makkksimal left
[17:19] <jnthn> chromatic++'s improvements last night took test from 517s to 502s - a small but nice extra gain. :-)

[17:19] <jnthn> (times for me, of course :-))

[17:20] *** masak left
[17:24] *** Chillance left
[17:24] <colomon> jnthn: it was more like a 10% improvement on my machine.

[17:24] *** Chillance joined
[17:24] *** dual joined
[17:31] <jnthn> colomon: Really? Wow.

[17:31] <colomon> I guess it's possible one of your later optimizations snuck into the comparison as well, I wasn't being careful.  :)

[17:32] <colomon> but I'm getting 475 wallclock on my system, and the previous timing I noted was 547.

[17:32] <colomon> at this point it's really solidly much better than alpha, too.

[17:32] <jnthn> Dunno, I pushed two, and then a third one later.

[17:32] <jnthn> Yes, that makes me happy. :-)

[17:40] * colomon should stop fantasizing about implementing Rat versions of the trig functions and get back to $work...

[17:44] *** nbrown left
[17:45] <colomon> Would probably be easier if they were FatRats...

[17:45] *** cdarroch joined
[17:45] *** cdarroch left
[17:45] *** cdarroch joined
[17:45] <jnthn> .oO( It occurs to me that Rat.Capture actually means something... )

[17:45] * jnthn lols

[17:46] <colomon> what does it mean?

[17:47] <jnthn> colomon: Just coercion to a capture

[17:48] <colomon> ah, does that make sense as something to call?

[17:48] <jnthn> rakudo: sub foo(Rat $r (:$numerator, :$denominator, *%)) { say $numerator; say $denominator; }; foo(3/5)

[17:48] <p6eval> rakudo 3704a2: OUTPUT«3␤5␤»

[17:48] <jnthn> colomon: The binder calls it in order to make things like the above work. :-)

[17:48] <colomon> I am awed that you got that working.

[17:49] <colomon> what does the *% in there mean?

[17:50] <jnthn> colomon: It's just a slurpy hash, it means "and throw away anything else"

[17:50] <jnthn> Though actually, a Rat probably doesn't ahve any other attributes.

[17:50] <jnthn> rakudo: sub foo(Rat $r (:$numerator, :$denominator)) { say $numerator; say $denominator; }; foo(3/5)

[17:50] <p6eval> rakudo 3704a2: OUTPUT«3␤5␤»

[17:50] <jnthn> ah, yeah, so you get away with just that. :-)

[17:50] <colomon> ah, cool.

[17:50] <jnthn> Works on returns too.

[17:51] <jnthn> rakudo: sub foo() { return 4/3 }; my (Rat $r (:$numerator, :$denominator)) := foo(); say $numerator; say $denominator;

[17:51] <p6eval> rakudo 3704a2: OUTPUT«4␤3␤»

[17:52] <colomon> rakudo: sub makerat() { return 3/5; }; my Rat $r (:$numerator, :$denominator) = foo()... beaten to the unch

[17:52] <p6eval> rakudo 3704a2: OUTPUT«Confused at line 11, near "my Rat $r "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[17:52] <colomon> punch

[17:52] <jnthn> That one *was* real fun to make work...

[17:52] <jnthn> I needs to blog about that stuff. :-)

[17:52] <colomon> jnthn++

[17:53] *** jferrero left
[17:54] *** cdarroch left
[17:56] *** nbrown joined
[17:57] *** cdarroch joined
[17:57] *** cdarroch left
[17:57] *** cdarroch joined
[18:00] *** ignacio_ left
[18:00] *** stephenlb joined
[18:02] <colomon> working $work build!  \o/

[18:04] *** meppl joined
[18:05] *** lichtkind joined
[18:07] *** nbrown_ joined
[18:10] *** nbrown left
[18:10] *** nbrown_ is now known as nbrown

[18:15] *** ignacio_ joined
[18:23] <colomon> hey, the release announcement just popped up in my mailbox!  \o/

[18:23] *** visitor9 joined
[18:24] <visitor9> Has any work begun on a Perl 6 binding to a GUI toolkit? Which one are you most interested in for Perl 6?

[18:25] <Su-Shee> gtk

[18:25] <Su-Shee> qt

[18:25] <arnsholt> AFAIK the native language bindings are a bit underspecified ATM

[18:25] <arnsholt> But Parrot as a native call interface so it's possible, but it'll be Rakudo-specific

[18:26] <visitor9> Does that mean, if someone writes PIR bindings to a GUI toolkit, then any Parrot-hosted lang can use them?

[18:27] <arnsholt> I think so

[18:27] <arnsholt> At least if you don't rely on any of the Rakudo data-type stuff

[18:29] *** SmokeMachine left
[18:29] <lichtkind> Su-Shee: kam die einteilung in unterseiten auf perl6.org auch von dir?

[18:42] *** payload left
[18:42] <Su-Shee> lichtkind: nur die idee/vorschlag. 

[18:42] *** ignacio_ left
[18:42] <lichtkind> Su-Shee: gut, danke

[18:44] *** nbrown left
[18:44] *** payload joined
[18:46] *** quietfanatic left
[18:47] <mathw> good localtime

[18:47] <mathw> Is there anything I could look at in Rakudo this evening that would be helpful?

[18:49] <jnthn> mathw: A lot of S03-smartmatch/*.t is still commented out in t/spectest.data

[18:49] <jnthn> mathw: I suspect a bunch of them may be not too hard to put back (the non-syntactic ones, anyways).

[18:49] <mathw> okay

[18:49] <mathw> I'll take a look

[18:49] <mathw> just waiting for rakudo to update and recompile

[18:49] <jnthn> Some of it may be review alpha, copy, paste. :-)

[18:50] <jnthn> Some of it may be re-write because the previous impl was either (a) in PIR not Perl 6 or (b) sucks. :-)

[18:50] <mathw> :)

[18:50] <jnthn> (or maybe (c) the spec changed...)

[18:50] <mathw> I'll be asking for help I'm sure

[18:50] <jnthn> I need to go buy food now (which is why it's just started to rain heavily, I guess...)

[18:51] <mathw> but I'm determined to do something useful from time to time instead of just lingering and talking like I used to do

[18:51] <mathw> hah

[18:51] <jnthn> But will be around and probably Rakudo-ing. :-)

[18:51] <mathw> yes it tends to work that way doesn't it

[18:51] *** nbrown joined
[18:51] <jnthn> Thing is, I don't think it's rained all the rest of the day! :-)

[18:51] <mathw> typical

[18:51] <mathw> I'm also trying to cope with my cat, who thinks he should be sitting in front of the screen

[18:52] *** visitor9 left
[18:52] <jnthn> mathw: Clearly he wants to see some lolcats....or the McDonalds site.

[18:53] <PerlJam> If *+* comes to mean { $^a + $^b }, then I guess all of those cool things we wrote like (*** + ***).(2) will have to become (*** + ***).(2,2 ...) or something

[18:53] <mathw> ah, he's wandered off now

[18:53] *** SmokeMachine joined
[18:54] <mathw> one day I'll find an ethernet cable lying around that he's been plugging himself into or something

[18:56] * jnthn -> getting wet buying stuff to cook for dinner

[18:59] *** ash__ joined
[19:00] *** ignacio_ joined
[19:01] *** ShaneC joined
[19:02] *** chromatic joined
[19:04] *** nbrown left
[19:09] *** nbrown joined
[19:25] * jnthn back

[19:25] <mathw> Well

[19:26] <mathw> I have discovered that Rat doesn't have an ACCEPTS method

[19:26] <mathw> alpha: ('1.2' ~~ 1.2).say

[19:26] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[19:26] <mathw> rakudo: ('1.2' ~~ 1.2).say

[19:26] <p6eval> rakudo 3704a2: OUTPUT«Method 'ACCEPTS' not found for invocant of class 'Rat'␤current instr.: 'infix:<~~>' pc 211284 (src/gen/perl6-actions.pir:15386)␤»

[19:27] <mathw> what I haven't figured out is where alpha keeps it

[19:27] <mathw> or if alpha is cheating

[19:28] <jnthn> src/setting/Rat.pm moybe the first place to look

[19:28] <PerlJam> you're looking for an alpha rat?

[19:29] <PerlJam> :)

[19:29] <mathw> har

[19:29] <ash__> do they have alphas? just curious

[19:29] <mathw> jnthn: I looked in there, no dice

[19:29] <ash__> what does it inherit from? 

[19:30] <ash__> did you check its parent? 

[19:30] <ash__> alpha: say Rat.^methods(:local); 

[19:30] <p6eval> alpha 30e0ed: OUTPUT«predsecnudenumeratorsuccNumdenominatorsignperlabsStrnew␤»

[19:30] <ash__> alpha: say ~Rat.^parents;

[19:30] <p6eval> alpha 30e0ed: OUTPUT«Any() Object()␤»

[19:31] <mathw> I've got a local tree with alpha, so I'm poking through that now

[19:31] <ash__> rakudo: say Rat.^methods(:local); # does this work now? 

[19:31] <p6eval> rakudo 3704a2: OUTPUT«absStrsecaccessor_helper_roaccessor_helper_roRatnewpredIntBoolnudesuccNumsignperl␤»

[19:32] <ash__> ooo, jnthn++ fixed introspection, at least some of it, woot

[19:33] <ash__> what does nude do on Rat?

[19:33] <PerlJam> ash__: numerator, denominator

[19:33] <PerlJam> nu de

[19:34] <mathw> okay I have no idea what alpha's doing

[19:34] <ash__> ah, cool

[19:34] <mathw> I guess it falls back to Any

[19:35] <ash__> rakudo: (3, 4, 1).sort; # :-( 

[19:35] <p6eval> rakudo 3704a2:  ( no output )

[19:36] <ash__> hmmm that gave me an error a second ago

[19:36] <ash__> rakudo: say ~Any.^methods(:local).sort;

[19:36] <p6eval> rakudo 3704a2: OUTPUT«Method 'sort' not found for invocant of class 'Array'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[19:37] <mathw> rakudo: (2.3 == 2.3).say

[19:37] <p6eval> rakudo 3704a2: OUTPUT«1␤»

[19:38] <colomon> alpha: ('1.2' ~~ 6/5).say

[19:38] <p6eval> alpha 30e0ed: OUTPUT«Method 'ACCEPTS' not found for invocant of class 'Rat'␤in Main (file src/gen_setting.pm, line 324)␤»

[19:38] <colomon> 1.2 isn't a Rat in alpha.

[19:39] <mathw> aaah

[19:39] <mathw> that makes sense

[19:39] <mathw> so the question is, which branch is correct about that

[19:39] <mathw> rakudo: 1.2.WHAT.say

[19:39] <p6eval> rakudo 3704a2: OUTPUT«Rat()␤»

[19:39] <colomon> Well, 1.2 is definitely supposed to be a Rat.

[19:39] <mathw> alpha: 1.2.WHAT.say

[19:39] <p6eval> alpha 30e0ed: OUTPUT«Num()␤»

[19:39] <colomon> Whether or not Rats should have an ACCEPTS, I dunno.

[19:39] <mathw> okay

[19:40] <mathw> well there should be some way to smartmatch it

[19:40] <colomon> Ah, right, that makes perfect sense.  :)

[19:40] <jnthn> RAt should have ACCEPTS

[19:40] <jnthn> Should do what == does, I suspect.

[19:40] <colomon> hold on, let me poke at the code.

[19:40] <PerlJam> Was REJECTS speced away?

[19:41] <colomon> Hmmm... I think == is just relying on Nums to do the work.

[19:41] <ash__> i shouldn't ACCEPTS exist on all objects? 

[19:41] <jnthn> colomon: Maybe - == could be overloaded for Rat though

[19:41] <colomon> probably makes sense to do so.

[19:42] <jnthn> But an ACCEPTS that just does $topic == self should be enough, I think.

[19:42] * mathw is trying that at the moment

[19:42] <mathw> I had thought of that, and then thought hang on... isn't that a bit simple

[19:42] <mathw> and then I thought well why shouldn't it be

[19:43] <mathw> !

[19:43] <mathw> okay

[19:43] <mathw> I don't know what just happened

[19:43] * mathw pokes

[19:44] <colomon> tell us more?

[19:45] <mathw> well I gave Rat an ACCEPTS

[19:45] <mathw> and I ran the same test, which does '1.2' ~~ 1.2

[19:45] <mathw> and now it says "Use of type object as value"

[19:45] <colomon> what were the arguments to ACCEPTS?

[19:46] <mathw> hold that thought

[19:46] <mathw> food time...

[19:51] <ash__> i think method ACCEPTS($self:, $other) {...} is the general definition of ACCEPTS... 

[19:52] <jnthn> rakudo: say '1.2' == 1.2

[19:52] <p6eval> rakudo 3704a2: OUTPUT«1␤»

[19:52] <jnthn> rakudo: Rat.^add_method('ACCEPTS', method ($topic) { self == $topic }); say '0.5' ~~ 1/2

[19:52] <p6eval> rakudo 3704a2: OUTPUT«1␤»

[19:52] <ash__> is there an overall numeric class/role that all numberish objects use? 

[19:52] <jnthn> Numeric

[19:53] <colomon> but it's NYI

[19:53] <ash__> okay, was wondering about that, Rat.^parents; only returns Any, Mu

[19:54] <ash__> is it a role? probably? 

[19:54] <colomon> yes

[19:54] <colomon> actually Rat does Numeric and Real.

[19:54] <colomon> and eventually Rational, I think...

[19:54] <ash__> how do you get a list of what roles an object has applied to it? 

[19:56] <jnthn> ash__: .^roles

[19:56] <jnthn> ash__: Roles aren't parents. :-)

[19:57] <ash__> yeah, i know, i just wasn't sure where they'd be stored

[19:59] <PerlJam> rakudo: my $a; say $a.^methods.join(":")

[19:59] <p6eval> rakudo 3704a2: OUTPUT«BUILDALL:new:Bool:say:print:defined:REJECTS:BUILD:clone:WHICH:CREATE:Capture:PARROT:bless:WHENCE:WHERE:list::notdef␤»

[20:00] <PerlJam> Why is there an empty method name just before .notdef ?

[20:02] <jnthn> Good question.

[20:06] <ash__> rakudo: my $a; say $a.^methods.map({ say $_; });

[20:06] <p6eval> rakudo 3704a2: OUTPUT«WHERE␤list␤␤notdef␤BUILDALL␤new␤Bool␤say␤print␤defined␤REJECTS␤BUILD␤clone␤WHICH␤CREATE␤Capture␤PARROT␤bless␤WHENCE␤1111111111111111111␤»

[20:06] <ash__> is my 1111111111111111111 === to your blank? 

[20:07] <ash__> oh, um no, i see a \n\n in there, nevermind, thats not it 

[20:07] <PerlJam> ash__: those 1s are the return values from each say

[20:07] <ash__> still, 1111111111111111111 is an odd result 

[20:07] <ash__> doh

[20:07] <ash__> yup, i see that now

[20:08] *** hercynium left
[20:09] <ash__> rakudo: my $a; $a.^methods.map({ say $_; });

[20:09] <p6eval> rakudo 3704a2:  ( no output )

[20:09] <ash__> why does that give no output? 

[20:09] <ash__> is it being lazy?

[20:10] <PerlJam> rakudo: my $a; $a.^methods.map({ say $_; }); say "hi";

[20:10] <p6eval> rakudo 3704a2: OUTPUT«hi␤»

[20:10] <PerlJam> rakudo: my $a; my @a = $a.^methods.map({ say $_; }); say "hi";

[20:10] <p6eval> rakudo 3704a2: OUTPUT«␤notdef␤BUILDALL␤new␤Bool␤say␤print␤defined␤BUILD␤REJECTS␤clone␤WHICH␤CREATE␤Capture␤PARROT␤bless␤WHENCE␤WHERE␤list␤hi␤»

[20:11] <PerlJam> ash__: I'm not sure if it has something to do with being in sink context, but that coupled with laziness is probably it.

[20:11] <mathw> okay

[20:11] <mathw> food is eaten

[20:11] <mathw> just re-gathering my thoughts

[20:12] <ash__> how would one make that not-lazy? eager()? 

[20:12] <PerlJam> rakudo: my $a; eager $a.^methods.map({ say $_; }); say "hi";

[20:12] <p6eval> rakudo 3704a2: OUTPUT«WHICH␤CREATE␤Capture␤PARROT␤bless␤WHENCE␤WHERE␤list␤␤notdef␤BUILDALL␤new␤Bool␤print␤say␤defined␤BUILD␤REJECTS␤clone␤hi␤»

[20:13] <PerlJam> rakudo: sub foo (*@_) { }; my $a; foo $a.^methods.map({ say $_; }); say "hi";

[20:13] <p6eval> rakudo 3704a2: OUTPUT«bless␤WHENCE␤WHERE␤list␤␤notdef␤BUILDALL␤new␤Bool␤say␤print␤defined␤BUILD␤REJECTS␤clone␤WHICH␤CREATE␤Capture␤PARROT␤hi␤»

[20:13] <PerlJam> rakudo: my $a; @($a.^methods.map({ say $_; })); say "hi";

[20:13] <p6eval> rakudo 3704a2: OUTPUT«hi␤»

[20:13] <PerlJam> rakudo: my $a; ($a.^methods.map({ say $_; })); say "hi";

[20:13] <p6eval> rakudo 3704a2: OUTPUT«hi␤»

[20:14] <mathw> ah

[20:14] <mathw> it looks like my ACCEPTS works

[20:14] <mathw> there's something else wrong with the test case which triggered me to add it

[20:15] <mathw> no there isn't

[20:15] <mathw> I'm misreading

[20:15] <mathw> this is another problem, with the next case

[20:15] <mathw> woo

[20:15] <ash__> rakudo: my $a; eager($a.^methods.map({ say $_. }))

[20:15] <p6eval> rakudo 3704a2: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[20:15] <ash__> eager() works

[20:15] <ash__> oops

[20:16] <ash__> rakudo: my $a; eager($a.^methods.map({ say $_ }))

[20:16] <p6eval> rakudo 3704a2: OUTPUT«BUILDALL␤new␤Bool␤say␤print␤defined␤REJECTS␤BUILD␤clone␤WHICH␤CREATE␤Capture␤PARROT␤bless␤WHENCE␤WHERE␤list␤␤notdef␤»

[20:16] <PerlJam> rakudo: my $a;  for $a.^methods { say $_ }

[20:16] <p6eval> rakudo 3704a2: OUTPUT«␤notdef␤BUILDALL␤new␤Bool␤print␤say␤defined␤BUILD␤REJECTS␤clone␤WHICH␤CREATE␤Capture␤PARROT␤bless␤WHENCE␤WHERE␤list␤»

[20:17] <PerlJam> huh.

[20:17] <PerlJam> I don't see the extra empty one in that list  (using the for loop)

[20:18] <PerlJam> rakudo: my $a;  for $a.^methods { say "<<$_>>" }

[20:18] <p6eval> rakudo 3704a2: OUTPUT«<<BUILDALL>>␤<<new>>␤<<Bool>>␤<<say>>␤<<print>>␤<<defined>>␤<<REJECTS>>␤<<BUILD>>␤<<clone>>␤<<WHICH>>␤<<CREATE>>␤<<Capture>>␤<<PARROT>>␤<<bless>>␤<<WHENCE>>␤<<WHERE>>␤<<list>>␤<<>>␤<<notdef>>␤»

[20:18] *** hercynium joined
[20:18] <ash__> it was first

[20:18] <PerlJam> oh, it was at the beginning the first time

[20:19] <PerlJam> rakudo: my $a;  say $a.WHAT;

[20:19] <p6eval> rakudo 3704a2: OUTPUT«Mu()␤»

[20:19] <PerlJam> rakudo: my $a;  say $a."WHAT";

[20:19] <p6eval> rakudo 3704a2: OUTPUT«Quoted method name requires parenthesized arguments at line 11, near ";"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[20:19] *** vamped joined
[20:19] <PerlJam> rakudo: my $a;  say $a."WHAT"();

[20:19] <p6eval> rakudo 3704a2: OUTPUT«Mu()␤»

[20:19] <PerlJam> rakudo: my $a;  say $a.""();

[20:19] <p6eval> rakudo 3704a2: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[20:19] <mathw> http://github.com/mattw/rakudo/commit/3b5214b1cc62f6e9ea5fe640c3a5a6a3373a1e2a <- trivial, really. Next problem...

[20:19] <PerlJam> rakudo: my $a;  say $a();

[20:19] <p6eval> rakudo 3704a2: OUTPUT«invoke() not implemented in class 'Mu'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:20] <PerlJam> btw, rakudo++ for some awesome error messages 

[20:21] <PerlJam> sometimes they make up for the LTA ones

[20:21] *** coke joined
[20:21] <mathw> okay I'm not sure about this test

[20:21] <coke> Hey, the rakudo notice that just hit my inbox says it requires parrot 2.1.0

[20:21] <mathw> ok(Mu ~~ 0);

[20:22] <mathw> that's what's making rakudo complain about the use of a type object as a value

[20:22] <mathw> I'm not sure what the purpose of this test is

[20:22] <PerlJam> rakudo: Mu ~~ 0

[20:22] <p6eval> rakudo 3704a2: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[20:22] <PerlJam> rakudo: Mu() ~~ 0

[20:22] <p6eval> rakudo 3704a2: OUTPUT«Could not find non-existent sub &Mu␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:22] <PerlJam> rakudo: my $a;  $a ~~ 0

[20:22] <p6eval> rakudo 3704a2: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[20:23] <coke> mberends: ping.

[20:23] * mathw looks at Int.ACCEPTS

[20:23] <mberends> coke: pong

[20:24] <coke> mberends: did you send out the latest release notice on rakudo ?

[20:24] <mathw> rakudo: my $a; $a == 0;

[20:24] <p6eval> rakudo 3704a2: OUTPUT«No applicable candidates found to dispatch to for 'infix:<==>'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:24] *** iblechbot joined
[20:24] <coke> (just making sure you is he. =-)

[20:24] *** justatheory left
[20:25] <mberends> coke: I sent emails to p6a etc, but only some have arrived :-/

[20:25] <coke> mberends: I just got one.

[20:25] <mberends> hmm, moritz_++ also tried to send some more

[20:25] <coke> mberends: you say it requires 2.1.0 - we cut 2.1.1 just for you guys to fix the memory leak that was identified in here yesterday.

[20:25] <coke> so if anyone tries to run rakudo agains the 2.1.0 release and not 2.1.1 or trunk, it's probably going to be less than awesome.

[20:26] <coke> Not sure if you want to put out an addendum, or just deal with it if anyone asks, but I wanted to let you know.

[20:26] *** cosimo left
[20:26] <mberends> coke: sorry, afk for dinner, talk in 45 mins?

[20:26] *** cosimo joined
[20:26] <coke> I'm done. just an FYI. enjoy your dinner!

[20:27] <coke> (curses, now I want food!)

[20:38] <jnthn> D'oh, the release announcement shoulda mentioned 2.1.1...

[20:39] *** colomon left
[20:39] <mathw> jnthn: the next test I've got that fails tries to do Mu ~~ 0. This seems odd.

[20:40] <jnthn> mathw: Mu == 0 is also problematic.

[20:40] <mathw> yes

[20:40] <mathw> rakudo: Mu == 0

[20:40] <p6eval> rakudo 3704a2: OUTPUT«No applicable candidates found to dispatch to for 'infix:<==>'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:40] <jnthn> Right.

[20:41] <ash__> undef was the old Mu? sorta... so, isn't that like saying my $a; $a ~~ 0? that seems like a valid test, IMO 

[20:41] <mathw> rakudo: Mu ~~ 0

[20:41] <p6eval> rakudo 3704a2: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[20:41] <jnthn> ash__: Yes

[20:41] <PerlJam> rakudo: 0 ~~ Mu

[20:41] <mathw> rakudo: my $a; $a ~~ 0

[20:41] <jnthn> I agree it should give True

[20:41] <p6eval> rakudo 3704a2:  ( no output )

[20:41] <p6eval> rakudo 3704a2: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[20:41] <ash__> rakudo: Mu ~~ Mu;

[20:41] <p6eval> rakudo 3704a2:  ( no output )

[20:41] <jnthn> I wonder if the answer is to define like

[20:42] <mathw> Out of experimentation, I moved Int.ACCEPTS from PIR to Perl 6, and it swaps over to the 'no applicable candidates' message for infix:<==>

[20:42] <PerlJam> What question is Mu ~~ 0 asking?

[20:43] <mathw> I don't know

[20:44] <mathw> other than that presmuably after my $a, $a contains Mu, and if you numify Mu maybe you get 0 so it should be true by that logic

[20:44] <jnthn> our multi infix:<==>(Mu $a where .notdef, $b) { 0 == $b } # or some such

[20:44] <jnthn> Essentially, the problem is...

[20:44] <jnthn> our multi infix:<==>($a, $b) { ... } won't accept Mu as a parameter.

[20:44] <jnthn> before undef ~~ Any, so it all worked out

[20:44] <mathw> Please don't say we have to add Mu overloads

[20:44] <jnthn> mathw: Yeah, but it's infix:<==> that numifies.

[20:45] <jnthn> mathw: Well, yeah, I thought that seemed...oddish too.

[20:45] <mathw> I suppose we do have to teach it what to do with Mu

[20:45] <jnthn> Well, undefineds generally

[20:45] <jnthn> oh, no, most of them are handled already

[20:46] <jnthn> rakudo: our multi infix:<==>(Mu $a where .notdef, $b) { 0 == $b }; my $a; say $a == 1; say $a == 0;

[20:46] <p6eval> rakudo 3704a2: OUTPUT«0␤1␤»

[20:47] <PerlJam> rakudo: say Mu.^parents

[20:47] <p6eval> rakudo 3704a2: OUTPUT«␤»

[20:47] <PerlJam> rakudo: say Any.^parents

[20:47] <p6eval> rakudo 3704a2: OUTPUT«Mu()␤»

[20:47] <mathw> jnthn: that simple?

[20:48] <PerlJam> the smart-match table in S03 is written in terms of Any, and doesn't mention Mu

[20:48] <ash__> that sounds like it needs updating, IMO... since Mu is kinda important, does it mention undef? 

[20:49] *** andy1 joined
[20:49] <jnthn> ash__: Well, that's the problem

[20:49] *** SmokeMachine left
[20:49] <jnthn> Mu !~~ Any, whereas the old undef ~~ Any

[20:49] <jnthn> So we never got into this kind of problem before.

[20:50] <jnthn> I know we can multi our way out of the situation. :-)

[20:50] <jnthn> But that feels slightly...inelegant.

[20:50] <ash__> yeah

[20:50] <ash__> maybe some of the Any functionality should have fallbacks for when you get passed a Mu 

[20:50] <ash__> or maybe Mu should be converted to an Any? /shrug

[20:51] <PerlJam> rakudo: my $a;  say Any ~~ $a;

[20:51] <ash__> or add some other definitions for Mu cases 

[20:51] <p6eval> rakudo 3704a2: OUTPUT«1␤»

[20:51] <mathw> jnthn: is there any particular reason why Int's ACCEPTS is defined in PIR?

[20:52] <PerlJam> rakudo: say Any ~~ Mu;

[20:52] <p6eval> rakudo 3704a2: OUTPUT«1␤»

[20:52] <mathw> aargh

[20:52] <mathw> head asplode

[20:53] <mathw> clearly I need sleep, not Perl

[20:53] <jnthn> mathw: Not that I know of.

[20:53] <PerlJam> rakudo: class X { }; say Mu ~~ X();

[20:53] <p6eval> rakudo 3704a2: OUTPUT«Could not find non-existent sub &X␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:53] <mathw> I will come back to rakudo tomorrow

[20:53] <PerlJam> rakudo: class X { }; say Mu ~~ X;

[20:53] <mathw> when I'm awake

[20:53] <p6eval> rakudo 3704a2: OUTPUT«0␤»

[20:53] <mathw> and maybe pick something less mind-bending to work on :)

[20:54] <PerlJam> I'm thinking that Mu ~~ * should always be false unless it's Mu ~~ Mu

[20:54] <mathw> the change I did make is here: http://github.com/mattw/rakudo/commit/3b5214b1cc62f6e9ea5fe640c3a5a6a3373a1e2a which adds Rat.ACCEPTS. not spectested.

[20:54] * mathw -> blessed sleep

[20:56] <jnthn> night, mathw 

[21:00] *** macae left
[21:00] <PerlJam> rakudo: sub foo { }; say &foo.arity; say &foo.count;

[21:00] <p6eval> rakudo 3704a2: OUTPUT«0␤0␤»

[21:01] <PerlJam> rakudo: sub foo ($,$,$) { }; say &foo.arity; say &foo.count;

[21:01] <p6eval> rakudo 3704a2: OUTPUT«3␤3␤»

[21:01] <PerlJam> rakudo: sub foo ($,$,$?) { }; say &foo.arity; say &foo.count;

[21:01] <p6eval> rakudo 3704a2: OUTPUT«3␤3␤»

[21:01] <PerlJam> rakudo: sub foo ($,$ = 2,$ = 3) { }; say &foo.arity; say &foo.count;

[21:01] <p6eval> rakudo 3704a2: OUTPUT«1␤3␤»

[21:01] <PerlJam> rakudo: sub foo ($,$? = 2,$? = 3) { }; say &foo.arity; say &foo.count;

[21:01] <p6eval> rakudo 3704a2: OUTPUT«1␤3␤»

[21:02] <PerlJam> rakudo: sub foo ($,$?,$? = 3) { }; say &foo.arity; say &foo.count;

[21:02] <p6eval> rakudo 3704a2: OUTPUT«2␤3␤»

[21:02] <jnthn> PerlJam: $? is perhaps getting swalled by the twigil rule, though I suspect wrongly...

[21:02] <PerlJam> yeah, I wasn't sure.

[21:03] <PerlJam> rakudo: sub foo ($a,$b?,$c? = 3) { }; say &foo.arity; say &foo.count;

[21:03] <p6eval> rakudo 3704a2: OUTPUT«1␤3␤»

[21:03] <jnthn> rakudo: sub foo ($,$,$?) { }; say &foo.arity; say &foo.count;

[21:03] <p6eval> rakudo 3704a2: OUTPUT«3␤3␤»

[21:04] <jnthn> rakudo: sub foo ($,$,$? ) { }; say &foo.arity; say &foo.count;

[21:04] <p6eval> rakudo 3704a2: OUTPUT«3␤3␤»

[21:04] <PerlJam> should be easyish to fix though.

[21:04] <jnthn> token twigil:sym<?> { <sym> }

[21:04] <jnthn> Hmm

[21:04] <jnthn> Maybe that one wants a <?before \w>

[21:04] <jnthn> Like some of the other twigil tokens.

[21:04] <jnthn> TimToady: See ^

[21:05] <PerlJam> add something like <before: <ident> > for twigils (I don't remember the exact syntax)

[21:05] <jnthn> Well, STD does it for some twigils.

[21:06] <jnthn> But not all of them.

[21:06] <jnthn> I'd rather check if it's an oversight or deliberate that ? wasn't given such a thing.

[21:06] <PerlJam> ah, I see that.

[21:06] <jnthn> But yes, in theory it'll fix it.

[21:07] <PerlJam> whoa ... what's <!!worry ...>  ?

[21:07] <ash__> what exactly is the point of ? in a parameter? like, sub foo($a!) {}; vs sub foo($a) { }; if i call it with no parameters it gives an error either way...

[21:07] <ash__> err s/?/!/ 

[21:08] *** clsn joined
[21:10] <PerlJam> ah ... S05++  I need to absorb the spec a little more.

[21:10] <clsn> Having a weird experience with rakudo lately.  Even with new rebuilt parrot and all rebuilt, the simple script 'token xx { "x" } say ("x" ~~ /<xx>/);' gives me an error.

[21:10] <jnthn> Makes it optional...

[21:11] <clsn> Anything with named regexps I think, though not the builtin ones.

[21:12] <jnthn> clsn: Hi! :-) Did you just grab the latest release or are you working from a git clone?

[21:12] <TimToady> testing a twigil fix that generalizes \w to all twigils

[21:12] <clsn> git clone.

[21:12] <jnthn> clsn: Basically though, a branch landed recently that has caused various regressions.

[21:13] <jnthn> clsn: In the meantime, you may wish to switch to the "alpha" branch while the fallout gets cleared up. :-)

[21:13] *** snarkyboojum joined
[21:13] <clsn> OK, thanks.  I was worried somethng really inexplicable was wrong with my system if nobody else heard of this...

[21:14] *** wknight8111 joined
[21:14] <jnthn> clsn: No, nothings "wrong" as such - just that a big bunch of internals changes landed and we're still putting various bits back together again.

[21:14] <TimToady> PerlJam: <!! is just like <? except that negative lookaheads aren't counting in LTM

[21:14] <TimToady> so it takes the LTM from after it

[21:14] <clsn> jnthn: Is the alpha branch not in git?  git branch isn't showing it after pull.

[21:14] <jnthn> clsn: I wrote a blog post about it here, if you like: http://use.perl.org/~JonathanWorthington/journal/40190

[21:15] <TimToady> whereas <? steals the LTM baton and doesn't use anything after

[21:15] <jnthn> clsn: Ah, you may need to git checkout origin/alpha

[21:15] <clsn> Oh, great, I am curious as to *what* happened too.

[21:15] <clsn> OK, thanks again!

[21:15] <PerlJam> TimToady: yeah, I got that from S05.  TimToady++ for writing this stuff down  :)

[21:15] * jnthn is not a git wizz kid :-)

[21:15] <clsn> Me either; we'll fake it.

[21:17] <pugs_svn> r29781 | lwall++ | [STD] generalize \w lookahead to all twigils 

[21:19] <cognominal> yea, jnthn is a wizz kid in everything programmatic.

[21:19] <ash__> jnthn, i was asking about '!' which makes parameters required, but whats the difference between foo($a) vs foo($a!) 

[21:19] <cognominal> jnthn++  for the last blog entry

[21:20] <ash__> in both cases if you say foo(); it gives an error

[21:21] <pmichaud> I see no real problem with the 2.1.1 versus 2.1.0 note in the announcement

[21:21] <pmichaud> rakudo will work with either one

[21:21] <jnthn> ash__: none

[21:22] <jnthn> ash__: It's useful on nameds

[21:22] <jnthn> ash__: Which are optional by default.

[21:22] <pmichaud> with 2.1.0 it will not be quite as nice as 2.1.1, but it will still generally work

[21:22] <jnthn> ash__: On positionals it's pretty pointless.

[21:22] <mberends> pmichaud: coke++'s point is just that the performance would be a bit less

[21:22] <ash__> okay, so, it does make a difference with named params, that makes sense 

[21:22] <chromatic> We yanked 2.1.0, so people will have to get 2.1.1.

[21:23] <mberends> ok, that solves it too

[21:23] <jnthn> pmichaud: Sure, but Parrot folks cut 2.1.1 so things would be less sucky. :-)

[21:23] <jnthn> ash__: ? is thus kinda useless on nameds. :-)

[21:23] <ash__> but not on positional 

[21:23] <jnthn> Right.

[21:23] <PerlJam> It wouldn't hurt for someone to reply to the announcement with that information.

[21:24] <pmichaud> jnthn: sure, I understand that.  But someone using --gen-parrot will end up with something that says "2.1.0", and it's also good if we can avoid the confusion

[21:24] <jnthn> pmichaud: Ah, I see.

[21:24] <mberends> pmichaud: --gen-parrot gets r44147, which is 2.1.1 in all but name...

[21:25] <chromatic> I didn't think of that, but it makes sense.

[21:25] <coke> 2.1.0 is gone?

[21:26] <pmichaud> mberends: agreed, 2.1.1 in all but name.  but someone looking at --parrot-version will see 2.1.0

[21:26] <pmichaud> pmichaud@plum:~/rakudo/parrot$ svn info | grep Revision

[21:26] <pmichaud> Revision: 44147

[21:26] <pmichaud> pmichaud@plum:~/rakudo/parrot$ ./parrot --version

[21:26] <pmichaud> This is Parrot version 2.1.0-devel built for amd64-linux.

[21:26] <mberends> I'm sorry for the confusion I've caused

[21:26] <pmichaud> there's just not a perfectly clean answer for this issue

[21:26] <pmichaud> suppose that we had detected the memory leak _after_ the rakudo release?  what would we have done then?  ;-)

[21:27] <coke> trunk can be updated with the new number, if that helps.

[21:27] <pmichaud> we'd end up with what we have now -- a rakudo release targeting 2.1.0

[21:27] <coke> I have an nqp question. ok for here?

[21:27] <pmichaud> except that it's svn number would end up pointing to a trunk version that doesn't have the leak fix, which would be less awesome than what we do have

[21:27] <pmichaud> coke: yes

[21:28] <coke> want a global in my module. can I do INIT { our $foo := 2;} and have the $foo available elsewhere in the module?

[21:28] <coke> do I have to separate the $our outside of the INITI  and the := 2 inside for that to work?

[21:29] <coke> (that /seems/ to DWIM.)

[21:29] <PerlJam> coke: our outside the INIT

[21:32] <pmichaud> our $foo;  INIT { $foo := 2 };   # I think

[21:32] <clsn> Rebuilt, doesn't fail the same, but an odd error maybe.  perl6 -e 'token xx { "x" } ; say "x" ~~ m/x/;' and the error is Confused at line 1, near "x\" ~~ m/x/"; that backslash looks strange. 

[21:33] <pmichaud> with "our" inside of the braces it limits the scope of the declaration to the INIT block

[21:33] <coke> pmichaud, PerlJam: excellent. now If I can just figure out how to say "this variable is really an int..."

[21:33] <pmichaud> coke: int as in Integer PMC or as in I register?

[21:34] <PerlJam> coke: why do you want to say "this var is an int"?

[21:34] *** dalek joined
[21:34] *** ruoso left
[21:34] <coke> I register.

[21:34] <coke> PerlJam: trying to keep it as close to the original PIR as possible.

[21:35] *** ewilhelm_ joined
[21:35] <PerlJam> coke: luckily you can use PIR in NQP  :)

[21:35] *** ewilhelm left
[21:35] <pmichaud> coke: welcome to my pain -- Parrot doesn't allow lexicals to refer to registers.

[21:35] <pmichaud> coke: welcome to my pain -- Parrot doesn't allow lexicals to refer to anything but PMCs.

[21:36] <pmichaud> I'm working on ways to make local declarations that might do that for specific block situations... but there's no general solution in Parrot for it.

[21:36] <pmichaud> in the specific example you give, there'd be almost no way to tie a package-scoped variable to a register.

[21:37] <coke> ok. might be to nest a lot of pir::opcodes to get this. Makes it a terrible example to convert to NQP. =-)

[21:37] <pmichaud> could be, yes.  You can also still do Q:PIR for long blocks of PIR

[21:37] <coke> ... this is so short, not worth converting then.

[21:38] <coke> (parrot's Math/Rand)

[21:38] * PerlJam would probably opt for Q:PIR  in Coke's case 

[21:41] <coke> PerlJam: the PIR itself is already so small, wrapping it in NQP be silly at that point.

[21:41] <coke> "would be"

[21:41] <coke> I'll pick a larger, non-math related sample to hack on.

[21:43] *** dalek left
[21:44] *** dalek joined
[21:47] *** ignacio_ left
[21:48] <chromatic> I have some ideas on how to make lexicals refer to primitives.

[21:48] <chromatic> How much does Rakudo benefit from that?

[21:49] <jnthn> May be a win.

[21:49] <jnthn> Though probably not for anything we implemented yet.

[21:49] <pmichaud> it'd be much bigger benefit for NQP than for Rakudo

[21:49] <jnthn> pmichaud: That's true...

[21:50] <pmichaud> Rakudo's types are pretty heavily tied up in PMCs -- they have to be, because so much of Perl 6 is method-based

[21:50] <jnthn> pmichaud: Int can't go in an I register, but int can.

[21:50] <pmichaud> but NQP wants to be able to emulate the vm, and not having a way to declare register types as lexicals (or access non-pmc registers from nested lexical scopes) really limits their utility

[21:51] <pmichaud> jnthn: sure, but can you keep track of type constraints and rw-ness?

[21:51] <TimToady> ash__: dunno if anyone answered this, but sink context is eager

[21:51] <pmichaud> anyway, I stand corrected -- Rakudo as it stands today can't make much use of them, but they're absolutely needed for us to be able to do much with native types in Perl 6. :)

[21:51] <jnthn> pmichaud: It's probably the same machinary we'd need to handle auto-boxing.

[21:52] <jnthn> pmichaud: Perhaps.

[21:52] <jnthn> pmichaud: I didn't work out a detailed implementation plan.

[21:52] <pmichaud> jnthn: right, I agree.

[21:52] <pmichaud> Anyway, lexicals as native registers would be a great benefit to NQP and nqp authors.

[21:52] <TimToady> ash__: that is, it's *specced* to be eager

[21:53] *** hatseflats left
[21:53] *** hatseflats joined
[21:53] <PerlJam> rakudo: my $a;  $a.^methods.map({ .say });

[21:53] <p6eval> rakudo 3704a2:  ( no output )

[21:53] <PerlJam> TimToady: so that should output all of the methods?

[21:53] <jnthn> pmichaud: Though my intuition is that other register types as lexicals will (a) certainly help NQP, which in turn helps Rakudo since parts of it are written in NQP and (b) stands a change of being useful for doing lowercase types in Perl 6.

[21:54] <jnthn> s/change/chance/

[21:54] <pmichaud> jnthn: agreed.

[21:54] <TimToady> PerlJam: yes, in theory, though maybe sink needs to be strictly eager

[21:54] <pmichaud> sink is on my list of rsn things to implement

[21:55] <jnthn> pmichaud: The overall plan for the lowercased types needs to include how object attributes work out too.

[21:55] <ash__> what makes something 'sink context'? 

[21:56] <pmichaud> jnthn: I agree.  Not sure what that will look like.

[21:56] <jnthn> pmichaud: Terrifying.

[21:56] <jnthn> :-D

[21:57] <TimToady> ash__: being a non-final statement, for one

[21:57] <TimToady> rakudo: my $a; $a.^method.map({ .say }); 42;

[21:57] <p6eval> rakudo 3704a2: OUTPUT«Method 'method' not found for invocant of class 'ClassHOW'␤current instr.: '!dispatch_.^' pc 410 (src/glue/dispatch.pir:100)␤»

[21:57] <TimToady> rakudo: my $a = 2; $a.^method.map({ .say }); 42;

[21:57] <p6eval> rakudo 3704a2: OUTPUT«Method 'method' not found for invocant of class 'ClassHOW'␤current instr.: '!dispatch_.^' pc 410 (src/glue/dispatch.pir:100)␤»

[21:57] <pmichaud> rakudo doesn't have sink context at all yet.  It needs a good way to detect the non-final statements.  :)

[21:57] <TimToady> rakudo: my $a = 2; $a.^methods.map({ .say }); 42;

[21:58] <p6eval> rakudo 3704a2: OUTPUT«maximum recursion depth exceeded␤current instr.: 'perl6;Seq;!fill' pc 13548 (src/builtins/Routine.pir:21)␤»

[21:58] <pmichaud> the current "fix" is to explicitly request eager, atm

[21:58] <TimToady> O_o

[21:58] <pmichaud> rakudo:  my $a = 2;  eager $a.^methods.map({ .say });

[21:58] <p6eval> rakudo 3704a2: OUTPUT«maximum recursion depth exceeded␤»

[21:58] <TimToady> rakudo: my $a = 2; sink $a.^methods.map({ .say });

[21:58] <pmichaud> ....which appears to point to a different problem :)

[21:58] <p6eval> rakudo 3704a2:  ( no output )

[21:59] <PerlJam> 2 bugs in one!  :)

[21:59] <pmichaud> rakudo:  my $a = 2;   sink $a;

[21:59] <p6eval> rakudo 3704a2: OUTPUT«Could not find non-existent sub &sink␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:59] <pmichaud> Right.

[21:59] <pmichaud> 21:54 <pmichaud> sink is on my list of rsn things to implement

[21:59] <TimToady> rakudo: my $a = 2; gather $a.^methods.map({ .say });

[21:59] <p6eval> rakudo 3704a2:  ( no output )

[22:00] <TimToady> gather is also supposed to be void inside

[22:00] <PerlJam> rakudo: my $a = 2; say $a.^methods

[22:00] <p6eval> rakudo 3704a2: OUTPUT«maximum recursion depth exceeded␤current instr.: 'perl6;Seq;!fill' pc 13548 (src/builtins/Routine.pir:21)␤»

[22:00] <PerlJam> rakudo: my $a; say $a.^methods

[22:00] <p6eval> rakudo 3704a2: OUTPUT«REJECTSBUILDcloneWHICHCREATECapturePARROTblessWHENCEWHERElistnotdefBUILDALLnewBoolsayprintdefined␤»

[22:00] <pmichaud> I'm guessing an issue with .^methods

[22:00] <pmichaud> on Int

[22:00] <PerlJam> rakudo: my $a = 2; say $a.WHAT

[22:00] <p6eval> rakudo 3704a2: OUTPUT«Int()␤»

[22:00] <TimToady> .WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT....

[22:01] <ash__> rakudo: my $a = 1; say $a.^methods(:local);

[22:01] <p6eval> rakudo 3704a2: OUTPUT«secACCEPTSRatIntpredBoolsuccNumsignperlWHICHabsComplexStr␤»

[22:01] <pmichaud> rakudo:  my $a = '2';  say $a.^methods

[22:01] <p6eval> rakudo 3704a2: OUTPUT«maximum recursion depth exceeded␤current instr.: 'perl6;Seq;!fill' pc 13548 (src/builtins/Routine.pir:21)␤»

[22:01] <TimToady> hmm, parent trap?

[22:01] <pmichaud> likely.

[22:02] <PerlJam> I bet Rats, Bools, Complex, and Nums do it too  :)

[22:02] <PerlJam> my $a = 3.14; say $a.^methods;

[22:02] <TimToady> I smell a Bool!

[22:02] <TimToady> ( no output )

[22:03] <PerlJam> rakudo: my $a = 3.14; say $a.^methods;

[22:03] <TimToady> ( no input either )

[22:03] <p6eval> rakudo 3704a2:  ( no output )

[22:03] * pmichaud looks forward to   has Complex $oedipus;

[22:03] <PerlJam> rakudo: my $a = Bool::True; say $a.^methods;

[22:03] <p6eval> rakudo 3704a2: OUTPUT«maximum recursion depth exceeded␤current instr.: 'perl6;Seq;!fill' pc 13548 (src/builtins/Routine.pir:21)␤»

[22:03] <TimToady> BTW, parent of Rat should be Cool rather than Any

[22:03] <PerlJam> rakudo: my $a = 4i; say $a.^methods;

[22:04] <p6eval> rakudo 3704a2:  ( no output )

[22:04] <jnthn> rakudo: my $a = 2; say $a.^methods(:local)

[22:04] <p6eval> rakudo 3704a2: OUTPUT«secACCEPTSRatIntpredBoolsuccNumsignperlWHICHabsComplexStr␤»

[22:04] <jnthn> rakudo: my $a = 2; say $a.^parents

[22:04] <p6eval> rakudo 3704a2: OUTPUT«␤»

[22:04] <TimToady> rakudo: say 2.WHAT.WHAT

[22:04] <p6eval> rakudo 3704a2: OUTPUT«Int()␤»

[22:04] <jnthn> oh wtf

[22:04] <TimToady> rakudo: say 2.WHAT.WHAT.WHAT

[22:04] <p6eval> rakudo 3704a2: OUTPUT«Int()␤»

[22:04] <jnthn> TimToady: my $a = 2; say $a.PARROT

[22:04] <jnthn> er

[22:04] <jnthn> rakudo: my $a = 2; say $a.PARROT

[22:04] <PerlJam> rakudo: say 3.14.WHAT.WHAT

[22:05] <p6eval> rakudo 3704a2: OUTPUT«Integer␤»

[22:05] <p6eval> rakudo 3704a2: OUTPUT«Rat()␤»

[22:05] <jnthn> .oO( must not use TimToady as an evalbot )

[22:05] <TimToady> timtoady deader: ( no output )

[22:05] <PerlJam> jnthn: why does .PARROT matter?

[22:06] <jnthn> PerlJam: 'cus it tells you what the thing *really* is.

[22:06] <jnthn> PerlJam: And also probably gives me a clue on how to fix the bug.

[22:06] <pmichaud> btw, it's  PARROT($foo)  now instead of $foo.PARROT

[22:06] <PerlJam> .^methods "delegates" to the .PARROTy thing?

[22:06] <jnthn> pmichaud: Huh? Both work, no?

[22:06] <pmichaud> because the .PARROT form doesn't let you see any intermediate ObjectRefs

[22:06] <jnthn> PerlJam: No

[22:06] <jnthn> PerlJam: Oh

[22:06] <pmichaud> (because they get dereferenced as part of the method call...)

[22:06] <jnthn> gah, tab complete

[22:06] <jnthn> pmichaud: Oh, good point.

[22:07] <jnthn> PerlJam: The problem is that it goes and finds the Parrot Integer PMC's PMCProxy rather than Perl 6's Int class.

[22:08] *** cls_bsd_ joined
[22:08] <PerlJam> rakudo: my $a = 3.14;  say $a.PARROT

[22:08] <p6eval> rakudo 3704a2: OUTPUT«Rat␤»

[22:09] <PerlJam> and it doesn't do that for Rats because ... ?

[22:09] <PerlJam> they happen to have the same name?

[22:09] <pmichaud> that used to not be the case, but now it is :)

[22:09] <pmichaud> my $a = 5;   say $a.PARROT;  say PARROT($a);

[22:09] <pmichaud> rakudo: my $a = 5;   say $a.PARROT;  say PARROT($a);

[22:09] <pmichaud> rakudo:  my $a = 5;  say $a;

[22:09] <pmichaud> ENOP6EVAL?

[22:09] <pmichaud> P6EVAL hateses mee?

[22:09] <pmichaud> rakudo:  say 'hello';

[22:09] <pmichaud> :-(

[22:09] <p6eval> rakudo 3704a2: OUTPUT«Integer␤Perl6Scalar->Integer␤»

[22:09] <pmichaud> rakudo: my $a = 3.14;  say $a.PARROT

[22:09] <p6eval> rakudo 3704a2: OUTPUT«5␤»

[22:09] <pmichaud> because there's no underlying Parrot type

[22:09] <p6eval> rakudo 3704a2: OUTPUT«hello␤»

[22:09] <p6eval> rakudo 3704a2: OUTPUT«Rat␤»

[22:09] *** clsn left
[22:10] <PerlJam> oh, so .PARROT lies when there's no underlying Parrot type?

[22:10] <pmichaud> no, it reports the actual Parrot type

[22:10] *** nbrown left
[22:10] *** rgrau left
[22:11] <pmichaud> rakudo:  my $a = 2;  say Parrot($a);

[22:11] <PerlJam> rakudo: class X { } ; my $a = X.new; say $a.PARROT

[22:11] <p6eval> rakudo 3704a2: OUTPUT«Could not find non-existent sub &Parrot␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:11] <p6eval> rakudo 3704a2: OUTPUT«X␤»

[22:11] <ash__> pmichaud: so, i am trying to figure out if its possible to implement nqp-rx's rx stuff with bison and flex... does that sound reasonable? just roughly speaking here, since you have already implemented it 

[22:11] *** rgrau joined
[22:11] <pmichaud> ash__: I'd be highly doubtful.

[22:11] <PerlJam> rakudo: class X { } ; my $a = X.new; say PARROT($a)

[22:11] <p6eval> rakudo 3704a2: OUTPUT«Perl6Scalar->X␤»

[22:11] <PerlJam> ah.

[22:11] *** dalek left
[22:12] <pmichaud> rakudo:  class X { } ;  say PARROT(X.new);

[22:12] <p6eval> rakudo 3704a2: OUTPUT«X␤»

[22:12] <ash__> pmichaud: i have a grammar defined in bison with flex that handles most of nqp's cases i have found, its not doing any code gen, but its parsing somewhat correctly 

[22:13] <pmichaud> ash__: are you able to parse nqp's grammar?

[22:13] *** dalek joined
[22:13] <ash__> no, not yet, if i see a grammar ID { } i just ignore whats between { } for now

[22:14] <pmichaud> ash__: well, nqp-rx's rx engine is based on its own grammar

[22:14] <pmichaud> so, you'd need to be able to parse that :-)

[22:14] <ash__> yeah, i know

[22:15] <ash__> i am trying to figure out how to write something that parses it

[22:15] <pmichaud> anyway, I'm doubtful of implementing rx with bison and flex... but that may be insufficient imagination on my part.  

[22:16] <ash__> i might just pull the contents out as a string

[22:16] <pmichaud> there's a reason I didn't head down that path in the first place :)

[22:16] <ash__> and make a custom parser to do the actual parsing of a regex 

[22:17] <ash__> i can parse http://github.com/ashgti/nq-nqp-rx/blob/master/t/basics.nqp file successfully, but its technically ignoring the stuff in token abc { } between the { }

[22:17] <PerlJam> ash__: so ... you'd be using bison/flex for what exactly?  ;)

[22:17] <ash__> learning 

[22:17] *** ggoebel joined
[22:17] <pmichaud> ash__: my mental model has always been that you start by parsing regexes first, and then build everything on top of that -- not the other way around :)

[22:17] <ash__> i have a class on compilers, and i wanted to learn how its been done in the past 

[22:17] *** payload left
[22:17] <ash__> so yacc/lex

[22:18] <PerlJam> ash__: you could write a version of NQP in C.  That would be interesting.

[22:18] <ash__> well, it parses most of nqp now, it just doesn't make any code for it

[22:18] <ash__> my plan is to have it gen code eventually, i just want to get the grammar right 

[22:19] <ash__> my biggest hurdle right now is the stuff between a { } in a token 

[22:19] <pmichaud> right

[22:19] <ash__> which is to say, a lot 

[22:19] <pmichaud> my point is that the nqp grammar is really a bunch of regexes

[22:20] *** dalek left
[22:20] <pmichaud> more to the point, nqp's codegen depends on having a regex parse tree to work from

[22:20] <ash__> i guess its a chicken and the egg problem, i am trying to write something that can parse your grammar, but it needs to be able to parse regex's so... yup, kinda why i am asking you about this 

[22:21] <pmichaud> right

[22:21] <pmichaud> in my mind, parsing regexes is the place to start

[22:21] <pmichaud> once you can parse regexes, building the rest of the grammar is really quite simple

[22:22] *** dalek joined
[22:22] <pmichaud> you can write something that parses everything but regexes, but then you're still left with the problem of "how do I parse a regex"?

[22:22] <TimToady> I don't think Mu needs to numify

[22:22] <PerlJam> rakudo:  Int.^methods.join(' ').say

[22:22] <p6eval> rakudo 3704a2:  ( no output )

[22:22] <TimToady> most of the failures we return ought to be derived from Failure or some such derived type

[22:22] <PerlJam> rakudo:  Int.^methods.join(' ').say; say "hi";

[22:22] <jnthn> TimToady: Should Mu == 0 fail?

[22:22] <p6eval> rakudo 3704a2: OUTPUT«maximum recursion depth exceeded␤current instr.: 'perl6;Seq;!fill' pc 13548 (src/builtins/Routine.pir:21)␤»

[22:23] <PerlJam> rakudo: my $a; $a.^methods.join(' ').say; say "hi";

[22:23] <TimToady> it's probably okay if it does

[22:23] <p6eval> rakudo 3704a2: OUTPUT«WHICH CREATE Capture PARROT bless WHENCE WHERE list  notdef BUILDALL new Bool print say defined BUILD REJECTS clone␤hi␤»

[22:23] <PerlJam> rakudo: my $a; $a.^methods.sort.join(' ').say; say "hi";

[22:23] <p6eval> rakudo 3704a2: OUTPUT«Method 'sort' not found for invocant of class 'Array'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:23] <jnthn> TimToady: so this is OK:

[22:23] <pmichaud> I think that Mu == 0   ought to give a "use of uninitialized..."  or something

[22:23] <jnthn> rakudo: my $a; say $a == 0;

[22:23] <p6eval> rakudo 3704a2: OUTPUT«No applicable candidates found to dispatch to for 'infix:<==>'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:23] <ash__> alpha: my $a; say $a == 0; 

[22:23] <TimToady> maybe variables should default to Any

[22:23] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤1␤»

[22:24] <pmichaud> Mu is basically our "undef".

[22:24] <TimToady> and you have to declare if you want to store a junction or a Mu

[22:24] <jnthn> pmichaud: The problem is that we fail the dispatch to ==

[22:24] <jnthn> TimToady: Maybe. ;-)

[22:24] <jnthn> TimToady: That would magic away that problem.

[22:24] <jnthn> TimToady: Trying to think of others it might make...

[22:24] <pmichaud> jnthn: we fail the dispatch to == ?

[22:24] <pmichaud> why?

[22:25] <jnthn> TimToady: Though none immediately come to mind.

[22:25] <pmichaud> oh, because == expects Any?

[22:25] <pmichaud> or ...?

[22:25] <jnthn> pmichaud: sure

[22:25] <jnthn> pmichaud: multi infix:<==>($a, $b) { }

[22:25] <pmichaud> we got away with it before because we weren't multidispatching operators?

[22:25] <jnthn> Default parameter types are Any

[22:26] <TimToady> in fact, there was speculation several years ago that we shouldn't allow assignment of junctions to variable by default

[22:26] <pmichaud> jnthn: right.

[22:26] <pmichaud> jnthn: got it.

[22:26] <TimToady> so maybe variables should default to Any as well

[22:26] <jnthn> pmichaud: No, we got away with it before because Failure ~~ Any

[22:26] <jnthn> And undef ~~ Any

[22:27] <pmichaud> in initial value, or type constraint?

[22:27] <chromatic> Why not Mu ~~ (anything) == Mu?

[22:27] <jnthn> TimToady: Well, there's two things: what we initialize a variable to and whether we put a type constraint on it.

[22:27] <pmichaud> jnthn: okay, makes sense.

[22:27] <jnthn> We can do one and not the other.

[22:27] <PerlJam> if vars default to Any, then I don't see a pressing need for a Mu entry in the S03 smart-match table.

[22:27] <PerlJam> :)

[22:29] <ash__> are regular expressions something that can't be defined using a tool like yacc/bison? 

[22:29] * jnthn tries to think what the fallout for chromatic's suggestion would be.

[22:29] <jnthn> Well, and how to do it...

[22:29] <pmichaud> istr that suggestion coming up also

[22:29] <pmichaud> (in the past at one point)

[22:29] <PerlJam> rakudo:  say ?Mu

[22:29] <p6eval> rakudo 3704a2: OUTPUT«0␤»

[22:29] <TimToady> I don't see how making Mu both bottom and top helps much of anything

[22:30] <pmichaud> there was a discussion of Mu being simultaneously at the top and bottom of the hierarchy :)

[22:30] <TimToady> the bottom should be Um

[22:30] *** quietfanatic joined
[22:30] <pmichaud> ummmmm.... maybe.

[22:30] <pmichaud> I could argue for nW

[22:31] <jnthn> I kinda don't fancy that.

[22:31] <TimToady> Lu

[22:31] * pmichaud wonders how many people have turned their monitors and/or heads 180 degrees :)

[22:31] <TimToady> "least undefined"

[22:31] <TimToady> I can rotate things in my head okay

[22:32] <pmichaud> well, fwiw, alpha essentially was doing the equivalent of initializing variables to Any

[22:32] <TimToady> was always fast on the spactial reasoning tests

[22:32] <pmichaud> it just called it "Failure" :)

[22:32] <TimToady> spatial even

[22:33] <pmichaud> (note:  initial value, not type constraint)

[22:33] <pmichaud> I'd think that initializing to Any would be a reasonable place for us to start and see what happens.

[22:33] <TimToady> sounds good to me

[22:33] <pmichaud> it's also fairly easy to do in rakudo :)

[22:34] <jnthn> aye.

[22:34] <jnthn> Maybe let's try that

[22:34] <PerlJam> and Mu ~~ *   is Bool::False?

[22:35] <pmichaud> just change src/Perl6/Compiler.pir:34  to point to Any instead of Mu

[22:35] <pmichaud> actually, we need to do it after Any is created , though.

[22:36] <pmichaud> so that setting might need to go into src/builtins/Any.pir

[22:36] *** lambdabot joined
[22:37] *** Su-Shee left
[22:37] <pmichaud> I'd leave Compiler.pir:34 as is, and then replace $!OBJECTREF with the Any protoobject when we get to Any.pir

[22:37] <pmichaud> (just in case any ObjectRefs get created before Any is established, which is a little later in the process)

[22:40] <TimToady> whatever still match anything

[22:40] <TimToady> matches

[22:41] <ash__> pmichaud: for nqp-rx did you make your own regular expression parser or did you use one that exists already? i think you made your own, right?

[22:41] <pmichaud> ash__: I started with PGE

[22:41] <pmichaud> (and yes, I wrote PGE)

[22:42] <ash__> okay, got ya, i'll look at PGE too to try to understand what all you had to do to get it working

[22:42] <pmichaud> it's actually easier to look at nqp :)

[22:42] <pmichaud> because now nqp parses itself.

[22:43] <ash__> but if your bootstrapping from scratch, you'd need a starting point, right? 

[22:43] <pmichaud> what backend are you ultimately wanting to target?

[22:43] <ash__> for now, i was going to do the llvm, but that can change for sure

[22:43] <pmichaud> ultimately you'll want/need things that can do object-oriented stuff

[22:44] <pmichaud> because regular expression processing in Perl 6 (and NQP) is very method-oriented

[22:45] <pmichaud> there might be other ways of doing it, though -- my focus/vision has become pretty narrow the past couple of months

[22:45] <pmichaud> anyway, if I were starting a project, I'd probably find ways to port the existing nqp to other backends, rather than start from scratch :)

[22:45] <jnthn> pmichaud: List/iterator question.

[22:45] <jnthn> pmichaud: If I have an iterator, what's the right way to get a Seq from it?

[22:45] <pmichaud> that was the purpose of making nqp self-hosting, so that one could write the backend and use the existing parser/engine :)

[22:45] <pugs_svn> r29782 | lwall++ | [S02,S09] default variables to Any, must declare Mu explicitly to hold junctions 

[22:45] <pugs_svn> r29782 | (this is to reduce pressure to duplicate == and such with Mu arguments)

[22:45] <pugs_svn> r29782 | most of our failure values should be derived from Any in any case;

[22:45] <pugs_svn> r29782 | Mu is more indicative of a major malfunction now.

[22:46] <jnthn> pmichaud: Or something that does Positional, or some such...

[22:46] <pmichaud> jnthn: I suspect it's  $iter.Seq   or Seq($iter)

[22:46] <pmichaud> $iter.Seq works now.

[22:46] <jnthn> Oh?

[22:46] <jnthn> OK.

[22:46] <jnthn> I just ran into an...issue when writing an example.

[22:47] <pmichaud> there are lots of updates and fixes that need to be made to the iterator method hierarchy in rakudo

[22:47] <jnthn> *nod*

[22:47] <pmichaud> I probably need to summarize the notes

[22:47] <jnthn> pmichaud: Let me ask another one then.

[22:47] <jnthn> pmichaud: Is it correct that grep returns a GatherIterator?

[22:47] <pmichaud> yes.

[22:47] <jnthn> OK

[22:47] <pmichaud> at least, it's not *incorrect*

[22:47] <jnthn> :-)

[22:47] <jnthn> OK

[22:47] <pmichaud> grep is lazy, so some form of iterator is warranted

[22:48] *** coke left
[22:48] <jnthn> Right, my question was more if it should be packaged up into something.

[22:48] <pmichaud> probably

[22:48] <pmichaud> getting iterator-as-list and iterator-as-item is still a bit tricky

[22:48] <jnthn> *nod*

[22:49] <pmichaud> so grep should be returning a GatherIterator in its "list form", not in its "item form"

[22:49] <pmichaud> but its "list form" needs to be non-flattening

[22:49] *** ash__ left
[22:49] <jnthn> The problem I hit is a fairly weirdish one.

[22:49] <jnthn> I'm doing That Cute Quicksort.

[22:50] <jnthn> multi quicksort([$pivot, *@values]) { quicksort(@values.grep({ $^n < $pivot })), $pivot, quicksort(@values.grep({ $^n >= $pivot }))

[22:50] <jnthn> }

[22:50] <jnthn> multi quicksort( () ) { () }

[22:50] <jnthn> gah, format fail

[22:50] <jnthn> And anyway, it wasn't producing a Capture properly for the sub-signature to look at.

[22:50] <PerlJam> jnthn: are you going to use this to implement Array.sort?   ;-)

[22:50] <jnthn> Since it only knew what to do with a Seq (and Array)

[22:50] <jnthn> PerlJam: lol.

[22:51] <jnthn> PerlJam: Though no. :-)

[22:51] <jnthn> Quicksort = bad when input data sucks.

[22:51] *** xomas joined
[22:51] *** xomas left
[22:51] *** xomas joined
[22:52] <pmichaud> jnthn: just for now, try a .Seq at the end of your greps and see what happens.

[22:53] *** xomas left
[22:53] *** justatheory joined
[22:54] <jnthn> pmichaud: That does it.

[22:54] <pmichaud> okay.  It won't be that way long, though.

[22:54] <pmichaud> this is a very useful datapoint :)

[22:54] <pmichaud> we need to modify gather/take to return a list-thinking form of GatherIterator, or (perhaps more likely)  GatherIterator needs to .Seq itself in item context

[22:55] <pmichaud> and act like a list in other contexts

[22:55] <pmichaud> anyway, this is a very useful example to consider/work from.

[22:55] *** masak joined
[22:55] <masak> oh hai.

[22:55] <jnthn> Well, for now I can make it work with .Capture being made to lolitsmasak work on Iterator.

[22:56] <pmichaud> I'm not sure that'd be right.

[22:56] <pmichaud> well, it'd be right if Capture honors the flattening rules.

[22:56] <jnthn> Well

[22:57] <masak> quick question: would @a[0, 2 ... *] DTRT and only return the even-indexed elements of @a, or would it (1) run forever, or (2) give me infinitely many Mu values at the end?

[22:57] <TimToady> Captures never flatten according to current spec

[22:57] <masak> I guess @a[0, 2 ... +@a] would DTRT, now that I think about it.

[22:57] *** justatheory left
[22:58] <pmichaud> TimToady: I mean what Capture does with an Iterator, not how a Capture itself acts in a flattening context.

[22:58] <jnthn> pmichaud: It's more about coercing to a Capture.

[22:58] <pmichaud> jnthn: yes, that's my point

[22:59] <pmichaud> the difference is

[22:59] <pmichaud> ($iter, 2, 3).Capture

[22:59] <pmichaud> versus

[22:59] <pmichaud> (@$iter, 2, 3).Capture

[22:59] <jnthn> ah.

[22:59] <pmichaud> you can't just flatten any ol $iter you see

[22:59] <masak> next question: what's the safest way to generate all the odd numbers up to $N?

[22:59] <TimToady> same thing, I think

[23:00] * pmichaud guesses  1, *+2, ... $N

[23:00] <masak> pmichaud: ah, *+2 is nice.

[23:00] <masak> I was thinking 1, 3 ... $N

[23:00] <pmichaud> fails if $N < 3, I think.

[23:00] <masak> and it seemed problematic for $N == 1

[23:00] <TimToady> by current spec, 1,3,5,7 ... 3 just makes 1,3

[23:00] <masak> right.

[23:00] <pmichaud> I haven't read updated spec.

[23:00] <pmichaud> so TimToady's comment might be more apropos

[23:00] <masak> TimToady: oh, that's nice.

[23:01] <masak> I don't understand why yet, but I guess I will :)

[23:01] <pmichaud> so then  1,3 ... $N  ?

[23:01] <masak> guess so.

[23:01] <TimToady> as long as $N >= 1, you're fine

[23:01] <masak> it is.

[23:01] <masak> well, um, it could be 0, I guess.

[23:01] <masak> what's 1,3 ... 0 ?

[23:02] <jnthn> pmichaud: Hmm. The initial patch I wrote doesn't help at all (for teaching iterators to coerce to capture)

[23:02] <jnthn> pmichaud: Maybe I just show example with .Seq in.

[23:02] <pmichaud> jnthn: you need this very soon?

[23:03] <pmichaud> requiring the .Seq would probably be very misleading

[23:03] <jnthn> pmichaud: It was example I wrote for blog post I was about to write, and thought I should check the code in it akshually ran. ;-)

[23:03] <pmichaud> ahhhh

[23:03] <pmichaud> can it wait 24 hrsish?

[23:03] <pmichaud> I can bump the list thinking a bit higher.  needs to be resolved soon anyway.

[23:04] <jnthn> pmichaud: Sure.

[23:04] <TimToady> we can probably force 1,3...0 to make (), but 1...0 is always gonna make 1,0

[23:04] *** colomon joined
[23:05] <TimToady> but by current spec, I think 1,3...0 is the same as 1,3...*

[23:06] <masak> without actually having read the updated spec, I'd say getting () feels better than getting 1,3...*

[23:06] <pmichaud> wild idea -- maybe   *,1,3...0  ?

[23:06] <pmichaud> nah, doesn't really give a good start point.

[23:06] <masak> that idea was so wild I don't think I understand what it meant :P

[23:08] <masak> ok, now I'm finally done translating E03.

[23:08] <masak> http://gist.github.com/309333

[23:08] <masak> I haven't run it yet, but I expect it to more-or-less run on alpha.

[23:08] <masak> now to blog about it and then see what SF got :)

[23:10] *** mssm joined
[23:12] <TimToady> I think we can fix it so that 1,3...0 makes ()

[23:12] <masak> yay

[23:13] <dalek> rakudo/master: 3b869ce | (Martin Berends)++ | docs/compiler_overview.pod:

[23:13] <dalek> rakudo/master: [docs/compiler_overview.pod] update for new master branch completed

[23:13] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/3b869cee4f986d4c6e590a1bdef8661619acfa72

[23:17] <mberends> jnthn, @others: please check docs/compiler_overview.pod for accuracy and completeness. Patches welcome :)

[23:18] *** iblechbot left
[23:20] <pmichaud> mberends: most of NQP is actually written in NQP.  I'll fix that section.  :)

[23:21] <jnthn> mberends: Will check it. Thanks! :-)

[23:22] <mberends> thank you too, it was very educational to go over it all

[23:26] <jnthn> mberends: Yes, Rakudo guts are, IMO, getting less and less terrifying.

[23:27] <jnthn> Either that or I've just ceased to see them as such.

[23:28] <jnthn> "What a hack!" :-D

[23:30] <masak> loliblogged! http://use.perl.org/~masak/journal/40195

[23:30] * masak looks at SF++'s code

[23:31] <masak> ooh, >>.subst!

[23:31] <masak> but, yeah, that won't work, since .subst in itself is non-destructive.

[23:31] <masak> he meant >>.=

[23:31] <masak> is there such a beast? :)

[23:31] <jnthn> mberends: The Stages section maybe belongs as a top level

[23:31] <masak> std: my @a; @a>>.=subst(/foo/, 'bar')

[23:31] <p6eval> std 29782: OUTPUT«ok 00:01 109m␤»

[23:31] <jnthn> masak: There is.

[23:31] <masak> whoa. :)

[23:32] <masak> that's intense.

[23:32] <jnthn> alpha: my @a = 'food', 'fool'; @a>>.=subst(/foo/, 'bar'); say @a.perl;

[23:32] <p6eval> alpha 30e0ed: OUTPUT«["bard", "barl"]␤»

[23:32] <masak> double whoa :)

[23:32] <jnthn> Bet master doesn't quite manage it again yet.

[23:32] <jnthn> master: my @a = 'food', 'fool'; @a>>.=subst(/foo/, 'bar'); say @a.perl;

[23:32] <jnthn> gah

[23:32] <jnthn> rakudo: my @a = 'food', 'fool'; @a>>.=subst(/foo/, 'bar'); say @a.perl;

[23:32] <p6eval> rakudo 3704a2: OUTPUT«["bard", "barl"]␤»

[23:32] <masak> \o/

[23:32] <jnthn> holy shit

[23:32] <jnthn> \o/

[23:33] <masak> 哈哈

[23:33] <jnthn> I'm getting to the point now where I've put so many bits back, I can barely remember them all.

[23:33] <mberends> Christmas draws nearer...

[23:34] <jnthn> heh

[23:34] <pugs_svn> r29783 | vamped++ | minor typo fix 

[23:34] <masak> I'm kinda coming around to the view that Perl 6 is executable line noise with a superiority complex.

[23:34] <jnthn> heh, >>.^

[23:34] <masak> O.O

[23:34] <diakopter> rakudo: say ['food','fool']>>.=subst(/foo/, 'bar').perl;

[23:34] <p6eval> rakudo 3704a2: OUTPUT«("bard", "barl")␤»

[23:35] <masak> rakudo: $0

[23:35] <p6eval> rakudo 3704a2: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 10887 (src/builtins/Iterator.pir:25)␤»

[23:35] <jnthn> :-/

[23:35] * masak submits rakudobug

[23:35] <jnthn> lta

[23:35] <masak> and wrong.

[23:36] <masak> alpha: $0

[23:36] <p6eval> alpha 30e0ed:  ( no output )

[23:36] <masak> that's better :)

[23:36] <diakopter> rakudo: $[0]

[23:36] <p6eval> rakudo 3704a2: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 10887 (src/builtins/Iterator.pir:25)␤»

[23:37] <jnthn> rakudo: (Rat, Complex)>>.^add_method('lol', method () { say "lolwtf" }); 1/2.lol; (1 + 2i).lol;

[23:37] <p6eval> rakudo 3704a2: OUTPUT«lolwtf␤lolwtf␤»

[23:37] <jnthn> Hyper-meta.

[23:38] *** rv2733 left
[23:38] <chromatic> Some of Rakudo's C code is still terrifying, jnthn.  Don't worry.

[23:38] <diakopter> rakudo: (Rat, Complex)>>.^add_method('', method () { say "lolwtf" }); 1/2.''(); (1 + 2i).''();

[23:38] <p6eval> rakudo 3b869c: OUTPUT«lolwtf␤lolwtf␤»

[23:39] <jnthn> !!

[23:39] <jnthn> rofl

[23:39] <masak> ok, SF and I had many points of similarity this time. I feel a little bit bad for not getting my code to run before submitting it, but that's the obvious next step. :)

[23:39] <jnthn> diakopter: Arguably, it's not incorrect.

[23:39] <jnthn> :-)

[23:40] <masak> no, it's very correct.

[23:40] <masak> it's the null string method. nothing to worry about.

[23:40] <diakopter> rakudo: [*]>>.^add_method('', method () { say "lolwtf" }); 1/2.''();

[23:40] <p6eval> rakudo 3b869c: OUTPUT«Method 'shift' not found for invocant of class 'Rat'␤current instr.: 'perl6;Mu;' pc 2375 (src/builtins/Mu.pir:541)␤»

[23:41] <masak> now what happened there, really?

[23:41] <jnthn> I...wish I knew.

[23:41] <diakopter> 1/2.''()

[23:41] <diakopter> rakudo: 1/2.''()

[23:41] <p6eval> rakudo 3b869c: OUTPUT«Method 'shift' not found for invocant of class 'Rat'␤current instr.: 'perl6;Mu;' pc 2375 (src/builtins/Mu.pir:541)␤»

[23:41] <masak> std: [*]>>.^add_method()

[23:41] <p6eval> std 29782: OUTPUT«ok 00:01 106m␤»

[23:41] <masak> ah.

[23:41] * masak submits rakudobug

[23:41] <diakopter> rakudo: [Any]>>.^add_method('', method () { say "lolwtf" }); 1/2.''();

[23:42] <masak> diakopter: how do you come up with these things? :)

[23:42] <p6eval> rakudo 3b869c: OUTPUT«lolwtf␤»

[23:42] <jnthn> diakopter: Any.^add_method will do there :-)

[23:42] <diakopter> I'm good at being^Wplaying the novice programmer

[23:42] <masak> novice?! .^add_method?

[23:42] <jnthn> rakudo: 1/2.''() # no, just this gets it

[23:42] <p6eval> rakudo 3b869c: OUTPUT«Method 'shift' not found for invocant of class 'Rat'␤current instr.: 'perl6;Mu;' pc 2375 (src/builtins/Mu.pir:541)␤»

[23:43] <masak> jnthn: nod.

[23:43] <diakopter> yah, as I wrote above

[23:43] <jnthn> I'm...completely bewildered...how.

[23:43] <masak> jnthn: a little RT ticket will remind you to find out how :P

[23:43] <diakopter> in the invocant

[23:43] <jnthn> So kind of you. :-P

[23:43] * masak is kindness itself

[23:43] <jnthn> oh, I know what it is

[23:44] <diakopter> rakudo: .''()

[23:44] <p6eval> rakudo 3b869c: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[23:45] <masak> that's wrong/lta too.

[23:45] *** pmurias left
[23:45] <diakopter> rakudo: .WHAT.say

[23:45] <p6eval> rakudo 3b869c: OUTPUT«Mu()␤»

[23:45] <diakopter> rakudo: Mu.''()

[23:45] <p6eval> rakudo 3b869c: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14244 (src/builtins/Seq.pir:52)␤»

[23:45] <jnthn> masak: Same underlying cause as 1/2.''()

[23:45] <jnthn> masak: Put them all on one ticket.

[23:45] <masak> jnthn: yes, I know. I'm on it. :)

[23:46] <jnthn> Thanks.

[23:46] <jnthn> :-)

[23:46] <masak> jnthn: for different tickets, you'd have seen me saying '/me submits rakudobug' twice :P

[23:46] <jnthn> (I didn't think it was obvious it was the same underlying cause, fwiw. Thus why I mentioned it. :-))

[23:46] <masak> no, it's obvious. :)

[23:46] <diakopter> rakudo: Any.^add_method('', sub ($a) { say $a }); 1/2.''();

[23:46] <p6eval> rakudo 3b869c: OUTPUT«0.5␤»

[23:46] <masak> I only pretend to be ignorant of the innards of Rakudo when it serves me. :P

[23:47] <diakopter> rakudo: Any.^add_method('', sub ($_) { $_.WHAT.say }); 1/2.''();

[23:47] <p6eval> rakudo 3b869c: OUTPUT«Rat()␤»

[23:48] <masak> rakudo: 1/2.'lolidontexist'()

[23:48] <p6eval> rakudo 3b869c: OUTPUT«Method 'lolidontexist' not found for invocant of class 'Rat'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:49] <diakopter> rakudo: Any.^add_method('', sub ($_) { $_.WHAT.say }); $_= [1/2]; .=''();

[23:49] <p6eval> rakudo 3b869c: OUTPUT«Null PMC access in elements()␤current instr.: 'perl6;SeqIter;get' pc 13737 (src/builtins/Routine.pir:122)␤»

[23:49] <jnthn> diakopter: you'd get away with a pointy block there too fwiw.

[23:49] <jnthn> rakudo: [].WHAT.say

[23:49] <p6eval> rakudo 3b869c: OUTPUT«Null PMC access in elements()␤current instr.: 'perl6;SeqIter;get' pc 13737 (src/builtins/Routine.pir:122)␤»

[23:49] <diakopter> o

[23:49] <jnthn> Eww. That one. :-/

[23:49] * masak submits rakudobug

[23:50] <jnthn> I thought I'd fixed that :-|

[23:50] <masak> 'pparently not

[23:51] <diakopter> rakudo: @_.'pop'().say;

[23:51] <p6eval> rakudo 3b869c: OUTPUT«/tmp/p7QvN9rmI9␤»

[23:52] <diakopter> rakudo: @_.pop.say;

[23:52] <p6eval> rakudo 3b869c: OUTPUT«/tmp/fsPRcEaY90␤»

[23:52] <diakopter> rakudo: @_[*-1].say;

[23:52] <masak> diakopter: p6eval artefact.

[23:52] <p6eval> rakudo 3b869c: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[23:53] <masak> and that one is indexing or whatever algebra not working properly, I guess.

[23:53] <masak> rakudo: my @a = 1, 2, 3; say @a[*-1]

[23:53] <p6eval> rakudo 3b869c: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[23:53] <jnthn> I think just NYRI

[23:53] <masak> right.

[23:53] <masak> you won't get a ticket for that :)

[23:54] <diakopter> ticket monster hungry

[23:54] <masak> nom nom nom

[23:55] * masak goes looking for more kittens doing that on Youtube

[23:55] <masak> jnthn: http://www.youtube.com/watch?v=MnagRjxp7v4

[23:56] <diakopter> rakudo: {;;;;;}.WHAT.say

[23:56] <p6eval> rakudo 3b869c: OUTPUT«Hash()␤»

[23:56] <masak> Hash? really?

[23:56] <masak> it's full of statements! :)

[23:57] *** cotto_w0rk left
[23:57] <diakopter> rakudo: {;;;(say 4)=>4;;}.WHAT.say

[23:57] <p6eval> rakudo 3b869c: OUTPUT«4␤Hash()␤»

[23:58] <diakopter> rakudo: {;;;{say 4}=>4;;}.WHAT.say

[23:58] <p6eval> rakudo 3b869c: OUTPUT«Hash()␤»

[23:58] <jnthn> No no, Rakudo's just telling diakopter what it thinks he's been smoking...

[23:59] <diakopter> rakudo: {{say 4},Nom}.WHAT.say

[23:59] <p6eval> rakudo 3b869c: OUTPUT«Block()␤»

[23:59] <diakopter> rakudo: {Nom,Nom,Nom}.WHAT.say

[23:59] <p6eval> rakudo 3b869c: OUTPUT«Block()␤»

[23:59] <jnthn> masak: Wow! nom nom nom! :-D

[23:59] <diakopter> rakudo: {nom,nom,nom}.WHAT.say

[23:59] <p6eval> rakudo 3b869c: OUTPUT«Block()␤»

[23:59] <diakopter> erm

