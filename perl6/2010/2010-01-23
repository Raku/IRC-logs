[00:00] <sjohnson> diakopter: what OS do you use for your desktop day to day use?

[00:03] *** patspam joined
[00:05] <pugs_svn> r29580 | lwall++ | [S03,S07] more Pm-16 refinements 

[00:08] <s1n_mini> sjohnson: i proudly use Windows 95, as God and Gates intended :)

[00:08] *** [particle] joined
[00:08] <sjohnson> serious?!

[00:09] <s1n_mini> unpatched as released in 1996 :)

[00:09] <s1n_mini> no i'm just kidding lol

[00:10] <s1n_mini> sorry for the off-topic, this class is seriously boring

[00:10] *** drbean joined
[00:10] *** lumi left
[00:11] *** lumi joined
[00:11] <TimToady> sjohnson: wasn't foresight, just experience that once spam attacks start, they usually continue :/

[00:11] *** nihiliad left
[00:11] <TimToady> and also laziness in not figuring out any other options :)

[00:11] <sjohnson> TimToady: one of the bots called me a fat face!  please do something about this

[00:12] <TimToady> did I mention it will be impossible to do evil programming in Perl 6?  :)

[00:12] <sjohnson> s1n_mini: i like off-topic if im not interrupting anyone's heavy perl log.. reminds us that we all aren't robots

[00:12] <s1n_mini> TimToady: care to test that?

[00:13] <TimToady> test what, whether I mentioned it?

[00:13] <s1n_mini> it's truthiness

[00:14] <s1n_mini> sometimes, evil things can be fun, if only to prove a point :)

[00:14] <TimToady> it was kinda sad, the day PHP took over from Perl as the language of choice for network abuse...

[00:14] <sjohnson> and lazy scoping abuse too

[00:14] *** [particle] left
[00:15] <sjohnson> now these PHP users have grown up, and are in our officez, programmin' our softwares

[00:15] <Juerd> PHP's scoping is so annoying.

[00:15] * s1n_mini can haz pee h pee

[00:16] *** riffraff joined
[00:16] <Juerd> The workaround is to write millions of tiny functions

[00:16] <sjohnson> Juerd: have you read the common PHP vs Perl milestone in html web publishing?

[00:17] <Juerd> No, what's that?

[00:17] <sjohnson> http://tnx.nl/php.html

[00:17] <Juerd> Seriously?

[00:17] <Juerd> I kind of wrote that :)

[00:18] <sjohnson> thats yours?

[00:18] <Juerd> Yea

[00:18] <sjohnson> wow

[00:18] <sjohnson> small world!

[00:18] <sjohnson> that's amazing

[00:19] <sjohnson> i've pasted that link to tons of people

[00:19] <sjohnson> whenever they ask "... but i like PHP"

[00:19] <Juerd> Thanks

[00:19] <Juerd> It's so damn incomplete though :(

[00:20] <sjohnson> well, if you ever thought of ammending it

[00:20] <sjohnson> you'd have my full support!

[00:20] <Juerd> I have. On average once per week I think.

[00:20] <Juerd> But I lack real motivation and inspiration.

[00:21] <Juerd> It's hard to make a point without much text

[00:21] <s1n_mini> Juerd: that image does a good job

[00:22] <Juerd> merlyn posted that line to perlmonks

[00:22] <sjohnson> Juerd: did you see my addition on the graph of programming languages, what Perl programmers think of PHP?

[00:22] <Juerd> He let me use it for the poster :)

[00:23] <Juerd> sjohnson: No

[00:23] <sjohnson> Juerd: http://imgur.com/LPPaL.jpg

[00:23] <sjohnson> i only added in the X and Y's of the Perl part

[00:23] <sjohnson> took me quite a while

[00:23] *** LaVolta joined
[00:23] <sjohnson> but i think youll like the what Perl thinks of PHP

[00:24] <Juerd> Hah

[00:24] <Juerd> I like Mickey Mouse better than PHP though :)

[00:24] <sjohnson> same

[00:24] <sjohnson> my brother and i always say "PHP.. such a Mickey Mouse language"

[00:24] <sjohnson> i had to stick it in there

[00:25] <s1n_mini> maybe blue's clues is more appropos

[00:25] <sjohnson> heh

[00:25] <sjohnson> i only learned about Deep Blue a while ago

[00:25] <sjohnson> if that's what you mean

[00:25] <sjohnson> starting to learn how to play chess

[00:26] <TimToady> more like teletubbies, I think

[00:26] <LaVolta> morning, everybody!

[00:26] <s1n_mini> no, the blue dog for kids

[00:26] *** [particle] joined
[00:26] <Juerd> Do you know about the lego/playmobil comparison?

[00:26] <Juerd> http://juerd.nl/site.plp/perl_lego

[00:29] <diakopter> everyone needs a Pretty Home Page

[00:29] <Juerd> It's weird how Personal Home Page became PHP: Hypertext Preprocessor

[00:29] <Juerd> But as a simple preprocessor in the cpp sense, I don't mind PHP :)

[00:30] <Juerd> It's much faster than Template Toolkit :(

[00:30] <diakopter> o

[00:31] <Tene> PHP was a great, simple, limited language for adding small amounts of dynamic behavior to an otherwise-static site.  It's a shame nobody developed it after the first couple of years.

[00:31] <Juerd> It has never been great and simple, IMO.

[00:31] <s1n_mini> one man's trash is another man's treasure

[00:32] <sjohnson> PHP is good to teach complete newbies how to program

[00:32] <sjohnson> basics of for loops, etc

[00:32] <Juerd> sjohnson: Oh no.

[00:32] <Tene> Eh, I was just guessing.  I never saw the early versions, so I just assumed they were sane at one point.

[00:32] <sjohnson> because it is very tolerant

[00:32] <Juerd> sjohnson: It's all but tolerant. How can you say it's tolerant?

[00:32] <s1n_mini> wasn't based on perl4?

[00:32] <sjohnson> Juerd: because newbs who are new and have thin skin.. wont cry when they see a scoping error in PHP

[00:32] <sjohnson> Juerd: and they dont have to memorize sigils, etc.. i just mean as an absolute beginners language

[00:33] <sjohnson> and then once you know what a for loop is, dump PHP

[00:33] <sjohnson> or learn Perl but dont use scrict;

[00:33] <sjohnson> perl == better

[00:33] * s1n_mini class over, later

[00:33] <sjohnson> cya

[00:33] <Juerd> sjohnson: I've taught Perl and PHP to absolute beginners. Obviously I'm better at teaching Perl because I'm more familiar with it, but it's much easier to let kids play with Perl than with PHP.

[00:33] <diakopter> function ($y) use ($x) {

[00:34] <sjohnson> Juerd: ill take your word for it.  i found learning Perl with the camel book DEAD simple

[00:34] <sjohnson> and intuitive

[00:34] <Juerd> Perl will give meaningful error messages on syntax errors, whereas PHP's are incomprehensible and often misleading.

[00:34] <sjohnson> i had perl learned in less than a week flipping through the camel book at work for a few hours a day

[00:34] <sjohnson> Juerd: i dont like those really arrogant PHP kidz you see around.. on slashdot or irl

[00:35] <sjohnson> who think they are scripting gurus cause they know a bit of PHP

[00:35] *** Chillance left
[00:35] <sjohnson> mirc scripts to annoy ppl are the same ilk of ppl

[00:35] *** lumi left
[00:35] <Juerd> sjohnson: Oh, and I do teach them to use strict. Newbies make lots and lots of typos in identifiers, at least those that I've instructed.

[00:35] *** lumi joined
[00:36] <Juerd> But my only audience has been kids, ages 14..17

[00:36] <Tene> same in my perl classes for adults

[00:38] <sjohnson> TimToady: hopefully not a silly question.. but have you ever played around / used PHP much?

[00:38] <sjohnson> i have to use it at work, otherwise i probably wouldn't use it

[00:38] * LaVolta just wondering why nobody metions Python for beginners...

[00:39] <diakopter> .oO( more than half of folks in here aren't identified and aren't voiced

[00:39] <diakopter> )

[00:39] <TimToady> sjohnson: nope, not something I've ever aspired to

[00:39] <sjohnson> diakopter: most of them don't even chat in the chan either

[00:40] <sjohnson> and if they try to... freenode will just alert them, to please register

[00:40] <sjohnson> and so will the topic... they should be ok methinks

[00:40] <sjohnson> just think of the happiness of not having bots!

[00:40] <diakopter> it didn't alert me when I tried to talk in the channel

[00:40] <pmichaud> okay, while out fetching dinner I think I realized that my thoughts on list and iterators are, in fact, completely bogus  :-|

[00:40] <sjohnson> are you sure you didnt get a CTCP diakopter ?

[00:41] <sjohnson> "Users will receive a server notice explaining this if they try to speak. "

[00:41] *** diakopter___ joined
[00:41] *** diakopter___ left
[00:41] <diakopter> sjohnson: ok

[00:41] <diakopter> pmichaud: 'completely'?

[00:42] *** sjohnson_ joined
[00:42] *** drbean left
[00:42] *** sjohnson__ joined
[00:43] <pmichaud> diakopter: if not 'completely', then perhaps 'seriously misguided'.

[00:43] <sjohnson> diakopter: i got a server message testing it out asking me to register

[00:43] <sjohnson> just to confirm i tested it

[00:43] *** sjohnson__ left
[00:43] <Tene> pmichaud: explain?

[00:43] *** sjohnson_ left
[00:44] <pmichaud> let's consider a statement like

[00:44] <pmichaud> @a = (4, 5, 1..1000, 7);

[00:45] <pmichaud> rhs is a List

[00:45] <TimToady> or a Parcel

[00:45] <pmichaud> (well, it's a Parcel that ends up acting like a List because it's in list context)

[00:45] <pmichaud> the current ng implementation has been saying that yes, Lists are (externally) immutable

[00:46] <pmichaud> so the List starts out with four things in it, the 4, the 5, the range, and the 7

[00:46] <pmichaud> as we start to iterate over the list, though, it takes the lazy range and starts making it into elements in the "generated" part of the list

[00:46] <pmichaud> thus as we're doing the assignment, at some point the rhs ends up looking something like   (4, 5, 1, 2, 3, 4..1000, 7)

[00:47] <Tene> Ouch.

[00:47] <pmichaud> i.e., we're taking elements off of the iterated range and putting them into the generated portion of the list

[00:47] * colomon nods

[00:47] <sjohnson> Juerd: if i can think of a bad thing to add to your site, i will add it.  i have to use PHP at work fulltime so i have come across a lot of crap

[00:47] <pmichaud> but we really don't want those elements there -- they're not going to be needed

[00:47] <pmichaud> in other words, when we're iterating any sort of list, the more common case is that we really want to be throwing elements away, not preserving them

[00:48] <colomon> I was wondering about that.  I keep thinking of the for 1..10000000 case....

[00:48] <TimToady> well, if you work ahead some, you have to track the generated but not yet consumed values

[00:49] <TimToady> so I don't think the view is entirely inaccurate

[00:49] <pmichaud> it may not be entirely inaccurate, yes

[00:49] <pmichaud> but the implementation is working too hard to preserve the immutable nature of Lists

[00:50] <pmichaud> when a List's immutability is really not all that important in most cases

[00:50] <pmichaud> (immutable in an external sense, not an internal one)

[00:50] <TimToady> to the first approximation, lists are not generally user-accessed

[00:50] <pmichaud> right

[00:50] <TimToady> as in Perl 5, they're internal thingies

[00:50] *** arnsholt_ joined
[00:50] <pmichaud> well, in Perl 6 they still tend to show up a bit

[00:51] <pmichaud> for example:    my $a = (1,2,3);   say $a.WHAT;

[00:51] <pmichaud> that's likely to be a List.

[00:51] <TimToady> I'd argue Parcel, I think.

[00:51] <TimToady> maybe, still waffling :)

[00:51] <pmichaud> if that's the case, then rakudo-ng's model is even more broken.

[00:51] *** s1n_mini left
[00:52] <sjohnson> i have had a few instances where i wnat to keep the lists data.  i was hoping to not have to write the $_ in $_ is copy

[00:52] *** riffraff left
[00:52] <pmichaud> in general, rakudo-ng says that any Parcel in item context becomes a List.

[00:53] <pmichaud> more to the point,  we'd somewhat expect      my $a = (1,2,(3,4), 5);   say $a.elems;   # 5

[00:53] <pmichaud> where .elems is a method on List

[00:53] * TimToady is trying to figure out one can assign an item a Parcel value...

[00:54] <pmichaud> right -- in Perl 6, it feels like Parcels end up being the "invisible internal thingy"

[00:54] <pmichaud> and List is more visible

[00:54] *** arnsholt left
[00:55] <TimToady> btw, I think whatever else we decide @$x and @($x) have to do the same thing

[00:55] <pmichaud> (caveat all statements here with my overall observation that suddenly something feels fundamentally wrong about rakudo-ng's List implementation to me)

[00:55] *** _jaldhar left
[00:55] <pmichaud> oh, *that's* interesting also :-)

[00:55] <pmichaud> that's the way I had been thinking of it, but I noticed yesterday the spec doesn't say that

[00:56] <pmichaud> and it becomes a little weird in the case of  @$x, 3  versus   @( $x, 3 )

[00:56] <TimToady> I think that case is handled by the autoreduction of item Parcels

[00:57] <pmichaud> I'm confused there, then.

[00:57] *** patspam left
[00:57] <pmichaud> (not surprising.  I just realized as I was walking into "Tasty Egg Roll"  that my mental model is now a mass of confusion :-)

[00:58] <TimToady> if $x contains, say [1,2,3], @$x derefs, but @($x, 3) doesn't, since the $x is embedded in a Parcel with 2 elements

[00:58] *** patspam joined
[00:58] <TimToady> but @($x) is a Parcel with one element, and therefore [1,2,3] derefs

[00:58] <pmichaud> right

[00:58] <pmichaud> that's fine w/me (and fits with how I thought of things before yesterday)

[00:58] <pmichaud> so,  @($x, 3).elems == 2

[00:58] <TimToady> yes

[00:59] <pmichaud> wfm

[00:59] <LaVolta> TimToady, you mean in @($x) case it will become @$x ?

[00:59] <pmichaud> while  (@$x, 3).elems ==   $x.elems + 1

[00:59] <TimToady> LaVolta: that would be another way to say it, but yes

[01:00] <TimToady> say rather that @$x is shorthand for @($x)

[01:00] <pmichaud> LaVolta: essentially,  in the @($x) case it's operating on $x.   In the @($x, 3)  case it's operating on the parcel  ($x, 3)

[01:01] <LaVolta> ah...thanks, got it :)

[01:02] <pmichaud> oh!

[01:02] <TimToady> pmichaud: I could almost argue that $x = is contextless, while $x := is item context

[01:02] <pmichaud> upon thinking about it further, perhaps Rakudo has it right after all!

[01:03] <pmichaud> let's re-examine the    @a = (4, 5, 1..1000, 7) case again

[01:03] <TimToady> but no, then $x = (1,2,3) would interpolate $x into a list, which is a bit of a nono

[01:03] <pmichaud> what Rakudo-ng is doing now (rightly or wrongly) is turning the rhs into an Array

[01:03] <pmichaud> and then it is shifting elements from that Array

[01:04] <pmichaud> which means the intermediate elements aren't being stored

[01:04] *** _jaldhar joined
[01:04] *** Baggiokwok joined
[01:04] <pmichaud> the original List still exists -- what Rakudo-ng does now is to create an Array from that List and use it for the assignment

[01:05] <TimToady> alternately, just take the list, poke it into the Array's generator spec, and then tell it to reify mostly eagerly

[01:05] <TimToady> why copy twice?

[01:05] <pmichaud> long story

[01:05] <pmichaud> but mainly to be able to deal with something like    ($b, @c) = ( 1..$something, $b )

[01:06] <TimToady> I think assignment is to a new $b and a new @c, and those are rebound to the variables upon completion, maybe

[01:07] <pmichaud> yeah, that doesn't fit Parrot's model all that well.  And we have to deal with other bindings for $b and $c

[01:07] <pmichaud> i.e.

[01:07] <pmichaud>    $a := $b;  ($b, @c) = ( 1..$something, $b );

[01:07] <pmichaud> at the end, $a still needs to be bound to (new) $b

[01:08] *** k23z__ left
[01:08] <TimToady> well, somehow we have to take a transactional view, and commit the change after creating the new values for $b and @c

[01:08] <TimToady> but after using the old values eagerly

[01:09] <pmichaud> right.  At the moment rakudo accomplishes that by creating an Array and copying from that   (the Array can still be lazy)

[01:09] *** ash__ left
[01:09] <pmichaud> I have some tricks to avoid the dual copies

[01:09] <pmichaud> anyway, here's a more interesting case

[01:09] <pmichaud> for   4,5,1..1000,7  { ... }

[01:10] <pmichaud> this is another case where we want to be able to iterate over the array and throw away the generated values

[01:10] <pmichaud> s/array/list/

[01:10] <TimToady> sure, I guess I don't see a problem

[01:10] <pmichaud> well, the way rakudo-ng is currently handling List, it keeps track of generated values

[01:11] <pmichaud> because the List is "immutable"

[01:11] *** ash_ joined
[01:11] *** ash_ left
[01:11] <TimToady> it's only immutable in the abstract

[01:11] <pmichaud> right

[01:11] <pmichaud> but internally, how to represent that?

[01:12] <TimToady> you can throw away values that can't be gotten back to

[01:12] <pmichaud> how do we know "can't be gotten back to"?

[01:12] *** ash_ joined
[01:12] *** ash_ left
[01:13] <TimToady> iterated externally, since a List is, to the first approximation, an iterator of iterators

[01:13] <pmichaud> ...and that's where Rakudo gets it wrong, then.

[01:14] <TimToady> we might want to do like with Range and distinguish List from ListIterator

[01:14] <pmichaud> rakudo-ng already does that

[01:14] <TimToady> the only time you need the whole list is in situations like (4,5,1..100,42)[@ix]

[01:15] <TimToady> where @x can visit the elements in any order

[01:15] <TimToady> in that case, it presumably promotes to Array

[01:15] <pmichaud> hopefully not

[01:16] <pmichaud> my $x = (1,2,3);   say $x.WHAT;   say $x[1];  say $x.WHAT;   # auto-promotes?

[01:16] <TimToady> I don't think List can be Positional, or you always have to remember it all

[01:16] <TimToady> that's bogus

[01:17] <pmichaud> is Parcel Positional?

[01:17] <TimToady> yes, but on syntactic elements

[01:17] *** lumi left
[01:17] <pmichaud> if we don't have to remember all of the parts of a List, how is it immutable?

[01:17] <TimToady> (1,2,1..1000,42) has 4 elements

[01:18] *** mssm left
[01:18] <pmichaud> "has 4 elements"  in the sense that calling   .elems on it would give me back 4?

[01:18] <TimToady> just in the sense that a given list, once you've determined the value of the nth element, will never determine a different value for it

[01:18] <TimToady> that doesn't mean it's accessible

[01:19] <TimToady> 0..* is 0,1,2,3,4,5, and the values are always those values

[01:19] <TimToady> but 'for 0..* {...}' doesn't have to store all the values

[01:19] <pmichaud> but how do we know that?

[01:20] <TimToady> because we iterate the list, and iterating is forgetting

[01:20] *** lumi joined
[01:20] <TimToady> all iterators are mutable in that sense

[01:21] <pmichaud> so if a List is really a iterator of iterators, it's mutable in that sense also?

[01:21] <TimToady> yes

[01:21] *** obra__ is now known as obra

[01:22] <pmichaud> what about something like

[01:22] <pmichaud>     (1..3).map( { $_ * 2 } ).[5,3,7]

[01:22] <pmichaud> is .map returning an Array there?

[01:22] <pmichaud> does it return something that auto-promotes to an Array?

[01:23] <pmichaud> (can't be a List if lists aren't positional)

[01:23] <TimToady> the subscript must autopromote it to something Positional

[01:23] *** k23z__ joined
[01:23] <pmichaud> so, subscripting a List promotes the List to an Array?

[01:23] <TimToady> could do like Perl 5 and index the stack directly though

[01:24] <TimToady> or whatever is functioning as the temporary value

[01:24] <TimToady> could perhaps even be handled by Cool.[]

[01:24] <pmichaud> perhaps subscripting just turns on a flag that tells the List  "you have to remember values now"  ?

[01:25] <TimToady> well, that would be an optimization

[01:25] <TimToady> pretend to be an Array for a moment

[01:25] <pmichaud> well, I kinda need to know if it auto-promotes 

[01:25] <pmichaud> in the sense that a programmer sees the actual promotion

[01:26] <TimToady> $list.[] doesn't have to mutate the type of $list

[01:27] <pmichaud> okay

[01:27] <TimToady> it might, however, consume as much of the list as it likes to get to the biggest index

[01:28] <pmichaud> well, if I had   $list.[5]   and later $list.[4,5]   I'd probably like the 5 element to be the same one

[01:28] <pmichaud> so it generates (and stores) as much of the list as it likes to get to the biggest index it's seen thus far

[01:28] <TimToady> well, that argues that $x = (1,2,3) promotes to Array immediately

[01:29] <TimToady> like we used to  :)

[01:29] <TimToady> which is probably okay, given that Arrays can auto-extend lazily

[01:29] *** mjk joined
[01:29] <pmichaud> I was thinking the same thing, but why does it need to promote to Array immediately?

[01:30] <pmichaud> why can't $x remain a List ?

[01:30] <TimToady> because Array's are for remembering positions

[01:30] <pmichaud> can a List just be an iterator that remembers positions if you need it to?

[01:30] <pmichaud> I can see why that wouldn't work, though.

[01:30] <TimToady> translation, can a List just behave like an Array?

[01:31] <pmichaud> well, an "immutable" Array

[01:31] <TimToady> we've already built the autogen into Array semantics, so it seems redundant to also try to make List work both ways

[01:31] <pmichaud> agreed, there redundancy here that I've been unable to resolve.

[01:31] <pmichaud> *there's

[01:32] <TimToady> I think lists are not positional

[01:32] *** Alias joined
[01:32] <pmichaud> rakudo-ng has the autogen in List semantics, and then uses that to derive ARray

[01:33] <TimToady> and then we wonder when we can GC the used values of the list

[01:33] <pmichaud> (I agree that feels wrong now)

[01:33] <pmichaud> part of the reason rakudo-ng does it that way, though, is because   Array ~~ List

[01:34] <TimToady> not sure List is a useful type

[01:34] <pmichaud> (perhaps that shouldn't be the case)

[01:34] <pmichaud> oh, I'd be just fine with eliminating List altogether if it's not in fact useful

[01:34] <pmichaud> I never have quite grokked the difference between  List/Array   and Mapping/Hash

[01:34] <pmichaud> other than mutability

[01:35] <TimToady> Array ~~ IterableByClonedIterator

[01:35] <pmichaud> cloned iterator?  In the sense that it actually clones the Array?

[01:35] <TimToady> in the sense that the Iterator is not an Array

[01:35] <TimToady> any you might have several pointing to the same Array

[01:36] <TimToady> *and

[01:36] <pmichaud> and modifying the array leaves the iterators in an undefined state?

[01:36] <pmichaud> (doctor, it hurts when I do that...?)

[01:36] <TimToady> presumably, depending on how fancy we get

[01:36] *** mjk left
[01:37] *** snarkyboojum joined
[01:37] <pmichaud> if we eliminate List, then that leads towards the notion I had last year that Parcel and List actually did similar things.

[01:37] <pmichaud> i.e., we're just left with Parcel

[01:37] <TimToady> a Parcel is a list of iterators

[01:37] <pmichaud> I tend to think of it as a list of syntactic elements

[01:38] <pmichaud> and what happens to it depends on the context in which it's used

[01:38] <pmichaud> so, subscripting a Parcel would turn it into an Array

[01:38] <TimToady> yes, but that's dynamically determined in the general case

[01:38] <TimToady> though we can recognize where to transmute to Capture most of the time

[01:38] <pmichaud> correct

[01:40] <pmichaud> iirc, p5 makes a fair bit of noise about the difference between "list" and "array".  Does eliminating List from p6 cause us an issue of any sort?

[01:40] <TimToady> $x = \(1, 2, 1..1000, 42); say $x.[2].WHAT   # Range

[01:41] <TimToady> well, list context is what iterates iterators in Perl, generally

[01:41] <TimToady> but in Perl 5 the iterators can't be stored into $x

[01:41] <TimToady> I think we should probably make it difficult in Perl 6 as well, though possible

[01:42] <TimToady> since for $iterator {...} isn't going to do what people expect, one way or another

[01:42] <pmichaud> well, I did observe earlier (in backscroll to colomon) that except for filehandles, p6 iterators tend to be invisible also

[01:42] <pmichaud> generally it'd want to be   for @$iterator { ... }

[01:43] <pmichaud> or something like that

[01:44] <pmichaud> eliminating List would also clean up another bit of ickiness in rakudo-ng (more)

[01:44] <diakopter> sjohnson: my point was that everyone who's currently a member of #perl6 should be voiced

[01:44] <pmichaud> right now invoking a method on a Parcel causes it to autopromote to a List

[01:45] <pmichaud> if we eliminate List, then we can leave it as a Parcel

[01:45] <diakopter> sjohnson: b/c they're not going to know they need to register/identify to be heard

[01:45] <diakopter> sjohnson: oh wait, nm.  <sigh>  /me shuts up

[01:45] <pmichaud> or have it autopromote to an Array

[01:45] <sjohnson> ( ╹◡╹)

[01:45] <LaVolta> diakopter, add that to MOTD? :-P

[01:46] <diakopter> still, not everyone watches their CTCPs (or even know what to watch, or why or what they'd be watching)

[01:47] <sjohnson> let us pray they read the topic

[01:47] <pmichaud> TimToady: okay, thanks, I think this helps a fair bit.  I'll play with my mental model a bit more and see if I can make some sense out of it (similar to what happened with Nil and Parcel :-)

[01:47] <sjohnson> if freenode allowed coloured topics, i would have made it stick out like a sore thumb

[01:47] <sjohnson> kloeri_: what do you think of coloured topics?

[01:48] <kloeri_> I usually try to avoid all the colour stuff as it mostly annoys me

[01:49] * pmichaud reviews the r29580 commit

[01:49] <kloeri_> most networks doesn't support ansi codes in topics afaik since /list could get rather interesting if they did

[01:49] <sjohnson> 4friend!

[01:50] <kloeri_> heh

[01:50] <sjohnson> kloeri_: is the spam bot harassing other freenode channels?

[01:50] <kloeri_> tons of channels, yeah

[01:50] <sjohnson> any hope of resolution?  or new ircd is the answer

[01:50] *** k23z__1 joined
[01:51] <sjohnson> so far this +R technology seems to do the trick well

[01:51] <kloeri_> new ircd is the real answer

[01:51] <sjohnson> though may cause annoyance to others as dia mentioned

[01:51] <sjohnson> kloeri_: is there an EST date?

[01:51] <kloeri_> until then +R will do, hopefully without causing too much annoyance

[01:52] <kloeri_> jan 30th is the migration

[01:52] <sjohnson> fantastic then

[01:52] *** japhb left
[01:53] <sjohnson> well gtg thanks for your help kloeri_ 

[01:53] <kloeri_> you're welcome

[02:00] *** k23z__ is now known as Guest31300

[02:00] *** Guest31300 left
[02:01] <pmichaud> Tene, colomon, jnthn:  see backscroll above for thoughts on lists and iterators, let me know if you have ideas or comments

[02:01] <pmichaud> afk, late dinner

[02:01] <colomon> roger

[02:01] <Tene> pmichaud: I've been reading. :)

[02:06] *** lumi left
[02:06] *** lumi joined
[02:11] *** drbean joined
[02:11] <colomon> pmichaud: what keeps on jumping out at me is that there are iterators everywhere.

[02:11] <colomon> That is, you want to iterator over the list, and you want iterators to generate the list.

[02:13] <TimToady> pmichaud: I think we promote an item Iterator to Seq, and define Seq to be extensible like Array, but readonly in the reified bits

[02:13] <TimToady> also thinking that Iterate is the role that does .get, while Iterable means you can create an object that does Iterate

[02:13] <colomon> and in the ideal world, if you only want to create the list to get its iterator, you don't want to store the values in it.

[02:14] <TimToady> so an Array does Iterable, but not Iterate

[02:14] *** payload joined
[02:15] <colomon> TimToady:  so Array would return an ArrayIterator, or something like that?

[02:15] <TimToady> either that, or iterators are Iterable, and other things are Iterableable

[02:15] <TimToady> colomon: nodnod

[02:16] <colomon> One thing pmichaud and I were talking about is how you know when the Iterator is done.

[02:16] <colomon> the spec says .get returns Nil in that case, but isn't Nil a valid value in a List / Array?

[02:18] <TimToady> a list-flattening iterator will throw away an embedded Nil so that the user never sees it

[02:18] <colomon> TimToady: hmmm....

[02:18] <TimToady> a slice iterator can return a Nil as an element, so something else will have to signal the end

[02:18] <TimToady> either that, or a slice iterator promotes Nil to []

[02:18] *** orafu left
[02:18] *** orafu joined
[02:18] * Tene drives home

[02:19] <colomon> we talked about .get returning two values, but that's a list, and things quickly get nonsensical.

[02:19] <jnthn> pmichaud: I'll read the list discussion tomorrow. EBEERANDCOMPLEXSEMANTICSINCOMPATIBLE.

[02:20] * LaVolta go to take a .NET exam, good luck :-P

[02:20] <colomon> pmichaud was talking about having a separate method to query if the list is done, but that means many iterators would need to store values internally, because you can't know if the list is done until you try to get the non-existent last value.

[02:20] <jnthn> LaVolta: Good luck...I did one of those a week or two ago. :-)

[02:21] <colomon> I really think having .get return a special value is a good approach, but finding a suitable special value is tricky...

[02:21] <LaVolta> jnthn, thanks...

[02:21] <jnthn> LaVolta: fwiw, I passed, so apparently it's not impossible. :-)

[02:22] *** Baggiokwok left
[02:22] <TimToady> I think Nil can be okay, given list vs slice semantics

[02:22] <TimToady> decommuting &

[02:23] <jnthn> I don't really like "you must remember to check the return value" in general, but I need to read the full discussion to get the context.

[02:23] <colomon> pmichaud: I keep on coming back to feeling strongly it's important to have a good iterator interface even if its something 99% of the programmers out there will never touch.  It looks to me like the sort of thing that power class designers may want to have available.  And I think it's important that as much as possible of p6 can be written in p6.  

[02:23] *** snarkyboojum left
[02:24] <colomon> jnthn: well, you definitely need to check something to know if the iterator ends!

[02:24] <colomon> the issue is whether it's the return value of .get or the return value of some other function.

[02:25] <pmichaud> colomon: (back)  I agree it's important to have a good iterator interface.  afaik none of us have any real clue what that should look like :-)

[02:25] *** clintongormley left
[02:25] <colomon> pmichaud: :)

[02:27] <colomon> pmichaud: TimToady seems to think .get returning Nil to indicate it's done is reasonable.

[02:27] <colomon> I'm also wondering HOP might have something useful to say on this subject.

[02:27] <pmichaud> I'm okay with that for now, I think.

[02:27] <colomon> *whether HOP

[02:28] <pmichaud> colomon++  # HOP might indeed be a good idea here

[02:28] <pmichaud> for the moment I'm having to get my head around the idea of dropping List altogether

[02:29] <pmichaud> or perhaps List and Mapping are just roles in the same sense as Numeric, Stringy, etc.

[02:29] <jnthn> pmichaud: I'm more used to the "we're out of values" being out of band. That said, most lanuages don't have the idea of undefined in the sense that Perl does.

[02:29] <colomon> Wouldn't List just be the Iterable TimToady was just talking about then?

[02:29] <pmichaud> colomon: perhaps

[02:29] <jnthn> pmichaud: I'd kinda seen List as the immutable version of Array, fwiw.

[02:30] <pmichaud> jnthn: right, so had I.  But I had the revelation today that this isn't really all that desirable

[02:30] <pmichaud> consider

[02:30] <pmichaud>     for  $a, $b, 1..1000000, $c { ... }

[02:30] <pmichaud> do we _really_ want to be storing those million elements as we generate them...?

[02:31] <Tene> for iterator interface, I'd imagine  it's the same as gather/take.  Throw an exception containing the element you want, and then actually return when you're done.

[02:31] <Tene> I need ot htink about whether that actually works, though.

[02:31] <colomon> pmichaud: or heck, for $file.lines { ... }

[02:32] <pmichaud> Tene: exceptions can work, but they can also be a bit heavyweight at times

[02:32] <jnthn> pmichaud: Good point, and if the assumption is that List does Positional, well, that's awkward in that situation, yes.

[02:32] <pmichaud> jnthn: well, that's the other thing -- above TimToady was conjecturing that List !~~ Positional

[02:32] <jnthn> Hmm.

[02:33] <pmichaud> so the "List as immutable form of Array" isn't really right.  TimToady conceptualizes it more as an iterator (of iterators)

[02:33] <pmichaud> and that fits my more recent experiences a bit closer as well.

[02:33] <jnthn> I can go with that.

[02:34] <pmichaud> I probably won't have a new model to even begin to work from until tomorrow morning

[02:34] <pmichaud> (new "mental model", that is)

[02:34] <jnthn> My feeling with the enum/hash stuff of late was that we were starting to pull away from the "there's a mutable and immutable version of the various data structures" model.

[02:34] <pmichaud> right

[02:34] <pmichaud> so the idea that "List"  really means "Iterator"   makes sense

[02:34] <colomon> HOP: "An iterator is an object interface to a list."  :)

[02:35] <jnthn> I want to call it iterator rather than list in that case.

[02:35] <pmichaud> I.e., a List is an iteration of some sort

[02:35] <jnthn> But I can go with eliminating list or some unification there.

[02:35] <jnthn> We do need to lay down the semantics though.

[02:36] <jnthn> If a list/iterator is an immutable view of an array, what happens if the array changes?

[02:36] <jnthn> Or is it an immutable view?

[02:36] <pmichaud> it's not immutable

[02:36] <jnthn> And all that lot.

[02:36] <colomon> and it's not a view.

[02:36] <jnthn> lol

[02:36] <jnthn> Thanks guys. :-)

[02:36] <pmichaud> if you change an array while it's being iterated, you get undefined results

[02:36] <jnthn> Ok.

[02:36] <pmichaud> (this is not all that uncommon, even in p5)

[02:36] <jnthn> We can define the semantics whichever way, so long as they're defined. :-)

[02:37] <jnthn> (And if it's defined that it's undefined, that's fine too...)

[02:37] <Juerd> I'm wondering - does the word "list" remain as something to describe the syntax for multiple items with commas in between, even if lists as a type are gone?

[02:37] <pmichaud> Juerd: I suspect so.

[02:37] <colomon> Juerd: that's what I was just thinking.

[02:37] <pmichaud> and it remains the name of a context

[02:37] <jnthn> Anyway, I'm not attached to the mutable and immutable version of the common data structures view of the world.

[02:38] <pmichaud> i.e., we still have "list context", which says that certain things get interpolated into the list/iterable view

[02:38] <Juerd> pmichaud: Context is, eventually, syntactic too

[02:38] *** ShaneC left
[02:38] <jnthn> Juerd: In fact, it may help in that it avoids the issue of casting to something that can be used as a list vs to List.

[02:38] <colomon> I'm thinking list might be implemented with an Iterator looks suspiciously like a cons node.

[02:38] <colomon> (ie, it's a value and another iterator)

[02:39] <pmichaud> colomon: very nice observation

[02:39] <Juerd> jnthn: I'd really like that confusion to be gone because I've never been able to keep them apart

[02:40] <jnthn> Juerd: Same. It's like the Numeric vs Num one.

[02:40] <pmichaud> Juerd: I'd say something along the lines of  "the comma creates a parcel, which is iterable as a list in list context"

[02:41] <Juerd> It's hard enough to know the differences between arrays and lists, or parcels. And at least those have very distinct names. list versus List is too tough :)

[02:41] <pmichaud> in most cases, parcels end up acting like lists

[02:41] <jnthn> Parcels don't tend to last long before the magically become something else. :-)

[02:41] <pmichaud> well, that may no longer be true :-)

[02:41] <jnthn> In the case of calls, they don't even survive until runtime.

[02:42] <pmichaud> parcels may start to remain as parcels :-)

[02:42] <jnthn> Not for calls, surely?

[02:42] <pmichaud> no, not for calls, except in the abstract

[02:42] <jnthn> Right, good.

[02:42] *** lumi left
[02:42] *** lumi joined
[02:42] <jnthn> I think I used my "you can panic once" but I might have requested a second right to panic if that one was changing again. :-)

[02:42] <Juerd> What creates a parcel, syntactically?

[02:42] <pmichaud> Juerd: comma

[02:43] <jnthn> commas.

[02:43] <jnthn> Heh, pm beat me to it. :-)

[02:43] <Juerd> Very intuitive then, I think

[02:44] <Juerd> It looks like what we've known as a list, it behaves like one, and it has a better name. I think that's a good combination :)

[02:44] <Juerd> Oh, and it can do much more. That's good too.

[02:45] *** meppl left
[02:45] <pmichaud> so, something along the lines of   "a list is an iterator that knows how to interpolate other structures and iterators"

[02:45] *** tonio_delapampa joined
[02:46] <pmichaud> so, we can interate a parcel like      1, 2, $a, @b, 1..5     and that iterator is able to (lazily) get iterators from the array and range to use for interpolation

[02:46] <jnthn> OK, it's 3:45am here and I need to sleep. :-)

[02:46] * jnthn will backlog this lot tomorrow

[02:46] <Juerd> pmichaud: What's the name "list" good for then?

[02:47] <pmichaud> that's what we call the iterator

[02:47] <pmichaud> it's a "list"

[02:47] <Juerd> Does the parcel need a list to be iterable?

[02:47] <pmichaud> a list is really an iteration of elements

[02:48] <pmichaud> especially since a parcel in a difference context would return a different iteration

[02:48] <pmichaud> or a different result

[02:48] <pmichaud> s/difference/different/

[02:48] <pmichaud> in capture context, the parcel   1, 2, $a, @b, 1..5  has five elements

[02:48] <pmichaud> (Int, Int, Scalar, Array, Range)

[02:49] <Juerd> 03:34 <@jnthn> I want to call it iterator rather than list in that case.

[02:49] <pmichaud> also, .list remains the general form of asking an object to return itself as an iterable list

[02:49] <Juerd> That's what I'm referring to

[02:50] <pmichaud> maybe, but I prefer   @a.list to  @a.iterator

[02:50] <pmichaud> since what I get back is a list of the elements in @a

[02:50] <Juerd> If a list is just something that can be iterated, then there's no practical distinction between list and iterator anymore, is there?

[02:50] <pmichaud> (I might get them lazily, but I do get them)

[02:50] *** lumi left
[02:50] <vamped> so will we be able to iterate both the capture and the items? ie parcel[4] is range, or 2nd item of @b

[02:51] *** lumi joined
[02:51] *** colomon__ joined
[02:51] *** colomon left
[02:51] <pmichaud> vamped: parcel[4] would be the 2nd item of @b, because in most cases we default to list context

[02:51] *** tonio_delapampa left
[02:51] <pmichaud> to get to it as a parcel, use the capture prefix:     \(1, 2, $a, @b, 1..5).[4]

[02:51] <vamped> and hopefully there will be a way to specify that we want all the items in one flast "list" ?

[02:52] <vamped> s/flast/flat

[02:52] <pmichaud> vamped: sure, that's already "list"

[02:52] <Juerd> Oh. I was thinking that perhaps parcel[4] would be 1..5, and parcel.list[4] would be @b[1]

[02:52] <pmichaud>     list 1, 2, $a, @b, 1..5       #  flattens

[02:52] <pmichaud> in general we tend to do things in Perl in list context much more than capture context

[02:52] <vamped> Good! that point has been confusing to me the past couple of days.

[02:53] <pmichaud> with a for statement like

[02:53] <pmichaud>      for 1, 2, $a, @b, 1..5 { ... }

[02:53] <pmichaud> we expect the fifth iteration to be the second element of @b

[02:53] <pmichaud> and not the range

[02:53] <pmichaud> same for

[02:53] <pmichaud> my @c = 1, 2, $a, @b, 1..5;     #  @c[4]  is the second element of @b

[02:54] <vamped> but what if $a=1,2,3; ?

[02:54] <pmichaud> scalars never interpolate directly

[02:54] <Juerd> Isn't it just syntactic sugar for: iterate (1, 2, $a, @b, 1..5).list { ... }  ;)

[02:54] <pmichaud> to get that behavior, use

[02:54] <pmichaud>    1, 2, $a.list, @b, 1..5

[02:54] <pmichaud> or

[02:54] <pmichaud>    1, 2, @$a, @b, 1..5

[02:55] <vamped> yes, but if we're dealing with @c (and may not know exactly what is inside) we can't do that

[02:55] <pmichaud> vamped: hmm?

[02:56] <vamped> if @c=1,2,$a,@b,1..5; I want to do something like for @c {...} and access all the elements, including what's inside $a if $a=1,2,3;

[02:56] * Juerd tries to imagine what would happen if we had iterator context instead of list context, and fails

[02:56] <pmichaud> yeah, I think "list" is really the word we want

[02:57] <Juerd> I find list confusing

[02:57] <pmichaud> vamped: right, there's not currently a shortcut that says to auto-interpolate anything that happens to look like an array inside

[02:57] <pmichaud> (not sure there should be, either)

[02:57] <Juerd> In Perl 5 you get away with calling two different thing list because they always coincide

[02:57] <Juerd> Well, almost always

[02:58] <vamped> perhaps you're right about that pmichaud.

[02:58] <pmichaud> Juerd: well, "list" really does mean "iterator"; that's primarily because in p6 lists are "lazy"

[02:58] <pmichaud> but I don't normally talk about the iteration of elements in a Range, I tend to think of it in terms of "give me a list of all of the values in the Range"

[02:59] <Juerd> pmichaud: But then it means two things. It describes the syntax with commas and it is a kind of thing.

[02:59] <pmichaud> no, the syntax with commas is a parcel

[02:59] <Juerd> I don't think people will ever unlearn to call that a list

[02:59] <pmichaud> that's okay, I don't see that as a problem

[02:59] <Juerd> I do

[03:00] <pmichaud> in most default contexts in Perl 6, it *is* acting like a list.

[03:00] <pmichaud> and when it's not, there's a keyword or something to explicitly call out the other context

[03:03] <pmichaud> afk for a bit -- need a walk

[03:03] <Juerd> Have fun

[03:04] *** colomon__ left
[03:04] * Juerd follows jnthn's example

[03:04] <Juerd> Good night

[03:04] *** colomon__ joined
[03:05] *** lumi left
[03:05] *** lumi joined
[03:06] *** colomon__ left
[03:07] *** colomon joined
[03:13] *** Baggiokwok joined
[03:13] *** k23z__1 left
[03:21] <LaVolta> jnthn, fyi, i'm back...however, it's just a course exam...the winter vacation's about to begin.

[03:23] *** justatheory left
[03:40] <pmichaud> okay, after my walk, I think I can mentally get my head around the notion that a list is an iterator (more)

[03:41] <pmichaud> first, discard the existing notion of List as an "immutable array".  In fact, start with a blank slate on the idea of "list".

[03:41] <pmichaud> When we say "list", we're really talking about a sequence or enumeration of elements.

[03:41] <pmichaud> s/elements/items

[03:43] <pmichaud> an "iterator" is also a sequence or enumeration of items, but instead of computing the entire sequence at the time the iterator is defined, an iterator tells us how to get from one item to the next

[03:43] <pmichaud> in other words, with an iterator, we don't have to produce the entire sequence at once -- we can produce it lazily

[03:44] <pmichaud> now then, in perl 6, our lists tend to be lazy by default

[03:44] <LaVolta> pmichaud, laziness is true virtue :)

[03:45] <pmichaud> in other words, we say that unless something indicates to the contrary, we try to produce all of our sequences (i.e., lists) lazily

[03:45] <pmichaud> so a "lazy list"  is really the same as an iterator

[03:46] <pmichaud> this is in contrast with Perl 5, where lists actually tended to be eager by default

[03:46] *** lumi left
[03:46] <pmichaud> in Perl 5, it was important to distinguish between "list" and "iterator" because one was eager and the other was lazy

[03:46] *** lumi joined
[03:47] <pmichaud> returning to p6, we still want to call things "lists" instead of "iterators"  because we're still talking about sequences

[03:47] <pmichaud> they're just lazy sequences now instead of eager ones

[03:48] <pmichaud> also,  we tend to want to talk about the sequence as a whole ("list")  rather than the process that was used to produce the sequence ("iterator")

[03:48] <perigrin> perhaps borrow from HOP and s/list/stream/ ?

[03:48] <pmichaud> good idea.  but we still want to talk about it as a whole, I think.

[03:49] <perigrin> yeah, but a list is potentially finite while  stream is unknowable because of it's laziness

[03:49] <perigrin> :)

[03:49] <pmichaud> in other words,  I want to be able to say   (1..100).list    as opposed to   (1..100).stream

[03:49] <perigrin> yes

[03:49] <pmichaud> so "list" seems like the right term.

[03:50] <pmichaud> anyway, an "array" then is a list that has memory

[03:50] * perigrin nods

[03:50] *** justatheory joined
[03:50] <pmichaud> in an array, as we enumerate the elements of the list, we also record them so that we can go back to them later

[03:50] *** justatheory left
[03:52] <pmichaud> externally, someone using an array doesn't know that it has lazy portions -- conceptually the array looks as though it is "eager"

[03:52] <perigrin> it's actually a pair (or more) of lists 

[03:52] <perigrin> one a vector of indicies 

[03:52] <perigrin> that enumerates the second

[03:52] <vamped> perigrin: that's what I was thinking but couldn't put it to english.

[03:52] <pmichaud> that's not the way I see it

[03:53] <pmichaud> an array contains things we've already enumerated, and lists that we've yet to enumerate

[03:54] <pmichaud> if we ask an array for something beyond the set of things we've already enumerated, it starts using its lazy lists to fill out the enumerated sequence until we get to what we're looking for

[03:56] <perigrin> hmm

[03:56] <perigrin> "yes" but I think that misses something that I'm not sure you care about since I missed the context 

[03:57] *** stepnem left
[03:57] <vamped> so 1,2,3,4..10 contains both an array (1,2,3) and a list (range 4..10) ?

[03:58] <pmichaud> vamped:  if you're looking at it as perl code, that's still a parcel

[03:58] <pmichaud> it's a parcel with a 1, a 2, a 3, and a range 4..10

[03:58] <pmichaud> but let's look at it this way:

[03:58] <pmichaud>     my @a = 1,2,3,4..*;

[04:00] <pmichaud> internally, @a ends up with enumerated items 1, 2, and 3   (at indexes 0, 1 and 2)   and an "unenumerated" range of 4..*

[04:01] <pmichaud> if we ask for  @a[7], then the array internally starts iterating over its unenumerated list to add elements to its enumerated list until it reaches the one at index 7

[04:02] <pmichaud> let's rephrase that without the word "iterating"

[04:02] <pmichaud> so

[04:03] <pmichaud> if we ask for @a[7], then the array internally grabs new items from its unenumerated list(s) and adds them to the enumerated sequence until it's able to fulfill the request for the element at index 7.

[04:03] *** snarkyboojum joined
[04:04] <pmichaud> anyway, the fundamental idea for me is that "lazy list" really means the same thing as "iterator"

[04:04] <vamped> ok. and I assume we want the enumeration to be uni-directional -- indexing starting at 0 (more)

[04:04] <pmichaud> and "array" is "a list where we remember the entire sequence of elements"

[04:04] <vamped> @a=1..10000,6,7; so it will not be possible to access @a[*-1] without filling in 10000 missing pieces ?

[04:05] <pmichaud> vamped: probably not, since *-1 in this case depends on knowing the last index (more)

[04:05] <perigrin> pmichaud: except you just said you dont' remember the entire sequence, just the ones enumerated "so far" :)

[04:05] <pmichaud> we remember the ones enumerated so far, and the lists that can tell us how to get to the remaining items in the sequence

[04:06] <pmichaud> (an array contains enumerated items and unenumerated lists)

[04:06] <pmichaud> vamped: I suppose it may be possible at some point to enumerate things at both ends, however.

[04:07] <pmichaud> that's likely to be a future feature, though.

[04:07] <vamped> it seems plausible from a lay-man standpoint anyway. anyway your mental model is looking good to me.

[04:08] <pmichaud> well, I'm also writing this for people who might read backscroll a bit later :)

[04:08] <pmichaud> (and to have a record of what I was thinking on my walk)

[04:08] <pmichaud> I'm also thinking it's feasible for a list to be Positional

[04:09] <pmichaud> what happens in that case is that the list uses itself to build an array, responds to the positional request(s), and then drops the array

[04:09] <pmichaud> so that   @b.map( { ... } ).[5,7,3]   works

[04:10] <pmichaud> essentially, postcircumfix:<[ ]>  on a list simply does it work on a temporary array

[04:10] <perigrin> pmichaud: mind if I present a slightly different take on it?

[04:10] <pmichaud> not at all

[04:11] <perigrin> a lazy list is the output of a function with a null signature

[04:11] <perigrin> that is the same thing as an "iterator" ... it simply provides a stream of values

[04:11] *** pnate joined
[04:12] <perigrin> an array is then the output of a function with a single element signature (the index)

[04:12] <perigrin> well a "hash"

[04:13] <perigrin> an array in Perl terms is then a hash where the index is generated from a list of sequential integers

[04:13] <perigrin> if you see what I mean

[04:13] <pmichaud> sure

[04:14] <perigrin> so (1,2,3,4..Inf) becomes a coroutine that returns 1 then 2 then 3 then 4 ... then evaluates the range to start generating further values

[04:14] <perigrin> this means that when you get to an array

[04:15] <perigrin> @foo[7] becomes something you could potentially calculate directly 

[04:15] <perigrin> rather than having to populate the entire list up to 7

[04:15] *** Exodist_test joined
[04:15] <pmichaud> that works in this specific case, but not in the general case

[04:15] *** Exodist_test left
[04:15] <pmichaud> we don't always know the number of elements a given iterator will produce

[04:15] *** Exodist_test joined
[04:15] <pmichaud> so if I have

[04:15] <perigrin> yes

[04:16] <pmichaud> (1,2,3, ..iterator..,  7, 8, 9)

[04:16] <pmichaud> and I ask for @foo[7]

[04:16] <pmichaud> I can't really find out where to jump without going through the iterator

[04:16] <perigrin> (1,2,3,4..Inf,7,8,9) is a good example because the middle is incalcuably large

[04:17] <pmichaud> oh, but in that case I can still easily jump to 7

[04:17] <pmichaud> because it clearly lands in the middle of the first iterator

[04:17] <pmichaud> the problem is when ..iterator.. might have a finite number of elements, but can't be known without actually stepping through them

[04:17] <pmichaud> for example, when reading from a filehandle

[04:18] *** lumi left
[04:18] <pmichaud> also, some iterators are destructive (such as filehandles)

[04:18] <pmichaud> and some iterators are expensive, such that you really want to store the results of what you've already computed rather than recomputing on each request

[04:18] <perigrin> in those cases you *would* have to resort to calculating the value iteratively or recursively yes

[04:18] <perigrin> you couldn't know what element was 7 until you knew what was 6 ... etc

[04:18] <perigrin> until you got to a known start state

[04:19] <pmichaud> right

[04:19] <perigrin> it was just another way of illustrating the same concept

[04:19] <pmichaud> right

[04:19] <pmichaud> one could conceivably come up with optimizations whereby finite lists don't have to be expanded in the enumerated section

[04:20] <pmichaud> (e.g., to save memory or computation time)

[04:21] *** lumi joined
[04:22] <pmichaud> anyway, that summarizes why I think it's okay to be thinking of "list" as "iterator".  Now to see if I can put it into implementable terms :)

[04:22] <pmichaud> later, though -- I'm going to take a break for a while.

[04:23] <perigrin> there's some nice stuff in python with Generators I was looking at trying to grok corouteins

[04:27] *** _jaldhar left
[04:29] *** smash__ joined
[04:34] *** Alias left
[04:44] *** Exodist_test left
[04:46] *** smash_ left
[04:47] *** jenk joined
[04:48] *** drbean left
[04:54] *** nihiliad joined
[04:56] *** vamped left
[05:02] *** stephenlb left
[05:05] * diakopter tries to discern under which user jifty (commitbit) was running previously

[05:08] *** lumi left
[05:08] *** lumi joined
[05:38] *** [particle]1 joined
[05:41] *** [particle] left
[05:46] *** gmat joined
[05:46] *** gmat left
[05:51] <diakopter> whee!

[05:51] <diakopter> finally got commitbit back

[05:51] <diakopter> http://commitbit.pugscode.org

[05:51] *** snarkyboojum left
[05:51] <diakopter> enjoy

[05:52] * diakopter out

[05:52] *** lumi left
[05:52] *** lumi joined
[06:05] *** jaldhar joined
[06:31] *** agentzh joined
[06:31] *** agentzh left
[06:34] *** vamped joined
[06:37] *** lumi left
[06:37] *** lumi joined
[06:44] *** vamped left
[06:48] *** nihiliad left
[07:36] *** cognominal joined
[07:44] *** agentzh joined
[08:04] *** mssm joined
[08:04] *** lumi left
[08:04] *** lumi joined
[08:19] *** colomon_ left
[08:35] *** vamped joined
[08:36] *** vamped left
[08:37] *** eternaleye left
[08:41] *** lumi left
[08:41] *** lumi joined
[08:45] *** eternaleye joined
[08:54] *** mikehh joined
[09:20] *** patspam left
[09:21] *** sjohnson sets mode: +o cognominal

[09:29] *** snarkyboojum joined
[09:32] *** kst left
[09:32] *** kst joined
[09:41] *** Su-Shee joined
[09:41] <Su-Shee> good morning

[09:42] *** mjk joined
[09:42] *** mjk left
[09:43] *** mjk joined
[09:44] *** cognominal left
[09:44] *** |mjk| joined
[09:44] *** mjk left
[09:44] *** |mjk| left
[09:44] *** mjk joined
[09:52] *** Su-Shee left
[09:54] *** Su-Shee joined
[09:54] *** mjk left
[09:56] *** snarkyboojum left
[09:58] *** lumi left
[09:58] *** lumi joined
[10:03] *** cognominal joined
[10:51] *** kaare joined
[10:52] *** kaare is now known as Guest78210

[10:57] *** lumi left
[10:57] *** lumi joined
[11:13] *** drbean joined
[11:14] *** colomon left
[11:19] *** colomon joined
[11:21] <colomon> now?

[11:21] <colomon> this time for sure?

[11:23] <colomon> morning!

[11:25] *** agentzh left
[11:26] *** agentzh joined
[11:27] <colomon> pmichaud: lists are always lazy feels right to me

[11:28] *** riffraff joined
[11:30] *** agentzh left
[11:32] *** lestrrat is now known as lest_away

[11:33] <colomon> so, hmmmm... do we need to be able to clone iterators?

[11:38] *** schmalbe joined
[11:39] *** k23z__ joined
[11:41] *** lest_away is now known as lestrrat

[11:48] *** LaVolta left
[11:55] *** meppl joined
[11:58] <colomon> HOP suggests defining a special $EXHAUSTED value to use as a sentinel instead of undef (our Nil) (page 168)

[12:01] *** pmurias joined
[12:07] *** jackyf joined
[12:09] *** payload left
[12:10] *** payload joined
[12:19] *** Baggiokwok left
[12:20] *** riffraff left
[12:26] <colomon> hmmm, HOP also defines a bunch of other possible interfaces.  

[12:27] <colomon> but I think $EXHAUSTED may be the ticket for us.

[12:28] <colomon> it has that simple and correct feeling.

[12:31] <colomon> I think we will want TimToady's Iterable role, too.

[12:31] <colomon> So Any.list would become something like:

[12:33] <colomon> multi method list() { given self { when Iterator { return self; } when Iterable { return self.Iterator } default { return make_list(self); } }

[12:33] *** schmalbe left
[12:34] <colomon> where make_list takes a scalar and returns an iterator that returns that scalar.

[12:34] <colomon> of course, the right way to do this is using OO dispatch.

[12:35] <colomon> So role Iterator should define .list (which is just "return self"), and what I gave as Iterable.Iterator up there should actually be Iterable.list.

[12:37] <colomon> seems to me a bonus of all this is a bunch of very low-level p6 concepts can suddenly be implemented in p6 itself.

[12:44] *** payload left
[13:10] *** k23z__ left
[13:14] *** k23z__ joined
[13:24] *** clintongormley joined
[13:26] *** athaba joined
[13:29] *** k23z__ left
[13:47] *** cognominal left
[13:47] *** Baggiokwok joined
[13:54] *** snarkyboojum joined
[13:59] <pugs_svn> r29581 | lwall++ | [Spec] random whackage on List, Seq, Parcel, Capture, Iterator, Nil etc. 

[13:59] <pugs_svn> r29581 | List is now simply the iterator role, and doesn't do Positional.

[13:59] <pugs_svn> r29581 | Seq takes over Positional duties for reified (or reifiable) value lists.

[13:59] <pugs_svn> r29581 | Think of Seq now as a constant Array (but also lazy like Array)

[13:59] <pugs_svn> r29581 | Iterable now means you can ask for an iterator, but doesn't do List.

[13:59] <pugs_svn> r29581 | Array, Seq, etc do Iterable, but not List.  Only actual iterators do List.

[13:59] <pugs_svn> r29581 | Nil is defined as a suitable sentinel for both list and slice iterators.

[14:00] <dalek> rakudo/ng: 8aedd0c | (Solomon Foster)++ | src/core/List.pm:

[14:00] <dalek> rakudo/ng: Start throwing iterator example code into List.pm.  Compiles but not tested or used for anything.

[14:00] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/8aedd0c5eea27b37f7019c5117afc9897dc04e5a

[14:01] *** payload joined
[14:01] *** frederico left
[14:01] *** frederico joined
[14:06] *** cognominal joined
[14:17] <colomon> TimToady: you out there?

[14:19] <colomon> Doesn't Iterator have to be a mutable type?

[14:25] <colomon> that is, it has state, and that state has to change for the iterator to be useful.

[14:33] *** drbean left
[14:44] <pugs_svn> r29582 | lwall++ | [S02] some clarifications for colomon++ 

[14:50] <colomon> TimToady: :)

[14:50] *** snarkyboojum left
[14:51] *** synth left
[14:51] *** snarkyboojum joined
[14:51] *** snarkyboojum left
[15:00] *** vamped joined
[15:01] <vamped> g'morning

[15:01] *** perigrin left
[15:01] <pmichaud> good morning

[15:01] <pmichaud> oooh, spec updates!  backscroll!  

[15:01] * pmichaud reads

[15:02] *** dalek left
[15:03] *** Baggiokwok left
[15:03] *** dalek joined
[15:03] *** perigrin joined
[15:03] <colomon> morning!

[15:03] *** BinGOs left
[15:04] *** k23z__ joined
[15:05] <pmichaud> part of me wants "get the next element at the head of the list"  to be .shift

[15:07] <colomon> :)

[15:08] <vamped> yes, in a way, the same.

[15:09] <pmichaud> ouch, I'm not entirely happy with the new Seq.

[15:09] <pmichaud> (although I did consider something similar last night)

[15:11] <pmichaud> I'm not sure we need pushback/unshift on iterators.  An iterator that does pushback/unshift is just an array.

[15:18] <colomon> I like the idea that pushback / unshift are special Iterator roles, as in S07.  It's easy enough to code an adaptor that turns a normal Iterator into either, after all...

[15:19] <pmichaud> colomon: why?

[15:19] <pmichaud> I mean, if an iterator with pushback acts like an array, why not just use an array?

[15:20] <pmichaud> imo, the notion of pushback/unshift on an iterator comes from a time when we didn't have lazy arrays

[15:20] <colomon> yeah, maybe?  I guess if an array can be lazy, there is very little practical difference.

[15:20] <pmichaud> so, pushback/unshift was a way of being able to put values into the iterator without forcing it to be eager, and we couldn't traditionally use an array for that because arrays were eager

[15:21] <colomon> I guess part of the reason I like the idea of the special roles is that we can completely defer actually worrying about them.  :)

[15:21] <pmichaud> but now that our arrays are lazy....   it's trivial to have an array that is built from an iterator and supports the pushback/unshift semantics

[15:22] <pmichaud> in other words, we can now do:

[15:22] <pmichaud> my @a = $socket.lines;

[15:22] <pmichaud> and if we need to push something into the stream, we just use @a.unshift

[15:23] <colomon> another point against the idea: it is trivial to implement using Iterator classes we're going to need anyway.

[15:23] <colomon> that is, we have to have an iterator class that has two iterators and does one, then the other.

[15:23] <pmichaud> not so trivial, actually

[15:24] <pmichaud> it means that every iterator that implements .get also needs to have a way of checking its pushback array

[15:24] <colomon> pmichaud: I'd argue that's the wrong approach.

[15:24] <pmichaud> put another way, the more you work on the "trivial" implementation, I think you just discover that it is, in fact, the same as an array implementation

[15:26] <colomon> that is, you take a normal array that implements .get without pushback, and add a buffer to implement pushback.  that can be done with a simple class.  though probably it has an array internally, for sure.

[15:26] <pmichaud> but why do that?

[15:26] <pmichaud> what advantage does that give us over using an array?

[15:26] <colomon> getting back on track, though, I think punting on pushback and unshift is appropriate for a first implementation.

[15:26] <pmichaud> fair enough, I'm willing to punt for now

[15:27] <pmichaud> TimToady: I'm not comfortable with the idea that "list" creates a Seq

[15:27] <colomon> because I don't see any advantage over an array other than I feel like I better understand how to implement it.  :)

[15:28] <pmichaud> in particular, I don't like the consequences of      for list($a, $b, 1..10000, @c) { ... }

[15:28] *** cognominal left
[15:29] *** cognominal joined
[15:29] <pmichaud> stated another way, I need a function/operator that performs list interpolation on its arguments without also imposing the "and remember everything you produce" semantic

[15:30] <pmichaud> (and I think "list" should be that function/operator)

[15:31] <pmichaud> if I want something to produce a Seq, it should be "Seq(...)"  or "seq" or something like that.

[15:31] *** ispeak joined
[15:34] <pmichaud> oops, apologies -- I misread the diff

[15:34] <pmichaud> a list in item context becomes a Seq, not any list

[15:35] <pmichaud> okay, I think that's fine for me

[15:35] *** ispeak left
[15:36] <vamped> pmichaud: back to .shift vs .get -- I think it is important to be consistent. if .get is the opposite of .unshift, then the two methods should either be (.shift and .unshift) or (.get and .put)

[15:37] <pmichaud> vamped: perhaps, although I'd prefer not ".put" -- it has a different traditional meaning

[15:37] <pmichaud> in the C world, "put" tends to mean "write" and not "pushback"

[15:38] <pmichaud> but yes, shift/unshift seem more appropriate to me (more)

[15:38] <vamped> perhaps, but in english it seems that get and put are opposites, as are shift and unshift.

[15:38] <pmichaud> however, if we go with the idea that iterators don't implement pushback semantics, and only generate elements, then I'm okay with the idea that "get the next element" has a different name than "shift"

[15:39] <vamped> wfm

[15:39] <pmichaud> in general terms, I expect most people to be using "shift" (on an array) in order to deal with any sort of iterator

[15:40] <pmichaud> let's look at the implementation of map, for instance

[15:40] <pmichaud> or any function that wants to iterate over a list

[15:40] <pmichaud> sub map( &block, *@values ) { ... }

[15:41] <pmichaud> we probably want @values to be evaluated lazily here

[15:41] <pmichaud> we also don't want to keep each value hanging around after we're through with it, in case it happens to be a very long lazy list

[15:42] <pmichaud> so, we'd tend to do     while (@values) {   my $item = @values.shift; ... }

[15:42] <pmichaud> that way a call like    map( { ... },  1..1000000 )    doesn't end up creating a million-element array

[15:42] *** uniejo joined
[15:43] *** colomon left
[15:43] *** colomon joined
[15:45] <pmichaud> so, internally the iterator can indeed have something like .get, but the way that most people will end up using it is with .shift

[15:46] <pmichaud> the same goes for lazy feeds

[15:46] <pmichaud> my @a <== $file.lines();   # lazy read of a file

[15:46] <pmichaud> while (@a) { $line = @a.shift; ... }

[15:47] <pmichaud> and if we want to push something back into the 'iterator', we end up doing unshift on the array, not on the list returned by $file.lines() (which we don't have access to anyway)

[15:48] * jnthn drops by

[15:48] <jnthn> pmichaud: Last bits sound sane to me, fwiw. :-)

[15:48] <pmichaud> greetings, jnthn.  the world changed again.  :-)

[15:49] <jnthn> pmichaud: oh noes!

[15:49] <jnthn> pmichaud: :-)

[15:49] <jnthn> pmichaud: What should I read for latest?

[15:49] *** Psyche^ joined
[15:50] <pmichaud> r29851 diff, mainly

[15:50] <pmichaud> er, 29581

[15:50] <pmichaud> (transpose)

[15:50] <jnthn> wow, that's a biggy.

[15:52] * colomon will be in and out all day -- in-laws down to help clean again

[15:52] <pmichaud> "An iterator

[15:52] <pmichaud> +can never return C<Nil> as an ordinary value, so it is the sentinel

[15:52] <pmichaud> +value that marks the end of iteration.

[15:52] <pmichaud> ...for some reason that sets off alarm bells to me.

[15:53] <pmichaud> (It didn't last night, but it does this morning)

[15:53] <jnthn> Yes, I would prefer that out of band too.

[15:53] <pmichaud> no, it's not that so much.

[15:53] <pmichaud> it's just that I can imagine an iterator returning Nil at some point.

[15:54] <pmichaud> but maybe not.

[15:54] <pmichaud> speculating:

[15:54] <pmichaud>     my $c = \(1, 2, (), 4);

[15:55] <pmichaud>     my $d = $c[2];   # $c[2] is Nil

[15:55] *** Patterner left
[15:55] <pmichaud>     for @$c { ... }    # only iterates over three elements -- skips the Nil element?

[15:56] *** Psyche^ left
[15:56] <colomon> I believe that's what TimToady has been saying, yes.

[15:56] *** Patterner joined
[15:56] <pmichaud> just seems weird that the capture would have something at index 2 but an iterator would always skip over it.

[15:56] <colomon> personally I still like the idea of a sentinel value instead of Nil, a special constant we set up.

[15:57] <colomon> (and pity the fool who wants to return that constant from an iterator for some reason)

[15:57] <jnthn> A Failure of some kind.

[15:57] <pmichaud> well, we could have a constant that we check for by its .WHICH value

[15:58] <colomon> Though another notion I had was if you wanted to return Nil from an iterator, you needed to create a special NilIterator value and return it.  (NilIterator being the iterator that is always done.)

[15:59] * colomon goes back to boxing

[15:59] *** am0c left
[15:59] <pmichaud> or perhaps in the case of     my $c = \(1, 2, (), 4);    the () gets itemized into an empty Seq or something.

[16:00] *** payload left
[16:01] <pmichaud> although that can't be right, because Nil is supposed to itemize into an undef of somes ort

[16:01] <pmichaud> *some sort

[16:01] <jnthn> +When it runs out of items, it will return C<Nil>.  List context

[16:01] <jnthn> +always removes C<Nil> values as part of flattening, while slice

[16:01] <jnthn> +context always promotes parcels to C<Seq>, so it is never possible

[16:01] <jnthn> +for this method to return C<Nil> as a value.  We can use C<Nil> as

[16:01] <jnthn> +the sentinel because iterators never return C<Parcel>s. and C<Nil>

[16:01] <jnthn> +is defined as the empty C<Parcel>.

[16:01] <jnthn> Is that saying that Nil can never happen anyway?

[16:01] <pmichaud> in the case of    my $c = \(1, 2, (), 4);      we're not in list context.

[16:02] <pmichaud> although maybe  @$c  implies that we are in list context.

[16:02] <jnthn> Yeah

[16:02] <jnthn> I think so.

[16:02] <pmichaud> but then, what to do with...

[16:02] <pmichaud>     for (@$c).kv { ... }

[16:03] <pmichaud> because after the Nil element, the indices no longer match up :-)

[16:04] <jnthn> But doesn't the list context make the () disappear?

[16:04] <pmichaud> what list context?

[16:04] <jnthn> Because it flattens the list?

[16:04] <jnthn> The one implied by that @ there.

[16:04] <pmichaud> sure

[16:04] <jnthn> So by the time .kv sees it the () is no more

[16:04] <jnthn> Oh, unless you're saying that's the problem. :-)

[16:04] <pmichaud> I'm saying that's the problem.

[16:04] <jnthn> Ah.

[16:04] <jnthn> OK

[16:05] <jnthn> I didn't consider it a problem. ;-)

[16:05] <pmichaud> for (@$c).keys {   say $c[$_];  }    #  oops, we never see the 4

[16:05] <jnthn> Just read through that diff...it looks sane.

[16:05] <jnthn> Yeah, I see what you mean. Hm.

[16:08] <pmichaud> I'm not sure I see the purpose of the Iterable role yet.

[16:08] <jnthn> "I can ask for an iterator", iiuc.

[16:08] *** payload joined
[16:08] <TimToady> probably just means that .list works

[16:08] <pmichaud> but .list works on everything, iiuc

[16:08] <jnthn> role Iterable { method list() { ... } }

[16:09] <jnthn> Well, yeah, if list is the thingy that enforces list context... :-/

[16:09] <jnthn> erm, if .list is, I mean.

[16:09] <pmichaud> no, .list doesn't mean "list context".  It means "object as a list"

[16:09] <TimToady> Cool.list is a fallback, not a role-supplied method

[16:09] <TimToady> Iterable means you can ask it for an iterator

[16:10] <pmichaud> so.....

[16:10] <jnthn> TimToady: What are the fallbacks in Cool meant to be dispatchable to?

[16:10] <pmichaud> do we still have the case that    (3).elems  ==  1   ?

[16:11] <TimToady> yes, but that's also because of Cool's .elems, not because everything does Positional

[16:12] <pmichaud> so, in the general case,   ($x).elems   could fail if $x isn't Cool ?

[16:12] <TimToady> well, if that worries us, we can put that one into Any :)

[16:12] <pmichaud> same for something like    $y.join('xyz')

[16:12] <pmichaud> ?

[16:13] <TimToady> the listy ones might still be in Any rather than Cool

[16:13] <TimToady> but maybe not

[16:13] <pmichaud> ...and if that's the case, then I get to my question of ".list works on everything"

[16:13] <TimToady> but not always for the same reason

[16:13] <pmichaud> sure

[16:14] <pmichaud> but then I don't see what "Iterable" does, if it's purpose is to say ".list works"

[16:14] <TimToady> it's a role, it means "I implement list" rather than relying on some fallback

[16:15] <TimToady> it means "I care about visitation and can visit more than one thing"

[16:15] <pmichaud> okay, I can accept that.

[16:15] *** stepnem joined
[16:15] <TimToady> the default is self-visitation, is all

[16:16] <colomon> I still think the last big worry is copying iterators.

[16:16] <pmichaud> wfm

[16:16] <pmichaud> colomon: what's an example of copying an iterator?

[16:17] <colomon> my @a <== 1...100000; my @b = @a

[16:17] <colomon> ?

[16:17] <pmichaud> the second assignment is mostly eager, there.

[16:18] <pmichaud> it would end up reifying both @b and @a

[16:18] <colomon> I've been thinking about the list operators I mucked about trying to implement earlier, and I'm trying to think of how to implement .... umm, is it xx now? ... using iterators.

[16:19] <colomon> maybe there isn't actually a use case for copying iterators and I'm worrying about nothing.

[16:19] <colomon> Any idea how often Lists get copied now?

[16:19] <pmichaud> depends on what you mean by "now"

[16:19] *** Chillance joined
[16:19] <colomon> in master.

[16:19] <TimToady> yes, "now" is what transactions are all about defining

[16:20] <pmichaud> colomon: in master, we don't have laziness.  So, always.  :-)

[16:21] <colomon> Certainly with the interface we're talking about now, we can naively copy iterators if we're working at iterator level, right?  my $iter = $x.list;  my $iter2 = $iter;

[16:21] <colomon> are we going to argue that shouldn't work?

[16:22] <pmichaud> with the interface we're talking about now,  $iter isn't an iterator, it's a Seq

[16:22] <pmichaud> because a list in item context becomes a Seq

[16:22] <TimToady> you can still get at the underlying iterator if you need to

[16:23] <pmichaud> in which case I'd say it's not a copy, but a reference

[16:23] <TimToady> yes, and .get on one advances everyone's view

[16:23] <TimToady> (in that case)

[16:23] <TimToady> not saying that's necessarily good

[16:23] <TimToady> biab &

[16:24] *** BinGOs joined
[16:24] <pmichaud> colomon: in your example of    my $iter2 = $iter, we end up with both $iter and $iter2 pointing to the same Seq

[16:24] <pmichaud> much like if I have    my $a = [1,2,3];  my $b = $a;   

[16:24] <pmichaud> $b isn't a copy of the array, it's the same array.

[16:25] <pmichaud> (and since it's the same Seq, we don't need to copy the iterator)

[16:25] <pmichaud> yes, we might need to have .clone on an iterator available; I'm just saying it doesn't seem to occur naturally

[16:30] <colomon> Ah, I guess I don't understand how Seq is supposed to work yet.

[16:30] <pmichaud> Seq is basically an immutable array, iiuc

[16:30] <colomon> I think my issue is I don't understand when they come into existence.

[16:30] <pmichaud> right now, whenever a list is used in item context

[16:31] <colomon> then how do you ever manage to work with the iterator itself?

[16:31] <pmichaud> that's kind of the point -- you don't need to.

[16:32] <pmichaud> +Types that do the C<List> role are generally hidden from casual view,

[16:32] <pmichaud> +since iteration is typically triggered by context rather than by

[16:32] <pmichaud> +explicit call to the iterator's C<.get> method.  Filehandles are a

[16:32] <pmichaud> +notable exception.

[16:32] <diakopter> O_O

[16:32] <colomon> but you do need to work with it to implement iterator support!

[16:33] <pmichaud> if you're asking "how does one get an iterator", I think it's via the .Iterator (or .iterator) method

[16:33] <pmichaud> (haven't read the updated spec for that)

[16:34] <colomon> ah, I thought the whole point of .list was it returned the iterator.

[16:34] <pmichaud> no, .list returns something that iterates

[16:34] <pmichaud> you don't do  .get on the thing returned by .list

[16:34] <pmichaud> the thing that is returned by .list does the .gets for you

[16:35] <vamped> i think it's conceivable that one might want to copy an iterator, where when one changes it does NOT change the other. 

[16:35] <pmichaud> vamped: sure, that'd be .clone

[16:35] <vamped> ok. so @a = @b.clone ?

[16:36] <pmichaud> no, because @b isn't an iterator

[16:36] <TimToady> I have no idea what that means on a lazy iterator

[16:36] <pmichaud> and right, cloning a lazy iterator (e.g., on a filehandle) doesn't always make sense

[16:36] <pmichaud> so .clone is very iterator specific

[16:36] <colomon> pmichaud: this thing that .list returns -- how does it know when it needs to .get ?  I don't understand how it is different in concept from an iterator.

[16:37] <pmichaud> colomon: it knows based on when you use it

[16:37] <pmichaud> essentially, it does the .get when you ask for an element

[16:38] <colomon> I'm not crazy here, though, right?  I mean, isn't "asking for an element" exactly the same in concept as calling .get?  Why have two different interfaces to do this?

[16:39] <pmichaud> look at it this way

[16:39] <pmichaud> suppose we have an iterator

[16:39] <pmichaud> let's call it $iter

[16:39] <pmichaud> what happens with     for $iter { ... }   ?

[16:40] <pmichaud> one thing that we know is that it _doesn't_ iterate the iterator here

[16:40] <pmichaud> if we want to do that, we have to do

[16:40] <pmichaud>     for $iter.list { ... }

[16:40] <pmichaud> ehh, this is a icky example

[16:41] <pmichaud> never mind

[16:41] <pmichaud> the main difference is that .list returns us the result of iterating an iterator

[16:42] <pmichaud> my $a = @a.iterator;   # $a is an Iterator

[16:42] <pmichaud> my $a = @a.list;   # $a is a Seq

[16:44] <colomon> is that just a difference in semantics, then?  ie I've been imagining that the method name was  .list, but it's actually .iterator?

[16:45] <pmichaud> they're in fact different results

[16:45] <colomon> wait, I can almost see it with the for example.

[16:45] <pmichaud> maybe this helps:

[16:45] <pmichaud> my @a = 1..10;

[16:45] <pmichaud> my @b = @a.list;

[16:45] <pmichaud> my @c = @a.iterator;

[16:45] <pmichaud> how many elements does @b have?

[16:46] <pmichaud> how many elements does @c have?

[16:46] <colomon> should that be $c instead?

[16:46] <pmichaud> no, @c

[16:47] <colomon> in my admittedly broken understanding, I'd think @b has 10 elements and @c has one.

[16:47] <pmichaud> correct.

[16:47] <pmichaud> and that's why .list doesn't return an iterator

[16:47] <pmichaud> it returns something that does the iteration

[16:47] <colomon> which is in fact a Seq?

[16:47] <pmichaud> s/does/drives/

[16:48] <pmichaud> no, it's not a seq, unless placed into item context

[16:48] * jnthn gotta go again, will backlog

[16:48] <pmichaud> a seq remembers all of the values of the iteration.  in general we don't want to do that

[16:48] <colomon> right.

[16:49] <Juerd> Does my @b = @a.list make @b lazy, or do you need := for that?

[16:49] <pmichaud> Juerd: you want <== for that

[16:49] <pmichaud> my @b <== 1..10000;   # forces laziness

[16:49] <colomon> my head's going in circles now, and I need to run downstairs and try to figure out why my server is no longer talking to my LAN.  but I will keep pondering this.

[16:50] <pmichaud> one can also do    my @b = lazy @a

[16:50] <Juerd> Hmm

[16:50] <vamped> so, we can't do $c = @a.iterator ?

[16:50] <pmichaud> (I think, if the 'lazy' keyword still exists)

[16:50] <Juerd> lazy as a keyword on the LHS looks wrong

[16:50] <pmichaud> vamped: you *can* do $c = @a.iterator -- that gives you the iterator itself instead of the results of the iteration

[16:50] <Juerd> s/L/R/

[16:51] *** tylerni7 left
[16:51] <pmichaud> Juerd: arrays are inherently lazy, but list assignment is "mostly eager"

[16:51] *** cls_bsd left
[16:55] <pmichaud> here's a question (for TimToady)

[16:55] <pmichaud> what about something like

[16:55] <pmichaud>      my @b = @a.map( { ... } );

[16:56] <pmichaud> assuming @a is finite, does the assignment take place eagerly?  and how does it know?

[16:57] *** vorner joined
[16:59] <pmichaud> feels like we'll need a way for lists and/or iterators to be able to say "I can still give you 'mostly eager' elements"

[16:59] <pmichaud> (and it has to be transitive)

[17:01] *** vamped left
[17:02] <pmichaud> does that sound correct-ish?

[17:03] *** tylerni7 joined
[17:03] <TimToady> nodnod

[17:03] * TimToady will be very distracted today; scorekeeping for four simultaneous quizzes...

[17:03] <pmichaud> that's fine, I'm just trying to publicly plow our collective path through this :-)

[17:04] *** nihiliad joined
[17:08] <colomon> pmichaud: I've briefly wondered if the "I can give you mostly eager" thing ought to be a role.  subrole?

[17:09] * colomon doesn't have a solid feel for how to design "class" hierarchies in the role-enabled world....

[17:13] *** Su-Shee_ joined
[17:17] <TimToady> probably more like: I do/don't know whether I'm finite/infinite

[17:18] <TimToady> or .estimate_available that can return a number, or Inf, or *

[17:18] <TimToady> where the estimate might or might not be terribly accurate, but would be good for an initial allocation in the destination

[17:19] <TimToady> so a filehandle might guess at the number of lines in a file

[17:19] <TimToady> but a RangeIterator knows exactly how many it has

[17:24] *** aindilis left
[17:30] *** Su-Shee left
[17:31] *** japhb joined
[17:34] *** clintongormley left
[17:34] *** clintongormley joined
[17:35] <pmichaud> TimToady: yes, I was thinking a similar thing on my walk.  Something like  .finity  which returns the number of items the iterator believes it can cheaply/easily produce

[17:38] *** simcop2387 joined
[17:38] *** simcop2387 left
[17:39] *** simcop2387 joined
[17:40] *** Su-Shee_ left
[17:50] *** cognominal left
[17:55] *** Chillance left
[18:00] *** eternaleye left
[18:01] *** colomon_ joined
[18:03] *** directrixx joined
[18:11] *** cognominal joined
[18:11] *** meteorja1 left
[18:11] *** meteorjay joined
[18:15] *** jaldhar left
[18:16] *** colomon left
[18:16] *** colomon_ is now known as colomon

[18:17] *** payload left
[18:18] *** justatheory joined
[18:21] *** vorner left
[18:35] *** cono joined
[18:35] <cono> perl6: ([/]1..3).perl.say

[18:35] <p6eval> pugs: *** ␤    Unexpected "1"␤    expecting dot, ":", "(", term postfix, operator or ")"␤    at /tmp/TAIUUosfeX line 1, column 5␤

[18:35] <p6eval> ..elf 29582: Parse error in: /tmp/iJkQFQeiLU␤panic at line 1 column 3 (pos 3): Error in quotesnabber␤WHERE: ([/]1..3).perl.say␤WHERE:   /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:1311:in `quotesnabber'␤  (eval):1:in `__quote_8917700'␤  STD_red/prelude.rb:406:in `block in

[18:35] <p6eval> ..longest_to…

[18:35] <p6eval> ..rakudo 1d4928: 1/6␤

[18:35] <cono> perl6: ([/]<1 2 3>).perl.say

[18:35] *** nbrown left
[18:35] <p6eval> pugs: *** reduce is nonsensical for /␤    at /tmp/Us9xavH8QO line 1, column 2-12␤

[18:35] <p6eval> ..rakudo 1d4928: 0.166666666666667␤

[18:35] <p6eval> ..elf 29582: Parse error in: /tmp/I2jceo5GQr␤panic at line 1 column 3 (pos 3): Error in quotesnabber␤WHERE: ([/]<1 2 3>).perl.say␤WHERE:   /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:1311:in `quotesnabber'␤  (eval):1:in `__quote_4321818'␤  STD_red/prelude.rb:406:in `block in

[18:35] <p6eval> ..longest…

[18:36] <cono> Why it have a difference?

[18:51] <k23z__> http://www.itu.dk/~kbilsted/ALB.jpg

[18:54] *** mikehh_ joined
[19:07] *** mikehh left
[19:16] *** jonasbn joined
[19:17] *** k23z__ left
[19:34] *** cls_bsd joined
[19:36] *** k23z__ joined
[19:41] *** payload joined
[19:47] *** k23z__ left
[20:02] *** |JackYF| joined
[20:05] *** jackyf left
[20:18] *** mssm left
[20:23] *** am0c joined
[20:26] *** am0c left
[20:26] <colomon> oh, hey.

[20:26] <colomon> ng: say 1/3;

[20:26] <p6eval> ng 9c9e28: Method 'clone' not found for invocant of class 'Perl6MultiSub'␤current instr.: 'perl6;Iterator[];_block8346' pc 278469 (src/gen/core.pir:32580)␤

[20:27] <colomon> ummm.... that's not the bug I was looking for.

[20:27] <colomon> that appears to be a fresh new bug?

[20:27] <colomon> oh, crap, did I do that this morning?

[20:28] *** lumi left
[20:29] *** lumi joined
[20:29] *** sundar joined
[20:32] <colomon> I'm kind of concerned that no one noticed this before now....

[20:35] <cono> colomon: what is ng ?

[20:35] <pmichaud> ng is the active development branch of rakudo

[20:35] <cono> rakudo: say 1/3;

[20:35] <TimToady> cono: a reduce operator is a list operator, and therefore requires a space before the first argument

[20:35] <p6eval> rakudo 1d4928: 0.333333333333333␤

[20:36] <TimToady> std: [/]<1,2,3>

[20:36] <p6eval> std 29582: ok 00:01 108m␤

[20:36] <TimToady> that's parsing as ([/])<1,2,3>

[20:37] <TimToady> not that , makes sense inside a <> subscript

[20:37] <TimToady> std: [/] 1,2,3  # this is better

[20:37] <p6eval> std 29582: ok 00:01 107m␤

[20:37] <TimToady> perl6: say [/] 1,2,3

[20:37] <p6eval> pugs: 0.1666666666666666666666666666666666666667␤

[20:37] <p6eval> ..elf 29582: Parse error in: /tmp/LFT7avJGII␤panic at line 1 column 6 (pos 6): Error in quotesnabber␤WHERE: say [/] 1,2,3␤WHERE:      /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:1311:in `quotesnabber'␤  (eval):1:in `__quote_4544362'␤  STD_red/prelude.rb:406:in `block in

[20:37] <p6eval> ..longest_toke…

[20:37] <p6eval> ..rakudo 1d4928: 0.166666666666667␤

[20:38] <cono> but why not a 1/6 ?

[20:38] <cono> I asked .perl.say

[20:38] <dalek> rakudo/ng: 9174831 | (Solomon Foster)++ | src/core/List.pm:

[20:38] <dalek> rakudo/ng: Revert "Start throwing iterator example code into List.pm.  Compiles but not tested or used for anything." because it appears to break ng badly.

[20:38] <dalek> rakudo/ng: This reverts commit 8aedd0c5eea27b37f7019c5117afc9897dc04e5a.

[20:38] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/9174831c0ff277b550789f05811512d3adb7375a

[20:38] <TimToady> because a Rat stringifies via Num

[20:38] <TimToady> perl6: say ([/] 1,2,3).perl

[20:38] <p6eval> pugs, rakudo 1d4928: 1/6␤

[20:38] <p6eval> ..elf 29582: Parse error in: /tmp/KsaaG0zhSM␤panic at line 1 column 7 (pos 7): Error in quotesnabber␤WHERE: say ([/] 1,2,3).perl␤WHERE:       /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:1311:in `quotesnabber'␤  (eval):1:in `__quote_6628927'␤  STD_red/prelude.rb:406:in `block in

[20:38] <p6eval> ..long…

[20:39] <TimToady> there's your 1/6

[20:39] <cono> rakudo: say ([/] <1 2 3>).perl

[20:39] <p6eval> rakudo 1d4928: 0.166666666666667␤

[20:39] <pmichaud> rakudo (the old version) isn't up-to-date on Rats

[20:39] <pmichaud> afk -- going to lunch and to think about iterators a while

[20:41] *** synth joined
[20:41] <cono> rakudo: ([/] <1 2 3>).WHAT.say

[20:41] <p6eval> rakudo 1d4928: Num()␤

[20:41] <cono> rakudo: ([/] 1,2,3).WHAT.say

[20:41] <p6eval> rakudo 1d4928: Rat()␤

[20:41] <cono> ah

[20:45] <TimToady> rakudo: for <1 2 3> { .WHAT.say }

[20:45] <p6eval> rakudo 1d4928: Str()␤Str()␤Str()␤

[20:46] <cono> Str ->  Num

[20:46] <cono> I think, I got it :D

[20:46] <TimToady> that's specced to return Int Int Int someday

[20:46] <cono> TimToady: ty :)

[20:52] <cono> Does rakudo have something like . in haskell ?

[20:56] <colomon> cono: sorry for disappearing there, phone call.  I see pmichaud answered your question.

[20:56] <colomon> what is . in haskell?

[20:56] <colomon> ng: say 1/3

[20:56] <p6eval> ng 917483: 0.333333333333333␤

[20:57] <cono> something like concatenating of functional types

[20:57] <colomon> ng: my $a = 0.333333333333333

[20:57] <p6eval> ng 917483:  ( no output )

[20:57] <cono> colomon: [ .Int . / ] <1 2 3> => must produce 1/6 Rat

[20:58] *** aesop joined
[20:59] <colomon> I don't believe perl 6 has a function composition operator (if that's what you mean)

[20:59] <cono> colomon: yeah, sorry, have a bad english :)

[20:59] <cono> you are right

[21:00] <colomon> rakudo: say ([/] (1, 2, 3)).perl

[21:00] <p6eval> rakudo 1d4928: 1/6␤

[21:00] <cono> rakudo: ([/]1,2,3).perl.say

[21:00] <p6eval> rakudo 1d4928: 1/6␤

[21:00] <cono> golf it :D

[21:00] <colomon> yeah, I'm still not completely comfortable leaving off the ( )s around my lists.  :)

[21:01] <cono> :)

[21:01] <colomon> anyway, as you can see, the example works fine in Rakudo (master) as long it's clear the type of the numbers is Int.

[21:01] <cono> yeah, %h = 1 => 2 ... different than p5

[21:01] <colomon> I don't think [ ] is implemented yet in Rakudo ng.

[21:02] <cono> problem was with <1 2 3>

[21:02] <cono> coz it have Str inside

[21:02] <aesop> whats %h = 1 => 2 in perl 6

[21:03] <cono> rakudo: my %h = 1 => 2; %h.perl.say

[21:03] <p6eval> rakudo 1d4928:  ( no output )

[21:03] <colomon> cono: right

[21:04] <cono> at local version i have: {"1" => 2}

[21:04] <cono> ng: my %h = 1 => 2; %h.perl.say

[21:04] <p6eval> ng 917483: Confused at line 1, near "my %h = 1 "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤

[21:04] <cono> std: my %h = 1 => 2; %h.perl.say

[21:04] <p6eval> std 29582: ok 00:01 109m␤

[21:05] <colomon> Hashes are currently on the ng to-do list.

[21:05] <cono> ic

[21:05] <cono> ng: say $*PERL

[21:05] <p6eval> ng 917483: ␤

[21:05] <cono> rakudo: say $*PERL

[21:05] <p6eval> rakudo 1d4928: Contextual $*PERL not found␤␤

[21:08] *** lumi left
[21:09] *** lumi joined
[21:09] *** Guest36383 left
[21:09] *** stepnem left
[21:09] *** Helios-- left
[21:09] *** jjore joined
[21:09] *** jjore left
[21:09] *** Chazz joined
[21:09] *** Helios-- joined
[21:10] *** Helios-- left
[21:10] *** Chazz is now known as Guest62648

[21:10] *** jjore joined
[21:10] *** Guest62648 left
[21:10] *** nadim_ joined
[21:10] *** jjore left
[21:11] *** Chazz_ joined
[21:11] <TimToady> std: ([/]1,2,3).perl.say

[21:11] <p6eval> std 29582: [31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/B5j5a7X8X8 line 1:␤------> [32m([/][33m⏏[31m1,2,3).perl.say[0m␤    expecting any of:␤  POST␤   bracketed infix␤    infix or meta-infix␤      postfix␤        postfix_prefix_meta_operator␤      

[21:11] <p6eval> ..prefix_circumfix_meta_operator__S_258reduce␤      prefix_postfi…

[21:11] *** jjore joined
[21:12] <frettled> Hm, what was that supposed to be?

[21:12] <TimToady> std: ([/] 1,2,3).perl.say

[21:12] <p6eval> std 29582: ok 00:01 107m␤

[21:13] <TimToady> STD requires the space there

[21:13] <cono> rakudo - not

[21:13] <cono> :)

[21:13] <TimToady> std: [/]

[21:13] <p6eval> std 29582: ok 00:01 105m␤

[21:13] <TimToady> rakudo: [/]

[21:13] <p6eval> rakudo 1d4928: Syntax error at line 2, near "[/]"␤in Main (file <unknown>, line <unknown>)␤

[21:14] <TimToady> STD is correct there too

[21:14] <TimToady> rakudo: say [/]()

[21:14] <p6eval> rakudo 1d4928: Use of uninitialized value␤␤

[21:14] <TimToady> rakudo: say [*]()

[21:14] <p6eval> rakudo 1d4928: 1␤

[21:14] <TimToady> rakudo: say [+]()

[21:14] <p6eval> rakudo 1d4928: 0␤

[21:15] *** am0c joined
[21:15] <frettled> *lights up* - aha

[21:15] *** pmurias_ joined
[21:15] <cono> why [*]() produce 1 ?

[21:15] <TimToady> [/] without a space or () is parsed as not having any args

[21:16] <TimToady> (in STD)

[21:16] <TimToady> std: print

[21:16] <p6eval> std 29582: Potential difficulties:␤  Unsupported use of bare 'print'; in Perl 6 please use .print if you want to print $_, or use an explicit argument at /tmp/CoRwdQef0X line 1:␤------> [32mprint[33m⏏[31m<EOL>[0m␤ok 00:01 105m␤

[21:16] <TimToady> std: print()

[21:16] <p6eval> std 29582: ok 00:01 105m␤

[21:17] *** payload1 joined
[21:17] <TimToady> could force reduction ops to follow a similar policy

[21:17] <cono> can i combine two operators in [] ?

[21:17] <TimToady> no

[21:18] <cono> three?

[21:18] <cono> joking? :)

[21:18] <frettled> You'd have to specify your own infix operator that combined them.  :)

[21:18] <frettled> infix?  why did I write infix?

[21:18] <TimToady> I presume cono wishes to alternate operators

[21:19] *** sundar left
[21:20] *** stepnem joined
[21:21] <cono> I just wanted to force Int type casting

[21:21] <cono> rakudo: ([/] <1 2 3>.map({ $_.Int })).perl.say

[21:21] <p6eval> rakudo 1d4928: 1/6␤

[21:22] <cono> or something like ([Int . /] <1 2 3>).perl.say :)

[21:31] *** pmurias left
[21:32] *** payload left
[21:38] <cono> rakudo: ([\/] map {.Int}, <1 2 3>).perl.say

[21:38] <p6eval> rakudo 1d4928: Syntax error at line 2, near "([\\/] map "␤in Main (file <unknown>, line <unknown>)␤

[21:38] <cono> std: ([\/] map {.Int}, <1 2 3>).perl.say

[21:38] <p6eval> std 29582: ok 00:01 109m␤

[21:40] <colomon> rakudo; <1 2 3>>>.Int.perl.say

[21:40] *** frederico left
[21:41] *** frederico joined
[21:41] <colomon> rakudo: <1 2 3>>>.Int.perl.say

[21:41] <p6eval> rakudo 1d4928: [1, 2, 3]␤

[21:41] *** jferrero joined
[21:42] <colomon> rakudo: say [/] <1 2 3>>>.Int

[21:42] <p6eval> rakudo 1d4928: 0.166666666666667␤

[21:42] *** snearch joined
[21:42] <colomon> or if you will

[21:42] <frettled> I think this is one case where the Unicode version is more readable: <1 2 3>».Int

[21:43] <colomon> rakudo: ([/] <1 2 3>».Int).perl.say

[21:43] <p6eval> rakudo 1d4928: 1/6␤

[21:43] <cono> std: <1 2 3>>>.Int.reduce(&infix:</>).perl.say

[21:43] <p6eval> std 29582: ok 00:01 128m␤

[21:43] <cono> rakudo: <1 2 3>>>.Int.reduce(&infix:</>).perl.say

[21:43] <p6eval> rakudo 1d4928: Unknown introspection value 'pos_required'␤in Main (file <unknown>, line <unknown>)␤

[21:44] <cono> ng: <1 2 3>>>.Int.reduce(&infix:</>).perl.say

[21:44] <p6eval> ng 917483: Symbol '&infix:</>' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)␤

[21:44] <aesop> owned

[21:45] <colomon> ng doesn't have reduce yet, either.

[21:45] <colomon> ng: say <1 2 3>.perl

[21:45] <p6eval> ng 917483: ("1", "2", "3")␤

[21:46] *** lumi left
[21:46] *** lumi joined
[21:47] *** snearch left
[21:48] <cono> moritz_: Your articles are great! Thanks :)

[21:48] *** snearch joined
[21:49] *** snearch left
[21:50] *** snearch_ joined
[21:52] *** cognominal left
[21:57] <pmichaud> back again, for a bit

[22:04] <frettled> And there was much rejoicing.

[22:04] <frettled> pmichaud: how's ng coming along?

[22:04] <pmichaud> well, we're having to rethink lists and iterators a fair bit

[22:07] <frettled> oh?

[22:20] <colomon> frettled: Today's spec changes are a side-effect.

[22:20] <frettled> aha

[22:21] <colomon> I think the easiest summery is that we (pmichaud mostly) realized that the idea of Lists as immutable Arrays didn't really sit well with the idea of Lists as things generated by Iterators.

[22:22] <colomon> It caused a bunch of overhead for common cases where you didn't actually care about anything but using what the Iterator was generating right away.

[22:23] <colomon> So now Lists are just iterators (more or less) and there's another type (Seq) to make a List look more like an Array if needed.

[22:24] <colomon> I think -- I admit I'm still fuzzy on some of the details.

[22:24] <pmichaud> there was already a Seq before, too -- but now it's different :)

[22:25] <frettled> The battle plan (spec) didn't survive contact with the enemy (implementation).  :D

[22:25] <pmichaud> that's happened a few times now :)

[22:25] <frettled> yep, and I think that's good

[22:27] <colomon> pmichaud: are you ready to try implementing the new spec?  it feels to me like it is time to implement and figure out what doesn't work about the current ideas in practice... but then, I'm not doing the core of the work.  :)

[22:27] <pmichaud> colomon: the new spec means we have to re-do all of Parcel as well.

[22:28] <pmichaud> it's not just a matter of writing "class Iterator ..."  and being done

[22:28] <colomon> ay ay ay!

[22:28] <pmichaud> or put another way -- the new "spec" is still incomplete

[22:28] <colomon> oh, I understand that, because there's still that magic thing .list returns that I don't understand very well.  :)

[22:28] <frettled> masak will be so pleased when he's back from his sabattical :D

[22:28] <pmichaud> well, I'm currently toying with the idea of ParcelIterator

[22:29] <frettled> Hrms, my browser doesn't want to be my friend right now, so I don't get to look at the spec changes.  *grumblesmurf*

[22:29] <pmichaud> which may in fact end up being "List"

[22:29] *** lumi left
[22:29] <frettled> at first glance, that may simplify things

[22:29] *** lumi joined
[22:34] *** Guest78210 left
[22:40] *** jonasbn left
[22:40] *** uniejo left
[22:44] *** snearch_ left
[23:00] *** cono left
[23:04] *** pnate left
[23:09] *** lumi left
[23:09] *** lumi joined
[23:12] *** orafu left
[23:12] *** orafu joined
[23:16] *** PacoLinux left
[23:18] *** clintongormley left
[23:18] *** patspam joined
[23:18] *** mssm joined
[23:23] *** mikehh_ left
[23:24] *** pnate joined
[23:31] *** orafu left
[23:31] *** orafu joined
[23:37] *** mssm left
[23:50] *** payload1 left
