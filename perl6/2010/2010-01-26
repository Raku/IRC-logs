[00:00] *** mj41_ joined
[00:15] *** dduncan joined
[00:17] *** mj41 left
[00:19] *** baest_ joined
[00:20] *** baest left
[00:23] *** dduncan left
[00:24] *** spinclad left
[00:24] *** renormalist left
[00:24] *** Tene left
[00:24] *** teneighty left
[00:24] *** nbrown left
[00:24] *** gabiruh left
[00:24] *** avar left
[00:24] *** frew left
[00:24] *** akl left
[00:24] *** p6eval left
[00:24] *** hatseflats left
[00:24] *** pnu left
[00:24] *** gabiruh_ joined
[00:24] *** avarab joined
[00:24] *** hatsefla1s joined
[00:24] *** Tene joined
[00:24] *** avarab is now known as avar

[00:28] *** nbrown joined
[00:29] *** meppel left
[00:32] *** frew joined
[00:39] *** mssm left
[00:41] *** lumi left
[00:50] *** patspam joined
[00:50] *** am0c joined
[00:50] *** Mantis joined
[00:52] *** xinming_ joined
[00:56] *** sundar left
[01:06] *** pmurias left
[01:06] *** niros left
[01:10] *** xinming left
[01:11] *** lestrrat is now known as lest_away

[01:13] *** xinming joined
[01:14] *** Chillance left
[01:15] *** rgrau left
[01:20] *** niros joined
[01:23] *** lest_away is now known as lestrrat

[01:31] *** xinming_ left
[01:33] *** LaVolta joined
[01:41] *** patspam left
[01:44] *** ShaneC1 left
[01:46] *** kcwu_ left
[01:48] *** partisan joined
[01:50] *** araujo left
[01:50] *** cdarroch left
[01:51] *** [particle] joined
[01:52] *** agentzh joined
[01:55] <pmichaud> TimToady: are you actively working on list/iterator issues (in background), or should I keep plugging away at it?

[01:56] *** cognominal joined
[01:59] *** [particle]1 left
[02:02] *** am0c left
[02:05] *** kcwu joined
[02:11] *** xinming_ joined
[02:11] *** xinming left
[02:16] *** lestrrat is now known as lest_away

[02:18] <colomon> pmichaud: have you been pressing on with the other issues for list/iterator?  It seems like the stuff we've been quibbling over is relatively minor...

[02:23] <pmichaud> colomon: it's major.

[02:23] <pmichaud> colomon: it significally affects the structure of parameter passing, list context, function call returns, array construction, list assignment, ...

[02:24] <colomon> I specifically meant the exact Iterator interface wrt .get versus .next / .value.

[02:24] <pmichaud> even that.

[02:24] <colomon> That seems like a small and easily changed detail compared to the rest of it.

[02:25] *** spinclad joined
[02:25] <pmichaud> except that the "rest of it" is intimately tied to the relationships between iterators and other classes

[02:25] <pmichaud> let me put it this way...

[02:26] <pmichaud> with this latest set of changes, I'm now on my _fifth_ implementation of arrays, lists, iterators, and the like, in eighteen months.

[02:26] <pmichaud> okay, more like 20 months now.

[02:27] <colomon> wooof

[02:27] <colomon> that's a lot of rewriting.

[02:27] <pmichaud> and not one of them has ever been a "minor detail".  The smallest change in structure always requires a significant refactor of everything, and often results in a design spec change.

[02:28] <spinclad> pmichaud: (backlogging)  my  .hasmore, .get  example should read  .next, .fetch  , with .next buffering for .fetch (as in your design earlier).  my using .get there confused the issue, .fetch was what i meant.

[02:29] <pmichaud> spinclad: +1

[02:29] <pmichaud> thanks

[02:30] <pmichaud> at this stage I'm likely to start playing with a variety of implementation approaches (to see if any work) -- my question to TimToady++ was just to see if he was actively pondering things and likely to spring another set of spec changes in the next day or so

[02:30] <pmichaud> if yes, I'd probably wait for them; if no, then I'll just barrel ahead with my best guess at things

[02:31] <pmichaud> it would also help to know if he (or anyone else) had any specific leanings after today's discussions on the topic

[02:31] <pmichaud> ruoso++ was favoring an exception-based model

[02:32] <pmichaud> iirc, Tene++ was favoring a next/get model, but having it be somewhat implicit in the .Bool and .get methods

[02:33] <pmichaud> I'm currently thinking of .get as fundamental, with .next/.value to be able to have a bit more control over things.  I haven't figured out how .get signals to the iterator itself "I'm done"  (doesn't have to be a sentinal, as the .get could set a flag directly in in the invocant iterator)

[02:33] <pmichaud> other votes would be very welcome

[02:35] *** TiMBuS joined
[02:35] <colomon> pmichaud: you're thinking that when it runs out, .get can return Nil or something like that and set the flag, and the flag is what you use to check and see if you are done?

[02:35] *** arnsholt_ is now known as arnsholt

[02:35] *** orafu left
[02:36] *** orafu joined
[02:36] <colomon> I suppose Mu might be better than Nil....

[02:38] <arnsholt> A sentinel value would preclude storing that value in the underlying list/collection

[02:38] <arnsholt> But it's also the most convenient in a lot of cases

[02:39] <arnsholt> Hard to make a decision

[02:40] <pmichaud> (on phone)

[02:40] *** stephenlb left
[02:41] <Tene> pmichaud: I'm not attached at all to implicit in .bool/.get, I just find a sentinal value rather distasteful, granting I might isunderstand how Nil is special.

[02:42] *** niros_ joined
[02:43] *** sjohnson sets mode: +o Tene

[02:47] *** sundar joined
[02:48] *** xinming joined
[02:48] *** LaVolta left
[02:48] *** lest_away is now known as lestrrat

[02:48] *** xinming_ left
[02:48] *** LaVolta joined
[02:52] <spinclad> for the sake of discussion i suggest calling the two-block/two-continuation interface  .get2:  $stream.get2( -> $_ { .useit }, { ... #`($stream is done) ... } )   # no sentinal, no buffering

[02:54] *** niros left
[02:54] <spinclad> you can look at the two blocks/continuations as a single multi continuation (where's the syntactic support for that?)

[02:57] <colomon> spinclad: are you proposing the blocks ought to be passed to the iterator?   :O 

[02:57] <spinclad> and at that as a variant (.getM, say, for the moment) that returns a Maybe Value (in haskell term) to a destructuring case switch:

[02:58] <spinclad> colomon: no, to the get2 method

[02:58] <colomon> spinclad: of the iterator, though, right?

[02:58] <spinclad> yes

[02:59] <spinclad> it's like continuation passing style

[03:01] *** drbean joined
[03:02] <colomon> It seems like something you'd do in Factor rather than in Perl.  (But, you know, Factor is way cool.)

[03:03] <colomon> I'm trying to code up toy examples, just to get a feel for what these things would be like.

[03:04] <colomon> Anyone have a notion whether you'd be allowed to call .value once .next returned false?

[03:04] <spinclad> (... case switch:) (warning, pidgeon haskell)  let $maybe = getM $stream in case $maybe of Maybe $value: use $value;   Nothing: # $stream is done

[03:04] <colomon> I'd be cool with that last one, I think, in a more perl 6ish version.

[03:06] <spinclad> in Haskell, aiui, the whole building and tearing down the Maybe gets compiled away.  when Perl 6 is farther along and can do that, well, much happiness...

[03:06] <spinclad> colomon: me too.

[03:07] <spinclad> at the moment, though, i don't see a way to compile away the Maybe layer, so at runtime it would carry a lot of overhead.

[03:07] <spinclad> something to work for on the longer term.

[03:08] <spinclad> colomon: once .next returns false, .value might fail.

[03:09] <colomon> if calling .value at that point is forbidden, it actually simplifies things quite a bit.  :)

[03:11] <spinclad> (but can you tell that failure from a value whose domain happens to be Failure?)

[03:13] <spinclad> (i keep thinking of  my $b = Nil #`(or whatever Sentinal is used); for ($a, $b, $c) { #`(does this ever see $c, or even $b?) }

[03:13] <spinclad> )

[03:14] <colomon> TimToady's theory is that $b just disappears if you do that.

[03:15] <spinclad> it should if it were @b, but not for $b: $b is a single value, not none, and not end-of-list.

[03:17] <spinclad> and wouldn't for see $b as end-of-list and quit prematurely, never getting to $c?  (like \0 in c strings: the same pathology.)

[03:18] *** pnate joined
[03:19] <pmichaud> colomon: I think that calling .value should be valid -- and it should return the "beyond the end of the iteration" value

[03:19] <pmichaud> (whatever that happens to be)

[03:19] <colomon> I think the idea would be that whatever generates the iterator from $a, $b, $c would do the absorbing of $b.

[03:19] <pmichaud> no,  my $b = Nil   causes $b to be Mu

[03:19] <pmichaud> because Nil in item context becomes Mu

[03:19] <pmichaud> it's not possible to store Nil in a variable

[03:21] <colomon> pmichaud: calling .value after the fact would make implementing .value more complicated.

[03:21] <pmichaud> why?

[03:21] <pmichaud> .next sets the value to be used the next time .value is called.

[03:22] <colomon> hold on, I'll post an example.

[03:23] *** hicx174_ joined
[03:23] <pmichaud> for reference:

[03:24] <pmichaud> my $b = Nil;   for (1, $b, 3) { say $_.WHAT; }   #  Int, Mu, Int

[03:24] <spinclad> pmichaud: how about my $b = \Nil?  is that already something besides the evanescent Nil itself?

[03:24] <TimToady> Parcel(Nil) is not the same as Nil

[03:24] <spinclad> ng: my $b = Nil; say $b.WHAT

[03:25] <spinclad> ENOP6BOT?

[03:25] <pmichaud> looks like ng currently gets it wrong anyway (not surprised)

[03:25] <colomon> I think my $.code calling is a bit wrong, but the point should come through: http://gist.github.com/286514

[03:26] <colomon> afk (rocking son)

[03:26] <TimToady> I think I'd be okay with changing Nil to mean something more like () xx *

[03:27] <TimToady> making it more suitable as an end marker

[03:27] <pmichaud> how would one check for Nil?  still the macro?

[03:27] <TimToady> it's primitive enough to warrant a macro, methinks

[03:27] *** pnate2 left
[03:27] <TimToady> it has to be magical somehow

[03:28] <TimToady> it's sort of the only object that isn't an object, as it were

[03:28] *** jaldhar joined
[03:28] <TimToady> an iterator that is guaranteed always to produce nothing

[03:29] *** araujo joined
[03:29] <pmichaud> colomon: the first .next/.value example you have isn't good -- we don't want to invoke $.code on each request for .value

[03:29] <pmichaud> we want to invoke it once, at the time the value is generated

[03:30] <pmichaud> colomon: but more to the point, I'm thinking the .next/.value semantics belong in the Iterator role (or something that does iterating), and not in each individual iterator type

[03:30] <pmichaud> i.e., MapIterator shouldn't have to implement a .next/.value because it's already supplied by the role.  MapIterator just needs a mechanism to "get the next value"

[03:30] *** dean-ero joined
[03:31] <pmichaud> (TimToady:  this discussion about .next/.value is highly speculative still -- waiting for some guidance from you :)

[03:31] <TimToady> what is .value?

[03:31] <pmichaud> perhaps the best explanation is to look at something like infix:<Z>

[03:31] <pmichaud> just a sec

[03:32] <pmichaud> http://gist.github.com/286214   # some examples I was playing with earlier

[03:33] <pmichaud> the problem with version #1 is that we can't always know that all of the iterators/lists can properly signal end-of-list before iterating

[03:34] <pmichaud> so, one possibility is to have an iterator do  ".next"   (iterate to the next value, return true if there is one, false if not)   and ".value"  (give back the value just iterated)

[03:34] *** cognominal left
[03:34] <TimToady> I'm opposed to eof-like solutions

[03:34] <Tene> pmichaud: In that model, how can you check if the iterator is done without advancing?

[03:35] <pmichaud> Tene: well, you can't.  But that's true in any model, I think.

[03:35] <spinclad> pmichaud: if you s/$.base-iterator/$.base-iterator.value/ in method value, i think it works.  if you call .value several times at the same place in map's iterator, it uses the same .value of the base-iterator... (modulo side-effects? arguably they *should* run again?)

[03:35] <pmichaud> Tene: wait, I phrased that wrong.

[03:36] <pmichaud> spinclad: they shouldn't.  The result of "map" should be the result of applying the code block *once* to each value (unless a REDO exception occurs)

[03:36] <spinclad> pmichaud: (re colomon's example)

[03:36] <pmichaud> spinclad: yes, I was working from colomon's example.

[03:36] <TimToady> me feeling is that pushback ought to cover all needs to peek ahead

[03:36] <spinclad> in which case map will call .value once at each position, and all's well

[03:37] <spinclad> maybe

[03:37] <pmichaud> spinclad: you're assuming that map is the only thing that would call/use MapIterator, I think?

[03:38] <spinclad> a moment while i reread...

[03:38] <pmichaud> TimToady: so, in the case of infix:<Z>, you're explicitly saying that we should use something like the third version?

[03:38] <pmichaud> i.e., where we go ahead and call .get and check for receiving Nil?

[03:38] <spinclad> pmichaud: yes i am

[03:38] <pmichaud> spinclad: I'm not sure that we can/should assume that any Iterator object has exactly one driver.

[03:39] <TimToady> the first versions will tend to be full of race conditions

[03:40] <TimToady> our iterators need to deal with backends that can't back up, and need pure gimme-what-you-got-right-now interfaces

[03:40] <pmichaud> TimToady: fair enough.  Those are reasons I can cope with.

[03:40] <TimToady> the only way to guarantee those kinds of backends work right is never to ask if they're ready, if there's a way to just try to read

[03:40] <TimToady> much like we almost always discourage people from using eof in p5

[03:40] <TimToady> just read the filehandle

[03:41] <spinclad> actually, i think, map doesn't call .next or .value, but just passes out a MapIterator, and the consumer .next/.value's it... so it's up to a third party.  but if the third party wants to dwell on a spot .valuing it, what should happen?  unspecced?

[03:41] <pmichaud> spinclad: I think that .next of the map iterator should apply the block to the value, and store it.

[03:42] <spinclad> yes, that's another model, and i think i agree, better.

[03:42] *** pnate left
[03:44] <pmichaud> TimToady: okay, I follow the reasons for wanting .get-returns-Nil a bit better now

[03:45] <pmichaud> (and I can agree with them)

[03:45] <pmichaud> I'll play with a few designs and see if I can better discover what we want Nil to really be

[03:45] <TimToady> and if Nil is magicaller than (), this also improves things from your view, I suspect

[03:45] <pmichaud> in some sense, Nil still wants to be a type :-)

[03:46] <pmichaud> that helps make it magicaller :-)

[03:46] <TimToady> well, it's really a junction: none(Mu)   :)

[03:47] <pmichaud> have you had a chance to read backscroll yet?

[03:48] <TimToady> just started

[03:48] <pmichaud> just in case there are some other ideas there that you might want to incorporate

[03:48] <pmichaud> I kind of like the notion of "interesting values of end-of-iteration"

[03:49] <pmichaud> it may be overkill/unnecessary, but in some ways it seems to fit

[03:49] <TimToady> interesting values of end of iteration are generally quite exceptional, I'd think

[03:50] <pmichaud> anyway, if you see anything there worth considering, let me know.  otherwise, I'm going to go with a get-returns-Nil based model and also suspend my preconceptions of what "Nil" is internally to see what can be made to fit its requirements

[03:50] <TimToady> so I'd just be inclined to throw 'em, and not try to pass 'em in-band, esp if that slows down the is-nil test

[03:51] <pmichaud> well, I'm thinking that in that case, the is-nil test could be a typecheck

[03:51] <pmichaud> i.e., we test for something that matches the "end of iteration" type

[03:51] <TimToady> I'd rather keep it a simple value if possible

[03:51] <pmichaud> fair enough.

[03:52] *** cognominal joined
[03:52] <pmichaud> so, what are the constraints on Nil?  It needs to be something that disappears in list context, and becomes Mu when used like an item.  Anything else?

[03:52] <TimToady> since we're going to be iterating iterators at many laziness levels, this has to be a blazing fast test

[03:52] <pmichaud> yes, and checking for Nil at the moment isn't a blazing fast test

[03:53] <pmichaud> unless it becomes its own type or something easily distinguishable from other things

[03:53] <TimToady> it doesn't have to disappear in a list if it can never appear in a list

[03:53] <TimToady> it merely has to terminate a sublist without terminating a superlist

[03:54] <pmichaud> that's an interesting concept

[03:54] <TimToady> it's not () anymore

[03:54] <pmichaud> well,  what would it be in   \(1, 2, Nil, 4)    ?

[03:54] <TimToady> that returns 1,2

[03:55] <TimToady> say 1, 2, (), 4 to mean the other thing

[03:55] <TimToady> if we separate those concepts

[03:55] <pmichaud> then    \(1, 2, foo(), 4)

[03:55] <pmichaud> and   sub foo() { return; }

[03:55] <TimToady> can return Parcel()

[03:55] <TimToady> that's not Nil

[03:55] <pmichaud> okay, so...

[03:56] <pmichaud> an empty Parcel is removed in list context, and becomes Mu in item context

[03:56] <pmichaud> but an empty Parcel isn't Nil

[03:56] <spinclad> so  sub foo() { return Nil; }

[03:56] <pmichaud> (which is a significant departure from what Nil has been previously)

[03:56] <TimToady> not much

[03:56] <TimToady> that returns Parcel(Nil), which is Parcel()

[03:57] *** xinming_ joined
[03:57] <pmichaud> I've always understood Nil to be the "undef in item context, empty list in list context" thingy, even before it was ()

[03:57] <spinclad> got it, just worked that out for /me

[03:57] <pmichaud> I'm fine if () is now that thingy

[03:57] <pmichaud> (I'm very fine with that, btw.)

[03:58] <pmichaud> (as in, I like that *much* better.)

[03:58] <colomon> sounds like we are getting somewhere, \o/

[04:00] <TimToady> for Christmas, I got Umberto Eco's book: the Infinity of Lists   :)

[04:00] *** sundar left
[04:01] <pmichaud> ....   if   

[04:01] <pmichaud>     sub foo() { return Nil; }

[04:01] <pmichaud> is the same thing as

[04:01] <pmichaud>     sub foo() { return (); }

[04:01] <pmichaud> ....then how do we have an iterator return Nil?  ;-)

[04:02] <TimToady> return from the gather?  :P

[04:02] <pmichaud> is that meant seriously or as in "I don't know..."

[04:02] <pmichaud> ?

[04:02] <TimToady> we could perhaps special-case return Nil for that purpose

[04:02] <pmichaud> okay.

[04:02] <pmichaud> "I don't know..."

[04:03] <pmichaud> (wasn't sure how to interpret the :P )

[04:03] <TimToady> though returning from gather does have that effect

[04:03] <pmichaud> right

[04:03] <TimToady> the joke was to force everything to use gather/take

[04:03] <pmichaud> right

[04:03] <pmichaud> which has its own set of performance issues :)

[04:03] <TimToady> including, presumably the implementation of gather :)

[04:04] <pmichaud> and we *still* haven't resolved exactly how we want to deal with    gather { my $a = 0;  for 1..5 { take $a; $a++; } }

[04:04] <TimToady> a function with a declared return type doesn't have to return a Parcel

[04:05] <TimToady> that might or might not mean anything

[04:06] <TimToady> being hauled off, bbl &

[04:06] <pmichaud> okay

[04:06] <pmichaud> thanks for the ideas... I'll play with it a bit more

[04:06] *** justatheory left
[04:13] <pmichaud> TimToady:  (opinion sought) --- my reading of the current spec prose is that there are a lot of places where "Nil" is really being used to mean "empty Parcel".  So much so that it makes sense to have a name for the empty Parcel, such as "Nil" (more)

[04:14] <pmichaud> So, if that's the case, and if the empty Parcel/Nil doesn't work out well as an iterator sentinel, perhaps we should go ahead and designate some other value or special thing as the end-of-iterator sentinel?

[04:15] *** xinming left
[04:15] <pmichaud> (just a thought... maybe playing with implementation a bit more will yield some more clues.)

[04:17] <spinclad> fwiw, here's a variation on infix:<Z> using a small variation on the .get2 interface: http://gist.github.com/286535

[04:17] <spinclad> (version 4 therein)

[04:18] *** lypanov1 joined
[04:20] *** jaldhar left
[04:23] *** xinming joined
[04:23] <spinclad> i'm unsure as yet how well .get2 composes or scales syntactically or semantically; i'm happy with it so far and want to pursue it further.

[04:24] <spinclad> let me know if you look at it and see problems.

[04:26] *** lypanov left
[04:29] * spinclad pursues clothes-washing &

[04:29] <cognominal> pmichaud, I thought of a sngleton value that cannot be used for anything but comparing with itself.

[04:30] *** xinming_ left
[04:32] <cognominal> ... well it be usable for assignment too.

[04:34] * cognominal returns to his bed to try to get some sleep

[04:55] *** drbean left
[04:58] *** dean-ero left
[05:07] *** xinming_ joined
[05:12] *** frew is now known as frioux

[05:13] *** mssm joined
[05:24] *** xinming left
[05:30] *** xomas left
[05:30] *** am0c joined
[05:30] *** am0c left
[05:35] *** christine joined
[05:38] *** xinming joined
[05:44] *** xinming_ left
[05:47] *** kcwu_ joined
[05:49] *** eternaleye left
[05:53] *** pnate2 joined
[06:00] *** eternaleye joined
[06:01] *** kcwu left
[06:10] *** sundar joined
[06:19] *** pnate2 left
[06:34] *** cognominal left
[06:49] *** cognominal joined
[06:51] *** simcop2387 left
[06:53] *** niros joined
[06:56] *** k23z__ joined
[07:04] *** niros_ left
[07:04] *** jonasbn joined
[07:07] *** am0c joined
[07:07] *** am0c left
[07:10] *** simcop2387 joined
[07:11] *** kaare joined
[07:11] *** kaare is now known as Guest4236

[07:32] *** Su-Shee joined
[07:33] <Su-Shee> good morning

[07:52] *** Baggiokwok joined
[08:02] *** iblechbot joined
[08:10] *** Guest4236 left
[08:11] *** Guest4236 joined
[08:11] *** [particle]1 joined
[08:16] *** pnate joined
[08:22] *** ejs joined
[08:25] *** renormalist joined
[08:28] *** cognominal left
[08:28] *** cognominal joined
[08:28] *** [particle] left
[08:30] *** rgrau joined
[08:33] *** drbean joined
[08:34] *** niros left
[08:35] *** ejs1 joined
[08:36] *** cj_ joined
[08:38] *** cj left
[08:41] *** am0c joined
[08:43] *** LaVolta left
[08:44] *** ejs left
[08:52] *** cognominal left
[08:52] *** cognominal joined
[09:09] *** dakkar joined
[09:19] *** drbean_ joined
[09:19] *** tkr left
[09:24] *** Baggiokwok left
[09:26] *** drbean left
[09:38] *** c9s left
[09:38] *** c9s joined
[09:39] *** payload left
[09:48] *** lumi joined
[09:51] <moritz_> good morning

[09:51] *** rgrau left
[09:52] *** rgrau joined
[09:57] * moritz_ just added a link to http://fedoraproject.org/wiki/Features/Rakudo_Perl_6 to the how-to-get-rakudo site

[09:57] <moritz_> gerd++

[09:59] *** meppl joined
[10:00] *** payload joined
[10:06] *** drbean_ left
[10:10] *** Mantis left
[10:10] *** bryan_ joined
[10:13] <jnthn> morning

[10:14] <moritz_> good morning

[10:19] *** lumi left
[10:19] *** lumi joined
[10:19] *** payload left
[10:20] *** cognominal left
[10:22] *** payload joined
[10:26] *** lestrrat is now known as lest_away

[10:26] *** lypanov1 left
[10:30] * mberends goes very offline, to work() on asp.net training

[10:30] *** mberends left
[10:30] <moritz_> have fun

[10:36] *** xinming_ joined
[10:48] *** agentzh left
[10:50] *** payload left
[10:51] *** lest_away is now known as lestrrat

[10:51] *** payload joined
[10:53] *** mikehh left
[10:53] *** lumi left
[10:54] *** lumi joined
[10:54] *** xinming left
[10:54] *** mikehh joined
[11:09] *** renormalist left
[11:31] *** xomas_ joined
[11:33] *** xomas_ is now known as xomas

[11:35] *** lichtkind joined
[11:38] *** drbean joined
[11:39] *** lumi left
[11:40] *** lumi joined
[11:40] *** Baggiokwok joined
[11:45] *** cognominal joined
[11:46] *** payload left
[11:47] *** rjh joined
[11:50] *** cls_bsd left
[11:53] *** Baggiokwok left
[12:08] *** LaVolta joined
[12:09] *** Baggiokwok joined
[12:11] *** mikehh_ joined
[12:11] *** mikehh left
[12:12] *** bryan_ left
[12:12] *** lumi left
[12:12] *** cls_bsd joined
[12:13] <colomon> morning!

[12:14] <moritz_> \o/

[12:14] *** lumi joined
[12:14] *** payload joined
[12:15] *** slavik joined
[12:16] <lichtkind> :)

[12:16] *** bluescreen joined
[12:20] *** am0c left
[12:42] *** rjh left
[12:43] *** rjh joined
[12:47] <cognominal> happy birthday jnthn 

[12:48] <jnthn> cognominal: Thanks! :-)

[12:48] *** lumi left
[12:48] *** lumi joined
[12:48] <moritz_> jnthn++

[12:48] <moritz_> erm

[12:48] <moritz_> jnthn.age++

[12:49] <moritz_> or so :-)

[12:49] *** SmokeMachine joined
[12:49] <frettled> ooh.

[12:50] <frettled> jnthn: congrats, may there be hundreds of more years in good health!

[12:50] <frettled> and since you're so young, you have a good chance for medical science to make you live for hundreds of years, too ;)

[12:51] <jnthn> hundreds? sheesh, I might even get to see Perl 8!

[12:51] <frettled> now now, let's not exaggerate ;)

[12:52] <jnthn> OK. Maybe 6.6.6. :-)

[12:52] <frettled> :)

[12:52] <frettled> I was going to suggest Perl 7, but...

[12:52] <colomon> happy birthday!

[12:53] *** mikehh_ left
[12:54] *** jaldhar joined
[12:54] *** mikehh_ joined
[13:02] *** ignacio_ joined
[13:05] *** lumi left
[13:07] <pmichaud> good morning #perl6

[13:08] *** lumi joined
[13:08] <pmichaud> "Hundreds?  Oh, so there's a small chance you'll see Perl 6 in your lifetime."  :-)

[13:09] *** takadonet joined
[13:09] <takadonet> morning all

[13:11] *** mikehh_ left
[13:11] *** mikehh_ joined
[13:18] <sjn> o7

[13:19] <sjn> pmichaud: do you know of any short and high-signal "sales texts" for perl6/rakudo?

[13:19] <sjn> short, as in < 100 words

[13:19] <pmichaud> sjn:  not off the top of my head.  might look at perl6.org and see if there's anything there

[13:20] <sjn> not really

[13:20] <sjn> a couple of us that are going to FOSDEM (Brussels, Feb 4-6) 

[13:21] <sjn> ...are going to set up a Perl stand there

[13:21] <frettled> sjn++ :)

[13:21] <sjn> basically see if we can't make Perl projects a little more visible

[13:21] <sjn> so we're trying to write some texts for flyers/postcards and such

[13:22] <sjn> TPF is putting some money into this too, luckily

[13:24] <sjn> any pointers would be helpful :)

[13:25] <sjn> this is what we have now: http://123.writeboard.com/470b8ce9d41307670 (pw is "")

[13:25] <sjn> still work-in-progres

[13:25] <sjn> +s

[13:26] <sjn> as you can see, Perl6/Rakudo needs more representation

[13:35] <pmichaud> afk # kids to school

[13:40] *** sundar left
[13:40] *** lumi left
[13:41] *** lumi joined
[13:41] *** payload left
[13:43] <jnthn> afk # slovak

[13:43] *** payload joined
[13:49] <slavik> ?

[13:51] *** payload left
[13:51] *** payload joined
[13:53] *** go|dfish left
[14:05] *** [particle]1 is now known as [particle]

[14:10] *** LaVolta left
[14:10] *** araujo left
[14:11] *** tkr joined
[14:15] *** ignacio_ left
[14:22] *** TiMBuS left
[14:24] *** ignacio_ joined
[14:25] *** am0c joined
[14:32] *** ignacio_ left
[14:38] *** lumi left
[14:38] *** lumi joined
[14:40] *** payload1 joined
[14:42] *** mj41 joined
[14:47] *** ignacio_ joined
[14:47] *** payload left
[14:47] *** partisan left
[14:52] <pugs_svn> r29586 | pmichaud++ | [pm.txt]:  Added Pm-19 for TimToady++ or others to answer. 

[14:52] <pugs_svn> r29586 | 

[14:52] <pugs_svn> r29586 | Pm-19:  In each statement below, how many times is the block argument

[14:52] <pugs_svn> r29586 |     to .map() executed?

[14:52] <pugs_svn> r29586 |  

[14:52] <pugs_svn> r29586 |         my @b  = (1,2,3 Z 4,5,6).map({ ... });

[14:52] <pugs_svn> r29586 |         my @@c = (1,2,3 Z 4,5,6).map({ ... });

[14:52] *** Guest4236 left
[14:52] <pugs_svn> r29586 |         my ($x, $y, @@z) = (1,2,3 Z 4,5,6).map({ ... });

[14:53] <colomon> pmichaud: doesn't that depend on the arity (er, count?) of the block?

[14:53] <pmichaud> assume the block has arity 1

[14:53] <moritz_> I guess a default of 1 is assumed

[14:54] <pugs_svn> r29587 | pmichaud++ | [pm.txt]:  Add arity/count assumption to Pm-19 (colomon++) 

[14:54] * colomon sincerely hopes the answer is the same in all three cases....

[14:54] <pmichaud> colomon: and what answer would that be?  ;-)

[14:55] <colomon> pmichaud: my instinct is 6, but I'd be cool with 3 in a pinch.

[14:55] <colomon> I just don't want what's on the left side of the = influencing the answer.

[14:56] <pmichaud> oh, that sort of thing happens already, though.  

[14:56] <colomon> I feel strongly that that way lies madness....

[14:56] <moritz_> that's what context is

[14:58] *** mj41_ left
[15:01] *** cotto_w0rk joined
[15:01] *** fda314925 joined
[15:01] <colomon> But those examples are simple.  What if it is something like my @@c = (1, 2, 3 Z 4, 5, 6).map({...}).grep({...}).sort.uniq  ?  tracing back through three functions to figure out how map is supposed to work in the @@c context.....

[15:02] *** kcwu_ left
[15:02] <pmichaud> colomon: the examples aren't actually that simple.  but knowing the answers to those examples would likely tell me the answers to the others.

[15:07] *** drbean left
[15:08] *** hicx174_ left
[15:09] *** kcwu joined
[15:09] <colomon> s/those examples are simple/those examples could be much, much crazier/

[15:10] <pmichaud> anyway, I think the short(est) answer to your question would be that .map wouldn't need to know about @@c directly -- it would use the context supplied to it by .grep (which uses the context supplied to it by .sort, which uses the context supplied to it by .uniq, which uses the context supplied to it by the assignment).

[15:11] <pmichaud> however, I agree that this might be somewhat problematic -- it starts to look like the want() issue again.... which is one of the reasons I'm explicitly posing the question in pm.txt :)

[15:11] <colomon> seems like that would require allowing multi methods to overload on context?

[15:12] <pmichaud> no, not necessarily.  the various iterators and flatteners would just need to know what context(s) to use

[15:12] *** payload1 left
[15:14] <colomon> Hmmm, just to make sure I'm tracking properly -- the idea here is that @@c might want a list of lists rather than a flattened list, right?

[15:14] <moritz_> right

[15:14] <PerlJam> good day #perl6

[15:14] <colomon> but doesn't it become an issue then what map's block actually does?  maybe it maps single numbers to lists....

[15:15] <pmichaud> ...that's one reason why these "simple" examples aren't so simple.  :)

[15:15] <pmichaud> and no, I hadn't thought of that case, which itself is a compounding issue :-)

[15:16] <pmichaud> colomon++

[15:17] <PerlJam> colomon: why would the answer to Pm-19 be 6?

[15:17] <pmichaud> PerlJam: .map could impose list context on its invocant.

[15:18] <PerlJam> seems backwards to my intuition.

[15:19] *** ejs1 left
[15:19] <pmichaud> PerlJam: suppose I said instead:     my @b = (foo14(), foo25(), foo36()).map( { ... } );

[15:19] <colomon> PerlJam: because conceptually (in my head, anyway), a map over a block with an arity of 1 wants to be fed a list of scalars.

[15:19] <pmichaud> where each of foo??  returns a 2-element list

[15:19] <pmichaud> in that case, would you expect the lists to flatten, or no?

[15:20] <PerlJam> I dunno.  Perl 6 has my intuition from Perl 5 all cock-eyed  :)

[15:20] <pmichaud> and there's also the case of

[15:20] <colomon> that is how it works in master, isn't it?

[15:21] <pmichaud>     my @b = (@foo[1,4], @foo[2,5], @foo[3,6]).map({ ... });

[15:21] <colomon> rakudo: (1, 2, 3 Z 4, 5, 6).map({ .say; $_ * 2; }).perl.say

[15:21] <pmichaud> colomon: master is definitely not authoritative here -- it doesn't know anything about slices

[15:22] <colomon> pmichaud: sure, just trying to justify where I might have gotten my intuitions on the subject.  :)

[15:22] <PerlJam> If we say that lists are always flattening, where's the difficulty with that?

[15:22] <pmichaud> well, the reason I asked (and the reason for most of my questions in pm.txt) is because I can argue it several ways, so I need someone (TimToady++) to say which way is the "right" one

[15:22] <colomon> (is dalek down?  anyway, testing locally shows map's block gets called six times.)

[15:23] <pmichaud> PerlJam: then how does one iterate over slices?

[15:23] <pmichaud> ng: say 'hello';   # I think p6eval is down

[15:23] <PerlJam> pmichaud: is a slice a list?

[15:23] <pmichaud> PerlJam: it's a list of lists

[15:24] <pmichaud> or one might say it's a list of captures

[15:24] *** p6eval joined
[15:24] <moritz_> pugs: say 1

[15:24] <p6eval> pugs: 1␤

[15:24] <moritz_> rakudo: say 'foo'

[15:24] <p6eval> rakudo 1d4928: foo␤

[15:24] <diakopter> moritz_: thanks for recovering that

[15:24] <moritz_> diakopter: I just killed the process :-)

[15:25] <diakopter> oh

[15:25] <PerlJam> pmichaud: what exactly do you mean by "iterate over slices"?  (I can read that 2 ways)

[15:25] <colomon> rakudo: (1, 2, 3 Z 4, 5, 6).map({ .say; $_ * 2; }).perl.say

[15:25] <p6eval> rakudo 1d4928: 1␤4␤2␤5␤3␤6␤[2, 8, 4, 10, 6, 12]␤

[15:25] <pmichaud> PerlJam: process a slice one capture at a time, instead of flattening the lists

[15:25] *** araujo joined
[15:25] <pmichaud> colomon: note that the example you give is in list context anyway :-)

[15:26] <colomon> :)

[15:26] <colomon> How does that work, actually?  Can you restate it in some other context?

[15:27] <pmichaud> ...how does what work?

[15:27] <PerlJam> pmichaud: What's the relationship between captures and lists?  Because captures are fairly atomic now (non-flattening) unless we pass them through a |-prefix right?

[15:27] <PerlJam> (or maybe I have that backwards)

[15:27] <colomon> pmichaud: how does my example get list context?  

[15:28] *** araujo left
[15:29] <colomon> If I try to reason backwards, .perl mucks things up, because it takes *something* and returns a Str.

[15:29] *** cotto_work left
[15:29] <pmichaud> colomon: oh, that's a good question.  The .say is in void ("sink") context

[15:29] *** araujo joined
[15:30] <pmichaud> the .perl will impose item context on its invocant

[15:30] *** araujo left
[15:31] <pmichaud> short answer -- I'm not at all sure what happens here, because contexts and slices are a bit fuzzy here (thus my question :-)

[15:31] <pmichaud> PerlJam: Captures are non-flattening, correct.

[15:31] <pmichaud> (unless explicitly flattened with |)

[15:32] <PerlJam> so a list of captures is as flat as it's going to get without some prodding by the programmer, so this would be "simple iteration"  :)

[15:32] *** araujo joined
[15:32] <pmichaud> oops, I mis-stated

[15:32] <pmichaud> Captures are non-flattening in slice context, they're flattening in list context

[15:33] <PerlJam> Way off topic, but does anyone happen to know the website that has tech docs or podcasts or something for $9?  I forget it's name.

[15:34] *** ejs joined
[15:36] <PerlJam> Hmm.  so the difference between "slice context" and "list context" is just that the latter flattens and the former does not?

[15:36] <pmichaud> PerlJam: yes, I think so.

[15:37] *** uniejo joined
[15:37] *** araujo left
[15:38] *** araujo joined
[15:38] <jnthn> pmichaud: Is the latest still that "to enforce a context call a method" holds? e.g. to put in list context, call .list?

[15:38] * jnthn is trying to keep up and failing

[15:38] <jnthn> Would that imply a .slice?

[15:38] <pmichaud> jnthn: no

[15:38] <jnthn> And Parcel would know what to do?

[15:38] <jnthn> OK

[15:38] <pmichaud> .list does not mean "put in list context"

[15:38] <pmichaud> it means "return yourself as a list"

[15:39] <pmichaud> here's the difference

[15:39] <pmichaud> my $a = [1,2,3];

[15:39] <pmichaud> my @b = [1,2,3];

[15:39] <pmichaud> oops

[15:39] <pmichaud> drat

[15:39] <pmichaud> my $a = [1,2,3];

[15:39] <pmichaud> my @b = 1,2,3;

[15:39] <pmichaud> both $a and @b are Array with 3 elements

[15:39] <pmichaud> $a in list context does not flatten, while @b in list context does flatten

[15:39] <jnthn> Right.

[15:39] <jnthn> OK

[15:40] <pmichaud> however, $a.list has three elements

[15:40] <jnthn> So what does "put something in list context" actually mean at this point, or is that still an unknown?

[15:40] <pmichaud> list(...)

[15:40] <PerlJam> jnthn: to put an expression in a particular context, you'd use a contextualizer:   item foo(), hash foo(), list foo(), slice foo()

[15:40] <pmichaud> say list($a).elems    # 1

[15:40] <pmichaud> say $a.list.elems   # 3

[15:41] <jnthn> OK, and list(@b) would flatten?

[15:41] <pmichaud> yes.

[15:41] <jnthn> Right.

[15:41] <pmichaud> say list(@b).elems # 3

[15:41] <jnthn> my @a = 1, (2, 3), 4;

[15:42] <jnthn> my @b = slice 1, (2, 3), 4;

[15:42] <jnthn> say @a.elems; # 4 ?

[15:42] <pmichaud> yes

[15:42] <jnthn> say @b.elems # ??

[15:42] <pmichaud> @b.elems would also be 4, I think :)

[15:42] <jnthn> Because the my @b = ... is a list assignment and implicitly forces list context ont he RHS?

[15:43] <jnthn> *on the

[15:43] <pmichaud> because a capture in list context flattens

[15:43] <jnthn> Thus the "slice" is useless in what I wrote, essentially?

[15:43] *** iblechbot left
[15:43] <pmichaud> yeah, to store a slice one would need @@b

[15:43] <pmichaud> my @@b = slice 1, (2,3), 4;   say @@b.elems  # 3

[15:44] <jnthn> my @@b = 1, (2,3), 4; # 3 or 4?

[15:44] <pmichaud> 3

[15:44] <jnthn> :-/

[15:44] *** bbkr joined
[15:44] <jnthn> oh, sorry

[15:44] <jnthn> That was the answer I wanted :-)

[15:44] <pmichaud> @@b =   is slice assignment, not list assignment

[15:44] <jnthn> Right.

[15:44] <jnthn> I braino-d.

[15:44] <pmichaud> ($a, @@b) = ....    would be list assignment :-)

[15:44] <jnthn> my @b; my @@b; # ok or error?

[15:44] <pmichaud> error

[15:44] <pmichaud> no

[15:44] <jnthn> OK.

[15:45] <pmichaud> not error

[15:45] <jnthn> ?

[15:45] <pmichaud> two different vars

[15:45] <pmichaud> my $b;  my @b;  my @@b;  my %b;

[15:45] <jnthn> OK, so @@ is a sigil?

[15:45] *** uniejo left
[15:45] <pmichaud> yes, @@ is a sigil

[15:45] <jnthn> @@b is not just an alternative view of @b?

[15:45] <jnthn> OK.

[15:45] <pmichaud> token sigil:sym<@@> { <sym> }

[15:45] <pmichaud> (from STD.pm)

[15:45] <jnthn> OK, I hadn't appreciated that part.

[15:46] <jnthn> I'd somehow thought @@ was just another view of...

[15:46] <jnthn> OK, so we have item, list, slice and hash contexts?

[15:46] *** Psyche^ joined
[15:46] <pmichaud> and sink

[15:46] <jnthn> Ah, ok.

[15:46] * PerlJam still thinks "void" when he sees "sink"

[15:47] <jnthn> "I just poured my cold coffee into the void!" does sound SO cooler. :-)

[15:48] <jnthn> pmichaud: OK, I think I follow the slice thing a bit more now. :-)

[15:48] <pmichaud> "loose lips void ships"   # hmmmmmm

[15:48] <jnthn> lol!

[15:49] <pmichaud> "Perl has everything, including the kitchen void"

[15:49] <PerlJam> And don't even ask about "everything and the ...  damn you pm! :-)

[15:50] <jnthn> pmichaud: Dare I ask about the iterator stuff? Or should I find time to backlog later? :-)

[15:50] *** cognominal left
[15:50] <PerlJam> So ... if I'm reading S03 correctly, then @@b = 1, (2,3), 4;  makes @@b look like [1],[2,3],[4]  right?

[15:50] <jnthn> (Gotta head out in a little bit...)

[15:50] <pmichaud> PerlJam: more like  \1, \(2,3), \4

[15:51] <pmichaud> jnthn: I'm still working away on it, but had to add a new Pm-19 to pm.txt

[15:51] <pmichaud> short answer is that TimToady++ has some good reasons for wanting a sentinel-based approach to end-of-iterator

[15:51] <jnthn> OK.

[15:51] <pmichaud> so, I'm heading in that direction.

[15:51] <PerlJam> Well, I was reading about @@() and I assume it applies to "slice assignment" the same:  say @@(<a b> X <1 2>)  # ['a', '1'], ['a', '2'], ['b', '1'], ['b', '2']

[15:52] <PerlJam> S03:4726

[15:52] <pmichaud> PerlJam: yeah, I'm not sure what to think there.

[15:52] <pmichaud> Because if a slice is a list of captures, but captures flatten in list context, then....

[15:52] <jnthn> OK, and the exact nature of the sentinel is still being determined?

[15:53] <jnthn> pmichaud: Maybe a slice is a parcel of captures?

[15:53] <pmichaud> jnthn: correct.   And it's possible that "Nil" will not be "()", or that the sentinel will not be Nil.

[15:53] <PerlJam> pm: where does it say a slice is a list of captures?

[15:54] <jnthn> pmichaud: OK, thanks for the updates. That saves me epic backlogging. :-)

[15:54] <pmichaud> okay, that's not precisely correct

[15:54] <TimToady> more like a list of parcels, I think

[15:54] <pmichaud> PerlJam: a slice become a list of non-flattening lists

[15:54] <pmichaud> that would be a better way to say it

[15:55] * TimToady sincerely hopes his day is less crazy than yesterday

[15:55] <pmichaud> basically, slice turns off the flattening nature of any of the nested lists

[15:55] *** Baggiokwok left
[15:55] <pmichaud> so that in list context, they no longer flatten

[15:56] *** araujo left
[15:57] <PerlJam> This becomes a flat list in C<@> context and a list of arrays in C<@@> context"   @@ context is the same as slice context, yes?

[15:57] <pmichaud> yes.

[15:57] *** cognominal joined
[15:57] <cottoo> jnthn, happy birthday!

[15:57] *** araujo joined
[15:57] <TimToady> if we consider take to be fairly fundamental, it means whether take 1,2,3 keeps 1,2,3 together as [1,2,3] or flattens into 1,2,3

[15:57] <jnthn> cottoo: Thanks! :-)

[15:58] *** Patterner left
[15:58] *** Psyche^ is now known as Patterner

[15:58] <TimToady> looking at it from the user end, it's in there mostly for multidimensional subscripting: @a[1,2,3; 4,5,6]

[15:58] <pmichaud> TimToady:  fossil at S03:2740?

[15:58] <pmichaud>     $a = list 1, 2, 3;          # force grouping using listop precedence

[15:58] <pmichaud>     $a = @ 1, 2, 3;             # same thing

[15:58] *** kaare_ joined
[15:58] <pmichaud> (does the @ require a paren?)

[15:59] <TimToady> yes

[15:59] <TimToady> std: $a = @ 1, 2, 3;

[15:59] <p6eval> std 29587: [31m===[0mSORRY![31m===[0m␤Anonymous variable requires declarator at /tmp/FpFZALNOqz line 1:␤------> [32m$a = @[33m⏏[31m 1, 2, 3;[0m␤    expecting twigil␤Other potential difficulties:␤  Variable $a is not predeclared at /tmp/FpFZALNOqz line 1:␤------> [32m$a[33m⏏[31m = @ 1, 2,

[15:59] <p6eval> ..…

[15:59] <pmichaud> same at S03:2750

[16:00] <pmichaud> anyway, correct -- slice context basically affects the flattening of list elements in the slice

[16:01] <pmichaud> so, to go back and restate things from earlier

[16:01] <TimToady> it's anti-flattening, in the sense that the conjectural groupings are no longer conjectureal

[16:01] <pmichaud> my @b = slice 1, (2,3), 4;   #  @b.elems == 3

[16:03] * PerlJam needs a Capture, Parcel, Slice, List, Array redux

[16:03] <pugs_svn> r29588 | lwall++ | [S03] fossil dug up by pmichaud++ 

[16:04] <pmichaud> PerlJam: we're still working those out a bit.  I'm fairly confident of Array and Parcel.  :-0

[16:06] <TimToady> you can mostly forget about Capture, which is just a Parcel sorted out into positional vs named args

[16:07] <TimToady> (unless, of course, you're implementing it :)

[16:08] <pmichaud> and a slice is basically a List with non-flattening elements

[16:08] <colomon> TimToady: on that latest patch: @a[$ foo()] = $(bar());    should there also be parens around foo()  ?

[16:08] <TimToady> of course

[16:09] <TimToady> blood hasn't hit the coffee stream yet

[16:09] *** brrant joined
[16:09] * colomon is now imagining TimToady as a coffee-adicted vampire....

[16:09] <pugs_svn> r29589 | lwall++ | [S03] braino on previous patch 

[16:11] <moritz_> is anybody opposed to deleting docs/Perl6/FAQ/Capture.pod in the pugs repo?

[16:11] <moritz_> it seems very out of date

[16:11] <pmichaud> void it

[16:11] <pmichaud> sink it

[16:11] <moritz_> sunk :-)

[16:11] <pugs_svn> r29590 | moritz++ | delete very outdated Capture FAQ 

[16:11] <pmichaud> moritz_++

[16:13] <moritz_> http://cdn.shopify.com/s/files/1/0016/9762/files/angelpod1920.png (very off-topic, but somehow I still had to think about Perl 6)

[16:14] *** lumi left
[16:15] *** lumi joined
[16:18] *** nihiliad joined
[16:19] <TimToady> hmm, no hugme to give a creepy hug to moritz++

[16:19] *** hugme joined
[16:19] <moritz_> seems to have been lost in a netsplit

[16:19] *** moritz_ sets mode: +vv p6eval hugme

[16:21] <TimToady> hugme: hug moritz++ creepily

[16:21] * hugme hugs moritz++ creepily

[16:21] <jnthn> hugme: hug me adverbially

[16:21] * hugme hugs jnthn

[16:21] <jnthn> aww!

[16:21] <TimToady> you didn't smile right

[16:23] <TimToady> hugme: hug jnthn adverbially

[16:23] * hugme hugs jnthn adverbially

[16:24] <jnthn> \o/

[16:24] <jnthn> hugme: That was a SO adjective hug!

[16:25] <jnthn> Time to go and celebrate getting a year old...back later/tomorrow. :-)

[16:25] <TimToady> have the appropriate amount of fun

[16:26] <colomon> and an inappropriate amount of beer.

[16:26] * TimToady thinks about chow fun

[16:27] <colomon> is that what -Ofun is all about?

[16:27] * TimToady beats colomon with a wet noodle

[16:28] <colomon> Is it a saucy noodle?  I'm getting kind of hungry...

[16:28] *** rgrau left
[16:32] <jnthn> augment grammar P6 { token routine_declarator:chow { <sym> <routine_def> } }; chow Main() { }

[16:32] <jnthn> <- really gone now :-)

[16:33] *** payload joined
[16:33] *** payload1 joined
[16:33] *** payload left
[16:37] <diakopter> mmm chow mein

[16:51] <TimToady> pmichaud: given how Failure can be either in-band or out-of-band in Perl 6, I think we should probably use some particular Failure as the sentinel, like Failure()

[16:52] <pmichaud> TimToady: yeah, that seems reasonable to me

[16:52] <TimToady> then people can write in 'use fatal' style if they want

[16:52] <pmichaud> I'm not sure I understand that last part ('use fatal')

[16:52] <TimToady> and since Failure() is both a type and a singleton value, we can optimize

[16:53] <TimToady> when a sub-iterator terminates with fail; it throws and exception instead of returning Failure() normally

[16:54] *** sukomalo joined
[16:54] <pmichaud> given that lists in general are pretty common, won't that cause lots of exceptions for even normal list semantic type thingies?

[16:54] <TimToady> not sure how that interacts with gather/take though

[16:54] <pmichaud> I mean, even a simple say @list;  could end up throwing an exception

[16:54] <TimToady> normally we'd use the Failure() as a sentinal value

[16:56] <TimToady> maybe that depends on whether the implementation of say does 'use fatal', not the current scope

[16:56] <pmichaud> ...I thought things like 'use fatal' were dynamic, though.

[16:57] <pmichaud> and it's not really the say() that would be imposing fatalness or non-fatalness, but whatever say uses to iterate its slurpy argument list

[16:57] <TimToady> use fatal is lexically scoped

[16:57] <TimToady> fail looks up at the caller to see what it says

[16:57] <TimToady> in the caller's lexical scope

[16:57] <pmichaud> just one level of caller?

[16:58] <TimToady> don't see how it could work otherwise

[16:58] <pmichaud> okay, that's fine.

[16:58] *** SmokeMachine left
[16:58] <pmichaud> I didn't recognize that aspect of 'use fatal', but if that's how it works, no problem.

[16:58] <TimToady> you have to write the code in your lexical scope with one assumption or the other

[16:58] <TimToady> can't have your caller changing the meaning of your code that way

[16:59] <pmichaud> anyway, a sentinel Failure works for me

[16:59] <TimToady> OTOH, maybe Failure() doesn't give a good message

[16:59] <TimToady> some some particular subtype of Failure

[16:59] <pmichaud> yeah, subtype of Failure was where I had been leaning at one point

[16:59] <TimToady> Nothing() or some such

[16:59] <pmichaud> NoMore()  :-)

[16:59] <TimToady> AllGone()

[17:00] <pmichaud> AllDone()

[17:00] <pmichaud> Done()

[17:00] <pmichaud> End()

[17:00] <pmichaud> Fini()

[17:00] <TimToady> TheEnd()

[17:01] <TimToady> It'sTheEndoftheWorldasWeKnowIt-andIFeelFine()

[17:01] <pmichaud> Fine()

[17:02] <TimToady> Credits()

[17:02] <pmichaud> okay, I'll go with some sort of sentinel or special-typed sentinel and see how that works.  Did you see the Pm-19 addition?

[17:02] <TimToady> ENOTYET

[17:02] <pmichaud> no problem -- I'm about to grab lunch.

[17:03] <pmichaud> there was some discussion of it in the backscroll also, around 14:51Z

[17:04] *** lumi left
[17:05] *** lumi joined
[17:06] <pmichaud> afk, lunch

[17:11] <TimToady> colomon: In my house, you aren't allowed to cry over spilled milk, but you *are* allowed to cry under it.

[17:14] *** sukomalo left
[17:14] *** pma joined
[17:15] *** cotto_w0rk is now known as cotto_work

[17:16] *** SmokeMachine joined
[17:22] *** pma left
[17:25] *** ash_ joined
[17:27] *** cognominal left
[17:28] <colomon> TimToady: a sensible policy.

[17:29] *** justatheory joined
[17:32] *** stephenlb joined
[17:36] *** cdarroch joined
[17:38] <[particle]> jnthn: happy birthday!

[17:38] <ash_> so... jnthn and/or pmichaud and/or colomon, any of you noticed that loop in ng seems to require a ; after it? even when it doesn't seem like it should? 

[17:41] <colomon> I saw you mentioning it yesterday.

[17:41] <colomon> seems like it must be some sort of parser glitch?

[17:41] <ash_> yeah, i think it is (probably) a parser glitch

[17:41] <ash_> ng: eval("loop { say 'done'; last; };");

[17:41] <p6eval> ng 7daa82: done␤Warning␤Null PMC access in get_string()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤

[17:41] <ash_> ng: eval("loop { \n say 'done'; \n last; \n } \n");

[17:41] <p6eval> ng 7daa82: Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (src/stage0/Regex-s0.pir:907)␤

[17:42] <TimToady> ash_: did you ever find STD.pm?

[17:43] <ash_> TimToady: yes i did, thanks

[17:45] <ash_> I am starting a compiler independent study in a week-ish and i was going to show my professor some of the perl 6 things I have been working with / learning since the christmas break, the perl 6 grammar is pretty amazing IMO, it would be interesting to implement a parser capable of handling it, like pmichaud's nqp-rx, but i doubt i'd be able to (in any sort of reasonable timeframe) implement the grammar completely, but i might try doing parts of it in our study 

[17:46] *** am0c left
[17:48] <colomon> looks like loop is line 354 of Grammar.pm

[17:48] <PerlJam> ash_: you mean loop requires a semicolon after the block even when it shouldn't?

[17:49] <PerlJam> That would be exceedingly weird.

[17:51] <colomon> PerlJam: yet it is true.

[17:51] * PerlJam is building ng now to see

[17:51] <colomon> Works okay if the loop is the last thing in the file, but if something else comes after, it fails.

[17:51] <colomon> without the semicolon, that is.  with it's fine.

[17:52] <PerlJam> weird

[17:54] <ash_> it gives the "Unable to parse blockoid" parser error if you don't have the ';'

[17:55] *** Chillance joined
[17:55] <colomon> ash_: hmmm, I'm getting the "Confused at line blah" error here.

[17:55] * PerlJam too

[17:55] <ash_> what is the difference between <block> and <xblock> in the grammar? 

[17:56] <PerlJam> xblocks can be pointy I think

[17:56] <ash_> colomon: are you running t/spec/S04-statements/loop.t ? 

[17:56] <colomon> ash_: no, I just made a dead simple test file.

[17:57] <TimToady> xblock is for an expression before a pblock

[17:57] <TimToady> such as an if or a for

[17:57] <PerlJam> ah, x for expression

[17:57] <ash_> colomon: can i see your example? and/or i can post mine 

[17:58] <lisppaste3> colomon pasted "loop example" at http://paste.lisp.org/display/93942

[17:58] <PerlJam> colomon: mine was just loop { say "hi"; last; }  # :-)

[17:58] <colomon> that's in working form, obviously, but easy enough to change.

[17:58] <colomon> PerlJam: oh sure, golf me.  ;)

[17:59] <ash_> still, either way, those examples look perfectly valid to me

[17:59] <colomon> oh sure, it's definitely a bug.

[17:59] <TimToady> last I heard, ng was trying to parse without using a MEMO array, like STD uses

[17:59] *** dakkar left
[18:00] <TimToady> maybe it's necessary here

[18:01] * PerlJam looks at STD's statements

[18:01] <TimToady> it's the stuff at the end of blockoid

[18:01] <ash_> i don't know the details, but if it can work for things like 'for' why wouldn't it work for 'loop'? just speculating... 

[18:02] <TimToady> specifically the endstmt memo

[18:04] <ash_> if you do <xblock(1)> whats the purpose of the (1) ? i am still learning how the whole grammar thing works :P 

[18:04] *** ejs left
[18:04] <TimToady> um, STD doesn't have that parameter

[18:05] <colomon> ash_: it's passed in as $*IMPLICIT

[18:05] <colomon> not that I know what that does.

[18:05] <colomon> so maybe setting a flag which is normally 0 to 1?

[18:06] <TimToady> maybe it's the difference between if and while on the handling of a bare block

[18:06] <TimToady> while assumes -> $_ but if doesn't

[18:06] *** ignacio_ left
[18:06] <TimToady> I don't think STD cares about that distinction currently

[18:07] <ash_> well, for uses <xblock(1)> in ng, but while just uses <xblock> (same with if)

[18:07] <PerlJam> aye, $*IMPLICIT == 1 seems to setup $_

[18:08] <TimToady> sorry, I meant if and for

[18:08] <TimToady> while is like if

[18:08] <PerlJam> well,  a true value for $*IMPLICIT anyway

[18:08] <ash_> it seems all the other statement_control tokens use xblock except loop

[18:08] *** go|dfish joined
[18:09] <colomon> PerlJam++ has it.  line 160 of Actions.pm handles IMPLICIT.

[18:09] <PerlJam> yep

[18:09] <ash_> no, i spoke to soon, default, CATCH, CONTROL statements use <block> as well

[18:10] <PerlJam> ash_: default too

[18:10] <ash_> okay, got ya, so (1) wouldn't be the issue 

[18:10] <PerlJam> oops, you said that one

[18:10] <PerlJam> the gravity around CATCH an CONTROL was too great for me too see default  :)

[18:11] <TimToady> well, does default {} fail?

[18:11] <ash_> no, not for me

[18:12] <ash_> ng: given 5 {default {say 'hi';}}

[18:12] <p6eval> ng 7daa82: hi␤

[18:12] <ash_> and its okay with whitespace and newlines around the { } too

[18:13] <PerlJam> ash_: you don't even need a give to use default

[18:13] <PerlJam> er, *given

[18:13] <TimToady> ng: given 5 { default { say 'hi'}␤say 'lo'}

[18:13] <p6eval> ng 7daa82: hi␤

[18:13] <TimToady> well, default needs to know where to succeed to

[18:13] <ash_> i know, i just like know where its going to return to

[18:14] <ash_> ng: default { say 'a'; } say 'b';

[18:14] <p6eval> ng 7daa82: Confused at line 1, near "default { "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤

[18:14] <TimToady> ng: default { say 'hi' }

[18:14] <p6eval> ng 7daa82: hi␤

[18:14] <colomon> oooo

[18:14] *** stephenlb left
[18:14] <ash_> did i spell something wrong? 

[18:14] <colomon> ng: default { say 'a'; }; say 'b';

[18:14] <p6eval> ng 7daa82: a␤

[18:14] <TimToady> ng default { say 'a' }␤say 'b';

[18:15] <TimToady> ng: default { say 'a' }␤say 'b';

[18:15] <p6eval> ng 7daa82: a␤

[18:15] <colomon> it is the same bug in this context.

[18:15] <ash_> ah 

[18:15] <ash_> well then, it might be <block> related

[18:15] <TimToady> eh, the semi above is necessary because there's no newline

[18:15] <PerlJam> TimToady: I think you were on the right track with @*MEMOS and <endstmt>.  Rakudo does something equivalentish, but different.

[18:15] <TimToady> not because of the bug

[18:16] <TimToady> if you put in newline with ␤ it works

[18:16] <TimToady> PerlJam: or not equivalent

[18:16] <colomon> TimToady++ is correct.

[18:16] *** rgrau joined
[18:16] <colomon> blast, I thought we had a clue there.

[18:16] * TimToady is always correct, except when he isn't.

[18:16] *** araujo left
[18:17] <jettero> I don't think my font is showing ␤  well... what is that meant to be?

[18:17] <ash_> a new line 

[18:17] <jettero> oh, I guess that's what it is, but it's really small

[18:17] <TimToady> which bot does that?

[18:18] *** stephenlb joined
[18:18] <TimToady> u: ␤

[18:19] <TimToady> phenny: u: ␤

[18:19] <TimToady> must be misremembering

[18:19] * PerlJam didn't know that any of the bots were unicode-smart

[18:19] <TimToady> there was one on here a month or so ago

[18:20] <jettero> oic, it's a tiny little N and L in a big enough font.  It looks kinda like a right arrow in my terminal font

[18:21] <TimToady> the p6eval bot will translate it both directions

[18:21] <diakopter> .u  ␤

[18:21] <phenny> U+0020 SPACE ( )

[18:21] <phenny> U+2424 SYMBOL FOR NEWLINE (␤)

[18:21] <TimToady> that were it

[18:22] <jettero> :)  How do you type that btw?

[18:22] <diakopter> copy/paste

[18:22] <jettero> I can type things like — and ē with my compose key, but I can't find a sequence for ␤

[18:22] <TimToady> I have a program that I can type to get it: 'u newline'

[18:23] <TimToady> various input methods allow raw unicode input, if you know the hex code

[18:23] <TimToady> gnome has a native one that I always forget

[18:24] <jettero> I'm going to look for that immediately

[18:26] <jettero> ctrl-shift

[18:26] <TimToady> CTRL-SHIFT-u

[18:26] <jettero> yeah, the u

[18:28] *** ShaneC joined
[18:28] <lichtkind> moritz_: can i get some question time?

[18:34] *** cdarroch left
[18:35] *** araujo joined
[18:37] <ash_> i like how in OS X you can just hold alt and get a limited set of unicode characters (like ¢ = option + 3) but you can switch input modes and do option + unicode number and it will put the character in 

[18:39] <jettero> I'm very fond of the compose key... it's still new for me.  You can add things to it if there's characters you like, not on the list

[18:39] <jettero> I needed some way to type: I'm running perl 5.10 on my palm prē

[18:44] *** cdarroch joined
[18:45] *** araujo left
[18:46] *** Chazz joined
[18:47] *** Chazz is now known as Guest77853

[18:47] *** araujo joined
[18:47] <ash_> so how would a *MEMO help with finding the end of the loop

[18:50] *** Guest77853 is now known as Chazz

[18:52] *** cj_ is now known as cj

[18:54] <pmichaud> back from lunch

[18:54] <diakopter> on Windows (since 3.1) you can Alt+0, codepoint on numpad

[18:54] <ash_> yay unicode support in all major os's 

[18:54] <ash_> bsd probably functions the same as linux, if your using gnome, etc. i am sure

[18:55] <jettero> I can't get the windows version to work, probably my terminal

[18:55] <jettero> or synergy

[18:56] <pmichaud> the problem with "loop" in ng is likely related to the <.ws>

[18:56] <pmichaud> or perhaps the :s isn't properly scoped

[18:57] <lichtkind> what was the end oft pugs hajdays end of 2007 ??

[18:57] *** araujo left
[18:58] *** araujo joined
[18:59] <pmichaud> I'm guessing it's the :s

[19:00] <pmichaud> ash_: *MEMO isn't used for finding the end of the loop here -- the problem is that after finding the end of the loop, it's not detecting a valid statement terminator.

[19:01] <pmichaud> and that generally has to do with eating or not-eating whitespace at the end of the closing brace

[19:01] <ash_> ah, okay, i guess that makes sense

[19:01] <pmichaud> so *MEMO (in STD) keeps track of where it's seen statement-ending curly braces

[19:01] <pmichaud> I have a fix... spectesting now

[19:03] *** rblasch joined
[19:04] *** araujo left
[19:05] <pmichaud> pushed as commit 78e3b48

[19:06] *** araujo joined
[19:06] <dalek> rakudo/ng: 78e3b48 | pmichaud++ | src/Perl6/Grammar.pm:

[19:06] <dalek> rakudo/ng: Fix statement termination with 'loop' statement control -- noticed

[19:06] <dalek> rakudo/ng: by ash_++.

[19:06] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/78e3b4868e2b67cb7b245a6b43a422e0cc5d6113

[19:07] <ash_> cool, t/spec/S04-statements/loop.t probably works then 

[19:07] <pmichaud> it fails, redeclaration of $i

[19:07] <ash_> ah, it still has the list declaration issue then

[19:07] <pmichaud> right

[19:08] <ash_> i can change the test to not rely on list declarations

[19:08] <pmichaud> yes, changing that causes the test to pass.

[19:09] <pmichaud> (feel free to double-check and commit changes)

[19:09] *** araujo left
[19:11] *** araujo joined
[19:11] *** ejs joined
[19:13] <pmichaud> If we use .get() on an Iterator to get a single element, is there a good name for a method on Iterators that could be used to retrieve (up to) $n elements?

[19:13] <pmichaud> .grab($n)   ?

[19:14] <pmichaud> (For filehandles, we use .lines($n), but that doesn't seem to fit for a generic iterator.)

[19:14] *** araujo left
[19:15] *** rblasch_ joined
[19:16] *** araujo joined
[19:17] <ash_> collect? 

[19:17] <ash_> .collect(5)

[19:18] <pmichaud> I thought of collect earlier, but didn't like it for some reason.  although it seems better now.

[19:18] <pmichaud> Plus, if we do that then we can always call collect :-)

[19:18] <pmichaud> (sorry, bad pun)

[19:19] <PerlJam> why not just .get($n) ?

[19:19] <ash_> .gimme(5) 

[19:19] <pmichaud> because it (currently) conflicts with .get on filehandles :)

[19:19] <pmichaud> I'm fine if .get accepts an argument

[19:19] *** araujo left
[19:20] <colomon> what does .get($n) return?

[19:20] <PerlJam> .lines($n) seems like it could be a synonym for .get($n) that just has the unit of iteration built-in for human convienence.

[19:20] <PerlJam> colomon: a list of $n things from the iterator.

[19:21] <pmichaud> colomon: .collect($n)   (or .get($n) if adopted)  returns a parcel with the $n next elements from the iteration

[19:21] *** araujo joined
[19:21] <colomon> so is .get(1) equivalent to .get() or does it return a parcel with 1 element?

[19:21] <PerlJam> If there's only 2 things left to iterate and we ask for 5 things from the iterator, do we get 3 Failure()s ?

[19:22] <pmichaud> PerlJam: either that or just 2 elements

[19:22] <pmichaud> or 2 elements and 3 nils

[19:22] <pmichaud> I'd reserve returning Failure() for when nothing is returnable.

[19:22] <PerlJam> colomon: yes :)

[19:22] *** rblasch__ joined
[19:23] <pmichaud> in general, a parcel with 1 element is the same thing as the one element.

[19:23] <colomon> pmichaud: ah

[19:24] <colomon> sorry, just trying to work through the ramifications of having the function which defines iteration return something which requires iteration.

[19:24] <PerlJam> colomon: a parcel doesn't *require* iteration

[19:24] <colomon> (or will a n element parcel have some other approach for examining its values)

[19:24] <PerlJam> colomon: you just have to put it in the proper container or context

[19:25] <pmichaud> basically, one possibility of map:

[19:26] <pmichaud>     my $c = $iter.collect(&block.count);

[19:26] <pmichaud>     last if $c ~~ sentinel;

[19:26] <pmichaud>     &block(|$c)

[19:26] <pmichaud> modulo syntax and the fact that eventually we don't want to be using .count to figure out the number of arguments

[19:27] <ash_> so... that could be like $file.map -> $line_1, $l2, $l3, $l4 { } and have line_1 ... n ? 

[19:27] <colomon> pmichaud: shouldn't the test be more like "last if $c.elems != &block.count" ?  (understanding that .elems probably doesn't work here)

[19:27] *** araujo left
[19:28] <pmichaud> colomon: no, it's possible to call block with fewer than .count elements

[19:28] <pmichaud> (optional params, for example)

[19:28] <colomon> rakudo: (1..5).map({ say $^a; say $^b; });

[19:28] <p6eval> rakudo 1d4928: 1␤2␤3␤4␤

[19:29] <pmichaud> that's a bug in rakudo

[19:29] <colomon> k

[19:29] <pmichaud> rakudo:   (1..5).map( -> $a, $b? { say $a; say $b; });

[19:29] <p6eval> rakudo 1d4928: 1␤Use of uninitialized value␤␤2␤Use of uninitialized value␤␤3␤Use of uninitialized value␤␤4␤Use of uninitialized value␤␤5␤Use of uninitialized value␤␤

[19:29] <pmichaud> that should display 1 2 3 4 5 Mu()

[19:29] *** araujo joined
[19:29] <pmichaud> (with \n's)

[19:30] *** rgrau left
[19:30] <colomon> pmichaud: is the ? necessary or just polite?  I guess I'm asking, if it weren't there, should it display 1 2 3 4 ?

[19:31] <pmichaud> if the ? isn't there, then there should be a complaint about not enough arguments being sent to the block

[19:31] *** araujo left
[19:31] <pmichaud> just as if one did  

[19:31] <pmichaud> rakudo:  (-> $a, $b { say $a; say $b; })(5)

[19:31] <p6eval> rakudo 1d4928: Not enough positional parameters passed; got 1 but expected 2␤in Main (file src/gen_setting.pm, line 324)␤

[19:31] <colomon> gotcha.

[19:32] <colomon> okay, sorry for the digression.

[19:32] <ash_> std: (-> $a, $b? { say $a; say $b; })(5)

[19:32] <p6eval> std 29590: ok 00:01 108m␤

[19:32] <ash_> looks good to the std if you just use ? 

[19:32] <PerlJam> syntax isn't the problem.

[19:32] <pmichaud> rakudo:  (-> $a, $b? { say $a; say $b; })(5)

[19:32] <p6eval> rakudo 1d4928: 5␤Use of uninitialized value␤␤

[19:32] *** iblechbot joined
[19:32] <pmichaud> okay, Use of uninit valud then :-)

[19:32] *** araujo joined
[19:33] <pmichaud> *value

[19:34] <pmichaud> I'll go with .collect($n) for now.

[19:34] <ash_> rakudo: (-> $a, $b? { say $a; say $b.WHAT; })(5)

[19:34] <p6eval> rakudo 1d4928: 5␤Failure()␤

[19:35] <colomon> pmichaud++ # .collect($n)

[19:35] * pmichaud desperatly wants to eliminate rakudo's master branch so that we don't see all of the places where it's become wrong

[19:36] *** rblasch left
[19:36] <ash_> pmichaud++ # for trying to get things figured out so ng can be master

[19:38] *** araujo left
[19:39] *** araujo joined
[19:40] *** rblasch_ left
[19:42] * colomon wants to be able to say "ng is my master now."

[19:43] <pmichaud> afk for a bit

[19:44] <ash_> how does rakudo-master deal with some of the issues like iterators?

[19:44] <PerlJam> colomon: you could, on your local repo, delete master and rename ng to master.  :)

[19:44] <colomon> PerlJam: it wouldn't be the same.

[19:45] <PerlJam> colomon: then perhaps you really want to be able to say "ng is our master now"  :)

[19:45] *** ash_ left
[19:48] <colomon> fair enough.  :)

[19:50] <TimToady> it seems strange if $iterator.collect($n) just returns another iterator

[19:50] <TimToady> for native types at least, you'd like to get a compact representation of those $n elements

[19:51] <TimToady> and for other types, a Seq or Array of 'em

[19:52] *** mariano__ joined
[19:52] <TimToady> there has to be some reason you want $n of them all together, and I suspect that'll involve treating them out-of-order, which implies indexing

[19:52] <TimToady> or some other reason for keeping the batch as a single object

[19:53] <TimToady> (I'd prefer .getbatch over .collect, I think, just to emphasize the relationship with .get)

[19:54] <TimToady> and to me, "collect" implies looking in random places

[19:54] *** cdarroch_ joined
[19:54] *** bluescreen left
[19:55] <PerlJam> TimToady: why not just .get($n) ?

[19:55] <TimToady> because then the type of the return value is not constant

[19:56] <PerlJam> .many($n) then?

[19:56] <TimToady> maybe .getseq($n)

[19:57] <PerlJam> getseq and getbatch seem to be encoding type information in the name when it should be a parameter IMHO

[19:57] <PerlJam> .get($n, Seq)  # I'm stubborn  :)

[19:57] <TimToady> BLETCH

[19:57] *** ash_ joined
[19:57] *** lumi left
[19:58] *** lumi joined
[19:58] <TimToady> if anything is parametric, it's the type of each element

[19:58] <PerlJam> yes, I agree with the sentiment, but getseq makes me feel the same way :)

[19:58] <PerlJam> true

[19:58] <PerlJam> (or maybe true :)

[19:59] <TimToady> and getseq may be written quite differently from getarray

[20:00] <TimToady> I think we also need to think hard about where we're baking in serial assumptions that we shouldn't

[20:00] *** ejs left
[20:01] <TimToady> i.e. hyper map should not be implemented with a while loop

[20:04] * PerlJam tries to wrap his head around "non-linear" iterators

[20:06] *** cdarroc3 joined
[20:06] *** jonasbn left
[20:07] <jettero> "serial assumptions" as in: maybe it's on multicore?

[20:07] <jettero> or something fancier?

[20:09] *** cdarroch left
[20:10] <TimToady> http://research.sun.com/projects/plrg/Publications/ICFPAugust2009Steele.pdf

[20:11] *** cdarroch_ left
[20:14] *** araujo left
[20:14] *** uniejo joined
[20:14] <pmichaud> I don't want $iterator.collect to return an iterator, it returns a Parcel

[20:14] <pmichaud> which can then be turned into a Capture (and that doesn't require iterating or flattening)

[20:15] *** araujo joined
[20:15] *** jaldhar left
[20:15] <pmichaud> I'm fine with .getbatch

[20:16] <jettero> these slides are great. 

[20:17] <PerlJam> jettero: they were fine until he started speaking lisp  :)

[20:17] *** payload joined
[20:17] <jettero> heh

[20:18] <jettero> I may not get all the way through then

[20:18] <pmichaud> I'm fine with .getseq also

[20:19] *** payload1 left
[20:19] <pmichaud> .getbatch is nice;  I had been considering .batch some time ago, to also emphasize the "batch" nature

[20:19] <pmichaud> .getseq might imply that what we're getting back is a Seq, which really oughtn't be the case

[20:19] * PerlJam concludes that TimToady and pmichaud have some weird aesthetics

[20:19] <pmichaud> PerlJam: yeah, we both like Perl 6.  :)

[20:20] *** lumi left
[20:20] *** lumi joined
[20:20] <PerlJam> .getseq and .getbatch both make me retch a little.  I could probably warm up to .batch though since it works in multiple conceptual dimensions.

[20:21] <pmichaud> in some sense, they should make one wretch.  We don't generally expect people to be using these directly :)

[20:21] <pmichaud> *retch

[20:21] <pmichaud> or *a wretch  :-)

[20:22] *** japhb left
[20:22] <pugs_svn> r29591 | pmichaud++ | [t/spec]:  Remove unnecessary list declaration from loop.t . 

[20:24] <TimToady> have also been considering whether the done testing should be an ugly operator:  take @iterators.>>get /// last

[20:24] *** cdarroc3 left
[20:24] <TimToady> instead of a macro

[20:25] <TimToady> (well, such operators are macros)

[20:25] <TimToady> it's also possible we should be hijacking the existing orelse/andthen for this

[20:25] <pmichaud> hmmm, hadn't thought of those.  that's a possibility.

[20:26] <pmichaud> anyway, I've created a new branch ("ng1") for ripping-out/refactoring ng's current parcel/list/array stuff -- we'll see how far I get :)

[20:26] <TimToady> since there's basically in there to process lists of continuations

[20:26] <dalek> rakudo/ng: b8201fd | pmichaud++ | t/spectest.data:

[20:26] <dalek> rakudo/ng: Mark t/spec/S04-statements/loop.t as passing.

[20:26] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/b8201fd3a75c9b7dc6b7ad07efbbf78847f44bcb

[20:27] <colomon> I dunno, I'd hesitate to add language-level support for using the iterators without some evidence that end-users were using them directly on a fairly regular basis.

[20:27] <TimToady> the basic point of the Steele slides is that parallizable lists should be represented as trees that can subdivide the work in parallel

[20:28] <TimToady> colomon: if you want to write the primitive operations in Perl 6, you have to have even more primitive operators to write 'em with

[20:28] <pmichaud> since our lists are lazy, that sounds more like parallizable iterators

[20:28] <TimToady> hyper lists are the opposite of lazy

[20:29] <TimToady> they're a form of eager list

[20:29] <pmichaud> okay, but to get to the eager list we often have to go through an iterator first

[20:29] <TimToady> but we still have to be able to iterate those

[20:29] <colomon> I thought we'd done away with the concept of hyper / eager lists?

[20:29] <pmichaud> colomon: nafaik

[20:29] <TimToady> who ever said that?

[20:30] <pmichaud> I'm sure that   @a >>+<< @b   involves hyper lists :-)

[20:30] <colomon> no one ever said it directly, but I thought the point of what we were doing is that lists are by definition lazy.

[20:30] <pmichaud> "lists" plain, yes.  but hyper lists are a different animal.

[20:31] <pmichaud> lists are lazy, unless eager or hyper :-)

[20:31] <TimToady> at least two different defs of list here

[20:31] <TimToady> list *context* is lazy

[20:31] <colomon> I thought that @a >>+<< @b would be adding two Seqs, or something like that.

[20:32] <pmichaud> (Seqs are lazy too :-)

[20:32] <TimToady> can be lazy

[20:32] <TimToady> just like Arrays

[20:32] <pmichaud> right

[20:32] <colomon> (BTW, I'm still somewhat tempted to allow @a >>+<< @b to be lazy... or to have an equivalent lazy concept, at least.)

[20:32] <TimToady> well, it depends on whether the context of *that* wants it lazily, eagerly, or hyperly

[20:33] <TimToady> but hyperops are already claiming you don't care what order they're done in

[20:33] <pmichaud> I thought part of the point of >><< was to say that it could be hyperized

[20:33] <pmichaud> right

[20:33] *** cdarroch joined
[20:33] <TimToady> which kinda implies you'll eventually want all the values

[20:33] <TimToady> regardless of which order you use them

[20:34] <TimToady> that's why we say that hyper is a form of eager

[20:34] <pmichaud> I've been very tempted several times in Rakudo to go make sure that >><< doesn't evaluate things in sequence

[20:34] <TimToady> they're both run-to-completion semantics

[20:34] <TimToady> pugs did that :)

[20:35] <pmichaud> haven't done it yet, but I'm likely to do so

[20:35] <PerlJam> pmichaud: after ng becomes master :)

[20:35] <TimToady> pugs: (1,2,3)>>.say

[20:35] <p6eval> pugs: 2␤3␤1␤

[20:36] *** uniejo left
[20:36] <pmichaud> PerlJam: yeah, the setback on lists/iterators this past weekend has definitely put me behind schedule.  I'm trying to catch up.

[20:36] <pmichaud> (not behind schedule for Rakudo *, just behind schedule for my milestone)

[20:36] <colomon> Right, I understand the benefits of having hyper.  I'm just thinking there are potential benefits to having list-ops, too, like the ability to add two finite lists with a single operator.

[20:36] <colomon> s/finite/infinite/

[20:37] <colomon> I suppose it falls into the category of "easy enough to implement that you can do it in a module".  :)

[20:37] <TimToady> it might fall out from the S metaoperator

[20:38] <pmichaud> "so easy, even a caveman can do it."

[20:40] <colomon> pmichaud: seriously, it's just (@a Z @b).map(-> $a, $b { $a + $b; }), isn't it?

[20:40] <colomon> the only tricky bit is handily the grammar to make using it elegant.

[20:40] <colomon> *handling

[20:41] <pmichaud> colomon: yes, that works

[20:41] <pmichaud> or even   { $^a + $^b } for @a Z @b

[20:43] <TimToady> of course, Z could in some cases hyperize itself too

[20:43] <colomon> TimToady: S»op« -- example says "single-thread", but does it also implement "serial" (ie in order)

[20:43] <TimToady> "serial" is one of the things the S stands for

[20:43] <colomon> ?

[20:44] <colomon> TimToady: is that a yes?

[20:45] *** araujo left
[20:45] *** araujo joined
[20:46] *** araujo left
[20:46] <PerlJam> colomon: See S03:4282  :-)

[20:47] <colomon> PerlJam: That's exactly where I'm looking.

[20:47] *** araujo joined
[20:47] <PerlJam> colomon: I know ... the paragraph right above the example you gave seems pretty clear to me.

[20:51] <colomon> PerlJam: combined with the examples it doesn't seem that clear to me.

[20:52] <PerlJam> colomon: why?  Do you think it's doing something different in each of those examples?

[20:53] <colomon> In particular, normal hyper-ops both don't have a default ordering and are potentially multi-threaded.

[20:53] <colomon> The example suggests S makes a hyper-op single-threaded.

[20:54] <colomon> That doesn't tell me if it is also serial.

[20:54] <colomon> It certainly isn't short-circuit, I hope!

[20:54] <colomon> I'm trying to figure out what set of S-words apply.

[20:55] <colomon> And are they still otherwise hyper?

[20:55] <colomon> It seems like serial, single-threaded hyper-ops could be lazy.  This spec most definitely does not say that, though...

[20:59] *** araujo left
[20:59] *** araujo joined
[20:59] *** fridim_ joined
[21:00] *** tarski joined
[21:00] *** SmokeMachine left
[21:00] *** lumi left
[21:00] *** lumi joined
[21:01] *** japhb joined
[21:07] <colomon> Though I suppose the only point (that I can see) to force single-threading is to also force it to run in order.

[21:07] <spinclad> well, it does say Sequential...

[21:20] <ash_> forcing single-threading might also be to protect the data if you don't know if its thread safe? 

[21:24] <colomon> ash_++

[21:24] *** mariano__ left
[21:25] <ash_> since most people don't write threadsafe code by default, since its only occasionally a legitimate concern 

[21:31] *** k23z__ left
[21:33] *** payload left
[21:35] *** ejs joined
[21:36] *** payload joined
[21:40] *** meteorja1 joined
[21:40] *** meteorjay left
[21:45] *** athaba joined
[21:52] *** cdarroch left
[21:52] *** rblasch__ left
[21:57] *** araujo left
[21:58] *** araujo joined
[22:02] *** lumi left
[22:02] *** lumi joined
[22:08] *** uniejo joined
[22:18] <ash_> completely unrelated to perl 6 but i found this, its pretty cool, this guy visualized some sorting algorithms, http://corte.si/posts/code/sortvis-fruitsalad/index.html

[22:21] *** pnate left
[22:24] <ash_> is there a reason for ng1 on github? 

[22:27] <pmichaud> ng1 is where I'm going to push my list/iterator changes for the next couple of days

[22:28] <pmichaud> because they're guaranteed to break tests for a short while

[22:28] <pmichaud> when it's done (hopefully tonight/tomorrow), I'll merge back to ng

[22:29] *** kaare_ left
[22:29] <ash_> is it that big of a deal if ng regresses? since its not master

[22:30] *** kraih_sri left
[22:31] *** Su-Shee left
[22:32] <pmichaud> no, but branches are cheap.

[22:32] <pmichaud> and merges are easy in git.

[22:32] <ash_> yeah, true

[22:32] <pmichaud> I only expect to keep the branch for a day or so, unless I bog down, in which case it's much easier to throw away the branch than it is to revert a bunch of changes

[22:33] <pmichaud> and that's the other reason for using a branch, I'm not sure that the next attempt will be the one we ultimately want to keep

[22:33] <pmichaud> although I already ripped out the Parcel -> List conversions in ng1, and I'm surprised at how much still works :)

[22:33] <pmichaud> although arrays are pretty much hosed atm

[22:37] <ash_> do any of the perl 6 list things have much of an affect on nqp-rx? 

[22:37] <pmichaud> not yet.  the @(...) definition might.

[22:38] <pmichaud> but it should be pretty similar overall.

[22:38] <pmichaud> the main reason nqp-rx doesn't have an issue is that its lists aren't lazy :)

[22:38] <pmichaud> and there's no flattening or list context -- it's just binding

[22:40] <ash_> ah, okay, cool 

[22:45] *** mikehh_ left
[22:46] <PerlJam> nqp-rx++ (A verful useful version of simplicity)

[22:47] <PerlJam> s/verful/very/

[22:47] <pmichaud> hmmm

[22:47] <PerlJam> one of these days I'll get my fingers and brain a little more coordinated

[22:48] <japhb> Still, the sentiment was accurate.

[22:49] *** iblechbot left
[22:50] <pmichaud> looks like the difference between .list and .iterator is that the former is marked as "flattening"

[22:50] <pmichaud> s/is/might be/

[22:50] <ash_> i am doing an independent study with a professor on compilers soon, i was thinking of trying to implement part of nqp for part of it

[22:50] <pmichaud> ash: that'd be cool

[22:51] *** colomon_ joined
[22:52] *** he_ left
[22:52] *** mtve left
[22:52] *** yves left
[22:52] *** REPLeffect left
[22:52] <pmichaud> need walk -- bbl

[22:52] <ash_> i am working from the Compilers principles, techniques and tools second edition and the crafting compilers book, so i'll see what happens

[22:52] *** yves joined
[22:52] *** mtve joined
[22:52] *** ejs left
[22:53] *** athaba left
[22:54] *** davidfetter joined
[22:54] <davidfetter> oh hai

[22:54] <PerlJam> ash_: what would your compiler generate?  C? or something else?

[22:54] <davidfetter> what's the latest re: rakudo atop parrot 2.0?

[22:55] <ash_> probably llvm for now, i don't know though, i am still learning :P 

[22:56] <PerlJam> ash_: were you going to try the GSoC too?  I think I saw you say something about that on #parrot

[22:57] *** alester left
[22:58] <ash_> yeah, this independent study is only till may-ish, so GSoC i think is more summer time, i was hoping to learn about compilers in general and then hoping for the GSoC to do the stack frame builder in llvm if it hasn't been done, or some other things if i can figure out something useful to try with parrot

[22:59] <ash_> the independent study is so i am not completely lost if i talk to the #parrot people about compilers

[23:06] *** mssm left
[23:06] *** mssm joined
[23:09] *** Chillance_ joined
[23:09] *** _Chillance_ joined
[23:10] <pmichaud> davidfetter: rakudo runs on parrot 2.0

[23:10] <pmichaud> (both ng and master branches)

[23:12] *** lumi left
[23:12] *** lumi joined
[23:12] *** patspam joined
[23:13] <ash_> unfortunately there hasn't been enough interest in a compiler class at my college, so i am doing it as an independent study 

[23:13] *** RichiH left
[23:14] *** RichiH joined
[23:16] <lichtkind> why is parrot no 2.0

[23:16] <lichtkind> API breakes?

[23:16] <Tene> lichtkind: what?  why is parrot 2.0?  Because January happened.

[23:17] <lichtkind> ah so year was over

[23:17] <lichtkind> i thought parrot 1.0 was because to st an API that will not be changed until 2.0

[23:18] <ash_> the major number changes once a year, its 2.0 this year, next year it will bump to 3.0

[23:18] <ash_> for parrot

[23:18] <davidfetter> pmichaud, great! is there anything else gating distribution on fedora?

[23:18] <ash_> i only know because i asked them a few days ago :P 

[23:19] <lichtkind> ash_: so no major API breaks?

[23:19] <ash_> nope

[23:19] <ash_> well, Context and CallSignature PMCs merged into CallContext but thats all in the changelogs 

[23:20] <ash_> i think thats the biggest change incompatibility change i can think of, but ask on #parrot for more details

[23:21] <lichtkind> ash_: thanks but i was never much into the low level side

[23:23] *** lumi left
[23:23] *** lumi joined
[23:26] *** Chillance left
[23:27] *** Chillance_ left
[23:34] *** ihrd joined
[23:35] *** uniejo left
[23:40] *** hudnix joined
[23:44] *** ash_ left
[23:54] <hudnix> rakudo: class A { method foo {say "foo"} }; class B {has A $.aaa handles 'foo' }; my B $b; $b.foo

[23:54] <p6eval> rakudo 1d4928:  ( no output )

[23:56] *** hercynium joined
[23:59] *** ihrd left
