[00:00] *** meppl left
[00:01] <jnthn> o/

[00:02] <lue> is that hello or goodbye. In any case, (hello|goodbye), jnthn o/

[00:04] <jnthn> it's "hai I'm back for a bit" :-)

[00:08] <lue> rakudo: my $greetings=('hello'|'goodbye'); say "$greetings jnthn!"

[00:08] *** hanekomu left
[00:08] <p6eval> rakudo c9db3d: OUTPUT«any("hello", "goodbye") jnthn!␤»

[00:14] <colomon> \o

[00:17] <lue> o/

[00:20] *** Sarten-X joined
[00:22] *** k23z__ left
[00:24] * lue wonders if you can represent aleph numbers in P6...

[00:26] <jnthn> Maybe suggest it on p6l. :-)

[00:28] *** snarkyboojum joined
[00:31] <lue> Oh yeah, I signed up for that, didn't I?

[00:31] <lue> snarky: hai o/

[00:31] <lue> std: aleph

[00:31] <p6eval> std 30307: OUTPUT«Undeclared routine:␤   'aleph' used at line 1␤ok 00:01 108m␤»

[00:32] <lue> std: my $a = Inf

[00:32] <p6eval> std 30307: OUTPUT«ok 00:01 107m␤»

[00:32] <lue> rakudo: say Inf - 1

[00:32] <p6eval> rakudo c9db3d: OUTPUT«Inf␤»

[00:32] <lue> rakudo: say (Inf - 1)

[00:32] <p6eval> rakudo c9db3d: OUTPUT«Inf␤»

[00:32] <lue> the same happens when s/Inf/aleph/

[00:33] <snarkyboojum> lue: hai ho o/

[00:33] <lue> .u aleph

[00:33] <phenny> lue: Sorry, no results for 'aleph'.

[00:34] <lue> .u beth

[00:34] <phenny> U+0712 SYRIAC LETTER BETH (ܒ)

[00:34] <lue> ( obviously, hebrew is not a part of phenny :( )

[00:36] <lue> rakudo: say *

[00:36] <p6eval> rakudo c9db3d: OUTPUT«!whatever_dispatch_helper␤»

[00:36] <lue> rakudo: say -(1)

[00:36] <p6eval> rakudo c9db3d: OUTPUT«-1␤»

[00:36] <lue> rakudo: say -(*)

[00:36] <p6eval> rakudo c9db3d: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[00:36] <sorear> .u HEBREW LETTER ALEF

[00:36] <phenny> U+05D0 HEBREW LETTER ALEF (א)

[00:36] <sorear> your spelling sucks

[00:36] <sorear> .u U+05D1

[00:36] <phenny> sorear: Sorry, no results

[00:36] <sorear> .u 05D1

[00:36] <phenny> U+05D1 HEBREW LETTER BET (ב)

[00:37] <sorear> .u 05D2

[00:37] <phenny> U+05D2 HEBREW LETTER GIMEL (ג)

[00:37] <sorear> .u 05D3

[00:37] <phenny> U+05D3 HEBREW LETTER DALET (ד)

[00:37] <sorear> .u 05D4

[00:37] <phenny> U+05D4 HEBREW LETTER HE (ה)

[00:37] <sorear> .u 05D5

[00:37] <phenny> U+05D5 HEBREW LETTER VAV (ו)

[00:37] <daemon> hmm anyway to look up the name of a symbol relative to its 'alt' code for isntance this symbol

[00:37] <daemon> (alt-456)

[00:37] <daemon> sorry

[00:37] <daemon> alt-789

[00:37] <daemon> 􏿽xA7

[00:38] <lue> sorry, but all the (math) resources I've read it's 'aleph' and 'beth'.

[00:38] <sorear> rakudo: say chr(789)

[00:38] <p6eval> rakudo c9db3d: OUTPUT«̕␤»

[00:38] <sorear> rakudo: say sprintf("%x", 789)

[00:38] <p6eval> rakudo c9db3d: OUTPUT«315␤»

[00:38] <sorear> .u U+0315

[00:38] <phenny> sorear: Sorry, no results

[00:38] <sorear> .u 0315

[00:38] <phenny> U+0315 COMBINING COMMA ABOVE RIGHT (◌̕)

[00:39] <sorear> .u 0789

[00:39] <phenny> U+0789 THAANA LETTER MEEMU (މ)

[00:39] <lue> how do you define a range of real numbers in rakudo? ( I saw Real.pm, so don't say I can't :) )

[00:40] <colomon> 3..5

[00:40] <colomon> for instance.

[00:40] <sorear> woah

[00:40] <sorear> rakudo has reals now?!

[00:40] <sorear> rakudo: sprintf "%.100f", sqrt(2)

[00:40] <p6eval> rakudo c9db3d:  ( no output )

[00:40] <snarkyboojum> Real.pm is a work in progress I think :)

[00:40] <sorear> rakudo: printf "%.100f", sqrt(2)

[00:40] <colomon> sorear: might not be what you are thinking of.

[00:40] <p6eval> rakudo c9db3d: OUTPUT«1.4142135623730951454746218587388284504413604736328125000000000000000000000000000000000000000000000000»

[00:41] <colomon> and yes, it is a work in progress.

[00:41] <sorear> sqrt(2) does not have that many 0s

[00:41] <colomon> very much so.

[00:41] <snarkyboojum> was about to say.. colomon++ should know about it ;)

[00:41] *** eternaleye left
[00:41] <lue> I meant how would you go about defining ℝ

[00:42] <snarkyboojum> rakudo: my Real $a = 1.4;

[00:42] <p6eval> rakudo c9db3d:  ( no output )

[00:42] *** opx^on is now known as opx^away

[00:42] <colomon> sorear: sqrt(2) generates a floating point number, with the usual 15 or so digits of precision.

[00:42] <snarkyboojum> rakudo: my Real $a = 1.4; $a.say; $a.WHAT.say

[00:42] <p6eval> rakudo c9db3d: OUTPUT«1.4␤Rat()␤»

[00:42] <snarkyboojum> I smell a Rat!

[00:42] <colomon> Real is a role, and Rat does Real.

[00:42] <snarkyboojum> :)

[00:43] <jnthn> OH REALY? ;-)

[00:43] <snarkyboojum> so I can never had a Real type hanging around?

[00:43] <lue> I'm curious as to how you would go about defining *all* real numbers ℝ (the range)

[00:43] <colomon> snarkyboojum: not by itself, Real is an abstract Role.

[00:43] <colomon> lue: depends on what you mean.

[00:43] <snarkyboojum> colomon: oic

[00:43] <colomon> oic?

[00:44] <snarkyboojum> oh i see

[00:44] <snarkyboojum> sorry

[00:44] <sorear> lue: You can't.  Not all reals are definable

[00:44] <lue> for use in math involving things like aleph and beth numbers :)

[00:44] <snarkyboojum> rakudo: my Real $a = Real.new(4.3); say $a;

[00:44] <colomon> lue: if you really want to be able to represent any real, you need to have some way to represent irrational numbers.

[00:44] <p6eval> rakudo c9db3d: OUTPUT«Real()<0x435a5f0>␤»

[00:44] <lue> (lazy of course)

[00:44] <snarkyboojum> rakudo: my Real $a = Real.new(4.3); say $a; $a.WHAT.say

[00:44] <p6eval> rakudo c9db3d: OUTPUT«Real()<0x4a1b808>␤Real()␤»

[00:44] <colomon> snarkyboojum: that's actually some sort of bug.  hmm....

[00:44] <lue> rakudo: say pi

[00:44] <p6eval> rakudo c9db3d: OUTPUT«3.14159265358979␤»

[00:44] <snarkyboojum> colomon: cool

[00:44] <lue> rakudo: say pi.WHAT

[00:44] <p6eval> rakudo c9db3d: OUTPUT«Num()␤»

[00:45] <lue> There's no IrRat!?

[00:45] <snarkyboojum> rakudo: say Num ~~ Real

[00:45] <p6eval> rakudo c9db3d: OUTPUT«1␤»

[00:45] <colomon> There's no IrRat.

[00:45] <lue> rakudo: say Num; say IrRat

[00:45] <p6eval> rakudo c9db3d: OUTPUT«Num()␤Could not find sub &IrRat␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[00:45] <snarkyboojum> an irrational number is a Num I guess?

[00:45] * lue thinks it's logical to include IrRat when creating Rat

[00:45] <colomon> there is no way to represent irrational numbers in Perl.

[00:46] <colomon> at least, not so far.

[00:46] <colomon> I'm not aware of any computer language that supports them.

[00:46] *** Sarten-X left
[00:46] <lue> What would be a good substitue for all real numbers ℝ then?

[00:46] <colomon> I've toyed with trying to implement them as lazy infinite streams of digits, but that would only be a toy.

[00:47] <snarkyboojum> colomon: that would be very cool tho

[00:47] <colomon> snarkyboojum: yeah, I know, that's why I was playing with the idea.  ;)

[00:47] <snarkyboojum> colomon: I like it! :)

[00:48] <colomon> lue: it totally depends on what you are trying to do with it.

[00:48] <colomon> -Inf..Inf is sort of ℝ

[00:48] <colomon> as a range.

[00:48] <lue> Trying to prove in rakudo that aleph 0 minus 1 equals aleph 0.

[00:49] <lue> ( as PoC code of advanced math, of course :) )

[00:49] <colomon> If we actually had properly implemented irrational numbers, they would be in the range -Inf..Inf.

[00:49] <lue> .oO(If P6 gets any more math-related features, then you could write the #1 programming best-seller "AP Calculus in Perl 6 and More")

[00:50] <lue> rakudo: say (-Inf..Inf)-1=(-Inf..Inf)

[00:50] <lue> rakudo: say (-Inf..Inf)-1==(-Inf..Inf)

[00:50] <p6eval> rakudo c9db3d:  ( no output )

[00:50] <lue> ō.o

[00:50] <colomon> lue:  you probably need an entirely different class-based concept of number system to mess about with different levels of infinity.

[00:51] <snarkyboojum> use Cantor;

[00:52] *** synth joined
[00:52] <cognominal> use Cantor 'hôtel';

[00:52] <colomon> I believe the spec says you are supposed to be able to do math on ranges, but it was implemented last time I checked.

[00:52] <lue> Technically, the categorization of numbers can be seen as a series of augmentations of classes.

[00:53] <lue> rakudo: say (1..3)+1

[00:53] <p6eval> rakudo c9db3d: OUTPUT«4␤»

[00:54] <lue> perl6: say (1..3)+1

[00:54] <p6eval> pugs, rakudo c9db3d: OUTPUT«4␤»

[00:54] <p6eval> ..elf 30307: OUTPUT«2␤»

[00:54] *** Sarten-X joined
[00:54] <lue> that does not seem right.

[00:55] <snarkyboojum> rakudo: say +(1..3)

[00:55] <p6eval> rakudo c9db3d: OUTPUT«3␤»

[00:55] <snarkyboojum> is coerces the range to a num i.e. the no of elems in the range I guess

[00:55] <snarkyboojum> to an Int even

[00:55] <colomon> snarkyboojum has it.

[00:56] <lue> rakudo: say (1...3)+1

[00:56] <p6eval> rakudo c9db3d: OUTPUT«4␤»

[00:56] <snarkyboojum> rakudo: say (1..3) Z+ 1

[00:56] <p6eval> rakudo c9db3d: OUTPUT«2␤»

[00:56] <jnthn> If you want to do those kinds of things, consider junctions.

[00:56] <lue> that's impractical for large ranges :)

[00:56] <jnthn> rakudo: say (all(1..3) + 1).perl

[00:56] <p6eval> rakudo c9db3d: OUTPUT«all(2, 3, 4)␤»

[00:56] <lue> (afaik)

[00:57] <lue> rakudo: say (all(1..3) + 1).WHAT

[00:57] <p6eval> rakudo c9db3d: OUTPUT«Junction()␤»

[00:58] <lue> rakudo: say (all(-Inf..Inf) - 1) == all(-Inf..Inf)

[00:58] <p6eval> rakudo c9db3d:  ( no output )

[00:59] <lue> again, nothing :/

[00:59] <jnthn> rakudo: printf "hmm '%s'", 'wtf';

[00:59] <p6eval> rakudo c9db3d: OUTPUT«hmm 'wtf'»

[00:59] <jnthn> rakudo: printf "hmm %s", 'wtf';

[00:59] <p6eval> rakudo c9db3d: OUTPUT«hmm wtf»

[00:59] <lue> rakudo: say (Inf - 1) == Inf

[00:59] <p6eval> rakudo c9db3d: OUTPUT«1␤»

[00:59] <colomon> snarkyboojum: (1..3) Z+ 1 iust (1, 2, 3) Z+ (1)

[00:59] <colomon> and Z stops when it runs out of elements on either side.

[01:00] <colomon> rakudo: (1..3) >>+>> 1

[01:00] <p6eval> rakudo c9db3d:  ( no output )

[01:00] <colomon> rakudo: say (1..3) >>+>> 1

[01:00] <p6eval> rakudo c9db3d: OUTPUT«234␤»

[01:00] <snarkyboojum> I was going for >>+>> yeah

[01:00] <snarkyboojum> just had to check the spec :)

[01:00] <colomon> or maybe 

[01:01] <snarkyboojum> oh wow - so those hyper operators work

[01:02] *** astrojp left
[01:02] * snarkyboojum still hasn't worked out how to do those double arrow characters on his mac

[01:02] <snarkyboojum> these ones »

[01:02] <snarkyboojum> (without copying and pasting) ;)

[01:03] <colomon> rakudo: say (1..3) Z+ (1, 1 ... *)

[01:03] <lue> if you know how to use the third level, try [third level key]-\ and SHIFT-[third level key]-|

[01:03] <p6eval> rakudo c9db3d: OUTPUT«234␤»

[01:03] <lue> The third level key is either ctrl, option, or Apple

[01:03] <lue> (forget)

[01:03] <colomon> There's no shame in using the Texas version like I did back there.  :)

[01:04] <lue> rakudo: say (1..3)»+»1

[01:04] <p6eval> rakudo c9db3d: OUTPUT«234␤»

[01:04] <colomon> [This section is conjectural, and may be ignored for 6.0.]

[01:04] <colomon> Since use of Range objects in item context is usually non-sensical, a Range object used as an operand for scalar operators will generally attempt to distribute the operator to its endpoints and return another suitably modified Range instead, much like a junction of two items, only with proper interval semantics. 

[01:04] *** meppl joined
[01:05] *** dj_goku left
[01:05] <snarkyboojum> rakudo: say (1..3)>>++

[01:05] <p6eval> rakudo c9db3d: OUTPUT«maximum recursion depth exceeded␤current instr.: 'perl6;Iterable;list' pc 10768 (src/builtins/Role.pir:111)␤»

[01:06] <snarkyboojum> rakudo: say (1,2,3)>>++

[01:06] <p6eval> rakudo c9db3d: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17239 (src/builtins/Junction.pir:399)␤»

[01:06] <snarkyboojum> oops ;)

[01:06] <snarkyboojum> rakudo: my @a = (1,2,3); say @a>>++

[01:06] <p6eval> rakudo c9db3d: OUTPUT«123␤»

[01:06] <colomon> rakudo: use Test; ok((!(1 & 2 | 3) < 2), "ditto");

[01:06] <p6eval> rakudo c9db3d: OUTPUT«ok 1 - ditto␤»

[01:06] <snarkyboojum> rakudo: my @a = (1,2,3); @a>>++; say ~@a

[01:06] <p6eval> rakudo c9db3d: OUTPUT«2 3 4␤»

[01:07] <colomon> doesn't work after my latest local real changes.

[01:07] <lue> I heard there was a fourth sigil (the first three are $,@,%).

[01:07] <jnthn> ++ modifies in place.

[01:07] <snarkyboojum> aye

[01:07] <jnthn> &

[01:07] <colomon> rakudo: my @a = (1,2,3); ++<<@a; say ~@a

[01:07] <p6eval> rakudo c9db3d: OUTPUT«2 3 4␤»

[01:08] <colomon> prefix hyper ops, \o/

[01:08] <colomon> jnthn: that test: (!(1 & 2 | 3) < 2)

[01:08] <snarkyboojum> definitely TMTOWTDI :)

[01:08] <colomon> what the heck is it supposed to be doing?

[01:08] <colomon> is < tighter than !?

[01:09] <snarkyboojum> rakudo: my @a = (1,2,3); say ++<<@a;

[01:09] <p6eval> rakudo c9db3d: OUTPUT«234␤»

[01:09] <snarkyboojum> :)

[01:09] <takadonet> rakudo: say 'a'..'f'

[01:09] <p6eval> rakudo c9db3d: OUTPUT«abcdef␤»

[01:10] <takadonet> rakudo: say 'a'..'bf'..'n'

[01:10] <p6eval> rakudo c9db3d: OUTPUT«Method 'succ' not found for invocant of class 'Range'␤current instr.: '!dispatch_.=' pc 440 (src/glue/dispatch.pir:118)␤»

[01:10] <lue> rakudo: say (!(1 & 2 | 3) < 2)

[01:10] <p6eval> rakudo c9db3d: OUTPUT«1␤»

[01:11] <colomon> rakudo: say (1 & 2 | 3) < 2

[01:11] <p6eval> rakudo c9db3d: OUTPUT«any(all(Bool::True, Bool::False), Bool::False)␤»

[01:11] <jnthn> colomon: That looks...weird.

[01:11] <jnthn> colomon: I suspect the ! should be outside the opening (

[01:11] <takadonet> rakudo: say 'a'..'b' 'f'..'n'

[01:11] <p6eval> rakudo c9db3d: OUTPUT«Confused at line 11, near "say 'a'..'"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[01:11] <colomon> rakudo: say 'a'..'b', 'f'..'n'

[01:12] <p6eval> rakudo c9db3d: OUTPUT«abfghijklmn␤»

[01:12] <takadonet> thanks colomon

[01:13] <colomon> jnthn: this is in precedence.t

[01:13] *** TiMBuS left
[01:14] <lue> quick, do you think natural numbers include the number 0?

[01:14] <snarkyboojum> rakudo: say 'a'^..'d'

[01:14] <p6eval> rakudo c9db3d: OUTPUT«bcd␤»

[01:14] <colomon> jnthn: if I move the ! to outside the opening (, the test passes.  but I'm not comfortable doing that because I don't understand what the test is trying to test.

[01:14] <snarkyboojum> lue: no

[01:14] <colomon> lue: first instinct yes, second .... um... no?

[01:14] <lue> I ask because one argument say it is NOT is this: "Counting to three is saying 'one, two, three', not 'zero, one, two'"

[01:15] <lue> With that argument, a programmer would say yes :)

[01:15] <snarkyboojum> lue: yeah, natural numbers are traditionally called 'counting numbers', so 0 isn't included :)

[01:15] <snarkyboojum> but that's the traditional definition :)

[01:16] <lue> a programmer's counting numbers includes 0 :) I say it depends on what you do. (so for me it's a yes)

[01:16] <snarkyboojum> Perl 6 isn't exactly traditional is it? 

[01:17] <colomon> ./perl6

[01:17] <snarkyboojum> N = Z+ :)

[01:18] <snarkyboojum> lue: ah, but you don't count with 0, you index from it ;)

[01:18] <lue> it involves counting when you access the array! :)

[01:19] <snarkyboojum> lue: but you certainly don't count, zero items ;)

[01:20] <colomon> syntax.t has max(1, 2, 3), but that's not a legal form, so far as I know?

[01:20] <lue> It feels like I count from zero quite often, actually :)

[01:20] <lue> rakudo: max(1,2,3)

[01:20] <p6eval> rakudo c9db3d: OUTPUT«invoke() not implemented in class 'Integer'␤current instr.: 'perl6;Any;_block4814' pc 341098 (src/gen/core.pir:27698)␤»

[01:20] <lue> std: max(1, 2, 3)

[01:20] <p6eval> std 30307: OUTPUT«ok 00:01 109m␤»

[01:21] <colomon> oh, I see.

[01:21] <colomon>     multi sub max($a, $b, $c) {return 9}

[01:21] <colomon> that doesn't seem to be working any more.

[01:21] <colomon> (in my local version, anyway)

[01:22] <colomon> rakudo: multi sub max($a, $b, $c) {return 9}; say max(1, 2, 3)

[01:22] <p6eval> rakudo c9db3d: OUTPUT«get_attr_str() not implemented in class 'Sub'␤current instr.: 'perl6;Code;signature' pc -1 ((unknown file):-1)␤»

[01:22] *** astrojp joined
[01:22] <lue> ō.o

[01:22] *** eternaleye joined
[01:22] <snarkyboojum> lue: people would certainly be confused if you asked for zero coffee in the morning :)

[01:23] <jnthn> colomon: oh, hmm

[01:23] <colomon> does syntax.t work for you?

[01:23] <jnthn> colomon: It appears...not :-/

[01:23] <colomon> t/spec/S06-multi/syntax.t

[01:23] <colomon> I mean.

[01:23] <jnthn> colomon: That looks bizzarely like something htat may be my fault.

[01:23] <jnthn> Yeah, I know the one you mean.

[01:23] <lue> well of course. That's why the 1,2,3 set of "natural numbers" are mapped to the 0,1,2 set of natural numbers :)

[01:23] <jnthn> Yes, I think my earlier patch is to blame. Sorry.

[01:24] <lue> Point is: I think 0 is a natural number.

[01:24] <colomon> jnthn: no worries, just trying to get my latest Real work tested and in.  :)

[01:24] <lue> Who here knows of a graphical hierarchy of number systems they've found? I'm looking...

[01:28] <colomon> rakudo: say (1 & 2 | 3) < 2

[01:28] <p6eval> rakudo c9db3d: OUTPUT«any(all(Bool::True, Bool::False), Bool::False)␤»

[01:28] <colomon> rakudo: say !(1 & 2 | 3) < 2

[01:28] <p6eval> rakudo c9db3d: OUTPUT«1␤»

[01:29] <colomon> rakudo: say (!(1 & 2 | 3)) < 2

[01:29] <p6eval> rakudo c9db3d: OUTPUT«1␤»

[01:30] <colomon> rakudo: say ?((1 & 2 | 3) < 2)

[01:30] <p6eval> rakudo c9db3d: OUTPUT«0␤»

[01:30] <jnthn> colomon: Yeah, I kinda...refactored the world...earlier today. :-)

[01:30] <colomon> jnthn: I got them impression.  jnthn++

[01:30] <colomon> I've kind of slowly starting doing the same with the math world.  ;)

[01:31] <jnthn> :-)

[01:31] <jnthn> I've got more to go in that area.

[01:31] <jnthn> I guess I did the first 80% and the second 80% is to come. :-)

[01:31] <lue> jnthn: is that why the whole planet just felt...happier, today?

[01:31] <jnthn> Well, I'd expect things to be found in a different way... :-)

[01:34] <diakopter> rakudo: my $a = 2;  say 2 - $a += 4;

[01:34] <p6eval> rakudo c9db3d: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17239 (src/builtins/Junction.pir:399)␤»

[01:34] <diakopter> I thought += was tighter than -

[01:35] <lue> I want to find a detailed graphic showing how all the number systems fit together (a "dependency tree" you might say), so I could toy with the possibility of a class-based way of dealing with numbers in P6

[01:36] <pugssvn> r30308 | colomon++ | [t/spec] Fudge precedence.t, add new real-bridge.t test file. 

[01:36] *** wolf2k_ubuntu joined
[01:36] <lue> i.e. class natural(){} class integers(){augments natural} class rational() {augments integers} and so on

[01:37] <sorear> colomon: Nobody implements them natively because they have nasty properties (most importantly, equality is undecidable, and while ordered, x > x diverges), however there are a dozen or three computable real libraries

[01:38] <sorear> colomon: TimToady has been talking about surreals in Perl...

[01:38] <colomon> ah, yes, hadn't considered equality.

[01:39] <colomon> you'd have to do it approximate equality....

[01:39] <cognominal> one Conway or another has got to be involved

[01:39] <lue> I love all the weird number systems. Surreal, superreal, etc. I just would like to see the dependency tree for these number system.

[01:40] <diakopter> lue: I don't think they'd augment

[01:40] <diakopter> I think they'd subset from the larger sets

[01:40] <dalek> rakudo: c638c55 | (Solomon Foster)++ | src/core/Real.pm:

[01:40] <dalek> rakudo: Start adding operators for Real and Num.

[01:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c638c5576207884111370f2cab3004f553b15d56

[01:40] <dalek> rakudo: 6ce9873 | (Solomon Foster)++ | t/spectest.data:

[01:40] <dalek> rakudo: Add real-bridge.t to the tests.

[01:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6ce9873b620613fc5b5da3ede7e2c490cafec6c3

[01:40] <colomon> cognominal: around here, the most likely Conway to be involved is Brian.

[01:40] <colomon> ;)

[01:40] <lue> depends on how you write the handling of numbers :)

[01:41] <lue> colomon: how are you reinventing the math world? I'm interested

[01:43] <colomon> lue: http://justrakudoit.wordpress.com/2010/03/30/numeric-plan-of-attack/

[01:44] <sorear> colomon: I'd really like to see an implementation of the algebraic numbers.  They can do a lot of the cool things computable reals can, but you can do ordered field operations on them without running into Rice hell

[01:44] <sorear> otoh - galois theory makes my head explode

[01:45] *** alester joined
[01:45] <colomon> sorear: it's been nearly 20 years since I thought about any of that.  :)

[01:47] <lue> I think a dependency-tree type system for different number systems (much like with linux package managers) is at least an idea worth trying out (if only as a module to start out)

[01:47] <lue> i.e. real numbers depend on rational and irrational

[01:47] *** xabbu42 left
[01:48] <colomon> lue: in particular, today I set things up so when you define a new Real type, you automatically get some basic operators compatible with any other Real type.

[01:49] <colomon> The new real-bridge.t is the start of example tests.

[01:49] <Coke-san> http://graphjam.com/2010/04/03/funny-graphs-practical-colon/

[01:51] <lue> :)

[01:51] <colomon> sorear: (quick wikipedia check)  ooo, algebraic numbers are interesting.

[01:51] <colomon> I can't recall ever knowing there was a countable subset of the irrationals...

[01:52] *** astrojp left
[01:54] <cognominal> Coke-san:  you could make that a corollary of the first Law of language redesign if you think smiley as a language redesign

[01:55] <sorear> Zorn's lemma implies the existance of a countably infinite subset of every infinite list

[01:55] *** Psyche^ joined
[01:56] <sorear> I have a feeling, though, that this is much weaker than the AoC

[01:58] <takadonet> rakudo: for 0..2 Z 1..3 -> $x,$y { say "$x $y" } 

[01:58] <p6eval> rakudo c9db3d: OUTPUT«0 1␤1 2␤2 3␤»

[01:59] *** Sarten-X left
[02:00] *** Patterner left
[02:00] *** Psyche^ is now known as Patterner

[02:00] <sorear> according to wikipedia, "every infinite set has a countably infinite subset" is independant of ZF and strictly weaker than even the axiom of countable choice

[02:01] <lue> .oO(and to think this discussion started because I wanted to be able to define aleph)

[02:01] <colomon> :)

[02:02] <colomon> off to bed...

[02:03] <jnthn> night, colomon 

[02:03] <lue> good night o/

[02:04] <lue> and now, back to a P6-created game where the game is described by a text file (yes, a parser)

[02:09] <sorear> Er, I had Zorn's lemma mixed up with the well-ordering theorem

[02:10] <dalek> rakudo: cb2a2d8 | jonathan++ | src/ops/perl6.ops:

[02:10] <dalek> rakudo: Fix throwing of exceptions when binding fails so we don't end up treating hash parameters as formats.

[02:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cb2a2d83ee82ea292b3125d7c783b57676705667

[02:10] <dalek> rakudo: 4d1b1c7 | jonathan++ | src/binder/bind.c:

[02:10] <dalek> rakudo: Awesomize errors for sub-signatures, to mention that the binding error was in a sub-signature and also, if it has one, the name of the variable that captured the entire thing that sub-signature is being bound against.

[02:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4d1b1c76b18d4f32e80b7329b883fe091fdbebd4

[02:10] <jnthn> std: sub foo (:$) { }

[02:10] <p6eval> std 30308: OUTPUT«ok 00:01 109m␤»

[02:34] <sorear> jnthn: Why does blizkost have gen-parrot.pl and related trappings?  Surely if you don't have Parrot, you should just use Perl5?

[02:36] * sorear attempts to remove the use of recursive make

[02:51] <sorear> jnthn: What is staging for

[02:51] <sorear> ?

[03:06] <lue> rakudo: my $a="module"; use $a.perl

[03:06] <p6eval> rakudo 4d1b1c: OUTPUT«Could not find sub &use␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[03:06] <lue> rakudo: my $a="module"; use perl

[03:06] <p6eval> rakudo 4d1b1c: OUTPUT«Unable to find module 'perl'.␤current instr.: 'perl6;Perl6;Module;Loader;need' pc 34766 (src/gen/role_pm.pir:807)␤»

[03:07] <lue> could I load a module from input given by the user (they give the name of a module, and then I use it)?

[03:07] <lue> std: my $a="module"; use $a.perl

[03:07] <p6eval> std 30308: OUTPUT«Undeclared routine:␤   'use' used at line 1␤ok 00:01 109m␤»

[03:09] <lue> rakudo: use lib

[03:09] <p6eval> rakudo 4d1b1c: OUTPUT«Unable to find module 'lib'.␤current instr.: 'perl6;Perl6;Module;Loader;need' pc 34766 (src/gen/role_pm.pir:807)␤»

[03:10] <Coke-san> NQP question: http://nopaste.snit.ch/20175

[03:11] <Coke-san> sorear: (don't have parrot) ... doesn't blizkost /require/ parrot?

[03:11] <Coke-san> blizkost?

[03:11] <Coke-san> is there an infobot in here?

[03:12] *** quester joined
[03:19] <Coke-san> (putting the class definition in an INIT doesn't seem to help, presuming that my problem is that the INIT is trying to get the class before it's ready.)

[03:20] *** molaf joined
[03:24] <takadonet> rakudo: say 'ab'..'e'

[03:24] <p6eval> rakudo 4d1b1c: OUTPUT«␤»

[03:30] <ash_> rakudo: my $a = 5; $a.HOW.add_method($a, 'fo', method { say 'new_method'; }); $a.'fo'();

[03:30] <p6eval> rakudo 4d1b1c: OUTPUT«Method 'fo' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[03:30] <ash_> hmmm thats bad, Integer is a leak from parrot

[03:30] <ash_> rakudo: class A { }; my $a = A.new; $a.HOW.add_method($a, 'fo', method { say 'new_method'; }); $a.'fo'();

[03:30] <p6eval> rakudo 4d1b1c: OUTPUT«new_method␤»

[03:31] <ash_> works fine with custom classes, seems to be a leaky parrot issue 

[03:31] *** meppel joined
[03:32] *** meppl left
[03:32] *** meppel is now known as meppl

[03:33] <sorear> Coke-san: Hi

[03:33] <Coke-san> ~~

[03:34] <sorear> Coke-san: Look carefully at the backtrace.

[03:34] <sorear> Are all the functions loaded in the right HLLs?

[03:35] <sorear> Coke-san: yes, blizkost requires Parrot.  But it has a built-in Parrot downloader/installer

[03:35] <sorear> which doesn't make much sense to me

[03:35] <Coke-san> sorear: it's probably a straight copy from rakudo's

[03:36] <Coke-san> and since you need parrot, giving the developer a hand to get it seems reasonable.

[03:36] <sorear> it makes no sense to install blizkost as your first Parrot library though

[03:37] <sorear> if your only Parrot library is blizkost, you might as well just use perl directly

[03:37] <Coke-san> sorear: first != only

[03:38] <Coke-san> also, blizkost may require a newer parrot than you have.

[03:39] <Coke-san> regarding my error - there is no HLL before or after the diff in the generated PIR.

[03:40] *** dj_goku joined
[03:43] <Coke-san> ok. the class definition was a noop. adding a literal pir::noop in the class definition causes it to actually create the subclass, but then it complains about using the core parrot type. Getting closer.

[03:43] *** ash_ left
[03:48] <sorear> Coke-san: I meant HLL in the backtrace

[03:49] <sorear> oh

[03:49] <sorear> Coke-san: try changing pir::subclass__ps to pir::subclass__vps

[03:49] <sorear> subclass__ps takes 1 string argument and returns a PMC

[03:50] <Coke-san> sorear: .. that code /works/

[03:50] <Coke-san> it's the nqp syntax of "class Foo is Bar" that is failing.

[03:50] <sorear> oh

[03:51] <Coke-san> even better, subclassing parrot's Hash seems to work; it's the ResizablePMCArray that's dying.

[03:52] <sorear> I wish I understood half of this

[03:59] <Coke-san> zzz

[04:02] <lue> good night

[04:11] *** meppl left
[04:18] *** JimmyZ joined
[04:19] *** wolf2k_ubuntu left
[04:23] *** Chillance left
[04:32] <quester> rakudo: our sub infix:<q> {$^a, $^b}; say <a c> «q» <b d>;

[04:32] <p6eval> rakudo 4d1b1c: OUTPUT«abcd␤»

[04:32] <quester> rakudo: sub infix:<q> {$^a, $^b}; say <a c> «q» <b d>;

[04:32] <p6eval> rakudo 4d1b1c: OUTPUT«Could not find sub &infix:<q>␤current instr.: '' pc -1 ((unknown file):-1)␤»

[04:33] <quester> ... does anyone know off the top of their head why "our" is needed here?  It seems odd to me.

[04:36] * quester was trying to define ö so that »ö« would be a metaop and got sidetracked

[04:37] *** arthur-_ left
[04:45] *** nihiliad left
[04:51] *** quester is now known as quester--away--

[05:29] *** quester--away-- left
[05:39] *** gfx joined
[05:48] *** quester--away-- joined
[05:49] *** quester--away-- is now known as quester_

[05:58] <cognominal> rakudo:   say %hash<a b c>.perl

[05:58] <p6eval> rakudo 4d1b1c: OUTPUT«Symbol '%hash' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[05:58] <cognominal> rakudo:    %hash = (:a<A>, :b<B>);; say %hash<a b c>.perl

[05:58] <p6eval> rakudo 4d1b1c: OUTPUT«Symbol '%hash' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[05:58] <cognominal> rakudo:   my  %hash = (:a<A>, :b<B>);; say %hash<a b c>.perl

[05:58] <p6eval> rakudo 4d1b1c: OUTPUT«Proxy.new()␤»

[05:58] <cognominal> rakudo:   my  %hash = (:a<A>, :b<B>);; say %hash<a b c>

[05:58] <p6eval> rakudo 4d1b1c: OUTPUT«␤»

[06:00] *** quester_ left
[06:11] *** JimmyZ left
[06:15] *** mberends joined
[06:31] *** justatheory left
[07:05] *** alester left
[07:17] *** cyberpass joined
[07:23] *** espadrine left
[07:29] *** ewilhelm joined
[07:30] *** cyberpass left
[07:33] *** snarkyboojum_ joined
[07:34] *** snarkyboojum left
[07:34] *** ewilhelm left
[07:34] *** snarkyboojum joined
[07:35] *** ewilhelm joined
[07:37] *** snarkyboojum_ left
[07:42] *** proller joined
[07:43] *** M_o_C joined
[07:44] *** M_o_C_ joined
[07:44] *** M_o_C_ left
[07:53] *** Su-Shee joined
[07:53] <Su-Shee> good morning

[07:53] <sorear> hello

[07:55] <sorear> fperrad got back to me.  5 down, 1 to go

[08:04] <moritz_> good morning

[08:06] <sorear> moritz_!

[08:06] <sorear> I've been waiting for you

[08:07] <sorear> hello moritz

[08:08] <moritz_> sorear: just replying to your mail

[08:09] <sorear> excellent, thank you

[08:09] <moritz_> I also don't think I contributed enought to blizkost so that my opinion really counts :-)

[08:25] *** xabbu42 joined
[08:33] *** pmurias joined
[08:41] *** gfx left
[08:42] *** ruoso left
[08:45] <Su-Shee> the example in "user defined array indexing" which says :Jan(1) - does that mean that the @months index starts with 1 instead of 0? 

[08:45] <moritz_> where? S09?

[08:45] <Su-Shee> yes

[08:46] <moritz_> I think it means that only the enum values of Month are valid indexes in the first dimension

[08:46] <moritz_> so yes, starts with 1 and ends with 12

[08:56] *** ruoso joined
[08:58] <Su-Shee> alpha: my $vitamin = 'c'; my @healthy = <<apple $vitamin>>; @healthy.say;

[08:58] <p6eval> alpha 30e0ed: OUTPUT«applec␤»

[09:00] *** envi^home joined
[09:00] * moritz_ has a prototype command line script that uses WWW::Mechanize to add comitters to the pugs repo

[09:00] <sorear> hugme is cooler.

[09:01] <moritz_> sorear: the plan is to incorporate it into hugme

[09:01] <moritz_> sorear: but first I need to make it non-blocking

[09:01] <moritz_> because it takes some time, and hugme is POE based

[09:01] <moritz_> so far hugme only works with github stuff

[09:02] <sorear> moritz++ I wanted to add the NQP tests to the harness but couldn't see how

[09:02] <sorear> moritz_: system("... &")?

[09:03] <moritz_> sorear: then I don't get any feedback if it was successful

[09:03] <sorear> What could possibly go wrong?

[09:03] <moritz_> lots of things

[09:04] <moritz_> for one commitbit is sometimes down

[09:04] <mberends> phenny, tell colomon re: S32::Numeric relocations, it would be most comforting if roots, which returns Complex, was also a method of Complex. Hopefully that is also implementable.

[09:04] <phenny> mberends: I'll pass that on when colomon is around.

[09:04] <sorear> what is 'commitbit'?

[09:04] <moritz_> sorear: the web frontend used to add committers

[09:05] <moritz_> mberends: then you can't easily calculate the complex roots of real numbers

[09:08] <mberends> moritz_: can a real number be coerced to Complex for roots() ?

[09:08] <moritz_> probably, yes

[09:08] <moritz_> 4.Complex.roots(5)

[09:08] <moritz_> looks sufficiently nice :-)

[09:13] * mberends likes that too

[09:18] *** mikehh left
[09:19] <cognominal> rakudo:  my ($a, $b) = 1, 2;    (1 ?? $a !! $b) = 3;  say "$a$b"

[09:19] <p6eval> rakudo 4d1b1c: OUTPUT«32␤»

[09:20] <cognominal> I knew it  :)

[09:23] <cognominal> rakudo: my $a is readonly := 0;

[09:23] <p6eval> rakudo 4d1b1c: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Code $block, Any $arg?, Any :export($export!)␤:(Mu $child, Mu $parent)␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:23] *** agentzh joined
[09:23] <cognominal> rakudo: my $a is readonly

[09:23] <p6eval> rakudo 4d1b1c: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Code $block, Any $arg?, Any :export($export!)␤:(Mu $child, Mu $parent)␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:23] <moritz_> sorear: after looking at PoCo::Client::HTTP in more detail I think I will really use system("script &") :/

[09:24] <cognominal> Well, I wanted to be able to bind a read-only variable to a constant but apparently readonly for variable is not (yet) supported.

[09:24] <moritz_> right

[09:24] <moritz_> it's only supported for parameters

[09:25] <moritz_> rakudo: sub a($x) { say $x); a(5); # binds a read-only variable to a constant

[09:25] <p6eval> rakudo 4d1b1c: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[09:25] <cognominal> meaning it will not be supported for mere variable

[09:25] <moritz_> rakudo: sub a($x) { say $x}; a(5);

[09:25] <p6eval> rakudo 4d1b1c: OUTPUT«5␤»

[09:25] <moritz_> it's just not yet implemented

[09:29] <cognominal> now suppose I bind a rw variable to a constant using :=     It should blow on me if I try to modify the variable value.

[09:29] <moritz_> aye

[09:35] *** mikehh joined
[09:53] *** espadrine joined
[10:05] <pugssvn> r30309 | moritz++ | [t/spec] test that you can call a sub of the same name as the current method (RT #74014) 

[10:06] *** payload joined
[10:09] <cognominal> rakudo: say !0

[10:09] <p6eval> rakudo 4d1b1c: OUTPUT«1␤»

[10:10] <cognominal>  rakudo:  say &prefix:<!>(0) 

[10:10] <p6eval> rakudo 4d1b1c: OUTPUT«1␤»

[10:10] <cognominal>  rakudo:  say &prefix:<!>(False) 

[10:10] <p6eval> rakudo 4d1b1c: OUTPUT«1␤»

[10:10] <cognominal> rakudo: say False.WHAT

[10:10] <p6eval> rakudo 4d1b1c: OUTPUT«Bool()␤»

[10:11] <cognominal> rakudo: say (!0).perl

[10:11] <p6eval> rakudo 4d1b1c: OUTPUT«Bool::True␤»

[10:12] *** hanekomu joined
[10:15] *** testme joined
[10:16] *** testme left
[10:16] <cognominal>  rakudo:  say &prefix:<!>.perl

[10:16] <p6eval> rakudo 4d1b1c: OUTPUT«{ ... }␤»

[10:19] *** hugme left
[10:21] *** hugme joined
[10:21] <moritz_> hugme: add foo to pugs

[10:21] <hugme> moritz_: usage: Add <email>,<nickname> to pugs

[10:21] *** moritz_ sets mode: +v hugme

[10:21] <moritz_> hugme: add [email@hidden.address] to pugs

[10:21] <hugme> moritz_: usage: Add <email>,<nickname> to pugs

[10:21] <moritz_> :/

[10:22] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo[1:delete]; @foo.say

[10:22] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "[1:delete]"␤in Main (file <unknown>, line <unknown>)␤»

[10:22] <Su-Shee> yeah, alpha, I'm confused too. 

[10:22] <moritz_> adverbs go outside the subscripts, but it was never implemented in rakudo

[10:22] <moritz_> std: my @foo = <foo bar baz flubb>; @foo[1:delete]; @foo.say

[10:22] <p6eval> std 30308: OUTPUT«ok 00:01 109m␤»

[10:22] <moritz_> std: my @foo = <foo bar baz flubb>; @foo[1]:delete; @foo.say

[10:23] <p6eval> std 30308: OUTPUT«ok 00:01 107m␤»

[10:23] *** hugme left
[10:23] <Su-Shee> then I'll ignore it. 

[10:24] *** hugme joined
[10:24] <moritz_> hugme: add [email@hidden.address] to pugs

[10:24] <hugme> moritz_: usage: Add <email>,<nickname> to pugs

[10:24] *** hugme left
[10:24] *** hugme joined
[10:24] <moritz_> hugme: add [email@hidden.address] to pugs

[10:24] * hugme hugs moritz_. If all goes well you'll get an email soon

[10:25] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo[1].delete; @foo.say

[10:25] <p6eval> alpha 30e0ed: OUTPUT«Method 'delete' not found for invocant of class 'Str'␤in Main (file src/gen_setting.pm, line 324)␤»

[10:25] <moritz_> alpha: my @foo = <foo bar baz flubb>; @foo.delete(1); say @foo

[10:25] <p6eval> alpha 30e0ed: OUTPUT«fooUse of uninitialized value␤bazflubb␤»

[10:26] <Su-Shee> that was the next one I've wanted to try. ;)

[10:26] <moritz_> :-)

[10:27] <Su-Shee> delete leaves the element empty and doesn't change the index, does it?

[10:29] <moritz_> right

[10:29] <moritz_> I don't know if it shortens the array if the last item is deleted

[10:29] <cognominal> say +"toto"

[10:29] <cognominal> oops

[10:29] <cognominal> rakudo: say +"toto"

[10:29] <p6eval> rakudo 4d1b1c: OUTPUT«0␤»

[10:30] *** Intensity joined
[10:30] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.push(<blubb>); @foo.say

[10:30] <p6eval> alpha 30e0ed: OUTPUT«foobarbazflubbblubb␤»

[10:34] *** ruoso left
[10:35] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.unshift(<blubb>); @foo.say

[10:35] <p6eval> alpha 30e0ed: OUTPUT«blubbfoobarbazflubb␤»

[10:37] *** payload left
[10:41] *** rekhajos joined
[10:45] *** kaare joined
[10:46] *** kaare is now known as Guest60427

[10:47] <cognominal> rakudo:   say ('a', 'b').WHAT

[10:47] <p6eval> rakudo 4d1b1c: OUTPUT«Parcel()␤»

[10:47] <cognominal> I thought Parcel were mostly invisible at the user level?

[10:47] *** M_o_C left
[10:48] *** M_o_C joined
[10:50] <moritz_> I don't know if they should be completely invisible, but I'm sure Rakudo exposes them far too often

[10:52] <cognominal> Writing an article makes me discover a lot of things

[10:53] <cognominal> There is no such things as teaching to learn.

[10:53] <cognominal> hum, I am not sure that's correct English

[10:56] *** Guest60427 left
[10:58] *** agentzh left
[11:03] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.delete(1, 3); say @foo

[11:03] <p6eval> alpha 30e0ed: OUTPUT«fooUse of uninitialized value␤baz␤»

[11:03] <Su-Shee> oha. 

[11:03] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.delete(1..3); say @foo

[11:03] <p6eval> alpha 30e0ed: OUTPUT«foo␤»

[11:03] *** clintongormley joined
[11:04] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.delete(0..2); say @foo

[11:04] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤Use of uninitialized value␤Use of uninitialized value␤flubb␤»

[11:05] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.shift(0..2); say @foo

[11:05] <p6eval> alpha 30e0ed: OUTPUT«No applicable candidates found to dispatch to for 'shift'␤in Main (file <unknown>, line <unknown>)␤»

[11:05] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo[0..2].shift; say @foo

[11:05] <p6eval> alpha 30e0ed: OUTPUT«foobarbazflubb␤»

[11:06] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; my @new = @foo[0..2].shift; say @new

[11:06] <p6eval> alpha 30e0ed: OUTPUT«foo␤»

[11:28] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; my @new = [||] @foo.delete(0..2); say @new

[11:28] <p6eval> alpha 30e0ed: OUTPUT«foo␤»

[11:29] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.delete(0..2); my @new = [||] @foo; say @new

[11:29] <p6eval> alpha 30e0ed: OUTPUT«flubb␤»

[11:29] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; @foo.delete(0..1); my @new = [||] @foo; say @new

[11:29] <p6eval> alpha 30e0ed: OUTPUT«baz␤»

[11:32] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; my @obs = @foo.delete(0..1); my @rest = @obs ~~ @foo; say @rest

[11:32] <p6eval> alpha 30e0ed: OUTPUT«0␤»

[11:33] <moritz_> rakudo: my @a = <foo bar baz>; @a.delete(1); say @a[1] ~~ EMPTY

[11:33] <p6eval> rakudo 4d1b1c: OUTPUT«0␤»

[11:34] <Su-Shee> I'm trying to get a list with obsolete elements really removed. ;) 

[11:34] <Su-Shee> and not just empty. 

[11:35] <moritz_> then @foo.grep({.defined}) or so

[11:35] <moritz_> or maybe with with splice instead of delete

[11:36] <Su-Shee> I was hoping for something simple and obvious. :/ 

[11:38] <Su-Shee> alpha: my @foo = <foo bar baz flubb>; my @obs = @foo.delete(0..1); my @rest = all(@obs) ~~ all(@foo); say @rest

[11:38] <p6eval> alpha 30e0ed: OUTPUT«all(Bool::False)␤»

[11:38] <Su-Shee> oeh :) 

[11:40] *** rekhajos left
[11:41] <moritz_> smart matching will nearly always return True or False

[11:41] <moritz_> the only exception I know if is matching a regex, which returns a Match object

[11:45] <Su-Shee> that can't be that difficult. how do I do a simple union/intersection of two lists?

[11:46] <moritz_> with hashes

[11:46] <jnthn> o/

[11:46] <moritz_> or with grep and any()

[11:46] <moritz_> lolitsjnthn!

[11:46] <moritz_> jnthn: I get two fails in t/spec/S06-multi/syntax.t - a regression?

[11:47] *** M_o_C left
[11:47] <jnthn> moritz_: It appears my setting work yesterday did it.

[11:48] *** meppl joined
[11:50] <jnthn> moritz_: Will try and fix tha tup today.

[11:51] <moritz_> rakudo: class A { method x { say %_.perl } }; A.new.x(:b)

[11:51] <p6eval> rakudo 4d1b1c: OUTPUT«Placeholder variables cannot be used in a method at line 11, near "}; A.new.x"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[11:51] <moritz_> rakudo: class A { method x(*%_) { say %_.perl } }; A.new.x(:b)

[11:52] <p6eval> rakudo 4d1b1c: OUTPUT«{"b" => Bool::True}␤»

[11:52] <moritz_> jnthn: afaict both should work, since methods always have implicit *%_

[11:52] *** dzikasosna joined
[11:53] <jnthn> moritz_: I suspect so, yeah.

[11:53] <pugssvn> r30310 | moritz++ | [t/spec] test usage of %_ in methods, RT #73892 

[11:54] * jnthn is still not completely awake yet :-)

[11:54] <moritz_> jnthn: no hurry :-)

[12:01] * jnthn om nom noms breakfast

[12:02] <Su-Shee> meh. that's all too 5ish. :/

[12:04] <moritz_> rakudo: my @a = <a b c>; my @b = <b c d>; my @inter = @a.grep(any(@b)); say @inter.perl

[12:04] <p6eval> rakudo 4d1b1c: OUTPUT«[any((), (), ())]␤»

[12:05] <moritz_> ouch

[12:05] <moritz_> rakudo: my @a = <a b c>; my @b = <b c d>; my @inter = @a.grep({ $_ eq any(@b) }); say @inter.perl

[12:05] <p6eval> rakudo 4d1b1c: OUTPUT«["b", "c"]␤»

[12:05] <colomon> o/

[12:05] <phenny> colomon: 09:04Z <mberends> tell colomon re: S32::Numeric relocations, it would be most comforting if roots, which returns Complex, was also a method of Complex. Hopefully that is also implementable.

[12:05] <moritz_> afaict those two should be the same

[12:06] <colomon> grep just does a smartmatch with it's filter argument.

[12:06] <moritz_> yes

[12:07] <moritz_> so smartmatching against any(@b) should the same as { $_ eq any(@b) }, right?

[12:07] <colomon> rakudo: say 'a' ~~ any(<b c d>)

[12:07] <p6eval> rakudo 4d1b1c: OUTPUT«0␤»

[12:07] <colomon> rakudo: say 'b' ~~ any(<b c d>)

[12:07] <p6eval> rakudo 4d1b1c: OUTPUT«1␤»

[12:08] <colomon> looks like somehow a grep bug and not a smartmatch bug?

[12:08] <jnthn> phenny tell quester the need for our on that of is a Rakudo bug...working on it, but it's teh hard. :-/

[12:08] <moritz_> colomon: aye

[12:09] <moritz_> heh

[12:09] *** jhuni left
[12:09] <moritz_> 31:    our multi method grep($test) {

[12:09] <moritz_> that should be Mu $test

[12:09] <colomon> mberends: there should be a roots.Complex because there is a version of roots which takes a Complex number.  IMO returning  Complex number doesn't enter into it.

[12:10] <colomon> moritz_++

[12:10] <colomon> moritz_: can you fix that and make sure there's a test for this case in grep.t?

[12:10] <moritz_> colomon: working on it

[12:10] <moritz_> (and on RT #74056 at the same time :)

[12:11] <colomon> \o/

[12:11] <moritz_> actually I think I'm done with the latter, now just need to spectest

[12:19] <moritz_> heh, there was actually a test in undef.t that didn't pass because grep in boolean context would always return 1

[12:19] *** snarkyboojum left
[12:24] <moritz_> rakudo: sub foo(%h($left)) {}; foo({ no => "left key" })

[12:24] <p6eval> rakudo 4d1b1c: OUTPUT«Not enough positional parameters passed; got 0 but expected 1 in sub-signature of parameter %h␤current instr.: 'foo' pc 213 (EVAL_1:82)␤»

[12:24] *** dzikasosna left
[12:25] <jnthn> moritz_: That's correct too.

[12:26] <jnthn> moritz_: $left is a positional, it just happens to work because of named to positional bindings.

[12:26] *** ruoso joined
[12:40] * moritz_ thought so

[12:40] <pugssvn> r30311 | moritz++ | [t/spec] test Junction matchers with .grep 

[12:40] <pugssvn> r30312 | moritz++ | [t/spec] unfudge passing TODO tests for rakudo 

[12:40] <dalek> rakudo: ebb9f47 | moritz++ | src/builtins/Iterator.pir:

[12:40] <dalek> rakudo: implement Iterator.Bool, so that "if @things.grep($tester)" works properly. Fixes RT #74056

[12:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ebb9f475c10a137ac0dc86b020db78cb402f6b00

[12:40] <dalek> rakudo: 7348b9a | moritz++ | src/c (2 files):

[12:40] <dalek> rakudo: List.grep should take a Mu, so that Junction matchers DWYM

[12:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7348b9ab234a5c88eea1df6b906b1564a69ecfef

[12:49] *** Coke-san is now known as CokeBot9000

[12:49] *** Chillance joined
[12:49] <pugssvn> r30313 | moritz++ | [t/spec] test that the return value from .grep Boolifies sensibly (RT #74056) 

[12:58] *** snarkyboojum joined
[13:05] *** am0c joined
[13:06] <takadonet> morning all

[13:06] <jnthn> o/

[13:06] <am0c> morning!

[13:08] <takadonet> wow! lots of commit since last night

[13:08] <moritz_> mostly jnthn++

[13:08] <moritz_> 30524 passing tests. \o/

[13:09] *** [particle] left
[13:09] *** dual left
[13:11] *** TiMBuS joined
[13:14] *** [particle] joined
[13:16] <takadonet> how many tests are they in the spec right now?

[13:17] *** slavik joined
[13:18] <moritz_> estimated 38.5k

[13:18] <moritz_> that's what rakudo's test_summary.pl says

[13:18] <moritz_> probably more... maybe 40k to 45k

[13:18] <colomon> takadonet: but note that Rakudo Alpha only passed 32k

[13:19] <slavik> what are we measuring?

[13:20] <moritz_> numbers

[13:20] <moritz_> integers, to be exact

[13:22] <snarkyboojum> wow, so less than 2k away from alpha?

[13:22] <dalek> rakudo: eaac605 | jonathan++ | src/Perl6/Actions.pm:

[13:22] <dalek> rakudo: Make anonymous named parameters (yes, I know...masak told me to) work.

[13:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/eaac605e9a30460228e19112d99df7e6cbca3912

[13:22] <dalek> rakudo: 1795a2e | jonathan++ | src/core/Signature.pm:

[13:22] <dalek> rakudo: Show sub-signatures in .signature.perl.

[13:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1795a2e32035f62487cde308451d8de55d0bc71e

[13:22] <colomon> snarkyboojum: well, it's a bit tricky... because we pass tests alpha never did.

[13:23] <colomon> so we won't have alpha's full functionality back by 32k.

[13:23] <snarkyboojum> colomon: but a simple numbers comparison

[13:23] <colomon> but we will be comparable.

[13:23] <snarkyboojum> colomon: ah ok

[13:23] <snarkyboojum> be awesome in different areas :)

[13:23] <colomon> but yeah, definitely it will be cause for celebration.

[13:24] <snarkyboojum> :)

[13:24] <colomon> and I'm looking forward to celebrating!  ;)

[13:26] *** ignacio_ joined
[13:28] *** Guest42283 left
[13:28] <moritz_> rakudo: multi x(%h($a, $b)) {}; multi x(%h($a, $b)) {}; x({:a, :b})

[13:28] <p6eval> rakudo 7348b9: OUTPUT«Ambiguous dispatch to multi 'x'. Ambiguous candidates had signatures:␤:(%h)␤:(%h)␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:28] <moritz_> rakudo on the server not yet recompiled

[13:33] <cognominal> jonathan++

[13:34] <CokeBot9000> rakudo: my @a=<svg form web>; say @a.grep("svg").perl

[13:34] <p6eval> rakudo 7348b9: OUTPUT«("svg", )␤»

[13:35] <CokeBot9000> should we not emit the trailing comma when .perl'ing ?

[13:36] <cognominal> is there a way to ask rakudo which branch and which patch number is used for its compilation?

[13:36] <cognominal> WHOA THERE, now compile is fast again.

[13:37] <moritz_> cognominal: not now - there's a patch for that in RT, but waits review from pmichaud++

[13:37] <CokeBot9000> chromatic++

[13:39] *** [particle] left
[13:39] <colomon> ah, that's what happened to that patch.

[13:40] <moritz_> colomon: speaking of patches... I think you'd be well suited to review RT #74008

[13:42] <colomon> is that the lazy seq / array patch?

[13:43] *** [particle] joined
[13:43] <moritz_> yes

[13:43] *** am0c left
[13:43] <colomon> it's been sitting open in a tab in Chrome since the first time you mentioned it, but I haven't had a chance to take a look.

[13:44] <moritz_> ok

[13:44] <moritz_> then sorry for redundant bothering :-)

[13:44] <colomon> maybe if I can get packing stuff done today, I can take a closer look tonight...

[13:44] <colomon> no, it's good, I should be looking at it.  :)

[13:46] <moritz_> in the end I don't want to hinder your packing in any way

[13:53] <moritz_> in current rakudo, how do I create a proper Perl 6 hash in PIR?

[13:54] <colomon> well, believe me, packing has the highest priority at the moment.  since the movers are coming to pack whatever we haven't tomorrow....

[13:54] <colomon> afk # heading back to pack, will hopefully be able to get wi-fi set up again when I arrive.

[13:54] *** colomon left
[13:54] <jnthn> rakudo: say (:()).WHAT

[13:54] <p6eval> rakudo 1795a2: OUTPUT«Parcel()␤»

[13:55] <jnthn> rakudo: say :().WHAT

[13:55] <p6eval> rakudo 1795a2: OUTPUT«Parcel()␤»

[13:55] * moritz_ expects Signature()

[13:55] *** PacoLinux joined
[13:55] <jnthn> yeah, same

[13:55] <jnthn> Just looking at #69320 on this. :-)

[13:55] *** astrojp joined
[13:56] <jnthn> rakudo: say :($a).WHAT

[13:56] <p6eval> rakudo 1795a2: OUTPUT«Symbol '$a' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[13:56] <jnthn> hmmm

[13:56] <moritz_> std: say :($a).WHAT

[13:56] <p6eval> std 30313: OUTPUT«ok 00:01 109m␤»

[13:57] <jnthn> oh heh

[13:57] <jnthn> we're missing token:sigterm anyway :-)

[13:57] *** gbacon joined
[13:57] <moritz_> std: :($a); say $a

[13:58] <p6eval> std 30313: OUTPUT«===SORRY!===␤Variable $a is not predeclared at /tmp/gCi6GwNeAp line 1:␤------> :($a); say $a⏏<EOL>␤    expecting any of:␤ POST␤   postfix␤  postfix_prefix_meta_operator␤FAILED 00:01 108m␤»

[13:58] <jnthn> std++

[13:58] * moritz_ looks at src/core/YOU_ARE_HERE.pm with slight bewilderment

[13:59] <jnthn> moritz_: :-)

[13:59] <moritz_> ah, some kind of marker for lexical things for the setting`

[13:59] <jnthn> moritz_: Correct.

[13:59] <CokeBot9000> I just tripped over that trying to run rakudo against an old parrot.

[13:59] <jnthn> moritz_: It's also the last line in CORE.setting

[14:00] <jnthn> (that STD uses)

[14:03] <pugssvn> r30314 | moritz++ | [t/spec] test that subsignatures appear in the output of Signature.perl 

[14:04] <jnthn> \o/

[14:05] <moritz_> rakudo: multi x(%h($a, $b)) {}; multi x(%h($a, $b)) {}; x({:a, 

[14:05] <p6eval> rakudo 1795a2: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[14:05] <moritz_> rakudo: multi x(%h($a, $b)) {}; multi x(%h($a, $b)) {}; x({:a,  :b})

[14:05] <p6eval> rakudo 1795a2: OUTPUT«Ambiguous dispatch to multi 'x'. Ambiguous candidates had signatures:␤:(%h (Mu $a, Mu $b))␤:(%h (Mu $a, Mu $b))␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[14:06] <moritz_> jnthn++

[14:06] <jnthn> :-)

[14:10] *** xabbu42 left
[14:16] *** dual joined
[14:17] *** Lorn joined
[14:23] *** nihiliad joined
[14:37] *** alester joined
[14:41] *** justatheory joined
[14:42] *** pmurias left
[14:43] *** Trashlord joined
[14:43] *** jaldhar left
[14:55] <ruoso> hmm... 

[14:56] *** Chillance left
[14:56] *** jaldhar joined
[14:57] *** ignacio_ left
[14:58] *** ash_ joined
[15:00] <moritz_> wow, signature parsing is complicated

[15:00] <moritz_> or declaration parsing, for that matter

[15:00] <jnthn> Tell me about it!

[15:00] * moritz_ tells jnthn that declaration parsing is complicated

[15:01] <ruoso> I didn't quite understand the motivations on lue's revamp of S32/Temporal

[15:01] * takadonet glad he only working on trans

[15:01] <ash_> jnthn, moritz_ i think i found a leaky parrot object

[15:01] *** IllvilJa joined
[15:01] <ash_> rakudo: class A { }; my $a = A.new; $a.HOW.add_method($a, 'fo', method { say 'new_method'; }); $a.'fo'(); my $b = A.new; say $a.^methods(:local); my $c = 1; $c.^add_method('fo', method { say 'new_method'; }); $c.fo;

[15:01] <p6eval> rakudo 1795a2: OUTPUT«new_method␤_block73␤Method 'fo' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[15:01] <ash_> Integer i think is from parrot 

[15:01] <moritz_> ruoso: I think he meant to simplify things, but since he hasn't replied to Mark's question on p6l, it's still a mistery to me

[15:02] <moritz_> ruoso: I think if he doesn't respond within a reasonable time frame, we could just revert his commit

[15:02] <IllvilJa> Builds of github rakudo goes WAY faster these days :-)

[15:02] <moritz_> IllvilJa: aye, chromatic++'s and bacek++'s "fault" :-)

[15:02] <ruoso> moritz_, one way or the other, I think his change is not aligned at all with current view of temporal definitions

[15:03] <ruoso> i.e.: "Temporal is divided into two parts: date and time."

[15:03] <ruoso> that's simply not true. it is the case in the gregorian calendar

[15:04] <ruoso> but might not be the case in other calendars

[15:04] <IllvilJa> chromatic++ & bacek++ indeed

[15:04] <ash_> my example could be shortened some, but the add method worked on a custom class object, but it fails on the Int

[15:05] <jnthn> ash_: I think I know why that is.

[15:05] <ruoso> using $*NOW as a context variable instead of a multi call

[15:05] <ash_> also, should ^add_method add a method to ALL instances of that object type? I added it to $a, and $b got it too 

[15:06] <ruoso> ash_, "type" is not the precise word...

[15:06] <ruoso> every object that shares the same metaclass instance 

[15:06] <jnthn> ash_: yes, to all instances.

[15:07] <ash_> got ya, just wondering, i wasn't sure 

[15:07] <ruoso> in fact... if that object was already runtime composed with other role

[15:07] <ruoso> calling ^add_method would probably add just to that specific object

[15:07] <ruoso> since it would have a metaclass instance on its own...

[15:08] <jnthn> Yes, true.

[15:08] *** SmokeMachine joined
[15:08] <ruoso> rakudo: my $a = 0 but True; $a.^add_method('bla',method { say "Hello" }); $a.bla()

[15:08] <p6eval> rakudo 1795a2: OUTPUT«No applicable candidates found to dispatch to for 'infix:<does>'. Available candidates are:␤:(Mu $do-it-to-me, Role $r)␤:(Mu $do-it-to-me, ConcreteRole $r)␤␤current instr.: 'infix:<but>' pc 277213 (src/gen/core.pir:3883)␤»

[15:09] <ruoso> oops

[15:09] <jnthn> Don't do "but True" yet.

[15:09] <jnthn> One of the many todos.

[15:09] <ruoso> okay... 

[15:10] <ruoso> rakudo: my $a = 0; role B { }; my $b = B.new(); $a does B; $a.^add_method('bla',method { say "Hello" }); $a.bla(); $b.bla(); say 'survived';

[15:10] <p6eval> rakudo 1795a2: OUTPUT«Hello␤Method 'bla' not found for invocant of class ''␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[15:10] <ruoso> hmm... that was supposed to work... I think...

[15:11] <ash_> um...

[15:11] <ash_> how would that work? 

[15:11] <ruoso> ah...

[15:11] <ruoso> wait...

[15:11] <ruoso> it did work

[15:11] <ash_> roles are immutable, add_method shouldn't be adding to the role 

[15:11] * ruoso just spotted the "Hello" at the beggining...

[15:11] <jnthn> :-)

[15:11] <moritz_> alpha: my $a = 0; role B { }; my $b = B.new(); $a does B; $a.^add_method('bla',method { say "Hello" }); $a.bla(); $b.bla(); say 'survived';

[15:11] <ruoso> $a has the method "bla", $b doesn't

[15:12] <p6eval> alpha 30e0ed:  ( no output )

[15:12] <moritz_> ruoso: care to turn that into a spectest?

[15:13] <ash_> i think this is a clearer example of what you meant ruoso

[15:13] <ash_> rakudo: class B { }; role Blank { }; my $a = B.new; my $b = B.new; $a does Blank; $a.^add_method('bla',method { say "Hello" }); $a.bla; $b.bla; say 'survived';

[15:13] *** ignacio_ joined
[15:14] <p6eval> rakudo 1795a2: OUTPUT«Hello␤Method 'bla' not found for invocant of class 'B'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[15:14] <ash_> it wasn't added to B in that case because $a had a does applied to it, so it had a new meta instance, i think, that was different than the one $b has 

[15:15] <ruoso> ash_, precisely

[15:15] <ash_> if you don't do the $a does Blank; they both say hello 

[15:15] <jnthn> Seems to make sense to me too. :-)

[15:16] <ruoso> that's why saying "type" is confuse...

[15:16] <ash_> yeah, true

[15:16] *** pmurias joined
[15:16] <ruoso> it's better to spell out the full name

[15:16] <ash_> what should happen if instead of $a does Blank; you did B does Blank; ? 

[15:16] <ash_> should $a and $b have 'bla'? 

[15:16] <ruoso> yes

[15:16] <ruoso> because you modified the roel

[15:16] <ruoso> but i *think* roles are closed

[15:17] <ash_> well, in my example i changed the role B to class B

[15:17] <ruoso> wait waity

[15:17] <dalek> rakudo: 2464ddb | moritz++ | src/glue/run.pir:

[15:17] <dalek> rakudo: bring back %*VM, though currently it is a parrot Hash, not a Rakudo Hash (no idea how to fix that :/ )

[15:17] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2464ddb1fc4b5a562d8ea889bc4be9ae600b58d0

[15:17] <ash_> sorry, i should of given it a new name, that's probably confusing since our two examples are so similar 

[15:18] <ruoso> I see what you mean

[15:18] <ruoso> I think it wouldn't

[15:18] <ash_> wonldn't or shouldn't? 

[15:18] <ruoso> when you call $a.^add_method it probably is a good reason to specialize the metaclass instance of $a

[15:18] <ruoso> to avoid action-at-a-distance

[15:18] <jnthn> eww...in place? :-)

[15:19] <ruoso> yeah... in place..

[15:19] <jnthn> I think .^add_method will do some action at a distance.

[15:19] <jnthn> If you're playing with meta-methods then you're asking for trouble anyway.

[15:19] <ruoso> if you do that on the protoobject, yes

[15:19] <ruoso> but doing that on a concrete object

[15:19] <ash_> hey, if the spec isn't clear enough, people like me will do "Bad Things" ™ with it 

[15:19] <ruoso> it's kinda confuse

[15:19] <jnthn> But all of those share the same meta-class instance (unless they got mixed in to).

[15:20] <jnthn> I'd rather things like add_method don't start doing magical things.

[15:20] <jnthn> They're our primitives.

[15:20] <ruoso> it's not magical

[15:20] <jnthn> That the magical things get implemented in terms of.

[15:20] <jnthn> It's more magical than I want a metaclass to be doing.

[15:20] <ruoso> it's assuming that it can't modify a public protoobject

[15:21] * ruoso would be happy with a warning

[15:21] <ash_> well, one more question, to confuse this a bit more, say class A { }; my $a = A.new; augement class A { ... add method ... }; does $a have it? 

[15:21] <jnthn> Yes.

[15:21] <ash_> and by it i mean the new method 

[15:21] <jnthn> yes.

[15:21] <jnthn> :-)

[15:21] <ruoso> but in order to use augment, you need to use MONKEY_PATCH

[15:21] <ash_> what about augment class A does Foo {}, does $a get all of Foo? 

[15:21] <jnthn> MONKEY_TYPING

[15:21] <jnthn> :-)

[15:22] * ruoso a bit outdated

[15:22] <ash_> or does that make a new meta instance? 

[15:22] <jnthn> No, $a gets all of Foo

[15:22] <jnthn> I made that work only a few days ago. :-)

[15:22] * ash_ is trying to figure out all the things that cause a new meta instance 

[15:22] <jnthn> For colomon++

[15:22] <ruoso> ash_, in order to use augment, you need to add a very ugly notice in your code, that will tell you that you're doing something nasty

[15:22] <jnthn> ash_: Mix-ins.

[15:22] <ruoso> you need to literally "use MONKEY_TYPING;"

[15:22] <ash_> i know

[15:22] <jnthn> Rakudo makes you do that these days too. :-)

[15:23] <jnthn> rakudo: augment class Int { }

[15:23] <p6eval> rakudo 1795a2: OUTPUT«Can't augment class Int without 'use MONKEY_TYPING'␤current instr.: 'perl6;Perl6;Grammar;add_name' pc 40228 (src/gen/perl6-grammar.pir:364)␤»

[15:23] <ruoso> my point is about being implicit vs explicit

[15:23] <ruoso> having $a.^add_method to modify the class is MONKEY_TYPING

[15:23] <ruoso> it should: 1) understand you're modifying just this object 

[15:23] <ruoso> or

[15:24] <jnthn> ruoso: It is, but I think people can Just Cope with that.

[15:24] <jnthn> Using .^ is immediately a big sign that something weird is going on.

[15:24] <ruoso> 2) refuse to do it unless "use MONKEY_TYPING"  is enabled

[15:24] <ruoso> or

[15:24] <jnthn> We could do (2)

[15:24] <pmurias> jnthn: there's a distinction between weird and evil

[15:24] *** IllvilJa left
[15:24] <ash_> 2 seems like a safe assumption 

[15:25] <ruoso> is there a metamethod to say "localize my metaclass instance"?

[15:25] <ruoso> because that refusal is only valid if you're modifying a public class

[15:26] <ruoso> but if you're modifying a private metainstance

[15:26] <ruoso> that's not monkey_typing

[15:27] <jnthn> There's not a meta-method to do that at the moment.

[15:27] <jnthn> Could be possible to make one.

[15:27] <ruoso> $a.^customize()

[15:27] <jnthn> Yeah, that could have other uses too.

[15:28] <jnthn> I'll ponder it a bit...could work.

[15:28] * ruoso always remember the prototype-based-oo 

[15:28] <jnthn> Trouble is we then have to make "is monkey typing allowed" something known at runtime.

[15:28] <jnthn> At the moment it's purely a prase time concept in Rakudo.

[15:28] <jnthn> Again, not a big deal...

[15:29] <ruoso> well... it's not this feature is the only that requires compile-time info in run-time

[15:29] <takadonet> anyone have example of using complex data structure such as hash of arrays?

[15:29] <ash_> the ability to customize a single object is a nice feature to have, IMO anyway, even if it is weird 

[15:29] * ruoso last phrase was kinda unparseable

[15:30] <ruoso> jnthn, at first, I think we could just forbid calling $a.^add_method before calling $a.^customize

[15:30] <jnthn> Well, maybe...

[15:30] <ruoso> one can always do $a.WHAT.^add_method if that's what he wants

[15:30] <jnthn> We gotta have a distinction between the initial class creation and later on :-)

[15:30] <ash_> rakudo: my %hash = { a => [1, 2, 3], b => [4, 5, 6] }; say %hash<a>[2];

[15:30] <p6eval> rakudo 1795a2: OUTPUT«3␤»

[15:31] <ruoso> jnthn, the distinction is if it is defined or not

[15:31] <jnthn> since we add methods in the first place with .^add_method now.

[15:31] <jnthn> Oh, hmm.

[15:31] <ruoso> but always on undefined objects

[15:31] <jnthn> Could work too.

[15:31] <jnthn> yeah, true

[15:31] <ash_> IMO its $a.HOW.add_method($a ...) vs Foo.HOW.add_method(Foo...)

[15:31] <ash_> instance vs class, or defined vs undefined objects

[15:32] <ruoso> the rule is, you can only call modifying-metamethods in 1) undef objects or 2) customized objects

[15:32] <ruoso> ash_, that's not what I meant

[15:32] <ruoso> ash_, $a.WHAT gets $a's protoobject

[15:32] <takadonet> rakudo: my %hash = { a => [1, 2, 3], b => [4, 5, 6] };say %hash<a>

[15:32] <p6eval> rakudo 1795a2: OUTPUT«1 2 3␤»

[15:32] <ruoso> ash_, so $a.WHAT.^add_method is explicitly modifying $a's metaclass instance

[15:33] * ruoso lunch &

[15:34] <takadonet> rakudo: my %hash = { a => [1, 2, 3], b => [4, 5, 6] };for %hash<a> -> $x { say $x}

[15:34] <p6eval> rakudo 1795a2: OUTPUT«1 2 3␤»

[15:35] <ash_> rakudo: my %hash = { a => [1, 2, 3], b => [4, 5, 6] }; for @(%hash<a>) -> $x { say $x}

[15:35] <p6eval> rakudo 1795a2: OUTPUT«1␤2␤3␤»

[15:36] <ash_> takadonet: it tried to assign the whole array to $x, if you do @() around it though, it will assume its a list and iterate that instead 

[15:37] <takadonet> ash_: that was my issue! Thanks Got a few more test working in trans.t now!

[15:37] <jnthn> \o/

[15:38] *** pyrimidine joined
[15:38] <takadonet> up to 16 passing out of .. a few more to go

[15:39] *** pmurias left
[15:39] <ash_> jnthn: i think i am just trying to find all the edge cases of when a meta instance might change, since I am looking to start implementing some of the MOP in my nq-nqp... its either do some of the MOP or try to imitate parrot's object model, so... for now I am just going to work with MOP since its perl 6's model, and nqp is based off of perl 6

[15:41] *** IllvilJa joined
[15:41] <jnthn> Yes, that's a good idea.

[15:41] <jnthn> ash_: That's that P6object.pir does fwiw.

[15:42] <jnthn> Implements the Perl 6 model atop of the Parrot primitives.

[15:42] <jnthn> But certainly there's no reason to emulate Parrot.

[15:42] <pyrimidine> do we have something akin to AttributeDeclarand implemented yet?  or (put another way), if there isn't how hard would it be to get that working?

[15:43] <jnthn> We had it in alpha.

[15:43] <jnthn> Pretty sure it's not yet put back in master.

[15:43] <ash_> i used it in alpha, at one point 

[15:43] <jnthn> It shouldn't be too hard.

[15:43] <pyrimidine> ok

[15:43] <ash_> lolibloged http://greaterthaninfinity.com/2010/04/runtime-support-for-nq-nqp/

[15:43] <jnthn> EDOMAINNAMETOOBIG

[15:43] <jnthn> ;-)

[15:44] <ash_> >∞ is what i always put for short 

[15:45] <moritz_> what exactly is nq-nqp?

[15:46] <ash_> an independent study i am doing on compilers, my attempt at applying what i am learning by constructing an alternative nqp based on the llvm 

[15:46] <moritz_> cool

[15:46] <moritz_> sounds a bit like smop in reverse :-)

[15:46] <ash_> hence, not quite nqp :P 

[15:46] <dalek> rakudo: c1b6e23 | jonathan++ | src/Perl6/ (2 files):

[15:46] <dalek> rakudo: Implement signature literals.

[15:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c1b6e23ba46209b7241a244e2eda09820f708a86

[15:46] <dalek> rakudo: c6c7754 | jonathan++ | src/core/operators.pm:

[15:46] <dalek> rakudo: prefix:<|> on anything other than the things we already define it on should not give an error, but instead give a Capture with just that thing in it; TimToady++.

[15:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c6c7754274a681b879ba34e6dc7419d8eea98830

[15:46] <dalek> rakudo: 1529fa0 | jonathan++ | src/builtins/Capture.pir:

[15:46] <dalek> rakudo: Capture.Capture should be identity.

[15:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1529fa05d43518453c6a0f12374094286e0a3be8

[15:46] <dalek> rakudo: b737dff | jonathan++ | src/core/Signature.pm:

[15:46] <dalek> rakudo: Implement smart-matching against a signature for the Capture and Any cases (and throw exceptions on the two we don't yet implement).

[15:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b737dff80ffa8a774242eddf27db4feff1b0330b

[15:46] <dalek> rakudo: 38db52b | jonathan++ | src/glue/run.pir:

[15:46] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[15:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/38db52ba5f7be2343f459c6c82610ad5642b653c

[15:47] <cognominal> jnthn, if I understand well, dispatch is also  made on the return type coercion. Am I right?

[15:47] <jnthn> In multi-dispatch?

[15:47] <jnthn> No.

[15:47] <ash_> i thought return type's weren't involved in MMD 

[15:47] <jnthn> It isn't (and kinda can't be in Perl 6 - context doesn't work like that).

[15:48] <jnthn> Time for a walk. :-) bbiab.

[15:48] <cognominal> ok, I just skimmed src/binder/bind.c and wondered what the coerce_to was.

[15:49] <jnthn> cognominal: That's to do with sub foo($x as Int) { ... }

[15:49] <jnthn> The Int goes in coerce_to

[15:49] <cognominal> ok, thx

[15:49] <cognominal> makes sense.

[15:49] <cognominal> ... to me.

[15:50] <jnthn> To me too, some days. ;-)

[15:50] * jnthn goes for walk

[15:51] * cognominal is amazed as how jonathan can compile S06 to code.

[15:53] <ash_> i wonder if you could implement the MMD in just parrot... 

[15:55] <cognominal> you certainly could but that would probably a bad idea.

[15:56] <ash_> doesn't parrot have mmd? or does it follow a different set of rules than perl 6's mmd? 

[15:56] <cognominal> I quite grok what C< x as Int > can mean in a signature, but I fail to find something like it in S06.

[15:57] <cognominal> ash_ I think it has a simpler set of rule, but you should ask jonathan

[15:57] <moritz_> cognominal: S02 mentions 'as'

[15:58] <moritz_> though only for return type coercions

[15:58] <cognominal> C<as> is mentionned in many places

[16:00] <moritz_> S02:1435 for example

[16:01] <CokeBot9000> parrot does have mmd.

[16:01] <moritz_> is it manhattan distance?

[16:02] <CokeBot9000> I believe so, yes.

[16:03] <ash_> manhattan distance? 

[16:04] <moritz_> http://en.wikipedia.org/wiki/Taxicab_geometry

[16:04] *** nihiliad left
[16:05] <moritz_> http://use.perl.org/~chromatic/journal/37753 has a short explanation

[16:05] *** nihiliad joined
[16:05] * cognominal uses his ack fu           ack --nocolor --nogroup  -- '^ .*(.* as .*)'  

[16:05] <cognominal> but finds nothing relevant

[16:06] <ash_> cognominal: did you check t/spec ? 

[16:06] <moritz_> rakudo: sub foo($a = 1, $b) { say $a }; foo(3)

[16:06] <p6eval> rakudo 2464dd: OUTPUT«Not enough positional parameters passed; got 1 but expected between 1 and 2␤current instr.: 'foo' pc 180 (EVAL_1:77)␤»

[16:06] <cognominal> ash_ : good idea

[16:06] *** cdarroch joined
[16:06] *** cdarroch left
[16:06] *** cdarroch joined
[16:06] <moritz_> rakudo: sub foo { @_[0] = "bah" }; my $a = "!"; foo($a); say $a

[16:06] <p6eval> rakudo 2464dd: OUTPUT«!␤»

[16:07] <slavik> rakudo: if ("123 500 5" ~~ /[(\d+)\s]+ <?{0 <= $0 <=255}>/) { say $0 }

[16:07] <p6eval> rakudo 2464dd: OUTPUT«No applicable candidates found to dispatch to for 'infix:<<=>'. Available candidates are:␤:(Any $a, Any $b)␤␤current instr.: '_block64' pc 844 (EVAL_1:289)␤»

[16:08] *** jaldhar left
[16:09] *** REPLeffect left
[16:09] <moritz_> rakudo: class A { has $s .= new }

[16:09] <p6eval> rakudo 2464dd: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤current instr.: '!dispatch_.=' pc 440 (src/glue/dispatch.pir:118)␤»

[16:09] <moritz_> rakudo: if ("123 500 5" ~~ /[(\d+)\s]+ <?{0 <= +$0 <=255}>/) {  say $0 }

[16:09] <p6eval> rakudo 2464dd: OUTPUT«123500␤»

[16:10] <cognominal> I suppose jonathan compiles straight form TimToady's mind.

[16:10] <moritz_> I think it was more explicit in previous versions of the spec

[16:10] <slavik> moritz_: I'll compile rakudo one of these days and run it on my local machine in a grammar ;)

[16:11] <moritz_> rakudo: say "yes" if 1 === 1|2

[16:11] <p6eval> rakudo 2464dd:  ( no output )

[16:12] <ash_> do junctions work yet? 

[16:12] <moritz_> aye

[16:12] <ash_> rakudo: say "yes" if 1 == 1|2

[16:12] <p6eval> rakudo 2464dd: OUTPUT«yes␤»

[16:12] <ash_> neat 

[16:12] <moritz_> but not on ===, which is still defined in PIR

[16:12] *** REPLeffect joined
[16:12] <moritz_> rakudo: say 1.WHICH

[16:12] <p6eval> rakudo 2464dd: OUTPUT«1␤»

[16:13] <moritz_> rakudo: say "foo".WHICH

[16:13] <p6eval> rakudo 2464dd: OUTPUT«foo␤»

[16:13] <moritz_> rakudo: say [].WHICH

[16:13] <p6eval> rakudo 2464dd: OUTPUT«88573784␤»

[16:13] <ash_> lol, umm... 

[16:13] <moritz_> rakudo: say [].WHICH

[16:13] <p6eval> rakudo 2464dd: OUTPUT«88571920␤»

[16:13] <ash_> rakudo: say ().WHICH

[16:13] <p6eval> rakudo 2464dd: OUTPUT«88583800␤»

[16:14] <ash_> () does it too 

[16:14] <moritz_> sure; all "normal" objects do

[16:17] <cognominal> ash_ : about the rakudo binder :  http://use.perl.org/~JonathanWorthington/journal/39772

[16:19] *** levengli joined
[16:19] *** nihiliad left
[16:23] *** nihiliad joined
[16:23] *** pmurias joined
[16:25] <levengli> anyone home?

[16:25] <moritz_> yes, but not for long :-)

[16:25] <levengli> :)

[16:25] <levengli> what's the p5 equivelant of$0?

[16:25] <moritz_> $1, but it's really not the same

[16:25] <moritz_> afk

[16:26] <levengli> wrong question

[16:26] <ash_> \0 i think? 

[16:26] <levengli> that's the p6 equivalent of p5's $0

[16:26] <ash_> oh, sorry ignore me

[16:26] <levengli> i.e what, if any, variable holds the invoking name of the script

[16:28] <ash_> $?FILE might be right.... but not always, thats the current file, not the file that was called

[16:29] <ash_> would it be in @*ARGS ? 

[16:29] <ash_> it might be @*ARGS 

[16:29] <snarkyboojum> rakudo: say @*ARGS[0]

[16:29] <p6eval> rakudo 38db52: OUTPUT«␤»

[16:30] <ash_> no, that didn't work for me locally either 

[16:31] <mberends> alpha: say $*PROGRAM_NAME

[16:31] <p6eval> alpha 30e0ed: OUTPUT«/tmp/oFlx6bfjsI␤»

[16:32] <mberends> rakudo: say $*PROGRAM_NAME

[16:32] <p6eval> rakudo 38db52: OUTPUT«/tmp/8RKc3hxBCx␤»

[16:32] <levengli> :)

[16:32] <levengli> mberends++

[16:32] <ash_> http://perlcabal.org/syn/S28.html ah, i see, mberends++ found it first its in there, look at perl 5 to perl 6 special variable translation 

[16:33] <snarkyboojum> doh - missed that :)

[16:33] <snarkyboojum> was looking at the same spec ;)

[16:33] *** dual left
[16:34] <snarkyboojum> rakudo: say @*ARGS.perl;

[16:35] <p6eval> rakudo 38db52: OUTPUT«[]␤»

[16:35] <snarkyboojum> rakudo: say $*PROGRAM_NAME;

[16:35] <p6eval> rakudo 38db52: OUTPUT«/tmp/Bu0mYTkmOs␤»

[16:35] <snarkyboojum> rakudo: say $*EXECUTABLE_NAME;

[16:35] *** masak joined
[16:35] <p6eval> rakudo 38db52: OUTPUT«../p/bin/perl6␤»

[16:35] <snarkyboojum> nice

[16:35] <masak> lol hai! o/

[16:35] <snarkyboojum> hi masak! \o

[16:35] <masak> hey snarky o/

[16:36] <mberends> hi masak o/

[16:36] <masak> mberends!

[16:36] <masak> just the person I needed.

[16:36] <mberends> oh.

[16:37] *** pmurias left
[16:37] <jnthn> ;-)

[16:38] <mathw> o/

[16:38] <jnthn> ash_: Rakudo subclasses Parrot's MultiSub PMC to implement the Perl 6 dispatch semantics.

[16:38] <ash_> jnthn: do you want me to submit a bug for the add_method thing? 

[16:38] <masak> rakudo: say -0; say -"0"

[16:38] <p6eval> rakudo 38db52: OUTPUT«0␤-0␤»

[16:38] * masak submits rakudobug

[16:38] <masak> :D

[16:39] <ash_> rakudo: say -+"0";

[16:39] <p6eval> rakudo 38db52: OUTPUT«-0␤»

[16:39] <masak> snarkyboojum: I would be happily hacking away on Yapsi or Tardis right now, if it weren't for this whole Temporal business that got me distracted. I'll be un-distracted in a little while, I hope.

[16:40] <jnthn> rakudo: say -0.0;

[16:40] <p6eval> rakudo 38db52: OUTPUT«0␤»

[16:40] <Trashlord> sup

[16:40] <snarkyboojum> masak: excellent! Temporal looks very important :)

[16:40] * masak thinks so

[16:40] <jnthn> rakudo: say :().WHAT

[16:40] <p6eval> rakudo 38db52: OUTPUT«Signature()␤»

[16:40] <masak> Trashlord: \o

[16:41] <jnthn> rakudo: my %h = a => 42; given %h { when :(Int :$a) { say "lol int" }when :(Str :$a) { say "lol string" } }

[16:41] <p6eval> rakudo 38db52: OUTPUT«lol int␤»

[16:41] <jnthn> rakudo: my %h = a => '42'; given %h { when :(Int :$a) { say "lol int" }when :(Str :$a) { say "lol string" } }

[16:42] <p6eval> rakudo 38db52: OUTPUT«lol string␤»

[16:42] <Trashlord> masak: hey man

[16:42] <jnthn> You can now smart-match against signatures, in order to dig into data structures to see what's in them. :-)

[16:43] <ash_> jnthn: ooooo very neat

[16:43] <ash_> :( ) makes a signature? 

[16:43] <mathw> jnthn: that is super cool

[16:43] <mathw> jnthn++

[16:44] <jnthn> ash_: yeah, signature literals.

[16:44] <jnthn> And then smart-matching as per S03. :-)

[16:45] <cognominal> yea, I like that feature that is very like pattern matching in Haskell.  jnthn++

[16:45] <cognominal> With Perl 6, we got the coolness of Haskell without the dreadful monads  :)

[16:46] <jnthn> Wonder if we have any tests for it...

[16:47] <pugssvn> r30315 | lwall++ | [S02] clarify that object identity from WHICH may not be a mundane value type 

[16:50] <jnthn> std: my $x where { $x > 42 };

[16:50] <p6eval> std 30314: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/JVidAiOiZE line 1:␤------> my $x ⏏where { $x > 42 };␤    expecting any of:␤       bracketed infix␤  infix or meta-infix␤      statement modifier loop␤  trait␤FAILED 00:01 109m␤»

[16:50] <jnthn> alpha: my $x where { $x > 42 };

[16:50] <p6eval> alpha 30e0ed:  ( no output )

[16:51] <TimToady> hmm

[16:51] <TimToady> std: my (my $x where { $x > 42 });

[16:51] <p6eval> std 30314: OUTPUT«===SORRY!===␤In parameter declaration, typename 'my' must be predeclared (or marked as declarative with :: prefix) at /tmp/l3Pnty0pbg line 1:␤------> my (my⏏ $x where { $x > 42 });␤FAILED 00:01 108m␤»

[16:51] <TimToady> std: my ($x where { $x > 42 });

[16:51] <p6eval> std 30314: OUTPUT«ok 00:01 108m␤»

[16:52] <TimToady> STD currently requires parens to get full parameter syntax

[16:52] <jnthn> aye

[16:53] <jnthn> WE do in Rakudo master also.

[16:53] <jnthn> alpha was sloppier though.

[16:54] <masak> std: class A { has ($.b where { $!b > 42 }) }

[16:54] <p6eval> std 30314: OUTPUT«ok 00:01 109m␤»

[16:54] <masak> \o/

[16:55] <ash_> rakudo: class A { has ($.b where { $!b > 42 }) }

[16:55] <p6eval> rakudo 38db52:  ( no output )

[16:55] <masak> std: 00

[16:55] <p6eval> std 30314: OUTPUT«Potential difficulties:␤  Leading 0 does not indicate octal in Perl 6 at /tmp/ML012Src1J line 1:␤------> 00⏏<EOL>␤ok 00:01 106m␤»

[16:55] *** M_o_C joined
[16:56] <ash_> rakudo: class A { has ($.b where { $!b > 42 }) }; my $a = A.new(b => 44); A.new(b => 21)

[16:56] <p6eval> rakudo 38db52:  ( no output )

[16:56] <masak> TimToady: jnthn and I were talking about whether numification should employ the Perl 6 grammar or not.

[16:57] <TimToady> well, yes and no :)

[16:57] <masak> TimToady: if it turns out it will, I think it makes less sense to warn about things like '00' in a string numification context.

[16:57] *** ruoso left
[16:57] *** frettled sets mode: +o masak

[16:57] <masak> TimToady: also, maybe it shouldn't do all the tricks that Perl 6 does, recognizing all manner of numbers.

[16:58] * TimToady smells arbitrary restrictions

[16:58] *** levengli left
[16:58] <frettled> Are they Julia-like?

[16:59] <TimToady> more like Mandelbrot, I'm afraid

[16:59] <frettled> kindof fuzzy, then

[16:59] <frettled> but they would be, in either case

[17:00] <TimToady> I think there should be self-similarity between the current language's idea of numbers and the default number conversion routine

[17:00] <TimToady> but it doesn't have to be identical

[17:00] <jnthn> .oO( mmm...юлия-like )

[17:00] <TimToady> for instance, numeric conversion has to deal with trimming whitespace and extra +/- in spots

[17:01] <frettled> I wonder how this could be made suitably dwimmy.

[17:02] <TimToady> dwimminess does tend to get lost in the vagaries of the human condition

[17:02] <frettled> which is: lazy

[17:03] <ash_> can you lazily determine dwim? 

[17:03] *** gbacon left
[17:04] <frettled> I don't see how that could be eagerly determined.

[17:07] <pugssvn> r30316 | jnthn++ | [t/spec] Add some basic tests for smart-matching against a signature. 

[17:13] <dalek> rakudo: 08e1886 | jonathan++ | t/spectest.data:

[17:13] <dalek> rakudo: Add S03-smartmatch/capture-signature.t to spectest.data.

[17:13] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/08e188645d2fc153e92db4e342955a29b6fef126

[17:16] <pugssvn> r30317 | lwall++ | [S02] rename ObjID to ObjAt to reduce possibility of collision with user types 

[17:17] <pugssvn> r30318 | lwall++ | [reduce.t] fix parsefail 

[17:18] <ash_> does infix:<eqv> check the meta instance? 

[17:19] <masak> rakudo: class A { class {} }

[17:19] <p6eval> rakudo 38db52: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;A;' pc -1 ((unknown file):-1)␤»

[17:19] <masak> jnthn: ^

[17:19] * masak submits rakudobug

[17:19] <masak> I can work around it for the mo.

[17:20] <jnthn> std: my $foo = 'foo'; say $foo R~= 'foo';

[17:20] <p6eval> std 30315: OUTPUT«ok 00:01 109m␤»

[17:20] <jnthn> rakudo: my $foo = 'foo'; say $foo R~= 'foo';

[17:20] <p6eval> rakudo 38db52: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17293 (src/builtins/Junction.pir:404)␤»

[17:21] <ash_> what should R~= doe? reverse the assignment semantics? so $a R~= $b becomes $b ~= $a ? 

[17:21] <jnthn> ash_: No, it's like 'foo' ~= $foo :-)

[17:22] <jnthn> Thus the error.

[17:22] <jnthn> I guess you'd have to write [R~]=

[17:22] <jnthn> Though Rakudo doesn't support that just yet

[17:30] <arnsholt> Hmm. Is there a way to find out when I got access to a GitHub repository?

[17:33] <CokeBot9000> arnsholt: If it happens to be in your feed, mebbe at something like:

[17:33] <CokeBot9000> http://github.com/coke

[17:33] <CokeBot9000> er, http://github.com/coke.atom

[17:34] *** gbacon joined
[17:34] <arnsholt> Yeah, it isn't my feed, unfortunately

[17:35] * jnthn -> noms

[17:36] <masak> indian food &

[17:36] *** masak left
[17:36] <ash_> my Int $a uses Int as the type constraint, is there a there a way to use a non class as a type constraint? or is that what "where" does? 

[17:36] <dalek> rakudo: 3611f1b | masak++ | src/core/Temporal.pm:

[17:36] <dalek> rakudo: [Temporal.pm] initial commit

[17:36] <dalek> rakudo: According to the new, not-yet-published Temporal spec.

[17:36] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3611f1baeaafd8c27d1d282e6c1435176792d3c5

[17:39] *** gbacon left
[17:39] *** colomon joined
[17:40] *** ash_ left
[17:40] <colomon> Temporal.pm \o/

[18:00] *** envi^home left
[18:05] *** hercynium left
[18:06] *** ShaneC joined
[18:07] *** ShaneC left
[18:10] *** rgrau joined
[18:11] *** hanekomu left
[18:13] *** kensanata joined
[18:14] *** dual joined
[18:21] *** pyrimidine left
[18:30] <pugssvn> r30319 | lwall++ | [S05] rewrite misleading description of "thunk" 

[18:31] <CokeBot9000> Is it too late at this point to give pugs a ^/trunk ?

[18:39] *** ash_ joined
[18:39] *** gbacon joined
[18:42] <TimToady> rakudo: multi prefix:<-> (Pair $p) { ('-' ~ $p.key) => $p.value }; say (-foo => 42).perl

[18:42] <p6eval> rakudo 3611f1: OUTPUT«"-foo" => 42␤»

[18:42] <TimToady> sorear: ^^^

[18:45] *** espadrine left
[18:50] <TimToady> sorear: re Q:anything, I don't know if it would generalize that far, would have to think about it more.

[18:54] <ash_> is the default constraint on scalar containers Mu or Any? 

[18:54] <TimToady> it probably depends on how much we can abuse the mixin mechanism that Q is using for things that might not want mixing in.

[18:54] <TimToady> Any

[18:54] <TimToady> if you want your container to hold junctions, you have to say so

[18:54] *** eternaleye left
[18:55] <TimToady> rakudo: my $x = 1|2;

[18:55] <p6eval> rakudo 3611f1:  ( no output )

[18:55] <TimToady> rakudo: my $x = 1|2; say $x;

[18:55] <p6eval> rakudo 3611f1: OUTPUT«any(1, 2)␤»

[18:55] <TimToady> hmm, I suspect that should fail

[18:55] <TimToady> rakudo: my Any $x = 1|2; say $x;

[18:55] <p6eval> rakudo 3611f1: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 17293 (src/builtins/Junction.pir:404)␤»

[18:56] <TimToady> did someone back out that change?

[18:57] <TimToady> rakudo: my $x; say $x.WHAT

[18:58] <p6eval> rakudo 3611f1: OUTPUT«Any()␤»

[18:58] *** cdarroch left
[18:58] <TimToady> hmm

[18:58] <ash_> it seems to assign it to Any, but also seems to set the default constraint to Mu 

[18:58] <[particle]> is that alpha or ng?

[18:58] <ash_> hence, why i asked 

[18:58] <TimToady> default constraint should be Any, methinks

[18:59] <TimToady> just like parameters

[18:59] *** cdarroch joined
[18:59] *** cdarroch left
[18:59] *** cdarroch joined
[18:59] <TimToady> maybe it was slowing things down too much  :(

[19:00] *** Woodi joined
[19:00] <TimToady> but maybe that just means you should be using := instead, if you want speed

[19:01] <colomon> seems more likely to be a bug which has cropped up?  at least, I don't remember ever seeing any discussion on the change....

[19:01] <TimToady> likely

[19:02] * colomon wonders if there are any tests for this...

[19:04] *** cdarroch left
[19:06] <TimToady> doesn't look like it, offhand

[19:06] <TimToady> there: eval_dies_ok 'my $a = (1 | 2 ^ 3)', '| and ^ may not associate';

[19:06] <TimToady> *there's

[19:06] <TimToady> but that's testing something else

[19:07] <TimToady> otoh, if it allowed association it would die for the wrong reason

[19:07] <TimToady> which is not good

[19:08] *** hanekomu joined
[19:08] <pugssvn> r30320 | mberends++ | [S32-temporal/Temporal.t] revise first 6 tests for new simplified spec 

[19:10] <pugssvn> r30321 | lwall++ | [precedence.t] add a few needful Mu declarations to allow assignment of junction 

[19:16] <mberends> afk about an hour, will resume Temporal work when back

[19:16] <TimToady> mberends++

[19:16] <dalek> rakudo: c41cf3f | (Martin Berends)++ | src/core/Temporal.pm:

[19:16] <dalek> rakudo: [core/Temporal.pm] bring day-of-week, month-name and day-name from alpha

[19:16] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c41cf3ffcb4cead4e2eb26658a0e32b3b50f4430

[19:18] *** bkeeler_ joined
[19:22] *** bkeeler_ is now known as keelerb

[19:22] <keelerb> Hallo folks

[19:24] *** keelerb is now known as bkeeler_

[19:30] *** astrojp left
[19:33] *** cdarroch joined
[19:33] *** cdarroch left
[19:33] *** cdarroch joined
[19:37] *** kensanata left
[19:38] *** cotto_work left
[19:38] *** cotto_work joined
[19:39] <TimToady> rakudo: sub aaa (%h is rw) { %h = <a b c> Z 1,2,3 }; my %h = <x y> Z 5,4; aaa(%h); %h.perl.say

[19:39] <p6eval> rakudo 3611f1: OUTPUT«{"a" => 1, "b" => 2, "c" => 3}␤»

[19:39] <TimToady> that looks correct to me

[19:39] <bkeeler_> Me too

[19:39] <TimToady> rakudo: sub aaa (%x is rw) { %x = <a b c> Z 1,2,3 }; my %h = <x y> Z 5,4; aaa(%h); %h.perl.say

[19:39] <p6eval> rakudo 3611f1: OUTPUT«{"b" => 2, "c" => 3, "a" => 1}␤»

[19:41] <TimToady> I don't know why finanalyst++ and moritz_++ thought it was wrong...

[19:42] *** kensanata joined
[19:42] *** eternaleye joined
[19:45] <moritz_> hm, what did I think was wrong?

[19:46] <moritz_> there was an example that used sub a(%x is rw) { ... } my %x; $x = ... }

[19:46] <TimToady> http://irclog.perlgeek.de/perl6/2010-04-04#i_2193258

[19:46] <moritz_> rakudo: sub aaa (%h is rw) { %h = <a b c> Z 1,2,3 }; my %h = <x y> Z 5,4; aaa(%h); %h.perl.say

[19:46] <p6eval> rakudo c41cf3: OUTPUT«{"b" => 2, "c" => 3, "a" => 1}␤»

[19:46] <TimToady> that is correct

[19:47] <moritz_> why? I thought the 'my' had no effect when it's in the same scope as an existing variable

[19:47] <TimToady> it's not in the same scope

[19:47] <TimToady> a sig belongs to the inner scope

[19:47] <TimToady> it's the one exception to {...} delimitation of scopes

[19:48] <TimToady> std: -> $x {...}; $x

[19:48] <p6eval> std 30321: OUTPUT«===SORRY!===␤Variable $x is not predeclared at /tmp/WJFTR899W1 line 1:␤------> -> $x {...}; $x⏏<EOL>␤    expecting any of:␤       POST␤   postfix␤  postfix_prefix_meta_operator␤FAILED 00:01 109m␤»

[19:49] <TimToady> std: sub aaa (%h is rw) { my %h }   # this would be redundant

[19:49] <p6eval> std 30321: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable %h (see line 1) at /tmp/O61Zr3RRXp line 1:␤------> sub aaa (%h is rw) { my %h⏏ }   # this would be redundant␤ok 00:01 108m␤»

[19:51] <TimToady> it's no biggie, I'm just trying to understand the backlog :)

[19:53] <moritz_> std: sub aaa (%h is rw) { %h = a => 1; my %h; %h = a => 3 }

[19:53] <p6eval> std 30321: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable %h (see line 1) at /tmp/5GST7Q0tQ9 line 1:␤------> sub aaa (%h is rw) { %h = a => 1; my %h⏏; %h = a => 3 }␤ok 00:01 108m␤»

[19:53] *** molaf left
[19:53] <moritz_> I don't see how the example was any different than that

[19:54] <TimToady> rakudo: sub aaa (%h is rw) { %h = <a b c> Z 1,2,3 }; my %h = <x y> Z 5,4; aaa(%h); %h.perl.say

[19:54] <p6eval> rakudo c41cf3: OUTPUT«{"a" => 1, "b" => 2, "c" => 3}␤»

[19:54] <TimToady> the my is outside the block here

[19:55] <TimToady> a signature declares lexicals inside its block, not outside

[19:56] <TimToady> the namespaces are independent, so it's as if the parameter was a different name:

[19:56] <TimToady> rakudo: sub aaa (%x is rw) { %x = <a b c> Z 1,2,3 }; my %h = <x y> Z 5,4; aaa(%h); %h.perl.say

[19:56] <p6eval> rakudo c41cf3: OUTPUT«{"a" => 1, "b" => 2, "c" => 3}␤»

[19:58] <moritz_> ah

[19:58] <moritz_> I somehow thought the my was *inside* the sub

[19:58] <moritz_> mental parsing fail on my side

[19:58] <TimToady> that would explain it. :)

[20:01] <TimToady> at least we have curlies; imagine trying to talk to a python bot using indentation...  :)

[20:01] <moritz_> :-)

[20:01] <frettled> haha

[20:03] <TimToady> rakudo: say [1,2] X~ <a b>   # /me suspects a bug

[20:03] <p6eval> rakudo c41cf3: OUTPUT«1a1b2a2b␤»

[20:03] <TimToady> yes, a bug

[20:03] <TimToady> [1,2] should not flatten in list context

[20:04] <moritz_> rakudo: .say for 1, [2, 3], 4

[20:04] <p6eval> rakudo c41cf3: OUTPUT«1␤23␤4␤»

[20:04] <moritz_> and I know why... the signature of X and X~ says Iterable

[20:04] <TimToady> I think X~ is taking liberties

[20:04] *** rajeshsr joined
[20:04] * moritz_ reports

[20:05] <moritz_> rakudo: say 1 X~ 2 X~ <a b>

[20:05] <p6eval> rakudo c41cf3: OUTPUT«No applicable candidates found to dispatch to for 'crosswith'. Available candidates are:␤:(&op, Iterable $a-iterable, Iterable $b-iterable)␤:(&op, Any $a, Any $b)␤␤current instr.: 'perl6;Code;assuming_helper' pc 13140 (src/builtins/Str.pir:38)␤»

[20:05] <TimToady> snarkyboojum++ gets the karma for running across it earlier

[20:05] <moritz_> and I assume that should work too? :-)

[20:06] <TimToady> yep

[20:06] * moritz_ reports

[20:06] *** rajeshsr left
[20:06] *** molaf joined
[20:06] <colomon> I don't think we have the tools to properly specify the signature for crosswith / Xop yet.

[20:06] <TimToady> list infixes are supposed to take lists, and should be list associative as well

[20:06] *** meppl left
[20:06] <TimToady> could well be

[20:07] <moritz_> colomon: slurpy paramter of Iterables?

[20:07] <colomon> I'd love to be wrong about that, mind you.

[20:07] <TimToady> the parser probably needs to be handing off parcels (or degenerate items)

[20:08] <moritz_> or maybe with a signature of (\$x), and unpacking them manually...

[20:08] <colomon> Isn't the proper signature something like **@a

[20:08] <TimToady> rakudo doesn't really do slices yet

[20:08] <TimToady> and that's what list infixes really are

[20:08] <moritz_> hm, right

[20:08] *** buubot left
[20:08] <TimToady> much like @a[1; 2; <3 4>]

[20:10] <TimToady> or crosswith(&[~]; 1; 2; <a b>), give or take a semicolon

[20:10] * ash_ still is a bit fuzzy on the whole slice vs list thing 

[20:10] <colomon> also, of course, Rakudo definitely doesn't handle passing Positional types that are iterators properly.

[20:13] <moritz_> http://news.perlfoundation.org/2010/04/grant-report-changing-the-perl.html

[20:13] <moritz_> rakudo: sub foo(:$w=4){say $w};foo('w'=>3);foo(w=>3);

[20:13] <p6eval> rakudo c41cf3: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'foo' pc 209 (EVAL_1:81)␤»

[20:14] <TimToady> anyway, when I see something like [1,2] X~ 3,4 it looks like @a[ [1,2]; 3,4 ] to me, which looks wrongish

[20:14] <ash_> moritz_++ neat article, i'll have to read that in depth 

[20:15] *** buubot joined
[20:15] *** gavgpv joined
[20:16] *** gavgpv left
[20:16] <colomon> TimToady: what do you think [1,2] X~ 3,4 should output?

[20:16] <colomon> or rather, I was more worried about [1, 2] X~ <a b>

[20:16] <TimToady> heh, add another implementor to your compiler and you'll get another pass in your compiler :)

[20:17] <moritz_> '1 23', '1 24' I'd guess

[20:17] <moritz_> [1,2] is one item

[20:17] <TimToady> correct

[20:17] <moritz_> which stringifies to '1 2'

[20:17] <moritz_> so it's the same as '1 2' X~ 3, 4

[20:18] <TimToady> rakudo: say ([1,2],) X~ <a b>

[20:18] <p6eval> rakudo c41cf3: OUTPUT«1 2a1 2b␤»

[20:18] <TimToady> the parser should probably be forcing those arguments to be parcels

[20:19] <pugssvn> r30322 | moritz++ | [t/spec] test that quoted pair keys account for positional arguments, and calling a function the only excpect named parameters dies 

[20:19] <TimToady> since a slice is a list of parcels

[20:19] <colomon> rakudo: my @a = [1, 2]; say +@a

[20:19] <arnsholt> In nqp-rx's operator precedence parser, are the precedence levels strings or ints?

[20:19] <p6eval> rakudo c41cf3: OUTPUT«1␤»

[20:19] <moritz_> (we probably had tests for that before, I but I couldn't find them in the obvious place)

[20:20] <arnsholt> (Or rather, can I make them ints?)

[20:20] <TimToady> or the binding for list infixes and other slices should be enforcing the parcel view on non-parcel lists

[20:21] <TimToady> that's probably the better direction

[20:21] * moritz_ closes the 6th-oldest bug in the perl6 RT queue

[20:22] * TimToady needs to define how positional parameters interact with slice parameters though, and whether an extra ';' is needed

[20:22] <TimToady> that is, should it be crosswith($op, @a; @b; @c) or crosswith($op; @a; @b; @c)

[20:23] <CokeBot9000> moritz_: do you typically cc the list on ticket mods?

[20:23] <moritz_> CokeBot9000: I typically use "reply", which does that, afaict

[20:23] <TimToady> or something else again, like crosswith($op, (@a; @b; @c))

[20:23] <moritz_> rakudo: my $x = 1..Inf; say "alive"

[20:24] <p6eval> rakudo c41cf3: OUTPUT«alive␤»

[20:25] <TimToady> rakudo: my @x = 1..Inf; say "dead"

[20:25] <p6eval> rakudo c41cf3:  ( no output )

[20:25] *** M_o_C left
[20:26] *** molaf left
[20:26] <TimToady> I still think arrays and iterators should basically be the same data structure, just with different api policy

[20:26] <moritz_> rakudo: class A { has $.a; method x(Str $x) {}; method all() { $!a } }

[20:26] <p6eval> rakudo c41cf3:  ( no output )

[20:26] <TimToady> they both consist of a known part and an unknown part

[20:27] *** kensanata left
[20:28] <colomon> TimToady: interesting, I was just thinking that we should revive "List" as a wrapper around Iterator with (in your terminology there, if I understand it) no known part.

[20:28] <TimToady> well, no known part till someone "unshifts" to it

[20:28] <TimToady> the iterator api basically boils down to shift and unshift

[20:29] <m6locks> rakudo: role A { our method !aa() { return 42; }  }; class B does A { method foo() { self!aa(); } }; my $bb = B.new; say $bb.foo();

[20:29] <p6eval> rakudo c41cf3: OUTPUT«42␤»

[20:29] <colomon> TimToady: my idea was that List very definitely would NOT remember earlier values from its iterator.

[20:30] <colomon> If you want that, you want a Seq.

[20:30] <TimToady> and a List defaults to .get (read .shift) in list context rather than the non-destructive interpolation that an array does

[20:30] <colomon> (Or at least, I don't know how a Seq is different from an Iterator that does have memory.

[20:30] <ash_> so... how private are $! variables? 

[20:30] <ash_> rakudo: class A { has $!a }; my $a = A.new(a => 42); my $method = method { return $!a }; $a.$method();

[20:31] <p6eval> rakudo c41cf3:  ( no output )

[20:31] <ash_> rakudo: class A { has $!a }; my $a = A.new(a => 42); my $method = method { return $!a }; $a.$method().say;

[20:31] <TimToady> yes, a List forgets values *just* *like* *shift* does

[20:31] <p6eval> rakudo c41cf3: OUTPUT«42␤»

[20:31] <ash_> should that be allowed? 

[20:31] *** Trashlord left
[20:31] <moritz_> ash_: rakudo doesn't really enforce privateness of attributes in any case

[20:31] <colomon> TimToady: yes.

[20:32] <moritz_> ash_: but I don't think it should be allowed

[20:32] <ash_> well, in the ideal situation, is that wrong? 

[20:32] <ash_> got ya 

[20:32] <ash_> some languages have different ideas of 'private', but most languages with reflection end up having all their variables public, eventually 

[20:33] <moritz_> rakudo: my $x = 0; $x++ for [,] 1, 2, 3; say $x

[20:33] <p6eval> rakudo c41cf3: OUTPUT«1␤»

[20:33] <TimToady> the compiler should have no idea what $!a means outside the class's block, I think

[20:34] <moritz_> rakudo: say +(1..Inf)

[20:34] <p6eval> rakudo c41cf3:  ( no output )

[20:34] <ash_> so, a bare "my $a = method { $!a }" would be a compiler error? 

[20:35] <ash_> by bare i mean, outside a class definition

[20:35] <CokeBot9000> moritz_: http://rt.perl.org/rt3/Ticket/Display.html?id=65864 seems to no longer blow up.

[20:35] <TimToady> outside of anyplace that doesn't define $!a

[20:35] <TimToady> including inside a different class definition

[20:35] <CokeBot9000> rakudo: my (%h?)

[20:35] <p6eval> rakudo c41cf3:  ( no output )

[20:35] <moritz_> std: my (%h?)

[20:35] <p6eval> std 30322: OUTPUT«ok 00:01 109m␤»

[20:35] <TimToady> rakudo: say [,](1,2,3).WHAT

[20:35] <moritz_> CokeBot9000: thanks

[20:36] <p6eval> rakudo c41cf3: OUTPUT«␤»

[20:36] <CokeBot9000> rakudo: sub foo($bar:) {};

[20:36] <p6eval> rakudo c41cf3:  ( no output )

[20:36] <moritz_> rakudo: my $x = [,] 1, 2, 3; say $x.WHAT

[20:36] <p6eval> rakudo c41cf3: OUTPUT«Seq()␤»

[20:36] <TimToady> seems like that would be a Parcel

[20:36] <colomon> errr... that's interesting.

[20:36] <CokeBot9000> rakudo: sub postcircumfix:<[ ]>(Str $s: @i) { my $res =

[20:36] <CokeBot9000> ""; for @i { $res ~= substr($s, $_, 1) }; $res }; say "OH HAI

[20:36] <p6eval> rakudo c41cf3: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[20:36] <CokeBot9000> curse you, cut and paste.

[20:37] <CokeBot9000> rakudo: sub postcircumfix:<[ ]>(Str $s: @i) { my $res = ""; for @i { $res ~= substr($s, $_, 1) }; $res }; say "OH HAI WORLD"[7,0,7,2,9,4,-1]

[20:37] <p6eval> rakudo c41cf3: OUTPUT«Negative indexes to .[] not allowed in Perl 6␤current instr.: 'perl6;Positional[::T];postcircumfix:<[ ]>' pc 10553 (src/metamodel/GrammarHOW.pir:44)␤»

[20:37] <colomon> rakudo: my $x = infix:<.>(1, 2); say $x.WHAT

[20:37] <p6eval> rakudo c41cf3: OUTPUT«Could not find sub &infix:<.>␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:37] <CokeBot9000> 65904 looks better, too.

[20:37] <colomon> rakudo: my $x = infix:<,>(1, 2); say $x.WHAT

[20:37] <p6eval> rakudo c41cf3: OUTPUT«Seq()␤»

[20:37] <CokeBot9000> std: sub postcircumfix:<[ ]>(Str $s: @i) { my $res = ""; for @i { $res ~= substr($s, $_, 1) }; $res }; say "OH HAI WORLD"[7,0,7,2,9,4,-1]

[20:37] <p6eval> std 30322: OUTPUT«ok 00:02 114m␤»

[20:37] <pugssvn> r30323 | moritz++ | [t/spec] my (%h?) 

[20:38] <TimToady> rakudo: sub postcircumfix:<[ ]>(Str $s: @i) { my $res = ""; for @i { $res ~= substr($s, $_, 1) }; $res }; say "OH HAI WORLD"[7,0,7,2,9,4,*-1]

[20:38] <p6eval> rakudo c41cf3: OUTPUT«Method 'Int' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[20:38] <TimToady> substr doesn't understand *-1 yet

[20:38] <moritz_> CokeBot9000: yes, I've taken RT #65904 which means it waits for spectests

[20:38] <CokeBot9000> hokay.

[20:38] * CokeBot9000 will double check that next dtime, danke.

[20:38] *** Trashlord joined
[20:38] <CokeBot9000> s/dtime/time/

[20:39] *** Trashlord is now known as Guest83313

[20:39] <TimToady> rakudo: say substr("XYZ", *-1, 1)

[20:39] <p6eval> rakudo c41cf3: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[20:39] <TimToady> rakudo: say substr("XYZ", -1, 1)

[20:39] <p6eval> rakudo c41cf3: OUTPUT«Z␤»

[20:40] <TimToady> how...quaint...

[20:40] <colomon> TimToady: I take it that is supposed to work?  :)

[20:40] <colomon> oh, wait.

[20:40] <colomon> *-1 syntax is supposed to replace -1 in substr?

[20:40] <TimToady> yes

[20:40] <colomon> I think we have a badly broken substr.t test file, then.

[20:41] <TimToady> could well be a broken spec too

[20:41] <colomon> I don't see any sign of *-1 in the substr spec.

[20:41] <colomon> but then, there's no sign of -1 there either, I think.

[20:42] <frettled> Spectest is broken, like the first specte-e-e-est.

[20:42] <colomon> lots of references to StrPos, is that defined somewhere?

[20:42] * colomon has just been broken by frettled++

[20:42] <TimToady> any place where we used to have magical negative semantics should probably switch to *-1 if possible

[20:42] <TimToady> splice as well

[20:43] <CokeBot9000> moritz_: one liner to get get git revision of rakudo i'm working with?

[20:44] <CokeBot9000> (the short version)

[20:44] <CokeBot9000> ah. git show --abbrev-commit. whee.

[20:44] <TimToady> it's a smell in Perl 5 that index can return a non-match that turns into a valid substr offset :(

[20:45] <CokeBot9000> moritz_: reply sends an email to the requestor by default, but not to the list.

[20:47] <colomon> TimToady: I've added substr and splice to my personal to-do list.  Pretty sure it will be a while before I get to them, though.  

[20:47] <colomon> Might should add them to the Rakudo * todo list as well?

[20:48] <colomon> Seems like a smallish change that would be good to have in place before the hypothetical masses start using Perl 6....

[20:48] <TimToady> rakudo: index("foo","bar"); say 'alive'

[20:48] <p6eval> rakudo c41cf3: OUTPUT«alive␤»

[20:48] <TimToady> rakudo: my $x = "XYZ"; say substr($x,index("BLECH",$x),1)

[20:48] <p6eval> rakudo c41cf3: OUTPUT«Substring 'XYZ' not found in 'BLECH'␤current instr.: 'perl6;Perl6Exception;throw' pc 14818 (src/builtins/Seq.pir:41)␤»

[20:49] <TimToady> I guess that's right...

[20:50] <TimToady> though perhaps LTA in explaining what happened

[20:51] <TimToady> throwing an unthrown exception should really give more than one line number, potentially

[20:52] <TimToady> the place where the Failure was used as a value could be completely elsewhere from where it was generated

[20:53] <TimToady> and the throw should include something like "Failure was used as a value at foo line 42" plus the message from the original problem.

[21:01] *** masak joined
[21:01] <masak> Greetings gentlemen.

[21:01] <TimToady> what about me?  today I'm an irascible grouch.  :)

[21:02] <masak> no greetings for you!

[21:02] <masak> :)

[21:02] <CokeBot9000> TimToady: ... today!?

[21:02] * TimToady mutters under his breath...

[21:02] <moritz_> masak: what about our gentleladies? :-)

[21:03] <moritz_> and butterflies! don't forget the butterflies!

[21:03] <TimToady> they are welcome on my lawn.

[21:03] <TimToady> butterflies too...

[21:03] <masak> moritz_: it's a line from an internet meme. in reality, I greet gentle-X for all possible values of X.

[21:03] * CokeBot9000 scurries away.

[21:04] <CokeBot9000> . o O (I am, of course, merely being a pain.)

[21:05] <masak> CokeBot9000: it does not logically follow that I don't greet you, though :)

[21:05] <TimToady> if he is merely being a pain, it follows that he can't be anything else

[21:06] <masak> no, that's 'being merely a pain' :)

[21:06] <CokeBot9000> I am being little else today, that is true.

[21:06] <masak> 'merely being a pain' just means that that's all he's doing at the moment.

[21:07] * TimToady thinks about whether that falls into the category of "gentle"

[21:07] <TimToady> I guess he could be a gentlepain

[21:07] <sjohnson> afternoon perl6 hackers

[21:07] <masak> sjohnson: \o

[21:08] <TimToady> o\

[21:08] <colomon> o/

[21:08] <masak> TimToady: "gentlepain" sounds like a euphemism worthy of the Perl 6 community :)

[21:09] <sjohnson> （　｀ー´）

[21:09] <moritz_> and GITA is Gentlepain In The ...

[21:09] <CokeBot9000> GentlePain Coke, that's me.

[21:10] *** Logo joined
[21:10] <TimToady> not to be confused with GentlePane, which is the glass around the Coke

[21:10] <TimToady> that was almost funny, so you should almost laugh.

[21:11] <masak> 哈

[21:11] * ash_ roflcopter? 

[21:12] <ash_> masak, you make me sad i only know 1 language, (for communicating) 

[21:12] <moritz_> we're down to 603 open tickets

[21:12] <masak> ash_: don't be sad! I'm sure some language community will welcome you with open arms.

[21:12] <moritz_> time for some sleep

[21:13] <masak> ash_: and claiming that I 'know' Mandarin feels like a wild exaggeration. :)

[21:13] <masak> I know how to switch input modes in Emacs :P

[21:13] <ash_> thats probably as valid as me saying i know english

[21:14] <ash_> i am trying to convince my friends i don't actually know english, i am just really good at pretending i do, just like i know perl, until i dont, then i don't, otherwise, yes

[21:14] <masak> :)

[21:16] *** meppl joined
[21:16] *** REPLeffect left
[21:17] <CokeBot9000> TimToady: http://rt.perl.org/rt3/Ticket/Display.html?id=60780 - I would imagine that on the last loop through, a would get 5, and b would get whatever undef is these days.

[21:18] <TimToady> no, it just fails to bind, unless you declare the second parameter as optional

[21:19] <ash_> can you label your loops in perl 6? so if you have " while 1 { while 2 { last "outer?" ; } } 

[21:19] <ash_> "

[21:19] <ash_>  or something

[21:19] <CokeBot9000> (fails to bind) - just on the last iteration, yes?

[21:20] <masak> ash_: yes. see S04.

[21:20] <TimToady> rakudo: FOO: for 1..10 { say $_; last FOO when 5 }

[21:20] <p6eval> rakudo c41cf3: OUTPUT«Confused at line 11, near "FOO: for 1"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[21:20] <masak> or see TimToady :)

[21:20] <sjohnson> rakudo: say " happiness ".rtrim;

[21:20] <p6eval> rakudo c41cf3: OUTPUT«Method 'rtrim' not found for invocant of class 'Perl6Str'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:20] <masak> Rakudo doesn't do labels yet.

[21:20] <TimToady> yes, just the last iteration

[21:21] <masak> sjohnson: there's no rtrim. just trim.

[21:21] <TimToady> for and map will eventually just be partial rebinding of the signature to a capture cursor or some such

[21:21] <TimToady> rakdudo say " happiness ".trim-trailing

[21:21] <sjohnson> masak: oic.  any idea if ltrim / rtrim will ever become part of perl 6 whitespace trimming methods?

[21:22] <TimToady> rakudo: say " happiness ".trim-trailing

[21:22] <p6eval> rakudo c41cf3: OUTPUT« happiness␤»

[21:22] <masak> ooh!

[21:22] <TimToady> ltrim and rtrim are ambiguous in right-to-left languages

[21:22] <sjohnson> thanks

[21:22] <colomon> rakudo: say " happiness ".trim-trailing

[21:22] <p6eval> rakudo c41cf3: OUTPUT« happiness␤»

[21:22] <masak> (ssenerawa ltr)++

[21:23] <colomon> rakudo: say " happiness ".trim-leading

[21:23] <p6eval> rakudo c41cf3: OUTPUT«happiness ␤»

[21:23] <masak> when did this happen? I completely missed it.

[21:23] <masak> it's much better than anything p6l ever proposed :)

[21:23] <sjohnson> probably was made to prevent me from ranting / whining on this chan :]

[21:23] <colomon> in the early days of ng, I think.

[21:23] <TimToady> it's been there for a month or so

[21:23] <masak> huh.

[21:24] <sjohnson> perl 6: surprising devs and users since 2000

[21:24] * CokeBot9000 loads up another coffee mug.

[21:24] <sjohnson> <-- happy

[21:25] <colomon> Huh, blame shows that's been in there a month, but I sure don't remember it being that recent.

[21:25] <TimToady> mind you, it looks like someone implemented it without speccing it

[21:25] *** ignacio_ left
[21:25] <masak> :)

[21:25] <colomon> .oO(whistles quietly to himself, innocently...)

[21:25] <masak> how rogue of someone.

[21:25] <CokeBot9000> sjohnson should totally have to spec it.

[21:25] <masak> +1

[21:26] * CokeBot9000 runs away.

[21:26] <colomon> There's also a comment to the effect that better names for the methods would be nice.  :)

[21:26] <masak> I like the names.

[21:26] <masak> they huffman about right, too.

[21:27] <TimToady> it's just about the smallest bikeshed in the world

[21:27] <masak> 'the smallest bikeshed in the world' would be a good name for a rock band.

[21:27] <TimToady> it sorta violates the notion that built-ins should be short enough not to need - or _ or ::

[21:28] <TimToady> and the notion that those devices are for user-defined stuff

[21:28] <masak> hm, yes.

[21:28] <TimToady> that's my main qualm with the current names

[21:29] <[particle]> use feature <:trim-ends>;

[21:29] <masak> leadtrim, lagtrim :)

[21:29] <masak> or leadtrim, trailtrim, I guess...

[21:29] <TimToady> tr and im

[21:29] <[particle]> trimhead trimtail

[21:29] <masak> TimToady: ewww!

[21:29] <masak> [particle]: no, too listy.

[21:29] <[particle]> in rtl languages that's mi and rt

[21:30] <masak> o.O

[21:30] <[particle]> :)

[21:30] <masak> [particle]: you hurt my brain :)

[21:37] <ash_> "    foo".tl; #=> "foo"; "foo     ".tt; #=> "foo"  

[21:37] <masak> "(You can also think of a thunk as a closure that uses the

[21:37] <masak> +current lexical scope parasitically.)" TimToady++, an description of 'thunk' that I actually think I understand

[21:37] <ash_> where tl is short for trim-leading and tt is short for trim-trailing 

[21:37] <ash_> or not 

[21:38] <masak> too short...

[21:38] <masak> yeah, got that part :)

[21:39] <masak> but .trim is the common one and has four characters.

[21:39] <masak> it feels wrong to give the two less common ones fewer characters.

[21:41] <cognominal> rakudo :   my @t; for  < a b > {  @t.push(  sub { $OUTER::_ } )  }; say $_() for  @t

[21:41] <cognominal> rakudo:   my @t; for  < a b > {  @t.push(  sub { $OUTER::_ } )  }; say $_() for  @t

[21:41] <p6eval> rakudo c41cf3: OUTPUT«Null PMC access in type()␤current instr.: '_block97' pc 692 (EVAL_1:282)␤»

[21:41] * masak submits rakudobug

[21:41] <masak> rakudo: for 1,2 { $OUTER::_ }

[21:42] <p6eval> rakudo c41cf3:  ( no output )

[21:42] <masak> hm.

[21:42] <masak> rakudo: for 1,2 { sub { $OUTER::_ } }

[21:42] <p6eval> rakudo c41cf3:  ( no output )

[21:42] <masak> rakudo: my $a; for 1,2 { $a = sub { $OUTER::_ } }; say $a()

[21:42] <p6eval> rakudo c41cf3: OUTPUT«Null PMC access in type()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:43] <masak> there we go.

[21:43] <masak> cognominal++

[21:43] <cognominal> masak: I am trying to adapt Web/lib/Tags.pm

[21:43] <masak> rakudo: my $a; for 1,2 { $a = sub { say $OUTER::_ }; $a() }

[21:43] <masak> cognominal: nice!

[21:43] <p6eval> rakudo c41cf3: OUTPUT«Null PMC access in type()␤current instr.: '_block64' pc 504 (EVAL_1:208)␤»

[21:43] <cognominal> this should generate routines for tag names and export them

[21:43] <masak> cognominal++

[21:44] <masak> rakudo: (sub { say $OUTER::_ }).()

[21:44] <p6eval> rakudo c41cf3: OUTPUT«Null PMC access in type()␤current instr.: '_block46' pc 300 (EVAL_1:127)␤»

[21:44] <cognominal> so this test was a way to generate a routine.

[21:44] <colomon> that reminds me.

[21:44] <masak> rakudo: { say $OUTER::_ }

[21:44] <p6eval> rakudo c41cf3: OUTPUT«Null PMC access in type()␤current instr.: '_block45' pc 282 (EVAL_1:124)␤»

[21:44] * masak can haz a golfed version

[21:45] <colomon> rakudo: role Animal { method speak() { say "Blah"; } }; role Canine does Animal { method speak() { say "Howl"; }}; 

[21:45] <p6eval> rakudo c41cf3:  ( no output )

[21:45] <colomon> rakudo: role Animal { method speak() { say "Blah"; } }; role Canine does Animal { method speak() { say "Howl"; }}; class Dog does Canine { }

[21:45] <p6eval> rakudo c41cf3:  ( no output )

[21:46] <cognominal> I would like to say something like :    my @t; for  < a textarea > {  @t.push(  sub is :named($OUTER::_) {  "<$OUTER::_>..."  } )  }; say $_() for  @t

[21:46] <colomon> rakudo: role Animal { method speak() { say "Blah"; } }; role Canine does Animal { method speak() { say "Howl"; }}; class Dog does Canine { }; Dog.new.speak

[21:46] <p6eval> rakudo c41cf3: OUTPUT«Could not find sub &say␤current instr.: 'perl6;Canine[];speak' pc 972 (EVAL_1:377)␤»

[21:47] <colomon> :\

[21:47] <masak> colomon: that seems wrong.

[21:47] <cognominal> masak, I don't think define a way to name an anonymous routine. 

[21:47] <cognominal> *Perl defines

[21:47] <masak> cognominal: in a parametric way? hm, use &eval?

[21:48] <cognominal> I hate eval

[21:48] <masak> cognominal: that's your problem :)

[21:48] <masak> it's a solution in this case.

[21:49] <ash_> cognominal: is that perl 5 or 6? 

[21:49] <colomon> masak: my code or Rakudo's response?

[21:49] <cognominal> not a clean one because ones parses as many times as there are tags to define.

[21:49] <masak> ash_: it's Web.pm, so Perl 6.

[21:49] <masak> colomon: Rakudo's not finding &say.

[21:49] <masak> colomon: perhaps a result of jnthn's refactors today.

[21:50] <masak> cognominal: unless you put together all the strings and eval at the end.

[21:50] <cognominal> rakudo: BEGIN { say "toto" }  # masak you mean that?

[21:50] <p6eval> rakudo c41cf3: OUTPUT«Could not find sub &say␤current instr.: '_block11' pc 0 (EVAL_1:9)␤»

[21:50] <masak> that seems wrong too.

[21:51] <masak> but perhaps a bit more expected, given that I know that the setting is loaded at CHECK time :P

[21:51] <masak> &say in methods in roles, however, should work fine.

[21:51] <cognominal> anyway I can do with eval. Right now I want Web.pm to run not to be elagant. Masak I will keep you   posted

[21:52] *** Su-Shee left
[21:52] <masak> cognominal: excellent.

[21:52] <colomon> rakudo: role Animal { method speak() { say "Blah"; } }; class Dog does Animal { }; Dog.new.speak

[21:52] <p6eval> rakudo c41cf3: OUTPUT«Could not find sub &say␤current instr.: 'perl6;Animal[];speak' pc 575 (EVAL_1:222)␤»

[21:52] <masak> I also would prefer it running rather than elegant.

[21:52] <colomon> masak: I was actually trying to duplicate the bug I got working on Numeric / Real a few days ago.

[21:53] <masak> rakudo: class Dos { method speak() { say "Blah"; } }; Dog.new.speak

[21:53] <colomon> I seem to have found an entirely different bug in the process. 

[21:53] <p6eval> rakudo c41cf3: OUTPUT«Could not find sub &Dog␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:53] <masak> rakudo: class Dog { method speak() { say "Blah"; } }; Dog.new.speak

[21:53] <p6eval> rakudo c41cf3: OUTPUT«Blah␤»

[21:53] <masak> colomon++

[21:53] <masak> colomon: care to submit it to RT? or shall I?

[21:53] <colomon> be my guest, I need to get back to packing.  ;)

[21:53] * masak submits

[21:54] <colomon> masak++

[21:56] <arnsholt> Is the interface to nqp-rx's operator precedence parser documented anywhere (beyond the code)?

[21:57] <masak> arnsholt: doubt it.

[21:58] <masak> arnsholt: sounds like you're volunteering to... :)

[21:59] <arnsholt> masak: Well, for the moment there's my development diary of Parrotlog

[21:59] <arnsholt> But to write the docs I have to figure out how the interface works in the first place... =)

[21:59] <arnsholt> But the thought has occured to me, yeah

[22:00] <arnsholt> Incidentally, do you know when I was given a commitbit to the nqp-rx repo on GitHub? I didn't know I had it until I discovered it by accident earlier today ^^

[22:02] <masak> no, I don't know :)

[22:02] <masak> arnsholt: I do know how the corresponding API works in PGE, and I'd guess that they might be similar.

[22:02] <masak> arnsholt: if it helps, feel free to ask me, or to look at the GGE source.

[22:02] <masak> s/or/and/

[22:04] <arnsholt> Right now I'm looking at Partcl-nqp, which is looking promising

[22:05] <masak> ok.

[22:05] <arnsholt> Or, possibly not

[22:06] <masak> huh.

[22:07] <ash_> arnsholt: nqp-rx's operator precedence comes directly from perl 6, its almost identical to rakudo and/or STD.pm 

[22:07] <ash_> so you know

[22:07] <arnsholt> Yeah, I'm looking at the Rakudo source as well

[22:08] <arnsholt> But Rakudo is pretty large, so I haven't been able to extract a whole lot of info yet

[22:09] <ash_> you know where thats set right? 

[22:09] <arnsholt> But the bit about STD.pm is good, thanks!

[22:11] <ash_> http://github.com/perl6/nqp-rx/blob/master/src/NQP/Grammar.pm#L421 is where it starts, its in the Grammar.O method that it happens 

[22:11] <mberends> I'm planning to make proto into Perl6::Proto::Installer, a Perl 5 module on CPAN. Any comments on that general idea?

[22:11] <ash_> will it auto install rakudo? 

[22:12] <mberends> yes, with some opportunity for overriding default settings

[22:12] <mberends> it will also use your existing Rakudo if  found in $PATH

[22:12] *** Logo left
[22:13] <mberends> (you would actually tell it to install Rakudo with one command)

[22:14] <masak> mberends: today it sounds like a rather good idea :)

[22:14] *** Guest83313 left
[22:15] *** wknight8111 joined
[22:15] <mberends> the idea has been forming for a few days, I don't want to create something that clashes in some unexpected way

[22:15] <ash_> arnsholt: the O function is defined in the cheats, btw. 

[22:15] <masak> mberends: I don't know how strictly categorized the Perl6:: category is, but most of it actually contains Perl 5 code emulating Perl 6 behaviour.

[22:16] <masak> mberends: perhaps better to just go with App::Proto or something.

[22:17] <mberends> masak: I know, hence my question. I would rather have a P6:: namespace though. OTOH, proto *is* Perl 5 based.

[22:17] <ash_> arnsholt: in src/cheats/hll-grammar.pir there is an overview of the O function for defining precedence 

[22:18] <masak> mberends: yeah, but not with the aim to do Perl 6-y stuff in Perl 5.

[22:18] <masak> at least not in the usual way :)

[22:18] <mberends> sure, it's a borderline case. We have to think how Perl 6 will relate to CPAN overall.

[22:21] <masak> I'd rather it didn't cram itself into a Perl6:: namespace.

[22:21] *** ash_ left
[22:21] <masak> particularly one that's already taken by a slightly different category.

[22:21] <mberends> ok, before finalizing that decision, I also want to continue some of the trials moritz_++ did with packaging Perl 6 software into CPAN.

[22:23] <mberends> fair enough to leave Perl6:: alone because of existing usage, I respect that

[22:23] <mberends> P6::  or p6:: ?

[22:25] <masak> what's the danger of not marking up the different lineage at all in the name?

[22:26] <masak> you know, as we haven't done with Perl 6 applications outside of CPAN? :)

[22:27] <mberends> if you mean a namespace hierarchy, it's just convention

[22:28] <masak> I bet people are going to do it in all possible ways no matter what I think :) but I don't feel it's necessary to say 'by the way, this is Perl 6' in the namespace itself.

[22:29] <mberends> I do, doubly so when Perl 6 is the purpose of the software

[22:29] <masak> well, there is that.

[22:29] <mberends> Also, the CPAN administration can more easily make special for Perl 6 software if it is clearly tagged

[22:30] <mberends> *special cases

[22:30] *** SmokeMachine left
[22:30] <mberends> there does need to be special treatment because of different testing, versioning, etc

[22:31] <masak> didn't someone actually publish a pure Perl 6 module to CPAN (which rendered incorrectly, etc)? who was it, and what's the module?

[22:31] <mberends> moritz_++

[22:31] <mberends> he blogged about the outcome, don't remember more right now

[22:32] <masak> http://search.cpan.org/~moritz/JSON-Tiny-0.1.2_1/

[22:32] <masak> that's gotta be the one.

[22:32] <mberends> yes

[22:32] <masak> moritz_++

[22:32] <masak> mberends: note the lack of Perl6:: prefix on the module name.

[22:33] <mberends> masak: that does not mean it's good precedent

[22:33] <masak> true.

[22:33] <masak> but it means that the only Perl 6 module actually on CPAN right now does not follow the proposed scheme :)

[22:33] <mberends> I want comment from a few more people before firming up decisions

[22:34] <masak> nod.

[22:34] <mberends> this is not a JFDI matter

[22:34] <masak> perhaps ask on #toolchain on irc.perl.org...

[22:34] <masak> I *think* that's a suitable forum.

[22:36] <mberends> I won't have time today or tomorrow, I hope the #perl6 members will chip in by Wednesday

[22:38] <lue> oh hai everybody

[22:38] <mberends> anyhow, baby steps... with only one or two uploads, a bad can be undone

[22:39] <mberends> oh hai lue

[22:39] <lue> YOU_ARE_HERE.pm looks interesting...

[22:40] <masak> hai lue.

[22:42] <masak> lue: apparently YOU_ARE_HERE.pm is a module so it'll fit into the pattern of the rest of the core/setting.

[22:43] <lue> all it says is YOU_ARE_HERE;

[22:43] <masak> lue: yes. you can read about that in the spec

[22:44] *** ruoso joined
[22:45] <lue> Nice work on Temporal.pm, as far as I can see. Glad I didn't write it, I don't even know what bless does :D

[22:45] <masak> lue: have you ever considered how obbject is formed?

[22:46] <masak> sorry 'how is obbject formed', I mean.

[22:47] <lue> I don't come from Perl 5, and never *really* dealt with classes, so I don't.

[22:48] <bkeeler_> they need to do way instain metaclass

[22:50] *** xabbu42 joined
[22:51] <sjohnson> any of you guys ever heard of a TV show called Chuck?  the camel book was shown on that tv show

[22:51] *** masak left
[22:51] *** nihiliad left
[23:09] * lue wonders if the spec would make a good wikibook...

[23:09] *** Logo joined
[23:17] *** xabbu42 left
[23:22] *** astrojp joined
[23:24] <cognominal> rakudo:   my %a ; %a<toto>='tata'; my $a = \%a; say $a<toto>

[23:24] <p6eval> rakudo c41cf3: OUTPUT«Null PMC access in type()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:25] *** hanekomu left
[23:25] <cognominal> I probably don't master Perl 6 references :(

[23:26] <TimToady> rakudo: my a; %a<toto>='tata'; my $a = %a; say $a<toto>

[23:26] <lue> rakudo: my %a; %a<toto>='tata'; my $a := %a; say $a<toto>

[23:26] <p6eval> rakudo c41cf3: OUTPUT«Malformed my at line 11, near "a; %a<toto"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[23:26] <colomon> sjohnson: My wife and I follow Chuck.

[23:26] <p6eval> rakudo c41cf3: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17293 (src/builtins/Junction.pir:404)␤»

[23:26] <TimToady> rakudo: my %a; %a<toto>='tata'; my $a = %a; say $a<toto>

[23:26] <p6eval> rakudo c41cf3: OUTPUT«tata␤»

[23:26] <TimToady> don't need the \

[23:26] <cognominal> nice

[23:27] <cognominal> thx

[23:27] *** ShaneC joined
[23:27] <pugssvn> r30324 | mberends++ | [S32-temporal/Temporal.t] revise all the remaining 11 tests to new spec 

[23:28] <cognominal> need sleep. Almost got Web to go past the listen and treat a request..

[23:28] <TimToady> basically, everything is already a reference

[23:28] <TimToady> so there's not much point in thinking about references explicitly

[23:31] <lue> What's the difference, then, between = and :=?

[23:31] <dalek> rakudo: 3b1d348 | (Martin Berends)++ | src/core/Temporal.pm:

[23:31] <dalek> rakudo: [core/Temporal.pm] minor changes to pass all 17 existing tests - more required

[23:31] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3b1d348364a4c0b0717eda180c9573f61285e779

[23:32] <cognominal> rakudo: say "a" . "a"

[23:32] <p6eval> rakudo c41cf3: OUTPUT«Confused at line 11, near "say \"a\" . "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[23:32] <sjohnson> colomon: i believe it was the 3-D ep of season 2 of Chuck with had Programming Perl above his bed

[23:32] <lue> \o/ mberends++

[23:32] <sjohnson> i was impressed

[23:32] <cognominal> rakudo: say( "a" . "a" )

[23:32] <p6eval> rakudo c41cf3: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[23:33] <TimToady> := simply copies a reference to somewhere that holds a reference.  = looks for container objects on its left and stuffs them with copies of whatever if has on its right, for some definition thereof

[23:33] *** xuser joined
[23:33] <TimToady> s/if/it/

[23:34] <TimToady> = is more about value semantics

[23:34] <cognominal> yea but := is not there yet on rakudo

[23:34] <lue> So if I wanted two spots in an array to be bound to the same number in the same location, would I use := ? (that's what I've always thought)

[23:35] <TimToady> yes

[23:35] <TimToady> := merely makes new aliases, hence parameter passing is built primarily on binding semantics

[23:35] <mberends> afk & # sleep

[23:35] <lue> Good. It's one of the two reasons I switched from Python: references and switch statements.

[23:36] <TimToady> o/

[23:36] <lue> goodnight o/

[23:36] <mberends> o/

[23:36] <cognominal> good night all.

[23:36] <lue> o/

[23:37] <TimToady> my o key is feeling vertiginous, like it's leaning to the side...

[23:38] <lue> .u right

[23:38] <phenny> U+22A2 RIGHT TACK (⊢)

[23:45] <frettled> as long as it's not too tacky

[23:45] <frettled> .u tack

[23:45] <phenny> U+22A5 UP TACK (⊥)

[23:45] <frettled> .u tacky

[23:45] <phenny> frettled: Sorry, no results for 'tacky'.

[23:45] <frettled> phew

[23:46] *** hercynium joined
[23:47] <lue> TimToady: is there any way to represent the range of all real numbers ℝ in Perl 6 yet, or is that NYS?

[23:49] <TimToady> get real :)

[23:50] <TimToady> by which I mean, I'm not interested in compteing with Mathematica.

[23:50] *** jhuni joined
[23:50] <TimToady> *competing

[23:50] <lue> be rational! :)

[23:50] <TimToady> too late!

[23:51] <lue> .oO(There must be a way)

[23:52] <TimToady> .oO(if Perl 6 becomes the language of choice of mathematicians, it will almost by definition *not* be the language of choice for anyone else...)

[23:52] <lue> A-hah! But it must be possible, as stated by the motto of the language!

[23:53] <TimToady> ask your average programmer what ℝ is and they'll just look at you funny

[23:53] <TimToady> that's one of those things I'll try to keep hard. :)

[23:53] <frettled> I'll look at you funny anyway, since that's something I'd expect to find in Mathematica et al.

[23:54] <frettled> possibly Mathlab and Singular, too ;)

[23:54] <lue> But Mathematica is not open-source, is it not?

[23:55] <frettled> No, see Sage for that.

[23:55] <frettled> http://www.sagemath.org

[23:56] <TimToady> but I'll tell you what.  if you define ℝ and a .ACCEPTS method for it, then you can ~~ ℝ to your heart's content.

[23:56] <frettled> I didn't know about Magma, heh.

[23:56] <frettled> lue: some people also use Octave, but I don't believe that is FOSS.

[23:57] <TimToady> I've never tried FOSS, I hear it's a pretty good app...

[23:57] <frettled> Oh, my mistake, it very much IS that, it's on gnu.org :)

[23:57] * frettled blushes appropriately.

[23:57] <lue> Freed by Larry, Open Source Software (FLOSS)

[23:58] <TimToady> I should use FLOSS more often...

[23:58] *** [particle] left
[23:58] *** rgrau left
[23:58] <lue> OOF (Object-Oriented Failure)

[23:58] <frettled> That's a good good-night note for me. :)

[23:59] <TimToady> OOF is spelled FOO in France.

[23:59] <ruoso> lue, it has been thought before that a "use Math::Symbols" would enable all the unicode math zoo

[23:59] <TimToady> s/thought/thought with horror/

