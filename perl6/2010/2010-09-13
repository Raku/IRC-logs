[00:00] *** qw3rty joined
[00:01] <lue> afk

[00:09] *** qw3rty left
[00:16] *** Quadrescence left
[00:22] *** Ross joined
[00:26] *** qw3rty joined
[00:30] *** roelos joined
[00:31] *** roelos left
[00:36] *** Ross left
[00:52] *** grapa joined
[00:59] *** alksentrs left
[01:01] *** grapa left
[01:03] *** vastak joined
[01:07] *** whiteknight left
[01:12] <dalek> specs: a877659 | TimToady++ | S03-operators.pod:

[01:12] <dalek> specs: move := and ::= to correct precedence section

[01:12] <dalek> specs: 

[01:12] <dalek> specs: tylercurtis++ noticed they were still in the item assignment section

[01:12] <dalek> specs: despite having been redefined as listop precedence.

[01:13] <dalek> specs: review: http://github.com/perl6/specs/commit/a877659a28884f898b84e0b4d0ae1fbfc650cfd9

[01:18] *** molaf_ joined
[01:22] *** molaf left
[01:25] *** meppl joined
[01:28] *** Schwern left
[01:43] *** flatwhatson left
[01:46] *** QinGW joined
[01:51] *** leprevost left
[01:55] *** flatwhatson joined
[01:56] *** Schwern joined
[02:14] <sorear> good * #perl6

[02:24] *** brxue joined
[02:33] *** lue left
[02:33] *** lue joined
[02:43] *** aloha left
[02:44] *** bacek left
[02:50] *** envi^home joined
[02:51] *** drbean left
[02:51] *** meppl left
[02:52] *** drbean joined
[02:54] *** petdance joined
[03:01] *** orafu left
[03:01] *** orafu joined
[03:05] *** patspam joined
[03:12] <sorear> seen jnthn

[03:14] *** sftp left
[03:15] <TimToady> not since Pisa

[03:16] <sorear> TimToady: what are the rules on 'supercede method ACCEPT'?

[03:18] <TimToady> well, if you supersede something that has already been used, you get what you pay for :)

[03:19] <TimToady> and to my mind ACCEPTS is pretty low level

[03:19] <sorear> how does "used" factor in?

[03:19] <sorear> normally I think of method calls not being fully resolved until runtime

[03:20] <sorear> but the given -> jumptable transformation relies on compile-time knowledge of ACCEPTS

[03:20] <TimToady> indeed

[03:20] <TimToady> smart matching is intended to be optimizable.

[03:21] <TimToady> it might even make sense to turn ACCEPTS into a multi with lexical scope

[03:22] <TimToady> the sort of dispatch that only cares about the pattern argument

[03:23] * sorear has a certain fondness for the CLOS notion of "there are no methods, only our multi sub"

[03:23] <TimToady> if push comes to shove, I'm quite willing to make ACCEPTS a don't-touch primitive for optmizability

[03:23] <TimToady> when 1 has to know its semantics

[03:25] <TimToady> alternately though, it might be possible to decide teh semantics of ACCEPTS at CHECK time, and then optimize 'em

[03:28] *** Guest27047 left
[03:35] <sorear> rakudo: my ($foo) = (1 .. *).flat; say $foo;

[03:35] <p6eval> rakudo 9993bb: OUTPUT«1␤»

[03:40] *** vastak left
[03:45] *** Schwern left
[03:50] *** patspam left
[03:56] <dalek> niecza: 6679769 | sorear++ | / (5 files):

[03:56] <dalek> niecza: Implement Match object generation

[03:56] <dalek> niecza: review: http://github.com/sorear/niecza/commit/66797696411c57a57afcd3097eb61056210917a2

[04:01] <sorear> Do I need to distinguish / $0 = [ x ] / from / $<0> = [ x ] /?

[04:01] <TimToady> no

[04:04] <tylercurtis> Wow. EXPR is scary.

[04:04] <TimToady> just a couple loops around a lambda... :)

[04:05] <sorear> The Perl 6 one in STD, or the PIR one in NQP?

[04:05] <sorear> IMO the latter is scarier ;)

[04:06] <tylercurtis> sorear: good point. :)

[04:39] *** QinGW left
[04:40] *** QinGW1 joined
[04:42] *** kjeldahl joined
[04:46] <sorear> Should I have a MONKEY_TYPING.pm6?  Or should I handle the use entirely in the compiler?

[04:47] <ash_> i image its more a compiler thing, or you could make it lexically scoped subs? would that work? 

[04:48] <TimToady> I suppose that depends on whether someone wants to monkey with MONKEY_TYPING.  :)

[04:48] <TimToady> (I'm fine with it in the compiler)

[04:50] *** kjeldahl left
[04:59] *** kaare joined
[04:59] *** kaare is now known as Guest98246

[05:09] *** meppl joined
[05:28] *** qw3rty left
[05:29] *** ash_ left
[05:37] *** Guest98246 is now known as kaare_

[05:50] *** petdance left
[05:57] *** plobsing left
[05:57] *** wtw joined
[06:05] *** c1sung joined
[06:09] *** uniejo joined
[06:13] *** baest joined
[06:16] *** masak joined
[06:16] <masak> oh hai, #perl6!

[06:17] <TimToady> ohaio/

[06:18] <tylercurtis> \o, masak

[06:19] <TimToady> I whacked on http://rosettacode.org/wiki/Number_reversal_game#Perl_6 some in kind of an interesting way

[06:21] <masak> oh! it's Bill Gates' pancake flipping algorithm :)

[06:23] <sorear> hello masak!

[06:23] * tylercurtis wonders, whenever reading discussion of naming conventions, whether he is the only person whose little finger hurts when using lots of underscores and capitals in variable/function names.

[06:23] * TimToady blames emacs

[06:23] * sorear wonders about <foo=!bar>

[06:24] * TimToady wonders about sourear

[06:24] <masak> @jumbled-list[^$d] .= reverse; # this works? awesome!

[06:24] <TimToady> *sorear

[06:24] <TimToady> and it was in the original, so I can't claim it

[06:24] <TimToady> well, I took out the spurious ()

[06:25] <masak> :)

[06:25] <masak> rakudo: my @a = 1..10; @a[^4].=reverse; say @a.perl

[06:25] *** brxue left
[06:25] <p6eval> rakudo 9993bb: OUTPUT«[4, 3, 2, 1, 5, 6, 7, 8, 9, 10]␤»

[06:25] <masak> \o/

[06:27] <TimToady> rakudo: my @a = 1..10; @a[0,2...8] .= reverse; say @a.perl

[06:27] <p6eval> rakudo 9993bb: OUTPUT«[9, 2, 7, 4, 5, 6, 3, 8, 1, 10]␤»

[06:27] <diakopter> sour ear

[06:29] <diakopter> "not half unreadable once you get used to it". :)

[06:33] <diakopter> kamsa: uhoi

[06:34] <masak> I'm looking at the "declare variable in a postponed piece of code" idiom, and I just know I'll be using it a lot.

[06:35] <TimToady> yeah, did it the other day with a given

[06:35] <sorear> you mean like END my $x = 5; ?

[06:36] * diakopter wonders what chunk of all Perl 6 code ever executed (excluded the roast) has gone through p6eval

[06:36] <masak> sorear: that's another place where it's possible.

[06:37] *** mberends left
[06:37] <masak> sorear: I can imagine using that one in one-liners. or more likely BEGIN my $sum = 0;

[06:37] <sorear> masak: whart is "the idiom"?

[06:37] <TimToady> see for example the link I just pasted

[06:37] <masak> sorear: see TimToady's last few Rossetta Code entries.

[06:38] <masak> sorear: the general pattern is that you declare a variable at a place in the code that is textually earlier but dynamically later than its first use/assigment.

[06:39] <sorear> I see

[06:39] <TimToady> http://rosettacode.org/wiki/Constrained_Random_Points_on_a_Circle#Perl_6 is the most egregious

[06:40] <TimToady> 2nd example

[06:40] <sorear> generally speaking niecza interprets foo my @x; as foo (ENTER { @x_slot := Array.new }, @x)

[06:45] <dukeleto> howdy

[06:48] *** qwebirc62872 joined
[06:48] <tylercurtis> Hello.

[06:48] <sorear> 2hello.

[06:49] <TimToady> \ohaio

[06:49] <masak> 4hello.

[06:50] <tylercurtis> rakudo: my $foo = 'perl'; say 5.$foo;

[06:50] <p6eval> rakudo 9993bb: OUTPUT«invoke() not implemented in class 'Perl6Str'␤  in main program body at line 22:/tmp/6TcBc8mMo5␤»

[06:50] *** kjeldahl joined
[06:52] *** s1n joined
[06:55] <dukeleto> tylercurtis: what error would you expect?

[06:59] <tylercurtis> dukeleto: I was expecting either a message saying you can't do that or for it to call 5.perl.

[07:02] <tylercurtis> STD expects it to call 5.perl(well, more accurately, it expects q[my $termish = 'termish'; $here.$termish] to call $here.termish).

[07:05] <sorear> that's probably Perl 5 leaking through

[07:06] <sorear> see S12:338 and S12:308

[07:06] <sorear> the correct form is $here."$termish"

[07:07] *** cjk101010 joined
[07:08] <tylercurtis> sorear: is viv incapable of handling $here."$termish"(), or should the instances of .$foo where $foo is a string in STD be removed?

[07:09] <sorear> tylercurtis: it would probably not be hard to add $here."$termish" support to viv

[07:10] *** tadzik joined
[07:11] *** Ross joined
[07:16] *** Ross left
[07:16] *** Ross joined
[07:27] *** bacek joined
[07:27] <tadzik> hello hello

[07:28] <sorear> hello

[07:28] <sorear> seen aloha

[07:28] *** Ross left
[07:30] *** aloha joined
[07:34] *** Sanitoeter left
[07:35] <tylercurtis> What's with the outdent on http://github.com/perl6/std/blob/master/STD.pm6#L4632?

[07:36] <moritz_> $a.$b takes $b as a code ref

[07:37] *** ssm left
[07:39] <sorear> Match generation is now fully working in niecza... 2x perf regression

[07:40] <sorear> oh, interesting, it's only a 10% regression with mono-sgen

[07:40] <dalek> niecza: ba15f79 | sorear++ | / (6 files):

[07:40] <dalek> niecza: Implement basic augment syntax

[07:40] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ba15f796d2b47d9fcdaeb1653bfd71edd4ef4709

[07:40] <dalek> niecza: bedd19a | sorear++ | / (3 files):

[07:40] <dalek> niecza: Implement {Match,Cursor}.at-{key,pos}

[07:40] <dalek> niecza: review: http://github.com/sorear/niecza/commit/bedd19a7f5abfc578c8ae9a4d6afa1cdbcfe6ab1

[07:40] <dalek> niecza: 064e443 | sorear++ | / (6 files):

[07:40] <dalek> niecza: Implement capturing for quantifiers and protoregexes

[07:40] <dalek> niecza: review: http://github.com/sorear/niecza/commit/064e443fda325a34508ad68acf7a29329215ed41

[07:40] <tylercurtis> Precise GC! \o/

[07:41] <sorear> tylercurtis: \o/

[07:41] <tylercurtis> Also generational GC! \o/

[07:43] <tylercurtis> Actually, sgen is not fully precise according to http://developers.sones.de/2010/09/01/taking-the-new-and-shiny-mono-simple-generational-garbage-collector-mono-sgen-for-a-walk/ "stacks and registers are scanned conservatively"

[07:43] *** tadzik left
[07:43] <tylercurtis> So, mostly-precise GC! \o/

[07:45] <tylercurtis> EXPR seems much easier to understand if I read the loop first. (and hopefully &reduce will be easier to understand once I better understand when it is called in the loop).

[07:51] <sorear> I've been using sgen for a couple weeks now

[07:52] <sorear> it's usually a bit faster, but the 2x speed difference with the current niecza is... unexpected

[08:00] <tylercurtis> Good night, #perl6! Tomorrow, I will hopefully find time to finish reading EXPR so I can start adding the appropriate actions to Bennu.

[08:01] *** timbunce joined
[08:08] *** tylercurtis left
[08:08] *** f00li5h left
[08:10] *** daxim joined
[08:12] <dukeleto> perl6: say NaN.Rat

[08:12] <p6eval> rakudo 9993bb: OUTPUT«-9.22337203685478e+18␤»

[08:12] <p6eval> ..pugs: OUTPUT«*** No such method in class Num: "&Rat"␤    at /tmp/gLwvJ5y5tF line 1, column 5 - line 2, column 1␤»

[08:12] <sorear> cute

[08:13] <dukeleto> i assume NaN.Rat should be NaN

[08:16] *** sjn joined
[08:18] *** f00li5h joined
[08:23] *** meteorjay joined
[08:24] <dukeleto> perl6: say 1i.Rat

[08:24] <p6eval> rakudo 9993bb: OUTPUT«Method 'Rat' not found for invocant of class 'Failure'␤  in 'Rat' at line 2938:CORE.setting␤  in main program body at line 22:/tmp/mA0cNsDkHB␤»

[08:24] <p6eval> ..pugs: OUTPUT«0 + 1i␤*** No such method in class Bool: "&Rat"␤    at /tmp/HCjzmRZJyB line 1, column 1 - line 2, column 1␤»

[08:25] *** azert0x joined
[08:25] <dukeleto> what should 1i.Rat actually complain about?

[08:25] <dalek> roast: 2f690f9 | leto++ | S32-num/rat.t:

[08:25] <dalek> roast: [S32-num] Add fudged test for NaN.Rat

[08:25] <dalek> roast: review: http://github.com/perl6/roast/commit/2f690f94accf8f591a35bbadd339fe4d82ad012d

[08:27] *** rcfox_ left
[08:29] *** rcfox joined
[08:31] <sorear> today's fun idiom: { say $/.pos } <!>

[08:40] *** dakkar joined
[08:41] <masak> prints, shoots, and backtracks.

[08:42] <dalek> roast: 326ee0a | leto++ | S32-num/rat.t:

[08:42] <dalek> roast: [S32-num] Add some tests for Rat representation of Inf

[08:42] <dalek> roast: review: http://github.com/perl6/roast/commit/326ee0a072ef21ccbd5f696667c87e2d125f29bf

[08:44] <dalek> niecza: 88f2d4b | sorear++ | src/ (2 files):

[08:44] <dalek> niecza: More efficiently handle protoregexes that don't backtrack

[08:44] <dalek> niecza: review: http://github.com/sorear/niecza/commit/88f2d4bbc502768a96ddf5c9bacdc89ef6bfebdb

[08:44] <dalek> niecza: e0c8d34 | sorear++ | lib/Kernel.cs:

[08:44] <dalek> niecza: Avoid method dispatch calling Sub subclasses

[08:44] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e0c8d3449fdc250b2f56ed679335b9cee64f9785

[08:45] <jnthn> morning, #perl6

[08:47] <masak> morning \o/

[08:47] * masak streches a bit o /o/

[08:51] <masak> s/ch/tch/

[08:52] *** thebird joined
[08:52] * jnthn stresses a bit

[08:54] <sorear> hello jnthn 

[08:54] *** meppl left
[08:55] <sorear> jnthn: I need a nice thread-friendly way of handling dispatch caches

[08:56] <jnthn> sorear: Generally, I guess you want those to be fast to read, primarily.

[08:56] <jnthn> sorear: I've not tested it yet, but in the 6model repo there's a sketched out multi dispatch catch

[08:56] <jnthn> *cache

[08:57] <jnthn> sorear: It uses an immutable/lock-free data structure approach to avoid locking, so it should have pretty good concurrency characteristics.

[09:00] *** bacek left
[09:01] <sorear> method dispatch is a hotspot in niecza

[09:02] <sorear> foreach (DynMetaObject k in GetMO().mro) {

[09:02] <sorear>   if (k.methods.TryGetValue(name, out method)) {

[09:02] <sorear>     // call it

[09:02] <sorear> I'd love to flatten that loop, by creating a flat method dispatch table per class at compose time

[09:03] <sorear> but you can add methods to Any at runtime

[09:03] <jnthn> That's fine

[09:03] <jnthn> They just don't make it into the flat table

[09:03] *** bacek joined
[09:03] <jnthn> We don't have to make augment efficient.

[09:04] <sorear> What if I use augment to replace an existing method?

[09:04] <jnthn> Then the table can be updated with the replacement.

[09:04] <sorear> (also, my Any is defined as an empty class in very low-level code and is augmented about four times in the setting, but that could probably be changed)

[09:04] <jnthn> It's not that the table is never re-built

[09:04] <masak> http://blogs.perl.org/users/flavio_s_glock/2010/09/perlito-perl6-in-net.html

[09:04] <jnthn> It's more that the set of entries stays the same.

[09:05] <sorear> it's the re-building that seems problematic to me

[09:05] <sorear> with threads involved

[09:06] <jnthn> sorear: Maybe build a new one, and then CAS it in place; if you got beat, try again.

[09:07] <sorear> ...

[09:07] <sorear> HOW COULD I HAVE FORGOTTEN CAS

[09:08] <jnthn> ;-)

[09:08] <jnthn> System.Threading.Interlocked class in .Net, fwiw.

[09:08] <sorear> yeah

[09:08] * masak hastily googles CAS

[09:08] * sorear reads jnthn's latest blog

[09:09] <jnthn> masak: Min concurrency model e CAS...

[09:09] <masak> jnthn++! # groan

[09:10] <jnthn> sorear: http://github.com/jnthn/6model/blob/master/dotnet/runtime/Runtime/MultiDispatch/DispatchCache.cs # the MultiDispatch cache I sketched out

[09:10] <masak> now niecza *has* to use CAS... :)

[09:10] <sorear> In other news, niecza has now reached its goal of "10 times faster than viv" on the JSON-Tiny benchmark

[09:10] <masak> sorear++

[09:11] <jnthn> sorear++ # nice!

[09:11] <jnthn> masak: 6model already is :-)

[09:11] <sorear> I'd like to steal as much 6model stuff as I can...

[09:11] <jnthn> Remember to send bug fixes upstream... ;)

[09:11] <sorear> (note: this will help you too)

[09:11] <jnthn> But, welcome. :-)

[09:11] <jnthn> sorear: You're welcome to a 6model commit bit too, if that'll help.

[09:12] <masak> I look forward to the day when we're comparing something like niecza to Rakudo, going "speed, or features?"

[09:13] <sorear> may I have an ORIENTATION or HACKING to go along with the README? :)

[09:13] * sorear is looking at 6model

[09:14] <jnthn> sorear: That's...a nice idea. I should really write one.

[09:14] <masak> HACKME

[09:15] <sorear> I should write a new one too

[09:15] <jnthn> lol

[09:15] <jnthn> masak: I so want to call it that now :P

[09:15] <sorear> I hat one but it got pretty outdated :/

[09:15] <masak> jnthn: I think you should.

[09:17] <jnthn> Well, I do have a loooong train journey tomorrow. And another one on Wednesday. :-)

[09:18] <sorear> 100us per loop iteration hmm

[09:18] <masak> that time unit is not something that comes up a lot in here. :)

[09:20] <sorear> I can't type \mu currently

[09:20] <sorear> I should be able to fix this, but XKB confuses me

[09:21] *** gottreu left
[09:21] <masak> μ # courtesy of Emacs :)

[09:21] <masak> (I switched to TeX input mode and literally typed '\mu')

[09:21] <masak> Emacs++

[09:22] * sorear wonders how likely a niecza program is to use 2^64 different method names in its lifetime

[09:22] <masak> in toto or per class? :)

[09:23] <sjn> µ (AltGr-m on my keyboard)

[09:23] <sorear> .u µ

[09:23] <phenny> U+00B5 MICRO SIGN (µ)

[09:23] <sorear> .u μ

[09:23] <phenny> U+03BC GREEK SMALL LETTER MU (μ)

[09:23] <sjn> .u µ

[09:23] <phenny> U+00B5 MICRO SIGN (µ)

[09:23] <sjn> huh

[09:24] <sorear> do they look the same to you?

[09:24] <sjn> they do

[09:24] <masak> here as well.

[09:24] <jnthn> Look slightly different on my font.

[09:24] <sorear> slightly different here.

[09:24] * sjn learned something new today :)

[09:25] * masak too

[09:25] <jnthn> How aµsing.

[09:25] <sjn> heheh

[09:25] <sorear> .u HIRIGANA SYLLABLE MU

[09:25] <phenny> sorear: Sorry, no results for 'HIRIGANA SYLLABLE MU'.

[09:25] <sorear> .u HIRIGANA LETTER MU

[09:25] <phenny> sorear: Sorry, no results for 'HIRIGANA LETTER MU'.

[09:25] <jnthn> sjn: I hear there's a Perl 6 event in Oslo tomorrow... ;-)

[09:26] *** goksie joined
[09:26] <sorear> .u HIRAGANA LETTER MU

[09:26] <phenny> U+3080 HIRAGANA LETTER MU (む)

[09:26] <sjn> jnthn: trying to get more people involved :)

[09:26] <sorear> that's a cooler mu, IMO

[09:26] <masak> indeed.

[09:27] <jnthn> sjn: :-)

[09:27] * sjn goes for some br^H^Hlunch

[09:32] <mathw> o/

[09:35] <masak> \o

[09:35] <daxim> ム  it's private.  厶

[09:36] <sorear> What's the first one?

[09:36] <daxim> katakana mu

[09:37] <masak> \㋡/

[09:37] <daxim> like in ゲーム

[09:37] <sorear> no, the second is katakana mu

[09:37] <sorear> er wait sorry

[09:37] <sorear> asked backward

[09:37] <sorear> what's the second?

[09:39] <daxim> private

[09:39] <daxim> know your radicals

[09:39] *** meppl joined
[09:39] <daxim> modern form is 私

[09:40] *** tadzik joined
[09:40] <masak> ooh. goes for hanzi too, it seems.

[09:40] <masak> perhaps not too surprising.

[09:53] *** ruoso left
[10:03] *** QinGW1 left
[10:08] *** Mowah joined
[10:41] *** jhuni joined
[10:51] *** brxue joined
[10:52] *** svetlins left
[10:54] <brxue> hello, I compiled perl6 rakudo star just now, It seems perl6 cost about 1 or 2 seconds to start up?

[10:54] <brxue> I mean the time between enter 'perl6' and it pops up '>'

[10:55] <jnthn> brxue: Yes, Rakudo startup is currently around that order of magnitude. 

[10:55] <masak> depends on your machine, but yes, it sounds about right.

[10:55] *** Kodi joined
[10:56] <jnthn> brxue: It should improve drastically.

[10:57] <jnthn> brxue: We have to build a load of stuff at startup at the moment that, in the future, we'll build at compile time, serialize and then just need to deserialize at startup. Should give quite a win, but it's kinda hard to get right. :-)

[10:58] <brxue> oh, thanks for your explaination

[10:59] <brxue> anyway, perl6 is so exciting

[11:10] *** goksie left
[11:10] <masak> we think so too :)

[11:11] *** f00li5h left
[11:11] *** f00li5h joined
[11:11] *** goksie joined
[11:12] <dalek> specs: 4517a6b | KodiB++ | S32-setting-library/Containers.pod:

[11:12] <dalek> specs: [S32::Containers] Dropped the :replace argument to .grab and .grabpairs.

[11:12] <dalek> specs: 

[11:12] <dalek> specs: $bag.grab(5, :replace) is better written as $bag.pick(5, :replace).

[11:12] <dalek> specs: review: http://github.com/perl6/specs/commit/4517a6b930491b5b46096b17008a06946c992565

[11:14] <Kodi> Is there a real PIR opcode I can use in place of the $P0[$P1] sugar?

[11:15] *** \xF0 left
[11:16] *** \xF0 joined
[11:19] *** satyavvd joined
[11:22] *** Infinoid left
[11:22] *** Infinoid joined
[11:27] *** mikehh left
[11:32] *** testilbot joined
[11:34] <moritz_> $P0[$P1] desugars to a get_pmc_keyed vtable called

[11:36] *** sftp joined
[11:47] <Kodi> Oh, thanks.

[11:54] <masak> moritz_: I've applied the enums patch locally, and it builds fine. doesn't pass any more tests in t/spec/S12-enums/basic.t, though.

[11:55] <masak> moritz_: I'm thinking I might go over those tests and see which ones are still valid, and if any needs adding.

[11:58] *** satyavvd left
[12:00] <masak> this person seems to be asking something: http://twitter.com/func6996/status/24375483494

[12:00] <masak> but what?

[12:00] <mathw> masak: are there any languages you *don't* speak?

[12:01] <mathw> Now I see you tweeting in Japanese

[12:01] <mathw> at least Ithink it's Japanese

[12:01] <masak> mathw: :)

[12:01] <masak> mathw: I must confess, I don't speak Japanese.

[12:01] <masak> Google Translate enhances my abilities a bit.

[12:01] <mathw> lol

[12:01] <mathw> you clearly speak more of it than I do

[12:01] <masak> if it round-trips, I trust it enough to tweet it. :)

[12:02] <moritz_> masak: I seem to recall that the enum tests tracked the old spec

[12:03] <masak> I can believe that. I think they'll need a bit of revision.

[12:03] <masak> I can do that later today. don't know how big a task it'd be.

[12:03] <masak> it might require some thought, and I tend to avoid or postpone thought in my coding :)

[12:04] *** plobsing joined
[12:04] <moritz_> :-)

[12:09] <jnthn> The enum tests have, afaik, had any love (or updates) since the last enum spec revision.

[12:09] <jnthn> They're probably woefully out of date. Not to mention that I considered various of them wtf-ish before...

[12:11] <takadonet> morning all

[12:11] <masak> morning, takadonet 

[12:13] <masak> I feel better about the current version of the enums spec than about any prior to it. it incorporates any feedback I've ever given on enums as a result of using them in application code.

[12:13] <jnthn> o/ takadonet 

[12:33] *** plobsing left
[12:33] *** smash joined
[12:34] <smash> hello everyone

[12:35] <masak> smash! \o/

[12:42] <[Coke]> ~~

[12:43] <jnthn> ...what do you want to be smart-matched against? :-)

[12:43] <[Coke]> <CENSORED>

[12:43] <[Coke]> sometimes I hate this channel.

[12:44] <masak> sorry... :)

[12:45] <masak> rakudo: sub postfix:<~~>($n) { say "$n says hi!" }; "<[Coke]>"\  ~~

[12:45] <p6eval> rakudo 9993bb: OUTPUT«<[Coke]> says hi!␤»

[12:45] <masak> you need the unspace there to make it work.

[12:45] <masak> :)

[12:49] <tadzik> dull day :|

[12:49] *** wamba joined
[12:50] <masak> as Mondays go, it's quite alright.

[12:51] <masak> but let's start a discussion, if that helps: what do we want to accomplish prior to the next Rakudo monthly release?

[12:52] <Kodi> masak: Well, I'm making good headway on container types for hashes.

[12:52] <tadzik> I'd like a performance-usable read()/write()

[12:52] <Kodi> Right now I'm passing tests for KeyHash, KeySet, and KeyBag.

[12:52] <masak> whatever that means, it sounds good :)

[12:52] * tadzik hides

[12:52] <masak> Kodi++

[12:52] <masak> Kodi: ok, what I thought it meant, then.

[12:52] * tadzik , from hideout "so File::Copy would make sense"

[12:53] <masak> tadzik: indeed. I'd like to see that, too.

[12:53] <masak> pmichaud++ left a clue in the backlog. I think improving perf means trying that clue out in practice.

[12:53] <tadzik> http://github.com/tadzik/perl6-Module-Tools/blob/master/lib/Module/Install.pm#L36

[12:53] <tadzik> for this is just too ugly to be tolerated :(

[12:54] <tadzik> in fact, I'm shameful for having this in a git history

[12:54] *** patspam joined
[12:55] <tadzik> so maybe: what particular features are we missing, and what of that list can we accomplish?

[12:55] <tadzik> there's a list I think

[12:56] <masak> here's pmichaud's clue: http://irclog.perlgeek.de/perl6/2010-09-11#i_2814518

[12:56] <masak> I don't know yet if it's just a simple question of substituting one word for another.

[12:56] <jnthn> masak: moze byt :-)

[12:57] <jnthn> masak: It sounds quite feasible that it could be that simple.

[12:57] <tadzik> will changing the container make copying byte-by-byte faster?

[12:57] <tadzik> jnthn: did you mean: Może być? :)

[12:57] <masak> here we go :)

[12:57] <masak> tadzik: anyway, feel free to try the above pmichaud tip on Rakudo. if it builds and passes spectests, I'll happily apply it for you.

[12:57] <tadzik> oh, in ROADMAP: Really important items -- module installer

[12:57] <jnthn> I meant môže byť but couldn't be bothered with all the marks. :P

[12:58] <tadzik> masak: I can try

[12:58] <masak> I promise to work on pls in the coming week. last time I did it felt really hopeful.

[12:58] <jnthn> pls do

[12:58] <masak> next up is handling dependencies properly.

[12:58] <masak> last time I tried I just managed to create a lot of test failures. I believe I was too tired to do things properly.

[12:59] <tadzik> well, we have a module installer

[12:59] <tadzik> and I think it even works on windows

[12:59] <masak> that's good news.

[12:59] <tadzik> I even wanted jnthn to check that out :)

[12:59] * tadzik gives a suspicious look

[13:01] *** plainhao joined
[13:02] <jnthn> masak: Too tired, or too full of good noms? :-)

[13:02] <jnthn> Or have you hacked on proto since $last-visit? :-)

[13:03] <masak> :)

[13:04] <masak> aye, I hacked a bit on pls a week or so ago.

[13:04] <jnthn> Oh, nice.

[13:04] <masak> together with tadzik++, who helped triage different projects, I believe.

[13:04] <tadzik> masak: has T @.contents; -- there should be this RIA?

[13:05] <masak> tadzik: no, I'll show you where.

[13:05] <jnthn> Somebody should really imeplement compact arrays. :-)

[13:05] <masak> hold on.

[13:07] <masak> tadzik: actually, now I don't see what pmichaud meant.

[13:07] <tadzik> (:

[13:08] * masak tries to read the logs again

[13:08] <tadzik> perl6: my @a; say @a.PARROT

[13:08] <p6eval> rakudo 9993bb: OUTPUT«Array␤»

[13:08] <p6eval> ..pugs: OUTPUT«*** No such method in class Array: "&PARROT"␤    at /tmp/bk8o1ksqq7 line 1, column 12 - line 2, column 1␤»

[13:08] <tadzik> pff

[13:08] <masak> pugs doesn't have a .PARROT method? shocking!

[13:10] <tadzik> Nice to have items -- module versioning and download -- what does that mean?

[13:11] <jnthn> use Foo:ver<42>;

[13:11] <tadzik> hmm

[13:11] <moritz_> which dies if no version >= 42 is available

[13:11] <tadzik> and download?

[13:12] <moritz_> downloading stuff is the task of the toolchain, not of the compiler

[13:12] <tadzik> but what does it mean in this context?

[13:13] <moritz_> ./installer install JSON:ver<1.0>

[13:14] <tadzik> hmm

[13:14] <tadzik> I can do it in neutro, or whatever

[13:15] <tadzik> masak: I actually think neutro can be turned into something using App::Pls as a logic, not sure how much turning it would be, and if the "turning" won't become "reimplementing proof-of-concept"

[13:15] <masak> tadzik: sounds interesting.

[13:15] *** kaare_ left
[13:15] <masak> also remember that proof-of-concept is just a proof of concept so far.

[13:16] *** uniejo left
[13:16] <tadzik> I know

[13:16] <tadzik> (which is barely proving the concept :P)

[13:17] *** Patterner left
[13:18] <tadzik> masak: I'm also wondering how much sense does "fetched" have, as long as we need either to clone, or to pull, and you never know if something is actually fetched

[13:19] *** ZadYree joined
[13:19] *** jhuni left
[13:22] *** am0c^ joined
[13:27] *** Psyche^ joined
[13:27] *** Psyche^ is now known as Patterner

[13:28] <tadzik> masak: hmm, I now thought: instead of working at adjusting neutro to App::Pls needs, maybe it'd be better to work at Module::Tools to be a suitable Pls backend (frontend? worker?)?

[13:28] <masak> also sounds worthwhile.

[13:28] <masak> pluggability++

[13:31] <tadzik> currently, there are just a bunch of subs: build(), install(), test() etc

[13:32] <masak> sounds kinda similar.

[13:34] <tadzik> bah, I wish some apps had --shut-up. prove's --QUIET is not enough

[13:34] <tadzik> does windows have something like redirecting to /dev/null?

[13:35] <moritz_> I think > nul

[13:36] <moritz_> TAP::Harness->new({ verbosity => -1, merge => 1 })

[13:38] <daxim> http://en.wikipedia.org/wiki/NUL:

[13:38] <tadzik> well, I'm running prove via run()

[13:38] <tadzik> no TAP in P6 yet, unfortunately

[13:40] *** Holy_Cow joined
[13:43] *** patspam left
[13:43] *** qwebirc62872 left
[13:46] *** PacoLinux joined
[13:47] *** satyavvd joined
[13:50] *** satyavvd_ joined
[13:52] *** satyavvd left
[13:52] *** satyavvd_ is now known as satyavvd

[13:54] *** plobsing joined
[13:54] <jnthn> -25 MSVC

[13:54] <jnthn> oops, wrong window

[14:06] *** patspam joined
[14:08] *** risou joined
[14:11] *** rcsheets joined
[14:15] *** uiteoi joined
[14:15] <tadzik> masak: I pushed a bugfix to pls, bug could possibly prevent Math::Model from building

[14:15] <masak> checking.

[14:16] <masak> that looks sane to me.

[14:17] <masak> tadzik++

[14:17] <tadzik> it caused SVG::Something not to build in Module::Build

[14:17] <tadzik> so I fixed this there and there

[14:17] <masak> thanks.

[14:18] <masak> inter-project dependencies are still broken in pls, though. need to look at that at some point.

[14:20] *** Kodi left
[14:21] *** b0m1ro joined
[14:22] <tadzik> broken in what way?

[14:22] <masak> hm, 'not yet implemented' would better describe them.

[14:23] <tadzik> hmm

[14:23] <masak> they work in the test suite, but not in proof-of-concept.

[14:27] *** svetlins joined
[14:36] *** wtw left
[14:39] *** risou_ joined
[14:40] <tadzik> colomon: mind moving mandelbrot scripts to bin/, so they can be neutro-installable?

[14:41] <tadzik> masak: same goes for pun btw

[14:42] <tadzik> and maybe tardis

[14:42] <masak> tadzik: gotcha.

[14:42] *** risou left
[14:43] <ZadYree> perl6: my @array = 4, 5, 6; say @array[1]

[14:43] <p6eval> pugs, rakudo 9993bb: OUTPUT«5␤»

[14:45] *** Trashlord joined
[14:45] <ZadYree> perl6: my @array = 4, 5, 6; say $array[1]

[14:45] <p6eval> rakudo 9993bb: OUTPUT«===SORRY!===␤Symbol '$array' not predeclared in <anonymous> (/tmp/ReBL6fBSkx:22)␤»

[14:45] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "["␤    expecting "::"␤    Variable "$array" requires predeclaration or explicit package name␤    at /tmp/AkQafPOkM0 line 1, column 32␤»

[14:45] <masak> rakudo: my @a = 1..5; @a[ ^3 ] xx= 2; say @a.perl

[14:45] <p6eval> rakudo 9993bb: OUTPUT«[1, 2, 3, 4, 5]␤»

[14:46] <masak> huh.

[14:46] <TimToady> std: my @array = 4, 5, 6; say $array[1]

[14:46] <ZadYree> ouch

[14:46] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $array is not predeclared (did you mean @array?) at /tmp/Wfp04qZA0o line 1:␤------> [32mmy @array = 4, 5, 6; say $array[33m⏏[31m[1][0m␤Check failed␤FAILED 00:01 119m␤»

[14:46] <ZadYree> I don't know if perl6 is for me ^^

[14:46] <TimToady> you'll get used to it in about 1 day

[14:46] <TimToady> and then you'll wish Perl 5 did it that way

[14:46] <masak> ZadYree: for what it's worth, you're not the first one to say that.

[14:46] <ZadYree> hehe

[14:47] <masak> ZadYree: but as TimToady points out, people usually come around.

[14:47] <TimToady> but rakudo's message is LTA (Less Than Awesome)

[14:47] * masak submits rakudobug

[14:47] <masak> ZadYree++

[14:48] <TimToady> ZadYree: you're stuck now, you've already contributed :)

[14:49] <ZadYree> hhaha

[14:49] <ZadYree> aight

[14:49] <ZadYree> i'm pretty used w/ $array[$_]

[14:49] <TimToady> I'd had more experience with it than you.  :)

[14:49] <mathw> You get used to it

[14:49] <mathw> real quick

[14:49] *** rcsheets left
[14:50] <masak> there are advantages to @array[$_] too, trust us. :)

[14:50] <TimToady> you get used to it the first time you don't have to say @{...}

[14:50] <mathw> absolutely

[14:50] *** drbean left
[14:50] <mathw> when you get what $array[$_] means in Perl 6 and what it's for :)

[14:50] <mathw> there is much rejoicing

[14:50] <mathw> or there was in my head anyway

[14:50] *** drbean joined
[14:50] <masak> TimToady: it's funny to read "I'd had more experience with it than you.  :)", flipping back between knowing and (emulating) not knowing who you are. :P

[14:51] <ZadYree> haha right hehe

[14:51] <masak> s/back/back and forth/

[14:52] <ZadYree> perl6: my $arr = ["aa", "bb", "cc"]; foreach($arr) {say $_ };

[14:52] <p6eval> rakudo 9993bb: OUTPUT«===SORRY!===␤Confused at line 22, near "foreach($a"␤»

[14:52] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "{"␤    expecting operator␤    at /tmp/uPse3mAaJP line 1, column 45␤»

[14:52] <ZadYree> well

[14:53] <ZadYree> so @{}? :P

[14:53] <PerlJam> ZadYree: there is no foreach

[14:53] <ZadYree> huh?

[14:53] *** ash_ joined
[14:53] <tadzik> just for

[14:53] <masak> ZadYree: there's been a few changes... :)

[14:53] <tadzik> rakudo: my $arr = ["aa", "bb", "cc"]; for $arr { .say }

[14:53] <p6eval> rakudo 9993bb: OUTPUT«aa bb cc␤»

[14:53] <ZadYree> ouch

[14:53] <masak> one iteration.

[14:54] <ZadYree> looks like ruby, js and all this shitty stuff xD

[14:54] <tadzik> hrm

[14:54] <tadzik> ...excuse me?

[14:54] <masak> tadzik: it's the $

[14:54] <tadzik> rakudo: my $arr = ["aa", "bb", "cc"]; for $arr.list { .say }

[14:54] <masak> tadzik: makes it not flatten.

[14:54] <p6eval> rakudo 9993bb: OUTPUT«aa␤bb␤cc␤»

[14:54] <tadzik> there we go

[14:54] <TimToady> perl6: my $array = <a d e r Y Z>; say $array[5,0,1,4,3,2,2], '++'

[14:54] <tadzik> ZadYree: you can have your say $_ if that's what you mean

[14:54] <p6eval> pugs, rakudo 9993bb: OUTPUT«ZadYree++␤»

[14:54] <ZadYree> ok

[14:55] <ZadYree> well, the problem is every perl <6 won't work anymore

[14:55] <tadzik> it's not supposed to be backwards compatibile

[14:55] <TimToady> that was the whole point

[14:55] <masak> backwards incompatibility was part of the original deal.

[14:55] <ZadYree> use perl5; or something like that?

[14:55] *** Trashlord left
[14:55] <masak> and Perl 5 is still there.

[14:55] <masak> very much so, in fact.

[14:56] <TimToady> we all still program in Perl 5 a lot

[14:56] <ZadYree> Ok I see

[14:56] <ZadYree> yeah

[14:56] *** svetlins left
[14:56] <tadzik> ZadYree: perl6 compiler is not the replacement for a Perl 5 compiler, to explain it easily

[14:56] <ZadYree> ok

[14:57] <tadzik> ZadYree: just curious, is autoboxing "shitty stuff" for you, or what was that about?

[14:57] *** Trashlord joined
[14:57] <ZadYree> well, in fact I'm pretty afraid of thise type things

[14:57] <ZadYree> $foo.array or so

[14:57] <ZadYree> s!thise!these!

[14:58] <TimToady> rakudo: my $arr = ["aa", "bb", "cc"]; for @($array) { .say }

[14:58] <p6eval> rakudo 9993bb: OUTPUT«===SORRY!===␤Symbol '$array' not predeclared in <anonymous> (/tmp/qr6A8BRE1E:22)␤»

[14:58] <TimToady> rakudo: my $arr = ["aa", "bb", "cc"]; for @($arr) { .say }

[14:58] <masak> rakudo: foreach (1, 2, 3) {}

[14:58] <TimToady> that's more like p5

[14:58] <p6eval> rakudo 9993bb: OUTPUT«aa␤bb␤cc␤»

[14:58] <p6eval> rakudo 9993bb: OUTPUT«===SORRY!===␤Unsupported use of 'foreach'; in Perl 6 please use 'for' at line 22, near " (1, 2, 3)"␤»

[14:58] <tadzik> oh, you'll love them once you see 'em

[14:58] <masak> std: foreach (1, 2, 3) {}

[14:58] <p6eval> std 32123: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of 'foreach'; in Perl 6 please use 'for' at /tmp/Sv3ikgiu3S line 1:␤------> [32mforeach[33m⏏[31m (1, 2, 3) {}[0m␤Parse failed␤FAILED 00:01 114m␤»

[14:59] <TimToady> rakudo: my $arr = ["aa", "bb", "cc"]; for @$arr { .say }

[14:59] <p6eval> rakudo 9993bb: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 22, near "@$arr { .s"␤»

[14:59] <TimToady> I presume that bug is logged

[14:59] <masak> which one?

[14:59] <TimToady> but @$arr is supposed to work too

[14:59] <masak> @$arr is in RT, yes.

[14:59] <TimToady> std: my $arr = ["aa", "bb", "cc"]; for @$arr { .say }

[14:59] <p6eval> std 32123: OUTPUT«ok 00:01 120m␤»

[14:59] <jnthn> @$arr as an alias to @($arr) is not nyi

[14:59] <TimToady> and that's even more like p5

[14:59] <tadzik> rakudo: (1, 2, 3, 4).grep({$_ %% 2}).map({ $_ + 1}).reverse.join.say

[15:00] <p6eval> rakudo 9993bb: OUTPUT«53␤»

[15:00] <tadzik> ZadYree: try to write such a chain in Perl 5 and you'll see what I mean

[15:00] *** b0m1ro left
[15:00] <ZadYree> haha yeah

[15:00] *** Holy_Cow left
[15:00] <tadzik> I alredy forgot which argument the array is, in Perl 5 functions

[15:00] *** ruoso joined
[15:01] <ZadYree> hum

[15:02] <ZadYree> perl6: my $arr = ["aa", {"foo" => "bar"}]; say $arr->[1]->{foo};

[15:02] <p6eval> rakudo 9993bb: OUTPUT«===SORRY!===␤Unsupported use of ->(), ->{} or ->[] as postfix dereferencer; in Perl 6 please use .(), .[] or .{} to deref, or whitespace to delimit a pointy block at line 22, near "1]->{foo};"␤»

[15:02] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "->["␤    expecting "::", term postfix, operator, ":" or ","␤    at /tmp/DubndoAx96 line 1, column 45␤»

[15:02] <tadzik> you don't need to

[15:02] <ZadYree> what's the equivalent

[15:03] <tadzik> ZadYree: you read to read http://perlgeek.de/en/article/5-to-6

[15:03] <ZadYree> ya i'm reading it :P

[15:03] <masak> rakudo: my $arr = ["aa", {"foo" => "bar"}]; say $arr[1]{foo}

[15:03] <p6eval> rakudo 9993bb: OUTPUT«Could not find sub &foo␤  in main program body at line 22:/tmp/NhCwh0bPK0␤»

[15:03] <tadzik> rakudo: my $arr = ["aa", {"foo" => "bar"}]; say $arr[1]<foo>

[15:03] <masak> rakudo: my $arr = ["aa", {"foo" => "bar"}]; say $arr[1]<foo>

[15:03] <tadzik> ...first!

[15:03] <p6eval> rakudo 9993bb: OUTPUT«bar␤»

[15:03] <masak> :)

[15:03] <masak> I was deterred by my own sloppiness :)

[15:04] <TimToady> perl6: my $arr = ["aa", {foo => "bar"}]; say $arr.[1].<foo>; # can use . if you like

[15:04] <masak> ZadYree: $arr[1]{"foo"} and $arr[1]<foo> are the same.

[15:04] <p6eval> pugs, rakudo 9993bb: OUTPUT«bar␤»

[15:04] <ZadYree> ah I see

[15:04] <masak> ZadYree: generally, one needs to quote hash keys when indexing, as opposed to in Perl 5.

[15:04] <TimToady> <foo bar baz> is just qw/foo bar baz/, and works as a constant subscript

[15:06] <TimToady> ->{foo} was an underpowered and error prone construct

[15:06] <tadzik> pardon my offtopic, has anybody seen "Salt", the movie?

[15:06] * masak plans to

[15:06] <TimToady> I suppose someone has

[15:06] *** b0m1ro joined
[15:06] <tadzik> well, someone here who can tell me is it worth it

[15:07] <TimToady> Ohh, http://rosettacode.org/wiki/Category:Perl_6 now has more than 200 entries, and spills to a second page \o/

[15:07] <TimToady> except for the fact that I now get to monitor two pages

[15:07] <masak> tadzik: http://www.rottentomatoes.com/m/1213717-salt/

[15:10] *** b0m1ro left
[15:10] <tadzik> hmm, I suppose I'll go anyway

[15:16] <TimToady> rakudo: class Foo {}; say Foo.new.perl;

[15:16] <p6eval> rakudo 9993bb: OUTPUT«Foo.new()␤»

[15:16] <TimToady> rakudo: class Foo {...}; say Foo.new.perl;

[15:16] <p6eval> rakudo 9993bb: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤  in main program body at line 1␤»

[15:16] <TimToady> rakudo: class Foo {...}; say Foo.new(42).perl;

[15:16] <p6eval> rakudo 9993bb: OUTPUT«42␤»

[15:16] <TimToady> o_O

[15:17] <masak> O_o

[15:17] * masak submits rakudobug

[15:17] *** b0m1ro joined
[15:17] <TimToady> pugs: class Foo {...}; say Foo.new.perl;

[15:17] <p6eval> pugs:  ( no output )

[15:17] <masak> TimToady: what should 'class Foo {...}; Foo.new' do?

[15:18] <TimToady> allow an additional class Foo {} later, methinks

[15:18] <TimToady> but otherwise act empty

[15:18] <masak> but instantiable?

[15:18] *** goksie left
[15:18] <TimToady> if the ... runs, it runs at compile time

[15:18] <jnthn> huh, I thought it just declared the name as "should be declared sometime later" and whined if that didn't happen.

[15:19] <jnthn> Maybe it forgets to whine.

[15:19] * masak submits a rakudobug about that too

[15:19] <jnthn> My intention when I put it in was that class Foo {...}; without a later non-stub class Foo would fail to compile though.

[15:19] <TimToady> perhaps class {...} really means class { method new {...} }

[15:19] <TimToady> as far as runtime goes

[15:20] <jnthn> TimToady: I'm not convinced it should make it until runtime.

[15:20] <TimToady> std: class Foo {...}; Foo.new.perl

[15:20] <p6eval> std 32123: OUTPUT«ok 00:01 115m␤»

[15:20] <jnthn> Could be more semantic than that. :-)

[15:21] <jnthn> I guess the alternative is that it creates and installs a Foo, but it's not yet composed.

[15:21] <jnthn> s/the/an/

[15:21] <TimToady> I guess there are two entirely different reasons for stubbing a class

[15:21] <TimToady> named (<compile run>) ~ " time"

[15:22] <TimToady> I suppose if ... is reserved for compile time, you can always get run time with ::Foo

[15:23] <masak> aye.

[15:23] <TimToady> otoh, there could be other reasons for stubbing at compile time than just wanting a real definition later in the same file

[15:24] <jnthn> Oh, I'd always seen the "class Foo { ... } so I can write Foo" as just an up-front promise that you'd define a Foo later but wanted to be able to talk about it now.

[15:24] <TimToady> well, but that doesn't say whether it's defined at ctime or rtime

[15:24] <TimToady> in that view, it just lets you drop the ::

[15:24] <jnthn> As in, define one later in the same compilation unit.

[15:25] <TimToady> that would generally be the case

[15:25] <TimToady> is there a reason to make it mandatory?

[15:26] <TimToady> s/reason/good enough reason/

[15:26] <jnthn> Well, at lesat partly that we don't have to worry about the answer to "so what is installed when I write class Foo { ... }"

[15:27] <jnthn> I can think of answers, but not any that I really like.

[15:27] <jnthn> Well, actually I quite like the "uncomposed" answer.

[15:27] <TimToady> you have to mark the symbol table entry as a stub in any case

[15:28] *** b0m1ro left
[15:28] <jnthn> Troo.

[15:28] <masak> so... no bug report? :)

[15:28] <TimToady> and run-time is better for dependency injection

[15:30] * masak pushes the undo button on that bug report

[15:32] *** plainhao left
[15:33] *** plainhao joined
[15:34] <jnthn> masak: I'm not quite sure everything is peachy...

[15:34] *** Ross joined
[15:34] <jnthn> masak: The behavior you showed is odd at best.

[15:34] <TimToady> he meant the 2nd report

[15:34] <masak> well, one bug of two got in.

[15:35] <jnthn> Oh, OK

[15:35] * jnthn got slightly distracted by $dayjob :-)

[15:35] <jnthn> ooh!

[15:36] <jnthn> redgate++ :-D

[15:36] <jnthn> (boss with contacts)++

[15:36] *** satyavvd left
[15:36] <jnthn> RedGate just sponsored me a copy of their .Net profiler for using in 6model work :-)

[15:36] <tadzik> yay!

[15:36] <TimToady> redgate++

[15:37] <TimToady> \o/ frabjous day

[15:37] <tadzik> specifically for 6model? Does this work per-project?

[15:37] * jnthn is very happy about that. It's already helped me understand performance stuff in the meta-model design.

[15:38] *** Holy_Cow joined
[15:38] <jnthn> tadzik: No, it's per-user actually, but it's my work on that which was interesting.

[15:39] * jnthn looks forward to implementing the new multi-dispatch stuff and cache and giving that a workout under the profiler, to see how it does.

[15:41] *** icwiener joined
[15:43] <sorear> good * #perl6

[15:44] <TimToady> *.good

[15:44] <sorear> jnthn: I remember the real problem now

[15:44] <sorear> jnthn: invalidating the correct classes seems to require a bunch of subclass weak refs

[15:44] <TimToady> actually, now.good, since we're in the same TZ

[15:45] <sorear> I guess maybe that could work if I had a Global Monkey-Typing Lock

[15:45] <sorear> (also, the .Net weak ref system sucks.)

[15:45] <ash_> rakudo: say localized-greeting; 

[15:45] <p6eval> rakudo 9993bb: OUTPUT«Could not find sub &localized-greeting␤  in main program body at line 22:/tmp/SyuNJCm0d3␤»

[15:45] <jnthn> sorear: Maybe some pub/sub thing would be better than weak refs.

[15:46] <ash_> would be fun to add that to the eval bot :P 

[15:46] <colomon> tadzik: is it as simple as moving to bin, or does something else need to be done?  I certainly don't mind moving them....

[15:46] <sorear> jnthn: explain?

[15:46] <jnthn> sorear: As in, an event based model

[15:46] <jnthn> Oh, I guess in .Net you still need weak refs for it though...

[15:47] <tadzik> colomon: no, just moving. and 755 would be nice too

[15:47] <jnthn> So back to square one

[15:47] *** mj41 left
[15:47] <colomon> tadzik: what, you think the executables should be executable?!?  ;)

[15:47] <tadzik> :)

[15:47] <sorear> jnthn: how would events work?

[15:48] * TimToady wonders if .pick(5, :replace) should be renamed pick-xx(5)

[15:48] <tadzik> btw, does anyone have an idea of how chmod works? Is there a syscall, or something?

[15:48] <jnthn> sorear: Sub-classes subscribe to be notified of changes to their parent classes.

[15:48] <jnthn> sorear: Though it gives a more general model

[15:49] <jnthn> sorear: So anyone could subscribe to know about changes to a class.

[15:49] <jnthn> Could be an optional part of the MOP perhaps.

[15:49] <jnthn> sorear: I've not thought too much about the details, but it could work.

[15:50] <colomon> tadzik: done.

[15:50] *** mj41 joined
[15:50] <tadzik> colomon++

[15:52] *** justatheory joined
[15:52] <tadzik> ouch

[15:53] <tadzik> colomon: how about #!/usr/bin/env perl6 at the top?

[15:53] <sorear> tadzik: yes, chmod is a syscall.

[15:54] <tadzik> sorear: do you have an idea is it available in rakudo, under some different name?

[15:54] <sorear> there's always pir::dlfunc

[15:55] <jnthn> rakudo: chmod 'README', 700 

[15:55] <p6eval> rakudo 9993bb: OUTPUT«Could not find sub &chmod␤  in main program body at line 22:/tmp/VbPOkNDtuq␤»

[15:55] <jnthn> Oh, I thought that was in.

[15:55] <tadzik> time for File::Chmod then I guess

[15:55] <jnthn> rakudo: pir::new('OS').chmod('README', 700)

[15:55] <p6eval> rakudo 9993bb:  ( no output )

[15:55] <jnthn> rakudo: pir::new('OS').chmod('README', 700); say "lived"

[15:55] <p6eval> rakudo 9993bb: OUTPUT«lived␤»

[15:56] <jnthn> tadzik: Lajk that. :-)

[15:56] <ash_> lajk? 

[15:56] * sorear is slowly pushing niecza towards a "$!x means $!Class::x and you have privacy from your children" modle

[15:56] <sorear> ping Alias_

[15:56] <jnthn> ash_: "like" :-)

[15:57] *** ash_ left
[15:59] *** uiteoi left
[16:01] <masak> ash_ is probably from a locale where 'j' is not pronounced [y] :)

[16:02] <tadzik> and 'a' like [ey]

[16:06] <shortcircuit> TimToady: This may be useful for you, to save you from monitoring two pages: http://rosettacode.org/wiki/Rosetta_Code/Find_unimplemented_tasks

[16:06] <shortcircuit> TimToady: Not strictly as-is, but as an example for how to get that data programmatically.

[16:08] <TimToady> shortcircuit: thanks, is there a way to get any addition marked Perl 6 to show up in my watch list?

[16:10] <jnthn> masak: Oh, *those* places. :)

[16:11] *** risou joined
[16:12] <shortcircuit> TimToady: That has been a feature I've wanted automatable for years. Theoretically, Semantic MediaWiki should enable RSS feeds based on semantic queries, but I wasn't satisfied with the results the last time I did it.

[16:12] <pmichaud> good morning, #perl6

[16:12] *** risou_ left
[16:13] <TimToady> morning.good

[16:13] <shortcircuit> TimToady: What you can probably do is use the MediaWiki API to monitor that category, and make sure that all entries in it are added to your user's watch list.

[16:13] <shortcircuit> TimToady: That'd require polling the category, though. (Be gentle, there! :) )

[16:15] *** am0c^ left
[16:15] <TimToady> well, just a list of anything recently touched in <lang perl6> would be useful; I'll poke a bit more, and yes, I've seen the performance discussion on #rosettacode :)

[16:16] <masak> swimming &

[16:16] *** masak left
[16:16] <tadzik> cineming &

[16:16] *** tadzik left
[16:18] <shortcircuit> TimToady: That kind of performance thing happens every 9-18 months. I upgrade and/or tune, and then things settle for a while. A check every ten minutes would probably be just fine, if you needed it that often.

[16:18] <TimToady> I'm thinking more like once or twice a day :)

[16:18] <shortcircuit> Yeah, I don't think anyone would notice. :)

[16:19] <TimToady> just don't want any Perl 6 code to slip past unaudited

[16:19] <shortcircuit> I once had a maintenance bot spin, with hooks on all its functions calling another function that slept a certain number of seconds based on the server's load average.

[16:28] *** plobsing left
[16:29] *** spq1 joined
[16:31] *** [particle] left
[16:32] *** [particle] joined
[16:37] *** spq1 left
[16:39] *** tylercurtis joined
[16:50] *** envi^home left
[16:55] *** kjeldahl_ joined
[16:56] *** kjeldahl left
[16:57] *** dakkar left
[16:58] *** meraxes joined
[16:59] *** mantovani left
[16:59] *** cls_bsd left
[16:59] *** mantovani joined
[16:59] *** cls_bsd joined
[17:01] *** daxim left
[17:04] *** sahadev joined
[17:07] <dalek> niecza: 9f6189f | sorear++ | lib/ (2 files):

[17:07] <dalek> niecza: Cheat a bit with field access in the kernel

[17:07] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9f6189f64407f925fc59c4d3def48f11c2708917

[17:07] <dalek> niecza: 72a824b | sorear++ | lib/Kernel.cs:

[17:07] <dalek> niecza: Use a MRO cache

[17:07] <dalek> niecza: review: http://github.com/sorear/niecza/commit/72a824b081575e4777fe744a496f782c30885793

[17:09] *** icwiener left
[17:12] *** Chillance joined
[17:13] *** risou_ joined
[17:13] *** risou left
[17:17] *** plobsing joined
[17:23] <pmichaud> I'm getting a ton of spectest failures with the latest parrot... known?

[17:24] *** goksie joined
[17:25] *** vapace joined
[17:26] *** patrickas joined
[17:26] <patrickas> o/

[17:27] <patrickas> TimToady: About the series crashing before producing enough elements in 0,0.001 ... 20, I think iti s a gather take issue that's way over my head :(

[17:28] *** Axius joined
[17:28] <patrickas> The following seems to dies the same way: sub foo () { gather { my $c=0; loop { $c = $c+0.001; take $c; } } } ; say $_ for foo();

[17:38] <pmichaud> ah, that sounds more like an iterator / list issue

[17:39] <sorear> sounds more like the fact that the garbage collector is C-recursive

[17:39] <pmichaud> right, the ultimate problem is the recursive gc

[17:39] <TimToady> perlmonks appears to be down

[17:39] <pmichaud> but still we don't want that to be holding 20,000 elements either

[17:40] <patrickas> should I masak it ?

[17:41] <pmichaud> how far does it get before crashing?

[17:41] <patrickas> on my pc around 4.0xx

[17:41] <pmichaud> okay

[17:41] <pmichaud> yes, I think it's okay to report it as a rakudobug

[17:42] <pmichaud> I'll look at it after lunch

[17:42] <patrickas> BTW whith a while loop it seems to last a bit longer before dying

[17:42] <pmichaud> hmmm

[17:42] <pmichaud> that doesn't make a lot of sense to me, but oh well :)

[17:42] <patrickas> sub foo () { gather { my $c=0; loop { $c = $c+0.001; take $c; } } } ; my $s = foo(); say $_.shift() while($s);

[17:42] <pmichaud> oh, like that

[17:42] <patrickas> well It may just be a coincidence

[17:42] <pmichaud> yes, that doesn't surprise me.

[17:43] <pmichaud> while is more efficient than for, there.

[17:45] <pmichaud> oh, I think I know what's happening.

[17:45] <pmichaud> I think we definitely need to null out registers in the case of for loops

[17:47] <pmichaud> I guess I'll add that to PAST::Compiler in a bit

[17:49] <pmichaud> that's going to be a little tricky -- have to make sure we don't null registers that correspond to lexicals

[17:51] <jnthn> .oO( Need to stop storing lexicals in registers... )

[17:51] <pmichaud> jnthn: that too.  Or I can just remove the parts of PAST::Compiler that try to optimize to re-use those registers.

[17:52] <pmichaud> i.e., to never use a lexical register for anything but declaring it

[17:52] <pmichaud> (and thus it never gets null'd)

[17:52] <jnthn> pmichaud: I was more advocating a Parrot change there than just a PAST::Compiler one. :-)

[17:52] <pmichaud> jnthn: yes, I followed that :)

[17:53] <pmichaud> I'm just speculating that a PAST::Compiler change will occur much sooner than that Parrot change.

[17:53] <jnthn> Indeed.

[17:53] <sorear> I've switched *to* storing variables in numbered registers, and it feels like an improvement

[17:53] <sorear> what do you mean it's not?

[17:53] *** Axius left
[17:54] <jnthn> sorear: Storing lexicals in an indexed storage is fine.

[17:54] <jnthn> sorear: But that shouldn't be the same one that all the temporaries live in.

[17:54] <pmichaud> sorear: right now parrot maps lexical symbols to call-frame registers

[17:54] <pmichaud> which means that if you null the register, you null the lexical too

[17:55] <pmichaud> it's the difference between

[17:55] <pmichaud>     .lex '$x', $P0

[17:55] <pmichaud>     null $P0

[17:55] <pmichaud> and

[17:55] <pmichaud>     $P0 = find_lex '$x'

[17:55] <pmichaud>     null $P0

[17:57] <pmichaud> I'm wondering if any of the PAST::Compiler changes are going to want/need a deprecation cycle, though.  :(

[17:57] <pmichaud> maybe I make it a compiler option... "null temporaries" or something like that.

[17:58] <pmichaud> that's probably safer and more flexible in the long run

[17:59] *** rblackwe joined
[17:59] <pmichaud> afk, lunch

[17:59] *** meppl left
[18:02] *** cdarroch joined
[18:02] *** cdarroch left
[18:02] *** cdarroch joined
[18:04] <timbunce> I spotted this old quote from TimToady recently: "The usability of a computer language is inversely proportional to the number of theoretical axes the language designer tries to grind." That made me smile and wonder how many theoretical axes perl6 is trying to grind :)

[18:04] *** Axius joined
[18:06] <PerlJam> timbunce: none!

[18:07] <PerlJam> timbunce: it let's the programmer grind his own axe.

[18:07] <PerlJam> s/'//

[18:07] *** cjk101010 left
[18:07] <timbunce> PerlJam: A language-axe grinding toolkit :)

[18:08] <flussence> it's got dates and complex numbers, so it at least does the x/y/t axes :)

[18:09] *** Axius left
[18:11] *** Axius joined
[18:18] <TimToady> fg

[18:18] <diakopter> current: no such job

[18:19] *** hercynium joined
[18:19] *** hercynium left
[18:19] *** hercynium joined
[18:22] *** risou_ left
[18:28] *** Axius left
[18:32] *** newbod joined
[18:46] *** azert0x left
[18:48] *** alester left
[18:50] *** newbod left
[18:53] *** mberends joined
[18:58] *** masak joined
[18:58] <masak> ahoy!

[18:58] <mberends> \o masak !

[18:58] *** sdziegie joined
[18:58] <masak> mberends! \o/

[18:58] *** sdziegie left
[18:59] <patrickas> masak!

[18:59] <masak> !

[18:59] <patrickas> that's short for YAYITSMASAK!

[19:00] <masak> \x[EXCLAMATION MARK]

[19:00] *** sdziegie joined
[19:00] <masak> or is that \c[]? I forget.

[19:00] <sorear> \c[]

[19:00] <masak> thanks sorear++

[19:03] <jnthn> .oO( \c[EXCLAMATION MASAK]

[19:03] <jnthn> )

[19:03] <masak> :)

[19:06] * tylercurtis thinks he understands how EXPR works now. :)

[19:06] * TimToady offers his condolences

[19:07] <tylercurtis> It turned out surprisingly easy to understand when I read the loop before looking at &reduce.

[19:08] <masak> TimToady's keynote is online now: http://www.presentingperl.org/ye2010/keynote/

[19:09] *** plainhao left
[19:10] *** hercynium left
[19:12] <PerlJam> where are the slides?

[19:12] <PerlJam> masak++ btw

[19:12] *** Mowah left
[19:12] <masak> mst++ http://twitter.com/shadowcat_mst/status/24397016927

[19:14] <patrickas> what should should '07' ... '10' return ?

[19:14] <patrickas> rakudo: say ~( '07' ... '10' ); # this is should be wrong

[19:14] <p6eval> rakudo 9993bb: OUTPUT«07 08 09 10␤»

[19:14] *** Intensity joined
[19:15] <patrickas> I guess it should be : 07 06 05 04 03 02 01 00 17 16 15 14 13 12 11 10 #is my understanding correct ?

[19:15] *** Raynes left
[19:16] <TimToady> why would it do that?

[19:16] <masak> o.O

[19:16] <masak> 00 17?

[19:17] <TimToady> I think the digits have to agree on a direction

[19:17] <patrickas> If the start and stop strings are the same length, this is applied at every position, with carry.

[19:17] <patrickas>   'aa' ... 'zz'   # same as 'a' .. 'z' X~ 'a' .. 'z'

[19:17] <TimToady> carry implies coherence

[19:18] <masak> I should hope so!

[19:18] <patrickas> '07' ... '10' # same as '0' .. '1' X~ '7' .. '0'

[19:18] <TimToady> no

[19:19] *** timbunce left
[19:19] <patrickas> the first two lines are form the spec, the last line is my interpolation of the spec :-)

[19:19] *** Raynes joined
[19:20] <PerlJam> patrickas: you are clearly insane :)

[19:20] <patrickas> http://perlcabal.org/syn/S03.html#line_2018

[19:21] <TimToady> nah, he's just an attentive reader :)

[19:21] <patrickas> PerlJam: Thanks! :-)

[19:21] <TimToady> though the two are not mutually exclusive

[19:22] <PerlJam> patrickas: Well, your presence on #perl6 more than qualifies you for insanity.  I'm just being redundant by stating it.

[19:22] <masak> PerlJam: you are clearly redundant :)

[19:22] <patrickas> PerlJam: implementing the convoluted series operator is just icing on the insanity cake :-)

[19:23] <dalek> niecza: 0c06bec | sorear++ | / (3 files):

[19:23] <dalek> niecza: Use a native Boolean for List $!flat

[19:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0c06becf7cf252dca64817c6b492f46ceff3d76e

[19:23] <dalek> niecza: bde27dd | sorear++ | lib/Kernel.cs:

[19:23] <dalek> niecza: Pack bools in Variable in memory

[19:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/bde27ddb3da3b3aa82092ff4265b035fbdd591db

[19:23] <dalek> niecza: af4b265 | sorear++ | src/Optimizer/RxSimple.pm:

[19:23] <dalek> niecza: Optimize cut literals and charclasses

[19:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/af4b265a069ff9e69bda772e3f536d57ddc3ef47

[19:24] <TimToady> I suspect we should add a rule that says if all the digits are, er, digits, then we force it to 0..9 semantics

[19:25] *** Chillance left
[19:25] <TimToady> we also need consistent ordering somehow

[19:25] <patrickas> TimToady: but then what happens about using this to count in different bases ?

[19:25] *** timbunce joined
[19:26] <patrickas> Hence, to produce all octal numbers that fit in 16 bits, you can say: '000000' ... '177777'

[19:26] <patrickas> then this part would need to be dropped too!

[19:26] <TimToady> well, then forget decimal, but we do need to have a consistent ordeering

[19:27] <TimToady> if the two sequences are the same length, the order is determined by cmp

[19:27] <TimToady> if they are not the same length, it goes short to long

[19:27] *** Chillance joined
[19:27] *** azert0x joined
[19:28] <TimToady> and maybe a rule that says any time you carry something that looks like digits (in context), it becomes 0

[19:29] <TimToady> but also maybe just say, "screw you" at that point.  ;)

[19:29] <patrickas> hehehehe

[19:30] <patrickas> well I did implement it the way it is currently specced

[19:31] <patrickas> so I'll I guess i just need to detect that special case and fail("screw you") on it :-)

[19:31] <TimToady> I may yet come around to your way of thinking, if they're gonna be screwed anyway

[19:32] <flussence> IMO if someone wants numeric ranges, that's what the .Int method's for

[19:32] <flussence> rakudo: say ~('0o07'.Int ... 10)

[19:32] <p6eval> rakudo 9993bb: OUTPUT«7 8 9 10␤»

[19:33] *** goksie left
[19:33] <TimToady> yes, but if they want octal numbers out, that doesn't do it

[19:33] <TimToady> or worse, duodecimal

[19:34] <flussence> oh, output? so it'd be "OUTPUT«0o07 0o10..." in that line above?

[19:34] <flussence> or whatever

[19:35] <TimToady> well, it's still hard to encode 3 data points into 2 values

[19:35] *** masak left
[19:36] <TimToady> the current algoritm conflates starting value with low end of range

[19:36] <patrickas> low end of range for each digit

[19:37] <TimToady> what I meant

[19:37] <TimToady> so either we ignore the end digits and take the 0 from the beginning, or we screw 'em

[19:37] <TimToady> propagating a 0 is likely to dwtm

[19:38] <TimToady> but yes, it does rather preclude the naïve X~ implementation

[19:39] <TimToady> it's probably one of those things that really ought to have an explicit function that specs the ranges

[19:40] *** gottreu joined
[19:40] <TimToady> as in S03:2074

[19:41] <TimToady> so maybe leave it at X~ for now

[19:42] *** Italian_Plumber joined
[19:42] <patrickas> ok

[19:43] *** daemon left
[19:43] *** wamba left
[19:46] *** daemon joined
[19:50] <colomon> random thought.... might it be more sensible to not spec anything like that at all, and just make sure there is a function to make base-N-in-string succ very easy to use for a series?

[19:50] <TimToady> didn't I just say that?

[19:50] <colomon> I dunno.  but if you did, TimToady++

[19:51] *** jaldhar left
[19:51] <flussence> Is there a way to get at character classes in normal code? Something that looks like Range.new('000' => 'zzz', :chars<alnum>) would be easy enough for most people to understand.

[19:51] <TimToady> that's what S03:2074 sez

[19:51] <patrickas> :-) that's the S03:2074 thingy, *.succ-in(@greek)

[19:53] <TimToady> flussence: it would be pretty easy to construct an @alnum by grepping 0..0x10ffff for /\w/

[19:54] <TimToady> perhaps @alnum isn't quite what you want htough

[19:54] <TimToady> though even

[19:54] <TimToady> you want %alnum-succ{$char} and %alnum-pred{$char}

[19:55] <TimToady> and some indication of how to carry

[19:56] <PerlJam> I want a way to define my "alphabet" and have .succ and .pred use it  :)

[19:56] <TimToady> that's the idea

[19:56] <TimToady> only without clobbering the built-ins

[19:56] <PerlJam> right

[19:56] <colomon> +1

[19:59] <PerlJam> how does Perl know how about 'a' .. 'z' anyway?

[19:59] <PerlJam> s/how//

[19:59] <TimToady> S03:1997

[19:59] <PerlJam> er, s:2nd/how// even

[20:00] *** Italian_Plumber left
[20:01] <PerlJam> That doesn't quite answer what I want to know I don't think.

[20:02] *** Eevee left
[20:02] *** timbunce left
[20:03] <PerlJam> or maybe it does

[20:03] <patrickas> Is there a more elegant wayt of getting $str.comb(/./) ?

[20:03] <PerlJam> if I can lexically define a sub that determines "is alphabetic"

[20:04] <TimToady> you mean like $str.comb?

[20:04] <tylercurtis> rakudo: say .perl given 'abdklsfoeknl4r'.comb;

[20:04] <TimToady> rakudo: say ~"patrickas".comb

[20:04] <patrickas> oh yes that's the one!

[20:04] <p6eval> rakudo 9993bb: OUTPUT«("a", "b", "d", "k", "l", "s", "f", "o", "e", "k", "n", "l", "4", "r")␤»

[20:04] <p6eval> rakudo 9993bb: OUTPUT«p a t r i c k a s␤»

[20:05] <patrickas> :-)

[20:06] *** Eevee joined
[20:06] <TimToady> PerlJam: a junction or hash would be more generally useful, along with a list

[20:07] <PerlJam> I keep thinking there's some unrealized general mechanism here, but I guess we already have it.  :)

[20:08] <TimToady> for something called a lot you might want a curried successory function

[20:08] * tylercurtis was just looking for an excuse to try out '.meth given $something' as a way to call methods as prefixes.

[20:08] *** timbunce joined
[20:08] * TimToady pictures a well successorized model

[20:09] * TimToady will probably be arrested for being a successory before the fact

[20:10] <PerlJam> How would one do  <a g c t> X~ <a g c t> X~ <a g c t>  using the series op?

[20:11] <TimToady> 'aaa', *.succ-in(<a g c t>) ... 'ttt'

[20:11] <TimToady> or something curried to go faster

[20:12] <TimToady> unless .succ-in is self-memoizing

[20:12] <TimToady> but memoization overhead is probably worse than precalculating the hash of successors

[20:14] <diakopter> sufferin' succohash

[20:14] * TimToady wonders if an enum map can store all that as both hashy and listy info

[20:14] <PerlJam> .succ-in is a terribly name BTW  :)

[20:14] <patrickas> rakudo: say '1' .. '3'; say '3' .. '1';

[20:14] <p6eval> rakudo 9993bb: OUTPUT«123␤␤»

[20:15] <TimToady> a range's order check happens before conversion to ...

[20:15] <TimToady> so '3' .. '1' is properly ()

[20:17] <sorear> TimToady: Should regexes without explicit () parameter lists get $_ placeholders?

[20:17] <diakopter> rakudo: say (3,6...6).perl

[20:17] <p6eval> rakudo 9993bb: OUTPUT«(3, 6)␤»

[20:17] <diakopter> rakudo: say (3,6...6.1).perl

[20:17] <p6eval> rakudo 9993bb: OUTPUT«(timeout)»

[20:17] * diakopter hopes this is known

[20:17] <colomon> diakopter: last series is infinite.

[20:17] <patrickas> yes, that's "unexpected" behaviour of '10' ... '07'   # same as '1' .. '0' X~ '0' .. '7'

[20:18] <flussence> does .succ-in need to be a separate method? i.e. if .succ had the list as an optional param instead, would it mess anything up?

[20:18] <colomon> diakopter: that's spec

[20:18] <diakopter> k

[20:18] <sorear> recent change

[20:18] <patrickas> it's not even <1 0> X~ '0' .. '7' as I would have naively expected

[20:18] <sorear> the limit in a ... is always exact now

[20:18] <colomon> rakudo: say (3, 6 ... (* >= 6)).perl

[20:19] <p6eval> rakudo 9993bb: OUTPUT«(3, 6)␤»

[20:19] <colomon> rakudo: say (3, 6 ... (* >= 6.1)).perl

[20:19] <p6eval> rakudo 9993bb: OUTPUT«(3, 6, 9)␤»

[20:19] <sorear> (and a smart-match)

[20:19] <colomon> rakudo: say (3, 6 ...^ (* >= 6.1)).perl

[20:19] <p6eval> rakudo 9993bb: OUTPUT«(3, 6)␤»

[20:19] <colomon> patrickas++

[20:19] <TimToady> superstitious parens?

[20:20] <colomon> TimToady: that's how I roll.

[20:20] <colomon> rakudo: say (3, 6 ...^ * >= 6.1).perl

[20:20] <p6eval> rakudo 9993bb: OUTPUT«(3, 6)␤»

[20:20] <patrickas> I guess by now we can call them patrickas parens

[20:20] <sorear> TimToady: what blocks do I need to generate ($_?) sigs on, and which can I let be ()?

[20:20] <patrickas> I think we could also name the space accidentally added after function calls after me :-)

[20:21] <TimToady> sorear: for sure you don't need $_ if it isn't used...

[20:22] <TimToady> though if something is expecting to feed a value to an arity-0 function, you still need the $?

[20:23] *** kjeldahl_ left
[20:23] <TimToady> rakudo: say ~(rand ... *)[^5]

[20:23] <p6eval> rakudo 9993bb: OUTPUT«0.706235900378914 1.70623590037891 2.70623590037891 3.70623590037891 4.70623590037891␤»

[20:23] <TimToady> that's a bad example though

[20:24] <TimToady> probably means successive thinking needs a predeccessory nap

[20:24] <TimToady> zzz &

[20:25] <sorear> I thought rand ~~ 0..^1

[20:25] *** perlygatekeeper joined
[20:26] <PerlJam> sorear: it is

[20:26] <sorear> oh, it's just being used as the initial

[20:26] <PerlJam> right

[20:26] *** shortcircuit joined
[20:27] <PerlJam> rakudo: say ~({rand} ... *)[^5]

[20:27] <p6eval> rakudo 9993bb: OUTPUT«0.306957105497958 0.771434015865577 0.355967136655586 0.380212301749527 0.67573216882009␤»

[20:27] * tylercurtis shopping &

[20:27] <tylercurtis> Hopefully, I'll find some time to get Bennu parsing expressions, too.

[20:27] <tylercurtis> By, folks.

[20:27] <PerlJam> that seems like such a small change to great effect

[20:27] <patrickas> rakudo: say  ( [X~] ('000'.comb Z.. '122'.comb) ).perl; #I re-killed a coroutine

[20:27] <PerlJam> perl6++

[20:27] <p6eval> rakudo 9993bb: OUTPUT«Cannot resume dead coroutine.␤  in 'Any::join' at line 1␤  in 'List::Str' at line 2558:CORE.setting␤  in 'infix:<~>' at line 7033:CORE.setting␤  in <anon> at line 154:CORE.setting␤  in <anon> at line 1␤  in 'List::Bool' at line 1␤  in 'prefix:<?>' at line 416:CORE.setting␤  in

[20:27] <p6eval> ..<ano…

[20:27] *** tylercurtis left
[20:32] <ZadYree> perl6: my $fref = sub{ say("ABC");}; $fref();

[20:33] <p6eval> pugs, rakudo 9993bb: OUTPUT«ABC␤»

[20:33] *** kjeldahl joined
[20:37] <ZadYree> perl6: my $rlist = [sub{say"A"}, sub{my $a = 2; my $b = 4; say 2 + 4;}, sub{.say}]; $rlist[2]();

[20:37] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "$rlist"␤    expecting "=", context, ":" or "("␤    at /tmp/4S8UyNKYSI line 1, column 4␤»

[20:37] <p6eval> ..rakudo 9993bb: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[20:37] <ZadYree> perl6: my $rlist = [sub{say"A"}, sub{my $a = 2; my $b = 4; say 2 + 4;}, sub{.say}]; $rlist[2]("aaa"));

[20:37] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "$rlist"␤    expecting "=", context, ":" or "("␤    at /tmp/eh7O7W_GYC line 1, column 4␤»

[20:37] <p6eval> ..rakudo 9993bb: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[20:37] <flussence> ZadYree: you don't need to write "sub" in perl6

[20:37] <ZadYree> ah?

[20:38] <ZadYree> tell me :S

[20:38] <flussence> it's implied with the {...}s

[20:38] <ZadYree> well

[20:38] <ZadYree> & what about hashtables in unreferences arrays?

[20:39] <ZadYree> in perl5: $foo = ["aa", {"bar" => "baz"}]

[20:39] *** Guest27047 joined
[20:40] <flussence> I don't understand it completely, but it probably works the same way map {...} does in p5 for differentiating the two

[20:40] <flussence> rakudo: say {a=>1}.WHAT; say { 1; 2 }.WHAT

[20:40] <p6eval> rakudo 9993bb: OUTPUT«Hash()␤Block()␤»

[20:41] <ZadYree> that's so weird

[20:41] <dukeleto> flussence: { } is a code block in perl 6

[20:41] <ZadYree> thos .THINGS are a PITA to learn

[20:41] <dukeleto> flussence: => returns a Hash in the first example

[20:42] *** rindolf joined
[20:42] <flussence> rakudo: { ; a => 1 }.WHAT # curious

[20:42] <p6eval> rakudo 9993bb:  ( no output )

[20:42] <flussence> whoops

[20:42] <flussence> rakudo: say { ; a => 1 }.WHAT

[20:42] <p6eval> rakudo 9993bb: OUTPUT«Block()␤»

[20:42] <flussence> rakudo: say { ; a => 1 }.().WHAT

[20:42] <ZadYree> another question: Will my old p5 scripts be compatible w/ p6?

[20:43] <p6eval> rakudo 9993bb: OUTPUT«Pair()␤»

[20:43] <flussence> ah, that makes sense

[20:43] <sorear> No.

[20:43] <dukeleto> ZadYree: no, they won't, but you can use Perl 5 modules from Perl 6

[20:44] <dukeleto> ZadYree: with blizkost

[20:44] <ZadYree> don't you find this weird?

[20:44] <sorear> no

[20:44] <dukeleto> ZadYree: why? perl 6 is not the same language as perl 5

[20:44] <sorear> why would you want to run your old Perl 5 scripts on Perl 6?

[20:44] <ZadYree> I mean, for every servers using p5 scripts, etc

[20:44] <sorear> /usr/bin/perl is not going away

[20:44] <ZadYree> ah

[20:45] <flussence> it's like the difference between VB6 and VB.Net (or so I'm told)

[20:45] <PerlJam> ZadYree: they can continue to use perl 5.

[20:45] <sorear> it's impossible to do a rewrite this big without breaking bug-compatibility

[20:45] <dukeleto> ZadYree: perl 5 lives on, independent of perl 6

[20:45] <ZadYree> ooo

[20:45] <sorear> which means that nobody is going to get rid of the old version

[20:45] <ZadYree> I didn't know that

[20:45] <dukeleto> ZadYree: people call them "sister languages"

[20:45] <ZadYree> hehe

[20:45] *** Guest27047 left
[20:45] <ZadYree> that's pretty nice, cause I was starting freaking out my pants

[20:46] <sorear> "other version" would be more appropriate

[20:46] *** Guest27047 joined
[20:46] <ZadYree> other perl distro ^^

[20:46] *** ruoso left
[20:46] <sorear> perl 5.8, 5.10, and 5.12 all came out after Perl 6 started

[20:46] <ZadYree> yup

[20:46] <sorear> the two series have been cooperating quite a bit

[20:47] <sorear> perl 6 also targets a slightly different niche than Perl 5; quick-and-dirty file scraping and reporting scripts are NOT what we are focusing on this time

[20:52] <flussence> OK so if I'm understanding series operators right, .succ is in effect a curried function that gets passed between values to generate the next one along?

[20:54] *** Italian_Plumber joined
[20:55] *** Ross left
[20:55] *** tadzik joined
[20:56] <patrickas> .succ is one of the possible functions depending on the endpoints

[20:56] <tadzik> hello again

[20:56] <flussence> 'lo

[20:57] <flussence> How does a range decide whether to use .succ/.pred, is that an implementation detail?

[20:57] <dukeleto> sorear: what niche *is* perl 6 focusing on? ::puts on devils advocate hat::

[20:58] <jnthn> All of them! ;-)

[20:59] *** Italian_Plumber left
[20:59] <sorear> dukeleto: the stuff people actually use Perl 5 for

[21:00] <patrickas> flussence: it is specced in S03:1750

[21:00] <patrickas> flussence: but it is still kind of a work in progress for some edge cases :-)

[21:01] *** alester joined
[21:04] *** rindolf left
[21:04] *** whiteknight joined
[21:06] *** tadzik left
[21:09] * patrickas out

[21:09] *** patrickas left
[21:11] <flussence> ah, I think I get it now

[21:17] *** kjeldahl left
[21:17] *** Entonian joined
[21:23] *** Schwern joined
[21:33] <dalek> niecza: 6617fa8 | sorear++ | src/ (3 files):

[21:33] <dalek> niecza: generate code for calling Backtrack once only

[21:33] <dalek> niecza: review: http://github.com/sorear/niecza/commit/6617fa8d6f972e9695b90bad10aea2b4b0442223

[21:33] <dalek> niecza: a85618a | sorear++ | src/Optimizer/RxSimple.pm:

[21:33] <dalek> niecza: optimization for cut befores, etc

[21:33] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a85618a4d4a894f3399b2556e1f86856e9b89332

[21:33] <dalek> niecza: 94cf523 | sorear++ | src/Niecza/Actions.pm:

[21:33] <dalek> niecza: Disable generation of $_ placeholder for rules

[21:33] <dalek> niecza: review: http://github.com/sorear/niecza/commit/94cf523637beaecf2a6cb7295adc86c3d30636de

[21:33] <dalek> niecza: 1bf77fa | sorear++ | / (5 files):

[21:33] <dalek> niecza: Decouple LAD optimization from RxOp

[21:33] <dalek> niecza: review: http://github.com/sorear/niecza/commit/1bf77fa46bea7d96c54af33d484e4dd5511609a3

[21:34] *** Sandy joined
[21:35] *** Sandy is now known as Guest43910

[21:35] *** Guest43910 left
[21:37] *** smash left
[21:41] *** sdziegie left
[21:56] *** cotto_work left
[22:03] *** Holy_Cow left
[22:03] *** vapace left
[22:03] *** cj left
[22:12] *** timbunce left
[22:20] *** Entonian left
[22:23] *** cj joined
[22:25] *** meraxes left
[22:32] *** amkrankruleuen joined
[22:34] *** cj left
[22:36] *** sftp left
[22:38] <dalek> niecza: 1705097 | sorear++ | src/Optimizer/RxSimple.pm:

[22:38] <dalek> niecza: First crack at LAD-specific optimizer

[22:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/17050978124cf61ea8a3c557723bdea79a26acf9

[22:38] <dalek> niecza: 0c65460 | sorear++ | src/Optimizer/RxSimple.pm:

[22:38] <dalek> niecza: Optimization for negated character classes

[22:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0c65460c750fd0423a37b76cf0ac6d6314913912

[22:38] <dalek> niecza: a64e016 | sorear++ | / (3 files):

[22:38] <dalek> niecza: Implement special case for quantified character classes

[22:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a64e0166f466087a8d02a18f662a73d47244252a

[22:42] *** Guest27047 left
[22:44] *** mberends left
[22:46] *** shortcircuit left
[22:46] *** shortcircuit joined
[22:48] *** araujo left
[22:48] *** amkrankruleuen left
[22:51] *** shortcircuit left
[22:52] *** shortcircuit joined
[22:56] *** meppl joined
[22:57] *** christin1 left
[22:58] *** mberends joined
[22:59] *** cj joined
[23:00] *** azert0x left
[23:05] *** Schwern left
[23:13] *** xinming left
[23:13] *** xinming joined
[23:23] *** cdarroch left
[23:34] *** thundergnat joined
[23:40] *** LionMadeOfLions left
[23:41] *** ruoso joined
[23:41] *** masonkramer joined
[23:47] *** araujo joined
[23:57] *** pochi joined
[23:58] <pmichaud> http://gist.github.com/578279   # I'm very confused by this.  The definition of Buf.decode2() is *exactly* the same as the definition of Buf.decode().

[23:58] <pmichaud> (except for the name, obviously)

