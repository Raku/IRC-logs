[00:02] *** Khisanth left
[00:03] <colomon> rakudo: say NaN == NaN

[00:03] <p6eval> rakudo ab2322: OUTPUTÂ«0â¤Â»

[00:06] *** Khisanth joined
[00:09] <colomon> rakudo: say NaN cmp NaN

[00:10] <lue> o hai again

[00:10] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤Â»

[00:10] <lue> not a number apparently is not not a number :) [according to NaN == NaN]

[00:11] <lue> rakudo: say NaN ~~ NaN # who knows?

[00:11] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤Â»

[00:11] <diakopter> rakudo: say NaN - NaN

[00:11] <p6eval> rakudo ab2322: OUTPUTÂ«NaNâ¤Â»

[00:11] <diakopter> rakudo: say NaN ** NaN

[00:11] <p6eval> rakudo ab2322: OUTPUTÂ«NaNâ¤Â»

[00:11] <diakopter> rakudo: say NaN / 0

[00:11] <p6eval> rakudo ab2322: OUTPUTÂ«Divide by zeroâ¤current instr.: 'infix:</>' pc 305405 (src/gen/core.pir:3048)â¤Â»

[00:11] *** am0c left
[00:12] <diakopter> rakudo: say 0 / NaN

[00:12] <p6eval> rakudo ab2322: OUTPUTÂ«NaNâ¤Â»

[00:12] <ash___> rakudo: say NaN.abs

[00:12] <p6eval> rakudo ab2322: OUTPUTÂ«NaNâ¤Â»

[00:12] <ash___> rakudo: say (-Inf).abs

[00:12] <p6eval> rakudo ab2322: OUTPUTÂ«Infâ¤Â»

[00:14] <lue> colomon!: http://en.wikipedia.org/wiki/James_Anderson_%28computer_scientist%29#Transreal_arithmetic_and_other_arithmetics

[00:14] <lue> explains why NaN == NaN fails

[00:19] <lue> rakudo: multi sub infix:</>($a, $b){if $b == 0 {say "Î¦";}; else { say $a div $b;}; }; 3/7; 9/0; # transreal numbers!

[00:19] <p6eval> rakudo ab2322:  ( no output )

[00:19] <lue> Å.o

[00:19] <arnsholt_> rakudo: our multi sub infix:</>($a, $b){if $b == 0 {say "Î¦";}; else { say $a div $b;}; }; 3/7; 9/0; # I think...

[00:20] <p6eval> rakudo ab2322:  ( no output )

[00:20] <arnsholt_> Or not. Oh well

[00:20] *** arnsholt_ is now known as arnsholt

[00:21] <lue> maybe overload is broken/NYI ?

[00:24] <lue> rakudo: say 1/0; say "I'm okay!"

[00:24] <p6eval> rakudo ab2322: OUTPUTÂ«Infâ¤I'm okay!â¤Â»

[00:28] <colomon> rakudo: multi sub infix:</>($a, $b){if $b == 0 {say "Î¦";} else { say $a div $b;}; }; 3/7; 9/0; # transreal numbers!

[00:28] <p6eval> rakudo ab2322:  ( no output )

[00:28] <colomon> :\

[00:29] <colomon> rakudo: multi sub infix:<//////>($a, $b){if $b == 0 {say "Î¦";} else { say $a div $b;}; }; 3//////7; 9//////0; # transreal numbers!

[00:29] <p6eval> rakudo ab2322: OUTPUTÂ«0â¤Î¦â¤Â»

[00:30] <colomon> lue: my problem at the moment is that somehow Test.pm's is was getting NaN to equal NaN, but I broke it in my local copy, making zillions of tests fail.

[00:30] <lue> why would want it to equal itself? It's an error.

[00:31] <colomon> yes, but you need to be able to check and see if that error happened.  That's the point of the tests in question.

[00:31] <ash___> rakudo: say 1/0 ;

[00:31] <p6eval> rakudo ab2322: OUTPUTÂ«Infâ¤Â»

[00:31] <ash___> o.0 

[00:31] <colomon> that's a Rat, btw.

[00:31] <ash___> I thought that was an error and NaN? 

[00:32] <colomon> nope.

[00:32] <lue> IEEE floating point arithmetic.

[00:32] <lue> rakudo: say 1/-0

[00:32] <p6eval> rakudo ab2322: OUTPUTÂ«Infâ¤Â»

[00:32] <lue> rakudo: say -1/0

[00:32] <p6eval> rakudo ab2322: OUTPUTÂ«-Infâ¤Â»

[00:33] <lue> -0 should have produced -Inf, IIRC

[00:33] <colomon> I don't think so, because -0 is an Int, and for Ints, -0 == 0

[00:34] <colomon> there's only one zero

[00:34] <colomon> rakudo: say 1 / -(0.Num)

[00:34] <p6eval> rakudo ab2322: OUTPUTÂ«Divide by zeroâ¤current instr.: 'infix:</>' pc 305405 (src/gen/core.pir:3048)â¤Â»

[00:34] <colomon> rakudo: say 1 / (0.Num)

[00:34] <p6eval> rakudo ab2322: OUTPUTÂ«Divide by zeroâ¤current instr.: 'infix:</>' pc 305405 (src/gen/core.pir:3048)â¤Â»

[00:34] <colomon> rakudo: say 1.Num / (0.Num)

[00:34] <p6eval> rakudo ab2322: OUTPUTÂ«Divide by zeroâ¤current instr.: 'infix:</>' pc 305405 (src/gen/core.pir:3048)â¤Â»

[00:34] <lue> rakudo: say (3.5).WHAT

[00:35] <p6eval> rakudo ab2322: OUTPUTÂ«Rat()â¤Â»

[00:35] <lue> Is Rat == Floating Point in perl6?

[00:36] *** hercynium joined
[00:37] *** rgrau_ joined
[00:40] <colomon> no, Rat is a rational number, int over int.

[00:40] <colomon> decimal numbers are now rational, not floating point.

[00:42] *** supernovus joined
[00:43] <colomon> I see.

[00:44] *** jql joined
[00:44] <colomon> Problem is that Rakudo is broken.... or maybe I don't understand the comparison operators.

[00:44] <colomon> Ah, I don't understand the comparison operators.

[00:44] <colomon> okay, this is an easy fix.

[00:45] <ash___> ?

[00:45] <colomon> I was thinking that infix:<eq> was equivalent to infix:<cmp> == 0

[00:45] <colomon> but it's not, it's infix:<leg> == 0

[00:46] <ash___> eqv or eq? Isn't eq for strings? 

[00:46] <colomon> ie infix:<eq> is string equality, not DWIM equality

[00:46] <supernovus> I read in the backlogs that := is not going to be implemented any time soon. I would then recommend that the IO::Socket::INET module be rewritten to not use it. Many libraries such as HTTP::Daemon and SCGI depend on the IO::Socket::INET library which is included in the Core, but currently does not work due to the := not being implemented.

[00:46] <lue> (with so many comparison operators, no other language compares)

[00:46] <lue> supernovus: who said that?

[00:47] <colomon> I overloaded infix:<eq> to be use infix:<cmp> for numbers.  that's what broke all the NaN tests.

[00:47] <colomon> because "NaN" does equal "NaN" 

[00:47] <colomon> even if NaN != NaN

[00:47] <ash___> ah

[00:47] <ash___> NaN fails all numeric comparison tests

[00:48] <supernovus> lue: Well, I haven't completely caught up yet, so I may be speaking out my arse, but you had asked about it and diakopter said it would take hundreds->thousands of hours to implement...

[00:49] <lue> I don't know much about the guts, but that seemed like a hyperbole to me.

[00:50] <lue> For $a := $b, you just need to assign $a to $b's location. (masak pointed me to a blog post earlier today, it's in the backlogs and explains better than me)

[00:51] <supernovus> The := thing is one of the few reasons left to stick with the 'alpha' branch. I will continue scouring the backlogs. :-)

[00:51] <ash___> rakudo: my $a = 1; my $b = \$a; say $b # is that supposed to say capture? 

[00:51] <p6eval> rakudo ab2322: OUTPUTÂ«Capture()<0x14d22b0>â¤Â»

[00:51] <ash___> alpha: my $a = 1; my $b = \$a; say $b ;

[00:51] <p6eval> alpha 30e0ed: OUTPUTÂ«1â¤Â»

[00:52] <lue> rakudo: my $a = 1; my $b = \$a; $b = 2; say $a

[00:52] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤Â»

[00:52] <lue> rakudo: my $a = 1; my $b = \$a; $b = 2; say $a; say $b;

[00:52] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤2â¤Â»

[00:52] <ash___> rakudo: my $a = 1; my $b = \$a; $a = 2; say $a; say $b;

[00:52] <p6eval> rakudo ab2322: OUTPUTÂ«2â¤Capture()<0x3f4e440>â¤Â»

[00:53] <colomon> I think there was definitely a misunderstanding on the complexity of implementing binding.

[00:53] <colomon> (in that discussion yesterday)

[00:53] *** [particle] left
[00:54] <lue> AFAIK, it should be _that_ hard.

[00:54] <lue> s/should/shouldn't/

[00:54] <supernovus> Well, I wish I knew more about the guts. I'm going to try to get some of my libraries like SCGI working on the new master, then I'll have to find out about adding them to proto. Oh well, I'm off to watch tonight's Doctor Who. Later!

[00:55] <lue> me too.

[00:55] <lue> supernovus: me too! afk

[00:55] <lue> (first me too about the guts, second about DW)

[00:55] *** supernovus left
[00:57] <ash___> this is kinda like := but not exactly: 

[00:57] <ash___> rakudo: my $a = 1; my $b = \$a; $a = 2; say $a; say $b[0]; $a = 123 ~ "hello"; say $b[0];

[00:57] <p6eval> rakudo ab2322: OUTPUTÂ«2â¤2â¤123helloâ¤Â»

[00:58] <ash___> $b is a capture of $a, so updating $a updates $b 

[00:58] <sorear> lue: If you think Rakudo is ever going to be faster than hand-optimized x86 code on qemu, you're crazy

[00:58] <sorear> also I don't understand what your deal is with mactel

[00:58] *** [particle] joined
[01:01] <sorear> incidentally, Rakudo already implements binding.

[01:01] <sorear> Just not the := syntax.

[01:01] <ash___> sorear: how? 

[01:01] <ash___> I know you can use a capture to get := like behavoiur 

[01:02] <sorear> rakudo: sub foo($x is rw, $y is rw) { say $x; $y = 2; say $x; }; my $z = 1; foo($z, $z);

[01:02] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤2â¤Â»

[01:02] <sorear> within the invocation, $x and $y are aliases

[01:03] <ash___> rakudo: my $x = 1; my $y = \$x; $y[0] = 123; say $x;

[01:03] <p6eval> rakudo ab2322: OUTPUTÂ«123â¤Â»

[01:03] <ash___> thats why that worked, the parameters are captures 

[01:04] <ash___> although, in alpha you didn't have to do [0] on the capture

[01:04] <ash___> alpha: my $x = 0; my $y = \$x; $y = 123; say $x;

[01:04] <p6eval> alpha 30e0ed: OUTPUTÂ«0â¤Â»

[01:04] <ash___> hmm

[01:05] <ash___> alpha: my $x = 0; my $y = \$x; $x = 123; say $y;

[01:05] <p6eval> alpha 30e0ed: OUTPUTÂ«123â¤Â»

[01:05] <ash___> maybe in alpha captures are only one directional 

[01:09] <sorear> What are you talking about?

[01:10] <ash___> using the $y from "my $x = 0; my $y = \$x;" to update $x 

[01:10] <sorear> This has nothing to do with binding.

[01:11] <ash___> I was just pointing out that captures function similar to bindings 

[01:11] <sorear> A capture is just an array + hash

[01:12] <sorear> You've discovered it's possible to update elements in arrays.

[01:12] <ash___> rakudo: my $x = 1; my $y = \$x; $y[0] = 123; say $x; # is almost the same functionality as $y := $x; $y = 123;

[01:12] <p6eval> rakudo ab2322: OUTPUTÂ«123â¤Â»

[01:14] <ash___> with normal arrays and hashes you can't update the variable that assigned you the value, my $x = 0; @a[0] = $x; @a[0] = 123; doesn't make $x = 123; but you can do that with a capture 

[01:18] <sorear> that's because your desugaring is wrong

[01:19] <sorear> my $x = 0; @a[0] := $x; $a[0] = 123

[01:19] <sorear> captures aren't like binding or a substitute for binding

[01:19] <sorear> they are implemented using binding

[01:49] *** tylerni7 joined
[01:49] *** tylerni7 left
[01:49] *** tylerni7 joined
[01:54] *** tylerni7 left
[01:54] *** tylerni7 joined
[01:54] *** tylerni7 left
[01:54] *** tylerni7 joined
[01:59] <dalek> rakudo: c52c61a | (Solomon Foster)++ | src/core/ (4 files):

[01:59] <dalek> rakudo: Add Numeric versions of the infix:<cmp> family of operators.  Move the old infix:<cmp>(Num, Num) operator code to infix:«<=>»(Num, Num) and delete infix:<cmp>(Num, Num).  Remove the Rat versions of infix:<cmp>.

[01:59] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c52c61a87f163e49cb4fa5ef3d92482584d2e0fb

[01:59] <dalek> rakudo: 9427875 | (Solomon Foster)++ | tools/test_summary.pl:

[01:59] <dalek> rakudo: Change // to || to keep Perl 5.8 happy.

[01:59] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9427875e1fac5c7ee5fda730446c1436c761e137

[01:59] <dalek> rakudo: 85a7aa4 | (Solomon Foster)++ | src/core/Numeric.pm:

[01:59] <dalek> rakudo: Eliminate Numeric versions of eq, ne, lt, gt, le, and ge -- these should always be string comparisons.

[01:59] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/85a7aa428dc3be5d415ef79dacaa5f0fa6c044f5

[02:00] *** Psyche^ joined
[02:02] <pugssvn> r30593 | colomon++ | [t/spec] Fudge Complex Rcmp tests.  Add Real tests for cmp, before, and after.  Fix a couple of Complex-valued tests to use is_approx rather than is. 

[02:04] *** Patterner left
[02:04] *** Psyche^ is now known as Patterner

[02:04] <lue> hello!

[02:07] <lue> sorear: I don't appreciate that. Who says rakudo can't be faster? I will say again: emulation of a chip (esp. Intel emu. on PPC) is slow for me.

[02:07] <lue> My deal with mactel is that it's new, and uses Intel.

[02:07] *** chitragupt_1 joined
[02:07] *** gurjeet joined
[02:10] *** chitragupt_1 left
[02:10] <lue> (When the streets of #perl6 are busy, I ought to ask for details on := and why no-one's implemented yet.)

[02:10] *** chitragupt_1 joined
[02:10] <colomon> So, Dr. Who any good tonight?

[02:13] <lue> yes! The Weeping Angels.

[02:13] <lue> (part 1 of 2)

[02:14] *** chitragupt_1 left
[02:15] <lue> And according to the trailer for Part 2, time is going to disintegrate or something.

[02:15] <lue> again.

[02:15] *** chitragupt_1 joined
[02:15] <colomon> :)

[02:16] *** chitragupt_1 left
[02:16] <lue> seriously, it happened about 5 months ago (our time) with the last doctor!

[02:17] *** chitragupt_1 joined
[02:17] <lue> and it's not even the season finale, so what the heck is going to happen _*then*_ ? :)

[02:18] <colomon> surprised early season finale!!

[02:18] <lue> no, the episode with stoneheâ€” *cough* a famous monument â€” hasn't happened yet.

[02:21] <colomon> that's what they *want* you to think.

[02:22] <lue> are they saying a trailer for the stonehenge epsiode is an experiment by the BBC to extend DW's "flux time" beyond the series !?

[02:22] <lue> s/are they/are you/

[02:23] <lue> O.o                                                 run.

[02:24] <colomon> rakudo: say sqrt(:x(10))

[02:24] <p6eval> rakudo ab2322: OUTPUTÂ«No applicable candidates found to dispatch to for 'sqrt'. Available candidates are:â¤:(Complex $x)â¤:(Any $x)â¤â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[02:25] * lue is getting ready to dabble in æ—¥æœ¬èª

[02:27] <spinclad> diakopter: pong  # finally unbacklogged

[02:28] <spinclad> diakopter: i see the wonderful shiny closureness now in perlesque!  \o/  diakopter++  perlesque++

[02:30] <lue> buubot: karma perlesque

[02:30] <buubot> lue: perlesque has karma of 1     

[02:31] *** circuitbreaker joined
[02:34] <diakopter> spinclad: yeah :)

[02:37] *** chitragupt_1 left
[02:40] <sorear> phenny: tell moritz_ that I've decided I don't like the plan I had earlier for splitting the setting, so I have nothing more for topic/lexical-persistence

[02:40] <phenny> sorear: I'll pass that on when moritz_ is around.

[02:42] <lue> does rakudo have an API or equivalent, for people wishing to muck about in its internals?

[02:43] <colomon> not as such.

[02:43] <sorear> it doesn't have a defined API but that shouldn't stop you

[02:43] <colomon> I mean, generally you just muck about.

[02:44] <sorear> with early-development software like rakudo, the API forms as we standardize mucking

[02:44] <sorear> the mucking comes first

[02:44] <diakopter> dukeleto: I'll try to make the May 25 thing

[02:44] <sorear> rakudo: say Perl6::Compiler.compile("2+2", target=>"pir");

[02:44] <p6eval> rakudo ab2322: OUTPUTÂ«â¤.HLL "perl6"â¤â¤.namespace []â¤.sub "_block59"  :anon :subid("18_1273372087.95608")â¤    .param pmc param_72 :slurpyâ¤.annotate "line", 0â¤    .const 'Sub' $P63 = "19_1273372087.95608" â¤    capture_lex $P63â¤.annotate "line", 1â¤    get_hll_global $P61, "!UNIT_START"â¤    .const 'Sub'

[02:44] <p6eval> ..$P63â€¦

[02:44] <lue> because I had a difficult time finding variable creation/initialization

[02:46] <sorear> rakudo: my $a; my $b; pir::store_lex__vSP('$b', $a); $b = 1; say $a;

[02:46] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤Â»

[02:46] <sorear> rakudo: my $a; my $b; pir::store_lex__vSP('$b', $a); $a = 1; say $b;

[02:46] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤Â»

[02:48] <diakopter> sorear: should I implement classes next? it's a very straightforward thing, much more so than getting closures right... since runsharp already does most of it for me.

[02:51] <sorear> diakopter: What would I know about priorities for an implementation of Perl 6 I haven't contributed to and don't use in an environment I don't run?

[02:51] <sorear> er

[02:51] <sorear> implementation of NQP

[02:51] *** nihiliad joined
[02:51] <sorear> oops.

[02:52] *** JimmyZ joined
[02:53] *** meppl joined
[02:53] <diakopter> it's not really meant to implement NQP, though someone could use it for that

[02:53] <diakopter> I intend it to be a target language for STD and viv

[02:53] <diakopter> so STD can translate itself to perlesque

[02:54] <sorear> (and then we can rewrite viv in perl6?)

[02:54] <sorear> hmm.  interesting concept

[02:55] <sorear> NQP is currently an implementation-defined language; I wonder if we should work to draw NQP, Perlesque, NQ-NQP together

[02:55] <diakopter> my other option for "what to do next" was "string eval"

[02:55] *** alester joined
[02:56] <sorear> diakopter: How are you going to do that without STD?

[02:56] <diakopter> b/c I consider string-eval highly necessary for getting a Perl 6 compiler/JIT/runtime going in the perlesque edition of STD

[02:56] <diakopter> sorry, string eval of perlesque code

[02:56] <diakopter> (not full-blown Perl 6)

[02:57] <diakopter> I'm not using STD right now to parse perlesque code

[02:57] <diakopter> in case that wasn't clear

[02:58] <diakopter> who is working on NQ-NQP

[02:58] <diakopter> oh.

[03:05] *** nihiliad left
[03:10] *** fridim joined
[03:12] *** molaf joined
[03:19] <diakopter> thoughts on implementing string eval: at each string-eval callsite in the user code, the emitted IL needs to contain a hardcoded string key that can be used to access a global dictionary/registry of compilation-context restorer callbacks.

[03:23] <diakopter> hrm. that won't work for programs emitted to disk. instead of in-memory callbacks then, the eval function itself needs to be emitted to the IL, and the grammar needs to be refactored a bit to allow eval-mode parsing, such that ...

[03:24] <diakopter> the types stack and other various global parse state-keepers are programmatically reconstructable

[03:24] <diakopter> hrm.

[03:25] *** rv2733 joined
[03:25] <diakopter> I'd better work on classes first and let that simmer (fester?) a while.

[03:25] *** meppel joined
[03:25] <TimToady> (it's essentially the same thing as YOU_ARE_HERE in the setting)

[03:26] <diakopter> TimToady alive

[03:26] * TimToady hides behind a cricket

[03:26] <TimToady> and continues backlogging

[03:26] <diakopter> Times Square is so empty, even the cricket stands out

[03:27] <diakopter> actually though

[03:27] <diakopter> I was thinking of Perl 5-style string eval

[03:27] <diakopter> JavaScript-style string-eval would be much easier

[03:28] <pugssvn> r30594 | lwall++ | [S02] dig out T Rex fossil found by sorear++ 

[03:28] *** meppl left
[03:29] <diakopter> TimToady: perlesque passed man_or_boy

[03:29] *** meppel is now known as meppl

[03:29] <diakopter> man_vs_boyt?

[03:29] <diakopter> er

[03:29] <diakopter> man_vs_bot?

[03:29] <diakopter> ER

[03:29] <diakopter> man_vs_boy?

[03:30] <diakopter> sorear: I'm curious how long it takes rakudo to run the man_or_boy.t at the 10 result level... would you mind running it?

[03:30] <sorear> diakopter: rakudo doesn't have closures

[03:30] <diakopter> but..

[03:31] <diakopter> I thought it passed man_or_boy.t

[03:31] <diakopter> I'll look again

[03:31] <diakopter> it doesn't seem fudged

[03:32] <diakopter> oh, it's not pulled down to spectests

[03:32] <diakopter> sry

[03:33] *** BrowserUk joined
[03:35] *** meppl left
[03:35] <TimToady> rakudo: sub counter { my $x = 0; return { say $x++ } }; my $c1 = counter; my $c2 = counter; $c1(); $c1(); $c2(); $c2();

[03:35] <p6eval> rakudo ab2322: OUTPUTÂ«0â¤1â¤2â¤3â¤Â»

[03:35] <TimToady> nope

[03:36] <TimToady> I find it rather amazing that we pass as many tests as we do without that...

[03:36] <TimToady> and given that STD uses bazillions of closures...

[03:37] <TimToady> well, the p5 translation of it does

[03:37] * TimToady goes back to his cricket

[03:37] *** circuitbreaker left
[03:38] <TimToady> alpha: sub counter { my $x = 0; return { say $x++ } }; my $c1 = counter; my $c2 = counter; $c1(); $c1(); $c2(); $c2();

[03:38] <p6eval> alpha 30e0ed: OUTPUTÂ«0â¤1â¤0â¤1â¤Â»

[03:38] <TimToady> okay, just a regression

[03:38] <diakopter> perlesque: sub A(int $k,Callable[:(-->int)] $x1,Callable[:(-->int)] $x2,Callable[:(-->int)] $x3,Callable[:(-->int)] $x4,Callable[:(-->int)] $x5-->int) {my Callable[:(-->int)] $B;$B=sub (-->int) {$k-=1;return A($k,$B,$x1,$x2,$x3,$x4)};if $k<=0 {return ($x4()+$x5())};return $B()};sub K(int $n-->Callable[:(-->int)]) {return sub (-->int) {return $n}};say(A(10,K(1),K(-1),K(-1),K(1),K(0)))

[03:38] <p6eval> perlesque: OUTPUTÂ«-67â¤Â»

[03:38] <diakopter> check it out :D  /me boasts

[03:39] <TimToady> where did you get that ugly Callable syntax :P

[03:39] <diakopter> I don't know.  I almost scrapped the Callable[] and just went with :()

[03:40] <TimToady> &:() wouldn't be too bad

[03:40] <TimToady> &[] is taken though

[03:40] <diakopter> &:() would certainly be better

[03:41] <diakopter> almost as clean as C#'s  Func<TArg0, TArg1, ... , TReturn>

[03:42] <sorear> How do you plan to compile Perl6 code which uses unsigged function arguments?

[03:43] <diakopter> the Perl 6 runtime will be verry different from the perlesque runtime

[03:43] <diakopter> the Perl 6 code won't JIT nearly as directly to CIL

[03:43] <diakopter> it'll JIT to runtime calls

[03:44] <diakopter> even in perlesque, those subs aren't translated directly to CIL subs

[03:44] <diakopter> each is split into a Bind and Exec methods

[03:45] <diakopter> so the trampoline actually bounces

[03:46] <diakopter> CLR Perl 6 may well be just as function-call heavy as Parrot Perl 6

[03:47] <diakopter> but it's the function calls and existence of native types in those function calls that'll be the huge efficiency difference, imhwt (in my humble wishful thinking)

[03:47] <ash___> so far, nq-nqp is very function-call oriented, but the llvm inlines a lot of them 

[03:48] <ash___> so when you turn on optimizations, + turns into an assembly add in most cases, which is nice

[03:48] <diakopter> ash___: you're the eternity blogger?

[03:48] <sorear> where's nqnqp?

[03:48] <ash___> huh? 

[03:48] <ash___> github

[03:48] *** chitragupt_1 joined
[03:49] <diakopter> http://greaterthaninfinity.com/

[03:49] <ash___> yea

[03:49] <ash___> thats mine

[03:49] <diakopter> oh, infinity, not eternity ;)

[03:49] <sorear> ash___: Why aren't you on planet6?

[03:49] <diakopter> typo in the README:  Not Quiet NQP-rx  ->  Not Quite NQP-rx

[03:50] *** chitragupt_1 left
[03:50] <diakopter> configuratoins

[03:50] <ash___> ssshh don't say it so loud 

[03:50] <diakopter> heh

[03:50] <ash___> sorear: i duno? 

[03:50] <ash___> plus, this was more a thought experiment than anything else

[03:50] *** envi^home joined
[03:51] <sorear> diakopter: For fun, I ran man-or-boy.t on rakudo.

[03:51] <ash___> i don't plan on stopping it, and now i get to work on parrot (as a GSoC) so maybe I can bring some of the llvm's optimizations to parrot to get rid of some method calls 

[03:51] <sorear> How long did it take?  0.3 s then "Maximum recursion depth exceeded"

[03:51] <diakopter> oh; jnthn told me that can be disabled in parrot

[03:52] <diakopter> at the nqp level maybe

[03:53] <diakopter> after all, parrot uses heap frames like smalltalk & perl (& perlesque)

[03:53] *** meppl joined
[03:58] <diakopter> sorear: the runsharp compiler is now fully exposed/available to/from perlesque code.  observe:

[04:00] <diakopter> perlesque: my AssemblyGen $ag = AssemblyGen.new('foo.exe'); my TypeGen $tg1 = ($ag.Public).Class("Class0");

[04:00] <p6eval> perlesque:  ( no output )

[04:00] <diakopter> no output is good, there.

[04:03] <diakopter> fooey. I need a way to represent type literals... hack hack hack

[04:05] *** Targhan joined
[04:14] *** BrowserUk left
[04:15] *** JimmyZ left
[04:18] <snarkyboojum> alpha runs man-or-boy.t for 5 seconds before 'maximum recursion depth exceeded' :)

[04:18] <diakopter> perlesque: my $ag = AssemblyGen.new('foo.exe'); my $tg1 = ($ag.Public).Class('Class0'); my $m1 = ($tg1.Public).Method(int, 'blah'); my $cg = $m1.AsCodeGen(); $cg.Return(4); $ag.Complete();

[04:19] <p6eval> perlesque:  ( no output )

[04:19] <dalek> csmeta: r255 | diakopter++ | trunk/Sprixel/ (4 files):

[04:19] <dalek> csmeta: [perlesque] enable type literals.  I'll need casting/coercion to enable full

[04:19] <dalek> csmeta: usage of runsharp from perlesque code.

[04:19] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=255

[04:27] *** molaf left
[04:34] *** JimmyZ joined
[04:34] *** JimmyZ left
[04:42] *** JimmyZ joined
[04:44] <diakopter> perlesque: my $ag = AssemblyGen.new('foo.exe'); my $tg1 = ($ag.Public).Class('Foo'); my $m1 = (($tg1.Public).Override).Method(string, 'ToString'); my $cg = $m1.AsCodeGen(); my $o = List[Operand].new(); $o.Add(Exp.new(Operands::StringLiteral, 'blah blah')); $cg.Invoke(Console, 'WriteLine', $o.ToArray()); $cg.Return(Operands::StringLiteral.new('BLAH')); $ag.Complete(); my $foo = Activator.CreateInstance($tg1); say($foo)

[04:44] <p6eval> perlesque: OUTPUTÂ«blah blahâ¤BLAHâ¤Â»

[04:46] <diakopter> it 1. creates a new assembly named foo.exe 2. declares a class Foo a part of that assembly 3. overrides System::Object's ToString() method such that calling ToString() on a Foo object prints 'blah blah' and then returns 'BLAH' 

[04:46] <diakopter> 4. Creates a Foo, and calls say() on it, which implicitly coerces it to string (calling the virtual override ToString())

[04:46] <diakopter> tada.

[04:47] <diakopter> and I had to add only 2 magical special cases to runsharp :P

[04:48] <snarkyboojum> I manage to get a segmentation fault if I bump up the recursion limit on parrot :)

[04:48] <snarkyboojum> but it runs man-or-boy.t further :P

[04:48] <dalek> csmeta: r256 | diakopter++ | trunk/Sprixel/ (2 files):

[04:48] <dalek> csmeta: [perlesque] got class declaration working programmatically in user code, without

[04:48] <dalek> csmeta: coercion.  my $ag = AssemblyGen.new('foo.exe'); my $tg1 =

[04:48] <dalek> csmeta: ($ag.Public).Class('Foo'); my $m1 = (($tg1.Public).Override).Method(string,

[04:48] <dalek> csmeta: 'ToString'); my $cg = $m1.AsCodeGen(); my $o = List[Operand].new();

[04:48] <dalek> csmeta: $o.Add(Exp.new(Operands::StringLiteral, 'blah blah')); $cg.Invoke(Console,

[04:48] <dalek> csmeta: 'WriteLine', $o.ToArray()); $cg.Return(Operands::StringLiteral.new('BLAH'));

[04:48] <dalek> csmeta: $ag.Complete(); my $foo = Activator.CreateInstance($tg1); say($foo)

[04:48] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=256

[04:50] <snarkyboojum> guess we're still a boy :)

[04:51] <diakopter> how long does it take to segv

[04:52] <snarkyboojum> it takes 13 seconds on my laptop

[04:53] <sorear> snarkyboojum: before or after 46422?

[04:53] <diakopter> perlesquel: .

[04:53] <p6eval> perlesquel: OUTPUTÂ«blah blahâ¤BLAHâ¤real 0.18â¤user 0.14â¤sys 0.01â¤Â»

[04:53] <diakopter> perlesquel: .

[04:53] <p6eval> perlesquel: OUTPUTÂ«blah blahâ¤BLAHâ¤real 0.17â¤user 0.16â¤sys 0.00â¤Â»

[04:53] <diakopter> ooo.  I just realized that adds a 4th stage to the compilation chain

[04:55] <diakopter> 1: Sprixel.exe 2: perlesque.exe (which it builds upon *every* invocation, including from p6eval), 3. the assembly created from p6eval input (emitted every time of course), and now 4. stage 3 can also emit assemblies.

[04:55] <diakopter> sidenote: the perlesquel p6eval target just invokes the last stage 3 emitted

[04:57] <snarkyboojum> sorear: dies after "ok 4 - man-or-boy test for start value 3" - so something else might well be wrong

[04:57] *** patspam joined
[04:59] <diakopter> phenny: tell pmurias please backlog; all kinds of neat stuff there

[04:59] <phenny> diakopter: I'll pass that on when pmurias is around.

[05:03] *** Targhan left
[05:07] *** patspam left
[05:27] <snarkyboojum> sorear: what did you mean by before or after 46422?

[05:30] *** JimmyZ left
[05:31] *** finanalyst joined
[05:40] <sorear> snarkyboojum: 46422, committed six hours ago and fixed a few minutes ago, contains a segfault bug, but it's only on a branch (I forgot this for a moment)

[05:44] <snarkyboojum> ah ok

[05:54] *** JimmyZ joined
[06:09] *** jonrafkind left
[06:11] *** jonrafkind joined
[06:11] *** \shade\ is now known as fn

[06:12] *** alester left
[06:13] *** fn is now known as \shade\

[06:19] *** kaare joined
[06:19] *** kaare is now known as Guest48518

[06:22] *** Guest48518 left
[06:28] *** jonrafkind left
[06:49] <pugssvn> r30595 | colomon++ | [t/spec] Fix test and unfudge. 

[06:51] <dalek> rakudo: 118f4aa | (Solomon Foster)++ | src/core/ (5 files):

[06:51] <dalek> rakudo: Overhaul sqrt for Numeric / Real.

[06:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/118f4aa4b6353b0ddeb43634764d117e202d9d68

[07:03] *** gfx joined
[07:12] *** dolmen joined
[07:12] *** bakedb__ joined
[07:35] *** swestres joined
[07:42] *** finanalyst left
[08:02] *** plobsing left
[08:39] *** levengli joined
[08:39] <levengli> anybody home now?

[08:40] *** dual_ joined
[08:41] <levengli> hi dual_

[08:41] *** dual left
[08:42] *** isBEKaml joined
[08:42] *** levengli left
[08:47] *** isBEKaml left
[08:48] *** dual joined
[08:49] *** dual_ left
[08:49] *** isBEKaml joined
[08:51] *** Su-Shee joined
[09:01] *** gfx left
[09:02] <isBEKaml> rakudo: sub subbydo { my $temp=23; return { say $_ + $temp }; }; my $tt = subbydo; my $test1=$tt(23); say $test1; say $tt.WHAT;

[09:02] <p6eval> rakudo ab2322: OUTPUTÂ«46â¤1â¤Block()â¤Â»

[09:04] <isBEKaml> uhhh, it executed alright. Why is a $test1 shown as 1? 

[09:04] <isBEKaml> I thought it only contained a ref (kinda) to subbydo? 

[09:05] <moritz_> guten Morgen

[09:05] <phenny> moritz_: 02:40Z <sorear> tell moritz_ that I've decided I don't like the plan I had earlier for splitting the setting, so I have nothing more for topic/lexical-persistence

[09:05] <isBEKaml> guten morgen, moritz_ !

[09:07] *** finanalyst joined
[09:18] <isBEKaml> rakudo: sub subbydo { my $temp=23; return { say $_ + $temp }; }; my $tt = subbydo; my $test1=$tt(23); say $test1.WHAT; say $tt.WHAT;

[09:18] <p6eval> rakudo ab2322: OUTPUTÂ«46â¤Bool()â¤Block()â¤Â»

[09:19] <isBEKaml> I don't understand why $test1 would type to a Bool()... :|

[09:19] *** masak joined
[09:19] <masak> oh hai, #perl6

[09:19] <isBEKaml> masak: hi

[09:21] <moritz_> \o/

[09:21] <moritz_> http://perlgeek.de/blog-en/perl-6/list-classify.writeback 7 comments - it seems that actually asking the reader a question does encourage people to comment

[09:21] <masak> there you go.

[09:25] <masak> [backlogging] diakopter has a screen-time limit? :)

[09:26] *** Heame joined
[09:27] <isBEKaml> that was the return statement in the subbydo doing this.. jeez.. :(

[09:27] <isBEKaml> rakudo: sub subbydo { my $temp=23;{ say $_ + $temp }; }; my $tt = subbydo; my $test1=$tt(23); say $test1.WHAT; say $tt.WHAT;

[09:27] <p6eval> rakudo ab2322: OUTPUTÂ«Use of uninitalized value in numeric contextâ¤23â¤invoke() not implemented in class 'Boolean'â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[09:28] <isBEKaml> rakudo: sub subbydo { my $temp=23;{ say $_ + $temp }; }; my $tt = subbydo; my $test1=$tt(23);

[09:28] <p6eval> rakudo ab2322: OUTPUTÂ«Use of uninitalized value in numeric contextâ¤23â¤invoke() not implemented in class 'Boolean'â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[09:29] *** Heame left
[09:32] <isBEKaml> odd, I thought the return statement in the earlier subbydo made it Bool(). This error message seems to be very misleading. Can someone over here clarify? 

[09:33] * moritz_ has no idea what's going on

[09:35] <isBEKaml> moritz_: there are two subs. The only difference is, one has a return statement, the other doesn't. With return, it works. Without, the error message is as above. 

[09:36] <moritz_> yes; and I have no idea what's going on

[09:37] <moritz_> opinion question: should ^@array actually re-dispatch to @array.keys instead of ^@array.elems ?

[09:37] <moritz_> I guess usually the former is meant

[09:37] <isBEKaml> if at all, I think the error msg should be "invoke() not implemented in class '<whatever type here>'" I think it can't be Boolean... 

[09:38] <moritz_> either way might be dangerous for custom array indexes

[09:42] *** M_o_C joined
[09:51] <masak> [backlog] yes, we perhaps should have a man_vs_bot test. :)

[09:53] <isBEKaml> moritz_: what would be the type of @array here? Any() ? If it contains only non-numeric elements, I think we shouldn't allow ^@array. ( I may be wrong here, though)

[09:55] * isBEKaml goes looking through backlogs for ^@ discussion

[10:02] <masak> isBEKaml: prefix:<^> should numify its argument.

[10:03] <masak> isBEKaml: more than a year ago, the spec was more complicated, and said that prefix:<^> on an array should give a list of 0..$n lists of indreasing $n.

[10:04] <masak> but that extra complexity was deemed unnecessary and a cause of bugs.

[10:04] <masak> so now it numifies instead, and there was much rejoicing.

[10:06] <isBEKaml> masak: yes, that was why I thought we shouldn't allow ^@ on non numeric arrays. 

[10:07] <masak> no, I think you misunderstand.

[10:07] <masak> the length is always numeric, that's all that matters.

[10:07] <masak> both for the old semantics and the present one.

[10:08] <masak> let's say @a = <a b c>; old semantics: ^@a would give ([0], [0, 1], [0, 1, 2])

[10:08] <masak> new semantics: ^@a gives (0, 1, 2)

[10:08] <masak> whether the array is 'non numeric' doesn't factor into it.

[10:10] <isBEKaml> oh, I see.. I was confused over 0..^ @a. Sorry for the line noise. 

[10:11] <masak> 0 ..^ @a works in the same way as given above. prefix:<^> is in every way sugar for 0..^

[10:12] <isBEKaml> array.length. we could simply have $#array?

[10:13] <masak> er.

[10:13] <masak> firstly, there's no @array.length. where did you get that?

[10:14] <isBEKaml> I was referring to a semantic. I know there's no array.length. So it's 0 .. $#array ? 

[10:14] <masak> secondly, the $#array syntax was ugly even for Perl 5. somewhere inside that twisted parser, there must be a rule saying that '#' doesn't indicate a comment if it comes directly after a '$'.

[10:14] <masak> oh, ok.

[10:14] <masak> for a while I thought you were suggesting we reintroduce $#array :)

[10:15] <isBEKaml> I won't reintroduce. Unlearn and relearn's fine with me. :)

[10:15] <masak> yes, ^@a means 0..^@a means 0..(@a.elems-1)

[10:15] <masak> rakudo: my @a = <a b c d e>; say @a.elems; say @a.end

[10:15] <p6eval> rakudo ab2322: OUTPUTÂ«5â¤4â¤Â»

[10:16] <masak> I'd say $#a has been replaced by the slightly longer @a.end

[10:17] <isBEKaml> $# was easy to remember. # for count. :)

[10:17] <isBEKaml> now we have a mnemonic for last element. @a.end! :)

[10:18] *** iblechbot joined
[10:19] <masak> if '#' really meant count there, how come the number is one less than the count of the elements? :P

[10:19] <isBEKaml> array indexing! :D

[10:21] <masak> yes, but set cardinalities aren't usually "zero-based" in the sense that they're off by one from the actual size.

[10:21] <isBEKaml> I was referring to the number and ids that we keep for items in day to day life. "Go over, meet the man in #5."

[10:21] <masak> all I'm saying is I like @a.end much better. :)

[10:21] <moritz_> isBEKaml: @array would be positional

[10:22] <isBEKaml> all I said it's a good mnemonic. :)

[10:23] <masak> the mnemonic being '# denotes count, so this is the *count* of the elements... minus one'. er.

[10:26] <isBEKaml> er, ppl remember stuff in different ways. room #5, counter #5 and so on. # is simply the last position in an array. remember how we had to grapple with list and scalar contexts in p5 ? assign a list to a scalar, you only get the last element. er, I just said @a.end is a much better mnemonic than $#a. 

[10:26] <masak> good, good. :)

[10:26] <masak> we'll leave it at that.

[10:29] <masak> lunch &

[10:29] *** masak left
[10:33] <isBEKaml> moritz_: we could just use @array.keys. opA(T) redispatch to opB(T.something), not opA(T.something). IOW, redispatch to do some other (possibly less costly) operation, never the same one. 

[10:33] <isBEKaml> in this case, both look similar. 

[10:33] <moritz_> it's not about looks :-)

[10:33] <isBEKaml> :)

[10:34] <moritz_> I just meant that ^@array could be made to mean @array.keys, not 0..^@array.elems

[10:34] *** JimmyZ left
[10:34] <moritz_> but it's probably ETOOMUCHMAGIC

[10:34] <isBEKaml> good, good. you got my point. :)

[10:34] <moritz_> and we should educate people to use @array.keys in the first place, even if it's 4 strokes more

[10:35] *** EXCHIM joined
[10:37] <isBEKaml> we probably should. it would also probbly mean saying, "there's one true way" when it's TMTOWDI

[10:37] <isBEKaml> :)

[10:38] * isBEKaml was thinking about a good practices doc as a spill over from java world. 

[10:38] <isBEKaml> we could do the same, only in a slightly less intimidating way. :)

[10:43] <isBEKaml> rakudo: my @a=<1 2 3 4>; say 0..^ @a;

[10:43] <p6eval> rakudo ab2322: OUTPUTÂ«01â¤Â»

[10:44] <isBEKaml> rakudo: my @a=<1 2 3 4>; say 0..^@a;

[10:44] <p6eval> rakudo ab2322: OUTPUTÂ«01â¤Â»

[10:44] <isBEKaml> alpha: my @a=<1 2 3 4>; say 0..^@a;

[10:44] <p6eval> alpha 30e0ed: OUTPUTÂ«0123â¤Â»

[10:49] <colomon> rakodu: my @a= 1 ... 4; 

[10:49] <colomon> rakodu: my @a= 1 ... 4; say (^@a).perl

[10:50] <colomon> rakudo: my @a= 1 ... 4; say (^@a).perl

[10:50] <p6eval> rakudo ab2322: OUTPUTÂ«0..^[1, 2, 3, 4]â¤Â»

[10:50] <colomon> too early

[10:50] <colomon> alpha: my @a= 1 ... 4; say (^@a).perl

[10:50] <p6eval> alpha 30e0ed: OUTPUTÂ«0..^4â¤Â»

[10:54] *** JimmyZ joined
[10:55] <isBEKaml> alpha: sub subbydo { my $temp=23;{ say $_ + $temp }; }; my $tt = subbydo; my $test1=$tt(23);

[10:55] <p6eval> alpha 30e0ed: OUTPUTÂ«Use of uninitialized valueâ¤23â¤invoke() not implemented in class 'Boolean'â¤in Main (file <unknown>, line <unknown>)â¤Â»

[10:56] <JimmyZ> rakudo: my @array = 1, 3, 5; say +@array;

[10:56] <p6eval> rakudo ab2322: OUTPUTÂ«3â¤Â»

[10:56] <JimmyZ> rakudo: my @array = 1, 3, 5; say @array.keys;

[10:56] <p6eval> rakudo ab2322: OUTPUTÂ«012â¤Â»

[10:57] *** finanalyst left
[10:57] <JimmyZ> rakudo: my @array; say ?@array; say +@array;

[10:57] <p6eval> rakudo ab2322: OUTPUTÂ«0â¤0â¤Â»

[10:58] <JimmyZ> rakudo: my @array = 1; say ?@array; say +@array;

[10:58] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤1â¤Â»

[10:58] <JimmyZ> rakudo: my @array = 1,2 ; say ?@array; say +@array;

[10:58] <p6eval> rakudo ab2322: OUTPUTÂ«1â¤2â¤Â»

[11:06] *** pmurias joined
[11:07] *** JimmyZ left
[11:18] *** JimmyZ joined
[11:22] <colomon> > my @a= 1 ... 4; say (^@a).perl

[11:22] <colomon> 0..^4

[11:26] <isBEKaml> colomon: \o/

[11:26] <isBEKaml> colomon++

[11:27] *** wknight8111 joined
[11:29] <isBEKaml> alpha: my @a= 1 ... 4; my @bb= (^@a); say @bb.perl;

[11:29] <p6eval> alpha 30e0ed: OUTPUTÂ«[0, 1, 2, 3]â¤Â»

[11:32] <colomon> very easy fix

[11:33] <colomon> :)

[11:33] <colomon> spectesting it right now.

[11:45] <cognominal> when I read something like @opstack, I have a itch to add twigils for stack and queue roles as opposed to full aray roles...  That would give   @>stack and @<queue. But,  chaplet of twigils in names will be a sure way to scare more people

[11:45] *** JimmyZ left
[11:45] <cognominal> On the other hand, I find   @>op nicer than @opstack

[11:47] <cognominal> anyway, anyone will be free to transmogrify Perl 6 if he has the proper skills.

[12:00] <dalek> rakudo: c18ef37 | (Solomon Foster)++ | src/core/Range.pm:

[12:00] <dalek> rakudo: Switch prefix:<^> to use +$max internally.

[12:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c18ef3793aea1aa37bceee617002b35b5cab7221

[12:01] *** sundar joined
[12:02] <sundar> what's the way to get the latest version of Synopses?

[12:03] <sundar> I remember someone saying the web version is usually outdated and it's better to pull it from some repository. 

[12:03] <colomon> Web version updates automatically.

[12:03] <colomon> I see the page I have open was updated this morning.

[12:04] <colomon> but it's worth checking that, because the automatic update was broken for a while earlier this year.

[12:05] <sundar> colomon: oh ok, I now see that the page I'm looking at was updated yesterday evening. thanks. 

[12:05] <colomon> the other way to get the latest is to pull them down from the subversion repo

[12:06] <colomon> http://svn.pugscode.org/pugs

[12:07] <lisppaste3> sundar pasted "Why does the second \s take a + and not a * like the others?  (from S05)" at http://paste.lisp.org/display/98993

[12:08] <colomon> just guessing: because it's between two alphabetic characters.

[12:08] <sundar> colomon: Ok, I'll pull that now for offline reading pleasure. :) 

[12:09] <colomon> http://svn.pugscode.org/pugs/docs/Perl6/Spec is more specific; there is a lot of stuff in the old pugs repo.

[12:11] *** JimmyZ joined
[12:15] <sundar> colomon: thanks, that makes sense... TIL ws is another dwimmery in perl6. 

[12:15] <pugssvn> r30596 | colomon++ | [t/spec] Refudge a tad, add a couple of tests to make sure prefix:<^> numifies its argument. 

[12:16] <colomon> mind you, I've never messed around with the :s modifier at all, so I might be completely wrong.  :)

[12:21] <sundar> colomon: you were not. I found another part of the Syn where it says <.ws> is "\s+ if it's between two \w characters,", and "\s* otherwise". :)

[12:26] *** fridim left
[12:33] <JimmyZ> rakudo: my @a = 1, 2, 4; say (1...^@a).perl.say;

[12:33] <p6eval> rakudo ab2322: OUTPUTÂ«(1)â¤1â¤Â»

[12:33] <JimmyZ> rakudo: my @a = 1, 2, 4; (1..^@a).perl.say;

[12:33] <p6eval> rakudo ab2322: OUTPUTÂ«1..^[1, 2, 4]â¤Â»

[12:36] *** rv2733 left
[12:37] *** rv2733 joined
[12:37] <colomon> JimmyZ: p6eval doesn't have the latest changes yet.

[12:38] <colomon> actually, it's two days behind at the moment.  that's a sign of trouble.  :(

[12:38] *** maspalio joined
[12:39] <JimmyZ> Yeah

[12:40] <JimmyZ> I am compiling by myself now.

[12:40] *** maspalio left
[12:43] *** masak joined
[12:45] <JimmyZ> alpha: my @a = 1, 2, 4; (1..^@a).perl.say

[12:45] <p6eval> alpha 30e0ed: OUTPUTÂ«1..^[1, 2, 4]â¤Â»

[12:46] <JimmyZ> pugs: my @a = 1, 2, 4; (1..^@a).perl.say

[12:46] <p6eval> pugs: OUTPUTÂ«(1, 2)â¤Â»

[12:47] <JimmyZ> alpha: my @a = 1, 2, 4; (^@a).perl.say

[12:47] <p6eval> alpha 30e0ed: OUTPUTÂ«0..^3â¤Â»

[12:47] <JimmyZ> rakudo: my @a = 1, 2, 4; (^@a).perl.say

[12:47] <p6eval> rakudo ab2322: OUTPUTÂ«0..^[1, 2, 4]â¤Â»

[12:48] <JimmyZ> ./perl6 -e 'my @a = 1, 2, 4; (1..^@a).perl.say'

[12:48] <masak> cognominal: [backlog] adding twigils for stack and queue sounds like a good idea for a module.

[12:48] <JimmyZ> 1..^[1, 2, 4]

[12:49] <colomon> masak: o/

[12:49] <masak> \o

[12:51] <colomon> I'm hanging with my parents and hunting LHF.

[12:51] <colomon> 32,000 passing tests is dangerously close.

[12:51] *** rgrau_ left
[12:51] * masak cheers colomon on

[12:51] <JimmyZ> colomon: Is the result right?

[12:52] <masak> I'm drafting up the presentation I'll be giving in a week and some.

[12:52] <masak> JimmyZ: no, but that bug was reported the other day.

[12:52] <colomon> JimmyZ: (^@a).perl.say is for sure wrong, and I've already fixed it.

[12:53] <colomon> (1..^@a).perl.say is a much trickier question

[12:53] <JimmyZ> jimmy@ubuntu:~/rakudo$ ./perl6 -e 'my @a = 1, 2, 4; (1..^@a).perl.say'

[12:53] <JimmyZ> 1..^[1, 2, 4]

[12:53] <JimmyZ> jimmy@ubuntu:~/rakudo$ ./perl6 -e 'my @a = 1, 2, 4; (^@a).perl.say'

[12:53] <JimmyZ> 0..^3

[12:53] <colomon> right, that's the correct (fixed) behavior for  (^@a).perl.say

[12:53] <masak> why is it tricky? I guess it has to do with not being able to numify because of strings.

[12:53] <colomon> masak: exactly.

[12:54] <moritz_> it probably deserves a special case

[12:54] <moritz_> if $arg ~~ Positional { numifiy }

[12:54] <masak> well, I don't think arrays should be whitelisted.

[12:54] <colomon> with prefix:<^>, we know we want to numify

[12:54] <masak> I think everything but scalar values should be blacklisted.

[12:54] <moritz_> rakudo: say (^'d').perl

[12:54] <p6eval> rakudo ab2322: OUTPUTÂ«0..^"d"â¤Â»

[12:55] <moritz_> well

[12:55] <colomon> that's the old behavior, it's 0..0 now.

[12:55] <moritz_> one can always say that if one of the endpoints is ~~ Numeric, the other should be numified too

[12:55] <masak> colomon: right, but the *reason* we know we want to numify has to be the same as the reason we know we want to numify 0..^@a

[12:55] <moritz_> rakudo: say (^'d').perl

[12:55] <p6eval> rakudo c18ef3: OUTPUTÂ«0..^0â¤Â»

[12:55] <moritz_> colomon++

[12:56] * moritz_ will hold his Perl 6 talk tomorrow

[12:56] <JimmyZ> rakudo:  (^'d4').perl.say

[12:56] <p6eval> rakudo c18ef3: OUTPUTÂ«0..^0â¤Â»

[12:56] <JimmyZ> rakudo:  (^'4d').perl.say

[12:56] <p6eval> rakudo c18ef3: OUTPUTÂ«0..^4â¤Â»

[12:57] <JimmyZ> rakudo:  say 'd4' + 4

[12:57] <p6eval> rakudo c18ef3: OUTPUTÂ«4â¤Â»

[12:57] <colomon> moritz_: did you just rebuild p6eval, or did it do it on its own?

[12:58] <colomon> afk

[12:59] <moritz_> colomon: I did

[13:00] <moritz_> I guess the rebuild is now sufficiently sane that I can enable the cron job again

[13:00] <moritz_> I've now enabled it every other hour

[13:02] <moritz_> 15 */2 * * *              perl /home/p6eval/rebuild-rakudo.pl  >> /home/p6eval/rakudo-buildlog 2>&1

[13:08] *** sundar left
[13:09] *** TiMBuS left
[13:20] <colomon> cron++

[13:20] <colomon> moritz_++

[13:20] <masak> p6eval++

[13:21] <dalek> rakudo: ee6ec74 | (Solomon Foster)++ | src/core/Pair.pm:

[13:21] <dalek> rakudo: Add infix:<cmp> for pairs.

[13:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ee6ec74defd21833de588a8814740ec578442c49

[13:22] <pugssvn> r30597 | colomon++ | [t/spec] Unfudge infix:<cmp> tests on pairs, also rewrite two of the tests so they parse correctly. 

[13:23] <colomon> with that, I'm showing 31974 passing tests.

[13:24] *** EXCHIM left
[13:25] *** EXCHIM joined
[13:29] *** M_o_C left
[13:33] <JimmyZ> wow, will reach alpha 

[13:34] *** alester joined
[13:35] <masak> ...but with different passing tests.

[13:35] <masak> anyway, only 6 tests left to 32k !

[13:37] <moritz_> 26

[13:37] <moritz_> if my subtraction cells haven't left me

[13:38] <JimmyZ> rakudo: say 32731 - 31974

[13:38] <p6eval> rakudo c18ef3: OUTPUTÂ«757â¤Â»

[13:38] <moritz_> rakudo: postfix:<k>($x) { 1000 * $k }; say 32\k - 31974

[13:38] <p6eval> rakudo c18ef3: OUTPUTÂ«Confused at line 11, near "postfix:<k"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[13:38] <masak> er. that's a seven. right, 26.

[13:39] <colomon> rakudo: postfix:<k>($x) { 1000 * $k }; say 32k - 31974

[13:39] <p6eval> rakudo c18ef3: OUTPUTÂ«Confused at line 11, near "postfix:<k"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[13:39] <moritz_> rakudo: use MONKEY_TYPING; augment class Int { method k ($x) { 1000 * $k }}; say 32.k - 31974

[13:39] <p6eval> rakudo c18ef3: OUTPUTÂ«Symbol '$k' not predeclared in kâ¤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)â¤Â»

[13:39] <moritz_> rakudo: use MONKEY_TYPING; augment class Int { method k ($x) { 1000 * $x }}; say 32.k - 31974

[13:39] <p6eval> rakudo c18ef3: OUTPUTÂ«Method 'k' not found for invocant of class 'Integer'â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[13:39] * moritz_ weeps

[13:39] <masak> \k

[13:40] <masak> rakudo: postfix:<k>($x) { 1000 * $x }; say 32\k - 31974

[13:40] <p6eval> rakudo c18ef3: OUTPUTÂ«Confused at line 11, near "postfix:<k"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[13:40] <masak> rakudo: sub postfix:<k>($x) { 1000 * $x }; say 32\k - 31974

[13:40] <p6eval> rakudo c18ef3: OUTPUTÂ«26â¤Â»

[13:40] <colomon> masak++

[13:41] <JimmyZ> rakudo: sub postfix:<k>($x) { 1000 * $x }; say 32k - 31974

[13:41] <p6eval> rakudo c18ef3: OUTPUTÂ«26â¤Â»

[13:41] <masak> oh, even that.

[13:42] <JimmyZ> alpha: sub postfix:<k>($x) { 1000 * $x }; say 32k - 31974

[13:42] *** rurban joined
[13:42] <p6eval> alpha 30e0ed: OUTPUTÂ«26â¤Â»

[13:43] <JimmyZ> alpha: sub postfix:<k>($x) { 1000 * $x }; say 32\k - 31974

[13:43] <p6eval> alpha 30e0ed: OUTPUTÂ«Confused at line 10, near "\\k - 31974"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[13:48] *** Su-Shee left
[13:50] <moritz_> std: sub postfix:<k>($x) { }; 32k

[13:50] <p6eval> std 30597: OUTPUTÂ«ok 00:01 116mâ¤Â»

[13:50] <moritz_> std: sub postfix:<k>($x) { }; 32\k

[13:50] <p6eval> std 30597: OUTPUTÂ«ok 00:01 114mâ¤Â»

[13:50] <masak> std: sub postfix:<k>($x) { }; 32kk

[13:50] <p6eval> std 30597: OUTPUTÂ«ok 00:01 114mâ¤Â»

[13:51] <JimmyZ> rakudo: sub postfix:<k>($x) { 1000 * $x }; say 32kk - 31974

[13:51] <p6eval> rakudo c18ef3: OUTPUTÂ«31968026â¤Â»

[13:51] <JimmyZ> rakudo: sub postfix:<k>($x) { 1000 * $x }; say 32\k\k - 31974

[13:51] <p6eval> rakudo c18ef3: OUTPUTÂ«31968026â¤Â»

[13:51] <JimmyZ> rakudo: sub postfix:<k>($x) { 1000 * $x }; say 32\kk - 31974

[13:51] <p6eval> rakudo c18ef3: OUTPUTÂ«31968026â¤Â»

[13:55] *** slavik1 left
[13:59] *** hercynium left
[13:59] *** slavik joined
[14:00] *** ReiniUrban joined
[14:01] <moritz_> http://www.perlmonks.org/?node_id=839112 couldn't resist :-)

[14:01] *** rurban left
[14:01] *** ReiniUrban is now known as rurban

[14:01] *** rurban left
[14:02] <slavik> moritz_: NICE!!!!

[14:02] <slavik> moritz_: that should be in the book :)

[14:02] <slavik> also, what does the 1_000 exactly mean? why not 1000 instead?

[14:02] <moritz_> it's the same

[14:02] <slavik> oh

[14:03] <moritz_> rakudo: say 1_000_000

[14:03] <p6eval> rakudo c18ef3: OUTPUTÂ«1000000â¤Â»

[14:03] <moritz_> works the same way in perl 5 too

[14:03] <moritz_> buubot: eval: 1_024

[14:03] <buubot> moritz_: 1024     

[14:03] <slavik> _ is like a comma? (period in europe)

[14:03] <masak> moritz_++

[14:03] <moritz_> yes

[14:03] <slavik> good point

[14:03] <slavik> moritz_++

[14:03] <moritz_> slavik: but you can use it at any position in a number

[14:04] <moritz_> rakudo: say 10_24

[14:04] <p6eval> rakudo c18ef3: OUTPUTÂ«1024â¤Â»

[14:04] <slavik> I see, so it's only visual?

[14:04] <moritz_> some cultures like to group their numbers in pairs

[14:04] <moritz_> right

[14:04] <slavik> ok, cool

[14:05] <slavik> so technically, Perl6 has some features that Java7 was supposed to have ...

[14:05] <masak> the Chinese tend -- at some level anyway -- to group in fours.

[14:05] <masak> JimmyZ: am I right?

[14:05] <moritz_> anyway, I'm fine with allowing _ at arbitrary positions

[14:05] <moritz_> rakudo: say 1__3

[14:05] <p6eval> rakudo c18ef3: OUTPUTÂ«Confused at line 11, near "say 1__3"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[14:06] <moritz_> std: 1__3

[14:06] <p6eval> std 30597: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Whitespace is required between alphanumeric tokens at /tmp/zrIsnxD0WC line 1:â¤------> [32m1[33mâ[31m__3[0mâ¤Two terms in a row at /tmp/zrIsnxD0WC line 1:â¤------> [32m1[33mâ[31m__3[0mâ¤    expecting any of:â¤  POSTâ¤   bracketed infixâ¤   infix or

[14:06] <p6eval> ..meta-iâ€¦

[14:06] <slavik> rakudo say 1_3

[14:06] <JimmyZ> masak: I can't follow you

[14:06] <slavik> rakudo: say 1_3

[14:06] <p6eval> rakudo c18ef3: OUTPUTÂ«13â¤Â»

[14:06] <moritz_> rakudo: say 12_

[14:06] <p6eval> rakudo c18ef3: OUTPUTÂ«Confused at line 11, near "say 12_"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[14:06] <slavik> I guess with two _, it thinks there is meaning to it

[14:06] <slavik> rakudo: say _12

[14:06] <p6eval> rakudo c18ef3: OUTPUTÂ«Could not find sub &_12â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[14:07] <slavik> right, because it's not a number ...

[14:07] <slavik> is it possible with Perl6 to have your own context definitions?

[14:08] <moritz_> yes

[14:08] <slavik> something like: my $feet = context<feet>(convert(30.48cm)) or something ...

[14:08] <moritz_> for example striing context consists only of a method call

[14:08] <moritz_> to .Str or .Stringy

[14:09] <masak> JimmyZ: I mean that ä¸‡ is a 'unit', sort of one level above 10.

[14:09] <slavik> 100?

[14:09] <moritz_> so you can define a prefix:<imperial> that calls the .Imperial method

[14:09] <moritz_> and define that method in all number types that present a value + unit

[14:09] <masak> slavik: no, I don't mean like that. we tend to organize things in 10^3 units.

[14:10] <masak> slavik: the Chinese (and the Koreans, and perhaps the Japanese too) tend to go with 10^4.

[14:10] <slavik> moritz_: or have all objects inherit an interface of measurement?

[14:10] <slavik> masak: ahh, I see

[14:10] <moritz_> slavik: likely s/inherit an interface/"do" a role/

[14:10] <moritz_> but of course inheritance would work too

[14:10] <masak> so the Chinese don't think of the population of China as being 1.4 * 10^9, but instead 14 * 10^8.

[14:11] <TimToady> yes, the Japanese also

[14:11] <moritz_> which is just as correct :-)

[14:11] <masak> aye, but a funny shift of perspective.

[14:12] <masak> I like the pause that both westerners and easterners have to take when converting :)

[14:12] <JimmyZ> masak: yes, but it's old, now most I saw is three , not four.

[14:12] <masak> JimmyZ: how would you think about the population of China?

[14:12] <moritz_> "big" *SCNR*

[14:12] <masak> JimmyZ: 1.4 * 10^9 or 14 * 10^8?

[14:13] <JimmyZ> well, we say 14äº¿

[14:13] <masak> I rest my case.

[14:14] <slavik> moritz_: right ...

[14:16] <pugssvn> r30598 | colomon++ | [t/spec] Unfudge tests. 

[14:16] <colomon> 31980 passing tests

[14:17] <JimmyZ>  masak: actually, we use three or four, depends on the fields.

[14:17] <masak> oh, ok. science does 3 more?

[14:17] <JimmyZ> yeah

[14:18] <JimmyZ> usually advanced field

[14:18] <masak> makes cultural sense, methinks.

[14:18] <TimToady> interestingly, ancient Greek had the concept of "myriad", which was 10,000

[14:19] <TimToady> and "myriads of myriads"

[14:19] <dalek> rakudo: e113d85 | (Solomon Foster)++ | src/core/Array.pm:

[14:19] <dalek> rakudo: Add proto for unshift so we can use named args.

[14:19] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e113d8591263fb1243b4bc2956505cc13370b98b

[14:19] * moritz_ wonders what kind of numbers the greeks measured in "myriads of myriads"

[14:19] <JimmyZ> masak: you're right.

[14:20] <moritz_> in great britain the scientists mostly use the SI system too

[14:20] <TimToady> moritz_: in general, they preferred geometry :)

[14:20] <masak> moritz_: probably most often "I've told you myriads of myriads of times not to exaggerate!" :P

[14:20] <moritz_> :-)

[14:21] *** alester left
[14:22] *** am0c joined
[14:22] <masak> this list might be of interest to someone: http://gist.github.com/395182

[14:22] <masak> it's of the 185 t/spec files that Rakudo's t/spectest.data doesn't mention.

[14:23] <moritz_> which tools/update_passing_test_data.pl processes

[14:23] <masak> o rly? I figured some tool would do that :)

[14:25] <moritz_> masak++ #made me look at a particular test file

[14:26] <pugssvn> r30599 | moritz++ | [t/spec] delete a test file that consistet of four tests; two of them bogus, two already present elsewhere 

[14:26] <moritz_> ... which I now deleted :-)

[14:26] <masak> \o/

[14:27] <moritz_> does EnumMap preserve key ordering?

[14:27] <masak> don't think so.

[14:27] <masak> if a file comes out as 'some tests passed' by this tool, can there still be reasons not to add it to t/spectest.data?

[14:28] <moritz_> sure

[14:28] <moritz_> for example rakudo passes some tests in temp.t

[14:28] <moritz_> but it doesn't implement 'temp' at all

[14:28] <moritz_> => no point in adding it

[14:28] <masak> ah.

[14:29] <masak> let.t is the same, but it also runs all tests! o.O

[14:29] <masak> time to write more tests. :)

[14:33] <pugssvn> r30600 | moritz++ | [t/spec] correct some enum tests that relied on hash key order 

[14:34] <pugssvn> r30601 | moritz++ | [t/spec] fix a syntax error 

[14:36] <pugssvn> r30602 | moritz++ | [t/spec] fudge undefined-types.t for Rakudo 

[14:38] <pugssvn> r30603 | moritz++ | [t/spec] unfudges for rakudo, found by autounfudge 

[14:38] *** alester joined
[14:40] <moritz_> uhm

[14:40] <moritz_> t/spec/S05-match/make.t 

[14:40] <isBEKaml> perlmonks.org is down? 

[14:40] <moritz_> that looks bogus

[14:40] <isBEKaml> I can't connect to it.. :(

[14:40] <moritz_> "4" ~~ / (\d) { make $0.sqrt } Remainder /;

[14:40] <moritz_> ok($/);

[14:41] <moritz_> I'd say that the regex doesn't match

[14:41] <moritz_> and that $/ is false even though make() was called

[14:41] <moritz_> correct?

[14:41] <moritz_> isBEKaml: wouldn't be the first time

[14:41] <moritz_> ... but works for me

[14:42] <isBEKaml> hmm, I just wanted to view the page you linked to... 

[14:42] <dalek> rakudo: 73a3d3e | moritz++ | t/spectest.data:

[14:42] <dalek> rakudo: [t/spec] run another test file

[14:42] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/73a3d3e9d4d0a025b5b60b2d4036d87ed585ef4c

[14:42] <isBEKaml> now I can see it.. repeated attempts. :(

[14:43] <pugssvn> r30604 | moritz++ | [t/spec] correct make.t - a $/ of a failed match is False, even if make() was called 

[14:45] <isBEKaml> rakudo: say 1_00_000;

[14:45] <p6eval> rakudo e113d8: OUTPUTÂ«100000â¤Â»

[14:45] <isBEKaml> rakudo: say 1_00_000 + 20_00_000;

[14:45] <p6eval> rakudo e113d8: OUTPUTÂ«2100000â¤Â»

[14:45] <isBEKaml> exactly like p5 ;)

[14:45] <moritz_> std: my @a; / ||@a /

[14:46] <p6eval> std 30599: OUTPUTÂ«ok 00:01 113mâ¤Â»

[14:47] <pugssvn> r30605 | moritz++ | [t/spec] fudge sequential-alternation.t for rakudo 

[14:49] <moritz_> rakudo: multi a($a) { 1 }; multi a(:$a) { 2 }; say a(:a)

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«2â¤Â»

[14:49] <JimmyZ> rakudo: say 1_0000

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«10000â¤Â»

[14:49] <moritz_> rakudo: multi a($a) { 1 }; multi a(:$a) { 2 }; multi a(:$a, :$b);  say a(:a)

[14:49] <JimmyZ> rakudo: say 1,0000

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«Malformed multi at line 11, near "a(:$a, :$b"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«10â¤Â»

[14:49] <JimmyZ> rakudo: say 10,000

[14:49] <moritz_> rakudo: multi a($a) { 1 }; multi a(:$a) { 2 }; multi a(:$a, :$b) { 3 }  say a(:a)

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«100â¤Â»

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«Confused at line 11, near "multi a(:$"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[14:49] <moritz_> rakudo: multi a($a) { 1 }; multi a(:$a) { 2 }; multi a(:$a, :$b) { 3 };  say a(:a)

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«Ambiguous dispatch to multi 'a'. Ambiguous candidates had signatures:â¤:(Any :a($a))â¤:(Any :a($a), Any :b($b))â¤â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[14:49] <JimmyZ> rakudo: say 10,000

[14:49] <p6eval> rakudo e113d8: OUTPUTÂ«100â¤Â»

[14:50] <JimmyZ> pugs: say 10,000

[14:50] <p6eval> pugs: OUTPUTÂ«100â¤Â»

[14:50] *** alester left
[14:50] <moritz_> I guess this should not be ambigious, right?

[14:50] <moritz_> t/spec/S06-multi/positional-vs-named.t

[14:51] <JimmyZ> pugs: print 1,2

[14:51] <p6eval> pugs: OUTPUTÂ«12Â»

[14:51] <JimmyZ> pugs: say 1,2

[14:51] <p6eval> pugs: OUTPUTÂ«12â¤Â»

[14:51] <JimmyZ> rakudo: say '000'

[14:51] <p6eval> rakudo e113d8: OUTPUTÂ«000â¤Â»

[14:51] <JimmyZ> rakudo: say 10,'000'

[14:51] <p6eval> rakudo e113d8: OUTPUTÂ«10000â¤Â»

[14:52] <JimmyZ> rakudo: say 10,+'000'

[14:52] <p6eval> rakudo e113d8: OUTPUTÂ«100â¤Â»

[14:52] <ash___> rakudo: say 10_000

[14:52] <moritz_> rakudo: eval 'augment class Int { }'

[14:53] <p6eval> rakudo e113d8: OUTPUTÂ«10000â¤Â»

[14:53] <p6eval> rakudo e113d8:  ( no output )

[14:53] <ash___> moritz_: shouldn't that complain about use MONKEY_TYPING? 

[14:53] <moritz_> ash___: yes, but the eval() is silent :-)

[14:53] <ash___> ah

[14:54] <moritz_> rakudo: use MONKEY_TYPING; { class Foo { }; augment class Foo { } }

[14:54] <p6eval> rakudo e113d8:  ( no output )

[14:54] * moritz_ incredibly stupid

[14:55] <pugssvn> r30606 | moritz++ | [t/spec] fudge augment-supersede.t 

[14:55] <moritz_> I was wondering why stuff didn't work in a test file, but worked here on evalbot

[14:55] <moritz_> I forgot to save the file.

[14:55] <JimmyZ> rakudo: eval ' class Foo{ }; augment class Foo { method Str() { 'hi'; }; say ~Foo'

[14:55] <p6eval> rakudo e113d8: OUTPUTÂ«Confused at line 11, near "eval ' cla"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[14:55] <JimmyZ> rakudo: eval 'class Foo{ }; augment class Foo { method Str() { 'hi'; }; say ~Foo'

[14:55] <p6eval> rakudo e113d8: OUTPUTÂ«Confused at line 11, near "eval 'clas"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[14:55] <ash___> I love when I do that, I switch to my terminal, hit make, run my program and the new change isn't working for some reason.... 

[14:55] <ash___> silly save button 

[14:56] *** Coleoid joined
[14:56] <moritz_> JimmyZ: can't use 'hi' inside a single-quoted string

[14:57] <ash___> rakudo: eval ' class Foo{ }; augment class Foo { method Str() { \'hi\'; }; say ~Foo'

[14:57] <p6eval> rakudo e113d8:  ( no output )

[14:58] <JimmyZ> rakudo: eval "use MONKEY_TYPING; class Foo{ }; augment class Foo { method Str() { 'hi'; } } ; say ~Foo"

[14:58] <p6eval> rakudo e113d8: OUTPUTÂ«Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespaceâ¤Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespaceâ¤Null PMC access in get_string()â¤current instr.: '_block14'

[14:58] <p6eval> ..pc 29â€¦

[14:58] <JimmyZ> rakudo: use MONKEY_TYPING; class Foo{ }; augment class Foo { method Str() { 'hi'; } } ; say ~Foo

[14:58] <p6eval> rakudo e113d8: OUTPUTÂ«Foo()â¤Â»

[14:58] <JimmyZ> rakudo: use MONKEY_TYPING; class Foo{ }; augment class Foo { method Str() { 'hi'; } } ; say ~Foo.new

[14:59] <p6eval> rakudo e113d8: OUTPUTÂ«hiâ¤Â»

[14:59] <JimmyZ> rakudo: class Foo { method Str() { 'hi'; } } ; say ~Foo

[14:59] <p6eval> rakudo e113d8: OUTPUTÂ«Foo()â¤Â»

[15:00] <JimmyZ> rakudo: eval "use MONKEY_TYPING; class Foo{ }; augment class Foo { our method Str() { 'hi'; } } ; say ~Foo.new"

[15:00] <p6eval> rakudo e113d8: OUTPUTÂ«Could not find sub 20_1273416224.9741â¤current instr.: '' pc -1 ((unknown file):-1)â¤Â»

[15:00] <colomon> what does S& mean?

[15:00] <colomon> like an all junction, but not threaded?

[15:01] <moritz_> yes

[15:01] <JimmyZ> rakudo: eval "use MONKEY_TYPING; class Foo{ }; augment class Foo { method Str() { 'hi'; } } ; say ~Foo.new"

[15:01] <colomon> junctions don't thread now, do they?

[15:01] <p6eval> rakudo e113d8: OUTPUTÂ«Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespaceâ¤Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespaceâ¤Null PMC access in get_string()â¤current instr.: '_block14'

[15:01] <p6eval> ..pc 29â€¦

[15:01] <moritz_> colomon: nope, they don't

[15:01] <pugssvn> r30607 | moritz++ | [t/spec] correct S12-class/literal.t 

[15:02] <colomon> we're skipping 55 tests in rx.t because we don't implement S&.

[15:02] <JimmyZ> rakudo: eval "class Foo { our method Str() { 'hi'; } } ; say ~Foo.new"

[15:02] <p6eval> rakudo e113d8: OUTPUTÂ«Could not find sub 19_1273416350.42779â¤current instr.: '' pc -1 ((unknown file):-1)â¤Â»

[15:02] <moritz_> colomon: I'm fine with replacing that by a simpler construct

[15:02] <colomon> oh?

[15:02] <moritz_> colomon: like 'and' or '&&' if applicable

[15:02] <moritz_> (watch the precedence)

[15:03] <colomon> the tests are like this:

[15:03] <moritz_> S05-* is not about testing S&. It's about testing regexes

[15:03] <colomon> ok eval(q{{ 'abcZ' ~~ /abc\Z/ }}) ~~ Failure S& /reserved/, 'retired metachars (\Z)';

[15:03] <colomon> I admit I don't really understand the logic.

[15:03] <moritz_> the return value of the eval should be a failure, and match /reserved/

[15:03] <colomon> (I was just thinking of implementing Sop which just does op....)

[15:03] <JimmyZ> Could not find sub 19_1273416350.42779? what's that?

[15:04] <moritz_> a LTA error message

[15:04] <moritz_> std: print $*OUT: "foo"

[15:04] <p6eval> std 30606: OUTPUTÂ«ok 00:01 113mâ¤Â»

[15:05] <masak> rakudo: {nextsame}()

[15:05] * moritz_ would gladly throw that syntactic form over board

[15:05] <p6eval> rakudo e113d8: OUTPUTÂ«Null PMC access in clone()â¤current instr.: '&nextsame' pc 18507 (src/builtins/assign.pir:78)â¤Â»

[15:05] <JimmyZ> seems that augment can't in eval

[15:05] <masak> moritz_: that use case for that syntactic form is basically the only argument I see for defending it ;P

[15:06] <moritz_> masak: it's only worth defending for Perl 5 convenience, IMHO

[15:07] <masak> perhaps, but even that is not something to be thrown overboard lightly.

[15:07] <moritz_> not? :-)

[15:08] <pugssvn> r30608 | moritz++ | [t/spec] more Rakudo unfudges found by autounfudge 

[15:10] <colomon> moritz_++

[15:10] <masak> no. all other things being equal, I see it as a strength being able to answer affirmatively to the question 'can you still do "print $FILE 1, 2, 3" in Perl 6?', albeit with the slight caveat that we made the syntax more consistent.

[15:10] <colomon> doing it the scientific way, instead of just looking manually for LHF...

[15:11] <masak> because there are some things we value more than backwards compatibility, such as the never-two-terms-in-a-row rule.

[15:11] <dalek> rakudo: ad46ef8 | moritz++ | t/spectest.data:

[15:11] <dalek> rakudo: run two more test files

[15:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ad46ef8782f5c53e0b5b787e437ead4544928b1a

[15:11] <JimmyZ> LTA ? Less Than Awesome?

[15:11] <colomon> moritz_: to put it a different way: can you see any reason why those tests need S& instead of just &?

[15:11] <colomon> JimmyZ: yes

[15:12] <JimmyZ> colomon: thanks

[15:12] <moritz_> colomon: the scientific (and automated) way has a drawback - it discouraged me from manually looking at test files, which is often also needed

[15:12] <colomon> sure, most of my bumps have involved simple patches to Rakudo.

[15:13] <moritz_> colomon: the idea was that the regex match is only carried out when the eval failed...

[15:13] <moritz_> colomon: but since a non-Exception return value won't cause an error, I don't think it *needs* to be S&

[15:14] * moritz_ wonders if the S meta op could just set a $*DO_IT_SEQUENTIALLY variable

[15:14] <colomon> moritz_: that's how I'd been thinking about S.

[15:14] <moritz_> and if that is set, the autotreading and hyper dispatcher will do it sequentially

[15:14] <moritz_> which is currently a no-op, because it is sequentially anyway :-)

[15:15] <moritz_> colomon: so +1 from me to implementing S

[15:16] <colomon> my only hesitation is that sometimes S means "short-circuit" instead, if I understand the spec correctly.  And that's completely different from sequential, and I have no idea how to handle it.

[15:17] <colomon> btw, how many tests did you win back with those two additional files?

[15:17] *** rgrau_ joined
[15:20] <colomon> (first stab at implementing Sop now compiling)

[15:20] <arnsholt> colomon: Sequential evaluation for | and & would essentially be short-circuit semantics

[15:21] <arnsholt> Or at least, that's how I understand it

[15:22] <colomon> do we have tests for this?  if no, can we come up with them?

[15:23] <arnsholt> I don't know if there are any tests, but I suppose the examples from S03 are a place to start

[15:24] <colomon> rakudo; say 2 orelse 4

[15:24] <colomon> rakudo: say 2 orelse 4

[15:24] <p6eval> rakudo e113d8: OUTPUTÂ«Confused at line 11, near "say 2 orel"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[15:26] *** dual left
[15:26] <ash___> std: say 2 orelse 4

[15:26] <p6eval> std 30606: OUTPUTÂ«ok 00:01 110mâ¤Â»

[15:28] <ash___> do the values in the settings belong to any package? GLOBAL maybe? 

[15:28] <colomon> S03-operators/also.t

[15:30] <masak> ash___: CORE

[15:30] <ash___> thanks masak 

[15:31] <diakopter> moritz_: did you see perlesque passed man_or_boy?

[15:31] <masak> S02 has the details.

[15:31] <colomon> ooooo, except for 3 S& 4 S& 5, we pass all the S& tests in also.t

[15:31] <colomon> I'm going to add that test file and spectest

[15:34] <isBEKaml> what are the flags that can be passed with --trace to perl6?

[15:34] <isBEKaml> the running.pod doesn't flesh them out... 

[15:35] <isBEKaml> I just passed numbers and it's dumping the whole trace.. er, it's still doing it.. :|

[15:36] <pmurias> diakopter: hi

[15:36] <phenny> pmurias: 04:59Z <diakopter> tell pmurias please backlog; all kinds of neat stuff there

[15:36] *** JimmyZ left
[15:36] <diakopter> pmurias: hi

[15:38] *** s1n left
[15:38] *** gurjeet left
[15:39] *** lichtkind joined
[15:39] *** gurjeet joined
[15:39] <isBEKaml> Specifically, what do those numbers stand for? perl6 --trace={0,1,4} -e "say 'hi';"

[15:40] <pmurias> diakopter: you intend to also class declaration with class Foo {...} not only through runsharp method calls?

[15:40] <diakopter> yes :)

[15:40] <diakopter> today

[15:40] <pmurias> good

[15:41] <diakopter> type literals are cool, too

[15:41] <diakopter> you saw the man_or_boy.t results?

[15:42] <pmurias> type literals?

[15:42] <diakopter> perlesque: say(int)

[15:42] <p6eval> perlesque: OUTPUTÂ«System.Int32â¤Â»

[15:43] <lichtkind> mas

[15:43] <lichtkind> masak: hej

[15:43] <masak> o/

[15:43] <lichtkind> :)

[15:43] <pmurias> t/man_or_boy.t should print out -67

[15:44] <diakopter> yes

[15:45] <diakopter> oh, I neglected to add TAP stuff

[15:45] *** isBEKaml left
[15:46] <pmurias> does visual studio support TAP integration or does it need the test results in a different format?

[15:46] <diakopter> no idea

[15:46] <diakopter> I commit to svn, then update from linux VM and test from mono

[15:46] <diakopter> then fix bugs then commit again

[15:47] <pmurias> i see

[15:47] <masak> lichtkind: I saw your post: http://use.perl.org/~perl6doc/journal/40348

[15:48] <lichtkind> masak: and?

[15:48] <diakopter> I've gotten quite good at printf debugging, since I can't really step through or set breakpoints in generated code

[15:48] <pmurias> should i fix the man_or_boy.t?

[15:48] <diakopter> I can

[15:48] <masak> lichtkind: I really hope someone starts such a project. whether from a clean slate or from November doesn't matter that much to me. November has been useful in other ways already.

[15:49] *** finanalyst joined
[15:49] <pmurias> fixing

[15:49] <masak> there is still potential to be explored in the area of Perl 6 wiki software, it's just that currently that niche isn't filled with any person with tuits.

[15:52] <lichtkind> masak: do you agree that the retrieving DBI data and buitlding html sites is the easy part?

[15:53] <masak> in the sense that it's just a SMOP, yes.

[15:53] <lichtkind> insider answer :)

[15:54] <dalek> csmeta: r257 | pawelmurias++ | trunk/Sprixel/t/man_or_boy.t:

[15:54] <dalek> csmeta: man or boy test produces TAP

[15:54] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=257

[15:54] <masak> my answer was meant to be read as something akin to this argument: http://blog.bitquabit.com/2009/07/01/one-which-i-call-out-hacker-news/

[15:55] <masak> i.e. some things look trivially easy, but the actual complexity has been invested into making the thing easy to use.

[15:55] <masak> it might be the lack of something like that which makes SocialText near unusable.

[15:56] <masak> similarly, the RT interface for constructing queries by shunting ANDs and ORs around in a formula tree structure -- obviously designed by a programmer -- is cute in theory, but bafflingly useless in practice.

[16:00] *** [mark] joined
[16:05] *** [mark] left
[16:07] <colomon> 32005 passing tests!

[16:07] *** molaf joined
[16:07] <masak> \o/

[16:07] <masak> colomon++

[16:07] <pugssvn> r30609 | colomon++ | [t/spec] Fudge for Rakudo. 

[16:08] <dalek> rakudo: 27e05a8 | (Solomon Foster)++ |  (3 files):

[16:08] <dalek> rakudo: Add dead simple preliminary implementation of Sop, and turn on the only test we were able to find for it.

[16:08] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/27e05a8ff044c20295695d56ee10f4d5691df2b6

[16:08] <slavik> out of how many?

[16:12] <colomon> 39026 that tools/test_summary.pl knows about

[16:12] <slavik> so roughly 80%

[16:13] <slavik> but not 100% of the spec has tests, right?

[16:13] <colomon> surely not

[16:14] <slavik> how much of spec has tests? best guesstimate :)

[16:14] <colomon> I've got not a clue.

[16:15] <ash___> slavik: you have to consider parts of the spec aren't fully written to, like S15 through S20 are rough drafts 

[16:16] <colomon> speaking of which, moritz_++, I think your next LHF challenge should be to write tests for the S metaop.  :)

[16:16] <ash___> really i'd say about 14 through 31 are rough drafts and most of those don't have tests, they might have some, but not many 

[16:17] <diakopter> pmurias: I overrode your changes; man_or_boy does 1..17 now

[16:17] <colomon> heh, none of those S& tests in rx.t actually work.  but I've switched them all to todos instead of skips.

[16:17] <ash___> plus, one of the biggest challenges (that would be awesome to achieve) is to have rakudo run STD.pm6 that would be great

[16:18] <slavik> ash___: good point

[16:18] <dalek> csmeta: r258 | diakopter++ | trunk/Sprixel/ (3 files):

[16:18] <dalek> csmeta: [perlesque] loop form of man_or_boy.t, to test 1..17 starting values

[16:18] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=258

[16:18] <pugssvn> r30610 | colomon++ | [t/spec] Move 55 "skip" tests to "todo". 

[16:18] <pmurias> diakopter: np

[16:18] *** stepnem joined
[16:19] * masak now has a project called 'failure' :) http://github.com/masak/failure

[16:19] <masak> it's Perl 5, though.

[16:19] <diakopter> masak: lol

[16:19] <masak> now I just need to name a project 'disaster' :P

[16:20] <diakopter> boondoggle

[16:20] <diakopter> deathmarch

[16:20] <masak> dancing class &

[16:20] *** masak left
[16:23] *** Ky6uk joined
[16:24] *** patrickas joined
[16:28] *** Ky6uk left
[16:31] *** EXCHIM left
[16:34] <moritz_> last test run: 31998

[16:34] <moritz_> passing

[16:36] *** literal left
[16:36] <patrickas> moritz_, I always wondered about how many tests does/did Pugs  pass and what is the intersection of passing tests between rakudo and Pugs? Is such info easy to get ?

[16:36] <phenny> patrickas: 08 May 11:35Z <masak> tell patrickas that the logotype/logo_32x32.png idea sounds good.

[16:37] *** literal joined
[16:37] <moritz_> patrickas: not sure where such info could be found... apart from running the tests yourself

[16:38] <arnsholt> Pugs probably passed more tests back in the day too

[16:38] <moritz_> ... when it tracked the spec :-)

[16:38] <arnsholt> Yeah

[16:39] <patrickas> oh... I was kinda hoping rakudo would be passing more tests than Pugs by now

[16:41] <moritz_> I'm pretty sure it does

[16:42] <moritz_> rakudo: /<[-]>/

[16:42] <p6eval> rakudo e113d8: OUTPUTÂ«Obsolete use of hyphen in enumerated character class;in Perl 6 please use .. instead at line 11, near "]>/"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[16:43] <diakopter> moritz_: numbers: http://pugs.blogs.com/pugs/2008/07/pugshs-is-back.html

[16:44] <moritz_> diakopter: thanks

[16:45] <moritz_> rakudo: say 'ab' ~~ /<after a>b/

[16:45] <p6eval> rakudo 27e05a: OUTPUTÂ«Method 'after' not found for invocant of class 'Regex;Cursor'â¤current instr.: '_block48' pc 317 (EVAL_1:128)â¤Â»

[16:46] <moritz_> rakudo: say 'ab' ~~ /<?after a>b/

[16:46] <p6eval> rakudo 27e05a: OUTPUTÂ«Method 'after' not found for invocant of class 'Regex;Cursor'â¤current instr.: '_block48' pc 317 (EVAL_1:128)â¤Â»

[16:46] <moritz_> rakudo: say 'ab' ~~ /<?before a>b/

[16:46] <p6eval> rakudo 27e05a: OUTPUTÂ«â¤Â»

[16:47] <moritz_> rakudo: /\A/

[16:47] <p6eval> rakudo 27e05a: OUTPUTÂ«Obsolete use of \A as beginning-of-string matcher;in Perl 6 please use ^ instead at line 11, near "/"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[16:48] <moritz_> rakudo: say eval('/\A/')

[16:49] <p6eval> rakudo 27e05a: OUTPUTÂ«â¤Â»

[16:49] <diakopter> how many tests in the entire test suite currently?

[16:49] <moritz_> TimToady: t/spec/S05-mass/rx.t seems to assume that a failed eval *returns* a Failure object - is that correct?

[16:49] <moritz_> diakopter: about 40k

[16:50] <diakopter> so rakudo fails 8K tests.

[16:50] <diakopter> is it possible to estimate how many of those 8K tests are of a generated nature?

[16:50] <moritz_> that number sounds deceptively low

[16:51] <moritz_> diakopter: not many... about 2k or so probably p5 regex tests borrowed from the p5 test suite

[16:51] <diakopter> (that is, how many of those 8K tests appeared after that pugs blog entry)

[16:51] <moritz_> that's not the same question :-)

[16:51] <diakopter> it's fairly close

[16:52] <diakopter> I mean, both of those conditions

[16:52] <diakopter> well really, just how many appeared after that pugs blog entry, sorry

[16:52] <diakopter> using the generated/imported condition as an estimate if necessary

[16:52] *** patrickas left
[16:53] <moritz_> about 20k new tests, of which probably 16k to 18k are not individually hand-written

[16:53] <diakopter> ok. assume 4K handwritten.

[16:53] <diakopter> seems high

[16:53] <diakopter> I'll assume 2K

[16:54] <moritz_> well, I've put a lot of effort into it; so has KyleHa++

[16:54] <diakopter> yes.

[16:54] <diakopter> oh, I guess 4K is reasonable given some of those are loop-y tests

[16:55] *** patrickas joined
[16:57] *** Intensity joined
[16:59] <diakopter> ok, pugs failed 2K/19K tests in July 2008, and today rakudo fails 8K/40K tests (of which 17K (21K minus 4K handwritten/new/passing) are 1. both passing and 2. generated/imported), which leaves 8K out of the July 2008 19K that Rakudo isn't passing

[17:00] <diakopter> oops, numbers fail.  trying again.

[17:00] * moritz_ would try to argue otherwise

[17:00] <moritz_> if pugs passed most of the new/generated tests, minus the 4k new ones

[17:01] <moritz_> it would pass all but 6k total

[17:01] <moritz_> which would be 36k

[17:01] <moritz_> assuming it did similar spec changes tracking as rakudo does

[17:01] <diakopter> why would it pass the new/generated tests but not the 4k handwritten ones?

[17:02] <moritz_> because the generated ones can be made to pass with rather little effort

[17:02] <diakopter> true; good point.

[17:03] <moritz_> so, did we learn anything of value from our little number experiments?

[17:04] <moritz_> that pugs was really awesome while it was being actively developed? I guess we knew that before :-)

[17:04] <moritz_> that rakudo still has a long way to go? we knew that too

[17:04] <diakopter> no; those weren't my points/intents

[17:05] <diakopter> I don't know.  I guess I just don't like all those generated tests, b/c they seem to inflate the numbers, regardless of implementation/comparisons

[17:06] <moritz_> I also think they should be somehow reduced

[17:06] <diakopter> maybe I could grow to like them someday

[17:06] <moritz_> yet I do see some value; the number of should-be-covered cases does increase quadratically with the number of supported numeric types

[17:07] *** am0c left
[17:07] <moritz_> rakudo: say (+<Int Num Rat Complex Real Numeric>)**2

[17:07] <p6eval> rakudo 27e05a: OUTPUTÂ«36â¤Â»

[17:08] <diakopter> yeah.  maybe most of the non-edge/corner crosses could be moved to a "stresstest" target

[17:09] <diakopter> or something.

[17:09] <moritz_> not sure; I'll think more about it

[17:09] <moritz_> afk&

[17:10] <colomon> my basic theory on the numeric tests is to decrease the number of values tested while increasing the number of combinations....

[17:10] <colomon> afk & mother's day dinner

[17:15] <diakopter> to clarify/revise my statement, instead of "inflate the numbers", I think more importantly they drown/crowd out the visibility of failing tests that are perhaps much more essential (such as closures, e.g.)

[17:16] * diakopter shuts up and goes back to Visual Studio to finish implementing class declarations in perlesque

[17:17] *** snarkyboojum left
[17:18] * patrickas learned that pugs is even awesomer that he though it was!

[17:18] <patrickas> audrey++ i guess

[17:20] *** cxreg joined
[17:21] *** am0c joined
[17:28] <slavik> pugs is awesome ... but I wonder how close it is to rakudo in terms of features

[17:30] <slavik> is there a perl5 implementation on parrot?

[17:31] *** M_o_C joined
[17:36] <diakopter> slavik: no one is working on one, afaik.

[17:38] <slavik> I have rakudo on my system

[17:38] <slavik> but Data::Dumper cannot be found ...

[17:39] <slavik> slava@dogbert:~/src/rakudo/rakudo-2010.03$ ./perl6 -e 'use Data::Dumper; my @a = 1..5; say Dumper @a;'

[17:39] <slavik> Unable to find module 'Data::Dumper'.

[17:39] <slavik> current instr.: 'perl6;Perl6;Module;Loader;need' pc 33942 (src/gen/role_pm.pir:0)

[17:39] <slavik> slava@dogbert:~/src/rakudo/rakudo-2010.03$ echo $PERL6LIB

[17:39] <slavik> .::/home/slava/src/rakudo/rakudo-2010.03/parrot/runtime/parrot/library/

[17:39] <slavik> slava@dogbert:~/src/rakudo/rakudo-2010.03$

[17:39] <diakopter> oh; you'd need sorear's edition for that, I think.

[17:39] <slavik> :(

[17:39] <slavik> where is that?

[17:39] *** envi^home left
[17:39] <diakopter> maybe his github?

[17:39] <diakopter> I don't know

[17:40] <diakopter> I just know he got a lot of Perl 5 integration (not *implementation*) done for parrot/rakudo

[17:41] <slavik> but the Data/Dumper.pir is there ...

[17:41] <diakopter> ohhh

[17:41] <diakopter> I have no idea.

[17:41] <diakopter> I don't use rakudo

[17:41] <slavik> diakopter: what do you use?

[17:41] <slavik> perlesque?

[17:41] <diakopter> I don't *use* anything; I'm developing perlesque

[17:42] <slavik> :(

[17:42] <diakopter> but I do weird-stress rakudo here on #perl6 via p6eval fairly often

[17:42] <slavik> k

[17:47] <diakopter> and std.

[17:48] <pmurias> diakopter: how is the implementation of classes going? ;)

[17:49] <diakopter> got them parsing

[17:49] <diakopter> working on vivifying/emitting 

[17:49] <pmurias> vivifying?

[17:50] <diakopter> yeah, the types have to become live during the parse

[17:51] <diakopter> as RunSharp.TypeGen that is

[17:51] <diakopter> which derives System.Type

[17:52] <diakopter> pmurias: oh yeah; by "today" I meant "my today" which means by 12 hours from now :D

[17:52] <pmurias> ah

[17:52] <diakopter> so, your tomorrow :)

[17:56] *** plobsing joined
[17:58] *** kaare joined
[17:58] *** kaare is now known as Guest86603

[18:01] *** Guest86603 left
[18:01] <diakopter> oh, and, I get lexical & anonymous classes for free.

[18:01] <diakopter> bonus.

[18:03] <diakopter> well, lexical in the sense its initialization block (and contained methods) close over all their outer lexical scopes, but non anonymous ones will still be globally available after declaration.  a minor nit.

[18:04] <diakopter> "minor nit" is repetitively redundant

[18:05] <pmurias> class Foo {my $bar=4;method foo {return $bar}}?

[18:06] <diakopter> yeah, and my $baz = 'hi'; class Foo {my $bar=4;method foo {return $bar ~ $baz}}

[18:08] <diakopter> so if an anonymous class is declared in a routine/block that runs more than once, each time it runs, it'll create a new anonymous class with its own "private static" variables such as $bar , above

[18:08] <diakopter> behavior of a named class whose initializer runs more than is undefined for now...

[18:08] <diakopter> more than *once

[18:09] <diakopter> that'll allow for parametric class generation, methinks

[18:11] *** iblechbot left
[18:12] <diakopter> rakudo: class Foo {my $bar=4;method foo {return $bar}; method baz {$bar=7}}; my Foo $f.=new; say $f.foo; $f.baz; say $f.foo

[18:12] <p6eval> rakudo 27e05a: OUTPUTÂ«4â¤7â¤Â»

[18:12] *** gurjeet left
[18:13] <diakopter> rakudo: class Foo {my $bar=4;method foo {return $bar}; method baz {$bar=7}}; my Foo $f.=new; say $f.foo; $f.baz; say $f.foo; $f.=new; say $f.foo; my Foo $g.=new; say $g.foo

[18:13] <p6eval> rakudo 27e05a: OUTPUTÂ«4â¤7â¤7â¤7â¤Â»

[18:13] <diakopter> yeah, that's the behavior of rakudo

[18:14] <diakopter> alpha: class Foo {my $bar=4;method foo {return $bar}; method baz {$bar=7}}; my Foo $f.=new; say $f.foo; $f.baz; say $f.foo; $f.=new; say $f.foo; my Foo $g.=new; say $g.foo

[18:14] <p6eval> alpha 30e0ed: OUTPUTÂ«4â¤7â¤7â¤7â¤Â»

[18:14] <diakopter> <whew>

[18:14] <diakopter> locals in the class block are private static

[18:15] <diakopter> pugs: class Foo {my $bar=4;method foo {return $bar}; method baz {$bar=7}}; my Foo $f.=new; say $f.foo; $f.baz; say $f.foo; $f.=new; say $f.foo; my Foo $g.=new; say $g.foo

[18:15] <p6eval> pugs: OUTPUTÂ«â¤7â¤7â¤7â¤Â»

[18:15] <diakopter> weird

[18:15] <diakopter> $bar was never set to 4

[18:15] <diakopter> pugs: class Foo {my $bar=4; say($bar); method foo {return $bar}; method baz {$bar=7}}; my Foo $f.=new; say $f.foo; $f.baz; say $f.foo; $f.=new; say $f.foo; my Foo $g.=new; say $g.foo

[18:15] <p6eval> pugs: OUTPUTÂ«4â¤â¤7â¤7â¤7â¤Â»

[18:16] <diakopter> weird.

[18:16] * diakopter will drop the issue

[18:17] <diakopter> mimicing rakudo is plenty at this point

[18:18] *** ^aristotle joined
[18:19] <^aristotle> alpha: my @a = <<a b c>>; my %h; %h{@a}

[18:19] <p6eval> alpha 30e0ed:  ( no output )

[18:19] <^aristotle> alpha: my @a = <<a b c>>; my %h; %h{@a}.join(" ")

[18:19] <p6eval> alpha 30e0ed: OUTPUTÂ«Use of uninitialized valueâ¤Use of uninitialized valueâ¤Use of uninitialized valueâ¤Â»

[18:19] <^aristotle> alpha: my @a = <<a b c>>; my %h; %h{@a}.join(" ").say

[18:19] <p6eval> alpha 30e0ed: OUTPUTÂ«Use of uninitialized valueâ¤Use of uninitialized valueâ¤Use of uninitialized valueâ¤  â¤Â»

[18:20] <^aristotle> alpha: my @a = <<a b c>>; my %h; [=] (%h{@a},1); %h{@a}.join(" ")

[18:20] <p6eval> alpha 30e0ed: OUTPUTÂ«Syntax error at line 10, near "[=] (%h{@a"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[18:20] <^aristotle> alpha: my @a = <<a b c>>; my %h; [=] %h{@a}; %h{@a}.join(" ")

[18:20] <p6eval> alpha 30e0ed: OUTPUTÂ«Syntax error at line 10, near "[=] %h{@a}"â¤in Main (file <unknown>, line <unknown>)â¤Â»

[18:20] *** M_o_C left
[18:24] *** ^aristotle left
[18:29] <lue> hello!

[18:29] <diakopter> lue: hi

[18:29] *** snarkyboojum joined
[18:30] <diakopter> perlesque: class Foo { method bar (--> str) { return 'hiyo' } }; say(4);

[18:30] <p6eval> perlesque: OUTPUTÂ«4â¤Â»

[18:30] <diakopter> heh. it doesn't actually do anything yet :)

[18:30] <diakopter> just recognizes the syntax

[18:32] <dalek> csmeta: r259 | diakopter++ | trunk/Sprixel/ (4 files):

[18:32] <dalek> csmeta: [perlesque] parsing class declarations & their methods; parameterized the sub

[18:32] <dalek> csmeta: declaration combinator in the process (instead of copy/pasting code; yay me).

[18:32] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=259

[18:34] <diakopter> perlesque: class Foo { method bar (--> str) { return 'hiyo' }; say('declared Foo') }; say(4);

[18:34] <p6eval> perlesque: OUTPUTÂ«declared Fooâ¤4â¤Â»

[18:36] <dalek> csmeta: r260 | diakopter++ | trunk/Sprixel/src/Perlesque/Declarations.cs:

[18:36] <dalek> csmeta: [perlesque] make class declaration block a lexical scope

[18:36] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=260

[18:38] <lue> I still wish there were some sort of resource where you could learn about rakudo's guts, the bits with nqp and pir.

[18:38] <diakopter> pmurias: see that last diff if you're curious about how to make a block a lexical scope.  it's a two-line change

[18:38] <lue> (and I don't wish to keep badgering people; learning everything that way takes forever :D)

[18:41] <arnsholt> lue: I think the best way ATM to learn NQP and PIR is simply to do something with them

[18:41] <arnsholt> The PIR docs are decent (the PDDs are quite useful), and NQP is pretty much a thin layer on top of PIR

[18:42] <lue> just some fun programming exercises?

[18:42] <arnsholt> And if there's anything you need to know, src/NQP/Grammar.pm in nqp-rx is pretty comprehensible

[18:42] <arnsholt> Whatever is the best way you learn programming languages pretty much

[18:42] <lue> I delved into PIR a while ago, not that hard. What I wish existed were Rakudo's "API" or equivalent.

[18:42] <lue> Ah well, time to find my pith helmet :)

[18:42] <arnsholt> I've got my Prolog on Parrot project, which I've learnt quite a bit from already

[18:46] <lue> I can't find src/NQP/Grammar.pm :/

[18:47] <diakopter> in the rakudo sources

[18:47] <diakopter> er

[18:47] <snarkyboojum> parrot src somewhere probably?

[18:47] <diakopter> http://github.com/perl6/nqp-rx/blob/master/src/NQP/Grammar.pm

[18:47] <lue> not in [rakudo]/src or [rakudo]/parrot/src (can't find the NQP folder)

[18:47] <colomon> NQP is in Parrot, not Rakudo

[18:48] <diakopter> lue: it's in nqp-rx sources

[18:48] <moritz_> only a compiled version of nqp-rx is shipped with parrot

[18:48] <diakopter> see the link above...

[18:48] <lue> ok. I ought to download it then :)

[18:48] <snarkyboojum> ah ok :)

[18:48] <lue> (nqp-rx)

[18:51] <diakopter> anyone here know about parrot's inheriting-hashes?

[18:51] *** M_o_C joined
[18:51] <patrickas> moritz_: are you still updating the proto web manually or is it ina  cron already ?

[18:51] <moritz_> patrickas: cron job

[18:52] <patrickas> and does the cron automatically pulls the latest update script from github ?

[18:52] <moritz_> it should, yes

[18:53] <patrickas> ok ... I guess I have to be a bit more careful when pushing  :-)

[18:53] <moritz_> btw the "has tests" detection is broken

[18:53] <moritz_> json has tests

[18:54] <patrickas> that's masak's work :-)

[18:54] <sorear> slavik: You need to write use Data::Dumper:from<perl5>;

[18:54] <sorear> slavik: different languages have disjoint module namespaces

[18:54] <moritz_> in fact it thinks that no project has tests at all

[18:54] <patrickas> or lack of ... actually I don't see anything in the code related to it... I guess he just added the pngs and relied on me to add the code. I'll do that next...

[18:55] <snarkyboojum> footer on proto.perl6.org looks a bit funny left aligned and outside the 700px column

[18:56] <sorear> slavik: there are two projects to support "perl5" as a Parrot language.  PONIE, a port of the P5 compiler to generate Parrot code (is dead, needs >5 man-years to revive), and blizkost (autothunks Parrot calls into libperl.so, mostly works)

[18:57] <slavik> sorear: blizkost makes use of parrot can call arbitrary C libraries thingy?

[18:58] <snarkyboojum> perhaps put it in a footer div which is styled similarly to head (in terms of width margin etc?)

[18:58] <moritz_> snarkyboojum: code is in the proto repo in web/index.tmpl

[18:58] <snarkyboojum> moritz_: aye :)

[18:59] <slavik> jnthn: blizkost ... Ğ±Ğ»Ğ¸Ğ·ĞºĞ¾ÑÑ‚ÑŒ?

[18:59] <slavik> or sorear

[19:07] * lue should peek in docs/ once in a while *cough*

[19:09] *** dual joined
[19:13] <sorear> slavik: no.  blizkost is a Parrot-API extension; it does not use the FFI

[19:13] <slavik> what does FFI stand for?

[19:13] <sorear> foreign function interface

[19:13] <sorear> aka "parrot can call arbitrary C libraries thingy"

[19:13] <slavik> also, does blizkost come from the slavic word to mean nearby?

[19:14] <slavik> I see

[19:14] <moritz_> yes

[19:14] <slavik> :)

[19:14] <slavik> finally, my russian is worth some random trivia

[19:14] <slavik> :P

[19:15] <sorear> jnthn speaks Slovak

[19:15] <sorear> I don't

[19:17] <slavik> :(

[19:17] <moritz_> I think it says as much in the README

[19:18] <slavik> moritz_: bah at you and reading READMEs :P

[19:19] <sorear> in any event, you don't need Data::Dumper in Perl6

[19:19] <sorear> the functionality is built in

[19:19] <slavik> .WHAT?

[19:19] <slavik> or .perl?

[19:19] <sorear> rakudo: say %*ENV.perl

[19:19] <p6eval> rakudo 27e05a: OUTPUTÂ«Method 'key' not found for invocant of class 'String'â¤current instr.: 'perl6;EnumMap;_block21197' pc 504340 (src/gen/core.pir:76818)â¤Â»

[19:19] <sorear> rakudo: say Cool.^methods.perl

[19:19] <moritz_> :-)

[19:19] <p6eval> rakudo 27e05a: OUTPUTÂ«[{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ...

[19:19] <p6eval> ..}, { â€¦

[19:19] <moritz_> well, it doesn't handle routines yes

[19:19] <moritz_> rakudo: say [{a => 2}, 4].perl

[19:19] <p6eval> rakudo 27e05a: OUTPUTÂ«[{"a" => 2}, 4]â¤Â»

[19:19] <sorear> neither does Data::Dumper, really

[19:20] * sorear ponders writing a rakudo decompiler

[19:20] <moritz_> just store a pointer to the original source code

[19:21] <slavik> since all code get's compiled to pir/pbc ... what would happen if you compile language1 on parrot and use a decompiler for language2 on the bytecode?

[19:22] <slavik> would be interesting methinks

[19:22] <slavik> instance language translation

[19:22] *** jonrafkind joined
[19:22] <sorear> language translation at the semantic level is a lot easier than you might think

[19:22] <slavik> you mean source to source?

[19:23] <sorear> I mean source to source-that-runs-the-same

[19:23] <sorear> most of the complexity in a program like p2c is involved in preserving formatting and comments

[19:24] <slavik> ahh

[19:25] <slavik> sorear: formatting and comments aside, compiling wins the optimizations from the compiler, so you can compile/decompile to see how to better write code or something

[19:27] *** M_o_C left
[19:31] <arnsholt> slavik: I think applying a decompiler to a different language would result in weird stuff

[19:31] <arnsholt> In the best case just a lot of inline PIR

[19:32] <lue> erm,.... YOU_ARE_HERE is seemingly useless.

[19:33] <arnsholt> From my understanding, it isn't

[19:33] <arnsholt> It's where user code is inserted to be run

[19:33] <sorear> YOU_ARE_HERE is very black magic

[19:33] <sorear> it's what makes the setting work

[19:34] <sorear> in topic/lexical-persistence, it's also what makes the REPL wor

[19:34] <sorear> k

[19:36] <lue> ok.

[19:37] *** ash___ left
[19:37] <lue> YOU_ARE_HERE.pm containing the line YOU_ARE_HERE; must be deep magic indeed :)

[19:37] <sorear> if you get rid of that line, the stage 2 compiler will be non-functional

[19:38] <sorear> resuming lexical scopes across compiler runs is very tricky

[19:38] <arnsholt> I think jnthn claimed responsibility for YOU_ARE_HERE

[19:39] <lue> rakudo: YOU_ARE_HERE; # just curious

[19:39] <p6eval> rakudo 27e05a:  ( no output )

[19:39] <diakopter> rakudo: say YOU_ARE_HERE;

[19:39] <p6eval> rakudo 27e05a: OUTPUTÂ«Null PMC access in type()â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[19:39] <diakopter> rakudo: say YOU_ARE_HERE.WHAT;

[19:39] <p6eval> rakudo 27e05a: OUTPUTÂ«Null PMC access in find_method('WHAT')â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[19:39] <sorear> rakudo: say 2+2; YOU_ARE_HERE;

[19:39] <p6eval> rakudo 27e05a: OUTPUTÂ«4â¤Â»

[19:40] <sorear> rakudo: YOU_ARE_HERE; say 2+2;

[19:40] <p6eval> rakudo 27e05a: OUTPUTÂ«4â¤Â»

[19:40] <sorear> rakudo: say $x; my $x; YOU_ARE_HERE;

[19:40] <p6eval> rakudo 27e05a: OUTPUTÂ«Any()â¤Â»

[19:40] <sorear> see?  magic.

[19:40] <slavik> is @*IN all the input lines?

[19:40] <sorear> I've tied the lexical scope in a knot

[19:41] <diakopter> rakudo: say .lines

[19:41] <p6eval> rakudo 27e05a: OUTPUTÂ«Method 'lines' not found for invocant of class ''â¤current instr.: '_block14' pc 29 (EVAL_1:0)â¤Â»

[19:41] <diakopter> rakudo: say lines

[19:41] <p6eval> rakudo 27e05a: OUTPUTÂ«No applicable candidates found to dispatch to for 'lines'. Available candidates are:â¤:(IO $filehandle, Any :bin($bin) = { ... }, Any :enc($enc) = { ... }, Any :nl($nl) = { ... }, Any :chomp($chomp) = { ... })â¤:(Str $filename, Any $limit = { ... })â¤â¤current instr.: '_block14'

[19:41] <p6eval> ..pc 29 â€¦

[19:41] *** Patterner left
[19:41] <sorear> it's considerably more awesome in lexical-persistence though ;)

[19:41] <lue> rakudo: say @*IN

[19:41] <p6eval> rakudo 27e05a:  ( no output )

[19:44] * sorear attempts to get people to try it

[19:46] *** kensanata joined
[19:48] *** alester joined
[19:49] <lue> wait, there's a fail command?

[19:51] <colomon> lue: not only that, but for a while there it didn't work.  ;)

[19:51] <mantovani> guys can I ask something here ?

[19:51] *** Psyche^ joined
[19:51] *** Psyche^ is now known as Patterner

[19:52] <colomon> mantovani: yes.

[19:52] <mantovani> all right.

[19:52] *** finanalyst left
[19:52] <mantovani> I tryng solve some problems and when the number is very big I have "inf"

[19:52] *** finanalyst joined
[19:53] <mantovani> http://paste.scsys.co.uk/43329?tx=on&wr=on&ln=on&tidy=on&hl=on&submit=Format+it!

[19:54] <mantovani> can I do something like big int

[19:54] <colomon> mantovani: that's perl 5, there is a separate channel for that, #perl

[19:54] <colomon> but isn't it just 

[19:54] <colomon> use BigInt;

[19:54] <colomon> ?

[19:54] <colomon> in 5.10, I mean.

[19:54] <mantovani> I can't

[19:54] <lue> colomon: the irony :)

[19:54] <colomon> I've not done that in a long time, but I believe it's something like that.

[19:54] <mantovani> if I do the result is very diferent

[19:55] <mantovani> I did, bigint and bitnum(bignum lock my pc)

[19:55] <mantovani> ok I'll try #perl5

[19:55] <mantovani> thanks

[19:55] <lue> just #perl ought to work.

[19:56] * lue gets a warm feeling as he finds src/builtins/assign.pir . Hope still exists for :=

[19:57] <sorear> := cannot be implemented there

[19:57] <sorear> := must be a parser special

[19:57] * colomon feels like he should know a shortcut for that equation, but nothing is coming to mind....

[19:57] <lue> I know. My current goal is to find variable initilization.

[19:57] <sorear> the implementation is trivial if TimToady would just get back to me on what it means

[19:57] *** alester left
[19:58] <sorear> colomon: that's the closed form of the fibonnaci sequence

[19:58] <colomon> sorear++

[19:58] <sorear> it can be reexpressed in a purely integer form using the LDU decomposition of the generating matrix

[19:59] <sorear> however, I forget the form

[20:04] *** justatheory joined
[20:09] <lue> how does trace work in Rakudo, if it even works yet?

[20:13] *** justatheory left
[20:14] <sorear> --trace is a PCT argument

[20:14] <sorear> it gets parsed and then fed into Parrot as trace flags

[20:14] <lue> ah.

[20:20] <finanalyst> rakudo: my regex an { <digit>+ }; my $x='qw=345 er=12'; $x ~~ m/<an>/

[20:20] <p6eval> rakudo 27e05a: OUTPUTÂ«Method 'an' not found for invocant of class 'Regex;Cursor'â¤current instr.: '_block70' pc 668 (EVAL_1:241)â¤Â»

[20:20] <finanalyst> alpha: my regex an { <digit>+ }; my $x='qw=345 er=12'; $x ~~ m/<an>/

[20:20] <p6eval> alpha 30e0ed: OUTPUTÂ«Unable to find regex 'an'â¤in regex Â»

[20:21] <finanalyst> std: my regex an { <digit>+ }; my $x='qw=345 er=12'; say ?($x ~~ m/<an>/)

[20:21] <p6eval> std 30610: OUTPUTÂ«ok 00:01 115mâ¤Â»

[20:22] <pmurias> diakopter: do you think writing a "fake" replacement for the part of runsharp that Sprixel uses so that it generates C# would be hard?

[20:22] <finanalyst> rakudo: my regex an { <digit>+ }; my $x='qw=345 er=12'; say ?($x ~~ m/<an>/)

[20:22] <p6eval> rakudo 27e05a: OUTPUTÂ«Method 'an' not found for invocant of class 'Regex;Cursor'â¤current instr.: '_block70' pc 690 (EVAL_1:243)â¤Â»

[20:22] <sorear> finanalyst: it's spelled <&an> for "my" regices

[20:22] <diakopter> pmurias: explain more?

[20:23] * pmurias gathers his words

[20:24] <finanalyst> rakudo: my regex an { <digit>+ }; my $x='qw=345 er=12'; say ?($x ~~ m/<&an>/)

[20:24] <p6eval> rakudo 27e05a: OUTPUTÂ«Confused at line 11, near "say ?($x ~"â¤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)â¤Â»

[20:25] <lue> rakudo: my regex xyzzy { <digit>+ }; my $x='qw=345 er=12'; say $x ~~ m/<xyzzy>/

[20:25] <p6eval> rakudo 27e05a: OUTPUTÂ«Method 'xyzzy' not found for invocant of class 'Regex;Cursor'â¤current instr.: '_block70' pc 679 (EVAL_1:22420114)â¤Â»

[20:25] <pmurias> diakopter: how hard would it be to write a version of runsharp that produces C#/something human readable as it's output would be

[20:25] <diakopter> very hard. it would be much easier to write a decompiler

[20:26] <sorear> what does runsharp produce currently?

[20:26] <pmurias> like c.Try(); being implemented like method Try {$.code .= 'try {'}

[20:26] <diakopter> it builds a stream of CIL

[20:26] <diakopter> but it is designed to emit to a stack-based assembly language

[20:27] <diakopter> which C# is definitely not

[20:27] <diakopter> pmurias: I do have the benefit of using Reflector on windows...

[20:27] <diakopter> pmurias: do you have a windows installation anywhere? Reflector is free

[20:28] *** alester joined
[20:28] <diakopter> pmurias: otoh I could spend some time trying to get [some version of] Reflector to work in mono

[20:28] <diakopter> (on linux)

[20:30] *** molaf left
[20:30] <diakopter> probably the best thing to do is spend some time trying to get Reflector, since it already has an excellent decompiler

[20:33] <diakopter> runsharp is quite an achievement; there's no way perlesque could have progressed so quickly [even close] without it.

[20:35] <pmurias> generating C# would have worked

[20:35] <diakopter> no

[20:36] <diakopter> well in the mono case, yes, now it would have, since mono has string-eval for C#

[20:36] <diakopter> but that's quite recent

[20:36] <diakopter> .NET doesn't have that

[20:36] <diakopter> it needs runtime codegen and loading of those types/routines in the same environment

[20:37] <diakopter> which runsharp provides

[20:39] <diakopter> theoretically though, on .NET it could emit the C# and call out to the Microsoft csc.exe compiler, and then load the resulting .dll or .exe ... but that would be very tricky to get right

[20:40] <arnsholt> Sounds a bit like implementing "eval" in C

[20:40] <diakopter> right.

[20:40] *** pmurias left
[20:42] *** pmurias joined
[20:44] <diakopter> pmurias: (see the backlog)

[20:48] <pmurias> looking...

[20:50] <dalek> csmeta: r261 | diakopter++ | trunk/Sprixel/src/ (3 files):

[20:50] <dalek> csmeta: [perlesque] a bit of incremental progress on classes.

[20:50] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=261

[20:50] <diakopter> sorear: the author of runsharp is a Stefan

[20:55] <moritz_> it's quite a common name $here :-)

[20:56] *** finanalyst left
[20:57] <moritz_> rakudo: sub a(@a, @b) { say @a === @b }; my @r = 1, 2, 3; a(@r, @r)

[20:57] <p6eval> rakudo 27e05a: OUTPUTÂ«1â¤Â»

[20:58] <moritz_> rakudo: sub a(@a, @b) { say @a === @b }; my @r = 1, 2, 3; a(@r, (1, 2, 3))

[20:58] <p6eval> rakudo 27e05a: OUTPUTÂ«0â¤Â»

[20:59] <moritz_> rakudo: say 1/2 === 1/2

[20:59] <p6eval> rakudo 27e05a: OUTPUTÂ«0â¤Â»

[20:59] <moritz_> I guess that should be True, no?

[20:59] <moritz_> if Rat is a value type

[21:01] *** orafu left
[21:01] *** orafu joined
[21:02] *** alester left
[21:04] *** vdo joined
[21:06] <moritz_> rakudo: say (1, 2, '3') eqv (1, 2, '3')

[21:06] <p6eval> rakudo 27e05a: OUTPUTÂ«1â¤Â»

[21:06] <moritz_> rakudo: say (1, 2, '3') eqv (1, 2, 3)

[21:06] <p6eval> rakudo 27e05a: OUTPUTÂ«0â¤Â»

[21:07] *** alester joined
[21:08] *** pmurias left
[21:08] *** dolmen left
[21:16] *** skangas left
[21:24] *** dolmen joined
[21:25] <snarkyboojum> moritz_: proto.per6.org has gone from 141 HTML validation errors to 0 :)

[21:32] <lue> I'm going afk for a bit, and leaving you a blog post, IIUC: http://rdstar.wordpress.com/

[21:33] *** dolmen left
[21:41] *** plobsing left
[21:42] *** meppl left
[21:50] *** alester left
[21:51] <diakopter> rakudo: class Foo {...}; class Foo {...}

[21:51] <p6eval> rakudo 27e05a:  ( no output )

[21:51] <diakopter> std: class Foo {...}; class Foo {...}

[21:51] <p6eval> std 30610: OUTPUTÂ«ok 00:01 110mâ¤Â»

[21:56] <diakopter> "unnecessary re-pre-declaration ..."

[21:56] <diakopter> :)

[21:56] <sorear> shrug, it's useful in autogenerated code

[21:58] <diakopter> looks like perlesque will need to require full predeclaration of classes

[21:58] <diakopter> (including fields & method signatures)

[21:58] <diakopter> since it's truly single-pass

[21:58] *** bakedb__ left
[21:59] <diakopter> so, I can just co-opt class predeclaration like so:

[21:59] *** jjore left
[22:01] <diakopter> class Foo {...; has str $str1; has List[PrototypeChain[string,P6object]] $chain; method (str $first, Foo $another_foo) {...} };

[22:01] <diakopter> or whatever the member syntax is

[22:01] <diakopter> :)

[22:01] <diakopter> (haven't gotten to those yet; I'm still on methods)

[22:07] *** kensanata left
[22:07] <diakopter> std: class Foo {...; has Str $str1; has Int $chain; method (Str $first, Foo $another_foo) {...} };

[22:07] <p6eval> std 30610: OUTPUTÂ«ok 00:01 112mâ¤Â»

[22:07] <diakopter> I'm not certain whether this will be a problem

[22:08] <diakopter> (requiring full predeclaration)

[22:11] *** lichtkind left
[22:12] * diakopter looks around for TimToady

[22:14] *** jjore joined
[22:16] <diakopter> obviously compilers targeting perlesque would need to be more-than-one-pass

[22:17] <snarkyboojum> patrickas: just noticed, something about the styling of the dl and children is causing the height of the content div to be computed incorrectly

[22:17] *** PacoLinux left
[22:18] <diakopter> rakudo: class Foo {...; has Str $str1; has Int $chain; method (Str $first, Foo $another_foo) {...} }; say Foo.new

[22:18] <p6eval> rakudo 27e05a: OUTPUTÂ«too few positional arguments: 1 passed, 2 (or more) expectedâ¤current instr.: 'perl6;Failure;new' pc 15527 (src/builtins/Seq.pir:77)â¤Â»

[22:18] <diakopter> interesting

[22:18] <diakopter> rakudo: class Foo {...; has Str $str1; has Int $chain; method new (Str $first, Foo $another_foo) {...} }; say Foo.new

[22:18] <p6eval> rakudo 27e05a: OUTPUTÂ«too few positional arguments: 1 passed, 2 (or more) expectedâ¤current instr.: 'perl6;Failure;new' pc 15527 (src/builtins/Seq.pir:77)â¤Â»

[22:18] <diakopter> rakudo: class Foo {...; has Str $str1; has Int $chain; method bar (Str $first, Foo $another_foo) {...} }; say Foo.new

[22:18] <p6eval> rakudo 27e05a: OUTPUTÂ«too few positional arguments: 1 passed, 2 (or more) expectedâ¤current instr.: 'perl6;Failure;new' pc 15527 (src/builtins/Seq.pir:77)â¤Â»

[22:19] <snarkyboojum> patrickas: i.e. box model height is computed to be 260px roughly - makes putting divs with margins and padding after the content div problematic

[22:20] *** jjore left
[22:20] <snarkyboojum> patrickas: anyway - don't know how to "fix" it, or even if it makes sense to :)

[22:23] <patrickas> strange!

[22:23] <patrickas> snarkyboojum: are you trying to fix the footer ?

[22:23] <snarkyboojum> patrickas: nope - was going to put a footer div in there below the content one, but I've noticed you've put the paragraph in the content div

[22:24] <snarkyboojum> patrickas: just mentioning the issue I see with the page

[22:25] <patrickas> Oh ok ...well if it is not affecting anything specific I guess no need to spend much time on it :-)

[22:25] <snarkyboojum> patrickas: it has to do with the dl, dt, dd CSS - if that's ripped out then the height for the content div is computed correctly - but don't know enough to fix it

[22:25] <snarkyboojum> patrickas: yeah - thought I'd mention it anyway

[22:26] <snarkyboojum> patrickas: site validates now too o/

[22:26] <patrickas> I saw that thanks :-)

[22:27] <snarkyboojum> patrickas: the link on the tests badge is currently broken too btw

[22:27] <patrickas> how are you calculating the heights ? is it a cross browser issue ?

[22:28] <patrickas> I have no idea what the link is supposed to point to ....

[22:29] <snarkyboojum> patrickas: just looking at the computed height in firefox and chrome

[22:29] <snarkyboojum> patrickas: using firebug/chrome dev tools etc

[22:42] *** ethel left
[22:44] *** hercynium joined
[22:49] <jnthn> rakudo: class Foo { ...; has $.x; }

[22:49] <p6eval> rakudo 27e05a:  ( no output )

[22:49] <jnthn> rakudo: class Foo { ...; has $.x; }; Foo.new

[22:49] <p6eval> rakudo 27e05a: OUTPUTÂ«too few positional arguments: 1 passed, 2 (or more) expectedâ¤current instr.: 'perl6;Failure;new' pc 15527 (src/builtins/Seq.pir:77)â¤Â»

[22:50] <jnthn> Heh. I guess the ... gets take to mean the whole lot is a stub. D'oh.

[22:50] <diakopter> I think that's what it's supposed to do...?

[22:50] <jnthn> diakopter: And ignore the rest of the declaration silently?

[22:50] <jnthn> That feels a tad wrong.

[22:51] <diakopter> that's what I presumed from my reading of S12

[22:51] <jnthn> We do need a better error for when you stub a class that never finishes getting defined.

[22:51] <jnthn> Heh. Maybe I read S12 and implemented what it said then. ;-)

[22:52] *** patrickas left
[22:52] <diakopter> If the class body begins with a statement whose main operator is a single prefix:<...> (yada) listop, the class name is introduced without a definition, and a second declaration of that class in the same scope does not complain about redefinition.

[22:52] <jnthn> oh, cool

[22:52] <jnthn> Not a bug \o/

[22:53] <diakopter> therefore, I can co-opt it to allow full predeclaration of attribute/method sigs

[22:53] <diakopter> since it seems perlesque will need to require it.

[22:53] <diakopter> which is fine for me... STD's translation of itself isn't going to be generating classes...

[22:54] <diakopter> I mean.

[22:54] <diakopter> STD won't need to generate perlesque classes to translate itself

[22:56] <jnthn> oh noes...my flight is delayed to 2am

[22:56] <diakopter> eww

[22:57] <jnthn> I already did a 5 hour bus journey to get to an airport that's not in the ash cloud so I can fly home. :-)

[22:58] *** plobsing joined
[23:08] *** jjore joined
[23:17] *** jjore left
[23:18] *** circuitbreaker joined
[23:18] *** mariano joined
[23:19] <diakopter> jnthn: in your experience programming in general, if a routine is written as recursive, is it usually a static routine, or are recursive instance routines just as common?

[23:19] <diakopter> sorear: u2

[23:19] <diakopter> well, anyone

[23:19] <diakopter> but hilite you

[23:21] <arnsholt> A recursive instance is no problem

[23:21] <arnsholt> A tree-traversal method for example, should be an instance method on the tree

[23:21] <diakopter> my question is whether to make instance methods also trampolined.  since a "method" can't be returned as a closure in perlesque, I guess it doesn't make sense to do it.

[23:22] <diakopter> arnsholt: well, my interviewers at a certain large software company would disagree with you... they seemed obsessed with rewriting recursive algorithms as iterative ones

[23:22] <arnsholt> Well, some problems are best expressed iteratively

[23:22] <arnsholt> And others recursively

[23:23] *** jjore joined
[23:23] <arnsholt> Also, IME some people are a bit allergic to recursion

[23:23] <diakopter> these were tree-traversal algorithms, mostly.

[23:24] <arnsholt> In that case, was there a good rationale?

[23:24] <diakopter> it was an interview question

[23:24] <arnsholt> Ah, right

[23:24] <diakopter> so there's no rationale

[23:24] <diakopter> :)

[23:25] <arnsholt> 'Cause IIRC you'd have to maintain an explicit stack to transform non-tail recursion into iteration

[23:25] <diakopter> right

[23:25] <diakopter> "don't use the language's callstack, maintain your own"

[23:25] <arnsholt> In which case you'd probably be better of with the OS/VM stack I think

[23:26] <diakopter> sure, but they're too limited for some applications.

[23:26] <arnsholt> True, true

[23:27] <diakopter> in any case, Perl 6 routines will be expressed as perlesque closures anyway, not methods, so it doesn't matter..

[23:27] <jnthn> diakopter: I think many of the ones I write don't use instance data. Actually I find C# shoehorns me into things being methods when actually I just want subrutines.

[23:27] <diakopter> well yeah

[23:27] <jnthn> So it's hard to say in that sense.

[23:28] <jnthn> I often find myself having a public method that does some prep for the recursion and then calls some over thing that's private and recurses (so the fact it's implemented recursively isn't part of the interface).

[23:28] <diakopter> I was worried about potentially overflowing the CLR stack in perlesque code, but it can't happen in the 5th stage (Perl 6) now that I've thought through it.

[23:29] <jnthn> Not that that's especially relevant to the question though...

[23:29] *** rgrau_ left
[23:29] <jnthn> Probably fairest to say is that I do have some that rely on instance data, but most don't.

[23:30] <diakopter> ... and if a perlesque method needs to get recursive, it can be rewritten as a recursive sub, so it'll be trampolined, if there's any danger of hitting stack limits.

[23:31] <diakopter> ok. I'm satisfied that methods don't need to be trampolined, for my purposes.

[23:31] <diakopter> they can always be in the future.

[23:32] <diakopter> phenny: tell pmurias it's going to be another few days to finish classes/methods.  They're somewhat more complex than I initially thought.  But it's all worked out in my head now, so I'm quite certain I can finish them soon.

[23:32] <phenny> diakopter: I'll pass that on when pmurias is around.

[23:44] *** lestrrat is now known as lest_away

[23:46] <dalek> csmeta: r262 | diakopter++ | trunk/Sprixel/ (4 files):

[23:46] <dalek> csmeta: [perlesque] a bit more progress

[23:46] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=262

[23:49] *** bluescreen joined
[23:50] *** bluescreen is now known as Guest2257

[23:53] *** mariano left
[23:53] *** Guest2257 left
[23:54] *** Guest2257 joined
