[00:11] *** supernovus joined
[00:24] *** xinzp joined
[00:24] *** ciphertext_ joined
[00:25] *** xinzp left
[00:31] <supernovus> The one disadvantage of working on my netbook: the core setting take 10+ minutes to compile... :(

[00:34] *** rgrau_ left
[00:38] <TimToady> std: /[ ]/

[00:38] <p6eval> std 31520: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null pattern not allowed at /tmp/zsKkBtPwao line 1:‚ê§------> [32m/[ [33m‚èè[31m]/[0m‚ê§    expecting any of:‚ê§    quantifier‚ê§       regex atom‚ê§Parse failed‚ê§FAILED 00:01 111m‚ê§¬ª

[00:38] <supernovus> Bah, what is the best way to share subs between different classes in the Rakudo core setting? I want to make assert-valid-date, days-in-month and is-leap from the Date class available to Temporal as well.

[00:42] *** lkk- joined
[00:43] <TimToady> you could try exporting from a class; dunno if rakudo supports that yet though (a class is supposed to "do" module...)

[00:43] <frew> moritz_: hey, I saw that you ported (or are porting) CGI::Application

[00:44] <frew> moritz_: you might want to port at least the basic parts of Plack

[00:44] <sorear> yay it's TimToady

[00:44] <sorear> diakopter: reping

[00:50] <supernovus> TimToady: Thanks, I will try that and see if the current rakudo supports it.

[00:51] <supernovus> I'm guessing subs in roles don't get merged in classes that do those roles?

[00:56] *** cls_bsd joined
[00:57] *** masonkramer joined
[00:58] *** ash_ joined
[01:03] *** songmaster joined
[01:08] <supernovus> Well, using our sub in a role worked. I'm out for dinner, but soon Temporal will have working validation on the parameters of new()

[01:09] *** supernovus left
[01:14] *** whiteknight left
[01:30] <dukeleto> New blog post about PL/Parrot and PL/Perl6: http://leto.net/dukeleto.pl/2010/06/rakudo-perl-6-in-your-postgresql-database.html

[01:40] *** supernovus joined
[01:57] <supernovus> Hmm, I'm not too familiar with how the core setting works, but if you have an 'our sub' in a class, role or module should it leak through to the global namespace?

[01:59] <ashleydev> Is any of the viv / gimmy5 / STD bootstrapping on Perl 5 using Regexp::Grammars?

[02:00] <ash_> ashleydev: no, i don't believe they do 

[02:00] <ashleydev> hmm

[02:01] <ashleydev> i just discovered that and have almost wet myself... I'm shocked to have found it by searching CPAN rather than through the usual news channels...

[02:01] <ashleydev> (I wasn't looking for it, but for something else actually and have spend the last hour reading the doc)

[02:06] <[Coke]> I only heard about it because Damian just showcased it at YAPC.

[02:06] <[Coke]> so it's not just you. =-)

[02:07] <ashleydev> bummed I missed YAPC, and I didn't see any blogs talking about it yet... I googled it and the only ref I saw was for OSCON (future)

[02:07] <ashleydev> what was the response at YAPC?

[02:09] *** agentzh joined
[02:16] <[Coke]> something akin to "OOOOH IT'S DAMIAAAAAN"

[02:16] <ashleydev> i still can't believe it... WOW

[02:16] <pmichaud> exit

[02:16] <pmichaud> ww

[02:17] <sorear> ashleydev: viv implements a -real- Perl 6 parsing engine; it'

[02:17] <sorear> s far more complete than even the one in rakudo

[02:17] <sorear> we haven't been using the Perl 5 regex engine for a couple weeks now

[02:19] *** supernovus left
[02:19] <ashleydev> so it's perl 5 implementation of a perl 6 grammar engine?

[02:19] <ashleydev> (viv that is)

[02:22] <sorear> yes and no

[02:22] <ashleydev> where can I get viv?

[02:22] <sorear> viv is a compiler; it takes in Perl 6 and generates Perl 5 with a similar structure

[02:22] <sorear> the grammar engine is in Cursor and CursorBaser

[02:22] <sorear> src/perl6 in the pugssvn

[02:22] <ashleydev> k

[02:23] <sorear> note that viv relies on STD.pmc in order to parse STD.pm6; it's a bit bootstrapped

[02:24] <ashleydev> so is it aiming to be an implementation of perl 6?

[02:25] <ashleydev> or just a parsing engine? -- I keep seeing people test syntax with the std: bot here.. but is viv aiming to be more than that?

[02:29] <sorear> viv/Cursor is a sandbox where we play with parsing technology on a mature VM

[02:39] <TimToady> .oO(mature == "for mature audiences only")

[02:40] <ashleydev> so is that sandbox for proving via real world use the Perl6 grammar syntax?

[02:42] *** TiMBuS joined
[02:43] <tylercurtis> sorear: is there a way to use viv outside of pugs/src/perl6/? When I try, I get "cannot open unicode maps from ./lib . : No such file or directory" as an error.

[02:44] *** justatheory joined
[02:45] <sorear> tylercurtis: viv needs to find syml/CORE.lex.store in $STD5PREFIX, uniprops in $PERL6LIB, and RE_ast.pm et al in $PERL5LIB

[02:45] <sorear> tylercurtis: try running 'make dist', the files will be automatically sorted

[02:48] <tylercurtis> sorear: thanks. I'll try that once I finish what I'm doing.

[02:55] <sorear> TimToady: After calling .Bool, how does Perl 6 know if the return value of that is true or false?

[03:02] *** jaldhar joined
[03:09] *** jaldhar left
[03:09] *** jaldhar joined
[03:09] *** agentzh left
[03:13] <ash_> doesn't .Bool --> Bool? 

[03:15] <sorear> Given a Bool, can I just *assume* it's either Bool::True or Bool::False?

[03:15] *** agentzh joined
[03:16] <lue> how can I test if a variable is rw?

[03:16] <pmichaud> latest thinking has been that Bool  is defined as    enum bool Bool <True False>

[03:17] <pmichaud> (although jnthn++ and I aren't sure that's going to hold up)

[03:17] <sorear> How is bool defined?

[03:17] * lue sorta likes the sound of enum

[03:17] <pmichaud> bool is a native type, like int

[03:17] * sorear is just now trying to figure out how to make enum work

[03:17] <pmichaud> in general, bool has been described as a bit1

[03:18] <pmichaud> sorear: yeah, there's some unclear aspects of enums at the moment, at least for jnthn++ and I

[03:18] <lue> is it possible to use filetest operators on a variable to test for rw/ro?

[03:19] *** felliott joined
[03:19] <ash_> lue: yes

[03:20] <ash_> rakudo: my $a = '/etc/passwd'; say $a ~~ :r 

[03:20] <p6eval> rakudo 7df2c2: OUTPUT¬´Method 'r' not found for invocant of class 'Str'‚ê§  in 'Enum::ACCEPTS' at line 4488:CORE.setting‚ê§  in 'infix:<~~>' at line 322:CORE.setting‚ê§  in main program body at line 11:/tmp/btUNrXWpTJ‚ê§¬ª

[03:20] <tylercurtis> pmichaud: are all NQP regexes isa Regex::Method or a subclass?

[03:21] <pmichaud> tylercurtis: checking

[03:21] <lue> no, to test if the variable itself is rw/ro.

[03:21] <ash_> rakudo: my $a = '/etc/passwd'; say $a ~~ :e

[03:21] <p6eval> rakudo 7df2c2: OUTPUT¬´1‚ê§¬ª

[03:21] <ash_> oh

[03:21] <ash_> hmm

[03:22] <pmichaud> tylercurtis: only those that are being used in rvalue (non-void) context

[03:22] <sorear> pmichaud: I need to pick your brain on just how Perl 6 lists are supposed to work

[03:23] <pmichaud> lue: there's been speculation that testing for ro-ness would be handled by a role, or some other aspects of a trait

[03:23] <pmichaud> sorear: I'll answer as best I can :-)

[03:24] <lue> because I noticed that := already has a definition in some P6 (well, it's just a die statement, but still), and thought of coding there.

[03:24] <sorear> lue: in niecza you can test if a variable is read-only using VAR($x).readonly, as described in S06

[03:24] <pmichaud> tylercurtis: NQP doesn't wrap all regexes in Regex::Method objects.  I suppose it could do that.

[03:24] <sorear> (actually you can't because the parser isn't written yet, but that's a SMOP)

[03:25] <tylercurtis> pmichaud: if I'm understanding you correctly, any regex that got passed as a function parameter would be in non-void context and thus would be a Regex::Method?

[03:25] <pmichaud> tylercurtis: correct.

[03:26] <pmichaud> tylercurtis: that's how we can get .match and other methods on the regex object itself.

[03:26] <tylercurtis> pmichaud: okay. Thanks.

[03:28] <sorear> pmichaud: so, uh.  What are the important types for lists?

[03:29] <lue> Well, I think something like $a ~~ :rw is appropriate.

[03:29] <pmichaud> sorear: at the moment, Rakudo has a base List type

[03:30] <pmichaud> well, let me back up a bit further

[03:30] <pmichaud> here's a list of classes involved in lists and iterators

[03:30] <pmichaud> Iterable - things that support .iterator .  Also the base class for things that can flatten in list context

[03:30] <sorear> I'm trying to implement lists in niecza from first principles

[03:30] <pmichaud> s/flatten/interpolate/

[03:31] <sorear> I have the mechanics of scalar containers fully implemented and I have native CLR arrays/dictionaries/etc

[03:31] <pmichaud> List - the basic lazy list type.  A list is simply a list of objects, which can be containers and/or values

[03:31] <pmichaud> Array - a List where each element is its own scalar container.

[03:31] <sorear> What, mechanistically, is "list context"?

[03:32] <pmichaud> in general, list context is created by  &infix:<,>

[03:32] <pmichaud> wait, that's not right.

[03:33] * sorear is currently implementing ClassHOW, but wants a head start on understanding lists

[03:33] <pmichaud> &infix:<,> is used to create a Parcel.  flattening list context on a parcel creates a List where list elements of the Parcel are considered to be "interpolated" into the overall list

[03:34] <pmichaud> so, with    (1, 2, @a, 4).flat    the elements of @a are considered to be part of the list

[03:34] <sorear> I have this vague understanding that contexts in Perl 6 are mediated by methods

[03:34] <sorear> ie .Bool

[03:35] <pmichaud> I'm not convinced that's the case (more)

[03:35] <sorear> so... the compiler automatically calls .flat on values in some place?

[03:35] <sorear> ok...

[03:35] <sorear> (more) ack

[03:35] *** agentzh left
[03:35] <pmichaud> about a year ago there was a push to try to get all of the contexts to correspond to types, but that hasn't worked out

[03:35] <pmichaud> but yes, the compiler automatically calls .flat on values in some places

[03:36] <pmichaud> for example, assignment to an array variable imposes .flat

[03:36] <pmichaud> also, when a Parcel is converted to a Seq (e.g., in item context), it's flattened.

[03:36] <sorear> What constitutes item context?  When is .item called?

[03:37] <pmichaud> it can be called explicitly; it's also called implicitly when assigning a value to a scalar container

[03:37] <pmichaud> my $x = (1, 2, @a);     imposes item context on the parcel

[03:37] <pmichaud> rakudo:  say (1,2,3).WHAT;  my $x = (1,2,3);  say $x.WHAT;

[03:37] <p6eval> rakudo 7df2c2: OUTPUT¬´Parcel()‚ê§Seq()‚ê§¬ª

[03:39] <pmichaud> for Parcels, .item returns a Seq containing the values of the Parcel (flattened)

[03:39] <pmichaud> for Iterables, .item returns a non-flattening reference to the Iterable

[03:40] <pmichaud> for most everything else (that I've encountered thus far), .item returns self

[03:42] <sorear> What does a non-flattening reference look like?

[03:42] <sorear> What about binding?

[03:42] <pmichaud> in Rakudo, it's an ObjectRef with the 'scalar' property set.  (I'm expecting to change the property name to 'item' at some point)

[03:42] <pmichaud> but basically, flattening behavior does not appear to be purely a property of the type of a value

[03:42] <pmichaud> i.e., if we have

[03:43] <pmichaud> my @a = 1,2,3;  my $b := @a;    say (4, 5, @a).elems;   say (4, 5, $b).elems;

[03:43] <sorear> I can do (in Mu) the equivalent of method item ($self is rw:) is rw { $self }, in niecza

[03:43] <pmichaud> even though @a and $b are the same object, the first say will report 5 while the second say will report 3

[03:43] <sorear> rw invocants are possible as a quirk of my model

[03:44] <sorear> I'm thinking this will come in handy here

[03:44] *** dimid joined
[03:44] <pmichaud> sure,  Rakudo defines  Mu.item as { self }

[03:44] <sorear> does that work for rw?

[03:45] *** sftp joined
[03:45] <pmichaud> rakudo isn't yet distinguishing is rw, but yes, it would work for that.

[03:45] <pmichaud> (i.e., rakudo tends to treat all methods as 'is rw' at the moment)

[03:45] <pmichaud> (if the method returns a container)

[03:48] <sorear> Why is self a container?

[03:48] <pmichaud> it isn't always a container

[03:48] <sorear> I thought all methods in Rakudo were delegated to the value

[03:48] <pmichaud> oh, that's a good point.

[03:49] <pmichaud> you're correct, they are, so in   Mu.item  it's currently returning the value

[03:49] <pmichaud> anyway, I suspect that in general using .item should remove any containers from the invocant

[03:49] <sorear> How does binding to $x is rw work, if .item is called?

[03:49] <pmichaud> ah, that.

[03:50] *** skids joined
[03:50] <pmichaud> I suspect that binding isn't currently calling .item.    checking

[03:50] <sorear> in niecza, there is no such thing as container(s)

[03:50] <sorear> every variable has one and only one container

[03:50] <sorear> it feels like a much nicer model

[03:50] <pmichaud> rakudo: sub xyz($a) { say $a.WHAT; };   xyz((3,4,5));

[03:50] <sorear> I'm trying to keep it

[03:50] <p6eval> rakudo 7df2c2: OUTPUT¬´Parcel()‚ê§¬ª

[03:51] <pmichaud> looks like Rakudo isn't imposing .item on binding yet

[03:51] <sorear> ok.

[03:51] <pmichaud> in rakudo, every variable also has only one container, I think.

[03:51] <sorear> Would it be possible to do away with 'scalar' by instead saying that the compiler doesn't .flat $-variables?

[03:51] <sorear> When exactly is .flat called?

[03:52] <frew> so Mu is what p5 would call UNIVERSAL right?

[03:52] <pmichaud> when something is put into flattening context

[03:53] <pmichaud> ...which somewhat answers your question -- the compiler cannot statically determine flattening context

[03:54] <pmichaud> (it might be able to do so if it has complete knowledge of all possible signature binds... but in the general case that's not always available)

[03:55] <sorear> What creates flattening context?

[03:55] <pmichaud> Arrays, Seq, and '&flat'

[03:55] <pmichaud> (there might be more -- that's what I know of at the moment)

[03:55] <sorear> What is '&flat' and where is it used?

[03:56] <pmichaud> it's a contextualizer

[03:56] <pmichaud> along with &list, &slice, and &item

[03:57] <pmichaud> (I'm not sure that &list is useful yet.)

[03:57] <pmichaud> oh, and &hash

[03:57] <sorear> What stops the return value of &flat from being contextualized again?

[03:57] <pmichaud> nothing.

[03:58] <pmichaud> that's even normal (more)

[03:58] <pmichaud> for example, with    my $x = (1,2,@a);

[03:58] <pmichaud> what happens is that a Seq is created that imposes flat context on the Parcel, and then item context is imposed on the Seq

[03:59] <pmichaud> so if I had

[03:59] <sorear> What is the difference between foo(|@arr) and foo(|$arr)?

[04:00] <pmichaud> my @a = (1, 2, 3, (item flat @c, @d));    then @a would end up with 4 elements, the last of which is a Seq of the flattened elements of @c and @d

[04:01] <pmichaud> it's generally more interesting to think of flat in terms of the return value of various parcel-generating operators

[04:01] <pmichaud> as in

[04:01] <pmichaud> my @a = (1, 2, 3, (item flat @c Z @d))

[04:01] <lue> afk

[04:01] <pmichaud> here, flat imposes flattening context on the results of @c Z @d, and item context converts that to a Seq

[04:04] <pmichaud> I'm not sure about the difference between  foo(|@arr) and foo(|$arr)

[04:05] <pmichaud> jnthn++ might know.

[04:05] <pmichaud> I mean, I know what foo(|@arr) does, but foo(|$arr)  seems a bit weird.

[04:06] *** skids left
[04:06] <pmichaud> oh, wait.  I know.

[04:06] <pmichaud> in any case,  foo(|$arr)  basically does $arr.Capture

[04:07] <pmichaud> so it's up to the .Capture method to return a Capture object that then gets used in the binding

[04:09] <sorear> What happens after my $x := @y; my @z := $x; for (@z) { .say } 

[04:09] <sorear> ?

[04:10] <sorear> What's the difference between &flat($a) and $a.flat?

[04:10] *** chronniff joined
[04:10] *** felliott left
[04:11] *** chronniff left
[04:12] <ingy> is there a text that describes the difference between token rule and regex in grammars?

[04:12] <sorear> S05

[04:12] <ingy> where

[04:12] <pmichaud> sorear: @z gets flattened.

[04:12] <ingy> I just read it

[04:13] <pmichaud> ingy: regex is a normal regex -- it automatically backtracks on various quantifiers

[04:13] <pmichaud> ingy:  token is a regex where backtracking is disabled by default

[04:13] *** kaare joined
[04:13] <pmichaud> ingy:  rule is a token (backtracking disabled) where whitespace in the pattern corresponds to intertoken whitespace in the match

[04:14] *** kaare is now known as Guest36062

[04:14] <pmichaud> rakudo:  say  'aaaaa' ~~ regex { a* a }   # matches

[04:14] <p6eval> rakudo 7df2c2: OUTPUT¬´aaaaa‚ê§¬ª

[04:14] <pmichaud> rakudo:  say  'aaaaa' ~~ token { a* a }   # doesn't match

[04:14] <p6eval> rakudo 7df2c2: OUTPUT¬´‚ê§¬ª

[04:15] <pmichaud> sorear: the difference between &flat($a) and $a.flat is that the former flattens its parcel while the latter returns the flattened version of $a

[04:16] <ingy> pmichaud: thank you

[04:16] <pmichaud> rakudo:  say "you're welcome" ~~ rule { \S* \S* }

[04:16] <p6eval> rakudo 7df2c2: OUTPUT¬´you're welcome‚ê§¬ª

[04:16] <pmichaud> note that in the rule I didn't have to specify anything to match the whitespace

[04:17] <ash_> does rule chomp front and back? 

[04:17] <ingy> rakudo:  say "you're      welcome" ~~ rule { \S* \S* }

[04:17] <p6eval> rakudo 7df2c2: OUTPUT¬´you're      welcome‚ê§¬ª

[04:17] <pmichaud> rakudo:  say "    you're  \n   welcome     " ~~ rule { \S* \S* }

[04:17] <p6eval> rakudo 7df2c2: OUTPUT¬´    you're  ‚ê§   welcome     ‚ê§¬ª

[04:18] <ingy> rakudo:  say "you'rewelcome" ~~ rule { \S* \S* }

[04:18] <p6eval> rakudo 7df2c2: OUTPUT¬´you'rewelcome‚ê§¬ª

[04:18] <sorear> pmichaud: so, if $a is the Seq <a b c>, my @b := $a results in @b.elems == 3, but my @b = $a results in @b.elems == 1?

[04:18] <pmichaud> + is more interesting here

[04:18] <pmichaud> rakudo:  say "you'rewelcome" ~~ rule { \S+ \S+ }  # fails

[04:18] <p6eval> rakudo 7df2c2: OUTPUT¬´‚ê§¬ª

[04:19] <ingy> ah

[04:19] <pmichaud> sorear: correct.

[04:19] <pmichaud> ingy: rule { \S+ \S+ }  is the same as   token { <.ws> \S+ <.ws> \S+ <.ws> }

[04:19] <ingy> ahrakudo:  say "you're  welcome" ~~ rule { \S+ \S+ }

[04:20] <ingy> rakudo:  say "you're  welcome" ~~ rule { \S+ \S+ }

[04:20] <p6eval> rakudo 7df2c2: OUTPUT¬´you're  welcome‚ê§¬ª

[04:20] <ingy> pmichaud: maybe not :)

[04:20] <pmichaud> ?

[04:20] <ingy> isn't that <.ws>+

[04:20] <pmichaud> <.ws>  already allows for multiple whitespace characters

[04:21] <ingy> I see

[04:21] <pmichaud> it's basically defined as   { <!ww> \s* }

[04:21] * ingy backs down

[04:21] <pmichaud> where <ww> is true when in the middle of a word

[04:21] <ingy> ;)

[04:21] <pmichaud> (i.e., between two word characters)

[04:22] <pmichaud> so, <.ws> requires at least one space between two word characters, and zero or more spaces anywhere else

[04:22] <ingy> ETOOMUCHPOWER!!

[04:22] <ingy> ;)

[04:22] * ingy gets back to ascending the learning curve

[04:23] <pmichaud> I should write a canonical blog post about regex, token, and rule -- it's a FAQ

[04:23] <pmichaud> afk for 15 -- walking furry canine creature that seems to inhabit my house

[04:31] *** ash_ left
[04:35] *** davidfetter left
[04:45] *** tedv left
[04:57] *** Guest36062 is now known as kaare_

[05:06] <kaare_> pmichaud: Doesn't the book contain a canonical chapter?

[05:06] * kaare_ downloaded book and will bring on vacation

[05:25] *** LionMadeOfLions joined
[05:26] *** justatheory left
[05:41] <sorear> pmichaud: What I still don't quite get is binding to @ variables

[05:42] <moritz_> it explains the difference

[05:42] <sorear> with $ variables, it is a universal truth that my $a := X1; $a = X2  means (X1).item = X2

[05:43] <sorear> but the identity does not seem to hold with @a and .flat

[05:57] *** cono joined
[05:59] *** ram__ joined
[05:59] *** ram__ left
[06:03] *** uniejo joined
[06:05] *** mberends joined
[06:14] <mberends> for MiniDBD::Pg, it's hard to choose between Parrot/Pg.pir and Zavolaj to reach the underlying libpq. There may be a way to have the cake and eat it, by including code for both options and then switching the module one way or another. That looks like a job for a macro. hmm

[06:20] <sorear> After my $x; my @y := $x;  what do fetches and stores to @y do?

[06:23] <mberends> just a guess, but would @y[0] be bound to $x, and @y[1] and up be bound to an anonymous array?

[06:25] <mberends> it looks like a terribly confusing mess :/

[06:27] <kaare_> mberends: Too me it looks like Zavolaj has a more fine grained access to libpg. 

[06:27] <kaare_> But that's without having looked very closely at it.

[06:30] <mberends> kaare_: working with Zavolaj is nice, because it points directly into native libraries. Its main drawback is that it's an external dependency that needs to be installed. Rakudo * will bundle it though.

[06:31] <moritz_> mberends: Pg.pir doesn't (yet) give access to the error messages yet

[06:33] <moritz_> and I think the right approach would be to have separate DBD modules for each approach

[06:33] <mberends> moritz_: ah, didn't see that yet. The libpq API is so friendly though, getting error messages should be very easy.

[06:34] <moritz_> mberends: should I push my not-yet-quite-workiing Pg.pir based DBD module?

[06:34] <kaare_> I would be happy to work on a DBD::PgPir version, except my vacation makes me unstable :-)

[06:35] <moritz_> that's fine

[06:35] <mberends> moritz_: yes, go for it!

[06:35] <kaare_> - and the fact that Pg.pir needs some updating.

[06:36] <mberends> kaare_: the name PgPir is useful for having cake and eating it :)

[06:37] <moritz_> one thing I'd like to improve over the DBI interface is passing around paramaters in DBI.connect as a hash instead of a string

[06:37] <moritz_> at least optionally

[06:37] <moritz_> letting the user do the quoting seems wrong

[06:38] <mberends> moritz_: as long as it's optional. I'd like to keep the P5->P6 migration path as easy as possible.

[06:39] <moritz_> understood.

[06:41] <kaare_> It is _so_ wrong. But a lot of these things are there because of age. DBI 2.0 should be designed from new. MiniDBI is OK as a 1:1 from P5

[06:42] <kaare_> _someone_ with Parrot knowledge and tuits should look at Pg.pir (or postgres.pir?) and http://www.postgresql.org/docs/9.0/static/libpq.html

[06:42] <moritz_> pushed MiniDBD::PgPir

[06:43] <mberends> moritz_++

[06:44] *** hugme joined
[06:45] * kaare_ pulled

[06:46] <mberends> kaare_: yes, that's the Postgresql manual I used to make a Zavolaj client. I'm currently low on Parrot tuits, getting perldancer into P6 matters more to me ;)

[06:49] <kaare_> mberends: I was hoping maybe dukeleto *hint hint* ;-)

[06:51] <moritz_> I'm testing a last_error method in Pg.pir right now

[06:51] <mberends> kaare_: yes :) I like his blog posting (of course;)

[06:56] <mberends> the Postgresql C API was so much easier to work with than the MySQL one, because the parameters passed and returned were simpler. Conversely, MySQL probably performs slightly faster because it passes more information per call.

[06:57] <sorear> pmichaud: Are the current list-context tests all correct?

[06:58] <kaare_> moritz_: I get Typename MiniDBD::StatementHandle must be pre-declared to use it with does at line 3, near "{\n    has "

[07:01] <kaare_> I guess it's because MiniDBI isn't installed here. I hoped that a export PERL6LIB=lib would help, but no.

[07:01] <moritz_> I guess I have to 'use MiniDBD'

[07:01] <moritz_> yep

[07:01] *** mj41_ joined
[07:01] <moritz_> fix pushed

[07:01] *** [particle]1 joined
[07:01] <kaare_> sorry. Forgot you mentioned it's untestet :-)

[07:02] *** p6eval joined
[07:02] *** songmaster left
[07:02] *** PZt left
[07:02] *** stef_ left
[07:02] *** opx^away left
[07:03] *** mj41_ is now known as mj41

[07:03] <kaare_> I changed the Makefile to include PgPir. Is it OK to push?

[07:03] <moritz_> sure

[07:04] *** songmaster joined
[07:04] *** PZt joined
[07:04] *** stef_ joined
[07:04] *** opx^away joined
[07:04] *** felipe joined
[07:04] *** thepler joined
[07:04] *** tomaw joined
[07:04] *** Gothmog_ joined
[07:05] *** felipe left
[07:16] *** rgrau joined
[07:20] *** cuppe joined
[07:21] *** cuppe_ joined
[07:29] <songmaster> \o/ My p6 sudoku solver works!

[07:32] <mathw> \o/

[07:35] *** songmaster left
[07:40] *** agentzh joined
[07:43] *** Ross joined
[07:58] *** wallberg joined
[07:59] *** felipe joined
[08:00] *** timbunce joined
[08:14] *** cygx joined
[08:26] *** tadzik joined
[08:26] <moritz_> rakudo: say @*ARGS.perl

[08:26] <p6eval> rakudo 7df2c2: OUTPUT¬´[]‚ê§¬ª

[08:31] *** dakkar joined
[08:32] *** Ross left
[08:32] <pugssvn> r31521 | moritz++ | [t/spec] test @*ARGS 

[08:33] <mathw> moritz_: I must thank you again for introducing me to Wise Guys. Wenn Sie Tantzt is currently the only thing keeping me attached to my last tenuous thread of sanity.

[08:34] <moritz_> wise guys and sanity. /me chuckles :-)

[08:34] <IllvilJa> mathw: isn't sanity overrated? GROSSLY overrated...?

[08:35] <dalek> rakudo: 3d2cb82 | moritz++ | t/spectest.data:

[08:35] <dalek> rakudo: run test file for @*ARGS

[08:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3d2cb821ff7e14f3a06e6556a68d649e6cbc30c1

[08:35] <mathw> IllvilJa: It depends which bit of sanity you lose...

[08:35] <mathw> Right now I'm about ready to start throwing people out of windows and through floorboards

[08:36] <IllvilJa> mathw: please don't.  It messes up the windows and floorboards very badly...

[08:36] <mathw> I know

[08:37] <mathw> I doubt my employer would be very happy with the damage to the facilities

[08:43] *** molaf joined
[08:46] *** thebird joined
[08:49] *** molaf left
[08:52] *** masak joined
[08:52] <masak> oh hai, #perl6!

[08:52] <phenny> masak: 30 Jun 18:39Z <moritz_> tell masak http://github.com/moritz/modules.perl6.org - my approach at phasing out the web/ folder from proto

[08:53] <masak> moritz_++

[08:53] <masak> I like 'modules'. it's not ideal, but it's far better than 'proto'.

[08:54] *** Trashlord left
[08:55] *** azert0x joined
[08:56] *** azert0x left
[08:57] *** azert0x joined
[08:57] *** azert0x left
[08:57] <mathw> oh hai masak

[08:57] <sorear> Hello! Masak!

[08:59] * mathw enjoys a brief moment of seeing the SVN log as rather like 1080p CCTV footage of somebody breaking into a bank vault

[09:01] *** azert0x joined
[09:01] *** azert0x left
[09:01] *** lkk- left
[09:02] *** azert0x joined
[09:02] *** azert0x left
[09:03] <masak> rakudo: say +Failure

[09:03] <p6eval> rakudo 7df2c2: OUTPUT¬´Use of uninitialized value in numeric context‚ê§0‚ê§¬ª

[09:05] *** azert0x joined
[09:10] *** tylercurtis left
[09:11] *** silug joined
[09:25] <sorear> yay, niecza has a working-seeming rudimentary ClassHOW now

[09:28] *** cygx left
[09:28] <mathw> sorear++

[09:30] *** mikehh joined
[09:37] <sorear> niecza has gotten to the point where typing in ASTs to test is getting tiring, so tomorrow I'm going to try and hook it up to STD.pm6

[09:38] <sorear> STD.pm6 will probably need a few changes for this to work; niecza is AFAIK the first compiler to be directly connected to STD

[09:38] <sorear> (viv, mildew, and elf work by processing match trees, not providing action methods, which is what I want to try and do)

[09:40] <mberends> sorear: very nice. Mildew also ran STD.pmc in-process afair, but yes, sharing data only at the tree level

[09:41] *** sorear sets mode: +o mberends

[09:41] <sorear> mberends: did mildew or elf define any extensions to Perl 6?

[09:42] <sorear> niecza is going to have to, since I'm trying to define my setting in extended-Perl-6

[09:42] <sorear> (you can't well define a class that is its own metaclass, to name an egregious example)

[09:42] <mberends> sorear: no, nothing beyond STD.pm6 language

[09:45] <masak> I'm glad Perl 6 is among the answers here: http://stackoverflow.com/questions/23930/factorial-algorithms-in-different-languages

[09:45] * sorear out

[09:53] <mberends> hi masak, I like their lolcode answer too :)

[09:53] <masak> :)

[09:56] <jnthn> o/

[09:56] *** sorear sets mode: +o masak

[09:56] <masak> \o

[09:57] *** sorear sets mode: +vv hugme p6eval

[09:57] *** sorear sets mode: +oo [particle]1 ingy

[09:58] *** sorear sets mode: +v IllvilJa

[09:58] *** sorear sets mode: +v ilogger2

[09:58] *** sorear sets mode: -v IllvilJa

[10:07] <bbkr> Is there any direct replacement of $. from P5? or do I have to use ZIP operator like "for .lines Z 1 .. * -> $line_content, $line_number { ... }" ?

[10:09] <mathw> masak: Awesome, they have it in Inform 7 as well :)

[10:09] <mathw> "To decide what number is the factorial of (n - a number):"

[10:13] <masak> the more I learn about Inform 7, the more it looks like a complex incarnation of HyperTalk.

[10:14] <mathw> It's bizarre

[10:14] <mathw> rather fun from time to time

[10:14] <mathw> not to mention that it's the only language in which I've ever successfully written a game :)

[10:16] *** pmurias joined
[10:18] <pugssvn> r31522 | pmurias++ | [mildew] [smop] say 7 works with an installed SMOP 

[10:18] <jnthn> But what about "say 42"?

[10:19] * pmurias checks ;)

[10:19] <phenny> pmurias: 30 Jun 18:18Z <sorear> tell pmurias pong.

[10:19] <pmurias> jnthn: works too

[10:20] <jnthn> \o/

[10:20] <jnthn> ;)

[10:25] <masak> lunch &

[10:27] * pragma_ checks ;)

[10:28] <pragma_> oh, it was some on-next-visibility-send-memo thing.

[10:29] *** Su-Shee joined
[10:29] <Su-Shee> good morning everyone. 

[10:29] <pragma_> what's good about it?

[10:30] <Su-Shee> everything you make good of it. ;)

[10:35] *** agentzh left
[10:40] *** araujo joined
[10:42] *** clintongormley joined
[10:45] <pmurias> pragma_: on-next-visibility-send-memo thing?

[10:46] *** tadzik left
[10:46] <pragma_> pmurias: yes.

[10:49] <pmurias> which thing did you refer to?

[10:51] <pragma_> phenny's thing.

[10:52] * pmurias understands

[10:52] <pmurias> pragma_: i checked if "say 42" worked in mildew

[10:59] *** tadzik joined
[11:06] *** amkrankruleuen joined
[11:09] <sorear> pmurias: you're very lucky I can't sleep tonight.

[11:09] <sorear> is there any chance you could be online at a time other than 4am US west coast time?  Or should we take this to email?

[11:10] <sorear> bbkr: try for .lines.kv -> $n, $text { ...

[11:10] <pmurias> checks what does 4am translate to in his timezone

[11:11] * arnsholt is occasionally convinced that everyone should just move to Swatch beats

[11:11] <bbkr> sorear++ :) I always forget there is kv for arrays available now :)

[11:13] <pmurias> sorear: i'm in UTC+2

[11:13] <pmurias> sorear: what's the current time in your place?

[11:14] <pmurias> s/time/hour/

[11:15] <sorear> 4:15

[11:18] <arnsholt> California time, isn't it?

[11:19] <pmurias> sorear: i could be on the channel any time while i'm awake (uni ended and i don't have anything planned for this week)

[11:22] <sorear> arnsholt: I don't expect random Internet people with other-side-of-the-world timezones to know where California is

[11:22] <arnsholt> Yeah, that's reasonable. I ask primarily so that I can place you on my mental people-time-map

[11:23] <arnsholt> For some reason I find it easier to remember California or New York than -9 or -6 hours

[11:30] <pmurias> sorear: are you awake enough to answer STD questions?

[11:30] <sorear> maybe

[11:30] <sorear> if not try again in ~14 hours

[11:33] <pmurias> what would it take to make STD installable?

[11:34] <sorear> if by "installable" you mean "like any other perl module" - that would require the CPAN folks to figure out what data files are

[11:35] <sorear> if you're willing to assume more of the issues yourself, you can use 'make dist', install the result of that somewhere, then set PERL5LIB, PERL6LIB, and STD5PREFIX to the right paths

[11:35] <pmurias> you can install data file with File::ShareDir

[11:35] <sorear> note: I don't recommend installing the PERL5LIB files into the system PERL5LIB

[11:36] <sorear> STD and Cursor are reserved module names in P6, not in P5

[11:38] <sorear> I'll have to check out File::ShareDir.  When I'm awake.

[11:39] <pmurias> ok

[11:39] <amkrankruleuen> ls

[11:40] <pmurias> sorear: if you need something done to help with STD being installable tell me

[11:40] <pmurias> sorear: mildew needs an installable STD

[11:41] <masak> std: STD, Cursor;

[11:41] <p6eval> std 31522: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared names:‚ê§        'Cursor' used at line 1‚ê§  'STD' used at line 1‚ê§Check failed‚ê§FAILED 00:01 112m‚ê§¬ª

[11:41] <masak> TimToady: ^

[11:42] <masak> sorear: it'd be very nice to be able to simply and reliably install STD as a module.

[11:43] <bbkr> are there any differences between Perl6::Grammar available in Rakudo and STD.pm from Pugs? I'm thinking of nasty mutation testing: generate a lot of random trash like "{.{}}#@" and run it through STD.pm and if passes then on Rakudo eval_lives_ok. so we may find rare differences between STD.pm and Rakudo

[11:44] <masak> bbkr: I had a similar idea (lots of random trash) for Rakudo once. I never realized it. Rakudo has gotten a lot more stable since.

[11:44] *** hugme left
[11:44] <masak> bbkr: I say go for it. if nothing else, you'll get a cool blog post out of it.

[11:45] <masak> should be *fairly* simple to set up with a shell script, methinks.

[11:45] *** pugssvn joined
[11:46] *** pmichaud joined
[11:46] *** Juerd joined
[11:46] <bbkr> masak: yes, it's simple. I plan to do it when I finish RT queue checking for Kiev build, probably weekend. can I match against Perl6::Grammar to achieve the same result as on "std" bot here?

[11:47] <bbkr> rakudo: say Perl6::Grammar.parse('say 1;')

[11:47] *** clintongormley left
[11:47] <p6eval> rakudo 3d2cb8: OUTPUT¬´say 1;‚ê§¬ª

[11:47] <bbkr> rakudo: say Perl6::Grammar.parse('blablablabla')

[11:47] <colomon> rakudo: say Perl6::Grammar.parse('say 1;').perl

[11:47] <p6eval> rakudo 3d2cb8: OUTPUT¬´blablablabla‚ê§¬ª

[11:48] <p6eval> rakudo 3d2cb8: OUTPUT¬´Method 'perl' not found for invocant of class 'Regex;Match'‚ê§  in main program body at line 11:/tmp/eCBml2ykRT‚ê§¬ª

[11:48] <masak> bbkr: no, Rakudo's Perl6::Grammar is simply the parser in Rakudo.

[11:48] *** clintongormley joined
[11:48] <masak> bbkr: to use STD, you need to use STD.pm6.

[11:48] <arnsholt> rakudo: Perl6::Grammar.parse('oogabooga') && say $/ ?? "pass" !! "fail"

[11:48] <p6eval> rakudo 3d2cb8: OUTPUT¬´fail‚ê§¬ª

[11:48] <arnsholt> rakudo: Perl6::Grammar.parse('say 1;') && say $/ ?? "pass" !! "fail"

[11:48] <p6eval> rakudo 3d2cb8: OUTPUT¬´fail‚ê§¬ª

[11:48] <arnsholt> Aw. Dang =)

[11:49] <bbkr> colomon: lack of .perl on Match() already seen it in RT

[11:49] <colomon> rakudo: Perl6::Grammar.parse('say 1;') ?? "pass" !! "fail"

[11:49] <p6eval> rakudo 3d2cb8:  ( no output )

[11:49] <colomon> rakudo: say Perl6::Grammar.parse('say 1;') ?? "pass" !! "fail"

[11:49] <p6eval> rakudo 3d2cb8: OUTPUT¬´pass‚ê§¬ª

[11:50] <colomon> I don't think .parse sets $/

[11:50] <arnsholt> Oh, right

[11:51] *** Util joined
[11:54] <bbkr> masak: do you know where can I get the code for std bot? I cannot just use STD.pm6 in Rakudo afaik, so I need to check how it works.

[11:54] <masak> bbkr: STD.pm6 isn't in Rakudo. it's in the repo formerly known as the Pugs repo.

[11:54] <masak> bbkr: in src/perl6

[11:54] <sorear> No Perl 6 implementation can run STD.pm6

[11:55] <bbkr> http://svn.pugscode.org/pugs/src/perl6/std - foud it :)

[11:55] <sorear> So if you're looking to "use STD" - give up now

[11:55] <bbkr> found*

[11:57] *** ruoso joined
[11:57] <pmurias> ruoso: hi

[11:58] *** cono left
[12:00] *** bluescreen joined
[12:00] *** bluescreen left
[12:00] *** bluescreen joined
[12:01] *** bluescreen is now known as Guest93363

[12:04] *** cono joined
[12:06] *** kaare_ left
[12:11] <ruoso> hi  pmurias 

[12:13] <pmurias> ruoso: say 42 works with the installed SMOP, know fixing the bitrot on some tests

[12:13] <ruoso> pmurias, that's awesome...

[12:14] <ruoso> it should then be close to get "use v6-mildew" then ;)

[12:17] <pmurias> i need to make STD installable and fix the bit rot so that Mildew builds core before that can happen

[12:17] <pmurias> * CORE

[12:30] <ruoso> Maybe we can convince TimToady to get STD released to CPAN, instead of embedding it in mildew

[12:30] <ruoso> pmurias, ^

[12:31] *** felliott joined
[12:32] <pmurias> ruoso: working with sorear/TimToady to get STD released would be better then releasing Mildew::STD

[12:35] *** Trashlord joined
[12:37] *** cygx joined
[12:38] <ruoso> pmurias, agreed...

[12:39] *** rgrau left
[12:39] *** rgrau_ joined
[12:39] <masak> std: my $h = {}; say (%$h).keys

[12:39] <p6eval> std 31522: OUTPUT¬´ok 00:01 114m‚ê§¬ª

[12:39] <masak> rakudo: my $h = {}; say (%$h).keys

[12:39] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11‚ê§¬ª

[12:39] <pugssvn> r31523 | pmurias++ | [mildew] enable option bundling 

[12:39] <pugssvn> r31524 | pmurias++ | [mildew] fix knowhow handling, ++FRONTEND --debug ++/FRONTEND 

[12:39] * masak submits rakudobug

[12:40] <masak> rakudo: my $h = {}; (%$h)

[12:40] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Confused at line 11, near "(%$h)"‚ê§¬ª

[12:40] <masak> rakudo: my $h = {}; %$h

[12:40] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Confused at line 11, near "%$h"‚ê§¬ª

[12:40] <masak> std: my $h = {}; %$h

[12:41] <p6eval> std 31522: OUTPUT¬´ok 00:01 110m‚ê§¬ª

[12:41] <masak> alpha: my $h = {}; %$h; say "alive"

[12:41] <p6eval> alpha 30e0ed: OUTPUT¬´Symbol '%$h' not predeclared in <anonymous> (/tmp/sADQXLXV_d:10)‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[12:41] <masak> huh.

[12:41] <sorear> pmurias: next time I see TimToady, I'll pester him to find out it renaming STD to Perl6::STD is plausable

[12:41] <masak> alpha: my $h = {}; %($h); say "alive"

[12:41] <p6eval> alpha 30e0ed:  ( no output )

[12:41] <masak> :(

[12:42] <pmurias> sorear: you removed $::ORIG?

[12:43] <pmurias> sorear: VAST::Base->Str seems to complain that $ORIG is undefined

[12:47] <masak> Match.caps rocks! moritz_++

[12:48] *** Guest23195 joined
[12:50] <colomon> Match.caps?

[12:50] * colomon has been distracted by $work the last few days...

[12:50] <arnsholt> captures, I think

[12:51] <sorear> pmurias: yes... I was trying to make STD closer to reentrant

[12:52] <sorear> see viv:198

[12:54] <pmurias> sorear: i need a way to set it from mildew

[12:54] *** cuppe left
[12:55] *** cuppe_ left
[12:55] <pmurias> sorear: i shouldn't be keeping you awake, i'll change it back to an our and will work out a proper way tommorrow

[12:55] *** cuppe joined
[12:55] *** cygx left
[12:56] *** cuppe_ joined
[12:56] <pugssvn> r31525 | pmurias++ | [viv] make $ORIG a global 

[12:56] <pugssvn> r31525 | [mildew] a lot of tests pass again

[12:57] *** masonkramer left
[12:57] *** masonkramer joined
[12:58] <sorear> pmurias: um, what are you doing in mildew that you can't set it?

[13:00] *** skids joined
[13:01] <diakopter> pmurias: how goes gsoc project

[13:01] *** foodoo joined
[13:04] <pmichaud> good morning, #perl6

[13:04] <jnthn> morning, pmichaud 

[13:06] <masak> morning, pmichaud

[13:08] <sorear> good morning pmichaud

[13:08] <sorear> my $a = \( (1,2) ); my @b = 3, $a[0], 4; @b.elems ?

[13:08] <colomon> o/

[13:09] *** [particle]1 is now known as [particle]

[13:09] <masak> ECMAScript 5 has "use strict"; -- http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/

[13:10] *** sorear sets mode: +voo pugssvn pmichaud ruoso

[13:10] *** pmurias left
[13:10] <masak> perhaps not news to people, I don't know...

[13:10] *** dalek joined
[13:10] <sorear> not quite news to me, but I had occasion to reread the ecmascript spec a few weeks ago

[13:11] *** sorear sets mode: +v dalek

[13:12] *** pmurias joined
[13:13] <diakopter> strict mode in es5 is entirely to enable compiler optimizations by disallowing "highly-pessimizing" certain JS language features and enforcing several swaths of code contracts

[13:14] <diakopter> pmurias: how goes gsoc project

[13:18] *** isBEKaml joined
[13:18] <frettled> diakopter: and I suspect that is a Good Idea, considering how people maul their JS code :)

[13:18] <pmurias> diakopter: i'm behing schedule, an installed smop works, working on mildew now

[13:18] <pmurias> cycling&

[13:18] <pmurias> * behind

[13:22] <diakopter> phenny: ask pmurias since mildew depends on pugscode's STD.pm6, will you rely on a p5 snapshot? and which one?

[13:22] <phenny> diakopter: I'll pass that on when pmurias is around.

[13:22] <sorear> pmurias asked me earlier about installable STD

[13:25] <diakopter> oh

[13:26] <pmurias> diakopter: if STD is installable and on CPAN, the version of mildew on CPAN should depend on that

[13:26] <phenny> pmurias: 13:22Z <diakopter> ask pmurias since mildew depends on pugscode's STD.pm6, will you rely on a p5 snapshot? and which one?

[13:27] <diakopter> I think perhaps sorear would be the most suited to prepare such a distribution

[13:28] <sorear> yeah

[13:28] <sorear> I've been working with azawawi on that

[13:29] <sorear> to prepare the next version of Syntax::Highlight::Perl6

[13:30] <Juerd> Oh wow, ecmascript "use strict" is not just literally "use strict", it is that *including* the quotes. A string in void context that *does something*. Eww!

[13:30] <Juerd> That's almost as scary as meaningful comments (#line)

[13:30] <sorear> Juerd: python docstrings have this beat by half a decade at least

[13:30] *** felliott left
[13:30] <sorear> Juerd: I recommend you never look up Smart::Comments on CPAN

[13:31] <Juerd> Too late for that

[13:32] <sorear> phenny: ask TimToady In the interests of pmurias & azawawi wanting to build installs, how would you feel about me moving src/perl6 into the Perl6::STD:: p5 namespace?

[13:32] <phenny> sorear: I'll pass that on when TimToady is around.

[13:33] *** foodoo left
[13:34] *** felliott joined
[13:38] <arnsholt> sorear: And the Python docstrings are probably nicked from Common Lisp =)

[13:39] *** felliott left
[13:40] *** envi^home joined
[13:41] *** ash_ joined
[13:41] *** wallberg left
[13:46] <masak> in what ways do Python docstrings have semantics?

[13:48] <sorear> they can be introspected

[13:48] <masak> cf Perl 6. :)

[13:48] <mberends> #!/usr/bin/env perl # this is not a comment ;)

[13:49] <masak> mberends: on Windows, it is :P

[13:49] <sorear> it's a comment to Perl

[13:49] <masak> but yes, it's a form of out-of-band deus ex machina thing.

[13:50] <sorear> it may or may not be a comment to fs/binfmt_script / execve, depending on where in the file it is

[13:50] <sorear> also that should be spelled #! /

[13:50] <masak> why?

[13:50] <Trashlord> yeah, I'm curious too as to why

[13:50] <sorear> according to the autoconf portability guide, there are a fair few unices that parse a 4 byte magic number for scripts

[13:53] <ash_> masak: comments and python can do other things too, like run tests (see doctest)

[13:54] <masak> ash_: sounds a lot like annotations, then.

[13:54] <masak> sorear: huh. learn something every day.

[13:55] <ash_> masak: yeah, but like sorear said, they can be introspected, so you can do that dynamically at run time with anything, even C extensions to python have a place to specify the docstring 

[13:55] <ash_> almost every object has a .__doc__ in python 

[13:56] <ash_> which is kinda cool, in the interactive terminal if you say help(somefunction) it pulls up the docstring in a man-page like interface

[13:56] <masak> nice.

[13:57] <ash_> its also nice because when you leave the manpage like interface you go right back to where you were in the interactive terminal, so no need to leave the terminal to check docs 

[13:58] <wolverian> now python only needs howdoIusethisthing(object)

[13:58] <ash_> well, in python there is only one way to do anything

[13:58] *** uniejo left
[13:58] <ash_> if you try anything else, well people say your doing it wrong... 

[13:58] * ash_ has some biased on python obviously... 

[13:59] * masak is considering learning a bit more of Python

[14:02] <ash_> its useful to know, especially considering how much stuff is being done in/with python these days...

[14:02] <masak> any reason not to make Match.keys return the names of the captured submatches?

[14:04] *** pnate2 joined
[14:06] <ash_> masak: do you mean like / <ws> / ~~ '   ';  $/.keys  == <ws>? 

[14:06] <masak> yes, if by the last <ws> you mean 'list of one string "ws"'.

[14:07] <ash_> yea, like <a b c> (not a token) 

[14:07] <ash_> or any other named regex

[14:07] *** Siddy joined
[14:07] <ash_> what happens if you have 2 with the same name? 

[14:07] <ash_> would it just list it twice? 

[14:08] *** pnate2 left
[14:08] <masak> no, just like a hash wouldn't.

[14:08] *** pnate left
[14:08] <masak> Match already does Associative...

[14:10] *** Trashlord left
[14:11] <ash_> so, if you captured more than 1 of a named something you would only have access to like the last capture? 

[14:11] <masak> no, .keys only gives the names of the subrules captured.

[14:11] <arnsholt> ash_: No, it'll be a list, I think

[14:12] <ash_> ah, i see the difference now, thanks

[14:12] <masak> according to S05, it'd be a list, yes.

[14:12] <masak> but you'd access that as usual, through $/{$subrule}.

[14:14] *** gbacon joined
[14:21] <colomon> ooo, that reminds me.

[14:21] <colomon> I tried building the ABC module.

[14:21] <colomon> regex assertion not terminated by angle bracket at line 83, near "::basenote"

[14:21] <colomon> thats from the regex <ABC::basenote>.

[14:22] <colomon> nyi in master?

[14:22] *** Guest93363 left
[14:23] <masak> nyi in nqp-rx.

[14:25] <masak> hm, if I knew how to contact LastOfTheCarelessMen, I'd suggest that he remove Makefile.in, Configure and lib/Configure.pm from his ABC and Vector repositories...

[14:25] <masak> so I can remove those projects from the bottom of http://github.com/masak/ufo/blob/master/README :)

[14:26] <colomon> Neither of them actually compiles under master anyway, it seems.  :(

[14:29] <colomon> is there an effective workaround for the regex thing?

[14:29] <arnsholt> masak: Doesn't he hang around here, but under some other handle?

[14:29] <colomon> "last", but I don't think he's logged on in a long time.

[14:31] <masak> huh. I had forgotten that.

[14:31] <masak> colomon: re effective workaround -- not that I know of. if you find one, please let me know.

[14:31] <colomon> bother.

[14:34] *** rgrau_ left
[14:36] *** Guest93363 joined
[14:37] <masak> rakudo: my ($a, $) = 4, 5; say $a # this is the way to explicitly assign to nothing, right?

[14:37] <p6eval> rakudo 3d2cb8: OUTPUT¬´4‚ê§¬ª

[14:38] <sorear> right

[14:38] <masak> rakudo: my ($a, *) = 4, 5; say $a # what about this?

[14:38] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Malformed parameter at line 11, near "*) = 4, 5;"‚ê§¬ª

[14:38] <masak> could it be made to work?

[14:38] <masak> is it a good idea?

[14:39] <masak> the two forms would be synonymous, as far as I can see.

[14:39] <arnsholt> Sounds reasonable to me

[14:39] *** Mowah joined
[14:39] <arnsholt> But I've come to understand that my understanding of Whatever is a bit limited

[14:40] <isBEKaml> Hi, what does this do here? What exactly is "times" ? >>> return (time, times) ¬ª-¬´ @s; # Benchmark.pm

[14:40] <masak> I suppose * would be more of a special case than $ in the implementation.

[14:41] <masak> rakudo: say times

[14:41] <isBEKaml> I worked around this by initalising two variables with time around the loop that runs the code and returning back the difference. 

[14:41] <p6eval> rakudo 3d2cb8: OUTPUT¬´Could not find sub &times‚ê§  in main program body at line 11:/tmp/jltqpeaHsP‚ê§¬ª

[14:41] <isBEKaml> masak: yes. times gave me nothing. time did. system.pm I guess.. 

[14:41] <PerlJam> isBEKaml: Are you converting the Perl 5 Benchmark?

[14:41] <ash_> masak: so would you loose the 5 in your example? 

[14:42] <isBEKaml> PerlJam: No, Pugs has Benchmark module. I'm trying to get it to work. :)

[14:42] <masak> isBEKaml: perldoc -f times

[14:42] <isBEKaml> PerlJam: made it work with the workaround I mentioned above. 

[14:42] <masak> ash_: yes.

[14:42] <PerlJam> isBEKaml: what masak said.  :)

[14:43] <ash_> masak: in perl5 wasn't that my ($a, undef) = 4, 5; ? 

[14:43] *** patspam joined
[14:43] <PerlJam> ash_: still is  :)

[14:43] <masak> ash_: yes, and the corresponding (s/undef/Mu/) would work here too, I think.

[14:43] <masak> isBEKaml: also, http://github.com/perlpilot/benchmark/

[14:44] <PerlJam> ash_: well, with () around the RHS

[14:44] <ash_> rakudo: my ($a, Mu) = 4, 5; 

[14:44] <p6eval> rakudo 3d2cb8:  ( no output )

[14:44] <isBEKaml> Ah, ok. I guess I could get this to work by calling something to akin to system("time").. Until we have it in Rakudo.. :)

[14:44] <ash_> cool 

[14:45] <isBEKaml> rakudo: say time

[14:45] <p6eval> rakudo 3d2cb8: OUTPUT¬´1277994371.64924‚ê§¬ª

[14:46] <masak> isBEKaml: &times is only mentioned twoce in very unlit corners of S29 right now.

[14:46] *** timbunce left
[14:47] *** felliott joined
[14:47] <isBEKaml> masak: times is just mentioned under Other Functions. :) No definition. 

[14:48] <masak> s/twoce/twice/

[14:48] <isBEKaml> the second one being part of "set priority times"

[14:52] <isBEKaml> masak: I just looked at perlpilot++'s Benchmark module. The code looks similar to what I did in Pugs' Benchmark module. 

[14:52] <isBEKaml> :)

[14:52] *** jaldhar left
[14:52] *** Siddy left
[14:53] <isBEKaml> I mean, it doesn't use times - just time for the difference. Btw, how do I run the system('time') ? exec::run? 

[14:54] *** timbunce joined
[14:55] <isBEKaml> D'oh. system.pm -> run("time")

[14:55] <PerlJam> isBEKaml: run("time $proggy");

[14:56] <isBEKaml> PerlJam: thanks. :)

[14:56] *** felliott left
[14:57] *** mberends left
[14:58] <pugssvn> r31526 | sorear++ | [STD] add a hook for subclasses to override initial slangs 

[14:59] <PerlJam> wow, pugs' Benchmark.pm does look remarkably like mine.  I guess even in a world of TIMTOWTDI, there's only so many ways to express a given thing.

[15:00] *** proller joined
[15:02] <PerlJam> though pugs' version was continuing the trend of tightly coupling the output and the timing info.

[15:02] <PerlJam> That's something that bothers me for some reason

[15:02] <pmichaud> re-good morning #perl6

[15:02] <PerlJam> greets pm

[15:02] <isBEKaml> greetings, pm!

[15:03] <isBEKaml> PerlJam: yeah, I was kinda confused when I saw that module. particularly, how it went about timing the loops. 

[15:03] <colomon> \o

[15:08] <isBEKaml> wow, I really should start thinking in terms of unicode ops... :|

[15:08] <pmichaud> interesting.   It's     my ($a, $) = 4, 5;  if declaring $a but    ($a, *) = 4, 5;   if $a is already declared.

[15:09] <jnthn> Aye

[15:09] <jnthn> $ is not a valid term

[15:09] <jnthn> std: $

[15:09] <p6eval> std 31525: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Non-declarative sigil is missing its name at /tmp/kKTvV_drkM line 1:‚ê§------> [32m<BOL>[33m‚èè[31m$[0m‚ê§Bogus statement at /tmp/kKTvV_drkM line 1:‚ê§------> [32m$[33m‚èè[31m<EOL>[0m‚ê§    expecting twigil‚ê§Parse failed‚ê§FAILED 00:01 112m‚ê§¬ª

[15:09] <pmichaud> I'm more curious that * isn't a valid param.  :-)

[15:09] <jnthn> Guess we maybe could make it one

[15:09] <pmichaud> jnthn: I have a question about roles ... :-)

[15:10] <jnthn> Though is *** then a slice-slurpy *? ;-)

[15:10] <jnthn> pmichaud: If you're really lucky, I may have an answer. ;-)

[15:10] *** alester joined
[15:10] <pmichaud> I'm trying to re-implement WHENCE

[15:10] <masak> pmichaud: could 'my ($a, *) = 4, 5;' be made legal?

[15:10] <pmichaud> the standard mechanism is     Foo but WHENCE({...})

[15:10] <pmichaud> how should WHENCE be defined here?

[15:11] <pmichaud> a sub returning a role?

[15:11] *** mikehh left
[15:11] <pmichaud> a role itself?

[15:11] <masak> pmichaud: ah, you already said it could.

[15:11] <pmichaud> masak: I don't know if that could be made legal or not... seems like an odd disjointness if it isn't, though.

[15:11] * jnthn thinks

[15:11] <jnthn> pmichaud: Give me a moment to check something in spec...

[15:12] <pmichaud> well, is there a syntax for a role  that would accept parens?

[15:12] <masak> pmichaud: yes, I agree.

[15:12] <jnthn> pmichaud: OK, checked what I wanted to

[15:12] <jnthn> pmichaud: does Role($param) is syntactic sugar, afaict from S14

[15:13] <jnthn> Here is the key langauge from S14:

[15:13] <jnthn> A role applied with C<does> may be parameterized with an initializer

[15:13] <jnthn> in parentheses, but only if the role supplies exactly one attribute

[15:13] <jnthn> to the mixin class:

[15:13] <jnthn> $fido does Wag($tail);

[15:13] <jnthn>     $line does taint($istainted);

[15:13] <jnthn> Note that the parenthesized form is I<not> a subroutine or method call.

[15:13] <jnthn> It's just special initializing syntax for roles that contain a single

[15:13] <jnthn> property.

[15:13] <pmichaud> jnthn: looking

[15:13] <jnthn> We had that in alpha but it ain't in master again yet.

[15:13] <jnthn> But this would suggest that WHENCE here is the role

[15:13] <pmichaud> agreed, and it mixes in a property

[15:14] <jnthn> And it has one "has $.foo" (maybe even it's $.WHENCE)

[15:14] <pmichaud> right

[15:14] <pmichaud> but nyi in master, yes?

[15:14] <jnthn> That syntax isn't, no

[15:14] <jnthn> It does seem to be clearly syntactic.

[15:14] <pmichaud> yes.

[15:14] <jnthn> But it should be easy

[15:14] <pmichaud> I'd be a little concerned about a potential conflict with the coercion syntax, however.

[15:14] <jnthn> It's just an extra arg to does and but

[15:15] <jnthn> Yeah, but you'd not do a coercion on the RHS of does and but, probably?

[15:15] <jnthn> I suspect it's a reducecheck thingy.

[15:15] <pmichaud> oh, you're saying it's a coercion tied to the actual &infix:<does>

[15:15] <jnthn> Others have remarked that they'd a less constrained syntax here

[15:15] <pmichaud> hmmmmm

[15:15] <jnthn> For setting up more than one attr.

[15:16] <jnthn> pmichaud: Yes, I've seen it as another arg given to does and but. Just another multi candidate

[15:16] <pmichaud> okay.

[15:16] <jnthn> It'd delegate the first args to the two arg form of does and but

[15:16] <jnthn> And then apply the value for the third.

[15:16] <sorear> I'd like to argue for enums NOT being subtypes of their base type

[15:16] <jnthn> All of does and but are implemetned in the setting btw.

[15:17] <pmichaud> yes, I saw that.

[15:17] <jnthn> Just in terms of the meta-model.

[15:17] <sorear> enum Foo <a b c>; Foo ~~ Int;  # this blocks a lot of optimizations since Int tends to be final otherwise

[15:17] <jnthn> I'm not sure if Foo ~~ Int so much as all(a, b, c) ~~ Int

[15:18] <ash_> rakudo: sub foo { try { return 42; }; }; say foo; # is that right? 

[15:18] <p6eval> rakudo 3d2cb8: OUTPUT¬´Null PMC access in type()‚ê§  in main program body at line 11:/tmp/4oJG5TUxUl‚ê§¬ª

[15:18] <sorear> either way

[15:18] <jnthn> No, a Null PMC access is never right.

[15:18] <sorear> a ~~ Int is bad type safety juju and breaks auto-finalize

[15:18] <ash_> err, i meant, it should return right? try shouldn't catch the return should it? 

[15:18] <jnthn> ash_: No, it should not

[15:18] <jnthn> I guess that's the real bug there.

[15:19] <pmichaud> jnthn: so, is it worth trying to get the   does Wag($property)   syntax working, or should I cheat a bit on WHENCE for now?

[15:20] <pmichaud> I'm fine either way.

[15:20] <jnthn> rakudo: role Foo { method lol { "omg" } }; my $x = Int but Foo; say $x.lol

[15:20] <p6eval> rakudo 3d2cb8: OUTPUT¬´Attempt to use rebless_subclass where the new class was not a subclass‚ê§  in 'infix:<does>' at line 38‚ê§  in 'infix:<does>' at line 456:CORE.setting‚ê§  in 'infix:<but>' at line 483:CORE.setting‚ê§  in main program body at line 11:/tmp/V5_6xznVkB‚ê§¬ª

[15:20] <jnthn> oh grrr

[15:20] <jnthn> pmichaud: It's worth getting that working

[15:20] <pmichaud> rakudo:  role Foo { method lol { "omg" } };  my $x = 3 but Foo;  say $x.lol'

[15:20] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Confused at line 11, near "say $x.lol"‚ê§¬ª

[15:20] <jnthn> pmichaud: Though I think we have a slight problem with mixing into type objects at the moment too

[15:20] <pmichaud> rakudo:  role Foo { method lol { "omg" } };  my $x = 3 but Foo;  say $x.lol;

[15:20] <p6eval> rakudo 3d2cb8: OUTPUT¬´omg‚ê§¬ª

[15:20] <pmichaud> yes, it appears we do.

[15:21] <pmichaud> rakudo:  role Foo { method lol { "omg" } };  my $x = Int.clone but Foo;  say $x.lol;

[15:21] <p6eval> rakudo 3d2cb8: OUTPUT¬´Attempt to use rebless_subclass where the new class was not a subclass‚ê§  in 'infix:<does>' at line 38‚ê§  in 'infix:<does>' at line 456:CORE.setting‚ê§  in 'infix:<but>' at line 483:CORE.setting‚ê§  in main program body at line 11:/tmp/VC_NbZTcob‚ê§¬ª

[15:21] <jnthn> Let me see if I can spot why.

[15:21] <pmichaud> okay.

[15:22] <jnthn> (src/metamodel/RoleToInstanceApplier.nqp if you want to look too, btw)

[15:22] <pmichaud> I'm heading to lunch

[15:22] <pmichaud> if it ends up being an easy fix, the I'm good with that.

[15:22] <pmichaud> If not, I'll cheat around it, but keep the model in mind so it's an easy switch later.

[15:22] <jnthn> oooh

[15:22] <jnthn> It's annoying.

[15:23] <arnsholt> pmichaud: Is implementing languages on Parrot with NQP fit under your plan for the NQP book?

[15:23] <jnthn> $subclass.HOW.add_parent($subclass, $target.WHAT);

[15:23] <pmichaud> arnsholt: yes.

[15:23] <frew> is there a clever way I can do an ordered reduce in p6?

[15:23] <arnsholt> Cool. Then I'll try to write up my recent experiences for that

[15:23] <pmichaud> arnsholt: excellent.

[15:23] <colomon> frew: they are always ordered.

[15:23] <jnthn> pmichaud: The thing is that type objects today are actually a Parrot subclass.

[15:24] <frew> the idea being [&&] @fn.map: { $_() }

[15:24] <colomon> frew: you mean you want to change the order?

[15:24] <jnthn> pmichaud: But add_parent does some "unwrapping" to get to the Parrot class from the type object.

[15:24] <frew> colomon: no, I want it to stay in order, and since it's a bool I want it to short circuit

[15:25] <jnthn> pmichaud: Thus it ends up making the Parrot class that represents non-type object instances the parent of the generated subclass.

[15:25] <colomon> frew: I don't think reduce short-circuits at the moment.

[15:25] <frew> does map do that stream thing yet?  because for the short-circuiting to matter the entire map shouldn't get calculated

[15:25] <jnthn> pmichaud: I think it's probably a p6object behavior.

[15:26] <colomon> frew: map is lazy, yes.

[15:26] <frew> ok, cool

[15:26] <pmichaud> frew: reductions don't short circuit

[15:26] <frew> so reduce should be short-circuiting but NYI?

[15:26] <pmichaud> let me rephrase that

[15:26] <frew> so what's the right way to do it?  junctions?

[15:26] <pmichaud> a reduction is allowed to short-circuit, but it still evaluates all of its arguments

[15:27] <pmichaud> so, for example,    [&&]  0, 1, 2, foo()

[15:27] <pmichaud> can still call foo() prior to invoking [&&]

[15:27] *** meppl joined
[15:27] <pmichaud> however    [&&]   fn-returning-lazy-list()

[15:28] <pmichaud> isn't required to eagerly evaluate the entire list before [&&] gets to it

[15:28] <colomon> frew: does that mean you do not care about the return value of the reduced?

[15:28] <colomon> *reduce

[15:29] <pmichaud> I don't know if [&&] is required to evaluate its list lazily.  We could probably make it do that.

[15:29] <jnthn> rakudo: sub foo() { say "oops" }; say [&&] gather { take 0; take 1; take foo(); }; # curious

[15:29] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Could not find sub &infix:<&&>‚ê§¬ª

[15:29] <frew> hm

[15:29] <colomon> pmichaud: I believe it is lazy but not short-circuiting at the moment.

[15:30] * pmichaud checks.

[15:30] <jnthn> huh, I thought that was added the other day

[15:30] <pmichaud> it was added, yes.

[15:30] <pmichaud> p6eval not up-to-date, likely.

[15:30] <jnthn> And is tested.

[15:30] <jnthn> Oh

[15:30] <jnthn> :S

[15:30] <frew> so gather is lazy?

[15:31] <pmichaud> frew: yes, almost by definition :-)

[15:31] <frew> I can see that

[15:31] *** Ross joined
[15:31] <jnthn> > sub foo() { say "oops" }; say [&&] gather { take 0; take 1; take foo(); };

[15:31] <jnthn> oops

[15:31] <jnthn> 0

[15:31] <jnthn> aww

[15:32] <colomon> I think for a little while reducewith did short-circuit, but we moved away from that for some reason.

[15:32] <masak> IIRC [&&] shouldn't short-circuit...

[15:32] <pmichaud> colomon: I think in order to have short-circuiting reduce we'd have to define it as   multi sub infix:<[&&]>(*@values) { ... }

[15:32] <frew> why shouldn't it?

[15:32] *** Su-Shee left
[15:32] <frew> I can understand that reduce may not always want to be lazy, but sometimes it would be nice

[15:33] <colomon> pmichaud: I mean short-circuiting in the lazy sense, not in the not evaluating its arguments sense.

[15:33] <arnsholt> It'd be hard to implement general-purpose short-circuiting for reduce I think

[15:33] <pmichaud> colomon: yes, that's what I mean also.

[15:33] <frew> arnsholt: right, it mostly just applies to booleans

[15:33] <colomon> I don't think there's any issue implementing the lazy sense at all.

[15:34] <masak> S03:4431: "Similarly, list-associative operators that have the thunk-izing characteristics of macros (such as short-circuit operators) lose those macro-like characteristics."

[15:34] <frew> maybe something clever could be done with reduce in boolean context?

[15:34] <colomon> it's the $chaining block in the non-triangle portion.

[15:34] <pmichaud> colomon: && isn't chained.

[15:34] <colomon> Oh, right!

[15:34] <colomon> never mind, then.

[15:35] *** synth left
[15:35] <pmichaud> masak: I think that S03:4431 says that all of the arguments are evaluated

[15:35] *** Ambiguity joined
[15:35] <pmichaud> masak: but that doesn't say anything about whether the evaluation of [&&] could short-circuit on the first false argument it finds

[15:35] <sorear> what is the difference between ?&, &&, and, and andthen?

[15:35] <pmichaud> ?& is boolean and

[15:35] <pmichaud> && is short-circuit and

[15:36] <pmichaud> 'and'  is short-circuit and, low precedence

[15:36] <ash_> & is also useable, it makes a junction 

[15:36] *** Su-Shee joined
[15:36] <masak> pmichaud: er. I almost don't see that distinction.

[15:36] <pmichaud> masak: for example,    [&&] 0..*    could return false without having to evaluate the infinite list.

[15:36] <masak> ah, right. infinite lists.

[15:37] <pmichaud> in that sense,  [&&] is lazy but not thunking

[15:37] <masak> I was going to say "I see only a difference in speed".

[15:37] <pmichaud> or, to make it more concrete

[15:37] <frew> pmichaud: so how is that different than my use case?

[15:37] <pmichaud> frew: it's not.

[15:37] <frew> ok, so it's just NYI then?

[15:37] * frew can't understand which is spec and which is impl :-)

[15:37] <sorear> if (node && node->valid) { ... // the #1 reason short circuiting exists in any language

[15:37] <pmichaud> frew: we're trying to decide what the spec is.

[15:37] <frew> heh

[15:38] <pmichaud> frew: currently there's nothing that says that [&&] has to be lazy.

[15:38] <pmichaud> I don't know if there's something that says that [op]  is eager.

[15:38] <frew> ok, well, I hope the spec supports my use case, because I know that at the very least it will be useful for some of the stuff we do at work and in DBIC often

[15:38] <pmichaud> I'm guessing no -- that in general reduce tries to be lazy.

[15:38] *** synth joined
[15:38] <ash_> sorear: if ($node.?valid) { # woo perl6

[15:38] <pmichaud> we're also exploring the distinction between   laziness of reduce and thunking behavior

[15:39] <frew> ok, so I'm not the first person to discuss this then

[15:39] <pmichaud> for example,    0 && foo()    would mean that foo() never gets invoked.  It's "thunked"

[15:39] <frew> right

[15:39] <frew> and that's what I care about

[15:39] <frew> (I think)

[15:39] <pmichaud> but [&&] 0, foo()    would still result in foo() being invoked, even though [&&] might short-circuit and stop evaluating its argument list as soon as it sees the 0.

[15:39] <frew> because the list isn't lazy?

[15:40] <pmichaud> because [&&] doesn't thunk its arguments.

[15:40] <pmichaud> while && does.

[15:40] <jnthn> With [&&] at the moment, you have to go thunk yourself.

[15:40] <frew> wow, can you tell p6 a function arg to be thunked?

[15:40] <frew> for anything?

[15:40] <pmichaud> frew: I don't think that's specced yet.

[15:40] <frew> ok

[15:40] <frew> well

[15:40] <frew> that would be really powerful

[15:40] <jnthn> frew: No, at the moemnt it's just handled by the compiler as a special case.

[15:40] <pmichaud> (and we've been curious about ways to spec it :)

[15:41] <frew> ok, that's less surprising

[15:41] <frew> generic thunking would be crazy (in a good way)

[15:41] <frew> but then so is p6 so w/e

[15:41] *** mmcleric joined
[15:43] *** rgrau joined
[15:44] <colomon> btw, the triangle form of reduce *is* lazy:

[15:44] <pmichaud> yes, triangle form is explicitly lazy.

[15:44] <colomon> rakudo: say ([\+] 1...*).munch(20)

[15:44] <frew> ok, well, I was just doing it in p6 and was curious how to do it, since of course I have to use a for loop and a return in the middle

[15:44] <p6eval> rakudo 3d2cb8: OUTPUT¬´13610152128364555667891105120136153171190210‚ê§¬ª

[15:44] <colomon> rakudo: say ([\+] 1...*).munch(20).perl

[15:45] <p6eval> rakudo 3d2cb8: OUTPUT¬´(1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210)‚ê§¬ª

[15:45] <colomon> frew: Can you tell us more about what you are trying to do?

[15:45] <frew> colomon: ure!

[15:45] <frew> sure*

[15:45] <pmichaud> afk, lunch

[15:46] <frew> basically, we have an alarm system (p5) that checks to see if any of the alarms conditions are met

[15:46] *** macdaddy joined
[15:46] <frew> if any of them are met then a bunch of notifications are sent out

[15:46] *** macdaddy is now known as Guest42363

[15:47] <frew> checking conditions is expensive

[15:47] <frew> so I need to NOT do that if possible

[15:47] <colomon> so the things in your map statement there are expensive

[15:48] <frew> very yes :-)

[15:48] <colomon> and you still need to know if the result is true or false.

[15:48] <frew> otherwise I wouldn't care if they got ran

[15:48] <frew> right

[15:48] <frew> so normally I just do 		return unless $_->check($observation, $dms);

[15:48] <colomon> are their values significant other than true or false?

[15:49] <frew> nope

[15:49] <frew> not in the lease

[15:49] <frew> least*

[15:50] <sorear> Bleh.

[15:50] <sorear> When TimToady fixed Test::Util to generate Test/Util.syml, he broke STD:auth<http://perl.org>

[15:52] <colomon> frew: so you need something like for @fn { return False unless $_() }; return True;

[15:57] * colomon is trying to think if there is a shorter way to do that....

[15:57] <colomon> oooo, here's an evil one:

[15:57] <colomon> [==] 1, @fn.map({ $_() })

[15:58] <colomon> of course, that only works if chaining functions can stop early in reduce, which I think is still ambigious.

[15:58] <colomon> *ambiguous 

[15:58] *** isBEKaml left
[15:59] * colomon can't decide if he loves that one or hates it.

[16:02] *** charsbar joined
[16:02] *** Grrrr joined
[16:03] *** cdarroch joined
[16:03] *** cdarroch left
[16:03] *** cdarroch joined
[16:16] *** gbacon left
[16:17] *** TiMBuS left
[16:18] <dalek> yapsi: cc725ab | masak++ |  (4 files):

[16:18] <dalek> yapsi: [Yapsi] implemented if, if/else statements

[16:18] <dalek> yapsi: This required a few new SIC opcodes, 'jf' (jump if false) and 'jmp'

[16:18] <dalek> yapsi: (jump unconditionally).

[16:18] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/cc725ab939f4080cb14f191e78df3f23ef05058d

[16:18] * moritz_ back

[16:19] <masak> moritz_! \o/

[16:20] <masak> moritz_: so, what's the next step for http://github.com/moritz/modules.perl6.org ?

[16:20] *** justatheory joined
[16:20] <moritz_> masak: getting a nod from somebody; then installling it

[16:20] * [Coke] ~~ at frew.

[16:21] <masak> moritz_: sir, I nod at you.

[16:21] * moritz_ feels nodded

[16:22] <PerlJam> what is modules.perl6.org exactly?

[16:22] <moritz_> PerlJam: it's basically the same as proto.perl6.org, but without proto

[16:22] *** christine joined
[16:22] <PerlJam> gotcha

[16:23] *** Sarten-X joined
[16:27] <masak> just like pls is basically the same as proto, but without proto. :)

[16:28] <jnthn> And a more pleasing name.

[16:28] <masak> *rimshot*

[16:29] *** xinming_ joined
[16:31] <moritz_> http://modules.perl6.org/ there you go

[16:31] <PerlJam> masak: funny.  I always insert a mental *rimshot* rather than type it because there are so many times in #perl6 that it would be appropriate that most of our conversations would be *rimshot* punctuated by pun

[16:32] <masak> PerlJam: the conversations would be rimshot to death.

[16:32] <ash_> how is pls coming along? 

[16:32] <masak> ash_: it works as a proof-of-concept.

[16:32] <masak> ash_: still need to test it for all projects, and likely generalize it in places.

[16:32] <masak> might get a round tuit this weekend.

[16:33] * jnthn eyes a small wooden item on his desk

[16:33] <masak> today is Yapsi release day :)

[16:35] *** hugme joined
[16:35] <moritz_> hugme: add masak to modules.perl6.org

[16:35] * hugme hugs masak. Welcome to modules.perl6.org!

[16:35] <masak> \o/

[16:36] * [Coke] ponders bringing a drumkit noise maker to the next hackathon.

[16:36] <masak> moritz_: is it OK if I add all the proto contributors to modules.perl6.org?

[16:36] <moritz_> masak: proto.perl6.org now redirects to modules/

[16:36] <moritz_> masak: sure

[16:36] <masak> gotta run now, but I'll do it laterz.

[16:36] <moritz_> it's a project we could migrate to the perl6 account over time

[16:36] <masak> o/

[16:36] *** masak left
[16:37] <moritz_> \o

[16:37] <[Coke]> "has tests" (but do they pass? ;)

[16:38] <bbkr> rakudo: $_ = {.()}; .() # bomb! hide!

[16:38] <p6eval> rakudo 3d2cb8: OUTPUT¬´maximum recursion depth exceeded‚ê§  in <anon> at line 1:/tmp/feZlmxWl0P‚ê§  in <anon> at line 11:/tmp/feZlmxWl0P‚ê§  in <anon> at line 11:/tmp/feZlmxWl0P‚ê§  in <anon> at line 11:/tmp/feZlmxWl0P‚ê§  in <anon> at line 11:/tmp/feZlmxWl0P‚ê§  in <anon> at line 11:/tmp/feZlmxWl0P‚ê§  in <anon>

[16:38] <p6eval> ..at l‚Ä¶

[16:38] *** amkrankruleuen left
[16:39] <moritz_> that's a nice one

[16:39] <moritz_> [Coke]: determining if tests pass is far  more tricky than detecting their presence

[16:40] <PerlJam> anyone who used proto "has tests"

[16:40] <jnthn> rakudo: .() given {.()}

[16:40] <p6eval> rakudo 3d2cb8: OUTPUT¬´invoke() not implemented in class 'Any'‚ê§  in <anon> at line 11:/tmp/bN9jE6hdr4‚ê§  in main program body at line 11:/tmp/bN9jE6hdr4‚ê§¬ª

[16:40] <jnthn> Aww

[16:48] *** rv2733 joined
[16:51] <ash_> jnthn: you use windows, right?

[16:51] <jnthn> right

[16:51] <ash_> is there any way to make an installer for a .dll and header files? 

[16:51] <ash_> i don't know windows so...

[16:52] <pmichaud> back from lunch

[16:52] <jnthn> ash_: Should be possible.

[16:52] <jnthn> It's putting the header files in a sensible place that's maybe the slightly trickier bit.

[16:53] <jnthn> But don't see why it wouldn't be doable.

[16:56] <ash_> is there a standard format for that sort of stuff if you use like Visual Studio? 

[16:56] <jnthn> "standard format"?

[16:56] <jnthn> For installers?

[16:56] <bbkr> rakudo: [{.()}, *.() .. *] # /me wonders why it runs infinitely instead of reaching recursion depth allowed

[16:56] <ash_> yeah, for installers

[16:56] <p6eval> rakudo 3d2cb8:  ( no output )

[16:56] <jnthn> The MS one is MSI (MicroSoft Installer)

[16:57] <ash_> for comparision, i know on OS X you can make a 'framework' thats a bundle of the .dylib, and .a files, as well as the headers, and they are versioned so you can include multiple versions, etc. 

[16:57] <jnthn> There's various tools that produce them

[16:57] <jnthn> It's not specific to installing just developer stuff though

[16:57] <ash_> hmm, alright

[16:58] <ash_> the only other projects I have seen that use libffi on windows include the source with their project and have modified build instructions, so they aren't building it as a separate .dll  

[16:59] <wolverian> look at what Gtk+ does

[16:59] * wolverian shrugs

[16:59] *** dakkar left
[17:01] *** tylercurtis joined
[17:02] *** Ross left
[17:02] *** Ross joined
[17:10] <pmichaud> jnthn: I'm going to fix closures first before continuing with WHENCE, since WHENCE will need working closures for autoviv :-)

[17:10] <pmichaud> (so I expect to fix closures today.)

[17:14] <colomon> \o/

[17:15] *** isBEKaml joined
[17:16] <bbkr> std: for sub{1}, {2} {.WHAT.say}

[17:16] <p6eval> std 31526: OUTPUT¬´ok 00:01 113m‚ê§¬ª

[17:17] <bbkr> rakudo: for sub{1}, {2} {.WHAT.say} # works... impressive :)

[17:17] <p6eval> rakudo 3d2cb8: OUTPUT¬´Sub()‚ê§Block()‚ê§¬ª

[17:17] <pmichaud> yes, sometimes rakudo actually works.  :-)

[17:17] <jnthn> :P

[17:17] <jnthn> pmichaud: +1

[17:18] *** thebird left
[17:18] <jnthn> pmichaud: In a sense, that's even more important. :-)

[17:18] <pmichaud> well, it's also likely to involve a fair bit of refactoring :-|

[17:18] <pmichaud> but I've been doing a lot of that lately :)

[17:18] <jnthn> pmichaud: I may be able to work something out for this mixing in to proto-objects bug too.

[17:18] <isBEKaml> beyond all sanity of the devs themselves.. Now that's impressive Rakudo power! :)

[17:19] <pmichaud> jnthn: okay, that will be great if so.

[17:19] <pmichaud> but me working on closures today will likely mean I won't be on WHENCE again until late tonight or sometimes tomorrow (thus you have a bit more time :-)

[17:19] <jnthn> Aye

[17:20] <jnthn> I'll be doing a lot of Rakudo hacking at the weekend

[17:20] *** pyrimidine joined
[17:20] <jnthn> (Hackathon!)

[17:20] <isBEKaml> 3 weeks out and I badly want to get back into Rakudo.. :(

[17:20] <jnthn> But hope to have a bit of time tonight too.

[17:23] <bbkr> std: 1 X 1 X 1

[17:23] <p6eval> std 31526: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[17:23] <bbkr> rakudo: 1 X 1 X 1

[17:23] <p6eval> rakudo 3d2cb8: OUTPUT¬´No applicable candidates found to dispatch to for 'infix:<X>'. Available candidates are:‚ê§:(Any $lhs, Any $rhs)‚ê§‚ê§  in main program body at line 11:/tmp/0guV9ORhE8‚ê§¬ª

[17:23] <bbkr> known bug?

[17:23] <pmichaud> rakudo needs slice context parameters

[17:24] <pmichaud> (yes, known bug)

[17:24] <pmichaud> I've been thinking I might be able to cheat with a Parcel and .slice, though.

[17:24] *** clintongormley left
[17:24] <lue> ohai

[17:25] *** hercynium_ left
[17:27] *** eternaleye joined
[17:28] <bbkr> pmichaud: thanks

[17:29] *** Siddy joined
[17:31] <bbkr> rakudo: nextsame # hmm, error message is LTA

[17:31] <p6eval> rakudo 3d2cb8: OUTPUT¬´Null PMC access in clone()‚ê§  in main program body at line 1‚ê§¬ª

[17:31] * bbkr reports

[17:33] *** Siddy left
[17:38] <pmichaud> jnthn: ping

[17:39] <jnthn> pmichaud: pong

[17:40] <pmichaud> perhaps you could help me walk through block construction?

[17:40] <pmichaud> we have PAST::Block nodes, which translate into the parrot subs

[17:40] <jnthn> Right.

[17:40] <pmichaud> we have Code objects that wrap the Parrot subs

[17:41] *** clintongormley joined
[17:41] <pmichaud> signatures get attached to... ?

[17:41] <jnthn> Unless they are immediate blocks, we then call create_code_object to wrap them.

[17:41] <jnthn> The sub add_signature is always used to attach a signature to a block.

[17:41] <pmichaud> to PAST::Block ?

[17:41] <jnthn> It expects to be passed the PAST::Block.

[17:42] <jnthn> It adds the call to the signature binder

[17:42] <jnthn> What then happens is either:

[17:42] <pmichaud> what is $!signature and $!lazy_sig_init in Code, then?

[17:43] <jnthn> If the $lazy parameter is set to true, then it returns a reference to a block that will create the signature

[17:43] <jnthn> (A PAST::Val node with the block as the value)

[17:43] <jnthn> We provide this to create_code_object.

[17:43] <jnthn> If lazy is not set, it just emits a :load :init block that attaches the signature at loadinit time.

[17:43] <jnthn> Well

[17:43] <jnthn> It uses .loadinit actually

[17:43] <jnthn> Rather than setting the PIR flags on the block directly.

[17:44] <jnthn> See line 2677 in Actions.pm

[17:45] <pmichaud> okay, I see that it's still working with the PAST::Block

[17:45] <jnthn> Yes

[17:45] <jnthn> The wrap is the last thing we do.

[17:45] <jnthn> $!lazy_sig_init is one of the things we pass along to the Code constructor.

[17:45] <jnthn> That is, it's provided as an argument to it.

[17:46] <jnthn> Note that $!signature is the high level, Perl 6 Signature object

[17:46] <jnthn> It's not the sig PMC

[17:46] <jnthn> That still gets attached to the block as a property for now.

[17:47] <pmichaud> (just a sec, background events)

[17:48] <jnthn> .oO( can we upgrade pmichaud++ to multi-core? )

[17:49] <tylercurtis> jnthn: not without having to worry about him ending up in a mental hospital. 

[17:50] <pmichaud> okay, so the $!signature property on a Parrot sub is a P6LowLevelSig

[17:50] <pmichaud> ?

[17:50] <jnthn> Correct.

[17:50] <jnthn> That's what the binder cares about.

[17:50] <pmichaud> and the $!signature attribute on a Code object is a Signature

[17:50] <jnthn> Right

[17:50] <pmichaud> (Perl 6)

[17:50] <jnthn> Which the binder doesn't care about - it's mostly just for the sake of enabling introspection.

[17:50] <jnthn> We build it and cache it

[17:51] <jnthn> Since it costs a little to build.

[17:51] <jnthn> Plus when we get custom parameter traits we'll need to have done so anyway.

[17:52] <pmichaud> so, there are two places that can produce a lazy sig

[17:52] <pmichaud> one is in Code.signature

[17:52] <pmichaud> another is in the binder, when invoking the sub?

[17:52] <pmichaud> wait, I said that wrong

[17:53] <pmichaud> there are two places that evaluate the lazy sig

[17:53] <pmichaud> one is in Code.signature

[17:53] <pmichaud> the other is in the binder

[17:53] <pmichaud> ?

[17:53] <bbkr> rakudo: use MONKEY_TYPING; augment class Any { method invoke {1} }; .() # monkey_typing bug?

[17:53] <p6eval> rakudo 3d2cb8: OUTPUT¬´invoke() not implemented in class 'Any'‚ê§  in main program body at line 11:/tmp/e7TjCZoxtm‚ê§¬ª

[17:54] <jnthn> pmichaud: Actually the code that does it lives in the dynop bind_signature

[17:54] <pmichaud> hmmmm

[17:54] <jnthn> pmichaud: At the moment it only actually invokes .signature

[17:54] <pmichaud> oh

[17:54] <pmichaud> so it's all in .signature

[17:54] <jnthn> Right

[17:54] <jnthn> Maybe a tad wasteful in a sense

[17:54] * arnsholt hates the blank page effect

[17:54] <jnthn> But at least means it's only done in one place. :-)

[17:54] <pmichaud> well, not only that, but I think I'd prefer it to be in the parrot sub somehow

[17:55] <jnthn> prefer...what to be in the Parrot sub somehow?

[17:55] <pmichaud> I'm worried about the possibility of ending up with a PAST::Block with no Code wrapper

[17:55] <pmichaud> the lazy sig evaluation

[17:55] *** rgrau left
[17:55] <jnthn> The lazy sig thing and the code wrapper only ever happen together

[17:55] <pmichaud> i.e., I don't think the Code object should be keeping track of the lazy sig generator -- that seems like it should be entirely a property of the Parrot sub

[17:56] <jnthn> Then we'd have to have a load init to attach the lazy signature builder

[17:56] <jnthn> Which we get to avoid now.

[17:56] <jnthn> Saving all those invocations at startup was kinda the point.

[17:56] <pmichaud> thinking.

[17:58] *** synth left
[17:58] <pmichaud> does every perl 6 block end up with exactly one Code.new invocation?

[17:58] *** sorear sets mode: +v hugme

[17:58] <pmichaud> or do we somehow end up with wrapper objects (e.g., in a loop)?

[17:58] <pmichaud> *multiple wrapper objects

[17:59] <jnthn> In a loop I think it's an immediate block so we don't get that

[17:59] <pmichaud> I mean a closure within a loop

[17:59] <jnthn> Otherwise I think there are situations where we may end up with multiple

[17:59] <pmichaud> for @list { my $sub = { ... } }

[17:59] <pmichaud> not the loop block itself.

[17:59] <jnthn> Ah

[17:59] <pugssvn> r31527 | sorear++ | [STD] Unbreak 'use STD' (the longname changes got more than they bargained for) 

[17:59] <jnthn> I'm not sure what happens there today.

[18:00] <jnthn> That's probably the source of our problems though, iiuc.

[18:00] <pmichaud> it's a part of it, yes.

[18:00] <jnthn> I think they end up sharing

[18:00] <pmichaud> I'm expecting to do some refactoring of Code generation.

[18:00] <jnthn> When we shoulda cloned or some such.

[18:00] <pmichaud> yes, but we also have to be careful about cloning

[18:00] <pmichaud> we don't want to clone the lazy_sig_init, or the sig

[18:00] <pmichaud> I mean, we *can*, but that gets expensive too :-)

[18:01] <jnthn> Right

[18:01] <jnthn> I'm pretty sure .clone today is smart about what it clones.

[18:01] <pmichaud> when I last checked, it was smart but not smart enough.  :)

[18:02] <jnthn> Feel free to educate it. ;-)

[18:02] <pmichaud> something about the current factoring also bugs/confuses me a bit.  I agree we want $lazy_sig_init to not have to be attached with loadinit, though.

[18:03] <jnthn> OK, that's the motivation for lazy sig things being the way they are today.

[18:03] <pmichaud> agreed.

[18:03] <jnthn> If you've a better/cleaner way that still gives us that win, I'm all for it.

[18:03] <pmichaud> I'll certainly preserve that feature.

[18:03] <jnthn> I just didn't think of one at the time I was doing it. :-)

[18:04] <pmichaud> would you see an issue with us having all blocks be wrapped in Code objects?

[18:04] <pmichaud> (not sure I'll do that, just curious if you have any bad reactions to it :-)

[18:04] *** mberends joined
[18:05] <jnthn> It just feels (a) wasteful for immediate blocks and (b) I'm not sure how PAST::Compiler will cope if the thing it expects to be a PAST::Block isn't one, but maybe it won't expect that really.

[18:05] <jnthn> Other than that, in theory I can't think of any immediate problems you'd hit.

[18:05] *** PZt left
[18:06] <pmichaud> PAST::Compiler generally doesn't care.

[18:06] <pmichaud> and yes, I think I can optimize out immediate blocks

[18:06] <pmichaud> but I'm thinking I'd prefer to always have the actions build a Code object, then optimize them out in the (very few) places that immediate blocks occur

[18:07] <pmichaud> rather than what we have now, which tries to be overly smart about immediate versus non-immediate blocks

[18:08] <pmichaud> in other words, I'm thinking of pushing the create_code_block and make_lazy_sig functions a little farther down the generation tree

[18:08] <pmichaud> right now they occur a bit high in the tree

[18:08] <jnthn> Could work.

[18:09] <jnthn> See in the statementlist action method btw

[18:09] <jnthn> (on immediate handling)

[18:09] <pmichaud> that's the main one that will change, yes :-)

[18:09] <pmichaud> the only time that statement list ends up with an immediate block is when it comes from circumfix:<{ }>

[18:10] <jnthn> Troo.

[18:11] <pmichaud> so it's much easier to have circumfix:<{ }>  simply tag its past with "I'm immediate in statementlist"  than it is to have statementlist try to figure out when a block might be immediate.

[18:11] <pmichaud> I did this in NQP and it made things much cleaner.

[18:11] *** supernovus joined
[18:12] *** synth joined
[18:12] <jnthn> I can easily believe that.

[18:13] <pmichaud> okay, I think I understand the code much better now.  Thanks.

[18:14] <jnthn> OK, great. :-)

[18:15] <pmichaud> oh, one last question

[18:15] <pmichaud> what happens with routine declarations?  Do we depend on the outer block being executed before they get invoked?

[18:16] <pmichaud> or do we suppress lazy signature initialization?

[18:16] <ingy> greetings

[18:18] <jnthn> rakudo: sub foo() { sub bar($a) { say $a } }; bar(42); # like this?

[18:18] <p6eval> rakudo 3d2cb8: OUTPUT¬´Could not find sub &bar‚ê§  in main program body at line 11:/tmp/GDHjY41yYQ‚ê§¬ª

[18:18] <jnthn> pmichaud: Won't happen here because bar isn't visible :-)

[18:18] <pmichaud> rakudo:   our &bar;  bar(42);   sub foo() { our sub bar($a) { say $a } };  # like this.

[18:18] <p6eval> rakudo 3d2cb8: OUTPUT¬´42‚ê§¬ª

[18:19] *** SmokeMachine joined
[18:19] <pmichaud> rakudo:   our &bar;  say &bar.WHAT;   sub foo() { our sub bar($a) { say $a } };  # like this.

[18:19] <p6eval> rakudo 3d2cb8: OUTPUT¬´Sub()‚ê§¬ª

[18:19] <jnthn> pmichaud: iirc, all the our ones are set up together no matter how they are nested in the package.

[18:19] <pmichaud> rakudo:   say &bar.WHAT;   sub foo() { our sub bar($a) { say $a } };  # like this.

[18:19] <p6eval> rakudo 3d2cb8: OUTPUT¬´Sub()‚ê§¬ª

[18:19] <pmichaud> rakudo:   say bar(42);   sub foo() { our sub bar($a) { say $a } };  # like this.

[18:19] <p6eval> rakudo 3d2cb8: OUTPUT¬´42‚ê§1‚ê§¬ª

[18:19] <jnthn> yes

[18:20] <jnthn>                 @PACKAGE[0].block.loadinit.push(PAST::Op.new(

[18:20] <jnthn>                     :pasttype('bind'),

[18:20] <jnthn>                     PAST::Var.new( :name($name), :scope('package') ),

[18:20] <jnthn>                     $past

[18:20] <jnthn>                 ));

[18:20] <pmichaud> so in that case, the creation of the Code object is .loadinit

[18:20] <jnthn> Yes.

[18:20] <pmichaud> but the signature may still be lazy.  Okay.

[18:20] <jnthn> (was going to type laodinit before but wanted to make absolutely sure first :-))

[18:21] <pmichaud> but for my-scoped subs, we create a new Code object each time we enter the scope?

[18:22] <jnthn> Yes

[18:22] <jnthn> I was hoping one day we'd have .once() on PAST nodes, as once speculated a while back, to make that more efficient.

[18:22] <pmichaud> actually, it's almost correct now.

[18:22] <jnthn> Or that we'd have proto-lexpads and could set it up once in there.

[18:22] <pmichaud> it doesn't want to be set up just once.

[18:22] <jnthn> ah

[18:23] <pmichaud> we want a new Code object at each scope entry.

[18:23] <pmichaud> that's what a closure does :-)

[18:23] <pmichaud> but we would like to keep from re-building the signature each time.

[18:23] <pmichaud> i.e., we'd want the signature kept somewhere.

[18:24] <pmichaud> (once we've computed it)

[18:24] <jnthn> Ah, yes...that's what I want "once"

[18:24] <jnthn> But yes, you're right.

[18:25] <pmichaud> that's why in some sense I'd like the properties to be held in the actual Parrot sub and not each individual code object

[18:26] <pmichaud> but I think I can make this work quite nicely.

[18:28] * jnthn looks forward to seeing it :-)

[18:28] <pmichaud> well, I have to depart in ~15 for a while, but will be able to pencil-and-paper some thoughts while I'm out.

[18:29] <pmichaud> (I've found that pencil-and-paper seems to work really well for figuring out these design issues, like lists and iterators.  Don't know why.)

[18:29] *** envi^home left
[18:29] <pmichaud> okay, thanks.  will work more on it later.

[18:37] <supernovus> So, is it correct behavior that any 'our sub' declared in a core setting library will automatically be available globally even if you didn't specify 'is export' ?

[18:39] <pmichaud> no.

[18:39] *** proller left
[18:39] <pmichaud> many of the subs should probably go inside the class declarations and be declared 'is export'

[18:39] <pmichaud> rakudo has them outside as a cheat for now.

[18:41] <supernovus> pmichaud: I have some 'our sub' statements in a role (yes, a role) and they seem to leak through so that you can call them directly from any user level code.

[18:42] <pmichaud> those should not be exporting if you have them in a role.

[18:42] <pmichaud> that's definitely a bug.

[18:42] <supernovus> I didn't think so

[18:43] <pmichaud> rakudo:  role XYZ { our sub foo() { say "oops"; } };   foo()  # like this?

[18:43] <p6eval> rakudo 3d2cb8: OUTPUT¬´Could not find sub &say‚ê§  in 'foo' at line 11:/tmp/LlANweUR4_‚ê§  in main program body at line 11:/tmp/LlANweUR4_‚ê§¬ª

[18:43] <pmichaud> yes, bug.

[18:43] <supernovus> pmichaud: Yeah, like that.

[18:43] <pmichaud> please to file a ticket.  :-)

[18:43] *** Mowah left
[18:43] <pmichaud> afk

[18:43] *** rv2733 left
[18:44] <lue> so, as of now, there's no P6 way of testing if a variable is rw, right?

[18:45] <ash_> lue: yes, i think you can do it in PIR though

[18:46] <lue> I know you can. I just wanted to avoid defining := in two places, and just edit operators.pm.

[18:46] <lue> And then I got the crazy idea to avoid inline PIR until the actual binding :)

[18:47] *** mmcleric left
[18:48] *** patspam left
[18:53] <PerlJam> speaking completely from ignorance here, but it doesn't seem like it would be too difficult to add a way to introspect on traits just like you can on methods.

[18:53] <lue> (unless of course there's a way to avoid PIR at that part as well; but that would require the Hand of God)

[18:53] <lue> I agree, something like $a ~~ :rw

[18:54] <lue> (although I'm speaking from ignorance as well :P)

[18:54] <ash_> rakudo: my $a; Q:PIR {   .local pmc a, b‚ê§    a = find_lex '$a'‚ê§     getprop b, 'rw', a‚ê§    say b };

[18:54] <p6eval> rakudo 3d2cb8: OUTPUT¬´1‚ê§¬ª

[18:54] <ash_> $a is rw, :P 

[18:56] <lue> methinks that ($a ~~ :rw) is not specced though. .oO(Ah well. That can always be fixed.)

[18:57] *** constant joined
[18:57] *** constant left
[18:57] *** constant joined
[18:59] <PerlJam> lue: that could get confusing:   $file ~~ :r

[19:00] <PerlJam> is the file readable or does $file have the :r trait?

[19:02] *** rgrau joined
[19:02] <ash_> $a ~~ rw (since there is an rw role...) 

[19:03] <ash_> rakudo: use MONKEY_TYPING; augment class Mu { method rw { Q:PIR {  .local pmc self, is_rw‚ê§    self = find_lex 'self'‚ê§     getprop is_rw, 'rw', self‚ê§ %r = box is_rw } } }; my $a; say $a ~~ :rw # almost, i think its not boxing right 

[19:03] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§The opcode 'box_p_p' (box<2>) was not found. Check the type and number of the arguments‚ê§¬ª

[19:03] <ash_> or i am doing boxing wrong 

[19:03] <ash_> either way

[19:05] <slavik> ash_: if the other guy beats you, you are doing boxing wrong :P

[19:05] <ash_> slavik: thats a good point too

[19:06] <slavik> and then you need to watch more Rocky movies

[19:06] <ash_> aww man, do i have to? 

[19:06] <slavik> fine, you can watch rambo

[19:07] <lue> rakudo: say $a ~~ rw

[19:07] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Symbol '$a' not predeclared in <anonymous> (/tmp/IsbSpSp8f3:11)‚ê§¬ª

[19:07] <ash_> lol, "He eats things that would make a billy got sick" 

[19:07] <lue> rakudo: my $a = 3; say $a ~~ rw

[19:07] <p6eval> rakudo 3d2cb8: OUTPUT¬´Could not find sub &rw‚ê§  in main program body at line 11:/tmp/hfrzX2vqAP‚ê§¬ª

[19:09] <ash_> rakudo: my $a is rw = 3; # surprised this works, but i have no idea what it means....  

[19:09] <p6eval> rakudo 3d2cb8:  ( no output )

[19:10] <lue> rakudo: my $a = 3; my ($b is rw) = $a; $b = 99; say $a

[19:10] <p6eval> rakudo 3d2cb8: OUTPUT¬´3‚ê§¬ª

[19:10] <lue> rakudo: my $a = 3; my ($b is rw) := $a; $b = 99; say $a

[19:10] <p6eval> rakudo 3d2cb8: OUTPUT¬´99‚ê§¬ª

[19:10] <[particle]> rakudo: my $b is ro = 3; say $b; $b = 5; say $b;

[19:10] <lue> I get the feeling the ($b is rw) causes some hidden side-effects though...

[19:10] <p6eval> rakudo 3d2cb8: OUTPUT¬´No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:‚ê§:(Mu $child, Role $r)‚ê§:(Code $block, Any $arg?, Any :export($export)!)‚ê§:(Mu $child, Mu $parent)‚ê§‚ê§  in main program body at line 11:/tmp/iA1cPNx8HH‚ê§¬ª

[19:11] <[particle]> rakudo: my ($b is ro) = 3; say $b; $b = 5; say $b;

[19:11] <p6eval> rakudo 3d2cb8: OUTPUT¬´No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:‚ê§:(Mu $child, Role $r)‚ê§:(Code $block, Any $arg?, Any :export($export)!)‚ê§:(Mu $child, Mu $parent)‚ê§‚ê§  in main program body at line 11:/tmp/IGT7C1nhFZ‚ê§¬ª

[19:11] <ash_> rakudo: my $a ::= 3; $a := 2; 

[19:11] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§::= binding not yet implemented at line 11, near " 3; $a := "‚ê§¬ª

[19:11] <lue> apparently, ro doesn't exist.

[19:11] <[particle]> hrmm, so it seems

[19:13] <jnthn> I think $a.VAR.rw could perhaps work

[19:13] <jnthn> (if not now, it's the way that probably should)

[19:13] <jnthn> No, it's readonly

[19:13] *** Guest42363 left
[19:13] <jnthn> not ro

[19:14] <ash_> jnthn: any idea what "my $a is rw" would mean?  

[19:15] <ash_> $a's container is read/write? i guess? 

[19:15] <ash_> because  with class attributes it makes an accessor in reality, so...

[19:15] <jnthn> yes

[19:15] <jnthn> it's kinda the default though

[19:16] <ash_> well, my $a is readonly might be a better examply 

[19:16] <ash_> example* 

[19:16] <ash_> rakudo: my $a is readonly 

[19:17] <p6eval> rakudo 3d2cb8:  ( no output )

[19:17] <ash_> rakudo: my $a is readonly = 3; $a = 5; 

[19:17] <p6eval> rakudo 3d2cb8: OUTPUT¬´Cannot assign to readonly value‚ê§  in '&infix:<=>' at line 1‚ê§  in main program body at line 11:/tmp/6oT0kt8ODx‚ê§¬ª

[19:17] <ash_> oh, that does work, neat... 

[19:18] <lue> I once tried $a.rw

[19:18] *** hercynium joined
[19:18] <jnthn> That ain't going to work :-)

[19:18] <jnthn> ($a.rw)

[19:19] <jnthn> rakudo: my $a = 42; say $a.VAR.rw;

[19:19] <p6eval> rakudo 3d2cb8: OUTPUT¬´Method 'VAR' not found for invocant of class 'Int'‚ê§  in main program body at line 11:/tmp/uvUklino82‚ê§¬ª

[19:19] *** macdaddy joined
[19:19] <jnthn> ENOTYeT

[19:19] <lue> ESHOUTINGMETHODS

[19:19] *** macdaddy is now known as Guest14798

[19:24] <lue> I get the idea that .VAR is more than justs adding a bunch of methods.

[19:25] <moritz_> ~.

[19:25] <pmurias> sorear: if i want to make STD handle a symbol that is not in the CORE ($LexicalPrelude) how should i do that?

[19:25] <lue> (or else it would work right now)

[19:26] <jnthn> lue: It's meant to be a macro, not meth.

[19:26] <lue> ah, well, that explains everything! :)

[19:30] *** SmokeMachine left
[19:34] *** supernovus left
[19:35] *** SmokeMachine joined
[19:38] *** PZt joined
[19:46] *** HarryS joined
[19:48] *** SmokeMachine left
[19:59] *** tylercurtis left
[19:59] *** brill joined
[19:59] *** tylercurtis joined
[20:01] *** Guest23195 left
[20:03] <brill> What is the status of perl 6?

[20:04] <sbp> currently: awesome

[20:04] <sbp> getting: awesomer

[20:04] *** Guest23195 joined
[20:04] <sbp> perl6 is different from previous big number versions in that there is not one single reference implementation

[20:04] *** SmokeMachine joined
[20:04] <brill> Leaving Python in the dust?

[20:04] <sbp> so there are several efforts in that domain, at different stages of "completion"

[20:05] <sbp> and of course a big part of a programming language is its libraries and communities. those things are still developing, but they've already been developing for years. the community is doing better than the libraries so far

[20:05] <slavik> blizkost will fix that ;)

[20:05] <lue> (it adopts the C/C++ model)

[20:05] <slavik> or pvipvi

[20:05] <slavik> Perl5 in Perl6

[20:06] <lue> of implementations, that is.

[20:06] <slavik> we need that

[20:06] <brill> So if I need sting manipulation perl 6 is worth a look?

[20:06] *** Intensity joined
[20:06] <brill> ie as awesome as Perl 5?

[20:07] *** Transformer joined
[20:08] <jnthn> brill: Perl 6 as a language is awesome at that - more so than Perl 5. The implementation on the other hand is still very much a work in progress. A lot of stuff works but (a) slowly and (b) we're still finding and fixing bugs so it's not always a smooth ride. 

[20:09] <jnthn> brill: There's some really nice Perl 6 code written and running today though that does parsing and other bits.

[20:09] <tylercurtis> brill: Are you willing to deal with no implementation nearly completely implementing the spec, the spec being unfinished and still changing, and not-very-good performance of at least some of the implementations? That said, as jnthn said, Perl 6 is a very awesome language

[20:09] *** Transformer left
[20:11] <brill> Thanks all. This pretty much answers my question.

[20:15] <tylercurtis> brill: It's even awesome to work with already, as long as the performance problems and the mutability of the spec(and thus the risk you might have to update your code as new things come along) aren't too big of an issue for you(I wouldn't build a company on it, certainly, but for side projects and throwaway scripts, I think it's a pretty good choice).

[20:18] <brill> So you're still using Perl5 for the more important scripts?

[20:19] <ash_> jnthn: is it possible to have a custom meta class in rakudo right now? 

[20:20] *** patspam joined
[20:20] <lue> jnthn: are there any unwanted side effects of  ($b is rw) := $a  as opposed to  $b := $a    ?

[20:23] <jnthn> ash_: short answer: no

[20:24] <jnthn> ash_: long answer: the main missing piece to start playing with that is being able to declare your own package declarator to associated with a metaclass.

[20:24] <jnthn> *associate

[20:24] <jnthn> lue: Do you mean my ($b is rw) := $a; ?

[20:24] <lue> yes.

[20:25] <jnthn> brill: Can't speak for everyone, but that's the case for me.

[20:25] <lue> (I forgot the my's)

[20:25] <ash_> is it possible to give a role a custom meta class? 

[20:25] <jnthn> lue: is rw is actually the default

[20:25] <ash_> rakudo: my $a = 4; my ($b is readonly) := $a; $b = 21; 

[20:25] <p6eval> rakudo 3d2cb8: OUTPUT¬´Cannot assign to readonly value‚ê§  in '&infix:<=>' at line 1‚ê§  in main program body at line 11:/tmp/7hg1YL77xr‚ê§¬ª

[20:25] <jnthn> ash_: Actually that's how roles are done - their meta-object is a RoleHOW, not a ClassHOW.

[20:26] <lue> so, in a perfect rakudo, my ($b is rw) := $a is a perfect workaround for my $b := a ?

[20:26] <jnthn> Yes

[20:26] <jnthn> Ah, I see what you're getting at now

[20:26] <jnthn> That does a signature bind...

[20:26] <ash_> jnthn: really, my eventual goal is to make a phaser for roles and classes, INHERITED (for classes) and COMPOSED (for roles) 

[20:26] <ash_> i just was hoping i could toy with it without hacking core bits of rakudo for now 

[20:28] <lue> rakudo: my @a = (1,2,3); (@a[3..5] is rw) := @a[0..2]; say @a;

[20:28] <p6eval> rakudo 3d2cb8: OUTPUT¬´===SORRY!===‚ê§Confused at line 11, near "(@a[3..5] "‚ê§¬ª

[20:28] <ash_> lue: slices don't work right now 

[20:28] <jnthn> std: my @a = (1,2,3); (@a[3..5] is rw) := @a[0..2]; say @a;

[20:28] <p6eval> std 31527: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/lLZzqoDIRg line 1:‚ê§------> [32mmy @a = (1,2,3); (@a[3..5] [33m‚èè[31mis rw) := @a[0..2]; say @a;[0m‚ê§    expecting any of:‚ê§ bracketed infix‚ê§  infix or meta-infix‚ê§      statement modifier loop‚ê§Parse failed‚ê§FAILED 00:01

[20:28] <p6eval> ..115m‚ê§¬ª

[20:29] <jnthn> Also it's a parse error

[20:29] *** pmurias left
[20:29] <ash_> std: my @a = 1, 2, 3; @a[3..5] := @a[0..2]; 

[20:29] <p6eval> std 31527: OUTPUT¬´ok 00:01 112m‚ê§¬ª

[20:30] <lue> that's what I'd like to do someday :) . (stupid NES and it's "shadow memory" *grumble*)

[20:30] <lue> so, apparently, I'll have to wait for/go code the real thing.

[20:31] <tylercurtis> brill: I don't really have anything I work on that is in the "important enough that Perl 6 is too risky" category, so I can't really answer that. Most of my time is spent on my GSoC project, where I can't use Perl 6 because Perl 6 isn't available in the Parrot repository. There are a few side projects I'm planning to work on that I won't use Perl 6 for, but that's because I plan to eventually develop into a commercial project. My latest side project is

[20:31] <tylercurtis> written in Perl 6, but given that it's a tool for writing articles including Perl 6 example code, that's unsurprising. I did use Perl 5 instead of Perl 6 for a very trivial script yesterday, but that's because I remembered how @ARGV in Perl 5 interpolated but didn't remember how @*ARGS interpolates into strings in Perl 6 and didn't feel like checking.

[20:32] *** brill left
[20:32] <jnthn> @*ARGS[]

[20:33] *** clintongormley left
[20:34] *** Su-Shee left
[20:34] <ash_> jnthn: do you think it would be difficult to add a phaser? or do you know of anything that would be a problem, if I added one to rakudo for INHERITED and COMPOSED 

[20:34] *** patspam left
[20:35] <jnthn> ash_: Well, it's only a problem if it's not in the spec.

[20:35] <jnthn> ;-)

[20:36] <tylercurtis> jnthn: for some reason I was thinking that the string created by "@*ARGS[]" would be different from Perl 5's "@ARGV".

[20:36] <jnthn> ash_: By all means go ahead and try it out though

[20:36] <ash_> jnthn: i was going to modify the spec too, i just wanted to prototype it also to see how it would work, or where it might be difficult to use 

[20:36] <lue> afk

[20:36] <jnthn> ash_: I think from previous discussions it's generally felt that it's OK if something along those lines ends up spec'd.

[20:37] <jnthn> ash_: Oh, prototype first is fine. :-)

[20:37] <jnthn> Even encouraged. :-)

[20:37] <jnthn> Just that if I apply it to Rakudo I'd like it to be spec'd at that point. ;-

[20:37] <ash_> i can modify the spec too, i don't mind doing that, although i am a bit more hesitant, because its really easy to fork rakudo and throw it away if i fail miserably 

[20:38] <jnthn> Right, so fork and try it first, and then we can tie up the spec and merging later on. :-)

[20:48] <tylercurtis> Does anyone know a way to get Emacs cperl-mode to syntax highlight Perl 6 POD properly? Whenever I view a file with it, it doesn't realize that the POD ends.

[20:51] <ash_> is that the one from the pugs repo?

[20:51] <ash_> or is that the modern cperl-mode from perl's main repo? 

[20:53] <tylercurtis> ash_: I don't really remember.

[20:53] <tylercurtis> ash_: does that mean that one of those does do it properly?

[20:54] *** masak joined
[20:54] <masak> ahoy, #perl6!

[20:55] * masak goes into Yapsi release mode

[20:55] *** patspam joined
[20:56] <dalek> yapsi: 4037362 | masak++ |  (3 files):

[20:56] <dalek> yapsi: [Yapsi] implemented 'while' loops

[20:56] <dalek> yapsi: Fairly straightforward after having done 'if' statements -- the necessary

[20:56] <dalek> yapsi: SIC instructions turned out to be just the same ones. Also added prefix:<-->

[20:56] <dalek> yapsi: so that it's easier to write 'while' loops that halt.

[20:56] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/40373625e528f41afe6835b437fd48dfbbf10e5f

[20:57] <masak> if statements and while loops, all in one day. :)

[20:57] <colomon> \o/

[20:57] <masak> oh right, I promised myself to write a docs/LOLHALP file, with low-hanging fruit for interested people.

[20:57] * masak does that now

[20:59] <ash_> tylercurtis: I am not sure, i haven't checked them recently, but http://svn.pugscode.org/pugs/util/cperl-mode.el is the one in pugs (according to svn last updated on 2010-05-12) 

[21:00] *** skids left
[21:00] *** g3oM1 joined
[21:04] <tylercurtis> ash_, thanks. the one from the pugs repo works!

[21:04] <ash_> cool 

[21:06] <masak> rakudo: my $a is readonly = 3; # should "real" Perl 6 allow the assignment here?

[21:06] <p6eval> rakudo 3d2cb8: OUTPUT¬´Cannot assign to readonly value‚ê§  in '&infix:<=>' at line 1‚ê§  in main program body at line 11:/tmp/M6tRHTv2Cs‚ê§¬ª

[21:07] *** patspam1 joined
[21:07] *** patspam left
[21:07] *** patspam1 is now known as patspam

[21:07] <ash_> masak: i'd think so... how else will it get a value? 

[21:08] <masak> ash_: that's what I'm thinking, too.

[21:08] <masak> unless the 'readonly' trait is to be taken *very* literally :)

[21:09] <ash_> my $var_might_as_well_be_Mu is readonly; 

[21:09] <masak> well, Any, but point taken. :)

[21:11] <cxreg> does 'prompt' have a noecho mode? :)

[21:12] <masak> cxreg: not by default.

[21:12] *** mand joined
[21:15] *** Guest93363 left
[21:25] <masak> I'd be delighted if some people would like to proof-read http://github.com/masak/yapsi/blob/master/doc/announce/2010.07

[21:26] *** mand left
[21:26] <dalek> yapsi: 758338d | masak++ | README:

[21:26] <dalek> yapsi: [README] updated

[21:26] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/758338d8ec46db68f324fdabbb5d5e5cfe906731

[21:26] <dalek> yapsi: 89a8f27 | masak++ | doc/ (2 files):

[21:26] <dalek> yapsi: [docs] added announcement and LOLHALP

[21:26] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/89a8f27f6c6c3ad842bd8165e111adbee5793bc5

[21:27] <sbp> masak: docs/LOLHALP - heh!

[21:27] <masak> :)

[21:27] *** tadzik left
[21:28] <masak> think of Yapsi as Rakudo's "spunky little sister"...

[21:28] <sbp> at first I thought you really wanted this proofread

[21:29] <sbp> but now I suspect you want praise

[21:29] <sbp> and you deserve it. that is a very entertaining release announcement

[21:29] <sbp> masak++

[21:29] <masak> sbp: thanks. I certainly didn't have praise in mind, but I'm glad to get it.

[21:30] <sbp> if people don't download this release, they must be a few pecans short of a byte

[21:30] <masak> :D

[21:31] <tylercurtis> masak: Yapsi's runtime will require a working Perl 6 implementation to run any code compiled with it, right? Any plans for someday branching off into a full-fledged VM implementation(with the core implemented in a subset like Pypi, Rubinius, Squeak, etc.)? (I'm going to be afk for a while but you don't have to wait until I return to answer; 'tis just a little throw-away question of curiosity)

[21:31] * masak creates the .tar.gz download

[21:32] <masak> tylercurtis: who knows? the more crazy stuff we manage to pull into the Yapsi project, the more people will likely take an interest and help keep it alive.

[21:32] <masak> I'm increasingly realizing that some things are really easy to implement really soon; things that Rakudo doesn't have yet. we should probably endeavour to put some such things in.

[21:33] <masak> some of the more fun phasers, for example.

[21:33] <colomon> masak: just got ABC to build with a simple (but ugly) rewrite of the one troubled regex.

[21:33] <masak> colomon: cool! you rock!

[21:33] <colomon> bad news is I think all the existing tests will fail without the ability to use things like <ABC::basenote> in regexes.

[21:34] <colomon> not having a way to test individual grammar rules by themselves makes life hard...

[21:34] <masak> colomon: yeah. feels like a deplorable regression in Rakudo.

[21:34] <colomon> +1

[21:34] <masak> colomon: hm, or maybe that syntax is gone entirely?

[21:34] <pmichaud> back again

[21:35] <colomon> oh?

[21:35] <masak> pmichaud: will <Foo::bar> ever work again in Rakudo?

[21:35] <masak> or is that syntax ancient?

[21:35] <masak> I mean, methods aren't our-scoped anymore.

[21:36] <colomon> (in a grammar, he means)

[21:36] <pmichaud> "It's official

[21:36] <pmichaud> because there's no official definition of "official"."   LOL

[21:36] <masak> well, in a regex outside of a grammar, too.

[21:37] <masak> :)

[21:38] <ash_> rakudo: class bar { our sub foo { 'foo' }}; say bar::foo; role foo { our sub bar { 'bar' } }; say foo::bar;

[21:38] <p6eval> rakudo 3d2cb8: OUTPUT¬´foo‚ê§Can not find sub foo::bar‚ê§  in main program body at line 1‚ê§¬ª

[21:38] <ash_> is there a reason i can' call the sub in the role? 

[21:38] *** whiteknight joined
[21:38] <masak> ash_: heh.

[21:39] <masak> ash_: that looks like a bug to me.

[21:39] <masak> but jnthn would know for certain.

[21:39] <ash_> i thought role's still made a namespace 

[21:39] * jnthn reaches for his dictionary and prepares to read masak's Yapsi release announcement

[21:40] <jnthn> ash_: It's, erm, awkward. :-)

[21:40] *** ruoso left
[21:40] <jnthn> ash_: our scoped stuff in a role is horrible.

[21:40] <pmichaud> masak: I'm looking up the rule-in-another-grammar syntax now

[21:40] <masak> jnthn: no miens this time, I promise. :)

[21:40] <pmichaud> I don't remember if it's   <Foo::bar>  or <Foo.bar> now (or something else)

[21:40] <jnthn> ash_: Consider if the role was parametric and the our scoped sub referred to a type parameter.

[21:40] <jnthn> er, method

[21:40] <jnthn> oh, sub

[21:40] <jnthn> well either way

[21:41] *** patspam left
[21:42] <colomon> masak: I don't see any sign of <Foo::bar> in S05. :\

[21:42] <masak> colomon: let's hope pmichaud comes back with something.

[21:42] <ash_> jnthn: so..... role foo[::T] { sub bar { say T }; foo[Int]::bar  # wouldn't work? 

[21:42] <ash_> :P

[21:42] <colomon> <ABC.basenote> doesn't work in practice.

[21:43] <pmichaud> colomon: why not?

[21:43] <jnthn> ash_: Well no way there because the sub is lexically scoped. :P

[21:43] <ash_> oops

[21:43] <colomon> pmichaud: I mean, I tried it and it doesn't work.

[21:43] <pmichaud> std:  / <XYZ::foo> /

[21:43] <p6eval> std 31527: OUTPUT¬´ok 00:01 112m‚ê§¬ª

[21:43] <ash_> role foo[::T] { our sub bar { say T }; foo[Int]::bar

[21:43] <jnthn> ash_: I'm not sure if that'll parse though

[21:43] <pmichaud> std:  / <XYZ.foo> /

[21:43] <p6eval> std 31527: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[21:43] <jnthn> std: role foo[::T] { our sub bar { say T }; foo[Int]::bar

[21:43] <p6eval> std 31527: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused at /tmp/nNLqZkjII4 line 1:‚ê§------> [32m[::T] { our sub bar { say T }; foo[Int]:[33m‚èè[31m:bar[0m‚ê§    expecting any of:‚ê§     coloncircumfix‚ê§   signature‚ê§Parse failed‚ê§FAILED 00:01 114m‚ê§¬ª

[21:43] <ash_> std: role foo[::T] { our sub bar { say T }; foo[Int]::bar # just checking 

[21:43] <p6eval> std 31527: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused at /tmp/8vfzcz8YD7 line 1:‚ê§------> [32m[::T] { our sub bar { say T }; foo[Int]:[33m‚èè[31m:bar # just checking[0m‚ê§    expecting any of:‚ê§     coloncircumfix‚ê§   signature‚ê§Parse failed‚ê§FAILED 00:01 114m‚ê§¬ª

[21:43] <ash_> oh well

[21:43] <pmichaud> std doesn't seem to provide much insight here.

[21:43] <jnthn> ash_: If anything is going to work though, that will be it.

[21:44] <jnthn> ash_: But it's probably going to have to actually make the role exist and then .WHO it or some such.

[21:44] <pmichaud> aha

[21:44] <pmichaud> answer is Pm-2 in pm.txt

[21:44] <ash_> alright, so, in theory a our sub in a role should work, one day 

[21:45] <jnthn> ash_: Somehow yes

[21:45] <ash_> kk, just curious 

[21:45] <jnthn> ash_: I'm not quite sure exactly how it should work off hand

[21:45] <pmichaud> http://svn.pugscode.org/pugs/misc/pm.txt

[21:45] <jnthn> There'll be a way though.

[21:46] <colomon> pmichaud: so it's just a matter of getting it implemented, eh?

[21:46] *** Guest14798 left
[21:46] <pmichaud> colomon: smop, yes.

[21:46] *** pyrimidine left
[21:46] *** patspam joined
[21:46] <pmichaud> std:   / <.XYZ::foo> /   # also curious

[21:46] <p6eval> std 31527: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[21:47] <ash_> maybe i'll pester TimToady about what it means, or if he has any thoughts on role_name[Type]::foo for calling a parametric role with an our scoped sub

[21:47] <colomon> pmichaud: is that ironic smop or actual smop?  ;)

[21:47] <pmichaud> colomon: don't know which, yet.

[21:47] <colomon> ah

[21:47] <jnthn> masak: Wow I understood every word.

[21:49] *** masak left
[21:49] <dalek> yapsi: f32fadd | masak++ | doc/announce/2010.07:

[21:49] <dalek> yapsi: [announce/2010.07] fixed tiny typo

[21:49] <dalek> yapsi: The email went away with the typo in it, but the blog post was corrected

[21:49] <dalek> yapsi: in time. Oh well.

[21:49] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/f32fadd06d8c3165157b62a90d75e27626fac351

[21:49] *** masak joined
[21:51] * masak stands down Yapsi release mode

[21:52] <pmichaud> masak++ # regular yapsi releases

[21:52] <pmichaud> why is yapsi still tied to alpha, ooc?

[21:52] <masak> pmichaud: at one point, it was waiting for GGE.

[21:52] <masak> pmichaud: now, there's no reason anymore, really.

[21:52] <pmichaud> masak: wfm

[21:53] <masak> pmichaud: but it's... strangely nice... not to have to Red Queen all the time. not used to that with my Perl 6 software.

[21:53] <arnsholt> "Red Queen"?

[21:53] <masak> arnsholt: http://en.wikipedia.org/wiki/Red_Queen's_race

[21:55] <arnsholt> Ah, right. I need to read those books

[21:55] <masak> you do.

[21:55] <masak> and with that, I bid you folks a Good Night(TM).

[21:55] <dalek> yapsi: f2020b2 | masak++ | lib/Yapsi.pm:

[21:55] <dalek> yapsi: [Yapsi] bumped SIC version

[21:55] <dalek> yapsi: Between releases, the SIC version is always the version number of the

[21:55] <dalek> yapsi: upcoming release.

[21:55] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/f2020b201f16113a3fe83376cb94ef07afbcf283

[21:56] <masak> tomorrow, I'll go to jnthn++'s place, and we'll have a hackathon. \o/

[21:56] *** g3oM1 left
[21:57] <tylercurtis> masak: if you're looking for a really crazy idea to get pulled into Yapsi, native code compilation works for the Lisp folks. ;)

[21:58] *** christine left
[21:58] <masak> tylercurtis: I have been toying with the idea to make a C runtime...

[21:59] <masak> tylercurtis: it would blow all the other implementations out of the water. unfortunately, it'd also be increasingly difficult to keep up-to-date with the regular Yapsi runtime, the one written in Perl 6.

[21:59] <jnthn> omg masak is coming!

[22:00] <jnthn> :-)

[22:00] <masak> tylercurtis: if you really mean "compilation", then I'm afraid we're already talking about a subset of Perl 6. cf eval.

[22:00] <masak> jnthn: see you tomorrow evening. 'night.

[22:00] <masak> o/

[22:00] *** masak left
[22:04] *** christine joined
[22:09] *** Guest23195 left
[22:14] *** alester left
[22:17] <pmichaud> jnthn: I think I figured out that it's just as easy to set a lazysig property on the Parrot sub as it is to include it as an attribute to a Code wrapper.

[22:20] *** SmokeMachine left
[22:20] <pmichaud> (and still not have it be done at .loadinit)

[22:21] <pmichaud> then by using setprophash and getprophash, we can make sure that all clones of a given Parrot sub end up with the same properties.

[22:21] <pmichaud> so that once the signature is set for one of the clones, it's set for all.

[22:24] <pmichaud> jnthn: would it be reasonable to have .arity and .count stored as part of a Signature object instead of a Code object?

[22:24] <pmichaud> afk for a moment, walk.

[22:29] <jnthn> pmichaud: Well, a Signature holds all the stuff needed to compute arity and count

[22:29] <jnthn> pmichaud: What do you mean by "stored"?

[22:29] <pugssvn> r31528 | sorear++ | [STD] A hook, to allow %*LANG to be overriden, must come AFTER %*LANG IS INITIALIZED.  Who would have thought before does no good? 

[22:30] <pmichaud> Signature has $!arity and has $!count

[22:30] <pmichaud> and Signature.arity / Signature.count methods that cache the results

[22:30] <pmichaud> right now we handle .arity / .count in Code

[22:30] <pmichaud> but since we'll have clones of Code objects floating about, it seems better to cache that information in the thing that doesn't get copied

[22:31] <pmichaud> (and arity/count is really a property of a signature more than a code object)

[22:31] <pmichaud> of course, we'll keep Code.arity and Code.count, but they can delegate to the Signature

[22:32] <pmichaud> related question -- currently the lazy_sig_init block creates a lowlevsig, yes?

[22:33] <jnthn> pmichaud: +1 to delegating .count and .arity to Signature and caching it.

[22:33] <jnthn> pmichaud: (lowlevel) yes

[22:33] <pmichaud> perfect

[22:33] <jnthn> pmichaud: Those are very cheap to create

[22:33] <jnthn> pmichaud: And normally all we need unless folks go introspecting.

[22:33] <pmichaud> right.

[22:34] <pmichaud> this will preserve that.

[22:34] <pmichaud> oh, wait

[22:35] <pmichaud> (re-reading backscroll)

[22:35] <pmichaud> 17:54 <jnthn> pmichaud: Actually the code that does it lives in the dynop bind_signature

[22:36] <jnthn> pmichaud: "the code" = what detects we need to build a signature

[22:36] <jnthn> And triggers it

[22:36] <jnthn> Not the actual building.

[22:36] <pmichaud> right

[22:36] <pmichaud> it triggers it by calling Code.signature ?

[22:38] <pmichaud> perl6.ops:612

[22:38] <jnthn> Correct.

[22:38] <jnthn> Though that probably builds more than it needs to...

[22:38] <pmichaud> so, that builds a Signature object even though it's not needed for introspection

[22:38] <pmichaud> right

[22:38] <jnthn> Yeah, mentioned that earlier

[22:38] <pmichaud> I'm going to refactor that to have it just build the llsig

[22:38] <jnthn> We've room for optimization there.

[22:38] <jnthn> OK, good.

[22:39] <jnthn> Not sure why I didn't get around to that before now, it's probably an easy win. :-)

[22:39] <pmichaud> so, the refactoring I'm thinking of keeps all of the llsig handling in the Parrot sub, and the high-level Perl 6 introspection handling in the Code object

[22:39] *** tedv joined
[22:40] <pmichaud> and if one doesn't do much introspection, then the Code object does little more than provide a handle to $!do (and handle closure cloning, which becomes trivial)

[22:40] <jnthn> wfm

[22:40] <pmichaud> and we preserve the lazy build of llsigs and lazier build of Signatures

[22:40] <jnthn> *nod*

[22:41] <pmichaud> okay.  I think we should get some speed wins.

[22:41] <pmichaud> we'll certainly build much less.

[22:41] <pmichaud> and closures will work.  :-)

[22:42] *** timbunce left
[22:42] <jnthn> \o/

[22:42] <pmichaud> if I haven't mentioned it lately, your code continues to be easy to read and update :)

[22:42] <pmichaud> okay, time for a walk, then I'll start tearing out stuff and refactoring (in a branch, of course)

[22:43] *** hercynium left
[22:45] *** amkrankruleuen joined
[22:46] <jnthn> pmichaud: That's good to know. At least if it's not perfect code, it's easy for others to improve. :-)

[22:49] *** cono left
[22:49] *** cono joined
[22:59] *** hercynium joined
[22:59] *** rgrau left
[23:05] *** cdarroch left
[23:05] *** rgrau joined
[23:07] *** Ross left
[23:07] *** sftp left
[23:09] <pmichaud> jnthn: would it be painful if I were to rename existing instance of "signature" to "llsig" or something?

[23:09] <pmichaud> to make it easier to distinguish when we're talking about a lowlevelsignature versus a Perl 6 Signature ?

[23:10] <jnthn> pmichaud: I hope not.

[23:10] <jnthn> (I hope it won't be painful, that is.)

[23:10] <pmichaud> okay

[23:10] <pmichaud> I think that'll be a bit easier to keep straight.

[23:10] <jnthn> pmichaud: Until you got confused over it today, I honestly never saw it as confusing. Now I can't see how it wouldn't be confusing.

[23:10] <jnthn> :-)

[23:10] <pmichaud> right now when I see "signature" it's hard for me to know if it's a lowlev sig or a ... right :)

[23:11] <dalek> niecza: 4c90cd6 | sorear++ |  (3 files):

[23:11] <dalek> niecza: Start Niecza::Grammar.

[23:11] <dalek> niecza: We still don't have the NIL parser, but subclassing technology works.  An

[23:11] <dalek> niecza: installable STD would help a lot.

[23:11] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4c90cd6f358abd90da3a8fcf5c9f50ed3f85f94b

[23:11] <pmichaud> .... and Parrot_pcc_get_signature actually obtains a Parrot signature, which is different from lowlevelsignature and Rakudo's Signature, yes?

[23:11] <jnthn> And it's naming is *really* f**ked up.

[23:11] <pmichaud> Yes, that too.  :-)

[23:12] <jnthn> Because it actually gets the equivalent of a *capture*.

[23:12] <jnthn> But call captures and contexts were merged so today it probably gets a CallContext

[23:13] <lue> hai again

[23:13] <jnthn> hellue!

[23:13] <pmichaud> and Perl6::Compiler::Signature actually generates llsigs, right?

[23:14] <jnthn> Correct

[23:14] <pmichaud> okay, got it.  Thanks.

[23:14] <lue> [ I spy complaints about Parrot ... so what's new? :) ]

[23:14] <jnthn> lue: It's OK, there were complaints about my confusing code too for good balance. ;-)

[23:17] <pmichaud> sub_signature is also a llsig?

[23:17] <jnthn> Yes

[23:19] <lue> .oO(I'll avoid tipping the scale again by not mentioning) PMCs.  .oO(Oops.)

[23:21] *** macdaddy joined
[23:21] *** macdaddy is now known as Guest87395

[23:31] <sorear> PMC = evil

[23:31] <sorear> under what circumstances does a class have an associated namespace?

[23:31] <cxreg> i wonder if you can use ccache with rakudo

[23:37] *** rgrau left
[23:45] *** ash___ joined
[23:47] *** ash_ left
[23:47] *** ash___ is now known as ash_

[23:53] <tylercurtis> tell masak If someone develops a native-code compiler for Perl 6, it would hardly be the first language with both eval and native-code compilation. Various Lisps are the most obvious examples.

[23:54] *** Psyche^ joined
[23:54] <sorear> phenny: tell tylercurtis to address phenny

[23:54] <phenny> sorear: I'll pass that on when tylercurtis is around.

[23:55] <pmichaud> tylercurtis: I'm pretty certain masak++ knows that already.  :)

[23:58] *** Patterner left
[23:58] *** Psyche^ is now known as Patterner

