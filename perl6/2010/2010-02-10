[00:00] <TimToady> it again has the feel of something being introspected that should Just Work...

[00:00] <jnthn> Well, it usually does.

[00:01] <jnthn> Well

[00:01] <TimToady> there's some kind of multi-ish thing that's getting dispatched to that is outside the role itself, maybe

[00:01] <jnthn> If I add role R { } to my collection...

[00:01] <jnthn> then I can do class Foo does R { } and it really means class Foo does R[] { }

[00:03] <jnthn> But I've not got a good way to write trait_mod:does to know that it should take R (the general thing) and actually resolve it to a particular role compose R[].

[00:03] <TimToady> as in, call the hidden R-doer routine with ()

[00:04] <TimToady> something curry-ish, like .assuming()

[00:04] <jnthn> I'm not sure that helps, given that if somebody wrote class Foo does R[Int] { } then by the time we get to the trait-mod, the thingy that makes it specialized has alreaedy happened.

[00:04] <TimToady> only that doesn't limit to ()

[00:05] <TimToady> I'm probably still missing something about what you're trying to do that is the immediate cause

[00:05] <jnthn> Well, that dispatch thingy kinda *is* the thing I'm talking about I guess, when I refer to the group of all roles under the name R.

[00:06] <jnthn> OK, let me step back and explain the current model I have.

[00:07] <jnthn> When I wrote: role R { }; role R[::T] { }; role R[::T1, ::T2] { } then one thing gets installed in the namespace/lexpad under R. It knows about all of the variants, and internally contains a Multi that it just calls to pick the variant.

[00:07] *** k23z__ joined
[00:08] <jnthn> Each of those multis serves as a kinda "role factory", and uses RoleHOW to build up a role, and through closure semantics it's methods end up seeing the current parameters given to the role.

[00:08] <jnthn> Suppose I write:

[00:09] <jnthn> class Foo does R { }; class Foo does R[Int] { }

[00:10] <jnthn> I have a trait_mod:does, but in one case it has R - the thing that knows about all of the roles. What we *want* is to compose R[] - the first parameterless variant. In the second case, we already did that, and we have a role ready to compose.

[00:10] <jnthn> My problem is what trait_mod:does should look like here.

[00:10] <jnthn> We could say that doing [] on any role (e.g. not the factory of them) is just identity.

[00:10] *** colomon joined
[00:10] <TimToady> zennishly

[00:11] <jnthn> And trait_mod:does just always does that to what it's given.

[00:11] <TimToady> well, [] is more like () then a zen slice, so an explicit [] would explicitly mean no args

[00:12] <jnthn> TimToady: Yeah.

[00:12] <jnthn> We could pull it off that way.

[00:12] <jnthn> The trickier bit is that we probably want R ~~ Role and R[Int] ~~ Role

[00:12] <TimToady> I suppose we could say that any role that has args must be used with [], and R *always* means the un-called multi

[00:13] <TimToady> and blow up if you say 'class Foo is R {...}'

[00:13] <jnthn> Yeah, but do we really want to make people write class Foo does R { }

[00:13] <TimToady> with some appropriate message

[00:13] <TimToady> they'd have to say class Foo does R[] if R has parameters

[00:13] <jnthn> I mean, parametric roles are useful, I'm just not convinced they're the Common Case.

[00:13] <jnthn> "has parameters"?

[00:14] <jnthn> There may be a role R { ... } and a role R[::T] { ... }

[00:14] <TimToady> perhaps an error, and you have to say role R[] for the first one

[00:14] <TimToady> could even require 'multi' keyword

[00:15] <jnthn> It'd resolve the ambiguity perhaps, but I'm not sure if I like forcing people to write [] after all their role names when they do them.

[00:15] <TimToady> only the ones that want parameters

[00:15] <jnthn> Ah, so

[00:15] <TimToady> does Positional is still just fine

[00:15] <TimToady> maybe

[00:15] <TimToady> bad example perhaps

[00:16] <jnthn> Well, Positional is role Positional[::T = Mu] { ... } I guess.

[00:21] <TimToady> anyway, does can probably do something special in the context of requiring an instantiated role, so it can assume [], whereas bare rvalue R is always the multi name, maybe

[00:22] *** kensanata left
[00:23] <jnthn> Something like that probably works.

[00:23] <jnthn> Should both R ~~ Role and R[Int] ~~ Role be true?

[00:24] *** pmurias left
[00:25] <TimToady> probably, but one of them could also respond to a more specific type

[00:26] <TimToady> AbstractRole, if it's the one that needs [] as rvalue

[00:26] <TimToady> or some such

[00:26] *** eternaleye left
[00:26] <jnthn> Yay

[00:26] <jnthn> Knowing that this is reasonable helps a lot.

[00:26] <jnthn> Thanks.

[00:26] <TimToady> or maybe ConcreteRole for the other :)

[00:27] <jnthn> :-)

[00:27] <TimToady> ReadyToRole

[00:27] <jnthn> :D

[00:27] * TimToady hides in shame

[00:27] *** stephenlb left
[00:27] <jnthn> It's OK, telling people to "Role up, role up" to one of my talks on roles was just as shameful. :-)

[00:28] <TimToady> HardRoles :)

[00:29] <TimToady> CastRoles

[00:30] <TimToady> to go back to the original metaphor

[00:30] <TimToady> well, it's the class that is the actor, really, so that doesn't work

[00:31] *** stephenlb joined
[00:31] <TimToady> it's more like Bill does Clown vs Bill does Bozo

[00:32] <TimToady> Bill does Clown[Bozo] I should say

[00:32] <jnthn> :-)

[00:32] *** bbkr left
[00:32] *** bbkr joined
[00:33] *** go|dfish left
[00:33] <TimToady> Comic: that's one Bill too many...

[00:34] *** andy2 joined
[00:34] <TimToady> Sidekick: no, duck typing is one Bill too many...

[00:35] <TimToady> Comic slugs Sidekick, who responds "Mu"...

[00:37] * TimToady 's arm and fist both hurt now.

[00:39] *** eternaleye joined
[00:45] *** go|dfish joined
[00:46] *** eternaleye left
[00:49] * TimToady apologizes for all the wise-quacks, and ducks.

[00:49] <colomon> jnthn++: class Whatever { ... } works great in operators.pm now.  Danke

[00:49] *** eternaleye joined
[00:50] <jnthn> Bitte.

[00:52] *** PZt joined
[00:53] *** cognominal left
[00:54] *** cognominal joined
[00:56] *** orafu joined
[01:03] <jnthn> colomon: BTW, does the multi fix unblock getting various trig bits back?

[01:04] <colomon> It should be a good start, anyway.  I'll try to take a proper look at it soon.

[01:04] <colomon> I was thinking I'd try to get more Range tests working first, then look at getting Rats back in shape, then trig.

[01:05] <jnthn> Sounds like a good plan.

[01:06] <dalek> rakudo/ng: cf189ea | (Solomon Foster)++ | src/core/operators.pm:

[01:06] <dalek> rakudo/ng: Start at a infix:<...>(@lhs, Whatever) implementation, which utterly fails to be called at the moment.

[01:06] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/cf189ea940dbf242263c111186000776e35c8a47

[01:10] *** cdarroch left
[01:11] *** cl58 joined
[01:11] * cl58 needs moritz_

[01:11] <cl58> moritz_: ping (come back from away!)

[01:15] *** eternaleye left
[01:18] *** drbean joined
[01:23] *** eternaleye joined
[01:24] *** johnz joined
[01:25] *** ihrd joined
[01:25] *** mssm left
[01:33] <jnthn> OK, sleep time for me... o/

[01:41] <colomon> \o

[01:44] *** synth joined
[01:45] *** andy2 left
[01:48] <colomon> ng: my @a = 1, 4; (@a ... *).GrabAndSay(10);

[01:48] <p6eval> ng cf189e: OUTPUT«sh: ./perl6: No such file or directory␤»

[01:50] <colomon> ng: my @a = 1, 4; (@a ... *).GrabAndSay(10);

[01:50] <p6eval> ng cf189e: OUTPUT«sh: ./perl6: No such file or directory␤»

[01:52] <dalek> rakudo/ng: 0af588e | (Solomon Foster)++ | src/core/operators.pm:

[01:52] <dalek> rakudo/ng: Add two more cases for the series operator.

[01:52] <dalek> rakudo/ng: Have discovered that even though it doesn't get dispatched if you write 1, 3, 5 ... *, it works fine for testing purposes to say my @a = 1, 3, 5; @a ... *.

[01:52] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/0af588e62c693fe6efba7518ffb790c411fe48ef

[02:03] *** Lorn left
[02:03] *** ihrd left
[02:04] *** lichtkind left
[02:07] <pugs_svn> r29669 | lwall++ | [STD] delete old p5=> that masak++ noticed 

[02:07] <colomon> ng: my @a = 1, 4; (@a ... *).GrabAndSay(10);

[02:07] <p6eval> ng cf189e: OUTPUT«1␤4␤7␤10␤13␤16␤19␤22␤25␤28␤»

[02:07] <colomon> ng: my @a = 1, 4, 16; (@a ... *).GrabAndSay(10);

[02:07] <p6eval> ng cf189e: OUTPUT«Method 'GrabAndSay' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[02:08] <colomon> ng: my @a = 1, 2, 4; (@a ... *).GrabAndSay(10);

[02:08] <p6eval> ng cf189e: OUTPUT«Method 'GrabAndSay' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[02:08] <TimToady> colomon: note that .batch(10) is already specced to do the grabbing, though not the saying

[02:08] <colomon> ah, it hasn't caught up with my latest patch yet.

[02:09] <colomon> TimToady: that's Iterator.batch?

[02:09] <TimToady> yes

[02:09] *** lest_away is now known as lestrrat

[02:09] <colomon> TimToady: hmmm....

[02:10] *** meppl left
[02:11] <colomon> ng: my @a = 1, 2, 4; (@a ... *).getbatch(10).perl.say

[02:11] <p6eval> ng cf189e: OUTPUT«Method 'getbatch' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[02:11] <colomon> ng: my @a = 1, 4; (@a ... *).getbatch(10).perl.say

[02:11] <p6eval> ng cf189e: OUTPUT«(28, 4, 7, 10, 13, 16, 19, 22, 25, 28)␤»

[02:12] <colomon> umm.....

[02:12] <colomon> ng: my @a = 1, 4; (@a ... *).GrabAndSay(10);

[02:12] <p6eval> ng cf189e: OUTPUT«1␤4␤7␤10␤13␤16␤19␤22␤25␤28␤»

[02:12] *** lue joined
[02:13] <TimToady> I think I see how that went wrong :)

[02:13] <colomon> TimToady: is "take $i.WHICH" an official way to return the value rather than the variable itself, or just a notion?

[02:14] <TimToady> a value type always returns its value for WHICH

[02:14] <TimToady> it wouldn't work for objects

[02:14] *** Austin joined
[02:15] <colomon> Thank you.

[02:15] *** cl58 left
[02:15] *** hercynium left
[02:15] <colomon> was .getbatch an earlier name for .batch, or is there a subtle difference?

[02:15] *** cl58 joined
[02:15] *** Austin left
[02:16] <TimToady> yes, decided batch was verby enough for the other dimension from '' vs 'obj'

[02:16] <TimToady> where '' is short for 'flat'  :)

[02:17] <TimToady> so 'get' is really getflat, and batch is batchflat

[02:18] <TimToady> and 'obj' is short for 'lumpy' :)

[02:19] <TimToady> still wonder whether we should have gone for smooth and crunch instead...

[02:19] <TimToady> *crunchy

[02:20] <TimToady> dinner &

[02:22] <dalek> rakudo/ng: 63cafa9 | (Solomon Foster)++ | src/core/operators.pm:

[02:22] <dalek> rakudo/ng: Fix to infix:<...> so that it returns the first value rather than a reference to the loop variable.

[02:22] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/63cafa95f6ee429ab7c357fbf882fdc3d251ac36

[02:23] <lue> Just out of curiosity, why is the bot named 'dalek'?

[02:24] <eternaleye> lue: Someone likes Dr. Who?

[02:25] <lue> what I was thinking. But it makes me scared on ng a little :)

[02:25] <lue> 'of', not 'on'

[02:29] <lue> If I ever push a commit to rakudo/ng, I'll make the comment begin with EXTERMINATE!

[02:55] <colomon> rakudo: say ~("Y".."AB")

[02:55] <p6eval> rakudo 1d4928: OUTPUT«Y Z AA AB␤»

[02:56] <colomon> ng: say ~("Y".."AB")

[02:56] <p6eval> ng 9fa0fd: OUTPUT«␤»

[02:58] *** hercynium joined
[02:59] *** JimmyZ joined
[03:06] *** cognominal left
[03:09] *** ShaneC left
[03:14] *** stephenlb left
[03:16] *** zorgnax left
[03:27] *** cotto_working left
[03:28] *** cotto_working joined
[03:29] * colomon is wondering what it means that his last push has not been announced here, nor does it show up in the commits list on github.

[03:29] <colomon> ng: say 1

[03:29] <p6eval> ng 9fa0fd: OUTPUT«1␤»

[03:29] <colomon> looks like p6eval has it, however, so I guess it must have left my laptop.

[03:29] *** LylePerl left
[03:29] <colomon> ng: my @a = 1, 2, 4; (@a ... *).batch(10).perl.say

[03:29] <p6eval> ng 9fa0fd: OUTPUT«(1, 2/1, 4/1, 8/1, 16/1, 32/1, 64/1, 128/1, 256/1, 512/1)␤»

[03:30] <colomon> ng: my @a = 4, 2, 1; (@a ... *).batch(10).perl.say

[03:30] <p6eval> ng 9fa0fd: OUTPUT«(4, 2/1, 1/1, 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128)␤»

[03:43] <colomon> ng: say 1, 2, 3 Z 4, 5, 6

[03:43] <p6eval> ng 9fa0fd: OUTPUT«Could not find non-existent sub &infix:<Z>␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[03:47] <colomon> ng: (0..3).map({$_ * 2}).join('|')

[03:47] <p6eval> ng 9fa0fd:  ( no output )

[03:47] <colomon> ng: (0..3).map({$_ * 2}).join('|').say

[03:47] <p6eval> ng 9fa0fd: OUTPUT«0|2|4|6␤»

[03:52] <JimmyZ> ng: ((4, 2, 1) ... *).batch(10).perl.say

[03:52] <p6eval> ng 9fa0fd: OUTPUT«Method 'succ' not found for invocant of class 'Seq'␤current instr.: '&prefix:<++>' pc 313961 (src/gen/core.pir:40849)␤»

[03:53] <colomon> JimmyZ: something's wrong with the grammar (I think) which blocks the straightforward forms calling of infix:<...>

[03:55] <JimmyZ> aye

[04:01] <colomon> ng: (1..3).first({ $_ % 2 == 0}).say

[04:01] <p6eval> ng 9fa0fd: OUTPUT«1␤»

[04:01] <colomon> ng: (1..3).first({ $^a % 2 == 0}).say

[04:02] <p6eval> ng 9fa0fd: OUTPUT«2␤»

[04:04] <colomon> ng: my @one = 1; say ~(@one .. 3);

[04:04] <p6eval> ng 9fa0fd: OUTPUT«Method 'succ' not found for invocant of class 'Array'␤current instr.: '!dispatch_.=' pc 440 (src/glue/dispatch.pir:118)␤»

[04:05] <pugs_svn> r29670 | colomon++ | [t/spec] Fudge for ng. 

[04:07] *** cl58 left
[04:10] <dalek> rakudo/ng: 9fa0fd1 | (Solomon Foster)++ | src/ (2 files):

[04:10] <dalek> rakudo/ng: Rename Iterator.getbatch to Iterator.batch.

[04:10] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/9fa0fd1f0c9545d38dd9fe3facc8646a28691b9e

[04:10] <dalek> rakudo/ng: 1feef8c | (Solomon Foster)++ | t/spectest.data:

[04:10] <dalek> rakudo/ng: Turn on S03-operators/range.t.

[04:10] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/1feef8c2dbf4cfb89a9d017ba5022144db492775

[04:12] <TimToady>  ng: say (0..*)[^10].perl

[04:12] <p6eval> ng 9fa0fd: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Range'␤current instr.: '!postcircumfix:<[ ]>' pc 314127 (src/gen/core.pir:40943)␤»

[04:12] <TimToady> there's another version of grab-the-first-10

[04:15] <JimmyZ> ng: (<4, 2, 1> ... *).batch(10).perl.say

[04:16] <p6eval> ng 9fa0fd: OUTPUT«Method 'succ' not found for invocant of class 'Seq'␤current instr.: '&prefix:<++>' pc 313961 (src/gen/core.pir:40849)␤»

[04:16] <TimToady> don't need the commas

[04:17] *** lestrrat is now known as lest_away

[04:17] *** jaldhar joined
[04:20] <JimmyZ> ng: (<4 2 1> ... *).batch(10).perl.say

[04:20] <p6eval> ng 9fa0fd: OUTPUT«sh: ./perl6: No such file or directory␤»

[04:21] <JimmyZ> ng: (<4 2 1> ... *).batch(10).perl.say

[04:21] <p6eval> ng 9fa0fd: OUTPUT«sh: ./perl6: No such file or directory␤»

[04:21] <TimToady> recompiling, but probably won't anyway

[04:21] <TimToady> won't work

[04:21] <JimmyZ> maybe

[04:21] <TimToady> unless someone has made <4 2 1> autoconvert to integer already

[04:21] <JimmyZ> ng: ((4, 2, 1) ... *).batch(10).perl.say

[04:21] <p6eval> ng 1feef8: OUTPUT«Method 'succ' not found for invocant of class 'Seq'␤current instr.: '&prefix:<++>' pc 313961 (src/gen/core.pir:40999)␤»

[04:21] <JimmyZ> ng: (<4 2 1> ... *).batch(10).perl.say

[04:21] <p6eval> ng 1feef8: OUTPUT«Method 'succ' not found for invocant of class 'Seq'␤current instr.: '&prefix:<++>' pc 313961 (src/gen/core.pir:40999)␤»

[04:22] <TimToady> looks like ... isn't actually behaving like a list infix

[04:23] <JimmyZ> ng: my @a = 1, 2, 4; (@a ... *).batch(10).perl.say

[04:23] <p6eval> ng 1feef8: OUTPUT«(1, 2/1, 4/1, 8/1, 16/1, 32/1, 64/1, 128/1, 256/1, 512/1)␤»

[04:23] <JimmyZ> yes

[04:24] <JimmyZ> ng: my @a = 4, 2, 1; (@a ... *).batch(10).perl.say

[04:24] <p6eval> ng 1feef8: OUTPUT«(4, 2/1, 1/1, 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128)␤»

[04:24] <TimToady> maybe Seq isn't flattening correctly

[04:24] *** k23z__ left
[04:24] <TimToady> but also, <4 2 1> is probably still making strings

[04:25] *** justatheory left
[04:27] <TimToady> (1, 2, 4, ... *).[^10].perl.say

[04:27] <TimToady> ng: (1, 2, 4, ... *).[^10].perl.say

[04:27] <p6eval> ng 1feef8: OUTPUT«No exception handler and no message␤current instr.: '&fail' pc 15242 (src/builtins/Junction.pir:207)␤»

[04:27] <TimToady> ng: (1, 2, 4 ... *).[^10].perl.say

[04:27] <p6eval> ng 1feef8: OUTPUT«Method 'succ' not found for invocant of class 'Seq'␤current instr.: '&prefix:<++>' pc 313961 (src/gen/core.pir:40999)␤»

[04:28] <TimToady> ng: ((1, 2, 4).flat ... *).[^10].perl.say

[04:28] <p6eval> ng 1feef8: OUTPUT«Method 'flat' not found for invocant of class 'Parcel'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[04:31] <TimToady> ng: (1, 2, 4 ... *).Array.[^10].perl.say

[04:31] <p6eval> ng 1feef8: OUTPUT«Method 'Array' not found for invocant of class 'GatherIterator'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[04:32] <sjohnson> rakudo: say 'hi';

[04:32] <p6eval> rakudo 1d4928: OUTPUT«hi␤»

[04:33] <sjohnson> rakudo: say ord('h');

[04:33] <p6eval> rakudo 1d4928: OUTPUT«104␤»

[04:33] <eternaleye> I think it's that there is no infix:<...>( Seq $lhs, Whatever )

[04:33] <eternaleye> ng: say Seq.new( 1, 2 ).flat

[04:34] *** gfx joined
[04:34] <p6eval> ng 1feef8: OUTPUT«Method 'flat' not found for invocant of class 'Seq'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[04:34] <eternaleye> ng: say Seq.new( 1, 2 ).Array

[04:34] <p6eval> ng 1feef8: OUTPUT«Method 'Array' not found for invocant of class 'Seq'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[04:34] <eternaleye> ng: say Seq.new( 1, 2 )

[04:34] <p6eval> ng 1feef8: OUTPUT«Null PMC access in get_integer()␤current instr.: 'perl6;Seq;elems' pc 265145 (src/gen/core.pir:23332)␤»

[04:34] <eternaleye> o.0

[04:34] <TimToady> shouldn't need that exact signature

[04:34] <eternaleye> I wonder if that null PMC error is known

[04:35] <TimToady> in fact, list infixes should generally have a sig more like ([*@lhs], [*@rhs]) or some such that will put flat context on both sides

[04:36] <eternaleye> ng: say Seq.new( 1, 2 ).^methods( :local )>>.name.join(', ')

[04:36] <p6eval> ng 1feef8: OUTPUT«Null PMC access in get_integer()␤current instr.: 'perl6;Seq;elems' pc 265145 (src/gen/core.pir:23332)␤»

[04:36] <eternaleye> ng: say Seq.^methods( :local )>>.name.join(', ')

[04:36] <p6eval> ng 1feef8: OUTPUT«Null PMC access in get_integer()␤current instr.: 'perl6;Seq;elems' pc 265145 (src/gen/core.pir:23332)␤»

[04:37] <TimToady> we don't want to have to write signatures for every single type that might be asked for a list

[04:37] <eternaleye> Gah, I'm channeling the Null PMC Bunny

[04:38] <eternaleye> ng: say ~[Seq.new( 1, 2 )]

[04:38] <p6eval> ng 1feef8: OUTPUT«Null PMC access in get_integer()␤current instr.: 'perl6;Seq;elems' pc 265145 (src/gen/core.pir:23332)␤»

[04:39] <TimToady> so probably you just want infix:<...> (Any, Any) with appropriate coercions internally

[04:40] <TimToady> or maybe list infixes automatically just get two parcel objects

[04:41] <eternaleye> The latter sounds cleanest

[04:41] <TimToady> more like a 2D slice, really

[04:41] <TimToady> and extends to list-associative listops

[04:42] <eternaleye> But can signatures for the contents of those parcels be specified?

[04:42] <TimToady> probably

[04:43] <TimToady> **$left, **$right to begin with

[04:43] <eternaleye> multi sub infix:<...>( :( Numeric $a, Numeric $b ), :( Whatever ) ) might be an interesting syntax

[04:44] <eternaleye> Using the signature decl syntax

[04:44] <TimToady> maybe.  at some point it's easier to just pull in the lists and look at the values

[04:45] <eternaleye> BTW, if ** is a singleton Whatever, what's **?

[04:45] <eternaleye> erm, s:1st/\*\*/*/

[04:46] <TimToady> HyperWhatever, but that's not what it means in a signature

[04:46] <TimToady> it takes over from the old @@

[04:46] <TimToady> it's "slicey" instead of "slurpy"

[04:47] <eternaleye> Yep. I was asking abut it in term position. My brain jumps around a lot.

[04:47] <TimToady> and 2D instead of 1D

[04:47] <TimToady> as rvalue generally means you can replace multiple dimensions at that spot

[04:47] <TimToady> sorta [;] * xx *

[04:48] <TimToady> except we don't have [;] anymore

[04:48] <TimToady> but maybe removing [;] was ill-considered

[04:53] <TimToady> now it's **(@dimensions)

[04:53] <TimToady> and ** is short for **(* xx *)

[04:54] <eternaleye> Sweet

[04:54] <TimToady> arguably it should be something like || to go with |

[04:55] <TimToady> ||(* xx *)

[04:55] <TimToady> though prefix || is gonna look funny to a C programmer

[04:56] <eternaleye> Or someone who has written ebuilds on Gentoo

[04:57] <eternaleye> There, ||( ) in the dependency spec means 'any of these is okay, switchable at will'

[04:59] <TimToady> I'm thinking slice interpolation is likely to change to prefix:<||>, since it's really the 2D form of prefix:<|>

[04:59] <TimToady> also, as a prefix wouldn't require ()

[04:59] <eternaleye> Makes sense

[04:59] <TimToady> ||@foo

[04:59] <TimToady> and the reduplication means the same thing for */**

[05:00] <eternaleye> Plus, it would preserve the |prefix feeding *signature symmetry, with ||prefix feeding **signature

[05:01] <TimToady> well, I'll think about it while I pick up kid from evening school.

[05:01] <TimToady> bbl &

[05:04] *** hanekomu left
[05:07] *** hanekomu joined
[05:21] *** cjk101010 joined
[05:36] <pugs_svn> r29671 | lwall++ | [S06,S09] change **() special form to prefix:<||> by analogy to prefix:<|> 

[05:41] <pugs_svn> r29672 | lwall++ | [STD] allow prefix:<||> 

[05:51] *** agentzh joined
[05:52] <pugs_svn> r29673 | lwall++ | [S03] add description of prefix:<||> semantics 

[05:53] *** lest_away is now known as lestrrat

[05:59] *** quietfanatic joined
[06:01] *** lue left
[06:03] *** synth left
[06:04] *** [particle] joined
[06:26] *** agentzh left
[06:26] *** agentzh joined
[06:47] *** patspam left
[06:49] *** fridim joined
[06:54] *** szabgab joined
[07:07] *** cognominal joined
[07:07] *** kaare joined
[07:07] *** kaare is now known as Guest55887

[07:09] *** am0c left
[07:15] *** uniejo joined
[07:15] *** JimmyZ left
[07:17] *** nabax joined
[07:19] *** Su-Shee joined
[07:20] <Su-Shee> good morning

[07:23] *** diakopter sets mode: +o Su-Shee

[07:23] <diakopter> in case le spammers strike

[07:24] <diakopter> griefers

[07:24] <diakopter> zzzzzzzzzzzzzzzzzzzzzzzzzzzzz&&&&

[07:28] *** eternaleye left
[07:28] <sjohnson> diakopter: i think the new ircd has eliminated that problem

[07:29] <sjohnson> i think it has better spam detection technology

[07:39] <spinclad> TimToady: i don't think i would call unary '||' a _flattening_ operator, as i think of flattening as what slurpy context does, as opposed to slice context

[07:39] *** eternaleye joined
[07:40] <spinclad> (re last edit to S03)

[07:42] <szbalint> freenode staff aren't very good in handling security/spam :)

[07:42] <spinclad> they can't be everywhere at once

[07:47] *** iblechbot joined
[07:53] *** drbean left
[08:02] *** rv2733 joined
[08:16] *** kst left
[08:24] *** lestrrat is now known as lest_away

[08:25] <eternaleye> TimToady: You said [;] had been nuked, but S32/Containers has an invocation of it under cat()

[08:27] *** lest_away is now known as lestrrat

[08:27] *** clausi joined
[08:29] <frettled> eternaleye: some roaches survive nuking ;)

[08:29] <eternaleye> Just wanted to point it out.

[08:30] <eternaleye> So the Giant Foot of Squishing could get it

[08:30] <frettled> I hope the Giant Foot of Squishing has a Giant Boot of Protection, that looks mighty sharp.  ;)

[08:30] <mathw> The Giant Foot of Squishing? I like that

[08:31] <mathw> I would imagine it probably has a good few levels of Heavy Armour

[08:34] *** cosimo left
[08:42] *** cosimo joined
[08:48] *** agentzh left
[08:50] *** rgrau joined
[08:52] <moritz_> good morning

[08:53] <moritz_> phenny: tell cl58 it seems we don't share much common uptime these days - feel free to /msg me, or send an email to [email@hidden.address]
[08:53] <phenny> moritz_: I'll pass that on when cl58 is around.

[08:53] <moritz_> phenny++

[08:54] *** mj41 left
[08:54] *** Speedy1 joined
[08:54] <Speedy1> www.search2.net

[08:55] <mathw> morning moritz_ 

[08:55] *** rgrau left
[08:57] *** mj41 joined
[08:58] *** Speedy1 left
[09:06] *** nabax left
[09:10] *** umut joined
[09:11] *** cosimo left
[09:12] *** fridim left
[09:14] *** umut left
[09:14] *** cosimo joined
[09:17] *** dakkar joined
[09:21] *** fridim joined
[09:25] *** lestrrat is now known as lest_away

[09:29] *** IllvilJa left
[09:40] *** payload left
[09:46] *** IllvilJa joined
[10:02] <moritz_> hugme: list projects

[10:02] <hugme> moritz_: I know about book, gge, hugme, ilbot, json, november, nqp-rx, nqpbook, perl6-examples, proto, svg-matchdumper, svg-plot, temporal-flux-perl6syn, tufte, web

[10:07] *** pmurias joined
[10:07] <pmurias> what does plan * do?

[10:07] *** mssm joined
[10:08] <moritz_> it's supposed to start planless testing

[10:08] <pmurias> why do we need that?

[10:10] <moritz_> to distinguish it from a forgotten plan, I think

[10:10] <moritz_> or from not running any tests at all, maybe

[10:10] <moritz_> not really sure

[10:11] <pmurias> it's not in all files

[10:11] *** araujo joined
[10:11] <Trashlord> hey

[10:11] <pmurias> Trashlord: hi

[10:12] <pmurias> moritz_: i think it would make sense to remove plan *

[10:12] <moritz_> pmurias: we should write a spec for testing

[10:12] <pmurias> yes :) wanted to propose that to

[10:13] <moritz_> and I think it does make sense to distinguish loading Test.pm from starting testing

[10:14] <moritz_> so *something* should stay that indicates starting of tests

[10:14] <pmurias> the first call to a testing function could do that

[10:15] <moritz_> it could, but I'm not sure if I like that

[10:15] <pmurias> we don't need to explicitly start testing

[10:16] <moritz_> aye; but that doesn't mean it's necessarily a good idea

[10:17] <pmurias> if you don't have a plan or call done_testing the test harness will protest

[10:17] <moritz_> it might not make a difference for TAP, but maybe for other testing protocols

[10:18] <moritz_> and while TAP is very good, it might not be the only thing worth considering (in the long range)

[10:18] <pmurias> yes

[10:18] <pmurias> but if you protocol needs an explicit start of testing the first call to the test function is enough

[10:19] <moritz_> unless there's a difference between running a test with no test cases, and running no test at all

[10:20] <moritz_> suppose you have steps 1) load Test.pm 2) plan *; 3) run some tests; 4) done_testing

[10:20] <moritz_> and you die silently before 3)

[10:20] <pmurias> step 0 is start test

[10:20] <moritz_> how do you start test?

[10:20] <moritz_> there might be difference if you die silently before running the first test

[10:21] <pmurias> tests are one per file

[10:21] <moritz_> if you haven't declared that you want to run tests, some other protocols might not classify that as a failure

[10:22] <pmurias> it would be the fault of the protocol

[10:22] <pmurias> you can die between steps 1 and 2

[10:22] <moritz_> that would be the fault of the test writer :-)

[10:23] <moritz_> anyway, I don't have a very strong opinion, but I'd like to hear what others have to say about it first

[10:23] <moritz_> and somehow (probably irrationally) I like the step of explicitly saying "now we start to test"

[10:23] <pmurias> i dispise such things

[10:24] <pmurias> it seems like having to initialise some C library libtap_init();

[10:25] <pmurias> and Test::More doesn't require anything like that

[10:26] *** Chillance joined
[10:26] <pmurias> IMHO if we want something like that it should be run_test {ok 1;ok 2;...}

[10:27] <pmurias> not plan *;ok 1,"first test";plan *;ok 1,"second test";

[10:27] <moritz_> 'plan *' twice doesn't make much sense to me

[10:31] <pmurias> calling 'plan *' at all doesn't make any sense to me

[10:31] <pmurias> if we run a test we run it

[10:32] *** jonasbn joined
[10:33] *** payload1 joined
[10:34] <pmurias> moritz_: or we can run multiple tests in the same program (then you need a way to distinguish when a tests starts and when it ends)

[10:36] <moritz_> if we want to test the language, we shouldn't rely too much on language features to work

[10:36] <moritz_> so testing last, redo, next etc. inside a block (as introduced by run_test { ... }) might be dangerous

[10:37] <moritz_> in general I like the idea, but not for the spectests

[10:38] <pmurias> it would be more for doing fancy stuff like running multiple tests faster

[10:39] <moritz_> aye

[10:40] <pmurias> we should likely ask the TAP guys about that once we have a solid spec of the basic stuff

[10:40] <moritz_> aye

[10:40] <moritz_> I know that some of the TAP guys also have been working on subtests

[10:41] <pmurias> that's why i suggested we ask them :)

[10:44] <moritz_> so at least a meta consens :-)

[10:45] <pmurias> we could also ask them about plan * ;)

[10:49] *** gfx left
[11:08] *** orafu left
[11:08] *** orafu joined
[11:10] <pmurias> moritz_: are there any docs for Test.pm we could turn into a spec?

[11:14] <colomon> ng: say -.2 ~~ -Inf..Inf

[11:14] <p6eval> ng 1feef8: OUTPUT«0␤»

[11:15] <colomon> ng: say -Inf before -.2

[11:15] <p6eval> ng 1feef8: OUTPUT«0␤»

[11:16] <colomon> ng: say -Inf < -.2

[11:16] <p6eval> ng 1feef8: OUTPUT«1␤»

[11:16] <colomon> ng: say (-Inf).WHAT

[11:16] <p6eval> ng 1feef8: OUTPUT«Num()␤»

[11:16] <pmurias> moritz_: my plan for getting writing a (semi-) spec for Test is to take the docs from ext/Test and the tests from t/02-test-pm correct and expand them and after everyone prune old stuff from rakudo's Test.pm

[11:18] *** lest_away is now known as lestrrat

[11:18] *** payload1 left
[11:21] <pugs_svn> r29674 | colomon++ | [t/spec] Fix (some of the?) broken tests and refudge. 

[11:24] *** meppl joined
[11:24] *** payload joined
[11:26] <colomon> ng: my $a = "AAA"; say --$a;

[11:26] <p6eval> ng 1feef8: OUTPUT«␤»

[11:27] <dalek> rakudo/ng: 7dc1b95 | (Solomon Foster)++ | t/spectest.data:

[11:27] <dalek> rakudo/ng: Turn on S02-builtin_data_types/range.t.

[11:27] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/7dc1b95a403520a4f667740cf6cdb3ccb7350e65

[11:38] *** masak joined
[11:38] <masak> oh hai, #perl6

[11:38] <colomon> o/

[11:46] <pmurias> moritz_: hi

[11:50] <Trashlord> hey

[11:50] <Trashlord> so when do you guys think perl 6 will be out? or do you not think about that? ;p

[11:50] <Trashlord> I mean, released officially

[11:50] <masak> gee, the idea never occurred to us. :)

[11:50] <masak> I guess we should set a release date or something.

[11:51] <masak> Trashlord: how about Feb 18th? is that fine with you?

[11:51] <Trashlord> I know a release date isn't planned

[11:51] <masak> sure it is.

[11:51] <masak> we have one every month.

[11:51] <masak> we release Perl 6 regularly.

[11:52] <masak> it's how good, functional open source is done.

[11:52] <masak> "Release Early, Release Often." We do that.

[11:52] <Trashlord> how is bad open source done?

[11:52] <masak> in many other ways :)

[11:53] <Trashlord> does Microsoft do bad open source? o.0

[11:53] <masak> I'm not up-to-date with how much Microsoft does open source at all. not much, I suspect.

[11:54] <masak> I know they have a couple of licenses registered with OSI, which is... bizarre.

[11:54] <pmurias> some of the ghc guys are employed microsoft research

[11:54] <masak> oh, that's nice.

[11:54] <masak> yeah, they seem to get releases out, at least.

[11:55] <pmurias> ghc is a good compiler

[11:56] * Trashlord was being sarcastic regarding Microsoft

[11:57] <masak> The Net tends to treat sarcasm as damage and routes around it.

[11:58] *** pmurias left
[11:59] *** johnz left
[11:59] <Trashlord> I'll make sure to memorize that

[11:59] *** johnz joined
[11:59] *** Lorn joined
[12:00] <masak> Trashlord: anyway, when you were asking about a release date, what is it that you were hoping for in particular? a full-featured Perl 6 implementation?

[12:00] *** bbkr left
[12:00] <masak> any features in particular you would like to see?

[12:00] <Trashlord> masak: yes. something like Perl 5?

[12:00] <Trashlord> -?

[12:01] <Trashlord> because I've played a bit with 6, and it looks promising, I enjoy it

[12:01] <masak> cool.

[12:01] <masak> I think so too.

[12:01] <dalek> rakudo/ng: 6a00fc0 | (Solomon Foster)++ | src/core/Range.pm:

[12:01] <dalek> rakudo/ng: Add Range.from and Range.to (why are these in the spec?!) and a very stupid but mostly functional implementation of Range.Num.

[12:01] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/6a00fc0ac28dee1510289031b40f92ccfe6c4d85

[12:02] <Trashlord> I know that rakudo releases every month

[12:02] <Trashlord> I just installed it yesterday

[12:03] <Trashlord> tried some stuff

[12:03] *** frettled sets mode: +o masak

[12:03] <frettled> Try to hang on to it for more than an hour, eh?  ;)

[12:03] <masak> I promise :)

[12:04] *** johnz left
[12:04] *** johnz joined
[12:05] <jnthn> lolhai

[12:05] <Trashlord> lolhey

[12:05] <masak> lolitsjnthn

[12:05] <jnthn> :-)

[12:05] <frettled> jnthnicious!

[12:06] <colomon> jnthn: I've been busy slowing down make spectest

[12:06] <masak> jnthnonderful!

[12:06] <colomon> Files=115, Tests=3570

[12:06] <masak> colomon++

[12:07] <jnthn> colomon: Wow!! :-)

[12:07] <moritz_> rakudo: say 'foo'.WHAT

[12:07] <jnthn> colomon: I gotta go debug a Java pile of hate for a bit again...will do some Rakudo hacking later on. :-) One thing from backlog (which I need more coffee to full read...)

[12:07] <moritz_> rakudo: say 'foo'.WICH

[12:08] <p6eval> rakudo 1d4928: OUTPUT«Str()␤»

[12:08] <p6eval> rakudo 1d4928: OUTPUT«Method 'WICH' not found for invocant of class 'Str'␤in Main (file src/gen_setting.pm, line 324)␤»

[12:08] <jnthn> colomon: 1, 3, 5 ... *

[12:08] <moritz_> rakudo: say 'foo'.WHICH

[12:08] <p6eval> rakudo 1d4928: OUTPUT«foo␤»

[12:08] <masak> Trashlord: the thing with Rakudo that's been going on for several months now, by the way, is that we're rewriting the inner workings to better cope with future change. most development is taking place in a branch ('ng'), so there's not many changes between the last couple of releases.

[12:08] <moritz_> rakudo: say 23.WHICH

[12:08] <p6eval> rakudo 1d4928: OUTPUT«23␤»

[12:08] <moritz_> rakudo: say 23.5.WHICH

[12:08] <p6eval> rakudo 1d4928: OUTPUT«23.5␤»

[12:08] <moritz_> ng: say 23.5.WHICH

[12:08] <p6eval> ng 7dc1b9: OUTPUT«47273655653440␤»

[12:08] <jnthn> colomon: Is ... parsed interestingly?

[12:08] <jnthn> colomon: That is, is it swallowing up the "1,3,5"?

[12:08] <Trashlord> masak: right, so it's alright if I don't update every month?

[12:08] *** ruoso joined
[12:09] <masak> Trashlord: it's alright if you don't update for a year! just use whatever release fits your needs. :)

[12:09] *** frettled sets mode: +o colomon

[12:09] <ruoso> bom dia #perl6

[12:09] <Trashlord> masak++

[12:09] *** frettled sets mode: +o ruoso

[12:09] <colomon> jnthn: as far as I can tell, if you do 1, 3, 5 ... *, it becomes +(1, 3, 5) ... *

[12:09] <masak> ruoso: bom dia.

[12:09] *** drbean joined
[12:09] <jnthn> colomon: STD just says "list infix"

[12:09] <moritz_> good localtime() ruoso 

[12:09] <frettled> ruoso: bom bom bom, bom bom-badilla #perl6?

[12:09] <masak> Trashlord: that said, we expect some release in Q2 (probably April) to really be something else.

[12:11] <jnthn> colomon: aha

[12:11] <jnthn>     $P22 = "&infix:<,>"(1, 2, 3)

[12:11] <jnthn>     $P23 = "&infix:<...>"($P22, 5)

[12:11] <jnthn> colomon: That's the code-gen for it.

[12:11] <jnthn> colomon: So that's fine

[12:11] *** cls_bsd left
[12:11] <jnthn> ng: say Array.does(Positional)

[12:11] <p6eval> ng 7dc1b9: OUTPUT«1␤»

[12:11] <jnthn> ng: say Seq.does(Positional)

[12:11] <p6eval> ng 7dc1b9: OUTPUT«1␤»

[12:11] <jnthn> ng: say Parcel.does(Positional)

[12:11] <p6eval> ng 7dc1b9: OUTPUT«0␤»

[12:11] <jnthn> Ah.

[12:12] <jnthn> colomon: And that's why it won't bind to @foo in the siggy.

[12:12] <colomon> hmmm

[12:13] <Trashlord> masak: awesome, looking forward to it

[12:13] *** xomas joined
[12:13] *** macae joined
[12:13] <colomon> so, parcel should also be positional?

[12:13] <masak> Trashlord: me too! I even tried to help the other day... :)

[12:14] <jnthn> colomon: I'd have to check the spec.

[12:14] <jnthn> colomon: My intuition is yes.

[12:15] <colomon> ng: say (1, 2, 3) ~~ Parcel

[12:15] <p6eval> ng 7dc1b9: OUTPUT«1␤»

[12:16] <colomon> ng: say (1, 2, 3).Seq

[12:16] <p6eval> ng 7dc1b9: OUTPUT«123␤»

[12:17] <jnthn> ng: say (1,2,3).WHAT

[12:17] <p6eval> ng 7dc1b9: OUTPUT«␤»

[12:17] <jnthn> ...

[12:18] <jnthn> From S02

[12:18] <jnthn>     Parcel      Positional

[12:18] <jnthn> So yes, it should.

[12:18] <colomon> can I just copy the code from Seq?

[12:18] <colomon> it's one bit in the initialization, right?

[12:19] <colomon> (not logical bit, but bit of code.)

[12:20] <jnthn> colomon: Not quite that simple, because at the moment Positional is much further into the bootstrap than Parcel, so I guess it'd be a case of trying to move it up first.

[12:21] * jnthn tries that to see if things explode.

[12:21] <colomon> I think, now that I know what is going on, I can work around it for the moment.

[12:21] <colomon> or you can make thinks go boom, that's cool too.  :) 

[12:22] *** clausi left
[12:24] <jnthn> Hmm...well, it doesn't break the build...of course, I didn't make Parcel do it yet.

[12:26] *** clausi joined
[12:28] <ruoso> jnthn, colomon, but it's important to notice (I'm not really sure about it) that the positional access in the parcel is only in the first dimension

[12:28] <ruoso> so if it has other parcels inside it you'll get them

[12:28] <colomon> afk, no battery left

[12:28] <ruoso> usually, the correct way to deal with Parcel is by using it as an Iterator

[12:29] <ruoso> where you do specify the slice/flat context when getting the items

[12:29] * moritz_ is quited surprised by Neil Mowbray's error messages (on p6c)

[12:29] <jnthn> ruoso: iiuc, binding it to @foo in a signature puts it in list context and it's no more a Parcel anyway. But yes, good to keep in mind.

[12:31] <jnthn> colomon: Positional now does Parcel locally, will push.

[12:32] *** cls_bsd joined
[12:33] *** barney joined
[12:35] <jnthn> moritz_: That error is just about certainly because it's failing to find the dynops

[12:35] <jnthn> As for why, I'm less sure. :-/

[12:35] <moritz_> jnthn: yes, but why? Configure.pl checks if parrot is installed, including dev files

[12:36] <moritz_> and usually one also gets an error message form failing to load such a thing, no?

[12:37] <jnthn> moritz_: Annoyingly, Parrot seems to silently fail on some .loadlib directives. :-/

[12:38] <jnthn> moritz_: The problem is that it needs to find them at compile time, otherwise it doesn't know what in the PIR is an op or a function call.

[12:39] <ruoso> jnthn, binding modifies the parcel?

[12:41] <jnthn> ruoso: No, just enforces context on it

[12:42] <ruoso> but it doesn't enforce flat context, does it?

[12:42] <moritz_> colomon: do you know if there was definitive decion on ?& et al (if it enforces context first)?

[12:42] <jnthn> ruoso: Not sure what the latest spec is on that

[12:43] <jnthn> ruoso: There were even commits in that area last night, that I didn't read yet...

[12:43] <ruoso> iiuc it's the slurpy bind that forces flat

[12:43] <ruoso> and the **@a bind forces slice

[12:43] <jnthn> Still adapting to a post-@@ world. :-)

[12:43] <ruoso> but default is non-modifying

[12:43] <ruoso> binding doesn't enforce the contex

[12:43] <moritz_> isn't that ||@a now?

[12:44] <jnthn> Those two are clear, but I'm not so sure on :(@foo) 

[12:44] <ruoso> moritz_, no... that's the other hand of **@a

[12:44] <jnthn> :(@foo is rw) is clearly not going to do anything to it.

[12:44] <ruoso> :(**@a) := (||@a)

[12:44] <moritz_> ruoso: ok, thanks

[12:45] * jnthn gotta go do @other-work-task for a while.

[12:47] <dalek> rakudo/ng: cb7f239 | jonathan++ |  (2 files):

[12:47] <dalek> rakudo/ng: Parcel should do Positional.

[12:47] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/cb7f2397cc98537f1123232cc15d4d324fa9f699

[13:08] *** payload left
[13:12] *** takadonet joined
[13:12] <takadonet> morning all

[13:17] *** SmokeMachine joined
[13:18] <masak> takadonet: \o

[13:22] <masak> right. I had 'a few' rakudobugs to report.

[13:22] <masak> rakudo: (class foo {}).new

[13:23] <p6eval> rakudo 1d4928: OUTPUT«Null PMC access in find_method('new')␤in Main (file <unknown>, line <unknown>)␤»

[13:23] * masak submits rakudobug

[13:23] <jnthn> ng: (class foo {}).new

[13:23] <p6eval> ng cb7f23: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤current instr.: 'perl6;Code;new' pc 11808 (src/builtins/Num.pir:27)␤»

[13:23] <jnthn> Creative.

[13:23] <masak> thanks.

[13:23] <masak> rakudo: class A {}; class C {}; my A $a .= new; my C $c := $a; say $c

[13:23] <jnthn> Should work though.

[13:23] <p6eval> rakudo 1d4928: OUTPUT«A()<0x2b1564a60fb0>␤»

[13:23] * masak submits rakudobug

[13:24] <masak> rakudo: use A::B

[13:24] <p6eval> rakudo 1d4928: OUTPUT«Can't find ./A/B in @*INC␤in Main (file <unknown>, line <unknown>)␤»

[13:24] <jnthn> masak: Think there already is one on binding not doing type checking.

[13:24] <masak> I'm unsatisfied about the './'

[13:24] <jnthn> That is a tad curious, yeah.

[13:24] <masak> jnthn: ok. if you're sure that one's in RT, I won't submit it.

[13:24] <moritz_> I planned to report that for ages

[13:25] <masak> rakudo: role A[B] {}

[13:25] <p6eval> rakudo 1d4928: OUTPUT«set_pmc_keyed() not implemented in class 'Integer'␤in Main (file <unknown>, line <unknown>)␤»

[13:25] * masak submits rakudobug

[13:25] <moritz_> curious DB view: J."StartTime" AS "JStartTime", J."EndTime" AS "JStartTime",

[13:25] <masak> here's one I'm not so sure about:

[13:26] <masak> rakudo: subset A of Int; subset B of Num where { $^n !% 2 }; say A ~~ B

[13:26] <p6eval> rakudo 1d4928: OUTPUT«Use of type object as value␤1␤»

[13:26] <masak> I see why I get the warning, but should I?

[13:26] <masak> also, should the answer be True here?

[13:27] <masak> rakudo: subset B of Num where { $^n !% 2 }; say Int ~~ B

[13:27] <p6eval> rakudo 1d4928: OUTPUT«Use of type object as value␤1␤»

[13:27] <masak> that's simpler, I guess.

[13:27] <jnthn> That should trivially be false in ng as Int !~~ Num now.

[13:27] <jnthn> (OK, by spec it ain't)

[13:28] <jnthn> However, I agree if it was, you should get the warning.

[13:28] <jnthn> If not, you should get False.

[13:28] <jnthn> And Int in general does not satisty the constraint.

[13:28] *** eternaleye left
[13:28] <masak> so nothing to see here, move along?

[13:28] <jnthn> Pretty much, IMO.

[13:28] <masak> ok.

[13:28] <masak> finally, I have a spec question.

[13:28] <jnthn> I'm not so fussed on making subsets behave specially on type objects.

[13:29] <masak> S12:1482 says the following:

[13:29] <masak> Int:_ where !*.defined

[13:29] <masak> If `!*.defined` is allowed, whence the need for .notdef?

[13:29] <masak> I know we talked about this before.

[13:29] <masak> .notdef always seemed like a strange creature to me. I accept that it has a use in 'when' clauses.

[13:29] <jnthn> std: :(Int:_ where !*.defined)

[13:29] <p6eval> std 29674: OUTPUT«===SORRY!===␤Multiple prefix constraints not yet supported at /tmp/8ktmfDHjet line 1:␤------> :(Int:_ where !*.defined⏏)␤    expecting any of:␤   method arguments␤ type_constraint␤FAILED 00:01 110m␤»

[13:30] <masak> but if !*.defined works, why do we need .notdef?

[13:30] <jnthn> masak: I find it a tad surprising !*.defined should work in that context.

[13:30] <masak> right.

[13:30] <jnthn> Oh, hmm

[13:30] <jnthn> Maybe not

[13:30] <jnthn> Dunno. May be a relic of pre-.notdef days.

[13:31] <masak> I'm pretty sure it is.

[13:31] <masak> that part of the spec is older, at least.

[13:31] <jnthn> One for TimToady++ to verify, I think.

[13:31] <masak> nod.

[13:31] <masak> rakudo: enum A <a b c>; enum B <a b c>; say &a.perl

[13:31] <p6eval> rakudo 1d4928: OUTPUT«B::a␤»

[13:31] * masak submits rakudobug

[13:33] <jnthn> ?

[13:34] <jnthn> Heh

[13:34] <moritz_> it should be ambiguous

[13:34] <jnthn> Oh

[13:34] <moritz_> I can never remember how to write that word :-)

[13:34] <jnthn> Yeah, that.

[13:34] * jnthn dearly hopes somebody else takes on the enum implementation for ng.

[13:35] <mathw> good afternoon #perl6

[13:36] <mathw> What's so horrible about enums?

[13:36] <jnthn> mathw: I'm fed up of writing implementations of them.

[13:36] <mathw> Should I put 'volunteering to look at the enum implementation in ng' before or after 'gouging my eyes out with a rusty nail' on my list of things I'd like to do today?

[13:37] <jnthn> mathw: The recent spec changes might akshually make it better than the rusty nail.

[13:37] <mathw> wow

[13:38] <mathw> I might have to have a look at those spec changes

[13:38] <jnthn> ng: say 'enums' before 'rusty nail'

[13:38] <p6eval> ng cb7f23: OUTPUT«1␤»

[13:38] <jnthn> Well, there we go.

[13:40] <mathw> lol

[13:41] <masak> jnthn: I'd be happy to take on the enum implementation. I like the way it's spec'd nowadays.

[13:41] <masak> it would be fun to make it happen.

[13:41] <mathw> I'd like to try and follow along and learn something

[13:42] <masak> cool. then I'll have someone to make rambling explanations to. :)

[13:42] <mathw> :)

[13:42] <mathw> Just don't try them in Esperanto yet

[13:42] <mathw> I haven't learned any Esperanto since Monday

[13:42] <masak> I promise.

[13:44] <mathw> \o/

[13:44] <jnthn> masak++ mathw++ # enums!

[13:45] <mathw> You're assuming my contribution will amount to anything more than pointless nitpicking

[13:45] <mathw> I shall try and be more useful than that

[13:46] <colomon> moritz_: My understanding is that ?& coerces its arguments to Bool.  I changed the implementation to work that way, too.  :)

[13:48] <masak> right. TimToady confirmed that, didn't he?

[13:48] <masak> ?& is a non-shortcircuiting version of &&

[13:48] <colomon> masak: Yes.

[13:48] <colomon> masak: No.

[13:48] <colomon> ng: say 4 && 4

[13:48] <p6eval> ng cb7f23: OUTPUT«sh: ./perl6: No such file or directory␤»

[13:49] <colomon> > say 4 && 4

[13:49] <colomon> 4

[13:49] <colomon> > say 4 ?& 4

[13:49] <colomon> 1

[13:49] <colomon> And that 1 is actually Bool::True.

[13:50] *** xomas left
[13:50] <colomon> > (1, 3, 5 ... *).batch(10).perl.say

[13:50] <colomon> Method 'postcircumfix:<[ ]>' not found for invocant of class 'Parcel'

[13:51] <colomon> afk... desperately need more sleep

[13:51] <mathw> 4 ?& 4 boils down to True AND True, I believe

[13:53] <masak> colomon: oh, you're right. my statement is only true if I use the result of && in boolean context.

[13:54] *** iblechbot left
[13:55] <masak> four rakudobugs in one day. not bad, considering that master is not generating new bugs lately. :)

[13:55] <mathw> masak: might also change depending on how your arguments coerce to bool, too

[13:55] <masak> yeah. it's all very tricky, come to think of it.

[14:05] *** xomas` joined
[14:16] *** bbkr joined
[14:24] *** slavik joined
[14:29] *** andy1 joined
[14:29] *** synth joined
[14:31] *** pmurias joined
[14:34] <masak> amazingly, the race is still on between GGE and ng.

[14:34] <masak> to the extent that it was ever a race, of course. :)

[14:35] *** drbean left
[14:35] <masak> I have two features left until GGE is 100% PGE-compliant.

[14:35] <masak> lookarounds and goals.

[14:35] <PerlJam> masak: tortoise and hare?  ;)

[14:36] <mathw> impressive

[14:36] <masak> PerlJam: maybe. I've managed to keep a fairly high activity wrt to GGE ever since August. but it does come and go.

[14:37] <masak> I think it's my longest-running pet project ever, measured in the length of uninterrupted time I've managed to keep up an interest.

[14:37] <masak> November might be slightly longer.

[14:38] <PerlJam> masak: have you seen that code_swarm video I did of rakudo the other day?  It's an interesting visualization of the "activity" of a project.

[14:39] <masak> PerlJam: URL?

[14:39] * masak hasn't backlogged today, surprisingly

[14:39] <PerlJam> http://feather.perl6.nl/~duff/rakudo-swarm.avi

[14:39] * masak looks

[14:42] <mathw> masak: GGE is very impressive

[14:42] <mathw> I wish I had the time to try and understand how these engines work

[14:42] * masak is transfixed by that video

[14:42] <mathw> I can comprehend a very basic regex engine, but anything high performance or with Perl-like features is just... beyond

[14:42] <masak> mathw: thanks. stand by for my 7-part tutorial :)

[14:42] <mathw> \o/

[14:42] <masak> wow. 2008 was The Year It Happened.

[14:43] <PerlJam> mathw: what perl-like features give you pause?

[14:43] <PerlJam> masak: wait, there's more :)

[14:43] <masak> whoa!

[14:44] <masak> 2009!

[14:44] <PerlJam> masak: if you want to play with your own code_swarm visualization, I put the config file I used in the rakudo repo in the tools dir.

[14:44] <mathw> PerlJam: lookaheads, for one. I don't even understand how to use those...

[14:45] <masak> I like the end especially.

[14:45] <masak> pmichaud has like a big feaking pulsating aura around him, jnthn has a smaller one, and things just go kaboom, like.

[14:45] <masak> it's like an action movie.

[14:46] * masak re-watches the end

[14:47] <masak> it's at 3:42. November 15, 2009. probably ng being branched or something like that.

[14:47] <PerlJam> yep

[14:47] <Trashlord> heh

[14:47] <PerlJam> (I used the ng branch for that visualization)

[14:47] <Trashlord> I sometimes find myself at work, at 3:42

[14:48] <PerlJam> master would have been much more boring towards the end

[14:48] <masak> Trashlord: oh, I was unclear. :)

[14:48] <masak> Trashlord: 3:42 in the vid.

[14:48] <Trashlord> ha, alright then

[14:48] * Trashlord laughs

[14:49] <masak> but I do believe pmichaud++ had some interesting sleep patterns while working on nqp-regex.

[14:49] <masak> I had, too, during the more intense phases of GGE development.

[14:50] <masak> mathw: re lookaheads, they're just a kind of subrule with a regex as an argument. and subrules are just regular methods.

[14:56] <mathw> I will probably understand them at such time as I find myself actually needing to use one

[14:57] <masak> what surprised me about them was that the 'foo' in <?before foo> isn't compiled at regex compile time, but at lookahead match time.

[14:57] <masak> fortunately it's also cached.

[14:59] <mathw> :)

[14:59] <mathw> good

[14:59] <masak> but still, lookaraounds will incur a runtime delay while compiling those 'foo'-like things. that ought to make them significantly slower than other regexes, since compilation is heavy.

[14:59] <mathw> yeah so I'm probably better off avoiding them in the general case

[14:59] <mathw> except where it makes something that would otherwise take a load of clunky code much more elegant

[14:59] <masak> dunno. they're definitely useful.

[15:00] <mathw> and sometimes ?before does seem tempting, if I really understood what it does :)

[15:01] <masak> it's a zero-width match at the current location.

[15:01] <masak> 'zero-width' means that even if the thing you're matching has some length, your current position doesn't move.

[15:01] <jnthn> masak: Basically, it says "does the next thing match this pattern", but without actually capturing or consuming any characters.

[15:02] <jnthn> erm

[15:02] <jnthn> tht was for mathw 

[15:02] <masak> jnthn: :)

[15:02] <jnthn> :-)

[15:02] <mathw> yay

[15:02] <mathw> ma<tab> strikes again

[15:02] * mathw gives jnthn a beer

[15:02] <jnthn> \o/

[15:02] * jnthn has also managed to find the annoying bug in the Java thingy he's hacking on, after many hours searching.

[15:02] <mathw> yay

[15:03] <jnthn> That greatly increases the chance of me getting Rakudo time today. :-)

[15:04] <mathw> yay xx (99..999).pick

[15:04] <jnthn> I have to say that this code-base gave me a new respect for TimToady's wanting making classes final etc a program-level decision rather than one for the class though.

[15:04] <jnthn> *loads* of stuff has been marked final, I guess for performance win.

[15:04] <jnthn> ut it 

[15:05] <jnthn> But it means I can't just subclass the thingy that is doing the Wrong Thing to fix it, I gotta patch the actual library.

[15:05] <PerlJam> That TimToady guy is one smart cookie.

[15:05] <PerlJam> ;)

[15:06] <jnthn> Yeah, but tbh until now, I'd not really grasped how annoying "final" decided by a class could be. :-)

[15:06] <mathw> I had

[15:06] <mathw> I've been bitten by that

[15:06] <mathw> What with being a C++ programmer

[15:06] <jnthn> You're suddenly making my need to do Java feel less bad. ;-)

[15:06] <mathw> And having to deal with the need for polymorphic behaviour, but the base class didn't declare any of its methods virtual

[15:06] <mathw> so polymorphic behaviour DO NOT HAVE

[15:06] <jnthn> eww

[15:06] <mathw> quite

[15:07] <jnthn> Bad choice of default, imo.

[15:07] <mathw> now, virtual methods do impose a runtime performance hit

[15:07] <mathw> but it's not a very big one these days

[15:07] <mathw> C++ is a powerful language indeed, and I'd still rather use it than Java

[15:07] <mathw> but it's got some crazy shit in it

[15:07] * PerlJam munches on coworker's home-made pork jerky  $coworker++

[15:07] <mathw> The type system is still crippled by its need to be C-like

[15:08] <mathw> and C++0x is taking entirely too long

[15:08] <PerlJam> mathw: what would you rather C++ than Java exactly?

[15:08] <PerlJam> s/what/why/

[15:09] <jnthn> EWW jerky :-O

[15:09] <mathw> because C++ lets me write types which behave indistinguishably from built-in types in all important respects

[15:09] <mathw> I can have a bignum type that reacts to arithmetic operators in precisely the expected manner

[15:10] <masak> mathw: could you tell me a bit about X++0x? your 'taking entirely too long' comment piqued my interest.

[15:10] <masak> er, s/X/C/

[15:10] *** nacho joined
[15:10] <mathw> I can write classes which do hugely crazy memory-sharing tricks internally and not care when I'm using them because it just happens behind the scenes

[15:11] <mathw> masak: the standardisation committee is working very slowly, basically

[15:11] <mathw> There's some good stuff in the drafts

[15:11] <PerlJam> mathw: I haven't used Java much, but I couldn't imagine someone *preferring* C++  :-)  Thanks.

[15:11] <masak> mathw: tell me about the good stuff.

[15:12] <masak> there's memory management, no?

[15:12] <mathw> masak: unfortunately they dropped template concept checking, which looked like a great idea

[15:12] <masak> why'd they drop it?

[15:12] <mathw> unproven

[15:12] <mathw> they decided that something developed for spec rather than developed in real use was too risky

[15:12] <mathw> they've been burned by things like that before it seems

[15:12] <masak> ah. makes sense.

[15:13] <masak> it -is- very useful to have at least one working implementation of the spec'd thing.

[15:13] <masak> cf Pugs, Rakudo.

[15:13] <mathw> uniform initialisation is an interesting one

[15:13] <masak> whuzzat?

[15:13] <mathw> gives us a object construction syntax that's the same for absolutely everything

[15:14] <mathw> and which lets you write a handler for it for a user-defined type

[15:14] <Trashlord> masak: you have my highest respect

[15:14] <mathw> so that standard containers will have a literal initialisation syntax

[15:14] <Trashlord> I must leave now, I have to create music, so see you guys later

[15:14] *** Trashlord left
[15:14] <masak> Trashlord: thank you, for whatever reason.

[15:14] <masak> dang, missed him :)

[15:14] *** cognominal left
[15:15] <mathw> the other thing I usually think of as exciting is the tremendously mundane rvalue references

[15:15] <mathw> which should lead to some performance gains

[15:15] <masak> 'tremenduously mundane'?

[15:15] <mathw> yeah it's not particularly flashy

[15:15] <masak> that can indeed be good.

[15:15] <mathw> but it means you'll be able to return temporary objects from functions by reference instead of by value

[15:15] <pmichaud> good morning, #perl6

[15:16] <masak> has my S26 email arrived yet? I think S26 suffers from being overly flashy.

[15:16] <mathw> ordinary references couldn't handle that, because the object would've been destroyed already

[15:16] <masak> pmichaud: \o

[15:16] <jnthn> pmichaud: Morning

[15:16] <mathw> rvalue references enable the concept of a 'move constructor' as well, which is a kind of destructive copy of an object which is going out of scope. They're basically all about cutting out unnecessary copying and object creation.

[15:17] *** SmokeMachine left
[15:18] <masak> mathw: that sounds nice.

[15:18] <mathw> yeah

[15:19] <masak> "The Art of the Metaobject Protocol" starts out by saying that compilers should be able to optimize for various object creation/destruction scenarios, but they generally don't have enough information to do that at compile-time.

[15:19] <mathw> there's library stuff to go with it

[15:19] *** cognominal joined
[15:19] <mathw> but yeah, overall I do like C++ despite its flaws

[15:19] <mathw> maybe just because I've spent so much time with it, it's like a comfortable jumper that's developed a hole

[15:21] <mathw> The only thing that really grates me regularly is that it has at the language level utterly zero comprehension of threading

[15:21] *** nacho left
[15:21] <mathw> Oh and no anonymous functions - but C++0x adds those too, which is exciting, even if they're not as flashy as Apple's 'blocks' extension which are full-blown closures.

[15:22] <mathw> it will make using STL algorithms much nicer :)

[15:22] *** am0c joined
[15:22] <moritz_> whenver I go back to a language that has no closures, I feel so lost

[15:23] *** Guest55887 left
[15:23] <PerlJam> mathw: how do you pronounce C++0x?  :-)

[15:23] <jnthn> moritz_: When C# 3.0 added such things, it felt like a whole different langauge to me.

[15:23] <mathw> yeah I love closures

[15:24] <mathw> My C++ would benefit greatly from them

[15:24] <jnthn> Programming in C# was suddenly funner.

[15:24] <mathw> and I also think they'd make it a lot easier to write good multithreaded apps

[15:24] <mathw> even without any extra multithreading support

[15:24] <mathw> although I think maybe C++0x also has a standardised syntax for TLS

[15:24] <mathw> can't remember

[15:24] <mathw> anyway, closures rock

[15:24] <mathw> PerlJam: "see plus plus oh eks"

[15:25] <mathw> although it should be called C++1x now, because it's definitely not coming out before 2010...

[15:25] *** cjk101010 left
[15:25] <mathw> and then we have to wait for compilers to propogate

[15:25] <mathw> so I'm not going to get to use this stuff at work for ages

[15:25] <mathw> seeing as how our compilers don't even ship TR1

[15:26] <mathw> I also need to get to the bottom of why one of the senior members of my team thinks smart pointers are the source of all evil

[15:29] <PerlJam> smart pointers use reference counting?!?

[15:29] <PerlJam> weird

[15:29] <mathw> some of them do

[15:30] <mathw> std::auto_ptr<> doesn't, but you can only have one of those pointing to a given object at any given time or Weird Things Happen.

[15:31] <mathw> (i.e. it tends to get destroyed before you expect it, and your program explodes)

[15:32] <PerlJam> one of these days I'll have to give C++ a try again (I haven't touched C++ in over a decade)

[15:33] <mathw> Well I'm firmly of the opinion that exposure to more languages is of great benefit to any programmer

[15:33] <mathw> even Java can teach you something

[15:33] <masak> full ack.

[15:33] <jnthn> Agree.

[15:33] <PerlJam> yep.  And C++ looks like a different animal than the one I knew, so it'll be a brand new language to me :)

[15:34] <mathw> it's changed since I first learned it

[15:34] * jnthn wouldn't mind giving F# a look

[15:34] <mathw> A lot of the changes have to do with people figuring out terrifyingly complicated things to do with the template system

[15:34] <mathw> F# interests me, as a Haskell nut

[15:34] <jnthn> It interets me as a guy who once did ML.

[15:34] <mathw> I need a little project to write in it

[15:34] <jnthn> :-)

[15:34] <moritz_> Fortress also looks like a cool language for some purposes

[15:35] <mathw> Assuming I can get around the ML syntax

[15:35] <mathw> which I don't know very well

[15:35] <mathw> I've read plenty of ML, but I always wrote Haskell

[15:35] <moritz_> I found that reading a language doesn't really teach you its syntax

[15:35] <mathw> I took a look at Clojure earlier, after masak's tweet, but I came to the same conclusion I did last time I looked at Scheme

[15:35] <mathw> I simply can't handle Lisp syntax

[15:35] <PerlJam> heh

[15:36] <mathw> it makes my eyes go funny

[15:36] *** SmokeMachine joined
[15:36] <mathw> I just don't have the inclination to spend the time required to get used to it

[15:36] *** xomas` left
[15:36] <mathw> I've not heard of Fortress

[15:36] *** xomas_ joined
[15:36] *** xomas_ left
[15:36] *** xomas_ joined
[15:36] <moritz_> it's a Java redesign of Fortran

[15:37] <moritz_> that sounds so negative

[15:37] <mathw> yes

[15:37] <moritz_> s/Java/Sun/

[15:37] <masak> Fortress shares a lot of things with Perl 6.

[15:37] <mathw> you've just mentioned two of my least favourite languages together

[15:37] <masak> it's meant to be growable.

[15:37] <moritz_> it's a new language from Sun that tries to be *very* good for numerical calculations

[15:37] * mathw looks it up

[15:37] <masak> it does a lot of things with definable operators.

[15:38] *** dugg joined
[15:38] <moritz_> http://en.wikipedia.org/wiki/Fortress_(programming_language)

[15:38] <masak> http://research.sun.com/projects/plrg/Publications/fortress.1.0.pdf

[15:38] <PerlJam> Another Guy Steele language.

[15:38] <moritz_> "Fortress is also designed to be both highly parallel and have rich functionality contained within libraries, drawing from Java but taken to a higher degree. For example, the 'for' loop is a parallel operation, which will not always iterate in a strictly linear manner depending on the underlying software and hardware. However, the 'for' loop is a library function and can be replaced by another 'for' loop of the programmer's liking rather than being built into th

[15:39] <moritz_> ... rather than being built into the language."

[15:39] <moritz_> that sounds a wee bit like Perl 6 :-)

[15:39] <xinming> PerlJam: What does "Guy Steele" mean please?

[15:40] <moritz_> http://en.wikipedia.org/wiki/Guy_L._Steele_Jr.

[15:40] <PerlJam> xinming: He's a big Lisp-head at Sun who has influenced several different technologies

[15:40] <xinming> Dman, It's a person name, I thought Guy Steele is kind of style. :-P

[15:40] <xinming> PerlJam: Thanks.

[15:40] <masak> I can heartily recomment Steele's "Growing a Language". one of the best talks I've ever read.

[15:41] <masak> gtg &

[15:41] *** masak left
[15:43] <PerlJam> I always think of Guy Steele as being old, so I'm always surprised at how young he actually is.

[15:44] <PerlJam> maybe it's just becuase of how much older than me he is that I think of him as "old"

[15:44] *** nihiliad joined
[15:44] <mathw> Well it's good really, because it means he'll be around to design more cool stuff for a while yet

[15:45] <moritz_> the more you read about how much somebody has done, the more you think of him as being "old"

[15:45] <PerlJam> moritz_: there's that too

[15:45] <mathw> yeah but then when you find out how young they are, you end up feeling inadequate

[15:46] <moritz_> if you chose to compare yourself to the top 0.01% of programmers you likely feel inadequate

[15:46] <mathw> yes

[15:46] <mathw> I try not to do that very often

[15:46] *** clausi left
[15:46] *** cl58 joined
[15:47] <mathw> I prefer to only compare myself to people in fields I'm actually good at :)

[15:47] <PerlJam> How do I know if the people I compare myself to are in the top 0.01% ?   :)

[15:47] *** cl58 left
[15:47] <moritz_> my mother happens to be a psychologist. She always told that the only person I should compare myself to is me

[15:47] <moritz_> it took me some years to realize, but she is right

[15:47] <xinming> I don't prefer to anyone as I always found frustration...

[15:48] <PerlJam> moritz_: more proof that you should always listen to your mother.

[15:48] <mathw> We should all listen to moritz's mother

[15:48] <xinming> At last, I realized, I shouldn't compare with others, Otherwise, I'll live in sorrow. :-)

[15:49] *** justatheory joined
[15:49] <Su-Shee> or, you're just not male and consider this competition stuff entirely different anyways. ;)

[15:50] <moritz_> Su-Shee: maybe you listened to your mom :-)

[15:51] <PerlJam> Su-Shee: comparison != competition  :)

[15:51] <Su-Shee> no, my learned values are plainly different from yours. I had to actually learn how to deal with all the male measurements of competition.

[15:51] <Su-Shee> PerlJam: as you (meta-you in the meaning of "you guys coding stuff) practice it, it's usally "compare to compete".

[15:51] <xinming> moritz_: But there is no much luck for Chinese people actually, parents always try to compare you with other people, and say, Look, How good they are, You should follow them up.

[15:54] *** justatheory left
[15:54] * xinming goes to sleep. bye all. :-)

[15:54] <PerlJam> goodnight xinming 

[15:56] <colomon> mathw: you think you've got it bad waiting for C++0x -- I had people I work with git upset last fall when I suggested I might not support Visual C++ 6.0 bugs anymore in my code....

[15:57] <mathw> colomon: yeah that's pretty bad, but we do use Visual C++ 2005 at work

[15:58] <colomon> mathw: I use 2005 too (mostly, I do have 2008).  6.0 is like 1997 or 1998.

[15:59] *** Kvorg joined
[15:59] *** Patterner left
[16:01] <colomon> mathw: my point was just if the trend continues, I don't get to use C++0x for production code until 2025 or so...

[16:01] *** Psyche^ joined
[16:01] *** Psyche^ is now known as Patterner

[16:01] <colomon> and by then we'll have working Perl 6 to .NET compilers, so it will be pointless anyway.  :)

[16:01] *** nacho joined
[16:02] *** jonasbn left
[16:03] <PerlJam> Hmm. 

[16:03] <jnthn> Perl 6 on .Net would be cool. :-)

[16:03] * PerlJam listens to Growing a Language (keynote OOPSLA 1998)

[16:04] * moritz_ started too

[16:05] <pmurias> moritz_: what's wrong with comparing yourself to others?

[16:05] <PerlJam> moritz_: about 18 minutes in is an interesting bit that made me think of perl.

[16:06] <moritz_> pmurias: you can only compare comparable things

[16:06] <moritz_> pmurias: and depends on what you compare, you might not be comparable to other people

[16:06] *** xomas_ is now known as xomas

[16:06] <moritz_> pmurias: and you might not notice that, which results in unhappiness

[16:06] <PerlJam> I wonder how we can get people like Guy Steele  to help out with Perl 6 (and if that would even be beneficial.  It seems so, but what do I know?)

[16:10] *** cjk101010 joined
[16:22] *** uniejo left
[16:24] *** xomas left
[16:34] *** k23z__ joined
[16:36] * arnsholt is contemplating implementing a rudimentary gather/take in ruby

[16:54] <Tene> arnsholt: Cardinal, the ruby-on-parrot project, has it. :)

[16:55] *** macae left
[16:56] <arnsholt> Cool. I'm working on an existing project (which uses Rails) so I suspect ruby-on-parrot might not be an option

[16:56] <arnsholt> But I've found a module that supplies dynamic scope, so it should be reasonably simple to implement

[17:00] *** uniejo joined
[17:02] *** rindolf joined
[17:02] <rindolf> Hi all.

[17:02] <rindolf> OK, I think I'll learn some Perl 6 now.

[17:02] <Tene> hi

[17:03] <moritz_> rindolf: have fun

[17:03] <rindolf> moritz_: thanks.

[17:03] <rindolf> Hi Tene 

[17:03] <Tene> Nice to see you here, rindolf.

[17:04] <rindolf> Tene: :-)

[17:04] <sjohnson> Perl 6 will bring you happiness of the heart

[17:06] <diakopter> the hope of which, anyway.

[17:07] <sjohnson> one of my favourite features is the:  if (5 > y > 10) stuff

[17:07] <sjohnson> err

[17:07] <rindolf> sjohnson: that is always false.

[17:07] <sjohnson> 5 < y < 10

[17:07] <sjohnson> i mean

[17:07] <colomon> ng: my $a = NaN; say 5 > $a > 10

[17:07] <p6eval> ng cb7f23: OUTPUT«0␤»

[17:08] <moritz_> rindolf: unless y returns something of a type with a weird overloaded infix:«>» operator

[17:08] <rindolf> moritz_: heh, heh.

[17:08] <moritz_> I've learned to be careful with words like "all" around here

[17:09] <rindolf> How long is {{ say [+] (1..999).grep( { $_ % 3 == 0 || $_ % 5 == 0 } ); }} supposed to take?

[17:09] <colomon> huh.  now you've got me wondering if Rat > Rat works "correctly".

[17:10] <moritz_> rindolf: as short as possible

[17:10] <rindolf> moritz_: :-)

[17:10] <moritz_> takes 5s on my machine

[17:10] *** cdarroch joined
[17:10] *** cdarroch left
[17:10] *** cdarroch joined
[17:11] <pugs_svn> r29675 | lwall++ | [Spec] squash [;] fossils noticed by eternaleye++ 

[17:11] <jnthn> 5s?!

[17:11] *** cotto_working left
[17:11] <moritz_> yes

[17:11] <diakopter> rakudo: say [+] (1..999).grep( { $_ % 3 == 0 || $_ % 5 == 0 } );

[17:11] <p6eval> rakudo 1d4928:  ( no output )

[17:12] <colomon> btw, jnthn, getting [+] working again  in ng is something I'm interested in tackling soon.

[17:12] <diakopter> timed out on that vps.

[17:12] <jnthn> colomon: Cool

[17:12] <diakopter> rakudo: say [+] (1..99).grep( { $_ % 3 == 0 || $_ % 5 == 0 } );

[17:12] <p6eval> rakudo 1d4928: OUTPUT«2318␤»

[17:12] <diakopter> rakudo: say [+] (1..199).grep( { $_ % 3 == 0 || $_ % 5 == 0 } );

[17:12] <p6eval> rakudo 1d4928: OUTPUT«9168␤»

[17:13] <colomon> jnthn: I'm pretty sure I'm going to need help on the grammar for that.  :)

[17:13] <TimToady> rakudo: say [+] (1..999).grep: * !% 3|5

[17:13] <p6eval> rakudo 1d4928: OUTPUT«any([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:13] <p6eval> ..186, 189…

[17:13] <TimToady> rakudo: say [+] (1..999).grep(* !% 3|5)

[17:13] <p6eval> rakudo 1d4928: OUTPUT«any([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:13] <p6eval> ..186, 189…

[17:13] <diakopter> rakudo: say [+] ((1..999).grep: * !% 3|5)

[17:13] <p6eval> rakudo 1d4928: OUTPUT«any([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:13] <p6eval> ..186, 189…

[17:14] <TimToady> rakudo: say [+] (1..999).grep(* !% 3&5)

[17:14] <p6eval> rakudo 1d4928: OUTPUT«all([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:14] <p6eval> ..186, 189…

[17:14] <TimToady> hmm

[17:14] <diakopter> rakudo: say [+]((1..999).grep: * !% 3|5)

[17:14] <p6eval> rakudo 1d4928: OUTPUT«any([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:14] <p6eval> ..186, 189…

[17:15] <diakopter> rakudo: say [+](1..999).grep: * !% 3&5

[17:15] <p6eval> rakudo 1d4928: OUTPUT«all([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:15] <p6eval> ..186, 189…

[17:15] <TimToady> grep doesn't appear to be collapsing the junction

[17:15] <jnthn> rakudo: say 15 !% 3&5

[17:15] <p6eval> rakudo 1d4928: OUTPUT«all(Bool::True, 5)␤»

[17:15] <diakopter> rakudo: say [+](1..999).grep: * !% (3&5)

[17:15] <p6eval> rakudo 1d4928: OUTPUT«all([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:15] <p6eval> ..186, 189…

[17:15] <diakopter> rakudo: say 15 !% (3&5)

[17:15] <p6eval> rakudo 1d4928: OUTPUT«all(Bool::True)␤»

[17:16] <diakopter> base case

[17:16] <jnthn> Precedence.

[17:16] <TimToady> yes, the ! should be collapsing it

[17:16] <jnthn> rakudo: say 15 !% 3&5; say 15 !% (3&5);

[17:16] <TimToady> hmm

[17:17] *** justatheory joined
[17:17] <p6eval> rakudo 1d4928: OUTPUT«all(Bool::True, 5)␤all(Bool::True)␤»

[17:17] <TimToady> right

[17:17] <TimToady> rakudo: say [+] (1..999).grep(* !% (3|5))

[17:17] <p6eval> rakudo 1d4928: OUTPUT«any([3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183,

[17:17] <p6eval> ..186, 189…

[17:17] <jnthn> (Dunno if Rakudo's correct there.)

[17:17] <jnthn> It's still failing to collapse the junction to a single boolean value though.

[17:17] <TimToady> there's something that ought to be collapsing that isn't

[17:17] *** cotto_working joined
[17:18] <jnthn> say [+] (1..999).grep((* !% (3|5)).Bool)

[17:18] <jnthn> rakudo: say [+] (1..999).grep({(%_ !% (3|5)).Bool})

[17:18] <p6eval> rakudo 1d4928: OUTPUT«Method 'Bool' not found for invocant of class ''␤in Main (file src/gen_setting.pm, line 324)␤»

[17:18] <jnthn> rakudo: say [+] (1..999).grep({?(%_ !% (3|5))})

[17:19] <p6eval> rakudo 1d4928:  ( no output )

[17:19] <jnthn> :-/

[17:19] <TimToady> my feeling is that * !% junction should just be returning true or false, since ! is boolean

[17:19] <jnthn> That'd make sense to me too.

[17:20] <TimToady> and, in fact, the ! metaop is really outside in the same sense as not()

[17:20] *** rv2733 left
[17:20] <TimToady> that would be a useful test for someone to write

[17:23] *** orafu left
[17:23] <TimToady> since, in any case $a != (2|3) should probably really mean not($a == (2|3)) if we following English semantics

[17:23] *** orafu joined
[17:25] <TimToady> assuming we rewrite != to ![==] and always hoist the negation to outside so that junctions never see negative operators

[17:26] <TimToady> this would provide Least Surprise

[17:29] <rindolf> How do I prepend a string to $s with p6?

[17:29] <pmichaud> $s ~= 'string'

[17:29] <pmichaud> oh, prepend

[17:29] <pmichaud> $s = 'string' ~ $s

[17:30] <pmichaud> or

[17:30] <pmichaud> $s = "string$s"

[17:30] <rindolf> pmichaud: ah.

[17:30] <TimToady> hmm

[17:31] <TimToady> $s [R~]= 'string'

[17:31] <pmichaud> I thought about that briefly.

[17:31] <PerlJam> TimToady++ you beat me to it

[17:31] <TimToady> but might not actually work

[17:31] <pmichaud> afk, lunchish

[17:32] <rindolf> my $s = "Sophie"; $s R~= "Hello "; say $s doesn't work.

[17:32] <TimToady> probably parses as R[~=]

[17:32] <pmichaud> I'm certain it doesn't work in Rakudo yet.

[17:32] <rindolf> Confused at line 1, near "[R~]= \"Hel"

[17:32] <pmichaud> Rakudo doesn't understand multiple metas.

[17:32] <TimToady> still writes out all the cases on spec?

[17:32] <moritz_> std: 1 [R~]= 2

[17:33] <p6eval> std 29675: OUTPUT«ok 00:01 107m␤»

[17:33] <pmichaud> ng will handle metas (or at least attempt it... not sure about multiple metas yet :-)

[17:34] <TimToady> ng: my $s = "Sophie"; $s [R~]= "Hello "; say $s

[17:34] <p6eval> ng cb7f23: OUTPUT«Confused at line 1, near "$s [R~]= \""␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[17:34] <pmichaud> "will" === "not yet"   :-|

[17:34] *** cognominal left
[17:35] <TimToady> ng: my $s = "Sophie"; "Hello " R~= $s; say $s

[17:35] <p6eval> ng cb7f23: OUTPUT«Confused at line 1, near "\"Hello \" R"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[17:37] *** macae joined
[17:37] <TimToady> perl6: my $s = "Sophie"; substr($s,0,0) = "Hello "; say $s

[17:37] <p6eval> rakudo 1d4928: OUTPUT«Sophie␤»

[17:37] <p6eval> ..pugs: OUTPUT«Hello Sophie␤»

[17:37] <p6eval> ..elf 29675: OUTPUT«Can't modify non-lvalue subroutine call in scalar assignment at (eval 125) line 4, near ""Hello\ ")"␤ at ./elf_h line 5881␤»

[17:38] <TimToady> er, what did rakudo do with the Hello?

[17:38] <TimToady> ng: my $s = "Sophie"; substr($s,0,0) = "Hello "; say $s

[17:38] <p6eval> ng cb7f23: OUTPUT«Cannot assign to readonly value␤current instr.: '&infix:<=>' pc 15051 (src/builtins/Junction.pir:113)␤»

[17:38] <pmichaud> substr() returned a value

[17:38] <pmichaud> and the assignment overwrote it

[17:38] <[particle]> IT EATED IT

[17:39] <pmichaud> because rakudo (master) allows writing over "constant" values

[17:39] <TimToady> perl6: my $s = "Sophie"; substr($s,0,0, "Hello "); say $s

[17:39] <p6eval> elf 29675, pugs: OUTPUT«Sophie␤»

[17:39] <p6eval> ..rakudo 1d4928: OUTPUT«too many positional arguments: 4 passed, 4 expected␤in Main (file <unknown>, line <unknown>)␤»

[17:39] <pmichaud> or, phrased differently, rakudo's substr doesn't return a modifiable lvalue for replacement

[17:40] <TimToady> should probably split out an insert() instead of overloading a 4-arg substr

[17:41] <TimToady> perl6: my $s = "Sophie"; $s ~~ s[^] = "Hello "; say $s

[17:41] <p6eval> rakudo 1d4928: OUTPUT«s/// not implemented, try .subst as workaround at line 10, near " = \"Hello "␤in Main (file <unknown>, line <unknown>)␤»

[17:41] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.14/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[17:41] <p6eval> ..elf 29675: OUTPUT«Parse error in: /tmp/6C27J5a5iZ␤panic at line 1 column 18 (pos 18): Can't understand next input--giving up␤WHERE: my $s = "Sophie"; $s ~~ s[^] = "Hello "; say $s␤WHERE:                  /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤ 

[17:41] <p6eval> ..STD_re…

[17:41] <rindolf> rakudo: say ((5,6,3) X+ (100,200,300)).perl

[17:41] <p6eval> rakudo 1d4928: OUTPUT«[105, 205, 305, 106, 206, 306, 103, 203, 303]␤»

[17:43] <rindolf> say ((5,6,3) X(min) (100,200,300)).perl ==> how do I write it properly?

[17:43] <TimToady> rakudo: say (5,6,3 X[min] 100,200,300).perl

[17:43] <p6eval> rakudo 1d4928: OUTPUT«[5, 100, 6, 100, 3, 100]␤»

[17:44] <TimToady> rakudo: say (5,6,3 Xmin 100,200,300).perl

[17:44] <p6eval> rakudo 1d4928: OUTPUT«[5, 5, 5, 6, 6, 6, 3, 3, 3]␤»

[17:44] <moritz_> std: 1 Xmin 2

[17:44] <p6eval> std 29675: OUTPUT«ok 00:01 105m␤»

[17:44] <TimToady> rakudo doesn't understand [] infixes

[17:44] *** cotto_working left
[17:44] <TimToady> so misparses X[min] as X [min]

[17:45] *** cotto_working joined
[17:45] <TimToady> rakudo: say 1 [+] 2

[17:45] <p6eval> rakudo 1d4928: OUTPUT«Confused at line 10, near "[+] 2"␤in Main (file <unknown>, line <unknown>)␤»

[17:45] <TimToady> ng: say 1 [+] 2

[17:45] <p6eval> ng cb7f23: OUTPUT«Confused at line 1, near "say 1 [+] "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[17:46] <TimToady> std: say 1 [+] 2

[17:46] <p6eval> std 29675: OUTPUT«ok 00:01 106m␤»

[17:46] <TimToady> std: say 1 [[[[[+]]]]] 2

[17:46] <p6eval> std 29675: OUTPUT«ok 00:01 106m␤»

[17:47] <TimToady> S04:4394

[17:47] <TimToady> er, S03:4394

[17:48] *** cognominal joined
[17:51] *** jaldhar left
[17:51] *** jaldhar joined
[17:56] <rindolf> say (^10).list.perl

[17:57] <colomon> ng: say (^10).list.perl

[17:57] <p6eval> ng cb7f23: OUTPUT«0..^10␤»

[17:59] <TimToady> ng: say (^10).flat.perl

[17:59] <p6eval> ng cb7f23: OUTPUT«Method 'flat' not found for invocant of class 'Range'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:59] <TimToady> ng: say (^10,).perl

[17:59] <p6eval> ng cb7f23: OUTPUT«(0..^10, )␤»

[17:59] *** dakkar left
[17:59] <TimToady> well, flat should do it

[17:59] <colomon> ng: say (^10).batch(10).perl

[17:59] <p6eval> ng cb7f23: OUTPUT«Method 'batch' not found for invocant of class 'Range'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[18:00] <colomon> ng: say (^10).iterator.batch(10).perl

[18:00] <p6eval> ng cb7f23: OUTPUT«(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)␤»

[18:00] <TimToady> Range probably needs an Any/Cool loopback to listify

[18:01] <TimToady> or flatten, maybe

[18:01] <colomon> ng: my @a = 1, 2; say &infix:<cmp>(|@a);

[18:01] <p6eval> ng cb7f23: OUTPUT«Confused at line 1, near "say &infix"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[18:01] <colomon> TimToady: or possible Iterable needs some additional functions.  It's all still kind of sketchy at the moment.  :)

[18:03] <colomon> ng: my @a = 1, 2; sub f($a, $b) { say "a = $a and b = $b"; }; f(|@a);

[18:03] <p6eval> ng cb7f23: OUTPUT«Confused at line 1, near "f(|@a);"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[18:03] <TimToady> this whole loopback scheme is all about tagmemics; if you use X as if it were a Y, then there's a semantic mechanism to do that.

[18:03] <TimToady> verbing nouns, and such

[18:04] <TimToady> a lot of methods use their invocant as a list or slice

[18:04] <TimToady> so the loopback gives the general mechanism so we *don't* end up scattering the coercions all over the palce

[18:04] <TimToady> *place

[18:04] <colomon> TimToady: sure, but Range actually is Iterable, which should mean it knows how to be used as a list or slice.

[18:05] <colomon> (I would think, anyway.)

[18:05] <TimToady> but it's the Coolish method that figures that out

[18:05] <TimToady> Oh, I got something that doesn't respond to .batch, but I know that it's Iterable, so I'll iterate it for .batch

[18:06] <TimToady> likewise for grep etc

[18:06] <TimToady> we shouldn't be putting a .grep method in everything iterable

[18:08] <TimToady> DRY, and all that

[18:08] <PerlJam> what is .batch again?

[18:08] <TimToady> N at a time

[18:09] <PerlJam> gotcha

[18:09] <TimToady> .batch(10) asks for 10, while .batch() just asks for "some"

[18:09] <colomon> TimToady: right, but if the .grep method was on Iterable itself, you wouldn't be repeating yourself for each iterable class.

[18:10] <PerlJam> er, .batch() asks for "some"?  That makes it behave like a lazy list?

[18:10] <colomon> mind you, I don't think .grep is the right granularity, it should be something like .list.

[18:10] <colomon> PerlJam: even if you ask for 10, it might still be lazy.

[18:10] <moritz_> PerlJam: laziness isn't guarantueed like in Haskell

[18:11] <PerlJam> colomon: aye, it's not the laziness I was worried about, but the listiness.

[18:11] <PerlJam> (dunno why I typed "lazy list" then, but weird things happen)

[18:11] <colomon> PerlJam: I'm not sure there's a distinction between the two anymore?

[18:11] <TimToady> anything .batch hands back is already evaluated

[18:12] <TimToady> it's the "how eager I want to be right now" method

[18:12] *** ShaneC1 joined
[18:12] <colomon> ng: say (^10).grep{{$^a %3 == 1}).batch(10).perl.say

[18:12] <p6eval> ng cb7f23: OUTPUT«Confused at line 1, near "say (^10)."␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[18:12] <TimToady> in supply and demand, it's the demand

[18:12] <colomon> ng: say (^10).grep({$^a %3 == 1}).batch(10).perl.say

[18:12] <p6eval> ng cb7f23: OUTPUT«(1, 4, 7)␤1␤»

[18:13] <PerlJam> okay, the jibes with what I was thinking even if I wasn't expressing it clearly.

[18:13] <colomon> TimToady: so in fact, .grep already works this way.  It calls .list internally.  :)

[18:13] <TimToady> well, should probably be calling flat now...

[18:14] <TimToady> but yeah, Iterable is a good place for that

[18:14] <TimToady> it's the non-Iterable that needs an Any entry

[18:14] <TimToady> to just return itself as a singleton iterator

[18:14] <TimToady> so that 42.grep works

[18:16] <TimToady> anyway, .list doesn't really mean much now, and it certainly doesn't flatten

[18:17] *** Su-Shee left
[18:22] <TimToady> nowadays .list means only "get the iterator from this and return it in a Parcel for later contextualization"

[18:23] <TimToady> and .slice and .flat imply .list

[18:24] <colomon> Does anyone out there have a clue how one would go about implementing f(|@a)?

[18:24] <colomon> I think I've patched it in the grammar, but that's only the first step...

[18:25] <colomon> (in ng, I mean.)

[18:26] <jnthn> Can maybe get away with something like what master does for now.

[18:26] <jnthn> But really probably needs constructing a capture.

[18:26] <jnthn> If latest spec still says that's what it does. :-)

[18:28] <colomon> jnthn: any idea where that would be located in master?

[18:28] <colomon> (I'm willing to accept half-measures if they work.  :)

[18:31] <jnthn> colomon: In the old actions.pm, I think.

[18:32] <jnthn> colomon: It probably examines the sigil of the variable that follows and sets .flatten() on the past node, or maybe .flatten() and .named()

[18:33] <colomon> named only if the sigil is %

[18:34] *** hercynium left
[18:34] <colomon> You think that will work in ng?

[18:35] * colomon is in almost but not quite completely, over his head.

[18:36] <sjohnson> hi colomon 

[18:36] <colomon> sjohnson: o/

[18:36] *** stephenlb joined
[18:37] *** stephenlb left
[18:37] <jnthn> colomon: I don't see why not. It'll have the same imperfections master has I guess, that's all.

[18:37] <jnthn> hi sjohnson 

[18:37] <sjohnson> jnthn: hi!  may I ask you an OT question

[18:37] *** stephenlb joined
[18:38] *** Su-Shee joined
[18:38] <sjohnson> just wondering if you are like me, in that you use Windows for desktop use, yet use things like Strawberry Perl, unxtools on sourceforge, and dislike cygwin

[18:38] <jnthn> I tried cygwin and never got on with it.

[18:38] <sjohnson> unxtools == http://sourceforge.net/projects/unxutils/

[18:39] <jnthn> I don't use that specifically, I did grab some utilities from some other gnu tools porting project though. I forget where. :-)

[18:40] <jnthn> I've tended to use ActivePerl a bit more, though mostly because I just had it around for longer.

[18:40] <jnthn> I've installed Strawberry elsewhere too though.

[18:41] <sjohnson> i am finding i like Strawberry a bit more

[18:41] <sjohnson> as it feels less corporate, the install is simpler and less nonsense, and for me, CPAN works a bit better

[18:42] <sjohnson> i've tried ubuntu and others about half a dozen times, and i find that Microsoft's OS's (the good ones) aren't really all that bad

[18:42] <jnthn> Yeah, I found CPAN smoother on Strawberry.

[18:42] <colomon> jnthn: was it DEBUG that did say from NQP?

[18:43] <jnthn> iirc, yes

[18:43] <jnthn> sjohnson: Oh, I find XP plenty usable, and 7 seems decent enough.

[18:43] <jnthn> The trick is to try and skip the sucky releases. :)

[18:44] <sjohnson> jnthn: yes i have found i prefer 7 more than XP, but XP was very good.  I strongly disliked Vista though, as i'm sure that isn't a surprise to anyone

[18:44] <sjohnson> Vista is like the Windows ME of >2000 OS's

[18:44] <sjohnson> i'm almost.. considering... *gasp*.. paying for windows 7 for my home use

[18:45] <sjohnson> as the prices are very reasonable now.  100+ bucks or so, instead of 500 like the days of yore

[18:45] <sjohnson> with XP

[18:45] *** cjk101010 left
[18:46] *** justatheory left
[18:48] <colomon> oh, that compiled.

[18:48] <colomon> I'm kind of scared now.

[18:49] <colomon> "flattened parameters must be a hash or array"

[18:50] <jnthn> :-)

[18:50] <jnthn> Wonder whoz op with that.

[18:50] *** justatheory joined
[18:50] <colomon> surely that should be positional or associative now, right?  :)

[18:51] <jnthn> I thought it looked at the sigil

[18:51] <jnthn> In which case, it's just that it's looking at it the wrong way. :-)

[18:51] <jnthn> I want to go find some nom now, but I'll not be gone long...feel free to nopaste the diff and I'll look in a moment when I'm back.

[18:51] <lisppaste3> colomon pasted "experimental code to implement f(!@a) in ng" at http://paste.lisp.org/display/94713

[18:53] <colomon> that error message isn't actually from rakudo -- must be in parrot?

[18:55] <lisppaste3> colomon annotated #94713 "new code in context" at http://paste.lisp.org/display/94713#1

[19:00] *** uniejo left
[19:13] *** xomas_ joined
[19:13] *** xomas_ left
[19:13] *** xomas_ joined
[19:14] *** uniejo joined
[19:18] *** cl58 joined
[19:24] <jnthn> back

[19:24] <jnthn> colomon: I thought about prefix:<|> while away.

[19:24] <jnthn> colomon: I don't think porting the old impl from master will fly :-(

[19:24] <colomon> :(

[19:25] <jnthn> colomon: Because of (a) our arrays has-a ResizablePMCArray now rather than is one, but also (b) it'd probably play badly with laziness.

[19:25] <jnthn> So I figure we're gonna have to do it "properly"

[19:25] <jnthn> Whatever properly means.

[19:25] <colomon> btw, I have .reduce working on binary functions now.  (easiest workaround for lack of f(|@a))

[19:25] <jnthn> OK, cool.

[19:26] <colomon> how would it play badly with laziness?

[19:26] <colomon> oh, i think i see

[19:27] <jnthn> Parrot would want to have all of the elements, I suspect.

[19:27] <colomon> yeah

[19:27] <jnthn> But (a) is a far bigger problem.

[19:27] <colomon> it doesn't know about laziness at all.

[19:27] <jnthn> (In terms of taking the approach master does, at any rate)

[19:27] <jnthn> Right

[19:27] <jnthn> I'll think about it, I don't have an immediate good answer.

[19:27] <colomon> okay

[19:28] <colomon> I'm going to work on cleaning what I've got that works and pushing it.

[19:31] <jnthn> Cool

[19:32] <jnthn> I noticed you won us back a good bunch of tests too :-)

[19:32] <jnthn> colomon: Is there anything I should look at that's blocking you?

[19:33] <jnthn> (Aside from prefix:<|> but I think that needs a bit more thought...)

[19:33] *** old_gray_bear joined
[19:34] <colomon> jnthn: as far as I know most Rat fixes should be straightforward with multi dispatch working.

[19:35] <colomon> there is the issue with weirdness with in getting the right $_ in grep.

[19:36] <colomon> ng: (^10).grep({say $_; 1;}).eager

[19:36] <p6eval> ng cb7f23: OUTPUT«Mu()␤Mu()␤Mu()␤Mu()␤Mu()␤Mu()␤Mu()␤Mu()␤Mu()␤Mu()␤»

[19:36] *** mberends joined
[19:36] <colomon> that's not exactly blocking, but we'd win back a fair number of tests it it worked.

[19:37] <colomon> I suspect that one is either really easy or really hard

[19:40] <pmichaud> back

[19:41] <dalek> rakudo/ng: 2a0400a | (Solomon Foster)++ | src/core/Any-list.pm:

[19:41] <dalek> rakudo/ng: Add Any.reduce.  Only works on binary functions for the moment.

[19:41] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/2a0400a34f09f91be32327e7aed467d477dbf959

[19:41] <dalek> rakudo/ng: 9c17cb6 | (Solomon Foster)++ | src/Perl6/Grammar.pm:

[19:41] <dalek> rakudo/ng: Add prefix:sym<|> to the grammar.

[19:41] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/9c17cb667a992f54bae2f7999f526da3def1af31

[19:41] <pugs_svn> r29676 | colomon++ | [t/spec] Unfudge .reduce test now that enough of .reduce is implemented to run it.  

[19:41] <colomon> \o/

[19:41] *** cl58 left
[19:42] <colomon> jnthn: on the whole, my problem right now isn't being blocked.  it's having too many cool corners to explore.

[19:42] <colomon> :)

[19:42] *** cl58 joined
[19:43] *** hercynium joined
[19:43] *** hercynium left
[19:43] *** hercynium joined
[19:43] <colomon> also only being able to type one-handed thanks to having a napping child in my lap.  :)

[19:45] <colomon> jnthn: oh, there is still the ... thing

[19:45] <colomon> ng: (1, 3, 5 ... *).batch(10).perl.get

[19:45] <p6eval> ng cb7f23: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Parcel'␤current instr.: '!postcircumfix:<[ ]>' pc 314753 (src/gen/core.pir:41266)␤»

[19:46] *** jonasbn joined
[19:46] *** rindolf left
[19:47] *** ewilhelm joined
[19:47] *** iblechbot joined
[19:48] <ewilhelm> pmichaud, did you post the code from your oscon lightning talk?

[19:49] <pmichaud> ewilhelm: I don't remember if I did or not.  But I certainly can :-)

[19:49] <ewilhelm> that would be awesome.  I seem to remember that it was quite an example of operators and other features.

[19:49] *** araujo left
[19:50] <pmichaud> http://www.pmichaud.com/2009/pres/oscon-perl6op

[19:50] <pmichaud> it's in there :-)

[19:50] <pmichaud> http://www.pmichaud.com/2009/pres/oscon-perl6op/slides/slide5.html

[19:50] *** araujo joined
[19:52] <ewilhelm> thanks.  Did you get my mail last month?

[19:52] <colomon> oooo, that's nice (not in reference to pmichaud's classic example :)

[19:53] <pmichaud> yes, but I've been very far behind on email

[19:53] <ewilhelm> trying to put together a "what you've missed in the last several years" talk for a mostly ruby-using crowd

[19:53] *** araujo left
[19:54] <ewilhelm> if anybody has suggestions, that would be great.  I thought I might work through the advent calendar as well.

[19:54] *** dugg left
[19:54] *** araujo joined
[19:56] *** ShaneC2 joined
[19:56] *** ShaneC1 left
[19:57] <pmichaud> (advent calendar)++

[19:58] <frettled> (++)++

[19:58] <frettled> pmichaud: so, ehrm, are you restful?

[19:58] <pmichaud> getting there :-)

[19:59] <pmichaud> vacation was excellent, but lots of things stacked up while I was out :-|

[19:59] <frettled> I know the feeling all too well.

[19:59] <frettled> I'm still trying to catch up with the consequences of Christmas.

[20:00] <TimToady> phone

[20:00] <frettled> hello?

[20:00] *** cl58 left
[20:02] <frettled> seems like a prank call ;)

[20:03] <frettled> pmichaud: I'm still enthused with ng

[20:03] * PerlJam wonders if there's a speech to text thingy that chromatic could use for the cabalcall

[20:04] *** old_gray_bear left
[20:04] <PerlJam> frettled: good.  many people are enthused but slightly annoyed that ng isn't called master :)

[20:04] <PerlJam> ("many" may have been too strong)

[20:04] <pmichaud> ("slightly" may have been too weak :-)

[20:05] <frettled> PerlJam: I have a very, very large ego, and I want it to be called master.  My ego is so large it counts for ten people.

[20:05] <PerlJam> that too :)

[20:05] <PerlJam> frettled: how big are your id and superego?

[20:05] <frettled> PerlJam: Mu⁴

[20:08] <colomon> ng: say 61731 * 61731

[20:08] <p6eval> ng 9c17cb: OUTPUT«3810716361␤»

[20:08] <colomon> ng: say 

[20:08] <p6eval> ng 9c17cb: OUTPUT«␤»

[20:08] <frettled> ng: say 2²

[20:08] <p6eval> ng 9c17cb: OUTPUT«Confused at line 1, near "say 2\x{b2}"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[20:08] <frettled> döh :)

[20:09] <frettled> I figured just now that writing the exponent like that would be really cool.

[20:09] * PerlJam idly wonders if there's a way to curry ** for all of those numeric superscripts.

[20:09] <PerlJam> (an "easy" way)

[20:10] <PerlJam> ng: say "\x{b2}"

[20:10] <p6eval> ng 9c17cb: OUTPUT«Could not find non-existent sub &b2␤current instr.: '_block23' pc 110 (EVAL_1:50)␤»

[20:10] <PerlJam> ng: say \x{b2}

[20:10] <p6eval> ng 9c17cb: OUTPUT«Confused at line 1, near "say \\x{b2}"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[20:10] <frettled> ⁽¹²³⁴⁵⁶⁷⁸⁹⁾

[20:11] <colomon> rakudo: say 61731 * 61731

[20:11] <p6eval> rakudo 1d4928: OUTPUT«3810716361␤»

[20:11] <PerlJam> colomon: were you hoping the answer to change? :)

[20:11] <colomon> yes.

[20:11] <colomon> wish there was a sheepish smiley

[20:12] <frettled> :-}

[20:12] <colomon> trying to track down a Rat math problem, but it turns out to be a test glitch!

[20:19] <pugs_svn> r29677 | colomon++ | [t/spec] Unfudge 22 tests thanks to jnthn++'s dispatch fix.  Also fix a broken test. 

[20:19] *** payload joined
[20:19] <frettled> PerlJam: I guess I'm just a bit tired, since I missed your comment regarding currying, and now that I saw it, I don't really understand what you're getting at :)

[20:21] *** ruoso left
[20:22] <TimToady> :】

[20:22] <dalek> rakudo/ng: eeff25d | (Solomon Foster)++ | src/core/Rat.pm:

[20:22] <dalek> rakudo/ng: Pull in the updated Rat operators from master.

[20:22] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/eeff25d732e56331d5e32363655a6ee1524a54af

[20:23] <colomon> ng: say 1;

[20:23] <p6eval> ng 9c17cb: OUTPUT«1␤»

[20:24] <frettled> TimToady: there are two dots next to your phone handset?

[20:24] <PerlJam> frettled: one way to get 2² to actually do the math is to define a postfix:<²> that takes an arg and squares it.  This can be done with ** as   $n ** 2.  I was thinking of how one could automatically do  that with all of the superscripts changing the 2 to the appropriate number.

[20:25] <colomon> ng: (^1000).grep({my $b = $^a; ($b % 3 == 0) || ($b % 5) == 0}).reduce({$^a + $^b}).say

[20:26] <p6eval> ng 9c17cb:  ( no output )

[20:26] <frettled> PerlJam: yeees, but will it then work intuitively for expressions?

[20:26] <colomon> > (^1000).grep({my $b = $^a; ($b % 3 == 0) || ($b % 5) == 0}).reduce({$^a + $^b}).say

[20:26] <colomon> 233168

[20:27] <PerlJam> frettled: it should

[20:27] *** payload left
[20:27] *** Chillance left
[20:28] <frettled> So now we only need to support Knuth's ↑ notation ;)

[20:29] <frettled> That's a bit more tricky.

[20:29] *** justatheory left
[20:29] <colomon> ng: (^1000).grep({($^b % 3 == 0) || ($b % 5) == 0}).reduce({$^a + $^b}).say

[20:29] <p6eval> ng 9c17cb:  ( no output )

[20:29] *** ashleyb joined
[20:29] <colomon> dang it, still not fast enough

[20:29] *** ash__ joined
[20:30] <frettled> hmm

[20:31] <jnthn> Dinner: nommed.

[20:31] <frettled> PerlJam: Just in case you're not familiar with it: http://en.wikipedia.org/wiki/Knuth's_up-arrow_notation

[20:31] <jnthn> Rakudo hacking!

[20:31] <colomon> \o/

[20:31] <PerlJam> ng: sub foo ($a,$b) { say "$a $b"; }; foo(3,5);  my &x = &foo.assuming( b => 7);

[20:31] <p6eval> ng 9c17cb: OUTPUT«3 5␤»

[20:31] <PerlJam> ng: sub foo ($a,$b) { say "$a $b"; }; foo(3,5);  my &x = &foo.assuming( b => 7);  x(19);

[20:31] <p6eval> ng 9c17cb: OUTPUT«3 5␤19 7␤»

[20:32] <frettled> jnthn: so, do you like the idea of using ⁽¹²³⁴⁵⁶⁷⁸⁹⁰⁻⁺⁾ directly?

[20:33] <PerlJam> ng: our &postfix:<²> := &infix:<**>.assuming(b => 2); say 2²;

[20:33] <p6eval> ng 9c17cb: OUTPUT«Confused at line 1, near "our &postf"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[20:33] <PerlJam> ng: &postfix:<²> := &infix:<**>.assuming(b => 2); say 2²;

[20:33] <p6eval> ng 9c17cb: OUTPUT«Confused at line 1, near "&postfix:<"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[20:34] <PerlJam> std: our &postfix:<²> := &infix:<**>.assuming(b => 2); say 2²;

[20:34] <p6eval> std 29677: OUTPUT«ok 00:02 132m␤»

[20:34] <jnthn> PerlJam: user defined ops don't work yet in ng. :-P

[20:34] <PerlJam> i'm going to go with NYI for rakudo unless someone can show me different

[20:35] <PerlJam> ah, there we go

[20:35] <frettled> heh

[20:35] <PerlJam> jnthn: they work in master?

[20:35] <ash__> colomon++ jnthn++ so many commits in the last 24 hours, i take it ng is going well? 

[20:35] <jnthn> Yeah, should do.

[20:35] <PerlJam> rakudo: our &postfix:<²> := &infix:<**>.assuming(b => 2); say 2²;

[20:35] <p6eval> rakudo 1d4928: OUTPUT«Confused at line 10, near "\x{b2};"␤in Main (file <unknown>, line <unknown>)␤»

[20:35] <jnthn> ash__: Not bad. :-)

[20:36] <colomon> ash__: we are definitely making progress again.  :)

[20:38] <mberends> since the ng spectest count is rising strongly, I think it's time to give it its own docs/spectest-progress.csv and start doing those graphs again

[20:38] <phenny> mberends: 09 Feb 22:47Z <jnthn> tell mberends sorry, connection dropped...I think use and require may need some review since imports need to be lexical etc - check with Pm.

[20:39] <colomon> mberends++ # fine idea

[20:39] *** ash___ joined
[20:40] <ash___> what % of tests does ng pass compared to master?

[20:40] <mberends> it was about 18% recently

[20:40] <ash___> cool

[20:41] *** hercynium left
[20:41] *** ash__ left
[20:42] *** justatheory joined
[20:42] <frettled> PerlJam: (sorry, was AFK) - now, how about <⁽>, <⁾>, <⁺>, and <⁻>? :->

[20:42] *** cognominal left
[20:42] *** cognominal joined
[20:46] <ash___> are nqp classes parrot classes once they get compiled? 

[20:52] <jnthn> ash___: Sorta, but no more than in the sense that Perl 6 ones are.

[20:52] <jnthn> ash___: That is, we create a Parrot class behind the scenes, but it's dealt with by the metaclass.

[20:53] <ash___> yeah, but if you define a class in NQP for a parser, what kind of object is that? a parrot one? under the hood i mean

[20:53] <jnthn> Under the hood, yes.

[20:54] <PerlJam> at least until NQP gets some other backend  :)

[20:56] <dalek> rakudo/ng: 54ca0fa | jonathan++ | t/spectest.data:

[20:56] <dalek> rakudo/ng: Add back three more test files that we've come to pass.

[20:56] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/54ca0fa2ccf86e1888c555c12624799f1a941fec

[20:57] <colomon> \o/

[20:57] <jnthn> Where I kinda want to end up is that we have "knowhow" as the primitive that the VM provides, and then ClassHOW is written in NQP or some such.

[20:57] <jnthn> colomon: Small ones, but nice to have. :-)

[20:57] <jnthn> ng: my $x; say $x.notdef

[20:57] <p6eval> ng eeff25: OUTPUT«1␤»

[20:57] <pmichaud> (spectest-progress.csv)

[20:58] <pmichaud> my intent is to (re)do list assignment and array fixes tonight, then switch ng branch to master shortly thereafter (probably tomorrow afternoonish)

[20:58] <pmichaud> if things go smoothly tonight I could do the branch rename tonight

[20:58] <ash___> whats the diff between notdef and defined? 

[20:58] *** macae left
[20:58] <colomon> jnthn: I reckon every one that can added in is a Good Thing, because more tests running is more assurance we're not breaking stuff as we work.

[20:58] <jnthn> ash___: !

[20:58] <pmichaud> then I'll bring spectest up to date

[20:59] <jnthn> colomon: Right.

[20:59] <mberends> pmichaud++

[20:59] <pmichaud> we'll see a big drop in spectest-progress.csv as a result... but that's reality :-)

[20:59] <mberends> ng: my $t1=time;run "sleep 10";my $t2=time;say $t2-$t1 # sleep() without a function

[20:59] <p6eval> ng eeff25: OUTPUT«10.0636529922485␤»

[20:59] <jnthn> :-P

[20:59] <pmichaud> ("time" is a function :-)

[20:59] <jnthn> mberends: That's cheating! :-)

[21:00] <pmichaud> (so is "run" :)

[21:00] <pmichaud> (so is "say" :)

[21:00] <jnthn> pmichaud: Sounds like a good plan. ng is coming along quite quickly at the moment.

[21:00] <pmichaud> jnthn: I agree, you all are doing great work.   :)

[21:00] <jnthn> pmichaud: Question.

[21:00] <mberends> btw, we have no safe mode again

[21:00] <jnthn> pmichaud: What's your plan on Match objects?

[21:00] <ash___> jnthn: i don't think i understand what you meant by ! 

[21:01] <pmichaud> jnthn: (Match)  I was planning to keep an approach similar to rakudo master... why?

[21:01] <jnthn> ash___: Heh, that'll teach me to be lazy. ;-)

[21:01] <colomon> ash___:  he means notdef is !defined

[21:01] <pmichaud> (keeping in mind that Match is different between nqp-rx and PGE)

[21:01] <jnthn> ash___: It is just method notdef() { !self.defined }

[21:01] <jnthn> :-)

[21:01] * colomon must admit he thought jnthn  was excited at first...

[21:02] <jnthn> pmichaud: I mean, at the moment postcircumfix:<[ ]> and <{ }> are not implemented by Regex::Match

[21:02] <ash___> ah, okay, i get it 

[21:02] <pmichaud> jnthn: they weren't implemented by PGE::Match either :-)

[21:02] <jnthn> pmichaud: Are we going to subclass it and implement those in a subclass? Add a cheat that pokes them in?

[21:02] <jnthn> pmichaud: Or treat them as foreign?

[21:02] <pmichaud> jnthn: probably whatever was done in master applies :)

[21:02] <ash___> ng: "hi" ~~ /(.*)i/; say $/; say $0; # i can haz $0 works now?

[21:03] <p6eval> ng eeff25: OUTPUT«Confused at line 1, near "say $0; # "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[21:03] <pmichaud> we will subclass it though, yes.

[21:03] <jnthn> ash___: You can't, I'm currently interrogating Pm on how to get us it back. ;-)

[21:03] <pmichaud> looks like in master we treated them as foreign aggregates

[21:04] <jnthn> OK.

[21:04] <pmichaud> I'd say do the same here for now

[21:04] <jnthn> That can work too.

[21:04] <jnthn> Might try and pop that in tonight.

[21:04] <jnthn> It's be Nice To Have.

[21:04] <pmichaud> ng:  "hi" ~~ /(.*)i/;  say $/[0];

[21:04] <p6eval> ng eeff25: OUTPUT«Can't postcircumfix:<[ ]> foreign objects yet.␤current instr.: '!postcircumfix:<[ ]>' pc 316355 (src/gen/core.pir:41714)␤»

[21:04] <pmichaud> hmmmm

[21:05] <pmichaud> well, I expect to also deal with grammars in the next 24h

[21:05] <ash___> $/<something> isn't working yet either 

[21:05] <pmichaud> depends on what else comes up around here, though

[21:05] <jnthn> Sure.

[21:05] <jnthn> There's loads of little bits to work on. :-)

[21:06] <pugs_svn> r29678 | jnthn++ | [t/spec] Couple of unfudges in a test file for tests that we now pass that master didn't. 

[21:06] <colomon> we have a week until the next release?

[21:06] <jnthn> Is that all?!

[21:06] <pmichaud> week + day :)

[21:06] <jnthn> Ooh, yes.

[21:07] <pmichaud> I know I haven't been very P6-productive lately; apologies to the group for that.  :-|

[21:07] <TimToady> maybe postfixes should have a ! metaoperator too

[21:07] <TimToady> $x.!defined

[21:07] <TimToady> $x!.defined

[21:08] <pmichaud> !$x.defined :-)

[21:08] <ash___> (insipired by ruby) $x.defined? 

[21:08] <TimToady> !really_long_expression.defined.oops_there_was_more

[21:08] <mberends> pmichaud: (P6-productive) that's cost you 0.1% of your forgiveness capital ;)

[21:09] *** synth left
[21:09] *** synth joined
[21:10] <mberends> spectest-progress.csv update: 115 files, 3235 (20.4% of 15828) pass, 0 fail

[21:10] <jnthn> eek

[21:10] <jnthn> .sub '!FAIL' .param pmc args            :slurpy $P0 = new ['Undef'] .return ($P0)

[21:10] <jnthn> .end

[21:11] <jnthn> Undef is no more. :-)

[21:11] * jnthn changes it cheat differently.

[21:11] <TimToady> it's undefined...

[21:11] <jnthn> TimToady: Right

[21:11] <PerlJam> unMu

[21:11] <jnthn> TimToady: But there ain't an Undef type.

[21:11] *** cognominal left
[21:12] *** cognominal joined
[21:14] <[particle]> Undef is undefined

[21:14] <[particle]> it's pushing up NaNs

[21:15] <ash___> undef !== Undef basically? 

[21:17] <TimToady> std: undef

[21:17] <p6eval> std 29678: OUTPUT«===SORRY!===␤Unsupported use of undef as a value; in Perl 6 please use something more specific:␤       Mu (the "most undefined" type object),␤   an undefined type object such as Int,␤    Nil as an empty list,␤    *.notdef as a matcher or method,␤ Any:U as a type

[21:17] <p6eval> ..constraint␤       or …

[21:18] *** takadonet left
[21:27] <TimToady> phenny: tell masak Positive lookaheads must be compiled at compile time, or they cannot participate in LTM as specced, and as STD implements.

[21:27] <phenny> TimToady: I'll pass that on when masak is around.

[21:30] <jnthn> rakudo: say $*PID

[21:30] <p6eval> rakudo 1d4928: OUTPUT«Contextual $*PID not found␤␤»

[21:30] <jnthn> ng: say $*PID

[21:30] <p6eval> ng 54ca0f: OUTPUT«␤»

[21:33] *** xomas_ left
[21:34] *** payload joined
[21:37] <dalek> rakudo/ng: df1e34e | (Martin Berends)++ | src/core/system.pm:

[21:37] <dalek> rakudo/ng: [core/system.pm] add a sleep() function that does and returns fractional seconds

[21:37] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/df1e34e4218e02a80787134d472a85b7417ea8c0

[21:38] *** uniejo left
[21:41] <jnthn> cognominal: about?

[21:41] <jnthn> cognominal: oops, sorry

[21:41] <jnthn> colomon: about?

[21:41] <colomon> yes

[21:42] <jnthn> I just tweaked FAIL to create a Failure with an unthrown exception.

[21:42] <colomon> still rocking my son.  :)

[21:42] <jnthn> :-)

[21:42] <jnthn> It breaks a couple of tests, though I think legitimately...

[21:42] <jnthn> One is range.t though

[21:42] <jnthn> "Use of type object as a value"

[21:42] <jnthn> In test 78

[21:43] <colomon> which range.t?

[21:43] <jnthn> The others are all in IO, where it tries to use $*PID

[21:43] <jnthn> S03-operators/range.t

[21:43] <jnthn> AFAICT, looking up a contextual var that isn't defined and testing it for definedness is OK.

[21:44] <jnthn> But trying to use one that doesn't exist is meant to be an error.

[21:44] <jnthn> As in, it throws.

[21:44] <jnthn> Guess we were getting away with that before now though.

[21:44] <colomon>  .first works on ranges is the test?

[21:45] <pmichaud> contextual vars that haven't been set return a Failure, iirc

[21:45] <pmichaud> normally the Failure should be "Use of undefined contextual $*FOO..."

[21:45] <jonasbn> pmichaud: ping

[21:45] <pmichaud> jonasbn: pong

[21:45] <jnthn> pmichaud: Right, if you then try to use it though, that failure throws, yes?

[21:45] <jnthn> pmichaud: So 

[21:45] <jnthn> if $*FOO.defined { ... } # totally fine, no exception

[21:46] <jnthn> say $*FOO; # oh noes

[21:46] * colomon is very confused

[21:46] <jonasbn> pmichaud: you will be in Copenhagen from Saturday to Wednesday?

[21:46] <jnthn> colomon: I think the test that I've made explode was todo's actually.

[21:47] <jnthn> colomon: Yes, it is the .first one

[21:47] <colomon> I don't see any contextual variables?

[21:47] <jnthn> #?rakudo todo '.first suffers from the bug where code blocks get the wrong $_'

[21:47] <jnthn> colomon: Ah, sorry for the confusion.

[21:47] <jnthn> colomon: It gives a failure object here due to use of proto-object as a value.

[21:47] <jnthn> colomon: Which now throws.

[21:47] <colomon> oh!

[21:47] <jnthn> Sorry!

[21:47] <colomon> I see

[21:47] <jnthn> :-)

[21:48] <colomon> either skip it or change $_ to $^a

[21:49] <colomon> that's a good change, really (the fail, I mean) it makes these problems stand out

[21:49] <jnthn> colomon: I skipped it, and the rest of the test file is fine.

[21:50] <jnthn> colomon: $*PID I can't even implement as it seems Parrot doesn't provide a way to give us it!

[21:50] <pmichaud> jonasbn: I'm arriving Copenhagen on Thursday, flight departs Copenhagen early Wednesday

[21:50] <pmichaud> jonasbn: it's not too late for me to change that schedule, if desired :)

[21:50] <jonasbn> okay

[21:50] <jonasbn> no no please don't

[21:50] <jonasbn> I just need to book hotel

[21:50] <pmichaud> I decided that my trying to make it to Dutch Perl Workshop was going to make the trip too long for me

[21:51] <colomon> jnthn: how was master doing PID?

[21:51] <jonasbn> out of the 5 people coming, you are the only one coming Thursday, so you might have to spend time with me :)

[21:51] <pmichaud> jnthn: ($*FOO failure)  yes

[21:51] <jonasbn> pmichaud: how old are your kid(s)?

[21:51] <pmichaud> jonasbn: well, normally the first day I like to catch up on sleep :)

[21:51] *** SmokeMachine left
[21:52] <pmichaud> but yes, I'll have some time on Thur and/or Fry

[21:52] <pmichaud> *Fri

[21:52] <pmichaud> kids are 12 and 8

[21:52] <jonasbn> okay, mine are almost 3 and just 5, so you can cope

[21:52] <jnthn> colomon: $*PID just gave undef in master and we got away wiht it!

[21:52] <jnthn> colomon: Or something.

[21:52] <jnthn> :-)

[21:53] <pmichaud> anyway, I figured that if I arrived on Thur, I'd be around for the first day of the OSD conference, in case we want to have any presentations then

[21:53] <jnthn> colomon: I'm going to Cheat Horribly and just set it to 0.

[21:53] <colomon> jnthn++

[21:53] *** eternaleye joined
[21:54] <jonasbn> I will be at the conference too, I am not sure about the Perl track I think we will save it for Saturday, but lets see, now we have the option at least

[21:54] <pmichaud> jonasbn: okay.

[21:55] <pmichaud> jonasbn: I'm sure I'd also benefit from just being able to hack on my own for a day as well :)

[21:55] <pmichaud> jonasbn: or get in some more sightseeing of copenhagen :)

[21:55] <jnthn> Copenhagen is a nice city to sightsee in. :-)

[21:55] <jonasbn> pmichaud: we can arrange that too, either hotel or I can set you up at my $job

[21:56] <jonasbn> it is really cold here now

[21:56] <jnthn> jonasbn: How cold is "really cold"?

[21:57] <pmichaud> hotel or $job works for me :)

[21:57] <jonasbn> jnthn: -3 degrees celcius

[21:57] <jnthn> colomon: That seems to get things passing again. :-)

[21:57] <jnthn> jonasbn: Ah, same-ish as here. :-)

[21:58] <jonasbn> well for walking around all day, it is a bit cold, especially if you come in your hawaii shirt, sandals and bermuda shorts

[21:58] <jnthn> jonasbn: I took one poor visitor sightseeing in Trencin last month, when it was -10C!

[21:58] <jnthn> colomon: Gah, spoke too soon...

[21:58] <colomon> ditto (25F), and this isn't really cold by our standards...

[21:58] <pmichaud> -3 celcius isn't that cold :)

[21:58] <pmichaud> it was -3 celsius here this morning :)

[21:59] <jnthn> colomon: oh gah, another one uses $*OS!

[21:59] <pmichaud> hmmmm,  if I left on Tuesday, I could flight to AMS and perhaps make it to Dutch Perl Workshop

[21:59] <pmichaud> (cheaper flights, too :)

[21:59] <colomon> jnthn++ # suffering the pain of doing the right thing

[22:00] <dalek> rakudo/ng: c36e0f4 | (Martin Berends)++ | t/spectest.data:

[22:00] <dalek> rakudo/ng: [t/spectest.data] add S29-context/sleep.t (passes all 4 tests)

[22:00] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/c36e0f4821ca08193ab9e43e85c39cebdee10ec9

[22:01] <jonasbn> pmichaud: all of the others are not coming until Saturday

[22:01] <Kvorg> silly question ... what is the accepted way to iterate the stdio, i.e. while (<>) from perl5?

[22:01] <jnthn> colomon: Gonna put $*OS and $*OSVER back "properly"

[22:01] <pmichaud> jonasbn: right.  So, would it be good to make sure I'm there as of Saturday morning (in case others are late or late-ish), or should I try to arrive the same time as others?

[22:02] <mberends> ng: say sleep(0.7)

[22:02] <p6eval> ng df1e34: OUTPUT«0.724602937698364␤»

[22:02] <jnthn> pmichaud: I suspect mberends++ and I will be there very early. :-)

[22:02] <jnthn> mberends: yay, sleep!

[22:02] <pmichaud> jnthn: okay, that would be good then.  I don't know how awake we'll all need to be for conference/hackathon on saturday, though :)

[22:02] <jonasbn> pmichaud: what ever is easiest for you, if you want to come here Thursday, it is fine with me, I just need to book hotels

[22:03] <jnthn> pmichaud: I won't be hugely awake that day, I suspect.

[22:03] <jnthn> pmichaud: Well, it all hangs off how good the coffee is I guess. :-)

[22:03] <pmichaud> jonasbn: well, I plan to book the ticket in the next 8 hrs, so I can definitively let you know then

[22:04] <pmichaud> (my reservation expires 7 hours and 55 minutes from now :)

[22:04] <jonasbn> okay, then I will book hotels tomorrow

[22:04] <pmichaud> jnthn/mberends:  any opinion on whether I should try to make it to nlpw?

[22:05] <pmichaud> (and I need to check with my wife also)

[22:05] <mberends> pmichaud: we can arrive earlier to make a mini-Hackathon is necessary. The schedule for the entire week is open :)

[22:05] <mberends> *if

[22:06] <pmichaud> how/when to get from AMS to nlpw?

[22:06] <pmichaud> i.e., if I flew to AMS, how would I make it to nlpw?

[22:06] <mberends> we'll have a big spacious enough hired car

[22:06] <jnthn> Yeah

[22:06] <mberends> so we pick you up

[22:06] <pmichaud> what day should I arrive AMS?  Wed or Thu?

[22:07] <pmichaud> (iirc, nlpw is Fri)

[22:07] <mberends> (gotta crush jnthn's @stuff a little, but np ;)

[22:07] <jnthn> Yes, it's Fri

[22:07] <PerlJam> Kvorg: for lines() { ... }

[22:07] <jnthn> oh noes my stuffs!

[22:07] <pmichaud> oh, I don't have a lot of stuff.  Everything I'll be bringing fits under the airline seat :)

[22:07] <Kvorg> PerlJam: Thanx!

[22:07] <PerlJam> Kvorg: though, I don't think that actually works at the moment

[22:08] <jnthn> pmichaud: The only thing to consider is that we'll be doing an overnighter from nlpw to Copenhagen.

[22:08] <jnthn> pmichaud: And I dunno how that plays out with jetlagged you. :-)

[22:08] <pmichaud> jnthn: that's not too big a concern for me I don't think.

[22:09] <jnthn> OK. :-)

[22:09] <pmichaud> (as long as I'm not driving, that is :)

[22:09] <Kvorg> hehe, no it does not: Symbol '$line' not predeclared in <anonymous> (test.pl:2) in Main (file <unknown>, line <unknown>)

[22:09] <jnthn> It woudln't be for me either, but I know some people who get pretty beaten up with jetlag. :-)

[22:09] <pmichaud> yes, that's why I normally like to arrive a day early to catch up on sleep :-)

[22:09] <Kvorg> i always thought that should be the first think i test when i build a new rakudo, but either it never works, or i never know the correct syntax of the moment.

[22:09] <Kvorg> kinda the most basic think to expect from a perl at any day ...

[22:10] <jnthn> $*IN.lines does (should) work

[22:11] <mberends> the NLPW time itself will probably be one track of talks each under 20 mins, similar to http://www.perlworkshop.nl/nlpw2009/talks

[22:11] <PerlJam> Kvorg: note that I said lines(), not $line

[22:11] <pmichaud> mberends: are you and jnthn already traveling from ams to nlpw?  or is that a special trip?  or otherwise "on the way"?

[22:12] <mberends> it's about a 1 hour deviation, very easy to splice in

[22:12] <pmichaud> when should I be in AMS for the splice?

[22:12] <jnthn> In Texas terms, it's just around the corner.

[22:12] <jnthn> ;-)

[22:13] <pmichaud> ("one hour" == "across town" in Texas terms :)

[22:13] <ash___> ng: say $*IN.lines.defined; 

[22:13] <p6eval> ng df1e34: OUTPUT«1␤»

[22:13] *** barney left
[22:13] <pmichaud> or, put another way, when were you and jnthn planning to head to nlpw?

[22:13] <jnthn> ng: for $*IN.lines { .say }

[22:13] <ash___> can you set $*IN to something else? like a file? 

[22:13] <p6eval> ng df1e34: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmitten,␤einem

[22:13] <p6eval> ..stark…

[22:13] <jnthn> ash___: sure

[22:13] <mberends> we had planned to travel Wednesday night to arrive in NL Thursday morning, but it's flexible (speaking on behalf of jnthn++)

[22:14] <ash___> cool, just didn't know if that functionality worked yet

[22:14] <jnthn> mberends, pmichaud: I'm flexible.

[22:14] <pmichaud> that might work

[22:14] <jnthn> ash___: We're not running the test yet I don't think...

[22:14] <PerlJam> ash___: $*IN is just a scalar that happens to already have a nice value.  You're free to change that value 

[22:15] <jnthn> Well, that test file output is hilarious

[22:15] <Kvorg> my bad, actually it does work, but it seems to wati for the end of file: for $*IN.lines {   say "Read the line: $_"; }

[22:15] <pmichaud> looks like I could arrive AMS at 15h55

[22:15] <Kvorg> (should I go for nopaste for little bits like that?)

[22:15] <jnthn> Kvorg: In master, yes?

[22:15] <PerlJam> Kvorg: aye, that's a laziness issue that's being worked upon.

[22:15] <pmichaud> (Wednesday, 15h55)    would that be early enough?

[22:15] <jnthn> Oh wait, for isn't lazy yet in ng either...

[22:16] <jnthn> pmichaud: That could possibly be workable if mberends++ is ammeanable to us setting off at $EARLY-HOUR on Wednesday from here.

[22:16] <Kvorg> and so does for $*IN.lines { .say }, with the same caveat

[22:16] <mberends> pmichaud, jnthn: cool, we can do that

[22:16] <pmichaud> jnthn: I'd be okay with hanging around AMS for a bit as well, if you're arriving later

[22:17] <pmichaud> also it'd be good to not plan that my flight will be on-time :)

[22:18] <Kvorg> what would one have to do to get non-buffered read from a terminal? is it possible with such a construct? (perhaps a pointless question)

[22:18] <pmichaud> so, if you two are arriving later in ams, that'd be no big deal.  I might even temporarily rent a place to sleep until you arrive :)

[22:18] *** Su-Shee left
[22:18] <mberends> pmichaud: on Wednesday there's no pressure on anyone to be on time :)

[22:19] <mberends> AMS has free WiFi in some corners

[22:19] <pmichaud> okay.  I'll mull it over, discuss it with wife, and book flights tonight and let everyone know what's up tomorrow :)

[22:19] <jnthn> OK. :-)

[22:20] <jnthn> colomon: Pushed the bunch.

[22:20] <colomon> jnthn: commit test changes as well, or did I miss that earlier?

[22:22] <jnthn> d'oh!!

[22:22] <jnthn> colomon: done, thanks.

[22:22] <dalek> rakudo/ng: 3a94b96 | jonathan++ | src/cheats/setup-io.pm:

[22:22] <dalek> rakudo/ng: Implement $*OS, $*OSVER and a hugely cheating and lying $*PID.

[22:22] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/3a94b963ea45e66343756d7b2fee13031cfaae34

[22:22] <dalek> rakudo/ng: fe967ce | jonathan++ | t/spectest.data:

[22:22] <dalek> rakudo/ng: We now pass S02-names_and_variables/contextual.t again.

[22:22] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/fe967ce8070daf3931ddc569d08e6e4e916afccd

[22:22] <dalek> rakudo/ng: 446afaf | jonathan++ | src/cheats/fail.pir:

[22:23] <dalek> rakudo/ng: Cheat less with failures. They actually throw now.

[22:23] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/446afaf1c8e5d681c902e3e76a231a0a5e039791

[22:23] <pugs_svn> r29679 | jnthn++ | [t/spec] Turn a todo into a skip - we fail harder now. 

[22:25] *** Su-Shee joined
[22:27] <colomon> ooo, so close to running 3600 tests on my system...

[22:28] <colomon> on the other hand, abs.t fails now.

[22:29] *** jonasbn left
[22:29] <jnthn> colomon: Oh?

[22:29] <jnthn> colomon: I get 8 passing TODOs here. :-/

[22:30] <mberends> be there dragons if I attempt to bring back %*ENV ?

[22:30] <pugs_svn> r29680 | colomon++ | [t/spec] Change to-do to skip because of harder fails. 

[22:30] <jnthn> mberends: RAAR

[22:30] <jnthn> mberends: Hash changed some

[22:30] <jnthn> mberends: But probably not too many dragos.

[22:31] <colomon> jnthn: huh, but it was definitely failing here.

[22:31] <colomon> I'm going to look at the to-dos.

[22:31] <jnthn> colomon: If it's numbery stuff, it could be platform specific annoyances.

[22:32] <jnthn> colomon: fwiw, I sign.t tends to fail here too.

[22:32] <colomon> hmmm...

[22:32] <Su-Shee> moritz_: the bertrand meyer book is extremely cool. 

[22:33] <colomon> ng: say 0.WHAT; say 0.abs.WHAT

[22:33] <p6eval> ng c36e0f: OUTPUT«Int()␤Num()␤»

[22:34] <jnthn> Gah. For the last two hours I've done this: loop { boil_kettle(); hack(); realize_its_no_longer_warm(); }

[22:36] <Tene> hehehe

[22:37] <pugs_svn> r29681 | jnthn++ | [t/spec] Remove bogus returns that's nothing to do with the test anyway. 

[22:37] <jnthn> yay

[22:37] <jnthn> $tea.slurp()

[22:38] <mberends> jnthn: snap!

[22:39] <PerlJam> ng: "Nice Day Isn't It?".lc.comb.sort.join.say

[22:39] <p6eval> ng c36e0f: OUTPUT«Method 'sort' not found for invocant of class 'GatherIterator'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:39] <PerlJam> Hrm.

[22:39] <jnthn> I wishes we had sort.

[22:39] <jnthn> We're missing some tests for not doing so.

[22:40] <PerlJam> rakudo: "Nice Day Isn't It?".lc.comb.sort.join.say

[22:40] <p6eval> rakudo 1d4928: OUTPUT«   '?acdeiiinnstty␤»

[22:41] *** cotto_working left
[22:41] <PerlJam> rakudo: "Nice Day Isn't It?".lc.comb.uniq.sort.join.say

[22:41] <p6eval> rakudo 1d4928: OUTPUT« '?acdeinsty␤»

[22:41] <jnthn> Oh.

[22:41] <jnthn> :-/

[22:42] <PerlJam> I don't understand the error message "method not found on GatherIterator".  what's up with that?

[22:44] <pmichaud> looks to me like .comb is returning a GatherIterator

[22:44] <pmichaud> might need to be a List with a GatherIterator

[22:44] <pmichaud> (it's a question of whether you want to treat an Iterator as a scalar object or as something that acts like a list)

[22:45] *** Su-Shee left
[22:45] <PerlJam> ng: "foo".comb.sort

[22:45] <p6eval> ng c36e0f: OUTPUT«Method 'sort' not found for invocant of class 'GatherIterator'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:45] <PerlJam> ng: "foo".comb.uniq

[22:45] <p6eval> ng c36e0f: OUTPUT«Method 'uniq' not found for invocant of class 'GatherIterator'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:45] <PerlJam> ng: "foo".comb.join

[22:45] <p6eval> ng c36e0f:  ( no output )

[22:46] *** nacho left
[22:46] <PerlJam> 1 out of 3 ain't bad ;)

[22:46] <pmichaud> I suspect .join is doing a .list on its invocant first

[22:46] <pmichaud> anyway, most of that still needs cleaning up, I suspect.

[22:48] <jnthn> ng: my $aref = [0]; $aref[0]++;

[22:48] <p6eval> ng c36e0f: OUTPUT«sh: ./perl6: No such file or directory␤»

[22:48] *** k23z__ left
[22:48] <jnthn> pmichaud: Above gives Cannot assign to readonly value

[22:49] <jnthn> pmichaud: Is that something that'll get cleared up in the list/array re-doing you've got planned?

[22:49] <jnthn> s/list/list assignment/

[22:49] *** ash__ joined
[22:51] <dalek> rakudo/ng: 2561333 | jonathan++ | src/core/EnumMap.pm:

[22:51] <dalek> rakudo/ng: .Num and .Int on EnumMap, and thus Hash.

[22:51] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/25613337b934fd36934880a3050f2725706d3e77

[22:51] *** ash___ left
[22:54] *** kst joined
[22:57] <pmichaud> jnthn: yes.

[22:59] <colomon> oooo, Enums!

[22:59] <colomon> afk # orchestra

[23:00] <jnthn> pmichaud: yay.

[23:01] *** dual left
[23:04] <jnthn> pmichaud: Hashes have the same issue.

[23:04] *** hercynium joined
[23:04] <jnthn> If the fix that does it for arrays doesn't help there, I can at least spot it and apply the same trick for the hashes though :-)

[23:05] *** cotto_working joined
[23:07] <ash__> how do you make a capture? isn't it \? like my $a = \$foo; ?

[23:07] *** nihiliad left
[23:14] <jnthn> \(...) should do it

[23:14] <dalek> rakudo/ng: dacbea0 | jonathan++ |  (2 files):

[23:14] <dalek> rakudo/ng: Add back Signature.perl, with a couple of minor tweaks for it to work under ng.

[23:14] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/dacbea09333cb2d406c1a938809aa86fe8f3b3a8

[23:15] <ash__> ng: my $a = 5; my $b = \($a);

[23:15] <p6eval> ng fe967c: OUTPUT«Confused at line 1, near "my $b = \\("␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[23:15] <ash__> does := not work in ng? its also giving me an error

[23:16] <ash__> ng: my $a := 5;

[23:16] <p6eval> ng fe967c: OUTPUT«Confused at line 1, near "my $a := 5"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤»

[23:17] *** ashleyb left
[23:18] <jnthn> ash__: Not yet.

[23:18] *** ashleyb joined
[23:19] *** cognominal left
[23:24] <pmichaud> := nyi in ng

[23:24] <jnthn> := is only sorta i in master. :-)

[23:25] <pugs_svn> r29682 | jnthn++ | [t/spec] Skip two tests due to [0] constructing a read-only array in ng. 

[23:27] *** iblechbot left
[23:31] <pugs_svn> r29683 | jnthn++ | [t/spec] Turn a couple of todos into skips since ng hardfails 'em; they're all RT tracked, anyways. 

[23:31] *** pmurias left
[23:32] <dalek> rakudo/ng: 8a4c410 | jonathan++ | src/Perl6/Actions.pm:

[23:32] <dalek> rakudo/ng: Fix an ickle bug in named parameter handling.

[23:32] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/8a4c410880070012f539f56789e6a806a4b9120e

[23:32] <dalek> rakudo/ng: cf9f32f | jonathan++ | src/builtins/Proxy.pir:

[23:32] <dalek> rakudo/ng: my %oh; %oh<lol>.notdef should be true; make it so.

[23:32] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/cf9f32ff10bf4c57facd9ea1957914d86d9c9cb0

[23:32] <dalek> rakudo/ng: 5b5e6a6 | jonathan++ | t/spectest.data:

[23:32] <dalek> rakudo/ng: S06-signature/named-parameters.t passes again.

[23:32] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/5b5e6a643a110ab19b589c3ead38bc205e1de9b0

[23:34] <jnthn> std: whatever( 'a' p5=> 'b', 'c' p5=> 'd' );

[23:34] <p6eval> std 29681: OUTPUT«===SORRY!===␤Unable to parse argument list; couldn't find final ')' at /tmp/6IOXfE1t73 line 1:␤------> whatever( 'a' ⏏p5=> 'b', 'c' p5=> 'd' );␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤FAILED 00:01 108m␤»

[23:36] *** kidd` joined
[23:36] *** kidd` is now known as rgrau

[23:36] <pugs_svn> r29684 | jnthn++ | [t/spec] p5=> is dead. 

[23:43] *** ash__ left
[23:47] *** drbean joined
[23:49] <dalek> rakudo/ng: 2d8d82a | jonathan++ | t/spectest.data:

[23:49] <dalek> rakudo/ng: One more passing test.

[23:49] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/2d8d82a5f5e0be3313aba5f66b0d666425994749

[23:56] *** Limbic_Region joined
