[00:00] <colomon> ah, just activating the :radix[ ] form doesn't make it work.  problem is in token circumfix:sym<[ ]>, I think...

[00:02] * lue is trying to fix the fractions of radcalc

[00:04] <mberends> jnthn: suspected regex backtracking bug http://nopaste.snit.ch/20018

[00:05] <jnthn> mberends: Agree.

[00:05] * mberends , having found a workaround, goes to sleep

[00:06] *** mberends left
[00:06] <lue> hopefully I fixed it, compiling...

[00:07] <TimToady> std: .4

[00:07] <p6eval> std 30146: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[00:08] <lue> std: :16<.4>

[00:08] <p6eval> std 30146: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed radix number at /tmp/7vyfVF06ni line 1:‚ê§------> [32m:16[33m‚èè[31m<.4>[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[00:08] <colomon> I thought it had to be 0.4?

[00:08] <TimToady> metoo

[00:08] <lue> just checking :)

[00:08] <TimToady> probably parsed it as a method call  :/

[00:09] <lue> rakudo: say Int.4

[00:09] <p6eval> rakudo 1cf076: OUTPUT¬´Confused at line 11, near "say Int.4"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[00:09] <TimToady> no, it parsed it as a number

[00:10] <TimToady> std: 4.

[00:10] <p6eval> std 30146: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Decimal point must be followed by digit at /tmp/jU36jiBhBU line 1:‚ê§------> [32m4.[33m‚èè[31m<EOL>[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[00:10] <TimToady> that's what we disallow

[00:10] <lue> but python allows it! (oh...)

[00:12] <TimToady> so is 4.i (4.)i or (4).i ?

[00:13] <TimToady> p6 will always take it as a method call

[00:14] <sorear> is 1.618 a method call?

[00:15] <sorear> should it be?

[00:15] <TimToady> why would it be?

[00:15] <sorear> .

[00:15] <TimToady> don't be a fundamentalist

[00:15] <colomon> TimToady++ # p6l

[00:16] <snarkyboojum> enjoyable post from TimToady on the perl 6 mailing list

[00:16] <snarkyboojum> colomon: beat me to it :)

[00:16] <colomon> snarkyboojum: because I used fewer letters.  ;)

[00:16] <lue> The tension is unbearable (compiling)

[00:16] *** cls_bsd joined
[00:18] <jnthn> TimToady: Wow!

[00:19] <jnthn> TimToady: You...kinda said what I feel but thought I should keep to myself. :-)

[00:19] <TimToady> well, someone has to exercise a little moral authority around here occasionally, and I have about as little as anyone...

[00:19] <lue> >say :16<16D.4>

[00:19] <lue> 1.42578125

[00:20] <lue> .... something went horribly wrong :)

[00:20] <TimToady> :)

[00:20] <colomon> but you still got a fractional answer, lue++

[00:20] <colomon> it's progress.

[00:20] <TimToady> and it's even the right sign

[00:20] <lue> I know! I think I broke the first guy's code though :)

[00:21] <jnthn> It's OK, I temporarily broke parsing 1 + 2 earlier tonight

[00:21] <jnthn> :-)

[00:21] <colomon> And I keep on breaking !=

[00:21] <lue> I wrote it so that the computation of the fraction is separate, and then I divide it appropriately and add.

[00:22] <jnthn> > say (('be','pi') >>~<< ('er','vo')).perl

[00:22] <jnthn> ["beer", "pivo"]

[00:22] <TimToady> looks like you took it as 1.6D4

[00:23] <jnthn> > say (('be','pi') >>R~<< ('er','vo')).perl

[00:23] <jnthn> ["erbe", "vopi"]

[00:23] <lue> >say :16<16D>

[00:23] <TimToady> yes, almost exactly that

[00:23] <lue> 1

[00:23] <jnthn> .oO( mmm....vopi! )

[00:23] *** meppl left
[00:24] * jnthn make spectests and hopes he didn't cause collateral damage.

[00:24] <colomon> jnthn++

[00:24] <lue> gah! Without the fraction, it takes the lefmost digit of the number!

[00:24] <cognominal> in Perl5, is there a low precedence operator of function application like the $ in haskell?

[00:24] <TimToady> actually, 1.6D.4 is what it looks like :)

[00:24] <arnsholt> Is the official #parrot on Freenode?

[00:24] <jnthn> arnsholt: no, it's on magnet

[00:25] <arnsholt> Oh, well. What's one more ircnet? =)

[00:25] <lue> I'm going to kill the original code, seems like :D

[00:25] <lue> (emacs pun)

[00:26] <jnthn> lue: If the new code passes more tests, go ahead! :-)

[00:28] <lue> rakudo: Q:PIR{$S0="hello"‚ê§$S1=$S0[5]‚ê§say $S1}

[00:28] <p6eval> rakudo 1cf076: OUTPUT¬´The opcode 'set_s_s_kic' (set<3>) was not found. Check the type and number of the arguments‚ê§current instr.: 'perl6;PCT;HLLCompiler;evalpmc' pc 972 (compilers/pct/src/PCT/HLLCompiler.pir:538)‚ê§¬ª

[00:28] <cognominal> s/Perl5/Perl6/

[00:29] <lue> Ah! Did I do something wrong in testing a snippet of PIR?

[00:29] <lue> (belated) hi cognominal o/

[00:29] <colomon> cognominal: how does it work?

[00:31] <snarkyboojum> lue: I've been having fun with very similar errors lately :)

[00:31] <lue> rakudo: Q:PIR{$S0="hello"‚ê§$S1=substr $S0 3‚ê§say $S1}

[00:31] <p6eval> rakudo 1cf076: OUTPUT¬´The opcode 'substr_s_s' (substr<2>) was not found. Check the type and number of the arguments‚ê§current instr.: 'perl6;PCT;HLLCompiler;evalpmc' pc 972 (compilers/pct/src/PCT/HLLCompiler.pir:538)‚ê§¬ª

[00:31] <jnthn> lue: comma

[00:31] <lue> rakudo: Q:PIR{$S0="hello"‚ê§$S1=substr $S0, 3‚ê§say $S1}

[00:32] <p6eval> rakudo 1cf076: OUTPUT¬´lo‚ê§¬ª

[00:32] <lue> rakudo: Q:PIR{$S0="hello"‚ê§$S1=substr $S0, 3, 3‚ê§say $S1}

[00:32] <p6eval> rakudo 1cf076: OUTPUT¬´lo‚ê§¬ª

[00:32] <lue> rakudo: Q:PIR{$S0="hello"‚ê§$S1=substr $S0, 3, 1‚ê§say $S1}

[00:32] <p6eval> rakudo 1cf076: OUTPUT¬´l‚ê§¬ª

[00:32] <jnthn> \o/

[00:32] <lue> substr(STRING, BEGIN, LENGTH) then

[00:32] <jnthn> Right.

[00:35] <lue> Is it alright if I break your hard work on the :[number] adverbs and have you send just one number, instead of an intpart and fracpart?

[00:35] <lue> :)

[00:36] <jnthn> colomon: BTW, if we've got reduce...and hypers...and Z/X/R/S...does that mean we're now parsing all of the hyperops? :-)

[00:37] <colomon> I think so.  We don't actually do anything with S yet other than parse it.

[00:37] <colomon> do you have the non-infix hypers parsing?

[00:37] <lue> (Goodbye, old &radcalc code. It'd take too much to modify using one number.)

[00:38] <jnthn> colomon: oh, no...

[00:38] <jnthn> colomon: I think they may be easier though

[00:38] <jnthn> colomon: Ah well, gotta save something for tomorrow :-)

[00:38] <colomon> :)

[00:38] <jnthn> colomon: It occurs to me that those probably desugar to map?

[00:38] <jnthn> Well

[00:38] <jnthn> Maybe

[00:38] <jnthn> As a first cut :-)

[00:39] <colomon> well, if they're not hyper.

[00:39] <jnthn> I guess they ain't meant to be lazy.

[00:39] <colomon> but that's a good first cut.

[00:39] <jnthn> Well

[00:39] <jnthn> @a>>++

[00:39] <jnthn> Maybe not quite that simple

[00:39] <colomon> oooo, right.

[00:39] <jnthn> But maybe

[00:39] <jnthn> :-)

[00:40] <jnthn> A first cut can certainly be a thin wrapper around map, anyway.

[00:40] <lue> in PIR, a num is a floating-point, right?

[00:40] <jnthn> yees

[00:41] <jnthn> colomon: Oh, we have that infixy form of reductions to do too I guess.

[00:41] <colomon> errr... so how do I code infix_prefix_meta_operator:sym<!> in such a way that != is not one, but !== and !=== are?

[00:42] <colomon> oh, right, I'd already forgotten that one's existence.  :)

[00:42] <jnthn> erm

[00:42] <colomon> <!before '!=' something?

[00:43] <jnthn> <!before '!=' [-<=>]> maybe

[00:43] <jnthn> char class of anything that's not =

[00:43] <colomon> sounds plausible....

[00:43] <jnthn> rakudo: say '$a != $b' ~~ /'!=' [-<=>]/

[00:43] <p6eval> rakudo 1cf076: OUTPUT¬´Confused at line 11, near "say '$a !="‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[00:44] <lue> rakudo: Q:PIR{$N0=3‚ê§say $N0}

[00:44] <p6eval> rakudo 1cf076: OUTPUT¬´3‚ê§¬ª

[00:44] <jnthn> rakudo: say '$a != $b' ~~ /'!=' <-[=]>/

[00:44] <p6eval> rakudo 1cf076: OUTPUT¬´!= ‚ê§¬ª

[00:44] <jnthn> rakudo: say '$a !== $b' ~~ /'!=' <-[=]>/

[00:44] <p6eval> rakudo 1cf076: OUTPUT¬´‚ê§¬ª

[00:44] <jnthn> colomon: That one.

[00:44] <jnthn> <!before '!=' <-[=]>>

[00:44] <cognominal> colomon,   in a haskell     sin $ 1 + 5    is equivalent to   sin(1+5)

[00:45] <jnthn> cognominal: In Perl 6, sin 1 + 5 is also equivalent to sin(1+5) ;-)

[00:45] <jnthn> ...wait, isn't it in Perl 5 too? :-)

[00:45] <cognominal> it works on the left side too

[00:46] <colomon> regex assertion not terminated by angle bracket at line 1285, near "[-<=>]> <s"

[00:46] <jnthn> colomon: yes, I got it wrong

[00:46] <jnthn> See update 

[00:46] <jnthn> <!before '!=' <-[=]>>

[00:46] *** arthur-_ left
[00:46] <colomon> ah, I see.  :)

[00:46] <jnthn> Sorry

[00:46] <jnthn> :-)

[00:46] <jnthn> Not sure what I was thinking. Probably wasn't.

[00:46] <colomon> no worries.

[00:46] <cognominal> f + g $ 1 + 5    is  (f+g) (1+5)    # supposing we can add function

[00:47] <colomon> is that f composed with g, or the value of f + the value of g?

[00:48] <cognominal> well that means    f( 1+5) + g(1+5)  according to the addition of functions

[00:49] <jnthn> Oh, it distributes the args amonst the functions?

[00:49] <sorear> jnthn: Is there anything I need to know before killing return_value_helper?

[00:50] <jnthn> sorear: I...don't even recall what it does. :-)

[00:50] <colomon> I think the quick answer is you could pretty easily set up Perl 6 to do that, but it doesn't have an equivalent by default.

[00:50] <cognominal> no, that the definition of function addition

[00:50] <jnthn> sorear: Oh, yes, kill it.

[00:51] <jnthn> sorear: Before a Parrot Calling Conventions interface, it was a world of pain to not use a hack like that.

[00:51] <jnthn> sorear: Now it's not.

[00:51] <jnthn> er, interface => interface change

[00:51] <colomon> rakudo: multi sub infix:<+>(&a, &b) { &a(!@_) + &b(!@_) };

[00:51] <p6eval> rakudo 1cf076: OUTPUT¬´Placeholder variable cannot override existing signature at line 11, near ";"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[00:52] <cognominal> $ is just an operator that the low precedent application of a function to its argument

[00:52] <cognominal> *precedence

[00:52] <colomon> rakudo: multi sub infix:<+>(&a, &b) { sub { &a(!@_) + &b(!@_) }}

[00:52] <p6eval> rakudo 1cf076: OUTPUT¬´Can not put multi on anonymous routine at line 11, near "}"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[00:52] <jnthn> ouch!

[00:53] <colomon> std: multi sub infix:<+>(&a, &b) { sub { &a(!@_) + &b(!@_) }}

[00:53] <p6eval> std 30146: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[00:54] <jnthn> I guess the $*MULTINESS or something is leaking too far

[00:54] <colomon> I'm sure jnthn++ can come up with something better anyway...  ;)

[00:54] <colomon> Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 70

[00:54] <colomon> ok(  ?(   (1 & 2 | 3) !=3), '& binds tighter than |');

[00:54] <colomon> is the line in question.

[00:55] <sorear> jnthn: Can you breifly explain what life was like before PCC, and how Blizkost worked *at all* then?

[00:56] <jnthn> probably sub infix:<+>(&a, &b) { sub (|$c) { &a(|$c) + &b(|$c) } } or some such

[00:56] <jnthn> sorear: There was PCC

[00:56] *** justatheory left
[00:56] <jnthn> sorear: There just wasn't a neat interface to it

[00:56] <sorear> I... don't really understand PCC

[00:56] <jnthn> sorear: So it was messing around with structures rather than just some vtable calls.

[00:56] <sorear> just a couple magic black boxes :(

[00:56] <jnthn> Well, you *can* treat it as a magic box now, for the most part. Which is a relief. :-)

[00:57] <jnthn> Essentially it's the thing that deals with moving args from caller to callee, and returns in the other direction.

[00:57] <jnthn> And those things being passed living in a CallContext data structure (I think that's what it's called now...)

[00:58] <jnthn> s/data structure/PMC/

[00:59] *** clintongormley left
[01:00] *** justatheory joined
[01:02] <dalek> rakudo: 5edcafa | jonathan++ | src/ (3 files):

[01:02] <dalek> rakudo: Get parsing of hyperops, including transparency of precedence, implemented. Stub in the various &hyper multis. Implement the very simplest case.

[01:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5edcafaaabbe47975959a37ca007a83f6a0b6f8b

[01:05] <snarkyboojum> rakudo: say <1 2 3>.exists(1)

[01:05] <p6eval> rakudo 1cf076: OUTPUT¬´Method 'exists' not found for invocant of class 'Parcel'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[01:06] <lue> rakudo: Q:PIR{$S0=substr "Oh", 2, 1‚ê§say $S0}

[01:06] <p6eval> rakudo 1cf076: OUTPUT¬´‚ê§¬ª

[01:06] <snarkyboojum> rakudo: my @a = <1 2 3>; say @a.exists(1)

[01:06] <p6eval> rakudo 1cf076: OUTPUT¬´Method 'exists' not found for invocant of class 'Array'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[01:06] <lue> rakudo: Q:PIR{$S0=substr "Oh", 2, 1‚ê§say $S0=undef}

[01:06] <p6eval> rakudo 1cf076: OUTPUT¬´error:imcc:syntax error, unexpected '=', expecting '\n' ('=')‚ê§     in file 'EVAL_1' line 65‚ê§‚ê§¬ª

[01:06] <lue> rakudo: Q:PIR{$S0=substr "Oh", 2, 1‚ê§say $S0==undef}

[01:06] <p6eval> rakudo 1cf076: OUTPUT¬´error:imcc:syntax error, unexpected RELOP_EQ, expecting '\n' ('==')‚ê§       in file 'EVAL_1' line 65‚ê§‚ê§¬ª

[01:06] <jnthn> pote≈°it

[01:06] <jnthn> oops, wrong window

[01:07] <lue> rakudo: Q:PIR{$S0=substr "Oh", 2, 1‚ê§if $S0==undef goto fail‚ê§say "yay"‚ê§fail:‚ê§say"boo undef"}

[01:07] <p6eval> rakudo 1cf076: OUTPUT¬´error:imcc:syntax error, unexpected IDENTIFIER ('undef')‚ê§  in file 'EVAL_1' line 65‚ê§yay‚ê§boo undef‚ê§¬ª

[01:07] <lue> rakudo: Q:PIR{$S0=substr "Oh", 2, 1‚ê§if $S0=="" goto fail‚ê§say "yay"‚ê§fail:‚ê§say"boo undef"}

[01:07] <p6eval> rakudo 1cf076: OUTPUT¬´boo undef‚ê§¬ª

[01:08] <lue> Now I can avoid keeping track of the length of the string! \o/

[01:10] *** astrojp left
[01:11] <TimToady> there are no infixy reductions

[01:12] <jnthn> TimToady: Whatcha call the 1, [+] 2,3,4 thingummy?

[01:13] <jnthn> er

[01:13] *** snarkyboojum left
[01:13] <jnthn> 1 [+] 2,3,4 

[01:13] <jnthn> ?

[01:13] <TimToady> exactly the same as (1 + 2), 3, 4

[01:13] <jnthn> Oh.

[01:13] <jnthn> So it's got nothing to do with reduction ops?

[01:13] <TimToady> and 1 [[[[[+]]]]] 2,3,4

[01:13] <jnthn> ...phew. :-)

[01:14] <TimToady> only an infix in prefix position is a reduction

[01:14] <jnthn> Aye

[01:14] <TimToady> and you have to use [] there to disambiguate

[01:14] <jnthn> OK, good.

[01:14] <jnthn> Something I'd read earlier today had led me to think otherwise.

[01:14] <lue> why does 1 [+] 2,3,4 not equal 1 + 2 + 3 + 4 ?

[01:14] <jnthn> OK, excellent, so we parse all the hyper ops. :-)

[01:14] <jnthn> erm

[01:14] <jnthn> meta-ops

[01:14] <jnthn> :-)

[01:14] <TimToady> because it doesn't

[01:14] <jnthn> Apart from the few hypers. :-)

[01:14] *** silug joined
[01:15] <jnthn> (unary ones)

[01:15] <colomon> To be precise there was misinformation on #perl6 about 1 [+] 2, 3, 4;   :)

[01:15] <jnthn> colomon: Heh, it wasn't just my brain being mushy then. :-)

[01:15] <colomon> but can hardly cast blame, as I fear I probably say something wrong on the channel at least once a day.  ;)

[01:15] <TimToady> S03:4611

[01:16] *** meppl joined
[01:16] *** snarkyboojum joined
[01:17] <TimToady> and S03:4196 (emphasis on "in term position")

[01:17] <TimToady> any other place, [] is only for disambiguation

[01:18] <jnthn> Heh

[01:18] <jnthn> It'll be good for obfuscations.

[01:18] <jnthn> :-)

[01:18] <TimToady> @a Z[+=] @b   vs   @a [Z+]= @b

[01:19] <jnthn> Oh.

[01:19] <TimToady> or de-obfuscations

[01:19] <TimToady> mind you, those might end up doing the same thing

[01:19] <TimToady> just differently :)

[01:20] <TimToady> but then there * * *  which can be written * [*] *

[01:21] <TimToady> in STD, != is distinguished from the other forms by being longer than !

[01:21] <TimToady> so it's simply LTM

[01:22] <colomon> if that only worked for me.... :(

[01:22] <TimToady> eventually all the contortions you guys are going through to avoid LTM is going to add up to more than implementing real LTM :)

[01:23] <m6locks> how does blessing work with a class that has another class as an attribute? i'm trying to write a constructor for it but return self.bless(self.CREATE(), :attributeClass) complains about type objects being abstract

[01:24] <jnthn> std: pi**time

[01:24] <p6eval> std 30146: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[01:24] <lue> is :16<3.DEAD_BEEF> legal ? (the underscore in the fractional part)

[01:24] <jnthn> ...Perl 6 supports censorship of some bad things, at least. :-)

[01:25] <TimToady> lue: yes

[01:25] <colomon> lue: yes

[01:25] <jnthn> m6locks: That doesn't look immediately wrong

[01:25] <TimToady>             $<fracpart> = [ '.' <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]?

[01:25] <jnthn> m6locks: What do you mean as "another class as an attribute"?

[01:25] <jnthn> m6locks: There is a bug in master in that area though.

[01:25] <jnthn> namely...

[01:26] <jnthn> rakudo: class Foo { has Str $.a }; say Foo.new.a.WHAT # should be Str()

[01:26] <p6eval> rakudo 5edcaf: OUTPUT¬´Any()‚ê§¬ª

[01:26] <jnthn> You may be hitting that one.

[01:26] <jnthn> I'll try and fix it soon.

[01:26] <m6locks> oh, could be

[01:26] <m6locks> yes, that was my point

[01:27] <TimToady> if you folx are abandoning the intpart/fracpart, it would be easier to parse radix fractions like dec_number does

[01:27] <TimToady> and just pass the whole coeff

[01:28] <TimToady> and then we can allow :16<.D> without requiring the 0

[01:29] *** nihiliad left
[01:29] <lue> Just one string is what I'm programming, with detection of the "." switching over to fractions.

[01:32] *** nihiliad joined
[01:34] <colomon> jnthn: we can say infixish(1) in Grammar.pm?

[01:35] <TimToady> which presumably tells the infix it's in a meta

[01:36] <TimToady> okay, testing STD patch that just passes the coeff with a . in the middle

[01:37] <jnthn> colomon: Not at the moemnt

[01:37] <jnthn> colomon: I'm not sure what that's needed for.

[01:37] <jnthn> TimToady: Yes. Is it "just" for error reporting?

[01:37] <colomon> see what TimToady just said.  But you used it, yes?

[01:37] <jnthn> I couldnt' see anywhere it affects teh parse.

[01:37] <jnthn> No

[01:37] <jnthn> I just called <infixish>

[01:37] <colomon>  {} <infixish(1)>

[01:38] <jnthn> Oh?

[01:38] <colomon> in token infix_circumfix_meta_operator:sym<¬´ ¬ª>

[01:38] <jnthn> oh, damm

[01:38] <jnthn> copy-pasto

[01:38] <jnthn> (from STD)

[01:38] <jnthn> It probably doesn't work.

[01:38] <jnthn> I only checked the non-unicode ones. :-)

[01:38] <jnthn> colomon: You can copy the stuff from STD probably though to get $*IN_META and add the parameter to infixish

[01:38] <jnthn> We support those.

[01:39] <colomon> I'll keep that in mind.  Today I'm just trying to puzzle out how to copy your precedence copying trick.  :)

[01:39] *** TiMBuS left
[01:39] <TimToady> it's mostly just for suppressing warnings on [..] and such, which might be mistaken for an attempt to leave out the endpoints of a range

[01:40] <TimToady> since the mathematicians seem inclined to write [1..]

[01:40] <jnthn> Ah, OK. :-)

[01:40] <jnthn> colomon: Just duplicating <O=.Ocopy('infixish')> should do it

[01:41] <colomon> yes, I thought so.  :)

[01:41] <colomon> except I need to reorder a bit to make it work.

[01:41] <colomon> :)

[01:41] <TimToady> it also suppresses Unexpected block in infix position

[01:41] <jnthn> TimToady: OK, thanks. :-)

[01:41] <jnthn> We can add it later on, then.

[01:42] <TimToady> though I don't know that we currently have any operators beginning with { or ->, but a user might add them

[01:42] <TimToady> STD is extensible, y'see...

[01:43] <TimToady> rakudo: 42 -> { ... }

[01:43] <p6eval> rakudo 5edcaf: OUTPUT¬´Confused at line 11, near "42 -> { .."‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[01:43] <TimToady> std: 42 -> { ... }

[01:43] <p6eval> std 30146: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/fVGRNQesOl line 1:‚ê§------> [32m42 [33m‚èè[31m-> { ... }[0m‚ê§    expecting any of:‚ê§   bracketed infix‚ê§  infix or meta-infix‚ê§FAILED 00:01 109m‚ê§¬ª

[01:44] <lue> PIR ifs need ==, not =, right?

[01:44] <jnthn> rihgt.

[01:45] <lue> sigh... now to go back :)

[01:45] <TimToady> std: sub infix:<-\>> {...}; 42 [->] 43

[01:45] <jnthn> We still need to steal all the two terms in a row good errors.

[01:45] <p6eval> std 30146: OUTPUT¬´ok 00:01 108m‚ê§¬ª

[01:45] <jnthn> rakudo: sub infix:<-\>> {...}; 42 -> 43

[01:45] <p6eval> rakudo 5edcaf: OUTPUT¬´Confused at line 11, near "42 -> 43"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[01:46] <jnthn> aw

[01:46] <jnthn> We don't do the bracketed form yet

[01:46] <lue> now I'm compiling (fingers crossed XoX)

[01:46] <jnthn> It's just Xo now

[01:46] <jnthn> ;-)

[01:46] <TimToady> don't recognize that operator

[01:46] <TimToady> actually, I finally removed that deprecation from STD

[01:47] <TimToady> std: 1 X+X 2

[01:47] <p6eval> std 30146: OUTPUT¬´Undeclared name:‚ê§      'X' used at line 1‚ê§ok 00:01 106m‚ê§¬ª

[01:48] <lue> It was my best attempt at a fingers crossed person (you can do better perhaps?)

[01:49] * colomon is really amused by Julie / Julia.

[01:51] <TimToady> ‚Çì‚òπ‚Çì

[01:51] <lue> That was a great movie!

[01:51] <lue> colomon++

[01:52] * jnthn didn't see that one

[01:52] * lue draws a big breath as he types ¬´./perl6 -e "say :16<16D.4>"¬ª into the terminal (minus the french quotes of course)

[01:52] <lue> oh yeah, I broke the adverbs :D

[01:54] <lue> >say radcalc(16,'16D.4')

[01:55] <lue> unrecognized/invalid character: .

[01:55] <lue> current instr.: '&radcalc' pc 11961 (src/builtins/Parcel.pir:78)

[01:55] <lue> called from Sub '_block14' pc 29 (EVAL_1:0)

[01:55] <lue> called from Sub '!UNIT_START' pc 1299 (src/glue/run.pir:23)

[01:55] <lue> called from Sub 'perl6;PCT;HLLCompiler;eval' pc -1 ((unknown file):-1)

[01:55] <lue> called from Sub 'perl6;PCT;HLLCompiler;command_line' pc 1489 (compilers/pct/src/PCT/HLLCompiler.pir:794)

[01:55] <lue> called from Sub 'perl6;Perl6;Compiler;main' pc -1 ((unknown file):-1)

[01:56] *** vamped joined
[01:56] <colomon> lue: Having just watched a bit of real Julia Child footage, I'm stunned at how well Meryl Streep has her down.

[01:57] <lue> colomon: Look up. What could be causing that? (the string var is named 'number')

[01:57] *** justatheory left
[01:57] <colomon> hmmmm

[01:58] *** Sarten-X left
[01:58] <lue> should I paste my &radcalc code so far?

[01:59] <colomon> yeah.

[01:59] <colomon> isn't that message coming from radcalc

[02:00] <lue> oh, that's an error sent by &radcalc itself :P

[02:00] <lue> (I should put DON'T PANIC in front of it...)

[02:00] <colomon> :)

[02:00] *** snarkyboojum left
[02:00] <m6locks> rakudo: my $a, $b = 1;

[02:00] <p6eval> rakudo 5edcaf: OUTPUT¬´Symbol '$b' not predeclared in <anonymous>‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[02:01] <lue> I know! I forget to increment my loop variable before jumping to fractions! (when you see the code, you'll know what I mean)

[02:01] <lue> and so it comes across the . twice!

[02:01] <TimToady> std: /\ /

[02:01] <p6eval> std 30146: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§No unspace allowed in regex (for literal # please quote with single quotes, '#') at /tmp/wQe2LopX01 line 1:‚ê§------> [32m/\[33m‚èè[31m /[0m‚ê§FAILED 00:01 107m‚ê§¬ª

[02:01] <TimToady> still slightly LTA...

[02:02] <lue>  /\/ever give up, TimToady! :)

[02:02] * colomon has completely broken parsing of the Rop, etc.

[02:02] <TimToady> told you it looked kinda like 1.6D.4  :)

[02:03] <colomon> oh, maybe it's the action that is broken, not the parsing.

[02:04] <lue> compiling ‚Çì‚òπ‚Çì

[02:04] *** snarkyboojum joined
[02:05] <lue> I just completely rewrote it TimToady (and IMO it's more efficient (less labels) and readable (comments!))

[02:05] <Juerd> moritz_: /dev/pts is mounted so I don't know what could be wrong.

[02:05] <Juerd> moritz_: Maybe someone (you?) fixed it?

[02:06] <jnthn> Juerd: I think moritz_++ found a way to fix it.

[02:06] *** M_o_C left
[02:06] <Juerd> \o/

[02:06] <colomon> lue: but does it pass the tests?  ;)

[02:07] <jnthn> sleep()

[02:07] <jnthn> night o/

[02:07] <colomon> night!

[02:07] <TimToady> o/

[02:07] <lue> night-i-o o/

[02:08] <lue> colomon: first it has to work :D

[02:08] <lue> done compiling! and now...

[02:08] *** Sarten-X joined
[02:09] <lue> >say radcalc(16,'16D.4')

[02:09] <lue> 369

[02:09] <lue> the fraction is just added to the integer *sob*

[02:10] <lue> I'm a moron. I didn't add the result of the fraction, but the numerator. :)

[02:13] *** gfldex joined
[02:14] <TimToady> The only way to be a genius is to keep on being a moron until you stop.  :)

[02:15] <lue> Fixed it, finger crossing time...

[02:16] <colomon> TimToady++

[02:16] <lue> OW! I sprained a tendon in my index finger :)

[02:18] <sorear> type with your tongue

[02:19] <TimToady> impossible to strain a muscle in your index finger; impossible to strain a tendon in your tongue.  tradeoffs...

[02:19] <TimToady> hard to cross your tongue though.

[02:20] <lue> :D :D :D :D :) :) :) :) :) \o/ \o/ \o/ \o/ \o/ \o/ ^.^ ^.^ ^.^

[02:20] <lue> >say radcalc(16,'16D.4')

[02:20] <lue> 365.25

[02:20] <Juerd> TimToady: Only if you're alone

[02:20] <sorear> shifted chars are hard... use your nose for those

[02:20] <TimToady> ooh, a significant number

[02:20] <lue> yes, the number of days in a year :)

[02:20] *** rcsheets joined
[02:20] <colomon> approximately.  ;)

[02:20] <TimToady> give or take a gregorian

[02:21] <rcsheets> There are 143 people in this channel.

[02:21] <sorear> rcsheets: no, only about 139

[02:21] <Juerd> rcsheets: That's not true :)

[02:21] <lue> now to fix adverbs, pass spectests, get a commit bit, and commit

[02:21] *** TimToady sets mode: +vv buubot dalek

[02:21] *** TimToady sets mode: +vv ilogger2 IRSeekBot

[02:21] *** TimToady sets mode: +vv p6eval phenny

[02:21] <Juerd> teh botz

[02:21] <rcsheets> ok so my definition of person is broken

[02:21] <lue> (or nopaste a patch)

[02:21] <TimToady> looks like there are six bots, unless you're one :)

[02:21] <snarkyboojum> depends how good the bots are

[02:21] <rcsheets> There are 143 IRC users in this channel.

[02:21] *** mauke joined
[02:21] <colomon> jnthn++

[02:21] <sorear> wrong again

[02:22] <sorear> 144

[02:22] <colomon> > say 3 R* 4 R- 20

[02:22] <colomon> 8

[02:22] <colomon> > say 3 R- 4 R* 20

[02:22] <colomon> 77

[02:22] <Juerd> Irssi said there were 143 "nicks". That's pretty accurate.

[02:22] <lue> ...where is the adverb defined? (oh dang it, forgot magnitude O.o)

[02:22] <rcsheets> hmm, nicks

[02:22] <rcsheets> ok, fine

[02:22] <rcsheets> i'll agree with nicks

[02:22] *** icke_ joined
[02:23] <colomon> > say 1, 2 RZ~ 'a', 'b'

[02:23] <colomon> a1b2

[02:23] <pugssvn> r30147 | lwall++ | [STD] pass single coeff to radcalc to make :16<.BABEFACE> easier 

[02:23] <pugssvn> r30147 | more awesomization of the no unspace message

[02:23] *** icke_ left
[02:23] <sorear> rcsheets: anyways, what brings you here?

[02:24] <rcsheets> necrocow. he's not here.

[02:24] <TimToady> would you like a commmit bit?

[02:24] <sorear> who, me?

[02:24] <sorear> and to what project?

[02:24] <rcsheets> but he thinks he is here. so... i joined, to see for myself.

[02:25] <TimToady> we hand out pugs repo commit bits like candy

[02:25] * TimToady refrains from making joke on "repo man"

[02:26] <lue> rakudo commit bit would be nice, as opposed to nopasting patches :)

[02:26] <TimToady> I don't have any of those

[02:26] <lue> (I would love a commit byte :) )

[02:26] <TimToady> but you can hack on the spec and tests, or even STD

[02:26] <TimToady> or any of the other projects in the pugs repo

[02:27] <lue> I has a pugs commit bit already, it's just rakudo...

[02:27] <lue> (got to go add in magnitude...)

[02:29] *** rcsheets` joined
[02:29] <lue> rakudo: Q:PIR{if 3 == 3 say "hey"}

[02:29] <p6eval> rakudo 5edcaf: OUTPUT¬´error:imcc:syntax error, unexpected PARROT_OP, expecting GOTO ('say')‚ê§     in file 'EVAL_1' line 64‚ê§¬ª

[02:29] <lue> so it has to be a goto...

[02:30] *** necrocow joined
[02:30] <rcsheets`> hi necrocow.

[02:30] <rcsheets`> can you see this?

[02:31] <necrocow> yes

[02:31] *** mauke left
[02:31] <necrocow> can you see this?

[02:31] <rcsheets`> yup.

[02:31] *** rcsheets` left
[02:31] * sorear wonders what this is about.

[02:31] <necrocow> ok

[02:32] <necrocow> looks liek giubson was split until a moment ago

[02:32] <necrocow> is is true there will be a pure C version of perl6 (like perl5 and before are)

[02:32] <rcsheets> i disagree, but anyway now you can ask #perl6 about perl 6.

[02:32] <lue> rakudo: say :16<A*2**16>

[02:32] <p6eval> rakudo 5edcaf: OUTPUT¬´655360‚ê§¬ª

[02:32] *** rcsheets left
[02:32] <lue> rakudo: say :16<A*2>

[02:32] <p6eval> rakudo 5edcaf: OUTPUT¬´Malformed radix number at line 11, near "<A*2>"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[02:32] <lue> rakudo: say :16<A**2>

[02:32] <sorear> necrocow: why?

[02:32] <p6eval> rakudo 5edcaf: OUTPUT¬´Malformed radix number at line 11, near "<A**2>"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[02:33] <sorear> necrocow: this language is what you make of it

[02:33] <lue> shouldn't A*2 default to A*2**1, and A**2 an ambiguity error?

[02:33] <necrocow> sorear: curious

[02:33] <TimToady> parrot is "pure C" in that sense

[02:34] <necrocow> I've had really bad experiences with parrot

[02:34] *** astrojp joined
[02:34] <necrocow> TimToady: tha'ts not the same, if Perl 6 is weritten in parrot, it's written in parrot, not straight C

[02:34] <necrocow> so I'm aksing about Perl6 not parrot

[02:34] <lue> TimToady: for magnitude in base conversion, what if someone leaves out the base? The exponent?

[02:34] <colomon> in the spec, both parts of *N**M are required

[02:34] <colomon> or at least, in the old spec.

[02:35] <colomon> both or neither.

[02:35] <TimToady> Perl 5 isn't written in C either, in that case. it's written in the ppcodes that the P5 interpreter uses

[02:35] <lue> EMISSINGARGUMENTS then?

[02:37] <TimToady> both parts are required in STD too

[02:37] <TimToady> std: :16<FACE*42>

[02:37] <p6eval> std 30147: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed radix number at /tmp/qMxuFDe1MO line 1:‚ê§------> [32m:16<FACE*[33m‚èè[31m42>[0m‚ê§    expecting radint‚ê§FAILED 00:01 107m‚ê§¬ª

[02:38] <TimToady> the error is kinda bogus though

[02:38] <lue> I'm going to write in error catchers for &radcalc for that then.

[02:38] <TimToady> in the expecting part

[02:39] *** vamped left
[02:39] <TimToady> you never get to radcalc in that case, since it can't find the >

[02:39] <TimToady> if rakudo follows STD there...

[02:40] <colomon> and it does at the moment, at least in this part.

[02:41] <necrocow> TimToady: well the actualy 'perl' program was indeed written in C, I've compiled it myself numerous times. What the 'perl' executable runs is another matter

[02:41] <necrocow> TimToady: you seem to be mixing things repeatedly

[02:42] <necrocow> I just want to know if there will be a striaght 'perl6' written in C, like how '/usr/bin/perl5' is

[02:42] <lue> Just in case you were to use radcalc() :)

[02:42] <lue> necrocow: if someone gets around to it :)

[02:42] <colomon> lue: good point.

[02:43] <lue> (The adverbs are still broken BTW :) )

[02:43] <necrocow> lue: I understand that... it would defiantely help if perl6 first existed :p

[02:43] <necrocow> s/defiantely/definately/

[02:43] <lue> It does... as a spec. :D

[02:44] <snarkyboojum> ./perl6 exists on my machine :)

[02:44] <necrocow> synlinks don't count :po

[02:44] <necrocow> or are you using raku or whatever it's called

[02:44] <snarkyboojum> certainly not a symlink

[02:44] <necrocow> rakudo, sorry

[02:44] <snarkyboojum> it's an executable :)

[02:44] <necrocow> but it's not a real perl6 though

[02:45] <TimToady> necrocow: you insist on making distinctions that are relatively meaningless

[02:45] <necrocow> huh

[02:45] <snarkyboojum> for that matter I have a perl6.c on my machine too :D

[02:45] <lue> It will be, once it passes the test suite :)

[02:45] *** nihiliad left
[02:45] <necrocow> TimToady: you seems to keep making distinctive things to be the same thing which is wrong

[02:45] *** nihiliad joined
[02:45] <sorear> necrocow: explain to me why it even matters

[02:46] <necrocow> TimToady: parrot != perl6, perl6 is (to be?) written in parrot, so what ever parrot is written in is irrevent. Perl5 reads ppcodes, but it is NOT written IN ppcodes, it is written in C

[02:46] <necrocow> those ARE important distinctions

[02:46] <sorear> (also, TimToady is always right :p)

[02:46] <snarkyboojum> the first line of which (perl6.c) is '#include "parrot/parrot.h"' :)

[02:46] <necrocow> I tihnk not :p

[02:47] <necrocow> so there is perl6 in c code then?

[02:47] <lue> Probably the virtual machine bit upsets him. I'm not a fan of it either (can't wait for self-supporting Rakudo)

[02:47] <sorear> Perl 5 is not written in C, it's written in an unholy custom macro language

[02:47] <colomon> There is certainly C code in Rakudo.

[02:48] <snarkyboojum> colomon: was just about to mention that, but once again beaten to it :)

[02:48] <colomon> Perl 6 is a specification, not a particular implementation.

[02:48] <sorear> I don't get what's so special about C

[02:48] <sorear> it's just a language

[02:48] <TimToady> and it obviously confuses everyone who uses it

[02:49] <necrocow> sorear: you're write, dispite all the C code, I should have been using javac to build perl5 all these years. How the hell could I have missed that

[02:49] <necrocow> I can't believe I was always using gcc

[02:49] <sorear> necrocow: "unholy custom macro language" != java

[02:49] <necrocow> it's still C ffs

[02:49] <cognominal> The important point is that Perl 6, once bootstrapped, will be mostly written in Perl 6 and the back end will be less relevant to the user of Perl 6. That cannot be said of Perl 5.

[02:49] <sorear> necrocow: if you want a Perl 6 implementation written in Pig Latin, feel free to write one.

[02:50] <sorear> Implementation language is an implementation detail

[02:50] <necrocow> I never saw the benefit of building a compiler with another instance of that compiler... that sometimes made it impossible ot build ghc fir instance

[02:50] <sorear> also, you should *never* use gcc to build perl5

[02:50] <sorear> you should always use make

[02:51] <necrocow> I've never been unable to build perl5 from sources 

[02:51] <sorear> perl6 is also built using make

[02:51] <cognominal> Things like parsing are written using a manual lexer and yacc for Perl 5 while parsing in Perl 6 is done in Perl 6.

[02:51] <necrocow> sorear: huh... I don't use gcc directly, whatever is in the Makefile, which I'm fairly certain uses gcc and such

[02:51] <sorear> *plonk*

[02:52] <lue> Oi!

[02:52] *** literal_ is now known as literal

[02:52] <necrocow> oh very matuire

[02:52] <necrocow> yeah the whole world needs to know you added someone t oyour ignore list

[02:52] <lue> Erm, who added you to an ignore list?

[02:52] <necrocow> fucking idiot

[02:52] *** necrocow left
[02:52] <lue> O WOAH! Language mister!

[02:53] <m6locks> O__o

[02:53] <sorear> being friendly to idiots is so hard

[02:53] <lue> rakudo: say :16<A*2**2> #would be 40

[02:54] <p6eval> rakudo 5edcaf: OUTPUT¬´40‚ê§¬ª

[02:54] <sorear> seriously, what's the point of joining and immediately being confrontational

[02:54] <sorear> maybe he's just a troll

[02:54] <lue> Ah well (IMO, an 'Oi!' was appropriate at that point...)

[02:55] <lue> at least he left volunatarily (now, should we block him from joining again...? Good thing I'm not op :) )

[02:57] *** fda314925 joined
[02:57] <lue> And for the record, how could I reply to someone on my ignore list? :)

[02:59] <sorear> plonk means I no longer care what you have to say

[03:02] <TimToady> actually, historically (Usenet) it's the sound of putting someone in your killfile

[03:02] <sorear> yes

[03:02] <TimToady> oddly, I'm acquanted with the chap who invented killfiles  :)

[03:02] <sorear> but irssi killlists are broken by design, and I don't use them

[03:03] <lue> Are you with the guy who invented kickbans?

[03:03] * sorear is trying to write a replacement in perl6

[03:03] <colomon> TimToady: is there a convenient list_infix operator which isn't a metaop?  I need it for a test case...

[03:03] <sorear> Z

[03:04] <colomon> Hmmm... Z is sort of implicitly a metaop... it's a funky case.

[03:04] <colomon> At least in theory, Z is just Z,

[03:04] <TimToady> ...

[03:04] <colomon> TimToady: You are a genius.  :)

[03:04] <lue> let me guess... in PIR, you can't do $N0 pow $N1, it has to be integers...

[03:05] <colomon> lue:  seems unlikely... pow is easier to implement on floats.

[03:05] <sorear> depends.  Is a FPU available?

[03:05] <colomon> > say 10 R... 1, 3

[03:05] <colomon> 13579

[03:06] <colomon> in PIR?  yes

[03:06] <lue> here's the line I'm trying: $N1 = base pow exponent

[03:07] <lue> it says it expected a newline when I try make :/

[03:07] <cognominal> what is R... ?

[03:08] <colomon> it's ... reversed

[03:08] <colomon> like 4 R- 5 is 5 - 4 = 1

[03:09] <lue> rakudo: say :16<A*2.5**3.6>

[03:09] <p6eval> rakudo 5edcaf: OUTPUT¬´Malformed radix number at line 11, near "<A*2.5**3."‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[03:09] <colomon> 10 R... 1, 3 is 1, 3 ... 10

[03:09] <lue> I'm guessing fractional magnitudes are not allowed?

[03:09] <colomon> lue: right

[03:09] <lue> that makes things easier :)

[03:09] <cognominal> clearly Perl 6 is a agglutinative language :)

[03:10] <cognominal> I just don't yet know all the morphemes

[03:10] <lue> argh! Still i won't let me do base pow exponent.

[03:11] <colomon> And you can just keep stacking them... it will work as soon as I spectest and check in.

[03:11] <colomon> you can do stuff like RXR~

[03:12] <lue> Is there a PIR expert that tells me why it won't let me use pow, insisting there should be a newline?

[03:12] <cognominal> is ROXOR possible ?  :)

[03:13] <colomon> only if you define your own O metaop.  :)

[03:13] <pugssvn> r30148 | lwall++ | [STD] give better message on missing ** part 

[03:13] <cognominal> I can't figure where that goes is the grammar

[03:13] <colomon> errr, and it would have to be like ROXOR~  or ROXOR+

[03:14] <cognominal> *in

[03:14] <colomon> unless we define a R operator that doesn't need an op to follow it. 

[03:14] <colomon> it would be consistent with X and Z....  ;)

[03:14] *** xomas left
[03:14] <lue> I'm about to cry. Hours of coding stopped by an unruly pow opcode...

[03:15] <Tene> sorear: what's wrong with /ignore in irssi?

[03:15] <pugssvn> r30149 | colomon++ | [t/spec] Add tests to make sure precedence is properly carried over from op to Rop. 

[03:15] <sorear> Tene: it corrupts autolog data

[03:16] <sorear> if I'm looking back at my logs in a week, the rage is gone and I've removed the ignore, but the log data is still absent

[03:16] * Tene nods.

[03:16] <Tene> 'k

[03:16] <colomon> lue: I only see         $N2 = pow $N0, $N1 constructions in alpha code....

[03:16] <lue> ...

[03:16] <lue> ...

[03:17] <lue> .....................

[03:17] <lue> ......

[03:17] <lue> meep

[03:17] <lue> rakudo: Q:PIR{fail}

[03:18] <p6eval> rakudo 5edcaf: OUTPUT¬´error:imcc:syntax error, unexpected '\n', expecting '('‚ê§   in file 'EVAL_1' line 64‚ê§Could not find non-existent sub fail‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[03:18] <colomon> oh, nevermind, pir::pow__NNN is operators.pm

[03:18] <lue> rakudo: Q:PIR{$I0=pow 2,3‚ê§say $I0}

[03:18] <p6eval> rakudo 5edcaf: OUTPUT¬´eval_ins: op 'pow_i_i_i' not found‚ê§‚ê§current instr.: 'perl6;PCT;HLLCompiler;evalpmc' pc 972 (compilers/pct/src/PCT/HLLCompiler.pir:538)‚ê§¬ª

[03:19] <colomon> NNN means it takes two Nums and returns a Num.

[03:20] <colomon> hmmm....

[03:20] <lue> rakudo: Q:PIR{$I0=2 pow 3‚ê§say $I0}

[03:20] <p6eval> rakudo 5edcaf: OUTPUT¬´error:imcc:syntax error, unexpected PARROT_OP, expecting '\n' ('pow')‚ê§     in file 'EVAL_1' line 64‚ê§2‚ê§¬ª

[03:20] <colomon> rakudo: say pir::pow__III(10,3)

[03:20] <p6eval> rakudo 5edcaf: OUTPUT¬´The opcode 'pow_i_i_i' (pow<3>) was not found. Check the type and number of the arguments‚ê§current instr.: 'perl6;PCT;HLLCompiler;evalpmc' pc 972 (compilers/pct/src/PCT/HLLCompiler.pir:538)‚ê§¬ª

[03:20] <lue> so they HAVE to be nums?

[03:20] <colomon> maybe?

[03:20] <lue> rakudo: Q:PIR{$I0=pow 2.0,3.0‚ê§say $I0}

[03:21] <p6eval> rakudo 5edcaf: OUTPUT¬´eval_ins: op 'pow_i_n_n' not found‚ê§‚ê§current instr.: 'perl6;PCT;HLLCompiler;evalpmc' pc 972 (compilers/pct/src/PCT/HLLCompiler.pir:538)‚ê§¬ª

[03:21] <lue> rakudo: Q:PIR{$N0=pow 2.0,3.0‚ê§say $N0}

[03:21] <p6eval> rakudo 5edcaf: OUTPUT¬´8‚ê§¬ª

[03:21] <lue> OK.

[03:21] *** wknight8111 left
[03:22] <lue> yes! Compiling...

[03:22] <snarkyboojum> rakudo: Q:PIR{$N0=pow 2.0,3‚ê§say $N0}

[03:22] <p6eval> rakudo 5edcaf: OUTPUT¬´8‚ê§¬ª

[03:23] <lue> rakudo: say radcalc(16,'12','.4',3.5,2.2) # radix, int, frac, base, exp

[03:23] <p6eval> rakudo 5edcaf: OUTPUT¬´283.284102145718‚ê§¬ª

[03:23] <colomon> > say 1, 3, 5 RXR~ 'a'..'d'

[03:23] <colomon> 1a3a5a1b3b5b1c3c5c1d3d5d

[03:23] <colomon> > say 1, 3, 5 X~ 'a'..'d'

[03:23] <colomon> 1a1b1c1d3a3b3c3d5a5b5c5d

[03:23] <lue> It allows fractional magnitudes thru radcalc directly then :)

[03:23] <lue> Is that legal?

[03:24] <colomon> well, radcalc is just a helper function, I don't know that it's actually spec'd anywhere.

[03:24] <lue> ah well. Until you can use pow on integers, I'm not worrying :)

[03:27] <lue> rakudo: say :16<A*2**3> # as a reference to see if my code works

[03:27] <p6eval> rakudo 5edcaf: OUTPUT¬´80‚ê§¬ª

[03:27] *** lichtkind left
[03:29] <lue> yes! Now to spectest and, if colomon doesn't want to do it, fix the adverbs! \o/

[03:30] <colomon> er... fix the adverbs?

[03:30] <colomon> (and for sure I'm going to bed as soon as my own spectest run is done.)

[03:31] <lue> Yes. I removed a variable. You just need to pass the number as a string, instead of an int string and a frac string :)

[03:31] <lue> It broke the adverbs though :D

[03:31] <lue> :16<>, :2<>, etc.

[03:31] <colomon> oh, you're saying the parsing changed.

[03:31] <colomon> or at least, what you use changed.

[03:31] <colomon> yes?

[03:32] <lue> yes! I completely rewrote radcalc :)

[03:32] <lue> where are the adverbs then?

[03:32] <colomon> but you haven't been able to test the full blow thing because we don't send the right info to you.

[03:32] <colomon> hold on, I'll get you a quick patch.

[03:33] <lue> I've been using the radcalc() function call to see if things worked. Is something missing?

[03:34] <colomon> once the actions are patched for you, you can run it against S02-literals/radix.t, and check that the 180-some tests we have still work after your change.

[03:34] <colomon>         my $intpart  := $<intpart>.Str;

[03:34] <colomon>         my $fracpart := $<fracpart> ?? $<fracpart>.Str !! "0";

[03:34] <colomon>         my $base     := $<base> ?? +($<base>[0].Str) !! 0;

[03:34] <colomon>         my $exp      := $<exp> ?? +($<exp>[0].Str) !! 0;

[03:34] <colomon>         make PAST::Op.new( :name('&radcalc'), :pasttype('call'),

[03:34] <colomon>             $radix, $intpart, $fracpart, $base, $exp

[03:34] <colomon>         );

[03:34] <colomon> look for that code in Actions.pm

[03:34] <colomon> and add

[03:34] <colomon> (after the my $fracpart line)

[03:35] <colomon> my $intfrac := $intpart ~ '.' ~ $fracpart;

[03:35] <colomon> and then in the $radix, $intpart, $fracpart, $base, $exp line, replace $intpart, $fracpart, with $intfrac,

[03:35] <snarkyboojum> lue: you can get pow to work with Rakudo Int()s http://paste.lisp.org/display/96699

[03:36] <snarkyboojum> lue: not sure that's what you were trying to do anyway - but what the hell

[03:36] <colomon> That should make the current parser talk to your version of radcalc so you can run tests on it.

[03:37] <lue> so after all modifications, run make spectest, and then nopaste a patch if all goes well?

[03:38] <colomon> don't do a full make spectest (at least at first) just do make t/spec/S02-literals/radix.t

[03:38] <colomon> that will do a short test that just tests your changes.

[03:38] <colomon> If that works out, then do a full spectest.  :)

[03:39] <colomon> and oh, make sure you have the latest t/spec/S02-literals/radix.t, I fudged it today.

[03:40] <lue> make test gets the latest spectest to rakudo, right?

[03:40] <colomon> and then if your code works, we'll have to unfudge some of the tests, including some that have never worked before!  :)

[03:40] * lue is running make; make test; make t/spec/more stuff here

[03:41] <lue> I heard make-ing individual tests is bad (oh well)

[03:42] <colomon> lue: TimToady is against it, and it probably is a logical blot on the system, but it works and is very handy.  ;)

[03:42] * lue intermitently afk and !afk whilst compiling

[03:42] <lue> bah well! I can always re-download the file :)

[03:44] <colomon> bah, strange failures here, going to bed instead of pushing.

[03:44] <colomon> lue: good luck!

[03:45] <lue> NO BUT WHAT IF i need to make a patch?

[03:45] <lue> I guess the unfudgeing/patching can wait 'til tomorrow if nothing else :)

[03:47] *** unobe joined
[03:55] <lue> garh, decimals broke again :/

[03:56] <lue> it also doesn't like :16()...

[03:56] <lue> I'll get to that tomorrow. Later!

[03:56] <sorear> lue: make test runs Rakudo-specific tests only

[03:56] *** astrojp left
[03:57] <sorear> you want make spectest, which svn clones the pugs repo and runs the P6 spec suite

[04:00] *** nihiliad left
[04:00] *** nihiliad joined
[04:06] *** cognomore joined
[04:21] *** meppl left
[04:31] *** dual left
[04:50] *** xomas joined
[04:50] *** xomas left
[04:50] *** xomas joined
[05:17] *** abra joined
[05:30] *** nihiliad left
[05:31] *** ShaneC left
[05:41] *** sorear joined
[05:43] * snarkyboojum is wondering how exists could be implemented for Array now that it's not backed by a ResizeablePMCArray (which implements exists_keyed)...

[05:43] <TimToady> bitmap?

[05:44] <TimToady> what is it implemented with?

[05:47] <snarkyboojum> I don't understand well enough.. perhaps it is :)

[05:47] <snarkyboojum> alpha used to be Array <- List <- ResizeablePMCArray

[05:49] <snarkyboojum> whereas in masters it's Array <- Seq <- Iterable <- Any <- Mu

[05:50] *** unobe left
[05:50] <snarkyboojum> I suspect I'm not making much sense :)

[05:50] <TimToady> whether a container is there in the list of pointers seems not to have much to do with derivation

[05:51] <TimToady> but I'm no expert in the internals

[05:52] *** am0c joined
[05:56] <snarkyboojum> and Mu is a P6opaque-ish thing ? No idea :) I was just hoping to port alpha's exists() functionality over to master :)

[06:03] <snarkyboojum> rakudo: @a = <a b c>; say @a.PARROT

[06:03] <p6eval> rakudo 5edcaf: OUTPUT¬´Symbol '@a' not predeclared in <anonymous>‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[06:04] <snarkyboojum> rakudo: my @a = <a b c>; say @a.PARROT

[06:04] <p6eval> rakudo 5edcaf: OUTPUT¬´Array‚ê§¬ª

[06:04] <sorear> As far as I know the Perl6 type ontology has nothing whatsoever to do with representation

[06:05] *** molaf joined
[06:05] *** eternaleye left
[06:08] *** eternaleye joined
[06:08] <snarkyboojum> my lack of understanding is the problem here :)

[06:08] <sorear>  you think YOU lack understanding?

[06:09] <snarkyboojum> :) most definitely

[06:09] *** IllvilJa left
[06:16] *** abra left
[06:16] <snarkyboojum> if say @a.PARROT returns 'Array', does that mean it uses an Array PMC? (naivety is bliss :))

[06:18] <sorear> Where is the master list of valid arguments to --target?

[06:20] *** cognomore left
[06:26] <snarkyboojum> parse, past, post, pir, evalpmc I think

[06:28] <snarkyboojum> from line 32 in parrot/compilers/pct/src/PCT/HLLCompiler.pir :)

[06:28] <snarkyboojum> afk

[06:32] *** payload joined
[06:35] *** am0c left
[06:45] <TimToady> std: /\ /

[06:46] <p6eval> std 30149: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes (' ') or use a backslashed form like \x20 at /tmp/GrxIyYMA4y line 1:‚ê§------> [32m/\[33m‚èè[31m /[0m‚ê§FAILED 00:01 107m‚ê§¬ª

[06:46] <TimToady> std: /\#/

[06:46] <p6eval> std 30149: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('#') or use a backslashed form like \x23 at /tmp/TinDHTWWpT line 1:‚ê§------> [32m/\[33m‚èè[31m#/[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[06:47] <TimToady> std: /\‚ê§/

[06:47] <p6eval> std 30149: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('‚ê§') or use a backslashed form like \x0a at /tmp/YOmcrtcG2A line 1:‚ê§------> [32m/\[33m‚èè[31m<EOL>[0m‚ê§FAILED 00:02 105m‚ê§¬ª

[06:48] <TimToady> std: :16<FACE*2>

[06:48] <p6eval> std 30149: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Base is missing ** exponent part at /tmp/2fnX4fV204 line 1:‚ê§------> [32m:16<FACE*2[33m‚èè[31m>[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[06:49] <TimToady> zzz &

[06:59] *** molaf left
[07:00] <sorear> snarkyboojum: thanks

[07:01] *** molaf joined
[07:34] *** abra joined
[07:37] <sorear> rakudo: class Bob is Int { }; my Int $a = 0; $a = Bob.new; say $a

[07:37] <p6eval> rakudo 5edcaf: OUTPUT¬´0‚ê§¬ª

[07:38] <sorear> I wonder how the existance of subclasses of primitive types interacts with the concept of unboxing

[07:41] *** mberends joined
[07:52] <moritz_> Int is not a primitive type; int is 

[08:03] <sorear> oh

[08:04] <sorear> rakudo: class Bob is int { }; my int $a = 0; $a = Bob.new; say $a

[08:04] <p6eval> rakudo 5edcaf: OUTPUT¬´Malformed my at line 11, near "int $a = 0"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[08:07] *** kaare joined
[08:08] *** kaare is now known as Guest14894

[08:09] *** envi^home joined
[08:12] *** jhuni left
[08:13] *** fridim joined
[08:16] <moritz_> but rakudo doesn't knoe about native/primitive types yet

[08:26] *** Chillance left
[08:32] <moritz_> phenny: tell pmichaud could you please add a small guide to the nqp-rx README telling people how to update the nqp sources in parrot? it seems to lower the truck number unnecessary as is

[08:32] <phenny> moritz_: I'll pass that on when pmichaud is around.

[08:32] *** moritz_ sets mode: +o sorear

[08:34] <sorear> ooh. shiny.

[08:35] *** Su-Shee joined
[08:35] <moritz_> alpha: say "yes" if "\t" ~~ / <[\t]> /;

[08:36] <p6eval> alpha 30e0ed: OUTPUT¬´yes‚ê§¬ª

[08:36] <moritz_> rakudo: say "yes" if "\t" ~~ / <[\t]> /;

[08:36] <p6eval> rakudo 5edcaf:  ( no output )

[08:43] *** |Jedai| joined
[09:06] <moritz_> phenny: tell pmichaud I've assigned RT #73698 to you; it's blocking me from running the JSON::Tiny test suite, and I need to port JSON::Tiny to proto regexes for the book... - would be nice if you could take a look in your sparse tuits

[09:06] <phenny> moritz_: I'll pass that on when pmichaud is around.

[09:17] <snarkyboojum> rakudo: my @a = [1,,3]; say @a.elems

[09:18] <p6eval> rakudo 5edcaf: OUTPUT¬´1‚ê§¬ª

[09:18] <snarkyboojum> what's happening there?

[09:18] <moritz_> rakudo: my @a = [1,,3]; say @a.perl

[09:18] <p6eval> rakudo 5edcaf: OUTPUT¬´[[1, 3]]‚ê§¬ª

[09:18] <moritz_> std: [1,,3]

[09:18] <p6eval> std 30149: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Preceding context expects a term, but found infix , instead at /tmp/83jkkgn6w6 line 1:‚ê§------> [32m[1,[33m‚èè[31m,3][0m‚ê§FAILED 00:01 108m‚ê§¬ª

[09:18] <moritz_> rakudo: my @a = 1,,3; say @a.elems

[09:18] <p6eval> rakudo 5edcaf: OUTPUT¬´2‚ê§¬ª

[09:18] <snarkyboojum> cool.. so rakudo should fail?

[09:18] <moritz_> aye

[09:18] <snarkyboojum> excellent

[09:31] *** am0c joined
[09:35] *** iblechbot joined
[09:38] <moritz_> phenny: tell jnthn that t/spec/S12-class/attributes.t emits some IMCC syntax errors, probably at compile time (but still runs) and passes all but one test - LHF?

[09:38] <phenny> moritz_: I'll pass that on when jnthn is around.

[09:38] *** colomon joined
[09:42] *** unobe joined
[09:45] *** unobe left
[09:53] <moritz_> rakudo: print 2**20

[09:54] <p6eval> rakudo 5edcaf: OUTPUT¬´1048576¬ª

[09:56] <colomon> o/

[09:57] *** M_o_C joined
[09:58] *** M_o_C left
[10:01] <moritz_> it's c\o/lomon!

[10:01] <moritz_> the last test in t/spec/S03-operators/r-metaop.t fails for me

[10:06] <colomon> moritz_: actually should be the last two tests that fail.  At least, I think I added the tests but haven't pushed the patch yet.  :(

[10:07] <colomon> or does it fail hard?

[10:07] <colomon> is 4 R- 5 R/ 10, -2, "Rop gets the precedence of op";

[10:07] <colomon> is (10 R... 1, 3), (1, 3, 5, 7, 9), "Rop gets list_infix precedence correctly";

[10:08] *** drbean left
[10:11] <colomon> I guess this is a sign the first of those two tests is not sufficient  -- I thought it wouldn't work without the patch!

[10:11] <moritz_> test 29, is 4 R- 5 R/ 10, -2, "Rop gets the precedence of op"; works

[10:12] <colomon> nods

[10:12] <colomon> I just tested it on one of my other machines.

[10:12] <colomon> you can ignore the #30 fail, it will do so until I get my patch pushed.

[10:12] <moritz_> rakudo: say 3 R/ 9 + 5 # should be 8

[10:13] <p6eval> rakudo 5edcaf: OUTPUT¬´4.66666666666667‚ê§¬ª

[10:13] <moritz_> that's something we can put in the test file

[10:13] <colomon> moritz_++

[10:13] <snarkyboojum> rakudo: my @list = <a b c>; @a[0].say;

[10:13] <p6eval> rakudo 5edcaf: OUTPUT¬´Symbol '@a' not predeclared in <anonymous>‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[10:13] <moritz_> rakudo: say 9 / 3 + 5

[10:13] <p6eval> rakudo 5edcaf: OUTPUT¬´8‚ê§¬ª

[10:14] <snarkyboojum> rakudo: my @list = <a b c>; @list[0].say;

[10:14] <p6eval> rakudo 5edcaf: OUTPUT¬´a‚ê§¬ª

[10:14] <snarkyboojum> rakudo: my @list = <a b c>; @list.exists(0);

[10:14] <p6eval> rakudo 5edcaf: OUTPUT¬´Method 'exists' not found for invocant of class 'Array'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[10:15] <colomon> moritz_: You unfudged a bunch of tests in radix.t that only work on 64-bit platforms.

[10:16] <moritz_> colomon: I'd like to move S03-operators/foo-metaop.t to S03-metaop/foo.t - what do you think about that?

[10:16] <moritz_> colomon: eh - could you please move them to overflow.t? 

[10:16] <colomon> moritz_: on overflow -- will do.

[10:17] <colomon> on S03-metaop -- makes sense to me.

[10:18] *** rv2733 joined
[10:18] <colomon> give me a sec (before reorg) to get the radix.t patches in.

[10:19] *** drbean joined
[10:19] * moritz_ will do it after breakfast :-)

[10:22] * colomon is now quietly singing "Overflow" from Porgy and Bess to himself, he just realized.

[10:28] <dalek> rakudo: e877b2a | (Solomon Foster)++ | src/Perl6/ (2 files):

[10:28] <dalek> rakudo: Move the <infix_prefix_meta_operator> <infixish> into the <infix_prefix_meta_operator> tokens themselves.

[10:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e877b2ae12cab206ccbde1c16920ec1f190c1884

[10:28] <dalek> rakudo: 6be8f8c | (Solomon Foster)++ | src/Perl6/Grammar.pm:

[10:28] <dalek> rakudo: Proper precedence for !op, Rop, and Sop.  jnthn++.

[10:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6be8f8c5a1d6726d05905ccbe0c40843489f9ac5

[10:31] <snarkyboojum> would this work for Array .exists? (I have a feeling is dodgey - but works i.e. passes tests :)) http://paste.lisp.org/display/96712

[10:32] <moritz_> rakudo: my @a = (1, 2); say @a[0] ~~ Proxy

[10:32] <p6eval> rakudo 5edcaf: OUTPUT¬´0‚ê§¬ª

[10:32] <colomon> moritz_: go ahead with the move whenever you're ready.

[10:32] <moritz_> rakudo: my @a = (Proxy, Proxy); say @a[0] ~~ Proxy

[10:32] <snarkyboojum> my @a = (1, 2); say @a[-1] ~~ Proxy

[10:32] <p6eval> rakudo 5edcaf: OUTPUT¬´1‚ê§¬ª

[10:32] <snarkyboojum> my @a = (1, 2); say @a[6] ~~ Proxy

[10:33] <colomon> is non-existence the only reason to return a Proxy?

[10:33] <snarkyboojum> dunno

[10:33] <moritz_> unless you store a Proxy inside it

[10:33] <moritz_> colomon: will do later on

[10:33] <snarkyboojum> but reading the source of Proxy.pir "A Proxy is used to represent non-existent elements in aggregates."

[10:33] <snarkyboojum> thought it might work ;)

[10:34] <snarkyboojum> so I take it - that's a no :)

[10:34] * moritz_ thinks so

[10:34] <snarkyboojum> how else could it be done?

[10:34] <moritz_> maybe you need to access the RPA under the hood directly

[10:34] <moritz_> afk

[10:34] <snarkyboojum> I tried, but there's no RPA there anymore in master right?

[10:36] <moritz_> the items must be stored somewhere

[10:36] <snarkyboojum> an Array is a Seq is a Iterable is an Any is a Mu

[10:37] <snarkyboojum> moritz_: agreed :) but where?

[10:37] <snarkyboojum> :)

[10:37] <colomon> snarkyboojum: look at postcircumfix:<[ ]> in Array.pir

[10:37] <snarkyboojum> colomon: k

[10:38] <colomon> that's where the Proxy is returned if the element doesn't exist, I think.

[10:38] <colomon>     unless null elem goto have_elem

[10:39] <snarkyboojum> so it just checks if values[n] is null or not in PIR

[10:39] <colomon> yeah

[10:39] <snarkyboojum> is that the appropriate check then?

[10:39] <colomon> I mean, I think -- I'm not an expert on this.

[10:39] <colomon> but that would be my thought on how to do it.

[10:40] <snarkyboojum> so checking for Proxy is invalid because you could store a Proxy object in the array

[10:40] <snarkyboojum> but if you check for an element and it's null Rakudo gives you back a Proxy object :)

[10:40] <snarkyboojum> how would you discern the difference?

[10:41] <colomon> I don't think you can if you just look at [ ]'s return value.

[10:42] <snarkyboojum> colomon: cheers again then

[10:42] <colomon> good luck!

[10:42] <snarkyboojum> colomon: it felt like cheating :)

[10:43] <colomon> afk # going to try to go back to bed, maybe

[10:43] <snarkyboojum> ?(bed) ;)

[11:08] *** PZt left
[11:08] *** meppl joined
[11:15] *** dual joined
[11:15] *** snarkyboojum left
[11:17] *** abra left
[11:23] <pugssvn> r30150 | moritz++ | [t/spec] re-fudge listquote.t for rakudo 

[11:23] <pugssvn> r30151 | moritz++ | [t/spec] failing Rop precedence test for colomon++ 

[11:23] <pugssvn> r30152 | moritz++ | [t/spec] unfudgea a >>+<< test for rakudo, jnthn++ 

[11:23] <pugssvn> r30153 | colomon++ | [t/spec] Move overflowing tests from radix.t to overflow.t. 

[11:24] <moritz_> wow, pugssvn seems slow

[11:25] <colomon> it must have just been off, no?

[11:25] <colomon> It didn't have any reports at all yesterday, as far as I can recall.  And someone (you, I suspect) was making changes all day long.

[11:26] <moritz_> and I tried to resurrect pugssvn

[11:26] <moritz_> another question regarding test file names

[11:26] <moritz_> currently they are inconsisten

[11:26] <moritz_> cross-metaop.t vs. r-metaop.t

[11:26] <moritz_> should we name them cross and reverse, or x and r?

[11:26] * moritz_ votes for the longer names

[11:27] <colomon> cross and reverse, I'd say

[11:29] <pugssvn> r30154 | moritz++ | [t/spec] move some meta operator test files to S03-metaops/ 

[11:32] <pugssvn> r30155 | moritz++ | [t/spec] also move hyper op tests to S03-metaops 

[11:46] *** wknight8111 joined
[11:46] <jnthn> o/

[11:46] <phenny> jnthn: 09:38Z <moritz_> tell jnthn that t/spec/S12-class/attributes.t emits some IMCC syntax errors, probably at compile time (but still runs) and passes all but one test - LHF?

[11:46] <colomon> \o

[11:46] <jnthn> moritz_: Ouch. I'll have to hunt that one down. Maybe we need to skip something we todo. :-)

[11:47] <jnthn> morning, colomon 

[11:47] <colomon> I got Rop precedence working late last night, checked it in this morning.

[11:47] <colomon> jnthn++ for figuring out how to do it.

[11:48] <jnthn> moritz_: I think I worked out the nqp => Parrot update process, btw. I'll give it a try, and if I don't cause epic fail, I'll document that.

[11:51] <colomon> moritz_: do you want me to patch t/spectest.data to match your new layout?

[11:54] *** clintongormley joined
[11:55] <jnthn> colomon++ # nice!

[11:56] <colomon> jnthn: if you look in the backlog, you can see a R... example, TimToady++'s idea.

[11:56] *** payload left
[11:56] <colomon> I think I just successfully patched my != issue by detecting it in the metaop code and switching it to logical ! == internally.

[11:59] <jnthn> OK.

[11:59] <jnthn> There's more tha one way to fix it :-)

[11:59] <colomon> obviously a grammar fix would be more elegant, but this way should work, I think.  spectesting now.  ;)

[12:00] *** Su-Shee left
[12:04] <jnthn> colomon: True, it would be. ;-)

[12:04] <moritz_> colomon: yes, pushing...

[12:06] <dalek> rakudo: 6a8049b | moritz++ | t/spectest.data:

[12:06] <dalek> rakudo: track name changes of test files

[12:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6a8049bf423b4200da3cccbaba26ff6bcd810ea3

[12:06] <dalek> rakudo: 760b272 | moritz++ | docs/running.pod:

[12:06] <dalek> rakudo: [docs] fixed a typo in running.pod reported in <https://bugzilla.redhat.com/show_bug.cgi?id=574547>, gerd++

[12:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/760b2727e27b74093f6fd7efbeb1911b8a665bcb

[12:06] <dalek> rakudo: 547069d | moritz++ | t/spectest.data:

[12:06] <dalek> rakudo: more passing test files

[12:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/547069d74d36c7512b61ad1ba237337502f481f5

[12:08] <jnthn> \o/

[12:09] *** Su-Shee joined
[12:15] <m6locks> rakudo: my Num $a = 5.22; say $a

[12:15] <p6eval> rakudo 6be8f8: OUTPUT¬´Type check failed for assignment‚ê§current instr.: '&die' pc 17127 (src/builtins/Junction.pir:399)‚ê§¬ª

[12:15] <m6locks> rakudo: my $a = 5.22; say $a.WHAT

[12:15] <p6eval> rakudo 6be8f8: OUTPUT¬´Rat()‚ê§¬ª

[12:16] <moritz_> in ideal Perl 6, you'd constrain $a to Numeric, not Num if you want it to hold any number type

[12:16] <m6locks> so Num is not a number?

[12:16] <jnthn> Rakudo only supports unideal Perl 6 so far. :-)

[12:16] <m6locks> rakudo: my Numeric $a = 5.22; say $a

[12:16] <jnthn> m6locks: Num = Floating point number

[12:16] <p6eval> rakudo 6be8f8: OUTPUT¬´Method 'ACCEPTS' not found for non-object‚ê§current instr.: '&infix:<=>' pc 16823 (src/builtins/Junction.pir:228)‚ê§¬ª

[12:17] <moritz_> the role Numeric is NYI

[12:17] <m6locks> aye, well i guess its not supported then

[12:17] <jnthn> m6locks: But 5.22 is not a floating point number in Perl 6, it's a Rat.

[12:17] <m6locks> oh, how do i make it a Num

[12:17] <m6locks> when assigning a value like that

[12:17] <moritz_> with scientific notation, 5.22e0

[12:17] <moritz_> or 5.22.Num

[12:18] <m6locks> i'm cool wit Rat too, I just need to change all the Nums to Rats

[12:25] *** am0c left
[12:29] *** M_o_C joined
[12:33] <colomon> aiiiiiiii!

[12:33] <jnthn> O_O

[12:34] <jnthn> colomon: ? :-)

[12:35] <colomon> > say (10 R... 1, 3)

[12:35] <colomon> Lexical 'self' not found

[12:35] <colomon> that worked fine last night...

[12:36] <jnthn> :-/

[12:36] <colomon> hmmm... that may have been before the Rop overhaul.

[12:36] * jnthn makes the latest

[12:36] <colomon> the actions part of it.

[12:36] <colomon> oh, hey, good thinking.

[12:37] <jnthn> (latest from git, that is)

[12:37] <jnthn> Will try it once it's built. :-)

[12:37] <colomon> I think it will work with the latest.

[12:37] <colomon> so it's a change I've made and haven't pushed.

[12:38] <jnthn> rakudo: say (10 R... 1, 3)

[12:38] <p6eval> rakudo 6be8f8: OUTPUT¬´13579‚ê§¬ª

[12:38] <colomon> this damn refactor is going to be the death of me.

[12:39] <jnthn> "Tormenting the implementers"

[12:39] <jnthn> :-)

[12:39] <jnthn> It's OK, I've felt that way about plenty of Rakudo refactors and I'm still alive. They're rarely fatal. :-)

[12:43] *** iblechbot left
[12:44] <jnthn> > say (10 R... 1, 3)

[12:44] <jnthn> 13579

[12:44] <jnthn> colomon: So certainly something you have locally.

[12:45] <colomon> yup.

[12:45] <jnthn> colomon: I can glance over the diff if you like.

[12:45] <colomon> > say reverseargs(&infix:<...>, 10, [1, 3])

[12:45] <colomon> Lexical 'self' not found

[12:45] <colomon> our multi sub reverseargs(&op, Mu $a, Mu $b) {

[12:45] <colomon>     &op($b, $a);

[12:45] <colomon> }

[12:46] <colomon> actually, can you try just that?

[12:46] <colomon> it would help pinpoint if the problem is that or something with != in the series operator.

[12:47] <jnthn> > our multi sub reverseargs(&op, Mu $a, Mu $b) { &op($b, $a); }

[12:47] <jnthn> > say reverseargs(&infix:<...>, 10, [1, 3])

[12:47] <jnthn> Lexical 'self' not found

[12:47] <jnthn> That's enough.

[12:48] <jnthn> The backtrace is...weird.

[12:48] <colomon> that's a huge help, then!

[12:48] <colomon> jnthn++

[12:48] <jnthn> Oh no, maybe it's not

[12:48] <jnthn> Is ... implemented using gather/take?

[12:49] <colomon> yes

[12:49] <jnthn> OK, it's somewhere within that, it appears...

[12:50] <colomon> what backtrace did you get?

[12:51] <jnthn>     find_lex $P21399, "self"

[12:51] <jnthn>     $P21400 = $P21399."succ"()

[12:51] <jnthn> That's where it's blowing up

[12:52] <jnthn> oh

[12:52] <jnthn> $next = { $.succ };

[12:52] <jnthn> In operators.pm, in infix:<...>, line 363

[12:54] <jnthn> colomon: note:

[12:54] <jnthn> > say ([1,3] ... 10)

[12:54] <jnthn> Lexical 'self' not found

[12:54] <colomon> oh.

[12:55] <moritz_> wrong invocant

[12:55] <jnthn> colomon: I don't know why $.succ and $.pred are being used in a sub though

[12:55] <jnthn> That can never work.

[12:55] <jnthn> oh, wait, it's assining a closure...

[12:55] <colomon> that's supposed to be defining a closure

[12:56] <jnthn> But still...

[12:56] <jnthn> It's a closure, not an anonymous method.

[12:56] <jnthn> Is it just menat to be .succ and .pred?

[12:56] * moritz_ thinks so

[12:56] <colomon> I think maybe it is.

[12:56] * moritz_ spectests without that dollar

[12:56] <colomon> Oh, it's never been called before because there is infix:<...>($lhs, $rhs)

[12:57] <jnthn> colomon: here you go...

[12:57] <jnthn> > our multi sub reverseargs(&op, Mu \$a, Mu \$b) { &op($b, $a); }

[12:57] <jnthn> > say reverseargs(&infix:<...>, 10, (1,3))

[12:57] <jnthn> 13579

[12:57] <colomon> so what we're seeing here is something utterly bizarre.

[12:57] <jnthn> Well, no, it's just that passing an array means you pass a single item, whereas actually what you really have is a parcel

[12:57] <jnthn> Also, the missing \s meant that context was being enforced by reverseargs

[12:58] <colomon> if there is a single item there (the array), shouldn't it call infix:<...>($lhs, $rhs)  ?

[12:58] <jnthn> So the the things had already been put into item context by the time we called &infix:<...> so it dispatched differently.

[12:58] <jnthn> (@lhs is copy, $rhs) is narrower than ($lhs, $rhs)

[12:59] <colomon> rebuilding with \s to see what happens.

[12:59] <jnthn> Anyway, I think the \s are what's missing.

[13:06] *** bbkr left
[13:13] <colomon> > say 10 R... 1, 3

[13:13] <colomon> 13579

[13:13] <colomon> I'd say you're right.  :)

[13:22] *** masak joined
[13:22] <colomon> o/

[13:22] <masak> oh hai, #perl6

[13:24] *** M_o_C left
[13:26] <moritz_> \o/ it's masak

[13:26] <masak> \o/

[13:26] *** bbkr joined
[13:27] <moritz_> colomon: in radix.t I get a passed TODO, test 78 - I assume on 32 bit that fails?

[13:29] * masak enjoys TimToady's "blue sky" email :)

[13:29] *** justatheory joined
[13:30] <masak> it's a bit harsh against p6l perhaps, but it's true.

[13:31] *** fridim left
[13:31] <colomon> moritz_: yes.

[13:34] <masak> jnthn: will you help me dust off my awful Russian too? :)

[13:34] <masak> he's been standing in a corner for years, collecting all that dust.

[13:35] *** astrojp joined
[13:36] <masak> rakudo: "foo:" ~~ / (\S+) ':' / and say "matched $0"

[13:36] <p6eval> rakudo 6a8049:  ( no output )

[13:37] <masak> I think that's the (known) 'backtracking inside of capture parens' bug

[13:40] *** MOAR-f00li5h left
[13:40] <masak> std: 1 [+] [+] 2, 3, 4

[13:40] *** f00li5h joined
[13:40] <p6eval> std 30155: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[13:40] *** f00li5h left
[13:40] *** f00li5h joined
[13:40] *** iblechbot joined
[13:40] <masak> yeah, seems I was wrong about the semantics of '1 [+] 2, 3, 4' yesterday.

[13:41] <masak> in my defense, it's quite a cute semantics :P

[13:41] *** muixirt joined
[13:42] <masak> std: <-> { [[[<=>]]] }

[13:42] <p6eval> std 30155: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Can't reduce with <=> because structural infix operators are diffy and not chaining at /tmp/QT5tXWtCvt line 1:‚ê§------> [32m<-> { [[[<=>]]][33m‚èè[31m }[0m‚ê§    expecting prefix_circumfix_meta_operator__S_257reduce‚ê§FAILED 00:02 107m‚ê§¬ª

[13:43] <moritz_> so that's parsed as infix:<[+]> listop:<[+]> ?

[13:43] <masak> oh. :) diffy.

[13:43] <bbkr> rakudo: class X { }; class { is X; } #s12 anon class segfaults :(

[13:43] <p6eval> rakudo 6a8049: OUTPUT¬´Invalid namespace key in set_pmc_keyed‚ê§current instr.: 'perl6;ClassHOW;new' pc 3749 (src/metamodel/ClassHOW.pir:27)‚ê§¬ª

[13:43] <masak> bbkr: yes. not yet implemented.

[13:43] <bbkr> thanks

[13:46] *** abra joined
[13:47] <colomon> )P""

[13:48] <dalek> rakudo: d296602 | (Solomon Foster)++ | src/ (2 files):

[13:48] <dalek> rakudo: Reorganization of !op, Rop, Xop, and Zop in preparation for a refactor.

[13:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d2966027ce9351fd260dd9de96d2c1a8eeb053e7

[13:48] <dalek> rakudo: 2067a57 | (Solomon Foster)++ | src/core/metaops.pm:

[13:48] <dalek> rakudo: Switch Mu $a to Mu \$a in the notresults and reverseargs functions, as per jnthn++'s advice.

[13:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2067a57f9781bee8e8aa914cf9ff0e41563e11d7

[13:48] <masak> colomon++

[13:50] *** synth left
[13:50] *** [synth] left
[13:50] *** synth joined
[13:50] *** [synth] joined
[13:50] <moritz_> rakudo: say [] ~~ [1]

[13:50] <p6eval> rakudo 6a8049: OUTPUT¬´0‚ê§¬ª

[13:50] <moritz_> who fixed that?

[13:51] <pugssvn> r30156 | moritz++ | [t/spec] a tiny unfudge for rakudo 

[13:52] <colomon> is anyone else getting intermittent test failures again?

[13:52] <moritz_> I get an intermittent pasisng TODO in uc.t

[13:53] <moritz_> and S04-statements/for.t fails reproducible

[13:53] <masak> http://twitter.com/arafatkamaal/status/10809395431 # strange/funny realization by someone

[13:53] <colomon> I've gotten crashes in uc.t as well.

[13:53] <m6locks> haven't built today

[13:54] <colomon> I'm also getting sometimes failures in S06-signature/named-parameters.t and a consistent failure in S03-operators/precedence.t.

[13:55] <colomon> If no else is seeing that last one (yet), it may be my fault.   Though I really don't know how...

[13:56] <moritz_> precedence.t is fine here.

[13:56] <colomon> have you pulled yet?  ;)

[13:56] <moritz_> no

[13:56] <colomon> that makes it sound more like it might be my fault.  :(

[13:57] * moritz_ pulls and re-tests

[13:57] *** justatheory left
[13:58] <bbkr> hmm, why this example: "'class X {}; my $x = X; for 1..10000000 { if $_ % 2 {$x .= HOW} else {$x .= WHAT}; }'" is eating the memory? if I call CLASS.HOW.WHAT.HOW.WHAT.HOW.WHAT... it should be constant amount of memory used, because WHAT and HOW methods return the same objects, isn't it?

[13:59] <moritz_> bbkr: even if not, it shouldn't leak memory,because no references to the original objects are being kept

[14:00] <bbkr> should i fill rakudobug?

[14:00] <moritz_> so either something is keeping references internally, or parrot's GC is too lazy

[14:00] <moritz_> bbkr: yes, please

[14:00] <colomon> no

[14:00] <colomon> it's happening because for eagerly gets the list to process on.

[14:01] <colomon> so it tries to build the 10000000 item list before it starts the loop.

[14:01] <moritz_> oh

[14:01] <moritz_> and for can't be lazy until we have sink context, right?

[14:02] <colomon> That's a separate issue, I think.

[14:02] <colomon> (But then, I admit I don't understand the implementation.)

[14:02] <moritz_> colomon: with your latest changes, test 20 of precedence.t fails

[14:02] <colomon> moritz_: yeah, that's what I've been seeing too.

[14:02] <moritz_> nqp: fail('foo')

[14:02] <p6eval> nqp: OUTPUT¬´Could not find non-existent sub fail‚ê§current instr.: '_block11' pc 0 (EVAL_1:5)‚ê§¬ª

[14:02] <moritz_> nqp: fail 'foo'

[14:02] <p6eval> nqp: OUTPUT¬´Confused at line 1, near "fail 'foo'"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[14:03] <colomon> can the brain trust take a look at that one?  I don't have a clue, but it must have happened in one of the last two commits....

[14:04] <bbkr> colomon: you're right. it used memory for building list;

[14:05] <colomon> as for "for", "map" lets you lazily evaluate its inputs but still eagerly evaluate its results.  I don't know why "for" should be any different.  But pmichaud actually changed it so "for" eagerly evaluated its inputs, and I'm sure he must have had a good reason.

[14:05] *** dalek left
[14:05] <colomon> afk # loading boxes of books into the minivan...

[14:12] *** dalek joined
[14:14] <colomon> why no t/spec/S03-metaops/cross.t?

[14:14] <masak> std: 64 R... 1, 2, 4

[14:15] <p6eval> std 30156: OUTPUT¬´ok 00:01 108m‚ê§¬ª

[14:15] <colomon> rakudo: say 64 R... 1, 2, 4

[14:15] <p6eval> rakudo 6a8049: OUTPUT¬´1248163264‚ê§¬ª

[14:15] <masak> \o/

[14:16] <jnthn> masak: You should give your Russian vodka. That'll make everything just fine.

[14:16] <jnthn> masak: Apparently it increases fluency.

[14:16] <jnthn> ;-)

[14:17] <jnthn> Or at least percieved fluency.

[14:17] <masak> I've actually felt my fluency increase from alcohol.

[14:17] <masak> in that particular case, it was Mandarin.

[14:18] <jnthn> I'm still trying to work out if it's just perception or if it really actually helps.

[14:18] <arnsholt> I agree. A bit of alcohol does help you loosen up a bit, I think

[14:18] *** Su-Shee left
[14:18] <jnthn> It may just be that you fear getting it a tad wrong less.

[14:19] <jnthn> And Just Say Stuff. And it's mostly good enough.

[14:19] <arnsholt> Without any actual empirical basis, I think it's related to the loss of inhibition that comes with alcohol

[14:19] <masak> jnthn: yeah.

[14:19] <jnthn> Of course, I guess this only works up to a point.

[14:19] <jnthn> :-)

[14:19] <arnsholt> Yeah, eventually the loss of brain catches up with you =)

[14:19] <masak> aye. inhibition is a necessary part of communication to some extent. :)

[14:21] <colomon> I've heard trad musicians say the same thing about drink increasing fluency...

[14:21] <masak> aww, I missed tonight's troll. :/

[14:21] <masak> who would have thought that a person called 'necrocow' would be so hostile? :P

[14:22] <jnthn> masak: Maybe you'll get to C him again.

[14:22] <masak> apparently he was very familiar with what '*plonk*' means, at least. I wasn't.

[14:22] <masak> jnthn: :)

[14:23] <masak> necrocow! come back and tell us more about compilers! :)

[14:23] <pugssvn> r30157 | colomon++ | Move cross.t to S03-metaops too. 

[14:23] <colomon> Yes, and he can spend more time telling TimToady how Perl 5 works.

[14:23] <jnthn> Clearly writing compilers in a language that we can all be more productive in is the wrong way to do it.

[14:24] <jnthn> :-)

[14:25] <arnsholt> The troll is always right, you know =)

[14:26] <colomon> masak: as for knowing what *plonk* means, apparently you don't spend much time behaving in a fashion to get yourself kicked out of chats...

[14:27] <jnthn> lol...searching Google for "plonk irc" to try and get insight is amusing.

[14:29] <arnsholt> nqp: my @a = (); say @a.WHAT;

[14:29] <p6eval> nqp: OUTPUT¬´Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " (); say @"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[14:29] <arnsholt> nqp: my @a := (); say @a.WHAT;

[14:29] <p6eval> nqp: OUTPUT¬´Confused at line 1, near "say @a.WHA"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[14:30] <jnthn> no listops, use parens with say

[14:30] <arnsholt> nqp: my @a := (); say(@a.WHAT);

[14:30] <p6eval> nqp: OUTPUT¬´Method 'WHAT' not found for invocant of class 'ResizablePMCArray'‚ê§current instr.: '_block11' pc 0 (EVAL_1:6)‚ê§¬ª

[14:31] <arnsholt> Not what I intended, but it did tell me what I wanted ^^

[14:31] <masak> colomon: no, to be honest I haven't (and wouldn't consider trying). I guess I used to be more of a groupie on #perl6, before I found my slots of productivity. but never outright maladjusted.

[14:32] <arnsholt> nqp: my @a := (); @a.push(1); say(@a);

[14:32] <p6eval> nqp: OUTPUT¬´1‚ê§¬ª

[14:32] <arnsholt> nqp: my @a := (); @a.push: 1; say(@a);

[14:32] <p6eval> nqp: OUTPUT¬´1‚ê§¬ª

[14:36] *** mdxi_ joined
[14:36] <arnsholt> nqp: my @a; sub b($x) { @a.push: $x; }; sub a() { @a := (); b("foo"); say(@a); }

[14:36] <p6eval> nqp:  ( no output )

[14:36] <arnsholt> nqp: my @a; sub b($x) { @a.push: $x; }; sub a() { @a := (); b("foo"); say(@a); } a();

[14:36] <p6eval> nqp: OUTPUT¬´Confused at line 1, near "sub a() { "‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[14:36] <arnsholt> nqp: my @a; sub b($x) { @a.push: $x; }; sub a() { @a := (); b("foo"); say(@a); }; a();

[14:36] <p6eval> nqp: OUTPUT¬´1‚ê§¬ª

[14:36] <arnsholt> nqp: my @a := (); @a.push: 1; @a.push: 2; say(@a);

[14:36] <p6eval> nqp: OUTPUT¬´2‚ê§¬ª

[14:39] <mathw> Hello

[14:39] <arnsholt> nqp: my @a; sub b($x) { @a.push: $x; }; sub a() { @a := (); b("foo"); }; a(); say(@a);

[14:39] <p6eval> nqp: OUTPUT¬´1‚ê§¬ª

[14:39] <masak> mathw!

[14:39] <mathw> masak!

[14:39] <colomon> o/

[14:40] *** christine joined
[14:40] <mathw> guess what masak

[14:40] <mathw> I still can't use the Esperanto direct object properly

[14:41] <masak> mathw: it's only been, what, a month or two?

[14:41] <mathw> true

[14:41] <masak> are you expecting a miracle? :P

[14:41] <mathw> not really

[14:41] <arnsholt> nqp: my @a := (); @a.push: 1; @a.push: 2; say(|@a);

[14:41] <p6eval> nqp: OUTPUT¬´12‚ê§¬ª

[14:41] <mathw> I just get embarrassed when I forget to even think abou tit

[14:41] <masak> that's the only really heavy point of Esperanto grammar. it takes time.

[14:42] <masak> trust me, in seven-eight years it'll be second nature to you :P

[14:42] <mathw> hopefully

[14:42] *** wknight8111 left
[14:42] <mathw> how are my named enums coming along? :)

[14:43] <masak> mathw: I'm free this afternoon, wanna help me finish them up? :)

[14:43] <mathw> I'd love to

[14:43] <masak> \o/

[14:43] <mathw> although I'm not sure if you can expect much in the way of 'help'

[14:43] * masak pushes the branch of the progress so far

[14:43] * jnthn is around to offer moral (and if needed technical) support for named enums too :-)

[14:43] <mathw> \o/

[14:44] <masak> hold on, gotta rebase and stuff.

[14:44] <colomon> come on, spectest, faster, faster!

[14:45] <masak> mathw: http://github.com/rakudo/rakudo/tree/named-enums

[14:45] <mathw> ooh fancy you

[14:45] <mathw> a branch in rakudo's own repo :P

[14:45] <masak> mathw: pull that and build, and then try something like 'enum A <b c d>'

[14:46] <masak> mathw: it's only for today, until we make this work :)

[14:46] * mathw builds

[14:46] * masak too

[14:47] *** dalek left
[14:50] *** dalek joined
[14:53] <mathw> masak: it accepts "enum A <b c d>" but not anything I might try to do with it after that

[14:54] <mathw> which bits of code are we going to be concerned with

[14:54] <masak> what's the error message?

[14:54] <mathw> ./perl6 -e "enum A <b c d>; say A::b.WHAT;"

[14:54] <mathw> Null PMC access in invoke()

[14:54] <mathw> current instr.: '_block14' pc 29 (EVAL_1:0)

[14:54] <mathw> called from Sub '!UNIT_START' pc 1299 (src/glue/run.pir:23)

[14:54] <mathw> called from Sub 'perl6;PCT;HLLCompiler;eval' pc -1 ((unknown file):-1)

[14:54] <dalek> rakudo: a61c40c | (Solomon Foster)++ | src/Perl6/Actions.pm:

[14:54] <dalek> rakudo: infix_prefix_meta_operator refactor!

[14:54] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a61c40cda94ba2bffc47c490e2157660686ce237

[14:54] <mathw> called from Sub 'perl6;PCT;HLLCompiler;command_line' pc 1489 (compilers/pct/src/PCT/HLLCompiler.pir:794)

[14:54] <mathw> called from Sub 'perl6;Perl6;Compiler;main' pc -1 ((unknown file):-1)

[14:55] <masak> hm.

[14:55] <masak> my build isn't finished quite yet.

[14:55] <masak> but take a look at the partial commit with 'git show' in the meantime.

[14:55] *** am0c joined
[14:56] * jnthn files NPMCA Rakudo bug

[14:56] <jnthn> oh, wait..

[14:56] <jnthn> :-)

[14:56] <moritz_> did you mean: masakbug? :-)

[14:56] <arnsholt> nqp: my @paths; sub choose(*@x) { my $v := @x.shift; @paths.push: "dummy"; return $v; }; sub blob() { say(choose("a", "b", "c")); }; blob();

[14:56] <p6eval> nqp: OUTPUT¬´a‚ê§¬ª

[14:56] <arnsholt> ARG!

[14:56] <masak> aaah. the Rakudo build ran much smoother after I killed Firefox :)

[14:57] <masak> I thought that might be it.

[14:57] <mathw> masak: my git-fu fails at this task

[14:57] <jnthn> masak: Yeah, it sucks how firefox gets like that when you have 5 or 6 tabs open. ;-0

[14:57] <masak> mathw: just typing 'git show' should be enough.

[14:58] <masak> jnthn: no, that's my two other browsers. :)

[14:58] <mathw> no, git show declares that I merged branch 'master'

[14:58] <moritz_> git show HEAD~2 # try this one

[14:59] <masak> mathw: oh, did you pull the named-enums branch into master? :/

[14:59] <mathw> I didn't try to

[14:59] <mathw> I don't grok git branching, really

[14:59] <masak> I know the feeling.

[14:59] <mathw> but my git thinks I'm on that branch

[15:00] <masak> it's ok. you'll probably need to back out somehow when you decide you're done with this experiment. but that's all.

[15:00] <masak> perhaps a 'git pull --force origin master' will be enough.

[15:01] <mathw> bah

[15:01] * mathw starts again

[15:01] <mathw> I really need to learn how to use git properly one day

[15:02] <jnthn> Same :)

[15:02] <jnthn> With time, I see to screw it up less though. :-)

[15:03] *** tylerni7 joined
[15:03] <masak> mathw: starting again would be 'git checkout -b named-enums origin/named-enums'.

[15:04] <mathw> Why is it that I only ever seem to have one USB cable?

[15:04] <mathw> Almost every gadget I own came with one

[15:04] <mathw> yet I can find only one

[15:05] <mathw> back shortly...

[15:10] <colomon> 28401 passing tests here, BTW.

[15:11] <moritz_> wow

[15:12] <masak> \o/

[15:14] * jnthn tries to remember what the peak was with alpha

[15:14] <moritz_> 35k?

[15:17] <pugssvn> r30158 | moritz++ | [t/spec] now that complex and Rat literals are gone, remove them from S02-literals/numeric.t; this makes the test file rather pointless, but maybe some brave sould will add tests for <2+3i> or so in future 

[15:18] <m6locks> rat is gone?

[15:18] <m6locks> i just switched all my nums to rat :D

[15:19] <m6locks> oh well

[15:20] <jnthn> m6locks: No, not in that sense.

[15:20] <masak> mathw: I'll be back in a while too. need to pull the ethernet cord while Firefox boots back up.

[15:20] <jnthn> moritz_: I don't think we were passing 35k?

[15:20] *** masak left
[15:21] <colomon> m6locks: it used to be that, say 3 / 4 was processed as one number by the grammar.

[15:21] <moritz_> actually only 3/4 (without the spaces)

[15:21] <colomon> m6locks: now it's just the integer 3 divided by the integer 4, which creates the Rat.

[15:21] <m6locks> oh ok

[15:21] <moritz_> so 1/2 ** 4 was parsed as (1/2) ** 4, not as 1/(2**4)

[15:21] <colomon> and 1/7/7/7/7 was just a nightmare.

[15:22] <moritz_> jnthn: you're right, it was only 32.7k :-)

[15:22] <m6locks> rakudo: say (5.42).WHAT

[15:22] <p6eval> rakudo a61c40: OUTPUT¬´Rat()‚ê§¬ª

[15:22] <colomon> no way, we've got 7/8ths of the tests back now?!

[15:22] <jnthn> 4.3k-ish to go then.

[15:22] <jnthn> We've still got a bunch of S05-mass/*.t

[15:24] <moritz_> hash slices

[15:25] <jnthn> Oh. Those.

[15:25] <jnthn> Yes.

[15:26] <mathw> \o/

[15:26] * mathw has masak's partial commit, but no masak

[15:26] <moritz_> currently I'm inclined to remove the fatal 'Use of type object as a value' in the vtables in Mu

[15:27] <jnthn> moritz_: Maybe it should be demoted to a warning.

[15:27] <moritz_> IMHO failing hard on something that's supposed to fail softly is wronger than not failing at all

[15:29] <arnsholt> nqp: say("{3}".WHAT)

[15:29] <p6eval> nqp: OUTPUT¬´Method 'WHAT' not found for invocant of class 'String'‚ê§current instr.: '_block11' pc 0 (EVAL_1:6)‚ê§¬ª

[15:29] <moritz_> jnthn: warning is good, yes

[15:31] *** wallberg joined
[15:31] <jnthn> arnsholt: don't expect NQP to handle .WHAT too well in general.

[15:38] *** masak joined
[15:39] <masak> mathw: back again :)

[15:39] <masak> mathw: while I was offline, I did some further experiments with the patch.

[15:39] <mathw> ahah

[15:39] <mathw> well I've got the thing up on my screen now

[15:39] <mathw> although it's still tryin gto compile it :)

[15:40] <masak> mathw: have a look at src/glue/enumeration.pm

[15:40] <masak> there's a sub there with a few things commented out.

[15:40] <masak> that's the one we want to get right for named enums to work.

[15:40] <masak> jnthn++ for all the help so far.

[15:41] <mathw> I've got a sub with one line commented out...

[15:41] <masak> ok.

[15:42] <masak> I put a 'say' statement at the top, and it actually gets called.

[15:43] <masak> right now I'm rebuilding with an added argument: the scope in which the enum is to be installed.

[15:43] <masak> it's in that area that my knowledge is a bit weak.

[15:44] <mathw> hmm

[15:44] <mathw> my build's blowing up now

[15:44] <masak> apparently, the thing to send in on the Actions side is PAST::Op.new( :pirop('get_namespace P') )

[15:44] <mathw> ah I know why

[15:45] <arnsholt> I think I'm trying to be to clever for my own good ^^

[15:46] <masak> jnthn: it's now a fact. the PAST::Op.new( :pirop('get_namespace P') ) argument is the one that causes the CREATE_NAMED_ENUMERATION to blow up. :/

[15:46] <arnsholt> jnthn: Yeah, I sort of guessed. But it does give me the type of the object, even if it's not quite what it's supposed to do =)

[15:46] <jnthn> masak: What do you do with it? :-)

[15:46] <jnthn> Or is it merely passing it that causes that?

[15:46] <masak> jnthn: the latter.

[15:47] <mathw> oooh dear

[15:47] <mathw> core dump on build

[15:47] <jnthn> What's the signature?

[15:47] <masak> jnthn: want me to push a state where it blows up?

[15:48] <jnthn> Can do

[15:48] <masak> jnthn: http://github.com/rakudo/rakudo/commit/d2668266e3449135bf02e3f4e91f9b27bc0023f2

[15:49] <arnsholt> nqp: my $s := sub { return "foo" }; my $a := $s(); say $a;

[15:49] <p6eval> nqp: OUTPUT¬´Routine declaration requires a signature at line 1, near "{ return \""‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[15:50] <arnsholt> nqp: my $s := sub() { return "foo" }; my $a := $s(); say $a;

[15:50] <p6eval> nqp: OUTPUT¬´Confused at line 1, near "say $a;"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[15:50] <arnsholt> nqp: my $s := -> { return "foo" }; my $a := $s(); say $a;

[15:50] <p6eval> nqp: OUTPUT¬´Missing block at line 1, near "-> { retur"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[15:50] <arnsholt> nqp: my $s := -> { return "foo"; }; my $a := $s(); say $a;

[15:50] <p6eval> nqp: OUTPUT¬´Missing block at line 1, near "-> { retur"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[15:51] <arnsholt> nqp: my $s := -> $x { return "x: " ~ $x; }; my $a := $s("foo"); say $a;

[15:51] <p6eval> nqp: OUTPUT¬´Confused at line 1, near "say $a;"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)‚ê§¬ª

[15:51] <arnsholt> nqp: my $s := -> $x { return "x: " ~ $x; }; my $a := $s("foo"); say($a);

[15:51] <p6eval> nqp: OUTPUT¬´No exception handler and no message‚ê§current instr.: '_block15' pc 51 (EVAL_1:0)‚ê§¬ª

[15:52] <arnsholt> Anyone more experienced than me have any suggestions on how to do this?

[15:52] <masak> arnsholt: in Perl 6, that's actually correct.

[15:52] <arnsholt> That's good at least

[15:53] <masak> arnsholt: a pointy block isn't "advanced" enough to return from.

[15:53] <masak> only subs, methods and submethods are.

[15:54] <arnsholt> nqp: my $s := -> $x { say("Alive: " ~ $x); }; $s("foo"); say("Alive");

[15:54] <p6eval> nqp: OUTPUT¬´Alive: foo‚ê§Alive‚ê§¬ª

[15:54] <arnsholt> nqp: my $s := -> $x { say("Alive: " ~ $x); }; my $a := $s("foo"); say("Alive: " ~ $a);

[15:54] <p6eval> nqp: OUTPUT¬´Alive: foo‚ê§Alive: 1‚ê§¬ª

[15:54] <arnsholt> masak: Thanks!

[15:54] <masak> no problem. :)

[15:55] <arnsholt> I don't really need the return value, but I do need an anonymous sub and then invoke it

[15:55] <mathw> okay, I think I'm finally in roughly the same place as masak

[15:55] <masak> jnthn: any thoughts?

[15:55] <arnsholt> Hang on, I may actually want a return value

[15:55] <mathw> arnsholt: use sub {} then

[15:55] <masak> arnsholt: 'return value' and 'returning early' are different things.

[15:56] <arnsholt> Oooooh, right

[15:56] <arnsholt> nqp: my $s := -> $x { say("Alive: " ~ $x); undef }; my $a := $s("foo"); say("Alive: " ~ $a);

[15:56] <p6eval> nqp: OUTPUT¬´Alive: foo‚ê§Null PMC access in get_string()‚ê§current instr.: '_block11' pc 0 (EVAL_1:5)‚ê§¬ª

[15:56] <mathw> yes, pointy blocks can't catch return exceptions, but subs can

[15:56] <masak> nqpbug! :)

[15:57] <arnsholt> I think I'll go with a sub (if I can get it to work), as I'm gonna stick some inline PIR and stuff in there as well

[15:57] <jnthn> masak: You're taking it as a scalar which should be fine...

[15:57] <masak> jnthn: this is where I got stuck during the hackathon. it looks like it should work.

[15:57] <masak> and we want to do something very much like this.

[15:57] <jnthn> Aye.

[15:58] <arnsholt> nqp: my $s := sub () { say "Hello!"; return "pong"; }; my $a := $s(); say($a);

[15:58] <p6eval> nqp: OUTPUT¬´Unable to parse blockoid, couldn't find final '}' at line 1‚ê§current instr.: 'parrot;Regex;Cursor;FAILGOAL' pc 1664 (src/Regex/Cursor-builtins.pir:179)‚ê§¬ª

[15:58] <jnthn> masak: I'm curious what it's trying to invoke.

[15:59] <masak> yeah. no idea.

[15:59] <masak> possibly the sub itself, but then again maybe not.

[16:00] <jnthn> Yeah, put passing an extra param shouldn't make the sub unfindable...

[16:00] <jnthn> *but

[16:00] <arnsholt> nqp: my $s := sub($x) { say "Hello!"; return "pong"; }; my $a := $s(); say($a);

[16:00] <p6eval> nqp: OUTPUT¬´Unable to parse blockoid, couldn't find final '}' at line 1‚ê§current instr.: 'parrot;Regex;Cursor;FAILGOAL' pc 1664 (src/Regex/Cursor-builtins.pir:179)‚ê§¬ª

[16:00] <jnthn> masak: Maybe I should grab the branch...

[16:00] *** dual left
[16:00] <masak> jnthn: I think we'll need the help, to be honest... :)

[16:01] <mathw> I have simply no idea

[16:01] <mathw> at the moment I get this

[16:01] <mathw> ./perl6 -e "enum A <a b c d>"

[16:01] <mathw> Not enough positional parameters passed; got 2 but expected 3

[16:01] <mathw> current instr.: 'CREATE_NAMED_ENUMERATION' pc 307701 (src/gen/core.pir:20547)

[16:01] <arnsholt> Bah. I don't think NQP likes me

[16:01] <masak> mathw: aye, me too.

[16:01] <mathw> thus, your last commit is an attempt to get that third paramet

[16:01] <mathw> +er

[16:01] <arnsholt> nqp: my $s := sub foo($x) { say "Hello!"; return "pong"; }; my $a := $s(); say($a);

[16:01] <p6eval> nqp: OUTPUT¬´Unable to parse blockoid, couldn't find final '}' at line 1‚ê§current instr.: 'parrot;Regex;Cursor;FAILGOAL' pc 1664 (src/Regex/Cursor-builtins.pir:179)‚ê§¬ª

[16:02] <masak> it's also a bit mystifying that it worked previously, when we only had two arguments and still three parameters.

[16:02] <masak> I mean, when we did that, the sub got successfully called.

[16:03] <masak> right now, I'm trying to add a fourth parameter to see if three arguments can call that sub :)

[16:04] <mathw> I'm trying to comprehend what's going on in that action method

[16:04] <arnsholt> nqp: my $s := sub foo ( ) { say "Hello!"; return "pong"; }; my $a := $s(); say($a);

[16:04] <p6eval> nqp: OUTPUT¬´Unable to parse blockoid, couldn't find final '}' at line 1‚ê§current instr.: 'parrot;Regex;Cursor;FAILGOAL' pc 1664 (src/Regex/Cursor-builtins.pir:179)‚ê§¬ª

[16:04] <masak> mathw: maybe I can help with that.

[16:04] <masak> mathw: the outermost 'if' checks if we got a name when parsing.

[16:05] <masak> mathw: the 'else' clause of that 'if' actually works :)

[16:05] <masak> mathw: (and it just calls a sub that returns an EnumMap)

[16:05] *** iblechbot left
[16:05] <mathw> I assume something else knows what to do with that

[16:05] <masak> mathw: well, it's a real Perl 6 object.

[16:06] <jnthn> nqp: my $s := sub foo ( ) { say("Hello!"); return "pong"; }; my $a := $s(); say($a);

[16:06] <p6eval> nqp: OUTPUT¬´Hello!‚ê§pong‚ê§¬ª

[16:06] <jnthn> arnsholt: ^

[16:06] <masak> rakudo: say (enum <a b c d>).values.perl

[16:06] <p6eval> rakudo a61c40: OUTPUT¬´MapIterator.new()‚ê§¬ª

[16:06] <masak> (grrr)

[16:06] <masak> rakudo: say (enum <a b c d>).values

[16:06] <p6eval> rakudo a61c40: OUTPUT¬´0123‚ê§¬ª

[16:06] <masak> rakudo: say (enum <a b c d>).keys

[16:06] <p6eval> rakudo a61c40: OUTPUT¬´abcd‚ê§¬ª

[16:06] <arnsholt> jnthn: Duh. Parens around the say >.<

[16:06] <masak> rakudo: say (enum <a b c d>).WHAT

[16:06] <p6eval> rakudo a61c40: OUTPUT¬´EnumMap()‚ê§¬ª

[16:06] <mathw> ah of course

[16:06] <jnthn> rakudo: say (enum <a b c d>).kv

[16:06] <p6eval> rakudo a61c40: OUTPUT¬´d3a0b1c2‚ê§¬ª

[16:06] <mathw> so what's the named enum maker trying to do

[16:07] <mathw> it does some dancing around to get the EnumMap

[16:07] <mathw> which I don't really understand

[16:07] <masak> mathw: right. it starts by getting the EnumMap to get the names of the keys.

[16:07] <masak> mathw: then it does something to add those keys to a namespace, like A::a, A::b, etc.

[16:08] <jnthn> moritz_: If you're able to build Parrot with ICU, you may find that some of the S05-mass/*.t actually work.

[16:08] <masak> mathw: finally, it installs a piece of code to be executed at loading of the script.

[16:08] <jnthn> moritz_: I think pmichaud++ did add back \c[...]

[16:08] <masak> mathw: that's the call to CREATE_NAMED_ENUMERATION. that's the one that's failing right now, in some way.

[16:08] *** rv2733 left
[16:09] <mathw> I don't understand where @BLOCK comes from

[16:10] <masak> mathw: note the 'our @BLOCK'.

[16:10] <masak> mathw: that means it's defined elsewhere and we simply get access to it from this method.

[16:10] <mathw> yes, I know that

[16:11] <mathw> but what is it

[16:11] <masak> no idea. :)

[16:11] <masak> it's defined at the top of Actions.pm.

[16:11] <masak> I guess it holds all the blocks that are eventually serialized to PIR.

[16:11] <masak> or something.

[16:12] <jnthn> masak: building

[16:13] <masak> nope, the combination of three arguments and four parameters didn't help :)

[16:13] <masak> so everything points to PAST::Op.new( :pirop('get_namespace P') ) causing the error in some way.

[16:14] *** pmurias joined
[16:14] <mathw> what is get_namespace P intended to do?

[16:15] <masak> get the current namespace, the one we want to install A into.

[16:15] <Trashlord> hey guys

[16:16] <masak> Trashlord: hi! o/

[16:16] <pmurias> hi

[16:16] <Trashlord> how's it going?

[16:16] <mathw> I'll let jnthn worry about if that's right

[16:17] <masak> Trashlord: we're trying to get named enums working :)

[16:17] * mathw examines CREATE_NAMED_ENUMERATION

[16:17] <Trashlord> ahg

[16:17] <Trashlord> -g

[16:17] <mathw> so you pass the name of the enum, the EnumMap and the scope to install it into

[16:17] <masak> Trashlord: no, it's really more 'ahg' right now :P

[16:17] <mathw> however that is eventually achieved :)

[16:18] <Trashlord> haha

[16:18] <masak> mathw: it seems that installing is achieved through hash accesses.

[16:18] <mathw> then you go over each value, mix EnumMixin into it

[16:18] <masak> which is very nice. a namespace is a bit like a Hash.

[16:18] <mathw> which is an empty role

[16:18] <mathw> or is possibly defined elsewhere

[16:18] <masak> no, it's defined above.

[16:18] <masak> and it's empty right now.

[16:18] <masak> (because I wanted to get this to work first)

[16:19] <mathw> then you stick it into the outer scope under the key name

[16:19] <mathw> or, when it's not commented out and wrong, that is

[16:19] <masak> nod.

[16:19] <mathw> and then you install the enumeration itself

[16:19] <mathw> and presumably that class will also be filled out

[16:19] <masak> aye.

[16:20] <mathw> what needs to go in those

[16:20] <masak> I'm not 100% sure yet.

[16:20] <masak> but S12 goes into enough detail.

[16:20] <masak> std: Enumeration

[16:21] <p6eval> std 30158: OUTPUT¬´Undeclared name:‚ê§      'Enumeration' used at line 1‚ê§ok 00:01 107m‚ê§¬ª

[16:22] <lue> ohai masak, mathw, Trashlord, and friends o/

[16:23] <masak> lue: \o

[16:23] <lue> Now to fix the adverb form of base conversion :)

[16:23] <Trashlord> sup

[16:23] <masak> lue: planning to attack RT again today? I liked the way you found a closeable yesterday :)

[16:23] <lue> masak: did you see my stupendous results with the radcalc function?

[16:24] <masak> lue: no, I must have missed that.

[16:24] <lue> I will, in addition to fixing the :16<> type base conversions. (when I has permissions to close bugs that is...)

[16:26] <masak> lue: until you have permission, just task someone who does with closing the ticket. they'll often happily oblige :)

[16:26] *** hercynium left
[16:27] <lue> Alright (still trying to find the failure in the adverbs...)

[16:28] *** Psyche^ joined
[16:28] * mathw is reading S12 and getting an idea of what needs to go in EnumMixin

[16:29] <mathw> although I need to check on what the anon enum creator's doing

[16:30] <masak> mathw: it's in src/glue/enum.pir. it just builds an EnumMap.

[16:30] *** Patterner left
[16:30] *** Psyche^ is now known as Patterner

[16:30] <lue> what do $< [name here] > mean/do (including the angle brackets) ?

[16:31] <mathw> rakudo: my $e = enum <a b c>; a.WHAT.say;

[16:31] <p6eval> rakudo a61c40: OUTPUT¬´Could not find non-existent sub &a‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[16:31] <masak> lue: it's short for $/< [name here] >

[16:31] <mathw> doh

[16:31] <masak> lue: that's a hash lookup into $/.

[16:31] <mathw> wake up

[16:31] <masak> mathw: right. an anon enum doesn't install anything.

[16:31] <masak> mathw: it's literally just an EnumMap object.

[16:32] <mathw> yeah

[16:32] <mathw> anyway, what I'm thinking about is, once things do install

[16:32] <mathw> S12 says that if you define an enum Day <Mon Tue> etc, then Mon.WHAT should say 'Day'

[16:32] <jnthn> back, sorry

[16:32] <jnthn> phone

[16:33] <masak> jnthn: it's ok. we held back all brilliant ideas for how to solve this until you were back. :P

[16:33] <lue> And what does $/ hold, I wonder...

[16:33] <mathw> lue: the current match object

[16:34] <jnthn> masak: Hmm. It makes it to CREATE_NAMED_ENUMERATION but may be dying in signature binding. :-/

[16:34] <masak> lue: may I recommend S05 as reading at this point?

[16:34] <masak> jnthn: sounds very reasonable.

[16:34] <jnthn> rakudo: pir::get_namespace__P()

[16:34] <p6eval> rakudo a61c40:  ( no output )

[16:34] <jnthn> rakudo: my $x = pir::get_namespace__P(); say $x;

[16:34] <p6eval> rakudo a61c40: OUTPUT¬´perl6‚ê§¬ª

[16:34] <lue> (I broke radcalc in coding radcalc I believe, back to look (stupid PIR...)) :)

[16:34] <jnthn> rakudo: my $x = pir::get_namespace__P(); say $x<IO>;

[16:34] <p6eval> rakudo a61c40: OUTPUT¬´2‚ê§¬ª

[16:36] <jnthn> rakudo: my $x = pir::get_namespace__P(); $x<&lol> = sub { say "rofl" }; lol;

[16:36] <p6eval> rakudo a61c40: OUTPUT¬´Cannot assign to readonly value‚ê§current instr.: '&die' pc 17127 (src/builtins/Junction.pir:399)‚ê§¬ª

[16:36] <lue> rakudo: Q:PIR{if 1==1 and 2==2 goto win‚ê§say "boo"‚ê§win:‚ê§say "yay"}

[16:36] <p6eval> rakudo a61c40: OUTPUT¬´error:imcc:syntax error, unexpected PARROT_OP, expecting GOTO ('and')‚ê§     in file 'EVAL_1' line 64‚ê§boo‚ê§yay‚ê§¬ª

[16:36] <mathw> masak: what I'm thinking is that I don't think using a mixin role can achieve S12's semantics for the enum values

[16:36] <lue> sigh, I guess you can't do that either :/

[16:36] <mathw> err

[16:36] <mathw> keys

[16:36] <jnthn> rakudo: my $x = CREATE_HASH_LOW_LEVEL(pir::get_namespace__P()); $x<&lol> = sub { say "rofl" }; lol;

[16:36] <p6eval> rakudo a61c40: OUTPUT¬´Invalid namespace key in set_pmc_keyed‚ê§current instr.: 'perl6;Proxy;!STORE' pc 14414 (src/builtins/Associative.pir:22)‚ê§¬ª

[16:36] <masak> mathw: ok.

[16:36] <mathw> err

[16:36] <mathw> I've confused myself now

[16:37] *** yves joined
[16:37] <jnthn> rakudo: my $x = CREATE_HASH_LOW_LEVEL(pir::get_namespace__P()); say $x<IO>;

[16:37] <p6eval> rakudo a61c40: OUTPUT¬´2‚ê§¬ª

[16:37] <jnthn> rakudo: my $x = CREATE_HASH_LOW_LEVEL(pir::get_namespace__P()); say $x<lolnotexisting>;

[16:37] <p6eval> rakudo a61c40: OUTPUT¬´‚ê§¬ª

[16:37] <jnthn> Hmm.

[16:38] <mathw> masak: the thing that makes me think this is that enum Day <Mon>; Mon.What eq "Day"; Mon ~~ Int; Mon.perl eq "Day::Mon"; Mon.key eq "Mon";

[16:39] <mathw> I'm mostly just guessing, but I think it might be necessary to construct a new type at this point

[16:40] <jnthn> masak: Hmm. Treating Parrot namespaces as hashes is...not working out quite as I hoped it may.

[16:40] <masak> jnthn: what do you propose we do?

[16:41] <m6locks> rakudo: my @eSa = 1.08635005541779435134e02, 6.57024977031928170135e00;

[16:41] <p6eval> rakudo a61c40: OUTPUT¬´Multiple Dispatch: No suitable candidate found for 'multiply_float', with signature 'PNP->P'‚ê§current instr.: 'perl6;Perl6;Actions;_block6075' pc 227527 (src/gen/perl6-actions.pir:12321)‚ê§¬ª

[16:41] <jnthn> Burn an effigy of Parrot for not coping with subclasses of String, maybe.

[16:41] <lue> I know what I did rong :) [compiling...]

[16:41] <mathw> port Rakudo to the .NET DLR :P

[16:41] <m6locks> what's with that multiple dispatch

[16:41] <jnthn> mathw: Oh boy can I not wait to start on the .Net backend.

[16:41] <jnthn> mathw: But Rakudo * first.

[16:41] <TimToady> if parrot would just give us compact arrays of native ints, we could do the rest of strings ourselves

[16:42] <m6locks> i want my numbers accurate ;___;

[16:42] <mathw> TimToady: I loved your message on p6l.

[16:42] <jnthn> TimToady: Apart from the bit of code I just discovered...will only work if passed a *Parrot* string.

[16:42] <jnthn> *sigh*

[16:43] <jnthn> masak: This means that writing this stuff in Perl 6 is going to be...tricky...until I can work out some solution.

[16:43] <masak> jnthn: no wonder it felt tricky! :P

[16:43] <jnthn> masak: Sorry. :-(

[16:43] <jnthn> masak: I...didn't expect the NameSpace PMC to contain...this... :-/

[16:43] <masak> jnthn: don't be. it was my idea to try to implement named enums.

[16:43] <m6locks> rakudo: my @eSa = 108.635005541779435134, 6.57024977031928170135;

[16:43] <p6eval> rakudo a61c40: OUTPUT¬´PAST::Compiler can't compile node of type BigInt‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[16:44] <masak> jnthn: I still would really like to see us implement large parts of the enum spec for R*.

[16:44] <jnthn> masak: Me too.

[16:44] <jnthn> masak: I'm afraid you've just hit on something I'm actually going to have to think about though. :-(

[16:44] <masak> mathw: seems your best option for Form.pm in the short term is to do what I do: run off alpha for the time being.

[16:44] <jnthn> Rather than having an instant answer for.

[16:45] <masak> jnthn: it's ok.

[16:45] <jnthn> mathw: What bits of named enums are you using?

[16:45] <jnthn> mathw: Are you essentially just using them as constants?

[16:45] <mathw> jnthn: yes

[16:45] <jnthn> Or do you rely on .pick and all that fancy?

[16:46] <jnthn> masak: Maybe we could as a stop gap literally compile enums to something like:

[16:46] <jnthn> enum A <a b c>; => module A { constant a = 1; constant b = 2; constant c = 3; }

[16:46] <jnthn> Or some such

[16:46] <masak> jnthn: that would be better than nothing, methinks.

[16:46] <jnthn> Yeah

[16:47] <jnthn> Just build up a PAST tree that does it.

[16:47] <lue> colomon told me to run make [spectest file here] to run certain spectests :)

[16:47] * masak tries that

[16:47] <jnthn> It's Not Good and very temporary

[16:47] <colomon> alpha: my @a; say (1, 2, 3) >>+>> @a

[16:47] <jnthn> But it's better than nothing.

[16:47] <mathw> it would cover my use case :)

[16:47] <jnthn> And should unblock mathw++

[16:47] <lue> (for the record, this  is the only method that's worked for me)

[16:47] <masak> aye.

[16:47] <p6eval> alpha 30e0ed: OUTPUT¬´Use of uninitialized value‚ê§Use of uninitialized value‚ê§Use of uninitialized value‚ê§123‚ê§¬ª

[16:47] <jnthn> colomon: Wow!

[16:48] <colomon> that's alpha.

[16:48] <jnthn> colomon: Er. I think alpha had that wrong. ;-)

[16:48] <jnthn> Plz to doing better in alpha. :-)

[16:48] <colomon> what should it do, though?

[16:48] <jnthn> Oh, for empty?

[16:48] <jnthn> Oh hmm

[16:48] <colomon> (I've got the guts of hyper torn up at the moment...)

[16:48] <jnthn> There isn't a last element to use I guess. :-/

[16:49] * jnthn checks So3

[16:50] <lue> I guess I should add support for things like :10('0b1092') #despite it being marked todo in the spectest

[16:51] <jnthn> colomon: Hmm...I don't see a clear answer in the spectests akshually.

[16:51] <mathw> S03 is also fuzzy on it

[16:52] <mathw> it talks about too-short on the pointy end, not empty

[16:52] <jnthn> Yeah

[16:52] <jnthn> You can't duplicate a non-existent last element. :-)

[16:52] <mathw> and the too-short extension case is clearly nonapplicable to the empty list

[16:53] <mathw> thus I propose that this should cause the compiler to replace one work-related file on the user's computer with a lolcat

[16:53] <lue> rakudo: say :16<'0o10'> # should be 8

[16:53] <p6eval> rakudo a61c40: OUTPUT¬´Malformed radix number at line 11, near "<'0o10'> #"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[16:53] <jnthn> mathw: Well, if TimToady++ will spec it that way, wfm.

[16:53] <jnthn> ;-)

[16:54] <mathw> :P

[16:54] <jnthn> colomon: Maybe alpha's response isn't so insane after all in some senses, but we really only want such a warning once, if at all. :-)

[16:55] <masak> hm. if I do decide to go to NPW on Iceland, I'll submit a talk and call it "Perl 6: Prince of Parsia" :)

[16:55] <jnthn> oh my.

[16:55] <masak> or, 'Parsea", p'haps.

[16:55] <masak> then I can lecture with a towel wound around my head! :D

[16:56] <mathw> \o/

[16:56] <mathw> man

[16:56] <jnthn> :-D

[16:56] <mathw> I wonder if I can get a grant to go, on the grounds that missing such a sight would be the end of my ability to enjoy life

[16:57] * mathw writes to the NHS

[16:57] <masak> mathw: there'll probably be photos...

[16:57] *** diakopter joined
[16:57] <jnthn> probably. ;-)

[16:57] <mathw> masak: but I have to see it in 3D super-HD with a free-roaming viewpoint

[16:57] <lue> mathw: Try the IMU. They were able to swindle some cash with Hypercalculus, last I hear.

[16:58] *** Lorn_ left
[17:00] *** dual joined
[17:03] * lue working on RT while figuring out how to complete the radcalc function

[17:03] <lue> rakudo: sub x{};sub x{1};say x

[17:03] <p6eval> rakudo a61c40: OUTPUT¬´Null PMC access in type()‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[17:04] <lue> rakudo: sub x{};sub x{1};say x; say "It didn't die, just warned us!"

[17:04] <p6eval> rakudo a61c40: OUTPUT¬´Null PMC access in type()‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[17:04] <lue> rakudo: class A { my $.x = 7; say $.x }

[17:04] <p6eval> rakudo a61c40: OUTPUT¬´Lexical 'self' not found‚ê§current instr.: 'perl6;A;_block45' pc 303 (EVAL_1:136)‚ê§¬ª

[17:06] <lue> hey, it doesn't cause a parrot segfault anymore (it seems), so would #57882 be considered closed?

[17:06] * masak looks

[17:07] <colomon> > say (1..5) >>+>> 1

[17:07] <colomon> 23456

[17:07] <colomon> > say (1..5) >>+>> (1,2)

[17:07] <colomon> 24567

[17:07] *** Maddingu1 joined
[17:08] <masak> lue: seems the segfault is only half of it.

[17:08] <masak> lue: I don't remember if this was ever discussed on p6l, and if so what the conclusion was.

[17:08] * masak tries to dig up a p6l thread

[17:08] <lue> alright, just checking (due to my sometimes very literal nature. The bug sent in was a segfault, not a failure in general. :) )

[17:08] <moritz_> if it was discussed on p6l, there was likely no conclusion :-)

[17:09] <lue> Would it be wise for me to join p6l? #prediction: yes

[17:09] * moritz_ doesn't feel wise enough to assess wisdom

[17:10] <moritz_> std: /<foo::bar>/

[17:10] <p6eval> std 30158: OUTPUT¬´ok 00:01 108m‚ê§¬ª

[17:11] <moritz_> rakudo doesn't parse this => lots of fallout in regex tests

[17:11] <moritz_> lots of other regex tests blow up because rakudo doesn't allow named regexes outside a grammar

[17:12] <masak> lue: here: http://www.mail-archive.com/perl6-language@perl.org/msg29047.html

[17:12] <masak> lue: would also be interesting to hear what jnthn has to say about it.

[17:12] <colomon> rakudo: say &infix:<+>()

[17:12] <p6eval> rakudo a61c40: OUTPUT¬´No applicable candidates found to dispatch to for 'infix:<+>'. Available candidates are:‚ê§:(!whatever_dispatch_helper , !whatever_dispatch_helper )‚ê§:(Int $a, Int $b)‚ê§:(Rat $a, Rat $b)‚ê§:(Rat $a, Int $b)‚ê§:(Int $a, Rat $b)‚ê§:(Complex $a, Complex $b)‚ê§:(!whatever_dispatch_helper ,

[17:12] <p6eval> ..Any $rh‚Ä¶

[17:13] <moritz_> colomon: we need those for [+] of 0-item list, right?

[17:14] <lue> rakudo: jnthn.say(jnthn.thoughts)

[17:14] <p6eval> rakudo a61c40: OUTPUT¬´Could not find non-existent sub &jnthn‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[17:14] <colomon> moritz_: right

[17:15] <lue> I'll leave it open then :)

[17:17] *** p6eval left
[17:17] *** p6eval joined
[17:18] <diakopter> perlito: say 'O HAI'

[17:18] <p6eval> perlito: OUTPUT¬´O HAI‚ê§¬ª

[17:19] <diakopter> (it's the perl5 backend)

[17:19] <masak> \o/

[17:19] <masak> diakopter++

[17:20] <masak> fglock++

[17:20] <masak> perlito: say [+] 1..5

[17:20] <p6eval> perlito:  ( no output )

[17:20] <moritz_> diakopter: if you patched p6eval, please commit the changes into the pugs repo

[17:21] <moritz_> perlito: class A { has $.x; method foo { say $.x } }; A.new(x => 3).foo

[17:21] <p6eval> perlito:  ( no output )

[17:21] <pugssvn> r30159 | diakopter++ | [p6eval] and stuff 

[17:22] <moritz_> diakopter++

[17:22] <diakopter> hrm, it needs a custom munger sub

[17:22] * diakopter goes to fix

[17:24] *** nihiliad joined
[17:25] <lue> rakudo: $/<a><b>; say "Alive!"

[17:25] <p6eval> rakudo a61c40: OUTPUT¬´Method 'postcircumfix:<{ }>' not found for invocant of class ''‚ê§current instr.: '!postcircumfix:<{ }>' pc 13740 (src/builtins/Code.pir:120)‚ê§¬ª

[17:25] <lue> Huh?

[17:26] <diakopter> I think < > is treated the same as { }

[17:28] <lue> rakudo: if 5 > my $a = 4 { say $a }

[17:28] <p6eval> rakudo a61c40: OUTPUT¬´Use of type object as value in numeric context‚ê§current instr.: 'perl6;Perl6Exception;throw' pc 14682 (src/builtins/Seq.pir:77)‚ê§¬ª

[17:28] <masak> right. postfix <> delegates to postfix {}

[17:29] <masak> rakudo: if 5 > (my $a = 4) { say $a }

[17:29] <p6eval> rakudo a61c40: OUTPUT¬´4‚ê§¬ª

[17:30] *** p6eval left
[17:30] *** p6eval joined
[17:32] <lue> Should that bug be closed, or is the problem no parens? (62472)

[17:33] * masak looks

[17:34] <masak> it can be closed when it has a better error.

[17:34] <masak> in my view, it doesn't yet.

[17:34] <moritz_> std: if 5 > my $a = 4 { say $a }

[17:34] <p6eval> std 30159: OUTPUT¬´ok 00:01 108m‚ê§¬ª

[17:34] <masak> it's *syntactically* correct :)

[17:37] <moritz_> rakudo: warn('foo')

[17:37] <p6eval> rakudo a61c40: OUTPUT¬´foo‚ê§¬ª

[17:37] * mathw is lured away by the prospect of sausages

[17:37] <lue> DON'T PANIC! But do you really need to declare a variable in an if's conditional? Seems pretty faulty...

[17:37] *** p6eval left
[17:37] *** p6eval joined
[17:37] <lue> there's your error

[17:37] <diakopter> oh, no, I just restarted it

[17:37] <diakopter> oh, nm

[17:37] *** envi^home left
[17:38] <mathw> lue: you'll inevitably find somebody who does

[17:38] <masak> lue: I think I discovered that ticket while actually writing some actual code. but no, it's not always a Good Thing to do... :)

[17:38] *** nihiliad left
[17:38] <mathw> Most of the time I'm fairly sure it's a bad idea though

[17:38] *** nihiliad joined
[17:38] <mathw> That doesn't mean there isn't a good use for it

[17:39] <lue> that, IMO, should be illegal in the spec. This would guarantee a result, and that's pretty... interesting. (convice me otherwise)

[17:39] <moritz_> it's specced what it should do.

[17:39] <moritz_> there's nothing unclear about it

[17:39] <moritz_> the variable is visible in the rest of the current lexical scope

[17:40] <moritz_> and the declaration returns the variable

[17:40] <moritz_> and the precedence of the item assignment operator is also specced

[17:40] <lue> Well then, maybe a warning? I don't forsee this as a common task...

[17:40] <moritz_> why a warning? it's not like the code looks harmless, but does something unpredictable

[17:41] <mathw> if you add a warning ,anybody who does use it has to put up with a warning, so you're effectively forbidding it

[17:41] <lue> Eh, I just don't like it :)

[17:41] <mathw> you either have it or you don't

[17:41] <moritz_> if you write a declaration inside an if-statement, you do it deliberately. That's not a typo :-)

[17:41] <mathw> well, you're forbidding it or encouraging the ignoring of warnings which is a Bad Thing

[17:41] <masak> I can easily give the rationale for a declaration in a while condition.

[17:41] <lue> Alright! You convinced me otherwise on warnings/errors

[17:42] <lue> but I still don't see why you'd want to do it that way :)

[17:42] *** p6eval left
[17:42] *** p6eval joined
[17:42] <lue> (I bet I will once I need to use it...)

[17:42] <diakopter> ahah.

[17:42] <diakopter> perlitobug

[17:43] <diakopter> it doesn't like empty statements

[17:44] *** p6eval left
[17:44] *** p6eval joined
[17:44] *** p6eval left
[17:45] *** p6eval joined
[17:45] * masak removes the named-enums branch on github

[17:45] <jnthn> masak: (class vars) can probably be made to work, just a pain.

[17:45] *** p6eval left
[17:45] *** p6eval joined
[17:45] <masak> jnthn: cool!

[17:47] <jnthn> Well

[17:47] <jnthn> Less of a pain than other things that need doing. :-)

[17:50] <diakopter> perlito: class A { has $.x; method foo { return $.x } }; my $a := A.new(x => 5); say $a.foo

[17:50] <p6eval> perlito: OUTPUT¬´5‚ê§¬ª

[17:51] <moritz_> perlito: class A { has $.x; method foo { return $.x } }; my $a = A.new(x => 5); say $a.foo

[17:51] <p6eval> perlito: OUTPUT¬´*** Error in assignment operation: infix<=> not implemented; use infix<:=> instead at /home/p6eval/Perlito/lib5/MiniPerl6/Grammar.pm line 39.‚ê§¬ª

[17:51] <moritz_> yikes

[17:51] <moritz_> just like nqp

[17:51] <diakopter> perlito: class A { has $.x; method foo { return $.x } }; say A.new(x => 5).foo

[17:51] <p6eval> perlito: OUTPUT¬´Can't call method "foo" without a package or object reference at (eval 3) line 16.‚ê§A=HASH(0x825df0)‚ê§¬ª

[17:51] <moritz_> perlito: class A { has $.x; method foo { return $.x } }; say (A.new(x => 5)).foo

[17:51] <p6eval> perlito: OUTPUT¬´5‚ê§¬ª

[17:51] <diakopter> (but aliasing to $a first, works)

[17:51] <diakopter> oh

[17:51] <moritz_> parsing issue

[17:51] <diakopter> nice

[17:52] <moritz_> kp6 had that too

[17:52] <diakopter> nice, to you, I mean

[17:52] <diakopter> ok, here, I hacked in something that recognizes if the eval input starts with a class

[17:53] <diakopter> o wait, hang on

[17:53] <diakopter> easier solution

[17:53] <moritz_> why?

[17:53] <diakopter> b/c perlito requires a Main class

[17:54] *** p6eval left
[17:54] *** p6eval joined
[17:54] <diakopter> perlito: class A { has $.x; method foo { return $.x } }; class Main { say (A.new(x => 5)).foo }

[17:54] <p6eval> perlito: OUTPUT¬´5‚ê§¬ª

[17:55] <moritz_> rakudo: Q:PIR{ $P0 = get_hll_global '&warn'‚ê§$P0("foo") }

[17:55] <p6eval> rakudo a61c40: OUTPUT¬´foo‚ê§¬ª

[17:55] <moritz_> rakudo: Q:PIR{  get_hll_global $P0, '&warn'‚ê§$P0("foo") }

[17:55] <diakopter> ok. if you don't define any classes, it's wrapped in 'class Main {' . $inp . '}'  but if you define your own class, you must explicitly write out your own Main class, too.

[17:55] <p6eval> rakudo a61c40: OUTPUT¬´foo‚ê§¬ª

[17:55] *** abra left
[17:56] * moritz_ wonders what went wrong locally

[17:56] <jnthn> masak: Any luck with the neamed enums hack?

[17:56] <pugssvn> r30160 | diakopter++ | [p6eval] helper wrapper for perlito, for convenience 

[17:56] <masak> jnthn: no, I looked at it and didn't see how to create the PAST structure.

[17:58] *** ChanServ sets mode: +o diakopter

[17:58] *** diakopter was kicked by diakopter (MEDDLING))
[17:58] <moritz_> rakudo: say  Q:PIR{  get_hll_global $P0, '&warn'‚ê§$P0("foo")‚ê§ %r = 3 }

[17:58] <p6eval> rakudo a61c40: OUTPUT¬´foo‚ê§Null PMC access in set_integer_native()‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[17:58] <moritz_> rakudo: say  Q:PIR{  get_hll_global $P0, '&warn'‚ê§$P0("foo")‚ê§ %r = box 3 }

[17:58] <jnthn> masak: PAST::Stmts node, and then loop over the hash thingies and make a PAST::Op.new( :pasttype('bind'), PAST::Var.new( :name($enum_element_name) :namespace($enum_name) :scope('package') ), PAST::Val.new( :value($enum_value) ))

[17:58] <p6eval> rakudo a61c40: OUTPUT¬´foo‚ê§3‚ê§¬ª

[17:58] <jnthn> Or some such

[17:59] <masak> jnthn: oh! ok.

[17:59] <jnthn> Yes, it's a sick hack.

[17:59] <jnthn> :-)

[17:59] <masak> jnthn: I'll try it while making supper.

[17:59] <jnthn> Yeah

[17:59] <jnthn> I'm going out for a wander, and I'll either come back having found supper and eaten it, or with stuff to cook. :-)

[18:00] <jnthn> Adventure!

[18:00] <jnthn> ;-)

[18:00] <lue> bye jnthn o/

[18:00] <colomon> o/

[18:00] <jnthn> back later :)

[18:02] <masak> o/

[18:03] <lue> (I just need to add in support for things like :2<0x98> and then unfudged radix.t ought to work :) )

[18:03] <lue> (and I need to unfudge radix.t)

[18:05] <masak> go lue! \o/

[18:07] <colomon> \o/

[18:08] <lue> just went to get some noms (lunch noms) now back to actually do what I said

[18:12] *** PZt joined
[18:14] *** jaldhar left
[18:15] <masak> & # noms

[18:15] *** masak left
[18:17] <lue> rakudo: Q:PIR{$I0=1 and 0‚ê§if $I0 = 1 goto fail‚ê§say "yay"‚ê§fail:‚ê§say "darn"}

[18:17] <p6eval> rakudo a61c40: OUTPUT¬´error:imcc:syntax error, unexpected PARROT_OP, expecting '\n' ('and')‚ê§     in file 'EVAL_1' line 64‚ê§error:imcc:syntax error, unexpected '=' ('=')‚ê§     in file 'EVAL_1' line 65‚ê§yay‚ê§darn‚ê§¬ª

[18:17] *** abra joined
[18:19] <lue> rakudo: Q:PIR{$I0=1‚ê§if $I0 = 1 and 2=2 goto win‚ê§say "fail"‚ê§win:‚ê§say "win"}

[18:20] <lue> rakudo: Q:PIR{$I0=1‚ê§if $I0 == 1 and 2==2 goto win‚ê§say "fail"‚ê§win:‚ê§say "win"}

[18:21] <p6eval> rakudo a61c40:  ( no output )

[18:21] <p6eval> rakudo a61c40: OUTPUT¬´error:imcc:syntax error, unexpected PARROT_OP, expecting GOTO ('and')‚ê§     in file 'EVAL_1' line 65‚ê§fail‚ê§win‚ê§¬ª

[18:21] <moritz_> lue: PIR does not support infix operators

[18:25] <lue> sigh :)

[18:25] <lue> The more I do this, the more I'd love to port this to P6 afterwards :)

[18:28] <moritz_> why not do it Perl 6 straight away

[18:30] <lue> Because the method was set up for me in pir, and I don't know how in P6 :D

[18:31] <lue> So I'll do it in PIR first, then study up on P6, and then port it :)

[18:31] *** jaldhar joined
[18:38] *** jaldhar left
[18:38] *** jaldhar joined
[18:39] <lue> OK! Time to compile...

[18:40] *** synth left
[18:40] *** [synth] left
[18:41] *** synth joined
[18:41] *** synth left
[18:43] *** synth joined
[18:44] *** synth left
[18:44] *** sorear left
[18:45] *** sorear joined
[18:46] <dalek> rakudo: 9780625 | (Solomon Foster)++ | src/core/metaops.pm:

[18:46] <dalek> rakudo: Rework hyper so that it properly handles cases with differing numbers of elements on each side.

[18:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9780625c7626e2a322624b14b2aa03b1170d3022

[18:47] <lue> rakudo: Q:PIR{$S0=substr "hello there",5‚ê§say $S0}

[18:47] <p6eval> rakudo a61c40: OUTPUT¬´ there‚ê§¬ª

[18:47] *** nihiliad left
[18:51] <lue> just out of curiosity, can you tell rakudo (make) to compile for a different CPU chip? Ex. On an intel machine, tell it to compile for PPC

[18:51] <moritz_> nope

[18:51] *** abra left
[18:51] *** nihiliad joined
[18:51] <moritz_> however the generated parrot byte code is platform independent

[18:52] *** Psyche^ joined
[18:52] *** snarkyboojum joined
[18:52] <moritz_> (in theory - no idea how well it works in practice)

[18:54] *** snarkyboojum left
[18:55] *** Patterner left
[18:55] *** Psyche^ is now known as Patterner

[18:56] *** ruudhaya joined
[18:56] <lue> YYYEEEESS! All of radcalc is programmed in, now to spectest (with fudged radix.t) :)

[18:56] *** ruudhaya left
[18:58] <dalek> rakudo: 0d10ff6 | moritz++ | src/core/IO.pm:

[18:58] <dalek> rakudo: enable printf() again

[18:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0d10ff649e1cd6a95b0be57f6f7dafacb355ecfa

[18:58] <dalek> rakudo: 3c9f65b | moritz++ | src/core/operators.pm:

[18:58] <dalek> rakudo: small fix in series operator

[18:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3c9f65b23577fd3f369ccbe825728ecdbbb51af5

[19:00] *** rv2733 joined
[19:02] <lue> misc.rakudo returned Dubious...

[19:02] <lue> (S03-operators)

[19:10] <lue> rakudo: say :16<2_F_A_C_E_D>

[19:10] <p6eval> rakudo a61c40: OUTPUT¬´3124461‚ê§¬ª

[19:11] <lue> bah! I left in an endless loop scenario (thank you spectest)

[19:24] <lue> *sob* why do fractions fail me now?

[19:27] *** pmurias left
[19:34] <lue> TWO periods? :16<16D.4> is sent to radcalc as 16D..4 !

[19:42] <lue> problem with the adverbs *grumble*

[19:42] <lue> (First big thing I've ever worked on in Rakudo :) )

[19:43] *** snarkyboojum joined
[19:44] *** nobyx joined
[19:44] * jnthn back

[19:46] <jnthn> lue++ # persistence!

[19:49] <lue> I can't tell Actions.pm to C<say> things so I find out where the double . comes in :(

[19:50] <lue> I'm guessing it's in $<fracpart>, but I'm not sure :)

[19:52] *** iblechbot joined
[19:52] <jnthn> lue: pir::say($thing); # will work

[19:53] <lue> in Actions.pm?

[19:53] <jnthn> Yes

[19:55] <lue> It started failing around when I added in support for things like :16<0o17>. I'm trying to get all of S02-literals/radix.t to pass :)

[19:57] <colomon> moritz_++ # fixing my wee series bug

[19:57] *** Maddingu1 is now known as Maddingue

[19:58] <lue> Either I fix it Actions.pm (the correct way) or program a workaround in radcalc (the cheat way). I would prefer Actions.pm

[19:58] *** molaf left
[19:58] <jnthn> lue: Yes, fixes are preferable to workarounds. :-)

[19:58] <jnthn> They save pain and wtfs later. :-)

[20:00] <lue> (aliens to Earth say WTZ :) )

[20:01] <colomon> I thought it would be WTB?

[20:01] *** snarkyboojum left
[20:03] <lue> What The Zark

[20:03] <lue> froody. The extra dot is a result of it being with $<fracpart>

[20:04] <lue> if it's always like that, then I can remove the dot we force in ( ~ "." ~ )

[20:05] <colomon> lue: can you paste the grammar you're using from fracpart now?

[20:06] <lue> the whole thing that sends off to radcalc (in Actions.pm)?

[20:07] <colomon> no, the bit you've changed in Grammar.pm

[20:07] <colomon> Or both parts, maybe!

[20:08] <colomon> oh, I see.  yeah, take out the extra ~ "." ~ in Actions.pm.  

[20:08] <colomon> That was my mistake, apologies.

[20:09] *** jaldhar left
[20:09] <lue> SINCE WHEN DID I NEED TO CHANGE GRAMMAR.PM? /o\

[20:09] <lue> ...sorry :)

[20:11] <colomon> I thought you were changing it this morning.  

[20:12] <colomon> It does need to be changed a bit eventually, but that's a low priority thing.

[20:12] *** clintongormley left
[20:13] <lue> there we go. fractions work again. (and another run of (fudged) radix.t)

[20:14] <lue> all pass! now to unfudge (let's see if that's easy)

[20:15] *** Guest14894 left
[20:19] <lue> unfudging is just removing all the #?rakudo stuff, right?

[20:20] *** jaldhar joined
[20:20] <jnthn> lue: yes

[20:21] <lue> alright!

[20:22] <sorear> hello jnthn

[20:23] <pugssvn> r30161 | lue++ | [t/spec] unfudged radix.t for rakudo 

[20:28] <lue> Test fails at :60[12,3,64] and stuff like that. I'll leave that for someone else. I'm done :)

[20:28] <lue> How do I create a patch, again?

[20:29] <colomon> lue: commit your changes locally, then use git patch.

[20:29] <lue> git commit ?

[20:31] <colomon> git commit, yes.

[20:31] <colomon> git commit -a 

[20:31] <colomon> Is the easiest way to commit all your changes at once.

[20:32] <jnthn> sorear: on phone, moment :-)

[20:33] <lue> then git patch, and nopaste said patch!

[20:34] <lue> erm, git patch doesn't work :(

[20:37] <colomon> should have left a file in the directory, with a name something like 0001 - your commit message

[20:37] <colomon> but you might need something like

[20:37] <colomon> git patch -1

[20:37] <lue> 'patch is not a git-command' :(

[20:38] <lue> and no 0001 file :(

[20:38] <colomon> sorry, it's git format-patch

[20:38] <colomon> git format-patch -1

[20:39] <colomon> will do it, I think.

[20:39] <lue> there it is!

[20:40] <colomon> \o/

[20:43] <lue> now to nopaste!

[20:44] *** dukeleto joined
[20:48] <lue> bah, paste failed. Try Again...

[20:49] <lue> OK... something's wrong with nopaste :(

[20:49] <colomon> use gist.github.com

[20:50] <colomon> nopaste hasn't worked the last three times I tried it.

[20:50] <colomon> :(

[20:51] <jnthn> back

[20:51] <colomon> o/

[20:51] <jnthn> sorear: oh hai

[20:51] <lue> http://gist.github.com/339561 there it is

[20:52] <lue> you will notice I'm much more liberal with comments than most :)

[20:53] <arnsholt> Anyone in here familiar with Parrot's continuations?

[20:53] <jnthn> arnsholt: mumble

[20:54] <jnthn> arnsholt: I think I've understood how they work at some point before now. :)

[20:54] <arnsholt> Heh

[20:54] <arnsholt> In that case, if you could take a look at this: http://nopaste.snit.ch/20025

[20:55] <arnsholt> Each time I call fail() in blob() choose() should backtrack and choose the next element in the list passed to it

[20:55] <bkeeler> Afternoon folks

[20:55] <lue> afternoon!

[20:55] <arnsholt> Which it does, on the -inside-, but for some reason the return value is always the same

[20:55] <lue> (has anyone looked at my patch? :) )

[20:56] <arnsholt> Is there something wrong with my code, or is it an actual bug?

[20:56] <colomon> lue: I started looking at it, then got distracted thinking of noms.

[20:56] <jnthn> lue: DON'T PANIC! Someone will look at your patch

[20:56] <lue> just checking :)

[20:56] <arnsholt> Those dastardly noms, always getting in the way =)

[20:57] <jnthn> arnsholt: Huh....I have to use my brain... :-)

[20:57] * jnthn tries to work out what the code does

[20:58] <arnsholt> It's supposed to be a non-deterministic searc (I'm fiddling around with doing Prolog for Parrot)

[21:01] *** payload joined
[21:01] <colomon> Did I say this shortly ago?  Unobe has a patch to make @a[*-1] work (which it does) but it blows up a bunch of spectests.

[21:02] <arnsholt> jnthn: It's adapted from a Scheme source if you'd find that easier to digest

[21:03] <jnthn> arnsholt: Probably not :-)

[21:03] <jnthn> So essentially it does:

[21:03] <jnthn>     say chosen

[21:03] <jnthn>     .return (chosen)

[21:03] <jnthn> And that's what populates city in

[21:03] <jnthn>     city = 'choose'("la", "ny", "bos")

[21:03] <jnthn>     say city

[21:03] <jnthn> >

[21:03] <jnthn> >

[21:03] <arnsholt> Yah

[21:03] <jnthn> ?

[21:03] <jnthn> grr, keybarod!

[21:03] <jnthn> ...that looks very weird.

[21:04] <lue> Happens to me too, jnthn. Especially things are being sent to IRC :)

[21:04] <colomon> lue: that is some well-commented code there.

[21:04] <arnsholt> The key is the bit above

[21:04] <jnthn> It has the right value and returns it...but then the thing it returns to gets a different value. :-/

[21:04] <arnsholt> Yeah. I just had an idea

[21:04] <arnsholt> I'm gonna try and remove the .tailcall

[21:04] <lue> I developed the habit when beginning my Python NES emulator :)

[21:04] <jnthn> oh.

[21:04] <jnthn> arnsholt: Tail calls do *certainly* have bugs.

[21:05] <jnthn> We work around one of them in Rakudo.

[21:05] <sorear> Why do tail calls have bugs?

[21:05] <arnsholt> No joy, unfortunately

[21:06] <jnthn> sorear: The one that bites me is, if you do a call into PIR from C, and that bit of PIR does a tailcall, the return value handling gets messed up and you get a null back instead of what the thing that was tail called to returns. IIRC.

[21:07] <jnthn> Probably not the case for arnsholt++

[21:07] <jnthn> But wouldn't surprise me if more bugs were lurking. :-/

[21:07] <arnsholt> Yeah. But I get the same result without the tailcall

[21:08] <jnthn> arnsholt: Aww. It does look odd. May be worth trying to get it down to a smaller example (though what you have is quite small) and ask some Parrot folks.

[21:08] <sorear> any hope of working TCO in R*?

[21:08] <lue> rakudo: my $num = 12345; printf "%d is %d digits long", $num, sub($s, @args is rw) { @args[2] = $s.elems }, 0;

[21:08] <jnthn> TCO = ?

[21:08] <p6eval> rakudo 0d10ff: OUTPUT¬´Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11‚ê§current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)‚ê§¬ª

[21:08] <colomon> tail call opt, I assume.

[21:08] <arnsholt> jnthn: Yeah, I've got some names from the people in #parrot, so right now I'm just waiting for them to show up

[21:08] <jnthn> Oh

[21:08] <sorear> tail call optimization, where anything evaluated in a returning context automatically becomes a tailcall

[21:09] <jnthn> For R*? No.

[21:09] <jnthn> Very unlikely.

[21:09] *** smash_ joined
[21:09] <smash_> hello everyone

[21:09] <smash_> moritz_: ping

[21:09] <jnthn> We've enough stuff to make *work*, let alone optimize. :-)

[21:09] <sorear> it lets you write loops recursively without blowing the stack, and is mandated by r5rs

[21:09] <arnsholt> So I figured I could ask in here as well, see if anyone were familiar with the continuations

[21:10] <jnthn> sorear: Yeah, I understand the concept, just didn't recognize the acronym. :-)

[21:10] <jnthn> sorear: I liked doing that in ML. Write recursive, get iterative memory usage. :-)

[21:10] <jnthn> We may be able to do it in Perl 6 but it probably screws up CALLER

[21:11] <jnthn> So it's a bit harder to know when you can do it, I guess.

[21:11] <arnsholt> Hmm. That's one for TimToady methinks

[21:12] <sorear> CALLER needs to be rethought anyways in the long run

[21:12] <sorear> since INLINING will screw it up

[21:12] <sorear> and that's a slightly important long-run optimization

[21:14] <lue> rakudo: ...

[21:14] <jnthn> sorear: Aye

[21:14] <p6eval> rakudo 0d10ff:  ( no output )

[21:15] *** hudnix joined
[21:15] <lue> rakudo: ??? "Hello"; say "<<just a warning"

[21:15] <p6eval> rakudo 0d10ff: OUTPUT¬´Stub code executed‚ê§<<just a warning‚ê§¬ª

[21:16] <lue> rakudo: !!! "Hello"; say "<<just an error"

[21:16] <p6eval> rakudo 0d10ff: OUTPUT¬´Stub code executed‚ê§current instr.: '&die' pc 17127 (src/builtins/Junction.pir:399)‚ê§¬ª

[21:17] <lue> jnthn: remember ... !!! ??? ? Would that be implementable in the new rakudo now ?

[21:18] <colomon> rakudo: say (1, 2, 3) >>~>> 'a'

[21:18] <p6eval> rakudo 0d10ff: OUTPUT¬´1a2a3a‚ê§¬ª

[21:22] *** rgrau` joined
[21:22] <jnthn> lue: I thought you just tried it out? :-)

[21:22] <jnthn> colomon: Nice! :-)

[21:23] <colomon> rakudo: say (1, 2, 3) >>~>> ()

[21:23] <p6eval> rakudo 0d10ff: OUTPUT¬´No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:‚ê§:(Any $a, Any $b)‚ê§‚ê§current instr.: '_block27127' pc 304349 (src/gen/core.pir:19496)‚ê§¬ª

[21:23] <lue> the arguments aren't accepted though :(

[21:23] <colomon> jnthn: I figured the [op] approach made sense here.  But that's easy to change if people feel that is the wrong approach.

[21:24] <lue> rakudo: say "foofoofoo".subst("foo", "bar", :x(1..2))

[21:24] <p6eval> rakudo 0d10ff: OUTPUT¬´barbarfoo‚ê§¬ª

[21:24] <lue> rakudo: say "foofoofoo".subst("foo", "bar", :x(5..6))

[21:24] <p6eval> rakudo 0d10ff: OUTPUT¬´barbarfoo‚ê§¬ª

[21:24] <jnthn> colomon: ooh, good point

[21:25] <jnthn> colomon: Yes, let's try that, until it's discovered to have issues, or the spec goes another way.

[21:25] <jnthn> colomon: Maybe I'll take a look at ++<<@a and @a>>++ this evening.

[21:25] *** Chillance joined
[21:26] <lue> rakudo: my $a = $b; my $b

[21:26] <p6eval> rakudo 0d10ff:  ( no output )

[21:26] <lue> rakudo: my $a = $b;

[21:26] <p6eval> rakudo 0d10ff: OUTPUT¬´Symbol '$b' not predeclared in <anonymous>‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[21:26] <lue> that's still a problem :)

[21:29] <lue> rakudo: class A { my $.b; method x { $!b = "b" } }; A.new.x

[21:29] <p6eval> rakudo 0d10ff: OUTPUT¬´No such attribute '$!b'‚ê§current instr.: 'perl6;A;x' pc 398 (EVAL_1:173)‚ê§¬ª

[21:30] <jnthn> s/my/has/

[21:31] <lue> just killing bugs on RT :)

[21:31] <lue> rakudo: class A { has $.b; method x { $!b = "b" } }; A.new.x

[21:31] <p6eval> rakudo 0d10ff:  ( no output )

[21:33] <moritz_> smash_: pong

[21:34] <smash_> moritz_: greetings, is it me of only registed users can see the copenhagen annouce in rakudo.org ?

[21:34] <lue> rakudo: class A does Int {}

[21:34] <p6eval> rakudo 0d10ff: OUTPUT¬´Method 'postcircumfix:<[ ]>' not found for invocant of class ''‚ê§current instr.: 'perl6;ClassHOW;add_composable' pc 4039 (src/metamodel/ClassHOW.pir:186)‚ê§¬ª

[21:35] <jnthn> smash_: I don't see it while not logged in.

[21:35] *** wknight8111 joined
[21:35] <smash_> jnthn: yeap, me neither

[21:35] <moritz_> smash_: I seem to have broken something...

[21:36] <lue> afk

[21:36] <moritz_> but I have no idea what :(

[21:37] *** jhuni joined
[21:38] <smash_> moritz_: sorry can't help you, i don't have any privileges there

[21:39] <moritz_> and I don't see any options to make it public or so

[21:39] <moritz_> I can try to re-post

[21:39] <moritz_> if that helps...

[21:39] *** molaf joined
[21:40] *** alester joined
[21:41] <jnthn> rakudo: my @a = 1,2,3; @a>>++; say @a;

[21:41] <p6eval> rakudo 0d10ff: OUTPUT¬´Method 'isa' not found for invocant of class 'Undef'‚ê§current instr.: 'perl6;Perl6;Actions;_block5849' pc 225685 (src/gen/perl6-actions.pir:0)‚ê§¬ª

[21:41] <moritz_> I created another announcement node on rakudo.org

[21:41] <moritz_> that doesn't show up eitehr

[21:42] <moritz_> and now both show up... wtf?

[21:43] <colomon> woah, lue actually made each error message start with DON'T PANIC!   :)

[21:43] <smash_> moritz_: yeao, seeing two annouces now

[21:43] <moritz_> better than none I think

[21:43] <jnthn> colomon: Yeah! :-)

[21:43] <smash_> moritz_: yes, better

[21:44] <jnthn> rakudo: my @a = { a => 1}, { a => 2}, { a => 3}; say @a>><a>; 

[21:44] <p6eval> rakudo 0d10ff: OUTPUT¬´123‚ê§¬ª

[21:44] <jnthn> wow!

[21:44] <moritz_> w00t

[21:44] <colomon> wow, I don't think I knew what was even possible in the spec!

[21:44] <jnthn> ...I accidentally the win when I implemented parallel dispatch, evidently.

[21:45] <jnthn> It's rather cool. :-)

[21:45] <jnthn> Well, it's only syntactic sugar for .postcircumfix:<{ }>('a')

[21:45] <jnthn> So by the time postfixish sees it, it's just a method call.

[21:46] <jnthn> So the standard parallel dispatch path works. :-)

[21:46] <jnthn> It is quite a cool discovery though. :-)

[21:46] * moritz_ wonders if we have tests for that...

[21:46] <dalek> rakudo: 70dd723 | (David Romano)++ | src/core/Array.pm:

[21:46] <dalek> rakudo: [src/core] indentation fix

[21:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/70dd72357a06832b65256820311287c37dd17388

[21:46] <dalek> rakudo: af16e57 | (David Romano)++ | src/core/operators.pm:

[21:46] <dalek> rakudo: [src/core] Define ne in terms of !eq

[21:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/af16e578a7804a1489b91380a02057de89d0b6df

[21:48] *** Enlik joined
[21:48] <jnthn> moritz_: I suspect not. :-)

[21:48] <jnthn> Hmm

[21:48] <jnthn> Guess it works for {..} and [...] postcircumfixes too just automatically. :-)

[21:49] *** Enlik left
[21:49] *** Enlik joined
[21:52] <moritz_> hm, lue has unfudge radix.t without patching rakudo - right?

[21:52] <colomon> I'm testing his patch right now.

[21:53] <colomon> so if he committed changes to radix.t, then yes.

[21:53] <moritz_> he did

[21:53] <jnthn> Talk about confidence in patch acceptance. :-)

[21:54] *** snarkyboojum joined
[21:55] <colomon> I'm going to run out to pick up noms (spicy beef with peanuts, woo-hoo) while the test runs, so even if it works I'll be a bit slow to push.

[21:55] <jnthn> colomon: Ooh, sounds nice. :-)

[21:55] * jnthn had beef with curry and veg tonight :-)

[21:56] *** Enlik left
[21:56] <colomon> from this place, it's usually heavenly.

[21:56] <pugssvn> r30162 | moritz++ | [t/spec] fudge S04-statement-modifiers/while.t for rakudo 

[21:56] <pugssvn> r30163 | moritz++ | [t/spec] test parallel dispatch on postcircumfix operators 

[21:56] *** Enlik joined
[21:56] *** payload left
[21:57] *** Enlik left
[21:57] *** Enlik joined
[21:58] *** pugssvn left
[22:02] * moritz_ thinks that pugssvn-- behaves very weirdly

[22:02] *** pugssvn joined
[22:03] <moritz_> I just regenerated the locales on feather3 in the hope that it helps...

[22:03] <lue> I wanted to test an unfudged radix.t against my patch, and didn't feel like a simple cp when I'd upload it anyway :)

[22:03] <moritz_> lue: you can test it locally unfudged without committing

[22:04] <moritz_> lue: commiting tests that fail for everybody else is considered rather rude here. Plesae don't do that again

[22:04] <lue> colomon: you know me! I'm going to start each message with DON'T PANIC! (you can change if you're really against it)

[22:04] <lue> mortiz_ alright :/

[22:05] *** eternaleye left
[22:05] <sorear> pcc_hackathon isn't merged yet :(

[22:06] *** nobyx left
[22:06] <pugssvn> r30164 | moritz++ | [t/spec] test that .HOW is readonly 

[22:06] <jnthn> sorear: I think merging it would also make Rakudo fail to build.

[22:07] <jnthn> sorear: I asked on list for a patch to fix up Rakudo.

[22:07] <lue> I'll work on improving bits of radix conversion in a while (including a port over to P6) :)

[22:09] <sorear> jnthn: a feature I need for Blizkost (slurpy return signatures in Parrot_pcc_invoke_sub_from_c_args) is only available in the branch

[22:09] <jnthn> sorear: Aww. :-(

[22:10] <sorear> it's ok, #parrot thinks I should be writing an entire C library to wrap libperl.so, then wrapping that with the NCI, then writing a binding layer in PIR

[22:10] <jnthn> ...

[22:11] <jnthn> That...wasn't the plan I'd had in mind for Blizkost.

[22:11] <jnthn> And sounds like a chunk more work.

[22:11] <sorear> Because, according to chromatic, the NCI code generator is the only thing that should be making PCC calls

[22:12] <jnthn> er, wtf?

[22:12] <sorear> I probably just failed to communicate again

[22:12] <jnthn> I thought the whole reason for having a unified model for PCC and the pain we all went through to move to one was so there _was_ an interface to do those things.

[22:13] <jnthn> Perhaps.

[22:13] <jnthn> Rakudo relies plenty of the ability to work with the PCC interface, for its multi dispatcher and signature binder, and I've never heard complaints about those along the same lines.

[22:14] <pugssvn> r30165 | moritz++ | [t/spec] in Test::Util, use Test; in order to have sub skip() available 

[22:15] <jnthn> moritz_++ # That allows the tests that use Test::Util to have a chance of working again, I guess?

[22:15] <moritz_> jnthn: currently these tests emit

[22:15] <moritz_> ok 1 - # SKIP test died: Not enough positional parameters passed; got 2 but expected 4

[22:16] <jnthn> Oh. :-/

[22:17] <moritz_> oh, it relies on $^a and $^b which seems not relieable

[22:17] <moritz_> next problem:

[22:17] <moritz_> rakudo: say $*EXECUTABLE_NAME

[22:17] <p6eval> rakudo 0d10ff:  ( no output )

[22:17] <moritz_> alpha: say $*EXECUTABLE_NAME

[22:18] <p6eval> alpha 30e0ed: OUTPUT¬´../rakudo-alpha/perl6‚ê§¬ª

[22:19] <jnthn> Probably just NYI.

[22:19] <moritz_> aye

[22:19] <jnthn> Should be an easy "copy from alpha" job.

[22:21] <moritz_> it's in src/builtins/globals.pir in alpha

[22:21] <moritz_> and in master @*INC is set up in src/Perl6/Compiler.pir

[22:21] <moritz_> what would you prefer? globals.pir?

[22:22] <jnthn> But it where e.g. $*PROGRAMENAME is set up

[22:22] <moritz_> it's not, in master

[22:22] <jnthn> Don't think we have a globals.pir in master

[22:22] <moritz_> rakudo: say $*PROGRAMNAME

[22:22] <jnthn> oh, I though mberends++ did that.

[22:22] <p6eval> rakudo 70dd72:  ( no output )

[22:22] <jnthn> oh.

[22:22] <jnthn> rakudo: say $*OS

[22:22] <p6eval> rakudo 70dd72: OUTPUT¬´linux‚ê§¬ª

[22:22] <moritz_> rakudo: say %*ENV.perl

[22:22] <p6eval> rakudo 70dd72: OUTPUT¬´Method 'key' not found for invocant of class 'String'‚ê§current instr.: 'perl6;EnumMap;_block14104' pc 408062 (src/gen/core.pir:58659)‚ê§¬ª

[22:22] <jnthn> :-/

[22:23] *** eternaleye joined
[22:23] <sorear> rakudo: say ::GLOBAL.keys.perl

[22:23] <p6eval> rakudo 70dd72: OUTPUT¬´Null PMC access in find_method('keys')‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[22:23] <sorear> what's the correct syntax for dumping all $*?

[22:23] <moritz_> src/cheats/setup-io.pm probably

[22:24] <jnthn> rakudo: say $*PROGRAM_NAME

[22:24] <p6eval> rakudo 70dd72: OUTPUT¬´/tmp/sQndXSIIeZ‚ê§¬ª

[22:24] <jnthn> ah

[22:24] <jnthn> Underscore :-)

[22:24] <jnthn> moritz_: src/glue/run.pir

[22:26] * lue is off to correct some of his errors in fixing radix conversion

[22:26] *** IllvilJa joined
[22:27] <lue> colomon: did you upload the patch yet? I'm off to correct my eagerness in unfudgeing radix.t :)

[22:28] <moritz_> jnthn: trying to add $EXECUTABLE_NAME in run.pir...

[22:29] <jnthn> +1

[22:32] <pugssvn> r30166 | moritz++ | [Test::Util] simplify code a bit 

[22:36] <jnthn> > my @a = 1,2,3; @a>>++; say @a;

[22:36] <jnthn> 234

[22:36] <jnthn> > my @a = 1,2,3; ++<<@a; say @a;

[22:36] <jnthn> 234

[22:37] <moritz_> now say @a>>++

[22:37] <moritz_> and say ++<<@a

[22:37] <jnthn> cheeky :-P

[22:37] <jnthn> > my @a = 1,2,3; say @a>>++;

[22:37] <jnthn> 123

[22:37] <jnthn> > my @a = 1,2,3; say ++<<@a;

[22:37] <jnthn> 234

[22:37] * moritz_ impressed

[22:37] <pugssvn> r30167 | moritz++ | [Test::Util] further simplification; now runs on Rakudo 

[22:37] <dalek> rakudo: 12b6d27 | moritz++ | src/glue/run.pir:

[22:37] <dalek> rakudo: re-instatiate $*EXECUTABLE_NAME

[22:37] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/12b6d2783874cd3bfbd7c075109093b55853803e

[22:38] <moritz_> anyway, bed time

[22:38] <jnthn> :-)

[22:38] <moritz_> 'night

[22:38] <jnthn> moritz_++

[22:38] <jnthn> night o/

[22:38] <lue> night o/

[22:39] * jnthn spectests

[22:41] *** huf left
[22:41] *** huf joined
[22:51] <jnthn> Anyone know if the S03-operators\precedence.rakudo test fail is an existing one?

[22:51] * jnthn is sure he's heard about it before...

[22:53] <lue> rebooting to try and get things working again. back in a bit!

[23:03] *** diakopter joined
[23:03] *** iblechbot left
[23:04] *** Enlik left
[23:04] <jnthn> .oO( /kick diakopter ABSENCE )

[23:06] <dalek> rakudo: 92745eb | jonathan++ | src/ (3 files):

[23:06] <dalek> rakudo: First cut of prefix and postfix hyper-operators. Parsing should all be fine, implementation probably needs tweaking for nested arrays.

[23:06] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/92745ebe599ed7320891cf2ff782bf4ac35c354a

[23:06] *** rgrau` left
[23:07] <diakopter> jnthn: ;P

[23:21] <diakopter> rakudo: say [+]++[+] 1

[23:21] <p6eval> rakudo 12b6d2: OUTPUT¬´2‚ê§¬ª

[23:22] <jnthn> std: say [+]++[+] 1

[23:22] <p6eval> std 30167: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Prefix requires an argument at /tmp/EHGW94kCDp line 1:‚ê§------> [32msay [+]++[+[33m‚èè[31m] 1[0m‚ê§FAILED 00:01 108m‚ê§¬ª

[23:22] <jnthn> Hm.

[23:22] <jnthn> :-/

[23:22] <diakopter> std fail?

[23:22] <jnthn> Or rakudo fail :-)

[23:23] <diakopter> oh, no.  yeah.

[23:23] <jnthn> I'm not sure what it'd mean if it did work.

[23:23] <diakopter> seems like it parsed it entirely right-associative, with which I don't see a problem

[23:23] <diakopter> er, prefix.

[23:24] * jnthn starts to see what it means :-)

[23:24] <jnthn> [+](++([+]1))

[23:24] <jnthn> Which...gives 2. :-)

[23:25] <diakopter> rakudo: say [+](++([+]1))

[23:25] <jnthn> Well, that's just an obfuscator's dream. :-)

[23:25] <p6eval> rakudo 12b6d2: OUTPUT¬´2‚ê§¬ª

[23:25] <jnthn> I'm not sure why STD doesn't like it.

[23:26] <diakopter> rakudo: say +[+]++[+]+1++

[23:26] <p6eval> rakudo 12b6d2: OUTPUT¬´2‚ê§¬ª

[23:26] <diakopter> std: say +[+]++[+]+1++

[23:26] <p6eval> std 30167: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Prefix requires an argument at /tmp/RlYzOf8ZvO line 1:‚ê§------> [32msay +[+]++[+[33m‚èè[31m]+1++[0m‚ê§FAILED 00:01 108m‚ê§¬ª

[23:26] *** kst joined
[23:27] <diakopter> mebbe std doesn't like nested reductions (without parens or other brackets) in general

[23:27] <diakopter> std: say +[+]++([+]+1++)

[23:27] <p6eval> std 30167: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[23:28] <diakopter> std: say +[+]++ [+]+1++ # o_O

[23:28] <p6eval> std 30167: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[23:30] *** crythias joined
[23:31] *** wallberg left
[23:31] <diakopter> √∂_√∂

[23:32] <diakopter> rakudo: say +[+] ++ [+]+1++

[23:32] <p6eval> rakudo 12b6d2: OUTPUT¬´2‚ê§¬ª

[23:32] <diakopter> jnthn: O_O

[23:32] <jnthn> :-/

[23:32] <diakopter> std: say ++ 4

[23:32] <p6eval> std 30167: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[23:32] <diakopter> std: say 4 ++

[23:32] <p6eval> std 30167: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Postfix found where infix expected (omit whitespace?) at /tmp/GTTMNkVqnY line 1:‚ê§------> [32msay 4 [33m‚èè[31m++[0m‚ê§    expecting any of:‚ê§    bracketed infix‚ê§  infix‚ê§  infix or meta-infix‚ê§FAILED 00:01 107m‚ê§¬ª

[23:33] <jnthn> rakudo: say ++4

[23:33] <p6eval> rakudo 12b6d2: OUTPUT¬´Cannot assign to readonly value‚ê§current instr.: '&die' pc 17140 (src/builtins/Junction.pir:399)‚ê§¬ª

[23:33] <jnthn> rakudo: say 1++

[23:33] <p6eval> rakudo 12b6d2: OUTPUT¬´Cannot assign to readonly value‚ê§current instr.: '&die' pc 17140 (src/builtins/Junction.pir:399)‚ê§¬ª

[23:33] <jnthn> ...how on earth you're getting away with it above, I've no idea. :-)

[23:33] <diakopter> where'd the intervening ++ go, then

[23:33] <diakopter> yeah

[23:33] <jnthn> Well, --target=parse is your friend if you want to see what Rakudo's parsing it as. :-)

[23:33] <diakopter> and ... I didn't realize whitespace was allowed between prefix...

[23:34] <jnthn> Yes

[23:34] <jnthn> Even between the << bit in a hyper one.

[23:34] <diakopter> ok, so it's pre-not-quite-fixed

[23:34] <jnthn> std: my @a; say ++<< @a;

[23:34] <p6eval> std 30167: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[23:34] <jnthn> :-)

[23:34] <jnthn> preclose

[23:34] <diakopter> prenear

[23:35] <jnthn> preish

[23:35] <jnthn> oh noes, $*LEFTSIGIL gets tweaked inside EXPR. :-/

[23:35] <diakopter> std: my @a; say -<< @a;

[23:35] <p6eval> std 30167: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[23:35] *** lue joined
[23:36] <jnthn> rakudo: my @a = 1,2,3; say (-<< @a).perl

[23:36] <p6eval> rakudo 12b6d2: OUTPUT¬´Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11‚ê§current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)‚ê§¬ª

[23:36] <diakopter> dunno what prefix - does

[23:36] <jnthn> rakudo: my @a = 1,2,3; my @b = -<< @a; say @b;

[23:36] <p6eval> rakudo 12b6d2: OUTPUT¬´Confused at line 11, near "my @b = -<"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[23:37] <diakopter> rakudo: my @a = 1,2,3; my @b = -<< @a; say @b;

[23:37] <p6eval> rakudo 12b6d2: OUTPUT¬´Confused at line 11, near "my @b = -<"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[23:37] <jnthn> negation

[23:37] <diakopter> rakudo: my @a = 1,2,3; my @b = +<< @a; say @b;

[23:37] <p6eval> rakudo 12b6d2: OUTPUT¬´Confused at line 11, near "my @b = +<"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[23:37] <diakopter> rakudo: my @a = 1,2,3; my @b = !<< @a; say @b;

[23:37] <p6eval> rakudo 12b6d2: OUTPUT¬´Confused at line 11, near "my @b = !<"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[23:37] <jnthn> oh

[23:37] *** JimmyHoff left
[23:37] <jnthn> wonder if the bot is up to date

[23:37] <jnthn> rakudo: my @a = 1,2,3; say ++<<@a; # know this one works locally

[23:37] <p6eval> rakudo 12b6d2: OUTPUT¬´Confused at line 11, near "say ++<<@a"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[23:37] <jnthn> ah

[23:37] <jnthn> ETOOSOON.

[23:37] <lue> colomon: ping

[23:38] <colomon> pong

[23:38] <colomon> just looking at the test results from your patch

[23:38] <diakopter> pugs: my @a = 1,2,3; say ++<<@a;

[23:38] <p6eval> pugs: OUTPUT¬´<Error><Error><Error>‚ê§¬ª

[23:38] <jnthn> Wow!

[23:38] <diakopter> pugs: my @a = 1,2,3; say -<<@a;

[23:38] <p6eval> pugs: OUTPUT¬´-1-2-3‚ê§¬ª

[23:39] <lue> I'm off to correct my eagerness in unfudgeing all of radix.t :/

[23:39] <diakopter> "and that's when she travelled forward in time..."

[23:40] <colomon> at least one of the tests, you're right and the test is wrong.

[23:40] <jnthn> That puts a new slant on test fail.

[23:40] <lue> I am?

[23:40] <colomon>  is(:8('0b1110'),  0o14, ':8(0b1110) converts from decimal');

[23:41] <colomon> should be Oo16 for the answer, I believe.

[23:41] <colomon> 1110 bin is 14 decimal, not 14 octal

[23:41] <diakopter> yeah but

[23:41] <colomon> actually all those answers are wrong in that section.

[23:41] <diakopter> it's supposed to use the string value of the number

[23:41] <diakopter> no

[23:42] <diakopter> it's spec

[23:42] <colomon> diakopter: can you be more specific about what the spec says?

[23:43] <lue> I plan on porting radcalc o'er to P6 when it's a good time to do so (it would be less code than PIR :) )

[23:43] <colomon> the :16() tests definitely assume the inner base overrides the radix.

[23:43] <lue> rakudo: say :16(0b110) # 6

[23:43] <p6eval> rakudo 12b6d2: OUTPUT¬´6‚ê§¬ª

[23:44] <diakopter> I don't know.  when I implemented them in sprixel, I understood it.  but I have no certainty that radix.t hasn't been changed since then.

[23:44] <lue> One thing I left out is the :60[34,59,2] type stuff :/

[23:44] <jnthn> oh no!

[23:44] <jnthn> I...just pushed a patch that included something it wasn't meant to. :-/

[23:45] <diakopter> o dears

[23:45] <lue> rakudo: say :60[59] # should be 59

[23:45] <p6eval> rakudo 12b6d2: OUTPUT¬´Malformed radix number at line 11, near "[59] # sho"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[23:45] <lue> perl6: say :60[59] # should be 59

[23:45] <p6eval> pugs: OUTPUT¬´59‚ê§¬ª

[23:45] <p6eval> ..rakudo 12b6d2: OUTPUT¬´Malformed radix number at line 11, near "[59] # sho"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)‚ê§¬ª

[23:45] <p6eval> ..elf 30167: OUTPUT¬´Unknown rule: rad_number‚ê§It needs to be added to ast_handlers.‚ê§ at ./elf_h line 2850‚ê§¬ª

[23:46] <lue> colomon: considering you're testing my patch, would it be aggravating to you if I started switching over to P6 code?

[23:47] <dalek> rakudo: 53707fb | jonathan++ | src/Perl6/Grammar.pm:

[23:47] <dalek> rakudo: Start to scatter various $*LEFTSIGIL bits around, in prep for item assignment. This covers all cases in STD apart from those in EXPR.

[23:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/53707fb03007c9ba464b8c483c945a36de440153

[23:47] <lue> (it'd take a while, but...)

[23:47] <jnthn> The above patch accidentally also enables the check for item assignment. I'm spectesting now to see if there's fallout.

[23:47] <jnthn> No point undoing it if it works.

[23:48] <Tene> or if it can be made to work.

[23:48] <colomon> lue: if you do that, let me work on getting the fudging correct for radix.t.

[23:48] <jnthn> Tene: I didn't realize that I'd also saved the bit that checked it - I'd wanted to make sure adding the various assignments to $*LEFTSIGIL hadn't broken anything. :-)

[23:49] * Tene nods.

[23:49] <jnthn> And then was prepping to spectest that as the next step. :-)

[23:49] <jnthn> .oO( I accidentally the item assignment. )

[23:49] <lue> will do colomon

[23:50] <jnthn> rakudo: my $a = 1, 2, 3; say $a;

[23:50] <p6eval> rakudo 92745e: OUTPUT¬´1 2 3‚ê§¬ª

[23:50] <jnthn> That's what's wrong and what the item assignment changes should fix.

[23:50] <diakopter> colomon: ... nor if radix.t was changed, whether it was changed correctly

[23:51] <jnthn> lol

[23:51] <jnthn> > my $a = 1, 2, 3; say $a;

[23:51] <jnthn> 1

[23:51] <jnthn> \o/

[23:51] <jnthn> Let's see what it makes of the test suite. :-)

[23:53] <colomon> lue: your patch looks solid -- at least, the test failures are not at all your fault.  lue++

[23:53] <sorear> jnthn: RTLD_GLOBAL is in.

[23:54] <jnthn> sorear++

[23:54] <jnthn> \o/

[23:54] <diakopter> rakudo should rebuild in 6 minutes..

[23:54] <diakopter> should start rebuilding I mean

[23:54] *** dual left
[23:54] <sorear> I was about to say

[23:55] <colomon> eval('2¬´1.1*:2<10>**:2<10>¬ª')   ????!?

[23:55] *** dual joined
[23:55] <lue> 6 minutes? That would not only be fast, but quite serendipitous

[23:56] <jnthn> colomon: huh?!

[23:56] <jnthn> :-)

[23:56] <colomon> std: 2¬´1.1*:2<10>**:2<10>¬ª

[23:56] <sorear> 6 minute rebuilds for rakudo would be extremely awesome

[23:56] <p6eval> std 30167: OUTPUT¬´ok 00:01 105m‚ê§¬ª

[23:56] <lue> It's a french quote test :) (I know...)

[23:57] <lue> (I didn't do it!)

[23:57] *** justatheory joined
[23:57] <lue> .sub '&radcalc' in pir would be multi method radcalc( in p6, correct?

[23:59] *** diakopter left
