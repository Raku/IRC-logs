[00:03] <pmichaud> hugme: show nqp-rx

[00:03] <hugme> pmichaud: the following people have power over 'nqp-rx': PerlJam, TimToady, [particle], colomon, jnthn, masak, moritz_, pmichaud. URL: http://github.com/perl6/nqp-rx/

[00:04] * jnthn plays cheesy 80's "I got the power!" song

[00:04] <jnthn> ...actually not.

[00:04] <jnthn> :-)

[00:04] <colomon> jnthn: also the fact we have four different trig bases...

[00:04] <jnthn> Four your base...

[00:04] <jnthn> colomon: Yeah, it multiplies out pretty quickly. :-)

[00:04] <pmichaud> all your base are belong to...

[00:04] <jnthn> ...our spectests. :)

[00:05] <sjohnson> camelia

[00:05] <pmichaud> hugme: show help

[00:05] <hugme> pmichaud: sorry, I don't know anything about 'help'

[00:05] <pmichaud> hugme: help

[00:05] <hugme> pmichaud: (add $who to $project | list projects | show $project | hug $nickname | tweet $twittername $message )

[00:05] <pmichaud> how do I see who has commit access to a project?

[00:06] <diakopter> hugme: show rakudo

[00:06] <hugme> diakopter: sorry, I don't know anything about 'rakudo'

[00:06] <diakopter> hugme: show nqp-rx

[00:06] <sorear> hugme: add sorear to nqp-rx

[00:06] <hugme> diakopter: the following people have power over 'nqp-rx': PerlJam, TimToady, [particle], colomon, jnthn, masak, moritz_, pmichaud. URL: http://github.com/perl6/nqp-rx/

[00:06] <hugme> sorear: sorry, you don't have permissions to change 'nqp-rx'

[00:06] <sjohnson> hugme: show hugme

[00:06] <hugme> sjohnson: the following people have power over 'hugme': PerlJam, TimToady, [particle], colomon, jnthn, masak, mberends, moritz_, pmichaud. URL: http://github.com/moritz/hugme/

[00:06] <jnthn> pmichaud: I thought show did that.

[00:06] <pmichaud> jnthn: me too, but the list that hugme gives doesn't match the actual collaborators list

[00:06] <jnthn> pmichaud: Maybe it only knows about the ones added through hugme.

[00:07] <pmichaud> for example, sorear++ is a nqp-rx committer, and TimToady isn't.

[00:07] <jnthn> Oh.

[00:07] <pmichaud> I think it might be reporting who has meta-level control

[00:07] <jnthn> Maybe it's bugge^Wbuggy.

[00:07] <pmichaud> i.e., who's authorized to had committers

[00:07] <pmichaud> as opposed to who the committers are

[00:07] <jnthn> Yeah

[00:07] <jnthn> I'm not sure if it equates the two.

[00:08] <jnthn> Pugs repo style.

[00:09] *** cdarroch left
[00:10] <sorear> do spectest runs normally take >1 hour?

[00:10] *** rv2733 left
[00:10] <sorear> ok, I'm down to failing three spectests

[00:10] <jnthn> sorear: Not for me. It depends on your hw

[00:10] <sorear> S05-mass/properties-general.t

[00:10] <sorear> S32-list/map.t

[00:10] <sorear> S32-num/rounders.t

[00:13] <sorear> actually the S05-mass one is just TODO passage since I have ICU

[00:14] <jnthn> rounders.t may be a compiler specific issue. I have a box where I get fails in that.

[00:14] <jnthn> map.t otoh is probably more concerning.

[00:16] <sorear> map.t needs to be fudged better

[00:16] <sorear> it was silently giving the wrong answer before, so we todo'd it

[00:16] <sorear> with my changes it dies

[00:17] <sorear> rakudo: next

[00:17] <p6eval> rakudo e98866: OUTPUT«Warning␤»

[00:17] <sorear> stefan@stefans:~/rakudo$ ./perl6 -e 'next'

[00:17] <sorear> Uncaught control exception 64 in eval

[00:18] <sorear> so I'm going to declare this spectest run "good enough"

[00:18] * sorear commits remaining changes and passes the baton to pmichaud 

[00:23] <pmichaud> sorear++

[00:24] <pugssvn> r30628 | sorear++ | Refudge S32-list/map to account for a possible control exception 

[00:25] <jnthn> Ah, yes, fudging things from todo to skip is often OK.

[00:25] * jnthn has had to do that various times too

[00:41] <pmichaud> hugme: add bacek to nqp-rx

[00:41] * hugme hugs bacek. Welcome to nqp-rx!

[00:43] * sjohnson hugs himself

[00:46] <diakopter> hugme: hug hugme

[00:46] * hugme hugs hugme

[00:46] <diakopter> hugme: hug hugme

[00:46] * hugme hugs hugme

[00:46] <diakopter> hugme: hug hugme

[00:46] * hugme hugs hugme

[00:47] *** plobsing joined
[00:51] <diakopter> hugme: hug hugme

[00:51] * hugme hugs hugme

[00:51] <diakopter> aww

[00:52] <pmichaud> autohugging. hmmm.

[00:52] <diakopter> hugme: hug themselves

[00:52] * hugme hugs themselves

[00:53] <jnthn> hugme: hug like that nice Icelandic girl I met

[00:53] * hugme hugs like

[00:53] <jnthn> ...aww!

[00:53] *** eternaleye joined
[00:53] <jnthn> .oO( /hug (\w+)/ )

[00:53] <diakopter> hugme: huge sky

[00:53] <hugme> diakopter: 

[00:54] *** k23z__ joined
[00:54] <k23z__> anyone awake ?

[00:54] <diakopter> O_O

[00:54] <pmichaud> zzzzz

[00:54] <k23z__> I remember seeing some discussions about OR being carried out in parallel

[00:55] <k23z__> and stuff like that

[00:55] <k23z__> and I'd like to mention a language where that *IS* currently implemented

[00:55] <k23z__> it's called ORC

[00:55] <k23z__> http://orc.csres.utexas.edu

[00:55] <k23z__> check out the documentationz http://orc.csres.utexas.edu/userguide/html/all.html

[00:55] <diakopter> or is it?

[00:55] <pmichaud> k23z__: awesome

[00:56] <k23z__> http://orc.csres.utexas.edu/userguide/html/all.html#N11091

[00:56] <k23z__> pmichaud, http://orc.csres.utexas.edu/userguide/html/all.html#N11091

[00:56] <k23z__> is this in p6 spec ?

[00:57] <pmichaud> k23z__: yes, as or-junctions

[00:57] <jnthn> I guess an any junction would be able to do something like that as an optimization.

[00:57] <jnthn> They're spec'd as parallel allowed.

[00:57] <k23z__> pmichaud, this currently implemented in Rakudo ?

[00:57] <jnthn> And as soon as one thing says true, that's enough for the lot to me.

[00:57] <pmichaud> if foo() | bar() | baz() { ... }    is allowed to do parallel testing

[00:57] <pmichaud> k23z__: or junctions are implemented, but not the parallel optimizatin

[00:58] <k23z__> ah ok

[00:58] <k23z__> if you guys ever want to kickstart this you might want to look at the ORC source ...

[00:58] <jnthn> pmichaud: Careful - would that not have to call all of the functions and then construct the junction? I guess we could thunk it, but I'm not sure if that's spec'd.

[00:58] <k23z__> this parallel thing seems to be the strong-point of ORC

[00:58] <pmichaud> jnthn: I think it's allowed to be thunked

[00:58] <jnthn> pmichaud: OK.

[00:58] <jnthn> pmichaud: I can't think of how thunking it would break the semantics, so I guess it's fine.

[01:01] * jnthn puts the ORC link onto his "things to look at when I have more time and conciousness" pile

[01:01] <pmichaud> yeah, I need a break to let the allergy/sinus meds to kick in.  :-|

[01:01] <pmichaud> bbiaw

[01:01] <jnthn> Aww

[01:09] *** jferrero left
[01:27] <pugssvn> r30629 | colomon++ | [t/spec] Cut back on a few more or less duplicate tests. 

[01:37] *** rml_ joined
[01:44] *** orafu left
[01:48] <isBEKaml> sorear++ # stagestats fix :)

[01:59] *** gbacon_ joined
[02:09] *** wknight8111 left
[02:17] *** patspam left
[02:17] *** patspam joined
[02:25] <colomon> 32129 passing tests, time for bed.

[02:25] <pugssvn> r30630 | colomon++ | [t/spec] Unfudge test after tweaking it a bit to avoid a unnecessary Rakudo bug which was irrelevant to what was being tested. 

[02:41] *** gbacon_ left
[02:42] *** gbacon_ joined
[02:50] *** k23z__ left
[02:53] *** gbacon_ left
[03:00] *** masonkramer left
[03:00] *** masonkramer_ joined
[03:00] *** masonkramer_ is now known as masonkramer

[03:08] *** dalek joined
[03:09] *** patspam left
[03:13] *** PenThrive joined
[03:22] *** envi^home joined
[03:38] <pugssvn> r30631 | sorear++ | Mostly unbitrot STD_syntax_highlight; it can now parse most of Rakudo's Perl6 

[03:40] <sorear> it's still failing on STD.pm6 though.

[03:40] <sorear> even though 'std' can handle STD

[03:40] <sorear> and they're using the same parsercore

[03:42] *** plobsing left
[03:43] *** plobsing joined
[03:51] <sorear> seems to be an encoding issue; it barfs on the first line mentioning $¢

[03:57] *** snarkyboojum left
[03:57] <sorear> yeeaap.  @MEMOS[$\u{fffd}

[03:57] <sorear> no wonder it barfed

[03:58] *** JimmyZ joined
[04:07] *** alester joined
[04:10] *** snarkyboojum joined
[04:10] <sorear> does azawawi IRC?

[04:17] <pugssvn> r30632 | sorear++ | Fix encoding error.  STD_syntax_highlight can parse STD.pm6 now! 

[04:17] <sorear> I'm not crazy about the colors but it's a far cry better than perl6.vim

[04:17] <sorear> in terms of what it can parse without losing sync

[04:18] * sorear reads STD.pm6

[04:18] *** hercynium left
[04:26] <diakopter> sorear: I see azawawi here occasionally

[04:28] *** justatheory left
[04:36] *** Guest75855 left
[04:39] *** snarkyboojum left
[04:43] *** snarkyboojum joined
[04:50] <sorear> seen Juerd

[04:50] <sorear> buubot: seen Juerd 

[04:50] <buubot> sorear: I don't think I've seen Juerd.     

[04:51] <sorear> wat.

[04:52] <sorear> Who runs perl6.org?

[04:59] * isBEKaml looks at moritz_ 

[05:00] <PerlJam> Is there something wrong with perl6.org?

[05:02] <isBEKaml> pointme: IRSeekBot

[05:03] *** snarkyboojum left
[05:03] <isBEKaml> :(

[05:07] <sorear> PerlJam: No, but it could be more awesome

[05:07] <isBEKaml> vim's perl6 syntax highlight file is over 2k lines! I wondered why vim was slow in displaying p6 files.. o.O

[05:07] <PerlJam> sorear: do you have a commit bit to the pugs repo?

[05:09] <sorear> PerlJam: Yes

[05:09] <PerlJam> sorear: see docs/feather/perl6.org

[05:09] <sorear> But that doesn't translate into a crontab bit on whatever hosts perl6.org

[05:09] *** snarkyboojum joined
[05:09] <isBEKaml> sorear: You can make small changes directly there. a cron job would update it every 15 mins. http://perl6.org/about/

[05:10] <isBEKaml> oh

[05:10] <sorear> You see, I just made the Perl 6 -> HTML converter work (again?)

[05:11] <sorear> So... we could have nicer links for STD.pm6 and in the spectest inserts

[05:18] *** alester left
[05:22] *** snarkyboojum left
[05:24] *** snarkyboojum joined
[05:52] *** snarkyboojum left
[05:56] *** Targhan_ left
[05:56] *** snarkyboojum joined
[05:59] <isBEKaml> http://pmichaud.com/2009/pres/oscon-rakudo/slides/start.html

[06:00] <isBEKaml> pmichaud++ 

[06:00] <isBEKaml> the presentation makes me badly want to write some code, heck, even a module that no one will use. Like, LOLTest! :D

[06:02] <isBEKaml> pmichaud: I cannot view beyond slide 92 on your awesome presentation. .  :(

[06:04] *** Chillance left
[06:09] * sorear finally made it through STD.pm6

[06:09] <sorear> I blame reasonable higlighting

[06:12] <isBEKaml> pmichaud: nm. Waited a while, I can see them now. Awesome presentation! :)

[06:15] *** meppl joined
[06:16] <sorear> careful there

[06:16] <sorear> tat's alpha

[06:17] <isBEKaml>  sorear: ? 

[06:17] <sorear> isBEKaml: the stuff about PGE is wrong

[06:17] <sorear> outdated, very much, rather

[06:18] <sorear> the front end of Rakudo was completely replaced in February

[06:18] <isBEKaml> sorear: Doesn't matter, I was just looking to gain more into how Rakudo came to be, now. :)

[06:18] <sorear> rakudo: say pir::typeof__SP(Perl6::Grammar)

[06:18] <p6eval> rakudo ddaab3: OUTPUT«Perl6::Grammar␤»

[06:18] <sorear> alpha: say pir::typeof__SP(Perl6::Grammar)

[06:18] <p6eval> alpha 30e0ed: OUTPUT«invoke() not implemented in class 'Undef'␤in Main (file <unknown>, line <unknown>)␤»

[06:18] <isBEKaml> Besides, we know where to look for new things, right? ;)

[06:48] <sorear> std: role Foo { after bar() { ... } }

[06:48] <p6eval> std 30632: OUTPUT«===SORRY!===␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/KJEZnpnHcm line 1:␤------> role Foo { after bar() ⏏{ ... } }␤    expecting any of:␤        bracketed infix␤  infix or

[06:48] <p6eval> ..meta-infix␤Undec…

[06:48] <sorear> std: role Foo { after bar() { ... }; }

[06:48] <p6eval> std 30632: OUTPUT«===SORRY!===␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/9OSllPfYFj line 1:␤------> role Foo { after bar() ⏏{ ... }; }␤    expecting any of:␤       bracketed infix␤  infix or

[06:48] <p6eval> ..meta-infix␤Unde…

[06:49] <sorear> does Perl 6 have method modifiers?

[06:51] <colomon> method modifers?

[06:52] <colomon> after is a comparison operator, btw...

[06:52] <isBEKaml> this looks like AOP to me, from what I have briefly worked on them... 

[06:52] *** dual left
[06:52] <isBEKaml> I think sorear wants to call something after some method is executed, something like a listener, perhaps? 

[06:54] <sorear> no, no

[06:54] <sorear> after NAME => SUB is sugar for method NAME { super.NAME; without-changing-return-value (SUB }

[06:54] <sorear> in Moose

[06:55] <sorear> is the Perl 6 class system planned to reach feature parity with Moose at any point?

[06:58] *** dual joined
[07:02] <colomon> I'm not aware of sugar for that.

[07:02] <colomon> I believe callsame should call the super's version of the method.

[07:09] <colomon> seems like the sort of thing which could be easily hacked into the object system with a module?

[07:10] *** iblechbot joined
[07:12] *** JimmyZ left
[07:17] <pugssvn> r30633 | colomon++ | [t/spec] Unfudge tests, add needed sort. 

[07:18] <sorear> colomon: I'm pretty sure I'd need a macro for that

[07:19] <colomon> sorear: woah, too bad no one is working on macros...  ;)

[07:19] * sorear finds the level of disagreement between the Moose and Perl6 communities quite ironic

[07:21] <dalek> rakudo: 82f7ef3 | (Solomon Foster)++ | src/core/Pair.pm:

[07:21] <dalek> rakudo: Add Pair.keys and Pair.values.

[07:21] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/82f7ef3429ff79ea9585d251452c130849770696

[07:29] *** JimmyZ joined
[07:30] * JimmyZ wonders what's the difference between $.key and self.key

[07:45] <sorear> none whatsoever

[08:00] <moritz_> good morning

[08:03] <isBEKaml> moritz_: good morning!

[08:04] <sjohnson> hi

[08:09] *** iblechbot left
[08:09] *** XaeroOne joined
[08:16] <isBEKaml> rakudo: class List { method do_something { for self.kv { .say } } }; List.new.say;

[08:16] <p6eval> rakudo ddaab3: OUTPUT«Illegal redeclaration of symbol 'List'␤current instr.: 'perl6;Perl6;Grammar;_block257' pc 42865 (src/gen/perl6-grammar.pir:265)␤»

[08:17] <isBEKaml> uhh, when was List added in? 

[08:17] <moritz_> pretty early

[08:17] <JimmyZ> nqp: module ResizablePMCArray { method WHO() { 'I\'m an Array'; } }; say(my @a.WHO);

[08:17] <p6eval> nqp: OUTPUT«I'm an Array␤»

[08:18] <isBEKaml> moritz_: so how can I, say, add a new method to the existing List and still reuse it?

[08:18] <moritz_> isBEKaml: yes, that's what 'augment' is for

[08:18] <isBEKaml> moritz_: something like inherit it and add.. 

[08:18] <moritz_> or inheriting, yes

[08:19] <moritz_> though rakudo has problems with augmenting and inheriting from some builtin types

[08:19] <isBEKaml> MONKEY_TYPING? 

[08:20] <isBEKaml> moritz_: like what? is that on RT that I can see?

[08:20] <moritz_> no idea

[08:21] <moritz_> rakudo: augment class Int { method foo  { say "OH HAI" } }; 5.foo

[08:21] <p6eval> rakudo ddaab3: OUTPUT«Can't augment class Int without 'use MONKEY_TYPING'␤current instr.: 'perl6;Perl6;Grammar;add_name' pc 43094 (src/gen/perl6-grammar.pir:344)␤»

[08:21] <isBEKaml> yes, I got something like that already here.

[08:21] <moritz_> rakudo: use MONKEY_TYPING; augment class Int { method foo  { say "OH HAI" } }; 5.foo

[08:21] <p6eval> rakudo ddaab3: OUTPUT«Method 'foo' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[08:21] <moritz_> rakudo: use MONKEY_TYPING; augment class Integer { method foo  { say "OH HAI" } }; 5.foo

[08:21] <p6eval> rakudo ddaab3: OUTPUT«Can't augment class that doesn't exist␤current instr.: 'perl6;Perl6;Grammar;add_name' pc 43094 (src/gen/perl6-grammar.pir:344)␤»

[08:22] <moritz_> I'll report it, just in case

[08:23] <isBEKaml> ok

[08:25] <JimmyZ> rakudo: use MONKEY_TYPING; augment class Str { method Yes() { 'yes, please'; } }; 'No'.Yes().say;

[08:25] <p6eval> rakudo ddaab3: OUTPUT«Method 'Yes' not found for invocant of class 'Perl6Str'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[08:32] <isBEKaml> rakudo: use MONKEY_TYPING; augment class Str { method YES() { 'yes, no, yes'; }; "No".Str.new.YES().say;

[08:32] <p6eval> rakudo ddaab3: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[08:32] <isBEKaml> oh...

[08:32] *** snarkyboojum left
[08:32] <isBEKaml> rakudo: use MONKEY_TYPING; augment class Str { method YES() { 'yes, no, yes'; } }; "No".Str.new.YES().say;

[08:32] <p6eval> rakudo ddaab3: OUTPUT«Null PMC access in get_repr()␤current instr.: 'perl6;Mu;CREATE' pc 2049 (src/builtins/Mu.pir:207)␤»

[08:33] <isBEKaml> moritz_: is this related?

[08:33] *** kaare joined
[08:33] *** kaare is now known as Guest50318

[08:34] *** snarkyboojum joined
[08:34] <moritz_> rakudo: Str.new

[08:34] <p6eval> rakudo ddaab3:  ( no output )

[08:34] <moritz_> rakudo: Str.new.foo

[08:35] <p6eval> rakudo ddaab3: OUTPUT«Method 'foo' not found for invocant of class 'Str'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[08:35] <moritz_> isBEKaml: might be

[08:39] <isBEKaml> rakudo: use MONKEY_TYPING; augment class Str { method YES() { 'yes, no, yes'; } }; Str.new.YES().say;

[08:39] <p6eval> rakudo ddaab3: OUTPUT«yes, no, yes␤»

[08:39] <isBEKaml> yeeesh, I don't understand this at all... :(

[08:40] <moritz_> rakudo: say 'a'.PARROT

[08:40] <p6eval> rakudo ddaab3: OUTPUT«Perl6Str␤»

[08:42] <moritz_> rakudo: say 'a'.Str.new.PARROT

[08:42] <p6eval> rakudo ddaab3: OUTPUT«Null PMC access in get_repr()␤current instr.: 'perl6;Mu;CREATE' pc 2049 (src/builtins/Mu.pir:207)␤»

[08:42] <moritz_> rakudo: say Str.new.PARROT

[08:42] <p6eval> rakudo 82f7ef: OUTPUT«Str␤»

[08:42] <moritz_> so a string literal is less Str'y then a new Str :/

[08:43] <isBEKaml> my thinking was, I'm still calling a method on an instantiated string that's defined in Str class. So why should that fail? 

[08:44] <isBEKaml> this is akin to saying (semantically speaking): Str.new.method is fine but not "somestring".Str.new.method. :/

[08:44] <moritz_> leaky HLL mapping, most likely

[08:44] *** Guest50318 left
[08:45] <moritz_> but I don't understand that aspect of Rakudo at all

[08:47] <JimmyZ> Actions.pm ~= s/Perl6Str/Str/g works, thought I'm not sure whether it's right or not.

[08:49] <moritz_> in line 18 it's certainly not right

[08:50] <JimmyZ> yes, that's not right

[08:50] <isBEKaml> uhh, why are there 2 Str definitions? Perl6Str and Str ? Like one for Parrot and one for p6?

[08:51] <isBEKaml> in 18 and 19

[08:51] <JimmyZ> I changed it in quote_EXPR and quote_delimited

[08:52] *** plobsing left
[08:53] <moritz_> nqp: say(:foo('bar'))

[08:53] <p6eval> nqp: OUTPUT«␤»

[08:53] <moritz_> nqp: say(:foo<bar>)

[08:53] <p6eval> nqp: OUTPUT«␤»

[08:53] <moritz_> nqp: say(:foo<bar>.key)

[08:53] <p6eval> nqp: OUTPUT«Method 'key' not found for invocant of class 'String'␤current instr.: '_block11' pc 0 (EVAL_1:835567572)␤»

[08:55] <JimmyZ> > say 'a'.PARROT

[08:55] <JimmyZ> Str

[08:56] <moritz_> JimmyZ: and can you agument Str locally, and use the new methods?

[08:56] <moritz_> *augment

[08:57] <JimmyZ> do you mean Actions.pm ~= s/Perl6Str/Str/ in in quote_EXPR and quote_delimited? if it is,  yes, I can

[08:59] <isBEKaml> JimmyZ: can you try this?  use MONKEY_TYPING; augment class Str { method YES() { 'yes, no, yes'; } }; "No".Str.new.YES().say;

[09:00] <moritz_> Null PMC access in get_repr()

[09:00] <moritz_> isBEKaml: the problem is that "No".Str.new calls .new on an instance, not on the type object

[09:00] <JimmyZ> isBEKaml: the same as moritz_ 

[09:01] <moritz_> because "No".Str is again an instance

[09:02] <JimmyZ> I can't augment Int

[09:02] <isBEKaml> that can't be right, can it? I mean, we should be able to use methods defined in Str even on instantiated Str objects. 

[09:03] <moritz_> not so sure with .new

[09:03] <moritz_> but if it's not usable, you shouldn't be able to call it

[09:03] <moritz_> you can say "No".WHAT.new and expect it to work

[09:03] <isBEKaml> not sure what you mean. Am I missing something here?

[09:04] <moritz_> jnthn, pmichaud: s:g/Perl6Str/Str/ in methods quote_EXPR and quote_delimited makes calling monkey-typed methods in class Str on string literals work... is it the "right" fix?

[09:05] <moritz_> isBEKaml: .new is meant to create new instance

[09:05] <isBEKaml> moritz_: you mean a new instance of the Str class, not the augmented one?

[09:05] <moritz_> instance = object

[09:06] <moritz_> but an instance/object can have other methods mixed in at run time

[09:06] <moritz_> what would .new on such an object return? one with thew mixed in methods, too? or a pure Str?

[09:06] <isBEKaml> I would expect the one with mixed in methods, since that's what we coded for.

[09:07] <moritz_> if it's supposed to work at all, it needs more spec

[09:11] <JimmyZ> rakudo: use MONKEY_TYPING; augment class Array { method Yes() { "hi"; } };  my @a; say @a.Yes;

[09:11] <p6eval> rakudo 82f7ef: OUTPUT«hi␤»

[09:14] <pugssvn> r30634 | moritz++ | [t/spec] fix bogus test ($! as parameter) 

[09:18] *** orafu joined
[09:21] *** PenThrive left
[09:22] <isBEKaml> moritz_: are namespaces and scoping strictly defined here? We may define augmented classes for existing ones.But if namespaces are clearly demarcated, we can get away with .new methods returning objects of augmented classes and not the existing ones. 

[09:24] <moritz_> augmenting isn't limited to a particular scope, if that's what you are asking

[09:24] <moritz_> apart from that, I don't understand what you're saying

[09:25] <isBEKaml> I mean namespaces as in package level scoping, file level scoping or even block level scoping(if inner classes exist in P6)

[09:28] <isBEKaml> if augmenting is not limited to any scopes, then .new should be able to return instances of any class that we ask for, right? The question is, how do we say we want the augmented class or the pure base class instead of leaving it to the compiler to figure that one out?

[09:28] <moritz_> we always want the augmented class

[09:28] <moritz_> if that wasn't the case, we wouldn't use augmenting, but inheritance

[09:29] <JimmyZ> rakudo: say 5.WHAT; say 5.Hi;

[09:29] <p6eval> rakudo 82f7ef: OUTPUT«Int()␤Method 'Hi' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:30] <moritz_> also after augmenting there is no "original" class anymore

[09:30] <isBEKaml> well, in this case, .new doesn't seem to return the augmented class. "No".Str.new.augmented_method

[09:30] <moritz_> .new isn't supposed to return a class

[09:31] <isBEKaml> terminology always got me before. :(

[09:32] <isBEKaml> here, I mean. "no".Str.new shouldn't return an instance of base Str, but the augmented Str and treat it with the augmented method that we added? 

[09:32] <moritz_> "no" should be augmented already

[09:32] <moritz_> and "no".Str too

[09:34] *** k23z__ joined
[09:36] <isBEKaml> moritz_: heh. I took so long to get here. I now see what you mean. Sorry for all the line noise and thank you very much for your patience. 

[09:36] <moritz_> no problem :-)

[09:36] <isBEKaml> moritz_: I was confused over calling a method on an instance and on the class. :(

[09:37] *** kel_ joined
[09:37] <isBEKaml> moritz_++ ## enormous patience. :)

[09:38] <JimmyZ> Will Num be replaced to Numeric?

[09:39] <JimmyZ> rakudo: use MONKEY_TYPING; augment class Numeric { method Yes() { "hi"; } }; my Num $a; say $a.Yes;

[09:39] <p6eval> rakudo 82f7ef: OUTPUT«Method 'Yes' not found for invocant of class ''␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:40] <JimmyZ> rakudo: use MONKEY_TYPING; augment class Numeric { method Yes() { "hi"; } }; my Numeric $a; say $a.Yes;

[09:40] <p6eval> rakudo 82f7ef: OUTPUT«hi␤»

[09:40] <JimmyZ> afk

[09:40] <moritz_> JimmyZ: Num will continue to exist to abstract floating point numbers

[09:40] <JimmyZ> and Numeric?

[09:40] <moritz_> JimmyZ: and Numeric is a role that all number types will implement

[09:40] <moritz_> so +$thing will try to coerce $thing to Numeric

[09:41] <moritz_> so any type that does Numeric is OK

[09:41] <JimmyZ> ah, ok, thanks

[09:42] <JimmyZ> I just got a mistake

[09:42] <moritz_> isBEKaml: would it be helpful to have a page on Perl 6 terminology?

[09:42] *** JimmyZ left
[09:43] <isBEKaml> yes, glossary of terms. 

[09:43] <isBEKaml> moritz_: we already have glossary.pod in docs?

[09:43] <moritz_> right, I just remembered that

[09:43] <isBEKaml> moritz_: perhaps add more to it?

[09:47] <moritz_> isBEKaml: aye; and render it as HTML somewhere

[09:49] <moritz_> how would you define "instance"?

[09:53] <isBEKaml> moritz_: thinking about it, there's a slight difference between p6's way of calling .new and java's way of calling new. java: class A {...} A anInstance = new A();

[09:53] <moritz_> yes, Perl 6 has type objects

[09:54] <moritz_> ie the class itself is also an object

[09:54] <isBEKaml> moritz_: it's pretty straightforward looking at it, class "A" has all the blueprint of methods and anInstance carries it forward into the real world. 

[09:54] <isBEKaml> moritz_: ie. you cannot use class "A" per se unless it's a static class. 

[09:56] <moritz_> isBEKaml: I'll put that into the glossary

[09:56] <isBEKaml> now thinking about how I erred in p6's way: "A".Str.new.method_augmented() --> "A".Str.new actually presents a blank state to the method and hence we see Null PMC access. Am I right?

[09:56] <moritz_> not sure; it's a bit more complicated with value types (and I'm a bit confused by other stuff atm)

[09:57] <isBEKaml> moritz_: can we represent the glossary like a plain text file ( a la *nix fortunes)

[09:58] <moritz_> isBEKaml: should be easy, with pod2text

[09:59] <moritz_> std: my $x = class {  }

[09:59] <p6eval> std 30634: OUTPUT«ok 00:01 113m␤»

[10:00] <isBEKaml> moritz_: my p5.10's pod2text got confused by multiple =head1 tags.. 

[10:01] <moritz_> isBEKaml: more likely by the =begin glossary... =end glossary

[10:01] <isBEKaml> Shouldn't be  problem though.. 

[10:02] <moritz_> grep -vE '^=(begin|end)' glossary.pod | pod2text

[10:06] <moritz_> phenny: ask masak if there's any tool that used the =begin glossary marker in docs/u4x/documentation - if not I'd like to remove it, because then it happens to be valid perl 5 POD, and easier for me to process :-)

[10:06] <phenny> moritz_: I'll pass that on when masak is around.

[10:11] <isBEKaml> moritz_: the problem is, I don't find =begin or =end in the pod text. where's it used actually?

[10:11] <isBEKaml> grep -E '=(begin|end)' glossary.pod returned nothing

[10:12] <moritz_> are we talking about the same file?

[10:12] <isBEKaml> so did this: fgrep -e '^=(begin|end)' *.pod

[10:12] <moritz_> docs/u4x/documentation/glossary.pod

[10:12] <moritz_> in the pugs repo

[10:12] <isBEKaml> Ah, I see. not the same file. 

[10:13] <moritz_> now I'm curious, which one did you look at?

[10:13] <isBEKaml> git pulled rakudo docs file. 

[10:15] <isBEKaml> http://github.com/rakudo/rakudo/blob/master/docs/glossary.pod

[10:15] <moritz_> yes

[10:15] <moritz_> that's pretty... skinny

[10:15] <moritz_> and rakudo specific

[10:16] <isBEKaml> hmm, then I'll check out u4x. 

[10:17] <isBEKaml> u4x's glossary has only 4 terms? 

[10:17] <moritz_> did you svn up?

[10:17] <moritz_> should be 6 or so :-)

[10:17] <isBEKaml> http://svn.pugscode.org/pugs/docs/u4x/documentation/

[10:18] <moritz_> oh

[10:18] <moritz_> I fogot to svn dcomiit

[10:18] <isBEKaml> :)

[10:18] <pugssvn> r30635 | moritz++ | [docs] an anonymous sub can have a name, in fact 

[10:18] <pugssvn> r30636 | moritz++ | [docs] expand glossary, and restore alphabetical order; contains a nice description of instances by isBEKaml++ 

[10:18] <pugssvn> r30637 | moritz++ | [t/spec] some Rakudo unfudges 

[10:21] <isBEKaml> nice. we'll add more to it when we see them coming. :)

[10:21] <isBEKaml> so, here's to more clarity out of chaos! ;)

[10:23] <isBEKaml> moritz_: There's a small typo in instances, I think. most types are defiC<defined($instance)>

[10:23] <isBEKaml> defiC<de...

[10:23] <moritz_> isBEKaml: could you please fix it?

[10:24] <moritz_> I hope you have commit access already?

[10:24] <isBEKaml> I don't have a commit bit. 

[10:24] <moritz_> high time to change that

[10:24] <moritz_> please tell me your email address (in private message, if you wish) and desired svn nick

[10:26] <isBEKaml> moritz_: I hope you got my private msg?

[10:26] <moritz_> isBEKaml: yes; mail sent

[10:26] <moritz_> isBEKaml: welcoem to the pugs repo; please add yourself to AUTHORS in your first commit

[10:27] <isBEKaml> moritz_: cool. traditional first commit to AUTHORS? :)

[10:27] <moritz_> yes

[10:31] <pugssvn> r30638 | moritz++ | [docs/u4x] small p5 script to render u4x docs into HTML 

[10:34] <moritz_> so, what shall we call the domain? docs.perl6.org? or doc? u4x?

[10:35] <moritz_> funny, python has python.org/doc/ and docs.python.org

[10:35] <isBEKaml> docs.perl6.org - for perl6's documentation page. Since this is u4x, this will always be u4x. u4x.perl6.org

[10:35] <moritz_> and php has phpdoc.org, and php.org/docs/

[10:36] <moritz_> ok, will do after breakfast :-)

[10:36] *** lestrrat is now known as lest_away

[10:36] <arnsholt> I vote for a single URL, at least

[10:37] <arnsholt> docs. might be easier for newcomers to remember than u4x.

[10:37] <isBEKaml> u4x is special! ;)

[10:38] <isBEKaml> As somebody once said, everyday will be X'Mas once Perl6 is out. 

[10:38] *** drake1 joined
[10:38] <arnsholt> I think that was audreyt

[10:40] <pugssvn> r30639 | svatsan++ | First traditional commit to AUTHORS 

[10:40] <isBEKaml> yay! :)

[10:40] <drake1> hello, why not allow sed like array subscripts?

[10:41] <arnsholt> What do those look like? I'm not really familiar with sed

[10:41] <drake1> like @array[3,$] to extract from element 3 to the last element

[10:41] <arnsholt> It'll be possible to slice an array from one place to the end. Can't remember the syntax off-hand though

[10:42] <drake1> in perl6?

[10:43] <drake1> in sed you can also address based on grep like patterns like @array[/from pattern/,/to pattern/]

[10:44] <arnsholt> How does that last work? Matches don't return anything int-like

[10:45] <drake1> in sed it would apply the subsequent commands to the range of elements in between the first and the last match

[10:46] <arnsholt> I think that's very sed-specific

[10:46] <drake1> but it's a nice feature

[10:46] <moritz_> drake1: that would be [3..*] in Perl 6

[10:46] <drake1> perl is more for the .. that , though

[10:47] <drake1> s,that,than

[10:47] <drake1> 3..* is from element three to the last?

[10:48] <drake1> actually it's not sed specific

[10:48] <drake1> ed uses similar semantics

[10:48] <isBEKaml> moritz_: would it be right to say  a non-zero value holds to be True for Boolean?

[10:48] <isBEKaml> or do we have a specific True for Booleans?

[10:49] <isBEKaml> rakudo: my Str $temp="hello"; say defined($temp);

[10:49] <p6eval> rakudo 82f7ef: OUTPUT«1␤»

[10:49] <isBEKaml> moritz_: IIRC, that was how it was in p5. 

[10:53] <snarkyboojum> say ?"hello"

[10:53] <snarkyboojum> rakudo: say ?"hello"

[10:53] <p6eval> rakudo 82f7ef: OUTPUT«1␤»

[10:54] <drake1> in perl6 you would proably have to say: @array2 = grep /from pattern/../to pattern/, @array1

[10:56] <snarkyboojum> rakudo: say ?''; say ?Nil; say ?Any

[10:56] <p6eval> rakudo 82f7ef: OUTPUT«0␤0␤0␤»

[11:00] <isBEKaml> snarkyboojum: I was referring to the case when we instantiate an object of a class/ or a native type class like Str and call defined() on them. They always return 1. So I was asking if 1 meant True or we have a separate Boolean type for that. 

[11:03] <moritz_> rakudo: say True.perl

[11:03] <p6eval> rakudo 82f7ef: OUTPUT«Bool::True␤»

[11:03] <moritz_> isBEKaml: we have enum Bool <False True>

[11:04] <moritz_> isBEKaml: remember to fix that typo :-)

[11:05] <isBEKaml> moritz_: yeah, I was looking to fix that typo and was thinking of providing a small snippet to show defined($instance). Was unsure when I saw "1" returned. 

[11:05] <isBEKaml> :)

[11:05] <moritz_> True stringifies to '1'

[11:05] <moritz_> rakudo: say True

[11:05] <p6eval> rakudo 82f7ef: OUTPUT«1␤»

[11:05] <moritz_> you can always use

[11:06] <Trashlord> Peyote Sound System - Aqua Dub

[11:06] <moritz_> if defined($instance) { say "OH YES" }

[11:06] <Trashlord> er, wrong channel, sorry about that

[11:07] <drake1> until cond;do .... hehe

[11:07] <snarkyboojum> rakudo:  class A {}; A.new.defined.perl.say

[11:07] <p6eval> rakudo 82f7ef: OUTPUT«Bool::True␤»

[11:08] <snarkyboojum> rakudo: (~True).perl.say

[11:08] <p6eval> rakudo 82f7ef: OUTPUT«"1"␤»

[11:08] <snarkyboojum> :)

[11:09] <cognominal> jonathan,  suppose I declare    my ($pos, $pos-args, $named-args);   than I use ($pos, $pos-args, $named-args) many times in lhs. Is this possible to use your pattern signature stuff to avoid repeating my self?

[11:09] <isBEKaml> I now understand why documentation is tough. We have to think what to include and what not to so as not to confuse the reader. :)

[11:09] <bacek> rakudo: my Int $a = 42; say $a;

[11:09] <p6eval> rakudo 82f7ef: OUTPUT«42␤»

[11:09] <cognominal> *then

[11:10] <drake1> oh it's getting alot closer to C++ then

[11:10] <drake1> with explicit storage declarations

[11:10] <cognominal> that would be patterns as replacement for ala C textual macros

[11:12] <cognominal> I suppose jonathan is geeklagged :)

[11:12] <moritz_> cognominal: my $sig = \($pos, $pos-args, :$named-args); or something

[11:12] <moritz_> erm

[11:12] <moritz_> :($pos, $pos-args, ...)

[11:13] <moritz_> so create a signature

[11:13] <cognominal> I meant jnthn 

[11:13] <drake1> in perl6 is a reference to an integer the same as a pointer to one?

[11:14] <moritz_> we officially have abolished pointers in Perl 6 :-)

[11:14] <cognominal> I will try it. I just have more success when I have the moral support of a true hacker

[11:14] <drake1> but your type declarations seem similar

[11:14] <snarkyboojum> no "references" per se either right moritz_ ?

[11:14] <drake1> really

[11:14] <moritz_> well, to some degree everything is a reference

[11:15] <drake1> references made many things easy

[11:15] <snarkyboojum> right

[11:15] <snarkyboojum> do mean along the lines of 'anything can be stored in a scalar'?

[11:16] <drake1> that was the trick; that references could be stored as scalar values

[11:16] <moritz_> rakudo: my @a = 1, 2, 3; @a[1] = <foo bar baz>; say @a.perl

[11:16] <p6eval> rakudo 82f7ef: OUTPUT«[1, ("foo", "bar", "baz"), 3]␤»

[11:17] <snarkyboojum> rakudo: my @list = 1, 2, 3; my $ref = @list; say $ref.elems

[11:17] <p6eval> rakudo 82f7ef: OUTPUT«3␤»

[11:17] <snarkyboojum> I shouldn't have called that $ref :)

[11:18] <cognominal> rakudo:  my $sig = \( $a, $b); $sig = ( 1, 2); say "$a$b" 

[11:18] <p6eval> rakudo 82f7ef: OUTPUT«Symbol '$a' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[11:18] <snarkyboojum> rakudo: my @list = 1, 2, 3; my $ref = @list; say $ref.WHAT

[11:18] <p6eval> rakudo 82f7ef: OUTPUT«Array()␤»

[11:19] <pugssvn> r30640 | svatsan++ | [u4x docs] Fixed minor typo and added examples to section on instances 

[11:20] * cognominal is clearly cargoculting

[11:20] *** xomas_ joined
[11:21] *** xomas_ is now known as xomas

[11:21] <cognominal> and if cargos will ever land, that will be on my poor head.

[11:22] <drake1> gotta write a C99 version of a perl5 server daemon

[11:23] <pugssvn> r30641 | moritz++ | [u4x/scripts] account for current script location in path 

[11:24] <moritz_> http://u4x.perl6.org/control-flow.html

[11:24] <drake1> rakuda: my $integer_ref = \123;say ${$integer_ref}

[11:25] <drake1> oh

[11:25] <moritz_> it would be $(...) in Perl 6, if any

[11:25] <isBEKaml> drake1: s/uda/udo/ ;)

[11:25] <drake1> oops heheh

[11:26] <cognominal> I bet a synopsis dedicated about Signature, Capture and other Parcels is warranted, as well as binding using :=

[11:26] <drake1> rakudo: my $intp = \123;say $$intp

[11:26] <p6eval> rakudo 82f7ef: OUTPUT«Confused at line 11, near "say $$intp"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:26] <moritz_> rakudo: my $intp = \123; say $($intp)

[11:26] <drake1> wicked

[11:26] <p6eval> rakudo 82f7ef: OUTPUT«Capture()<0x3725d40>␤»

[11:27] <moritz_> but there's really no good reason to use an explicit capture of a single scalar

[11:27] <cognominal> ...because  that subjet somehow becomes orthogonal to routines.

[11:28] <drake1> many of my own routines are macro substitution

[11:28] <moritz_> ... and?

[11:29] <drake1> then explitic usage becomes important

[11:31] <moritz_> so what would you use explicit captures of a single variable for?

[11:31] <pmichaud> synopsis about signature:  S06

[11:31] <pmichaud> synopsis about Capture and Parcels:  S07

[11:31] <drake1> moritz: probably nothing

[11:31] <pmichaud> don't believe anything you currently read in S07 :-)

[11:32] <pmichaud> oops, s/S07/S08/

[11:32] * moritz_ doesn't

[11:32] <pmichaud> actually, much of S07 is in flux as well :-)

[11:32] <cognominal> pmichaud++  # I forgot it was already there

[11:32] <moritz_> pmichaud: btw your "wholly inadequate reply to an Anonymous Monk" is ranked as second-best node of the year on perlmonks

[11:33] <pmichaud> moritz_: wow, I didn't know that.  Good to know.

[11:33] <pmichaud> (I didn't even know that such statistics were available :-)

[11:33] <moritz_> http://www.perlmonks.org/?node=Best Nodes

[11:34] <moritz_> http://www.perlmonks.org/?node=Best%20Nodes # with proper URL escaping

[11:34] <moritz_> (it's also best of the month, but that's much easier to achieve)

[11:34] <isBEKaml> moritz_: the HTMLified control-flow docs has turned out good. Could be made more awesome. (no, I'm not thinking perldoc.perl.org, heavy on my poor little machine)

[11:35] <moritz_> isBEKaml: if nobody steps up to awesomeify it here, I'll make it another "This Week's Contribution to Perl 6"

[11:35] <moritz_> :-)

[11:35] <moritz_> and TPF has greed to sponsor a few t-shirts to the new contributors

[11:35] <moritz_> so everybody wins :-)

[11:35] <isBEKaml> moritz_++ ## awesomeness++

[11:36] <pmichaud> afk, errands

[11:36] <drake1> Im more for the cat <<EOF |ed t-sthirt

[11:41] <isBEKaml> moritz_: easily done. All that's needed a single style.css that can accomodate all the tags without even having to modify them. :)

[11:41] <moritz_> isBEKaml: feel free to put it in u4x/scripts

[11:42] <pugssvn> r30642 | moritz++ | [helpnow] update REAMDE, new idea (awesomify u4x.perl6.org) 

[11:42] <drake1> then it's just: /^.IM print.format 22,23/s/23/24/ to adjust the position

[11:42] <moritz_> diakopter, colomon: you are listed as potential voluntueers in misc/helpnow/README... do you want to create next week's challenge?

[11:43] <colomon> hmm

[11:44] * colomon is trying to remember what ideas he had through a groggy sleep-deprived brain....

[11:44] <colomon> s/through/with/

[11:44] <moritz_> colomon: the README also has some ideas

[11:44] <moritz_> colomon: and there's no need to settle for one today

[11:44] <isBEKaml> moritz_: port a smallish module. I like that!

[11:45] <isBEKaml> not too easy. not too hard either. 

[11:45] <moritz_> isBEKaml: yes, but we'd have to think of a smallish module that can easily be ported

[11:45] *** xomas left
[11:45] <isBEKaml> then somebody would come up with YOU_ARE_HERE.pm and E2MUCHMAGIC. :)

[11:46] <moritz_> I thought of List::Util, but it contains only one function that's not core in Perl 6 :-)

[11:46] <moritz_> Date::Simple is already ported

[11:47] <drake1> perls new pattern caret and dollar isn't line-feed oriented by default, right?

[11:47] *** clintongormley joined
[11:47] <moritz_> right

[11:48] <drake1> nice

[11:48] <moritz_> ^ stands for start-of-string

[11:48] <isBEKaml> Log::Message? Should be easy right?

[11:48] <moritz_> ^^ stands for start-of-line

[11:48] <drake1> thats really nice

[11:48] <moritz_> isBEKaml: that's a good idea... I just haven't used it yet

[11:49] <isBEKaml> moritz_: enough to hold interest for the weekend. :)

[11:50] <colomon> moritz_: what one function in List::Util isn't core?

[11:50] <moritz_> colomon: first

[11:50] <colomon> that's like grep but returning only the first match?

[11:51] <moritz_> right

[11:51] <colomon> that's in CORE.

[11:51] <moritz_> it is?

[11:51] <moritz_> rakudo: say <a b c >.first(b|c)

[11:51] <p6eval> rakudo 82f7ef: OUTPUT«Could not find sub &b␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[11:51] <colomon> line 27 any-list.pm

[11:51] <moritz_> rakudo: say <a b c >.first("b"|"c")

[11:51] <p6eval> rakudo 82f7ef: OUTPUT«any("b", "c")␤»

[11:51] <moritz_> now that looks wrong

[11:52] <colomon> rakudo: say <a b c >.first("b")

[11:52] <p6eval> rakudo 82f7ef: OUTPUT«b␤»

[11:52] <isBEKaml> rakudo: say <a b c b d e>.first("b")

[11:52] <p6eval> rakudo 82f7ef: OUTPUT«b␤»

[11:52] <drake1> <a b c> is for a list object?

[11:52] <colomon> rakudo: say (1... 10).first({ * !% 3})

[11:52] <moritz_> drake1: yes

[11:52] <p6eval> rakudo 82f7ef: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[11:52] <isBEKaml> again, shouldn't that be returning an index or something?

[11:52] <drake1> moritz: nice

[11:53] <colomon> rakudo: say (1... 10).first({ $_ !% 3})

[11:53] <moritz_> the problem is that the argument isn't Mu

[11:53] <p6eval> rakudo 82f7ef: OUTPUT«3␤»

[11:53] <moritz_> so List.first autothreads

[11:53] <drake1> moritz: sometimes blank separation is gettin cumbersome in the shell

[11:53] <colomon> moritz_: we should have a test about that.

[11:53] *** xomas_ joined
[11:53] <colomon> but clearly first should take the same argument as grep.

[11:53] <moritz_> colomon: aye; I'm spectesting my fix right now

[11:53] <colomon> moritz_++

[11:54] <isBEKaml> colomon, moritz_: when calling on first(), shouldn't the default output be the string itself with the _index_ in the list/string?

[11:54] <moritz_> isBEKaml: that's not what the spec says

[11:55] <moritz_> that would be first_index from List::MoreUtils

[11:55] <moritz_> that said, we could have :key and :pair named args

[11:55] *** wknight8111 joined
[11:55] <moritz_> where :key returns the index, and :pair returns an index => value pair

[11:55] <isBEKaml> moritz_: key-value pairs are a good idea. TimToady++

[11:59] <drake1> how to create an array with all the filenames in a directory? like my @name = <*>; or something new?

[11:59] <moritz_> my @name = glob '*'; # probably

[11:59] <drake1> fine

[12:00] <drake1> I do for F in $(ls|grep ...) alot

[12:00] <pugssvn> r30643 | moritz++ | [t/spec] the "first" sub/method should also work with a junction as matcher 

[12:00] <drake1> but that isn't standard glob

[12:00] <moritz_> you have regexes in Perl 6 too :-)

[12:01] <isBEKaml> drake1: don't you use *nix find at all?

[12:01] <drake1> yeah but `glob' is bourne shell name substitution patterns?

[12:01] *** JimmyZ joined
[12:02] <isBEKaml> drake1: from what I have seen, passing the output of ls to for loops in shell can cause problems, if you don't know they cointain shell special chars..

[12:02] <drake1> isBEKaml: I don't use `find

[12:02] <drake1> ' alot, no\

[12:02] <drake1> isBEKaml: that's true

[12:03] <isBEKaml> drake1: then use it. that's better than passing around ls outputs to for loops. 

[12:03] <drake1> isBEKaml: because the stream needs a separation character to distinguish a name element

[12:03] *** jhuni left
[12:04] <isBEKaml> drake1: exactly what I meant. I can't tell you how many backups I lost due to that until I found out about find. :)

[12:05] <drake1> isBEKaml: when you don't work in a clean directory is can be a pain

[12:05] <drake1> s,is can,it can

[12:06] <isBEKaml> nothing's clean. you just work with what you got. just using the right tools can get the job done most of the time. 

[12:06] <drake1> isBEKaml: but `find' can use NUL separation in the stream and cpan has a perl specific version

[12:06] <drake1> isBEKaml: yeah, I always end up with a C rock

[12:07] <isBEKaml> drake1: if you're referring to File::Find, that's limited in scope compared the Shell's find utility. Some have suggested File::Find::Object instead. 

[12:07] <moritz_> file, File::Find is quite nice, but needs getting used to

[12:07] <drake1> isBEKaml: then it's all matching exactly the memory

[12:07] <isBEKaml> though I have used neither. 

[12:07] <moritz_> File::Find is actually just a directory iterator

[12:07] <moritz_> and you provide a closure that takes a filename + path

[12:07] <drake1> it don't do stat?

[12:08] <moritz_> it does readdir

[12:08] <moritz_> why should it do stat?

[12:08] <drake1> recursively on directory entries?

[12:08] <moritz_> ah, right

[12:08] <dalek> rakudo: 16e9537 | moritz++ | src/core/Any-list.pm:

[12:08] <dalek> rakudo: accept junctions as matcher argument to first()

[12:08] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/16e953764af25049b22f04f76a88a398f7481807

[12:08] <moritz_> it does that

[12:08] <drake1> ok

[12:11] <isBEKaml> moritz_: Text::Wrap is anothe rsmallish module that can be ported though I don't know how useful it would be in p6 (wrt unicode handling). just a plain exercise? 

[12:11] <moritz_> Text::Wrap might be a good candidate

[12:12] <isBEKaml> yeah, that's small at around 200 lines. 

[12:12] <moritz_> ah cool

[12:13] <moritz_> it's a ... condensed Perl 5 code

[12:13] <moritz_> but there's no need to copy the implementation

[12:14] <isBEKaml> yeah, very small enough to hold in your head for a couple of hours. :)

[12:15] <isBEKaml> I was unsure how useful it would be in p6.. 

[12:15] <moritz_> I am, too

[12:15] <moritz_> but still it's a nice idea for porting

[12:17] <arnsholt> A question about R*: Is it going to distribute a set of working modules as well? (My memory can't decide what I've heard and not)

[12:17] <moritz_> arnsholt: I think it wll

[12:17] <moritz_> *will

[12:18] <drake1> so far I only have a shell escape with perl in the bin

[12:18] <arnsholt> Right. Then the second question: what's the current rough estimate on when it'll be released?

[12:18] <moritz_> June

[12:19] *** iblechbot joined
[12:21] <pmichaud> June.

[12:23] <drake1> do you think it's better with a perl module for environment parameters or is @ARGV alright?

[12:23] <arnsholt> Right. I've got the beginnings of a HMM decoder module that might be nice for R*, but June might be a bit early to get it done

[12:23] <drake1> environment parameters / header information

[12:24] <arnsholt> (I need to get my exams and papers done before I can really get some work done on it)

[12:27] *** _kiss joined
[12:29] *** _kiss left
[12:34] *** TiMBuS joined
[12:34] <drake1> like execve("/usr/bin/perl",parameters versus use module; module.getparam

[12:39] <drake1> alternatively the perl system could be loaded all the time with modularized IPC

[12:41] <drake1> except I don't know how complicated that would become

[12:48] <drake1> perl would probably prefer a separate parallel task

[12:49] <snarkyboojum> rakudo: my $a = ...

[12:49] <p6eval> rakudo 16e953: OUTPUT«No exception handler and no message␤current instr.: '&fail' pc 18021 (src/builtins/Junction.pir:481)␤»

[12:49] <snarkyboojum> std: my $a = ...

[12:49] <p6eval> std 30643: OUTPUT«ok 00:01 113m␤»

[12:50] <drake1> did you write a doc on the module interface for C code?

[12:52] <drake1> would be pretty awesome to allow access to the shared server page

[12:55] *** am0c joined
[12:59] <drake1> if I only knew how to set the function address and to pass a scalar perl could run all the time

[13:01] <snarkyboojum> rakudo: sub test; say "hi";

[13:01] <p6eval> rakudo 16e953: OUTPUT«Symbol '$ss_SS_S_S__S_S_s' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[13:01] <snarkyboojum> std: sub test; say "hi";

[13:02] <p6eval> std 30643: OUTPUT«===SORRY!===␤Missing block at /tmp/kl6SqnrhQu line 1:␤------> sub test⏏; say "hi";␤    expecting any of:␤ block␤  new name to be defined␤     routine_def␤     trait␤Parse failed␤FAILED 00:01 112m␤»

[13:03] <snarkyboojum> interesting rakudo error there :)

[13:04] <drake1> while(read(0,func,1) { perl_func(AUTO_FUNC_MACRO,args); } or similar

[13:04] <snarkyboojum> or error *message* I should say

[13:04] <moritz_> snarkyboojum: has to do with p6eval 

[13:04] <moritz_> snarkyboojum: try it locally

[13:04] <snarkyboojum> moritz_: oh ok

[13:05] <snarkyboojum> moritz_++ # more sane - Could not find sub &test

[13:08] <drake1> what's the easiest way to let perl work like an interactive shell with symbolic integer input?

[13:09] <drake1> instead of ascii commands

[13:09] <moritz_> uhm, are integers not represented in ascii?

[13:10] <dalek> nqp-rx: 08a765d | pmichaud++ | src/NQP/ (2 files):

[13:10] <dalek> nqp-rx: Add typename parsing to variable declarations.

[13:10] <dalek> nqp-rx: (The typenames don't do anything yet, we just ignore them after parsing.)

[13:10] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/08a765d71271b3294422c70f7d1c5f9307583a0b

[13:10] <dalek> nqp-rx: cf979eb | pmichaud++ | src/NQP/Grammar.pm:

[13:10] <dalek> nqp-rx: Enable typename parsing for parameters.  Again, this simply

[13:10] <dalek> nqp-rx: parses the typenames, nothing is being done with the typenames

[13:10] <dalek> nqp-rx: for now.

[13:10] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/cf979eb814e41cf48c5597c3596968b9f8a4ef4b

[13:10] <drake1> yeah, bit I wan't to be able to write an integer and let perl understand the symbolic meaning

[13:10] <drake1> s,bit,but

[13:10] <moritz_> rakudo: say 345

[13:10] <p6eval> rakudo 16e953: OUTPUT«345␤»

[13:10] <moritz_> rakudo: say chr(65)

[13:10] <p6eval> rakudo 16e953: OUTPUT«A␤»

[13:12] <drake1> so I need to find out how to read four characters and associate them with a function

[13:12] <moritz_> I still don't understand what you're trying to achieve

[13:12] <moritz_> represent a program by a list of its ascii character values?

[13:12] <drake1> a parallel functional interface from perl to any other language

[13:13] <drake1> moritz: so perl input pipe can be used for IPC

[13:14] <jnthn> pmichaud: Ooh...interesting commits. ;-)

[13:14] <jnthn> o/ all

[13:14] <moritz_> \o

[13:14] <isBEKaml> hi jnthn 

[13:14] <jnthn> cognominal: It's possible augment ($foo, $bar) := blah() # may do what you want

[13:14] <drake1> moritz: and so perl can access "our" shared server page via module extensions

[13:14] <moritz_> drake1: something like mod_perl / mod_parrot?

[13:14] <jnthn> rakudo: sub foo() { return 1,2,:c<3> }; my ($a, $b, :$c) := foo(); say "$a $b $c"

[13:14] <p6eval> rakudo 16e953: OUTPUT«1 2 Any()␤»

[13:15] <drake1> moritz: yes, but for a completely different system with separate task allocation for perl

[13:15] <moritz_> jnthn: would have been more impressive if it actually worked :-)

[13:15] <jnthn> Curious...

[13:15] <jnthn> moritz_: I thought it did...I thought it was tested too. :-|

[13:16] <moritz_> rakudo: sub foo() { return (1,2,:c<3>) };  my ($a, $b, :$c) := foo(); say "$a $b $c"

[13:16] <p6eval> rakudo 16e953: OUTPUT«1 2 3␤»

[13:16] <moritz_> jnthn: return() probably ignores named args

[13:16] <drake1> moritz: the module should then be able to fetch the page reference from the environment parameters and get the semaphore via C code

[13:16] <moritz_> jnthn: .sub '&return' .param pmc retvals :slurpy

[13:16] <jnthn> moritz_: It shouldn't transform it to a named arg, though

[13:17] <jnthn> moritz_: return takes only a parcel

[13:17] <jnthn> (There's some compiler magic to handle that.)

[13:17] <jnthn> rakudo: sub foo() { return 1,2,:c<3> }; my ($a, $b, $c) := foo(); say "$a $b $c"

[13:17] <p6eval> rakudo 16e953: OUTPUT«1 2 Any()␤»

[13:17] <jnthn> hm

[13:18] <jnthn> rakudo: sub foo() { return 1,2,:c<3> }; my ($a, $b, $c) = foo(); say "$a $b $c"

[13:18] <p6eval> rakudo 16e953: OUTPUT«1 2 c      Any()␤»

[13:18] <moritz_> rakudo: sub foo() { return 1,2,:c<3> }; say foo().perl

[13:18] <p6eval> rakudo 16e953: OUTPUT«(1, 2, "c" => Any)␤»

[13:18] <jnthn> er.

[13:18] <moritz_> er. is a good comment

[13:18] <jnthn> OK, so it's not the unpacking that's broken after all.

[13:18] <jnthn> rakudo: sub foo() { return 1,2,:c(3) }; my ($a, $b, $c) = foo(); say "$a $b $c"

[13:18] <p6eval> rakudo 16e953: OUTPUT«1 2 c      Any()␤»

[13:19] <cognominal> hum, so := is in rakudo, whatever it does...

[13:19] <jnthn> rakudo: sub foo() { return 1,2,c=>3 }; say foo().perl

[13:19] <p6eval> rakudo 16e953: OUTPUT«(1, 2, "c" => Any)␤»

[13:19] * moritz_ submits rakudobug

[13:19] <isBEKaml> rakudo: 'sub foo() { return 1,2,{:c(3)} }; my ($a, $b, $c) = foo(); say "$a $b $c";

[13:19] <p6eval> rakudo 16e953: OUTPUT«Confused at line 11, near "'sub foo()"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[13:19] <jnthn> rakudo: sub foo() { return c=>3 }; say foo().perl

[13:19] <p6eval> rakudo 16e953: OUTPUT«"c" => Any␤»

[13:19] <isBEKaml> rakudo: sub foo() { return 1,2,{:c(3)} }; my ($a, $b, $c) = foo(); say "$a $b $c";

[13:19] <p6eval> rakudo 16e953: OUTPUT«1 2 c      3␤␤»

[13:20] <isBEKaml> funnily enough, it gave out the value when I put in curlies as a blockoid. :)

[13:20] <moritz_> rakudo: sub foo() { return 1,2,{:c(3)} }; say foo().perl

[13:20] <p6eval> rakudo 16e953: OUTPUT«(1, 2, {"c" => 3})␤»

[13:20] <moritz_> because it's a (positional) hash, not a named argument

[13:22] <isBEKaml> hmmm, so return with multiple values translates to either a list or an hash. 

[13:22] <moritz_> not either

[13:22] <moritz_> a Parcel

[13:22] <moritz_> which has both listy and hashy characteristics

[13:23] *** cls_bsd left
[13:23] *** cls_bsd joined
[13:23] <moritz_> or was that a Capture?

[13:23] * moritz_ sighs

[13:23] <moritz_> capture, probably

[13:24] <isBEKaml> I don't know about Parcels yet. 

[13:24] *** cls_bsd left
[13:24] * moritz_ neither, sadly

[13:24] <jnthn> moritz_: return hands back a Parcel

[13:24] * isBEKaml goes looking at S08, but finds it under [draft]

[13:24] <jnthn> When you do my (...some sig) := foo(); then the Parcel from foo is coerced into a capture

[13:24] <jnthn> *Capture

[13:25] <jnthn> It's that coercion that makes the paris in the Parcel into nameds.

[13:25] <jnthn> When you do a call normally, we just make a Capture right away though - return is special (in fact, in theory everything with a signature of :(\|$parcel)

[13:28] *** pmurias joined
[13:28] *** cls_bsd joined
[13:28] <isBEKaml> so whenever we bind my ($...) := foo_method(), the method returns a parcel but how about routinely defined subs that return ($...); ?

[13:28] <moritz_> every routine returnes a Capture

[13:29] <moritz_> which is supposed to flatten in list context

[13:29] *** cls_bsd left
[13:29] <isBEKaml> jnthn: my ($a, $b,$c) = foo(); but foo() here has the last return statement; return ($x,$y,$z);

[13:29] <isBEKaml> Capture inlist context?

[13:29] <drake1> := is for immediate evaluation?

[13:29] <moritz_> sorry, I'm being confusing

[13:29] <pugssvn> r30644 | moritz++ | [t/spec] tests for RT #75118, named arguments to return() 

[13:29] <moritz_> drake1: := is for binding

[13:29] <drake1> ok

[13:30] <jnthn> I'd imagine return ($x,$y,$z); and return($x, $y, $z) work the same was as they do with function calls, since really you're just making a call to return.

[13:30] <drake1> in `make' := means immediate whereas = means to first evaluate at substition

[13:31] * jnthn afk for a bit

[13:33] *** cls_bsd joined
[13:34] <isBEKaml> jnthn: I don't understand... " return ($x,$y,$z); and return($x, $y, $z) work the same " I must have missed something... What's the difference between the two? 

[13:34] <moritz_> the spec

[13:34] <moritz_> *space

[13:34] * moritz_ fights with the lag monster

[13:34] <isBEKaml> jnthn: sub foo() { ... return ($x, $y,$z); } my ($a,$b,$c) = foo() ## this is a simple method call? no capture/parcel here?

[13:35] <isBEKaml> moritz_: that's significant? :O

[13:35] <moritz_> yes

[13:35] *** christine left
[13:35] <moritz_> foo (1, 2, 3); # calls foo with one argument, which is a Parcel of 3 items

[13:35] <moritz_> foo(1, 2, 3); # calls foo with three arguments

[13:36] <isBEKaml> for a moment, I thought you were joking. ;)

[13:36] <moritz_> I'm not

[13:37] *** christine joined
[13:38] *** meteorjay left
[13:43] <drake1> maybe I should add a bit to my hoebrew conf language like the ability to say: PARAM=$(1)sepchar$(2); STRING=~ /(cap1)otherset(cap2)/$PARAM hehe

[13:43] *** meteorjay joined
[13:43] <drake1> but I don't need it

[13:43] <isBEKaml> moritz_: you're right. We lose free form with subs. I used to write method name with params on the next line. Should remind myself to write them on the same line... 

[13:44] <moritz_> isBEKaml: Perl 6 is still mostly free form

[13:44] <isBEKaml> moritz_++ ## spaced clarification. :)

[13:44] <isBEKaml> moritz_: yes, *mostly*

[13:44] <moritz_> isBEKaml: it never makes a difference if you have 1 or 10 spaces in a particular place

[13:45] <moritz_> just non vs. some makes a difference

[13:45] <moritz_> and that's true in Perl 5 too, but in less spots

[13:46] <moritz_> and I think it's very sane that Perl 6 forbids the space after the sigil

[13:46] <moritz_> buubot: eval: my $x = 3; $ x + $x

[13:46] <buubot> moritz_: 6     

[13:46] <isBEKaml> yes, but sub method-name\n(params) is no more usable approach. 

[13:46] <moritz_> there are two solutions

[13:46] <moritz_> three, actually

[13:47] <moritz_> 1) method-name(\n params)

[13:47] <moritz_> 2) method-name:\n params

[13:47] <moritz_> 3) method-name\\n(params)

[13:47] <moritz_> I like 2) best

[13:48] <drake1> how is the new evaluation syntax for perl6 patterns?

[13:48] <isBEKaml> wow, I can still have place holders to say there's more to come! yay! :)

[13:48] <isBEKaml> I actually like the first way, though I can use 2 too.. 

[13:49] <drake1> like s/pat/code/e ?

[13:49] * moritz_ recommdns reading S02 (for isBEKaml )

[13:49] <moritz_> drake1: s[pat] = code;

[13:49] <drake1> ok

[13:49] <drake1> interesting

[13:50] <pmurias> diakopter: hi

[13:50] <moritz_> rakudo: my $x = 'foo'; $x ~~ s[o] = 4 + 5; say $x;

[13:50] <p6eval> rakudo 16e953: OUTPUT«f9o␤»

[13:50] *** meteorjay left
[13:50] <drake1> moritz: seems a bit like memory representation in macro fields

[13:50] *** meteorjay joined
[13:51] <isBEKaml> moritz_: I initially started with S02, still haven't gotten halfway through.. Slow reading :(

[13:51] <moritz_> it's a tough read at first, I know

[13:51] <arnsholt> isBEKaml: I've found that a more tractable approach is to read a bit here and a bit there, as you want to know about some particular subject

[13:51] <arnsholt> Keeps my brain from exploding, at least =)

[13:52] <drake1> just found out that bash has a special command substitution operator in the <( sequence heh

[13:52] <isBEKaml> arnsholt: better approach. hang out on #perl6 and ask questions about everything that piques your interests as discussions happen. ;)

[13:52] * isBEKaml runs and hides. 

[13:52] <arnsholt> Yeah, I do that as well ^^

[13:53] <isBEKaml> arnsholt: cat Specs &

[13:54] *** vapace joined
[14:04] <diakopter> pmurias: hi

[14:05] <pmurias> diakopter: how much is left to be done for classes in perlesque?

[14:09] <dalek> rakudo: 8ef25bd | moritz++ | t/spectest.data:

[14:09] <dalek> rakudo: run another test file (for "eager")

[14:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8ef25bd8a14f1eaaa5a43661890d6a7b1fa1311d

[14:10] <moritz_> rakudo: say [+]

[14:10] <p6eval> rakudo 16e953: OUTPUT«Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[14:12] <diakopter> pmurias: about 3-6 hours or so

[14:13] <pmurias> is there anything i could help with?

[14:13] <drake1> I have a sed command that could need some ungetc in the `q' phase

[14:14] <drake1> j/k

[14:14] <drake1> but that isn't perl

[14:14] <drake1> specifically

[14:15] *** XaeroOne left
[14:16] <moritz_> rakudo: say NaN

[14:16] <p6eval> rakudo 16e953: OUTPUT«NaN␤»

[14:16] <jnthn> rakudo: say "{NaN} bread"

[14:16] <p6eval> rakudo 16e953: OUTPUT«NaN bread␤»

[14:18] *** vapace left
[14:18] *** vapace joined
[14:20] *** rv2733 joined
[14:20] <drake1> just linked a line of library objects from a shell set to one single executable. pretty easy

[14:21] <arnsholt> jnthn: Yes, we have no bread? =)

[14:22] *** meteorjay left
[14:23] *** pmurias left
[14:23] *** pmurias_ joined
[14:23] <moritz_> rakudo: printf '%- 8s', 34

[14:23] <p6eval> rakudo 16e953: OUTPUT«34      »

[14:23] <moritz_> rakudo: printf '%-8s', 34

[14:23] *** pmurias_ left
[14:23] <p6eval> rakudo 16e953: OUTPUT«34      »

[14:23] <JimmyZ> rakudo: printf '%-16s', 34

[14:23] <p6eval> rakudo 16e953: OUTPUT«34              »

[14:23] *** pmurias joined
[14:23] *** meteorjay joined
[14:24] <jnthn> rakudo: my $cap; my $*OUT = class { method print(*@args) { $cap ~= @args; } }; printf '%-16s', 34; say $cap; # just curious if it works...

[14:25] <p6eval> rakudo 16e953: OUTPUT«Method 'printf' not found for invocant of class ''␤current instr.: 'printf' pc 375002 (src/gen/core.pir:28858)␤»

[14:25] <jnthn> rakudo: my $cap; my $*OUT = class :: is IO { method print(*@args) { $cap ~= @args; } }; printf '%-16s', 34; say $cap; # just curious if it works...

[14:25] <p6eval> rakudo 16e953:  ( no output )

[14:25] <jnthn> Heh.

[14:25] <jnthn> :-)

[14:27] <dalek> book: 71cb8c0 | moritz++ | src/builtins.pod:

[14:27] <dalek> book: [builtins] Nan is spelled NaN

[14:27] <dalek> book: review: http://github.com/perl6/book/commit/71cb8c05f679cbcc703a3b827cd11d125611e162

[14:27] <dalek> book: 60c5804 | (Prakash Kailasa)++ | src/multi-dispatch.pod:

[14:27] <dalek> book: minor fixes in examples

[14:27] <dalek> book: Signed-off-by: Moritz Lenz [email@hidden.address]
[14:27] <dalek> book: review: http://github.com/perl6/book/commit/60c580432f0127c35f01a78a6ee07a8c32625fa2

[14:27] <dalek> book: 063bc7a | moritz++ | src/operators.pod:

[14:27] <dalek> book: make pair object explanation a bit clearer

[14:27] <dalek> book: review: http://github.com/perl6/book/commit/063bc7aef2fa28d94451aae10483c33aa25c6bba

[14:27] <dalek> book: 6858b1d | moritz++ | src/operators.pod:

[14:27] <dalek> book: [ops] use the same code consistently in example and explanation

[14:27] <dalek> book: review: http://github.com/perl6/book/commit/6858b1d1db707db95d6e1040f005d0f9254e3dbc

[14:29] <moritz_> phenny: tell sahadev that I've applied most patches from your 'book' fork; I didn't apply the one about custom paper size because it makes it harder to talk about a specific page number across platforms

[14:29] <phenny> moritz_: I'll pass that on when sahadev is around.

[14:30] *** jaffa4 joined
[14:31] <moritz_> rakudo: 1 ==> 2

[14:31] <p6eval> rakudo 16e953: OUTPUT«Confused at line 11, near "1 ==> 2"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[14:32] <dalek> book: 199a8e1 | (Prakash Kailasa)++ | src/basics.pod:

[14:32] <dalek> book: missing statement terminator in example. also, use B<< .. >> so

[14:32] <dalek> book: that -> is rendered bold.

[14:32] <dalek> book: Signed-off-by: Moritz Lenz [email@hidden.address]
[14:32] <dalek> book: review: http://github.com/perl6/book/commit/199a8e19539b182649bbfee526f7ba3cd8eb3178

[14:34] <drake1> the arrow or -> means sub operator in perl?

[14:34] <jnthn> You could read it as "lambda"

[14:34] <jnthn> It's an anonymous block that may take parameters

[14:34] <jnthn> rakudo: my $code = -> $a, $b { say $a + $b }; $code(3,39)

[14:34] <p6eval> rakudo 16e953: OUTPUT«42␤»

[14:35] <drake1> also parameters ok

[14:35] <jnthn> Well, -> { ... } works too; just means it takes 0 parameters.

[14:36] <drake1> thats pretty smart

[14:40] *** JimmyZ left
[14:41] <drake1> so $a and $b works like template parameters?

[14:41] <moritz_> if they are between -> and {, they are the signature

[14:42] <drake1> like function(a,b) ?

[14:43] <moritz_> yes

[14:43] <drake1> then it's a bit curly

[14:45] <jnthn> It's the same thing that shows up in e.g. for loops

[14:45] <jnthn> rakudo: my @a = 1,2,3; for @a -> $thingy { say $thingy }

[14:45] <p6eval> rakudo 8ef25b: OUTPUT«1␤2␤3␤»

[14:45] <drake1> like in a shift?

[14:45] <jnthn> But you can then iteratre multiple things at a time

[14:46] <jnthn> rakudo: my @a = 1,2,3,4; for @a -> $thing, $other-thing { say "$thing, $other-thing" }

[14:46] <p6eval> rakudo 8ef25b: OUTPUT«1, 2␤3, 4␤»

[14:46] * isBEKaml finds pugs/docs/tutorial/ full of good reads, pods riddled with references to HHGTTG. :)

[14:46] <jnthn> drake1: In the sense that in Perl 5, you use shift to get hold of parameters, yes. In Perl 6, you needn't do that - just write a signature saying what variables they should go into.

[14:47] <isBEKaml> pfft, s/riddled/sprinked/

[14:47] <isBEKaml> *sprinkled

[14:48] <isBEKaml> though they are a bit dated. 

[14:48] <drake1> pretty nice for matrix abstraction

[14:58] <drake1> can you modify a subroutine to another language?

[14:59] <drake1> without having to call a compiler through system calls

[15:01] *** jferrero joined
[15:01] <drake1> I mean with a built in address in memory when it's run

[15:03] <drake1> something like: sub <C> { int a, b; and blah blah } #end of C routine

[15:07] *** kulp joined
[15:08] <dalek> nqp-rx: cf5f0c7 | pmichaud++ | src/setting/ (4 files):

[15:08] <dalek> nqp-rx: Make sure setting subroutines are properly package ('our') scoped

[15:08] <dalek> nqp-rx: instead of defaulting to lexically scoped.

[15:08] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/cf5f0c7648fafb172a5c6a40183b8887d78f4bfe

[15:08] <dalek> nqp-rx: c5a3363 | pmichaud++ | build/Makefile.in:

[15:08] <dalek> nqp-rx: Fix test target to rebuild nqp-settings.pbc prior to running tests.

[15:08] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/c5a3363872b458d7a5985bc6416ba019cadaafaf

[15:08] <dalek> nqp-rx: 1232366 | pmichaud++ | src/Regex/P6Regex (2 files):

[15:08] <dalek> nqp-rx: Turn INIT() sub in P6Regex::Actions into a standard INIT {...} block.

[15:08] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/123236692fd555bce5a4fb339d2ed5a62304c62f

[15:08] <dalek> nqp-rx: f4c4650 | pmichaud++ | src/NQP/Actions.pm:

[15:09] <dalek> nqp-rx: Adjust so that load_bytecode on a precompiled module automatically

[15:09] <dalek> nqp-rx: executes the mainline of the module.  This is required for

[15:09] <dalek> nqp-rx: lexically-scoped subroutines to be initialized properly inside of

[15:10] <jnthn> pmichaud: cf5f0c7 makes nqp-rx have not-Perl-6 semantics, fwiw.

[15:10] <jnthn> Guess that's part of the "not quite" :-)

[15:10] <drake1> like you can write assembler in C it would also be nice to write to write Python in Perl etc

[15:11] <jnthn> drake1: Such things would be possible if there's a compiler that targets the same VM for the language as you're running Perl 6 on.

[15:11] <jnthn> drake1: The idea of switching languages inside a given scope is certainly something very built-in to Perl 6 though.

[15:11] <jnthn> It's what happens when you write a regex.

[15:12] <jnthn> pmichaud: Just fyi, f4c4650 was already done in Rakudo too. :-)

[15:12] <drake1> it would be sweet

[15:13] <drake1> I only have it like that in the make scripts

[15:14] <drake1> but that is very dirty tricks

[15:16] <drake1> compared to a simple language modifier

[15:16] <pmichaud> 15:10 <jnthn> pmichaud: cf5f0c7 makes nqp-rx have not-Perl-6 semantics, fwiw.

[15:17] <pmichaud> ...?

[15:17] <pmichaud> how so?

[15:18] *** TiMBuS left
[15:18] <pmichaud> if you mean that core setting in Perl 6 has lexically scoped subs, then yes.

[15:18] <pmichaud> but these really aren't NQP core setting -- NQP doesn't come with a runtime library

[15:18] <pmichaud> in order to make use of nqp-setting, it has to be explicitly loaded.

[15:19] <pmichaud> in that sense, perhaps "setting" is the wrong word to use there (I've never been fond of this term for what this library is providing)

[15:20] <pmichaud> jnthn: and yes, the code for f4c4650 comes from rakudo

[15:21] <drake1> some kind of xs wrapper perhaps?

[15:21] <pmichaud> afk for a while

[15:22] *** n00bie joined
[15:22] <n00bie> !eval test

[15:23] <n00bie> :p guess not 

[15:23] <jnthn> pmichaud: I just meant the "defaulting to our"

[15:24] <jnthn> pmichaud: But yes, there's maybe a nicer word than "setting" in order to avoid confusion.

[15:24] <drake1> "our" is shared in between package scopes, right?

[15:25] <moritz_> "our" means it appears in a symbol table

[15:25] <moritz_> and can be accessed from other packages

[15:25] <jnthn> pmichaud: Ah, wait, I just read the patch. 

[15:25] <drake1> ok

[15:25] <moritz_> but it's not the same in all packages, if that's what you mean with 'shared'

[15:25] <jnthn> pmichaud: The commit message made me think there was a compiler tweak to default to "our".

[15:25] <jnthn> pmichaud: So, I'm not worried at all now. :-)

[15:25] * jnthn should read patches before complaining about them. ;-)

[15:29] <moritz_> btw I've pushed the 'mob4' branch to github

[15:30] <drake1> moritz: so it isn't like file scope?

[15:30] <moritz_> it has working support for native Perl 6 match objects which only contain named, non-quantified captures :-)

[15:30] <moritz_> and uses a very ugly hack, as seen in the last commit on that bnrach

[15:30] <moritz_> drake1: nope

[15:31] <drake1> moritz: I always forget what it means

[15:31] <moritz_> drake1: perldoc -f our

[15:31] <moritz_> it's pretty much the same in Perl 6

[15:32] <moritz_> in the mob4 branch, I use a :vtable(

[15:32] <moritz_> set_pmc_keyed'

[15:32] <moritz_> which re-dispatches to eval_hash_setter

[15:32] <drake1> for some time I thought it was shared across forks

[15:32] <moritz_> if it re-dispatches to postcircumfix:<{ }>, it looks endlessly

[15:33] <moritz_> jnthn, pmichaud: I'd appreciate it if you could take a look there - I haven't managed to solve it properly

[15:54] *** k23z__ left
[16:00] <drake1> our volatile shared parameter with implicit collision handlers

[16:02] *** xinming left
[16:06] *** iblechbot left
[16:07] *** xinming joined
[16:11] <drake1> must be some dialect this other ones say different. gotta go. bye

[16:12] *** drake1 left
[16:13] *** pmurias left
[16:18] *** justatheory joined
[16:26] <dalek> rakudo: 92508d6 | moritz++ |  (4 files):

[16:26] <dalek> rakudo: NYI error messages for feed operators

[16:26] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/92508d6f5a139eb3da36ff8bc38747255c06583f

[16:27] <dalek> csmeta: r272 | diakopter++ | trunk/Sprixel/t/man_or_boy.t:

[16:27] <dalek> csmeta: [perlesque] add some more iterations to man_or_boy.t

[16:27] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=272

[16:34] *** thraidh joined
[16:38] *** Targhan joined
[16:51] <pugssvn> r30645 | svatsan++ | First cut towards awesomifying u4x.perl6.org 

[16:54] <arnsholt> Hmm. is u4x.perl6.org supposed to be publicly accessible?

[16:54] <moritz_> arnsholt: yes, but I haven't created an index.html yet

[16:54] <arnsholt> Ah, right. That would explain the 403

[16:54] <moritz_> and for some reason the directory listing doesn't work

[16:55] *** ruoso joined
[16:58] <pugssvn> r30646 | moritz++ | [docs/u4x] copy style file to document root 

[16:58] <isBEKaml> moritz_: I was about to modify the script to do that. :)

[16:59] <moritz_> afk

[17:10] *** {shade} left
[17:11] <isBEKaml> hmm, <pre> code samples not really nice on the glossary... LTA

[17:14] *** {shade} joined
[17:17] *** pmurias joined
[17:17] *** LowRider joined
[17:17] *** pmurias left
[17:18] *** pmurias joined
[17:19] *** LowRider left
[17:21] *** pmurias left
[17:29] <colomon> moritz_: hooking up additional arguments to .subst -- LHF suitable for your project?

[17:29] <colomon> afk -- nap to try to make up for 3 hours up with a teething little guy last night.

[17:42] *** justatheory left
[17:44] <pugssvn> r30647 | svatsan++ | removed newlines to avoid LTA htmlification 

[17:46] <thraidh> are all grammars implicitly derived from Cursor?

[17:47] <arnsholt> IIRC they are. Check S05 to be sure though

[17:48] <thraidh> S05 is not clear on that matter

[17:48] <jnthn> I believe it is the case.

[17:48] <thraidh> at least not to me...

[17:52] <thraidh> when i introduce a method in a grammar i learned that i can treat that method like a rule, but it has to accept and return a Cursor object

[17:54] <thraidh> is the Cursor object given to the method read-only or can i modify it and return that instead of leaving the original alone and creating a new one?

[18:01] *** alester joined
[18:02] *** k23z__ joined
[18:03] *** justatheory joined
[18:04] *** M_o_C joined
[18:08] <pmichaud> jnthn: yes... actually, there's a problem with nqp now that unscoped sub declarations default to both 'my' and 'our'

[18:09] <pmichaud> I meant to fix that many months ago (shortly after switching nqp to default subs to 'my') but apparently forgot to do that

[18:09] <pmichaud> the other patches today are intended to get things to the point where it's possible to fix that

[18:10] <pmichaud> I'm about to commit a patch so that a sub explicitly declared 'my' is definitely only lexically scoped, at least.  

[18:10] *** pjcj left
[18:10] <pmichaud> (the underlying problem is that parrot puts the subs in the namespace by default -- forgot to turn that off when I created the lexically bound subs)

[18:10] <pmichaud> but that means that a lot of code has been able to "cheat" because the subs were available via the package

[18:11] <pmichaud> so... that needs a bit of cleaning up

[18:16] *** vapace left
[18:19] *** n00bie is now known as Weather

[18:19] <thraidh> how do i create a Cursor-object and how do i set the new position? according to S32 the position is Int, but cannot be modified

[18:20] *** Weather is now known as [n0b0ty]

[18:22] <pmichaud> there's an example in STD.pm

[18:22] <pmichaud> er, STD.pm6

[18:23] <thraidh> pmichaud: thank you

[18:23] <pmichaud> oops, I was slightly wrong there

[18:24] <pmichaud> it's creating a new cursor from an existing one

[18:24] <pmichaud>     $here = self.cursor($*HIGHWATER) if $highvalid;

[18:24] <pmichaud> anyway, I'm not sure the API for Cursor's is fully stabilized yet -- it'll want some coordination between implementations

[18:25] <pmichaud> in answer to your earlier question, objects aren't really ever "read-only", iirc

[18:26] <pmichaud> but most of the regex engines expect you to return a new cursor, not reuse an existing one.  (also not set in stone)

[18:28] <thraidh> with "read-only" i actually meant "supposed not to be modified", i.e. contractually read-only

[18:28] <pmichaud> yes, it's probably meant to be treated read-only

[18:29] <thraidh> now, i only have to find out what the argument to self.cursor means. but i'll dig in STD.pm6

[18:30] <pmichaud> I think it's a position.

[18:30] <pmichaud> anyway, the typical mechanism for setting a position to a cursor is via the :pos() or :continue() arguments, I think.

[18:31] <thraidh> (i should really turn of the the ascii-to-icon-smiley-translation...)

[18:33] <thraidh> i hope STD.pm6 will help me find enlightenment

[18:34] <thraidh> :pos() is not supposed to contain a smiley showing its tongue...

[18:36] <jnthn> pmichaud: Aye, I had to do quite a bit of clean-up when I fixed a similar issue in Rakudo.

[18:36] <jnthn> pmichaud: Though the Rakudo issue was failing to clear $*SCOPE in places that STD did so.

[18:36] <jnthn> pmichaud: I shook out a bunch more related issues when adding lexical classes/roles too...and the leixcal setting of course.

[18:39] <pmichaud> yes, clearing $*SCOPE is next on my list

[18:40] *** M_o_C left
[18:40] <pmichaud> I also think I'm going to add a simplified $*HIGHWATER to nqp for better error reporting... if it works out we can do something similar in rakudo

[18:41] <thraidh> is $/.sqrt supposed to work now or anytime in the future?

[18:41] <pugssvn> r30648 | svatsan++ | [u4x docs] use File::Find, File::Basename 

[18:42] <thraidh> question rephrased: does perl6 know it has to implicitly convert $/ from Match to Str to Num to run the .sqrt method?

[18:48] *** nimiezko joined
[18:51] <jnthn> pmichaud: +1

[18:51] <jnthn> pmichaud: A nicer error for "two terms in a row" could be nice too.

[18:52] <jnthn> Dunno how hard it is - I think part of it is in EXPR, which I'm scared to touch. :-)

[18:53] *** jaffa4 left
[18:54] <cognominal> rakudo:   sub { Str $toto }  #  not a friendly message when scope specifier forgotten. common mistake coming from C

[18:54] <p6eval> rakudo 92508d: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[18:54] <thraidh> moritz_ told me it wasn't as hard as it looks

[18:54] <thraidh> i think he lied ;)

[18:55] <jnthn> std: sub { Str $toto }

[18:55] <p6eval> std 30647: OUTPUT«Use of uninitialized value $FATALS in numeric gt (>) at STD.pm line 100909.␤===SORRY!===␤Confused at /tmp/PGMpG3gzat line 1:␤------> sub { Str ⏏$toto }␤    expecting any of:␤      bracketed infix␤  infix or meta-infix␤      statement modifier

[18:55] <p6eval> ..loop␤Parse fa…

[18:55] <jnthn> oooh!

[18:56] <cognominal> ironically, the error is given by FAILGOAL that is designed to be user friendly :)

[18:56] <diakopter> line 100909

[18:57] <thraidh> actually rakudo error message always look somewhat scary

[18:57] <pmichaud> (two terms in a row) -- just having $*HIGHWATER should be enough to at least point to the right place for the error

[18:57] <jnthn> pmichaud: Cool! :-)

[18:57] <pmichaud> even if it doesn't say "two terms in a row", it'll at least be at the beginning of the offending second term

[18:58] *** nimiezko left
[18:58] <jnthn> *nod*

[18:58] <pmichaud> std: sub { Str $toto }  # curious

[18:58] <p6eval> std 30647: OUTPUT«Use of uninitialized value $FATALS in numeric gt (>) at STD.pm line 100909.␤===SORRY!===␤Confused at /tmp/rirakGhPx7 line 1:␤------> sub { Str ⏏$toto }  # curious␤    expecting any of:␤   bracketed infix␤  infix or meta-infix␤      statement

[18:58] <p6eval> ..modifier lo…

[18:58] <pmichaud> oh, jnthn++ already tried it

[18:59] <pmichaud> we can probably clean that one up some also

[18:59] <jnthn> pmichaud: Yes. Note that it manages to make STD's error handling warn too. ;-)

[18:59] <pugssvn> r30649 | svatsan++ | [u4x docs] minor change to include style in render script 

[18:59] <cognominal> traidh, thx to pmichaud++ and jnthn++, rakudo error message are more and more precise and helpful

[18:59] <thraidh> is Cursor.pmc which resides beneath STD.pm6 supposed to be looked at?

[18:59] <thraidh> cognominal: i'm not saying that they are not helpful

[19:00] <thraidh> they are, if you are brave enough to come back to the screen after hiding with the monsters under your bed

[19:01] *** jhuni joined
[19:01] <thraidh> and i'm very thankful for everything you guys do

[19:01] *** plobsing joined
[19:04] <thraidh> it's just that from a (new) user's perspective the stack trace is at first sight more confusing than helping

[19:04] <isBEKaml> moritz_: I have made a few changes to the render script and I will pick up on the first cut of stylesheet tomorrow. Meanwhile, can you try that out and let me know how that goes? 

[19:05] <pmichaud> thraidh: I totally agree.  So far we have limited ability to control the stacktrace dump

[19:05] <pmichaud> it can be done... but it's a bit painful

[19:05] *** pjcj joined
[19:05] <thraidh> but since rakudo is currently probably more developed than "used", it's probably ok the way it is

[19:06] <pmichaud> no, I think we should get rid of the stacktrace (more)

[19:06] *** iblechbot joined
[19:06] <lue> AUGCAUAUUUAA!

[19:06] <pmichaud> what I *really* want to have is that rakudo dumps a simple error message, and saves the stacktrace information somewhere that we can then display it if we're interested :-)

[19:06] <lue> I smell logfiles!

[19:07] <pmichaud> lue:  or core dumps :)

[19:07] * isBEKaml time for bed. Later, #perl6! :)

[19:07] <thraidh> --developer-debug switch?

[19:07] <pmichaud> thraidh: more likely an environment variable

[19:07] <pmichaud> (as well as a switch)

[19:07] <pmichaud> or a policy setting

[19:07] <lue> that implie someone panicked.

[19:08] <lue> *implies

[19:08] <lue> .oO( and we all know what happened last time when a death star's core was shot— dumped. :) )

[19:08] <thraidh> ask the monsters under my bed, when i told them of the stack trace ;(

[19:08] *** isBEKaml left
[19:10] <lue> .oO(wouldn't we dump a camel though? Or a butterfly?)

[19:11] <lue> .oO(楽土 panic. »ö« dumped.)

[19:13] <thraidh> ooh... i always thought that was a "checking if your UTF-8 is working"

[19:13] <thraidh> now i see the butterfly

[19:14] <lue> well, a better check would be the japanese. The french quotes and o with umlaut are only within the latin subset (I believe) :)

[19:15] <lue> 駱駝道。

[19:15] <arnsholt> But the encoding of the guillemets is different in UTF-8 and iso-8859, so it works just as well

[19:16] <arnsholt> As a bonus, people are more likely to have the guillemets in their fontset

[19:16] <lue> guillemets?

[19:16] <arnsholt> The French quotes. They're called guillemets in French =)

[19:16] <jnthn> Those fancy French words.

[19:17] <arnsholt> I don't get many chances to use my French, so I take what I get =)

[19:18] <lue> Tu parles français?

[19:18] <thraidh> i thought it was guillemots? but then i wasn't very good in french

[19:18] <lue> I would think it's guille*ments*

[19:19] <arnsholt> It's guillemets

[19:19] <arnsholt> (Ref. http://en.wikipedia.org/wiki/Guillemet)

[19:19] <thraidh> you're right

[19:21] <arnsholt> But apparently X11 calls them guillemots

[19:22] <lue> XFree86 or XOrg?

[19:22] <lue> *Xorg

[19:22] <thraidh> according to wikipedia that's a common misspelling

[19:22] <arnsholt> The X Windows headers, so both of them probably

[19:23] <arnsholt> Yeah, I can see why. "mot" and "met" are quite similar phonetically in French, so an anglophone may very well have trouble distinguishing them

[19:25] <lue> (Anywell), anything interesting happen in Rakudo lately? /me doesn't want to backlog :P

[19:25] <lue> rakudo: my $a = 2; my $b := $a; $b = 4; say $a;

[19:25] <p6eval> rakudo 92508d: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17864 (src/builtins/Junction.pir:393)␤»

[19:26] <thraidh> i think they are quite distinguishable, but an anglophone may have problems to pronounce "met" since there is no equivalent vowel in english

[19:28] *** rv2733 left
[19:29] <cognominal> Interestingly the french wikipedia article says that guillemet is not derived from Guillaume, contrary to the english article.

[19:30] <lue> good thing I have an Italian who grew up also speaking French for a french teacher :)

[19:30] <cognominal> so http://www.decodeunicode.org/en/u+00ab would be a fiction

[19:31] <lue> rakudo: say "anyone using Linux Libertine ought to appreciate \xE000 , unless I screw that up.";

[19:31] <p6eval> rakudo 92508d: OUTPUT«anyone using Linux Libertine ought to appreciate  , unless I screw that up.␤»

[19:32] *** wknight8111 left
[19:32] <lue> .u E000

[19:32] <phenny> U+E000 (No name found)

[19:34] <lue> me just noticed an update to util/cperl-mode.el in the pugs repo !

[19:35] <lue> (it may have been a while, but I just updated)

[19:41] <thraidh> what does $here.<PRE>:delete mean?

[19:41] <thraidh> actually only the :delete part

[19:41] <jnthn> It means "delete this from the hash"

[19:41] <jnthn> It's an adverb.

[19:42] <jnthn> (just like a parameter that gets passed along to the indexer)

[19:42] <thraidh> oh

[19:42] <jnthn> So it knows rather than just to look up the key PRE, it should delete it.

[19:42] *** molaf joined
[19:43] <thraidh> since the whole line is: $PRE=$here.<PRE>:delete; i assume that it is looked up, assigned to $PRE and then deleted from $here

[19:45] <jnthn> No, it looks is up, deletes it and returns what was deleted.

[19:45] <jnthn> And then that gets assigned.

[19:45] <jnthn> Think of it along the same lines as when you do $x++

[19:45] <jnthn> It modifies $x, but returns what it used to be.

[19:45] <thraidh> since $here is also a Cursor-object, is the rule PRE called?

[19:46] <jnthn> No

[19:46] <jnthn> I don't know why the . was written there, it'd function the same without it.

[19:46] <jnthn> It's just a hash indexer.

[19:48] <thraidh> that is, the Cursor-object contains the matches so far

[19:48] <jnthn> Oh, if $here is some match object then in that case, yes. I thought you meant at this particular line of code.

[19:49] <thraidh> and the named rule PRE is deleted from the set of known matches?

[19:49] <jnthn> The *thing that it matched* is deleted from...

[19:49] <jnthn> iiuc.

[19:50] <thraidh> yes... i'll have to learn to express myself more precise

[19:55] *** kst left
[19:58] <sorear> pmichaud: Hi

[19:59] <jnthn> sorear! \o/

[20:01] <sorear> jnthn: That line of code comes from STD.pm6

[20:02] <sorear> have you ever looked inside gimme5?

[20:03] *** rgrau joined
[20:04] *** kst joined
[20:06] *** mariano joined
[20:08] <lue> afk

[20:08] *** kst left
[20:11] <jnthn> sorear: Yes, I figured.

[20:11] <jnthn> sorear: I've glanced at it, but no more.

[20:12] <sorear> gimme5 doesn't support full perl6

[20:12] <sorear> it parses perl6 using about 2000 lines of p5regex

[20:13] <sorear> my first reaction reading it was "TimToady should apply to the IOCCC"

[20:14] <cognominal> he is a serial offender

[20:18] <thraidh> is Cursor.pmc to be taken as a valid reference to learn things or should there be a warning sign to stay away?

[20:19] <jnthn> I thought pmc was generated from pm6, but maybe I am wrong.

[20:20] <thraidh> Cursor.pmc looks very perl5 to me

[20:20] <thraidh> while Cursor.pm6 only consists of colour definitions

[20:22] *** micr0spell joined
[20:23] <sorear> Cursor.pmc is hand-written Perl 5

[20:23] <sorear> it's called .pmc because Perl 5 looks for .pmc, then .pm

[20:23] <sorear> while Perl 6 looks for .pm6, then .pm

[20:24] <sorear> Cursor.pmc is a grab bag for everything that TimToady wanted to implement in STD, but couldn't because of gimme5 design limitations

[20:24] <sorear> it also contains the STD rules kernel

[20:25] <sorear> you might be interested in reading the equivalent Rakudo file, src/Regex/Cursor.pir in nqp-rx

[20:27] <thraidh> so far i'm still in the state of being scared by rakudo's error messages

[20:27] <thraidh> i think, reading .pir files is a magnitude (or more) greater

[20:27] * micr0spell Discounts!! Our Special Limited Time Offers Up To May,22!!! Notebooks,Plasma and LCD TV's.Buy your electronic needs at our unique prices. Laptop Sony VAIO􏿽xAE VGN-FW590FFD-575,57$!!!Apple MacBook􏿽xAE Air MC234LL/A-695,27$!!! http://www.elplace.com/

[20:27] *** micr0spell left
[20:28] <thraidh> and i want to express my deep respect to anyone handcoding .pir files

[20:31] <thraidh> does rakudo share parts of nqp-rx? i.e. is rakudo using the same Cursor as nqp?

[20:31] <sorear> pmichaud has my NQP-rx and Rakudo batons; I need a project

[20:31] <sorear> thraidh: the rakudo parser is written in nqp-rx, so yes

[20:34] *** envi^home left
[20:34] <thraidh> ok... do the programs written in rakudo use the same Cursor as nqp?

[20:35] <thraidh> after all, rakudo could be implemented in java with antlr but generate parrot code

[20:36] <thraidh> that code would need to refer to a Cursor implementation

[20:37] <diakopter> sorear: if I may offer a project suggestion, how about fleshing out the emit_p5 edition of viv?

[20:40] <diakopter> lue: have you read the paper "Study of the techniques for emulation programming"

[20:43] <jnthn> thraidh: Yes, Rakudo ues the same Cursor class as nqp-rx.

[20:44] <thraidh> then i fear i will have to look into Cursor.pir, since it seems not to be compatible with Cursor.pmc (or STD.pm6)

[20:46] <sorear> thraidh: Right now, Rakudo doesn't actually implement Perl6 regex at all; regex operations are delegated to NQP-rx, which must be available at runtime

[20:46] <sorear> masak is planning to fix this at some point

[20:46] <sorear> not just cursors, but also the Match objects are a sticking point for spectests

[20:47] <thraidh> ah

[20:47] <jnthn> sorear: It's not really "delegated" as such. It's just that nqp-rx happens to hold the regex implementation.

[20:47] <jnthn> sorear: We just subclass it and add some extra bits.

[20:47] <sorear> partly because NQP's match objects are very simplified, mostly because they don't inherit from Mu

[20:47] <thraidh> that explains probably why i can't use .perl on Match objects

[20:48] <sorear> diakopter: mm viv

[20:48] *** alester left
[20:50] <thraidh> and i thought, i could just write a simple program to make my girlfriend's life easier

[20:51] *** kst joined
[20:55] *** elmex left
[20:59] <sorear> You may be in the wrong channel.

[20:59] <sorear> If you just want to write programs, use Perl 5.

[21:02] <thraidh> no... i already know (a good part of) Perl 5

[21:02] <thraidh> it's time to learn something new

[21:10] *** elmex joined
[21:26] <thraidh> is the nqp EXPR implementation expected to be stable

[21:27] <thraidh> or "somewhat stable" 

[21:27] <thraidh> as opposed to "definitely temporary"

[21:28] *** molaf left
[21:29] *** pjcj left
[21:29] <thraidh> or, to rephrase the question, is EXPR contained in some specification?

[21:35] *** iblechbot left
[21:37] *** pjcj joined
[21:45] <k23z__> buubot, eval $^_^$;;

[21:45] <buubot> k23z__:      

[21:53] <colomon> thraidh: pretty sure nqp's EXPR is not contained in any specification.

[21:53] <thraidh> i feared that

[21:54] <thraidh> is it to be expected that some EXPR will one day be in any specification?

[21:54] <thraidh> or will it be an internal specification detail?

[21:55] <thraidh> even if it is just too useful

[21:56] *** [n0b0ty] left
[21:57] <sorear> we reserve the right to add things to the spec as they are seen useful

[21:57] <sorear> feel free to exploit unspecified and undocumented features of rakudo

[21:58] <sorear> if enough people use them, they will make it into perl6

[22:08] <thraidh> have you ever considered a thing like "set -x" for perl6?

[22:11] <sorear> you mean -d:Trace ?

[22:11] <sorear> or -Mautodie ?

[22:11] <thraidh> probably -d:Trace

[22:11] <thraidh> i'll try

[22:12] *** justatheory left
[22:13] <sorear> those are both perl5 command line options

[22:15] <sorear> rakudo: say pir::loadlib__PS("libm.so")

[22:15] <p6eval> rakudo 92508d: OUTPUT«libm␤»

[22:15] <sorear> rakudo: say pir::dlfunc__PPSS(pir::loadlib__PS("libm.so"), "sin", "dd")

[22:15] <p6eval> rakudo 92508d:  ( no output )

[22:15] <sorear> rakudo: say pir::dlfunc__PPSS(pir::loadlib__PS("libm.so"), "sin", "dd")(1)

[22:15] <p6eval> rakudo 92508d: OUTPUT«0.841470984807897␤»

[22:16] <sorear> rakudo: say pir::dlfunc__PPSS(pir::loadlib__PS("libm.so"), "sinf", "ff")(1)

[22:16] <p6eval> rakudo 92508d: OUTPUT«No NCI thunk available for signature 'ff'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:17] <sorear> rakudo: pir::trace(1); 2+2; pir::trace(0)

[22:17] <p6eval> rakudo 92508d: OUTPUT«0087 set_args PC24 (2), 2, 2␤008b find_sub_not_null P1, "&infix:<+>"                                        P1=PMCNULL ␤008e invokecc P1                                        P1=Perl6MultiSub=PMC(0x35a93c0)␤49075 get_params PC113 (1), P6                                       

[22:17] <p6eval> ..PC11…

[22:17] <sorear> rakudo: pir::trace(4); 2+2; pir::trace(0)

[22:17] <p6eval> rakudo 92508d: OUTPUT«# Calling sub 'perl6;infix:<+>'␤# current instr.: '_block14' pc 142 (EVAL_1:64)␤*** switching to ␤# Calling sub 'perl6;upgrade_to_num_if_needed'␤# current instr.: 'infix:<+>' pc 299219 (src/gen/core.pir:1021)␤# Calling sub 'parrot;P6protoobject;ACCEPTS'␤# current instr.:

[22:17] <p6eval> ..'upgrade_t…

[22:19] <jnthn> sorear: (native calling) Zavolaj wraps those very PIR ops. :-)

[22:19] <sorear> jnthn: plobsing in #parrot was looking for NCI functions that didn't work

[22:19] <sorear> he's testing a libjit framebuilder patch

[22:19] <jnthn> sorear: Oh, cool!

[22:19] <jnthn> plobsing++

[22:20] <plobsing> it's not a patch. it's a dynext library

[22:21] <jnthn> plobsing: Using libjit rather than the hard-coded NCI thunks, though?

[22:21] <plobsing> yes

[22:21] <jnthn> :-)

[22:21] <jnthn> That will make Zavolaj a bunch more useful.

[22:23] <plobsing> you can give it a try at git://github.com/plobsing/parrot-libjit-fb.git if you like

[22:24] <jnthn> plobsing: Thanks, may well have time to play tomorrow. :-)

[22:24] <jnthn> (bit tired now, so going for sleep soon here :-))

[22:24] <plobsing> bug reports welcome!

[22:28] *** k23z__ left
[22:29] *** sorear left
[22:31] <thraidh> now, that i can use EXPR in rakudo to build my own syntax trees, i'll go to sleep, too

[22:32] *** thraidh left
[22:34] *** rgrau left
[22:35] *** sorear joined
[22:36] *** constant left
[22:44] *** Trashlord left
[22:45] *** kel_ left
[22:48] *** jaldhar_ joined
[22:52] *** jaldhar_ is now known as jaldhar

[22:58] *** Psyche^ joined
[23:02] *** Patterner left
[23:02] *** Psyche^ is now known as Patterner

[23:13] <sorear> hilight: 2+2

[23:13] <sorear> highlight: 2+2

[23:13] <p6eval> Please use /msg p6eval 2+2

[23:20] <diakopter> sorear: msg me if you want an acct on the p6eval box

[23:21] *** Chillance joined
[23:21] <diakopter> to diagnose that error...

[23:21] <diakopter> (I don't know what's wrong with it)

[23:29] <sorear> neither do I, but it's obvious from looking at the source that it could never have worked in the first place

[23:29] *** JimmyZ joined
[23:30] <sorear> and I'm not real keen on fixing up something that's half-implementex

[23:30] <lue> is that STD hilight?

[23:31] <sorear> theoretically

[23:31] <sorear> I have the actual STD hilighter working

[23:32] * sorear just discovered 'tloop'

[23:32] <sorear> it's a STD repl!!!

[23:32] <sorear> now part of me really wants to attach tloop to viv and make a Standard Perl 6 evaluator

[23:36] * lue forgot for a second that STD only checks syntax

[23:41] <sorear> no

[23:41] <sorear> STD also checks scoping

[23:42] <sorear> std: say $foo

[23:42] <p6eval> std 30649: OUTPUT«===SORRY!===␤Variable $foo is not predeclared at /tmp/lq9c0tOFqh line 1:␤------> say $foo⏏<EOL>␤Check failed␤FAILED 00:01 112m␤»

[23:43] <lue> OK. When I first saw that statement, I thought .oO(doesn't STD already eval— oh yeah, it doesn't.)

[23:46] <lue> sorear: how's it going with := ?

[23:48] *** meppl left
[23:49] <sorear> lue: starved for pm-tuits

[23:49] <sorear> pm has this way of inspiring me to do things The Right Way or not at all

[23:49] <sorear> it's vaguely annoying

[23:52] <lue> what do you need from him?

[23:52] <sorear> a complete specification of how := works in edge cases like (@x[5], @x) := foo()

[23:53] <sorear> I could just implement LHSes that are simple variables or postcircumfix expressions, but I know he'd have no part of it

[23:54] <lue> why would you do that in the first place? :)

[23:55] <lue> I can see (@x[5], @y), but not that. First set element 5 of @x to foo(), then rewrite the entire array to contain foo() [from my understanding]

[23:57] <sorear> like I said, edge cases.

[23:58] <lue> I can see why you need his explanation (or Larry's :) ) of how that should work. I'm very confused right now.

[23:58] <plobsing> is '[:=] @x' valid?

[23:58] <lue> std: my @x; [:=] @x

[23:59] <p6eval> std 30649: OUTPUT«ok 00:01 113m␤»

[23:59] <lue> syntactically, it seems to be OK.

