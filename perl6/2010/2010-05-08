[00:00] <diakopter> someone asked for something similar the other day

[00:00] <sjohnson> in my magical dream world, i imagined:  push @a, $_->{somekey} if exists; # would do it

[00:01] *** mikehh_ is now known as mikehh

[00:02] *** kst` joined
[00:02] <arnsholt> sorear: The joys of Unicode =)

[00:02] <arnsholt> (And it's probably your font, rather than the terminal)

[00:02] <sjohnson> diakopter: ... what are your thoughts on this radical feature request

[00:03] <sjohnson> or idea, rather.

[00:03] <sjohnson> i haven't requested it yet :)

[00:03] *** kst` left
[00:04] <sorear> sjohnson: given %_<somekey> { @a.push($_) if .exists }

[00:04] <sorear> good enough?

[00:04] <sorear> er

[00:04] <sorear> s/exists/defined/ and that one will work

[00:05] <sorear> it'll work better if you give me a bit more context

[00:05] <sorear> is this in a loop?

[00:05] <sjohnson> i will give the context by pastebin example

[00:05] <diakopter> that wouldn't autovivify?

[00:05] <sjohnson> my brother at work asked me about it today, and i figured out a way in perl 5

[00:05] <sjohnson> so one sec

[00:06] *** ethel left
[00:07] <sjohnson> sorear: http://www.pastebin.org/208696  (dont worry, it's very simple)

[00:09] <sorear> %h{*; "key1"}.values # I think a multidimensional hash slice will do what you need

[00:10] <sjohnson> thanks

[00:11] <sjohnson> im looking forward to understanding perl 6

[00:16] <diakopter> me2

[00:17] *** eternaleye joined
[00:36] *** snarkyboojum left
[00:38] *** s1n joined
[00:41] *** snarkyboojum joined
[00:46] <lue> ohaidere

[00:48] *** _jaldhar left
[00:50] <lue> rakudo: my @a; @a[0..3] = (1,2,3,4); say @a

[00:50] <p6eval> rakudo ab2322: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[00:50] <lue> ō.o

[00:50] <diakopter> large list/array refactor/rewrite imminent

[00:51] <lue> oooh! Would that work?

[00:51] <diakopter> I don't know

[00:52] <lue> Hell of a lot better than pushing about 0x10000 times :)

[00:52] <diakopter> well, you wouldn't ever type out all the pushes in the source code, would you?

[00:53] <diakopter> or do you mean over the course of a lifetime?

[00:53] <diakopter> (as long as you're assigning more than 1, it saves a literal push)

[00:54] <lue> maybe I have to look at push() again. I got the feeling it did one at a time, but that's probably wrong.

[00:55] <sorear> diakopter: are you doing the refactor?

[00:55] *** rv2733 left
[00:56] *** BrowserUk joined
[00:56] <diakopter> :P no.. I just read the phone-cabal transcripts and the irclogs, and pmichaud seems to be warming up to another rewrite

[00:56] <diakopter> transcripts:  http://use.perl.org/~chromatic/journal/

[00:57] <diakopter> notably: April 21 pmichaud said 'hope to work on the List implementation, especially laziness and context'

[00:58] <diakopter> but after that, when pmichaud was chatting with TimToady and others here a week or so ago, it seemed like more rewriting needed to occur

[00:59] * diakopter looks for the reference

[00:59] <lue> how would I use push to push a certain range of values, short of typing (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, (ad nauseum))

[00:59] <lue> (and yes, I do need a lot of zeroes.)

[00:59] <diakopter> a loop?

[01:00] *** lichtkind left
[01:00] <Juerd> lue: 0 xx $thatmany

[01:00] <lue> rakudo: my @a; @a.push(0 xx 3); say @a

[01:00] <p6eval> rakudo ab2322: OUTPUT«000␤»

[01:01] <lue> Yay! I don't suppose I could put references to @a elements inside @a that easily :)

[01:01] <Juerd> Why not?

[01:03] <lue> lemme try...

[01:03] *** nihiliad left
[01:04] <BrowserUk> rakudo: my @a= 1; my %h = 1,2; @a.push( %h{2} // () ); say @a;

[01:04] <p6eval> rakudo ab2322: OUTPUT«1␤»

[01:06] <lue> rakudo: my @a; @a.push(0 xx 3); loop (my $i=0; $i <= 3; $i++) { @a.push(0); @a[(i+3)] := @a[i]; }; say @a

[01:06] <p6eval> rakudo ab2322: OUTPUT«Could not find sub &i␤current instr.: '_block58' pc 456 (EVAL_1:27900521)␤»

[01:06] <lue> rakudo: my @a; @a.push(0 xx 3); loop (my $i=0; $i <= 3; $i++) { @a.push(0); @a[($i+3)] := @a[$i]; }; say @a

[01:06] <p6eval> rakudo ab2322: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[01:06] <diakopter> sorear: oh, oops.

[01:06] <lue> something like that is what I need.

[01:06] <diakopter> sorear: here is the reference

[01:07] <diakopter> http://irclog.perlgeek.de/perl6/2010-05-04#i_2293626

[01:08] <diakopter> pmichaud isn't yet happy with Seq and binding

[01:08] <diakopter> so there's a lot of exploratory work that it seems he's expecting he'll be the one to shoulder

[01:08] <sorear> thanks

[01:09] *** patrickas left
[01:09] <diakopter> not as notably, I'm not happy with the binding spec, because it's way too magic imho.

[01:10] <diakopter> (oh wait, that's a tautology) :)

[01:10] * lue thinks of pythonic [3:6]. Everybody wants the colon.

[01:11] <diakopter> sorear: (sorry for co-opting your description "magic" for that)

[01:20] <lue> rakudo: my @a; @a.push(0 xx 3); @a.push (:@a[1..3] xx 3)

[01:20] <p6eval> rakudo ab2322: OUTPUT«Confused at line 11, near [email@hidden.address] (:"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[01:20] <lue> hmm..

[01:20] <lue> (tried :=)

[01:23] <lue> rakudo: my @a; @a.push(0 xx 3); @a.push (@a[1..3] xx 3) say @a

[01:23] <p6eval> rakudo ab2322: OUTPUT«Confused at line 11, near [email@hidden.address] (@"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[01:24] <lue> rakudo: my @a; @a.push(0 xx 3); @a.push(@a[1..3] xx 3) say @a

[01:24] <p6eval> rakudo ab2322: OUTPUT«Confused at line 11, near [email@hidden.address] instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[01:26] *** BrowserUk left
[01:30] <lue> := being unimplemented bugs me deeply. Anyone know where these kinds of things are implemented?

[01:34] <diakopter> lue: it would take hundeds->thousands of hours to "implement"

[01:35] <diakopter> I'm just making sure you know what you're considering undertaking

[01:39] <lue> It's one of the two reason I switched from Py3 to P6. I'd like to at least see where it would be (I am grepping my way through the code now BTW)

[01:39] <diakopter> it would be *everywhere*

[01:40] <diakopter> lue: probably it would be best to solve your problem another way.  if you would, please explain why you believe you need the := operator to solve your problem?  I'm willing to bet several folks around here can help

[01:40] <diakopter> (including myself)

[01:40] <diakopter> can, and are willing

[01:40] *** nihiliad joined
[01:41] <lue> The NES has several "shadow" areas, where access to it defers you to some actual memory (i.e. going to 0x900 would take you to code at 0x100) [MORE]

[01:42] * diakopter falls off my chair

[01:42] <lue> In Python 3, I had to write an extra method to avoid headache with updating everything (Py3 has not references)

[01:42] <lue> I could do the same in P6, but references would save a lot of work. :)

[01:43] <lue> (yes, I switched in the middle of writing an NES emulator to make writing the emulator easier.)

[01:43] * diakopter wonders about all the other NES emulators

[01:45] <diakopter> please explain more how Py3 doesn't have references...?)

[01:45] <lue> They're all written at least partly in x86, if they're even available for linux.

[01:46] <lue> I could never find anything about pointers, or references.

[01:47] * sorear falls off his chair, too

[01:47] <sorear> if you're so adamantly opposed to interpreters

[01:47] <sorear> why are you writing one

[01:47] <sorear> and in a high-level language with no optimizations, at that

[01:48] <diakopter> you'd be better off running an x86 os on an x86 emulator

[01:48] <diakopter> and then running the nes emulator on that

[01:50] <lue> I actually tried that. It was awful.

[01:50] <lue> This is my last step, short of buying another computer :)

[01:50] <diakopter> well, it'll certainly be an instructive exercise (potentially), whichever way you go.

[01:52] <lue> sorear: if I were opposed to interpreters, I would go for C.

[01:52] <lue> My goal in the middle of this (the reason I'm trying Python/Perl/etc. first) is also to make it so the program runs no matter what.

[01:53] <lue> sorear: I have an old computer. I'm going to whine about virtual machines and interpreters. I know my attitude would be different if I had a new Mactel laptop.

[01:54] <lue> Even compiled programs can run slow for me. Don't trust me too much when I talk about speed issues :P

[01:57] <lue> rakudo: my $a = 3; my $b = \$a; say $a.WHERE; say $b.WHERE

[01:57] <p6eval> rakudo ab2322: OUTPUT«62691056␤62685008␤»

[01:59] * lue is trying to figure a way to get a quick 'n' dirty := working. (Goodbye, sanity...)

[02:00] *** Psyche^ joined
[02:03] *** aindilis left
[02:03] *** Patterner left
[02:03] *** Psyche^ is now known as Patterner

[02:05] *** donri left
[02:10] * lue thinks trying something less complicated first might be a good idea...

[02:10] * lue just to get a feel for working in compiler guts :)

[02:17] *** \shade\ joined
[02:29] <lue> afk (and maybe when this place is bustling with people it'll be easier to figure out my problem)

[02:30] <lue> (no offense to anyone who has helped already)

[02:32] *** ShaneC left
[02:36] *** BrowserUk joined
[02:36] *** BrowserUk left
[02:53] *** fridim joined
[02:55] *** kst left
[02:58] *** kst joined
[03:11] *** cdarroch left
[03:19] <colomon> rakudo: say 3/4 cmp 5/6

[03:19] <p6eval> rakudo ab2322: OUTPUT«-1␤»

[03:19] <colomon> rakudo: say 3/4 <=> 5/6

[03:19] <p6eval> rakudo ab2322: OUTPUT«-1␤»

[03:19] <colomon> rakudo: say ~(3/4) cmp ~(5/6)

[03:19] <p6eval> rakudo ab2322: OUTPUT«-1␤»

[03:20] <colomon> rakudo: say 3/4 < 5/6

[03:20] <p6eval> rakudo ab2322: OUTPUT«1␤»

[03:20] <colomon> rakudo: say "a" cmp "b"

[03:20] <p6eval> rakudo ab2322: OUTPUT«-1␤»

[03:20] *** _jaldhar joined
[03:21] <colomon> Oh, I see, Rat has special case versions of cmp.  Hmmm....

[03:25] *** am0c left
[03:35] *** alester joined
[03:39] *** am0c joined
[03:44] <dalek> csmeta: r247 | diakopter++ | trunk/Sprixel/ (5 files):

[03:44] <dalek> csmeta: [perlesque] broken code commit :)

[03:44] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=247

[03:45] *** christine left
[03:46] *** christine joined
[03:54] *** jonrafkind left
[03:55] *** tylerni7 joined
[03:59] *** JimmyZ joined
[04:03] <sorear> What does my $var is Type(Args) mean?

[04:06] <sorear> Do we have any pretty multi-variable graphs 'racing' Rakudo, Pugs, mildew, etc., on spectests vs. time?

[04:06] <diakopter> :P

[04:07] <diakopter> no; those variables would be very difficult to quantify

[04:07] <JimmyZ> Pugs is outdate

[04:07] <sorear> run spectest, graph

[04:08] <JimmyZ> outdated

[04:09] *** snarkyboojum left
[04:09] *** snarkyboojum joined
[04:16] <diakopter> sorear: I'm sorry; I misunderstood.

[04:19] *** justatheory left
[04:20] *** am0c left
[04:22] *** thowe joined
[04:27] *** kst left
[04:34] *** am0c joined
[04:34] *** kst joined
[04:42] <sorear> std: (* + my $x); say $x;

[04:42] <p6eval> std 30583: OUTPUT«ok 00:01 113m␤»

[04:42] <sorear> TimToady: Should that parse?  There is talk of a compiler-generated implicit block...?

[04:43] <sorear> er, nevermind, the answer was given three pages down

[04:44] *** snarkyboojum left
[05:08] *** orafu left
[05:09] *** orafu joined
[05:11] *** am0c left
[05:17] <sorear> hmm, LTM requires a metaclass compatibility engine

[05:19] *** pure1111 joined
[05:19] *** pure1111 left
[05:23] <JimmyZ> rakudo: (1,1, * + *, ... *).batch(28).perl.say

[05:23] <p6eval> rakudo ab2322: OUTPUT«No exception handler and no message␤current instr.: '&fail' pc 18025 (src/builtins/Junction.pir:481)␤»

[05:26] <JimmyZ> rakudo: (1,1, * + * ... *).batch(28).perl.say

[05:26] <p6eval> rakudo ab2322: OUTPUT«(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811)␤»

[05:30] *** envi_home2 left
[05:42] <JimmyZ> rakudo: 'hello'

[05:42] <p6eval> rakudo ab2322:  ( no output )

[05:48] *** BrowserUk joined
[05:48] *** BrowserUk left
[05:56] *** snarkyboojum joined
[06:03] *** alester left
[06:06] *** meppl joined
[06:10] *** JimmyZ left
[06:14] *** kst left
[06:18] *** kst joined
[06:22] *** JimmyZ joined
[06:25] <sorear> What is the difference between COMPILING::<$?FOO> and $*FOO?

[06:35] *** jhuni joined
[06:47] <JimmyZ> rakudo: class Foo { say method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[06:47] <p6eval> rakudo ab2322: OUTPUT«F␤hi␤hi␤»

[06:51] <JimmyZ> rakudo: class Foo { my method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[06:51] <p6eval> rakudo ab2322: OUTPUT«hi␤hi␤»

[06:51] <JimmyZ> rakudo: my.WHAT.say

[06:51] <p6eval> rakudo ab2322: OUTPUT«Malformed my at line 11, near ".WHAT.say"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[06:51] <JimmyZ> rakudo: class Foo { our method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[06:51] <p6eval> rakudo ab2322: OUTPUT«hi␤hi␤»

[06:58] *** k23z__ joined
[06:59] <sorear> TimToady: Is the bit about magical hashes for grammatical categories at the end of S02 a fossil?  I think we use protoregexes in STD:: for that now

[06:59] *** Ross joined
[07:06] *** dalek left
[07:09] *** dalek joined
[07:12] *** fridim left
[07:19] *** nihiliad left
[07:28] *** plobsing joined
[07:32] *** TiMBuS left
[07:43] *** kst left
[07:45] *** finanalyst joined
[07:45] <finanalyst> rakudo: my @a=1,2,3; say ( ^@a ).perl

[07:45] <p6eval> rakudo ab2322: OUTPUT«0..^[1, 2, 3]␤»

[07:46] <finanalyst> alpha: my @a=1,2,3; say ( ^@a ).perl

[07:46] *** Su-Shee joined
[07:46] <p6eval> alpha 30e0ed: OUTPUT«0..^3␤»

[07:55] *** kst joined
[08:08] *** _jaldhar left
[08:12] *** envi^home joined
[08:16] <moritz_> alpha is probably saner here

[08:17] *** finanalyst left
[08:38] *** snarkyboojum left
[08:40] <JimmyZ> alpha: class Foo { my method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[08:40] <p6eval> alpha 30e0ed: OUTPUT«Method 'F' not found for invocant of class ''␤in Main (file src/gen_setting.pm, line 324)␤»

[08:40] <JimmyZ> rakudo: class Foo { my method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[08:40] <p6eval> rakudo ab2322: OUTPUT«hi␤hi␤»

[08:41] <isBEKaml> alpha: class Foo { !method F() { 'hi'; }; };Foo.new.F.say; Foo.F.say;

[08:41] <p6eval> alpha 30e0ed: OUTPUT«hi␤hi␤»

[08:41] <isBEKaml> weird, I thought ! was private... 

[08:43] * isBEKaml goes looking at S06 and S12

[08:43] <JimmyZ> I want create statci method

[08:43] <JimmyZ> static

[08:43] <JimmyZ> seems there were no static methods

[08:43] <isBEKaml> methods are generally public. I don't think we have static methods. 

[08:44] <JimmyZ> rakudo: class Foo { my method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[08:44] <p6eval> rakudo ab2322: OUTPUT«hi␤hi␤»

[08:44] <JimmyZ> alpha: class Foo { my method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[08:44] <moritz_> methods are "static" if they don't access any attributes

[08:44] <p6eval> alpha 30e0ed: OUTPUT«Method 'F' not found for invocant of class ''␤in Main (file src/gen_setting.pm, line 324)␤»

[08:44] <moritz_> rakudo: class F { has $!x; method a { $!x } }; F.a

[08:44] <p6eval> rakudo ab2322: OUTPUT«Type objects are abstract and have no attributes, but you tried to access ␤current instr.: 'perl6;F;a' pc 385 (EVAL_1:22350407)␤»

[08:45] <isBEKaml> moritz_: no accessor methods are static? 

[08:45] <JimmyZ> alpha: class Foo { has $!x; method F() { $!x; }; }; Foo.F.say; Foo.new.F.say;

[08:45] <p6eval> alpha 30e0ed: OUTPUT«Type objects do not have state, but you tried to access attribute $!x␤in Main (file <unknown>, line <unknown>)␤»

[08:45] <JimmyZ> alpha: class Foo { has $!x; method F() { $!x; }; }; Foo.new.F.say;

[08:45] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤␤»

[08:46] <isBEKaml> moritz_: the difference in behaviour seen between alpha and rakudo? my scoped methods are seen too?

[08:46] <JimmyZ> rakudo: class Foo { has $!x =0 ; method F() { $!x; }; }; Foo.F.say;

[08:46] <p6eval> rakudo ab2322: OUTPUT«Type objects are abstract and have no attributes, but you tried to access ␤current instr.: 'perl6;Foo;F' pc 397 (EVAL_1:169)␤»

[08:46] <moritz_> isBEKaml: iirc alpha thought 'my' methods were private

[08:46] *** dalek left
[08:46] <JimmyZ> rakudo: class Foo { has $!x =0 ; method F() { $!x; }; }; Foo.new.F.say;

[08:46] *** hejki left
[08:46] <p6eval> rakudo ab2322: OUTPUT«0␤»

[08:46] *** hejki joined
[08:47] <moritz_> alpha generally has problems with properly scoping routines

[08:47] <JimmyZ> alpha: class Foo { my method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[08:47] <p6eval> alpha 30e0ed: OUTPUT«Method 'F' not found for invocant of class ''␤in Main (file src/gen_setting.pm, line 324)␤»

[08:47] <isBEKaml> moritz_: that should be the correct behaviour, right? "my"s are essentially scoped within the block, right?

[08:47] <moritz_> yes

[08:48] <JimmyZ> alpha: class Foo { say method F() { 'hi'; }; }; Foo.F.say; Foo.new.F.say;

[08:48] <p6eval> alpha 30e0ed: OUTPUT«F␤hi␤hi␤»

[08:48] <JimmyZ> alpha has less bugs 

[08:49] <moritz_> that's a broad oversimplification

[08:50] *** dalek joined
[08:52] <pugssvn> r30584 | moritz++ | [t/spec] test for rx/.../ and rx{...} quoting 

[08:53] <moritz_> rakudo: multi sub infix:<+>() { 42 }; say 5 + 5

[08:53] <p6eval> rakudo ab2322: OUTPUT«No applicable candidates found to dispatch to for 'infix:<+>'. Available candidates are:␤:()␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[08:58] <moritz_> rakudo: say BEGIN 5

[08:58] <p6eval> rakudo ab2322: OUTPUT«5␤»

[09:00] *** Ross left
[09:00] *** snarkyboojum joined
[09:00] *** Ross joined
[09:01] <pugssvn> r30585 | moritz++ | [t/spec] simpler tests for BEGIN blocks as expressions; tests RT #62188 and RT #74836 

[09:03] *** Ross left
[09:08] <dalek> rakudo: c49d32b | moritz++ | t/spectest.data:

[09:08] <dalek> rakudo: run S04-phasers/rvalues.t

[09:08] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c49d32b119513fbb66d0fd8b8946458a91354994

[09:12] <pugssvn> r30586 | moritz++ | [t/spec] test for RT #74778, multiple occurences of $^a should count as a single parameter 

[09:15] *** [mark] joined
[09:16] *** Maddingue left
[09:21] <pugssvn> r30587 | moritz++ | [t/spec] test for RT #65738, overriding exports do not affect modules loaded later on 

[09:24] <moritz_> these module loading tests seem very fragile to me

[09:24] <moritz_> all split up in different files

[09:32] *** bakedb__ joined
[09:32] *** clintongormley joined
[09:34] *** [mark] left
[09:34] <isBEKaml> rakudo: class Foo { method !F() { "some stuff" }; method G() { say "some more stuff"; say F(); }; }; Foo.G;

[09:34] <p6eval> rakudo ab2322: OUTPUT«some more stuff␤Could not find sub &F␤current instr.: 'perl6;Foo;G' pc 530 (EVAL_1:232)␤»

[09:35] *** patrickas joined
[09:36] <isBEKaml> rakudo: class Foo { method !F() { "some stuff" }; method G() { say "some more stuff"; say !F(); }; }; Foo.G;

[09:36] <p6eval> rakudo ab2322: OUTPUT«some more stuff␤Could not find sub &F␤current instr.: 'perl6;Foo;G' pc 530 (EVAL_1:22350472)␤»

[09:36] <isBEKaml> rakudo: class Foo { method !F() { "some stuff" }; method G() { say "some more stuff"; say self!F(); }; }; Foo.G;

[09:36] <p6eval> rakudo ab2322: OUTPUT«some more stuff␤some stuff␤»

[09:36] <sjohnson> hi

[09:38] <sjohnson> （´ー｀　）

[09:40] <isBEKaml> rakudo: class Foo { method !F() { "some stuff" }; method F() { say "I'm F..."; }; method G() { say "some more stuff"; say self!F(); }; }; Foo.G; Foo.F;

[09:40] <p6eval> rakudo ab2322: OUTPUT«some more stuff␤some stuff␤I'm F...␤»

[09:41] <isBEKaml> something's off... Why should we define two methods in the same class with same name but under different scopes? 

[09:41] <cognominal> http://www.youtube.com/watch?v=nCgQDjiotG0

[09:41] <cognominal> oops wrong window

[09:42] <isBEKaml> hi sjohnson 

[09:43] <isBEKaml> I feel this can lead to a lot of confusion... :|

[09:43] *** will__ joined
[09:43] <isBEKaml> alpha: class Foo { method !F() { "some stuff" }; method F() { say "I'm F..."; }; method G() { say "some more stuff"; say self!F(); }; }; Foo.G; Foo.F;

[09:43] <p6eval> alpha 30e0ed: OUTPUT«some more stuff␤some stuff␤I'm F...␤»

[09:43] *** will__ left
[09:44] <moritz_> rakudo never really enforced privacy of attributes and methods

[09:44] <moritz_> known bug

[09:44] *** will__ joined
[09:44] <sjohnson> isBEKaml: hi

[09:45] *** will__ left
[09:45] <isBEKaml> hmm, how does std treat it? 

[09:45] <isBEKaml> std: class Foo { method !F() { "some stuff" }; method F() { say "I'm F..."; }; method G() { say "some more stuff"; say self!F(); }; }; Foo.G; Foo.F;

[09:45] <p6eval> std 30587: OUTPUT«ok 00:01 113m␤»

[09:45] *** will__ joined
[09:46] <isBEKaml> heh

[09:46] *** will__ left
[09:47] <sjohnson> cognominal: interesting link nonetheless!

[09:48] <isBEKaml> cognominal: I came across this on reddit. potato gun tests. :)

[09:51] *** JimmyZ left
[09:52] *** plobsing left
[09:53] *** masak joined
[09:53] <masak> oh hai, #perl6

[09:53] <isBEKaml> hi masak!

[09:55] *** jhuni left
[09:55] *** JimmyZ joined
[09:58] <cognominal> hi masak

[10:04] <masak> lunch & :)

[10:05] <patrickas> hello moritz and mazak, I just committed the latest changes ... including the linkification of readme badge

[10:06] <moritz_> patrickas++

[10:06] <masak> patrickas: cool. I have an early general badge icon. will try to push it later today.

[10:06] * moritz_ has registered thejoyofsix.org, and now ponders what to put up there

[10:09] <JimmyZ> joyo?

[10:09] <JimmyZ> oh joy of six

[10:09] <isBEKaml> patrickas: cool :)

[10:10] <isBEKaml> moritz_: now, perl6 has become impishly naughty! ;)

[10:11] * patrickas parsed it as the-joyo-fsix too :-)

[10:12] * isBEKaml likes the .org domain suffix to joyofsix

[10:14] *** wknight8111 joined
[10:16] *** k23z__ left
[10:21] <isBEKaml> personally, I like punning perl 6 or "Perling Six" or "Perling 6" :)

[10:24] *** \shade\ left
[10:24] *** fda314925 left
[10:24] *** Trey left
[10:25] *** bbkr_ joined
[10:25] *** bakedb__ left
[10:27] *** \shade\ joined
[10:27] *** fda314925 joined
[10:27] *** Trey joined
[10:27] *** \shade\ left
[10:27] *** fn joined
[10:32] *** pmurias joined
[10:33] <sjohnson> masak: hi, long time no see

[10:39] *** bbkr_ left
[10:41] <moritz_> rakudo: class X {method x (*@_) {say @_} }; X.new.x(5)

[10:42] <p6eval> rakudo ab2322: OUTPUT«5␤»

[10:43] *** JimmyZ left
[10:44] <isBEKaml> moritz_: that's variable argument passing? 

[10:44] <isBEKaml> *@_

[10:44] <moritz_> yes

[10:45] <moritz_> "slurpy" we call it

[10:45] <isBEKaml> we call it varargs. :)

[10:45] *** k23z__ joined
[10:46] <pugssvn> r30588 | moritz++ | [t/spec] test for RT #72940, *@_ in method signature 

[10:46] <isBEKaml> rakudo: class X {method x (*@_) {say @_} }; my @tt = <1 2 3 3 4 5 9>;my @tt1 = <1 2 3 3 4 5 9 102384 1203941023>; X.x(@tt, @tt1);

[10:46] <p6eval> rakudo ab2322: OUTPUT«123345912334591023841203941023␤»

[10:52] <isBEKaml> rakudo: my $xt=139741234132659817984750128304981495681749756018048321; say $xt; say $xt.WHAT;

[10:52] <p6eval> rakudo ab2322: OUTPUT«2934593596619636033␤Int()␤»

[10:53] <moritz_> that one is pretty nasty (and reported)

[10:53] <isBEKaml> yeah, that ran into overflow in my local p6 REPL

[10:55] <isBEKaml> what's the max limit of an Int() ? 

[10:55] <isBEKaml> or where is it documented? I'm looking at operators.pod.. 

[10:55] <moritz_> in theory Int should be a bigint

[10:56] <isBEKaml> I was curious when I saw the varargs spitting out exactly as I gave in. "say" does stringify it without casting into types. 

[10:57] <moritz_> more importantly, rakudo treats the insides of <...> as strings

[10:58] <isBEKaml> I'll keep that in mind... # < ... > === qw/ /

[10:59] <moritz_> actually the spec says there should be some more magic

[11:00] <moritz_> recognizing numbers and pairs inside <...>

[11:00] <moritz_> but the stringification should still be preserved

[11:00] *** Ross^ joined
[11:00] *** Ross^ is now known as Ross

[11:06] <isBEKaml> that surely must be based on what it is used with? say -> stringify. <..> -> relevant_stuff()

[11:07] <moritz_> rakudo: say 42 but role { method Str { "foo" } }

[11:07] *** patrickas left
[11:07] <p6eval> rakudo ab2322: OUTPUT«42␤»

[11:08] <moritz_> huh. That didn't work out as planned

[11:09] <isBEKaml> there must be a lot of type introspection going on under the hood with < ... > 

[11:09] *** arthur-_ left
[11:10] <moritz_> no, just parsing magic

[11:13] *** felipe left
[11:14] *** Su-Shee left
[11:14] *** gbacon left
[11:14] *** bloonix left
[11:14] *** skangas left
[11:14] *** mdxi left
[11:14] *** kcwu left
[11:14] *** dhoss left
[11:14] *** pnu left
[11:14] *** moritz_ left
[11:17] *** k23z__ left
[11:17] *** pmurias_ joined
[11:18] <isBEKaml> <...> doesn't seem to be treating Int()s, just Num() - I guess a broader range than Int() ? 

[11:18] *** k23z__ joined
[11:18] <isBEKaml> rakudo: my @tt = <1234 10302984019283401293571492859841 134 983>; my @tt1 = <2498 129238742394347 134 13445>; my @ttr = @tt1 Z+ @tt; say "tt:  @tt[]"; say "tt1: @tt1[]"; say "ttr: @ttr[]"; say @ttr>>.WHAT;

[11:18] <p6eval> rakudo ab2322: OUTPUT«tt:  1234 10302984019283401293571492859841 134 983␤tt1: 2498 129238742394347 134 13445␤ttr: 3732 1.03029840192834e+31 268 14428␤Num()Num()Num()Num()␤»

[11:18] <isBEKaml> note: the range is exceeded that of an Int(

[11:18] <isBEKaml> Int()

[11:19] *** Su-Shee joined
[11:19] *** gbacon joined
[11:19] *** bloonix joined
[11:19] *** skangas joined
[11:19] *** mdxi joined
[11:19] *** kcwu joined
[11:19] *** dhoss joined
[11:19] *** pnu joined
[11:19] *** moritz_ joined
[11:19] *** card.freenode.net sets mode: +o moritz_

[11:20] <isBEKaml> Zops are nice here.. :)

[11:20] *** Ross left
[11:20] *** clintongormley left
[11:23] <dalek> rakudo: ab01a92 | moritz++ | t/spectest.data:

[11:23] <dalek> rakudo: correct a test name, moritz--

[11:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ab01a92d9050f5e1cb691a484dcc6c85f68247c9

[11:32] <pugssvn> r30589 | moritz++ | [t/spec] make some debugging output harmless 

[11:33] *** rv2733 joined
[11:35] <masak> phenny: tell patrickas that the logotype/logo_32x32.png idea sounds good.

[11:35] <phenny> masak: I'll pass that on when patrickas is around.

[11:35] <masak> sjohnson: hi! indeed. how're you?

[11:40] *** k23z__ left
[11:41] <colomon> rakudo: say <1234>».WHAT

[11:41] <p6eval> rakudo ab2322: OUTPUT«Str()␤»

[11:41] <colomon> rakudo: say (+«<1234>)».WHAT

[11:41] <p6eval> rakudo ab2322: OUTPUT«Num()␤»

[11:42] <colomon> isBEKaml: note that those numbers in your example never are Ints.

[11:42] <masak> (but, it can be argued, should be)

[11:43] <moritz_> as I've done before :-)

[11:44] <colomon> I am merely describing what is, not what should be.  :)

[11:44] <masak> *nod*

[11:45] <isBEKaml> colomon: *nods*

[11:45] <colomon> so, is anyone else's latest Rakudo broken, or did my innocent changes last night have really weird effects?

[11:46] <moritz_> colomon: all fine here... except for non-zero exit statusses in some test files

[11:46] <isBEKaml> colomon: I didn't presume them to be Int()s, < ... > magic in retaining numbers and pairs gave me the impression that it can be Int()s too.. 

[11:47] <colomon> isBEKaml: < ... > magic is purely hypothetical so far, as far as I know.

[11:47] <colomon> moritz_: crap.

[11:48] <isBEKaml> colomon: So it isn't in yet? :O

[11:48] <colomon> isBEKaml: as I said, not as far as I know.

[11:48] <moritz_> colomon: exactly how innocent is it? :-)

[11:49] <colomon> moritz_: I made Real and Num versions of the numeric comparison operators.

[11:49] <colomon> all the math and operator tests work fine.

[11:50] <colomon> but '' ~ '' (those are single quotes) causes a seg fault.

[11:50] <moritz_> colomon: try the newest parrot

[11:50] <moritz_> colomon: lots of small string fixes since yesterday

[11:50] <colomon> hey, that happens with an unmodified copy, too.  :\

[11:50] <colomon> rakudo: say '' ~ ''

[11:50] <p6eval> rakudo ab2322:  ( no output )

[11:51] <moritz_> works fine here

[11:52] <isBEKaml> mine segfaulted too. I built this last night. 

[11:52] <colomon> what platform are you on?  it's failing for me on OS X 10.5 32-bit and 64-bit  CentOS.

[11:53] <moritz_> 64bit Debian here

[11:53] <moritz_> but today's parrot

[11:53] <snarkyboojum> I can verify segfault

[11:53] <colomon> ah.  I've bumped parrot to HEAD and I'm rebuilding now.

[11:53] <snarkyboojum> but with parrot 46393

[11:54] <moritz_> 46403 here

[11:58] <isBEKaml> afk &

[11:59] <colomon> with head (which is 46405, I think, without looking) '' ~ '' works again.

[11:59] <colomon> so does classify.t

[12:00] <moritz_> colomon: then feel free to bump PARROT_REVISION

[12:00] <colomon> moritz_: believe me, I will, as soon as I've done a full spectest.  :)

[12:00] <snarkyboojum> same here - rebuilding with parrot 46405 has fixed the segfault here

[12:00] <snarkyboojum> moritz_++ :)

[12:01] <moritz_> so, masak doesn't need to report :-)

[12:01] <snarkyboojum> and colomon++ (for noticing) :)

[12:01] * snarkyboojum stops going karma crazy

[12:04] <arnsholt> Hmm. I got a transient segfault on make test with latest Rakudo

[12:05] <arnsholt> Known issue?

[12:05] <arnsholt> (On OS X 10.6)

[12:05] <moritz_> arnsholt: yes.. pleae try upgrading to parrot HEAD

[12:05] * colomon really needs to get around to upgrading to 10.6...

[12:06] <moritz_> arnsholt: it should make the segfaults go away, only a few non-zero exits should remain

[12:06] <arnsholt> Ah, OK

[12:06] <sjohnson> masak: not bad:)

[12:06] <sjohnson> bedtime :)

[12:07] <masak> :)

[12:09] *** finanalyst joined
[12:10] <colomon> starting spectest again, but I think I hear a toddler singing in his crib.... I guess if I haven't checked patches in in 20 minutes, someone else should do the parrot bump.  :)

[12:10] *** barney joined
[12:11] * moritz_ tries to motivate himself to buy some foodstuff for the weekend

[12:12] <moritz_> and after that, maybe blogging about List.classify?

[12:13] <snarkyboojum> rakudo: use Test; ok(!( "\x[9FC4]"  ~~ m/^<.isIdeographic>$/ ), q{Don't match unrelated <isIdeographic>} );

[12:13] <p6eval> rakudo ab2322: OUTPUT«ok 1 - Don't match unrelated <isIdeographic>␤»

[12:13] <snarkyboojum> bizarro - that fails for me

[12:13] <snarkyboojum> not ok 4 - Don't match unrelated <isIdeographic>

[12:14] <snarkyboojum> I get 9 failures in t/spec/S05-mass/properties-derived.t

[12:14] <snarkyboojum> have for a while

[12:16] <moritz_> there are some platform specific differences wrt Unicode handling in regexes which we haven't been able to nail down yet

[12:17] <moritz_> rakudo: say [1, 2] cmp [1, 2, 0]

[12:17] <p6eval> rakudo ab2322: OUTPUT«-1␤»

[12:18] <moritz_> rakudo: say [1, 2] cmp [3, 2, 0]

[12:18] <p6eval> rakudo ab2322: OUTPUT«-1␤»

[12:19] <colomon> moritz_: ?

[12:19] <colomon> rakudo: say [1, 2] Zcmp [3, 2, 0]

[12:19] <p6eval> rakudo ab2322: OUTPUT«-10␤»

[12:20] <moritz_> colomon: I just wanted to check if cmp numifies arrays

[12:20] <snarkyboojum> strangely all the test that fail use \x[9FC4]

[12:20] <snarkyboojum> tests

[12:20] <colomon> moritz_: ah.

[12:20] <moritz_> colomon: no bug-hunting intetions or so :-)

[12:21] <colomon> actually, it's probably stringifying them, isn't it?

[12:21] <moritz_> 31896 passing tests now

[12:21] <colomon> that wouldn't get that result, hmmmm....

[12:21] <moritz_> rakudo: [1, 2] cmp [0]

[12:21] <p6eval> rakudo ab2322:  ( no output )

[12:21] <moritz_> rakudo: say [1, 2] cmp [0]

[12:21] <p6eval> rakudo ab2322: OUTPUT«1␤»

[12:21] <moritz_> you're right

[12:21] <moritz_> not sure what the right semantics would be

[12:22] <colomon> me neither.

[12:23] <colomon> (I just knew that there was <cmp>($a, $b), <cmp>(Num, Num), and some Date and Rat cmps and that's it.)

[12:23] <moritz_> in perl 5 it would numify

[12:23] <moritz_> no wait

[12:23] <moritz_> perl 5 has no "magic" cmp at all :-)

[12:24] * moritz_ -> shopping :/

[12:39] <isBEKaml> back

[12:46] *** JimmyZ joined
[12:49] *** iblechbot joined
[12:54] <dalek> rakudo: 7810dbe | (Solomon Foster)++ | build/PARROT_REVISION:

[12:54] <dalek> rakudo: Bump parrot version to get string fixes.

[12:54] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7810dbe417c0f068e4d4a00b2361617f4b18ca23

[12:54] <dalek> rakudo: f8ca417 | (Solomon Foster)++ | src/core/Real.pm:

[12:54] <dalek> rakudo: Add Real and Num versions of the numeric comparison operators.

[12:54] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f8ca417cfe64fc04e625fbf394190c9b7e7a70f5

[13:00] *** Su-Shee left
[13:00] *** gbacon left
[13:00] *** bloonix left
[13:00] *** skangas left
[13:00] *** mdxi left
[13:00] *** kcwu left
[13:00] *** dhoss left
[13:00] *** pnu left
[13:00] *** moritz_ left
[13:02] <masak> moritz_: I just pushed a commit to the web/ directory of proto, adding a bunch of .png icons. haven't seen the updated result on the site yet, but I'm guessing these will have to be copied somewhere, somehow.

[13:05] <jnthn> masak: What does "FRESH" mean?

[13:05] <masak> jnthn: update within the past 90 days.

[13:05] <jnthn> OK.

[13:05] <jnthn> Nice idea - maybe good to have a key at the bottom that explains that? :-)

[13:06] <masak> or simply a better hover text :P

[13:06] *** Su-Shee joined
[13:06] *** gbacon joined
[13:06] *** bloonix joined
[13:06] *** skangas joined
[13:06] *** mdxi joined
[13:06] *** kcwu joined
[13:06] *** dhoss joined
[13:06] *** pnu joined
[13:06] *** moritz_ joined
[13:06] *** card.freenode.net sets mode: +o moritz_

[13:07] <jnthn> Ooh, yes, even better.

[13:07] * jnthn doesn't have a proto checkout on this machine...not sure if I have commit access either, thorugh probably.

[13:08] <masak> who doesn't these days? ;)

[13:08] *** k23z__ joined
[13:09] * jnthn pulls the latest Rakudo and book

[13:10] <moritz_> masak: you could add a homepage to the github proto page

[13:10] <JimmyZ> ls

[13:10] <masak> moritz_: good idea.

[13:10] * masak does so

[13:20] <diakopter> pmurias: hi

[13:20] <diakopter> pmurias_: hi

[13:22] <diakopter> pmurias: I'm still trying to debug my broken code... 

[13:25] <masak> moritz_: hm. the proto.perl6.org site is updated now, save for the icons. what do I do?

[13:25] *** nihiliad joined
[13:32] <moritz_> masak: where should the icons come from?

[13:34] <moritz_> masak: simplest solution: change build-project-list.pl to copy them to $output_dir

[13:34] <masak> moritz_: good idea.

[13:34] * masak does that

[13:35] <moritz_> I didn't point the web server's DocumentRoot proto/web for security reasons

[13:36] <moritz_> like, accidental execution of perl scripts as CGI or so

[13:37] <masak> *nod*

[13:38] <isBEKaml> if we're storing the project icons on proto too, shouldn't there be a way to upload these things too? Consider this a future enhancement. :)

[13:38] <diakopter> masak: what was that test you ran the other day that showed the closure fail of current rakudo

[13:39] <masak> diakopter: gosh, there have been so many...

[13:39] <diakopter> the sub that returned a sub

[13:39] <masak> diakopter: but try calling the same closure-returning sub twice, executing the things in some order...

[13:39] <masak> diakopter: maybe just grep for my name and 'sub foo' in the logs?

[13:39] <diakopter> heh

[13:40] <masak> :P

[13:40] <dalek> csmeta: r248 | diakopter++ | trunk/Sprixel/ (6 files):

[13:40] <dalek> csmeta: [perlesque] Callable[:(OptionalParamTypes --> ReturnType)] as a type now *works*

[13:40] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=248

[13:40] <diakopter> pmurias: ping

[13:42] <masak> moritz_: hope this works. http://github.com/masak/proto/commit/09f011cdab51729ec105cf943f99460e320a2db7

[13:43] <moritz_> masak: testing it now...

[13:43] <moritz_> of course a cp *.png might work too :-)

[13:44] *** JimmyZ left
[13:45] *** _jaldhar joined
[13:45] * isBEKaml calls it an early night. Night, #perl6! :)

[13:46] <moritz_> sleep well

[13:46] <masak> isBEKaml: 'night!

[13:46] *** isBEKaml left
[13:47] <moritz_> masak: icons seem to work

[13:47] <masak> \o/

[13:47] <dalek> csmeta: r249 | diakopter++ | trunk/Sprixel/t/parse_bug.t:

[13:47] <dalek> csmeta: [perlesque] fix now-broken test since perlesque now requires the return type to

[13:47] <dalek> csmeta: appear in the signature parens after the -->, just to be more consistent with

[13:47] <dalek> csmeta: closure signatures.

[13:47] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=249

[13:48] <pmurias> diakopter: hi

[13:48] <diakopter> pmurias: found another bug; still fixing

[13:48] <masak> if someone sees a way to improve on the icons, feel free. I can draw, but it's not my forte.

[13:49] *** jaldhar_ joined
[13:49] *** _jaldhar left
[13:51] * moritz_ would suggest an opened book for "README", but can't draw

[13:52] <masak> I like the idea. lurkers, give it your best shot!

[13:52] <moritz_> and a stethoscope for tests

[13:52] <masak> :)

[13:53] <moritz_> and maybe a clock for "fresh"

[13:53] *** jaldhar_ left
[13:54] *** jaldhar_ joined
[13:55] *** jaldhar_ left
[13:55] *** jaldhar_ joined
[13:55] <moritz_> maybe thejoyofsix.org should collect similar things as perl6.org/fun/

[13:55] <snarkyboojum> looks like there's data for an "is popular" badge as well

[13:56] <moritz_> snarkyboojum: yes, but we (that is, masak++) decided against it

[13:56] <snarkyboojum> ah

[13:56] <masak> snarkyboojum: I can explain to you why if you want. :)

[13:56] <masak> short story: it promotes the wrong values.

[13:56] <snarkyboojum> was thinking along those lines

[13:58] <snarkyboojum> does proto have tests (not sure how you'd test it but..)

[13:59] <masak> moritz_: if you don't put a lot of risqué innuendo on thejoyofsix.org, I'll be very disappointed :)

[13:59] <masak> snarkyboojum: been thinking about developing a 'testable core' to proto.

[13:59] <masak> snarkyboojum: haven't gotten around to it.

[13:59] <snarkyboojum> rightio

[14:00] <snarkyboojum> you're a busy man - no doubt about it :)

[14:00] <masak> it's my own fault. I chose to become interested in this language community where almost everything is up for grabs :)

[14:01] * masak gets back to his code analyzing time-traveling graphical class explorer

[14:01] <snarkyboojum> heh

[14:01] <masak> snarkyboojum: speaking of which, where do we stand on tardis?

[14:02] <snarkyboojum> I haven't changed much since I pushed that branch

[14:02] <masak> snarkyboojum: my plan for the month is basically getting sigmund going. preferably before my talk in Moscow.

[14:02] <snarkyboojum> which is to say, v. basic yapsi integration

[14:02] <masak> v. basic yapsi integration is still good news.

[14:02] <masak> snarkyboojum++

[14:02] <snarkyboojum> masak: well it works, but you probably want to take a look :)

[14:03] <masak> I think I realized that we won't be able to get at $OUTER::a with the current API to Yapsi.

[14:03] <masak> we'll need to do something about that.

[14:03] <masak> apart from that, the best thing that could happen to Tardis is probably subroutines in Yapsi :)

[14:04] <snarkyboojum> right, nested blocks currently break with find-var or whatever it is

[14:04] <masak> ouch.

[14:04] <snarkyboojum> in tardis that is

[14:04] <masak> is there a failing test?

[14:04] * snarkyboojum checks

[14:05] <snarkyboojum> oh right.. tests :) they need completely updating

[14:05] <masak> :)

[14:05] <snarkyboojum> I'll get onto that in the yapsi-integration branch then :)

[14:14] <masak> \o/

[14:18] *** cognominal left
[14:20] *** cognominal joined
[14:24] <pugssvn> r30590 | colomon++ | [t/spec] A bunch of Real to Real comparison tests. 

[14:28] *** JimmyZ joined
[14:36] *** felipe joined
[14:36] *** JimmyZ left
[14:39] *** JimmyZ joined
[14:42] *** barney left
[14:44] *** mberends joined
[14:47] <dalek> rakudo: 91501c7 | (Martin Berends)++ | Test.pm:

[14:47] <dalek> rakudo: [Test.pm] emit per-test timestamps only if PERL6_TEST_TIMES is set

[14:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/91501c7c52e328e57b321f42a990222df4fe274d

[14:47] <dalek> rakudo: e30bcb0 | (Martin Berends)++ | tools/test_summary.pl:

[14:47] <dalek> rakudo: [tools/test_summary.pl] record test timings in JSON format in docs/test_summary.times

[14:47] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e30bcb064feac7274bc1cc84eedb38b9331c11e5

[14:49] <moritz_> mberends: pleasae .gitignore the generated file

[14:51] <mberends> ok moritz_++

[14:51] <JimmyZ> rakudo: say 1 if 1;

[14:51] <p6eval> rakudo ab2322: OUTPUT«1␤»

[14:51] <JimmyZ> rakudo: say if 1;

[14:51] <p6eval> rakudo ab2322: OUTPUT«␤»

[14:52] <mberends> moritz_: it was already .gitignored from previous work :)

[14:52] <moritz_> mberends: ah, great

[14:53] <masak> rakudo: say

[14:53] <p6eval> rakudo ab2322: OUTPUT«␤»

[14:53] <masak> alpha; say

[14:53] <masak> alpha: say

[14:53] <p6eval> alpha 30e0ed: OUTPUT«say requires an argument at line 10, near ""␤in Main (file src/gen_setting.pm, line 2593)␤»

[14:54] <JimmyZ> rakudo: say if if 1;

[14:54] <p6eval> rakudo ab2322: OUTPUT«Could not find sub &if␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[14:54] <JimmyZ> rakudo: sub if() { '2' }; say if if 1;

[14:54] <p6eval> rakudo ab2322: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'if' pc 210 (EVAL_1:44870260)␤»

[14:55] <JimmyZ> rakudo: sub ifs() { '2' }; say ifs if 1;

[14:55] <p6eval> rakudo ab2322: OUTPUT«2␤»

[14:55] <JimmyZ> bug?

[14:55] <JimmyZ> rakudo: sub if() { '2' }; say if;

[14:55] <p6eval> rakudo ab2322: OUTPUT«␤»

[14:55] *** kfo_ joined
[14:55] <masak> o.O

[14:55] <JimmyZ> rakudo: sub if() { '2' }; say if();

[14:55] <p6eval> rakudo ab2322: OUTPUT«2␤»

[14:56] <masak> std: say if

[14:56] <p6eval> std 30590: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'if' used at line 1␤Potential difficulties:␤  Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/Kl15RUYHeZ line 1:␤------> [32msay[33m⏏[31m

[14:56] <p6eval> ..if[0m␤Check fa…

[14:56] <masak> rakudo: say if

[14:56] <p6eval> rakudo ab2322: OUTPUT«Could not find sub &if␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[14:56] * masak submits rakudobug

[14:57] <mberends> masak: who would ever have imagined that proto (obviously a throwaway name) would become a hostname. What's next? A domain name? An RFC? A proto-col?

[14:57] <JimmyZ> rakudo: my @a = 1, 2, 3; say (1 .. ^@a).perl.say

[14:57] <p6eval> rakudo ab2322: OUTPUT«1..0..^[1, 2, 3]␤1␤»

[14:57] <JimmyZ> alpha: my @a = 1, 2, 3; say (1 .. ^@a).perl.say

[14:57] <p6eval> alpha 30e0ed: OUTPUT«1..0..^3␤1␤»

[14:57] *** wknight8111 left
[14:57] <masak> mberends: :P

[14:57] <JimmyZ> masak: Is it another bug?

[14:58] *** kfo left
[14:58] *** kfo_ is now known as kfo

[14:58] <JimmyZ> rakudo: my @a = 1, 2, 3; ^@a.perl.say

[14:58] <p6eval> rakudo ab2322: OUTPUT«[1, 2, 3]␤»

[14:59] <moritz_> rakudo: my @a = 1, 2, 3; say (0 ..^ @a).perl

[14:59] <p6eval> rakudo ab2322: OUTPUT«0..^[1, 2, 3]␤»

[14:59] <JimmyZ> alpha: my @a = 1, 2, 3; (1 ... ^@a).perl.say

[14:59] <p6eval> alpha 30e0ed: OUTPUT«don't know how to handle a right-hand side of[0, 1, 2]in series operator␤in sub »

[14:59] <JimmyZ> rakudo: my @a = 1, 2, 3; (1 ... ^@a).perl.say

[14:59] <p6eval> rakudo ab2322: OUTPUT«(1)␤»

[15:02] <JimmyZ> alpha: sub take() { 'hi' }; say take;

[15:02] <p6eval> alpha 30e0ed: OUTPUT«hi␤»

[15:02] <JimmyZ> alpha: say take;

[15:02] <p6eval> alpha 30e0ed: OUTPUT«too few positional arguments: 0 passed, 1 (or more) expected␤in Main (file <unknown>, line <unknown>)␤»

[15:03] <JimmyZ> rakudo: sub take() { 'hi' }; say take;

[15:03] <p6eval> rakudo ab2322: OUTPUT«hi␤»

[15:03] <finanalyst> rakudo: my @x=-2,1.2,-1.4,0.2; say @x.max: { .abs }

[15:03] <p6eval> rakudo ab2322: OUTPUT«Too many positional parameters passed; got 2 but expected between 0 and 1␤current instr.: '_block62' pc 440 (EVAL_1:22350388)␤»

[15:04] <finanalyst> alpha: my @x=-2,1.2,-1.4,0.2; say @x.max: { .abs }

[15:04] <p6eval> alpha 30e0ed: OUTPUT«-2␤»

[15:04] <JimmyZ> rakudo: sub take() { 'hi' }; say ~ gather { for 1 .. 5 -> $_ { take $_; } }

[15:04] <p6eval> rakudo ab2322: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'take' pc 211 (EVAL_1:25854642)␤»

[15:04] <jnthn> rakudo: role R { method m { say 42 } }; R.m

[15:04] <p6eval> rakudo ab2322: OUTPUT«Could not find sub &say␤current instr.: 'perl6;R[];m' pc 537 (EVAL_1:22350453)␤»

[15:04] <JimmyZ> rakudo: sub take() { 'hi' }; say [~] gather { for 1 .. 5 -> $_ { take $_; } }

[15:04] <p6eval> rakudo ab2322: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'take' pc 245 (EVAL_1:22350334)␤»

[15:04] <JimmyZ> rakudo: sub take() { 'hi' }; say [~] gather { for 1 .. 5 -> $_ { take $_; } }; say take

[15:04] <p6eval> rakudo ab2322: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'take' pc 265 (EVAL_1:96)␤»

[15:04] *** pmurias_ left
[15:04] <moritz_> JimmyZ: if you don't declare take() as a multi, you hide all the outer candidates

[15:05] <JimmyZ> rakudo: multi sub take() { 'hi' }; say [~] gather { for 1 .. 5 -> $_ { take $_; } }; say take

[15:05] <p6eval> rakudo ab2322: OUTPUT«No applicable candidates found to dispatch to for 'take'. Available candidates are:␤:()␤␤current instr.: '_block85' pc 657 (EVAL_1:30333074)␤»

[15:05] <JimmyZ> rakudo: say [~] gather { for 1 .. 5 -> $_ { take $_; } }; say take

[15:05] <p6eval> rakudo ab2322: OUTPUT«12345␤too few positional arguments: 0 passed, 1 (or more) expected␤current instr.: '&take' pc 18249 (src/builtins/Capture.pir:129)␤»

[15:05] <jnthn> I suspect that take is not currently defined as a multi.

[15:05] <finanalyst> moritz_: is sort broken when a callable is supplied?

[15:05] <jnthn> So even declaring a multi hides the one in the setting.

[15:05] <moritz_> finanalyst: don#t think so

[15:06] <JimmyZ> alpha: multi sub take() { 'hi' }; say [~] gather { for 1 .. 5 -> $_ { take $_; } }; say take

[15:06] <p6eval> alpha 30e0ed: OUTPUT«push_pmc() not implemented in class 'Sub'␤in Main (file <unknown>, line <unknown>)␤»

[15:06] <moritz_> jnthn: should it be multi? I'd think so...

[15:06] <JimmyZ> alpha: sub take() { 'hi' }; say [~] gather { for 1 .. 5 -> $_ { take $_; } }; say take

[15:06] <finanalyst> rakudo: my @x=-2,1.2,-1.4,0.2; say @x.max: { .abs }

[15:06] <p6eval> alpha 30e0ed: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤in Main (file src/gen_setting.pm, line 324)␤»

[15:06] <p6eval> rakudo ab2322: OUTPUT«Too many positional parameters passed; got 2 but expected between 0 and 1␤current instr.: '_block62' pc 440 (EVAL_1:22350388)␤»

[15:06] <moritz_> finanalyst: what has it got to do with sort?

[15:06] <finanalyst> sorry. max

[15:07] <moritz_> rakudo: my @x=-2,1.2,-1.4,0.2; say @x.sort( { .abs })[0]

[15:07] <JimmyZ> alpha:  say gather

[15:07] <p6eval> rakudo ab2322: OUTPUT«0.2␤»

[15:07] <p6eval> alpha 30e0ed: OUTPUT«too few positional arguments: 0 passed, 1 (or more) expected␤in Main (file <unknown>, line <unknown>)␤»

[15:07] <JimmyZ> rakudo:  say gather

[15:07] <p6eval> rakudo ab2322: OUTPUT«Could not find sub &gather␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[15:07] <colomon> finanalyst: max can take a closure which takes two arguments (ie a comparison function) but not one which takes just one.

[15:07] <colomon> yet, that's not up to spec.

[15:07] <colomon> though the spec is kind of vague, as I recall.

[15:08] <finanalyst> colomon: max worked in alpha

[15:08] <finanalyst> with one argument

[15:08] <colomon> Anyone one a copy of Programming Languages: Principles and Practice by Kenneth C. Louden?  State of the art circa 1992....

[15:08] * moritz_ has blogged: http://perlgeek.de/blog-en/perl-6/list-classify.html

[15:09] <moritz_> finanalyst: that doesn't mean it's spec :-)

[15:09] *** mberends left
[15:09] <finanalyst> well it was consistent with sort

[15:09] <colomon> I think it should be spec, but the spec is funky here.

[15:10] <moritz_> we can certainly talk about making it spec

[15:10] <colomon> It takes an "Ordering" argument, which might be a closure

[15:10] <colomon> but "Ordering is as described in "Type Declarations""

[15:10] <colomon> and that section isn't there, as far as I can tell.

[15:10] <colomon> but maybe I'm just not looking in the right place.

[15:10] <colomon> gotta run to the farmer's market....

[15:11] <moritz_> S29:138 subset Ordering where Signature | KeyExtractor | Comparator | OrderingPair | Whatever

[15:11] <JimmyZ> alpha:  sub gather($a) { 'hi'; }; say gather { take $_; }

[15:11] <p6eval> alpha 30e0ed: OUTPUT«hi␤»

[15:11] <moritz_> let's say "huh"

[15:11] <masak> moritz_: nice post.

[15:11] <JimmyZ> rakudo:  sub gather($a) { 'hi'; }; say gather { take 'oh; }

[15:11] <p6eval> rakudo ab2322: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[15:11] <finanalyst> if you compare the specs for sort, min and max, they are all similar, which they should be. So why do they work differently?

[15:11] <JimmyZ> rakudo:  sub gather($a) { 'hi'; }; say gather { take 'oh'; }

[15:11] <moritz_> masak: thanks. I kinda feel it lacks a strong finish

[15:11] <p6eval> rakudo ab2322: OUTPUT«oh␤»

[15:12] <JimmyZ> rakudo:  sub gather($a) { 'hi'; }; say gather { take $_; }

[15:12] <p6eval> rakudo ab2322: OUTPUT«Any()␤»

[15:12] <masak> moritz_: I like the finish. it currently has me thinking back over recent code. :)

[15:12] <JimmyZ> alpha:  sub gather($a) { 'hi'; }; say gather { take $_; }

[15:12] <p6eval> alpha 30e0ed: OUTPUT«hi␤»

[15:13] <JimmyZ> alpha:  sub gather($a) { 'hi'; }; say gather { take 'hello'; }

[15:13] <p6eval> alpha 30e0ed: OUTPUT«hi␤»

[15:13] *** [Coke] left
[15:13] <JimmyZ> rakudo:  sub gather($a) { 'hi'; }; say gather { take 'hello'; }

[15:13] <p6eval> rakudo ab2322: OUTPUT«hello␤»

[15:13] <JimmyZ> which one is right?

[15:14] <JimmyZ> alpha: say gather { take 'hello'; }

[15:14] <p6eval> alpha 30e0ed: OUTPUT«hello␤»

[15:14] <moritz_> rakudo:  sub gather($a) { 'hi'; }; say gather { take('hello'); }

[15:14] <p6eval> rakudo ab2322: OUTPUT«hello␤»

[15:14] <moritz_> that certainly should be "hi"

[15:14] * masak submits rakudobug

[15:14] *** plobsing joined
[15:16] <JimmyZ> and the 'take' ?

[15:16] <masak> is never executed.

[15:16] <masak> because it's in the closure passed as $a.

[15:17] <JimmyZ> rakudo:  sub take($a) { 'hi'; }; say gather { take 'hello'; }

[15:17] <p6eval> rakudo ab2322: OUTPUT«␤»

[15:17] <JimmyZ> alpha:  sub take($a) { 'hi'; }; say gather { take 'hello'; }

[15:17] <p6eval> alpha 30e0ed: OUTPUT«␤»

[15:17] <jnthn> masak: Why should it be "hi"?

[15:17] <jnthn> gather(...) is certainly a sub call

[15:18] <JimmyZ> alpha:  sub gather($a) { $a(); }; say gather { take 'hello'; }

[15:18] <p6eval> alpha 30e0ed: OUTPUT«take without gather␤hello␤»

[15:18] <jnthn> But gather { ... } need not be.

[15:18] <masak> jnthn: you're right.

[15:18] <masak> it's not a bug.

[15:19] <jnthn> rakudo: sub gather($a) { say "hi" }; say gather({ take ('hello') })

[15:19] <masak> I now think one has to use () to distinguish the function call from the statement prefix.

[15:19] <p6eval> rakudo ab2322: OUTPUT«hi␤1␤»

[15:19] <masak> nothing to see here, move along :)

[15:19] <JimmyZ> alpha:  sub gather($a) { gather $a(); }; say gather { take 'hello'; }

[15:19] <jnthn> And we get it right there. (phew) :-)

[15:19] <p6eval> alpha 30e0ed: OUTPUT«maximum recursion depth exceeded␤in Main (file <unknown>, line <unknown>)␤»

[15:19] <masak> JimmyZ: you need {} after 'gather'.

[15:19] <JimmyZ> alpha:  sub gather($a) { gather {$a()}; }; say gather { take 'hello'; }

[15:20] <p6eval> alpha 30e0ed: OUTPUT«maximum recursion depth exceeded␤in Main (file <unknown>, line <unknown>)␤»

[15:20] <JimmyZ> alpha:  sub gather(Code $a) { gather {$a()}; }; say gather { take 'hello'; }

[15:20] <p6eval> alpha 30e0ed: OUTPUT«maximum recursion depth exceeded␤in Main (file <unknown>, line <unknown>)␤»

[15:20] <masak> hm.

[15:20] <JimmyZ> rakudo: say ({take 'hello';}).WHAT

[15:20] <p6eval> rakudo ab2322: OUTPUT«Block()␤»

[15:20] <JimmyZ> alpha:  sub gather(Blocak $a) { gather {$a()}; }; say gather { take 'hello'; }

[15:21] <p6eval> alpha 30e0ed: OUTPUT«Malformed routine definition at line 10, near "gather(Blo"␤in Main (file <unknown>, line <unknown>)␤»

[15:21] <JimmyZ> alpha:  sub gather(Block $a) { gather {$a()}; }; say gather { take 'hello'; }

[15:21] <p6eval> alpha 30e0ed: OUTPUT«maximum recursion depth exceeded␤in Main (file <unknown>, line <unknown>)␤»

[15:21] <JimmyZ> alpha:  sub gather(Block $a) { gather $a(); }; say gather { take 'hello'; }

[15:21] <p6eval> alpha 30e0ed: OUTPUT«Nominal type check failed for parameter '$a'; expected Block but got Code instead␤in Main (file src/gen_setting.pm, line 324)␤»

[15:21] <pugssvn> r30591 | moritz++ | [S32] sub form of min, max and minmax take the ordering argument by name 

[15:21] <pugssvn> r30591 | 

[15:21] <pugssvn> r30591 | Otherwise it would be too confusing that max(1, 2, 3) takes the 1 as

[15:21] <pugssvn> r30591 | comparison criterion.

[15:22] <dalek> rakudo: 30ac13b | jonathan++ | src/Perl6/Compiler/Role.pm:

[15:22] <dalek> rakudo: Partially fix the role + lexical setting issue (but not completely :-/).

[15:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/30ac13bd83551e067e4ab9d749a6d44c865cf76e

[15:22] <dalek> rakudo: b52bbee | jonathan++ | src/glue/dispatch.pir:

[15:22] <dalek> rakudo: Make $obj.RoleName::method() calls work.

[15:22] *** mberends joined
[15:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b52bbeee4291e43da8e3bc81aec79dcdb01e6554

[15:23] <JimmyZ> if I create 'take' sub by myself, then I can't use the 'take sub of perl 6 ?

[15:23] *** jonrafkind joined
[15:23] <moritz_> does it say anywhere that take is a sub?

[15:24] <JimmyZ> someone said take is a sub

[15:24] <JimmyZ> an gather isn't

[15:24] <JimmyZ> and gather isn't

[15:24] <moritz_> not good enough :-)

[15:25] <masak> S04 says it's a 'list prefix operator'.

[15:25] <masak> OTOH, in the next sentence it calls it a function. :P

[15:26] <masak> but that's not a contradiction in Perl 6, I guess.

[15:26] <moritz_> right

[15:26] <masak> S04 is full of mentions of the 'take function'.

[15:26] <masak> I'd certainly expect that if you overrode it, you'd get your version, not the original one.

[15:27] <moritz_> I guess you can access &OUTER::say once that's implemented

[15:27] <masak> &OUTER::take? yes, certainly.

[15:27] <masak> or do a nextsame or something.

[15:27] <JimmyZ> nextsame?

[15:27] <masak> JimmyZ: S06.

[15:28] <JimmyZ> ok, thanks

[15:28] <moritz_> nextsame works only if it's a multi

[15:28] <JimmyZ> take is not a multi

[15:28] <masak> or if you wrap the original &take.

[15:29] <moritz_> TIMTOWTDI

[15:29] <masak> 'nextsame' tells the dispatcher to call the next candidate with the same arguments. as far as I know, there are three situations with such dispatchers: inheritance, multi dispatch, and wrapping.

[15:29] <masak> I'm still on the lookout for interesting corner cases between these :)

[15:30] <TimToady> and, with the newest change, it is specced to *start* the multi dispatcher within a proto

[15:30] <jnthn> I suspect that whole ot needs to be ripped up and done again some day thanks to recent changes.

[15:30] <jnthn> *lot

[15:31] <TimToady> or the proto just automatically sets up the dispatcher on entry to a proto, and the nextsame just finds the first entry

[15:31] <masak> jnthn: you remember that OO/Damian/nextwith issue? was there ever a followup to that?

[15:31] <TimToady> that does less violence to the 'nextsame' semantics

[15:32] <jnthn> masak: I don't think we got to a conclusive answer.

[15:32] <masak> jnthn: neither do I.

[15:32] <masak> but I hardly remember the issue.

[15:32] <jnthn> Current Rakudo semantics are the sanest answer I have to date.

[15:32] <jnthn> There are other ways, but I think they create worse problems.

[15:33] <moritz_> solution: don't let Damian anywhere near Perl6 :-)

[15:33] <TimToady> or maybe we should make scanmulti a call that precedes nextsame

[15:33] <jnthn> scanmulti?

[15:33] <TimToady> find the candidates

[15:33] <masak> moritz_: you joke, but I believe Damian has contributed some wonderful simplifications too.

[15:33] <jnthn> Ah.

[15:34] <jnthn> moritz_: I'm not sure that it was Damian who found the issue in the first place, fwiw. He just got roped into the discussion. :-)

[15:34] <masak> moritz_: the eventual MMD resolution mechanism was partly his idea, IIRC.

[15:34] <TimToady> then the magic is in scanmulti instead of overloading nextsame inside a proto

[15:34] <moritz_> yes, I do joke

[15:34] <masak> yeah, jnthn showed me some scary internals, we both went 'wtf?' and then we went and talked to Damian, who also looked puzzled.

[15:34] <moritz_> and I don't want to diminish TheDamian++'s contributions to perl6 in any way

[15:35] <TimToady> which issue was this?

[15:35] * masak wishes he remembered the details

[15:35] <jnthn> TimToady: If you do nextwith/callwith and provide arguments of different types than the initial call.

[15:36] <masak> ah, right.

[15:36] <masak> you end up outside of the already collected set of candidates.

[15:36] <jnthn> However, we already computed our candidates based on the origian arguments.

[15:36] <TimToady> right

[15:36] <jnthn> *original

[15:36] <jnthn> So the dispatch fails

[15:36] <jnthn> Which by me is completely fine.

[15:36] <TimToady> this seems fine to me

[15:37] <jnthn> (the nextwith/callwith fails, I menat)

[15:37] <jnthn> Oh, good. :-)

[15:37] <masak> so simple!

[15:37] <TimToady> nextwith is just for lying to the candidates you already have

[15:37] <TimToady> if you want a new dispatch, you know where to find it

[15:38] <jnthn> *nod*

[15:38] <moritz_> if you do &?ROUTINE($args), will it do a fresh multi dispatch?

[15:38] <moritz_> or will it instead try to call this very candidate we're in?

[15:38] <TimToady> I don't think so

[15:38] <TimToady> not unless &?ROUTINE is a proto

[15:38] <masak> rakudo: class A { method foo(Str $a) { say "A" } }; class B is A { method foo($a) { say "B"; nextwith(42) } }; B.new.foo("OH HAI")

[15:39] <p6eval> rakudo ab2322: OUTPUT«B␤Nominal type check failed for parameter '$a'; expected Str but got Int instead␤current instr.: 'perl6;A;foo' pc 432 (EVAL_1:22350418)␤»

[15:39] <masak> \o/

[15:39] <TimToady> .() there is a low-level invoke

[15:39] <TimToady> and now it's *always* a low-level invoke

[15:39] <TimToady> and you get multi dispatch by low-level invoking a proto

[15:40] <masak> rakudo: class A { multi method foo(Str $a) { say "Str" }; multi method foo(Int $a) { say "Int" } }; class B is A { method foo($a) { say $a; nextwith(42) } }; B.new.foo("OH HAI")

[15:40] <p6eval> rakudo ab2322: OUTPUT«OH HAI␤Int␤»

[15:40] <masak> should that work?

[15:40] <TimToady> so .() never has to worry about multis anymore

[15:40] <masak> the Int multi candidate is not in the initial set of candidates.

[15:40] <TimToady> multis are ignore by the .() dispatcher

[15:40] <masak> ah, so it should worK?

[15:40] <jnthn> masak: Multi dispatch is a nested dispatch

[15:40] <TimToady> .() only looks for an only/proto

[15:41] <TimToady> that's that long-term plan

[15:41] <TimToady> not the current setup

[15:41] <masak> *nod*

[15:41] <jnthn> We only look for candidates at the current inheritance "level".

[15:41] <masak> when you say .() dispatch, that's as opposed to which other dispatches?

[15:41] <TimToady> .method() dispatch

[15:41] <jnthn> We don't go looking all the way up the tree until a nextwith requires us to do so

[15:41] <masak> ok.

[15:42] <jnthn> Since most of the time we don't need such candidates since we don't usually defer.

[15:42] <TimToady> but the same principle holds there now too

[15:42] <masak> seems sane.

[15:42] <TimToady> .method() just looks for an ordinary method or proto

[15:42] <jnthn> I *hope* that aspect of things hasn't changed.

[15:42] <jnthn> In which case we *may* get away with just changing Rakudo's multi dispatcher and the method one can mostly stay as it is.

[15:43] <TimToady> the difference there now is that the proto method can call multis in subclasses too

[15:43] <jnthn> And it may not even be quite as bad a change as I fear, but it's still going to hurt.

[15:43] <jnthn> TimToady: Please no.

[15:43] <TimToady> please yes

[15:43] <jnthn> TimToady: Don't do that.

[15:43] <TimToady> you don't have to do it for Rakudo *

[15:43] <TimToady> the current semantics fall out if you put a proto in any class with multis

[15:44] <jnthn> I don't want to do it at all. It seems to completely mess up the idea of the multi dispatch being a nested dispatch.

[15:44] <TimToady> it's very consistent, and I think you'll see that eventually :)

[15:44] <jnthn> :-/

[15:45] <TimToady> it's still a nested dispatch, just just that a method proto finds a different set of candidates

[15:45] <TimToady> that's all

[15:45] <jnthn> But then the method proto needs to know about the fact that it's in a class hierarchy.

[15:45] <TimToady> and that's already how regexes have to work their protos

[15:45] <TimToady> methods are supposed to know that!!!

[15:45] <TimToady> that's what makes 'em methods :)

[15:46] <jnthn> No

[15:46] <jnthn> A class has methods

[15:46] <jnthn> The dispatcher knows about the hierarchy.

[15:46] <jnthn> It finds said methods.

[15:46] <masak> I must admit that I initially expected multis to dispatch across inheritance relations. haven't completely ingested the new spec changes, but I think they now match my initial expectations.

[15:46] <jnthn> I find this very clean.

[15:47] <jnthn> Well, a class knows about is parents of course

[15:47] <jnthn> But my point was more that the dispatcher finds the methods by looking at the class.

[15:47] <jnthn> Or classes

[15:47] <jnthn> And then just calls 'em.

[15:48] <jnthn> And the methods themselves don't really care so much about what class they are in, or how they got called.

[15:48] <TimToady> well, protos are always special that way

[15:48] <TimToady> that's why they're protos

[15:48] <jnthn> Does this mean we're going to be doing the "auto-generated proto" kind of thing too?

[15:49] <TimToady> well, we have a choice

[15:49] <TimToady> when we see a multi that has no proto around it

[15:49] <TimToady> we can either generate one, or fail

[15:49] <TimToady> bare multis can never be called

[15:49] <TimToady> well, I suppose they can be exported into a proto's scope

[15:49] <jnthn> That would make class C { multi method m() { say 42 } }; C.m # fail

[15:50] <jnthn> Because there's no proto?

[15:50] <masak> o.O

[15:50] <moritz_> sounds too complicated for the user

[15:50] <TimToady> unless there's a generic proto in some base class like Any, which theyre might be

[15:50] <TimToady> *there

[15:50] <masak> :-/

[15:51] <masak> that will invalidate a lot of existing code.

[15:51] <TimToady> we already have 10 users...

[15:52] * moritz_ doesn't really see the need for such a deep change

[15:52] <masak> TimToady: I know this was what I signed up for as an early adopter. so I'm not really complaining.

[15:52] <jnthn> TimToady: "generic proto"

[15:52] <masak> TimToady: but... are you sure there's a need to break things?

[15:52] <JimmyZ> another revolution?

[15:53] <jnthn> masak: I'm mostly complaining because I'm not sure I have the motivation to do such an epic re-write of something I've spent the last two years trying to get in shape against the spec...before it changed. :-/

[15:53] <masak> jnthn: I can see that.

[15:53] <jnthn> Which is fine, because stuff getting done doesn't only depend on me.

[15:53] *** mberends left
[15:54] <moritz_> not only, but mostly :(

[15:54] <jnthn> But, well...I don't see many others hacking on this area.

[15:54] <masak> jnthn: I can also kinda glimpse the consistency TimToady is talking about.

[15:54] <jnthn> masak: Me too.

[15:54] <jnthn> I do like the idea of drawing proto regex semantics and proto method semantics closer together.

[15:54] <masak> but I don't like the fact that one how needs to declare a proto.

[15:55] <masak> jnthn: me too.

[15:55] <masak> that seems fundamentally sane.

[15:56] *** JimmyZ left
[15:57] <moritz_> insane

[15:58] <masak> the need to declare a proto for multis, yes.

[15:58] <masak> the unification of regex and method proto semantics seems fundamentally sane.

[15:59] <jnthn> Yes, making users declare a proto is a bit...ugh. OTOH, does the unification argue for having the proto regex protos auto-generate too if the method ones are going to.

[15:59] <TimToady> please note that I said we had a choice there; I have not made that choice

[15:59] <jnthn> TimToady: Aye, but one of the choices feels...very unfriendly.

[15:59] <TimToady> giving people control when they need it is not unfriendly

[16:00] <TimToady> defaulting to a global proto when they don't is also not unfriendly

[16:00] <jnthn> Making them write a proto with every multi, rather than it being an option, otoh...

[16:00] <TimToady> why are you guys panicking?  I never said that

[16:00] <jnthn> I don't get "global proto" really.

[16:00] * masak panics a bit less

[16:00] <jnthn> TimToady: Maybe not, but multiple of us seem to have taken it that way. :-)

[16:01] * jnthn too

[16:01] <jnthn> TimToady: Can you elaborate on what "global proto" would mean?

[16:01] <TimToady> if for any foo() there's a (yes, generated), proto foo (|$anything_you_like) {} then I don't see much problem

[16:02] <TimToady> whatever the least-specific signature is

[16:02] <jnthn> *nod*

[16:02] <TimToady> it's just a proto that allows any kind of multi in in

[16:02] <TimToady> in it

[16:02] <masak> does that go for multi methods too?

[16:02] <TimToady> probably generated at the UNIT level

[16:03] <TimToady> yes, a generic proto method in Any, or some similar place

[16:03] <TimToady> note, however, that means a multi method could call candidates both higher and lower in the class hierarchy

[16:03] <TimToady> to limit it to subtypes, you'd put a proto in your class

[16:04] <TimToady> just as to limit multi subs to a lexical scope

[16:04] <TimToady> you put a proto in that scope

[16:05] *** hercynium left
[16:05] <TimToady> presumably the pecking order of multi methods can be tweaked to make sure ties between class break in favor of Liskov, if that's a problem

[16:07] <masak> TimToady: so when I declare my first multi .foo in Foo, a proto .foo gets installed in Any?

[16:07] <jnthn> Any.methods is gonna look great. ;-)

[16:07] <masak> without MONKEY_TYPING?

[16:08] <jnthn> I think they'd have to be "hidden" in some way, or just "exist in theory" or something.

[16:08] <jnthn> well

[16:08] <jnthn> that won't work either

[16:08] <jnthn> hmm

[16:08] <moritz_> or is there an Any.GENERIC_PROTO?

[16:08] <TimToady> it might just get installed in the parentest class that needs it

[16:09] <masak> this feels very magical.

[16:09] <TimToady> as in "if you were to put an explicit proto, this is where you'd have put it"

[16:09] <moritz_> that seems to introduce a fundamental asymmetry between classes and roles

[16:09] <TimToady> there wasn't one already? :)

[16:10] <moritz_> another one, I might say :-)

[16:10] <TimToady> masak: magic is fine if it's the right magic

[16:10] <masak> absolutely.

[16:11] <TimToady> likewise, instead of just poking a proto into UNIT, it could go into the first lexical scope that actually uses a multi

[16:11] <masak> but in essence, this is the kind of magic that causes definition of new classes to slip a proto into some parenter class, without the need for MONKEY_TYPING.

[16:11] <TimToady> this might be suboptimizal though, if you're expecting multis in different scopes to "share"

[16:11] <moritz_> "this magic needs more magic"

[16:12] <TimToady> masak: something like that, and we could shield the user from that to some extent, even, if we don't tell them those methods are there unless they ask specifically

[16:12] <TimToady> if we decided that was a good thing

[16:12] <TimToady> at least clump the proto methods in a group that can be ignored easily :)

[16:13] <masak> I'll withhold judgment until I see this actually implemented somewhere. :)

[16:13] <masak> if it's really that bad, the poor implementors will complain enough anyway.

[16:14] <TimToady> it's also not clear to what extent that different modules will want to share the same set of default protos; but this is something we'd have to deal with anyway, under MI

[16:15] <colomon> woah, tools/test_summary.pl just blew up badly for me.  :(

[16:15] <colomon> Ah, it's been upgraded to require 5.10, I guess?

[16:16] <TimToady> but I find it fundamentally comforting that any ordinary dispatch, whether functional or methodical, is looking only for a single thing to invoke, and that thing we invoke does a delegation to handle all cases of multi, and that delegation is customizable at that single point

[16:16] <moritz_> colomon: the only 5.10ism I spot is line 253

[16:17] <moritz_> colomon: easy enough to change to ||

[16:17] <TimToady> and I don't see it as being that hard to get to, more of a code rearrangement of where the candidate list is calculate, but nextsame etc don't change at all

[16:17] <TimToady> *calculated

[16:17] <lisppaste3> colomon pasted "tools/test_summary.pl messages" at http://paste.lisp.org/display/98961

[16:18] <moritz_> colomon: yep, change // to || on that line

[16:19] <colomon> moritz_: was just running it using 5.10.  :)  but I blew a lot of error messages, so I've stopped that.

[16:19] <colomon> 5.10 just isn't my default perl.

[16:21] <colomon> wow, a bit disturbed at how casually I've thrown cmp's using complex numbers about the code.  Mr. Foster, those do not work!  (yet)

[16:21] <masak> std: sub if() { '2' }; say if;

[16:21] <p6eval> std 30591: OUTPUT«Potential difficulties:␤  Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/uedzAGDWOF line 1:␤------> [32msub if() { '2' }; say[33m⏏[31m if;[0m␤ok 00:01 113m␤»

[16:21] <masak> o.O

[16:22] <masak> so... it's OK... but I shouldn't use a bare 'say'...

[16:22] <masak> what?

[16:22] <moritz_> std: sub foo(); foo if;

[16:22] <p6eval> std 30591: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/IGEo2r594o line 1:␤------> [32msub foo()[33m⏏[31m; foo if;[0m␤    expecting any of:␤  block␤  new name to be defined␤     param_sep␤      routine_def␤      signature␤        trait␤Parse failed␤FAILED 00:01 111m␤»

[16:22] <diakopter> backtracking?

[16:22] <masak> diakopter: possibly.

[16:23] <masak> diakopter: rakudo currently does something very similar, as uncovered by JimmyZ++ earlier.

[16:24] <TimToady> if is currently considered a terminator, as are all statement modifiers

[16:24] <TimToady> and terminators are slightly keywordish

[16:24] <masak> why then is the statement not an error?

[16:25] <masak> the 'if' needs to be followed by an expression if it's parsed as a keyword, no?

[16:25] <TimToady> you'd think

[16:25] <masak> std: "OH HAI" if;

[16:25] <p6eval> std 30591: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'if' used at line 1␤Check failed␤FAILED 00:01 110m␤»

[16:25] <masak> case in point.

[16:25] <TimToady> well, LTA error there

[16:26] <masak> aye.

[16:27] <TimToady> but it shows characteristics of parsing something both as a terminator and then as a term, which is a bit odd, so probably either

[16:27] <TimToady> 1) some unnecessary backtracking, or

[16:27] <TimToady> 2) something not properly hidden inside a "suppose"

[16:27] <masak> this all goes into the ticket.

[16:28] <TimToady> std: sub if() { '2' }; say if();

[16:28] <p6eval> std 30591: OUTPUT«ok 00:01 111m␤»

[16:29] <TimToady> and overriding the standard control words typically requires parens on the call anyway, since the control words typically steal the listop LTM slot

[16:30] <TimToady> but anyone who writes "say if;" probably deserves a WTF sort of error message anyway :)

[16:31] <masak> yes, but not this:

[16:31] <masak> rakudo: sub if() { '2' }; say if;

[16:31] <p6eval> rakudo ab2322: OUTPUT«␤»

[16:31] <diakopter> std: say but but but

[16:31] <p6eval> std 30591: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'but' used at line 1,1,1␤Check failed␤FAILED 00:01 110m␤»

[16:31] <diakopter> heh;  1,1,1

[16:35] *** justatheory joined
[16:36] <masak> rakudo: subset Foo where Whatever; say 1 ~~ Foo

[16:36] <p6eval> rakudo ab2322: OUTPUT«0␤»

[16:37] <masak> moritz_: good call on the 'Ordering' commit... but I don't see how 1 would smartmatch on Ordering in the first place. care to explain?

[16:38] <moritz_> masak: I'm not quite sure; I don#t understand Ordering well enough

[16:38] <moritz_> masak: I just observed the behaviour in Rakudo

[16:39] <moritz_> (which might get the Ordering wrong, though)

[16:39] <masak> it probably does, then.

[16:39] <masak> but as I said, I agree with the commit in general.

[16:39] <masak> even if Rakudo has Ordering wrong, the change will prevent other thinkos.

[16:39] <moritz_> even then I think it's less confusing than getting a type check error

[16:39] <moritz_> or a no multi to dispach to-error

[16:41] <masak> exactly.

[16:41] *** sundar joined
[16:43] * moritz_ tries to come up with a non-contrieved example for an only sub with a where-block constraint

[16:44] <masak> sub advance_monopoly_piece(Int $steps where * > 0) { ... }

[16:44] <TimToady> I don't think Ordering should be thought of as much of a constraint, since almost anything can smartmatch

[16:44] <TimToady> so I agree with making it named

[16:45] <masak> S29 thinks of Ordering as a constraint.

[16:45] <TimToady> no much of a

[16:45] <TimToady> *not

[16:45] * TimToady blames the high pollen count getting into his keyboard--yeah, that's the ticket

[16:46] * colomon is very confused by all this

[16:46] <TimToady> oh wait, I'm thinking of something else

[16:47] <masak> Matcher?

[16:47] <masak> also defined in S29, by the way.

[16:48] <moritz_> right, Matcher is basically Any | Mu

[16:48] <moritz_> erm

[16:48] <TimToady> yes, Matcher

[16:48] <moritz_> Any|Junction

[16:48] <TimToady> Mu where none(Bool)  :)

[16:48] <TimToady> so Ordering is more of a constraint, yes

[16:48] <colomon> seems like we need to be able to convert Ordering to a comparison sub.

[16:49] <colomon> else there will be loads of boilerplate duplication in min, max, etc

[16:51] <TimToady> if there is no intersection between the Ordering types and the types that do Orderable (or whatever role it is), then the argument for named becomes not so strong

[16:51] <moritz_> unless we want to make it optional

[16:52] <TimToady> that is, I kinda agree that 1 does not look like a valid ordering

[16:52] <colomon> afk

[16:52] <TimToady> yes, well, then we'll have fights over whether you should write min(1,2,3) or [min](1,2,3)  :)

[16:53] * moritz_ doesn't want to write that FAQ entry

[16:56] <masak> clearly we should all write [1,2,3].min

[16:57] <moritz_> .oO( clearly there should be less ways to do it )

[16:57] <moritz_> my proposal on p6l for removing the sub forms wasn't greeted very positively

[16:58] <masak> rawr!

[16:58] <moritz_> OTOH I should probably stop listen to them (or asking them in the first place )

[16:59] <moritz_> huh

[16:59] <moritz_> it seems we don't really talk about smart matching anywhere in the book

[16:59] <masak> p6l exists to convince you that your original proposal isn't so overboard after all :P

[16:59] <moritz_> speaking of overboard...

[17:00] <moritz_> anyone else agrees that the @by ordering seems  a bit excessive?

[17:01] <moritz_> and that having a type constraint on an Array parameter lowers the chances of a successful dispatch?

[17:01] <moritz_> rakudo: say 2.3 ~~ 0..*

[17:01] <p6eval> rakudo ab2322: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[17:01] <moritz_> alpha: say 2.3 ~~ 0..*

[17:01] <p6eval> alpha 30e0ed: OUTPUT«012␤»

[17:01] <moritz_> wow

[17:02] <moritz_> I guess 0..* shouldn't blindly whatever-curry

[17:03] <colomon> moritz_: I think the @by ordering is pretty cool.

[17:03] <colomon> though obviously the create user could easily generate his own version.

[17:06] <TimToady> hmm

[17:06] <TimToady> std: subset Ordering where Signature | KeyExtractor | Comparator | OrderingPair | Whatever | Positional[Ordering];

[17:06] <p6eval> std 30591: OUTPUT«ok 00:01 112m␤»

[17:06] <TimToady> recursive subset!

[17:06] <colomon> my mind was already blown by the possibility of | in subsets.

[17:07] <colomon> recursive might make my brains melt.

[17:07] <moritz_> anyway, I agree that we should have consistency in the interfaces of min, max, minmax and sort

[17:09] <dalek> book: f6d54a7 | moritz++ | src/subs-n-sigs.pod:

[17:09] <dalek> book: [subs] where-blocks on parameters

[17:09] <dalek> book: review: http://github.com/perl6/book/commit/f6d54a7b9dd3a56a95b2148557f1fb67abd06a1b

[17:10] * colomon feels like he is still groping for the right way to thing about Ordering...

[17:12] <colomon> there's one important different (IMO) between Ordering for sort and min/max/minmax

[17:13] <moritz_> btw I found a bug in List.classify

[17:13] <moritz_> it stringifies the Pair keys

[17:13] <colomon> moritz_: right, I assumed you knew that.  :)

[17:13] <moritz_> rakudo: say (1, 1.1, 2).classify( { .floor }).perl

[17:13] <p6eval> rakudo ab2322: OUTPUT«("2" => [2], "1" => [1, 11/10])␤»

[17:14] <TimToady> hmm, if the default with an unspecified ordering is to try a multi dispatch on, say, the first two items, and if we want to assume that the rest of the items use the same ordering, then we maybe want some way of capturing the ordering candidate that was actually found, depending on the dwim level

[17:14] <colomon> with sort, one prefers to get the one-arg form but can deal with getting a comparison operator

[17:14] <TimToady> is key stringification just a rakudo limitation?

[17:14] <moritz_> I know how it can be fixed, but it's costly and probably not worth the effort

[17:14] <colomon> with min/max/minmax, you pretty much always want a comparison function.

[17:14] <colomon> TimToady: hashes have to have Str keys at the moment.

[17:15] <moritz_> TimToady: rakudo stringifies hash keys, and List.classify uses hashs

[17:15] <moritz_> bug in Pairs there's no such restriction

[17:15] <moritz_> colomon: why would you pretty much always want a comparison function with min or max?

[17:15] <moritz_> colomon: most of my uses of List::Util qw(max) in Perl 5 are quire straight forward

[17:16] <TimToady> 99% of min/max will be straight numeric

[17:16] <TimToady> 99% of sort will be strings

[17:17] <colomon> moritz_: I'm talking internally, not from the user's point of view.

[17:17] <colomon> with sort, you want to do a Schwartzian transform if possible

[17:17] <colomon> if min/max, you want to do comparisons.

[17:18] <colomon> (hmmm... I think ... could be wrong about the last)

[17:18] <TimToady> well, depends on how structured your numbers are :)

[17:19] <TimToady> you might want the min mod some number, for instance

[17:20] <TimToady> or the number is really some kind of employee id that the middle n digits means something particular

[17:21] <TimToady> or the number is an index into an array that has the actual comparison values

[17:21] <TimToady> I think there's more potential overlap than you might think

[17:21] <TimToady> but as I say, that's in the 1%, not the 99%

[17:22] <TimToady> to me, the main question is whether the default should be forced, or dwimmy

[17:22] <TimToady> generally, we've been going for dwimmy

[17:22] <TimToady> on anything having to do with orderings

[17:23] <moritz_> so far I only had positive suprises with .sort :-)

[17:23] <TimToady> I'm sure we can arrange some negative ones for you if you'd like...

[17:24] <moritz_> :/

[17:27] <TimToady> there are an astounding number of places to draw the line on dwimminess, depending on how much of the input we examine to guess, and how specific/generic we make our guess.

[17:28] <TimToady> for instance, just the case of examining the first two arguments

[17:28] <TimToady> if they are both of type Int, do we use Int's notion of <=> or something more generic?

[17:28] <TimToady> what if we have 1 min 2.3

[17:29] <TimToady> the sweet spot seems to be switching between Numeric and Stringy, but not assuming much more than that

[17:29] <moritz_> I knd think that Perl 5 programmers expect comparsion between numbers and positional to coerce to Numeric

[17:29] <TimToady> and what do we do for 1 min "2"?

[17:30] <TimToady> vs sort 1,"2"...

[17:30] <TimToady> yes, my 99%s above leads me to think that people want a numeric bias some times, and a string bias other times

[17:30] <moritz_> so far rakudo coerces to Str in that case

[17:31] <TimToady> sort should bias towards strings if there's doubt, but we really need something sane if we get a random mixture

[17:31] <TimToady> with sort, at least we know we're supposed to be eager

[17:31] *** molaf joined
[17:32] <TimToady> so a solution that prescans the values is not out of the question

[17:32] <TimToady> but it could be at a cost

[17:33] <moritz_> I wonder if Str should have a .looks-like-number mehod

[17:33] <TimToady> one almost wants a call into an iterator that say "reify yourself eagerly and give me a type histogram"

[17:33] <moritz_> so that Numeric <=> Str could default to .Numeric coercion of .looks-like-number is true

[17:34] <TimToady> well, yes, we need that in there somewhere, as a refinement of typology dwimmery

[17:34] <TimToady> and we've done some tomfoolery with literals to make them pretend to be both numeric while remembering their original string

[17:35] <TimToady> so maybe there's some kind of kinda-coerce-to-num-if-you-can method

[17:35] <TimToady> that is the primitive underlying the currently specced behavior of literals like <1 2.3 foo>

[17:36] <TimToady> or <+1-2i> for that matter

[17:36] <TimToady> or <22/7>

[17:36] <moritz_> I'm still not sure if it's a good idea to inflict that magic on <...> by default

[17:37] <TimToady> but a kinda-coerce sounds more Schwartzian than just re-blessing

[17:37] <TimToady> I am

[17:37] <TimToady> too many people were expecting it

[17:37] <moritz_> is there a quoting attribute that controls that magic?

[17:37] *** sundar left
[17:37] <TimToady> good question

[17:38] <moritz_> like Q:m<...> where :m stadns for "type magic" or so

[17:38] <TimToady> probably worth defining one

[17:38] <moritz_> +1

[17:40] <TimToady> :n for numeric, :d for dwim are both available, it seems

[17:41] <TimToady> can't have :s for smart :)

[17:41] <moritz_> iirc <...> also dwims on colonpairs

[17:41] <moritz_> so :n would not be enough

[17:42] <TimToady> no, only «...» I thought...hmm...

[17:42] <moritz_> so :n for numeric, :p for pairs?

[17:42] <moritz_> :t for typemagic

[17:42] <TimToady> p is currently take for pathnames

[17:42] <TimToady> *taken

[17:43] <TimToady> qp[/etc/passwd]

[17:43] <moritz_> oh right

[17:43] <TimToady> it doesn't really have to be short, if it's the default

[17:43] <TimToady> hard thing that is possible, Q:!dwim<...>

[17:44] <TimToady> "don't do what I mean"  :)

[17:44] <TimToady> :D even

[17:44] *** BrowserUk joined
[17:45] <TimToady> :!DWIM :D

[17:45] <moritz_> as long as it's not default on Q :-)

[17:45] <TimToady> yes, well, it shouldn't be, nor on '' or ""

[17:46] <TimToady> just comes in with :w and :ww, I guess

[17:47] <TimToady> anyway, there's some primitive transformer there that should be available for deep magic

[17:47] <moritz_> and it should be available in method or sub form somehow

[17:47] <TimToady> so there's .looks-like-number(:make-it-so)  :)

[17:48] *** kaare joined
[17:48] <moritz_> :-)

[17:48] *** colomon left
[17:48] *** kaare is now known as Guest37229

[17:48] <TimToady> more like $x.mixin-numeric-type if $x.looks-like-number

[17:49] *** BrowserUk left
[17:50] <TimToady> or, possible, .Numeric just always does that, and leaves the old Str value available too

[17:50] <TimToady> memory usage possibly suffers, if the Str would otherwise be GC'd

[17:51] <TimToady> and it might not follow Least Surprise for some definitions of it

[17:51] *** Guest37229 left
[17:51] <TimToady> .Numbery  :)

[17:53] <moritz_> hugme: add szabgab to book

[17:53] * hugme hugs szabgab. Welcome to book!

[17:53] <szabgab> thanks

[17:59] <dalek> csmeta: r250 | diakopter++ | trunk/Sprixel/ (5 files):

[17:59] <dalek> csmeta: [perlesque] closures much closer. a couple loose ends to tie up.

[17:59] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=250

[17:59] <TimToady> maybe looks-like-number is just .dwim-number ~~ Numeric

[18:00] *** bakedb__ joined
[18:00] <TimToady> so maybe looks-like-number is really kinda useless, if you're going to figure it out again to do the coercion

[18:00] <moritz_> maybe the coercion should have a way to signaling that it was going wrong

[18:00] <TimToady> does anyone have a use case for knowing that something looks like a number without actually doing the coercion?

[18:00] <moritz_> other than returning 0

[18:01] <TimToady> that's also an idea

[18:01] <TimToady> lemme think about that...

[18:01] <TimToady> biab &

[18:02] <moritz_> maybe coercing "foo" to Numeric should really return a kind of soft fail that still behaves like 0 in numeric context

[18:03] <dalek> book: 9815dba | (Gabor Szabo)++ | README:

[18:03] <dalek> book: add PerlJam to README

[18:03] <dalek> book: review: http://github.com/perl6/book/commit/9815dbac75db3dab3cb90a79cb34e84a54745062

[18:03] <cognominal> $obj.<attr1 attr2> = < val1 val2 >  # is there a  hash-like syntax to manipulate many object attribtutes at once. Something like this pseudo-code?

[18:04] <moritz_> I'm not aware of such a feature

[18:05] * jnthn isn't either

[18:05] <moritz_> though if you want to use attributes like hash keys, you probably have a design problem

[18:05] <moritz_> just like "variable variable names"

[18:15] <cognominal> afk

[18:22] <TimToady> well, there $obj.$attrname if you need it, but you'd have to write your own loop

[18:23] <TimToady> rakudo: my $p = :foo<bar>; my $a = 'key'; say $p.$a

[18:23] <p6eval> rakudo ab2322: OUTPUT«invoke() not implemented in class 'Perl6Str'␤current instr.: '!dispatch_variable' pc 833 (src/glue/dispatch.pir:293)␤»

[18:23] <TimToady> alpha: my $p = :foo<bar>; my $a = 'key'; say $p.$a

[18:23] <p6eval> alpha 30e0ed: OUTPUT«invoke() not implemented in class 'Perl6Str'␤in Main (file <unknown>, line <unknown>)␤»

[18:23] <TimToady> pugs: my $p = :foo<bar>; my $a = 'key'; say $p.$a

[18:23] <p6eval> pugs: OUTPUT«foo␤»

[18:24] <TimToady> pugs++

[18:24] <moritz_> rakudo: my $p = :foo<bar>; my $a = 'key'; say $p."$a"

[18:24] <p6eval> rakudo ab2322: OUTPUT«Quoted method name requires parenthesized arguments at line 11, near ""␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[18:24] <moritz_> rakudo: my $p = :foo<bar>; my $a = 'key'; say $p."$a"()

[18:24] <p6eval> rakudo ab2322: OUTPUT«foo␤»

[18:24] <TimToady> ah, right

[18:24] <TimToady> pugs is before we make that hardref only

[18:25] <TimToady> rakudo++

[18:25] <TimToady> pugs: my $p = :foo<bar>; my $a = 'key'; say $p."$a"()

[18:25] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "\"$"␤    expecting ".", "\187", ">>", "=", "^", operator name, qualified identifier, variable name, "...", "--", "++", "i", array subscript, hash subscript or code subscript␤    at /tmp/ZDoyHkUrFM line 1, column 42␤»

[18:25] <TimToady> heh

[18:26] *** ash___ joined
[18:31] *** mssm joined
[18:32] <TimToady> perhaps Numeric keeps the string around as the "mix out" if it feels that it was incompletely converted, and turns the straight numeric if it thinks no information was lost, other than, say, whitespace

[18:32] <TimToady> s/turns/returns/

[18:32] <TimToady> what do you call the base of mixin, anyway?

[18:35] <TimToady> sorear: <sorear> What does my $var is Type(Args) mean?

[18:35] <TimToady> I don't think it means anything; that syntax is really for traits rather than types

[18:38] <TimToady> <sorear> hmm, LTM requires a metaclass compatibility engine

[18:39] <TimToady> it does?  did I write one by accident and not know it?

[18:40] <moritz_> not unheard of :-)

[18:40] <TimToady> hadn't heard of PEGs until a little while ago :)

[18:41] <TimToady> and now I are one, or something like that

[18:42] <TimToady> I'm sure that I've unknowingly violated and/or invalidated any number of patents over the years... :)

[18:43] <TimToady> maybe I should get a business patent on that...

[18:44] <moritz_> on unknowingly violating patents?

[18:44] <lue> ohai o/

[18:45] <lue> .oO(the USPTO needs to clean up its act, imo)

[18:45] <ash___> that sounds like a profitable business patent to me 

[18:45] <moritz_> especially since it implies endless recursion

[18:46] <moritz_> if you violate a patent, you automatically violate this new patent

[18:46] <ash___> I like googling recursion 

[18:46] <moritz_> which in turn means you violate this patent agian

[18:47] <lue> We've probably violated a patent on the concept of patents by now :)

[18:47] *** aindilis joined
[18:48] <ash___> I now have very primitive array support in nq-nqp, so you can do @a := (1, 2, 3); for instance 

[18:49] <ash___> oh, and strings, and doubles work now 

[18:49] <lue> \o/

[18:52] <moritz_> nqp: my @a := (1, 2, 3); @a[0] = 5; say(@a)

[18:52] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " 5; say(@a"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[18:52] <moritz_> nqp: my @a := (1, 2, 3); @a[0] := 5; say(@a)

[18:52] <p6eval> nqp: OUTPUT«3␤»

[18:52] *** jhuni joined
[18:52] <moritz_> nqp: my @a := (1, 2, 3); @a[0] := 5; say(|@a)

[18:52] <p6eval> nqp: OUTPUT«523␤»

[18:53] <moritz_> that#s actually two ways in which nqp is not a proper Perl 6 subset

[18:54] <ash___> also, because I am lazy, in my nq-nqp i made = the same as := (for now anyway. I always default to =) 

[18:54] *** nihiliad left
[18:55] <ash___> moritz_: do you mean that say(@a) does its length? not its values?

[18:55] *** nihiliad joined
[18:55] <ash___> and which other way? 

[18:56] <lue> why does = not work in nqp?

[18:58] <ash___> semantic meaning, that and implementing = is more difficult 

[18:59] <lue> .oO(that nqp code reminded me of my need for := in rakudo)

[18:59] <ash___> rakudo: my $a := 1; # still broke? 

[18:59] <p6eval> rakudo ab2322: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[18:59] <ash___> okay, not broke, but NYI

[19:02] *** tylerni7 left
[19:03] <dalek> csmeta: r251 | diakopter++ | trunk/Sprixel/src/ (2 files):

[19:03] <dalek> csmeta: [perlesque] still more progress.

[19:03] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=251

[19:03] <lue> for implementing :=, <naive>wouldn't you just have to get the location of the RHS and set the LHS to its location?</naive>

[19:04] *** colomon joined
[19:05] <moritz_> ash___: yes, and 2) is that binding a list to @a should make @a immutable

[19:05] <lue> I get the feeling though, if that's all it takes, it's not as easy as it sounds.

[19:05] <moritz_> that's binding, not assignment

[19:05] *** tylerni7 joined
[19:05] *** tylerni7 left
[19:05] *** tylerni7 joined
[19:06] <masak> lue: did you read my recent blog post about binding and assignment?

[19:07] <ash___> moritz_: ah, i see, makes sense

[19:07] *** k23z__ left
[19:07] <moritz_> also say(@foo) and say(|@foo) should be the same, since say() has a slurpy arg

[19:07] <ash___> I wonder if I could get away with making lists immutable, I wonder if mutable lists are used in the nqp grammar 

[19:08] <moritz_> rakudo: sub f(*@x) {say @x.join(',') }; my @a = (1, 2); f(@a); f(|@a)

[19:08] <p6eval> rakudo ab2322: OUTPUT«1,2␤1,2␤»

[19:08] <moritz_> ash___: under the hood it's all ResizablePMCArrays

[19:08] <lue> eh, no. where be your blog?

[19:08] <ash___> nqp: say(|(1, 2, 3)); say((1, 2, 3)); # it seems to flatten both of those, but @a doesn't get flattened 

[19:08] <p6eval> nqp: OUTPUT«123␤123␤»

[19:08] <moritz_> ash___: adding immutability would be another abstraction layer

[19:08] <masak> lue: http://use.perl.org/~masak/journal/40246

[19:08] *** fn left
[19:10] <moritz_> http://perlgeek.de/blog-en/perl-6/list-classify.writeback

[19:10] <moritz_> the last comment made me think

[19:10] <Su-Shee> moritz_: classify: group ip adresses by mask, domains by tld, any internet protocol containing headers ("all mail having x-foobar: blabla"), objects having attribute xy (?) 

[19:10] <moritz_> shouldn't it really return a hash?

[19:11] <moritz_> you could still do my :(@even, @odd) := |@list.classify(...)

[19:11] <moritz_> but I think all implementations will use a hash internally anyway

[19:11] <moritz_> so why not just return the hash?

[19:14] * lue reading masak's blog, be back in a bit.

[19:14] <ash___> moritz_: all implementations will use a hash internally where? 

[19:17] <colomon> ash___:  in classify

[19:17] <lue> good post. := seems more like something I need.

[19:17] <colomon> actually, most implementations will probably just crib moritz_++'s lovely version.  :) 

[19:19] <lue> ( I bet the Periodic Table of Operators is outdated by now :) )

[19:19] <colomon> lue: yup.

[19:20] <colomon> I really wish it would get updated so I could buy a nice copy to hang on my wall.

[19:20] <colomon> or as a t-shirt!

[19:20] <masak> lue: it is, a bit.

[19:20] <masak> lue: prefix:<=> is in there, for example.

[19:21] <colomon> It predates the Z metaop

[19:21] <colomon> etc.

[19:23] <lue> I'd like to see it updated too. I'd consider updating it, but I know almost 0 about all the operators that exist :)

[19:24] <masak> the original author has recently expressed interest in doing another update.

[19:25] <lue> \o/ I'd like to have one as a 1024x768 wallpaper (yeah right)

[19:25] *** jaldhar_ left
[19:28] <ash___> I wonder what it would take to get perl6 on the jvm.... or is that a good choice for a platform? 

[19:28] <masak> the thought has occurred to people.

[19:29] <moritz_> diakopter++ has done much research on backend platforms

[19:29] <masak> doing some large-ish percentage would probably be reasonably possible. :)

[19:29] <moritz_> I'm sure he has a more informed opinion than me

[19:30] <diakopter> not about the jvm, but I imagine it would end up looking similar to what I've built on the clr

[19:31] <ash___> I know of other languages on the jvm that have multi-methods (like clojure) but I don't know of any with dynamic grammars, or of any other languages at all that have dynamic grammars... 

[19:31] <diakopter> cue jonrafkind 's paper link

[19:32] <moritz_> are ranges purely numeric?

[19:32] *** jaldhar_ joined
[19:32] <ash___> rakudo: say 'a' .. 'd' # ? does that count as numeric? 

[19:32] <p6eval> rakudo ab2322: OUTPUT«abcd␤»

[19:33] <diakopter> perlesque: my $a = sub (int $b --> Callable[:(int --> int)]) { say($b); return sub (int $c --> int) { say('$b: ' ~ $b); say('$c: ' ~ $c); return ($c * $b) } }; my $d = $a(5); my $e = $a(7); say($d(3)); say($e(11));

[19:33] <p6eval> perlesque: OUTPUT«5␤7␤$b: -1412522840␤$c: 3␤57398776␤$b: -1412522912␤$c: 11␤1642117152␤»

[19:33] <ash___> although that might be doing the character code of 'a', and incrementing till it gets to the character code for 'd' and then converting to strings... 

[19:33] <ash___> rakudo: say 'a' .. 'Z' 

[19:33] <p6eval> rakudo ab2322: OUTPUT«␤»

[19:33] <diakopter> Hah.  it works, kinda.  there's some kind of value-type unboxing failure in the code generation, so you're seeing the memory address of the arg $b

[19:34] <ash___> hmm

[19:34] <colomon> rakudo: say 'a' ... 'Z'

[19:34] <p6eval> rakudo ab2322: OUTPUT«Decrement out of range␤current instr.: 'perl6;Perl6Exception;throw' pc 15354 (src/builtins/Associative.pir:46)␤»

[19:34] <diakopter> but it works, generically.

[19:34] <ash___> std: say 'a'..'z' 

[19:34] <p6eval> std 30591: OUTPUT«ok 00:01 112m␤»

[19:34] <colomon> interesting....

[19:34] <ash___> std: 'a'..'Z'

[19:34] <p6eval> std 30591: OUTPUT«ok 00:01 110m␤»

[19:34] <moritz_> rakudo: say 'a'..'z'

[19:34] <p6eval> rakudo ab2322: OUTPUT«abcdefghijklmnopqrstuvwxyz␤»

[19:34] <moritz_> rakudo: say 'a'...'z'

[19:34] <diakopter> pmurias: around?

[19:34] <colomon> ash___:  I'm 99% certain STD doesn't check the end values of ranges.

[19:34] <p6eval> rakudo ab2322:

[19:34] <p6eval> ..OUTPUT«abcdefghijklmnopqrstuvwxyzaaabacadaeafagahaiajakalamanaoapaqarasatauavawaxayazbabbbcbdbebfbgbhbibjbkblbmbnbobpbqbrbsbtbubvbwbxbybzcacbcccdcecfcgchcicjckclcmcncocpcqcrcsctcucvcwcxcyczdadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzeaebecedeeefegeheiejekelemeneoepeqereseteuevewex…

[19:35] <moritz_> bug

[19:35] <colomon> woah.

[19:35] <ash___> lol, that sure is a bug

[19:35] <colomon> thought that one worked.

[19:35] <colomon> Range is broken, but series is usually smarter.

[19:35] * moritz_ submits rakudobug

[19:35] <ash___> rakudo: say 1...10; say 'az' ... 'd';

[19:35] <p6eval> rakudo ab2322: OUTPUT«12345678910␤azbabbbcbdbebfbgbhbibjbkblbmbnbobpbqbrbsbtbubvbwbxbybzcacbcccdcecfcgchcicjckclcmcncocpcqcrcsctcucvcwcxcycz␤»

[19:35] <colomon> rakudo: say 'a', 'b' ... 'z'

[19:35] <diakopter> rakudo: say 'aa'...'z'

[19:35] <moritz_> huh? range semed to work, for low case to lower case

[19:35] <p6eval> rakudo ab2322: OUTPUT«abcdefghijklmnopqrstuvwxyz␤»

[19:35] <p6eval> rakudo ab2322:

[19:35] <p6eval> ..OUTPUT«aaabacadaeafagahaiajakalamanaoapaqarasatauavawaxayazbabbbcbdbebfbgbhbibjbkblbmbnbobpbqbrbsbtbubvbwbxbybzcacbcccdcecfcgchcicjckclcmcncocpcqcrcsctcucvcwcxcyczdadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzeaebecedeeefegeheiejekelemeneoepeqereseteuevewexeyezfafbfcfdfefffgfhfifjfk…

[19:36] <lue> I'd still like range to go over all of unicode (that's best left to a module probably)

[19:36] <diakopter> rakudo: say 'aa'...'a'

[19:36] <p6eval> rakudo ab2322: OUTPUT«Decrement out of range␤current instr.: 'perl6;Perl6Exception;throw' pc 15354 (src/builtins/Associative.pir:46)␤»

[19:36] <lue> rakudo: say 'ø'..'Ø'

[19:36] <p6eval> rakudo ab2322: OUTPUT«␤»

[19:36] <colomon> moritz_: unless someone's fixed it, Range is badly broken in general for string ranges.

[19:36] <colomon> rakudo: say 'a', 'b' ... 'z'

[19:36] <p6eval> rakudo ab2322: OUTPUT«abcdefghijklmnopqrstuvwxyz␤»

[19:36] <colomon> heh, if that works, the series fix might be the easiest thing ever.

[19:36] <moritz_> rakudo: say 'a' .. 'd'

[19:36] <p6eval> rakudo ab2322: OUTPUT«abcd␤»

[19:37] *** jaldhar_ left
[19:37] <TimToady> we talked about making single chars a special case that is exempt from "carry"

[19:37] *** envi^home left
[19:38] <TimToady> that is, you don't get carry unless the endpoint is at least 2 chars

[19:38] <masak> TimToady: are you blocking on something other than time/tuits for emit_p5 in viv?

[19:38] <TimToady> no, just tuits

[19:38] *** kensanata joined
[19:38] <lue> rakudo: say '¡'..'¢' # just testing

[19:38] <TimToady> it's really just reporducing the hierarchical parts of gimme5

[19:38] <p6eval> rakudo ab2322:  ( no output )

[19:39] <TimToady> the un6() parts are already mostly there

[19:39] * masak is thinking about having a look at it at some point

[19:39] <TimToady> reporduction is overrated

[19:39] <moritz_> .oO( after tardis, the book and gsoc? ;-)

[19:39] *** nihiliad left
[19:39] <masak> moritz_: something like that :)

[19:39] <diakopter> (if masak were to put time into that, diakopter's efforts would be assisted)

[19:40] <moritz_> speaking of the book, I've sent a patch for Pod::PseudoPod::LaTeX to chromatic

[19:40] <masak> diakopter: what makes you interested in emit_p5?

[19:40] <diakopter> b/c I want to make a version of it that emit_perlesque

[19:40] <moritz_> that makes the =begin screen...=end screen sections appear in the latex output

[19:45] <diakopter> emit_perlesque ho

[19:46] * masak ponders the ramifications of successfully teaching the #perl6 community to tell him that he doesn't have time to branch out to new projects :)

[19:47] <diakopter> masak: focus

[19:47] <masak> wise words.

[19:48] <diakopter> synopses: focus

[19:48] <masak> :P

[19:48] <diakopter> synopses: become synoptic

[19:49] <masak> the reason I'm looking in viv right now is that I'm copying parts of it for sigmund. the reason I'm spending time on sigmund is that I need a bit of non-vapor for my talk in Moscow in a week and a bit. :)

[19:50] <moritz_> masak: have you submitted a title for your talk yet?

[19:50] <masak> yes.

[19:50] <moritz_> so, what is it?

[19:50] <masak> I'll nopaste it and the abstract.

[19:50] <masak> please hold.

[19:52] <masak> http://gist.github.com/394738

[19:53] <moritz_> nice :-)

[19:53] <moritz_> so how time-travely is tardis these days?

[19:53] <masak> it totally does the time travel part.

[19:54] <masak> right now it seems to have a bit of trouble with blocks.

[19:54] <masak> but we'll fix that soon.

[19:54] <masak> I really like how it fell out that Tardis::Debugger subclasses Yapsi::Runtime and just adds a method to collect variable data along the way. :)

[19:55] <ash___> moritz_: where do I email  the perl cla to? Or do i have to snail mail it? 

[19:55] *** Heame joined
[19:55] *** finanalyst left
[19:56] <masak> ash___: you have to snail mail it.

[19:56] <colomon> I believe it's the Michigan address.

[19:56] <ash___> ah, got ya

[19:56] <ash___> they should setup an email address like parrot :P 

[19:57] <colomon> (The first address I found on the web was wrong, and the CLA got bounced back to by the post office.)

[19:58] *** Su-Shee left
[19:58] <Heame> Hi all. Is Damian Conway still a part of the perl6 thing?

[19:59] <moritz_> more or less, yes

[19:59] <moritz_> we don't see much of him in here

[19:59] <Heame> is he ever around here?

[19:59] <Heame> :)

[20:00] <TimToady> he doesn't do irc

[20:00] <moritz_> but he's still active, discusses with larry, occasionally gives talks etc

[20:00] <Heame> Ta.

[20:00] *** Heame left
[20:00] *** colomon left
[20:00] <lue> I wonder. I always here of another, more popular #perl6 channel. Haven't seen it yet.

[20:01] <masak> lue: if you find it, let us know.

[20:01] <TimToady> lue: are you often subject to hallucinations?

[20:01] <lue> no! :) But I was told that a while ago.

[20:01] <TimToady> then maybe you need a better BS detector :)

[20:02] <lue> guess that's another circuit broken in this TARDIS :/

[20:03] <lue> I'm curious; why does Damian not do irc?

[20:03] <TimToady> there isn't anyone around here we can't psychoanalyze into negative self-esteem :)

[20:04] <TimToady> he doesn't have ADD

[20:04] <lue> there are a couple atoms in the corner waiting to recieve more electrons :)

[20:04] *** colomon joined
[20:06] <pmurias> diakopter: pong

[20:10] <lue> perl6: my @a=2,3; @a[1] := @a[0]; @a[1]=5; say @a[0];

[20:10] <p6eval> elf 30591: OUTPUT«2␤»

[20:10] <p6eval> ..pugs: OUTPUT«5␤»

[20:10] <p6eval> ..rakudo ab2322: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[20:11] <lue> ooh! pugs gets it right.

[20:11] *** molaf left
[20:12] <moritz_> alpha: my @a=2,3; @a[1] := @a[0]; @a[1]=5; say @a[0];

[20:12] <p6eval> alpha 30e0ed: OUTPUT«rtype not set␤in Main (file <unknown>, line <unknown>)␤»

[20:13] <lue> it seems like wouldn't be that difficult to implement, but I hardly know anything about rakudo's guts :)

[20:15] <lue> rakudo: my $a = 3; my $b = 2; $b.WHERE = $a.WHERE; say $b # hmm... (probably read-only value :/)

[20:15] <p6eval> rakudo ab2322: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[20:16] *** meppl left
[20:19] <pugssvn> r30592 | pmurias++ | [mildew] update to current perlesque 

[20:20] <sorear> jnthn!!!

[20:20] *** jhuni left
[20:20] <sorear> I fixed that bug already, in a different way, as part of my changes to make lexicals work in the REPL

[20:20] <sorear> (Do I need a CLA to get patches reviewed now too? :()

[20:21] *** lue left
[20:21] <masak> definitely not.

[20:21] <masak> are you saying you've got variables working in the REPL?

[20:21] <moritz_> sorear: jnthn is on vacation, more or less, so you need to be patient a bit :-)

[20:23] <diakopter> refactoring generated code is easier than refactoring handwritten code.

[20:23] *** lue joined
[20:24] <lue> who doesn't love their G3 Pismo laptop shutting down randomly? I do!

[20:25] <sorear> TimToady: In very broad terms, metaclass compatibility is that, if Foo is a subclass of Bar, Foo.HOW does all of the roles thar Bar.HOW does

[20:25] <sorear> TimToady: any subclass of Cursor needs to regenerate LTM tables at compose time

[20:26] <sorear> TimToady: that means, that any subclass of Cursor needs to be built with a metaclass that does GrammarHOW's roles

[20:26] <sorear> TimToady: STD can get away with it because gimme5's metamodel is built for a grammar; Rakudo will need something much more general or much uglier.  I'd prefer the former ;)

[20:27] *** mssm left
[20:28] <sorear> masak: yes.

[20:28] <masak> sorear++!

[20:29] <lue> yes to what?!

[20:29] <masak> lue: working variables in the REPL.

[20:29] <masak> apparently, sorear didn't think macros were awesome enough for one week. :P

[20:30] <lue> :(                        )

[20:30] <lue> (jawdrop)

[20:30] <sorear> getting prototype macros was much easier than I thought

[20:30] <sorear> but there are lots of dark corners that need to be explored, so production-quality macros are as hard as ever

[20:31] <masak> still; prototype macros are infinitely more awesome than nothing.

[20:39] <sorear> masak: There are some interesting leads still in topic/lexical-persistence.  Essentially, it turns out that the machinery needed to persist lexicals in the REPL is exactly the same as the machinery required to compile the setting in multiple translation units (less memory, more parallelism, win all around)

[20:40] <sorear> however, our current !UNIT_START machinery requires either having a complete setting or no setting

[20:40] <masak> huh.

[20:40] <sorear> due to initializing %*ENV and @*ARGS

[20:40] <masak> I see.

[20:40] <sorear> which makes compiling half of the setting impossible

[20:42] * moritz_ doesn't understand

[20:43] <moritz_> most of the setting doesn't need %*ENV or @*ARGS

[20:43] *** justatheory left
[20:43] *** [Coke] joined
[20:44] *** am0c joined
[20:44] <sorear> moritz_: no, but the code which resumes lexical scopes does

[20:44] <sorear> because the code which resumes lexical scopes is also responsible for capturing arguments from parrotland

[20:45] <sorear> it does the main(@argv) vs. main (@*ARGS) impedence match

[20:46] <moritz_> and can't that be factored out?

[20:46] <sorear> perhaps, but I'm not sure of the best way

[20:47] <sorear> I suppose I could just experment :)

[20:48] <moritz_> I mean, discouple the lexical scope resuming from setting up these variables

[20:49] <sorear> When should the variables be set up?

[20:49] <moritz_> in a separate PIR sub?

[20:49] <sorear> When should that sub be called?

[20:49] <sorear> At the start of any module which does not claim to be part of the setting?

[20:50] <moritz_> !set_up_process_variables  or so

[20:52] <sorear> Is that supposed to be the name of the sub?

[20:52] <moritz_> yes

[20:53] <moritz_> or is it written in Perl 6?

[20:53] <moritz_> by convention the internal PIR subs start with a !

[20:54] *** fn joined
[20:55] <sorear> well, the problem is that Parrot doesn't make args available anywhere except the :main sub of the packfile being loaded

[20:55] <sorear> so we need to put something there to capture the arguments

[20:55] <sorear> however, if we put "something there to capture the arguments" in the setting, and the Hash class hasn't been defined yet - bang

[20:56] <moritz_> unless you introduce a second step

[20:56] <masak> what do the '.' nodes represent in the YAML output from viv?

[20:56] <sorear> Do elaborate.

[20:56] <moritz_> where you store it an parrot hash

[20:56] <moritz_> somehwere in a private, global variable

[20:56] <sorear> And only set up the contextuals in a late setting INIT block?

[20:57] <moritz_> yeah, something like that

[20:57] <sorear> I like it.

[20:57] <sorear> I'll try that nextg.

[21:00] *** kensanata left
[21:00] *** orafu left
[21:01] *** orafu joined
[21:03] *** iblechbot left
[21:06] * sorear goes into the rakudo makefile and adds 'time' to all the command variables.  I wonder if this should be automable?

[21:07] <moritz_> sure, the makefile is generated

[21:07] <sorear> "can be"

[21:07] <sorear> "can be", absolutely

[21:07] <sorear> it's just something I've done enough times that I wonder if there ought to be a Configure.pl stage for it

[21:09] <diakopter> pmurias: Triumph! :D

[21:10] <diakopter> perlesque: my $a = sub (int $b --> Callable[:(int --> int)]) { say($b); return sub (int $c --> int) { say('$b: ' ~ $b); say('$c: ' ~ $c); return ($c * $b) } }; my $d = $a(5); my $e = $a(7); say($d(3)); say($e(11));

[21:10] <moritz_> sorear: trying a simple patch to Configure.pl ... but need to rebuild parrot first

[21:10] <p6eval> perlesque: OUTPUT«5␤7␤$b: 5␤$c: 3␤15␤$b: 7␤$c: 11␤77␤»

[21:10] <diakopter> perlesquel: .

[21:10] <p6eval> perlesquel: OUTPUT«5␤7␤$b: 5␤$c: 3␤15␤$b: 7␤$c: 11␤77␤real 0.05␤user 0.05␤sys 0.00␤»

[21:11] <diakopter> masak: ^^ that's the test you were trying on rakudo earlier

[21:11] <dalek> csmeta: r252 | diakopter++ | trunk/Sprixel/ (6 files):

[21:11] <dalek> csmeta: [perlesque] strongly typed closures with Perl 6 declaration syntax.

[21:11] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=252

[21:12] <moritz_> diakopter: now go and port the man-or-boy test to perlesque

[21:12] <masak> diakopter: groovy.

[21:12] <diakopter> where's man-or-boy

[21:12] <moritz_> t/spec/integration/man-or-boy.t

[21:12] <masak> is there anything more to man-or-boy than just getting cloning of closures right?

[21:13] <moritz_> just needs closures, conditionals and arithmetics

[21:13] <diakopter> hm

[21:13] <diakopter> I think I'd better look at that wikipedia article instead of porting from the Perl 6

[21:14] * diakopter finds salvation in the C# example on rosettacode

[21:15] <moritz_> sorear: first approximation: 

[21:15] <moritz_> $maketext =~ s{(?<!\\\n)^\t(?!\s*-?cd)}{\ttime }mg;

[21:15] <moritz_> in Configure.pl

[21:16] <diakopter> I mean, er, the JavaScript example

[21:26] * diakopter finished porting

[21:26] <moritz_> sorear: pushed Configure patch

[21:27] <sorear> oooh

[21:27] <diakopter> http://perl6.pastebin.com/NiUF985w

[21:27] <diakopter> creating a test file for it

[21:27] <moritz_> $maketext =~ s{(?<!\\\n)^\t(?!\s*-?cd)(?=[^\n]*\S)}{\ttime }mg;

[21:27] <sorear> hmm, building latest rakudo on latest parrot took 19 minutes real, an increase of 8 minutes from last time

[21:27] <sorear> real time, however, fell by 1 minute

[21:28] <moritz_> huh.

[21:28] <moritz_> I thought that string caching thing should have sped up pbc_to_exe quite a bit

[21:28] <sorear> so someone seems to have made a time/memory "trade"off that affects core.pir generation

[21:28] <sorear> it does

[21:28] <sorear> pbc_to_exe and parrot -o perl6.pbc are mere blips now

[21:28] <sorear> core.pir generation, however, is getting slower (again)

[21:29] <sorear> it's swap bound for me

[21:29] <dalek> rakudo: 7247277 | moritz++ | Configure.pl:

[21:29] <dalek> rakudo: [Configure] experimental timing option for Makefile

[21:29] <dalek> rakudo: Inspired by sorear++

[21:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/724727756b4f1f751f39961055b4adc3731430aa

[21:29] <sorear> before immutable strings and the COW fixes went in, core.pir generation was taking ~12 hours; I can't complain about the current state of affairs at all :)

[21:31] * diakopter feels stupid

[21:32] <lue> diakopter: why?

[21:32] *** fn left
[21:32] *** fn joined
[21:32] <diakopter> cuz I inverted the typenames and varnames in the A function when porting :D

[21:33] *** fn left
[21:34] *** \shade\ joined
[21:35] <lue> ooh.

[21:40] *** rv2733 left
[21:45] <diakopter> man_or_boy found a couple bugs so far

[21:45] <diakopter> :)

[21:46] <moritz_> you know, the first bug it found in Rakudo was a regression in "is copy" :-)

[21:46] <moritz_> I only ported it Perl 6 when rakudo's lexical implementation was pretty good

[21:46] <arnsholt> I suppose there's a reason it's called man or boy test ^^

[21:47] <moritz_> :-)

[21:47] <lue> what is man_or_boy? Is it like initiation for Rakudo?

[21:48] <arnsholt> lue: http://en.wikipedia.org/wiki/Man_or_boy_test

[21:48] <arnsholt> It's originally from ALGOL

[21:49] <masak> I now have a small p5 script that uses viv output to tell me when a sub references 'self' or uses OO twigils, or when a method doesn't.

[21:51] <ash___> moritz_: is there a man or boy test for nqp? 

[21:55] <masak> good night, #perl6.

[21:55] *** masak left
[21:57] *** thowe left
[21:58] <lue> night masak

[22:01] <sorear> man or boy is a torture test for lexical closures and call-by-expression

[22:01] *** ethel joined
[22:04] <lue> afk

[22:08] *** chitragupt_ joined
[22:08] *** chitragupt_ left
[22:10] <sorear> jnthn: How does $rolemaker work in your newest patch?

[22:14] *** kaare joined
[22:15] *** kaare is now known as Guest72415

[22:17] *** Guest72415 left
[22:17] *** chitragupt_ joined
[22:18] *** chitragupt left
[22:18] *** dual left
[22:19] *** chitragupt_ left
[22:19] *** chitragupt joined
[22:21] *** pmurias left
[22:22] *** dual joined
[22:24] <diakopter> moritz_: whee

[22:25] <diakopter> (man_or_boy.t works correctly now)

[22:25] *** chitragupt_ joined
[22:25] <dalek> csmeta: r253 | diakopter++ | trunk/Sprixel/ (6 files):

[22:25] <dalek> csmeta: [perlesque] fix bugs exposed by man_or_boy.t

[22:25] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=253

[22:25] <dalek> csmeta: r254 | diakopter++ | trunk/Sprixel/Main.cs:

[22:25] <dalek> csmeta: [perlesque] disable test debug mode

[22:25] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=254

[22:27] <diakopter> C:\Projects\CSMeta\Sprixel\bin\Debug>perlesque.exe ..\..\t\man_or_boy.t

[22:27] <diakopter> -67

[22:28] <arnsholt> Congrats

[22:28] <diakopter> thanks

[22:29] <diakopter> takes about a quarter second

[22:29] <diakopter> I'll time it on linux

[22:29] <diakopter> too bad the program is too long to enter into p6eval, I think

[22:31] *** chitragupt_ left
[22:34] <diakopter> sweet

[22:34] <diakopter> it does fit.

[22:34] <diakopter> perlesque: sub A(int $k,Callable[:(-->int)] $x1,Callable[:(-->int)] $x2,Callable[:(-->int)] $x3,Callable[:(-->int)] $x4,Callable[:(-->int)] $x5-->int) {my Callable[:(-->int)] $B;$B=sub (-->int) {$k-=1;return A($k,$B,$x1,$x2,$x3,$x4)};if $k<=0 {return ($x4()+$x5())};return $B()};sub K(int $n-->Callable[:(-->int)]) {return sub (-->int) {return $n}};say(A(10,K(1),K(-1),K(-1),K(1),K(0)))

[22:34] <p6eval> perlesque: OUTPUT«-67␤»

[22:34] <diakopter> perlesquel: .

[22:34] <p6eval> perlesquel: OUTPUT«-67␤real 0.05␤user 0.04␤sys 0.01␤»

[22:42] *** chitragupt_ joined
[22:42] *** chitragupt_ left
[22:43] *** TiMBuS joined
[22:45] *** arnsholt_ joined
[22:48] *** bakedb__ left
[22:49] *** [Coke]_ joined
[22:49] *** Gruber joined
[22:49] *** buu_ joined
[22:50] *** buu_ left
[22:50] *** yahooooo7 joined
[22:51] *** buu left
[22:53] *** wasy_ joined
[22:54] *** [Coke] left
[22:54] *** tylerni7 left
[22:54] *** s1n left
[22:54] *** yahooooo left
[22:54] *** buubot left
[22:54] *** jql left
[22:54] *** arnsholt left
[22:54] *** Dori10 left
[22:54] *** Grrrr left
[22:54] *** diakopter left
[22:54] *** wasy_ is now known as wasy

[22:54] <sorear> diakopter: not going to implement HM and shorten those ugly type sigs to nothing? :p

[22:56] *** jaldhar_ joined
[22:58] *** diakopter joined
[22:58] <diakopter> I musta been netsplit

[22:59] *** yahooooo7 left
[22:59] *** gbacon left
[22:59] *** bloonix left
[22:59] *** skangas left
[22:59] *** mdxi left
[22:59] *** kcwu left
[22:59] *** dhoss left
[22:59] *** pnu left
[22:59] *** moritz_ left
[23:00] *** yahooooo7 joined
[23:00] *** gbacon joined
[23:00] *** bloonix joined
[23:00] *** skangas joined
[23:00] *** mdxi joined
[23:00] *** kcwu joined
[23:00] *** dhoss joined
[23:00] *** pnu joined
[23:00] *** moritz_ joined
[23:00] *** card.freenode.net sets mode: +o moritz_

[23:00] *** yahooooo7 left
[23:00] *** gbacon left
[23:00] *** bloonix left
[23:00] *** skangas left
[23:00] *** mdxi left
[23:00] *** kcwu left
[23:00] *** dhoss left
[23:00] *** pnu left
[23:00] *** moritz_ left
[23:01] *** yahooooo7 joined
[23:01] *** gbacon joined
[23:01] *** bloonix joined
[23:01] *** skangas joined
[23:01] *** mdxi joined
[23:01] *** kcwu joined
[23:01] *** dhoss joined
[23:01] *** pnu joined
[23:01] *** moritz_ joined
[23:01] *** card.freenode.net sets mode: +o moritz_

[23:02] *** s1n joined
[23:06] <sorear> diakopter: not going to implement HM and shorten those ugly type sigs to nothing? :p

[23:07] <diakopter> well...

[23:07] <sorear> it would help you fit more code on the p6eval command

[23:07] <diakopter> heh

[23:08] *** ChanServ sets mode: +o diakopter

[23:08] <diakopter> afaik, Perl 6 specifies no type inference except at the entire-program level

[23:09] <sorear> Perl 6 specifies no type inference

[23:09] <sorear> "type inference" in a Perl 6 compiler is actually value inference, aka variable range analysis

[23:09] <sorear> a very standard optimization

[23:09] *** buubot joined
[23:10] <diakopter> I think I read somewhere in the Minor Prophets that they can be inferred in optimizations... yeah.

[23:10] <diakopter> it only really would help for things that are used only as native types anyway

[23:11] <sorear> diakopter: being able to eliminate the multi dispatch to !STORE in $a = $b is a huge win

[23:11] <diakopter> true.

[23:12] <diakopter> I'm not there yet. :)  I intentially don't remember more of the Perl 6 spec than I plan to implement in the next month or two.

[23:12] <diakopter> intentionally

[23:12] <sorear> Hmm.  Does anyone know offhand how much slower it is to compile N pbcs then run pbc_merge, over just concatenating the pir and running imcc once?

[23:13] <diakopter> rakudo: sub A(int $k,Callable[:(-->int)] $x1,Callable[:(-->int)] $x2,Callable[:(-->int)] $x3,Callable[:(-->int)] $x4,Callable[:(-->int)] $x5-->int) {my Callable[:(-->int)] $B;$B=sub (-->int) {$k-=1;return A($k,$B,$x1,$x2,$x3,$x4)};if $k<=0 {return ($x4()+$x5())};return $B()};sub K(int $n-->Callable[:(-->int)]) {return sub (-->int) {return $n}};say(A(16,K(1),K(-1),K(-1),K(1),K(0)))

[23:13] <p6eval> rakudo ab2322: OUTPUT«Invalid typename in parameter declaration at line 11, near " $k,Callab"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[23:13] <diakopter> perlesque: sub A(int $k,Callable[:(-->int)] $x1,Callable[:(-->int)] $x2,Callable[:(-->int)] $x3,Callable[:(-->int)] $x4,Callable[:(-->int)] $x5-->int) {my Callable[:(-->int)] $B;$B=sub (-->int) {$k-=1;return A($k,$B,$x1,$x2,$x3,$x4)};if $k<=0 {return ($x4()+$x5())};return $B()};sub K(int $n-->Callable[:(-->int)]) {return sub (-->int) {return $n}};say(A(15,K(1),K(-1),K(-1),K(1),K(0)))

[23:13] <p6eval> perlesque: OUTPUT«-3250␤»

[23:14] <diakopter> heh

[23:14] <diakopter> perlesque: sub A(int $k,Callable[:(-->int)] $x1,Callable[:(-->int)] $x2,Callable[:(-->int)] $x3,Callable[:(-->int)] $x4,Callable[:(-->int)] $x5-->int) {my Callable[:(-->int)] $B;$B=sub (-->int) {$k-=1;return A($k,$B,$x1,$x2,$x3,$x4)};if $k<=0 {return ($x4()+$x5())};return $B()};sub K(int $n-->Callable[:(-->int)]) {return sub (-->int) {return $n}};say(A(35,K(1),K(-1),K(-1),K(1),K(0)))

[23:14] <p6eval> perlesque: OUTPUT«␤Native stacktrace:␤␤    mono [0x48b560]␤    mono [0x41b0df]␤  /lib/libpthread.so.0 [0x2acb713dba80]␤    mono [0x5cc70d]␤  mono [0x5cc846]␤  /lib/libpthread.so.0 [0x2acb713dba80]␤    mono [0x5c1ebd]␤ mono [0x5c2cdc]␤ mono [0x5c2ffb]␤  mono [0x5c319b]␤  mono [0x5cb29c]␤ 

[23:14] <diakopter> tick tock

[23:14] <p6eval> ../lib/libpthread.so.0 [0x2acb7…

[23:14] <diakopter> sweet

[23:14] <sorear> did it crash?

[23:14] <diakopter> yeah

[23:15] <diakopter> (I changed the depth exponent from 10 to 35

[23:15] <diakopter> )

[23:15] <diakopter> oh, I guess it didn't crash

[23:16] <diakopter> it tried to use more memory than that perl resource limiter would let it

[23:16] <diakopter> that's a lot of activation records.

[23:17] <sorear> aren't they GCd?

[23:17] *** \shade\ left
[23:17] <diakopter> yeah but apparently man_or_boy creates a very large graph of them

[23:18] <diakopter> hm. 20 completes, but 25 doesn't

[23:18] <diakopter> 20 -> -175416

[23:18] <diakopter> 22 -> -865609

[23:19] <diakopter> oh look, they're there in that wikipedia table :)

[23:22] *** \shade\ joined
[23:23] <diakopter> the advantage of perlesque over just plain C# (on the CLR) is that the C# solutions will run out of stack space much much more quickly that perlesque's frame trampoline will run out of heap space.

[23:24] <diakopter> as chromatic wrote, I'm doomed to writing trampolines the rest of my life.

[23:24] <diakopter> apparently

[23:24] <sorear> where did he write this?

[23:24] * diakopter looks

[23:25] <diakopter> hm. some blog comment/reply

[23:25] <diakopter> on ... /me tries to remember

[23:26] <diakopter> oh I remember

[23:28] <diakopter> argh. maybe it wasn't he

[23:34] <diakopter> found it!

[23:35] <diakopter> (not written by chromatic)

[23:35] <diakopter> wait, yes it was. argh.

[23:35] <diakopter> http://www.perlmonks.org/?node_id=836442

[23:39] <diakopter> and another

[23:39] <diakopter> http://use.perl.org/comments.pl?cid=70351&sid=43716

[23:39] <diakopter> (not that I dispute what he wrote... in fact just the contrary)

[23:40] <diakopter> ok I've reached my 10 hour screen-time limit for the day; afk

