[00:00] <TimToady> rakudo: say (1...10).map(* * *).map(* * 10)

[00:00] <p6eval> rakudo e58b16: OUTPUT«20120300560900␤»

[00:00] <TimToady> rakudo: say ~(1...10).map(* * *).map(* * 10)

[00:00] <p6eval> rakudo e58b16: OUTPUT«20 120 300 560 900␤»

[00:01] <TimToady> that's also quite wrong

[00:01] <TimToady> oh, way

[00:01] <TimToady> *wait

[00:01] <TimToady> rakudo: say ~(1...10).map(* ** 2).map(* * 10)

[00:01] <p6eval> rakudo e58b16: OUTPUT«10 40 90 160 250 360 490 640 810 1000␤»

[00:02] <TimToady> no, it's fine, it's my brane is rwong

[00:02] *** bjarneh joined
[00:02] <jnthn> I think it's more a bug in the iterator impl

[00:02] <jnthn> Likely oversight/unchecked condition than anything fundemental.

[00:02] <jnthn> But too tired to trace it now

[00:03] *** eiro left
[00:03] <TimToady> rakudo: say (1 ... 10).grep({ $_ %% 2}).grep(*)

[00:03] <p6eval> rakudo e58b16:  ( no output )

[00:03] <TimToady> rakudo: say ~(1 ... 10).grep(*).grep(*)

[00:04] <p6eval> rakudo e58b16:  ( no output )

[00:04] <TimToady> rakudo: say ~(1 .. 10).grep(*).grep(*)

[00:04] <sorear> is my *$a := foo; the best way to get the head of a lazy list in P6?

[00:04] *** eiro joined
[00:04] <p6eval> rakudo e58b16:  ( no output )

[00:04] <TimToady> well, if you don't want the tail, maybe

[00:05] <TimToady> also, probably fails with too many args

[00:05] <sorear> I'm thinking about the correct equivalent code for if (my ($C) = $C->foo) { .. }

[00:06] <TimToady> that looks vaguely familar :)

[00:06] <TimToady> how 'bout foo[0]

[00:07] <TimToady> hmm, might be heavy

[00:07] <TimToady> well, my ($a) = foo  might just still work

[00:08] <TimToady> or possibly my ($a,*@) = foo will do

[00:09] <TimToady> since the my makes a sig in p6

[00:09] <jnthn> I hope you wanted a := :-)

[00:09] <jnthn> But yes, I think that'd work

[00:09] <jnthn> slurpies are lazy

[00:09] <TimToady> ((my $a),*) = foo to force nonsig

[00:09] <TimToady> though probably nyi

[00:10] <jnthn> my ($a,*@) = foo will parse it as a sig but then whine that it's too complex to be turned into a plain old list

[00:10] <TimToady> rakudo: say (my $a) = 1,2,3; say $a

[00:10] <p6eval> rakudo e58b16: OUTPUT«Any()␤»

[00:10] <jnthn> huh.

[00:10] <TimToady> thats...bogus

[00:10] <jnthn> That's very odd

[00:11] <TimToady> rakudo: my $a; say ($a) = 1,2,3; say $a

[00:11] <lue> only one say got interpreted, it seems.

[00:11] <p6eval> rakudo e58b16: OUTPUT«Any()␤»

[00:11] <TimToady> rakudo: my $a; ($a) = 1,2,3; say $a

[00:11] <lue> [timtoady's first try]

[00:11] <p6eval> rakudo e58b16: OUTPUT«1 2 3␤»

[00:11] <TimToady> rakudo: (my $a) = 1,2,3; say $a

[00:11] <p6eval> rakudo e58b16: OUTPUT«1 2 3␤»

[00:12] <TimToady> rakudo: ((my $a),*) = 1,2,3; say $a

[00:12] <p6eval> rakudo e58b16: OUTPUT«1␤»

[00:12] <TimToady> there you go

[00:12] <TimToady> rakudo: (my $a,*) = 1,2,3; say $a

[00:12] <p6eval> rakudo e58b16: OUTPUT«1␤»

[00:12] <sorear> TimToady: not planning to actually generate Perl 6 for input to Rakudo

[00:13] <sorear> instead I'm plotting niecza's regex compiler

[00:13] <TimToady> well, tmtowtdi

[00:16] <ingy> rakudo: class C { has $.v is rw }; my $o = C.new; $o.v = "a\nb\n"; my $s = $o.v; $s ~~ s/\n$//

[00:16] *** Guest48289 left
[00:16] *** ispeak_ joined
[00:16] <p6eval> rakudo e58b16:  ( no output )

[00:17] <ingy> rakudo: class C { has $.v is rw }; my $o = C.new; $o.v = "a\nb\n"; my $s = $o.v; $s ~~ s/\n$//; say $s;

[00:17] <p6eval> rakudo e58b16: OUTPUT«a␤b␤»

[00:18] <TimToady> try with $$ instead

[00:19] <TimToady> unless, of course, that's not what you want :)

[00:20] *** ispeak_ left
[00:20] <ingy> jnthn: have you seen: Null PMC access in find_method('new')

[00:20] <jnthn> Not for a long time.

[00:20] *** chitragupt left
[00:20] *** [Coke] left
[00:20] *** gfldex left
[00:20] *** LionMadeOfLions left
[00:20] *** rokoteko left
[00:20] *** cosimo left
[00:22] <ingy> jnthn: IIIII

[00:22] <ingy> sorry

[00:22] <TimToady> this is #perlIIIIII

[00:22] <ingy> jnthn: I get it on a $s ~~ /...//

[00:23] <ingy> TimToady: :P

[00:23] <sorear> Perl IX

[00:23] *** eiro left
[00:23] <TimToady> is that like Ice IX?

[00:24] <TimToady> turns the whole world into a Perl cube?

[00:24] *** frew joined
[00:25] *** [Coke] joined
[00:25] *** rokoteko joined
[00:26] <ingy> rakudo: my $s = *; $s ~~ s/...//; 

[00:26] <p6eval> rakudo e58b16:  ( no output )

[00:27] <ingy> rakudo: my $s = *; $s ~~ s/...//; say $s

[00:27] <p6eval> rakudo e58b16: OUTPUT«!whatever_dispatch_helper␤»

[00:27] <ingy> rakudo: my $s = *; say $s

[00:27] <p6eval> rakudo e58b16: OUTPUT«!whatever_dispatch_helper␤»

[00:27] <TimToady> DIHWIDT

[00:27] <ingy> rakudo: say *

[00:27] <p6eval> rakudo e58b16: OUTPUT«!whatever_dispatch_helper␤»

[00:27] *** chitragupt joined
[00:27] <jnthn> So it's doing *.Str which gets curried

[00:28] <TimToady> .Str isn't supposed to curry *

[00:28] <TimToady> .Stringy is

[00:28] <sorear> rakudo: say *.Str

[00:28] <p6eval> rakudo e58b16: OUTPUT«_block65␤»

[00:28] *** cognominal joined
[00:28] <TimToady> just as .Str isn't supposed to thread junctions

[00:29] * ingy is lost

[00:29] <TimToady> .Str is a low-level "turn this into a single string no matter what"

[00:29] *** Pravin joined
[00:30] *** Pravin left
[00:30] <TimToady> ~$x is the same as .Stringy, which says, 'do stringification', and can autothread over junctions

[00:30] *** cosimo joined
[00:30] <sorear> .Stringy turns an object into a Str, Buf, or Cat !?!?

[00:30] <TimToady> say (1|2).Str

[00:30] <TimToady> rakudo: say (1|2).Str

[00:30] <p6eval> rakudo e58b16: OUTPUT«any(1, 2)␤»

[00:30] <TimToady> rakudo: say ~(1|2)

[00:30] <p6eval> rakudo e58b16: OUTPUT«any(1, 2)␤»

[00:31] <TimToady> which is wrong

[00:31] *** mtnviewmark joined
[00:31] <TimToady> should say any("1","2")

[00:31] <TimToady> rakudo: say ~(1|2).Stringy

[00:31] <p6eval> rakudo e58b16: OUTPUT«Method 'Stringy' not found for invocant of class 'Int'␤  in main program body at line 1␤»

[00:32] <TimToady> rakudo: say (1|2) ~ ""

[00:32] <p6eval> rakudo e58b16: OUTPUT«any("1", "2")␤»

[00:32] <TimToady> liek that, only unary :)

[00:32] <TimToady> *ke

[00:32] <sorear> std: my $x is smiling;

[00:32] <p6eval> std 31610: OUTPUT«ok 00:01 111m␤»

[00:32] <sorear> rakudo: my $x is smiling;

[00:32] <TimToady> std doesn't check traits at all

[00:32] <p6eval> rakudo e58b16: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Routine $r, Any :default($default)!)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤:(Mu $type where ({ ... }), Any :rw($rw)!)␤:(Mu

[00:32] <p6eval> ..$type…

[00:33] *** mtnviewmark left
[00:33] <sorear> wait, how did rakudo even get that far

[00:33] <sorear> I thought 'my $x is smiling' did a name lookup on ::smiling

[00:33] <sorear> before calling any multis

[00:33] <TimToady> only to see if it's a known type

[00:34] <TimToady> if not, it must be a trait that is handled by a compile-time dispatch

[00:34] <sorear> what if it is a known type?

[00:34] <TimToady> then it's an "isa"

[00:35] <sorear> my $x is Foo => Foo is container type

[00:35] <sorear> my $x is cow => trait_mod:<is>($declarand, :cow)

[00:35] <sorear> ?

[00:35] <TimToady> or that, yes, on a non-class

[00:35] <TimToady> rakudo: my $x is Scalar of Int = 42; say $x

[00:35] <ingy> what's a more direct way to do subst besides ~~ s/// ?

[00:36] <p6eval> rakudo e58b16: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $child, Role $r)␤:(Routine $r, Any :default($default)!)␤:(Code $block, Any $arg?, Any :export($export)!)␤:(Mu $child, Mu $parent)␤:(Mu $type where ({ ... }), Any :rw($rw)!)␤:(Mu

[00:36] <p6eval> ..$type…

[00:36] <ingy> because the ~~ is screwed up

[00:36] <TimToady> rakudo: my @x is Array of Int = ^42; say ~@x

[00:36] <p6eval> rakudo e58b16: OUTPUT«Modifications to classes are not allowed after instantiation.␤  in 'trait_mod:<is>' at line 61:CORE.setting␤  in main program body at line 20:/tmp/lnm3f03urY␤»

[00:37] <TimToady> um

[00:37] <lue> don't quote me, but I think s/// is described in S05

[00:38] <TimToady> rakudo: my $x = 'abc'; $x.=substr(/b/,'r'); say $x

[00:38] <TimToady> rakudo: my $x = 'abc'; $x.=subst(/b/,'r'); say $x

[00:38] <p6eval> rakudo e58b16:  ( no output )

[00:38] <p6eval> rakudo e58b16: OUTPUT«arc␤»

[00:38] *** LionMadeOfLions joined
[00:38] <TimToady> rakudo: my $x = 'abc'; say $x.subst(/b/,'r');

[00:38] <p6eval> rakudo e58b16: OUTPUT«arc␤»

[00:38] <TimToady> that kind of more direct?

[00:40] <ingy> rakudo: my $x = 'abc'; $x.subst(/b/,'r'); say $rx

[00:40] <ingy> rakudo: my $x = 'abc'; $x.subst(/b/,'r'); say $x

[00:40] <p6eval> rakudo e58b16: OUTPUT«===SORRY!===␤Symbol '$rx' not predeclared in <anonymous> (/tmp/nGyLgWWCRw:20)␤»

[00:40] <p6eval> rakudo e58b16: OUTPUT«abc␤»

[00:40] <lue> .oO(~~ is smart match, so I guess it should deal with regex matches too. A pun in P6 is just waiting.)

[00:40] <ingy> rakudo: my $x = 'abc'; $x.=subst(/b/,'r'); say $x

[00:40] <p6eval> rakudo e58b16: OUTPUT«arc␤»

[00:40] <ingy> TimToady: yeah

[00:42] <ingy> Null PMC access in find_method('new') was caused by ~~s/// but .=subst() worked fine :(

[00:44] <lue> rakudo: my $a = Regex.new(<alpha>)

[00:44] <p6eval> rakudo e58b16: OUTPUT«too few positional arguments: 2 passed, 3 (or more) expected␤  in main program body at line 1␤»

[00:47] <lue> rakudo: my $a = /<alpha>/; say $a.WHAT

[00:47] <p6eval> rakudo e58b16: OUTPUT«Regex()␤»

[00:49] <lue> rakudo: my $a = /<alpha>+/; my $b = "!! smart" ~~ $a; say "$\ match"

[00:49] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Unsupported use of $\ variable; in Perl 6 please use the filehandle's :ors attribute at line 20, near " match\""␤»

[00:49] <lue> rakudo: my $a = /<alpha>+/; my $b = "!! smart" ~~ $a; say "$b match"

[00:49] <p6eval> rakudo 692aa1: OUTPUT«smart match␤»

[00:49] <TimToady> decommuting &

[00:51] <lue> .oO(the pun needs a little work, but at least it's out there.)

[00:54] *** jaldhar joined
[00:55] <ingy> is 'this' a p6 keyword?

[00:58] <lue> afk

[00:58] *** jaldhar left
[01:00] <sorear> ingy: yes, but it's spelled 'self'

[01:18] *** meppl left
[01:30] <ash_> rakudo: class Foo { has $.a; method bar { self.a } }; say Foo.new(:a(10)).bar;

[01:30] <p6eval> rakudo 692aa1: OUTPUT«10␤»

[02:09] <awwaiid> rakudo: class Foo { has $.a; method bar { .a } }; say

[02:09] <p6eval> rakudo 692aa1: OUTPUT«␤»

[02:10] <awwaiid> er

[02:10] <awwaiid> rakudo: class Foo { has $.a; method bar { .a } }; say Foo.new(:a(10)).bar;

[02:10] <p6eval> rakudo 692aa1:  ( no output )

[02:13] <ash_> rakudo: class Foo { has $.a; method bar { $!a } }; say Foo.new(:a(10)).bar;

[02:13] <p6eval> rakudo 692aa1: OUTPUT«10␤»

[02:15] <ash_> rakudo: class Foo { has $.a; method bar($this:) { $this.a } }; say Foo.new(:a(10)).bar; # if you want to use this instead of self...

[02:15] <p6eval> rakudo 692aa1: OUTPUT«10␤»

[02:15] *** gfx joined
[02:20] <lue> I'm guessing string encoding standards (Unicode, Shift-JIS, etc.) comes from Parrot?

[02:22] <TimToady> string encoding standards usually come from standards bodies

[02:24] <lue> It's availability comes from Parrot, I meant.  :)

[02:24] <lue> s/'//

[02:26] *** jaldhar joined
[02:30] <lue> or rather: Are my options for encoding methods in Rakudo limited by what's been implemented in Parrot?

[02:32] <TimToady> well...considering rakudo doesn't really do buffers yet, it's whatever you get as options on open

[02:33] *** snarkyboojum left
[02:35] *** stef__ joined
[02:36] <lue> one of masak's commits seems to suggest we don't have control over available encoding methods directly.

[02:36] <lue> [ I could be misinterpreting it though :) ]

[02:37] *** snarkyboojum joined
[02:38] *** stef_ left
[02:42] <sorear> lue: encodings are just algorithms, you can write your own

[02:42] * sorear is thinking classes need to be a special kind of sub

[02:45] <TimToady> why?

[02:49] *** ash_ left
[02:57] *** sftp left
[02:59] *** xinming left
[03:01] *** ash_ joined
[03:07] * lue is trying to find out how to write such an algorithm

[03:10] *** xinming joined
[03:13] *** xinming left
[03:16] <sorear> TimToady: because they have a lexical scope and are cloned

[03:23] *** ash_ left
[03:29] *** xinming joined
[03:57] *** xinming left
[03:59] *** xinming joined
[04:07] *** snarkyboojum left
[04:18] *** hercynium left
[04:35] *** ash_ joined
[04:35] *** bjarneh left
[04:38] *** justatheory left
[04:38] *** azert0x joined
[04:38] *** azert0x left
[04:41] *** azert0x joined
[04:41] *** azert0x left
[04:41] *** ash_ left
[04:53] <sorear> rakudo: my class A { say A.new; }

[04:53] <p6eval> rakudo 692aa1: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤  in main program body at line 1␤»

[04:53] <sorear> pugs my class A { say A.new; }

[04:53] <sorear> pugs: my class A { say A.new; }

[04:53] <p6eval> pugs: OUTPUT«<obj:A>␤»

[04:53] <sorear> elf: my class A { say A.new; }

[04:54] <p6eval> elf 31610: OUTPUT«syntax error at (eval 124) line 4, near "{ package A"␤BEGIN not safe after errors--compilation aborted at (eval 124) line 5.␤ at ./elf_h line 5881␤»

[04:54] <sorear> mildew: my class A { say A.new; }

[04:54] <p6eval> mildew: OUTPUT«Can't open perl script "mildew": No such file or directory␤»

[04:58] *** xinming left
[05:01] *** tylerni7 left
[05:03] *** envi^home joined
[05:08] *** tylerni7 joined
[05:09] *** tylerni7 left
[05:09] *** tylerni7 joined
[05:12] * lue is going insane trying to find one webpage about implementing an encoding standard

[05:15] *** tylerni8 joined
[05:16] *** tylerni7 left
[05:21] *** tylerni8 left
[05:21] *** tylerni7 joined
[05:21] *** tylerni7 left
[05:21] *** tylerni7 joined
[05:29] *** azert0x joined
[05:30] *** xinming joined
[05:31] *** ashleydev joined
[05:44] *** tylercurtis left
[05:47] *** PerlJam left
[05:48] *** PerlJam joined
[05:50] <sorear> lue: character encoding standards are completely insane

[05:50] <sorear> every country has ten of the stupid things

[05:50] <sorear> also, everybody hates encodings invented by foreigners

[05:50] <sorear> I will be amazed if Unicode catches on outside the US

[05:52] <sorear> here's one of the more awesome ones: http://www.unicode.org/reports/tr16/

[05:52] <sorear> (implemented natively in the Perl 5 core!)

[05:53] *** meppl joined
[05:57] <lue> I can't find one document on how to implement an encoding standard, that's what's making me loopy right now :)

[05:58] <lue> But I agree, way too many encoding standards O.o

[06:00] <sorear> what, exactly, are you having trouble with?

[06:00] <sorear> what encoding standard are you trying to implement?

[06:00] <sorear> I would assume you're trying to find the spec for an encoding stnadard

[06:01] *** cls_bsd joined
[06:02] <lue> well, I'm looking for general tips on implementing encoding standards (probably ISO-8859-1 first, to let some tests pass).

[06:03] <sorear> 1. find the definition of the encoding

[06:03] <sorear> 2. implement it

[06:03] <sorear> it really is that easy

[06:03] <sorear> find the person who implemented :=; this is 1000x easier

[06:03] * lue found himself

[06:04] <sorear> never can tell with those IRC people

[06:04] <sorear> they're often collective pseudonyms

[06:05] <lue> The idea I got is a low-level one, where I get the number and then manually pull the letter from a correctly encoded font :D

[06:06] <lue> If it's that easy, then I'll gladly give that idea up.

[06:07] <sorear> ok

[06:07] <sorear> a character encoding is an algorithm for mapping strings to byte sequences

[06:07] <sorear> are you following me

[06:08] <lue> yes.

[06:08] <sorear> most encodings (Baudot, SCSU and the ISO-2022 family are the main exceptions here) encode each character independantly

[06:09] <sorear> a becomes 61, « becomes C2 AB, «a« becomes C2 AB 61 C2 AB

[06:09] <sorear> in one well-known encoding

[06:09] <sorear> still follow

[06:10] <lue> yes.

[06:10] <lue> [I think the idea I got is the kind of idea you implement at the OS level]

[06:12] *** Guest38858 left
[06:12] *** Guest38858 joined
[06:12] *** Guest38858 is now known as pragma_

[06:14] <sorear> just out of curiousity, how old are you

[06:15] <lue> 15

[06:15] <lue> I know how character encoding works, what happened is I got an overcomplicated idea which made my life miserable.

[06:15] <sorear> hah.  I knew it

[06:16] *** constant left
[06:16] <lue> Now that I know that's overcomplicating things, my life is good again. thank you sorear.

[06:16] <sorear> back when I was 15 I, too, was obsessed with exactly this sort of thing

[06:17] *** constant joined
[06:17] *** constant left
[06:17] *** constant joined
[06:18] <sorear> (I think I still have a copy of that OS I wrote with a text editor, a shell, and a B compiler lying around somewhere.  Idiot me didn't understand B+ trees back then so the whole thing is nigh-unusably slow...)

[06:18] <sorear> so, for most encodings, you can encode characters one at a time

[06:18] <sorear> a string is a lot like a list of characters

[06:18] <sorear> rakudo: say "«a«".comb.perl

[06:18] <p6eval> rakudo 692aa1: OUTPUT«("«", "a", "«")␤»

[06:18] <sorear> you can unpack it into a real list with .comb

[06:19] <sorear> how about a really, really simple encoding: UTF-32BE

[06:20] <sorear> UTF-32BE is defined using Unicode

[06:20] <sorear> Unicode assigns numbers to characters, so it's already most of an encoding

[06:20] <sorear> but the numbers Unicode assigns go up to ~1 million, and normal character encodings are only allowed to use 0 - 255

[06:21] <sorear> UTF-32 uses base 256 arithmetic to represent each character in 4 "digits"

[06:22] <sorear> rakudo: sub char2utf32($ch) { my $unicode_index = ord($ch); (($ch div 16777216) mod 256), (($ch div 65536) mod 256), (($ch div 256) mod 256), (($ch div 256)) }; say "«a«".comb.map(&char2utf32).perl.say

[06:23] <p6eval> rakudo 692aa1:  ( no output )

[06:23] <sorear> rakudo: sub char2utf32($ch) { my $unicode_index = ord($ch); (($ch div 16777216) mod 256), (($ch div 65536) mod 256), (($ch div 256) mod 256), (($ch div 256)) }; say "«a«".comb.map(&char2utf32).perl

[06:23] <p6eval> rakudo 692aa1:  ( no output )

[06:23] <sorear> what gives, Rakudo

[06:23] <sorear> rakudo: sub char2utf32($ch) { my $unicode_index = ord($ch); return (($ch div 16777216) mod 256), (($ch div 65536) mod 256), (($ch div 256) mod 256), (($ch div 256)) }; say "«a«".comb.map(&char2utf32).perl

[06:23] <p6eval> rakudo 692aa1:  ( no output )

[06:26] <sorear> ok, rakudo appears to be broken

[06:27] <sorear> > sub char2utf32($ch) { my $u = ord($ch); return (($u div 16777216) mod 256), (($u div 65536) mod 256), (($u div 256) mod 256), (($u mod 256)) }; say "«a«".comb.map(&char2utf32).flat.perl

[06:27] <sorear> (0, 0, 0, 194, 0, 0, 0, 171, 0, 0, 0, 97, 0, 0, 0, 194, 0, 0, 0, 171)

[06:27] <sorear> much better

[06:27] <sorear> p6eval--

[06:28] <sorear> lue: still with me?

[06:28] <lue> yes.

[06:28] <sorear> do you understand what that code is doing?

[06:29] <lue> yes, it takes a character (I presume to utf8) and turns it into utf-32

[06:29] <lue> [I'll read up on the specifics of UTF-32]

[06:29] <sorear> I just explained UTF-32.

[06:29] <sorear> If you still need to "read up", then no, you're *not* following me and I need to explain something

[06:29] <sorear> What do I need to explain?

[06:30] *** xinming left
[06:30] *** cognominal left
[06:31] <lue> Sorry, I didn't mean it like that.

[06:32] *** stef__ left
[06:32] *** xinming joined
[06:32] <lue> [I actually don't know what I meant there; I incorrectly thought there was more magic to UTF-32]

[06:33] <sorear> Oh. Ok.

[06:33] <sorear> (I'm just doing a list of numbers because Rakudo doesn't support byte strings well yet.  masak++ for being in the middle of fixing this)

[06:34] <sorear> Another important family of encodings are the "SBCS" encodings, or Single-Byte Character Set

[06:34] <sorear> SBCS encodings, as their names imply, devote 1 and only 1 byte to each character

[06:34] <sorear> therefore, they can faithfully represent no more than 256 characters

[06:35] <lue> (ASCII and ANSI immediately come to mind, although ASCII is technically 7-bit)

[06:35] <sorear> all SBCS encodings predate Unicode, and SBCS encodings were the dominant family (outside of Asia, anyway) before recently

[06:35] <sorear> ANSI is not a protocol

[06:35] <sorear> er

[06:35] <sorear> ANSI is not a character set

[06:36] *** cognominal joined
[06:36] <sorear> ANSI is a byte-oriented interactive protocol for communicating with video terminals like the DEC VT-102

[06:37] <sorear> among other services, ANSI allows a character encoding to be negotiated, allowing text to be sent to the terminal

[06:37] <lue> Alright. (I must've misread something.)

[06:38] <sorear> ANSI also provides services for editing already sent text, changing font sizes, ejecting sheets of paper, making noises, reprogramming the terminal so that the space bar generates "rm -rf /\n", and many other things

[06:38] <sorear> to my knowledge, no complete implementation exists

[06:38] <sorear> note that ANSI is actually the name of a standards body

[06:38] <sorear> the standard most people are talking about has a much different name

[06:38] <sorear> as is common for standards, it is actually available from several different organizations

[06:39] <sorear> you can get a free copy at http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-048.pdf

[06:39] <sorear> this is the single most confusing document I have ever attempted to read

[06:40] <sorear> I've read disassembler output which made more sense

[06:40] <sorear> also, it's not just you

[06:40] <sorear> lots of people misunderstand what it is

[06:41] <sorear> end of tangent

[06:41] <sorear> ASCII is, yes, an example

[06:41] <sorear> it's the mother of most SBCSes, actually

[06:42] <sorear> most national SBCSes came about by importing US-ASCII computers and adding some other characters

[06:42] <sorear> most of them added characters in the 128-255 range that ASCII didn't use (because ASCII was designed for use as part of a 7-bit teleprinter line protocol)

[06:43] <sorear> not quite always, though

[06:43] <sorear> a lot of people replaced $ with their favorite currency symbol

[06:43] <pugssvn> r31611 | lwall++ | [spec] random cleanup of fossils from before proto became a multi wrapper 

[06:43] *** PZt left
[06:44] <sorear> the Finns replaced [ \ ] { | } with Ä Ö Ë ä ö ë

[06:44] <sorear> the Finnish code deserves special mention for two reasons.

[06:45] <sorear> One, all IRC servers nominally use it, and as such #moo[ and #moo{ are considered to be the same channel (because they're really #mooä and #mooÄ and it's case insensitive

[06:46] <sorear> Two, trigraphs were added to C to support them (and possibly other contries that did the same thing?)  if( array ??( index ??) ) ??< code here ??>

[06:46] <lue> That's interesting.

[06:47] <sorear> The Japanese (back before computers were powerful enough to support a kanji font) used an 8-bit code with the katakana sylabery in part of 128-255

[06:47] <sorear> but they also switched out \ for the yen sign for some reason

[06:48] <sorear> anyways, towards the end of the SBCS era, every country that used non-US-English letters had their own, incompatible, SBCS

[06:49] *** gfx left
[06:49] <lue> .oO(what joy international emails and the Internet in general must've been)

[06:49] <sorear> I should also mention EBCDIC, IBM's ASCII competitor, which was origenally intended to be a compatible extension of the old (pre-1900) punch card formats, but they managed to invent six versions of it that weren't even compatible with *each other*... luckily this is dead now

[06:49] <sorear> exactly

[06:50] <sorear> international e-mail is what about the end of this era

[06:50] <sorear> brought about

[06:51] <sorear> near the end, the ISO tried to improve the situation as much as they could while still using 8-bit codes

[06:52] <sorear> so they came up with a few encodings each of which served several countries, collectively known as ISO-8859

[06:52] *** LionMade0fLions joined
[06:52] <sorear> ISO-8859-1 was designed to serve England, France, Spain, the U.S, Germany

[06:52] <lue> (about 13 or 14 of them, if I recall)

[06:52] <TimToady> -1 became -15 when they added the euro

[06:53] <TimToady> but people still just call it latin-1

[06:53] <sorear> it has ASCII, «french quotes», áccentos, eñe, sharp s (ß), a few other things

[06:53] <TimToady> and that became the first 256 chars of Unicode

[06:54] <TimToady> .u ¬

[06:54] <phenny> U+00AC NOT SIGN (¬)

[06:54] <sorear> Unicode is not a character encoding.  It's a character *set*.  Unicode, for the first time, made it possible to talk about characters independant of any one encoding

[06:54] *** LionMadeOfLions left
[06:54] *** breinbaas joined
[06:55] <TimToady> but the codepoints have abstract numbers that just happen to match latin-1

[06:55] <sorear> after Unicode was invented (early 90s), changing text between encodings became a well-defined proposition

[06:55] <sorear> they match a lot of existing encodings

[06:55] <TimToady> as long as you believed in UCS-2

[06:55] <sorear> I think the general rule was "as little creativity as possible, match status quo whenever you can"

[06:56] <sorear> stuff like smilies are in Unicode mostly because a few of the SBCSes had them

[06:56] <TimToady> I know a bunch of CJK folks who would say a great deal too much creativity was used :)

[06:57] <TimToady> Zapf Dingbats and such

[06:57] <sorear> I know almost nothing about pre-Unicode CJK encodings, so I'm not talking about that aspect of the history

[06:57] <sorear> you're welcome to though

[06:57] <lue> what a wonderful history you're giving by the way, sorear.

[06:59] <sorear> this is the end of my tangent.

[06:59] <sorear> encodings used now in the West fall into two groups

[06:59] <sorear> the "legacy" SBCS encodings are now defined as a 1:1 map between Unicode character numbers and bytes

[07:00] <TimToady> non-linear for anything not ISO-8859-1ish

[07:01] <TimToady> and the UTFs

[07:01] <TimToady> which presume to represent any valid Unicode codepoint

[07:01] <TimToady> albeit by different schemes

[07:02] <lue> I can't help but wonder why Unicode stopped at such a seemingly arbitrary number, 0x10FFFF

[07:02] <TimToady> UTF-32 is a fixed-width scheme

[07:02] <sorear> that's the other group of encodings used now

[07:02] <TimToady> they figgered 16 planes were enough

[07:02] <sorear> the Unicode-based encodings

[07:03] <sorear> the Unicode-based encodings are defined as a simple mathematical translation of the codepoint numbers

[07:03] <TimToady> UTF-16 was original viewed as fixed width before they invented surrogates to represent chars above ffff

[07:03] <TimToady> but it's really variable width

[07:03] <TimToady> UTF-8 is anabashedly variable width

[07:03] <TimToady> *un

[07:03] <sorear> the simplest Unicode-based encoding is the one I showed you earlier - UTF32

[07:03] <moritz_> good morning

[07:03] <TimToady> o/

[07:03] <lue> good morning moritz_ o/

[07:04] <TimToady> UTF-32 is more or less equivalent to UCS-4

[07:04] <TimToady> and UCS-2 was equivalent to UTF-16 before they invented surrogates

[07:04] * lue can't wait to see what happens to Unicode when we discover sentient aliens as advanced as us... *muhahahaha*

[07:04] <TimToady> UCS-1, if it existed, would more or less be Latin-1

[07:05] <sorear> I think merging our character set standards will be the least of our worries when that happens

[07:05] <TimToady> mostly the western world is moving almost exclusively to UTF-8 for interchange of data

[07:06] <TimToady> in the east there tends to be a preference for UTF-16 because it is more compact for east asian characters

[07:07] <TimToady> (where they use Unicode at all; many continue to use Big-5 or ISO-2022 or whatever their original non-unicode character set was)

[07:08] <ingy> how do I subst "x/y/z" into "x/y"?

[07:08] <sorear> the common east asian characters in Unicode are assigned around 4000-8000, the rare ones are assigned above 10000

[07:08] <TimToady> see the perl5 encode module for much more on this subject

[07:09] <ingy> sorear: the bareword 'this' seemed to cause silent errors...

[07:09] <sorear> ingy: it's spelled self in perl6

[07:09] <sorear> TimToady: does an East Asian think of 一 as U+4E00 or as a codepoint in their native set?

[07:09] <sorear> (independant of how they encode it)

[07:10] <ingy> sorear: I know that. But I was using a $this.foo and forgot the $ and it got no compile or runtime errors

[07:10] <TimToady> they think of it as a character they learned in school, and don't much give a rip about the other :)

[07:10] <TimToady> std: this.foo

[07:10] <ingy> sorear: so I assumed 'this' meant something

[07:10] <p6eval> std 31611: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'this' used at line 1␤Check failed␤FAILED 00:01 110m␤»

[07:10] <TimToady> rakudo: this.foo

[07:10] <p6eval> rakudo 692aa1: OUTPUT«Could not find sub &this␤  in main program body at line 20:/tmp/Pdi9pnukUK␤»

[07:10] <ingy> *shrug*

[07:10] <ingy> IT HAPPENED!

[07:11] <ingy> :)

[07:11] <TimToady> were you trapping run-time errors?

[07:11] <TimToady> rakudo doesn't catch undef routines at compile time like std does

[07:11] <ingy> maybe

[07:11] <ingy> I have no ida what I'm trapping most of the time

[07:11] <ingy> :)

[07:12] <ingy> 00:08 <@ingy> how do I subst "x/y/z" into "x/y"?

[07:12] <ingy> :]

[07:12] <TimToady> same way you would in Perl 5, but quote the /

[07:12] <moritz_> rakudo: say 'foo x/y/z bla'.subst('x/y/z', 'x/y')

[07:12] <sorear> I need a better way to type stuff like 一

[07:12] <p6eval> rakudo 692aa1: OUTPUT«foo x/y bla␤»

[07:13] <sorear> that's control-shift-4E00 :/

[07:13] <lue> well, my biggest concern now is how you can implement new encoding standards (like UTF-32) in P6, and use them for Buf and IO

[07:13] <sorear> unfortunately I've yet to find an input method with documentation in English

[07:13] <moritz_> sorear: compose - - ?

[07:13] <lue> an em dash? —

[07:13] <ingy> rakudo: say "x/y/z".subst(/(.*)\/.*/, $0)

[07:13] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:13] <sorear> moritz_: that's not a dash, that's the CJK character for one

[07:13] <TimToady> I can just type CTRL-space ichi

[07:14] <sorear> I can't read Japanese at a software manuals level

[07:14] <sorear> TimToady: what do I need to install to make that work?

[07:14] <moritz_> ingy: if you want to use any match variables on the RHS of a subst, you need to use a closure, which gets $/ as the first positional parameter

[07:14] <moritz_> rakudo: say "x/y/z".subst(/(.*)\/.*/, -> $/ { $0 })

[07:14] <TimToady> 一 is not software manual level; it's first grade.  :)

[07:15] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:15] <moritz_> huh

[07:15] <sorear> TimToady: the documentation for installing input methods is well above a first-grade level

[07:15] <moritz_> rakudo: say "x/y/z".subst(/(.*)\/.*/, -> $/ { 'WTF' })

[07:15] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:15] <moritz_> rakudo: say "x/y/z".subst(rx/(.*)\/.*/, -> $/ { 'WTF' })

[07:15] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:15] <sorear> the only input method I've successfully installed is compose key handling for «, and that took months of shotgun debugging

[07:15] <TimToady> I use anthy

[07:16] <moritz_> rakudo: say "x/y/z".subst(rx/(<-[/]>*)\/.*/, -> $/ { 'WTF' })

[07:16] <p6eval> rakudo 692aa1: OUTPUT«WTF␤»

[07:16] <lue> I use IBus with anthy, then I type CTRL Space - Enter 

[07:16] <moritz_> rakudo: say "x/y/z".subst(rx/(<-[/]>*)\/.*/, -> $/ { $0 })

[07:16] <p6eval> rakudo 692aa1: OUTPUT«x␤»

[07:16] <moritz_> backtracking into captures

[07:16] <ingy> GO moritz_!!!

[07:16] <ingy> :)

[07:16] <sorear> TimToady: urxvt good enough or do I also need a better terminal?

[07:17] <TimToady> nokloo

[07:17] <ingy> I'm just trying to get the dir part of a pathname...

[07:17] <TimToady> I just use gnome term

[07:17] <lue> is there some sort of magic role or something to make your encoding usable with IO and such?

[07:18] <TimToady> mostly you have to make sure LANG=en_US.UTF-8

[07:18] <TimToady> then most things work right

[07:19] <ingy> rakudo: say "x/y/z".subst(/(.*)/.*/, -> $/ { $0 })

[07:19] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[07:19] <ingy> rakudo: say "x/y/z".subst(/(.*)[/].*/, -> $/ { $0 })

[07:19] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[07:19] <TimToady> [] isn't character class in p6

[07:19] <TimToady> use '/'

[07:19] <ingy> rakudo: say "x/y/z".subst(/(.*)<[/]>.*/, -> $/ { $0 })

[07:19] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:20] <ingy> rakudo: say "x/y/z".subst(/(.*)<before />.*/, -> $/ { $0 })

[07:20] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 20, near " />.*/, ->"␤»

[07:20] <moritz_> it's backtracking into captures that's NYI and causes trouble

[07:20] <ingy> rakudo: say "x/y/z".subst(/(.*)<before </>>.*/, -> $/ { $0 })

[07:20] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 20, near " </>>.*/, "␤»

[07:21] *** xinming left
[07:21] <ingy> rakudo: say "x/y/z".subst(/(.*)<before [/]>.*/, -> $/ { $0 })

[07:21] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 20, near " [/]>.*/, "␤»

[07:21] <TimToady> pmichaud was gonna fix backtracking into things pretty soon

[07:21] <lue> .oO(the spec doesn't seem to say anything about creating new encodings...)

[07:21] <TimToady> the spec wants to believe that every can live happily with unicode :)

[07:22] <TimToady> *everyone

[07:22] <sorear> lue: create a new encoding and thousands of people will swear to kill you.

[07:22] <ingy> so how can I get the dirpath from a unix filepath?

[07:22] <sorear> don't do it.

[07:22] <ingy> :)

[07:22] <ingy> tmtowtdi, I'm sure

[07:23] <TimToady> rindex :)

[07:23] *** xinming joined
[07:24] <TimToady> rakudo: say "x/y/z".subst(/(.*)'/'.*/, { $0 })

[07:24] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:24] <TimToady> rakudo: say "x/y/z".subst(/(.*)'/'.*/, -> $/ { $0 })

[07:24] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:24] <lue> TimToady: weeeell, one test relies on ISO-8859-1 to work right.

[07:25] <lue> (t/spec/S16-filehandles/io.t)

[07:25] <ingy> rakudo: say "x/y/z".subst(/(.*)'/'.*/, -> $/ { 'WTF' })

[07:25] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:25] <TimToady> rakudo: say "x/y/z".subst(/(.*)'/'.*/, 'foo')

[07:25] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:25] <lue> goodnight o/

[07:26] <TimToady> \o

[07:26] <rcsheets`> what is that last character inside p6eval's angle quotes? it renders as a thin box for me.

[07:26] <TimToady> rakudo: say "x/y/z".subst(/^(.*)'/'.*$/, 'foo')

[07:26] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:27] <TimToady> newline

[07:27] <TimToady> .u ␤

[07:27] <phenny> U+2424 SYMBOL FOR NEWLINE (␤)

[07:27] <rcsheets`> ah, ok. thanks.

[07:27] <ingy> rakudo: $f = "x/y/file"; say $f.substr(0, $f.rindex('/'))

[07:27] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Symbol '$f' not predeclared in <anonymous> (/tmp/qNbvoUISVZ:20)␤»

[07:27] <TimToady> most terminals it's an N over L

[07:27] <ingy> rakudo: my $f = "x/y/file"; say $f.substr(0, $f.rindex('/'))

[07:27] <p6eval> rakudo 692aa1: OUTPUT«x/y␤»

[07:27] <ingy> :)

[07:28] <rcsheets`> i assume it's just the font i'm using

[07:29] <TimToady> rakudo: say "x/y/z".match(/^.* <?before '/'>/)

[07:29] <p6eval> rakudo 692aa1: OUTPUT«x/y␤»

[07:29] <TimToady> rcsheets`: could well be a font issue

[07:29] <sorear> installing anthy and uim-anthy and restarting X did nothing.

[07:30] <sorear> I need docs for this, and not ones written in Japanese

[07:30] <sorear> ctrl-space ichi -> "ichi"

[07:30] <TimToady> what kind of machine?

[07:31] <sorear> PC, debian sid

[07:31] * sorear tries installing gnome-terminal

[07:32] *** tedv left
[07:32] <TimToady> you might need to tell it that ctrl-space is what turns it on somehow

[07:33] <TimToady> it might be bound to a different seq by default

[07:33] <TimToady> or you might need to speak to whatever manages your input methods and enable anthy in it

[07:33] <TimToady> or it could be your term

[07:34] <TimToady> historically some systems have been loathe to believe that anyone in US_en would want east asian keybindings

[07:34] <TimToady> but that has improved in the last couple years

[07:35] <TimToady> er, en_US

[07:35] <TimToady> *loath

[07:35] *** skids left
[07:35] <sorear> I think I need to install something to manage my input methods

[07:35] <sorear> I don't currently have anything fitting that description

[07:35] <TimToady> scim or ibus, ibus being the newest

[07:36] <TimToady> ibus is current default on ubuntu

[07:36] <ingy> rakudo: $*PROGRAM_NAME

[07:36] <p6eval> rakudo 692aa1:  ( no output )

[07:36] <ingy> rakudo: say $*PROGRAM_NAME

[07:36] <p6eval> rakudo 692aa1: OUTPUT«/tmp/827m47pFcy␤»

[07:36] <ingy> rakudo: say $*PROGRAM_NAME.rindex('/')

[07:37] <p6eval> rakudo 692aa1:  ( no output )

[07:37] <TimToady> rakudo: say $*PROGRAM_NAME.WHAT

[07:37] <p6eval> rakudo 692aa1: OUTPUT«Str()␤»

[07:37] * sorear installs ibus, ibus-gtk, ibus-anthy

[07:38] <ingy> I get unimplemented unicode in 'Cool::rindex' at line 2220:CORE.setting

[07:38] <sorear> apparently I now need to upgrade libc6, gcc, and python

[07:38] <ingy> rakudo: say $*PROGRAM_NAME.rindex('/')

[07:38] <p6eval> rakudo 692aa1:  ( no output )

[07:39] *** skids joined
[07:39] <TimToady> rakudo: say rindex('/',$*PROGRAM_NAME).perl

[07:39] <ingy> rakudo: my $p = $*PROGRAM_NAME; say $p.rindex('/')

[07:40] <p6eval> rakudo 692aa1:  ( no output )

[07:40] <ingy> rakudo: my $p = $*PROGRAM_NAME.Str; say $p.rindex('/')

[07:40] <TimToady> timing out maybe

[07:40] <p6eval> rakudo 692aa1:  ( no output )

[07:40] <TimToady> rakudo: say rindex('/',$*PROGRAM_NAME).WHAT

[07:40] <ingy> rakudo: say "OK"

[07:40] <p6eval> rakudo 692aa1:  ( no output )

[07:40] <p6eval> rakudo 692aa1: OUTPUT«OK␤»

[07:41] <TimToady> Cross-charset index not supported in 'Cool::rindex' at line 2212:CORE.setting in main program body at line 1:foo

[07:42] * sorear wonders if he should uninstall uim and xim

[07:43] <TimToady> so some kind of bug that p6eval is deigning not to report

[07:43] <sorear> p6eval doesn't report errors recently

[07:43] *** ashleydev left
[07:43] <TimToady> I don't think you should need to, as long as you aren't giving old env vars

[07:43] <sorear> I think it's part of moritz_ 's information suppression campaign

[07:44] <TimToady> I've got: XMODIFIERS=@im=ibus

[07:44] <ingy> TimToady: is $*PROGRAM_NAME not a string?

[07:44] <TimToady> rakudo: say '/'.PARROT

[07:44] <p6eval> rakudo 692aa1: OUTPUT«Str␤»

[07:44] <TimToady> rakudo: say $*PROGRAM_NAME.PARROT

[07:44] <p6eval> rakudo 692aa1: OUTPUT«String␤»

[07:44] <ingy> Str vs String?

[07:45] <ingy> rakudo: say $*PROGRAM_NAME.Str.PARROT

[07:45] <p6eval> rakudo 692aa1: OUTPUT«String␤»

[07:45] <TimToady> rakudo: my $s = $*PROGRAM_NAME ~ ''; say $s.rindex('/')

[07:45] <p6eval> rakudo 692aa1:  ( no output )

[07:46] <TimToady> looks like a leaky parrot

[07:46] <ingy> rakudo: my $s = ~$*PROGRAM_NAME; say $s.rindex('/')

[07:46] <p6eval> rakudo 692aa1:  ( no output )

[07:47] *** xinming left
[07:48] <sorear> perl: warning: Setting locale failed.

[07:48] <TimToady> rakudo: say ($*PROGRAM_NAME ~ "").rindex('/')

[07:48] <sorear> D:

[07:48] <p6eval> rakudo 692aa1:  ( no output )

[07:48] <TimToady> do you have the utf8 locales installed?

[07:49] <TimToady> locale -a should tell you

[07:50] <sorear> I have en_US.utf8

[07:50] <TimToady> and LANG=en_US.UTF-8 is what I use

[07:51] <TimToady> though, oddly, local -a lists it as .utf8

[07:51] <TimToady> probably normalizes

[07:51] <sorear> $LANG is .utf8 here

[07:51] <TimToady> possibly Perl wants the UTF-8 form

[07:51] <sorear> perl -e '' doesn't carp after apt-get returned

[07:51] <TimToady> I dunno

[07:51] <sorear> do I need to poke perl harder to get it to locale carp?

[07:51] <ingy> rakudo: say "x/y/z".subst(/^.* <?before '/'>/, '')

[07:52] <p6eval> rakudo 692aa1: OUTPUT«/z␤»

[07:52] <ingy> rakudo: say "x/y/z".subst(/^(.*) <?before '/'> .*/, -> $/ { $0 })

[07:52] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:53] <ingy> :'(

[07:53] <TimToady> subst is supposed to set $/ in the outer scope so that the closure sees it without passing it as a param

[07:53] <TimToady> but I don't think rakudo does that right yet

[07:54] <TimToady> rakudo: my $p = "x/y/z"; $p ~~ s/(.*) '/'/$0/; say $p

[07:54] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:55] *** skangas left
[07:55] <TimToady> rakudo: my $p = "x/y/z"; $p ~~ s/(.*) '/' .*/$0/; say $p

[07:55] <p6eval> rakudo 692aa1: OUTPUT«x/y/z␤»

[07:56] <TimToady> rakudo: my $p = "x/y/z"; $p ~~ s/.* <( '/' .* )>//; say $p

[07:56] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Confused at line 20, near "$p ~~ s/.*"␤»

[07:57] <TimToady> rakudo: my $p = "x/y/z"; $p ~~ s/.* '/'//; say $p

[07:57] <p6eval> rakudo 692aa1: OUTPUT«z␤»

[07:58] <TimToady> rakudo: my $p = "x/y/z"; $p ~~ s/$<foo>=[.*] '/' .*/$<foo>/; say $p

[07:58] <p6eval> rakudo 692aa1: OUTPUT«Any()␤»

[07:59] <sorear> according to pstree, ibus-daemon is now running

[07:59] <ingy> rakudo: my $f = "x/y/file"; while $f ~~ s/<! '/'>$// {}; say $f

[07:59] <TimToady> rakudo: my $p = "x/y/z"; my $foo; $p ~~ s/$foo=[.*] '/' .*/$foo/; say $p

[07:59] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Confused at line 20, near "while $f ~"␤»

[07:59] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Confused at line 20, near "$p ~~ s/$f"␤»

[07:59] <TimToady> maybe you should just use split :)

[08:00] <sorear> TimToady: http://pastie.org/1038636 - do you see anything obviously wrong here?

[08:00] <ingy> rakudo: my $f = "x/y/file"; while ($f ~~ s/<! '/'>$//) {}; say $f

[08:00] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[08:00] <sorear> it's still not working after despite ibus running

[08:00] <sorear> hmm

[08:00] <sorear> maybe I need to configure ibus to use anthy somehow.

[08:01] <TimToady> I seem to recall someone (ingy?) having trouble with have all the other LC_* set

[08:01] <TimToady> that cleared up after setting only LANG

[08:02] <TimToady> I get a little ibus gidget in the top bar

[08:02] <ingy> rakudo: my $f = "x/y/file"; export LANG="en_US.UTF-8"

[08:02] <ingy> export LANG="en_US.UTF-8"

[08:02] <p6eval> rakudo 692aa1: OUTPUT«Could not find sub &LANG␤  in main program body at line 20:/tmp/OSx9lm_7yu␤»

[08:03] <TimToady> with a little picture of a world in front of a keyboard

[08:03] <TimToady> that lets you configure ibus

[08:03] <ingy> rakudo: my $f = "x/y/file"; my $a = $f.split('/').pop; say $a.perl

[08:03] <p6eval> rakudo 692aa1: OUTPUT«"file"␤»

[08:03] <sorear> my computer isn't powerful enough for a top bar

[08:03] <sorear> I had to disable it

[08:03] <ingy> rakudo: my $f = "x/y/file"; my $a = $f.split('/'); say $a.perl

[08:03] <p6eval> rakudo 692aa1: OUTPUT«("x", "y", "file")␤»

[08:03] <ingy> rakudo: my $f = "x/y/file"; my $a = $f.split('/'); $a.pop; say $a.perl

[08:04] <p6eval> rakudo 692aa1: OUTPUT«("x", "y")␤»

[08:04] <ingy> rakudo: my $f = "x/y/file"; my $a = $f.split('/'); $a.pop; say $a.join('/')

[08:04] <TimToady> rakudo: my $f = "x/y/file"; say $f.flip.subst(/.*?'/'/, '').flip

[08:04] <p6eval> rakudo 692aa1: OUTPUT«x/y␤»

[08:04] <sorear> hmm.  this 'ibus-setup' thing looks promisng

[08:05] <sorear> 一!

[08:05] * sorear dances

[08:05] <ingy> rakudo: say "abc".flip

[08:05] <p6eval> rakudo 692aa1: OUTPUT«cba␤»

[08:05] <TimToady> すごい！

[08:06] <ingy> TimToady++

[08:06] <TimToady> in p6 we differentiate .reverse from .flip

[08:06] <TimToady> .reverse is only for lists

[08:10] <sorear> hey, ibus-setup even lets me disable control-space

[08:10] * sorear switches IM activation to a key combo he hits less often by accident

[08:10] <TimToady> yeah, I have that problem too...

[08:10] <sorear> TimToady++

[08:16] <ingy> I _finally_ have TestML really working now. Starting to pass the TestML test suite...

[08:16] <ingy> p6/rakudo is a huge PITA.

[08:17] <ingy> but you all are great to work with!

[08:17] <sorear> How, exactly, do you test a test harness

[08:17] <drbean> sorear: 恭喜! 恭喜!

[08:18] <moritz_> sorear: like everything else: you put in example input, and monitor the response

[08:18] <ingy> sorear: TestML is not a harness

[08:18] *** TiMBuS joined
[08:18] <ingy> it's a programming language neutral way to write unit tests, that works under any existing harness

[08:19] <sorear> drbean: that doesn't look like any of the 15 hanzi I know

[08:20] <TimToady> 恭喜發財 恭喜发财 [gong1 xi3 fa1 cai2] /congratulations for getting rich (traditional Chinese New Year's future use/

[08:20] <sorear> what did that come from?

[08:20] *** azert0x left
[08:21] <TimToady> originally, cedict

[08:21] <sorear> originally?

[08:22] <TimToady> well, I've had it since 2004 or so, so who knows what it is now...

[08:26] <TimToady> my mouth keeps flopping open, so I'd better flop over soon on purpose before I flop over accidentally

[08:26] <TimToady> zzz &

[08:28] *** Ross joined
[08:43] <sorear> perl6: say class { &?BLOCK.leave(2); } # Opinions?

[08:43] <p6eval> rakudo 692aa1: OUTPUT«Could not find sub &?BLOCK␤  in main program body at line 20:/tmp/lna2SdHXlV␤»

[08:43] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&class"␤    at /tmp/vAdP1UyJjg line 1, column 5 - line 2, column 0␤»

[08:44] <sorear> pugs: say class :: { &?BLOCK.leave(2); }

[08:44] <p6eval> pugs: OUTPUT«*** ␤    Unexpected " {"␤    expecting "(", twigil or word character␤    at /tmp/dzaSDMqFDH line 1, column 13␤»

[08:44] <sorear> pugs: say anon class { &?BLOCK.leave(2); }

[08:44] <p6eval> pugs: OUTPUT«*** No such subroutine: "&anon"␤    at /tmp/O5Yf7aEIG1 line 1, column 5 - line 2, column 0␤»

[08:54] <dalek> niecza: 9ddeaf8 | sorear++ |  (3 files):

[08:54] <dalek> niecza: A few steps towards class declarations

[08:54] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9ddeaf8406a7aec82f8cc3f77d54bf73e8f91ca4

[09:02] *** gfldex joined
[09:10] *** pmurias joined
[09:10] *** Ross left
[09:17] *** Ross joined
[09:39] *** PZt joined
[09:40] *** quietdev joined
[09:54] <sorear> results of today's walk:

[09:54] <sorear> - niecza is going to implement modules using a blatant rip of the .NET assemblies mechanism, which I will then convince TimToady to write into the spec

[09:55] <sorear> - precompilation of individual modules only really needs to be supported for the cases where whole program static compilation is possible

[09:56] <sorear> - STD.pm6 tangles static analysis too much; the module system, setting loader, trait system should be factored out to an $*ACTIONS-like contextually bound pair

[09:58] <sorear> - $STD::ALL could usefully be refactored, perhaps by only storing the roots of compilation units which are referenced by use, or something like that.  OUTER is problematic, doubly so because of P5's circular reference stupidity

[10:02] * sorear out.

[10:38] *** eiro joined
[10:38] *** eiro left
[10:58] *** redicaps1 joined
[11:00] *** redicaps1 left
[11:16] *** sftp joined
[11:25] *** M_o_C joined
[11:28] *** Kejohm joined
[11:32] *** Kejohm left
[11:35] *** s1n left
[11:39] <cognominal> rakudo:  say ?1..2

[11:39] <p6eval> rakudo 692aa1:

[11:39] <p6eval> ..OUTPUT«111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111…

[11:44] <moritz_> wtf?

[11:44] <cognominal> masaked

[11:45] *** Ross left
[11:45] *** Ross joined
[11:45] <cognominal> #76442

[11:46] <moritz_> rakudo: say Bool::True..2

[11:46] <jnthn> rakudo:  say ?(1..2)

[11:46] <p6eval> rakudo 692aa1:

[11:46] <p6eval> ..OUTPUT«111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111…

[11:46] <p6eval> rakudo 692aa1: OUTPUT«1␤»

[11:46] <jnthn> oh

[11:46] <jnthn> Bool.succ on true is identity.

[11:46] *** eiro joined
[11:46] *** eiro left
[11:46] <moritz_> right

[11:47] <jnthn> I bet that's what causes it.

[11:47] <cognominal> I think Range should be  a parametric role so as to force the two arguments to be of the same type.

[11:47] <cognominal> not sure of the details though

[11:48] <moritz_> or at least if one endpoint is numeric, coerce the other ot numeric

[11:49] <cognominal> it makes no sense to have extremty of a range to have different types.

[11:50] <cognominal> I think my example should fail.

[11:52] <jnthn> moritz_: That makes sense, yes

[11:57] *** pragma_ left
[11:58] *** M_o_C left
[12:01] *** pmurias left
[12:05] *** pragma_ joined
[12:06] *** pragma_ is now known as Guest38594

[12:09] *** kid51 joined
[12:25] *** ilogger2 joined
[12:30] *** SmokeMachine joined
[12:31] *** rv2733 joined
[12:31] *** SmokeMachine left
[12:32] *** SmokeMachine joined
[12:37] *** takadonet joined
[12:38] <takadonet> morning all

[13:04] *** SmokeMachine left
[13:10] *** SmokeMachine joined
[13:13] *** takadonet left
[13:16] *** SmokeMachine left
[13:40] *** tylercurtis joined
[13:41] *** TiMBuS joined
[13:44] *** masak joined
[13:44] <masak> #perl6! \o/

[13:45] <jnthn> #masak! \o/

[13:45] <masak> rakudo: say (my $a) = 1,2,3; say $a # discovered by TimToady++

[13:45] <p6eval> rakudo 692aa1: OUTPUT«Any()␤»

[13:45] <masak> did it ever get reported?

[13:46] <jnthn> masak: Now i'm awake-ish..

[13:46] <jnthn> rakudo: say ((my $a) = 1,2,3);

[13:46] <p6eval> rakudo 692aa1: OUTPUT«1 2 3␤»

[13:46] <jnthn> rakudo: (say (my $a)) = 1,2,3;

[13:47] <p6eval> rakudo 692aa1: OUTPUT«Any()␤»

[13:47] <masak> ah.

[13:47] <jnthn> It's only a bug if it's not meant to have parsed as the second of those.

[13:47] * masak asks viv

[13:53] *** mulander joined
[13:54] <masak> viv puts the 'say' outermost. http://gist.github.com/470719

[13:54] * masak submits rakudobug

[14:04] <jnthn> masak++

[14:11] <moritz_> masak++ # ufo

[14:11] <masak> moritz_++ # p6eval yapsi target

[14:12] <moritz_> masak: I haven't cron-jobbed the rebuild yet

[14:12] <masak> no worries. I'm not hacking on it right now.

[14:12] <masak> might be later today, though. :) eager to set my teeth in the new runtime.

[14:13] * moritz_ just made Tufte compile

[14:13] *** azert0x joined
[14:13] *** azert0x left
[14:13] *** pmurias joined
[14:14] <moritz_> and I realized I don't understand enough ruby to continue porting scruffy

[14:23] *** azert0x joined
[14:23] *** azert0x left
[14:27] <masak> Austrian Airlines and I seem to have just agreed on some nice, cheap YAPC::EU flight tickets for me. :)

[14:27] <moritz_> you use an Australian airline to fly from Sweden to Italy? sweet :-)

[14:28] <masak> er, no :)

[14:29] <masak> has anyone else investigated trains from Bologna to Pisa?

[14:30] <jnthn> Austria is the one without Kangaroos

[14:30] <jnthn> masak: Yes

[14:30] <jnthn> masak: I'll be doing that.

[14:30] <masak> me too. on the Monday.

[14:31] <jnthn> When?

[14:31] <masak> I'll be arriving in Bologna 19:15 on 2010-08-02.

[14:31] <jnthn> Ah, OK

[14:31] <jnthn> Waaaay later than me.

[14:31] <masak> ok.

[14:32] <jnthn> (Like, 7 hours later.)

[14:32] <jnthn> Anyway, probably it's a case of connecting in Florence.

[14:32] <jnthn> Though there may be some direct trains too.

[14:33] *** timbunce joined
[14:33] <masak> jnthn: does one pre-book trains, or just buy them JIT?

[14:33] *** azert0x joined
[14:33] *** azert0x left
[14:33] <jnthn> masak: I plan to buy them on the day.

[14:34] <jnthn> masak: I did that kinda thing when in Italy before now.

[14:34] <jnthn> Worked out.

[14:34] <masak> you plan to buy them afk, and not thourhg the intertubes?

[14:34] <masak> *through

[14:34] <jnthn> Probably

[14:34] <jnthn> I'm not sure what options for buying them over the Intertubes are for Italy

[14:35] <jnthn> I think I looked into it when doing vacation in Italy previously, and ended up not doing so.

[14:35] <masak> ok.

[14:35] *** azert0x joined
[14:36] *** azert0x left
[14:36] *** azert0x joined
[14:37] <masak> "No subsets of Ada are allowed. Babbage is just the opposite. None of Babbage is defined except its extensibility - each user must define his own version. To end the debate of large languages versus small, Babbage allows each user to make the language any size he wants. Babbage is the ideal language for the "me" generation." -- http://www.tlc-systems.com/babbage.htm

[14:38] <masak> that sounds a bit like Perl 6, actually :)

[14:38] <moritz_> it sounds a bit more extremist than Perl 6

[14:38] <moritz_> (which is a large language by default)

[14:38] <masak> I guess it is.

[14:38] <masak> or it's a small language with a default large language slapped on.

[14:39] <masak> *lol* -- the calling convention is "call by telephone" :P

[14:39] <masak> "This is especially effective for long-distance parameter passing."

[14:44] <moritz_> masak: I'm hacking a bit on SVG.pm... currently SVG.serialize takes a single positional argument

[14:45] <moritz_> masak: which makes it a bit awkward to pass pairs to it

[14:45] <moritz_> SVG.serialize((:x[]))

[14:45] <masak> moritz_: hm. yes.

[14:45] <moritz_> masak: mind if I magically accept a single, named param instead?

[14:45] <masak> no.

[14:45] <masak> please go ahead.

[14:46] <moritz_> I'm also writing tests for it :-)

[14:46] <masak> moritz_++

[14:46] <moritz_> with the background of refactoring later

[14:46] <masak> sounds good.

[14:47] *** patspam joined
[14:48] <masak> sorear, lue: when I was 15, I was also toying with the idea of writing an OS. :-P

[14:53] <tylercurtis> masak: You should. I cannot wait to see the release announcements for that. :)

[14:54] <TimToady> ranges are not always the same type on both sides.  see 1..*

[14:57] <TimToady> After Christmas it should be our goal to make Perl 6 fast enough that we can write an OS in it...and then *not* write an OS in it.  :)

[14:57] *** skids joined
[15:00] *** oha joined
[15:00] <moritz_> sounds boring :-)

[15:01] <moritz_> rakudo: say .Int.perl for True, False

[15:01] <p6eval> rakudo 692aa1: OUTPUT«Bool::True␤Bool::False␤»

[15:01] <moritz_> uhm.

[15:01] <moritz_> masak: wanna submit? :-)

[15:02] <TimToady> rakudo: say .Numeric.perl for True, False

[15:02] <p6eval> rakudo 692aa1: OUTPUT«1␤0␤»

[15:02] <TimToady> but I suspec .Int should do that too

[15:02] <TimToady> rakudo: say True ~~ Int

[15:02] * masak ubsmits

[15:02] <p6eval> rakudo 692aa1: OUTPUT«0␤»

[15:02] <moritz_> rakudo: sub f($t?) { say defined($t).Int }; f("a" => 3)

[15:03] <masak> er, *submits

[15:03] <p6eval> rakudo 692aa1:  ( no output )

[15:03] <moritz_> gives "Method 'Int' not found for invocant of class 'Pair'" locally

[15:03] <moritz_> which is wrong too, no?

[15:03] <moritz_> is defined() parsed specially?

[15:04] <ingy> morning

[15:04] <masak> moritz_: no.

[15:04] <moritz_> so another bug?

[15:04] <masak> let me confirm locally.

[15:04] * ingy just discovered that .WHICH is not really unique.

[15:04] <TimToady> rakudo: say defined("a" => 3).WHAT

[15:04] <p6eval> rakudo 692aa1: OUTPUT«0␤»

[15:04] <masak> moritz_: I get the same.

[15:04] * masak submits rakudobug

[15:05] <moritz_> rakudo: say 1 xor 1

[15:05] <p6eval> rakudo 692aa1: OUTPUT«1␤»

[15:05] <moritz_> huh.

[15:05] <ingy> rakudo: my $h = {}; my $n = $h.WHICH; say $h.WHICH; say $n.WHICH;

[15:05] <p6eval> rakudo 692aa1: OUTPUT«35409216␤35409216␤»

[15:05] <TimToady> rakudo say (1 xor 1)

[15:05] <TimToady> rakudo: say (1 xor 1)

[15:05] <p6eval> rakudo 692aa1: OUTPUT«␤»

[15:06] <moritz_> ingy: that'a known problem, .WHICH should include type information

[15:06] <masak> that's right, right?

[15:06] <ingy> I think it would be better to add a '.' or something to the beginning of scalars' WHICH

[15:06] <masak> the 'say 1 xor 1' thing.

[15:07] <moritz_> masak: yes, looser precedence than I thought

[15:07] <ingy> moritz_: no, I think WHICH should just be unique

[15:07] <masak> moritz_: makes sense that it's the same as 'or', though.

[15:07] <TimToady> S02:583

[15:07] <moritz_> ingy: which it would be achieve with type info, yes

[15:07] <TimToady> rakudo is not up to spec there

[15:07] <ingy> adding a '.' would also, moritz_ 

[15:07] <ingy> and simpler

[15:07] <ingy> :)

[15:08] <masak> rakudo: sub f($t?) { say defined($t).WHAT }; f("a" => 3)

[15:08] <moritz_> ingy: the old spec said that for value objects (Str, Int, Num etc.) .WHICH == $_

[15:08] <p6eval> rakudo 692aa1: OUTPUT«0␤»

[15:08] <masak> o.O

[15:08] <ingy> moritz_: and I agree with that

[15:08] <moritz_> ingy: then a dot doesn't help

[15:08] <ingy> moritz_: oh?

[15:08] <ingy> moritz_: example?

[15:08] <moritz_> unless you do it only for non-value objects

[15:09] <TimToady> S02:583 !!!

[15:09] <masak> hugme: hug TimToady

[15:09] * hugme hugs TimToady

[15:09] <moritz_> TimToady: you may be the language designer, but we're still free to ignore you :-)

[15:09] <ingy> TimToady: to whom do you speak?

[15:09] <masak> rakudo: sub f($t?) { say defined($t).WHAT }; f()

[15:09] <p6eval> rakudo 692aa1: OUTPUT«0␤»

[15:09] * diakopter winks awake

[15:10] <masak> rakudo: sub f($t?) { say defined($t).Int }; f()

[15:10] <p6eval> rakudo 692aa1:  ( no output )

[15:11] <TimToady> ingy: when I cite the spec in the middle of a conversation, it means the spec already discusses this, and it might have some bearing on the conversation, unless you're moritz_++  :)

[15:12] <masak> I like the exception clause to that.

[15:12] <ingy> moritz_: ''.WHICH -> '.'; '.'.WHICH' -> '..'; $h.WHICH.WHICH -> '.35409216'

[15:12] <ingy> TimToady: except you were in the middle of 3 conversations

[15:12] <ingy> :)

[15:12] <diakopter> std: S02:583 !!!

[15:12] <p6eval> std 31611: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/v1zB_w_eZb line 1:␤------> [32mS02:[33m⏏[31m583 !!![0m␤    expecting any of:␤      coloncircumfix␤   signature␤Undeclared name:␤ 'S02' used at line 1␤Parse failed␤FAILED 00:01 108m␤»

[15:13] <ingy> TimToady: and my reponse to your blurt would then be, "url?". 

[15:14] * ingy just woke up on the grumpy side of the bed

[15:14] <moritz_> irc.pugscode.org

[15:14] <masak> ingy: just go to the IRC logs, and it'll be a link.

[15:14] <moritz_> which turns S02:583 into an URL

[15:15] <ingy> o neat!

[15:15] *** oha left
[15:15] <moritz_> ingy: we've spent a long time optimizing those autolinking features :-)

[15:16] <masak> moritz_++ # again

[15:16] <diakopter> rakudo: say ?|0?|0

[15:16] <p6eval> rakudo 692aa1: OUTPUT«1␤»

[15:17] <diakopter> rakudo: say ?|0!?|0

[15:17] <p6eval> rakudo 692aa1: OUTPUT«0␤»

[15:18] <ingy> moritz_++

[15:19] <masak> afk &

[15:19] *** masak left
[15:21] <ingy> TimToady: so... I'm glad that S02:583 mentions YAML, because I was just starting to write a YAML dumper for p6 when I came across the WHICH issue. For YAML's purposes, adding a '.' to the start of scalars (and using the current numbers for objects) would probably work just great.

[15:21] <ingy> TimToady: that's akin to a scheme I use for p5...

[15:22] <ingy> then again, I'm not too awfully concerned about the collisions for now :)

[15:23] <ingy> bbi2-3h...

[15:23] * TimToady thinks "fractional addresses..."

[15:28] *** ashleydev joined
[15:31] <moritz_> phenny: tell masak that I've pushed some fairly substantial changes to SVG, making it use methods internally instead of subs. My plan would be to rename it to XML::Writer or so, and then start a new SVG.pm, which automatically promotes some attributes into :style<...>, and optionally adds an SVG header

[15:31] <phenny> moritz_: I'll pass that on when masak is around.

[15:33] *** asig2 joined
[15:40] *** asig2 left
[15:48] *** ashleydev left
[16:05] <timbunce> What's the best way to represent exportable constants in a role?

[16:13] <TimToady> std: my constant pi is export = 3;  # won't work in rakudo though

[16:13] <p6eval> std 31611: OUTPUT«ok 00:01 112m␤»

[16:13] <TimToady> or possibly

[16:13] <TimToady> std: has constant pi is export = 3;

[16:14] <p6eval> std 31611: OUTPUT«ok 00:01 109m␤»

[16:14] <TimToady> constant is supposed to be 'our' by default

[16:14] <TimToady> rakudo: my constant pi = 3;

[16:14] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Malformed my at line 20, near "constant p"␤»

[16:15] <diakopter> std: constant pi is export = 3;

[16:15] <TimToady> but rakudo is still parsing it as a scope declarator rather than a sub declarator

[16:15] <p6eval> std 31611: OUTPUT«ok 00:01 109m␤»

[16:15] <timbunce> TimToady: thanks. What's a workable approach for rakudo meanwhile?

[16:15] * moritz_ wonders if enums are exported

[16:15] <TimToady> rakudo: role Foo { constant pi = 3 }; say Foo::pi

[16:16] <p6eval> rakudo 692aa1: OUTPUT«Can not find sub Foo::pi␤  in main program body at line 1␤»

[16:16] <moritz_> rakudo: role Foo { our $pi = 3 }; say $Foo::pi

[16:16] <p6eval> rakudo 692aa1: OUTPUT«Null PMC access in type()␤  in main program body at line 20:/tmp/M57BNs8HR2␤»

[16:16] <moritz_> rakudo: module Foo { our $pi = 3 }; say $Foo::pi

[16:16] <p6eval> rakudo 692aa1: OUTPUT«3␤»

[16:16] <moritz_> feijl

[16:16] * moritz_ submits rakudobug

[16:16] <timbunce> moritz_: yeah, that'll do. thanks

[16:17] *** TiMBuS left
[16:17] <jnthn> moritz_: fwiw, I'm not sure how to make that one work.

[16:18] <jnthn> our scoped stuff in roles doesn't make too much sense or at least needs some more thought

[16:18] <TimToady> rakudo: role Foo { our $pi = 3 }; class F does Foo {}; say $F.pi

[16:18] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Symbol '$F' not predeclared in <anonymous> (/tmp/6oAiHlFE7w:20)␤»

[16:18] <TimToady> rakudo: role Foo { our $pi = 3 }; class F does Foo {}; say $F::pi

[16:18] <p6eval> rakudo 692aa1: OUTPUT«Null PMC access in type()␤  in main program body at line 20:/tmp/WzM6KtH3Vy␤»

[16:18] <jnthn> TimToady: heh, that's not going to work for sure

[16:19] <moritz_> jnthn: maybe by punning the role into a class of the same name?

[16:19] <TimToady> rakudo: role Foo { our $pi = 3 }; Foo.new; say $Foo::pi

[16:19] <p6eval> rakudo 692aa1:  ( no output )

[16:19] <TimToady> kaboom?

[16:20] <jnthn> TimToady: er

[16:20] * timbunce thinks I'll generate methods for now and wait for the dust to settle...

[16:20] <jnthn> TimToady: Why would the meta-object for a role know about about an our-scoped variable in the role body?

[16:20] *** justatheory joined
[16:20] <jnthn> *know anything about

[16:20] <diakopter> moritz_: we could make p6eval output the "killed..." message I think

[16:20] <TimToady> std: has constant $.pi = 3;

[16:20] <moritz_> diakopter: +1 if you know how to do it

[16:20] <p6eval> std 31611: OUTPUT«ok 00:01 110m␤»

[16:20] <diakopter> heh

[16:21] <jnthn> TimToady: Anyway, for it to work at all we probably need to say that creating a concrete role creates a package along side it, then we'd need to get the concrete form of the role and .WHO it to get the package and lookup in that.

[16:21] *** skangas joined
[16:21] <jnthn> Since it could easily have been role Foo[$x] { our $y = $x; }

[16:22] <TimToady> twoo

[16:22] <jnthn> In general, anything our-scoped inside a role is horribly awkward.

[16:23] <TimToady> well, perhaps the generic role has a canonical longname by which its package is named

[16:23] <moritz_> I'm trying to port some Ruby code to Perl 6, and... URKS. @points.extend Scruffy::Helpers::PointContainer unless @points.kind_of? Scruffy::Helpers::PointContainer

[16:23] <jnthn> TimToady: That doesn't address it so much though

[16:24] <TimToady> actually, the canonical name of Foo[$x] is just Foo, but Foo[Int] is the longname, I guess :)

[16:24] <jnthn> TimToady: Because it's about instantiations of the role rather than the "role" itself (where a role as it appears in the program is really specifying a role factory that may produce many roles).

[16:25] <TimToady> so Foo:: is the package of the role factory, but ::('Foo[Int]'):: or some such is the package of the instant

[16:25] <TimToady> *instance

[16:25] <lue> y oh hai o/

[16:26] <TimToady> except, of course, Foo:: doesn't work terribly well for a multi-role

[16:28] <jnthn> All roles are multi-roles in a sense

[16:28] <TimToady> rakudo: role Foo[Int] { method x { say 1 } }; role Foo[Num] { method x { say 1.414 } }; class X does Foo[Int] {}; X.new.x

[16:28] <p6eval> rakudo 692aa1:  ( no output )

[16:28] <TimToady> shouldn't that work?

[16:29] <TimToady> heh, Could not find sub &say

[16:29] <jnthn> > role Foo[Int] { method x { 1 } }; role Foo[Num] { method x { 1.414 } }; class

[16:29] <jnthn> X does Foo[Int] {}; say X.new.x

[16:29] <jnthn> 1

[16:29] <jnthn> Yes, it's a lexical chain bug with roles

[16:30] <pmurias> TimToady: how should i go about adding the Perl6:: prefix to packages in STD?

[16:30] <jnthn> I hoped pmichaud++'s fixes would help, but sadly not. :-(

[16:30] <TimToady> rakudo: role Foo[Int] { method x { 1.say } }; role Foo[Num] { method x { 1.414.say } }; class X does Foo[Int] {}; X.new.x

[16:30] <p6eval> rakudo 692aa1: OUTPUT«1␤»

[16:30] <TimToady> rakudo: role Foo[Int] { method x { 1.say } }; role Foo[Num] { method x { 1.414.say } }; class X does Foo[Num] {}; X.new.x

[16:30] <p6eval> rakudo 692aa1: OUTPUT«1.414␤»

[16:32] <jnthn> Anyway, role Foo { } is really taken to be role Foo[] { }

[16:32] <jnthn> That is, a role that takes no type parameters.

[16:35] *** silug joined
[16:39] <TimToady> pmurias: I thought you said you weren't changing STD

[16:41] <pmurias> did I?

[16:42] <TimToady> or maybe sorear++ indicated that

[16:42] <TimToady> just packaging it in Perl6:: for CPAN

[16:43] <pmurias> I created an installable src/STD-dist

[16:43] <TimToady> which, up till now has been a namespace for flakey emulations of Perl 6

[16:43] <TimToady> which STD arguably is pretty flakey :)

[16:43] <pmurias> it's has some minor changes needed to specify search locations for some things and make one bug workaround work

[16:43] <moritz_> pmurias: if you give me a link to a document that describes how to install and run mildew, I can try to fix up the mildew: evalbot target

[16:44] <pmurias> moritz_: that would be great

[16:45] <TimToady> anyway, my intent is that someday when Perl 6 is real, STD be a real top-level package for any language derived from STD

[16:45] <pmurias> TimToady: i want to add an Perl6:: prefix to stuff so that the dist can be place on CPAN

[16:45] <TimToady> yes, well, that's kinda CPAN's problem

[16:45] <pmurias> * placed

[16:46] <moritz_> pmurias: you can also prevent it from being indexed by appropriate entries in the META.yaml file

[16:47] <pmurias> moritz_: it's intended that mildew will be installed with cpanm Mildew

[16:47] <TimToady> if Perl 6 folks can't create new top-level package names without getting the agreement of CPANfolk, then I've got a problem with that.

[16:48] <pmurias> i don't think CPANfolk would complain if dist built from STD-dist was uploaded on cpan

[16:49] <pmurias> but in it's current form it would create a lot of top-level package names 

[16:49] <pmurias> and i'm not sure we want to use things like DEBUG and Stash

[16:50] <TimToady> maybe we need real namespaces (and I don't mean packages in the parrot sense)

[16:50] <pmurias> moritz_: dzill --install-command 'cpanm .' in src/STD-dist,v6/Mildew,v6/SMOP,v6/Mildew-Setting should install mildew

[16:51] <moritz_> pmurias: why not just no-index all files in the STD distribution, add an (indexed) .pod file explaining what it's all about, and be happy?

[16:51] <TimToady> and I'd rather prefix all those types with STD:: than Perl6::, I think

[16:52] <TimToady> it would be nice to have a namespace prefix mechanism that would make GLOBAL:: really mean GLOBAL::STD:: or some such, maybe

[16:52] <TimToady> needs more thinking...but I hate ::-itis

[16:53] <pmurias> moritz_: if you don't want to use Dist::Zilla i could supply a bunch of tarball

[16:53] <pmurias> * tarballs

[16:54] <moritz_> pmurias: I'm installing dist::zilla now... shouldn't be a problem

[16:56] <TimToady> and STD is called STD because it's not just for STD::P6, but also for STD::P5, STD::Ruby, STD::Python, STD::APL, etc

[16:57] <pmurias> STD::P5 would be very handy for p5 users

[16:57] <TimToady> it's half written already

[16:57] <TimToady> ran out of tuits

[16:57] <moritz_> p5 users have PPI, no?

[16:57] <TimToady> PPI, at least historically, tended to have no understanding of what the code actually means

[16:58] <moritz_> like me :-)

[16:59] <TimToady> p6 needs a p5 parser so it can at least find the end of the { use v5; ... } block

[16:59] <pmurias> and PPI is not extensible

[16:59] <TimToady> and perhaps also run the block some day

[17:00] <pmurias> TimToady: wouldn't it be possible to harness the perl5 parser for that?

[17:01] <TimToady> std: rx:P5/[a-z]/

[17:01] <p6eval> std 31611: OUTPUT«ok 00:01 125m␤»

[17:01] *** patspam left
[17:01] *** patspam1 joined
[17:01] *** patspam1 is now known as patspam

[17:01] <TimToady> it uses that subset of it already

[17:03] <TimToady> std: rx/[a-z]/

[17:03] <p6eval> std 31611: OUTPUT«[31m===[0mSORRY![31m===[0m␤Invalid regex metacharacter (must be quoted to match literally) at /tmp/KcnLZdfvEt line 1:␤------> [32mrx/[a-[33m⏏[31mz]/[0m␤Potential difficulties:␤  [a-z] appears to be an old-school character class; please use <[a..z]> if you mean a character

[17:03] <p6eval> ..c…

[17:04] <pmurias> moritz_: if you encounter any problems with installing Mildew mention them to me

[17:04] <TimToady> pmurias: not easily, unless you teach the perl5 parser to treat an unmatched } as an EOF

[17:04] <moritz_> pmurias: just a question... can I easily install it into a location that's not the system perl, so that I can wipe it again easily?

[17:05] <pmurias> local::lib

[17:05] <moritz_> I feared that answer

[17:05] <pmurias> that's what i use

[17:05] <moritz_> I use it too

[17:05] <pmurias> moritz_: what's the problem with that?

[17:05] <moritz_> which is the problem

[17:05] <moritz_> I want to have a location for my modules

[17:05] <moritz_> and a separate for mildew modules

[17:05] <moritz_> so that I can wipe mildew stuff without wiping mine

[17:05] <pmurias> i see

[17:06] <pmurias> cpanm has and -l option for specifing which local::lib directory to install to

[17:08] <pmurias> moritz_: do you think that will work?

[17:09] <moritz_> I'm trying it...

[17:09] <moritz_> Unrecognized command: --install-command.

[17:10] <pmurias> dzill install --install-command?

[17:10] <moritz_> right, just arrived at the same conclusion

[17:10] <pmurias> * dzil

[17:12] <moritz_> huh.

[17:12] <moritz_> #   Failed test 'use STD;'

[17:12] <moritz_> #   at t/use_ok.t line 4.

[17:12] <moritz_> #     Tried to use 'STD'.

[17:12] <moritz_> #     Error:  Can't locate File/ShareDir.pm in @INC

[17:13] <moritz_> cpan[1]> install File::ShareDir

[17:13] <moritz_> Going to read '/root/.cpan-5.12.1/Metadata' Database was generated on Fri, 09 Jul 2010 23:27:09 GMT

[17:13] <moritz_> File::ShareDir is up to date (1.02).

[17:13] <moritz_> pmurias: I have to leave now to buy some food before the stores close, will try again later or tomorrow

[17:14] <pmurias> moritz_: ok

[17:17] <pmurias> moritz_: fixed

[17:17] <pugssvn> r31612 | pmurias++ | [STD-dist] add a missing prereq noticed by mortiz++ 

[17:20] *** ashleydev joined
[17:21] *** tedv joined
[17:21] <pugssvn> r31613 | lwall++ | [specs] add C<also> declarator to prefix any trait to be applied to the outer declaration 

[17:21] <pugssvn> r31613 | this lets us say "also is Int" without the 'is' conflicting with Test's is function

[17:21] <pugssvn> r31613 | and it's extensible as new trait_mods are added

[17:21] <pmurias> moritz_: you don't have File::ShareDir?

[17:22] <moritz_> pmurias: I have

[17:23] <pmurias> and the tests don't find it?

[17:23] <moritz_> pmurias: it's just... I have two perls, and currently no idea if dzil and cpanm pick up the right one

[17:23] <moritz_> anyway, right now it's happily installing a huge dependency tree

[17:23] <pmurias> looking at the @INC should clear some things up

[17:24] <moritz_> which works for me as long as no action on my part is required :-)

[17:25] <pmurias> that's the intended installation experience ;)

[17:25] <moritz_> it's a piece of irony that I need DateTime::TimeZone even though none of the code works with time zones

[17:26] <moritz_> but Params-Validate requires it, it seems

[17:26] <pmurias> you are still at STD-dist?

[17:26] <moritz_> no, mildew

[17:26] <moritz_> STD-dist was easy, because STD ran on the evalbot server previously

[17:27] <pmurias> mildew has a lot of dependencies

[17:27] <pmurias> moritz_: so you decided to postpone shopping?

[17:28] <moritz_> pmurias: my girlfriend decided for me :/

[17:28] <moritz_> still 32min left :-)

[17:34] *** Mowah joined
[17:39] <pmurias> moritz_: how's the installation going?

[17:41] <pugssvn> r31614 | lwall++ | [basic.t] s/does/also does/ in the one spot that uses it 

[17:52] *** Mowah left
[17:55] *** sftp joined
[18:00] *** paroxyzm joined
[18:00] <lue> rakudo: my Buf @a = 1,2,3; @a[3] = 4; say @a; say @a.WHAT

[18:00] <p6eval> rakudo 692aa1:  ( no output )

[18:04] <lue> > my Buf @a = 1,2,3; @a[3] = 4; say @a; say @a.WHAT

[18:04] <lue> maximum recursion depth exceeded

[18:05] <TimToady> that's an array *of* Buf

[18:05] <TimToady> not an array of Int

[18:06] <lue> oh. I was under the impression that Buf was a type of array.

[18:06] <arnsholt> Then you want my Buf $a

[18:06] <TimToady> putting the type in front gives the type of each individual element

[18:07] <TimToady> which works for $a because there's only one

[18:07] <paroxyzm> Hi! Im interested in perl6 regexes.. i found that article: http://perlgeek.de/en/article/5-to-6#post_19 and it says : 'aaaa' ~~ m/ a | aaa | aa /;

[18:07] <lue> rakudo: my Buf $a = 1,2,3; say $a

[18:08] <p6eval> rakudo 692aa1:  ( no output )

[18:08] <paroxyzm> On my pc the return value is 'a' not 'aaa'

[18:09] <lue> rakudo: say I_AM_A_FAILURE; # seems like p6eval isn't returning errors

[18:09] <p6eval> rakudo 692aa1: OUTPUT«Could not find sub &I_AM_A_FAILURE␤  in main program body at line 20:/tmp/fVRVwEgqHV␤»

[18:12] <lue> rakudo: say 'aaaa' ~~ m/ a | aaa | aa /

[18:12] <p6eval> rakudo 692aa1: OUTPUT«a␤»

[18:12] <tylercurtis> Does Rakudo have LTM?

[18:12] <lue> yes (IIRC), but it's quite clearly broken there :)

[18:13] <moritz_> only for constant prefixes of proto regexes

[18:13] <paroxyzm> What was the meaning of that output?

[18:13] <moritz_> pmurias: ! Bailing out the installation for Mildew-0.01. Retry with --prompt or --force.

[18:13] <moritz_> [DZ] [DZ] error running {{["cpanm -L /home/p6eval/mildew-install ."]}} at /usr/local/lib/perl/5.10.0/Moose/Meta/Method/Delegation.pm line 108

[18:15] <lue> paroxyzm: that post is from 2008. I get the feeling things have changed since then. [as they frequently do in P6]

[18:16] <moritz_> paroxyzm: it's supposed to output 'aaa'

[18:16] <moritz_> just not yet implemented yet

[18:16] <paroxyzm> lue: Thanks :)

[18:16] <moritz_> lue: I try to keep those posts up-to-date

[18:16] <moritz_> if you find something where it differs from current spec, please let me know

[18:17] <TimToady> LTM is implemented in STD but not in rakudo

[18:17] <moritz_> and as I pointed out at the top of the page, I described spec status, not "is" status

[18:17] <jnthn> TimToady: A while back you mentioned stuff about native types and part of it was Num.REPR. I've been working out how to slot this into my mental model of Perl 6...and slowly succeeding. But is the implication here that given a type, we can know its representation?

[18:17] <lue> paroxyzm: I forgot to mention that sometimes it's the implementation's fault. :)

[18:18] <jnthn> TimToady: That is, what happens if I go and Int.CREATE(:repr('P6Hash'))?

[18:18] <jnthn> TimToady: But the real reason I'm asking this in a sense is that I've been struggling with fast attribute access in combination with not knowing the underlying representation.

[18:19] <paroxyzm> lue: So what is the best implementation for regexes?

[18:19] <paroxyzm> lue: anyway p6 will be big if those regexes are to become truth ;)

[18:19] <TimToady> jnthn: if it's P6opaque, the repr can be anything you like, since it's opaque

[18:19] <jnthn> TimToady: That is, knowing that the type is Dog, if we can Dog.CREATE(:repr<anything>), actually tells us nothing we can rely on at runtime.

[18:20] <jnthn> And that means we hit real problems when trying to emit something more optimal than two names.

[18:20] <jnthn> (the class and the attribute name)

[18:20] <lue> paroxyzm: I can't say for sure, I'm a 'newb' myself :)

[18:20] <jnthn> Or so far as I can see anyway.

[18:21] <jnthn> I guess what I'm asking for is the REPR to be choosable by type.

[18:21] <paroxyzm> lue: oh

[18:21] *** justatheory left
[18:21] <jnthn> So you commit to "this type will have this REPR" at class composition time.

[18:21] *** rcsheets` left
[18:21] <jnthn> But not by instance.

[18:21] *** rcsheets` joined
[18:23] *** paroxyzm left
[18:23] <TimToady> you probably need to get the opinion of one of the other folks who have worked with Responder Interfaces, like ruoso++ or nothingmuch++

[18:23] <jnthn> Aye

[18:24] <TimToady> possibly Dog with an alternative RI is just a different type somehow that doesn't pessimize what Dog is by default

[18:24] *** rcsheets` left
[18:24] <TimToady> using a different RI might just be a matter of mixing in a different .HOW

[18:25] <TimToady> but I'm not the expert on anything hiding behind .HOW

[18:25] * TimToady has no knowhow

[18:25] <jnthn> :-)

[18:26] <jnthn> My problem isn't the existence of different representations.

[18:27] <jnthn> It's more that not being able to know by type what representation I have.

[18:28] <jnthn> The end result being that either everything is pessimal (too slow) or everything but P6opaque and a bunch of RIs for e.g. int, num etc are pessimal.

[18:29] <jnthn> Which is OK for now but sucks for the guy who implements another REPR some day and then finds that the mechanism that is used to make P6opaque fast is useless.

[18:29] <jnthn> (e.g. useless for his representation)

[18:30] <TimToady> well, people who invent reprs had better know how to make them fast them own selves

[18:30] <jnthn> Part of it is a code-gen thing though

[18:30] <TimToady> I don't see how you can borrow much from something called "opaque"

[18:31] <TimToady> it's opaque so we can cheat

[18:31] <TimToady> if someone looks inside, they'll discover we're cheating :)

[18:32] <TimToady> but there might be some value in declaring a default repr for a class

[18:32] <TimToady> and we can even say "you can't override it" for now

[18:33] <jnthn> Imagine we're code-generating an attribute lookup. We're in a single inheritance situation, so in theory we can do all attribute lookups by an offset into the object - eg. fast fast fast. We'd really like at compile time to go and say to the REPR "OK, I'm emitting a look for $!foo in class Bar, please give me a 'hint' that I can also emit in the code, if possible, and I'll give that back to you when we try and retreive the attribute at runtime"

[18:33] <jnthn> Now, in an MI situation or we get augmenting going on and so on, it'll come back and say "sorry dave, I can't do that"

[18:34] <jnthn> But in situations where it's possible, the REPR could give back something interesting.

[18:35] <jnthn> If we can't make some assumption about the underlying REPR from the type object, then we either (a) can't do these things or (b) have to tag every hint with "oh and I got the hint from this REPR and if that ain't you, you'd best ignore it and just use the names"

[18:36] <jnthn> Taht is, we can lazily pessimize, but it seems like it'll cost us a little to have the ability to do so.

[18:36] <TimToady> such a type is, in essence, a native type in the sense that the repr is closed, though the class could add methods

[18:37] <TimToady> and non-final, in that you can add more offsets under SI

[18:37] *** timbunce left
[18:37] <TimToady> rather than lazily pessimizing, I'd rather take the sum of what we know at CHECK time to know which reprs we can lock down

[18:37] <jnthn> My point is that

[18:38] <jnthn> sub foo(Dog $x) { ... }

[18:38] <jnthn> The type constraint Dog isn't a constraint on the REPR that could be passed in

[18:38] <jnthn> Unless we associate a single REPR with a type.

[18:39] <TimToady> I think we should drive the repr choice to be just sufficiently declarative to know whether we can optimize at CHECK time

[18:39] <jnthn> OK

[18:39] <TimToady> much like most of our other optimizations that you can choose to pessimize if you declare you want to

[18:39] <TimToady> class Dog is repr(*) or some such

[18:40] <TimToady> otherwise default is repr(P6opaque)

[18:40] <TimToady> would that be good enough?

[18:40] <tylercurtis> rakudo: subset Odd of Int where * % 2; my Odd $i = 6; say 'Shouldn't happen.'

[18:40] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Confused at line 20, near "say 'Shoul"␤»

[18:40] <jnthn> TimToady: Yes :-)

[18:40] <tylercurtis> rakudo: subset Odd of Int where * % 2; my Odd $i = 6; say 'Shouldn\'t happen.'

[18:40] *** timbunce joined
[18:40] <jnthn> TimToady: Thanks. :-)

[18:40] <p6eval> rakudo 692aa1:  ( no output )

[18:41] <TimToady> and .bless(:repr) is illegal unless declared is repr(*)

[18:41] <jnthn> :-)

[18:41] <jnthn> Excellent, that helps a lot.

[18:41] <TimToady> we aim to blaze

[18:41] <jnthn> Yes, I've been spending a lot of time recently thinking about that.

[18:42] * jnthn decides to switch focus on enjoying the world cup match for a bit :-)

[18:42] <TimToady> "we aim to breeze" would rhyme better

[18:45] <lue> rakudo: role Thing { ... }; role Stuff does Thing { method a { say 'a' } }; role Thing does Stuff { method b { say 'b' } }; Thing.a

[18:45] <p6eval> rakudo 692aa1:  ( no output )

[18:46] <TimToady> .new maybe?

[18:47] <lue> well, the error is actually maximum recursion depth exceeded :)

[18:47] <lue> rakudo: role Thing { ... }; role Stuff does Thing { method a { say 'a' } }; role Thing does Stuff { method b { say 'b' } }; Thing.new.a

[18:47] <p6eval> rakudo 692aa1:  ( no output )

[18:49] <lue> I'm surprised it doesn't error when A does B and B does A. It's only when I start trying to use it.

[18:49] <TimToady> it wouldn't compose until .new forces it to compose a class, I imagine

[18:50] <lue> It could be a wonderful collage of evil if it worked, though :)

[18:50] <TimToady> and roles ignore up doeses

[18:50] <TimToady> s/up/dup

[18:51] <TimToady> a 'does' on a role merely says, "Be sure you invite my friends along too."

[18:52] <tylercurtis> rakudo: role Thing { ... }; role Stuff does Thing { method a { say 'a' } }; role Thing does Stuff { method b { say 'b' } }; class ActualThing does Stuff { }; ActualThing.new.a

[18:52] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤maximum recursion depth exceeded␤»

[18:53] <TimToady> well, perhaps that's not how rakudo does it :)

[18:53] <TimToady> jnthn: ^^

[18:54] <lue> that's the first time an error came up in p6eval today! \o/

[18:55] <pmichaud> good morning, #perl6

[18:55] <lue> (maybe 'does' should be smart enough not to invite itself)

[18:55] <lue> guten tag, pmichaud o/

[18:55] <pmichaud> http://picasaweb.google.com/lh/photo/XQe716XBkmKHt1vsH8JKaw?feat=directlink  # view from my balcony :-)

[18:57] *** hercynium joined
[18:57] <lue> ooh! aah!

[18:57] <lue> [ I like the part Picasa put under the picture: "Sign in to like this photo" :) ]

[19:00] <lue> the first P6 pun ever:    m/smart/  # well, the core of the pun, anyway

[19:00] <TimToady> is that Maui I see?

[19:01] <pmichaud> It is Maui, yes.  :-)

[19:02] <TimToady> every island smells a little different

[19:04] <pmichaud> my son says it smells like popcorn here

[19:04] <TimToady> the big island usually smells of sulfur  :)

[19:05] *** cono joined
[19:08] *** aubreyja_ joined
[19:09] <sorear> good * #perl6

[19:09] <pmurias> hi

[19:10] <pmurias> moritz_: could you nopaste ~/.cpanm/build.log?

[19:14] *** aubreyja_ left
[19:17] *** ashleydev left
[19:19] <sorear> jnthn: talk to me about reprs

[19:24] <sorear> jnthn: 'Dog' looks like a class but it's really treated as a role

[19:25] <sorear> so what I'm planning to do for the general case is to pass a Dog-vtable

[19:25] <sorear> with functions for calling all Dog methods, and indexes for all Dog slots

[19:25] <sorear> or rather, accessors

[19:26] *** aubreyja joined
[19:26] <sorear> also, I'm going to extend the Dog|U notation

[19:27] <sorear> Dog|U - protoobject repr

[19:27] <sorear> Dog|D - standard object repr

[19:27] <sorear> Dog|<name> - named repr

[19:27] <sorear> the autospecializer will, among other things, generate |D forms of methods

[19:32] *** mtk joined
[19:46] <lue> afk

[19:48] *** kensanata joined
[19:48] *** eternaleye joined
[20:01] <cognominal> what is the way to ask a parametric rôle that the parameter  C<does> some other role?   

[20:01] <cognominal> role MyRole[T does U]   # something like that

[20:05] <cognominal> I think that Range should be    something like   role Range[T does TotalOrder] { ... } ;      role TotalOrder[U] {    method succ() --> U  {  ...  }  ...  }

[20:10] *** masak joined
[20:10] <masak> ahoy!

[20:10] <phenny> masak: 15:31Z <moritz_> tell masak that I've pushed some fairly substantial changes to SVG, making it use methods internally instead of subs. My plan would be to rename it to XML::Writer or so, and then start a new SVG.pm, which automatically promotes some attributes into :style<...>, and optionally adds an SVG header

[20:11] * masak renames it now, lest he forget

[20:12] <tylercurtis> masak: Bennu is about to have an actual runtime that makes the build process even more hellish. :)

[20:12] <tylercurtis> yapsi: my $a; say $a;

[20:13] <p6eval> yapsi: OUTPUT«Any()␤»

[20:13] <tylercurtis> On the plus side, that will soon work. :)

[20:13] <masak> I feel I lack context. what/who's Bennu?

[20:14] <masak> and which hellish build process are we talking about?

[20:14] *** Trashlord joined
[20:15] <masak> moritz_: ping

[20:17] <tylercurtis> masak: My very early-stage Perl 6 to LLVM compiler that uses SIC. The build process of compiling code using it.

[20:17] <masak> oh, right!

[20:17] <masak> sorry, I forgot its name.

[20:17] <masak> tylercurtis: you should add it to the poc-projects.list file in the pls branch of proto.

[20:18] *** mtk left
[20:18] *** jferrero joined
[20:19] *** mtk joined
[20:20] <tylercurtis> Now, not only do you need yapsi, old rakudo, recent rakudo, and LLVM, you also need GNU libtool at /usr/local/bin/libtool(because I was too lazy to deal with the problem of OS X's libtool at /usr/bin(which is earlier in my path) being weird). :)

[20:20] <tylercurtis> masak: Will do, once I finish pushing these changes.

[20:21] <masak> \o/

[20:21] *** mtk is now known as mtk_

[20:21] <masak> exciting times. I never dreamed of SIC compiling to LLVM.

[20:21] *** mtk_ is now known as mtk

[20:22] <moritz_> masak: pong

[20:23] <masak> moritz_: since I pinged, I concluded that the reason ufo wasn't working was because I broke it. nevermind. :)

[20:23] <masak> it's fixed now.

[20:23] <moritz_> speaking of exciting times

[20:23] <moritz_> Germany 3 -- 2 Urugay

[20:23] <masak> congratulations.

[20:24] <masak> football, right? :P

[20:24] <moritz_> right :-)

[20:24] * masak .oO( nailed it )

[20:25] *** kfo joined
[20:25] *** jferrero left
[20:27] <jnthn> cognominal: role MyRole[::T where U] { ... } probably works

[20:28] <moritz_> pmurias: ah, found the problem: CHI won't install

[20:28] <moritz_> Couldn't load class (CHI::Driver) because: Invalid version format (dotted-decimal versions require at least three parts) at /usr/lib/perl/5.10/version.pm line 194.

[20:29] <jnthn> TimToady: Well, thing is that in role R1 { method m { } }; role R2 { method m { } }; role R3 does R1 does R2 { method m { } }, iiuc we'd like that to eliminate the methods from R1 and R2.

[20:30] <jnthn> So it's not just as simple as a completely flat "and add these too" if we wnat this to work.

[20:30] <jnthn> If that can fail and we get a conflict when we compose R3 into a class, well, fine, but I suspect that's not what's wanted.

[20:30] <jnthn> pmichaud: Nice photo!

[20:31] *** aubreyja left
[20:31] <masak> moritz_: I don't like BEGIN { @*INC.push: 'lib', '../lib' };

[20:31] <masak> moritz_: and with ufo, it's not needed.

[20:31] <moritz_> masak: feel free to remove

[20:31] * masak removes

[20:32] *** ashleydev joined
[20:32] <moritz_> CHI versions 0.34 and 0.35 fail with the same error message

[20:33] <tylercurtis> masak: would you prefer a pull request or a patch?

[20:33] <masak> tylercurtis: you're saying you don't have commit access?

[20:33] <masak> :)

[20:34] <moritz_> this feels like it could be easy to fix...

[20:34] <masak> tylercurtis: what's your name on github?

[20:34] <tylercurtis> masak: ekiru

[20:34] <masak> tylercurtis: welcome aboard.

[20:35] <masak> tylercurtis: just push to poc-projects.list on the pls branch.

[20:36] <tylercurtis> masak: done.

[20:36] <masak> tylercurtis: ...and you got the comma on the line before. :) tylercurtis++

[20:36] <masak> json--

[20:40] <masak> moritz_: rename complete.

[20:41] <tylercurtis> masak: Does JSON support an extra comma?

[20:41] <moritz_> no :(

[20:41] <masak> hence the --

[20:41] <masak> moritz_: could you also add yourself to AUTHORS in xml-writer?

[20:41] <moritz_> javascript does, but a brain-dead browser does not

[20:42] <moritz_> masak: yes... and rename it in hugme 

[20:42] <moritz_> wait, the other way round :-)

[20:42] <masak> ...and change the url in .git/config :)

[20:42] <moritz_> currently I don't have commit access

[20:42] <masak> oh?

[20:42] * moritz_ stupid

[20:42] <moritz_> ignore me

[20:43] * masak does so

[20:43] <moritz_>  lib/XML/Writer.pir            | 2123 +++++++++++++++++++++++++++++++++++++++++

[20:43] <moritz_> doen't look like you need to ship it

[20:44] <lue> ohai o/

[20:44] <moritz_> oh, svg wasn't on hugme

[20:45] * masak kills off the .pir file

[20:45] * moritz_ faster

[20:45] <masak> :)

[20:45] <masak> indeed.

[20:46] <lue> rakudo: my $a = Buf.new('N', 'E', 'S', 0x1A); say $a

[20:46] <p6eval> rakudo 692aa1:  ( no output )

[20:46] <masak> lue: Buf.new takes a list of integers.

[20:47] <masak> actually, right now it takes an array of integers.

[20:47] <masak> that's likely to change.

[20:47] <tylercurtis> rakudo: my $a = Buf.new([1,2,3,4,5]); say $a

[20:47] <p6eval> rakudo 692aa1:  ( no output )

[20:48] <moritz_> rakudo: $*OUT.write:  Buf.new([:16<6d>, :16<c3>, :16<70>])

[20:48] <masak> tylercurtis: locally, that says "Buf()<0x10c9161e0>"

[20:48] <p6eval> rakudo 692aa1:  ( no output )

[20:48] <jnthn> masak: Oh?

[20:48] <jnthn> masak: Relying on slurpy laziness in Buf?

[20:49] <masak> jnthn: yes. pmichaud suggested it should be like it was from the beginning.

[20:49] <masak> jnthn: hold on, I'll dig up the blog post.

[20:49] <masak> jnthn: http://use.perl.org/~masak/journal/40422

[20:49] <masak> last paragraph.

[20:50] <moritz_> masak: I think allowing named arguments to XML::Writer.serialize was a bad idea

[20:50] <jnthn> oh

[20:50] <masak> moritz_: ok.

[20:50] <jnthn> Well consistency is a good point, but my point was also good. :-)

[20:50] <moritz_> masak: because now I want to subclass it, and find myself duplicating the arugment extraction logic

[20:50] <jnthn> masak: Maybe you want an alternative constructor.

[20:51] <masak> jnthn: pmichaud had a counter-point against yours. do read the logs.

[20:51] *** patspam left
[20:52] <masak> moritz_: sometimes I feel the whole way named arguments and pairs rub against each other is "wrong". but it's been a long time now since I wrote code that made me feel that.

[20:52] <jnthn> masak: OK, iirc, in encode you get a byte-buffer?

[20:52] <masak> yes.

[20:53] <jnthn> oh wtf

[20:53] <jnthn> you're not doing at all what I thought

[20:53] <masak> get a fresh bytebuffer, assign the string to it, and iterate over its bytes.

[20:53] <jnthn> OK

[20:53] <jnthn> ...yes, that's exactly what I wanted us to avoid.

[20:53] <masak> ok.

[20:54] <masak> I haven't realized that till now.

[20:54] <jnthn> ByteBuffer is capable of being index into positionally and keeps a reference to the original string.

[20:54] <jnthn> Meaning that .encode doesn't allocate a load of new storage

[20:54] <jnthn> If the Buf just references a ByteBuffer

[20:54] <jnthn> Yes that's not the _only_ case.

[20:55] <masak> hm, that is indeed nicer.

[20:55] <jnthn> But I'd have thought it was a common enough one to make sure we avoid copying.

[20:55] <masak> but it'll cease to work as soon as the Buf is treated as an array.

[20:55] <masak> yes, I agree that it's a common case, and worth optimizing for.

[20:55] <jnthn> Oh

[20:56] <jnthn> has T @.contents;

[20:56] <jnthn> Hmm

[20:56] <jnthn> Ok, leave it as it is for now I guess

[20:56] <jnthn> This is going to be hard to get right until we have compact arrays.

[20:56] <jnthn> Or hard to get right and efficient.

[20:56] <jnthn> And working trumps fast and wrong.

[20:57] <jnthn> But just a heads up that we should re-visit this in the future to avoid so much copying.

[20:57] <jnthn> (Looking at it more, it's not quite trivial.)

[20:58] <masak> aye.

[20:58] <jnthn> our multi sub infix:<eqv>(Buf $a, Buf $b) { return $a.contents ~~ $b.contents;

[20:58] <jnthn> }

[20:59] <jnthn> Naybe use eqv in there?

[20:59] <masak> does it matter?

[20:59] <moritz_> seems more robust with eqv

[20:59] <masak> oki, changing.

[20:59] <moritz_> if you have a Buf[Any], and one of the entries is a *

[20:59] *** kensanata left
[20:59] <jnthn> moritz_: Right.

[20:59] <masak> good point.

[21:01] *** dju joined
[21:02] *** timbunce left
[21:02] <lue> rakudo: my $a = Buf.new([0x4E, 0x45, 0x53]); say $a.decode

[21:03] <p6eval> rakudo 692aa1:  ( no output )

[21:03] *** dju left
[21:03] *** dju joined
[21:03] <lue> > my $a = Buf.new([0x4E, 0x45, 0x53]); say $a.decode

[21:03] <lue> NES

[21:06] <masak> \o/

[21:06] <masak> that's about what the tests do, too.

[21:07] <masak> jnthn: did you find pmichaud's objection that speed might not be an issue after all for slurpies?

[21:08] *** timbunce joined
[21:11] <moritz_> http://github.com/moritz/svg

[21:11] <dalek> rakudo: 7579f7a | masak++ | src/core/Buf.pm:

[21:11] <dalek> rakudo: [Buf] infix:<eqv> for Bufs now uses eqv internally

[21:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7579f7a069eaf2c2a34b425c058fea26ab3cbff0

[21:14] <jnthn> masak: In the long run maybe it won't be

[21:14] <jnthn> The trouble is that | is not always too smart at the moment.

[21:14] <jnthn> But if you avoid that you're fine.

[21:15] <masak> I see two use cases.

[21:15] <masak> Buf.new(byte, byte, byte)

[21:15] <masak> and Str.encode($encoding)

[21:16] *** whiteknight joined
[21:16] <masak> the latter might have to use | if we only allow the slurpy constructor.

[21:16] *** tadzik joined
[21:16] <moritz_> why not allow both constructrs, as multis?

[21:16] <masak> moritz_: that's a possibility.

[21:17] <masak> moritz_: it falls, I believe, under pmichaud's "API based on Rakudo's current characteristics"

[21:17] <masak> which may or may not be considered a disadvantage.

[21:17] <jnthn> masak: But if you have a slurpy constructor and you pass an array, it'll get flattened into the slurpy

[21:17] <masak> oh.

[21:18] <masak> even if you provide both, as moritz_ suggests?

[21:18] <jnthn> rakudo: sub foo(*@x) { say @x.elems }; my @a = 1,2,3; foo(@a);

[21:18] <p6eval> rakudo 692aa1: OUTPUT«3␤»

[21:18] <moritz_> rakudo: multi f(@a) { }; multi f(*@a) { }; f(my @a = (1, 2, 3))

[21:18] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Redeclaration of symbol @a at line 20, near " = (1, 2, "␤»

[21:18] <jnthn> huh

[21:18] <moritz_> doesn't look like a redeclaration to me

[21:18] <moritz_> rakudo: multi f(@a) { }; multi f(*@a) { }; f(my @x = (1, 2, 3))

[21:19] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Redeclaration of symbol @x at line 20, near " = (1, 2, "␤»

[21:19] <moritz_> rakudo: multi f(@a) { }; multi f(*@a) { }; my @x = (1, 2, 3); f(@x)

[21:19] <p6eval> rakudo 692aa1:  ( no output )

[21:19] <jnthn> moritz_: You could do that

[21:19] <jnthn> er

[21:19] <ingy> greetings

[21:19] <jnthn> masak ^^

[21:19] <jnthn> masak: But just the slurpy one and don't | the thing going in should be efficient today

[21:20] <jnthn> o/ ingy

[21:20] <ingy> \o jnthn 

[21:20] <masak> moritz_: rakudobug?

[21:21] <moritz_> masak: yes

[21:21] <masak> jnthn: then it sounds to me I should change back to the just the slurpy.

[21:21] * masak submits rakudobug

[21:22] <jnthn> masak: Aye

[21:22] <jnthn> masak: For consistency too

[21:23] <jnthn> masak: We can optimize further later.

[21:23] * jnthn afk for a bit

[21:23] *** araujo joined
[21:24] *** araujo left
[21:24] *** araujo joined
[21:24] <sorear> When do the executable statements in the body of a class { } run?

[21:24] * moritz_ is pretty sure that's in S12 somewhere

[21:24] <lue> any reason why Buf -> Str is decode(), and Str -> Buf is encode()? That seems backwards to me [ not that it matters at all, just wondering ]

[21:25] <masak> rakudo: multi f(@a) { }; multi f(*@a) { }; my @x; f(@x = (1, 2, 3))

[21:25] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[21:25] <masak> o.O

[21:25] <moritz_> rakudo: multi f(@a) { };  my @x; f(@x = (1, 2, 3))

[21:26] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20␤»

[21:26] <moritz_> std: multi f(@a) { };  my @x; f(@x = (1, 2, 3))

[21:26] <p6eval> std 31614: OUTPUT«ok 00:01 117m␤»

[21:26] <masak> rakudo: multi f(*@a) { }; f(my @x = (1, 2, 3))

[21:26] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Redeclaration of symbol @x at line 20, near " = (1, 2, "␤»

[21:26] <masak> rakudo: multi f(@a) { }; f(my @x = (1, 2, 3))

[21:26] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Redeclaration of symbol @x at line 20, near " = (1, 2, "␤»

[21:26] *** whiteknight left
[21:27] *** takadonet joined
[21:27] <takadonet> hey everyone

[21:27] <moritz_> o/

[21:27] <moritz_> rakudo: f(my @x = (1, 2, 3))

[21:27] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Redeclaration of symbol @x at line 20, near " = (1, 2, "␤»

[21:27] <moritz_> rakudo: f(my @x)

[21:27] <p6eval> rakudo 692aa1: OUTPUT«Could not find sub &f␤  in main program body at line 20:/tmp/Z7mIzm_qJb␤»

[21:29] <masak> moritz_++

[21:29] <masak> so it has nothing to do with multis, only with the assignment in the argument list.

[21:30] <masak> rakudo: f(my $x = (1, 2, 3))

[21:30] <p6eval> rakudo 692aa1: OUTPUT«Could not find sub &f␤  in main program body at line 20:/tmp/mFoG7yiTUW␤»

[21:30] <moritz_> list assignment :-)

[21:30] <masak> rakudo: f(my %x = (1, 2, 3))

[21:30] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Redeclaration of symbol %x at line 20, near " = (1, 2, "␤»

[21:30] <takadonet> for loop are not lazy yet correct?

[21:31] <takadonet> in conjunction with a gather/take

[21:31] <moritz_> they are, to some extend

[21:31] <moritz_> rakudo: for 1..* {.say; last }

[21:31] <takadonet> i.e: my @matches = gather for $/<fasta> -> $m {take $m.ast;}

[21:31] <p6eval> rakudo 692aa1: OUTPUT«1␤»

[21:32] *** silug left
[21:32] <takadonet> could be something else then that is making it eager

[21:32] <moritz_> takadonet: that' easier written as my @matches = $<fasta>.map: { *.ast }

[21:32] <moritz_> takadonet: and do use a current development version of rakudo - in the last release, array assignment was still eager

[21:34] <takadonet> moritz_: I'm always using the newest development version!  :)

[21:34] <moritz_> takadonet: great :-)

[21:35] <takadonet> moritz_: code fails if I changed to using a map :(

[21:36] <moritz_> weird

[21:37] <takadonet> Really could be the way I written it

[21:41] *** whiteknight joined
[21:42] * masak goes home to sleep

[21:42] <masak> thought I would get some Yapsi runtime hacking done today, but there wasn't enough consequtive thinking time.

[21:42] <masak> ah well, maybe tomorrow.

[21:42] <masak> 'night.

[21:42] <lue> goodnight masak o/

[21:42] *** masak left
[21:46] <pmurias> moritz_: the CHI dependency is not esential

[21:46] <lue> rakudo: role B { has $.var = 3 }; class A does B { method z { say $.var;} }; A.z

[21:46] *** kloeri left
[21:46] <p6eval> rakudo 692aa1:  ( no output )

[21:47] <sorear> lue: a byte sequence for text is useless except to store and transmit, so we call it encoded

[21:47] <sorear> decoding the bytes produces characters, which can be processed in many more ways

[21:47] *** kloeri joined
[21:48] <pmurias> moritz_: any other solutions forthe CHI problem other than making Mildew stop using it?

[21:48] <lue> ah, ok.

[21:48] <sorear> CHI?

[21:49] <pmurias> sorear: i use it for caching the parse

[21:50] <pmurias> sorear: it's a CPAN module

[21:51] <pmurias> moritz_: if you comment the dependency out in dist.ini mildew will work just fine (with the default frontend)

[21:52] *** mtk left
[21:52] *** kloeri left
[21:54] <lue> for    class A does B    why can I not access variables in B through A?

[21:54] <lue> (or, more accurately, attributes)

[21:56] *** takadonet left
[21:56] <tylercurtis> rakudo: role B { has $.foo is rw; }; class A does B {}; my $a = A.new; A.foo = 'foo'; A.foo.say;

[21:56] <p6eval> rakudo 692aa1: OUTPUT«Type objects are abstract and have no attributes, but you tried to access $!foo␤  in main program body at line 70␤»

[21:57] <tylercurtis> rakudo: role B { has $.foo is rw; }; class A does B {}; my $a = A.new; $a.WHAT.say; $a.defined.say;

[21:57] <p6eval> rakudo 692aa1: OUTPUT«A()␤1␤»

[21:58] <tylercurtis> Hmm... I don't know.

[21:58] <lue> rakudo: role B { has $.foo is rw = 3; }; class A does B { method z { say $.foo } }; A.z

[21:58] <p6eval> rakudo 692aa1:  ( no output )

[21:59] *** kloeri joined
[22:03] *** hsb joined
[22:04] <lue> rakudo: role B { has $.foo is rw = 3; }; class A does B { method z { say B.foo } }; A.z

[22:04] <p6eval> rakudo 692aa1:  ( no output )

[22:09] <lue> can Someone Who Knows Why™ explain why I'm not allowed to access B's attributes in A?

[22:09] <nothingmuch> Q/sb end

[22:10] <jnthn> lue: you can if you use the right syntax ;-)

[22:11] <lue> I just found it.

[22:11] <jnthn> lue: When you compose a role into a class, the attrs are just as if you had declared them in the class

[22:11] <jnthn> So you can see $.foo in the method in the class too :-)

[22:11] <jnthn> s/see/use/

[22:11] <lue> rakudo: role B { has $.foo is rw = 3; }; class A does B { has B $.foo; method z { say $.foo } }; A.z

[22:11] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Attribute '$!foo' already exists in the class, but a role also wishes to compose it␤»

[22:11] <tylercurtis> rakudo: role B { has $.foo is rw; }; class A does B {}; my $a = A.new; A.foo = 'foo'; A$a.foo.say;

[22:11] <p6eval> rakudo 692aa1: OUTPUT«===SORRY!===␤Confused at line 20, near "A$a.foo.sa"␤»

[22:12] <tylercurtis> rakudo: role B { has $.foo is rw; }; class A does B {}; my $a = A.new; $a.foo = 'foo'; $a.foo.say;

[22:12] <lue> ...or not

[22:12] <p6eval> rakudo 692aa1: OUTPUT«foo␤»

[22:12] <jnthn> lue: You re-declared it

[22:12] <jnthn> See what tylercurtis++ did :-)

[22:13] <lue> ah. What I want to do is write methods in class A that mess with attributes in role B, but I can't seem to do that.

[22:13] <jnthn> Sure you can

[22:14] <jnthn> lue: The thing is that by composing a role the attributes are in your class now

[22:14] <jnthn> lue: Thing of role composition like copying stuff from the role into your class.

[22:14] <jnthn> *Think

[22:14] <tylercurtis> rakudo: role B {has $.foo is rw; }; class A does B { method double_foo { $.foo *= 2; } }; my $a = A.new(:foo(5)); $a.foo.say; $a.double_foo; $a.foo.say;

[22:14] <p6eval> rakudo 692aa1: OUTPUT«5␤10␤»

[22:15] <lue> rakudo: role B { has $.foo = 3 }; class A does B { method zi { say $.foo } }; A.zi

[22:15] <p6eval> rakudo 692aa1:  ( no output )

[22:16] <jnthn> A.new.zi

[22:16] <jnthn> Otherwise the class has no instance attributes :-)

[22:16] <jnthn> rakudo: role B { has $.foo = 3 }; class A does B { method zi { say $.foo } }; A.new.zi

[22:16] <p6eval> rakudo 692aa1: OUTPUT«3␤»

[22:16] <lue> OK. What was messing me up was bad coding then :)

[22:18] *** kloeri left
[22:18] <lue> .oO(probably the closest thing to a jumptable in P6 is given/when (unless there's magic I'm not aware of)...)

[22:19] *** mtk joined
[22:21] *** Sanitoeter joined
[22:25] *** tadzik left
[22:30] *** kloeri_ joined
[22:37] <TimToady> given/when is designed to be optimizable to a jumptable if you have well-behaved values in the when bits

[22:37] *** rv2733 left
[22:37] <TimToady> that was the big reason for changing ~~ from symmetrical to asymmetrical

[22:38] <lue> I'll only need 256 when's, from 0 to 0xFF :)

[22:39] <TimToady> otoh, you can also use an array of functions

[22:39] <lue> rakudo: sub A { say 'a' }; sub B { say 'b' }; my @a = A(), B(); @a[1]

[22:39] <p6eval> rakudo 692aa1: OUTPUT«a␤b␤»

[22:39] <TimToady> I doubt anyone is going to do the jumptable optimization any time soon, since (afaik) it was *never* done in Perl 5 (unlike Perl 4)

[22:40] <TimToady> but maybe it'll be easier in 6

[22:40] <lue> I gave up Python whilst coding my NES emulator because I got to the opcodes and found Python doesn't come with switch statements.

[22:40] <TimToady> since it's just a matter of running down the statements and seeing if they're all integer whens, or string whens

[22:41] <lue> .oO(255 elseif's... *shudder*)

[22:41] <TimToady> in other words, Python's only way to do it didn't line up with your only way to do it.  :)

[22:42] <TimToady> presumably P6 can also do it with multi opcode (42) {...}

[22:45] *** mtk left
[22:45] *** timbunce left
[22:46] <lue> I grappled between P5 and 6 for an afternoon, looking for something better, and I went with 6 because the -> (as opposed to .) confused me greatly. The End :)

[22:47] <sorear> moritz_: do you know who changed p6eval to suppress error messages and why?

[22:48] <lue> I should do multi opcode. It's extermely lazy! (after coding 256 opcode() methods, of course) \o/

[22:48] <jnthn> lue: Nah, pre-deref'd interpreter ftw. :-)

[22:48] <jnthn> (you take the array of instructions and build an array of sub references, then just go through that array).

[22:49] <lue> rakudo: multi method op(1) { say 'do' }; multi method op(2) { say 're' }; my $a = 2; op($a)

[22:49] <p6eval> rakudo 692aa1: OUTPUT«Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespace␤Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespace␤Could not find sub &op␤  in main program body at line

[22:49] <p6eval> ..20:/tmp/85…

[22:49] <lue> rakudo: multi sub op(1) { say 'do' }; multi sub op(2) { say 're' }; my $a = 2; op($a)

[22:50] <p6eval> rakudo 7579f7: OUTPUT«re␤»

[22:50] <jnthn> :-)

[22:50] <jnthn> lue: also multi op(1) { say 'do' }

[22:50] <jnthn> lue: multi name is just like multi sub name

[22:50] <jnthn> but shorter

[22:50] <jnthn> :-)

[22:50] <lue> I'm glad I dumped Python! \o\ /o/

[22:51] <lue> rakudo  $satisfiedcustomer++

[22:51] <jnthn> Yay, I has @nice-hotel booked for $vacation :-)

[22:52] <jnthn> Which ain't for a month and a half. Eh well.

[22:52] <lue> how great is @_ ?

[22:54] <jnthn> @_ ?

[22:54] *** azert0x left
[22:54] <tylercurtis> rakudo: say TimeMachine.new.travel(Date.today + 45).find(:person<jnthn>).WHERE

[22:55] <p6eval> rakudo 7579f7: OUTPUT«Could not find sub &TimeMachine␤  in main program body at line 20:/tmp/v3NsTvtXeF␤»

[22:55] <lue> rakudo: enum Vacancy <Vacant Booked>; my @nice-hotel; @nice-hotel[208] = Booked; # hotel management made esay by P6!

[22:55] <p6eval> rakudo 7579f7:  ( no output )

[22:55] <lue> s/esay/easy/

[22:56] <lue> rakudo: use TARDIS :ver<40TT>; # please oh please oh please...

[22:56] <p6eval> rakudo 7579f7: OUTPUT«===SORRY!===␤Unable to find module 'TARDIS' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval//p2/lib/parrot/2.5.0-devel/languages/perl6/lib␤  .)␤»

[22:57] <tylercurtis> lue: http://github.com/masak/tardis someday.

[22:58] <jnthn> tylercurtis: <Germany Austria Slovenia>.any :-)

[22:58] <arnsholt> std: given 5 -> $x { ... }

[22:58] <p6eval> std 31614: OUTPUT«ok 00:01 113m␤»

[22:59] * arnsholt rereads S04

[22:59] <tylercurtis> rakudo: given 5-> $x { say $x }

[22:59] <sorear> lue: yer syntax is wrong anyway

[22:59] <p6eval> rakudo 7579f7: OUTPUT«===SORRY!===␤Unsupported use of -> as postfix; in Perl 6 please use either . to call a method, or whitespace to delimit a pointy block at line 20, near " $x { say "␤»

[23:00] <tylercurtis> rakudo: given 5 -> $x { say $x }

[23:00] <p6eval> rakudo 7579f7: OUTPUT«5␤»

[23:00] <arnsholt> rakudo: given 5 -> $x { when 5 { say "da" } }

[23:00] <lue> tylercurtis: that's a time-travelling debugger.

[23:00] <p6eval> rakudo 7579f7: OUTPUT«Use of uninitialized value in numeric context␤»

[23:00] <lue> (That reminds me, I need to finish my Time Traveller's Tense Handbook, so tardis can speak properly)

[23:00] <arnsholt> Wha'?

[23:01] <jnthn> arnsholt: Well, you bound it to $x rather than the defualt $_, and when goes looking at $_. :P

[23:01] <arnsholt> Oh, probably due to $_ being undef

[23:01] <arnsholt> Yeah, what you said ^^

[23:01] <tylercurtis> lue: Do you have a tardis of your own you're working on?

[23:01] <jnthn> I *think* Rakudo isn't meant to go binding it to both.

[23:02] <lue> not yet, I was referring to masak's.

[23:02] <arnsholt> As far as I can make from S04 an pblock with given doesn't make a lot of sense, but STD appears to disagree

[23:03] <lue> [you're welcome to give me a fully-equipped genetics labratory though. Then I can start on my TARDIS :)]

[23:08] *** mtk0 joined
[23:10] * sorear sighs.

[23:14] *** rokoteko joined
[23:17] *** mtk0 left
[23:18] *** mtk0 joined
[23:18] *** mtk0 left
[23:18] *** pmurias left
[23:19] *** mtk joined
[23:25] *** kloeri_ is now known as kloeri

[23:32] <arnsholt> I'm thinking of having a whack at giving NQP given/when

[23:32] <arnsholt> But before I get too deep into this, does anyone in the know know if this likely to be a desired feature?

[23:33] * tylercurtis would use it.

[23:33] <arnsholt> Good that I'm not the only one, at least =)

[23:37] <sorear> probably it would be best to implement it semi-syntactically

[23:37] <arnsholt> What do you mean?

[23:37] <sorear> pmichaud wouldn't like adding ACCEPTS to Integer, so when 42 { should desugar to $_ == 42, not 42.ACCEPTS($_)

[23:38] <arnsholt> Ah, right

[23:38] <arnsholt> NQP has ~~ though, so as a first approximation I think it should work

[23:52] <sorear> I can't find anything in S12 or the S12 tests on when class Foo { say "hi" } prints

[23:53] *** masonkramer joined
[23:53] <sorear> BEGIN, ENTER, and DO are the main contenders in my mind

[23:55] *** Psyche^ joined
[23:58] *** envi^home joined
[23:59] *** Psyche^ is now known as Patterner

