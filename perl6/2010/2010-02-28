[00:00] *** mikehh joined
[00:01] *** snarkyboojum joined
[00:01] <lue> s.b.: o/

[00:02] <masak> snarkyboojum: oh hai!

[00:02] <snarkyboojum> masak: ello

[00:04] <masak> rakudo: my $a = $a++; say $a

[00:04] <p6eval> rakudo f960a2: OUTPUT«Any()␤»

[00:04] <jnthn> rakudo: my $a = ++$a; say $a

[00:04] <p6eval> rakudo f960a2: OUTPUT«1␤»

[00:04] <jnthn> rakudo++ :-)

[00:05] <masak> yup.

[00:05] <masak> rakudo: my Int $a = $a++; say $a

[00:05] <p6eval> rakudo f960a2: OUTPUT«Int()␤»

[00:05] <masak> rakudo: my Int $a = $a++; say +$a

[00:05] <p6eval> rakudo f960a2: OUTPUT«Use of type object as value␤current instr.: 'perl6;Perl6Exception;throw' pc 14251 (src/builtins/Seq.pir:52)␤»

[00:05] <masak> hm.

[00:07] <jnthn> Don't *think* I disagree with that too much.

[00:07] <jnthn> Maybe just warn rather than die.

[00:07] <jnthn> But it at least tells you what you did.

[00:07] <masak> indeed.

[00:08] <masak> just thinking that it's quite obvious that the Int type object would numify to 0.

[00:08] <jnthn> :-/

[00:08] <jnthn> alpha: say +Int

[00:08] <p6eval> alpha 30e0ed: OUTPUT«Use of type object as value␤0␤»

[00:09] <ruz> rakudo: grammar I { rule k { 'k' }; rule v { 'v' } }

[00:09] <p6eval> rakudo f960a2: OUTPUT«Symbol '$ss_SS_S_S__S_S_s' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[00:09] *** eternaleye left
[00:09] * ruz is sad

[00:11] * masak hugs ruz

[00:12] <lue> hugme: hug ruz

[00:12] <lue> ...where is hugme?

[00:12] <mberends> rakudo: grammar I { rule k { 'k' }; rule v { 'v' }; }; say "give ruz a semicolon"

[00:13] <p6eval> rakudo 2314af: OUTPUT«Symbol '$ss_SS_S_S__S_S_s' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[00:13] <jnthn> I think grammars ain't back in master yet, but bkeeler++ was/is working on a patch. :-)

[00:13] <masak> lue: hugme hasn't been around lately. I have to do all my hugging the old-fashioned way.

[00:15] <lue> rakudo: sub hugme($a){say "$a is hugged by a butterfly. All is well";}; hugme("ruz");

[00:15] <p6eval> rakudo 2314af: OUTPUT«ruz is hugged by a butterfly. All is well␤»

[00:16] <snarkyboojum> mein gott 40 commits in the last 24 hours or so :)

[00:16] *** eternaleye joined
[00:18] <snarkyboojum> jnthn is on a complete and utter rampage :) w00t

[00:20] <colomon> snarkyboojum: dang, you're right!  I hadn't quite appreciated how many patches jnthn++ has pushed today...

[00:23] *** hanekomu_ left
[00:25] *** new_order joined
[00:26] *** IllvilJa left
[00:30] <masak> SF strikes again! http://lastofthecarelessmen.blogspot.com/2010/02/e03-laziness-catch.html

[00:31] <jnthn> pmichaud: When you're back, see http://lastofthecarelessmen.blogspot.com/2010/02/e03-laziness-catch.html

[00:32] <jnthn> pmichaud: Not quite sure how we fix that one. :-/

[00:33] *** mikehh left
[00:34] *** mberends left
[00:35] *** simcop2387 left
[00:36] <colomon> yow.

[00:37] <colomon> automatically wrap the iterator in a Seq when it's attached to @a?

[00:39] <jnthn> Maybe.

[00:40] <quietfanatic> Why is it "use of type object as value"?

[00:40] <quietfanatic> It's not a type object, it's an undefined object of that type

[00:40] <quietfanatic> so it should say "use of undefined object as value"

[00:41] <masak> I'd tend to agree.

[00:41] <lue> actually, I say that types are objects :)

[00:41] <jnthn> type object and undefined object of a certain type are, in my eyes, the same thing.

[00:41] <quietfanatic> Well, I'm just going by what TimToady said to me once

[00:42] <jnthn> You could emit the error either way and it's probably correct.

[00:42] <quietfanatic> that Int, as an object, isn't a type, it's an undefined Int.

[00:42] <jnthn> Right, but it's a "type object" in that it represents all values of the type too.

[00:43] <quietfanatic> I guess it could be seen that way, yeah.

[00:43] <quietfanatic> whatever :)

[00:43] <jnthn> Having implemented a bunch of the type-y stuff, I'm more prone to see them that way. :-)

[00:44] <jnthn> I agree "undefined object" may be a more useful way to explain it to the user.

[00:44] <quietfanatic> ...that's what I was thinking

[00:44] <jnthn> LTA error ticket welcome.

[00:44] <quietfanatic> I might submit if I get around to it

[00:44] <jnthn> masakbot!

[00:45] * masak comes to life

[00:46] * masak submits LTA ticket

[00:46] <lue> masak: submit ticket

[00:46] *** masak left
[00:46] <lue> masak: sleep

[00:46] <lue> sorry, masakbot:

[00:47] *** masak joined
[00:48] <jnthn> http://github.com/rakudo/rakudo/commits/ - whole page is commits from today. \o/

[00:48] <masak> jnthn++

[00:48] *** simcop2387 joined
[00:48] <masak> colomon++

[00:49] <jnthn> pmichaud++ and colomon++ too!

[00:49] *** mberends joined
[00:50] <lue> masakbot: applaud again

[00:56] <lue> (o great, the quiet time is finally coming...)

[00:56] * masak rattles his chains

[00:56] * jnthn turns up Within Temptation

[00:57] * mberends commits @*INC

[00:57] <jnthn> ...well at least someone did something useful. :-)

[00:57] <jnthn> mberends++

[00:58] <mberends> the dreaded %*ENV still lieth and waiteth...

[00:59] <jnthn> Oh boy... 

[00:59] <jnthn> :-)

[01:02] <jnthn> Anyways, sleeps for me

[01:02] <jnthn> night! o/

[01:02] *** lejon joined
[01:02] <masak> night, jnthn! o/

[01:02] <mberends> o/

[01:03] <lue> night o/

[01:03] <lejon> ?

[01:03] <lejon> help

[01:04] * lue your help has been granted, but its location is unknown.

[01:04] <lue> what do you need help with?

[01:04] <masak> lejon: hello. welcome to #perl6.

[01:05] <lue> Bonvenon al #perl6 !

[01:05] <lejon> :) well, first time using IRC ...

[01:05] <masak> cool.

[01:05] <masak> lejon: you from .se?

[01:05] <lejon> yup

[01:06] <masak> jag med.

[01:06] <masak> :)

[01:06] <lejon> Stockholm area

[01:06] <lejon> ok

[01:06] <masak> Uppsala here.

[01:06] <lejon> Ah! Mina gamla hemtrakter...

[01:06] <lue> I have a tractor in my garden (?) (I do not speak your tounge)

[01:06] <masak> lejon: Varför flyttade du? Här är så fint :)

[01:07] <lue> stop stop stop stop stop /o\

[01:07] <lejon> Hehe, "trakter" means "area" or "location" :)

[01:07] *** cognominal joined
[01:07] <mberends> lue: there's always Google Translate ;)

[01:07] <lue> Saluton, cognominal! (I'm in an esperanto mood)

[01:07] <lejon> Well, we moved from Uppsala since we both worked in Stockholm, but we do miss it...

[01:08] <lue> evilbot: run google translate

[01:08] <lue> evilbot: run translate #my bad

[01:08] <lue> hmmmm :)

[01:08] *** mberends is now known as evilbot

[01:09] *** evilbot is now known as mberends

[01:13] <lue> diakopter: ping, by any chance?

[01:18] <lejon> hi, everyone... does anyone now what the state of perl6 grammars are?

[01:19] <lue> ask masak, he's been working on an engine :)

[01:19] <TimToady> well, he's been working on a PGE clone, which isn't exactly perl6...

[01:19] <masak> :)

[01:19] <masak> lejon: the state of the art is STD.pm, obviously.

[01:19] <TimToady> lejon: what do you want to know?

[01:19] <mberends> lejon: Perl 6 grammars work very well, there are just a few details to implement in Rakudo

[01:19] <masak> lejon: if you're looking at parsing Perl 6, you might want to have a look at STD.pm.

[01:20] <masak> lejon: if you want to *use* Perl 6 grammars for other things, I'd recommend Rakudo alpha.

[01:20] *** lue is now known as The

[01:20] <lejon> well, I was mostly wondering if rakudo can pares STD.pm at this stage for instance?

[01:20] *** The is now known as lue

[01:20] <masak> no, not yet.

[01:20] <TimToady> not quite

[01:20] <masak> they're converging, though.

[01:20] <TimToady> though we haven't tried recently :)

[01:21] <lue> .oO(darn, spaces aren't allowed in nicknames)

[01:21] <lejon> "they" meaning rakudo and ...?

[01:21] <masak> STD.pm

[01:21] <TimToady> STD parsed nearly all the test suite, it just doesn't run it

[01:22] <TimToady> rakudo parses less of it, but runs much of what it does parse

[01:22] <lejon> Oh, I see so rakudo has their own version of STD.pm...?

[01:22] <TimToady> well, they call it grammar.pm

[01:22] <lejon> cool, I see...

[01:22] <lue> it's not that big, really... (only ~1000 lines of code)

[01:23] <TimToady> well, even STD.pm is only 5700 lines, and that's with a bunch of ops that should be in CORE instead

[01:23] <TimToady> (which is what I'm working on currently btw)

[01:24] <cognominal> lue, kiel vi fartas?

[01:24] *** xomas left
[01:24] <lue> eh... I'm not proficient in epo yet, just a few phrases :)

[01:25] <lue> Mi estas komencanto. (for one)

[01:27] <masak> cognominal: ho, ĉu ankaŭ vi parolas?

[01:28] <huf> masak: what language is this?

[01:28] <lue> (like I said before, at least I have somewhere to practice esperanto in (relatively) real life)

[01:29] <masak> huf: Esperanto. seemingly everyone on this channel speaks it. :)

[01:29] <huf> heh ;)))

[01:29] <lue> there's the ##esperanto channel here on freenode (not there, though)

[01:29] <Tene> I don't!  I'm rather not fond of esperanto.  I do study lojban, though.

[01:29] <masak> don't listen to Tene. he's just a grumpy Lojbanist. :P

[01:30] <lue> Tene: why not? (just curious)

[01:30] <Tene> Good advice.  Definitely should ignore me.

[01:30] *** Guest2390 joined
[01:31] <Tene> lue: http://www.xibalba.demon.co.uk/jbr/ranto/ is a good overview of stuff I dislike about it.  The reason I don't study it, though, is that it's just not interesting to me.

[01:32] *** wknight8111 left
[01:32] <masak> I wouldn't say that page reflects Esperanto very well. it does reflect many outside misconceptions about the language, though.

[01:32] <lue> beh. Klingon may be well-known, but there are only ~a dozen fluent speakers (not me)

[01:33] <lue> that webpage seems oddly extremist. (not saying you are, Tene)

[01:33] <Tene> Esperanto doesn't introduce enough interesting ideas to learn it for research purposes, afaict, and insufficient speakers to learn it for utility.

[01:34] <masak> true.

[01:34] <Tene> Hmm.  "good overview" is a bit extreme.  "Mentions a few things that bothered me, among other things I haven't evaluated".

[01:34] <lue> the part about european-centric (not asia-friendly): I once read of a conversation between two epo speakers, one jp.

[01:34] <masak> the community of thousands of speakers that does exist, though, is kind of an interesting phenomenon on its own :)

[01:35] <masak> lue: thing is, Eo is in a way an isolating language masquerading as a European one.

[01:35] <lue> The japanese guy said that all asian languages (jp, chinese, ko, etc.) are completely different from each other, so it makes no difference

[01:35] *** lest_away is now known as lestrrat

[01:35] <lue> that it's mainly european-based to asians.

[01:35] <masak> yeah, pulling words from something other than Europe seems difficult in practice.

[01:36] <lue> "Clumsy - full of hard sounds, odd letters and absurd words." that one made me laugh. The only (slightly) difficult ones are (possibly) ĥ and r

[01:36] <masak> lue: yes, but even Asians will recognize the isolating part.

[01:37] <masak> lue: tbh, 'sc' isn't easy either :P

[01:37] <cognominal> Speaking of language, right now, I am using Objective-C.  Coming from Perl, which excels at  not repeating itself, it is extremely painful. Also you could cram a perl one liner in the space of an Apple Objective-C identifier.

[01:37] <Tene> cognominal: write perl to generate your obj-C, of course!

[01:37] <masak> cognominal: does Objective-C have redeeming qualities?

[01:38] <cognominal> it is dynamic, sort of. Recently got closures too.

[01:38] * lue is analyzing this page and writing about it as he goes. This page was written in the ASCII days, it seems. The special characters argument is invalid.

[01:38] <cognominal> Tene: I am seriously thinking doing that. But I don't want to be sidetracked :)

[01:39] *** amindfv joined
[01:39] <TimToady> pmichaud: Junction.Str is *not* supposed to autothread

[01:40] <cognominal> Also it seems that the Cocoa environment has one right way to do anything and I have trouble to figure it out. In Perl, I often immediately find some way to do something even if in the long term it is not the right one.

[01:42] <cognominal> At least, it helps to get started and has the immediate rewarding property, a very important one for me who get easily discouraged.

[01:47] *** Guest2390 left
[01:48] *** mikehh joined
[01:48] <masak> g'night, people.

[01:48] <lejon> well, time to sleep good night!

[01:48] <lue> goodnight

[01:48] *** masak left
[01:48] *** lejon left
[01:51] <pugssvn> r29885 | lwall++ | [S02] clarify what was meant by "Nil undefined as an item". 

[01:54] *** jferrero left
[01:59] <pmichaud> TimToady: (Junction.Str)   noted, sorry if I got it backwards again

[01:59] <pmichaud> thanks for the clarification :)

[02:06] <pmichaud> TimToady: If you have any thoughts or suggestions for http://lastofthecarelessmen.blogspot.com/2010/02/e03-laziness-catch.html, they'd be welcome.  :-)

[02:07] <pmichaud> (afk, drugstore run)

[02:10] *** mssm left
[02:12] *** jaldhar left
[02:13] *** jaldhar joined
[02:24] *** mssm joined
[02:29] <lue> rakudo: multi sub infix :<≤>($a, $b) { $a <= $b;}; say 3≤5;

[02:29] <p6eval> rakudo a7403f: OUTPUT«traits specified as colon pairs not yet understood at line 11, near "($a, $b) {"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[02:30] <lue> rakudo: multi sub infix :<≤> ($a, $b) { $a <= $b;}; say 3≤5;

[02:30] <p6eval> rakudo a7403f: OUTPUT«traits specified as colon pairs not yet understood at line 11, near "($a, $b) {"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[02:30] <lue> hmm

[02:30] <mberends> lue: omit some spaces

[02:30] <colomon> lue: rakudo doesn't allow you to create new operators yet.

[02:31] <colomon> and yes, don't think there should be a space between infix and :

[02:32] <lue> alpha: multi sub infix:<≤> ($a, $b) { $a <= $b;}; say 3≤5;

[02:32] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[02:32] <lue> \o/

[02:35] <mberends> lue++

[02:35] <mberends> lue: soon you'll be able to store that in a module, and never type <= again ;)

[02:37] <colomon> I'd prefer to use R>

[02:37] <colomon> ;)

[02:37] <lue> that's what I'm doing right now. The 'official' P6 module, a work in progress.

[02:37] <lue> (what should the jnthn() sub do?)

[02:37] <mberends> it should DWIM

[02:38] <lue> DWIM?

[02:38] <mberends> Do What I Mean, perlish for automagically Doing The Right Thing

[02:39] <lue> alpha: multi sub prefix:<¬> ($a) { !$a;}; say ¬5;

[02:39] <p6eval> alpha 30e0ed: OUTPUT«0␤»

[02:39] <lue> ah, so the meta-sub

[02:39] <lue> alpha: multi sub prefix:<¬> ($a) { !$a;}; say ¬False;

[02:39] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[02:40] <lue> jnthn() would be the most complex sub out there, then.

[02:40] <lue> Would it take arguments to decide what to do, or magically tell based on its surroundings?

[02:41] <mberends> oh, the latter

[02:41] <colomon> I think it would take a string of code or a closure, and make the code Just DWIM.

[02:42] <lue> so there would be a prefix, suffix, infix, etc... great

[02:44] <mberends> perhaps just fix

[02:44] <lue> alpha: multi sub prefix:<¬> ($a) { !$a;}; say 3¬=5;

[02:44] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "\x{ac}=5;"␤in Main (file <unknown>, line <unknown>)␤»

[02:44] <lue> so you could define multi sub fix:<> ?

[02:44] <colomon> no, I think mberends was making a funny

[02:45] <lue> that would make it slightly easier, though

[02:45] <mberends> yes, sorry my ;) key was asleep

[02:45] <lue> multi sub fix:<jnthn> { if in {...} if pre {...} ... } or something like that.

[02:47] <colomon> I was thinking jnthn should just be a sub, but actually, now I want prefix:<jnthn> so we can use metaops with it....

[02:47] <colomon> rakudo: my $a = 80000.0000000000000000000000000;

[02:47] <p6eval> rakudo a7403f: OUTPUT«PAST::Compiler can't compile node of type BigInt␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[02:47] <arlinius> rakudo: say [\jnthn] @_

[02:47] <p6eval> rakudo a7403f: OUTPUT«Confused at line 11, near "say [\\jnth"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[02:48] <colomon> rakudo: my $a = 1.0000000000000000000000000000000000000000000000000000000000000000000e1;

[02:48] <p6eval> rakudo a7403f: OUTPUT«float division by zero␤current instr.: 'perl6;Perl6;Actions;_block5172' pc 198761 (src/gen/perl6-actions.pir:10645)␤»

[02:48] <lue> what would the prefix form do w/ metaops ?

[02:48] * lue .oO(jnthn's gonna have a medical condition of some sort when he reads the backlog, maybe shock)

[02:49] <colomon> well, mostly I want to have hyper-jnthn

[02:49] <colomon> jnthn<<@code-array

[02:50] <lue> alpha: multi sub infix:<hai> ($a, $b) { $a + $b;}; multi sub suffix:<hai> ($a) { $a.perl;}; say 5 hai 4; say "oh"hai;

[02:50] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "hai;"␤in Main (file <unknown>, line <unknown>)␤»

[02:50] <lue> alpha: multi sub infix:<hai> ($a, $b) { $a + $b;}; multi sub suffix:<hai> ($a) { $a.perl;}; say 5 hai 4; say "oh"hai

[02:50] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "hai"␤in Main (file <unknown>, line <unknown>)␤»

[02:50] <lue> alpha: multi sub infix:<hai> ($a, $b) { $a + $b;}; multi sub suffix:<hai> ($a) { $a.perl;}; say 5 hai 4; say "oh".hai

[02:50] <p6eval> alpha 30e0ed: OUTPUT«9␤Method 'hai' not found for invocant of class 'Str'␤in Main (file src/gen_setting.pm, line 324)␤»

[02:51] <colomon> postfix, not suffix, I think.

[02:51] <lue> alpha: multi sub infix:<hai> ($a, $b) { $a + $b;}; multi sub postfix:<hai> ($a) { $a.perl;}; say 5 hai 4; say "oh"hai

[02:51] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "hai"␤in Main (file <unknown>, line <unknown>)␤»

[02:51] <colomon> huh.

[02:52] <colomon> alpha: multi sub infix:<hai> ($a, $b) { $a + $b;}; say 5 hai 4;

[02:52] <p6eval> alpha 30e0ed: OUTPUT«9␤»

[02:52] <lue> alpha: multi sub infix:<hai> ($a, $b) { $a + $b;}; multi sub prefix:<hai> ($a) { $a.perl;}; say 5 hai 4; say hai"there";

[02:52] <p6eval> alpha 30e0ed: OUTPUT«9␤"there"␤»

[02:52] <colomon> alpha:  multi sub postfix:<hai> ($a) { $a.perl;};  say "oh"hai

[02:52] <p6eval> alpha 30e0ed: OUTPUT«"oh"␤»

[02:52] <lue> just testing to see if you could have multiple operators w/ same name

[02:52] <pmichaud> you can, within some limits.

[02:53] <pmichaud> things get confused when there's an infix and postfix operator with the same token.

[02:53] <pmichaud> (because they both parse in operator position)

[02:53] <colomon> pmichaud: how hard would it be to get define-your-own operators working in master?

[02:53] <lue> the jnthn() omnisub ought to be an interesting challenge though

[02:53] <pmichaud> colomon: shouldn't be too hard

[02:54] <arlinius> alpha: multi sub postfix:<+> ($a) { $a + 2 }; say 5+

[02:54] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "+"␤in Main (file <unknown>, line <unknown>)␤»

[02:54] <pmichaud> colomon: I've been thinking of adding that "soonish"

[02:54] <arlinius> like that kind of confused

[02:54] <colomon> pmichaud: sweet

[02:54] <pmichaud> the tricky part is getting the parser modified to recognize the new tokens

[02:54] <arlinius> alpha: multi sub postfix:<!> ($a) { $a + 2 }; say 5!

[02:54] <colomon> right

[02:54] <p6eval> alpha 30e0ed: OUTPUT«7␤»

[02:54] <pmichaud> (which isn't hard, but has to happen at BEGIN time)

[02:55] <lue> tell it to forget other things then. (o wait, bad idea)

[02:55] <lue> maybe it can happen at ALMOSTREADY or DONTBEGINJUSTYET time :D

[02:57] <colomon> pmichaud: I was just looking at S02-builtin_data_types/num.t, It's kind of a nightmare.

[02:57] <lue> (is there a quick list of the kinds of operators P6 has?)

[02:57] <colomon> lue:  see S03

[02:58] <colomon> http://perlcabal.org/syn/S03.html

[02:58] <pmichaud> it's a year out of date, but there's also http://www.ozonehouse.com/mark/periodic/

[02:58] <pmichaud> (Periodic table of the Perl 6 operators)

[02:58] <colomon> if that were up-to-date I would totally buy one to hang on the wall.

[02:59] *** synth joined
[02:59] * colomon still wants a Rakudo t-shirt, for that matter...

[02:59] *** synth left
[02:59] *** redicaps left
[02:59] <pmichaud> rakudo.spreadshirt.com

[02:59] *** redicaps joined
[02:59] <pmichaud> cafepress.com/rakudo

[02:59] <lue> I'm there (S03), but it's not exactly a quick list (list as in grocery).

[03:00] <pmichaud> lue: "Operator precedence" at the top of S03 is a pretty good list

[03:00] *** synth joined
[03:01] <colomon> pmichaud: If there's nothing snappier by YAPC:NA, I'll get the value t-shirt Rakudo Perl 6 from cafepress.  :)

[03:01] <pmichaud> colomon: works for me.  I'm open for suggestions on snappier designs, too :)

[03:02] <colomon> I think I'd rather have a light-colored Rakudo logo on a dark-colored t-shirt.

[03:02] <pmichaud> I can probably arrange that :-)

[03:02] <lue> .rnd(Our deluxe Peanut Chicken, where our motto is "So peanutty, you won't taste the chicken!")

[03:02] <colomon> pmichaud++

[03:03] <colomon> lue: the thing is, Perl 6 has a gazillion operators. It's an important component of the design, but it makes normal lists tricky.

[03:04] <lue> A good list I'm interested in would be the names you'd use in multi sub [name]:<jnthn> ...

[03:04] <lue> but I'll manage with the ones out there :)

[03:08] <lue> pmichaud: how about a shirt that says something like: (more)

[03:09] <lue> 楽土 Perl 6 (Rakudo Perl 6): Its name is japanese, so it must be cool.

[03:11] <arlinius> rakudo: sub 楽土 { say "楽土" }

[03:11] <p6eval> rakudo a7403f:  ( no output )

[03:11] <arlinius> rakudo: sub 楽土 { say "楽土" }; 楽土

[03:11] <p6eval> rakudo a7403f: OUTPUT«楽土␤»

[03:11] *** cognominal left
[03:11] <lue> good sub! must include...

[03:12] *** cognominal joined
[03:13] <TimToady> pmichaud: if you bind an iterator to @, it should become something Positional with the iterator as its "extender"

[03:13] <TimToady> interesting Q whether it should become Seq or Array though

[03:13] *** lichtkind left
[03:14] <colomon> TimToady: seems like it would depend on whether it is a rw parameter or not....

[03:14] <TimToady> depends on how rw distributes

[03:14] *** mberends left
[03:14] <TimToady> but maybe rw is what we want

[03:14] <TimToady> (to make an Array)

[03:15] *** lichtkind joined
[03:16] *** k23z__ left
[03:16] <colomon> pmichaud: Am I correct in thinking dec_number must be the function generating the divide by zero / BigInt errors with super-long decimal numbers?

[03:18] *** lichtkind left
[03:19] *** zorgnax left
[03:19] <colomon> rakudo: say (10.).WHAT

[03:19] <p6eval> rakudo a7403f: OUTPUT«Confused at line 11, near "say (10.)."␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[03:19] <TimToady> std: say (10.).WHAT

[03:19] <p6eval> std 29885: OUTPUT«===SORRY!===␤Decimal point must be followed by digit at /tmp/mgsIBGZ0mi line 1:␤------> say (10.⏏).WHAT␤FAILED 00:01 107m␤»

[03:20] <colomon> I see what's going on in the grammar.  :)

[03:20] *** lichtkind joined
[03:20] *** redicaps left
[03:20] *** redicaps joined
[03:20] *** lichtkind left
[03:21] <pmichaud> I'm not sure Seq or Array are the right answers, though

[03:21] <pmichaud> suppose I have

[03:21] <pmichaud>     foo( (1..1000000).map({ ... }) )

[03:22] <TimToady> the "extender" part of a Seq or Array is still lazy

[03:22] <pmichaud> is it normal to expect that foo() will keep around all 1 million elements?  What if it wants to process them one-at-a-time

[03:22] <TimToady> then it shifts them

[03:22] <pmichaud> that argues for Array, then.

[03:22] <pmichaud> (since Seq doesn't shift)

[03:23] *** lue is now known as TheDoctor

[03:23] *** TheDoctor is now known as The_Doctor

[03:23] <pmichaud> it also means that the parameter isn't really bound to the argument

[03:24] <pmichaud> (which may be okay, but feels like a bit of a departure)

[03:24] *** The_Doctor is now known as Doctor_Who

[03:24] *** Doctor_Who is now known as lue

[03:24] <lue> I can't pick a decent DrWho-related nick! :(

[03:24] *** redicaps left
[03:25] *** redicaps joined
[03:26] <pmichaud> colomon: yes, whatever is making decimal numbers into Rats is what is generating the problems with really big decimals

[03:26] <pmichaud> s/big/long/

[03:26] <lue> the biggest decimal I can think of is .999... :P

[03:26] <lue> (not allowing whole numbers in the mix)

[03:27] <colomon> pmichaud: the one thing that occurred to me -- maybe we could track how many times the @ variable is used?  If it's only referred to once, the iterator should be fine, if it's more than once it has to be Seq/Array?

[03:27] <pmichaud> colomon: what about binding?

[03:27] <colomon> pmichaud: darned if I know.  I'm just trying to brainstorm here.  :)

[03:31] <colomon> and if we're going down that path, what happens if you pass an iterator to a $ argument?

[03:32] <pmichaud> I'm still struggling with that a bit also :-)

[03:32] <lue> std: my $ = 4; say $

[03:32] <p6eval> std 29885: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at /tmp/eznc8Rg04J line 1:␤------> my $ = 4; say $⏏<EOL>␤    expecting twigil␤FAILED 00:01 108m␤»

[03:32] <lue> std: my $$ = 4; say $$

[03:32] <p6eval> std 29885: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at /tmp/ar1SFwrOcR line 1:␤------> my $$ = 4; say $$⏏<EOL>␤    expecting twigil␤FAILED 00:01 106m␤»

[03:32] <pmichaud> std:  say (my $ = 4);

[03:32] <p6eval> std 29885: OUTPUT«ok 00:01 106m␤»

[03:35] <lue> alpha: say (my $ = 4);

[03:35] <p6eval> alpha 30e0ed: OUTPUT«Malformed declaration at line 10, near "$ = 4);"␤in Main (file <unknown>, line <unknown>)␤»

[03:35] <pmichaud> otoh,  .999..... *is* a whole number :-)

[03:36] <lue> I know, but it is still a decimal :)

[03:38] *** cognominal left
[03:39] <pmichaud> 03:12 <TimToady> pmichaud: if you bind an iterator to @, it should become something Positional with the iterator as its "extender"

[03:39] <pmichaud> so, is there a method that gets called whenever an object is about to be bound?

[03:39] <pmichaud> (if so, what is that method called?)

[03:47] *** Chillance left
[03:49] <colomon> pmichaud: is it DEBUG that lets you "say" in Actions.pm?

[03:49] <pmichaud> say in Actions.pm requires parens.

[03:49] <pmichaud> (NQP doesn't support listops)

[03:49] <colomon> oh, so say works?

[03:49] <pmichaud> I think it does, ye.

[03:49] <pmichaud> yes.

[03:50] <pmichaud> but you have to do   say("something")   and not    say "something"

[03:50] <pmichaud> if that doesn't work, there's always   pir::say("something")

[03:50] <colomon> pmichaud++

[03:50] * colomon is trying to figure out how dec_number works without deciphering the PIR portion...

[03:51] <pmichaud> the PIR portion is simply figuring out what value to use as the base

[03:51] <pmichaud> so, given   123.456

[03:51] <pmichaud> the PIR portion is calculating the base as 1000

[03:51] <colomon> I think it's coming out zero sometimes.

[03:51] <pmichaud> (because there are three digits after the decimal)

[03:52] <colomon> say() doesn't work.

[03:52] <pmichaud> try pir::say() then.

[03:52] <colomon> compiling...

[03:53] <colomon> that compiled, I think.

[03:53] <colomon> (still building)

[03:53] <lue> colomon: PIR isn't that bad! Not when you've studied assembler!...

[03:53] <pmichaud> I don't think that $base can be zero.

[03:54] <pmichaud> do you have an example where it's failing?

[03:54] <colomon> rakudo: my $a = 1.0000000000000000000000000000000000000000000000000000000000000000000e1;

[03:54] <p6eval> rakudo a7403f: OUTPUT«float division by zero␤current instr.: 'perl6;Perl6;Actions;_block5172' pc 198761 (src/gen/perl6-actions.pir:10645)␤»

[03:55] <pmichaud> rakudo:  my $a = 1.00000000000000000000000000000000000000000000000000000000000

[03:55] <p6eval> rakudo a7403f: OUTPUT«Nominal type check failed for parameter '$a'; expected Int but got Num instead␤current instr.: 'perl6;Rat;gcd' pc 316077 (src/gen/core.pir:37051)␤»

[03:55] <colomon> lue: I've programmed 6502 and IBM mainframe assembler.  But I'd still rather avoid it if I can.

[03:56] <pmichaud> okay, what is happening in the 1.000000000000000000000e1 case is that we're going outside the range of values that can be computed in an I register.

[03:56] <colomon> thought it might be something like that.

[03:56] <pmichaud> so, perhaps changes all of the occurrences of $I2 to $N2

[03:56] <pmichaud> *change

[03:56] <pmichaud> that would at least get us into the realm of floating point values

[03:56] <pmichaud> we don't actually lose much by doing that, since NQP's math ops are going to end up doing floating point anyway

[03:57] <colomon> :(

[03:57] <colomon> seems like there's something off with this approach.

[03:58] <pmichaud> we do rub against Parrot's limited view of numbers here, yes.

[03:58] <pmichaud> there was a long thread about this just eight days ago in Parrot

[03:58] * lue thinks he'll avoid the jnthn omnisub for now

[04:00] <pmichaud> anyway, are you trying the  $I2 -> $N2 approach?

[04:00] <colomon> actually, I'm still trying to get say to compile for me.

[04:00] <colomon> it keeps on compiling for a long time and then failing.

[04:00] <pmichaud> pir::say didn't work?

[04:00] <lue> rakudo: $a=3; say $a.WHO;

[04:00] <p6eval> rakudo a7403f: OUTPUT«Symbol '$a' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[04:01] <lue> rakudo: my $a=3; say $a.WHO;

[04:01] <p6eval> rakudo a7403f: OUTPUT«Int␤»

[04:01] <colomon> error:imcc:syntax error, unexpected INTC, expecting $end ('10')

[04:01] <colomon> is what I get from pir::say($base);

[04:01] <pmichaud> weeeeeeird

[04:01] <lue> How would you get the name of a variable for use in code?

[04:01] <lue> other than providing it manually?

[04:03] <sjohnson> hi

[04:03] *** meppel joined
[04:04] <colomon> lue: you mean something like sub a($b) { say $b.WHO; }; my $c = "hello"; a($c) and you want WHO to print $c?

[04:04] <lue> yes, in a nutshell.

[04:04] <colomon> lue: unfortunately, I don't have a clue.  :)

[04:04] <pmichaud> I would think that it would have to print $b :-)

[04:04] <pmichaud> and .WHO means something else :)

[04:05] <lue> I know. I want to create a dalek() sub, which nullifies the provided variable, and say "[variable name] exterminated!"

[04:05] <colomon> I took the pir::say out and finally have a complete build again.

[04:06] <lue> my $a=3; say $a.WHO;

[04:06] <lue> rakudo: my $a=3; say $a.WHO;

[04:06] <p6eval> rakudo a7403f: OUTPUT«Int␤»

[04:06] <lue> rakudo: my $a=3; say $a.WHAT;

[04:06] <p6eval> rakudo a7403f: OUTPUT«Int()␤»

[04:06] <lue> rakudo: my $a=3; say $a.WHEN;

[04:06] <p6eval> rakudo a7403f: OUTPUT«Method 'WHEN' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[04:06] <lue> rakudo: my $a=3; say $a.WHERE;

[04:06] <p6eval> rakudo a7403f: OUTPUT«47393419560592␤»

[04:06] <lue> rakudo: my $a=3; say $a.WHY;

[04:06] <p6eval> rakudo a7403f: OUTPUT«Method 'WHY' not found for invocant of class 'Integer'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[04:06] <lue> rakudo: my $a=3; say $a.HOW;

[04:06] <p6eval> rakudo a7403f:  ( no output )

[04:07] <lue> ?

[04:07] <colomon> trying $I2 -> $N2 now.

[04:07] <colomon> I'm predicting it doesn't work, at least for Rats.

[04:07] <Tene> lue: you'd need macros to do that, and they're NYI in rakudo.

[04:07] *** meppl left
[04:07] <lue> I find WHO counterintuitive AND redundant (a world record!)

[04:07] <Tene> lue: I got a prototype working, but I'm still blocking on spec decisions from TimToady to start really working on it.

[04:08] <Tene> rakudo: my $a = 3; say $a.WHO.WHAT

[04:08] <p6eval> rakudo a7403f: OUTPUT«Method 'WHAT' not found for invocant of class 'Int'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[04:08] <Tene> rakudo: my $a = 3; say $a.WHAT.WHAT

[04:08] <p6eval> rakudo a7403f: OUTPUT«Int()␤»

[04:10] <colomon> pmichaud: I've been wondering for a while if the dec_number routine should call infix:</> instead of Rat.new.

[04:11] <colomon> > say 1.1000000000000000000000000000000000000

[04:11] <colomon> too many positional arguments: 3 passed, 1 expected

[04:11] <colomon> > say 1.1000000000000000000000000000000000000e1

[04:11] <colomon> 10

[04:12] <colomon> seems LTA

[04:13] *** cognominal joined
[04:14] *** xinming_ joined
[04:14] <pmichaud> yes, I'm certain that it is.  You're very welcome to come up with a better algorithm :-)

[04:15] *** justatheory left
[04:16] <pmichaud> I threw that one together just to get something working, not because I felt it was the right way to go.

[04:16] <colomon> sure, believe me, I understand that approach.  :)

[04:16] <colomon> (don't look to hard at infix:<Z>, for instance. ;)

[04:17] <pmichaud> the way that alpha computed fractional parts was by iterating over each digit and place

[04:18] <pmichaud> probably should bring that back.

[04:18] <lue> rakudo: multi sub infix:<xyzzy>($a, $b) {say $a.WHAT; say $b.WHAT;}; 3 xyzzy 3;

[04:18] <p6eval> rakudo a7403f: OUTPUT«Confused at line 11, near "3 xyzzy 3;"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[04:18] <lue> rakudo: multi sub infix:<xyzzy> ($a, $b) {say $a.WHAT; say $b.WHAT;}; 3 xyzzy 3;

[04:18] <p6eval> rakudo a7403f: OUTPUT«Confused at line 11, near "3 xyzzy 3;"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[04:19] <pmichaud> (rakudo doesn't allow custom operators yet)

[04:19] <lue> alpha: multi sub infix:<xyzzy> ($a, $b) {say $a.WHAT; say $b.WHAT;}; 3 xyzzy 3;

[04:19] <lue> (forgot)

[04:19] <p6eval> alpha 30e0ed: OUTPUT«Int()␤Int()␤»

[04:19] <lue> alpha: multi sub infix:<xyzzy> ($a, $b) {say $a.WHAT; say $b.WHAT;}; 3 xyzzy

[04:19] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "xyzzy"␤in Main (file <unknown>, line <unknown>)␤»

[04:19] <lue> darn, I was hoping to use a workaround to allow the same name for infix and postfix.

[04:20] <colomon> pmichaud: I need to get to bed.  But if you haven't done something with this by tomorrow, I'll happily try to sort out a better approach.

[04:21] <lue> night o/

[04:21] <pmichaud> colomon: well, I'm likely to head to bed also

[04:21] <pmichaud> but I might tackle it briefly

[04:21] <pmichaud> at any rate, feel free to start on it whenever :-)

[04:21] <colomon> good luck!

[04:21] <lue> then who be here (besides me) :(

[04:22] <colomon> pmichaud: is Actions.pm in NQP-rx?

[04:22] <TimToady> I am vaguely here

[04:22] <pmichaud> colomon: yes

[04:22] <pmichaud> (assuming you mean "written in NQP")

[04:23] <colomon> pmichaud: what sort of math is available there?  it looks like Int and Num math?

[04:23] <pmichaud> it ultimately becomes all num for the most part

[04:23] <TimToady> well, if Int were really bigint...

[04:23] <pmichaud> it's a limitation of parrot's math operators at the moment

[04:24] <lue> .oO(I'm surprised parrot doesn't come with bolton and notlob operators)

[04:24] <lue> .oO(in PIR at least)

[04:25] <lue> rakudo: say "hello".flip

[04:25] <p6eval> rakudo a7403f: OUTPUT«olleh␤»

[04:26] <colomon> rakudo: say 1.1000000000000000000000000000000

[04:26] <lue> rakudo: say True ~~ 42;

[04:26] <p6eval> rakudo a7403f: OUTPUT«Nominal type check failed for parameter '$a'; expected Int but got Num instead␤current instr.: 'perl6;Rat;gcd' pc 316077 (src/gen/core.pir:37051)␤»

[04:26] <p6eval> rakudo a7403f: OUTPUT«0␤»

[04:26] <lue> that is wrong!

[04:26] <lue> rakudo: say False ~~ 42;

[04:26] <p6eval> rakudo a7403f: OUTPUT«0␤»

[04:27] <colomon> lue: are you thinking of it backwards?  True is not a kind of 42...

[04:27] <lue> rakudo: say 42 ~~ True;

[04:27] <p6eval> rakudo a7403f: OUTPUT«1␤»

[04:27] <lue> rakudo: say 42 ~~ False;

[04:27] <p6eval> rakudo a7403f: OUTPUT«0␤»

[04:27] <pmichaud> colomon: the tricky part to dec_number is being able to decide when we should construct a rat, and when we should stick with a Num.

[04:27] <lue> It should still come out 1 the other way, though.

[04:27] <pmichaud> ~~ isn't commutative.

[04:28] <lue> .rnd(autonomous anarcho-syndicalist commune)

[04:28] <colomon> pmichaud: actually, looking at that result above, I really think infix:</> is the way to go instead of Rat.new.

[04:29] <pmichaud> colomon: right now, it would always end up calling  infix:</>(Int, Num)   then

[04:29] <pmichaud> which would always produce a Num, I think.

[04:29] <colomon> hmmm?

[04:29] <colomon> Rat.new takes two Ints.

[04:30] <pmichaud> colomon: after making the $I2 -> $N2 conversion, it gets an Int and a Num

[04:30] *** meppel left
[04:30] <colomon> oooo.

[04:30] <colomon> what I'm thinking of fixes the one problem but not the other.

[04:30] <pmichaud> or, if you don't make the $I2 -> $N2 conversion, you get two ints, but go out-of-range whenever the denominator has more digits than can fit into an int

[04:30] <pmichaud> as I said, the tricky part is deciding when to construct a rat, and when to stick with a num

[04:31] <colomon> pmichaud: I don't think that's quite right.

[04:31] <colomon> hmmm...

[04:31] <TimToady> it's always supposed to make a rat

[04:31] <colomon> rakudo: say 1.100000000000000000000000000000

[04:31] <p6eval> rakudo a7403f: OUTPUT«PAST::Compiler can't compile node of type BigInt␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[04:31] <TimToady> unless there an e

[04:31] <pmichaud> ...and unless it goes outside of 64-bit ratness?

[04:31] <colomon> TimToady: that's not right, it's only... what pmichaud said.

[04:32] <TimToady> spec says Rat64, but with a .Str that allows the whole thing, including conversion to FatRat

[04:32] <lue> I'm gonna work on the jnthn omnisub tomorrow. I have the feeling that after I do, I could make my own P6 Periodic Table...

[04:32] <TimToady> S02:3181

[04:33] <pmichaud> I don't think we can do FatRat until we have bigints, and bigints aren't likely in the next two or so months

[04:33] <pmichaud> so we just live with being out-of-spec there, I suspect.

[04:35] * colomon is tired and thinking in circles.

[04:37] <colomon> instead of $base being 10, 100, 1000, etc., it should be 1, 2, 3, I think.  I wouldn't worry about getting more digits than you can count with a 32-bit int.

[04:37] <pmichaud> sure, but you still run into issues when base > 32

[04:38] <pmichaud> actually, when base > 10

[04:38] <pmichaud> because we still can't construct an int that large

[04:38] <colomon> but $exp can go larger than 10 and still work, right?

[04:39] *** mssm left
[04:39] <pmichaud> because it's a num and not an int

[04:40] <pmichaud> I can get it so that we construct valid nums for long strings of digits; as I said -- the tricky part is deciding when it's safe for us to construct a rat

[04:40] <pmichaud> either that or our Rats need to be able to have num/den that can easily go outside of the range of ints

[04:41] <pmichaud> (i.e., set num/den to be Num/Float instead of Int/Integer

[04:41] <colomon> can you calculate $int * (10 ** $base) + $frac as a Num and see if it fits in an Int?

[04:41] <colomon> in NQP-rx, I mean?

[04:41] <colomon> got to go to bed now, too tired to think....

[04:41] <pmichaud> sure, can do that

[04:42] <pmichaud> but I think you mean    $int + $frac / (10 ** $base)

[04:43] <pmichaud> oh, for the later one... hmm

[04:43] <pmichaud> I'm not sure I want to be doing that exponentiation step on every dec_number literal, though :-|

[04:44] <TimToady> literals don't have to be fast

[04:44] <pmichaud> ...and every string-to-number conversion :-)

[04:45] <pmichaud> but yes, we could do a table lookup or something if we had to 

[04:46] <pmichaud> oh!!!!

[04:46] <pmichaud> colomon: you're right, infix:</>  might be the more correct approach here.

[04:52] <pmichaud> msg colomon  in dec_number,   try changing  $I2 to $N2  and then switch the call to Rat.new to instead be  &infix:</>

[04:52] <pmichaud> phenny tell colomon  in dec_number,   try changing  $I2 to $N2  and then switch the call to Rat.new to instead be  &infix:</>

[04:53] <pmichaud> phenny: tell colomon  in dec_number,   try changing  $I2 to $N2  and then switch the call to Rat.new to instead be  &infix:</>

[04:53] <phenny> pmichaud: I'll pass that on when colomon is around.

[04:53] <pmichaud> (ETOOMANYMESSAGEBOTS)

[04:54] *** justatheory joined
[04:55] <lue> must.....eat...spoonful of...... pure......caffeine!

[04:57] <lue> how does phenny know when someone's around when there's no indication they aren't (except for the lack of talking)

[04:57] <Tene> lue: phenny only responds to messages sent to the channel.

[04:57] <pmichaud> phenny remembers nicks, waits for the next time the person with that nick speaks

[04:57] <lue> ah.

[04:58] <pmichaud> phenny: tell lue   like this

[04:58] <phenny> pmichaud: I'll pass that on when lue is around.

[04:58] <Tene> So, if someone sent a message to me with phenny, phenny would deliver it as soon as I spoke.

[04:58] <lue> I get it. I don't need an example :)

[04:58] <phenny> lue: 04:58Z <pmichaud> tell lue   like this

[04:58] <lue> ah! I said I didn't need an example!

[04:58] <pmichaud> tell that to phenny :)

[04:58] <Tene> phenny: tell lue that you're sorry for providing an example

[04:58] <phenny> Tene: I'll pass that on when lue is around.

[04:58] <lue> phenny: tell pmichaud  I don't need an example!

[04:58] <phenny> lue: I'll pass that on when pmichaud is around.

[04:58] <phenny> lue: 04:58Z <Tene> tell lue that you're sorry for providing an example

[04:59] * lue fun with phenny

[05:00] <lue> phenny: tell hugme  it's great to have you back!

[05:00] <phenny> lue: I'll pass that on when hugme is around.

[05:03] <diakopter> lue: around here, op status doesn't mean anything except "you're on a mostly persistent connection and you're here often enough to kick spammers".  But since a few days after freenode switched to a new ircd, there's been no spam problem, so I move to deop everyone but TimToady (or something)...

[05:04] <lue> Alright. I just like having op status :D

[05:04] <diakopter> yeah.. that's generally why, for years, nobody was op nearly all of the time

[05:05] <lue> I would, however, love to mass-kick everyone in the user list (to my right) who never does anything except stay logged in

[05:06] <TimToady> why?

[05:06] *** gabiruh joined
[05:06] <TimToady> they're our friends

[05:06] <Tene> Hmm... that counts as a vote against yourself for op privs.

[05:06] <lue> I don't know, honestly. (I haven't been here long enough to know most of the guys who never show)

[05:06] <Tene> Some people just like watching.

[05:06] <Tene> I lurked for a long time before I started contributing.

[05:06] <lue> I wouldn't REALLY kick them. That would take a lot of typing and backlash :(

[05:06] <Tene> There are plenty of other channels that I just lurk in.

[05:07] <TimToady> there is no pecking order here

[05:09] <Tene> Hmm.  Looks like I don't have privileges to modify the access list for #perl6 anyway.

[05:11] *** nihiliad left
[05:11] <lue> probably the only thing i'd do with chanop is rename pugssvn to cyberman :D

[05:12] <diakopter> I (still) hope you're (still) kidding

[05:12] <Tene> Hmm.  By my reading of this, nobody here has has access to modify the access list, only freenode-staff.

[05:12] <diakopter> I think audreyt does

[05:12] <Tene> lue: You know you can't do that, right?

[05:12] <arlinius> can't rename users with op status :P

[05:12] <Tene> diakopter: not anymore.  she's not even set as founder anymore.

[05:12] <diakopter> oh, ok

[05:12] <Tene> freenode-staff is set as founder

[05:12] <pmichaud> I contacted the freenode staff to try to regain some channel control (with mst++'s help) but heard no response.

[05:12] <phenny> pmichaud: 04:58Z <lue> tell pmichaud  I don't need an example!

[05:12] <pmichaud> I'll likely try again.

[05:13] <Tene> and as successor.

[05:13] <diakopter> arlinius: no one can rename *anyone* else

[05:13] *** hercynium joined
[05:13] <diakopter> oh, that's what you were saying

[05:13] <Tene> diakopter: staff can force nick changes on some ircds.

[05:13] <lue> I wonder how masak's doing with the TARDIS, and where that progress is...

[05:14] <diakopter> Tene: 

[05:14] <arlinius> sure, but you can (theoretically) give a command to a bot to tell it to rename itself

[05:14] <lue> phenny: tell masak  the past wants him to come back here and answer some questions about the TARDIS

[05:14] <phenny> lue: I'll pass that on when masak is around.

[05:14] <arlinius> it just has nothing to do with being a channel op

[05:14] <arlinius> but yeah, that's basically what i was saying

[05:15] <lue> I would think you could change the names of _bots_. Not people, but bots...

[05:15] <Tene> lue: no difference, as far as IRC is concerned.

[05:15] <Tene> pmichaud: proposal on who to have set as founder and successor?

[05:16] <pmichaud> I was just going to set me as founder to begin with, then anyone else as successor.

[05:16] <pmichaud> I don't need to be founder -- I was just the person who agreed to try to make something happen :)

[05:16] * Tene nods.

[05:16] <pmichaud> my first act would likely be to find someone to pass it off to :)

[05:16] <lue> Hard tossup between pmichaud and TimToady: founder of P6, or founder of Rakudo? hmmm

[05:17] <Tene> lue: founder just means privileges to amdinister the channel in additional ways.

[05:18] <lue> and the title of Admin (like how I like just having the title of op)

[05:18] <lue> s/Admin/Founder/

[05:19] *** justatheory left
[05:20] <Tene> #freenode says that we need to http://freenode.net/group_registration.shtml which I'm currently reading.

[05:21] <lue> let's pillage the offices! ...and register as a group. (oh wait, not that kind of group registration)

[05:23] <pmichaud> yes, that's what I did before :)

[05:25] <lue> check out http://freenode.net/group_pillage.shtml. I think that's what we should do :)

[05:26] <arlinius> we should not find a page on a server? :)

[05:26] <lue> also http://vikingguide.info/freenode_strategy_C3.html :)

[05:27] <Tene> pmichaud: #freenode says that only you can inquire about a group registration form you've submitted. :P

[05:27] <lue> the term is *en*quire, not inquire (I'm not british, but still)

[05:27] <pmichaud> that was many weeks ago -- I'd have to go back and track it down

[05:27] <diakopter> they keep records of them; if you submitted it, they have it (allegedly)

[05:28] <diakopter> probably some mailing list

[05:28] <pmichaud> where do I inquire?

[05:28] <diakopter> I msg'd you

[05:34] <diakopter> lue: why do you think "the term is *en*quire, not inquire"

[05:35] <lue> enquire is informal, inquire is formal (in British English, no distinction in American)

[05:36] <lue> Such as: I enquire you about your bananas, the FCC inquires you about your pirate radio.

[05:37] <arlinius> hrm

[05:37] <diakopter> Oxford English Dictionary has this for "enquire":  An alternative form of INQUIRE. The mod. Dicts. give inquire as the standard form, but enquire is still very frequently used, esp. in the sense ‘to ask a question’.

[05:37] <lue> And, despite my not being british (i'm american), I have developed the tendency to type humourous instead of humorous.

[05:38] <diakopter> also http://www.askoxford.com/asktheexperts/faq/usage/enquire

[05:39] <arlinius> lue: what they're talking about could be described as a formal inquiry anyway

[05:40] <lue> that's redundant (askoxford proves my point, actually)

[05:40] <lue> (i'm weird that way, you find me harp on the strangest points sometimes :D)

[05:41] *** Achilles333 joined
[05:42] <arlinius> how current are the docs in the rakudo git repository's docs directory?

[05:44] *** am0c left
[05:45] <pmichaud> time for sleep here

[05:48] *** gfx joined
[05:58] *** am0c joined
[06:18] <lue> anyone here? (leafing through fortune-mod to pass the time)

[06:19] <Tene> I am.

[06:20] <lue> (still leafing through fortune-mod...sigh)

[06:38] <arlinius> I guess guide_to_setting applied to alpha and is (partly?) obsolete in master?

[06:46] *** am0c left
[07:00] *** am0c joined
[07:02] *** eternaleye left
[07:10] *** eternaleye joined
[07:40] <lue> it is called night, and I have found it to be good. I call it...

[07:40] <lue> ...goodnight

[07:41] *** lue left
[08:38] *** iblechbot joined
[08:44] *** lejon joined
[08:47] *** gfx left
[08:56] <lejon> Hello, anyone here?

[09:05] *** athenot left
[09:07] *** Achilles333 left
[09:15] *** mberends joined
[09:16] <mberends> hi lejon

[09:16] <lejon> hi there 

[09:16] *** mssm joined
[09:17] <mberends> it would be nice if you could come to http://conferences.yapceurope.org/hack2010dk/

[09:18] *** IllvilJa joined
[09:20] <lejon> Looks great, but don't think I can make it, I'm happy if I get the evenings to play around with p6...

[09:20] *** Guest55249 joined
[09:23] <mberends> fine, the conferences tend to stimulate a lot of extra interest in a region anyway. stay in touch...

[09:24] *** Su-Shee joined
[09:25] <mberends> rakudo: .say for @*INC # newly added

[09:25] <p6eval> rakudo a7403f: OUTPUT«/home/p6eval/.perl6/lib␤/home/p6eval//p1/lib/parrot/2.1.0-devel/languages/perl6/lib␤lib␤.␤»

[09:25] <Su-Shee> good morning

[09:25] <mberends> hi Su-Shee 

[09:27] <mberends> rakudo: run 'echo $PERL6LIB'

[09:27] <p6eval> rakudo a7403f: OUTPUT«lib␤»

[09:27] <mberends> ok

[09:41] *** eternaleye left
[09:43] *** gbacon joined
[09:51] *** eternaleye joined
[09:58] *** lejon left
[10:04] *** Guest55249 left
[10:26] *** orafu left
[10:26] *** orafu joined
[10:38] *** Trashlord joined
[10:38] *** pmurias joined
[10:38] <pmurias> ruoso: hi

[10:39] <Trashlord> I think I have a hard drive that's about to fail

[10:39] <Trashlord> well, not about to, but it will sometime in the near future

[10:43] <mberends> Trashlord: start using a new hard drive *before* the old one dies, it's much easier to recover stuff that way

[10:44] <Trashlord> it's just music, it's already backed up on an external drive

[10:44] <Trashlord> I knew its life is going to end soon, so I bought an external and backed up everything, just in case

[10:44] <Trashlord> can't afford to lose 40GB of music, heh

[10:44] <Trashlord> but well, I think I'll order a new drive anyway

[10:44] <Trashlord> IDE drives should be pretty cheap

[10:45] <mberends> I'm starting to use Ubuntu One as cloud storage

[10:45] <Trashlord> I don't really like cloud storage

[10:45] <Trashlord> feels like my data isn't really mine

[10:45] <Trashlord> kinda paranoid about it

[10:46] <mberends> it's not suitable as primary storage, but probably useful as a spare copy

[10:58] *** redicaps left
[11:13] <pmurias> mberends: how's vill doing?

[11:17] <mberends> pmurias: it's dormant, I have decided to concentrate on Rakudo * until that is released, and LLVM upgrades to 2.7 at the end of March, with some incompatible API changes

[11:30] *** jnthn joined
[11:32] <mberends> \o jnthn

[11:35] *** mkyser left
[11:36] *** iblechbot left
[11:43] *** uniejo joined
[11:56] <jnthn> hi, mberends 

[12:00] <Infinoid> dalek can't seem to find the "ng" branch feed any more.  Is that expected?

[12:01] <jnthn> Infinoid: It has ceased to exist.

[12:01] <jnthn> Infinoid: Became master.

[12:01] <Infinoid> awesome, I'll stop trying to track it then

[12:01] <jnthn> :-)

[12:01] <mberends> Infinoid: it has gone to meet its Maker. It is an ex-branch ;-)

[12:08] <jnthn> Infinoid: Are commits from Rakudo master being reported again now too?

[12:08] <jnthn> Infinoid: Yesterday it appears they weren't...but maybe that's resolved now.

[12:08] *** Sarten-X2 joined
[12:09] <colomon> o/

[12:09] <phenny> colomon: 04:53Z <pmichaud> tell colomon  in dec_number,   try changing  $I2 to $N2  and then switch the call to Rat.new to instead be  &infix:</>

[12:09] <jnthn> hi colomon 

[12:10] <colomon> hello!

[12:12] <Infinoid> jnthn: I think the plugin crashed due to not finding the ng feed

[12:12] <Infinoid> working on that now.

[12:12] <jnthn> Infinoid: Cool, thanks.

[12:13] <Infinoid> (and adding the sanity checks I promised to add, regarding input checking for bad feed data)

[12:14] <mberends> fresh Rakudo checkout does not build on freshly installed Ubuntu 9.10 :-(

[12:15] * jnthn so hopes it's not that they have That Version Of GCC

[12:15] <jnthn> (Though unlikely.)

[12:15] <mberends> gcc 4.4.1-4ubuntu9

[12:16] <jnthn> Oh, phew. 4.1.2/4.1.3 are the ones that had the issue.

[12:16] <Su-Shee> yes. I had this.

[12:17] *** payload joined
[12:17] <jnthn> It's surprising, because compilers are normally perfect peices of software without bugs.

[12:18] <jnthn> ;-) ;-)

[12:18] <mberends> its last gasp is "Killed make: *** [perl6.pbc] Error 137" from perl6.pbc --target=pir src/gen/core.pm > src/gen/core.pir

[12:18] <Su-Shee> well I solved the problem competently by installing a different minor of gcc. ;)

[12:18] <jnthn> Killed?

[12:18] <jnthn> Ouch.

[12:19] <mberends> yep, it musta been very sore

[12:19] <jnthn> Out of memory or something?

[12:21] <mberends> unlikely, but will start gathering more info from a new run

[12:22] <jnthn> Are you working with Parrot HEAD or the one from PARROT_REVISION?

[12:22] <mberends> PARROT_REVISION, from Configure.pl --gen-parrot

[12:23] *** dalek left
[12:23] *** dalek joined
[12:23] <lisppaste3> mberends pasted "Rakudo build failure on Linux/x86" at http://paste.lisp.org/display/95736

[12:26] *** wknight8111 joined
[12:27] <Infinoid> Everything about dalek should be perfect now.  If not, please feel free to scream at me about it

[12:28] <mberends> thanks Infinoid++

[12:30] <jnthn> Exit code 137: The job was killed because it exceeded the time limit. 

[12:31] <jnthn> oh, wait, that might not be a general meaning...

[12:31] <mberends> ah, thanks jnthn++. (Note to self: get a fasta computa)

[12:33] <mberends> (it was relatively unknown that the Rakudo build process has Attention Deficit Disorder)

[12:33] <wknight8111> good morning #parrot

[12:33] <jnthn> fail.

[12:34] <colomon> wknight8111: good morning, but this is #perl6

[12:34] <wknight8111> colomon: Ah, damnit

[12:34] <wknight8111> too early!

[12:34] <mberends> ENEEDCOFFEE

[12:34] <jnthn> wknight8111: No, I don't think you can characterize Perl 6 that way. ;-)

[12:35] <jnthn> mberends: Dunno if it is a time-out style issue though.

[12:35] <jnthn> mberends: Try deleting a chunk of core.pm and see if it works. ;-)

[12:36] <mberends> jnthn: but it fits the Killed message. Doing new fresh builds on x86 and amd64 right now.

[12:37] <jnthn> .oO( Do u limit the time it can run for? :-) )

[12:37] <mberends> that kinda stifles the hope of getting Rakudo into Android any time soon :(

[12:37] * mberends has no limits

[12:40] *** am0c left
[12:40] <jnthn> mberends: Well, there has been ponderings of splitting up the build process, but it creates its own complications.

[12:41] <jnthn> OTOH we do have sub classes workingish now.

[12:41] <colomon> Hmmm... could you have Parrot running on Android and do Perl 6 to PIR conversion on a big machine?

[12:41] <mberends> that sounds like a good hackathon brainstorming topic, along with modularized testing

[12:42] <jnthn> colomon: Yes, true.

[12:42] * colomon would love to have a good excuse to get an Android...

[12:42] <mberends> colomon: good idea. My Android cost me £0.01, plus a 24 month contract...

[12:43] <colomon> nice price!

[12:43] <mberends> It's an LG GW-620 from t-mobile uk

[12:46] <colomon> I'm pretty sure I could convince Verizon to give me a good price for a Droid.  But still probably $100 or so.

[12:46] * uniejo also considers buying an Android - Waiting to see HTC Desire in the shops.

[12:48] <mberends> ah, the failing Ubuntu environment has no swap space, and "only" 1GB RAM :-/

[12:48] *** lisppaste3 joined
[12:49] *** ggoebel joined
[12:50] <uniejo> mberends: If you have disk space you can create a temp swap file and attach to the swap space.

[12:51] <mberends> uniejo: ok, will do that as soon as the latest checkout crashes again

[12:52] <mberends> (there is a partition created for swap, but not yet mkswap'ed)

[12:53] <uniejo> Ok, that should make it work.

[12:54] *** am0c joined
[12:55] <mberends> the parrot process running perl6.pbc has a very volatile virtual memory size, from around 250MB to 380MB. And it just died the same way.

[12:55] <mberends> at least the volatility indicates that GC is working properly

[12:56] * uniejo remember in the early days where recommended swap space used to be less than 200MB. Now i prefer to have about 2G of swap space. It kund of makes the difference between a perl script crashing after doing a lot of processing + data, and doing a slow finish due to swapping.

[12:57] <mberends> a slow finish trumps a crash every time

[12:59] * colomon may need help momentarily getting the PAST right for an infix:</> operation....

[13:05] <uniejo> colomon: Sorry. I do not think that I have enough PAST knowledge to help. What is your problem?

[13:05] <colomon> I'm trying to embed a call to infix:</> in Actions.pm.

[13:06] <colomon> But it actually seems to have "worked" on first try.

[13:06] <uniejo> Great.

[13:06] *** Guest85017 joined
[13:06] <mberends> swap space solved the build problem. parrot perl6.pbc peaked at 593MB

[13:08] <jnthn> Wow!

[13:09] <jnthn> colomon: PAST::Op.new( :pasttype('call'), :name('&infix:</>'), ...args... ) or some such. :-)

[13:10] <colomon> I did

[13:10] <colomon>         make PAST::Op.new( :name('&infix:</>'), :pasttype('call'),

[13:10] <colomon>             $int * $base + $frac, $base

[13:10] <colomon>         );

[13:10] <colomon> which seems to work.  Except that it doesn't actually do the right thing.

[13:10] <jnthn> The PAST production looks sane.

[13:11] <colomon> yeah, no, it's the algorithm that's broke.

[13:20] <colomon> > say 1.1

[13:20] <colomon> 1.1

[13:20] <colomon> > say 1.11111111111111111111111111111

[13:20] <colomon> 1

[13:20] <colomon> > say (1.11111111111111111111111111111).WHAT

[13:20] <colomon> Num()

[13:20] <colomon> > say (1.1).WHAT

[13:20] <colomon> Rat()

[13:24] * uniejo just tested memory usage for a one liner -e 'sleep(100)'. Perl6 uses about 38792 kb and perl 5 about 1260 kb. Rss size from `ps -eo pid,user,args,rss | grep sleep`

[13:27] *** Chillance joined
[13:36] *** xinming_ is now known as xinming

[13:36] *** cgra joined
[13:41] *** cgra left
[13:43] *** lichtkind joined
[13:44] *** lejon joined
[13:44] <lejon> Hi all!

[13:44] <lejon> Does anyone know if there is a standard idiom for doing "file slurp" in perl 6?

[13:44] <lichtkind> hai lejon 

[13:45] <lichtkind> slurp

[13:45] <lejon> Ah!

[13:45] <lejon> :)

[13:45] <lichtkind> $content = slurp $filename;

[13:45] <lichtkind> or @content_lines  = slurp $filename;

[13:46] <lejon> Cool! And that is a "built in" now? (I.e don need to "use" anything...)

[13:46] <lichtkind> yes mam

[13:46] <lejon> Super cool! :)

[13:46] <lichtkind> but i dont know if its implemented already in rakudo

[13:47] <lejon> ok... that would be a pity! :)

[13:47] <lejon> since that's what I'm using...

[13:47] <lichtkind> lejon: yes but perl 6 is huge lang, it cant be done all 

[13:47] <lichtkind> lejon: yes its very practical

[13:47] <lejon> Yep, I do understand that!

[13:48] <lejon> so "slurp" will work both on filenames and filehandles I guess?

[13:49] <lejon> slurp is indeed implemented in Rakudo!! Yay!! :)

[13:49] <lejon> Wat cool!

[13:49] <lejon> I mean, Way cool!

[13:51] <colomon> lichtkind: I don't think @content_lines = slurp $filename works?  Or at least, not the way you'd expect?

[13:51] <lichtkind> lejon: ah does ist also work on handles?

[13:51] <colomon> I would expect that to be @content_lines = lines($filename);  (which is lazy...)

[13:52] <lichtkind> colomon: i think i sae that once in synopses

[13:52] <colomon> $filehandle.slurp works.

[13:53] <lejon> colomon is correct

[13:53] <lejon> but slurp $filehandle did not work...

[13:53] <colomon> lejon: is that in the spec?  It would be easy enough to add....

[13:54] <lichtkind> yeah after reading http://svn.pugscode.org/pugs/docs/Perl6/Spec/S32-setting-library/IO.pod

[13:54] <lejon> dont know, actually...

[13:54] <uniejo> Lines work.   'my @lines = lines "README"; say @lines[2]'

[13:54] <lichtkind> i think colomon++ is right indeed

[13:54] <lejon> I'm testing it in rakudo as we speak :)

[13:54] <lichtkind> i seen

[13:54] <colomon> lines($filehandle) and lines($filename) should both work, I think.

[13:55] <lichtkind> and eager lines will push the laziness out of lines :)

[13:56] <lejon> really super nice, I always missed that in Perl 5

[13:56] <colomon> It's amazing the things you learn implementing enough to get tests to pass.  ;)

[13:57] <lichtkind> colomon: i dont understand

[13:57] <uniejo> Remember that lines in Perl 6 already have the line feed removed, except for slurp.

[13:58] <lichtkind> uniejo: very cool

[13:58] <colomon> lichtkind: I implemented the lazy version of lines and the sub version that takes a filename, both so that we could get more tests passing in spectest.  :)

[13:59] <lichtkind> colomon great

[13:59] <snarkyboojum> colomon++ :)

[14:00] <colomon> well, and I've been waiting lazy lines for about a year now, since I worked out that it would make processing big files drastically more efficient.  :)

[14:00] <colomon> but that still doesn't quite work, because for isn't lazy yet.

[14:02] <lichtkind> colomon: but with rakudo ng it is?

[14:02] <colomon> lichtkind: rakudo is rakudo ng now.

[14:02] <colomon> or the other way around, I guess.

[14:03] <colomon> I believe pmichaud++ doesn't have lazy for working yet. 

[14:04] <colomon> lines is lazy, if you did something like lines("hugefile").grep(/something-to-look-for/).eager, it would only use the memory needed to store the lines that matched the grep, not the entire file.  (module garbage collection issues)

[14:05] <uniejo> The branches moved like this on last swap: master => alpha  and  ng => master

[14:05] <colomon> but for lines("hugefile") -> $line { whatever } will still read the entire file into memory at once, I believe.

[14:10] <pmichaud> no, lines() is lazy.

[14:10] <lejon> Does anyone have and hints or pointers on how to debug Perl 6 grammars?

[14:10] <colomon> pmichaud: right, but is for lazy yet?

[14:10] <colomon> I thought you'd disabled that last I heard.

[14:11] <mberends> lejon: start with small things that work, then test everything you add

[14:11] <lichtkind> mberends: cheers

[14:11] <lichtkind> mberends: i lost you yesterday

[14:11] <mberends> lichtkind: prost

[14:11] <lichtkind>  had network problems

[14:11] <lichtkind> mberends: :)

[14:12] <jnthn> In theory, isn't for essentially just sugar for map these days?

[14:12] <pmichaud> for isn't lazy yet.

[14:12] <pmichaud> yes, for is just sugar for map

[14:13] <jnthn> OK, and we have lazy map, so "in theory" it should be easy. ;-)

[14:13] <pmichaud> essentially    for something { block }  ===>    list(something).map({ block })

[14:13] <pmichaud> I haven't switched it because we don't have 'sink' yet.

[14:13] <jnthn> Ah

[14:13] <jnthn> Yeah, it'd occurred to me that to do it now would mean a hack that tacks .eager on the end...

[14:14] <jnthn> But probably better to wait for sink context.

[14:14] <pmichaud> also, we need .map to be smart enough to handle next/last/redo exceptions.

[14:16] <pmichaud> (re: http://lastofthecarelessmen.blogspot.com/2010/02/e03-laziness-catch.html)   After a bit of discussion on this last night, I'm thinking we don't really know how array binding works yet.  :-(

[14:18] <jnthn> Ouch :-(

[14:23] <pmichaud> 14:09 <lejon> Does anyone have and hints or pointers on how to debug Perl 6 grammars?

[14:23] <pmichaud> lejon: rakudo (master, not alpha)  also has a <?DEBUG> rule that traces the progress of the grammar.

[14:23] <pmichaud> I guess I should add grammars back into master today :0|

[14:24] <pmichaud> afk for a bit

[14:24] <lejon> Aha, cool! Will try it

[14:24] <lejon> Thanks for that!

[14:25] <colomon> Is there some reason why we can't just say that if you assign an iterator to a @var, it becomes a lazy Array?

[14:25] <colomon> err, except that it makes writing lazy subs impossible without directly addressing the iterator.

[14:26] <colomon> yeah, this is Trouble with a capital T.

[14:26] <colomon> (well, the sub could be lazy, but the full Array would be built in memory at some point.)

[14:27] <lejon> sorry for my ignorance here but would the #25 Minneapolis release be on the "Master" track?

[14:27] * colomon was also pondering that perhaps Iterators should derive from Mu rather than Any, but since Iterators are Iterable, that just makes another mess...

[14:27] <lejon> i.e support the <?DEBUG> rule?

[14:29] <colomon> lejon: #25 was under the old master.  which I guess makes it more likely to support <?DEBUG> than #26...

[14:30] <lejon> ok, thanks, added it as the first rule, but I don't really see any effect of it... hmm...

[14:31] <colomon> sorry, I'm fairly grammar ignorant.  

[14:31] <lejon> :)

[14:33] <colomon> > say 1.777777777777777777777

[14:33] <colomon> 0.99999999999861

[14:33] <colomon> is not an improvement.  :(

[14:37] *** masak joined
[14:37] <masak> oh hai, #perl6

[14:37] <phenny> masak: 05:14Z <lue> tell masak  the past wants him to come back here and answer some questions about the TARDIS

[14:37] <masak> Tene: I think we might have discussed this before, but if so, I've forgotten. where and why are you blocking on spec wrt macros?

[14:38] <masak> rakudo: say True ~~ 42

[14:38] <p6eval> rakudo a7403f: OUTPUT«0␤»

[14:38] *** uniejo left
[14:39] <colomon> masak: o/

[14:39] <jnthn> colomon: As approximations go...that one sucks.

[14:39] *** uniejo joined
[14:40] <jnthn> :-/

[14:40] <colomon> jnthn: yes.

[14:41] <pmichaud> <?DEBUG> doesn't exist in alpha

[14:42] <pmichaud> (so it's not in Minneapolis)

[14:42] <colomon> ah.

[14:42] <colomon> does it exist in master?

[14:43] <pmichaud> yes.

[14:43] <pmichaud> but grammars don't exist in master yet

[14:43] <pmichaud> thus  14:23 <pmichaud> I guess I should add grammars back into master today :0|

[14:43] <colomon> darned if you do, darned if you don't.  :)

[14:44] <pmichaud> I'm fine with saying that binding an iterator to a @var creates an Array; but that opens up all sorts of other issues.

[14:44] *** masak left
[14:44] <colomon> yeah, I figured that out for myself.  :(

[14:44] <colomon> it seems like a very thorny problem.

[14:44] <mberends> pmichaud: rod.create( :back(self) );

[14:44] <pmichaud> one of the nastier ones being that the elements of the array still need to be bound to the elements of the iterator -- i.e., they aren't copies.

[14:45] <pmichaud> (which is different from array assignment, where the elements are copies)

[14:45] <jnthn> I still do wonder if we're letting iterators leak out too much.

[14:46] <pmichaud> jnthn: we may be,  but I think that aspect is actually orthogonal to this problem :-|

[14:46] <jnthn> But I guess we can't help that.

[14:47] <pmichaud> my guess at this point is that we're trying to be a bit too clever in saying that @-sigil binds to anything Positional

[14:47] <pmichaud> because most people expect @ to behave like Array, and not every Positional acts like an Array

[14:48] <lejon> pmichaud: ok, I see, I just started experimenting with this yesterday so I'm not entirely clear on the different tracks... :)

[14:48] <pmichaud> lejon: in absence of <?DEBUG> -- the recommendation is to do as mberends suggested:  use small incremental changes to the grammar and test frequently.

[14:49] <jnthn> Well, I see it as a conflict between desire to keep values reified, or just to produce them and throw them away.

[14:49] <jnthn> Or at least it's partially that.

[14:49] <jnthn> When the iterator is bound the @a, we expect it to have Seq-ish semantics.

[14:49] <pmichaud> yes, partially that

[14:49] <lejon> *nod* I started playing with one of the example grammars ("CSSGrammar")... just to get into it..., will try to break things down...

[14:50] <pmichaud> but we also want things bound to @a to have throw-it-away semantics

[14:50] <pmichaud> which Seq doesn't have.

[14:50] <colomon> pmichaud: right, that's the real sticking point in my mind.

[14:51] <pmichaud> which tells me that @ should in fact mean "Array" and not just "Positional"

[14:51] *** lejon left
[14:51] *** lejon joined
[14:51] <lejon> oops..

[14:51] <colomon> I don't see how that follows?

[14:51] <pmichaud> colomon:  if we want throw-it-away semantics, we need to be able to shift

[14:52] <pmichaud> actually, rephrase

[14:52] <colomon> ah, didn't understand what you meant by throw-it-away.  maybe.

[14:52] <TimToady> maybe Seqs are mutable/immutable in the same sense as Strs

[14:52] <TimToady> so you could shift one, but the identity changes

[14:53] <pmichaud> most people expect @a to remember all of the values until explicitly told to forget one, thus if we want throw-it-away semantics we need to be able to shift

[14:53] <pmichaud> TimToady: yes, I'd been brainstorming something like that a short while ago (offline, not on #perl6)

[14:54] <pmichaud> but then it feels like we should just use Array.  Or perhaps the difference between Seq and Array becomes the way its elements are bound

[14:56] <TimToady> perhaps we should stick with more of a p5ish model of mutability until we find the optimizer needs Seq and immutable Strs

[14:56] <TimToady> then negotiate

[14:56] <pmichaud> in addition to binding to iterators, we want to be able to handle binding to other positionals as well.  for example,    my @a := 1..100000;

[14:57] <pmichaud> if @a is bound to a range (which does Positional), we still want to be able to process the elements with throw-it-away semantics

[14:57] <pmichaud> so that somewhat implies that @a is something other than the Range directly

[14:58] <pmichaud> (p5ish model)  yes, that seems like a possibility also

[15:00] <TimToady> maybe we somehow need to unify arrays and iterators, such that getarg is the same as shift

[15:00] <TimToady> and since arrays track known/unknown

[15:00] <TimToady> you don't get positional elements till you request them

[15:00] <pmichaud> I think that helps, yes, but I'm not sure it resolves the dilemma fromt he post

[15:00] <pmichaud> *from the

[15:00] <TimToady> and any shift on a pure iterator just pulls straight from the queue

[15:01] <TimToady> haven't backlogged

[15:01] <pmichaud> (the one from last night)

[15:01] <pmichaud> i.e.,   if @a is bound to an iterator,  people still expect +@a to not consume the iterator

[15:01] <TimToady> it wouldn't, if that's considered a reifying operation

[15:01] <TimToady> only shift consumes it

[15:02] <pmichaud> in which case the iterator "has memory" by default, or @a is something other than an iterator

[15:02] <TimToady> +@a would only copy the internal extender iterator into reified values, logically

[15:02] <pmichaud> so then @a is really an Array

[15:02] <TimToady> evey array is a reified section plus an iterator

[15:02] <TimToady> either of which can be empty

[15:03] <pmichaud> right, I'm saying that @a isn't an iterator, then.

[15:03] <lisppaste3> colomon pasted "What's worrying me..." at http://paste.lisp.org/display/95738

[15:03] <pmichaud> (it's an iterable, but not an iterator)

[15:03] <TimToady> it is if you shift it

[15:04] <TimToady> fundamentally unifies shift and getarg

[15:04] <pmichaud> sure, I was in favor of that from the beginning (weeks ago)

[15:04] <TimToady> so there is not getarg anymore

[15:04] <TimToady> or getarg is shift, and get can unpack a 'sub-shift'

[15:04] <pmichaud> I'm just trying to figure out what really happens when we bind to a @-sigiled variable

[15:06] *** Trashlord left
[15:06] <TimToady> if everything is using the Array interface, it becomes simple again

[15:07] <pmichaud> right, so   my @a := gather { ... };   means that @a is in fact an Array, and not the lazy iterator thing returned by gather (more)

[15:07] <pmichaud> or, gather returns an Array with its lazy portion already established

[15:07] <TimToady> @a is a lazy iterator thing returned by gather that knows the Array interface already

[15:08] <colomon> "already established"?

[15:08] <TimToady> an iterator is just an array with no reified part (yet)

[15:08] <pmichaud> but I'm not sure what to do with    my @a := 5..1000;

[15:09] <pmichaud> or an array is just an iterator with a reified part :-)

[15:09] <TimToady> well, we still probably need the concept of getting an iterator from an iterable, but in this case it would present an Array interface as soon as it's an iterator

[15:10] <pmichaud> for reference, I mused about .shift and .get some time ago:  http://irclog.perlgeek.de/perl6/2010-01-23#i_1923841

[15:10] <pmichaud> it does tend to want an interface other than return EMPTY, though.

[15:10] <TimToady> but I think shift is really getarg, and get can pull stuff out of @a[0]

[15:11] <TimToady> maybe

[15:11] <TimToady> could be the other way

[15:11] <TimToady> I guess p5 is more get == shift

[15:11] <TimToady> i.e. flattening

[15:11] <pmichaud> so, in the case of   my @a := 5..1000;     the binding actually grabs an iterator from the range?

[15:12] <pmichaud> (or otherwise builds an Array that has a Range in its lazy portion?)

[15:14] <TimToady> well, any binding of immutable to mutable either has to fail or copy somehow

[15:14] <TimToady> maybe such a binding turns into assignment?

[15:14] <pmichaud> well, we don't exactly want assignment

[15:15] <pmichaud> because with   my @a := @b;   the elements of @a need to be the same as @b

[15:15] <TimToady> but you want to poke a RangeIterator into the Array imaginary bit

[15:15] <jnthn> TimToady: Do you see @ as implying mutability as well as Positional?

[15:15] <TimToady> I think that's what we're being driven toward currently

[15:15] <jnthn> OK

[15:16] <pmichaud> mutability for the array, but not necessarily for its elements

[15:16] <jnthn> Yes - that's a good distinction to draw.

[15:16] <pmichaud> i.e., we can shift the array, but not necessarily modify the elements in the array

[15:16] <jnthn> nod

[15:17] <TimToady> and a Str is an Array of NFG chars, probably

[15:17] <TimToady> presumably compact

[15:18] <TimToady> I think it's okay to have intermediate lazy iterator types, as long as they're only ever hidden in the imaginary part of an array

[15:18] <pmichaud> so, is there a method that gets called on an object that says "return something I can bind to an array?"

[15:19] <pmichaud> I'd be very happy if we could hide all of our iterators behind Array

[15:19] <TimToady> from the standpoint of human engineering, I think that would be a win too

[15:19] <pmichaud> well, that's why I'd be happy :)

[15:19] <TimToady> I shudder every time .WHAT returns GatherIterator

[15:19] <pmichaud> same here.

[15:19] <lichtkind> does .get also autochomp?

[15:20] <pmichaud> but a question:  if .shift is the normal way to iterate over elements of an Array, how do we signal end-of-iteration?

[15:20] *** meppl joined
[15:20] <TimToady> let's trying unifying them, then, and if it's the right decision, other things should get simpler, though Array itself has to always know both parts

[15:20] <TimToady> same way?

[15:20] <pmichaud> so, shifting an empty array returns Empty ?

[15:20] <TimToady> yeah

[15:21] <pmichaud> that feels weird, but okay.  Same for .pop ?

[15:21] <TimToady> we need to take the best parts about Arrays and Iterators and smush them together

[15:21] <TimToady> and people who use +@array to mean ?@array will need to learn that ?@array doesn't have to count all the elements

[15:21] <lichtkind> colomon: does .get also autochomp?

[15:21] <TimToady> whiel +@array does

[15:21] <TimToady> *while

[15:22] <pmichaud> yes, I noticed that also. (more)

[15:22] <colomon> lichtkind: pretty sure yes.

[15:22] <pmichaud> I almost wrote that as a comment to the post, but couldn't find a diplomatic way to say it :)

[15:22] <colomon> really?

[15:23] <pmichaud> (it was late)

[15:23] <colomon> Not the diplomatic bit, the ?@array bit.

[15:23] <pmichaud> sure

[15:24] <pmichaud> ?@array simply means "is the array empty?"  We can figure that out by just producing a single element (or not)

[15:24] <pmichaud> +@array means "how many elements do you have?"   That requires producing them all.

[15:24] <lichtkind> colomon: thanks

[15:24] <colomon> I don't recall ever seeing that used, there are a lot of places in the core where that would come in handy....

[15:24] <pmichaud> in the posting, the code said

[15:24] <pmichaud> sub sum(@a) { +@a ?? @a.reduce(...) !! 0 }

[15:24] <pmichaud> much better would've been  ?@a  instead of +@a

[15:24] <TimToady> well, it's still the case that you usually just want to do what you're doing and check for Empty afterwards

[15:25] <pmichaud> and since the part before ?? is in boolean context already, one could even omit the ? and/or + altogether

[15:25] <TimToady> and we haven't really solved the get vs getarg problem yet

[15:25] <pmichaud> TimToady: correct

[15:25] <pmichaud> my guess is that getarg is really a shift on a Slicel

[15:26] <TimToady> don't think it can be that simple

[15:26] <colomon> pmichaud: My perception has been that @a in boolean context tests definedness rather than quantity of elements.

[15:27] <TimToady> param binding is currently defined in terms of get vs getarg on the same sequence

[15:27] <TimToady> colomon: no, it tells that the array isn't empty

[15:27] <colomon> TimToady: I don't mean in theory, I mean in practice.

[15:27] <pmichaud> TimToady: then in general, things like gather, map, etc. tend to return Slicels instead of Arrays, and binding to an Array flattens the Slicel

[15:27] <TimToady> an empty array is defined

[15:27] <jnthn> colomon: .Bool by default looks at .defined, but for arrays it should be overrideen.

[15:27] <lichtkind> colomon: thanks for helping me with http://www.perlfoundation.org/perl6/index.cgi?action=revision_compare&page_name=perl_6_index_tablet&mode=source&Button=Compare+Revisions&new_revision_id=20100228152713&old_revision_id=20100227005830

[15:27] <TimToady> but false

[15:27] <jnthn> s/dee/dde/

[15:28] <lichtkind> mberends: still there?

[15:28] <TimToady> have to go shower, but will think about shift vs flat/slice semantics

[15:28] <colomon> rakudo: my @a;  @a ?? say "True" !! say "False"

[15:28] <TimToady> afk &

[15:28] <pmichaud> okay.  I'll start on an Array/Iterator unification

[15:28] <p6eval> rakudo a7403f: OUTPUT«True␤»

[15:29] <pmichaud> rakudo is wrong there.

[15:29] <colomon> pmichaud: but that's why I've been using +@a or @a.elems in code for that.  :)

[15:29] <pmichaud> then it's been wrong for a long time.

[15:29] <pmichaud> alpha:  my @a;  say @a ?? 'True' !! 'False';

[15:29] <p6eval> alpha 30e0ed: OUTPUT«False␤»

[15:29] <pmichaud> but apparently not too long :)

[15:30] <colomon> rakudo: my @a;  ?@a ?? say "True" !! say "False"

[15:30] <p6eval> rakudo a7403f: OUTPUT«True␤»

[15:30] <pmichaud> rakudo is still wrong there :-)

[15:30] <pmichaud> alpha:  my @a;  ?@a ?? say 'True' !! say 'False'

[15:30] <p6eval> alpha 30e0ed: OUTPUT«False␤»

[15:30] <pmichaud> alpha is right again 

[15:31] <colomon> What can I say, I've been programming in ng for four months now.  :)

[15:31] <pmichaud> as I've been saying, using @a.elems is code smell

[15:31] <pmichaud> because we're forcing something lazy to become eager

[15:32] <colomon> .elems is pretty necessary for dealing with negative index arguments in array functions.

[15:32] <colomon> but yeah, lazy is good.

[15:32] <pmichaud> sure, in that case it's fine

[15:33] <pmichaud> .elems when explicitly needing to talk about positionals is probably okay

[15:33] <pmichaud> but .elems just to check for emptiness, or to process elements n-at-a-time is wrong

[15:34] <dalek> rakudo: 67f51f7 | moritz++ | src/cheats/match-bool.pm:

[15:34] <dalek> rakudo: cheat in Regex::Match.defined

[15:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/67f51f786c3f8440fccba4c76fb0201b264b1ee9

[15:34] <dalek> rakudo: d4df605 | moritz++ | t/spectest.data:

[15:34] <dalek> rakudo: more passing test files

[15:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d4df605f714c3532e47383e46042d5cdd7936560

[15:34] <dalek> rakudo: 1a5d342 | moritz++ | Test.pm:

[15:34] <dalek> rakudo: [Test.pm] diag() actual type of failed isa_ok() test

[15:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1a5d34263fb9421dfe00adc525de7f98c487b393

[15:39] <colomon> So, are there tests for Array.Bool out there somewhere?

[15:42] <colomon> Seq.Bool, I mean.

[15:42] *** Psyche^ joined
[15:46] *** Patterner left
[15:46] *** Psyche^ is now known as Patterner

[15:50] <pmichaud> I don't know if there are or not.  There need to be :)

[15:51] <colomon> I've got it coded up.

[15:51] <colomon>     multi method Bool() {

[15:51] <colomon>         self!fill(1) ?? Bool::True !! Bool::False;

[15:51] <colomon>     }

[15:51] <colomon> It tests okay by hand.

[15:54] *** dual left
[15:56] <colomon> So, is it kosher to have side effects in iterators for tests?

[16:01] <colomon> Or perhaps more sensibly, do we have a testing method that can test whether or not an iterator has been completely iterated?

[16:02] *** iblechbot joined
[16:08] *** pmurias left
[16:13] <mberends> lichtkind: pong

[16:14] <lichtkind> ah

[16:15] *** Guest85017 left
[16:15] <pugssvn> r29886 | colomon++ | [t/spec] Some basic tests for Seq.Bool / Array.Bool. 

[16:19] <mberends> colomon: git pull before you commit, t/spectest.data just pushed

[16:19] <colomon> mberends++

[16:20] <dalek> rakudo: 7ef1ac2 | (Martin Berends)++ | t/spectest.data:

[16:20] <dalek> rakudo: [t/spectest.data] re-enable S28-named-variables/inc.t, all 3 pass (@*INC)

[16:20] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7ef1ac209d446d8de2b8a6a2c86ec44260dfe7f0

[16:23] <diakopter> hm

[16:29] <mberends> is there an example anywhere of a tied hash written in PIR?

[16:33] <jnthn> mberends: Did we ever ascertain that just taking an instnace of the Env PMC and passing it to '&CREATE_HASH_LOW_LEVEL' and sticking what's returned in the namespace wouldn't work?

[16:34] <mberends> jnthn: we never tried exactly that, you did warm that it might go *boom* ;)

[16:34] <jnthn> It might, but it fight be FANTASTIC.

[16:34] <jnthn> *might

[16:35] <mberends> the env PMC is standing by... 100. 99. 98. 97...

[16:35] <colomon> jnthn: t/spec/S32-scalar/defined.t has two failures, looks like it might be Nil?

[16:39] <colomon> rakudo: say defined(Nil)

[16:39] <p6eval> rakudo 67f51f: OUTPUT«0␤»

[16:41] <jnthn> colomon: erm

[16:41] <jnthn> TimToady went and spec'd that this is True, iirc

[16:41] <jnthn> Unfortunately, I'm a bit...bewildered...still on that.

[16:41] <jnthn> Since along with $foo.?does_not_exist returns Nil

[16:41] <jnthn> That menas things like

[16:42] <jnthn> $foo.?does_not_exist // 2 # breaks

[16:42] <jnthn> We rely on that working somewhere in the setting.

[16:42] <jnthn> It may be that the code in the setting has wrong expectations.

[16:43] <colomon> I'm very confused by the spectest results, but none of it seems to be related to what I just did...

[16:43] <dalek> rakudo: f2975bf | (Solomon Foster)++ | t/spectest.data:

[16:43] <dalek> rakudo: Add new test file S32-array/bool.t.

[16:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f2975bff9599fcb8251a58e8452e6217c56f023c

[16:43] <dalek> rakudo: d42198a | (Solomon Foster)++ | src/core/Seq.pm:

[16:43] <dalek> rakudo: Implement Seq.Bool.

[16:43] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/d42198a94fa53764080fa64aba276a82ca16736b

[16:43] <jnthn> colomon: I changed Nil to be undefined yesterday.

[16:43] <jnthn> hang on, let me re-read the spec ommit

[16:43] <jnthn> to be sure I actually understood it

[16:44] <colomon> but it looks like the test that is failing is testing for Nil to be undefined...

[16:44] <jnthn> oh.

[16:44] <jnthn> Since method calls are performed directly on

[16:44] <jnthn> +any object, C<Nil.defined> returns C<True> just as C<().defined> does.

[16:44] <colomon> not ok 13 - variable $foo is now undefined again

[16:45] <colomon> $foo = Nil;

[16:45] <colomon> ok(!defined($foo), 'variable $foo is now undefined again');

[16:45] <jnthn> hmm

[16:46] <jnthn> rakudo: my $foo = 42; say defined($foo); $foo = Nil; say defined($foo)

[16:46] <p6eval> rakudo 7ef1ac: OUTPUT«1␤1␤»

[16:46] <jnthn> rakudo: say defined(Nil)

[16:46] <p6eval> rakudo 7ef1ac: OUTPUT«0␤»

[16:46] <jnthn> rakudo: my $foo = Nil; say $foo.WHAT

[16:46] <p6eval> rakudo 7ef1ac: OUTPUT«Seq()␤»

[16:46] <jnthn> Oh.

[16:47] <mberends> jnthn: it's half of FANTASTIC (FANTA). %*ENV didn't go boom, but it's read-only ;-)

[16:47] <jnthn> Lemon or orange?

[16:47] <jnthn> :-)

[16:47] <mberends> sweet lemon

[16:47] <jnthn> mmm

[16:48] <jnthn> Would go well with stroopwafels.

[16:48] <jnthn> .oO( Yay, I goes to Holland for a couple of days next week! )

[16:48] <mberends> aw, that was my surprise for you ;)

[16:48] <colomon> anyway, I had four spectests fail, so our tests have gotten messy again.

[16:48] <jnthn> colomon: Fails thare are there without your patches?

[16:48] <jnthn> OK, probably my-- fault.

[16:49] *** dual joined
[16:49] <jnthn> mberends: What happens when you try to write to it?

[16:49] <jnthn> "Cannot assign to readonly..."?

[16:49] <colomon> I dunno, I made changes and then did a pull --rebase, so I don't know before and after.

[16:50] <mberends> xactly

[16:50] <colomon> let me revert locally and see...

[16:50] <jnthn> mberends: I think I know why, I've not a solution immediately to hand.

[16:50] <mberends> jnthn: there may be a way to add a role that intercepts the writing

[16:50] <jnthn> Yes

[16:51] <jnthn> Maybe

[16:51] <jnthn> Well

[16:51] <mberends> shall I commit the read-only code?

[16:51] <jnthn> It's osrt of an assign/binding mis-match too.

[16:51] <jnthn> Yes, it's progress.

[16:51] <jnthn> It enables CGIs! ;-)

[16:51] <mberends> yes, and microbenchmarks

[16:52] <jnthn> \o/

[16:52] *** justatheory joined
[16:54] <pmichaud> (Nil and defined)   I'm pretty sure that it should be defined.

[16:54] <jnthn> pmichaud: I can go with that, I just need an answer on my .? question :-)

[16:55] <jnthn> That is, if I do $foo.?does_not_exist and get Nil back, how do I test if a method was called or not, and then provide the alternate value?

[16:56] <pmichaud> I'm not sure that .?does_not_exist should really be returning Nil.

[16:57] <jnthn> Awww!

[16:57] <pmichaud> (Yes, I know it got speced that way... I'm just not sure it works out)

[16:57] <jnthn> Yeah, it all worked out nicely when Nil was undefined, which is why it all made sense to me at the time. :-)

[16:58] <pmichaud> well, until a few weeks ago we had .?does_not_exist returning undef/failure

[16:58] <jnthn> Yeah

[16:58] <jnthn> But failure was deemed "too strong" or something.

[16:58] <jnthn> (That is, you wrote .?)

[16:58] <jnthn> (So you said it's OK if the thing isn't there)

[16:59] *** ggoebel left
[17:00] <pmichaud> well, would someone do     .*method // 2   ?

[17:00] *** ggoebel joined
[17:00] <dalek> rakudo: 40f0e06 | (Martin Berends)++ | src/glue/run.pir:

[17:00] <dalek> rakudo: [glue/run.pir] add a crafty read-only %*ENV suggested by jnthn++

[17:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/40f0e06e9a39757f0e3aa1b02ed325f83989ff1b

[17:01] <jnthn> Maybe not, but the use-cases differ.

[17:01] <colomon> jnthn: yup, all failures without my patch, too.

[17:01] <colomon> *happen

[17:01] <jnthn> .* = call all available things - I'm expecting some (maybe empty) list of results.

[17:01] <jnthn> Same with .+

[17:02] <jnthn> With .? it makes sense that you'd usually want to substitute another value if there wasn't one returned.

[17:02] <jnthn> erm

[17:02] <pmichaud> this sounds like the same issue we had at one point with +/*/? in regexes

[17:02] <jnthn> if there wasn't a method to call

[17:02] <jnthn> There may be an analogy, yes.

[17:02] <pmichaud> perhaps .? should always return a list

[17:03] <pmichaud> just like  <xyz>?  always creates an array

[17:03] <jnthn> Hm

[17:03] <pmichaud> if so, then

[17:03] <jnthn> Then you can just use ||

[17:03] *** Achilles333 joined
[17:03] <pmichaud>     my $result = $obj.?no_such_method[0] // 2

[17:03] <jnthn> Yeah

[17:03] <jnthn> That [0] feels like a smell though.

[17:03] <pmichaud> well, it's what we do in regexes

[17:04] <jnthn> Yeah, and I trip over it there too. :-)

[17:04] <pmichaud> so that would be more consistent

[17:04] <jnthn> Yes, consistent I agree on.

[17:04] <jnthn> Though I can agree to inconsistency through difference use case too, so... :-)

[17:05] *** ggoebel left
[17:10] *** xomas_ joined
[17:14] *** ggoebel joined
[17:16] *** ggoebel left
[17:16] *** lejon_ joined
[17:18] *** lejon left
[17:18] *** lejon_ is now known as lejon

[17:19] *** lue joined
[17:22] <lue> hello!

[17:24] *** ggoebel joined
[17:29] *** Achilles333 left
[17:31] <pmichaud> lue: o/

[17:31] *** xomas_ left
[17:31] <lue> o/

[17:31] <lue> (geez it's quiet right now...)

[17:32] <pmichaud> yes, I think the latest round of "omg the spec is changing" kinda threw everyone off for a bit.  :)

[17:33] <pmichaud> TimToady:  a few thoughts about array/iterator/etc.

[17:34] <pmichaud> (coming over several input lines)

[17:34] <lue> the spec did what?

[17:35] <pmichaud> - I think we might want to go back to the notion of 'List' as a fundamental type

[17:35] <dalek> rakudo: b4ccaa0 | (Solomon Foster)++ | src/core/A (2 files):

[17:35] <dalek> rakudo: Switch to ?@array in a couple of places.

[17:35] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b4ccaa0d7837771c0f75f6939b0326b47ab658c4

[17:35] <pmichaud> - List itself can do shift/unshift/push/pop, so its "mutable" in that sense

[17:36] <pmichaud> - in this sense, List would replace our current notion of Seq

[17:36] *** Trashlord joined
[17:36] <pmichaud> - the main difference between List and Array is that List holds references to the things it iterates (e.g., if iterating a list of containers), while Array copies the values

[17:37] <pmichaud> - the primary meaning of @ is "does List"   (and Array ~~ List)

[17:38] <pmichaud> - we might be able to retain the notion of @ as being "does Positional", but we then need to figure out what we want to do with something like   my @a := 1..10000;

[17:38] <lue> I don't know why, but seeing Seq makes me think of sed and some cool-looking character in a Capcom game...

[17:39] <pmichaud> - although I guess we have to figure out the meaning of   my @a := 1..100000;   anyway, as it's clear @a has to be bound to a List and not to the Range directly.

[17:39] <pmichaud> - (end of thoughts for now)

[17:42] <lue> rakudo: my @a=0..*; @a[Inf]=3; say @a[Inf];

[17:42] <p6eval> rakudo 40f0e0: OUTPUT«Cannot use negative index on arrays␤current instr.: '&die' pc 16676 (src/builtins/Junction.pir:347)␤»

[17:42] <lue> ...what?

[17:43] <lue> rakudo: my @a=0..*; @a[+Inf]=3; say @a[+Inf];

[17:43] <p6eval> rakudo 40f0e0: OUTPUT«Cannot use negative index on arrays␤current instr.: '&die' pc 16676 (src/builtins/Junction.pir:347)␤»

[17:43] <lue> ô.ō

[17:43] <moritz_> rakudo: say Inf < 0

[17:43] <p6eval> rakudo 40f0e0: OUTPUT«0␤»

[17:45] <pmichaud> afk # lunch

[17:45] <arnsholt> rakudo: Inf > 0

[17:45] <p6eval> rakudo 40f0e0:  ( no output )

[17:45] <arnsholt> rakudo: say Inf > 0

[17:45] <p6eval> rakudo 40f0e0: OUTPUT«1␤»

[17:46] <lue> I expected an error with my array code, but not a negative index error!

[17:49] *** nihiliad joined
[17:50] <moritz_> lue: please file a bug report

[17:50] *** ggoebel left
[17:51] *** ggoebel joined
[17:53] <lue> where doth I 'file' this, how you call it, 'bug report' ?

[17:54] <moritz_> lue: send a mail to [email@hidden.address]
[17:54] * moritz_ gets lots of spectest failures :(

[17:55] *** ggoebel left
[17:58] <lue> I'm not used to filing a bug report for rakudo. Usually, I find a bug, we discuss it, and someone starts to fix it :D

[17:58] *** TiMBuS joined
[17:58] <moritz_> lue: time to get used to it

[17:58] <moritz_> lue: it's not hard

[17:59] <moritz_> lue: just copy&paste what you did, and the explanation that the error message is simply wrong

[18:02] *** payload left
[18:05] <colomon> rakudo: say Inf.Int

[18:05] <p6eval> rakudo 40f0e0: OUTPUT«-9223372036854775808␤»

[18:05] *** amindfv left
[18:07] <lue> ...wow, it's not sending. (Maybe that's a sign) :D

[18:09] <colomon> pmichaud: my only objection to your new List idea is it still prevents us from writing memory-efficient lazy subs without diving down to the iterator level.

[18:09] *** ggoebel joined
[18:11] <lue> I think I'll leave rakudobug for other people to use. I can't send the email (honest!) :)

[18:12] *** ggoebel left
[18:16] *** athenot joined
[18:16] <jnthn> colomon: Is the problem that sub foo(@x) { @x.grep(/bar/) } at some point will reify everything?

[18:16] <jnthn> colomon: Or put differently:

[18:16] <colomon> jnthn: yes, that's what I'm worried about.

[18:16] <lue> jnthn: o/ read last night's backlogs? :)

[18:17] <jnthn> for foo(lines($file)) -> $line { ... }

[18:17] <jnthn> lue: I hear I gets a sub.

[18:17] <jnthn> :-P

[18:17] <lue> oh yes. And uncovering several key details about P6 subs in the process...

[18:17] <colomon> exactly.  I'm worried that ....

[18:18] <jnthn> colomon: Yeah, I was just tracing where we reify and keep all the stuff around.

[18:18] <colomon> for lines($file).grep(/bar/) -> $line { ... }

[18:18] <colomon> will be much more efficient than the foo version.

[18:18] <colomon> (well, actually I'm worried that the foo version will be less efficient, but you know what I mean)

[18:19] <jnthn> colomon: It occurs to me that the problem isn't so much inside the sub itself (that grep would be lazy), but that the thingy the sub returns will keep the data around.

[18:19] <jnthn> As the for loop iterates over it.

[18:20] <colomon> jnthn: the grep would be lazy, but if @x reifies as it is iterated, it will create a potentially huge array which is completely unnecessary.

[18:20] *** eternaleye left
[18:20] <jnthn> colomon: Right

[18:20] <colomon> I would assume the result of the grep (in foo) would be lazy as well.

[18:20] <jnthn> colomon: Was just working through at one point we hit the problem.

[18:21] <jnthn> But agree we hit it. Hmm.

[18:21] <colomon> It just looks like we might be very lazy and still waste boatloads of memory.

[18:21] <jnthn> Right, which is a srs DO NOT WANT.

[18:22] <jnthn> I agree that ideally developers shouldn't have to drop to iterator semantics just to factor a grep or two out into a sub.

[18:23] <colomon> so the goal is to make sub baz(@x) { @x.grep(/bar/) Z @x.grep(/quux/) } work without making your foo waste memory.

[18:25] * jnthn 's brain implodes.

[18:26] <lue> what about foobar then :D

[18:28] <lue> jnthn: at least it wasn't the mess of an *ex*plosion :)

[18:29] *** eternaleye joined
[18:30] <jnthn> Yes, I am occasionally considerate.

[18:33] <colomon> I'm starting to suspect there may be no way to do it (short of clever optimizations).

[18:34] <jnthn> colomon: Yes, it's a tricky one.

[18:39] <lue> I would love to help, but I do not know anything of this problem :(

[18:41] *** abra joined
[18:42] <colomon> jnthn: are we working too hard at this?

[18:42] <colomon> sub foo(@x is iter) { @x.grep(/bar/); }

[18:43] <colomon> If you declare "is iter", then your @x is really an iterator, without memory.

[18:43] <colomon> If you don't, it becomes a Seq or something, with full memory.

[18:44] <TimToady> no, if shift == get, then we don't have a problem with arrays keeping stuff around

[18:45] <colomon> TimToady: er, yes we do.

[18:45] <TimToady> no, we don't

[18:45] <colomon> oh, I see.

[18:46] <colomon> no, wait.

[18:46] * jnthn doesn't see it.

[18:46] <colomon> see the @x.grep Z @x.grep example

[18:46] <colomon> versus just @x.grep once.

[18:46] <colomon> how can you write grep so that it consumes @x in the second case and not in the first?

[18:47] <jnthn> Right. In the first we only want to consume the values in the iterator once.

[18:47] <jnthn> Implying we need to somehow keep them around

[18:47] <jnthn> In the second case we don't need to keep them around, but how to know?

[18:48] <TimToady> unfortunately, can't talk right now...

[18:51] <jnthn> np

[18:57] <lue> getting the jnthn() sub to do everything is a stretch... especially when one wants to use use infix, postfix, etc.

[19:04] *** abra left
[19:09] <lue> alpha: multi sub infix:<jnthn>($a, $b){say "$a only a test $b";};multi sub postfix:<jnthn>($a){say "$a !";};say 3 jnthn 4; say "hi"jnthn;

[19:09] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "jnthn;"␤in Main (file <unknown>, line <unknown>)␤»

[19:09] <pmichaud> colomon: false

[19:09] <pmichaud> 18:08 <colomon> pmichaud: my only objection to your new List idea is it still prevents us from writing memory-efficient lazy subs without diving down to the iterator level.

[19:09] <lue> alpha: multi sub infix:<jnthn>($a, $b){say "$a only a test $b";};multi sub postfix:<jnthn!>($a){say "$a !";};say 3 jnthn 4; say "hi"jnthn!;

[19:09] <p6eval> alpha 30e0ed: OUTPUT«3 only a test 4␤1␤hi !␤1␤»

[19:10] <pmichaud> colomon:  we can still do memory-efficient lazy subs, since we can do List.shift

[19:11] <lue> rakudo: say ((1,2,3) + (4,5,6))

[19:11] <p6eval> rakudo b4ccaa: OUTPUT«6␤»

[19:12] <lue> alpha: say ((1,2,3) + (4,5,6))

[19:12] <p6eval> alpha 30e0ed: OUTPUT«6␤»

[19:12] <pmichaud> essentially, if you treat @variable like an array, then it keeps elements around.  if you continually shift elements, it acts like an iterator.

[19:12] <lue> ô.ō

[19:12] <lue> so, I'm guessing you'd never use + on arrays (either that or that's an error)

[19:12] <pmichaud> sure, you can do that -- it just means "how many elements in the array?"

[19:14] <jnthn> pmichaud: Maybe I'm just being slow... Any chance you could take our foo and bar examples and explain where / how it's treated like array and iterator in each of them?

[19:14] <pmichaud> looking for the examples

[19:15] <pmichaud> sub foo(@x) { @x.grep(/bar/) }  # this one?

[19:16] <jnthn> yes

[19:16] <jnthn> sub baz(@x) { @x.grep(/bar/) Z @x.grep(/quux/) }

[19:16] <jnthn> That's the other one

[19:17] <jnthn> pmichaud: Assume that we call them both with something like lines($fh)

[19:17] <lue> alpha: multi sub circumfix:<≤≥>($a){say $a;}; ≤"e"≥

[19:17] <p6eval> alpha 30e0ed: OUTPUT«Syntax error at line 10, near "\u2264\"e\"\u2265"␤in Main (file <unknown>, line <unknown>)␤»

[19:17] <pmichaud> well, the second one clearly reifies @x and keeps it around, otherwise it can't work at all.

[19:17] <lue> alpha: multi sub circumfix:<≤ ≥>($a){say $a;}; ≤"e"≥

[19:17] <p6eval> alpha 30e0ed: OUTPUT«e␤»

[19:18] <jnthn> pmichaud: Right, which is fine.

[19:18] <lue> alpha: multi sub circumfix:<jnthn jnthn>($a){say "do something with $a";}; jnthn"e"jnthn;

[19:18] <p6eval> alpha 30e0ed: OUTPUT«do something with e␤»

[19:18] <jnthn> What is it about bar that means we reify, and about foo that means we don't?

[19:18] <lue> alpha: multi sub circumfix:<jnthn jnthn>($a){say "do something with $a";}; jnthn5jnthn;

[19:18] <p6eval> alpha 30e0ed: OUTPUT«do something with 5␤»

[19:18] <jnthn> That's my "missing puzzle piece" as it were. :)

[19:19] <pmichaud> it depends on what @x is.

[19:19] <pmichaud> hmmm.

[19:20] <pmichaud> assuming that we do   foo($fh.lines)

[19:21] <pmichaud> $fh.lines is going to return us a List

[19:21] <pmichaud> it'll be lazy

[19:21] <pmichaud> that list gets bound to @x

[19:22] <pmichaud> we then turn around and call @x.grep, which creates another iterator on the list bound to @x

[19:22] <pmichaud> grep then works on that iterator.  Each iteration does indeed cause @x to reify

[19:23] <pmichaud> so our original List coming back from $fh.lines grows and doesn't lose elements, because we're never shifting it.

[19:23] <pmichaud> I think that's likely the correct answer here.  But the fact that this example causes @x to stick around doesn't mean it's impossible to write one that doesn.t

[19:23] <pmichaud> *doesn't

[19:24] * colomon is back

[19:25] <pmichaud> this particular example is different from what we would get if we had done   $fh.lines.grep(/bar/)   -- in that case, we don't keep the elements around.

[19:25] <lue> \o \o Hello again, colomon! o/ o/

[19:25] <colomon> pmichaud: That's exactly my point.

[19:25] <pmichaud> what, that a sub call would work differently from a method call?

[19:26] <pmichaud> or that binding a variable to an object means the object behaves differently in a different context?

[19:26] <colomon> No, that if you do things immediately they can be memory-efficient lazy, but if you refactor them into a sub call they're suddenly memory-wasting lazy.

[19:26] <jnthn> pmichaud: iiuc, then:

[19:26] <jnthn> $fh.lines.grep(/bar/) # doesn't keep stuff around

[19:27] <pmichaud> colomon: they're memory-wasting lazy because you bound to a list variable

[19:27] <jnthn> sub foo(@x) { @x.grep(/bar/); foo($fh.lines)

[19:27] <pmichaud> sub foo($list) { $list.grep(/bar/); }   # not wasting

[19:27] <jnthn> Ahh...

[19:27] <jnthn> But then sub bar($list) { $list.grep(/x/) | $list.grep(/y/) } # epic fail?

[19:27] <pmichaud> (I think.)

[19:28] <jnthn> gah!

[19:28] <pmichaud> jnthn: yeah, not sure about that one.

[19:28] <jnthn> s/|/Z/, sorry

[19:28] <jnthn> (to my credit, they are next to each other on my keyboard :-))

[19:28] <pmichaud> (to your discredit, they're next to each other on your keyboard.  Get a real US keyboard :)

[19:28] <colomon> :)

[19:29] <jnthn> My keyboard is British and thus has awesome national deb^W^Wsomething.

[19:29] <jnthn> :-)

[19:29] <lue> jnthn: you must be using dvorak :D

[19:29] <jnthn> lue: No, querty

[19:30] <jnthn> er

[19:30] <jnthn> qwerty

[19:30] <jnthn> .oO( now *that's* embrassing to mis-spell )

[19:30] <lue> just glide your index finger over the first 6 letters. qqwerty :) (double-q result of glide)

[19:30] <jnthn> pmichaud: I can see the arguments for those answers. It just feels perhaps a little surprising.

[19:31] <pmichaud> jnthn: I'm not sure of my answers at the moment, they don't make sense.

[19:31] <colomon> I still think my "is iter" suggestion is the clean way out of the situation.  By default everything is safe and reifies to Seq/Array.  If you declare "is iter" then you get a pure Iterator with the resultant benefits and drawbacks.

[19:31] <colomon> Though I suspect someone can come up with a better name that "is iter".

[19:32] <pmichaud> instead of "is iter" I think I'd prefer it to just go to a scalar and you do your own explicit shifting

[19:33] <jnthn> In a sense, the problem is that we want to have our iterator and eat it.

[19:34] <jnthn> And whether it's "is iter" or "use $ not @" essentially it's a case of giving the user an option of which to do.

[19:34] <jnthn> It just feels like a quirky one to explain.

[19:34] <pmichaud> quirky to explain that there's a more memory-efficient way of writing certain constructs?

[19:36] <jnthn> Well, you get some quite different semantics along with it too (like, only try to use this thingy once).

[19:36] <jnthn> I guess we tend to use @ when referring to lists of things, so maybe "use $ instead to say how to deal with this whole bunch of things rather than reify" makes some sense.

[19:36] <colomon> no, quirky that if I pass a hash as a scalar, it acts like I'd passed %hash, but if I pass "an array" it may or may not act like I'd passed @array.

[19:37] <jnthn> colomon: Thanks, that's what I was trying to say but failing. 

[19:37] <pmichaud> oh, I suspect some of this impacts hashes as well

[19:37] <pmichaud> but yes, I get your point

[19:37] <pmichaud> consider:

[19:38] <pmichaud> my $lines = $fh.lines;   $lines.grep(/bar/)

[19:38] *** xomas joined
[19:38] <colomon> I'd almost rather break the assumption that the user doesn't see Iterator and force them to declare Iterator $a for this functionality.

[19:38] <pmichaud> colomon: in all of my exeamples, the user doesn't see Iterator

[19:38] <pmichaud> that's not the point/issue.

[19:38] <pmichaud> *examples

[19:39] <pmichaud> my $lines = $fh.lines;  say $lines.WHAT;  # List

[19:39] <colomon> pmichaud: right, I'm saying IMO it might be better to have the user see Iterator, rather than magically invoking it if they do certain things.

[19:39] <pmichaud> I'm reasonably sure that making the iterators visible by default is non-perlish

[19:40] <colomon> please continue with your examples, I'm dying of curiosity here.  :)

[19:41] <pmichaud> I'm just guessing that we end up keeping things around more often than we suspect

[19:42] <jnthn> Yeah, I see...if that one would keep things around too...

[19:43] <jnthn> In a sense, "if you want to not keep things around, never bind or assign"

[19:44] <pmichaud> I wonder how p5 distinguishes something like   grep(/x/, <FILE>)    from   grep(/x/, @a)

[19:44] <pmichaud> or if it distinguishes them

[19:46] <moritz_> it does not

[19:46] <pmichaud> so, grep(/x/, <FILE>)  slurps the entire file into memory as it's processing?

[19:46] <moritz_> yes

[19:46] <pmichaud> well.... there ya go.

[19:46] <moritz_> which is why people write while(<FILE>) { ... } rather than for(<FILE>) { ... }

[19:47] <pmichaud> yes, but we'd prefer that    for lines() { ... }    not do that, I suspect.

[19:47] <moritz_> correct

[19:47] <pmichaud> since for lines() { ... }  is the preferred replacement for while ....

[19:47] *** lifeng joined
[19:47] <pmichaud> I'm not sure how to reconcile the two conflicting views here.

[19:48] *** moritz_ sets mode: +o jnthn

[19:48] *** moritz_ sets mode: +o colomon

[19:48] <lue> If I knew what the heck you guys were talking about (I'm not a backlog guy), I could try to impart awesome middle ground :)

[19:49] <moritz_> lue: if you really cared, you could actually backlog this once :-)

[19:49] <lue> alright. I'm just afraid of becoming insane (uncharacteristic of me to be afraid of that, but...)

[19:49] <colomon> pmichaud: it seems to me we're already halfway there, since it seems we've all agreed that iterators should bind in an array-like fashion to @a, and there should also be a way to make that not happen.

[19:49] <pmichaud> rakudo:  sub foo(@x) { say +@x ?? @x.elems !! 'noway'; };   foo((1,2,3));

[19:49] <p6eval> rakudo b4ccaa: OUTPUT«3␤»

[19:50] <pmichaud> oh, wait

[19:50] <pmichaud> rakudo:  sub foo(@x) { say +@x ?? @x.elems !! 'noway'; };   foo((1,2,3).map({$_}));

[19:50] <p6eval> rakudo b4ccaa: OUTPUT«0␤»

[19:50] <pmichaud> lue: ^^^

[19:51] <pmichaud> colomon: I don't like the idea that the array-like/iterator-like property belongs to the container, though.

[19:51] * moritz_ always thought that .elems and prefix:<+> evaluated eagerly - should they?

[19:51] <colomon> moritz_: yes.

[19:51] <pmichaud> moritz_: the problem is that the first +@x exhausts the iterator, leaving nothing for @x.elems

[19:52] *** xomas left
[19:52] <moritz_> pmichaud: so it should not only exhaust the iterator, but replace it by an array... or something?

[19:52] <colomon> rakudo: sub foo(@x) { say +@x; say +@x; };  foo((1,2,3).map({$_}));

[19:52] <p6eval> rakudo b4ccaa: OUTPUT«3␤0␤»

[19:52] <pmichaud> well, we need some way of knowing that @x keeps its elements around.

[19:52] *** new_order left
[19:53] <pmichaud> I don't think we want to have some strange list of operations that cause an iterator to become an array/seq

[19:53] <pmichaud> (while others do not)

[19:53] <colomon> pmichaud: I do agree that we're not in complete agreement on how to signal array-like vs iterator-like, yes.  :)

[19:54] <moritz_> so... a list keeps both its items and potentially and iterator around, with an API to ask for that iterator?

[19:54] * moritz_ probably missed too much of the discussions from the last weeks to be of any use

[19:54] <pmichaud> moritz_: it's basically restarted again last night 

[19:54] <pmichaud> so you're not too far behind at all

[19:55] <pmichaud> I can certainly imagine something like

[19:55] <moritz_> that's a bit bad :(

[19:55] <lue> and the argument is about what it should return?

[19:55] <pmichaud> sub foo(@x) { @x.iterator.grep(/bar/) }   # consumes @x as we go

[19:55] <pmichaud> versus @x.grep(/bar/)  which leaves the values of @x in place

[19:55] <colomon> It's a spin-off of masak's insane Exegesis updating notions, if you trace it back far enough.  :)

[19:56] <moritz_> pmichaud: sounds sane-ish

[19:57] <jnthn> I'm a lot less comfortable with that than "use $"

[19:57] <jnthn> oh wtf

[19:57] <jnthn> I'm a lot MORE comfortable with that than "use $" 

[19:57] <colomon> agreed.

[19:57] <colomon> though I'm not sure .iterator is the right magic word.

[19:57] <pmichaud> of course, then someone becomes surprised when   foo(@a)   leaves @a empty

[19:58] <pmichaud> bbiab -- errand

[19:58] <colomon> (at least, right now it is non-distructive)

[19:58] <colomon> ack, good point.

[19:59] <ruz> hi

[19:59] <lue> oi ruz!

[20:01] <lue> $_ is 'it', correct? (mind you, I have never programmed anything in perl before :) )

[20:01] <moritz_> lue: yes

[20:04] <lue> rakudo: say ((1,2,3).map({$_})

[20:04] <p6eval> rakudo b4ccaa: OUTPUT«Confused at line 11, near "say ((1,2,"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[20:04] <lue> rakudo: say ( (1,2,3).map({$_}) )

[20:04] <p6eval> rakudo b4ccaa: OUTPUT«123␤»

[20:04] <lue> rakudo: say ( (1,2,3).map({$_}) ).perl

[20:04] <p6eval> rakudo b4ccaa: OUTPUT«MapIterator.new()␤»

[20:05] <lue> rakudo: say ( (1,2,3).map({$_}).str )

[20:05] <p6eval> rakudo b4ccaa: OUTPUT«Method 'str' not found for invocant of class 'MapIterator'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:05] <lue> rakudo: say str( (1,2,3).map({$_}) )

[20:05] <p6eval> rakudo b4ccaa: OUTPUT«Could not find non-existent sub &str␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:05] <lue> (fun with experiments)

[20:06] *** athenot left
[20:06] <lue> rakudo: say +(1,2,3)

[20:06] <p6eval> rakudo b4ccaa: OUTPUT«3␤»

[20:07] <lue> rakudo: sub foo(@x) { say +@x ?? @x.elems !! 'noway'; };   foo((1,2,3).map({$_})) #ought to output 3 then, right?

[20:07] <p6eval> rakudo b4ccaa: OUTPUT«0␤»

[20:07] <lue> alpha: sub foo(@x) { say +@x ?? @x.elems !! 'noway'; };   foo((1,2,3).map({$_})) #ought to output 3 then, right?

[20:07] <p6eval> alpha 30e0ed: OUTPUT«3␤»

[20:07] <jnthn> Right, that's The Issue.

[20:08] <jnthn> alpha had an easier time getting ti right because it didn't also do laziness.

[20:08] <lue> I'm assuming then the hard part is fixing it, not finding what it should be fixed to :)

[20:09] <colomon> lue: no, actually the hard part is figuring out what it should do.

[20:09] * lue is taking a break from P6 and learning how to model in Blender (still available here, though)

[20:10] <colomon> because sometimes you want it to behave like alpha does, and sometimes you want it to behave like master does.

[20:10] <lue> Oh, now your asking if it should be 3, or if that was always wrong?

[20:10] <lue> too bad you can't badger the programmer in the middle of execution and ask "what do you mean?"

[20:12] *** hercynium left
[20:13] <colomon> lue: the issue here is basically what happens when you iterate over a large structure.

[20:14] <colomon> errr, not a large structure, but a logically large structure.

[20:14] <colomon> So, imagine iterating over all the lines in a 2gig text file, or the range 1..1000000000

[20:14] <lue> alpha: sub foo(@x) { say +@x ?? @x.elems !! 'noway'; };   foo((1...10).map({$_})) #ought to output 3 then, right?

[20:14] <p6eval> alpha 30e0ed: OUTPUT«10␤»

[20:14] <lue> oh!

[20:15] <lue> wait, that's alpha :D

[20:15] <lue> rakudo: sub foo(@x) { say +@x ?? @x.elems !! 'noway'; };   foo((1...10).map({$_}))

[20:15] <p6eval> rakudo b4ccaa: OUTPUT«0␤»

[20:16] <colomon> so if you say something like (1..100000000000).grep({is-prime($_)}), you don't want it generating an Array with 100000000000 elements in it.

[20:16] <colomon> You want it to send each element individually down to grep, and only store the ones that are prime.

[20:18] <lue> (suggestion #1) how's about a loop using the range as the parameters?

[20:20] <colomon> lue: the thing is, this already *works* in Rakudo master.

[20:20] <colomon> (well, there is no is-prime function, but if there were, it would work the way we'd like it too.)

[20:22] <colomon> it works because of the iterator setup.  when you do the grep, it asks the Range for an iterator, and then iterates over that.

[20:22] <colomon> This works really well.

[20:23] <colomon> But it interacts very weirdly with passing @rray arguments to functions.

[20:24] <pmichaud> 19:46 <moritz_> which is why people write while(<FILE>) { ... } rather than for(<FILE>) { ... }

[20:24] <pmichaud> 19:46 <pmichaud> yes, but we'd prefer that    for lines() { ... }    not do that, I suspect.

[20:24] <pmichaud> actually, it'd be "okayish" if for lines() { ... } also stored the values it read.  That doesn't affect laziness at all, just memory consumption.

[20:25] <pmichaud> but yes, we would prefer   for lines() { ... } to work on a 2gb file without eating up all available memory

[20:27] <lue> would tossing the values into a temporary file of some sort be a valid action (brainstorming)

[20:28] *** miksss joined
[20:28] <colomon> pmichaud: I can't decide if your .iterator proposal is perfect, or if it needs an additional step which means the iterator is only consumed if the original object was itself an iterator.

[20:28] *** miksss left
[20:28] <colomon> errr, which is already how it works, maybe?

[20:28] <pmichaud> colomon: I'm not entirely comfortable with .iterator

[20:30] *** nihiliad left
[20:30] <pmichaud> perhaps it has more to do with bound versus unbound lists

[20:30] <pmichaud> (1..10000).map(...)   # unbound

[20:31] <pmichaud> my @a := 1..10000;  @a.map(...)  # bound

[20:31] <pmichaud> the unbound list consumes elements as it's processed, the bound list save elements as they're processed

[20:32] <colomon> what is my @a = 1..10000; bound or unbound?

[20:32] <pmichaud> that's an assignment, so @a ends up with a copy anyway

[20:32] <colomon> !?

[20:32] <pmichaud> the 1..10000 gets mostly-eager-evaluated anyway on assignment

[20:33] <pmichaud> (an optimizer might choose not to evaluate, but the spec says assignment is mostly eager)

[20:33] <jnthn> I guess if people want to write lazy constructs spread out more nicely, that's what the pipe operators are for.

[20:34] <pmichaud> yes, and the pipes also make a bit of a bound-versus-unbound distinction

[20:34] <pmichaud> my @a <== pipe...    # lazy capture into @a

[20:35] <pmichaud> but being able to distinguish bound-versus-unbound would mean that something like    for lines() { ... }   can consume the iterator, while    my @a := lines();  for @a { ... }    wouldn't

[20:36] <pmichaud> it doesn't resolve the   sub foo(@x) { @x.grep(/bar/); }  issue, though.

[20:37] * lue .oO(the jnthn omnisub will end up being an entirely different project on its own... (more)

[20:37] *** nihiliad joined
[20:37] * jnthn wonders if $x will cut it

[20:37] <pmichaud> (i.e., this case would end up keeping all of the elements of @x around)

[20:37] * lue ... I think it'd even need its own team!)

[20:37] <pmichaud> hmmm, \$x

[20:37] <jnthn> Well, \$x means "jfbi" :-)

[20:37] <lue> (our salute to references! ō\)

[20:38] <pmichaud> but we still need a way to make it slurpy, I think.

[20:38] <lue> alpha: my $x=3; my $y=\$x; $y=4; say $x;

[20:38] <p6eval> alpha 30e0ed: OUTPUT«3␤»

[20:38] <jnthn> Ah.

[20:38] <jnthn> That's...trickier.

[20:38] <lue> alpha: my $x=3; my $y=\$x; $($y)=4; say $x;

[20:38] <p6eval> alpha 30e0ed: OUTPUT«3␤»

[20:39] <lue> how would you do what I'm trying to do? (change $x thru reference)

[20:39] <jnthn> my $y := $x; # binding

[20:39] <pmichaud> alpha:  my $x = 3;  my $y := $x;  $y = 4;  say $x;

[20:39] <jnthn> But we didn't implement it yet in master.

[20:39] <p6eval> alpha 30e0ed: OUTPUT«4␤»

[20:39] <jnthn> I don't think...

[20:39] <pmichaud> no, it's not in master yet.

[20:39] <jnthn> rakudo: my $x = 3;  my $y := $x;  $y = 4;  say $x;

[20:39] <p6eval> rakudo b4ccaa: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 16676 (src/builtins/Junction.pir:347)␤»

[20:40] <pmichaud> I'm somewhat waiting for the binding of iterators/lists semantics to shake out

[20:40] <jnthn> rakudo: my $x = 3;  my ($y) := $x;  $y = 4;  say $x;

[20:40] <p6eval> rakudo b4ccaa: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 16676 (src/builtins/Junction.pir:347)␤»

[20:40] <jnthn> heh heh.

[20:40] <pmichaud> hmm, that's weird.

[20:40] <jnthn> rakudo: my $x = 3;  my ($y is rw) := $x;  $y = 4;  say $x;

[20:40] <p6eval> rakudo b4ccaa: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:41] <jnthn> bah :-)

[20:41] <pmichaud> I would've expected the := nyi message

[20:41] <lue> alpha: my $x = 3; my $y := $x; $y = 4; say $x;

[20:41] <p6eval> alpha 30e0ed: OUTPUT«4␤»

[20:41] <jnthn> pmichaud: No, because binding against a sig on the lhs works.

[20:41] <lue> \o/ for alpha.

[20:41] <pmichaud> jnthn: oh, evil.

[20:41] <jnthn> Parens => we parse a sig there => signature binding.

[20:41] * pmichaud goes to see "how" that works.

[20:41] <jnthn> oh noes

[20:41] * lue change of topic... success. Thank you for using the 楽土 parser

[20:42] <jnthn> pmichaud: I didn't put anything in EXPR. :-)

[20:43] <pmichaud> okay.  I don't think that := should be syntactic, though.

[20:44] <pmichaud> maybe it has to be, but STD doesn't have it that way.

[20:44] <jnthn> Depends what you mean by :=

[20:44] <pmichaud> infix:<:=> 

[20:44] <jnthn> It dispatches to := as a normal multi-sub

[20:44] <jnthn> So that part isn't syntactic.

[20:44] <pmichaud> but the "bindish_check" part is.

[20:44] <jnthn> The syntactic decision is just that we actually want the signature, not just a list.

[20:45] <jnthn> I did ponder writing Signature!STORE

[20:45] <pmichaud> I still claim this is incorrect but won't push it now.  I'll just reserve an "I told you so" for later :-)

[20:46] <jnthn> :-P

[20:46] <pmichaud> yes, Signature!STORE is more of what I have been thinking would be proper.

[20:46] <jnthn> It's OK, I'm used to them (and used to them being completely justified). :-)

[20:46] <jnthn> Yeah, but...I didn't like it. :-)

[20:46] <jnthn> When .once() is implemented in PAST, I'll be happier. :-)

[20:46] <Tene> phenny: tell masak "For a given grammatical category, a default parsing rule or set of rules is used".  The spec doesn't discuss where this "default parsing rule" is defined.

[20:46] <phenny> Tene: I'll pass that on when masak is around.

[20:51] *** wknight8111 left
[20:53] <pugssvn> r29887 | colomon++ | [t/spec] Bring num.t up-to-date a bit, and fudge it for Rakudo. 

[20:53] <Tene> phenny: tell masak That was the big omission, at least.  Search the logs for mention of that quote to find my discussion with TimToady about it.

[20:53] <phenny> Tene: I'll pass that on when masak is around.

[20:55] <lue> (masak's gonna get a lot of messages...)

[20:55] <Tene> phenny: tell masak I hear you're going to get a lot of messages.  Good luck with that.

[20:55] <phenny> Tene: I'll pass that on when masak is around.

[20:56] <pmichaud> afk for a while

[20:57] <lichtkind> good night

[20:57] <Tene> lue: I looked at scrollback, and those two (three now) are the only messages queued for masak so far.  What are you talking about, a lot of messages?

[20:58] <lichtkind> good night

[20:58] *** uniejo left
[20:58] <lue> goodnight lichtkind o/

[20:58] <Tene> g'night lichtkind 

[20:59] <lichtkind> thanks

[20:59] <pmichaud> jnthn: how about using a capture, as in     sub foo(|$x) { $x.grep(/bar/) }

[20:59] <lue> Tene: you say hi, and three  messages blare out at you. It'll seem like a lot of messages at first.

[20:59] <Tene> lue: no, that's pretty normal around here.

[21:00] *** lejon_ joined
[21:00] <moritz_> at least for masak++ :-)

[21:00] *** lejon left
[21:00] *** lejon_ is now known as lejon

[21:00] <lue> rakudo: say 1++

[21:00] <p6eval> rakudo b4ccaa: OUTPUT«Cannot assign to readonly value␤current instr.: '&die' pc 16676 (src/builtins/Junction.pir:347)␤»

[21:00] <lue> alpha: say 1++

[21:00] <p6eval> alpha 30e0ed: OUTPUT«Unable to set lvalue on PAST::Val node␤in Main (file <unknown>, line <unknown>)␤»

[21:00] <jnthn> pmichaud: Well, it'll delay any contextualization I guess.

[21:00] <Tene> phenny: tell masak Ah, nevermind, I was misinformed.  Looks like it's only me in your messages so far.

[21:00] <phenny> Tene: I'll pass that on when masak is around.

[21:00] <pmichaud> then if the argument to foo() was already bound, it has the array semantics, if the argument to foo() was unbound, grep can throw things away as it processes them

[21:01] <pmichaud> foo(@a)    # list bound, so @a remembers reified elements

[21:01] <lue> Tene: i left a message for him! :)

[21:01] <pmichaud> foo(1..10000)  # range unbound, so iterator tosses elements as grep processes them

[21:01] <pmichaud> and if you do

[21:01] <pmichaud> sub foo(|$x) { $x.grep(/bar/) Z $x.grep(/foo/) }

[21:01] <pmichaud> you deserve whatever mayhem you get.

[21:02] <jnthn> pmichaud: What will .grep do when called on a capture?

[21:02] <jnthn> .list?

[21:02] <jnthn> (first)?

[21:02] <pmichaud> I suspect it iterates over the positionals, yes.

[21:02] <pmichaud> so yes, .list

[21:02] <jnthn> Heh, evil :-)

[21:02] <jnthn> It probably does the right kinda thingy.

[21:02] <pmichaud> well, in general   .grep and .map  already do .list or .iterator on the invocant 

[21:02] <jnthn> *nod*

[21:03] <jnthn> May have to teach capture about .iterator

[21:04] <jnthn> But .list it knows well. :-)

[21:04] <pmichaud> well, I suspect .iterator goes away in all of this

[21:04] <pmichaud> or at least becomes very uncommon

[21:04] <pmichaud> .list is the normal "give me your elements as an iterable list" in this scencario

[21:04] <pmichaud> *scenario

[21:04] <jnthn> Yes, good point.

[21:04] <jnthn> It feels feasible.

[21:04] <pmichaud> so everything tends to return List instead of *Iter

[21:04] <jnthn> I like that.

[21:04] *** wknight8111 joined
[21:05] <jnthn> Seeing MapIterator etc leaking out has been kinda...hmm.

[21:05] <pmichaud> right, we all feel that's wrong

[21:05] *** IllvilJa left
[21:05] *** lichtkind left
[21:05] <pmichaud> so    @a.map({...}).WHAT  # List

[21:05] <jnthn> That would make me (and the test suite, I suspect) has a happy.

[21:05] <pmichaud> me also.

[21:06] <jnthn> What about Seqs?

[21:06] <pmichaud> and if you invoke  @a.map({...}).some_other_method    the List returned from .map is unbound, and thus its return values aren't held anywhere (although @a's are held of course, because @a is bound)

[21:06] * jnthn guesses Seq goes away now and we're back to List and Array.

[21:06] <pmichaud> I don't see a need for Seq in this scenario

[21:06] <pmichaud> right.

[21:07] <pmichaud> which would also make me happier.

[21:07] <colomon> \o/

[21:07] <pmichaud> or, Seq is a List that doesn't support shift/unshift

[21:07] * jnthn just realized that "What about Seqs?" said out loud at a hackathon could make our discussions seem more interesting than they really are.

[21:07] <pmichaud> oh, I always pronounce "Seqs"  like "seeks"

[21:08] <jnthn> I hadn't been.

[21:08] <colomon> jnthn: I'd pro... what pmichaud said.

[21:08] <jnthn> I'll start now.

[21:08] <pmichaud> since it's short for "sequence"

[21:08] <dalek> rakudo: 1201479 | (Solomon Foster)++ | t/spectest.data:

[21:08] <dalek> rakudo: Turn on S02-builtin_data_types/num.t.

[21:08] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1201479e5a6e68fb83dd0c3f822d8843dd3280fc

[21:08] <pmichaud> although it has been fun to pronounce Seq as "non-Sequiter"

[21:08] <pmichaud> er, SeqIter

[21:08] <jnthn> lol

[21:09] <pmichaud> anyway, my guess is that the hierarchy might be  Array ~~ List  and  List ~~ Seq

[21:09] <pmichaud> and Seq is something that reifies elements but has no shift/unshift

[21:09] <lue> let's hope none of the rakudo code is PIRmanent :)

[21:09] <pmichaud> (so it's _completely_ immutable)

[21:10] <pmichaud> List isa Seq, but also provides shift/unshift so it can act like an iterator

[21:10] <jnthn> That could work out.

[21:10] <pmichaud> Array isa List, but it keeps copies of element values instead of being bound directly.

[21:12] * pmichaud hopes that the unbound/bound distinction cuts the knots.

[21:13] <jnthn> It feels right, and I like how captures - a mechanism that naturally delays evaluation - seems to fit naturally into this solution.

[21:14] <pmichaud> TimToady: see above re bound/unbound lists, and let us know if you think it's a promising avenue to pursue or a likely dead end.

[21:15] <pmichaud> time for me to run some other errands to prepare for trips

[21:15] <bkeeler> Hmm, interesting backlog today

[21:15] *** mssm left
[21:15] <lue> bkeeler: o/    quite.

[21:16] <bkeeler> rakudo: say map { $_, $_ * 2 } 1..5

[21:16] <p6eval> rakudo b4ccaa: OUTPUT«Confused at line 11, near "say map { "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[21:16] <bkeeler> rakudo: say map { $_, $_ * 2 }, 1..5

[21:16] <p6eval> rakudo b4ccaa: OUTPUT«22222␤»

[21:16] <bkeeler> Gah, habits

[21:17] <bkeeler> Seems like getting List into the action would help that, taking advantage of the parcel flatting in List.get

[21:17] <pmichaud> bkeeler: yes, quite.

[21:17] <pmichaud> bkeeler: it'll have to wait until we figure out exactly what Lists are, though :)

[21:18] <bkeeler> hehe

[21:18] <pmichaud> another possibility:   Array ~~ List  and List ~~ Seq

[21:18] <pmichaud> er, scratch that

[21:18] <lue> therefore, Array ~~ Seq

[21:18] <pmichaud> Array ~~ List and   List ~~ Iterable

[21:18] <pmichaud> Iterable just returns values but forgets them

[21:18] <bkeeler> Sounds reasonable

[21:19] <pmichaud> List remembers the values it iterates

[21:19] <pmichaud> Array copies the values it iterates

[21:19] <pmichaud> oh, I know what I meant

[21:19] <pmichaud> then most functions return Iterable, but binding an Iterable converts it into a List

[21:20] <pmichaud> (can change the names here)

[21:20] * colomon wonders if he can turn 24979 passing tests into 25000+ before the hockey game is over...

[21:21] <lue> if you can, set the hockey game to be play and .25x speed :) then you'll have enough time...

[21:21] <pmichaud> the idea being that one type is for "unbound iterator" and a derived type is for "bound iterator", and Array is further derived from the last one

[21:21] <lue> s/play and/played at/

[21:21] *** IllvilJa joined
[21:21] <bkeeler> Plus you might actually stand a chance of seeing the puck

[21:22] <lue> nah, you'd need .125x speed :)

[21:22] <bkeeler> pmichaud: It makes sense to me

[21:22] *** TiMBuS left
[21:22] *** parrot joined
[21:22] <colomon> it's not that hard to see... though I admit I really liked it when they did that experiment with computer enhancing the puck a decade or so ago.  :)

[21:22] <bkeeler> I was trying to making sense of Seq Array & List, and wasn't having much luck until this discussion

[21:23] <lue> I think the main goal of this discussion is to make it last days :)

[21:25] <pmichaud> definitely not.

[21:25] <colomon> jnthn: is ~(%($pair)), "when\tnow\n", 'hash stringification';  # Method 'hash' not found for invocant of class 'Pair'

[21:26] <pmichaud> I'd like it to be done :-)

[21:26] <jnthn> colomon: Just needs Pair.hash writing.

[21:26] <colomon> should it be Pair.hash or Pair.Hash?

[21:26] <jnthn> Bothish.

[21:26] <jnthn> erm 

[21:26] <jnthn> :-)

[21:27] <jnthn> Oh

[21:27] <jnthn> Actually

[21:27] <moritz_> rakudo: {a => 1}.isa(Hash)

[21:27] <jnthn> I wonder if you can get away with returning self in .hash

[21:27] <p6eval> rakudo b4ccaa:  ( no output )

[21:27] <moritz_> rakudo: say {a => 1}.isa(Hash)

[21:27] <p6eval> rakudo b4ccaa: OUTPUT«0␤»

[21:27] <moritz_> rakudo: say {a => 1}.WHAT

[21:27] <p6eval> rakudo b4ccaa: OUTPUT«Hash()␤»

[21:27] <jnthn> It may be hashish enough :-)

[21:27] <moritz_> rakudo: say Hash.isa(Hash)

[21:27] <jnthn> But anyway, we probably need .hash and .Hash

[21:27] <p6eval> rakudo b4ccaa: OUTPUT«Method 'isa' not found for invocant of class 'RoleHOW'␤current instr.: 'perl6;Any;isa' pc 9675 (src/gen/RoleToClassApplier.pir:540)␤»

[21:27] <moritz_> jnthn: I think it's because Hash is a role, not a class...

[21:28] <colomon> jnthn: both of which return self?

[21:28] <jnthn> No

[21:28] <colomon> that's the kind of complicated Rakudo hacking I can handle.  :)

[21:28] <jnthn> colomon: Make a hash.

[21:28] <jnthn> my %h = self; # may work ;-)

[21:29] <jnthn> moritz_: That last issue is, yes.

[21:29] <colomon> wait, if %(Pair) doesn't work, why should %h = self work?

[21:29] <jnthn> They're doing different things.

[21:29] <jnthn> %(Pair) calls Pair.hash

[21:30] <jnthn> my %h = self does something like

[21:30] <jnthn> %h := Hash.new

[21:30] <jnthn> %h!STORE(self)

[21:30] <jnthn> Or similar.

[21:30] <colomon> k

[21:30] <colomon> trying now.

[21:30] *** pmurias joined
[21:33] <colomon> jnthn: maximum recursion depth exceeded

[21:33] <IllvilJa> US vs Canada in male Hockey in Vancouver.  Better not watch it to preserve SOME faith in mankind... ;-)

[21:33] <jnthn> FAIL.

[21:34] <moritz_> Unable to coerce value for '$str' from Str to EMPTY; no coercion method defined

[21:34] <moritz_> current instr.: 'sprintf' pc 252305 (src/gen/core.pir:12088)

[21:34] <moritz_> that's from S02-literals/listquote-whitespace.t

[21:34] <IllvilJa> (According to my son, some US player almost managed to 'throw' a Canadian guy into the lap of the US players who are sitting waiting 'on reserve'... intresting game...  Don't worry, no more spoilers for those who want to watch)

[21:34] <jnthn> Ugh.

[21:35] *** mberends left
[21:35] <colomon> trying {self} now.

[21:35] <moritz_> rakudo: say <abc\de>.perl

[21:36] <p6eval> rakudo b4ccaa: OUTPUT«"abc\\de"␤»

[21:36] <moritz_> rakudo: printf "%02x", ord "\\";

[21:36] <p6eval> rakudo b4ccaa: OUTPUT«Could not find non-existent sub &printf␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:36] <moritz_> rakudo: say sprintf "%02x", ord "\\";

[21:36] <p6eval> rakudo b4ccaa: OUTPUT«5c␤»

[21:37] <moritz_> rakudo: printf "%02x", ord "/";

[21:38] <p6eval> rakudo b4ccaa: OUTPUT«Could not find non-existent sub &printf␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:39] <moritz_> rakudo: my $vis = sprintf "%02x", ord '/'

[21:39] <p6eval> rakudo b4ccaa:  ( no output )

[21:39] <moritz_> that's the line that dies in listquote-whitespace.t

[21:40] <moritz_> ... sometimes

[21:40] <moritz_> and sometimes it lives

[21:40] <jnthn> moritz_: I think it's a random fail.

[21:40] <moritz_> weird

[21:40] <jnthn> yeah

[21:40] <colomon> jnthn: should the stringification of a hash really end with a newline?

[21:40] <jnthn> colomon: I think so

[21:40] <moritz_> sometimes it can't coerce to Perl6Scalar, sometimes to ObjectRef

[21:40] <colomon> We're getting that wrong, then.

[21:41] <jnthn> is it not like key\tvalue\nkey\tvalue\n

[21:41] <colomon> not ok 34 - hash stringification

[21:41] <colomon> #      got: "when\tnow"

[21:41] <colomon> # expected: "when\tnow\n"

[21:41] <jnthn> moritz_: Yes, that's what makes me think something may be Very Very Wrong.

[21:41] <jnthn> moritz_: sprintf.rakudo does similar things to me.

[21:42] <jnthn> oh

[21:42] <jnthn> hmm

[21:43] <jnthn> moritz_: I think I see what's wrong.

[21:44] <jnthn> Trying to fix.

[21:45] <pugssvn> r29888 | moritz++ | fudge defined.t for rakudo 

[21:46] <pugssvn> r29889 | moritz++ | [t/spec] correct catch_type_cast_mismatch.t and improve fudging for rakudo 

[21:47] <moritz_> oops, that commit to defined.t was probably out of date

[21:47] <pugssvn> r29890 | moritz++ | test for RT #72872, Mu eqv Mu 

[21:51] *** lejon left
[21:52] <pugssvn> r29891 | moritz++ | [t/spec] test for RT #72790: $obj.?nonexistent() should return Nil, not some scalar, undefined value 

[21:53] <jnthn> moritz_: Think sprintf patch has worked :-)

[21:55] * colomon isn't going to spectest until jnthn has his patch in...

[21:56] <lue> rakudo: my $s=1; say $s++

[21:56] <p6eval> rakudo 120147: OUTPUT«1␤»

[21:56] <lue> rakudo: my $s=1; say ($s++)

[21:56] <p6eval> rakudo 120147: OUTPUT«1␤»

[21:56] <pugssvn> r29892 | moritz++ | [t/spec] test for RT #72286: self should not be writeable 

[21:59] <colomon> rakudo: my %a = { a => 5, b => 72 }; say ~%a

[21:59] <p6eval> rakudo 120147: OUTPUT«maximum recursion depth exceeded␤current instr.: 'parrot;P6protoobject;VTABLE_name' pc 1296 (runtime/parrot/library/P6object.pir:764)␤»

[21:59] <colomon> oh good, that's not my fault.

[21:59] <lue> rakudo: sub hi($a) { say $a; say $a.WHAT; }; hi(3); hi((3,4,5));

[21:59] <p6eval> rakudo 120147: OUTPUT«3␤Int()␤3␤Parcel()␤»

[22:00] <lue> rakudo: sub hi($a) { say $a; say $a.WHAT; }; hi((3,4,5));

[22:00] <p6eval> rakudo 120147: OUTPUT«3␤Parcel()␤»

[22:00] <lue> rakudo: sub hi(@a) { say @a; say @a.WHAT; }; hi(3); hi((3,4,5));

[22:00] <p6eval> rakudo 120147: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Int instead␤current instr.: 'hi' pc 203 (EVAL_1:79)␤»

[22:00] <lue> roar.

[22:01] <lue> rakudo: sub hi($a) { say $a[2]; say $a.WHAT; }; hi((3,4,5));

[22:01] <p6eval> rakudo 120147: OUTPUT«5␤Parcel()␤»

[22:03] <lue> rakudo: multi sub prefix:<jnthn>($a){say $a;}; multi sub infix:<jnthn>($a, $b){ say $a, "+", $b;}; jnthn3; 3jnthn4;

[22:03] <p6eval> rakudo 120147: OUTPUT«Confused at line 11, near "3jnthn4;"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[22:03] <jnthn> colomon: pushed

[22:03] <colomon> jnthn: danke.

[22:03] <lue> rakudo: multi sub prefix:<jnthn>($a){say $a;}; multi sub infix:<jnthn>($a, $b){ say $a, "+", $b;}; jnthn3; 3 jnthn 4;

[22:03] <p6eval> rakudo 120147: OUTPUT«Confused at line 11, near "3 jnthn 4;"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[22:03] <jnthn> .oO( what on earth is lue doing with my name )

[22:03] <colomon> unfortunately, I just realized my Pair.hash function was borked.

[22:04] <colomon> rakudo: my %a = { a => 5, b => 72 }; say ~%a

[22:04] <lue> roar. you'd think there'd be some sort of way to distinguish between infix, prefix, and postfix within rakudo when using the same name multiple times...

[22:04] <p6eval> rakudo 120147: OUTPUT«maximum recursion depth exceeded␤current instr.: 'parrot;P6protoobject;VTABLE_name' pc 1296 (runtime/parrot/library/P6object.pir:764)␤»

[22:04] <jnthn>  rakudo: my %a = { a => 5, b => 72 }; say "alive"

[22:04] <p6eval> rakudo 120147: OUTPUT«alive␤»

[22:04] <jnthn>  rakudo: my %a = { a => 5, b => 72 }; say %h.perl

[22:04] <p6eval> rakudo 120147: OUTPUT«Symbol '%h' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[22:04] <jnthn>  rakudo: my %a = { a => 5, b => 72 }; say %a.perl

[22:04] <p6eval> rakudo 120147: OUTPUT«{"a" => 5, "b" => 72}␤»

[22:04] <jnthn>  rakudo: my %a = { a => 5, b => 72 }; say %a.^methods(:local)

[22:04] <p6eval> rakudo 120147: OUTPUT«pushdeletepostcircumfix:<{ }>␤»

[22:05] <lue> jnthn: just trying out things, and your name was used mainly because that's what the testing is for (the omnisub) :D

[22:05] <jnthn> rakudo: say EnumMap.^methods(:local)

[22:05] <p6eval> rakudo 120147: OUTPUT«ACCEPTSfmtiteratornewIntvaluesNumperlCaptureofinvertkeyspostcircumfix:<{ }>reversecontainspairsexistskv␤»

[22:05] <jnthn> colomon: oh, oddness

[22:05] *** parrot left
[22:05] <jnthn> colomon: But looks like EnumMap.Str is NYI

[22:05] <dalek> rakudo: 4d8935e | jonathan++ | src/pmc/p6lowlevelsig.pmc:

[22:05] <dalek> rakudo: Add missing mark.

[22:05] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4d8935ee8218862a611fbd09e2da8980aa88b9e7

[22:05] <lue> rakudo: say +3; say 3+4; say 4+

[22:05] <p6eval> rakudo 120147: OUTPUT«Confused at line 11, near "say 4+"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[22:05] <lue> rakudo: say +3; say 3+4;

[22:05] <p6eval> rakudo 120147: OUTPUT«3␤7␤»

[22:06] <jnthn> colomon: Granted it's a bad way to fail though.

[22:06] <colomon> jnthn: the reason I wasn't getting a newline for ~Hash was because I was actually getting ~Pair.

[22:06] <jnthn> Ah.

[22:06] <lue> it works when I use +, but custom operators whine about that kind of stuff.

[22:06] <jnthn> colomon: I don't think Pair needs the newline.

[22:06] <lue> (+3 and 3+4, but not jnthn3 and 3jnthn4)

[22:06] <colomon> jnthn: that's what I figured.

[22:06] <jnthn> lue: It's because + is not alphanumeirc.

[22:07] <lue> that.... shouldn't matter

[22:07] <jnthn> It does.

[22:07] <jnthn> :-)

[22:07] <jnthn> lue: consider $a eq $b vs $aeq$b :-)

[22:07] <colomon> jnthn: also, here's another one...

[22:07] <colomon> rakudo: my %a = { a => 5, b => 72 }; say %a.Sgr

[22:07] <p6eval> rakudo 120147: OUTPUT«Method 'Sgr' not found for invocant of class ''␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:07] <colomon> rakudo: my %a = { a => 5, b => 72 }; say %a.Str

[22:07] <p6eval> rakudo 120147:  ( no output )

[22:08] <colomon> la la la la la

[22:08] <lue> I can define prefix:<@> and infix:<@> but not prefix:<xyzzy> and infix:<xyzzy> (THAT doesn't make sense)

[22:08] <jnthn> lue: You *can* define them

[22:08] <jnthn> You just need spaces. :-)

[22:08] <lue> looky here: (more)

[22:08] <lue> rakudo: multi sub prefix:<jnthn>($a){say $a;}; multi sub infix:<jnthn>($a, $b){ say $a, "+", $b;}; jnthn 3; 3 jnthn 4;

[22:08] <p6eval> rakudo 120147: OUTPUT«Confused at line 11, near "3 jnthn 4;"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[22:08] <lue> alpha: multi sub prefix:<jnthn>($a){say $a;}; multi sub infix:<jnthn>($a, $b){ say $a, "+", $b;}; jnthn 3; 3 jnthn 4;

[22:08] <jnthn> alpha: multi infix:<lue>($a, $b) { say "omg" }; 3 lue 4

[22:09] <p6eval> alpha 30e0ed: OUTPUT«3␤3+4␤»

[22:09] <p6eval> alpha 30e0ed: OUTPUT«omg␤»

[22:09] <lue> that didn't work yesterday!

[22:09] <jnthn> lue: Note works in alpha, but not yet master.

[22:09] <jnthn> colomon: eww

[22:10] <lue> alpha: multi sub prefix:<jnthn>($a){say $a;}; multi sub infix:<jnthn>($a, $b){ say $a, "+", $b;}; multi sub postfix:<jnthn>($a){say "+",$a;}; jnthn 3; 3 jnthn 4; 4 jnthn;

[22:10] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "jnthn;"␤in Main (file <unknown>, line <unknown>)␤»

[22:10] <lue> I can't define an infix & postfix with the same name, that's the real problem.

[22:10] <jnthn> lue: Try with alpha.

[22:10] <lue> look up. I did :)

[22:10] <jnthn> lue: oh, wait

[22:11] <jnthn> Yeah

[22:11] <jnthn> No, you can't do that.

[22:11] <jnthn> That's just a language rule though.

[22:11] <jnthn> (Perl 6 does one-pass parsing.)

[22:11] <lue> and I can't use a tricky workaround in infix to fake a postfix either :(

[22:11] <moritz_> if you could, the parser wouldn't know if it exepcts an operator or a term after that postfix-or-infix thing

[22:12] <jnthn> When the parser doesn't know those things, it gets upset and goes and cries in the corner.

[22:12] <lue> STOP CRYING then

[22:12] <jnthn> Even when it finishes, it doesn't know how to parse it still. :-)

[22:12] <lue> at least let me see if rhs = nothing, then I can fake a postfix :)

[22:13] <lue> (check backlogs -- I tried already)

[22:14] <arlinius> isn't the one-pass parse rule broken other place(s) anyway though (at least in spec, if not current implementation)?

[22:14] *** meppl left
[22:16] <lue> alpha: multi sub infix:<xyzzy>($a, $b) {$b~~undef ?? say "postfix" !! say "infix";}; 3 xyzzy 4

[22:16] <p6eval> alpha 30e0ed: OUTPUT«infix␤»

[22:16] <lue> alpha: multi sub infix:<xyzzy>($a, $b) {$b~~undef ?? say "postfix" !! say "infix";}; 3 xyzzy

[22:16] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "xyzzy"␤in Main (file <unknown>, line <unknown>)␤»

[22:16] <arlinius> alpha: multi sub infix:<xyzzy>($a, $b) {$b~~undef ?? say "postfix" !! say "infix";}; 3 xyzzy Nil

[22:16] <p6eval> alpha 30e0ed: OUTPUT«postfix␤»

[22:16] * colomon has now paused the hockey game....

[22:16] <arlinius> :P

[22:16] <lue> it'd be nice to not force the user to type Nil for my workaround... WAIT!

[22:16] <lue> alpha: multi sub infix:<xyzzy>($a, $b=Nil) {$b~~undef ?? say "postfix" !! say "infix";}; 3 xyzzy

[22:16] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "xyzzy"␤in Main (file <unknown>, line <unknown>)␤»

[22:17] <lue> darnit

[22:17] <jnthn> Nice try. :-P

[22:17] <arlinius> alpha: multi sub infix:<xyzzy>($a, $b=Nil) {$b~~undef ?? say "postfix" !! say "infix";}; infix:<xyzzy>(3)

[22:17] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near ":<xyzzy>(3"␤in Main (file <unknown>, line <unknown>)␤»

[22:17] <jnthn> oh colomon... :-)

[22:17] <jnthn> > my %h = a => 1, b => 2; say %h.Str

[22:17] <jnthn> "b" => 2

[22:17] <jnthn> "a" => 1

[22:17] <jnthn> I has patch.

[22:17] <jnthn> :-)

[22:17] <colomon> \o/

[22:17] <jnthn> colomon: Want me to spectest it and push it?

[22:18] <jnthn> colomon: Or want me to paste it and you can pop it in with what you're up to?

[22:18] <colomon> please?

[22:18] <jnthn> ...was that to spectest and push? :-)

[22:18] * jnthn spectests

[22:19] <IllvilJa> Folks, I'm messing around with Catalyst (which implies messing around with Moose and friends).  Installing the Catalyst framework in a Perl 5 'fresh' environment require (IMHO) insane amounts of CPAN modules to be installed (269 modules on one of my gentoo boxes for instance...).  Anyone who dares to speculate how much of that goes away once Catalyst is ported to Perl 6?

[22:20] <jnthn> Well, much of Moose is kinda built-in. :-)

[22:20] *** iblechbot left
[22:20] <IllvilJa> Another way to put the question, how 'much' of Catalyst's 269 module dependencies are there only to 'turn perl 5 into perl6' ;-)?

[22:20] * jnthn has no idea :-)

[22:20] <jnthn> 269?!

[22:20] <lue> alpha: multi sub infix:<xyzzy>($a, $b=Inf) {$b~~Inf ?? say "\o/" !! say "/o\";}; 3 xyzzy

[22:20] <p6eval> alpha 30e0ed: OUTPUT«say requires an argument at line 10, near " \"/o\\\";}; "␤in Main (file src/gen_setting.pm, line 2593)␤»

[22:21] <moritz_> IllvilJa: aptitude install libcatalyst-perl # no CPAN fiddeling required :-)

[22:21] * jnthn was expecting 100 or so. :-)

[22:21] <lue> alpha: multi sub infix:<xyzzy>($a, $b=Inf) {$b~~Inf ?? say "\\o/" !! say "/o\\";}; 3 xyzzy

[22:21] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "xyzzy"␤in Main (file <unknown>, line <unknown>)␤»

[22:21] * lue sobs

[22:21] <bkeeler> rakudo: multi xyzzy($loc) { say "Nothing Happens." }; multi xyzzy($loc where { $loc ~~ "inside building"|"debris room" }) { say "Poof!" }

[22:21] <IllvilJa> Yes.  Well, it is a so called 'e-build' in gentoo, which pulls in 268 other e-builds as dependencies (every CPAN-module get's it's own e-build).

[22:21] <p6eval> rakudo 120147:  ( no output )

[22:22] <IllvilJa> I suspect that the gentoo folks 'by default' pulls in a lot of stuff considered useful to the 'causal Catalyst developer'.

[22:22] <pugssvn> r29893 | colomon++ | [t/spec] Refudge for Rakudo. 

[22:22] *** snarkyboojum left
[22:22] <IllvilJa> So the most used plugins get installed at the same time (authorization, authentication etc).

[22:22] <jnthn> bkeeler: You maybe get away with multi xyzzy($loc where "inside building"|"debris room") { ... }

[22:23] <bkeeler> Ah yes, thanks

[22:23] <jnthn> Whatever is RHS of where in a signature is just smart-matched against.

[22:23] <IllvilJa> But yes, Catalyst is fun and cool, but a lot of the simplicity it gives to you is due to a quite complex install.  With some luck, the installation complexity is automated (as in the genoo/e-build case, or when using the 'cpan' module on a more 'normal' linux hos).

[22:23] *** xabbu42 joined
[22:24] <pugssvn> r29894 | moritz++ | [t/spec] some rakudo unfudges 

[22:24] <IllvilJa> But I'm looking forward to use Catalyst on Perl6.  Hey, cannot that be used as a metric for when Perl6 is 'ready'?  That Catalyst runs on it?

[22:24] <IllvilJa> On production boxes?

[22:24] <lue> .oO(Is there any time ~~ is not better than == ?)

[22:24] <arlinius> lue: yes, when you want == :P

[22:24] <jnthn> When you mean ==

[22:25] <jnthn> lue: When you know you want a numerical comparrision.

[22:25] <lue> rakudo: say 3 ~~ 3;

[22:25] <p6eval> rakudo 120147: OUTPUT«1␤»

[22:25] <bkeeler> Coolness, got signatures working in my grammar partch.  rule foo($a) { 'foo' { say "A is $a" } 'bar' } etc etc

[22:25] <colomon> bkeeler: \o/

[22:26] <jnthn> \o/

[22:26] <jnthn> bkeeler++

[22:26] <jnthn> At some point, we should pipe it through pmichaud --code-review --apply-if-ok :-)

[22:27] <bkeeler> Yep.  I made some changes after the first review, but I'm about ready for a second

[22:27] <jnthn> Cool

[22:27] <bkeeler> Should write a few tests first though

[22:27] <jnthn> tests are good

[22:27] <lue> pmichaud --code-review --ok="apply" --not-ok="ask" -Ofun

[22:28] <jnthn> \o/

[22:30] <colomon> BTW, I'm pretty sure I've got 25,000+ tests passing now.

[22:30] <jnthn> \o/

[22:30] <bkeeler> \o/ colomon++

[22:30] <jnthn> colomon++

[22:30] <colomon> there were a lot of tests in pair.t.

[22:31] <jnthn> gah, commit rejected!

[22:31] <lue> ō\ we salute you, colomon

[22:31] <colomon> jnthn: sorry about that.

[22:31] <IllvilJa> find $RAKUDO_SOURCE_HOME -name=\* --exec pmichaud --code-review --ok="apply" --not-ok="ask" -Ofun --coffe-supply=/dev/espresso-maker

[22:32] <IllvilJa> If necessary to trick poor michaud into reviewing the entire source...

[22:32] <lue> error: unknown paramter: coffe-supply (did you mean coffee-supply) :)

[22:32] <jnthn> colomon: 'tis OK :-)

[22:32] <pmichaud> .oO(I have it on good knowledge that pmichaud doesn't drink much coffee :)

[22:33] <IllvilJa> Ah... s/coffe/coffee/g.  Hm, looks awfully perl5-ish... how do you express that in Perl 6 BTW?

[22:33] <pmichaud> I think the last time I drank coffee was 2002.

[22:33] <lue> pmichaud --send-complaints-to=/dev/null

[22:33] <pmichaud> maybe even 2001.

[22:33] <jnthn> pmichaud: wow!

[22:33] <IllvilJa> Yes, /dev/null is underrated, useful for tons of things.

[22:34] <jnthn> pmichaud: Tea?

[22:34] <dalek> rakudo: 1667377 | (Solomon Foster)++ | src/core/Enum.pm:

[22:34] <dalek> rakudo: Last version of Pair.hash was completely broken; this one is uglier but seems to work better.

[22:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1667377e3de3ebfa07ed2754f3eff598e0a1d65f

[22:34] <dalek> rakudo: fca8574 | (Solomon Foster)++ | t/spectest.data:

[22:34] <dalek> rakudo: Turn on S02-builtin_data_types/pair.t.

[22:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fca85745ffa3095abae3bf4355c1eaa7a5071813

[22:34] <dalek> rakudo: f4fdba4 | (Solomon Foster)++ | src/core/Enum.pm:

[22:34] <dalek> rakudo: Add Enum.hash.

[22:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f4fdba460d2c3d2be6107f8566b752c371d58b0f

[22:34] <pmichaud> Tea, yes.  Mostly Dr Pepper for caffeine

[22:34] <IllvilJa> pmichaud: so which year will you have the cup of coffe for THIS decade?  One cup a decade seem to be a healthy way to go :-D.

[22:35] * IllvilJa considering go make another pot of addictive, full caffeine grade, coffee

[22:35] <colomon> I don't think I've ever had a full cup of coffee....

[22:35] <lue> pmichaud --code-review --ok="apply" --not-ok="ask" --send-complaints-to=/dev/null --caffeine-source="/dev/autocaffiene" -Ofun

[22:35] <colomon> Hockey is going to overtime!  SWEEEET!

[22:36] <lue> yes, ain't it amazing?

[22:36] * bkeeler has a plumbed in espresso machine in his kitchen

[22:36] <jnthn> :-O

[22:36] <jnthn> That sounds almost as good as a plumbed in beer pump.

[22:36] <arlinius> bkeeler: you like liquid ash-tray?

[22:36] <bkeeler> Err no thanks

[22:37] <bkeeler> But I love a good espresso

[22:37] <arlinius> oh, I thought you said you had an espresso machine :P

[22:37] <lue> > jnthn --fix-code="rakudo/master" --when="now" --quality="A+"

[22:37] <lue> Completed in .4 seconds

[22:37] *** mssm joined
[22:37] <jnthn> lue: Yeah, I do that all the time, it's just the spectest runs that slow me down. :-P

[22:38] <bkeeler> And yes, I also have a "kegerator" as they're called in the states

[22:38] <colomon> ....which is why we need to have another round of optimization sometime soon.  :)

[22:38] <arlinius> so make rakudo faster? :P

[22:38] <lue> tardis --debug-file="jnthn.p6" --time-travel="enable" --ttopt="realtime"

[22:39] * colomon would really go for a kegerator full of Magners

[22:39] <lue> fixed 63 errors. Will run faster in future :)

[22:39] <jnthn> colomon: If I shave that many seconds of the spectest run again, it'll run in negative time. :-)

[22:40] <jnthn> Then I know my patch is FAIL before I've even finished writing it.

[22:40] <bkeeler> Mine is full of New Belgium Trippel

[22:40] <jnthn> .oO( sometimes I already know that anyway... )

[22:40] <lue> I really could use masak here. the jnthn omnisub would need a dang good parser builtin...

[22:41] <lue> masakbot --awaken --logon

[22:41] <jnthn> Yeah, well, I filled mine with borovička.

[22:41] <jnthn> colomon: Does Hash.Str working fix any tests?

[22:42] <colomon> One, at least, but I've got to think there must be more out there...

[22:42] <jnthn> :-)

[22:42] <colomon> probably indicates another test file we should be turning on somewhere....

[22:42] <jnthn> Almost finished testing.

[22:42] <jnthn> hash.t and hash-ret.t would be great to get.

[22:42] <colomon> yay!

[22:42] <jnthn> But I need to not fail at implementing hash slices first.

[22:43] <jnthn> ...or get beaten to implementing them...

[22:44] <lue> jnthn --implement="hash slices" --summon-ally="David Tennant"

[22:45] <lue> oh wait, sorry

[22:45] <dalek> rakudo: 1f2bd09 | jonathan++ | src/core/EnumMap.pm:

[22:45] <dalek> rakudo: Get EnumMap.Str (and thus Hash.Str) working again.

[22:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1f2bd09c20132625a5ea0184007bd650fd7669ae

[22:45] <lue> jnthn --cancel ; jnthn --implement="hash slices" --summon-ally="TimToady"

[22:46] <jnthn> EINSUFFICIENTBEER

[22:46] *** astrojp joined
[22:46] <lue> jnthn --include="/dev/beer.h"

[22:47] <bkeeler> You keep your C headers in /dev?

[22:48] <arlinius> yeah it leaves more room for device files in /usr/include

[22:48] <lue> I thought dev was for tools a DEVeloper needed :)

[22:48] <arlinius> lue &> /usr/include/null

[22:48] <bkeeler> hehe

[22:48] <lue> aaaaaaaaaaaaaaaaaaaaaaaaaaa

[22:48] *** lue left
[22:49] <arlinius> !

[22:49] *** lue joined
[22:49] <lue> error: lue not found. Recreating...

[22:51] <lue> ...done. Owner is lue. Group is lue. chmod rwxrwxr-x complete.

[22:52] <lue> where is everyone? this place was hopping a few seconds ago...

[22:56] <diakopter> .

[22:56] <IllvilJa> Well, the finale in Hockey in vancouver with Canada vs US were just finished and the winner is.... <to be filled in by the aid of lazy evaluation when you check out the game yourself>

[22:56] <lue> ah, the hockey game...

[22:57] <IllvilJa> So a lot of ppl were busy either looking up the facts, or checking their options for viewing the game WITHOUT having the result spoiled in advance :-).

[22:57] *** Su-Shee left
[22:58] <IllvilJa> I happened to shout out the fact that Sweden ladies won over Canada in the curling finale in this channel, without thinking about those who wanted to watch it afterwards... with the thrill of the event intact.

[22:58] <lue> rakudo: sub winner($a){$a=3 ?? say "Canada" !! say "US";}; $b=1; $b++; winner($b+1)

[22:58] <p6eval> rakudo 4d8935: OUTPUT«Symbol '$b' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[22:58] <lue> rakudo: sub winner($a){$a=3 ?? say "Canada" !! say "US";}; my $b=1; $b++; winner($b+1)

[22:58] <p6eval> rakudo 4d8935: OUTPUT«Canada␤Cannot assign to readonly value␤current instr.: '&die' pc 16676 (src/builtins/Junction.pir:347)␤»

[22:58] <IllvilJa> Wonderful summary of the game ;-).

[22:59] <jnthn> rakudo: say "The winner is {('USA', 'Canada').pick}!"

[22:59] <p6eval> rakudo 4d8935: OUTPUT«The winner is USA!␤»

[22:59] <jnthn> Rakudo knows.

[22:59] <lue> Can Any North American Combat All ?

[22:59] <lue> Can Any North American Defeat All ?

[22:59] <arlinius> canaca

[22:59] <IllvilJa> rakudo: say "The winner is {('USA', 'Canada').pick}!"

[22:59] <diakopter> pugs: say "The winner is {('USA', 'Canada').pick}!"

[22:59] <p6eval> rakudo 4d8935: OUTPUT«The winner is USA!␤»

[22:59] <p6eval> pugs: OUTPUT«The winner is Canada!␤»

[23:00] * lue kicks the dogs

[23:00] <arlinius> std: say "The winner is {('USA', 'Canada').pick}!"

[23:00] <p6eval> std 29894: OUTPUT«ok 00:01 109m␤»

[23:00] <arlinius> :)

[23:00] <IllvilJa> Hm... we have a candidate for a spectest coming up!

[23:00] <lue> alpha: say "The winner is {('USA', 'Canada').pick}!"

[23:00] <p6eval> alpha 30e0ed: OUTPUT«The winner is USA!␤»

[23:01] <jnthn> Rakudo seems pretty damm sure. :-)

[23:01] <jnthn> Clearly Pugs hasn't caught up with the latest spec changes here.

[23:01] <jnthn> :-)

[23:01] <diakopter> pugs: say "The winner is {('USA', 'Canada').pick}!"

[23:01] <p6eval> pugs: OUTPUT«The winner is USA!␤»

[23:01] <diakopter> pugs: say "The winner is {('USA', 'Canada').pick}!"

[23:01] <p6eval> pugs: OUTPUT«The winner is Canada!␤»

[23:01] <diakopter> pugs: say "The winner is {('USA', 'Canada').pick}!"

[23:01] <p6eval> pugs: OUTPUT«The winner is Canada!␤»

[23:01] <diakopter> pugs: say "The winner is {('USA', 'Canada').pick}!"

[23:01] <p6eval> pugs: OUTPUT«The winner is USA!␤»

[23:02] <IllvilJa> My confidence in pugs got even better :-D.

[23:02] <arlinius> pugs seems to be just choosing randomly with no knowledge of the game

[23:02] <diakopter> rakudo: say "The winner is {('USA', 'Canada').pick}!"

[23:02] <p6eval> rakudo 4d8935: OUTPUT«The winner is USA!␤»

[23:02] <lue> alpha: say "The winner is {my $a=('USA', 'Canada').pick}; ('USA', 'Canada').pick;}!" if $a~~"Canada" { die('liar!') }

[23:02] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "{ die('lia"␤in Main (file <unknown>, line <unknown>)␤»

[23:02] <IllvilJa> Well, given that we talk about hockey here, that's good enough for me.

[23:02] <lue> alpha: say "The winner is {my $a=('USA', 'Canada').pick}; ('USA', 'Canada').pick;}!"; if $a~~"Canada" { die('liar!') }

[23:02] <p6eval> alpha 30e0ed: OUTPUT«Symbol '$a' not predeclared in <anonymous> (/tmp/Zis7x7bMqH:10)␤in Main (file <unknown>, line <unknown>)␤»

[23:02] <diakopter> heh

[23:02] <arlinius> diakopter: maybe jnthn really *did* hardcode that one

[23:04] <diakopter> pugs: my$a;say "The winner is {$a=('USA', 'Canada').pick;}!"; if $a~~"Canada" { die('liar!') }

[23:04] <p6eval> pugs: OUTPUT«The winner is Canada!␤*** liar!␤    at /tmp/ltbAVHyg9D line 1, column 75-88␤»

[23:04] <diakopter> pugs: my$a;say "The winner is {$a=('USA', 'Canada').pick;}!"; if $a~~"Canada" { die('liar!') }

[23:04] <p6eval> pugs: OUTPUT«The winner is USA!␤»

[23:04] <diakopter> hm

[23:04] <pmurias> lue: the problem here is that there is a new lexical block in "{...}"

[23:04] <pmurias> s/block/scope/

[23:05] <IllvilJa> Well, maybe junctions would  come to the rescue here.  Until you have watched the game, it consists of a superposition of the probability functions of both US as well as Canada being victorious.

[23:05] <lue> alpha: say "The winner is {our $a=('USA', 'Canada').pick}; ('USA', 'Canada').pick;}!"; if $a~~"Canada" { die('liar!') }

[23:05] <p6eval> alpha 30e0ed: OUTPUT«Symbol '$a' not predeclared in <anonymous> (/tmp/X4Q4Ef3miP:10)␤in Main (file <unknown>, line <unknown>)␤»

[23:05] <IllvilJa> We can mess this up really badly if we get more coffe...

[23:05] * IllvilJa realizes that he got a steaming cup just in front of him! Beware, #perl6!

[23:05] <pmurias> alpha: say "The winner is {our $a=('USA', 'Canada').pick}; ('USA',  'Canada').pick;}!"; our $a;if $a~~"Canada" { die('liar!') }

[23:05] <p6eval> alpha 30e0ed: OUTPUT«The winner is Canada; ('USA',  'Canada').pick;}!␤liar!␤in Main (file /tmp/E4gHXlRTgE, line 10)␤»

[23:05] <arlinius> rakudo: my $winner = "USA"|"Canada"; say $winner eq "USA";

[23:05] <p6eval> rakudo 4d8935: OUTPUT«any(1, 0)␤»

[23:06] <lue> alpha: my $a = "Canada"&"USA"; say $winner eq "USA";

[23:06] <p6eval> alpha 30e0ed: OUTPUT«Symbol '$winner' not predeclared in <anonymous> (/tmp/snMQJn1brc:10)␤in Main (file <unknown>, line <unknown>)␤»

[23:06] <lue> alpha: my $a = "Canada"&"USA"; say $a eq "USA";

[23:06] <p6eval> alpha 30e0ed: OUTPUT«all(Bool::False, Bool::True)␤»

[23:07] * lue will use Explosion Principle. Wait one moment

[23:07] <IllvilJa> You probably knew this, but at one point in the tutorial for Catalyst, the perl 5 module 'Perl6::Junctions' is used which is sort of cool.

[23:07] <arlinius> rakudo: my $winner = "USA"|"Canada"; say ?($winner eq "USA");

[23:07] <p6eval> rakudo 4d8935: OUTPUT«1␤»

[23:07] *** pmurias left
[23:07] <IllvilJa> (Which makes me even more impatient on getting Catalyst dragged up onto the perl6 steed...)

[23:08] <lue> alpha: my $a=True; my $b=!True; my $c=(True and !True); my $canada=($a or True); say $canada

[23:08] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[23:08] <lue> alpha: my $a=True; my $b=!True; my $c=($a and $b); my $canada=($a or True); say $canada

[23:08] <p6eval> alpha 30e0ed: OUTPUT«1␤»

[23:09] <lue> no, it's supposed to come out false!

[23:10] <lue> .oO(explosion principle would be a good programming task)

[23:12] *** nihiliad left
[23:13] <colomon> jnthn: EnumMap.Str still broken, but I'll have it working properly in a minute.

[23:14] <colomon> Though what should it return if it is empty?

[23:15] *** nihiliad joined
[23:16] <colomon> alpha: my %h; say %h.Str;

[23:16] <p6eval> alpha 30e0ed: OUTPUT«␤»

[23:16] * lue --form-of="windmill guy"

[23:16] *** lue is now known as Guru-Guru

[23:16] <jnthn> colomon: Nothing I guess.

[23:16] <colomon> alpha: my %h = { a=>5 }; say %h.Str

[23:17] <jnthn> rakudo: my %h; say %h.Str

[23:17] <p6eval> alpha 30e0ed:  ( no output )

[23:17] <p6eval> rakudo 1f2bd0: OUTPUT«␤»

[23:17] <colomon> huh, that's weird.

[23:19] <colomon> alpha: my %h = { a=>5 }; say %h.perl

[23:19] <p6eval> alpha 30e0ed:  ( no output )

[23:19] <colomon> Am I doing something wrong there?

[23:20] <jnthn> huh

[23:20] <jnthn> No, that looks wrong.

[23:20] <jnthn> alphabug?

[23:20] <jnthn> :-/

[23:20] <jnthn> rakudo: my %h = { a=>5 }; say %h.perl

[23:20] <p6eval> rakudo 1f2bd0: OUTPUT«{"a" => 5}␤»

[23:20] <jnthn> rakudo: my %h = { a=>5 }; say %h.Str

[23:20] <p6eval> rakudo 1f2bd0: OUTPUT«"a" => 5␤»

[23:21] <colomon> I've got it figured out how to make it work properly in master.

[23:21] <colomon> self.pairs.map({ .Str ~ "\n" }).join();

[23:23] <jnthn> oh huh, I wrote .perl

[23:23] <jnthn> duh!

[23:23] * Guru-Guru --reset

[23:23] *** Guru-Guru is now known as lue

[23:24] <colomon> jnthn: no worries.  :)

[23:25] <colomon> spectesting the patch now, I don't imagine it will fail.

[23:26] <lue> karma --target="colomon" --cause="fail on $_"

[23:27] <arlinius> is this what you were looking for last night lue? http://perlcabal.org/syn/S02.html#Grammatical_Categories

[23:29] <lue> that seems to be it! \o/ (but firefox froze :( )

[23:29] <arlinius> firefox tends to do freeze on those pages :\

[23:30] <arlinius> (and in general)

[23:30] <colomon> I've found OS X Chrome works a lot better on those pages.

[23:31] <bkeeler> They have large parts of the test suite embedded in hidden frames, take a while for firefox to render

[23:31] <lue> just the percabal pages. Lot worse when I had firebug :)

[23:31] <bkeeler> It's slowish on my nice Mac Pro

[23:31] <arlinius> I get javascript errors with firefox (the continue/stop script) dialog)

[23:32] *** snarkyboojum joined
[23:32] <lue> me too. They ought to use CSS style:hidden and all that.

[23:32] <lue> instead of frames

[23:33] <pugssvn> r29895 | colomon++ | [t/spec] Unfudge now working test. 

[23:33] <bkeeler> They probably do, I was using the term frame a bit loosely

[23:33] <bkeeler> I haven't actually looked to see how they do it, mind you

[23:34] <arlinius> they look like iframes

[23:34] <lue> the hell... nobody uses those anymore! they're going to be deprecated.

[23:34] <arlinius> <iframe id="simple_134" style="display:none;" width="100%"></iframe>

[23:34] *** hejki joined
[23:35] <lue> use a <div>! it's better.

[23:35] <arlinius> div with scrolling?

[23:35] <lue> very possible.

[23:36] <lue> masakbot --awaken

[23:38] <dalek> rakudo: 588a345 | (Solomon Foster)++ | src/core/EnumMap.pm:

[23:38] <dalek> rakudo: Switch EnumMap.Str to use .Str ~ "\n" in its map.

[23:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/588a345ffcad37de0e38a238a4e191059731cb9c

[23:38] *** nihiliad left
[23:38] <bkeeler> That's not how you wake the masakbot

[23:38] <lue> I wonder how you define a ternary operator (?? !! conditional shortcut)

[23:39] <lue> bkeeler: then how?

[23:39] <bkeeler> You have to write your request on a piece of lutefisk and put it in his mouth

[23:40] * lue has the sudden urge to write a #perl6 interactive fiction ...

[23:41] <bkeeler> It is dark.  You are likely to be eaten by a Lue

[23:41] <pmichaud> .oO(Anything with "Perl 6" in it must be fictional.)

[23:42] <lue> > examine car

[23:42] <lue> it is the ApocolypseMobile!

[23:43] <lue> > drive car

[23:43] <lue> you need the Synopsis warpdrive to drive the ApocolypseMobile

[23:45] <bkeeler> hacking rakudo is like figuring out how to get the babelfish in that silly game

[23:45] <lue> what, in the H2G2 text game? It's not that hard (when you know)

[23:45] <bkeeler> Of course it's not hard when you know how

[23:45] <bkeeler> It's when you don't know how that it's hard

[23:46] <jnthn> ...knowing how is a requirement?

[23:46] <jnthn> :-)

[23:46] *** lue is now known as P6_IFgame

[23:46] <jnthn> bkeeler: You find your way around after a while. :-)

[23:46] <P6_IFgame> It is dark. You are likely to be eaten by a lue.

[23:47] <pmichaud> You are lost in a maze of twisty ParrotMagicCorridors (PMCs), all different.

[23:47] <P6_IFgame> pmichaud: invalid command.

[23:47] <pmichaud> P6_IFgame: plugh

[23:47] <P6_IFgame> pmichaud: nothing interesting happens.

[23:48] *** xabbu42 left
[23:49] <P6_IFgame> the lue is getting closer.

[23:49] <P6_IFgame> you hear several lues getting closer.

[23:50] <P6_IFgame> ***You have died***

[23:50] *** P6_IFgame is now known as lue

[23:50] <lue> yummy. :)

[23:52] *** nihiliad joined
[23:57] * jnthn -> rest

[23:57] <lue> good rest, jnthn

[23:57] <jnthn> o/

