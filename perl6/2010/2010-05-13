[00:01] *** Schwern left
[00:04] *** xinming joined
[00:06] *** justatheory left
[00:07] *** Trashlord left
[00:09] *** Trashlord joined
[00:17] *** sahadev left
[00:20] *** alester joined
[00:23] *** lestrrat is now known as lest_away

[00:27] *** Chillance left
[00:33] <sorear> pmichaud: I'm confused about the function and relationship between Perl6Scalar and ObjectRef

[00:34] <sorear> I can see why we need one of them, to implement the distinction between binding and assignment.  But both?

[00:35] <pmichaud> at one point we needed "soft references" versus "hard references"

[00:35] <pmichaud> we may still need that, which is why it hasn't been completely taken out

[00:36] *** masonkramer joined
[00:36] <jnthn> pmichaud: iirc, we're currently only using one of them?

[00:36] <pmichaud> but you're correct that the function is not a purely bright line in rakudo at the moment

[00:36] <pmichaud> jnthn: we have instances of both in the codebase, iirc

[00:36] <jnthn> OK

[00:36] <pmichaud> I was going to see about cleaning it up as part of fixing the binding semantics

[00:36] <jnthn> OK, cool.

[00:36] <masonkramer> I read somewhere that in perl 6, it will be possible to ask for machine ints instead of sv's...is that still in the cards? and if so, could anyone point me towards more information about it

[00:37] <pmichaud> masonkramer:    my int $x;

[00:37] <jnthn> masonkramer: It's spec'd in S09

[00:37] <pmichaud> (note lowercase 'i')

[00:37] <jnthn> masonkramer: Rakudo doesn't implement it yet, sadly.

[00:37] <pmichaud> CNYI in Rakudo at the moment.

[00:37] <jnthn> On the cards post-Rakudo *.

[00:38] *** yinyin joined
[00:39] <sorear> note, however, that it won't be helping performance for a while

[00:39] <sorear> even once it's implemented

[00:39] <sorear> because MMD optimization is a completely orthogonal problem

[00:39] <masonkramer> Hmm...not sure I follow you

[00:39] <sorear> has int $.field is good for memory usage regardless

[00:39] <masonkramer> I thought one of the problems is that double indirection requires double dereferencing

[00:39] <sorear> when we implement native types, $int1 + $int2 will work like this:

[00:40] <sorear> 1. Wrap $int1 and $int2 into freshly constructed Int object

[00:40] <sorear> 2. Fetch the multisub list for &infix:<+>

[00:40] <sorear> 3. Filter out candidates that can't handle two ints

[00:40] <sorear> 4. Call the best one

[00:41] <sorear> once we have local type inference / MMD optimization:

[00:41] <sorear> 1. Wrap $int1 and $int2 into freshly constructed Int objects

[00:41] <jnthn> sorear: 3 isn't really right fwiw.

[00:41] <sorear> 2. Call &infix:<+>:(Int,Int)

[00:41] <jnthn> But you probably know that. :-)

[00:41] <sorear> once we have that + inlining

[00:41] <sorear> 1. addl %ecx, %edx

[00:42] <sorear> jnthn: actually I haven't studied the MMD kernel all that much yet.  I know it does funky things with posets and inheritence metrics, but that's about it

[00:42] <jnthn> (The algorithm is just a case of looking through the sorted candidate list until we find one that matches, then calling that. Once we find a match, we (usually) ignore the rest of the list)

[00:43] <jnthn> posets?

[00:43] <jnthn> Gee, I hope I wasn't meant to know what they were when I implemetned it. :-)

[00:43] <jnthn> It just makes a DAG based on an n-by-n smart-matching of type objects.

[00:43] <sorear> posets are basically a kind of directed graph

[00:43] <jnthn> It's a DAG.

[00:43] <sorear> when you look at a poset, your frame of reference is the ordering

[00:44] <sorear> two nodes are > < or incomparable

[00:44] <jnthn> If that view implies topological sorting, then it's probably fine.

[00:44] * jnthn is not a graph theorist :-)

[00:44] <sorear> topological sorting is the link between the poset view and the DAG view

[00:44] <jnthn> Ah, OK.

[00:44] <sorear> they're the same concept seen from different angles

[00:45] <jnthn> I hadn't heard the term "poset" before. Nice to know.

[00:46] <sorear> (note that, since topological sorting is strictly a finite algorithm, infinite posets and infinite DAGs are not *quite* the same)

[00:46] *** autin joined
[00:48] <jnthn> .oO( and now I'm glad I'm not a graph theorist :-) )

[00:48] <sorear> neither am I

[00:48] <diakopter> sorear: I thought 2/3/4 can happen at compile-time

[00:48] <sorear> diakopter: that's called an optimization

[00:48] <sorear> diakopter: and we don't have nearly enough manpower to do everything at once :/

[00:49] <diakopter> :P

[00:49] <diakopter> why so defensive?

[00:49] <sorear> so, there will probably be a revision of rakudo with native ints but no MMD optimization

[00:49] <sorear> Personal failing.  Please make me aware.

[00:50] <diakopter> ok; I was just verifying that the model in my head was correct-ish

[00:50] <diakopter> (that MMD can happen at compile-time)

[00:50] <diakopter> for variables with type annotations.

[00:50] <sorear> diakopter: Yes; that was in the second version of my explanation

[00:50] <diakopter> (and for ones without, given inference)

[00:51] <sorear> 17:41 < sorear> once we have local type inference / MMD optimization:

[00:51] <sorear> 17:41 < sorear> 1. Wrap $int1 and $int2 into freshly constructed Int objects

[00:51] <jnthn> and you know all the candidates and that they don't require runtime subset checks... :-)

[00:51] <sorear> 17:41 < sorear> 2. Call &infix:<+>:(Int,Int)

[00:51] <sorear> could I have done this clearer?

[00:51] <diakopter> well

[00:51] <sorear> IMO the natural way to do this is specialized MMD trampolines.

[00:52] <sorear> "Call through this if you have an Int and an Int"

[00:52] <diakopter> my question wasn't addressing your statements' clarity

[00:52] <sorear> it might point to the only candidate

[00:52] <sorear> or, if there becomes more than one, it can be redirected to the general dispatcher

[00:53] <diakopter> I don't see why an int would become an Int... why wouldn't there be an &infix:<+>:(int,int)

[00:53] <masonkramer> I'm sorry to ask, but what does MMD stand for? (naturally, I understood very little of what just transpired in this room :))

[00:54] <sorear> masonkramer: multi-method-dispatch

[00:54] <sorear> basically

[00:54] <sorear> you have a normal sub - there's one function, direct call

[00:54] <masonkramer> ohh

[00:54] <masonkramer> this is same name, different function sigs

[00:54] <sorear> you have a method (a virtual one, if you go that way) - one function per slot in the inheritence hierarchy

[00:55] <sorear> yes

[00:55] *** jonrafkind left
[00:55] <diakopter> sorear: did you see my question above?  ^^

[00:56] <sorear> diakopter: Primitive types cannot be passed to polymorphic functions

[00:56] <sorear> So the MMD engine would have to receive Int and Int

[00:56] <diakopter> I assume you're going to follow that up with an explanation of why Primitive types cannot be passed to polymorphic functions

[00:57] <sorear> I'm not sure if it makes sense to have &infix:<+>:(int,int), in light of the fact that the MMD engine can never see an int

[00:57] <sorear> diakopter: main reason is that it screws up the garbage collector

[00:57] <sorear> the GC needs to know what's a pointer

[00:58] <sorear> that means that a given stack slot should either be able to hold Any, or int, but not both

[00:58] <diakopter> ok. on my VM, it knows the difference between primitive types and reference types

[00:58] <sorear> exactly

[00:58] <diakopter> right, so it wouldn't "screw up the garbage collector"

[00:58] <sorear> you can't write a single function that accepts Object and int in the JVM; I'm sure CIL is the same

[00:59] <diakopter> eh?

[00:59] <sorear> it doesn't "screw up the garbage collector" because the runtime manager /doesn't let you do it/

[00:59] <diakopter> why can't you write a single function that accepts Object and int in the JVM?

[01:00] <masonkramer> "you can't write a single function that accepts Object and int in the JVM" - but the dispatcher accepts a function name and a signature and finds the method that accepts two ints...

[01:00] <jnthn> diakopter: I think sorear's point is that if you have a Capture and it's just a list of objects, things have to be auto-boxed. OTOH, you may be able to define a Capture type that can hold low-level types too.

[01:00] <sorear> Because you can't.  It's against the rules.  Functions (I'm talking about functions here, not overloaded sets of functions) have to set an argument type

[01:00] *** BrowserUk joined
[01:00] <sorear> It can be [java.lang.Object; or I

[01:00] <sorear> not both

[01:00] <sorear> er, java/lang/Object

[01:00] <diakopter> oh, I didn't realize you were talking about a single argument.

[01:01] <diakopter> that wasn't clear

[01:01] *** lest_away is now known as lestrrat

[01:01] <sorear> Oh.  Sorry about that.

[01:01] <sorear> masonkramer: Using the dispatcher to implement the dispatcher is going to require some very careful tiptoeing around the circularity saw.

[01:01] <sorear> It's probably possible, but I'm not smart enough to do it

[01:03] <diakopter> jnthn: I suspect you're right.

[01:03] <sorear> A few years ago, some far-too-clever ML hackers implemented a garbage collector with a built-in type inference engine, which was able to walk up and down the stack and determine, by looking at who passed what arguments where, what was actually a reference.  They could pass full-word non-references to polymorphic functions.

[01:03] <sorear> jnthn: Exactly

[01:04] <sorear> jnthn: Although, if you "define a Capture type that can hold low-level types too", that's just autoboxing by any other name

[01:04] <diakopter> I think my problem is I can't picture in my mind this thing you call "the MMD engine"

[01:04] <sorear> Hmm, I'm typing rather quickly.  Usually that means I'm attacking someone?

[01:05] *** sahadev joined
[01:05] <diakopter> I don't know; does it? :)

[01:05] <jnthn> Could just be higher than usual coffee intake. ;-)

[01:05] <BrowserUk> ?

[01:05] <phenny> BrowserUk: 12 May 09:28Z <ruoso> tell BrowserUk please take a look at perl6-language history. TimToady sent your comments about the threading model there and I'm posting a reply...

[01:05] <masonkramer> sorear: no, you're not - I am learning a lot - it feels like drinking from a firehose, but it's not aggressive

[01:06] <sorear> diakopter: It can take many forms.  Ours lives in src/pmc/perl6multisub.pmc, in particular the 'invoke' vtable

[01:06] *** orafu left
[01:08] *** orafu joined
[01:08] *** wknight8111 left
[01:09] <diakopter> I think it will be interesting to observe p6 code written when primitive types are implemented/available as well as Any.  I postulate that there will be a goodly amount of primitive type annotations.

[01:11] <sorear> You really only need them for function arguments

[01:11] *** eternaleye left
[01:11] <diakopter> given the presence/behavior of coercions, the most-used coercions will of course still work

[01:11] <sorear> Everything else can be produced by a straightforward fixed-point analysis

[01:11] <sorear> Kleene++

[01:11] *** BrowserUk left
[01:12] <diakopter> sorear: do you mean as opposed to just-plain-locals?

[01:12] <sorear> yes

[01:12] <diakopter> ij

[01:12] <diakopter> ok

[01:14] *** justatheory joined
[01:14] <masonkramer> fixed point analysis?  "everything else"?

[01:14] <sorear> Ok

[01:15] <sorear> First, you need a finite model

[01:15] <diakopter> finite model?

[01:15] <sorear> of Any

[01:15] <sorear> for this, we'll need to reduce Any to a finite set of values

[01:15] <sorear> like Any(), {all defined Ints}, {all objects of type ClassHOW}, etc

[01:15] <masonkramer> Any is a finite set, ok

[01:15] <masonkramer> keep going :)

[01:16] <sorear> now make a big table of all the variables in your function, and the subset of values it can take

[01:16] <sorear> initially, assume that arguments can hold the values in their signatures, and variables nothing

[01:16] <sorear> when you get to a statement, add all possibilities

[01:16] <masonkramer> <phase space of a function signature S, loaded>

[01:17] <sorear> since there are only a finite number of variables and a finite number of values in our model, you can only add a possibility a finite number of times

[01:17] <sorear> which means that the iteration is guaranteed to terminate

[01:17] <diakopter> barring overflow?

[01:17] <sorear> there's some brilliant work by Kleene showing that the state at the end of the iteration is consistant

[01:18] <sorear> so we now have a type signature for every variable

[01:18] <sorear> for best results, transform into SSA first

[01:18] <sorear> diakopter: Overflow?

[01:19] <diakopter> never mind; I must be a bumbling idiot.  Proceed.

[01:27] *** snarkyboojum left
[01:30] *** pencilk joined
[01:33] *** Oktal joined
[01:40] <sorear> oh, one more thing

[01:40] <sorear> in the ideal world, where we just use subsets of Any directly, the calculation is exact

[01:40] <sorear> you always get the precise sets of legal values

[01:41] <sorear> not subsets of Any, but subsets of Any^{number of variables}

[01:41] <sorear> but if you do it that way, it usually won't halt

[01:41] <sorear> since it amounts to running every possible trace of the function

[01:42] <sorear> when you use the finite model, you create a halting language based on the language, which you can use for analysis

[01:42] <sorear> the art of fixed point analyzers lies in choosing the right model - fine enough to tell you what you need, but coarse enough to keep runtime under control

[01:44] *** snarkyboojum joined
[01:45] *** sahadev left
[01:48] <masonkramer> so...just to make sure I'm on the same page as you - fixed point analysis is a way of inferring type based on iterating through the entire phase M of the function signature + variables of a function,  considering all possible values for every variable and argument in the entire phase space, and then inferring a type that can hold all possible values for each function?

[01:51] <masonkramer> *for each variable

[01:51] <masonkramer> ?

[01:54] <sorear> Yes.

[01:54] <sorear> Because the notion of "type" is so broad it actually underpins several different optimizations

[01:58] <sorear> nqp: loop { say(2); last; }

[01:58] <p6eval> nqp: OUTPUT«Confused at line 1, near "loop { say"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[01:58] <sorear> nqp: repeat { say(2); last; }

[01:58] <p6eval> nqp: OUTPUT«Confused at line 1, near "repeat { s"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[01:58] <sorear> nqp: while 1 { say(2); last; }

[01:58] <p6eval> nqp: OUTPUT«2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2␤2􏿽xE2􏿽x90

[01:59] <sorear> Help

[02:07] <masonkramer> haha

[02:13] <masonkramer> sorear: it just seems rather slow (impossibly slow?) to iterate the entire phase space of a function, (with phase_space = set_size_of(Any)^n) in order to do type inference.  I think there's something I'm missing up there around there is "choosing the right model...keep runtime under control" - what I don't understand is why this type inference would be happening at runtime

[02:13] <sorear> masonkramer: the run time of the compiler

[02:13] <sorear> set_size_of(Any) is infinity

[02:14] <masonkramer> but you can model it in a way that is feasibly computable

[02:14] <sorear> the unapproximated algorithm only works in mathland

[02:14] <masonkramer> that's what you're trying to tell me

[02:14] <sorear> yes

[02:14] <masonkramer> neato

[02:19] *** agentzh joined
[02:21] *** snarkyboojum left
[02:22] *** justatheory left
[02:23] *** lestrrat is now known as lest_away

[02:24] <masonkramer> So - is compile-time type inference already in Rakudo?  my $i = "25" + 10; #what is $i's type?

[02:24] *** eternaleye joined
[02:24] <sorear> masonkramer: Any

[02:26] *** felipe left
[02:27] <masonkramer> But could it theoretically be inferred to be an Int?  Since, in the enumeration, it can only contain values that are legal for Int? 

[02:29] *** JimmyZ joined
[02:31] <sorear> It could if any of this was implemented in Rakudo

[02:32] <masonkramer> but from what you were saying earlier, there is no real benefit to doing that until MMD optimization

[02:32] <sorear> Yes.

[02:39] <dalek> nqp-rx: 458dbfe | sorear++ |  (2 files):

[02:39] <dalek> nqp-rx: Implement :flat :named (|%hash)

[02:39] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/458dbfebbba4fd729cea616a0a8a69811e6d8fbe

[02:39] *** eternaleye left
[02:44] *** sahadev joined
[02:49] <colomon> masonkramer: If you have a + with something that's not a Numeric type on both sides, each side is converted to Numeric if possible.

[02:49] <colomon> rakudo: say "25".Numeric

[02:50] <p6eval> rakudo ed2409: OUTPUT«25␤»

[02:50] <colomon> rakudo: say "25".Numeric.WHAT

[02:50] <p6eval> rakudo ed2409: OUTPUT«Num()␤»

[02:51] <colomon> rakudo: say "25" + 10

[02:51] <p6eval> rakudo ed2409: OUTPUT«35␤»

[02:52] <masonkramer> colomon: but I'm thinking about this from the PoV of compile-time type checking.  $i with an Int type would tend to be more useful for that purpose

[02:53] *** eternaleye joined
[02:56] <colomon> and I'm telling you what Rakudo actually does.

[02:57] <masonkramer> right - thank you

[03:01] *** plobsing joined
[03:22] *** Schwern joined
[03:22] *** bubaflub left
[03:29] <dalek> nqp-rx: f5f582d | sorear++ |  (3 files):

[03:29] <dalek> nqp-rx: Basic loop control (next/last/redo terms)

[03:29] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/f5f582d2d87cea6218cf454d125e27e6eb8f2e0f

[03:37] *** xinming left
[03:38] *** sahadev left
[03:41] <dalek> nqp-rx: 379f1b2 | sorear++ | src/NQP/Grammar.pm:

[03:41] <dalek> nqp-rx: Fix a typo (pmichaud++)

[03:41] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/379f1b2d4f58e17ad51dfdf3748aaa57a0547fe9

[03:45] *** patspam left
[03:50] *** Oktal left
[03:51] <diakopter> TimToady: did you see this one: http://lamp.epfl.ch/~phaller/doc/haller07actorsunify.pdf

[03:52] *** rv2733 joined
[03:57] *** jonrafkind joined
[04:00] *** am0c joined
[04:03] <dalek> nqp-rx: c5482a9 | pmichaud++ |  (2 files):

[04:03] <dalek> nqp-rx: Switch HLL::Actions to use find_codepoint opcode, bump PARROT_REVISION.

[04:03] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/c5482a92b82ba3765624acc1397e58708bc16a77

[04:10] <colomon> masonkramer: I keep on thinking about what you could know at compile time with that example.

[04:11] <colomon> On the one hand, if the equation is just "25" + 10, it can not only know the answer is an Int (assuming Str.Numeric can return an Int), it can know the Int is 35.

[04:12] <colomon> If all you actually know is Str + Int, then you can easily say the type is either Numeric or Fail.

[04:12] <colomon> But I'm not sure how much better than that you can get.

[04:12] *** rv2733 left
[04:33] *** Intensity joined
[04:38] *** pencilk left
[04:40] <sorear> colomon: there's only one multi that matches that situation, the (Any + Any) one, so the code is inlined to Str.Numeric + Int.Numeric

[04:40] <sorear> Int.Numeric is inlined to Int

[04:40] <sorear> Str.Numeric has a type signature which specs a return of Int|Num

[04:40] <sorear> so we see Int|Num + Int

[04:40] <sorear> which is (Int + Int)|(Num + Int)

[04:40] <sorear> = Int|Num

[04:41] *** snarkyboojum joined
[04:50] <eternaleye> In S05, under :exhaustive, it says 'say "@()";' - shouldn't this be @[], since it's a zen slice of @/ and not an invocation?

[04:53] <sorear> @/ doesn't exist

[04:53] <sorear> @() is a list of all anonymous captures

[05:10] *** xinming joined
[05:24] *** felipe joined
[05:28] <dalek> nqp-rx: c3b0e83 | sorear++ | src/stage0/ (3 files):

[05:28] <dalek> nqp-rx: Rebootstrap so REPL stuff can use |% and last

[05:28] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/c3b0e83602b6872d768e6ea8db8802209afad98e

[05:33] *** lest_away is now known as lestrrat

[05:34] *** snarkyboojum left
[05:38] *** Schwern left
[05:49] *** [mark] joined
[05:53] <eternaleye> diakopter: Fascinating example of parallel development: a similar paper was published the same year at a different conference, but in Haskell. See my message to p6-lang for the link. The main difference I'm seeing is that the Haskell one focused on client-server relationships, rather than actor-model, but unifying the two papers' approaches could prove very interesting.

[06:03] *** hercynium left
[06:04] *** hercynium joined
[06:06] <eternaleye> diakopter: On reading more closely, they actually refer to the one I linked as citation 15

[06:08] <eternaleye> diakopter: Their 'receive' looks one _heck_ of a lot like our given/CATCH/etc - this paper's a great find!

[06:10] <eternaleye> And gather/take could probably be implemented trivially on top of their actor { ... } construct

[06:12] *** pencilk joined
[06:13] *** hercynium left
[06:13] *** alester left
[06:14] <eternaleye> probably using a send( gatherActor, 'get' ) -> receive { when 'get' { try { $gatherblock.() CATCH { reply($_) } } } } or some such

[06:15] *** snarkyboojum joined
[06:18] *** aindilis joined
[06:19] *** hercynium joined
[06:24] *** rv2733 joined
[06:27] <diakopter> eternaleye: :)

[06:27] <eternaleye> Or maybe more like actor { try { $gatherblock.() CATCH { my $taken = $_; receive { when 'get' { reply( $taken ) } } } } }

[06:28] <diakopter> let's see what daniel says

[06:28] <eternaleye> + a resume($taken)

[06:29] <eternaleye> That whole paper is just ridiculously elegent and intuitive, without sacrificing usability

[06:30] <eternaleye> It even would live the Perlish idea of 'you can modify the underlying system'

[06:31] <diakopter> it received best paper at the conference at which it was presented

[06:31] <eternaleye> The one I linked to was in the /topic back when Pugs was still the leading implementation - I'd say _this_ paper should be in the /topic today

[06:31] <diakopter> heh.  I assume you meant a  ;  before the  CATCH

[06:32] <eternaleye> Ah, yes

[06:33] <diakopter> when viewed through a dark lens, ruoso's proposal(s) aren't all that dissimilar (being actor-ish)

[06:33] <eternaleye> The beauty is that what I entered is very nearly feature-complete as an implementation of gather, all it would need added would be getArg and batch and batchArg variants

[06:34] <diakopter> yeah but, someone has to implemenat actor and receive/reply and ... scala

[06:34] <eternaleye> Which are trivial loops and/or maps of reply() and resume() with slice()

[06:35] <eternaleye> Well, the scala bits are almost superfluous. The actor() and receive/reply would be some work, yes, but the parrot hybrid threads GSoC would lay a great deal of the groundwork

[06:42] <eternaleye> "Unfortunately, on the JVM there is no safe way for library code to ﬁnd out if a thread is

[06:42] <eternaleye> blocked." - this is something we could address, since Parrot is still figuring out its threading system

[06:47] <diakopter> luckily for me, CLR provides ThreadState of which WaitSleepJoin means blocked

[06:49] *** k23z__ joined
[06:50] <eternaleye> Hm, andThen/orElse would need renamed, which would likely be an unbelievably colorful bikeshed

[06:51] <eternaleye> (orElse and orelse meaning vastly different things would probably be a Bad Idea)

[07:02] <eternaleye> Ooh, looking on his website there's a 2009 paper on the subject

[07:02] <eternaleye> (Philipp Haller, that is)

[07:04] *** clintongormley joined
[07:05] <eternaleye> His website is a gold mine: http://lamp.epfl.ch/~phaller/

[07:06] *** snarkyboojum_ joined
[07:09] *** snarkyboojum left
[07:09] *** snarkyboojum_ is now known as snarkyboojum

[07:17] *** meppl joined
[07:21] *** iblechbot joined
[07:22] *** jonrafkind left
[07:22] <eternaleye> diakopter: His paper on translucent functions is interesting, as it points out (and then fixes) a performance trap in the original paper.

[07:24] <eternaleye> Hm, maybe the trap could be avoided altogether by reusing MMD semantics rather than given/when semantics...

[07:27] <eternaleye> No, that wouldn't avoid it, just make it easier to minimize by using a well-optimized building block. The algorithm would still be flawed.

[07:30] *** snarkyboojum left
[07:36] <eternaleye> Hm, translucent functions might have a hard time coexisting with junctions

[07:36] *** [mark] left
[07:41] *** Su-Shee joined
[07:41] <eternaleye> Also, it seems incompatible with when's use of smartmatching rather than just typechecking. Perhaps a shared queue like in the original, with 'virtual' queues for each condition, and virtual queues are populated with references to the object in the shared queue which matches the condition? That also obviates the need for the timestamp, since the messages are time-ordered in the shared queue, but it avoids having to rescan the whole queue on

[07:41] <eternaleye>  react {...} calls. It would need backreferences to remove handled messages from virtual queues other than the matched one though

[07:41] *** Schwern joined
[07:43] <eternaleye> Join patterns could be represented by & junctions as the when clause

[08:07] <moritz_> good morning

[08:07] <phenny> moritz_: 12 May 23:08Z <bubaflub> tell moritz_ ok.  lemme know if i should add similar tests for the other twigils

[08:22] *** plobsing left
[08:23] <moritz_> phenny: tell bubaflub sure, would be great to have some kind of systematic test for all of them - see http://perlcabal.org/syn/S02.html#line_1849 for the complete list; if you have troubles using one of them, feel free too ask

[08:23] <phenny> moritz_: I'll pass that on when bubaflub is around.

[08:23] <moritz_> std: :$<a>

[08:23] <p6eval> std 30620: OUTPUT«===SORRY!===␤Bogus statement at /tmp/2XpONBVXfq line 1:␤------> <BOL>⏏:$<a>␤Parse failed␤FAILED 00:01 113m␤»

[08:24] <moritz_> TimToady: shouldn't that construct a colon pair, like other combinations of colon + twigil'ed variable?

[08:24] <moritz_> :$~foo

[08:24] <moritz_> std: :$~foo

[08:24] <p6eval> std 30620: OUTPUT«ok 00:01 110m␤»

[08:29] *** Schwern left
[08:34] *** dakkar joined
[08:45] *** fridim_ joined
[08:50] *** envi^home joined
[08:51] <pugssvn> r30621 | moritz++ | [S06] fill empty section with a reference to what we have about that topic 

[08:58] *** snarkyboojum joined
[09:01] *** dakkar left
[09:02] *** dakkar joined
[09:05] *** kfo joined
[09:15] *** iblechbot_ joined
[09:16] <sjohnson> hello

[09:16] *** iblechbot left
[09:17] <sorear> hi

[09:25] *** proller left
[09:31] *** am0c left
[09:39] *** pmurias joined
[09:40] *** proller joined
[09:40] <sjohnson> sorear: hi

[09:41] *** masak joined
[09:41] <masak> oh hai, #perl6

[09:41] <sjohnson> hji

[09:42] <dalek> book: 4bdbcd4 | moritz++ | src/subs-n-sigs.pod:

[09:42] <dalek> book: [subs] correct syntax in an example

[09:42] <dalek> book: review: http://github.com/perl6/book/commit/4bdbcd4609041353607adabf3e2c69d69c67ec79

[09:42] <dalek> book: 6418b41 | moritz++ | src/subs-n-sigs.pod:

[09:42] <dalek> book: [subs] first shot at introspection

[09:42] <dalek> book: review: http://github.com/perl6/book/commit/6418b41e195cc338aa7427b7fa6b7faad7f57a01

[09:42] <masak> rakudo: say ('h' .. 'j')[0, 2, 1]

[09:42] <p6eval> rakudo ed2409: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Range'␤current instr.: '!postcircumfix:<[ ]>' pc 11329 (src/builtins/Role.pir:26)␤»

[09:42] <sjohnson> （　｀ー´）

[09:42] <masak> bug or feature?

[09:42] <masak> should I be able to index a range?

[09:42] <moritz_> bug, IMHO

[09:42] * masak submits it as such

[09:42] <moritz_> alpha: say ('h' .. 'j')[0, 2, 1]

[09:42] <p6eval> alpha 30e0ed: OUTPUT«hji␤»

[09:42] <sjohnson> ... damn bugs..

[09:42] <moritz_> pugs: say ('h' .. 'j')[0, 2, 1]

[09:42] <p6eval> pugs: OUTPUT«hji␤»

[09:43] * sjohnson sprays raid on rakudo

[09:43] <moritz_> all sane implementations agree :-)

[09:43] <moritz_> elf: say ('h' .. 'j')[0, 2, 1]

[09:43] <p6eval> elf 30621: OUTPUT«Can't call method "postcircumfix__91_32_93" without a package or object reference at (eval 128) line 3.␤ at ./elf_h line 5881␤»

[09:43] <masak> in other news, I dig chromatic's post http://www.modernperlbooks.com/mt/2010/05/dont-make-the-robot-devil-angry.html

[09:43] <masak> and I feel for Aaron Sherman on p6c. I hope he gets a good answer.

[09:44] <masak> (partly because I want to know it too.)

[09:45] *** am0c joined
[09:45] *** TiMBuS joined
[09:47] <moritz_> rakudo: my regex foo { f.o }; say Grammar.parse('fuo', :rule(&foo))

[09:47] <p6eval> rakudo ed2409: OUTPUT«fuo␤»

[09:47] <moritz_> that's no the answer you were looking for, right? :-)

[09:48] <sjohnson> rakudo:  declare something; test the next thing; print what the value is

[09:48] <p6eval> rakudo ed2409: OUTPUT«Could not find sub &something␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:48] <masak> yeah, at least part of it.

[09:49] <masak> it doesn't answer the question asked: how do I call a grammar rule from an rx rule?

[09:49] <masak> /<foo>/ seems to no longer work, is that intentional?

[09:50] <moritz_> nope; by latest spec it should first search for a lexical &foo, then for a method

[09:50] <moritz_> rakudo doesn't do the lexical searching yet

[09:50] <masak> hm; makes sense.

[09:50] <masak> I think that it doing so is an R* priority.

[09:50] <moritz_> +1

[09:51] <masak> preferably sooner.

[09:55] <cognominal> what is the way to call a method when you have its name as a string?

[09:55] <moritz_> $obj."$method-name"()

[09:57] <masak> parens required to protect against concat p5ism.

[09:58] <cognominal> thx, I thought I tried it.

[09:58] <cognominal> apparently noy

[09:58] <cognominal> *not

[09:59] *** moritz_ sets mode: +oo masak cognominal

[10:00] <moritz_> I've tried to change the subversion post-commit hook to put the first line of the log message into the email subject

[10:01] <sjohnson> $obj.~$method-name; <-- won't this work too?

[10:01] <moritz_> I seriously doubt it

[10:01] <moritz_> std: my ($obj, $meth); $obj.$method

[10:01] <p6eval> std 30621: OUTPUT«===SORRY!===␤Variable $method is not predeclared at /tmp/IgoFtx8Z4L line 1:␤------> my ($obj, $meth); $obj.$method⏏<EOL>␤Check failed␤FAILED 00:01 113m␤»

[10:01] <moritz_> std: my ($obj, $meth); $obj.$meth

[10:01] <p6eval> std 30621: OUTPUT«ok 00:02 112m␤»

[10:01] <moritz_> std: my ($obj, $meth); $obj."$meth"

[10:01] <p6eval> std 30621: OUTPUT«===SORRY!===␤Unsupported use of . to concatenate strings or to call a quoted method; in Perl 6 please use ~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses at /tmp/vytlUJK4dr line 1:␤------> my ($obj, $meth);

[10:01] <p6eval> ..$o…

[10:01] <moritz_> std: my ($obj, $meth); $obj."$meth"()

[10:02] <p6eval> std 30621: OUTPUT«ok 00:01 112m␤»

[10:02] <moritz_> std: my ($obj, $meth); $obj.~$meth

[10:02] <p6eval> std 30621: OUTPUT«===SORRY!===␤Confused at /tmp/hTvKMPPq95 line 1:␤------> my ($obj, $meth); $obj.⏏~$meth␤    expecting postfix_prefix_meta_operator␤Parse failed␤FAILED 00:01 112m␤»

[10:03] <moritz_> if there are problems with commit hooks, feel free to bug me

[10:07] *** snarkyboojum left
[10:10] *** snarkyboojum joined
[10:11] *** yinyin left
[10:17] <masak> here's someone else who doesn't like Second Systems: http://www.schockwellenreiter.de/blog/2010/05/13/utf-8-und-python/

[10:18] <moritz_> he doesn't say nice things about Perl 6 either :-)

[10:18] <Su-Shee> masak: he hoping for the same reasons that perl 6 will hopefully be a dead born child. ;)

[10:19] <Su-Shee> also, is a famous german blogger idiot. ;)

[10:19] <Su-Shee> he is.

[10:19] <masak> he's hoping for a stillborn, yes.

[10:19] <masak> sounds like something a person would say to stir up feelings.

[10:20] <masak> maybe to get angry comments or something.

[10:20] <moritz_> he has the opinion that since he has spent learning an overly complex system, it's a disadvantage to simplify it

[10:20] *** pencilk left
[10:20] <masak> that's basically the argument of some Perl 5 people, though :)

[10:20] <Su-Shee> he's the typical middle aged aging german engineer hoping for no change at all, ignore him. seriously.

[10:20] <masak> except that they add that the overly complex system really is simple if you look at it the right way. :P

[10:21] <masak> Su-Shee: consider it done.

[10:21] * moritz_ was about to write a highly sarcastic blog post and register it there as a trackback

[10:21] <moritz_> but it's probably not worth the effort

[10:22] <Su-Shee> moritz_: depends on how many new readers you want. ;)

[10:22] <masak> also, the Internet tends to treat sarcasm as damage and route around it.

[10:24] <masak> as chromatic wrote, positive blogging is worth so much more than defensive blogging.

[10:25] <Su-Shee> a well the first rule of ruling successfully is to learn to ignore the masses and only listen to the right people. (not necessarily your friends or your peers though)

[10:26] *** lestrrat is now known as lest_away

[10:26] <moritz_> well, don't ignore the masses, just ignore what they say :-)

[10:27] <Su-Shee> no. ignore the masses. you'll get success by attracting the right group of early adopters. the masses follow _them_ not you. 

[10:27] *** agentzh left
[10:27] * moritz_ never heard of early adaptors in the context of ruling

[10:28] <Su-Shee> moritz_: well you're a physicist and not a political scientist. ;)

[10:31] *** JimmyZ left
[10:32] <masak> rakudo: say try {}

[10:32] *** PZt left
[10:32] <p6eval> rakudo ed2409: OUTPUT«Null PMC access in type()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[10:32] * masak submits rakudobug

[10:33] <masak> meh, we already had that one :)

[10:35] <masak> do you know what I think is a source for hope? it's that most of the projects on the list on http://proto.perl6.org/ didn't exist a year ago. imagine where the Perl 6 ecosystem will be a year from now.

[10:37] <masak> hm, maybe the 'fresh' medal should link to the project's commit log...

[10:37] <moritz_> didn't we have a chart of number of proto projects over time?

[10:37] <moritz_> that would fit nicely onto that page too

[10:37] <moritz_> maybe at the bottom

[10:37] <masak> yes; I believe it's in Tim Bunce's talk.

[10:38] <masak> aye; slide 83 of http://www.slideshare.net/Tim.Bunce/perl-myths-200909

[10:41] <moritz_> http://moritz.faui2k3.org/tmp/proto-projects-list.png

[10:41] <moritz_> more up to date

[10:42] *** pmurias left
[10:42] *** pmurias joined
[10:44] <masak> seems we peaked in May :)

[10:45] * mathw waves

[10:45] * moritz_ particles

[10:45] * masak duals

[10:48] <moritz_> I've beautified it a bit

[10:49] <masak> out of 36 hand-picked bugs deserving (IMHO) to be fixed by the Rakudo Star release, 14 have been fixed so far. http://use.perl.org/~masak/journal/39597

[10:50] <masak> 'There are currently over 400 new/open bugs in RT.'

[10:50] * masak chuckles

[10:55] *** cxl_ joined
[10:59] *** cxl_ left
[11:11] *** pmurias left
[11:17] *** rv2733 left
[11:20] *** snarkyboojum left
[11:20] *** snarkyboojum joined
[11:22] *** masonkramer left
[11:22] *** masonkramer joined
[11:37] * colomon just finally unpacked his copy of the Dragon Book.  Also Sligo and Michigan tunebooks, Newfoundland songbooks, and my most heavily used math books.  Good box!

[11:37] <moritz_> and I thought colomon knew math already :-)

[11:38] <colomon> I know what books to look in, at any rate.  :)

[11:39] <k23z__> colomon, math books, which ?

[11:39] <k23z__> *which ones

[11:40] <colomon> In particular, Linear Algebra (Friedberg / Insel / Spence) and Vector Calculus (Marsden / Tromba).  Plus Numerical Recipes in C.

[11:40] <moritz_> http://www.amazon.de/Taschenbuch-Mathematik-Ilja-N-Bronstein/dp/3817120079/ref=sr_1_1?ie=UTF8&s=books&qid=1273750799&sr=8-1-catcorr # the bible

[11:42] <colomon> "Tashcenbuch"?

[11:42] <colomon> *ch

[11:43] <Su-Shee> *HAHA* the bronstein calling a taschenbuch is great :)

[11:43] <Su-Shee> colomon: poket book

[11:43] <Su-Shee> pocket

[11:44] <colomon> It's 1216 pages long, yes?!

[11:44] <colomon> If that's the table of contents there, it looks like it covers a *lot* of useful stuff.

[11:45] <k23z__> you must be an engineer if I'm not mistaken

[11:46] <colomon> k23z__: I'm not an engineer, but I write software used by engineers.  

[11:50] <jnthn> o/

[11:50] *** mberends joined
[11:50] <masak> jnthn! \o/

[11:51] <colomon> \o

[11:51] <jnthn> masak!

[11:51] <masak> jnthn: I've been constantly reminded, in the past few days, why it is that we elected to call the making of presentation slides 'procrastinating'. :)

[11:53] <jnthn> masak: Ты еше в России? :-)

[11:53] <masak> no, no, not yet :)

[11:53] * jnthn doesn't need to be envious yet then ;-)

[11:53] <masak> my plane is Sunday.

[11:53] <masak> s/is/leaves on/

[11:53] <jnthn> Oh...loads of time to procrastinate!

[11:53] <masak> well, um... :/

[11:54] <masak> I accidentally an Esperanto camp in between. :P

[11:54] <jnthn> Way to make your brain asplode. :-)

[11:55] <Juerd> Ĉu plena kampado? :P

[11:55] <mberends> \o nice to be online for a few minutes :-)

[11:55] <dalek> rakudo: 70795ca | (Martin Berends)++ | tools/test_summary.pl:

[11:55] <dalek> rakudo: add a second report example to tools/test_summary.pl

[11:55] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/70795ca86b46f91d21087742670229c1ed7ec912

[11:55] <masak> Juerd: ne vere. sed mi ne trovis pli bonan tradukon por 'renkontiĝo'.

[11:55] <Juerd> O hai mberends 

[11:55] <masak> mberends: hi!

[11:56] <jnthn> mberends: \o/

[11:56] <mberends> hai Juerd, sorry I forgot to tell you I had to miss Amsterdam.pm :-(

[11:56] <Juerd> masak: meeting. :)

[11:56] <masak> Juerd: 'meeting' sonas kiel maltro granda okazo, ĉar nia daŭros dum tagoj.

[11:56] <masak> Juerd: kaj enhavas 'meetings'.

[11:56] <Juerd> masak: Congress.

[11:56] <masak> tio sonas tro serioze :P

[11:57] <k23z__> masak, what language is that ?

[11:57] <k23z__> swedish or esperanto ?!

[11:57] <k23z__> or.. ?

[11:57] <masak> k23z__: it's Esperanto.

[11:57] <Juerd> Vi estas malkontentigebla :)

[11:57] <masak> 100 years older than Perl. :)

[11:58] <masak> Juerd: we're going to a renkontiĝo. :) that's it.

[11:58] <Juerd> Make that 200

[11:58] <masak> Juerd: please show me that math.

[11:58] *** am0c left
[11:58] <Juerd> Oh, I'm mistaken

[11:59] <Juerd> I thought Esperanto was 17xx but it's 18xx

[11:59] <Juerd> And I had no idea that it was indeed almost exactly 100 years older :)

[11:59] <masak> :)

[11:59] *** M_o_C joined
[11:59] <Juerd> I want to live through 2087 and see what language that year will bring.

[12:00] <jnthn> Perl 7?

[12:00] <Juerd> jnthn: Esperanto, Perl 6, Perl 7?

[12:00] <Juerd> s/6/5/

[12:00] <Juerd> Maybe a language that unifies speech and programming

[12:00] <Juerd> (No, not BASIC)

[12:00] <jnthn> COBOL?

[12:00] <jnthn> <ducks>

[12:00] <masak> there are uncanny parallels between Perl and Esperanto. both had benovelent dictators. both were 'open source' but centrally controlled in some sense. both 'contain the world' in the Mahler sense.

[12:01] <masak> I guess that would make Perl 6 Ido. :(

[12:01] <Juerd> No

[12:01] <masak> NO! :(

[12:01] <Juerd> Ido is not Esperanto

[12:01] <Juerd> Perl 6 is Perl

[12:02] <masak> also, Perl 6 wasn't developed mostly by the French.

[12:02] <Juerd> A someone less awkward analogy would be Esperanto : Ido :: Perl : Kurila

[12:02] <Juerd> s/one/what/

[12:02] *** orafu left
[12:02] <masak> but Ido does have a spec, and it does tend slightly more towards sanity and 'logic' than does Esperanto.

[12:03] <jnthn> masak: If it was, we'd have an easy explanation for why it's taking so long though. ;-)

[12:03] <jnthn> "La grèves!" ;-)

[12:03] <k23z__> Juerd, is Kurila like actively developed or something, I saw it on CPAN but is it actually used ?

[12:03] <masak> jnthn: it's not to late to blame it all on the French, I guess.

[12:03] <masak> cognominal: no offense.

[12:04] * jnthn menat it mostly light-heartedly...but hopes he never has the misfortune to visit France while a strike is taking place again.

[12:04] <jnthn> :-)

[12:04] *** orafu joined
[12:04] <masak> 'kurila began life as "Perl 7". The name caused so much controversy that it was changed to kurila.' http://www.perlfoundation.org/perl5/index.cgi?kurila

[12:04] <masak> who would've guessed? :P

[12:05] <masak> in other news, I've decided to rename Yapsi into Perl 8. 

[12:05] <masak> :P

[12:05] <k23z__> "kurila is an experimental, incompatible fork of Perl 5 by Gerard Goossen. Its intent is to allow experimentation with the internals without the burden of backwards compatibility. kurila radically rewrites and even removing some features."

[12:06] *** bluescreen joined
[12:06] * masak is happy there are people exploring those venues

[12:06] *** bluescreen is now known as Guest41966

[12:06] <masak> it explores the extent of TimToady's statement about something based on insanity still being insane.

[12:06] <Juerd> k23z__: It's being developed but has a user base of 1

[12:07] <mberends> gerard++'s talk at the Dutch Perl Workshop was very impressive

[12:07] <k23z__> Juerd, haha

[12:07] <masak> even Perl 6 has a larger user base than that... :)

[12:07] <Juerd> It became pythonic in syntax, at least in the sense that it now has semantic identation.

[12:07] <Juerd> s/ident/indent/

[12:07] * jnthn figures he should deal with some of his work pile

[12:07] <k23z__> masak, is there any estimate for p6's user base ?

[12:08] <k23z__> masak, the current one that is

[12:08] <Juerd> k23z__: Well, at least 2 :)

[12:08] <Su-Shee> now you're modest. it's at least 3. 

[12:08] <masak> k23z__: I don't know what such an estimate would measure. perhaps Rakudo downloads per month?

[12:08] <Juerd> \o/

[12:08] <masak> k23z__: or number of querents per day on the #perl6 channel?

[12:09] <masak> but neither of those are very accurate to begin with.

[12:09] <k23z__> masak, I think unique IP address downloads of Rakudo would be pretty accurate

[12:09] <jnthn> number of authors with module sin proto? :-)

[12:09] <jnthn> (under-estimate but a maybe interesting statistic)

[12:10] * Juerd wants to commit a module sin

[12:11] <masak> jnthn: that's not 'users', that's 'project authors'.

[12:12] *** am0c joined
[12:12] <masak> k23z__: there are some numbers here: http://github.com/rakudo/rakudo/downloads

[12:12] <masak> k23z__: but many of us here don't register there because we use the Git repo directly.

[12:14] <jnthn> masak: Yeah...it gives a lower bound though I guess.

[12:14] <jnthn> But certainly only tells part of the story.

[12:15] <masak> also, not all who download go on to become what I'd call 'users'.

[12:15] <masak> maybe they just like having a 'perl6' binary on their computer :)

[12:15] <masak> I know I do.

[12:17] *** hugme joined
[12:17] <moritz_> hugme: add Juerd to sin

[12:17] <hugme> moritz_: sorry, I don't know anything about project 'sin'

[12:17] <moritz_> bad luck :/

[12:17] <masak> nothing that can't be fixed.

[12:18] <jnthn> Just gotta find something it can be an acronym for. :-)

[12:19] *** JimmyZ joined
[12:20] <masak> something recursive, maybe. "Sin Isn't Nutritious"?

[12:22] <mberends> loliblogged: http://blogs.perl.org/users/martin_berends/2010/05/measuring-rakudo-performance.html

[12:23] <masak> mberends: interesting. mberends++

[12:24] <masak> mberends: those 'freezes' have been reported earlier by quietfanatic, when he did some performance-intensive graphics, or even just printing lines to $*OUT.

[12:24] <mberends> yeah, they're fairly random

[12:25] <masak> at that time (maybe 3/4 year ago), it created a sort of oscillating, wobbly feel to the execution.

[12:25] <jnthn> Said 'freezes' are probably when GC runs happen.

[12:25] <masak> aye.

[12:26] <jnthn> mberends++ # will read it in detail later

[12:26] *** fridim_ left
[12:27] <masak> mberends: suggestion: add a link in the last sentence to http://perlgeek.de/blog-en/perl-6/contribute-now-announce.html

[12:27] <mberends> sure, thanks :)

[12:27] <masak> moritz_: there's an unclosed <code> in http://perlgeek.de/blog-en/perl-6/contribute-now-fix-up-a-test.html

[12:27] *** ruoso joined
[12:31] <mberends> masak: link added

[12:31] <masak> \o/

[12:34] *** snarkyboojum left
[12:34] <mberends> \o (moving out of street-wifi range), working a bit on zavolaj/mysql too

[12:35] *** mberends left
[12:37] *** orafu left
[12:37] *** orafu joined
[12:37] <masak> yay! real DB support in Rakudo would be sweet.

[12:37] <masak> haven't seen much blogging about the progress of that.

[12:38] <jnthn> masak: The mysql example in the zavolaj repo works decently, afaik.

[12:38] <jnthn> It just needs for somebody to package up a module nicely.

[12:39] <jnthn> "just" :-)

[12:39] <masak> that sounds intensely promising.

[12:40] *** xinming left
[12:40] <masak> hah! the example involves a table called 'nom'! http://github.com/jnthn/zavolaj/blob/master/examples/mysqlclient.p6

[12:40] <masak> I wonder who wrote that... :P

[12:41] <jnthn> Yeah...mberends++ wrote it after we'd been for lunch. :-)

[12:42] <masak> huh! ok, he was my second guess. :)

[12:42] *** Guest37407 left
[12:42] <jnthn> I'm not to blame for ALL lolspeak in example code. :P

[12:43] <masak> true.

[12:43] <jnthn> .oO( I guess I can't wriggle out of the blame for all the Slovak proclaiming the virtues of beer in the spectests, though. )

[12:43] <masak> lol!

[12:44] <masak> that's a tweet in itself: "How many modules do you know whose spectests are full of Slovak proclaiming the virtues of beer?"

[12:46] <k23z__> when p6 grows will one be able to prove that the code he writes is correct, like those Haskell people do ?

[12:46] <masak> hm, only four hits for 'pivo' in the spectest suite.

[12:46] <masak> k23z__: funny you should mention that. my talk on Monday will partly be about that.

[12:46] <masak> k23z__: want a sneak peek?

[12:46] <k23z__> masak, sure thing

[12:47] * masak prepares a gist

[12:47] <jnthn> masak: Clearly I don't write enough tests. :-)

[12:47] <masak> k23z__: http://gist.github.com/399787

[12:47] <k23z__> I've been reading from Dijkstra's book "A Discipline of programming" but some stuff came up and I had to postpone it ..

[12:47] <k23z__> masak, reading .. :)

[12:47] <masak> k23z__: note the PRE blocks in the loops.

[12:49] <masak> there's no proof-of-concept for it yet, but given things like that, it should be possible for a piece of software to walk the AST of the program and prove that the sub actually sorts the elements.

[12:50] <masak> jnthn: "dnes je horuci a potrebujem pivo"

[12:50] <masak> was that during the summer? :)

[12:51] <masak> seems it was. July.

[12:51] <k23z__> masak: that is very nice

[12:51] <jnthn> Presumably. ;-)

[12:51] <k23z__> masak, does the compiler actually evaluate those PRE-conditions ?

[12:51] <k23z__> masak, how about post-conditions ?

[12:51] <masak> k23z__: no, right now there's no compiler that can handle those.

[12:51] <k23z__> masak, do you plan to implement POST conditions also in the language ?

[12:52] <k23z__> ah I understand

[12:52] <masak> k23z__: I'm hoping Yapsi will be the first to do so.

[12:52] <masak> k23z__: both PRE and POST are in the spec.

[12:52] <masak> S04.

[12:52] <masak> they can also be applied to other things than loops; methods, for example.

[12:53] <masak> if they're put directly in a class block, they count as being applied to all methods in that class.

[12:53] <masak> so it's a way to uphold invariants. and it has always been a place where I think static analysis could perform wondrous things.

[12:55] <k23z__> masak, I like this feature very much, I hope rakudo gets it also, it would be a big + :)

[12:55] *** xinming joined
[12:55] <k23z__> masak, are there other concepts from the realm of formal methods that you plan to include ?

[12:56] <masak> k23z__: perhaps there would be, if I had any formal education in this area. but I don't, I just find it exciting. :)

[12:57] <masak> it feels like a place where pragmatism and theory can meet a bit.

[12:57] *** araujo left
[12:57] *** araujo joined
[13:00] * mathw has been reading about Perlesque, and likes

[13:00] *** XaeroOne joined
[13:04] <masak> Perlesque is The Awesome, and it's intriguing to think that it might end up running STD.pm6 somehow.

[13:06] <mathw> yes

[13:06] <mathw> and that it could maybe also be implemented on the JVM

[13:10] <[Coke]> anyone able to build rakudo-latest with parrot-latest?

[13:11] <moritz_> [Coke]: worked for me a couple of hours ago

[13:11] <moritz_> trying again now

[13:12] <[Coke]> http://nopaste.snit.ch/20543 is my failure.

[13:12] <moritz_> huh.

[13:13] <moritz_> yes, I get the same

[13:13] <moritz_> did anybody touch nqp in parrot?

[13:15] <moritz_> it's definitively not a rakudo change causing that

[13:16] <dalek> rakudo: 7e0aa33 | moritz++ | build/Makefile.in:

[13:16] <dalek> rakudo: [build] missing pod2man should not be fatal

[13:16] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7e0aa3326bfb3c51bfbe91aec711a32394887f9e

[13:16] <moritz_> masak: thanks, markup fixed

[13:17] *** dju left
[13:17] <[Coke]> moritz_: npq, no. pct, I think so.

[13:17] <[Coke]> if time permits, I'll see if I can figure out which recent change did that.

[13:17] <moritz_> it's parrot-nqp that's being executed

[13:17] <moritz_> and I'm pretty sure it doesn't use PCT under the hood :-)

[13:19] *** dju joined
[13:27] <moritz_> erm

[13:27] <moritz_> I meant PGE

[13:27] <moritz_> PCT *is* used

[13:27] <moritz_> all those TLA are confusing me :(

[13:28] <masak> be glad they're not FLA, then :)

[13:30] <jnthn> FLA isn't a FLA.

[13:30] <mathw> nitpicker

[13:30] *** PZt joined
[13:31] <jnthn> namecaller

[13:31] <masak> 'for any given xLA, if xLA is a xLA, then x == 3' :)

[13:32] <moritz_> only if |x| == 1

[13:33] <moritz_> FoLA

[13:33] <masak> ooh!

[13:33] <masak> FivLA

[13:33] <moritz_> SixxLA

[13:33] <masak> lol

[13:34] <jnthn> SevenLA actually works.

[13:34] <jnthn> Well

[13:34] <jnthn> If you can make SEVEN into an acronym... :-)

[13:35] *** dju is now known as dju_

[13:35] *** dju_ is now known as dju__

[13:35] *** dju__ is now known as dju

[13:40] *** XaeroOne left
[13:40] *** BrowserUk joined
[13:40] <BrowserUk> ?

[13:41] *** BrowserUk left
[13:41] <masak> ¿

[13:45] *** plobsing joined
[13:48] *** M_o_C left
[13:52] <k23z__> masak, if you have time, read Dijkstra's book, he invented this stuff, I think formal methods are superior to test-driven development, but they require a lot of studying

[13:53] <masak> k23z__: thanks for the tip.

[13:54] <PerlJam> k23z__: sure, formal methods may be superior, but they have a much higher cost in terms of time.

[13:54] <k23z__> PerlJam, yeah but don't you feel very good when you know you wrote a piece of code that can't go wrong, like.. ever ?

[13:54] <PerlJam> (yes, this could be a various of wanting something "fast" or "correct"  :)

[13:54] *** lest_away is now known as lestrrat

[13:54] <PerlJam> s/various/variation/

[13:55] <PerlJam> k23z__: I'm happy with "good enough" rather than "perfect"  usually

[13:55] *** JordiGH joined
[13:56] <PerlJam> But, it depends on the application.   If I were writing some software that controlled a pace-maker or the trajectory of an airplane or something, "perfect" would tug on me a little more :)

[14:01] <masak> I wouldn't mind 'perfect' more often if it was cheap.

[14:01] <k23z__> PerlJam, now that you mention it, there's a book called "Why programs fail" and there is an example about a software bug that caused the death of a pilot and a passenger on a plane landing in Poland

[14:02] <k23z__> PerlJam, I'm sure there are many much more disastrous results of software bugs(probably in that book as well)

[14:02] <k23z__> I haven't read it all yet tough ...

[14:02] <k23z__> *though

[14:02] <JordiGH> I'm afraid I can't let you land this plane, John.

[14:02] <[Coke]> I think notfound fixed the build,t esting...

[14:03] <k23z__> JordiGH, hahaha

[14:03] <k23z__> like HAL 3000  , or what was the name ?

[14:03] <JordiGH> The machines, they're really out to kill.

[14:04] <[Coke]> HAL9000

[14:04] <[Coke]> (and his sister, SAL)

[14:04] <masak> there was something called a Therac-25, used in medicine. it contained a race condition and killed three patients with excess radiation. http://en.wikipedia.org/wiki/Therac-25

[14:05] <JordiGH> Ah, that's a famous example, masak. I remember having to read about that in my engineering ethics class in undergrad.

[14:06] <masak> there's also http://en.wikipedia.org/wiki/Ariane_5_Flight_501

[14:07] <PerlJam> software errors have destroyed expensive rocket systems for NASA;  they have caused massive power outages; and they have killed people.  Software is a dangerous thing

[14:07] <[Coke]> build fixed. tests added by NotFound++ to insure that regression doesn't occur again.

[14:07] <masak> hardware exception during casting from floating point to int.

[14:07] <PerlJam> (I'm also willing to bet that the Toyota sticking-gas-pedal problem is really a software error)

[14:07] <masak> [Coke]++

[14:07] * masak read that as 'test added to NotFound++'

[14:08] <JordiGH> described by patient Ray Cox as "an intense electric shock". It caused him to scream and run out of the treatment room

[14:08] <[Coke]> masak: notfound++ did all the work. I just say "hey, is this borked?"

[14:09] <masak> [Coke]++ # anyway

[14:09] <[Coke]> ... I wonder why, when I let myself type on autopilot, that my grammar goes to hell.

[14:09] <PerlJam> [Coke]: your reptilian brain isn't very grammatical.

[14:10] <[Coke]> PerlJam: ... If it can type, it can handle grammar. :P

[14:12] <PerlJam> typing is easy, that's just a technical skill (like stacking bricks atop each other); grammar requires thinking about what you're typing  (like stacking bricks in the form of a house instead of just a pile of bricks)

[14:12] <jnthn> Grammars overrate is

[14:12] *** mikehh left
[14:13] *** kensanata joined
[14:13] *** Helios left
[14:14] <masak> agree I not. grammar without, extract exceedingly sentence becomes structure from difficult.

[14:15] <PerlJam> masak: I think you mean "extracting"

[14:15] <PerlJam> ;)

[14:15] <masak> are you complaining about my lack of grammar? :)

[14:20] *** Helios joined
[14:22] *** JimmyZ left
[14:30] * PerlJam wonders if Perl 6 is an "emerging language" ... http://emerginglangs.com/

[14:31] *** bubaflub joined
[14:31] <tedv> It's clearly a language.  How do you define "emerging"?

[14:32] <masak> if it's coming out of something, like a nest or a burrow, it's emerging.

[14:34] <PerlJam> The thing is ... I don't see a Perl 6 person in this list http://radar.oreilly.com/2010/05/announcing-the-emerging-langua.html

[14:35] <PerlJam> And looking at the other languages ... Perl 6 should be there.

[14:35] <moritz_> we just need somebody to present it, no?

[14:37] <PerlJam> Someone who's going to OSCON.

[14:37] *** tedv left
[14:42] *** k23z__ left
[14:45] *** TiMBuS left
[14:50] *** mathw left
[14:51] *** mathw joined
[14:52] *** pmurias joined
[14:53] *** JordiGH left
[14:53] *** k23z__ joined
[15:01] *** plobsing left
[15:07] *** Khisanth left
[15:07] *** kensanata left
[15:07] *** lisppaste3 left
[15:08] *** PerlJam left
[15:09] *** PerlJam joined
[15:09] *** clintongormley left
[15:10] *** clintongormley joined
[15:10] *** alester joined
[15:11] <diakopter> PerlJam: TimToady said Perl [6 or otherwise] shouldn't be there since it already has its own oscon track

[15:12] <pmurias> diakopter: hi

[15:12] <diakopter> hi

[15:13] <pmurias> diakopter: how is the class implementation progressing?

[15:19] *** Su-Shee left
[15:21] <diakopter> pmurias: nothing in 3 days; $work

[15:22] *** Khisanth joined
[15:23] <diakopter> jnthn: when a class is declared inside another block, and that block runs again, are the class' methods' updated wrt their outer_lex pointers?

[15:24] *** mantovani left
[15:24] *** Lorn left
[15:24] <jnthn> diakopter: For anoymous classes certainly yes.

[15:25] <jnthn> I guess for others too

[15:25] <jnthn> Well

[15:25] * jnthn ponders

[15:25] * diakopter was pondering this yesterday

[15:25] <jnthn> I think the answer is yes, and I think Rakudo probably gets it right.

[15:25] <jnthn> roles are different though in that sense.

[15:26] <jnthn> A role body doesn't run until the role gets consumed in some way.

[15:26] <diakopter> oh

[15:26] <jnthn> Since they body may depend on parameters.

[15:26] <diakopter> what about a parametric class then

[15:26] <jnthn> Don't exist.

[15:26] <jnthn> Only roles are parametric in Perl 6.

[15:27] <diakopter> ohh

[15:27] <diakopter> hee

[15:27] <pmurias> diakopter: did you set svn:eol-style on files in the sprixel repo?

[15:28] <diakopter> no; feel free to set it however you like and standardize the eols

[15:29] <diakopter> when does the role declaration body run

[15:30] <jnthn> diakopter: When a role with a not-yet-seen set of parameters is needed

[15:30] <jnthn> Where needed means "composed" really

[15:31] <diakopter> ok

[15:31] <jnthn> Since puns are done out of composition.

[15:31] <diakopter> similar to when a .NET generic class is composed at runtime from a runtime-generatd type, I guess.

[15:31] <jnthn> So essentially you have a "cache" of captures to roles.

[15:31] *** iblechbot_ left
[15:31] <jnthn> A role in Perl 6 is actually always a role factory.

[15:31] <jnthn> That can potentially generate many roles.

[15:32] <diakopter> ok.

[15:33] <jnthn> rakudo: role Foo[::T] { say T }; class C1 does Foo[Int] { }; class C2 does Foo[Str] { }; class C3 does Foo[Int] { }

[15:33] <p6eval> rakudo 7e0aa3: OUTPUT«Could not find sub &say␤current instr.: '_block52' pc 437 (EVAL_1:177)␤»

[15:33] <jnthn> oh, grr

[15:33] * jnthn wonders if that bug goes away with pmichaud++s upcoming lexical/closure fixes.

[15:33] <jnthn> But anyway it'd print Int\nStr\n

[15:34] <jnthn> Not Int\nStr\nInt\n

[15:34] <jnthn> Since we already manufactured a role for Int

[15:34] <jnthn> e, for when we pass the parameter Int

[15:36] <PerlJam> diakopter: re emerging langs ... really?  that seems ... odd.  

[15:39] *** Lorn joined
[15:39] <PerlJam> Sure perl has it's own track, but the point of emerginglangs (as I understand it) is to communicate and focus on language design/implementation issues that may be shared across languages.   Not having Perl 6 in that camp leads to further isolation I think.  I mean, I'd rather have the C# or Clojure or whatever people talking about the cool things they picked up from Perl 6 than have Perl 6 be invisible.

[15:40] <pmurias> is C# an emerging language?

[15:41] <diakopter> PerlJam: besides, all 80 attendance slots for EmergingLangs are full

[15:41] <PerlJam> pmurias: they're on the list ... http://emerginglangs.com/speakers/

[15:41] <diakopter> so I couldn't attend :)

[15:42] <PerlJam> diakopter: you could if you were invited as a speaker  :)

[15:42] <diakopter> and only 80 attendance slots with 40 speakers ... seems... odd.

[15:42] <moritz_> elite conference?

[15:42] <diakopter> ok, 28 speakers.

[15:42] <PerlJam> I'm not sure what to make of that either.

[15:42] <PerlJam> the ratio is still off IMHO

[15:43] <PerlJam> but, yes, I guess it's an elite conf of language hackers.

[15:43] <PerlJam> (ergo someone from Perl 6 should be there!  ;)

[15:43] <diakopter> no it seems emerginglangs wanted a language-duke-it-out session during oscon, and it started to get a lot of attention on twitter, so oscon brought it under its umbrella and limited its attendance

[15:44] <diakopter> since after all, if those 80 people attend the TWO FULL DAYS (5 rounds of wrestling per day?) of emerginglangs, they would miss 2/3 of oscon

[15:45] <diakopter> I don't know.  seems more like a worship service to me

[15:46] *** XaeroOne joined
[15:46] <diakopter> more likely, the 80 attendees would attend only a small part of the 2 days each

[15:47] <diakopter> I mean, PyPy isn't a language

[15:47] <XaeroOne> doesn't perl6 have versions like perl5 ie. perl 5.12 etc?

[15:47] <moritz_> perl5.something is not a Perl 6 version

[15:48] <masak> XaeroOne: you mean like Perl 6.2, Perl 6.4, etc?

[15:48] <XaeroOne> yeah, no what I mean is are there version like perl 6.10 or soemthing? I cant find anything like that?

[15:48] <XaeroOne> right

[15:48] <diakopter> XaeroOne: do you mean Perl 5 mode when using the perl6 binaries?

[15:48] <diakopter> oh

[15:49] <PerlJam> XaeroOne: Yes, Perl 6.0.0 is yet to be released.

[15:49] <XaeroOne> :o

[15:49] <masak> XaeroOne: no, it doesn't yet. in that sense, we're still working up to 6.0.0.

[15:49] <masak> XaeroOne: ...which won't be a program like Perl 5, but a document. a specification.

[15:49] <XaeroOne> when is 6.0.0 going to be released?

[15:49] <moritz_> when it's done

[15:49] <masak> Christmas.

[15:49] <masak> but probably not Christmas 2010.

[15:49] <PerlJam> XaeroOne: in the mean time, there's Rakudo ...  http://rakudo.org/how-to-get-rakudo

[15:51] <diakopter> XaeroOne: there isn't a schedule for finalizing the specification.  see http://perl6.org/specification/

[15:51] *** rmrfslash joined
[15:52] <XaeroOne> i am just about learning perl5 and I read the perl5 to perl6 and differences between perl5 and perl6, now I don't like to learn perl5 anymore :s

[15:52] <masak> XaeroOne: why not?

[15:52] <masak> it's a quite powerful language.

[15:52] <masak> with lots of tools and modules.

[15:53] <masak> and a huge user base.

[15:53] <pmurias> diakopter: should i add [perlesque] to commit messages in perlesque

[15:53] <XaeroOne> yeah, i just fed up of people pointing out whats wrong with perl5

[15:53] <pmurias> XaoeroOne: and a mature implementation

[15:53] *** gpw left
[15:53] <XaeroOne> what is perlesque?

[15:53] *** gpw joined
[15:54] <masak> XaeroOne: people will always criticise Perl, especially those who don't use it and haven't tried to learn it.

[15:54] <XaeroOne> i like perl though, specially the special characters :)

[15:55] <masak> you mean the sigils? $@%&

[15:55] <diakopter> XaeroOne: perlesque is a p6/p5-ish language that tries to stick to the strongly-typed subset of Perl 6, so that it can run an automatically translated version of Larry Wall's standard parser for Perl 6

[15:56] <diakopter> on the CLR

[15:56] <XaeroOne> i like the ^/\>< also, i hate the __DATA__ thingy, it doesn't look nice at all

[15:56] <diakopter> (Mono on Linux/Mac/Windows or .NET on Windows/Silverlight)

[15:57] <XaeroOne> maybe it would make more sense to the python people :P

[15:58] <dalek> csmeta: r271 | pawelmurias++ | trunk/Sprixel (50 files):

[15:58] <dalek> csmeta: [perlesque] set eol-style:native

[15:58] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=271

[15:58] <XaeroOne> ok so if I write a basic perl6 program will it still run when perl 6.0.0 is finally released?

[15:58] *** am0c left
[15:59] <XaeroOne> coz if there are a lot of changes then it would be better to write it in perl5 and then re-write it later in p6?

[16:00] <moritz_> the effort of re-writing a Perl 6 program to a later version of the Perl 6 spec is larger than rewriting a p5 program to Perl 6

[16:00] *** rmrfslash left
[16:01] <PerlJam> moritz_: s/is/can be/

[16:01] <PerlJam> depends on the the specific features used and how complex the program is.

[16:01] <masak> XaeroOne: you're looking for some reassurances that things will stay the way they are now. most things probably will, but some things might change drastically. there's no way to tell.

[16:02] <diakopter> perlesque: my $sw = System::Diagnostics::Stopwatch.new(); $sw.Start(); loop (my $a=100000000;$a>0;$a-=1) { }; say($sw.Elapsed)

[16:02] <p6eval> perlesque: OUTPUT«00:00:00.3721830␤»

[16:02] <diakopter> perlesquel: .

[16:02] <p6eval> perlesquel: OUTPUT«00:00:00.3853940␤real 0.44␤user 0.44␤sys 0.00␤»

[16:02] <masak> XaeroOne: if you want stability now, Perl 5 is the version for you.

[16:02] <diakopter> meh

[16:02] <diakopter> masak++

[16:02] <PerlJam> XaeroOne: also note that many Perl 6 features have been ported to Perl 5 in one way or another.

[16:03] <masak> XaeroOne: those of us who like Perl 6 at the present date, almost by definition, have some way to cope with the lack of stability.

[16:03] <PerlJam> XaeroOne: Perl 6 OOP can be done with Moose in Perl 5.  Want everything to be an object?  "use autobox" in Perl 5.

[16:04] <PerlJam> XaeroOne: want given/when and smart matching?  Just make sure you have a newish version of Perl 5.  :)

[16:04] <XaeroOne> yeah, adding things like smart match and switch and stuff like that to perl5 is a good idea, over time it will make the transition to 6 easier

[16:04] <moritz_> though the smart matching in perl 5 isn't really comparable to that of Perl 6

[16:04] <masak> XaeroOne: the reaction you had -- reading about Perl 6, and then no longer wanting to learn Perl 5 -- is probably one that people can relate to in here. that said, the more I learn about Perl 5, the more I realize what a nice language it is.

[16:04] <moritz_> it just doesn't work well if you don't have user exposed types

[16:05] <XaeroOne> but more i read about perl6 the less it make me want to learn perl5 :(

[16:06] <PerlJam> XaeroOne: Perl 5 makes a really good base for learning Perl 6

[16:06] <XaeroOne> perl6 is so awesome, it has the best things of many things

[16:06] <masak> XaeroOne: except we're not done building it yet.

[16:06] <masak> XaeroOne: not wanting to scare you off here, just being honest.

[16:06] <masak> you can do some cool things already with Rakudo et al.

[16:06] <masak> but not everything.

[16:07] <XaeroOne> python has this 2to3 script that converts python 2.x scripts to 3.x scripts, any possibility that we could have one pl2p6 kinda thing?

[16:07] <masak> yes.

[16:07] <XaeroOne> cool

[16:07] <masak> current plan is TimToady writing a grammar for Perl 5.

[16:07] <masak> similar to how STD.pm6 is a grammar for Perl 6.

[16:08] <masak> then you could have some tool walk the parse tree and translate somehow.

[16:08] <masak> there's already some MAD hooks in the Perl 5 compiler to do something like that. but I believe it's bitrotted some.

[16:08] <pmurias> having more people work on the grammar for Perl 5 would be great

[16:10] <XaeroOne> ok so on sourceforge>parrot-win32 i need to get what to get p6 working: parrotwin32 setup, parrot-rakudo addon and the docs?

[16:10] *** molaf joined
[16:11] <pmurias> diakopter: how hard would it be to make perlesque clean up it's internal state after running a file

[16:11] <diakopter> pmurias: the two .exe it produces?

[16:11] <diakopter> easy

[16:12] <diakopter> oh, you mean in memory

[16:12] <pmurias> yes

[16:12] <diakopter> maybe an hour work; all the static things just need made instance things

[16:12] <pmurias> i experimented with making it run files sequentially from standard input but i spit out some strange errors

[16:12] <diakopter> heh

[16:13] *** XaeroOne left
[16:13] <diakopter> jnthn: did you see perlesque can use things from System.dll :)  like Stopwatch :)

[16:14] <jnthn> diakopter: Yes, noticed. :-)

[16:15] <diakopter> too bad perlesque doesn't have leaf-detection (for routines), so that the int in the example above can be a true int

[16:15] <diakopter> in that example, it's being loaded/stored as a field on a lexpad every time

[16:16] <diakopter> actually

[16:16] <diakopter> it could do it.

[16:17] <diakopter> since perlesque doesn't contain hash indexing (maybe it shouldn't?) as { }, it could just lookahead to make sure there's no { before the next }

[16:17] <diakopter> oh nm that's wrong :D :D

[16:17] <diakopter> commutalism&

[16:19] *** mantovani joined
[16:21] *** rv2733 joined
[16:28] <TimToady> MTTLA  :P

[16:28] <TimToady> LTATLA  :)

[16:29] *** kerframil joined
[16:31] <sorear> masak: I gave up on kurila when he removed 'tie' and operator overloading without compensation, because "such features confuse people" :/

[16:32] <masak> sorear: huh.

[16:34] <sorear> it's certainly interesting, but it violates "Perl will remain Perl"

[16:34] <sorear> can't call it Perl 6 if it doesn't give you rope. :)

[16:34] <masak> guess that's why he called it Perl 7 :P

[16:35] <masak> nom &

[16:35] *** masak left
[16:36] *** justatheory joined
[16:46] <[Coke]> huh. http://www.perl9.org/

[16:48] <jnthn> std: my @baz = @foo >>>>+<<<< @bar;

[16:48] <p6eval> std 30621: OUTPUT«===SORRY!===␤Variable @foo is not predeclared at /tmp/0JNBSI2XV9 line 1:␤------> my @baz = @foo⏏ >>>>+<<<< @bar;␤Missing << or >> at /tmp/0JNBSI2XV9 line 1:␤------> my @baz = @foo >>>>+<<<⏏< @bar;␤    expecting

[16:48] <p6eval> ..infix_circumfix…

[16:50] <TimToady> std: 1 >>[>>+<<]<< 2

[16:50] <p6eval> std 30621: OUTPUT«ok 00:01 110m␤»

[16:55] *** cdarroch joined
[16:55] *** cdarroch left
[16:55] *** cdarroch joined
[17:00] <TimToady> std: 1 >>>>[+]<<<< 2

[17:00] <p6eval> std 30621: OUTPUT«ok 00:01 112m␤»

[17:00] <TimToady> that also works

[17:01] <TimToady> problem is, +< is an operator

[17:01] *** pmurias_ joined
[17:01] *** pmurias_ left
[17:01] <TimToady> and >>op<< is rope :)

[17:03] *** dakkar left
[17:05] * TimToady wonders if we should add op like we added ...

[17:09] *** k23z__ left
[17:11] <TimToady> moritz_: technically, the <a> in $<a> is a subscript, and < isn't a twigil.  that does not mean we shouldn't force it to dwim though

[17:12] * TimToady has visions of :$<a><b><c> turning into 'a/b/c' => $<a><b><c>

[17:13] <TimToady> or of :$<a/b/c> looking up $/<a><b><c>

[17:14] <TimToady> bbl &

[17:15] * PerlJam has visions of xpath in perl 6 now

[17:17] * ruoso would strongly suggest a different subscript operator to that, since "/" is quite a regular character to be in a hash key...

[17:17] <phenny> ruoso: 01:09Z <BrowserUk> tell ruoso I've subscribed to p6.lang, but I've no idea how to reply to posts that happened before I subscribed? Can you post a "placeholder" reply to your 3rd revision, so I can reply to that when it arrives--Or would that bring down the ire of the list upon you? 

[17:18] <moritz_> it looks like a neat shortcut, but it breaks the symmetry between Match and Hash+Array

[17:22] *** SmokeMachine joined
[17:31] *** pmurias left
[17:36] *** eternaleye left
[17:37] *** patrickas joined
[17:43] *** jaldhar_ left
[17:52] *** ash___ left
[17:53] *** ShaneC joined
[17:54] *** ShaneC left
[18:00] *** iblechbot joined
[18:01] <diakopter> ruoso: did you get a chance to read that other paper Nigel Sandever and & I suggested?

[18:03] *** iblechbot left
[18:10] *** perlygatekeeper left
[18:19] *** rv2733 left
[18:29] *** stepnem left
[18:31] *** masak joined
[18:32] <masak> ahoy!

[18:34] *** SmokeMachine left
[18:34] <masak> [Coke]: that perl9 page is a bit of good-natured fun. the person obviously knows his Perl 6 in order to make the page in the first place.

[18:35] <jnthn> masak: ahoj! nemam pivo.

[18:35] <masak> jnthn: you'll just have to wait until they open again :P

[18:36] *** stepnem joined
[18:37] *** kel joined
[18:39] <[Coke]> masak: it's inspiring me to make a perlX graph.

[18:40] <masak> what's a PerlX graph?

[18:40] <masak> also, it's an interesting mix of sillyness, intentionally bad ideas, and things that Perl 6 already does with no extra syntax or semantics.

[18:41] <[Coke]> masak: I'll post the graph here when it's done.

[18:42] <masak> excellent.

[18:45] *** proller left
[18:55] *** envi^home left
[18:56] *** patrickas left
[19:01] *** dakkar joined
[19:14] *** eternaleye joined
[19:35] *** eternaleye left
[19:36] *** SmokeMachine joined
[19:44] *** \shade\ is now known as toshade

[19:44] *** toshade is now known as \shade\

[19:46] <[Coke]> masak: bah. google is lying to me. will make it difficult to trust my graph. :P

[19:46] *** \shade\ left
[19:46] *** \shade\ joined
[19:46] * masak gets an idea of what the graph is about :)

[19:46] <masak> in what way is Google lying to you?

[19:47] *** eternaleye joined
[19:50] *** \shade\ is now known as shade\

[19:52] *** SmokeMachine left
[19:52] <[Coke]> response in browser and programatically are not teh same.

[19:56] *** thraidh joined
[19:57] <thraidh> hi

[19:57] <thraidh> i was just trying to write my first perl6-program with rakudo

[19:58] <thraidh> and i got somewhat confused by the usage of rules throughout the platform

[19:58] <thraidh> is it true that rules are slightly different whether i'm using parrot, nqp or rakudo?

[19:58] *** eternaleye left
[19:59] *** shade\ is now known as {shade}

[19:59] <thraidh> especially when it comes to expression-matching with infix operators

[20:00] <[Coke]> note that rakudo and nqp are both implemented /on/ parrot (and parrot ain't perl6); and yes, rakudo implements a lot more of the spec.

[20:00] <thraidh> as i understand the docs, with parrot you can use: proto 'infix:+' or so

[20:01] <thraidh> nqp has somewhat more magic with <EXPR>

[20:01] <[Coke]> thraidh: you can't use that "with parrot", no.

[20:01] <thraidh> but with rakudo nothing seems to work...

[20:01] <thraidh> are the docs outdated then?

[20:02] <[Coke]> what docs are you reading?

[20:02] <thraidh> http://en.wikibooks.org/wiki/Parrot_Virtual_Machine/Optables_and_Expressions

[20:02] <thraidh> for example

[20:03] * [Coke] wonders who wrote that.

[20:03] *** lisppaste3 joined
[20:03] *** ash_ joined
[20:03] <thraidh> or this: http://www.parrotblog.org/2008/03/episode-7-operators-and-precedence.html

[20:04] <[Coke]> the blog entry is out of date, yes.

[20:05] <thraidh> then there is squaak

[20:05] <thraidh> which comes with parrot 2.3.0

[20:06] <[Coke]> I'm afraid the original page doesn't have a lot of context showing where those proto's are meant to be put. they're certainly not valid PIR - they might be intended for nqp-rx. (And there's a typo in them, so they're not going to work anyway.)

[20:06] <thraidh> which uses the techniques described 

[20:07] <[Coke]> I don't know if squak has been updated to use nqp-rx instead of the old style PGE.

[20:07] <diakopter> [Coke]: looks like whiteknight added the initial version of that pag

[20:07] <thraidh> i accepted that "is optable" and "proto 'infix:+'" are not really current anymore

[20:08] <[Coke]> thraidh:  - are you looking for "how to write perl6" or "how to write a language targeting parrot" ?

[20:08] <thraidh> but then there is abc from the parrot examples which uses nqp-rx

[20:08] <thraidh> actually i want to write some sort of interpreter in perl6

[20:08] <[Coke]> ok. then I would avoid anything specifically targeting parrot as that will likely just confuse the issue.

[20:09] <thraidh> yes

[20:09] <[Coke]> and just concentrate on rakudo and the SYN.

[20:09] <thraidh> i've recognized that by now

[20:10] <[Coke]> best Perl6 docs are probably off of http://perlcabal.org/syn/

[20:10] <thraidh> according to S05 there is no <EXPR>

[20:11] <TimToady> EXPR is just a method

[20:11] <masak> S05 doesn't say there is no EXPR :)

[20:11] <[Coke]> best sample code I can think of is something like http://github.com/partcl/partcl-nqp , but that's written primarily in nqp-rx, which is going to have a lot of callouts to parrot.

[20:11] <thraidh> is it unique to nqp?

[20:11] <TimToady> it's just that any method on Cursor or its derivatives can act like a rule

[20:11] <masak> no, it's a rule in the Perl 6 grammar.

[20:11] <thraidh> or can i use EXPR with rakudo?

[20:11] <masak> it's the root of the operator parser rules.

[20:12] <thraidh> i failed so far to do this

[20:12] <TimToady> it's a bottom-up parser pretending to be a normal rule

[20:12] <thraidh> i figured that much...

[20:12] <TimToady> but if you want one in your own grammar, you have to write/steal one

[20:12] *** meppl left
[20:12] <TimToady> or derive from a language that has one

[20:12] *** iblechbot joined
[20:13] <thraidh> how can i steal the one from nqp?

[20:13] <TimToady> I don't know if nqp has one or not

[20:13] <masak> thraidh: this piece of code might interest you: http://github.com/masak/gge/blob/master/examples/algebra

[20:13] <masak> thraidh: note how it uses &Perl6::Grammar::number on line 28.

[20:14] <masak> you probably want something like that.

[20:14] <TimToady> that is rather non-spec though

[20:15] <masak> it worked when I wrote it :(

[20:15] <TimToady> the name of the Perl 6 grammar is unlikely to be Perl6::Grammar, is what I mean

[20:16] <masak> ah, right.

[20:16] <diakopter> They call me Jane ... that's not my name.

[20:16] <masak> well, at least Rakudo alpha had it that way, so I used it.

[20:17] <thraidh> what i'm actually trying to do is writing some code which can  understand latex-equations and produce the corresponding error-equation

[20:17] <TimToady> but also there's no such thing as an optable in standard Perl 6 grammars

[20:17] <masak> thraidh: sounds cool.

[20:17] <masak> thraidh: are you using tests? I would.

[20:18] <thraidh> masak: tests for what? my own code? or other peoples tests to understand how perl6 works?

[20:18] <diakopter> heh

[20:18] <masak> thraidh: both are a good idea, but I meant the former.

[20:19] <masak> thraidh: the spectests might actually be helpful in understanding how rules and regexes work.

[20:19] <thraidh> masak: right now i'm still struggling with building a latex-equation parser

[20:20] <masak> right, but see, that's what I'm talking about :)

[20:20] <thraidh> masak: i'm not getting it to compile (since i tried to use the nqp-EXPR)

[20:20] <masak> in order to struggle less, it's useful to write it in very tiny increments.

[20:20] <masak> that's how I end up writing grammars, anyway.

[20:21] <masak> usually if I take too large a leap, I'm punished by ending up with something that doesn't parse anything.

[20:21] <thraidh> right... but that's step two, isn't it?

[20:21] <masak> no, I don't think it is.

[20:22] <thraidh> tests are good, as soon as you begin to get any results, whether correct or not

[20:22] <masak> starting with almost nothing, building up more and more of what you want in the grammar... should be step one.

[20:22] <masak> and tests are just a nice way during that step to make sure you don't regress.

[20:22] <thraidh> yes

[20:22] <thraidh> i agree

[20:22] <masak> it all comes down to running something like the tests either manually or automatically.

[20:22] <masak> and then you might as well do it automatically. :)

[20:23] <masak> besides, you'll get a medal.

[20:23] <diakopter> does latex have some other formal grammar?

[20:23] <thraidh> not really

[20:23] <diakopter> oh; it's dynamic

[20:24] <thraidh> only tex can parse tex (or latex)

[20:24] <diakopter> like, symbols can have their meaning changed, new commands added; neat!

[20:24] <thraidh> but i do not really need to understand all of latex

[20:24] <thraidh> just very simple things

[20:24] <masak> diakopter: sounds familiar... :)

[20:25] <diakopter> thraidh: http://pauillac.inria.fr/~maranget/hevea/

[20:27] <masak> thraidh: anyway; welcome to #perl6! hope you'll enjoy it here. you seem to have gotten off to a running start. :)

[20:28] <thraidh> thank you

[20:29] <thraidh> by the way: my native language is not english, so i may misunderstand things or produce awkward sentences... i apologize for that

[20:29] <masak> seems to work fine so far. what is your native language?

[20:30] <thraidh> diakopter: that site seems to be something with a different quality

[20:30] <thraidh> masak: i'm from germany

[20:30] <masak> cool. moritz_ is from there too.

[20:30] <masak> and Su-Shee. and probably others.

[20:31] <thraidh> germany isn't that small ;)

[20:31] <masak> so I've heard. :)

[20:32] <thraidh> anyway, back to my original question

[20:32] <thraidh> it seems that i either need to implement all the precedence-stuff manually

[20:32] <thraidh> or steal nqp's <EXPR>

[20:32] <thraidh> (but i have no clue how)

[20:33] <masak> thraidh: I have an operator precedence parser that you can borrow if you want.

[20:33] <thraidh> or you your parser

[20:33] <masak> http://github.com/masak/gge/blob/master/lib/GGE/OPTable.pm

[20:34] <[Coke]> masak: but... isn't this something he can just do in p6? certainly I didn't write my open operator parser for partcl.

[20:34] <masak> it's a port of PGE's optable parser. PGE used to be what parsed the Rakudo source and regexes.

[20:34] <[Coke]> s/open/own/

[20:34] <masak> [Coke]: well, you *can* do this with grammars, too.

[20:34] <masak> [Coke]: but I maintain that sometimes doing it with an OPTable parser is shorter and more economical.

[20:35] <masak> I haven't had much traction for that idea. there's no optable parser exposed by the spec, as TimToady pointed out.

[20:35] <thraidh> but then you would need to do something like: rule add_expr { <mul_expr> '+' <mul_expr> } rule mul_expr { <term> '*' <term> } ...

[20:36] <masak> oh, and optable parsers can sometimes be faster, too. they're usually preferable in expression-like situations.

[20:36] <masak> thraidh: yes, exactly.

[20:36] <masak> it's a bit verbose, since the only things you care about are the '+' and the '*'.

[20:36] <thraidh> i wanted to avoid that...

[20:37] <[Coke]> ooh, perl6 segfault (just try to run http://github.com/partcl/partcl-nqp/blob/master/src/Partcl/Grammar.pm with it.)

[20:37] <masak> thraidh: you can take a look at http://github.com/masak/gge/blob/master/t/03-optable.t to see what it can do. all those tests but one pass.

[20:38] <[Coke]> (rakudo, sorry)

[20:41] *** sahadev1 joined
[20:42] * [Coke] opens http://trac.parrot.org/parrot/ticket/1634 to track that.

[20:43] <thraidh> hmm... it seems my project might be more difficult than i anticipated

[20:44] <masak> if that's due to any shortcoming with Perl 6, please feel free to suggest improvements.

[20:44] <ash_> [Coke]: a real segfault? I haven't gotten a segfault in parrot in a long long time... 

[20:44] <[Coke]> ash_: I got 2 today.

[20:45] <[Coke]> but it's been a while. =-)

[20:45] <thraidh> i'd like nqp's <EXPR> in rakudo ;)

[20:45] *** kel_ joined
[20:45] <[Coke]> ash_: feel free to see if you can duplicate TT #1634. (or reduce the size of the .pm needed to generate it.)

[20:46] <thraidh> maybe as a package, since it does probably not belong into the core

[20:47] <masak> thraidh: use EXPR:from<nqp>; # something like that, then

[20:47] <thraidh> masak: will that work? or is that proposed syntax?

[20:48] <masak> thraidh: it will work eventually. Perl 6 is meant to have that syntax, yes.

[20:48] *** kel left
[20:48] *** dju left
[20:48] *** dju joined
[20:49] <thraidh> masak: until then i'll try to integrate your optable

[20:49] <masak> thraidh: let me know how it goes. you'll need the alpha branch of Rakudo, by the way.

[20:49] * masak goes to bed; early morning at the Russian consulate tomorrow

[20:50] *** masak left
[20:50] <thraidh> argh...

[20:50] <thraidh> nothing is ever easy...

[20:52] *** pmurias joined
[20:57] *** dju left
[20:57] *** dju joined
[20:58] *** dju left
[20:59] *** dju joined
[21:05] <[Coke]> perl6: grammar a;

[21:05] <p6eval> elf 30621, pugs, rakudo 7e0aa3:  ( no output )

[21:06] <[Coke]> rakudo: grammar a; say "ok";

[21:06] <p6eval> rakudo 7e0aa3: OUTPUT«ok␤»

[21:06] <[Coke]> wtf.

[21:06] <[Coke]> for me, that's segfaulting rakudo.

[21:06] *** kel_ left
[21:08] *** bubaflub left
[21:08] <thraidh> echo 'grammar a; say "ok";' | rakudo/rakudo/perl6

[21:08] <thraidh> [Coke]: works fine for me

[21:09] <[Coke]> guessing that it's the parrot version that's the issue.

[21:10] <thraidh> 2.3.0-devel here

[21:16] <thraidh> is it forbidden to use comments in grammars?

[21:16] *** molaf left
[21:16] <thraidh> (i know it's not...)

[21:16] *** pmurias left
[21:17] <thraidh> i got a segfault when i commented on rule... it's not reproducible...

[21:26] *** gbacon left
[21:27] *** wknight8111 joined
[21:29] <thraidh> how can i print all methods/properties of an object?

[21:29] <jnthn> $obj.^methods

[21:30] <jnthn> Gives you a list of all the methods

[21:30] <jnthn> Or if you want just the ones in the most derived class, $obj.^methods(:local)

[21:30] *** hercynium left
[21:30] <jnthn> rakudo: class Foo { method a { }; method b { }; }; for Foo.^methods { .name.say }

[21:30] <p6eval> rakudo 7e0aa3: OUTPUT«a␤b␤first␤minmax␤does␤grep␤join␤values␤can␤Numeric␤elems␤end␤reduce␤Str␤keys␤reverse␤uniq␤isa␤map␤classify␤pairs␤kv␤ACCEPTS␤min␤max␤pick␤BUILDALL␤new␤Bool␤say␤print␤defined␤WALK␤item␤BUILD␤REJECTS␤clone␤WHICH␤perl␤CREATE␤Capture␤PARROT␤bless␤WHENCE␤WHERE␤list␤␤notdef␤»

[21:30] <jnthn> rakudo: class Foo { method a { }; method b { }; }; for Foo.^methods(:local) { .name.say }

[21:30] *** hercynium joined
[21:30] <p6eval> rakudo 7e0aa3: OUTPUT«a␤b␤»

[21:31] *** Guest41966 left
[21:31] <thraidh> jnthn: thanks

[21:33] <thraidh> rakudo: "hi" ~~ /hi/; $/

[21:33] <p6eval> rakudo 7e0aa3:  ( no output )

[21:33] *** dakkar left
[21:33] <thraidh> rakudo: "hi" ~~ /hi/; $/.WHAT

[21:33] <p6eval> rakudo 7e0aa3:  ( no output )

[21:33] <thraidh> rakudo: "hi" ~~ /hi/; say $/.WHAT

[21:33] <p6eval> rakudo 7e0aa3: OUTPUT«Regex::Match()␤»

[21:34] <thraidh> rakudo: "hi" ~~ /hi/; say $/.^methods

[21:34] <p6eval> rakudo 7e0aa3: OUTPUT«Method 'methods' not found for invocant of class 'P6metaclass'␤current instr.: '!dispatch_.^' pc 408 (src/glue/dispatch.pir:99)␤»

[21:34] <thraidh> hrmpf

[21:37] <moritz_> oh hai

[21:38] <moritz_> thraidh: in Rakudo, $/ is not yet a Perl 6 object, so many things (includiing introspection) don't work on it

[21:38] <thraidh> oh

[21:38] <thraidh> moritz_: thanks

[21:39] <moritz_> rakudo: 'a' ~~ /a/; say $/.WHAT

[21:39] <p6eval> rakudo 7e0aa3: OUTPUT«Regex::Match()␤»

[21:39] <moritz_> should just be Match

[21:39] <moritz_> rakudo: 'a' ~~ /a/; say $/ ~~ Any

[21:39] <p6eval> rakudo 7e0aa3: OUTPUT«1␤»

[21:40] *** gbacon joined
[21:41] <thraidh> moritz_: i can access named rules with $<name> or $/<name> (i heard)

[21:41] *** ash_ left
[21:41] <moritz_> yes, that works in Rakudo

[21:41] <thraidh> moritz_: can i get a list of available names?

[21:41] <moritz_> rakudo: 'a' ~~ /a/; say $/.keys

[21:41] <p6eval> rakudo 7e0aa3: OUTPUT«Method 'keys' not found for invocant of class 'Regex;Match'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:41] <moritz_> that's one of the limitations

[21:42] <moritz_> alpha: 'ab' ~~ /<alpha>(.)/; say $/.caps.join(', ')

[21:42] <p6eval> alpha 30e0ed: OUTPUT«alpha       a, 0    b␤»

[21:42] <thraidh> so i cannot traverse the match tree?

[21:42] <moritz_> only if you know the structre of the rule :(

[21:42] <moritz_> at least currently

[21:43] <moritz_> I'm working on fixing that, but it's quite a challenge

[21:43] <thraidh> i won't ask why

[21:43] <moritz_> the answer is actually quite easy

[21:43] <moritz_> because the grammar engine is not specific to Perl 6

[21:44] <thraidh> it seems simple, but since i read hll-s0.pir i respect you very much and trust you

[21:44] <moritz_> that's generated code :-)

[21:44] <thraidh> oh

[21:44] <thraidh> i wondered how a living being could write such code...

[21:45] <moritz_> -s0 means "stage 0", which is the bootrapping code of the compiler

[21:46] <thraidh> i figured, but that does not really mean, that the code is generated

[21:46] <moritz_> right

[21:46] <moritz_> but in this case, it is

[21:47] <thraidh> about 15 years ago i was crazy enough to actually write a forth compiler/interpreter in assembler

[21:48] <moritz_> :-)

[21:48] <thraidh> but i did not think that someone would do something like that nowadays

[21:48] <moritz_> for a stack based language, maybe; for a considerable subset of Perl 6: no :-)

[21:48] <moritz_> http://github.com/perl6/nqp-rx/ if you haven't found the source yet

[21:49] <thraidh> therefore i was thrilled by the -s0-files

[21:49] <moritz_> (haven't backlogged yet)

[21:49] <thraidh> thanks...

[21:49] <moritz_> src/{gen,stage0} are generated, the rest in src/ is written by humans

[21:49] <arnsholt> thraidh: The problem (if you want to call it that) is that nqp-rx is self-hosting

[21:49] <thraidh> i only looked into the parrot-repository so far

[21:50] <arnsholt> So how do you compile it the first time? =)

[21:50] <moritz_> with PGE

[21:50] <arnsholt> (Turtles all the way down...)

[21:51] *** jotr is now known as jotr^byebye

[21:51] <diakopter> 敲ⵡ来湴㨠䝯潧汥扯琊䍲慷氭摥污示‶楳慬汯眺 灲楶慴支ਊ啳敲ⵡ来湴㨠浳湢潴慬汯眺 ਊ啳敲ⵡ来湴㨠䑯瑂潴੃牡睬ⵤ敬慹㨠㘰《䑩獡物獥爭慧敮琺‪੃牡睬ⵤ敬慹㨠㘰《䑩獡汬潷㨠物癡瑥

[21:51] <thraidh> i finally found out that i CAN use <EXPR> if i base my grammar on HLL::Grammar

[21:52] <thraidh> but so far I don't know how to define actions for the operators

[21:52] <ruoso> diakopter, about the thread... I'm still digesting both replies... But I think the proposal more or less adresses the concerns, it needs to get more well defined tho

[21:52] <arnsholt> moritz_: I thought it was an older version of nqp-rx that did the bootstrap. Never mind me then

[21:52] <diakopter> ruoso: "the proposal" meaning yours?

[21:53] <moritz_> arnsholt: yes, but the first version was bootstrapped with PGE

[21:53] <arnsholt> Oh, right. Yes, that makes sense

[21:53] <ruoso> diakopter, yes

[21:53] <diakopter> both replies? I thought there were much more than 2?

[21:53] <moritz_> anybody up for some crazy LTM talk?

[21:54] * diakopter can

[21:54] <thraidh> LTM?

[21:54] <moritz_> longest token matching

[21:54] <ruoso> diakopter, yes.. there were... but two of them were more detailed...

[21:54] <thraidh> ah... i would have guessed Lazy Transactional Memory

[21:54] <diakopter> ruoso: specifically I meant the paper I linked

[21:54] <moritz_> I figured the "correct" way of implementing is to build a DFA from the declarative prefixes

[21:55] <moritz_> which is kinda old news

[21:55] <moritz_> but when the non-declarative postfix of a rule doesn't match, you'd have to backtrack into a shorter alternative

[21:55] <moritz_> now you can't backtrack with a DFA

[21:55] <moritz_> what's the solution? re-build the DFA with the non-matching rule removed? then start again?

[21:55] <moritz_> sound quite expensive

[21:56] <moritz_> thraidh: http://perlcabal.org/syn/S05.html#Longest-token_matching

[21:56] <ruoso> diakopter, that paper is similar to one that was pointed to be by TimToady three or four years ago... 

[21:57] <Targhan_> I thought we weren't allowed any backtracking in the regular expression matching

[21:57] <diakopter> ruoso: ok. one of the "longer" replies mentioned that paper too, saying it was most appropriate

[21:57] <moritz_> Targhan_: oh sure we are, in general

[21:57] <ruoso> but one thing I have in my mind is the idea that threading and event-based-programming would be better if implicit in Perl 6, via feeds, lazy lists and so on

[21:58] <diakopter> ruoso: did you read it? the title is similar, but I didn't think the content was similar

[21:58] <ruoso> didn't fully read it, but skimmed through 

[21:59] *** hugme left
[21:59] <ruoso> diakopter, but I'm still digesting all the replies, and will still take a more careful read on all the quoted papers

[22:00] <ruoso> what I mean is that I share the concerns raised, and to the extent I can see, the model address those

[22:00] <diakopter> ruoso: the long message this morning said he was preparing a detailed proposal

[22:00] *** PerlJam left
[22:00] <ruoso> yes, I'm waiting for that one too..

[22:00] <diakopter> afk&

[22:00] * ruoso decommute &

[22:01] *** dalek left
[22:01] *** Juerd left
[22:01] *** Juerd joined
[22:01] *** pmichaud left
[22:02] *** pugssvn left
[22:02] *** pmichaud joined
[22:02] *** pugssvn joined
[22:04] <thraidh> as far as i understand, LTM only considers (more or less) fixed text, correct?

[22:04] <moritz_> nope; it considers traditional regular expressions

[22:05] <thraidh> but it "breaks" as soon as <ws> is found

[22:05] <moritz_> yes, because the default <ws> contains backtracking control

[22:05] *** PerlJam joined
[22:06] <moritz_> which isn't part of REG

[22:06] <moritz_> anyway, bed time; see you soon

[22:07] <thraidh> gute nacht

[22:07] *** ruoso left
[22:09] <thraidh> traditional REG is anything you can do with a DFA?

[22:09] *** hercynium left
[22:09] *** hercynium joined
[22:11] *** iblechbot left
[22:14] *** estrabd left
[22:39] *** Limbic_Region joined
[22:39] <thraidh> rakudo: say [+] (1,2,3)

[22:39] <p6eval> rakudo 7e0aa3: OUTPUT«6␤»

[22:39] <thraidh> rakudo: say [+] [1,2,3]

[22:39] <p6eval> rakudo 7e0aa3: OUTPUT«6␤»

[22:39] <thraidh> rakudo: my @x=[1,2,3]; say [+] @x

[22:39] <p6eval> rakudo 7e0aa3: OUTPUT«1 2 3␤»

[22:40] <thraidh> rakudo: my @x=(1,2,3); say [+] @x

[22:40] <p6eval> rakudo 7e0aa3: OUTPUT«6␤»

[22:40] <thraidh> rakudo: my @x=[1,2,3]; say [+] @@x

[22:40] <p6eval> rakudo 7e0aa3: OUTPUT«Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[22:40] <sjohnson> perl6!!

[22:40] *** clintongormley left
[22:41] <thraidh> perl6: my @x=[1,2,3]; say [+] @@x

[22:41] <p6eval> rakudo 7e0aa3: OUTPUT«Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[22:41] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected end of input␤    expecting "::"␤    Variable "@@x" requires predeclaration or explicit package name␤    at /tmp/pZlyAgb7Gt line 1, column 27␤»

[22:41] <p6eval> ..elf 30621: OUTPUT«/home/p6eval/pugs/misc/STD_red/match.rb:117:in `block in to_dump0': undefined method `to_dump0' for nil:NilClass (NoMethodError)␤      from /home/p6eval/pugs/misc/STD_red/match.rb:117:in `map'␤        from /home/p6eval/pugs/misc/STD_red/match.rb:117:in `to_dump0'␤   from

[22:41] <p6eval> ../home/p6eval/pugs/misc/S…

[22:41] <thraidh> perl6: my @x=[1,2,3]; say [+] @x

[22:41] <p6eval> pugs, rakudo 7e0aa3: OUTPUT«1 2 3␤»

[22:41] <p6eval> ..elf 30621: OUTPUT«/home/p6eval/pugs/misc/STD_red/match.rb:117:in `block in to_dump0': undefined method `to_dump0' for nil:NilClass (NoMethodError)␤      from /home/p6eval/pugs/misc/STD_red/match.rb:117:in `map'␤        from /home/p6eval/pugs/misc/STD_red/match.rb:117:in `to_dump0'␤   from

[22:41] <p6eval> ../home/p6eval/pugs/misc/S…

[22:43] <thraidh> perl6: my @x=(1,2,3); my $n=[+] @x; say $n;

[22:43] <p6eval> pugs, rakudo 7e0aa3: OUTPUT«6␤»

[22:43] <p6eval> ..elf 30621: OUTPUT«/home/p6eval/pugs/misc/STD_red/match.rb:117:in `block in to_dump0': undefined method `to_dump0' for nil:NilClass (NoMethodError)␤      from /home/p6eval/pugs/misc/STD_red/match.rb:117:in `map'␤        from /home/p6eval/pugs/misc/STD_red/match.rb:117:in `to_dump0'␤   from

[22:43] <p6eval> ../home/p6eval/pugs/misc/S…

[22:50] *** eternaleye joined
[22:58] *** Psyche^ joined
[22:58] *** eternaleye left
[23:00] *** skangas left
[23:02] *** Patterner left
[23:02] *** Psyche^ is now known as Patterner

[23:10] *** _buno_ joined
[23:11] *** _buno_ left
[23:11] *** snarkyboojum joined
[23:11] *** kensanata joined
[23:12] *** eternaleye joined
[23:14] <thraidh> perl6: "a" ~~ /a { make "b" }/; say $();

[23:14] <p6eval> pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.14/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[23:14] <p6eval> ..elf 30621: OUTPUT«Undefined subroutine &GLOBAL::circumfix__36_32_41 called at (eval 125) line 4.␤ at ./elf_h line 5881␤»

[23:14] <p6eval> ..rakudo 7e0aa3: OUTPUT«␤»

[23:18] *** kensanata left
[23:22] *** masonkramer left
[23:22] *** masonkramer joined
[23:23] *** masonkramer left
[23:24] <lue> I find it amazing that the guys of Diaspora* love Ruby because the creator allows you to do something in more than one way, that his way isn't the only way.

[23:25] <lue> Seem familiar?...

[23:25] <lue> [and hi]

[23:25] <Tene> hi lue

[23:27] <lue> .oO(the new wikipedia logo is nice)

[23:28] <thraidh> hi lue

[23:28] <thraidh> does anyone know why <<"a" ~~ /a { make "b" }/; say $();>> does not return "b"?

[23:30] *** cdarroch left
[23:31] <jnthn> thraidh: I think that's syntax from a while back that changed

[23:31] <jnthn> say $/.ast is the new way.

[23:31] <thraidh> perl6: "a" ~~ /a { make "b" }/; say $/.ast

[23:31] <p6eval> elf 30621: OUTPUT«Global symbol "$_47" requires explicit package name at (eval 125) line 4.␤ at ./elf_h line 5881␤»

[23:31] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.14/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[23:31] <p6eval> ..rakudo 7e0aa3: OUTPUT«␤»

[23:32] *** rgrau left
[23:33] <thraidh> hmm... that should have worked, shouldn't it?

[23:34] <jnthn> I think so.

[23:34] <jnthn> rakudo: "a" ~~ /a { make "b" }/; say $/

[23:34] <p6eval> rakudo 7e0aa3: OUTPUT«a␤»

[23:35] <Tene> rakudo: "a" ~~ /a { make "b" }/; say $/.perl

[23:35] <p6eval> rakudo 7e0aa3: OUTPUT«Method 'perl' not found for invocant of class 'Regex;Match'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:35] <jnthn> Yeah, certainly shoulda.

[23:35] <jnthn> nqp: my $m = "a" ~~ /a { make "b" }/; say($m.ast);

[23:35] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " \"a\" ~~ /a"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[23:35] <jnthn> nqp: my $m := "a" ~~ /a { make "b" }/; say($m.ast);

[23:35] <p6eval> nqp: OUTPUT«␤»

[23:36] <jnthn> nqp: my $m := "a" ~~ /a { make "b" }/; say($m);

[23:36] <p6eval> nqp: OUTPUT«a␤»

[23:36] <jnthn> ah...

[23:36] <jnthn> Not Rakudo specific though.

[23:36] <jnthn> Seems to be in the regex engine.

[23:37] <thraidh> rakudo: grammar g { rule TOP { a } } class a { method TOP($/) { make "b" } } say g.parse("a").ast

[23:37] <p6eval> rakudo 7e0aa3: OUTPUT«Confused at line 11, near "grammar g "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[23:38] <thraidh> rakudo: grammar g { rule TOP { a }; }; class a { method TOP($/) { make "b" }; }; say g.parse("a").ast

[23:38] <p6eval> rakudo 7e0aa3: OUTPUT«␤»

[23:38] <thraidh> rakudo: grammar g { rule TOP { a }; }; class a { method TOP($/) { make "b" }; }; say g.parse("a", :actions(a)).ast

[23:38] <p6eval> rakudo 7e0aa3: OUTPUT«b␤»

[23:38] <thraidh> THAT works

[23:39] <thraidh> rakudo: grammar g { rule TOP { a { make "c" } }; }; class a { method TOP($/) { make "b" }; }; say g.parse("a").ast

[23:39] <p6eval> rakudo 7e0aa3: OUTPUT«␤»

[23:39] <thraidh> that should work, too (i think)

[23:48] <thraidh> i'll go to bed now... good night

[23:49] <lue> good night

[23:53] *** thraidh left
[23:58] <lue> afk

