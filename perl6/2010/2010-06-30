[00:00] <tylercurtis> It looks like just about everything has its own .perl method defined, ingy. http://paste.scsys.co.uk/45333

[00:01] <tylercurtis> Which probably does not make what you want to do easy.

[00:04] <cuppe> hm. should first always work like grep, just returning the first match? working with block syntax?

[00:04] <ingy> tylercurtis: nod. I guess I could monkey patch *

[00:04] <[Coke]> ah, I assumed it was actually a method on cool. Presumably you could put a .json at the top level object, invoke .perl, get the result, and have a common way to dump the results)

[00:04] <[Coke]> s/object/class/

[00:04] *** lest_away is now known as lestrrat

[00:04] <[Coke]> but who knows, might be easier to add .json everywhere.

[00:05] <[Coke]> is there a channel for pod-people?

[00:06] <cuppe> rakudo: say first {/B/ and !/F/}, "BED"

[00:06] <p6eval> rakudo 451b40: OUTPUT«Method 'match' not found for invocant of class ''␤  in 'Regex::Bool' at line 5042:CORE.setting␤  in 'prefix:<!>' at line 351:CORE.setting␤  in <anon> at line 11:/tmp/EtuAYSA0BC␤  in 'Block::ACCEPTS' at line 4985:CORE.setting␤  in 'infix:<~~>' at line 322:CORE.setting␤  in

[00:06] <p6eval> ..'Any::fir…

[00:11] *** sftp left
[00:16] *** songmaster joined
[00:18] <dukeleto> sorear++ # thanks for answering my question about @_

[00:29] *** rgrau_ left
[00:33] *** felliott left
[00:33] *** azert0x left
[00:43] *** Chillance left
[00:44] *** felliott joined
[00:47] *** lkk- joined
[00:49] *** felliott left
[00:54] *** bluescreen joined
[00:54] *** bluescreen is now known as Guest49617

[00:57] *** masonkramer_ joined
[00:57] *** masonkramer left
[00:57] *** masonkramer_ is now known as masonkramer

[00:58] <whiteknight> Are the rakudo people looking at this new "organizations" feature in github?

[00:59] <pmichaud> I'll probably look at it after R* is released

[00:59] <pmichaud> I've often wanted it, but this is not the month to be rocking the boat :)

[00:59] <pmichaud> (an "organizations" feature, that is)

[01:02] <whiteknight> I'm sort of interested in seeing how it works, but I'm not going to create an organization myself

[01:02] <whiteknight> so I want you people to be the guinea pigs :)

[01:02] <pmichaud> I'll very likely convert the perl6 account to be an organizational account

[01:02] <pmichaud> and I can see about converting the parrot account to the same

[01:03] <pmichaud> so yes, we can be the guinea pigs, if you can handle waiting a month

[01:03] *** skids joined
[01:04] <whiteknight> I can definitely wait. 

[01:06] <colomon> rakudo: say "5/4".eval

[01:06] <p6eval> rakudo 36998b: OUTPUT«1.25␤»

[01:07] <sorear> diakopter: Why hasn't dalek reconnected yet?

[01:08] *** sorear sets mode: +oooo pmichaud whiteknight [Coke] dukeleto

[01:09] <diakopter> dunno

[01:09] <diakopter> i'll hup

[01:10] *** dalek joined
[01:10] <diakopter> dalek: WELCOME BACK YOU BOT YOU

[01:10] *** plobsing joined
[01:13] *** gbacon left
[01:20] *** kensanata joined
[01:20] *** kensanata left
[01:22] *** meppl left
[01:25] *** sorear sets mode: +vv dalek p6eval

[01:25] <sorear> hugme and pugssvn are still out

[01:30] <diakopter> I don't know how to retrieve those

[01:30] <diakopter> well let me see

[01:32] <diakopter> oops

[01:33] <diakopter> I guess I could hijack moritz_'s screen session, though people growl about that

[01:33] <diakopter> ah well; I've done worse

[01:33] <diakopter> feather2, mind you

[01:39] *** hugme joined
[01:39] <diakopter> success

[01:40] <diakopter> moritz_: kill me later :)

[01:43] *** pugssvn joined
[01:44] <diakopter> mruhaha

[01:45] <diakopter> phenny: tell moritz_ let's run the bots in looping shell scripts if possible so a sighup from another root user can restart them more easily

[01:45] <phenny> diakopter: I'll pass that on when moritz_ is around.

[01:45] *** ashleydev left
[01:49] *** tylercurtis_ joined
[01:49] *** tylercurtis left
[01:49] *** tylercurtis_ is now known as tylercurtis

[01:51] *** whiteknight left
[01:55] <pmichaud> the series operator documentation is either ambiguous or contradictory

[01:56] <pmichaud> when is the paragraph beginning with "The exact function deduced..." supposed to apply?

[01:57] *** sorear sets mode: +vv hugme pugssvn

[01:58] <colomon> ciphertext and I were thinking it should be after the left hand values are passed along.

[01:59] <pmichaud> that sentence doesn't really make sense to me

[01:59] *** Guest49617 left
[01:59] <pmichaud> if I follow that paragraph precisely, then it would mean

[01:59] <pmichaud>    1, 2, 3 ... $n         would result in 1, 2, 3, 2, 1, 0, -1    when $n is == -1

[02:00] <pmichaud> and I'm pretty sure that's not what is intended

[02:00] <pmichaud> (as it contradicts earlier statements)

[02:01] <colomon> ah, I think I see what you're getting at.

[02:01] <pmichaud> I think the function has to be deduced based on the first value of the lhs, not the last one.

[02:03] <pmichaud> one part of the spec says "values on opposite sides of the limit"

[02:03] <pmichaud> this part of the spec says "deduced from the final value on the left to the limit on the right"

[02:04] <pmichaud> still a third part says "on the wrong side of the first value of the left list"  (granted, only for intuited numeric generators)

[02:04] <pmichaud> seems like it really ought to be one rule.

[02:05] <colomon> agreed.

[02:05] <colomon> (I think, on the tired side to follow this.)

[02:06] <colomon> My impression is the limit rule we are using in the master branch seems to do what TimToady wants.

[02:07] <pmichaud> looking

[02:07] <colomon> even though it's not exactly what the spec says.

[02:07] <pmichaud> but my last impression was that limit rule has some broken edge cases

[02:07] <colomon> (I wrote it under direction from him.)

[02:08] <colomon> for sure it won't work as is on the very first element

[02:08] <[Coke]> for those that remember packy from YAPC: 

[02:08] <[Coke]> http://packy.livejournal.com/156186.html

[02:08] <pmichaud> yes, what is in master now is too complex to really be correct, imo.

[02:09] *** Guest49617 joined
[02:11] <colomon> packy++

[02:12] <pmichaud> okay, so here's my current guess

[02:12] <pmichaud> when we intuit a numeric generator, we use that generator to determine the limit condition

[02:13] <pmichaud> when we don't intuit a numeric generator, we use the last element of the lhs and the first element of the rhs to determine the limit condition

[02:13] <pmichaud> so:   'a', 'b', 1 ... $n     would indeed produce   'a', 'b', 1, 0, -1, -2    when $n == -2

[02:14] <colomon> pmichaud: errr... that's intuiting the generating function, not the limit, right?

[02:14] <pmichaud> it's both.

[02:15] <pmichaud> with    'z' ... 'a'    we automatically determine the generating function (.pred) and the limit  

[02:16] <pmichaud> oh, bad example.

[02:16] <colomon> nod

[02:16] <pmichaud> with    99 ... 3    we automatically ....

[02:17] <colomon> what do you think the limit function is here?

[02:18] <pmichaud> well, we're not intuiting an arithmetic or geometric series

[02:19] <pmichaud> therefore our generating function is .pred, and we stop when { $^a !after 3 }

[02:19] <pmichaud> or, put another way, we continue as long as { $^a !before 3 }

[02:20] <pmichaud> (to strictly match the spec)

[02:21] *** agentzh joined
[02:22] <pmichaud> I'm also curious about

[02:23] <pmichaud> 1, 2, 3, *+1 ... 0     # infinite?

[02:23] <pmichaud> as opposed to

[02:23] <pmichaud> 1, 2, 3 ... 0   # Nil?

[02:23] <colomon> my first thought is infinite.

[02:24] <pmichaud> alas, no.  spec says:

[02:24] <colomon> the Nil rule is for "intuited numeric generators"

[02:24] <pmichaud> okay then

[02:24] <pmichaud> so, the first one is infinite, the second is nil

[02:24] <colomon> yes

[02:24] <pmichaud> and   1, 2, 3 ... $n   is not always the same as   1, 2, 3, *+1 ... $n

[02:24] <pmichaud> *that* will confuse people a lot.

[02:24] <colomon> because the code block could be anything.

[02:25] <colomon> agreed.

[02:28] <colomon> it's like the mostly eager stuff -- the Nil rule is an attempt to rule out cases where the series probably isn't doing what the author intends.

[02:29] <colomon> but that means it doesn't really fit in well with the big picture DWIMiness for series.

[02:29] <pmichaud> part of me wants to examine the entire lhs for increase/decrease to determine the limit

[02:30] <pmichaud> er, the relation to the limit

[02:30] <colomon> but it doesn't have to be consistent at all.

[02:30] <pmichaud> sure, and in that case, we don't deduce a limit.

[02:30] <pmichaud> sorry, we don't deduce a relation

[02:30] <colomon> 2, -3, 1, -1, 33, { * + (-1, 1).pick } ... 10 is legal, after all.

[02:31] <pmichaud> and you'd want to stop as soon as we get a value that is 10 or before?

[02:31] <pmichaud> I could almost argue that this series should continue until 10 is reached exactly, otherwise infinite

[02:31] <colomon> that's supposed to stop *only* reached exactly.

[02:31] <colomon> *when ten is reached

[02:32] <colomon> sigh. very tired.

[02:32] <pmichaud> ah.  current spec says  that it would stop when we get 10 or a value less than 10.

[02:32] <colomon> wait, that's not right either.

[02:32] <pmichaud> (the "either side" rule.)

[02:32] <colomon> yes, I think you're right.

[02:34] <pmichaud> (and the fact that there's confusion about what should happen just shows how the spec has the dwimminess or ambiguity knobs turned up too high)

[02:35] <pmichaud> I think as a general rule it might be nicer if we simply say "if monotonicity can be determined from the lhs, we use that to determine the relation to the limit.  otherwise, stop only when the limit is reached exactly."

[02:35] <colomon> I absolutely think the spec here has some maturing to do uyet.

[02:36] <pmichaud> because "the absolute value when geometric with sign changes" is also a bit weird to deal with.

[02:37] <pmichaud> or, stated differently, the spec as it exists now involves memorization of too many special cases, and in Perl 6 we're trying to eliminate that :)

[02:37] <colomon> :)

[02:39] <pmichaud> so, if all(@lhs) !after $limit, then the condition becomes $_ !after limit

[02:39] * lue thinks the spec needs to be a bit more accessible. :)

[02:39] <pmichaud> hmm, that's not quite right.

[02:41] <colomon> wouldn't it be something like if [before] @lhs?

[02:41] <colomon> if you want @lhs to be monotonic.

[02:41] <colomon> [!after] is legal, isn't it?  crazy language we've got here.

[02:42] <colomon> rakudo: say [!after] 1, 1, 2, 3, 3, 4, 5

[02:42] <p6eval> rakudo 36998b: OUTPUT«1␤»

[02:42] <colomon> rakudo: say [!after] 1, 1, 2, 3, 3, 2, 5

[02:42] <p6eval> rakudo 36998b: OUTPUT«0␤»

[02:43] <colomon> rakudo: say [before] 1, 1, 2, 3, 3, 4, 5

[02:43] <p6eval> rakudo 36998b: OUTPUT«0␤»

[02:43] <colomon> rakudo: say [before] 1, 1.2, 2, 3, 4, 5

[02:43] <p6eval> rakudo 36998b: OUTPUT«1␤»

[02:49] *** am0c joined
[02:51] *** agentzh left
[02:53] <colomon> so if [!after] @lhs, then the termination case is $latest after $rhs? 

[02:53] <colomon> no, because the case is, if the $latest equals the limit, the output $latest and we're done.

[02:54] <frew> rakudo: say 1 before 2

[02:54] <p6eval> rakudo 36998b: OUTPUT«1␤»

[02:54] <frew> rakudo: say 0 before 2

[02:54] <p6eval> rakudo 36998b: OUTPUT«1␤»

[02:54] <frew> rakudo: say 2 before 0

[02:54] <p6eval> rakudo 36998b: OUTPUT«0␤»

[02:55] <frew> how is before different than < ?

[02:56] <colomon> sorry that's not clear, pmichaud, but the point I'm trying to make is it's not enough to say $latest after $rhs, because you can only return the $rhs (the limit) once.

[02:56] <lue> rakudo: say 'a' before 'z'; say 'a' < 'z';

[02:56] <p6eval> rakudo 36998b: OUTPUT«1␤0␤»

[02:56] <lue> well, there's one reason.

[02:56] <frew> ah interesting

[02:56] <frew> so < is numeric and before is generic

[02:56] <frew> that makes sense

[02:56] <colomon> after / before is anything.

[02:56] <colomon> < is numeric

[02:56] <frew> :-)

[02:57] <colomon> sorry, running very slow brain-wise here.

[02:57] <ash_> catch blocks set $_ to the exception, right? 

[02:57] <frew> rakudo: say [<foo frew frioux bar baz biff zong>].sort {$^a before $^b}

[02:57] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Confused at line 11, near "say [<foo "␤»

[02:58] <frew> rakudo: [<foo frew frioux bar baz biff zong>].sort {$^a before $^b}.perl.say

[02:58] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Confused at line 11, near "[<foo frew"␤»

[02:58] <frew> rakudo: <foo frew frioux bar baz biff zong>.sort {$^a before $^b}.perl.say

[02:58] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Confused at line 11, near "<foo frew "␤»

[02:58] <frew> :-(

[02:58] <ash_> rakudo: ([<foo member:frew frioux bar baz biff zong>].sort: {$^a before $^b}) .perl.say

[02:58] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Confused at line 11, near "([<foo mem"␤»

[02:58] <frew> rakudo: (<foo frew frioux bar baz biff zong>).sort {$^a before $^b}.perl.say

[02:58] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Confused at line 11, near "(<foo frew"␤»

[02:58] <ash_> rakudo: (<foo member:frew frioux bar baz biff zong>.sort: {$^a before $^b}).perl.say

[02:58] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Confused at line 11, near "(<foo memb"␤»

[02:59] <ash_> rakudo: (<foo frew frioux bar baz biff zong>.sort: {$^a before $^b}).perl.say

[02:59] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Confused at line 11, near "(<foo frew"␤»

[02:59] <ash_> grr

[02:59] <frew> rakudo: (<foo frew frioux bar baz biff zong>).sort({$^a before $^b}).perl.say

[02:59] <lue> .oO(interesting clock)

[02:59] <ash_> thats weird 

[02:59] <p6eval> rakudo 36998b: OUTPUT«("frew", "frioux", "foo", "bar", "biff", "zong", "baz")␤»

[02:59] <frew> \o/

[02:59] <frew> so that's probably the default sort I'd bet

[03:00] <colomon> what, why \o/

[03:00] <colomon> ?

[03:00] <colomon> before and after are not for sorted

[03:00] <frew> uh

[03:00] <frew> because it worked?

[03:00] <colomon> for bar zong is sorted?!?

[03:00] <frew> after we tried 7 different ways and failed

[03:00] <frew> what?

[03:01] <frew> lookj at the result

[03:01] <frew> oh wait

[03:01] <frew> ywah

[03:01] <colomon> "frew", "frioux", "foo", "bar", "biff", "zong", "baz" -- how is that sorted?

[03:01] * frew can't read

[03:01] <colomon> if you pass a two argument comparison to sort, it has to return -1  0  +1, just like cmp

[03:01] <frew> oooh

[03:02] <colomon> rakudo: (<foo frew frioux bar baz biff zong>).sort({$^a cmp $^b}).perl.say

[03:02] <p6eval> rakudo 36998b: OUTPUT«("bar", "baz", "biff", "foo", "frew", "frioux", "zong")␤»

[03:02] <colomon> which is the standard default sort.

[03:02] *** molaf joined
[03:02] <colomon> before only returns true or false.

[03:02] <colomon> (and yes, cmp is the default sort)

[03:02] <colomon> rakudo: (<foo frew frioux bar baz biff zong>).sort.perl.say

[03:02] <frew> so the reduce form just returns *if* the list is sorted then?

[03:02] <p6eval> rakudo 36998b: OUTPUT«("bar", "baz", "biff", "foo", "frew", "frioux", "zong")␤»

[03:02] <colomon> [before], you mean?

[03:02] <colomon> yes

[03:03] <frew> that's reduce right?

[03:03] <colomon> yes.

[03:03] <frew> k, just making sure

[03:03] <colomon> that's not just sorted, there cannot be any duplicates

[03:03] <lue> hm, according to the spec, loose and & loose or are list associative, not left assoc. (as Grammar.pm would have us believe)...

[03:03] <colomon> [!after] is sorted with duplicates

[03:04] <colomon> I sooooo need to go to bed.

[03:05] <lue> .oO(let's change it and see what happens...)

[03:08] *** ash_ left
[03:08] <colomon> 'night, all.

[03:09] <lue> goodnight colomon o/

[03:18] <colomon> one last thought, pmichaud: are you thinking that the monotonic test you're proposing should work for series where you pass in the generating code block?  That 1, 1, *+* ... 400000 series I used the other day was really slick, requiring the user to find the exact limit value on something like that would be a big drawback.

[03:20] <colomon> of course, the problem with that is what do you do for the 1, { code } ... 4000000 case?  Hmmm... guess it can be based on 1 versus 4000000

[03:20] <colomon> pmichaud: what were you saying about comparing the first value on the LHS to the limit?  :)

[03:20] <colomon> ....sleep

[03:20] *** broquaint left
[03:21] *** broquaint joined
[03:29] <dalek> csmeta: r359 | stefa...@cox.net++ | trunk/vicil (4 files):

[03:29] <dalek> csmeta: [vicil] Switch to generated code for testing.  Extend code generator to handle

[03:29] <dalek> csmeta: closure cloning and protopad tree bootstrapping.

[03:29] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=359

[03:33] <diakopter> impressive

[03:41] <lue> heh. I changed one thing (well, two) in Grammar.pm, and every single spectest test returns dubious :)

[03:43] *** Guest49617 left
[03:43] *** mikehh left
[03:43] *** mikehh joined
[03:47] *** tedv left
[03:55] *** ashleydev joined
[03:56] *** jaldhar left
[03:56] *** jaldhar joined
[03:56] *** am0c left
[03:58] <sorear> How does Perl 6 interpret the return value of .Bool?

[04:03] <lue> afk

[04:04] *** ashleydev left
[04:09] *** ashleydev joined
[04:11] <cxreg> o_O how do you use a variable in hash subscript?  <> seems to work like q{}

[04:11] *** am0c joined
[04:13] <frew> cxreg: %has{$foo}

[04:13] *** molaf left
[04:13] <cxreg> ah, i thought {} was always a block

[04:13] <PerlJam> cxreg: <> is the "quote words" operatior

[04:13] <PerlJam> er, operator

[04:13] <PerlJam> cxreg: {} is always a block, except when it's not :)

[04:14] <cxreg> um ok, but i thought that was a big emphasis of TimToady, that {} was unambiguous in 6

[04:14] <cxreg> anyway, {} it is.

[04:16] <PerlJam> cxreg: yeah, except that {} for subscripting is still pretty fundamental to PErl

[04:17] <cxreg> its just syntax

[04:18] <cxreg> i thought <> replaced {} as a subscript, across the board

[04:18] <PerlJam> nope, <> is just a convienent shorthand

[04:19] <PerlJam> {} is even used for user-defined indexing into @arrays

[04:22] *** skids left
[04:27] <frew> for some reason I can't seem to get nqp to match a ';'

[04:27] <frew> after some other stuff...

[04:28] <frew> in perl 5 I'd so something like, ([^;]+);

[04:28] <frew> how do I do the same thing in perl 6?

[04:29] <frew> I tried [!';'];

[04:29] <sorear> <![;]>

[04:30] <sorear> (.*?);

[04:30] <sorear> (<![;]>*);

[04:30] <[particle]> (<![;]>*) ;

[04:31] <sorear> tomorrow, I'm going to have to pick brains (TimToady? pmichaud?) on exactly what BEGIN means in a compiled context

[04:31] <[particle]> hrmm, do you need to quote the semicolon? i think not

[04:31] <frew> I did the first with a +

[04:31] <[particle]> well, s/*/+/

[04:31] <frew> man

[04:31] <frew> I'm getting some kind of infinit loop

[04:31] <[particle]> back to plotting my weekend backpacking...

[04:32] <frew> http://paste.scsys.co.uk/45336

[04:32] <frew> input of '$frwe:1;'

[04:41] *** justatheory left
[04:41] <sorear> Oh wait nevermind.  I already came up with the answer to this one; it's in my notes.

[04:41] <frew> ?

[04:58] *** mberends left
[05:02] *** ashleydev left
[05:16] *** IllvilJa left
[05:22] *** kaare joined
[05:22] *** kaare is now known as Guest30036

[05:25] <ingy> hi [particle] 

[05:27] *** amkrankruleuen joined
[05:28] <amkrankruleuen> Hello. (:

[05:28] <PerlJam> greetings

[05:29] *** Su-Shee joined
[05:31] <PerlJam> Suuuuuuuuu-Sheeeeeeeeee

[05:31] * PerlJam is tired

[05:35] *** cono left
[05:41] <songmaster> Question — I have a 2-dimensional array, [[1,2],[3,4]. How do I flatten it to [1,2,3,4]?

[05:41] <songmaster> (missing second ] in my array)

[05:46] *** cono joined
[05:49] *** songmaster left
[05:50] *** agentzh joined
[05:55] <sorear> Hello amkrankruleuen

[05:57] <dalek> csmeta: r360 | stefa...@cox.net++ | trunk/vicil/Kernel.cs:

[05:57] <dalek> csmeta: [vicil] Implement protoobjects

[05:57] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=360

[06:00] *** rcsheets` joined
[06:05] *** amkrankruleuen left
[06:08] <Su-Shee> PerlJam: no wonder.. it's early in the morning ;)

[06:09] *** uniejo joined
[06:09] *** Guest63979 left
[06:11] * sorear invents not one, but two compiler-specific phasers.  Just like that.

[06:12] <dalek> csmeta: r361 | stefa...@cox.net++ | trunk/vicil/ (2 files):

[06:12] <dalek> csmeta: [vicil] Tiny change of plans.  There is no KERNEL frame; very low-level

[06:12] <dalek> csmeta: definitions are done in the main setting, possibly at PREINIT or PRELUDE time.

[06:12] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=361

[06:20] *** Guest30036 is now known as kaare_

[06:23] <sorear> I need a new name for my Perl 6 implementation

[06:24] <sorear> I've deviated far enough from diakopter's plans that I don't feel right keeping his name

[06:25] *** am0c left
[06:27] *** mmcleric joined
[06:28] *** Mowah joined
[06:31] *** mberends joined
[06:39] *** am0c joined
[06:55] <cxreg> is there some way to make a method private to everyone except privileged classes?

[06:56] <sorear> make it private and use trusts?

[06:56] <sorear> but accessibility is only a convention in Perl

[07:04] *** lestrrat is now known as lest_away

[07:05] *** TiMBuS joined
[07:10] <TiMBuS> i got a seasoned perl5er to report back on how accessible perl6 is at the moment. he wrote up a nice little 'trip report' about it

[07:10] <TiMBuS> i will nopaste it

[07:10] <TiMBuS> nopaste?

[07:10] <TiMBuS> wheres purl :<

[07:14] <tylercurtis> TiMBuS: http://nopaste.snit.ch/

[07:14] <TiMBuS> got it, thanks :)

[07:16] <TiMBuS> http://nopaste.snit.ch/21695 <- needs wordwrap

[07:16] *** Ross joined
[07:17] <TiMBuS> http://nopaste.snit.ch/21695?wr=on&submit=Format+it! i guess that's the link you'd want.

[07:17] <TiMBuS> when you word wrap it ruins the actual paragraphs. a bit annoying :<

[07:18] *** amkrankruleuen joined
[07:19] *** cuppe left
[07:20] <tylercurtis> http://nopaste.snit.ch/21695?tx=on&submit=Format+it! works fine for me: word-wrap without breaking paragraphs. 

[07:20] *** cuppe_ left
[07:21] *** cuppe joined
[07:22] *** cuppe_ joined
[07:23] *** junior_ joined
[07:24] *** junior_ left
[07:29] *** amkrankruleuen left
[07:29] *** amkrankruleuen joined
[07:35] <TiMBuS> probably your browser wrapping ti for you. oh well regardless its all useful imo

[08:00] <dalek> csmeta: r362 | stefa...@cox.net++ | trunk/vicil/notes.pod:

[08:00] <dalek> csmeta: [vicil] Tonight's insights

[08:00] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=362

[08:01] <sorear> this stefa...@cox.net guy

[08:01] <sorear> stealing all my karma

[08:01] *** aesop left
[08:02] <kaare_> Stefans are like that

[08:05] *** aesop joined
[08:07] *** masak joined
[08:07] <masak> oh hai, #perl6!

[08:07] <masak> http://www.marriedtothesea.com/092607/tgiw.gif

[08:16] <sorear> Hello masak

[08:16] <sorear> I need your help naming something

[08:17] <masak> :)

[08:17] <sorear> You seem to be good at it

[08:17] <masak> why, thanks.

[08:17] <masak> what is it?

[08:17] <sorear> It's a Perl 6 implementation I'm hacking on

[08:17] <masak> oh, I read about that.

[08:17] <masak> tell me a bit more.

[08:18] *** dakkar joined
[08:18] <sorear> I used to call it Sprixel/VICIL but it's veered quite far from diakopter's spec and I feel his name is no longer mine to use

[08:18] <masak> so what characterizes it?

[08:18] <sorear> it targets the CLR.  its experimental focus is static compilation support and CHECK time optimization

[08:18] <masak> nice.

[08:19] <masak> you could call it "Czech" :) and no-one would be able to spell it.

[08:21] <sorear> Do you have something a little more unique?

[08:21] <sorear> I suppose Czech is better than Go

[08:21] <masak> hm, maybe a variation of "Nie mamy czas" would be appropriately punny.

[08:22] <masak> I was also thinking along the lines of "Optimus Prime".

[08:22] <masak> but that's both a keyboard and a giant robot, so it'd have to be different somehow.

[08:22] <masak> maybe "Optimus Six"?

[08:23] <masak> still sounds more like a language than an implementation...

[08:23] <mathw> # And you look like a victim of a surgical crime / A little Darth Vader a little Optimus Prime

[08:23] <masak> mathw: we listen to different kinds of music. :P

[08:24] <mathw> So do I, but that song's funny

[08:24] <mathw> also desperately sad

[08:24] * sorear wants something compact, cheery

[08:24] <sorear> maybe I'll try Niecz

[08:25] <sorear> (what's 'mamy')?

[08:25] <arnsholt> What's "Nie mamy czas"? =)

[08:25] <masak> it means "We don't have time" in Czech.

[08:25] <mathw> O6

[08:26] <masak> sorear: you could call it "Maglev".

[08:26] <masak> (because it's fast, and has no friction)

[08:27] <sorear> Niecza has a very good Google Uniqueness Quotient

[08:28] <masak> that's nice.

[08:28] *** thebird joined
[08:28] <masak> looks a bit like "Nietzsche", too.

[08:28] <sorear> and it has a nice semi-meaningful expansion, and it rolls like Rakudo or Yapsi or Sprixel

[08:28] * sorear takes

[08:28] <sorear> thanks

[08:28] <masak> you're welcome.

[08:29] <mathw> \o/

[08:29] *** mathw sets mode: +o masak

[08:30] <masak> phenny: tell jnthn lol we named sorear++'s Perl 6 implementation based on "Min man e kass" :P

[08:30] <phenny> masak: I'll pass that on when jnthn is around.

[08:34] *** Ross left
[08:37] <sorear> What's that?

[08:37] *** timbunce joined
[08:38] <kaare_> Nietzsche declared that God is dead. Perhaps Niecza will declare Perl5 to be dead ;-)

[08:39] <masak> sorear: it's a song in Czech that somebody put Swedish subtitles on.

[08:39] <masak> sorear: http://www.youtube.com/watch?v=y3oFc-phIBA

[08:42] <sorear> ah.

[08:43] <masak> jnthn started his exploration of Swedish by forming sentences of the form "Min X är kass" -- "My X is broken/bad"

[08:44] <masak> so don't be surprised if people send bug reports starting "Min Niecza e kass" :P

[08:44] <moritz_> diakopter: the evalbot did run in a loop

[08:44] <phenny> moritz_: 01:45Z <diakopter> tell moritz_ let's run the bots in looping shell scripts if possible so a sighup from another root user can restart them more easily

[08:45] <sorear> Are Swedish and Czech closely related?

[08:47] <masak> sorear: not in any immediate sense.

[08:48] <masak> sorear: but there's a subculture/tradition here in Sweden (and to a lesser extent in the anglosphere) of subtitling lyrics which "sound like" Swedish if you don't listen too closely.

[08:49] <masak> & # posing with milk

[08:49] *** mikehh left
[08:50] *** mikehh joined
[08:50] *** plobsing left
[08:51] *** mj41 left
[08:52] *** mikehh left
[08:52] *** mikehh joined
[08:59] *** mikehh left
[08:59] <dalek> csmeta: r363 | stefa...@cox.net++ | trunk/vicil/Compiler.pm:

[08:59] <dalek> csmeta: [vicil] Start on tree compiler

[08:59] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=363

[09:00] *** lkk- left
[09:03] <tylercurtis> moritz_: about to go to bed, but thought I should let you know that :min_depth and :descend_until are both implemented for transformation and appear to work(by which I mean, they pass all my tests, including tests of the two together).

[09:04] <moritz_> tylercurtis: yay

[09:04] <moritz_> tylercurtis: I don't know if I'll have time to play around with them, but if yes I'll let you know the result

[09:08] <tylercurtis> moritz_: thanks.

[09:09] *** cuppe left
[09:09] *** cuppe joined
[09:09] *** cuppe_ left
[09:09] *** cuppe_ joined
[09:12] <pugssvn> r31509 | moritz++ | [t/spec] tests for RT #72912, .perl on result of series operator 

[09:19] *** tadzik joined
[09:19] *** tylercurtis left
[09:23] <jnthn> morning, #perl6

[09:23] <phenny> jnthn: 08:30Z <masak> tell jnthn lol we named sorear++'s Perl 6 implementation based on "Min man e kass" :P

[09:23] <jnthn> lol

[09:23] <moritz_> good morning jnthn 

[09:24] <bbkr> morning P6

[09:25] <bbkr> rakudo; my %h; %h<one><two> = 1;

[09:25] * bbkr pokes rakudo eval

[09:25] <moritz_> try it with : instead of ;

[09:25] <bbkr> rakudo: my %h; %h<one><two> = 1;

[09:25] <arnsholt> IIRC that doesn't work

[09:25] <p6eval> rakudo 36998b: OUTPUT«Method 'postcircumfix:<{ }>' not found for invocant of class 'Proxy'␤  in main program body at line 1␤»

[09:25] <bbkr> yep, sleepy :)

[09:26] <arnsholt> (Autovivification is NYI)

[09:26] <jnthn> masak: Hmm...do the Czechs really spell it czas?

[09:26] * jnthn checks

[09:27] <jnthn> masak: They don't - the z to imply softness is a Polishism. :-) The Czech is čas. ;-)

[09:27] <bbkr> czas is polish word :)

[09:27] <jnthn> bbkr: Means "time"?

[09:27] <bbkr> yes

[09:28] <jnthn> :-)

[09:28] <jnthn> At least the meaning is consistent then. :)

[09:29] <sorear> Does Nie mean anything in Polish?

[09:29] <bbkr> "nie mam czasu" means "i don't have time for that". useful phrase to remember :)

[09:29] <bbkr> Nie means "no"

[09:29] <bbkr> or "i don't"

[09:29] <bbkr> negation

[09:29] <jnthn> bbkr: At least the meaning was the same. :-) Woulda been far worse if they'd chosen the Polish verb szukam and expected it to mean something good in Slovak. :-)

[09:30] <Su-Shee> it means never in german. 

[09:32] <jnthn> Su-Shee: I managed to order beer and currywurst in German on Sunday. \o/

[09:32] *** mmcleric left
[09:32] <bbkr> Slovak, Czech and Polish are very similiar languages. I think relation can be compared to case of Ukrainian and Russian - they use their own languages but can understand each other without dictionary

[09:32] * jnthn had a short time in Cologne.

[09:32] *** mmcleric joined
[09:33] <Su-Shee> jnthn: and did you actually _get_ beer and currywurst (UAH.. :) ?

[09:33] <jnthn> Su-Shee: I did! \o/

[09:33] <jnthn> And it was very nice. :-)

[09:33] <Su-Shee> I've never eaten currywurst once... or bavarian weisswurst.. 

[09:34] <amkrankruleuen> o polak!

[09:34] <Su-Shee> my polish collegue immediately recognized zavolaj, btw. and found it funny.

[09:34] <jnthn> bbkr: Well...maybe native speakers can. While I found I could guess my way through a decent bit of Czech, Polish felt that bit more distant.

[09:35] <pugssvn> r31510 | moritz++ | [t/spec] test for RT #76068, two iterations of a loop share the same $_ if it is not a formal parameter of the block 

[09:35] <jnthn> Su-Shee: Huh, most of what I eat in Germany is wurst. :-)

[09:35] <sorear> I've finished renaming and extracting niecza; it now lives on github

[09:35] <Su-Shee> jnthn: I think it's similar that I understand dutch and can read it "somehow". 

[09:36] <jnthn> :-)

[09:36] <Su-Shee> jnthn: man, can't you go for the better things of german food? like our variety of bread? or cakes? :)

[09:36] <amkrankruleuen> Polish have hard grammar.

[09:36] <sorear> Who do I poke to get a new repo on dalek?

[09:37] <tadzik> sure we do :)

[09:37] <jnthn> You mean I've been eating the wurst thing you have? :-)

[09:37] <moritz_> sorear: maybe diakopter knows

[09:37] <jnthn> Su-Shee: I agree on the cakes though. :-)

[09:37] <jnthn> They are also great.

[09:37] * sorear out

[09:37] <bbkr> Su-Shee: Czech is funny for people from Poland because Czech words sounds similiar to Polish diminutives

[09:37] <Su-Shee> jnthn: ok, then try bratwurst as well and go for hams next. ;)

[09:38] <Su-Shee> bbkr: for me, dutch has a "cute" sound. :)

[09:38] * jnthn takes notes for his next trip to Germany :-)

[09:38] <cono> bbkr: It's funny for Ukrainian too :)

[09:39] <Su-Shee> jnthn: oh, and short before christmas: cookies. that's something we really do very well. christmas cookies. all kinds of regional stuff, some recipes are like 800 years odl..

[09:40] <bbkr> cono: for me Ukrainian was quite understandable without learning. reading was a bit more difficult, but cyrylic is in fact very cute.

[09:41] <cono> bbkr: Are you from Poland?

[09:41] <bbkr> cono: yes

[09:41] <cono> neighbour :

[09:41] <cono> )

[09:42] <jnthn> Su-Shee: Conveniently, I have a sleeper train from here to Cologne, and from there I can easily get to the UK to see family. So I now have a great excuse to visit a German christmas market in Germany. :-)

[09:42] <Su-Shee> harhar. who isn't a neighbour on continental europe? ;)

[09:42] <jnthn> (German christmas markets seem to happen all over the UK these days too, but I suspect the real thing is far better.)

[09:42] <Su-Shee> jnthn: you could probably get away with asking randomly housewife-ish looking middle aged women in a small town for christmas cookies ;)

[09:43] <cono> Su-Shee: ofc, but Ukraine and Poland so close to each other

[09:44] <Su-Shee> cono: well historically spoken, poland's position in between has been more of a curse but a blessing. ;)

[09:45] <masak> right, "čas".

[09:45] <cono> between what countries?

[09:46] <Su-Shee> sweden, russia, germany/prussia

[09:46] <Su-Shee> food! 

[09:46] <masak> Su-Shee: this could be a solution to Poland's problems: http://www.economist.com/node/16003661?story_id=16003661

[09:47] <cono> haha, Ukraine rocks :D

[09:47] <tadzik> oh no

[09:48] <tadzik> it's rainy enough alredy

[09:48] <jnthn> masak: hah :-)

[09:48] <jnthn> cono: Indeed. :-)

[09:48] <bbkr> masak: hahaha, nice one. amazing how they reorganized countries with maintaining continent shape

[09:49] <jnthn> I love how they moved Switzerland up to the Nordics. :-)

[09:49] <bbkr> rakudo: class A { has $.foo }; my A $a .=new( foo => 42 ); say $a.perl

[09:49] <p6eval> rakudo 36998b: OUTPUT«A.new()␤»

[09:50] <masak> bbkr: .perl on user-created classes is LTA.

[09:50] <jnthn> It's also unspec'd.

[09:50] <masak> jnthn: the idea of .perl is to serialize so that an eval() restores the object as best possible, no?

[09:51] <jnthn> masak: something laik that.

[09:51] <bbkr> leaving #61918 open then, with comment that it does not crash now

[09:51] <jnthn> masak: otoh, do we want .perl to go exposing an object's privates?

[09:52] <moritz_> sure

[09:52] *** perlygatekeeper1 joined
[09:52] *** perlygatekeeper left
[09:54] <bbkr> rakudo: my Int $x = +"2";

[09:54] <masak> jnthn: what moritz_ said. I think using .perl is sufficiently "meta" to consider it not a real breach of OO principles.

[09:54] <p6eval> rakudo 36998b: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/Kd2cLlQ1a9␤»

[09:55] <masak> bbkr: mmmr, I hate that bug. :/

[09:55] <bbkr> rakudo: (+"2").WHAT.say

[09:55] <p6eval> rakudo 36998b: OUTPUT«Num()␤»

[09:55] <masak> also, why doesn't it say which type it expected and which one it got?

[09:55] <moritz_> masak: I think colomon++ has been preparing to fix that

[09:55] <masak> nice.

[09:55] <cono> what means LTA?

[09:55] <moritz_> cono: less than awesome

[09:56] <cono> :)

[09:56] <bbkr> rakudo: say 'hello-world'.split(/<ws>/).perl;

[09:56] <cono> thanks

[09:56] <p6eval> rakudo 36998b: OUTPUT«("", "ello", "", "", "orld", "", Mu)␤»

[09:56] <masak> moritz_: re http://stackoverflow.com/questions/3147776/is-there-a-working-cpan-cpan6-like-project-for-perl6

[09:56] <masak> moritz_: nice reply.

[09:56] <masak> moritz_: however, we seriously need to find a URL that doesn't contain the word 'proto'.

[09:56] <masak> nor 'pls'.

[09:56] <moritz_> masak: modules.perl6.org?

[09:56] <masak> yes.

[09:57] <bbkr> rakudo: say 'a-b-c'.split(/<ws>/).perl; # doesn't look good

[09:57] <p6eval> rakudo 36998b: OUTPUT«("", "", "", "", "", "", Mu)␤»

[09:57] <masak> it doesn't highlight the level difference between 'project' and 'module' that I've sometimes been advocating, but maybe that's just as well.

[09:57] <moritz_> "project" is just *very* general

[09:57] <masak> bbkr: huh. is that an RT ticket.

[09:58] <masak> moritz_: true. so is 'ecosystem'.

[09:58] <bbkr> masak: http://rt.perl.org/rt3/Ticket/Display.html?id=63066 - related

[09:58] <masak> bbkr: yeah, but it's seemingly gotten worse.

[10:00] <bbkr> masak: i added comment there, but it looks now like higher priority than just end of line mismatch

[10:00] <moritz_> zero-width matches in general seem to set it up

[10:00] <moritz_> more or less

[10:00] <masak> bbkr: indeed. it's more or less another bug now.

[10:02] <bbkr> rakudo: sub s($i is copy) { my @array; for 1..3 { @array.push($i); my $i = 1 + $i; }}; s(9);

[10:02] <p6eval> rakudo 36998b: OUTPUT«Use of uninitialized value in numeric context␤Use of uninitialized value in numeric context␤Use of uninitialized value in numeric context␤»

[10:02] <moritz_> http://stackoverflow.com/questions/3144043/why-do-i-get-divide-by-zero-errors-when-i-try-to-run-my-script-with-rakudo/3148172#3148172

[10:03] <dalek> rakudo: 261eb2a | moritz++ | README:

[10:03] <dalek> rakudo: README: emphasize that installing Rakudo is really necessary

[10:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/261eb2ae08fee75a0a0e3935ef64c516e8bc2b98

[10:03] <masak> not running 'make install' gives a divide by zero now?

[10:04] <moritz_> seems like

[10:04] <masak> couldn't we just detect that situation once and for all, and put a nice error message there? :)

[10:05] <bbkr> rakudo: my $x = "foo"; class A { my $.y = $x }

[10:05] <p6eval> rakudo 36998b:  ( no output )

[10:05] <bbkr> rakudo: my $x = "foo"; class A { my $.y = $x }; A.new.y.say;

[10:05] <p6eval> rakudo 36998b: OUTPUT«Method 'y' not found for invocant of class 'A'␤  in main program body at line 11:/tmp/flkcISPHqk␤»

[10:06] <moritz_> masak: I'm kinda surprised it doesn't blow up in a more helpful way, since .loadlib now fails loudly

[10:06] <masak> bbkr: that's right, as far as I can see.

[10:06] <masak> or does 'my' also create accessors?

[10:06] <jnthn> moritz_: If you can dig through perl6.pir in alpha

[10:06] <bbkr> masak: it is right. i'm testing http://rt.perl.org/rt3/Ticket/Display.html?id=63588

[10:06] <jnthn> moritz_: Then the code we used to have is in there.

[10:06] <jnthn> moritz_: It'd want to go into src/Perl6/Compiler.pir

[10:06] <moritz_> jnthn: I'll take a look

[10:07] <bbkr>  rakudo: my $x = "foo"; class A { my $.y = $x; sub foo {say $.y} }; A.new.foo;

[10:07] <p6eval> rakudo 36998b: OUTPUT«Method 'foo' not found for invocant of class 'A'␤  in main program body at line 11:/tmp/5zh9sYrXBv␤»

[10:07] <bbkr>  rakudo: my $x = "foo"; class A { my $.y = $x; method foo {say $.y} }; A.new.foo;

[10:07] <p6eval> rakudo 36998b: OUTPUT«Method 'y' not found for invocant of class 'A'␤  in 'A::foo' at line 11:/tmp/eHqN_GnKLq␤  in main program body at line 11:/tmp/eHqN_GnKLq␤»

[10:07] <jnthn> bbkr: We don't do anything with my $.foo yet in Rakudo afaik

[10:07] <jnthn> Beyond creating the lexical

[10:08] <jnthn> I think we probably should generate a method too

[10:08] <jnthn> But...I'm not quite sure how that should look...

[10:08] <jnthn> (The normal route goes through the meta-model...)

[10:09] <moritz_> I'm kinda convinced that class attributes need a re-design in Perl 6

[10:11] <bbkr> rakudo: "foo" ~~ /<B::TOP>/

[10:11] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 11, near "::TOP>/"␤»

[10:11] <bbkr> ? why it complaints about regex assertion instead of nonexisting grammar?

[10:12] <jnthn> moritz_: It's hard to have class attributes when you don't really have a "class" object. :-)

[10:13] <jnthn> class Foo { ... } # installs Foo in the namespace

[10:13] <jnthn> erm

[10:13] <bbkr> rakudo: my ::MyType ::= :(Num, Str);

[10:13] <p6eval> rakudo 36998b: OUTPUT«===SORRY!===␤Malformed my at line 11, near "::MyType :"␤»

[10:13] <jnthn> s/Foo/type-object/

[10:16] *** agentzh left
[10:18] *** amkrankruleuen left
[10:18] <TiMBuS> hey there, just wondering if masak, jnthn, other higher ups saw that paste before

[10:18] <masak> cognominal: the thing you submitted to RT feels more like a topic for p6l than a ticket in RT.

[10:20] <masak> TiMBuS: this one? http://nopaste.snit.ch/21695?tx=on&submit=Format+it!

[10:21] <TiMBuS> thats the one

[10:21] *** literal left
[10:22] <masak> TiMBuS: I'm getting an unusual tl;dr reaction to that text. could you summarize a bit? like, two or three bullet points?

[10:22] <cognominal> masak: yea. I hit a snag and it triggers a lot of thoughts

[10:23] <masak> cognominal: even besides that, it's a Perl 6 feature request more than a Rakudo feature request.

[10:23] <masak> hence, p6l.

[10:24] *** azert0x joined
[10:24] <cognominal> I made my mind on one thing,  I think Range should be a parametric class. I don't know if parametric classes have a sensible default.

[10:24] <cognominal> masak,  feel free to follow up on p6l

[10:25] *** HarryS joined
[10:25] <TiMBuS> dot points is a bit hard since its a bit of a detailed um. journey to find perl 6

[10:25] <masak> cognominal: was there a use case in there somewhere? what do you want this for?

[10:26] <masak> TiMBuS: what's the most sailent point in what you wrote?

[10:27] <TiMBuS> finding perl6 is a little bit difficult, and could use some polish

[10:27] <masak> agreed.

[10:27] <TiMBuS> in particular, the perl download page could use a link

[10:27] <masak> url?

[10:27] <TiMBuS> since googlig for perl 6 takes you there

[10:27] <TiMBuS> http://www.perl.com/download.csp

[10:28] <cognominal> masak, using Range on Ints, excluded values are a lot of trouble and unecesseraly complicates the code

[10:28] <TiMBuS> The second hit (on google) is the perlfoundation.org page for downloading Perl 6 [ http://www.perlfoundation.org/perl6/index.cgi?download_perl_6 ]

[10:28] <masak> right. who has the keys to that page?

[10:28] <TiMBuS> also not a great link

[10:30] *** am0c left
[10:30] *** ruoso left
[10:30] <masak> bbkr: the reason '"foo" ~~ /<B::TOP>/' gives the error 'regex assertion not terminated by angle bracket' is that the <B::TOP> syntax isn't implemented in nqp-rx.

[10:31] <masak> bbkr: so the only thing that tells us is that right now, it's not possible to make the bug manifest.

[10:31] <bbkr> masak: thanks

[10:32] <masak> cognominal: do you have a code example of how you picture using your proposed addition?

[10:32] *** mmcleric left
[10:34] *** mmcleric joined
[10:35] <cognominal> I guess I will golf one

[10:35] <masak> s/sailent/salient/

[10:35] <masak> 'salient' means 'jumping [out]', apparently.

[10:38] <dalek> rakudo: aa015ad | moritz++ | src/Perl6/Compiler.pir:

[10:38] <dalek> rakudo: more awesome error message when running a non-installed Rakudo outside of the 

[10:38] <dalek> rakudo: build directory

[10:38] <dalek> rakudo: masak++ for complaining, jnthn++ for telling me where to steal the code

[10:38] <dalek> rakudo: (alpha's perl6.pirg)

[10:38] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/aa015ad043fc11ca10aecaf866b4158bea8edd47

[10:38] <masak> \o/

[10:38] <frettled> masak: I just read your p6c post regarding a monkey-typed Bool.pick.  You suggest:  defined self ?? self || (True, False).pick;  - couldn't that be easier implemented as:  self // (True, False).pick

[10:39] <moritz_> http://rakudo.org/submit-a-bug-report

[10:39] <masak> frettled: oh, 'course. much better. thanks. :)

[10:39] <moritz_> now somebody needs to change the title in the navigation bar

[10:39] <moritz_> I don't know how to do that (and I don't know if i have the privileges to do it)

[10:41] * frettled was useful again!  Woot!

[10:43] <xinming> '11

[10:44] *** figg joined
[10:44] *** am0c joined
[10:45] *** tadzik left
[10:45] *** figg left
[10:46] *** hugme left
[10:46] *** hugme joined
[10:47] *** amkrankruleuen joined
[10:48] <moritz_> hugme: tweet rakudoperl #rakudo now supports the $*ARGFILES magic file handle, which replaces the 'while (<>) { ... }' which you might know from Perl 5

[10:48] * hugme hugs moritz_; tweet delivered

[10:58] *** tadzik joined
[11:07] <bbkr> rakudo: sub example ($x is rw) { $x = 3; my @a; @a.push($x); $x = 5; say @a[0]; }; example(3);

[11:07] <p6eval> rakudo 261eb2: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in 'example' at line 11:/tmp/Px0mu1JHtu␤  in main program body at line 11:/tmp/Px0mu1JHtu␤»

[11:07] <bbkr> where is raadonly value here?

[11:08] <bbkr> readonly*

[11:08] <masak> that's the question.

[11:09] <bbkr> rakudo: sub example ($x is rw) { $x = 3; my @a; @a.push($x); $x = 5; say @a[0]; }; example();

[11:09] <p6eval> rakudo 261eb2: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in 'example' at line 11:/tmp/PeJ2HXfitk␤  in main program body at line 11:/tmp/PeJ2HXfitk␤»

[11:09] <hejki> rakudo: class Foo { has Int $.x is rw; method bar { "type of x: $.x.WHAT".say } }; my $f = Foo.new(); my $str = "foobar"; $str ~~ /(oo)/; $f.x = $0; $f.bar

[11:09] <p6eval> rakudo 261eb2: OUTPUT«type of x: oo.WHAT␤»

[11:09] <masak> bbkr: ah. it's the 3.

[11:09] <bbkr> rakudo: sub example ($x is rw) { $x = 3; my @a; $x = 5; }; example(3);

[11:09] <p6eval> rakudo 261eb2: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in 'example' at line 11:/tmp/RnjdwmwGFk␤  in main program body at line 11:/tmp/RnjdwmwGFk␤»

[11:09] <hejki> rakudo: class Foo { has Int $.x is rw; method bar { "type of x: " ~ $.x.WHAT ~ "".say } }; my $f = Foo.new(); my $str = "foobar"; $str ~~ /(oo)/; $f.x = $0; $f.bar

[11:09] <p6eval> rakudo 261eb2: OUTPUT«␤»

[11:09] <masak> bbkr: in your first one-liner.

[11:10] <hejki> rakudo: class Foo { has Int $.x is rw; method bar { "type of x: {$.x.WHAT}".say } }; my $f = Foo.new(); my $str = "foobar"; $str ~~ /(oo)/; $f.x = $0; $f.bar

[11:10] <masak> bbkr: the 3 is a literal, hence read-only.

[11:10] <p6eval> rakudo 261eb2: OUTPUT«type of x: Match()␤»

[11:11] <bbkr> rakudo: sub example ($x is rw) { $x = 3; my @a; @a.push($x); $x = 5; say @a[0]; }; my $z = 3; example($z);

[11:11] <p6eval> rakudo 261eb2: OUTPUT«3␤»

[11:11] <bbkr> masak: if this is expected behavior, then http://rt.perl.org/rt3/Ticket/Display.html?id=61982 can be closed as not spec-compatible?

[11:12] <masak> moritz_: could you have a look at http://rt.perl.org/rt3/Public/Bug/Display.html?id=61982 ?

[11:12] <masak> moritz_: I can't see how `$x = 5` could be legal if $x is bound to the argument 3.

[11:13] <masak> fwiw, it should work fine (and output 3) for 'is copy'.

[11:19] <bbkr> rakudo: say $x; my $x=4;

[11:19] <p6eval> rakudo 261eb2: OUTPUT«Any()␤»

[11:23] <bbkr> rakudo: my @a = "foo", "foot"; if @a[all(0,1)] ~~ /^ foo/ { say "OH MY!" }

[11:23] <p6eval> rakudo 261eb2: OUTPUT«OH MY!␤»

[11:23] <bbkr> yay

[11:23] <masak> bbkr++

[11:24] <bbkr> this test belongs more to array indexing or junctions or smartmatch/

[11:24] <bbkr> ?

[11:24] <colomon> pmichaud, et al: just finished some more timings.  It appears that stringifying an array of 100 strings (each < 80 chars) into a single Str takes about 17 seconds on my MBP.

[11:25] <moritz_> masak: huh? $x is rw

[11:25] <masak> moritz_: 3 isn't.

[11:26] <colomon> 50 strings appears take 5.4 seconds, suggesting we might be O(N^2) here.

[11:26] <masak> moritz_: sub example($x is rw) { ... }; example(3)

[11:26] <masak> bbkr: junctions, I'd say.

[11:26] <moritz_> masak: then the dispatch should fail

[11:26] <masak> moritz_: oh, indeed.

[11:26] <moritz_> masak: but modulo that, and calling it as example(my $y = 3), the problem is gone

[11:27] * moritz_ -> afk

[11:27] <masak> moritz_: right. just checking what it was you were reporting.

[11:28] <colomon> 200 strings, 77 secs

[11:31] <masak> colomon: Schlemiel, probably. http://en.wikipedia.org/wiki/Schlemiel_the_Painter's_algorithm

[11:34] <colomon> masak: interesting.  I had assumed it probably had something to do with copying the entire string at each stage of the concat.

[11:34] <masak> colomon: that's an equivalent statement of the problem.

[11:36] <pugssvn> r31511 | bbkr++ | [t/spec] tests for RT #63126 Junctions in array and hash indices dont work in Rakudo 

[11:39] *** literal joined
[11:41] *** sftp joined
[11:43] <bbkr> rakudo: map { say "$^a - $^b"}, 1..10 Z 1..10

[11:43] <p6eval> rakudo 261eb2: OUTPUT«No candidates found to invoke␤  in 'map' at line 1593:CORE.setting␤  in main program body at line 11:/tmp/b5qrcyUWOD␤»

[11:43] *** sftp left
[11:43] <colomon> rakudo: map { say "$^a - $^b"}, (1..10 Z 1..10)

[11:43] <p6eval> rakudo 261eb2:  ( no output )

[11:44] <colomon> oh, not eager

[11:44] <colomon> rakudo: (1..10 Z 1..10).map( { say "$^a - $^b"}).eager

[11:44] <p6eval> rakudo 261eb2: OUTPUT«1 - 1␤2 - 2␤3 - 3␤4 - 4␤5 - 5␤6 - 6␤7 - 7␤8 - 8␤9 - 9␤10 - 10␤»

[11:44] <masak> rakudo: for 1..10 Z 1..10 -> $a, $b { say "$a - $b" }

[11:44] <bbkr> not fixed then :)

[11:44] <p6eval> rakudo 261eb2: OUTPUT«1 - 1␤2 - 2␤3 - 3␤4 - 4␤5 - 5␤6 - 6␤7 - 7␤8 - 8␤9 - 9␤10 - 10␤»

[11:45] <masak> bbkr: what was the bug?

[11:45] *** xinming_ joined
[11:45] <bbkr> masak: http://rt.perl.org/rt3/Ticket/Display.html?id=64568

[11:46] <bbkr> rakudo: say <<:a(1)>>.perl

[11:46] <p6eval> rakudo 261eb2: OUTPUT«":a(1)"␤»

[11:47] <masak> bbkr: not so sure... infix:<,> binds tighter than infix:<Z>...

[11:47] *** xinming left
[11:48] <masak> bbkr: the error message is unfriendly, but it's essentially complaining about &map being fed just a List.

[11:48] <bbkr> then it shuld get "rejected" status?

[11:48] <masak> bbkr: as far as I can see, yes.

[11:48] <bbkr> should*

[11:48] <bbkr> masak: ok, rejecting. thanks

[11:48] <masak> bbkr++

[11:49] *** TiMBuS left
[11:49] *** TiMBuS joined
[11:50] <jnthn> There's a ticket about said error being LTA.

[11:50] <jnthn> It offers a beer to the fixer. 

[11:50] <jnthn> <- motivated

[11:51] <bbkr> rakudo: say "\c[LATIN CAPITAL LETTER A]".ord # segfault!

[11:51] <p6eval> rakudo 261eb2: OUTPUT«65␤»

[11:51] <bbkr> hmm

[11:51] <bbkr> checking HEAD

[11:52] *** sftp joined
[11:53] <masak> someone points out on friendfeed that the Rakudo Star release on July 29 is two days after (or before?) the StarCraft 2 release. http://friendfeed.com/zag/1a0a4bf9/rakudo-29-2-starcraft

[11:55] <bbkr> rakudo: sub foo(*$a) { say $a.WHAT }; foo(reverse(3, 4));

[11:55] <p6eval> rakudo 261eb2: OUTPUT«Array()␤»

[11:58] <bbkr> rakudo: say "improper collapse" if 10 < (5|25) < 20;

[11:58] <p6eval> rakudo 261eb2: OUTPUT«improper collapse␤»

[11:58] *** rv2733 joined
[11:59] <bbkr> rakudo: sub foo { fail }; sub bar { foo(); 2; CATCH { 1; } }; say bar();

[11:59] <p6eval> rakudo 261eb2: OUTPUT«Null PMC access in type()␤  in main program body at line 11:/tmp/D8viQ_pk5t␤»

[11:59] <jnthn> bbkr: Is that junction one actually wrong?

[12:00] <jnthn> 10 < 25 and 5 < 20

[12:00] <masak> jnthn: agree.

[12:00] <jnthn> And it's certainly defined as two calls to <

[12:00] <masak> bbkr: could you give the RT url?

[12:00] <jnthn> Not some kind of list infix.

[12:01] <bbkr> masak: sure, http://rt.perl.org/rt3/Ticket/Display.html?id=61676

[12:01] <masak> jnthn: it's a bit of a hybrid, I'd say. :) but your argument still holds.

[12:02] <masak> bbkr: rejected.

[12:02] <bbkr> say "impossible" if 10 < any(5,25) < 20

[12:02] <bbkr> rakudo: say "impossible" if 10 < any(5,25) < 20

[12:02] <masak> bbkr: transitive behavior does not hold when junctions are involved.

[12:02] <p6eval> rakudo 261eb2: OUTPUT«impossible␤»

[12:02] <bbkr> masak++

[12:03] <masak> junctions stubbornly refuse to do more than they were built to do :)

[12:03] <jnthn> :)

[12:04] <masak> what people often seem to expect is something like this: http://blog.woobling.org/2009/08/abstracting-ambiguity.html

[12:04] *** TiMBuS|Away joined
[12:06] <bbkr> is this: (0,1)[*..*] expected to go into infinite loop?

[12:07] <jnthn> I very much doubt it.

[12:07] <colomon> it's not supposed to, but it certainly does last time I checked.

[12:07] *** TiMBuS left
[12:08] *** envi^home joined
[12:09] <bbkr> colomon: already reporetd? if so - ticket can be merged http://rt.perl.org/rt3/Ticket/Display.html?id=61844 with this report

[12:09] <colomon> bbkr: no idea if it's reported or not.

[12:10] <bbkr> colomon: ok, i'm at 70% RT queue checking so I'll find it anyway

[12:11] *** jaldhar left
[12:12] <masak> bbkr: my hero!

[12:12] <masak> hugme: hug bbkr 

[12:12] * hugme hugs bbkr

[12:13] *** azert0x left
[12:13] <colomon> loliblogged: http://justrakudoit.wordpress.com/2010/06/30/rakudo-and-speed/

[12:14] <masak> colomon++ # nice!

[12:15] <colomon> masak++ # good link explaining the sort of performance issue we have.  :)

[12:16] <jnthn> (This relies on the $*ARGFILES patch from yesterday, making lines basically the equivalent of while () from Perl 5.)

[12:16] <jnthn> colomon: <> eated as HTML tag?

[12:16] <colomon> oh, probably.

[12:16] <jnthn> omnomnomtag

[12:18] <colomon> jnthn++ # updated

[12:18] *** ruoso joined
[12:19] <colomon> slurp is supposed to default to $*ARGFILES in the long run, isn't it?

[12:19] <masak> blog engines should have a "warning, <> symbols nommed" label on preview or something.

[12:19] <colomon> right now it doesn't even work with $*ARGFILES.

[12:22] *** szbalint left
[12:24] *** azert0x joined
[12:26] *** pmurias joined
[12:26] <pmurias> ruoso: hi

[12:26] <pmurias> sorear: ping

[12:28] *** skids joined
[12:28] <ruoso> pmurias, hi... long time no see...

[12:29] <pmurias> yes..

[12:29] <pmurias> had my last exam yesterday now will try to catch up with the GSoC

[12:30] <pmurias> ruoso: could you try installing the SMOP from the repo on your box?

[12:30] <ruoso> yes... I'll try

[12:33] *** IllvilJa joined
[12:38] <bbkr> http://rt.perl.org/rt3/Ticket/Display.html?id=68762 - does .lines on descriptor produce lazy list now?

[12:40] <masak> bbkr: sounds like a question perfectly suited for some empirical studies.

[12:40] <masak> bbkr: do you have Rakudo installed locally?

[12:40] <bbkr> yes, both Kiev and yesterday build

[12:41] <bbkr> rakudo: say 1..{$_} # checking http://rt.perl.org/rt3/Ticket/Display.html?id=68788 

[12:41] <p6eval> rakudo 261eb2:  ( no output )

[12:41] <bbkr> rakudo: say (1..{$_}).WHAT.say

[12:41] <p6eval> rakudo 261eb2: OUTPUT«Range()␤1␤»

[12:43] <bbkr> nice, aiming at <630 tickets in RT today :)

[12:44] <masak> best of luck.

[12:44] <masak> hm, autovivification isn't on in docs/ROADMAP?

[12:44] <jnthn> I thought it was?

[12:44] <masak> ah, it's among "Nice to have" as "vivification"...

[12:44] <jnthn> oh, I didn't realize it goet demoted.

[12:44] <masak> probably makes sense.

[12:45] <masak> it *will* be nice to have, but it's not a showstopper.

[12:50] <jnthn> *nod*

[12:51] <colomon> bbkr: lines is lazy now, but it might still be slow.  probably worth testing.  

[12:52] *** amkrankruleuen left
[12:53] *** kaare_ left
[12:54] <bbkr> colomon: thanks. what status should ticket have then? there is no "acceptable" speed level defined, "very slow" is too general, at which point we can reply "resolved"?

[12:57] <pugssvn> r31512 | bbkr++ | [t/spec] tests for RT #68788 segmentation fault on the "say 1..{$_}" 

[12:57] *** masonkramer_ joined
[12:57] *** masonkramer left
[12:57] *** masonkramer_ is now known as masonkramer

[12:58] <masak> bbkr: I'd just reject the ticket. but I'm known to be very unsentimental about these things, so maybe check with someone else too.

[12:59] <masak> (i.e. I often reject tickets with no clear bug description)

[12:59] <pugssvn> r31513 | pmurias++ | [STD] better error message when loading STD withought having run make 

[13:01] *** grandmoun joined
[13:03] <pugssvn> r31514 | pmurias++ | [mildew] say 1 parses 

[13:03] *** am0c left
[13:03] <bbkr> masak: I also think it should be rejected. The only precisely described issue (.lines not being lazy) is now solved.

[13:03] <masak> bbkr: nod.

[13:04] <masak> bbkr: it's worth noting, of course, that the submitter considers Rakudo to be so slow that the problem doesn't even need to be explicitly pointed out :)

[13:04] <masak> but that says more about the expectations of the submitter (and perhaps our relative tolerance) than anything else.

[13:05] *** IllvilJa left
[13:05] *** mmcleric_ joined
[13:05] *** mmcleric left
[13:05] *** mmcleric_ is now known as mmcleric

[13:12] *** plainhao joined
[13:14] *** felliott joined
[13:15] *** ive joined
[13:15] <masak> mathw: ping

[13:17] *** am0c joined
[13:18] <mathw> masak: pong

[13:18] *** gbacon joined
[13:18] <masak> "Form.pm uses a Makefile generated by the ufo script. The Makefile is included in the source tree..." nononono... :/

[13:19] <masak> see, http://github.com/mattw/form/blob/master/Makefile contains a path which likely only exists on your computer...

[13:19] <masak> 'git rm Makefile && git push origin master'

[13:19] <masak> er, and a 'git commit' in between.

[13:20] <masak> mathw: sorry I did not check this earlier. :/

[13:20] * masak thinks of ways to make the ufo README clearer on this point

[13:21] <mathw> You could mention it at all

[13:21] <mathw> Your documentation's a little too on the 'this is simple' rather than 'this is what you do' side

[13:21] <masak> mentioning it would probably help.

[13:21] * masak tries that

[13:23] <masak> mathw: so, ufo makes a Makefile that obviates the need to set PERL6LIB. this can't be done without knowing the absolute path of the project's lib/ dir.

[13:24] *** felliott left
[13:25] <mathw> Sure

[13:25] <masak> in that sense, ufo is actually replacement for Configure.pm et al, not just out to destroy them.

[13:25] <mathw> you just need to mention that this Makefile can't be distributed, and people will require ufo as a build-time dependency

[13:25] <masak> aye. ufo or pls.

[13:27] <pugssvn> r31515 | bbkr++ | [t/spec] tests for RT #74624 Any + 0.1 is a Num, not a Rat in Rakudo 

[13:28] <masak> mathw: fixed, thanks. http://github.com/masak/ufo/commit/a3a059d7119cb4c74f4dde8f45e95cfba23a483f

[13:30] <mathw> http://github.com/mattw/form/commit/a80e32c0a1ad66527aec92ac0ffcc91919fd65fa

[13:30] <masak> mathw++

[13:30] <pmichaud> good morning, #perl6

[13:30] <mathw> oh hai pmichaud

[13:31] <masak> hi pm

[13:31] <pmichaud> autovivification is "nice to have"?

[13:31] <pmichaud> that feels wrongish to me.

[13:32] <masak> it does? oh good. :)

[13:32] <mathw> isn't it a crucial part of Perl being Perl?

[13:32] <bbkr> rakudo: $_ = "test"; s/t/x/; .say;

[13:32] <pmichaud> anyway, I should have it ready shortly.

[13:32] <p6eval> rakudo aa015a: OUTPUT«test␤»

[13:32] <mathw> \o/

[13:32] <masak> ++pmichaud

[13:32] <mathw> So instead of changing it to 'essential' it can be changed to 'done', I like

[13:33] <bbkr> rakudo: $_ = "test"; $_ ~~ s/t/x/; .say;

[13:33] <p6eval> rakudo aa015a: OUTPUT«xest␤»

[13:33] <bbkr> bare s/// does not default to $_  as in P5? 

[13:33] <pmichaud> bbkr: nyi

[13:34] <masak> $ perl6 -e 'say @*ARGS.perl'

[13:34] <masak> ["-"]

[13:34] <masak> wtf?

[13:34] <masak> this must be a recent change.

[13:34] <masak> it seems to have broken ufo.

[13:34] <pmichaud> bug

[13:34] * masak submits

[13:34] <masak> I can work around it easily.

[13:34] <masak> just letting you know.

[13:34] <bbkr> rakudo: $_ = "test"; $_ ~~ tr/t/x/; .say;

[13:34] <p6eval> rakudo aa015a: OUTPUT«===SORRY!===␤Confused at line 11, near "$_ ~~ tr/t"␤»

[13:34] <pmichaud> the bug is in IO::ArgFiles

[13:34] <pmichaud> (which has quite a few bugs atm)

[13:35] <masak> good to know.

[13:37] <mathw> well no

[13:37] <mathw> bugs are bad

[13:38] <pmichaud> IO::ArgFiles needs to be much lazier about grabbing things from @*ARGS, and much more direct about manipulating @*ARGS

[13:38] <masak> mathw: they are. but having them as unknown unknowns is worse.

[13:40] <mathw> This is true

[13:40] <mathw> If they are unknown unknowns, you get like I've got at work

[13:40] <mathw> We know there's a bug somewhere... quite probably two of them... but neither makes any sense or is very obvious

[13:41] *** dakkar left
[13:41] <masak> by the way, if anyone is interested in helping with a small patch to ufo, let me know.

[13:41] <masak> there's an easy possible improvement to the 'install' target.

[13:44] <arnsholt> What kind of improvement?

[13:44] <masak> I'm preparing a small gist outlining it. hold on.

[13:46] <masak> http://gist.github.com/458666

[13:48] *** synth_ joined
[13:48] <pugssvn> r31516 | pmurias++ | [smop] fix building smop tests 

[13:49] <mberends> loliblogged: http://blogs.perl.org/users/martin_berends/2010/06/rakudo-perl-6-gets-into-databases.html

[13:50] *** synth left
[13:51] <masak> mberends++!

[13:52] <pugssvn> r31517 | bbkr++ | [t/spec] one of tests description was in double quotes which caused unwanted interpolation and broke whole test file 

[13:52] <bbkr> try.t fixed :)

[13:53] * [Coke] wonders why people reply to the RT "info" email and not the actual response.

[13:54] *** synth_ left
[13:58] *** dakkar joined
[13:59] <hejki> btw.. what's the state of sockets?

[13:59] <pmichaud> some of them are open.  others are blocked.

[13:59] <pmichaud> :-)

[14:00] <hejki> rakudo: class Vuvuzela { has $.note = "BZZzzzZZzz"; method play { while 1 { $.note.say } } }; my $vuvuzela = Vuvuzela.new(); $vuvuzela.play;

[14:00] <hejki> hehe

[14:00] <p6eval> rakudo aa015a:

[14:00] <p6eval> ..OUTPUT«BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZ…

[14:00] <hejki> i meant 'what's the state of sockets in <insert any p6 compiler here>'

[14:00] <pmichaud> iirc, rakudo has sockets, but not non-blocking sockets

[14:00] <arnsholt> masak: Umm, ufo with no arguments seems to be broken

[14:01] <masak> arnsholt: try the very latest ufo.

[14:01] <masak> just fixed it.

[14:01] <TiMBuS|Away> does parrot have non blocking sockets?

[14:01] <pmichaud> TiMBuS|Away: I don't think Parrot has non-blocking I/O, which is partially why Rakudo doesn't have it yet.

[14:02] <bbkr> rakudo: sub foo($bar:) {}; # I have no idea how this should behave

[14:02] <p6eval> rakudo aa015a:  ( no output )

[14:02] <TiMBuS|Away> is there any particular reason for this? maybe i could hack it in

[14:03] <arnsholt> masak: There's a bug in your bugfix. If @*ARGS is empty you get the usage message

[14:03] <masak> rakudo: class Vuvuzela { has $.note = "BZZzzzZZzz"; method play { loop { say $.note } } }; Vuvuzela.play

[14:03] <p6eval> rakudo aa015a: OUTPUT«Type objects are abstract and have no attributes, but you tried to access $!note␤  in 'Vuvuzela::play' at line 67␤  in main program body at line 11:/tmp/Q4TOe05JSa␤»

[14:03] <masak> oh right.

[14:03] <masak> rakudo: class Vuvuzela { has $.note = "BZZzzzZZzz"; method play { loop { say $.note } } }; Vuvuzela.new.play

[14:03] <pmichaud> TiMBuS|Away: afaik, it's just that nobody's looked at it.  It may be also blocking on some design issue.

[14:03] <TiMBuS|Away> i recall whiteknight wanted to build a big nonblocking socket solution thing on which to add blocking and scheduled and callbacked socket stuff and aaahh

[14:03] <p6eval> rakudo aa015a:

[14:03] <p6eval> ..OUTPUT«BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZZzz␤BZZzzzZ…

[14:03] <jnthn> mberends: fwiw, I'd rather see the Postgres DBD done in terms of Zavolaj rather than calling down to the Parrot hting.

[14:03] <masak> arnsholt: oh, indeed. I fixed it as if everyone has the newer Rakudo.

[14:03] <jnthn> *thing

[14:04] <masak> arnsholt: fixing fix.

[14:04] <jnthn> mberends: Then it only takes porting Zavolaj in order for FakeDBI to be useful on other backends/implementations.

[14:04] <PacoLinux> I just compiled rakudo head in a pII with 312Mb of ram and 172 Mb of swap in 868m14.925s

[14:04] <masak> arnsholt: fixed, thanks. http://github.com/masak/ufo/commit/917839a53502a2966e942582d63d67ed8b4e2afc

[14:04] <mberends> jnthn: yes, thanks for mentioning :)

[14:05] <BinGOs> masak: I call prior art! http://search.cpan.org/dist/Acme-Vuvuzela/

[14:05] <masak> BinGOs: :)

[14:05] <pmichaud> masak: *sigh*  stuff like that is why I don't like accepting known-buggy code into raudo.

[14:05] <pmichaud> *rakudo

[14:05] <pmichaud> it encourages too many incorrect workarounds.

[14:05] <hejki> BinGOs: i was inspired strongly by it

[14:06] <masak> pmichaud: agree. and this is an especially hard-to-test one.

[14:06] <pmichaud> maybe I'll just fix argfiles now.

[14:06] <BinGOs> add a fork() and you have something truely annoying.

[14:06] <masak> pmichaud: keeping high standards in this regard will only get more important as time passes and more people rely on Rakudo.

[14:06] <pmichaud> agreed

[14:06] *** plobsing joined
[14:07] <pmichaud> I'm thinking that once I get past these remaining Pm-shaped obstacles, the bulk of my time is going to be reviewing patches and saying "no, you can't apply this yet because ..."

[14:07] <masak> pmichaud: I like it when you do that, yes.

[14:07] <arnsholt> masak: I think you meant "@*ARGS > 1 && @*ARGS[0] ne '-'"

[14:07] <pmichaud> i.e., I'll morph more into a patch pumpking than a code generator

[14:07] <pmichaud> here, I'll fix argfiles now.

[14:07] <masak> arnsholt: @*arrgh!

[14:07] <pmichaud> seeing the workarounds makes me very sad.

[14:07] <arnsholt> With the || it's still a no-go

[14:08] <pmichaud> actually, I'm just going to commit a disable patch for the moment.

[14:10] <masak> arnsholt: no, && isn't it either.

[14:10] <masak> arnsholt: let me reset my brain and try again.

[14:10] <arnsholt> With && it runs with my Rakudo at least =)

[14:10] <masak> that's just because you're not passing two or more arguments.

[14:11] <pmichaud> masak:  as soon as I do "make test"  (not "make spectest")  I'll push an argfiles disable.

[14:11] *** colomon left
[14:11] *** azert0x left
[14:11] <pmichaud> you can then work from that, and hopefully avoid the workaround altogether.

[14:12] *** ash_ joined
[14:13] <masak> arnsholt: I get this now:

[14:13] <masak> elsif !(!@*ARGS || @*ARGS[0] ne '-')

[14:13] <masak> De Moivre tells me it's equal to this:

[14:13] <[Coke]> moritz_: will 'make install' always install into the local directory? ;)

[14:13] <masak> elsif @*ARGS && @*ARGS[0] eq '-'

[14:14] <masak> no, wait.

[14:14] <masak> it's right as it is. arnsholt++

[14:14] <pmichaud> well, except that it fails if someone puts '-' on the commandline explicitly.

[14:14] <dalek> rakudo: 806efc8 | pmichaud++ | src/ (2 files):

[14:14] <dalek> rakudo: Disable IO::ArgFiles for the time being, it's got bugs and is forcing people to 

[14:14] <dalek> rakudo: write incorrect workarounds.

[14:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/806efc89d42a5458b488856eabf2acce96f36a41

[14:14] <masak> I can live with that.

[14:15] <masak> in the short term.

[14:15] *** azert0x joined
[14:15] <pmichaud> with 806efc you can avoid the issue altogether -- @*ARGS is no longer getting '-' prepended to it prematurely.

[14:15] <masak> thanks. pmichaud++

[14:15] <masak> removing fix. :)

[14:16] <pmichaud> oh, but I might've broken something else.

[14:16] <bbkr> rakudo: $_ = "foo"; say .=subst(/o/, { ~$/ }, :g)

[14:16] <p6eval> rakudo aa015a: OUTPUT«fAny()Any()␤»

[14:17] <bbkr> it above output corect?

[14:17] <masak> no.

[14:18] <masak> bbkr: ~$/ should contain an 'o' in both evaluations of the closure.

[14:18] <masak> s/contain/be/

[14:18] <bbkr> masak: thanks, #66782 still not fixed

[14:18] <pmichaud> rakudo:  $_ = 'foo';  say .subst(/(o)/, { $0 })

[14:19] <p6eval> rakudo aa015a: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤  in <anon> at line 1␤  in 'Cool::subst' at line 1941:CORE.setting␤  in main program body at line 11:/tmp/pJ53NlDHLz␤»

[14:19] <pmichaud> looks like $/ isn't being set properly.

[14:19] <masak> aye.

[14:19] <jnthn>  $_ = "foo"; say .subst(/o/, { ~$/ }, :g)

[14:19] <jnthn> rakudo: $_ = "foo"; say .subst(/o/, { ~$/ }, :g)

[14:19] <p6eval> rakudo aa015a: OUTPUT«fAny()Any()␤»

[14:20] <jnthn> ah, not specific to .=

[14:20] <pmichaud> I'm not too surprised that $/ stopped working, given the recent container changes I've been making.

[14:20] <pmichaud> I am surprised that there doesn't seem to be a test that is catching it.

[14:21] <bbkr> rakudo: / <[\x10000..\xEFFFF]> /; say "alive" # testing 67122

[14:21] <p6eval> rakudo aa015a: OUTPUT«alive␤»

[14:21] <bbkr> yay

[14:21] <pmichaud> that's less "yay" than might be evident at first

[14:21] <pmichaud> it doesn't fail because <[\x10000.\xeffff]>  doesn't do anything at present :-|

[14:22] <pmichaud> afk, bbiab

[14:23] *** colomon joined
[14:23] <bbkr> rakudo: "\x[10001]" ~~ /<[\x10000..\xEFFFF]>/

[14:23] <p6eval> rakudo aa015a:  ( no output )

[14:23] <bbkr> rakudo: say "\x[10001]" ~~ /<[\x10000..\xEFFFF]>/

[14:23] <p6eval> rakudo aa015a: OUTPUT«␤»

[14:24] <bbkr> pmichaud: indeed, parses but doesn't work as expected.

[14:27] *** ash_ left
[14:34] <bbkr> rakudo: (for 1 {}).WHAT.say; # RT #70888 does not crash now, but I have doubts if it should be tested just with lives_ok or isa_ok and compare to ParrotIter (ParrotIter is not in the Spec)

[14:34] <p6eval> rakudo aa015a: OUTPUT«ParrotIter()␤»

[14:34] *** uniejo left
[14:35] *** clintongormley left
[14:36] <[Coke]> I'm pretty sure that ParrotIter shouldn't appear in the spectests.

[14:36] <colomon> +1

[14:38] *** mj41 joined
[14:39] <jnthn> oh my...are all our for loop iterations being marshalled through ParrotIter?

[14:39] <arnsholt> masak: ai forkeded ur gist

[14:40] <arnsholt> And added a patch

[14:40] <bbkr> rakudo: /[ ]/ # is this allowed in current spec? reported in 71800, previously crashing with Null PMC access, now parsing fine, but ticket says it's expected to throw "Null pattern not allowed"

[14:40] <p6eval> rakudo aa015a:  ( no output )

[14:40] <masak> arnsholt: cool, thanks!

[14:40] <arnsholt> Not sure if it's beautiful code, but it's working code at least

[14:42] <masak> rakudo: say "abcd".index("xyz") == 0

[14:42] <p6eval> rakudo aa015a: OUTPUT«Method 'Bridge' not found for invocant of class 'Failure'␤  in 'infix:<==>' at line 3203:CORE.setting␤  in main program body at line 11:/tmp/ZxB0qUmBCP␤»

[14:42] <masak> arnsholt: possible issue :)

[14:42] * masak submits rakudobug

[14:42] <arnsholt> Heh

[14:43] <masak> rakudo: Failure == 0

[14:43] <p6eval> rakudo aa015a: OUTPUT«Method 'Bridge' not found for invocant of class ''␤  in 'infix:<==>' at line 3203:CORE.setting␤  in main program body at line 11:/tmp/OiVcR_FiiT␤»

[14:43] *** plobsing left
[14:43] <arnsholt> Oh, if I'd read the doc properly I'd've seen that. Failure is 0 in numeric context

[14:43] <masak> arnsholt: I think you want to check for definedness instead.

[14:43] <arnsholt> definedness and == 0, yeah

[14:44] <masak> aye.

[14:44] <masak> in that order.

[14:44] *** pmurias left
[14:44] <arnsholt> Certainly not the other way 'round, yeah ^^

[14:44] * masak is not sure he likes .Bridge :/

[14:46] <jnthn> std:  /[ ]/ 

[14:46] <p6eval> std 31517: OUTPUT«Potential difficulties:␤  [ ] appears to be an old-school character class; horizontal whitespace should be matched with \h instead at /tmp/bqQ2RrZVf6 line 1:␤------> [32m/[ ][33m⏏[31m/[0m␤ok 00:01 111m␤»

[14:47] <TimToady> hmm

[14:48] <TimToady> I'd still expect Null pattern not allowed

[14:48] <masak> +1

[14:48] <TimToady> std: /[]/

[14:48] <p6eval> std 31517: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null pattern not allowed at /tmp/nX8i59okz3 line 1:␤------> [32m/[[33m⏏[31m]/[0m␤    expecting regex atom␤Parse failed␤FAILED 00:01 108m␤»

[14:48] <colomon> rakudo: say Failure ~~ Real

[14:49] <p6eval> rakudo 806efc: OUTPUT«1␤»

[14:49] <TimToady> std: /[  ]/

[14:49] <p6eval> std 31517: OUTPUT«ok 00:01 108m␤»

[14:49] <colomon> rakudo: say Failure ~~ Positional

[14:49] <masak> bbkr: re [perl #65904] -- I'd expect it to give an error, as I wrote in the original bug report.

[14:49] <p6eval> rakudo 806efc: OUTPUT«1␤»

[14:50] <masak> o.O

[14:50] <colomon> is Failure supposed to do every role?

[14:50] <masak> not that I know.

[14:50] <colomon> rakudo: say Failure ~~ Stringy

[14:50] <p6eval> rakudo 806efc: OUTPUT«1␤»

[14:51] <jnthn> rakudo: say Failure.^roles.perl

[14:51] <bbkr> masak: #65904 left unchanged then, thanks.

[14:51] <p6eval> rakudo 806efc: OUTPUT«()␤»

[14:51] <colomon> rakudo: role Foobar { method no-need() { say "boo!"; }; }; say Failure ~~ Foobar

[14:51] <p6eval> rakudo 806efc: OUTPUT«1␤»

[14:51] <jnthn> Oh, I wonder if this is to do with the "failure is always acceptable" thing

[14:52] <masak> bbkr: well, you wrote "I'm not sure what is expected result." -- The expected result was outlines in the ticket.

[14:52] <bbkr> rakudo: sub foo(Bool :$x) { say "works!"}; foo(:x); # #69200, where can i put tests for this one?

[14:52] <p6eval> rakudo 806efc: OUTPUT«works!␤»

[14:53] *** clintongormley joined
[14:53] <jnthn> In with the other colonpair tests maybe

[14:54] <colomon> rakudo: my $a = Failure; say +$a

[14:54] <masak> arnsholt: nice solution with the lexicographic sorting, by the way. didn't think of that.

[14:54] <p6eval> rakudo 806efc: OUTPUT«Use of uninitialized value in numeric context␤0␤»

[14:54] <masak> arnsholt: one simplification would be to ditch the gather and just $makefile.say instead of 'take'.

[14:55] <bbkr> masak: I appreciate your huge patience :) ticket was more than 1 year old and I wasn't sure if spec hasn't changed since then because it parses fine now.

[14:57] <bbkr> rakudo: sub { "hello" #`(test) }.()

[14:57] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤Confused at line 11, near "sub { \"hel"␤»

[14:58] *** JimmyZ joined
[14:59] <masak> bbkr: well, a sub still doesn't take an invocant. :P

[14:59] <jnthn> rakudo: (sub { "hello" #`(test) }).()

[14:59] <p6eval> rakudo 806efc:  ( no output )

[14:59] <jnthn> (note problem is that the #` but the .() on a sub decl without parens)

[14:59] <arnsholt> masak: Very true with the say

[14:59] * jnthn guesses maybe the ticket was about #`(...)

[15:00] <arnsholt> And thanks for the compliment. I was kinda happy with that (which is why I commented it as well =)

[15:00] *** rlb3 joined
[15:00] <bbkr> jnthn: 69012

[15:02] <masak> arnsholt: if you prepare a new diff with the proposed changes, based off the latest ufo, I'll apply it.

[15:04] <pmichaud> 14:39 <jnthn> oh my...are all our for loop iterations being marshalled through ParrotIter?

[15:04] <pmichaud> at the moment, yes.  That will change when we s/for/map/

[15:04] <[particle]> rakudo: say { "hello" #`(test) }.()

[15:04] <jnthn> pmichaud: OK

[15:04] <p6eval> rakudo 806efc: OUTPUT«hello␤»

[15:04] <jnthn> pmichaud: Heh. I guess we know that ParrotIter works reliably now. ;-)

[15:04] <pmichaud> also, ParrotIter is significantly changed from what you wrote :)

[15:05] <jnthn> Well, yes - iterators probably significantly changed too. :-)

[15:05] <pmichaud> right

[15:05] <[particle]> oh, now i see jnthn++ meant s/that/not/ above

[15:05] <jnthn> [particle]: er, yes :-)

[15:06] * pmichaud goes back to ArgFiles work

[15:06] *** ash_ joined
[15:09] * [Coke] wonders if pmichaud is darning his argfiles. # really needs a silent F there, but work with me.

[15:10] *** mberends left
[15:11] <arnsholt> Hmm. My current Rakudo dies if it can't find a prefix with index

[15:11] * arnsholt updates

[15:12] *** kensanata joined
[15:13] <pmichaud> [Coke]: right now I'm darning someone else's argfiles.

[15:13] <ash_> is the patch for argfiles being applied to master? 

[15:13] <pmichaud> when it's ready, yes.

[15:14] <ash_> oh, btw, has anyone seen cygx? I was just wondering how the try.rakudo.org backend was coming along? I wanted to see if we could start testing the frontend and backend together

[15:16] *** rlb3 left
[15:16] *** am0c left
[15:16] <masak> last seen almost exactly 48 hours ago.

[15:16] *** rlb3 joined
[15:18] <ash_> alright, well, i'll see if i can catch him later 

[15:26] <arnsholt> rakudo: my $string = "abcd"; my $prefix = "xyz"; $string.index: $prefix;

[15:26] <p6eval> rakudo 806efc:  ( no output )

[15:27] <arnsholt> Hmm. At the REPL it does

[15:29] <arnsholt> say defined "abcd".index: "xyz"

[15:29] <arnsholt> rakudo: say defined "abcd".index: "xyz"

[15:29] <p6eval> rakudo 806efc: OUTPUT«0␤»

[15:30] *** ashleydev joined
[15:35] *** justatheory joined
[15:37] *** JimmyZ left
[15:41] <Tene> http://www.tbray.org/ongoing/When/201x/2010/06/29/No-Defaults#c1277899140.235379 -- apparently, in Fortress, it's a syntax error for spacing cues to not match the actual precedence of an expression.

[15:41] *** alexbobP joined
[15:42] <alexbobP> so what's the deal with perl 6?  is it ever going to have it's own interpreter?

[15:42] <pmichaud> alexbobP: I don't understand the question.

[15:42] <masak> alexbobP: how do you mean?

[15:42] <Tene> alexbobP: I'm not quite sure what you're asking about here?

[15:42] <arnsholt> masak: Updated: http://gist.github.com/458738

[15:43] *** patspam joined
[15:43] <masak> arnsholt: thanks! will look.

[15:43] <ash_> lol 3 responses saying the same thing but different 

[15:44] <alexbobP> pmichaud: I was under the impression that, currently, perl6 exists only in the form of various modules you can import

[15:44] *** rlb3 left
[15:45] <alexbobP> pmichaud: does that mean I can't get the benefits such as strong typing and syntax changes?

[15:45] <pmichaud> alexbobP: http://perl6.org/

[15:45] *** rlb3 joined
[15:45] <pmichaud> alexbobP: http://rakudo.org/

[15:45] <alexbobP> pmichaud: thanks

[15:45] <pmichaud> Perl 6 has gone far beyond the Perl6:: modules in CPAN.

[15:46] <alexbobP> oh, so it *does* have a compiler now!

[15:46] <alexbobP> cool.

[15:46] <Tene> rakudo: class A { has Str $.msg; method frob { say $.msg; } }; my A $a .= new( :msg("Look, it works!") ); $a.frob();

[15:46] <p6eval> rakudo 806efc: OUTPUT«Look, it works!␤»

[15:46] * cxreg adds more methods to Pg

[15:46] <pmichaud> also:  http://rakudo.org/node/73

[15:49] <ash_> is blizkost specific to a version of perl5 or does it link to any perl5? 

[15:50] <jnthn> ash_: I don't know about any version.

[15:51] <jnthn> ash_: But certainly it's not too specific, afaik.

[15:51] *** macdaddy joined
[15:51] *** Ross joined
[15:51] *** macdaddy is now known as Guest80095

[15:51] *** mmcleric left
[15:52] <ash_> cool, so it would work with either 5.10 or 5.12 (i guess thats the more direct question i should ask) 

[15:53] <masak> alexbobP: yes. that's why people were a bit confused at your initial question. :)

[15:53] <jnthn> ash_: afaik.

[15:53] <pmichaud> alexbobP: you might also be interested in http://perl6advent.wordpress.com/2009/12/01/

[15:53] <jnthn> ash_: Most important is you have the libperl or whatever it's called

[15:53] <pmichaud> (perl6advent isn't listed on perl.org?)

[15:53] <alexbobP> masak: I see XD

[15:54] <masak> arnsholt: applied; pushed. thanks! arnsholt++

[15:54] <arnsholt> Cool!

[15:54] <alexbobP> masak: I knew that it was just the perl6 cpan module a long time ago, and I hadn't heard anything since, so I just didn't know about this development

[15:54] <alexbobP> this makes me happy

[15:54] <alexbobP> pmichaud: I'll check it out

[15:54] <masak> alexbobP: there was a big project called Pugs already in 2005.

[15:54] <[Coke]> alexbobP: is there a place we could have been talking about it that we missed?

[15:55] <alexbobP> [Coke]: yeah dude, it's all your fault

[15:55] <alexbobP> you guys weren't on the ball with notifying me!  sheesh XD

[15:56] <alexbobP> I think there's a rule somewhere that alexbobP has to be notified of all cool new things.  I suppose you didn't bother to look where that rule was.  ;)

[15:56] <[Coke]> heh. I'm just wondering if there's some marketing opportunity we missed. we're not very good at that sort of thing. =-)

[15:56] <masak> alexbobP: next time we'll spam you sooner. :P

[15:56] <pmichaud> alexbobP: we're curious where you would have expected to hear more about Perl 6 (that we've obviously missed for 3+ years)

[15:56] <[Coke]> alexbobP: share and enjoy.

[15:56] <alexbobP> yeah I dunno

[15:56] <pmichaud> I phrased that wrong.  :)

[15:56] <alexbobP> I didn't really have my feelers out

[15:56] <alexbobP> I could have googled "perl 6" and found all this

[15:57] <pmichaud> alexbobP: no problem.  Glad we were able to surprise you today.  :)

[15:57] <alexbobP> but I didn't :P

[15:57] <alexbobP> pmichaud: me too.

[15:57] <[Coke]> hokay. if you have any good marketing ideas, you're obligated to share them now. ^_^

[15:57] <[Coke]> er, going forward.

[15:57] <alexbobP> okay, how about a "why perl 6 whomps python" page

[15:57] * masak .oO( Mention Perl 6 at next Superbowl )

[15:57] <alexbobP> python's all the rage

[15:57] <alexbobP> so we gotta beat it, right?

[15:57] <masak> alexbobP: nah :)

[15:57] <cuppe> can't we all just get along

[15:58] <alexbobP> ubuntu didn't get on desktop computers by being all "who wants to use this software you've never heard of"

[15:58] <alexbobP> it's all about the "we can do everything windows can do and better"

[15:58] <cxreg> how do you spell before/after/around like in Moose?

[15:58] <masak> cxreg: callsame/nextsame

[15:58] <pmichaud> we're not really far enough along to talk about "why perl6 whomps python".

[15:58] <masak> cxreg: see S06.

[15:58] <cxreg> masak: ok thanks

[15:59] <pmichaud> because the first retort will be "python is 100x faster than perl6"  :-)

[15:59] <alexbobP> haha aww

[15:59] <alexbobP> (so we're still faster than ruby, right?)

[15:59] <masak> only 100x? :P

[15:59] <pmichaud> sometimes.

[15:59] <pmichaud> rakudo is still painfully slow.

[15:59] *** cdarroch joined
[15:59] *** cdarroch left
[15:59] *** cdarroch joined
[15:59] <pmichaud> (we're working on it.)

[15:59] <masak> alexbobP: as soon as you try Rakudo, you'll notice that it's... slightly speed-impaired.

[16:00] <pmichaud> s/slightly//

[16:00] *** colomon left
[16:00] <masak> alexbobP: but that's OK, because we tend to think it's cool to be the first to be using Perl 6 features as they come online.

[16:00] <alexbobP> masak: right.  Well I won't be doing that for work XD

[16:00] <alexbobP> but I'll try it in my spare time!

[16:00] <masak> \o/

[16:01] <masak> alexbobP: that's about what we want to hear right now.

[16:01] <masak> alexbobP: want to see a few cool things in Perl 6? :)

[16:01] <[Coke]> I think partcl is about 160X slower than tclsh8.5

[16:02] <[Coke]> er, partcl-nqp.

[16:02] <alexbobP> masak: sure.

[16:02] <masak> rakudo: .say for grep { $_ % all 2..$_/2 }, 2..* # print all primes, forever

[16:02] <p6eval> rakudo 806efc: OUTPUT«2␤3␤5␤7␤11␤13␤17␤19␤23␤29␤31␤37␤41␤43␤47␤»

[16:02] <alexbobP> lol, "␤"

[16:02] <masak> rakudo: class Vuvuzela { method play { say "BZZZZ!" } }; Vuvuzela.new.play # easy-to-use OO

[16:02] <p6eval> rakudo 806efc: OUTPUT«BZZZZ!␤»

[16:02] <alexbobP> XD

[16:03] <ash_> lol @vuvuzela

[16:03] <arnsholt> alexbobP: Perl 6 supports  Unicode, and we're not afraid to use it =)

[16:03] <alexbobP> rakudo: Vuvuzela.new.play

[16:03] <p6eval> rakudo 806efc: OUTPUT«Could not find sub &Vuvuzela␤  in main program body at line 11:/tmp/K4W9KgOTwq␤»

[16:03] <alexbobP> I guess the class doesn't stick around?

[16:03] <diakopter> rakudo: class Vuvuzela { method play { say "BZZZZ!" } }; Vuvuzela.play

[16:03] <p6eval> rakudo 806efc: OUTPUT«BZZZZ!␤»

[16:03] <masak> alexbobP: no, new session each time.

[16:03] <ash_> pugs: class Vuvuzela { method play { say "BZZZZ!" } }; Vuvuzela.new.play # old school perl6

[16:03] <p6eval> pugs: OUTPUT«BZZZZ!␤»

[16:03] <masak> rakudo: say [<=] 3, 4, 4, 5, 5, 6, 8; # look at that operator! it means "is the list sorted non-decreasing?"

[16:03] <p6eval> rakudo 806efc: OUTPUT«1␤»

[16:04] <cxreg> masak: A method named 'AutoCommit' already exists in class 'FakeDBD;Pg;Connection'. It may have been supplied by a role.

[16:04] <cxreg> that was from "my proto method AutoCommit"

[16:04] <masak> cxreg: moritz_ reported something similar the other day.

[16:04] <masak> (to RT)

[16:04] <cxreg> masak: ok, so i'm doing the right thing, it just dont work yet?

[16:05] <masak> cxreg: hard to say without a nopaste.

[16:05] <masak> how could I guarantee you're doing the right thing? :P

[16:05] <cxreg> psych(ic|osis)

[16:05] <masak> :)

[16:05] *** patspam1 joined
[16:05] *** patspam left
[16:05] *** patspam1 is now known as patspam

[16:06] <masak> cxreg: I seem to be mistaken, it was another proto-related bug that moritz_ submitted.

[16:06] <masak> cxreg: feel free to submit yours, with adequate means to replicate it.

[16:06] <cxreg> masak: my main question is, are you expected to be able to supply a proto method for a generated accessor

[16:06] <masak> hm.

[16:06] <masak> what's your goal here?

[16:06] <cxreg> to "tie" AutoCommit

[16:07] <masak> ooh, naughty.

[16:07] <masak> yeah, I'd expect that to fail. :)

[16:07] <cxreg> :(

[16:07] <pmichaud> I love it when a fix causes the source to become 50% shorter.  :-)

[16:07] <masak> (because no-one's tried it before)

[16:07] <cxreg> masak: heh.

[16:08] <masak> rakudo: class A { has $.b; proto method b {} }

[16:08] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤A method named 'b' already exists in class 'A'. It may have been supplied by a role.␤»

[16:08] <masak> cxreg: that's your error, right?

[16:08] <cxreg> right

[16:09] <masak> I don't think I've seen this addressed in S12.

[16:09] <masak> and I know TimToady has been thinking about multi methods recently-ish.

[16:09] <moritz_> putting the proto first should make it work

[16:09] *** Guest23195 joined
[16:09] <cxreg> moritz_: before the accessor declaration?

[16:09] <masak> rakudo: class A { proto method b {}l has $.b  }

[16:09] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 11␤»

[16:09] <masak> oops.

[16:10] <masak> rakudo: class A { proto method b {}; has $.b }

[16:10] <moritz_> s/l/;/

[16:10] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤A method named 'b' already exists in class 'A'. It may have been supplied by a role.␤»

[16:10] *** meppl joined
[16:10] <moritz_> accessor generation doesn't honor protos. That's a bug

[16:10] <ash_> rakudo: class A { proto method b {}; has $!b } 

[16:10] <p6eval> rakudo 806efc:  ( no output )

[16:10] * cxreg puts some toothpaste in the hole

[16:10] * masak submits rakudobug

[16:11] <ash_> granted that doesn't mean the same thing...

[16:11] *** Su-Shee left
[16:13] <masak> swimming &

[16:13] *** rlb3 left
[16:14] *** masak left
[16:14] *** rlb3 joined
[16:14] <cxreg> ash_: that might be an ok solution for now though, since it can just do the setting

[16:19] <ash_> rakudo: class A { multi method b {}; has $.b }

[16:19] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤A method named 'b' already exists in class 'A'. It may have been supplied by a role.␤»

[16:19] <ash_> should that work? 

[16:19] <ash_> rakudo: class A { method b {}; has $.b }

[16:19] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤A method named 'b' already exists in class 'A'. It may have been supplied by a role.␤»

[16:20] <pmichaud> iirc, yes, you should be able to define a method and have it suppress the automatically generated one

[16:20] <pmichaud> but if you're defining a method, you probably don't need to be using $.  

[16:21] <ash_> yeah, i know, you'd probably just want to $! the variable, but i was wondering if it should die because you made a method with the same name (or even a multi with the same name) 

[16:21] <ash_> rakudo: class A { multi method b($) {}; has $.b } 

[16:21] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤A method named 'b' already exists in class 'A'. It may have been supplied by a role.␤»

[16:21] <pmichaud> ash_: iiuc, it's not supposed to die.

[16:22] <jnthn> I think it's not meant to either.

[16:23] <jnthn> I thought Attribute.nqp's compose method even had logic to check if a method was already defined.

[16:23] <ash_> that last one, should that make a mutli out of b? (so if you did .b it would call the normal accessor, and .b($scalar) would call the multi?) 

[16:23] <jnthn> Hmm...maybe.

[16:23] <pmichaud> ash_: I'm pretty sure that if you define any method you don't get an automatically generated one.

[16:23] <jnthn> What pmichaud++ just proposed is far simpler though ;-)

[16:24] <ash_> kk, just curious 

[16:24] <pmichaud> I have been wrong many times before about such things, though.  :)

[16:24] <pmichaud> I'm wrong.

[16:25] <pmichaud> S12:  "You may write your own accessors to override any or all of the

[16:25] <pmichaud> autogenerated ones.

[16:25] <jnthn> "any or all"

[16:25] <pmichaud> Yes.

[16:25] <ash_> so, the multi would add one, not override? (since the signatures differe) 

[16:25] <ash_> differ* 

[16:25] <jnthn> Thing htat's any or all of the auto-genrated ones though (accross all attributes)

[16:25] <jnthn> And maybe not a reference to multis.

[16:26] <pmichaud> oh, that could be.

[16:26] <jnthn> omg my typing!

[16:26] <pmichaud> that's a bit ambiguous :)

[16:26] <jnthn> *think, that's

[16:26] <pmichaud> jnthn: yes, I think you're right.

[16:26] <pmichaud> since the earlier packages talk about "the autogenerated accessor", that implies there's only one.

[16:27] <jnthn> *nod*

[16:27] <pmichaud> I'd prefer that paragraph I quoted above to say  "You may write your own accessors to suppress the autogenerated ones."

[16:27] <pmichaud> as opposed to "override".

[16:27] <pmichaud> unless we assume the autogenerated ones always exist, and we are indeed overriding.

[16:27] <ash_> any or all, so $. makes a accessor, but $.a is rw; makes an accessor and assigner(??) so is that the only case you'd have more than 1 auto generated function? 

[16:27] <jnthn> I think suppress would be a better word, yes.

[16:28] <jnthn> ash_: no, it's still making one thingy

[16:28] <jnthn> ash_: with "is rw" it's just an lvalue thing.

[16:28] <pmichaud> ash_: "is rw"  just means the accessor is also "is rw"

[16:29] <cxreg> pmichaud: my goal was to leave the accessor, but supply a proto too

[16:29] <pmichaud> cxreg: right.  The spec is a bit ambiguous here.

[16:29] <pmichaud> cxreg: If we assume that any same-named method suppresses the accessor, then you'd have to write your own accessor.

[16:30] <[particle]> if you don't supply proto or multi, it assumes only, no?

[16:30] <ash_> yeah, it sounds like we should ask for clarification on this one 

[16:30] <pmichaud> anyway, in the meantime I suggest using  $!b   and explicitly providing the methods you want.  :)

[16:30] <cxreg> pmichaud: i'm such a troublemaker :)

[16:30] <pmichaud> cxreg: we all are.

[16:32] <moritz_> hugme: tweet rakudoperl current state of #perl6 database access with #rakudo: http://tinyurl.com/p6db-blog

[16:32] * hugme hugs moritz_; tweet delivered

[16:35] *** TiMBuS|Away left
[16:35] *** rlb3 left
[16:36] <pmichaud> I have to run for a bit, so I'm pushing my IO::ArgFiles patch without a full spectest.  ("No!  Bad pumpking!")   I'll spectest in about 30, feel free to revert if I've broken anything.

[16:36] <pmichaud> bbi30

[16:38] *** colomon joined
[16:39] <dalek> rakudo: 8e7bf30 | pmichaud++ | src/core/IO.pm:

[16:39] <dalek> rakudo: Add IO.open to allow attaching an existing IO object to a file.  Also now 

[16:39] <dalek> rakudo: understands "-" as a filename meaning "standard input".

[16:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8e7bf30c109b8ee58dd52f37943865584cfb3bda

[16:39] <dalek> rakudo: 7df2c27 | pmichaud++ | src/ (2 files):

[16:39] <dalek> rakudo: Refactor IO::ArgFiles.

[16:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7df2c274aff5633f30ecb8c216aeb8793d47e900

[16:40] <moritz_> pmichaud: $*ARGFILES understood - as meaning $*IN already

[16:40] *** dakkar left
[16:43] <moritz_> oh

[16:43] <moritz_> now open() does

[16:43] <moritz_> I wonder if that's a security risk or not

[16:45] *** ruoso left
[16:45] <jnthn> hmm

[16:45] <jnthn> Yeah, I thought open wasn't going to have the "magical" chars like in Perl 5...

[16:46] <moritz_> maybe we should have a named argument that does magic for convenience

[16:46] <moritz_> speaking of perl 5 oddities...

[16:46] <moritz_> perl -pe '' '| echo "pwnd"'

[16:46] <moritz_> pwnd

[16:47] <moritz_> -p uses magic <>

[16:47] <moritz_> which interprets shell meta characters

[16:53] *** tadzik left
[16:54] <pmichaud> I was just copying the p5 semantics; didn't see anything that claimed p6 was different in this respect.

[16:55] * pmichaud runs 'make spectest' to validate his push.

[16:55] <moritz_> well, perl 6 open() is more like perl 5's 3-argument open

[16:57] <pmichaud> anyway, I'm fine if we need to patch .open() -- getting ArgFiles to work was my primary goal here.

[16:58] *** amkrankruleuen joined
[16:58] <pmichaud> also, I like that ArgFiles can be attached to any array, not just $*ARGS

[16:58] <amkrankruleuen> Hello.

[16:59] <pmichaud> my $handle = IO::ArgFiles.new(:args['a', 'c', 'x']);   # read from 'a', then 'c', then 'x'

[17:00] <pmichaud> rakudo:  say $*IN.get;

[17:00] <p6eval> rakudo 806efc: OUTPUT«Land der Berge, Land am Strome,␤»

[17:01] <pmichaud> rakudo:  say $*ARGFILES.get;

[17:01] <p6eval> rakudo 806efc: OUTPUT«Method 'get' not found for invocant of class 'Failure'␤  in main program body at line 11:/tmp/OsQyDHIYkj␤»

[17:01] <pmichaud> ah, I think that @*ARGS and $*ARGFILES initialization is in the wrong place.  ;-(

[17:01] <moritz_> works locally here

[17:02] <pmichaud> for some reason it's in UNIT_START -- needs to be much more global than that.

[17:02] <pmichaud> fails in the repl

[17:02] <pmichaud> which is probably why it fails in p6eval

[17:03] <colomon> can somebody reply to this?  http://justrakudoit.wordpress.com/2010/06/30/rakudo-and-speed/#comments

[17:03] <bbkr> how this should work? can i use $*ARGFILES.lines to get lines of all file names given in ARGS?

[17:03] <colomon> (I'm in the middle of trying to get a release out for $work)

[17:03] <pmichaud> bbkr: yes.

[17:03] <bbkr> pmichaud: awesome, more dataprocessing power

[17:03] <pmichaud> and   lines()  is supposed to be a shortcut for $*ARGFILES.lines

[17:04] *** cygx joined
[17:04] <pmichaud> (replaces the p5 <> operator)

[17:04] *** thebird left
[17:04] <frettled> pmichaud: ooh, that's nice

[17:05] <moritz_> rakudo: say lines().elems

[17:05] <bbkr> pmichaud: even more awesome. will it accept ranges as well? "lines(1, 2, 32..45, 78 ..*)" ?

[17:05] <p6eval> rakudo 806efc: OUTPUT«No applicable candidates found to dispatch to for 'lines'. Available candidates are:␤:(IO $filehandle, Any :bin($bin) = { ... }, Any :enc($enc) = { ... }, Any :nl($nl) = { ... }, Any :chomp($chomp) = { ... })␤:(Str $filename, Any $limit = { ... })␤␤  in main program body at

[17:05] <p6eval> ..line 11…

[17:06] <moritz_> also works locally here

[17:06] <pmichaud> right

[17:06] *** patspam left
[17:06] *** patspam1 joined
[17:06] <pmichaud> the problem is that @*ARGS and $*ARGFILES aren't being initialized at the proper time for the repls

[17:06] *** patspam1 is now known as patspam

[17:06] <pmichaud> bbkr: lines[1, 2, 32..45, 78..*]   # maybe

[17:09] *** justatheory left
[17:10] <jnthn> rakudo: say $*IN.lines[0,2,4....*]

[17:10] <p6eval> rakudo 806efc: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 11␤»

[17:10] <bbkr> rakudo: sub foo { return 1,2,3}; say foo[0,2]; # just checking if sub output can be indexed without .

[17:10] <p6eval> rakudo 806efc: OUTPUT«13␤»

[17:10] <jnthn> rakudo: say $*IN.lines[0,2,4...*]

[17:10] <jnthn> rakudo: say $*IN.lines[0,2,4...100]

[17:11] <p6eval> rakudo 806efc:  ( no output )

[17:11] <p6eval> rakudo 806efc: OUTPUT«Land der Berge, Land am Strome,Land der Hämmer, zukunftsreich!Volk, begnadet für das Schöne,vielgerühmtes Österreich!Heiß umfehdet, wild umstritteneinem starken Herzen gleich.hoher Sendung Last getragen,vielgeprüftes Österreich!Mutig in die neuen Zeiten,arbeitsfroh und

[17:11] <p6eval> ..hoffnungsrei…

[17:11] <jnthn> heh :-)

[17:11] <pmichaud> hint:  try a range, not a series.

[17:11] <colomon> jnthn: for sure infinite series are never going to work in [ ], are they?

[17:11] <jnthn> pmichaud: I wanted every other line. ;-)

[17:11] <jnthn> colomon: No, I think not. :-)

[17:11] <colomon> pmichaud: does range work now?

[17:11] <jnthn> colomon: I realized that rihgt after typing it. :-)

[17:11] <colomon> rakudo

[17:11] <colomon> rakudo: my @a = 1, 2, 3; say @a[1..*]

[17:11] *** kensanata left
[17:12] <pmichaud> colomon: no, it probably doesn't work yet either.

[17:12] <p6eval> rakudo 806efc:  ( no output )

[17:12] <colomon> drat.  I was hoping someone had fixed that and I hadn't noticed.

[17:12] <cygx> moritz_: I just wanted to mention that I'm still on track with try.rakudo.org - I might actually get a (somewhat) working prototype done as early as tomorrow, but barring major disasters definitely this week

[17:12] <phenny> cygx: 28 Jun 17:51Z <ash_> tell cygx how is the backend going? Is there anyway I could start testing any of it with the backend? I can run it on my server, also i don't mind if some of the responses are faked for now

[17:14] <ash_> cygx: could you not use a cookie to store the session ID instead of putting it into the template? (it requires less parsing, and no special template variables) 

[17:15] <cygx> ash_: sure, could be easily done; but the problem is that I wanted to allow multiple different sessions from the same client

[17:16] <cygx> ash_: for now, just put __RAKUDO_SHELL__ID__ anywhere you want the id to appear

[17:16] <ash_> alright, can do

[17:17] *** patspam left
[17:18] <cygx> I also did some major re-thinking of the backend design, and I think I figured out a way to do it that would work in Rakudo; I'll do it in Perl5 for now so that I can re-use code from the frontend

[17:18] <cygx> I don't think porting the frontend is feasible as long as there's no mod_rakudo for Apache, though (startup times :()

[17:18] *** envi^home left
[17:19] <ash_> but there is a mod_parrot 

[17:19] <ash_> (which can load rakudo) 

[17:19] <ash_> http://www.parrot.org/mod_parrot

[17:19] <cygx> last I looked, mod_parrot was seariously out-of-date...

[17:19] <ash_> ah

[17:19] <ash_> i haven't tried it, i just know someone started it at one point

[17:23] *** Cyrus joined
[17:26] <ash_> cygx: is it okay to get the results via javascript? 

[17:28] <cygx> ash_: sure; the idea is to use long polling to have a persistent connection to the server so new output can be passed along as soon as it's ready

[17:29] <alexbobP> long polling?

[17:29] <alexbobP> is that when the server holds up the connection as long as possible when there's no data

[17:29] <alexbobP> and the client reconnects as soon as a connection breaks?

[17:29] <ash_> yea

[17:30] <alexbobP> I did that in second life once for a script that was accessing web data

[17:30] <cygx> alexbobP: http://en.wikipedia.org/wiki/Comet_%28programming%29#Ajax_with_long_polling

[17:30] <alexbobP> I found that connections from their servers would time out after, like, 30 seconds, so I made a php script that holds for up to 25 seconds before sending back emptiness

[17:32] <alexbobP> had no idea that it had a name at the time :P

[17:32] <cygx> alexbobP: imo the most elegant solutionimo would be a chunked XHR, which is basically only supported by firefox :(

[17:32] <cygx> *solution

[17:32] <alexbobP> cygx: what's that?

[17:33] <ash_> if everyone had a modern browser i'd say use a websocket 

[17:33] *** pyrimidine joined
[17:33] <ash_> but not everyone has an html5 browser

[17:34] <huf> that's a constant

[17:34] <huf> at least, as long as the web is evolving, "not everyone has a modern browser" will remain true

[17:34] <cygx> alexbobP: http supports partial transfer using chunks; you'll get this if you call flush() fromn php but the problem is that the client-side code won't trigger apropriate events in most browsers

[17:34] <alexbobP> cygx: ah, I see

[17:34] <[particle]> if the web stops changing, we'll all upgrade our browsers?

[17:35] <cygx> before AJAX was around, web developers would use hidden iframes and chunked transfer to get persistent connections

[17:35] <cygx> I prefer long polling because it's cleaner, imo

[17:35] <alexbobP> http is a protocol designed for fetching existing pieces of data, that's the issue

[17:35] <ash_> cygx: gmail still uses that trick 

[17:35] <moritz_> cygx++ # try.rakudo.org hacking

[17:35] <alexbobP> we will be doing hacks (like reconnecting after getting the chunk) until there is a new protocol that works right

[17:36] <alexbobP> cygx: chunked transfer sounds like it's a subset of long polling, since you're still holding a connection open

[17:36] <cygx> moritz_: could you see if IO::Pty::HalfDuplex works on the intended server - couldn't get it to work on the *nix box I have access to :(

[17:36] <ash_> WebSocket is the new protocol to solve that problem in a standard way, till then you need long polling, a hidden iframe, or javascript comet

[17:37] <pugssvn> r31518 | moritz++ | [t/spec] switch reduce.t to planless testing (last patch forgot to update its plan) 

[17:37] <moritz_> cygx: will try

[17:37] <cuppe> rakudo: say first {/B/ and !/F/}, "BED" # is this supposed to work?

[17:37] <cygx> ash_: comet is the generic  term for the various techniques like log polling/chunked transfer and not a seperate thing ;)

[17:37] <p6eval> rakudo 7df2c2: OUTPUT«Method 'match' not found for invocant of class ''␤  in 'Regex::Bool' at line 5186:CORE.setting␤  in 'prefix:<!>' at line 351:CORE.setting␤  in <anon> at line 11:/tmp/LnI9T39R9M␤  in 'Block::ACCEPTS' at line 5129:CORE.setting␤  in 'infix:<~~>' at line 322:CORE.setting␤  in

[17:37] <p6eval> ..'Any::fir…

[17:40] <moritz_> cygx: at least all tests pass

[17:41] <moritz_> cygx: do you need any more testing than that?

[17:41] <cygx> moritz_: that's good to hear, but I still need to find a machine I can develop on :(

[17:41] <moritz_> cygx: I can give you an account there

[17:42] <cygx> moritz_: that would be easiest for me, please do

[17:42] <pmichaud> cuppe: yes, that should probably work.  I suspect an error in Regex::Bool

[17:43] <cuppe> works if you change first to grep

[17:43] <cuppe> rakudo: say grep {/B/ and !/F/}, "BED"

[17:43] *** ashleydev left
[17:43] <p6eval> rakudo 7df2c2:  ( no output )

[17:43] <cuppe> yeah

[17:44] <ash_> hmmm cygx i setup my server on my computer (running locally) and its not giving any response back, is there some way i can test that my computer is working right? 

[17:44] <pmichaud> shouldn't that have said "BED"?

[17:44] <moritz_> it should have

[17:44] <pmichaud> I still get the error here locally.

[17:44] <ash_> err, the try.rakudo.org code is running on my computer, thats what i mean 

[17:44] <pugssvn> r31519 | moritz++ | [t/spec] un-TODO a passing test for rakudo 

[17:45] <cygx> ash_: the code in the repository is somewhat... incomplete ;)

[17:45] <pmichaud> it's the prefix:<!> that is causing problems.

[17:45] <ash_> alright, i just wanted to start integrating my code with yours 

[17:45] <cuppe> pmichaud: yeah I noticed it was the ! specifically. with grep I don't get the error, it's just silent

[17:45] <pmichaud> I get the error with grep also.

[17:46] <cygx> ash_: I basically scrapped the old code once I decided on how to do the backend so that I could re-use the frontend code

[17:46] <cuppe> weird, I don't. my version is just a few days old

[17:47] <pmichaud> .....and the problem is that   prefix:<!> is introducing a new context that has a $_ that isn't the $_ we want to match.

[17:47] <moritz_> why does it introduce a new context?

[17:48] <pmichaud> every block has its own $_

[17:48] <pmichaud> and prefix:<!> is defined as

[17:48] <ash_> cygx: we should come up with an api for our communication that we both follow, like input requests go to /send?id=sesison_id with X data, and Y expected result 

[17:48] <pmichaud>     our multi prefix:<!>(Mu $a) { $a.Bool ?? False !! True;

[17:48] <pmichaud> }

[17:48] <pmichaud> so when the regex ($a) gets .Bool invoke on it, it's currently doing a contextual find for $_ and getting the one from prefix;<!>

[17:48] <colomon> ooooo

[17:48] <moritz_> but that evaluates $a in the original context, no?

[17:49] <moritz_> at least it should

[17:49] <pmichaud> not if  $a.Bool  is using a contextual

[17:49] <pmichaud> (which it is)

[17:49] <colomon> $a in the original context is a regex

[17:49] <pmichaud> $a *is* a regex

[17:49] <pmichaud> that's not the problem

[17:49] <pmichaud> the problem is that Regex.Bool  does a contextual lookup of $_

[17:49] <moritz_> ah

[17:49] <pmichaud> I guess it needs to do an outer lookup instead

[17:50] <moritz_> right

[17:50] <pmichaud> but *that's* going to cause some issues also.

[17:50] <colomon> special version of prefix:<!> which takes a regex?

[17:50] <colomon> would that work?

[17:50] <[Coke]> (mod_parrot) could use some love. I can put you in touch with the author if you like.

[17:50] <pmichaud> colomon: not really.

[17:50] <PerlJam> Is lift implemented?

[17:50] <moritz_> colomon: sounds more like a workaround, not like a solution

[17:51] <moritz_> PerlJam: no

[17:51] <pmichaud> colomon: I think we have to fix Regex.Bool, not the operators that enforce boolean context.

[17:51] <pmichaud> it's more a question of

[17:51] <pmichaud> my $regex = /.../;

[17:51] <ash_> [Coke]: that would be cool, especially if it came out around Rakudo*, it might be nice to have another toy in the * toolbox 

[17:51] <pmichaud>    {   if $regex .... }

[17:51] <pmichaud> do we use the $_ from the block in which the regex was defined, or the one in which it was evaluated?

[17:52] <[Coke]> ash_: it's jhorwitz - if you want an intro, ping me at [email@hidden.address] and I'll forward intros.

[17:52] <PerlJam> pmichaud: the latter surely.

[17:52] <pmichaud> PerlJam: in which case it's dynamic, not lexical.

[17:52] <lue> ohai o/

[17:52] <pmichaud> and    prefix:<!>($regex)   would be evaluating $regex inside of the code for prefix:<!>

[17:53] <pmichaud> the same problem exists for prefix:<?> btw

[17:53] <pmichaud> say grep {/B/}, "BED"

[17:53] <pmichaud> rakudo: say grep {/B/}, "BED"

[17:53] <p6eval> rakudo 7df2c2: OUTPUT«BED␤»

[17:54] <pmichaud> rakudo: say grep {?/B/}, "BED"

[17:54] <p6eval> rakudo 7df2c2:  ( no output )

[17:55] <cygx> ash_: there already is an api in place, at least for sending input; how output is returned is not implemented yet because I first implemented the non-JS version

[17:55] <cygx> ash_: I'll write it up for you when I upload my current version later today

[17:55] *** davidfetter joined
[17:55] <davidfetter> !fakedbi

[17:56] <davidfetter> no info bot?

[17:56] <pmichaud> no info bot.

[17:56] <cygx> ash_: basically, you send a POST to /send?<session-id> and get different HTTP status codes depending on the backend state

[17:58] *** justatheory joined
[18:00] <pmichaud> I'm not even certain that 'lift' truly helps in this case.

[18:02] <lue> rakudo: say ("hi" andthen 0 andthen "hiagain")

[18:02] <p6eval> rakudo 7df2c2: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤»

[18:02] <pmichaud> huh?

[18:02] <pmichaud> that's.... weird.

[18:03] <lue> hrm, I guess andthen and orelse are still NYI.

[18:03] <pmichaud> we can at least warn about them.

[18:03] <lue> pmichaud: I agree, weird error.

[18:04] <PerlJam> weird that it's parsed as postcircumfix

[18:04] <PerlJam> (or attempted to parse)

[18:04] <lue> would andthen and orelse be defined in Grammar.pm?

[18:05] <pmichaud> lue: I think so -- check STD.pm6

[18:05] * lue checks

[18:06] <lue> because it isn't, BTW.

[18:06] <pmichaud> right, I'm sure it isn't currently defined.

[18:06] <pmichaud> We should define them in Grammar.pm and then have them fail.

[18:08] <lue> From STD.pm6 (only occurence of andthen):

[18:08] <lue>     token infix:sym<andthen>

[18:08] <lue>         { <sym> <O(|%loose_and)> }

[18:08] <lue> so yes, it should be defined (/me defining)

[18:09] <[Coke]> is there a difference between  foo( :name('bar') ) and foo( :name<bar> ) ? both variants are used in the Actions.pm for rakudo, it seems.

[18:10] <pmichaud> there's no difference for that case

[18:10] <PerlJam> [Coke]: syntax :)

[18:10] <pmichaud> but  :name<one two>  is the same as  :name(['one', 'two'])   and not  :name('one two')

[18:11] <[Coke]> pmichaud: might be worth going through the code base and picking one type, neh?

[18:11] <lue> hrm, any place I can get the different pasttypes? (all the and/or stuff has them)

[18:11] <[Coke]> lue: in parrot, src/compiler/pct/src/PAST/Node.pir

[18:11] <pmichaud> [Coke]: might be.  I don't see it as an important sort of consistency.

[18:11] *** clintongormley left
[18:12] <pmichaud> lue: don't try to associate a pasttype with it -- there isn't one.

[18:12] <lue> ah, ok.

[18:12] <pmichaud> for now it will just have to fail.

[18:13] <[Coke]> pmichaud: I'm the sort of guy that will go through p5 code and insure that we use '' everywhere we can. =-)

[18:15] <[particle]> instead of letting Perl::Critic do that for you?

[18:15] <PerlJam> [particle]: Perl::Critic groks NQP?

[18:15] <PerlJam> oh, he did say p5 code

[18:16] <[Coke]> [particle]: Perl::Critic does not, last I played it with, edit the code.

[18:17] <sorear> hello #perl6

[18:18] <sorear> phenny: tell pmurias pong.

[18:18] <phenny> sorear: I'll pass that on when pmurias is around.

[18:22] <sorear> hey, it's alexbobP

[18:23] *** mberends joined
[18:23] *** sftp left
[18:23] <lue> where would I define andthen and orelse so it could fail? (after defining in Grammar.pm, still gives the circumfix err)

[18:24] <colomon> does qqx{ } not work yet in master?

[18:24] *** supernovus joined
[18:24] <moritz_> rakudo: say qqx/ echo { 2 + 3 } /

[18:24] <p6eval> rakudo 7df2c2: OUTPUT«operation not permitted in safe mode␤  in <anon> at line 1:/tmp/1DQPik5SJC␤  in main program body at line 11:/tmp/1DQPik5SJC␤»

[18:24] <colomon> that actually seems promising...

[18:24] <moritz_> works, yes

[18:25] <pmichaud> works locally

[18:25] *** sorear sets mode: +oo colomon mberends

[18:25] <colomon> I'm trying to debug a $work script which worked fine under master.

[18:25] <colomon> gives me 

[18:25] <colomon> maximum recursion depth exceeded

[18:25] <colomon>   in 'postcircumfix:<{ }>' at line 1

[18:25] <colomon> under aa015ad043fc11ca10aecaf866b4158bea8edd47

[18:25] <pmichaud> are the curlies next to something that looks like a variable?

[18:26] *** sorear sets mode: +v hugme

[18:26] <moritz_> colomon: typically happens on %hash{$/}

[18:26] <colomon> moritz_: bingo!

[18:26] <pmichaud> also  $foo{...}

[18:26] *** IllvilJa joined
[18:26] * lue will assume operators.pm

[18:26] <colomon> script is working now, moritz_++

[18:26] <alexbobP> hey, sorear!

[18:27] <pmichaud> lue: operators.pm, yes.

[18:27] <pmichaud> lue: although you should no longer be getting the postcircumfix err, so something is very amiss here.

[18:27] <alexbobP> sorear: s'been a while.  I guess we've been cohabitating in #interhack all this time, but nobody has said anything there for months XD

[18:27] <supernovus> Has a method for allowing multiple versions of a library (as per S11) been spec'ed for Rakudo?

[18:27] <sorear> supernovus: no.

[18:27] <PerlJam> supernovus: S11 is the spec ;)

[18:27] <pmichaud> supernovus: I have some general ideas about how we'll do it, but it's not a priority at present.

[18:28] <pmichaud> primarily we'll have to get rid of our namespace-based classes.

[18:28] <pmichaud> (in the parrot sense of "namespace")

[18:29] <supernovus> Ah, I was going to look at helping with that feature, but I don't know how the parrot side of things work :(

[18:30] <lue> well, operators.pm says something about ||, and, or, and && as being weird in the grammar.

[18:30] <pmichaud> supernovus: we have a lot of prep work to do with lexically-scoped classes before I think we can justifiably address versioned modules

[18:30] <pmichaud> lue: they are -- those are the :pasttype's you saw earlier.

[18:30] <pmichaud> lue:  the trick with ||, and, or, andthen, etc. is that they have to "thunk" their arguments

[18:31] <pmichaud> i.e., unlike most other operators, these operators have to evaluate the arguments after the operation has started, not before

[18:32] <pmichaud> anyway, the postcircumfix error reads like a parsing error, so it's a problem in the grammar and not in the operators.pm file.

[18:32] *** clintongormley joined
[18:33] <lue> IIUC, andthen and orelse are defined as being loose_and and loose_or in the spec.

[18:33] <pmichaud> that's their precedence level, yes.

[18:33] <lue> which should have list associativity, not left like Grammar.pm says.

[18:34] <pmichaud> that shouldn't make a difference to parsing either

[18:34] <lue> [ I changed it last night (just to see what happens) and every spectest ended up failing :) ]

[18:35] <pmichaud> right.  Our implementations of 'and' and 'or' aren't list operators yet.

[18:35] <pmichaud> we can make them that way when we decide how we want to generally handle thunked arguments in Rakudo and/or Perl 6

[18:35] <lue> *sigh* even after defining them in core/operators.pm, :

[18:36] <lue> Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1

[18:36] <timbunce> std: class Foo {  ... }; role Foo { ... };

[18:36] <p6eval> std 31519: OUTPUT«ok 00:01 110m␤»

[18:36] <pmichaud> lue: I did say that the problem isn't in operators.pm.

[18:36] <pmichaud> *tap* *tap*  Is this thing on?!?

[18:36] <moritz_> std: package Foo { ... }; class Foo { }

[18:36] <p6eval> std 31519: OUTPUT«ok 00:01 107m␤»

[18:36] <timbunce> do classes and roles have separate namespaces?

[18:36] <pmichaud> timbunce: no.

[18:36] <moritz_> no

[18:36] <lue> I heard you :). I thought though that explicitly redefining it would help. hrm...

[18:37] <timbunce> so shouldn't "class Foo {  ... }; role Foo { ... };" be an error?

[18:37] <pmichaud> timbunce: yes, it should.

[18:37] <pmichaud> oh

[18:37] <pmichaud> wait

[18:37] <pmichaud> not if you explicitly use the ...'s

[18:37] <timbunce> pmichaud: because?

[18:37] <pmichaud> rakudo:  class Foo { has $.a; };  role Foo { method b() { ... } };

[18:37] <p6eval> rakudo 7df2c2: OUTPUT«Null PMC access in isa()␤  in main program body at line 1:/tmp/GV_zXZUdIr␤»

[18:38] <pmichaud> bah.

[18:38] <[Coke]> colomon: perhaps it might be worth using a StringBuffer when doing concats of big lists.

[18:38] <pmichaud> timbunce: I think S11 says something about this... checking.

[18:38] <colomon> [Coke]: that indeed seems very likely, if we do have a working StringBuffer.  :)

[18:38] <pmichaud> but essentially  "class Foo { ... }"  simply declares Foo as a package-ish identifier, iirc.

[18:39] <pmichaud> it doesn't explicitly say 'Foo' has to be a class.

[18:39] <pmichaud> std:  class Foo { ... };  role Foo { ... }

[18:39] <p6eval> std 31519: OUTPUT«ok 00:01 107m␤»

[18:39] <pmichaud> the standard grammar thinks it's okay.  :)

[18:39] <moritz_> phenny: tell masak http://github.com/moritz/modules.perl6.org - my approach at phasing out the web/ folder from proto

[18:40] <phenny> moritz_: I'll pass that on when masak is around.

[18:41] *** amkrankruleuen left
[18:41] *** plainhao left
[18:41] <[Coke]> colomon: parrot does. feel free to borrow it. =-)

[18:41] <PerlJam> pmichaud: S12:52 

[18:41] <[Coke]> (worth checking to see if it's faster than Str ~ Str , anyway.)

[18:44] *** supernovus left
[18:45] <pmichaud> Ah, what I'm thinking of is S10:128

[18:46] <pmichaud> "Such empty packages may be subsequently be redeclared as any other

[18:46] <pmichaud> package-like object (module, class, etc.), and no redeclaration warning will be issued

[18:46] <pmichaud> for such a redeclaration."

[18:46] <pmichaud> I'm not sure that exactly applies to timbunce++'s question.

[18:47] <PerlJam> I don't think the spec is explicit about timbunce's case.

[18:47] <pmichaud> However, since a role can function as a class, and vice-versa, it seems to me that declaring a package via either role/class could be considered legal.

[18:48] <cygx> is someone working on #58258 (ie making the REPL useful?)

[18:48] <pmichaud> cygx: me.

[18:48] <pmichaud> cygx: I have to do some significant refactors in rakudo to get it to work properly.

[18:48] *** kfo_ joined
[18:48] <pmichaud> cygx: but it should be done by July 9th.

[18:48] <timbunce> pmichaud: that's handy. What about the case where Foo is already defined as a role, say, and then perl sees "class Foo { ... }". The spec doesn't cover that. It sounds like the intent is that it wouldn't complain.

[18:49] <pmichaud> I would think it wouldn't complain.

[18:49] <cygx> pmichaud: that's promising - otherwise, try.rakudo.org would have to suffer the same shortcomings as I'm just piping the input to a rakudo process

[18:49] <pmichaud> I don't think we want the person writing "class Foo { ... }"  to make sure "Foo"  is declared to have to recognize that Foo is in fact a role.

[18:50] <PerlJam> std: role Foo { hash $.x; }; class Foo { ... }

[18:50] <p6eval> std 31519: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'GLOBAL::<Foo>' (from line 1) at /tmp/PjYv7cjXDd line 1:␤------> [32mrole Foo { hash $.x; }; class Foo [33m⏏[31m{ ... }[0m␤Illegal redeclaration of symbol 'Foo' (see line 1) at /tmp/PjYv7cjXDd line 1:␤------>

[18:50] <p6eval> ..[32mr…

[18:50] <timbunce> pmichaud: that's exactly the situation I'm in :)

[18:50] <pmichaud> std: class Foo { hash $.x; };  class Foo { ... }

[18:50] <p6eval> std 31519: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'GLOBAL::<Foo>' (from line 1) at /tmp/5uTXFoqCyV line 1:␤------> [32mclass Foo { hash $.x; };  class Foo [33m⏏[31m{ ... }[0m␤Illegal redeclaration of symbol 'Foo' (see line 1) at /tmp/5uTXFoqCyV line 1:␤------>

[18:50] <p6eval> ..[32…

[18:50] <pmichaud> looks like a std bug to me.

[18:51] <timbunce> Anyone here know java and want to help out with my java2perl6 utility (for DBDI)?

[18:51] *** kfo left
[18:52] <pmichaud> cygx: fwiw, the REPL in NQP already solves RT #58258

[18:52] <pmichaud> so if you wanted to try it out with NQP, that might be a valid approach :-)

[18:52] <PerlJam> timbunce: I wish.  Having DBDI and DBI and some DBDs worked out would be quite cool to have before R*

[18:52] <pmichaud> (and if you can get it working in nqp, then there's a good chance that you could provide an interactive web interface for all of Parrot's PCT-based languages)

[18:52] <pmichaud> s/in/with/

[18:54] <timbunce> PerlJam: that would be nice, though I've no idea about timescales. I'm hoping FakeDBI can at least "tick the box" for R*. At some point FakeDBI can migrate to using DBDI, once it's usable.

[18:55] <PerlJam> timbunce: yeah ... but for PR it should probably just be called DBI  :)

[18:55] <PerlJam> pmichaud: earlier was a people bug  s/hash/has/

[18:55] <pmichaud> PerlJam: I'm not sure I agree with that last remark.

[18:56] <PerlJam> pmichaud: why not?

[18:56] <pmichaud> (calling it DBI)

[18:56] <pmichaud> it might be implying something that isn't true.

[18:56] <timbunce> I think FakeDBI doesn't have the right foundations for that. It's a pity the name is so blunt though.

[18:56] <cygx> pmichaud: sorear++ suggested using IO::Pty::HalfDuplex, ie the web shell will workd with any program which uses blocking io to read from stdin (which I'm assuming the Rakudo REPL does/will do?)

[18:57] <pmichaud> I'd hate for someone to say "Perl 6 has DBI already"

[18:57] <pmichaud> cygx: rakudo REPL blocks on stdin, yes.

[18:57] <PerlJam> yeah, I guess that would be sort of a "bait and switch" kind of situation

[18:57] <cxreg> i'm having a hell of a time declaring a lvalue method

[18:58] <pmichaud> cxreg: what sort of lvalue method do you need?

[18:58] *** hercynium left
[18:58] <timbunce> Something like ProtoDBI would be a better name. Still, I can't grumble. I'm delighted it's there and it'll certainly help me down the road.

[18:58] <PerlJam> timbunce: what needs doing for DBDI exactly?

[18:58] <pmichaud> "EarlyDBI"

[18:58] <pmichaud> "SimpleDBI"

[18:58] <cxreg> this is back to earlier, when i wanted a proto for one.  i gave up on that and made a private member, and want a lvalue sub to make my own accessor.

[18:59] <timbunce> pmichaud: yeap, anything like that would be fine.

[18:59] <[Coke]> timbunce: I have some java experience and would be willing to help out.

[18:59] <pmichaud> cxreg: most methods in rakudo act like lvalue methods already, I think.

[18:59] <cxreg> hrm

[19:00] <timbunce> [Coke]: great, please join #dbdi so I can pick your brains :)

[19:00] <pmichaud> rakudo:  class XYZ { has $!x; method x() { $!x } };   my $a = XYZ.new;  $a.x = 3;  say $a.x;

[19:00] <p6eval> rakudo 7df2c2: OUTPUT«3␤»

[19:00] <pmichaud> yes, that's a bug.

[19:00] <pmichaud> but it's a bug you could exploit until we have "is rw" working on methods.  :-)

[19:00] <ash_> which part of it is a bug? 

[19:00] <cxreg> heh

[19:00] <ash_> whats the right way? 

[19:00] <pmichaud> ash_: method x() is rw { ... }

[19:00] <ash_> got ya

[19:01] <cxreg> pmichaud: i dont understand, why did the proto have no args?

[19:01] <pmichaud> cxreg: what proto?

[19:01] <cxreg> er, the sub declaration

[19:01] <cxreg> "method x()"

[19:01] <pmichaud> doesn't need any

[19:01] <pmichaud> you're returning the container

[19:01] <cxreg> oh..

[19:01] <pmichaud> you're not defining how to store a value into it

[19:01] <cxreg> i misunderstood what that code did

[19:02] *** pyrimidine left
[19:02] <cxreg> so really the issue is that "method ... is rw" is not implemented yet

[19:02] <timbunce> PerlJam: I'll write up a blog post in the next day or so. Basically get java2perl6 to produce a set of perl6 class/role modules that match the JDBC API and then start writing implementations that match those interfaces.

[19:02] <pmichaud> cxreg: well, that's *an* issue, yes.

[19:02] <pmichaud> but note that an "is rw" method never sees the value being assigned to the thing it returns as rw

[19:03] <cxreg> sigh

[19:04] <pmichaud> what you may be looking for instead is proxy values (in S06)

[19:04] <pmichaud> i.e., a proxy value has a STORE method that says what to do when something attempts to store a value in the proxy

[19:04] <cxreg> i wanted callnext :p

[19:05] <pmichaud> (and proxy values are still somewhat conjectural in the spec)

[19:07] <moritz_> cxreg: it's spelled nextwith

[19:08] <cxreg> callsame, rather

[19:08] <cxreg> whats nextwith?

[19:08] <ash_> next in the multi-dispatch with different parameters 

[19:08] <cxreg> oic

[19:08] <moritz_> next candidate, called with a specified signature

[19:09] <cxreg> ok lunch.  i'll hammer on this again later.

[19:09] <ash_> rakudo: multi foo(Int $a) { nextwith("Hi"); }; multi foo(Str $b) { say $b; }; foo 3;

[19:09] <p6eval> rakudo 7df2c2: OUTPUT«Null PMC access in clone()␤  in 'foo' at line 1␤  in main program body at line 11:/tmp/GrUAuBvmhO␤»

[19:10] <ash_> hmm

[19:10] <ash_> does nextwith not work right now?

[19:10] <pmichaud> ash_: I don't know.

[19:10] <pmichaud> ash_: looks like "no."

[19:10] <moritz_> I think it's a bit broken, but your example won't work anyway

[19:10] <ash_> well, i could of written it wrong

[19:11] <moritz_> because the first dispatch limits it to the (Int $a) candidate

[19:11] <jnthn> ash_: It works

[19:11] <jnthn> ash_: But it should die more gracefully

[19:11] <jnthn> Or maybe shouldn't die at all.

[19:11] <moritz_> so the candidate list is empty then

[19:11] <jnthn> Anyway, what moritz_++ said.

[19:12] <pmichaud> rakudo:  multi foo(Int $a) { nextwith("hi"); };  multi foo($b) { say $b; };  foo 3;

[19:12] <ash_> ah, i guess that should of been callwith not nextwith 

[19:12] <p6eval> rakudo 7df2c2: OUTPUT«Null PMC access in clone()␤  in 'foo' at line 1␤  in main program body at line 11:/tmp/W313wCwRs_␤»

[19:12] <pmichaud> how about that one?

[19:15] *** felliott joined
[19:18] <jnthn> ...that should work

[19:18] <jnthn> Oh, it probably did

[19:18] <jnthn> oh, wait

[19:18] <jnthn> Hm

[19:19] <ash_> i thought nextwith redispatched (like a new call completely) 

[19:20] <ash_> kinda like just doing (in that case) foo(args); (just without having to write the sub's name 

[19:20] <jnthn> rakudo:  multi foo(Int $a) { say "here"; nextwith("hi"); }; multi foo($b) { say "and here"; say $b }; foo(3);

[19:20] <p6eval> rakudo 7df2c2: OUTPUT«here␤Null PMC access in clone()␤  in 'foo' at line 1␤  in main program body at line 11:/tmp/IIg0PyIgEa␤»

[19:20] <jnthn> No, that's certainly wrong.

[19:20] <jnthn> oh!

[19:20] <jnthn> I bet it works fine on methods.

[19:20] <jnthn> Just not multi subs for some reason.

[19:22] <ash_> ah, but it should work with mult subs too, right? 

[19:22] <jnthn> yeah

[19:22] <jnthn> I think that's NYI for now though

[19:22] <jnthn> And I can't really be bothered to invest too much time in it given spec changes mean I'm going to have to re-do the whole dispatchy stuff anyway in a bit.

[19:23] <ash_> no worries

[19:23] <ash_> just wonder if it was supposed to be right

[19:23] <jnthn> The one pm pasted shoulda worked, yes

[19:24] <ash_> why wouldn't the orginal? 

[19:30] <jnthn> Because you're walking through a candidate list

[19:31] <jnthn> And the list was formed based on the arguments you initial passed.

[19:32] <ash_> i think i understand, thanks 

[19:33] *** Guest80095 left
[19:36] *** rgrau left
[19:36] <ingy> greetings

[19:37] * davidfetter waves to mr. döt net

[19:37] *** justatheory left
[19:39] *** justatheory joined
[19:40] <Guest23195> hmm this http://blogs.perl.org/users/martin_berends/2010/06/rakudo-perl-6-gets-into-databases.html

[19:40] *** Guest23195 is now known as kaare_

[19:41] <kaare_> I would have thought that cxreg's implementation using libpg would be fast and right?

[19:41] *** justatheory_ joined
[19:41] *** justatheory left
[19:41] *** justatheory_ is now known as justatheory

[19:41] *** synth joined
[19:42] <kaare_> What's the ++ og using Pg.pir if you have direct access through libpg?

[19:42] <kaare_> og -> of

[19:43] <kaare_> Or doesn't it really use direct library calls?

[19:47] *** justatheory left
[19:58] *** ilogger2 joined
[20:01] <timbunce> S06 seems to have very little to say about the return type of a subroutine, like what the effect of defining a return type is. Is that specified elsewhere?

[20:05] <mberends> on incoming parameters, types are constraints that are checked at call time. Returns could be handled as an output parameter, subject to the same constraint type checking at runtime.

[20:06] *** justatheory joined
[20:08] <mberends> but the checking is NYI :(

[20:09] <timbunce> Can I say sub Foo (--> Container) to mean the sub returns an object that does the Container role?

[20:09] <mberends> rakudo: sub a(Str $s, --> Int){ $s.uc }; say a("Foo"); # should complain about no Int

[20:09] <p6eval> rakudo 7df2c2: OUTPUT«FOO␤»

[20:09] <timbunce> std: sub Foo (--> Container)

[20:09] <p6eval> std 31519: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse signature at /tmp/RlLrIwYJqN line 1:␤------> [32msub Foo [33m⏏[31m(--> Container)[0m␤Couldn't find final ')'; gave up at /tmp/RlLrIwYJqN line 1:␤------> [32msub Foo (--> [33m⏏[31mContainer)[0m␤    expecting typename␤Parse

[20:09] <p6eval> ..faile…

[20:11] <mberends> std: class Container { ... }; sub Foo (--> Container) {...}

[20:11] <p6eval> std 31519: OUTPUT«ok 00:01 109m␤»

[20:12] <timbunce> mberends: so role names can't be used to express return types? ever?

[20:13] *** zamolxes joined
[20:13] <pmichaud> I'm pretty sure that role names would be acceptable as return constraints.

[20:13] <mberends> timbunce: oh, sorry, I tried class instead of role. role should also be fine.

[20:13] <mberends> std: role Container { ... }; sub Foo (--> Container) {...}

[20:13] <p6eval> std 31519: OUTPUT«ok 00:01 109m␤»

[20:13] <pmichaud> phone

[20:14] <mberends> rakudo: role Container { ... }; sub Foo (--> Container) {...}

[20:14] <p6eval> rakudo 7df2c2:  ( no output )

[20:14] <timbunce> ah, so my failure was because Container isn't predefined (yet), ok, thanks.

[20:14] *** dju_ joined
[20:18] *** dju_ is now known as dju

[20:36] <jnthn> Yes, role types are fine as return types

[20:41] <lue> pmichaud: would it be safe for me to experiment with getting := working, or will that be an exercise in futility?

[20:45] <pmichaud> lue: it's safe to experiment

[20:48] <lue> Alright. Time to head into my Molybdenum bunker (in case of BOOM) and start experimenting!

[20:50] <pmichaud> at its core, you want to do

[20:50] <pmichaud> (given 'source' and 'target' pmcs)

[20:50] <pmichaud>     $P0 = new ['ObjectRef'], source

[20:50] <pmichaud>     copy target, $P0

[20:50] <pmichaud>     .return (target)

[20:52] <pmichaud> you might try defining &infix:<:=> just with that to begin with, and see what works/breaks.

[20:53] <pmichaud> I know that rebinding sources is likely to cause problems/confusion.

[20:53] <pmichaud> (and possibly enough confusion that it's a good argument not to have := implemented to begin with.)

[20:54] <pmichaud> oh wait, &infix:<:=>  is defined in the settings?!

[20:54] <pmichaud> that's.... going to make things much more difficult.

[20:54] <jnthn> why?

[20:54] <pmichaud> unless 'is ref' is working.

[20:54] <jnthn> Just make sure the parameters are \$foo'd

[20:55] <pmichaud> oh, is the backslash the new 'is ref'?

[20:55] <jnthn> pmichaud: "is parcel" but it's always written with \ these days, iirc

[20:55] <pmichaud> okay, that might simplify it a bit.

[20:55] <pmichaud> is it really a parcel?

[20:55] <jnthn> No

[20:55] <pmichaud> or just whatever argument gets passed.

[20:55] <jnthn> It means "apply no context whatsoever to this"

[20:55] <pmichaud> okay

[20:55] <jnthn> Just binds exactly what was passed

[20:55] <pmichaud> might not be so difficult then.

[20:55] <jnthn> No, it should work

[20:55] <jnthn> We need it in the setting really

[20:56] <pmichaud> yes, I know.

[20:56] <jnthn> Since it almost certainly wants to be a multi

[20:56] <jnthn> We already have some candidates

[20:56] <jnthn> So it should just be a case of filling out the one that currently throws an error saying that case is NYI

[20:57] <pmichaud> yeah.  I haven't figured out how to handle the   $b := $a;  $a := $x;  case though.

[20:57] <pmichaud> we'll either need to put another level of indirection on our containers (ick), or find a way to rebind symbols in the lexpad (also ick)

[21:01] *** jferrero joined
[21:01] <ash_> pmichaud: is it hard (possible) to add your own phaser? 

[21:01] <ash_> or to the world in general, i just figured pmichaud would know 

[21:01] <pmichaud> ash_: I'm not sure I understand "add your own phaser"

[21:01] <pmichaud> you mean, add a new stage?

[21:02] <pmichaud> (what I like to call a "phaser bank"?)

[21:02] <ash_> ummm yes? (not familiar with stage as its being used) 

[21:03] <pmichaud> give me an example of what you're wanting to do, then.

[21:04] <ash_> role Foo { COMPOED {  say 'here'; } }; $a does Foo; # would say 'here' now

[21:04] <ash_> COMPOSED* 

[21:04] * lue apparently made a big BOOM just walking to the bunker

[21:04] <pmichaud> ash_: that would likely require a grammar modification and some other stuff.

[21:05] <pmichaud> ash_: it's not (yet?) a simple thing to add a new phaser.

[21:05] *** pmurias joined
[21:05] <ash_> could i do that with a meta class? 

[21:05] <ash_> if i made that like a sub 

[21:05] <ash_> instead of a phaser

[21:06] <pugssvn> r31520 | lwall++ | [STD] simplify charname matching 

[21:06] <pugssvn> r31520 | parse the \| parameter specially

[21:06] <pugssvn> r31520 | unbreak the null pattern matcher

[21:06] <pmichaud> iiuc, the metaclass controls composition, yes.

[21:09] <ash_> rakudo: role Foo { our sub COMPOSED { say 'here' }}; Foo::COMPOSED; # is there a way to call that sub? 

[21:09] <p6eval> rakudo 7df2c2: OUTPUT«Can not find sub Foo::COMPOSED␤  in main program body at line 1␤»

[21:11] <cxreg> mberends: my Pg class is updated, now with many more methods, and commit/rollback

[21:11] <cxreg> one issue I haven't solved yet is making AutoCommit commit when set to true

[21:12] <cxreg> due to various setbacks with multimethods and lvalue methods :/

[21:12] <mberends> cxreg++ very nice though

[21:12] <mberends> cxreg: thanks, I'm very happy with what you've done

[21:13] <cxreg> np :)  I think it's ready for general inclusion, if you like

[21:14] <mberends> two things before that: 1. the repo has been renamed to MiniDBI, see backlog. and 2. have you also added a test script that evals 99-common.pl6 ?

[21:14] <cxreg> kaare_: one advantage of using Pg.pir is that you dont have to maintain your own thunks and NCI-fu, or depend on a middle layer like zavolaj

[21:15] <cxreg> oops, yeah still need to produce a test.  i guess it requires instructions on stubbing out an empty db like the mysql test?

[21:16] <mberends> yes, the postgresql example in zavolaj is the easiest to copy

[21:17] <mberends> the s/FakeDBI/MiniDBI/g in all files is almost ready to push

[21:17] <cxreg> some of the links in your post are now or soon to be outdated btw

[21:17] <mberends> yeah, I'll definitely revise the blog post :)

[21:18] <mberends> ... and rewrite some yapc::eu slides ;)

[21:19] <jnthn> cxreg: But Pg.pir *is* a "middle layer" and it does pretty much what Zavolaj does for you.

[21:19] * mberends <- happy bunny

[21:19] <cxreg> jnthn: fair enough.  it's just that you already have it :)

[21:19] <cxreg> zavolaj++ btw

[21:20] <dukeleto> does the *+* operator have a name?

[21:20] <cxreg> snowman?

[21:20] <jnthn> *+* operator?

[21:20] <mberends> starry-eyed ?

[21:20] <pmichaud> "cheerleading plus"?

[21:20] <cxreg> cheerleading jesus?

[21:21] * cxreg ducks

[21:21] <alexbobP> cheesus

[21:21] <pmichaud> dukeleto: that's just a plain infix:<+>  with two "whatever" operands.

[21:21] <kaare_> Perhaps Pg.pir has the advantage of support from the pl/parrot folks?

[21:21] <dukeleto> pmichaud: aha! thanks for the explanation

[21:21] <pmichaud> the whatever operands cause it to become a closure

[21:22] <dukeleto> kaare_: i am pretty much "the pl/parrot folks", but there are a few other brave souls helping me. what is your question?

[21:22] * dukeleto is working on a blog post about PL/Perl6 and will mention the awesome work done with Pg.pir + friends recently

[21:23] <cxreg> dukeleto: mberends has one up, maybe you could link it - http://blogs.perl.org/users/martin_berends/2010/06/rakudo-perl-6-gets-into-databases.html

[21:23] <kaare_> dual: Yes, I meant you :-) I thought that maybe you maintain Pg.pir?

[21:23] <dukeleto> kaare_: nope, I didn't write Pg.pir

[21:25] <dukeleto> kaare_: according to svn blame, leo wrote most of it, with some patches from "The Usual Suspects"

[21:26] <kaare_> ok

[21:30] <mberends> FakeDBI is dead. Long live MiniDBI ! (well, not too long ;)

[21:31] <dukeleto> mberends++

[21:32] <ash_> FakeDBI got renamed? 

[21:32] <mberends> yes :) now editing the blog posting

[21:35] <jnthn> mberends: I prefer the new name.

[21:35] <timbunce> mberends: "Perl 5 DBI (v1) became hard to maintain and is no longer being actively developed" doesn't paint the right picture. There's a *lot* of work going on in the DBD::File area for example. Can you soften the wording? Something like "Perl 5 DBI (v1) is very widely used. The stability of the API is paramount so radical changes are unlikely."

[21:37] <pmichaud> I greatly prefer the new name.

[21:37] <kaare_> yeah, MiniDBI++

[21:37] <mberends> timbunce: thanks, doing it right now. :)

[21:38] <cosimo_> I was a bit surprised when i read "no longer being actively developed" 

[21:38] <timbunce> mberends: also "translate the Java classes of JDBC into Perl 6" could lead people to think it's translating more than just the class/interface APIs.

[21:38] <mberends> yes, that's wrong too

[21:39] <timbunce> mberends: all it does is spit out .pm6 files that define roles with stub method definitions. Someone still has to write the code behind those stubs :)

[21:40] <mberends> heh, I half remembered that and forgot to write it. sorry, will fix :)

[21:43] *** skids joined
[21:45] *** tylercurtis joined
[21:49] <kaare_> night &

[21:49] *** pnate2 joined
[21:49] *** hercynium joined
[21:50] *** rgrau joined
[21:51] *** jferrero left
[21:52] <lue> afk

[21:52] <ingy> how do I get t the length of $foo.bar.array ?

[21:52] <ingy> gi!mf

[21:53] *** opx^away joined
[21:53] <dukeleto> ingy: @array.elems

[21:53] <ingy> thx

[21:54] <ingy> dlimf!

[21:54] <dukeleto> ingy: say join " ", @foo.^methods is useful

[21:54] <ingy> yay1

[21:54] <ingy> yay!

[21:54] <ash_> ~@foo.^methods # is a bit shorter 

[21:55] <dukeleto> ash_++

[21:55] <ash_> +@array # also a shortcut for the length of an array 

[21:55] <ash_> rakudo: my @a = <a b c>; say +@a, ~@a.^methods(:local);

[21:55] <p6eval> rakudo 7df2c2: OUTPUT«3at_pos new exists splice delete perl␤»

[21:55] *** pnate joined
[21:55] <ash_> rakudo: my @a = <a b c>; say +@a, ' ', ~@a.^methods(:local);

[21:56] <p6eval> rakudo 7df2c2: OUTPUT«3 perl delete at_pos new exists splice␤»

[21:57] *** pnate2 left
[22:05] *** timbunce joined
[22:07] *** pmurias left
[22:08] *** kfo_ joined
[22:08] *** davidfetter joined
[22:08] *** colomon joined
[22:08] *** pjcj_ joined
[22:08] *** kloeri joined
[22:08] *** PZt joined
[22:08] *** buubot joined
[22:08] *** Lorn joined
[22:08] *** farmer.freenode.net sets mode: +ov colomon buubot

[22:08] *** PZt left
[22:08] *** stef_ joined
[22:09] *** hercynium left
[22:09] *** whiteknight joined
[22:14] *** kensanata joined
[22:19] *** synth joined
[22:20] *** skids left
[22:29] *** justatheory left
[22:33] *** hercynium joined
[22:36] *** Trashlord joined
[22:36] <mberends> loli(re)blogged: http://blogs.perl.org/users/martin_berends/2010/06/rakudo-perl-6-gets-into-databases.html # s/Fake/Mini/g and other tweaks

[22:37] *** hercynium_ joined
[22:38] <mberends> sleep &

[22:38] *** hercynium left
[22:48] *** saaki joined
[22:49] *** ive joined
[22:50] *** timbunce left
[22:55] <dalek> csmeta: r364 | stefa...@cox.net++ | trunk/vicil:

[22:55] <dalek> csmeta: [vicil] Delete.  It now lives at git://github.com/sorear/niecza.git

[22:55] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=364

[22:56] <sorear> diakopter: ping

[23:00] <diakopter> PLONG

[23:01] <diakopter> sorear: how is Niecza pronounced

[23:01] *** ashleydev joined
[23:02] <sorear> I hadn't thought about that much.  I'd been going knee + tsar - r

[23:03] <sorear> Anyway.  Who do I talk to about adding repositories to dalek?

[23:04] <jnthn> sorear: nee-yee (dipthong)

[23:04] <jnthn> cha

[23:05] <jnthn> gah

[23:05] <jnthn> nee-yeh cha

[23:05] <jnthn> But pallated.

[23:05] <jnthn> (the n is)

[23:05] <jnthn> Consult your nearest friendly local Slav for help. ;-)

[23:07] *** Sanitoeter joined
[23:12] *** PZt joined
[23:18] *** tedv joined
[23:22] *** kensanata left
[23:33] *** ive left
[23:46] *** rgrau_ joined
[23:48] *** rgrau left
[23:54] *** Psyche^ joined
[23:55] *** Psyche^ is now known as Patterner

