[00:00] <jnthn> Don't make me break out the ASCII YMCA dance.

[00:01] * diakopter refrains from making you

[00:01] *** c1sung left
[00:01] *** c1sung joined
[00:06] *** crythias1 joined
[00:08] *** crythias left
[00:22] *** crythias joined
[00:25] *** crythias1 left
[00:25] <mberends> colomon: monitor updated with sampling and display options: http://gist.github.com/369869

[00:25] <colomon> mberends: would change, but in the middle of a run with it right now.  ;)

[00:26] <mberends> o/ # going to sleep

[00:26] <colomon> mberends: actually, for my taste the nicest change would be to switch it to using stderr instead of stdout.

[00:26] <colomon> mberends++

[00:27] <mberends> colomon: thanks for the feedback, can make that another option

[00:28] <jnthn> o/, mberends++ 

[00:35] *** dual left
[00:37] <colomon> jnthn: hmmm.  mberends++ tool is not showing an unexpected increase in memory consumption in mandelbrot.  (yet, still at smallish numbers.)

[00:38] <colomon> oh, except I'm not factoring it correctly.

[00:38] <colomon> hmmm....

[00:39] <colomon> oh, there we go.

[00:39] <colomon> looked at properly, it suggests doubling the edge size a bit more than doubles the memory usage.

[00:40] <colomon> but it's nothing crazy yet.

[00:40] <jnthn> OK.

[00:41] <colomon> or maybe it is.

[00:41] <colomon> okay, here's what's crazy.

[00:41] <jnthn> At the moment, a Complex is heavy. It's IIRC 2 PMCs at a Parrot level per Perl 6 object. A Complex is the Complex object itself + a Num for real part + a Num for imaginary part = 6 PMCs.

[00:41] <colomon> it looks to me like it's doubling like it should be, more or less.

[00:42] <colomon> BUT... it's doubling from a HUGE base.

[00:42] *** dual joined
[00:43] <jnthn> I may try and patch Parrot pre-R* to get it down to 3. After R* when I do the native types work I should be able to get it down to 1.

[00:43] <colomon> actually, Complex might be two Rats in this case.

[00:43] <jnthn> Oh

[00:43] <jnthn> Then wow. :-)

[00:44] <jnthn> Rat = Rat object + the two parts = 6 PMCs.

[00:44] <jnthn> So your total Complex number of two Rats is 14 PMCs.

[00:44] <jnthn> .oO( no damm wonder it's slow )

[00:45] <colomon> hold a sec

[00:45] <jnthn> I suspect I may need to try writing that Parrot patch. :-)

[00:46] <colomon> looks to me like it's taking about 4 MB per unit of edge size.

[00:46] <colomon> ack, it's hard to figure out what units we should be talking about.

[00:47] <colomon> If you think switching Rat to Num will make a noticeable, that's an easy enough test to do.

[00:47] <jnthn> I'd be interested to know.

[00:48] <colomon> anyway, 4 MB is insanely high for this.

[00:49] <jnthn> What does a "unit of edge size" actually mean?

[00:51] <colomon> well, you give it the width / height (ie edge size) on the command line.

[00:51] <colomon> doubling that quadruples the number of pixels calculated (because the image is square)

[00:51] <colomon> that affects the overall timing, and what I'm seeing is right in line with that.

[00:52] <colomon> double that also doubles the memory usage.

[00:53] <colomon> that sort of makes sense, because since for does not lazily handle its arguments, the entire list of complex values for each row of pixels must be in memory at once.

[00:54] <colomon> but at the same time, that implies that 161 Complex numbers requires 1.3 GB to store (according to the numbers I just got), which is insane.

[00:56] <colomon> If I'm figuring correctly (based on earlier numbers, too, not those) that's 4MB for each Complex number.

[00:58] <jnthn> erm.

[00:58] <jnthn> That...can't be right.

[00:58] <colomon> I hope not.

[00:58] <jnthn> Or at least, can't be the whole story.

[01:01] <colomon> sure.

[01:02] <colomon> if you look at the code, it's a nested loop.

[01:03] <diakopter> maybe parrot is allocating more memory unnecessarily (before it actually needs it)?

[01:03] <colomon> all results are dumped each time through the outer loop, so that shouldn't be accumulating memory.

[01:03] <colomon> and the results suggest it isn't -- if it was, we'd be seeing the memory go up by 4 rather than by 2.

[01:04] <jnthn> diakopter: Not sure. Allocation stratergy tweaks have in the past made notable differences though.

[01:04] <colomon>     my @line = subdivide($re + ($upper-right.im)i, $re + 0i, ($width + 1) / 2).map({ mandel($_) });

[01:04] <colomon>     my $middle = @line.pop;

[01:04] <colomon>     (@line, $middle, @line.reverse).map({ @color_map[$_] }).join(' ').say;

[01:04] <diakopter> maybe more tweak possibilities exist

[01:05] <jnthn> Undoubtably.

[01:05] <colomon> is the inner loop, and increasing $width by 1 increases the memory usage by about 4MB.

[01:05] <diakopter> in the meantime, strategery abound

[01:07] *** rv2733 left
[01:08] <colomon> going to run load the dishwasher, will check back in a few minutes to see how the Numified version is doing.

[01:16] *** Chillance joined
[01:19] *** wknight8111 left
[01:20] *** ob1 joined
[01:22] *** ob1 left
[01:23] <colomon> jnthn: if mberends++' script is accurate, switching to Num shaves 17 seconds off the execution time, and 

[01:23] <colomon> rakudo: say 1520201728 - 1516560384

[01:23] <p6eval> rakudo 78faa0: OUTPUT«3641344␤»

[01:24] <colomon> 3.6 MB off the memory usage.

[01:25] <jnthn> :/

[01:26] <jnthn> Which is a tiny fraction of the whole.

[01:26] <colomon> yup

[01:26] <jnthn> Which would seem to suggest we're blowing our memory on something other than the storage.

[01:27] <colomon> other than storage of Complex components anyway, yes.

[01:27] <jnthn> Yes, that's what I meant.

[01:27] * diakopter guesses scopes & frames

[01:28] <jnthn> The thing is, we seem to be back to while 1 { 1 } leaking again.

[01:28] <jnthn> Which is really shit.

[01:28] <colomon> could somehow be storage of the Arrays, I suppose...

[01:29] <jnthn> Well, what diakopter said makes some sense too I fear.

[01:29] <jnthn> I guess we're leaking those somehow.

[01:29] <diakopter> maybe they're not being GCd

[01:30] <colomon> even when memory usage gets up into the GBs?

[01:30] <jnthn> The bigger problem is why.

[01:30] <diakopter> (even if all references to them are being nulled)

[01:30] <jnthn> Is it a GC mis-configuration.

[01:30] <jnthn> Or is it lost pointers

[01:30] <jnthn> Or something else.

[01:31] <diakopter> GC mis-configuration or GC mis-implementation

[01:31] *** sorear left
[01:31] <jnthn> nod

[01:31] *** sorear joined
[01:32] <diakopter> try this

[01:32] <diakopter> just do a nested loop of the same structure, but with no storage, just Int counters

[01:33] <diakopter> and empty arrays though

[01:33] <diakopter> so map is still called

[01:33] <jnthn> nod

[01:33] <jnthn> That'd be revealing.

[01:34] *** drbean_ is now known as drbean

[01:34] <colomon> I've just noticed that the inner loop is actually map, so in theory.... arrrgh.

[01:34] <diakopter> that would tell you whether the problem is in the routine passed to map or in all teh corntol fowl around it

[01:35] <diakopter> the control flow, even

[01:35] * colomon likes the idea of corntol fowl.

[01:36] * diakopter fights the downwards funargs problem for yet another hour

[01:37] <diakopter> I should yearn to write in anagrams all the mite

[01:37] <diakopter> at lates, where I see meth

[01:37] <colomon> I really don't know how to coherently modify the algorithm to not use storage.

[01:38] <colomon> oh hey, though, one thing we could easily do is change max_iterations on the inner mandelbrot calculation.

[01:39] <colomon> increasing that (say) would cause additional inner loops / calculations without any difference to the longer term storage in the script.

[01:40] <colomon> so if just looping is using memory, it would show up that way.

[01:40] <diakopter> apparently ye olde volcano will put Europe back into the Dark Sage

[01:41] <diakopter> if cable news has anything to say about it.

[01:41] <colomon> Dark Sage!  oh no!  I prefer rosemary!

[01:44] <colomon> my wife just discovered our insurance covers cleanup from volcanic ash!

[01:44] *** meppl left
[01:44] <diakopter> but not damage from it?

[01:44] * diakopter hides the garage door openers

[01:45] <colomon> she's in the debris removal section, so we don't know.

[01:46] <colomon> our shrubs are covered against aircraft, too.

[01:46] <jnthn> Better than having your shrubs covered in aircraft, I guess.

[01:47] * diakopter looks around for the punkings

[01:47] <colomon> web search suggests it's been 2.5 billion years since there were active volcanos in Michigan, so they must be worried about the supervolcanos out west....

[01:47] <diakopter> yeah but big enough eruption can have global effect

[01:48] <diakopter> spaceship-wide, I should say.

[01:48] <jnthn> Cable news is probably full of crap.

[01:48] <jnthn> Some airlines are even doing test flights to see what happens to their aircraft if they fly them in the closed airspace.

[01:49] <jnthn> Apparently, nothing much yet.

[01:49] <colomon> diakopter: sure, but is there likely to be a worldwide volcano eruption which: 1) causes measurable amounts of ask damage to my house and 2) doesn't end civilization in the process?

[01:49] <colomon> *ash

[01:49] <diakopter> I guess not. :'(

[01:54] <diakopter> someone should use bombs to convert the volcanic cone to something that just oozes magma

[01:57] *** Psyche^ joined
[01:58] <jnthn> What could possibly go wrong? :-)

[01:58] *** nihiliad left
[02:01] *** Patterner left
[02:01] *** Psyche^ is now known as Patterner

[02:01] <colomon> just started a size 1001 run for overnight.  by my reckoning it should take about 5 hours to run...

[02:03] *** rgrau left
[02:05] *** envi^home joined
[02:07] * jnthn -> sleep now 

[02:07] <jnthn> o/

[02:08] <diakopter> o/

[02:08] <colomon> o/

[02:15] <sorear> colomon: Why?  Stress testing?

[02:18] *** PZt joined
[02:19] <diakopter> .. start with some tomahawks, if that doesn't work, maybe a trident.

[02:21] *** meppl joined
[02:28] *** crythias left
[02:34] *** _jaldhar joined
[02:35] *** eternaleye joined
[02:38] <diakopter> hm.

[02:38] <sorear> also, you do not need volcanos to have fun with ash

[02:41] <diakopter> sorear: you might be interested:

[02:41] <diakopter> I'm trying to solve the downward funargs problem for perlesque

[02:41] <sorear> funargs problem?  ick

[02:41] <diakopter> er

[02:41] <diakopter> yes

[02:41] <diakopter> downwards funarg, I mean. :|

[02:42] <diakopter> http://en.wikipedia.org/wiki/Funarg_problem#Downwards_funarg_problem

[02:43] <diakopter> The second paragraph under "Practical Limitations" is exactly what perlesque does.

[02:44] * diakopter keeps at it

[03:06] *** cledu left
[03:13] *** jaldhar_ joined
[03:14] *** _jaldhar left
[03:35] *** fridim joined
[03:36] *** jaldhar_ left
[03:36] *** jaldhar_ joined
[03:43] *** meppel joined
[03:46] *** meppl left
[03:46] *** meppel is now known as meppl

[03:47] <sorear> diakopter: the Wikipedia Funarg Problem is ... not at all the same as the funarg problem I know

[03:52] <diakopter> oh

[03:53] <diakopter> sorear: which one do you know

[03:53] <diakopter> the one described in terms of free variables and their binding and activation environments?

[03:58] *** Chillance left
[04:01] * diakopter figured it out.

[04:05] * diakopter can't decide which is more fun: having cake or eating cake.

[04:07] <sorear> diakopter: yes, the free variable binding problem in Lisp-2

[04:07] <sorear> the one which was solved by the invention of lexical scope

[04:09] <diakopter> oh :)

[04:11] <diakopter> you're saying "lexical scope" makes the binding environment synonymous with the declaration environment.

[04:11] <diakopter> there could have been other ways to do it

[04:11] <diakopter> since there are a couple levels of "bind" there

[04:13] <sorear> the original funarg problem was a semantic problem, not an implementation one

[04:13] <sorear> so it could be fixed by conceptual leaps

[04:13] <diakopter> I can imagine a "bind_free_vars" function that is a compile-time instruction to "curry" free variables to particular scopes...

[04:13] <diakopter> (treating a function declaration like a function template)

[04:14] <diakopter> (so it doesn't actually curry the values, just the slots)

[04:14] <diakopter> now _that_ would be metaprogramming.

[04:16] *** jaldhar_ left
[04:16] <diakopter> kindof a generalization of 'compose' and 'curry'

[04:17] *** jaldhar_ joined
[04:19] *** XaeroOne joined
[04:36] <sorear> sooooo.... the CLR uses dynamic scoping?

[04:36] <sorear> I had no idea Microsoft was /that/ crazy

[04:36] <diakopter> nope

[04:36] <sorear> so why are you having a funarg problem?

[04:36] <diakopter> CIL (its assembly language) doesn't have scoping

[04:36] <diakopter> at all

[04:37] <diakopter> b/c perlesque has lexical and dynamic scoping (and closures, and continuations for that matter), and I'm compiling perlesque to CIL

[04:37] <diakopter> so all closures must be strongly typed on each's full signature

[04:38] <diakopter> so I need variables of particular closure-types to be able to store closures with identical signatures.

[04:38] <diakopter> (but different function bodies, obviously)

[04:39] <diakopter> .. and I'm ignoring co- and contra-variance on signatures entirely.

[04:40] <diakopter> stackframes are reified as CIL objects on the heap, and codegen to resolve all lexical slots is done at compiletime

[04:47] <sorear> sounds like perlesque is a real exercise in Turing completeness

[04:48] <TimToady> oddly, Perl 5 gets around the whole issue without putting the activation stack on the heap

[04:48] <TimToady> at the expense of having to clone closures, basically

[04:48] <diakopter> sorear: Guy Steele explains the definition drift/specification of the funarg problem: http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03278.html

[04:49] <diakopter> TimToady: but that's the same thing..

[04:49] <diakopter> aren't the cloned closures activation records themselves?

[04:50] <TimToady> yes, well, you might say it's using indirection to solve the problem :)

[04:50] <sorear> TimToady: essentially, Perl 5 does keep activation records on the heap; the pad is only an index, lexicals are 'struct sv' in the arena

[04:51] <diakopter> ok. perlesque does the same thing in an OO way; a closure class is created for each subroutine, and instances of that closure class hold links to their proper parent scopes

[04:51] <TimToady> yeah, I suppose, depending on whether you consider the lexpads to be part of the activation record :)

[04:52] <diakopter> each perlesque subroutine also has a 'frame' class, from which its activation records are spawned; those are the lexpads themselves, and also hold links to each's Caller frame

[04:53] *** jaldhar_ left
[04:53] *** jaldhar_ joined
[04:54] <diakopter> sigh.  there's also a 'bind' interface created for each unique subroutine interface, and a 'return' interface created for each unique return type. *sigh* so that it's all still strongly-typed.

[04:54] <diakopter> Yes, OOdles of casting.

[04:55] *** jaldhar_ left
[04:55] <diakopter> s/subroutine interface/subroutine signature/

[04:55] *** jaldhar_ joined
[04:55] <sorear> TimToady: That reminds me of another question I've had for a long time.  Why does Perl 5 have one stack per CV, instead of the more traditional approach of intermixing all activation records on a common stack?

[04:55] <diakopter> someone help the n00b; what's a CV

[04:57] <sorear> the perl 5 data structure which represents a sub or closure instance (or format, but let's not go there)

[04:57] <diakopter> ok

[04:57] <sorear> the target of CODE references

[04:57] *** gfx joined
[04:58] <sorear> s/Perl/perl/

[04:59] *** ReiniUrban joined
[04:59] <diakopter> sorear: that's an interesting question. actually I considered a model something like that

[05:00] * diakopter waits for TimToady comment

[05:00] <diakopter> sorear: I guess that's one way of tracking recursion depth

[05:00] *** justatheory left
[05:01] *** rurban left
[05:01] *** ReiniUrban is now known as rurban

[05:01] <diakopter> oh, I see. the caller link on the last frame must point to the CV itself and not to the top record on that CV's stack.

[05:02] <diakopter> (I'm not saying I know *why* it was done that way)

[05:03] <diakopter> oh

[05:03] <sorear> um, why would anyone want to track recursion depth

[05:03] <diakopter> sorear: another benefit is that it separates the code from the lexpads, so that code can be changed

[05:03] <diakopter> after a frame has been entered

[05:04] <diakopter> I dunno; warnings tracks it, doesn't it?

[05:04] <sorear> activations and code are separated in every model

[05:04] <TimToady> well, last I looked, the CVs themselves were all on their own stack separate from the lexpads, but that might have changed since then

[05:05] <sorear> I'm not asking about CVs

[05:05] <sorear> I'm asking why there are so many padlists

[05:05] <sorear> Why isn't there a single global PL_padstack?

[05:06] *** c1sung left
[05:06] <TimToady> actually, the CX statck

[05:06] <TimToady> *stack

[05:06] <TimToady> one reason for tracking recursion level (besides warning on deep recursion) is that we cache a lexpad at each level

[05:06] <sorear> or, for that matter, the lexicals /could/ have been stored on PL_stack

[05:06] <TimToady> so it's only allocated from the heap the first time we want one at that level

[05:08] <TimToady> Perl 5 keeps a lot of stacks that most other implementations combine

[05:09] <TimToady> you might think of the various stacks as having a rudimentary form of typing

[05:10] <diakopter> hee

[05:10] <diakopter> YA typing layer

[05:10] <TimToady> I don't recommend you do it that way

[05:10] <TimToady> it was mostly driven by trying to fake out C macros to do the right thing

[05:10] <diakopter> me?

[05:11] * diakopter wonders if there are "compile Perl successfully" test cases in C compilers' regression suites

[05:11] <TimToady> that was a major test in gcc, at least at one time

[05:11] * diakopter not surprised

[05:12] <diakopter> seems it would be difficult to break down the tests...

[05:12] <TimToady> at the time, perl put more stress on the compiler than many other open source projects could

[05:13] <TimToady> this was before the big projects we know and love today

[05:13] <diakopter> I guess that's one way to out-lock-in the vendors

[05:14] *** Xaero joined
[05:16] *** molaf joined
[05:16] <sorear> reminds me of the way we used to smoke new DIMMs using gcc before memtest86+ came out

[05:16] <sorear> typically on Linux or Xfree86

[05:17] *** c1sung joined
[05:17] *** XaeroOne left
[05:17] <sorear> "run make World; make realclean in a loop for 24 hours.  Check for cores."

[05:25] *** justatheory joined
[05:33] *** phenny left
[05:34] *** nsh left
[05:34] *** sbp left
[05:35] *** Sarten-X joined
[05:37] *** Maxt0r joined
[05:37] *** nsh joined
[05:37] <Maxt0r> hi

[05:37] *** sbp joined
[05:38] <diakopter> Maxt0r: hi

[05:38] <Maxt0r> i have a problem with a split function am using can anyone hepl plz

[05:38] <Maxt0r> i have a file i open it n read form it as follows :open (FH, $filename) || die ("Could not open $filename!");

[05:39] <Maxt0r> then i pass info to an array :   my @xxx =<FH>;

[05:39] <diakopter> TimToady: you still around?

[05:39] <diakopter> Maxt0r: this is a Perl 6 channel

[05:39] <Maxt0r> foreach $line (<FH>)

[05:39] <Maxt0r> perl 6?^

[05:39] <Maxt0r> whats the dif

[05:39] <Maxt0r> can u help me out?

[05:39] <diakopter> a lot of differences. :)  see perl6.org

[05:40] <Maxt0r> can u help me

[05:40] <Maxt0r> with this quiestion is simple

[05:40] <Maxt0r> my split function is not spliting lols

[05:40] <diakopter> probably #perl can help you out more

[05:40] <Maxt0r> ok

[05:40] <Maxt0r> nvm ty

[05:40] <diakopter> yw

[05:44] <sorear> Where did all the vowels go?

[05:44] <diakopter> gn wth th wnd

[05:45] <diakopter> sorear: check this out :)

[05:45] <diakopter> perlesque: my $last = 4; my $sub_a = sub int foo (int $arg0) { say(my $b = $arg0 + 5); $last = $b; return $b; }; my $sub_b = $sub_a; $sub_b(4); $sub_b = sub int bar (int $arg0) { say(my $b = $arg0 + 4); if ($b>19) { $sub_b = $sub_a; }; $last = $b; return $b; }; while ($last < 100) { $sub_b($last); };

[05:45] <p6eval> perlesque: OUTPUT«9␤13␤17␤21␤26␤31␤36␤41␤46␤51␤56␤61␤66␤71␤76␤81␤86␤91␤96␤101␤»

[05:45] *** fridim left
[05:45] <diakopter> full type inference for expressions

[05:46] <diakopter> (as long as you like either ints or closures) :D  (but yes, it'll work for any CLR type)

[05:46] <diakopter> and those $sub_a and $sub_b variables can store each other's routines, since they have identical signatures.

[05:47] <diakopter> (as you can see, the output series increments by 4 until it's > 19, when it starts incrementing by 5)

[05:47] <diakopter> sorear: cool or what? :)

[05:47] <sorear> I've implemented Damas-Milner

[05:48] <sorear> it's going to take more than /that/ to impress me

[05:48] *** fridim joined
[05:48] <diakopter> it's the closures-as-variables I'm pointing at

[05:50] <diakopter> as soon as I can get type-prototyping working, closures can be arguments and return values, too

[05:50] <diakopter> TimToady: actually that presents a problem for me.

[05:51] <diakopter> I mean, I have an idea to work around it in perlesque, but it'll make it no longer a Perl 6 subset

[05:51] <diakopter> how to represent the types of closures in signatures.

[05:53] <diakopter> in C#, it would be Func<param0_type, param1_type, param2_type, ... , return_type> and Action<param0_type, param1_type, param2_type, ...> for routines that return Void

[05:53] <sorear> I think GRIN might be relevant to you

[05:54] <diakopter> GRIN?

[05:54] *** XaeroOne joined
[05:54] <sorear> the Graph Reduction Intermediate Notation

[05:55] <sorear> a very interesting body of work concerning strongly-typed implementation formulations for higher-order languages

[05:55] <sorear> not /directly/ relevant, you aren't implementing a global superoptimizer for Haskell, but ... has parallels

[05:56] *** Xaero left
[05:56] <diakopter> heh

[05:56] <diakopter> in this case, I just need a notation

[05:57] <jql> hmm... I guess you can't just steal parentheses as function type description notation

[05:59] <diakopter> TimToady will reply sometime...

[05:59] <diakopter> my idea was to use other existing closure variables as prototypes

[06:00] <diakopter> so in the example above, I worked around it by assigning $sub_a a dummy empty routine

[06:01] <jql> hmm, there is a syntax for closure parameter declarations already. spiffy

[06:01] <diakopter> but instead of a typename, if there was some sig_of($other_strongly_typed_closure_with_signature) operator, I could put that in place of the typename in the function signature

[06:01] <diakopter> orly?

[06:01] <diakopter> do tell

[06:01] <jql> my sub testit (&testcode:(Int)) {testcode(12)}

[06:01] <diakopter> oh hah

[06:01] <diakopter> where'd you find that

[06:02] <diakopter> jql: thanks! :)

[06:02] <jql> multi sub t1 (&code:(Str --> Bool)) { 'Str --> Bool' };

[06:02] <jql> return types, too

[06:02] <diakopter> ahh, I see

[06:03] <diakopter> ok, now what if &code and t1 there have types that are mutually recursive

[06:03] * jql whips out the handy book of combinators

[06:03] <jql> I believe.... $math

[06:05] * diakopter waits

[06:07] * diakopter goes to get a drink

[06:07] <jql> hmm... perhaps multi sub t1 (::T, &code:(::T --> ::U)) or some such nonsense

[06:08] <jql> with a --> U at the end

[06:09] <jql> multi sub t1(::T, &code:(T, ::U)) --> U, if that was a valid thing to do. *shrug*

[06:10] <jql> multi sub t1(::T, &code:(T --> ::U)) --> U   # comma is *so* tempting

[06:17] *** Maxt0r left
[06:31] <diakopter> ok

[06:32] <cognominal> nqp: say(<a b c>)

[06:32] <p6eval> nqp: OUTPUT«3␤»

[06:33] <cognominal> nqp: my @a := <a b c>; say(@a)

[06:33] <p6eval> nqp: OUTPUT«3␤»

[06:34] <diakopter> nqp: (<a b c>).say

[06:34] <p6eval> nqp: OUTPUT«Method 'say' not found for invocant of class 'ResizablePMCArray'␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[06:35] <diakopter> /o/

[06:38] <cognominal> nqp: my @a := ('a', 'b', 'c'); say(@a)

[06:38] <p6eval> nqp: OUTPUT«3␤»

[06:39] <cognominal> nqp: my @a := ('a', 'b', 'c'); say(@a[0])

[06:39] <p6eval> nqp: OUTPUT«a␤»

[06:41] *** rv2733 joined
[06:41] *** Exodist_ is now known as Exodist

[06:52] *** rv2733 left
[06:52] *** phenny joined
[07:07] *** gfx left
[07:10] *** finanalyst joined
[07:14] *** Kyril left
[07:19] <finanalyst> perl6: role A { has $.att}; my $x .=new(:att<$y>); say $x.att

[07:19] <p6eval> elf 30402: OUTPUT«Can't call method "att" on an undefined value at (eval 123) line 9.␤ at ./elf_h line 5881␤»

[07:19] <p6eval> ..pugs: OUTPUT«*** No such method in class Item: "&att"␤    at /tmp/Gy8CVyuj6W line 1, column 49 - line 2, column 1␤»

[07:19] <p6eval> ..rakudo 78faa0: OUTPUT«Method 'att' not found for invocant of class 'Any'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[07:20] <sorear> is perl6: just an alias for elf: pugs: rakudo: ?

[07:21] <finanalyst> rakudo: role A {has $.col}; my A $x .= new(:col<$y>); $x.col.say

[07:21] <p6eval> rakudo 78faa0: OUTPUT«$y␤»

[07:21] *** XaeroOne left
[07:21] <sorear> and if so, why no alpha: ?

[07:21] *** XaeroOne joined
[07:22] <finanalyst> it seems to me that $y should be flagged as not having been declared

[07:22] *** cotto_w0rk joined
[07:24] <finanalyst> any one able to comment?

[07:32] *** nsh left
[07:32] *** nsh joined
[07:34] <mberends> finanalyst: the <$y> is equivalent to ('$y'), therefore $y are two literal characters

[07:36] <finanalyst> mberends: thanx, i just realised that too. just as i was writing a rakudobug!

[07:36] <finanalyst> but didnt send it

[07:39] * mberends re-boots to Windows to try process memory monitoring there too

[07:39] *** mberends left
[07:45] *** hicx174 left
[07:52] *** mberends joined
[07:54] *** yahooooo7 joined
[07:55] *** gabiruh_ joined
[07:55] *** cookys_ joined
[07:56] *** diakopte1 joined
[07:56] *** phenny left
[07:56] *** yahooooo left
[07:56] *** cotto left
[07:56] *** cookys left
[07:56] *** Helios left
[07:56] *** diakopter left
[07:56] *** pmurias joined
[07:56] *** frettled_ joined
[07:59] *** Helios joined
[08:00] *** iblechbot joined
[08:11] *** justatheory left
[08:15] *** justatheory joined
[08:17] *** ejs joined
[08:22] *** ejs left
[08:22] *** ejs joined
[08:38] *** pmurias left
[08:48] *** hicx174 joined
[08:49] *** _jaldhar_ joined
[08:50] *** jaldhar_ left
[08:50] *** ejs left
[08:52] *** M_o_C joined
[08:55] *** ejs joined
[08:55] *** ejs left
[08:55] <moritz_> good morning

[08:56] <mberends> good morning moritz_

[09:06] *** justatheory left
[09:17] *** XaeroOne left
[09:19] <finanalyst> rakudo: role A { has $.x = 2; method doit($y) { return $.x * $y } }; my A $z; say $z.doit(1.5)

[09:19] <p6eval> rakudo 78faa0: OUTPUT«Type objects are abstract and have no attributes, but you tried to access ␤current instr.: 'perl6;Attribute;accessor_helper_ro' pc 3554 (src/gen/Attribute.pir:400)␤»

[09:20] <finanalyst> can anyone tell me what I am doing wrong here?

[09:20] <moritz_> finanalyst: you are not creating a new instance of A

[09:20] <moritz_> and still you access $.x, which in turn relies on $!x

[09:20] <moritz_> which is an attributte

[09:21] <finanalyst> isnt the 'my A $z' doing that

[09:21] <moritz_> which you can't access outside of an instance

[09:21] <moritz_> finanalyst: no, that's merely a type constraint

[09:21] <finanalyst> so how does a role become a class?

[09:21] <moritz_> automatically, if you want it

[09:22] <finanalyst> rakudo: role A { has $.x = 2; method doit($y) { return $.x * $y } }; my A $z = .new; say $z.doit(1.5)

[09:22] <p6eval> rakudo 78faa0: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 17293 (src/builtins/Junction.pir:404)␤»

[09:22] <moritz_> rakudo: role A { has $.x = 2; method doit($y) { return $.x * $y } }; my $z = A.new; say $z.doit(1.5)

[09:22] <p6eval> rakudo 78faa0: OUTPUT«3␤»

[09:22] <finanalyst> yep. beat me to it

[09:23] <moritz_> I suspect that's a bug in rakudo

[09:23] <moritz_> rakudo: role A { }; my A $x .= new()

[09:23] <finanalyst> rakudo: role A { has $.x = 2; method doit($y) { return $.x * $y } }; my A $z .= new; say $z.doit(1.5)

[09:23] <p6eval> rakudo 78faa0:  ( no output )

[09:23] <p6eval> rakudo 78faa0: OUTPUT«3␤»

[09:24] <finanalyst> why a bug?

[09:24] <moritz_> I don't see where the type check failure is coming from

[09:24] <moritz_> but I'm not quite awake yet

[09:32] *** jaldhar joined
[09:33] *** _jaldhar_ left
[09:53] *** frettled_ is now known as frettled

[09:57] <moritz_> sorear: (backloggin) yes, perl6: just runs different Perl 6 compilers

[09:58] <moritz_> perl6: say "foo"; # one without differences, I hope

[09:58] <p6eval> elf 30402, pugs, rakudo 78faa0: OUTPUT«foo␤»

[10:06] *** masak joined
[10:07] <masak> oh hai, #perl6

[10:07] <mberends> good masak, morning

[10:07] * masak is having a good morning

[10:08] <masak> GGE now runs all tests under master. \o/

[10:08] <masak> it passes almost half of them, too :)

[10:08] <masak> (as opposed to 100% on alpha)

[10:08] <masak> (well, except for TODOs, of course)

[10:09] <masak> rakudo: role A { has $.x = 2; method doit($y) { return $.x * $y } }; my A $z = .new; say $z.doit(1.5)

[10:09] <p6eval> rakudo 78faa0: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 17293 (src/builtins/Junction.pir:404)␤»

[10:10] <masak> rakudo: class A { has $.x = 2; method doit($y) { return $.x * $y } }; my A $z = .new; say $z.doit(1.5)

[10:10] <p6eval> rakudo 78faa0: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 17293 (src/builtins/Junction.pir:404)␤»

[10:10] <masak> rakudo: class A {}; my A $x .= new

[10:10] <p6eval> rakudo 78faa0:  ( no output )

[10:10] <masak> interesting.

[10:10] <masak> rakudo: class A { has $.x }; my A $x .= new

[10:10] <p6eval> rakudo 78faa0:  ( no output )

[10:10] <masak> rakudo: class A { has $.x = 2 }; my A $x .= new

[10:10] <p6eval> rakudo 78faa0:  ( no output )

[10:11] <masak> oh!

[10:11] <masak> .new

[10:11] <masak> never mind :)

[10:11] <sorear> GGE?

[10:12] <masak> it's a port of PGE to Perl 6.

[10:12] <masak> PGE is pmichaud++'s Perl 6 grammar engine, written in PIT.

[10:13] <masak> *PIR

[10:13] *** snarkyboojum joined
[10:13] <masak> snarkyboojum! \o/

[10:13] <snarkyboojum> masak: hello! o/

[10:13] <masak> snarkyboojum: I might start that 'immediate blocks' branch today in Yapsi.

[10:14] <snarkyboojum> masak: just having fun wasting time getting my new macbook pro up and running - rakudo builds quickly on an i7 :)

[10:14] <masak> ooh, nice.

[10:15] <snarkyboojum> masak: sounds awesome - I'll have to follow along

[10:15] <masak> I'm hoping to keep that branch fairly short-lived.

[10:16] <snarkyboojum> sure

[10:16] <masak> basically just add tests like 'my $a; { ++$a }; say $a', and implement the bare minumum to get it working.

[10:16] <snarkyboojum> would be interesting to watch it in progress however short lived :)

[10:18] <masak> I see it as the big step Yapsi will take this month.

[10:18] <snarkyboojum> masak: feel free to let me know if there is anything I can add or think about

[10:18] <masak> it'll enable a lot of other nice things, including ifs, loops and subs.

[10:19] <masak> snarkyboojum: how's it going with Tardis?

[10:19] <snarkyboojum> masak: ah - looked at it, I'll probably have to bounce stuff of you, as I haven't gotten my hands dirty yet

[10:19] <masak> ah, ok.

[10:20] <snarkyboojum> looked like a rewrite of Tardis.pm

[10:20] <snarkyboojum> etc

[10:20] <masak> aye, seems likely.

[10:20] <masak> and it'll need yet another one when we have nested scopes...

[10:20] <snarkyboojum> excellent - perhaps I can forge ahead and see what I can accomplish/break :)

[10:22] <masak> \o/

[10:31] *** Alias joined
[10:36] *** _jaldhar joined
[10:36] *** jaldhar left
[10:37] *** IllvilJa left
[10:38] <masak> continuing the 'our'/'my' discussion from yesterday: what default scoping do 'regex' et al. have, such that one is now required to add 'our' or 'my' to it to make it stick in an appropriate lexpad?

[10:39] <moritz_> masak: 'has'

[10:39] <sorear> I thought 'regex' could only appear in classes?

[10:39] <masak> moritz_: thought so.

[10:40] <moritz_> sorear: that restricted was lifted for convenience

[10:40] <masak> moritz_: and I suppose that is because they're really methods in sheep's clothing.

[10:41] <moritz_> masak: aye

[10:41] <sorear> moritz_: wasn't you or masak complaining about language bigotry last week on not allowing regex outside grammar

[10:41] <masak> that was I.

[10:42] <masak> it works now, if you do 'my'/'our'.

[10:42] <moritz_> in rakudo?

[10:42] *** iblechbot left
[10:42] <masak> aye.

[10:42] <moritz_> rakudo: our regex foo { '.' }; say '.' ~~ /<foo>/;

[10:43] <p6eval> rakudo 78faa0: OUTPUT«Method 'foo' not found for invocant of class 'Regex;Cursor'␤current instr.: '_block61' pc 613 (EVAL_1:239)␤»

[10:43] <moritz_> rakudo: my regex foo { '.' }; say '.' ~~ /<foo>/;

[10:43] <p6eval> rakudo 78faa0: OUTPUT«Method 'foo' not found for invocant of class 'Regex;Cursor'␤current instr.: '_block65' pc 601 (EVAL_1:229)␤»

[10:43] <masak> hm.

[10:43] <masak> or not.

[10:43] <moritz_> what am I doing wrong? :-)

[10:43] <masak> just too early, I guess. :/

[10:44] <masak> I guess what I'm asking -- and this can be seen as the last throe of my 'bigotry' claim -- is why 'regex' et al. don't default to 'my' scope, and things would work just like they did in alpha.

[10:45] <masak> or, if that helps, they could default to 'my' scope outside of classes and roles, and have 'has' scope inside.

[10:46] <moritz_> because then they couldn't be called as methods, and thus benefit from inheritance

[10:48] <masak> I won't press it. maybe the consistency is important somehow. 'my' is not that hard to remember to add outside of a class, grammar or role.

[10:48] <moritz_> well

[10:48] <moritz_> there are two things where context sensitive defaults would be benefitial

[10:48] <moritz_> 1) multi foo  could default to 'method' inside classes, roles and grammars

[10:49] <moritz_> and default to subs elsewhere

[10:49] <masak> I've had that same thought.

[10:49] <moritz_> 2) regex foo  could default to 'has' inside classes, roles and grammars, and to 'my' everywhere else

[10:49] <masak> it seems we are in violent agreement.

[10:49] <moritz_> that goes against the "list of arbitrary things to remember" rule

[10:50] <masak> I guess so.

[10:50] <masak> one could put those context-sensitive defaults in a module, I guess.

[10:51] <moritz_> use magic::default;

[10:53] <moritz_> on a totally unrelated note I've taken care that Date objects are immutable

[10:53] <moritz_> I guess DateTime objects are not, right?

[10:54] <masak> no, and I thought quite a bit about that.

[10:54] <masak> CPAN's DateTime objects are mutable, and make quite good use of it.

[10:54] <moritz_> aye, I think it makes sense

[10:54] <masak> if you look at the IRC logs, you'll see that my goal was to produce a fairly unchanged subset of CPAN's DateTime :)

[10:55] <masak> I didn't want to break that rule by introducing immutability.

[10:55] <moritz_> Perl 6 has this tendency to keep simple objects immutable, and more complex objects mutable

[10:55] <moritz_> so it kind of fits

[10:55] <masak> also, it was fun to make use of intelligent rw accessors (not yet impl in Rakudo)

[10:57] <moritz_> Mark J. Reed on p6l:

[10:57] <moritz_> my $bday = new Date.new(1968, 5, 5);

[10:57] <moritz_> my $specifically = DateTime.new(:date($bday), :hour(20), :minute(47));

[10:57] <moritz_> or at least, Date should have a method that returns it's value as

[10:57] <moritz_> pairs suitable for passing to DateTime.new.

[10:58] <moritz_> another syntax I thought about was

[10:58] <moritz_> $bday.DateTime(:hour(20), :minute(47))

[10:59] <masak> I think I prefer the DateTime.new version.

[10:59] <moritz_> currently I lean towards DateTime.new(:date($bday), :hour(20), :minute(47)) - but since DateTime is your domain, I want your opinions... right

[10:59] <mberends> this discussion interests me, but I'll be out for a few hours. Happy bikeshedding!

[11:00] *** mberends left
[11:00] <masak> seems the bikeshedding is done already :)

[11:00] <moritz_> mberends: so far we kept the bikeshedding low by having just masak and me discussing it :-)

[11:01] <moritz_> masak: do we still need DateTime.today() then?

[11:01] <masak> oh!

[11:02] <masak> no, we don't. we'll just force people to use .Date :)

[11:02] <masak> or, I suppose Date.new(...)

[11:02] <masak> I wouldn't mind seeing both in that case.

[11:02] <moritz_> what's the ...?

[11:04] <masak> Date.new( $dt ), perhaps.

[11:04] <masak> or some aptly named named :)

[11:04] <moritz_> ok

[11:07] <masak> rakudo: say "foo".subst( /(o)/, { $0.uc } )

[11:08] <p6eval> rakudo 78faa0: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class ''␤current instr.: '!postcircumfix:<[ ]>' pc 10733 (src/builtins/Role.pir:90)␤»

[11:08] <masak> I'd really like for the above to work again by Rakudo Star.

[11:08] <moritz_> again? never did

[11:08] <moritz_> afaict

[11:08] <masak> alpha: say "foo".subst( /(o)/, { $0.uc } )

[11:08] <p6eval> alpha 30e0ed: OUTPUT«fOo␤»

[11:08] <moritz_> huh?

[11:09] <masak> I use it all over the place in my code.

[11:09] <moritz_> rakudo: say "foo".subst( /(o)/, -> $/ { $0.uc } )

[11:09] <p6eval> rakudo 78faa0: OUTPUT«Method 'uc' not found for invocant of class 'Regex;Match'␤current instr.: '_block58' pc 757 (EVAL_1:257)␤»

[11:09] <masak> not cool...

[11:09] <moritz_> aye

[11:09] <masak> but that's not what I meant.

[11:09] <masak> I meant the closure having the correct $/

[11:10] <moritz_> I know

[11:10] *** rgrau joined
[11:14] <lisppaste3> moritz_ pasted "DateTime <-> Date integration" at http://paste.lisp.org/display/97950

[11:14] * masak looks

[11:15] <masak> s/aboved/above/

[11:16] * moritz_ is glad for git rebase -i

[11:16] <masak> it rocks.

[11:16] <moritz_> masak: for a moment I was thinking you meant by patch :-)

[11:17] <masak> :)

[11:17] <masak> moritz_: looks fine. I'm glad Date and DateTime start talking to each other.

[11:17] <Trashlord> hello, friends

[11:17] <masak> moritz_: do you think that it makes sense to keep DateTime mutable but Date immutable?

[11:18] <masak> Trashlord: hi!

[11:18] <moritz_> masak: yes

[11:18] <pugssvn> r30403 | moritz++ | [S32::Temporal] Date <-> DateTime integration 

[11:18] <pugssvn> r30403 | 

[11:18] <pugssvn> r30403 | * DateTime constructor which takes a Date object, as suggested by Mark J. Reed

[11:18] <pugssvn> r30403 | * DateTime.Date coercion method

[11:18] <pugssvn> r30403 | * Remove DateTime.today, since date-only calculations are meant be done by the

[11:18] <Trashlord> what's up?

[11:18] <pugssvn> r30403 |   Date class

[11:18] <pugssvn> r30403 | * Date.new() constructor taking a DateTime object

[11:18] <moritz_> the sun is up

[11:18] <masak> Trashlord: GGE is back up.

[11:18] <masak> (but still fails tests)

[11:18] <Trashlord> I like the sun

[11:19] <masak> I hear the sun is coming back to this hemisphere this summer.

[11:21] <masak> heh, http://github.com/masak/gge/commits/ng-compat

[11:22] <masak> (you can see where my focus has been this month)

[11:22] <pugssvn> r30404 | moritz++ | [t/spec] initial tests for Date, taken from my Date module 

[11:26] *** fridim left
[11:26] *** baisong joined
[11:27] <Trashlord> hey, is there a significant difference between rakudo and pugs?

[11:28] <sorear> yes

[11:28] <masak> both are Perl 6 implementations.

[11:28] <masak> one stopped being in active development three years ago.

[11:28] <sorear> pugs has been undeveloped for several years

[11:29] <masak> even at that point, it was due for a major refactor.

[11:29] <masak> I don't think it ever landed :/

[11:29] <Trashlord> oh

[11:29] <sorear> that's the most common time for software to die

[11:29] <sorear> right when an overhaul is needed

[11:30] <masak> Pugs had a bus number of 1, and though the main dev wasn't hit by a bus, the effect was pretty much that :/

[11:31] <Trashlord> haha

[11:32] <sorear> as compared with Parrot, which has a bus number of 0

[11:32] <masak> Trashlord: no, not much haha at all :/

[11:32] <sorear> the developers are all still here but we don't have a clue what we're working on

[11:33] <sorear> replacing the entire Parrot development team today would have no significant effect

[11:39] <Trashlord> heh

[11:48] <dalek> rakudo: 83650e0 | moritz++ |  (2 files):

[11:48] <dalek> rakudo: first shot at Date

[11:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/83650e0a5f5458a996c0869eb66fdece5d5eefa3

[11:54] <masak> I just had an idea, tried to implement it in Rakudo master, and it worked! \o/

[11:54] <masak> 1. implement a custom data structure, e.g. Tree

[11:54] <masak> 2. implement &map on that data structure

[11:54] <masak> 3. ???

[11:54] <masak> 4. profit!

[11:54] <masak> http://gist.github.com/370183

[11:54] *** wknight8111 joined
[11:55] <moritz_> you know that ??? fail()s? :-)

[11:55] <masak> it didn't in this case :)

[11:55] <masak> I'm thinking whether an example such as this belongs in the book.

[11:55] <masak> it's very self-contained, and it shows something which you can definitely not do easily in Perl 5.

[11:56] <colomon> I think the spec expects you to implement an iterator for the tree, BTW.  :)

[11:56] <masak> colomon: could you produce code that shows how to do that?

[11:56] <masak> I'd be much obliged.

[11:57] *** clintongormley joined
[11:57] <colomon> masak: I don't think I have time at the moment, but if no one has by afternoon I'll give it a try.

[11:57] <masak> nodnod, no rush.

[11:57] <moritz_> rakudo: say 0 cmp 1

[11:57] <jnthn> o/ 

[11:57] <p6eval> rakudo 78faa0: OUTPUT«-1␤»

[11:57] <masak> anytime before 2038 would be good :)

[11:57] <jnthn> masak: Yes, regexes are has scoped

[11:57] <colomon> though in that case, at least with current code, you wouldn't get a tree back.

[11:58] <masak> jnthn: \o

[11:58] <jnthn> masak: The reason <foo> doesn't work yet is that it always goes looking for a method, rather than checking out the lexical scopes first.

[11:58] <colomon> masak++ for picking a good simple project to be exploring at this time.

[11:58] <moritz_> jnthn: so NYI, right?

[11:58] <jnthn> Well, the compiler can go look I guess...

[11:58] <jnthn> moritz_: Correct.

[11:58] <masak> colomon: but wouldn't the resulting &map give you back a Tree?

[11:59] <jnthn> moritz_: I did the first half of the work (making our and my work on regexes).

[11:59] <colomon> masak: no, if it takes a normal iterator, it will give you back a MapIterator, not a Tree.

[11:59] <jnthn> moritz_: Still need to do the next bit.

[11:59] <masak> colomon: I have simple ideas all the time. it's just that some of them turn out to be very difficult in practice :P

[11:59] <colomon> automatically getting back a Tree is something we discussed WRT the hypers, but none of that is implemented yet afaik.

[11:59] *** Trashlord left
[12:00] <masak> colomon: I confess I don't grok MapIterators. do they have to do with laziness?

[12:00] <colomon> yes.

[12:00] <colomon> gotta run now.  more later

[12:02] <masak> anyway, my point was that with a few lines of code I can do map over a Tree, and that's pretty useful.

[12:03] <jnthn> heh, once for === map, that means you'd be able to do a for loop over the tree too. ;-)

[12:03] <masak> o.O

[12:03] <jnthn> Maybe.

[12:03] <jnthn> :-)

[12:04] * masak didn't even think of that

[12:05] <moritz_> ohh

[12:05] <moritz_> I forgot to actually add Date.pm to the repo

[12:05] <moritz_> bad moritz_--, no cookie

[12:06] <moritz_> done that now

[12:11] <dalek> rakudo: 5ab1c03 | moritz++ | src/core/Date.pm:

[12:11] <dalek> rakudo: actually add Date.pm, moritz--

[12:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5ab1c03d4ded2bc90f5ccf3dec656fd8c4973449

[12:12] <moritz_> 82 new tests due to Date.pm

[12:15] *** rv2733 joined
[12:15] * masak uses the slowness of Rakudo to his advantage by starting a script, modifying it, and starting a second, modified version of it

[12:15] *** Trashlord joined
[12:16] *** Trashlord is now known as Guest61693

[12:17] <arnsholt> masak: I'm not entirely sure that counts as an advantage =p

[12:18] <masak> it's one of those conditional advantages, you know :P

[12:18] <masak> at the very least, it helps me find bugs faster than if I weren't doing it.

[12:18] <arnsholt> Heh

[12:20] <masak> hm. it seems I've finally arrived at a test failure which requires me to think about the semantics of the program, as opposed to consmetics-level stuff.

[12:24] <jnthn> oh noes! ;-)

[12:25] <masak> for some reason, the *: quantifier is backtracking. bad, bad quantifier.

[12:27] <moritz_> in GGE, or in nqp?

[12:27] <masak> in GGE.

[12:37] <wknight8111> How do I run the test t/spec/S06-signature/introspection.t?

[12:37] <masak> perl6 t/spec/S06-signature/introspection.t

[12:37] <moritz_> make t/spec/S06-signature/introspection.

[12:38] <masak> but that's a weird use of make

[12:38] <moritz_> masak: not at all

[12:38] <moritz_> masak: it runs fudge if necessary

[12:38] <masak> make specifies the target, not they source.

[12:38] <masak> s/they/the/

[12:39] <moritz_> well, the target is to run that test file

[12:39] <moritz_> s/target/goal/ perhaps

[12:39] <masak> yes, that's the weird bit.

[12:39] <masak> make makes things.

[12:39] <masak> and side effects don't count, usually :)

[12:39] <moritz_> it's only an implementation detail that sometimes there's a .rakudo file involved

[12:39] <wknight8111> build...takes....too.....long.....

[12:39] <moritz_> wknight8111: then speed up parrot :-)

[12:42] *** jaldhar_ joined
[12:43] <wknight8111> Speedups to Parrot aren't going to cut down this build time by too much

[12:43] *** _jaldhar left
[12:43] <jnthn> Why not? The compilers are Parrot programs.

[12:44] <jnthn> That's like saying speedups to Parrot aren't going to cut down any times by too much.

[12:44] <jnthn> Which may be true...but... :-/

[12:45] <wknight8111> how do I jnthn: Speeding up parrot by 50% will speed up the build by at most 50%

[12:45] <wknight8111> to really cut time in that build process, we need to reduce the algorithmic complexity of it

[12:45] <moritz_> well

[12:45] <moritz_> one step is to split the compilation of these .pm files

[12:45] <moritz_> which is non-trivial

[12:46] <jnthn> wknight8111: I think we'd all very happily take a 50% speedup in the build!

[12:46] <masak> moritz_: 'split' in what sense?

[12:46] <moritz_> masak: compile each of them separately

[12:46] <masak> ah, ok.

[12:46] <moritz_> I don't know if it's really going to be faster in sum, but it's much easier to parallelize

[12:46] *** finanalyst left
[12:47] <masak> moritz_: I was thinking along those lines the other day.

[12:47] *** finanalyst joined
[12:47] <masak> moritz_: one things that one could already parallelize quite easily would be compilation of 'leaves', or more exactly, clades in the tree which don't depend on other things.

[12:48] <moritz_> masak: well, they would be all independent, more or less

[12:48] <jnthn> wknight8111: We can surely get the parse time's complexity down, but the grammar action methods I'd be less sure on. I mean, most of them just build ASTs. Stages after that walk said AST to make POST, which is walked to make PIR. Beyond that it's IMCC, which I guess could be sped up some by algorithmic improvements.

[12:49] <moritz_> one thing we could improve is memory footprint by not keeping those $/ around for every node of the parse tree

[12:49] <moritz_> I mean it's enough to store the position inside the string, and the string once

[12:49] <jnthn> Yes, that is certainly true.

[12:51] <jnthn> (I guess you mean "every node of the PAST tree")

[12:54] <moritz_> yes

[12:54] <moritz_> otoh the parse tree still keeps references to those same Match objects

[12:54] <moritz_> so not much gain at all

[12:55] <moritz_> unless we implement parse tree pruning... do we? :-)

[12:55] <jnthn> The trouble is knowing when could you prune.

[12:56] <jnthn> I mean, what if an action method wants to dig a few levels down, etc.

[12:56] * moritz_ kinda hoped that EXPR would be such a boundary

[12:57] <jnthn> That could be a good one.

[12:58] * jnthn afk for a bit

[12:58] *** meppl left
[12:59] *** ReiniUrban joined
[13:00] <masak> sushi &

[13:01] *** rurban left
[13:01] *** ReiniUrban is now known as rurban

[13:02] <wknight8111> mmmm...sushi

[13:03] *** wknight8111 left
[13:03] *** fridim joined
[13:04] *** M_o_C left
[13:06] *** xinming_ joined
[13:08] *** fridim left
[13:19] *** dual left
[13:24] *** iblechbot joined
[13:29] * masak relishes the sushi

[13:33] <masak> moritz_++ # http://trac.parrot.org/parrot/ticket/1560

[13:33] <masak> that's why you were talking about t/spec/S06-signature/introspection.t

[13:38] *** M_o_C joined
[13:38] *** M_o_C left
[13:38] *** M_o_C joined
[13:40] *** M_o_C left
[13:52] *** xinming_ left
[13:54] *** xinming joined
[14:04] *** kfo_ joined
[14:06] *** xinming left
[14:07] *** kfo_ is now known as kfo

[14:12] *** xinming joined
[14:27] *** pmurias joined
[14:27] <pmurias> diakopte1: hi

[14:27] *** dual joined
[14:37] *** snarkyboojum left
[14:59] *** mikehh left
[15:01] *** pmurias left
[15:04] *** iblechbot left
[15:11] * colomon seems to have found the setting on mandelbrot-color.pl that makes it swap even on his big 64-bit Linux box...

[15:12] *** finanalyst left
[15:12] *** finanalyst joined
[15:15] <colomon> It's using up 5.7 GB at the moment.

[15:15] *** justatheory joined
[15:30] <colomon> masak: ping?

[15:30] *** mberends joined
[15:31] <colomon> mberends++ # I think we learned a good bit using your script last night.

[15:31] <mberends> :) current trying to port it to Windows

[15:31] <masak> colomon: pong

[15:32] <colomon> masak: trying to take a quick look at Tree before lunch (while watching the boy).

[15:32] <masak> awesome.

[15:32] <colomon> weirdly, adding does Iterable to Tree breaks everything.

[15:32] *** mikehh joined
[15:32] * masak is in the middle of hunting down a very elusive but possibly disastrous rakudobug

[15:33] <colomon> masak++

[15:33] <masak> the kind I didn't think we had anymore.

[15:33] <colomon> rakudo--

[15:33] <masak> of course, at this stage it might just be masak who deserves that --

[15:33] <masak> we'll see :)

[15:35] <colomon> rakudo++ # iterator works!

[15:36] <colomon> http://gist.github.com/370287

[15:36] <colomon> first time I've ever used a local sub in Perl 6, worked like a charm on the first try.

[15:36] <colomon> :D

[15:39] <colomon> of course, the does Iterable crash seems worrisome.

[15:39] <masak> colomon++ # nice local sub :)

[15:40] <colomon> attempting to get grep to work, but having difficulties.  time for lunch, alas.

[15:43] <finanalyst> rakudo: role A {has $.a; has $.b}; my @x of A; for ^3 { @x[$_] .= new(:a($_*2), :b($_+3))}; for @x {.perl.say

[15:43] <p6eval> rakudo 5ab1c0: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[15:44] <finanalyst> rakudo: role A {has $.a; has $.b}; my @x of A; for ^3 { @x[$_] .= new(:a($_ * 2), :b($_ + 3))}; for @x {.perl.say}

[15:44] <p6eval> rakudo 5ab1c0: OUTPUT«get_pmc_keyed() not implemented in class ''␤current instr.: 'perl6;Positional[::T];postcircumfix:<[ ]>' pc 10553 (src/metamodel/GrammarHOW.pir:44)␤»

[15:44] <finanalyst> rakudo: role A {has $.a; has $.b}; my @x of A; for ^3 { @x[$_]  .= new(:a($_ * 2), :b($_ + 3))}; for @x {.perl.say}

[15:44] <p6eval> rakudo 5ab1c0: OUTPUT«get_pmc_keyed() not implemented in class ''␤current instr.: 'perl6;Positional[::T];postcircumfix:<[ ]>' pc 10553 (src/metamodel/GrammarHOW.pir:44)␤»

[15:47] <finanalyst> rakudo: role A {has $.a; has $.b}; my @x of A; for ^3 { @x[$_]  .= new(:a($_ * 2), :b($_ + 3))}; for @x {$_.b.say}

[15:47] <p6eval> rakudo 5ab1c0: OUTPUT«get_pmc_keyed() not implemented in class ''␤current instr.: 'perl6;Positional[::T];postcircumfix:<[ ]>' pc 10553 (src/metamodel/GrammarHOW.pir:44)␤»

[15:47] <finanalyst> rakudo: role A {has $.a; has $.b}; my @x; for ^3 { @x[$_]  .= A.new(:a($_ * 2), :b($_ + 3))}; for @x {$_.b.say}

[15:48] <p6eval> rakudo 5ab1c0: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[15:48] *** _jaldhar_ joined
[15:48] *** jaldhar_ left
[15:49] <finanalyst> role A {has $.a; has $.b}; my @x; for ^3 { @x.push: A.new(:a($_ * 2), :b($_ + 3)) }; for @x {$_.b.say}

[15:50] <finanalyst> rakudo: role A {has $.a; has $.b}; my @x; for ^3 { @x.push: A.new(:a($_ * 2), :b($_ + 3)) }; for @x {$_.b.say}

[15:50] <p6eval> rakudo 5ab1c0: OUTPUT«3␤4␤5␤»

[15:50] *** justatheory left
[15:52] <finanalyst> Hi anyone. Is there a neater way to instantiate an array of objects other than pushing?

[15:53] <masak> rakudo: my @x = 1, 2, 3; say @x.perl

[15:53] <p6eval> rakudo 5ab1c0: OUTPUT«[1, 2, 3]␤»

[15:53] *** diakopte1 is now known as diakopter

[15:54] <slavik> rakudo: my @arr = "blah" ** 5; say @arr.perl

[15:54] *** baisong left
[15:54] <masak> rakudo: class A {}; my @x = A.new, A.new, A.new; say @x.perl

[15:54] <p6eval> rakudo 5ab1c0: OUTPUT«[0]␤»

[15:54] <p6eval> rakudo 5ab1c0: OUTPUT«[A.new(), A.new(), A.new()]␤»

[15:54] <slavik> rakudo: my @arr = "blah" x 5; say @arr.perl

[15:54] <p6eval> rakudo 5ab1c0: OUTPUT«["blahblahblahblahblah"]␤»

[15:54] <slavik> that way

[15:55] <finanalyst> slavik: see my previous code. Suppose the objects have typed structure

[15:55] *** sorear left
[15:57] *** Kyril joined
[15:57] <finanalyst> rakudo: role A {has $.a; has $.b}; my @x of A; for ^4 { @x[$_] .= new(:a($_ *3), :b($_ + 2)}; say @x.perl

[15:57] <p6eval> rakudo 5ab1c0: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[15:57] <finanalyst>  rakudo: role A {has $.a; has $.b}; my @x of A; for ^4 { @x[$_] .= new(:a($_ *3), :b($_ + 2))}; say @x.perl

[15:57] <p6eval> rakudo 5ab1c0: OUTPUT«get_pmc_keyed() not implemented in class ''␤current instr.: 'perl6;Positional[::T];postcircumfix:<[ ]>' pc 10553 (src/metamodel/GrammarHOW.pir:44)␤»

[15:58] <diakopter> g'morn #perl6

[15:58] *** eternaleye left
[16:00] <masak> diakopter: \i

[16:00] <diakopter> p/

[16:00] <masak> :-w

[16:01] <masak> *shudder* -- I think I just got a glimpse into what combination of circumstances cause this bug to happen.

[16:01] <diakopter> do tell

[16:01] <masak> and why no-one has discovered it until now. :(

[16:01] <diakopter> your theory

[16:01] <masak> my current theory involves references to lexical subs, anonymous subs, reentrancy, and deep nesting.

[16:01] *** sorear joined
[16:02] <masak> I'm minimizing very carefully, but the thing I started from is GGE, so it will probably take all evening or more.

[16:02] <diakopter> ah

[16:02] * diakopter dealt a lot with those things last night perlesque

[16:02] <diakopter> in perlesque

[16:02] <masak> yeah, I saw.

[16:02] <masak> heady stuff :)

[16:05] <diakopter> is it reproducible

[16:05] <diakopter> with a particular pattern in your gge

[16:05] <masak> it is.

[16:05] <masak> want me to push the debug branch?

[16:07] <diakopter> what's the pattern that manifests it

[16:07] <diakopter> or is it every pattern

[16:07] <masak> a+ ** b

[16:07] <diakopter> remind me what ** means plz

[16:08] <masak> in this case, it repeats 'a+' with 'b' as a separator.

[16:08] <masak> but that doesn't matter; the error occurs in the parsing of the regex.

[16:08] <masak> to parse 'b', the regex parser has to call itself.

[16:08] <masak> that seems to be essential to the bug.

[16:10] <diakopter> how does it call itself

[16:10] <dalek> rakudo: 842d2b0 | pmichaud++ | docs/spectest-progress.csv:

[16:10] <dalek> rakudo: spectest-progress.csv update: 391 files, 30643 (79.4% of 38606) pass, 2 fail

[16:10] <dalek> rakudo: Failure summary:

[16:10] <dalek> rakudo: S06-multi/syntax.rakudo 21 - use multi method to override builtin lives

[16:10] <dalek> rakudo: S06-multi/syntax.rakudo 22 - use multi method to override builtin

[16:10] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/842d2b092eaeb6a706d6a3e154ea4b1c283a5da2

[16:10] <masak> ok, so the optable parser works through callbacks, right?

[16:10] * diakopter misses phenny b/c I want to msg pmurias

[16:10] <masak> for example, a sub parse_quantifier that can parse '**' and such.

[16:11] <masak> now, parse_quantifier needs to know where 'b' ends, because it might be a parenthesized expression or something.

[16:12] <masak> so it simply calls the whole regex expression parser with a caveat to stop parsing at the term: level.

[16:12] <diakopter> oh

[16:12] <masak> so, when we're parsing 'b', we're in the p6regex parser calling the optable parser calling parse_quantifier calling the p6regex parser calling the optable parser calling parse_term.

[16:12] * masak exhales

[16:13] <masak> s/ex/in/

[16:13] <masak> and somewhere there, an array that should have contained one element turns out to be empty.

[16:14] <diakopter> any chance it's a parrotbug?

[16:14] <masak> and this under mysterious circumstances, such as it containing the element before a call, and being empty right after the call.

[16:14] <masak> diakopter: dunno, might be.

[16:14] *** takadonet joined
[16:15] <takadonet> morning all

[16:15] <masak> hm, explaining this might actually help me write a minimal example from scratch :)

[16:15] <masak> takadonet: \o

[16:15] <takadonet> I see commit are happening!

[16:15] * takadonet does a git pull

[16:19] <takadonet> masak: what editor do you use for creating Perl6 code?

[16:19] *** rv2733 left
[16:19] <masak> takadonet: vim 7.2

[16:19] *** IllvilJa joined
[16:19] <masak> and I write most prose in Emacs. :)

[16:20] <takadonet> <--- emacser here

[16:20] <diakopter> <--- Notepad++

[16:21] <takadonet> I been installing Padre so at least I will have syntax highlighting

[16:22] <masak> well, I have it too; it's just that it breaks sometimes.

[16:28] <diakopter> referring to http://www.cs.chalmers.se/~boquist/phd/  does anyone know what he means by "forcing of closures"?

[16:30] <masak> something that causes the call target to be unknown at compile time? :)

[16:30] <masak> wouldn't that be more or less all of OO method calls out there?

[16:31] <masak> all polymorphic dispatch, at least.

[16:36] *** masak left
[16:37] *** justatheory joined
[16:38] <diakopter> jql: howdy

[16:49] *** lichtkind joined
[16:51] <lichtkind> cheers

[16:52] <diakopter> hi

[16:52] *** Guest61693 is now known as Trashlord

[16:52] *** Trashlord left
[16:52] *** Trashlord joined
[16:55] *** levengli joined
[17:01] <levengli> is there a library of pm for perl6 in the dist/

[17:05] *** envi^home left
[17:05] *** levengli left
[17:09] <diakopter> I admit: I don't know what dist/ levengli was asking about

[17:18] *** hercynium joined
[17:21] *** wknight8111 joined
[17:23] *** Chillance joined
[17:30] * jnthn looks over the NPW email and is highly amused by the restaurant description "Prikið (burgery-fusion, greasygood, hangover killer meal incl. painkillers)"

[17:30] <jnthn> Including painkillers?!

[17:30] <jnthn> :-)

[17:32] <colomon> jnthn: why does class Tree is Iterable blow up my code?  :)

[17:33] <colomon> (or rather, masak++'s code that I have copied)

[17:33] <jnthn> 'cus Iterable in Rakudo is a class last I checked.

[17:34] *** lichtkind_ joined
[17:34] <colomon> errr... is "is Iterable" not the proper syntax for class derivation?

[17:34] *** lichtkind left
[17:34] *** lichtkind_ is now known as lichtkind

[17:37] <colomon> http://www.harmonyware.com/pictures/big.png

[17:38] <colomon> 1001 x 1001 completed while we were at lunch.  

[17:39] <colomon> took 6.4 GB of memory to compute.

[17:39] *** rv2733 joined
[17:57] <wknight8111> I've learned a lesson today: If I have only 10 minutes to hack, I can't even run a failing Rakudo test case

[17:57] <wknight8111> much less figure out why it fails

[18:06] *** Alias left
[18:06] *** Alias joined
[18:06] <jnthn> colomon: Well, it's certainly pretty. :-)

[18:08] <colomon> FK

[18:08] <colomon> afk

[18:14] <colomon> back.

[18:15] <colomon> I'm quite pleased by the picture, actually.  :)

[18:21] <colomon> with Tree $t: ($t.iterator Z~ 'a'...*).eager.perl.say;

[18:21] <colomon> ("H2Oa", "Hb", "Oc", "Od")

[18:21] <colomon> :)

[18:22] <colomon> If I could just make Tree Iterable, that would be cleaner... ;)

[18:23] *** meppl joined
[18:28] *** iblechbot joined
[18:30] *** hercynium left
[18:34] *** _jaldhar_ left
[18:35] *** _jaldhar_ joined
[18:42] *** _jaldhar_ left
[18:43] *** _jaldhar_ joined
[18:46] *** Kyril left
[18:49] <slavik> colomon: mandebrot ... perl6?

[18:50] <finanalyst> alpha: my @a = 1,2,3,4; for @a[ 1 .. *-1 ] { .say }

[18:50] <p6eval> alpha 30e0ed: OUTPUT«2␤3␤4␤»

[18:51] <finanalyst> rakudo: my @a = 1,2,3,4; for @a[ 1 .. *-1 ] { .say }

[18:51] <p6eval> rakudo 842d2b:  ( no output )

[18:52] <finanalyst> jnthn: is it known that rakudo has stopped liking * in arrays?

[18:54] <arnsholt> Regression from alpha, IIRC

[19:00] *** [synth] joined
[19:02] *** synth left
[19:03] <colomon> slavik: mandelbrot, in perl 6: http://github.com/colomon/mandelbrot

[19:04] <colomon> It is slower than a very slow thing, but it works and is stable.

[19:04] <slavik> colomon: nice :)

[19:04] <colomon> (errr, the color version works, the b&w version probably still needs a tiny bit of work to be ported to the current Rakudo.)

[19:04] <slavik> err

[19:05] <slavik> it's like 20 lines of code ...

[19:05] <slavik> .map is paralell?

[19:05] <colomon> slavik: no.

[19:05] <slavik> :(

[19:05] <colomon> http://perl6advent.wordpress.com/2009/12/17/day-17-making-snowmen/

[19:06] <slavik> colomon: use opengl to draw it?

[19:06] <colomon> that post describes the code, and also the changes needed to make it parallel when Rakudo supports that.

[19:06] <colomon> nope, it just dumps a PPM file to standard output.

[19:06] <slavik> aww

[19:08] <colomon> Hmmm, actually  >>☃ might work now.  I probably need to revisit the code more carefully at some point.  But for this weekend, it's been a great timing / stability / memory usage test.

[19:09] <slavik> colomon: cool stuff :)

[19:10] <colomon> :)

[19:22] *** [synth] is now known as synth

[19:32] *** finanalyst left
[19:37] *** ejs joined
[19:46] <sorear> colomon: 6 GB?  Why?  Memory leak?

[19:47] <colomon> sorear: either that or Parrot / Rakudo is immensely piggy.

[19:48] <colomon> That was actually what I predicted it would take after my tests yesterday, the script seems to need 4MB additional memory every time you increase the edge length of the fractal by 1.

[19:48] <sorear> last time I studied the mandelbrot set, it could be computed in constant space

[19:49] <sorear> my favorite definition of a memory leak is "any bug which increases asymptotic space complexity"

[19:49] <sorear> (never-freed memory was nice until they invented GC)

[19:50] *** nihiliad joined
[19:53] *** molaf left
[19:57] *** pmurias joined
[19:57] <pmurias> diakopter: ping

[19:58] <pmurias> diakopter: how do i submit failing test cases for perlesque? can i get a commit bit? ;)

[20:16] *** eternaleye joined
[20:29] <colomon> sorear: yes, constant space is right.  for this algorithm, each pixel is buffered until a line is done, and then the entire thing is dumped.  its memory usage should be minimal. definitely should not take 6GB.

[20:32] *** justatheory left
[20:49] *** _buno_ joined
[20:54] *** _buno_ left
[20:55] *** _buno_ joined
[20:56] *** _buno_ left
[20:56] <lichtkind> mberends: hai

[20:57] <mberends> hai lichtkind

[20:57] <lichtkind> mberends: howsetging meen

[20:59] <mberends> lichtkind: it's going on Windows today, spelunking the mysterious corridors of the Win32::PerfLib class

[21:00] *** ReiniUrban joined
[21:00] <lichtkind> hm, my new system runs well, im sort of back trying go over 500 today

[21:00] *** wknight8111 left
[21:01] *** rurban left
[21:01] *** ReiniUrban is now known as rurban

[21:04] *** rv2733 left
[21:06] <lichtkind> whats the differens between the bit and bool type?

[21:11] *** buno_ joined
[21:12] <mberends> probably bit is 1 or 0, bool is true or false (this is splitting hairs). numeric versus logical.

[21:13] <lichtkind> i suppose your right

[21:13] <lichtkind> and that some conversion might also be easy

[21:13] <Juerd> Which right? :)

[21:13] <Juerd> lichtkind: s/your/you're/

[21:13] <lichtkind> Juerd: right as in Bool::True

[21:14] <mberends> Juerd: my right ;)

[21:16] <Juerd> I hope you have multiple. :)

[21:16] *** buno_ left
[21:17] *** _buno_ joined
[21:17] <lichtkind> Juerd: i know it you're im just lazy now

[21:18] <mberends> lichtkind: s/it/it's/ s/im/I'm/ ;)

[21:18] <Juerd> s/<after you're>/;/

[21:18] <Juerd> s/$/./  # nit

[21:18] <colomon> I believe Bool is numerical in theory.

[21:19] <colomon> say True

[21:19] <colomon> rakudo: say True # works better with rakudo:

[21:19] <p6eval> rakudo 842d2b: OUTPUT«1␤»

[21:19] <colomon> "numerical", ugh, should be "numeric".

[21:25] *** _buno_ left
[21:26] *** _buno_ joined
[21:26] *** _buno_ left
[21:29] <IllvilJa> Is 'gitpan' the future CPAN?

[21:30] <mberends> no, CPAN will continue in the future, with additions for Perl 6

[21:31] <IllvilJa> ok, so CPAN for released packages and gitpan for development snapshots of them?

[21:31] *** _buno_ joined
[21:32] <mberends> yes. predictions are hard though, particularly those about the future ;)

[21:32] *** _buno_ left
[21:33] <IllvilJa> Yes.  Predictions are overrated, wild speculations will do fine :-D.

[21:37] *** PacoLinux left
[21:37] *** _buno_ joined
[21:38] *** iblechbot left
[21:38] *** _buno_ left
[21:39] *** _buno_ joined
[21:50] *** hercynium joined
[21:54] *** _buno_ left
[21:54] *** _buno_ joined
[21:54] <diakopter> pmurias: hi :)

[21:54] <diakopter> pmurias: yeah; what's your google id

[21:56] *** _buno_ left
[21:56] *** _buno_ joined
[21:57] <sorear> mberends: you beleive in CPAN6?

[21:57] <mberends> sorear: I'll believe it when I see it.

[21:57] * diakopter finally today finished the SF heptary Saga of Seven Suns

[21:58] *** justatheory joined
[21:58] <sorear> ok, we're in agreement there.

[21:59] <diakopter> CPAN is plenty fine good

[22:01] <sorear> IllvilJa: if you ask me, the future lies with metadata-only systems like proto and plumage

[22:02] <diakopter> sorear: I'm staring blankly at the disassembly of ActiveState's perl-clr bridge.

[22:04] <sorear> ooooh

[22:04] <sorear> someone has a reverse engineering project for me?

[22:09] *** cosimo left
[22:12] *** _buno_ left
[22:13] *** _buno_ joined
[22:15] <lue> why hello there

[22:16] <mberends> welcome to our century

[22:16] <diakopter> it's a dark one.

[22:16] <lue> 21st, right?

[22:19] <lue> the DW premiere was awesome. Epic title sequence, epic remodel, and awesome h2g2 reference :)

[22:20] <diakopter> pmurias: you around?

[22:21] <pmurias> diakopter: yes

[22:23] <diakopter> pmurias: should I add your google email address?

[22:24] * mberends discovers he has been asleep for a few minutes. Goodnight o/

[22:24] <pmurias> [email@hidden.address]
[22:24] <pmurias> that's my google id right?

[22:25] <diakopter> I guess :)

[22:25] <diakopter> mberends: :)

[22:25] <pmurias> diakopter: does perlesque have a test suit?

[22:25] <diakopter> no

[22:26] <diakopter> it's only recently attained verifiable input/output status

[22:26] <diakopter> external interaction, I mean

[22:26] <diakopter> as opposed to hosting the tests itself

[22:26] <diakopter> which I hate

[22:26] <pmurias> hosting the tests itself?

[22:27] <pmurias> that means hardcoding ok(...)?

[22:27] <diakopter> I mean, internal tests

[22:28] <diakopter> I think all the tests should be "black box"

[22:28] <diakopter> to spec

[22:29] <diakopter> what's your failing test

[22:29] <diakopter> it's probably just NYI

[22:29] <pmurias> reproducing...

[22:30] <pmurias> sub int foo(int $arg0) {return 4;} fails to parse with a bizare error message

[22:31] <pmurias> diakopter: the parser is hand coded recursive descent?

[22:31] <diakopter> no

[22:31] <diakopter> heh

[22:31] <diakopter> LOL, in fact.

[22:31] <diakopter> you obviously haven't looked at the code :P

[22:32] <diakopter> it's got its own parser generator (which does generate a recursive descent parser, yes)

[22:33] <diakopter> std: sub int foo(int $arg0) {return 4;}

[22:33] <p6eval> std 30404: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/dN6EcgZRmy line 1:␤------> [32msub int [33m⏏[31mfoo(int $arg0) {return 4;}[0m␤    expecting any of:␤        block␤  routine_def␤        trait␤Parse failed␤FAILED 00:01 107m␤»

[22:33] <pmurias> diakopter: the problem is with the lack of the whitespace after foo

[22:33] <diakopter> I know, but I'm curious why std doesn't like it either

[22:34] <diakopter> std: my $a = sub Int foo (int $arg0) {return 4;}

[22:34] <p6eval> std 30404: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/srPya0uZAn line 1:␤------> [32mmy $a = sub Int [33m⏏[31mfoo (int $arg0) {return 4;}[0m␤    expecting any of:␤       block␤  routine_def␤        trait␤Parse failed␤FAILED 00:01 108m␤»

[22:34] <pmurias> std: sub foo(int $arg0) {return 4;}

[22:34] <p6eval> std 30404: OUTPUT«ok 00:01 109m␤»

[22:34] <pmurias> std: int sub foo(int $arg0) {return 4;}

[22:34] <p6eval> std 30404: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/w6p6WacmR2 line 1:␤------> [32mint [33m⏏[31msub foo(int $arg0) {return 4;}[0m␤    expecting any of:␤     bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse failed␤FAILED 00:01 110m␤»

[22:34] <pmurias> std:  sub int foo(int $arg0) {return 4;}

[22:34] <p6eval> std 30404: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/1T5ySTq2vW line 1:␤------> [32msub int [33m⏏[31mfoo(int $arg0) {return 4;}[0m␤    expecting any of:␤        block␤  routine_def␤        trait␤Parse failed␤FAILED 00:01 107m␤»

[22:34] <diakopter> TimToady: consider yourself summoned

[22:35] <diakopter> ok; it's a bug in the grammar, yeah

[22:35] <diakopter> I thought return type went between 'sub' and subname

[22:36] * diakopter goes to look at the Synopsis again

[22:36] *** clintongormley left
[22:37] <pmurias> diakopter: why is a sub name require in a sub declaration?

[22:37] <pmurias> s/declaration/literal/

[22:37] <diakopter> b/c anonymous ones are still NYI

[22:37] <diakopter> :P

[22:37] *** _buno_ left
[22:39] <pmurias> named ones seem a bit unnessesary

[22:42] <pmurias> good night

[22:42] <lue> gnight o/

[22:42] <diakopter> o  /

[22:42] *** pmurias left
[22:46] <lue> afk

[22:48] *** cosimo joined
[22:53] *** mberends_ joined
[22:53] *** mberends left
[23:00] *** Kyril joined
[23:09] *** orafu left
[23:09] *** orafu joined
[23:21] *** astrojp joined
[23:21] <diakopter> got anonymous subs working.

[23:21] <diakopter> heh

[23:22] <colomon> std:  my int sub foo(int $arg0) {return 4;}

[23:22] <p6eval> std 30404: OUTPUT«ok 00:01 111m␤»

[23:22] <diakopter> ahhh.... 

[23:22] *** wknight8111 joined
[23:23] <colomon> std:  our int sub foo(int $arg0) {return 4;}

[23:23] <diakopter> std: my $a = my int sub foo(int $arg0) {return 4;}

[23:23] <p6eval> std 30404: OUTPUT«ok 00:01 109m␤»

[23:23] <p6eval> std 30404: OUTPUT«ok 00:01 110m␤»

[23:23] <diakopter> std: my $a = my int sub (int $arg0) {return 4;}

[23:23] <p6eval> std 30404: OUTPUT«ok 00:01 110m␤»

[23:23] <diakopter> std: my $a = my int sub(int $arg0) {return 4;}

[23:23] <p6eval> std 30404: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my at /tmp/B6ZEE25DRq line 1:␤------> [32mmy $a = my int [33m⏏[31msub(int $arg0) {return 4;}[0m␤    expecting any of:␤    declarator␤       multi_declarator␤ routine_declarator␤       typename␤Parse failed␤FAILED 00:01 108m␤»

[23:23] <diakopter> whew

[23:24] <diakopter> perlesque: my $a = sub (int $b) { say($b); say($b); return 1; }; $a(9); say(10);

[23:24] <p6eval> perlesque: OUTPUT«9␤9␤10␤»

[23:24] <diakopter> o_O

[23:25] <diakopter> I, um, um, 

[23:25] <diakopter> it's supposed to require the sub return type

[23:25] <diakopter> wait

[23:25] *** Grrrr joined
[23:25] <diakopter> perlesque: my $a = sub (int $b) { say($b); say($b); }; $a(9); say(10);

[23:25] <p6eval> perlesque: OUTPUT«9␤9␤»

[23:25] <diakopter> O_O

[23:25] <diakopter> weird.

[23:26] <diakopter> perlesque: my $a = sub (int $b) { say($b); say($b); }; $a(9); say(10);

[23:26] <p6eval> perlesque: OUTPUT«9␤9␤»

[23:26] <diakopter> strange.

[23:26] <diakopter> ooooooo I have an idea

[23:29] <diakopter> oh, interesting; it was infinitely looping b/c it never returned.

[23:29] <diakopter> will fi l8r

[23:29] <diakopter> fix l8r

[23:30] *** p6eval left
[23:30] *** p6eval joined
[23:30] <diakopter> perlesque: my $last = 4; my $sub_a = sub int foo (int $arg0) { say(my $b = $arg0 + 5); $last = $b; return $b; }; my $sub_b = $sub_a; $sub_b(4); $sub_b = sub int bar (int $arg0) { say(my $b = $arg0 + 4); if ($b>19) { $sub_b = $sub_a; }; $last = $b; return $b; }; while ($last < 100) { $sub_b($last); };

[23:30] <p6eval> perlesque: OUTPUT«9␤13␤17␤21␤26␤31␤36␤41␤46␤51␤56␤61␤66␤71␤76␤81␤86␤91␤96␤101␤»

[23:30] <diakopter> perlesquel: runlast

[23:30] <p6eval> perlesquel: OUTPUT«9␤13␤17␤21␤26␤31␤36␤41␤46␤51␤56␤61␤66␤71␤76␤81␤86␤91␤96␤101␤»

[23:30] <diakopter> hee

[23:31] <diakopter> perlesquel: runlast

[23:31] <p6eval> perlesquel: OUTPUT«9␤13␤17␤21␤26␤31␤36␤41␤46␤51␤56␤61␤66␤71␤76␤81␤86␤91␤96␤101␤»

[23:31] <diakopter> there you see the difference two compilation stages makes.

[23:31] <lichtkind> good night your brave ones

[23:33] *** lichtkind left
[23:33] <sorear> what's perlesquel?

[23:33] <diakopter> :D  it just runs the last image perlesque compiled from p6eval input

[23:35] <diakopter> perlesque: loop (my $x=0;$x<100000000;$x+=1) { }; say(939391);

[23:35] <p6eval> perlesque: OUTPUT«939391␤»

[23:35] <diakopter> perlesquel: runlast

[23:35] <p6eval> perlesquel: OUTPUT«939391␤»

[23:35] <diakopter> mmmmm raw speed

[23:46] *** p6eval left
[23:46] *** p6eval joined
[23:47] <diakopter> perlesque: loop (my $x=0;$x<100000000;$x+=1) { }; say(939391);

[23:47] <p6eval> perlesque: OUTPUT«939391␤»

[23:47] <diakopter> perlesquel: runlast

[23:47] <p6eval> perlesquel: OUTPUT«939391␤»

[23:47] <diakopter> hm

[23:54] *** p6eval left
[23:54] *** p6eval joined
[23:55] <diakopter> perlesquel: runlast

[23:55] <diakopter> :/

[23:55] <p6eval> perlesquel: OUTPUT«939391␤real 0.39␤user 0.39␤sys 0.00␤»

[23:55] <diakopter> perlesquel: runlast

[23:55] <p6eval> perlesquel: OUTPUT«939391␤real 0.40␤user 0.37␤sys 0.02␤»

[23:55] <diakopter> oh ok

[23:58] <pugssvn> r30405 | diakopter++ | [evalbot] add perlesquel pseudo-backend (it times the execution and displays the output of the last perlesque p6eval input 

[23:58] <diakopter> )

[23:59] <diakopter> perlesquel: runlast

[23:59] <p6eval> perlesquel: OUTPUT«4␤real 0.05␤user 0.04␤sys 0.00␤»

