[00:01] <dalek> rakudo/master: 6884da0 | jonathan++ | src/core/ (2 files):

[00:01] <dalek> rakudo/master: Bring loads of methods for EnumMap (previously Mapping) and Hash back. Rewrite those that used to be in PIR into Perl 6. Some that don't do mutations but were only in Hash are now in both; I see no good reason for them not to also be in EnumMap.

[00:01] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/6884da05657857e92c5705910c3e655bd3d57334

[00:01] <dalek> rakudo/master: 7452234 | jonathan++ | t/spectest.data:

[00:01] <dalek> rakudo/master: We pass S03-smartmatch/scalar-hash.t again.

[00:01] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/7452234b31048140f7280a7711fb2ed948f6597b

[00:01] <dalek> rakudo/master: 3b44842 | jonathan++ |  (3 files):

[00:01] <dalek> rakudo/master: Move Regex.ACCEPTS to core.

[00:01] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/3b44842b6074339d0f35a6fe06c292dfc66e294d

[00:03] *** nihiliad left
[00:09] *** lue joined
[00:11] <lue> hello! (hello... hello....)

[00:11] <phenny> lue: 23 Feb 12:17Z <colomon> tell lue Looks like you did a nice job on minmax.t.  lue++

[00:12] <bkeeler> heya

[00:13] <lue> aw, thank you phenny ---- I MEAN colomon

[00:18] <bkeeler> % ./perl6 -e 'grammar Foo { token TOP { 'bar'+ }; }; Foo.parse("barbar") && say("Yay, grammars work!");'

[00:18] * quester is trying to grok how sort is deciding on the arity of the by parameter...

[00:19] <quester> rakudo: { $^a.Str }.arity.say; <25 3>.sort( { $^a.Str } ).perl.say;

[00:19] <p6eval> rakudo 9b33a8: OUTPUT«1␤Too many positional parameters passed; got 2 but expected 1␤current instr.: '_block65' pc -1 ((unknown file):-1)␤»

[00:19] <bkeeler> Yay, grammars work!

[00:19] <bkeeler> Now lets see how many grammar tests I can make it pass...

[00:20] *** meppl left
[00:20] <lue> Is grok supposed to be a word like hoopy or frood?

[00:20] <jnthn> quester: I thought it was calling .arity. :-/

[00:20] <bkeeler> it means 'understand compmletely'

[00:20] <jnthn> pmichaud: When around, see ^^ sort fail

[00:20] <bkeeler> From Heinlein, Stranger in a strange land

[00:21] <lue> Froody.

[00:22] <quester> jnthn:  Yes.  Well, actually (&by.?arity // 2).  There was some discussion of that eariler today.  It looks like it should work, but it doesn't.  Or my perl6-fu is deficient....

[00:23] <quester> lue:  What bkeeler said.  In context, "I'm trying to wrap my mind around..."

[00:24] <lue> That's what it seemed like, just making sure. (use words like "frood" and "hoopy" too!)

[00:26] * bkeeler knows where his towel is

[00:26] <lue> I know as well. It's around my neck :)

[00:27] <bkeeler> Is it permissible to define a named regex/rule/token outside of a class or grammar?

[00:28] *** colomon joined
[00:28] <lue> thank you colomon!

[00:29] <colomon> you're welcome.  

[00:29] <colomon> I think you might be right about the isnt tests, too, though I didn't check them all.

[00:30] <lue> yeah, the isnt's for min were basically the is's for max (and vice versa)

[00:31] <colomon> That seems very unnecessary.

[00:31] <lue> maybe in a time far away, someone messed up, and a thoughtful coder put that in in case it ever happens again. The End.

[00:33] <jnthn> Programmers mess up? nah, never happens. :-)

[00:34] <lue> Just "extra features", right? :)

[00:35] <colomon> It does kind of make me wonder how they messed up, that it made since to test that a == 3 and a != 10 in back-to-back tests...  :)

[00:36] <lue> Let's go remove it! (I'm assuming isnt's aren't part of the planned test count)

[00:36] <colomon> They are, but we can make up the count by actually testing that the "3 min 5" form works.

[00:37] <colomon> hmmm....

[00:37] <colomon> rakudo: say 3 min "a"

[00:37] <p6eval> rakudo 9b33a8: OUTPUT«3␤»

[00:37] <colomon> rakudo: say 3 min 20

[00:37] <p6eval> rakudo 9b33a8: OUTPUT«3␤»

[00:38] <colomon> Ah, the numeric comparison only fires if both sides are numbers.

[00:39] <lue> How would you compare a number and a string? String -> Unicode, compare to number?

[00:40] <colomon> There are two "sensible" choices in Perl: treated the number as a string, or the string as a number.

[00:40] <colomon> rakudo: say ~3

[00:40] <p6eval> rakudo 3b4484: OUTPUT«3␤»

[00:40] <colomon> rakudo: say +"a"

[00:40] <p6eval> rakudo 3b4484: OUTPUT«0␤»

[00:40] <colomon> rakudo: say 3 < "a"

[00:41] <p6eval> rakudo 3b4484: OUTPUT«0␤»

[00:41] <lue> rakudo: say 3 > "a"

[00:41] <p6eval> rakudo 3b4484: OUTPUT«1␤»

[00:41] <colomon> because that's +3 < +"a" == 0;

[00:41] <colomon> on the other hand

[00:41] <colomon> rakudo: say 3 gt "a"

[00:41] <p6eval> rakudo 3b4484: OUTPUT«0␤»

[00:42] <colomon> that's ~3 gt ~"a"  (where gt is the string version of >)

[00:42] <colomon> cmp tries to automatically choose the right comparison method, but if there's one number and one string it has to decide which to use.

[00:43] <colomon> apparently it chooses string.

[00:44] <arlinius> rakudo: say 3 cmp "a"

[00:44] <p6eval> rakudo 3b4484: OUTPUT«-1␤»

[00:44] <arlinius> rakudo: say 3 cmp +"a"

[00:44] <p6eval> rakudo 3b4484: OUTPUT«1␤»

[00:45] <diakopter> I guess it chooses the left one

[00:45] <arlinius> rakudo: say "a" cmp 3

[00:45] <p6eval> rakudo 3b4484: OUTPUT«1␤»

[00:45] <arlinius> rakudo: say +"a" cmp 3

[00:45] <p6eval> rakudo 3b4484: OUTPUT«-1␤»

[00:45] <TimToady> out-of-type cmp is not yet specced

[00:46] <bkeeler> TimToady: Is it permissible to define a named regex/rule/token outside of a class or grammar?

[00:46] <TimToady> well, if it doesn't find a metaobject to register it with, it's likely to be unhappy

[00:46] <bkeeler> It is, indeed, unhappy

[00:47] <TimToady> but a my or our method should probably just poke it into the symbol table and then forget about it

[00:47] <bkeeler> 't/spec/S05-grammar/example.t is very unhappy

[00:47] <jnthn> bkeeler: What kind of sad does it has?

[00:47] * jnthn guesses a "oh noes not in a class" sad :-)

[00:48] <dalek> rakudo/master: 90b5153 | jonathan++ | src/ (3 files):

[00:48] <dalek> rakudo/master: Minor optimization to BUILDALL and .can. Takes 10s or so off the spectest run for me.

[00:48] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/90b5153761768b8d07fcb7a8b2a900d236499119

[00:48] <dalek> rakudo/master: a7874a7 | jonathan++ | src/builtins/ (2 files):

[00:48] <dalek> rakudo/master: Rip out the .fixup_cloned_sub macro - we don't need it any more. Should make .clone a tiny, tiny bit cheaper by saving a (useless) check.

[00:48] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/a7874a7c1e07d4975d64a6cd3a7f54058d274106

[00:48] <bkeeler> The metamodel for module refuses to real with adding methods to it

[00:48] <jnthn> Ah, yes.

[00:48] <bkeeler> and named regexes/tokens/etc are methods

[00:48] <jnthn> :-|

[00:48] <jnthn> Yeah...hm.

[00:48] <jnthn> Well, you could make it just shut up whining and throw the thing away

[00:49] <bkeeler> I have a more-or-less working implementation of grammars here, just trying to make tests pass

[00:49] <jnthn> But then we'd not catch methods outside of classes either.

[00:49] <jnthn> Which would sorta suck.

[00:50] <jnthn> TimToady: Only if it's our or my?

[00:50] <jnthn> TimToady: Do regex/rule/token default to "has" scope?

[00:51] <TimToady> yes

[00:51] <TimToady> they're just methods

[00:51] *** constant joined
[00:51] *** constant left
[00:51] *** constant joined
[00:52] * lue is searching for mac keyboard layout pictures *grumble* (third-level specifically)

[00:52] <jnthn> TimToady: Hm

[00:53] <jnthn> TimToady: So we require "our" or "my" to not get a complaint?

[00:53] <jnthn> (or anonymous)

[00:53] *** cdarroch left
[00:53] <TimToady> well, it's sort of a useless declaration if we don't put it somewhere, so probably warrants a warning

[00:54] *** lestrrat is now known as lest_away

[00:54] <bkeeler> We don't seem to support our- or my-scoped methods yet anyhow

[00:54] <jnthn> TimToady: Well, right now we explode rather than warn.

[00:54] <jnthn> bkeeler: Aye, we don't.

[00:55] <bkeeler> I don't even know what they would mean anyway

[00:55] <jnthn> bkeeler: We (also) install them in the package and/or lexpad.

[00:55] <jnthn> Rather than just letting the metaobject know about them.

[00:56] <bkeeler> Don't they end up in the package anyway?

[00:56] <jnthn> No

[00:57] <jnthn> Not my default

[00:57] <jnthn> (alpha got that wrong)

[00:57] *** Chillance left
[00:57] <jnthn> er, by default

[01:00] <bkeeler> Well, I'm just gonna say that example.t needs fixin

[01:01] <lue> Quick, Exegesis man! to the Apocolypse Mobile!

[01:01] <jnthn> bkeeler: Sounds like it.

[01:02] <bkeeler> OK, now I guess need that pugs commit bit ;)  Who's giving them out today?

[01:02] <jnthn> bkeeler: mozem

[01:03] <jnthn> bkeeler: pm me your email address

[01:03] <lue> I would think you could only hand out two commit bits, then you'd have to start a new project :D

[01:03] <jnthn> bkeeler: And your desired username

[01:03] *** yinyin joined
[01:04] <jnthn> bkeeler: Done. :-)

[01:04] <jnthn> bkeeler: You should has a mail shortly.

[01:06] <bkeeler> jnthn: Yep, thanks!

[01:06] <jnthn> \o/

[01:06] <jnthn> ooh, huh, 2am...ok, sleep time :-)

[01:06] <jnthn> catch you all tomorrow

[01:06] <jnthn> er, today :-)

[01:07] <jnthn> o/

[01:07] <bkeeler> \o

[01:07] <bkeeler> Sleep well

[01:07] <bkeeler> Quick break for me too I think

[01:08] *** athenot left
[01:08] <lue> o/

[01:10] *** mssm joined
[01:18] *** f00li5h[HireMe] left
[01:18] *** f00li5h[HireMe] joined
[01:18] *** snarkyboojum joined
[01:22] *** snarkyboojum left
[01:25] *** ggoebel joined
[01:29] *** lest_away is now known as lestrrat

[01:45] <lichtkind> good night

[01:45] *** lichtkind left
[01:59] *** mssm left
[02:02] <lue> Anyone know of a keyboard layout viewer in linux? (bleh...)

[02:03] *** rgrau left
[02:04] <pugssvn> r29812 | lichtkind++ | added myself, inserted 3,4 link before, not only november 

[02:04] *** lichtkind joined
[02:07] *** lichtkind left
[02:07] <arlinius> lue: yeah, cat

[02:10] *** alester left
[02:11] <lue> cat, the console text reader?

[02:12] <TimToady> it's the console text writer--you're the reader

[02:12] <arlinius> it only writes what it reads

[02:13] <arlinius> unless you use -n

[02:13] <arlinius> or -v or similar

[02:13] <lue> something graphical. I can't find a picture of the Apple Keyboard when you press Option (the third-level)

[02:18] *** wknight8111 left
[02:21] *** QtPlatypus left
[02:23] <arlinius> you mean ⌥?

[02:24] <TimToady> well, there's always ⌨

[02:24] <lue> yes. I just need the picture of what keys you get when you press that on a mac layout

[02:25] *** ihrd joined
[02:26] *** ihrd left
[02:27] <lue> Ah well. I wanted to create a raised-eyebrow smiley like: ô.ō , only with something more curved than a circumflex

[02:27] *** ShaneC left
[02:27] <eternaleye> lue: http://www.bohemianalps.com/blog/2009/03/special-characters-in-linux/

[02:28] <eternaleye> It has a diagram of levels 1-4

[02:28] <eternaleye> On an apple keyboard

[02:28] <lue> thank you.

[02:28] <lue> but I wanted level 17 :)

[02:30] *** arlinius joined
[02:33] * lue will go and rewrite minmax.t some more (remove useless isnt's, and so on)

[02:34] *** nbrown left
[02:34] *** nbrown joined
[02:35] <colomon> lue++

[02:36] <lue> should C<$1 min $2> be in S32, or in S03?

[02:37] <colomon> that's a darned good question.

[02:37] *** Exodist joined
[02:37] <colomon> It's a list op... it's actually $1 min $2 min $3 min $4... 

[02:38] <TimToady> it's already in S03

[02:38] <lue> so (for 2+ elements) it's a more cubersome form of min/max ?

[02:38] <colomon> TimToady: lue meant where in the spec tests.

[02:39] <TimToady> 3, I'd think

[02:39] <colomon> I'm inclined to think S03.

[02:39] <lue> me as well, just thought to make sure. So a separate minmax.t file, if it's not already tested?

[02:40] <colomon> Sounds reasonable.

[02:41] <colomon> I didn't find any tests for min / max in S03, except a couple of max= / min= tests.

[02:41] <colomon> TimToady: one thing I've been wondering about min / max.

[02:42] <colomon> As I understand it, the [op] @a metaoperator acts as if you said @a[0] op @a[1] op @a[2]...   right?

[02:42] <TimToady> correct

[02:43] <TimToady> but the latter form is still processed as a list internally, presumably

[02:43] <colomon> Does that imply that [min] @a should only be calling min once, instead of doing pairwise min?

[02:43] <TimToady> since it's list associative

[02:43] <TimToady> might call .min once

[02:44] <TimToady> the method is generally the more basic form

[02:44] *** athenot joined
[02:44] <pugssvn> r29813 | lue++ | [t/spec] removed 4 redundant isnts, bumped no. of tests from 42 to 38 

[02:44] <colomon> Right now in master, infix:<min> just calls .min.

[02:45] <colomon> And I was wondering if [min] should also just be calling .min the once, or if it should be calling it once for each pair in the reduce.

[02:45] <TimToady> there is nothing that forces a list associative operator to be done pairwise

[02:45] <TimToady> so just call .min once, I'd think

[02:46] <colomon> Okay.

[02:46] <colomon> Seems like an extra case for [op] implementation, but a very sensible one.  :)

[02:46] <lue> TimToady: I'm scared of how well the TIMTOWTDI maxim applies in real life (more...)

[02:47] <lue> just today we were using graphing calculators in math. The teacher did stuff one way, I did it another, and thought of TIMTOWTDI.

[02:47] <lue> I think I'm obsessed with P6 now :)

[02:48] <TimToady> colomon: all of the metaops are supposed to be derivative, in theory

[02:48] <TimToady> and all done internally with higher-order functions

[02:48] <TimToady> (or methods)

[02:49] <TimToady> there's no way we can pregenerate all the possible nested metaoperators

[02:49] <colomon> oh, right, sure!  that's supposed to be part of the "ng" / STD magic.  :)

[02:49] <TimToady> there's not just [min], but [min=] and [min]<< and ...

[02:49] *** yinyin left
[02:50] <TimToady> well, maybe [min=] doesn't make a lot of sense

[02:50] <TimToady> generally, assignment doesn't mix well with reduce

[02:50] <TimToady> but [Xmin] is perfectly valid

[02:51] <colomon> I really want to see this stuff working in Rakudo, but I don't have the grammar-fu to get that part of things working.

[02:52] <colomon> I went ahead and implemented .reduce last week just to get a jump on things.  :)

[02:54] <lue> when I _add_ a file to svn, should I run util/add-text-file.sh like the HOWTO says?

[02:55] <colomon> lue: I've never heard of that.  I think I may not have read the HOWTO.  

[02:55] <colomon> (in my defense, it doesn't appear in the Rakudo version of the pugs tests.)

[02:56] <TimToady> yes, that wants to be run

[02:57] <colomon> yeah, it looks like it sets the SVN meta flags properly for a text file.

[02:58] *** athenot_ joined
[02:59] <lue> hey! S03 tells us how to deal with Inf in min/max operators. Basically, +Inf is biggest, -Inf is smallest. Now if it would tell us about NaN...

[02:59] <TimToady> should return NaN, obviously :)

[03:00] *** athenot left
[03:00] *** athenot_ is now known as athenot

[03:01] <lue> That's the problem (I have, at least). Inf is NaN. So...? (philosophical questions FTW)

[03:01] <colomon> lue: NaN essentially means your math has gone wrong, and everything afterward needs to be tainted with NaN.

[03:02] <lue> rakudo: say 1/0

[03:02] <p6eval> rakudo a7874a:  ( no output )

[03:02] <lue> rakudo: say (1/0).perl

[03:02] <p6eval> rakudo a7874a: OUTPUT«1/0␤»

[03:02] <lue> whoops (not familiar with .perl)

[03:02] <lue> rakudo: say (1/0).WHAT

[03:03] <p6eval> rakudo a7874a: OUTPUT«Rat()␤»

[03:03] <lue> methinks that should return NaN :)

[03:03] <lue> or an error. But not ( no output )

[03:03] <eternaleye> rakudo: say (1/0).Num

[03:03] <p6eval> rakudo a7874a: OUTPUT«Divide by zero␤current instr.: 'infix:</>' pc 219201 (src/gen/core.pir:1074)␤»

[03:04] <TimToady> parrot is still a bit exception happy

[03:04] <lue> rakudo: say (1/0) ~~ undef

[03:04] <p6eval> rakudo a7874a: OUTPUT«Unsupported use of undef as a value; in Perl 6 please use something more specific:␤        Mu (the "most undefined" type object),␤   an undefined type object such as Int,␤    Nil as an empty list,␤    *.notdef as a matcher or method,␤ Any:U as a type constraint␤       or

[03:04] <p6eval> ..fail() as a failure return␤       …

[03:04] <eternaleye> lue: Rat just stores numerator and denominator, it's only when you convert it to a lossy type (Num) that it has anything wrong

[03:05] <lue> It should equal undef at least (or the equivalent of)

[03:05] <lue> rakudo: say (1/0) ~~ Mu

[03:05] <p6eval> rakudo a7874a: OUTPUT«1␤»

[03:05] <eternaleye> rakudo: say (1/0).notdef

[03:05] <p6eval> rakudo a7874a: OUTPUT«0␤»

[03:05] <eternaleye> Rat isa Mu, but 1/0 is defined

[03:05] <lue> rakudo: say (1/0) ~~ Inf

[03:05] <p6eval> rakudo a7874a: OUTPUT«Method 'ACCEPTS' not found for invocant of class 'Num'␤current instr.: 'infix:<~~>' pc 212590 (src/gen/perl6-actions.pir:15692)␤»

[03:05] <TimToady> rakudo: say Inf.defined

[03:05] <p6eval> rakudo a7874a: OUTPUT«1␤»

[03:05] <lue> rakudo: say (1/0) == Inf

[03:06] <p6eval> rakudo a7874a: OUTPUT«Divide by zero␤current instr.: 'infix:</>' pc 219201 (src/gen/core.pir:1074)␤»

[03:06] <TimToady> rakudo: say NaN.defined

[03:06] <p6eval> rakudo a7874a: OUTPUT«1␤»

[03:06] <eternaleye> rakudo: say (1/0).Num.WHAT

[03:06] <p6eval> rakudo a7874a: OUTPUT«Divide by zero␤current instr.: 'infix:</>' pc 219201 (src/gen/core.pir:1074)␤»

[03:06] <lue> seems min/max is tested (somewhat) in S03-operators/misc.t

[03:07] <eternaleye> TimToady: Should that return Failure, instead of dying immediately?

[03:07] <eternaleye> Or NaN?

[03:07] <TimToady> or, arguably, Inf

[03:07] <colomon> Or Inf?

[03:07] <colomon> The only problem with Inf as an answer is

[03:07] <colomon> rakudo; say (-1/0).perl

[03:07] <eternaleye> But it shouldn't die immediately, right?

[03:07] <colomon> rakudo:  say (-1/0).perl

[03:07] <TimToady> correct

[03:08] <p6eval> rakudo a7874a: OUTPUT«-1/0␤»

[03:08] <colomon> oh, hey, it does keep the sign!

[03:08] <TimToady> we always try to minimize control flow damage, within reason

[03:08] <eternaleye> The usual answer my math teacher gave was that x/0 isn't inf or -inf, its not defined because it's nonsensical, which places it as NaN

[03:08] <TimToady> because exceptions are death to parallel algorithms

[03:08] <lue> I have half-a-mind to email a math professor at (the UK) Cambridge to settle these questions regarding Inf/NaN/etc.

[03:08] *** lestrrat is now known as lest_away

[03:08] <eternaleye> colomon: Because / is a constructor, rather than performing a mathematical operation

[03:09] <eternaleye> It desugars to Rat.new(-1, 0)

[03:09] <colomon> eternaleye: yes, but Rat.new does a good bit of work internally.

[03:10] <colomon> rakudo: say Inf * sign(-1)

[03:10] <p6eval> rakudo a7874a: OUTPUT«-Inf␤»

[03:10] <lue> I think (x/0)=±Inf and (x/±Inf)=0 , simply because of 1/0.01, 1/0.001, 1/0.0001, etc.

[03:10] <eternaleye> colomon: It still boils down to storing them individually, and -1/0 should skip any simplification code

[03:11] <lue> rakudo: loop (my $i=1; $i=0.000001; $i=$i/10) { say 1/$i; }

[03:11] <p6eval> rakudo a7874a:

[03:11] <p6eval> ..OUTPUT«1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤1000000␤10…

[03:11] <eternaleye> By the way, should there be a 'thinko-catcher' prefix:<...> to catch people who do 1, 2, ... 7 instead of 1, 2 ... 7

[03:12] <eternaleye> ?

[03:12] <lue> that didn't work...

[03:12] <colomon> should be $i==0.0000001

[03:12] <lue> d'oh!

[03:12] <arlinius> rakudo: say 1, 2, ... 7

[03:12] <p6eval> rakudo a7874a: OUTPUT«No exception handler and no message␤current instr.: '&fail' pc 16495 (src/builtins/Junction.pir:364)␤»

[03:12] <lue> rakudo: loop (my $i=1; $i==0.000001; $i=$i/10) { say 1/$i; }

[03:12] <arlinius> rakudo: say 1, 2 ... 7

[03:12] <p6eval> rakudo a7874a:  ( no output )

[03:12] <p6eval> rakudo a7874a: OUTPUT«Method 'succ' not found for invocant of class 'Seq'␤current instr.: '&prefix:<++>' pc 352474 (src/gen/core.pir:49723)␤»

[03:13] <arlinius> rakudo: my ($a, $b); $a = 44, $b = 102; say "$a : $b";

[03:13] <p6eval> rakudo a7874a: OUTPUT«Undefined value shifted from empty array␤current instr.: 'perl6;Perl6Exception;throw' pc 14117 (src/builtins/Seq.pir:52)␤»

[03:13] <arlinius> that should be "44 : 102"?

[03:13] <lue> alpha: loop (my $i=1; $i==0.000001; $i=$i/10) { say 1/$i; }

[03:13] <colomon> arlinius: that's just a case that's not handled yet.

[03:13] <p6eval> alpha 30e0ed:  ( no output )

[03:13] <eternaleye> rakudo: for 1, .1, .01 ... .000001 -> $i { say 1/$i }

[03:13] <p6eval> rakudo a7874a: OUTPUT«Method 'pred' not found for invocant of class 'Seq'␤current instr.: '&prefix:<-->' pc 352536 (src/gen/core.pir:49734)␤»

[03:13] <arlinius> figured

[03:13] <eternaleye> Hm, that's an odd bug

[03:13] <arlinius> pugs: my ($a, $b); $a = 44, $b = 102; say "$a : $b";

[03:14] <p6eval> pugs: OUTPUT«44 : 102␤»

[03:14] <colomon> it's just a ... thing.

[03:14] <TimToady> alpha: for 1, .1, .01 ... .000001 -> $i { say 1/$i }

[03:14] <p6eval> alpha 30e0ed: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤in Main (file <unknown>, line <unknown>)␤»

[03:14] <colomon> there are a lot of cases, and we don't handle that one yet.

[03:14] <eternaleye> pugs: for 1, .1, .01 ... .000001 -> $i { say 1/$i }

[03:14] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "."␤    expecting operator or block construct␤    at /tmp/wjjHms28Mc line 1, column 20␤»

[03:14] <lue> rakudo: loop (my $i=1; $i==0.000001; $i=$i/10;) { say 1/$i; }

[03:14] <p6eval> rakudo a7874a: OUTPUT«Missing block at line 11, near "(my $i=1; "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[03:14] <TimToady> alpha: for 1/1, .1, .01 ... .000001 -> $i { say 1/$i }

[03:14] <colomon> I'm trying to work on a better version, but it's not ready for prime time yet.

[03:14] <p6eval> alpha 30e0ed: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤in Main (file <unknown>, line <unknown>)␤»

[03:14] <colomon> on the other hand.

[03:14] <arlinius> colomon: oh you meant ...

[03:15] <lue> bah! Who knew that was going to be so hard to code :/

[03:15] <arlinius> what about the "$a = 44, $b = 102"?

[03:15] <arlinius> that should work as two assignments, yes?

[03:15] <colomon> rakudo: (1, .1, .01 ... *).batch(6).perl.say

[03:15] <p6eval> rakudo a7874a: OUTPUT«(1, 1/10, 1/100, 1/1000, 1/10000, 1/100000)␤»

[03:15] <TimToady> yes, but rakudo doesn't parse it right, I don't think...

[03:15] <TimToady> so use parens

[03:15] *** daemon left
[03:16] <eternaleye> rakudo: for ( 1, .1, .01 ... .000001 ) -> $i { say 1/$i }

[03:16] <p6eval> rakudo a7874a: OUTPUT«Method 'pred' not found for invocant of class 'Seq'␤current instr.: '&prefix:<-->' pc 352536 (src/gen/core.pir:49734)␤»

[03:17] <lue> rakudo: (1, .1, .01 ... *).batch(6).Num.say

[03:17] <p6eval> rakudo a7874a: OUTPUT«6␤»

[03:17] <lue> |:(

[03:17] <colomon> rakudo: (1, .1, .01 ... *).batch(6)>>.Num.say

[03:17] <p6eval> rakudo a7874a: OUTPUT«10.10.010.0010.00011e-05␤»

[03:17] <colomon> rakudo: (1, .1, .01 ... *).batch(6).>>Num.perl.say

[03:17] <p6eval> rakudo a7874a: OUTPUT«Confused at line 11, near "(1, .1, .0"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[03:18] <colomon> rakudo: ((1, .1, .01 ... *).batch(6).>>Num).perl.say

[03:18] <p6eval> rakudo a7874a: OUTPUT«Confused at line 11, near "((1, .1, ."␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[03:18] <eternaleye> colomon: missing . before Num

[03:18] <colomon> rakudo: (1, .1, .01 ... *).batch(6)>>.Num.perl.say

[03:18] <p6eval> rakudo a7874a: OUTPUT«(1, 0.1, 0.01, 0.001, 0.0001, 1e-05)␤»

[03:18] <lue> rakudo: (1, .1, .01 ... *).batch(12).perl.say; say "take the reciprocal of these fractions"

[03:18] <p6eval> rakudo a7874a: OUTPUT«(1, 1/10, 1/100, 1/1000, 1/10000, 1/100000, 1/1000000, 1/10000000, 1/100000000, 1/1000000000, 1e-10, 1e-11)␤take the reciprocal of these fractions␤»

[03:20] <colomon> ack, I need a perl 6 blog name already...

[03:20] <lue> should I move the min/max related tests from S03-operators/misc.t to a S03-operators/minmax.t file? Or is that unecessary?

[03:20] <colomon> I'd say yes

[03:21] <lue> alright. I'll get to that after I'm done with some work

[03:22] * lue &

[03:24] *** nbrown left
[03:24] * colomon ponders "Rakudo Death Star"

[03:28] <bkeeler> ...and I'm back

[03:28] * TimToady hids

[03:28] <TimToady> hides, even

[03:28] <bkeeler> hehe

[03:28] <TimToady> oops

[03:28] * pmichaud sees TimToady crouching behind a missing 'e'

[03:30] <dalek> rakudo/master: 4f74e3b | (Solomon Foster)++ | src/core/Rat.pm:

[03:30] <dalek> rakudo/master: Make Rat.Num return +/- Inf if the denominator is 0.

[03:30] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/4f74e3b1bb56ecdf31ff2356ff6ae73ae581f5f8

[03:32] <colomon> So I want to make blog posts about work on series, but I don't have a name for my hypothetical Perl 6 blog yet.

[03:32] <pmichaud> ("Rakudo Death Star")  I keep pondering "Rakudo Super Nova", which would tend to imply that it blows up a lot :)

[03:32] <pmichaud> or that it blows everything else away

[03:33] <pugssvn> r29814 | colomon++ | [t/spec] Add tests that Rat.Num properly creates Inf when called for. 

[03:34] <colomon> "Rakudo Nova" has a nice ring to it...

[03:34] <pmichaud> keep in mind that in some languages "Nova" means "doesn't go"  :-)

[03:35] <pmichaud> (more literally, "no va"  :-)

[03:36] <colomon> Rakudo Star Blazers

[03:36] <bkeeler> snopes has an interesting writeup on that whole Chevy Nova thing

[03:36] <arlinius> so it should have been an earlier version?

[03:39] <eternaleye> RakuDo It.

[03:39] <colomon> Just Rakudo It

[03:40] <quester> phenny: tell pmichaud The oddness with sort not working right for an arity-1 "by" function that I mentioned at 1419Z appears to be caused by the underlying Parrot sort being called, rather than the sort in rakudo/src/core/Seq.pm.

[03:40] <phenny> quester: I'll pass that on when pmichaud is around.

[03:40] <TimToady> um, pmichaud is right here

[03:41] *** quietfanatic joined
[03:41] <colomon> need to sleep, unless someone can suggest something better "overnight" will probably go with "Just Rakudo It" in the morning.  :)

[03:41] <TimToady> Smooth Operator

[03:42] <TimToady> Whirled Series

[03:42] <eternaleye> Smooth Operator Hypers Forward

[03:42] <TimToady> Never Metaop I Didn't Like

[03:42] <quester> pmichaud:  Oops, sorry.  I wasn't watching the channel for a few minutes.

[03:42] <pmichaud> and yes, you are correct about the cause (Parrot's sort interfering)

[03:42] <phenny> pmichaud: 03:40Z <quester> tell pmichaud The oddness with sort not working right for an arity-1 "by" function that I mentioned at 1419Z appears to be caused by the underlying Parrot sort being called, rather than the sort in rakudo/src/core/Seq.pm.

[03:43] <pmichaud> I can't fix that immediately -- trying to add it to Parcel.sort will end up in an infinite loop.

[03:43] <pmichaud> I'll fix it first thing tomorrow, or later tonight if I have time/energy

[03:50] *** xinming left
[03:53] <quester> pmichaud:  Thank you.  I don't really need it fixed, I was just trying to explore some of the structure of Rakudo using sort as a starting point.  OTOH, it would be nice if the first example program in the Perl 6 book worked again.

[03:56] <pmichaud> agreed -- almost anything dealing with lists, arrays, etc still needs some cleaning up

[03:57] *** ggoebel left
[04:01] *** agentzh joined
[04:04] *** cognominal left
[04:09] *** cognominal joined
[04:10] <bkeeler> Zounds, the parrot svn seems slow tonight

[04:14] <bkeeler> svn: Can't find a temporary directory: Internal error

[04:14] *** athenot left
[04:15] <bkeeler> Google sez that's a server disk full condition

[04:18] <[particle]> i've notified the parrot hosting admins

[04:18] <[particle]> thanks for reporting!

[04:18] <bkeeler> Sure thing, good to know it's not on my end

[04:39] <lue> (reading backlog) I want to drive a Toyota Nova :D

[04:40] *** agentzh left
[04:50] <lue> are lives_ok {} blocks part of the planned tests count ?

[04:53] *** TiMBuS joined
[04:54] <TimToady> should be

[04:54] <lue> alright. So anything that churns out a result (is, isnt, lives_ok, dies, etc.) are counted as tests then.

[04:55] *** stephenlb left
[04:56] *** cognominal left
[04:57] *** dalek joined
[04:57] <lue> alpha: say 2 min Mu

[04:57] <p6eval> alpha 30e0ed: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤in Main (file <unknown>, line <unknown>)␤»

[04:57] <lue> alpha: say (2 min Mu)

[04:58] <p6eval> alpha 30e0ed: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤in Main (file <unknown>, line <unknown>)␤»

[04:58] <lue> pugs: say (2 min Mu)

[04:58] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "min"␤    expecting operator or ")"␤    at /tmp/zJSmkU2Vf4 line 1, column 8␤»

[05:05] *** cognominal joined
[05:10] *** stephenlb joined
[05:15] <lue> rakudo: say "foo" min +Inf

[05:15] <p6eval> rakudo 4f74e3: OUTPUT«Inf␤»

[05:16] <lue> alpha: say "foo" min +Inf

[05:16] <p6eval> alpha 30e0ed: OUTPUT«sh: ../rakudo-alpha/perl6: No such file or directory␤»

[05:16] *** stephenlb left
[05:23] *** xinming joined
[05:34] <lue> alpha: my @a = 1,2,3,4; my @b = 9,8,7,1; say @a minmax @b

[05:34] <p6eval> alpha 30e0ed: OUTPUT«18␤»

[05:34] <lue> alpha: my @a = 1,2,3,4; my @b = 9,8,7,1; say @(@a minmax @b)

[05:34] <p6eval> alpha 30e0ed: OUTPUT«18␤»

[05:35] <lue> pugs: say 1,2 minmax 9,8

[05:35] <p6eval> pugs: OUTPUT«*** No such subroutine: "&infix:minmax"␤    at /tmp/jSiHUA77mL line 1, column 1 - line 2, column 1␤»

[05:35] <lue> alpha: say 1,2 minmax 9,8

[05:35] <p6eval> alpha 30e0ed: OUTPUT«18␤»

[05:35] *** yinyin joined
[05:37] *** lest_away is now known as lestrrat

[05:38] *** Trashlord joined
[05:39] <lue> rakudo: say (1,2,3) min 4

[05:39] <p6eval> rakudo 4f74e3: OUTPUT«1␤»

[05:40] <TimToady> that doesn't make sense to me

[05:42] <lue> It's supposed to work. I see it as "the minimum value of all provided values is 1)

[05:42] <lue> s/)/"/

[05:43] <lue> It's probably interpreted as 1 min 2 min 3 min 4

[05:44] <lue> rakudo: say (1,2,3) max 4

[05:44] <p6eval> rakudo 4f74e3: OUTPUT«4␤»

[05:45] <lue> It can be used as a quick way to see if there is any value in the array which is too high/low.

[05:46] <lue> Say you have a list of scores out of 5. C<@a max 5> and C<@a min 0> can tell you if an illegal score is reached. (quicker than looping thru elements, anyway)

[05:48] <TimToady> that should be @a >>max>> 5 or some such

[05:49] <TimToady> scalar operators shouldn't be in the business of hypering themselves

[05:52] <lue> If the spec says that's not what should happen, should I tell the test that's not OK? (with isnt or something)

[05:53] <TimToady> looks rather isnt to me

[05:53] <TimToady> that's a cross-type min

[05:53] <TimToady> which, like cross-type cmp, isn't specced yet

[05:54] <TimToady> but chances are if that one worked it would do it with Numeric coercions

[05:54] <TimToady> and +(1,2,3) min 4 is 3

[05:54] <TimToady> as is +(4,5,6) min 4

[05:54] <lue> is there a more blanketing statement than isnt? isnt compares certain values it should not be, and I want it to fail in general.

[05:57] <TimToady> well, but what if it *should* be 3?

[05:57] <TimToady> mind, this is unspecced...

[05:58] <lue> so, for now, it isnt 4. Can live with that :)

[06:04] <lue> alpha: say (1,2,3,4) min (5,6,7,8)

[06:04] <p6eval> alpha 30e0ed: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤in Main (file <unknown>, line <unknown>)␤»

[06:04] <lue> alpha: my @a=(1,2,3,4); my @b=(5,6,7,8); say @a min @b; #I bet this is NYS

[06:04] <p6eval> alpha 30e0ed: OUTPUT«Multiple Dispatch: No suitable candidate found for 'cmp', with signature 'PP->I'␤in Main (file <unknown>, line <unknown>)␤»

[06:07] <lue> alpha: say 1 min 2 max 3; # heh heh, let's give you a workout, alpha

[06:07] <p6eval> alpha 30e0ed: OUTPUT«3␤»

[06:07] <lue> not sure when you'd actually do this, but still...

[06:07] <lue> (maybe I know how it works...)

[06:08] <lue> alpha: say 1 min 4 max 3; #i'm guessing 4

[06:08] <p6eval> alpha 30e0ed: OUTPUT«3␤»

[06:08] <lue> alpha: say 5 min 4 max 3; #i'm guessing 4

[06:08] <p6eval> alpha 30e0ed: OUTPUT«4␤»

[06:08] <lue> \o/ again, not sure if you'd ever need this...

[06:10] <TimToady> it looks left associative, when it should be right

[06:10] <lue> oh! so those would be isnt's...

[06:11] <TimToady> according to S03:85

[06:12] <TimToady> though there's something to be said for list associative with different operators at the same precedence acting like non-associative and forcing parens

[06:12] <lue> for C<5 min 4 max 3> starting from the right still gets you 4...

[06:13] <lue> C<1 min 4 max 3> (from right) gets you 1

[06:14] *** athenot joined
[06:15] <TimToady> yeah, but I may outlaw those entirely

[06:16] <TimToady> I'll probably try making different list-assoc ops non-assoc in STD and see what breaks in t

[06:16] <lue> cause a WTHDYNTF error? (What The Hell Do You Need This For) :)

[06:16] <TimToady> and see if there's a use case that's worth the confusion of allowing it

[06:16] <TimToady> I suspect not

[06:17] <lue> so C<isnt>'s it is!

[06:23] <TimToady> well, it would be compile error, so isnt is too late

[06:23] <lue> It compiles though :)

[06:24] <TimToady> std: 1 but 2 but 3

[06:24] <p6eval> std 29814: OUTPUT«[31m===[0mSORRY![31m===[0m␤"but" is not associative at /tmp/r9MozdwY8i line 1:␤------> [32m1 but 2 but [33m⏏[31m3[0m␤FAILED 00:01 107m␤»

[06:24] <lue> good to have the isnt in there anyway. Can't be too sure.

[06:24] <TimToady> it would fail like that

[06:24] <TimToady> if it doesn't compile, it'll blow up the .t

[06:24] <TimToady> so it needs to be in an eval_dies_ok or some such

[06:24] <TimToady> assuming I change it

[06:26] <lue> so, put it the offending code in dies_ok() brackets? or eval_dies_ok?

[06:30] <TimToady> eval_dies_ok with a string that should parsefail

[06:30] <TimToady> dies_ok isn't good enough to prevent parsefailing the whole *.t

[06:31] <lue> so the usage would be eval_dies_ok{code here}, 'optional string';

[06:33] <lue> .oO(if I knew where TAP was defined, I'd look it up myself...)

[06:33] <TimToady> no, more like eval_dies_ok q{code here}, 'string'

[06:34] <lue> dankon.

[06:34] <TimToady> look at other instances in t/ for examples

[06:51] *** kaare joined
[06:52] *** kaare is now known as Guest7107

[06:55] <pugssvn> r29815 | lue++ | [t/spec] moved min/max related to S03-operators/minmax.t 

[06:56] <pugssvn> r29816 | lue++ | [t/spec] min, max, and minmax operator tests added. 

[06:56] <lue> froody. I'm done for the night. Bye!

[06:56] *** lue left
[07:05] *** cotto left
[07:06] *** cotto joined
[07:26] *** justatheory left
[07:34] *** ihrd joined
[07:39] *** Su-Shee joined
[07:40] <Su-Shee> good morning

[07:48] *** yves joined
[07:52] <spinclad> good morning Su-Shee 

[07:53] *** Sarten-X2 joined
[07:54] *** xabbu42 joined
[08:03] *** cotto left
[08:03] *** iblechbot joined
[08:06] <ewilhelm_> rakudo: say [+] (1..999).grep( { $_ % 3 == 0 || $_ % 5 == 0 } );

[08:06] <p6eval> rakudo 4f74e3: OUTPUT«Confused at line 11, near "say [+] (1"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[08:06] <ewilhelm_> what happened?

[08:08] <pugssvn> r29817 | lwall++ | [S03] list associative treats non-matching ops as non-associative 

[08:10] <ewilhelm_> rakudo: [+] 1..2

[08:10] <p6eval> rakudo 4f74e3: OUTPUT«Confused at line 11, near "[+] 1..2"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[08:10] <spinclad> ewilhelm_: [+] is NYI in master branch, i believe

[08:11] <ewilhelm_> NYI?

[08:11] <spinclad> alpha: say [+] 1..2

[08:11] <p6eval> alpha 30e0ed: OUTPUT«3␤»

[08:11] <pugssvn> r29818 | lwall++ | [STD] make non-matching list assoc into non-assoc 

[08:11] <pugssvn> r29818 |     (and treat invocant colon as really-a-comma for that)

[08:11] <pugssvn> r29818 | [CORE] add TrigBase enum

[08:11] <spinclad> not yet implemented(/invented)

[08:11] <ewilhelm_> hmm, it's the first example in the advent calendar

[08:12] <TimToady> well, it's not advent anymore :)

[08:12] <ewilhelm_> and that says to checkout master http://perl6advent.wordpress.com/2009/12/01/day-1-getting-rakudo/

[08:12] <ewilhelm_> so you take back all the presents on boxing day?

[08:12] <spinclad> master then is now alpha; ng then has become master

[08:13] <TimToady> so everything in the calendar should work with alpha:

[08:13] <TimToady> the new master had some temporary regressions in order to make progress elsewhere

[08:14] <ewilhelm> ah, so working off of alpha would be good for getting feet wet?

[08:15] <spinclad> many improvements in ng; much effort now going into recovering all that was implemented before or never implemented yet

[08:15] <TimToady> depends on which foot you want to get wet :)

[08:15] <spinclad> yes, running alpha is good for stability

[08:16] <ewilhelm> feet of other people in this case

[08:16] <TimToady> but alpha doesn't have laziness

[08:16] <ewilhelm> going to give a talk to a roomful of polyglots tomorrow about why they want to start learning perl 6.

[08:16] <spinclad> there's a lot that's specced that works better in new master though

[08:18] <ewilhelm> is master planned to turn into star?

[08:18] <spinclad> yes

[08:18] <pugssvn> r29819 | lwall++ | [minmax] add some missing semis 

[08:18] <ewilhelm> ok, thanks

[08:20] <spinclad> my pleasure

[08:22] <pugssvn> r29820 | lwall++ | [precedence.t] can no longer have | and ^ at same paren level 

[08:24] <TimToady> std: 1 min 2 max 3

[08:24] <p6eval> std 29816: OUTPUT«ok 00:01 107m␤»

[08:28] *** athenot left
[08:30] *** ihrd left
[08:34] *** jonasbn joined
[08:35] <moritz_> good morning

[08:36] <sjohnson> hi

[08:37] <TimToady> std: 1 min 2 max 3

[08:38] <p6eval> std 29820: OUTPUT«[31m===[0mSORRY![31m===[0m␤"min" and "max" are non-associative and require parens at /tmp/lFFJ6i5J7d line 1:␤------> [32m1 min 2 max [33m⏏[31m3[0m␤FAILED 00:01 107m␤»

[08:38] <TimToady> std: 1 | 2 ^ 3

[08:38] <p6eval> std 29820: OUTPUT«[31m===[0mSORRY![31m===[0m␤"|" and "^" are non-associative and require parens at /tmp/ypuzWGpoRv line 1:␤------> [32m1 | 2 ^ [33m⏏[31m3[0m␤FAILED 00:01 105m␤»

[08:39] <TimToady> std: 1 min 2 min 3

[08:39] <p6eval> std 29820: OUTPUT«ok 00:01 105m␤»

[08:39] <TimToady> std: 1 but 2 but 3

[08:39] <p6eval> std 29820: OUTPUT«[31m===[0mSORRY![31m===[0m␤"but" and "but" are non-associative and require parens at /tmp/A5bbxrpIEi line 1:␤------> [32m1 but 2 but [33m⏏[31m3[0m␤FAILED 00:01 105m␤»

[08:42] <TimToady> std: 1 ..^ 2 ^.. 3

[08:42] <p6eval> std 29820: OUTPUT«[31m===[0mSORRY![31m===[0m␤"..^" and "^.." are non-associative and require parens at /tmp/yMN57nSGGM line 1:␤------> [32m1 ..^ 2 ^.. [33m⏏[31m3[0m␤FAILED 00:01 105m␤»

[08:43] <TimToady> that's enough damage for one night

[08:43] <TimToady> zzz &

[08:44] *** lestrrat is now known as lest_away

[08:57] <ewilhelm> pugs: say -42.fmt('n%+5d')

[08:57] <p6eval> pugs: OUTPUT«-0␤»

[08:57] <ewilhelm> pugs: say (-42).fmt('n%+5d')

[08:57] <p6eval> pugs: OUTPUT«n  -42␤»

[08:59] <ewilhelm> is the method supposed to bind more tightly than the negative?

[09:01] <vorner> ewilhelm: it doesn't look like it binds tighter, it would output -   42 if it would, not -0

[09:01] <moritz_> ewilhelm: method calls are parsed as belonging to the term, and thus have the tightest precedence

[09:02] * vorner doesn't make sense, ignore him, 42.fmt is string…

[09:02] <moritz_> now the only question is if -42 is parsed as <prefix> <number>, or if there's a rule for parsing -42 as a number of its own

[09:03] <moritz_> rakudo: say -42.fmt('n%+5d')

[09:03] <p6eval> rakudo 4f74e3: OUTPUT«Could not find non-existent sub &sprintf␤current instr.: 'perl6;Any;fmt' pc 278993 (src/gen/core.pir:23578)␤»

[09:03] <moritz_> alpha: say -42.fmt('n%+5d')

[09:03] <p6eval> alpha 30e0ed: OUTPUT«-0␤»

[09:04] *** eternaleye left
[09:04] <ewilhelm> alpha: say '-42.3'.fmt('n%+5d')

[09:04] <p6eval> alpha 30e0ed: OUTPUT«n  -42␤»

[09:05] <ewilhelm> where should an Nth-time newbie start reading documentation these days?

[09:07] <moritz_> ewilhelm: maybe at http://github.com/perl6/book/

[09:08] *** dakkar joined
[09:08] <moritz_> it's not yet very complete, but it's rather up-to-date

[09:09] <ewilhelm> ah, thanks

[09:11] *** jferrero joined
[09:15] <ewilhelm> this link to the pugscode svn is broken (needs s/spec/Spec/)  http://perlcabal.org/syn/S01.html

[09:19] *** rv2733 joined
[09:51] <moritz_> ewilhelm: I'll try to find out where that link is generated or set

[09:52] *** yinyin left
[09:54] <pugssvn> r29821 | moritz++ | [Text::SmartLinks] fix case in link to svn as reported by ewilhelm++ 

[09:55] <ewilhelm> thanks

[10:09] <moritz_> it's been updated at the full hour, and now the link works

[10:25] *** pmurias joined
[10:26] *** orafu left
[10:26] *** orafu joined
[10:36] *** lest_away is now known as lestrrat

[10:44] <mathw> Morning

[10:44] <pmurias> mathw: hi

[10:46] <mathw> pmurias!

[10:52] *** payload joined
[11:03] *** TiMBuS left
[11:15] *** jonasbn left
[11:24] <jnthn> morning :-)

[11:24] <jnthn> ...sort of... :-)

[11:25] *** payload left
[11:26] <colomon> o/

[11:26] *** mikehh left
[11:27] *** mikehh joined
[11:29] *** uniejo joined
[11:52] <bbkr> will user be able to extend 'from' sources in this "use libc:from<C>;" syntax? IMO something like "use HTML::Entities:from<git http://github.com/masak/web/blob/master/lib>" would be awesome.

[11:53] <jnthn> :from is more aimed at language names...

[11:53] <jnthn> The adverb form is intended to be pretty extensible though.

[11:53] <jnthn> So :source<http://...> maybe could be made to do something like that.

[11:54] <jnthn> Not quite sure on the mechanism yet.

[11:54] *** arthur-_ joined
[11:55] <bbkr> soo nice! that would make problems with installation and updates obsolete, if user will be able to include current version of library directly from web.

[11:57] <jnthn> Well, presents possibly a performance/security/other issue too of course. :-)

[11:58] *** wanradt__ joined
[11:59] *** wanradt left
[12:07] <bbkr> performance won't be big problem. GIT/SVN revisions can be saved and then checked for updates instead of slurping whole file every time. and security problems can also be solved, a lot can be taken from Java playground and their security model of online services like RMI. not to mention, this online library loading would be useful for "one time jobs" and testing new library versions before installing them on production servers.

[12:07] *** payload joined
[12:07] <colomon> http://justrakudoit.wordpress.com/2010/02/24/series-implementation-i/

[12:08] <jnthn> blog name win!

[12:09] <colomon> Inspired by eternaleye++, tagline by TimToady++

[12:11] *** payload1 joined
[12:11] *** payload left
[12:13] <colomon> Interestingly, editing the wordpress blog really really did not agree with the current OS X version of Google Chrome.  One of the few things I've had difficulty with in Chrome.

[12:17] *** iblechbot left
[12:23] <uniejo> colomon: Nice series operator. I had the idea that the match for next number could be passed down to another multi sub based on arity and colditionals on parameters. That would make it easy to extend with new functions to recognize number sequences.

[12:24] <uniejo> colditionals => conditionals

[12:24] <moritz_> that would need some aditional speccing, but I think the idea isn't too bad

[12:25] <moritz_> it would be awesome if the multi infix:<...> could do that by multi dispatch directly

[12:25] <colomon> uniejo: I was originally working on that theory (see the current series implementation in master) but it seems like it would be a lot more complicated with the way series is spec'd now.

[12:25] <colomon> I guess it could be done with very complicated where clauses...

[12:26] <moritz_> which would slow down dispatch

[12:26] <moritz_> => bad

[12:27] * moritz_ just commented on the blog

[12:27] <colomon> \o/

[12:27] <moritz_> one idea is to have a multi with Code for the RHS

[12:27] <moritz_> and the "magic" series operator could build a closure and re-dispatch to the Code multi

[12:27] <moritz_> that would make it a bit more elegant, and smaller functions

[12:31] <colomon> I'm not sure what you mean by "a multi with Code for the RHS"?

[12:31] <colomon> I can imagine a helper sub that took the seed, the limit, and a Code block...

[12:33] <colomon> (comment read) Oh, I like the idea of making it a Perl 6 project.  Or should it just be a branch of Rakudo?  That might be the easiest way to take advantage of an existing testing framework...

[12:34] *** araujo joined
[12:37] <moritz_> multi infix:<...>(@lhs, Code $rhs)

[12:37] <moritz_> (re project) whatever works best for you

[12:38] <colomon> moritz_: I don't think Code on the rhs is a legal form for ... anymore.

[12:38] <moritz_> oh. I haven't followed all the spec changes closely enough

[12:38] <colomon> (If you take a peak in master's operators.pm, that's exactly how the old code works.)

[12:39] *** cosimo joined
[12:39] <colomon> Code blocks are supposed to be the last item on the lhs now.

[12:39] <colomon> which makes loads more sense, but is trickier for multi dispatch.

[12:41] <colomon> afk # got to get ready to go try to get a loan pre-approval...

[12:42] <jnthn> @lhs where { @lhs[*-1] ~~ Code } # maybe

[12:42] *** colomon left
[12:43] *** cosimo left
[12:43] *** cosimo joined
[12:44] <moritz_> can't you do something like a (@lhs, *$last, $rhs) or so?

[12:44] <moritz_> oh I suppose that slurpies need to go last

[12:46] <jnthn> yeah

[12:47] <moritz_> ([*@most, *$one], $RHS) # signature unpacking?

[12:48] <takadonet> morning all

[12:49] <jnthn> Still need the *@foo to come last.

[12:49] <jnthn> So don't think you can handle it with the unpacking either.

[12:51] <pmurias> how should the optimalising to C backend for mildew be called? i need a short name that can be used like "./mildew -Chere_the_name_will_be_used foo.p6"

[12:52] <moritz_> copt?

[12:52] <jnthn> wick

[12:53] <jnthn> 'cus it's -Cwick :-)

[12:53] <moritz_> or you could steal the -O command line switch from gcc and just call it -CO

[12:53] <mathw> or -CoptC

[12:53] * moritz_ throws beer mugs at jnthn 

[12:53] <mathw> case-sensitive, of course

[12:53] * jnthn catches them and starts slurping away happily

[12:53] <mathw> -Coptic

[12:54] <jnthn> .oO( optimize like an Egyptian... )

[12:58] *** ignacio_ joined
[13:09] *** rvr777 joined
[13:11] *** colomon joined
[13:12] <dalek> rakudo/master: 59c65be | moritz++ | t/spectest.data:

[13:12] <dalek> rakudo/master: re-enable S03-junctions/associative.t

[13:12] <dalek> rakudo/master: review: http://github.com/rakudo/rakudo/commit/59c65be84afc1ffa8fb00fd56d7163724f9aab8f

[13:13] * jnthn likes it when tests Just Start Working again due to other changes. :-)

[13:15] *** quester left
[13:21] *** synth joined
[13:23] *** SmokeMachine joined
[13:27] <mathw> jnthn: optimise like a NES programmer

[13:29] *** SmokeMachine left
[13:32] *** BinGOs left
[13:33] *** BinGOs joined
[13:37] *** BinGOs left
[13:39] *** BinGOs joined
[13:42] *** cjk101010 joined
[13:44] *** cjk101010 left
[13:44] <pmurias> mathw: :)

[13:45] <pugssvn> r29822 | pmurias++ | [mildew] playing around with displaying the AST with gtk (using the yet 

[13:45] <pugssvn> r29822 | unpublished Forest::Gtk2

[13:46] <pugssvn> r29823 | pmurias++ | [mildew] start of implementing -CoptC 

[13:48] *** crazed left
[13:48] * mathw blinks

[13:49] <mathw> you're going with one of my suggestions? Wow.

[13:51] *** crazed joined
[13:51] *** colomon left
[13:59] *** SmokeMachine joined
[14:02] *** xabbu42 left
[14:07] *** ruoso joined
[14:19] <pmurias> ruoso: hi

[14:20] <ruoso> hi pmichaud 

[14:20] <ruoso> hi pmurias 

[14:21] *** rgrau joined
[14:21] <pmurias> ruoso: i started working on generating yeast C code directly (not going through m0ld)

[14:23] <ruoso> cool

[14:23] <ruoso> that's awesome

[14:23] <ruoso> how is it going?

[14:24] <pmurias> emitting calls is left

[14:24] <pmurias> ruoso: under what conditions do you think we could inline {...} instead of emitting a Code.new(...).postcircumfix:()(...)

[14:24] <pmurias> ?

[14:25] *** ggoebel joined
[14:25] <pmurias> ruoso: but it will definitily be done till 26th (deadline on a university project i'm going it as a part of)

[14:34] *** profjuan joined
[14:35] *** profjuan left
[14:36] *** bluescreen joined
[14:36] *** ruoso left
[14:41] *** rv2733 left
[14:43] *** rv2733 joined
[14:44] *** macae joined
[14:44] *** rv2733 left
[14:50] *** rv2733 joined
[14:51] *** rgrau left
[14:52] *** macae left
[14:54] *** ruoso joined
[14:55] * ruoso with a faulty connection

[14:55] <ruoso> pmurias, I'm not sure... because that affects CALLER::

[14:55] <ruoso> and OUTER::

[14:55] <ruoso> you would need to detect too many things

[14:55] <ruoso> (using open source development as university project)++

[15:02] *** xalbo joined
[15:03] <xalbo> The more I think about it, the less comfortable I am with * meaning both Whatever and autocurrying.  They both seem really useful ideas, but it seems like using the same thing for them will probably lead to confusion.

[15:04] <PerlJam> xalbo: or just stop thinking of Whatever and autocurrying as different things :)

[15:05] *** slavik joined
[15:05] *** slavik left
[15:06] <xalbo> In particular, looking at the "False ~~ True" thread, i realized that seeing "when some_function(*) {", we can't know whether that's "autocurry &some_function and invoke it on the topic" or "call &some_function with Whatever as an argument and smartmatch the result against the topic" without looking at the implementation of &some_function.

[15:08] *** crazed left
[15:08] *** crazed joined
[15:08] <xalbo> Unless there's some deeper similarity that i'm missing (* by itself is some form of identity function, or something).

[15:09] <PerlJam> Hmm

[15:13] <PerlJam> That seems similar to the problem with Junctions.

[15:13] <PerlJam> We can't know to autothread a Junction vs. pass the Junction through without looking at the implementation.

[15:14] <PerlJam> really all we need to see is the list of candidates with their signatures.

[15:15] <xalbo> Yes, now that you mention it, it does seem very similar.

[15:15] <ruoso> xalbo, autocurry only happens on operators

[15:16] <xalbo> Really?  Somehow I totally missed that.

[15:16] *** rv2733 left
[15:17] <PerlJam> so the determination for "when * { ... }" must be purely syntactic?

[15:18] <jnthn> some smartmatch uses are syntactic.

[15:18] <jnthn> It'd not surprise me if that one was to be too.

[15:18] <PerlJam> yes, it just hadn't occured to me until just now :)

[15:19] <ruoso> xalbo, "For any unary or binary operator ... if the operator has not specifically requested to handle "*" itself , the compiler is required to translate directly to an appropriately curried closure ... "

[15:19] <PerlJam> The only "probem" in xalbo's universe is the bare * as Whatever vs. autocurry

[15:19] <ruoso> bare * is never autocurry, because it's not on an operator

[15:20] <ruoso> imnsho, "when * { }" is  definitely syntactic

[15:21] <PerlJam> okay, so   foo(*) is always "pass a Whatever to &foo"  ?

[15:21] <ruoso> yes

[15:21] *** Trashlord left
[15:21] <ruoso> (unless I missed something)

[15:22] <PerlJam> &infix:<+>(*)  <-- no curry?

[15:22] <ruoso> and actually a fail, since infix:<+> expects two arguments

[15:22] <PerlJam> er, &infix:<+>(*,1) then

[15:23] * PerlJam is having trouble typing *And* thinking  :)

[15:23] <xalbo> So "* + 2" curries, but "* + 1 + 1" would break?  Interesting.

[15:23] <ruoso> but I'd expect most math operators to actually provide the :(Whatever, Numeric) and :(Numeric, Whatever) multi candidates

[15:24] <PerlJam> xalbo: um ... how do you figure?

[15:24] <ruoso> and also the :(Code, Numeric) and :(Numeric, Code) as to prevent the failure xalbo is trying to indicate

[15:24] <PerlJam> oh

[15:24] <PerlJam> Hmm

[15:25] <ruoso> "* + 1" returns a Code

[15:25] <xalbo> If the operators have to provide all those multis, it feels like something is a little off.  Isn't the point of automatically currying them so that they don't have to do that?

[15:26] <ruoso> yes... specially for user-defined operators

[15:27] *** synth left
[15:27] *** iblechbot joined
[15:27] <ruoso> but built-in operators could be completely defined

[15:28] *** Guest7107 left
[15:28] <pmurias> ruoso: re CALLER variables that don't have is dynamic are hidden

[15:28] <ruoso> pmurias, but that doesn't solve the OUTER:: problem

[15:28] <ruoso> it is certainly a viable optimization

[15:29] <ruoso> but It sure is an optimization, so I'd suggest doing it afterwards

[15:32] *** cosimo left
[15:33] <pmurias> if we kept the lexical scope and only removed the create an new frame it would work

[15:37] <m-locks> rakudo: subset Even of Int where { $_ % 2 == 0 }

[15:37] <p6eval> rakudo 59c65b: OUTPUT«Confused at line 11, near "subset Eve"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[15:38] *** ruoso left
[15:41] *** pmurias left
[15:44] <pmichaud> good morning, #perl6

[15:46] *** synth joined
[15:47] *** Psyche^ joined
[15:49] <jnthn> morning, pmichaud 

[15:49] <m-locks> good evening :)

[15:49] *** rvr777 left
[15:50] <pmichaud> jnthn: got seriously sidetracked last night -- will be roadmapping shortly

[15:50] *** Patterner left
[15:50] *** Psyche^ is now known as Patterner

[15:51] *** pmurias joined
[15:52] <jnthn> pmichaud: No worries, I didn't get around to much last night either.

[15:52] *** ruoso joined
[15:52] *** colomon joined
[15:53] <colomon> jnthn++ # checking in on the git commits this morning...

[15:54] *** nihiliad joined
[15:54] <colomon> errr.... wait, perhaps was checking something from last year... lost in github....

[15:55] <colomon> Oh, only tests turned on so far today.  :(

[15:56] <jnthn> colomon: yes, just some patches from last night

[15:56] <colomon> Somehow I was looking at commits from nearly a year ago, when you checked in a bunch of stuff one morning.

[15:57] <jnthn> huh...I was awake on a morning?

[15:57] *** justatheory joined
[15:57] <colomon> errr... probably not actually morning, even.

[15:57] <jnthn> ;-)

[15:57] <colomon> I just processed it as such because I thought it was "new today".  ;)

[15:57] <colomon> I could kind of desperately use another eight hours of sleep.

[16:01] <jnthn> Today for me is more like, client asks "Why does X take so long?", I look, and answer something like "Oh, becasue to produce this report it does approximately 300,000 SQL queries."

[16:01] <jnthn> (I'm happy to report that the guy who wrote this attrocity has now pursued a non-programming career path...)

[16:03] <pmurias> jnthn: you mean he got promoted to management? ;)

[16:03] <jnthn> pmurias: Oh noes...scary thought! :-)

[16:03] *** justatheory left
[16:07] *** mkyser joined
[16:07] <PerlJam> colomon++ I just saw your post about the series op

[16:08] <pmichaud> url ?

[16:08] <PerlJam> and jnthn++ too because I just tried some signature stuff that I didn't think would work, but it did  :)

[16:08] <PerlJam> pm: http://justrakudoit.wordpress.com/2010/02/24/series-implementation-i/

[16:08] <PerlJam> I like the name too  :-)

[16:08] <PerlJam> Just Rakudo it

[16:08] <pmichaud> Hope Nike's lawyers don't notice :)

[16:08] <PerlJam> although the vowel sounds are a little off, it's still nice

[16:09] <jnthn> PerlJam: What did you try, out of curiosity?

[16:09] * jnthn likes to see what people do with sigs :-)

[16:10] <PerlJam> jnthn: multi sub foo ([$a,$b]) { ... }; multi sub foo([$a,$b,$c]) { ... }

[16:10] <jnthn> oh yes

[16:10] <jnthn> you can multi-dispatch on unpackability. 

[16:10] <PerlJam> jnthn: and I tried using sub foo (*[$a,$b,$c]) { ... } and that worked too

[16:11] <jnthn> omg

[16:11] <jnthn> I'd never thought of trying that :-)

[16:11] <colomon> PerlJam: thanks!

[16:11] <jnthn> PerlJam: Any chance you could site S06-multi/unpackability.t ? ;-)

[16:11] <jnthn> s/site/write/

[16:11] <PerlJam> jnthn: maybe later today, sure.

[16:12] <jnthn> \o/

[16:12] <jnthn> delegation++, PerlJam++

[16:12] *** wanradt_ joined
[16:12] <PerlJam> colomon: btw, the RHS of ... can be a list too 

[16:13] <colomon> PerlJam: yes, I know, but I wanted to start with the "simplest" case first.  :)

[16:13] <PerlJam> okay, just checking

[16:13] <colomon> It's actually worse that that, because you can chain series operators into one op call...

[16:14] <colomon> I don't even know how to declare the signature for that!

[16:15] *** wanradt__ left
[16:17] <colomon> I'm still torn on whether to branch Rakudo to work on series, or create a separate project.  Seems like a branch would be easier, but a separate project would be easier to work with and test.

[16:17] <pmichaud> I think branch (more)

[16:17] <pmichaud> we can do it as a separate project, and I'm happy to do so, but we also need to watch contributors if the code is going to eventually make it into the rakudo repo

[16:17] <pmichaud> i.e., we'd need to make sure the contributors have cla's

[16:18] <colomon> ah, that's a good argument, indeed.

[16:19] <pmichaud> to make that a bit clearer, we could do it as a separate project from the rakudo account instead of from the perl6 account :)

[16:19] <pmichaud> but it seems to me that within the existing rakudo repository is overall simpler

[16:20] *** ash_ joined
[16:21] <pugssvn> r29824 | duff++ | [S03] closure clarification for the LHS of &infix:<...> 

[16:21] <colomon> okay, sounds like a branch it is.

[16:22] <colomon> but I think I might nap first.  :)

[16:22] *** alester joined
[16:22] * PerlJam hopes that his clarification is what was actually meant

[16:23] * colomon is now contemplating a series made of closures...

[16:27] <TimToady> I thought about that, but didn't commit one way or another in the spec.  Requiring a closure to be last is conservative, which is ok for now.

[16:28] <PerlJam> yeah, the other thing was potentially awesome and thorny  :)

[16:29] <PerlJam> (and I'd prefer my programming language not prick my fingers if possible)

[16:36] *** tylerni7 joined
[16:36] *** tylerni7 left
[16:36] *** tylerni7 joined
[16:39] *** kaare_ joined
[16:40] *** ash_ left
[16:47] *** mssm joined
[16:51] <TimToady> xalbo: * + 1 + 1 is intended to autocurry transitively as WhateverCode used to, though perhaps the spec is less than clear on the subject

[16:52] <xalbo> How does it do that?  Does infix:<+>(Code($), Numeric) get automatically defined, or manually, or is there something else that makes it work?

[16:53] <Tene> what about: sub foo($n) { ... }; my $x = &foo + 5; ?

[16:57] *** athenot joined
[16:57] *** justatheory joined
[16:57] <pmichaud> ....did the spec change wrt WhateverCode?  oh dear.

[16:58] *** locsmif joined
[17:00] <pmichaud> +Alternately, for those unary and binary operators that don't care to handle

[17:00] <pmichaud> +C<*> themselves, it is automatically curried at compile time into a closure

[17:00] <pmichaud> +that takes one or two arguments.  (See below.)

[17:00] <pmichaud> Ouch.

[17:02] <jnthn> How do we know at compile time that the operators don't handle it themselves?

[17:02] <jnthn> Or rather, how to those operators declare they will do so?

[17:02] *** ash_ joined
[17:02] <pmichaud> We know all of the signatures for operators in scope.

[17:02] <jnthn> ...

[17:02] <jnthn> *sigh*

[17:03] <pmichaud> You're correct that this is a level of capability that Rakudo doesn't have at present.

[17:03] <jnthn> Well, guess we ain't gonna be doing those in a hurry then.

[17:03] <pmichaud> well, we have to have something in place to be able to handle   @a[*-1]

[17:04] <jnthn> Was the way it used to be really so bad.

[17:04] <jnthn> HOw many times do things have to be re-designed?

[17:04] <jnthn> *sigh*

[17:04] <pmichaud> sure, I see the problems with the old way.  The old way required a ton of function proliferation

[17:04] <PerlJam> jnthn: until their design is "right"  :)

[17:04] <jnthn> I'll wait for one I'd prefer to implement then. :-)

[17:05] <pmichaud> for every operator, we ended up with     (Any, Whatever)   (Whatever, Any)  (Any, WhateverCode)   (WhateverCode, Any)   etc. variants

[17:05] <PerlJam> Perhaps if there were some indication of "feature volatility" within the spec, you could use that to prioritize implementation 

[17:05] <pmichaud> PerlJam: except that's not really the driving force

[17:06] <pmichaud> PerlJam: implementation gets prioritized based on feature need, not volatility

[17:06] <jnthn> pmichaud: Yeah, but you could handle that as a dispatch failure fallback-ish thing, like we do with junction auto-threading.

[17:06] *** ash__ joined
[17:06] <pmichaud> as Tene++ points out above, I am a little concerned about having to now have    infix:<+>(Any, Code)  variants

[17:06] *** cotto joined
[17:07] *** ggoebel left
[17:08] <PerlJam> and user-defined ops would need to do the same or suffer breakage.

[17:08] *** ash_ left
[17:08] *** ash__ is now known as ash_

[17:08] <pmichaud> well, "Code" just seems too unrestrictive -- it grabs a lot of things that don't have anything to do with Whatever currying

[17:08] <jnthn> *nod*

[17:08] <pmichaud> seems like we should still have a WhateverCode type

[17:09] <pmichaud> it's a little difficult to interpret this from the diff -- I should go read the original syn

[17:12] <TimToady> fixing

[17:13] <pugssvn> r29825 | lwall++ | [S02] clarify transitive nature of autocurrying 

[17:13] <pugssvn> r29825 | reintroduce WhateverCode for that purpose

[17:15] <TimToady> that should help some

[17:18] <PerlJam> Arrays still don't interpolate in double quoted strings, right?

[17:18] <pmichaud> in rakudo, not yet

[17:18] <pmichaud> use { }

[17:18] <PerlJam> bummer

[17:18] <pmichaud> "{@array} interpolates."

[17:18] <pmichaud> that might be more fixable with the new grammar, though.

[17:18] <colomon> Seems like we could define infix:<->(Whatever, $a) to return a closure as a quick fix for @a[*-1]  ? 

[17:19] <ruoso> jnthn, as a matter of implementation, you can cheat atm by having all the variants declared

[17:19] <pmichaud> ruoso: yes, and we probably will go with that cheat (as we've done in the past)

[17:19] <pmichaud> but it means that user-defined operators won't work according to spec there

[17:19] <ruoso> (unless you cheat by automatically declaring the variants when the operator is declared)

[17:20] <jnthn> I still don't see the problem with auto-generation on multi-dispatch failure.

[17:20] *** ggoebel joined
[17:20] <ruoso> that would work too

[17:20] <pmichaud> jnthn: it wouldn't fail

[17:20] <ruoso> it's a cheat, tho

[17:20] <pmichaud> Whatever ~~ Any

[17:20] <jnthn> Ah.

[17:20] <jnthn> :-/

[17:20] <ruoso> ah...

[17:20] <ruoso> right

[17:21] * jnthn wonders how much changing that would break, and guesses "far too much"

[17:21] <pmichaud> even if that works,  WhateverCode ~~ Code   and Code ~~ Any

[17:21] <ruoso> but automatically declaring the variants woudl work

[17:21] <jnthn> hmm

[17:32] <TimToady> jnthn: the problem with lazy generation is that it is probably post-optimizer, for any kind of classical optimizer

[17:33] <TimToady> it would also tend to do the wrong thing with hypers and such

[17:33] <pmichaud> I guess the only real reason this "hurts" is that it implies a level of scope detail that we don't have in Rakudo at present, but will ultimately have to have anyway

[17:33] <jnthn> We'll need it for doing optimization stuff.

[17:33] <TimToady> scope detail?

[17:33] <pmichaud> right

[17:33] <jnthn> I just didn't foresee us needing it "soon" as it were.

[17:33] <TimToady> there is specifically not a lexical scope on these

[17:33] <pmichaud> at present we don't have a way of seeing all operator variants from within the compiler

[17:33] <TimToady> ah

[17:33] <jnthn> TimToady: We need to know what variants are in scope.

[17:33] <TimToady> yes, that is assumed

[17:34] <TimToady> which is why multis are defined lexically

[17:34] <jnthn> Right

[17:34] <pmichaud> thus "scope detail"  :-)

[17:35] <TimToady> given that most of our multis end up deferring to underlying methods, I've tried to make it really easy to factor out the multis and inline the primitives where reasonable

[17:35] <pmichaud> agreed there -- this is the first instance I know of where it becomes mandatory :)

[17:36] <TimToady> if everything is lazy, we end up running slower, in the long run

[17:36] <pmichaud> agreed

[17:36] <TimToady> (in the absense of aggressive run-time optimization)

[17:36] <jnthn> Right, that's what bothers me - I'd considered we could put this off until we write an optimizer.

[17:36] <jnthn> Whereas now we kinda can't, plus it's for a feature we really want for R*, I guess.

[17:36] <TimToady> and that's why I keep stressing that lexical multis are fundamental

[17:37] <pmichaud> I'm not (yet?) arguing against the change, just noting that its mandating something we weren't prioritizing at the moment.

[17:37] <jnthn> I never disagreed they weren't.

[17:37] <pmichaud> I suspect our answer will be to cheat on operators/whatever for now (by explicitly declaring the variants, or auto-generating somehow)

[17:37] <jnthn> That isn't the same as making sure the compiler has all such info to hand to make decisions on.

[17:37] <TimToady> well, we can require the trait, and ignore whether any sigs match Whatever

[17:38] <pmichaud> oh, that could work also

[17:38] <TimToady> assuming any op that is *-aware has a proto to hang the trait on

[17:38] <TimToady> seems like a way forward, and possibly cleaner anyway

[17:38] <pmichaud> I think all of our ops ended up with protos anyway, for some other reason.

[17:38] * jnthn does wonder just how much effort it would take to make said info available...

[17:38] <pmichaud> jnthn: definitely worth pondering :-)

[17:39] <jnthn> Well, I guess I was pondering what to do for my next grant. :-P

[17:39] <pmichaud> oooh, that's a good point :)

[17:39] <TimToady> whateverness might just be a role

[17:39] *** colomon left
[17:39] *** ggoebel left
[17:40] <jnthn> Well, I guess I gave us compile-time access (or at least easy potential for having it) for signatures.

[17:41] <pmichaud> and Parrot's conversion of contexts into PMCs makes it easier to follow scopes

[17:41] <jnthn> That sorta helps in that direction.

[17:41] * ruoso .oO( it would be kinda important for every parrot structure to be a PMC )

[17:42] * ruoso .oO( in terms of how far any introspection could go )

[17:42] <pmichaud> oh, one can introspect non-PMCs via opcodes and the like... but yes, having it as a PMC is much more direct and simpler

[17:43] <TimToady> could sure use compact arrays of ints for string/buffer processing though...

[17:43] <ruoso> pmichaud, my point is precisely on how far you can expose the introspection

[17:44] <pmichaud> oh, I suspect we already have a form of "compact array of int" in Parrot.

[17:44] <pmichaud> whether it's sufficient to solve our other needs... I don't know yet.

[17:44] <jnthn> The general case for compact arrays and structs is kinda trickier. :-)

[17:45] <jnthn> We may be able to get away with such for Buf though.

[17:45] <TimToady> well, the PDL folks'll want num arrays

[17:46] <TimToady> and complex...

[17:46] <ruoso> compact arrays can only be used for native types

[17:46] *** ggoebel joined
[17:46] <ruoso> otherwise they're regular arrays

[17:46] <pmichaud> Parrot already has FixedFloatArray (for native nums)

[17:46] <pmichaud> and ResizableFloatArray

[17:46] <jnthn> pmichaud: We may well want a more general approach though.

[17:47] <jnthn> pmichaud: Though they could do for a first cut.

[17:47] <pmichaud> jnthn: right.

[17:47] <ruoso> more general as in "void*" ? ;) ;)

[17:47] <TimToady> strings/buffers under NFG want int8, uint8, int16, uint16, int32 and uint32 arrays

[17:47] <jnthn> ruoso: Or generic type style, etc.

[17:48] <TimToady> the unsigned ones optimized for all precomposed chars (NFC)

[17:49] <jnthn> The Big Thing I'd like to work on post-R* is getting us the native types, compact arrays, compact structs, cheaper attribute access rather than hash lookups all the time, etc. But it's a sizeable chunk of work. :-)

[17:49] <TimToady> the signed optimized for non-precomposed NFG ints represented as negative chars

[17:50] <TimToady> but yes, not necessary for R*

[17:50] <TimToady> presuming we can prevent people from over-using misfeatures as we go forward

[17:52] *** pyrimidine joined
[17:55] *** eternaleye joined
[17:55] <pmichaud> jnthn: in the (2009-08) ROADMAP, which of the "large-scale tasks" do you think are still blockers for us?  (more)

[17:56] <pmichaud> jnthn: I'm thinking only D, G, H, and Z at present are "large-scale tasks".   Most of the others we seem to have addressed.

[17:56] <jnthn> Well taken in reverse, I think these ones are dealt with: A, B, C, maybe F

[17:57] <jnthn> heh, our done and to-do lists mostly are opposites. That's good. :-)

[17:57] <pmichaud> yes

[17:57] <pmichaud> okay, I can work from that

[17:57] <jnthn> oh, I is not really an issue now I guess

[17:57] <jnthn> J matters for R*, IMO.

[17:57] <pmichaud> right, I'm thinking I is "done enough"

[17:57] <pmichaud> good point on J

[17:57] <jnthn> (I done enough) +1

[17:58] <pmichaud> for E, I'm thinking that while we need more work on lexical symbol handling, we now have the correct underlying model

[17:58] <jnthn> E - we need to sort out some more bits of that.

[17:58] * jnthn re-reads it

[17:58] <jnthn> Ah, we've dealt with some aspects of that, eys.

[17:58] <jnthn> *yes

[17:59] <jnthn> WE need lexical classes/lexical roles and lexical symbol importation

[17:59] <pmichaud> I guess there's enough left to do that we should leave it in

[17:59] <jnthn> Yeah, I think so.

[17:59] <pmichaud> okay, I think that covers it well enough

[18:01] <pmichaud> short break for lunch here, then will update ROADMAP

[18:01] *** meppl joined
[18:02] *** bluescreen left
[18:10] *** cami joined
[18:11] <pugssvn> r29826 | lwall++ | [S02] add semilists as Slicel to go with Parcel 

[18:12] <pugssvn> r29827 | lwall++ | [S29] restrict Matcher from taking Bool 

[18:17] *** ShaneC joined
[18:17] *** bluescreen joined
[18:21] *** stephenlb joined
[18:21] *** dakkar left
[18:27] *** ruoso left
[18:27] <pugssvn> r29828 | lwall++ | [S03] when and ~~ to warn on direct use of "True" or "False" 

[18:28] *** jferrero left
[18:28] *** spray left
[18:29] <m-locks> jesus was a perl 6 programmer

[18:29] <TimToady> what, the perl of great price?

[18:30] <m-locks> ;P

[18:43] *** ruoso joined
[18:52] *** hicx174 joined
[19:03] *** Chillance joined
[19:13] *** justatheory left
[19:14] *** cami left
[19:17] *** rv2733 joined
[19:19] *** justatheory joined
[19:20] *** ruoso left
[19:22] *** ggoebel left
[19:22] *** pyrimidine left
[19:22] *** pyrimidine joined
[19:24] *** cotto left
[19:28] *** zpmorgan joined
[19:36] *** ruoso joined
[19:50] *** xabbu42 joined
[19:51] <pmichaud> TimToady: for today's conference call...

[19:51] <pmichaud> my $a;   $a{'foo'} = 3;   # autovivifies array to be a hash ?

[19:52] <pmichaud> (more coming, just a sec)

[19:52] <jnthn> Where was the array?

[19:52] <PerlJam> jnthn: it's an associative array :)

[19:52] <pmichaud> sorry

[19:52] <pmichaud> let me start over....

[19:53] <pmichaud> my $a;  $a{'foo'} = 3;  # autovivifies $a to be a hash ?

[19:53] <pmichaud> my $a = Dog;   my $b = $a{ :name<Fido> };   #  treats $a as a Dog protoobject?

[19:54] <pmichaud> my $a;  my $b = $a{'foo'};   # treats $a as a hash?

[19:56] <pmichaud> on another interesting topic... feather.perl6.nl doesn't seem to be ntp synchronized :)

[19:56] <TimToady> yes, no, fail

[19:57] <TimToady> WHENCE is special syntax with a name, I think

[19:57] <pmichaud> okay, I'm lost.    Dog{ :name<Fido> }   is syntactic?

[19:57] <pmichaud> okay.

[19:57] <TimToady> yes

[19:58] <jnthn> Is there a non-syntactic-only form too?

[19:58] <jnthn> s/-only//

[19:58] <pmichaud> but WHENCE ...

[19:58] <jnthn> That is, does the syntactic form desugar to something?

[19:59] <jnthn> Hmm...

[19:59] <TimToady> something mentioning WHENCE explicilty

[19:59] <jnthn> :-)

[19:59] <pmichaud> $x but WHENCE( { :name<Fideo> } )   # according to S12

[19:59] <jnthn> Ah, ok

[19:59] <jnthn> wfm, I think. :-)

[19:59] <pmichaud> *Fideo

[19:59] <pmichaud> grrr

[19:59] <pmichaud> *Fido

[20:00] *** athenot left
[20:00] <pmichaud> phone

[20:02] *** s1n joined
[20:04] *** ignacio_ left
[20:04] *** ignacio_ joined
[20:14] *** daemon joined
[20:18] *** uniejo left
[20:23] <pugssvn> r29829 | pmurias++ | [mildew] method calls are emitted in -CoptC 

[20:31] *** ggoebel joined
[20:34] <pmichaud> TimToady: oh, I just remembered a question...

[20:35] <pmichaud> your notes say that variables default to "Any" type -- do you mean this as   "my $a"   is the same as "my Any $a"?

[20:35] <TimToady> too late :)

[20:35] <TimToady> yes

[20:35] <pmichaud> earlier when we were discussing this, I had been thinking that  variables would still be type-constrained as Mu but would be initialized to Any

[20:35] <pmichaud> (which is what rakudo alpha effectively does)

[20:36] <pmichaud> and "type constrained as Mu"  means effectively "unconstrained"

[20:36] <pmichaud> so,   my $a;  is similar to   my Mu $a = Any

[20:36] <TimToady> any reasoning other than performance?

[20:37] <pmichaud> well, then the following remains valid:

[20:37] <pmichaud>     my $a = 2|3;

[20:37] <pmichaud> if we constrain $a to Any, then one cannot assign Junctions to variables w/o explicitly declaring they're allowed.  (Perhaps that's a desirable feature, though.)

[20:38] <TimToady> I was thinking of it as potentially a feature.

[20:38] <pmichaud> it does mean that a function can't return a junction to you unless you're explicitly willing to accept it :-)

[20:39] <pmichaud> I'm guessing the same holds for arrays;  i.e.,   my @array;  is actually    my @array of Any;   ?

[20:39] <TimToady> yes, well, that is arguably a feature to everyone but Damian :)

[20:39] *** mberends joined
[20:39] <pmichaud> okay, we'll try it with the constraint then.

[20:40] <TimToady> can always relax it later

[20:40] <pmichaud> yes, it does impose some extra performance overhead

[20:40] <pmichaud> don't know if it'll be significant

[20:40] <jnthn> I guess we'd better set "Any is the default type" in signatures like my ($x, $y) := foo(); too for consistency.

[20:40] <jnthn> (They default to Mu now.)

[20:40] <pmichaud> yes, there also.

[20:41] <jnthn> pmichaud: If you're doing it, it's a one-line add. :-)

[20:41] <pmichaud> not doing it yet -- working on roadmap and hackathon planning first

[20:41] <jnthn> OK, sure. :-)

[20:41] <pmichaud> I just had the question arise during the call and meant to ask but forgot :)

[20:44] *** rhuxton joined
[20:44] <TimToady> I suspect my next spec issue is to figure out how cmp/min/max/etc. can consistently deal with type mismatches and unorderable types

[20:44] <pmichaud> +1 

[20:45] <TimToady> consistency may be antithetical to dwimminess, however

[20:45] <TimToady> people expect all the numbers to sort like Reals

[20:46] <TimToady> then there's the little matter of strings that look like numbers

[20:47] <TimToady> the expectations themselves are likely insane

[20:49] <m-locks> btw what compiler supports subsets?

[20:49] <m-locks> now referring to http://gist.github.com/244255

[20:49] <jnthn> Rakudo's alpha branch does.

[20:49] <jnthn> They ain't back in master yet.

[20:49] <m-locks> umm ok

[20:50] <pyrimidine> ran into this myself just yesterday (lack of subsets in master)

[20:50] <m-locks> i was playing around with it and thought i broke something cos rakudo got confused, but its all good

[20:51] <m-locks> hmm i better get that alpha too just to be sure

[20:53] *** ruoso left
[20:55] <m-locks> hmm the .git file apparently points to master amirite?

[20:55] *** hercynium joined
[20:55] <m-locks> how do i get that alpha

[20:56] <PerlJam> m-locks: git checkout -b alpha -t origin/alpha

[20:56] <jnthn> git checkout origin/alpha

[20:56] <m-locks> thx

[20:56] <PerlJam> m-locks: Mine's just a more verbose version of what jnthn said.

[20:56] <rhuxton> Newbie Q: The recent (v. interesting) capture/signature discussion here: http://use.perl.org/~JonathanWorthington/journal/40196 says "For any other object, we coerce to a capture by looking at all of the  public attributes (things declared has $.foo) up the class hierarchy and  making those available as named parameters."

[20:56] <rhuxton> Does this not violate encapsulation?

[20:56] <PerlJam> (though mine will work on more versions of git :)

[20:57] <PerlJam> rhuxton: no

[20:57] <jnthn> rhuxton: It's only using information that's available through introspection anyway.

[20:57] <jnthn> PerlJam: Yours will also set up a local branch with tracking which is important if you want to commit, iiuc. Mine is only OK if you simply want to use it.

[20:58] <jnthn> rhuxton: You'd have to have declared such attributes like "has $.x". A "has $!x" attribute won't be included.

[20:58] <rhuxton> Realised I'm not clear there. If I remove attribute "foo", but replace it with a method to preserve the interface then it's not going to be available any more. Even though I thought I preserved the public interface.

[20:58] <PerlJam> jnthn: yeah, I think I do tracking branches reflexivly these days :)

[21:00] <PerlJam> rhuxton: if you've kept the public interface the same, then nothing has changed.

[21:00] <jnthn> rhuxton: Only if your definition of "preserving the public interface" doesn't include removing public attributes, that is.

[21:01] <jnthn> rhuxton: It's not unique to Perl 6 to make attribute accessors and methods have different meanings.

[21:01] <jnthn> 'tis that way in C# too.

[21:01] <jnthn> I can't just change a property into a method and consider it as not an interface change.

[21:03] <PerlJam> rhuxton: though if you've replaced the "foo" attribute with "bar" by saying "has $.bar", you've just added to the public interface.

[21:04] <rhuxton> I've been reading "public attributes" as "attributes with public accessors". Hmm - if the public interface of a class is more than just the methods that means sooner or later you'll end up with a "fake attribute" feature.

[21:04] <jnthn> rhuxton: One thing that may make things less of a concern, mind, is that you can still write a "has $.x" and a method x that overrides the default accessor semantics.

[21:05] <jnthn> That is, an accessor won't get generated for you if you wrote one of your own.

[21:06] *** snarkyboojum joined
[21:06] <PerlJam> rhuxton: "fake attribute"?

[21:06] <rhuxton> jnthn: so I'm not gaining access to "$.x" but to the method "x" that (usually) maps to it? Hmm...

[21:07] <rhuxton> PerlJam: a "fake attribute" as an empty container that "handles" $.x because we don't actually have one.

[21:07] <jnthn> rhuxton: Of course, if you're worried, there's nothing to stop you imeplemented method Capture() { ... } to define how you want your class to coerce. :-)

[21:07] <jnthn> *implementing

[21:08] <PerlJam> rhuxton: using "has $.foo" is the same thing as saying "has $!foo" and implmenting your own .foo accessors method only with more writing on your part  :)

[21:09] <m-locks> hardcore archiving action

[21:11] <rhuxton> PerlJam: so are the accessors labelled "accessor"  with whatever the property-labelling-thingummy is called? And if so, should that not be what we're looking at for the Capture() coercion (ta jnthn)?

[21:11] *** hercynium left
[21:11] <TimToady> I would be inclined to think that anything outside a class shouldn't care whether $.foo is an attribute or a method pretending to be an attribute

[21:12] <PerlJam> rhuxton: er ... that's what's happening.

[21:12] <PerlJam> rhuxton: or are you worried about partitioning the accessors from the other non-accessor methods?

[21:12] *** astrojp joined
[21:13] <jnthn> TimToady: The issue is that when we're unpacking an object in a signature, it has to make a capture from that object for the binder.

[21:13] <jnthn> TimToady: And at the moment it does that by doing .^attributes and looking for those that have an accessor.

[21:13] <TimToady> oh, for a submethod then

[21:14] <TimToady> so you're really looking at the $!foo list

[21:14] <jnthn> TimToady: Yes, but you can tell if something was declared $.foo or $!foo

[21:14] <jnthn> TimToady: We ignore anything that wasn't declared $.foo

[21:14] <rhuxton> PerlJam: I'm not here worried about partitioning the accessors. I'm probably wondering whether I can define a method, label it an accessor and have the rest of the system treat it as such.

[21:14] <jnthn> TimToady: So you can't get at anything you woudln't otherwise be able to get at.

[21:15] <TimToady> but then what if we refactor so $.foo is a synthetic attribute, we lose our refactorability

[21:15] <TimToady> this seems like a design issue with WHENCE objects

[21:15] <jnthn> TimToady: Well, that's the concern rhuxton  has.

[21:15] <rhuxton> TimToday: Aha! What I was trying to say, but coherently.

[21:15] <PerlJam> heh

[21:15] <jnthn> TimToady: I'm not sure how big a deal it is or not though.

[21:16] <jnthn> has $.language-designer handles 'problem' # :-)

[21:16] <TimToady> as long as we have a way of saying named attrs outside of a WHENCE that just attach where appropriate

[21:16] <rhuxton> jnthn: It happens often enough that I thought of it reading the (your?) article. And I'm not that bright.

[21:17] <jnthn> TimToady: Sorry, I'm completely missing how WHENCE fits into this.

[21:19] <PerlJam> isn't more like that anti-WHENCE because you're turning an object into a capture rather than the other way?

[21:19] <PerlJam> s/more/it more/

[21:19] <jnthn> Heh, that's a curious way of looking at it. :-)

[21:19] <jnthn> Not sure it gets an answer though...

[21:19] <jnthn> Also, you can set privates from WHENCE.

[21:20] <jnthn> Well, they provide things to BUILD anyway.

[21:20] <TimToady> S12:780 is what I'm talking about

[21:22] <jnthn> TimToady: OK, I'm aware of that bit of the synopsis, but not how it helps.

[21:22] *** hercynium joined
[21:22] <jnthn> TimToady: Given an arbitrary object, how do I produce a capture that can be used to bind against a signature?

[21:22] <jnthn> (If it doesn't have a .Capture that says how to do it already, that is)

[21:23] <TimToady> well, going that way, as long as some subobject or other supplies it, I guess a refactor ends up with the same named arg

[21:23] <TimToady> though delegation could still mess you up

[21:24] <PerlJam> jnthn: you just need to use the .to_JSON and .from_JSON methods that all objects have  ;>

[21:25] <jnthn> TimToady: Yes, but the named args we put into the capture are based on .^attributes, then checking if .has_accessor is true.

[21:25] <jnthn> Or whatever the trait to check is called, I forget exactly...

[21:26] <jnthn> TimToady: I'm struggling to see what you're suggesting the list of named params we should stick in the capture is made from.

[21:26] <TimToady> well, it's probably okay for now; we can extend to other methods incl delegated ones later

[21:26] <rhuxton> I think what I'm arguing is that (if there isn't one already) there should be an "accessor" label (trait?) that can be applied to any method. That's what my public attribute are then, because I've declared them as such.

[21:26] <jnthn> OK.

[21:26] <TimToady> it's more like the set of methods that have no args

[21:27] <TimToady> which could include delegated no-arg methods

[21:28] <TimToady> otoh, we might not have that info handy when we need it

[21:28] <jnthn> yeah

[21:28] <jnthn> The "is accessor" trait approach could work...

[21:28] <jnthn> Though may be code-smell-ish.

[21:28] <PerlJam> should there be an .^accessors to hide this behind in any case?

[21:29] *** ignacio_ left
[21:29] <TimToady> traits are usually code-smelly

[21:30] *** pmurias left
[21:31] <TimToady> afk &

[21:31] *** pmurias joined
[21:39] *** bluescreen left
[21:40] <rhuxton> thx all - not sure I understood most of that, but I feel better that at least the question made sense :-)

[21:40] *** kaare_ left
[21:43] <spinclad> example: Real does Complex { method im #`[is accessor?] { 0 } }  and  exxp(Complex :(:$re, :$im)) { ... }  # a function with no :(Real) multi candidate, this is the one that matches

[21:43] <spinclad> *class Real ...

[21:45] *** mssm left
[21:45] *** rhuxton left
[21:50] *** SmokeMachine left
[21:54] *** justatheory left
[21:54] *** lestrrat is now known as lest_away

[21:55] *** justatheory joined
[21:58] *** mssm joined
[22:06] *** alester left
[22:11] *** desertm4x joined
[22:14] *** lest_away is now known as lestrrat

[22:23] *** am0c joined
[22:31] *** hercynium left
[22:32] *** lue joined
[22:33] *** Su-Shee left
[22:34] <lue> hello!

[22:41] <lue> (hello... hello... hello...)

[22:43] *** iblechbot left
[22:43] <Tene> Hi!

[22:45] <lue> 'ello!

[22:46] *** wknight8111 joined
[22:49] <lue> I'm literally walking in Linus' footsteps, it seems. He uses KDE (which I do), and Fedora (which I do). He used Fedora originally for its support of PPC (me too!)

[22:49] *** ash_ left
[22:51] *** zpmorgan left
[22:52] *** masak joined
[22:52] * masak does a flip in the air and lands on the floor of #perl6

[22:52] <phenny> masak: 23 Feb 18:41Z <TimToady> tell masak re anon class is, see http://irclog.perlgeek.de/perl6/2010-02-23#i_2024709

[22:53] <masak> TimToady: gotcha. thanks.

[22:53] *** cdarroch joined
[22:53] *** zpmorgan joined
[22:53] *** cdarroch left
[22:53] *** cdarroch joined
[22:53] <masak> lue: hello! :)

[22:54] <lue> oi!

[22:54] <lue> Do you has a temporal update up yet? (Haven't bothered looking)

[22:54] *** locsmif left
[22:55] <masak> no, tonight I've been trying to make GGE put together a grammar. I got quite far but not all the way.

[22:55] *** fda314925 joined
[22:55] <masak> now I have a bunch of semi-confused questions for pmichaud, or whoever would like to provide a faithful simulation of pmichaud.

[22:56] <jnthn> lolitsmasak

[22:56] <masak> yayitsjnthn

[22:56] <masak> ...who is soon, by the way, moving in with the rest of us Swedes :)

[22:57] <masak> where did I put that old "WELCOME" mat?

[22:57] <jnthn> :-)

[22:57] *** IllvilJa left
[22:57] <jnthn> Yes, < 1 week left in Slovakia.

[22:57] <jnthn> Still doesn't feel quite real.

[22:57] <masak> changing country starting with an S always has an unreal feel to it.

[22:58] <m-locks> whatcha doin there in slovakia

[22:58] <lue> Who here can't wait for Rakudo die(*) ?

[22:58] <masak> m-locks: turning beer into Rakudo code! :)

[22:58] <jnthn> what masak said

[22:58] <jnthn> :-)

[22:58] <m-locks> ok :D

[22:58] <masak> lue: come again?

[22:59] <masak> lue: die-Star?

[22:59] <jnthn> deathstar!

[22:59] <masak> oh.

[22:59] <jnthn> ...maybe. :-)

[22:59] <masak> that's not a moon, it's a space station. :/

[22:59] <jnthn> Oh well, at least it's got a big viewing window now.

[23:00] <lue> Wait, that's telling it to kill * ... How about Rakudo die*() ( or die*(Rakudo) )

[23:00] <jnthn> m-locks: For last couple of years, I've not needed to live anywhere in particular (working entirely from home).

[23:00] <m-locks> thats nice

[23:00] <jnthn> m-locks: And somehow ended up in Slovakia. :-)

[23:00] <m-locks> hows that place been

[23:00] <masak> jnthn: do EnumMap objects accept any types of objects as keys?

[23:01] <jnthn> m-locks: It's a small, but interesting and beautiful country, and it's been fun to try and learn some of the language too.

[23:01] <jnthn> Also nice people, nice beer and nice food.

[23:01] <m-locks> overall verdict: nice :)

[23:02] <jnthn> masak: Yeah, though they coerce to Str, I believe, by default.

[23:02] *** ggoebel left
[23:02] <masak> jnthn: :/

[23:02] <masak> so, "no".

[23:02] <jnthn> m-locks: Yes, I've enjoyed it.

[23:03] <jnthn> I'm sure Sweden will also be enjoyable too. :-)

[23:03] <jnthn> Though different. :-)

[23:03] *** ggoebel joined
[23:03] <m-locks> it will

[23:03] <jnthn> masak: Right

[23:03] *** lestrrat is now known as lest_away

[23:03] <masak> jnthn: sometimes I fear that Rakudo Star will set some ugly precedents.

[23:03] <jnthn> masak: I think you gotta say you want other key types.

[23:03] <masak> jnthn: hash keys as Str-only being one of them.

[23:04] <masak> jnthn: I want other key types.

[23:04] <masak> :)

[23:04] <jnthn> masak: Oh, the coerce to Str as default is spec, afaik.

[23:04] <masak> even for EnumMap?

[23:04] <masak> what about Int enum keys?

[23:04] <lue> .oO(A string-lock... what kind of locksmith _is_ EnumMap? :) )

[23:05] <jnthn> masak: Good question.

[23:05] <masak> TimToady++ # r29828

[23:05] <jnthn> masak: For now also coerce to string but, well, hmm.

[23:06] <masak> this is all part of what I fear might become too entrenched.

[23:06] <masak> if that's the word. ingrained.

[23:07] <jnthn> masak: It would perhaps be englightening to see what it'd take to make non-string hashes work.

[23:08] <jnthn> Maybe we take a moment to play with that at $hackathon.

[23:08] * masak looks around for hugme

[23:08] <masak> oh, well.

[23:08] * masak hugs jnthn :)

[23:08] <jnthn> :-)

[23:08] *** ggoebel left
[23:08] <masak> hackathon it is.

[23:08] <jnthn> Cool.

[23:09] * jnthn is glad that there'll be a few days totally set aside for Perl 6 things. :-)

[23:09] <masak> jnthn: I almost created a GGE grammar today! :)

[23:09] <jnthn> Wow!

[23:09] <masak> yeah.

[23:09] <masak> I hope to succeed in that before Copenhagen. it'd be really cool.

[23:09] <masak> then I can try to make GGE parse Perl 6 code.

[23:09] * jnthn wonders how long before GGE can run on master. :-)

[23:09] * lue wants to feel excitement, but is unawares of GGE and such

[23:10] <jnthn> masak: I figure you're still using alpha for now?

[23:10] <masak> lue: GGE is a parser engine I'm writing.

[23:10] <masak> jnthn: I'm so using alpha.

[23:10] <jnthn> Makes sense.

[23:10] <masak> jnthn: and GGE will, in a way, forever target alpha codebases.

[23:11] <masak> lue: I'm kinda ripping off the code of some other guy (forgot his name), but I'm writing it in Perl 6 instead of Parrot Intermediate Code.

[23:11] <lue> So, anyone can start a Grammar Engine if they wanted to? (No easy feat, I see)

[23:11] <masak> oh, right. it's pmichaud++ who wrote the original. :P

[23:12] <masak> the original's called PGE. it used to drive Rakudo.

[23:12] *** IllvilJa joined
[23:12] <masak> lue: well, it's tricky in places, but not near as magical as I suspected.

[23:12] <masak> lue: then again, I'm aware that my brain has been warped by this task, more than any prior project, actually. I'm now forever a parserhead.

[23:12] <lue> IIPMGE (Incredibly Intelligent Psychic Medium Grammar Engine)

[23:13] <masak> lue: my sekkrit plan is to be able to parse Perl 6 code from within a Perl 6 program.

[23:14] <masak> neither PGE or STD.pm allowed me to do that easily six months ago when I started.

[23:14] <lue> \o/ (thinking of funny grammer engine names/acronyms for the heck of it)

[23:14] *** ggoebel joined
[23:15] *** payload1 left
[23:15] <snarkyboojum> I love the idea of a time-travelling debugger (!) Sounds v. cool :)

[23:16] <masak> snarkyboojum: let's go ahead and create it! :)

[23:16] <pmichaud> 22:55 <masak> now I have a bunch of semi-confused questions for pmichaud, or whoever would like to provide a faithful simulation of pmichaud.

[23:16] <pmichaud> <- simulator available

[23:16] <masak> \o/

[23:16] <snarkyboojum> indeedy! :)

[23:16] <lue> DYEGE (Doesn't Yet Exist Grammer Engine)

[23:16] <masak> snarkyboojum: actually, there's no need to wait for the parser engine to finish. we can work off ASTs in the meantime.

[23:16] <masak> pmichaud: ok, so. hai.

[23:17] <masak> pmichaud: GGE::$!MATCH holds the metaclass object for GGE::Match, yes?

[23:17] <pmichaud> as a horribly crufty workaround for other issues, yes :)

[23:17] <masak> pmichaud: the generated regex code uses it to create new objects. why?

[23:18] <masak> why not just call GGE::Match.new directly from that code?

[23:18] <pmichaud> ummmmm

[23:18] <lue> (GE Name) GENERAL (Grammar Engine Needing Extra Robitussin, At Least)

[23:18] <pmichaud> I don't know about the generated regex code using it to create new objects

[23:19] <masak> also, am I reading correctly that it's the GGE::Match.new code that decides the eventual type of the created object? and that it does this through a named parameter 'grammar'?

[23:19] <pmichaud> I always thought the regex code used whatever match object was passed in

[23:19] <masak> pmichaud: yes, but it starts by calling .new on it.

[23:19] *** bkeeler_ joined
[23:19] <masak> $!MATCH.new, to be exact.

[23:20] <masak> hm, I guess that's the match object it'll eventually return.

[23:20] <pmichaud> it always uses PGE::!$MATCH, iirc

[23:20] <pmichaud> not GGE::$!MATCH

[23:20] <masak> right. PGE :)

[23:20] <masak> sorry. :)

[23:20] <pmichaud> okay, that was confusing me a bit :)

[23:20] <lue> (GE Name) GREP (GRammer Engine Paradigm) :D

[23:21] <masak> it's also the match object holding the other methods in the grammar.

[23:21] <pmichaud> the whole $!MATCH business was a hacky workaround so that Rakudo could do matching using Rakudo Match objects instead of PGE PGE::Match objects

[23:21] <masak> oooh.

[23:21] <masak> then I don't need that right now. good.

[23:22] <pmichaud> so, Rakudo would temporarily set PGE::$!MATCH to the protoobject for Rakudo's Match, call the function, then set it back.

[23:22] <pmichaud> or something like that.

[23:22] <pmichaud> looking.

[23:22] <masak> ewww :)

[23:22] <jnthn> Eww! :-D

[23:22] * jnthn tries to put back deferal, just for fun.

[23:22] <pmichaud> yes, that's what it was doing.

[23:23] *** lichtkind joined
[23:23] <pmichaud> part of the problem was that pge didn't have a good cursor model underneath, and when one was finally created in STD.pm, it was too difficult to clean up PGE

[23:23] *** pyrimidine left
[23:23] <lichtkind> so 5 edits further away

[23:24] <masak> pmichaud: understood.

[23:24] <pmichaud> so as a workaround to resolve some masakbugs, I added the PGE::$!MATCH bit to allow the caller to say "I prefer this type of match object by default, please".

[23:24] <masak> pmichaud: I suspect GGE is in the same pinch, but I don't see the depth of it all yet. :)

[23:24] <jnthn> What goes around comes around. :-)

[23:25] <masak> pmichaud: though it feels increasingly incestuous that basically all the types in the hierarchy descend from Match...

[23:25] <pmichaud> PGE::Match.new(obj)   always uses the type of obj if it happens to be isa PGE::Match.  If it's not an instance of PGE::Match (or a subclass), then it creates an instance of the invocant

[23:25] <pmichaud> masak: we have similar issues in STD.pm, only everything derives from Cursor instead :)

[23:25] <masak> oh noes :)

[23:25] <lue> How would run the Perl6-coded GE? Using the Perl6-coded GE?

[23:26] <pmichaud> nqp-rx at least separates Match objects to be entirely separate from cursor's  :-)

[23:26] <pmichaud> *cursors

[23:26] <masak> pmichaud: ok, [use type of old Match obj] good to know. thanks.

[23:27] <masak> lue: try GGE and see for yourself. it's on github.

[23:27] <pmichaud> in the new world of things,  Grammar is Cursor

[23:27] <lue> ((I can see why noone's written tests of S08))

[23:27] <masak> lue: it's probably more complete than most people suspect.

[23:27] <lue> masak: can I runs it on doctor?

[23:27] <pmichaud> (in the old world of things, Grammar is Match)

[23:27] *** hercynium joined
[23:27] <lichtkind> masak: please check http://www.perlfoundation.org/perl6/index.cgi?carl_m%C3%A4sak

[23:27] <masak> pmichaud: I find it about as strange that Grammar should be Cursor, as that it should be Match. but oh well.

[23:28] <pmichaud> masak: yes, everyone finds it strange at first

[23:28] <lichtkind> masak: and you cant silence me on the november bug :)

[23:28] <pmichaud> the question that resolves the issue --   if regexes are methods, what are they methods on?

[23:28] <masak> lichtkind: you missed a few projects. :P

[23:28] <jnthn> lichtkind: you missed a few hundred bug reports

[23:28] <masak> pmichaud: point.

[23:28] <lichtkind> masak: so please add it

[23:28] <lue> rakudo: $a=1,2,"pi"; say $a.WHAT

[23:29] <masak> lichtkind: in my copious spare time. :)

[23:29] <p6eval> rakudo 59c65b: OUTPUT«Symbol '$a' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[23:29] <lue> rakudo: my $a=1,2,"pi"; say $a.WHAT

[23:29] <masak> lichtkind: thanks for creating an article about me! lichtkind++

[23:29] <p6eval> rakudo 59c65b: OUTPUT«Seq()␤»

[23:29] <pmichaud> so, if regexes are methods in a grammar, and we want them to be invoked on a match-in-progress, then grammar needs to be a subclass of match-in-progress

[23:29] <lichtkind> masak: if you tell me i can edit is also

[23:29] <lue> rakudo: say Parcel(1,2,"pi",:a<b>)

[23:29] <p6eval> rakudo 59c65b: OUTPUT«Could not find non-existent sub &Parcel␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:29] <pmichaud> rakudo:  say (1,2,"pi").WHAT;  # just checking.

[23:29] <p6eval> rakudo 59c65b: OUTPUT«Parcel()␤»

[23:29] <lichtkind> masak: im currently serious about bringing some serious content into wiki

[23:30] <lichtkind> currently we have articles about nealry all major heads and implementations

[23:30] <masak> pmichaud: I had another question about the tests, but it resolved itself as I researched it further. :)

[23:30] <pmichaud> excellent.  The zen approach to bug fixing.  :)

[23:30] <pmichaud> "Through inaction all bugs are eventually resolved."

[23:31] <lue> I'm thinking of writing S08 tests... trying to figure out how to test it.

[23:31] <masak> lichtkind: I'm appalled that you haven't even mentioned proto, my greatest unintentional success to date, as well as the biggest collaboration project in all of Perl 6 lang.

[23:31] <masak> s/lang/land/

[23:31] <masak> funny typo.

[23:31] <lichtkind> masak: proto has a chapter in a page its not linked yet

[23:32] <pmichaud> lue: keep in mind that some portions of S08 are likely out of date

[23:32] <masak> lichtkind: 'module' should not have a capital 'm'. and the funny thing is that Web.pm isn't a module so much as a project of loosely connected modules.

[23:32] <lue> rakudo: say (1,2,'pi')['pi']

[23:32] <p6eval> rakudo 59c65b: OUTPUT«1␤»

[23:33] <masak> lichtkind: you're very welcome to write that I blog occasionally.

[23:33] <masak> lichtkind: did you catch my comments at http://irclog.perlgeek.de/perl6/2010-02-22#i_2019666 ?

[23:34] <lue> rakudo: say (1,2,'pi')[2]

[23:34] <p6eval> rakudo 59c65b: OUTPUT«pi␤»

[23:34] <masak> std: &foo

[23:34] <p6eval> std 29829: OUTPUT«ok 00:01 109m␤»

[23:34] <masak> rakudo: &foo

[23:34] <p6eval> rakudo 59c65b: OUTPUT«Symbol '&foo' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[23:34] <masak> alpha: &foo

[23:34] <p6eval> alpha 30e0ed:  ( no output )

[23:34] * masak submits rakudobug

[23:35] <pmichaud> std:  $x

[23:35] <p6eval> std 29829: OUTPUT«Potential difficulties:␤  Variable $x is not predeclared at /tmp/2JjN6iaBDt line 1:␤------> [32m$x[33m⏏[31m<EOL>[0m␤ok 00:01 105m␤»

[23:35] <masak> proof of a regression in three simple steps :)

[23:35] <pmichaud> interesting.

[23:35] <masak> pmichaud: &foo is not so much a variable as a bareword with a & in front.

[23:36] <pmichaud> ...and it means...?

[23:36] *** hsb left
[23:36] <jnthn> meh. It's just a lookup of a thingy somewhere. :-)

[23:36] <masak> pmichaud: 'the Code thingy you find when looking for "foo" in this scope'

[23:36] <lichtkind> masak: yes yes leto helped me with that

[23:36] <pmichaud> yes, I'm wondering where that "somewhere" is, though.

[23:36] <jnthn> masak: We don't store subs in the lexpad and/or namespace as barewords anymore.

[23:37] <jnthn> They are stored with the &

[23:37] *** Aniya joined
[23:37] <masak> but the spec is still the same.

[23:37] <jnthn> pmichaud: Yes, maybe &foo always calls back to the namespace?

[23:37] <masak> and STD.pm.

[23:37] <jnthn> pmichaud: Note also

[23:37] <pmichaud> jnthn: oh, certaily not.

[23:37] <jnthn> rakudo: &infix:<+>

[23:37] <p6eval> rakudo 59c65b: OUTPUT«Symbol '&infix:<+>' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[23:37] <jnthn> rakudo: &infix:<+>(1,2)

[23:37] <masak> o.O

[23:37] <p6eval> rakudo 59c65b: OUTPUT«Symbol '&infix:<+>' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[23:37] <jnthn> gah :-|

[23:37] <pmichaud> &foo();    my sub foo() { ... }

[23:37] <jnthn> Well that is fail too

[23:38] *** lest_away is now known as lestrrat

[23:38] <jnthn> pmichaud: oops, I meant falls back

[23:38] * masak submits rakudobug

[23:38] <lichtkind> masak: better http://www.perlfoundation.org/perl6/index.cgi?carl_m%C3%A4sak ?

[23:38] <jnthn> pmichaud: If there's nothing in the lexpad.

[23:38] <pmichaud> jnthn: yes, the &infix:<+> bug showed up when you added the adverbs to names.

[23:38] <pmichaud> jnthn: but how can you know that in advance?

[23:38] <pmichaud> (nothing in the lexpad)

[23:38] <masak> lichtkind: indeed better. thanks.

[23:38] *** tboyd joined
[23:38] <jnthn> You look in the lexpad first, and if nothing found, look to the ns?

[23:38] <pmichaud> when subs defaulted to 'our' scope, &foo made a bit more sense to me.

[23:39] <jnthn> *nod*

[23:39] <pmichaud> jnthn: so, if I have:

[23:39] <jnthn> OK, I guess the best answer I have is: what would STD do? :-)

[23:39] <pmichaud> &foo();   my sub foo() { ??? };   &foo();

[23:39] <pmichaud> are the two &foo's identical?

[23:39] <masak> lichtkind: if you're wondering, 'wrote with others' sounds a bit contrived. 'co-wrote' is more colloquial, methinks.

[23:39] <pmichaud> or do we always generate code that says "look up lexical first, if not found then package" ?

[23:39] <lichtkind> masak: true

[23:40] <jnthn> pmichaud: I was thinking the latter.

[23:40] <lichtkind> masak: changed that too

[23:40] <jnthn> pmichaud: But may be wrong

[23:40] <pmichaud> jnthn: so, perhaps &foo just forces a find_name opcode

[23:40] <masak> lichtkind++

[23:40] <jnthn> pmichaud: Yes, that was what I was pondering.

[23:41] <pmichaud> that seems workable.

[23:41] *** tboyd left
[23:41] <lichtkind> to all: anything missing there http://www.perlfoundation.org/perl6/index.cgi?implementations ?

[23:44] <masak> lichtkind: looks good to me.

[23:44] <masak> lichtkind: s/feature rich/feature-rich/

[23:44] <lichtkind> ah

[23:44] <lichtkind> masak: and each entry has an article :)

[23:45] <masak> impressive :)

[23:45] <lichtkind> masak: we need a bit wikified infos

[23:46] <lichtkind> masak feature-rich.. in german we would write featurerich

[23:46] <jnthn> masaks's blog :-)

[23:46] <masak> lichtkind: what jnthn++ said. that's a typo.

[23:46] <masak> kind of a double genitive :)

[23:46] <jnthn> But a cute one.

[23:47] <masak> well, kill your darlings...

[23:47] <lichtkind> jnthn: yes :)

[23:47] <lichtkind> but already gone

[23:47] <lue> I like when

[23:47] <bkeeler_> What the heck is the point of S02-whitespace_and_comments/one-pass-parsing.t?

[23:47] <masak> faster-than-lichtkind.

[23:47] <jnthn> awwww...why ain't ma candidate list getting stuck in ma lexpad...

[23:47] <lue> we respond with

[23:47] <Aniya> i can't believe this!!!! who the f*ck are you to do this, DIEGOPOP??? http://www.youtube.com/watch?v=cAMMiiAcSjk

[23:47] <lue> less than three

[23:48] <lue> words in a

[23:48] <lue> line. :)

[23:48] <masak> Aniya: that doesn't feel extraordinarily on-topic.

[23:48] <lue> *cough* ... wrong channel? (please say yes)

[23:49] <snarkyboojum> lichtkind: still a typo at http://www.perlfoundation.org/perl6/index.cgi?jonathan_worthington - 'developement'

[23:49] * snarkyboojum is a natural nitpicker :)

[23:50] <masak> snarkyboojum: seriously. let's set aside some time for drafting up a time-travelling debugger, and then we'll win eternal fame and glory. when are you available?

[23:50] <lichtkind> snarkyboojum: thanks an fixed too

[23:50] <lue> masak: I'm available 30 minutes ago (hey, you said time travel)

[23:51] <snarkyboojum> masak: I'd love to help out - but probably lacking knowledge/confidence :)

[23:51] <masak> lue: I like your attitude. you can be on the project if you hand us results from the future so we don't have to write them.

[23:51] <Aniya> i can't believe this!!!! who the f*ck are you to do this, DIEGOPOP??? http://www.youtube.com/watch?v=cAMMiiAcSjk

[23:52] <lue> I had them. But not now.

[23:52] <masak> would someone kick Aniya?

[23:52] *** Aniya was kicked by jnthn (I can't belive this! who the f*ck are you to spam our channel?))
[23:52] <masak> thanks.

[23:52] *** Aniya joined
[23:52] <lue> .oO(maybe Aniya's a spambot)

[23:52] <lue> aw hell

[23:52] <masak> kickban, perhaps.

[23:52] <masak> just a suggestion.

[23:52] <lue> masak: I had the results. But not now. I will have them in the future, when I go into the past :)

[23:53] *** Aniya left
[23:53] <pmichaud> lue: okay, you can be on the project now.  But you won't get any credit until sometime in the future, about the same time as you head into the past.  :)

[23:53] <masak> snarkyboojum: if it helps, I don't care very much about people's knowledge. the confidence has to be at some minimum level. but mostly it's about learning-as-you-go, so tuits and drive matter more than background.

[23:53] *** jnthn sets mode: +bi #perl6!*@*

[23:54] <jnthn> oh wtf

[23:54] <BinGOs> heh

[23:54] <lue> I has to be invited now? :(

[23:54] <snarkyboojum> masak; sounds constructive to me :)

[23:54] *** jnthn sets mode: -bni #perl6!*@*

[23:54] <masak> snarkyboojum: the debugger sorta requires a runtime. but I guess one can fake even that part early in the process.

[23:55] <snarkyboojum> masak: yeah, interesting to think about

[23:55] *** athenot joined
[23:55] <lue> 'Hey! who's that hoopy frood with the towel and time machine? Why that's lue of course, with masak and snarkyboojum!'

[23:55] *** jnthn sets mode: +b Aniya!*@*

[23:55] <jnthn> That's the one I wanted. 

[23:55] <masak> lue: :)

[23:55] <masak> snarkyboojum: the smallest possible use case seems to be stepping back and forth over a couple of variable declarations and print statements.

[23:56] <BinGOs> You might want your +n

[23:56] <masak> snarkyboojum: after that, one could bring subroutines and calls into the mix.

[23:56] <lue> (I just wanted to use the words hoopy and frood. Maybe I can sneak them into Esperanto somehow :D )

[23:56] <snarkyboojum> masak: yep - piecemeal is good

[23:56] <masak> lue: I have never seen those two words translated into Eo.

[23:57] *** ComWT joined
[23:57] <BinGOs> it just that without +n on the channel you don't have to be joined to the channel to send msgs to it.

[23:57] <masak> snarkyboojum: and TDD is very good. if you want, you can borrow my sekkrit vapourware TDD technology. :)

[23:57] <masak> snarkyboojum: just don't release it as a CPAN module without asking. :P

[23:57] <snarkyboojum> tote?

[23:58] <masak> yeah, at least an early ancestor of it.

[23:58] <snarkyboojum> masak: coolio :) remember reading about it a while ago

[23:58] <jnthn> BinGOs: Curiously, I didn't touch the n mode anywhere on purpose. :-/

[23:59] <masak> snarkyboojum: I've been using it for half a year. need to bootstrap it up to a releaseable Perl 6 project Real Soon Now.

[23:59] <snarkyboojum> masak: sounds sweet

[23:59] <lue> masak: good thing I have a place to practice esperanto in (relatively) real life. :)

[23:59] <masak> snarkyboojum: so, when do we start? with the Tardis debugger, I mean.

[23:59] <snarkyboojum> hey, is proto supposed to work on the latest Rakudo?

