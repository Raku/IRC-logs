[00:02] <pmichaud1> is the ordering of candidates in Perl6MultiSub significant?

[00:05] *** sftp left
[00:05] <jnthn> pmichaud1: No

[00:05] <jnthn> pmichaud1: (more)

[00:06] *** Juerd_ joined
[00:06] <jnthn> The ordering that they're passed to set_candidates is not, and the order of the RPA it populates is not.

[00:06] <jnthn> It sorts them on the first dispatch.

[00:06] <jnthn> But even that doesn't touch said RPA.

[00:06] *** cono left
[00:06] <pmichaud1> would it be hugely painful to convert the candidates RPA into a hash...?  ;-)

[00:06] <jnthn> Not if there's a way to get all the values out

[00:06] <jnthn> To sort them

[00:07] <jnthn> After the sorting the dispatcher doesn't care about that RPA.

[00:07] <pmichaud1> well, it'd just be an iterator :-)

[00:08] <jnthn> Anyway, likely not a problem to do that, just more code to fix up ;-)

[00:08] <pmichaud1> I'm just thinking a hash keyed by subid might be simpler than searching through a list for matches.  :-)

[00:08] <jnthn> Yes.

[00:09] *** Schwern joined
[00:10] *** Juerd_ left
[00:11] <jnthn> I think it's getting towards sleep time here. :-)

[00:11] <pmichaud1> enjoy sleep

[00:11] <pmichaud1> more hackathon tomorrow?

[00:11] <jnthn> Any last questions while I snooze? :-)

[00:11] <jnthn> Oh yes

[00:11] <pmichaud1> \o/

[00:11] <jnthn> Much of Sunday too

[00:11] <pmichaud1> hopefully we'll have shiny new closures working.

[00:11] <jnthn> Tomorrow is hacking, probably a nice walk at some point, and hopefully some good noms too :-)

[00:12] <pmichaud1> I _really_ wish to be there.  :)

[00:12] <jnthn> Awww. :-)

[00:12] <jnthn> We have to have some hackathon here some day :-)

[00:12] <jnthn> And...Pisa in a month. ;-)

[00:13] <pmichaud1> okay, afk for me for a bit

[00:13] <jnthn> OK, night o/

[00:14] <pmichaud1> oh, one last q

[00:14] <pmichaud1> is there a significant difference between set_candidates and incorporate_candidates?

[00:15] <pmichaud1> I'm guessing that if set_candidates returns a new Perl6MultiSub based on an existing one, that's really the same as "incorporate_candidates" is doing.

[00:16] <pmichaud1> afk

[00:22] *** eternaleye left
[00:43] *** clintongormley left
[01:03] *** pmichaud1 left
[01:06] *** lest_away is now known as lestrrat

[01:06] <dalek> niecza: 93ff19c | sorear++ |  (2 files):

[01:06] <dalek> niecza: Refactor closure translation

[01:06] <dalek> niecza: review: http://github.com/sorear/niecza/commit/93ff19cbb430e856a29a301c252df1a2ab884438

[01:06] <dalek> niecza: 89a3f9a | sorear++ | Niecza/Actions.pm:

[01:06] <dalek> niecza: Implement translation for bare blocks

[01:07] <sorear> dalek?  I pushed more than that

[01:07] <diakopter> it must've gotten floodblocked

[01:08] <sorear> an IRC client can send 1 line every 2 seconds, at least

[01:08] *** sorear sets mode: +v dalek

[01:08] <diakopter> dalek is broken such that it usually sends the first 3 lines within 1 second

[01:11] *** patspam left
[01:18] <ingy> \o/

[01:19] <ingy> My TestML.pm6 parser is fulling passing it's first tests!!

[01:19] * ingy heads off to a track practice

[01:23] *** Trashlord left
[01:24] *** meppl left
[01:25] <sorear> Niecza has classes again

[01:26] <sorear> (but dalek is still silent...)

[01:29] *** dalek left
[01:29] <lue> what would you call a document detailing all of the classes, methods, etc. in the src/ folder ( for the benefit of new contributers of course :) ) ?

[01:29] *** dalek joined
[01:31] *** Trashlord joined
[01:32] <sorear> lue: ROADMAP

[01:32] <sorear> the file currently with that name should be renamed TIMELINE

[01:33] <lue> hm, hadn't thought of that.

[01:34] <lue> I thought 'API', but the more I read exactly what an API _is_, the more it seems like that's the spec.

[01:41] *** Chillance left
[01:47] *** isBEKaml joined
[01:47] *** plobsing joined
[02:00] *** eternaleye joined
[02:21] *** japhb joined
[02:26] *** wmiksss1 joined
[02:28] <sorear> jnthn: ping

[02:28] <sorear> (or anyone else who groks lexical classes)

[02:31] <TimToady> whaddya wanna know?

[02:31] <phenny> TimToady: 02 Jul 21:18Z <sorear> ask TimToady What does sub &* {} mean?

[02:32] <sorear> A few things

[02:32] <sorear> 1.

[02:32] <sorear> sub x { my class Foo {} }  # How many times is Foo composed?

[02:34] <TimToady> only once, I think, same as package evaluation time

[02:34] <TimToady> in that sense a class is just a package

[02:38] <TimToady> sub &* {} isn't anything, but sub &*foo is a dynamically scoped sub name, that must be called as &*foo()

[02:38] <sorear> sub x($a) { my class Foo { method y { $a } } }  # What happens here?

[02:38] <sorear> std: sub &* {} #buglet?

[02:38] <p6eval> std 31531: OUTPUT«ok 00:01 110m␤»

[02:38] <TimToady> I dont' know how it's parsing it, offhand

[02:39] <sorear> $<sigil>=['&''*'?]? <deflongname>?

[02:39] <sorear> STD.pm6 +2022

[02:40] <sorear> [ $<sigil>=['&''*'?] <deflongname>? | <deflongname> ]?

[02:40] <TimToady> probably a holdover from when * was global

[02:40] <TimToady> it's violating the usual rule that twigils require a following \w

[02:41] <sorear> I see

[02:41] <sorear> so what of my second class query?

[02:41] <colomon>  loliblogged: http://justrakudoit.wordpress.com/2010/07/03/off-the-map/

[02:42] <sorear> sub x($a) { my ::Y := $a; my class Foo does Y { } }  # Here, have a third

[02:42] <TimToady> somehow that $a has to clone, but maybe it's the entry to x() that does it

[02:42] <TimToady> that won't work

[02:42] <TimToady> Y has to be known at compile time

[02:43] <TimToady> composition must happen at compile time

[02:43] <TimToady> whole point of the traits paper...

[02:44] <TimToady> so perhaps package/module/class blocks are transparent to the when-to-clone choice

[02:45] <TimToady> so the method's block gets cloned on entry to x, perhaps, if that makes sense

[02:45] <sorear> But if ::T were bound in a BEGIN, it would work?

[02:45] <TimToady> presumably

[02:46] <sorear> How about: my class Foo {}; sub x($a) { augment class Foo {} } #4

[02:46] <TimToady> the augment is also compile time

[02:46] <TimToady> declarator, not exectuble statement

[02:46] <sorear> Legal to put in a sub?

[02:47] <sorear> How about: my class Foo {}; sub x($a) { augment class Foo { method y { $a }} } #5

[02:47] <TimToady> sure, but kinda like putting a BEGIN block there

[02:47] <sorear> Aha.  (Cancel 5)

[02:47] <sorear> don't cancel 5 actually

[02:47] <sorear> I'm guessing Foo::y will never be cloned?

[02:47] <TimToady> though, actually, the block of the augment doesn't run until the sub is called, i suspect

[02:48] <sorear> and so will always return undef?

[02:48] <sorear> How about: sub x($a) { my class Foo { method y { $a } }; BEGIN { Foo.new.y } } #6

[02:48] <TimToady> it's not a BEGIN exactly, since package blocks run like normal code, even though the declaration they declare happens at compile time

[02:50] <TimToady> in the same sense that in Perl 5, package foo; knows the name 'foo' at compile time, but runs the code in it whenever the normal execution would happen

[02:52] <sorear> hmm

[02:53] <TimToady> looking at #6 now...

[02:54] <TimToady> but my brane glazes over; short sleep rations here last night...

[02:55] <sorear> #5 I think should work kind of like our subs do

[02:55] <sorear> since it's the same sort of thing; a more-visible declarator inside a lexical scope

[02:57] *** TiMBuS joined
[02:58] <TimToady> it knows $a is a lexical in a sub that should clone, yes

[02:58] <TimToady> but augment isn't creating anything new on its own

[02:59] <TimToady> except the method, of course

[02:59] <TimToady> #6 should parse fine because the typeness of Foo is known by the BEGIN block

[03:00] <TimToady> however, the .y will fail

[03:00] <TimToady> I think

[03:00] <TimToady> or perhaps you only get the protopad's $a

[03:01] <sorear> my $a; my $b; sub c { my class D { }; $a = D; $b = sub { augment class D { } } }; c; $b(); c; $b(); #7. Does the final call to $b have any effect?  This is a question of how distinct multiple instantiations of D are.

[03:03] <TimToady> I can see an argument for cloning D there

[03:04] <TimToady> but if we drive it so far that everything has to be decided at run time, we've probably pushed it too far

[03:04] <TimToady> there's probably some kind of purist position there that we're going to avoid

[03:04] <TimToady> in the interestests of being able to make some guaratees to the compiler

[03:05] <TimToady> not sure where the exact boundary is though

[03:05] <TimToady> certainly if we arrange to clone D there, then anything in the augment has to follow along

[03:06] <TimToady> and I suppose if we do clone D, then 'state D' would avoid cloning in some cases

[03:06] <TimToady> state class D, rather

[03:07] <sorear> I think I have a consistant mental model here

[03:07] <sorear> it clones D, but in a very shallow way

[03:08] <TimToady> we do support virtual names to some extent

[03:08] <sorear> in particular the typology of the system is completely static

[03:09] <sorear> a runtime notion of 'D' consists of the single 'D' protodescriptor + enough OUTER::s for all methods

[03:09] <TimToady> so an anonymous class is still a single class regardless of how it's used

[03:09] <sorear> augment BEGINs by augmenting the protodescriptor and runs by setting an OUTER::

[03:10] <sorear> "an anonymous class is still a single class regardless of how it's used" elaborate?

[03:10] <TimToady> $x = class { method x {...} };  $x.new.WHAT   # same for any instance of $x anywhere

[03:12] <sorear> what about sub a($y) { class { method x { $y } } }; a(1).new.WHAT === a(2).new.WHAT

[03:12] <sorear> I hope False

[03:12] <TimToady> that's an our class

[03:12] <TimToady> did you mean 'my'?

[03:12] <sorear> that's an anon class

[03:13] <TimToady> with our, the only thing lexical is the name

[03:13] <sorear> it doesn't have a name, how can it be our

[03:13] <TimToady> oh, right, told you I was tired...

[03:14] <TimToady> so yes, that's running a different class {}

[03:14] <sorear> ok

[03:14] <sorear> then your statement about anon classes doesn't conflict with my mental model

[03:15] <TimToady> you probably shouldn't be comparing with my mental model assuming it's coherent at the moment :)

[03:15] <sorear> anything else to add before afk?

[03:15] <TimToady> it sounds like you're on the right track, I think

[03:15] <sorear> pmichaud++ for suggesting walks around the neighborhood as a way to understand things

[03:15] <TimToady> but I could be wrong :)

[03:15] <sorear> it works very well for me

[03:16] <TimToady> my son Aron likes to figure out quantum physics and black holes that way

[03:16] <TimToady> but I should go sleep

[03:16] <sorear> 'night

[03:17] <TimToady> zzzzzzzzzzzzzzzzzzz

[03:24] *** ash_ left
[03:42] *** isBEKaml left
[03:47] *** jaldhar joined
[03:48] *** frettled joined
[03:50] <pragma_> please, no inspiration from ruby.

[03:56] *** isBEKaml joined
[03:57] <tylercurtis> pragma_: None at all?

[04:04] <sorear> S06 has 3333 lines...

[04:08] <isBEKaml> And, S03 has the greatest line count at 5076. :) #obviously... 

[04:13] *** Guest83880 left
[04:25] <sorear> Hmm, I can't find the rules for sub foo { our sub bar { } }

[04:25] <sorear> I thought they were in S06, but no luck

[04:25] <sorear> I'll just add my version of the rules to S06

[04:27] *** kfo joined
[04:28] <sorear> ahah, found it

[04:29] *** isBEKaml left
[04:30] *** kfo_ left
[04:37] *** skids left
[04:39] <pugssvn> r31532 | sorear++ | [S04] Clarify interaction of lexical classes and packages with members after discussion with TimToady 

[04:45] *** isBEKaml joined
[04:47] <tylercurtis> rakudo: use MONKEY_TYPING; augment class Mu { method kilo () { self * 1000; }; method mega () { self.kilo.kilo; }; }; say 5.kilo; say 5.mega;

[04:47] <p6eval> rakudo 7017d2: OUTPUT«5000␤Method 'kilo' not found for invocant of class 'Integer'␤  in 'Mu::mega' at line 11:/tmp/K7PmVfKGg6␤  in main program body at line 11:/tmp/K7PmVfKGg6␤»

[04:48] <tylercurtis> rakudo: use MONKEY_TYPING; augment class Mu { method kilo () { self * 1000; }; method mega () { self.kilo.kilo; }; }; say 5.kilo; say 5.kilo.kilo; # Why does 5 * 1000 not have the kilo method?

[04:48] <p6eval> rakudo 7017d2: OUTPUT«5000␤Method 'kilo' not found for invocant of class 'Integer'␤  in main program body at line 11:/tmp/8iyMLlIAcB␤»

[04:49] <tylercurtis> rakudo: use MONKEY_TYPING; augment class Mu { method kilo () { self * 1000; }; method mega () { self.kilo.kilo; }; }; say 5.kilo; say (5*1000).kilo # doesn't seem to work either

[04:49] <p6eval> rakudo 7017d2: OUTPUT«5000␤Method 'kilo' not found for invocant of class 'Integer'␤  in main program body at line 11:/tmp/Vlp4KcnrPe␤»

[04:49] *** ruoso left
[04:51] <frew> masak++ # excellent blog post

[05:02] <frew> rakudo: say * ~ ' ' ~ * for <a b c d>;

[05:02] <p6eval> rakudo 7017d2: OUTPUT«_block54␤_block54␤_block54␤_block54␤»

[05:04] <frew> rakudo: say * for <a b c d>;

[05:04] <p6eval> rakudo 7017d2: OUTPUT«!whatever_dispatch_helper␤!whatever_dispatch_helper␤!whatever_dispatch_helper␤!whatever_dispatch_helper␤»

[05:04] <frew> haha

[05:04] <frew> map * * * for <a b c d>;

[05:04] <frew> rakudo: map * * * for <a b c d>;

[05:04] <p6eval> rakudo 7017d2:  ( no output )

[05:05] <frew> rakudo: say map * * * for <a b c d>;

[05:05] <p6eval> rakudo 7017d2: OUTPUT«␤␤␤␤»

[05:06] <frew> rakudo: say map * + 1 for <a b c d>;

[05:06] <p6eval> rakudo 7017d2: OUTPUT«␤␤␤␤»

[05:06] <frew> rakudo: say map * + 1, <a b c d>;

[05:06] <p6eval> rakudo 7017d2: OUTPUT«1111␤»

[05:06] <frew> rakudo: say map * ~ 1, <a b c d>;

[05:06] <p6eval> rakudo 7017d2: OUTPUT«a1b1c1d1␤»

[05:06] <frew> rakudo: say map * * *, <a b c d>;

[05:06] <p6eval> rakudo 7017d2: OUTPUT«00␤»

[05:06] <frew> wow

[05:07] <frew> it worked EXACTLY HOW IT HOGUHT

[05:07] <frew> awesome

[05:08] <tylercurtis> * * * is kinda confusing, I think.

[05:09] <tylercurtis> rakudo: say map {$^a * $^b}, <a b c d>;

[05:09] <p6eval> rakudo 7017d2: OUTPUT«00␤»

[05:09] <tylercurtis> or even...

[05:09] <tylercurtis> rakudo: say map &infix:<*>, <a b c d>

[05:09] <p6eval> rakudo 7017d2:  ( no output )

[05:09] <tylercurtis> or no.

[05:21] *** ashleydev left
[05:30] *** justatheory left
[05:37] *** envi^home left
[05:41] <frew> Trashlord: but the fact that it wokrs is awesome

[05:45] <tylercurtis> frew: I think your tab-completion didn't work quite properly, there. If you think that's an awesome aspect of *, I have the perfect link for you. Just let me find it.

[05:46] <frew> correct :-)

[05:46] <frew> tylercurtis: is it the recent blog post about * ?

[05:46] <frew> tylercurtis: it's not the * * * that's awesome, it's that p6 was consistent about it

[05:46] <frew> that's pretty excellent

[05:47] <tylercurtis> frew: No. It's a wonderful little bit of obfuscated code that I saw somewhere, possibly moritz_'s blog, that really takes advantage of Perl 6's consistency about it.

[05:47] <frew> rakudo: say map * ** 2, 1..5;

[05:47] <p6eval> rakudo 7017d2: OUTPUT«1491625␤»

[05:48] <frew> ...

[05:48] <frew> rakudo: say map * ** * * * 1..9

[05:48] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Confused at line 11, near "say map * "␤»

[05:48] <frew> heh

[05:48] <frew> oh well

[05:48] <frew> say map (* * *) ** * 1..9;

[05:49] <frew> rakudo: say map (* * *) ** * 1..9;

[05:49] <tylercurtis> rakudo: say map * ** * * *, 1..9;

[05:49] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Confused at line 11, near "say map (*"␤»

[05:49] <p6eval> rakudo 7017d2:  ( no output )

[05:50] <tylercurtis> Anyway, I found it: http://perlgeek.de/blog-en/perl-6/starry-obfu.html

[05:50] <tylercurtis> With an explanation here: http://perlgeek.de/blog-en/perl-6/dissecting-starry-obfu.html

[05:55] <tylercurtis> frew: although it appears that when that was written, Whatever would only ever create a unary function.

[06:09] *** constant left
[06:10] *** constant joined
[06:10] *** constant left
[06:10] *** constant joined
[06:32] *** isBEKaml left
[06:32] <ingy> hola

[06:32] <tylercurtis> Hi.

[06:32] <ingy> :)

[06:36] <frew> rakudo: say map * * * ** * 1..9;

[06:36] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Confused at line 11, near "say map * "␤»

[06:37] <frew> rakudo: say map * * * ** 2 1..9;

[06:37] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Confused at line 11, near "say map * "␤»

[06:37] <tylercurtis> rakudo: say map * * * ** 2, 1..9;

[06:37] <p6eval> rakudo 7017d2:  ( no output )

[06:38] <frew> rakudo: say map * * * ** *, 1..9;

[06:38] <p6eval> rakudo 7017d2:  ( no output )

[06:38] <frew> rakudo: say map * * * + *, 1..9;

[06:38] <p6eval> rakudo 7017d2:  ( no output )

[06:38] <frew> rakudo: say (map * * * + *, 1..9).perl;

[06:38] <p6eval> rakudo 7017d2: OUTPUT«Method 'Num' not found for invocant of class 'WhateverCode'␤  in 'Cool::Numeric' at line 1585:CORE.setting␤  in 'Cool::Numeric' at line 1586:CORE.setting␤  in 'infix:<+>' at line 5890:CORE.setting␤  in <anon> at line 11:/tmp/GTogSKuL_r␤  in 'Any::join' at line 1␤  in

[06:38] <p6eval> ..'List::perl' a…

[06:43] <tylercurtis> rakudo: say (* * * + *)(1, 2, 3)

[06:43] <p6eval> rakudo 7017d2: OUTPUT«Too many positional parameters passed; got 3 but expected 1␤  in <anon> at line 1:/tmp/WAipoCrfdO␤  in main program body at line 11:/tmp/WAipoCrfdO␤»

[06:43] <tylercurtis> rakudo: say (* * * + *)(1)

[06:43] <p6eval> rakudo 7017d2: OUTPUT«Method 'Num' not found for invocant of class 'WhateverCode'␤  in 'Cool::Numeric' at line 1585:CORE.setting␤  in 'Cool::Numeric' at line 1586:CORE.setting␤  in 'infix:<+>' at line 5890:CORE.setting␤  in <anon> at line 11:/tmp/J7C_hDpWyG␤  in main program body at line

[06:43] <p6eval> ..11:/tmp/J7C_hDp…

[06:47] <mathw> phenny: tell masak Awesome blog post!

[06:47] <phenny> mathw: I'll pass that on when masak is around.

[06:51] *** eternaleye left
[06:52] *** f joined
[06:53] <f> where

[06:53] <f> hello

[06:55] *** f left
[07:11] *** Su-Shee joined
[07:15] <frew> rakudo: 240*8

[07:15] <p6eval> rakudo 7017d2:  ( no output )

[07:16] <frew> rakudo: say 240*8

[07:16] <p6eval> rakudo 7017d2: OUTPUT«1920␤»

[07:21] *** cono joined
[07:51] *** Ross joined
[08:05] *** agentzh joined
[08:19] *** masak joined
[08:19] <masak> lol I woke up

[08:19] <phenny> masak: 06:47Z <mathw> tell masak Awesome blog post!

[08:19] <masak> thanks :)

[08:23] *** isBEKaml joined
[08:27] <masak> std: state class D { }

[08:27] <p6eval> std 31532: OUTPUT«ok 00:01 110m␤»

[08:28] *** zamolxes left
[08:28] *** patch joined
[08:28] *** f00li5h joined
[08:28] *** zamolxes joined
[08:36] <isBEKaml> masak: as always, great post! I have a question about '*'. Do they allow callables to be taken as params? 

[08:36] <isBEKaml> callables might be taken as blocks that are to be executed on satisfying some conditions.. 

[08:37] <masak> rakudo: my $a = *.assuming(4); say $a(* + 38)

[08:37] <p6eval> rakudo 7017d2: OUTPUT«assuming_helper␤»

[08:37] <isBEKaml> rakudo: map * for <foo bar baz duck>

[08:37] <p6eval> rakudo 7017d2: OUTPUT«No candidates found to invoke␤  in 'map' at line 1564:CORE.setting␤  in main program body at line 11:/tmp/go0yQ8s0Sr␤»

[08:37] <tylercurtis> rakudo: (*.(5)).(&say)) # not really sure if the dotty form is right.

[08:37] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Confused at line 11, near ") # not re"␤»

[08:37] <masak> rakudo: my $a = *.assuming(4); say $a(* + 38)()

[08:37] <p6eval> rakudo 7017d2: OUTPUT«42␤»

[08:37] <masak> \o/

[08:37] <masak> isBEKaml: that what you meant?

[08:37] <tylercurtis> (*(5))(&say)

[08:37] <tylercurtis> rakudo: (*(5))(&say)

[08:38] <p6eval> rakudo 7017d2: OUTPUT«5␤»

[08:38] <masak> TimToady: would it make sense to have a special case for map/grep of *, for people who expect the 'identity transform' to be spelled that way?

[08:38] <isBEKaml> tylercurtis showed a weird form of a callable.. :)

[08:39] <isBEKaml> Though I recognise &prefix to indicate a block.. 

[08:39] *** azert0x joined
[08:39] *** azert0x left
[08:39] *** azert0x joined
[08:39] *** azert0x left
[08:39] <tylercurtis> rakudo: my &funcall := *(*); funcall(&say, 5)

[08:39] <p6eval> rakudo 7017d2: OUTPUT«:= binding of variables not yet implemented␤  in 'infix:<:=>' at line 601:CORE.setting␤  in main program body at line 11:/tmp/ZPm0qPWgwh␤»

[08:40] *** azert0x joined
[08:40] <tylercurtis> rakudo: my &funcall = *(*); funcall(&say, 5)

[08:40] <p6eval> rakudo 7017d2: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in <anon> at line 1:/tmp/KLj0thrrzG␤  in main program body at line 11:/tmp/KLj0thrrzG␤»

[08:40] <tylercurtis> I write too much NQP.

[08:40] <tylercurtis> rakudo: my &funcall = *(5); funcall(&say)

[08:40] <p6eval> rakudo 7017d2: OUTPUT«5␤»

[08:40] <isBEKaml> tylercurtis: this is more close to what I have in mind. It would be nice if we can do that by inlining conditional statements.

[08:41] *** azert0x left
[08:41] <isBEKaml> not the above, the one before. 

[08:41] <masak> "inlining conditional statements"?

[08:42] *** azert0x joined
[08:42] <isBEKaml> masak: More like, execute this block only if it satisfied certain criteria. funcall(&callable, params_callable) if (condition);

[08:43] *** azert0x left
[08:43] <isBEKaml> masak: by inlining, funcall(&callable, params_to_callable if (condition_satisfied) );

[08:44] <isBEKaml> there, it's inside the funcall. 

[08:46] <tylercurtis> Part of me wants to complain that if I saw that without seeing the example of what you'd want it to mean immediately before it, I'd have no clue what it did. On the other hand, that's also true of a lot of wonderful features of Perl 6.

[08:48] <isBEKaml> tylercurtis: that's right. Eg in point, I kind of understand map/grep, but I don't really fully understand it though I use it regularly in another FP language I use(Scala)

[08:48] <tylercurtis> masak: Would you be willing to describe the current format of SIC to me sometime if I'm not able to sufficiently figure it out by reading the source of Yapsi?

[08:48] <masak> tylercurtis: oh, absolutely.

[08:49] <isBEKaml> masak: I had wanted to ask you about if-else block in Yapsi. it doesn't seem to work the way I see it. Can you explain if you have any other syntax in mind? 

[08:49] <masak> isBEKaml: what doesn't work?

[08:50] <masak> ./yapsi -e 'if 42 { say 5 } else { say 3 }'

[08:50] <masak> 5

[08:50] <isBEKaml> yapsi -e 'my $foo = 42; if($foo > 50) {say "hie"; } else { say "no"; }; '

[08:50] <isBEKaml> Could not parse

[08:50] <tylercurtis> masak: thanks. I'm working on a top-secret not-very-good-idea project(that will probably stop being top-secret around the point words appear on the screen) involving it.

[08:50] <masak> isBEKaml: ah, infix:<< > >> not implemented yet.

[08:50] <masak> isBEKaml: also, you'd need a space after 'if' and before the (optional) paren.

[08:51] <isBEKaml> masak: ah, expression evaluation isn't in yet.. :)

[08:51] <masak> tylercurtis: interesting :)

[08:51] <masak> isBEKaml: there's only two operators for far. ++$a and --$a

[08:51] <masak> isBEKaml: holding off on the rest pending the implementation of subs.

[08:52] *** Juerd left
[08:52] *** Juerd joined
[08:53] <isBEKaml> masak: 3 weeks ago, I was thinking about how I'd do if-else blocks (hit on the expression evaluation thingy, thought of taking it up later). But then $DAYJOB took me up. :(

[08:55] <isBEKaml> masak: ok, back to question. How do we best go about implementing expr evaluation (I'm totally new to compilers/parsers, remember? )

[08:55] <tylercurtis> masak: of course, I'm also working on my GSoC, a library for unit-correct calculation(which is partially blocking on an apparent Rakudo bugs), translating Notation as a Tool of Thought from APL to Perl 6, my social life, and probably some other stuff(eventually I might find time to work on my potential Javascript compiler again, although now that I've written some Perl 6, I don't think I could stand to modify the parser to understand semicolon elision)

[08:55] <tylercurtis> no guarantees that it'll be even at that point anytime soon.

[08:55] <masak> isBEKaml: best way is probably to hook in STD, which mostly solved the whole parsing issue.

[08:56] <masak> isBEKaml: then we can focus on traversing the parse tree and building useful structures out of it.

[08:57] <isBEKaml> masak: how do we do that? And, STD can emit AST? 

[08:57] <masak> tylercurtis: I liked the APL notes you had on PerlMonks. they were well-researched and generally an interesting read.

[08:57] <isBEKaml> masak: nm the first question(exercise for me, will read the source)

[08:57] <masak> isBEKaml: the "how" is a good question. I'm open for ideas. as far as I know, STD only produces a parse tree, no AST.

[08:58] <tylercurtis> masak: thanks. hopefully I'll manage to get around to doing the same for the rest of the paper at some point.

[08:59] <isBEKaml> masak: [noobish] err, what's the difference between parse tree and AST? 

[08:59] <masak> isBEKaml: I just found out a couple weeks ago. :) I used to think they were the same.

[09:00] <masak> isBEKaml: briefly, a parse tree is closer to the source text in its structure. an AST is closer to the semantics. or something.

[09:00] <masak> knowledgeable people on this channel will probably have a better explanation. :)

[09:00] <tylercurtis> isBEKaml: AST's are generally massaged to be more convenient to generate code from/optimize/what-have-you. Whereas the parse tree is just exactly the tree of grammar rules that parsed the code.

[09:00] <masak> right.

[09:00] <sorear> isBEKaml: the parse tree directly corresponds to the physical structure of the code

[09:01] <sorear> the PAST is a language-independant structure; it looks exactly the same whether you're running perl6 --target=past, or lua, or go, or python, or anything else

[09:01] <masak> things like, you can put the while/until condition in a 'repeat' loop either before or after the block. the AST would abstract away that insignificant difference.

[09:02] <sorear> it's not correct to talk about "STD doesn't generate AST"

[09:02] <sorear> because the parse /is/ an AST

[09:02] <masak> oh?

[09:02] <sorear> the "parse" / "past" distinction is 100% a Parrot invention

[09:02] <sorear> because Parrot is supposed to run multiple languages, y'see

[09:03] <sorear> they needed to separate language-specific trees from non-language-specific ones

[09:03] <masak> sorear: I've been considering adopting PAST wholesale for Yapsi. do you think that's a good idea?

[09:03] <sorear> AST is a pretty general technical term

[09:03] <sorear> masak: No.  Anything which can run 100% of PAST is a Parrot clone

[09:04] <masak> huh.

[09:04] <sorear> both PAST and Rakudo-Parse are kinds of AST

[09:04] *** envi^home joined
[09:04] <sorear> STD generates its own parse-oriented AST; it also has an 'Actions' module which generates a slightly nicer AST

[09:05] <sorear> viv uses Actions for historical reasons, but I recommend you don't; I've wasted more time chasing Actions bugs than Actions has saved me :(

[09:05] <tylercurtis> sorear: Python(at least CPython) also has a distinction between the parse tree and the AST.

[09:05] <isBEKaml> uhh, let me get this straight - parse trees are for compilation phase, ASTs are more towards runtime phase (optimize,inline, do-whatever). 

[09:06] <masak> isBEKaml: correct. except sorear is saying both kinds are known as ASTs.

[09:06] <isBEKaml> sorear?

[09:06] <masak> oh wait. no, it's not a compile/runtime distinction.

[09:06] <sorear> isBEKaml: a normal compiler breathes ASTs (the technical term); it uses them in almost every phase, and has several different kinds of them

[09:06] <sorear> however, every compiler has its own idiosyncratic set of names for various AST flavors

[09:07] <sorear> Rakudo uses three - 'parse', 'past', and 'post'

[09:07] <masak> right. inside a compiler, it's mostly trees of different kinds. the frontend converts text->tree and the backend tree->text.

[09:08] <sorear> My use of AST is probably not completely standard either

[09:08] <isBEKaml> masak: I'm confused by your use of tree->text. I'd have thought tree->some_other_form_for_another_layer_of_compiler. 

[09:09] <isBEKaml> given how we have different forms of trees for Parrot alone. 

[09:09] <masak> well, I've gotten the impression that "Abstract" in AST means that it's somehow more separated from its textual form.

[09:10] <masak> isBEKaml: sure, but I meant that eventually, some serializer will spit back out text, or a binary blob.

[09:12] <masak> I cloned a templating engine for Web.pm that worked in much the same way. it's called Hitomi, and was a clone of Python's Genshi. internally, everything is lazy streams of XML-ish nodes, but it consumes and produces text externally.

[09:13] <isBEKaml> I don't get the full picture (though I guess it's better than what it was y'day ). I think I'll "get" it when I do something on Yapsi/read some compiler book. (I don't want to read "Dragon" book, it's too dense for me :( )

[09:14] <masak> getting one's hands dirty sure helps for me, though I'm hardly an expert.

[09:14] <masak> writing GGE (a grammar engine) was loads of fun.

[09:14] <isBEKaml> masak: yes, I'd have guess most compilers have layers on layers built into them and the mental model is never clear. :/

[09:14] <pugssvn> r31533 | sorear++ | [S12] Clarify phasing of lexical classes 

[09:14] <sorear> I've never seen "Dragon" book

[09:15] <sorear> do a search for "Let's Build a Compiler"

[09:15] <masak> sorear: http://en.wikipedia.org/wiki/Dragon_Book_(computer_science)

[09:15] <sorear> it's a ~20-part series of tutorials written in the 80s which walks you through writing most of a Pascal compiler to mc68k machine code in Pascal

[09:16] <sorear> *excellent* read

[09:16] <tylercurtis> Good night, folks.

[09:16] <sorear> I was like, 14 when I read them.  made perfect sense even then.

[09:16] <masak> tylercurtis: 'night!

[09:17] <isBEKaml> tylercurtis: G'night!

[09:17] <sorear> is isBEKaml a new yapsi recruit?

[09:17] <masak> yes. :) isBEKaml++

[09:18] * sorear now understands the "class" statement well enough to implement it in niecza

[09:18] <masak> isBEKaml: have you found doc/LOLHALP yet?

[09:18] <isBEKaml> masak: yes. :)

[09:18] <isBEKaml> sorear: partly because learning about compilers has been on my TODO list for way too long... :)

[09:19] *** tylercurtis left
[09:19] <masak> isBEKaml: yesterday, I tried to fix a design flaw that'll bite us if it isn't fixed early. it can be illustrated with this script: `my $a = 3; while --$a { say my $b; $b = 42 }`

[09:19] <masak> isBEKaml: try running that in Yapsi.

[09:20] <sorear> Was there no sixperl call on 6/24?

[09:20] <sorear> 6/23

[09:20] *** sorear sets mode: +o masak

[09:21] <isBEKaml> masak: Any() ?

[09:21] <masak> where does this 'sixperl' moniker come from? it confuses me every time I see it.

[09:21] <masak> isBEKaml: yeah. that means "not assigned to yet".

[09:21] <isBEKaml> sixperl? I haven't seen that before. 

[09:21] <masak> rakudo: say my $a

[09:21] <p6eval> rakudo 7017d2: OUTPUT«Any()␤»

[09:22] <isBEKaml> masak: shouldn't it throw some exception in the saycall? my $b?

[09:22] <isBEKaml> rakudo: say my $b 

[09:22] <p6eval> rakudo 7017d2: OUTPUT«Any()␤»

[09:23] <isBEKaml> pfft. 

[09:23] <masak> :)

[09:23] <masak> isBEKaml: declarations are just expressions.

[09:23] <masak> isBEKaml: no, the issue is that in the second iteration, $b is 42.

[09:23] *** skangas joined
[09:24] <isBEKaml> masak: ah, I see.. #don't know how I missed it :(

[09:24] <isBEKaml> find-vars? 

[09:25] <masak> find-vars is working fine.

[09:25] <masak> there's a deeper issue at work. Yapsi doesn't get a fresh lexpad for each new iteration. it should.

[09:25] * sorear out

[09:25] *** azert0x joined
[09:26] <isBEKaml> masak: one more thing I noticed in my cursory reading of the source. the block expressions always treated in 'main' scope. this is expected?

[09:27] <masak> not quite sure what you mean.

[09:27] <isBEKaml> will come back after looking at the source more closer. 

[09:27] <masak> right now, all the block names are prefixed 'main', but that's just convention.

[09:30] <jnthn> oh lol I can be concious too

[09:31] <isBEKaml> I see, so that's just naming convention... 

[09:32] <masak> isBEKaml: yes. yesterday, trying to solve the above issue, I briefly toyed with the idea of just naming the blocks 'block0', 'block1', etc.

[09:34] <jnthn> phenny: tell pmichaud that incorporate_candidates is primarily used for the situation where we have multis from outer scopes and need to add those. Please keep it separate as we'll need it to also be able to sort or tie-break on outerness one day.

[09:34] <phenny> jnthn: I'll pass that on when pmichaud is around.

[09:35] <masak> isBEKaml: right now, Yapsi cheats quite intolerably, actually, and derives block outer/inner relationships by virtue of whether one is a prefix of the other. that won't fly in the long run, so I should probably go ahead and start by factoring away that.

[09:37] <isBEKaml> masak: I didn't quite see that. I was totally glazed out when I saw those sicify parts :D

[09:37] <masak> yeah. I should probably add some comments in those areas.

[09:38] <isBEKaml> or add a doc that explains the SIC model

[09:38] <masak> that'd be nice, too.

[09:39] <masak> basically though, this is the way the compiler works: program text --[grammar]--> $/ --[find-vars]--> $/ --[sicify]--> SIC.

[09:40] <masak> the find-vars step makes sure that any use of a variable $a is always preceded by a declaration 'my $a'.

[09:40] <masak> the sicify step serializes the $/ tree into actual instructions.

[09:42] <isBEKaml> I see.. 

[09:46] *** agentzh left
[09:47] * jnthn sips coffee and waits for awakeness to come about

[09:49] <masak> both find-vars and sicify mix traversal code and actual things-they-do. I've been thinking of ways to separate traversal and the interesting stuff.

[09:52] *** plobsing left
[09:55] *** tadzik joined
[09:55] <masak> there's an spj paper about not having to write a lot of traversal code manually. it's called "Scrap Your Boilerplate" -- http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps

[09:56] <masak> I don't think all of the Haskell tricks are applicable to languages like Perl 6, but it definitely gives hints of better ways to do things.

[09:56] <masak> the other day I did a proof-of-concept auto-traverser using Match.caps. that seemed to be a very viable approach.

[09:57] <masak> so there are definitely better ways to do it than Yapsi's current approach.

[10:01] <masak> sorear, TimToady: CursorBase.pmc:L1852 seems to expect a $PERL6LIB variable to be set. the README doesn't mention this at all.

[10:01] <isBEKaml> masak: I'll look into it and see if I can come up with something. (No guarantees, though) ;)

[10:01] <masak> isBEKaml: nice. best of luck.

[10:02] <masak> ah; it all works fine if $PERL6LIB is unset.

[10:03] <masak> did anyone ever figure out whence the "Deep recursion" warnings came?

[10:03] *** masonkramer left
[10:03] *** masonkramer joined
[10:04] <isBEKaml> masak: With what I have taken up, I think I'll need it. :)

[10:06] <masak> isBEKaml: relax, many of us here are amateurs. there are certainly knowledgeable people with credentials too (especially in the "core group"), but most of us manage to contribute stuff without a CS major. :)

[10:07] *** zed_ joined
[10:07] <masak> ooh, viv output is kinda cute nowadays :)

[10:08] <isBEKaml> masak: No, I meant my $DAYJOB. Last few weeks have been especially hectic. lots of luck enough to have time to yapsi yapsi. 

[10:08] <masak> ah. well, I've yet to meet someone who says "oh, I wish I had *less* time available to do the things I want rather than the things I need to do!" :)

[10:09] <masak> std: package Foo {}; my $*Foo::bar

[10:09] <p6eval> std 31533: OUTPUT«ok 00:01 111m␤»

[10:10] <masak> rakudo: package Foo {}; my $*Foo::bar = 42; say $*Foo::bar

[10:10] <p6eval> rakudo 7017d2: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/pSglJZ4wt1␤»

[10:10] *** zed_ left
[10:12] *** zed_ joined
[10:14] <masak> 637 new/open/stalled bugs in RT. 367 (58%) by some fellow named masak. :P

[10:15] <jnthn> How far to the 1000th? ;-)

[10:15] <masak> it takes a while to check. I think I'm in the 800s.

[10:15] <jnthn> gaaaah...it's too early for metamodel hacking...

[10:15] <isBEKaml> how long did he take to the 500th? double that!

[10:15] <masak> :)

[10:15] <isBEKaml> no halve it! :D

[10:15] <masak> isBEKaml: on average, it's one new ticket a day. I've been at it since mid-2008.

[10:16] <isBEKaml> masak: I still remember the twigil bug that we accidentally stumbled upon. :)

[10:17] <masak> which one was that?

[10:17] *** zed_ left
[10:17] <isBEKaml> don't know the RT number. something around my $^a passing rakudo. 

[10:19] <isBEKaml> that's when I really understood what twigils were and how they were meant to be auto-vivifying themselves. 

[10:28] <masak> nice.

[10:28] <masak> I don't remember it at all.

[10:29] <masak> "auto-vivifying" is probably a misnomer in this case, but yeah.

[10:31] <masak> since 2008-05-07, I've submitted 914 RT tickets.

[10:33] <masak> isBEKaml: ah, found it: http://rt.perl.org/rt3/Ticket/Display.html?id=75264

[10:35] <isBEKaml> masak: yes. :)

[10:37] <jnthn> phenny: tell pmichaud currently every P6object has an attribute it almost certainly never uses (addattribute $P0, '%!properties') - can we toss it?

[10:37] <phenny> jnthn: I'll pass that on when pmichaud is around.

[10:38] *** synth left
[11:05] <jnthn> rakudo: role R { method foo { ... } }; class C {}; (C.new does R).^methods(:local)>>.name>>.say;

[11:05] <p6eval> rakudo 7017d2: OUTPUT«foo␤»

[11:06] <masak> rakudo: sink 42

[11:06] <p6eval> rakudo 7017d2: OUTPUT«Could not find sub &sink␤  in main program body at line 11:/tmp/fKMAo1F8Hv␤»

[11:07] <masak> huh? what did http://github.com/rakudo/rakudo/commit/233401137e161f878b63044e7a1f371fd06817f3 add if the above doesn't work?

[11:08] <colomon> masak: is p6eval behind again?

[11:09] <colomon> > sink (1..10).map({.say})

[11:09] <colomon> 1

[11:09] <masak> it claims to be on the latest commit.

[11:09] <colomon> 2

[11:09] <colomon> 3

[11:09] <colomon> etc

[11:09] <colomon> it also claimed to be latest commit last time it was a couple of days behind.

[11:09] <masak> it shouldn't claim that.

[11:09] <isBEKaml> 7017d2 -> latest commit? 

[11:09] <masak> yes.

[11:09] <masak> it should claim to be on the commit it's on :P

[11:10] <isBEKaml> "claim", yes. :D

[11:10] <masak> that would be much more helpful.

[11:12] <isBEKaml> mine at 7df2c2 shows the same output as colomon's did. 

[11:12] <isBEKaml> that's assuming mine is older than what p6eval shows. 

[11:13] <isBEKaml> must be since I built this a couple of days ago. 

[11:14] *** rv2733 joined
[11:15] <colomon> masak: as I'm going away for a week in about fifteen minutes, and I haven't accomplished this yet, I'm charging you with worrying about the complete wrongness of http://en.wikipedia.org/wiki/Perl_6#Gather

[11:15] <masak> OH NOES

[11:15] <masak> colomon: ok, task accepted. thanks for the heads-up.

[11:15] <colomon> masak++

[11:15] <masak> colomon: have a nice away.

[11:15] <colomon> masak: have a nice hackathon!

[11:15] <jnthn> colomon: Enjoy your away :-)

[11:16] <isBEKaml> colomon: enjoy your vacation! :)

[11:17] *** pmurias joined
[11:17] <pmurias> TimToady: ping

[11:17] <isBEKaml> masak: disregard what I said above. that particular commit was made on Jun 26. :|

[11:18] <masak> rakudo: my @squares = gather for 0..Inf { take $_ * $_ }; say @squares[5]

[11:18] <p6eval> rakudo 7017d2:  ( no output )

[11:18] <jnthn> rakudo: my @suqares = map * * *, 0..Inf; say @squares[3];

[11:18] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Symbol '@squares' not predeclared in <anonymous> (/tmp/s5raMgb1eH:11)␤»

[11:18] <jnthn> rakudo: my @squares = map * * *, 0..Inf; say @squares[3];

[11:18] <p6eval> rakudo 7017d2:  ( no output )

[11:19] <masak> rakudo: say (map * * *, 0..Inf)[3]

[11:19] <p6eval> rakudo 7017d2: OUTPUT«42␤»

[11:19] <masak> 42!?

[11:19] <masak> oh.

[11:19] <masak> *lol*

[11:19] <tadzik> The answer to life, the universe and everything :)

[11:19] <isBEKaml> lol

[11:19] <tadzik> Even rakudo knows

[11:20] <masak> Rakudo++

[11:20] <masak> I thought I'd be getting 9 or something...

[11:20] <masak> ...but 42 is actually correct!

[11:20] <jnthn> Wow! :-)

[11:21] <isBEKaml> now we know what the question is! :D

[11:21] <tadzik> :D

[11:21] <tadzik> \o/

[11:21] <colomon> errr... the problem with the example is that you cannot assign a not-known-infinite (but really infinite) list to a @ variable by =

[11:22] <masak> isBEKaml: ssh! it's rumored that if anyone ever finds out, the universe will reboot.

[11:22] <masak> colomon: right, that's the "mostly eager" thing, I guess.

[11:22] <isBEKaml> masak: oh, wait. I didn't tell anyone. <Looks behind warily... >

[11:22] <jnthn> Shouldn't we assume infinite unless we know otherwise?

[11:23] <jnthn> Or does that get us into other kinds of trouble?

[11:24] <colomon> jnthn: IMO yes, but neither the spec nor pmichaud agrees, and I assume they have a good reason that I just don't understand.

[11:26] <masak> I suppose it has to do with people's expectations when they do array assignment.

[11:28] *** timbunce joined
[11:39] *** mmcleric joined
[11:42] <masak> couldn't we have a 'given for'?

[11:44] <masak> std: sub isprime() {}; given for 2, 3, 5, 6, 7 { when isprime($_) { ... }; default { die "OH NOES!" } }

[11:44] <p6eval> std 31533: OUTPUT«===SORRY!===␤Undeclared routine:␤      'for' used at line 1␤Check failed␤FAILED 00:01 116m␤»

[11:45] <jnthn> for by default already topicalizes if you don't have an argument.

[11:45] <masak> d'oh!

[11:46] <masak> once again, Perl 6 is already as awesome as I would like it to be.

[11:46] <jnthn> rakudo: for 1,2,3 { when 2 { say "oo"; }; default { say "n" } }

[11:46] <p6eval> rakudo 7017d2: OUTPUT«n␤oo␤n␤»

[11:47] *** colomon left
[11:47] <masak> rakudo: for 1..3 { when * % 2 { say "oo" }; when * %% 2 { say "n" } }

[11:47] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 11␤»

[11:48] <masak> rakudo: my $a = * % 2; say $a(5)

[11:48] <p6eval> rakudo 7017d2: OUTPUT«1␤»

[11:48] <masak> rakudo: my $a = * %% 2; say $a(5)

[11:48] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Confused at line 11, near "my $a = * "␤»

[11:48] * masak submits rakudobug

[11:48] <masak> rakudo: say 5 %% 2

[11:48] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Confused at line 11, near "say 5 %% 2"␤»

[11:48] <masak> oh.

[11:49] <masak> out-of-date p6eval.

[11:50] <isBEKaml> is 5 %% 2 == 0?

[11:50] <isBEKaml> isn't it 1?

[11:51] <masak> isBEKaml: no, that's 5 % 2 :)

[11:53] <isBEKaml> D'oh! %% checks for divisibility while % is modulo. :(

[11:53] *** meppl joined
[11:53] <masak> correct.

[11:59] *** snuff joined
[12:13] *** pragma_ joined
[12:14] *** pragma_ is now known as Guest76215

[12:15] *** clintongormley joined
[12:15] *** sftp joined
[12:22] *** timbunce left
[12:24] *** rv2733 left
[12:52] *** pmichaud joined
[12:53] <pmichaud> good morning, #perl6

[12:53] <phenny> pmichaud: 09:34Z <jnthn> tell pmichaud that incorporate_candidates is primarily used for the situation where we have multis from outer scopes and need to add those. Please keep it separate as we'll need it to also be able to sort or tie-break on outerness one day.

[12:53] <phenny> pmichaud: 10:37Z <jnthn> tell pmichaud currently every P6object has an attribute it almost certainly never uses (addattribute $P0, '%!properties') - can we toss it?

[12:54] <pmichaud> jnthn: I'm fine with tossing %!properties

[12:54] *** M_o_C joined
[12:55] <pmichaud> might need a deprecation cycle for it.

[13:08] <jnthn> pmichaud: ping

[13:08] <pmichaud> jnthn: pong

[13:08] <jnthn> pmichaud: I've hit on a...nasty.

[13:08] <jnthn> rakudo: class Foo { }; say Foo.WHAT

[13:08] <p6eval> rakudo 7017d2: OUTPUT«Foo()␤»

[13:08] <jnthn> rakudo: class Foo { }; say Foo.HOW.WHAT

[13:08] <p6eval> rakudo 7017d2: OUTPUT«Foo()␤»

[13:09] <jnthn> rakudo: class Foo { }; say ClassHOW.WHAT

[13:09] <p6eval> rakudo 7017d2: OUTPUT«ClassHOW()␤»

[13:09] <jnthn> rakudo: class Foo { }; say Foo.HOW ~~ ClassHOW

[13:09] <p6eval> rakudo 7017d2: OUTPUT«1␤»

[13:09] <jnthn> rakudo: class Foo { }; say Foo.HOW ~~ Foo

[13:09] <p6eval> rakudo 7017d2: OUTPUT«1␤»

[13:09] <jnthn> pmichaud: Basically Foo.HOW.WHAT giving back Foo rathr than ClassHOW is really bad.

[13:09] <jnthn> *rather

[13:10] <jnthn> pmichaud: The underlying issue I'm trying to deal with is that at the moment we can't mix into a metaclass

[13:10] <jnthn> Which means than doing various package traits neatly is a no-go

[13:12] <pmichaud> looking.

[13:12] <jnthn> pmichaud: I has a P6object patch to change that.

[13:12] <jnthn> pmichaud: It also let me remove an Evil Hack in ClassHOW.pir

[13:13] <jnthn> We're a few S12 spectests down but not many and hopefully easily fixed.

[13:13] <pmichaud> can I see the patch?  ;-)

[13:13] <jnthn> Which one? P6object?

[13:13] <pmichaud> yes

[13:13] <jnthn> it removes more than it adds ;-)

[13:13] <jnthn> pasting

[13:14] <jnthn> http://gist.github.com/462559

[13:14] <jnthn> pmichaud: ^

[13:14] <pmichaud> do the p6object tests pass with the patch?

[13:14] <jnthn> Yes

[13:15] <jnthn> Well, all the Parrot tests pass, I'm sure it runs p6object tests within that.

[13:15] <jnthn> yes

[13:15] <jnthn> just ran them independently too

[13:15] <jnthn> All pass.

[13:16] <pmichaud> I'm just thinking to make sure we're not likely to break something else somewhere.

[13:16] <jnthn> *nod*

[13:18] <pmichaud> I think I'm fine with the p6object patch.

[13:18] <jnthn> pmichaud: spectested - the only places we break is in S12-introspection

[13:19] <jnthn> Which I bet is because I relied on those semantics.

[13:19] <jnthn> pmichaud: OK, thanks.

[13:19] <pmichaud> well, I'm more worried about what we break outside of rakudo :-)

[13:19] <jnthn> *nod*

[13:19] <pmichaud> but we'll call it a bug

[13:19] <jnthn> Yes, it feels just wrong ituitively to me

[13:20] <jnthn> Metaclasses shouldn't be special - they're just classes. :-)

[13:21] <masak> +1

[13:21] <pmichaud> I've managed to redo multisub handling, now I'm just chasing down errors that it exposes

[13:22] <jnthn> pmichaud++ \o/

[13:22] <pmichaud> (can't even get "make test" to run atm, though)

[13:22] <jnthn> That's not so surprising given how much core functionality depends on multis. ;-)

[13:22] <pmichaud> the new code is much more straightforward

[13:23] <pmichaud> for one, there's a lot less special-casing between lexical and package multisubs

[13:23] <masak> pmichaud: it might please you to know that pls now has a failing test which will pass as soon as Rakudo does closure cloning right. :)

[13:23] <pmichaud> the new code also handles:

[13:23] <pmichaud> my $x = our multi sub abc(Int $y) { ... };

[13:24] <pmichaud> which installs a candidate in &abc  but sets $x to be only the specific candidate.

[13:24] <jnthn> Oh nice

[13:24] <jnthn> That'll fix a ticket. :-)

[13:24] <jnthn> I hadn't been looking forward to fixing that. ;-)

[13:25] <pmichaud> it's simple, now.  :)

[13:25] <pmichaud> well, assuming I can get the darn compiler to run again.  :-)

[13:26] <pmichaud> the problem with having so much in the setting is that once the setting doesn't compile properly, you're pretty much stuck.  :-|

[13:26] <masak> Perl 7 will have a minimal setting. :)

[13:27] <pmichaud> Null PMC access in find_method('!select')

[13:27] <jnthn> oh sh...

[13:27] <pmichaud> that's where I'm stuck now.

[13:27] <jnthn> Well, that means a role is hosed somewhere. :-|

[13:27] <jnthn> pmichaud: Turn off Perl 6 backtraces and paste me the PIR backtrace, please.

[13:28] <pmichaud> http://gist.github.com/462567

[13:29] <jnthn> ewwwww

[13:29] <pmichaud> fwiw, I did not touch any of the perl6multisub code except to add a new method.

[13:29] <jnthn> I guess Parcel is declared as does Positional?

[13:29] <pmichaud> it is.

[13:29] <jnthn> OK

[13:30] <jnthn> That may be the first time in the setting we actually call "does"

[13:30] <jnthn> If so, it is also the first time we try to do a multi-dispatch to trait_mod:<does>

[13:30] <jnthn> Which in turn may be the first time we try to do a multi-dispatch.

[13:30] <pmichaud> I'm curious as to what is calling .perl, too.  :)

[13:30] <jnthn> er, so am I

[13:30] <jnthn> Oh

[13:30] <pmichaud> I didn't change anything for multi-methods

[13:30] <jnthn> One good guess

[13:30] <pmichaud> (yet)

[13:30] <jnthn> (traits are multi subs. our'd multi subs.)

[13:31] <pmichaud> ohhhhhhhhh

[13:31] <jnthn> Is that a type check fails

[13:31] <jnthn> See src/core/traits.pm

[13:31] <masak> pmichaud: #73034 is now officially the new #58392. :)

[13:31] <jnthn> Or the dispatch fails

[13:31] <jnthn> And .perl is called in trying to make an error.

[13:31] <pmichaud> okay

[13:32] <jnthn> pmichaud: I don't know if I pushed this yet, but I noticed a fail in traits.pm where some things that shoulda been makred "our" were not

[13:32] <jnthn> As in, some candidates were marked that and other were not

[13:32] <jnthn> I committed by maybe didn't push that

[13:32] <jnthn> Anyway, one other thing to do is to run the stage-1 compiler

[13:32] <pmichaud> looks like everything in traits.pm is 'our'

[13:32] <jnthn> Oh, OK

[13:32] <jnthn> I think I musta introduced and then fixed a fail of my own yesterday then.

[13:33] <pmichaud> stage-1 compiler doesn't get very far, it depends on stuff from the setting.

[13:33] <jnthn> If you run the stage-1 compiler and try to write a couple of our-scoped multis...

[13:33] <jnthn> Oh?

[13:33] <jnthn> You can't even start it

[13:33] <jnthn> ?

[13:33] <pmichaud> I can start it

[13:33] <pmichaud> I can compile to PIR

[13:33] *** timbunce joined
[13:33] <pmichaud> but some things don't run

[13:33] <jnthn> *nod*

[13:33] <pmichaud> e.g.,  $*ARGFILES

[13:33] <jnthn> Not entirley surprising

[13:33] <jnthn> Check the PIR though

[13:33] <jnthn> For an our-scoped multi

[13:33] <jnthn> And make sure it's what you expected there.

[13:33] <pmichaud> okay, will do that.

[13:34] <jnthn> I very much suspect it's a trait dispatch gone rong though.

[13:36] <masak> rakudo: say "UR DOIN IT ", 'gnor'.uc.flip

[13:36] <p6eval> rakudo 7017d2: OUTPUT«UR DOIN IT RONG␤»

[13:36] <masak> rakudo: say "UR DOIN IT ", 'gnor'.comb.sort.join.flip

[13:36] <p6eval> rakudo 7017d2: OUTPUT«UR DOIN IT rong␤»

[13:36] <pmichaud> aha, I has a fail.

[13:36] <pmichaud> jnthn++

[13:36] <masak> rakudo: say "UR DOIN IT ", 'gnor'.comb.sort.join.uc.flip

[13:37] <p6eval> rakudo 7017d2: OUTPUT«UR DOIN IT RONG␤»

[13:38] *** hercynium left
[13:38] <masak> rakudo: say "UR DOIN IT ", 'please ignore most of the contents of this string'.comb[8..11].sort.join.uc.flip

[13:38] <p6eval> rakudo 7017d2: OUTPUT«UR DOIN IT RONG␤»

[13:38] <masak> :)

[13:38] * jnthn GNORs on a stroopwafel

[13:40] <tadzik> wow :)

[13:41] <pmichaud> jnthn: so, what I ultimately ended up doing was to create Perl6MultiSub.merge_candidates

[13:41] <pmichaud> it merges the candidates from another Perl6MultiSub, but skips any duplicates (by subid)

[13:42] <jnthn> pmichaud: +1

[13:42] <jnthn> pmichaud: I'll glance over it post-commit

[13:42] <pmichaud> so for our-scoped multis in a block, we create a Perl6MultiSub for the our-scoped multis in the the blcok

[13:42] <jnthn> pmichaud: YOu left incorporate_candidates as a separate method?

[13:43] <pmichaud> then we do   .merge_candidates based on the existing package-scoped Perl6MultiSub

[13:43] <jnthn> pmichaud: That is, you haven't conflated "update the candidates" with "add these candidates from an outer scope"?

[13:43] <pmichaud> and store the result back into the package (as well as a lexical)

[13:43] <jnthn> +1 on the approach for packages

[13:43] <pmichaud> well, I use merge_candidates also for "add from outer scope"

[13:44] <jnthn> erm

[13:44] <jnthn> For lexical multis?

[13:44] <pmichaud> Yes

[13:44] <jnthn> oh no

[13:44] <jnthn> I said plesae don't do that.

[13:44] <pmichaud> it doesn't change anything.

[13:44] <jnthn> I know it doesn't *now*

[13:45] <jnthn> But later 

[13:45] <jnthn> multi foo() { }; { multi foo() { }; foo() }

[13:45] <jnthn> That's meant to work

[13:45] <jnthn> At some point

[13:45] <jnthn> Because we will want to tie-break on scope depth

[13:46] <jnthn> And I had incorporate_candidates separate as my "here's where I'll make that work" hook.

[13:46] <jnthn> I probably shoulda explained that better yesterday.

[13:46] <pmichaud> I understand.  It's trivially easy to fix.

[13:46] <pmichaud> I did not eliminate incorporate_candidates.

[13:47] <jnthn> OK. :-)

[13:47] <pmichaud> I'm not using it for lexical multis at the moment, but that can be fixed. 

[13:47] <pmichaud> We can also fix merge_candidates so that it understands scoping.

[13:48] <pmichaud> so I went with the "keep common-looking-things-the-same" approach for now, knowing we can change it easily.

[13:49] <jnthn> OK

[13:49] <jnthn> I'm not sure if merge_candidates needs to...I'll have to see the code.

[13:49] <jnthn> Anyway, OK, we can fix it later I guess.

[13:52] <pmichaud> okay, my codegen is definitely not quite right

[13:52] <pmichaud> need a break then will fix

[13:52] <masak> 'break' in Perl 6 is now called 'succeed'. sounds a lot more positive. :)

[13:56] * jnthn looks forward to this evening's curry succeed

[13:59] <pmurias> TimToady: why does setting $ALL->{'UNIT'} also set $ALL->{'MY:file<MildewCORE.setting>'}?

[14:01] * jnthn spectests the bunch of meta changes

[14:04] *** skids joined
[14:09] <pmichaud> aha, found it...(I think)

[14:09] <pmichaud> since   our multi sub .... has both a block and package component, can't use  $symbol<multi> for both.  :-)

[14:10] <jnthn> Ah.

[14:11] *** JimmyZ joined
[14:11] <pmichaud> so it was never generating the .loadinit

[14:11] <masak> 卓明亮! \o/

[14:11] <JimmyZ> 麦高！下午好！

[14:11] <pmichaud> yay!  "make test" runs again!

[14:12] <JimmyZ> O(∩_∩)O哈哈~

[14:12] *** Guest76215 left
[14:12] *** Guest76215 joined
[14:12] *** Guest76215 is now known as pragma_

[14:13] <pmichaud> yay!  The test I was failing now passes!

[14:13] <jnthn> \o/

[14:13] * pmichaud optimistically runs "make spectest"

[14:13] <masak> JimmyZ: 很高兴见到你

[14:14] <JimmyZ> masak: 我也一样，(*^__^*) 嘻嘻……

[14:15] <JimmyZ> masak: Does Yaspi have roadmap?

[14:15] <masak> JimmyZ: a small one, in the README.

[14:15] <jnthn> pmichaud: In other news, my broked introspection tests pass too ;-)

[14:15] <pmichaud> so far, no failz in spectest.

[14:16] <jnthn> :-)

[14:16] <jnthn> Same here

[14:16] <jnthn> Down to S15 now

[14:16] <jnthn> er, S16

[14:16] <jnthn> Which means all the interesting tests have passed

[14:16] <jnthn> ;-)

[14:16] <JimmyZ> masak: good

[14:17] <pmichaud> I'm only up to S04

[14:17] <pmichaud> one smartmatch failure

[14:17] <jnthn> aw

[14:18] <pmichaud> (which I'll likely regress on for today)

[14:18] <pugssvn> r31534 | pmurias++ | [CursorBase] work around nasty bug in Storable 

[14:19] <jnthn> pmichaud: +1

[14:20] <pmichaud> RT #72048

[14:20] <pmichaud> (is the one I'm failing)

[14:21] *** ashleydev joined
[14:22] <jnthn> pmichaud: :S

[14:22] <pmichaud> yeah, getting some S12 fails now

[14:23] <jnthn> Yes, I very much doubt that test can be failed in isolation.

[14:25] <pmichaud> I'm likely to need some help debugging the role failures.

[14:25] <jnthn> pmichaud: S14 tests may be informative.

[14:25] <jnthn> I suspected so. ;-)

[14:25] <pmichaud> yes, they are.

[14:25] <pmichaud> I'll commit and push.

[14:25] <jnthn> Feel free to paste details

[14:25] <jnthn> My spectest run is nearly done

[14:25] <jnthn> After that I can switch branches and help out

[14:27] <pmichaud> pushed.

[14:27] <jnthn> branch name?

[14:27] <pmichaud> I should also probably try mergine with master, since some fixes / changes have been made since I created the branch.

[14:28] <pmichaud> *merge

[14:28] <jnthn> OK

[14:28] <jnthn> wait for me to push

[14:28] <pmichaud> will wait.

[14:28] <jnthn> I hope there'll be no conflicts. I suspect you've not touched meta-model stuff really

[14:28] <jnthn> If you have a paste of which test files fail, I'd be curious to see it

[14:28] <jnthn> particularly S14

[14:28] <pmichaud> still waiting for the spectests

[14:29] <pmichaud> the only S14 that failes is parameterized-basic.t

[14:29] <pmichaud> *fails

[14:29] <jnthn> oh

[14:29] <jnthn> And the S12 ones? Are we talking many or few?

[14:29] <pmichaud> neither a lot nor a little

[14:29] <jnthn> ok

[14:29] <pmichaud> looks like five test files

[14:29] <jnthn> ok

[14:29] <pmichaud> (don't know how many tests in each yet)

[14:30] <pmichaud> ah, I bet I know the problem.

[14:30] * jnthn is in trig test purgatory

[14:30] <jnthn> pmichaud: If the parametric roles tests fail that's not too surprising.

[14:31] <jnthn> pmichaud: They do tricks with closure-ish stuff

[14:31] <pmichaud> looks like I'm getting a Code object that has an incomplete Sub

[14:31] <jnthn> Line cloning the Methods per parameterization so they capture the right type parameter

[14:31] <jnthn> Ah

[14:31] <jnthn> *Like

[14:31] <pmichaud> like, perhaps, a Sub without a lazysig or llsig

[14:31] <jnthn> Oh

[14:31] <jnthn> oh oh oh

[14:31] <jnthn> Could it be to do with generic sigs?

[14:32] <pmichaud> what's a "generic sig"?   ;-)

[14:32] <jnthn> (::T $x, T $y) style stuff

[14:32] <jnthn> Where the T here is a thunk

[14:32] <pmichaud> oh, yes, it could be that the thunking isn't thunked

[14:32] <pmichaud> looking

[14:32] <jnthn> Features in the S14 one you fail

[14:35] <pmichaud> http://gist.github.com/462610  # my test failure summary

[14:35] <jnthn> t/spec/S06-multi/proto.rakudo # hmm

[14:36] <jnthn> hmm...hard to spot an easy pattern in those S12 ones just from the test names

[14:36] <pmichaud> oh, I'm also getting

[14:36] <jnthn> t/spec/S12-introspection/methods.t is a very odd one to fail

[14:36] <pmichaud> Multiple declarations of lexical '&bar'

[14:36] <pmichaud> that's... interesting.

[14:37] <jnthn> hm

[14:37] <jnthn> t/spec/S12-introspection/methods.t doesn't do much clever besides declare methods and introspect them

[14:37] <jnthn> Could make it easy to spot the fail

[14:37] <masak> rakudo: class A { method foo() { return rand() < .5 } }; class B is A { method foo() { my $result = callsame; say $result ?? "success" !! "failure" } }; B.new.foo for ^5

[14:37] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Unsupported use of rand(); in Perl 6 please use rand at line 11, near "() < .5 } "␤»

[14:37] <masak> rakudo: class A { method foo() { return rand < .5 } }; class B is A { method foo() { my $result = callsame; say $result ?? "success" !! "failure" } }; B.new.foo for ^5

[14:37] <p6eval> rakudo 7017d2: OUTPUT«failure␤success␤failure␤failure␤success␤»

[14:38] <masak> \o/

[14:38] <pmichaud> I think I'm not detecting proto properly.

[14:38] <pmichaud> or.... hmm.

[14:39] <masak> "Pls is less prototyping... and more pleasing." -- jnthn++ :)

[14:40] <pmichaud> yes, I'm failing to detect "sub after proto"

[14:41] <jnthn> ah

[14:41] <isBEKaml> masak: callsame akin to super() ? 

[14:42] <jnthn> along those lines

[14:42] <jnthn> but better ;-)

[14:42] <masak> rakudo: class A { method foo { say "original foo" } }; role Mixin { method foo { say "before!"; callsame; say "after!" } }; (A.new but Mixin).foo

[14:42] <p6eval> rakudo 7017d2: OUTPUT«before!␤original foo␤after!␤»

[14:42] <masak> jnthn++++++++++

[14:42] <masak> this is so cool!

[14:42] <pmichaud> testing proto fix

[14:44] <isBEKaml> class but role? # I really need to get my head around to reading the spec.. ;)

[14:44] <pmichaud> proto fix may also explain some of the operator-related fails.

[14:45] <masak> isBEKaml: actually, object but role. A.new is an instance.

[14:45] <arnsholt> masak: pong?

[14:46] <isBEKaml> rakudo: role Foo { method do_what { say "I'm doing it!" } }; class Bar does Foo { method do_what { say "me? "; callsame; say "me again? "; } }; Bar.new.do_what;

[14:46] <p6eval> rakudo 7017d2: OUTPUT«me? ␤me again? ␤»

[14:46] <masak> arnsholt: did you see spinclad's comment in the backlog about the sorting of paths in ufo?

[14:46] <isBEKaml> No? 

[14:47] <isBEKaml> rakudo: role Foo { method do_what { say "I'm doing it!" } }; class Bar does Foo { method do_what { say "me? "; callsame; say "me again? "; } }; (Bar.new but Foo).do_what;

[14:47] <p6eval> rakudo 7017d2: OUTPUT«Could not find sub &say␤  in 'do_what' at line 11:/tmp/MGtYyzKBaY␤  in main program body at line 11:/tmp/MGtYyzKBaY␤»

[14:47] <masak> isBEKaml: as to the first one...

[14:47] <masak> isBEKaml: the method in the class shadows the one in the role.

[14:47] <masak> isBEKaml: so there's nothing to 'nextsame' to.

[14:47] <pmichaud> jnthn: pushed fix for protos

[14:47] <pmichaud> re-spectesting.

[14:48] <jnthn> pmichaud: pushed stuff in master

[14:48] <masak> isBEKaml: second one: &say in roles is a well-known (and irritating) bug.

[14:48] <arnsholt> masak: No, i didn't. Was it aroun your ping?

[14:48] <masak> arnsholt: hold on, I'll find it for you.

[14:48] <masak> http://irclog.perlgeek.de/perl6/2010-07-02#i_2506626

[14:49] <isBEKaml> the second one made me go wtf? 

[14:49] <arnsholt> Cheers

[14:49] <pmichaud> masak: I'm wondering if my latest fixes will help the &say bug.

[14:49] <jnthn> pmichaud: so am I ;-)

[14:49] <masak> tentative \o/

[14:49] <isBEKaml> \o/ #hopefully

[14:49] <pmichaud> it seems plausible, at least.

[14:50] <pmichaud> S14-roles/parameterized-basic.t still fails for me

[14:50] <jnthn> It doesn't have a sinlge proto

[14:50] <jnthn> So it wasn't going to be that.

[14:50] <arnsholt> masak: D'oh. That's a very good point

[14:50] <isBEKaml> rakudo: role Foo { method do_what { say "I'm doing it!" } }; class Bar does Foo { method do_what { say "me? "; nextsame; say "me again? "; } }; (Bar.new).do_what;

[14:50] <p6eval> rakudo 7017d2: OUTPUT«me? ␤me again? ␤»

[14:50] <masak> arnsholt: care to draft up a fix?

[14:51] <jnthn> isBEKaml: That is correct

[14:51] <dalek> rakudo: ffe80d7 | jonathan++ | src/ (2 files):

[14:51] <dalek> rakudo: Re-implement is default trait for multis.

[14:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ffe80d7dd7ed80e855d41595a1fad65b6a37ff49

[14:51] <dalek> rakudo: 5954d61 | jonathan++ | t/spectest.data:

[14:51] <dalek> rakudo: Turn on S12-methods/default-trait.t. This means that S12 is no longer the 

[14:51] <dalek> rakudo: synopsis with the most regressed test files from the alpha days.

[14:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5954d61406046054661666f3dc69b060fbdb9f75

[14:51] <dalek> rakudo: 9551482 | jonathan++ | src/ (2 files):

[14:51] <dalek> rakudo: First cut of starting to get 'is hidden' do work again. Not a complete 

[14:51] <dalek> rakudo: implementation.

[14:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9551482bca3ea4367d54e34c101b836cf0ba5ed6

[14:51] <dalek> rakudo: f509251 | jonathan++ | src/metamodel/ClassHOW.pir:

[14:51] <dalek> rakudo: Rip out old hidden implementation.

[14:51] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f5092516bb7446b28f46fb9f15d8a307f4cae730

[14:51] <jnthn> awww...it missed patches!

[14:52] <isBEKaml> masak: I see what you meant. 

[14:52] <arnsholt> masak: I'll look into it

[14:52] <arnsholt> Just have to update my laptop Rakudo first

[14:53] <masak> \o/

[14:58] <pmurias> phenny: help

[14:58] <phenny> pmurias: Hi, I'm a bot. Say ".commands" to me in private for a list of my commands, or see http://inamidst.com/phenny/ for more general details. My owner is sbp.

[14:58] <masak> rakudo: { my $a; our sub foo() { $a } }

[14:58] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Symbol '$a' not predeclared in foo (/tmp/1J_da4PFWo:11)␤»

[14:58] <masak> bug or feature?

[14:58] <jnthn> "feature" ;-)

[14:58] <pmurias> isn't phenny responsible for tell?

[14:59] <masak> grrrr...

[14:59] <jnthn> (not really)

[14:59] * masak submits rakudofeature

[14:59] <jnthn> I think that should work.

[14:59] <jnthn> phenny: tell pmurias yes I am

[14:59] <phenny> jnthn: I'll pass that on when pmurias is around.

[14:59] <pmichaud> ah, found it, I think.

[15:00] * jnthn digs into the next bit of trying to get mixing into metaclasses straightened out

[15:00] <jnthn> pmichaud: btw, I was very happy to remove a "it worked but I never quite understood why" hack from ClassHOW after that P6object fix. :-)

[15:00] <pmichaud> jnthn: \o/

[15:02] <JimmyZ> rakudo: { my $a = 'hi'; sub foo() { $a; }; }

[15:03] <p6eval> rakudo 7017d2:  ( no output )

[15:03] <JimmyZ> masak: it's different?

[15:03] <masak> JimmyZ: yes, because subs are 'my'-scoped per default.

[15:04] <JimmyZ> rakudo: { my $a = 'hi'; our sub foo() { $a; }; }

[15:04] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Symbol '$a' not predeclared in foo (/tmp/HUTRCYgA_r:11)␤»

[15:04] <jnthn> That one is likely fixed in pmichaud++'s branch

[15:05] <masak> :)

[15:05] <isBEKaml> rakudo: my $a="hi"; our sub foo() { $a; }

[15:05] <p6eval> rakudo 7017d2:  ( no output )

[15:05] <masak> note that you're not printing anything :)

[15:05] <JimmyZ> std: { my $a = 'hi'; our sub foo() { $a; }; }

[15:05] <isBEKaml> the only thing different from yours is the block _not_ surrounding it. 

[15:05] <p6eval> std 31534: OUTPUT«ok 00:01 115m␤»

[15:06] <JimmyZ> oh bug?

[15:06] <isBEKaml> I'd assume __main__ 

[15:06] <pmichaud> > { my $a = 'hi'; our sub foo() { $a } };   say foo();

[15:06] <pmichaud> hi

[15:06] <masak> isBEKaml: yes. the block was necessary to produce the bug.

[15:06] <masak> pmichaud: \o/

[15:07] <pmichaud> ohhhhhhhh

[15:07] <pmichaud> is *that* why we've had that bug?!?

[15:07] <pmichaud> (I'm surprised that fails in current rakudo.  Now I understand why.)

[15:08] <isBEKaml> rakudo: say {my $a="hi"; our sub foo() { $a }; }; # crazy, let's see... 

[15:08] <p6eval> rakudo 7017d2: OUTPUT«===SORRY!===␤Symbol '$a' not predeclared in foo (/tmp/AAcF8ALfk8:11)␤»

[15:08] <isBEKaml> Ah, expected bug. :)

[15:08] <JimmyZ> rakudo: say {my $a="hi"; sub foo() { $a }; };

[15:08] <p6eval> rakudo 7017d2: OUTPUT«_block46␤»

[15:09] <arnsholt> masak: Eh, right. I think I found the bug

[15:09] <JimmyZ> std: say {my $a="hi"; sub foo() { $a }; }(); # and crazy too.

[15:09] <p6eval> std 31534: OUTPUT«ok 00:01 113m␤»

[15:09] <JimmyZ> rakduo: say {my $a="hi"; sub foo() { $a }; }(); # and crazy too, sorry this one

[15:10] <arnsholt> Change $cur to $prev in the string output to the Makefile, and it works for sorear++'s example >.>

[15:10] <JimmyZ> bad, second typo

[15:10] <jnthn> rakudo: say {my $a="hi"; sub foo() { $a }; }(); 

[15:10] <isBEKaml> rakudo: say {my $a="hi"; sub foo() { $a }; }.(); # crazy _ JimmyZ

[15:10] <p6eval> rakudo 7017d2: OUTPUT«foo␤»

[15:10] <isBEKaml> :D

[15:11] <isBEKaml> but foo for the whole block surrounding foo() ? 

[15:11] <masak> rakudo: say {my $a="hi"; sub foo() { $a }; }.().()

[15:12] <p6eval> rakudo 7017d2: OUTPUT«hi␤»

[15:12] <masak> :P

[15:12] * masak goes away and leaves it to others to explain that :)

[15:12] <isBEKaml> extend .() to what we get as foo. But why do we get foo() for the whole block surrounding sub foo() ? 

[15:13] <masak> arnsholt: sorear's example? do you mean spinclad?

[15:13] <arnsholt> spinclad++ indeed

[15:13] <arnsholt> My brane si highly defective when it comes to names

[15:13] <masak> arnsholt: I'll see if I find it obvious what you mean if I look at the code.

[15:14] <arnsholt> Line 161 of ufo. First occurence of $cur (inside a string) -> $prev

[15:15] <arnsholt> Stupid, really. If the previous dir is not a prefix of the current, you should output the -previous- one, not the -current- one

[15:15] <masak> I think I found it. but it's not line 161 here :)

[15:15] <arnsholt> A big fat brainfart, essentially

[15:15] <arnsholt> Line 161 in HEAD at least =)

[15:15] <masak> arnsholt: does that help entirely, though? we still don't special-treat slashes in any way, and it seems we should...

[15:16] * masak heads to github just to be sure

[15:16] <arnsholt> Sorry!

[15:16] <arnsholt> Line 160

[15:16] <masak> we are now in agreement.

[15:16] <arnsholt> I had a debug say in my code

[15:17] *** ashleydev left
[15:18] <masak> consider the files 'foo/A.pm' and 'football/B.pm'. the corresponding dirs are 'foo' and 'football' (sans slashes).

[15:18] <masak> one is a prefix of the other.

[15:18] <arnsholt> Yeah, I was just thinking of that

[15:18] <masak> that's what spinclad said.

[15:18] *** ashleydev joined
[15:19] <arnsholt> But if you modify directory-of to leave the trailing / that should fix it

[15:19] <masak> it would.

[15:19] <masak> suddenly it feels risky *not* to have tests for this :)

[15:20] *** ashleydev left
[15:20] <arnsholt> Yeah, tests might be a good idea =)

[15:21] *** ashleydev joined
[15:22] <pmichaud> jnthn: seems like 'of' and 'returns' isn't working on method introspection for me.

[15:22] <jnthn> hm

[15:22] <jnthn> rakudo: sub foo() of Int { }; say &foo.of

[15:22] <p6eval> rakudo 7017d2: OUTPUT«Int()␤»

[15:22] <jnthn> (just checking)

[15:23] <jnthn> pmichaud: Is that your ownly failure?

[15:23] <jnthn> pmichaud: If not, I suspect another failure is at the root of this one

[15:23] <pmichaud> > sub foo() of Int { };  say &foo.of;

[15:23] <pmichaud> Mu()

[15:23] <jnthn> our multi trait_mod:<returns>(Routine $r, Mu \$type) { $r does Callable[$type];

[15:23] <jnthn> }

[15:23] <pmichaud> feels like the same problem with S14-roles/parameterized-basic.t

[15:24] <jnthn> Right

[15:24] <pmichaud> or at leas related.

[15:24] <pmichaud> *least

[15:24] <jnthn> Yes

[15:24] <jnthn> I suspect fixing the S14 one will fix that

[15:24] <pmichaud> any suggestions on how to find the S14 problem?

[15:25] *** tylercurtis joined
[15:25] <pmichaud> oh, wait.

[15:25] <jnthn> pmichaud: Can you paste me the full test output?

[15:25] <jnthn> (easier to see what/how it fails that way)

[15:25] <pmichaud> http://gist.github.com/462633

[15:26] <pmichaud> I'm going to look at the role constructor

[15:26] <pmichaud> (in actions.pm)

[15:26] <pmichaud> I bet I changed something there.

[15:26] <pmichaud> so that the signature isn't being applied.

[15:27] <jnthn> youch

[15:27] <jnthn> Yes

[15:27] *** eternaleye joined
[15:27] <jnthn> pm

[15:27] <jnthn> oh

[15:27] <jnthn> pmichaud: You're making it into the role body

[15:27] <jnthn> Then it's failing in the signature binding

[15:28] <jnthn> Almost certainly

[15:28] <pmichaud> right

[15:28] <jnthn> That points to a thunk perhaps

[15:28] <pmichaud> because the signature isn't being attached, likely.

[15:28] <jnthn> Right

[15:28] <pmichaud> I'm guessing

[15:28] <jnthn> But I suspect it's not the role constructor that's the problem

[15:28] <pmichaud>                 $package.signature($<def_module_name>[0]<signature>[0].ast);

[15:28] <pmichaud>                 $package.signature_text(~$<def_module_name>[0]<signature>[0]);

[15:28] <jnthn> But rather thunks

[15:28] <jnthn> Becuase we make it into the role body

[15:28] <jnthn> Which means we used the signautre

[15:28] *** cotto joined
[15:28] <jnthn> pmichaud: Try these in the REPL:

[15:29] <jnthn> role Foo[$x] { }; Foo[42].new

[15:29] <jnthn> role Foo[::T] { }; Foo[Int].new

[15:29] <jnthn> role Foo[::T, T] { }; Foo[Int, Int].new

[15:29] <jnthn> If (or which) of those fail could be informative.

[15:29] <masak> rakudo: enum A <b c d>; sub foo(A $x) {}; foo(b)

[15:29] <p6eval> rakudo 7017d2: OUTPUT«Nominal type check failed for parameter '$x'; expected {"b" => 0, "c" => 1, "d" => 2} but got Int instead␤  in 'foo' at line 11:/tmp/Lq80n6PjTg␤  in main program body at line 11:/tmp/Lq80n6PjTg␤»

[15:29] <masak> ok, so there are three things wrong here.

[15:29] <jnthn> RT'd already

[15:29] <pmichaud> > role Foo[::T] { }; Foo[Int].new

[15:29] <pmichaud> Ambiguous dispatch to multi '_block29'. Ambiguous candidates had signatures:

[15:29] <pmichaud> :(Mu $x)

[15:29] <pmichaud> :(Mu ::T )

[15:29] <jnthn> oh

[15:29] <pmichaud> the first one worked.

[15:29] <jnthn> try each one alone ;-)

[15:29] <masak> jnthn: I suspected that, but I couldn't find it.

[15:29] <pmichaud> oh.

[15:29] <jnthn> Or Foo1, Foo2, Foo3

[15:30] *** justatheory joined
[15:30] <masak> submitting just in case. people with finding skillz can merge.

[15:30] <masak> (1) I'm sending in a role, it should accept the parameter. no error.

[15:30] <pmichaud> jnthn: all three succeeded.

[15:30] <masak> (2) it stringifies the enum in the error message

[15:31] <masak> (3) it reports the unnamed parameter as ''. can probably do better.

[15:31] <jnthn> pmichaud: hmmm :-)

[15:32] *** timbunce left
[15:32] <masak> ah, http://rt.perl.org/rt3/Ticket/Display.html?id=75370

[15:33] <jnthn> pmichaud: OK, I guess it's the boring task of bisecting the test file then. :-(

[15:33] <jnthn> To see which chunk of it explodes

[15:33] <masak> ok, this one alone, then:

[15:33] <masak> rakudo: sub foo(Str) {}; foo 42

[15:33] <p6eval> rakudo 7017d2: OUTPUT«Nominal type check failed for parameter ''; expected Str but got Int instead␤  in 'foo' at line 11:/tmp/QAMDSHJxvP␤  in main program body at line 11:/tmp/QAMDSHJxvP␤»

[15:33] * masak submits rakudobug

[15:34] <jnthn> pmichaud: OOC

[15:34] <jnthn> role Foo[::T] { method bar(T $x) { } }; Foo[Int].bar(42);

[15:35] <jnthn> rakudo: role Foo[::T] { method bar(T $x) { } }; Foo[Int].bar(42);

[15:35] <p6eval> rakudo 7017d2:  ( no output )

[15:35] <jnthn> rakudo: role Foo[::T] { method bar(T $x) { } }; Foo[Int].bar(4/2);

[15:35] <p6eval> rakudo 7017d2: OUTPUT«Constraint type check failed for parameter '$x'␤  in 'bar' at line 11:/tmp/VoCXJqQCqb␤  in main program body at line 11:/tmp/VoCXJqQCqb␤»

[15:35] *** justatheory left
[15:36] <pmichaud> > role Foo[::T] { method bar(T $x) { } };  Foo[Int].bar(4/2);

[15:36] <pmichaud> Constraint type check failed for parameter '$x'

[15:36] <jnthn> :-(

[15:36] <jnthn> Well, it's not that then.

[15:36] <jnthn> Must be somehing mroe subtle

[15:36] <pmichaud> anyway, I'm pretty certain the problem is that a signature or lazy sig isn't being attached.

[15:37] <pmichaud> so, I can debug that.

[15:37] <jnthn> I suggest removing chunks of the S14 test until you find the chunk you have to remove to make the bug happen

[15:37] <jnthn> It may well become very obvious where to look then.

[15:38] <pmichaud> aha!

[15:38] <pmichaud> Important clue:

[15:38] <pmichaud> called from Sub 'perl6;CEven;!class_init_79' pc 11965 (EVAL_1:0) (t/spec/S14-roles/parameterized-basic.rakudo:120)

[15:38] <pmichaud> looks like the problem is in the CEven role.  :-)

[15:39] <pmichaud> er, class.

[15:39] <jnthn> oooh!

[15:39] <pmichaud> anyway, bisected.  :-)

[15:39] <jnthn>     role MD_block[Int $x where { $x % 2 == 0 }] {

[15:39] <jnthn>         method what { 'even' };

[15:39] <jnthn>     }

[15:39] <jnthn> That's the role it composes

[15:39] <pmichaud> right

[15:39] <jnthn> I'll bet it's that "where" block that is missing it's siggy

[15:39] <pmichaud> yes.

[15:40] * jnthn is happy we know where the problem may lie

[15:40] <pmichaud> aha

[15:40] <jnthn> (that'll probably resolve other issues too)

[15:40] <pmichaud>         my $lazy_name := make_lazy_sig_block($expr<past_block>);

[15:40] <pmichaud> make_lazy_sig_block probably doesn't do anything useful.

[15:40] <jnthn> ah

[15:41] <pmichaud> (the other block code no longer uses it)

[15:41] <pmichaud> so, this is the code that confused me earlier.

[15:41] <pmichaud> I'm guessing we have to force the signature to lazy evaluation?

[15:42] <pmichaud> because if $expr is already a block, it seems like its signature would have already been applied.

[15:42] <jnthn> I seem to remember that had to be lazy always, yes

[15:43] <pmichaud> I wonder if it now works for me to make all signatures lazy.

[15:43] <pmichaud> (It didn't earlier.)

[15:43] <jnthn> Maybe

[15:43] <jnthn> I think that particular one really needs to be though

[15:44] <pmichaud> so yes, the likely problem is that pblock's don't have lazy signature generation

[15:45] <pmichaud> nor typenames

[15:45] <pmichaud> hmmmm

[15:46] <jnthn> The time for strolling and nomming approaches.

[15:53] <masak> mmm, nom.

[15:54] <masak> std: sub foo(A | B $x) {}

[15:55] <p6eval> std 31534: OUTPUT«===SORRY!===␤In parameter declaration, typename 'A' must be predeclared (or marked as declarative with :: prefix) at /tmp/zu0AqXJyrD line 1:␤------> sub foo(A⏏ | B $x) {}␤Parse failed␤FAILED 00:01 112m␤»

[15:55] <masak> std: sub foo(Str | Int $x) {}

[15:55] <p6eval> std 31534: OUTPUT«===SORRY!===␤Unable to parse signature at /tmp/o_2NjCLpGd line 1:␤------> sub foo⏏(Str | Int $x) {}␤Couldn't find final ')'; gave up at /tmp/o_2NjCLpGd line 1:␤------> sub foo(Str ⏏| Int $x) {}␤    expecting any of:␤    

[15:55] <p6eval> ..constrain…

[15:55] <masak> there's another way the Wikipedia article on Perl 6 lags behind.

[15:55] <masak> we do such things with subtypes now.

[15:56] <jnthn> Let's go for noms!

[15:56] *** masak left
[15:56] <jnthn> \o/ o/

[16:06] *** JimmyZ left
[16:11] *** JimmyZ joined
[16:18] <lue> y o hai o/

[16:21] *** mmcleric left
[16:37] *** ashleydev left
[16:44] <arnsholt> phenny: tell masak http://gist.github.com/462687 fixes both the previous/current (d'oh) bug in my unique dirs patch, and the more subtle foo/footbal thing

[16:44] <phenny> arnsholt: I'll pass that on when masak is around.

[16:44] *** M_o_C left
[16:49] *** JimmyZ left
[16:57] *** JimmyZ joined
[16:58] *** isBEKaml left
[17:12] *** eternaleye_ joined
[17:12] *** eternaleye left
[17:29] *** snuff_ joined
[17:31] *** snuff left
[17:43] *** Ross left
[17:43] *** Ross joined
[17:44] *** JimmyZ left
[17:46] *** mmcleric joined
[18:14] *** skangas left
[18:16] *** TiMBuS left
[18:34] <tylercurtis> Is there a way to lexically disable :sigspace within a regex?

[18:34] <pmichaud> :sigspace(0)

[18:34] <pmichaud> or :!sigspace

[18:34] <tylercurtis> Thanks.

[18:34] <pmichaud> (I think NQP might only understand the first.  I know it understands at least one.)

[18:36] <Ross> brb

[18:37] *** M_o_C joined
[18:40] *** songmaster joined
[18:42] *** Ross left
[18:47] *** envi^home left
[18:48] *** supernovus joined
[18:48] *** M_o_C left
[18:49] *** Ross joined
[18:49] *** Ross left
[18:49] *** Ross joined
[18:49] *** sftp left
[18:52] *** sftp joined
[19:01] <sorear> phenny: tell masak that the "Deep recursion" warnings come from Moose; CORE.setting defines a lot of operators, each operator results in defining a new child grammar, and Moose generates warnings if you nest classes more than 100 deep.  #moose says "WONTFIX - your code is broken if you're inheriting that deeply".

[19:01] <phenny> sorear: I'll pass that on when masak is around.

[19:04] *** cono left
[19:05] <sorear> good morning #perl6

[19:05] <tylercurtis> Good morning, sorear.

[19:06] *** cono joined
[19:06] <tylercurtis> Does Rakudo support heredocs?

[19:07] *** supernovus left
[19:20] *** dalek left
[19:24] <sorear> tias?

[19:25] *** sorear sets mode: +oov szabgab pmichaud pugssvn

[19:25] *** pugssvn left
[19:36] *** Ross left
[19:40] *** skids left
[19:41] *** skids joined
[19:43] <ingy> pmichaud: you about?

[19:44] *** PerlJam left
[19:46] *** cotto left
[19:46] *** PZt left
[19:47] *** Juerd left
[19:50] * ingy just realized the Test.pm is not OO. It has no Test::Builder equiv.

[19:51] <ingy> I think I'm gonna need that to get TestML working

[19:51] <ingy> so I guess I will create it.

[19:54] <ingy> Actually I probably don't need it.

[19:55] *** masonkramer left
[20:00] <ingy> anyone know what this means? -> 'if $number_of_tests ~~ ::Whatever'

[20:00] <jnthn> ingy: Checking if $number_of_tests contains something of type Whatever

[20:00] <jnthn> e.g. *

[20:01] <jnthn> I guess it's what handles when you write plan *;

[20:01] *** sawyer_ joined
[20:01] <ingy> jnthn: so Test::plan(*) == no_plan ?

[20:02] <jnthn> Right.

[20:02] <ingy> thx!

[20:02] *** pugssvn joined
[20:06] * jnthn summons masak

[20:06] *** masak joined
[20:06] <jnthn> \o/

[20:06] <masak> \o/

[20:06] <phenny> masak: 16:44Z <arnsholt> tell masak http://gist.github.com/462687 fixes both the previous/current (d'oh) bug in my unique dirs patch, and the more subtle foo/footbal thing

[20:06] <phenny> masak: 19:01Z <sorear> tell masak that the "Deep recursion" warnings come from Moose; CORE.setting defines a lot of operators, each operator results in defining a new child grammar, and Moose generates warnings if you nest classes more than 100 deep.  #moose says "WONTFIX - your code is broken if you're inheriting that deeply".

[20:07] <masak> sorear: *lol*

[20:07] <masak> sorear: I remember you mentioning the 100-level limit, but I didn't think you had an actual use case for it.

[20:07] *** Ross joined
[20:07] <masak> arnsholt: thanks, will review.

[20:08] *** pugssvn left
[20:08] *** skids left
[20:09] <mmcleric> hello

[20:09] <phenny> mmcleric: 29 Jun 22:38Z <jnthn> tell mmcleric Thanks for the whatevercode patch - bit too tired to review it tonight, but will give it a proper look tomorrow. :-)

[20:09] <jnthn> o/

[20:09] <mmcleric> jnthn: i guess you still didn't looked at it? :)

[20:09] <jnthn> erm

[20:09] * jnthn hides

[20:09] <jnthn> ;-)

[20:09] <jnthn> Not yet

[20:10] <mmcleric> ok... how about some new task, then? :)

[20:11] *** skids joined
[20:12] *** pugssvn joined
[20:13] <jnthn> mmcleric: Hmm...not a bad idea. ;-) Let me think. :-)

[20:14] <jnthn> mmcleric: Looking at your patch

[20:14] <jnthn> if pir::exists($last, 'returns') {

[20:14] <jnthn> That line feels...weird

[20:15] <jnthn> I'm a little surprised it works...

[20:15] <mmcleric> are you looking at version with comments? :)

[20:15] <jnthn> Yes

[20:15] <jnthn> From http://github.com/berekuk/rakudo/commit/413f25c9eee82cc10abd19f499923f9077205b02

[20:15] <mmcleric> yep

[20:15] *** dalek joined
[20:15] <mmcleric> so, as i said there, i tried to keep ast tree clean from useless nodes

[20:15] <jnthn> Yes, the idea is good, but checking it that was is...creative. :-)

[20:15] <jnthn> Did

[20:16] <jnthn> if $last.returns() { ... } not do it?

[20:16] <jnthn> The exists check will be fragile, I expect.

[20:16] <masak> std: my $a; return 42 unless($a)

[20:16] <mmcleric> maybe, but not arity - arity can be zero

[20:16] <p6eval> std 31534: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/ETNeUoAqvo line 1:␤------> my $a; return 42 ⏏unless($a)␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤      statement modifier loop␤  statement_mod_cond␤Parse failed␤FAILED 00:01 114m␤»

[20:16] <jnthn> Since it relies on there being a hash underneath the PAST::Node which their kinda needin't be. I'm surprised it works at all.

[20:16] *** PerlJam joined
[20:16] <masak> rakudo: sub foo { my $a; return 42 unless($a) }

[20:16] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[20:16] <masak> \o/

[20:17] * masak submits rakudobug

[20:17] <jnthn> if pir::defined($node.arity) { ... } is probably better then

[20:17] <mmcleric> jnthn: i see

[20:17] *** supernovus joined
[20:17] <jnthn> doing pir::exists on a PAST::Node feels kinda wrong though.

[20:17] <masak> rakudo: my $a; return 42 unless($a)

[20:17] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[20:17] <masak> rakudo: return 1 unless(1)

[20:17] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[20:18] <masak> rakudo: say "OH HAI"

[20:18] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[20:18] <masak> oh :(

[20:18] <mmcleric> also, i remember pmichaud saying that this part of code should be moved from sym<( )> to method semilist

[20:19] <jnthn> That sounds sensible. If pmichaud felt so then I can completely go with that.

[20:20] <jnthn> In the next bit:  :arity($inv.arity)

[20:20] *** dalek left
[20:20] <jnthn> I see why you've added that but I don't quite get why it fixes those chains.

[20:23] *** rv2733 joined
[20:24] *** plobsing joined
[20:26] *** pmichaud_ joined
[20:26] <jnthn> pmichaud_: lol I'm back...

[20:26] <jnthn> pmichaud_: Any luck on the where bug?

[20:27] <pmichaud_> yes, mostly bad.

[20:28] <pmichaud_> we're going to have to significantly re-think Code, I fear.

[20:28] <pmichaud_> or, at least, I am.

[20:29] <mmcleric> jnthn: without that part, arity was wrong... i don't remember exact ast tree, sorry

[20:29] <mmcleric> although it looks normal to me - if we propagate returns, why not arity too?

[20:29] <pmichaud_> all of the block-oriented nodes get a significant rework in the llsig branch, fwiw

[20:30] <pmichaud_> (speaking of .arity and .returns, that is)

[20:30] <jnthn> pmichaud_: Yeah, I'm looking at mmcleric++'s patch and figuring if I apply it there *will* be merge conflicts. (I won't.)

[20:30] <jnthn> (Until after the dust settles from your merge.)

[20:30] <pmichaud_> yes, that patch will likely need to wait.

[20:30] *** dalek joined
[20:32] <jnthn> mmcleric: Anyways, the overall logic of the patch makes sense.

[20:32] <jnthn> The arity propagation bothered me a little at first glance, but makes sense to me now I see what it's going.

[20:32] <jnthn> *doing

[20:32] <pmichaud_> jnthn: I need to come up with a way to distinguish a static Code object from a dynamic one.

[20:33] <jnthn> mmcleric: As pmichaud++ is refactoring a bunch of stuff at the moment, though, it's a bad time to try and get it in right now. But it's the right direction.

[20:33] *** masak left
[20:33] <jnthn> pmichaud_: OK, background?

[20:33] *** Ross left
[20:33] <jnthn> pmichaud_: What's the actual problem you've hit on?

[20:33] <pmichaud_> let's look at the following:

[20:34] *** Juerd joined
[20:34] <pmichaud_>       my sub abc() of Int { ... }

[20:34] <supernovus> Hmm... I have come across an interesting problem. Augmenting a class that does a role that defines an attribute causes 'bad things' to happen.

[20:34] <pmichaud_>     my $x = &abc;

[20:34] <mmcleric> jnthn: great :) so, i'll move propagation to semilist and wait until your merge, and then rebase, right?

[20:35] <jnthn> supernovus: The role has little to do with it

[20:35] <jnthn> supernovus: Anything that adds an attribute in an augment will cause bad things to happen.

[20:35] <jnthn> supernovus: We need a good error for it.

[20:35] <pmichaud_> the "of Int" has to apply to a 'static' Code object -- a Code object that is forever associated with the static sub.

[20:35] <jnthn> mmcleric: Yes, good plan.

[20:35] <pmichaud_> the thing that gets assigned to &x has to be a "dynamic" Code object -- it has to represent the state of the closure at the point the assignment is performed.

[20:35] <supernovus> jnthn: That's the thing, the augment isn't adding an attribute, just a method.

[20:36] <supernovus> rakudo: role F { has Int $.boo = 1; }; class B does F {}; use MONKEY_TYPING; augment class B { method sush { say 'hi' } }; my $b = B.new; $b.sush;

[20:36] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[20:36] <jnthn> supernovus: I don't get it - you just send the augment composed a role with an attribute?

[20:37] <jnthn> Oh, I see

[20:37] <jnthn> Hmm, awkward.

[20:37] <jnthn> File Rakudo bug

[20:37] <supernovus> that's not the error message I got over here

[20:37] <supernovus> Attribute '$!boo' already exists in the class, but a role also wishes to compose it

[20:37] <jnthn> oh...wait, p6eval is broken

[20:37] <jnthn> pmichaud_: Traits should be applied once, yes.

[20:38] <pmichaud_> jnthn: the problem is, that traits are reflected in a Code object.

[20:38] <jnthn> pmichaud_: That's...probably part of why we cloned one thing instead of .new'd before...

[20:38] <pmichaud_> yeah

[20:38] <pmichaud_> I was hoping to avoid actual cloning, but it may not be possible.

[20:38] <jnthn> Though it completely didn't occur to me when you said it yesterday. :-(

[20:39] <jnthn> Re-applying the traits all the time just won't fly though.

[20:39] <pmichaud_> agreed.

[20:39] <jnthn> It's semantically wrong.

[20:40] <jnthn> I can't think of a good way to separate the dynamic and static aspects here really either.

[20:40] <jnthn> Or at least, not a clean one.

[20:40] <pmichaud_> well, I'm wondering to what degree Parrot's underlying model may be wrong, and if that's coloring our perception.

[20:41] <pmichaud_> i.e,. the idea that we clone a (static) sub to capture a context seems/feels really out of place

[20:42] <jnthn> Well, it's the lexicals we really care about more than the sub, I guess

[20:42] <jnthn> But the sub references the lexicals.

[20:43] <pmichaud_> so, here's an example.

[20:43] <pmichaud_> let's suppose I have

[20:44] <pmichaud_> { my sub abc() { ... };    &abc but something   if (0,1).pick; }

[20:44] <pmichaud_> am I modifying the static Code object or a lexical copy?

[20:44] <jnthn> but will *always* clone

[20:44] <jnthn> The interesting case is "does"

[20:45] <pmichaud_> okay, does, then.

[20:45] <pmichaud_> { my sub abc() { ... };   &abc does something if (0,1).pick; }

[20:45] <pmurias> sorear: re the 100 limit would flattening the inheritance chain manually work?

[20:45] <phenny> pmurias: 14:59Z <jnthn> tell pmurias yes I am

[20:45] <jnthn> Right, that's the interesting question.

[20:46] <jnthn> pmichaud_: For traits it doesn't maybe come up because they are "compile time" application so those would apply to the static thing.

[20:46] <jnthn> pmichaud_: This case, OTOH, is a decidedly *runtime* mixin.

[20:46] <pmichaud_> but what's "the static thing" in this instance?

[20:47] <jnthn> In my mental model, it was "the sub we initially store, and that every other instnace is a clone from"

[20:47] <jnthn> Kind of analogous to the proto-lexpad idea.

[20:47] <pmichaud_> where "sub we initially store" ends up with a Code object that becomes its "static copy"?

[20:48] <pmichaud_> i.e., for every block (with traits) we have to at loadinit create a Code object for it?

[20:48] <jnthn> I guess my (maybe bad) assumption here is that we create one Code object, apply the traits to it, and everything else is either an alias to or a clone of that.

[20:48] <pmichaud_> alias to doesn't work because we have to make copies to capture closures

[20:49] <pmichaud_> "clone of" is nasty because we have to know exactly when we're making copies

[20:50] <jnthn> In the current model, don't we currently assume that we always need a copy though?

[20:50] <pmichaud_> the current model of what?

[20:50] <pmichaud_> (the current model is broken :-)

[20:50] <supernovus> Bug submitted. I'll find a workaround for a loadable DateTime::strftime until it is resolved.

[20:50] <jnthn> In your current implementation you do Code.new at every entry to a block for the things within it, iiuc?

[20:50] <pmichaud_> that's not really a copy, though.

[20:50] <pmichaud_> well, I guess it is.

[20:51] <pmichaud_> okay, yes -- I create a copy upon entry to each block.

[20:51] <jnthn> Right, so if you just clone every time you currently new...?

[20:51] <jnthn> It's no more costly in terms of the number of objects we end up making, and there's no more to have to know iiuc.

[20:51] <pmichaud_> it's somewhat more costly at startup (more)

[20:52] <pmichaud_> or, we have to have something that is really smart about creating code instances

[20:52] <pmichaud_> probably the latter

[20:52] <jnthn> How much more costly though?

[20:52] <pmichaud_> well, you were wanting to avoid having a loadinit for every block, iirc :-)

[20:53] <jnthn> I mean, the cost of not having working closures is pretty high too. ;-)

[20:53] <pmichaud_> I'd like to lazily create the Code objects

[20:53] <jnthn> OK

[20:53] * jnthn thinks

[20:53] <pmichaud_> but yes, I see where you're coming from and I think that can work.

[20:53] <jnthn> What if we were to have a scheme where:

[20:54] <pmichaud_> really what I want to have happen is to have everything tied to the Parrot sub.

[20:54] <jnthn> 1) First time we call Code.new it builds a new object and labels the Parrot sub with that object

[20:54] <jnthn> 2) Next time around it sees "oh, we have our 'static' code object already, so I'll just clone that"

[20:54] <pmichaud_> so I don't want to be calling Code.new, because that's the wrong place.

[20:54] <jnthn> Code.gimme ;-)

[20:54] *** PZt joined
[20:54] <jnthn> OK, but I think the idea holds

[20:54] <pmichaud_> yeah

[20:55] <jnthn> We attach to the Parrot sub first time around, and clone from that the following times

[20:55] <jnthn> And the first time - for anything that has traits - will be in a :load :init

[20:55] <jnthn> And for anything without traits I guess it doesn't matter.

[20:55] <pmichaud_> it gets tricky with our-scoped subs

[20:55] <pmichaud_> because they have to be initialized at loadinit also.

[20:55] <pmichaud_> (but then rebuilt in the block, and replaced)

[20:56] <pmichaud_> so in some sense what I really want is   Sub.get_Code(....)

[20:57] <pmichaud_> where get_Code does the object building and returning

[20:57] <pmichaud_> and cloning

[20:57] <pmichaud_> or something like taht.

[20:57] <jnthn> *nod*

[20:57] <pmichaud_> anyway, I agree with your basic premise, I just need to map it out.

[20:57] <pmichaud_> thanks.

[20:57] <jnthn> Sure, I'm not sure of the best formulation

[20:57] <pmichaud_> well, I'm very happy with the current factorization, so it should be easy to get to there from here.

[20:57] <jnthn> :-)

[20:58] <pmichaud_> I have a feeling this will work out to be even cleaner.

[20:59] <pmichaud_> actually, I think I may start from an assumption that all blocks get a Code object at :loadinit, and then figure out how to optimize out the :loadinits

[21:01] <jnthn> OK

[21:03] *** mncharity_ joined
[21:05] <pmurias> mncharity_: hi

[21:06] *** pmichaud_ left
[21:07] *** sundar joined
[21:10] *** masak joined
[21:13] <masak> mncharity_: hi!

[21:14] *** sundar left
[21:14] *** sundar joined
[21:15] <mncharity_> Hi :)

[21:18] * mncharity_ dusting elf...

[21:18] *** supernovus_ joined
[21:19] <mncharity_> (job search;)

[21:19] *** supernovus left
[21:19] *** supernovus_ is now known as supernovus

[21:27] *** rv2733 left
[21:33] <pmichaud> jnthn: okay, I think I figured it out.

[21:34] <pmichaud> essentially, we'll have two functions on Parrot subs.  get_code will return the static Code object, get_closure will return a clone of that object and the current closure sub

[21:34] <pmichaud> static compile-time thingies will work on the get_code object, while runtime bindings will be done using the get_closure object

[21:36] <pmichaud> blocks and subs that don't require any compile-time traits and attributes will delay creating their Code object and sigs until a closure is actually needed

[21:36] <pmichaud> immediate blocks will have the Code objects optimized out completely

[21:36] <pmichaud> (but we can still get to them or generate one lazily if needed)

[21:39] <pugssvn> r31535 | putter++ | misc/elf/README: One of the "two small errors" fixed by r26238, perhaps wasn't an error. 

[21:39] <pugssvn> r31535 | (/usr/bin/env will find elf_h if <pathtopugs>/misc/elf is added to PATH)

[21:39] <supernovus> masak: I moved DateTime::strftime from Temporal into a loadable module. I had to change how to add the strftime method to your DateTime object due to a bug (reported), but it does work.

[21:39] <jnthn> pmichaud: OK, sounds sane on first reading.

[21:39] <pmichaud> yeah, it seems very clean.

[21:40] <jnthn> pmichaud: I wonder if we can build on that to do the static lexpad vs dynamic lexpad things in the future too

[21:40] <pmichaud> and it exactly models what we're looking for, so that we can easily distinguish the static code representation from a dynamic one.

[21:40] <pmichaud> jnthn: perhaps so.

[21:40] <jnthn> Sounds like it's heading in the same direction we want ot push that.

[21:40] <jnthn> *to

[21:42] <masak> supernovus: cool.

[21:42] <pugssvn> r31536 | putter++ | misc/STD_red/README - Update ruby 1.9 install notes. 

[21:44] *** Su-Shee left
[21:44] <supernovus> masak: Along with a few other refactors of Date and Temporal. I'll send a [PATCH] soon.

[21:44] <masak> supernovus: thanks.

[21:51] <cognominal> jnthn, this one is for you :  http://pastie.org/1029601 # not golfed yet, but I think it should not. It is a good way to stress your dispatch engine.

[21:54] *** pmurias left
[21:55] <cognominal> hum, the first line has one } too much :(

[21:57] <jnthn> cognominal: erm

[21:57] <jnthn> Does your build work at all?

[21:57] <cognominal> anyway it blows up before reaching it.

[21:57] <cognominal> rakudo:  multi method subtree(@a, @path, Range $r?, Bool :$mod?) {  subtree( @a[@path.unshift], $r, $mod)  }

[21:57] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[21:58] <jnthn> rakudo: oh no

[21:58] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[21:58] <cognominal> ??

[21:58] *** sorear sets mode: +o masak

[21:59] <masak> "Bit like sticking a fork in your own face to protest the media's preoccupation with conventional beauty." -- Wikipedians discuss Camelia at http://en.wikipedia.org/wiki/Talk:Perl_6

[21:59] <jnthn> cognominal: The rakudo build seems busted :-S

[21:59] <cognominal> is the current build broken?

[21:59] *** sorear sets mode: +v pugssvn

[21:59] <jnthn> head builds for me :-S

[21:59] *** sorear sets mode: +v dalek

[21:59] <pmichaud> make verify parrot version?

[21:59] <pmichaud> s/make/maybe/

[21:59] <jnthn> yeah

[21:59] <cognominal> hum, I probably forgot to do a make install

[21:59] <jnthn> Should be 47972

[22:01] <cognominal> now I get a more sensible message :  Useless declaration of has-scoped Method in a module; add our or my to install it in the lexpad or namespace

[22:02] <cognominal> I should have used multi subs.

[22:04] <pugssvn> r31537 | putter++ | [elf_h] Makefile - Don't run regression tests by default. 

[22:04] <masak> arnsholt: applied; pushed. thanks!

[22:06] *** bjarneh joined
[22:08] <pugssvn> r31538 | putter++ | [elfish] Improve README's. 

[22:09] *** Dfaure joined
[22:09] <pugssvn> r31539 | putter++ | elfish/on_lisp - Minor steps towards supporting additional cl implementations. 

[22:13] <tylercurtis> Can you forward-declare types in Perl 6? e.g., if Foo had a Bar attribute, but I wanted them both in the same file with Foo first, could I do "class Foo { has ::Bar $.bar; } class Bar { }" or something like that?

[22:13] <jnthn> or class Bar { ... } before it

[22:13] <jnthn> That just "stubs" it

[22:13] <jnthn> And you fill in the declaration later

[22:14] <masak> wonder how Perl 6 would fare in this golfing contest: http://stackoverflow.com/questions/3169051/code-golf-word-frequency-chart

[22:14] <masak> it's interesting to see that Perl and Ruby basically tie.

[22:14] <masak> Perl 5, that is.

[22:14] *** skids left
[22:14] <masak> I'm not 100% sure Perl 6 would beat Perl 5, but I'm prepared to be proven wrong. :)

[22:14] <tylercurtis> And either of those would have the same semantics as just having Bar before Foo? Thanks.

[22:14] <cognominal> jnthn, I corrected the many errors. And now I hit the dispatcher.

[22:14] <cognominal> Ambiguous dispatch to multi 'subtree'. Ambiguous candidates had signatures:

[22:14] <cognominal> :(@a, @path, Range $r?, Bool :mod($mod))

[22:14] <cognominal> :(@a, Positional  (), Range $r)

[22:15] <masak> oh, and I laughed at "Java [...] 743 chars" :)

[22:15] <cognominal> I would think the second signature would be more specific

[22:15] <mncharity_> (ah well, elfparse build broken - a task for a hypothetical 'nother time.)

[22:16] <jnthn> cognominal: You perhaps need to make that named parameter required

[22:17] <jnthn> Do make the dispatcher distinguish them

[22:17] <jnthn> *To

[22:18] <cognominal> I need to read the dispatch rules...

[22:19] * sorear feels that P6 mainly improves over P5 in programming-in-the-large

[22:19] * mncharity_ looking forward to Star.

[22:19] <jnthn> cognominal: Well the think to remember is that beyond being constraining, the dispatcher doesn't care about named arguments.

[22:20] <jnthn> Making one required forces it to be constrainty.

[22:20] <mncharity_> g'night pmurias, masak, all. &

[22:20] <masak> mncharity_: 'night!

[22:20] *** mncharity_ left
[22:25] *** Dfaure left
[22:27] *** skids joined
[22:29] <cognominal> rakudo:  multi sub f(@p, Range $r?, Bool :$mod ) { say 1 }; multi sub f([], Range $r) { say 2 }; f([], 1..2);

[22:29] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[22:29] <cognominal> arf, p6eval is broken

[22:30] <masak> yes, it is.

[22:30] <cognominal> jnthn, with the Bool :$mod parameter, there is an anbirguity

[22:30] <pmichaud> jnthn: ping

[22:30] <cognominal> without it, there is not

[22:30] <cognominal> *ambiguity!

[22:31] <cognominal> sounds fishy to me.

[22:32] <jnthn> cognominal: I'm not convinced it's wrong. named parameters don't partcicipate in multi dispatch.

[22:32] <jnthn> pmichaud: pong

[22:32] <jnthn> cognominal: Only as constraints

[22:32] <pmichaud> okay, now I need some guidance through the install_method code.

[22:33] <jnthn> cognominal: And an optional named parameter doesn't contrain much...

[22:33] <jnthn> install_method?

[22:33] <jnthn> Are we in Actions.pm? :-)

[22:33] <pmichaud> yes.

[22:34] <jnthn> Ah yes. This arose out of my dislike of epic duplication between method_def and regex_def...

[22:35] <pmichaud> well, really I need to understand method_def

[22:35] <pmichaud> I can then fix up regex_def

[22:35] <jnthn> Anyway, this routine does up to 3 things

[22:35] <jnthn> 1) It always adds it to the current package's method table.

[22:35] <jnthn> 2) It maybe adds it to the lexpad and/or package depending on if it's my or our

[22:36] <jnthn> 3) It keeps track of multi stuff

[22:36] <jnthn> Basically, Perl6::Compiler::Package keeps track of all the methods

[22:37] <jnthn> It later generates the PAST that calls add_method on the metaclass

[22:37] <pmichaud> which component ends up "owning" the method?

[22:37] <jnthn> The %table is the methods table from a Perl6::Compiler::Package instance

[22:37] <pmichaud> i.e., which one ends up with the actual PAST::Block node?

[22:37] <jnthn> If anything should "own" it, it's this one.

[22:37] <pmichaud> okay.

[22:37] <jnthn> oh wait

[22:37] <jnthn> No, that doesn't

[22:38] <jnthn> The $code parameter is actually

[22:38] <jnthn> my $code := create_code_object(PAST::Val.new(:value($past)), 'Regex', 0, $sig_setup_block);

[22:38] <jnthn> Note that PAST::Val

[22:38] <pmichaud> right

[22:38] <jnthn> So the PAST::Block goes into the PAST tree "in place" as it were

[22:39] <pmichaud> where?

[22:39] <jnthn> And the meta-class just gets a reference to it

[22:39] <pmichaud> the PAST::Val node won't do it.

[22:39] <jnthn> Wherever the method_def was

[22:39] <pmichaud> it has to be pushed into the block somewhere, or returned

[22:39] <jnthn> That is, in the block the method was written in.

[22:39] <jnthn> It is returned

[22:39] <sorear> Is elf being ressurrected?

[22:39] <jnthn> Last line of method_def is make $past;

[22:39] <pmichaud> okay.

[22:40] <jnthn> The PAST::Block ends up directly inside the containing block

[22:40] <jnthn> (so it has it's outer correct)

[22:40] <sorear> phenny: tell TimToady Just to clarify my question from earlier: I only want to rename the Perl 5 modules in STD.  STD.pm6 will be unaltered; viv will contain code to remap STD, Cursor, etc -> Perl6::* (like it already remaps so many renamed Perl6 functions)

[22:40] <pmichaud> okay.

[22:40] <phenny> sorear: I'll pass that on when TimToady is around.

[22:41] <pmichaud> so, does the code object that goes into the method table want to be a static code or a dynamic one?

[22:42] <pmichaud> I'm guessing static -- I'm guessing the method table is processed at :load :init time?

[22:42] <masak> std: === SORRY? ===

[22:42] <p6eval> std 31539: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix === instead at /tmp/3yUX07O8hU line 1:␤------> <BOL>⏏=== SORRY? ===␤Parse failed␤FAILED 00:01 111m␤»

[22:43] <jnthn> (:load :init) depends - not if it's an anonymous class

[22:43] <jnthn> Or a lexical one

[22:43] <jnthn> But I guess static too

[22:43] <jnthn> Almost certainly so

[22:44] <pmichaud> okay, so here's a really awful question.

[22:44] <jnthn> Because then roles will want to create dynamic versions of it.

[22:44] * jnthn slurps his beer harder in anticipation

[22:44] <pmichaud> class XYZ { our $foo;   method foo() { say $foo } };

[22:44] <pmichaud> actually, worse:

[22:44] <pmichaud> class XYZ { our $foo = 5;   method foo() { say $foo } };

[22:45] <jnthn> oh... :-/

[22:45] <jnthn> Would we end up with a problem there?

[22:45] <jnthn> I guess yes

[22:45] <pmichaud> well, if we use the static foo() (:load :init), it exists before the class block has executed.

[22:45] * jnthn ownders what it does today

[22:45] <jnthn> Right, the thing is

[22:46] <jnthn> The meta-stuff happens at begin time

[22:46] <jnthn> But the actuall running of the block happens later

[22:46] <pmichaud> rakudo:  class XYZ { our $foo = 5;  method foo() { say $foo } }; XYZ.new.foo;

[22:46] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[22:46] <jnthn> heh

[22:46] <jnthn> I didn't think we'd get it right today

[22:46] *** songmaster left
[22:46] <pmichaud> rakudo:  class XYZ { our $foo = 5;  method abc() { say $foo } }; XYZ.new.abc;

[22:46] <p6eval> rakudo d27eb3: OUTPUT«Null PMC access in isa_pmc()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc 1376 (runtime/parrot/library/P6object.pir:803)␤»

[22:47] * jnthn looks to see if the bug submitter next to him is poised...but actually he's distracted and not watching the channel ;-)

[22:47] <pmichaud> okay... I can leave it static for now, but that's an issue we'll want to address.

[22:47] <jnthn> pmichaud: I'm not sure if that can work.

[22:47] <jnthn> I mean, it shoulnd NPMCA

[22:47] <jnthn> *shouldn't

[22:47] *** supernovus left
[22:48] <pmichaud> is there a reason the methods have to be installed at BEGIN time?

[22:48] <pmichaud> could it happen at the beginning of the class block?

[22:48] <pmichaud> or do we have to worrya bout.... nm

[22:48] <jnthn> No

[22:48] <jnthn> Unless you think we can do *everything* at the start of the class block

[22:48] <pmichaud> class XYZ { ... };   XYZ.new.abc;  class XYZ { method abc() ... }

[22:48] <jnthn> If you didn't install the methods, you can't compose the class

[22:49] <cognominal> jnthn, I submitted my problem as #76372   feel free to close it if it is not a bug.

[22:50] <pmichaud> this looks like a variation on the 'our' stuff we discussed last night.  It seems like a method has to be installed once when the class is composed, and then again when the class block is entered.

[22:50] <jnthn> It feels like we're missing something here. But I don't know what. :S

[22:51] <jnthn> Re-installing methods in the metaclass feels really weird though

[22:51] <jnthn> And worse, if it's an our method it'd need to be re-installed in 3 places.

[22:51] <jnthn> (package, lexpad, metaclass)

[22:52] * cognominal is hitting S06 again

[22:53] <jnthn> It's not a punch bag! :P

[22:55] <pmichaud> one difference between methods and our subs is that we expect the enclosing block to only be executed once.

[22:56] <pmichaud> (maybe more than once in the case of roles, though.)

[22:56] <jnthn> Yes

[22:56] <jnthn> Well, many times for roles

[22:56] <jnthn> But for roles we explicitly *have* to clone and re-capture the methods.

[22:56] <jnthn> Always

[22:56] <jnthn> In fact, for a role we do do that re-installation today!!

[22:56] <pmichaud> right

[22:57] <pmichaud> anyway, I'm going to leave it as static for now and let you think about that one.

[23:01] <jnthn> OK

[23:01] <jnthn> .oO( oh no I have to think?! )

[23:01] <pmichaud> either that or drink beer :-)

[23:01] <pmichaud> both seem to work.

[23:02] <jnthn> I'm currently drinking a very very nice beer :-)

[23:02] * [Coke] *only* has guiness in the house atm.

[23:03] *** mmcleric left
[23:03] * pmichaud very optimistically types "make"

[23:04] * pmichaud abandons that plan.

[23:05] <pmichaud> okay, this latest code change was definitely too great a leap.

[23:05] <pmichaud> let me get back to something that passes a fair number of spectests and start from there.

[23:06] <masak> here's what pls looks like right now. comments welcome: http://gist.github.com/462912

[23:07] <sorear> it looks like cpanminus

[23:07] <sorear> also a wee bit like yum

[23:09] *** takadonet joined
[23:09] <takadonet> hey everyone

[23:09] <masak> sorear: I've used yum, years ago. never used (or even seen the output of) cpanminus, but I've heard from other people that its goals are similar to proto/pls's.

[23:09] *** tadzik left
[23:09] <masak> takadonet: \o

[23:10] <takadonet> masak: how are u sir?

[23:10] <masak> takadonet: I'm at a hackathon, writin ur future installer :P

[23:10] <takadonet> masak: nice

[23:10] <takadonet> masak: where is the hackathon?

[23:10] <masak> in Lund, .se

[23:15] * jnthn is mocking masak

[23:15] * masak feels hollow inside :/

[23:15] <jnthn> :P

[23:15] <jnthn> I doubt that after all the curry... ;-)

[23:17] <masak> 哈哈

[23:20] <sorear> what?

[23:23] *** tadzik joined
[23:26] <masak> sorear: so, there's something slightly odd with actually writing "ha ha". we never used to do that in paper correspondance, for example. but using idiograms has no precedence, and feels both lively and globally hip.

[23:26] *** meppl left
[23:26] <masak> sorear: by an extraordinary coincidence, that character (pronounced HA1 in Mandarin) means "Pugs".

[23:27] <masak> s/precedence/precedents/

[23:31] *** takadonet left
[23:36] <jnthn> Just for a little own dog food nomming, I started writing a simple little Perl 6 module. :-) http://github.com/jnthn/test-mock

[23:37] <masak> now added to pls. :)

[23:37] <jnthn> pls install test-mock

[23:37] <jnthn> ;-)

[23:37] * masak does :)

[23:49] *** ashleydev joined
[23:54] *** sundar left
[23:54] <sorear> masak: the dog breed?

[23:54] *** Psyche^ joined
[23:54] <masak> anyone have an idea how to test whether a directory is empty?

[23:54] <masak> sorear: I think so. it was TimToady who said it once.

[23:55] <sorear> I think readdir is the only way

[23:56] *** tadzik left
[23:58] *** Patterner left
[23:58] *** Psyche^ is now known as Patterner

