[00:00] <lue> how do I get rid of an edit I've stashed? (git)

[00:02] <sorear> Where can I get a copy of alpha?

[00:11] *** takadonet joined
[00:12] <takadonet> morning all

[00:12] <takadonet> ...

[00:12] <takadonet> sorry force of habit.... good afternoon all

[00:12] <sorear> What's to say it's not morning?

[00:12] <takadonet> well my timezone is not morning :P

[00:13] <lue> It's morning somewhere. What time is it there?

[00:13] <takadonet> 7 p.m

[00:14] <lue> 16 15 14 13 12 11 10 09 08 07 06 05 It's morning at around UTC+2 (leftmost is UTC-8)

[00:15] <jnthn> sorear: It's just a branch

[00:15] <jnthn> So you already have it

[00:15] <jnthn> git checkout alpha

[00:15] <jnthn> or maybe origin/alpha

[00:17] <sorear> Ah.

[00:17] <lue> If I've stashed changes to a file (git), how would I get rid of that changed file.

[00:17] <takadonet> jnthn:do you ever sleep?

[00:17] <sorear> yes, :(

[00:17] <sorear> he's asleep 90% of the time I'm hacking his pet project

[00:17] <sorear> makes communications a real bother

[00:18] <lue> rakudo: say (24 * .9)

[00:18] <p6eval> rakudo 63ff06: OUTPUT«21.6␤»

[00:18] <diakopter> rakudo: 0 but last

[00:18] <p6eval> rakudo 63ff06: OUTPUT«Warning␤Null PMC access in can()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc -1 ((unknown file):-1)␤»

[00:19] <lue> are you implying he's assleep 22 hours a day?

[00:19] <diakopter> phenny: tell masak  rakudo: 0 but last

[00:19] <phenny> diakopter: I'll pass that on when masak is around.

[00:20] <lue> .oO(I can't tell if the Apple Newton giveaway at ThinkGeek is real or not... I really hope it is!)

[00:22] * sorear wonders whether to expunge the PIR from Blizkost

[00:22] <jnthn> sorear: Heh, you do know that I started Blizkost explicitly with the hope that others would pick it up and hack on it lots and make a better job of it than I could? :-)

[00:22] <takadonet> time to hack some stuff on Perl 6 :)

[00:22] <takadonet> step 1: get Padre updated

[00:23] <lue> I guess I just git stash apply, delete the file, and hope git pull puts it back?

[00:23] <jnthn> sorear: Curious - replace it with...NQP?

[00:23] <Tene> with... grapes?

[00:23] <jnthn> ...no, there are more useful things to do with grapes.

[00:23] <lue> with... the help of the 楽土 die() * ?

[00:24] <Tene> Ah, replace the PIR with curry!

[00:24] <jnthn> .oO( .assuming )

[00:25] <jnthn> takadonet: I do try to sleep, but I've mostly failed this week. :-/

[00:25] <takadonet> jnthn: Well as long as you are working on Perl 6, I'm happy :)

[00:26] <takadonet> jnthn: WIll buy you a few beers the next time I'm in Europe 

[00:26] <sorear> jnthn: Yes, rewrite perl5.pir in NQP

[00:26] * jnthn in theory went to bed in time for 6-7 hours sleep last night. In reality, lay awake for ages, slept 3 hours and made heavy use of his client's coffee machine this morning ahead of his meeting with them.

[00:26] <jnthn> takadonet: \o/

[00:26] * sorear wonders if jnthn has even been following the latest blizkost changes

[00:26] <jnthn> sorear: Works for me. :-)

[00:27] <lue> what is a good hex editor for the command line?

[00:27] <sorear> tweak

[00:27] <lue> >tweak jnthn

[00:27] <lue> C0 FF EE A3 90 32

[00:27] <lue> O.o

[00:28] <jnthn> sorear: I do read the commits, but invariablity with some lag.

[00:28] <jnthn> sorear: I've not had any "omfg" moments yet. :-)

[00:29] <jnthn> sorear: Though my lack of p5 guts knowledge (esp magic) has made following a little tricky of late. ;-)

[00:29] <lue> I have the feeling signing up at github will _not_ give me a rakudo commit bit :)

[00:31] <takadonet> .... my padre crashes now!

[00:31] * takadonet starts to cry

[00:31] <jnthn> sorear: Just read the ones from yesterday too. I'm just confused on:

[00:31] <jnthn> $mw.Label(-text => 'Hello, world!').pack;

[00:31] <jnthn> Don't think nqp supports the "-" there...

[00:32] <jnthn> nqp: my $mv; $mw.Label(-text => 'Hello, world!').pack;

[00:32] <p6eval> nqp: OUTPUT«Symbol '$mw' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 137 (compilers/pct/src/PCT/HLLCompiler.pir:101)␤»

[00:32] <jnthn> nqp: my $mw; $mw.Label(-text => 'Hello, world!').pack;

[00:32] <p6eval> nqp: OUTPUT«Method 'Label' not found for invocant of class 'Undef'␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[00:32] <jnthn> oh

[00:32] <jnthn> I'm wrong.

[00:32] <jnthn> std: my $mw; $mw.Label(-text => 'Hello, world!').pack;

[00:32] *** sundar left
[00:32] <p6eval> std 30265: OUTPUT«ok 00:01 109m␤»

[00:33] <jnthn> rakudo: my $mw; $mw.Label(-text => 'Hello, world!').pack;

[00:33] <p6eval> rakudo 63ff06: OUTPUT«Method 'Num' not found for invocant of class 'Pair'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[00:33] <jnthn> oh.

[00:33] <jnthn> I feared so.

[00:34] <jnthn> sorear: -text => 'Hello, world!' is parsing as -(text => 'Hello, world!')

[00:34] <lue> While all the other implementations would generate a bunch of 200's, Rakudo is proud to generate more 501's than anybody else :)

[00:36] *** Chillance left
[00:42] <jnthn> lue: Yeah, sometimes we fail too hard. :-)

[00:43] <lue> almost as bad as a 404, except then you don't know where to place the blame.

[00:46] <jnthn> Hmmm...I think I like that option. ;-)

[00:46] <lue> where are things like 'and' and 'or' implemented in Rakudo? I want to find a place to put andthen and orelse.

[00:47] <jnthn> Well, those two are done iirc with support from having PAST nodes that they map to quite nicely.

[00:47] <jnthn> That may not be the case for andthen and orelse.

[00:47] <jnthn> Well, probably isn't.

[00:47] <jnthn> So they'll take a bit more effort.

[00:47] <lue> I have to get into the PAST? Blech, I was hoping to place it in Grammar.pm :)

[00:48] <jnthn> See Grammar.pm for how and and or are parsed.

[00:48] <jnthn> Yeah, but you kinda need to give them some semantics as well as parse them. :-P

[00:48] *** yinyin joined
[00:48] *** xabbu42 left
[00:48] <sorear> jnthn: Oh? :/

[00:49] <sorear> nqp: sub foo(*%args) { print %args }; foo(x => 2)

[00:49] <p6eval> nqp: OUTPUT«Multiple Dispatch: No suitable candidate found for 'modulus', with signature 'PPP->P'␤current instr.: 'foo' pc 29 (EVAL_1:0)␤»

[00:49] <sorear> ...what

[00:51] <lue> rakudo: multi sub infix:<orelse> ($a,$b) {if $a { return $a;} else { return $b;};}; say (0 orelse 1)

[00:51] <p6eval> rakudo 63ff06: OUTPUT«1␤»

[00:51] <lue> done :)

[00:51] <lue> rakudo: multi sub infix:<orelse> ($a,$b) {if $a { return $a;} else { return $b;};}; say (0 orelse 0 orelse 1)

[00:51] <p6eval> rakudo 63ff06: OUTPUT«1␤»

[00:51] <jnthn> sorear: print(%args)

[00:51] <lue> rakudo: multi sub infix:<orelse> ($a,$b) {if $a { return $a;} else { return $b;};}; say (0 orelse 0 orelse 2)

[00:51] <p6eval> rakudo 63ff06: OUTPUT«2␤»

[00:51] <sorear> nqp: sub foo(*%args) { print(%args) }; foo(x => 2)

[00:51] <p6eval> nqp: OUTPUT«Hash[0xfc987f10]»

[00:51] <lue> rakudo: multi sub infix:<orelse> ($a,$b) {if $a { return $a;} else { return $b;};}; say (0 orelse 1 orelse 2)

[00:51] <p6eval> rakudo 63ff06: OUTPUT«1␤»

[00:51] <jnthn> lue: yeah but iirc you need to thunk it.

[00:51] <sorear> nqp: sub foo(*%args) { print(%args.keys) }; foo(x => 2)

[00:51] <p6eval> nqp: OUTPUT«Method 'keys' not found for invocant of class 'Hash'␤current instr.: 'foo' pc 29 (EVAL_1:0)␤»

[00:52] <sorear> nqp: sub foo(*%args) { print(%args<x>) }; foo(x => 2)

[00:52] <p6eval> nqp: OUTPUT«2»

[00:52] <sorear> nqp: sub foo(*%args) { print(%args<x>) }; foo(-x => 2)

[00:52] <p6eval> nqp: OUTPUT«too many positional arguments: 1 passed, 0 expected␤current instr.: 'foo' pc 37 (EVAL_1:0)␤»

[00:52] <lue> thunk it?

[00:52] <sorear> nqp: sub foo(*%args) { print(%args<x>) }; foo('-x' => 2)

[00:52] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near "> 2)"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[00:52] <sorear> How do I form a named argument pair with a dahs

[00:53] <sorear> jnthn: Anyways, I don't actually have get_exports working, which is the last significant roadblock to binding POSIX, Tk, CGI, and other modules which you can use without subclassing to Parrot

[00:54] *** cotto joined
[00:54] <sorear> Making stuff like Bot::BasicBot work requires subclassing across HLL boundaries

[00:54] <sorear> which is slightly less trivial

[00:54] <jnthn> sorear: Not sure how you can do that too easily in NQP yet...it came up recently ish...forget the solution.

[00:54] <jnthn> Or workaround.

[00:55] <jnthn> sorear: Well, getting those working is a good start. :-)

[00:55] <lue> what is the process of thunking?

[00:55] <jnthn> It gets a whole load of CPAN available. Currently none of it is.

[00:55] <jnthn> lue: consider: if foo() || bar() { ... }

[00:55] <jnthn> Here if foo() is true then bar() doesn't get run

[00:55] <jnthn> So it's more going on that just a multi dispatch to infix:<||>

[00:56] <lue> Then I must've read the spec on orelse wrong

[00:56] <lue> I thought that was the point.

[00:57] <jnthn> Well, I"m rather tired too :-)

[00:57] <jnthn> Hmm...probably I should sleep

[00:57] <jnthn> Or I might sleep past my train tomorrow. Which would suck.

[00:57] <lue> Orelse is proceed on failure, so...

[00:58] <lue> night jnthn o/ (it's 3am already?)

[00:58] <jnthn> lue: Right, so you need to have the RHS only being if there's a failure

[00:58] <jnthn> Yes, 3am! O-O

[00:58] <jnthn> night o/

[00:59] <lue> rakudo: multi sub infix:<orelse> ($a,$b) {if $a { return $a;} else { return $b;};}; say (1==2 orelse 2<1 orelse 3==3)

[00:59] <p6eval> rakudo 63ff06: OUTPUT«0␤»

[00:59] <takadonet> how do your read a file in the 'lazy' way ?  

[01:01] <lue> afk

[01:07] <sorear> takadonet: hopefully, we won't

[01:07] <takadonet> ?

[01:08] <sorear> lazy file reading is a Bad Idea

[01:08] <sorear> been there, done that, got the headaches

[01:09] <takadonet> sorear: using $fh.get is the 'lazy' way

[01:09] <takadonet> does not read the whole file at once

[01:17] *** jaldhar left
[01:21] *** elmex left
[01:21] *** flity joined
[01:33] *** quietfanatic left
[01:36] *** justatheory left
[01:36] *** jferrero left
[01:41] *** mikehh left
[01:44] *** colomon joined
[01:46] *** cotto left
[01:48] *** jaldhar joined
[01:50] *** cotto joined
[01:55] *** Psyche^ joined
[01:57] *** charsbar joined
[01:58] *** cotto_work left
[01:59] *** Patterner left
[01:59] *** Psyche^ is now known as Patterner

[02:04] <lue> rakudo: multi sub infix:<orelse> ($a,$b) {say ($a,$b).join("\n"); if $a { return $a;} else { return $b;};}; say (1==2 orelse 2<1 orelse 3==3)

[02:04] <p6eval> rakudo 63ff06: OUTPUT«2␤2␤0␤»

[02:05] <lue> that's it, orelse has no precendence

[02:05] <lue> *defined

[02:05] <lue> rakudo: multi sub infix:<orelse> ($a,$b) {say ($a,$b).join("\n"); if $a { return $a;} else { return $b;};}; say ((1==2) orelse (2<1) orelse (3==3))

[02:05] <p6eval> rakudo 63ff06: OUTPUT«0␤0␤0␤1␤1␤»

[02:10] <lue> where would pasttype's be defined?

[02:15] <lue> I have the feeling properly implementing orelse/andthen will require my first trip into 楽土's deep magic :)

[02:18] *** flity left
[02:19] *** flity joined
[02:23] *** JimmyZ joined
[02:26] *** justatheory joined
[02:26] *** bwk joined
[02:30] *** elmex joined
[02:31] <bwk>   

[02:31] <bwk>   /bye

[02:31] *** wknight8111 left
[02:33] *** bwk left
[02:34] *** JimmyZ left
[02:42] *** slavik left
[02:53] *** justatheory left
[02:59] *** justatheory joined
[03:03] *** justatheory left
[03:09] *** justatheory joined
[03:14] *** justatheory left
[03:21] *** gfx joined
[03:28] <lue> afk

[03:30] *** stephenlb left
[03:33] *** simcop2387 left
[03:35] *** meppel joined
[03:39] *** meppl left
[03:40] *** justatheory_ joined
[03:40] *** ash_ joined
[03:42] *** justatheory_ is now known as justatheory

[03:46] *** simcop2387 joined
[04:08] *** wormwood joined
[04:34] *** cotto_work joined
[04:36] *** rgrau left
[04:48] *** meppel left
[05:00] *** bwk joined
[05:02] <sorear> jnthn: Tiiiiiny problem

[05:03] <sorear> jnthn: NQP doesn't support POD5

[05:06] <sorear> s/POD5/POD/

[05:06] <sorear> it supports a tiny subset of POD6 which is not compatible with perldoc

[05:07] <lue> NQPOD ?

[05:09] <sorear> for it to be called NQPOD, you would have to be able to write documentation in it

[05:09] <lue> NQNQPOD then :)

[05:15] <lue> What's the difference between NQP and P6? Why is it "Not Quite"? (I can guess, but specifics would be nice :) )

[05:15] <sorear> "Declarator Pod blocks must either precede or immediately follow a valid Perl 6 declarator,"

[05:16] <sorear> lue: NQP is stripped down to the point where one person can implement it without going insane

[05:16] <sorear> lots of varied features are removed

[05:16] <sorear> like the assignement/binding distinction

[05:16] <sorear> and user-defined operators

[05:16] <sorear> and non-parenthetized functions

[05:16] <sorear> and junctions

[05:17] <sorear> and the entire setting (use inline PIR for I/O)

[05:17] *** ash_ left
[05:17] <sorear> and the explicit metamodel

[05:17] <lue> Nice summary of P5, but I asked for NQP :D

[05:18] *** ash_ joined
[05:18] <lue> seriously, after saying it like that, it seems more like P5 :)

[05:18] <sorear> NQP is like P5 done right

[05:18] <sorear> NQP is what Larry should have created in 1993 or whatever

[05:18] <sorear> P6 is a 2010 programming language

[05:19] <sorear> maybe later

[05:20] <sorear> (also, minor nit but P5 does have the assignment/binding distinction and non-parenthetized functions)

[05:21] <sorear> "Declarator Pod blocks must either precede or immediately follow a valid Perl 6 declarator,"  <-  how I love ambiguous specifications

[05:21] <sorear> EITHER specifiy before

[05:21] <sorear> OR after

[05:22] <sorear> oh, it explains three pages down

[05:27] <lue> xor-ing is so annoying. What if I want to pick both? :(

[05:30] *** ash_ left
[05:31] <lue> .oO(It is sooo annoying trying to see the 4th dimension. But it's going to be worth it!)

[05:39] *** xinming left
[05:43] *** flip214 joined
[05:44] <flip214> hi

[05:48] <sorear> For example, at the start of a ShiftJIS encoded file you can specify C<=encoding ShiftJIS> in the ShiftJIS encoding.

[05:49] <sorear> ^^^ actually, the ASCII subset of ShiftJIS is compatible with UTF-8

[05:49] <sorear> flip214: hi

[05:51] *** xinming joined
[05:58] *** bwk left
[06:00] *** bwk joined
[06:00] <bwk> \help info

[06:00] <bwk> \help info

[06:01] *** bwk left
[06:02] *** bwk joined
[06:02] *** bwk left
[06:13] <lue> night

[06:14] *** bwk joined
[06:15] <bwk>  /who #perl6

[06:15] *** bwk left
[06:18] *** justatheory left
[06:20] <spinclad> rakudo: multi sub infix:<orelse> ($a is thunk, $b is thunk) { return $a() || $b() }; (say 0) orelse (say 1) orelse (say 2);

[06:20] <p6eval> rakudo 63ff06: OUTPUT«0␤1␤invoke() not implemented in class 'Boolean'␤current instr.: 'infix:<orelse>' pc 255 (EVAL_2:86)␤»

[06:22] <spinclad> rakudo: multi sub infix:<orelse> ($a is thunk, $b is thunk) { return $a() || $b() }; {{say 0} orelse {say 1}} orelse {say 2};

[06:22] <p6eval> rakudo 63ff06: OUTPUT«0␤»

[06:22] <spinclad> rakudo: multi sub infix:<orelse> ($a is thunk, $b is thunk) { return $a() || $b() }; say {{say 0} orelse {say 1}} orelse {say 2};

[06:22] <p6eval> rakudo 63ff06: OUTPUT«0␤1␤»

[06:24] <spinclad> rakudo: multi sub infix:<orelse> ($a is thunk, $b is thunk) { return $a() || $b() }; sub spit($a) { say $a; $a }; say {{spit 0} orelse {spit 1}} orelse {spit 2};

[06:24] <p6eval> rakudo 63ff06: OUTPUT«0␤1␤1␤»

[06:25] <spinclad> 'is thunk' seems to be ignored (see first try)...

[06:26] <spinclad> hmm..

[06:27] <spinclad> rakudo: multi sub infix:<orelse> ($a is thunk, $b is thunk) { return $a() || $b() }; sub spit($a) { say $a; $a }; say (spit 0) orelse (spit 1) orelse (spit 2);

[06:27] <p6eval> rakudo 63ff06: OUTPUT«0␤1␤invoke() not implemented in class 'Integer'␤current instr.: 'infix:<orelse>' pc 297 (EVAL_2:98)␤»

[06:28] <spinclad> rakudo: multi sub infix:<orelse> ($a is thunk, $b is thunk) { return $a() || $b() }; sub spit($a) { say $a; $a }; say (spit 1) orelse (spit 0) orelse (spit 2);

[06:28] <p6eval> rakudo 63ff06: OUTPUT«1␤0␤invoke() not implemented in class 'Integer'␤current instr.: 'infix:<orelse>' pc 297 (EVAL_2:98)␤»

[06:41] * sorear attempts to modify NQP to skip *all* POD6

[06:52] *** eiro joined
[06:52] *** eiro left
[06:52] *** eiro joined
[06:52] *** eiro left
[06:52] *** eiro joined
[06:55] *** justatheory joined
[06:58] *** hercynium left
[07:04] *** justatheory left
[07:07] *** rgrau` left
[07:12] *** Trashlord left
[07:38] *** am0c left
[07:47] *** jjore joined
[07:49] *** jjore left
[07:49] *** jjore joined
[07:56] *** flip214 left
[08:13] *** iblechbot joined
[08:21] *** asits joined
[08:23] *** asits left
[08:23] *** Su-Shee joined
[08:28] *** pmurias joined
[08:29] *** M_o_C joined
[08:36] *** skyler__ joined
[08:39] *** skyler_ left
[08:48] <snarkyboojum> how'd you with that sorear? :)

[08:55] <sorear> All I know so far is that P6regex hates ma

[08:55] <sorear> me

[08:57] <snarkyboojum> hugme: hug sorear

[08:57] * hugme hugs sorear

[08:58] <sorear> It's not working and not telling me why not.

[08:58] <sorear> So I'm shotgun debugging.

[08:58] <sorear> With 10 minute compile delays.

[08:58] <sorear> Confused at line 34!

[08:58] <sorear> and it doesn't even tell me what *rules* are casuing the problem

[08:59] <snarkyboojum> :(

[08:59] <sorear> I suppose nobody in this room understands NQP-rx well enough to spot bugs

[09:01] <snarkyboojum> certainly not me

[09:01] <sorear> PCT needs a debugger

[09:04] *** jaffa4 left
[09:05] *** jaffa4 joined
[09:05] *** jhuni joined
[09:14] <pmurias> ruoso: hi

[09:15] *** xinming left
[09:17] *** proller left
[09:18] *** proller joined
[09:20] <jnthn> morning

[09:20] <sorear> jnthn: do you understand p6 rules at all

[09:23] <jnthn> Yes.

[09:23] <sorear> http://pastie.org/900073 http://pastie.org/900074 http://pastie.org/900075

[09:23] <jnthn> Rakudo's grammar is written in them. :-)

[09:23] <sorear> I am absolutely stumped

[09:23] <sorear> I'm trying to add pod support to NQP

[09:24] <sorear> my modified rules compile

[09:24] <sorear> however, I'm still getting "Completely generic parse error" while trying to parse valid POD6

[09:26] * sorear waits for jnthn to change his mind about knowing anything

[09:26] <jnthn> Didn't say I know anything about POD. :-P

[09:26] <sorear> You don't have to

[09:26] *** mberends left
[09:27] <sorear> However, the new pod_comment rule I added doesn't work

[09:27] <sorear> I have no idea why and PCT won't tell me

[09:27] <sorear> All other tests pass

[09:27] <sorear> except the new ones I added

[09:29] <jnthn> assertion on line 52 through 56 - is the whole lot meant to be in a lookahead?

[09:30] <sorear> Which line is 52

[09:30] <sorear> my line 52 is:    [

[09:30] <sorear> If that's in a lookahead, then no

[09:30] <jnthn> in http://pastie.org/900073

[09:30] *** Trashlord joined
[09:31] *** gfx left
[09:31] <sorear> hmm, nopaste did a number on that file

[09:31] <sorear> Yes, I meant to put that entire block in a lookahead.

[09:32] <jnthn> OK

[09:32] <sorear> A 6POD block without begin/end cannot contain another block; it ends before the next = line

[09:32] <sorear> Did I phrase that into regex correctly

[09:32] <sorear> (sorry, I'm frustrated)

[09:32] <jnthn> So for this:

[09:32] <jnthn> =for comment blah

[09:32] <jnthn> say ("ok 5");

[09:33] <jnthn> oops, there's a line-break between then.

[09:33] <jnthn> Is it the blank line that terminates the directive?

[09:33] <sorear> the blank line terminates the comment, and the say is executed as code

[09:33] <sorear> yes

[09:34] <sorear> line 56 - ^^ \h* \n can postterminate the directive

[09:35] <jnthn> As a debugging thing, on:

[09:35] <jnthn> | <identifier>

[09:35] <jnthn> Try putting:

[09:35] <jnthn> | <identifier> { pir::say('got here') }

[09:35] <jnthn> To check that we're actually falling onto this rule 

[09:35] <jnthn> I think there's maybe also a <?DEBUG> that turns on some tracing.

[09:36] <jnthn> The casue doesn't jump out at me right away, though...after going over that bit it doesn't look obviously wrong.

[09:36] *** rbaumer joined
[09:37] * sorear recompiles

[09:37] <sorear> I added <?DEBUG> at the beginning of comp_unit

[09:38] <jnthn> Oh, maybe just wants to be <DEBUG>

[09:39] <jnthn> Looking at the source, <DEBUG(1)> can turn it on, <DEBUG(0)> can turn it off.

[09:39] <jnthn> And <DEBUG> alone turns it on.

[09:39] <jnthn> Buttom of http://github.com/perl6/nqp-rx/blob/master/src/Regex/Cursor-builtins.pir

[09:39] <sorear> Apparently it worked anyway, because the bootstrap process is generating an enormous amount of spam

[09:40] <jnthn> :-)

[09:41] <mathw> o/

[09:41] <jnthn> o/ mathw 

[09:42] <mathw> jnthn: have you discovered the real heating controls yet?

[09:43] <jnthn> mathw: :-P

[09:43] <jnthn> Akshually not.

[09:44] <mathw> :)

[09:44] <mathw> I picked up that tweet just after aikido last night

[09:44] <sorear> Yay, instead of NQP giving me /no/ information on why it refused to parse

[09:44] <sorear> I now have 1,642 lines of tracage

[09:44] <mathw> and cracked up in front of the instructors :)

[09:45] <mathw> I know it's mean, but it's very funny

[09:46] <Trashlord> sup dudes

[09:48] *** MAK_ joined
[09:49] <MAK_> hello

[09:49] <sorear> HELLO

[09:49] <MAK_> http://github.com/masak/yapsi is this is a rakudo fork

[09:49] <sorear> no

[09:50] <sorear> it's like pypy

[09:50] <sorear> it runs ON rakudo

[09:50] <MAK_> spec complete implementation?

[09:50] <jnthn> mathw: Heh, it was one of those moments that was kind "wtf" enough to share. :-)

[09:50] <sorear> MAK_: Spec complete implementations don't exist and won't for at least five years

[09:50] <sorear> The P6 spec is *huge*

[09:50] <MAK_> 5 years?????

[09:50] <sorear> More likely 10

[09:51] <jnthn> sorear: Heh. I think we're aiming for a bit less than that. :-)

[09:51] <MAK_> Socking news

[09:51] <MAK_> shocking

[09:51] <sorear> jnthn: Christmas will be far sooner, yes

[09:51] <jnthn> sorear: Where did you hear that, or is that your own opinion?

[09:51] <sorear> but it will be a long time before all the obscure corners of the spec are implemented in a single compiler

[09:52] <MAK_> perl 7 will need to be planned if perl 6 takes another decade to make a spec complete release

[09:52] <sorear> Christmas could be as early as next year

[09:52] <jnthn> sorear: Well, according to S01, it'll be somewhat driven by when there's a viable release that's useful. :-)

[09:52] <MAK_> seriously will it take 10 years?

[09:53] <sorear> MAK_: I don't think you grasp the magnitude of what "spec complete" means

[09:53] <MAK_> No i got it, the spec is always a moving target

[09:53] <MAK_> so by that definition there is nothing  like 'spec complete'

[09:54] <jnthn> Everything in the spec that nobody has implemented yet should be considered conjectural for 6.0.0 anyway.

[09:54] <MAK_> What I meant was that at some point the spec it self will freeze for some time and the implemetation will match it. called rakudo 1.0

[09:54] <sorear> MAK_: The spec is 1.25 megabytes of plain text

[09:54] <MAK_> will that take 10 years

[09:54] <sorear> this thing makes the C++ spec look like a leaflet

[09:54] <jnthn> mathw: I think that'll be rather sooner than 10 years.

[09:54] <jnthn> er

[09:54] <jnthn> MAK_: ^

[09:55] <sorear> If the spec were frozen *right now* it wouldn't be fully implemented for many years to come

[09:55] <MAK_> The spec can even 1.25 GB if it isnt frozen

[09:55] <sorear> It's 2010, do you know how many compilers fully implement C++ 1999?

[09:56] <sorear> 0.

[09:56] <pmurias> sorear: have you seen the c++ spec?

[09:56] <MAK_> :(

[09:56] <sorear> pmurias: yes, it's shorter than the perl one

[09:56] <MAK_> no

[09:56] <MAK_> why the hell then people look at perl and C++ with different standards

[09:57] <sorear> the C++ spec is 1,300 pages of precisely specified legalese

[09:57] <sorear> the Perl spec is 40,000 lines of dense and ambiguous prose

[09:58] <MAK_> no my question was regarding a release named 6.0.0 wil that take 10 years?

[09:58] <sorear> 6.0.0 will not be spec complete

[09:58] <MAK_> that is ok 

[09:58] <sorear> large parts of the spec will be rechristened future plans

[09:58] <MAK_> but will 6.0.0 take 10 years?????

[09:58] <sorear> 6.0.0 will probably come in '11 or '12

[09:58] <sorear> no

[09:58] <sorear> the first feature complete 6 will take 10 years

[09:58] <sorear> or more

[09:59] <sorear> that's like 6.28.0

[09:59] <sorear> perl 6 has a lot of features

[09:59] <sorear> go read the synopses

[09:59] <sorear> all of them

[09:59] <sorear> in order

[09:59] <MAK_> well as you said I understood, we are speaking achieving a very ambitous aim

[09:59] <sorear> you'll be back sometime in may

[09:59] <MAK_> for?

[09:59] <MAK_> ok

[09:59] <MAK_> got it

[09:59] <sorear> well, assuming you do nothing other than read and don't return until you finisjh

[10:00] <MAK_> I never questioned the magnitude of the job

[10:00] <MAK_> but if its really so huge, how do people managed to stay focussed on it for so long? 

[10:00] <sorear> in that case, you greatly overestimate our manpower

[10:00] <sorear> we have lesser milestones

[10:01] <colomon> rakudo: say (+"2i")

[10:01] <p6eval> rakudo 63ff06: OUTPUT«2␤»

[10:01] <sorear> the most important of which is codename "Christmas", when implemented perl 6 becomes better than 5

[10:01] <MAK_> But 6.0.0 by 2011 is perfectly acceptable 

[10:02] <MAK_> the '10 years' thing kind of shocked me for a moment

[10:02] <pmurias> MAK_: where did you get that estimate?

[10:02] <sorear> Me

[10:03] <sorear> MAK_ was asking how long it would take for every single word in docs/Perl6/Spec/*.pod to be implemented

[10:03] <sorear> I said, very optimistically, 10 yearxs

[10:06] <MAK_> This is also means yapsi is only as complete as rakudo

[10:06] <pmurias> yapsi is less compelete then rakudo

[10:06] <MAK_> always

[10:06] <sorear> yapsi *just started*

[10:07] * jnthn -> train station + 5 hour journey

[10:07] <sorear> and you expect it to implement all 194,000 words of the spec?

[10:07] *** Trashlord left
[10:07] <jnthn> (but maybe wifi on train)

[10:07] <colomon> god traveling

[10:07] *** clintongormley joined
[10:07] <colomon> *good

[10:07] <colomon> though that's an interesting typo

[10:08] <MAK_> How of spec will 6.0.0 of 2011 will cover? atleast 70%?

[10:09] <sorear> Why do you care?

[10:09] <MAK_> hmmm

[10:09] <MAK_> ok then leave it

[10:09] <moritz_> good localtime() everybody

[10:09] <colomon> o/

[10:12] *** yinyin left
[10:14] <mathw> o/ moritz

[10:14] *** jferrero joined
[10:14] <colomon> rakudo: say 10 || 9

[10:14] <p6eval> rakudo 63ff06: OUTPUT«10␤»

[10:14] <colomon> rakudo: say 10 !!|| 9

[10:14] <p6eval> rakudo 63ff06: OUTPUT«1␤»

[10:15] <moritz_> rakudo: say 1 !|| 3

[10:15] <p6eval> rakudo 63ff06: OUTPUT«0␤»

[10:16] <moritz_> colomon: do you have any idea how to get reduce of chained ops working?

[10:17] <colomon> moritz_: I don't know that I know how to do it correctly.

[10:17] <colomon> but we could chain it by hand easily enough.

[10:17] <pmurias> how can type inference be tested?

[10:17] <colomon> moritz_: we just have to be a lot smarter in how we handle things with [op]

[10:18] <sorear> jnthn: The super obvious thing I was missing?  You can't have a space between function and ( in NQP.

[10:18] <moritz_> colomon: my idea was: check if op is %chaining, and if yes, dispatch to a different reduce method

[10:18] <moritz_> sorear: same in Perl 6

[10:19] <colomon> moritz_: I think we might do well to move everything to a different reduce method.  :)

[10:19] <pmurias> adding a INFERED_TYPE_IS($expression,"internal type description") seems to be a solution

[10:19] <colomon> is %chaining always a serious of boolean comparisons?

[10:19] <moritz_> pmurias: well, by writing test cases. Only that it can't be normal Perl 6, because it's not specced

[10:19] <moritz_> right, that should help

[10:20] <moritz_> colomon: chaining associativity implies that $a op $b op $c is the same as ($a op $b) && ($b op $c)

[10:20] <colomon> we can certainly work with that.

[10:21] <moritz_> so, how do I ask in the action method if an op has chaining assoc?

[10:22] * colomon goes looking...

[10:23] * moritz_ goes backlogging

[10:23] <colomon> jnthn may have picked an awkward time to go on a train.  :)

[10:24] *** MAK_ left
[10:25] <sorear> .*? still means as little as possible, right?

[10:26] <moritz_> sorear: yes.

[10:26] <moritz_> sorear: but beware, tokens don't backtrack

[10:26] <moritz_> so .*? never matches anything inside a token

[10:27] <moritz_> sorear: re POD parsing, it might be worth looking at how STD.pm does it

[10:27] <sorear> I'm suprised this is working at all, then

[10:27] <sorear> .*? in a token is matching /too much/

[10:27] <moritz_> wow

[10:27] <sorear> Where does STD live

[10:28] <moritz_> rakudo: our token a { .*? }; say 'foo' ~~ /<a>/

[10:28] <p6eval> rakudo 63ff06: OUTPUT«Method 'a' not found for invocant of class 'Regex;Cursor'␤current instr.: '_block63' pc 625 (EVAL_1:243)␤»

[10:28] <sorear> token pod_comment {

[10:28] <sorear>     ^^ \h* '='

[10:28] <sorear>     [

[10:28] <sorear>     | 'begin' \h+ 'END' >>

[10:28] <sorear>         [ .*? \n '=' 'end' \h+ 'END' » \N* || .* ]

[10:28] <sorear>     | 'begin' \h+ <identifier>

[10:28] <moritz_> sorear: pugs repo

[10:28] <sorear>         [

[10:28] <sorear>         ||  .*? \n '=' 'end' \h+ $<identifier> » \N*

[10:28] <sorear>         ||  <.panic: '=begin without matching =end'>

[10:28] <sorear>         ]

[10:28] <sorear>     | 'begin' » \h*

[10:28] <sorear>         [ $$ || '#' || <.panic: 'Unrecognized token after =begin'> ]

[10:28] <sorear>         [

[10:28] <moritz_> http://svn.pugscode.org/pugs/src/perl6/STD.pm

[10:28] <sorear>         || .*? \n \h* '=' 'end' » \N*

[10:28] <sorear>         || <.panic: '=begin without matching =end'>

[10:28] <sorear>         ]

[10:28] <sorear>     | <identifier>

[10:28] <sorear>         .*? <?before ^^ \h* [ 

[10:28] <sorear>             '='

[10:28] <sorear>             [ 'cut' »

[10:28] <pmurias> sorear: nopaste

[10:29] <sorear>               <.panic: 'Obsolete pod format, please use =begin/=end instead'> ]?

[10:29] <sorear>           | \n ]>

[10:29] <sorear>     |

[10:29] <sorear>         [ \s || <.panic: 'Illegal pod directive'> ]

[10:29] <sorear>         \N*

[10:29] <sorear>     ]

[10:29] <sorear> }

[10:29] <pmurias> nopaste: http://paste.lisp.org/new/perl6

[10:30] <sorear> pmurias: I nopasted, then attempted to copy the URL, failed, and pasted the wrong thing

[10:30] <sorear> (I'm suprised nobody kicked me)

[10:30] *** MAK_ joined
[10:30] <sorear> http://pastie.org/900118

[10:30] <sorear> this is what I meant to paste

[10:30] * moritz_ was not fast enough to kick

[10:31] * sorear needs an IRC client with better flood control

[10:31] * moritz_ recommends irssi

[10:31] * sorear is using irssi

[10:32] <sorear> moritz_: that nopaste ^^ is my current rule

[10:32] <moritz_> wow, my irssi has flood control

[10:32] <sorear> my irssi has flood control.  that's why I said "better"

[10:32] <sorear> to my knowledge irssi has no command to retroactively stop a paste

[10:32] <moritz_> ok :-)

[10:33] <sorear> I meant to paste text, so I confirmed (not reading enough of the message to see the "29 lines" bit)

[10:35] <sorear> Can I feed newlines into p6eval

[10:36] <sorear> STD.pm appears to not support general-case abbreviated Pod, either

[10:36] <moritz_> rakudo: say1

[10:36] <p6eval> rakudo 63ff06: OUTPUT«Could not find sub &say1␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[10:36] <moritz_> rakudo: say 1

[10:36] <p6eval> rakudo 63ff06: OUTPUT«1␤»

[10:37] <moritz_> rakudo: say 1;␤say 2 # p6eval converts the ␤ # into a newline

[10:37] <p6eval> rakudo 63ff06: OUTPUT«1␤2␤»

[10:38] <sorear> std: =begin comment␤=end comment

[10:38] <p6eval> std 30265: OUTPUT«ok 00:01 107m␤»

[10:38] <sorear> std: =for comment␤=begin comment␤=end comment␤SYNTAX ERROR

[10:38] <p6eval> std 30265: OUTPUT«ok 00:01 105m␤»

[10:38] <sorear> std: SYNTAX ERROR

[10:39] <p6eval> std 30265: OUTPUT«Undeclared names:␤     'ERROR' used at line 1␤   'SYNTAX' used at line 1␤ok 00:01 106m␤»

[10:39] <sorear> std gets it wrong

[10:39] *** MAK_ left
[10:41] <sorear> moritz_: do you see what's wrong here?

[10:42] <moritz_> sorear: I'm not familiar with the current POD format at all

[10:43] <sorear> moritz_: this isn't a pod challenge

[10:43] <sorear> 03:38 < sorear> std: =for comment␤=begin comment␤=end comment␤SYNTAX ERROR

[10:43] <sorear> ^^^ this input should be parsed as 2 pod comments followed by an uncommented line

[10:43] <sorear> however, my NQP rules don't work correctly

[10:44] <sorear> .*? is being greedy and is eating the entire paragraph, instead of stopping at ^^ =

[10:46] <moritz_> rakudo: say 'a' ne 'b'

[10:46] <p6eval> rakudo 63ff06: OUTPUT«1␤»

[10:47] <colomon> moritz_: look at copyO in Grammar.pm.  That shows how to fetch the O value.

[10:47] <sorear> who are the P6 rules experts around here

[10:48] <sorear> I don't need pod

[10:49] <jnthn> sorear: If you odn't need it, then I suggest not trying to implement it. :-)

[10:49] * jnthn has slow net access on the train

[10:49] <colomon> jnthn: \o/

[10:50] <jnthn> sorear: If you're trying to go beyond what STD does, then maybe better to let STD work it out first. :-)

[10:50] <jnthn> I think S26 maybe generally needs some tweaking yet too.

[10:51] <jnthn> colomon: Just pondering how you can go introspecting the Os from the grammar...if there's a way to do that.

[10:51] <sorear> ok, I'll just TODO the test

[10:51] <colomon> looks to me like you do that in copyO?

[10:52] <jnthn> Well, yes, but that's from within the grammar.

[10:52] <jnthn> Whereas I guess you want to do it at runtime?

[10:52] <jnthn> In the grammar we just parsed it, so have access to it in the syntax tree...

[10:52] * moritz_ just added a ton of prefix:<[+]>() { 0 } subs to the setting, see if it works...

[10:52] <jnthn> moritz_++

[10:53] <colomon> moritz_: you shouldn't need the [ ]  in there.

[10:53] <moritz_> colomon: oh, you're right

[10:53] * jnthn likes how this train has inclusive coffee :-)

[10:54] <sorear> patch generated, time to track down the NQP czar

[10:54] <colomon> jnthn: we want access to it from prefix_circumfix_meta_operator:sym<reduce>, I think.

[10:55] *** opx^on joined
[10:55] <sorear> the github remote is "perl6"

[10:55] <moritz_> sorear: it's pmichaud 

[10:55] <jnthn> colomon: Are you thinking we pass it as an adverb to reduce?

[10:55] * moritz_ suggested that

[10:55] <colomon> jnthn: or call a different version of reduce, something like that.

[10:55] <moritz_> or maybe use a different reduce alltogether

[10:56] <sorear> moritz_: should I sit on it until pmichaud's life has stabilized?

[10:56] <jnthn> Ah, passing it along as adverb would be easy I guess.

[10:56] <sorear> I found the CREDITS

[10:57] <moritz_> sorear: depends on the patch... if it seems obviously correct and non-intrusive, we might apply it without asking pmichaud

[10:57] *** opx^on left
[10:57] <jnthn> Aye. Generally I think we may have to not wait for pmichaud in some areas we normally would, if it's starting to block us too much.

[10:57] *** opx^on joined
[10:58] <sorear> moritz_: http://pastie.org/900148

[10:59] <sorear> does that count as obviously correct

[11:02] <moritz_> looks fine to me

[11:02] *** snarkyboojum left
[11:03] <moritz_> somehow the patch doesn't apply here

[11:03] <colomon> So, should [&&] short circuit?

[11:03] <moritz_> colomon: nope

[11:03] <jnthn> colomon: no

[11:03] <sorear> moritz_: corrupt patch?

[11:03] <moritz_> colomon: S03 mentions that [thing] is parsed as a normal listop, not macro-ish

[11:03] <moritz_> sorear: maybe it's UTF-8 mess

[11:03] <sorear> I blame pastebin

[11:03] <colomon> k

[11:04] <moritz_> sorear: are your also 'sorear' on github?

[11:04] <sorear> my normal fileserver is down now...

[11:04] <sorear> yes

[11:04] <moritz_> hugme: add sorear to nqp-rx

[11:04] * hugme hugs sorear. Welcome to nqp-rx!

[11:04] <sorear> I could use github but it feels like such a waste for a one-off patch

[11:04] <moritz_> sorear: push it :-)

[11:05] *** snarkyboojum joined
[11:09] <moritz_> > say infix:<+>()

[11:09] <moritz_> 0

[11:09] <moritz_> > say infix:<*>()

[11:09] <moritz_> 1

[11:09] <moritz_> however if I enable that for all operators, I get weird errors while compiling Test.pir

[11:10] <dalek> nqp-rx: 31b97cc | sorear++ |  (2 files):

[11:10] <dalek> nqp-rx: Implement paragraph and abbreviated Pod comments

[11:10] <dalek> nqp-rx: With this, NQP implements all forms of pod comment defined in S26, except

[11:10] <dalek> nqp-rx: for the multiline declaration comment (left out on purpose, it's useless

[11:10] <dalek> nqp-rx: without a metamodel) and paragraph blocks which are terminated by the

[11:10] <dalek> nqp-rx: start of a delimited block (a corner case that STD fails too).

[11:10] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/31b97cc76359dbd8582da12c90ed56526d9bf7ce

[11:12] <jnthn> moritz_: Such as?

[11:13] <colomon> moritz_: when compiling Test.pir?  can you narrow it down to particular operators that cause the trouble?

[11:13] <moritz_> Method 'incorporate_candidates' not found for invocant of class 'MultiSub'

[11:13] <moritz_> I suspect it happens when I try to add a multi that's not yet defined in Perl 6

[11:13] <moritz_> testing this hypothesis now

[11:14] <jnthn> moritz_: Yes, sounds like it.

[11:14] <jnthn> moritz_: Sounds like it's a case of it already existing in PIR perhaps

[11:16] <moritz_> aye

[11:17] <moritz_> I just comment them out

[11:17] <moritz_> and for now only active those ops that are actually defined in Perl 6

[11:17] <jnthn> wfm

[11:17] *** xinming joined
[11:17] <jnthn> Though we should also move those ones not defined in Perl 6 into being.

[11:18] *** riffraff joined
[11:18] <clintongormley> moritz_: thanks for the strace suggestion yesterday - it helped me figure out what was going wrong

[11:19] <moritz_> clintongormley: so, what was wrong?

[11:19] <clintongormley> a child was exiting inbetween steps in LWP::Protocol::http, setting $! to a spurious value

[11:19] <clintongormley> so local'izing $! and %! in my reaper solved that

[11:20] <moritz_> evil action at a distance

[11:20] <moritz_> we know why $! is not a global variable in Perl 6 anymore

[11:20] <clintongormley> indeed!

[11:21] <moritz_> just like sub DESTROY { eval { # this resets $@ implicitly } }

[11:21] <clintongormley> yeah

[11:22] <clintongormley> btw, how is performance in p6 these days? has it improved dramatically with rx? or not yet?

[11:23] *** snarkyboojum left
[11:23] <dalek> rakudo: 1c57374 | moritz++ | src/core/metaops.pm:

[11:23] <dalek> rakudo: implement 0-ary infix operators, to be used as the degenerated case by the reduce meta operator

[11:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1c573748de8443ff8832519e15af5130d06dc950

[11:23] <moritz_> clintongormley: actually just yesterday there was a decent performance boost, due to some optimizations by parrot folks

[11:23] <moritz_> bacek++

[11:23] <moritz_> chromatic++

[11:23] <clintongormley> oh yes - i saw a tweet about that, a 4 line change

[11:23] <clintongormley> nice :)

[11:24] <clintongormley> so could you compare it to p5 performance? as in 30% as fast a the equiv in p5 or something like that?

[11:24] <moritz_> it halfed time and memory usage of rakudo compilation

[11:24] <clintongormley> wow!

[11:24] <moritz_> will, it's still orders of magnitudes slower

[11:25] <moritz_> as in, typically takes about 100x of the Perl 5 code

[11:25] <clintongormley> ok

[11:26] <clintongormley> i realise that you're not in the optimisation stage yet, but any ideas about the likely final outcome? eg it'll always be slower because it is doing more, but we expect to reach X

[11:26] <moritz_> I have no idea, actually

[11:26] <moritz_> when parrot gets a decent JIT engine, much is possible

[11:26] <clintongormley> ok

[11:26] <moritz_> but there's no way I could predict that

[11:27] <clintongormley> whyever not?

[11:27] <clintongormley> don't ever let reality get in the way of predictions!

[11:27] <moritz_> :-)

[11:27] <colomon> moritz_, jnthn: I'm working on a new reduce function specifically for [op]

[11:27] <moritz_> colomon++

[11:28] <jnthn> colomon: Cool.

[11:28] <jnthn> colomon: I guess the question is, should .reduce given an op know what to do with it just automatically or not...

[11:28] <jnthn> Or should have have ot pass in adverbs to specify the assoc or chaining, etc.

[11:29] <moritz_> which boils down to the question: does a multi know its own associativity etc.?

[11:29] <jnthn> Well, I guess it'd be done by traits.

[11:30] <jnthn> But we don't implement protos sharing the love^Wtraits yet.

[11:30] *** Chillance joined
[11:36] *** masak joined
[11:36] <masak> oh hai, #perl6!

[11:36] <phenny> masak: 01 Apr 23:33Z <snarkyboojum> tell masak 'lid' is an awesome name for the coverage tool :)

[11:36] <phenny> masak: 00:19Z <diakopter> tell masak  rakudo: 0 but last

[11:36] <masak> rakudo: 0 but last

[11:36] <p6eval> rakudo 63ff06: OUTPUT«Warning␤Null PMC access in can()␤current instr.: 'parrot;P6protoobject;ACCEPTS' pc -1 ((unknown file):-1)␤»

[11:36] * masak submits rakudobug

[11:36] <moritz_> rakudo: last

[11:36] <p6eval> rakudo 63ff06: OUTPUT«Warning␤»

[11:36] <moritz_> std: 1 ?? 2 : 3

[11:36] <p6eval> std 30265: OUTPUT«[31m===[0mSORRY![31m===[0m␤Precedence too loose within ??!!; use ??()!! instead  at /tmp/Wx3K3jQgcH line 1:␤------> [32m1 ?? 2 [33m⏏[31m: 3[0m␤    expecting an infix operator with precedence tighter than item assignment␤FAILED 00:01 109m␤»

[11:36] <masak> \o/

[11:37] <masak> a bit LTA, but much better than before.

[11:37] <moritz_> rakudo: 1 ?? 2 : 3

[11:37] <p6eval> rakudo 63ff06: OUTPUT«Confused at line 11, near "1 ?? 2 : 3"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[11:37] <masak> rakudo: die "A"; CATCH { say "OH HAI" }; CATCH { say "OH NOES" }

[11:37] <p6eval> rakudo 63ff06: OUTPUT«OH HAI␤»

[11:37] <masak> std: die "A"; CATCH { say "OH HAI" }; CATCH { say "OH NOES" }

[11:37] <p6eval> std 30265: OUTPUT«ok 00:01 106m␤»

[11:38] <masak> what actually *does* happen when you have to CATCH blocks in a scope?

[11:38] <masak> S04 only says that it's disallowed.

[11:38] <masak> should it be a compile-time error?

[11:38] * moritz_ hopes so

[11:38] <masak> s/to/two/

[11:38] * masak submits rakuodbug

[11:40] <jnthn> masak: oh hai!

[11:41] <masak> loljnthnonatrain!

[11:41] <moritz_> rakudo: say <a b c> Z (1, *)

[11:41] <p6eval> rakudo 63ff06: OUTPUT«a1b!whatever_dispatch_helper␤»

[11:42] <masak> rakudo: my $a; CHECK { $a = 42 }'

[11:42] <p6eval> rakudo 63ff06: OUTPUT«Confused at line 11, near "CHECK { $a"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[11:42] <masak> rakudo: my $a; INIT { $a = 42 }'

[11:42] <p6eval> rakudo 63ff06: OUTPUT«Confused at line 11, near "INIT { $a "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[11:42] * masak submits rakudobug

[11:42] <moritz_> masak: there's a trailing ' in your input

[11:42] <masak> argh.

[11:42] <masak> rakudo: my $a; CHECK { $a = 42 }

[11:42] <p6eval> rakudo 63ff06: OUTPUT«Null PMC access in getprop()␤current instr.: '&infix:<=>' pc 16888 (src/builtins/Junction.pir:228)␤»

[11:42] <masak> rakudo: my $a; INIT { $a = 42 }

[11:42] <p6eval> rakudo 63ff06: OUTPUT«Null PMC access in getprop()␤current instr.: '&infix:<=>' pc 16888 (src/builtins/Junction.pir:228)␤»

[11:42] <masak> moritz_: thanks.

[11:43] <jnthn> masak: Ja, jag är i tåget. :-)

[11:44] <jnthn> masak: Men nu jag vill äta lunch. bbiab :-)

[11:44] <masak> technically right to use 'i', but we use 'på' as to the Englishmen.

[11:44] <masak> s/nu jag vill/nu vill jag/

[11:44] <jnthn> ...you can explain why that last one when I arrive. :-)

[11:44] <masak> (there's a rule that puts the predicate before the subject if the sentence starts with an adverbial)

[11:44] * jnthn ->> nomvagn

[11:44] <masak> :)

[11:45] <moritz_> rakudo: my $x; say $x * 3

[11:45] <p6eval> rakudo 63ff06: OUTPUT«0␤»

[11:45] <masak> no warning?

[11:45] <moritz_> alpha: my $x; say $x * 3

[11:45] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤0␤»

[11:45] <masak> there we go.

[11:45] * masak submits regression rakudobug

[11:45] <moritz_> masak: there's already a ticket for it

[11:45] <moritz_> for warnings with undefined values

[11:45] <masak> then I won't submit one :P

[11:45] <moritz_> alpha: my $x; $x *= 4; say $x

[11:45] <p6eval> alpha 30e0ed: OUTPUT«4␤»

[11:45] <masak> s/as to/as do/

[11:45] <moritz_> rakudo: my $x; $x *= 4; say $x

[11:45] <p6eval> rakudo 1c5737: OUTPUT«0␤»

[11:46] <moritz_> now that's a more interesting regression

[11:46] <moritz_> rakudo: say infix:<*>()

[11:46] <p6eval> rakudo 1c5737: OUTPUT«1␤»

[11:46] <masak> moritz_: is there a ticket for the more interesting regression?

[11:46] <moritz_> masak: not that I'm aware of

[11:46] * masak submits one

[11:47] <masak> I couldn't sleep last night. I laid up thinking about phasers. :/

[11:48] <moritz_> Actions.pm line 2008 looks wrong to me

[11:48] <moritz_> what if $<infix_prefix_meta_operator><sym> is something other than !?

[11:49] <masak> write a test that makes it fail :P

[11:50] <moritz_> I guess that doesn't work easily, since we can't define custom infix_prefix_meta_operator's yet

[11:50] <moritz_> oh

[11:50] <moritz_> rakudo: say 3 R!= 3

[11:50] <p6eval> rakudo 1c5737: OUTPUT«0␤»

[11:50] <moritz_> rakudo: say 3 R!= 4

[11:50] <p6eval> rakudo 1c5737: OUTPUT«1␤»

[11:50] <moritz_> hm

[11:51] <moritz_> rakudo: say 3 Z!= 4

[11:51] <p6eval> rakudo 1c5737: OUTPUT«1␤»

[11:52] <moritz_> rakudo: say 3 Z!= 0

[11:52] <p6eval> rakudo 1c5737: OUTPUT«1␤»

[11:52] <moritz_> rakudo: say 3 !!= 0

[11:52] <p6eval> rakudo 1c5737: OUTPUT«0␤»

[11:52] <moritz_> rakudo: say 3 !!= 3

[11:52] <p6eval> rakudo 1c5737: OUTPUT«1␤»

[11:52] * moritz_ givez up

[11:55] <moritz_> still, this unconditional special-casing of infix:<!=> makes me uneasy

[11:55] <colomon> moritz_: line 2008 is only supposed to trigger on that particular operator. 

[11:55] <moritz_> colomon: yes, but independent of the meta op

[11:56] *** payload joined
[11:56] <moritz_> if $metaop eq '!' &&  $opsub eq "&infix:<!=>" {

[11:56] <colomon> moritz_: no, that factors in the meta op

[11:56] <moritz_> oh.

[11:56] <moritz_> you're right

[11:56] <moritz_> and I'm stupid :-)

[11:58] *** payload left
[11:58] <colomon> it is a weird special case, I admit.  :)

[11:58] *** payload joined
[12:00] <colomon> and at least in theory, the grammar should handle it.  But in practice, I needed to add the special case to make things work.

[12:01] <moritz_> i can see - it would take assignment operator and negate the result

[12:03] *** snarkyboojum joined
[12:05] *** envi^home joined
[12:05] *** molaf joined
[12:07] <masak> snarkyboojum: oh hai!

[12:07] <snarkyboojum> masak: hello!

[12:07] <masak> snarkyboojum: we had a successful first release yesterday! \o/

[12:08] <masak> now there's a bit of a technical debt in the form of tests that should've been written for the runtime... :)

[12:08] <snarkyboojum> masak: congratulations :) enjoyed the release email :) o/

[12:08] <masak> thanks. :)

[12:09] <snarkyboojum> ah yes - played with it a bit today - fun stuff

[12:09] <masak> snarkyboojum: if you want some LHF, see if you can make the 'say' op go through an object with a .say method -- that'll help us mocking for the tests.

[12:09] <snarkyboojum> what is missing in master to stop it from working there

[12:09] <snarkyboojum> masak: ok - will take a gander

[12:10] <masak> don't know exactly what's missing in master, but I expect us to go with alpha for as long as GGE doesn't run on master.

[12:10] <snarkyboojum> masak: ah - good point

[12:11] <masak> snarkyboojum: I think making an $!output attribute and passing an object in with the constructor Runtime.new would be enough.

[12:12] <masak> I plan to write up a more detailed roadmap for the coming month, thereby hopefully increasing the bus number by some fractions at least.

[12:13] <takadonet> morning all

[12:13] *** wknight8111 joined
[12:13] <masak> takadonet: \o

[12:13] *** payload left
[12:15] <masak> well, time to go home and have lunch. see y'all tonight.

[12:15] *** masak left
[12:15] *** fda314925 left
[12:16] <takadonet> rakudo: ??? 'Warning....'

[12:16] <p6eval> rakudo 1c5737: OUTPUT«Stub code executed␤»

[12:17] *** fda314925 joined
[12:23] *** opx^on left
[12:43] <pugssvn> r30266 | moritz++ | [t/spec] partially fudge reduce.t for rakudo 

[12:43] <pugssvn> r30267 | moritz++ | [t/spec] unfudge a given test for rakudo 

[12:46] <moritz_> rakudo: my $x = 3; say "foo \$x"

[12:46] <p6eval> rakudo 1c5737: OUTPUT«foo \3␤»

[12:46] * moritz_ reports bug

[12:48] *** payload joined
[12:52] *** molaf left
[12:54] <snarkyboojum> phenny: tell masak, not sure if you meant something like this re making the say 'op' go through an object with a .say method? http://gist.github.com/353097

[12:54] <phenny> snarkyboojum: I'll pass that on when masak is around.

[12:55] <pugssvn> r30268 | moritz++ | [t/spec] fudge identity.t for rakudo 

[12:55] <pugssvn> r30269 | moritz++ | [t/spec] account for the fact that subs are lexical by default; fudge an integration test for rakudo 

[12:59] <snarkyboojum> rakudo: class A { method test($message) { say $message } }; A.new.test("hello")

[12:59] <p6eval> rakudo 1c5737: OUTPUT«hello␤»

[13:00] <snarkyboojum> rakudo: class A { method test($message) { say $message } }; my A $a .= new; $a.test("hello");

[13:00] <p6eval> rakudo 1c5737: OUTPUT«hello␤»

[13:01] <snarkyboojum> rakudo: class A { method test($message) { say $message } }; my A $a .= new; $a.test "hello";

[13:01] <p6eval> rakudo 1c5737: OUTPUT«Confused at line 11, near "$a.test \"h"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[13:03] *** payload left
[13:03] *** payload joined
[13:04] <moritz_> $a.test: 'hello'

[13:05] <snarkyboojum> moritz_: thanks :)

[13:05] *** envi^home left
[13:07] <m6locks> happy easter y'all! :3

[13:08] <m6locks> now it's time for sum sushi ->

[13:08] * PerlJam wonders how the Catalysty style of using  sub foo : bar() baz() { ... } will be reconciled with the perl6y sub foo :bar() :baz() { ... }   

[13:09] <PerlJam> Seems like it would be nice to get the perl5 folks to start leaning in a perl6 direction on that one

[13:09] *** proller left
[13:09] <moritz_> PerlJam: nope, attributes will be replaced by 'sub foo is bar'

[13:10] <moritz_> traits

[13:10] *** proller joined
[13:10] *** iblechbot left
[13:11] <snarkyboojum> I really like that $a.test: 'hello' syntax

[13:11] <moritz_> masak does not :-)

[13:11] <PerlJam> oh,  that's right.  I've been doing to much Perl 5 lately that I don't sufficiently context switch

[13:11] * moritz_ likes it, too

[13:11] <snarkyboojum> the colon just seems to make so much sense, more natural to me :)

[13:11] <PerlJam> s/to/too/

[13:11] <snarkyboojum> oic

[13:12] <snarkyboojum> I've seen it in some of his code tho :)

[13:12] *** envi^home joined
[13:13] *** rgrau joined
[13:16] *** meppl joined
[13:22] <dalek> rakudo: dd2043b | moritz++ | t/spectest.data:

[13:22] <dalek> rakudo: we pass 4 more tests

[13:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/dd2043b5c06b1c94ce029d3fd788e2c75ac0471e

[13:23] <colomon> \o/

[13:24] <jnthn> Is that 4 more tests, or test files? :-)

[13:25] <moritz_> test files

[13:25] <jnthn> \o/

[13:27] <takadonet> how well do Grammar work in the current master branch?

[13:27] <moritz_> quite OK

[13:28] <moritz_> proto regexes work!

[13:28] <takadonet> ok, Having some trouble on some old code that worked before the NG branch was merged back into the master

[13:29] <moritz_> one thing that doesn't work in master is backslash escapes in character classes

[13:29] <PerlJam> takadonet: show the code (and error) and maybe one of us can tell you where things go awry

[13:30] <takadonet> PerlJam:I will as soon as I narrow down the bug little more. The application is over 4 files right now...

[13:30] <PerlJam> takadonet++  I like that ... talking about a Perl 6 application  :)

[13:30] <takadonet> finally!

[13:32] <snarkyboojum> anon subtypes in method signatures rock

[13:33] <jnthn> :-)

[13:33] <jnthn> Perl 6 signatures are generally pretty cool.

[13:34] <jnthn> Ooh, there's snow here. :-D

[13:34] <jnthn> (Well, outside the train.)

[13:34] <snarkyboojum> was just reading "The Next Mainstream Programming Language" preso by Tim Sweeney, and he was talking about dependent types, and I thought - hey Perl 6 can do that.. I think that's how :)

[13:35] <jnthn> Yeah. :-)

[13:35] <snarkyboojum> too advanced ;)

[13:35] <jnthn> Heh. Perl is all about taking cool things and getting mere mortals using them without realising it.

[13:36] <PerlJam> the next mainstream programming language will do all the things that Perl  6 can do, but will it be Perl 6?

[13:36] <jnthn> "I'm not currying! I just call .assuming!"

[13:36] <snarkyboojum> hehe

[13:36] <snarkyboojum> partial function application? what's that?

[13:42] *** arnsholt joined
[13:44] *** synth joined
[13:44] *** payload left
[13:49] <TimToady> moritz_: .*? is supposed to work fine in a token, just as .*! does; in either case the greedy or frugal behavior overrides context

[13:52] <takadonet> there is no debugger for parrot code is there?

[13:53] <moritz_> TimToady: ah, ok

[13:54] <moritz_> 29057 passing tests

[13:54] <jnthn> moritz_: \o/

[13:54] <jnthn> moritz_++

[13:55] *** xabbu42 joined
[13:55] * moritz_ barely involved

[13:58] <lisppaste3> colomon pasted "Start of new reduce for [op]" at http://paste.lisp.org/display/97233

[13:58] *** M_o_C left
[13:58] <TimToady> takadonet: no, not yet; I think writing a debugger for parrot would involve several yaks.

[13:58] <colomon> hey guys, I'm running around doing moving stuff for the next bit, but I got this far before I got distracted.  This doesn't handle the new modifiers, but should do a pretty good job of handling the basic we handle now...  (untested)

[13:59] <takadonet> TimToady:indeed

[13:59] <moritz_> colomon: will take a closer look soon

[14:00] <TimToady> in particular, being able to backmap reliably from bytecode position to source code position

[14:00] *** wormwood_ joined
[14:01] <jnthn> TimToady: The sad bit is that for a little while that actually worked reasonably. :-(

[14:01] <moritz_> jnthn: it seems the parrot folks are willing to work on the annotation stuff if they get a test case

[14:01] <jnthn> Evidently I didn't write sufficient tests to make sure it kept working...was sure I'd written some though.

[14:01] <TimToady> "reliably" :/

[14:02] <jnthn> moritz_: Yeah, I'll have to look at how the tests I wrote last time around are and perhaps just add to those.

[14:02] <TimToady> not sure the parrot introspection is up to snuff either

[14:02] <TimToady> (for a debugger)

[14:03] *** wormwood left
[14:03] * jnthn longs for the day that Rakudo has a .Net backend and he can debug Perl 6 in Visual Studio...

[14:03] <TimToady> and you have to have better resolution of position than just line level

[14:03] <TimToady> since you can have multiple statements on a line

[14:04] <jnthn> TimToady: Yeah, the Parrot one can in theory handle column as weel

[14:04] <jnthn> It's a general purpose bytecode annotaation system

[14:04] <jnthn> Rather than just line and file.

[14:04] <jnthn> You can stash all kinds in there.

[14:04] *** arnsholt left
[14:04] <TimToady> all you really need is file and position in file

[14:05] <TimToady> line/column should be derivable from that

[14:05] <jnthn> True.

[14:05] <TimToady> however you care to define "line" and "column"

[14:05] <TimToady> two users can, in fact, have different definitions

[14:05] *** broquain1 is now known as broquaint

[14:06] <TimToady> depending on how their editor counts them

[14:06] <TimToady> but position is basic

[14:06] <TimToady> assuming, of course, a reasonable definition of position :)

[14:07] <TimToady> STD currently assumes precanonicalized Unicode, and positions of codepoints, as unpacked by "U* in p5

[14:08] <TimToady> er, "U*"

[14:09] <TimToady> anyway, STD doesn't track line numbers at all, it merely calls .lineof to get the actual line of a position when it needs to print a line number

[14:09] <TimToady> seems to work out very well in practice

[14:10] <TimToady> and it's *so* easy to miss a line transition while parsing

[14:14] <PerlJam> TimToady: and .lineof rescans counting newlines?

[14:15] <TimToady> no, just builds the table once on first use

[14:15] <TimToady> doesn't take very long

[14:17] <jnthn> ooh, time for a train change soon.

[14:17] <jnthn> back later

[14:18] *** pyrimidine joined
[14:18] <TimToady> presumably if someone's editor uses a different line number scheme, that can be taken into account in .lineof

[14:19] <TimToady> .u paragraph

[14:19] <phenny> U+2029 PARAGRAPH SEPARATOR ( )

[14:19] *** astrojp joined
[14:19] <TimToady> that's almost certainly another line from the user's point of view, but I'll bet neither vim nor emacs thinks so

[14:20] *** justatheory joined
[14:21] <TimToady> yes, vim renders it as a space.  :)

[14:22] *** wknight8111 left
[14:26] <moritz_> rakudo: say [+] 4..445

[14:26] <p6eval> rakudo dd2043: OUTPUT«99229␤»

[14:26] *** wormwood joined
[14:27] <moritz_> I've implemented that in O(1) in rakudo locally, but I'm not sure if my multi is actually called :-)

[14:29] *** wormwood_ left
[14:30] <moritz_> hm, it's not :(

[14:32] *** jaldhar left
[14:35] *** nihiliad joined
[14:51] *** molaf joined
[14:52] *** REPLeffect joined
[14:56] <diakopter> rakudo: say || ()

[14:56] <p6eval> rakudo dd2043: OUTPUT«␤»

[14:59] *** kcwu_ left
[14:59] *** mberends joined
[15:02] *** kcwu joined
[15:02] *** jaldhar joined
[15:04] <colomon> moritz_: did you get a chance to look at that code?

[15:04] <TimToady> std: my $a; CHECK { $a = 42 }'

[15:04] <p6eval> std 30269: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing punctuation (semicolon or comma?) after block at /tmp/7poTgRn7qh line 1:␤------> [32mmy $a; CHECK { $a = 42 }[33m⏏[31m'[0m␤    expecting any of:␤   POST␤   bracketed infix␤    horizontal whitespace␤    infix or meta-infix␤      postfix␤  

[15:04] <p6eval> ..     postfix_prefix_me…

[15:04] <TimToady> hmm

[15:05] <TimToady> another one of those SLTA messages that probably isn't worth fixing

[15:06] <diakopter> S[lightly|uper]

[15:06] *** molaf left
[15:10] <TimToady> slightly in this case

[15:11] <TimToady> an extra ' right there is not the usual failure mode in the typical program

[15:14] <TimToady> in a sense, the syntax error occurs before it ever tries to parse the ' as a term

[15:15] <TimToady> because the check to see if there's more on the line after }, and whether it's a valid continuation, is a lookahead from the }

[15:15] *** arthur-_ joined
[15:15] <PerlJam> The error message is awesome-enough for now I think :)

[15:15] <TimToady> "something there, I don't recognize it, therefore there should have been punctuation"

[15:16] <diakopter> std: my $a; CHECK { $a = 42 }{}

[15:16] <p6eval> std 30269: OUTPUT«ok 00:01 107m␤»

[15:16] <diakopter> subscript

[15:16] <TimToady> postfixes

[15:17] <TimToady> std: my $a CHECK { $a = 42}.foo

[15:17] <p6eval> std 30269: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/68K3fpdpBj line 1:␤------> [32mmy $a [33m⏏[31mCHECK { $a = 42}.foo[0m␤    expecting any of:␤     bracketed infix␤  infix or meta-infix␤      statement modifier loop␤  trait␤FAILED 00:01 107m␤»

[15:17] <TimToady> hmm, or not...

[15:17] <TimToady> oh

[15:17] <TimToady> duh

[15:17] <PerlJam> heh

[15:17] <TimToady> std: my $a; CHECK { $a = 42}.foo

[15:17] <p6eval> std 30269: OUTPUT«ok 00:01 107m␤»

[15:17] <PerlJam> those pesky semis

[15:22] *** snarkyboojum left
[15:27] *** lichtkind joined
[15:28] <lichtkind> jnthn: thanks i found out that prompt works exactly like ask, si i will make an alias

[15:28] <lichtkind> since i think ask is a much nicer name and shorter

[15:28] <lichtkind> and fits better to say

[15:33] *** arnsholt joined
[15:34] *** jhuni left
[15:35] *** ash_ joined
[15:36] *** M_o_C joined
[15:38] <pmurias> ruoso: ping

[15:44] *** Jedai joined
[15:50] <moritz_> colomon: notreally

[15:53] <ash_> http://www.youtube.com/watch?v=jl9HVEJl_-w is an interesting video, its a visualization of the commits to perl, the beginning is funny how larry is the one running around all the branches and so many others come and go 

[15:56] *** iblechbot joined
[16:00] *** ggoebel joined
[16:07] *** cotto_work left
[16:07] *** cotto_work joined
[16:08] *** mikehh joined
[16:08] <colomon> moritz_: okay, I'm working on it in bits and pieces between running out on errands.  :)

[16:20] *** arthur-_ left
[16:23] *** opx^on joined
[16:24] *** xinming left
[16:24] *** riffraff left
[16:26] *** jaldhar left
[16:27] <pugssvn> r30270 | lwall++ | [STD] SMA message on strange stuff after block error 

[16:29] <jaffa4> hi

[16:30] <jaffa4> Are regular expressions implemented in Perl 6 fully?

[16:30] <jaffa4> I mean the library behind the regular expressions.

[16:30] <moritz_> jaffa4: stop asking questions to which you should long know the answer

[16:30] <jaffa4> I mean the library behind it.

[16:30] <jaffa4> l i b r a r y

[16:32] *** xinming joined
[16:32] <jaffa4> I know it does not work fully in rakudo

[16:32] <jaffa4> I am not asking that

[16:32] <jaffa4> I guess there must be functions that are called when a regular expression is met in a perl 6 code.

[16:33] <ash_> the regex stuff in perl 6 is written in nqp 

[16:33] <ash_> s/perl 6/rakudo/

[16:35] <jaffa4> and where is it?

[16:35] <arnsholt> NQP lives on GitHub

[16:36] <jaffa4> where is the regex stuff?

[16:36] <moritz_> hugme: show nqp-rx

[16:36] <arnsholt> In NQP.

[16:36] <hugme> moritz_: the following people have power over 'nqp-rx': PerlJam, TimToady, [particle], jnthn, masak, moritz_, pmichaud. URL: http://github.com/perl6/nqp-rx/

[16:36] <ash_> you mean the implementation? under src/Regex 

[16:36] <ash_> its written in pir 

[16:36] <jaffa4> yes, the implementation

[16:37] <arnsholt> There's also some interesting code in src/cheats

[16:37] <jaffa4> did you not write it is writen in nqp?

[16:38] <ash_> well, parts of nqp are in nqp and other parts are in pir, it depends on which parts your looking for 

[16:38] <ash_> for instance the Cursor is in pir, but the grammar is in nqp 

[16:38] <arnsholt> NQP was started by pmichaud originally (I think). The list of people above are those who now have commitbits to it

[16:39] <moritz_> arnsholt: not quite - it's those who have permissions on hugme to add new contributors

[16:39] <arnsholt> Oh, right. Important difference, that

[16:42] *** hercynium joined
[16:47] *** Sanitoeter_ joined
[16:48] *** prism is now known as daemon

[16:49] *** Sanitoeter_ is now known as `Sanitoeter

[16:50] *** xinming left
[16:53] *** wormwood left
[16:55] <moritz_> std: /<[...b]>/

[16:55] <p6eval> std 30269: OUTPUT«ok 00:01 109m␤»

[16:55] <moritz_> rakudo: say 'b' ~~ /<[...b]>/

[16:55] <p6eval> rakudo dd2043: OUTPUT«b␤»

[16:55] *** riffraff joined
[16:57] *** Sanitoeter left
[17:00] <ash_> does ...b mean like Mu ... b ? or something

[17:01] *** jaldhar joined
[17:03] <moritz_> . .. .

[17:03] <moritz_> erm

[17:03] <moritz_> . .. b

[17:05] <pugssvn> r30271 | moritz++ | [t/spec] test for RT #64220, strange error for <[...b]> 

[17:06] <takadonet> hmmm trans is not fix yet....

[17:06] <ash_> ah, thats confusing, i was expecting ... to match the ... operator (i was kinda assuming longest token matching, but i guess thats not a token in regexs) 

[17:06] <moritz_> std: List

[17:06] <p6eval> std 30270: OUTPUT«ok 00:01 108m␤»

[17:06] *** payload joined
[17:06] <colomon> pugs: say [**] 1..4

[17:06] <p6eval> pugs: OUTPUT«1␤»

[17:07] <colomon> pugs: say [**] 2..5

[17:07] <p6eval> pugs: OUTPUT«Inf␤»

[17:07] <takadonet> rakudo: "beer\n4\nme".trans(/\n/ => '')

[17:07] <p6eval> rakudo dd2043: OUTPUT«too few positional arguments: 2 passed, 3 (or more) expected␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:07] <colomon> pugs: say [**] 2..4

[17:07] <p6eval> pugs: OUTPUT«2417851639229258349412352␤»

[17:07] <colomon> pugs: say (2 ** 3) ** 4

[17:07] <p6eval> pugs: OUTPUT«4096␤»

[17:08] <colomon> pugs: say 2 ** (3 ** 4)

[17:08] <p6eval> pugs: OUTPUT«2417851639229258349412352␤»

[17:09] <colomon> > say reducewith(&infix:<**>, (2, 3, 4));

[17:09] <colomon> 4096

[17:09] <colomon> > say reducewith(&infix:<**>, (2, 3, 4), :right-assoc);

[17:09] <colomon> 2.41785163922926e+24

[17:09] <takadonet> rakudo: say "beer\n4\nme".trans(/\n/,'')

[17:09] <p6eval> rakudo dd2043: OUTPUT«beer␤4␤me␤»

[17:10] <TimToady> ash_: and if it were a token in regexes, it wouldn't necessarily be a token in character classes

[17:10] <ash_> oh, character classes have their own set of tokens? 

[17:10] <TimToady> the token set depends on which sublanguage you're in

[17:11] <ash_> i didn't realize character classes were another sublanguage 

[17:11] <TimToady> well, of course they do, even in any other regex language

[17:11] <pugssvn> r30272 | moritz++ | [t/spec] test for RT #71086, .kv within class Parcel does not work 

[17:11] *** molaf joined
[17:12] <TimToady> if you say [a-z] in old fashioned regexes, the - is special in that sublanguage; a - doesn't mean anything in normal regex

[17:12] <pugssvn> r30273 | moritz++ | [t/spec] label test appropriately 

[17:13] <TimToady> and * is a token outside, but not inside

[17:14] <ash_> hmm, i wasn't thinking of it like that, i just figured you could contextually tell if you were inside a [ ] that - was a range operator, but it does make more sense to consider it a sublanguage than a contextual thing

[17:14] <takadonet> rakudo: say "beer\n4\nme".trans(/\n/,'')

[17:14] <p6eval> rakudo dd2043: OUTPUT«beer␤4␤me␤»

[17:14] <takadonet> rakudo: "beer\n4\nme".trans(/\n/ => '')

[17:14] <p6eval> rakudo dd2043: OUTPUT«too few positional arguments: 2 passed, 3 (or more) expected␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:14] <TimToady> sublanguages *are* context

[17:14] <takadonet> Are both format allowed?

[17:14] *** `Sanitoeter left
[17:15] <takadonet> Second did work before the ng merge

[17:15] <moritz_> I think .trans hasn't been ported yet, and it defaults to the parrot .trans method

[17:15] *** Sanitoeter_ joined
[17:15] <TimToady> one could take the stronger view that all context is your current language, too

[17:16] <takadonet> mortiz_: so that why the first version works? Since it's using parrot .trans

[17:16] <moritz_> takadonet: at least that's my interpretation

[17:17] <TimToady> rakudo: say ' ' ~~ /<[! .. ~]>/

[17:17] <p6eval> rakudo dd2043: OUTPUT«␤»

[17:17] <TimToady> rakudo: say '!' ~~ /<[! .. ~]>/

[17:17] <p6eval> rakudo dd2043: OUTPUT«!␤»

[17:17] <ash_> TimToady: yeah, that makes sense, i was thinking more that a context wasn't a sublanguage since its rules might only vaguely differ from its parent language, but it makes more sense to view them as individual languages 

[17:17] <TimToady> rakudo: say '~' ~~ /<[! .. ~]>/

[17:17] <p6eval> rakudo dd2043: OUTPUT«~␤»

[17:17] <takadonet> mortiz_: time to get my hands a little dirty in rakudo guts. Can you point in a general direction to get .trans into master branch please ? :)

[17:17] <TimToady> rakudo: say '~' ~~ /<[. .. .]>/

[17:17] <p6eval> rakudo dd2043: OUTPUT«␤»

[17:17] <TimToady> rakudo: say '.' ~~ /<[. .. .]>/

[17:17] <ash_> rakudo: say '!' .. '~';

[17:18] <p6eval> rakudo dd2043: OUTPUT«.␤»

[17:18] <p6eval> rakudo dd2043:  ( no output )

[17:18] <ash_> is there anything between '!' and '~' ? 

[17:18] <TimToady> string ranges are different from character ranges

[17:19] <ash_> ah, dang, the nuances 

[17:19] <TimToady> you can't increment ! and get to ~

[17:19] <TimToady> (in strings)

[17:20] <TimToady> because strings do "carry"

[17:20] *** Sanitoeter_ left
[17:21] <TimToady> a character range is really an integer range in disguise

[17:21] <ash_> so how would the character class define the range !..~ 

[17:21] <ash_> i see

[17:22] <ash_> makes sense, but i don't see why .. for a string couldn't attempt the same thing, although that might not be what you'd expect from a string i suppose

[17:22] <TimToady> rakudo: say (ord('!') .. ord('~')).map: *.chr

[17:22] <p6eval> rakudo dd2043: OUTPUT«invoke() not implemented in class 'String'␤current instr.: 'perl6;Code;signature' pc 13159 (src/builtins/Str.pir:115)␤»

[17:22] <TimToady> rakudo: say (ord('!') .. ord('~')).map: {.chr}

[17:22] <p6eval> rakudo dd2043: OUTPUT«!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~␤»

[17:22] <TimToady> like that

[17:22] *** kaare joined
[17:22] <TimToady> rakudo: say 'a'..'zz'

[17:22] <p6eval> rakudo dd2043:

[17:22] <p6eval> ..OUTPUT«abcdefghijklmnopqrstuvwxyzaaabacadaeafagahaiajakalamanaoapaqarasatauavawaxayazbabbbcbdbebfbgbhbibjbkblbmbnbobpbqbrbsbtbubvbwbxbybzcacbcccdcecfcgchcicjckclcmcncocpcqcrcsctcucvcwcxcyczdadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzeaebecedeeefegeheiejekelemeneoepeqereseteuevewex…

[17:23] <TimToady> not if you expect that

[17:23] *** kaare is now known as Guest50464

[17:23] <TimToady> that's "carry"

[17:23] <ash_> true, i wasn't thinking of that case... 

[17:23] <ash_> your right, you could always treat your string as an integer, and do it that way

[17:23] <TimToady> but carry doesn't make sense for individual characters, since <[]> are just character sets

[17:24] <ash_> ya, not full strings, just the characters themselves 

[17:24] <TimToady> so it dwym, if ym the right thing :)

[17:24] <ash_> TimToady: is http://github.com/ashgti/nq-nqp-rx/blob/master/docs/Object%20Meta-model%20Map.png roughly correct? in a vauge ish sorta way

[17:25] *** xinming joined
[17:25] *** Sanitoeter_ joined
[17:26] <TimToady> I have no idea what some of your lines mean

[17:26] <TimToady> what does the line between lexical stash and class instance mean?

[17:26] <ash_> yeah, me either, i am trying to figure some of that out, what i was thinking was if you looked up (for instance) "Mu" it would check the lexical scope, right? then travese up the OUTER's till it finds a match

[17:27] <ash_> It would be a lexical value, like my $a, where '$a' is defined in the current lexical scope 

[17:27] *** payload left
[17:27] *** mikehh left
[17:27] <ash_> i think i might be mixing terms up here, but the CurLex stash should contain the lexically scoped variables 

[17:27] *** payload joined
[17:28] <TimToady> how is that different from the lexical stash on the left?

[17:28] <ash_> the left diagram is more the general case, the right diagram i was trying to match to what it might be in an instance (like "my $a;" since it should default to Any, and be a lexical value) 

[17:29] <ash_> well, i guess i didn't show it right, but the current stash should have a pointer to OUTER, so you can go form the current lexical scope all the way to the outermost scope 

[17:30] *** Guest50464 left
[17:30] *** payload left
[17:31] <TimToady> not sure what your Anys and colons mean either

[17:31] *** payload joined
[17:31] *** Sanitoeter_ is now known as `Sanitoeter

[17:31] <TimToady> the Any has a WHAT too

[17:32] <TimToady> rakudo: say Any.WHAT

[17:32] <ash_> $a : Any means $a is an instance of many, the Any : ClassHOW sould probably be AnyHOW : ClassHOW, i guess, or maybe not... 

[17:32] <p6eval> rakudo dd2043: OUTPUT«Any()␤»

[17:32] *** payload left
[17:32] <ash_> does that  .WHAT refer to itself?

[17:32] <TimToady> in that case, yes

[17:32] *** payload joined
[17:32] <TimToady> .WHAT always gets you the type object, even from the type object itself

[17:33] <ash_> k, so, with class instances, .WHAT refers to itself, that makes sense 

[17:33] <TimToady> $a just has extra stuff and is defined

[17:33] <ash_> should any two instances return the same .WHAT ? 

[17:33] <TimToady> only if they are of the same type

[17:34] <TimToady> WHAT is the nominal type

[17:34] <ash_> so, my $a; my $b; $a.WHAT =:= $b.WHAT =:= Any.WHAT? 

[17:34] <TimToady> HOW has nothing to do with that, only with behavior

[17:34] <TimToady> which is why it's called HOW, after all

[17:34] *** envi^home left
[17:34] <ash_> yeah, that makes sense 

[17:35] <TimToady> rakudo: my $a; my $b; say $a.WHAT =:= $b.WHAT =:= Any.WHAT

[17:35] <p6eval> rakudo dd2043: OUTPUT«1␤»

[17:35] *** cotto_work left
[17:35] <TimToady> but those are types of the initial contents, not of the container

[17:35] <jnthn> oh hai

[17:35] <TimToady> O/  <-- swelled head

[17:36] <TimToady> rakudo: my $a; say VAR($a).WHAT

[17:36] <p6eval> rakudo dd2043: OUTPUT«Could not find sub &VAR␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:36] <TimToady> alpha: my $a; say VAR($a).WHAT

[17:36] <p6eval> alpha 30e0ed: OUTPUT«Method 'WHAT' not found for invocant of class 'MutableVAR'␤in Main (file src/gen_setting.pm, line 324)␤»

[17:36] <TimToady> pugs: my $a; say VAR($a).WHAT

[17:36] <p6eval> pugs: OUTPUT«Scalar␤»

[17:37] <TimToady> pugs: my @a; say VAR(@a).WHAT

[17:37] <p6eval> pugs: OUTPUT«Array␤»

[17:37] <ash_> I am not sure what you mean, TimToady... 

[17:37] <TimToady> the type of $a is Scalar, not Any

[17:37] <ash_> ah

[17:37] <TimToady> the type of the contents of $a is Any

[17:38] <TimToady> scalar vars always like to deref themselves though

[17:38] <ash_> oooo, i see now, yeah, that makes sense, i was thinking of the '$a' as an alias to an object, not as a container 

[17:38] <TimToady> unlike arrays

[17:38] <jnthn> nqp: my $a = 42; say "the answer is $a";

[17:38] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " 42; say \""␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[17:38] <bkeeler> Morning, #p6

[17:38] <jnthn> nqp: my $a := 42; say "the answer is $a";

[17:38] <p6eval> nqp: OUTPUT«Confused at line 1, near "say \"the a"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[17:38] <jnthn> nqp: my $a := 42; say("the answer is $a");

[17:38] <p6eval> nqp: OUTPUT«the answer is 42␤»

[17:38] <jnthn> nqp: my $a := 42; say("the answer is \$a");

[17:38] <p6eval> nqp: OUTPUT«the answer is \42␤»

[17:38] *** `Sanitoeter is now known as Sanitoeter

[17:38] <jnthn> nqp: my @a; @a.push(1); say("the answer is @a[0]");

[17:38] <p6eval> nqp: OUTPUT«the answer is @a[0]␤»

[17:38] <TimToady> pugs: my $a = 42; say $a.WHAT, ' ', VAR($a).WHAT

[17:38] <p6eval> pugs: OUTPUT«Int Int␤»

[17:39] <ash_> hmm, well then i need to re-approach some of my current work then, i think 

[17:39] <TimToady> hmm, I think pugs is wrong on that last one

[17:39] *** elmex left
[17:40] <ash_> so, the container acts as a forwarder sorta, right? since when you do $a.perl its not going to call Scalar's .perl, its going to call whatever is in $a's .perl 

[17:40] <TimToady> std: my $a; CHECK { $a = 42}'

[17:40] <p6eval> std 30273: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/Zow8yy3cwo line 1:␤------> [32mmy $a; CHECK { $a = 42}[33m⏏[31m'[0m␤    expecting any of:␤     POST␤   bracketed infix␤    horizontal whitespace␤    infix or meta-infix␤

[17:40] <p6eval> ..     postfix␤        pos…

[17:41] <TimToady> yes, most methods forward

[17:41] <TimToady> some things that look like methods may be macros really

[17:41] <TimToady> like .HOW

[17:41] <ash_> yeah

[17:42] *** Sanitoeter is now known as `Sanitoeter

[17:43] <TimToady> rakudo: say 42.HOW === 43.HOW

[17:43] <p6eval> rakudo dd2043: OUTPUT«1␤»

[17:43] <TimToady> rakudo: say 42.HOW === 'lue'.HOW

[17:43] <p6eval> rakudo dd2043: OUTPUT«0␤»

[17:44] <TimToady> rakudo: my $x = 1; say $x.HOW === 1.HOW

[17:44] <p6eval> rakudo dd2043: OUTPUT«1␤»

[17:44] <TimToady> but even there, you get the autoderef

[17:44] <TimToady> that's why we need VAR($x) if we really want to talk about the variable object

[17:46] <ash_> so,  for instance, my $a; would make a container called "$a" and add it to the lexical scope, that would have an internal value of Any 

[17:47] <TimToady> alpha: my $x; say VAR($x) === VAR($x)

[17:47] <p6eval> alpha 30e0ed: OUTPUT«Method 'HOW' not found for invocant of class 'MutableVAR'␤in Main (file src/gen_setting.pm, line 324)␤»

[17:47] <TimToady> might also have a type constraint of Any, which stays, even if the contents changes to some other type of object

[17:48] <TimToady> rakudo: my Any $x = 1; say $x.WHAT

[17:48] <p6eval> rakudo dd2043: OUTPUT«Int()␤»

[17:48] *** `Sanitoeter is now known as Sanitoeter

[17:48] <TimToady> rakudo: my Any $x = 1; $x = Mu;

[17:48] <p6eval> rakudo dd2043: OUTPUT«Type check failed for assignment␤current instr.: '&die' pc 17192 (src/builtins/Junction.pir:399)␤»

[17:48] <ash_> yeah, that makes sense, the constraint hangs around 

[17:48] <TimToady> rakudo: my Any $x = 1; $x = 'lue';

[17:48] <p6eval> rakudo dd2043:  ( no output )

[17:48] <TimToady> rakudo: my Any $x = 1; $x = 'lue'; say $x

[17:48] <p6eval> rakudo dd2043: OUTPUT«lue␤»

[17:49] <TimToady> you see the constraint is still Any, not Int

[17:50] <TimToady> the type on a variable is essentially just a smartmatcher

[17:50] <ash_> yeah, i see that, i'll have to look at how to implement a container in my program 

[17:50] <TimToady> biab &

[17:51] <ash_> rakudo: say Scalar;

[17:52] <p6eval> rakudo dd2043: OUTPUT«Could not find sub &Scalar␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:52] *** elmex joined
[17:52] <ash_> i guess in rakudo there isn't access to the scalar container currently 

[17:53] <moritz_> rakudo: say VAR(my $x)

[17:53] <p6eval> rakudo dd2043: OUTPUT«Could not find sub &VAR␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:55] *** proller left
[17:56] *** bbkr left
[18:01] *** cotto_work joined
[18:02] <ash_> lunch & 

[18:02] *** ash_ left
[18:06] *** wknight8111 joined
[18:09] *** SmokeMachine joined
[18:09] *** mikehh joined
[18:11] <moritz_> rakudo: class A { has $!b; method x { say (:$!b).perl } }; A.new(b => 3).x

[18:11] <p6eval> rakudo dd2043: OUTPUT«Symbol '$!b' not predeclared in x␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[18:11] <colomon> integration/99problems-01-to-10.t crashing in my spec test....

[18:11] <moritz_> :(

[18:11] <moritz_> what's wrong with it

[18:12] <lisppaste3> colomon pasted "crash" at http://paste.lisp.org/display/97243

[18:13] <moritz_> colomon: looks like one instance of *-1 needs to be fudged out

[18:13] <colomon> what changes today would have triggered that?!

[18:13] <moritz_> it's new in spectest.data

[18:13] <moritz_> I added it a few hours ago

[18:14] <colomon> ah

[18:15] <moritz_> I don't understand why it fails for you, and passes for me

[18:15] <moritz_> colomon: did you svn up?

[18:15] <colomon> integration/99problems-11-to-20.t seems to be in an endless loop or something...

[18:16] <colomon> r30273

[18:16] <moritz_> oooh, I forgot to svn dcommit

[18:16] <pugssvn> r30274 | moritz++ | [t/spec] fudge some integration tests for rakudo 

[18:16] <moritz_> my fault

[18:17] <colomon> no worries

[18:19] <colomon> I'm glad you're getting those tsets going

[18:20] <colomon> *tests

[18:24] <pyrimidine> colomon: I saw the same thing (infinite loop on 99problems-11-to-20.t) 

[18:24] <moritz_> pyrimidine: should now be fixed by 'svn up'

[18:25] <colomon> pyrimidine:  believe moritz_ just checked in the fix

[18:25] <pyrimidine> ok, updating...

[18:28] *** wknight8111 left
[18:33] <colomon> gack, going to run out of battery before spectest finishes....

[18:35] <moritz_> then don't spectest :-)

[18:36] <TimToady> I prefer plugging in to not running spectests...

[18:37] <TimToady> perhaps colomon is living in one of those benighted parts of the world where only aristocrats are allowed to have power

[18:37] <colomon> sleeping boy on lap, power cord in other room

[18:38] <TimToady> it's the boy that's benighted then.  :)

[18:38] * pyrimidine running spectest now as well...

[18:38] <colomon> done! 

[18:38] <colomon> and pushed

[18:41] <dalek> rakudo: 8f35ce2 | (Solomon Foster)++ | src/core/metaops.pm:

[18:41] <dalek> rakudo: Add new reducewith sub intended to be the backend for [op] (though that is not wired up yet).

[18:41] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8f35ce29e93a779c8f791fc80011ea7477451161

[18:44] <pyrimidine> only saw on fail, same one I've been seeing intermittently (on S12-methods/instance.rakudo)

[18:44] <pyrimidine> *one

[18:44] * moritz_ has seen that too

[18:45] <TimToady> std: 3 !!= 4

[18:45] <p6eval> std 30274: OUTPUT«[31m===[0mSORRY![31m===[0m␤Ternary !! seems to be missing its ?? at /tmp/jAUGxap574 line 1:␤------> [32m3 !![33m⏏[31m= 4[0m␤FAILED 00:01 108m␤»

[18:45] <TimToady> kinda the wrong message, but it's supposed to blow up

[18:45] <colomon> rakudo: 3 !!= 4

[18:45] <p6eval> rakudo dd2043:  ( no output )

[18:45] *** colomon left
[18:46] <TimToady> according to S03:3965

[18:46] <TimToady> std: 3 ![!=] 4

[18:46] <p6eval> std 30274: OUTPUT«ok 00:01 106m␤»

[18:46] <TimToady> that's fine though

[18:48] *** riffraff left
[18:49] *** colomon joined
[18:50] <colomon> he woke up about 30 seconds after the machine shut down, so we've relocated to the living room and the MBP is plugged in.  :)

[18:52] <colomon> rakudo: say 3 !!= 4

[18:52] <p6eval> rakudo dd2043: OUTPUT«0␤»

[18:52] <colomon> rakudo: say 3 != 4

[18:52] <p6eval> rakudo dd2043: OUTPUT«1␤»

[18:52] <colomon> rakudo: say 3 !!!!!!!= 4

[18:52] <p6eval> rakudo dd2043: OUTPUT«1␤»

[18:52] <colomon> rakudo: say 3 !!!!!!!!= 4

[18:52] <p6eval> rakudo dd2043: OUTPUT«0␤»

[18:52] <colomon> perhaps that's overkill... ;)

[18:52] <moritz_> std: 1 !!!!= 3

[18:52] <p6eval> std 30274: OUTPUT«[31m===[0mSORRY![31m===[0m␤Ternary !! seems to be missing its ?? at /tmp/L6BZ77s1V3 line 1:␤------> [32m1 !![33m⏏[31m!!= 3[0m␤FAILED 00:01 106m␤»

[18:52] *** ShaneC joined
[18:53] * colomon is still irrationally pleased that works...

[18:53] <moritz_> maybe !== is not iffy enough :-)

[18:53] *** ShaneC left
[18:55] *** M_o_C left
[18:56] <moritz_> std: [\==] 1, 2, 3

[18:56] <p6eval> std 30274: OUTPUT«ok 00:01 107m␤»

[18:56] <colomon> rakudo: say 3 !!!!!!!!== 4

[18:56] <p6eval> rakudo dd2043: OUTPUT«0␤»

[18:58] <dalek> rakudo: 0ccaf6c | moritz++ | src/core/metaops.pm:

[18:58] <dalek> rakudo: implement :$chaining in reducewith()

[18:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0ccaf6c4ddaef2100bad6fe013a3bcd1825b3dc2

[18:58] <colomon> moritz_++

[18:58] <pugssvn> r30275 | lwall++ | [STD] Be more forthright on !!op prohibition. 

[18:58] *** ash_ joined
[18:59] <colomon> re r30275: awwww....

[18:59] <sorear> TimToady: In Pod6, is it possible to interleave a long block (say, =begin METHODS) with ambient code?

[18:59] <jnthn> .oO( The prohibition didn't work out too well. )

[19:01] <colomon> .oO(Am I a !!op bootleggger?)

[19:01] *** moritz_ sets mode: +oo colomon sorear

[19:01] <TimToady> sorear: no

[19:02] <TimToady> such things should be accumulated by name, not by structure

[19:03] <moritz_> colomon: some initial tests show that calling reducewith() directly seems to work

[19:04] <TimToady> bbl &

[19:04] <sorear> TimToady: oh, so multiple METHOD blocks are legal and concatenated?

[19:04] <colomon> I forgot we also need the "triangle" versions for reducewith.

[19:04] <moritz_> colomon: not forgot, postponed :-)

[19:05] <colomon> You may have postponed, I just plain forgot.  ;)

[19:05] <colomon> lots of distractions today

[19:09] <moritz_> currently trying triangle

[19:10] <colomon> btw, you appear to have skipped the case where chaining and right-assoc are both turned on.  don't know if that's ever a real issue....

[19:12] <moritz_> aye, doing that now

[19:12] *** rbaumer left
[19:15] <colomon> \o/

[19:15] <moritz_> my current version just doesn't combine triangle with chaining yet

[19:16] * colomon wonders if the spec actually describes that....

[19:17] <moritz_> Triangular reductions of chaining operators always consist of one or

[19:17] <moritz_> more C<True> values followed by 0 or more C<False> values.

[19:17] <moritz_> so yes, should be implemented

[19:18] <dalek> rakudo: bcdee8e | moritz++ | src/core/metaops.pm:

[19:18] <dalek> rakudo: reducewith with triangle; implement combination of chaining and right-assoc

[19:18] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/bcdee8ef256fb2fe0af01466f6b1faff115dce84

[19:19] *** am0c joined
[19:19] <colomon> \o/

[19:20] <moritz_> now it "just" needs to plugged into Actions.pm

[19:21] <jnthn> oh hai

[19:21] <jnthn> :-)

[19:21] * jnthn knows how to do that bit, probably

[19:21] <jnthn> What do we need? Just to detect chaning, \ and right associativity?

[19:21] <colomon> right.

[19:21] <PerlJam> colomon++ moritz++ jnthn++   just reading the scrollback it seems like a little bit of positive synergy going on.

[19:22] * [particle] considers "negative synergy"

[19:22] <jnthn> masak++ and I some stuff coming that fixes 5 (!) bugs.

[19:22] <jnthn> *have some

[19:22] <jnthn> Also, masak++ bakes awesome bread.

[19:22] *** ive joined
[19:22] <colomon> hacking with moritz_++ is fun.  :)

[19:22] <colomon> it's been far too long since we last had the chance. 

[19:24] <PerlJam> [particle]: I suppose the opposite of "synergy" would be "antergy"?

[19:24] <[particle]> you'll have to ask bucky about that

[19:25] <[particle]> hopefully there aren't too many examples of antergy such that it needs a name :)

[19:25] <colomon> btw, masak and jnthn, my wife wanted to know if I could get you guys to ship us some tea.  :)

[19:27] <colomon> apparently she fell in love years ago with a Swedish tea that isn't available hereabouts, and has been trying to figure out how to get more ever since...

[19:28] <jnthn> Got the name of it?

[19:28] <colomon> not on me, but if you're game I'll ask her when she gets home.

[19:28] <colomon> jnthn++

[19:30] <jnthn> I think we're game. :-)

[19:30] * moritz_ hopes it's not hunting season

[19:30] <PerlJam> wabbit season!

[19:30] <colomon> duck season!

[19:30] <PerlJam> :-)

[19:31] <jnthn> lol xx 2

[19:36] <moritz_> who wants to be release manager for the April release? (won't be the Rakudo * release)

[19:41] <dalek> rakudo: eaf92e0 | moritz++ | docs/ChangeLog:

[19:41] <dalek> rakudo: [docs] start ChangeLog for next release

[19:41] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/eaf92e0625f6ab1351335903840168e5e5e0032f

[19:45] <colomon> jnthn: Kobbs tea "Sörgårdste"

[19:46] * colomon hopes that pasted correctly, looks properly Swedish here...

[19:47] *** alester left
[19:48] *** alester joined
[19:49] <Coke-san> colomon: +1

[19:53] <jnthn> looks properly Swedish here too :-)

[19:54] <jnthn> colomon: Ah, masak++ recognizes the name.

[19:56] <moritz_> colomon: do you want to do the April release?

[19:58] <moritz_> in general we're looking for release managers for the next few months

[19:58] <colomon> moritz_: May would be much better for me.  :)

[19:58] <colomon> jnthn: \o/

[19:58] <moritz_> colomon: ok, I'll enter you for May

[19:59] <moritz_> phenny: tell pmichaud that you're noted as release manager for the April release (with questionmark) - should I try to find somebody else for that task?

[19:59] <phenny> moritz_: I'll pass that on when pmichaud is around.

[20:05] <dalek> rakudo: fc30fad | moritz++ | docs/release_guide.pod:

[20:05] <dalek> rakudo: [docs] the Copenhagen release has already happend; colomon++ voluntueered for May

[20:05] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fc30fad47726ea062ba512bbf2b1ed20b8b027eb

[20:06] *** mikehh left
[20:11] <moritz_> rakudo: say Rat.new()

[20:11] <p6eval> rakudo bcdee8:  ( no output )

[20:11] <moritz_> rakudo: say Rat.new().perl

[20:11] <p6eval> rakudo bcdee8: OUTPUT«Any()/Any()␤»

[20:11] <moritz_> any objections to making Rat.new() without args just die?

[20:11] <moritz_> I don't see what good it would do to have it

[20:12] <[particle]> rakudo: say Int.new().perl

[20:12] <p6eval> rakudo bcdee8: OUTPUT«0␤»

[20:12] <[particle]> why isn't Rat.new() 1/1?

[20:12] <jnthn> Well, it's kinda immutable once crated. :-)

[20:12] <[particle]> or 0/1

[20:13] <jnthn> or 0/0

[20:13] <jnthn> ;-) ;-)

[20:13] <[particle]> *nudge* *nudge*

[20:13] <jnthn> Rat.new would just set 0/1, anyways.

[20:13] <moritz_> sound sensible

[20:14] * moritz_ spectests

[20:19] <pugssvn> r30276 | moritz++ | [t/spec] unfudge tests for Rat.new.perl, RT #68958 

[20:22] <dalek> rakudo: cfc139f | moritz++ | src/core/Rat.pm:

[20:22] <dalek> rakudo: trivial Rat.new() without arguments (returns 0/1)

[20:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cfc139f2ec898580f4d8dfbae88d59a59a54d521

[20:23] *** skyler_ joined
[20:23] *** skyler__ left
[20:23] <diakopter> std: blah: goto blah; sub blah() { }

[20:23] <p6eval> std 30275: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of routine 'blah' (see line 1) at /tmp/2gkNuDCu65 line 1:␤------> [32mblah: goto blah; sub blah[33m⏏[31m() { }[0m␤    expecting new name to be defined␤FAILED 00:01 106m␤»

[20:23] <diakopter> TimToady: is that a stdbug?

[20:24] <dalek> nqp-rx: 67a8eaf | jonathan++ | src/Regex/P6Regex/Actions.pm:

[20:24] <dalek> nqp-rx: Correct action methods for \e and \f sequences in regexes.

[20:24] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/67a8eaf07469e5b2dbddaf432542891f9ff9f37a

[20:24] <dalek> nqp-rx: e3f10da | jonathan++ | src/HLL/ (2 files):

[20:24] <dalek> nqp-rx: Add detection of unknown backslash sequences and fix the \$ bug along the way. masak++ too. :-)

[20:24] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/e3f10daae3ea4e2feceabc042ca9a0d241a4d6c3

[20:24] <dalek> nqp-rx: b17415a | jonathan++ | src/HLL/ (2 files):

[20:24] <dalek> nqp-rx: Properly implement \f, \e and \0 escapes in strings.

[20:24] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/b17415a4def6dea00c31baee69bb65399553bc7c

[20:24] <dalek> nqp-rx: 88873ca | jonathan++ | src/stage0/ (3 files):

[20:24] <dalek> nqp-rx: Update the bootstrap.

[20:24] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/88873caed7a79816de7efd1cd2709b89425eb934

[20:24] *** molaf left
[20:24] <diakopter> if not, I didn't realize subs & label namespaces coincided

[20:25] *** kfo_ joined
[20:28] <pmurias> diakopter: subs have a & sigil

[20:28] <jnthn> I suspect stdbug.

[20:29] *** kfo left
[20:29] *** kfo_ is now known as kfo

[20:30] *** [particle] left
[20:30] <diakopter> pmurias: I was referring to the label "blah"

[20:30] <diakopter> std: blah: sub blah() { }

[20:30] <p6eval> std 30276: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of routine 'blah' (see line 1) at /tmp/gDCxGQr2eI line 1:␤------> [32mblah: sub blah[33m⏏[31m() { }[0m␤    expecting new name to be defined␤FAILED 00:01 106m␤»

[20:31] <pmurias> std: sub blah() {};blah: 1

[20:31] <p6eval> std 30276: OUTPUT«ok 00:01 107m␤»

[20:32] <pmurias> diakopter: what i meant is that even if labels and routines shared namespaces blah and &blah shouldn't collide

[20:33] * jnthn sees it like pmurias 

[20:33] <diakopter> oh

[20:33] * diakopter comprehends, finally

[20:34] *** [particle] joined
[20:34] *** [particle] left
[20:34] *** pmurias left
[20:36] <sorear> jnthn++

[20:37] <sorear> jnthn: you ought to fix your parrot U:line

[20:37] <jnthn> U:line?

[20:38] <sorear> look in parrot:CREDITS

[20:38] <sorear> N: Jonathan Worthington

[20:38] <sorear> U: jonathan

[20:38] <jnthn> omgz karma loss!

[20:38] <sorear> also "who's that jonathan guy who keeps committing"

[20:39] <jnthn> Well, my svn handle is jonathan for Parrot svn.

[20:39] <ash_> sorear: i don't think its jnthn, that would be just silly 

[20:39] <jnthn> Yeah, jnthn never commits!

[20:39] <ash_> add a second U? 

[20:44] *** ive left
[20:44] *** ive joined
[20:52] <takadonet> rakudo: say "beer\n4\nme".trans(/\n/,'')

[20:52] <p6eval> rakudo cfc139: OUTPUT«beer␤4␤me␤»

[20:52] <takadonet> rakudo: say "beer\n4\nme".trans(/\n/ =>'')

[20:52] <p6eval> rakudo cfc139: OUTPUT«too few positional arguments: 2 passed, 3 (or more) expected␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:03] <dalek> rakudo: 0893322 | jonathan++ | build/PARROT_REVISION:

[21:03] <dalek> rakudo: Bump PARROT_REVISION to get latest nqp-rx fixes.

[21:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/08933220122b0aa94ac25f95db77fe493794dfca

[21:03] <dalek> rakudo: 50fa7b0 | jonathan++ | t/spectest.data:

[21:03] <dalek> rakudo: Turn S02-literals/fmt-interpolation.t back on.

[21:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/50fa7b06cbbd178723e6bc513dfd425bac106f88

[21:03] * moritz_ wonders if Good Friday was a public holliday in other countries too

[21:06] <m6locks> yes it was

[21:06] <m6locks> but we were prepared :)

[21:07] <pugssvn> r30277 | jnthn++ | [t/spec] Unfudge a few tests that we now pass. 

[21:07] <jnthn> moritz_: Yes, it is here in Sweden too

[21:11] *** payload left
[21:11] *** pyrimidine left
[21:13] <pugssvn> r30278 | jnthn++ | [t/spec] Few more unfudges from rx.t for \e and \f fixes. 

[21:13] <jnthn> The first results and the masak+jnthn easter hackathon!

[21:14] <jnthn> Time for us to go for a walk now. bbiab. :-)

[21:15] <Coke-san> moritz: it's per-company here in the US. I have it off. Whee.

[21:15] <Coke-san> also, moritz++ # nqp help!

[21:26] *** arnsholt left
[21:27] *** cognominal joined
[21:32] *** ash_ left
[21:37] *** [synth] joined
[21:38] *** Su-Shee left
[21:39] *** synth left
[21:41] *** [synth] left
[21:46] <pugssvn> r30279 | lwall++ | [STD] add label as constant rather than type as noticed by diakopter++ 

[21:46] <pugssvn> r30279 | [STD] report EOF correctly now that we no longer add ';' to original text

[21:46] <pugssvn> r30279 | [Cursor] add .label_id method so we can tell labels from other constants

[21:46] <pugssvn> r30279 | [std] add filename to 'ok' for more visibility into sub-compilation by 'use'

[21:46] *** snarkyboojum joined
[21:51] *** eternaleye left
[21:51] *** kolibrie left
[21:51] *** broquaint left
[21:51] *** breinbaas left
[21:51] *** awwaiid left
[21:51] *** TimToady left
[21:51] *** gbacon left
[21:51] *** szbalint left
[21:53] *** eternaleye joined
[21:53] *** kolibrie joined
[21:53] *** Lorn joined
[21:53] *** broquaint joined
[21:53] *** breinbaas joined
[21:53] *** frew joined
[21:53] *** _sri joined
[21:53] *** awwaiid joined
[21:53] *** TimToady joined
[21:53] *** gbacon joined
[21:53] *** szbalint joined
[21:53] *** verne.freenode.net sets mode: +o TimToady

[21:56] <diakopter> aiiiiieeeeee

[21:56] <jnthn> I'm in masak's office, nabbing his pens. ;-)

[21:56] *** masak joined
[21:56] <masak> oh hai, #perl6!

[21:56] <phenny> masak: 12:54Z <snarkyboojum> tell masak not sure if you meant something like this re making the say 'op' go through an object with a .say method? http://gist.github.com/353097

[21:57] <masak> snarkyboojum: it's an excellent commit. next time, favor forgiveness to permission -- you have write access to the Yapsi repo already :)

[21:57] <cognominal> Yapsi?

[21:57] <masak> :)

[21:57] <cognominal> what is that?

[21:58] <masak> colomon: it's a compiler announced on April 1 on p6c.

[21:58] <masak> arg, cognominal.

[21:58] <masak> tab completion fejl.. :/

[21:59] <masak> rakudo: /<[a..\]]>/

[21:59] <p6eval> rakudo 50fa7b: OUTPUT«regex assertion not terminated by angle bracket at line 11, near "]>/"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[21:59] * masak submits rakudobug

[21:59] *** alester left
[21:59] <masak> rakudo: /<[a..\\]>/

[21:59] <p6eval> rakudo 50fa7b: OUTPUT«Confused at line 11, near "/<[a..\\\\]>"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[21:59] <jnthn> std:  /<[a..\]]>/

[21:59] <p6eval> std 30279: OUTPUT«ok 00:01 109m␤»

[21:59] <jnthn> std:  /<[a..\\]>/

[21:59] <p6eval> std 30279: OUTPUT«ok 00:01 107m␤»

[22:00] <masak> it's almost cheating after you've looked at the nqp-rx source :P

[22:00] *** awwaiid left
[22:00] *** awwaiid joined
[22:02] <masak> rakudo: say "e" ~~ /<[a..\e]>/

[22:02] <p6eval> rakudo 50fa7b: OUTPUT«e␤»

[22:02] <masak> same bug. :)

[22:04] *** constant joined
[22:05] <masak> rakudo: say 'foto' ~~ /<-[\t]>+/

[22:05] <p6eval> rakudo 50fa7b: OUTPUT«fo␤»

[22:05] <jnthn> rakudo: my $x = 3; say "foo \$x"

[22:05] <p6eval> rakudo 50fa7b: OUTPUT«foo $x␤»

[22:06] *** lichtkind left
[22:08] *** nihiliad left
[22:10] *** eternaleye left
[22:10] *** kolibrie left
[22:10] *** Lorn left
[22:10] *** broquaint left
[22:10] *** breinbaas left
[22:10] *** _sri left
[22:10] *** TimToady left
[22:10] *** gbacon left
[22:10] *** szbalint left
[22:10] *** frew left
[22:10] *** meppl left
[22:12] *** broquaint joined
[22:12] *** szbalint joined
[22:13] *** _sri joined
[22:16] *** eternaleye joined
[22:16] *** breinbaas joined
[22:16] *** kolibrie joined
[22:16] *** Lorn joined
[22:16] *** frew joined
[22:16] *** TimToady joined
[22:16] *** verne.freenode.net sets mode: +o TimToady

[22:16] *** Sanitoeter left
[22:18] <diakopter> std: blah: sub blah() { }

[22:18] <p6eval> std 30279: OUTPUT«ok 00:01 107m␤»

[22:18] <jnthn> rakudo: foo()

[22:18] <p6eval> rakudo 50fa7b: OUTPUT«Could not find sub &foo␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:18] <pugssvn> r30280 | masak++ | [t/spec/S05-mass] fudged properties-general.t 

[22:20] *** astrojp left
[22:20] *** eternaleye left
[22:20] *** breinbaas left
[22:20] *** kolibrie left
[22:20] *** Lorn left
[22:20] *** TimToady left
[22:20] *** frew left
[22:22] *** arthur-_ joined
[22:22] *** eternaleye joined
[22:22] *** arthur-_ left
[22:22] *** Sanitoeter joined
[22:24] *** TimToady joined
[22:24] *** kolibrie joined
[22:24] *** frew joined
[22:25] <dalek> rakudo: e889ed4 | masak++ | t/spectest.data:

[22:25] <dalek> rakudo: [spectest.data] uncommented two test files

[22:25] <dalek> rakudo: S05-mass/properties-block.t and S05-mass/properties-block.t

[22:25] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/e889ed4ef181d8111d721f31cd0b4a617c1a1665

[22:25] <masak> that's 1264 more tests run, most of them passing, I think.

[22:25] *** ggoebel left
[22:25] <jnthn> We probably just broke 30,000. masak++!

[22:25] * masak spectests

[22:28] <jnthn> rakudo: /foo/i

[22:28] <p6eval> rakudo 50fa7b: OUTPUT«Unsupported use of /i; in Perl 6 please use :i at line 11, near ""␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[22:28] <masak> \o/

[22:28] *** arthur-_ joined
[22:29] <colomon> \o/

[22:30] <colomon> \o/

[22:30] <colomon> \o/

[22:30] <jnthn> colomon: Has you a happy?

[22:30] <masak> are those three happy people?

[22:30] *** breinbaas joined
[22:30] <masak> or the same happy person thrice?

[22:30] <colomon> one very happy person

[22:30] <snarkyboojum> masak: cheers :) consider it commited then

[22:31] <colomon> I didn't think we'd hit 30,000 for another week or more...

[22:31] <masak> snarkyboojum++

[22:31] <snarkyboojum> s/commited/committed/

[22:31] <masak> snarkyboojum: I do have a question and a pondering, however... :)

[22:32] *** breinbaas left
[22:32] <masak> the question has to do with the TODO comment; why couldn't you just use 'say' rather than 'print ... "\n"'?

[22:32] <snarkyboojum> masak: thought you might

[22:33] <snarkyboojum> masak: didn't know how to ;) it thinks I'm referring to the current say sub if I do that I think (expected 2 args, got 1 type error message)

[22:33] <masak> sounds like a bug.

[22:33] *** jaffa4 left
[22:33] <snarkyboojum> ah

[22:33] <snarkyboojum> well how would it work out which say I want to use?

[22:34] *** iblechbot left
[22:34] <masak> rakudo: class A { method say($x) { say $x } }; A.new.say("OH HAI")

[22:34] <p6eval> rakudo 50fa7b: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'perl6;A;say' pc 425 (EVAL_1:190)␤»

[22:34] <snarkyboojum> yeah that sort of thing :)

[22:34] <masak> snarkyboojum: subs are orthogonal to methods.

[22:34] <jnthn> That's...wrong. :|

[22:34] <jnthn> wtf.

[22:34] * masak submits a rakudobug

[22:34] <masak> :)

[22:35] <snarkyboojum> ah - excellent :)

[22:36] *** breinbaas joined
[22:36] <masak> the pondering has to do with making Yapsi::Runtime::IO a class.

[22:36] <masak> might we make it a subtype instead?

[22:36] <diakopter> ISpay

[22:36] <snarkyboojum> yeah.. has similar doubts about it being a class

[22:37] <snarkyboojum> s/has/had

[22:37] <masak> something like subset Yapsi::IO where { .can('say') }

[22:37] <snarkyboojum> masak: sounds cool - didn't know enough to have that exact thought :)

[22:38] <masak> anyway, all that's just details. nice commit! now we can write tests for the runtime!

[22:41] <snarkyboojum> masak: yay! those comments are great - I learn a lot from them :)

[22:44] <pugssvn> r30281 | jnthn++ | [t/spec] Unfudge a test for NoSuch::Class error message. 

[22:48] <dalek> rakudo: 9a20634 | jonathan++ | src/ (2 files):

[22:48] <dalek> rakudo: Make A::B.new in the case that A::B doens't exist emit a message that mentions A::B, not just a null PMC access.

[22:48] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9a20634ae6cf444b432d5b8dce40688a78b461fa

[22:48] <masak> \o/ jnthn++

[22:49] <colomon> \o/

[22:49] <colomon> seems like you guys are on fire today!

[22:50] <lue> O HAI! I have an extinguisher!

[22:50] *** ive left
[22:51] <colomon> lue: no!  let them burn!

[22:51] <colomon> we need their light.

[22:51] <colomon> .oO(metaphor out of control!)

[22:51] <lue> I could use it in a few hours when the big ball of nuclear fusion/fission is not in the sky

[22:51] <jnthn> colomon: Is the new reducewith ready to be wired up?

[22:52] * masak .oO( fired up )

[22:52] <colomon> jnthn: go for it!

[22:52] <colomon> I reckon it still needs some work, but it will be easier to test once it is wired up.

[22:53] <colomon> lue: as I hear it "The sun is a miasma / Of incandescent plasma"

[22:53] <colomon> I get 29080 passing tests here.

[22:54] <lue> I like the nuclear bit. It can scare some people who've heard of Chernobyl :)

[22:55] <colomon> jnthn: also note that you can bind all the parameters but the iterable one.

[22:55] <colomon> assume, curry, whatever.  :)

[22:56] <masak> mmm... curry assumptions.

[22:56] <masak> jnthn: I fixed up http://use.perl.org/~masak/journal/40167 to reflect that you fixed up Rakudo. :)

[22:56] * colomon would like to make triangle reduce lazy...

[22:57] <jnthn> masak: I assume we're going for a curry sometime? ;-)

[22:57] <masak> definitely.

[22:57] *** Schwern joined
[22:57] <jnthn> \o/

[22:57] <masak> maybe not before tomorrow, though :)

[22:57] <jnthn> it's already tomorrow

[22:57] <jnthn> oh, wait...

[22:58] * masak bans jnthn from implementing S32::Temporal :P

[22:58] <jnthn> THANK YOU! :-D

[22:58] <lue> THAT'S MY JOB! :)

[22:58] <masak> that's what you wanted all along, isn't it? :P

[22:59] <jnthn> Actually I wanted somewhere to keep my bike nice and dry...

[22:59] <masak> lue: I was hoping you'd just retro-commit the Temporal module from Perl 6.3.8, released in 2149... :)

[22:59] <masak> talk about bootstrapping the Temporal module :P

[23:00] <lue> I would, but then 6.3.8 would be derived from 6.3.8, and that's not good :/

[23:00] * masak .oO( Art of the Metatemporal Protocol )

[23:01] <lue> I'd have to transfer it through the sub-etha, and reroute it into hyperspace, to try and bypass the laws, but...

[23:03] <lue> I suppose it couldn't hurt. Alright, I'm go

[23:03] *** lue left
[23:05] *** masak left
[23:06] *** masak joined
[23:07] *** lue joined
[23:07] <lue> oh wow. Let's NOT do that!

[23:09] <lue> masak: are you there?

[23:10] <masak> lue: think so.

[23:13] <lue> How to define a Duration object...

[23:13] <masak> I guess it's rooted in two Instants...

[23:14] <lue> the current spec says it's TAI-seconds aware

[23:14] <masak> well, so is Instant.

[23:14] <lue> If you would like a _complete_ revision, I'll define things that can't be implemented :)

[23:15] <jnthn> rakudo: say [<] 1,3,2,4

[23:15] <masak> rakudo: say 2 ** 3 ** 4; say [**] 2, 3, 4

[23:15] <p6eval> rakudo 9a2063: OUTPUT«1␤»

[23:15] <p6eval> rakudo 9a2063: OUTPUT«2.41785163922926e+24␤4096␤»

[23:17] <lue> rakudo: say 2 * 3 ** 4; say 2 ** 3 * 4;

[23:17] <p6eval> rakudo 9a2063: OUTPUT«162␤32␤»

[23:17] <colomon> well, that's two wrong answers.  :(

[23:17] <masak> colomon: jnthn has a nice surprise coming, though :P

[23:18] <colomon> oooooooo

[23:18] <lue> rakudo: say 2 ** (3 ** 4);

[23:18] <p6eval> rakudo 9a2063: OUTPUT«2.41785163922926e+24␤»

[23:19] <lue> rakudo: say (2 ** 3) ** 4;

[23:19] <p6eval> rakudo 9a2063: OUTPUT«4096␤»

[23:19] <lue> that's where it goes wrong :)

[23:20] <colomon> rakudo: say reducewith(&infix:<**>, (2, 3, 4), :right-assoc);

[23:20] <p6eval> rakudo 9a2063: OUTPUT«2.41785163922926e+24␤»

[23:21] *** opx^on is now known as opx^away

[23:28] <lue> for a duration _object_, how would you define what duration it measures? (seconds, minutes, etc.)

[23:28] <dalek> rakudo: 3469ffe | jonathan++ | src/Perl6/ (2 files):

[23:28] <dalek> rakudo: Wire reduce meta op up to use the new reducewith that can handle chaining, triangle form and right-associative ops.

[23:28] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3469ffe042f2b2f749a163cbdb80289120d06a51

[23:29] <masak> lue: well, it's clearly defined in terms of Instants, but if you want to convert it into civil time, it possibly depends on where you are on the globe, and what religion you belong to, etc.

[23:29] <masak> jnthn++!

[23:29] <lue> yes, I'm just wondering how the coder would define the object...

[23:29] <lue> my Duration $something something something

[23:29] <colomon> jnthn++

[23:29] <lue> jnthn++

[23:30] <masak> lue: maybe Duration.new( :from(Instant.new(...)), :to(Instant.new(...)) ) ?

[23:30] *** eternaleye left
[23:32] <lue> my Duration $var = 3 #`(TAI seconds); say $var.Gregorian::Minutes ?

[23:33] *** opx^away is now known as opx^on

[23:33] *** opx^on is now known as opx^away

[23:34] *** Sarten-X left
[23:36] <masak> lue: it's concrete questions such as the ones you're asking that would be nice to answer in order to build a fine Temporal module.

[23:37] <masak> I'm increasingly thinking about going back to First Principles: how would I *like* a Time object to work?

[23:37] <lue> Whoever wrote it just said "This is a doughnut" without describing it

[23:37] <lue> Would you like a revision, or an overhaul? <:)>.evil

[23:38] * masak thinks the spec doesn't say "This is a doughnut" nearly enough :)

[23:38] <jnthn> Is it a sugary one?

[23:38] <masak> it does, however, say "You need a wormhole for that."

[23:39] <masak> jnthn: the S04 and S05 doughnuts are sugary :)

[23:39] <masak> and the S12 one, I s'pose.

[23:39] <lue> is it toruses or torii ?

[23:39] <jnthn> Donoughts have a hole too...I see opportunities for unification here.

[23:39] <masak> lue: 'tori'.

[23:40] <lue> alright

[23:40] <masak> jnthn: "The Grand Spec-Doughnut Unification of 2010"!

[23:40] * lue is quietly rewriting all of Temporal to his own design, toning it down so you have a chance of implementing it :)

[23:43] *** eternaleye joined
[23:43] *** lue left
[23:44] *** lue joined
[23:44] <lue> oh! disconnections are no fun :/

[23:46] <lue> (I much prefer Unix Epoch over TAI...)

[23:46] *** SmokeMachine left
[23:47] <lue> rakudo: say time()

[23:47] <p6eval> rakudo 3469ff: OUTPUT«1270251136.55319␤»

[23:48] <jnthn> http://rt.perl.org/rt3/Ticket/Display.html?id=64968

[23:48] * masak looks

[23:48] <lue> shinky hypertext (looking)

[23:48] <lue> s/shinky/shiny/

[23:48] <lue> rakudo: my $a; say $a.defined

[23:49] <p6eval> rakudo 3469ff: OUTPUT«0␤»

[23:49] <lue> rakudo: my $a=3; say $a.defined

[23:49] <p6eval> rakudo 3469ff: OUTPUT«1␤»

[23:50] <jnthn> std: say (0,0,0,0,0,0) >>+>> ((1,2) xx *)

[23:50] <p6eval> std 30281: OUTPUT«ok 00:01 109m␤»

[23:50] <lue> rakudo: say time()

[23:50] <jnthn> rakudo: say (0,0,0,0,0,0) >>+>> ((1,2) xx *)

[23:50] <p6eval> rakudo 3469ff: OUTPUT«1270251341.38794␤»

[23:50] <p6eval> rakudo 3469ff:  ( no output )

[23:51] <jnthn> colomon: Maybe one for you to look at: (1,2) xx * ain't lazy, it seems

[23:52] <jnthn> (should be)

[23:52] <colomon> jnthn: I actually looked at that a few days ago, and it was a bloodbath.

[23:52] <jnthn> Ouch.

[23:52] <colomon> I will try again at some point, but it was discouraging, to say the least.

[23:52] <colomon> > say [**] 2, 3, 4

[23:52] <colomon> 2.41785163922926e+24

[23:53] <jnthn> rakudo: sub foo(*@data, $bar) { say $bar }; my @data = 1,2,3; foo(@data, 'OH HAI')

[23:53] <p6eval> rakudo 3469ff: OUTPUT«Not enough positional parameters passed; got 2 but expected between 1 and 0␤current instr.: 'foo' pc 250 (EVAL_1:95)␤»

[23:54] *** mikehh joined
[23:56] <snarkyboojum> wowsers - 32190 tests - did I read that correctly? :)

[23:59] <masak> :)

