[00:00] *** simcop2387 left
[00:00] *** simcop2387 joined
[00:14] *** jferrero joined
[00:26] *** ihrd joined
[00:26] *** rgrau` left
[00:27] *** ihrd left
[00:29] <colomon> japhb: no naming conventions for modules yet that I'm aware of.

[00:34] *** lumi left
[00:34] *** lumi joined
[00:35] <japhb> I was thinking either Algorithm::Name or Algorithm::Problem::Name, so in this case: Algorithm::MiniSat, Algorithm::SAT::MiniSat, or Algorithm::Satisfiability::MiniSAT.  The latter construction would work well if there was a parallel space for specialty data structures, such as Structure::BalancedTree::RedBlack or Structure::BVH::Octree.

[00:36] *** payload joined
[00:39] *** pmurias left
[00:41] *** ericholscher joined
[00:41] *** ericholscher left
[01:01] *** meppl joined
[01:01] *** lestrrat is now known as lest_away

[01:03] *** mssm left
[01:05] *** lumi left
[01:07] *** ashizawa joined
[01:07] *** lumi joined
[01:16] *** justatheory left
[01:23] *** bpa joined
[01:25] <japhb> phenny, tell pmichaud Now that we're both back ... we had discussed a couple months ago moving http://gitorious.org/parrot-plumage/parrot-plumage/blobs/master/src/lib/Util.nqp into NQP-rx, possibly with a name change to NQP::Util or somesuch, but that you wanted to think about the details.  What are your current thoughts on this?

[01:25] <phenny> japhb: I'll pass that on when pmichaud is around.

[01:29] *** niros left
[01:31] *** lest_away is now known as lestrrat

[01:34] *** drbean joined
[01:36] *** jferrero left
[01:47] *** araujo left
[01:51] *** Chillance left
[01:54] *** TiMBuS joined
[01:54] *** bpa left
[01:55] *** popo joined
[01:56] *** popo left
[02:01] *** lumi left
[02:01] *** lumi joined
[02:06] *** justatheory joined
[02:08] *** orafu left
[02:09] *** orafu joined
[02:12] *** hitsubunnu joined
[02:13] *** hitsubunnu left
[02:14] *** am0c joined
[02:15] *** am0c left
[02:16] *** FCO left
[02:36] *** orafu left
[02:36] *** orafu joined
[02:37] *** issacclee joined
[02:37] *** meppl left
[02:39] *** issacclee left
[03:27] <japhb> phenny, tell masak What is the current status of proto's installed-modules branch?

[03:27] <phenny> japhb: I'll pass that on when masak is around.

[03:27] <japhb> carlins?

[03:29] <japhb> What is Carlin Bingham's nick here?  He appears to be the most recent proto committer ....

[03:31] *** agentzh joined
[03:35] *** araujo joined
[03:38] *** cotto left
[03:39] <colomon> japhb: I think just carlin.

[03:39] <colomon> I don't think installed-modules is ready for prime-time yet.

[03:40] <japhb> *sigh*

[03:40] <colomon> yeah.

[03:40] <japhb> I just want to see it merged, so I can reasonably import it into Plumage.

[03:41] <colomon> I want to see it working, because I think it would be a huge help getting ng moved over to master smoothly.

[03:41] <japhb> phenny, tell carlin What is the current status of proto's installed-modules branch?  You appear to be the only committer of late ...

[03:41] <phenny> japhb: I'll pass that on when carlin is around.

[03:41] <japhb> colomon, nodnod.  Speaking of which, what's the ng status?

[03:52] *** cotto joined
[03:58] <colomon> japhb: goal is to switch ng to master this Thursday, with a target of passing about 75% as many tests.

[03:59] <colomon> my gut feeling is it takes another week to reach that.

[03:59] <colomon> things have gotten fouled up a bit because we keep refining how to handle lazy lists.

[03:59] <colomon> (the list concept underwent significant revision this week in the spec as a result.)

[04:08] <colomon> still, I think it will be exciting to watch all the check-ins to the ng branch this week -- I expect a lot of progress very quickly.

[04:09] <colomon> afk (off to bed)

[04:17] <japhb> colomon, thanks for the info

[04:25] *** ooops joined
[04:25] *** ooops left
[04:53] *** redicaps joined
[04:54] *** nihiliad left
[05:24] *** diakopter sets mode: -R
 
[05:28] *** diakopter sets mode: +oo japhb Tene

[05:30] *** d4l3k_ left
[05:30] *** dalek joined
[05:31] *** diakopter sets mode: +v dalek

[05:42] <diakopter> every time I port Sprixel back and forth from/to JS to/from C#, it improves.  "I am not making this up."

[06:14] *** agentzh left
[06:28] *** pnate left
[06:30] *** pnate joined
[06:40] *** redicaps left
[06:40] *** redicaps joined
[06:56] *** gfx joined
[06:57] *** pnate2 joined
[07:07] *** Lorn left
[07:09] *** pnate left
[07:10] *** pnate joined
[07:14] *** kaare joined
[07:14] *** justatheory left
[07:15] *** pnate2 left
[07:15] *** kaare is now known as Guest34084

[07:21] *** Lorn joined
[07:30] *** jferrero joined
[07:33] *** Su-Shee joined
[07:33] <Su-Shee> good morning

[07:34] *** Baggiokwok joined
[07:36] *** diakopter sets mode: +o Su-Shee

[07:45] <diakopter> does anyone remember that tweet about the tweet that got erased from the web (including all caches)? I can't find it anywhere.

[07:48] *** pnate2 joined
[07:49] <diakopter> reminds me of that sci-fi book about a book that causes its readers to forget they read it.  funny, I'd forgotten all about it.

[07:58] *** he_ joined
[08:00] *** jonasbn joined
[08:00] *** pnate left
[08:05] *** k23z__ joined
[08:08] <Su-Shee> reminds me of the micro phage in the shockwave rider. ;)

[08:11] <diakopter> Su-Shee: exactly!

[08:11] *** iblechbot joined
[08:12] <Su-Shee> which is one of the best scifi I've ever read. 

[08:16] *** pnate joined
[08:17] *** mssm joined
[08:20] *** meppl joined
[08:21] *** gfx left
[08:23] *** Baggiokwok left
[08:29] *** pnate2 left
[08:37] <diakopter> [More OT]  'Avatar = awesome. I wish the whole world was in 3D.'

[08:37] *** cotto left
[08:40] *** cognominal joined
[08:41] *** blackbart joined
[08:41] *** blackbart left
[08:42] *** k23z__ left
[08:48] *** cotto joined
[08:52] *** Baggiokwok joined
[08:52] *** TiMBuS left
[08:53] *** kloeri__ left
[09:00] *** cognominal left
[09:00] *** cognominal joined
[09:00] *** payload left
[09:01] *** payload joined
[09:02] *** pnate2 joined
[09:05] *** pnate left
[09:09] *** dakkar joined
[09:16] *** cottoo joined
[09:17] *** cotto left
[09:27] *** ejs joined
[09:47] *** xomas_ joined
[10:09] *** redicaps left
[10:11] *** xomas_ is now known as xomas

[10:34] *** drbean left
[10:39] *** Baggiokwok left
[10:43] *** payload left
[10:56] <colomon> diakopter: I got  glasses for the first time two weeks ago.  the effect on my vision is almost exactly like wearing 3D glasses to a movie.  I had completely failed to notice that I wasn't seeing depth properly until I started seeing it again...

[11:07] <mathw> weird

[11:08] <mathw> But I guess it was a bit like when my eyes started to go and I didn't realise that I was *supposed* to be able to see the writing on the blackboard

[11:09] <colomon> I do feel like I perceive depth with the glasses still.

[11:10] <colomon> but when I put them on, everything becomes more delicate and I really see in 3D.

[11:10] <colomon> s/with/without/

[11:10] <colomon> it is weird, but cool

[11:11] <moritz_> good localtime

[11:12] <colomon> morning!

[11:12] *** lumi left
[11:12] *** lumi joined
[11:16] <mathw> colomon: at least there's an improvement to make it worth the effort :)

[11:17] <mathw> hi moritz_ 

[11:17] <colomon> mathw: definitely

[11:17] <moritz_> hi mathw - how are things?

[11:27] <mathw> I'm bored out of my skull

[11:27] <mathw> waiting for a very large program to compile

[11:27] <mathw> and hoping I won't have the urge to throw the computer out of the window when I run it again

[11:27] <mathw> (segmentation faults are not a good way to start the week)

[11:34] *** lestrrat is now known as lest_away

[11:39] *** k23z__ joined
[11:43] *** drbean joined
[12:04] *** payload joined
[12:05] *** k23z__ left
[12:12] *** SmokeMachine joined
[12:33] *** ashizawa left
[12:34] *** Baggiokwok joined
[12:35] *** bluescreen joined
[12:48] *** k23z__ joined
[12:57] *** lest_away is now known as lestrrat

[13:00] *** patspam left
[13:08] *** simcop2387 left
[13:14] *** ruoso joined
[13:19] *** lumi left
[13:20] *** lumi joined
[13:23] *** mariuz joined
[13:27] *** JohnDoe365 joined
[13:29] *** iblechbot left
[13:33] *** simcop2387 joined
[13:42] *** bluescreen left
[13:42] *** bluescreen joined
[13:43] *** payload left
[13:44] *** payload joined
[13:59] *** JohnDoe365 left
[14:08] *** mariuz left
[14:09] <colomon> moritz_: I'm thinking some of us should conspire to try to finish proto's useful branch in the next couple of days.

[14:10] <moritz_> colomon: some of us should, but currently I'm in a very unpleasant mixture of being either stressed out or offline (or both, sometimes)

[14:10] <colomon> I'm sorry to here that.  If there's anything we can do to help with the stress...

[14:11] <colomon> *hear

[14:11] <colomon> (gack, my spelling is awful today for some reason)

[14:11] <moritz_> nope

[14:13] <colomon> I'm actually going to be offline most of the rest of the morning and at least part of the afternoon myself.  Just hoping to get wheels moving...

[14:17] *** Baggiokwok left
[14:34] *** LaVolta left
[14:47] *** drbean left
[14:48] *** rgrau left
[14:49] <colomon> okay, I pulled the latest installed-modules, and now I'm taking the boy to the library for storytime.

[14:49] *** colomon left
[14:51] *** ash_ joined
[14:51] *** jonasbn left
[14:54] *** xinming_ is now known as xinming

[14:59] *** Guest34084 left
[15:01] *** PacoLinux joined
[15:04] <ash_> in S07, it referrer to roles called like List::PushBack, does that seem odd to anyone else? I am referring to naming it List, since lists are generally assumed to be immutable why would a list be able to push back? 

[15:04] *** iblechbot joined
[15:05] <moritz_> seems odd, yes

[15:08] *** jaldhar left
[15:09] *** payload left
[15:09] *** payload joined
[15:11] *** lumi left
[15:11] <ash_> there is a List::Unshift too, so just 2 references to it, just thought i'd comment on that

[15:11] *** lumi joined
[15:16] <mathw> yes it does seem odd

[15:22] <ash_> ng: @*INC = 1, 2; 

[15:22] <p6eval> ng 7daa82: Cannot assign to readonly value␤current instr.: '&infix:<=>' pc 14470 (src/builtins/Junction.pir:113)␤

[15:22] <ash_> are globals not implemented in ng? 

[15:22] <moritz_> ng: @*:INC.push: 3

[15:22] <p6eval> ng 7daa82: Confused at line 1, near "@*:INC.pus"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤

[15:22] <moritz_> ng: @*INC.push: 3

[15:22] <p6eval> ng 7daa82: Method 'push' not found for invocant of class 'Undef'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤

[15:23] <moritz_> could be

[15:23] <moritz_> s/globals/contextuals/

[15:24] <ash_> S02: $*foo       dynamically overridable global variable    i thought the * twigil was 'global' ? 

[15:24] * moritz_ thought we had no globals :-)

[15:26] <ash_> ah, i was worried something had changed in the spec and i had not even realized it 

[15:28] *** payload left
[15:34] *** mberends joined
[15:35] <ash_> does anyone know off hand of a set of tests for twigils? 

[15:35] <ash_> or is there a way i can verify that the * twigil is working properly? 

[15:38] <pmichaud> good morning, #perl

[15:38] <phenny> pmichaud: 01:25Z <japhb> tell pmichaud Now that we're both back ... we had discussed a couple months ago moving http://gitorious.org/parrot-plumage/parrot-plumage/blobs/master/src/lib/Util.nqp into NQP-rx, possibly with a name change to NQP::Util or somesuch, but that you wanted to think about the details.  What are your current thoughts on this?

[15:38] <pmichaud> er, #perl6

[15:40] <ash_> good morning pmichaud 

[15:42] <moritz_> oh hai

[15:44] *** payload joined
[15:44] *** saschi left
[15:44] *** Psyche^ joined
[15:45] *** ejs left
[15:48] <jnthn> morning, pmichaud 

[15:48] *** Patterner left
[15:48] *** Psyche^ is now known as Patterner

[15:51] *** ash_ left
[15:51] <mathw> hello!

[15:54] <pmichaud> I'm still searching for the magic constellation of relationships between iterators, arrays, and lists :-|

[15:54] *** alester joined
[15:55] *** jaldhar joined
[15:56] *** jaldhar left
[15:56] *** jaldhar joined
[15:57] *** lumi left
[15:57] *** lumi joined
[15:58] *** jferrero left
[16:00] *** jferrero joined
[16:01] *** ejs joined
[16:10] <pmichaud> how does an iterator signal "no more elements?"

[16:10] <diakopter> return instead of yield? oh wait, that's IEnumerable

[16:12] <jnthn> pmichaud: Nil last I checked...

[16:12] <pmichaud> jnthn: how does one check to see if an iterator returned Nil, then ?

[16:12] <jnthn> pmichaud: But it keeps changing.

[16:12] <jnthn> pmichaud: Nil.ACCEPTS($ret_val) - but that's kinda uncheap...

[16:12] <pmichaud> Nil isn't a type

[16:12] <jnthn> So?

[16:12] <pmichaud> so, what you wrote is the same as   ().ACCEPTS($ret_val)

[16:12] <jnthn> Nor is 42 but I can smart-match against that. :-)

[16:12] <jnthn> What type of thingy is Nil?

[16:12] <jnthn> I guessed an empty parcel.

[16:12] <pmichaud> Nil is an empty Parcel

[16:13] <jnthn> OK, so can an empty Parcel smart-match against another?

[16:13] <jnthn> Oh wait...

[16:13] <jnthn> ...calling a method on a parcel forces it into item context.

[16:13] <jnthn> Hm

[16:13] <pmichaud> using a Parcel in item context converts it into a Seq

[16:13] <pmichaud> and I suspect an empty Seq should match like an empty array

[16:14] <jnthn> Yeah

[16:14] <jnthn> I mean, detecting if you have an empty parcel is possible by checking (a) is it a Parcel and (b) is it empty, but I'm not sure how that looks in Perl 6, since they tend to evaporate when touched.

[16:15] *** nihiliad joined
[16:16] <pmichaud> I have been thinking that perhaps method calls aren't sufficient to force a Parcel into item context

[16:16] *** KyleHa joined
[16:17] <pmichaud> i.e., that we could invoke methods on a Parcel without forcing it to be an item.  That would be very helpful now -- especially for dealing with .Capture

[16:17] <pmichaud> (some methods would force the Parcel to become a Seq, but not all)

[16:17] <jnthn> Use the Junction rule 

[16:17] <jnthn> "If the method ain't defined on Parcel itself, we make it a Seq"

[16:18] <jnthn> (the junction one being "If the method ain't defined on Junction, we auto-thread"

[16:18] <pmichaud> could do that, too.  I suspect there aren't that many methods where it matters.

[16:18] <jnthn> Right.

[16:19] <jnthn> Could work.

[16:19] <PerlJam> good morning #perl6

[16:19] <jnthn> Let me know if you needs a dispatcher tweak.

[16:19] <pmichaud> well, it could work, yes, but even at that     Nil.ACCEPTS($ret_val)  is really ugly/slow.

[16:20] <jnthn> True.

[16:20] <pmichaud> I think I would almost prefer an exception-based model in that case

[16:20] <jnthn> I've preferred to avoid using Nil in-band to indicate this all along.

[16:21] *** partisan left
[16:22] <pmichaud> well, on thinking about it further, we probably have to be able to check for Nil anyway

[16:23] <pmichaud> because of the possibility of:    sub foo(*args) {   return;  }

[16:23] <jnthn> Yes, that is true.

[16:23] <jnthn> isnil dynop. ;-)

[16:24] <pmichaud> oh, could just have a .isnil method on Parcel

[16:24] <jnthn> Well, that's cleaner, yes.

[16:25] *** cdarroch joined
[16:25] <PerlJam> you want to use Nil to signify that an iterator is "done"?

[16:26] <pmichaud> PerlJam: I want to know (1) how an iterator signifies that it's done, and (2) how to detect when something returns Nil

[16:26] <PerlJam> okay. Because I don't think that "returning Nil" can be the answer to (1)

[16:27] <pmichaud> I'm fine with that -- thus my original question

[16:27] <pmichaud> 16:08 <pmichaud> how does an iterator signal "no more elements?"

[16:27] <moritz_> TimToady and ruoso had some extensive dicussions about that

[16:28] <pmichaud> moritz_: recently?

[16:28] <moritz_> but I don't remeber their outcome

[16:28] <pmichaud> as in, within the last 3 days?

[16:28] <moritz_> pmichaud: no, more like a year ago

[16:28] <pmichaud> moritz_: okay.  The array/list/iterator spec was significantly redone over the weekend.

[16:29] <moritz_> and we didn't have a Nil back then

[16:29] <pmichaud> hmmm.  in general, "exception"  means "return a failure" in p6

[16:31] <pmichaud> so perhaps we need a StopIteration role or something

[16:33] <pmichaud> or maybe IterationFailure

[16:38] <pmichaud> actually, thinking about it more, it's Seq (or the notion of immutable array/list) that seems to give me the most heartburn

[16:40] *** payload left
[16:40] <pmichaud> for example, if I have

[16:40] *** payload joined
[16:40] <pmichaud>     my $b = 20;   my $a = (1..5, $b);   $b = 21;  say $a.perl;   # what gets output?

[16:41] *** gabiruh joined
[16:43] <diakopter> the C# compiler generates a state machine class (IEnumerable<EnumeratedType>), whose MoveNext method returns true until it is out of items; that generated MoveNext method wraps the user's generator code. 

[16:44] <diakopter> The generated class contains a IEnumerator<EnumeratedType> field that stores the last enumerated item, so when MoveNext returns true, the call puts the EnumeratedType in some out parameter somewhere, and it's returned

[16:45] <pmichaud> diakopter: so, it basically has two parts -- "yes, I got another element", and "here is the element I got"

[16:45] <diakopter> yes

[16:45] <pmichaud> colomon++ was suggesting something along those lines

[16:47] <pmichaud> that could be made to work

[16:47] *** SeaSalt45654322 joined
[16:48] <pmichaud> I have to think a bit more about list/seq... talking a walk

[16:48] <diakopter> walk your talk, too! :)

[16:49] <pmichaud> *taking

[16:50] <pmichaud> :)

[16:51] <SeaSalt45654322> Hi all..can anyone recommend a good IDE to get started with perl 6?

[16:51] <moritz_> SeaSalt45654322: do you happen to like vim?

[16:52] <moritz_> if yes: there's a Perl 6 plugin for vim. If not: http://padre.perlide.org/

[16:55] *** Salada345 joined
[16:56] <Salada345> moritz: thanks. I've never used it outside the linux shell...the ideal IDE for me would have a debugging feature that shows me my variable values after i run my scripts

[16:57] <moritz_> Salada345: that's an ability that a debugger has to provide, an IDE can only integrate that nicely with the editor

[16:57] <moritz_> Salada345: and we don't have such a debugger yet :/

[16:58] <Salada345> mortiz_:gotcha...is that just for perl 6 or is it also the case for perl 5?

[16:59] <moritz_> Salada345: perl 5 has better debugger support

[16:59] <diakopter> it's especially great on Windows using ActivePerl's Perl Dev Kit, whose debugger listener is compatible with both ActivePerl and Strawberry Perl.

[17:00] <Salada345> moritz_: Thank you for your help! I'll keep myself updated on VIM

[17:00] <diakopter> , which facilitates step-through, breakpoints (conditional or not), step-out, etc

[17:01] * moritz_ goes offline, see you tomorrow

[17:01] <diakopter> visually, I mean

[17:01] <diakopter> moritz_: g'night

[17:02] <Salada345> diakopter: nice, that is exactly what i was looking for.

[17:02] <diakopter> Perl Dev Kit costs money, though...

[17:03] <diakopter> oh, I didn't realize they had it for all those other platforms too (Mac, Linux, Solaris, AIXppc)

[17:04] <Salada345> do you know any others that are comparable? but free?

[17:05] <diakopter> yes

[17:05] <diakopter> www.epic-ide.org

[17:05] <diakopter> if you're accustomed to Eclipse

[17:07] *** clintongormley joined
[17:08] *** zloyrusskiy joined
[17:08] <diakopter> a quick google search turns up others: perl-express.com, also ActiveState's Komodo Edit

[17:10] <diakopter> commute&

[17:11] *** payload left
[17:12] *** saschi joined
[17:12] *** SeaSalt45654322 left
[17:16] *** Salada345 left
[17:17] *** jaldhar left
[17:32] <pmichaud> lunch

[17:33] *** ejs left
[17:36] *** FCO joined
[17:50] *** supernovus joined
[17:53] *** ejs joined
[17:55] *** SmokeMachine left
[17:56] *** stephenlb joined
[18:01] *** lypanov joined
[18:01] *** jettero joined
[18:02] <jettero> what's going on with xs for perl6 so far?  I was googling for things, but I keep finding really old stuff

[18:03] <jettero> seems like a hard problem since there's multiple implementations and things

[18:10] <supernovus> when defining multi subs with different parameters, shouldn't  (Num $a, Num $b) outweigh (Object $a, Object $b)  ??

[18:10] *** dakkar left
[18:11] <TimToady> supernovus: I would think so

[18:11] <jnthn> Should do.

[18:11] <PerlJam> jettero: there is no XS for perl6.  See?  Easy peasy  :)

[18:12] *** rgrau joined
[18:12] <TimToady> XS is one of the p5 things that p6 thinks should get broken.  so only a co-interpreter running perl5 will be able to support XS directly

[18:12] <TimToady> unless someone resurrects ponie

[18:13] <supernovus> Hmm, in rakudo trunk I have: multi sub infix:<should-be> (Num $a, Num $b) { ... } and multi sub infix:<should-be> (Object $a, Object $b) { ... } and if I do a "1 should-be 2" it dispatches to the Object one. If I comment out the Object one, it goes to the Num one.

[18:13] <TimToady> smop might eventually make it easy to meld run-loops for p5 and p6

[18:13] *** zloyrusskiy left
[18:13] *** ShaneC1 joined
[18:14] <TimToady> what happens if you change Object to Any?

[18:14] *** meppel joined
[18:15] <TimToady> (Object is going away in favor of Mu, btw)

[18:15] *** ejs left
[18:15] <TimToady> Any is more correct in any case, unless you want to allow junctions as arguments

[18:19] *** ejs joined
[18:22] <diakopter> Mu Cool Any -> Yo Am UNCOL

[18:25] *** stephenlb left
[18:25] *** simcop2387 left
[18:25] *** jjore left
[18:25] *** stepnem left
[18:25] *** ingy left
[18:25] *** Khisanth left
[18:25] *** c9s__ left
[18:25] *** _ilbot2 left
[18:25] *** ssm left
[18:25] *** cognominal left
[18:25] *** hercynium left
[18:25] *** tomaw__ left
[18:25] *** eternaleye left
[18:25] *** yahooooo left
[18:25] *** nadim_ left
[18:25] *** BinGOs left
[18:25] *** kraih_sri left
[18:25] *** lisppaste3 left
[18:25] *** pmichaud left
[18:25] *** pugs_svn left
[18:25] *** sjohnson left
[18:25] *** spinclad left
[18:25] *** zorgnax left
[18:25] *** awwaiid left
[18:25] *** sunnavy left
[18:25] *** gbacon left
[18:25] *** sbp left
[18:25] *** diakopter changes topic to: »ö« | http://perl6.org/ | nopaste: http://paste.lisp.org/new/perl6 | evalbot usage: 'perl6: say 3;' or rakudo: / pugs: / std: , or /msg p6eval perl6: ... | irclog: http://irc.pugscode.org/ | UTF-8 is our friend!

[18:25] *** meppl left
[18:26] <supernovus> Well, changing to Any as well as fixing a typo (duh!) fixed the dispatching problem :-)

[18:28] <TimToady> rather than making Parcel respond to some methods and not to others, we might place parcel responses on the macro/nonmacro boundary with .WHAT etc

[18:28] <TimToady> which means maybe there's .NIL and maybe .NOTNIL macros

[18:28] <TimToady> maybe

[18:29] <TimToady> (and I hope ng isn't still trying to treate .WHAT et al. as real method calls...)

[18:30] <TimToady> *treat in modern english

[18:31] <PerlJam> TimToady: and how does an Iterator signify that there are no more items to iterate?

[18:31] <PerlJam> (I would think that it would return Mu() or the appropriate "undef" thing)

[18:31] <TimToady> that would still be Nil, as per current spec

[18:32] <TimToady> Mu is not the absence of an object

[18:32] <TimToady> Nil is

[18:32] *** pmichaud joined
[18:32] *** hercynium joined
[18:32] *** tomaw__ joined
[18:32] *** eternaleye joined
[18:32] *** yahooooo joined
[18:32] *** nadim_ joined
[18:32] *** BinGOs joined
[18:32] *** ssm joined
[18:32] *** kraih_sri joined
[18:32] *** lisppaste3 joined
[18:32] *** awwaiid joined
[18:32] *** sbp joined
[18:32] *** zorgnax joined
[18:32] *** spinclad joined
[18:32] *** sjohnson joined
[18:32] *** irc.freenode.net sets mode: +ovoo pmichaud lisppaste3 spinclad sjohnson

[18:32] *** pugs_svn joined
[18:32] *** gbacon joined
[18:32] *** sunnavy joined
[18:32] *** irc.freenode.net sets mode: +vo pugs_svn gbacon

[18:32] *** ejs left
[18:33] <PerlJam> When reading from a socket and there's nothing to read, do we get a Mu-thingy or a Nil ?  the iterator isn't "done" because the socket is still open and available, but there's just no data.

[18:33] *** Khisanth joined
[18:33] *** stephenlb joined
[18:33] *** simcop2387 joined
[18:33] *** stepnem joined
[18:33] *** jjore joined
[18:33] *** ingy joined
[18:33] *** _ilbot2 joined
[18:33] *** c9s__ joined
[18:33] *** irc.freenode.net sets mode: +ov Khisanth _ilbot2

[18:33] <PerlJam> (assume a non-blocking read obviously)

[18:34] <pmichaud> PerlJam: blocking read?

[18:34] <pmichaud> oh, non-blocking

[18:34] <pmichaud> I would expect we'd get some sort of failure object

[18:34] <TimToady> sockets are a bit biased towards the exception model

[18:35] <pmichaud> TimToady: did you see my earlier question asking "how does an iterator signal that it's done?"

[18:35] <TimToady> did you see my response above?

[18:35] <pmichaud> er, "how does it signal 'no more elements'?"

[18:35] <pmichaud> no

[18:35] <pmichaud> maybe it occurred during a netsplit or something...?

[18:36] <TimToady> hmm

[18:36] <tkr> PerlJam: .. Mu thingy? Is that like Maybe monad in haskell?

[18:36] * pmichaud goes to check irclog

[18:36] <TimToady> missing there too

[18:36] <PerlJam> pmichaud: ...

[18:37] <PerlJam> <@PerlJam> TimToady: and how does an Iterator signify that there are no more items to iterate?

[18:37] <PerlJam> <@TimToady> that would still be Nil, as per current spec

[18:37] <pmichaud> If Nil, then how does one check that an iterator returned Nil ?

[18:37] <pmichaud> (or any other function, for that matter)

[18:37] <TimToady> by current spec, iterators never return Nil

[18:38] <TimToady> except to indicate the end

[18:38] <pmichaud> right

[18:38] <pmichaud> so, how do we check that we reached the end?

[18:38] <TimToady> @TimToady> rather than making Parcel respond to some methods and not to others, we might place parcel responses on the macro/nonmacro  boundary with .WHAT etc

[18:38] <TimToady> 10:28 <@TimToady> which means maybe there's .NIL and maybe .NOTNIL macros

[18:38] <TimToady> 10:28 <@TimToady> maybe

[18:38] <tkr> why cant iterators return Maybe, haskell style?

[18:38] <TimToady> 10:29 <@TimToady> (and I hope ng isn't still trying to treate .WHAT et al. as real method calls...)

[18:38] <TimToady> 10:30 <@TimToady> *treat in modern english

[18:39] <TimToady> tkr: all non-native types are Maybe in Perl 6

[18:39] <TimToady> but we want to be able to return undefined values

[18:40] <TimToady> up to and including Mu

[18:40] <tkr> and what is the Just in perl 6?

[18:40] <TimToady> subset types

[18:40] <tkr> TimToady: return !!0 .. aka. false.

[18:41] <TimToady> I don't follow you there.

[18:42] <tkr> you can return undefined, defined, and defined but false. right?

[18:42] <tkr> I think Im too perl5.

[18:42] <TimToady> well, !!0 would be true

[18:43] <sbp> .NOTNOTNIL?

[18:43] <TimToady> pmichaud: I could perhaps be argued into a NIL value that is always guaranteed to return Nil no matter how many times you try

[18:43] <TimToady> esp if it goes with a .NIL macro

[18:43] <TimToady> oh wait

[18:44] <TimToady> that makes NIL() hard

[18:44] <TimToady> well, makes NIL require parens, at least

[18:44] <pmichaud> right now we have Nil

[18:44] <tkr> TimToady: I dont follow you anymore. !!0 is false as against "0 but true"

[18:45] *** cognominal joined
[18:45] <TimToady> nevermind, not enough caffeine

[18:45] <TimToady> !!0 is Bool::False, ye

[18:45] <TimToady> yes even

[18:46] <TimToady> truth is determined by whatever .Bool returns, which is what 'but' overrides

[18:46] <TimToady> well, it'd have to be 'but True', since there's no lower-case truth in Perl anymore :)

[18:47] <pmichaud> there is so :)

[18:47] <tkr> so the iterator could return a Maybe, with Just or Nothing.

[18:47] <tkr> .. or the Haskell way. where is mauke?

[18:49] *** ejs joined
[18:49] *** colomon joined
[18:52] <TimToady> or possibly we should divorce Nil from the concept of () a bit

[18:52] <TimToady> such that return () returns an 'epsilon' that can be removed, while return Nil terminates by promising to always return ()

[18:53] <PerlJam> interesting

[18:53] *** _Jedai_ left
[18:54] <TimToady> possibly Nil is the *undefined* Parcel

[18:54] <PerlJam> then what's Parcel()  ?

[18:54] <PerlJam> or are they just synonyms

[18:54] <tkr> !!0 != () ... thats a fact.

[18:55] *** _Jedai_ joined
[18:55] <tkr> no. 0 = () # synonym

[18:56] <tkr> I think they did this silly thing with == vs === in php. which is similarly funny.

[18:56] <PerlJam> tkr: but Perl 6's == vs === isn't funny?  :)

[18:57] <TimToady> ==== would be funny

[18:57] <TimToady> <=> is funny if you've seen Star Wars

[18:57] <PerlJam> TimToady: I guess that's why we don't have :::: instead of <cut>

[18:58] <tkr> what wait. what does "===" do? :)

[18:58] <TimToady> what it's supposed to do, we hope

[18:59] <tkr> if (0 === !!0 and !!0 === ()) { # ?

[18:59] <pmichaud> 0 === !!0   # false

[19:00] <TimToady> that can't possibly be true, since === will never be true for two different types

[19:00] <pmichaud> === checks type and value equivalence, iirc

[19:00] <diakopter> my sardonicism detector must be broken

[19:00] <Su-Shee> you guys make me afraid sometimes. 

[19:00] <PerlJam> Su-Shee: afraid of what?

[19:01] <pmichaud> TimToady: the case I'm playing with atm is    ($a, $b, 1..10, $c).map( { ... } )

[19:01] <pmichaud> what's the invocant of .map ?

[19:01] <Su-Shee> PerlJam: overall anxiety. deep german angst what you might invent out of a combination of =?!::= or something :)

[19:01] <TimToady> pmichaud: looks like a Seq to me, currently

[19:02] <pmichaud> TimToady: yes, but I don't want it to be a Seq, because I don't want to be preserving those 1..10 values as I process them

[19:02] <[particle]1> ==== is spacetime equivalence.

[19:02] <KyleHa> =?!::= is the Su-Shee incremental anxiety operator.

[19:02] *** [particle]1 is now known as [particle]

[19:02] <pmichaud> I want it to be a List of some sort, where I can get the flattening characteristics of a list but without the "I remember all of the positionals" of Array or Seq

[19:02] *** ejs left
[19:02] <Su-Shee> it'll be like vim .. every typo will show a useful result. ;)

[19:02] <TimToady> pmichaud: gotcha

[19:03] *** Chillance joined
[19:03] <pmichaud> so far I'm seeing a variety of cases... let me see if I can enumerate them (will do it in another window then paste results)

[19:03] *** hercynium left
[19:04] <Su-Shee> [particle]: how about ~~~~~ for biological/dna equivalent? can't think too soon about biocomputing. ;) 

[19:05] <[particle]> with perl 6, you can discover new species in one line of code!

[19:07] <Su-Shee> well we have phasers, Mu and eigenstates - the bio realm is a little underrepresented ;)

[19:07] <tkr> how woud you build as subroutine zipWith ($sub, \@x, \@y) in perl 6 without using the << = >> stuff . or how it was.

[19:08] <tkr> without the hyperoperators. from the basic building blocks?

[19:08] *** ash_ joined
[19:08] *** ash_ left
[19:08] <tkr> I was bit surprised that I couldnt do it in perl5 without a loop.

[19:09] <tkr> is prober currying implemented? I could try some perl6 out on my free time. :)

[19:12] *** ash_ joined
[19:13] <pmichaud> TimToady: some of what I have so far:   http://gist.github.com/286129

[19:15] <pmichaud> oh, and there's another case

[19:15] <pmichaud> (writing)

[19:15] <diakopter> $r = 1..4, @a;

[19:16] <TimToady> Useless use of @a in void context

[19:16] <diakopter> o

[19:18] <pmichaud> http://gist.github.com/286131  # updated with additional case

[19:19] *** justatheory joined
[19:20] <ash_> is S07's reference to List::PushBack and List::Unshift correct? Should those be Array:: instead of List::?

[19:20] <pmichaud> ash_: that's what we're trying to work out now, I think :)

[19:21] <ash_> ah, okay, cool

[19:21] <pmichaud> and S07 has been conjectural anyway, as opposed to being blessed (in the sense that implementations have agreed to it)

[19:22] <ash_> hence the [DRAFT] mark on it still? 

[19:22] <ash_> as apposed to say S06 that doesn't have [DRAFT] anymore

[19:22] <TimToady> I don't think we can simply say that iterators with pushback/workahead are just Arrays

[19:23] <TimToady> Arrays don't directly provide the iterator interface

[19:23] <pmichaud> I've been wondering if they should

[19:24] <tkr> might I ask why on earth "() === 0" instead of "() == !!0" ?

[19:24] <ash_> but, calling them a List seemed confusing to me, since List's are immutable... 

[19:24] <pmichaud> ash_: I think we have to kind of "forget what we thought was true" and restart from first principles

[19:24] <pmichaud> tkr:  () === 0   # false

[19:25] <tkr> pmichaud: so should be !!0 == ()

[19:25] <pmichaud> tkr: at the moment, that would raise a "use of undefined value" exception

[19:25] <pmichaud> because () is Mu which is undefined

[19:26] <tkr> undef != !!0

[19:26] <TimToady> () isn't Mu

[19:26] <pmichaud> () is Nil

[19:26] <pmichaud> which becomes Mu in item context, yes?

[19:27] <TimToady> yes

[19:27] <pmichaud> and == imposes (numeric) item context on its values

[19:27] <tkr> ahh. so () could me a "Maybe" with values of !!0 or undef

[19:27] <tkr> s/me a/be a/

[19:27] <pmichaud> I should've said  "because 'item ()' is Mu which is undefined", then

[19:28] <tkr> do you use !!0 =

[19:28] <tkr> ?

[19:28] <TimToady> why do you keep talking about !!0 ?

[19:28] <tkr> it's a very good false.

[19:28] <pmichaud> tkr:  !!0  is just False

[19:29] <pmichaud> ng:   say (!!0).WHAT

[19:29] <p6eval> ng 7daa82: Int()␤

[19:29] <pmichaud> oops

[19:29] <pmichaud> that's a bug :-|

[19:29] <pmichaud> should've been Bool

[19:29] <ash_> rakudo: say (!!0).WHAT

[19:29] <p6eval> rakudo 1d4928: Bool()␤

[19:31] <tkr> pmichaud: it should me Maybe -> Nothing -> False

[19:31] <TimToady> .map wants to get some kind of object and tell it "you need to be iterable according to my current context, which is (list|slice)"

[19:31] <tkr> Mothing is more like a undef

[19:31] <pmichaud> tkr: ! returns a Bool

[19:32] *** jferrero left
[19:32] <pmichaud> TimToady: that's not precisely the way I've been viewing it (more)

[19:32] <pmichaud> .map gets some kind of object that already has a context (list|slice), and knows how to iterate it

[19:33] <pmichaud> I can see the other view, however.

[19:33] <pmichaud> (I don't quite see how to implement it, though)

[19:33] <TimToady> that seems wrongish, or we can never have a method override its outer context

[19:33] <TimToady> like .slice or .list

[19:33] <tkr> pmichaud: perl -MDevel::Peek -wle 'Dump(0); Dump(!!0);' # perl 5

[19:34] <pmichaud> tkr: we're talking about Perl 6 here.

[19:34] <TimToady> a method is parsed as a postfix, but the postfix actually is in charge of the semantics of its argument, generally

[19:34] <tkr> pmichaud: and that's whats Im trying to understand. what a coincidence!

[19:35] <pmichaud> tkr:  in Perl 6, prefix:<!> returns a Bool.

[19:35] *** zaxklone joined
[19:36] <pmichaud> and  !!0  would complain about a ternary having a !! without a ??

[19:36] <ash_> tkr a useful thing in perl 6 is .perl if you want to see how whatever you have would define itself 

[19:36] <TimToady> pmichaud: not as a prefix

[19:36] <pmichaud> std:   say !!0;

[19:36] <p6eval> std 29585: [31m===[0mSORRY![31m===[0m␤Ternary !! seems to be missing its ?? at /tmp/1pG9Mob9ic line 1:␤------> [32msay [33m⏏[31m!!0;[0m␤    expecting infix stopper␤FAILED 00:01 106m␤

[19:36] <pmichaud> std:   say(!!0);

[19:36] <ash_> rakudo: my $a = 5; say (!$a).perl;

[19:36] *** [particle]1 joined
[19:36] <p6eval> std 29585: ok 00:01 106m␤

[19:36] <p6eval> rakudo 1d4928: Bool::False␤

[19:36] <pmichaud> okay.

[19:37] <pmichaud> std:   if 3 = !!0 { say 'ok'; }

[19:37] <p6eval> std 29585: ok 00:01 107m␤

[19:37] <TimToady> std: say (!!0)

[19:37] <p6eval> std 29585: ok 00:01 106m␤

[19:37] <ash_> so, saying !$a where $a = 5; its returning Bool::False

[19:37] <pmichaud> bad example on the say there, but... yes, you're correct

[19:37] <pmichaud> (on my say, not TimToady's)

[19:37] <TimToady> well, perhaps overzealous <terminator> matching on the say parsing

[19:37] *** lumi left
[19:38] <pmichaud> TimToady: I don't quite understand "method override its outer context"

[19:38] *** lumi joined
[19:39] <TimToady> list ($a,$b,$c).item   vs item ($a,$b,$c).list   for instance

[19:40] * jnthn back for a bit...

[19:40] * jnthn backlogs latest lists discussion

[19:40] *** zaxklone left
[19:40] <pmichaud> I don't see the conflict in that example.

[19:40] <tkr> Int $x overrides your String $x if you are writing a  subclassed method which is defined as Int $x ..? 

[19:41] <pmichaud> list ($a,$b,$c).item   #   a parcel in item context (becomes a Seq or List) that is then evaluated as a non-flattening item in list context

[19:41] <ash_> tkr: can you give an example? 

[19:42] <TimToady> single dispatch doesn't pay attention to types of anything other than the invocant

[19:42] *** [particle] left
[19:42] <colomon> supernovus: 1 and 2 are not Num, they are Int.  (Not sure if someone else has pointed this out or no.)

[19:42] <pmichaud> item ($a,$b,$c).list   #  creates a list from the Parcel, and then treats that list in item context

[19:42] <TimToady> pmichaud: but what you said seems to indicate that ($a,$b,$c) knows its in list context

[19:42] <TimToady> *it's

[19:42] <pmichaud> I think I was saying that .map treats its invocant as being in list context

[19:43] <pmichaud> if its invocant is a parcel

[19:43] <TimToady> okay

[19:43] <pmichaud> and that in order to do a map on slices, we'd have to have something that explicitly turns the "invocant" into a slice

[19:44] <TimToady> but there's a question about transitively passing on contexts like slice or hyper

[19:44] <tkr> ash_: actually, Im having trouble at the moment, but trying to hold the thought.

[19:44] <pmichaud> (1,2 Z 3,4).map: { ... }     # list or slice processing?

[19:47] <tkr> pmichaud: its jsut array members. ("1,2", " Z 3", "4") .. imho. what is your $" ? 

[19:47] <tkr> .. list members.

[19:48] <tkr> no wait. ("1", "2 Z 3", "4") ..

[19:48] <ash_> tkr: Z is a zip operator to zip the two lists together 

[19:48] <pmichaud> tkr:  ... what ash said

[19:48] <PerlJam> tkr: (1,2 Z 3,4)  ==  (1,3), (1,4), (2,3), (2,4)

[19:48] <ash_> its going to zip 1,2 to 3, 4 

[19:48] <pmichaud> tkr:  in slice context, it becomes   (1,2), (3,4)

[19:48] <PerlJam> oops. no

[19:49] <pmichaud> er

[19:49] <pmichaud> (1,3), (2,4)

[19:49] * PerlJam needs caffiene

[19:49] <pmichaud> in list context it becomes  (1,3,2,4)

[19:49] <tkr> this is about I was asking in the beginning

[19:49] <PerlJam> tkr: Z is the zip operator  :)

[19:49] <pmichaud> so my question is, how many iterations does .map perform in that case?  

[19:49] <pmichaud> if we imagine the map operator as working on slices, then it has two elements it works on

[19:49] <tkr> 1:07 < tkr> how woud you build as subroutine zipWith ($sub, \@x, \@y) in perl 6 without using the << = >> stuff . or how it was.

[19:49] <pmichaud> if we imagine it to be working on lists, then it has four elements

[19:50] <tkr> 21:08 < tkr> without the hyperoperators. from the basic building blocks?

[19:50] <PerlJam> tkr: in native Perl 6, we'd just use zip and map I think  :-)

[19:52] <tkr> yes, so "zip" is as native as it gets?

[19:52] <tkr> Id like to build a "zip" function myself, so that it works with infinite lists just fine.

[19:52] <supernovus> colomon: I know, I used Num as I wanted the comparison to be used by any numeric values, and Int will dispatch to Num.

[19:53] <pmichaud> tkr:  in perl 6, or perl 5?

[19:53] <tkr> ... in perl of course, if that isnt obvious.

[19:53] <tkr> pmichaud: well ATLEAST in perl 6. geez.

[19:53] <pmichaud> tkr: in perl 6, the builtin zip operator will work with infinite lists just fine

[19:53] <tkr> yes. but "zip" is then as basic as you can get?

[19:54] <pmichaud> tkr:  I don't know what you mean by "basic"

[19:54] <jnthn> pmichaud: Put another way, would you expect that we can write zip in Perl 6?

[19:54] <tkr> well compared, to let's take it to extreme "from nand to tetris in 12 steps"

[19:54] <pmichaud> if you're asking "is it possible to write a version of the zip operator in Perl 6 itself", I think the answer is "yes" but I can't tell you how to do it at the moment because we're still revising the way that lists and iterators work

[19:55] <colomon> In fact, the zip operator is one of the ones I've been keeping in the back of my mind during this whole list rewrite discussion.

[19:55] <tkr> pmichaud: ok, thanks. its still under work, I completely understand. :)

[19:55] <TimToady> slice context is more basic than zip, and slices are what zip is built out of

[19:55] <tkr> I was just curious.

[19:55] <ash_> isn't zip already written in perl 6? 

[19:55] <pmichaud> ash_: not one that understands slice context, or is lazy.

[19:55] <pmichaud> (at least, not in Rakudo)

[19:56] <tkr> pmichaud: where it has?

[19:57] <pmichaud> tkr:  I don't understand the question.

[19:59] *** ejs joined
[19:59] <tkr> can some other release to give the perl programmer to feel of wonderfulness of writing a zipwith() function in perl6 without using the builtin "zip" -function?

[19:59] <pmichaud> tkr: the part we're struggling with now is a language design issue, not an implementation issue

[20:00] <pmichaud> so, no.

[20:00] <tkr> Im sorry for all the preposition erros etc, byt I wasnt sure to whom I was talking to. ;)

[20:01] <tkr> pmichaud: thank you a million for all the effort you will be doing for perl 6, and also thse answers. :)

[20:01] <pmichaud> you're welcome.  apologies that they're not clearer today.

[20:01] *** cotto_work left
[20:01] *** cotto_work joined
[20:04] *** pmurias joined
[20:06] <TimToady> errands &

[20:06] *** KyleHa left
[20:07] *** ash__ joined
[20:07] <pmichaud> colomon: http://gist.github.com/286189  # guess #1 at infix:<Z>

[20:08] <pmichaud> probably lots of errors in it, but that's my first draft guess.

[20:09] <colomon> That is crazy and beautiful.  pmichaud++

[20:10] <colomon> I think I'd been assuming you'd construct an iterator type to do that....

[20:10] <jnthn> Wow.

[20:10] <pmichaud> the iteration is assumed by .list

[20:10] <pmichaud> and .shift

[20:10] *** [particle]1 left
[20:10] <jnthn> pmichaud: btw, any ideas what might cause a block to come out with its :outer pointing back on itself?

[20:11] <pmichaud> jnthn: in PAST?

[20:11] <jnthn> Yeah

[20:11] <pmichaud> sounds like a broken reference somewhere

[20:11] <jnthn> pmichaud: The lazy sig blocks seem to be coming back like that in PIR.

[20:11] <pmichaud> do they contain references to themselves?

[20:11] <jnthn> Shouldn't...

[20:11] <jnthn> I'll dig in.

[20:12] <pmichaud> if yes, such references have to go through a PAST::Var :scope('register')

[20:12] <ash__> whats the parameter **@ called? (i thought slurpies only had 1 star) 

[20:12] <pmichaud> ash_: I think that's a slice

[20:12] <jnthn> Oh, I thought it was *@@

[20:12] <jnthn> :-)

[20:12] <ash__> ah, that slurpies in slice context? 

[20:12] <PerlJam> I thought it ... what jnthn said

[20:12] <pmichaud> ah, yes, *@@

[20:12] * pmichaud fixes

[20:13] <pmichaud> http://gist.github.com/gists/286189   # fixed

[20:13] *** k23z__ left
[20:14] <pmichaud> ....but even this small example starts to illustrate the difficulty I'm having with iterators.  What if one of the iterators returned Nil?

[20:14] <pmichaud> (to mark the end of the iteration)

[20:15] *** ash_ left
[20:15] <ash__> iterators could raise special exception instead of returning a specific thing?

[20:15] <pmichaud> ash__: in which case, we'd need a try block here (and everywhere) that we happen to be using an iteration

[20:15] <pmichaud> that doesn't seem right.

[20:16] <ash__> the control structure could catch it, that could signal 'i am done iterating' 

[20:16] <pmichaud> which control structure.  the 'while'?

[20:17] <ash__> i am not sure, maybe you'd need to use for loops instead? i duno, just thinking out loud. 

[20:17] <pmichaud> replace "for loop" with "map" and we might have an answer

[20:17] <pmichaud> (since "for loops"  are really just "map")

[20:18] *** [particle] joined
[20:18] <ash__> then you'd never have to worry about looking at what was last returned, just wait until the proper exception was raised

[20:18] <colomon> you might not even have an enclosing loop, at the level you want to worry about.

[20:19] <colomon> I mean, think of how lazy map would be implemented -- basically it makes a new iterator which iterates the original iterator once (maybe more) and then processes the result and returns that.

[20:20] <colomon> map would need to know that it shouldn't process that "Nil" result.

[20:21] <ash__> colomon: are you suggesting a lazy map that could return a gather? 

[20:21] <pmichaud> keep in mind that the result of a gather tends to be an iterator also 

[20:21] <pmichaud> so at some point we have to use a circularity saw to break the cycle

[20:22] <colomon> yeah, that's a simplified version of how you would implement gather.

[20:24] <colomon> pmichaud: keep in mind it would be pretty easy to take the suggestion from HOP and just implement a special code for "iterator is finished" instead of Nil.

[20:24] <pmichaud> we still have to check for it

[20:24] <colomon> like a singleton Iterator end class.

[20:24] <pmichaud> and checking for it makes things icky

[20:24] <colomon> yes, I'll be really impressed if you can figure out a way to avoid checking.

[20:24] <PerlJam> colomon: an Iterator returns an Iterator() to signify the end?  :)

[20:25] <colomon> PerlJam: that's simpler than I was thinking, but seems pretty reasonable to me.

[20:27] *** lumi left
[20:27] *** lumi joined
[20:27] <pmichaud> http://gist.github.com/286189   # more infix:<Z> possibilities

[20:27] <PerlJam> Maybe the "end signal" should be a parameter of the iterator  (though I guess that would mean we're just talking about the reasonable default then)

[20:27] <pmichaud> oops, forgot some >>

[20:27] <ash__> if you don't want to check the return of each iteration the only control structure way i can think of to find the end is to use an exception handler then you only have to raise when your done and there is no individual checking of results 

[20:28] <pmichaud> http://gist.github.com/286189  # reload

[20:29] <pmichaud> if we check iterator return values for a sentinel, then we get something like

[20:31] <pmichaud> http://gist.github.com/286214   # a sentinel version (at end)

[20:32] <pmichaud> where "== SENTINEL" is some sort of test

[20:33] <pmichaud> so far I like #2 best

[20:35] <Tene> ng: for (1..3) Z (1..5) { say "$^a - $^b }

[20:35] <p6eval> ng 7daa82: Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (src/stage0/Regex-s0.pir:907)␤

[20:35] <Tene> ng: for (1..3) Z (1..5) { say "$^a - $^b" }

[20:35] <p6eval> ng 7daa82: Could not find non-existent sub &infix:<Z>␤current instr.: '_block14' pc 29 (EVAL_1:0)␤

[20:35] <Tene> rakudo: for (1..3) Z (1..5) { say "$^a - $^b" }

[20:35] <p6eval> rakudo 1d4928: 1 - 1␤2 - 2␤3 - 3␤

[20:35] <ash__> pmichaud: http://gist.github.com/286221 fork of yours with an exception :P 

[20:36] <Tene> ew

[20:36] <pmichaud> move the CATCH outside the gather, I think

[20:37] <Tene> no, that won't work.

[20:37] <pmichaud> gather { take @iters>>.get; };  CATCH SENTINEL { };

[20:37] <Tene> What he has is right.

[20:37] <pmichaud> why won't it work?

[20:37] <Tene> You're returning the gather.

[20:37] <pmichaud> oh

[20:38] <ash__> it can be outside of the loop though

[20:38] <pmichaud> okay, then...    gather { loop { take @iters>>.get };  CATCH SENTINEL { } }   # maybe?

[20:38] <ash__> i wasn't sure which to put it in, the loop or gather 

[20:38] <Tene> pmichaud: why that instead of CATCH { last } ?

[20:38] <ash__> .get would have to raise SENTINEL when it can't find what to get next though 

[20:39] <ash__> don't want to catch everything... i think personally

[20:39] <Tene> Right.

[20:39] <pmichaud> Tene: so we're not constantly creating/undoing an exception handler, I suppose.

[20:39] <Tene> pmichaud: Ah.

[20:39] <pmichaud> keep in mind that whatever we ultimately come up with will also be the mechanism for map

[20:39] <pmichaud> and for all list context stuff

[20:39] <pmichaud> which means we'd really like it to be fast-ish

[20:39] <Tene> ash__: I really don't think that throwing exceptions is the right thing to do there.  It would ake working with iterators very awkward.

[20:39] <ash__> in parrot how expensive are exception handlers? 

[20:40] <pmichaud> ash__: very.

[20:40] <Tene> You have to put exception handlers all around every tie you work with lists... really not feasible at all.

[20:40] *** bluescreen left
[20:40] <ash__> yeah, that seems kinda bad then, i was just trying to avoid the checking of every result to find the SENTINEL thats all 

[20:41] <pmichaud> the use of a sentinel seems bad to me at any rate.  I'd prefer to have a definitive "okay to move to next element"

[20:42] <ash__> from S04: To return from your immediate caller, you can say:

[20:42] <ash__>      caller.leave(1,2,3)

[20:42] <ash__> is there anyway to take advantage of that? 

[20:42] <Tene> That's not going to help here, no.

[20:42] <pmichaud> ash__: the iterator might be nested several calls deep

[20:42] <pmichaud> we could be iterating a lazy array that contains a lazy list with a lazy range in it...

[20:42] <ash__> but if you use blocks you'd have your own call frames to reference 

[20:43] <ash__> so to return from 1, you move up 2 and exit .leave it 

[20:43] <ash__> just thinking outloud again

[20:44] <pmichaud> at the moment, I kind of like the idea that we have   .next/.value, and then .get is simply    method get() { .next ?? .value !! Nil }

[20:44] <Tene> you really don't want the data structures reaching out and anipulating your control flow.  That would work very badly.

[20:44] <Tene> pmichaud: I like that.

[20:45] <pmichaud> or, if we assume that .next sets the "value" to Nil when it reaches the end of iteration, it's just

[20:45] <pmichaud>    method get { ?self && .next; .value; }

[20:45] <pmichaud> or even

[20:45] <pmichaud>     method get() { .next; .value; }    

[20:46] <ash__> so in that case SENTINEL would be Nil 

[20:47] <Tene> Are we sure that Nil wouldn't cause a seipredicate problem?

[20:47] <pmichaud> Nil has problems

[20:47] <pmichaud> in general 

[20:47] <pmichaud> for one, we don't have a good way to test for Nil

[20:48] <pmichaud> unless we introduce macros to do it

[20:48] <PerlJam> Perl 6 needs macros anyway  :)

[20:48] <Tene> I like Parrot's ethod of having truthiness of the iterator indicate whether there are more elements, or at least an explicit "more?" ethod.

[20:48] <pmichaud> the problem with "truthiness" is that we can't always know

[20:48] <pmichaud> that's why my solution #1 doesn't work

[20:49] <pmichaud> in general:

[20:49] <Tene> PerlJam: I' still waiting on soe resolutions to the spec from TimToady before I start working on them.

[20:49] *** bluescreen joined
[20:49] <pmichaud>     while ($iter) { $iter.get; }   #   what do we do if .get determines there are no more elements?

[20:49] <Tene> PerlJam: So, if you're interested in macros, pls harass TT.

[20:50] <PerlJam> Tene: What part(s) of the spec need clarifying?

[20:50] <pmichaud> ...can we work on macros another day?  plzkthx

[20:50] <Tene> pmichaud: .Bool tries to fetch another value, and if it can get one, it saves it in a buffer, and .get checks that buffer.

[20:51] <pmichaud> Tene: that sounds like .next

[20:51] <pmichaud> Tene: but I don't want every .Bool to imply "fetch next value"

[20:52] <Tene> pmichaud: .Bool checks the buffer, and if it's empty, tries to fetch another value.  .get checks the buffer, and if it's used, clears it and returns that value, otherwise fetches a new value.

[20:52] *** fridim_ joined
[20:52] <pmichaud> I'd prefer not to do "clears it"

[20:52] <Tene> pmichaud: how else can you deterine if there can be more elements besides trying to get another element?

[20:53] <pmichaud> I'm not saying we shouldn't try, I'm saying that .Bool shouldn't necessarily be that request

[20:53] <Tene> pmichaud: Sure, that's fine.  method can_has_more? { ... };

[20:53] <pmichaud> regardless, if we go the .Bool route, then someone implementing an Iterator still has to write a method (that is neither .Bool or .get) that fetches the next value

[20:54] <Tene> That's not internal iterator logic?

[20:54] <pmichaud> it's different for each type of iterator, I think.

[20:56] <pmichaud> unless we expect every Iterator to implement its own  "see if buffer is filled, if not, fetch value into buffer; return true/false"    and   "return value in buffer, clear buffer"   methods 

[20:56] *** renormalist joined
[20:56] <pmichaud> seems like that logic should be factored out, so that there's really just a "fetch next value" method and the Iterator role handles the buffer and boolean logic

[20:58] *** eternaleye left
[20:58] *** fridim_ left
[20:58] <pmichaud> a very interesting variation on this would be to be able to vary the size of the buffer, and have a .getlast($n)  method that gets the last $n values of the buffer

[20:58] <pmichaud> that could be very useful for implementing the series operator :)

[20:58] <pmichaud> as well as handling batch iterations

[20:59] <pmichaud> so, we could have    .next($n)   # retrieve the next $n items into the buffer

[20:59] <ash__> just curious, what's involved for handling iterations in parallel? 

[20:59] <pmichaud> .get   # get the last item

[20:59] <pmichaud> .getlast($n)  #  return the last $n items from the buffer

[21:01] <Tene> Hm.  I' becoming progressively more convinced that throwing an exception on being asked for more items when there are no more is reasonable.

[21:01] <pmichaud> why?

[21:01] <Tene> Unless there's a reason why returning Nil for that isn't a semipredicate issue.

[21:02] <pmichaud> well, I'm pretty sure we want some sort of out-of-band communication (more)

[21:02] <pmichaud> the question is whether that should be exception based or some sort of query/response

[21:03] <pmichaud> I'm thinking now that query/response gives more flexibility and options

[21:03] <Tene> The question I have there is what should the behavior of .give-me-another be when .are-there-ore? returns false?

[21:03] <pmichaud> oh, in that case it returns Nil

[21:03] <pmichaud> Nil isn't the sentinel in that case, it's just the value you get when you ask an iterator for more elements and there are none

[21:03] <pmichaud> or, perhaps some iterators get to choose that as well.

[21:03] *** xinming_ joined
[21:04] *** ash__ left
[21:04] *** fridim_ joined
[21:04] <pmichaud> but if an iterator is done, it can return values (without those values having to be treated as "sentinel" values)

[21:04] *** ash_ joined
[21:05] *** FCO left
[21:06] <pmichaud> and, of course,  .give-me-another can return Failure objects 

[21:06] <Tene> Can iterators use 'fail'?

[21:07] <pmichaud> sure

[21:07] <Tene> Heh.  Exactly.

[21:07] <pmichaud> this is what Rakudo (master) does now, in fact

[21:07] <pmichaud> rakudo:   my @a;   my $x = @a.shift;  say $x;

[21:07] <p6eval> rakudo 1d4928: Undefined value shifted from empty array␤␤

[21:07] <Tene> Then .give-me-more will throw exceptions when isused under 'use fatal', etc.

[21:07] *** ash_ left
[21:08] <pmichaud> note that the "undefined value" message takes place at the point of the 'say', not the shift

[21:08] *** ash_ joined
[21:08] <pmichaud> rakudo:  my @a;  my $x = @a.shift;  say "here";  say $x;

[21:08] <p6eval> rakudo 1d4928: here␤Undefined value shifted from empty array␤␤

[21:08] <Tene> ng: my @a; my $x = @a.shift; say 'hi';

[21:08] <p6eval> ng 7daa82: hi␤

[21:09] <Tene> Okay, I like that.

[21:09] <pmichaud> so, when an iterator reaches it end, its .get (or whatever) just calls 'fail'

[21:09] <pmichaud> method get() {   $value || fail 'no more values to iterate' }

[21:10] <pmichaud> but we can't use a generic test for Failure as a sentinel, because we might be iterating over a list of failures :-)

[21:11] <pmichaud> ...which is another reason why I'd prefer not to use Nil as the "I'm at the end of iteration" signal (more)

[21:11] <pmichaud> by returning a Failure, we can give better information about the type of iteration that we went beyond the end of

[21:12] *** payload joined
[21:12] *** ash__ joined
[21:12] *** spinclad left
[21:13] *** ash__ left
[21:14] <colomon> pmichaud: backing up a sec, are you proposing the basic iterator interface should be .get with in-line end-of-iteration status, with some sort of generic adapter code to get the .next / .value interface?

[21:14] *** ash__ joined
[21:14] <colomon> (with current quibbling being over how .get should signal end-of-iteration?)

[21:14] <pmichaud> colomon: I'm not at the point of a proposal yet (more)

[21:15] *** eternaleye joined
[21:15] <pmichaud> I'm saying that at the moment, I like (1) .get returns failure objects if we attempt to go beyond the end of an iteration sequence, and (2) those objects aren't the way that we signal "end of iteration"

[21:16] <Tene> s/returns failure objects/calls &fail/

[21:16] *** xinming left
[21:16] <colomon> ah.

[21:16] <pmichaud> &fail is "return failure object"

[21:16] <pmichaud> that's what &fail means :-)

[21:16] <colomon> well, in that case, I'd like to put in strong support for what I thought you were saying.

[21:17] <Tene> &fail is "return failure objects, except under dynamic 'use fatal' conditions, when it throws exceptions instead"

[21:17] *** Su-Shee left
[21:17] <pmichaud> Tene: okay, that's really what I meant, yes :)

[21:18] <Tene> colomon: how can you iterate over failures, then?

[21:18] <pmichaud> I'd really like to separate the notion of "generate the next value of the iteration" from "retrieve the next value of the iteration"

[21:18] <pmichaud> at the moment, .get is the latter

[21:19] <Tene> is that different from "advance to the next ite / fetch the current item"?

[21:19] <pmichaud> I'm thinking about it in terms of  $file.get

[21:19] <Tene> I'm a little bit hazy on uses of "next" in your description.

[21:19] <pmichaud> currently,   .get means "advance to next item and return it"

[21:20] <pmichaud> i.e., it's the primary external mechanism for iterators

[21:21] <colomon> sorry for interruption, my boy just spit partially digested milk all over my leg.

[21:21] <pmichaud> colomon: don't cry over it :-)

[21:21] <colomon> groan.

[21:22] <colomon> my issue with "advance to the next item / fetch the current item" as a basic approach is it means lots of iterators will have to have internal buffers.

[21:22] <pmichaud> colomon: yeah, I'm not too keen about that either

[21:23] <pmichaud> well, *somewhere* there's likely to have to be a buffer

[21:23] <colomon> and on the other hand, if you have the "get the next item or return special flag" interface, you can easily generate an adapting class with buffer that will allow that approach to dealing with the world.

[21:23] <pmichaud> maybe instead of defining .get in terms of .next and .fetch, we define .next and .fetch in terms of .get

[21:23] <colomon> yes, pmichaud, that's exactly what I'm proposing.

[21:23] <pmichaud> so:    method next() { $buffer = .get;  ?self; }

[21:24] <pmichaud>     method value() { $buffer; }

[21:24] <colomon> you just said it eloquently.  

[21:24] <Tene> pmichaud: under that scheme, you can have 'next' return a failure when there are no more items.

[21:24] <pmichaud> Tene: well, I really want .next to return true/false

[21:24] <colomon> and then the only question is what is a reasonable "I'm done" value for .get to return.

[21:24] <Tene> Right, yes, that would be much better.

[21:25] <pmichaud> colomon: I think .get should return a Failure (more)

[21:25] <pmichaud> but I think it should also set the "I'm finished" flag of the iterator to true

[21:25] <Tene> colomon: Please tell me what kind of objects you're absolutely certain nobody would ever want to iterate over.

[21:25] <pmichaud> i.e., the way that .get signals it's done is that it sets the iterator's boolean value to false

[21:26] <Tene> It can't be failures.  Iterating over $! is explicitly discussed in the specs.

[21:26] <colomon> Tene: we can make a special object exactly for this purpose.  If some crank wants to iterate over it, it's on their head.

[21:26] <pmichaud> colomon: I don't like the sentinel approach, for reasons cited above

[21:26] <ruoso> pmichaud, calling fail is not the same as returning a failure

[21:26] <Tene> ruoso: already discussed.

[21:26] <ruoso> ah.. right

[21:27] <ruoso> pmichaud, in my mind... we need to have the Iterators working at a similar level then the one of Unix Pipes

[21:27] <ruoso> I mean...

[21:27] <pmichaud> ruoso: to me, the phrase "returning a failure"  implies a call to &fail, just like  "displaying a value"  implies a call to "&print" or "&say"

[21:27] <colomon> pmichaud: was there reason other than the resulting code isn't so elegant?

[21:27] <ruoso> pmichaud, the semantics are different... calling fail means that the exception is thrown...

[21:27] <ruoso> returning a failure might not mean that

[21:27] <colomon> (sorry, it's been the kind of day where following the conversation isn't necessarily the same as understanding it.)

[21:28] <pmichaud> ruoso: calling fail means that an exception is thrown if "use fatal" is in effect

[21:28] <ruoso> pmichaud, really? I thought that was only for the "lazy exceptions"...

[21:28] <Tene> ruoso: and 'print' actually prints to $*OUT, which ight not display to anyone.  "display a value" is still a fairly reasonable way to talk about calling &say.

[21:29] <pmichaud> ruoso: most exceptions are lazy.  If we want to throw an exception, we use 'die'

[21:29] <Tene> ruoso: No, &fail only throws if you've "use fatal"

[21:29] <pmichaud> &fail is "soft failure"

[21:29] <ruoso> pmichaud, sorry... dislexia on my part

[21:29] <ruoso> I meant die...

[21:29] <pmichaud> ruoso: np :)

[21:29] <ruoso> but anyway

[21:29] <ruoso> about iterators

[21:30] <ruoso> I think an iterator is like an unix pipe

[21:30] <ruoso> in the sense that you can have separated threads in each end of it

[21:30] <ruoso> in fact, I kinda assumed we would have "implicit threading"

[21:30] <ruoso> by creating threads for the iterator usage

[21:30] <ruoso> like...

[21:31] <ruoso> my @a = map { ... }, @b;

[21:31] <ruoso> this would mean at least three interpreter threads

[21:31] <ruoso> one to produce the values in @b

[21:31] <ruoso> other to consume that values and pass through the map block

[21:31] <ruoso> and other to consume the values from the map and store in @a

[21:32] <pmichaud> ruoso: that makes sense, but doesn't really conflict with any of what we've been saying

[21:32] <pmichaud> (or resolve)

[21:32] <ruoso> I know it doesn't... ;) I was just brainstorming ;)

[21:32] <pmichaud> okay

[21:32] <pmichaud> yes, I tend to think of iterators as being independent "threads" as well.

[21:33] <pmichaud> (always have)

[21:33] <ruoso> and Control Exceptions would be used to signal "Buffer Empty", "Buffer Full" and "Data Available"

[21:33] <ash__> so... just thinking about how other languages do things, ruby does iteration inside out with yield and do block's, python does iterators with .next() and raising an exception, php does iterators by implementing an interface with foreach blocks that call next(), valid(), key() and current() till next returns false()

[21:34] *** ash_ left
[21:34] <ruoso> pmichaud, about get and fetch... the issue with .hasNext(), .next() (as in java) is that it doesn't make sense for intensive parallel programming

[21:35] <ruoso> doing a simple operation that might fail is more parallel-friendly

[21:35] <ash__> you could have 2 iterator types (at least), one for parallel that can grab multiple things at a time, and 1 that just does things in order

[21:35] <ash__> next(Int $count) grabs next $count then sends those to $count number of threads?

[21:36] <ruoso> but when you consider "implicit threading" an iterator that "does things in order" is too restrictive

[21:36] <ash__> s/next/get/

[21:37] <ruoso> ash__, in my head that's implemented by map itself (or any other parallellizing op/sub)

[21:37] <Tene> colomon: so, where are you going to store this sentinal value?  In a namespace?  What happens when you ask for a list of objects in that namespace?

[21:38] *** spinclad joined
[21:38] <pmichaud> Tene: we can certainly come up with a sentinel that always has the meaning "iteration done".  I'm not saying we should, but we can.

[21:38] <colomon> Tene: I'm not saying it's possible to create a value that can never be used wrongly.

[21:39] <colomon> Just that we can create one that exists solely for the purpose of being a sentinel.  

[21:40] <ruoso> I'm a bit off the discussion... but I liked more the idea of the iterator throwing an exception when it was over

[21:40] <ruoso> instead of retuning a special value

[21:41] <ash__> i think that was argued against because exception handling is expensive

[21:41] <ruoso> because you can always ask: "what if you want to return the special value as an item of the iteration?"

[21:41] <pmichaud> ruoso: TimToady "solved" that particular objection by saying that Nil was the "special value", and that iterators never return "Nil" except at the end of the iteration. 

[21:41] <Tene> ash__: using &fail works well there, though, because you can explicitly ask the iterator if it's done, or if you want exception semantics, just 'use fatal'.

[21:41] <pmichaud> that brings up other issues, though.

[21:42] <ruoso> it's like null-terminating strings...

[21:43] <ash__> its kinda an issue of "never return XXX" vs "never raise XXX" ? 

[21:43] <ruoso> it worked fine, untill someone came with utf-16

[21:43] <pmichaud> except that strings can have null bytes, but arrays and lists can never have Nil

[21:43] <ruoso> but Nil is an object

[21:44] <ruoso> that needs to be returned somehow

[21:44] <pmichaud> no

[21:44] <pmichaud> Nil is ()

[21:44] <pmichaud> which is an empty list in list context, or Mu in item context

[21:44] <ruoso> yeah yeah... but in the VM it needs to be represented somehow

[21:44] <ruoso> it *is* something

[21:44] <pmichaud> an empty Parcel

[21:44] <ruoso> precisely

[21:45] <pmichaud> but an empty Parcel can never occur in a list

[21:45] <ruoso> if it *is* something, you might need to work with it

[21:45] <pmichaud> okay

[21:45] <ruoso> I mean... semantically, it's confusing

[21:45] <pmichaud> I'm not saying I agree with TimToady's suggestion (I don't -- see above), I'm just saying that he resolved it by saying that value could never be part of an iteration

[21:46] <ruoso> it's the valdemort value

[21:46] <pmichaud> which was your objection :)

[21:46] <ruoso> ;)

[21:46] <spinclad> speaking haskelly... Nil is Nothing, and everything else is Just itself

[21:48] <ruoso> s/valdemort/voldemort/

[21:48] <pmichaud> so, if we say we're doing an exception-based model, then we'd have to have

[21:48] <spinclad> (the Vole of Death)

[21:49] <pmichaud>     method get() { return the next value if available || die StopIterationException }

[21:50] <ruoso> pmichaud, yeah... something like that

[21:50] <pmichaud> afk, picking up kid

[21:51] <ruoso> and if performance is an issue... CPS might be an interesting way to solve it... the optimizer can take the exception handling code as well as the regular continuation and call $list.get(&continuation_with_value, &continuation_without_a_value)

[21:52] * spinclad was just composing something on a two-continuation model... you beat me to it

[21:53] <ruoso> but... 

[21:53] * ruoso need to run before the parking keeps his car for the night...

[21:54] <ash__> i think ruby's yield semantic is pretty elegantly and simple. then you can figure out how you want to handle all the implementation details, but its kinda an inside out way of doing things

[21:54] <spinclad> $stream.get: -> $it { ... }, { #`(eof) ... }

[21:55] <spinclad> a bit like 'if'

[21:55] * ruoso likes spinclad idea

[21:56] <ruoso> and considering .get is something that is not for the most regular use

[21:56] <ruoso> (using in list context is what the regular use will be)

[21:57] * ruoso really needs to go &

[21:57] *** ruoso left
[21:57] <ash__> i don't see the purpose of the 2nd block

[21:57] <spinclad> that's what you call if the stream is done

[21:57] <ash__> why not let the first block do that at the end of itself before it returns? 

[21:57] *** clintongormley left
[22:00] <ash__> i guess i am saying doesn't the $stream know how to handle the finishing up of things? 

[22:00] <spinclad> mm?  the first block is called if the stream isn't done.  why should the stream always be done after one value?

[22:00] <ash__> like, here, one sec, let me write an example

[22:01] <spinclad> the $stream can do what it likes.  this is what _you_ want to do if the stream is done.

[22:01] *** bluescreen left
[22:01] *** supernovus left
[22:02] <PerlJam> ash__: spinclad is basically parameterizing the iterator with the end-of-iteration action. 

[22:03] <spinclad> the $stream.get above is the same as:

[22:03] <ash__> http://gist.github.com/286309 is kinda what i was thinking

[22:04] <spinclad> if $stream.hasmore { $it = $stream.get; ... #`(first block here) } else { #`(second block here: eof) }

[22:04] <ash__> then it makes the person who implements it responsible for if they want to thread, or if they want to take things 1 at a time or 2 or n at t time

[22:06] *** fridim_ left
[22:07] <colomon> oh, I see.

[22:16] *** niros joined
[22:18] *** fridim_ joined
[22:18] *** sjohnson sets mode: +ooo spinclad ash__ colomon

[22:20] *** [particle]1 joined
[22:21] <diakopter> sigh

[22:27] <ash__> why the sigh?

[22:27] *** niros_ joined
[22:28] *** cognominal left
[22:32] *** [particle] left
[22:34] *** ejs left
[22:35] <ash__> does ng have 'loop' implemented yet?

[22:36] <ash__> its not passing S04-statements/loop.t so i guess not... 

[22:36] *** mikehh joined
[22:38] <colomon> it does have loop!

[22:39] <colomon> ng: my $a = 1; loop { say $a++; if $a == 5 { last; } }

[22:39] <p6eval> ng 7daa82: 1␤2␤3␤4␤

[22:40] *** niros left
[22:40] <ash__> hmmm it doesn't seem to be passing that test though

[22:40] <ash__> although that might be a different issue

[22:41] <ash__> maybe its the: my ($i,    $continued); in it

[22:41] <ash__> ng: my ($i,    $continued);

[22:41] <p6eval> ng 7daa82: Redeclaration of symbol $i at line 1, near ";"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤

[22:42] *** lumi left
[22:42] *** lumi joined
[22:44] <ash__> updated http://gist.github.com/286309 to an example that is functional in ng and master rakudo 

[22:45] <Tene> ash__: indeed, list declarations are NYI in ng.

[22:45] <ash__> well, maybe it passes those tests once those are working then

[22:45] *** snearch joined
[22:46] <Tene> ash__: you could rewrite that test to not use list declaration syntax.

[22:48] <ash__> i can try

[22:50] <ash__> ng: ng: my $i; loop ($i = 0; $i < 10; $i++) {} say $i;

[22:50] <p6eval> ng 7daa82: Confused at line 1, near "ng: my $i;"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤

[22:50] <ash__> part of it doesn't seem to be getting parsed correctly, i think 

[22:51] <ash__> ng: my $i; loop ($i = 0; $i < 10; $i++) {} say $i;

[22:51] <p6eval> ng 7daa82: Confused at line 1, near "loop ($i ="␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)␤

[22:51] <ash__> ng: my $i; loop ($i = 0; $i < 10; $i++) {}; say $i;

[22:51] <p6eval> ng 7daa82: 10␤

[22:51] <ash__> it seems to require a semicolon after the } on the loop, is that right? 

[22:51] <Tene> ng: my $i; loop ($i = 0; $i < 10; $i++) { say $i; }; say "done";

[22:51] <p6eval> ng 7daa82: 0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤done␤

[22:51] <Tene> ash__: if it's not the end of the line, certainly.

[22:52] <ash__> but if it is the end of the line? 

[22:52] <ash__> like, it seems to always require one

[22:52] <ash__> for ng to parse it

[22:52] <Tene> Okay.  So you either add one to the test file, as it's not incorrect to have one there, or you fix ng's parser.

[22:52] <ash__> even in the examples in the test that look like they shouldn't need one

[22:53] <ash__> well, i'd rather ng parse it correctly, so... i could do that, or i could add 1 more test that's an eval to check for the 2 cases and fudge the failing one and change the tests so they use a ; to let ng pass them...

[22:53] <ash__> i guess 2 more cases, not 1 more

[22:54] *** lucs left
[22:57] *** iblechbot left
[23:04] *** fridim_ left
[23:07] <ash__> where is the std grammar located on the pugs repo? 

[23:07] *** niros_ left
[23:08] <pmichaud> 21:55 <ruoso> and considering .get is something that is not for the most regular use

[23:08] <pmichaud> except that $file.get *is* for regular use

[23:08] <pmichaud> and as we have it spec'd now, it shouldn't throw an exception on eof

[23:10] <Tene> is EOF specced for $file.get ?

[23:10] <sjohnson> hi

[23:11] *** sundar joined
[23:11] <pmichaud> 22:03 <spinclad> if $stream.hasmore { $it = $stream.get; ... #`(first block here) } else { #`(second block here: eof) }

[23:11] <pmichaud> the problem with this is that it's possible that $stream.get actually resulted in EOF

[23:11] <pmichaud> in which case we don't want to do #`(first block here) -- we want to do the eof block

[23:11] <jettero> earlier I asked about xs in perl6, and I was told that there won't be any.  And what I really meant was: what will there be to interface with the local c libs? is that just going to be impossible? I can't accept that...

[23:12] <Tene> pmichaud: isn't that what .hasmore *is for*?  If that's the case, what does .hasore even do?

[23:12] *** Helios joined
[23:12] <pmichaud> Tene: the problem is that we often can't determine that we have more until we actually make the attempt

[23:12] <ash__> jettero: currently in rakudo, parrot supports an NCI system for calling c libs

[23:12] <pmichaud> e.g., when reading from stdinput

[23:12] <Tene> pmichaud: which means that .hasmore *needs to attempt*

[23:12] <ash__> but its part of parrot not part of perl 6

[23:13] <pmichaud> Tene: if that was implicitly assumed by spinclad's example, I didn't catch it.

[23:13] <Tene> jettero: Nothing is specified.  It's likely to be implementation-dependent.  Rakudo runs on parrot, which does support loading native libraries.

[23:13] <jettero> ash__: I don't know what NCI is, but I have something to google for.  Can you somehow invoke these from within perl6?  Surely there's got to be some plans for this kind of thing.

[23:13] <Tene> pmichaud: it's iplicit in the assumption that .hasmore would actually be useful for anything.

[23:13] <jettero> There's a way for perl6 to speak implementation dependantly to the underlying implementation? or something?

[23:14] <ash__> yes, you can call them from perl6, but like Tene said, tis implementation dependent 

[23:14] <ash__> s/tis/its/

[23:14] <jettero> excuse my giberish.. I"m a little surprised by the answers I'm getting.  I can't imagine not being able to ... invoke a syscall, or the like

[23:14] <Tene> jettero: Yes, Rakudo can talk to C just fine.  I've used it several ties.

[23:15] <ash__> sys calls are different, it can open another program if you want, thats in the spec, but calling a .so or .dylib or .dll is different

[23:15] <jettero> well,I don't mean like exec() necessarily, but any of the POSIX stuff probably comes from a .so

[23:16] <jettero> and to write windows modules you'd need something like Win32 stuff... or gtk or wx...

[23:16] *** lumi left
[23:16] *** lumi joined
[23:16] <Tene> jettero: parrot has a 'loadlib' opcode that loads a .so or .dylib or .dll or whatever, and a 'dlfunc' opcode to get symbols fro it.

[23:16] <Tene> jettero: look at http://github.com/tene/parrot-elementary/blob/master/Elementary.pir for an example.

[23:17] <jettero> so you can write extensions for perl6, they're just implementation specific...

[23:17] <ash__> yeah, that would be in S21 Calling Foreign Code but its really more of an implementation dependant functionality, rakudo has it out of the box, you might need to write some helpers though but it does work in parrot code

[23:17] <Tene> jettero: To use that PIR file from Perl 6, you would say: "use Elementary:from<parrot>;"

[23:17] <jettero> ok, great

[23:18] <jettero> I apparently just didn't know how to ask the qeustion

[23:18] <pmichaud> jettero: it's implementation specific at the moment because we're looking for a reasonable "common interface".  Someday there will likely be a defacto standard -- the language doesn't prescribe one at this time.

[23:18] <ash__> yeah xs specifically is gone, but there is a way to work around it

[23:18] <Tene> jettero: I've seen a few projects that attept to auto-generate that stuff by parsing C header files, but I haven't seen any that are usable enough yet.

[23:18] <pmichaud> afk, dinner

[23:19] <jettero> yeah, I'm not in love with xs... I just wanted to know you can get down to the bottom, so to speak.  And I know it's not done, but I didn't know how to read about what's working and what's not

[23:20] <ash__> jettero http://perlcabal.org/syn/ has a list of all the specs, and you can alway download your favorite perl 6 implemenation and run its test suite (if it has one) 

[23:20] <Tene> jettero: I' glad that I could help.  Feel free to ask e for ore inforation if you want to actually try it yourself.  I'd be glad to help.

[23:21] <ash__> a bunch of the specs (most actually) are still drafts since none of the implementations have solidified the details on them yet 

[23:26] *** xinming joined
[23:32] *** niros joined
[23:32] *** xinming_ left
[23:36] *** ash__ left
[23:36] *** snearch left
[23:36] *** ash_ joined
[23:40] *** ihrd joined
[23:40] *** ihrd left
[23:42] <pmichaud> (more iterator thoughts)

[23:43] <pmichaud> if we go with an exception-based model, and if we expect  my $line = $file.get // 'default';  to continue to work, then .get shouldn't be the thingy that throws an exception.

[23:44] <pmichaud> that implies to me that an iterator probably implements some method other than .get to mean "get the next element and signal eof", and .get is a wrapper/driver method of some sort.

[23:47] <pmichaud> or, we go with something like what spinclad++ was mentioning, where something supplies an iterator a block that indicates code to be run when retrieving the next element would reach end-of-iteration

[23:47] <pmichaud> (end of thoughts for the moment)

[23:48] <pmichaud> afk, rb2

[23:49] <jettero> Tene: thanks, yes, you did help.  Is this channel logged? or shouldI attempt to cut and paste it?

[23:49] <jettero> (all those URLs)

[23:49] <Tene> jettero: This channel is logger.

[23:49] <jettero> k, I'll probably look for it tomorrow then. thanks again

[23:51] *** payload left
[23:51] *** payload joined
[23:51] <Tene> The log is at http://irc.pugscode.org/

[23:51] <jettero> super

[23:55] *** lumi left
[23:55] *** lumi joined
[23:55] *** ash_ left
[23:59] *** nihiliad left
