[00:01] <TimToady> well, i vs Ä« can be worse; usually makes it a different verb, kita vs kiita

[00:02] *** Psyche^ joined
[00:03] <lue> would the u in rune be a better approximation than the oo in boot? [en:wikipedia page for Japanese IPA says the latter, but that doesn't seem right]

[00:03] <TimToady> those are the same sound in my dialect

[00:04] <TimToady> though boot is perhaps a better example because un will tend to be pre-nasalized

[00:04] <diakopter> rakudo: my$n=3;my@m=0 xx (my$v=$n*$n);my($r,$c,$d)=$n div 2,$n div 2-($n %% 2),($n %% 2??2!!4);sub t{$d=4 if --$d<1};sub m{if $d%%2 {$r+=$d==4??-1!!1}else {$c+=$d==3??-1!!1}};sub l{t;m;my$x=@m[$r*$n+$c];t;t;m;t;$x};while $v {@m[$r*$n+$c]=--$v;t if!l;m};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n

[00:04] <p6eval> rakudo d9aa57: OUTPUTÂ«0 1 2â¤7 8 3â¤6 5 4â¤Â»

[00:05] <TimToady> and r also tends to distort nearby sounds in english

[00:05] <lue> mine too, just wondering if there was a molecule of difference between the two [and curses to the wide array of accents in English]

[00:05] <diakopter> rakudo: my$n=4;my@m=0 xx (my$v=$n*$n);my($r,$c,$d)=$n div 2,$n div 2-($n %% 2),($n %% 2??2!!4);sub t{$d=4 if --$d<1};sub m{if $d%%2 {$r+=$d==4??-1!!1}else {$c+=$d==3??-1!!1}};sub l{t;m;my$x=@m[$r*$n+$c];t;t;m;t;$x};while $v {@m[$r*$n+$c]=--$v;t if!l;m};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n

[00:05] <p6eval> rakudo d9aa57: OUTPUTÂ« 0  1  2  3â¤11 12 13  4â¤10 15 14  5â¤ 9  8  7  6â¤Â»

[00:05] <diakopter> TimToady: :)

[00:05] <diakopter> it's a turtle

[00:05] <TimToady> especially if you pronounce boot with a glo'al stop at the end, it sounds cut off like a japanes would pronounce bu

[00:06] *** Patterner left
[00:06] *** Psyche^ is now known as Patterner

[00:06] <TimToady> because they would be distinguishing it from buu

[00:07] * lue is reminded of how the phrase 'glottal stop' is like the term 'lisp': if you have it, saying what it is will give you away.

[00:07] <diakopter> TimToady: that's a Turtle-y spiral matrix you were discussing... now if only it could be more idiomatic p6

[00:07] <TimToady> yes, also "shibboleth" in the original usage

[00:08] <diakopter> lots o' help from masak++ on the last statement (outputting)

[00:08] <TimToady> yes, a number of solutions do it that way.  I was thinking of something that abstracted the turtle's direction a little more

[00:10] <diakopter> the non-golfed-for-p6eval-irc is a bit easier to read, but not by much

[00:11] <diakopter> I didn't see [m]any solutions that started from the middle...?

[00:12] <TimToady> the nice thing about starting from the middle is you don't have to worry about edges

[00:12] <TimToady> and the nice thing about starting from the edges is you don't have to worry about the middle :)

[00:13] <diakopter> heh

[00:13] *** justatheory left
[00:13] <diakopter> any suggestions for cleaning up this?  fmt('%'~($n*$n).Str.chars~'d')

[00:14] <TimToady> lemme play with it a bit

[00:14] <diakopter> (pad for the largest item)

[00:14] <diakopter> I couldn't get an interpolating edition

[00:14] <diakopter> er, that's supposed to be fmt('%'~($n*$n-1).Str.chars~'d')

[00:15] <sorear> I chose rune because it's one letter

[00:15] <diakopter> masak suggested log10 but I couldn't begin to guess how to do that in rakudo

[00:15] <sorear> my brain was too much in Japanese mode to realize that boot and rune had the same vowel length

[00:15] <TimToady> but the r and the n rune the sound of it

[00:15] <Tene> diakopter: fmt() takes two args.

[00:15] <sorear> lue: any more questions?

[00:17] <diakopter> Tene: it's from my last msg to rakudo above

[00:17] <diakopter> the last statement

[00:17] <Tene> oh

[00:18] <TimToady> the parens around ($n %% 2) should be unnecessary

[00:18] <TimToady> and you won't get that proggy past STD

[00:19] <TimToady> std: my$n=4;my@m=0 xx (my$v=$n*$n);my($r,$c,$d)=$n div 2,$n div 2-($n %% 2),($n %% 2??2!!4);sub t{$d=4 if --$d<1};sub m{if $d%%2 {$r+=$d==4??-1!!1}else {$c+=$d==3??-1!!1}};sub l{t;m;my$x=@m[$r*$n+$c];t;t;m;t;$x};while $v {@m[$r*$n+$c]=--$v;t if!l;m};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n

[00:19] <p6eval> std 32108: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Variable $r is not predeclared at /tmp/KfWfpjIrl1 line 1:â¤------> [32mmy$n=4;my@m=0 xx (my$v=$n*$n);my($r[33mâ[31m,$c,$d)=$n div 2,$n div 2-($n %% 2),($n [0mâ¤Variable $c is not predeclared at /tmp/KfWfpjIrl1 line 1:â¤------> [32mmy$n=4;my@m=0 xx

[00:19] <p6eval> ..(â€¦

[00:20] <TimToady> for more than one reason

[00:20] <TimToady> std: my$n=4;my@m=0 xx (my$v=$n*$n);my ($r,$c,$d)=$n div 2,$n div 2-($n %% 2),($n %% 2??2!!4);sub t{$d=4 if --$d<1};sub m{if $d%%2 {$r+=$d==4??-1!!1}else {$c+=$d==3??-1!!1}};sub l{t;m;my$x=@m[$r*$n+$c];t;t;m;t;$x};while $v {@m[$r*$n+$c]=--$v;t if!l;m};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n

[00:20] <p6eval> std 32108: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Whitespace required before < operator at /tmp/TxYJUO0W7d line 1:â¤------> [32m% 2),($n %% 2??2!!4);sub t{$d=4 if --$d<[33mâ[31m1};sub m{if $d%%2 {$r+=$d==4??-1!!1}else[0mâ¤    expecting escapeâ¤Parse failedâ¤FAILED 00:01 123mâ¤Â»

[00:20] <TimToady> std: my$n=4;my@m=0 xx (my$v=$n*$n);my ($r,$c,$d)=$n div 2,$n div 2-($n %% 2),($n %% 2??2!!4);sub t{$d=4 if --$d <1};sub m{if $d%%2 {$r+=$d==4??-1!!1}else {$c+=$d==3??-1!!1}};sub l{t;m;my$x=@m[$r*$n+$c];t;t;m;t;$x};while $v {@m[$r*$n+$c]=--$v;t if!l;m};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n

[00:21] <p6eval> std 32108: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Variable $x is not predeclared at /tmp/ag_0yV1sh1 line 1:â¤------> [32m}else {$c+=$d==3??-1!!1}};sub l{t;m;my$x[33mâ[31m=@m[$r*$n+$c];t;t;m;t;$x};while $v {@m[$[0mâ¤Two terms in a row at /tmp/ag_0yV1sh1 line 1:â¤------> [32m=3??-1!!1}};sub

[00:21] <p6eval> ..l{t;m;my$â€¦

[00:23] * diakopter confuzzled

[00:25] <diakopter> I read through them all again; none start from the middle

[00:25] <diakopter> unless you count the recursive ones that rotate/swap

[00:25] <diakopter> but I'm not

[00:25] <diakopter> I don't get why STD doesn't like it

[00:27] <TimToady> m;foo;bar;

[00:27] <TimToady> rakudo is letting you get into bad habits

[00:28] <diakopter> what's wrong with m;foo;bar

[00:28] <diakopter> oh; heh.

[00:30] <diakopter> std: my$n=2;my@m=0 xx (my$v=$n*$n);my ($r,$c,$d)=$n div 2,$n div 2-$n%%2,($n%%2??2!!4);sub t{$d=4 if --$d <1};sub f{if $d%%2 {$r+=$d==4??-1!!1}else {$c+=$d==3??-1!!1}};sub l{t;f;my$x=@m[$r * $n+$c];t;t;f;t;$x};while $v {@m[$r*$n+$c]=--$v;t if!l;f};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n

[00:30] <p6eval> std 32108: OUTPUTÂ«ok 00:02 123mâ¤Â»

[00:30] <diakopter> rakudo: my$n=2;my@m=0 xx (my$v=$n*$n);my ($r,$c,$d)=$n div 2,$n div 2-$n%%2,($n%%2??2!!4);sub t{$d=4 if --$d <1};sub f{if $d%%2 {$r+=$d==4??-1!!1}else {$c+=$d==3??-1!!1}};sub l{t;f;my$x=@m[$r * $n+$c];t;t;f;t;$x};while $v {@m[$r*$n+$c]=--$v;t if!l;f};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n

[00:30] <p6eval> rakudo d9aa57: OUTPUTÂ«0 1â¤3 2â¤Â»

[00:31] *** macroron left
[00:32] <TimToady> Perl 6 is not trying to be a golf-friendly language...

[00:35] *** drbean joined
[00:37] *** awwaiid left
[00:39] <diakopter> added; feel free to edit/replace it... :) http://rosettacode.org/wiki/Spiral_matrix#Perl_6

[00:42] <TimToady> working on it

[00:44] *** awwaiid joined
[00:52] *** whiteknight left
[00:52] <lue> I find rosettacode a fun repository of stuff to try to code.

[01:08] *** risou_ left
[01:20] *** bjarneh joined
[01:26] *** kid51 joined
[01:27] <diakopter> rakudo: my$n=4;my@m=0 xx (my$v=$n*$n);my ($r,$c,$z)=0,0,0;while $v >= ($n*$n) div 2 { @m[($n-$r-1)*$n+$n-$c-1]=$v - 1; @m[$r*$n+$c]=$n*$n - --$v - 1; if $z%%2 { ++$c; if $r {--$r} else {++$z}  } else { ++$r; if $c {--$c} else {++$z} }};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n # zigzag array

[01:27] <p6eval> rakudo d9aa57: OUTPUTÂ« 0  1  5  6â¤ 2  4  7 12â¤ 3  8 11 13â¤ 9 10 14 15â¤Â»

[01:33] <diakopter> rakudo: my$n=2;my@m=0 xx (my$v=$n*$n);my ($r,$c,$z)=0,0,0;while $v >= ($n*$n) div 2 { @m[($n-$r-1)*$n+$n-$c-1]=$v - 1; @m[$r*$n+$c]=$n*$n - --$v - 1; if $z%%2 { ++$c; if $r {--$r} else {++$z}  } else { ++$r; if $c {--$c} else {++$z} }};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n # zigzag array

[01:33] <p6eval> rakudo d9aa57: OUTPUTÂ«0 1â¤2 3â¤Â»

[01:33] <diakopter> rakudo: my$n=1;my@m=0 xx (my$v=$n*$n);my ($r,$c,$z)=0,0,0;while $v >= ($n*$n) div 2 { @m[($n-$r-1)*$n+$n-$c-1]=$v - 1; @m[$r*$n+$c]=$n*$n - --$v - 1; if $z%%2 { ++$c; if $r {--$r} else {++$z}  } else { ++$r; if $c {--$c} else {++$z} }};say ~@m.splice(0,$n).fmt('%'~($n*$n).Str.chars~'d') for ^$n # zigzag array

[01:33] <p6eval> rakudo d9aa57: OUTPUTÂ«Cannot modify readonly valueâ¤  in '&infix:<=>' at line 1â¤  in main program body at line 22:/tmp/JnMS7YQnqGâ¤Â»

[01:33] <diakopter> oops

[01:36] *** Transformer joined
[01:38] *** Transformer left
[01:39] *** justatheory joined
[01:42] <sorear> rakudo: my$n=5;sub k($n,$x,$y){$n==1??1!!($x!=$n-1)??($y??($n*2-1+k($n-1,$n-2-$x,$n-1-$y))!!$x+1)!!$n+$y};for^$n ->$y{(^$n).map({k($n,$_,$y)}).Str.say}

[01:42] <p6eval> rakudo d9aa57: OUTPUTÂ«1 2 3 4 5â¤16 17 18 19 6â¤15 24 25 20 7â¤14 23 22 21 8â¤13 12 11 10 9â¤Â»

[01:42] <diakopter> oooo cool

[01:43] *** justatheory left
[01:44] <Getty> is there btw already a twitter account for that rakudo eval? lol

[01:44] <sorear> twitter? why?

[01:44] <Getty> just funny marketing ;)

[01:45] <diakopter> heh

[01:45] <Getty> you make @rakudo_eval something and he replies with @youraccount OUTPUT

[01:46] <sorear> p6eval already runs on freenode and magnet, maybe something could be done with twirc

[01:46] <sorear> <-- clueless twitter non-user

[01:46] <Getty> yeah twirc could work with a bit tweeking on the botside (the bot must anyway use the twirc server)

[01:47] <Getty> but Net::Twitter is anyway hell easy stuff

[01:47] <sorear> the closest I've come to any twitter stuff was a nethack bot that tweeted high scores

[01:49] <diakopter> now the coolest would be an omegle client

[01:50] <diakopter> try to find a chat buddy; get rakudo!

[01:53] <sorear> rakudo: my @a = (1); @a Â»+=Â» 2;

[01:53] <p6eval> rakudo d9aa57: OUTPUTÂ«Cannot modify readonly valueâ¤  in '&infix:<=>' at line 1â¤  in <anon> at line 204:CORE.settingâ¤  in 'hyper' at line 1â¤  in 'hyper' at line 211:CORE.settingâ¤  in main program body at line 1â¤Â»

[01:53] <sorear> are lvalue arrays broken?

[01:57] <colomon> might just be broken with respect to hyper

[01:58] <sorear> rakudo: my @r = (1, 2, 3); @rÂ»++; # stolen from S03-metaops/hyper.t

[01:58] <p6eval> rakudo d9aa57:  ( no output )

[01:58] <sorear> rakudo: my @r = (1, 2, 3); @rÂ»+=Â» 5;

[01:58] <p6eval> rakudo d9aa57: OUTPUTÂ«Cannot modify readonly valueâ¤  in '&infix:<=>' at line 1â¤  in <anon> at line 204:CORE.settingâ¤  in 'hyper' at line 1â¤  in 'hyper' at line 211:CORE.settingâ¤  in main program body at line 1â¤Â»

[01:58] <sorear> so I guess Â»+=Â» is the problematic one

[01:58] <colomon> rakudo: my @r = (1, 2, 3); @rÂ»++; say @r.perl

[01:58] <p6eval> rakudo d9aa57: OUTPUTÂ«[2, 3, 4]â¤Â»

[01:59] <colomon> looks like.

[02:00] <sorear> rakudo: my @a = [1,2],[3,4]; say @a.perl

[02:00] <p6eval> rakudo d9aa57: OUTPUTÂ«[[1, 2], [3, 4]]â¤Â»

[02:00] <sorear> rakudo: my @a = [1,2],[3,4]; @a = @aÂ».reverse; say @a.perl

[02:00] <p6eval> rakudo d9aa57: OUTPUTÂ«[2, 1, 4, 3]â¤Â»

[02:01] *** kid51 left
[02:01] <sorear> any good way to prevent flattening?

[02:02] <sorear> @aÂ».=reverse seems to not-flatten

[02:04] <colomon> rakudo: my @a = [1,2],[3,4]; say @a.perl; say @a>>.reverse.perl

[02:04] <p6eval> rakudo d9aa57: OUTPUTÂ«[[1, 2], [3, 4]]â¤([2, 1], [4, 3])â¤Â»

[02:05] <colomon> It's the = part in @a = @aÂ».reverse which is doing the flattening, maybe?

[02:06] <sorear> what's happening is that .reverse returns a flatteny list

[02:06] <sorear> this is needed in order for @a = @a.reverse to work

[02:08] <colomon> hmmm?

[02:08] <colomon> rakudo: say [1, 2, 3, 4].reverse.perl

[02:08] <p6eval> rakudo d9aa57: OUTPUTÂ«[4, 3, 2, 1]â¤Â»

[02:08] <sorear> .perl doesn't show flatteny

[02:09] <sorear> the act of calling a method strips off the flatteny bit

[02:09] <sorear> (ObjectRef w/ 'scalar' prop, in Rakudo)

[02:10] <sorear> rakudo: my$n=5;my@a=[1];for 2..$n ->$o{@aÂ».=reverse;@a=[1..$o-1],(@aÂ»Â»+Â»Â»($o*2-1)).reverse;for@a Z ($o..$o*2-1) { $^a.push($^b)}};.Str.say for @a

[02:10] <p6eval> rakudo d9aa57: OUTPUTÂ«1 2 3 4 5â¤16 17 18 19 6â¤15 24 25 20 7â¤14 23 22 21 8â¤13 12 11 10 9â¤Â»

[02:10] <sorear> diakopter: non-recursive list version

[02:23] <diakopter> :)

[02:24] <sorear> do you like either of them enough to use?

[02:30] <sorear> rakudo: say $*IN.getc.perl

[02:31] <p6eval> rakudo d9aa57: OUTPUTÂ«src/gc/gc_ms.c:1234: failed assertion 'PObj_is_movable_TESTALL(str)'â¤Backtrace - Obtained 20 stack frames (max trace depth is 32).â¤/home/p6eval//p2/lib/libparrot.so.2.7.0 [0x2ad8964641a3]â¤/home/p6eval//p2/lib/libparrot.so.2.7.0(Parrot_confess+0x87)

[02:31] <p6eval> ..[0x2ad8964642d7]â¤/home/p6eval//p2â€¦

[02:31] <sorear> reading a single character from stdin appears to be impossible

[02:37] <diakopter> sorear: well, yeah. :) they're certainly more idiomatic. also, enigmatic, since I can't read them. of course, I haven't tried very hard.

[02:38] *** yrgd joined
[02:39] <sorear> here's a hint: they're both based on the recursion principle

[02:39] <sorear> the spiral matrix of order N contains the spiral matrix of order N-1, shifted 1 down, rotated 180 degrees, and with 2*N-1 added to each element

[02:49] *** lue left
[02:49] <sorear> rakudo really ought to have nightlies

[02:50] *** molaf joined
[03:01] <diakopter> sorear: yeah I understood the solutions that used that technique; I just didn't get that from your code

[03:07] <sorear> probably because my code was so golfed, eh?

[03:08] *** meppl left
[03:14] <diakopter> sorear: à² Yà²  yeah :)

[03:20] <sorear> .u à² 

[03:20] <phenny> U+0CA0 KANNADA LETTER TTHA (à² )

[03:20] <sorear> kannawhat

[03:24] <TiMBuS> à² _à² 

[03:24] <sorear> .u à² 

[03:24] <phenny> U+0CA0 KANNADA LETTER TTHA (à² )

[03:31] <isBEKaml> kannada? :)

[03:31] <isBEKaml> http://www.google.com/transliterate

[03:32] <isBEKaml> I don't know kannada, but that's one of the spoken Indian languages. 

[03:36] <sorear> according to wikipedia kannada is also a script

[03:37] <isBEKaml> I didn't literally mean *spoken*, but yes, it has its own script and spoken largely in Karnataka, one of the states in India. 

[03:39] <isBEKaml> Many Indian languages have their own written forms, only a few take forms from other Indian languages or don't have any at all(very few, I know only one here)

[03:39] <isBEKaml> Though in the former case, it's largely Devanagari. 

[03:46] <isBEKaml> .u U+0BA4

[03:46] <phenny> isBEKaml: Sorry, no results

[03:46] <isBEKaml> .u 0BA4

[03:46] <phenny> U+0BA4 TAMIL LETTER TA (à®¤)

[03:47] *** leprevost joined
[03:58] *** yrgd left
[04:12] *** shade\ left
[04:14] *** shade\ joined
[04:20] *** cognominal left
[04:20] *** cognominal joined
[04:22] *** molaf left
[04:22] *** yrgd joined
[04:27] *** envi^home joined
[04:35] *** justatheory joined
[04:49] *** drbean left
[05:12] * sorear reads on llvm

[05:18] *** justatheory left
[05:59] *** Guest23195 joined
[06:09] *** awwaiid left
[06:13] <sorear> it looks like llvm will not work well for a niecza target

[06:13] <sorear> it's a bit too ll

[06:14] <sorear> notably, I'd have to come up with my own garbage collector, and some thread sync stuff

[06:36] <sorear> How bad would it be if for ^* { eval q:s"class { method m$_ { } }" } # leaked memory?

[06:40] * sorear idly wonders how much faster nqp-rx would be with dynops

[06:45] *** bjarneh left
[06:59] *** zag joined
[07:05] *** drbean joined
[07:13] *** Ross joined
[07:17] *** azawawi joined
[07:18] <azawawi> hi

[07:18] <azawawi> sorear: ping

[07:29] <sorear> pong

[07:29] <azawawi> sorear: I remember you said before about making viv more re-usable. Is that still the case?

[07:30] <sorear> not reusable; installable

[07:31] <azawawi> sorear: i see

[07:33] <azawawi> sorear: When I based Perl6::Refactor on viv (not complete), I found out that updating custom-viv scripts are a bit hard on the maintaince part. That's why I am asking about the re-usability.

[07:34] <sorear> azawawi: if you're trying to reuse viv, you're doing it wrong

[07:35] <azawawi> sorear: what's the correct way of doing it then?

[07:35] <sorear> use STD;

[07:35] <sorear> the reusable part of viv is called STD.pmc

[07:35] <sorear> you're only the second person to think that using any of the code in viv is a good idea

[07:35] <sorear> I have no clue why people think that

[07:36] <sorear> viv is a perl 6 to perl 5 compiler based on the STD framework

[07:36] <sorear> nothing more

[07:36] <sorear> you'll notice that none of the official tools use viv

[07:37] <azawawi> Part of it comes from being able to hack viv scripts faster.

[07:37] <sorear> ?

[07:37] <azawawi> The tree is already represented in a OO-form that one can use right away.

[07:38] <sorear> that's not even part of viv

[07:39] <sorear> that's standard functionality of STD

[07:40] <azawawi> I see. Thanks. I will try to re-use STD then. I was thinking in doing a PPI-like package first to simplify things a bit.

[07:41] <sorear> What does PPI do that STD doesn't?

[07:41] <azawawi> wrap it like PPI... search functionality

[07:42] <sorear> (note: the viv syntax tree is not quite the same as the native STD syntax tree; there's an impedence matching layer in Actions.pm.  As far as I can tell it brings no benefits, only bugs and slowness, so I don't use it in new projects)

[07:42] <sorear> I had to fix about four bugs in Actions before it could correctly mediate the full syntax tree from parsing STD.pm6

[07:43] <sorear> azawawi: xpathy stuff?

[07:43] <azawawi> sorear: simpler, http://search.cpan.org/~adamk/PPI-1.213/lib/PPI/Find.pm

[07:45] <azawawi> sorear: although representing whitespace and comments maybe a problem with STD.pm if i remember correctly

[07:46] <azawawi> sorear: To do proper solid refactor tools, you need to be able to search & traverse the parse tree for matches.

[08:06] <sorear> azawawi: viv (older versions) preserved whitespace and comments by passing through the text between submatches verbatim

[08:07] <sorear> look at viv around line 500-520 for inspiration

[08:07] * azawawi looks above for more inspiration :)

[08:07] <azawawi> sorear: thx

[08:08] *** zulon joined
[08:11] *** azawawi left
[08:12] *** patspam left
[08:19] *** Mowah joined
[08:20] *** envi^home left
[08:24] *** zag left
[08:27] <moritz_> moin

[08:33] *** envi^home joined
[08:45] <moritz_> rakudo: my $x = 2; say 'aaaa' ~~ /a ** $x /

[08:45] <p6eval> rakudo d9aa57: OUTPUTÂ«aâ¤Â»

[08:48] <moritz_> rakudo: my $x = 2; say 'aaaa' ~~ /a ** {$x} /

[08:48] <p6eval> rakudo d9aa57: OUTPUTÂ«aaaaâ¤Â»

[08:49] <moritz_> rakudo: my $x = 2; say 'aaaa' ~~ /a ** <?{$x}> /

[08:49] <p6eval> rakudo d9aa57: OUTPUTÂ«aaaaâ¤Â»

[08:49] <moritz_> rakudo: my $x = 2; say 'aaaa' ~~ /a ** <{$x}> /

[08:49] <p6eval> rakudo d9aa57: OUTPUTÂ«aâ¤Â»

[08:52] <moritz_> how do I quantify with a variable number?

[09:10] *** drbean left
[09:11] *** isBEKaml left
[09:43] *** Ross left
[09:56] <pugssvn> r32109 | sorear++ | [viv] use Getopt::Long 

[09:58] *** whiteknight joined
[10:06] *** christine left
[10:15] *** meppl joined
[10:28] *** christine joined
[10:31] *** risou_ joined
[10:32] *** M_o_C joined
[10:36] *** molaf joined
[10:45] *** risou_ left
[11:11] *** espadrine` joined
[11:17] *** zulon left
[11:32] *** nimiezko joined
[11:41] *** Alias joined
[11:46] *** M_o_C left
[12:04] *** whiteknight left
[12:09] *** zulon joined
[12:13] *** stepnem left
[12:14] *** stepnem joined
[12:16] *** jaldhar left
[12:17] *** drbean joined
[12:22] *** kirillm left
[12:23] *** amkrankruleuen joined
[12:25] *** amkrankr1leuen joined
[12:25] *** stepnem left
[12:26] *** amkrankruleuen left
[12:26] *** amkrankr1leuen is now known as amkrankruleuen

[12:28] *** amkrankruleuen left
[12:30] *** stepnem joined
[12:30] *** stepnem left
[12:34] *** stepnem joined
[12:40] *** feiquet joined
[12:40] *** espadrine` left
[12:46] *** plluksie joined
[12:49] <nimiezko> rakudo: (+"2").WHAT

[12:49] <p6eval> rakudo d9aa57:  ( no output )

[12:49] *** PacoLinux joined
[12:49] <nimiezko> rakudo: (+"2").HOW

[12:49] <p6eval> rakudo d9aa57:  ( no output )

[12:50] <nimiezko> rakudo my Int $a = +"2" ;

[12:50] *** dimid left
[12:50] <nimiezko> rakudo: my Int $a = +"2" ;

[12:50] <p6eval> rakudo d9aa57: OUTPUTÂ«Type check failed for assignmentâ¤  in '&infix:<=>' at line 1â¤  in main program body at line 22:/tmp/A55G4LSrJkâ¤Â»

[12:53] <TiMBuS> rakudo: say (+"2").WHAT

[12:53] <p6eval> rakudo d9aa57: OUTPUTÂ«Num()â¤Â»

[12:54] <TiMBuS> that's a reported bug

[12:54] *** kirillm joined
[12:55] *** amkrankruleuen joined
[12:55] <TiMBuS> rakudo: my Int $a = "2".Int; $a.say

[12:55] <p6eval> rakudo d9aa57: OUTPUTÂ«2â¤Â»

[13:03] *** rgrau_ joined
[13:09] *** orafu left
[13:09] *** orafu joined
[13:11] *** drbean left
[13:13] <nimiezko> TiMBuS: thanks

[13:14] <TiMBuS> that's alright

[13:14] <nimiezko> and why is there e

[13:15] <nimiezko> a difference between : 

[13:15] <nimiezko> rakudo: map { ["a", @^t] }, [2] ;

[13:15] <p6eval> rakudo d9aa57:  ( no output )

[13:15] <TiMBuS> you gotta make the bot print it

[13:15] <nimiezko> Yes, I just begin to understand it

[13:16] <nimiezko> rakudo: say (map { ["a", @^t] }, [2]).perl ;

[13:16] <p6eval> rakudo d9aa57: OUTPUTÂ«(["a", 2])â¤Â»

[13:17] <nimiezko> rakudo: say (map ({ ["a", @^t] }, [2])).perl ;

[13:17] <p6eval> rakudo d9aa57: OUTPUTÂ«No candidates found to invoke for method 'map' on object of type 'Array'; available candidates have signatures:â¤:(Mu : &block;; *%_)â¤â¤  in 'map' at line 1723:CORE.settingâ¤  in main program body at line 22:/tmp/A1bwGx7yabâ¤Â»

[13:17] <nimiezko> I just put some parenthesis in between.

[13:18] <TiMBuS> rakudo: say (map({ ["a", @^t] }, [2])).perl ;

[13:18] <p6eval> rakudo d9aa57: OUTPUTÂ«(["a", 2])â¤Â»

[13:19] *** jhuni left
[13:19] <nimiezko> ok, understand it. function call vs. list construct

[13:19] <TiMBuS> yep that's it

[13:19] <TiMBuS> you can use unspace

[13:19] <TiMBuS> function\ ('args')

[13:20] <TiMBuS> but yeah it's best to avoid that

[13:21] <nimiezko> the error message was not really helpful to me

[13:24] <TiMBuS> you're right, but I'm not sure how to check for that error

[13:24] *** dual left
[13:26] <nimiezko> The thing is that the error message does not say what it considers to be arguments for the called function

[13:28] <nimiezko> I did not understood what was exactly the "object of type 'Array'"

[13:29] *** risou joined
[13:40] <TiMBuS> well, technically it didn't have any arguments

[13:40] <TiMBuS> since it saw it as map(Array: )

[13:41] <TiMBuS> which is the same as Array.map()

[13:41] <TiMBuS> or, mostly the same

[13:43] *** masak joined
[13:43] <masak> oh hai, #perl6!

[13:44] <nimiezko> The thing was to identify this "Array" when you are persuaded to have two distinct elements (a block code and an Array)

[13:51] <masak> \ã‹¡/

[13:57] <TiMBuS> Cannot resume dead coroutine.

[13:57] <TiMBuS> well thats odd..

[13:58] <TiMBuS> I was trying to shorten haskells pascal's triangle example

[13:58] <TiMBuS> @list := gather loop { take ((0, @list) Z+ (@list, 0)) };

[13:59] <masak> rakudo: @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; say 'alive'

[13:59] <p6eval> rakudo d9aa57: OUTPUTÂ«===SORRY!===â¤Symbol '@list' not predeclared in <anonymous> (/tmp/9x6ih5tQ73:22)â¤Â»

[14:00] <masak> rakudo: my @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; say 'alive'

[14:00] <p6eval> rakudo d9aa57: OUTPUTÂ«aliveâ¤Â»

[14:00] <TiMBuS> it stays alive, it just refuses to work

[14:00] <TiMBuS> i guess its because @list wont change each take

[14:00] <masak> rakudo: my @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; say @list[0, 1, 2]

[14:00] <p6eval> rakudo d9aa57:  ( no output )

[14:00] <masak> hm. :/

[14:01] <TiMBuS> it makes some of haskells self-referential lists impossible

[14:01] <TiMBuS> stick with '...' i guess

[14:01] <masak> I'd love to cram a rakudobug out of what you just said, though.

[14:02] <masak> worst thing I see so far is that it doesn't give any output when told to do so.

[14:02] <masak> a red-handed "Cannot resume dead coroutine" would be great.

[14:02] * masak tries locally

[14:03] <masak> prints nothing here either.

[14:06] *** espadrine joined
[14:23] <TiMBuS> masak, 

[14:23] <TiMBuS> my @list = 1; @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; @list[1]

[14:23] <TiMBuS> try that

[14:26] <TiMBuS> wait why don't i just try that

[14:26] <TiMBuS> rakudo: my @list = 1; @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; @list[1

[14:26] <TiMBuS> uh

[14:26] <p6eval> rakudo d9aa57: OUTPUTÂ«===SORRY!===â¤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 22â¤Â»

[14:26] <TiMBuS> rakudo: my @list = 1; @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; @list[1]

[14:26] <p6eval> rakudo d9aa57:  ( no output )

[14:26] <TiMBuS> :/

[14:26] <TiMBuS> rakudo: my @list = 1; @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; say @list[2]

[14:26] <p6eval> rakudo d9aa57:  ( no output )

[14:26] <masak> locally, it also outputs nothing.

[14:27] *** dual joined
[14:27] <TiMBuS> well its gotta output something

[14:28] <TiMBuS> i think i have both the latest parrot and rakudo revisions

[14:29] <masak> I might not.

[14:29] <masak> but p6eval ought to.

[14:30] <TiMBuS> rakudo: my @list = 1; @list := gather loop { take ((0, @list) Z+ (@list, 0)) }; say @list[2]; say 'wtf';

[14:30] <p6eval> rakudo d9aa57: OUTPUTÂ«wtfâ¤Â»

[14:30] <TiMBuS> well ive got no idea then

[14:31] *** risou left
[14:31] *** risou_ joined
[14:31] <TiMBuS> oookay so, locally that second one works

[14:32] *** risou_ left
[14:32] <TiMBuS> but without the second 'say' i get the error

[14:32] *** risou_ joined
[14:32] <masak> :/

[14:32] <TiMBuS> ===SORRY!===â¤Cannot resume dead coroutine.

[14:32] <masak> seems quite elusive still.

[14:33] <masak> but that error definitely has to do with gather/take.

[14:33] <masak> pmichaud++ will know more.

[14:33] <TiMBuS> actually, if I use >>+<< instead of Z+

[14:34] <TiMBuS> i get no error

[14:35] <TiMBuS> in fact it works as expected

[14:37] <masak> workarounds++

[14:37] *** timbunce joined
[14:37] <TiMBuS> well it doesn't work how I want it to, but it works how perl wants it to

[14:37] <TiMBuS> probably

[14:38] <TiMBuS> rakudo: @list := gather { my $z = 1; loop { $z = take ((0, $z) >>+<< ($z, 0)) } }; say @list[2];

[14:38] <p6eval> rakudo d9aa57: OUTPUTÂ«===SORRY!===â¤Symbol '@list' not predeclared in <anonymous> (/tmp/0m8GuNiwW5:22)â¤Â»

[14:38] <TiMBuS> arg

[14:38] <TiMBuS> rakudo: my @list := gather { my $z = 1; loop { $z = take ((0, $z) >>+<< ($z, 0)) } }; say @list[2];

[14:38] <p6eval> rakudo d9aa57: OUTPUTÂ«Sorry, sides are of uneven length and not dwimmy.â¤  in 'hyper' at line 179:CORE.settingâ¤  in <anon> at line 202:CORE.settingâ¤  in 'hyper' at line 1â¤  in <anon> at line 1â¤  in 'List::at_pos' at line 1â¤  in 'Any::postcircumfix:<[ ]>' at line 1660:CORE.settingâ¤  in main program

[14:38] <p6eval> ..body aâ€¦

[14:39] <TiMBuS> didnt expect that

[14:40] *** stepnem left
[14:40] <TiMBuS> my @list := gather { my @z = 1; loop { @z = take ((0, @z) >>+<< (@z, 0)) } }; say @list[2];

[14:40] <TiMBuS> -_-

[14:40] <TiMBuS> rakudo: my @list := gather { my @z = 1; loop { @z = take ((0, @z) >>+<< (@z, 0)) } }; say @list[2];

[14:40] <p6eval> rakudo d9aa57: OUTPUTÂ«1331â¤Â»

[14:40] <TiMBuS> woo

[14:40] <masak> TiMBuS++

[14:41] <masak> nicest solution I've seen yet.

[14:41] *** timbunce left
[14:42] <TiMBuS> close enough to a self-referential list

[14:43] *** stepnem joined
[14:43] *** timbunce joined
[14:46] *** zulon left
[14:48] *** zulon joined
[14:49] *** stepnem left
[14:50] <TimToady> rakudo: my @list := gather { my @z = 1; loop { @z := take ((0, @z) >>+<< (@z, 0)) } }; say @list[2];

[14:50] <p6eval> rakudo d9aa57: OUTPUTÂ«1331â¤Â»

[14:50] <TimToady> binding is better

[14:51] <TimToady> pity about:

[14:51] <TimToady> rakudo: my @list := gather { loop { (state @z = 1) := take ((0, @z) >>+<< (@z, 0)) } }; say @list[2];

[14:51] <p6eval> rakudo d9aa57: OUTPUTÂ«===SORRY!===â¤"state" not yet implemented at line 22, near "= 1) := ta"â¤Â»

[14:51] * masak might take a look at 'state' in Rakudo

[14:51] <masak> jnthn++ indicated that it wasn't extremely hard.

[14:52] <masak> doesn't take a rocket surgeon to implement it, at least :P

[14:52] *** stepnem joined
[15:02] * TimToady thinks about: my @list := gather { loop -> @z = 1 { take ((0, @z) >>+<< (@z, 0)) } }; say @list[2];

[15:04] *** kid51 joined
[15:19] <szbalint> rakudo: my @foo = ("a", "b", "ab"); my @bar = ("a", "b", "ab" | "ba"); say "match!" if (@foo ~~ @bar);

[15:19] *** pmurias joined
[15:19] <p6eval> rakudo d9aa57:  ( no output )

[15:20] <pmurias> ruoso: how should i send the gsoc code sample to google?

[15:20] <szbalint> hm. Did I misunderstand it or smartmatching doesn't cooperate with junctions yet?

[15:20] <masak> szbalint: seems to me that should work.

[15:20] <masak> szbalint: but I guess it depends on what the inner comparison is. it might be something other than smartmatch.

[15:26] <szbalint> rakudo: say "match!" if ("ab" ~~ any("ab", "ba"));

[15:26] <p6eval> rakudo d9aa57: OUTPUTÂ«match!â¤Â»

[15:30] *** Mowah left
[15:30] *** amkrankruleuen left
[15:34] *** Italian_Plumber left
[15:36] *** rgrau__ joined
[15:37] <TiMBuS> hmmmm is there a way to copy a list when you put it into a hash?

[15:37] <masak> could you be a bit more specific?

[15:37] <TiMBuS> %h = (foo => @foos.copy)

[15:37] <masak> ah.

[15:37] <masak> .clone

[15:38] <TiMBuS> that doesnt seem to work

[15:38] <masak> but please say array next time when you don't mean list :)

[15:38] <TiMBuS> my bad

[15:38] <moritz_> foo => [@foos]

[15:38] <masak> that might create an array of an array, though.

[15:38] *** rgrau_ left
[15:38] <masak> ...I think.

[15:39] <TiMBuS> that's what I thought it would do

[15:39] <masak> seems I'm wrong.

[15:39] <masak> do what moritz_++ says.

[15:39] <TiMBuS> done

[15:40] <TiMBuS> so what does .clone do?

[15:40] <masak> clones an object.

[15:40] <TiMBuS> i guess it has a use elsewhere in perl

[15:41] <masak> well, it's a fairly common use case in OO.

[15:42] <moritz_> my @a = 1, 2, 3; my %h = a => @a.clone; %h<a>.push: 4; say @a.perl

[15:42] <moritz_> rakudo: my @a = 1, 2, 3; my %h = a => @a.clone; %h<a>.push: 4; say @a.perl

[15:42] <p6eval> rakudo d9aa57: OUTPUTÂ«[1, 2, 3]â¤Â»

[15:42] <moritz_> you see, .clone actually gives you copy

[15:42] *** BaggioKwok joined
[15:43] <TiMBuS> rakudo: my @a = <1 2 3>; my $b = @a.clone; $b[1]=4; say @a;

[15:43] <p6eval> rakudo d9aa57: OUTPUTÂ«143â¤Â»

[15:44] <moritz_> that's curious

[15:45] <TiMBuS> im just glad it bugged because I thought I was going crazy

[15:45] <szbalint> ouch :)

[15:45] <TiMBuS> crazier

[15:45] <moritz_> did anybody submit it already?

[15:46] * moritz_ still waits for answers to his p6u mail

[15:46] <szbalint> don't get warnocked :)

[15:46] <masak> it's a warnock-friendly mail...

[15:46] * masak tries to recall why he didn't write a reply right away

[15:47] *** feiquet left
[15:47] <moritz_> btw the last idea doesn't seem to work out in current rakudo

[15:48] <TiMBuS> i think .clone copies the RPMCA

[15:49] <masak> moritz_: high-level response: I think I'd match all [% %] things with the same rule, but have a closure by its end narrowing down what's accepted.

[15:49] <masak> including logic involving a stack for nested things.

[15:49] <masak> and an exception for the [% verbatim %] case.

[15:50] <moritz_> but I use a grammar because I don't want to maintain my own stack

[15:50] <masak> that's one of many reasons to use a grammar.

[15:51] <masak> myself, I'd be happy to get the other reasons, and do the stack manually. ymmv.

[15:52] <moritz_> if I could properly parameterize the rules, I'd be very happy

[15:53] *** jferrero joined
[15:53] <moritz_> rule nested_command_helper($command, $args = 1, $slurpy = 0) {

[15:53] <moritz_>     [ $open ~ $close

[15:53] <moritz_>         [<arg> ** $args, <slurpy_arg> ** $slurpy ]

[15:53] <moritz_>     ] ~ [ $open ~ $close 'end'$command ]

[15:53] <moritz_>     <chunks>*

[15:53] <moritz_> }

[15:54] <moritz_> then I could just use

[15:54] <moritz_> <nested_command_helper('setvar', 1, 1)>

[15:54] <moritz_> etc.

[15:54] <masak> I don't grok, but it looks lovely.

[15:54] <moritz_> but currently <arg> ** $args doens't work that way in rakudo

[15:55] <masak> doesn't the comma after that have to be escaped or quoted?

[15:55] <moritz_> you mean in the call?

[15:56] <moritz_> std: / <alpha(1, 2, 3)>

[15:56] <p6eval> std 32108: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Regex not terminated at /tmp/VtZl5anNiJ line 1 (EOF):â¤------> [32m/ <alpha(1, 2, 3)>[33mâ[31m<EOL>[0mâ¤    expecting quantifierâ¤Parse failedâ¤FAILED 00:01 119mâ¤Â»

[15:56] <moritz_> std: / <alpha(1, 2, 3)> /

[15:56] <p6eval> std 32108: OUTPUTÂ«ok 00:01 119mâ¤Â»

[15:56] <moritz_> that's just a normal capture

[16:02] <pmichaud> good morning, #perl6

[16:02] <phenny> pmichaud: 28 Aug 09:29Z <moritz_> tell pmichaud when you write a release guide for *, be sure to mention updating http://rakudo.org/how-to-get-rakudo

[16:02] <moritz_> good morning pmichaud 

[16:03] <pmichaud> I'm not sure that release managers will always have edit access to the how-to-get-rakudo page; perhaps it would be better to eliminate the direct links altogether.

[16:04] <moritz_> wfm

[16:04] <masak> +1

[16:05] <masak> moritz_: no, I mean in [<arg> ** $args, <slurpy_arg> ** $slurpy ]

[16:05] <moritz_> oh yes, the comma should be removed

[16:08] <pmichaud> (changing FORBID_PIR from contextual to global) -- doesn't this lose lexical scoping?

[16:09] <moritz_> I don't think it was ever lexically scoped

[16:09] <pmichaud> well, 'use' is supposed to be lexically scoped.

[16:09] <moritz_> star: { use FORBID_PIR }; pir::printerr__vP("Foo")

[16:09] <p6eval> star 2010.07: OUTPUTÂ«===SORRY!===â¤pir::op forbidden in safe modeâ¤â¤Â»

[16:10] <pmichaud> anyway, it's fine as global for now.

[16:10] * pmichaud wonders if it's valid to export a dynvar :-)

[16:10] <pmichaud> that would be.... interesting.

[16:12] * masak can't believe that match failure introspection isn't a more common requirement

[16:13] *** amiri left
[16:14] <masak> right now I'm staring at a Perl 5 regex, wondering why it doesn't match against a given string.

[16:14] *** amiri joined
[16:19] *** nimiezko left
[16:20] <moritz_> masak: sprinkle it with  (?{ print "$`|$&|$'\n" })   statements

[16:20] <moritz_> which tell you how far the match proceeded at this part of the regex

[16:21] <masak> in the end, I pasted the string on top of the regex, and then pretended to be a regex engine. it helped.

[16:24] <Juerd> moritz_: Isn't it easier to just run perl -Mre=debug on it? :)

[16:24] <masak> ooh, -Mre=debug

[16:24] *** BaggioKwok left
[16:25] <masak> I knew there would be a benefit to complaining loudly in here :)

[16:25] <masak> Juerd++

[16:26] <Juerd> I sometimes wonder how people cope without those tools :)

[16:26] <masak> my original point! :)

[16:26] <moritz_> Juerd: I find -Mre=debug too verbose

[16:27] <Juerd> Although you are probably all much better programmers than me, and don't run into the need to debug or profile code, look documentation up, etc :)

[16:27] <Juerd> Or at least less often

[16:28] <Juerd> moritz_: It wasn't very readable with my 64 kilobyte regex, indeed :)

[16:29] <moritz_> Juerd: I hope that was generated?

[16:29] <Juerd> Certainly :)

[16:36] *** patspam joined
[16:44] <TimToady> new turtle spirals: http://rosettacode.org/wiki/Spiral_matrix#Perl_6

[16:46] <szbalint> hehe, rosettacode is like pringles for you TimToady. :)

[16:48] <masak> (lay-egg)++

[16:56] <\xF0> what did the 64kb regex do?

[16:59] *** Italian_Plumber joined
[16:59] <Juerd> Why is dir declared as $.dir and then used as $!dir?

[17:00] <pmichaud> $.dir creates $!dir and a public method accessor

[17:00] <moritz_> $.dir is short for $!dir + "give an accessor"

[17:00] <Juerd> \xF0: Match all words that appear, bogglewise, in a 5x5 matrix of letters, between 3 and 7 characters in length

[17:00] <\xF0> haha

[17:00] *** M_o_C joined
[17:01] <Juerd> Oh, too bad. I think $.dir is much prettier.

[17:02] <pmichaud> $.dir goes through the accessor interface.

[17:02] <Juerd> Couldn't that be optimized?

[17:02] <pmichaud> well, in this case the accessor is read-only

[17:02] <gfldex> std: class A {}; A.new().?nosuchmethod();

[17:02] <p6eval> std 32108: OUTPUTÂ«ok 00:01 115mâ¤Â»

[17:02] <pmichaud> it would need to be    has $.dir is rw;   to have a rw accessor

[17:02] <gfldex> rakudo: class A {}; A.new().?nosuchmethod();

[17:02] <p6eval> rakudo d9aa57:  ( no output )

[17:02] <gfldex> rakudo: class A {}; A.new().?nosuchmethod(); say 'flap' xx 3;

[17:03] <pmichaud> (and yes, in that case it could be optimized... *if* you can be sure that it's not overridden in a subclass or something)

[17:03] <p6eval> rakudo d9aa57: OUTPUTÂ«flapflapflapâ¤Â»

[17:05] *** kid51 left
[17:10] *** amkrankruleuen joined
[17:11] *** espadrine left
[17:12] *** espadrine joined
[17:18] *** Italian_Plumber1 joined
[17:19] *** Italian_Plumber left
[17:27] *** risou__ joined
[17:28] *** risou_ left
[17:44] *** stepnem left
[17:44] *** lue joined
[17:44] <lue> hello o/

[17:44] <masak> hi \ã‹¡/

[17:45] <lue> .u ã‹¡

[17:45] <phenny> U+32E1 CIRCLED KATAKANA TU (ã‹¡)

[17:46] *** stepnem joined
[17:46] *** espadrine left
[17:46] *** Italian_Plumber1 left
[17:46] <lue> so it's supposed to be this, right? -> (ãƒ„) :)

[17:46] *** Italian_Plumber joined
[17:46] <masak> aye :)

[17:50] *** masak left
[17:52] <TimToady> and http://rosettacode.org/wiki/Zig-zag_matrix#Perl_6

[17:54] <moritz_> TimToady: did you test that code with rakudo?

[17:55] *** espadrine` joined
[18:11] *** plluksie left
[18:15] *** stepnem left
[18:18] *** stepnem joined
[18:19] *** lamstyle left
[18:22] *** lamstyle joined
[18:24] <lue> would  token TOP { [<a>|<b>]+}  in a grammar match the entire text to a mix of lines that are either <a> or <b>?

[18:27] <arnsholt> If <a> and <b> match newline at the end, I think so

[18:29] *** charlyp joined
[18:30] *** M_o_C left
[18:36] *** hans__ joined
[18:37] <lue> This is my first time trying to use grammars, and I don't know what I'm getting wrong: http://gist.github.com/556545

[18:37] *** envi^home left
[18:40] *** molaf left
[18:42] <lue> Could someone take a look at it and see what I'm getting wrong [if I'm getting anything wrong in the first place :)] ?

[18:43] *** zulon left
[18:43] <Tene> I will look

[18:44] <Tene> did you try it with the parsetrace option on?

[18:44] *** risou__ left
[18:44] <lue> eh, no.

[18:45] *** risou_ joined
[18:45] <Tene> lue: you say \S+, but you have items with spaces

[18:45] <arnsholt> Yeah, that's probably it

[18:45] <arnsholt> "the shop" won't match \S+

[18:47] <lue> Aah. Putting \N+ there would end up matching the rest of the line, wouldn't it?

[18:47] <moritz_> lue: it'll be much easier for you if you test the lines individually

[18:47] <moritz_> right

[18:47] <moritz_> [<!before '->' > .]+

[18:49] *** risou__ joined
[18:49] <lue> looks like I need to read up a lot on regexes :) . Just out of curiousity, what does the ! before `before' mean?

[18:49] <moritz_> it's a negated assertion

[18:49] <moritz_> "not before ->"

[18:50] *** risou_ left
[18:50] <moritz_> like (?! ... ) in Perl 5

[18:51] <lue> so, would replacing the [S+] with what you typed be enough?

[18:52] <Tene> not quite.  There's a <ws> there too.

[18:53] <moritz_> right, my regex eats up whitespace too

[18:53] <Tene> maybe [<!before <ws> '->'> .]+

[18:53] <Tene> or there's always .+?

[18:54] *** risou__ left
[18:55] *** M_o_C joined
[18:55] *** stepnem left
[18:56] *** stepnem joined
[18:57] <lue> Testing the two tokens separately, it's the <command> token that's the problem.

[18:59] <lue> there's something about it that causes it to gobble the entire text. [maybe forcing quotation marks to be around the item and its replacement would help?]

[19:00] <moritz_> lue: maybe it's easier to just split up the lines, and then split the non-comment lines on '->' with a limit of 2?

[19:01] <moritz_> I mean split up into lines

[19:06] *** hans__ left
[19:11] *** Mowah joined
[19:12] <lue> It seems to be working, I just have no way of telling if it is.

[19:13] <moritz_> why ever not?

[19:17] *** espadrine` left
[19:18] *** espadrine joined
[19:18] <lue> well, in the .perl output, every single  orig =>  line contains the entire text, yet the from => and to => lines have numbers that seem to be indicating the position of whatever's matched.

[19:18] <lue> And I don't know how to make sure this is the case.

[19:19] *** Snowclone left
[19:19] <moritz_> you can always ask for .Str of a particular submatch to see what it matched

[19:20] <lue> c<say>ing $match<TOP><command><item>.Str results in  Any()<0x6811460>

[19:21] <moritz_> then it didn't match the way you thought

[19:21] <moritz_> note that a quantifier always introduces an array

[19:22] <moritz_> and there's no TOP level

[19:22] <moritz_> so likely something like $match<command>[0]<item>.Str

[19:22] <TimToady> moritz_: yes, I tested it

[19:23] <moritz_> good

[19:23] <moritz_> I noticed that one solution seemed to use NYI-features in rakudo

[19:23] <moritz_> but I could have been wrong, of course

[19:24] <TimToady> they all worked

[19:24] <moritz_> \o/

[19:24] <TimToady> any idea which feature?

[19:25] <moritz_> no

[19:30] <moritz_> yay, the code from http://perlgeek.de/blog-en/perl-6/huffman-tree-with-rakudo.writeback still works 

[19:32] <TimToady> lunch &

[19:34] <lue> $<item>=[<!before <ws> '->' > \N]+ <ws> '->' â€¦ works just like I want it to :)

[19:46] <sorear> good * #perl6

[19:48] *** M_o_C left
[19:48] <lue> good DateTime.now, sorear o/

[19:48] *** M_o_C joined
[19:49] *** stepnem left
[19:50] *** timbunce left
[19:50] *** stepnem joined
[19:51] *** nimiezko joined
[19:55] *** timbunce joined
[20:03] <moritz_> rakudo: say Mu.can('Str')

[20:03] <p6eval> rakudo d9aa57: OUTPUTÂ«Method 'can' not found for invocant of class ''â¤  in main program body at line 22:/tmp/W9lGj0wBzlâ¤Â»

[20:03] <moritz_> rakudo: say Mu.^can('Str')

[20:03] <p6eval> rakudo d9aa57: OUTPUTÂ«â¤Â»

[20:03] <moritz_> rakudo: say Any.^can('Str')

[20:03] <p6eval> rakudo d9aa57: OUTPUTÂ«Strâ¤Â»

[20:06] <charlyp> Question: want to dump all var/array/hashes  to a file using "print FILEHANDLE $dumper->dumpvars(\*::)" but doesn't work. Whats wrong? 

[20:06] *** whiteknight joined
[20:09] <sorear> charlyp: 1. that's Perl 5 code, this is #perl6   2. you should use \%::

[20:14] *** M_o_C left
[20:14] *** tadzik joined
[20:14] <tadzik> oh hai

[20:18] <charlyp> sorear: ok I tried with \%:: and have same result. My problem, if i just use '$dumper->dumpvars(\*::) i got all the stuff on the STDOUT   - on the terminal, but i want to put it i a file

[20:19] <moritz_> charlyp: try a Perl 5 help channel, like #perl

[20:19] *** slavik left
[20:19] <moritz_> or was it #perlhelp? not sure...

[20:20] <charlyp> ok, will try.with #perl

[20:20] <sbp> it's #perl apparently

[20:21] <lue> How do I use a variable in a regex? I'd like to do something like s/@a[0]/'a'/

[20:23] <tadzik> block should work, no?

[20:24] *** TiMBuS left
[20:24] <tadzik> rakudo: my $a = "foobar"; my $b = "foo"; say $a ~~ s/{$b}/boo/;

[20:24] <p6eval> rakudo d9aa57: OUTPUTÂ«1â¤Â»

[20:24] <tadzik> oh noes

[20:24] <tadzik> rakudo: my $a = "foobar"; my $b = "foo"; $a ~~ s/{$b}/boo/; say $a

[20:24] <p6eval> rakudo d9aa57: OUTPUTÂ«boofoobarâ¤Â»

[20:24] <tadzik> well, I have no clue now

[20:25] <lue> rakudo: my $a = "foobar"; my $b = "foo"; $a ~~ s/{make $b}/boo/; say $a

[20:25] <p6eval> rakudo d9aa57: OUTPUTÂ«boofoobarâ¤Â»

[20:28] *** TiMBuS joined
[20:29] <lue> rakudo: my $a = "foobar"; my @b = <foo bar>; $a ~~ s/@b/boo/; say $a

[20:29] <p6eval> rakudo d9aa57: OUTPUTÂ«foobarâ¤Â»

[20:29] <lue> rakudo: my $a = "foobar"; my @b = <foo bar>; $a ~~ s/@b[0]/boo/; say $a

[20:29] <p6eval> rakudo d9aa57: OUTPUTÂ«foobarâ¤Â»

[20:30] *** pugssvn left
[20:31] <lue> .oO(S05 is a big help here :/)

[20:32] *** pugssvn joined
[20:32] *** ChanServ sets mode: +v pugssvn

[20:32] *** jaldhar joined
[20:33] *** tri1 joined
[20:40] *** masak joined
[20:40] <masak> ahoy \o/

[20:40] <szbalint> hello there, mariner :)

[20:41] <tadzik> oh hai masak 

[20:41] *** amiri left
[20:41] <masak> must one really write MAIN($n as Int) rather than MAIN(Int $n)? does the spec weigh in on this?

[20:41] * masak checks

[20:41] <tadzik> I don't think so

[20:42] <tadzik> there is a difference, isn't it?

[20:42] *** pugssvn left
[20:42] <tadzik> the first is 'casting' to Int, the second expects an Int, no?

[20:42] <masak> yes.

[20:43] <masak> if all we ever got from the command line was Str, when would the latter ever be used?

[20:43] <tadzik> no eye deer

[20:44] *** Ross joined
[20:45] <lue> does anyone know how to interpolate variables in regexes, i.e. s/@a[0]/'a'/

[20:45] *** pugssvn joined
[20:45] *** ChanServ sets mode: +v pugssvn

[20:45] <masak> lue: that should work. see S05 for the details.

[20:46] *** Ross left
[20:46] <lue> I did, and it was no help.

[20:47] <lue> rakudo: my @a = <a b c>; my $b = "hallo"; $b ~~ s/@a[0]/'e'/; say $b;

[20:47] <p6eval> rakudo d9aa57: OUTPUTÂ«halloâ¤Â»

[20:48] <masak> rakudo: my @a = <a b c>; my $b = "hallo"; say ?($b ~~ /@a[0]/)

[20:48] <p6eval> rakudo d9aa57: OUTPUTÂ«0â¤Â»

[20:48] <masak> rakudo: my @a = <a b c>; my $b = "hallo"; say ?($b ~~ /@a/)

[20:48] <p6eval> rakudo d9aa57: OUTPUTÂ«0â¤Â»

[20:48] <masak> rakudo: my $a = 'a'; my $b = "hallo"; say ?($b ~~ /$a/)

[20:48] <p6eval> rakudo d9aa57: OUTPUTÂ«1â¤Â»

[20:53] <lue> hmm. Bug, perhaps?

[20:53] <masak> quite possibly.

[20:54] <masak> rakudo: my @a = 'a'; my $b = "hallo"; say ?($b ~~ /@a/)

[20:54] <p6eval> rakudo d9aa57: OUTPUTÂ«1â¤Â»

[20:54] <masak> rakudo: my @a = 'a'; my $b = "a0"; say ?($b ~~ /@a[0]/)

[20:54] <p6eval> rakudo d9aa57: OUTPUTÂ«1â¤Â»

[20:54] <masak> there you go.

[20:54] *** IcyBee joined
[20:54] <masak> rakudo: my @a = 'a'; my $b = "a0"; say ?($b ~~ /^ @a[0] $/)

[20:54] <p6eval> rakudo d9aa57: OUTPUTÂ«1â¤Â»

[20:56] *** IcyBee left
[20:57] <lue> rakudo: my @a = 'a','b'; my $b = "hallo"; say ($b ~~ s/@a[0]/'e'/)

[20:57] <p6eval> rakudo d9aa57: OUTPUTÂ«1â¤Â»

[20:57] <lue> rakudo: my @a = 'a','b'; my $b = "hallo"; $b ~~ s/@a[0]/'e'/; say $b

[20:57] <p6eval> rakudo d9aa57: OUTPUTÂ«halloâ¤Â»

[20:57] <masak> lue: my last evaluation shows that /@a[0]/ parses as /@a '0'/

[20:58] *** tri1 left
[21:00] <tadzik> rakudo: my @a = 'a','b'; my $b = "hallo"; $b ~~ s{/@a[0]/}'e'/; say $b

[21:00] <lue> yea, I got that.

[21:00] <p6eval> rakudo d9aa57: OUTPUTÂ«===SORRY!===â¤Confused at line 22, near "$b ~~ s{/@"â¤Â»

[21:00] <tadzik> whoops

[21:01] <tadzik> rakudo: my @a = 'a','b'; my $b = "hallo"; $b ~~ s/{@a[0]}/'e'/; say $b

[21:01] <p6eval> rakudo d9aa57: OUTPUTÂ«'e'halloâ¤Â»

[21:01] <tadzik> duh, I get it all wrong with blocks as far as I can see

[21:02] <masak> tadzik: how's the studying going?

[21:02] <tadzik> masak: not bad, there was some RÂ³ geometry today

[21:03] <tadzik> that's in our linear algebra program too

[21:03] <tadzik> planning either Jordan's matrix, or Complex numbers and ortoghonalization tomorrow

[21:03] <tadzik> (I'm trying to translate the terms I know, let me know if I get it wrong)

[21:04] <lue> masak: would that parsing be considered a bug?

[21:04] <masak> lue: I'm pretty sure it would.

[21:04] <masak> but most likely, it's a TODO.

[21:07] <lue> If I remember right, a similar problem occurs in string interpolation.

[21:07] <lue> rakudo: my @a = <a b c>; say "I know the letter @a[0]."

[21:08] <p6eval> rakudo d9aa57: OUTPUTÂ«I know the letter a.â¤Â»

[21:08] <masak> seems fine to me.

[21:08] <lue> Hm, guess not.

[21:08] <masak> that used to not work, but jnthn++ implemented it a few months ago.

[21:09] <lue> rakudo: my @a = <a b c>; my $b = "hallo"; $b ~~ s/"@a[0]"/e/; say $b; # please work

[21:09] <p6eval> rakudo d9aa57: OUTPUTÂ«halloâ¤Â»

[21:10] <masak> lue: do 'my $x = @a[0]' and then use $x in your regex.

[21:13] <tadzik> g'night #6

[21:13] *** tadzik left
[21:13] <masak> sleep sweetly, tadzik. dream of non-zero determinants.

[21:16] *** Guest23195 left
[21:16] <sorear> does anyone use "std", the script?

[21:18] <lue> I do every once in a while, when I'm not sure if the code I have should even parse.

[21:18] <lue> masak: I know, I guess I'll have to do that.

[21:19] *** pugssvn left
[21:19] <lue> afk

[21:20] *** charlyp left
[21:20] <sorear> I'm about to delete std

[21:21] <sorear> replaced with 5 lines of code in viv --compile-setting

[21:21] <sorear> everything else std does, tryfile does better

[21:21] *** pugssvn joined
[21:21] *** ChanServ sets mode: +v pugssvn

[21:21] <masak> +1

[21:21] <TimToady> tryfile is a stupid name for a compiler

[21:22] <TimToady> oh, that's not what you said... :)

[21:22] <sorear> the real reason I'm doing this is to deduplicate the 20 lines of entry point code

[21:23] <sorear> which is about to get much bigger as I make viv installable

[21:24] <masak> TimToady: are all things coming in as MAIN parameters typed Str?

[21:24] *** Eevee left
[21:26] <TimToady> I suppose, but maybe we can come up with something a bit dwimmier.

[21:26] <masak> I"m currently of two minds about it myself.

[21:27] <TimToady> yeah...

[21:31] <masak> I think just to see what happens, I'd like Str which look like Int to typematch as Int, and ditto Num. but they should still typematch as Str even if they look like numbers.

[21:31] *** lichtkind joined
[21:31] <TimToady> just like the currently specced semantics of <...>

[21:31] <masak> maybe there's a common denominator there somewhere.

[21:31] <sorear> perl 5 and Tcl beleive that 3 === "3"

[21:31] <TimToady> yes, things we are forced to write as text

[21:32] <sorear> perl 6 and python believe the opposite

[21:32] <TimToady> perl 6 believes lotsa things :)

[21:33] <TimToady> I think minimally if you do string operators on the value, it should use the original string value, whether or not it thinks it is a string

[21:33] <masak> not sure I see where that would make a difference, but it sounds sane-ish.

[21:34] <TimToady> well, the question arises when you do multi type matching, will it match Str stronger than, say, Int

[21:34] <TimToady> Int should be stronger, but Str somehow available

[21:34] <masak> oh, didn't think of multi.

[21:35] <masak> the question is really what mechanism does the type fudging, and how it meshes with multi.

[21:35] <TimToady> otoh, if you're writing such a MAIN sig, you should probably just leave the type off if that's what you mean

[21:35] <TimToady> I suspect the fudging is predispatch, much as with <1 2.3>

[21:36] <TimToady> similar considerations for "SOME TEXT" to be born as ascii that knows how to Buf and Str

[21:36] <masak> well, my initial reaction was that it was a waste of semantic space never to be able to use 'sub MAIN(Int $x)'

[21:36] <masak> ASCII literals, yes.

[21:37] <masak> "use-based polymorphism" :)

[21:37] <TimToady> possibly even latin-1 buf8 literals

[21:41] <pugssvn> r32110 | sorear++ | [std] Fold setting-compiler functionality into viv; remove in favor of tryfile 

[21:41] <TimToady> by which I mean a latin1 buffer type like we have utf8 buffer type

[21:41] <TimToady> so the type is not ambiguous

[21:41] <TimToady> if we did that, we wouldn't need an ascii buf type probably

[21:41] <TimToady> bbl &

[21:41] * perigrin ponders how a fuzzy type inference engine would work

[21:43] <arnsholt> perigrin: Weirdly? =)

[21:44] <masak> we want to find a balance between least-surprise and weird here. :)

[21:46] <perigrin> arnsholt: there are a lot of things in this world that work Weirdley that I think may just be a kind of awesome I can't comprehend yet.

[21:46] <perigrin> Haskell for example.

[21:46] <masak> that's how most of us feel about Haskell. :)

[21:47] <pmichaud> I wonder if trying to use "Int" to match a Str holding an integer goes a bit too far.  Seem like maybe we want another (subset) type, like  StrInt

[21:47] <masak> pmichaud: I'm not suggesting it as a general thing.

[21:47] <pmichaud> ah

[21:47] <masak> pmichaud: only things coming in through MAIN

[21:47] <masak> pmichaud: since right now there's no way to pass in an Int.

[21:49] <pmichaud> well, there are lots of other places that this occurs... like prompts

[21:49] <pmichaud> my $age = prompt "Enter your age: ";  calculate-benefit($age)

[21:49] *** timbunce left
[21:49] <perigrin> is that a problem in practice? Can perl6 coerce 6 from "6"? (and the next question is can it coerce 6 from "six" and "VI"...)

[21:49] <masak> for some reason, prompts feel naturally Str-y.

[21:50] <pmichaud> masak: sure, but plenty of people will likely want to say ...and only accept Int-valued Strs.

[21:50] <masak> perigrin: I don't think that's the next question. :)

[21:50] <perigrin> masak: hmm depends on which of us is asking it :)

[21:50] <pmichaud> It happens in the same way that <1 2 3>  surprises people by being Str and not Int (before the spec changes that made them be "both")

[21:51] <sorear> perigrin: "6" is not an Int

[21:51] <masak> oh dear. I had repressed the memory of that change. :/

[21:51] <perigrin> sorear: I didn't say it was ... in fact I know it's not.

[21:51] <pmichaud> I keep hoping it'll change again :)

[21:51] <sorear> perigrin: this is the single biggest difference between Perl 6 and Perl 5, imo

[21:51] <pmichaud> in some ways, what someone really wants to say is   MAIN(Cool $value as Int)

[21:51] <perigrin> sorear: I specifically asked if it could be *coerced* from "6" 

[21:52] <pmichaud> but that's not really it either

[21:52] <sorear> perigrin: perl 6 doesn't have a single concept of coercion yet

[21:52] <perigrin> :(

[21:52] <pmichaud> one can certainly do  "6".Numeric

[21:52] <pmichaud> or even +"6"

[21:53] <pmichaud> but what we're looking for here is something like    Str where $_.Numeric ~~ Int

[21:54] <perigrin> pmichaud: as I (slowly) learn about Type systems one of the things that I'm discovering is totally under valued in the Moose type system are the coercions

[21:54] *** timbunce joined
[21:54] <masak> perigrin: please do share.

[21:55] <ash_> is there a .Numeric and a .Num? 

[21:55] <phenny> ash_: 28 Aug 10:22Z <moritz_> tell ash_ that I made FORBID_PIR persist between REPL lines

[21:55] <pmichaud> ash_: yes

[21:56] <pmichaud> (maybe NYI in rakudo)

[21:56] <pmichaud> rakudo:  say "6".Numeric

[21:56] <p6eval> rakudo d9aa57: OUTPUTÂ«6â¤Â»

[21:56] <ash_> i guess Numeric is all of the num-ish types? 

[21:56] <pmichaud> rakudo:  say "6".Numeric.What

[21:56] <p6eval> rakudo d9aa57: OUTPUTÂ«Method 'What' not found for invocant of class 'Num'â¤  in main program body at line 22:/tmp/hbJO_bra0kâ¤Â»

[21:56] <pmichaud> rakudo:  say "6".Numeric.WHAT

[21:56] <p6eval> rakudo d9aa57: OUTPUTÂ«Num()â¤Â»

[21:56] <pmichaud> that's likely wrong there.

[21:56] <colomon> that's a bug, probably

[21:56] <pmichaud> Should be Int().

[21:56] <masak> ash_: Numeric is "anything that's a scalar number". Num is a floating-point value.

[21:57] * masak submits rakudobug

[21:57] <ash_> masak: by num-ish i meant number like, not specifically Num 

[21:57] <sorear> I thought that was Real

[21:57] <masak> ash_: that's Numeric.

[21:57] <sorear> Numeric includes vector numbers

[21:57] <masak> pmichaud: oh wait. that's a really old, known one.

[21:57] <pmichaud> masak: yes, it's in my list of "things I'd really like to clean up soon"

[21:57] <pmichaud> along with Stringy

[21:58] <masak> sorear: I'm quoting S32/Numeric:57.

[21:58] <perigrin> masak: you'll have to forgive my psudeo code but the idea that one can provide an explicit hint on how to convert a Str to an Int: coerce Int from Str via { $_.Numeric.floor } 

[21:58] <pmichaud> since I just finished my last summer conference yesterday, I'm hoping to do less traveling and more hacking (as in bug fixing) soon.

[21:58] <perigrin> for example

[21:58] *** nimiezko left
[21:58] <pmichaud> perigrin: in p6, I belive that's the .Int method of Str

[21:59] <pmichaud> *believe

[21:59] <perigrin> p6's typesystem is much more integrated than Moose's

[21:59] <colomon> star: say "6".Int

[21:59] <pmichaud> (or perhaps I'm misunderstanding what you're suggesting/asking)

[21:59] <p6eval> star 2010.07: OUTPUTÂ«6â¤Â»

[21:59] <colomon> star: say "6".Int.WHAT

[21:59] <p6eval> star 2010.07: OUTPUTÂ«Int()â¤Â»

[21:59] <colomon> star: say "6.32".Int.WHAT

[21:59] <p6eval> star 2010.07: OUTPUTÂ«Int()â¤Â»

[21:59] <sorear> perigrin: coercions in Perl 6 are what we call slushy

[21:59] <ash_> rakudo: say "123.456" + "1" 

[21:59] <p6eval> rakudo d9aa57: OUTPUTÂ«124.456â¤Â»

[21:59] <sorear> perigrin: that means that anybody with initiative can claim them

[22:00] <sorear> perigrin: do you want absolute power over designing the coercion system?

[22:00] <pmichaud> "absolute power" is a myth :-)

[22:00] <perigrin> the last time I took intiative I started my own business ... I'm still recovering from this :)

[22:00] <sorear> I was planning to lure stevan in here and give it to him, but ...

[22:00] <colomon> pmichaud: did you run out of conferences, or run out of summer?  ;)

[22:00] <masak> rakudo: say "foo".Int

[22:00] <p6eval> rakudo d9aa57: OUTPUTÂ«0â¤Â»

[22:01] <ash_> rakudo: say "foo" + 'bar' + 123 + True 

[22:01] <p6eval> rakudo d9aa57: OUTPUTÂ«124â¤Â»

[22:01] <ash_> i can reason why True = 1, but i always find it funny when I do: True + True = 2 

[22:01] <ash_> it makes sense, just funny 

[22:02] <ash_> rakudo: say True + True 

[22:02] <p6eval> rakudo d9aa57: OUTPUTÂ«2â¤Â»

[22:02] <sorear> perl 6 totally ought to define +True = -1 a la Pascal

[22:02] <perigrin> ash_: 2 is *very* double true.

[22:02] *** Mowah left
[22:03] <colomon> hmmm.  why do Str.Int and Str.Num exist?

[22:03] <pmichaud> colomon: out of conferences.  Summer still has three weeks left.  :)

[22:05] <perigrin> didn't I read somewhere in a synopsis that if you try assinging an Int to a Str for example it will try calling .Int and assinging the result?

[22:05] <pmichaud> it'll type fail.

[22:05] <pmichaud> rakudo:  my Str $x = 5;

[22:05] <p6eval> rakudo d9aa57: OUTPUTÂ«Type check failed for assignmentâ¤  in '&infix:<=>' at line 1â¤  in main program body at line 22:/tmp/LkRpK2iUzBâ¤Â»

[22:05] <perigrin> rakudo: say 5.Str

[22:06] <p6eval> rakudo d9aa57: OUTPUTÂ«5â¤Â»

[22:06] <perigrin> rakudo: my Str $x = 5.Str

[22:06] <p6eval> rakudo d9aa57:  ( no output )

[22:06] <perigrin> rakudo: my Str $x = 5.Str; say $x;

[22:06] <colomon> (just to make it clear -- I don't have anything against Str.Int, I'm just wondering why it's not Cool.Int instead.  And the answer may be as simple as "colomon overlooked it".)

[22:06] <p6eval> rakudo d9aa57: OUTPUTÂ«5â¤Â»

[22:07] <perigrin> pmichaud: perhaps a trait is coercable would make that not type fail but instead try ?

[22:07] <perigrin> possibly one with y'know a better spelling

[22:08] <pmichaud> perigrin: yes, we've been exploring something like that -- haven't come up with anything concrete yet  (thus sorear++ is absolutely correct when he says it's slushy :-)

[22:08] <pmichaud> in signatures, one can do "as Type"  to do a coercsion

[22:08] <pmichaud> *coercion

[22:08] <pmichaud> thus    sub abc($x as Int) { ... }

[22:09] <perigrin> Int $x is Coercible would be the same thing I suspect

[22:09] <perigrin> but generic :)

[22:11] <pmichaud> there was discussion about this starting near http://irclog.perlgeek.de/perl6/2010-08-09#i_2679700

[22:12] <pmichaud> my coerced Num $x    and  my Num $x is coerced

[22:12] <pmichaud> or something like that

[22:13] <pmichaud> It's one of those ongoing questions that the language implementors get to torment the language designer with :-)

[22:14] *** jhuni joined
[22:16] <perigrin> :)

[22:18] <perigrin> honestly I quite like $value.Type it seems to fit in with how lots of other things work in perl6

[22:21] <perigrin> the only prior art I've personally worked with is Moose

[22:21] <perigrin> which keeps the Type Constraint and the coercion orthogonal in that unless you explicitly enable coercion you don't get it

[22:21] <perigrin> (we have an attribute trait: coerce => 1 to enable it)

[22:22] *** christine left
[22:23] <masak> well, in Perl 6 you also have to explicitly enable coercion with 'as SomeOtherType'.

[22:23] <perigrin> er and in MooseX::Declare you can say is coerce in a method signature

[22:24] <perigrin> masak: I'm kinda responding to the stuff pmichaud commented on in the irclog ... it seemd 'as Type' was part of the slushy-ness

[22:24] <masak> as far as I'm aware, any type constraint must still match just as strictly. if it does, *then* the coercion is done.

[22:25] <perigrin> which side? with a coercion there is always two ... master and app...er from and to

[22:26] <masak> the type constraint is still on the incoming, pre-coercion value.

[22:26] <perigrin> in Moose yes ... if you convert from Foo to Bar ... you must match Foo ... there isn't a concept of non-strict matching of Foo

[22:26] <perigrin> when you're done you either get a type failure 

[22:26] <perigrin> or something that matches Bar 

[22:27] <perigrin> type constraint matching in Perl is boolean ... 

[22:28] <perigrin> s/Perl/Moose/

[22:28] <perigrin> bah sorry

[22:29] *** yrgd left
[22:31] <ash_> MooseX::Declare won't install cleanly on OS X with 5.12 

[22:31] <ash_> anyone, thats kinda off topic

[22:31] <ash_> anyway* 

[22:31] <perigrin> I have it on mine I think.

[22:31] <perigrin> yeah

[22:31] <perigrin> and I'm on 5.12.1

[22:32] <ash_> i always get test failures, so cpan doesn't want to install it, its not needed by anything i am using, just a nice to have, but i can live without it 

[22:34] <sorear> -f

[22:34] <perigrin> ash_: yeah I never use it directly myself except for testing and for writing code examples because the syntax is much nicer.

[22:35] *** pmurias left
[22:39] *** Chillance joined
[22:46] *** rgrau__ left
[22:48] <masak> rakudo: say ~<teeka tok teek>.pick(8, :replace)

[22:48] <p6eval> rakudo d9aa57: OUTPUTÂ«teeka teeka tok teeka tok teek teeka tokâ¤Â»

[22:48] <masak> :D

[22:48] * masak pipes that script into his speech synthesizer

[22:52] <pugssvn> r32111 | sorear++ | [STDeco] add a concept of standard syml files for viv, found in the installed data dir; several small refactors 

[22:53] *** rgrau_ joined
[22:56] *** yrgd joined
[22:58] *** timbunce left
[23:05] <pugssvn> r32112 | sorear++ | [CursorBase] If a module is found in a readonly syml dir, don't look for the .pm 

[23:08] <arnsholt> Is it only infix operators that support :nextterm in nqp-rx?

[23:08] <pugssvn> r32113 | sorear++ | [viv] add a --check/-c mode so viv can subsume tryfile, too 

[23:25] <pugssvn> r32114 | sorear++ | [viv] Improve documentation a bit 

[23:26] <masak> rakudo: "" ~~ /x/; make []; ~$/.ast<c>

[23:26] <p6eval> rakudo d9aa57: OUTPUTÂ«postcircumfix:<Nil()> not defined for type Array()â¤  in main program body at line 1â¤Â»

[23:26] <masak> hah! got you, bug!

[23:26] <masak> yeah!

[23:26] * masak slams it into RT!

[23:27] <masak> rakudo: my @a; @a<foo> = "bar"

[23:28] <p6eval> rakudo d9aa57: OUTPUTÂ«Cannot modify readonly valueâ¤  in '&infix:<=>' at line 1â¤  in main program body at line 22:/tmp/cAkoixwzacâ¤Â»

[23:28] <masak> hm. also a bit LTA.

[23:28] <masak> rakudo: my @a; say @a<foo>.WHAT

[23:28] <p6eval> rakudo d9aa57: OUTPUTÂ«Failure()â¤Â»

[23:28] <masak> yeah, that'd be readonly.

[23:28] * masak doesn't report that one

[23:29] *** _jaldhar joined
[23:33] *** jaldhar left
[23:33] <masak> rakudo: ~[]<c>

[23:33] <p6eval> rakudo d9aa57: OUTPUTÂ«postcircumfix:<Nil()> not defined for type Array()â¤  in main program body at line 1â¤Â»

[23:33] <masak> ooh, much shorter.

[23:33] <masak> rakudo: ~[]<>

[23:33] <p6eval> rakudo d9aa57:  ( no output )

[23:39] <masak> rakudo: ~5<c>

[23:39] <p6eval> rakudo d9aa57: OUTPUTÂ«postcircumfix:<Nil()> not defined for type Int()â¤  in main program body at line 1â¤Â»

[23:39] <masak> rakudo: ~5{'c'}

[23:39] <p6eval> rakudo d9aa57: OUTPUTÂ«postcircumfix:<Nil()> not defined for type Int()â¤  in main program body at line 1â¤Â»

[23:41] <pugssvn> r32115 | sorear++ | [STD-dist] Install standard syml files; install viv as an executable 

[23:42] <sorear> STD 32115 pushed to CPAN

[23:44] <masak> \o/

[23:44] <masak> sorear++

[23:45] <sorear> If a Perl script is installed executable on Win32, how can I run it?

[23:45] <sorear> Will the toolchain somehow make "viv" work?

[23:46] *** meppl left
