[00:03] *** cdarroch left
[00:16] *** payload left
[00:20] *** nihiliad left
[00:21] *** meppl left
[00:21] *** mssm left
[00:26] *** drbean joined
[00:31] *** payload joined
[00:32] *** pnate left
[00:35] *** s1n joined
[00:38] *** lumi left
[00:38] *** lumi joined
[00:42] *** lichtkind_ joined
[00:55] *** lestrrat is now known as lest_away

[00:57] *** zorgnax left
[00:57] *** zorgnax joined
[01:00] *** Chillance left
[01:00] *** lichtkind left
[01:07] <pmichaud> I'm looking for a method (name) that can be used on an Iterator to get it to return itself in a form appropriate for a Seq

[01:08] <pmichaud> (without actually being a Seq)

[01:08] <pmichaud> for example, if I have

[01:08] <diakopter> .net has GetEnumerator

[01:08] <pmichaud> my $i = (1..5).iterator;  $i.get;  $i.get;  $i.foo

[01:08] <diakopter> GetSequencer

[01:09] <diakopter> .sequencer

[01:09] <pmichaud> I'd like $i.foo to return me    3..5

[01:10] <diakopter> .seq

[01:10] <jnthn> .rest

[01:10] <pmichaud> yeah, I thought of .seq, but somehow that feels like it ought to return a Seq

[01:10] <pmichaud> oooh, .rest might work

[01:10] <pmichaud> the key feature is that

[01:10] <pmichaud>     $file.foo    # returns the remaining lines of the file

[01:10] <jnthn> But why not .clone, because you're taking a snapshot of the iterator at the curent state?

[01:10] <jnthn> Or have I missed the point?

[01:11] <pmichaud> because  $file.clone  should clone the iterator, but doesn't give me all of the lines

[01:11] <jnthn> Oh, it's meant to give all the rest of the values?

[01:11] <pmichaud> right

[01:11] <pmichaud> rest of the values

[01:11] <jnthn> OK, gotcha.

[01:11] <jnthn> I rest my case.

[01:11] <jnthn> :-)

[01:11] <pmichaud> but it's also allowed to do so lazily, if state isn't an issue

[01:11] *** Chillance joined
[01:12] <jnthn> That's OK, it's still the rest of them, in some way.

[01:12] <pmichaud> i.e.,  a RangeIterator is allowed to return a range without having to eagerly generate them all

[01:12] <pmichaud> and a MapIterator is allowed to return a new MapIterator

[01:12] <jnthn> *nod*

[01:12] <pmichaud> but a filehandle would go ahead and slurp up the remaining values, because that causes a state change

[01:13] <jnthn> OK, makes sense.

[01:13] <jnthn> Is this really the "fairly eager" level?

[01:13] <pmichaud> here's the larger issue

[01:13] <pmichaud> yeah... "fairly eager"

[01:13] <pmichaud> "mostly eager" as defined now suffers from a sequencing issue

[01:14] *** lumi left
[01:14] *** lumi joined
[01:14] <pmichaud> in that it stops evaluating at the first potentially non-finite item

[01:14] <jnthn> oh, mostly eager was the term I was looking for :-)

[01:15] <pmichaud> what I'd really like is a form of eagerness for a transactional-type of thingy

[01:15] <pmichaud> for example, to be able to evaluate     (1..1000, $file.lines)

[01:15] <pmichaud> such that it gives me back

[01:15] <pmichaud>    1..1000, "line 1", "line 2", "line 3", ..., "last line"

[01:15] <pmichaud> i.e., the 1..1000 can still be lazy

[01:16] <jnthn> Ah, I see.

[01:16] <pmichaud> but $file.lines went ahead and flattened out into values

[01:16] <jnthn> Could you not define mostly eager as looking through the things available and asking them to DTRT in a "mostly eager" context?

[01:17] <pmichaud> yeah, I suppose.  or we could say that Ranges in mostly eager context are allowed to not flatten

[01:17] <Tene> I really like how leaving off word boundaries on my hilight ends up notifying me of most of these conversations, due to "flatTened".

[01:17] <jnthn> I think it's a decision for the iterator, tbh.

[01:17] <pmichaud> so,  .eagerize

[01:17] <jnthn> .eagerish

[01:18] <Tene> Will definitely read when I get home from work.

[01:18] <jnthn> .eagerize suggests to me "completed eager", at first glance.

[01:18] <pmichaud> yes, it's a decision for the iterator, definitely -- I'm just trying to decide what to call it

[01:19] <pmichaud> .eagerify  (c.f. "stringify" and "numify")

[01:19] <pmichaud> or, perhaps, .itemize :-)

[01:20] <jnthn> Perhaps .eagerify by default could give you the mostly eager semantics, and .eagerify(:really) maybe the "completely eager" one or something.

[01:20] <pmichaud> well, "completely eager" is probably just .eager

[01:20] <jnthn> Ah

[01:20] <pmichaud> c.f. the "eager" function

[01:20] <jnthn> Yeah, you're right.

[01:20] <jnthn> In that case, I'm not sure you want a name too close to .eager

[01:20] <pmichaud> but perhaps it's   .eager(:mostly)

[01:21] <jnthn> Well, perhaps, but...

[01:21] <jnthn> ...mostly eager feels to me like the default.

[01:21] <jnthn> As in, what's usually the right thing.

[01:21] <pmichaud> depends on the operation

[01:21] <jnthn> True.

[01:21] <pmichaud> surely if I say    my @a = eager 1..10, $file.lines;

[01:21] <pmichaud> I really expect that 1..10 to be converted to the actual elements

[01:22] <jnthn> Yes, but then you're throwing in something to explicitly say you want a different level of eagerness.

[01:23] <jnthn> (My point being that since that's the special case because you had to write eager there, I'd expect it to be the special case in the iterator API and the one specified by an adverb...)

[01:23] *** lichtkind_ left
[01:23] <pmichaud> yeah, but I'd expect   (1..10).iterator.eager    to also give me back 10 items

[01:23] <jnthn> Yeah, me to.

[01:23] <jnthn> So...I think maybe the adverbs are a bad idea.

[01:24] <pmichaud> right.

[01:24] <pmichaud> and I haven't convinced myself to like   .mostlyeager   or .meager :-)

[01:24] <jnthn> :-)

[01:25] <jnthn> .rest is cute but doesn't quite convey the transactional or mostly eager sense.

[01:26] <jnthn> Maybe an overly-descriptive method name is a bad thing though.

[01:26] <jnthn> .getstuffeagerlythathastransactionalsemantics sucks. :-)

[01:26] *** araujo left
[01:27] <jnthn> Anyway, I think defining mostly eager to be aware of these transactiony needs is the main issue.

[01:27] <jnthn> Method names are easily tweaked if somebody thinks of a better one; semantics less so.

[01:28] <pmichaud> well, I might just go with .seq for now then -- I've not come up with much better

[01:28] *** ihrd left
[01:28] <pmichaud> it has reasonable analogues with .item, .list, .hash, etc.

[01:28] <jnthn> yeah, but confusion with .Seq

[01:28] <pmichaud> well, that may not be too bad -- the whole point of this is to get something that can be placed into a Seq

[01:29] <jnthn> Yeah, true.

[01:29] <jnthn> The "distinguished by a capital" just makes me twitchy.

[01:29] <pmichaud> oh, we already do that with Hash <-> hash

[01:29] <pmichaud> and we used to do it with List <-> list

[01:29] <jnthn> Yes, true.

[01:30] <jnthn> .oO( to avoid the confusion, we rename it to .hashish...implementation available in Morocco )

[01:30] <pmichaud> anyway, I can use .seq for now and we can change it later if we decide on something more appropriate.  I may discover that my planned design doesn't work anyway

[01:30] <jnthn> Yes, wfm.

[01:33] <jnthn> OK, it's late and I gotta actually work tomorrow, rather than wondering around Slovak castles in -10C.

[01:33] <jnthn> *wandering

[01:33] <pmichaud> okay, see you tomorrowish

[01:33] <jnthn> Aye, night o/

[01:57] *** nihiliad joined
[01:59] *** ash_ left
[02:03] *** Chillance left
[02:09] *** REPLeffect left
[02:32] *** fridim_ left
[02:36] *** orafu left
[02:37] *** orafu joined
[02:40] *** lest_away is now known as lestrrat

[02:42] *** lestrrat left
[02:47] *** lestrrat joined
[02:47] *** lumi left
[02:48] *** lumi joined
[02:54] <diakopter> so

[02:55] <sjohnson> hi dia

[02:55] <diakopter> hey

[02:56] *** k23z__ left
[02:57] *** ShaneC left
[02:59] *** gfldex joined
[03:05] *** Jimmy_Zhuo joined
[03:06] *** Jimmy_Zhuo is now known as JimmyZ

[03:11] *** agentzh joined
[03:22] *** REPLeffect joined
[03:22] *** gabiruh joined
[03:51] *** nihiliad left
[03:51] *** hjs left
[04:11] *** araujo joined
[04:18] *** Baggiokwok joined
[04:32] *** Baggiokwok left
[04:47] *** gfx joined
[05:07] *** kraih_sri left
[05:07] *** Intensity left
[05:07] *** kraih_sri joined
[05:07] *** kraih_sri left
[05:08] *** stepnem left
[05:08] *** kraih_sri joined
[05:17] *** Helios left
[05:17] *** cjk101010 joined
[05:17] *** Guest87460 left
[05:17] *** Chazz joined
[05:17] *** Helios joined
[05:18] *** Chazz is now known as Guest85607

[05:18] *** lisppaste3 left
[05:19] *** lisppaste3 joined
[05:20] <cjk101010> morning

[05:21] *** Intensity joined
[05:26] *** lumi left
[05:26] *** lumi joined
[05:27] *** stepnem joined
[05:30] *** wjl_ joined
[05:30] *** stepnem left
[05:31] *** Intensity left
[05:32] *** JimmyZ left
[05:32] *** Helios left
[05:32] *** Helios joined
[05:33] *** Helios left
[05:34] *** agentzh left
[05:34] *** Helios joined
[05:34] *** agentzh joined
[05:36] *** stephenlb left
[05:36] *** Intensity joined
[05:45] *** stepnem joined
[05:48] *** stepnem left
[05:48] *** Intensity left
[05:51] *** wjl_ left
[05:54] *** Helios left
[05:54] *** ssm left
[05:54] *** Helios joined
[05:54] *** ssm joined
[05:54] *** Helios left
[05:55] *** Helios joined
[05:56] *** eternaleye left
[06:00] *** ssm left
[06:00] *** ssm joined
[06:04] *** stepnem joined
[06:10] *** mj41_ joined
[06:16] <sjohnson> hi

[06:20] *** dj_goku joined
[06:21] *** s1n left
[06:21] *** Helios left
[06:21] *** s1n joined
[06:22] *** s1n left
[06:22] *** Helios joined
[06:22] *** Helios left
[06:22] *** s1n joined
[06:22] *** s1n left
[06:23] *** Helios joined
[06:23] *** Helios left
[06:23] *** s1n joined
[06:23] *** Helios joined
[06:24] *** Helios left
[06:25] *** Helios joined
[06:26] *** lumi left
[06:27] *** lumi joined
[06:28] *** mj41 left
[06:32] *** justatheory left
[06:35] *** drbean left
[06:38] *** Helios left
[06:38] *** Helios joined
[06:39] *** Helios left
[06:40] *** Helios joined
[06:40] *** Helios left
[06:41] *** Helios joined
[06:41] *** Helios left
[06:42] *** Helios joined
[06:42] *** Helios left
[06:43] *** Helios joined
[06:55] *** am0c left
[06:56] *** am0c joined
[07:08] *** JimmyZ joined
[07:16] *** Su-Shee joined
[07:16] <Su-Shee> good morning

[07:16] <cjk101010> morning

[07:33] *** kaare joined
[07:33] *** jonasbn joined
[07:34] *** kaare is now known as Guest51809

[07:35] *** Guest51809 left
[07:35] *** pnate joined
[07:36] *** kaare_ joined
[07:41] *** gfx left
[07:51] *** JimmyZ left
[07:57] *** iblechbot joined
[08:18] *** ejs joined
[08:35] *** rgrau joined
[08:39] *** stepnem left
[08:43] *** ejs left
[08:46] <moritz_> good morning

[08:46] *** stepnem joined
[08:51] *** ejs joined
[08:51] <sjohnson> hi

[08:56] *** mikehh left
[08:56] *** mikehh joined
[09:01] *** lumi_ joined
[09:01] *** ejs1 joined
[09:02] *** lumi left
[09:06] *** Baggiokwok joined
[09:08] *** mikehh left
[09:08] *** mikehh joined
[09:10] *** dakkar joined
[09:10] *** ejs left
[09:13] *** pnate2 joined
[09:20] *** mssm joined
[09:20] *** mikehh left
[09:24] *** pnate left
[09:36] *** Baggiokwok left
[09:40] *** agentzh left
[09:42] *** agentzh joined
[09:42] *** drbean joined
[09:44] *** stepnem left
[09:51] *** meppl joined
[09:52] *** stepnem joined
[09:55] *** lestrrat is now known as lest_away

[10:21] *** wwhskgcrraz joined
[10:21] *** wwhskgcrraz left
[10:24] *** Exodist left
[10:24] *** Exodist joined
[10:30] *** lumi_ left
[10:30] *** lumi joined
[10:30] *** drbean left
[10:32] *** rblasch joined
[10:33] *** cottoo joined
[10:33] *** c0tt0 left
[10:38] *** xinming_ left
[10:38] *** stepnem left
[10:44] *** xinming joined
[10:46] *** stepnem joined
[10:54] *** jferrero joined
[10:54] *** diakopter sets mode: +R
 
[10:54] <diakopter> till the morn'

[10:54] <diakopter> PST

[11:06] *** xomas left
[11:06] *** cottoo left
[11:14] *** agentzh left
[11:17] *** cottoo joined
[11:20] *** colocs joined
[11:21] *** Baggiokwok joined
[11:21] *** colocs left
[11:22] <sjohnson> diakopter: hows it going?

[11:30] *** k23z__ joined
[11:30] *** rgrau left
[11:42] *** payload left
[11:45] *** rgrau joined
[11:46] *** korpenkraxar joined
[11:47] *** ab5tract joined
[11:48] *** xpcowyvu joined
[11:48] *** xpcowyvu left
[11:55] *** cottoo left
[11:56] *** drbean joined
[11:56] *** cottoo joined
[11:57] *** smash_ left
[12:00] *** bluescreen joined
[12:01] *** pnmguhd joined
[12:01] *** pnmguhd left
[12:11] *** silug left
[12:13] *** jonasbn left
[12:16] *** uwfhwxmndu joined
[12:16] *** uwfhwxmndu left
[12:18] *** payload joined
[12:24] *** k23z__ left
[12:25] *** ruoso joined
[12:25] *** Baggiokwok left
[12:29] *** k23z__ joined
[12:30] *** lumi left
[12:30] *** lumi joined
[12:44] *** Guest92725 joined
[12:45] *** Guest92725 left
[12:50] *** athaba joined
[12:59] *** iblechbot left
[13:01] *** rgrau left
[13:01] *** lichtkind joined
[13:04] <lichtkind> what changes where made in s01? cant find them

[13:06] <moritz_> r29431, lwall++ [S01] take another lap around Mt Sinai...

[13:06] <moritz_> before that r28174 and r28172

[13:08] <sjohnson> moritz_: ot question

[13:08] <sjohnson> ever done any clipper programming?

[13:08] <moritz_> nope

[13:08] <moritz_> that was quick :-)

[13:10] <colomon> morning!

[13:10] <lichtkind> or to aks the other way arout are there anywhere changelogs for the svn ?

[13:10] <lichtkind> morning

[13:11] <colomon> lichtkind: svn log is the command you are looking for, maybe?

[13:11] <moritz_> lichtkind: I keep a git-svn mirror of the specs locally on disc, then 'git log $filename' is pretty quick

[13:11] <moritz_> svn log also works, but is a tad slow for my taste :-)

[13:11] *** moritz_ sets mode: +oo colomon lichtkind

[13:11] <sjohnson> moritz_: just doing a bit of a clipper => transition lately.. haven't been doing much perl lately *sad face*

[13:12] <sjohnson> err.. harbour transition

[13:12] <sjohnson> (32/64 bit modern compiler)

[13:16] <colomon> moritz_: thought of course, if you don't already have the git-svn mirror, plain svn log is probably much faster.

[13:17] <moritz_> colomon: yes. It's all a matter of how often you need it

[13:17] <moritz_> I'd be lost without my git mirror of the test suite

[13:22] <moritz_> rakudo: {redo}

[13:23] <moritz_> locally that prints a newline

[13:24] <moritz_> to STDERR

[13:24] *** bluescreen left
[13:24] <moritz_> that's less than awesome

[13:24] *** cognominal joined
[13:27] *** lumi left
[13:28] *** lumi joined
[13:39] *** bluescreen joined
[13:40] *** payload left
[13:44] *** am0c left
[13:44] *** am0c joined
[13:46] *** Chillance joined
[13:47] *** Lorn left
[13:55] <sjohnson> rakudo: say "have hope, sjohnson"

[13:55] *** Lorn joined
[13:55] * sjohnson kills himself

[13:56] <moritz_> hugme: hug sjohnson 

[13:56] * hugme hugs sjohnson

[13:56] <sjohnson> （　° ー°）

[13:57] <moritz_> we have a bot for hope. It's not p6eval :-)

[13:57] *** payload joined
[13:57] <sjohnson> bless { hugme }

[13:58] <sjohnson> "saved 6 people from suicide... and counting!" is its slogan i believe

[13:58] *** k23z__ left
[13:58] <moritz_> and the Perl 6 slogan is "Perl 6 - gets your job done, or gets you job"

[13:58] <moritz_> *a job

[13:59] *** macae joined
[14:03] *** silug joined
[14:06] *** jferrero left
[14:09] <Su-Shee> both, actually.

[14:12] *** macae left
[14:12] *** frettled left
[14:14] <sjohnson> heh

[14:14] <sjohnson> perl 6 is smarter than i'll ever be in life

[14:17] <Su-Shee> sjohnson: I use the idiot's subset. ;)

[14:18] *** ejs1 left
[14:21] *** ejs1 joined
[14:22] *** sjohnson sets mode: +o Su-Shee

[14:26] *** bluescreen left
[14:27] <sjohnson> so Su-Shee, how's it oging

[14:27] <Su-Shee> got my full contract yesterday (I'm finished with probation period) and I'm the designated perl 6 driver err developer now. ;)

[14:28] <Su-Shee> (and the UI chick..)

[14:29] <colomon> \o/

[14:30] *** bluescreen joined
[14:31] <Su-Shee> I essentially got served my dream job. :)

[14:31] <sjohnson> nice

[14:32] <sjohnson> my job lets me use perl about 10% of the day

[14:32] <sjohnson> those are happy periods though at work, though

[14:32] <moritz_> networking++

[14:32] *** frettled joined
[14:32] <moritz_> sjohnson: that's more than average, I'd say :-)

[14:32] *** sjohnson sets mode: +o frettled

[14:32] <sjohnson> moritz_: yeah... i better not jinx it

[14:32] <sjohnson> :)

[14:33] *** REPLeffect left
[14:34] *** REPLeffect joined
[14:39] *** k23z__ joined
[14:45] <lichtkind> i found in the svn log only one change relataed to S01 ... around mt sinai thing

[14:45] <moritz_> before that there were some typo fixes, and about .pl vs. .p6 or .pl6

[14:45] <lichtkind> was there any other?

[14:45] <moritz_> longer ago, though

[14:46] *** drbean left
[14:47] <moritz_> lichtkind: http://nopaste.snit.ch/19401 all changes to S01 in 2009 and 2010

[14:50] <pmichaud> jnthn: ping

[14:50] <pmichaud> (good morning, #perl6)

[14:50] <frettled> good morning!

[14:50] <frettled> pmichaud: so, how are you doing today?

[14:51] <pmichaud> well so far

[14:51] <pmichaud> making good progress on iterators and laziness

[14:51] <frettled> \o/

[14:53] *** JimmyZ joined
[14:53] *** cjk101010 left
[14:56] *** colomon left
[14:58] *** nihiliad joined
[14:59] *** wasy_afk is now known as wasy

[15:06] *** lichtkind left
[15:06] *** PerlJam left
[15:06] *** PerlJam joined
[15:07] *** silug left
[15:07] *** rgrau joined
[15:14] *** kaare_ left
[15:16] *** _ash joined
[15:16] *** cognominal left
[15:17] *** lest_away is now known as lestrrat

[15:19] <_ash> my $a = 5; my @b; @b[0] := $a; $a = 6; say @b; #should print 6 right? 

[15:19] <moritz_> yes

[15:19] <pmichaud> binding doesn't work for array elements yet

[15:20] <pmichaud> (in any of the implementations, although I know how to do it in ng)

[15:20] *** lichtkind joined
[15:20] * moritz_ hopes that somebody submits a non-regex Perl 6 talk to the Copenhagen Open Source days

[15:20] <moritz_> we now have two regex talks

[15:20] <moritz_> masak++ and me

[15:20] <pmichaud> I need to see if jonasbn reserved a talk spot for me or if I should still submit

[15:20] <moritz_> pugs: my $a = 5; my @b; @b[0] := $a; $a = 6; say @b

[15:20] <moritz_> pmichaud: you should

[15:21] <pmichaud> I'll do that shortly.

[15:21] <moritz_> in his mail yesterday he wrote "something, if anybody else intends to give a talk, please submit your abstract ASAP to: [email@hidden.address] and Cc me."

[15:21] <moritz_> where me = jonasb <at> gmail

[15:22] <_ash> are there any other shortcuts for := binding? just curious if there is a way to write it like my @a = ($b) and get a similar kind of binding

[15:22] <moritz_> I'm not aware of any

[15:23] <pmichaud> my @a = \$b;   # might work

[15:23] *** iblechbot joined
[15:23] <pmichaud> rakudo:  my $a = 5;  my @b = \$a;  $a = 6;  say @b;

[15:23] <pmichaud> ENOP6EVAL

[15:24] <pmichaud> > my $a = 5;  my @b = \$a;  $a = 6;  say @b;

[15:24] <pmichaud> 6

[15:24] <_ash> if you msg p6eval it works

[15:24] <_ash> that printed 6 since i messaged it 

[15:25] <_ash> so, in theory, you could do my @a = (\$b, \$c); $b = somethingelse; $c = somethingelse and @a is updated? 

[15:25] <pmichaud> I believe so.

[15:26] <_ash> does my $a = \$b; work similar to my $a := $b? 

[15:26] <pmichaud> yes.

[15:26] <pmichaud> they're slightly different, but the end result is the same

[15:26] <pmichaud> for many operations

[15:26] *** p6eval left
[15:26] <_ash> okay, cool

[15:26] *** p6eval joined
[15:27] <moritz_> rakudo:  my $a = 5;  my @b = \$a;  $a = 6;  say @b;

[15:27] <_ash> ng: say 'hi'';

[15:27] <moritz_> I don't understand what's wrong

[15:28] <moritz_> I see all the messages in the logging console

[15:28] <moritz_> pugs: say 1

[15:28] <_ash> it worked when i messaged it still, so you know

[15:28] <korpenkraxar> hi all! what text editors/IDEs are there out there that can do Perl 6 syntax highlighting and/or checking? I only know of Padre, but have not used it for Perl 6 yet.

[15:28] <moritz_> there's a Perl 6 plugin for Padre

[15:29] <moritz_> and there's a rather good syntax file for vim

[15:29] <_ash> vim and emacs too as always, although the emacs one's a bit spotty at times

[15:29] <moritz_> and a slightly less up-to-date one for emacs

[15:29] <hudnix> oh , where can I find the emacs one?

[15:29] <moritz_> in the pugs repo in misc/

[15:30] <moritz_> no

[15:30] <moritz_> util/ or so

[15:30] <hudnix> thanks

[15:30] <moritz_> http://svn.pugscode.org/pugs/util/cperl-mode.el

[15:30] <moritz_> hudnix: if you want to update it, I can give you a commit bit - just /msg me your email address and desired nickname

[15:31] <hudnix> ok, I'll take a look

[15:31] *** ruoso left
[15:31] <moritz_> (or if I'm offline, ask somebody else - many people here can hand out commit bits)

[15:31] <_ash> the emacs one is a bit dated, as a warning 

[15:31] * hudnix has given up getting padre working on his ubuntu box

[15:32] <moritz_> #padre on irc.perl.org is usually very friendly

[15:32] *** JimmyZ left
[15:32] <hudnix> yeah, they gave up on me when they found out I've been forcing my cpan installs :)

[15:33] <moritz_> :-)

[15:33] <moritz_> I do that too at times, I have to admit

[15:37] *** cognominal joined
[15:38] *** Psyche^ joined
[15:39] *** ejs1 left
[15:46] <Su-Shee> me too. especially gui stuff which tries to activate a test requiring popping up a window - which will fail if I'm root or work over the net. 

[15:49] *** ruoso joined
[15:52] *** ejs joined
[15:54] *** Patterner left
[15:56] <jnthn> pmichaud: pong

[15:57] *** Psyche^ left
[15:58] *** nihiliad left
[15:59] *** Patterner joined
[16:06] *** nihiliad joined
[16:08] <_ash> my is a lexical function right? 

[16:13] <pmichaud> jnthn: was just noticing a few things about the binder code

[16:13] <pmichaud> currently, the binder expects to create the objects and set their properties?

[16:14] *** moritz_ sets mode: +oo jnthn _ash

[16:14] <jnthn> pmichaud: I think in ng we're duplicating some of the work there.

[16:14] <pmichaud> okay.

[16:14] <jnthn> pmichaud: e.g. they get set up as lexical decls

[16:14] <jnthn> But then the binder re-does it.

[16:14] <pmichaud> right.

[16:14] <jnthn> There's some cleanup to be done there, I suspect.

[16:14] <pmichaud> which one _should_ be doing it?

[16:15] <jnthn> Suspect the binder.

[16:15] <jnthn> Oh

[16:15] <jnthn> I know why we're doing this.

[16:15] <jnthn> Parrot regalloc issue iirc - if you don't init a register visibly somewhere, it reuses them and the lexicals end up sharing registers. :-( :-(

[16:15] <pmichaud> that's a different issue

[16:15] <pmichaud> oh, wait, no it isn't

[16:16] <pmichaud> well, we could certainly simply do    null $P0

[16:16] <pmichaud> instead of having to allocate an object

[16:17] <jnthn> pmichaud: We could.

[16:18] <jnthn> pmichaud: It was in the back of my mind as a "thing to revisit at some point to be more optimal"

[16:18] <pmichaud> okay

[16:18] <jnthn> Though I've been more concerned about making things work / correct semantics for now. :-)

[16:18] <pmichaud> yeah, I think we have a few inefficiencies in place

[16:19] <pmichaud> I just modified the binder in ng1 so that it creates a Parcel for slurpy args instead of a RPA

[16:19] <pmichaud> I'm also wondering if it's possible for me to eliminate the 'flatten' property soonish

[16:19] <pmichaud> ...but not entirely certain about that yet.

[16:19] <jnthn> OK.

[16:20] <moritz_> pmichaud: push it

[16:20] <jnthn> That shoulda helpefully been an easy change.

[16:20] <pmichaud> it was

[16:20] <_ash> ng: say 'hello p6eval?':

[16:21] <_ash> hmm odd

[16:21] <moritz_> somehow p6eval is even more broken than it used to be

[16:22] *** sukomalo joined
[16:23] * moritz_ has to leave, see ya all tomorrow

[16:24] <_ash> moritz_: i think diakopter fixed class creation in it though

[16:24] <_ash> in rakudo i mean specifically

[16:24] *** ruoso left
[16:25] *** SmokeMachine joined
[16:29] *** alester joined
[16:34] <pmichaud> jnthn: I'm thinking I'd still like all of an array's elements to share a common prophash.  Any reason you can think that might not work?

[16:42] *** ejs1 joined
[16:42] *** ejs left
[16:43] *** colomon joined
[16:44] *** _ash left
[16:59] *** lnoxuwh joined
[16:59] *** lnoxuwh left
[16:59] *** justatheory joined
[17:01] *** riffraff joined
[17:02] *** payload left
[17:04] *** lumi left
[17:04] *** lumi joined
[17:05] *** pmurias joined
[17:09] *** ejs1 left
[17:17] *** silug joined
[17:17] <pmichaud> TimToady: I'm rapidly coming to a point where I could use at least a hint on Pm-19.

[17:17] <pmichaud> (it's okay if it's a provisional answer)

[17:18] <TimToady> still recovering from having to take antihistimines last night, but will look

[17:18] <pmichaud> understood

[17:18] <pmichaud> (and thanks)

[17:19] <TimToady> btw, haven't finished backlogging, but if you want something transactional, maybe you want a transactional verb like commit

[17:19] <TimToady> or purify, or something

[17:19] <pmichaud> those seem plausible also

[17:19] <pmichaud> for the moment I've gone with making Array and Seq strictly eager, just to get me over the current humps

[17:20] <TimToady> also "eager" defaults to mostly eager; spec says you don't get either of strict eager or strict lazy without pragmas, iirc

[17:20] <pmichaud> oh, if that's the case, I can definitely live with that

[17:20] <pmichaud> would that be true of the 'eager' listop, as well?

[17:20] <pmichaud>     my @a = eager 1..*;    # still returns a lazy list?

[17:23] <TimToady> if it makes things simpler, sure

[17:23] <pmichaud> okay

[17:23] <TimToady> eager doesn't mean you get what you want :)

[17:23] <TimToady> that would be more like demanding

[17:24] <pmichaud> and just to verify -- same is true for 'lazy' -- it's "mostly lazy" by default and you have to do something special to mean "strictly lazy"?

[17:24] <TimToady> parsimonious or some such :)

[17:24] <pmichaud> okay

[17:25] <pmichaud> need to fold those into my mental model, but that does simplify things a bit, I think

[17:26] <TimToady> I think the answer for Pm-19 is that map is transparent to the parcel structure of the input, running on each element, but preserving parcel structure in the output

[17:26] *** jackyf joined
[17:26] <TimToady> (with extra parcel around each map results)

[17:26] <TimToady> but that could just be SleepyBrane talking

[17:26] <pmichaud> ummmm. ouch

[17:27] <pmichaud> I hope that's sleepy brane

[17:27] <TimToady> yes, I agree, but it seems to be what's wanted semantically to keep the binding lazy

[17:27] <TimToady> or the assignment

[17:27] <pmichaud> what if the {...} block took 3-at-a-time instead of 1-at-a-time

[17:27] <pmichaud> ?

[17:27] <pmichaud> then how would we preserve the parcel structure?

[17:28] <TimToady> good question

[17:28] <pmichaud> and colomon++ also posed the possibility that a 1-at-a-time input could be producing parcels of n elements

[17:28] <TimToady> that part's easy

[17:28] <pmichaud> (indeed, there's not even a requirement that the parcels produced by .map are all of the same "dimensions")

[17:29] *** rblasch left
[17:30] <pmichaud> fwiw, my (weak) preference at this point is that we require the input to map to explicitly indicate slicing if that's what is desired

[17:30] <pmichaud> (slice 1,2,3 X 4,5,6).map({...})

[17:31] *** alester left
[17:31] <TimToady> or (1,2,3 X 4,5,6).slice.map?

[17:31] <pmichaud> that'd be fine also

[17:32] <pmichaud> in general I tend to treat the prefix listops as method forms :-)

[17:32] <pmichaud> the alternative is that we always assume slices, and explicitly require list for 1-at-a-time

[17:32] <pmichaud> the tricky part to that is that we sometimes get sliced parcels even when we didn't intend them

[17:33] <pmichaud> so it tends to make sense to default to list context until explicitly indicated otherwise

[17:33] <TimToady> no, I think flat is better

[17:34] <pmurias> why is strictly lazy and strictly eager pragma only?

[17:34] <pmichaud> I'll start that way for now then

[17:34] <pmichaud> we can leave the question open in Pm-19 for now

[17:34] <TimToady> strictly eager is good mostly for blowing up memory

[17:35] <TimToady> strictly lazy is good mostly for writing impenetrably recursive Haskell definitions

[17:35] <pmichaud> but I'll assume that map gets 1-at-a-time "flat" semantics for now

[17:35] <pmichaud> thanks

[17:35] <TimToady> might possibly have a pmap that does parcel at a time, say

[17:35] <pmichaud> that could happen too

[17:36] <pmichaud> but then we might want a pgrep also :)

[17:36] <TimToady> or meta-operators on postfixes :)

[17:37] * pmichaud is NOT going there today.  :)

[17:38] <pmichaud> would it make sense to use Iterable as a designator that "this data structure tends to flatten in flattening contexts?"

[17:38] *** cdarroch joined
[17:38] <pmichaud> (keeping in mind that other things might suppress that, such as storage in a scalar var)

[17:38] *** alester joined
[17:38] <TimToady> or maybe it's just -> \$parcel {...} or some scuh

[17:38] <TimToady> such, even

[17:39] <TimToady> also -> @@slice {...} might be useful

[17:39] <pmichaud> ooooh

[17:40] <pmichaud> I like --> @@slice

[17:40] <TimToady> well, except for the @@, which nobody likes :)

[17:40] *** macae joined
[17:40] <pmichaud> that might be a bit tricky, still

[17:41] <TimToady> yes, well, that's why it should be up to a signature how much it binds, not .arity

[17:41] <pmichaud> especially if we have something like    -> $a, @@slice { ... }

[17:41] <TimToady> I keep saying that...

[17:42] <pmichaud> oh, I agree fully it shouldn't be .arity (or .count).  I'm just waiting for the construct that lets me do a partial bind of a signature against an active iterator :-)

[17:42] * jnthn wishes he'd first heard TimToady say this before he'd re-designed the signature binder :-)

[17:43] <jnthn> Think I can do it without too many changes...

[17:43] <TimToady> basically, has to have a backchannel for the modified capture to feed on to the next iter

[17:44] <TimToady> I wrote a way to do that once by cheating with a where block at the end

[17:45] <TimToady> something like \$remainder where { $external_state = $remainder }

[17:45] <pmichaud> on the other question I just posed...

[17:45] <jnthn> Could it not be a way of calling with an iterator, and it just iterates it a bit?

[17:45] <TimToady> but one needs a way of specifying that in the forward direction too

[17:45] <pmichaud> 17:37 <pmichaud> would it make sense to use Iterable as a designator that "this data structure tends to flatten in flattening contexts?"

[17:46] <TimToady> how does binding to a capture not iterate its positions anyway?

[17:46] <jnthn> And then after the call you're ready for the next one.

[17:46] <jnthn> TimToady: It does, my point is why do we need a "here's what's left" backchannel?

[17:46] <jnthn> TimToady: If it's used the iterator to obtain N values that it needed to do the binding, for example.

[17:47] <TimToady> ah, yes, that's perhaps a better way to look at it

[17:47] <pmichaud> yes, that's what I was thinking

[17:47] <jnthn> TimToady: Then the next call, it'll pass in the smae iterator as the argument source.

[17:47] <pmichaud> we need to rethink much of the spec replacing the word "list" with "active iterator", I think.

[17:47] <TimToady> so we only need the forward signal that says OK to leave some

[17:47] <jnthn> Yeah.

[17:47] <pmichaud> i.e., "list" is something that we tend to consume elements from

[17:48] <TimToady> I don't generally believe in lists these days

[17:48] <pmichaud> (I'm finding that in the current implementation of stuff as well)

[17:48] <TimToady> it's a figment of the user's imagination

[17:48] <TimToady> it's all really parcels and captures and iterators and such

[17:48] <pmichaud> well, "List" is starting to look like it's a mechanism for grabbing elements from a set of iterators using list context

[17:49] <TimToady> yes

[17:49] *** yahooooo left
[17:49] <TimToady> so I try to avoid the term in describing any data structure

[17:49] <pmichaud> it also seems to be the thing that we use to talk about "all of the remaining elements of an iterator" -- i.e., to turn an iterator back into something that can flatten

[17:49] <TimToady> (internally)

[17:49] <pmichaud> (without actually producing the iterator's elements at that point)

[17:50] <TimToady> isn't that just whether the next binding is slurpy?

[17:51] <TimToady> hmm, there's a problem with mutable capture

[17:51] <TimToady> nextsame

[17:51] <jnthn> ah, hm.

[17:51] <jnthn> :-/

[17:51] <jnthn> That is a problem.

[17:52] *** stephenlb joined
[17:52] <TimToady> capture more like a Seq with a pointer into it?

[17:52] <TimToady> s/pointer/index/

[17:52] <jnthn> Maybe...

[17:53] <TimToady> or possibly pessimize to that when we see nextsame

[17:54] <TimToady> you're not "consuming" the capture currently, are you?

[17:54] <TimToady> (or nextsame wouldn't work)

[17:55] <TimToady> so maybe we're not losing much by keeping a cursor into it

[17:55] <jnthn> TimToady: No, relying on captures being immutable.

[17:56] <TimToady> yes, it's the original string you're parsing, as it were, and the work is done by cursors

[17:56] <jnthn> TimToady: Iteration of the capture doesn't modify the capture.

[17:56] *** uniejo joined
[17:57] <TimToady> but the positionals have to get reified internally

[17:57] <TimToady> that's more like a Seq

[17:58] <TimToady> (current definition of Seq)

[17:59] <pmichaud> on a related noted, if I have    my $a = Seq($b, $c);

[17:59] <TimToady> are you saying that we can use the internal reified status as the cursor?

[18:00] <pmichaud> does $a get the values of $b and $c or does it actually refer to the $b and $c containers?

[18:00] <TimToady> in any case, a sig of ($a,$b,\$c) wants to know the state after binding two positionals

[18:00] *** ejs joined
[18:00] <TimToady> hmm, and nextsame has to reset that state, urq

[18:00] <jnthn> TimToady: What do you mean by "know the state"?

[18:01] <TimToady> the place to begin parsing the next time

[18:01] <jnthn> TimToady: Well yes, nextsame essentially needs a "snapshot" of the state.

[18:01] <pmichaud> e.g.:   my ($b, $c) = 4,5;  my $a = Seq($b, $c);  $b++;  say $a;   #  "4 5"  or "5 5" ?

[18:02] <jnthn> TimToady: It gets that now just by virtue of the capture being immutable, so it staches that away.

[18:02] <jnthn> *stashes

[18:02] <jnthn> Which is cheap.

[18:03] <TimToady> so the current binding position is an external cursor into the capture

[18:03] <jnthn> Right.

[18:03] * pmichaud wanders off to lunch.

[18:03] <TimToady> that's what we need to keep around for the next map etc

[18:04] <jnthn> Oh, I'd not seen in that way.

[18:04] <jnthn> I'd seen the bind as working us through the iterator, but we remember the position before we start, and make that available to nextsame.

[18:04] <TimToady> and nextsame uses the cursor that was in effect at the beginning of the call

[18:04] <jnthn> So it can "replay" the bind.

[18:05] *** uniejo left
[18:05] <TimToady> we can bind to further than the iterator reifies, when we bind a slurpy

[18:05] <jnthn> Wouldn't a slurpy just end up sucking in the lot?

[18:06] <TimToady> not in the eager sense

[18:06] <pmichaud> 17:37 <pmichaud> would it make sense to use Iterable as a designator that "this data structure tends to flatten in flattening contexts?"

[18:06] <TimToady> a lazy slurpy has to copy in the remaining iterator

[18:06] <pmichaud> oops

[18:06] *** dakkar left
[18:07] <TimToady> no, you can't use intrinsic typing for the flattening decision

[18:07] <pmichaud> not completely, no, but as part of it?

[18:07] <TimToady> or $array starts flattening

[18:08] <TimToady> yes, Iterable does mean "flattenable"

[18:08] <pmichaud> i.e., check the container (or reference) to see if it's "don't flatten", and if not, then check the type

[18:08] <TimToady> or to put it another way, flattening a non-Iterable is the identity function

[18:10] <TimToady> hmm, I think I just came up with an argument against @@

[18:11] <TimToady> we bind to a sequence of parcels with *@@

[18:11] <TimToady> but how do we bind to a single parcel?

[18:12] <pmichaud> right now in ng1 I have Parcel as a object that doesn't tend to disappear

[18:12] <TimToady> the *$,*@ trick doesn't work out, or we'd get *$$,*@@

[18:13] <pmichaud> wouldn't bind to a single parcel just be @@ by itself?

[18:13] <TimToady> what we really want is something more like **$,**@

[18:13] <TimToady> @@[*$,*@] maybe

[18:15] *** snearch joined
[18:16] <pmichaud> afk, lunch

[18:16] <TimToady> but I'm thinking maybe we want something else to say "look for a parcel here"

[18:16] <TimToady> and leave the sigils out of it

[18:17] <TimToady> maybe steal \

[18:17] <TimToady> and use |$c to trap binding state

[18:17] *** pmurias left
[18:18] *** lisppaste3 left
[18:18] <TimToady> then -> \$x {...} maps parcel to parcel

[18:18] <TimToady> *\$ and *\$ fall out naturally too

[18:19] <TimToady> er, s:2nd/'$'/@/

[18:19] <TimToady> and ugly @@ can probably die

[18:20] <TimToady> shower &

[18:20] *** uniejo joined
[18:21] <TimToady> or maybe | is the opposite of flattening

[18:23] <sjohnson> OT: anyone ever been super close to having their car towed, and saved it at the nick of time?

[18:23] <sjohnson> in*

[18:23] *** cjk101010 joined
[18:26] *** lisppaste3 joined
[18:32] *** uniejo left
[18:33] *** riffraff left
[18:37] *** lumi left
[18:37] *** lumi joined
[18:49] *** ruoso joined
[18:51] *** ejs left
[18:52] *** bluescreen left
[19:00] *** sukomalo left
[19:01] *** snearch left
[19:07] *** bluescreen joined
[19:10] <hudnix> no, but I once succeeded in getting my piece of crap car towed...

[19:10] *** stephenlb left
[19:13] *** stephenlb joined
[19:13] <colomon> RangeIterator is Iterator !  \o/

[19:17] <colomon> ooo, and range-iterator.t runs now.  nice.  pmichaud++

[19:19] *** cognominal left
[19:22] <pmichaud> jnthn: I'm thinking I'd still like all of an array's elements to share a common prophash.  Any reason you can think that might not work?

[19:25] * pmichaud walks off to think for a while.

[19:26] <sjohnson> hudnix: thanks for sharing

[19:32] *** alester left
[19:35] *** wu1 joined
[19:38] *** mikehh joined
[19:39] *** diakopter sets mode: -R
 
[19:39] <diakopter> oops

[19:40] *** ShaneC joined
[19:46] *** supernovus joined
[19:48] <supernovus> If I make a container class using something like: class MyArray is Array { ... }  shouldn't I be able to use it later by doing my @array is MyArray; ?

[19:49] <pmichaud> yes

[19:49] <pmichaud> but 'is MyArray' is NYI in rakudo

[19:50] <supernovus> Ah, okay, that explains the problem I was having... is there a way to force the container class without using 'is' that works in Rakudo currently?

[19:50] <pmichaud> no

[19:50] <pmichaud> and I don't think there are tests for the behavior yet (hint hint)

[19:51] <pmichaud> you could potentially do   my $array = MyArray.new();

[19:51] <jnthn> pmichaud: Sorry, was afk nomming...common prophash may well work.

[19:51] <jnthn> pmichaud: What's gonna go in there?

[19:51] <pmichaud> rw, mainly

[19:51] <jnthn> OK

[19:51] <pmichaud> any common type information

[19:51] <jnthn> Just wanted to make sure you didn't expect type in th...d'oh. :-)

[19:51] <jnthn> pmichaud: Type information comes through the role parameter. :-)

[19:52] <jnthn> Though I guess you could cache it in the prophash...

[19:52] <pmichaud> you mean on the array?

[19:52] <jnthn> Yeah

[19:52] <jnthn> @foo.of # what's the type constraint on my elements

[19:52] <pmichaud> ultimately we end up doing !STORE on the element, and that's what's does the type check

[19:52] <pmichaud> *what

[19:52] <jnthn> Right, agree.

[19:52] <pmichaud> so if the element doesn't have type information on it, then there's no typecheck

[19:53] <pmichaud> it's okay for the type information to be in two places

[19:54] <pmichaud> and I'd be fine if the shared prophash simply had its 'type' property bound to the 'of' property of the Array 

[19:54] <pmichaud> (or role, or whatever)

[19:54] <jnthn> Yup, we could also do that.

[19:54] <jnthn> The type info don't change once it's set anyway.

[19:54] <pmichaud> well, it might.  or we'll have to get a little fancier on type checks

[19:54] <pmichaud> but I suspect we'll have to do that anyway

[19:55] <jnthn> Trying to change the type of things an already created and populated array accepts is Really Evil. :-)

[19:56] <pmichaud> oh, it's not changing the type that would do it

[19:56] <pmichaud> my Int $b = 4;   my Num @a;   @a[0] := $b;    @a[0] = 3.4; 

[19:57] *** silug left
[19:57] <pmichaud> @a[0] ends up with two constraints at runtime

[19:57] <pmichaud> it has its own constraint (Num), as well as the constraint of the underlying thing it's bound to (Int)

[19:57] <jnthn> oh, ouch.

[19:58] <jnthn> But yes, true.

[19:58] <pmichaud> so, we're not really "changing" the type of @a[0] -- we just have to know to check multiple types

[19:58] <pmichaud> because @a[0] can still be re-bound to something else

[19:58] <pmichaud> anyway, the type property for any individual container is effectively immutable, yes.

[19:59] <pmichaud> I'm also wondering if I can find a good way to identify container PMCs

[20:00] <pmichaud> including things that may objectref a container PMC

[20:01] <jnthn> I think somewhere in S32 it aludes to a Container role or some such.

[20:01] <pmichaud> well, I'd prefer it to be a "fast check" :-)

[20:01] <pmichaud> .ACCEPTS(Container)  is likely to be unbearably slow 

[20:03] <pmichaud> anyway, I'll try out the shared prophash shortly then.  Glad you don't see any obvious blockers for that.

[20:04] <jnthn> No, we'd discussed it before, and I don't remember having any objections - I just mostly cared about the types stuff, which I could do without a property on everything in a different way.

[20:05] <pmichaud> I don't understand that last bit... but okay.  :)

[20:06] <jnthn> pmichaud: Yeah, that sentence was a tad fail...

[20:07] <jnthn> pmichaud: I meant that because I did typed arrays using parametric role stuff, I didn't need to stick a property on everything.

[20:07] <pmichaud> right

[20:07] <jnthn> Now we care about doing More Other Stuff.

[20:08] <jnthn> But I think we'd got to the point of agreeing it was workable before, I just didn't ever do it because I didn't need it. :-)

[20:08] <pmichaud> I couldn't remember if we agreed it would work or not

[20:08] <pmichaud> plus, things could've happened in the interim to say "oh yeah, that won't work because... "

[20:09] <pmichaud> anyway, having a shared prophash will make things a ton easier on this end :-)

[20:13] <pmichaud> jnthn: can you think of any easy (and reasonably efficient) way to have objects of the Iterator class automatically receive a 'flatten' property?

[20:13] <pmichaud> maybe override the init_pmc vtable?

[20:14] <jnthn> That would do it.

[20:14] <pmichaud> if we override the init_pmc vtable, do we also have to make sure to somehow invoke the superclass' init_pmc ?

[20:14] <TimToady> hmm, has to be able to happen halfway through a sig binding

[20:14] <jnthn> pmichaud: What's the interface to create an iterator?

[20:14] <pmichaud> or does that happen automatically somehow?

[20:14] <jnthn> pmichaud: Probably, yeah, which is...ugh.

[20:15] <jnthn> pmichaud: tbh I'd rather avoid relying too much on vtable overrides.

[20:15] <pmichaud> that's fine, me also

[20:15] <pmichaud> any other way you can think of to optimize a check for "isa Iterator" or "does Iterator"?

[20:16] <pmichaud> or, alternatively, a way to optimize "doesn't Iterator"  :-)

[20:16] <TimToady> maybe the default is flat, and we have a getitem for positionals (that aren't in any repeating sig)

[20:17] <jnthn> pmichaud: Perhaps some kinda caching scheme.

[20:17] <jnthn> pmichaud: But I'd rather optimize those in general rather than special case this.

[20:17] <pmichaud> jnthn: well, I strongly suspect that most things will be checked for flattening behavior only once

[20:18] <pmichaud> complete arrays and hashes being the exception

[20:18] <TimToady> I think iterators should assume they're flattening unless specifically told otherwise, item by item

[20:18] <pmichaud> TimToady: yes, that's not the difficulty

[20:18] *** cotto_work left
[20:19] *** cotto_work joined
[20:19] <pmichaud> the main thing that has to flatten is a Parcel

[20:19] <jnthn> The hard bit is doing that check quickly.

[20:19] <jnthn> Our isa is a bit slow... :-/

[20:20] <TimToady> introspection is usually wrong

[20:20] <jnthn> pmichaud: I'd say worry about correct semantics over going really fast for now on that part.

[20:20] <pmichaud> but in general, it would be more useful if we could quickly know that something *doesn't* flatten

[20:20] <TimToady> I'd say that Iterator *overrides* .get

[20:20] <TimToady> and normal .get is identity

[20:21] <pmichaud> well, that's a method call overhead

[20:21] <jnthn> pmichaud: Hmm. Trouble is we're generlly more optimized for when a does check is gonna succeed.

[20:21] <TimToady> you have method call overhead anyway

[20:21] <pmichaud> (I'm fine with method call overhead for now)

[20:21] <TimToady> why not use the existing mechanism?

[20:21] <TimToady> presumably cached already too

[20:21] <pmichaud> but more generally, it's possible that .get will give me back something that needs further flattening (in list context)

[20:22] <TimToady> introspection is almost always a design smell

[20:22] <TimToady> whether it's .isa or .arity

[20:22] <pmichaud> so I still have to check whatever I .get to see if more flattening can occur

[20:22] <pmichaud> (I could check for identity.)

[20:22] <TimToady> or looking at passive properties

[20:23] <pmichaud> but checking .get for identity seems smelly also

[20:24] <TimToady> some ideas are worth a bit in the data structure

[20:24] <pmichaud> well, that's effectively what a property is

[20:24] <pmichaud> also, flattening/non-flattening has to be a property of the container, not just the object

[20:26] * jnthn gotta go for a bit - also something is very wrong with my net connection today and it keeps dropping. :-/

[20:26] <jnthn> back later

[20:26] <pmichaud> ok, afk for a walk also

[20:27] <TimToady> lunch, and thinking about how map's sig is actually in the variadic area of some implicit supersig

[20:29] *** japhb left
[20:36] *** _ash joined
[20:37] *** lumi left
[20:37] *** lumi joined
[20:39] *** jonasbn joined
[20:49] <pmichaud> brane hurts, going to bed

[20:49] <diakopter> !

[20:49] *** athaba left
[20:49] *** jackyf left
[20:58] *** macae left
[21:00] *** ignacio_ joined
[21:00] *** niros joined
[21:03] <_ash> pmichaud: i am sure your aware of this but on ng1 i get the following when i do @a.perl;

[21:03] <_ash> > my @a = [1, 2]; say @a.perl;

[21:03] <_ash> Method 'perl' not found for invocant of class 'ResizablePMCArray'

[21:03] <_ash> my @a = (1, 2); say @a.perl; works though

[21:06] <colomon> _ash: ng1 actually fails the basic test for arrays (the one that "make test" runs) right now.  

[21:06] <_ash> ah, okay, i just wanted to make sure it was known a parrot object was leaking into perl6, thats all

[21:08] <colomon> not a bad thought, at all.

[21:09] <colomon> I'm just warning you not to expect any Array-related code to work at the moment in ng1.

[21:09] <_ash> although, my @a = [1, 2]; say @a.WHAT; returns Array 

[21:09] <_ash> yeah

[21:09] <_ash> i figured as much

[21:10] *** FurnaceBoy_ joined
[21:10] <colomon> ng: my @a = [1, 2]; say @a.perl

[21:10] <p6eval> ng b8201f: OUTPUT«[[1, 2]]␤»

[21:13] *** FurnaceBoy_ left
[21:15] *** Su-Shee left
[21:24] *** jonasbn left
[21:24] *** athaba joined
[21:24] *** SmokeMachine left
[21:30] *** ruoso left
[21:30] *** japhb joined
[21:31] *** felipe left
[21:36] *** lumi left
[21:36] *** lumi joined
[21:42] *** felipe joined
[21:47] *** jferrero joined
[21:55] *** cjk101010 left
[22:01] *** pnate2 left
[22:05] *** Ouse26698 joined
[22:06] *** silug joined
[22:06] *** REPLeffect left
[22:06] *** REPLeffect joined
[22:11] *** patspam joined
[22:15] *** bluescreen left
[22:19] *** uniejo joined
[22:19] *** pmurias joined
[22:19] <diakopter> anyone around to commit a synopsis typo for me?

[22:20] <diakopter> (no pugs checkout here)

[22:20] <diakopter> in S02:    undefined instance ofthat

[22:20] <diakopter> oh, I guess I do have one on the p6eval vps

[22:22] <pmurias> diakopter: i could do that, you could checkout just the synopses though

[22:22] <diakopter> done

[22:22] <pugs_svn> r29594 | diakopter++ | [S02] typo 

[22:27] *** korpenkraxar_ joined
[22:31] *** ignacio_ left
[22:33] *** [particle] left
[22:36] *** korpenkraxar left
[22:39] *** knewt joined
[22:42] *** iblechbot left
[22:46] *** knewt is now known as knewt2

[22:49] *** lumi left
[22:52] *** Chillance left
[22:53] *** lumi joined
[22:59] *** wasy is now known as wasy_afk

[23:01] *** [particle] joined
[23:01] <diakopter> anyone: the only interface to buf8/buf16/buf32 is the positional indexer?

[23:03] <diakopter> also, how would one know whether a buf holds ints or uints? (referring to   buf         native buffer (finite seq of native ints or uints, no Unicode)

[23:03] <diakopter> )

[23:05] <pmurias> diakopter: shouldn't a unint buf be a different type?

[23:05] *** lumi left
[23:05] *** frioux left
[23:05] *** frew joined
[23:05] *** lumi joined
[23:05] <diakopter> pmurias: yes, but I don't see that defined/explained in S02

[23:06] *** supernovus left
[23:09] <diakopter> here's my assumption/inference:

[23:11] <diakopter> buf of uint  -  buf32 of uint32

[23:11] <diakopter> buf of int - buf32 of int32

[23:11] <diakopter> buf8 of uint - buf8 of uint8

[23:11] <diakopter> buf8 of int - ??

[23:12] <diakopter> buf16 of uint - buf16 of uint16

[23:12] <diakopter> etc.

[23:13] <diakopter> does this mean you always must declare the item type of a native buf container?  

[23:13] <diakopter> or is there a default one?

[23:13] <diakopter> (byte?)

[23:14] *** k23z__ left
[23:16] <diakopter> pmurias: any thoughts?

[23:17] *** REPLeffect left
[23:18] *** REPLeffect joined
[23:19] <diakopter> or must you declare either 1) a number of bits per buf element, or 2) the element type?

[23:20] *** payload joined
[23:21] *** korpenkraxar_ left
[23:22] <diakopter> how does one define the length of a buf one wants to initialize?

[23:25] <diakopter> I'd be glad to write some tests to  t/spec/S02-builtin_data_types/buf.t  once I know how to write them

[23:28] <pmurias> diakopter: the buf (withought a number takes the length from the string it's initialised with)

[23:30] <pmurias> diakopter: buf16 of uint seems a bit confusing, as it might not be a buffer made of uints

[23:30] <diakopter> ok, but how do you declare the length of a buf without an initializing string

[23:31] <diakopter> I mean, I take it a buf is supposed to serve as the lowest level array of numbers (regardless of whether they're intended to represent strings/chars)

[23:32] *** uniejo left
[23:33] <pmurias> buffers are mutable?

[23:35] <pmurias> diakopter: my buf16 $foo;$foo[30] = 5;

[23:35] <pmurias> diakopter: i think the resize when needed

[23:36] <diakopter> but

[23:37] <diakopter> that's what I'm asking

[23:38] <diakopter> it doesn't make sense to me if the length is mutable.

[23:38] <pmurias> why shouldn't it be

[23:38] <diakopter> I mean, I thought it was supposed to be a "compact array"

[23:38] <pmurias> it is

[23:38] <diakopter> but not necessarily laid out sequentially in memory?

[23:39] <pmurias> normal arrays are laid sequentially in memory

[23:39] <diakopter> I don't see "normal array" in these lists of native types

[23:40] <pmurias> if you want to resize a buffer just alloc a new bigger chunk of memory and copy over the old stuff

[23:41] <diakopter> are you saying the Perl 6 user should do that? or the Perl 6 engine behind the scenes?

[23:41] <pmurias> the Perl 6 engine

[23:41] <diakopter> ok. why wouldn't Array of <native type> be considered a native type?

[23:42] <pmurias> because it's an Array

[23:43] <pmurias> native types aren't a fully featured objects (so that some overhead is avoided)

[23:44] <diakopter> that much I knew.

[23:45] <diakopter> but your answer of "because it's an Array" doesn't answer the question

[23:45] <pmurias> why doesn't it?

[23:45] <diakopter> I knew it was an Array; I was asking what makes it an Array such that it's not a native type?

[23:45] <Tene> pmurias: what behavior must "Array of int" support, such tha tit's "fully featured" in ways that would not work for a native type?

[23:46] * pmurias looks

[23:46] <diakopter> and if it has anything, why isn't there a lower-level native type of a fixed-length array of native types?

[23:48] *** wjl_ joined
[23:48] <diakopter> and if Array is the lowest-level fixed-length vector, how then does one declare the length of the Array at initialization?

[23:48] <diakopter> (without assigning it a Range uselessly, I guess)

[23:49] <diakopter> pmurias: wait a second, Array's length is mutable

[23:49] <diakopter> why did you say it's immutable

[23:50] <pmurias> diakopter: did i? maybe it's too late for me to speak sensibly

[23:51] <diakopter> hm. maybe you didn't. perhaps I wrongly inferred you implying that.

[23:52] <diakopter> (from when you said "normal arrays are laid out sequentially in memory")

[23:52] *** aesop joined
[23:52] <pmurias> Tene: you can mix in things with does? you can store undefined values in a thing of Array type

[23:52] <diakopter> I don't see how an Array can be laid out sequentially in memory if its length is mutable.

[23:53] <diakopter> that's just impossible.

[23:53] <pmurias> how do you imagine it being implemented?

[23:53] <diakopter> what do you mean by "it"

[23:53] <pmurias> an Array that's not sequentially laid out in memory

[23:54] <diakopter> I didn't say I was imagining that.

[23:55] <pmurias> diakopter: when you resize an Array it allocates an new block of memory and copies over the old data

[23:55] <diakopter> that's fine

[23:55] <diakopter> but that has nothing to do with what I'm asking for

[23:55] <pmurias> diakopter: you stated that's impossible

[23:55] <diakopter> I'm asking for something that does Positional with a fixed-length

[23:55] <diakopter> once initialized.

[23:55] <diakopter> and fixed item size.

[23:56] <diakopter> (a native type)

[23:56] <diakopter> or struct.

[23:56] <diakopter> I assumed that was buf

[23:57] <diakopter> pmurias: I did not say that was impossible.

[23:57] *** meppl left
[23:57] *** spinclad left
[23:57] *** hatsefla1s left
[23:57] *** eiro left
[23:57] *** krunen left
[23:57] *** Gothmog_ left
[23:57] *** constant left
[23:57] *** presh_ left
[23:57] *** hatseflats joined
[23:57] *** spinclad joined
[23:58] *** meppl joined
[23:58] *** lumi left
[23:58] <pmurias> diakopter: "That's just impossible."

[23:58] *** lumi joined
[23:58] <diakopter> your "that" is different from my "that"

[23:59] <pmurias> my int16 @array[100];

