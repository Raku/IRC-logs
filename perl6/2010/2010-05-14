[00:16] *** TiMBuS joined
[00:19] *** ruoso joined
[00:35] *** circuitbreaker left
[00:39] *** snarkyboojum left
[00:51] *** autin left
[00:53] <spinclad> rakudo: grammar g { rule TOP { a { say $\; make "b"} }; }; say g.parse("a").ast

[00:53] <p6eval> rakudo 7e0aa3: OUTPUT«Unsupported use of $\ variable; in Perl 6 please use the filehandle's :ors attribute at line 11, near "; make \"b\""␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[00:53] <spinclad> rakudo: grammar g { rule TOP { a { say $/; make "b"} }; }; say g.parse("a").ast

[00:53] <p6eval> rakudo 7e0aa3: OUTPUT«a␤␤»

[00:54] <spinclad> rakudo: grammar g { rule TOP { a { say $/; make "b"; say $/.ast } }; }; say g.parse("a").ast

[00:54] <p6eval> rakudo 7e0aa3: OUTPUT«a␤b␤␤»

[00:55] *** masonkramer joined
[00:55] <spinclad> rakudo: grammar g { rule TOP { a }; }; class a { method TOP($/) { say $/; make "b"; say $/.ast }; }; say g.parse("a").ast

[00:55] <p6eval> rakudo 7e0aa3: OUTPUT«␤»

[00:56] <spinclad> rakudo: grammar g { rule TOP { a }; }; class a { method TOP($/) { say $/; make "b"; say $/.ast }; }; say g.parse("a", :actions(a)).ast

[00:56] <p6eval> rakudo 7e0aa3: OUTPUT«a␤b␤b␤»

[00:58] <spinclad> so in { } in a rule, it gets $/ but doesn't seem to actually set its .ast; in :actions, it gets $/ and does set its .ast.

[00:58] <spinclad> should the first work, then?

[00:59] *** yinyin joined
[00:59] * spinclad afk -> dinner

[01:01] *** wknight8111 left
[01:09] *** snarkyboojum joined
[01:28] *** plobsing joined
[01:39] *** snarkyboojum left
[01:42] *** gfx joined
[01:46] <colomon> rakudo: say q{hello}

[01:46] <p6eval> rakudo 7e0aa3: OUTPUT«hello␤»

[01:47] <colomon> rakudo: my $a = "hello"; say q{$a world}

[01:47] <p6eval> rakudo 7e0aa3: OUTPUT«$a world␤»

[01:47] <colomon> rakudo: my $a = "hello"; say qq{$a world}

[01:47] <p6eval> rakudo 7e0aa3: OUTPUT«hello world␤»

[01:47] <sjohnson> yo dudes

[01:48] <colomon> o/

[01:49] <sjohnson> hi colomon, how's life?

[01:49] <colomon> pretty good, eh?

[01:49] <colomon> how are things with you?

[01:49] <sjohnson> not bad.  i did some *gasp* PHP work that i am proud of

[01:49] <sjohnson> (we chose to use PHP at work about 6 years ago, long before I knew perl :[

[01:50] *** BrowserUk joined
[01:50] <sjohnson> Perl and PHP are the main stuff we use at work

[01:51] <sjohnson> and often i find myself "outsourcing" many parsing jobs to a something.pl script

[01:51] <colomon> :)

[02:01] *** JimmyZ joined
[02:08] *** BrowserUk left
[02:32] *** ruoso left
[02:38] *** agentzh joined
[02:41] <eternaleye> rakudo: grammar g { rule TOP { a } } class g { method TOP($/) { make "b" } } say g.parse("a").ast

[02:41] <p6eval> rakudo 7e0aa3: OUTPUT«Confused at line 11, near "grammar g "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[02:41] <eternaleye> rakudo: grammar g { rule TOP { a } }; class g { method TOP($/) { make "b" } } say g.parse("a").ast

[02:41] <p6eval> rakudo 7e0aa3: OUTPUT«Illegal redeclaration of symbol 'g'␤current instr.: 'perl6;Perl6;Grammar;_block257' pc 42723 (src/gen/perl6-grammar.pir:272)␤»

[02:44] *** BrowserUk joined
[02:44] *** BrowserUk left
[02:49] *** masonkramer left
[02:53] *** nsh left
[02:54] *** nsh joined
[03:02] <lue> ohai

[03:04] *** JimmyZ left
[03:04] *** JimmyZ joined
[03:06] *** alester left
[03:13] *** {shade} left
[03:30] *** lestrrat is now known as lest_away

[03:31] *** justatheory left
[03:35] *** molaf joined
[03:36] <lue> echo $greeting

[03:36] <agentzh> lue: this is also a perfectly valid nginx.conf statement now ;)

[03:39] * agentzh imagines a day when he can write full-fledged perl 6 code in nginx.conf directly.

[04:03] *** {shade} joined
[04:23] *** gfx left
[04:37] *** rv2733 joined
[04:43] *** lest_away is now known as lestrrat

[05:05] *** jhuni joined
[05:29] *** Limbic_Region left
[05:46] <jhuni> rakudo: say [~] [xx] [xx] (2, 4)

[05:46] <p6eval> rakudo 7e0aa3: OUTPUT«2 2 2 22 2 2 2␤»

[05:47] <jhuni> rakudo: say [~] ( 2 xx 2 xx 2 xx 2 )

[05:47] <p6eval> rakudo 7e0aa3: OUTPUT«22222222␤»

[05:48] * jhuni confused

[05:52] <jhuni> rakudo: say [~] ( ((2 xx 2) xx 2) xx 2 )

[05:52] <p6eval> rakudo 7e0aa3: OUTPUT«22222222␤»

[05:58] <eternaleye> rakudo: say [~] ( \((2 xx 2) xx 2) xx 2 )

[05:58] <p6eval> rakudo 7e0aa3: OUTPUT«Capture()<0x4056fc0>Capture()<0x4056fc0>␤»

[05:59] <eternaleye> rakudo: say [~] ( [(2 xx 2) xx 2] xx 2 )

[05:59] <p6eval> rakudo 7e0aa3: OUTPUT«2 2 2 22 2 2 2␤»

[05:59] <eternaleye> jhuni: It looks like it's not flattening correctly. If I remember correctly, a bug has already been filed for that.

[06:01] <eternaleye> rakudo: .say for [\+] ([\+] (1..*)).batch(32) # From the same concept as triangular numbers... Tetrahedral numbers!

[06:01] <p6eval> rakudo 7e0aa3: OUTPUT«1␤4␤10␤20␤35␤56␤84␤120␤165␤220␤286␤364␤455␤560␤680␤816␤969␤1140␤1330␤1540␤1771␤2024␤2300␤2600␤2925␤3276␤3654␤4060␤4495␤4960␤5456␤5984␤»

[06:02] <jhuni> The replication operator works correctly

[06:02] <eternaleye> jhuni: It's more that parentheses aren't getting out of the way when they're supposed to sometimes

[06:03] *** molaf left
[06:05] <jhuni> does this have something to do with chaining?

[06:06] *** kel_ joined
[06:08] <eternaleye> jhuni: I don't think so

[06:08] <sorear> No

[06:09] <sorear> The Perl6 parcel/slicel semantics are still a tad murky, and Rakudo and the spec aren't in complete agreement yet

[06:10] <jhuni> rakudo: say [~] [Rxx] (2, 2, 2, 2)

[06:10] <p6eval> rakudo 7e0aa3: OUTPUT«22␤»

[06:13] <jhuni> rakudo: say ((2 ** 4) == (2 R** 4))

[06:13] <p6eval> rakudo 7e0aa3: OUTPUT«1␤»

[06:37] <sorear> TimToady: Do we have the technology to generate good error messages for *syntax* errors in PEGs?

[06:37] <sorear> Unable to parse blockoid, couldn't find final } at (20 lines away from the actual error) has gotten to the point where I want to do something about it

[06:43] <jhuni> If I am understanding this right, the xx operator looks like gather { take $a for 1..$b } from ./operators.pm on line 262

[06:58] <jhuni> yeah it looks like there is something wrong with the flattening, so now I wonder where the source code behind this flattening stuff is

[07:02] <sorear> As far as I know that doesn't exist

[07:03] *** meppl joined
[07:10] *** Bzek joined
[07:12] *** BrowserUk joined
[07:12] <BrowserUk> ?

[07:12] *** BrowserUk left
[07:16] *** iblechbot joined
[07:25] *** plobsing left
[07:41] *** snarkyboojum joined
[07:49] *** snarkyboojum left
[07:50] <jhuni> rakudo: say [~] (2 xx 4).reduce: { $^a[] xx $^b }

[07:50] <p6eval> rakudo 7e0aa3: OUTPUT«22222222␤»

[07:54] *** jql left
[07:54] *** jql joined
[08:05] <pmichaud> incoming nqp bonus

[08:08] *** cookys_ left
[08:26] *** snarkyboojum joined
[08:29] <sorear> pmichaud: no dalek

[08:34] <mathw> morning

[08:34] * mathw is really starting to hate C++

[08:34] * mathw wants to use Perl 6 instead

[08:54] <m6locks> so why dontcha :)

[08:54] *** proller joined
[08:55] <sjohnson> hi

[09:01] *** zag joined
[09:04] <zag> Whether there are any restrictions for translate per6/book to other languages ? I plan to translate into Russian.

[09:04] <zag> perl6/book (http://github.com/perl6/book.git)

[09:06] <JimmyZ> feel free to do it.

[09:13] *** lestrrat is now known as lest_away

[09:27] <mathw> m6locks: Insufficient concurrency support

[09:27] <mathw> In the future, though...

[09:30] *** pdcawley joined
[09:39] *** k23z__ joined
[09:40] <k23z__> hi, just read the news about Allison being elected in Python Software Foundation, any thoughts about how this will affect Parrot and implictly Rakudo development ?

[09:41] <sorear> not at all.

[09:42] <sorear> this means that Allison is now most responsible for the paper pushing required to manage a nonprofit organization, with 5-6 figures of grant money involved, and lots of beauracrcy

[09:43] <sorear> it has absolutely no bearing on technical matters

[09:43] <sorear> except insofar as, if the presedent flubs the job, getting a PSF grant will be a wee bit harder

[09:44] <JimmyZ> k23z__: where is the new? link?

[09:44] <k23z__> JimmyZ, check Gabor's blog

[09:44] <JimmyZ> er, news

[09:44] <moritz_> good morning

[09:44] <m6locks> gm

[09:45] <JimmyZ> k23z__: I don't know who is  Gabor

[09:45] <szabgab> me

[09:45] <JimmyZ> good morning moritz_ 

[09:45] <k23z__> JimmyZ, http://szabgab.com/blog/2010/05/1273870026.html

[09:45] <JimmyZ> thanks

[09:49] *** clintongormley joined
[09:52] *** lest_away is now known as lestrrat

[09:55] *** proller left
[09:58] <cognominal> hum,  find_lex in a Q:PIR searches for pir opcodes?

[09:58] <moritz_> does it?

[09:59] <moritz_> why would an opcode be in a lexical scope?

[10:00] *** proller joined
[10:00] *** JimmyZ left
[10:00] <cognominal> I try to make sense of  method term:sym<pir::op>($/) {  in Actions.pm

[10:00] <moritz_> in rakudo or nqp-rx?

[10:01] <cognominal> rakudo

[10:02] <cognominal> but I would no be surprised it uses some magic of nqp-rx

[10:02] <moritz_> it searches $pirop

[10:02] <moritz_> which is a variable

[10:04] *** pdcawley left
[10:05] <cognominal> E2MUCHMAGIC

[10:06] <moritz_> why?

[10:06] <moritz_> it works :-)

[10:06] *** pdcawley joined
[10:07] <cognominal> yea, but I don't understand it

[10:08] *** pnu left
[10:08] <moritz_> what part is that you don't understand?

[10:09] <cognominal> pir opcodes are not in a lexpad as far as I know

[10:09] <moritz_> right

[10:09] <moritz_> it searches for the varible $pirop, which was define two lines above

[10:09] <moritz_> in Perl 6 code

[10:09] <moritz_> and which holds a string representation of $<op>

[10:10] <moritz_> which is what \w+ matched in line 1189 of src/Perl6/Grammar.pm

[10:12] <cognominal> so   for example parsing  pir::clone__PP($<name><identifier>);  will lead to a search of  clone_PP in some lexpad. That's where I have a problem

[10:13] <moritz_> nope

[10:14] <moritz_> it compiles to a PAST::OP with pirop set to 'clone PP'

[10:14] <moritz_> which will eventually compile down to $P1 = clone $P0

[10:14] <moritz_> and $P0 is whatever $<name><identifier> compiles down to

[10:15] <cognominal> but there a find_lex!!

[10:16] <moritz_> but that's internal to the method that compiles pir::clone_PP

[10:16] <moritz_> it's not in the emitted code

[10:16] <cognominal> but it must find the opcode in some pad to work!

[10:16] <moritz_> nope

[10:17] <moritz_> opcodes are like built-ins in Perl 5

[10:17] <moritz_> they are just available

[10:17] <moritz_> no need to do anything to actually use them

[10:17] <moritz_> print 5; # look, no search in lexpads involved

[10:17] <cognominal> so what the purpose of the find_lex?

[10:18] <moritz_> it acts as a bridge between the perl6 and the PIR code in Actions.pm

[10:19] <moritz_> it's run at compile time, and doesn't appear in the PIR output at all

[10:22] <cognominal> as usual, I make some hidden assumption that is dead wrong and blinds me :(

[10:22] *** yinyin left
[10:25] <moritz_> cognominal: http://nopaste.snit.ch/20552

[10:25] <moritz_>     .lex "$x", $P23

[10:25] <moritz_>     find_lex $P24, "$x"

[10:25] <moritz_>     find_lex $P25, "$x"

[10:25] <moritz_>     clone $P26, $P25

[10:25] <moritz_> that's the non-boilerplate part the program compiles down to

[10:27] <moritz_> that's for my $x; pir::clone__PP($x)

[10:27] <moritz_> the 'my $x;' leads to to the .lex "$x" directive

[10:27] <moritz_> and the pir::clone__PP($x) looks up $x ( find_lex $P25, "$x" )

[10:28] <cognominal> hum, so the find_lex has nothing to do with a pir opcode.

[10:28] <moritz_> and then just clones it, and stores the result in $P26

[10:28] <moritz_> right

[10:28] <cognominal> I was stuck on that

[10:29] <cognominal> thx

[10:29] <moritz_> np

[10:31] <cognominal> using ./perl6 --target=PIR  interactively is a nice trick

[10:35] <cognominal> the  find_lex $P24, "$x"  seems spurious though

[10:36] <sorear> it is

[10:36] *** wknight8111 joined
[10:37] <sorear> see also: tcurtis' GSoC project to fix that

[10:38] <moritz_> cognominal: aye; I've just wondered if there's an easy way to prevent that

[10:42] <cognominal> anyway, I am still amazed with how much magic one can pull with Perl 6  grammars

[10:42] <moritz_> indeed

[10:43] <cognominal> many interesting books in perspective

[10:47] <cognominal> I long to see the Perl6 Petri dish macros as opposed to the Lisp hygienic macros to further the Perl 6 biotop

[10:52] <k23z__> cognominal, what are those ?

[10:53] <cognominal> it is a figment of my imagination :)

[10:54] <pugssvn> r30622 | colomon++ | [spec] Switch atan2 to work on Real instead of Numeric.  Add TrigBase argument to it as well. 

[10:55] <cognominal> k23z__, I just want to say that everything lisp is sterile grammarwise, so if their hygienic macros are great, I suppose that Perl 6 macro will be fertile comparatively

[10:55] <cognominal> even I don't know about the specifics

[10:57] *** iblechbot left
[11:11] *** agentzh left
[11:31] *** JimmyZ joined
[11:37] <jnthn> o/

[11:37] <cognominal> \o

[11:37] *** thraidh joined
[11:39] <thraidh> hi

[11:40] <JimmyZ> \o/

[11:40] <thraidh> what is the best way  to find out if S05 is wrong or the implementation of regexes not up to the spec

[11:41] <colomon> ask TimToady when he's around.

[11:41] <colomon> but it's a safe guess that implementation is not up to spec yet.

[11:41] <colomon> in general, I don't know about your specific case.

[11:41] *** iblechbot joined
[11:42] <JimmyZ> std: / '' /

[11:42] <p6eval> std 30622: OUTPUT«ok 00:01 113m␤»

[11:42] <thraidh> rakudo: "a" ~~ /a {make "b"}/; say $/.ast

[11:42] <p6eval> rakudo 7e0aa3: OUTPUT«␤»

[11:42] <thraidh> should output "b"

[11:42] <thraidh> std: "a" ~~ /a {make "b"}/; say $/.ast

[11:42] <p6eval> std 30622: OUTPUT«ok 00:01 111m␤»

[11:43] <thraidh> is std just a syntax check?

[11:43] <thraidh> rakudo: "foo123bar" ~~ / foo <( \d+ )> bar / ; say $()

[11:43] <p6eval> rakudo 7e0aa3: OUTPUT«Confused at line 11, near "\"foo123bar"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:44] <JimmyZ> thraidh: yes

[11:45] <thraidh> std: "foo123bar" ~~ / foo <( \d+ )> bar / ; say $()

[11:45] <p6eval> std 30622: OUTPUT«ok 00:01 111m␤»

[11:45] <thraidh> rakudo: "foo123bar" ~~ / foo <( \d+ )> bar / ; say $()

[11:45] <p6eval> rakudo 7e0aa3: OUTPUT«Confused at line 11, near "\"foo123bar"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:45] *** iblechbot left
[11:46] <thraidh> is there a list of things which do not yet work with rakudo?

[11:48] <jnthn> No

[11:48] <jnthn> Not an exhaustive one, anyway

[11:48] <jnthn> Oh, I think $() is dead anyway - is it still mentioned in S05?

[11:48] <jnthn> If so, I *think* it's a fossil

[11:51] <thraidh> rakudo: "a" ~~ /a {make "b"}/; say $/.ast

[11:51] <p6eval> rakudo 7e0aa3: OUTPUT«␤»

[11:51] *** jhuni left
[11:51] <thraidh> but that should work?

[11:51] <jnthn> That should I think work.

[11:51] <jnthn> Suspect it's a bug

[11:52] <thraidh> actually, right now, it only works if you use separate grammar and actions 

[11:52] <jnthn> (Knowing other things that are implemented, I quite surprised it doesn't work.)

[11:52] <jnthn> Yeah

[11:52] *** envi^home joined
[11:53] <thraidh> rakudo: grammar g { rule TOP { a }; }; class a { method TOP { make "b" }; }; say g.parse("a", :actions(a)).ast

[11:53] <p6eval> rakudo 7e0aa3: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: 'perl6;a;TOP' pc 913 (EVAL_1:65488615)␤»

[11:55] <thraidh> hmm... this works locally...

[11:56] <thraidh> rakudo: grammar G { rule TOP { a }; }; class A { method TOP { make "b" }; }; say G.parse("a", :actions(A)).ast

[11:56] <p6eval> rakudo 7e0aa3: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: 'perl6;A;TOP' pc 913 (EVAL_1:58911895)␤»

[11:56] <thraidh> rakudo: grammar G { rule TOP { a }; }; class A { method TOP($/) { make "b" }; }; say G.parse("a", :actions(A)).ast

[11:56] <p6eval> rakudo 7e0aa3: OUTPUT«b␤»

[11:56] <thraidh> my fault

[11:57] <thraidh> rakudo: grammar G { rule TOP { a { make "c"; }; }; class A { method TOP($/) { make "b" }; }; say G.parse("a").ast

[11:57] <p6eval> rakudo 7e0aa3: OUTPUT«Malformed regex at line 11, near "TOP { a { "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[11:57] <thraidh> rakudo: grammar G { rule TOP { "a" { make "c"; }; }; class A { method TOP($/) { make "b" }; }; say G.parse("a").ast

[11:57] <p6eval> rakudo 7e0aa3: OUTPUT«Malformed regex at line 11, near "TOP { \"a\" "␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[12:02] <pmichaud> good morning, #perl6

[12:03] <jnthn> morning, pmichaud 

[12:03] <colomon> o/

[12:03] <thraidh> good afternoon, pmichaud

[12:04] <pmichaud> nqp: sub A($a) { return { say($a * 2); } };  my $x := A(3);  my $y := A(5);  $x();

[12:04] <p6eval> nqp: OUTPUT«10␤»

[12:04] <pmichaud> ENOTUPDATED?

[12:04] <colomon> that's fixed?  \o/

[12:05] <pmichaud> pmichaud@plum:~/nqp-rx$ ./nqp

[12:05] <pmichaud> > sub A($a) { return { say($a * 2); } };  my $x := A(3);  my $y := A(5);  $x();

[12:05] <pmichaud> 6

[12:05] <jnthn> \o/

[12:05] <jnthn> pmichaud++

[12:06] <pmichaud> the nqp fix ended up being relatively straightforward once PAST was fixed up a bit... I'm hoping rakudo will be the same.

[12:06] <thraidh> jnthn: is that the perl6-communities way to applaud someone?

[12:07] <jnthn> thraidh: Aye. :-)

[12:10] <pmichaud> I always thought it was just a postfix sigil identifying a person or entity.  :-)

[12:12] <jnthn> I++ think that approach++ could get noisy. ;-)

[12:13] <pmichaud> you++ mean it hasn't been noisy already? ;-)

[12:14] <thraidh> for c-minded people it has the connotation of incremention (is that a word?)

[12:15] <thraidh> (or for any other language with roots in c)

[12:15] <thraidh> where would the person-or-entity-thing come from?

[12:16] <colomon> pmichaud was joking.

[12:16] <colomon> ++ is still increment in Perl 6

[12:17] <colomon> and in fact, there is sometimes a bot on the channel tracking how many ++'s each person has gotten.

[12:17] <thraidh> it is... but i think its string concatenation in somewhere else (smalltalk?)

[12:18] <jnthn> @karma jnthn

[12:18] <jnthn> aww, ENOBOT

[12:18] <thraidh> *g*

[12:18] <jnthn> No point making commits

[12:18] <jnthn> ;-)

[12:18] <thraidh> i assume there is no --

[12:18] <jnthn> Oh, there is. :-)

[12:18] <jnthn> jnthn-- didn't write enough patches this week.

[12:19] <thraidh> ;)

[12:20] <thraidh> do i have to learn pir in order to write a somewhat more complicated program with rakudo?

[12:20] <jnthn> thraidh: No

[12:20] <jnthn> thraidh: More if you wnat to hack on Rakudo.

[12:21] <thraidh> i assumed that might become necessary at some point

[12:21] <jnthn> There's the occasional module that does use PIR.

[12:21] <jnthn> But they're doing quite low-level-ish things.

[12:22] <jnthn> Plus end up being backend-specific.

[12:22] <thraidh> i have the bad habit to always want to do things which are hard, impossible or not working (though not intentionally)

[12:24] <thraidh> is it good style to separate grammar and actions?

[12:24] <jnthn> Yes,

[12:25] <jnthn> Because then you can choose to associate a different set of actions wiht the same grammar later

[12:25] <thraidh> or is that just 'legacy' since there was no other way in the earlier days

[12:25] <jnthn> Or just get the parse tree.

[12:25] <jnthn> Without doing actions

[12:25] <jnthn> No, it's not legacy, it's a good way to do it in any non-trivial case.

[12:27] <thraidh> i read somewhere that rules are "just" methods

[12:27] <thraidh> but i can't find that anymore

[12:28] <thraidh> what would the capture of such a method be?

[12:29] <thraidh> and what would be expected from such a method to do? how do i consume the string to be matched?

[12:35] *** bluescreen joined
[12:35] *** bluescreen is now known as Guest75855

[12:36] *** constant left
[12:36] *** constant joined
[12:36] *** constant left
[12:36] *** constant joined
[12:38] *** iblechbot joined
[12:38] <pmichaud> *sigh*  Current rakudo on current parrot trunk haz failz

[12:39] <pmichaud> Multiple declarations of lexical '$'

[12:39] <pmichaud> that's weird.

[12:39] *** orafu left
[12:41] <thraidh> indeed

[12:41] <pmichaud> will have to clean those up before I can fix closures

[12:42] *** orafu joined
[12:42] *** JimmyZ left
[12:42] <thraidh> rakudo: grammar G { rule TOP { a }; }; class A { method TOP($/) { make "b" }; }; say G.parse("a", :actions(A)).ast

[12:42] <colomon> pmichaud: how complicated is it?  Could one of us fix that while you work on something else arcane?

[12:42] <p6eval> rakudo 7e0aa3: OUTPUT«b␤»

[12:42] <thraidh> rakudo: grammar G { rule TOP { a }; }; class A { method TOP($/) { make "b" }; }; say G.parse("a", :actions(A)).ast.perl

[12:42] <p6eval> rakudo 7e0aa3: OUTPUT«"b"␤»

[12:42] <thraidh> rakudo: grammar G { rule TOP { a }; }; class A { method TOP($/) { make ["b"] }; }; say G.parse("a", :actions(A)).ast.perl

[12:42] <p6eval> rakudo 7e0aa3: OUTPUT«["b"]␤»

[12:43] <pmichaud> colomon: I don't know how complicated it is.  But yes, my nefarious plan was to let you collectively work it out for a while :)

[12:43] <colomon> :)

[12:43] <jnthn> pmichaud: ah, I can probably fix that easily if I can work out where it's coming from.

[12:43] <pmichaud> I was trying to bump PARROT_REVISION to 46606

[12:43] <jnthn> It's probably just an accident that we got away with before Parrot got more strict.

[12:43] <jnthn> oh, three sixes...that's evil.

[12:43] <jnthn> ;-)

[12:44] <pmichaud> you can bump to 46607 if it helps.

[12:44] <jnthn> ;-)

[12:45] <jnthn> pmichaud: Building a bumped version now to see the fail.

[12:46] <[Coke]> yah, that was a long standard reported bug (duplicate .lexes)

[12:46] <[Coke]> STANDING.

[12:46] <[Coke]> (stupid brain. I know where you live.)

[12:47] *** circuitbreaker joined
[12:49] <thraidh> [Coke]: it's not the brain... it's the fingers... they think they can write what they want...

[12:50] <pmichaud> oh, I bet the problem is with anonymous sigils then

[12:50] <jnthn> pmichaud: Yeah

[12:50] <jnthn> It may be a trivial fix in Signature.pm

[12:52] <pmichaud> probably need to switch a ::Var node to be something other than :lexical

[12:52] <jnthn> Well, or just not emit it at all perhaps.

[12:52] <pmichaud> yeah, that might work as well, as long as nothing expects to bind

[12:53] <pmichaud> oh, I bet it's .parameter

[12:53] <pmichaud> grrr

[12:53] <pmichaud> :scope<parameter>

[12:53] <jnthn> Very unlikely.

[12:53] <jnthn> Rakudo barely uses :scope<parameter>

[12:53] <jnthn> Only to get the call_sig to pass along to the binder.

[12:53] <pmichaud> okay, then it's a :scope<lexical> decl that is the likely culprit

[12:53] <pmichaud> yeah, you're right

[12:53] <jnthn> Yeah, I very much suspect so.

[12:54] <pmichaud> I'll let you hack away on getting it up to latest parrot trunk for a while then, and work on some other stuff for a bit

[12:54] <pmichaud> afk for a bit

[12:56] <thraidh> where do i find my current parrot_revision?

[12:58] <colomon> thraidh: build/PARROT_REVISION

[12:58] *** Bzek left
[13:01] <thraidh> if you do not have a secret developer trunk, then current rakudo passes all tests with parrot revision 46405

[13:04] *** perlygatekeeper joined
[13:15] <jnthn> > sub foo($, $) { say "ok" }; foo(4, 2);

[13:15] <jnthn> ok

[13:15] <jnthn> > my ($, $, $c) = 1,2,3; say $c;

[13:15] <jnthn> 3

[13:15] <jnthn> Thing those should be the two main cases that we got broken.

[13:15] <jnthn> Work now

[13:15] <jnthn> spectesting.

[13:18] *** am0c joined
[13:20] *** thraidh left
[13:21] <mathw> \o/

[13:23] <sahadev1> rakudo: [reduce { $^a + $^b }, -5..5].perl.say

[13:23] <p6eval> rakudo 6c97fe: OUTPUT«[0]␤»

[13:23] <sahadev1> rakudo: [reduce { $^b < 0 ?? $^a-$^b : $^a+$^b }, -5..5].perl.say

[13:23] <p6eval> rakudo 6c97fe: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[13:24] <sahadev1> is this a bug?

[13:24] <colomon> rakudo: [reduce { $^b < 0 ?? $^a-$^b !! $^a+$^b }, -5..5].perl.say

[13:24] <p6eval> rakudo 6c97fe: OUTPUT«[20]␤»

[13:24] <sahadev1> ah, thanks colomon.

[13:24] <colomon> rakudo: (reduce { $^b < 0 ?? $^a-$^b !! $^a+$^b }, -5..5).say

[13:24] <p6eval> rakudo 6c97fe: OUTPUT«20␤»

[13:26] <colomon> you're welcome.  

[13:26] <colomon> now if I could just figure out my own bug so easily.... ;)

[13:27] <PerlJam> colomon: put your code up where more eyes can view it and get the Internet to help you  :)

[13:28] <colomon> code used to be 1 / self.sin($base);

[13:28] <colomon> is now 1 / $x.sin($base);

[13:28] <colomon> is it possible that the second one parses as (1 / $x).sin($base) instead of 1 / ($x.sin($base))?

[13:29] <colomon> (basically, I went through and switched Complex's trig functions to be in terms of an invocant $x rather than self, and now all the functions which do "/ $x.sin($base)" or "/ $x.sinh($base)" are broken.

[13:31] *** BrowserUk joined
[13:31] <PerlJam> you can easily (?) parenthesize ($x.sinh($base)) if you suspect it's a precedence problem.  

[13:31] <PerlJam> If the parens don't fix it, then there's something else wrong.

[13:32] <colomon> PerlJam++ # for simple wisdom that was eluding me

[13:33] <colomon> afk (but compiling PerlJam's suggestion)

[13:36] <lisppaste3> sahadev1 pasted "why does'nt this terminate?" at http://paste.lisp.org/display/99224

[13:39] <jnthn> pmichaud: Fixes pushed.

[13:39] *** plobsing joined
[13:45] *** pnu joined
[13:46] *** BrowserUk left
[13:50] <PerlJam> sahadev1: why do you have only two ??, but three !! ?

[13:52] <PerlJam> oh, never mind.  My eyes are playing tricks on me.

[13:52] *** zag left
[13:52] *** isBEKaml joined
[13:53] <sahadev1> PerlJam: :)

[13:53] <sahadev1> $^a[0..*-3] # is this wrong syntactically?

[13:54] <sahadev1> what is the right way to say, give me the slice from 0 to everything but last 2 elements?

[13:54] <moritz_> it should work

[13:56] <moritz_> rakudo: say reduce {$^a + $^b}, (-5)..5

[13:56] <p6eval> rakudo 6c97fe: OUTPUT«0␤»

[13:56] <moritz_> rakudo: say reduce {$^a + $^b}, (-5)..0

[13:56] <p6eval> rakudo 6c97fe: OUTPUT«-15␤»

[13:57] <moritz_> \o/ it seems that p6l commit mails now have a proper subject line

[13:57] <moritz_> ie my patch worked

[13:57] * jnthn -> köpa öööööööl

[14:00] <sahadev1> rakudo: my @a = 1..5; @a[0..*-3].perl.say

[14:00] <p6eval> rakudo 6c97fe:  ( no output )

[14:00] <moritz_> rakudo still has problems with *

[14:00] <moritz_> current workaround:

[14:01] <moritz_> rakudo: my @a = 1..5; say @a[0..@a-3].perl

[14:01] <p6eval> rakudo 6c97fe: OUTPUT«(1, 2, 3)␤»

[14:01] <sahadev1> moritz_: thanks.

[14:01] <moritz_> sahadev1: you're welcome

[14:03] *** isBEKaml left
[14:03] <moritz_> sahadev1: I'm curious, how did you learn about Perl 6?

[14:03] *** isBEKaml joined
[14:03] *** JimmyZ joined
[14:04] <sahadev1> moritz_: i have been following it on and off ever since cups were shattered back in 2000 :)

[14:05] <sahadev1> i have been programming in perl since 1997.

[14:05] <moritz_> :-)

[14:05] <mathw> Welcome!

[14:06] <isBEKaml> hi, #perl6! :)

[14:06] <mathw> Hi isBEKaml

[14:07] <colomon> o/

[14:08] <PerlJam> hello isBEKaml 

[14:08] <isBEKaml> how's things? bumped parrot revisions, eh? {backloggin}

[14:08] * PerlJam idly wonders what everyone's "perl age" is

[14:08] <moritz_> isBEKaml: ongoing closure fixes, and adaption to parrot changes

[14:09] <isBEKaml> PerlJam: you should be wondering about perl{6}age... ;)

[14:09] * moritz_ has been doing Perl since 2003

[14:09] *** TiMBuS left
[14:09] <colomon> oh, bother, additional parens did not fix my issue.  :\

[14:10] <moritz_> and Perl 6 since 2007

[14:10] <isBEKaml> thinking about it, we might as well put in a new word into our perl dictionary, perlage! :)

[14:10] <PerlJam> isBEKaml: actually what I was wondering was "how many perl 6 people have used perl 4 or earlier?"

[14:10] * moritz_ looks at Tene 

[14:10] <[Coke]> o/

[14:10] <moritz_> erm, TimToady actually

[14:10] * colomon starting learning Perl in 1995, and bought the Perl 6 / Parrot book when it was fairly new (2003ish)

[14:11] * [Coke] cut his teeth on perl 4 on xenix.

[14:11] <colomon> so yes, I used perl 4 for a number of years.

[14:11] <PerlJam> that makes at least 5 people so far

[14:11] * [Coke] assumes the xenix is worth bonus points. =-)

[14:11] * sahadev1 remembers looking at some Perl 4 code back in 1995 - using cgi-lib.pl

[14:11] <isBEKaml> or it can be perlhexage! :)

[14:11] <colomon> it certainly wasn't linux I was using in '95.  :)

[14:12] <PerlJam> [Coke]: you get some condolences anyway  :)

[14:12] <colomon> but I don't remember which of the motley collection of Unixish machines at my old $work had Perl on it.

[14:13] <mathw> 11

[14:13] <colomon> is [0..*-3] ever meant to work?

[14:13] <moritz_> yes

[14:13] <colomon> rakudo: say 1..5-3

[14:13] <p6eval> rakudo 6c97fe: OUTPUT«12␤»

[14:13] <PerlJam> I've had this theory for a while that the perl people that most object to Perl 6 are those that have *only* used Perl 5.

[14:13] * isBEKaml has used perl5 on and off, for an year. And, looks at the tall _trees_ around him and feels stymied. 

[14:14] * mathw never used Perl 4, and started with Perl 5.6

[14:14] <mathw> At least I think it was 5.6

[14:14] <colomon> moritz_: I don't understand how.

[14:14] <mathw> But Perl 6 was announced not long after...

[14:14] <moritz_> colomon: with Whatever-currying

[14:14] <colomon> oh, wait.

[14:14] <PerlJam> colomon: the real question is ... what does it *do* ?   :)

[14:14] <mathw> And I've followed it all along, with varying involvement over time

[14:15] <colomon> moritz_: my problem is that 1..* and 1..*-1 are wildly different things.

[14:15] <moritz_> mathw: it must have 5.6 for me too, but when I started caring about perl versions i already used 5.8

[14:15] <moritz_> colomon: seems like, yes

[14:16] <mathw> moritz_: I remember an early encounter with Perl 5.004 which left me reeling, because it didn't have three-argument open

[14:16] <mathw> astonishingly, we still have a few servers at work with 5.005 on

[14:16] <colomon> mathw: I didn't even learn about three-argument open until last year, I think.  :)

[14:16] <isBEKaml> thankfully, our servers run perl 5.8.4 

[14:17] <mathw> I've got 5.10 on my desktop at work

[14:17] *** bacek left
[14:17] <colomon> moritz_: I guess the good news is that 1..* will "do the right thing" in [ ] anyway.

[14:17] <mathw> have written a few scripts which require it

[14:17] <mathw> but I can't do much like that as other people have to use them :(

[14:17] *** bacek joined
[14:17] * moritz_ mostly likes say() and infix // about perl 5.10

[14:18] <mathw> // is awesome

[14:18] <mathw> I also like given...when :)

[14:18] <moritz_> I like the other things too, but I don't use them as often

[14:18] <isBEKaml> given...when is part of 5.10? :O

[14:18] <mathw> yup

[14:18] <isBEKaml> I thought it was introduced in perl6... 

[14:18] <PerlJam> isBEKaml: and a limited form of smart matching

[14:19] <mathw> when I last gave my Perl 5 course at work, I teased everyone horribly with it

[14:19] <moritz_> but you need parens around the arguments to given and when in 5.10

[14:19] <pmichaud> jnthn: I still get some failures with new Parrot trunk

[14:19] <mathw> because we don't have anything running 5.10 officially here :)

[14:19] <PerlJam> isBEKaml: yes, it was introduced in Perl 6, then ported to Perl 5

[14:19] *** moritz_ sets mode: +oooo pmichaud mathw PerlJam isBEKaml

[14:19] *** moritz_ sets mode: +o colomon

[14:19] <isBEKaml> PerlJam: wow, nice.. :) 

[14:19] <PerlJam> isBEKaml: Perl borrows from everywhere, even its siblings.

[14:20] <lisppaste3> pmichaud pasted "current rakudo failures" at http://paste.lisp.org/display/99226

[14:20] *** hugme joined
[14:20] *** moritz_ sets mode: +vv lisppaste3 hugme

[14:21] <isBEKaml> PerlJam: I knew that about Perl in general. I just didn't know that p5p still port stuff from newer releases... 

[14:22] <moritz_> t/spec/S03-junctions/autothreading.rakudo regularly aborts when run as part of 'make spectest'

[14:22] <colomon> pmichaud: you mean, current Rakudo with Parrot HEAD?

[14:22] <PerlJam> isBEKaml: What makes Perl 6 special that p5p *wouldn't* borrow from it?  :)

[14:22] <pmichaud> current Rakudo.

[14:22] <pmichaud> as pushed by jnthn a short while ago

[14:22] <colomon> oh, I see, jnthn++ pushed stuff while I was out.

[14:22] <isBEKaml> PerlJam: Ops? :)

[14:22] *** patspam joined
[14:23] <mathw> isBEKaml: the thing is that Perl 6 isn't newer than 5.12, they're contemporaries so why shouldn't they share things?

[14:23] <moritz_> t/spec/S12-class/attributes.rakudo emits an IMCC syntax error

[14:24] *** Trashlord left
[14:24] <moritz_> t/spec/S12-attributes/instance.rakudo same

[14:24] <isBEKaml> mathw: they can and that's nice. I thought current releases are generally maintenance stuff. The nice thing is, that's not. :)

[14:25] <moritz_> the last time I've seen IMCC syntax errors from Perl 6 code, it was because of  has ($.a, $.b)

[14:25] <PerlJam> isBEKaml: oh no.  Perl 5 is still active and evolving.  It's not "in maintenance" while waiting for Perl 6 or anything.

[14:26] <mathw> isBEKaml: I think for a while they were, but it's really kicked back up on Perl 5 recently.

[14:26] <mathw> Which is awesome, really

[14:26] *** sahadev1 is now known as sahadev

[14:27] <PerlJam> mathw: when releases were onerous, they were few and far between.  So p5p decided to fix that.  :)

[14:27] <isBEKaml> mathw: yes, I remember reading somewhere (shadowcat ? don't recall) that p5 switched dev releases from bug fix cycles to monthly cycles. Now, that's great for p5!

[14:27] <mathw> PerlJam: That was a good thing for them to fix

[14:27] <mathw> Releases should never be difficult

[14:27] <PerlJam> indeed.

[14:28] <colomon> rakudo: say acosec(1i)

[14:28] <p6eval> rakudo 6c97fe: OUTPUT«0 + -0.881373587019543i␤»

[14:28] <jnthn> pmichaud: Oh? What fails?

[14:28] <PerlJam> This is the first time in over 10 years that I've started paying attention to p5p (well, #p5p really).

[14:28] <jnthn> pmichaud: oh, nm, just saw paste

[14:29] <jnthn> pmichaud: Those two aren't specific to the Parrot bump

[14:29] <jnthn> pmichaud: One of them seems to be intermitent too.

[14:29] <jnthn> pmichaud: They're on my todo list.

[14:30] <jnthn> oh, wtf

[14:30] <jnthn> "syntax error ... somewhere"

[14:31] <jnthn> Thanks Parrot, that's wonderful. :|

[14:31] <isBEKaml> PerlJam: I didn't too much about p5p's changes in release cycles. What did they do that eased release cycles? 

[14:31] <moritz_> btw I've got a mail from Aliaksandr Zahatski, asking about licensing/legal issues regarding translating the Perl 6 book to Russian

[14:31] *** xomas_ joined
[14:32] <moritz_> I'm going to answer "fine by me, see license notice in README", only more verbose... anything else I should write?

[14:32] <colomon> rakudo: say acosec(1i, Degrees)

[14:32] <p6eval> rakudo 6c97fe: OUTPUT«0 + -50.4989867105262i␤»

[14:32] <moritz_> he proposed the same license for his work as we already use (cc by attribution, share-alike, non-commercial=

[14:33] <pmichaud> should we also check with chromatic?

[14:33] <moritz_> I'm going to CC him

[14:33] <pmichaud> wfm

[14:33] <moritz_> and anybody else who wants :-)

[14:34] <mathw> Surely if it's CC-BY-SA-NC he can do what he likes with it as long as he doesn't sell it, releases it under the same licence and credits you

[14:34] <PerlJam> moritz_: sounds good to me.

[14:34] * jnthn spots the underlying issue

[14:34] <jnthn> (with the two failures)

[14:34] * mathw posts jnthn a giant cookie

[14:34] <moritz_> mathw: yes; still it's a nice move of him to ask first

[14:34] <jnthn> Trying a patch now

[14:34] <mathw> moritz_: oh definitely

[14:35] *** xomas_ is now known as xomas

[14:35] <PerlJam> moritz_: be sure to tell Aliaksandr to give himself attribution for the translation  :)

[14:36] * PerlJam wonders if Onyx Neon Press does multi-lingual publications

[14:36] <isBEKaml> PerlJam: I believe that's what moritz_ will be asking of chromatic. .. :)

[14:38] <isBEKaml> moritz_: that's nice of him to ask first. I see no issues if he uses CC by SA and NC. But what will he do when you go live with the book? 

[14:39] <isBEKaml> I think he should clarify that first, though he's free to continue using the same licence. 

[14:39] <moritz_> what will he do? I don't understand the issue...

[14:40] <isBEKaml> moritz_: you had mentioned on the README that you'll be revoking CC by SA licence when you go to print. Aliaksandr, though he can continue with the same licence and offer online reading, should clarify his position on this. 

[14:41] <PerlJam> er, what?

[14:41] <moritz_> isBEKaml: the README says that maybe we'll remove the "noncommerical" part of the license in future

[14:41] *** JimmyZ left
[14:41] <isBEKaml> just to be sure, if you're going to link to his work under translations. 

[14:42] <moritz_> isBEKaml: which leaves him in a better position

[14:42] <moritz_> and I don't plan to make money from his translation anyway :-)

[14:42] <isBEKaml> oh, we're good then. :)

[14:43] <jnthn> pmichaud: Have a fix for those two as well

[14:43] <jnthn> pmichaud: spectesting again, then will push

[14:43] <pmichaud> jnthn: okay, good.  I'm having to rethink our sub wrapper objects a fair bit

[14:43] <jnthn> Turned out to be a trivial fix.

[14:43] <jnthn> pmichaud: oh?

[14:44] <jnthn> pmichaud: The wrappers getting in the way of lexical capturing somehow?

[14:44] <pmichaud> in order to properly get a clone of the (parrot) sub, we need a clone of its wrapper

[14:44] <jnthn> *nod*

[14:44] <jnthn> Cloning the wrapper *should* clone the Parrot sub.

[14:44] <jnthn> I'm pretty sure it does, anyways.

[14:44] <pmichaud> right, but PAST doesn't know about wrappers.

[14:44] <pmichaud> I mean, PAST::Block doesn't know about wrappers

[14:44] <pmichaud> and it's the thing that is doing the newclosure to clone the sub

[14:45] <jnthn> Ah.

[14:45] <jnthn> Yeah, I can sorta see that issue.

[14:45] <jnthn> Hmm.

[14:45] <pmichaud> cloning the wrapper also has to clone its properties

[14:45] <pmichaud> or, at least some of them (e.g., signature)

[14:46] <pmichaud> ...unless those are attributes now?

[14:46] <jnthn> pmichaud: Still prop.

[14:46] <isBEKaml> moritz_: what exactly were those "ongoing closure fixes" that you mentioned? 

[14:47] <moritz_> isBEKaml: what pmichaud is working on... some fixes to parrot's closure handling

[14:47] <pmichaud> well, parrot's closure handling is fine now... it's rakudo's that is a pain

[14:47] <colomon> Strange question: what is supposed to happen when we define two multi methods with the exact same signature in a class?

[14:47] <jnthn> colomon: Nothing until you call it.

[14:48] <jnthn> colomon: At that point, a conflict.

[14:48] <jnthn> colomon: Unless one is marked "is defualt"

[14:48] <isBEKaml> oh, I see. 

[14:48] <pmichaud> nqp:  sub A($a) { return { say($a*2); } };  my $x := A(3);  my $y := A(5);  $x();  # just checking

[14:48] <p6eval> nqp: OUTPUT«10␤»

[14:48] <pmichaud> ESTILLNOTUPDATED

[14:48] * pmichaud checks that he did actually push the nqp changes to github...

[14:49] <jnthn> colomon: It can be useful, though. Like you can write multiple methods with the same signature as "even handlers"

[14:49] <jnthn> colomon: And have them all invoked with .*

[14:49] *** XaeroOne joined
[14:49] <isBEKaml> pmichaud: I think I came across something like this last week. I wasn't here since - so I'll just paste what I didn't understand then

[14:50] <pmichaud> isBEKaml: yes, I fixed closures in nqp last night

[14:50] <pmichaud> isBEKaml: I was just seeing if p6eval had updated yet (it hasn't)

[14:50] *** snarkyboojum left
[14:50] <isBEKaml> pmichaud: oh, didn't moritz_++ update cron entries to p6eval? 

[14:51] <isBEKaml> moritz_: ?

[14:51] <pmichaud> here's how it looks on my system:

[14:51] <colomon> jnthn: neither marked default, and the calls were working.

[14:51] <pmichaud> > sub A($a) { return { say($a * 2) } };  my $x := A(3);  my $y := A(5);  $x();

[14:51] <pmichaud> 6

[14:52] <isBEKaml> pmichaud: nice, is it really necessary that closures are to be bound always? 

[14:52] <pmichaud> isBEKaml: how do you mean?

[14:52] <isBEKaml> nqp: sub A($a) { return { say($a * 2) } };  my $x = A(3);  my $y = A(5);  $x();

[14:52] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " A(3);  my"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[14:52] <isBEKaml> pmichaud: :=

[14:52] <pmichaud> isBEKaml: nqp doesn't have assignment, only binding

[14:52] <jnthn> colomon: Oh.

[14:52] <jnthn> colomon: That sounds very odd.

[14:52] <isBEKaml> pmichaud: Oh

[14:53] <colomon> jnthn: do a search on acosec in Complex.pm.

[14:54] <isBEKaml> nqp: sub subbydo_returns { my $temp:=23;  return {$_ + $temp}; }; my $ttr := subbydo_returns;my $test2:=$ttr(23);say $test2.WHAT; say $test2; # just checking, I may be sorely wrong in usage

[14:54] <p6eval> nqp: OUTPUT«./nqp: error while loading shared libraries: libparrot.so.2.1.0: cannot open shared object file: No such file or directory␤»

[14:54] <colomon> I've been trying to figure out how I broke it, and it turns out the answer was that I changed the first Complex.acosec to be a method instead of a multi method, and suddenly dispatch switched to using the second acosec, which was broken.

[14:54] <pmichaud> jnthn: I'm wondering if I want/need a wrapper PAST node of some type

[14:54] <moritz_> rebuilding nqp-rx's parrot failed on the server that runs evalbot

[14:54] <moritz_> cleaning now, and trying again

[14:55] <pmichaud> yes, there are times when make realclean seems to fail horribly for parrot

[14:55] <pmichaud> I run into that when doing batches of spectest_progress updates

[14:55] <isBEKaml> nqp: sub subbydo_returns { my $temp:=23;  return {$_ + $temp}; }; my $ttr := subbydo_returns;my $test2:=$ttr(23);say $test2; # just checking, I may be sorely wrong in usage

[14:55] <p6eval> nqp: OUTPUT«./nqp: error while loading shared libraries: libparrot.so.2.1.0: cannot open shared object file: No such file or directory␤»

[14:55] <moritz_> on my dev box I have a git clone of parrot, and use git clean -xdf   to wipe out old files

[14:55] <moritz_> it's *very* thorough

[14:55] *** JimmyZ joined
[14:56] <moritz_> so if you have patches lying around... don't.

[14:56] <isBEKaml> pmichaud: where am I failing? 

[14:56] <pmichaud> isBEKaml: you're not ... the problem is that nqp is currently being rebuilt for p6eval

[14:56] <moritz_> nqp-rx is currently being rebuilt

[14:56] <pmichaud> isBEKaml: you're just catching it in the middle of a rebuild

[14:57] <isBEKaml> oh, jeez :(

[14:57] *** snarkyboojum joined
[14:57] <pmichaud> but beyond that, in NQP all sub declarations require a signature

[14:57] * isBEKaml really should go drink another strong cup of coffee

[14:57] <pmichaud> and there's no implicit $_

[14:57] <jnthn> pmichaud: (wrapper type) could we have it as a property on the PAST::Block?

[14:58] <pmichaud> jnthn: I'm thinking perhaps a bit more general (more)

[14:58] <jnthn> pmichaud: I'd actually quite like to still have a PAST::Block in the AST.

[14:58] <pmichaud> what we really want is a PAST node type that can deal with context

[14:58] <jnthn> In that it makes various bits of analysis easier later perhaps.

[14:58] * jnthn listens

[14:58] *** ruoso joined
[14:58] <pmichaud> "if in void context, return this otherwise return this-other-thing"

[14:59] <pmichaud> the chances I made to PAST::Block for better closure support basically are context aware...  if a block is being used as an rvalue (i.e., not void context), then we make a clone and return it

[14:59] <pmichaud> otherwise, if in void context, we do nothing more than generate the block definition

[15:00] <moritz_> nqp: say('rebuild finished')

[15:00] <p6eval> nqp: OUTPUT«rebuild finished␤»

[15:00] <pmichaud> because creating a clone is an unnecessary cost in that case

[15:00] <pmichaud> for Rakudo, it's a bit more than just creating a clone

[15:00] <pmichaud> because in our case, we're actually creating PAST nodes that create a wrapper for the block

[15:01] <[Coke]> (realclean on parrot is not guaranteed to work across svn updates.)

[15:01] <pmichaud> so, what I'd like is some sort of node (or way to use existing nodes) such that in void context it just builds the wrapper + block, but in non-void context it clones the wrapper

[15:02] <jnthn> pmichaud: +1

[15:02] <jnthn> That sounds quite sane.

[15:02] <pmichaud> so more generically I think I want a context-aware node type in PAST

[15:02] <pmichaud> so that context sensitivity can be exploited by PAST users as well as PAST internally.

[15:02] <moritz_> so... is there some mechanism for detecting sink/void context already?

[15:03] <pmichaud> moritz_: not that is exposed to a PAST user.

[15:03] <pmichaud> I'm thinking this might be a way to get that.

[15:03] <moritz_> that would be great

[15:03] <pmichaud> ....but YES!  This would also resolve the sink/void context deal as well.

[15:03] <moritz_> because it would bring us close to lazy 'for' loops

[15:03] <pmichaud> "in void context, add a .sink call to the result; in non-void context, just return the result"

[15:03] <moritz_> right

[15:04] *** plobsing left
[15:04] <pmichaud> it's much cleaner (so far) to let PAST figure out context than to try to have the actions determine it.

[15:04] <jnthn> pmichaud: oooh! :-)

[15:04] <moritz_> and the PAST optimizer can get rid of PAST::Val nodes in sink context, and optionally warn

[15:04] <jnthn> pmichaud: TimToady++ has been talking about it as a later pass too, iirc.

[15:04] <jnthn> pmichaud: So it all fits together.

[15:04] *** iblechbot left
[15:05] <pmichaud> moritz_: even better, the PAST compiler itself can do it.

[15:05] <pmichaud> it doesn't have to be an optimization setp.

[15:05] <pmichaud> *step

[15:05] <pmichaud> it falls out fairly naturally

[15:05] <jnthn> *nod*

[15:05] * jnthn likes it

[15:05] <pmichaud> that potentially means I could remove my .closure addition I just made to PAST::Block, and use the new nodetype instead

[15:06] <pmichaud> (but I kind of like the .closure addition; it's common enough to almost warrant being a default)

[15:06] *** Chillance joined
[15:06] <pmichaud> I suppose it would also be possible to generalize the node to handle several types of context beyond just void

[15:06] <jnthn> Just pushed the fixes to has ($!x, $!y)

[15:06] <pmichaud> i.e., int, string, and pmc

[15:07] <jnthn> There's an RT for that somewhere, if anyone feels like finding it.

[15:07] <jnthn> pmichaud: I suggest just void and not at first.

[15:07] <pmichaud> so... "when in int context, generate this code; when in string context, generate this other code, when in ..."

[15:08] <jnthn> pmichaud: I'd like to be more sure HLLs could use int/string etc context thins.

[15:08] <jnthn> *things

[15:08] <jnthn> (In a useful way.)

[15:08] <pmichaud> jnthn: I'm thinking there's a default "generate this code" and exceptions "but when in X context, use this instead"

[15:08] <pmichaud> jnthn: I'm certain of it.

[15:08] <jnthn> And also that we don't tie PAST too closely to Parrot.

[15:08] <pmichaud> I agree, tying past closely to parrot is a small issue

[15:08] <jnthn> (PMC is quite specific in that sense.)

[15:09] <pmichaud> well, it's more "other" than "pmc"

[15:09] <jnthn> ("boxed thingy" is more generic though)

[15:09] <jnthn> *nod*

[15:09] <jnthn> If you're comfortable there will be HLL uses, it's fine - I do OTOH like the small-ness of PAST. :-)

[15:10] <pmichaud> but I know that a HLL might want to be able to optimize    my int $i = 2 + 3    to use an integer add opcode instead of generating a function call

[15:10] <pmichaud> i.e., it provides another place for some good type optimizations

[15:10] <pmichaud> I'd probably just have "void", "int", "str", and "default"

[15:11] <pmichaud> and rakudo would tend to stick to "void" and "other" for its work.

[15:12] <jnthn> pmichaud: Yeah, that does make sense.

[15:12] <jnthn> pmichaud: OK, I like it.

[15:13] <pmichaud> (I'm thinking that NQP could itself make use of these features... so yeah, at least one other HLL has a use case :)

[15:13] <jnthn> pmichaud: Just suggest to avoid "PMC" as one of the options, call it something more generic.

[15:13] <pmichaud> right

[15:13] <pmichaud> "default"

[15:13] <pmichaud> "object"

[15:13] <pmichaud> something like that

[15:13] * jnthn likes object

[15:13] <pmichaud> most likely default

[15:13] <moritz_> "Mu"

[15:13] * moritz_ hides

[15:13] * jnthn switches moritz_ to Mu-te

[15:13] <jnthn> ;-)

[15:13] <moritz_> :-)

[15:14] <pmichaud> afk, time to walk and roll this around in my head a bit more

[15:14] <moritz_> roll, roll, roll the head

[15:14] *** cdarroch joined
[15:14] *** cdarroch left
[15:14] *** cdarroch joined
[15:14] <isBEKaml> lolling on the shoulders? ;)

[15:15] <isBEKaml> I admit all this discussion was way over my head and understood next to nothing of what actually transpired :(

[15:16] <moritz_> isBEKaml: 'twas the same in my first year in here too

[15:16] <moritz_> and mostly in the second, too

[15:16] *** xomas left
[15:16] <isBEKaml> moritz_: hopefully I'll catch on. :)

[15:16] <moritz_> and I still don't understand many of the current discussions, especially those about closure guts and concurrency

[15:17] <pmichaud> back for a sec

[15:18] <pmichaud> I think it's going to be a PAST::Context type, which has two children and a "context type" attribute.  The first child is generate if the context is given by "context type", otherwise the second child is generated.  (either may be null, which causes nothing to be generated)

[15:18] <pmichaud> if there are situations wehre multiple contexts are possible, then just chain them together like if-then-else logic

[15:19] <jnthn> isBEKaml: In summary, we found a place where we could do with passing a bit more high-level semantic information down to a lower "layer" of the compiler so it can generate the correct / better code.

[15:19] <pmichaud> isBEKaml: ...thereby providing a framework to solve several seemingly unrelated problems at once.  :-)

[15:19] <jnthn> pmichaud: I like that. Chaining them will probably be a rare case.

[15:20] <jnthn> So I don't mind if it's a little more effort, and really it's not that much anything

[15:20] <pmichaud> in this case, we fix closures and also void/sink context

[15:20] <pmichaud> right, I agree

[15:20] <pmichaud> and it also allows greater generalization of context types

[15:20] <pmichaud> okay, afk again

[15:20] <jnthn> We do the same with the if pasttype node anyway.

[15:20] <jnthn> pmichaud++

[15:20] <isBEKaml> jnthn++; pmichaud++

[15:22] <isBEKaml> jnthn: so that's what you were referring to as PAST? Btw, stupid qn here, does PAST stand for Parrot Abstract Syntax Tree? 

[15:23] <jnthn> Yes, it does.

[15:24] <jnthn> PAST is a representation of programs. We turn that (through an intermediate step) into Parrot Intermediate Code

[15:24] <jnthn> Though in the future we plan to be able to transform it into other VM's code too

[15:24] <isBEKaml> that would be further low level? not in intermediate PIR? 

[15:25] <[Coke]> s/further/different/

[15:26] <jnthn> isBEKaml: different, as Coke said.

[15:26] <jnthn> isBEKaml: PIR is specific to Parrot.

[15:26] <jnthn> I guess PAST is kind of our last abstraction layer before we start to Go Specific.

[15:27] <jnthn> If you do perl6 --target=past and then type some code, you can see the PAST tree.

[15:27] <isBEKaml> jnthn: where is this laid down? I really would like to go through those docs first and come back asking (stupid ;) ) questions

[15:28] *** PerlJam left
[15:28] <jnthn> Depends on the "this". If you want details of PAST, see http://docs.parrot.org/parrot/latest/html/docs/pdds/pdd26_ast.pod.html

[15:28] <isBEKaml> ah, jnthn. I remember asking that exact question about perl6's switches on the cmd line, last week. Got no answer though. 

[15:28] *** PerlJam joined
[15:28] <jnthn> isBEKaml: Those are documented in docs/running.pod

[15:29] <jnthn> (In the Rakudo repo)

[15:29] <isBEKaml> jnthn: I was looking at running.pod included with rakudo. It was very sparse about the switches esp --trace

[15:30] <isBEKaml> jnthn: it says trace=[flags]. What flags can we pass in?

[15:30] <jnthn> isBEKaml: Ah

[15:30] <jnthn> isBEKaml: That's just actually iirc passing flags straight down to Parrot's trace code.

[15:31] <jnthn> So would be the same as the Parrot trace flags

[15:31] * jnthn very rarely uses --trace

[15:31] <jnthn> You're right though, it's not documented at the Rakudo level.

[15:32] <isBEKaml> jnthn: yes. just ran parrot --help-debug and got trace codes. 

[15:32] <jnthn> https://svn.parrot.org/parrot/trunk/docs/running.pod offers a little more info

[15:33] * jnthn isn't sure what's available there.

[15:33] * [Coke] points at PARROT_OPTIONS later in rakudo's running.pod

[15:33] <jnthn> Last time I used --trace I think it actually crashed.

[15:33] <jnthn> That maybe was fixed though.

[15:33] <[Coke]> if --trace is just passthrough, just point down there.

[15:33] <jnthn> (was quite a while ago)

[15:34] <isBEKaml> jnthn: When I used trace and passed some random integer like 1, it just went out spewing lots of stuff scrolling

[15:34] <[Coke]> 1 is "every opcode" 4 is "every parrot sub"

[15:34] <[Coke]> 5 is "both"

[15:35] <isBEKaml> [Coke]: parrot --help-debug doesn't say anything about 5. 

[15:35] <isBEKaml> [Coke]: 1 - opcodes, 2 - find method, 4 - function calls. 

[15:36] <[Coke]> isBEKaml: bitflags.

[15:36] <isBEKaml> [Coke]: ah, well

[15:36] <isBEKaml> [Coke]: 7 is everything under the Parrot's Sun! 

[15:37] * JimmyZ uses perl6 -target=past -e 'say "hi", but it outputs nothing.

[15:37] <TimToady> sorear: yes, STD almost always nails the exact location of the error; if you get an off-by-20-lines error in rakudo, try feeding to STD

[15:37] <JimmyZ> err. --target

[15:37] <TimToady> of course, it's also possible that STD will accept it...

[15:38] <jnthn> isBEKaml: Yes, it's extremely verbose.

[15:40] <isBEKaml> jnthn: and, I was thinking there must be something wrong here. This is a simple program, trace just spits out the entire trace to parrot assembly than just the program? :O

[15:41] <moritz_> JimmyZ: use --target=past together with a file (or STDIN), not -e

[15:41] <moritz_> JimmyZ: known bu

[15:42] <jnthn> isBEKaml: I think it traces the parser/compiler stages as well as the runtime.

[15:42] <isBEKaml> jnthn: I just tried perl6 --trace=1 -e 'say "hi"'. It just spews out stuff

[15:42] <JimmyZ> moritz_: okay, thanks.

[15:42] <jnthn> isBEKaml: Yup

[15:42] <jnthn> isBEKaml: As I said, it's verbose. :-)

[15:42] <TimToady> sorear: there are reasons rakudo cannot do as well as STD: 1) rakudo must backtrack more aggressively to make up for lack of true LTM, so cannot commit to knowing that a panic is warranted where STD commits.

[15:43] <TimToady> and 2), it doesn't use a highwater algorithm to track what we were trying when we failed, or where that was.

[15:43] *** XaeroOne left
[15:43] <isBEKaml> jnthn: way too much verbose! :) Not that I complain, but maybe, cut down to what's just necessary or does it have all the debug switches enabled? 

[15:44] <jnthn> isBEKaml: If I get to running with --trace, I probably *want* to know everything that happens.

[15:45] <jnthn> isBEKaml: It's rare that you need that much info though, which is why the --target=... options are often awy more useful for debugging.

[15:45] <jnthn> *way

[15:45] <moritz_> rakudo: sub X { }; sub X { }

[15:45] <p6eval> rakudo cddbf3: OUTPUT«Multiple declarations of lexical '&X'␤␤current instr.: 'perl6;PCT;HLLCompiler;evalpmc' pc 987 (compilers/pct/src/PCT/HLLCompiler.pir:542)␤»

[15:45] <moritz_> parrot++

[15:46] <isBEKaml> moritz_: has it enforced public/private jurisdictions in classes yet? 

[15:46] <moritz_> it's not parrot's job

[15:47] <isBEKaml> jnthn: I just tried --target=past, it's way more readable. :)

[15:48] <jnthn> :-)

[15:48] <isBEKaml> moritz_: It's our job. ;)

[15:48] <pmichaud> isBEKaml: also, --target=pir is sometimes more useful

[15:49] <pmichaud> --trace shows every parrot instruction that executes... which can be a lot

[15:49] <pmichaud> --target=pir shows the PIR code that is generated

[15:49] <moritz_> should redefining an "only" method in class be an error?

[15:49] <moritz_> I think so, just not sure...

[15:49] <jnthn> moritz_: Believe so

[15:49] <jnthn> I thought we checked that...

[15:50] <jnthn> rakudo: class Foo { method m { }; method m { }; }

[15:50] <p6eval> rakudo cddbf3:  ( no output )

[15:50] <jnthn> Ah, apparently not.

[15:51] <isBEKaml> jnthn: another stupid qn, what does PMC in PAST code here stand for? 

[15:51] <pugssvn> r30623 | moritz++ | [t/spec] some Rakudo unfudges 

[15:51] <moritz_> jnthn: RT #68290, if you care

[15:52] <jnthn> moritz_: Need to care about $dayjob for a little ATM, but may be an easy fix.

[15:52] <isBEKaml> Parrot Machine Code? 

[15:53] <moritz_> Parrot Magical Cookie

[15:53] <jnthn> Parrot Magic Class

[15:53] <pmichaud> PolyMorphic Container

[15:53] <moritz_> or PolyMorphicContainer

[15:53] <jnthn> ...or cookie

[15:53] <jnthn> :-)

[15:53] <pmichaud> originally it was Parrot Magic Cookie

[15:53] <moritz_> it's basically "any parrot objects"

[15:53] <isBEKaml> That's a lot to remember. :)

[15:54] *** lucs left
[15:57] <isBEKaml> pmichaud: just did --target=pir, I'd say I prefer to look at PAST. :-). PIR generated looks like obfu to me compared to PAST compared to what I wrote in p6. ;)

[15:57] <[Coke]> it's been retcon'd.

[15:57] <pmichaud> isBEKaml: yes.  it actually makes a lot more sense to look at --target=pir for simpler languages like nqp 

[15:58] <pmichaud> in rakudo's case, there's so much setup+takedown that has to take place that it's hard to see the underlying bits at times

[15:59] <isBEKaml> pmichaud: and, I just noticed the .tailcall keyword in the pir. (hazarding a guess here) closure? 

[15:59] <pmichaud> no, just a tailcall

[15:59] <moritz_> tailcall is ... tailcall

[15:59] <pmichaud> it calls another sub while removing the caller

[16:00] <isBEKaml> ok.

[16:02] *** rv2733 left
[16:04] * pmichaud takes a continuation on handling rakudo closures and works on nqp settings.

[16:05] <isBEKaml> nqp: sub subbydo_returns($x) { my $temp:=23;  return {$x + $temp}; }; my $ttr := subbydo_returns;my $test2:=$ttr(23);say $test2;

[16:05] <p6eval> nqp: OUTPUT«Confused at line 1, near "say $test2"␤current instr.: 'parrot;HLL;Grammar;panic' pc 501 (src/cheats/hll-grammar.pir:196)␤»

[16:06] <jnthn> isBEKaml: need parens around args

[16:06] <jnthn> say($test2)

[16:06] <isBEKaml> nqp: sub subbydo_returns($x) { my $temp:=23;  return {$x + $temp}; }; my $ttr := subbydo_returns;my $test2:=$ttr(23);say($test2);

[16:06] <p6eval> nqp: OUTPUT«_block20␤»

[16:07] <isBEKaml> what?

[16:07] <isBEKaml> rakudo: sub subbydo_returns($x) { my $temp:=23;  return {$x + $temp}; }; my $ttr := subbydo_returns;my $test2:=$ttr(23);say($test2);

[16:07] <p6eval> rakudo cddbf3: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤current instr.: 'subbydo_returns' pc 253 (EVAL_1:34731342)␤»

[16:07] <isBEKaml> rakudo: sub subbydo_returns { my $temp:=23;  return {$_ + $temp}; }; my $ttr := subbydo_returns;my $test2:=$ttr(23);say($test2);

[16:07] <p6eval> rakudo cddbf3: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17864 (src/builtins/Junction.pir:393)␤»

[16:08] <isBEKaml> rakudo: sub subbydo_returns { my $temp=23;  return {$_ + $temp}; }; my $ttr:= subbydo_returns;my $test2=$ttr(23);say($test2);

[16:08] <p6eval> rakudo cddbf3: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17864 (src/builtins/Junction.pir:393)␤»

[16:08] <isBEKaml> rakudo: sub subbydo_returns { my $temp=23;  return {$_ + $temp}; }; my $ttr= subbydo_returns;my $test2=$ttr(23);say($test2);

[16:08] <p6eval> rakudo cddbf3: OUTPUT«46␤»

[16:08] <[Coke]> . o O (and people say purl is noisy. =-)

[16:09] <moritz_> [Coke]: people not reading error messages is pretty noisy :-)

[16:09] <isBEKaml> [Coke]: personally, I like fail-loud languages :)

[16:10] <jnthn> [Coke]: Yes, but there's some signal here. ;-)

[16:11] <PerlJam> isBEKaml: you must *love* Moose then!  It gives a complete strack trace when things go wrong.

[16:11] <isBEKaml> what's with nqp's response? 

[16:11] <PerlJam> er, s/strack/stack/

[16:11] <isBEKaml> PerlJam: I haven't used p5 that much. Just some silly scripts here and there. 

[16:11] <jnthn> PerlJam: You almost make that sound like a bad thing?

[16:11] <moritz_> rakudo also has noisy stack traces

[16:11] <moritz_> p6eval just strips them

[16:12] <jnthn> Main problem is that Rakudo's give all the PIR level info

[16:12] <jnthn> Rather than just the Perl 6 subs.

[16:12] <PerlJam> jnthn: It's not bad, but sometimes it is annoying.  9 times out of 10, I don't need the full stack trace.

[16:12] <isBEKaml> and stack traces aren't a bad thing per se. It's the ppl that code them to avoid problems. like passing over exceptions. 

[16:12] *** moritz_ sets mode: +oo PerlJam [Coke]

[16:13] <isBEKaml> PerlJam: I have been using java and I use stack traces to print everywhere I catch exceptions when in development and remove them to just include loggin when they go live. :)

[16:14] <PerlJam> I want a .perlrc file where I can tell it to be less verbose, but also remind me that I told it that and to suggest that I might want to be more verbose  :)

[16:15] <isBEKaml> or an environment variable? 

[16:15] <PerlJam> whatever the mechanism, I'm not picky

[16:15] <moritz_> btw test_summary.pl counted 32020 passing tests

[16:15] <Juerd> PerlJam: In that case you get a compile time option! ;)

[16:16] <Juerd> Sometimes it's better to be picky :P

[16:16] *** XaeroOne joined
[16:18] <isBEKaml> what? perl6 --help shows stagestats as one of its options but not on running.pod? :O

[16:18] <moritz_> patches welcome

[16:19] <isBEKaml> moritz_: in that case, stagestats had either been removed or you'd have to tell me what they do. :)

[16:19] *** justatheory joined
[16:20] <PerlJam> isBEKaml: looks like time spent in each stage to me

[16:20] * moritz_ finds that pretty obvious from the output

[16:20] <isBEKaml> Unable to open filehandle from path '--stagestats'

[16:20] <isBEKaml> this is what i get

[16:20] <moritz_> ./perl6 --stagestats t/spec/S02-literals/quoting.rakudo

[16:20] <moritz_> works here

[16:20] <PerlJam> isBEKaml: are you sure you didn't misspell the option?

[16:21] <isBEKaml> PerlJam: no. Was it added recently?

[16:21] <moritz_> yes

[16:22] <isBEKaml> ah, time for compile and upgrade. :)

[16:37] *** JimmyZ left
[16:37] *** pdcawley left
[16:39] *** cdarroch left
[16:45] <moritz_> std: sub a($!) { }

[16:45] <p6eval> std 30623: OUTPUT«ok 00:01 113m␤»

[16:45] *** xomas` joined
[16:46] *** xomas` left
[16:48] *** clintongormley left
[16:54] *** alester joined
[16:57] <diakopter> most of us are rational? or each of us is usually rational?

[16:58] *** SmokeMachine joined
[16:59] <diakopter> std: sub a($!!) { }

[16:59] <p6eval> std 30623: OUTPUT«ok 00:01 111m␤»

[17:02] <diakopter> std: sub a($!!) { !!$!!%!!$!!%$! }

[17:02] <p6eval> std 30623: OUTPUT«ok 00:01 112m␤»

[17:03] <jnthn> Ouch my eyes. :-P

[17:03] <arnsholt> diakopter: I hate you =p

[17:03] <diakopter> I see :)

[17:06] <diakopter> rakudo: sub a($!!) { !!$!!%!!$!!%$! }; say a(&a)

[17:06] <p6eval> rakudo f3998c: OUTPUT«Unable to bind attributive parameter '$!!' - could not find self␤current instr.: 'a' pc 193 (EVAL_1:78)␤»

[17:06] <jnthn> ...creative.

[17:07] <jnthn> rakudo: nice try :-)

[17:07] <p6eval> rakudo f3998c: OUTPUT«Confused at line 11, near "nice try :"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[17:23] *** k23z__ left
[17:35] * Tene looks at moritz_

[17:37] *** eternaleye left
[17:43] <moritz_> Tene: sorry, mis-hilighted you earlier

[17:43] <Tene> moritz_: I know.  Just harassing you.

[17:44] *** iblechbot joined
[17:58] *** cdarroch joined
[17:58] *** cdarroch left
[17:58] *** cdarroch joined
[18:01] *** jhuni joined
[18:02] <[Coke]> rakudo: try nice; "ok"

[18:02] <p6eval> rakudo f3998c:  ( no output )

[18:07] <diakopter> rakudo: say "ok" if try nice

[18:07] <p6eval> rakudo f3998c: OUTPUT«Null PMC access in get_bool()␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[18:08] <sorear> isBEKaml: Due to a bug in rakudo (which moritz++ recently applied my fix for), --stagestats wasn't being parsed

[18:08] <sorear> jnthn: 

[18:08] <sorear> buubot: karma jnthn

[18:08] <buubot> sorear: jnthn has karma of 810     

[18:08] <jnthn> Ah, like that. :-)

[18:08] <jnthn> buubot: karma jonathan

[18:08] <buubot> jnthn: jonathan has karma of 397     

[18:08] *** lue left
[18:09] <jnthn> I spread myself around. :-)

[18:09] <sorear> it's a real shame @karma is gone; having written large parts of the @karma bot I have a couple hundred on file there ;)

[18:09] <jnthn> Aww

[18:09] <jnthn> buubot: karma sorear

[18:09] <buubot> jnthn: sorear has karma of 64     

[18:09] <jnthn> Power of 2 win!

[18:09] *** Trashlord joined
[18:10] *** envi^home left
[18:16] <[Coke]> jnthn++ # WOO!

[18:16] <[Coke]> # ... oh, wait.

[18:20] <diakopter> TimToady: you may find this relevant: http://www.infoq.com/news/2010/05/STM-Dropped

[18:20] <diakopter> ruoso: u2 ^^

[18:25] <jnthn> [Coke]: :-P

[18:25] <cognominal> buubot:  karma gnole

[18:25] <buubot> cognominal: gnole has karma of 1     

[18:26] <cognominal> stupid French pun, about a revolutionary dance and booze.  :)

[18:29] *** xomas joined
[18:36] *** lue joined
[18:39] *** ShaneC joined
[18:41] *** ShaneC left
[18:52] *** xomas left
[18:55] *** am0c left
[18:57] *** am0c joined
[19:05] <pugssvn> r30624 | colomon++ | [t/spec] Unfudge a tad. 

[19:15] *** lue left
[19:15] *** lue joined
[19:16] *** XaeroOne left
[19:32] <cognominal> diaokopter: the ghc  haskell people are partlly founded by MS, are they still found of STM?

[19:33] <cognominal> *fond

[19:33] * colomon has decided it's worth deathmarching to 33,000 passing tests...

[19:35] <sjohnson> y0

[19:35] <[Coke]> colomon: This for trig stuff?

[19:36] <colomon> nope, for everything.

[19:37] <colomon> right now we're just over 32,000 passing tests.

[19:37] <[Coke]> oh, you should totally aim for 33,333, then!

[19:37] <colomon> And I'm spectesting changes that will get us about 30 more.  (in ceiling and floor)

[19:38] <colomon> mostly I'm hoping to have more passing than alpha used to before next week's release.

[19:38] <PerlJam> colomon++

[19:38] <[Coke]> rakudo: say 2**15

[19:38] <p6eval> rakudo f3998c: OUTPUT«32768␤»

[19:40] <cognominal> are the apps on proto using alpha or more recent rakudo?

[19:40] <colomon> cognominal: yes

[19:41] <colomon> depends on the app.

[19:41] <colomon> may not be many that are off alpha yet.

[19:41] <cognominal> ok

[19:57] <sorear> I'd like to call Rakudo's "say" from within Perl6::Compiler.

[19:58] <sorear> But say is a "my" sub.

[19:58] <sorear> Should I make it "our" or is there a less bad way?

[20:00] <sorear> maybe I could just use $*OUT.say directly

[20:05] <colomon> please try the last and let us know if it works...

[20:05] <colomon> :)

[20:05] <sorear> if it works?

[20:06] <sorear> I'm supposed to read something in that statement but I can't tell what.

[20:06] <colomon> say has been pretty hard to use in the core code lately, and if you've got a clever way I don't know about, I'm excited.  but only if it actually works, rather than just being a clever idea.

[20:07] <pugssvn> r30625 | colomon++ | [t/spec] Unfudge tests that now pass. 

[20:08] <colomon> I've been setting a global code variable and then assigning &say to it when I run tests.  uuuuugly.

[20:11] *** rv2733 joined
[20:12] <sorear> it works.

[20:13] * sorear wonders if $*AUTOPRINT should actually be &*AUTOPRINT and be able to override formatting

[20:14] <TimToady> std: [reduce { $^b < 0 ?? $^a-$^b : $^a+$^b }, -5..5].perl.say

[20:14] <p6eval> std 30624: OUTPUT«[31m===[0mSORRY![31m===[0m␤Precedence too loose within ??!!; use ??()!! instead  at /tmp/WSMtoqmShK line 1:␤------> [32m[reduce { $^b < 0 ?? $^a-$^b [33m⏏[31m: $^a+$^b }, -5..5].perl.say[0m␤    expecting an infix operator with precedence tighter than item assignment␤Parse

[20:14] <p6eval> ..f…

[20:14] <TimToady> hmm, correct, but LTA

[20:14] <colomon> sorear++: \o/

[20:17] * PerlJam would have no clue how to get from "precedence too loose" to "oh! I used a colon instead of !!"

[20:18] * [Coke] wonders if there is a limit as to how potentially helpful we can make the error messages.

[20:19] * [Coke] waits for a module that will just try to run your code and edit it with appropriate "did you mean" updates.

[20:20] <PerlJam> [Coke]: the limit is our ability to guess a priori what programmers *might* do and provide a hint as to what they should do.

[20:26] *** pmurias joined
[20:31] <sorear> I spoke slightly too soon

[20:31] <sorear> my perl6 cannot run any code from files

[20:32] <[Coke]> D'oh.

[20:34] *** Guest75855 left
[20:39] <pugssvn> r30626 | colomon++ | [t/spec] Add tests for method forms. 

[20:45] <diakopter> cognominal: I don't know; probably.

[20:47] *** Guest75855 joined
[20:51] *** jferrero joined
[20:55] <cognominal> I have not checked recently, but spj was a  STM advocate 

[20:55] *** ashleydev joined
[20:56] <bkeeler> That's because STM is easy in Haskell

[20:56] <ashleydev> I'm not sure if this commentary on the discussion of currency and STM has been mixed in here, but I thought I'd bring it up: http://www.bluebytesoftware.com/blog/2010/01/03/ABriefRetrospectiveOnTransactionalMemory.aspx

[20:56] <bkeeler> OH HAI #perl6!

[20:57] <ruoso> hugme, hug ruoso

[20:57] * hugme hugs ruoso

[20:57] * ruoso too tired for a friday

[20:58] <jnthn> bkeeler! \o/

[21:04] <bkeeler> Sorry I been scarce, it's been a hectic couple of weeks

[21:04] * colomon just added 100 passing tests the way that feels cheap.... :(

[21:05] <bkeeler> Who knew that turning 40 was such an involved process?

[21:05] *** perlygatekeeper left
[21:05] <colomon> bkeeler: oh no!  what do I have to fear in the near future?

[21:05] <colomon> (for generous definitions of "near")

[21:06] <bkeeler> Oh, big party, lots of guests, BBQ was going full swing for two days prior

[21:06] <bkeeler> Cooked nearly 50 pounds of meat

[21:06] <colomon> bkeeler++++++!

[21:06] <jnthn> Wow!!!

[21:06] <colomon> you have a smoker?

[21:06] <bkeeler> Yeah

[21:06] <bkeeler> Pulled pork, brisket, ribs etc

[21:06] <colomon> drool

[21:07] <bkeeler> The house is just now returning to normal

[21:07] <colomon> I was just looking at a smoker on Amazon.com, and fantasizing... 

[21:07] <bkeeler> I recommend the pellet kind.  Sooo easy to use

[21:08] *** pmurias left
[21:09] <bkeeler> http://drangle.com/~bruce/meatfest.jpg

[21:11] <bkeeler> Anyway, I figure its finally time to get back to the regex interpolation stuff

[21:13] <sorear> Why is "eval" silent?

[21:19] *** sahadev left
[21:20] <jnthn> bkeeler: Nice invite! :-D

[21:20] <jnthn> sorear: Silent?

[21:20] <sorear> rakudo: eval '$two'

[21:20] <p6eval> rakudo e98866:  ( no output )

[21:20] <jnthn> What would you expect?

[21:20] <sorear> rakudo: $two

[21:20] <p6eval> rakudo e98866: OUTPUT«Symbol '$two' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[21:20] <jnthn> Right, eval catches errors

[21:20] <sorear> That's a disgusting p5ism

[21:20] <jnthn> rakudo: eval '$two'; say $!

[21:21] <p6eval> rakudo e98866: OUTPUT«Symbol '$two' not predeclared in <anonymous>␤»

[21:21] <jnthn> ?

[21:21] <sorear> Runtime evaluation and exception handling are orthogonal issues.

[21:21] <sorear> If I want try eval "", I should have to say try eval ""

[21:21] <sorear> It's not even that much longer

[21:22] <jnthn> Well, then you're asking about the Perl 6 spec rather than Rakudo. :-)

[21:22] <jnthn> I don't feel strongly either way.

[21:22] <jnthn> And Rakudo can implement either.

[21:22] <sorear> rakudo actually goes out of its way by a fair amount to implement implicit try

[21:23] <sorear> so there must be a good reason

[21:23] <jnthn> It being the current spec and expectation is a good reason.

[21:24] <jnthn> Now we have the blockless form of try though, it is pretty short to seperate the two out.

[21:28] <TimToady> first let's count how many evals in the test suite would have to change to 'try eval'

[21:29] * colomon just added a few.

[21:29] <jnthn> TimToady: A lot of things use eval_dies_ok and eval_lives_ok, which certainly would need to be changed.

[21:29] <jnthn> TimToady: Though that's a test harness change rather than a test change.

[21:29] <sorear> TimToady: some evals in the test suite are already try { eval }

[21:29] *** ruoso left
[21:30] <sorear> S02-builtin_data_types/anon_block.t :94

[21:30] <TimToady> then there's the question of whether we can actually change Perl culture that much...

[21:30] *** iblechbot left
[21:31] <TimToady> on that topic, it'd be better to leave eval as is, and come up with a different word for the tryless kind

[21:31] <jnthn> .oO( compile )

[21:31] <jnthn> Though that sounds like it doesn't run it

[21:32] <bkeeler> A version that doesn't run it could be useful though

[21:33] <jnthn> True

[21:33] <jnthn> compile('foo').() # bit ugly though.

[21:35] <arnsholt> my &code = compile('foo') might be nice though

[21:35] <jnthn> yeah

[21:36] <arnsholt> Stuff like mod_perl wrapping CGI scripts would probably like it

[21:38] <sorear> rakudo: my &code = Perl6::Compiler.compile('say "Hello"');  code;

[21:38] <p6eval> rakudo e98866: OUTPUT«Hello␤»

[21:39] <arnsholt> Quick to implement too it appears =)

[21:40] <moritz_> rakudo: my &code = Perl6::Compiler.compile('say "Hello"'); say "compiled"; code(); code()

[21:40] <p6eval> rakudo e98866: OUTPUT«compiled␤Hello␤Hello␤»

[21:40] <sorear> Does anybody else see failures with S02-magicals/progname.t ?

[21:41] <sorear> It doesn't look like any of my changes should have had an effect there

[21:41] <colomon> sorear: not here.

[21:41] * moritz_ recompiles

[21:41] <sorear> rakudo: $*PROGRAM_NAME ~~ /./

[21:42] <p6eval> rakudo e98866:  ( no output )

[21:42] <sorear> rakudo: say $*PROGRAM_NAME

[21:42] <p6eval> rakudo e98866: OUTPUT«/tmp/dzElm34En4␤»

[21:42] <sorear> huh.

[21:42] <moritz_> you didn't say anything in the first eval

[21:42] <jnthn> rakudo: say $*PROGRAM_NAME ~~ /./

[21:42] <p6eval> rakudo e98866: OUTPUT«/␤»

[21:42] <sorear> yes

[21:42] <sorear> I know

[21:42] <sorear> however, $*PROGRAM_NAME doesn't exist here!

[21:43] <sorear> I seem to have magically broken whatever is supposed to set it

[21:44] <pugssvn> r30627 | lwall++ | [STD.pm6] do a bit better at diagnosing bogus ??!! constructs of various sorts 

[21:44] <cognominal> what is the story on the := operator in rakudo?

[21:45] <moritz_> NYI in master.

[21:45] <moritz_> that's a short story :-)

[21:45] *** ashleydev left
[21:46] <moritz_> though I think binding to a a scalar, hash or array shouldn't be too hard - it's already implemented for signatures

[21:46] <moritz_> binding to a hash or array item could be harder

[21:47] <cognominal> ok.

[21:47] <sorear> really, the hardest part is parsing

[21:48] <moritz_> it's parsed already

[21:48] <sorear> the LHS of := has to be parsed as an expression then turned into a signature

[21:48] <moritz_> for some value of "parsed"

[21:48] <jnthn> sorear: Not really.

[21:48] <sorear> and we can't currently do that except in very limited cases

[21:48] <jnthn> sorear: At least, that's not the plan I heard for implementing it.

[21:49] <sorear> jnthn: What complicated plan was that?

[21:49] <sorear> rakudo: my $a; my $b; Q:PIR { $P0 = find_lex "$a" ␤ store_lex "$b", $P0 }; $a = 5; say $b

[21:49] <jnthn> sorear: Something fun involving object refs and in-place upgrade or something. It makes sense every time pmichaud++ explains it to me. :-)

[21:49] <p6eval> rakudo e98866: OUTPUT«5␤»

[21:50] <sorear> see, we have the backend technology for binding RIGHT NOW

[21:50] <sorear> pmichaud: why am I wrong?

[21:50] <jnthn> sorear: We could perhaps maybe doing it that way.

[21:50] <jnthn> *do

[21:52] <sorear> does anyone see any spectest failures at the moment?

[21:53] <moritz_> last time I tried I saw a lot '1' exit codes

[21:53] *** nimiezko joined
[21:53] <sorear> S04-statements/return.t looks like a case of "how could this work"

[21:54] *** SmokeMachine left
[21:58] *** jotr^byebye is now known as jotr^outtahere

[21:59] <sorear> rakudo: eval 'return 1'; say $!

[21:59] <p6eval> rakudo e98866: OUTPUT«␤»

[22:01] <sorear> rakudo: use Test; eval_dies_ok 'return 1'

[22:01] <p6eval> rakudo e98866: OUTPUT«ok 1 - ␤»

[22:01] <moritz_> rakudo: my $x =  eval 'return 1'; say $!.Bool; say $x.perl

[22:01] <p6eval> rakudo e98866: OUTPUT«1␤()␤»

[22:01] <moritz_> eval_dies_ok probably uses the old perl 5 trick

[22:02] <moritz_> no

[22:02] <sorear> This is amazing.

[22:02] <moritz_> try { eval ($code); $eval_exception = $! }

[22:02] <sorear> 'return 1' throws a return exception

[22:02] <sorear> it's caught by the blanket handler in eval

[22:02] <sorear> which stores the 1 in $!

[22:02] <sorear> I think

[22:03] <sorear> rakudo: my $x = eval 'return 0'; say $!.Bool;

[22:03] <p6eval> rakudo e98866: OUTPUT«1␤»

[22:03] <jnthn> sorear: Sounds plausible.

[22:03] <moritz_> rakudo: my $x = eval 'return 0'; say $!

[22:03] <p6eval> rakudo e98866: OUTPUT«␤»

[22:03] <jnthn> Well

[22:04] <jnthn> Plausible that it's catching the return exception.

[22:04] <sorear> Anyway, when I simplified eval to use $compiler.eval instead of $compiler.compile; #`( stuff that eval does itself these days ); $code()

[22:04] <sorear> it stopped working

[22:05] <jnthn> Must be some subtle difference between them.

[22:05] <moritz_> the difference in scope of the $code() call?

[22:05] <sorear> moritz_: and the return exception handler

[22:06] <sorear> extra handler

[22:06] <moritz_> for example in Perl 6 there are the $_, $/ and $! magical vars automatically set up

[22:06] <sorear> they're set up from OUTER, not CALLER

[22:06] <sorear> and the OUTER will be the same here

[22:07] <sorear> src/cheats/eval.pm uses a blanket exception handler; it will catch return exceptions and put them in $!

[22:08] <moritz_> t/spec/S06-signature/named-parameters.rakudo                 (Wstat: 11 Tests: 82 Failed: 0) Non-zero wait status: 11 Parse errors: No plan found in TAP output

[22:08] *** alester left
[22:09] <moritz_> that's the only fail in my spectest that's not just non-zero exit status

[22:09] <moritz_> off to bed, good night() to near UTCish people :-)

[22:09] *** masonkramer joined
[22:22] *** am0c left
[22:42] *** clintongormley joined
[22:44] *** meppl left
[22:45] <lue> AUGCAUAUUUAA!

[22:50] <lue> hello?

[22:53] <saaki> echo echo echo

[22:55] <lue> XKCD-inspired Wikipedia war: http://en.wikipedia.org/wiki/Malamanteau (check out the discussion tab)

[22:58] *** Psyche^ joined
[22:58] *** clintongormley left
[22:59] * lue is getting really annoyed that whenever he comes to #perl6 lately, it's dead silent.

[23:00] <bkeeler> *crickets*

[23:02] *** Patterner left
[23:02] *** Psyche^ is now known as Patterner

[23:07] *** dual left
[23:07] *** kensanata joined
[23:07] <pmichaud> no, the lhs of := does not have to be a signature.  TimToady clarified that a short time ago.

[23:09] <lue> Just Mu, right?

[23:10] *** nimiezko left
[23:10] * lue starts wondering about less defined than Mu.

[23:13] *** dual joined
[23:16] *** kel_ left
[23:18] <lue> .oO(a portmanteau, malapropism, and neologism... malamanteau is awesome!)

[23:20] *** kensanata left
[23:20] <saaki> heh

[23:20] <jnthn> The discussion page was, like, almost YouTube comment page quality.

[23:22] <bkeeler> In pir, what happens if you call 'iter' on something that's not an array, or otherwise iterable?

[23:22] <sorear> demons fly out of your nose

[23:22] <bkeeler> Sounds painful

[23:22] <sorear> you can't do anything with a PMC unless you know exactly what APIs the PMC is written to

[23:23] <sorear> a PMC is allowed to interpret any operation in any way

[23:23] <sorear> most non-iterable PMCs will probably use the 'default' iter, which throws an exception

[23:23] <jnthn> bkeeler: The boring answer that doesn't involve nose demons is that you'll get an error about get_iterator not being implemented in a PMC of type worreva. :-)

[23:24] <sorear> but you can't count on that :/

[23:24] <jnthn> You can't count on nose demons either. ;-)

[23:24] <bkeeler> Any way to find out if it does support get_iterator?

[23:24] <jnthn> bkeeler: not afaik

[23:24] <sorear> If you have a PMC without knowing what it is, you're already doing something wrong

[23:25] <jnthn> sorear: Well...or the set of things it could be, anyway.

[23:25] <sorear> trace that PMC backward; where it enters your code, slap an interface comment

[23:26] <sorear> jnthn: sure, all thet matters is you need to require an interface

[23:26] <lue> .oO(EPMCDESIGNFLAW)

[23:26] <jnthn> bkeeler: A Perl 6 thing will have a .iterator method and do the Iterable role.

[23:26] <bkeeler> Indeed.  I'm in nqp-land right now though

[23:26] <sorear> it doesn't make sense to say "this function takes an arbitrary PMC" (unless it's just storing them)

[23:27] <sorear> it does make sense to say "this function takes an arbitrary PMC which either iterates like an array or throws an exception in iter"

[23:38] <lue> afk (whilst thinking about malamanteaus)

[23:50] <sorear> we have 1,000+ tests for cosine?

[23:52] <jnthn> Well, that's 'cos... ;-)

[23:53] <jnthn> sorear: Well, when you consider boundary conditions + the various Perl 6 number types (int, num, complex, rat)..and then do something combinatorial...you easily get a lot of tests.

[23:57] <sjohnson> hello all

[23:58] <jnthn> o/ sjohnson 

[23:59] <sjohnson> （　｀ー´）

