[00:00] <cono> tadzik: in p6 I wanted to take lazy list with results, not a cb

[00:00] *** Patterner left
[00:00] *** Psyche^ is now known as Patterner

[00:02] <tadzik> hmm. That might be even better. http://wiki.github.com/rakudo/rakudo/perl-5-modules-to-port-to-perl-6 lists File::Find as one of the wanted modules, and I wonder what did the author of this have in mind: an almost verbatim port (from API side), or something new giving the same functionalities

[00:03] <cono> I guess functionality

[00:03] <cono> new perl = new functionality :)

[00:04] <tadzik> that sounds sane :)

[00:04] <cono> why you need to make backport functionality?

[00:04] <tadzik> Maybe that's what people are expecting? I don't know, hence my questions

[00:05] <cono> tadzik: are you a author of p5's File::Find ?

[00:05] <tadzik> cono: nope

[00:05] <cono> ic

[00:05] <tylercurtis> tadzik: could the callback delete files that would otherwise later be found? If so, including a way to do the callback approach might be nice even though the list approach would probably be nicer most of the time.

[00:05] <tadzik> I've never written any Perl 5 module actually

[00:05] *** Limbic_Region joined
[00:06] <tadzik> tylercurtis: I think that's possible

[00:06] <cono> if cycle iterate it before deleting :)

[00:06] <tylercurtis> then again, if the list is lazy, I guess that wouldn't be a problem.

[00:07] <jnthn> pmichaud: Tests were fine. \o/

[00:08] *** skids joined
[00:09] <cono> tadzik: pay attention on OS detection at the end of file: http://cpansearch.perl.org/src/JESSE/perl-5.12.1/lib/File/Find.pm

[00:09] <tadzik> http://wklej.org/id/367460/ -- what does it want? Both arguments fit, don't they?

[00:10] <tadzik> cono: oh, right, windows

[00:10] <tadzik> well, that'd only change the directory separator in my case. Windows uses \, yep?

[00:10] <tylercurtis> tadzik: find(&foo, 'lib')

[00:10] <cono> tadzik: and others and others :)

[00:11] <tadzik> tylercurtis: yep, that's it. Where's the mistake?

[00:11] <cono> tadzik: elsif ($^O eq 'MacOS') { ...

[00:11] <tadzik> (I guess it's some ridicolous typo)

[00:11] <dalek> rakudo: c633afc | jonathan++ | src/cheats/parrot/Sub.pir:

[00:11] <dalek> rakudo: Make sure that if the static sub had its $!do changed, all the dynamics also 

[00:11] <dalek> rakudo: will have that $!do. Makes it possible to fix wrap properly later, but more 

[00:11] <dalek> rakudo: immediately makes Zavolaj work again.

[00:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c633afc74f237b0051d3139a996af97ee9af64dd

[00:11] <tadzik> cono: MacOS uses \ too?

[00:12] <tadzik> for now, the directory separator is the only thing that would make the code not portable (I hope)

[00:12] <cono> tadzik: look at the Find.pm, it skips ^Icon\015\z at macos ... and so on

[00:13] <tadzik> hmm. I've never used MacOS, so I don't really know the case. Well, that has to be taken into consideration though

[00:13] <tylercurtis> tadzik: that parses as a call to find with "(&foo, 'lib') as an argument.

[00:13] <tylercurtis> tadzik: You want "find(&foo, 'lib')"

[00:13] <cono> tadzik: perldoc File::Find /dont_use_nlink

[00:14] <tadzik> oh this damn whitespace

[00:14] <tadzik> thanks tylercurtis++

[00:15] *** perlygatekeeper1 left
[00:15] <tadzik> cono: well, I don't use nlink either :)

[00:15] <tylercurtis> tadzik: at least it is visible significant whitespace. :)

[00:16] *** perlygatekeeper joined
[00:16] <tylercurtis> (assuming no one is evil enough to use a Unicode thin space...)

[00:16] <tadzik> being whitespace sensitive smells python to me, but my coding style was to always omit space here anyway

[00:16] <cono> tadzik: I guess you need read File/Find.pm more carefully :)

[00:16] <tadzik> cono: I see that File::Find does some fancy magic: nlink, stat, I just recursively travel across directories :)

[00:17] <cono> :)

[00:17] <tadzik> still, I wonder how bad it is :)

[00:17] <cono> What are you doing if you found symlink to a directoru?

[00:17] <tylercurtis> tadzik: like I said, at least you can see the whitespace or lack thereof, unlike in Python.

[00:17] <tadzik> cono: good question, it should be checked

[00:18] <cono> :)

[00:18] <PerlJam> tadzik: I have a dinky little File::Find like thing I did at http://github.com/perlpilot/file-find-p6  (It doesn't handle anything but ordinary files and directories )

[00:18] <tylercurtis> And they don't even get the ease of defining new operators in exchange. :)

[00:18] <tadzik> PerlJam: yep, that's similar to mine

[00:19] <tadzik> PerlJam: http://wklej.org/id/367461/

[00:19] <tadzik> I also implemented finddepth and stuff, but the algorithm is basically the same

[00:21] <cono> tadzik: look at File::Spec implementation http://search.cpan.org/~smueller/PathTools-3.31/ it have different class for different OS. Nice idea imho

[00:22] <tadzik> cono: yep, nice. Yet I think File::Spec has more platform specific things to do -- if not everything it does it platform specific

[00:23] <cono> I think all modules in File::* have platform specific stuff

[00:23] <tadzik> probably

[00:23] <cxreg> yay, now i can get back to making Pg pass all the tests

[00:23] <cxreg> jnthn++ pmichaud++

[00:23] *** lest_away is now known as lestrrat

[00:25] *** azert0x left
[00:28] *** oha joined
[00:30] *** masonkramer joined
[00:30] *** justatheory joined
[00:33] *** justatheory left
[00:34] *** oha left
[00:35] <lue> rakudo: sub circumfix:<[ )>(@a) { @a[0] ..^ @a[1] }; say [0,10)

[00:35] <p6eval> rakudo 1d4ba4: OUTPUT«0123456789␤»

[00:41] *** ash_ left
[00:44] <TimToady> rakudo: sub circumfix:<[ )>(@a) { @a[0] ..^ @a[1] }; say [1,2,3]

[00:44] <p6eval> rakudo 1d4ba4: OUTPUT«1 2 3␤»

[00:46] <sorear> TimToady: oh, beautiful.

[00:47] <lue> I need to see if there's a way to say something like (@a where .elems = 2)

[00:48] <sorear> ==, surely?

[00:48] <sorear> TimToady: What is the relationship between .HOW and .WHO?

[00:49] <lue> oh, yes of course :)

[00:49] <jnthn> lue: That's disgusting. :P

[00:50] <jnthn> circumfixes with non-matching endpieces

[00:50] <jnthn> :-)

[00:50] <lue> but it's mathematics!

[00:50] <lue> [ISO did much worse, (more)]

[00:50] <lue> rakudo: sub circumfix:<[ [>(@a) { @a[0] ..^ @a[1] }; say [0,10[

[00:50] <p6eval> rakudo c633af: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 22␤»

[00:51] <lue> it won't even work! :)

[00:51] <jnthn> Heh

[00:51] *** patspam left
[00:51] <jnthn> Yeah, circumfixes are very picky about what chars you can use as starters and stoppers.

[00:51] <lue> [0,10[ is the ISO way of saying [0,10)  # see wikipedia on interval notation

[00:52] <lue> rakudo: sub circumfix:<] [>(@a) { @a[0] ^..^ @a[1] }; say ]0,10[ # ISO way for (0,10)

[00:52] <p6eval> rakudo c633af: OUTPUT«===SORRY!===␤Confused at line 22, near "]0,10[ # I"␤»

[00:52] *** patspam joined
[00:52] <tylercurtis> lue: I think that should be valid, but isn't implemented in Rakudo yet.

[00:52] <lue> .oO(IMO, ISO hit their heads when deciding that one)

[00:53] <tylercurtis> std: sub circumfix:<] [>(@a) { @a[0] ^..^ @a[1] }; say ]0,10[ # ISO way for (0,10)

[00:53] <p6eval> std 31784: OUTPUT«===SORRY!===␤Confused at /tmp/cvcPCa7GiU line 1:␤------> fix:<] [>(@a) { @a[0] ^..^ @a[1] }; say ⏏]0,10[ # ISO way for (0,10)␤    expecting any of:␤      argument list␤    statement modifier loop␤Other potential difficulties:␤  Unsupported use

[00:53] <p6eval> ..of bare '…

[00:53] <tylercurtis> Maybe not.

[00:53] <jnthn> tylercurtis: Custom circumfixes are implemented.

[00:54] <jnthn> tylercurtis: But chars you get away with for doing them is a whole other matter.

[00:54] <lue> .oO[ The GNU Octave language is plain confusing, and possessing the Virtues of a Programmer doesn't help :) ]

[00:55] <TimToady> sorear: WHO has nothing to do with HOW, really.  HOW is the metaobject.  WHO is supposed to uniquely identify the library module that supplies the definition of the object, including all the :ver and :auth info

[00:56] <TimToady> WHO is sort of the original "from" of the use

[00:56] <lue> [ matrices being the basic data type is a mistake. ]

[00:57] *** macroron left
[00:59] *** au|zzz is now known as au|irc

[01:04] *** timbunce left
[01:08] <sorear> TimToady: I see

[01:09] <sorear> TimToady: I'm vaguely trying to understand the connection between Foo and Foo::, if there is one at all.  jnthn talked about (class { our $x = 42 }).WHO<$x> earlier

[01:11] *** colomon joined
[01:17] *** rurban left
[01:24] *** Schwern left
[01:28] *** ash_ joined
[01:31] *** tadzik left
[01:39] *** ashleydev left
[01:44] <dalek> rakudo: 82b1b78 | (Solomon Foster)++ | src/core/operators.pm:

[01:44] <dalek> rakudo: Allow Int factors in geometric series if possible.

[01:44] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/82b1b7823cd865fcdbb62928eb53d00d96adcebf

[01:45] *** plobsing joined
[01:47] *** skids left
[01:50] <plobsing> ping ash_ 

[01:50] <ash_> hi

[01:50] <ash_> i am on #parrot also 

[01:50] <plobsing> oops, wrong channel

[02:01] *** jferrero left
[02:16] *** xabbu42_ joined
[02:17] *** timbunce joined
[02:19] *** xabbu42 left
[02:19] *** xabbu42_ is now known as xabbu42

[02:21] *** snarkyboojum left
[02:37] *** snarkyboojum joined
[02:44] *** ashleydev joined
[02:52] *** patspam left
[02:52] *** felliott joined
[02:55] *** Daenyth joined
[02:56] <Daenyth> Hi, I'm trying to compile rakudo 2010.06, and I get this compile error:

[02:56] <Daenyth> /usr/bin/parrot  src/gen/perl6.pbc --target=pir  \ src/gen/core.pm > src/gen/core.pir

[02:56] <Daenyth> /usr/bin/parrot: symbol lookup error: dynext/perl6_ops.so: undefined symbol: Parrot_find_global_n

[02:56] <Daenyth> make: *** [perl6.pbc] Error 127

[02:56] <Daenyth> I'm on arch linux 32 bit with parrot 2.6.0

[02:57] <pmichaud> rakudo 2010.06 might not run with parrot 2.6.0

[02:57] <Daenyth> pmichaud: what versions should I try things with?

[02:57] <pmichaud> normally each version of rakudo "knows" what version of parrot to use

[02:57] <pmichaud> see build/PARROT_REVISION if you're not using the --gen-parrot option

[02:57] <Daenyth> yeah, I'm not. I maintain the rakudo package for arch, which typically uses the system's parrot package

[02:58] <pmichaud> tomorrow's release of Rakudo will work with Parrot 2.6.0

[02:58] <Daenyth> sounds good enough then :)

[02:58] <Daenyth> I'm really looking forward to it

[02:59] <Daenyth> Once rakudo * comes out I'll be adding it to pacman's community repository

[02:59] <Daenyth> er

[02:59] <Daenyth> s/pacman/arch/

[02:59] <jnthn> Pacman! \o/

[02:59] <pmichaud> that will be a week from tomorrow.

[02:59] <Daenyth> yup

[03:00] <Daenyth> looking forward to hacking at project euler in p6 too, just decided I'd start

[03:00] <jnthn> pmichaud: If you missed it in the backscroll - the Zavolaj fix caused no new fails and got committed.

[03:00] <Daenyth> been doing it in python but now I'll be doing it in py, p6 and haskell

[03:00] <pmichaud> \o/

[03:01] *** astrojp joined
[03:04] <tylercurtis> Daenyth: It'll probably be slow, but it'll be lovely.

[03:06] <Daenyth> indeed

[03:07] * jnthn -> sleep o/

[03:08] <pmichaud> jnthn: ping

[03:08] <pmichaud> (hoping to catch before sleep)

[03:09] *** Limbic_Region left
[03:09] <pmichaud> http://gist.github.com/485512  # this program takes 33 seconds under kiev; takes 75 seconds under current trunk  :-(

[03:10] *** skids joined
[03:12] *** hatseflats left
[03:12] *** PerlJam left
[03:13] *** hugme left
[03:15] *** dukeleto left
[03:15] *** dalek left
[03:15] *** Juerd left
[03:15] *** pmichaud left
[03:15] *** dukeleto joined
[03:16] *** Juerd joined
[03:16] *** pmichaud joined
[03:17] *** pugssvn left
[03:19] <snarkyboojum> takes exactly 33 seconds on master here (not that that's useful for comparison purposes :))

[03:20] *** Juerd left
[03:20] *** pmichaud left
[03:20] <sorear> Daenyth: Welcome!

[03:21] *** dukeleto left
[03:21] *** hatseflats joined
[03:21] *** pmichaud joined
[03:21] *** dukeleto joined
[03:25] <Daenyth> o/

[03:26] *** hatseflats left
[03:26] *** ash_ left
[03:26] *** knewt2 left
[03:26] *** rgrau left
[03:26] *** sftp left
[03:26] *** Lorn left
[03:26] *** cognominal left
[03:26] *** pjcj left
[03:26] *** c1sung left
[03:26] *** Tene left
[03:26] *** sukria left
[03:26] *** dimid_ left
[03:27] *** pugssvn joined
[03:29] *** meppel joined
[03:29] *** c1sung joined
[03:29] *** sorear sets mode: +voo pugssvn pmichaud dukeleto

[03:30] *** sorear sets mode: +v p6eval

[03:30] *** hatseflats joined
[03:31] *** sftp joined
[03:31] *** ash_ joined
[03:31] *** knewt2 joined
[03:31] *** Lorn joined
[03:31] *** cognominal joined
[03:31] *** pjcj joined
[03:31] *** Tene joined
[03:31] *** sukria joined
[03:31] *** dimid_ joined
[03:33] <cxreg> o_O

[03:33] <cxreg> "state" not yet implemented at line 308, near "ment    =>"

[03:33] *** meppl left
[03:33] <cxreg> line is:             statement    => $statement,

[03:33] <pmichaud> oooops.

[03:33] <pmichaud> file bug, plz?

[03:34] <Daenyth> hrm

[03:34] <Daenyth> Haskell confuses me :(

[03:34] *** PerlJam joined
[03:34] <cxreg> rakudo: my %hash = (statement => "foobar")

[03:34] <pmichaud> right

[03:34] <p6eval> rakudo 82b1b7: OUTPUT«===SORRY!===␤"state" not yet implemented at line 22, near "ment => \"f"␤»

[03:34] <cxreg> ok, filing

[03:34] <pmichaud> looks like the "NYI" message is a little over-eager.

[03:34] <cxreg> heh

[03:34] <pmichaud> I might be able to fix locally.

[03:37] <cxreg> rakudo: my %hash = ("statement" => "foobar")

[03:38] <p6eval> rakudo 82b1b7:  ( no output )

[03:38] <cxreg> rakudo: my %hash = (somestatement => "foobar")

[03:38] <p6eval> rakudo 82b1b7:  ( no output )

[03:38] <cxreg> so just bareword hash keys that start with "state"

[03:39] <pmichaud> it's only a problem because it's seeing the "state" part of "statement" as a potential declarator, and carping immediately (before noting that it's not really a declarator)

[03:39] <cxreg> heh

[03:39] <pmichaud> rakudo:  my %hash = ( supersederfoo => 'xyz' );   # same problem

[03:39] <p6eval> rakudo 82b1b7: OUTPUT«===SORRY!===␤"supersede" not yet implemented at line 22, near "rfoo => 'x"␤»

[03:39] <pmichaud> I have a local fix, I think -- compiling now.

[03:39] <tylercurtis> http://github.com/ekiru/p6-html4 Yay! I'm done translating the HTML 4.01 Strict DTD to Perl 6! Now to make it actually work in Rakudo. :)

[03:39] <cxreg> rt 76644 filed

[03:40] <pmichaud> cxreg++

[03:41] <tylercurtis> And then to actually make it capable of emitting HTML. I suppose that would be a useful feature.

[03:42] <pmichaud> pmichaud@plum:~/rakudo$ ./perl6

[03:42] <pmichaud> > my %hash = (statement => 'xyz');

[03:42] <pmichaud> statement	xyz

[03:42] <cxreg> yay

[03:42] <pmichaud> quicktesting now

[03:45] * cxreg is trying to grok p6rules enough to see where this breaks

[03:45] <cxreg> is it in termish?

[03:46] <pmichaud> cxreg: http://gist.github.com/485540

[03:46] <tylercurtis> cxreg: my guess is that the check for 'state' and 'supersede' that panics doesn't check for a word boundary.

[03:46] <snarkyboojum> pmichaud: wow - fwiw, on my lappy that program runs in 14 seconds on kiev and 33 on master

[03:46] <pmichaud> snarkyboojum: nice laptop.  :)

[03:46] <pmichaud> I'm running it on my slow desktop righ tnow

[03:47] <pmichaud> anyway, the problem is the 200%+ slowdown

[03:47] <snarkyboojum> pmichaud: :P - thought I'd check the 2+ times speed reduction

[03:47] <snarkyboojum> yeah

[03:48] <pmichaud> I'm bisecting now to find where the problem might be.

[03:51] <Daenyth> Yay, my first haskell program compiled!

[03:51] <Daenyth> (Boo, it didn't work right! :( )

[03:52] <snarkyboojum> Daenyth: hey - satisfying the type system is still something! :)

[03:52] <Daenyth> yeah, that broke me for a bit

[03:52] <Daenyth> I'm still letting my brain ferment enough to learn this language

[03:55] <Daenyth> http://gist.github.com/485549 I'm trying to figure out what I did wrong...

[03:55] <Daenyth> should probably head to #haskell too..

[03:56] <tylercurtis> Daenyth: does the problem say to include numbers which are divisible by both 3 and 5?

[03:56] * sorear used to be a regular there

[03:56] <Daenyth> tylercurtis: yeah

[03:56] <Daenyth> "Add all the natural numbers below 1000 that are multiples of 3 or 5."

[03:57] <Daenyth> actually my limit should be 999, but still

[03:57] <Daenyth> 9 is just way off

[03:58] <sorear> Daenyth: you should be using ghci for this

[03:58] <sorear> load the file

[03:58] <sorear> 1. check if wanted returns the right values for stuff

[03:58] <Daenyth> hrm

[03:58] <sorear> 2. check problem1 3 - it's not 3?  problem solved

[03:58] <sorear> etc

[03:59] <Daenyth> if if :l file, I get "Not in scope: `wanted'" when I try to use that

[03:59] <Daenyth> (First day with haskell)

[03:59] <sorear> module Euler1 (wanted, problem1, main) where

[03:59] <Daenyth> aha

[03:59] <sorear> perhaps an export list will help

[04:00] <sorear> it's been about two years since I used haskell

[04:00] <Daenyth> that did it

[04:00] <sorear> hmm, ISTR you can leave off the export list entirely to mean "everything' as long as the module / where is there

[04:00] <sorear> exporting functions made it give the right answer??

[04:00] <Daenyth> er no

[04:00] <Daenyth> made it in scope 

[04:00] <Daenyth> :)

[04:01] <Daenyth> aha

[04:01] <Daenyth> so yeah, not giving the right value somewhere

[04:01] <Daenyth> wanted 10 -> False

[04:01] *** snarkyboojum left
[04:01] <Daenyth> oh

[04:01] <Daenyth> had the mod arguments in the wrong order

[04:01] <Daenyth> should really have used infix there >.>

[04:02] <Daenyth> yay, it works now!

[04:02] <Daenyth> sorear: many thanks :D

[04:03] <Daenyth> Now to figure out how to golf this fucker down a notch ;)

[04:05] *** snarkyboojum joined
[04:06] *** cognominal left
[04:07] *** cognominal joined
[04:09] <sorear> rakudo: my $x = (); say $x.perl; say $x.WHAT;

[04:09] <p6eval> rakudo 82b1b7: OUTPUT«Any␤Any()␤»

[04:11] <snarkyboojum> Daenyth: try mod x 3 and mod x 5

[04:12] <Daenyth> yeah, I got it now :)

[04:12] <snarkyboojum> oops - nevermind.. just looked at the log

[04:12] <Daenyth> http://github.com/Daenyth/Project-Euler/blob/master/haskell/1/euler1.hs

[04:12] <Daenyth> <3

[04:15] <pmichaud> RT #76644 fix pushed ... cxreg++

[04:16] *** Juerd joined
[04:16] <cxreg> pmichaud++ # no thank *YOU* :)

[04:21] <colomon> rakudo: say [+] (1 ... 999).grep(* %% 3 || * %% 5)

[04:21] <p6eval> rakudo 82b1b7: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in <anon> at line 2:/tmp/hwbVhWFQpF␤  in 'Block::ACCEPTS' at line 5405:CORE.setting␤  in 'infix:<~~>' at line 397:CORE.setting␤  in <anon> at line 1383:CORE.setting␤  in 'List::Bool' at line 1␤  in 'prefix:<!>' at

[04:21] <p6eval> ..line…

[04:21] <colomon> rakudo: say [+] (1 ... 999).grep(* %% any(3, 5))

[04:21] <p6eval> rakudo 82b1b7:  ( no output )

[04:23] <colomon> > say [+] (1 ... 999).grep(* %% any(3, 5))

[04:23] <colomon> 233168

[04:23] <snarkyboojum> colomon: v. nice :)

[04:24] *** sftp left
[04:24] *** ash_ left
[04:24] *** knewt2 left
[04:24] *** Lorn left
[04:24] *** pjcj left
[04:24] *** Tene left
[04:24] *** sukria left
[04:24] *** dimid_ left
[04:27] <snarkyboojum> > say [+](1 .. 999).grep: * %% (3|5)

[04:27] <snarkyboojum> 233168

[04:28] <Daenyth> that's beautiful

[04:29] <Daenyth> %% is modulo?

[04:29] <tylercurtis> %% is divisible IIRC. % is modulo.

[04:29] *** sftp joined
[04:29] *** ash_ joined
[04:29] *** knewt2 joined
[04:29] *** Lorn joined
[04:29] *** pjcj joined
[04:29] *** Tene joined
[04:29] *** sukria joined
[04:29] *** dimid_ joined
[04:30] <pmichaud> %% is  "evenly divisible by"

[04:30] <pmichaud> say 9 %% 3

[04:30] <pmichaud> rakudo: say 9 %% 3

[04:30] <snarkyboojum> divisible by or some such..  % is modulo

[04:30] <pmichaud> p6eval still doesn't like me.  :-|

[04:30] <p6eval> rakudo 82b1b7: OUTPUT«1␤»

[04:30] <lue> rakudo: play "nice"

[04:30] <p6eval> rakudo 82b1b7: OUTPUT«Could not find sub &play␤  in main program body at line 22:/tmp/ReRPsa86Cc␤»

[04:31] <snarkyboojum> "evenly divisible by" - that's what I mean

[04:31] <snarkyboojum> meant ;)

[04:31] <Daenyth> nice

[04:31] *** [synth] joined
[04:31] <tylercurtis> rakudo: sub play {}; play nice;

[04:31] <p6eval> rakudo 82b1b7: OUTPUT«Could not find sub &nice␤  in main program body at line 22:/tmp/mi4EXHWHLC␤»

[04:31] <pmichaud> rakudo:  for 1..20 { .say if $_ %% 4; }

[04:31] <p6eval> rakudo 82b1b7: OUTPUT«4␤8␤12␤16␤20␤»

[04:32] <tylercurtis> rakudo: sub eat () {...}; eat sandwich;

[04:32] <p6eval> rakudo 82b1b7: OUTPUT«Could not find sub &sandwich␤  in main program body at line 22:/tmp/SOeZ2Y2FZj␤»

[04:32] <lue> .oO(Everyone stand back. I'm into P6 and have just regained my interest in High Level Math™)

[04:33] *** quietfanatic joined
[04:34] <quietfanatic> Eck

[04:34] <quietfanatic> rakudo: class X {has @.things}; X.new(things => [3, 4, 5]).things.map({say $_})

[04:34] <p6eval> rakudo 82b1b7:  ( no output )

[04:34] <quietfanatic> rakudo: class X {has @.things}; X.new(things => [3, 4, 5]).things[].map({say $_})

[04:34] <pmichaud> X is an evil class name.

[04:34] <p6eval> rakudo 82b1b7:  ( no output )

[04:34] *** synth left
[04:34] <pmichaud> so is Z

[04:34] <quietfanatic> That's not the problem

[04:34] <pmichaud> oh.

[04:34] <pmichaud> (they're still evil :-)

[04:34] <quietfanatic> rakudo: class Xbox {has @.things}; Xbox.new(things => [3, 4, 5]).things[].map({say $_})

[04:34] <p6eval> rakudo 82b1b7:  ( no output )

[04:34] <quietfanatic> The problem is map doesn't work on @.attributes.

[04:34] <lue> .oO(funny how a 'box' suffix can turn something even more evil...)

[04:35] <quietfanatic> lue: :)

[04:35] <tylercurtis> rakudo: class Foo {has @.things}; Foo.new(things => [3, 4, 5]).things[].map({say $_}) # just checking

[04:35] <p6eval> rakudo 82b1b7:  ( no output )

[04:35] <quietfanatic> I pity the Foo

[04:35] <pmichaud> rakudo:  class Foo { has @.things };  Foo.new( things => [3,4,5]).things.perl.say

[04:35] <p6eval> rakudo 82b1b7: OUTPUT«[[3, 4, 5]]␤»

[04:36] <tylercurtis> rakudo: class Foo {has @.things}; Foo.new(things => [3, 4, 5]).things.WHAT.say

[04:36] <p6eval> rakudo 82b1b7: OUTPUT«Array()␤»

[04:36] <pmichaud> rakudo:  class Foo { has @.things };  Foo.new( things => [3,4,5]).things[].perl.say

[04:36] <p6eval> rakudo 82b1b7: OUTPUT«[[3, 4, 5]]␤»

[04:36] <tylercurtis> rakudo: class Foo {has @.things}; Foo.new(things => [3, 4, 5]).things.[0].say

[04:36] <p6eval> rakudo 82b1b7: OUTPUT«3 4 5␤»

[04:36] <colomon> the problem is masp is lazy

[04:36] <quietfanatic> rakudo: class Foo {has @.things}; Foo.new(things => (3, 4, 5)).things[].map({say $_})

[04:36] <p6eval> rakudo 82b1b7:  ( no output )

[04:36] <quietfanatic> Too lazy then?

[04:36] <pmichaud> rakudo:  class Foo { has @.things };  Foo.new( things => [3,4,5]).things[].map( .say ).eager

[04:36] <p6eval> rakudo 82b1b7: OUTPUT«Any()␤No candidates found to invoke for method 'map' on object of type 'Array'; available candidates have signatures:␤:(Mu : &block;; *%_)␤␤  in main program body at line 22:/tmp/j2AzdW1bDi␤»

[04:36] <colomon> rakudo: class X {has @.things}; X.new(things => [3, 4, 5]).things.map({say $_}).eager

[04:36] <pmichaud> rakudo:  class Foo { has @.things };  Foo.new( things => [3,4,5]).things[].map( {.say} ).eager

[04:37] <p6eval> rakudo 82b1b7: OUTPUT«3 4 5␤»

[04:37] <quietfanatic> rakudo: class Foo {has @.things}; .say for Foo.new(things => (3, 4, 5)).things.map({'Foo' ~ $_})

[04:37] <pmichaud> there.

[04:37] <p6eval> rakudo 82b1b7: OUTPUT«Foo3␤Foo4␤Foo5␤»

[04:37] <quietfanatic> Huh.

[04:37] <lue> rakudo: my $a = 3; say $_ # should this work ?

[04:37] <pmichaud> currently 'for' is eager in Rakudo.

[04:37] <p6eval> rakudo 82b1b7: OUTPUT«Any()␤»

[04:37] <lue> s/work/DWIM/

[04:38] <quietfanatic> Then I'm having a different problem that looks similar.

[04:40] <lue> rakudo: my $a = 3; $a; say $_

[04:40] <p6eval> rakudo 82b1b7: OUTPUT«Any()␤»

[04:40] <tylercurtis> lue: well, if you don't ask for map to be evaluated, you aren't going to get it evaluated.

[04:41] <lue> … /me looks up pronouns

[04:42] <tylercurtis> lue: if you want something to be in $_, either set it, or, even better, use given.

[04:42] <tylercurtis> rakudo: my $a = 3; given $a { .say; }

[04:42] <colomon> pmichaud: what's the status of your series overhaul?

[04:42] <p6eval> rakudo 82b1b7: OUTPUT«3␤»

[04:42] <quietfanatic> rakudo: say '1' ~ ($_ for 2..4) ~ '5'

[04:42] <p6eval> rakudo 82b1b7: OUTPUT«15␤»

[04:42] <quietfanatic> rakudo: say '1' ~ (2..4.map({$_})) ~ '5'

[04:42] <p6eval> rakudo 82b1b7: OUTPUT«12 3 45␤»

[04:42] <quietfanatic> rakudo: say '1' ~ ((2..4).map({$_})) ~ '5'

[04:42] <p6eval> rakudo 82b1b7: OUTPUT«12 3 45␤»

[04:43] <tylercurtis> rakudo: say ~(2, 3, 4)

[04:43] <p6eval> rakudo 82b1b7: OUTPUT«2 3 4␤»

[04:43] <snarkyboojum> Daenyth: your website title here (http://daenyth.github.com/) is surprisingly close to my mutteringmadman.com idea :D

[04:43] <Daenyth> :)

[04:43] <tylercurtis> quietfanatic: lists stringify with spaces between the elements.

[04:43] <pmichaud> bbl

[04:44] <quietfanatic> Yeah, that wasn't what I was testing

[04:44] <quietfanatic> Okay I think I may have isolated it.

[04:45] <colomon> does for not return values yet?

[04:45] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say (2..4).map(&s)

[04:45] <p6eval> rakudo 82b1b7:  ( no output )

[04:45] <lue> well, having to use .map is counterintuitive to me [says one who has not read the spec]

[04:45] <quietfanatic> It seems for does not return values yet.

[04:46] <quietfanatic> but

[04:46] <quietfanatic> rakudo: sub s2 ($x) { s($x) }; multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say (2..4).map(&s2)

[04:46] <p6eval> rakudo 82b1b7: OUTPUT«234␤»

[04:46] <quietfanatic> rakudo: my sub s2 ($x) { s($x) }; multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say (2..4).map(&s2)

[04:47] <p6eval> rakudo 82b1b7: OUTPUT«234␤»

[04:47] <quietfanatic> Okay, locally, the former (with .map(&s)) gives an error

[04:47] <quietfanatic> (method 'count' not found for Perl6MultiSub)

[04:47] <quietfanatic> and the latter, with .map(&s2) returns nothing, or so it seems

[04:48] <quietfanatic> rakudo: my sub s2 ($x) { s($x) }; multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say 1 ~ (2..4).map(&s2) ~ 5

[04:48] <lue> .oO(that's wizard [the error message] )

[04:48] <p6eval> rakudo 82b1b7: OUTPUT«12 3 45␤»

[04:48] *** astrojp left
[04:48] <quietfanatic> The error may be just that I have an old version

[04:49] <quietfanatic> Wait

[04:49] <quietfanatic> no, locally the former returns nothing, without error too.

[04:49] <quietfanatic> It's just the code I have that's acting weird

[04:49] <colomon> > sub s2 ($x) { s($x) }; multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say (2..4).map(&s2)

[04:49] <colomon> 234

[04:50] <colomon> that's latest locally

[04:50] <quietfanatic> Yeah, me too...

[04:50] <lue> .rnd(Cake is an interesting food to attempt consumption of near a computer)

[04:50] <quietfanatic> I mean, not latest but that's what it does

[04:51] <colomon> oh, it's map(&s) which gives the error?

[04:51] <quietfanatic> I don't get why my code is doing different things

[04:51] <quietfanatic> It's not that one-liner that gives the error, but a similar longer situation I have

[04:53] <colomon> try equiv of map({ s($_) }) instead?

[04:54] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say (2..4).map({s($_)})

[04:54] <p6eval> rakudo 31d41e: OUTPUT«234␤»

[04:54] <quietfanatic> That works with the code I have too...

[04:55] <quietfanatic> the strange thing being that if I declared a my-sub that had exactly the same contents 's($_)', it returned nothing

[04:55] <colomon> the reason approximately is that rakudo is getting confused because it doesn't know which s to dispatch to the other way/

[04:55] *** lestrrat is now known as lest_away

[04:56] *** Util joined
[04:56] <quietfanatic> Yeah, I guess

[04:56] <quietfanatic> The problem though is that these examples do not show the same behavior as what I have in my larger code.  I'll have to investigate.

[04:57] *** skids left
[04:57] *** ash_ left
[04:57] <tylercurtis> multis and map sounds scary. How does it know how many parameters to pass to the mapped multi?

[04:57] <tylercurtis> s/how does/how could/

[04:57] <quietfanatic> Oh well, I'll figure that out later.  For now I have a workaround

[04:57] <colomon> exactly

[04:58] *** lest_away is now known as lestrrat

[04:59] <quietfanatic> That's what I figured the problem was with it not finding the 'count' method

[04:59] <quietfanatic> where &sub.count tells you how many arguments it takes

[04:59] <colomon> it might should work

[04:59] <colomon> but it's definitely scary.

[05:00] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say &s.count

[05:00] <p6eval> rakudo 31d41e: OUTPUT«Method 'count' not found for invocant of class 'Perl6MultiSub'␤  in main program body at line 22:/tmp/5Y56FdtFB0␤»

[05:00] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say &s:(Int).count

[05:00] <p6eval> rakudo 31d41e: OUTPUT«Could not find sub &s:(Int)␤  in main program body at line 22:/tmp/Upya_8JMEX␤»

[05:00] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; my &s2 = multi s (Str $x) { $x }; say &s2.count

[05:01] <p6eval> rakudo 31d41e: OUTPUT«1␤»

[05:01] *** macdaddy joined
[05:01] *** macdaddy left
[05:01] <quietfanatic> I think it's unambiguous what .count should be though, because it includes optional parameters

[05:01] *** _macdaddy joined
[05:01] <quietfanatic> it should be equal to the largest .count in all its candidates.

[05:02] <quietfanatic> And .arity should be the smallest .arity

[05:02] *** snarkyboojum_ joined
[05:02] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say &s.arity

[05:02] <p6eval> rakudo 31d41e: OUTPUT«Method 'arity' not found for invocant of class 'Perl6MultiSub'␤  in main program body at line 22:/tmp/iCLjYkQl5A␤»

[05:02] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; multi s (Str $x) { $x }; say &s2.arity

[05:02] <p6eval> rakudo 31d41e: OUTPUT«Could not find sub &s2␤  in main program body at line 22:/tmp/2HvLHYYp0i␤»

[05:02] <quietfanatic> rakudo: multi s (Int $x) { ~$x }; my &s2 = multi s (Str $x) { $x }; say &s2.arity

[05:02] <p6eval> rakudo 31d41e: OUTPUT«1␤»

[05:03] *** snarkyboojum left
[05:03] *** snarkyboojum_ is now known as snarkyboojum

[05:03] <quietfanatic> I'm gonna submit that as a bug report.

[05:03] <quietfanatic> (the count/arity thing)

[05:04] <tylercurtis> rakudo: sub factorial($n, $accum?) { if $n < 2 { 1 } else { factorial($n - 1, $n * $accum); } }; say (1...3).map(&factorial);

[05:04] <p6eval> rakudo 31d41e: OUTPUT«1Use of uninitialized value in numeric context␤1␤»

[05:04] <tylercurtis> rakudo: sub factorial($n, $accum? = 1) { if $n < 2 { 1 } else { factorial($n - 1, $n * $accum); } }; say (1...3).map(&factorial);

[05:04] <p6eval> rakudo 31d41e: OUTPUT«11␤»

[05:04] <tylercurtis> rakudo: sub factorial($n, $accum? = 1) { if $n < 2 { $accum } else { factorial($n - 1, $n * $accum); } }; say (1...3).map(&factorial);

[05:05] <p6eval> rakudo 31d41e: OUTPUT«26␤»

[05:05] <tylercurtis> rakudo: sub factorial($n, $accum? = 1) { if $n < 2 { $accum } else { factorial($n - 1, $n * $accum); } }; say (^6).map(&factorial);

[05:05] <p6eval> rakudo 31d41e: OUTPUT«16120␤»

[05:06] <tylercurtis> rakudo: sub factorial($n, $accum? = 1) { say("n $n, acc $accum"; if $n < 2 { $accum } else { factorial($n - 1, $n * $accum); } }; say (^6).map(&factorial);

[05:06] <Daenyth> What sort of support is there for currying in perl6?

[05:06] <p6eval> rakudo 31d41e: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[05:06] <quietfanatic> sub s (Int $x) | (Str $x) { say $x }; say &s.arity;

[05:06] <quietfanatic> You use .assuming for currying.

[05:07] <quietfanatic> my &say3 = &say.assuming(3);  say3(4);

[05:07] <tylercurtis> Daenyth: http://perlcabal.org/syn/S06.html#Currying

[05:07] <Daenyth> <3

[05:07] <quietfanatic> rakudo: my &say3 = &say.assuming(3);  say3(4);

[05:07] <p6eval> rakudo 31d41e: OUTPUT«34␤»

[05:07] <Daenyth> nifty

[05:08] <tylercurtis> O.o '(use IO::Logging).assuming(logfile => ".log");' this is somewhere between awesome and terrifying.

[05:08] <Daenyth> :O

[05:08] <Daenyth> former

[05:09] <quietfanatic> rakudo: sub s (Int $x) | (Str $x) { say $x }; say &s.arity;

[05:09] <tylercurtis> Definitely the latter if you supply a positional parameter.

[05:09] <p6eval> rakudo 31d41e: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[05:09] <Daenyth> tylercurtis: true

[05:09] <colomon> std: sub s (Int $x) | (Str $x) { say $x }; say &s.arity

[05:09] <p6eval> std 31784: OUTPUT«ok 00:01 123m␤»

[05:09] <quietfanatic> rakudo: sub s ($x, $y?) { say $x }; say &s.arity;

[05:10] <p6eval> rakudo 31d41e: OUTPUT«1␤»

[05:10] <quietfanatic> rakudo: sub s ($x, $y?) { say $x }; say &s.count;

[05:10] <p6eval> rakudo 31d41e: OUTPUT«2␤»

[05:10] <tylercurtis> quietfanatic: iirc, Rakudo doesn't support the (Int $x) | (Str $x) part of your example.

[05:10] <Daenyth> would be nice if the evalbot had a mode to pm back the AST it got

[05:11] <quietfanatic> tylercurtis: Yeah, no multisigs.

[05:13] <tylercurtis> Daenyth: no, it would not.

[05:13] <tylercurtis> $ "viv foo.p6|wc -l"

[05:13] <tylercurtis>       47

[05:13] <tylercurtis> foo.p6 being "say 1;"

[05:13] <Daenyth> ah true  >.>

[05:13] <Daenyth> ouch

[05:13] <Daenyth> lol

[05:15] <tylercurtis> Daenyth: note that viv uses its "concise" format by default, too.

[05:15] <Daenyth> heh :(

[05:17] <sorear> the concise format could be made more concise

[05:17] <sorear> viv concise is designed mostly for hacking on viv - knowing the node types and all the various derived fields is necessary

[05:19] <sorear> an evalbot parser could probably do something more like -MO=Deparse,-p

[05:20] <cxreg> mberends: ping

[05:20] <Daenyth> that's more like what I had in mind

[05:20] <sorear> or even -MO=Deparse,-p,-P,-q,-x9

[05:23] <tylercurtis> sorear: Does viv --p6 work?

[05:27] *** jedai left
[05:27] <sorear> tylercurtis: degenerately, yes

[05:28] <sorear> it fully parses your source code, and then reassembles it with no changes

[05:28] <sorear> I'm not sure what it was ever intended to do

[05:28] <tylercurtis> sorear: all I ever seem to get from it is a blank line.

[05:28] <sorear> I probably broke it with the recent $*ORIG cleanups.  It never used to do anything useful.

[05:29] *** jedai joined
[05:29] <tylercurtis> sorear: perhaps it was intended to do eventually do something like Deparse?

[05:30] *** stepnem left
[05:30] * tylercurtis has no idea, but can't think of another reason for a --p6 option.

[05:30] *** colomon left
[05:31] <sorear> bear in mind that the first version of gimme5 was actually gimme6

[05:31] <sorear> it removed regexes and produced Pugs-compatible output

[05:31] <lue> rakudo: my @a = 1,2,3; my @b = 2,3,4; my Set @c = @a, @b; say @c

[05:31] <tylercurtis> Ah.

[05:32] <p6eval> rakudo 31d41e: OUTPUT«123234␤»

[05:32] <tylercurtis> rakudo: my @a = 1,2,3; my @b = 2,3,4; my @c is Set = @a, @b; say @c

[05:32] <p6eval> rakudo 31d41e: OUTPUT«Modifications to classes are not allowed after instantiation.␤  in 'trait_mod:<is>' at line 61:CORE.setting␤  in main program body at line 22:/tmp/J8JFELqOoL␤»

[05:32] <tylercurtis> rakudo: my @a = 1,2,3; my @b = 2,3,4; my Set $c = @a, @b; say @c

[05:32] <p6eval> rakudo 31d41e: OUTPUT«===SORRY!===␤Symbol '@c' not predeclared in <anonymous> (/tmp/s_dci7aOwC:22)␤»

[05:33] <tylercurtis> rakudo: my @a = 1,2,3; my @b = 2,3,4; my Set $c = @a, @b; say $c

[05:33] <p6eval> rakudo 31d41e: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/rFnsEUIwcM␤»

[05:33] <lue> rakudo: my Set @a = 1,2,3,2,3,4; say @a

[05:33] <p6eval> rakudo 31d41e: OUTPUT«123234␤»

[05:33] *** stepnem joined
[05:34] <tylercurtis> lue: "my Set @a" is similar to "my $a is Positional of Set"

[05:34] <lue> And I thought Set worked right (or is Set not a container of unique values?)

[05:34] <tylercurtis> lue: You're getting a list of Sets, not a Set.

[05:35] <lue> rakudo: my Set @a = 1,2,3,2,3,4; say @a.perl

[05:35] <p6eval> rakudo 31d41e: OUTPUT«[1, 2, 3, 2, 3, 4]␤»

[05:36] <lue> rakudo: my Set @a = {1,2,3,2,3,4}; say @a.perl # oh pls let {} define a Set

[05:36] <p6eval> rakudo 31d41e: OUTPUT«[{ ... }]␤»

[05:37] <sorear> rakudo: my Set $a = Set(1,2,3,2,3,4); say $a.perl

[05:37] <p6eval> rakudo 31d41e: OUTPUT«Could not find sub &Set␤  in main program body at line 22:/tmp/lyOI7N18LR␤»

[05:37] <sorear> you cannot define Set @a

[05:37] <sorear> ever

[05:37] <sorear> @a requires an object which can be indexed

[05:37] <sorear> sets are not ordered

[05:38] <sorear> unless, of course, you meant to define an array of Set

[05:38] <sorear> (which is, as tylercurtis++ pointed out, what Set @a actually means)

[05:38] <lue> ah. So I just used the wrong sigil.

[05:39] <lue> rakudo: my Set $a = 1,2,3,2,3,4; say $a

[05:39] <p6eval> rakudo 31d41e: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/DVGFuRjTZb␤»

[05:39] <lue> .oO(To The Spec!)

[05:39] <tylercurtis> lue: "my Set $a = 1;" will never type-check. You want "my Set $a .= new(1,2,3,2,3,4);"

[05:40] <snarkyboojum> rakudo: my Set $a .= new(1,3,2,4); say $a

[05:40] <p6eval> rakudo 31d41e: OUTPUT«Set()<0x83cc910>␤»

[05:40] <tylercurtis> rakudo: my Set $a .= new(1,3,2,4); say $a.perl;

[05:40] <p6eval> rakudo 31d41e: OUTPUT«Set.new(1, 3, 2, 4)␤»

[05:41] <snarkyboojum> rakudo: my Set $a .=new(1,3,2,4); say $a.^methods(:local).join(' ')

[05:41] <p6eval> rakudo 31d41e: OUTPUT«elems subset intersection equal superset keys at_key exists union new difference Bool subsetorequal values Num perl supersetorequal of␤»

[05:42] <sorear> lue: assignments don't coerce.  my Set $a = #`(whatever goes here has to already be a Set)

[05:43] <tylercurtis> sorear: not to mention that "my Set $a = 1,2,3,2,3,4" parses as "(my Set $a = 1),2,3,2,3,4".

[05:44] <tylercurtis> right? Item assignment is tighter than infix:<,>, no?

[05:44] <lue> .oO(hmm... Set isn't being very friendly :/)

[05:44] <sorear> std: my Set $a = 1,2,3,2,3,4

[05:44] <p6eval> std 31784: OUTPUT«ok 00:01 118m␤»

[05:44] <sorear> there used to be a warning for this

[05:45] <sorear> ah, no, it's only a special case in name lookup

[05:45] <sorear> std: my $x, $y;

[05:45] <p6eval> std 31784: OUTPUT«===SORRY!===␤Variable $y is not predeclared (declarators are tighter than comma, so maybe your 'my' signature needs parens?) at /tmp/jR_HqEaTjT line 1:␤------> my $x, $y⏏;␤Check failed␤FAILED 00:01 117m␤»

[05:47] <lue> rakudo: my $a = Set.new(1,2,3,2,3,4); say $a

[05:47] <p6eval> rakudo 31d41e: OUTPUT«Set()<0x84b0fb0>␤»

[05:48] <lue> I wonder, should there be a say method for Set?

[05:52] *** snarkyboojum left
[05:53] *** uniejo joined
[05:59] <szabgab> rakudo: for 1,3 ... 11 { say $_ }

[05:59] <p6eval> rakudo 31d41e: OUTPUT«1␤3␤5␤7␤9␤11␤»

[05:59] <szabgab> rakudo: for 1,3 ...^ 11 { say $_ }

[05:59] <p6eval> rakudo 31d41e: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[06:00] <szabgab> I wonder why is the latter?

[06:03] *** justatheory joined
[06:04] *** snarkyboojum joined
[06:05] <tylercurtis> Daenyth: if you want to golf that further, "print $ problem1 1000".

[06:08] *** meppel is now known as meppl

[06:15] *** justatheory left
[06:19] *** eternaleye left
[06:32] *** _macdaddy left
[06:37] <pugssvn> r31785 | moritz++ | [t/spec] test for RT #71846, and refudge a bit 

[06:39] <moritz_> szabgab: ...^ is NYI, I think

[06:41] *** [particle] left
[06:42] *** [particle] joined
[06:42] *** xinming left
[06:48] *** dalek joined
[06:48] *** sorear sets mode: +v dalek

[06:49] *** Mowah joined
[06:52] *** baest joined
[06:54] *** colomon joined
[06:59] *** sorear sets mode: +o colomon

[06:59] <sorear> hello!

[06:59] <au|irc> o/

[07:00] *** xinming joined
[07:01] *** mberends left
[07:04] <mathw> Good morning

[07:04] <sorear> Good morning mathw

[07:05] *** stepnem left
[07:05] <moritz_> \o

[07:06] <pugssvn> r31786 | moritz++ | [t/spec] unfudge a series test, colomon++ 

[07:07] *** plobsing left
[07:07] *** tylercurtis left
[07:08] *** tylercurtis joined
[07:08] *** tylercurtis left
[07:09] <sorear> au|irc: dalek ate the first batch of commits, but I'm in the middle of the refactor that will enable the regex compiler

[07:09] <au|irc> \o/

[07:09] <au|irc> so sleeping on it did help? :)

[07:09] *** daxim joined
[07:10] <sorear> Maybe

[07:10] <au|irc> Either :)

[07:10] *** stepnem joined
[07:11] <sorear> (,)

[07:13] <au|irc> (->) :)

[07:18] <mathw> (>>=)

[07:18] *** rgrau joined
[07:21] * mathw always liked the Monad operators

[07:22] <cognominal> I have trouble composing monads, that my main grief with haskell

[07:22] <au|irc> (>=##) :)

[07:22] <mathw> composing monads is quite difficult

[07:22] <mathw> although I think I'm behind on some of the latest thinking there

[07:22] *** cjk101010 joined
[07:22] <mathw> But last time I looked at it, you had to jump through hoops to design composable monads

[07:22] <mathw> and then worse hoops to actually compose them properly

[07:23] <mathw> this always seemed a weakness :(

[07:23] <sorear> I am *so* glad I wrote that testsuite last week

[07:23] <mathw> I'm seeing blog posts lately about quite effective monad transformers, but I think more than a level or so of those would probably drive you nuts

[07:23] <mathw> sorear: I'm so glad I wrote a testsuite for Form.pm along with its features. They're awesome!

[07:24] <cxreg> aaiieeee

[07:24] <cognominal> monads being the heart of handling state in haskell, this is quite a hurdle. I don't know if it is a real one or just a lack of proficiency from me.

[07:24] <cxreg> i've got a situation where sometimes 'foo' eq any($bar.^methods) is true, and sometimes false.  seemingly random.

[07:26] <mathw> cognominal: no, it's a real hurdle. You can still do cool stuff, but it hurts composability of functions which use monads.

[07:26] <cognominal> I have a "ceiling theory". Most language have some necessary feature that many people can't seem to master. A university teacher said he lose half of his class when he teach pointers in C.

[07:26] <mathw> cxreg: that's... odd. Have you checked if the return of $bar.^methods is the same between the two cases?

[07:26] <mathw> cognominal: It took me a long time to grok pointers. Then it was quite sudden and seemed very obvious.

[07:27] <cognominal> I remember pointers were difficult for me. But at that time, circa 1987,  I had only the K&R and no access to Internet or source code.

[07:28] <cognominal> no irc either :)

[07:28] <sorear> I think a lot of people would benefit from a few months spent implementing a toy toolchain

[07:28] <cxreg> mathw: it varies each time i run the program

[07:29] <sorear> cxreg: tried --hash-seed?

[07:29] <cxreg> mathw: i ran it 4 times, got 4 different results

[07:29] <cxreg> although it /seems/ to be just ordering

[07:29] <cxreg> not sure why that would affect any(

[07:29] <mathw> the ordering is likely to vary

[07:29] <mathw> Certainly, it's not promised to be the same

[07:29] <sorear> parrot --hash-seed=deadbeef /path/to/perl6.pbc program.pl

[07:29] <mathw> that shouldn't affect the way it turns into an any() though

[07:30] <mathw> cognominal: They were difficult for me largely because I could see the concept but I had no good explanation of what they were useful for.

[07:31] <mathw> cognominal: Realising what they were good for also allowed me to move on a level and write far more sophisticated software, because I suddenly had pass-by-reference and malloc() available to me

[07:32] <cxreg> the ordering definitely plays a role here

[07:33] <snarkyboojum> cxreg: code?

[07:34] <cognominal> syntax is also a hurdle when you deal with pointers to functions returning pointer to functions (like signals handler in unix). Damian Conway has a paper about how that could have been done right. I guess Perl 6 benefited from it.

[07:34] <cognominal> s/functions/function/g

[07:34] <cognominal> I don't dare to imagine with the plural...

[07:37] <mathw> Oh yes, function pointer syntax in C is hideous.

[07:37] <cxreg> rakudo: class Foo { has $.bar; has $.baz; has $.biff }; say ("biff" eq any(Foo.^methods) ?? "yay" !! "nay")

[07:37] <p6eval> rakudo 31d41e: OUTPUT«nay␤»

[07:37] <cxreg> rakudo: class Foo { has $.bar; has $.baz; has $.biff }; say ("biff" eq any(Foo.^methods) ?? "yay" !! "nay")

[07:37] <p6eval> rakudo 31d41e: OUTPUT«nay␤»

[07:37] <cxreg> rakudo: class Foo { has $.bar; has $.baz; has $.biff }; say ("biff" eq any(Foo.^methods) ?? "yay" !! "nay")

[07:37] <p6eval> rakudo 31d41e: OUTPUT«yay␤»

[07:37] <cxreg> there ya go

[07:38] <cxreg> :(

[07:39] * sorear is very glad that in Perl 6 @( @foo ) has been redefined to do something sensible

[07:40] <mathw> cxreg: I think you should file a rakudobug

[07:41] <cxreg> i agree.  my second today.

[07:41] <mathw> Yes unfortunately there are still many bugs

[07:41] <mathw> But it's good to find them

[07:45] <cxreg> i'm not actually complaining ;)

[07:45] *** zulon joined
[07:45] <mathw> \o/

[07:46] <cxreg> filed RT 76648

[07:49] <moritz_> cxreg++ # breaking stuff

[07:49] <cognominal> sorear, what it does?      @$foo still does not work in rakudo last time I checked

[07:49] *** ashleydev left
[07:50] <moritz_> but @($foo) works

[07:50] <sorear> I said @( @foo )

[07:50] <sorear> not @( $foo )

[07:51] <sorear> I don't explicitly write that, but it sometimes happens if I return an array from one function, then try to dereference it elsewhere

[07:51] <cognominal> yes that's different indeed.

[07:51] <sorear> Perl 6 does the sensible thing and ignores the redundant deref

[07:51] <sorear> Perl 5 will attempt to access the global array whose name is the decimal encoding of the number of elements in @foo

[07:51] <cxreg> assuming strict refs is off

[07:52] <sorear> even if strict refs is on, the error is caught too late

[07:52] <sorear> and it doesn't DWIM in any case

[07:52] *** PZt left
[07:54] *** PZt joined
[07:55] <dalek> niecza: e337510 | sorear++ |  (2 files):

[07:55] <dalek> niecza: Push automatic is Any down and out of the parser

[07:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e3375104ccd20791aa4cfc770e1b0fde62838d6c

[07:55] <dalek> niecza: b08dd5f | sorear++ |  (2 files):

[07:55] <dalek> niecza: Op::*, not the parser, should construct Decls

[07:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b08dd5ffd8f86f4b7361ff40d74f993fd31a61a9

[07:55] <dalek> niecza: 4da1598 | sorear++ |  (3 files):

[07:55] <dalek> niecza: Move state completely to the new model

[07:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4da1598d601f6faea0edce332308df3615c54f1b

[07:55] <dalek> niecza: 87b12f0 | sorear++ |  (3 files):

[07:55] <dalek> niecza: Move class traits to new model

[07:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/87b12f0a09b9ae4b37fa6a176f51679f6395e2af

[07:55] <dalek> niecza: 4998f99 | sorear++ |  (2 files):

[07:55] <dalek> niecza: Move methods to new model

[07:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4998f99b3cca61ad6e8535ccde5326c08723cf52

[07:55] <dalek> niecza: 0067ab2 | sorear++ |  (2 files):

[07:55] <dalek> niecza: Move YOU_ARE_HERE & remove vestiges of !decls hack.

[07:55] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0067ab266ecbae41439ece75a9c7ce3d3096f457

[08:02] *** mberends joined
[08:03] <cxreg> is there some way of checking if a variable is declared in your current scope?

[08:03] <cxreg> might seem like an odd question, but it's relevant to something that's being run by 'eval slurp'

[08:04] <moritz_> eval '$x'; if $! { say '$x is not defined' }

[08:05] <mberends> rakudo: my $a; my $b=1; say defined($a); say defined($b)

[08:05] <p6eval> rakudo 31d41e: OUTPUT«0␤1␤»

[08:05] <mberends> (morning cxreg moritz_)

[08:05] <moritz_> I should have said s/defined/declared/

[08:05] <cxreg> hm

[08:06] <cxreg> compilation fails, on the line i try to use the as-it-happens-undeclared variable

[08:06] <cxreg> i guess it's gotta be in eval

[08:07] <moritz_> rakudo: my $x; eval 'say "in eval"; eval q[$x]; say $! ?? "not declared" !! "declared";'

[08:07] <p6eval> rakudo 31d41e: OUTPUT«in eval␤declared␤»

[08:07] <moritz_> eval 'say "in eval"; eval q[$x]; say $! ?? "not declared" !! "declared";'

[08:07] <moritz_> rakudo: eval 'say "in eval"; eval q[$x]; say $! ?? "not declared" !! "declared";'

[08:07] <p6eval> rakudo 31d41e: OUTPUT«in eval␤not declared␤»

[08:07] <moritz_> seems to work fine

[08:08] <cxreg> mberends: hiya.  have a number of commits for MiniDBI

[08:08] <mberends> \o/

[08:08] <mberends> jnthn++ # fixed Zavolaj!

[08:08] <cxreg> indeed!

[08:12] <cxreg> mberends: one odd thing i saw and couldn't yet solve, if MiniDBD::mysql cannot connect, you get a "Null PMC access in isa_pmc"

[08:13] <szabgab> is   for lines 'file' -> $line {}  lazy or does it read all the file in memory?

[08:13] <szabgab> or rather "will it be lazy?"

[08:14] <mberends> cxreg: ouch. It ought to be possible to catch that and handle it better. I guess those are the sort of code paths that are tested less often. I'll look into it.

[08:14] *** colomon left
[08:14] *** colomon joined
[08:14] <cxreg> mberends: i also made a number of improvements to 99-common.pl6

[08:14] <cxreg> mberends: i can push to my fork first if you'd like to code review

[08:15] <mberends> cxreg: just go ahead and commit. I'm busy with $work today, and I trust the anarchy :)

[08:15] *** colomon left
[08:15] <cxreg> oke doke

[08:16] <cxreg> i got all common tests passing in both mysql and pg, so i'm happy

[08:16] <mberends> w00t!

[08:16] * mberends is happier

[08:16] *** colomon joined
[08:16] <moritz_> hey, git makes it really easy to revert commits if something's wrong :-)

[08:16] <cxreg> true

[08:16] <cxreg> git++

[08:17] *** colomon left
[08:17] <moritz_> I think there's a high emotional barrier against reverting stuff, but IMHO it's ok to break that barrier, and just talk to the committer

[08:18] <cxreg> ok, pushing

[08:18] <szabgab> moritz_: is   for lines 'file' -> $line {}  lazy ?

[08:19] <szabgab> or I need to call open and then use  $fh.lines to get lazyness?

[08:19] <moritz_> szabgab: it should. If not, it's a bug

[08:20] <szabgab> I have no idea how to test that, but for now it is not that important :)

[08:20] <moritz_> just take a huge file, and abort after the first line

[08:20] <moritz_> if it's much slower than with a short file, it's not lazy

[08:21] <sorear> szabgab: it's lazy - try for lines $*IN -> $line { say $line }

[08:21] <moritz_> seems lazy, yes

[08:21] <sorear> it will, however, store copies of all lines read

[08:22] <moritz_> time ./perl6 -e 'for lines("README") { .say; last }'

[08:22] <moritz_> =head1 Rakudo Perl 6

[08:22] <moritz_> real    0m1.164s

[08:22] <moritz_> szabgab: it should not

[08:22] <moritz_> erm, meant sorear, sorry

[08:22] <moritz_> cat README README README README README README > big

[08:22] <moritz_> time ./perl6 -e 'for lines("big") { .say; last }'

[08:22] <moritz_> =head1 Rakudo Perl 6

[08:22] <moritz_> real    0m1.181s

[08:23] <sorear> moritz_: O(1) space lazy list processing is NYI in Parrot

[08:23] <moritz_> sorear: afaict pmichaud implemented it in rakudo on top of parrot

[08:24] <moritz_> except that it might leak :(

[08:24] <moritz_> sorear: at least that was one of the explicit design goals of the 'list' branch

[08:24] <sorear> Yes, 'list' is a much better foundation for moving forward.

[08:25] <szabgab> what is interesting with the screencasts is the the number of viewers drop a lot for the second part

[08:25] <sorear> screencasts?

[08:25] <moritz_> :(

[08:25] <szabgab> right now it is 805 for the first part and 176 for the second

[08:25] <moritz_> sorear: you should really follow planetsix :-)

[08:25] <szabgab> and 18 for the 3rd

[08:26] <szabgab> but the first one got some 500 hits on the first day

[08:27] <szabgab> I wish I understood why is that drop for the second part

[08:27] <moritz_> szabgab: do you have a small page linking to all the screen casts?

[08:27] <szabgab> http://szabgab.com/perl6.html

[08:28] <moritz_> szabgab: care to add an id="screencasts" to the <h2>?

[08:28] <szabgab> no problem but why?

[08:29] * moritz_ wants to reddit it

[08:29] <szabgab> and why does the id help in that?

[08:30] <moritz_> because I can link to the correct section, helping with the low attention span of the audience :-)

[08:30] <szabgab> try now

[08:30] <moritz_> thanks, szabgab++

[08:31] * sorear wonders if anyone here has noticed the niecza termcast feed

[08:31] <dalek> niecza: a5170a7 | sorear++ |  (3 files):

[08:31] <dalek> niecza: Implement the REGEX COMPILER!

[08:31] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a5170a750ae92988a59c9618006dbaeae0568843

[08:31] <moritz_> sorear: if you have a niecza blog, please contact [Coke] about adding it to the planetsix feed

[08:31] <mberends> sorear: wow!

[08:32] <sorear> right now it's capable of handling any regex matching [\w\*?]*

[08:32] <szabgab> I did not know you can link to an id :)

[08:32] <moritz_> http://www.reddit.com/r/programming/comments/csdvo/perl_6_screencasts_an_easy_way_to_get_started/

[08:33] <moritz_> szabgab: with #id

[08:33] <szabgab> moritz_++ thanks

[08:33] <sorear> ok, screencasts are not *quite* what I thought they were

[08:33] <szabgab> on two terms :)

[08:33] <szabgab> sorear: what were you expecting?

[08:34] <sorear> szabgab: not a video file

[08:35] <szabgab> moritz_: oh in r/programming :)

[08:35] <moritz_> szabgab: yes; I try to break out the echo chamber

[08:35] <moritz_> szabgab: in the end, somebody typically also posts to r/perl, but it's on the ironman feed anyway

[08:35] <daxim> we'll arrange a screen -x just for you, sorear

[08:35] <szabgab> so I go back to prepare the 4th entry

[08:37] <moritz_> szabgab++

[08:38] <szabgab> the padre screencast was averaging 15.6 view / day

[08:38] <szabgab> I wonder how will these do

[08:39] * moritz_ wonders if rakudo.org can stand a slashdot citation, once R* is released

[08:39] *** xabbu42 left
[08:41] <frettled> If it's running Apache, enabling mod_cache with mod_mem_cache ought to help a lot for that eventuality.

[08:43] <moritz_> otoh my stupid blosxom blog also handled ~10k visitors in 4 hours, which is about what the advent calendar got when slashdotted

[08:44] *** dakkar joined
[08:44] <szabgab> I was wondering if there is any real world use for R* ?

[08:44] <frettled> szabgab: it got ingy excited :)

[08:45] <szabgab> I mean the operator

[08:45] <frettled> oh

[08:45] <szabgab> rakudo: 2 r* 4

[08:45] <szabgab> rakudo: 2 R* 4

[08:45] <p6eval> rakudo 31d41e: OUTPUT«===SORRY!===␤Confused at line 22, near "2 r* 4"␤»

[08:45] <p6eval> rakudo 31d41e:  ( no output )

[08:45] <szabgab> rakudo: say 2 R* 4

[08:45] <au|irc> sorear: congrats :)

[08:45] <p6eval> rakudo 31d41e: OUTPUT«8␤»

[08:45] <au|irc> sub _rxopt($C) { _rxdisj( _rxone($C), $rxnone ); }

[08:45] <au|irc> # correct?

[08:46] <moritz_> szabgab: not really. Unless you overload it to work with matrices, which are not commutative

[08:46] *** thebird joined
[08:47] <frettled> Then the remaining use is to confuse people.  \o/

[08:47] <szabgab> so now someone needs to create a phylosophy around R*  :)

[08:50] <moritz_> well, it's just an abbreviation

[08:50] <moritz_> which happens to be an infix operator

[08:54] <au|irc> sorear: oh, nvm, I misread the code. :)

[08:56] <perigrin> phenny: tell masak his post on the 10 year history of p6 has proven invaluable. I rattled most of it off at someone today in 10min.

[08:56] <phenny> perigrin: I'll pass that on when masak is around.

[08:56] <sorear> au|irc: msread? that ought to work

[08:56] <sorear> (also, my network is acting up)^H.)

[08:57] <au|irc> well, implemented that way 'abc' won't match /abc/

[08:57] <au|irc> er, /ab?c/

[08:57] <au|irc> only 'ac' matches

[08:59] <sorear> oh, right, oops

[08:59] *** Raynes joined
[08:59] <sorear> that rxopt  is <?> | <!>

[08:59] <au|irc> yeah

[09:00] *** timbunce left
[09:04] *** au|irc is now known as au|afk|dinner

[09:06] <cxreg> perigrin: indeed; that post has done a lot to stir people up

[09:09] *** mj41 joined
[09:12] *** [bjoern] left
[09:12] <perigrin> cxreg: yeah but I have a vested interest. I've been manning the TPF booth at OSCON this week.

[09:21] <Juerd> .oO( one week )

[09:21] <Juerd> .oO( * )

[09:36] *** snarkyboojum left
[09:39] <sorear> std: { our $x; }; { our $x; }

[09:39] <p6eval> std 31786: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/05HHY2YfWZ line 1:␤------> { our $x⏏; }; { our $x; }␤ok 00:01 115m␤»

[09:39] <sorear> hmm.  I don't have commoning

[09:42] *** redicaps joined
[09:42] *** redicaps left
[09:44] *** pmurias joined
[09:45] <pmurias> where can i get the list of options i can pass to Configure (more specificaly how do i enable MULTIPLICITY?)

[09:45] <moritz_> which project are you talking about?

[09:45] <sorear> ./Configure -des -DMULTIPLICITY

[09:46] <sorear> ./Configure -h

[09:46] <sorear> moritz_: perl 5

[09:47] *** cognominal left
[09:48] <sorear> INSTALL

[09:48] <sorear> Configure's own sources

[09:48] <sorear> man Config

[09:48] <moritz_> NO

[09:48] <moritz_> Configure is generated code

[09:48] <moritz_> you don't want to read that

[09:48] *** cognominal joined
[09:49] <moritz_> it, like, hurts :-)

[09:49] <sorear> I /have/ read it, and it's where most of what I know about the configure options comes from

[09:54] <pmurias> moritz_: re which project, meant to ask on #perl

[09:55] <moritz_> oh :-)

[09:56] <moritz_> szabgab: fwiw, somebody did submit your first p6 screencast to reddit - which might explain the relatively high visitor stats

[09:57] * sorear out.

[09:57] <pmurias> moritz_: but i want to know to build a perl with multiplicity to work on packaging up smop's p5 interop so it's slightly OT

[09:57] <moritz_> where O stands for "on" and not "off" :-)

[10:05] <moritz_> rakudo: my $x = -2; say ($x max 0) min 10

[10:05] <p6eval> rakudo 925a9b: OUTPUT«0␤»

[10:05] <moritz_> rakudo: my $x = 12; say ($x max 0) min 10

[10:05] <p6eval> rakudo 925a9b: OUTPUT«10␤»

[10:05] <moritz_> rakudo: my $x = 5; say ($x max 0) min 10

[10:05] *** lestrrat is now known as lest_away

[10:05] <p6eval> rakudo 925a9b: OUTPUT«5␤»

[10:06] *** smash__ joined
[10:06] *** Schwern joined
[10:06] <smash__> hello everyone

[10:06] <moritz_> rakudo: my $x = 5; say $x max 0 min 10

[10:06] <moritz_> hi smash__ 

[10:06] <p6eval> rakudo 925a9b: OUTPUT«5␤»

[10:06] <szabgab> moritz_: yeah, and nice comments too :)

[10:06] <moritz_> well, it's reddit. You get 20 upvotes and 5 snarky comments

[10:08] *** xabbu42 joined
[10:09] <moritz_> rakudo: my $x = (1, 2, 3); say :$x.perl

[10:09] <p6eval> rakudo 925a9b: OUTPUT«"x" => (1, 2, 3)␤»

[10:09] <moritz_> TheDamian++

[10:14] *** tadzik joined
[10:16] <moritz_> rakudo: my %h = "a=b\nc=d".split("\n")>>.split('='); say %h.perl

[10:16] <p6eval> rakudo 925a9b: OUTPUT«{"a" => "b", "c" => "d"}␤»

[10:16] <moritz_> rakudo: my %h = "a=b\nc=d\n".split("\n")>>.split('='); say %h.perl

[10:16] <p6eval> rakudo 925a9b: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 4600:CORE.setting␤  in main program body at line 22:/tmp/FrsCKl37Rs␤»

[10:16] <moritz_> rakudo: my %h = "a=b\nc=d\n".split("\n")>>.split('=').flat; say %h.perl

[10:16] <p6eval> rakudo 925a9b: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 4600:CORE.setting␤  in main program body at line 22:/tmp/ZwuqIKq0Od␤»

[10:17] <moritz_> rakudo: my %h = "a=b\nc=d\n".split("\n")>>.grep(*).split('='); say %h.perl

[10:17] <p6eval> rakudo 925a9b: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 4600:CORE.setting␤  in main program body at line 22:/tmp/AD5JVD6yV0␤»

[10:17] <moritz_> rakudo: my %h = "a=b\nc=d\n".split("\n")>>.grep({$_}).split('='); say %h.perl

[10:17] <p6eval> rakudo 925a9b: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 4600:CORE.setting␤  in main program body at line 22:/tmp/lZtGCAYIZi␤»

[10:18] <moritz_> rakudo: my %h = "a=b\nc=d\n".split("\n")>>.grep(*.chars).split('='); say %h.perl

[10:18] <p6eval> rakudo 925a9b: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 4600:CORE.setting␤  in main program body at line 22:/tmp/6SPg1oTZu8␤»

[10:18] <moritz_> rakudo: "a=b\nc=d\n".split("\n")>>.grep(*.chars).split('=').perl.say

[10:18] <p6eval> rakudo 925a9b: OUTPUT«("a", "b c", "d")␤»

[10:19] <moritz_> rakudo: "a=b\nc=d\n".split("\n")>>.split('=').perl.say

[10:19] <p6eval> rakudo 925a9b: OUTPUT«(("a", "b"), ("c", "d"), (""))␤»

[10:19] *** zulon left
[10:19] <moritz_> rakudo: "a=b\nc=d\n".split("\n")>>.split('=').grep(* == 2).perl.say

[10:19] <p6eval> rakudo 925a9b: OUTPUT«()␤»

[10:20] *** snarkyboojum joined
[10:22] *** masak joined
[10:23] <masak> o/

[10:23] <phenny> masak: 21 Jul 20:48Z <moritz_> tell masak tadzik++ noticed a lack of license in proto... care to add the AL2?

[10:23] <phenny> masak: 21 Jul 21:55Z <Kodi> tell masak I implemented immutability for DateTimes and edited the spec and tests appropriately, and then, since I was on a roll, I did the same for leap-second validation. All that remains is some cleanup, and then I'll have a gist for you to look at.

[10:23] <phenny> masak: 08:56Z <perigrin> tell masak his post on the 10 year history of p6 has proven invaluable. I rattled most of it off at someone today in 10min.

[10:23] *** snarkyboojum left
[10:23] <masak> perigrin: yay

[10:23] <masak> Kodi: you rock.

[10:24] <masak> moritz_: sure, will do.

[10:24] <masak> ok, so I have a blog post draft for you to look at.

[10:24] <masak> hold on, I'll post it as a gist.

[10:26] <masak> http://gist.github.com/485816 -- comments are encouraged. :)

[10:27] <tadzik> szabgab++ # screencast are awesome

[10:27] <masak> aye, szabgab++

[10:28] <tadzik> method attack-with-camelia  { say "flap flap RAWWR!" }

[10:28] <tadzik> oh wow

[10:29] <masak> :)

[10:31] *** snarkyboojum joined
[10:32] *** xabbu42 left
[10:33] <masak> oh, and in thinking about my Parsea talk for YAPC::EU, I now have a new sekkrit project. it's not too ambitious, but it's a really nice example of something I think we'll see a lot of. come to the talk and be the first to see it :)

[10:43] *** zulon joined
[10:44] <masak> updated http://gist.github.com/485816 -- check out the example at the bottom :)

[10:45] * masak backlogs

[10:49] <tadzik> 1, 2, 4 ... *                               # powers of two

[10:49] <tadzik> serious question, how does rakudo know that?

[10:50] <masak> tadzik: it detects arithmetic and geometric sequences through a few simple rules.

[10:50] <masak> tadzik: S03 has the details.

[10:50] <tadzik> I'll take a look, thanks

[10:51] <TiMBuS> im writing a 'tell' module for my perl6 irc bot but I keep running into regex bugs. anyone know something better than this: /tell <.ws> $<name>=[.+?] <.ws> $<msg>=[.+]/

[10:54] <TiMBuS> thats the best i can do without bugs, but its a bit simple..

[10:56] <masak> TiMBuS: please be more specific.

[10:57] <TiMBuS> i guess i'll narrow it down a little: i want to put <.ws>+ in there in place of the <.ws>'s but it freezes.

[10:57] <masak> I haven't experienced any bugs in that area.

[10:57] <masak> TiMBuS: it should be just <.ws>

[10:57] <masak> TiMBuS: <.ws>+ does freeze, but it's not a bug.

[10:57] <TiMBuS> oh?

[10:57] <masak> it's just a think on your part.

[10:57] <masak> if you look up what <.ws> does, and what + does, and then think about it... :)

[10:57] <masak> s/a think/a thinko/

[10:58] <TiMBuS> i didn't know <ws> matched more than one.

[11:00] <masak> in English, "whitespace" is a mass noun.

[11:00] <masak> it can refer to any number of whitespace characters.

[11:00] <masak> there should probably be a compiler error on <.ws>+ eventually, though.

[11:00] <TiMBuS> that would be handy

[11:01] <TiMBuS> mayybe its because I was using <-ws> and it only matches one character

[11:01] <TiMBuS> the wrong character :/

[11:02] <TiMBuS> rakudo: my $a = "test"~~ /<-ws>/; $a.say

[11:02] <p6eval> rakudo 925a9b: OUTPUT«e␤»

[11:06] <masak> I have a difficult time thinking what <-ws> even means...

[11:06] <masak> TiMBuS: I'd still advise you to look up the exact semantics of <ws>

[11:06] <masak> it's a bit magical.

[11:10] <TiMBuS> yeah i did that after you said to :), and I knew -ws doesnt match the first letter because of the 'matching the start of a string' effect it has

[11:10] <masak> ooh, that's why. yes, of course. TiMBuS++

[11:11] <TiMBuS> well, matching the space "inbetween" the letter and the start of the string.. its still a bit complicated

[11:12] *** meppel joined
[11:12] <cxreg>     say [+] (1..6).pick(3, :replace); # 3d6  <- cute

[11:13] *** colomon joined
[11:15] <colomon> o/

[11:16] *** meppl left
[11:17] <dalek> niecza: 3bf633b | sorear++ |  (3 files):

[11:17] <dalek> niecza: Implement package declarations

[11:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/3bf633bee8a17838c5fc614c61e078f487bf654f

[11:17] <dalek> niecza: d4c0960 | sorear++ |  (3 files):

[11:17] <dalek> niecza: Implement "our" variables

[11:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d4c096023e4a2444d14aec01edcc17c5be817c54

[11:17] <dalek> niecza: 260f408 | sorear++ |  (4 files):

[11:17] <dalek> niecza: Implement $Foo::x referencing syntax

[11:17] <dalek> niecza: review: http://github.com/sorear/niecza/commit/260f40891f8471dc0bde51868ba44ad6ff53964b

[11:17] <masak> cxreg: catering to the role playing people out there. :)

[11:17] <tadzik> :)

[11:17] <tadzik> related to Perl6 MMORPG? :)

[11:18] *** cogno joined
[11:18] <masak> everything is related to Perl 6 MMORPG :)

[11:18] <cxreg> .classify is a new one to me, that's interesting

[11:18] <tadzik> masak: where are you going to publish this?

[11:18] <masak> tadzik: before you asked, I was thinking use.perl.org

[11:19] <masak> tadzik: but now I'm thinking I might make a special HTML page with a bit better formatting and syntax highlighting.

[11:19] <cxreg> use.perl6.org :D

[11:19] <masak> just a static page for this one :)

[11:19] <colomon> only gurps players want 3d6 like that.

[11:19] *** snarkyboojum left
[11:19] <masak> colomon: I'm sorry?

[11:19] * tadzik prefers d20

[11:20] <masak> but I have had a whole bunch of ideas for a blog engine for myself in the past few days.

[11:20] <colomon> gurps system is based on rolling 3d6 for everything.

[11:21] *** ab5tract left
[11:21] *** cogno left
[11:21] <colomon> for D&D stats, we'd have done something like 4d6 drop the lowest

[11:21] <masak> colomon: should I perhaps choose something other than 3d6?

[11:21] <masak> ok.

[11:22] * masak changes it

[11:22] <tadzik> :)

[11:22] <colomon> trying to think how to make a slick one-liner for that.  :)

[11:22] <masak> ooh, "drop the lowest", now I see what you mean.

[11:22] <cxreg> masak: so, i previously read that sort memoizes

[11:22] <tadzik> one day I'll mistake ~= with =~ :/ Any better thing for adding something to a string?

[11:23] <cxreg> is there some way to do cache control?

[11:23] <masak> colomon: pick four, sort descending, .[^3]

[11:23] <colomon> masak: brill!

[11:23] <masak> cxreg: what do you mean by cache control?

[11:23] <cxreg> masak: what if you dont want to or can't afford to cache the computed value for each element

[11:24] <masak> tadzik: you could always write it out :) $a = $a ~ "foo"

[11:24] <tadzik> :)

[11:24] <masak> cxreg: then probably roll your own.

[11:24] <cxreg> masak: maybe unlikely but definitely possible

[11:24] <cxreg> masak: i guess i dont grok which syntax incurs the magic memoize

[11:25] <cxreg> just the star version?

[11:25] <masak> cxreg: any unary code object.

[11:25] <masak> hm, and nullary.

[11:25] <cxreg> ok

[11:27] <colomon> masak: btw, left a terrific one-line sitting in my repl from when I was rocking my boy late in the night, but my system rebooted while my wife was rocking him.  :(

[11:27] * moritz_ has a nice idea for a Perl 6 module: produce Roman numerals

[11:27] <masak> colomon: do you remember it?

[11:27] <colomon> more or less

[11:27] <colomon> I think

[11:27] <cxreg> moritz_: with ... overloading? :)

[11:28] <masak> colomon, moritz_: do you have any suggestions for improvements of http://gist.github.com/485816 -- how to make it shine?

[11:28] <moritz_> cxreg: NOOOO

[11:28] <moritz_> masak: I'll take a look

[11:28] <masak> \o/

[11:29] <cxreg> has damian produced any godawful perl 6 monstrosities yet? :)

[11:29] <moritz_> sure

[11:29] <moritz_> the IO::Prompter thing

[11:29] <masak> cxreg: he's written IO::Prompter, which looks way cool.

[11:29] <masak> moritz_: I swear, we would make a fun twin act! :P

[11:30] *** meppel is now known as meppl

[11:31] <colomon> rakudo: say ((257, * div 2 ... 1) Z% (2 xx *)).perl

[11:31] <masak> [Coke]: when's the release today? I'm pondering whether to spend time on enums or not.

[11:31] <moritz_> masak: we'd just have to work on the looks :-)

[11:31] <p6eval> rakudo 925a9b: OUTPUT«(1, 0, 0, 0, 0, 0, 0, 0, 1)␤»

[11:31] <TiMBuS> tadzik: sub infix:<`=> ($a is rw, $b){$a~=$b}

[11:31] <TiMBuS> :p

[11:31] <colomon> rakudo: say ((254, * div 2 ... 1) Z% (2 xx *)).perl

[11:31] <tadzik> TiMBuS :)

[11:31] <p6eval> rakudo 925a9b: OUTPUT«(0, 1, 1, 1, 1, 1, 1, 1)␤»

[11:31] <masak> colomon: neat.

[11:32] <moritz_> rakudo: .say for 'Camelia', *.chop ... ''

[11:32] <p6eval> rakudo 925a9b: OUTPUT«Camelia␤Cameli␤Camel␤Came␤Cam␤Ca␤C␤␤»

[11:32] <colomon> that's just the warm up.  :)

[11:32] <colomon> sweet!

[11:33] <cxreg> you guys are sick

[11:33] <moritz_> masak: I likes it. I don't know what to contribute

[11:34] <colomon> rakudo: say (((254, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *)).perl

[11:34] <p6eval> rakudo 925a9b: OUTPUT«(0/1, 1/9, 1/81, 1/6561, 1/43046721, 5.39659527735429e-16, 2.91232405875626e-31, 8.48163142321055e-62)␤»

[11:34] <masak> moritz_: ok. I'll let it sit there for a few hours, and then I'll publish.

[11:34] <masak> anyone who thinks of more example, please get in touch :)

[11:35] <colomon> rakudo: say (((19, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *)).perl

[11:35] <p6eval> rakudo 925a9b: OUTPUT«(1/3, 1/9, 0/1, 0/1, 1/43046721)␤»

[11:35] <cxreg> the X operator needs a 'where', like in SQL

[11:35] <masak> after reading the p6l thread, I now realize that I don't give a damn about character ranges.

[11:35] <masak> nom &

[11:35] <colomon> rakudo: say( [+] (((19, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *))).perl

[11:36] *** masak left
[11:36] <p6eval> rakudo 925a9b: OUTPUT«0.444444467675018␤»

[11:36] <moritz_> masak: btw I'm working on a "common idioms translated to Perl 6" post

[11:36] <Juerd> moritz_: Great!

[11:36] <colomon> rakudo: say (1/3) ** 19

[11:36] <p6eval> rakudo 925a9b: OUTPUT«8.60391597237732e-10␤»

[11:37] * Juerd removes that from his to do list :)

[11:37] <cxreg> moritz_: i thought most perl 5 idioms were huffman encoded to an operator

[11:37] <colomon> hmmmm :\

[11:37] <Juerd> cxreg: Yes. Hello World is now just *;

[11:37] <Juerd> I know it isn't, but it should be! ;)

[11:38] <Juerd> rakudo: *

[11:38] <p6eval> rakudo 925a9b:  ( no output )

[11:38] <cxreg> heh

[11:38] <colomon> masak: $a cmp $b is not "lexicographic ordering"

[11:38] <moritz_> http://nopaste.snit.ch/22204 # it's what I have now

[11:38] <TiMBuS> imo a bare *; should be a hq9+ repl

[11:39] <TiMBuS> just so nobody makes one in it D:

[11:39] <Juerd> I wonder if from within P6 one can make * do something like this.

[11:39] <moritz_> are we starting the "how many distinct meanings can you give a single character" game again?

[11:39] <Juerd> moritz_: No, the "Which operator will be the hello-world-op?"

[11:39] <moritz_> Juerd: sub term:<*> { say "hello, world" }; # NYI, of course

[11:40] <Juerd> moritz_: How about a two-column layout with P5 left and P6 right?

[11:40] <tadzik> and python, just to point them with a finger and laugh :>

[11:41] <moritz_> Juerd: maybe. I plan to explain them a bit in the text that follows, don't know if they are needed then

[11:43] <Juerd> moritz_: Without another language, it's not really a translation :)

[11:43] <Juerd> And the improvement doesn't show

[11:43] <moritz_> Juerd: point taken. I should either compare, or change the title

[11:48] <pmurias> don't we have a nicer way to create a required attribute?

[11:51] <moritz_> we have ways to enforce its presence in a constructor

[11:53] <tadzik> rakudo: say 'ok' if "foo~ ~~ / \S+ /

[11:53] <p6eval> rakudo 925a9b: OUTPUT«===SORRY!===␤Unrecognized backslash sequence: '\S' at line 22, near "+ /"␤»

[11:53] <tadzik> isn't it 'a non-whitespace character?'

[11:53] *** dalek left
[11:53] <moritz_> you need to close your quote

[11:53] <tadzik> oh

[11:54] <tadzik> right, my bad

[11:54] <moritz_> rakudo: say 'ok' if "foo@ ~~ / \S+ /

[11:54] <p6eval> rakudo 925a9b: OUTPUT«===SORRY!===␤Unrecognized backslash sequence: '\S' at line 22, near "+ /"␤»

[11:54] <moritz_> rakudo: say 'ok' if "foo" ~~ / \S+ /

[11:55] <p6eval> rakudo 925a9b: OUTPUT«ok␤»

[11:55] <moritz_> rakudo: say 'ok' if "foo" ~~ / \S+ /; say $/

[11:55] <p6eval> rakudo 925a9b: OUTPUT«ok␤foo␤»

[11:57] <pmurias> moritz_: you mean if i write my own constructor i can enforce the presense of the attribute

[11:57] <pmurias> moritz_: but writing constructors is clumsy

[11:57] *** dalek joined
[11:57] <moritz_> right

[11:58] <moritz_> method new(*%h {:$required! }) { nextsame }

[11:58] *** Util left
[11:59] <pmurias> ugly

[11:59] *** Util joined
[11:59] <moritz_> aye

[11:59] *** envi^home joined
[12:00] *** Kodi joined
[12:00] <pmurias> would has Int:D $foo work?

[12:00] <moritz_> or method new(:$required, *%) { nextsame } # but still ugly

[12:00] *** au|afk|dinner is now known as au|irc

[12:00] <moritz_> pmurias: it would, but it would produce a quite curious error message

[12:00] <tadzik> The only thing worse than a typo in the code is a typo in the tests

[12:00] <Kodi> moritz_: http://rosettacode.org/wiki/Roman_numerals#Perl_6

[12:01] <moritz_> Kodi: nice. Somebody should wrap it up in a module.

[12:01] *** rml_ joined
[12:01] <pmurias> moritz_: that's up to the compiler

[12:01] <moritz_> is there a license for code on rosettacode?

[12:02] <tadzik> pmurias: how about has $.param = die "param is required"?

[12:02] <Kodi> moritz_: http://rosettacode.org/wiki/Rosetta_Code:Copyrights

[12:02] <au|irc> moritz_: GFDL 1.2

[12:02] <moritz_> pmurias: I'd be surprised to get a better error message than "type check failed for attribute 'foo', expected Int:D, got: Int:U"

[12:02] *** masonkramer left
[12:02] <moritz_> huh. GFDL for code... :-)

[12:02] <Kodi> moritz_: Yeah. That was a mistake, really.

[12:02] *** masonkramer joined
[12:03] *** azert0x joined
[12:03] <Kodi> moritz_: But I wrote the code, so I could release it under a different license, too.

[12:04] <moritz_> Kodi: that would be cool

[12:04] <moritz_> Kodi: just stuff it into a Roman.pm, and put an 'is export' on the sub

[12:04] <colomon> masak: leg is lexicographic ordering

[12:05] <colomon> rakudo: say( [*] (((19, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *))).perl

[12:05] <p6eval> rakudo 925a9b: OUTPUT«0␤»

[12:05] <colomon> dang it, how did I make it work last night?!

[12:06] <colomon> rakudo: say( [*] (((19, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:06] <p6eval> rakudo 925a9b: OUTPUT«8.60391597237732e-10␤»

[12:06] <colomon> rakudo: say (1/3)**19

[12:07] <p6eval> rakudo 925a9b: OUTPUT«8.60391597237732e-10␤»

[12:07] <colomon> bingo

[12:07] <moritz_> what are you trying to achieve? power series?

[12:07] <moritz_> btw alternating signs are easily created with (1, -1) xx *

[12:08] <colomon> it's a (psuedo) efficient way to raise a number to an Int power by repeated multiplication

[12:08] <colomon> rakudo: say( [*] (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:08] <moritz_> ah, horner schema

[12:08] <p6eval> rakudo 925a9b: OUTPUT«0.00411522633744856␤»

[12:08] <colomon> except that should be a float.  :\

[12:09] <colomon> s/float/Rat/

[12:09] <moritz_> rakudo: say  [+] ((1, -1) xx *) Z* (1, 3 ... 7).map(* ** 2 / [*] 1..*)

[12:09] <p6eval> rakudo 925a9b:  ( no output )

[12:10] *** lest_away is now known as lestrrat

[12:10] <moritz_> rakudo: say  [+] ((1, -1) xx *) Z* (1, 3 ... 7).map({$_ ** 2 / [*] 1..$_})

[12:10] <colomon> moritz_: if you're trying to get sine, you can't use * twice like that

[12:10] <p6eval> rakudo 925a9b: OUTPUT«-0.301388888888889␤»

[12:10] <[Coke]> oooh, I found out how GE is categorizing "perl6.org". - shareware/freeware.

[12:11] <moritz_> colomon: aye, just noticed

[12:11] <[Coke]> (make of that what you will)

[12:11] * colomon made the same mistake yesterday.  :)

[12:11] <moritz_> rakudo: say sin(1)

[12:11] <p6eval> rakudo 925a9b: OUTPUT«0.841470984807897␤»

[12:11] <moritz_> [Coke]: it is "freeware", at some level :-)

[12:12] <moritz_> rakudo: say  [+] ((1, -1) xx *) Z* (1, 3 ... 7).map({2** $_ / [*] 1..$_})

[12:12] <moritz_> rakudo: say sin(2)

[12:12] <p6eval> rakudo 925a9b: OUTPUT«0.907936507936508␤»

[12:12] <p6eval> rakudo 925a9b: OUTPUT«0.909297426825682␤»

[12:12] <moritz_> much better

[12:12] <cxreg> did you guys ever see the movie Pi?

[12:12] <cxreg> i think that's where this is headed

[12:12] *** xabbu42 joined
[12:13] <moritz_> not me

[12:13] <moritz_> 4 * arctan(1) is headed at pi :-)

[12:13] <cxreg> heh

[12:13] <colomon> Pi!!

[12:13] <colomon> that is one whacked out movie

[12:14] <tadzik> rakudo: say 2 * atan(Inf)

[12:14] <p6eval> rakudo 925a9b: OUTPUT«3.14159265358979␤»

[12:14] <moritz_> rakudo: say atan(Inf) - 2 * atan(0)

[12:14] <p6eval> rakudo 925a9b: OUTPUT«1.5707963267949␤»

[12:15] <colomon> masak: also, sorting students by number by grade is going to be confusing to Americans, who mostly have letter grades.  maybe sort students by age instead?

[12:15] <moritz_> rakudo: say atan(0)

[12:15] <p6eval> rakudo 925a9b: OUTPUT«0␤»

[12:15] * moritz_ must be confusing something

[12:15] <moritz_> rakudo: say atan(1)

[12:15] <p6eval> rakudo 925a9b: OUTPUT«0.785398163397448␤»

[12:15] <moritz_> rakudo: say atan(Inf) - 2 * atan(1)

[12:15] <p6eval> rakudo 925a9b: OUTPUT«0␤»

[12:15] <moritz_> \o/

[12:16] <tadzik> rakudo: say atan(Inf).WHAT

[12:16] <moritz_> getting a "real" 0 there is nice

[12:16] <p6eval> rakudo 925a9b: OUTPUT«Num()␤»

[12:17] *** takadonet joined
[12:17] <takadonet> morning all

[12:19] <moritz_> \o

[12:20] <colomon> o/

[12:21] *** snarkyboojum joined
[12:23] *** macroron joined
[12:23] *** macroron left
[12:24] *** colomon left
[12:28] <baest> masak: I like the factorial example for (http://gist.github.com/485816): subset Positive of Int where { $_ > 0 }; sub postfix:<!> (Positive $n) { [*] 1 .. $n } ; say 10!;

[12:30] <baest> whoops ENOMASAK :)

[12:31] <cxreg> i enjoy putting non-deterministic things in the conditional block of a subset

[12:31] <cxreg> like, say, rand

[12:33] *** colomon joined
[12:33] <moritz_> cxreg: also nice: my $x = 0; subset PositiveEnough of Int where { $_ > ++$x }

[12:33] <colomon> nice?!  # gonna have to backlog

[12:34] <moritz_> "nice"

[12:34] <cxreg> moritz_: reminds me of when i set a constraint in postgres that was basd on now()

[12:34] <cxreg> it passed the constraint when the value was set, but the row could never be updated

[12:34] <cxreg> hilarity ensues

[12:35] <cxreg> "where now() - column < '1 minute'::interval" or something

[12:35] <colomon> that's "nice" for evil values of "nice".  understood.

[12:35] <colomon> rakudo: say( [*] (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:35] <moritz_> cxreg: fun :-)

[12:35] <p6eval> rakudo 925a9b: OUTPUT«0.00411522633744856␤»

[12:38] *** rgrau_ joined
[12:40] <colomon> rakudo: say( [*] (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/2, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:41] <p6eval> rakudo 925a9b: OUTPUT«0.03125␤»

[12:44] <colomon> rakudo: (1/2, { $_ * $_ } ...  *).perl.say

[12:44] <colomon> whoops

[12:44] <p6eval> rakudo 925a9b:  ( no output )

[12:45] <colomon> rakudo: (1/2, { $_ * $_ } ...  *).munch(10).perl.say

[12:45] <p6eval> rakudo 925a9b: OUTPUT«(1/2, 1/4, 1/16, 1/256, 1/65536, 2.3283064365387e-10, 5.42101086242752e-20, 2.93873587705572e-39, 8.63616855509444e-78, 7.45834073120021e-155)␤»

[12:45] <colomon> that's right.

[12:45] <colomon> rakudo: ((5, * div 2 ... 1) Z% (2 xx *)).perl.say

[12:46] <p6eval> rakudo 925a9b: OUTPUT«(1, 0, 1)␤»

[12:46] <colomon> rakudo: say( (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/2, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:46] <p6eval> rakudo 925a9b: OUTPUT«0.50.0625␤»

[12:46] <colomon> and that's wrong

[12:46] *** nadim left
[12:46] <colomon> :\

[12:47] <moritz_> rakudo: ((5, * div 2 ... 1) Z% (2 xx *))>>.WHAT.say

[12:47] <p6eval> rakudo 925a9b: OUTPUT«Int()Int()Int()␤»

[12:48] <colomon> moritz_++

[12:48] <[Coke]> masak - you have time. release is not for hours!

[12:48] *** masak joined
[12:48] <moritz_> [Coke]: there's also one patch I want to bring in, that moves README to README.pod, and renders it with pod2text during 'make'

[12:49] <moritz_> it's not crucial, but nice-to-have, IMHO

[12:49] * [Coke] begins to catch up. I have Pi on DVD. messed. up.

[12:49] <moritz_> (if other people think it's a stupid idea, please speak up now)

[12:49] <masak> I think it's a nice idea.

[12:50] <[Coke]> moritz_: then you have to know how to build rakudo to read the makefile.

[12:50] <[Coke]> er, to read the README.

[12:50] <masak> baest: subset Positive of Int where { $_ > 0 }; sub postfix:<!> (Positive $n) { [*] 1 .. $n } ; say 10!;

[12:50] <[Coke]> I think plain text is prolly best there.

[12:50] <masak> baest: it does show the strengths of Perl 6, but it's hardly original, and it's one more builtin than the six I already have.

[12:50] <moritz_> [Coke]: it's in POD now, so it's not more complicated than ebfore

[12:50] <[Coke]> (now, if you write it in POD and check in the generated file, well, that's the right kind of evil.

[12:51] <[Coke]> moritz_: OH.

[12:51] * moritz_ doesn't like checking in generated files

[12:51] <moritz_> it just doesn't end with .pod :-)

[12:51] <[Coke]> well then, it's a step in the right direction. :P

[12:51] <[Coke]> moritz_: EW!

[12:51] <colomon> masak: I directed a bunch of comments to you in the backlog there.  :)

[12:51] <takadonet> masak: which 6 are you showing in your reddit post?

[12:51] <moritz_> s/reddit/blog/ :-)

[12:52] <masak> takadonet: http://gist.github.com/485816

[12:52] <takadonet> which I will link from reddit :P

[12:52] * [Coke] wonders if anyone else wants a "testj" target that will automagically do "TEST_JOBS=3".

[12:52] <moritz_> [Coke]: I just export TEST_JOBS=3 in my .bashrc

[12:53] <masak> it's meant for reddit et al. I want to keep Perl 6 at the front of people's minds.

[12:53] <masak> eventually, even the trolls might get tired :)

[12:53] <au|irc> masak: nice gist :) isn't &infix:<...> the epitome of dwimmery. (btw maybe s/cmp/leg/ for symmetry as colomon++ points out, but "cmp" also works the same since .name is Str, plus it's more familiar...)

[12:53] <[Coke]> moritz_: ya, that's probably less crazy.

[12:53] <jnthn> o/ folks

[12:53] <au|irc> \o jnthn

[12:53] <masak> au|irc: oh, right. 'leg'

[12:54] <colomon> \o

[12:54] <masak> I always get those two mixed up. Perl 5 interference.

[12:54] <baest> masak: fair enough

[12:54] <masak> I'll change to 'leg' for correctness, and add a comment that 'cmp' also works.

[12:54] <au|irc> masak++

[12:54] *** mmcleric_ joined
[12:55] *** mmcleric_ left
[12:55] *** mmcleric left
[12:55] <jnthn> Anyone had any luck with the Zavolaj fix, beyond me last night?

[12:55] <moritz_> jnthn: cxreg mentioned something in the backlog, iirc

[12:55] <baest> masak: concerning the builtins

[12:56] <masak> yes.

[12:58] <colomon> rakudo: say( (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/2, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:58] <p6eval> rakudo 925a9b: OUTPUT«0.50.0625␤»

[12:58] <colomon> oh

[12:58] <colomon> rakudo: say ((((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/2, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:58] <p6eval> rakudo 925a9b: OUTPUT«(1/2, 1/16)␤»

[12:58] <colomon> rakudo: say ([*[ (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/2, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:58] <p6eval> rakudo 925a9b: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 22␤»

[12:58] <colomon> rakudo: say ([*] (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/2, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:58] <p6eval> rakudo 925a9b: OUTPUT«1/32␤»

[12:59] <colomon> rakudo: say ([*] (((5, * div 2 ... 1) Z% (2 xx *)) Z* (1/3, { $_ * $_ } ...  *)).grep(*>0)).perl

[12:59] <p6eval> rakudo 925a9b: OUTPUT«1/243␤»

[12:59] <colomon> and there is the magic one-liner from last night rebuilt!

[12:59] <jnthn> moritz_: OK, bit tied up at the moment but will try and track it down

[13:00] <masak> colomon: what... what does it do? :)

[13:00] <colomon> it raises a number to the nth power by efficient repeated mulitplications

[13:00] <colomon> so you can take, say, 1/3 ** 5 (the above example) and get a Rat back

[13:01] <zulon> is there a difference between >>%>> 2 and Z% (2 xx *) ?

[13:01] <zulon> it feels like it's the same thing

[13:01] <masak> zulon: the former hyperthreads.

[13:01] <colomon> zulon: Z% is lazy

[13:02] <zulon> ok, thanks

[13:02] <colomon> but hmmm, in this case >>%>> would be better, I think.  zulon++

[13:02] <colomon> rakudo: say ([*] (((5, * div 2 ... 1) >>%>> 2) Z* (1/3, { $_ * $_ } ...  *)).grep(*>0)).perl

[13:02] <p6eval> rakudo 925a9b: OUTPUT«1/243␤»

[13:02] <colomon> \o/

[13:03] <[Coke]> colomon: that one liner doesn't make me love perl6. =-)

[13:04] <masak> anyone mind if I apply this? http://rt.perl.org/rt3/Ticket/Display.html?id=76642

[13:04] <colomon> [Coke]: not even ($n, * div 2 ... 1) >>%>> 2 to get the binary representation of an Int $n? :)

[13:04] <masak> [Coke]: I was thinking the same thing...

[13:04] <masak> colomon: that one is cooler.

[13:04] <masak> but still slightly esoteric.

[13:05] <masak> in the post, I'm aiming for things that "read well" in the sense of mapping a short program to an everyday situation.

[13:06] <moritz_> masak: go right ahead. I already removed the test file from t/spectest.data

[13:07] <masak> moritz_: excellent.

[13:07] <masak> I'll apply the patch and run spectests.

[13:08] <colomon> masak: that certainly was not intended for your post!  it was a one-liner I came up with at 2am to distract myself from the idea of writing a new infix:<**>(Numeric $a, Int $b) using a more efficient version of the same algorithm.

[13:10] <[Coke]> reading the spec, shouldn't the rat just be <1/3> ? (which in rakudo seems to be the same as "1/3", which seems wrong.)

[13:10] <masak> colomon: :)

[13:10] <masak> colomon: make sure the algorithm is maintainable. :P

[13:10] <masak> [Coke]: I thought the <1/3> form had gone away.

[13:11] <masak> maybe that was wishful thinking...

[13:11] <[Coke]> masak: it's still in S02.

[13:11] <colomon> 1/3 is just two Ints divided, which is a Rat

[13:11] <moritz_> [Coke]: <1/3> is a Rat literal. 1/3 produces a Rat at run time

[13:11] <masak> right.

[13:11] <[Coke]> "Rational literals are indicated by separating two integer literals (in any radix) with a slash, and enclosing the whole in angles:"

[13:11] <masak> if I were the optimizer, I'd have 1/3 as a Rat too.

[13:11] <[Coke]> ok. rakudo doesn't seem to know that 1/3 is a rat. does it?

[13:12] <[Coke]> rakudo say 1/3.WHAT

[13:12] <moritz_> rakudo: say (1/3).WHAT

[13:12] <p6eval> rakudo 925a9b: OUTPUT«Rat()␤»

[13:12] <masak> [Coke]: parens.

[13:12] <masak> [Coke]: methods calls bind pretty tight.

[13:12] <moritz_> [Coke]: that's the difference between a literal and an expression: the literal has tighter precedence than method calls

[13:13] <[Coke]> ok. so if we have a rat, and a rat times a rat is a rat... what is that giant one liner for? =-)

[13:13] <[Coke]> seems like you just want to print out the rat at the end instead of default stringification through num. No?

[13:14] <moritz_> rakudo: say ((1/3) ** 2).WHAT

[13:14] <p6eval> rakudo 925a9b: OUTPUT«Num()␤»

[13:14] <[Coke]> yes, ** nums.

[13:14] <colomon> moritz_++ has it

[13:14] <colomon> it's to do ** without converting to Num

[13:14] <[Coke]> but there's more going on in that one liner just reducing that to multiplication, no?

[13:14] <masak> [Coke]: colomon wants to change that.

[13:14] <moritz_> rakudo: printf '%.15f', 0.1 ** 3

[13:14] <p6eval> rakudo 925a9b: OUTPUT«0.001000000000000»

[13:14] <colomon> well, I don't know how badly I want to change that.

[13:15] <colomon> but I know people complained enough about 3 ** 4 power being a Num that a hack was worked into the code.

[13:15] <moritz_> [Coke]: the point of the one-liner is to have $a**$b doing O(log($b)) multiplications, instead of O($b)

[13:15] <colomon> s/code/Rakudo/

[13:16] <moritz_> O($b) would be the naiive implementation [*] $a xx $b

[13:16] <colomon> moritz_++ for explaining it much better than I would have.  (very bad night for sleep in our household)

[13:16] <[Coke]> ah. that was not entirely clear, especially in the context of the original set of one liners. =-)

[13:17] <[Coke]> rakudo: my $a = 1/3; $b = 1; $b *= $a for 1..5; say $b.perl

[13:17] <p6eval> rakudo 925a9b: OUTPUT«===SORRY!===␤Symbol '$b' not predeclared in <anonymous> (/tmp/kOaoZFU9gI:22)␤»

[13:17] <[Coke]> rakudo: my $a = 1/3; my $b = 1; $b *= $a for 1..5; say $b.perl

[13:17] <p6eval> rakudo 925a9b: OUTPUT«1/243␤»

[13:17] <moritz_> 243?

[13:18] <moritz_> ah, /me confused

[13:18] <masak> by the way, I'm still getting errors when running POD2MAN during 'make install'. I think we reached the conclusion last time that it's because I've made my own install of Perl 5 etc. but the fact that it happens at all means something's wrong. I don't know how to fix it.

[13:18] <[Coke]> that I think shows the Rats off, I think. (look, it's exact!)

[13:18] * PerlJam wonders if Perl 6 could get an I meta-op to turn $a/$b into $b/$a on-the-fly   ;)

[13:18] <masak> PerlJam: R/

[13:19] <[Coke]> rakudo: (4 R/5).say

[13:19] <masak> you think it, we haz it :P

[13:19] <p6eval> rakudo 925a9b: OUTPUT«1.25␤»

[13:19] <colomon> and if you mean so you can hyper or something...

[13:19] <colomon> rakudo: say ((1/3, 2/3, 32/33)>>R/>> 1).perl

[13:19] <PerlJam> yeah, but I is so mnemonic for "invert" which is the op that I think I want.  I don't ever think "I want to reverse the arguments here"

[13:20] <p6eval> rakudo 925a9b: OUTPUT«[3/1, 3/2, 33/32]␤»

[13:20] <PerlJam> anyway, Perl6++  :)

[13:20] <masak> PerlJam: roll your own :)

[13:20] <masak> PerlJam: Perl 6 is built to be forked.

[13:20] <mathw> PerlJam: Make Rakudo so that you can fudge the grammar, and add the I metaop as a duplicate of R

[13:20] <PerlJam> indeed.

[13:21] <PerlJam> mathw: I can't already fudge the grammar?  :)

[13:21] <jnthn> Mmmm...user-defiend meta-ops.

[13:21] <avar> masak: what pod2man errors?

[13:21] <colomon> rakudo: sub postfix:<I>($a) { 1 / $a; }; say ((1/3, 2/3, 32/33)>>I).perl

[13:21] <p6eval> rakudo 925a9b: OUTPUT«===SORRY!===␤Could not find sub &postfix:<I>␤»

[13:21] <colomon> rakudo: our sub postfix:<I>($a) { 1 / $a; }; say ((1/3, 2/3, 32/33)>>I).perl

[13:21] <p6eval> rakudo 925a9b: OUTPUT«[3/1, 3/2, 33/32]␤»

[13:21] <masak> avar: in my Makefile, the variable 'POD2MAN' ends up being set to the empty string.

[13:21] <mathw> PerlJam: I don't believe so - not without rebuilding Rakudo :)

[13:22] <PerlJam> mathw: that's good enough ... I build my own rakudo all the time :)

[13:22] <masak> avar: which means that during install when it's used, I get funky permission-denied errors because it tries to run non-commands.

[13:22] <mathw> user-defined metaops would be awesome

[13:22] <avar> ah, mine too

[13:22] <masak> avar: we should form a union and go on strike.

[13:22] <masak> :)

[13:22] <PerlJam> in fact, I think I've built a rakudo, on average, once a day for the last few months.

[13:22] <avar> yup

[13:22] * avar greps where POD2MAN comes from

[13:23] <masak> avar++ # going one step further than complaining

[13:23] <jnthn> mathw: It's probably just a smop to get 'em in Rakudo.

[13:23] <jnthn> mathw: For some value of s

[13:23] <jnthn> :-)

[13:23] <moritz_> avar: it comes from parrot's Configure

[13:23] <avar> it's in Makefile.in..

[13:23] <avar> aw, I can't patch that, it's in svn *hiss*

[13:24] <[Coke]> ... did you build parrot as root?

[13:24] <[Coke]> why that should matter, I have no idea, but ISTR that affected pod.

[13:24] <avar> anyway, you can fix it in the MAkefile.in too with ifndef ... 

[13:25] <masak> avar: if you prepare the patch, I'll apply it.

[13:26] <moritz_> avar: how portable is ifndef?

[13:26] <avar> it'll fail on freebsd/solaris make, you need nmake and gmake respectively.

[13:26] <moritz_> what windows blah?

[13:26] <avar> don't windows people get nmake?

[13:26] <[Coke]> parrot's make tries to work in bsd make, fwiw.

[13:27] <moritz_> then we should try that too

[13:27] *** baest left
[13:28] <[Coke]> pastebot?

[13:28] <moritz_> none atm :(

[13:28] <PerlJam> just use gist.github.com

[13:28] <avar> wasn't parrot moving to git?

[13:28] <[Coke]> http://nopaste.snit.ch/22205 - spectest failure

[13:28] <[Coke]> avar: eventually.

[13:28] <moritz_> avar: yes, but only after the GSOC projects

[13:28] <moritz_> and after R*, for that matter

[13:29] <avar> I guess git://repo.or.cz/parrot.git works in the meantime

[13:29] <moritz_> in order not cause disruptions

[13:29] <avar> how about the pugs repository, like the spectests?

[13:29] <[Coke]> moritz_: more after we have a working testbed with trac/git integration that preservers history.

[13:29] *** rgrau_ left
[13:29] <[Coke]> ;... but that will take at least that long, yes. =-)

[13:29] *** tadzik left
[13:29] <[Coke]> avar: SFAIK, no plans on migrating pugs

[13:29] <moritz_> avar: http://github.com/moritz/Mu/ is a git mirror of pugs

[13:30] <moritz_> but migration would require TimToady++ to learn git first :-)

[13:30] <avar> github has svn commit support now :) 

[13:30] <avar> I mainly want t/spec so I can watch it on github :)

[13:31] <moritz_> we also discussed splitting the repo

[13:31] <moritz_> but I'm not sure that's good for the community

[13:31] <moritz_> or the projects in there

[13:31] <PerlJam> I'm fairly sure it's not.

[13:33] <[particle]> masak: http://gist.github.com/485816 has a bug... for 1..10 X 1..10 X 1..10 -> $x, $y, $x {  # loop in a cube should be $x, $y, $z

[13:33] <moritz_> hum, das that work with rakudo today?

[13:33] <masak> [particle]: thank you.

[13:33] <moritz_> rakudo: say 1..2 X <a b> X <X Y>

[13:33] <p6eval> rakudo 925a9b: OUTPUT«No applicable candidates found to dispatch to for 'infix:<X>'. Available candidates are:␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/bvMK9WS8xG␤»

[13:33] <moritz_> masak: maybe constrain yourself to running examples? :-)

[13:33] <masak> rakudo: 1..10 X 1..10 -> $x, $y, $x { say $x, ' ', $y }

[13:34] <p6eval> rakudo 925a9b: OUTPUT«===SORRY!===␤Confused at line 22, near "1..10 X 1."␤»

[13:34] <masak> moritz_: oh, indeed.

[13:34] <masak> moritz_: removing that one.

[13:34] <mathw> aaah

[13:34] <masak> I ran most of them.

[13:34] <mathw> it does that with Z as well

[13:34] <mathw> that's a known bug?

[13:34] <mathw> or known NYU?

[13:34] <moritz_> yes

[13:34] <masak> I just assumed that one worked :)

[13:34] <moritz_> it's in RT

[13:34] <moritz_> and it needs multi-dim slices to work properly

[13:34] <masak> rakudo: .say for <a b> Z <c d> Z <e f>

[13:34] <p6eval> rakudo 925a9b: OUTPUT«No applicable candidates found to dispatch to for 'infix:<Z>'. Available candidates are:␤:()␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/XVCeEXUSJv␤»

[13:35] <masak> this *used* to work.

[13:35] <au|irc> masak: map { $_ * $_ }, 1 ... *  

[13:35] <moritz_> yes. With some weird PIR magic

[13:35] <au|irc> [...] is of lower prec than [,]

[13:35] <avar> moritz_: what's your readlink $(which perl) ?

[13:35] <au|irc> and so maybe need parens around ( 1 ... *)

[13:36] <moritz_> avar: my perl is /usr/bin/perl, and it works here. It's masak on OS X where it fails

[13:36] <au|irc> (or "map: {$_ * $_}")

[13:36] <moritz_> or just use 1..*

[13:36] <au|irc> (1 ... *).map, that is.

[13:36] <au|irc> true, but well, that section is on infix:<...> ...

[13:36] <moritz_> oh.

[13:36] <au|irc> =)

[13:37] *** masak left
[13:37] <avar> moritz_: does your osx use perlbrew?

[13:37] <moritz_> avar: I'm on Debian

[13:37] *** masak joined
[13:37] <avar> whatever, what's perl like on the system where pod2man isn't detected

[13:37] <mathw> moritz_: good. Glad it's known. I wanted to do a three-way zip the other day and I was beaten by it :(

[13:38] <avar> oh, masak is the one with the problem

[13:38] <avar> stop having vaguely similar nicks guys!

[13:38] <avar> masak: above question...

[13:38] <masak> sorry...

[13:38] <masak> avar: I don't know. it's pretty good, I guess.

[13:38] <avar> ..

[13:38] <masak> much faster than Rakudo :)

[13:38] <avar> I mean how is it installed, what does readlink $(which perl) give you

[13:38] <masak> avar: seriously, though

[13:39] <masak> ok, checking.

[13:39] <masak> $ readlink $(which perl)

[13:39] <masak>  

[13:39] <masak> (that's an empty line)

[13:39] <masak> or rather, no output at all.

[13:40] <moritz_> what about 'which perl' directly?

[13:40] <masak> /usr/bin/perl

[13:40] <moritz_> http://github.com/moritz/perlgeek.de/blob/master/other/perl-5-to-6/27-common-idioms.pod review welcome before I blog it

[13:41] * masak reads

[13:41] <frettled> readlink only shows something if it was a link.

[13:42] *** masonkramer left
[13:42] <[Coke]> http://www.groklaw.net/article.php?story=20100720220611321 - "I have done some pearl scripting in Linux"

[13:42] <frettled> perl=$(which perl); -l $perl && readlink $perl || echo $perl

[13:43] *** tadzik joined
[13:43] <PerlJam> moritz_: I think the Numbers section could use some more words to describe what it's doing, but I don't know what those words would be.

[13:43] <masak> moritz_: there's an encoding artifact after "Perl" in "Perl 6", last paragraph under DESCRIPTION. probably an nbsp. is that just a consequence of the way you show the post right now, or a real encoding issue?

[13:44] <moritz_> masak: I hope it's a github POD issue

[13:44] <masak> oki

[13:44] <[Coke]> for a while, the nbsp was in a lot of the docs.

[13:44] <[particle]> moritz_: case insensitively should be hyphenated

[13:44] <[Coke]> [particle]: but don't capitalize it!!

[13:44] <moritz_> probably because I don't declare =encoding utf8

[13:44] <masak> moritz_: you should probable mention min= and max= under Numbers, too.

[13:45] <masak> s/ble/bly/

[13:45] <masak> moritz_: under "Debugging", ss/as good as possible/as faithfully as possible/. note, adverb.

[13:46] <moritz_> masak++ [particle]++ PerlJam++

[13:46] <[particle]> someone here knows british english... "zip fastener" is "zipper" in the usa

[13:46] <[particle]> ...just noting an idiom...

[13:46] <masak> the italics of "colonpair" collides a bit with the quotes. maybe italicize quotes, or just ditch the italics.

[13:46] <PerlJam> [particle]++  :)

[13:47] *** daxim left
[13:47] <masak> moritz_: the 'has ... die' idiom is cute. haven't seen that before. moritz_++

[13:48] <moritz_> masak: I've seen it first from tadzik++

[13:48] <masak> tadzik++

[13:48] <moritz_> pushed an update

[13:48] <tadzik> I've seen it first on the internets, on a blog yelling how unintuitive Perl6 is :)

[13:48] <moritz_> which hopefully incorporates all your feedback

[13:48] <jnthn> Could write an "is required" trait to make that much neater...soonish.

[13:50] <au|irc> moritz_: maybe .lc instead of .uc in sorting case insensitively

[13:50] <masak> fans go crazy... gotta be S05-mass... :)

[13:50] <au|irc> (historically, for the uc('ß') => 'SS' treatment on some locales)

[13:51] <masak> tadzik: url?

[13:51] <moritz_> au|irc: german ß does sort like SS

[13:51] <tadzik> masak: don't remeber I must say.

[13:51] <tadzik> may want to find

[13:51] <tadzik> and IIRC, he wrote that someone on #perl6 suggested this

[13:51] <au|irc> moritz_: well, yes, but it's two characters :)

[13:51] <moritz_> au|irc: I remember that there was some Unicode oddity that made uc the safer comparsion, but I might be wrong

[13:51] <masak> tadzik: if you do find it, do post it here.

[13:51] <tadzik> will try

[13:52] <masak> moritz_: I remember it the other way around.

[13:52] <moritz_> ok, will change

[13:53] <tadzik> got it

[13:53] <tadzik> „The Perl6 version is shorter, and arguably more elegant. TimToady helped me figure out the Perl6 equivalent to Moose's required => 1. You just set a default that will throw an exception when evaluated.”

[13:53] <tadzik> Who would guess :)

[13:53] <tadzik> http://chris.prather.org/what-stops-me-from-using-perl-6-today.html

[13:53] <masak> ah, a Moose person. :)

[13:53] <avar> masak: I fixed the stupid parrot configure

[13:54] <masak> avar++

[13:54] <masak> I need more examples under infix:<X> ! it looks too meager now that the 'loop over cube' is gone.

[13:54] <[particle]> how do you do an accent-insensitive search in p6?

[13:54] <masak> maybe that's a sign that I should throw out infix:<X> and do operator overloading or something instead...

[13:55] <moritz_> [particle]: with the :m modifier, iirc

[13:55] <moritz_> search in S05 for 'mark'

[13:55] <[particle]> might be worth mentioning, if it's implemented

[13:55] <moritz_> it's not

[13:55] <tadzik> there I still things Perl 6 could learn from Moose, IMHO

[13:55] <[particle]> ah, well.

[13:56] *** masak left
[13:56] <PerlJam> tadzik: certainly.  Moose is more mature at this point.  Many people have lots of experience with it.

[13:56] <tadzik> PerlJam: is it possible that Perl6 specs will change, learning from Moose experiences?

[13:56] <smash__> i'm getting an error with 'make spectest_smolder'

[13:56] <moritz_> which one?

[13:56] *** masak joined
[13:56] <masak> au|irc: did you know that some Japanese programmer named ^..^ the 'neko operator'? :)

[13:57] <au|irc> masak: yeah :) still remember that :)

[13:57] <PerlJam> tadzik: sure it's possible.  But I think most of the lessons aren't in the spec as much as the implementation  :)

[13:57] <masak> oh, is it old? I thought it was new as of six months or so.

[13:58] <smash__> moritz_: 'curl: (26) failed creating formpost data'

[13:58] <PerlJam> tadzik: and I think that there are some things that Moose does wrong (and they know it) that we should make it a point not to do  :)

[13:58] <au|irc> masak: 2001 Damian http://www.mail-archive.com/perl6-language@perl.org/msg08317.html

[13:59] <[particle]> ah, that's much closer to when Neko was a popular meme

[13:59] <tadzik> PerlJam: I, e.g. will love to have [ 'a possibility to use' | 'an equivalent to' ] Moose-like BUILD submethod

[13:59] <masak> oh! so *that's* the source. au++

[13:59] <au|irc> :)

[13:59] <tadzik> where parameters are alredy initialized, and I can just do my job

[13:59] <moritz_> tadzik: I still think that Perl 6 BUILD should behave much the same way

[13:59] <tadzik> like, what's the easiest way to say "Object created" after the creation of object?

[13:59] <masak> but different op, though.

[13:59] <masak> it's from the time when we had ^ as 'hyper'.

[14:00] <au|irc> moritz++ # 5-to-6 series is wonderful for me catching up syntax here, keep'em coming :)

[14:00] <masak> ^..^ is the rightful owner of the name 'neko operator' :)

[14:00] *** uniejo left
[14:00] <tadzik> Either overloading new and parsing the params to constructor yourself, or overload BUILD and initialize params yourself

[14:00] <tadzik> this is insane, IMHO

[14:00] <au|irc> masak: right. in 2005 it's repurposed for ^..^ (also by damian in a conference somewhere iirc)

[14:01] <masak> tadzik: how would you have it?

[14:01] <tadzik> masak: Moose style is nice. You write your sub BUILD, in which the parameters are alredy parsed and initialized

[14:01] <moritz_> masak: point is that in rakudo the preseence of a BUILD submethod breaks automatic attribute initialization

[14:02] <moritz_> masak: which I still think is a bug. It's a submethod after all, and shouldn't affect what the magic things in Mu do for you

[14:02] <masak> moritz_: yes, now that sucks.

[14:02] <masak> right.

[14:02] <masak> BUILD shouldn't be magical at all, IMO.

[14:02] <smash__> moritz_: can't find the rakudo_test_run.tar.gz anywhere

[14:02] <moritz_> rakudo: class A { has $.b; submethod BUILD { say $.b } }; A.new(b => 23)

[14:02] <tadzik> exactly

[14:02] <p6eval> rakudo 925a9b: OUTPUT«Any()␤»

[14:03] *** pmurias left
[14:03] <avar> masak: posted in #parrot: http://github.com/avar/parrot/compare/configure-versiononly 

[14:03] <tadzik> moritz_: pmichaud says it's intentional feature

[14:03] <moritz_> IMHO that should say 23, and both tadzik and me would be happy

[14:03] <tadzik> and masak

[14:03] <moritz_> "intentional" implies a point of view that I don't share

[14:03] <tadzik> and Perl5'ers

[14:03] <masak> I really like http://chris.prather.org/what-stops-me-from-using-perl-6-today.html

[14:03] <masak> it's honest, and well-researched.

[14:04] <masak> tadzik: let's just say that the semantics around BUILD isn't quite ironed out yet.

[14:05] <masak> what are the failures in t/spec/S29-context/die.rakudo and t/spec/S29-context/exit.rakudo about?

[14:05] <au|irc> S12: "In fact, within submethods, use of the C<$.foo> form on attributes that are declared directly by this class is illegal"

[14:05] *** felliott left
[14:05] <tadzik> in specs or in rakudo?

[14:05] <tadzik> pff

[14:05] <masak> tadzik: a bit of both, I suspect.

[14:05] <tadzik> I'd love it changed, and I see I'm not the only one

[14:05] <moritz_> :(

[14:06] <avar> masak: can you try that patch and see if it detects your pod2man then?

[14:06] <masak> I've never fully understood the $.b restriction in submethods.

[14:06] <masak> avar: will do, as soon as spectest is done.

[14:07] <avar> greeeeeeeeeeeeeeeeeeeeeeeeeeat

[14:08] <moritz_> masak: since rakudo works off an installed parrot, you can safely reconfigure parrot during the spectest run (as long as you don't "make install")

[14:09] *** REPLeffect joined
[14:09] <au|irc> tadzik: if it's some comfort, the spec would have "submethod BUILD ($!b) { say $!b }" work; that is, any params you might use in BUILD can be initialized for you

[14:09] <masak> moritz_: right, but it's the Rakudo Makefile that contains the missing POD2MAN.

[14:09] <au|irc> (and it's even implemented :))

[14:09] <tadzik> :)

[14:09] <au|irc> rakudo: class O { has $.b; submethod BUILD ($!b) { say $!b } }; O.new(b => 23)

[14:10] <p6eval> rakudo 925a9b: OUTPUT«23␤»

[14:10] <moritz_> au++

[14:10] <moritz_> masak: ah, right

[14:10] <tadzik> hmm

[14:10] <tadzik> that's sometin

[14:11] <tadzik> so the things we put -- BUILD (<here>) -- will be initialized as if we never wrote our BUILD ourselves?

[14:11] <moritz_> seems like

[14:11] <au|irc> right. then you also get to modify it

[14:11] <tadzik> not too bad

[14:12] <masak> tadzik: long as you use the $!b form, yes.

[14:12] <masak> tadzik: good news is, it's not restricted to BUILD submethods.

[14:13] <masak> did we punt on the $/-in-block-in-subst bug until after the release?

[14:14] <moritz_> masak: pmichaud had a patch for it, which caused other breakages

[14:14] <masak> oh :/

[14:14] <moritz_> masak: I think the conclusion was "it's more complicated than that"

[14:14] <masak> right.

[14:14] *** lestrrat is now known as lest_away

[14:14] <masak> one of my examples (the one with the balanced parentheses) works around that bug.

[14:16] * au|irc feels the all-too-familiar sleep-drifting dopamine pull and reluctantly waves g'nite :-)

[14:16] *** au|irc is now known as au|zzz

[14:16] <PerlJam> good night au

[14:16] <moritz_> good night

[14:17] <moritz_> /o

[14:17] <Juerd> I'm postponing the feather1 migration.

[14:17] <au|zzz> o∀

[14:18] <Juerd> For some reason, the target machine starts to act up when the transfer is around 95%

[14:18] <Juerd> I don't have any time left to try and find a workaround.

[14:18] <moritz_> Juerd: do you have any numbers on much /home/ size was reduced? or file count?

[14:18] <masak> 晚安, au

[14:18] <Juerd> moritz_: File count: no, but at least the 1M files from that Maildir should help a lot.

[14:19] <moritz_> :-)

[14:19] <Juerd> moritz_: Disk usage went from 59 GB to 34 GB

[14:19] <moritz_> that's decent :-)

[14:19] <Juerd> That's /data, by the way

[14:19] <Juerd> Which contains /home and /var

[14:19] <moritz_> makes sense

[14:20] <Juerd> But I wanted to migrate feather[123] before I went away for a week

[14:20] <Juerd> Now feather0 is still running, just for feather1

[14:20] <moritz_> :/

[14:20] <Juerd> A waste of electricity

[14:21] <Juerd> But I don't understand why the new dom0 acts so weird after the transfer has been going on for a while

[14:22] <Juerd> It starts skipping clock ticks, messing up TCP checksums, and gets a very high load

[14:22] <Juerd> Until I stop the transfer, after which everything returns to normal.

[14:22] * moritz_ remembers the broken RAM module in an old feather ...

[14:23] <Juerd> RAM was tested on the new dom0 before we put it into production

[14:23] <moritz_> :-)

[14:23] <Juerd> But I've used 4 different kernels before I found one that isn't severely buggy

[14:23] <Juerd> (Stay away from 2.6.32 .. 2.6.34)

[14:24] <Juerd> It's running on 2.6.31 now. Maybe it's broken too.

[14:24] <Juerd> I could try, when I return after a week, to write the data from within a domU instead of directly on the dom0. Then at least it can't mess up the hardware very easily.

[14:25] *** alester joined
[14:33] <masak> rakudo: my @people = <huie dewey louie>; say (@people Z=> 1..*).perl

[14:33] <p6eval> rakudo 925a9b: OUTPUT«("huie" => 1, "dewey" => 2, "louie" => 3)␤»

[14:33] <masak> rakudo: my @people = <huie dewey louie>; say (@people Z=> (1 ... *)).perl

[14:33] <p6eval> rakudo 925a9b: OUTPUT«("huie" => 1, "dewey" => 2, "louie" => 3)␤»

[14:33] *** astrojp joined
[14:33] * masak goes with the former in the blog post draft

[14:35] <colomon> rakudo: say (1 x *).munch(10).perl

[14:35] <p6eval> rakudo 925a9b: OUTPUT«_block114␤»

[14:36] <moritz_> 1 xx * ?

[14:37] <Juerd> Z=> is very nice but very ugly too

[14:37] <Juerd> And hard to type, shiftwise

[14:37] <[particle]> masak: huey

[14:37] * moritz_ likes it

[14:38] <masak> [particle]: thanks. I'm not a native :)

[14:38] <masak> ss/native/native speaker/ :)

[14:38] <[particle]> it's not a CN

[14:38] <masak> no, but it's a cultural, um, artifact.

[14:39] *** _macdaddy joined
[14:40] <colomon> rakudo: say (1 xx *).munch(10).perl

[14:40] <p6eval> rakudo 925a9b: OUTPUT«(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)␤»

[14:40] <colomon> moritz_: I knew 1 xx * worked.  wondered what 1 x * did.  Is x Str repetition?

[14:40] <moritz_> yes

[14:40] <moritz_> and since you can't do it infinitely, it's better to curry it

[14:40] <dalek> rakudo: 220b678 | (Timothy Totten)++ |  (2 files):

[14:40] <dalek> rakudo: Removed DateTime::strftime, as it's moved to an external repo.

[14:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/220b6781621b6bf3c3d2fd6070b7f74efd86c8df

[14:40] <[particle]> rakudo: say '1' x 10

[14:41] <p6eval> rakudo 925a9b: OUTPUT«1111111111␤»

[14:41] <colomon> you could do it infinitely if you returned a Cat...  ;)

[14:41] <masak> avar: ok, ready to apply your patch now.

[14:41] <moritz_> masak: btw it's good to style to apply patches with 'git am -s' (which add the signed-off line)

[14:41] <avar> masak: to parrot?

[14:41] <masak> moritz_: ok, good to know.

[14:41] <masak> avar: locally first.

[14:41] <masak> moritz_: I'll remember that till next time.

[14:42] <avar> masak: ok then :)

[14:42] <masak> avar: I'm thinking how I can easily go from http://github.com/avar/parrot/compare/configure-versiononly to something I can apply.

[14:42] <[particle]> moritz_: is that in a rakudo guide? that's a good hint

[14:42] <masak> copy+paste is the easiest I can think of, but it's boring and error-prone.

[14:42] <avar> masak: I'll produce it, wait a bit

[14:42] <masak> \o/

[14:42] <moritz_> git clone the repo, git show the patch, pipe to patch -p1

[14:43] <tadzik> in regexps, <foo> ** <bar>+ is <foo> separated by a positive number of <bar>s?

[14:43] <masak> tadzik: yes.

[14:43] <Kodi> masak: http://gist.github.com/486055

[14:43] <avar> masak: http://gist.github.com/486058 

[14:43] * moritz_ doesn't know the relative precedence of ** and +

[14:43] <masak> tadzik: unless the priorities make it mean [<foo> ** <bar>]+

[14:43] <avar> masak: or, use git svn, then cherry-pick :)

[14:44] <tadzik> hmm

[14:44] <masak> tadzik: that calls for a bit of empirical investigation :)

[14:44] <masak> avar: thanks.

[14:44] <tadzik> would be better to match it just in case :)

[14:44] <Kodi> masak: I'll apply the changes to Pugs if it all looks good.

[14:44] <masak> tadzik: I'd put in [<bar>+] for clarity anyway.

[14:44] <masak> Kodi: haven't had a time to look yet.

[14:44] <masak> *phew*

[14:44] <tadzik> masak: yep, that's what I did

[14:45] <PerlJam> tadzik: note thatll also match <foo> by itself  (i.e., no <bar>)

[14:45] <masak> Kodi: will look after I apply avar++'s patch. :)

[14:45] <tadzik> yeah, that's ok for me

[14:45] <Kodi> masak: Sure.

[14:45] <masak> tadzik: note that `a ** foo` is a tricky one. it means `a ** [f] oo`

[14:46] <tadzik> masak: neat

[14:47] <masak> avar: I can't make `patch` work with that patch. :/

[14:48] <masak> avar: did I mention I'm running Parrot in its SVN repo?

[14:48] <TiMBuS> masak, is 'map { $_ * $_ }, 1 ... * # squares' really an example of the ... operator?

[14:48] <tadzik> wow, after refactoring grammars suprisingly many tests passed

[14:48] <TiMBuS> or is that the map taking a normal range?

[14:48] <avar> masak: patch -p1 < patch ?

[14:49] <masak> TiMBuS: sort of and sort of not.

[14:49] <masak> ah, -p1. I tried -p0

[14:49] <avar> all git patches need -p1

[14:49] <avar> that works?

[14:51] *** tylercurtis joined
[14:52] <masak> now it works.

[14:52] <masak> testing it.

[14:54] *** pmurias joined
[14:56] *** skids joined
[14:58] *** justatheory joined
[15:00] <tadzik> rakudo: "\n" ~~ / \w /

[15:00] <p6eval> rakudo 925a9b:  ( no output )

[15:00] <tadzik> rakudo: say 'ok' if "\n" ~~ / \w /

[15:00] <p6eval> rakudo 925a9b:  ( no output )

[15:01] *** ashleydev joined
[15:08] *** justatheory left
[15:11] *** smash__ left
[15:11] *** smash__ joined
[15:12] *** quietfanatic left
[15:12] *** patrickas joined
[15:12] <patrickas> hello perl6, long time no see :-)

[15:14] <moritz_> \o/ patrickas 

[15:17] <colomon> \o

[15:18] <pmichaud> good morning, #perl6

[15:18] <colomon> o/

[15:18] <moritz_> good morning

[15:18] <masak> \o

[15:19] <masak> patrickas! \o/

[15:19] <patrickas> hello pmichaud

[15:19] <masak> pmichaud! \o/

[15:19] <patrickas> masak: o/

[15:20] *** kcwu joined
[15:21] <tadzik> is there something like whitespace-not-newline in regexes?

[15:21] <moritz_> tadzik: there's \h for a horizontal space

[15:21] <moritz_> s/a /

[15:22] <moritz_> so blank, tab, whatever (but not \n or vertical tab)

[15:22] *** rgrau_ joined
[15:23] <tadzik> great, thanks moritz_++

[15:25] *** jaldhar left
[15:27] *** jaldhar joined
[15:32] <moritz_> rakudo: say [\+] 0..6

[15:32] <p6eval> rakudo 925a9b: OUTPUT«0136101521␤»

[15:32] <moritz_> rakudo: say ~[\+] 0..6

[15:32] <p6eval> rakudo 925a9b: OUTPUT«0 1 3 6 10 15 21␤»

[15:32] <colomon> are there any tests for Str.lines yet?  (LHF hunt)

[15:32] <moritz_> probably not

[15:32] <moritz_> also lines() and slurp() without arguments are untested

[15:32] <colomon> The implementation was trivial.  :)

[15:33] <pmichaud> rakudo:  say [\*] 0..6

[15:33] <p6eval> rakudo 925a9b: OUTPUT«0000000␤»

[15:33] <pmichaud> rakudo:  say [\*] 1..6

[15:33] <p6eval> rakudo 925a9b: OUTPUT«12624120720␤»

[15:33] <pmichaud> rakudo:  say ~[\*] 1..6

[15:33] <p6eval> rakudo 925a9b: OUTPUT«1 2 6 24 120 720␤»

[15:33] * moritz_ writes a reply to Jon Lang's p6l mail

[15:34] <pmichaud> moritz_: I was about to do the same.

[15:34] <pmichaud> I'll let you reply :)

[15:34] *** achromic joined
[15:34] <moritz_> ok :-)

[15:34] <masak> avar: nope, still getting the same permission errors :/

[15:34] <pmichaud> do you have an answer for square numbers?

[15:34] *** ashleydev_ joined
[15:34] *** ashleydev left
[15:34] *** ashleydev_ is now known as ashleydev

[15:34] <moritz_> rakudo: say ~(1..10).map(* ** 2)

[15:35] <p6eval> rakudo 925a9b: OUTPUT«1 4 9 16 25 36 49 64 81 100␤»

[15:35] <pmichaud> that works.

[15:35] <avar> masak: what errors?

[15:35] <masak> avar: the original ones.

[15:35] <avar> masak: does Configure.pl say it finds the pod2man program?

[15:35] <masak> avar: as in, POD2MAN is still unset here.

[15:35] <masak> avar: Rakudo's or Parrot's?

[15:36] <moritz_> rakudo: say ~(1, { $_ + 2 * .sqrt + 1} ... 100)

[15:36] <avar> masak: parrot's

[15:36] <p6eval> rakudo 925a9b: OUTPUT«1 4 9 16 25 36 49 64 81 100␤»

[15:36] <masak> avar: auto::pod2man -       Is pod2man installed.................................no.

[15:37] <masak> rakudo: .say for 'ba', { $_ ~ 'na' } ... *

[15:37] <avar> masak: set a $DB::single = 1; breakpoint in runstep in auto::pod2man

[15:37] <avar> then check what $cmd is

[15:37] <p6eval> rakudo 925a9b:

[15:37] <p6eval> ..OUTPUT«ba␤bana␤banana␤bananana␤banananana␤bananananana␤banananananana␤bananananananana␤banananananananana␤bananananananananana␤banananananananananana␤bananananananananananana␤banananananananananananana␤bananananananananananananana␤banananananananananananananana␤bananananananananananananan…

[15:38] <masak> avar: where's auto::pod2man?

[15:38] <avar> it's one of the files I patched

[15:38] * masak looks

[15:39] <masak> avar: and by 'set a $DB::single = 1; breakpoint', you mean...?

[15:39] * masak isn't used to debugging Perl 5

[15:41] <masak> ah, just add such a line there?

[15:41] <masak> magic! :)

[15:41] <masak> Rakudo should have something like that.

[15:41] <avar> yeah

[15:41] *** snarkyboojum left
[15:42] <avar> then run perl -d Configure.pl

[15:42] <masak> avar: once I've done that, what do I do? just run perl Configure.pl again, or with some special flag?

[15:42] <avar> then press c

[15:42] *** macroron joined
[15:42] * masak guesses -D

[15:42] <masak> oki

[15:42] <masak> this is awesome

[15:43] <moritz_> pmichaud: mail sent. Feel free to add anything that I omitted :-)

[15:43] <colomon> moritz_++

[15:44] <masak> avar: http://gist.github.com/486135

[15:44] <colomon> rakudo: say ([\*] (1...*)).munch(10).perl

[15:44] <moritz_> pmichaud: we have a patch in RT that moves README to README.pod, and generates README at build time with pod2text - any objections?

[15:44] <p6eval> rakudo 925a9b: OUTPUT«(1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800)␤»

[15:45] <colomon> moritz_: triangle reduce is lazy, too, if he wants infinite series.  :)

[15:45] <moritz_> :-)

[15:45] <pmichaud> moritz_: patch +1

[15:45] <pmichaud> oh, wait

[15:46] <pmichaud> why do we need both README.pod and README?

[15:46] <avar> masak: well, "permission denied" was a different error from what I got, mine couldn't find the path at all

[15:46] <moritz_> pmichaud: some people feel that reading pod is not nice. I don't care either way

[15:47] <masak> avar: I have such a file, and it's not executable.

[15:47] *** charsbar joined
[15:47] <pmichaud> so, when I get a tarball, I have a README.pod but nothing else, yes?

[15:47] <moritz_> even if not, I'd rename it

[15:47] * [particle] would not like to see CREDITS.pod, README.pod, MANIFEST.pod etc

[15:47] <moritz_> pmichaud: right

[15:47] <masak> it's an OS X wrapper of some kind.

[15:47] <pmichaud> that seems not-so-good

[15:47] <avar> masak: well, then your system is broken.

[15:47] <moritz_> pmichaud: unless 'make release' generates the README

[15:47] <moritz_> [particle]: MANFIEST is not POD :-)

[15:47] <pmichaud> well, git clone would be the same way.

[15:47] <masak> avar: I know that. I was just hoping Rakudo/Parrot could compensate in this case.

[15:47] <masak> avar: because many are running Mac OS X.

[15:48] <pmichaud> I'm not sure I agree with the idea of generating README at build time.

[15:48] * moritz_ decommutes, but will backlog

[15:48] *** Raynes left
[15:48] <pmichaud> seems like README ought to be available pre-build

[15:48] <masak> and it's not fun to see errors during 'make install'.

[15:48] <masak> pmichaud: good point.

[15:50] <pmichaud> does our README need to have pod at all?

[15:50] <[particle]> no

[15:51] *** felliott joined
[15:51] <masak> Kodi: ok, I'm now ready to review http://gist.github.com/486055 -- but I think I need a break first.

[15:52] <masak> others are welcome to take a look, though.

[15:52] <Kodi> masak: By all means. :)

[15:52] <masak> Kodi: I'm really happy to see spec and Rakudo change together, though. that's a good sign.

[15:53] <Kodi> masak: I have to leave in about 40 minutes, but I should be able to get on IRC again this afternoon, at least briefly.

[15:53] <masak> Kodi: things might be applied by then, if all goes well :)

[15:53] <Kodi> I'm crossing my fingers.

[15:53] <pmichaud> masak:  gist 485816 is very nice

[15:54] <masak> pmichaud: thank you.

[15:54] <pmichaud> ooc, did you see my latest slides using .classify?

[15:54] <masak> I'm having second thoughts about 'drool' in the title, though. :)

[15:54] <masak> and now that I've verbalized it, of course I can't use it :/

[15:54] <masak> pmichaud: nope, url?

[15:55] <masak> "Six builtins that will make you want Perl 6 and Rakudo Star"?

[15:55] <masak> "You know you want to: Six builtins from Perl 6 and Rakudo Star"?

[15:56] *** pyrimidine joined
[15:56] <[particle]> Perl 6 has six builtins you never knew you needed: try them in Rakudo Star

[15:57] <masak> [particle]: I like.

[15:58] *** eternaleye joined
[15:59] *** Raynes joined
[16:01] <pmichaud> url coming

[16:02] <pmichaud> the illustrative slide is http://www.pmichaud.com/2010/pres/oscon-perl6/slides/slide28b.html#end

[16:02] <masak> so, we're back where we started with the POD2MAN issue: "your system is broken" and no fix in sight.

[16:02] <masak> avar++ for trying, though.

[16:02] <pmichaud> but the the disucssion begins at http://www.pmichaud.com/2010/pres/oscon-perl6/slides/slide23b.html#end

[16:03] <pmichaud> and I need to add a slide in there that has the result of "what will the following do?"

[16:03] <pmichaud> (in the presentation, I actually run the code live)

[16:04] *** qwr joined
[16:04] <masak> pmichaud: in a PAST::Op with :pasttype('call') and :name('!create_anon_enum'), if I change :name to '&some-sub', can I write some-sub in Perl 6?

[16:05] <masak> does .comb have the Int second argument, like .split does?

[16:05] * masak checks specs

[16:05] <Tene> masak: Should be.

[16:05] *** rgrau_ left
[16:05] <Tene> For the former about PAST, that is.

[16:06] <masak> Tene: ok, cool.

[16:06] <masak> Tene: and does that have to be a sub that pollutes the user namespace?

[16:07] <masak> Tene: (I'm looking toward porting the enum creation code to Perl 6, and then doing scary things with it)

[16:07] <avar> masak: how can you call perldoc in your shell if it doesn't have +x ?

[16:07] <tylercurtis> What is the cause of the occasional spikes of fail on the spectest graph?

[16:07] <Tene> masak: you can specify the namespace in PAST

[16:07] <Tene> :ns, I think.

[16:08] <masak> avar: `which perldoc` doesn't point to where `which perl` is pointing.

[16:08] <masak> avar: the former has +x

[16:08] <masak> Tene: ok, cool. any prior art in Rakudo?

[16:08] <masak> Tene: for Perl 6 subs, I mean.

[16:08] <Tene> masak: no idea. :)

[16:08] <masak> oki. thanks anyway.

[16:09] <masak> tylercurtis: patches that fail the build right around when the statistics are collected, I guess.

[16:09] <pmichaud> masak:  yes, you can use &some-sub to call a perl 6 sub.

[16:09] <avar> masak: perl doesn't have +x ?

[16:09] <pmichaud> in fact, that's what PAST generates

[16:09] *** xabbu42 left
[16:09] <masak> avar: yes, but the perldoc in that dir doesn't.

[16:11] *** justatheory joined
[16:12] <avar> masak: You're not doing a very good job of explaining this to me :)

[16:12] <avar> anyway, looks like you might have to call it as perl $(which perldoc), not $(which perldoc)

[16:12] <jnthn> masak: prior art  in type_declarator:sym<subset>'s action method

[16:13] <masak> pmichaud: cute .classify example. I already have something a bit like that in my post.

[16:13] <masak> avar: sorry. I think my setup is weird because I've installed my own Perl(s) over the system-default one.

[16:13] <masak> avar: the result being that Parrot gets confused over where to look for my perldoc, and gets it wrong.

[16:14] <avar> sounds like you've just fatally broken if it something isn't +x

[16:14] <masak> avar: seems that instead of doing `which perldoc`, it assumes it's in the same dir as the 'perl' of `which perl`

[16:14] <avar> does it work if you chmod +x it ?

[16:14] <avar> yeah, that's what it does.

[16:14] *** qwr left
[16:14] *** lest_away is now known as lestrrat

[16:14] <masak> avar: well, I hesitate to chmod a file containing a comment with all-caps saying "DON'T CHMOD +x!"

[16:15] <masak> (paraphrased)

[16:15] <avar> DO IT

[16:15] *** ashleydev left
[16:15] <masak> :)

[16:15] <tylercurtis> masak: what's REALLY fun is when you install a new Perl in addition to the system one, but keep the system one installed, and you accidentally use the system cpan instead of cpan, and it decides to wipe the config of your new cpan executable. :)

[16:16] <masak> tylercurtis: o.O

[16:17] <masak> rakudo: my $foo = "cccc"; while $foo ~~ s/ ^^ (c) // { say "!" }

[16:17] <p6eval> rakudo 925a9b: OUTPUT«!␤!␤!␤»

[16:18] <masak> \o/

[16:19] *** lestrrat is now known as lest_away

[16:19] <tylercurtis> masak: although to be fair, it's possible that I have accidentally deleted some modules I shouldn't have from my system Perl's @INC.

[16:20] <[particle]> why 3 !'s?

[16:20] <masak> [particle]: three 'c's.

[16:20] <[particle]> i c 4

[16:20] <masak> oh wait.

[16:21] <masak> rakudo: my $foo = "cccc"; while $foo ~~ s/ ^^ (c) // { say $foo }; say "finally, $foo"

[16:21] <p6eval> rakudo 925a9b: OUTPUT«ccc␤cc␤c␤finally, ␤»

[16:21] <masak> ah.

[16:21] <[particle]> ya

[16:21] <masak> the last substitution evaluates to false.

[16:22] <tylercurtis> rakudo: ("ccc" ~~ s/ ^^ (c) //).WHAT.say

[16:22] <p6eval> rakudo 925a9b: OUTPUT«Cannot modify readonly value␤  in '&infix:<=>' at line 1␤  in 'Substitution::ACCEPTS' at line 5514:CORE.setting␤  in 'infix:<~~>' at line 411:CORE.setting␤  in main program body at line 22:/tmp/b5bxC5qyfZ␤»

[16:22] <masak> does that mean that the value of ~~ s/// is the result of the substitution?

[16:22] <masak> I'd have expected it to be $/.

[16:22] <tylercurtis> rakudo: my $foo = "ccc"; ($foo ~~ s/ ^^ (c) //).WHAT.say

[16:23] <p6eval> rakudo 925a9b: OUTPUT«Str()␤»

[16:24] <masak> pmichaud: why is the result of ~~ s/// a Str and not a Match?

[16:24] <pmichaud> masak: I don'tknow -- I didn't implement s///

[16:24] <masak> hm, I guess it is kinda parallel to += et al...

[16:24] <pmichaud> but I'm guesssing it returns $foo

[16:25] <tylercurtis> Because the spec says so.

[16:25] <pmichaud> (which remains a string)

[16:25] <tylercurtis> "method Str subst(Str $self: Regex $search, Str $replacement);"

[16:25] <tylercurtis> Or at least that the subst method returns a Str.

[16:25] <pmichaud> tylercurtis: that explains .subst, but not necessarily the smartmatch form.

[16:25] <colomon> masak: why the heck would it be a match?

[16:25] <pmichaud> smartmatch tends to be sugar for  .ACCEPTS

[16:26] <masak> colomon: because of the above use case with the while loop, for example.

[16:26] <moritz_> masak: because it's supposed to return Str

[16:26] *** Kodi left
[16:26] <masak> colomon: a successful match would make more sense with while $foo ~~ s///

[16:26] <masak> ok, so "why is it supposed to return Str?" :)

[16:27] <moritz_> because s/// is an in-place modification

[16:27] <moritz_> oh wait

[16:27] <moritz_> hm

[16:27] * colomon scratches his head.

[16:27] <moritz_> in Perl 5, it returns the number of substitutions

[16:27] <masak> in Perl 6, returning a Match would be very informative.

[16:27] <pmichaud> one can successfully argue that s/// can do the modification and return whether or not it did one.

[16:28] <pmichaud> and what masak++ said

[16:28] <masak> it's not like the resulting Str isn't in $foo anyway.

[16:28] <moritz_> right

[16:28] <colomon> right

[16:28] <masak> hence, without really having thought everything through, I vote for Match.

[16:29] <moritz_> so would s:g/// return all a list of all matches?

[16:29] <moritz_> s/all//

[16:29] <pmichaud> masak: is the match that gets returned the one that existed before the substitution?

[16:30] <masak> pmichaud: yes, I think so.

[16:30] *** ashleydev joined
[16:30] <pmichaud> (because after the substitution, the match no longer applies :-)

[16:30] <masak> which is yet another useful bit of info.

[16:30] <masak> a bit like $foo++ in that sense.

[16:30] <tylercurtis> But, wouldn't the Match be meaningless with the modified string?

[16:31] *** cdarroch joined
[16:31] *** cdarroch left
[16:31] *** cdarroch joined
[16:31] <moritz_> it stores its own .org

[16:31] <cono> rakudo: class A {method pack($format) {  while $format ~~ s/ ^^ (c) // { say $1 }; }; }; A.new.pack("ccc")

[16:31] <pmichaud> Match would still have .orig

[16:31] <moritz_> erm, orig

[16:31] <p6eval> rakudo 925a9b: OUTPUT«Null PMC access in find_method('new')␤  in 'A::pack' at line 22:/tmp/KDrB7YL6Bo␤  in main program body at line 22:/tmp/KDrB7YL6Bo␤»

[16:31] <masak> tylercurtis: the Match... what moritz_ and pmichaud said.

[16:34] <jnthn> Note taht s/// almost certainly delegates to .subst at the moment

[16:34] <moritz_> and that it is an object, and should be a call

[16:34] <pmichaud> colomon: ping

[16:34] <moritz_> ... which again requires ~~ to set $_ on the RHS

[16:34] <jnthn> moritz_: right, which is why it's not done like that yet

[16:34] <jnthn> moritz_: patches welcome.

[16:35] <moritz_> "lol"

[16:35] <moritz_> speaking of patches...

[16:35] <moritz_> I have a branch on github that add adverbs to s///

[16:35] <masak> \o/

[16:35] <moritz_> but currenlty only s:g/// works

[16:35] <colomon> pmichaud: pong

[16:35] <masak> moritz_: ship it!

[16:35] <colomon> moritz_++

[16:35] <colomon> moritz_: merge, baby, merge!

[16:35] <moritz_> wait

[16:36] <moritz_> something as simple as :g(1) gives rather weird errors

[16:36] <pmichaud> colomon: I could use some information about a commit... one moment

[16:36] * moritz_ rebuilds the branch to obtain it again

[16:36] <masak> no, don't merge. you should all 'git pull --rebase'.

[16:36] <moritz_> masak: merging "real" branches is fine :-)

[16:37] <masak> oh, indeed.

[16:37] <avar> Yeah, but there are a lot of needless merge commits in the history, especially by pmichaud :)

[16:37] <avar> pmichaud: you know, you can configure git pull to rebase by default

[16:38] <avar> git config branch.master.rebase true

[16:38] <pmichaud> http://github.com/rakudo/rakudo/commit/e298e50d6768315e3177d5d1f2929f9b5fc12e0b

[16:38] <jnthn> pmichaud: BTW, is it bug or design that if you write an action method for, say, an infix operator, the match object that gets sent in there doesn't have the operands as matches?

[16:38] <pmichaud> design

[16:38] <jnthn> pmichaud: OK. Rationale?

[16:38] <pmichaud> (think about it and it's obvious why :-)

[16:38] <pmichaud> when does the action method get invoked?

[16:39] <pmichaud> (answer:  after parsing the infix operator token)

[16:39] <jnthn> Oh.

[16:39] <masak> wow, Kodi++ actually did leap second validation in http://gist.github.com/486055 !

[16:39] <jnthn> Yes, thus reducecheck...

[16:39] * masak is impressed

[16:39] <pmichaud> right.

[16:39] <jnthn> It makes sense. It's just...not very sueful. :-)

[16:39] <jnthn> *useful

[16:40] <pmichaud> EXPR provides another action opportunity

[16:40] *** timbunce joined
[16:40] <jnthn> I know, but...then we end up with a fat EXPR.

[16:40] <jnthn> :-)

[16:40] <pmichaud> and it makes sense there, because then it occurs at the point of the reduction isntead of the point of the parse

[16:41] <jnthn> *nod*

[16:41] <jnthn> I know you've just been un-keen on EXPR accumulating stuff in the past

[16:41] <pmichaud> it's often design smell.

[16:41] <jnthn> And I look at, say, ~~ where we need to generate something different and think "ah...here goes another one..."

[16:42] <jnthn> (there aren't many now. I'm just trying to not get EXPR to the point where you come and review it some day and say "OH NO!!!" :-))

[16:43] <pmichaud> colomon: http://github.com/rakudo/rakudo/commit/e298e50d6768315e3177d5d1f2929f9b5fc12e0b

[16:43] <pmichaud> what's really going on there?

[16:43] <colomon> it's a check to see if any component of the Numeric is NaN

[16:43] <colomon> to see if they are both NaN

[16:44] <colomon> otherwise, just use ==

[16:44] <pmichaud> we need to find a much more efficient mechanism

[16:44] <colomon> profiling issues?

[16:44] <pmichaud> consider:  http://gist.github.com/486216

[16:44] <pmichaud> prior to that commit, takes 33 seconds on my box

[16:44] <pmichaud> after that commit, takes 77 seconds on my box

[16:44] <colomon> yowza!

[16:44] <moritz_> wow

[16:44] <masak> moritz_: re proto and license. proto *does* have a license already. :/

[16:45] <colomon> first obvious thought, overload Real.ACCEPTS as well

[16:45] <masak> <tadzik> moritz_: TBH, I don't see any module on proto containing a licens

[16:45] <pmichaud> keep in mind that Numeric.ACCEPTS gets called a *lot*

[16:45] <masak> moritz_: seems tadzik was (erroneously) thinking that no Perl 6 project whatsoever had a license.

[16:45] <tylercurtis> Isn't there a method for checking an array for containing something?

[16:45] <tadzik> nope

[16:45] <moritz_> masak: ah, misread

[16:45] <tadzik> masak: I meant a LICENSE file

[16:45] <colomon> If there's a Real.ACCEPTS, it will only get called when there's a Complex involved, no?

[16:46] <colomon> oh, wait.  bother.

[16:46] <masak> tadzik: you're not sounding less confused today.

[16:46] <moritz_> tylercurtis: like any(@list) == 4

[16:46] <masak> tadzik: proto has a LICENSE file.

[16:46] <tadzik> proto has, yep

[16:46] <colomon> pmichaud: why is it getting called in that program at all?

[16:46] <masak> tadzik: as do *all* of my projects. I can't speak for others :)

[16:46] <pmichaud> what's the signature for infix:<+> , etc?

[16:46] <tadzik> But I remember checking few, some of the funnier ones, LWP::Simple, Math::Model…

[16:46] <moritz_> Math::Model is pretty new

[16:47] <masak> tadzik: if there's no LICENSE file, ordinary copyright rules and no particular licensing apply.

[16:47] <tylercurtis> moritz_: wouldn't that be more efficient than grepping for all the elements that are NaN?

[16:47] * masak is not a lawyer

[16:47] <pmichaud> doing things with arrays there is wrong wrong wrong

[16:47] <colomon> pmichaud: errr... but that should be calling ~~ Numeric, not ~~ a number, no?

[16:47] <pmichaud> and .elems too

[16:48] * moritz_ puts a license notice into Math-Model

[16:48] <masak> moritz_++

[16:49] <masak> heh, "Pirate Perl Hacker". oscon-- pirates++

[16:49] <pmichaud> colomon: http://gist.github.com/486225

[16:49] <pmichaud> or maybe not

[16:49] <pmichaud> hmmm

[16:49] <pmichaud> oh

[16:49] <colomon> that's called the Numeric conversion method

[16:50] <colomon> *calling

[16:50] *** envi^home left
[16:50] <tylercurtis> What is the .reals method for?

[16:50] <TiMBuS> hey masak, you should show some hyperoperators in this here 'builtins you never knew you needed' gist

[16:50] <pmichaud> colomon: anything that has Numeric as a type constraint will call Numeric.ACCEPTS

[16:50] <colomon> why?

[16:50] <pmichaud> because that's how typeconstraints are implemented

[16:51] <masak> TiMBuS: I'm leaning towards scrapping infix:<X> right now and going with user-defined operators.

[16:51] <masak> TiMBuS: which isn't a builtin, but who's counting? :)

[16:51] <colomon> pmichaud: I'm not trying to be dense here.  As I understand it, that .ACCEPTS gets called when you say something like $x ~~ 10

[16:52] <colomon> it certainly is not doing anything useful for the $x ~~ Numeric case!

[16:52] <pmichaud> colomon: it gets called far more often than that

[16:52] <pmichaud> .ACCEPTS gets called anytime you have a type constraint

[16:52] <moritz_> why?

[16:52] <TiMBuS> the ability to define your own ops is builtin tho!

[16:52] *** xabbu42 joined
[16:52] <moritz_> pmichaud: yes, but shouldn't that be the ACCEPT method on the type object?

[16:52] <pmichaud> moritz_: yes.

[16:52] <pmichaud> Numeric is the type object here.

[16:53] <colomon> pmichaud: he means, on the metaobject, I think.

[16:54] <pmichaud> colomon: I don't know what you mean by metaobject.

[16:54] <TiMBuS> oo heres a cool use of a hyperoperator i just found: @altnicks = $nick «~« ("_","__",^10); #Spare nicknames in the case of a nick collision

[16:54] <pmichaud> rakudo:  class Foo { method ACCEPTS($x) { say "Foo.ACCEPTS"; } };  my Foo $x;  $x = 5;

[16:54] <p6eval> rakudo 220b67: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/VRzh0_eo9t␤»

[16:54] <moritz_> so, not called

[16:55] <pmichaud> okay

[16:55] <masak> rakudo: class A { method pack($_) { s/c// }}; A.new.pack("ccc") # discovered by cono++

[16:55] <pmichaud> I understand now.

[16:55] <p6eval> rakudo 220b67: OUTPUT«Null PMC access in find_method('new')␤  in 'A::pack' at line 22:/tmp/s19cKkLaRU␤  in main program body at line 22:/tmp/s19cKkLaRU␤»

[16:55] * masak submits rakudobug

[16:55] <pmichaud> that said,

[16:55] <pmichaud> the commit I referenced slows that example program down by a factor of 2+

[16:55] *** patspam joined
[16:55] <colomon> pmichaud: sure, and I'd like to fix it ASAP.

[16:55] <colomon> I just don't understand why it would even be called in your example code.

[16:55] *** zenog joined
[16:56] <TiMBuS> rakudo: (1,4, {$^b*2 + 2 - $^a} ... 50).perl.say; #squares using '...'

[16:56] <colomon> you're sure it's that particular commit and not just one near it?

[16:56] <p6eval> rakudo 220b67: OUTPUT«(1, 4, 9, 16, 25, 36, 49)␤»

[16:56] <pmichaud> I'll double check

[16:56] <pmichaud> but that's where git-bisect ended up

[16:56] <zenog> Hi guys, how can I invoke functions via references in Perl 6? Like this: &$fun_ref(1); ?

[16:57] <moritz_> zenog: $fun.()

[16:57] <justatheory> What's the shortcut for `my $foo is Foo::Bar = Foo::Bar.new`?

[16:57] * colomon is kind of hoping .ACCEPTS is getting called incorrectly there, and we can make things even faster by eliminating that call.

[16:57] <moritz_> zenog: or just $fun()

[16:57] <moritz_> justatheory: my Foo::Bar $foo .= new

[16:57] <justatheory> moritz_++ # that's right.

[16:58] <pmichaud> even if we eliminate that call, I'm not comfortable with the ACCEPTS 

[16:58] <moritz_> justatheory: my $x is type; is probably not what you want - it specifies the container type, not the type of the content

[16:58] <pmichaud> again, it puts things into arrays that ought not to be arrayed

[16:58] <colomon> pmichaud: it surely can be better.

[16:58] <zenog> moritz_: Is this possibly not implemented yet?

[16:58] <zenog> moritz_: I mean in Rakudo.

[16:59] <justatheory> moritz_: Right, I want to do both at once, without typing Foo::Bar twice.

[16:59] <tylercurtis> rakudo: my $foo = sub ($s) { say $s; }; $foo("hey, zenog");

[16:59] <p6eval> rakudo 220b67: OUTPUT«hey, zenog␤»

[16:59] <colomon> hmmm... I guess while you check on the exact commit causing the trouble, I can try optimizing that against your code.

[16:59] <tylercurtis> zenog: it appears to work.

[16:59] <moritz_> zenog: it's implemented for over a year now

[17:00] <tylercurtis> justatheory: I don't think you do want to specify the container type.

[17:00] *** Mowah left
[17:00] <justatheory> tylercurtis: I'm in a ROb Pike talk at OSCON in which he thinks static typing is really important, but the syntax in C++ and Java sucks.

[17:00] <justatheory> Was trying to remember how Perl 6 solved that problem.

[17:01] <colomon> pmichaud: woah, there already is a Real.ACCEPTS.  huh.

[17:01] <tylercurtis> justatheory: my Foo::Bar $foo .= new;

[17:01] <justatheory> But I agree, I often wouldn't specify the container type, myself.

[17:01] <tylercurtis> justatheory: container type is not the variable type.

[17:01] <justatheory> tylercurtis: Yeah, that's what moritz_ said.

[17:01] <moritz_> the 'is' syntax is for cases like  my Foo $x is ORMMapped .= new()

[17:02] *** Trashlord left
[17:02] <moritz_> where ORMMapped is a type that inherits from SCALAR or so

[17:03] <pmichaud> colomon:  confirmed, that's the commit that does the slowdown

[17:04] <jnthn> pmichaud: got link to the commit to hand?

[17:04] <pmichaud> http://github.com/rakudo/rakudo/commit/e298e50d6768315e3177d5d1f2929f9b5fc12e0b

[17:04] <jnthn> (sorry if it was earlier - watching some seminar at $dayjob today so mostly distracted)

[17:04] <colomon> pmichaud: I think something has to be seriously wrong someplace in there, because as I understand it, that code should only be called if you are calling ACCEPTS on a Complex number, and there are no Complex numbers in that code at all.

[17:04] <pmichaud> as of the previous commit, that benchmarks runs in 33 sec on my box

[17:04] *** dakkar left
[17:04] <pmichaud> colomon: why only on a Complex?

[17:04] <pmichaud> wouldn't it be called on anything that "does Numeric"?

[17:05] <colomon> because there's a Real.ACCEPTS that should be called on anything that does Real.

[17:05] <pmichaud> what about Int?

[17:05] <moritz_> rakudo: say Int ~~ Numeric

[17:05] <colomon> rakudo: say Int ~~ Real

[17:05] <p6eval> rakudo 220b67: OUTPUT«1␤»

[17:06] <pmichaud> Well, Real.ACCEPTS didn't get added until later, so let me try that commit.

[17:06] <moritz_> so, how is the .ACCEPTS method selected?

[17:06] <moritz_> rakudo: say Real ~~ Numeric

[17:06] <p6eval> rakudo 220b67: OUTPUT«1␤»

[17:07] <moritz_> every class that 'does Real' gets both

[17:07] <colomon> it should be like any method, shouldn't it?  you use the most specific one available

[17:07] <pmichaud> oh, Real.ACCEPTS is slow also.

[17:07] <pmichaud> (if self eq NAN, I guess.)

[17:08] <pmichaud> but then it calls &infix:<==>

[17:08] <pmichaud> that looks evil

[17:08] <moritz_> rakudo: multi f(Real $) { say "real" }; multi f(Numeric $) { say "numeric" }; f(3)

[17:08] <jnthn> moritz_: Real ~~ Numeric too

[17:08] <p6eval> rakudo 220b67: OUTPUT«real␤»

[17:08] <jnthn> So the Real one wins

[17:08] <colomon> the self eq NaN stuff is how the old versions worked as well.

[17:08] <moritz_> jnthn: so they are all multi, and dispatch on the invocant, right?

[17:09] <pmichaud> ACCEPTS isn't multi (yet)

[17:09] <colomon> ACCEPTS can be multi

[17:09] <jnthn> moritz_: No, just because Real's ACCEPTS masks the one from Numeric

[17:09] <jnthn> ooh, back to the seminar...bbl

[17:09] <moritz_> jnthn: I thought all roles are composed flatly?

[17:09] <colomon> but the multi gets all tangled up with the roles.

[17:10] <masak> jnthn: I still hope to make enums a bit more awesome before the release. looking at it now. I could use some minimal hand-holding, if you're not too distracted.

[17:10] <colomon> pmichaud: I switched Numeric.ACCEPTS to skip all the NaN stuff, and that didn't change the execution time at all.

[17:11] <colomon> I think the problem may have been that the old Int.ACCEPTS was cheating

[17:11] *** zenog left
[17:11] <colomon> rakudo: say NaN == NaN

[17:11] <p6eval> rakudo 220b67: OUTPUT«0␤»

[17:11] <masak> jnthn: basically, what I want to do is turn src/glue/enum.pir into Perl 6. or at least the !setup_named_enum sub.

[17:11] *** ashleydev left
[17:11] <tylercurtis> rakudo: say NaN ~~ Int

[17:11] <p6eval> rakudo 220b67: OUTPUT«0␤»

[17:12] <colomon> that is to say, Int.ACCEPTS(Int) just called == on its arguments, which means it would get the wrong answer for NaN

[17:12] *** justatheory left
[17:12] <pmichaud> fwiw, I don't think that Real.ACCEPTS should be calling &infix:<==>

[17:12] <tylercurtis> colomon: that wouldn't be called on NaN, would it?

[17:12] <masak> jnthn: I think I'll start by writing that out as Perl 6. but after that, where in src/ do I put the code? not src/core, right?

[17:12] <colomon> tylercurtis: Int is supposed to have a NaN value

[17:12] <colomon> it currently doesn't because our current Int is crippled

[17:13] *** Mowah joined
[17:13] <moritz_> pmichaud: Any       Numeric   numeric equality        +$_ == X

[17:14] <colomon> pmichaud: what do you think it should do?  all the old numeric .ACCEPTS methods were done with infix:<==> at some point. (that is, possibly they would call another .ACCEPTS function that did it instead of doing it themselves.)

[17:14] <pmichaud> normally I think that operators should be defined in terms of methods, not vice-versa.

[17:14] <pmichaud> anyway, I'll let it go for now.

[17:15] <pmichaud> what I do know is that we get a significant slowdown there, and it hurts.

[17:15] <pmichaud> the example code there comes from a reddit post where someone complained about how slow rakudo was

[17:15] <pmichaud> and they tested it against Kiev, which was *before* the additional slowdown introduced by this .ACCEPTS change

[17:16] *** thebird left
[17:16] <pmichaud> so if they go back and check it on current trunk, they'll see that Rakudo Atlanta is 200% slower than Kiev was.

[17:16] <colomon> I suspect if you can figure out why it is calling Int.ACCEPTS, you'll have the answer.

[17:16] <cxreg> lastlog biff 4

[17:16] <pmichaud> ..."you"?   ;-)

[17:16] <cxreg> oops

[17:16] <colomon> "we"...

[17:16] <pmichaud> colomon: aren't you the numeric expert?  ;-)

[17:17] <colomon> yes, but I'm not the "why the hell is the type system doing THAT?!" expert.

[17:17] <pmichaud> as you said, it's not the type system in this case.

[17:17] <pmichaud> at least, it shouldn't be.

[17:17] <colomon> let me see if I can overload Int.ACCEPTS and speed things up.

[17:17] <tylercurtis> colomon: where in the spec does it say NaN ~~ Int?

[17:17] <pmichaud> sure, but I'd really like to know why it's slow.

[17:17] <pmichaud> oh, hmmmm.

[17:17] <colomon> "it shouldn't be" is the key, I suspect.

[17:18] <pmichaud> rakudo:  role XYZ { method ACCEPTS($x) { say "XYZ.ACCEPTS"; } };  sub abc(XYZ $x) { say "abc $x"; };  abc(3);

[17:18] <p6eval> rakudo 220b67: OUTPUT«Nominal type check failed for parameter '$x'; expected XYZ but got Int instead␤  in 'abc' at line 22:/tmp/Y1NvZS5OFE␤  in main program body at line 22:/tmp/Y1NvZS5OFE␤»

[17:18] <masak> huh.

[17:19] <pmichaud> sure, makes sense

[17:19] <pmichaud> I also need an  "Int does XYZ"

[17:19] <masak> oh, right.

[17:19] <moritz_> rakudo:  role XYZ { method ACCEPTS($x) { say "XYZ.ACCEPTS"; }; class A does XYZ { }; A.new ~~ XYZ

[17:19] <p6eval> rakudo 220b67: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[17:19] <moritz_> rakudo:  role XYZ { method ACCEPTS($x) { say "XYZ.ACCEPTS" } }; class A does XYZ { }; A.new ~~ XYZ

[17:19] <pmichaud> rakudo:  role XYZ { method ACCEPTS($x) { say "XYZ.ACCEPTS"; } };  sub abc(XYZ $x) { say "abc $x"; }; class A does XYZ { };  abc(A.new);

[17:19] <p6eval> rakudo 220b67:  ( no output )

[17:19] <p6eval> rakudo 220b67: OUTPUT«abc A()<0x7cb0960>␤»

[17:21] <pmichaud> okay, I'm satisfied it's not the type constraints causing the ACCEPTS, at least not directly.

[17:21] <pmichaud> but *something* slows it down.

[17:21] <colomon> would looking at the PIR help?  

[17:21] <colomon> (my wife always says "have you tried looking at the picture?" when I have $work frustrations)

[17:21] <pmichaud> it might.  I have to go elsewhere in the conference now, though

[17:22] <moritz_> I have a weird idea... maybe some non-printable Unicode character sneaked in, and caused parsing slowness?

[17:22] <pmichaud> it would be very nice if this gets fixed before the release.  it's undoubtedly slowing us down immensely

[17:22] <colomon> agreed.

[17:22] <pmichaud> because, as we can see -- the example is pretty basic operations

[17:22] <masak> aye.

[17:22] <colomon> dang it, every thing I've tried so far has just made things slightly slower...

[17:23] <colomon> (47s, 48s, 49s ...)

[17:23] <moritz_> rakudo: printf '%x', 127

[17:23] <pmichaud> afk for a bit

[17:23] <p6eval> rakudo 220b67: OUTPUT«7f»

[17:23] <pmichaud> exit

[17:23] <pmichaud> ww

[17:24] <colomon> does say work in the CORE again yet?

[17:25] <tylercurtis> moritz_: shouldn't "my %exists = @keys Z=> 1 xx *;" be "my %exists = @keys Z=> True xx *;"

[17:25] <tylercurtis> moritz_: in http://perlgeek.de/blog-en/perl-5-to-6/27-common-idioms.html

[17:25] <moritz_> colomon: no idea, I usually use pir::printerr__vS("string\n")

[17:25] <PerlJam> tylercurtis: you don't like 1 as a true value?

[17:25] <moritz_> tylercurtis: doesn't really matter for the typical use case

[17:25] <colomon> moritz_++ 

[17:26] *** mberends left
[17:27] <PerlJam> rakudo: say (?1).WHAT

[17:27] <p6eval> rakudo 220b67: OUTPUT«Bool()␤»

[17:27] <masak> (1) someone writes pie-in-the-sky proposals on p6l, (2) moritz_ points out "the tools are already there, you're just using the wrong one; leave well enough alone", (3) necro-equine flagellation continues unabated

[17:27] <tylercurtis> It doesn't really matter, but a bit clearer, no, when the explanation is "create a hash from an array, with true value for each array item:"?

[17:28] <tylercurtis> Mentally move the "no" to the end of the sentence in your mind, please.

[17:29] <moritz_> masak: I can understand the want for having an index, it's a very natural urge to make the tool you're currently looking at more powerful

[17:29] <masak> moritz_: aye.

[17:29] <moritz_> masak: what it means for me is to ignore the remainder of thread, with the knowledge that I've tried, at least.

[17:29] <masak> I've had the same thought, fwiw.

[17:29] <moritz_> thing is, infix:<...> is slow already

[17:29] <masak> aye.

[17:30] <masak> class Thread { has $!ignore-switch; }

[17:30] <moritz_> people will ask "why is this slower than loop (my $x = 0; $x <10; $x+=2) { ... }"

[17:30] <moritz_> ?

[17:30] <colomon> rakudo: say (1, -> *@a { +@a * +@a } ... *).munch(10).perl

[17:30] <p6eval> rakudo 220b67: OUTPUT«(1, 1, 4, 9, 16, 25, 36, 49, 64, 81)␤»

[17:30] <moritz_> "because we introspect the signature of the block to see if it accepts a named 'i' parameter

[17:30] <moritz_> "

[17:31] <PerlJam> colomon: cute

[17:31] <moritz_> btw, comming back to my s:g/// branch

[17:31] <tylercurtis> masak: to be fair, Perl 6 is something of a pie-in-the-sky sort of language, itself.

[17:31] <moritz_> ./perl6 -e 's:g(1)/a/a/'

[17:31] <moritz_> ===SORRY!===

[17:31] <moritz_> undefined identifier 'Capture'

[17:32] <moritz_> let me just say "wtf?"

[17:32] <masak> tylercurtis: right, in the sense that it promises people lots of futuristic, cool stuff.

[17:33] <moritz_> interestingly the PAST output doesn't contain any references to "Capture" at all

[17:33] <PerlJam> colomon: though, looking at the result, that doubled 1 bothers me enough that I would have started with 0 rather than 1  :)

[17:33] <colomon> rakudo: say (-> *@a { +@a * +@a } ... *).munch(10).perl

[17:33] <moritz_> neither after the POST stage

[17:33] <p6eval> rakudo 220b67: OUTPUT«(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)␤»

[17:33] <masak> tylercurtis: p6l will probably always be the place where abstraction astronauts, type theoreticians, and people who want to make every tool in the toolbox into a swiss army knife. that's probably the natural order of things.

[17:33] <colomon> PerlJam: starting with zero wouldn't help.

[17:34] <PerlJam> rakudo: say (0, -> *@a { +@a * +@a } ... *).munch(10).perl

[17:34] <p6eval> rakudo 220b67: OUTPUT«(0, 1, 4, 9, 16, 25, 36, 49, 64, 81)␤»

[17:34] <moritz_> I think it does help

[17:34] <PerlJam> sure it would!

[17:34] <moritz_> 1 element with value 0

[17:34] <masak> src/glue/enum.pir turns out to be too hard for my poor little brain :/ I don't even know where to start.

[17:34] <masak> and jnthn seems to be un-about.

[17:35] <colomon> PerlJam: ah.  the generated elements are exactly the same, you're just changing the first element so it doesn't stand out.

[17:35] * masak hacks a bit on sekkrit project in the meantime

[17:35] <moritz_> masak: your GSOC thing? :-)

[17:35] <pmichaud> back again, briefly

[17:35] <masak> moritz_: er. yes. absolutely.

[17:35] <masak> that's what I meant. the GSoC thing.

[17:35] <colomon> okay, Real.ACCEPTS is what is going slow, in the current code.

[17:35] <colomon> it's getting called a zillion times.

[17:36] <PerlJam> colomon: right, same as say (0..* Z* 0..*).munch(10).perl

[17:36] <pmichaud> as a general code review remark

[17:36] <PerlJam> colomon: (i.e. start the squares at 0)

[17:36] *** timbunce left
[17:36] *** cono left
[17:36] <pmichaud> the line

[17:36] <pmichaud>         if @a.grep("NaN").elems > 0 {

[17:36] <pmichaud> is pretty bad

[17:36] <colomon> could be any(@a) eq "NaN"

[17:37] <pmichaud> best is

[17:37] <masak> why string comparison?

[17:37] <colomon> but it's totally not the source of the problem here

[17:37] <PerlJam> um, why are stringifying NaN?

[17:37] <pmichaud>         if @a.grep("Nan") { 

[17:37] <colomon> masak: do you have a better way of detecting NaN?

[17:37] <pmichaud>         if @a.grep("NaN") { 

[17:37] <pmichaud> .elems > 0 turns a boolean lazy operation into an eager one

[17:37] <masak> colomon: there probably should be one.

[17:37] <colomon> masak: agreed, actually

[17:37] <moritz_> rakudo: say pir::isnan__ip(NaN)

[17:38] <p6eval> rakudo 220b67: OUTPUT«error:imcc:syntax error, unexpected IREG, expecting '(' ('$I114')␤ in file 'EVAL_8' line 79␤===SORRY!===␤syntax error ... somewhere␤»

[17:38] <masak> colomon: .isNaN or sump'n

[17:38] <pmichaud> ohhhhhhhhhh

[17:38] <masak> pmichaud: right, .first would be enough here.

[17:38] <pmichaud> keep in mind that .grep calls ACCEPTS :-)

[17:38] <pmichaud> and so does .first

[17:38] <colomon> ?(@a).grep("NaN")

[17:38] <pmichaud> even the ? is superfluous in an if statement

[17:39] <colomon> pmichaud: don't know if you saw what I said back there, but I've added prints to the code, and Real.ACCEPTS is what is getting called a zillion times in the current version.

[17:39] <pmichaud> colomon: sure, okay

[17:39] <colomon> not that it is great

[17:39] <PerlJam> I don't get it.   Why doesn't  if @a.grep(NaN) { ... }  work?

[17:40] <pmichaud> that might work as well

[17:40] <colomon> PerlJam: it would, but it would be doing eq "NaN" internally

[17:40] <pmichaud> I was simply commenting on the   .elems>0  evilness

[17:40] <tylercurtis> rakudo: say NaN ~~ NaN

[17:40] <p6eval> rakudo 220b67: OUTPUT«1␤»

[17:41] <PerlJam> colomon: are you sure?

[17:41] <PerlJam> rakudo: say NaN.WHAT

[17:41] <tylercurtis> rakudo: (1, 2, NaN, 4, 5, NaN).grep(NaN).say

[17:41] <p6eval> rakudo 220b67: OUTPUT«Num()␤»

[17:41] <p6eval> rakudo 220b67: OUTPUT«NaNNaN␤»

[17:41] <colomon> tylercurtis: right.  that calls Num.ACCEPTS, which did in the old version self eq 'NaN'

[17:41] <pmichaud> afk, in a talk

[17:41] <moritz_> PerlJam: I can confirm, NaN testing is done by string

[17:42] <PerlJam> moritz_: okay, but that happens "under the covers", we should still treat NaN as NaN in Perl

[17:42] <colomon> okay, taking the NaN check out of Real.ACCEPTS gets me my first speed up of this investigation

[17:42] *** zulon left
[17:42] <PerlJam> (and it works AFAICS)

[17:42] <moritz_> PerlJam: but the built-in ACCEPT methods count as "Under the cover"

[17:43] <colomon> PerlJam: you're proposing I try to optimize the code by performing the exact same operation, only with an additional level of indirection.

[17:44] <tylercurtis> rakudo: say NaN.defined

[17:44] <PerlJam> colomon: No, I'm just reacting to an oddly stringified NaN.  :-)   I wasn't paying attention long enough to see that you were trying to optimize something.  Sorry.

[17:44] <p6eval> rakudo 220b67: OUTPUT«1␤»

[17:45] <colomon> masak, moritz_: can one of you guys figure out the magic pir op to do a NaN check?  that would be a big help here no matter what we do.

[17:45] <tylercurtis> O.o

[17:45] <moritz_> colomon: just tried without success... will ask in #parrot

[17:46] <colomon> moritz_++

[17:46] <pmichaud> I don't think there's a magic pir op for a nan check, fwiw

[17:46] <colomon> also, someone think of a good name for a "is NaN" method.  :)

[17:46] <pmichaud> .oO(methods are slow...)

[17:46] <moritz_> is there anything that's not slow?

[17:47] <moritz_> except for pir:: stuff, maybe?

[17:47] <pmichaud> moritz_: good point.  :)

[17:47] <tylercurtis> colomon: isNaN? :)

[17:47] <colomon> calling Real.ACCEPTS unnecessarily thousands of times is really slow. 

[17:47] <pmichaud> colomon: prove it's unnecessary, first :)

[17:47] <masak> colomon: .isNaN

[17:48] <pmichaud> I'm not sure it should be a method.  I feel that's a design flaw.

[17:48] * [Coke] wonders why "munch" and not "head". 

[17:48] <pmichaud> [Coke]: because it consumes

[17:49] <pmichaud> [Coke]: as opposed to simply producing the leading elements but leaving them in the list

[17:49] <sbp> why is NaN a Num()?

[17:49] <sbp> that seems extremely confusing

[17:49] <moritz_> what should it be?

[17:49] <tylercurtis> sbp: because a Num is a machine-precision floating-point number.

[17:49] <PerlJam> moritz_: Not a Number  :)

[17:49] <pmichaud> afk

[17:49] <moritz_> tylercurtis++

[17:49] <tylercurtis> sbp: and a NaN is the undefined value for machine-precision floating-point numbers.

[17:49] <colomon> pmichaud: what, if not a method?

[17:50] <sbp> why not Float() then?

[17:50] <moritz_> sbp: because our floats are called Num

[17:50] <colomon> sbp: there is no such type

[17:50] <[Coke]> pmichaud: I almost would prefer shift() then. =-)

[17:50] <sbp> interesting divergent perspectives on the intent of my question... :-)

[17:51] *** justatheory joined
[17:51] <rokoteko> do you expect to pass a Not A Number to f.ex. a sub that expects a Num?

[17:51] <tylercurtis> A question: if Num is machine-precision floating point, then what's the difference between Num and num?

[17:52] <moritz_> rokoteko: most subs that expect a number should acccept Real or Numeric in their signature

[17:52] <moritz_> tylercurtis: for example Num can hold undefined value, can have mix-ins etc.

[17:52] <masak> nom &

[17:52] *** masak left
[17:52] <rokoteko> so NaN can be a numeric value that is undefined?

[17:53] <colomon> okay, this is interesting.  If I comment out the /= and += lines, the script has only about 40 calls to Real.ACCEPTS (versus 20,000 for the full version)

[17:53] <tylercurtis> moritz_: speaking of undefined values...

[17:53] <tylercurtis> rakudo: say NaN.defined

[17:53] <p6eval> rakudo 220b67: OUTPUT«1␤»

[17:53] <moritz_> colomon: that seems very odd

[17:53] <tylercurtis> Should that be the case?

[17:54] <moritz_> tylercurtis: I haven't seen anything to counter-indicate that

[17:54] <colomon> tylercurtis: yes

[17:54] *** smash__ left
[17:54] <moritz_> tylercurtis: .defined is really more like "is this an object instance" (as opposed to type objects)

[17:54] <tylercurtis> It seems like "Since num can support the value NaN but not the general concept of undefinedness, you can coerce an undefined value like this:" seems to me to imply that NaN is a specific concept of undefinedness.

[17:55] <moritz_> colomon: #parrot says string comparison is the way to test for NaN on parrot

[17:55] <colomon> moritz_: aiiiiiiiiieeeeeee!

[17:56] <colomon> moritz_: it gets better.  if I add in one of the /= lines, I get 237 calls to Real.ACCEPTS.  If I add in the second, I get 16037.

[17:57] <[Coke]> how is /= implemented?

[17:58] <colomon> [Coke]: automatically generated from /, which in this case is Rat / (all but the first time you call it)

[17:58] *** timbunce joined
[17:58] <colomon>     ($a.numerator * $b.denominator) / ($a.denominator * $b.numerator);

[17:58] <colomon> oh, wait

[17:58] <colomon> multi sub infix:<*>(Rat $a, Int $b) {

[17:58] <colomon>     ($a.numerator * $b) / $a.denominator;

[17:58] <colomon> }

[17:58] <colomon> is the one probably being called

[17:59] <tylercurtis> Is there any reason why "$foo != $foo" won't work for NaN-checking of Reals in Perl 6?

[17:59] <moritz_> rakudo: say NaN != NaN

[17:59] <colomon> tylercurtis: hmmmm.....

[17:59] <p6eval> rakudo 220b67: OUTPUT«1␤»

[18:00] <moritz_> rakudo: say Inf == Inf

[18:00] <colomon> oh, maybe I have it.

[18:00] <p6eval> rakudo 220b67: OUTPUT«1␤»

[18:00] <tylercurtis> colomon: that's what NotFound suggested in #parrot, and it's the definitive way in lower-level languages iirc.

[18:01] <moritz_> C has an isnan function

[18:02] <colomon> every time we call Real.sign, we call ~~ NaN

[18:03] <colomon> might be the problem?

[18:03] *** xabbu42 left
[18:06] <colomon> boo-ya!

[18:07] <colomon> taking the ~~ NaN out of Real.sign eliminated all but 6 of the calls to Real.ACCEPTS

[18:07] <colomon> guess it's not the type system after all.

[18:07] <PerlJam> colomon++

[18:08] <colomon> okay, at this point the only thing stopping me from a patch is pmichaud's mysterious comment that he doesn't thing a method is the thing for detecting NaN.

[18:08] <jnthn> phenny: tell masak often src/glue is a good place for such things. See e.g. src/glue/subset.pm

[18:08] <phenny> jnthn: I'll pass that on when masak is around.

[18:09] <jnthn> phenny: tell masak also see how it's handled in the makefile

[18:09] <phenny> jnthn: I'll pass that on when masak is around.

[18:09] <PerlJam> colomon: make a patch anyway.   Better an incremental improvment than none at all  :)

[18:11] <colomon> aha!  every time you construct a Rat, it calls div twice.  Every time you call div, it calls .sign twice.  Every time you call .sign, it smartmatches against ~~ NaN.

[18:12] <jnthn> colomon: Whoa!

[18:12] <jnthn> colomon: I can imagine that being un-fast.

[18:13] <colomon> particularly when, every time you call ~~ NaN, it stringifies two numbers and does a string comparison.

[18:13] <PerlJam> If parrot/rakudo had something like Devel::NYTProf, I bet that would have been spotted easier.

[18:13] <colomon> PerlJam: agreed

[18:14] <colomon> for sure, I would think, as long as you had a rough call graph.

[18:15] *** cono joined
[18:16] <tylercurtis> Parrot has some sort of profiling stuff, I think, not sure how well it works, though. One of the Parrot GSoC students is doing profiling stuff, too. 

[18:17] * jnthn afk again 

[18:18] <colomon> rakudo: say ?NaN

[18:18] <p6eval> rakudo 220b67: OUTPUT«1␤»

[18:20] <PerlJam> Hmm.  is there an "unzip" operator yet?

[18:21] <colomon> PerlJam: classify?  (not an op, obviously...)

[18:22] *** isBEKaml joined
[18:26] <PerlJam> If this hypothetical unzip op were U, it would be such that after, (@a Z @b) U (@A,@B), @a and @A would be the same (@b and @B too)

[18:27] <PerlJam> and that leads me to wonder if there is any equivalent to fork or tee for feeds.

[18:28] <PerlJam> I guess fork would just be clone with the proper initialization of state

[18:28] <colomon> PerlJam: you can stick "my @a" in the middle of a feed to copy the info at that point in the feed, I think.

[18:30] *** timbunce left
[18:32] <tylercurtis> rakudo: (1...100) ==> map: * ** 2 ==> my @a ==> grep: * %% 2 ==> my @b; @a ==> grep: * %% 3 ==> my @c; Set.new(@b).intersection(Set.new(@c)).perl.say

[18:32] <p6eval> rakudo 220b67: OUTPUT«===SORRY!===␤Confused at line 22, near "(1...100) "␤»

[18:32] <tylercurtis> rakudo: (1, 2 ... 100) ==> map: * ** 2 ==> my @a ==> grep: * %% 2 ==> my @b; @a ==> grep: * %% 3 ==> my @c; Set.new(@b).intersection(Set.new(@c)).perl.say

[18:32] <p6eval> rakudo 220b67: OUTPUT«===SORRY!===␤Confused at line 22, near "(1, 2 ... "␤»

[18:32] <pmichaud> colomon: where would .isNaN belong...?

[18:33] <colomon> pmichaud: each type would have its own.

[18:33] *** timbunce joined
[18:33] <Util> I am trying to get the location of the configured&installed parrot from within Rakudo. Does Perl6 have some equivilant to Perl5 %Config from `use Config`, or somewhere else I might find Parrot's location? 

[18:33] <pmichaud> so, a method on Cool?  Any?

[18:33] <colomon> which would let us optimize the Int and Rat cases for now.

[18:34] <colomon> hmmm.... on Cool too, maybe.

[18:34] <pmichaud> Util:  $*VM<config>  

[18:34] <colomon> I think I've got an optimization worked out that doesn't need .isNaN.

[18:34] <pmichaud> Util: (I think)

[18:34] <colomon> (BTW)

[18:34] <pmichaud> yes, checking for NaN sounds terribly inefficient in general.

[18:34] <colomon> but it will be a compromise, isNaN is still needed for best efficiency.

[18:34] <pmichaud> so we should avoid doing it

[18:35] <colomon> pmichaud: it would require a spec change to do away with it.

[18:35] <colomon> and my inclination is that it is probably to have it.

[18:35] <[Coke]> ENOPARSE

[18:36] <colomon> ack, my inclination is that having .ACCEPTS check for NaN is a good thing.

[18:36] <pmichaud> what type is NaN ?

[18:36] <colomon> pmichaud: all numeric types have a NaN value, in theory

[18:37] <colomon> though TimToady and I discussed making it a numeric type of its own at one point.

[18:37] <PerlJam> my $a = "hello";   say $a.isNaN;   #  :-)

[18:38] <Util> pmichaud: Worked; thanks!

[18:38] *** markjreed joined
[18:39] <[Coke]> rakudo: say $*VM<config>.perl

[18:39] <p6eval> rakudo 220b67: OUTPUT«Cannot substr on a null string␤  in 'Pair::perl' at line 1␤  in <anon> at line 4530:CORE.setting␤  in 'Any::join' at line 1␤  in 'EnumMap::perl' at line 4530:CORE.setting␤  in main program body at line 22:/tmp/hsc2BK1p5R␤»

[18:39] <markjreed> rakudo: say (1,2,4,...*)[0..10].perl

[18:39] <p6eval> rakudo 220b67: OUTPUT«===SORRY!===␤Comma found before apparent series operator; please remove comma (or put parens␤    around the ... listop, or use 'fail' instead of ...) at line 22, near "...*)[0..1"␤»

[18:39] <colomon> making .isNaN a standard numeric method would get around all of the array nonsense, and also all us to detect NaN internally without using ACCEPTS.

[18:39] <markjreed> rakudo: say (1,2,4...*)[0..10].perl

[18:39] <p6eval> rakudo 220b67: OUTPUT«(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024)␤»

[18:39] * pmichaud considers ['parrot';'Hash';'perl'

[18:39] <pmichaud> colomon: make it a method for now.

[18:40] <[Coke]> I'm thinking $*VM<config> shouldn't be a parrot hash.

[18:40] <[Coke]> at least not until HLL interop is more likely to work.

[18:40] <markjreed> huh.  locally I get n/1 for all the generated elements of the series..

[18:40] <pmichaud> technically that is HLL interop working :-)

[18:40] <colomon> pmichaud: okay.

[18:40] <[Coke]> pmichaud: ... fair enough.

[18:41] <pmichaud> [Coke]: since a parrot Hash doesn't have a .perl method :-)

[18:41] * [particle] ponders a visual cue on p6 error messages, like camelia with a broken wing

[18:41] <pmichaud> (yes, it's a reasonable thing to say that Rakudo should wrap the parrot config hash with its own)

[18:42] <[Coke]>  »ö≤

[18:44] <colomon> pmichaud: I have a very simple patch that makes the execution time go from 48s to 27s locally.  :)

[18:45] <pmichaud> colomon: please apply if spectests pass.

[18:45] <pmichaud> I _really_ don't want a huge speed hit between kiev and atlanta.

[18:47] *** markjreed left
[18:50] <[Coke]> ... but I want to cut the release NOW!

[18:50] <[Coke]> . o O (kidding)

[18:50] <colomon> just one spectest....

[18:50] <colomon> .oO(I hope)

[18:52] <patrickas> rakudo: say ~(1, -2, 4 ... 1/2);

[18:52] <p6eval> rakudo 220b67:  ( no output )

[18:53] <patrickas> rakudo and series.t seem to agree this is the correct behaviour, but I think that's not according to spec, it should be an infinite series right ? 

[18:54] <colomon> patrickas: nope

[18:54] <[Coke]> phenny: U+263A

[18:54] <colomon> errr... wait, unless that special rule comes into play.  :\

[18:55] <moritz_> .u 263A

[18:55] <phenny> U+263A WHITE SMILING FACE (☺)

[18:55] *** justatheory left
[18:55] <patrickas> shouldn't (1, -2, 4 ... 1/2) behave similarly to "1,-1/2,1/4 ... 0   # like 1,-1/2,1/4 ... *" <- from the spec

[18:55] <patrickas> oh no it should not

[18:55] <patrickas> silly me

[18:56] <colomon> patrickas: are you sure?

[18:56] <PerlJam> patrickas: should be Nil by my reading of the spec

[18:57] <colomon> oh, yup, nill

[18:57] <colomon> Nil

[18:57] <colomon> "if a supplied limit value is on the "wrong" side of the first value of the full left list, Nil is returned, even though the limit value never matches, and never falls between two generated values."

[18:57] <colomon> and "For a geometric series with sign changes, the same criterion is used, but applied only to the absolute valu"

[18:57] <colomon> *value

[18:58] <patrickas> ok i see

[18:58] <colomon> rakudo: say ~(1, 2, 4 ... 1/2)

[18:58] <p6eval> rakudo 220b67: OUTPUT«␤»

[18:59] <PerlJam> rakudo: say ~(1, -2, 4 ... 2)

[18:59] <p6eval> rakudo 220b67:  ( no output )

[18:59] <lue> ohai o/

[18:59] <PerlJam> I don't think that one is correct.

[18:59] <colomon> now that one is wrong, no?

[19:00] <colomon> someone add the test case...

[19:00] <moritz_> why?

[19:00] <moritz_> rakudo: say ~(1, 2, 4 ... 2)

[19:01] <p6eval> rakudo 220b67:  ( no output )

[19:01] <moritz_> same thing, just without the sign change

[19:01] <moritz_> oh wait

[19:01] <moritz_> this loops infinitely, no?

[19:01] <PerlJam> that's wrong too  :)

[19:01] <patrickas> say ~(1, 2, 4 ... 2) this should return 1 ,2

[19:01] <colomon> what patrickas  said

[19:01] *** justatheory joined
[19:02] <moritz_> and what should (1, -2, 4, ... 2) be?

[19:02] <PerlJam> 1, -2

[19:04] <pugssvn> r31787 | moritz++ | [t/spec] increasing geometric series, with and without sign change. colomon++, PerlJam++ 

[19:04] <colomon> moritz_++

[19:05] <PerlJam> Hrm.

[19:05] *** cono left
[19:05] <PerlJam> rakudo:  (1, -2, 4 ... *).[^10]

[19:05] <p6eval> rakudo 220b67:  ( no output )

[19:06] <PerlJam> rakudo:  (1, -2, 4 ... *).munch(10)

[19:06] <moritz_> rakudo: say   (1, -2, 4 ... *).[^10]

[19:06] <p6eval> rakudo 220b67:  ( no output )

[19:06] <PerlJam> oh yes, thanks

[19:06] <p6eval> rakudo 220b67: OUTPUT«1-24-816-3264-128256-512␤»

[19:06] <patrickas>  rakudo:  say ~(1, -2, 4 ... *).[^10]

[19:06] <p6eval> rakudo 220b67: OUTPUT«1 -2 4 -8 16 -32 64 -128 256 -512␤»

[19:06] <[Coke]> what is phenny using as source for the unicode chars?

[19:06] *** cono joined
[19:07] <PerlJam> now, here's the fun one that behaves badly on my local rakudo ...

[19:07] *** sftp left
[19:07] <PerlJam> rakudo: say ~(1, -2, 4 ... 25).[^10]

[19:07] <p6eval> rakudo 220b67: OUTPUT«1 -2 4 -8 16 -32 64 -128 256 -512␤»

[19:07] <moritz_> ouch

[19:08] <pugssvn> r31788 | moritz++ | [t/spec] another series test, PerlJam++ 

[19:09] <PerlJam> moritz++ indeed

[19:10] <pmichaud> afk, lunch

[19:11] <dalek> rakudo: 6442956 | pmichaud++ | docs/announce/2010.07:

[19:11] <dalek> rakudo: Some announcement updates for Atlanta release.

[19:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6442956542337f1d2d744d4b5ba621ce73a1e5af

[19:11] <PerlJam> moritz_: ah, by my reading of the spec 1, -2, 4 ... 25  should result in 1, -2, 4, -8, 16, -32  

[19:11] <moritz_> rakudo: say (1, 3, 5 ... 10)

[19:11] <p6eval> rakudo 220b67: OUTPUT«13579␤»

[19:11] <colomon> I would say it ends at 16

[19:12] <moritz_> PerlJam: by analogy of the output above I'd also say 16

[19:12] *** justatheory left
[19:12] <colomon> moritz_: "which combines zip with Z=>" on your blog post -- should be "which combines zip with =>"

[19:12] <PerlJam> -32 < 25, we haven't exceeded the limit

[19:12] <colomon> PerlJam: absolute value test

[19:13] <colomon> (because it's a sign-switching geometric series)

[19:14] *** timbunce left
[19:14] <PerlJam> Hmm.   Series have way too many special cases :)

[19:14] <moritz_> colomon: fixed, thanks

[19:14] <colomon> PerlJam: you should try implementing them!  ;)

[19:14] <moritz_> PerlJam: that's why p6l suggests to make it even more complicated :-)

[19:15] <colomon> which is why I like to consider p6l a humor mailing list.

[19:15] <PerlJam> moritz_: It's just another bikeshed  :)

[19:15] * patrickas is trying :-) Amd pulling out his hair :-)

[19:16] <colomon> "Don't you think this bikeshed should have an anti-aircraft gun?"

[19:16] <colomon> "for mosquitos, you know!"

[19:16] *** sftp joined
[19:16] <PerlJam> heh

[19:18] *** Clinteger joined
[19:18] *** kensanata joined
[19:19] *** macroron left
[19:20] <PerlJam> colomon++ and moritz++  just because I think you guys don't get enough  :)

[19:20] * PerlJam wanders off again

[19:21] * cxreg wonders where ^methods is defined

[19:22] <cxreg> oh git log, how you rock my world

[19:22] <cxreg> src/parrot/ClassHOW.pir  .sub 'methods'

[19:24] <moritz_> cxreg: and now think about how long it would have taken with svn log :-)

[19:24] <cxreg> hahahahahaha

[19:25] <cxreg> and 4 renames or so later, it lives in src/metamodel/ClassHOW.pir

[19:25] <cxreg> <3 git

[19:27] <moritz_> indeed. It's quite awesome technology

[19:28] <cxreg> ok, so ^methods just returns an array, and any() is supposed to convert an array to a junction?

[19:28] * cxreg is trying to fix his own bug report

[19:29] *** hercynium left
[19:29] * Clinteger cries listening to a screencast of someone who doesn't speak English well

[19:30] *** mberends joined
[19:30] *** hugme joined
[19:30] <moritz_> hugme: hug Clinteger 

[19:30] * hugme hugs Clinteger

[19:31] <Clinteger> I don't like watching people struggling to speak English. Just speak a language you're better at :(

[19:32] <cxreg> like perl 6?

[19:32] <Clinteger> :p the problem is that perl6 is english too

[19:32] <moritz_> Clinteger: it's not that easy. When I write my blog posts in German, the audience is maybe 1/10 of the size, if at all

[19:32] <Clinteger> moritz_, actually I don't mind text

[19:33] <lue> .oO($_ != 'matter';)

[19:33] <Clinteger> mostly because "th" is usually difficult for non-native English speakers

[19:34] *** Kodi joined
[19:34] <moritz_> and 'ch' is usually difficult for anybody except Germans and Scottsmen

[19:34] <Clinteger> exactly.

[19:35] * lue is happy to be German&American :)

[19:36] <moritz_> lue: can you pronounce "Streichholzschächtelchen"? :-)

[19:36] <Clinteger> that would be a disaster for me :)

[19:37] * patrickas can !

[19:37] <patrickas> unless correctness is a requirement :-)

[19:37] <lue> I was only in Germany from birth till 5! I didn't learn a lot of spelling :(

[19:37] <lue> I could certainly try though :)

[19:37] <moritz_> lue: should be enough to learn to speak most sounds

[19:37] <moritz_> patrickas: recognizability is :-)

[19:38] <lue> Due to my background, I can't help but snicker on the inside when someone can't say 'ch'. .oO[ Lock Ness Monster :) ]

[19:38] <patrickas> ok I think I got a patch for series.

[19:39] <patrickas> It's pretty ugly but hopefuly it'll do until someone refactors series.

[19:39] <colomon> patrickas++

[19:42] *** pmurias left
[19:44] <colomon> dang it, two failures in the spectest.  :(

[19:45] <moritz_> rakudo: say 'NaN' ~~ NaN

[19:45] <p6eval> rakudo 220b67: OUTPUT«1␤»

[19:45] <moritz_> rakudo: say +'NaN'

[19:45] <p6eval> rakudo 220b67: OUTPUT«NaN␤»

[19:46] <patrickas> moritz_ I am getting a failure in th last test you added for series

[19:46] <patrickas> is ~(1, -2, 4 ... 25).[^10], '1 -2 4 -8 16'

[19:46] <patrickas> got: '1 -2 4 -8 16 Any() Any() Any() Any() Any()' # expected: '1 -2 4 -8 16'

[19:47] <moritz_> patrickas: oh, that might be a list indexing bug

[19:47] <moritz_> rakudo: say ~<a b>.[^10]

[19:47] <p6eval> rakudo 220b67: OUTPUT«a b Any() Any() Any() Any() Any() Any() Any() Any()␤»

[19:48] <moritz_> yes, it is

[19:48] <pmichaud> ranges don't clip yet

[19:48] <pmichaud> I started to implement it but got sidetracked.

[19:48] <patrickas> oh ok ...

[19:48] <moritz_> patrickas: feel free simplify the test (ie remove the .[^10])

[19:48] <pmichaud> (so yes, it's a rakudo bug, plz file if you get a chance kthxbye)

[19:48] * moritz_ files rakudobug

[19:50] *** xabbu42 joined
[19:50] *** kensanata left
[19:51] *** Schwern left
[19:55] <colomon> spectesting again...

[19:56] *** gaal joined
[19:56] <gaal> }:)

[19:57] <gaal> moritz_: re: case in comparison, I'm just guessing but could it be related to Turkish dotless I?

[19:58] <szabgab> woot gaal

[19:58] <szabgab> long time not seen!

[19:59] <gaal> hey :)

[19:59] <gaal> what's up szabgab?

[19:59] <szabgab> will you come on monday to help me out?

[19:59] <moritz_> gaal: no idea. That thing screws up in all case conversions :-)

[19:59] *** takadonet left
[20:00] <gaal> szabgab: sorry, can't. Have fun though (I'm sure you will)

[20:01] <szabgab> rakudo: my @keys <a b c>; my %exists = @keys Z=> 1 xx *; say %exists.perl 

[20:01] <p6eval> rakudo 220b67: OUTPUT«===SORRY!===␤Confused at line 22, near "my @keys <"␤»

[20:01] <szabgab> rakudo: my @keys = <a b c>; my %exists = @keys Z=> 1 xx *; say %exists.perl 

[20:01] <p6eval> rakudo 220b67: OUTPUT«{"a" => 1, "b" => 1, "c" => 1}␤»

[20:01] <szabgab> rakudo: my @keys = <a b c>; my %exists = @keys Z 1 xx *; say %exists.perl 

[20:01] <p6eval> rakudo 220b67: OUTPUT«{"a" => 1, "b" => 1, "c" => 1}␤»

[20:01] <moritz_> .oO( somebody reads my blog after all :-)

[20:02] <szabgab> and I think you don't need the => in the first 2 examples :)

[20:02] <moritz_> szabgab: that's correct, as long as @keys doesn't contain Pair objects

[20:02] <szabgab> hmm

[20:03] <moritz_> rakudo: my @keys = 'a', 'b => 2, 'c'; my %h = @keys Z=> 1 xx *; say %h.perl

[20:03] <p6eval> rakudo 220b67: OUTPUT«===SORRY!===␤Confused at line 22, near "my @keys ="␤»

[20:03] <moritz_> rakudo: my @keys = (a', 'b' => 2, 'c'; my %h = @keys Z=> 1 xx *; say %h.perl

[20:03] <p6eval> rakudo 220b67: OUTPUT«===SORRY!===␤Confused at line 22, near "my @keys ="␤»

[20:03] <moritz_> rakudo: my @keys = 'a', 'b' => 2, 'c'; my %h = @keys Z=> 1 xx *; say %h.perl

[20:03] <p6eval> rakudo 220b67: OUTPUT«{"c" => 1, "b\t2" => 1, "a" => 1}␤»

[20:03] <moritz_> rakudo: my @keys = 'a', 'b' => 2, 'c'; my %h = @keys Z 1 xx *; say %h.perl

[20:04] <p6eval> rakudo 220b67: OUTPUT«Odd number of elements found where hash expected␤  in '!STORE' at line 4600:CORE.setting␤  in main program body at line 22:/tmp/oV9yX2nA2x␤»

[20:04] <gaal> where did that tab come from?

[20:04] <szabgab> interesting

[20:04] <szabgab> tab represents the pair :)

[20:05] <gaal> ah, I see

[20:05] <gaal> Isn't .perl supposed to be reversible though?

[20:05] <szabgab> I guess it is a buggy representation of a pair

[20:06] <gaal> buggy\tpair

[20:06] <colomon> actually, Hash keys are Str right now.

[20:07] <colomon> so when you use 'b' => 2 as a key, it stringifies it.

[20:07] <colomon> to "b\t2"

[20:07] *** justatheory joined
[20:09] <colomon> rakudo: my @keys = 'a', 'b' => 2, 'c'; my %h = @keys Z=> 1 xx *; say %h.keys>>.WHAT

[20:09] <p6eval> rakudo 220b67: OUTPUT«Str()Str()Str()␤»

[20:10] <gaal> d'oh right, that wasn't @keys.perl. I wonder if in the context of hash keys perl5-like $; isn't a better delimiter. (I've been far away from things, maybe something like that is specced)

[20:11] <huf> maybe you guys know it, what's it called when a brand name gets expanded to mean the whole concept? (such as xerox)

[20:11] <pmichaud> huf: trademark dilution

[20:11] <pmichaud> (or maybe just "dilution")

[20:11] <huf> hum, is that the linguistic term?

[20:12] <pmichaud> I think that's the legal term

[20:12] <pmichaud> wait, that's not it

[20:12] <pmichaud> (looking)

[20:12] <[Coke]> genericized

[20:12] <pmichaud> yeah, genericized

[20:13] <[Coke]> I think there's an esoteric language-geek word for it, too.

[20:14] <gaal> there is a related phenomenon called dilution though: http://en.wikipedia.org/wiki/Trademark#Dilution

[20:14] *** lest_away is now known as lestrrat

[20:15] <[Coke]> metonymy is not the geek work I was thinking of, but will do.

[20:17] <gaal> were you thinking of synecdoche?

[20:17] <pmichaud> yeah, I remembered "dilution" first because it's what came up when I trademarked my product :)

[20:17] *** rindolf joined
[20:17] <rindolf> Hi all.

[20:18] <pmichaud> grrr, silly oscon schedule

[20:19] <pmichaud> at 13h40 I have to choose between mst and schwern

[20:19] <pmichaud> at 14h30 I have to choose between obra and Fenwick

[20:19] *** lestrrat is now known as lest_away

[20:20] * pmichaud wanders off to choose :)

[20:24] <tadzik> hmm

[20:24] <tadzik> S03: If no closure is provided, and the sequence is numeric, and is obviously arithmetic or geometric (from examining its last 3 values), the appropriate function is deduced: 1, 2, 4 ... *   # powers of 2

[20:25] <tadzik> how does Rakudo know whether these are powers of two, or just even numbers?

[20:25] <tadzik> ah, my bad

[20:25] <tadzik> nevermind

[20:25] <colomon> 1 isn't an even number.  :)

[20:25] <tadzik> yeah, I see :)

[20:25] <moritz_> you need at least three numbers to tell

[20:25] <tadzik> yeah, I've read that

[20:25] <tadzik> just mistaken :)

[20:25] <colomon> and if 4/2 == 2/1 you have a geometric series

[20:26] <colomon> that's actually the easy part of series.  :)

[20:28] <tadzik> so, when is #31 coming out?

[20:28] <[Coke]> about 10pm eastern.

[20:28] <tadzik> oh, there alredy is an announcment in docs

[20:28] <[Coke]> (perhaps sooner)

[20:28] <[Coke]> yes, it was helpfully pre-written for me. =)

[20:29] <moritz_> release rakudo generally isn't very hard

[20:29] *** masak joined
[20:29] <masak> ahoy!

[20:29] <phenny> masak: 18:08Z <jnthn> tell masak often src/glue is a good place for such things. See e.g. src/glue/subset.pm

[20:29] <phenny> masak: 18:09Z <jnthn> tell masak also see how it's handled in the makefile

[20:29] <moritz_> I've done it about 2.5 times

[20:30] <masak> jnthn: thanks.

[20:31] <tadzik> + .perl on custom classes now dumps attributes

[20:31] <tadzik> \o/

[20:31] <tadzik> rakudo++

[20:32] <masak> things *are* awfully nice nowadays, aren't they?

[20:32] <dalek> rakudo: 56b25a2 | moritz++ | tools/contributors.pl:

[20:32] <dalek> rakudo: [tools/contributors.pl] avoid Mojibake

[20:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/56b25a2bc6ee2876f9464f9c96badd7160da4195

[20:32] <dalek> rakudo: 9c90c2f | moritz++ | docs/announce/2010.07:

[20:32] <dalek> rakudo: [docs] update contributor list in release announcement

[20:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9c90c2f703e8c818fd7ada9a00d74446665a5f7e

[20:33] <szabgab> I wonder what product did pmichaud trademakr? rakudo?

[20:33] <szabgab> so will people use rakdo also as a verb?

[20:34] <szabgab> so "to rakudo something" will mean to give it an elegant solution?

[20:34] <tadzik> They alredy do, as in justrakudoit.wordpress.com :)

[20:35] <masak> wow. http://corky.net/dotan/log/images/perl6-watchmen_a.jpg

[20:35] <masak> dotan++

[20:35] <szabgab> strange, the latest screencast I made is 6 min long in ogv but when I convert it to avi to upload it says it is 18 min long

[20:36] *** timbunce joined
[20:37] <masak> moritz_++ made Reddit: http://www.reddit.com/r/programming/comments/csk7u/common_perl_6_data_processing_idioms/

[20:37] *** justatheory left
[20:37] *** justatheory joined
[20:38] <pmichaud> szabgab: (trademark)  "PmWiki"

[20:38] <szabgab> so I was asked today what do I want to achieve by giving a perl 6 talk at the Python UG meeting

[20:38] <moritz_> szabgab: I'm curious what you answered

[20:38] <masak> :)

[20:39] <szabgab> I curious what would you say :)

[20:39] <pmichaud> I've given Perl 6 talks at python conferences before

[20:39] <pmichaud> in fact, I gave a Perl 6 talk at Pycon :-)

[20:39] <szabgab> oh the people who asked are some of the python ppl

[20:39] <szabgab> pmichaud is brave

[20:40] <moritz_> raise awareness, give people ideas to steal from

[20:40] <pmichaud> anyway, "Perl 6 has happily stolen ideas from many other languages, including Python.  We'd like to give you an opportunity to steal from us..."  :-)

[20:40] <pmichaud> (actually, my PyCon talk was about Perl 6 grammars and Parrot more than Perl 6 itself :)

[20:40] <cxreg> is there any way to avoid a 5 minute compile when you change a line of code in rakudo? :/

[20:40] <cxreg> i'm supposing not, the src/gen/core.pir bit takes a while

[20:41] <moritz_> cxreg: you can prototype core functions in normal Perl 6 scripts

[20:41] <moritz_> and methods too

[20:41] <tylercurtis> szabgab: that no one would be asking that question if you were giving a talk about Haskell.

[20:41] <cxreg> hrm

[20:41] <pmichaud> cxreg: alas, not reliably.

[20:42] *** gaal left
[20:42] <szabgab> likely I'll also concentrate on grammars

[20:43] <szabgab> and I was just trying to learn them :)

[20:43] <cxreg> i'm taking a stab at the perplexing any() bug i filed last night

[20:43] <tylercurtis> szabgab: when is the talk?

[20:43] <szabgab> monday

[20:43] <moritz_> cxreg: maybe there's a .flat missing somewhere

[20:44] <[Coke]> Ok. anyone trying to slip anything else in today?

[20:45] <tylercurtis> If it were further in the future, I have a project I'm working on that might be a nice example once it's further along were you to want to discuss the type system.

[20:45] <pmichaud> did colomon's patch get committed?

[20:46] <szabgab> tylercurtis: maybe another talk

[20:46] <moritz_> pmichaud: don't think so

[20:47] <pmichaud> I'd want to wait for that patch (or hear more about why it's not in yet)

[20:47] <szabgab> I hope to give a few of them, anywhere they would let me talk :)

[20:47] <patrickas> rakudo: say ~(1, 2, 3 , 4... 3);

[20:47] *** Schwern joined
[20:47] <p6eval> rakudo 220b67:  ( no output )

[20:47] *** patspam left
[20:47] <pmichaud> [Coke]: We're currently passing around 23,000 tests.  I have no idea how many tests are in the suite at the moment, because the scripts that I have that used to compute those numbers are obviously broken.

[20:51] <Kodi> masak: Can we get my patch into release 31?

[20:51] <masak> Kodi: I'm just about to spectest it.

[20:51] <lue> hi again o/

[20:51] <Kodi> masak: Great!

[20:51] <colomon> pmichaud: not yet.

[20:51] <colomon> first spectest turned up problems.

[20:52] <colomon> second spectest just ended, should push in a minute or two.

[20:52] <[Coke]> colomon++

[20:52] <Util> Trying to get a patch in to fix `make test` on MinGW Win32; requesting eyes on the patch:

[20:52] <Util>     http://rt.perl.org/rt3/Public/Bug/Display.html?id=76680

[20:52] <[Coke]> Gonna be another 2 hours, easy.

[20:52] <masak> patch++

[20:52] <colomon> unless someone has pushed another patch in the meantime.  :\

[20:53] <Util> Tiny patch here

[20:53] <pmichaud> Util: looking

[20:53] <pmichaud> Util:  +1 to your patch

[20:54] * patrickas wonders will it be faster to spectest now or wait for colomon's patch and spectest then :-?

[20:54] <[Coke]> Util: looks good to me.

[20:54] <colomon> wait a second, I'll push as soon as I've verified I have a compile here.

[20:54] <pmichaud> Util: feel free to push/apply

[20:54] <patrickas> colomon++'s patch is supposed to bring the spectest time down cosiderably right ?

[20:55] <[Coke]> yes.

[20:55] *** _pragma is now known as pragma_

[20:55] <colomon> patrickas: probably not that much

[20:55] <[Coke]> er, that one file. which was it?

[20:55] <colomon> it mostly only affects Rat arithmetic

[20:56] <patrickas> oh ok ...

[20:56] <Util> pmichaud, [Coke]: Thanks! Will push now

[20:56] <pmichaud> (mostly affects Rat arithmetic)  yes, but a single /  automatically puts you into the realm of Rat arithmetic.  :-)

[20:56] <colomon> sure, but lots of tests don't do any arithmetic at all

[20:56] <colomon> pushed

[20:57] <colomon> I'm just trying to say, just because it nearly halved the execution time of that one script doesn't mean it will do the same for the entire spectest.

[20:58] <pmichaud> colomon: agreed.

[21:01] * jnthn back

[21:02] <jnthn> masak: I'm about now if you need some help

[21:02] <masak> \o/

[21:02] * masak grabs jnthn so he doesn't run away again :)

[21:02] <dalek> rakudo: 08809ca | (Solomon Foster)++ | src/core/Int.pm:

[21:02] <dalek> rakudo: Add the notdef check to Int.sign.

[21:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/08809ca026aa149d85d92b9699ace86a9c5838e3

[21:02] <dalek> rakudo: 9c4bd55 | (Solomon Foster)++ | src/core/Int.pm:

[21:02] <dalek> rakudo: Add Int.sign so that we can take advantage of the fact our current Int cannot be 

[21:02] <dalek> rakudo: NaN to drastically speed up Rat construction.

[21:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9c4bd5582c95d875e19725c3f6ec36de65c61cde

[21:02] <dalek> rakudo: 12c5229 | (Solomon Foster)++ | src/core/Cool-str.pm:

[21:02] <dalek> rakudo: Tweak Cool.words, implement Cool.lines.

[21:02] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/12c5229616220a54059e887fa2fc63f2d9ca25b7

[21:03] * [Coke] is very glad the machine he's doing the release on today has 3g.

[21:03] <tadzik> Tweak Cool.words, implement Cool.lines. Sounds like fun

[21:03] <[Coke]> and... out. see folks in a few hours when I settle in to cut the release.

[21:04] <colomon> [Coke]++

[21:04] <sjohnson> perl 6 eq 

[21:04] <sjohnson> 14:01 <@falzer> heh

[21:04] <sjohnson> oops

[21:04] <sjohnson> http://www.artofsmoking.com/motorcycle.jpg

[21:07] <tadzik> moritz_: So note :$var.perl is quick way of obtaining the value of a variable for debugging; purposes, along with its name. This semicolon after debugging, a typo?

[21:07] <mberends> jnthn: nice to have Zavolaj alive again. Through it, Rakudo can haz fork() on Linux ;)

[21:07] *** eternaleye left
[21:08] <jnthn> oh fork!

[21:08] <dalek> rakudo: ca32e3a | util++ |  (2 files):

[21:08] <dalek> rakudo: [t] Change PARROT from ENV var to calculated, to fix RT#76680

[21:08] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ca32e3a2f99a05bea3cb7b085c1158875a0fb688

[21:09] <colomon> pmichaud: I've marked .isNaN on my to-do list, I don't see a reason it needs to be done for the release today, I don't think it will speed up this case much.  Once I've got that it will be easy to clean up Numeric.ACCEPTS and Real.ACCEPTS.

[21:10] <colomon> pmichaud: let me know if you want me to try to squeeze more speed out of that example code, I have a few more ideas.  I just don't know that they're worth pursuing this close to release.

[21:10] <pmichaud> colomon: I'm fine with that; I mainly wanted to avoid the expensive math :-)

[21:10] *** perlygatekeeper left
[21:10] <colomon> oooo, belay that.

[21:10] <colomon> !

[21:11] <colomon> I have another optimization that makes a noticeable difference in that example code.

[21:11] <pmichaud> okay

[21:11] <colomon> pretty simple, I'll spectest it now.

[21:11] <pmichaud> again, this came from a reddit poster asking "why is rakudo so slow", so it's "in the wild."  

[21:11] <colomon> this one is just switching from $a.sign * $b.sign to ($a * $b).sign

[21:12] <pmichaud> $a and $b are....?

[21:12] <pmichaud> rats?

[21:12] <colomon> Ints

[21:13] <pmichaud> okay

[21:13] <colomon> I guess it might be slower if they were big enough to overflow to Nums when multiplied together.

[21:13] <pmichaud> what's the whole line of code?

[21:13] <jnthn> mberends: All other Zavolaj things are working again?

[21:13] <colomon>     if ($a * $b).sign < 0 && $result * $b != $a {

[21:14] <colomon> it's in infix:<div> in Int.pm

[21:14] <mberends> jnthn: yes!

[21:14] *** kjeldahl joined
[21:14] <jnthn> mberends: yay!

[21:14] <pmichaud> ..is that doing a truncation?

[21:14] <jnthn> mberends: I think the pir::clone call maybe can be tossed now pmichaud++ fixed closures.

[21:15] <jnthn> mberends: Feel free to try that.

[21:15] <pmichaud> (or a floor?)

[21:15] *** molecules joined
[21:15] <mberends> jnthn: yes, can do soon

[21:15] <jnthn> mberends++

[21:16] <colomon> pmichaud: it's adjusting the result from parrot's div operator so that it has the Perl 6 semantics for negative numbers and div.  I don't remember the exact details.

[21:16] <colomon> (but I'm pretty sure I added tests for it.)

[21:17] <pmichaud> colomon: faster might be   ($a < 0 ?^ $b < 0) && ...

[21:17] <pmichaud> avoids .sign altogether

[21:17] *** Mowah left
[21:17] <colomon> hmmm.

[21:18] <colomon> ?^ is exclusive or?

[21:18] <pmichaud> boolean exclusive or, yes.

[21:19] <colomon> give me a minute...

[21:21] <pmichaud> you can speed it up even further with

[21:22] <pmichaud> my $result = pir::div__III($a, $b) - (( $a < 0 ?^ $b < 0) ?& $b != $a);

[21:22] <pmichaud> and still further by eliminating the "my $result ="

[21:22] <colomon> woah.

[21:22] *** hercynium joined
[21:22] *** hercynium left
[21:23] *** rindolf left
[21:23] <colomon> how does that handle the $result * $b != $a?

[21:23] <pmichaud> oh, sorry

[21:23] <pmichaud> I missed that part

[21:23] <pmichaud> ummmm

[21:23] <pmichaud> shouldn't that be a mod, anyway?

[21:23] <pmichaud> why do a multiply?

[21:24] <tadzik> rakudo: class A { has $.par }; my $foo = A.new(par => 7); say $foo.perl

[21:24] <p6eval> rakudo 9c90c2: OUTPUT«A.new(par => 7)␤»

[21:24] <pmichaud> what is that really checking for?

[21:24] <colomon> is a mod any faster?

[21:24] <pmichaud> it can be

[21:24] <tadzik> rebuild time

[21:25] <pmichaud> are you checking that $a is evenly divisible by $b ?

[21:25] <colomon> actually, the ($a < 0 ?^ $b < 0) patch doesn't work either.  :\

[21:25] <colomon> yes

[21:26] <pmichaud> pir::div__III($a, $b) - (($a < 0 ?^ $b < 0) && ?($a % $b));

[21:26] <pmichaud> probably need parens around the ($a < 0) and ($b < 0)

[21:26] <pmichaud> otherwise it parenthesizes wrong

[21:26] <pmichaud> could use ^^ instead of ?^

[21:26] <pmichaud> but I think ?^ will be faster

[21:27] <colomon> okay, testing that one again.

[21:27] *** Schwern left
[21:27] <pmichaud> pir::div__III($a, $b) - (($a < 0 ?^ $b < 0) ?& ?($a % $b));   # my current best guess

[21:27] <pmichaud> no wait

[21:27] <colomon> pir::div__III($a, $b) - (($a < 0 ?^ $b < 0) && ?($a % $b)); looks very tempting.  that's a good reason to use %

[21:27] <pmichaud> pir::div__III($a, $b) - ((($a < 0) ?^ ($b < 0)) ?& ?($a % $b));   # my current best guess

[21:28] <pmichaud> (but in some respects this code completely makes me say "...huh?"  There really need to be some comments explaining why we need to be subtracting one.)

[21:28] * masak .oO( pir::div__III looks like some ancient Romans named it. "This is our third attempt at the division function" )

[21:30] *** PZt left
[21:31] <colomon> first version with parans works

[21:32] *** d4rt joined
[21:32] <colomon> errr... but it's actually slower?

[21:33] <pmichaud> if it's slower, that indicates that $a < 0 is slower than .sign

[21:33] <pmichaud> and that could be.... concerning

[21:33] <pmichaud> (because $a < 0 is very common)

[21:33] <pmichaud> might try && instead of ?& -- that will short-circuit

[21:34] *** nimiezko joined
[21:35] <colomon> what the heck?

[21:36] <colomon> it went so fast that time it's hard to believe something wasn't broken

[21:36] <colomon> isn't broken

[21:36] <colomon> pmichaud++

[21:37] <pmichaud> my version:  avoids an extra subroutine call.  avoids a method call.  avoids allocating a lexical variable.  avoids lexical lookups.  avoids 2 extra assignments.  :-)

[21:38] <colomon> how much faster do you think?

[21:38] <pmichaud> I have no idea, though :)

[21:38] <colomon> your version: returns wrong type

[21:38] <colomon> :(

[21:39] <colomon> huh

[21:39] <pmichaud> how would that be possible?

[21:39] <colomon> possible has to do with doing math on a Bool, checking now

[21:39] <pmichaud> math on a bool should either return 0 or 1

[21:39] <colomon> yes, but of what type?

[21:39] <pmichaud> int

[21:40] <colomon> div__III returns an Integer rather than an Int.

[21:40] <colomon> rakudo: say (True).PARROT

[21:40] <p6eval> rakudo 9c90c2: OUTPUT«Bool␤»

[21:40] <colomon> rakudo: say (1 + True).PARROT

[21:40] <p6eval> rakudo 9c90c2: OUTPUT«Num␤»

[21:40] <pmichaud> go ahead and put the   "my $result =" back in, then.

[21:40] <colomon> no, no!

[21:40] <pmichaud> that will at least cast it properly

[21:41] <colomon> just needs a ?? with the bool bit

[21:41] <pmichaud> no no

[21:41] *** justatheory left
[21:41] <pmichaud> say  PARROT(1 - True)

[21:41] <pmichaud> rakudo:  say PARROT(1 - True)

[21:41] <p6eval> rakudo 9c90c2: OUTPUT«Num␤»

[21:42] <pmichaud> rakudo:  say PARROT(1 - 1)

[21:42] <p6eval> rakudo 9c90c2: OUTPUT«Integer␤»

[21:42] <pmichaud> aha

[21:42] <pmichaud> okay, True is being converted into a Num

[21:43] <pmichaud> more precisely,  &infix:<->  is treating True as a Num

[21:43] <colomon> Ummm... your version is leaving out a boxing as well.

[21:43] <pmichaud> you don't need a box

[21:43] <pmichaud> that's really old style

[21:43] <pmichaud> you only need box with  Q:PIR.  

[21:44] <pmichaud> &infix:<=>   will automatically end up boxing the int register

[21:44] <colomon> so we're good returning Integers?

[21:45] <pmichaud> well, that's what you had before (in the case wehre the 'if' was false)

[21:45] <pmichaud> rakudo:  say PARROT(3/3);

[21:45] <p6eval> rakudo 9c90c2: OUTPUT«Rat␤»

[21:45] <pmichaud> rakudo:  say PARROT(3 div 3);

[21:45] <p6eval> rakudo 9c90c2: OUTPUT«Perl6Scalar->Integer␤»

[21:46] <pmichaud> so it was okay before, it's probably okay now :)

[21:47] *** nadim joined
[21:47] <colomon> hokey smokes, adding ?? 1 !! 0 after the Bool just kills the speed.

[21:47] <colomon> hmmm... Int cast?

[21:48] <masak> Kodi: ping

[21:48] <pmichaud> I don't know why it would kill the speed

[21:48] <pmichaud> we should figure that out as well

[21:48] <jnthn> How does ?? but it's LHS in boolean context?

[21:48] <jnthn> *put

[21:49] <pmichaud> jnthn: vtable get_bool

[21:49] <jnthn> Are we going through one of those v-table overrides?

[21:49] <jnthn> Ah

[21:49] <jnthn> That may be to blame

[21:49] <pmichaud> this is a good example of where a low-level subroutine really needs to be optimized and avoid unnecessary contexts, calls, assignments, etc.

[21:49] <colomon> maybe the super fast speed was some weird fluke

[21:49] <pmichaud> (there are quite a few that I've seen)

[21:49] <jnthn> pmichaud: *nod*

[21:49] <colomon> pmichaud: which is a good example of why we need a good profiler

[21:50] <pmichaud> colomon: yes, that will help. 

[21:50] *** justatheory joined
[21:50] <pmichaud> but it's also the case that we should avoid writing expensive code in the first place :)

[21:50] <masak> Kodi: ah. un-ping.

[21:50] <pmichaud> try using  pir::sub  instead of   &infix:<->

[21:50] <Kodi> masak: Un-pong.

[21:51] <masak> Kodi: things look good on this end so far.

[21:51] <pmichaud> that would probably correctly cast the bool into an int instead of a num

[21:51] <Kodi> masak: Good.

[21:51] <pmichaud> (and using pir::sub__III  would guarantee that)

[21:51] <colomon> using .Int worked.

[21:51] <pmichaud> wfm

[21:51] <Kodi> I'm leaving in a few minutes.

[21:52] <pmichaud> rakudo:  say PARROT(1-True);

[21:52] <p6eval> rakudo 9c90c2: OUTPUT«Num␤»

[21:52] <pmichaud> we really ought to figure out how to make that Int

[21:52] *** Schwern joined
[21:52] <pmichaud> rakudo:  my @a;  say PARROT(1 - @a);

[21:52] <colomon> one thing at a time.  :)

[21:52] <p6eval> rakudo 9c90c2: OUTPUT«Num␤»

[21:52] <pmichaud> that one also.

[21:52] <colomon> pmichaud: ready for this?

[21:53] <colomon> "original" (start of today) speed: 48s

[21:53] <colomon> after Int.sign added: 27s

[21:53] <tylercurtis> pmichaud: "use integer;" ;)

[21:53] <colomon> after ($a * $b).sign: 22s

[21:53] <colomon> current: 4s

[21:53] *** Clinteger left
[21:53] <tadzik> :O

[21:53] <tadzik> awesome

[21:54] <colomon> pmichaud++

[21:54] <tadzik> pmichaud++ indeed

[21:54] <colomon> still gotta spectest

[21:54] <pugssvn> r31789 | masak++ | [S32] DateTime immutable, leap seconds validation 

[21:54] <pugssvn> r31789 | 

[21:54] <pugssvn> r31789 | The rest of this message is from Kodi++, who prepared the combined

[21:54] <pugssvn> r31789 | spec/Rakudo patch:

[21:54] <pugssvn> r31789 | 

[21:54] <pugssvn> r31789 | There are two major changes here: DateTimes are now immutable and

[21:54] <pugssvn> r31789 | DateTime constructors now validate leap seconds.

[21:54] <pugssvn> r31789 | 

[21:54] <pugssvn> r31789 | tai-utc should provide a hash, not a subroutine, but this doesn't

[21:54] <pugssvn> r31789 | work when Rakudo is compiled.

[21:54] <pugssvn> r31789 | 

[21:54] <pugssvn> r31789 | It shouldn't be too hard to write a Perl 5 script, to be run as

[21:54] <pugssvn> r31789 | part of Rakudo's build process, that automatically updates the

[21:54] <pugssvn> r31789 | leap-second table in tai-utc.pm.

[21:54] <pugssvn> r31789 | 

[21:54] <pugssvn> r31789 | I haven't run DateTime-strftime.t because ++supernovus is moving

[21:54] <pugssvn> r31789 | strftime out of Rakudo, and hence DateTime-strftime.t out of

[21:54] <pugssvn> r31789 | pugs.

[21:54] <frettled> masak: I see room for improvement in pugssvn's spamming routines :)

[21:55] <pugssvn> r31790 | masak++ | [t/spec] updated Date.t, calendar.t and DateTime.t to follow spec 

[21:55] <masak> Rakudo patch landing soon.

[21:55] <colomon> spectesting

[21:56] <pmichaud> colomon: can you nopaste the patch?

[21:56] <pmichaud> I want to run it locally and reply to the reddit poster to gave the original test

[21:56] <jnthn> pmichaud++, colomon++

[21:56] <Kodi> masak++!

[21:56] <colomon> http://gist.github.com/486667

[21:56] <jnthn> It's a good example that we *can* optimize stuff in quite a lot of places. :-)

[21:56] <pmichaud> exactly

[21:57] <colomon> that's not an actual patch, just the one routine that has changed.

[21:57] <pmichaud> and the value of people saying "this looks weird... is something wrong?"

[21:57] <colomon> in Int.pm

[21:57] <pmichaud> colomon: that's all I need, if it's all that needs to be changed to get the improvement

[21:57] <colomon> people++

[21:57] <colomon> pmichaud: should be

[21:58] *** Kodi left
[21:58] * colomon is tempted to try creating a raw-div operator, as Rat should only be calling div in cases where the adjustment section isn't needed at all.

[21:59] <pmichaud> from 48s to 4s isn't good enough for you?  ;-)

[21:59] *** nimiezko left
[21:59] *** stepnem left
[21:59] <colomon> well, I certainly like 48s to 4s -- but what if it could be 3s?

[21:59] <colomon> ;)

[21:59] *** tedv joined
[22:00] <colomon> I hope we get to spend a good hunk of the next few months optimizing Rakudo.

[22:00] <cxreg> a profiler, eh?

[22:01] <jnthn> colomon: Optimizing some aspects of Rakudo is a big part for my next grant. So I sure intended to be doing so :-)

[22:01] <cxreg> speaking of which, anyone have any formalized thoughts on debugging hooks?

[22:01] <colomon> not least because I'd like to see it running about 100x faster in general.  :)

[22:01] <masak> 100x faster would be awesome. imagine doing the spectest suite in 18 seconds. :)

[22:01] <colomon> pmichaud: have you been able to duplicate the speed increase on your end?

[22:01] <colomon> I'll feel better when someone else has it working.

[22:01] *** nimiezko joined
[22:02] <colomon> feels sort of mythical at the moment.

[22:02] <pmichaud> building now

[22:02] <pmichaud> will take some time, as I have to get my build back up to present head instead of Jun 20 :-)

[22:03] <masak> wow, people really care about DateTime and Temporal. I didn't notice when all these tests for them got added. :)

[22:03] <masak> someone++

[22:03] *** stepnem joined
[22:05] <tylercurtis> colomon: my GSoC project might potentially be helpful for that to some extent (not optimizing Rakudo's standard libraries but optimizing its generated code), although no doubt it could use a lot of improvement. My really ambitious plan (not sure if I'll get to them in GSoC) is to transform PAST to some sort of either CPS or SSA form to make well-known optimizations easy to express. :) Not sure if that's something I'll be able to do during GSoC or not, 

[22:05] <tylercurtis> though.

[22:05] <colomon> tylercurtis++

[22:05] <pmichaud> finished building parrot...building rakudo now (with patch)

[22:07] <[particle]> tylercurtis: have you seen treessa?

[22:07] <tylercurtis> [particle]: I have not.

[22:08] <[particle]> it's what gcc uses internally.  google gcc gimple TreeSSA.  worth a read

[22:08] <tylercurtis> [particle]: have a link?

[22:08] <tylercurtis> ah. alright.

[22:09] *** lest_away is now known as lestrrat

[22:09] *** tadzik left
[22:09] <[Coke]> great. now we just one more test file to be 10x faster, and I can cut a release.

[22:09] <[Coke]> c'mon, you did one. let's go.

[22:10] <[particle]> crack that whip!

[22:11] <masak> [Coke]: just pushed Kodi++'s patch.

[22:11] <masak> though you might like to know.

[22:11] *** skids left
[22:11] <masak> s/though/thought/

[22:12] <pmichaud> argggggggggh

[22:13] <pmichaud> PackFile_unpack: This Parrot cannot read bytecode files with version 8.0.

[22:13] * pmichaud starts his compile sequence over.

[22:13] <[Coke]> pmichaud: is the reddit post the "20s for rakudo, but 8ms for p5"?

[22:13] <pmichaud> colomon: yes.

[22:13] <pmichaud> er, Coke:  yes

[22:13] <[Coke]> I'

[22:13] <pmichaud> (tab fail)

[22:13] <[Coke]> m ... right.

[22:13] <dalek> rakudo: 00848d2 | (Kodi Arfer)++ |  (3 files):

[22:13] <dalek> rakudo: Immutability and leap-second validation for DateTimes.

[22:13] <dalek> rakudo: Signed-off-by: Carl Masak [email@hidden.address]
[22:13] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/00848d23e642e777903f34ff5572de470b7567f9

[22:14] <[Coke]> that takes nearly 55s with master pre-kodi's patch on my OS X box with 3G dual core.

[22:14] <pmichaud> yeah

[22:14] <colomon> is there a link to the post?

[22:14] <[Coke]> so he has a fast box. =-)

[22:14] <[Coke]> http://www.reddit.com/r/programming/comments/crybo/rakudo_stars_really_really_release_ready_porting/

[22:15] <[Coke]> (first comment)

[22:15] <pmichaud> [Coke]: no, he was running Kiev

[22:15] <pmichaud> in Kiev, it's about 50% faster than master is today

[22:15] <pmichaud> on my system, Kiev took 33second, and master (as of this morning) took 77s

[22:15] <colomon> you might also point out that Rakudo is doing it all exactly with Rats...

[22:17] <pmichaud> yes, I thought about that as well.

[22:17] <pmichaud> but I didn't really want to say anything as long as Rakudo master was 2x slower than kiev :)

[22:17] *** justatheory left
[22:18] *** Schwern left
[22:19] *** supernovus joined
[22:20] <supernovus> Hurray for Kodi++'s Temporal changes making it in!

[22:20] *** xabbu42 left
[22:21] <masak> yay

[22:21] <supernovus> I'm going to test DateTime::Utils against the new immutable DateTime.

[22:22] <masak> supernovus++

[22:22] <supernovus> masak: btw, you and Kodi have commit rights to the temporal-utils project where DateTime::Utils now lives (having escaped from the 'lib' directory of the Rakudo tree...)

[22:23] <masak> supernovus: thanks; good to know.

[22:24] <pmichaud> argggggh

[22:24] <[Coke]> is there a way to get a reddit rss feed based on a search?

[22:24] * pmichaud is having trouble doing a simple build.

[22:24] <[Coke]> pmichaud: building using -gen-parrot?

[22:25] *** navidaad joined
[22:25] <[Coke]> that file in the comments drops from about 55 to about 4.5 s.

[22:25] <pmichaud> [Coke]: it's mostly user error on this end, having to do with trying to do this, work on another task, and talk to people at the conference all simultaneously

[22:25] <supernovus> Well 'make test' in temporal-utils shows no failing tests with the new immutable DateTime object, so all seems well :-)

[22:25] <[Coke]> pmichaud: hokay.

[22:25] *** navidaad left
[22:26] *** chee joined
[22:26] <chee> roar

[22:26] <pmichaud> meow

[22:26] <[Coke]> will wait for pmichaud to bless this patch. want to make sure it goes in the releas.

[22:26] <chee> is it perl6 time yet

[22:26] <pmichaud> oh, as long as it passes the spectests, I'm blessing it.

[22:26] <chee> Perl6'clock

[22:26] <[Coke]> it's always perl6 time.

[22:27] <chee> damn wt

[22:27] <pmichaud> I'm simply trying to run it so that I can see the performance improvement on my system.

[22:27] <chee> Perl 6 o'clock

[22:27] <[Coke]> release will be cut later this evening.

[22:27] <pmichaud> (and I'm expecting colomon++ to push the patch and do the spectests, not me )

[22:28] <masak> chee: I'm about to release a blog post about cool Perl 6 features. wanna read the draft?

[22:29] <chee> masak: sure!

[22:29] <masak> chee: http://gist.github.com/485816

[22:30] <masak> if anything strikes you as odd/unclear while reading that, do let me know.

[22:30] <chee> perl 6 is the only language worth programming in, and so I have had to tell the people I am working for that I cannot write anymore code until final release.

[22:30] <masak> chee: :)

[22:30] <pmichaud> colomon:  4s here

[22:30] <masak> chee: you'll find very little of One True Language Syndrome in here...

[22:30] <pmichaud> ..."final release?"

[22:31] <pmichaud> I don't know that term.  :-)

[22:31] <masak> chee: and the concept "Final Release" is quite alien to us (or anyone doing real software)

[22:31] <chee> i mean, release D:

[22:31] <masak> chee: you do realize that this is release #31?

[22:31] <pmichaud> afk, snack, then reply to reddit post

[22:33] <colomon> pmichaud: sorry, I decided to run a load of dishes while I was spectesting the patch.  :)

[22:33] <colomon> 4.5s, \o/

[22:33] *** paul1234 joined
[22:35] <masak> rakudo: my $foo = CREATE_SUBSET_TYPE(Int, { $_ < 5 }); say 3 ~~ $foo; say 7 ~~ $foo

[22:35] <p6eval> rakudo 9c90c2: OUTPUT«1␤0␤»

[22:37] <colomon> aiiii, all sorts of test fail

[22:38] <colomon> oh, no, bad feeling about why things sped up so much

[22:38] <masak> colomon: fast-but-wrong?

[22:38] <colomon> switching over to Num inappropriately?

[22:40] <colomon> rakudo: say (-1.0).WHAT

[22:40] <p6eval> rakudo 9c90c2: OUTPUT«Rat()␤»

[22:40] *** pyrimidine left
[22:40] <cxreg> masak: still waiting to publish that?

[22:40] <cxreg> masak: it's almost less than a week!

[22:40] <cxreg> :D

[22:40] <colomon> arrrrr

[22:41] *** nimiezko left
[22:41] <masak> cxreg: I thought I'd cut it just in time :)

[22:41] <colomon> > say (-1.0).WHAT

[22:41] <colomon> Num()

[22:41] <cxreg> it looked like it was a distilled version of the advent calendar to me?

[22:41] <cxreg> in any case, very tasty

[22:42] *** xabbu42 joined
[22:42] *** xabbu42 left
[22:43] <masak> cxreg: thanks.

[22:43] *** xabbu42 joined
[22:45] <colomon> type returned from div still isn't correct.  :\

[22:46] *** nimiezko joined
[22:47] <colomon> yeah, that's why it's so fast, it's switched over to Num at some point.

[22:47] <colomon> bother

[22:48] *** hercynium joined
[22:49] *** cdarroch left
[22:49] *** ashleydev joined
[22:49] <cxreg> masak: 1,1,*+*...* is oddly appealing

[22:49] <colomon> rakudo: say True.Int.WHAT

[22:49] <cxreg> can't say i grok the & forms which follow it though

[22:49] <p6eval> rakudo 9c90c2: OUTPUT«Bool()␤»

[22:49] <masak> cxreg: I seem to be the only one who likes the & forms better :)

[22:50] <jnthn> Oh, &[+] ?

[22:50] <masak> cxreg: &foo in general means 'the sub called foo'

[22:50] <jnthn> &[+] is just sugar for &infix:<+> pretty much

[22:50] *** supernovus left
[22:50] <masak> cxreg: &infix:<+> means 'the sub which is an infix op with the name +'

[22:50] <masak> cxreg: &[+] is just a short form of &infix:<+>

[22:51] <cxreg> ah

[22:51] <masak> maybe I should remove those, tho'

[22:51] * jnthn finds the short forms a tad cryptic

[22:51] <masak> they don't really add anything for a newbie.

[22:51] <jnthn> masak: No, and poor newbie probably is still getting their head around *+*

[22:51] <jnthn> :-)

[22:51] <cxreg> lol

[22:52] <masak> poof -- gone.

[22:52] <cxreg> ^*+*^ # a snowman with sunglasses?

[22:52] <tylercurtis> I don't much like the &[op] form because it's too close to [op].

[22:54] <jnthn> std: ^*+*^

[22:54] <p6eval> std 31790: OUTPUT«===SORRY!===␤Bogus term at /tmp/82XKs6I3fb line 1 (EOF):␤------> ^*+*^⏏<EOL>␤Parse failed␤FAILED 00:01 116m␤»

[22:54] <jnthn> std: ^*+*

[22:54] <p6eval> std 31790: OUTPUT«ok 00:01 116m␤»

[22:54] <jnthn> Damm, so close.

[22:54] <jnthn> std: multi postfix:<^>($n) { }; ^*+*^

[22:54] <p6eval> std 31790: OUTPUT«Potential difficulties:␤  $n is declared but not used at /tmp/ebsVZ_zrQD line 1:␤------> multi postfix:<^>(⏏$n) { }; ^*+*^␤ok 00:01 122m␤»

[22:55] <jnthn> \o/

[22:56] <masak> what is that, a bat with flashlight eyes?

[22:56] <colomon> well, so much for that optimization.

[22:56] <jnthn> I was just told a snowman with sunglasses.

[22:56] * tylercurtis suspects that it is possible to make a Unicode-art lolcat valid Perl 6.

[22:57] <jnthn> I look forward to seeing it. :-)

[22:57] <timbunce> After doing "perl6 --target=pir --output=dbdi.pir dbdi.pl6" I get a dbdi.pir but how to do I run it? I tried "parrot dbdi.pir" but that spits out a page of "error:imcc:syntax error, unexpected PREG, expecting '(' ('$P11238')" errors.

[22:57] *** tadzik joined
[22:58] <colomon> with the Bool expression properly converting to an Int, pmichaud's optimized version of div is actually much slower than my clunky one.  :(

[22:58] <colomon> afk # dinner

[22:58] <tadzik> timbunce: you can't currently. Compiling modules work, iirc

[22:58] <timbunce> tadzik: :(

[22:58] <mberends> timbunce: those .pir files are only usable as modules for 'use', unless you do extra Parrot work

[22:59] <tadzik> timbunce: I remember my disappointment when I was told this on perl6-users few months ago :(

[22:59] <timbunce> I'd like to demo the code running during my 5 minute lighting talk at OSCON. But spending 1 minute waiting for it to compile won't look good!

[23:00] * colomon is sad

[23:00] <tadzik> make it a module, and the code would be 'Module::run' :)

[23:01] <huf> how does 1, 2, 4, ... * work?

[23:01] <tadzik> huf: it calculates the geometric series based on the first 3 elements

[23:01] <tadzik> I remember reading it in S03 today, can supply a link

[23:01] <timbunce> in rakudo, what's an easy/clean/short way to wait for the user to press return?

[23:02] <tadzik> how about prompt()?

[23:02] <tadzik> prompt ''

[23:02] <tadzik> there are maybe more efficient ones, but this one is easy and short :)

[23:03] <masak> prompt 'Press return'; # :)

[23:03] <tadzik> $*IN.read: 1 #also works

[23:03] <timbunce> prompt is perfect, thanks.

[23:03] <masak> um, no; .read is a binary-read method.

[23:03] <tadzik> but it's imperfect, if you put two chars they stay in the buffer

[23:03] <masak> you mean $*IN.get

[23:03] <colomon> pmichaud: optimization is broken

[23:03] <tadzik> oh, maybe

[23:04] *** xabbu42 left
[23:04] <jnthn> prompt '$ perl6 run-demo.p6' # ;-)

[23:05] <masak> I love it when a fake live demo comes together.

[23:05] <huf> tadzik: thanks

[23:05] <tadzik> huf: want a link?

[23:05] <huf> got it now

[23:10] *** lestrrat is now known as lest_away

[23:11] <tadzik> szabgab++ # screencasts are great, keep up the good work!

[23:16] *** jferrero joined
[23:18] *** au|zzz is now known as au|irc

[23:18] <au|irc> szabgab++ indeed ⟈⟉

[23:19] *** kid51 joined
[23:20] <masak> is that a cyclop?

[23:21] <huf> isnt that a teletubby?

[23:22] <tadzik> it's just two rectangles in my font :(

[23:23] <pmichaud> colomon: my version of <div> causes fails?

[23:23] <pmichaud> if so, that actually means that other things are broken as well.

[23:23] <pmichaud> because the optimized form should work if the original does.

[23:24] <pmichaud> anyway, go with the form you had that includes the 'if' statement for now.

[23:24] <pmichaud> if you can avoid the block-form of 'if', you'll save a bit of time

[23:24] <pmichaud> i.e.,  $result-- if ...

[23:24] <pmichaud> insetad of   if ... { $result-- }

[23:24] <pmichaud> that way we can at least get back to the 22second form instead of the 48 second one

[23:25] <pmichaud> I'll deep dive into the various operators over the next couple of days and figure out why the type coercions are all being done wrong.

[23:27] <pmichaud> I still claim the problem is with &infix:<->

[23:27] *** ab5tract joined
[23:28] <pmichaud> or with the dispatch to &infix:<->

[23:29] *** justatheory joined
[23:29] *** kjeldahl left
[23:30] <masak> [Coke]: still there? you're not releasing quite yet, are you? :P

[23:30] * pmichaud tries a different fix.

[23:33] *** d4rt left
[23:33] <colomon> pmichaud: yeah, definitely needs more analysis

[23:33] <colomon> at this point, I'll be happy for 22s and a working spectest

[23:34] <pmichaud> I still don't completely understand what the $result-- is intended to correct, though.

[23:34] <pmichaud> Parrot gets the result off by one whenever one of the operands is negative?

[23:38] <pmichaud> anyway, the lesson I'm getting from all of this is that Rat arithmetic is really slow (likely slower than it needs to be)

[23:39] <jnthn> pmichaud: Here's another reason it epicly sucks.

[23:39] <jnthn> pmichaud: Rat often contains two Ints.

[23:40] <tylercurtis> colomon: what is the desired division behavior?

[23:40] <jnthn> That's 3 objects. Apart from an object is 2 PMCs really (Object PMC and attr storage).

[23:40] <jnthn> And n Int also keeps a parrot Integer PMC instance around

[23:40] <jnthn> Result: 1 Rat = 8 PMCs.

[23:42] <tylercurtis> colomon: div does flooring division, right?

[23:42] *** Schwern joined
[23:42] <masak> no need for FatRat, Rat is fat all by itself...

[23:42] *** mantovani left
[23:42] <jnthn> ENEEDDIET

[23:42] *** mantovani joined
[23:42] *** justatheory left
[23:43] <tylercurtis> colomon: if so, have you looked into the fdiv op? "Set $1 to the quotient of $2 divided by $3. The result is the floor() of the division i.e. the next whole integer towards -inf. If the denominator is zero, a 'Divide by zero' exception is thrown."

[23:44] <pmichaud> timbunce++ 

[23:45] <sjohnson> heh

[23:45] <pmichaud> (timbunce just demoed dbi in Perl 6 as a lightning talk :)

[23:45] <jnthn> timbunce++

[23:46] <s1n> masak: just curious, what was the reason for DateTime going back to being immutable?

[23:46] <colomon> tylercurtis: is that as opposed to the (parrot) div op?

[23:46] <colomon> (not ignoring you, trying to eat dinner too.)

[23:47] <pmichaud> rakudo:  say pir::fdiv__NNN(-3, 4)

[23:47] <p6eval> rakudo 00848d: OUTPUT«-1␤»

[23:47] <tylercurtis> colomon: Right. the Parrot "div" op does truncating division. "fdiv" does flooring division.

[23:47] *** jferrero left
[23:47] <pmichaud> I think fdiv also expects num instead of int?

[23:48] <tylercurtis> pmichaud: both work.

[23:48] <pmichaud> rakudo:  say pir::fdiv__III(-3, 4)

[23:48] <p6eval> rakudo 00848d: OUTPUT«0␤»

[23:48] <pmichaud> nope.

[23:48] <tylercurtis> Well... there's a fdiv_i_i_i op, at least.

[23:48] *** astrojp left
[23:48] <pmichaud> odd that it gives a different result than fdiv_n_n_n

[23:49] <jnthn> That feels...wrong.

[23:49] <pmichaud> very wrong

[23:50] *** felliott left
[23:51] <pmichaud> http://gist.github.com/486811  # ouch!

[23:51] *** felliott joined
[23:51] <jnthn> wtf

[23:51] <masak> [Coke]: my enum patch made it in! don't you dare release without it! :P

[23:51] *** Raynes left
[23:51] <tylercurtis> C integer division truncates or floors?

[23:51] <jnthn> pmichaud: oh

[23:52] <jnthn> pmichaud: read the op 

[23:52] <jnthn> src/ops/math.ops

[23:52] <masak> whose op?

[23:52] <jnthn> looks FAIL

[23:52] <jnthn> masak: failz op!

[23:52] <masak> oh nose!

[23:53] <dalek> rakudo: 0d0fd7e | masak++ |  (4 files):

[23:53] <dalek> rakudo: [src/glue] translated !setup_named_enum PIR->p6

[23:53] <dalek> rakudo: This is an idempotent commit that paves the way for more correct

[23:53] <dalek> rakudo: enum semantics.

[23:53] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/0d0fd7e5026cd75363aecd7f370c743a3e30c13b

[23:53] <dalek> rakudo: 5fe1939 | masak++ | src/glue/enum.pm:

[23:53] <dalek> rakudo: [src/glue/enum.pm] return the right things

[23:53] <dalek> rakudo: enum Foo <a b c>;

[23:53] <dalek> rakudo: Previously, requesting Foo yielded an EnumMap, whereas it now yields an

[23:53] <dalek> rakudo: object of some kind whose .enums method returns an EnumMap. Similarly,

[23:53] <dalek> rakudo: requesting b yielded an Int, whereas now it returns an object that responds

[23:53] <dalek> rakudo: to a number of methods, as per S12.

[23:53] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5fe193902ce23a683e10ebb708beaead35218d23

[23:53] <masak> \o/

[23:53] <tylercurtis> In C, "double d = someInt / someOtherInt" does integer division, doesn't it?

[23:53] <jnthn> masak++

[23:53] * masak finds the appropriate RT ticket to close

[23:53] <jnthn> tylercurtis: Right.

[23:54] <jnthn> masak *closes* masakbug!

[23:54] <jnthn> er, rakudobug

[23:54] <jnthn> :-)

[23:54] <masak> some schmuck with far too many tickets on his name opened it some time ago...

[23:54] <sjohnson> yo masak

[23:54] *** skids joined
[23:54] <tylercurtis> jnthn: And C integer division truncates?

[23:54] <masak> sjohnson: hey, fella!

[23:54] <jnthn> tylercurtis: Think so

[23:54] <jnthn> tylercurtis: Passing it to floor looks kinda odd though

[23:54] <masak> sjohnson: try the new enums! they're fresh! :)

[23:54] <jnthn> Anyway, I'm pretty sure that code is br0ken.

[23:55] <sjohnson> masak == perl 6 master

[23:55] <jnthn> Sadly, Parrot went out yesterday, so we can nee fix it now.

[23:55] <tylercurtis> jnthn: looks as though they thought they were getting a float division and flooring it.

[23:55] <jnthn> tylercurtis: right

[23:55] <sjohnson> all these new features are quite exciting

[23:55] <colomon> nod

[23:55] <masak> rakudo: enum A <a b c>; say A.enums.WHAT

[23:55] <colomon> afk # skyping

[23:55] <sjohnson> they will make text parsing tasks at work even more flexible

[23:55] <jnthn> sjohnson: You see feeds too? :-)

[23:55] <p6eval> rakudo 00848d: OUTPUT«Method 'enums' not found for invocant of class 'EnumMap'␤  in main program body at line 22:/tmp/CLQqPSQOKr␤»

[23:55] <jnthn> masak: ETOOSOON

[23:55] <masak> jnthn: right.

[23:55] <masak> when's p6eval rakudo rebuild time?

[23:56] <masak> rakudo: enum A <a b c>; say A.WHAT

[23:56] <p6eval> rakudo 00848d: OUTPUT«EnumMap()␤»

[23:56] <masak> it's the examples from http://rt.perl.org/rt3/Ticket/Display.html?id=75296

[23:57] *** Psyche^ joined
[23:57] *** Patterner left
[23:57] *** Psyche^ is now known as Patterner

[23:59] <tadzik> rakudo: "\e\e".split('\e').perl.say

[23:59] <p6eval> rakudo 00848d: OUTPUT«("\x[1b]\x[1b]")␤»

[23:59] <tadzik> why so weird? :\

[23:59] <masak> tadzik: "\e" eq "\x[1b]"

