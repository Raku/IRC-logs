[00:14] *** ilogger2 joined
[00:16] *** Gothmog_ joined
[00:16] *** kraih_sri joined
[00:17] *** broquaint joined
[00:19] *** colomon joined
[00:20] *** mathw joined
[00:23] <diakopter> archtech: spokesbug as opposed to spokesperson or mascot.

[00:23] <archtech> diakopter, that's not what I mean :P

[00:24] <archtech> I mean why is perl6's page targeting the 2 to 6 year old demographic

[00:24] <TimToady> get 'em while they're young

[00:25] <archtech> :P

[00:26] <TimToady> also, to discourage curmudgeons who are too set in their ways to adapt.  :)

[00:27] <TimToady> we're trying to discourage the formation of the type of high-priesthood that has developed in other communities

[00:27] <archtech> TimToady, it depends what you need to adapt to.

[00:28] <archtech> I'm not convinced Teletubbies is the right image for Perl 6.

[00:28] <archtech> But good luck with it

[00:28] <TimToady> and it's not just 2 to 6 year old demographic, but the half of the population that aren't into chest thumping games

[00:29] <diakopter> I see it more as anime-ish

[00:29] <diakopter> than teletubbish

[00:30] <TimToady> teletubbies are ugly

[00:31] <archtech> Not to mention associating Perl6 with bugs :P

[00:31] <diakopter> that's the self-deprecating humor

[00:31] <diakopter> reverse psychology, irony, whichever.

[00:32] <archtech> The problem is, this self-deprecating humor leaves impression that you have bugs and that's funny.

[00:32] <diakopter> but ... those things are both true.

[00:32] <diakopter> (some bugs are quite funny)

[00:33] <archtech> It is ...

[00:33] <archtech> Well I don't know what to say, maybe check framing in linguistics.

[00:33] <archtech> I can't explain well this type of stuff.

[00:33] <TimToady> basically, in anthropological terms, we want to fix some of the bugs in current hacker culture too

[00:34] <TimToady> we want to move away from being a Vulnerability as Weakness culture into more of a Vulnerability as Strength culture.

[00:34] <archtech> TimToady, to me, something Perl 6 could use in its image is, slick, modern look.

[00:34] <archtech> Because the common perception is that Perl is arcane and ancient.

[00:34] <TimToady> but that's what everyone else is doing. :)

[00:34] <archtech> And this page looks a bit like a home page from 1997

[00:34] <archtech> Which supports this image.

[00:35] <TimToady> simple is okay; we don't need flashy

[00:35] <archtech> modern/slick != flashy

[00:35] <diakopter> mmm, slickness. like that gradient highlight that adds a "sheen" to many logos.

[00:35] <archtech> I guess we put different meaning into slickness

[00:35] <TimToady> anyway, we want to communicate simplicity

[00:36] <TimToady> there's already far too much slick in the world

[00:36] *** lue joined
[00:36] <archtech> Well, good luck with it.

[00:36] <TimToady> we'll do okay :)

[00:37] <snarkyboojum> it's really quite different to something from 1997 - just check perl.org from 1997 or something at archive.org

[00:38] <diakopter> speaking of, 2019 called; they want a Perl 7 implementation.

[00:39] <snarkyboojum> let me check the wayforwardmachine

[00:39] <snarkyboojum> says Perl6 is still state of the art :P

[00:40] <lue> I've got The Docter on speed-dial!

[00:40] * lue is talking to The Docter

[00:41] <lue> ...eh, Doctor

[00:41] <diakopter> hmm. wondering whether I should admit I typoed my last msg (meant to type Perl 6)

[00:42] <snarkyboojum> ah :)

[00:44] <TimToady> nah, the ghost of Tolkien claims that large sequels only take 14 years

[00:45] <TimToady> though the ghost of Moses keeps saying "I thought you said 40 years"

[00:45] <lue> The Doctor says perl 6 came out in the '10s...

[00:46] *** ash__ joined
[00:48] *** ash__ left
[00:48] *** ash__ joined
[00:48] <TimToady> well, Perl 6 will be 16 in 2016, which is the usual age for a coming-out party...

[00:49] <TimToady> though perhaps we could schedule a bat mitzvah in 2012

[00:50] <lue> So Perl was found in Israel?

[00:50] <lue> It's written in Hebrew?

[00:51] <diakopter> Aramaic

[00:53] <lue> The Doctor tells me Perl 6 will have an "official" implementation February 16, 2011, around tea.

[00:55] <diakopter> lue: that would be impressive... (since "official" merely means "implementing the whole spec correctly")

[00:55] <lue> as in the "perl" program is updated.

[00:56] <colomon> diakopter: the whole story: at around lunch time, February 16, 2011, a bunch of us are going to go in and take everything Rakudo 2011 doesn't implement out of the spec.  :)

[00:56] <lue> You're talking to the Doctor too!? That's who the third voice is.

[00:56] <TimToady> well, just mark it all as "post 6.0"

[00:59] <diakopter> colomon: but what about the features other implementations implement but Rakudo doesn't (by then)?

[00:59] <lue> what other implementations? :)

[01:00] <diakopter> >:

[01:01] <lue> Ooh, should'nt have said that. (sorry Doctor!)

[01:01] <colomon> diakopter: I'm sure someone will revert the spec within a couple of days.  :)

[01:01] <colomon> once the slashdotting wears down.

[01:01] <diakopter> |:|

[01:02] <ash__> which spec is 'use' in? 

[01:05] <mberends> S09

[01:06] *** drbean joined
[01:07] *** patspam joined
[01:24] *** am0c joined
[01:29] <TimToady> er, S11, actually

[01:37] <mberends> <oops> I read S11 and typed S09 </oops>

[01:37] <TimToady> fired off those old octal neurons, did it? :)

[01:37] <diakopter> you musta thought S09 was octal

[01:37] <diakopter> hm

[01:38] <TimToady> other way around

[01:38] <diakopter> yar

[01:38] <mberends> no, musta just been half asleep

[01:39] <TimToady> the night is yet young

[01:39] <diakopter> I love how S09 is top-ranked on google for "S09"

[01:39] <diakopter> S08 is fourth

[01:40] *** ruoso joined
[01:40] <diakopter> same with S07

[01:40] <diakopter> S06 is 2nd

[01:40] <diakopter> and S05 and S04

[01:40] <diakopter> S03 is top

[01:41] <TimToady> some people are easily amused

[01:42] * mberends is :-)

[01:42] <diakopter> ok, maybe "love" was too strong

[01:43] <TimToady> we can give you some great deals on S09!

[01:43] <mberends> lorl

[01:45] <lue> Do I get Oxiclean if I order my own copy of S09 with a credit card?

[01:46] <TimToady> only if you do it with the credit card we give you

[01:47] <diakopter> std: my %%%3

[01:47] <p6eval> std 29700: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[01:48] <diakopter> riddle me that.

[01:48] <TimToady> (my %) % %3 probably

[01:49] <diakopter> std: my % % % 3

[01:49] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Anonymous variable requires declarator at /tmp/uUSmkdZcZg line 1:‚ê§------> [32mmy % % %[33m‚èè[31m 3[0m‚ê§    expecting twigil‚ê§FAILED 00:01 106m‚ê§¬ª

[01:49] <diakopter> std: my % % %3

[01:49] <p6eval> std 29700: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[01:49] <TimToady> er

[01:49] <TimToady> my *is* a declarator...

[01:49] <TimToady> oh, it's the second one

[01:49] <TimToady> er, third?

[01:49] <TimToady> depending on how you count

[01:49] <diakopter> ok, but what does %3 mean

[01:50] <TimToady> presumably something like %($3)

[01:50] * diakopter facestab

[01:50] <mberends> it's so useful to have a human online who can think like a parser

[01:50] <diakopter> or even like STD

[01:51] <TimToady> well, STD doesn't actually care

[01:51] <TimToady> it just assumes \d+ is a legal name to go after a sigil

[01:51] <lue> STD just gives you a crummy number.

[01:51] <lue> std: say "hello";

[01:51] <p6eval> std 29700: OUTPUT¬´ok 00:01 105m‚ê§¬ª

[01:52] <TimToady> well, it gives you a parse tree, but those don't ircify very well

[01:52] <TimToady> you can get the parse tree if you run STD yerself

[01:52] <mberends> the best feature is the user-context-sensitive help

[01:53] <mberends> it seems to "know" what you're "thinking"

[01:53] <mberends> or even what you "need", that's cool

[01:54] <diakopter> std: my & & &

[01:54] <TimToady> interesting, it returns the 3 as 'index'

[01:54] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Anonymous variable requires declarator at /tmp/2UJbwi7pDV line 1:‚ê§------> [32mmy & & &[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§      infix noun‚ê§       twigil‚ê§FAILED 00:02 128m‚ê§¬ª

[01:54] <diakopter> but I *did* declare &

[01:54] <diakopter> (pronounced "unnhh")

[01:55] <TimToady> yes, but you declared it as anonymous, so you have to declare it again

[01:55] <diakopter> o

[01:55] <TimToady> std: my & & my &

[01:56] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Illegal redeclaration of routine '' (from line 1) at /tmp/mMpXxmp0d1 line 1:‚ê§------> [32mmy & & my &[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        infix noun‚ê§       twigil‚ê§FAILED 00:01 128m‚ê§¬ª

[01:56] <diakopter> std: my & && my &

[01:56] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Illegal redeclaration of routine '' (from line 1) at /tmp/IkfSG99sKG line 1:‚ê§------> [32mmy & && my &[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§       infix noun‚ê§       twigil‚ê§FAILED 00:01 128m‚ê§¬ª

[01:56] <TimToady> fnerk

[01:56] <TimToady> wow, a real STD buglette

[01:57] <diakopter> buglers are in high demand

[01:58] <TimToady> so are taps, at the end of the day

[02:00] <diakopter> std: my (&*; %, $; int &a;);

[02:00] <p6eval> std 29700: OUTPUT¬´ok 00:01 110m‚ê§¬ª

[02:01] *** nbrown joined
[02:02] <diakopter> std: my ($ where $)

[02:02] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of $) variable; in Perl 6 please use $::EGID at /tmp/fr9mogIA1u line 1:‚ê§------> [32mmy ($ where $)[33m‚èè[31m<EOL>[0m‚ê§FAILED 00:01 108m‚ê§¬ª

[02:03] <TimToady> std: my ($)

[02:03] <p6eval> std 29700: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[02:03] <TimToady> std: my ( $ where $ )

[02:03] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Anonymous variable requires declarator at /tmp/rM21s2O1of line 1:‚ê§------> [32mmy ( $ where $[33m‚èè[31m )[0m‚ê§    expecting twigil‚ê§FAILED 00:01 108m‚ê§¬ª

[02:04] <TimToady> that message could be improved

[02:04] <diakopter> std: my $ is is is is

[02:04] <p6eval> std 29700: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[02:05] <diakopter> use speeth_imphedimenths;

[02:08] <diakopter> std: my (IS $)

[02:08] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Invalid typename IS at /tmp/qOgHWbou66 line 1:‚ê§------> [32mmy (IS[33m‚èè[31m $)[0m‚ê§FAILED 00:01 108m‚ê§¬ª

[02:08] <diakopter> std: my IS $

[02:08] <p6eval> std 29700: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§In "my" declaration, typename IS must be predeclared (or marked as declarative with :: prefix) at /tmp/sf4acPdyRs line 1:‚ê§------> [32mmy IS[33m‚èè[31m $[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[02:09] *** hidx joined
[02:25] <dalek> rakudo/ng: b14892b | pmichaud++ | src/Perl6/Grammar.pm:

[02:25] <dalek> rakudo/ng: Add NYI messages for := and ::= bindings.

[02:25] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/b14892ba93b2d246de80fb8db8b87f8bb58c0871

[02:28] * lue hears an echo of EXTERMINATE!

[02:32] <colomon> ng: say split("", "forty-two");

[02:32] <p6eval> ng c0f4cc: OUTPUT¬´Could not find non-existent sub &split‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[02:35] <lue> I want to do a raised eyebrow smiley for that result...

[02:36] <TimToady> actually, it couldn't find an existent sub

[02:36] <TimToady> or it found a non-existent sub

[02:38] <TimToady> but I'd settle for a simple "Couldn't find &split"

[02:38] <colomon> I was just working on writing split.  :)

[02:39] <colomon> But I suppose the error message is LTA.

[02:42] <pugs_svn> r29701 | lwall++ | [STD] don't carp about duplicate anonymous routine declarations 

[02:42] <pugs_svn> r29701 | make undeclared type message the same for parameters as for other declarations

[02:42] <pugs_svn> r29701 | clarify the message about anonymous variables

[02:42] <pugs_svn> r29701 | don't report a $) variable where ) is the $*GOAL

[02:43] <pugs_svn> r29701 | and in general, diakopter++ for tormenting STD

[02:59] <dalek> rakudo/ng: 97e5506 | (Solomon Foster)++ | src/core/Rat.pm:

[02:59] <dalek> rakudo/ng: Clean up ugly bit in GCD now that list assignment works again.

[02:59] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/97e5506214ddf85141cfbdf0a4e0c543d5fceccc

[02:59] <dalek> rakudo/ng: f0a4366 | (Solomon Foster)++ | src/core/Any-str.pm:

[02:59] <dalek> rakudo/ng: Add sub versions of split.

[02:59] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/f0a43667c7cbda075bd94eed0091d55e7cc9ff20

[03:03] <TimToady> std: $

[03:03] <p6eval> std 29701: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Non-declarative sigil is missing its name at /tmp/2UBSoTgoHF line 1:‚ê§------> [32m$[33m‚èè[31m<EOL>[0m‚ê§    expecting twigil‚ê§FAILED 00:01 107m‚ê§¬ª

[03:03] <TimToady> std: my (IS $)

[03:03] <p6eval> std 29701: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§In parameter declaration, typename 'IS' must be predeclared (or marked as declarative with :: prefix) at /tmp/Iyv9OMXEPB line 1:‚ê§------> [32mmy (IS[33m‚èè[31m $)[0m‚ê§FAILED 00:01 108m‚ê§¬ª

[03:03] <TimToady> std: my ($ where $)

[03:03] <p6eval> std 29701: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Non-declarative sigil is missing its name at /tmp/9D7Z9jkIB3 line 1:‚ê§------> [32mmy ($ where $[33m‚èè[31m)[0m‚ê§    expecting twigil‚ê§FAILED 00:01 108m‚ê§¬ª

[03:05] <TimToady> std: my & && my &

[03:05] <p6eval> std 29701: OUTPUT¬´ok 00:01 127m‚ê§¬ª

[03:05] *** hidx left
[03:13] *** tylerni7 left
[03:22] *** tylerni7 joined
[03:22] *** tylerni7 left
[03:22] *** tylerni7 joined
[03:30] <k23z__> is berlios offering private  svn ?

[03:34] <dalek> rakudo/ng: 88f0181 | (Solomon Foster)++ | src/core/Num.pm:

[03:34] <dalek> rakudo/ng: Pull in Num.Rat from master.

[03:34] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/88f0181d121bc3bfd1ce90513f109f220aefbdb4

[03:34] <pugs_svn> r29702 | colomon++ | [t/spec] Unfudge three tests that work now. 

[04:09] * lue is listenting to the Milk Bar song from Majora's Mask on a loop

[04:11] * colomon is watching fiddlers he knows in the Olympic opening ceremony (a few minutes behind real time).

[04:14] * lue thinks that colomon has a TV in his office (or a computer in his living room)

[04:14] * lue or has figured out quantum physics

[04:14] <colomon> my wife and I both have our laptops out.

[04:15] <lue> I'm on my laptop, but the battery lasts only 50 minutes (old laptop)

[04:16] <colomon> We're both plugged in, too.  :)

[04:17] <colomon> I get 2 - 3 hours of battery, depending on how often I recompile (or run spectests).

[04:17] <lue> If I got two new batteries, and swapped my cd drive with the 2nd, I have the power of most modern laptops!

[04:17] <lue> It's an old PowerBook G3 Wallstreet.

[04:18] <colomon> OS X, at least, I hope?

[04:18] <lue> Nah, Linux. Switched because OS X for this laptop wouldn't be supported anymore.

[04:19] <colomon> ah, Yellow Dog (?) is probably a fine choice.

[04:19] <colomon> just so you're not running OS 9 or whatever.  (okay, I'm a relative newcomer to the Mac.)

[04:20] <lue> Fedora. Chose Gentoo first, then Ubuntu, then switched to OpenSuSE, then Fedora.

[04:20] <lue> PPC Linux is BLOODY difficult, compared to Intel.

[04:22] <colomon> My wife has a PPC Mac in our basement, which at this point we keep around mostly so I can test my code on PPC if need be.

[04:22] <colomon> I keep on thinking I should replace it with a Playstation 3.  :)

[04:23] <lue> I got this laptop as a free gift. It was given to get rid of it, but hey, Free Mac (they're expensive).

[04:24] <colomon> I know, I'm on a MBP.  :)

[04:24] <colomon> Really well worth the cost, though, drastically better machine than my old Windows laptops.

[04:25] <lue> O.o Shiny! What I would do for that (not much) o.O

[04:27] <lue> ... Milk Bar theme never gets old :D

[04:31] <colomon> holy smokes, I just had 992 tests run (and I think pass) in my very slightly hacked sin.t!

[04:33] <lue> you created a test for sins? (getting a little HEAVENLY, are we?)

[04:34] <colomon> dude, I have like 1700 tests for sin.

[04:35] <colomon> ng: sin(Inf)

[04:35] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'sin' pc 219906 (src/gen/core.pir:4769)‚ê§¬ª

[04:36] <lue> my salute to puns!

[04:36] <colomon> ng: say Inf.WHAT

[04:36] <p6eval> ng 88f018: OUTPUT¬´Num()‚ê§¬ª

[04:37] *** Chillance joined
[04:38] *** Chillance left
[04:46] <lue> ng: say Inf.WHICH

[04:46] <p6eval> ng 88f018: OUTPUT¬´Inf‚ê§¬ª

[04:47] <TimToady> it's possible that Inf should not be in any of Int/Num/Rat, but be a subtype of Numeric

[04:47] <lue> ng: say Inf+5

[04:47] <p6eval> ng 88f018: OUTPUT¬´Inf‚ê§¬ª

[04:47] <lue> good. Nothing weird. :)

[04:47] <TimToady> it's currently Num for historical reasons having to do with IEEE floaters

[04:48] <TimToady> but p6 is supposed to extend the idea of Inf to all numeric types (that aren't native)

[04:50] <colomon> Hmmm, subtype of Numeric or subtype of Real?

[04:50] <lue> Inf can be argued to not be a number at all. (I don't argue this, btw)

[04:51] <TimToady> mostly, we need to put it where it can be dispatched sanely without having a lot of strange 'if' statements here and there

[04:51] <lue> (ahh, perl6, the only language to care about what Infinity is...) Is it a real number?

[04:51] <TimToady> but there's an argument that any values are allomorphic

[04:52] <TimToady> 42 is an integer, a real, a rational, etc.

[04:54] <lue> hmm, looking at wikipedia about infinity... this is now a quest for the truth (get our philosophy caps on!)

[04:54] <colomon> But if it's a subtype, you can be real slick with it, eh?  multi sub infix:<+>(Infinity $x, Real $y) { return $x; }

[04:54] <TimToady> don't want slick, I want cute :P

[04:55] <TimToady> we can also dispatch on specific values

[04:56] <lue> but is cute -Ofun? I think slick is.

[04:56] <TimToady> otoh, values are consider an extra constraint, so doesn't dispatch only on the nominal type

[04:56] <TimToady> (whatever that type is)

[04:57] <colomon> I think having Infinity be its own type is definitely -Ofun, whether you call it cute or slick.

[04:58] <TimToady> just thinking maybe the nominal type of a constant might be possibly be a role like Numeric without committing to a storage type, as long as all such values are distinguishable without consulting the storage type

[04:58] <lue> but then what good would be assigning a value to the variable of that type be?

[04:58] <lue> Ah, the wonders of infinity...

[04:59] <TimToady> a variable must have a storage type

[04:59] <TimToady> but these are constants

[04:59] <colomon> But we need to have pos / neg Infinity, that's two values... guess it could be two types, but that doesn't feel instinctively right to me.

[05:00] <lue> Maybe something like: my Infinity $a = +; my Infinity $b = -;

[05:02] <lue> according to dr. math, infinity is NaN. (http://mathforum.org/dr.math/faq/faq.large.numbers.html)

[05:02] <colomon> I'm really liking this idea, though.  All the special cases become simple easy to understand functions...

[05:03] <colomon> Infinity.sin() { NaN; }

[05:03] <TimToady> I don't have any fixed ideas on this, but it seems like something worth considering

[05:03] <colomon> NaN might make sense as a type as well...

[05:03] <lue> it's a concept, NaN :)

[05:03] <colomon> I will keep this in the back of my mind.

[05:04] <lue> I hold on to my belief that (x/0)=Infinity and (x/Infinity)=0

[05:07] <lue> I don't care if Infinity is NaN, IMO, it's its NaN-ness that makes it work.

[05:07] <lue> (you should ask me about my crazy theories sometime :D )

[05:07] <TimToady> is Inf-time sometime?

[05:08] <colomon> It's when you go to Milliways.

[05:09] <lue> It's probably all time and no time, at the same time >:D

[05:09] <lue> (bah, but time's an illusion (lunchtime doubly so))

[05:09] <TimToady> as for the bucket, NaNtucket.

[05:10] <TimToady> the lunch bucket, that is

[05:11] <lue> infinity is measured in NaNometers :)

[05:12] *** gfx joined
[05:12] <colomon> ng: say asin(1.0);

[05:12] <p6eval> ng 88f018: OUTPUT¬´1.5707963267949‚ê§¬ª

[05:13] <colomon> ng: say sin(asin(1.0));

[05:13] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'sin' pc 219906 (src/gen/core.pir:4769)‚ê§¬ª

[05:13] * lue wants to go to the Milliways Milk Bar :D

[05:14] <colomon> ng: say sin(1.5707963267949)

[05:14] <p6eval> ng 88f018: OUTPUT¬´No applicable candidates found to dispatch to for 'infix:<div>'‚ê§current instr.: 'perl6;Rat;new' pc 287232 (src/gen/core.pir:0)‚ê§¬ª

[05:15] <colomon> ng: my $a = asin(1.0); say $a; say asin($a);

[05:15] <p6eval> ng 88f018: OUTPUT¬´1.5707963267949‚ê§too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'asin' pc 220247 (src/gen/core.pir:4871)‚ê§¬ª

[05:15] <colomon> ng: my $a = asin(1.0); say $a; say sin($a)

[05:15] <p6eval> ng 88f018: OUTPUT¬´1.5707963267949‚ê§too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'sin' pc 219906 (src/gen/core.pir:4769)‚ê§¬ª

[05:15] <colomon> say sin(1.6)

[05:16] <colomon> ng: say sin(1.6)

[05:16] <p6eval> ng 88f018: OUTPUT¬´0.999573603041505‚ê§¬ª

[05:20] <colomon> too tired to figure this out tonight...

[05:21] <lue> 21:20 over here. I'm beginning to feel it too.

[05:21] <TimToady> of course, if IEEE floaters do the right thing with these NaNnies, then maybe we can just go ahead and use Num for mixed-mode operations when it's needed

[05:21] <lue> how do you write a recurring decimal in p6?

[05:21] <TimToady> and then we dont have to write anything special for 'em

[05:21] <colomon> lue: say 1/3

[05:22] <TimToady> yes, Rats

[05:22] <colomon> ng: say 1/3

[05:22] <p6eval> ng 88f018: OUTPUT¬´0.333333333333333‚ê§¬ª

[05:22] <colomon> ng: say (1/3).perl

[05:22] <p6eval> ng 88f018: OUTPUT¬´1/3‚ê§¬ª

[05:22] <colomon> ng: say (1/3).WHAT

[05:22] <p6eval> ng 88f018: OUTPUT¬´Rat()‚ê§¬ª

[05:22] <TimToady> ng: say (1/3).perl

[05:22] <p6eval> ng 88f018: OUTPUT¬´1/3‚ê§¬ª

[05:23] <lue> what about .999... and .111...? I wanted to try something with them...

[05:24] <lue> of course, .999... = 1 and .111... = 0. Just want to see if p6 knows this.

[05:24] <colomon> ng: say 1/9

[05:24] <p6eval> ng 88f018: OUTPUT¬´0.111111111111111‚ê§¬ª

[05:24] <lue> ng: say 1/9 = 0;

[05:24] <p6eval> ng 88f018: OUTPUT¬´0.111111111111111‚ê§Cannot assign to readonly value‚ê§current instr.: '&infix:<=>' pc 15452 (src/builtins/Junction.pir:113)‚ê§¬ª

[05:24] <RandalSchwartz> since when is .111111 = 0 ?

[05:24] <colomon> ng: say (1/9)*9

[05:24] <TimToady> ng: say 9 * 1/9

[05:24] <p6eval> ng 88f018: OUTPUT¬´1‚ê§¬ª

[05:24] <colomon> RandalSchwartz: since never. :)

[05:24] <lue> or whatever .111... is equal to.

[05:25] <lue> I know .999... is equal to 1.

[05:25] <RandalSchwartz> I'd say .11111... is equal to itself

[05:25] <colomon> I don't think there's a way to say .9999.... in perl.  Yet.

[05:25] <colomon> (I mean, as distinct from 1 or .11111.... times 9)

[05:26] <lue> 3/3 is both .999... and 1.

[05:26] <lue> 1/3=0.333...*3=1

[05:27] <lue> 1/3=0.333...*3=.999...

[05:27] <lue> (1/3)*3=1

[05:27] <colomon> afk # off to bed

[05:29] *** patspam left
[05:30] <TimToady> ng: say "yes" if 1/3 * 3 == 1

[05:30] <p6eval> ng 88f018: OUTPUT¬´yes‚ê§¬ª

[05:30] *** patspam joined
[05:30] <TimToady> don't try that one in Perl 5

[05:33] <lue> Heh, fun with numbers! Does P6 have the power to write œÄ as a ratio? (œÄ/1 doesn't count)

[05:34] <s1n> TimToady: seems to work for me (perl -e 'print "yes\n" if 1/3 * 3 == 1')

[05:35] <TimToady> bet it doesn't work for other fractions

[05:35] <s1n> lue: how would you express pi as a ratio given it's irrational?

[05:35] <TimToady> we don't have an IrRat type

[05:35] <lue> that's the point >:)

[05:35] <s1n> TimToady: perl -e 'print "yes\n" if 7/16 * 16 == 7'

[05:36] <TimToady> powers of 2 should always work

[05:36] <s1n> ahh, that's the requirement, it breaks when i do 2342345/45234214

[05:37] <s1n> wait, whoops

[05:37] <s1n> nope, still works

[05:38] <TimToady> maybe someone installed a fuzz onto == comparisons since I last looked

[05:38] <s1n> dunno, but i can't craft a number that breaks

[05:38] <TimToady> maybe they got tired of that FAQ :)

[05:39] <lue> hm, maybe I can invent the number ‚àè for the sole purpose of the ration œÄ/‚àè ...

[05:39] <lue> oops ratio

[05:43] <lue> ANFSCD... I want to make myself a 4 dimension person so I can "walk" through the timeline as I please.

[05:46] *** rv2733 joined
[05:49] *** rv2733 left
[05:50] *** rv2733 joined
[05:50] <lue> I believe the statement that 4D *can not, in any way, possibly ever be TIME,* is (quite frankly) ignorant.

[05:51] *** athenot joined
[05:52] *** drbean left
[05:54] *** rv2733 left
[06:24] *** k23z__ joined
[06:32] *** athenot left
[06:47] *** simcop2387 joined
[06:47] *** iblechbot joined
[06:49] *** lue left
[06:56] *** TiMBuS joined
[07:14] *** drbean joined
[07:28] *** Su-Shee joined
[07:29] <Su-Shee> good morning

[07:32] <Su-Shee> phenny: tell vamped yes, I'm talking the art of electronics. this summer, it seems.

[07:32] <phenny> Su-Shee: I'll pass that on when vamped is around.

[07:35] *** kaare joined
[07:35] *** kaare is now known as Guest54390

[08:18] *** vamped joined
[08:19] <vamped> hello Su-shee

[08:19] <phenny> vamped: 07:32Z <Su-Shee> tell vamped yes, I'm talking the art of electronics. this summer, it seems.

[08:19] <vamped> lol. like clockwork.

[08:20] <vamped> Su-Shee: AOE has been rumoured for 4 years. Was there anything semi-official that you saw?

[08:24] <Su-Shee> vamped: it's flagged as pre-order at amazon for half a year now and wikipedia says it's comming in 2010. 

[08:26] <Su-Shee> vamped: I already considered hooking up all those makers and arduino freaks to send fanmail to the author. ;)

[08:31] <vamped> Yes. Well the author "is working on it" and it will "take a long time." I suppose I want it done right, and not just another re-release that is not much different from the original.

[08:33] <Su-Shee> vamped: that's the same with this computer graphic's bible and the meyer-oo book and we never see new stevens' bibles again.. 

[08:36] *** synth joined
[08:36] <vamped> same with "Programming Perl" :D - it's been 10 years since last release.

[08:37] *** vamped left
[09:00] *** gfx left
[09:34] *** Chillance joined
[09:46] *** Chillance left
[09:50] *** fridim joined
[09:50] *** Chillance joined
[09:51] *** drbean left
[10:00] <colomon> ng: say 2.Num.Num

[10:00] <p6eval> ng 88f018: OUTPUT¬´2‚ê§¬ª

[10:00] <colomon> ng: say 2.1.Num.Num

[10:00] <p6eval> ng 88f018: OUTPUT¬´2.1‚ê§¬ª

[10:00] <colomon> ng: say 2.Int.Num

[10:00] <p6eval> ng 88f018: OUTPUT¬´2‚ê§¬ª

[10:03] <colomon> ng: say Inf.sin

[10:03] <p6eval> ng 88f018: OUTPUT¬´NaN‚ê§¬ª

[10:03] <colomon> ng: say asin(1).sin

[10:03] <p6eval> ng 88f018: OUTPUT¬´1‚ê§¬ª

[10:03] <colomon> ng: say asin(1)

[10:03] <p6eval> ng 88f018: OUTPUT¬´1.5707963267949‚ê§¬ª

[10:03] <colomon> ng: say sin(asin(1))

[10:03] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'sin' pc 219906 (src/gen/core.pir:4769)‚ê§¬ª

[10:06] <colomon> ng: say Int.sin('degrees');

[10:06] <p6eval> ng 88f018: OUTPUT¬´Use of type object as value‚ê§current instr.: 'perl6;Perl6Exception;throw' pc 13784 (src/builtins/Associative.pir:118)‚ê§¬ª

[10:06] <colomon> ng: say Inf.sin('degrees')

[10:06] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[10:10] *** am0c left
[10:11] *** agentzh joined
[10:26] *** mssm joined
[10:27] *** am0c joined
[10:36] *** k23z__ left
[10:44] *** pmurias joined
[10:46] <pmurias> hi

[10:58] <colomon> o/

[11:03] *** agentzh left
[11:10] *** nbrown left
[11:11] *** nbrown joined
[11:13] *** Rix joined
[11:24] *** IllvilJa joined
[11:26] *** drbean joined
[11:46] <pugs_svn> r29703 | colomon++ | [t/spec]i Fudge two questionable tests that fail hard. 

[11:47] <colomon> rakudo: say pi.Rat(1e-10)

[11:47] <p6eval> rakudo 1d4928: OUTPUT¬´3.14159265361894‚ê§¬ª

[11:47] <colomon> rakudo: say pi.Rat(1e-10).perl

[11:47] <p6eval> rakudo 1d4928: OUTPUT¬´312689/99532‚ê§¬ª

[11:51] <pugs_svn> r29704 | colomon++ | [t/spec] Replace references to pi the constant with a local variable. 

[11:57] *** masak joined
[11:58] <masak> hi #perl6. hope you had a nice Friday night. I did. :)

[11:59] <masak> I'm not staying long (going swimming), but while I'm here, I might as well submit a rakudobug.

[11:59] <masak> rakudo: foo(5) { say "HAI 5!" }; foo(5)

[11:59] <p6eval> rakudo 1d4928: OUTPUT¬´Confused at line 10, near "{ say \"HAI"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[11:59] <masak> erm.

[11:59] <masak> rakudo: sub foo(5) { say "HAI 5!" }; foo(5)

[11:59] <p6eval> rakudo 1d4928: OUTPUT¬´HAI 5!‚ê§¬ª

[11:59] <masak> rakudo: sub foo(Inf) { say "HAI INFTY!" }; foo(Inf)

[11:59] <p6eval> rakudo 1d4928: OUTPUT¬´Malformed routine definition at line 10, near "foo(Inf) {"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[12:00] <masak> rakudo: sub foo(NaN) { say "NAN BREAD!" }; foo(NaN)

[12:00] <p6eval> rakudo 1d4928: OUTPUT¬´Malformed routine definition at line 10, near "foo(NaN) {"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[12:00] *** mssm left
[12:00] * masak submits rakuodbug

[12:01] <colomon> masak: you would love the weird bugs I've been getting in ng.

[12:01] <masak> I'm sure.

[12:01] <dalek> rakudo/ng: b38e07b | (Solomon Foster)++ | t/spectest.data:

[12:01] <dalek> rakudo/ng: Turn on roots.t.

[12:01] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/b38e07b36c3cede5544d1c43b18251c48ea76a7c

[12:01] <masak> I stumbled on this, which really is a TODO bug of sorts, because I wanted to see if Inf and NaN would match other types than Num.

[12:01] <masak> TimToady mentioned in the backlog that they should.

[12:04] *** mberends joined
[12:05] <masak> mberends: o/

[12:05] <jnthn> Good day, folks. 

[12:05] <masak> lolitsjnthn!

[12:05] <mberends> good morning masak+jnthn 

[12:06] <masak> 'masak+jnthn' sounds like one of those freaky mech bots with big cannons as arms, destroying everything in their path.

[12:06] <mberends> eek! duck!

[12:07] <masak> except we don't shoot ammunition, but bug reports and Rakudo features :)

[12:07] <dalek> rakudo/ng: b9c1166 | (Martin Berends)++ | docs/compiler_overview.pod:

[12:07] <dalek> rakudo/ng: [docs/compiler_overview.pod] first 25% of rewrite for ng

[12:07] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/b9c1166a4512cee2daf8f7face4ad3331b941780

[12:07] <dalek> rakudo/ng: 075b8f9 | (Martin Berends)++ |  (19 files):

[12:07] <dalek> rakudo/ng: Merge branch 'ng' of github.com:rakudo/rakudo into ng

[12:07] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/075b8f97dab0436555621d41b93605d2cdac5e56

[12:08] <jnthn> masak: One arm shooting bugs and the other shooting fixes makes a rather schizophrenic mech bot. :-)

[12:08] <masak> jnthn: it's just the Yang and Yin of software development :)

[12:08] <mberends> o noes, that second commit was not ready for release :( please kill it somebody...

[12:09] <masak> mberends: 'git revert' and then push again?

[12:09] <mberends> thanks, will try that

[12:11] <colomon> jnthn: I've got another crazy dispatch thing going on.

[12:11] <colomon> ng: sin(Inf)

[12:11] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'sin' pc 219906 (src/gen/core.pir:4769)‚ê§¬ª

[12:12] <colomon> ng: asin(.9)

[12:12] <p6eval> ng 88f018:  ( no output )

[12:12] <colomon> ng: say asin(.9)

[12:12] <p6eval> ng 88f018: OUTPUT¬´1.11976951499863‚ê§¬ª

[12:12] <jnthn> ng: Inf

[12:12] <p6eval> ng 88f018:  ( no output )

[12:12] <jnthn> ng: say Inf

[12:12] <p6eval> ng 88f018: OUTPUT¬´Inf‚ê§¬ª

[12:12] <colomon> ng: say sin(asin(.9))

[12:12] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'sin' pc 219906 (src/gen/core.pir:4769)‚ê§¬ª

[12:13] <dalek> rakudo/ng: 4aa2add | (Martin Berends)++ |  (19 files):

[12:13] <dalek> rakudo/ng: Revert "Merge branch 'ng' of github.com:rakudo/rakudo into ng"

[12:13] <dalek> rakudo/ng: This reverts commit 075b8f97dab0436555621d41b93605d2cdac5e56, reversing

[12:13] <dalek> rakudo/ng: changes made to b9c1166a4512cee2daf8f7face4ad3331b941780.

[12:13] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/4aa2addf09895da625d199512d85fd25e55357e2

[12:13] <jnthn> ng: asin(Inf)

[12:13] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'asin' pc 220247 (src/gen/core.pir:4871)‚ê§¬ª

[12:13] <colomon> jnthn: I think we could really really use a version of that message that actually printed what the arguments and candidates were.

[12:14] <colomon> Either that or I need a dispatch internals debugging lesson.

[12:14] <masak> mberends: seems you only reverted the merge commit, and not the 25% rewrite commit.

[12:14] <mberends> warning: mberends-- may have messed up some source files. build with caution

[12:15] <colomon> ng: say Inf.sin

[12:15] <p6eval> ng 88f018: OUTPUT¬´NaN‚ê§¬ª

[12:15] <mberends> masak: the 25% rewrite is OK, that's the only one I wanted to commit

[12:15] <colomon> ng: say Inf.sin('degrees')

[12:15] <jnthn> ng: &asin.candidates>>.signature>>.perl>>.say

[12:15] <p6eval> ng 88f018: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[12:15] <p6eval> ng 88f018: OUTPUT¬´Symbol '&asin' not predeclared in <anonymous>‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[12:16] <jnthn> wtf

[12:16] <masak> mberends: there's a way to avoid making merge commits when pulling with git. it's spelled "git pull --rebase origin <branch>"

[12:16] <mberends> silly me, I remember that.... now

[12:17] <masak> it's a very nice aspect of git. it means, "pull, but pretend the work I just did comes after the things I pull".

[12:18] <masak> anyway. swimming.

[12:18] <mberends> and that can be automated in a config file too, somehow

[12:18] <masak> probably.

[12:18] <masak> I don't think I'd want it on by default, though.

[12:18] <mberends> enjoy the swim!

[12:18] <masak> will be back later to pester you all with rakudobugs and bad puns. :)

[12:18] *** masak left
[12:18] <jnthn> oh, there were puns? I should bother to backlog!

[12:19] <mberends> jnthn: you can't backlog the future... yet

[12:19] <mberends> wait long enough and it works

[12:19] <jnthn> oh

[12:20] <jnthn> That's disappointing.

[12:20] <jnthn> .oO( Why isn't the future out yet? )

[12:20] <colomon> the lack of puns or the insanity of sin?

[12:20] <jnthn> colomon: Both...though the second is more sinful than disappointing. :-)

[12:21] <jnthn> colomon: I'll take a look soonish. Need coffee.

[12:21] <colomon> ng: &asin.candidates>>.signature>>.perl>>.say

[12:21] <p6eval> ng 88f018: OUTPUT¬´sh: ./perl6: No such file or directory‚ê§¬ª

[12:22] <colomon> jnthn: roger.

[12:23] <spinclad> colomon: yes?

[12:24] <colomon> spinclad: hmmm?

[12:24] <jnthn> :-)

[12:25] <spinclad> roger: that's me.

[12:25] <colomon> Ah.

[12:33] <colomon> Apologies for accidentally invoking you.

[12:36] *** iblechbot left
[12:39] <pugs_svn> r29705 | pmurias++ | [mildew] '1' gets converted to SSA correctly 

[12:39] <pugs_svn> r29706 | pmurias++ | [mildew] refactored the conversion into ssa into subroutines 

[12:56] <jnthn> mberends: Erm.

[12:57] <jnthn> mberends: I think that revert did something really odd.

[12:57] <pugs_svn> r29707 | pmurias++ | [mildew] -Cssa executes the transformed AST 

[12:57] <pugs_svn> r29708 | pmurias++ | [mildew] inner molds are converted to ssa too 

[12:57] <pmurias> ruoso: the transformation to SSA is begining to work :)

[12:59] *** rv2733 joined
[12:59] <jnthn> mberends: It seems that it somehow reverted a bunch of changes from yesterday.

[12:59] <jnthn> Though the merge patch you reverted seemed to re-do the ones from yesterday too

[12:59] * jnthn is confused

[12:59] <mberends> jnthn: mea culpa :( I think I un-committed some other peoples' commits

[13:00] <mberends> lots of FAIL here too

[13:01] <jnthn> Essentially commit b9c1166a4512cee2daf8f7face4ad3331b941780 (the one where you added the 25% change to the doc) looks fine.

[13:02] * jnthn pulls and sees if he can clear up

[13:02] <mberends> what happened here was, I forgot to git pull before adding the 25% pod update

[13:03] <mberends> then I stashed, pulled, applied the stash, pushed. Then the mess erupted.

[13:04] <jnthn> mberends: Mighta got it sorted, testing.

[13:05] *** patspam left
[13:12] <jnthn> oh huh

[13:13] <mberends> is that good or bad?

[13:13] <jnthn> Heh

[13:13] <jnthn> Forgot that after a revert you gotta commit the revert :-)

[13:14] <jnthn> Done and pushed

[13:14] <jnthn> My tree here seems to have everything in it.

[13:14] <jnthn> So think we're OK again.

[13:14] <jnthn> Oddness. :-/

[13:14] <colomon> \o/

[13:14] <jnthn> colomon: I reproduced your sin issue.

[13:14] <mberends> pulled, testing

[13:14] <colomon> jnthn: I'm hoping you mean in a way which makes it comprehensible?

[13:15] <jnthn> colomon: Trying to work out why it's failing.

[13:15] *** drake1 joined
[13:16] <drake1> hello

[13:16] <dalek> rakudo/ng: b7fb2e1 | jonathan++ |  (19 files):

[13:16] <dalek> rakudo/ng: Revert "Revert "Merge branch 'ng' of github.com:rakudo/rakudo into ng""

[13:16] <dalek> rakudo/ng: This reverts commit 4aa2addf09895da625d199512d85fd25e55357e2.

[13:16] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/b7fb2e14e30b0ceac03cff25c7df0d4fe4da892f

[13:17] <drake1> how far is perl6 before it's safe to use?

[13:18] <mberends> drake1: we're aiming for a major milestone release called Rakudo * in April

[13:18] <jnthn> drake1: Depends what you want to use it for. :-) For experimentation and learning the language, it's safe now, I guess. :-)

[13:19] <drake1> for instance, I wrote my own little language you can use for inspiration www.gangsterfreak.com/cslib/cut/csconf :)

[13:19] <jnthn> colomon: OK, found something curious.

[13:19] <jnthn> ng: say 1.5.sin('radians')

[13:19] <p6eval> ng 4aa2ad: OUTPUT¬´sh: ./perl6: No such file or directory‚ê§¬ª

[13:19] <drake1> jnthn: just when I can build it for my CD distros

[13:20] <colomon> > say 1.5.sin('radians')

[13:20] <colomon> Any.sin  1.5  radians

[13:20] <colomon> Num.sin  1.5 radians

[13:20] <colomon> 0.997494986604054

[13:20] <jnthn> colomon: Now do Inf.sin('radians')

[13:21] <jnthn> colomon: Seems to be different between Rat and Num.

[13:21] <jnthn> :-/

[13:21] <jnthn> drake1: The Rakudo * release planned for April is probably more suitable for that.

[13:21] <colomon> > say 1.5.Num.sin('radians')

[13:21] <colomon> Num.sin  1.5 radians

[13:21] <drake1> ok

[13:21] <colomon> 0.997494986604054

[13:22] <drake1> jnthn: is it very different than perl5 or is the non-library systax like the good old one?

[13:22] <colomon> btw, jnthn, my slightly hacked sin.t passed 992 tests last night before hitting this issue.

[13:22] <jnthn> drake1: It's really rather different.

[13:23] <drake1> jnthn: so it wont replace the earlier version

[13:23] <jnthn> drake1: Perl 6 should be seen more as "another language in the Perl family" rather than "Perl 5's replacement"

[13:23] <drake1> nice

[13:23] <jnthn> drake1: Right. We install a perl6 binary.

[13:23] <jnthn> And leave /usr/bin/perl as Perl 5. :-)

[13:23] <drake1> very nice

[13:23] <jnthn> The two are meant to co-exist. :-)

[13:23] <jnthn> colomon: Wow

[13:23] *** apeiron joined
[13:23] <jnthn> colomon: I'm trying to investigate what's up, it's not obvious. :-/

[13:24] <drake1> I've heard the reference notation has change a bit

[13:25] <drake1> jnthn: what about things like use strict; and regular expression with slashes?

[13:26] <jnthn> drake1: use strict is the default in Perl 6. Regular expressions still can be written between slashes, though regex syntax has changes (not everything changed, though... /^\d+$/ for example still works just fine :-)).

[13:27] <drake1> perfect

[13:27] <drake1> then I probably wont need the old one at all

[13:27] <drake1> jnthn: and pack is still a standard func?

[13:29] <jnthn> drake1: Not sure about pack, sorry...maybe somebody else knows.

[13:29] <drake1> hm

[13:30] <drake1> maybe I should try it

[13:30] <jnthn> rakudo: pack

[13:30] <p6eval> rakudo 1d4928: OUTPUT¬´Could not find non-existent sub pack‚ê§in Main (file src/gen_setting.pm, line 324)‚ê§¬ª

[13:30] <jnthn> Ah.

[13:30] <drake1> ok

[13:31] <drake1> then it's more friendly for the kids

[13:31] <jnthn> drake1: I think "not yet implemented, not sure on if it's in the specification" is the best I can answer on that.

[13:31] <drake1> hehe

[13:31] <jnthn> :-)

[13:31] <colomon> I believe pack is intended to be implemented, but the spec isn't worked out yet.

[13:31] <jnthn> colomon: Ah, OK, cool. :-)

[13:31] <drake1> I think it should be standard though, it's one of the best for quick oneliners

[13:31] <colomon> Buf is still largely unspec'd, isn't it?

[13:32] <jnthn> colomon: Yeah, I think it's intentions are understoodish, and its details need somebody to write a first cut implementation and see how it works out.

[13:32] <colomon> And pack is a Buf function.

[13:32] <jnthn> Ah

[13:33] <jnthn> Yeah, you're right.

[13:33] *** mssm joined
[13:34] <colomon> jnthn: could some of the Num.sin calls be somehow slipping through to Parrot's version of sin?

[13:35] <jnthn> colomon: I don't see how that would happen.

[13:35] <colomon> jnthn: I don't have any idea how, but it's I'm pretty sure all of rakudo's versions of sin take two arguments, and parrot's only takes one...

[13:35] <jnthn> Oh, hang on...

[13:37] <drake1> actually I may write a perl interface for my newly invented binary executable object format, is the binary interface for perl6 alot different?

[13:38] *** pmurias left
[13:38] <colomon> drake1: I'm not sure exactly what you mean, but the answer is almost certainly yes.  Rakudo is pretty drastically different than perl 5.

[13:39] <drake1> colomon: I mean the XS interface

[13:40] <drake1> not the shell pipe open

[13:40] <jnthn> drake1: Then *very* different.

[13:40] <drake1> ok

[13:40] <drake1> maybe you have a doc with the outline?

[13:41] <drake1> and what about typeglobs, are you going to continue the use?

[13:42] <jnthn> We don't have anything solid yet - the best thing on offer at the moment is actually a module, which can be found at http://github.com/quietfanatic/link-c

[13:42] <drake1> ok

[13:42] <drake1> (trying to find a pen for a note

[13:43] <drake1> got it

[13:43] <jnthn> colomon: That Parrot sin method thought may be a good one...

[13:44] <colomon> jnthn: would there be parrot docs foR drake1's binary interface. 

[13:44] <colomon> ?

[13:44] <drake1> seems like link-c

[13:44] <jnthn> colomon: Perhaps, but then you gotta know how to dive down to the Parrot level to do bits too.

[13:44] *** jcharlot joined
[13:45] <jnthn> drake1: Essentially though, Rakudo compiles Perl 6 down to bytecode that runs on the Parrot VM, and it provides the guts of the native calling stuff.

[13:45] <jnthn> link-c is built atop of those.

[13:46] <jnthn> colomon: You were spot on.

[13:46] <jnthn> :-)

[13:46] <drake1> like for dynamic links or what you mean?

[13:46] <jnthn> drake1: For calling functions in an external library.

[13:46] <drake1> sweet

[13:46] <jnthn> drake1: The intention is that you don't need a glue layer any more.

[13:47] <drake1> but the type must be set

[13:47] <jnthn> drake1: Eventually, we want to have something nice and declarative at the Perl 6 level.

[13:47] <jnthn> drake1: However, it's one of the parts of Perl 6 that's still very much a work in progress. :-)

[13:47] *** athenot joined
[13:47] <jnthn> Yeah, Perl 6 lets you write types in signatures, so we can hopefully get something nice.

[13:47] <drake1> please let me know if I can be of any help [email@hidden.address]
[13:48] <jnthn> Well, playing with stuff and reporting bugs is always welcome. :-)

[13:48] <jnthn> colomon: I has a fixish thing. :-)

[13:48] <drake1> only found one bug in the perl core so far, but it was the new version of od in the bin that changed the display instead

[13:49] <colomon> \o/

[13:49] *** jcharlot left
[13:50] <jnthn> drake1: Perl 6 is at a much earlier stage, so I'm afraid for now there's many more bugs to find.

[13:51] <jnthn> drake1: We're working hard at stomping on 'em though. :-)

[13:51] <drake1> sure

[13:51] <drake1> hehe

[13:52] <drake1> im trying to find some in my own source codes but I can't

[13:53] <drake1> completely auto-generated C

[13:53] <jnthn> colomon: spectesting then will push if all is well

[13:53] <colomon> \o/

[13:54] *** TiMBuS left
[13:58] <jnthn> colomon: pushed

[14:00] <jnthn> colomon: I plan to work on captures, nested signatures, etc a bit today.

[14:02] <dalek> rakudo/ng: 6090323 | jonathan++ | src/cheats/num.pm:

[14:02] <dalek> rakudo/ng: Make sure NaN, Inf etc are Perl 6 Nums, not Parrot Floats, so we dispatch to the right sin, etc.

[14:02] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/6090323be886c31ac85fb12bb61c76e66f005293

[14:03] <drake1> you can make nice graphs with gnuplot if you're going to test the math stuff

[14:08] <colomon> jnthn: that seems to clear up the sin(Inf) issue, but not the nearly identical asin issue.  hold a moment and I'll get you a test case.

[14:08] *** drbean left
[14:08] <colomon> ng: say sin(asin($desired_result))

[14:08] <p6eval> ng b7fb2e: OUTPUT¬´Symbol '$desired_result' not predeclared in <anonymous>‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[14:09] <colomon> ng: sin(asin(0))

[14:09] <jnthn> colomon: There's a high probability that it's a similar issue

[14:09] <p6eval> ng b7fb2e: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§current instr.: 'sin' pc 219906 (src/gen/core.pir:4769)‚ê§¬ª

[14:09] <jnthn> colomon: That is, somewhere we're ending up with a Parrot Float, not a Perl 6 Num

[14:09] <drake1> whats that .pir ?

[14:10] <colomon> and that still happens in my build here with Inf fixed.

[14:10] <jnthn> colomon: Right, I guess asin must be returning a Parrot Float then.

[14:10] <colomon> jnthn: oh, could it be in the result of sin, asin, etc is a Parrot Float.

[14:10] <jnthn> brb, making some lunch.

[14:10] <mberends> drake1: http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html

[14:11] <drake1> thanks

[14:11] <drake1> it almost rhymes on one of my alias names hehe

[14:12] <colomon> ng: say sin(sin(0))

[14:12] <p6eval> ng b7fb2e: OUTPUT¬´0‚ê§¬ª

[14:13] <colomon> ng: say sin(pir::asin__Nn(0))

[14:13] <p6eval> ng b7fb2e: OUTPUT¬´0‚ê§¬ª

[14:14] <colomon> ng: say sin(pir::asin__Nn(0.5))

[14:14] <p6eval> ng b7fb2e: OUTPUT¬´0.5‚ê§¬ª

[14:15] <drake1> so perl6 uses the sine maps from the local FPU environment?

[14:16] <colomon> drake1: it uses the Parrot sine, which I expect is the local FPU.

[14:16] <drake1> hm

[14:16] <drake1> thought you meant suspect

[14:16] <colomon> jnthn: I need to be away from the keyboard a bit, but it looks to me like the problem must somehow be in Any!from-radians

[14:17] <jnthn> colomon: ah, ok

[14:17] <colomon> jnthn: see the above direct calls to pir, and the fact that sin and asin have the same Nn signature

[14:17] <colomon> but I completely cannot understand what might be wrong with !from-radians, particularly as this is the radians case, which just returns self.

[14:20] *** lichtkind joined
[14:21] <colomon> afk

[14:26] *** TiMBuS joined
[14:27] *** drake1 left
[14:33] *** apeiron left
[14:37] <mberends> ng 6090323 todos 76, skips 324, passes 3966 out of 4366 tests!

[14:38] <jnthn> Almost 4000!

[14:38] <jnthn> Wow, that was an unhealthy lunch. :-)

[14:45] <colomon> :)

[14:50] <jnthn> Don't see immediately hwy !from-radians is wrong...as you say, it just returns self.

[14:51] <jnthn> ng: say PARROT(4.2e1)

[14:51] <p6eval> ng 609032: OUTPUT¬´sh: ./perl6: No such file or directory‚ê§¬ª

[14:51] <jnthn> oh, here's an interesting one.

[14:51] <jnthn> > say PARROT(sin(4.2e1))

[14:51] <jnthn> Num

[14:51] <jnthn> > say PARROT(asin(4.2e1))

[14:51] <jnthn> Float

[14:53] <lichtkind> mberends: moin

[14:53] <jnthn> > say PARROT(pir::asin__Nn(4.2e1))

[14:53] <jnthn> ng: say PARROT(pir::asin__Nn(4.2e1))

[14:53] <p6eval> ng 609032: OUTPUT¬´Num‚ê§¬ª

[14:54] <jnthn> ng: say PARROT(pir::asin__Nn(4.2e1)!from_radians('radians'))

[14:54] <p6eval> ng 609032: OUTPUT¬´Method '!from_radians' not found for invocant of class 'Float'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[14:55] *** snarkyboojum joined
[14:56] <jnthn> ng: say PARROT(pir::asin__Nn(4.2e1)!from-radians('radians'))

[14:56] <p6eval> ng 609032: OUTPUT¬´Float‚ê§¬ª

[14:58] <pmichaud> good morning, #perl6

[15:01] <jnthn> morning, pmichaud 

[15:02] <jnthn> colomon: from_radians is indeed going to the "just hand back self" branch, so I'm rather mystified as to how things go wrong there, though clearly it looks like they are.

[15:02] <jnthn> *from-radians, that is.

[15:08] <colomon> yup, that's a weird one, all right.

[15:13] <pmichaud> okay, what's on the list of things that need fixing today?

[15:13] *** rv2733 left
[15:14] <colomon> pmichaud: how hard would constants be to do?  I keep on bumping into the lack of pi.

[15:14] <pmichaud> checking

[15:21] <pmichaud> jnthn: ping

[15:21] <jnthn> pmichaud: p0ng

[15:22] <pmichaud> in Grammar.pm:116, where we look up barewords to see if they're known names, why do we do all of the checks for Abstraction/P6protoobject/Perl6Role ?

[15:23] <jnthn> pmichaud: What would you expect to see?

[15:24] <pmichaud> naively, anything that is named in the namespace.

[15:24] <jnthn> An our sub would be named in the namespace too though?

[15:24] <pmichaud> i.e., if the symbol exists, then it's a known "name"

[15:24] <pmichaud> an our sub wouldn't be a bareword

[15:24] <pmichaud> because they begin with &

[15:24] <pmichaud> (yes, that _used_ to be the case in master :-)

[15:25] <jnthn> I dunno...that may be a little too naiive.

[15:25] <jnthn> You're right that we maybe would get away with it now.

[15:25] <jnthn> We could try it.

[15:25] <pmichaud> well, I agree, but we have the case of    constant foo = 3    which will put "foo" into the namespace

[15:26] <pmichaud> so we're no longer just looking for abstraction/protoobject/p6role

[15:26] <jnthn> Yeah, true.

[15:26] <jnthn> We didn't have the issue in master since constants were lexically scoped there.

[15:26] <pmichaud> right

[15:26] <jnthn> We never caught up with the our-scoped change.

[15:27] <jnthn> I don't see any immediate problems with saying "bareword and in the namespace = known name"

[15:27] <pmichaud> the one place that might bite us is parrot's method-in-namespace bug

[15:27] <jnthn> Yes.

[15:27] <pmichaud> because methods end up in the namespace without the '&'

[15:27] <pmichaud> but actually, given the way we build our methods now, I suspect that might not be the case

[15:27] <jnthn> Even if you :nsentry('') them?

[15:28] <pmichaud> well, I'll remove the checks and see what happens

[15:28] <jnthn> Is there a reason we can't :anon methods now, by the way?

[15:28] <pmichaud> it doesn't mean what we think it means :-(

[15:28] <jnthn> I thought it just meant "don't put it in the namespace"?

[15:28] <pmichaud> basically (unless chromatic++ has already fixed it),  :anon had the effect of not registering it as a method, iirc

[15:29] <jnthn> We don't care though.

[15:29] <pmichaud> oh, that's true.

[15:29] <jnthn> I don't think I even emit :method on methods any more.

[15:29] <jnthn> We add them all through the meta-model.

[15:29] <jnthn> .^add_method...

[15:29] <pmichaud> anyway, I'll try removing the checks and we'll see what breaks.

[15:29] <jnthn> OK

[15:30] <jnthn> tbh that code was rather inspired by master anyway

[15:30] <jnthn> :-)

[15:30] <pmichaud> yeah

[15:30] <pmichaud> also, I notice a quite a few

[15:30] <pmichaud>     my $test  := pir::get_hll_global__PPS(@parts, $final);

[15:30] <pmichaud> __PPs  is much more efficient than __PPS

[15:30] <jnthn> Remind me what uppercsae vs lowercase means again?

[15:30] <pmichaud> (well, maybe not *much*, but the __PPS version ends up creating a string register)

[15:31] <pmichaud> uppercase ==  *must* be a register

[15:31] <jnthn> Ah, OK

[15:31] <pmichaud> lowercase == may be a constant or register

[15:31] <jnthn> OK.

[15:31] <jnthn> btw, in S02:

[15:31] <jnthn> A parcel may be captured into an object with backslashed parens:

[15:31] <jnthn>     $args = \(1,2,3,:mice<blind>)

[15:31] <jnthn> Does that read to you as "what's in $args after this is a Capture"?

[15:31] <pmichaud> yes.

[15:31] <jnthn> OK, good.

[15:32] <jnthn> The wording just felt a bit...odd. :-)

[15:39] <jnthn> Hmm...this in S02 is fossil, I guess:

[15:39] <jnthn> In item context, though, the implied parentheses are not removed, so

[15:39] <jnthn> $a = < a b >;

[15:39] <jnthn> is equivalent to:

[15:39] <jnthn> $a = ('a', 'b');

[15:39] <jnthn> which, because the list is assigned to a scalar, is autopromoted into

[15:39] <jnthn> a C<Capture> object:

[15:39] <jnthn> $a = \('a', 'b');

[15:40] *** Psyche^ joined
[15:40] <lichtkind> does anybody know who writes lith-ology.blogspot.com ?

[15:40] <pmichaud> jnthn: yes, fossil.

[15:40] <jnthn> Good.

[15:40] <pmichaud> colomon: how would you like pi to be initialized?

[15:41] <pmichaud> and, where should we put it?  ;-)

[15:42] <colomon> pmichaud: Hmmm... Num.pm?

[15:42] <pmichaud> looks like it goes in Numeric

[15:43] <pmichaud> keep in mind we have to have it defined before any function/method that uses it, also

[15:43] <pmichaud> (S32 says Numeric)

[15:43] <pmichaud> C<Numeric> provides some constants in addition to the basic

[15:43] <pmichaud> mathematical functions.

[15:43] <pmichaud> constant pi is export = 3.14159_26535_89793_23846_26433_83279_50288;

[15:43] <colomon> right but we don't have Numeric this week, do we?

[15:43] <colomon> :)

[15:43] <colomon> also, there's another issue there...

[15:43] <pmichaud> we can create a Numeric.pir, though, and just put 'pi' in it :)

[15:43] <colomon> ng: my $pi = 3.14159_26535_89793_23846_26433_83279_50288

[15:43] <p6eval> ng 609032: OUTPUT¬´PAST::Compiler can't compile node of type BigInt‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[15:44] *** Psyche^ is now known as Patterner

[15:44] <pmichaud> yeah, we need something to detect when we're outside the boundaries of Rat

[15:44] <colomon> which is to say, it tries to construct it as a Rat and fails miserably.

[15:44] <lichtkind> pmichaud: fossil is the author?

[15:45] <colomon> pmichaud: shouldn't it be Numeric.pm?  Or does it have to be in the pir world?

[15:45] <pmichaud> lichtkind: I was replying to jnthn

[15:45] <pmichaud> colomon: initially it probably needs to be in the pir world, unless 'constant' is already implemented

[15:45] <jnthn> No, it's not.

[15:45] <colomon> ah, okay.  Numeric.pir it is.  :)

[15:45] <pmichaud> then I'll put it in the pir world as a cheat for now

[15:46] <jnthn> Though since it's just "stick this thingy in the namespace" it should be relatively easy. :-)

[15:46] <pmichaud> right

[15:46] <pmichaud> jnthn: no issues with changing the name test (yay!)

[15:46] <pmichaud> at least, we pass spectest

[15:47] <jnthn> pmichaud: I doubted there would be.

[15:47] <jnthn> :-)

[15:47] <jnthn> Just the method one we may hit, but that's likely not a big deal for now.

[15:48] <dalek> rakudo/ng: 00da096 | pmichaud++ | src/Perl6/Grammar.pm:

[15:48] <dalek> rakudo/ng: Modify the is_name() test to be less discriminating.  All spectests

[15:48] <dalek> rakudo/ng: pass (although we may have to revisit this at some point in the future).

[15:48] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/00da096219781eea36b3dbc9903f2624e7cacf61

[15:51] <pmichaud> Currently we have src/cheats/setup-io.pm, but it looks like it's starting to initialize more than just the io process vars

[15:51] <pmichaud> perhaps a src/cheats/constants.pir instead ?

[15:51] <jnthn> pmichaud: Oh, that was me being lazy and thinking "heh, it's in cheats anyway" :-)

[15:52] <jnthn> pmichaud: I'm curious what the non-cheat version of that lot should look like

[15:52] <jnthn> Anyway, yes, feel free to rename...

[15:52] <pmichaud> well, we might not be able to avoid the cheat there.... that somewhat gets into "knowhow" issues

[15:52] <pmichaud> it may be that we want src/knowhow/parrot/...   for that sort of stuff :)

[15:52] <jnthn> knowhow?

[15:53] <pmichaud> well, whatever we use to say "this is the parrot-specific internals the compiler has to know about"

[15:53] <jnthn> I was pondering more a src/backend/parrot/ etc structure

[15:53] <pmichaud> that works too.

[15:53] <pmichaud> although maybe it's just src/vm/parrot

[15:53] <jnthn> That's better.

[15:53] <jnthn> I wrote the last one and looked at it like "eww, long" 

[15:53] <[particle]> or rts (runtime system)

[15:54] <pmichaud> i.e., things that really can't be "cheats" but also are vm-specific

[15:54] <jnthn> Yeah

[15:54] <jnthn> I'd rather we defer any re-structuring like that until we're actively working on an additional backend though.

[15:54] <pmichaud> hmmm.... I didn't think that $*OS was a string

[15:54] <jnthn> Oh?

[15:55] <jnthn> oh, wrose

[15:55] <jnthn> S02 doesn't evne name it.

[15:55] <pmichaud> right, it's now  $*DISTRO

[15:55] <lichtkind> so nobody knows here who is lithology

[15:56] <pmichaud> lichtkind: no, I don't.

[15:56] <pmichaud> oh, wait

[15:56] <pmichaud> might be able to find it in the mailing archives

[15:56] <jnthn> Is that the guy who writes teh summaries?

[15:56] <lichtkind> yes

[15:56] <lichtkind> in the blog software is no name

[15:56] <pmichaud> lichtkind: http://lists.parrot.org/pipermail/parrot-dev/2010-January/003668.html

[15:57] <pmichaud> has the name, email address, etc.

[15:58] <lichtkind> pmichaud: thanks, but there is a nick , no clear name :)

[15:58] <pmichaud> there's an email address :)

[16:00] <pmichaud> echo "Who are you?" | mail [email@hidden.address]  # :-)

[16:01] <lichtkind> true :)

[16:03] *** nihiliad joined
[16:07] *** iblechbot joined
[16:14] *** nadim joined
[16:15] <colomon> rakudo: say pi.Rat(1e-10).perl

[16:15] <p6eval> rakudo 1d4928: OUTPUT¬´312689/99532‚ê§¬ª

[16:15] <pmichaud> > say pi

[16:15] <pmichaud> 3.14159265358979

[16:16] <colomon> ooooooo.

[16:16] <pugs_svn> r29709 | lichtkind++ | submit 2 perl 6 talks, made and held by lichtkind 

[16:16] <pmichaud> > say e

[16:16] <pmichaud> 2.71828182845905

[16:16] *** justatheory joined
[16:16] <pmichaud> test then commit then push :)

[16:18] *** Trashlord joined
[16:21] <jnthn> Yay, first pieces of Capture coming together.

[16:21] <Trashlord> yay!

[16:21] <jnthn> colomon: BTW...

[16:21] <jnthn> t\spec\S32-num\roots.rakudo ................................... Failed 4/44 subt

[16:21] <jnthn> ests

[16:21] <jnthn> colomon: I've been seeing this since roots.t was added back.

[16:21] <jnthn> It may be platform specific.

[16:22] <colomon> works on mine.  hmmm....

[16:22] <colomon> I checked in all my changes to it...

[16:23] <colomon> which tests are failing?

[16:24] <jnthn> Failed tests:  4, 6, 8, 10

[16:24] <jnthn> If they involve NaNs or Infs, then *very* likely platform issue.

[16:25] <jnthn> In also have abs.t:

[16:25] <jnthn> TODO passed:   9-10, 14-15, 29-30, 34-35

[16:25] <jnthn> And sign.t:

[16:25] <jnthn> Failed test:  29

[16:25] <jnthn> I may try a run on my laptop at some point though...using a newer version of the compiler on there.

[16:25] <colomon> jnthn: I have the abs.t todo passes here, too.  The issue is it's a big loop and some of the values work and some fail.

[16:26] <jnthn> Ah, OK

[16:26] <jnthn> np then.

[16:26] <colomon> I tried looking into again the other day.

[16:26] <colomon> ng: say 0.abs.WHAT

[16:26] <p6eval> ng 00da09: OUTPUT¬´Num()‚ê§¬ª

[16:26] <colomon> ng: say PARROT(0)

[16:26] <p6eval> ng 00da09: OUTPUT¬´Integer‚ê§¬ª

[16:26] <jnthn> oh, damm

[16:26] <jnthn> Our integer constants are being made as Parrot Integer rather than Perl 6 Int? Hm.

[16:27] <colomon> I dunno, just thought of trying that.

[16:27] <colomon> ng: say PARROT(0.Int)

[16:27] <p6eval> ng 00da09: OUTPUT¬´Integer‚ê§¬ª

[16:27] <colomon> ng: say 4.abs.WHAT

[16:27] <p6eval> ng 00da09: OUTPUT¬´Num()‚ê§¬ª

[16:28] <colomon> ng: my Int $a = 3; $a++; say PARROT($a); say $a.abs.WHAT

[16:28] <pmichaud> we might be type-mapping Float->Num, but I don't think we've done that for Integer->Int.  Last time I tried that, I think it made Rakudo unbearably slow.

[16:28] <p6eval> ng 00da09: OUTPUT¬´ObjectRef->Integer‚ê§Num()‚ê§¬ª

[16:28] <jnthn> colomon: In Actions.pm, there's a line

[16:28] <jnthn> if $<integer> { make PAST::Val.new( :value($<integer>.ast) ); }

[16:28] <jnthn> Maybe add a :returns('Int') and see if that helps.

[16:28] <pmichaud> jnthn++

[16:28] <jnthn> We had that in master

[16:28] <dalek> rakudo/ng: f90dfa8 | jonathan++ |  (5 files):

[16:28] <dalek> rakudo/ng: Stub in Capture, add capture and capterm in the grammar and actions for them, and add Parcel.Capture for coercing a Parcel to a Capture (capterm is implemented in terms of this; we need it anyway for other bits).

[16:28] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/f90dfa8f1e2256dbd4b18e94e9773ae86c923dce

[16:29] <jnthn> Heh, Parcel.Capture is a step towards my (siggy here) := foo(); too :-)

[16:30] <jnthn> That said, I ain't quite figured out yet, how on earth we know that the decl is meant to return a signature rather than a list that we need for assignment.

[16:30] <jnthn> Oh, maybe I know how we can...

[16:30] <jnthn> Anyway, that's not on today's hit list. :-)

[16:30] <pmichaud> the answer would have to be that it always returns a signature, and that assignment to a signature knows how to dtrt

[16:31] <jnthn> pmichaud: I was thinking more that we could resolve it at compile time... :-|

[16:31] <jnthn> In the reducecheck or some such.

[16:31] <pmichaud> maybe, but that feels wrongish to me

[16:31] <jnthn> Why?

[16:31] <pmichaud> because then assignment is having to do additional checks of the lhs

[16:32] <pmichaud> I think it much more likely that we'll need a way to convert Signature objects into a parcel of the things in the signature

[16:32] <pmichaud> (for other operations as well)

[16:33] <jnthn> I was pondering making it produce a PAST node that is the list of variables that list assignment needs, but tagging it with the Perl6::Compiler::Signature, and binding knows that if it gets something on the LHS tagged with one of those it should grab that and use it instead.

[16:33] <jnthn> We can do it the other way.

[16:33] <pmichaud> what about something like

[16:33] <pmichaud>     foo(my ($a,$b));

[16:33] <jnthn> std:  foo(my ($a,$b));

[16:33] <p6eval> std 29709: OUTPUT¬´Undeclared routine:‚ê§   'foo' used at line 1‚ê§ok 00:01 109m‚ê§¬ª

[16:33] <jnthn> Heh

[16:33] <jnthn> What does that mean? :)

[16:34] <pmichaud> std:  say(my ($a,$b));

[16:34] <p6eval> std 29709: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[16:34] <jnthn> It'd want the list of variables there anyway.

[16:34] <pmichaud> right

[16:34] <pmichaud> but it's hard to determine that syntactically, I think.

[16:34] <jnthn> I was meaning syntactic on the :=

[16:34] <dalek> rakudo/ng: aa4e264 | pmichaud++ |  (2 files):

[16:34] <dalek> rakudo/ng: Add "pi" and "e" constants.

[16:34] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/aa4e2643ad1fa247adb688a11e050546601b4051

[16:34] <dalek> rakudo/ng: a3054f5 | pmichaud++ |  (5 files):

[16:34] <dalek> rakudo/ng: Merge branch 'ng' of [email@hidden.address] into ng

[16:34] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/a3054f5c74df5f6e8e0c1fd2a5a7e6441222ecce

[16:34] <jnthn> That is, it's always a list apart from in that case.

[16:35] <pmichaud> okay, then the reason I don't like it is that we'd have to do add syntactic checks on := where they aren't currently present.

[16:35] <pmichaud> perhaps we should ask TimToady++ if he thinks that signature binding is more of a syntactic construct or a runtime-thingy.

[16:35] <jnthn> I'm tend to prefer making static decisions when we can...

[16:36] <jnthn> Yes, good idea.

[16:36] <jnthn> I'd been thinking of it as a syntactic one.

[16:36] <jnthn> But that could well be wrong.

[16:36] <pmichaud> well, "prefer making static decisions"  sounds like "optimization" to me.

[16:36] <jnthn> Optimization but also predictability. :-)

[16:36] <pmichaud> static-as-optimization feels different to me than static-as-specification

[16:37] <jnthn> Sure

[16:37] <pmichaud> ooc, is it possible to get a Signature object into a scalar?

[16:37] <jnthn> OK, we get a ruling from TimToady++. :-)

[16:37] <pmichaud> or to have a function that returns a signature object?

[16:38] <jnthn> I don't see why my $x = :(...); wouldn't work.

[16:38] <jnthn> They're "just objects" in a sense.

[16:38] <colomon> jnthn: doesn't see to compile with :returns('Int')  ?  I put it after :value() ...

[16:38] <jnthn> Error?

[16:38] <pmichaud> jnthn: if it's possible to get a non-syntactic signature on the lhs of :=, then we'd have to handle it as a runtime thingy

[16:38] <jnthn> colomon: You did put a comma in too? :value(...), :returns('Int')

[16:39] <pmichaud> fn-returning-signature() := ....

[16:39] <jnthn> pmichaud: Hmm

[16:39] <colomon> nope, that must be it.

[16:39] <TimToady> my brane is in sideways today due to a sinus infection, but it seems to me that a reducecheck is conservative, and can be generalized later if desired

[16:39] <jnthn> pmichaud: Well, I was planning to make that work anyway.

[16:39] <pmichaud> jnthn: right, in which case that part isn't syntactic :-)

[16:39] <jnthn> pmichaud: The issue I had was more that we expect my ($a, :$b) = ... and my ($a, :$b) := ... to mean differnt things.

[16:40] <jnthn> That is, we expect a different thing on the LHS.

[16:40] <pmichaud> jnthn: which is why I think we expect a same thing on the LHS (a signature), and simply write  Signature!STORE

[16:40] <pmichaud> for assignment

[16:40] <jnthn> I can go with that, I just didn't fancy making every list assignment slower and much more complex.

[16:41] <pmichaud> it shouldn't be significantly slower.

[16:41] <pmichaud> and Signature!STORE can be optimized

[16:41] <jnthn> Which it will, because the signature will have to go look in the lexpad of its caller for all of the variables.

[16:41] <TimToady> It's not clear to me that 'my' returns a signature

[16:41] <pmichaud> ah, good clarification :)

[16:41] <jnthn> TimToady: Let me take a step back a bit.

[16:41] <colomon> > say PARROT(0)

[16:41] <colomon> Int

[16:41] <colomon> > say 0.abs.WHAT

[16:41] <colomon> Int()

[16:41] <TimToady> though you still have :() =

[16:42] <jnthn> sub foo() { return 1, :a<2>; }

[16:42] <TimToady> returns Parcel, I think

[16:42] <jnthn> my ($a, :$b) = foo(); # list assignment of the Parcel from foo, so $a gets 1, $b gets a Pair

[16:43] <pmichaud> why the :?

[16:43] <jnthn> my ($a, :$b) := foo(); # signature binding, $a gets 1, $b gets 2

[16:43] <jnthn> pmichaud: It was to contrast with the example that followed it.

[16:43] <pmichaud> I mean the colon in :$b ?

[16:43] <jnthn> Named parameter.

[16:43] <pmichaud> in which case it's not bound from a positional argument

[16:43] <jnthn> What's parsed after my is a signature.

[16:44] <TimToady> I'm not sure we have to support assignment to any possible signature

[16:44] <jnthn> But....we're not doing signature binding, but list assignment there.

[16:44] <pmichaud> okay, then your second case is wrong.

[16:44] <jnthn> I've been uncomfortable with this area of the spec before, fwiw.

[16:44] <jnthn> No, because in the second case, we are doing binding.

[16:44] <pmichaud> why would :$b get the :a<2> ?

[16:44] <TimToady> I don't see why we have to support list assignment to a fancy signature

[16:44] <pmichaud> they have different names

[16:45] <jnthn> pmichaud: oh gah

[16:45] <jnthn> I mean :b<2>

[16:45] <jnthn> Sorry

[16:45] <TimToady> list assignment shouldn't have to worry about named parameters *at all*

[16:45] *** masak joined
[16:45] <jnthn> TimToady: Are you saying that a signautre that has things in it other than positionals gets them discounted, or it's an error to have an excessively complex signature there if'll moan?

[16:45] <TimToady> yes

[16:45] <jnthn> TimToady: OK. So

[16:45] *** TiMBuS left
[16:46] <jnthn> sub foo() { return 1, :b<2> }

[16:46] <jnthn> my ($a, $b) = foo(); # fine, $a has 1, $b has a Pair

[16:46] <TimToady> yes

[16:46] <jnthn> my ($a, :$b) = foo(); # error?

[16:46] <jnthn> And error when if so?

[16:46] <TimToady> reducecheck sez "Too fancy to assign to"

[16:47] <pmichaud> what about a signature object, as opposed to a declar?

[16:47] <jnthn> And finally, my ($a, :$b) := foo(); # $a gets 1, $b gets 2?

[16:48] <TimToady> binding should work consistently, modulo rw concerns

[16:48] <lisppaste3> colomon pasted "With the return Int patch" at http://paste.lisp.org/display/94909

[16:48] <jnthn> TimToady: "consistently"?

[16:48] <TimToady> same as parameter binding

[16:49] <colomon> split-simple2 I've been getting.  abs.t has more todo passes, great.

[16:49] <jnthn> TimToady: OK.

[16:49] <pmichaud> what about assignment to a signature object (that has named params)?

[16:49] <TimToady> as in, "oops, I got a Parcel, need a Capture, so .Capture it"

[16:49] *** Su-Shee left
[16:49] <TimToady> how the heck to you assign to a signature object?

[16:49] <TimToady> *do you

[16:49] <pmichaud> fn-returning-signature() = ... ? 

[16:49] <jnthn> :($a, :$b) = 1, :b<2>;

[16:49] <TimToady> if $sig = ... it replaces the sig

[16:49] <colomon> basic-types.t seems to be missing its last test, and pointy.t and arity.t are both quitting early.

[16:49] <pmichaud> if not possible, no problem.

[16:50] <TimToady> I suspect we can just outlaw that for now

[16:50] <jnthn> I guess the above is just a "Can not write to readonly thingy"

[16:50] <pmichaud> whatever we do to outlaw that can also be used to outlaw the   my ($a, :$b) = ...  thing

[16:50] <TimToady> we can do anything conservative we like, as long as it doesn't admit possiblities that will have to be outlawed later

[16:50] <pmichaud> granted that reducecheck can make it a compile-time check instead of a runtime one

[16:50] <pmichaud> but we'd still need the runtime check

[16:51] <TimToady> pmichaud: I think that's different

[16:51] <jnthn> TimToady: The one I struggle with a bit in this area too is...

[16:51] <jnthn> my ($a, :$b) := foo(); # works, does what's expected

[16:52] <jnthn> :($a, :$b) := foo(); # what to do here?

[16:52] <jnthn> Since I kinda expect them both to call some kinda !BIND method on Signature or some such.

[16:53] <pmichaud> fwiw, current rakudo-ng plan is that   infix:<:=>  is a standard operator (multisub)

[16:53] <jnthn> But IIRC, the second is meant to do, well, nothing.

[16:53] <TimToady> sure, but it's probably declaring a $a and $b inside the sig and then throwning them away

[16:53] <TimToady> I think that's even specced somewhere

[16:53] <jnthn> Hmm

[16:53] <TimToady> it's the declarator that says *where* you're installing the new symbols

[16:53] <jnthn> I can sorta see that conceptually-ish...trying to work out how to map that to an implementation is trickier. :-)

[16:54] <TimToady> no declarator, no install

[16:54] <TimToady> but sigs declare new variables, not referring to externals

[16:54] <TimToady> so it all follows

[16:54] <jnthn> I guess.

[16:55] <TimToady> probably the only weird thing left is actually ($a,$b) := ($b,$a) # no : on front

[16:55] <jnthn> Hmm

[16:55] <jnthn> "List binding"?

[16:56] <TimToady> it's liek we need a way to promote a list of lvalues to a sig

[16:56] <TimToady> *like

[16:56] <TimToady> probably can be done at compile time

[16:56] <jnthn> Again, recognized syntacticly?

[16:57] <TimToady> but it's also got to defeat the declaring of a new $a and $b

[16:57] <TimToady> I think so

[16:57] <TimToady> $foo := ($b,$a) is always going to clobber $foo itself, regardless of what's in $foo

[16:57] <pmichaud> why does that have to be recognized syntactically?

[16:57] <jnthn> TimToady: In sub foo($a, :$b) { } I'd kinda ended up with an impl where the sig can say "here are the variables declared within me".

[16:58] <pmichaud> ($a,$b) := ($b,$a)  doesn't have to be recognized syntactically

[16:58] <pmichaud> any more than we don't have to syntactically recognize  ($a,$b) = ($b,$a)

[16:58] <TimToady> well, it would be good to know at compile time that you can't say ($a,1,$b) := ($b,$a)

[16:59] <TimToady> certainly Perl 5 takes the lvalue checks rather seriously

[17:00] <TimToady> and knowing something's an lvalue has got to be good info for an optimizer

[17:00] <jnthn> TimToady: What I don't get about the "promote LHS to a signature" suggestion is that this makes it like :($a, $b) := ..., which we just said didn't update $a and $b.

[17:00] <TimToady> it promotes to something else then

[17:00] <TimToady> an "lvalue parcel"

[17:00] <pmichaud> we already have lvalue parcels for list assignment, fwiw

[17:01] <jnthn> TimToady: Or we just make :($a, $b) := ... do what IMHO is the Right Thing.

[17:01] <jnthn> (actually update things, rather than just throw away data)

[17:01] <jnthn> I can see it becoming an FAQ, that's all.

[17:02] <jnthn> "Why can't I update existing variables with the return values of a function if I also want to do unpacking of arguments signature-style?"

[17:03] *** LaVolta joined
[17:03] <jnthn> Agree if we want to keep current semantics an "lvalue parcel" makes more sense though.

[17:03] <masak> ng passes 4k tests!? wow!

[17:03] <pmichaud> should be a lot more, soon -- we have constant pi and constant e working again as of about 10 minutes ago

[17:03] <jnthn> masak: Progress!

[17:04] <pmichaud> and I'm about to fix slices, I hope

[17:04] <masak> \o/

[17:04] <jnthn> \o/

[17:05] <jnthn> colomon: Thsoe new failures are...curious. :-/

[17:05] <TimToady> supersede ($a, $b) := ... should make for an explicit override of an existing declaration, maybe

[17:05] <jnthn> ah, that could work.

[17:05] <jnthn> Maybe.

[17:06] <jnthn> :-)

[17:06] <colomon> they look llike they might all be seg faults

[17:06] <TimToady> std: supersede ($a, $b) := ...

[17:06] <p6eval> std 29709: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[17:06] <pmichaud> colomon: I've been getting those for a while now

[17:06] <colomon> and don't have anything obvious to do with 

[17:06] <colomon> ints

[17:06] *** lue joined
[17:06] <TimToady> arguably, that should complain that $a and $b are missing

[17:06] <TimToady> std: supersede Foo

[17:06] <p6eval> std 29709: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§In supersede declaration, typename 'Foo' must be predeclared (or marked as declarative with :: prefix) at /tmp/GRhHo2BAUE line 1:‚ê§------> [32msupersede Foo[33m‚èè[31m<EOL>[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[17:07] <TimToady> std: supersede $foo

[17:07] <colomon> pmichaud: okay, Ill commit this then.

[17:07] <p6eval> std 29709: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[17:07] <TimToady> hmm

[17:07] <jnthn> colomon: commit it, we cna triage it.

[17:08] <TimToady> well, maybe not supersede, we're mixing up composition-time declarations with other stuff

[17:09] *** Su-Shee joined
[17:10] <TimToady> phenny: tell masak Note that TTAGGG is not generally rendered into amino acids, but "TTAGGG" x $n is the definition of a telomere.

[17:10] <phenny> TimToady: I'll pass that on when masak is around.

[17:10] <masak> TimToady: I always wondered about why you chose that sequence :)

[17:10] <phenny> masak: 17:10Z <TimToady> tell masak Note that TTAGGG is not generally rendered into amino acids, but "TTAGGG" x $n is the definition of a telomere.

[17:11] <masak> http://en.wikipedia.org/wiki/Telomere

[17:11] *** jferrero joined
[17:15] *** Limbic_Region joined
[17:15] <TimToady> well, vertebrates, anyway, plus some fungussesses

[17:15] <colomon> pmichaud, jnthn: Thought: If we're releasing this week, should we be trying to update our parrot to the latest in prep for release?

[17:15] <pmichaud> colomon: yes

[17:15] <jnthn> pmichaud: When are you plotting the merge to master?

[17:16] <pmichaud> jnthn: sometime today.

[17:16] <jnthn> .oO( what's the masterplan? )

[17:16] <jnthn> pmichaud: OK, cool.

[17:17] <TimToady> I don't think Parcel should promote to Capture in a scalar

[17:17] <TimToady> it should promote when it's used as a parameter list in a binding

[17:17] <pmichaud> agreed, it should be Seq or remain a Parcel

[17:17] <TimToady> er, argument list

[17:17] <jnthn> *nod*

[17:17] <jnthn> Agree.

[17:17] <jnthn> I figured that was fossil.

[17:18] <TimToady> I've been digging them out whenever I've seen them, but they're a common as trilobytes

[17:19] *** itz joined
[17:19] <LaVolta> 1. ok, I am here just to wish you all a happy chinese year, I hope it won't be too late :-P

[17:20] <pmichaud> jnthn: okay, I have a (I think) role-related problem for you... testing then commit in a second

[17:20] <LaVolta> 2. it's a bit late...already bedtime, see ya, and good luck on Perl6.

[17:21] *** LaVolta left
[17:21] <lue> Looks like I /join ed at the wrong time... Have no idea what's going on :/

[17:21] <pmichaud> lue: that's true for most of us here, I fear :)

[17:23] <lue> I come and you're talking about supersede-ing and DNA! :O

[17:23] <lue> and ng becoming master! O.O

[17:23] <masak> lue: we've always been omnivores around here. :)

[17:23] <masak> lue: 'ng' and 'master' are the two most interesting Rakudo git branches.

[17:24] <pmichaud> jnthn:  just pushed 74c800c

[17:25] <pmichaud> with that, I have:

[17:25] <masak> lue: 'master' is the old Rakudo, from 2007 up until the January release. 'ng' is the future.

[17:25] <pmichaud> > my @a = 5..10;  say @a[2,4];

[17:25] <pmichaud> No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'

[17:25] <lue> The Future has interrupted that developement with an important announcement, coming shortly...

[17:25] <pmichaud> it appears that  @a.'postcircumfix:<[ ]>'( parcel )    isn't finding the postcircumfix:<[ ]> method from Positional

[17:26] <dalek> rakudo/ng: 74c008c | pmichaud++ | src/builtins/Positional.pir:

[17:26] <dalek> rakudo/ng: Update to try to enable array slices... seems to have a dispatch

[17:26] <dalek> rakudo/ng: issue that I think I need jnthn++ to look at.

[17:26] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/74c008c044dbfd05b69f5da1146ea3ea2f04b46d

[17:27] <lue>  /o\

[17:29] <jnthn> pmichaud: Is the postcircumfix:<[ ]> in Seq marked :multi?

[17:29] <pmichaud> yes.

[17:29] <jnthn> OK.

[17:29] <jnthn> It's not an Obvious Problme then. :-(

[17:29] <pmichaud> .sub 'postcircumfix:<[ ]>' :method :multi(_, ['Integer'])

[17:29] <pmichaud> let me check Array, though

[17:29] <pmichaud> .sub 'postcircumfix:<[ ]>' :method :multi(_, ['Integer'])

[17:29] <pmichaud> and the one from Positional.pir

[17:30] <pmichaud> .sub 'postcircumfix:<[ ]>' :method :multi(_, _)

[17:32] <jnthn> Hmm...is that a Parrot multi-dispatch error or a Rakudo one?

[17:32] <jnthn> (checking)

[17:32] <pmichaud> Parrot, likely

[17:32] <pmichaud> it's invoked from Positional.pir:172

[17:32] <pmichaud>     .tailcall invocant.'postcircumfix:<[ ]>'(args :flat)

[17:33] <jnthn> oh, our Perl6Multi emits the same error.

[17:35] <jnthn> pmichaud: I have a nasty feeling (need to verity)...

[17:36] <jnthn> ...that the problem is that with Parrot multi subs we don't go searching up the inheritance tree.

[17:36] <pmichaud> ...but it used to work before

[17:36] <pmichaud> (in master)

[17:36] <pmichaud> ..didn't it?

[17:36] <pmichaud> checking

[17:37] <jnthn> Let me stash what I'm working on so I can pull this and see the stack trace etc...

[17:38] <pmichaud> oh, apparently we weren't doing it in master

[17:38] <pmichaud> i.e., there was only one postcircumfix: (in Positional), not overridden by List or Array

[17:39] <jnthn> Yeah, that's what I suspected.

[17:40] <jnthn> I think the options are:

[17:40] <jnthn> 1) Convert those multis to be Perl6MultiSub

[17:40] *** meppl joined
[17:40] <jnthn> 2) I try and get our dispatcher to handle Parrot MultiSub

[17:40] <pmichaud> I'm fine with either #1 or #2

[17:40] <pmichaud> I'm not sure how to do either at the moment, though

[17:41] <pmichaud> is there an easy way to convert to Perl6MultiSub ?

[17:41] <jnthn> Let me see what #2 would take.

[17:41] <jnthn> There used to be in master.

[17:41] *** pmurias joined
[17:41] <pmichaud> okay.  can I leave it to you to work on, then?

[17:42] <pugs_svn> r29710 | lwall++ | [S02] attempt clarification of <a b> semantics wrt parcels and assignment, jnthn++ 

[17:42] <pmichaud> it's safe to ignore the other postcircumfix:<[ ]>  candidates in Positional.pir -- at the moment I've only worked on :multi(_, _)   and :multi(_, ['Integer'])

[17:42] <jnthn> OK, and the example that should work is?

[17:43] <TimToady> caveat implementor: I probably shouldn't be speccing while my cheekbone sinus is threatening to explode.

[17:43] <pmichaud> my @a = 5..10;  say @a[2,4];   # 79

[17:43] <pmichaud> or even

[17:43] <jnthn> TimToady++ # thanks, will review

[17:43] <pmichaud> my @a = 5..10;  say @a[4,2];  # 97

[17:45] <jnthn> Heh heh...you were very right you didn't want to hack on this. :-)

[17:45] * jnthn digs in.

[17:47] <lue> sorry, Tim. (I once had a sinus infection that came-and-went for weeks. It ended with horse pills)

[17:49] <dalek> rakudo/ng: d71e295 | (Solomon Foster)++ | src/Perl6/Actions.pm:

[17:49] <dalek> rakudo/ng: Add :returns('Int') to the integer action, so that we get Ints instead of Integers.

[17:49] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/d71e295fe6d98950de698e4c7da90ded1f99bcca

[17:51] <jnthn> Compiling.

[17:51] <jnthn> If this works first time, I'll be amazed.

[17:52] <lue>  /o\    *is scared of daleks

[17:52] <masak> lue: ours is a very kind robot, considering.

[17:53] <jnthn> Nope.

[17:54] <lue> Impossible! Have you _watched_ Dr. Who? Ever seen a FRIENDLY dalek!?

[17:56] <jnthn> ng: say [ 5..10 ].[2,4];

[17:56] <p6eval> ng d71e29: OUTPUT¬´No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'‚ê§current instr.: '!postcircumfix:<[ ]>' pc 10619 (src/builtins/Iterator.pir:25)‚ê§¬ª

[17:56] <jnthn> \o/

[17:56] <mathw> They're fine if they think you're also a dalek

[17:57] <jnthn> pmichaud: OK, that gives a different error here, so think I maybe have got it. :-)

[17:57] <jnthn> pmichaud: Only one problem

[17:57] <jnthn> pmichaud: We need to do transform_to_p6opaque when we do new ['Array'] for my @a;

[17:57] <masak> lue: I've watched Dr. Who. :) just saying there's always an exception.

[17:58] * mathw is watching Doctor Who right now

[17:58] *** Su-Shee left
[18:01] <lue> On what channel are you watching Doctor Who!?

[18:01] <lue> Truth be told, I've never watched that much of The Doctor...

[18:02] <TimToady> re pi, CORE.setting uses 3.14159_26535_89793_238, which limits the denominator to 1 quintillion for a Rat64 (not that we have those yet either)

[18:04] <lue> That won't do. I work with quattuordecillions!

[18:05] <TimToady> you can set up your own FatRat pi then.

[18:06] * masak .oO( fatrat pie?! eeew! )

[18:06] <jnthn> masak: I was thinking just the same!

[18:06] <masak> :)

[18:06] <TimToady> when the pie was opened, the rats began to sing...

[18:06] <lue> ... and all was well. Amen.

[18:07] * masak doesn't have that cultural hash key

[18:07] <TimToady> look for "four and twenty blackbirds baked in a pie"

[18:08] <jnthn> Wow, that poem involves junctions too?

[18:08] <jnthn> :-)

[18:08] <masak> good thing I ate already...

[18:08] <jnthn> Lucky you! :-/

[18:08] <jnthn> On the upside, at least I vaguely feel like eating today.

[18:09] <lue> And in the distance, he hath been slain, for he killed His camel, and ate His onion. Amen.

[18:09] <masak> jnthn: oh, you didn't before? :/

[18:09] <jnthn> masak: Yesterday my stomach was has an epic ache.

[18:09] <masak> sorry to hear that.

[18:09] <masak> we need to take good care of our developers...

[18:10] <jnthn> I get it now and then...annoying, but not a biggie.

[18:10] <TimToady> actually, it starts "Sing a song of sixpence, a pocket full of rye"

[18:10] <masak> ...so that they can be properly tortured by TimToady and the spec. <cackle />

[18:10] <jnthn> pmichaud: oh hey, I has a fix, I think.

[18:10] * masak read 'Sing a song of :sigspace...'

[18:10] <jnthn> pmichaud: spectesting to ensure no collateral damage

[18:11] <jnthn> Ironically, we probably multi-method dispatch Parrot multi-methods better than Parrot now. ;-)

[18:11] <lue> And an @ of people came, with slashed and %ed pi.

[18:11] <masak> lue: you should go ahead and become a blog poet.

[18:13] <lue> he considered the #, but saw that it was a die() waiting to happen. Amen.

[18:13] <lue> :D

[18:14] <pmichaud> jnthn++  # probable fix

[18:15] <pmichaud> I'm heading off for lunch in a bit

[18:15] <jnthn> pmichaud: Tests fine.

[18:15] <jnthn> pmichaud: Pushed.

[18:15] <jnthn> oh no, somebody else pushed first.

[18:15] <jnthn> now pushed. 

[18:16] <jnthn> pmichaud: It gets into a postcircumfix method in Positional. Apparently that method does have an issue.

[18:16] <jnthn> But it makes it there now :-)

[18:16] <pmichaud> that's possible.  I'll take it from there then.

[18:16] <jnthn> Don't read the C patch with remaining eye. ;-)

[18:16] <jnthn> (It's actually not that bad.)

[18:19] <dalek> rakudo/ng: d4a3bc5 | jonathan++ | src/ (3 files):

[18:19] <dalek> rakudo/ng: Need to make sure we create Array and Seq as p6opqaues.

[18:19] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/d4a3bc5904faeb481309ac5d3f1295a78c529728

[18:19] <dalek> rakudo/ng: c11b42c | jonathan++ | src/pmc/p6 (2 files):

[18:19] <dalek> rakudo/ng: Teach the Rakudo method dispatcher how to walk the inehritance hierarchy when considering Parrot MultiSubs as well as Perl6MultiSub.

[18:19] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/c11b42c6ccf2923f2ab3a36d23ff4fe8daef762d

[18:21] <jnthn> OK, time to go acquire nom...will continue on arg unpacking and capture bits later. :-)

[18:27] * lue wishes to help but doesn't know where his attention is useful.

[18:28] <pmurias> lue: you may consider helping with writing tests

[18:28] <lue> I'll look at that.

[18:31] *** Su-Shee joined
[18:36] *** uniejo joined
[18:37] *** pochi joined
[18:38] *** rindolf joined
[18:38] <pmichaud> jnthn: an idea

[18:38] <pmichaud> 17:56 <jnthn> pmichaud: We need to do transform_to_p6opaque when we do new ['Array'] for my @a;

[18:38] <pmichaud> how about a  p6opaque_new  opcode that does both in a single step?

[18:39] <pmichaud> just a thought

[18:39] <pmichaud> afk, lunch

[18:39] *** rindolf left
[18:39] *** rindolf joined
[18:42] <rindolf> Hi all.

[18:42] <rindolf> So how can I fix a Rakudo/Parrot bug? Can someone assign one to me?

[18:42] *** mssm left
[18:43] <pugs_svn> r29711 | colomon++ | [t/spec] Unfudge todo tests which now work. 

[18:44] <masak> rindolf: things are a bit stormy right now, with the upcoming merge and all.

[18:44] <rindolf> masak: ah.

[18:44] <masak> rindolf: in general, it's a very welcome question, but right now it's mostly pmichaud and jnthn doing stuff.

[18:44] <masak> not impossible to keep up, though. :)

[18:44] <masak> I try, and colomon seems to succeed.

[18:45] <lue> I'm trying to keep up with them, and I've been here awhile! (it's that dalek that puts me behind)

[18:46] <colomon> masak: A lot of it is selective ignoring of things that are way over my head...

[18:46] <masak> colomon: that's actually a good tip. I should do that more often. :P

[18:49] <jnthn> pmichaud: That's a fine idea.

[18:49] <jnthn> masak: It helps. :-)

[18:49] <jnthn> masak: I tried to do that with laziness. :-)

[18:50] <jnthn> (but ended up reading the impl anyway :-))

[18:50] <masak> heh :)

[18:51] <jnthn> masak: How's enums? Any blockers?

[18:51] <lichtkind> masak: hello, how is von doing?

[18:51] <lue> where can I find where spectests that need to be written are?

[18:51] <masak> jnthn: not tried yet. I'll give it a shot soon today.

[18:52] <jnthn> lue: http://svn.pugscode.org/pugs/t/spec/TODO

[18:52] <masak> lichtkind: who's 'von'?

[18:52] <masak> -Ovon

[18:52] <lichtkind> masak: ahh i mean nov

[18:52] <lichtkind> haha

[18:52] <masak> lichtkind: it's a bit of a sitting duck right now, I guess.

[18:52] <masak> lichtkind: I'm a bit of a neglecting parent...

[18:53] *** mssm joined
[18:53] * jnthn hides all the guns

[18:56] * lue gave jnthn a faulty gun lock

[18:57] <pugs_svn> r29712 | lichtkind++ | updated syntax in talk to recent spec 

[18:57] <lichtkind> masak: don't worry i care about tpf perl 6 wiki until it works :)

[18:58] <masak> lichtkind: I'm glad I have you to pester me like I pester the Rakudo devs. :)

[18:58] *** jaldhar joined
[18:58] <lichtkind> masak: im good at annoying people ask anyone :)

[18:59] <lue> My talent is confusion. (ask me about time travel)

[18:59] <rindolf> rakudo: "Hello".length

[18:59] <p6eval> rakudo 1d4928: OUTPUT¬´Method 'length' not found for invocant of class 'Str'‚ê§in Main (file src/gen_setting.pm, line 324)‚ê§¬ª

[18:59] <lichtkind> lue: your a time traveler too?

[19:00] <masak> rindolf: 'length' for Str is spelled 'chars'

[19:00] <lue> almost. I have yet to genetically reprogram myself into a 4D person.

[19:00] <lue> Then I can walk through time as I please.

[19:00] <masak> rindolf: in general, 'length' is a taboo word in Perl 6.

[19:00] <lichtkind> lue: i am 11D :)

[19:00] <rindolf> masak: ah.

[19:01] <lue> O.O ubbuhbubhbuhbhbuuuhhhbhbhhuuhhbbuh...

[19:05] <lichtkind> lue: keep cool averybody is 11D :)

[19:05] <lichtkind> just most people dont use it :)

[19:05] <masak> do ranges and <a b c> constructions flatten in enums. for example in `enum Rank (2..9, <J Q K A>);`?

[19:05] * colomon is actually 13EEE

[19:05] <lue> I can, however, travel through the WSoGMM dimensions, but I'm right now in control of only 3 base dimensions.

[19:05] <lue> :)

[19:06] <lue> Hang on, going to WSoGMM dimension 65536.

[19:06] * lue takes his laptop with him.

[19:07] <mberends> hope it's a 16 bit machine

[19:07] <lue> what, my TARDIS? it's 1024-bit.

[19:08] <lue> well, not my TARDIS...

[19:08] <jnthn> masak: Yes, I belive so, but everything in there should be constant.

[19:08] <masak> yes, because of the time it's eval'ed.

[19:09] <jnthn> Right.

[19:09] <lue> Well, I helped reconfigure The Doctor's TARDIS to travel through WSoGMM dimensions (alternate realities, according to him)

[19:09] <lue> He doesn't seem to like it...

[19:10] <lue> ng: say warn('hello!');

[19:10] <p6eval> ng c11b42: OUTPUT¬´hello!‚ê§Null PMC access in type()‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[19:11] <colomon> ng: say PARROT(1); say PARROT(-1);

[19:11] <p6eval> ng c11b42: OUTPUT¬´Int‚ê§Integer‚ê§¬ª

[19:12] <lue> *raise eyebrow smiley*

[19:13] <colomon> ng: my $a = 1; say PARROT($a); say PARROT(-$a)

[19:13] <p6eval> ng c11b42: OUTPUT¬´ObjectRef->Int‚ê§Integer‚ê§¬ª

[19:14] <lue> ng: say PARROT(1)==Int;

[19:14] <p6eval> ng c11b42: OUTPUT¬´Use of type object as value‚ê§current instr.: 'perl6;Perl6Exception;throw' pc 13848 (src/builtins/Associative.pir:118)‚ê§¬ª

[19:14] <lue> ng: say PARROT(1).WHAT==Int;

[19:14] <p6eval> ng c11b42: OUTPUT¬´Use of type object as value‚ê§current instr.: 'perl6;Perl6Exception;throw' pc 13848 (src/builtins/Associative.pir:118)‚ê§¬ª

[19:14] <lue> ng: say PARROT(1).WHAT~~Int;

[19:14] <p6eval> ng c11b42: OUTPUT¬´0‚ê§¬ª

[19:14] <colomon> ng: say PARROT(1).WHAT

[19:14] <p6eval> ng c11b42: OUTPUT¬´Str()‚ê§¬ª

[19:14] <lue> ah.

[19:14] <lue> ng: say PARROT(1)~~Int;

[19:14] <p6eval> ng c11b42: OUTPUT¬´0‚ê§¬ª

[19:15] <jnthn> lue: PARROT is just a debugging function that gives a string describing the underlying data type of something.

[19:15] <jnthn> ng: say 1 ~~ Int

[19:15] <p6eval> ng c11b42: OUTPUT¬´1‚ê§¬ª

[19:15] <jnthn> :-)

[19:15] <colomon> looks like prefix:<-> always returns a Num?

[19:15] <lue> aaah. (WSoGMM Dimension 65536 is warping my brain a little)

[19:15] <colomon> pir::box__PN(pir::neg__NN($a))

[19:16] <jnthn> colomon: Probably want an overload for Int.

[19:16] <colomon> trying that now.

[19:17] <colomon> masak: the other problem with following pmichaud and jnthn when they both get busy is the rest of my life seems to be running in slow motion...

[19:18] *** jackyf joined
[19:18] <colomon> > say PARROT(-1)

[19:18] <colomon> Ambiguous dispatch to multi 'prefix:<->'. Ambiguous candidates had signatures:

[19:18] <colomon> :(Int $a)

[19:18] <colomon> jnthn: you rock!!!!!

[19:19] <colomon> Of course, now it's a bug in PIR and I'm not sure how to handle it:

[19:19] <colomon> multi sub prefix:<->(Int $a) {

[19:19] <colomon>     Q:PIR {

[19:19] <colomon>         $P0 = find_lex '$a'

[19:19] <colomon>         $N0 = $P0

[19:19] <colomon>         $N0 = neg $N0

[19:19] <colomon>         %r = '!upgrade_to_num_if_needed'($N0)

[19:19] <colomon>     }

[19:19] <colomon> }

[19:21] <colomon> Looks like upgrade_to_num_if_needed must be the culprit?

[19:22] <colomon> ng: say 1!upgrade_to_num_if_needed

[19:22] <p6eval> ng c11b42: OUTPUT¬´Method '!upgrade_to_num_if_needed' not found for invocant of class 'Int'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[19:22] <colomon> ng: say (1.Num)!upgrade_to_num_if_needed

[19:22] <p6eval> ng c11b42: OUTPUT¬´Method '!upgrade_to_num_if_needed' not found for invocant of class 'Num'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[19:23] <jnthn> I think it's meant to be a sub rather than a method

[19:23] <colomon> right.

[19:23] <colomon> ng: say !upgrade_to_num_if_needed(1)

[19:23] <p6eval> ng c11b42: OUTPUT¬´0‚ê§¬ª

[19:23] <colomon> errrrr...

[19:23] <jnthn> wtf

[19:23] <colomon> ng: say !upgrade_to_num_if_needed(1.Num)

[19:23] <p6eval> ng c11b42: OUTPUT¬´0‚ê§¬ª

[19:23] <jnthn> ng: say &upgrade_to_num_if_needed(1)

[19:23] <colomon> maybe can only be called from PIR?

[19:23] <p6eval> ng c11b42: OUTPUT¬´Symbol '&upgrade_to_num_if_needed' not predeclared in <anonymous>‚ê§current instr.: 'perl6;PCT;HLLCompiler;panic' pc 137 (src/PCT/HLLCompiler.pir:101)‚ê§¬ª

[19:24] <jnthn> ng: say upgrade_to_num_if_needed(1)

[19:24] <p6eval> ng c11b42: OUTPUT¬´1‚ê§¬ª

[19:24] <jnthn> ng: say upgrade_to_num_if_needed(1).WHAT

[19:24] <p6eval> ng c11b42: OUTPUT¬´Int()‚ê§¬ª

[19:24] <jnthn> colomon: Replace the ! with an &

[19:24] <jnthn> Though I think that sub is...leaking. :-)

[19:24] <jnthn> But it'll probably fix the immediate problem.

[19:24] <colomon> were you responsible for the Ambiguous dispatch to multi 'prefix:<->'. Ambiguous candidates had signatures...

[19:25] <colomon> error?

[19:25] <colomon> because that's a thing of beauty...

[19:25] <jnthn> Yes

[19:26] <colomon> jnthn++

[19:26] <jnthn> The one I'd like to do in the future is for when you get a failed dispatch, it showhow could show how the candidates failed to match.

[19:26] <colomon> +1

[19:26] <jnthn> But it's kinda hard to do.

[19:26] <jnthn> Well

[19:26] <colomon> switching to & doesn't actually help

[19:26] <jnthn> Oh. :-/

[19:27] <colomon> ng: say PARROT(upgrade_to_num_if_needed(1));

[19:27] <p6eval> ng c11b42: OUTPUT¬´Integer‚ê§¬ª

[19:27] <jnthn> Look up the sub - where is it defined?

[19:27] <colomon> cheat/int-ops.pir

[19:27] <colomon>     $I0 = test

[19:27] <colomon>     .return ($I0)

[19:27] <jnthn> The upgrade_to_num_if_needed one?

[19:27] <colomon> yes

[19:27] <colomon> er, wait.

[19:28] <colomon> there's also a version of that function in Int.pm

[19:28] <jnthn> Ah

[19:28] <jnthn> That'll be the interesting one, is suspect

[19:28] <jnthn> Is it marked as "our"?

[19:28] <colomon> the two lines I posted are still how it converts to Int/Integer.

[19:28] <colomon> yes.

[19:28] <jnthn> Hmm

[19:28] <jnthn> Sounds like something is incomplete-ish there.

[19:29] <jnthn> I'm pondering that it may be worth a refactor to make it a private method though.

[19:29] <jnthn> Then it's not going to pollute the namespace.

[19:31] <colomon> ng: say PARROT(1+3)

[19:31] <p6eval> ng c11b42: OUTPUT¬´Integer‚ê§¬ª

[19:32] <colomon> So how do you return an actual Int from PIR code?

[19:32] <colomon> right now, almost any operator you use on an Int will give you back an Integer.

[19:34] <colomon> Also, it seems like we need some sort of tests for this, but I'm not clear on how to do it -- it would be very Rakudo-specific.

[19:36] <colomon> afk # need to run errands.

[19:36] <jnthn> oops, sorry, got disctracted by the latest Gas Princess news story

[19:37] <jnthn> colomon: The issue is that making them Rakudo Ints all the way through gets kinda expensive, so we've mostly been able to get away with doing that in master. :-/

[19:37] <jnthn> As pmichaud mentioned earlier, it's most a performance issue.

[19:38] <colomon> jnthn: Ah.

[19:39] <jnthn> And I can tell you how to make an Int, sure

[19:39] <jnthn> But I'm not sure we should be scattering it all over the codebase...

[19:40] <colomon> jnthn: we wouldn't, we'd be putting it all in upgrade_to_num_if_needed

[19:40] <jnthn> (If we decide we'll take the hit and go with our higher-level Int anyway, there's a way to ask Parrot to do it for us, iirc, too.

[19:40] <colomon> but if it will kill performance... I can just kill the "is the result of that operation an Int" tests and get on with things.  I dunno.

[19:40] <jnthn> colomon: Well, true.

[19:40] <colomon> anyway, I do need to run at the moment.

[19:41] <colomon> ttyl

[19:41] <jnthn> OK, catch you later

[19:44] * lue is back from WSoGMM Dimension 65536 (he should fix his pan-dimensional wireless)

[19:48] <lue> This line looks interesting (from t/spec TODO): * (r28208, r28210, r28213, r28215) Temporal updates

[19:49] * masak 's ears perk up

[19:50] <masak> lue: I was finalizing a large-ish Temporal overhaul in November. never quite got it finished. it's still on github, though.

[19:51] <pugs_svn> r29713 | lwall++ | [S02] list all the scope declarators in one spot 

[19:51] <pugs_svn> r29713 | further distinguish parcels bound to sigs from those bound to parameters

[19:51] <pugs_svn> r29713 | some ideas on how to handle the allomorphism of literals more dwimmily

[19:51] <lue> Just the Temporal part looked... interesting (especially seeing time travel's on the mind right now)

[19:51] <masak> Temporal needs a lot of love. I remember focusing on the constructor, but things like arithmetic would be nice to have, too.

[19:52] <masak> I believe it's a prime case where Perl 6 can manage to feel 'just right' and attract a lot of people.

[19:52] <masak> handling time is very central in many apps.

[19:52] <masak> oh well, with a bit of luck I'll get to have another look at it before Rakudo *.

[19:53] <pugs_svn> r29714 | lwall++ | [S02] Rat.perl does / notation, actually 

[19:53] <lue> What exactly is the full potential of Temporal { >:) }

[19:54] <masak> lue: right now, you mean?

[19:55] <masak> lue: the spec has the details. S32/Tempotal

[19:55] <lue> alrighty. I'll look, and see what I can do with it... [evil laugh]

[19:56] <masak> lue++

[19:57] *** Limbic_Region left
[19:58] <lue> It seems to support multiple calendars. Is this actually implemented yet?

[19:59] <masak> no.

[19:59] <TimToady> well, as far as I'm concerned, the first thing to do to all the Temporal type names is s/Temporal::/

[19:59] <masak> I agree fully.

[19:59] <lue> Perl6: the only language to worry about what calendar you use.

[19:59] <masak> I'd prefer if Temporal::DateTime was just Time.

[19:59] <TimToady> that works too

[19:59] <masak> lue: no, Java does that as well.

[19:59] <masak> lue: I'm not saying it's a good idea, just that Perl 6 isn't alone in doing it. :)

[19:59] <TimToady> and use O'clock for the time of day :)

[20:00] * masak hides TimToady 

[20:00] <masak> anyway...

[20:00] <lue> Date, by the way, is really just further group of Time.

[20:00] <lue> I really don't know why we separate it as a different thing. :)

[20:01] <TimToady> it's just a civil time with less precision than Time

[20:01] <masak> Ruby calls it Time, even though it contains a date as well.

[20:01] <TimToady> in p6, we can has Time == civil time

[20:01] <masak> it seems to work for them.

[20:01] <TimToady> Instant means atomic time

[20:01] * lue is looking up strange & unusual calendars

[20:01] <masak> I remember having a longish discussion about DateTime/Time with mberends++ late last year.

[20:01] <masak> maybe two, actually.

[20:02] <TimToady> O'clocks are actually durations from midnight

[20:03] <TimToady> (relative to a timezone)

[20:03] <masak> is the need for such a class common?

[20:03] <masak> I'm somewhat put off by that apostrophe... :/

[20:04] <TimToady> but anything common enough to be specced doesn't want to fall into the Give::Everything::A::Long::Name trap

[20:04] <TimToady> oh, O'clock is a joke

[20:04] <masak> exactly.

[20:04] <masak> oh phew.

[20:04] <lue> Such as Temporal::DateTime::Format::Western::Oclock

[20:04] <lue> :)

[20:04] <TimToady> but think about 3.O'clock.pm  :)

[20:05] <masak> :)

[20:05] <TimToady> If you're gonna use Oclock, I'd rather have the apostrophe :)

[20:05] <lue> ooh, we should support the Darian calendar!

[20:05] <masak> if &foo returns a list of things, and I call foo in the RHS of a scalar assignment, does the whole list end up in the scalar?

[20:06] <TimToady> ends up a Seq

[20:06] <masak> right, but the whole Seq ends up in the scalar, right?

[20:06] <TimToady> sure

[20:06] <masak> quite unline in Perl 5.

[20:06] <masak> where it would just spill over.

[20:06] <TimToady> unlike Perl, we don't throw info away willy nilly

[20:06] <TimToady> Perl 5

[20:06] <masak> right.

[20:06] <masak> just checking.

[20:07] <masak> I'm thinking whether to repeat pmichaud++'s naughty idea of making the PGE::Match object return a list of a lot of things, not just the object created.

[20:07] <TimToady> scalar assignment is more or less the same as binding to a scalar in type semantics, as far as the argument is contextualized

[20:08] <masak> it would break all locations in my own code where I put the new object in a scalar.

[20:08] <TimToady> well, technically, a Match is supposed to behave more like a Capture than a Parcel

[20:09] <masak> doesn't help me very much, I'm afraid.

[20:09] <TimToady> a common failing wrt retroprojects :P

[20:10] <masak> TimToady: re recent spec commit: does 'anon' really introduce a name, even one that isn't stored anywhere? I thought introduce a name was what 'anon' wasn't doing.

[20:10] <TimToady> colomon: see latest change to S02 wrt allomorphism of rat literals

[20:10] <lue> <tone type="mumble">I wonder what the P6 calendar would be (as a novelty of course)</tone>

[20:11] <masak> lue: centerfold pictures of sexy operators? :P

[20:11] <TimToady> s/change/changes/

[20:11] <jnthn> masak: Just because something knows its name doesn't mean it has to be installed anywhere under that name.

[20:11] <lue> I mean a calendar, like Gregorian, Hebrew...

[20:11] <jnthn> It's like if I take a secret vacation. None of you can find me, but I still know my name. :-)

[20:12] <masak> :)

[20:12] <lue> pugs: say 16<16.D4>;

[20:12] <p6eval> pugs: OUTPUT¬´*** Odd number of elements found where hash expected: VInt 16‚ê§    at /tmp/JRyucczwcs line 1, column 5-14‚ê§¬ª

[20:12] <lue> :(

[20:12] <TimToady> need :

[20:12] <lue> pugs: say :16<16.D4>;

[20:12] <p6eval> pugs: OUTPUT¬´22.828125‚ê§¬ª

[20:12] <masak> jnthn: but what is the name of an anon sub or role or class?

[20:12] <lue> just realized. (Wow, big decimal)

[20:13] <TimToady> std: anon $myname = 42;

[20:13] <p6eval> std 29713: OUTPUT¬´ok 00:01 108m‚ê§¬ª

[20:13] <lue> In my Hexcalendar draft, with 16 months, each month will have 22.828125 (0x16.D4) days :D

[20:13] <TimToady> std: my $sub = anon sub Myself {...}

[20:13] <p6eval> std 29713: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[20:14] <jnthn> masak: If you write anon sub marine() { ... } then it's name is marine.

[20:14] <TimToady> std: my $sub = anon sub myself {...}; myself();

[20:14] <p6eval> std 29713: OUTPUT¬´Undeclared routine:‚ê§   'myself' used at line 1‚ê§ok 00:01 107m‚ê§¬ª

[20:15] <masak> jnthn: the spec only contains examples of 'anon' without the name. I guess that's what threw me off.

[20:16] <jnthn> Ah, OK

[20:18] <masak> so it's a way to make an anonymous recursive routine, for example. or an anon role which contains references typed to itself.

[20:18] <pugs_svn> r29715 | lwall++ | [S02] clarify that anon allows a name but doesn't install it for jnthn++ 

[20:18] <TimToady> no, it would not work for recursion

[20:18] <TimToady> use $?ROUTINE for that

[20:18] <masak> ok.

[20:19] <masak> right, it would not work for recursion because the call is run-time, and then the name is gone.

[20:19] <TimToady> it's really for doc and errors

[20:19] <TimToady> the name is in the object itself, if it cares

[20:19] <TimToady> or you can't give run-time error messages

[20:20] <TimToady> (with the name)

[20:20] <jnthn> rakudo: [].ACCEPTS([])

[20:20] <TimToady> the name is not in the symbol table even at runtime

[20:20] <p6eval> rakudo 1d4928:  ( no output )

[20:20] <jnthn> ng: [].ACCEPTS([])

[20:20] <p6eval> ng c11b42: OUTPUT¬´sh: ./perl6: No such file or directory‚ê§¬ª

[20:20] <jnthn> ng: [].ACCEPTS([])

[20:20] <p6eval> ng c11b42: OUTPUT¬´sh: ./perl6: No such file or directory‚ê§¬ª

[20:20] <TimToady> see myself above

[20:20] <jnthn> tssk

[20:20] <jnthn> ah

[20:20] <TimToady> the name is not in the symbol table even at compile time, I meant

[20:21] <lichtkind> will there be a ¬ª√∂¬´ operator?

[20:22] <TimToady> if there's an infix:<√∂> operator, sure

[20:22] <jnthn> lichtkind: If you write a √∂ one, yes.

[20:22] <lichtkind> thats for shure

[20:22] <lichtkind> but i ment a complete ¬ª√∂¬´

[20:22] <araujo> happy new year!

[20:23] <lichtkind> :)

[20:23] <TimToady> we don't want people overriding metaoperators

[20:24] <jnthn> If you met a metaoperator, you want to know how it's going to operate.

[20:24] <TimToady> anything that looks like a hyperoperator should be derived from the base operator by the standard metaop

[20:24] <jnthn> \o/

[20:24] <jnthn> > our sub foo([$head, *@tail]) { say $head; say @tail.perl; }

[20:24] <jnthn> > my @array = 1,2,3,4; foo(@array);

[20:24] <jnthn> 1

[20:24] <jnthn> [2, 3, 4]

[20:24] *** nbrown left
[20:24] <TimToady> you could define a term:<¬ª√∂¬´> if you like though

[20:24] <masak> araujo: Êñ∞Âπ¥Âø´Ê®ÇÔºÅ

[20:25] <TimToady> well, technically you want a *$head

[20:25] <araujo> masak, :D

[20:25] <TimToady> or an initial (1,2,3) won't flatten

[20:25] *** nbrown joined
[20:26] <jnthn> TimToady: ?

[20:26] *** orafu joined
[20:26] <jnthn> TimToady: Inside it's just a subsignature, no?

[20:26] <jnthn> TimToady: The capture that's made has the array flattened out into it.

[20:26] <TimToady> oh, didn't see the []

[20:26] <jnthn> :-)

[20:26] <TimToady> that's okay then

[20:26] <jnthn> Phew!

[20:26] <jnthn> :-)

[20:26] <jnthn> You had me worried then. :-P

[20:27] <lue> rakudo: say hex(42);

[20:27] <TimToady> though it'd work without the [] if you use *$

[20:27] <p6eval> rakudo 1d4928: OUTPUT¬´Could not find non-existent sub hex‚ê§in Main (file src/gen_setting.pm, line 324)‚ê§¬ª

[20:27] <jnthn> TimToady: Sure. :-)

[20:27] <TimToady> and then you could take foo(@a,@b)

[20:27] <TimToady> which won't work with yours

[20:27] <lue> rakudo: say hex("42");

[20:27] <p6eval> rakudo 1d4928: OUTPUT¬´Could not find non-existent sub hex‚ê§in Main (file src/gen_setting.pm, line 324)‚ê§¬ª

[20:27] <lue> D:

[20:28] <jnthn> TimToady: Yes, true.

[20:28] <jnthn> I guess it's all about what you want to accept. :-)

[20:29] <lue> how do you convert _to_ a hex number? I know from, but not to...

[20:29] <TimToady> .fmt('%x')

[20:29] <lue> rakudo: say 52.fmt('%x');

[20:29] <p6eval> rakudo 1d4928: OUTPUT¬´34‚ê§¬ª

[20:29] <lue> :D

[20:30] <TimToady> ng: say 52.fmt('%x')

[20:30] <lue> ng: say :16<16.D4/4>

[20:30] <p6eval> ng c11b42: OUTPUT¬´Could not find non-existent sub &sprintf‚ê§current instr.: 'perl6;Any;fmt' pc 270601 (src/gen/core.pir:23916)‚ê§¬ª

[20:30] <p6eval> ng c11b42: OUTPUT¬´Confused at line 1, near "say :16<16"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)‚ê§¬ª

[20:30] <jnthn> rakudo: say "I'm only {24.fmt('%x')}!"

[20:30] <TimToady> aww

[20:30] <p6eval> rakudo 1d4928: OUTPUT¬´I'm only 18!‚ê§¬ª

[20:30] <jnthn> \o/

[20:30] <jnthn> Hex. Shaving off the years.

[20:30] <TimToady> no beer for you

[20:30] <lue> ng: say :16<(16.D4/4)>

[20:30] <jnthn> TimToady: Huh?!

[20:30] <p6eval> ng c11b42: OUTPUT¬´Confused at line 1, near "say :16<(1"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)‚ê§¬ª

[20:30] <jnthn> TimToady: Oh, it's 21 over there, ain't it. :-|

[20:31] <lue> apparently, arithmetic in :16 is not allowed :/

[20:31] <jnthn> That said, I do remember when I was in Chicago when I *was* 21, and as I reached for my ID the guy was like "oh, you're clearly over 21" :-)

[20:31] <TimToady> I got carded once when I was about 40

[20:32] <TimToady> don't think would happen now though

[20:33] <dalek> rakudo/ng: 04a857f | jonathan++ | src/builtins/ (2 files):

[20:33] <dalek> rakudo/ng: Get unpacking of positional arguments working again.

[20:33] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/04a857fa6fe33271949a3cec89071e8af5f88020

[20:33] <lue> ng: say 0x16.D4;

[20:33] <p6eval> ng c11b42: OUTPUT¬´Method 'D4' not found for invocant of class 'Int'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[20:33] <lue> rakudo: say 0x16.D4;

[20:33] <p6eval> rakudo 1d4928: OUTPUT¬´Method 'D4' not found for invocant of class 'Int'‚ê§in Main (file src/gen_setting.pm, line 324)‚ê§¬ª

[20:33] <TimToady> no

[20:33] <lue> pugs: say 0x16.D4;

[20:33] <p6eval> pugs: OUTPUT¬´*** No such method in class Int: "&D4"‚ê§    at /tmp/UDKLs9zbPy line 1, column 5-12‚ê§¬ª

[20:33] <TimToady> have to use : form for that

[20:33] <TimToady> otherwise too ambig with methods

[20:34] <lue> :/ I want to do hex arithmetic with decimals, thought that would work.

[20:34] <TimToady> what if you have a D4 method you want to call?

[20:35] <lue> why would you name a method D4? shorthand for "divide-by-4"? :)

[20:35] <TimToady> which reminds me, we should put a deadbeef method into Num :)

[20:35] <TimToady> beats me, I'm just the language designer; I don't tell people how to use it

[20:35] <lue> ng: say 0xdeadbeef;

[20:36] <p6eval> ng c11b42: OUTPUT¬´3735928559‚ê§¬ª

[20:36] <lue> ng: say 0xc0ffee;

[20:36] <TimToady> ng: say 0xdeadbeef.deadbeef

[20:36] <p6eval> ng c11b42: OUTPUT¬´12648430‚ê§¬ª

[20:36] <p6eval> ng c11b42: OUTPUT¬´Method 'deadbeef' not found for invocant of class 'Int'‚ê§current instr.: '_block14' pc 29 (EVAL_1:0)‚ê§¬ª

[20:36] <lue> what would the deadbeef method do?

[20:36] <TimToady> say Mu

[20:36] <lue> moo

[20:37] <TimToady> ng: say 0xdeadbeef.?deadbeef

[20:37] <p6eval> ng c11b42:  ( no output )

[20:37] <TimToady> ng: my $result = 0xdeadbeef.?deadbeef; say $result

[20:37] <p6eval> ng c11b42:  ( no output )

[20:37] <TimToady> rakudo: my $result = 0xdeadbeef.?deadbeef; say $result

[20:37] <p6eval> rakudo 1d4928: OUTPUT¬´Undefined value returned by invocation of undefined method‚ê§‚ê§¬ª

[20:38] <TimToady> another case where rakudo returns a Failure that should probably just return Nil

[20:38] <jnthn> TimToady: Really?

[20:38] <TimToady> I told it the call was optional

[20:39] <jnthn> Hmm...true.

[20:39] <lue> ng: say 1 and 1; #ANFSCD

[20:39] <p6eval> ng c11b42: OUTPUT¬´1‚ê§¬ª

[20:39] <lue> ng: say 1 or 1; #ANFSCD

[20:39] <p6eval> ng c11b42: OUTPUT¬´1‚ê§¬ª

[20:39] <TimToady> rakudo: my $result = 0xdeadbeef.*deadbeef; say $result

[20:39] <p6eval> rakudo 1d4928: OUTPUT¬´‚ê§¬ª

[20:39] <masak> rakudo: my $a; say ($a.?foo).WHAT

[20:39] <p6eval> rakudo 1d4928: OUTPUT¬´Failure()‚ê§¬ª

[20:39] <lue> ng: say 1 xor 1;

[20:39] <p6eval> ng c11b42: OUTPUT¬´1‚ê§¬ª

[20:39] * masak submits rakudobug

[20:39] <lue> ng: say 1 nor 1;

[20:39] <p6eval> ng c11b42: OUTPUT¬´Confused at line 1, near "say 1 nor "‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)‚ê§¬ª

[20:39] <jnthn> The failure is easy to distinguish though. If I expected no results, it's harder to distinguish that from "nothing was called".

[20:39] <jnthn> That is, a method that just did return; would return Nil too, no?

[20:40] <lue> ng: say 1 and 1; say 1 or 1; say 1 xor 1; say 1 nand 1; say 1 nor 1; say 1 xnor 1; #simple test of implemented logic.

[20:40] <p6eval> ng c11b42: OUTPUT¬´Confused at line 1, near "say 1 nand"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)‚ê§¬ª

[20:40] <TimToady> sure, though we could distinguish those in slice context, presumably

[20:40] <jnthn> Or if you were interesteed in the failure I guess use . and a try/CATCH

[20:41] <jnthn> Since presumably you want to do something on the failure anyway.

[20:41] <TimToady> I prefer exceptions to be reserved for unexpected things

[20:41] <jnthn> Yeah, good point.

[20:41] <TimToady> use of Failure as a normal return value is a design smell

[20:41] <jnthn> OK, we'll Nil it. :-)

[20:41] <jnthn> .oO( TimToady 1 - Nil jnthn

[20:42] *** sg__ joined
[20:42] <TimToady> basically, .* and by extension .? should return something sliceable to get the number of successful returns as subparcels

[20:42] <jnthn> Parcel of Parcels?

[20:42] <TimToady> presumably

[20:42] <jnthn> wfm

[20:42] <masak> oh, that's an even better explanation.

[20:43] <masak> it should be Nil because it's an empty list.

[20:43] <masak> parallel to quantifier ? returning an empty list upon no match.

[20:43] <TimToady> Parcel(Nil) is a real returned Nil, whille Nil is no parcels

[20:43] <TimToady> masak: nodnod

[20:43] * masak likes consistency

[20:43] <TimToady> I said it just for you :)

[20:44] <masak> awww. you shouldn't have. :)

[20:44] <TimToady> okay, we're both lousy liars.

[20:44] <lue> you fooled me

[20:45] <masak> lousy + epsilon, then.

[20:45] * TimToady OHNOES over the epsilon infestation

[20:46] <masak> wishing epsilon could just go to zero already, and stay there.

[20:47] <TimToady> the next best thing to being zero...

[20:48] <masak> nevermind, it's negligible anyway.

[20:49] <masak> jnthn: I'll see what I can come up with wrt anon enums.

[20:49] <masak> food &

[20:49] <TimToady> only for continuous functions; fortunately, Heisenberg seems to have solve that for the physical world, so that physicists can cancel their dx's and dy's

[20:49] <TimToady> *solved

[20:50] <masak> Heisenberg++

[20:50] *** masak left
[20:52] <lue> are nand, nor, and xnor useful operators? You can emulate them with a bunch of and/or/xor commands, but...

[20:53] <jnthn> lue: Given that you can easily define new operators in Perl 6 anyway, it'd be easy enough to pop such things in a library.

[20:53] <jnthn> use Logical::Extras;

[20:53] <jnthn> :-)

[20:55] <TimToady> rakudo: say True !and True

[20:55] <p6eval> rakudo 1d4928: OUTPUT¬´Confused at line 10, near "!and True"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[20:55] <TimToady> rakudo: say True !&& True

[20:55] <p6eval> rakudo 1d4928: OUTPUT¬´Confused at line 10, near "!&& True"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[20:55] <TimToady> rakudo: say True !?& True

[20:55] <p6eval> rakudo 1d4928: OUTPUT¬´Confused at line 10, near "!?& True"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[20:55] <quietfanatic> rakudo: sub infix:<nand> {not $^a and $^b}; say 1 nand 1

[20:55] <p6eval> rakudo 1d4928: OUTPUT¬´0‚ê§¬ª

[20:56] <TimToady> anyway, the ! metop is supposed to get you that already

[20:56] <TimToady> *metaop

[20:56] <dalek> rakudo/ng: df72c91 | jonathan++ | src/ (3 files):

[20:56] <dalek> rakudo/ng: Unpacking of hashes works, and objects nearly works, once I fix attribute introspection.

[20:56] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/df72c91c0990bd7ef1e5e607d74d4a21069dd3ac

[20:56] <quietfanatic> perl6: say 1 !and 1

[20:56] <jnthn> std: say True !?& True

[20:56] <p6eval> elf 29715: OUTPUT¬´Parse error in: /tmp/NQQIQ7Z0hx‚ê§panic at line 1 column 10 (pos 10): Only boolean infix operators may be negated‚ê§WHERE: say 1 !and 1‚ê§WHERE:          /\<-- HERE‚ê§  STD_red/prelude.rb:99:in `panic'‚ê§  (eval):8:in `__infix_prefix_meta_operator_4861890'‚ê§  STD_red/prelude.rb:406:in `block

[20:56] <p6eval> ..‚Ä¶

[20:56] <p6eval> ..pugs: OUTPUT¬´*** ‚ê§    Unexpected "!"‚ê§    expecting operator, ":" or ","‚ê§    at /tmp/feA87eDX0z line 1, column 7‚ê§¬ª

[20:56] <p6eval> ..rakudo 1d4928: OUTPUT¬´Confused at line 10, near "!and 1"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[20:56] <p6eval> std 29715: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Can't negate ?& because multiplicative operators are not iffy enough at /tmp/LMRD0Ruyjt line 1:‚ê§------> [32msay True !?&[33m‚èè[31m True[0m‚ê§FAILED 00:01 107m‚ê§¬ª

[20:56] <jnthn> std: say True !and True

[20:56] <p6eval> std 29715: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Can't negate and because loose and operators are not iffy enough at /tmp/DsfAcMcVLH line 1:‚ê§------> [32msay True !and[33m‚èè[31m True[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[20:56] <jnthn> std: say True !&& True

[20:57] <p6eval> std 29715: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Can't negate && because tight and operators are not iffy enough at /tmp/1iq6TlwJjH line 1:‚ê§------> [32msay True !&&[33m‚èè[31m True[0m‚ê§FAILED 00:01 105m‚ê§¬ª

[20:57] <TimToady> well, that's suboptimal :)

[20:57] <jnthn> :-)

[20:57] <quietfanatic> Is it because they short-circuit?

[20:57] <jnthn> I think ng may well generate 'em...

[20:57] <TimToady> ng: say 1 !&& 1

[20:57] <p6eval> ng 04a857: OUTPUT¬´Confused at line 1, near "say 1 !&& "‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)‚ê§¬ª

[20:57] <jnthn> ng: say True !?& True

[20:57] <p6eval> ng 04a857: OUTPUT¬´Confused at line 1, near "say True !"‚ê§current instr.: 'perl6;HLL;Grammar;panic' pc 500 (src/stage0/HLL-s0.pir:328)‚ê§¬ª

[20:57] <jnthn> Oh, no. :-/

[20:57] <jnthn> Maybe op= that I was thinking of.

[20:58] <TimToady> we shouldn't generate on spec, mostly we should just do higher-order function calls

[20:58] *** rindolf left
[20:59] <TimToady> funny that % is considered iffy enough, but && isn't

[21:02] *** snarkyboojum left
[21:05] <jnthn> std: sub foo(|$capt) { };

[21:05] <p6eval> std 29715: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[21:05] <jnthn> std: sub foo(|$capt, $another_arg) { };

[21:05] <p6eval> std 29715: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Can't put required parameter after variadic parameters at /tmp/F9HaLx8val line 1:‚ê§------> [32msub foo(|$capt, $another_arg[33m‚èè[31m) { };[0m‚ê§    expecting any of:‚ê§ constraint‚ê§       parameter‚ê§       trait‚ê§FAILED 00:02 106m‚ê§¬ª

[21:05] <jnthn> std: sub foo($blah, |$capt) { };

[21:05] <p6eval> std 29715: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[21:05] <jnthn> TimToady: Is that last one also an error (that is, it's everything into the capture or nothing)?

[21:06] <jnthn> std: sub foo(|$capt ($a, $b, :$c)) { }

[21:06] <p6eval> std 29715: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[21:06] <jnthn> std: sub foo(|$capt :($a, $b, :$c)) { }

[21:06] <p6eval> std 29715: OUTPUT¬´ok 00:01 106m‚ê§¬ª

[21:06] <jnthn> And you unpack with a signature after it if you want both?

[21:06] <ash__> do grammars currently contain any mechanism for setting precedence? I know nqp has one, but i was wondering if normal grammars do 

[21:06] <jnthn> iiuc, we "promote" that signature to be the one considered by MMD too.

[21:07] *** k23z__ joined
[21:10] <jnthn> ash__: In Rakudo, you'd be able to inherit from HLL::Grammar I guess.

[21:11] <TimToady> no, | is supposed to snapshot the current CaptureCursor, so you can have params before that advance the cursor

[21:11] <jnthn> ash__: But that's not a "standard Perl 6" solution.

[21:11] <ash__> i suppose with MMD on a grammar you can control precedence in a way... is that how your supposed to do it? 

[21:11] <cognominal> reading js stuff, I note that for a function C<fun>, there is a  fun.toString() that returns its source. Is the equivalent  &fun.perl considered for Perl 6?

[21:11] <TimToady> I suppose we could allow params after too if | is considered a zero-width parameter

[21:12] <jnthn> TimToady: Ah, OK...I'd thought only one was allowed. :-/

[21:12] <jnthn> That was, it was an "all or nothing" thing.

[21:12] <jnthn> Is there a use-case for snapshotting it part way through?

[21:12] <TimToady> we have to have the ability to have multiple CaptureCursors anyway

[21:12] <jnthn> It's...rather awkward from my current standpoint. :-/

[21:13] <jnthn> Partly because CaptureCursor got invented after I did a huge overhaul of the binder. :-(

[21:16] <jnthn> .oO( All of which would matter less to me if I didn't have a long overdue grant to wrap up that requires me to do |$args )

[21:19] <jnthn> TimToady: The "all or nothing" was coming from current spec, FWIW:

[21:19] <jnthn> It is allowed to rebind the parameters within the signature, but

[21:19] <jnthn> only as a subsignature of the capture argument:

[21:19] <jnthn> sub compare (|$args (Num $x, Num $y --> Bool)) { ... }

[21:19] <jnthn> (from S06)

[21:19] <TimToady> in theory, CaptureCursors would make that trivial

[21:19] <TimToady> and also enable the correct binding semantics for grep etc

[21:20] <TimToady> where correct means "non-introspectively"

[21:20] <jnthn> I still don't quite get what such an invocation looks like, though.

[21:21] <jnthn> If I have { $^n < 100 } for example

[21:22] <jnthn> And I'm writing grep

[21:22] <jnthn> If I have this in &condition, for example

[21:22] <jnthn> What does the invocation look like?

[21:22] <jnthn> &condition(|@list) would give "too many arguments", presumably.

[21:23] <TimToady> that's what Pm-19 was all about

[21:23] *** jackyf left
[21:23] <TimToady> though it's only an approximation

[21:24] <TimToady> but basically we have a way of binding that the incoming cursor knows that it's a submatch, and returns a new cursor somehow

[21:24] <TimToady> you can tell how many things were bound by comparing before/after on cursors

[21:25] <TimToady> ruoso and I were discussing this the other day too

[21:27] <TimToady> http://irclog.perlgeek.de/search.pl?channel=perl6&nick=&q=CaptureCursor

[21:29] <TimToady> I should probably update Pm-19 with something in terms of CaptureCursor

[21:30] <jnthn> TimToady: That'd be helpful

[21:30] <jnthn> TimToady: Yes, I was there watching that discussion as it happened too. :-)

[21:30] <jnthn> I even chimed in now and then...

[21:31] <ash__> wouldn't some sort of precedence mechanism be useful in a grammar? 

[21:31] <jnthn> ash__: Depends what you were parsing. ;-)

[21:32] <ash__> well, if you wanted to make a grammar tool for say perl 6 you'd need one

[21:32] <jnthn> Right.

[21:33] <TimToady> what do you mean by 'grammar tool'?

[21:33] <ash__> something to parse the perl 6 grammar, so nqp or perl 6 itself would be an example i'd reference 

[21:33] <TimToady> um, what do you think it's doing now?

[21:34] <ash__> not sure, thats why  i am asking 

[21:34] <TimToady> STD.pm already uses operator precedence to parse Perl 6

[21:34] <jnthn> TimToady: I think ash__ is asking if, when writing a grammar for some other language in Perl 6, if there'd be a way to re-use the operator precedence parsing mechanism as found in STD.

[21:35] <TimToady> sure, but somewhere you have to have a bottom-up parser installed in your grammar that can make use of it

[21:35] <ash__> i just can't form proper questions, thanks jnthn :p

[21:35] <TimToady> that's EXPR in STD

[21:36] <TimToady> precedence is just annotations on subrules that function as a lexer

[21:36] <TimToady> any bottom-up parser or parser-generator could examine those precedence annotations and do something reasonable with 'em

[21:37] <TimToady> though a parser-generator isn't very flexible

[21:37] <TimToady> which is why STD doesn't

[21:38] <ash__> how does EXPR know the precedence? is it hard coded into it? (looking at it now, but its a bit large) 

[21:39] <jnthn> ash__: It's declared along with the operators.

[21:39] <TimToady> it's currently set by <O()> assertions in the respective operator rules

[21:39] <jnthn>     token prefix:sym<+>

[21:39] <jnthn>         { <sym> <O(|%symbolic_unary)> }

[21:40] <ash__> okay

[21:40] <TimToady> usually by reference to a set of predefined precedence hashes defined earlier

[21:40] <colomon>  hey, how did range.t break while I was out?   :\ 

[21:40] <jnthn> If you look up %symbolic_unary near the top of STD, you'll see it. :-)

[21:40] <jnthn> colomon: Not afaik. :-/

[21:40] <colomon> oh, it's another crash.

[21:40] <jnthn> colomon: oops, missed the "how"

[21:40] <colomon> never mind, then.

[21:40] <jnthn> Oh, roaming segv. :-|

[21:40] <jnthn> colomon: Do you get one on index.t too?

[21:41] <colomon> not this time, but I've been seeing that one about 2/3rds of the time.

[21:41] <TimToady> ash__: and metaoperators either pass through the precedence of the base operator, or impose a new precedence of their own

[21:43] *** hercynium joined
[21:43] *** uniejo left
[21:44] *** uniejo joined
[21:44] <TimToady> most parser generators would have difficulty dealing with such dynamic precedence, which is why we stick with simple operator precedence.

[21:44] <ash__> so, if you defined 2 infix ops like: infix:<¬£> (Int $a, Int $b) {...} and infix:<‚àû> (Int $a, Int $b) {...}   and did 1 ¬£ 3 ‚àû 6 would that be... left to right? 

[21:45] <TimToady> and because parser generators tend to give lousy error messages

[21:45] <ash__> or would that throw an error? 

[21:46] <TimToady> the default is addition prec, which is left associative

[21:47] <TimToady> see also S06:1791

[21:48] *** hercynium left
[21:49] <ash__> ah, okay so you can set it via the is tighter/is looser/is equiv 

[21:49] <colomon> jnthn: I think I'm going to revert the change that made a Int constant an Int instead of an Integer.

[21:50] <jnthn> colomon: It's causing other issues?

[21:51] <jnthn> fwiw, it caused no new failures here...

[21:51] <colomon> jnthn: It just seems like we should be consistent (somewhat) and if most Int operations are going to return Integers, there's no sense in making one exception to the rule.

[21:51] <jnthn> Yeah, good point.

[21:51] <TimToady> ash__: most of the operator definitions in STD don't actually belong there, and will eventually move to CORE

[21:52] <ash__> CORE is the default settings, right? 

[21:52] <TimToady> yes

[21:52] <TimToady> CORE.setting has stubs in the current STD directory

[21:53] <TimToady> mostly to declare known type names, currently

[21:53] <TimToady> STD implements the setting as an outer lexical scope, though rakudo hasn't got there yet

[21:54] <ash__> alright, that makes sense, thanks for the info, CORE.setting is pretty helpful actually

[22:02] <pugs_svn> r29716 | colomon++ | [t/spec] Remove the 10 abs tests which were tripping up ng, in a fashion which makes them easy to add back in the future. 

[22:03] <ash__> is Num's constant pi correct in CORE.setting? didn't it get changed into a rat? 

[22:05] <colomon> ng: say pi.WHAT

[22:05] <p6eval> ng df72c9: OUTPUT¬´Num()‚ê§¬ª

[22:07] <ash__> pugs commit r29714

[22:07] <ash__> just asking

[22:09] <colomon> ash__: A Rat64 that would require more than 64 bits of storage in the denominator is automatically converted either to a Num or to a lesser-precision Rat, at the discretion of the implementation. 

[22:09] <colomon> (that's S02)

[22:10] <ash__> gotcha 

[22:10] <dalek> rakudo/ng: da4a858 | (Solomon Foster)++ | src/Perl6/Actions.pm:

[22:10] <dalek> rakudo/ng: Revert "Add :returns('Int') to the integer action, so that we get Ints instead of Integers."

[22:10] <dalek> rakudo/ng: "It just seems like we should be consistent (somewhat) and if most Int operations are going to return Integers, there's no sense in making one exception to the rule."

[22:10] <dalek> rakudo/ng: This reverts commit d71e295fe6d98950de698e4c7da90ded1f99bcca.

[22:10] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/da4a8587b48a2170d44dd32c556348b843c410a8

[22:11] <colomon> ng: say abs("-10")

[22:11] <p6eval> ng df72c9: OUTPUT¬´Method 'Num' not found for invocant of class 'Perl6Str'‚ê§current instr.: 'perl6;Any;abs' pc 259401 (src/gen/core.pir:19809)‚ê§¬ª

[22:12] <pugs_svn> r29717 | colomon++ | [t/spec] Unfudge three tests which work now. 

[22:17] <ash__> ng: say "string".WHAT

[22:17] <p6eval> ng df72c9: OUTPUT¬´Str()‚ê§¬ª

[22:18] <colomon> ng: say PARROT("string")

[22:18] <p6eval> ng df72c9: OUTPUT¬´sh: ./perl6: No such file or directory‚ê§¬ª

[22:19] <jnthn> colomon: Youch. I just caught one of the segfaults in the debugger.

[22:20] <jnthn> colomon: It's wrongly allocating memory for a string somehow, it seems.

[22:20] <colomon> yeah? he said, optimistically...

[22:22] <colomon> Oh, that reminds me.  I don't know if you saw my paste from a couple of days ago, but valgrind seemed to catch it referring to a couple of bytes off the edge of a long allocation.

[22:23] <jnthn> colomon: Hm

[22:23] <ash__> i bet #parrot would love to see a valgrind report on misallocation of memory, thats helpful for tracking down the problem 

[22:23] <jnthn> colomon: It seems to be some GC-ish issue.

[22:23] <jnthn> Memory pool (mis-)management or something.

[22:26] <colomon> jnthn: how did you catch the segfault?

[22:26] <jnthn> Ran the code under a C debugger.

[22:26] <colomon> I mean, what file was it?  maybe I can valgrind it for further useful information.

[22:27] <jnthn> src/string/apic.c

[22:27] <jnthn> *api.c

[22:27] <jnthn> Line 904

[22:27] <jnthn> ->strstart gets set to something invalid in Parrot_gc_allocate_string_storage(interp, s, len);

[22:29] <jnthn> I'm kinda too tired to go debugging memory pools code right now though.

[22:30] <colomon> I meant, what p6 were you running to get the bug?  (I assumed there was a test file involved.)

[22:31] <jnthn> arity.t

[22:32] <jnthn> It may be that it doesn't segv on your platform though :-/

[22:32] <colomon> nope, it sure does segfault here.  :)

[22:32] <colomon> valgrind, here we go!

[22:33] <dalek> rakudo/ng: 2b06cc0 | jonathan++ | src/b (2 files):

[22:33] <dalek> rakudo/ng: Stub out capture snapshots in signatures. Note we can't do them as real snapshots until we get CaptureCursor style stuff in place, but we should be able to quickly get equivalent semantics in place, and when we do get CaptureCursor the infrastructure is there to use.

[22:33] <dalek> rakudo/ng: review: http://github.com/rakudo/rakudo/commit/2b06cc052064e24211be1fecd99f2463f2121479

[22:34] <colomon> ah, might work better if we were using the same code.  :p

[22:34] *** Su-Shee left
[22:34] <jnthn> Well yeah, it may just be very memory sensitive...

[22:35] <colomon> (first valgrind run is still working here.  :)

[22:38] <jnthn> Of course, it's possible the memory pool code is wrong, but something is corrupting the block sizes, etc.

[22:39] <cognominal> please blog all the wonderful stuff you do so that beotians like me can have a vague idea of it.

[22:39] <colomon> hmmm, works fine under valgrind.  :(

[22:39] <jnthn> :-(

[22:39] <colomon> time to pull and try again.

[22:40] *** sg__ left
[22:44] <colomon> nope, still works.  :(

[22:47] *** uniejo left
[22:47] <jnthn> :-(

[22:48] *** masak joined
[22:48] <masak> ok, I'm officially confused.

[22:49] <colomon> masak: one of us!  one of us!

[22:49] <jnthn> It's official!

[22:49] <masak> I seek clarity. hi, jnthn.

[22:49] <jnthn> What confuseth thee, o masak?

[22:50] <masak> anon enums, their place in the new world order, and the inner workings of Grammar and Actions.

[22:50] <masak> I'll try to pose specific questions, see if that helps.

[22:51] <masak> question number one: in http://gist.github.com/303711 , how come I haz a need for both 'token term:sym<type_declarator>' and 'token type_declarator'?

[22:52] <jnthn> The first says that it is parsable in syntactic category of terms.

[22:52] <masak> ok.

[22:52] <jnthn> so if we have <term> then one of the things we can match at that point is a type_declarator

[22:52] <masak> it's a term, I'll grant that.

[22:53] <masak> so it's another entry point than via <declarator>, is that it?

[22:53] <jnthn> Correct.

[22:53] <masak> is the latter for 'my ...' et al?

[22:54] <jnthn> That kinda stuff, yes.

[22:54] <masak> \o/

[22:54] * masak haz a quantum of understanding

[22:54] * jnthn tries not to entangle it

[22:55] <masak> question number two: ok, so it parses. I get an annoying error message. how do I know where to add incantations in Actions?

[22:55] <masak> what's the thinking behind adding stuff?

[22:55] <masak> the old world order has a nice, clear method enum_declarator wherein everything happens.

[22:56] <masak> the new one... not so much.

[22:56] <jnthn> You'd want a method matching the grammar rule name

[22:56] <lichtkind> bye

[22:56] <jnthn> method type_declarator:sym<enum>($/) { ... }

[22:56] <masak> lichtkind: \o

[22:56] <jnthn> o/

[22:56] <lichtkind> :)

[22:57] <jnthn> dobru noc, lichtkind 

[22:57] *** lichtkind left
[22:57] <masak> jnthn: I have that.

[22:57] <masak> but it's meanless.

[22:57] <jnthn> Great, so it gets called. :-)

[22:57] <masak> it only does make $<type_declarator>.ast;

[22:57] <jnthn> oh wait

[22:57] <jnthn> which does that?

[22:57] <masak> oh wait.

[22:57] <jnthn> Your term:sym<type_declarator> one should do that.

[22:57] <masak> that's term:sym<type_declarator>

[22:57] <jnthn> Right.

[22:58] <masak> yes. why?

[22:58] <masak> you seem to find that obvious.

[22:58] <jnthn> .oO( that's how I know I've been doing this stuff too long... )

[22:58] <masak> what am I not seeing?

[22:58] <jnthn> Basically, each thing that we parse in the grammar (or most of 'em, anyway) need to lead to production of some AST node.

[22:59] <jnthn> Things that do $<term>.ast will need said node.

[22:59] <masak> nodnod. the former part is totally clear to me as well.

[23:00] <jnthn> All you're doing is saying "when the term matched this protoregex, then all we need to do is get the AST node made by the type_declarator's action method and pass it on up"

[23:00] <masak> it's just the which-things-end-up-with-which-things part that's not entirely clear to me.

[23:00] <jnthn> Maybe think of it as, you associate bits of AST that you build further down in the tree with the match nodes.

[23:01] <jnthn> Thus the things above them in the tree - which have the match nodes to hand - can then get hold of the AST nodes that were built by calling .ast

[23:01] <jnthn> The make function just sets what .ast will return for the match object.

[23:01] <masak> jnthn: (by the way, I hear your –Æ–ª—ñ—è is creating a bit of a FUD over not winning the election.)

[23:02] <masak> jnthn: yes, the thing with the bits of AST and .ast is no issue to me.

[23:02] <jnthn> masak: (–î–∞, –Ω–æ –£–ª–∏—è –∫—Ä–∞—Å–∏–≤–∞—è...hmm...but I guess I can't finish that with "so I'm turning a blind eye" :-P)

[23:02] <masak> but I'm still confused over why term:sym<...> should have a trivial implementation, but type_declarator:sym<enum> should not.

[23:03] *** Guest54390 left
[23:03] <mberends> .oO( it's so much easier to just leave it to TimToady++ and read viv output ;)

[23:03] <masak> jnthn: I could consume the bit of the phrase you could produce, at least. and without resorting to Google Translate :)

[23:03] <jnthn> masak: Because it's doing something like the parse-tree equivalent of delegation. :-)

[23:03] <masak> jnthn: ok, that does help.

[23:04] <jnthn> masak: So looking at wht happens

[23:04] <jnthn> Something does <term>

[23:04] <masak> right.

[23:04] <masak> doesn't much matter what.

[23:04] <jnthn> term is a proto-regex, so we end up magically term:sym<type_declarator>

[23:04] <jnthn> Tht contains <type_declarator> so we go and parse one of them

[23:05] <jnthn> at this point we did not run _any_ action methods at all.

[23:05] <jnthn> ignoring what happens to actually parse a type declarator etc, at the end of the type_declarator rule, the type_declarator action method gets run.

[23:05] * masak .oO( Yulia has a husky, almost spooky voice... )

[23:05] <masak> http://www.kniivila.net/2010/tymosjenko-talar-till-nationen/#more-4386

[23:06] *** payload joined
[23:06] <jnthn> How am I meant to explain ASTs to you if you're talking about –∫—Ä–∞—Å–∏–≤–∞—è –£–ª–∏—è?!

[23:06] <masak> sorry... :)

[23:07] <jnthn> ...where was I...

[23:07] <masak> we finally called a method.

[23:07] <jnthn> Ah, OK, so actually type_declarator is also proto_regex, so we end up in the enum variant of it.

[23:07] <jnthn> Anyway, it calls that action method.

[23:07] <masak> yes.

[23:08] <jnthn> It builds a chunk of AST that represents an enum.

[23:08] *** bkeeler joined
[23:08] *** bkeeler left
[23:08] <masak> that part represent my question three, by the way.

[23:08] *** bkeeler joined
[23:08] <masak> you mentioned that it should be possible to do that in pure Perl 6.

[23:09] <jnthn> We'll disregard how exactly to do that for now, but the point is we end up with some kind of PAST::Node (e.g. some subclass of it) and we do make $that-ast-that-we-made;

[23:09] <jnthn> This associates the AST with the match node.

[23:09] <jnthn> The action method returns, and the type_declarator_enum rule returns too

[23:09] <jnthn> That leaves us back in term:sym<type_declarator>

[23:09] <jnthn> Which is now at the end of the rule, so it calls the action method there

[23:10] <masak> yes.

[23:10] <jnthn> It does not need to do anything to what has been constructed, so it just gets the AST node we built already, which it gets through $<type_declarator>.ast

[23:10] <masak> since we're in term:sym<type_declarator>, it's an anon enum, yes?

[23:10] <jnthn> And it does make of that.

[23:10] <lisppaste3> colomon pasted "valgrind errors on S03-operators/basic-types.t " at http://paste.lisp.org/display/94920

[23:10] <jnthn> masak: No

[23:10] <jnthn> Not automatically.

[23:11] <masak> the `make $<type_declarator>.ast` is a kind of delegation? it just pulls up the result from its child node.

[23:11] <colomon> That paste has what appear to be clear errors caught by valgrind.

[23:11] <jnthn> colomon: Oooh!

[23:11] <jnthn> masak: It pulls up the node that the action method we ran for type_declarator set using make.

[23:12] <masak> right. seems I get that part.

[23:12] <jnthn> masak: It's sorta like delegation, but the result was already produced for us anyway. :-)

[23:12] <masak> indeed.

[23:12] <jnthn> So we just get hold of it.

[23:12] <jnthn> I guess

[23:12] <masak> aye.

[23:12] <jnthn> We parse by descending

[23:13] <jnthn> And build AST as we come back up

[23:13] <jnthn> colomon: That matches the segv I saw.

[23:13] <jnthn> colomon: But gives more detail.

[23:13] <jnthn> colomon: It looks like the pool compaction is hosed.

[23:13] <colomon> jnthn: \o/

[23:13] <masak> jnthn: yep.

[23:13] <jnthn> colomon: Well, unless the code that does pool compaction is fine and the memory got corrupted another way.

[23:14] <masak> jnthn: anywhere I can read up about PAST? I'm a bit fuzzy on both the syntax and the properties of it.

[23:14] <jnthn> Syntax wise, it's just like creating a bunch of Perl 6 objects - that's all the nodes are.

[23:14] <colomon> jnthn: how do we get this to the parrot gang?

[23:14] <jnthn> masak: http://docs.parrot.org/parrot/latest/html/docs/pdds/pdd26_ast.pod.html

[23:15] <jnthn> masak: That documents the various AST nodes that exist.

[23:15] <masak> thanks!

[23:15] <jnthn> colomon: Maybe filing a Trac ticket is easiest.

[23:15] <masak> \o/

[23:15] <colomon> I don't know anything about the parrot bug tracking system?

[23:16] <masak> with this new information, I think I can go back into my cocoon and try again :)

[23:16] <masak> will be back tomorrow. good night!

[23:16] *** masak left
[23:17] <jnthn> http://trac.parrot.org/parrot

[23:17] *** iblechbot left
[23:19] <colomon> jnthn: I hate to be dense, but I don't see where to submit bugs there?

[23:21] <jnthn> colomon: gah, needs an account

[23:21] <jnthn> colomon: I can submit.

[23:21] <colomon> danke.

[23:23] <colomon> "clarify that anon allows a name but doesn't install it for jnthn++"

[23:23] <colomon> I'm impressed that the language spec has special cases for jnthn.

[23:24] <colomon> :)

[23:25] *** payload left
[23:25] <jnthn> ;-)

[23:26] <mberends> does that mean the language *does* install a name when the user is *not* jnthn ?

[23:26] <colomon> That's how I read it, though I guess it is under-specified.

[23:27] * jnthn can't wait to see the code to detect if it's him.

[23:27] <colomon> Wow, pi.t is spectacularly useless.

[23:27] <colomon> None of the tests actually conform to the spec.

[23:28] <colomon> and creating 3.14159265358979323846264338327950288419716939937510e0 so you can compare the first five digits to pi is very silly.

[23:29] *** hercynium joined
[23:31] <jnthn> colomon: http://trac.parrot.org/parrot/ticket/1443

[23:33] <mberends> jnthn: why is the Parrot version there 1.9 and not 2.0?

[23:33] <mberends> (nit, nit)

[23:33] <jnthn> mberends: It's probably not either, it's whatever PARROT_REVISION is set to.

[23:33] <mberends> aha

[23:34] <jnthn> mberends: We'll sync up with latest Parrot soon, I expect.

[23:34] <jnthn> In prep for Thursday release.

[23:34] <jnthn> If we can re-produce it again then, we can bump the version number in the ticket too. :-)

[23:34] <jnthn> Just wanted to get the issue and valgrind output recorded.

[23:35] <mberends> fine. I hope ng becomes master by Thursday

[23:36] <jnthn> It will.

[23:37] <jnthn> I think pmichaud++ is keen to get slices in place first.

[23:37] <mberends> yes. cool!

[23:37] <jnthn> colomon++ is doing a really great job in lots of built-ins too.

[23:38] <mberends> absolutely. colomon++

[23:44] * colomon blushes

[23:48] <pmurias> jnthn: jnthn might end up a popular user name if it give extra language features

[23:50] <mberends> developers: when you have contributed enough to Perl 6, queue here to have a language feature named after you ;)

[23:53] *** payload joined
[23:53] *** Rix left
[23:54] <lue> Oi! You've talked a lot while I was gone :)

[23:56] <mberends> tell me about it... as a confirmed backlog junkie, it's hard to survive off-channel

[23:58] <lue> *twitch* *twitch* I'm fine... *TWITCCH*

[23:58] <diakopter> <gurgle>

[23:59] * diakopter drowns in the backlog from several days ago until now.

[23:59] <lue> Quick! Get diakopter out of the C++ !!!

