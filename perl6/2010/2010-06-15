[00:00] *** cdarroch left
[00:01] *** szabgabx joined
[00:16] *** lest_away is now known as lestrrat

[00:19] *** azert0x left
[00:29] *** snarkyboojum left
[00:38] *** Schwern joined
[00:39] *** gbacon left
[00:54] *** adhlssu07 joined
[01:04] <pugssvn> r31259 | lwall++ | [STD] don't give the wrong advice on sub() 

[01:05] *** whiteknight left
[01:08] *** Visitor99 joined
[01:16] *** adhlssu07 left
[01:17] *** alester joined
[01:23] *** stepnem left
[01:27] *** snarkyboojum joined
[01:39] *** Visitor99 left
[01:48] <snarkyboojum> what's the best url to point someone at when attempting to explain what Rakudo Star will/might mean? http://use.perl.org/~pmichaud/journal/39411?

[01:48] <pmichaud> so far, yes.

[01:49] <snarkyboojum> pmichaud: cheers :)

[01:49] <pmichaud> question for the channel:  I think our .perl may be a little too naive as specced (more)

[01:49] <pmichaud> consider:

[01:49] <pmichaud>     my $r = 1..5;   my @r = $r, 3;   say @r.perl

[01:49] <pmichaud> what should be the output?

[01:50] <pmichaud> currently I'm voting in favor of   "([1..5], 3)"

[01:51] <pmichaud> (although this is not at all what the spec says at the moment.)

[01:51] <diakopter> what's the argument against [[1..5], 3]

[01:51] <pmichaud> okay, I've changed my mind :-)

[01:51] *** colomon joined
[01:51] <pmichaud> now I'm going to argue in favor of   ( (1..5).item, 3 )     :-)

[01:52] <pmichaud> one argument against  [[1..5], 3]  is that it doesn't contain a Range :)

[01:53] <snarkyboojum> I'd find it confusing that it seems to say that @r contains an array, when 1..5 is a range

[01:53] <snarkyboojum> or am I misunderstanding what @r contains? :)

[01:53] <pmichaud> @r is an array of two elements

[01:53] <pmichaud> the first element is a non-flattening range, the second element is a 3

[01:53] <snarkyboojum> pmichaud: yep, but 1..5 is still a range isn't it?

[01:54] <pmichaud> yes, but if you were to eval the string  "[1..5, 3]"   you souldn't end up with a 2-element array.

[01:54] <snarkyboojum> ah ok

[01:54] <pmichaud> and one of the claimed purposes of .perl is that you can evaluate the returned string back to the same object.

[01:55] <snarkyboojum> right :)

[01:55] <diakopter> rakudo: [1..3].item.WHAT.say

[01:55] <p6eval> rakudo cfbeb5: OUTPUT«Array()␤»

[01:55] *** Schwern left
[01:55] <diakopter> item should return a range?

[01:56] *** JeffreyKegler joined
[01:56] <pmichaud> you put it inside of an array

[01:56] <pmichaud> [1..3]  is an Array containing a lazily evaluated array

[01:56] <diakopter> rakudo: (1..3).item.WHAT.say # oh

[01:56] <pmichaud> [1..3].item is that same Array

[01:56] <p6eval> rakudo cfbeb5: OUTPUT«Range()␤»

[01:56] <TimToady> yes, the $r suppresses flattening in the list assignment

[01:57] <diakopter> rakudo: ( (1..5).item, 3 ).say

[01:57] <p6eval> rakudo cfbeb5: OUTPUT«123453␤»

[01:57] *** Schwern joined
[01:57] <diakopter> rakudo: ( (1..5).item, 3 ).perl

[01:57] <p6eval> rakudo cfbeb5:  ( no output )

[01:57] <diakopter> rakudo: ( (1..5).item, 3 ).perl.say

[01:57] <p6eval> rakudo cfbeb5: OUTPUT«(1..5, 3)␤»

[01:57] <pmichaud> that's wrong in current master, probably fixed in my list branch

[01:58] <pmichaud> well, it's closer in my list branch

[01:58] <TimToady> rakudo: (1..5).say

[01:58] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[01:58] <pmichaud> > ( (1..5).item, 3).perl.say

[01:58] <pmichaud> (1..5, 3)

[01:58] <diakopter> (that's what it says above)

[01:58] <pmichaud> anyway, I'm thinking that .perl ought to be smart enough to distinguish items versus flattening objects and dtrt

[01:59] <pmichaud> (I've started doing this in the new branch, but wanted to ask the channel before doing anything much more radical with it)

[01:59] *** Visitor99 joined
[02:00] <TimToady> I'd argue that should say '1..5'

[02:00] <TimToady> sorry 'bout the lag--my family is microwaving on 2.4Ghz  :/

[02:00] <pmichaud> that can be done also :-)

[02:01] <TimToady> I mean (1..5).say should say that

[02:01] <pmichaud> right

[02:01] <pmichaud> what about  ~(1..5)  ?

[02:01] <pmichaud> is that still "1 2 3 4 5"?

[02:01] <TimToady> Stringy can be different from Str

[02:02] <TimToady> .say is presumably forcing .Str

[02:02] <Visitor99> rakudo: my Rat $rat=1.2; my Int $int=5; my Str $str="string!"; my @arreglo = ($rat, $int, $str); for @arreglo { when ($_~~Rat) { say "$_ =rational"; }  when ($_~~Str) { say "$_ =string"; }  when ($_~~Int) { say "$_ =integer"; } }

[02:02] <p6eval> rakudo cfbeb5: OUTPUT«string! =rational␤»

[02:02] <TimToady> or some other-level stringifier that isn't ~

[02:02] <Visitor99> that line works ok when using "if" instead of "when"

[02:03] <Visitor99> i had the idea that "when" was similar to "if". 

[02:03] *** JimmyZ joined
[02:03] <pmichaud> Visitor99: note that you don't need the $_ ~~   in the when clauses.

[02:03] <colomon> rakudo: my Rat $rat=1.2; my Int $int=5; my Str $str="string!"; my @arreglo = ($rat, $int, $str); for @arreglo { when Rat { say "$_ =rational"; }  when Str { say "$_ =string"; }  when Int { say "$_ =integer"; } }

[02:03] <p6eval> rakudo cfbeb5: OUTPUT«1.2 =rational␤5 =integer␤string! =string␤»

[02:04] <Visitor99> oh,,,, cool.. :)

[02:04] <TimToady> otherwise there would be little point in given/when

[02:04] <pmichaud> rakudo:  for 1.2, 5, 'string!' { when Rat { say "$_=rational" }; when Str { say "$_=string"; };  when Int { say "$_=integer"; } }

[02:04] <p6eval> rakudo cfbeb5: OUTPUT«1.2=rational␤5=integer␤string!=string␤»

[02:04] *** JeffreyKegler left
[02:04] <diakopter> heh !=

[02:05] <snarkyboojum> rakudo: my $r = 1..5; my @r = $r, 3; @r.map: { .WHAT }

[02:05] <p6eval> rakudo cfbeb5:  ( no output )

[02:06] <snarkyboojum> rakudo: (eval '[[1..5], 3]').map: { say .WHAT }

[02:06] <p6eval> rakudo cfbeb5:  ( no output )

[02:06] <snarkyboojum> hehe I give up :)

[02:07] <pmichaud> Visitor99: anyway,  "if" tests a boolean condition, while "when" does a smartmatch

[02:07] <pmichaud> also, a matching "when" skips to the end of the block, while an "if" will fall through to continue executing the rest of the block

[02:10] *** [mark] joined
[02:10] <TimToady> but it's not clear that ~(1..5) should do the same as ~(1...5), since .. has a valid scalar meaning of "interval"

[02:11] <pmichaud> sure, I can buy that

[02:11] <pmichaud> at the moment I was more interested in the proper handling o f.perl

[02:11] <pmichaud> er, of .perl

[02:12] <TimToady> I'm inclined to be conservative about eager listification in the absence of a list context

[02:12] <TimToady> scalars should generally behave as scalars unless provoked

[02:13] <diakopter> rogue scalars are scary

[02:13] <TimToady> so ~(1..5) may well be different from ~(1..5,)

[02:14] <pmichaud> well, as far as .perl goes, I think rakudo gets that one right-ish atm

[02:14] <pmichaud> rakudo:  say (1..5).perl

[02:14] <p6eval> rakudo cfbeb5: OUTPUT«1..5␤»

[02:14] * diakopter suddenly regrets spending a week straight fuzzing rakudo on series & range literals.

[02:14] <pmichaud> rakudo:  say (1..5,).perl

[02:14] <p6eval> rakudo cfbeb5: OUTPUT«(1..5, )␤»

[02:15] <pmichaud> it's the array case that I find a bit more interesting for .perl

[02:15] <TimToady> rakudo: say (1..5,)

[02:15] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[02:15] <TimToady> rakudo: say (1..5)

[02:15] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[02:15] <TimToady> that one's wrongish

[02:15] <pmichaud> oh?

[02:15] <pmichaud> the 1..5 doesn't interpolate in list context?

[02:16] <diakopter> rakudo: say (1..5,,Nil)

[02:16] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[02:16] <TimToady> oh, you're right

[02:16] <TimToady> that is a list context

[02:16] <TimToady> rakudo: (1..5).say

[02:16] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[02:16] <TimToady> that one is wrongish

[02:16] <pmichaud> I'm willing to say that should be different

[02:16] <pmichaud> I wouldn't have a problem with ranges stringifying to something else

[02:17] <pmichaud> and presumably   rakudo:  say (1..5).item    # "1..5", not "12345"  or "1 2 3 4 5"

[02:17] <TimToady> correct

[02:17] <pmichaud> so, when say stringifies the items of its list, it uses Stringy or Str ?

[02:18] <TimToady> Str

[02:18] <pmichaud> and same for interpolation in double-quotes?

[02:18] <TimToady> ~ is high-level, Str is low

[02:18] <pmichaud> my $r = 1..5;   say "$r";   # ??

[02:19] <TimToady> well, ~(1..5) may also be '1..5'

[02:19] <TimToady> more interesting is junctions

[02:19] <TimToady> ~(1|2|3) is "1"|"2"|"3" but (1|2|3).Str is 'any(1,2,3)'

[02:20] <TimToady> but I'd say string interpolation is Stringy

[02:20] <TimToady> not Str

[02:20] <TimToady> "$r" is sugar for ~$r

[02:21] <pmichaud> okay, and infix:<~>  is also using Stringy interpretations of things

[02:21] <TimToady> nod

[02:22] <pmichaud> I have a feeling that's going to confuse people :)

[02:22] <pmichaud> that     say $r    would be different from   say "$r"

[02:22] <pmichaud> or, more precisely, that    say $r, " hello"      will end up being different from   say "$r hello"

[02:23] <TimToady> if $r is a range, those are the same output

[02:23] <TimToady> assuming range is always "1..5"

[02:24] <pmichaud> oh, so in the case of range, .Stringy and .Str end up being the same

[02:24] <TimToady> but ... is likely to be different

[02:24] <TimToady> that's what I'm thinking, since Ranges are intervals first

[02:24] <pmichaud> okay

[02:24] <TimToady> and only lists of integers secondarily

[02:24] <TimToady> whereas a Series is always implicitly listy

[02:24] <pmichaud> we'll need to get some tests in place for some of this :-)

[02:25] <TimToady> we've been detangling .. and ... for a while now :)

[02:25] <pmichaud> and strings, too.

[02:25] <pmichaud> anyway, I'm hoping the new list implementation will help us in our detanglings.

[02:25] <pmichaud> it's definitely resulting in much cleaner code overall.

[02:26] <TimToady> \o/

[02:26] <pmichaud> and it's no longer a question of "what methods do we need" but rather "which classes should have which ones?"

[02:26] <colomon> \o/

[02:26] <JimmyZ> what does detanglings mean?

[02:26] <pmichaud> And there's usually only one or two obvious places for each.

[02:26] <pmichaud> so I'm pretty happy with the overall API.

[02:26] <TimToady> JimmyZ: do you know "tangle"?

[02:27] <JimmyZ> yes

[02:27] <JimmyZ> thanks.

[02:27] <TimToady> detangling is removing the tangle :)

[02:27] <JimmyZ> thanks again

[02:28] <TimToady> np, you're English is much better than my Mandarin :)

[02:28] <TimToady> *your

[02:28] <TimToady> my English ain't so good either...

[02:35] * JimmyZ knows that TimToady's perl is much much much better than him

[02:36] <diakopter> LOLz at indefinite 'him' antecedent

[02:37] * JimmyZ knows his english is poor too, wrong wording.

[02:37] <diakopter> I wasn't laughing at you :) your english was clear

[02:37] <JimmyZ> ^_^

[02:37] <diakopter> properer english would be "his" instead of "him"

[02:38] <JimmyZ> yeah

[02:39] *** JimmyZ left
[02:44] *** JimmyZ joined
[02:49] <Visitor99> the rakudo that is used when i invoke rakudo: in this irc channel, it's the same that is available via github?

[02:51] <colomon> Visitor99: yes

[02:51] <colomon> unless it's gotten behind.

[02:51] <colomon> rakudo: say 1

[02:51] <p6eval> rakudo cfbeb5: OUTPUT«1␤»

[02:52] <colomon> okay, it's up to date at the moment.

[02:54] *** masonkramer joined
[02:54] <TimToady> std: sub() {}

[02:54] <p6eval> std 31259: OUTPUT«[31m===[0mSORRY![31m===[0m␤Word 'sub' interpreted as 'sub()' function call; please use whitespace around the parens at /tmp/tmmJNnExhn line 1:␤------> [32msub[33m⏏[31m() {}[0m␤Unexpected block in infix position (two terms in a row) at /tmp/tmmJNnExhn line 1:␤------>

[02:54] <p6eval> ..[32msu…

[02:54] <TimToady> looks like std is also up-to-date

[02:54] <diakopter> std: sub{}

[02:54] <p6eval> std 31259: OUTPUT«ok 00:01 104m␤»

[02:56] *** gbacon joined
[02:56] *** diakopter sets mode: +oooo colomon ingy sorear Juerd

[02:57] *** TimToady sets mode: +vv buubot dalek

[02:57] *** TimToady sets mode: +vv ilogger2 IRSeekBot

[02:57] *** TimToady sets mode: +vv p6eval phenny

[02:57] *** TimToady sets mode: +v pugssvn

[03:02] *** stepnem joined
[03:09] <snarkyboojum> could someone give me some advice on what I'm doing wrong here? http://gist.github.com/438641 - I get 'Null PMC access in invoke()'

[03:12] <snarkyboojum> I'm sure it's a UTS error (User Too Stupid) :)

[03:12] <pugssvn> r31260 | sorear++ | [dfa/Cursor] Refactor & implement quantifiers. 

[03:15] *** masonkramer left
[03:21] <Visitor99> rakudo: my $a; say $a.WHAT; $a = 1; say $a.WHAT; $a = Mu; say $a.WHAT;

[03:21] <p6eval> rakudo cfbeb5: OUTPUT«Any()␤Int()␤Mu()␤»

[03:21] *** plobsing joined
[03:25] <Visitor99> rakudo: my $a; say $a.WHAT; $a = 1; say $a.WHAT; $a = Mu; say $a.WHAT; $a = Any; say $a.WHAT; 

[03:25] <p6eval> rakudo cfbeb5: OUTPUT«Any()␤Int()␤Mu()␤Any()␤»

[03:31] <Visitor99> my $a = 123; say $a.reverse;

[03:31] <Visitor99> rakudo: my $a = 123; say $a.reverse;

[03:31] <p6eval> rakudo cfbeb5: OUTPUT«123␤»

[03:31] <TimToady> rakudo: my $a = 123; say $a.flip

[03:31] <p6eval> rakudo cfbeb5: OUTPUT«321␤»

[03:32] <Visitor99> if there is no reverse for an int.. why such a method exists for ints?

[03:33] <pmichaud> it's treated like a list of one element

[03:33] <pmichaud> in general, most non-list objects will act like a list of one element if you attempt to use a list method on them

[03:33] <TimToady> such methods are more a part of the language than a method of any particular type

[03:34] <TimToady> though any given type may override them, of course

[03:34] <snarkyboojum> rakudo say Int.^methods(:local).join(' ');

[03:34] <snarkyboojum> rakudo: say Int.^methods(:local).join(' ');

[03:34] <p6eval> rakudo cfbeb5: OUTPUT«log log10 sech truncate sin sqrt Int asin Bool cosh succ sign asinh acosech abs reals ceiling unpolar floor asech Rat round acosec acosh Num cosech cotan atan2 tan Real atan cos acos tanh perl Numeric Str acotanh ACCEPTS from-radians pred atanh Bridge exp cosec sinh to-radians

[03:34] <p6eval> ..WHIC…

[03:35] *** gbacon left
[03:35] <TimToady> it seems odd that Int would have all those Real methods as :local

[03:36] <pmichaud> agreed

[03:37] <pmichaud> rakudo sez

[03:37] <pmichaud> augment class Int does Real {

[03:37] <pmichaud> so I'm guessing the Real methods are composed into the Int class

[03:38] <pmichaud> beyond that, I don't know the current state of things in rakudo -- I've been letting colomon++ et al. handle those while I'm focused elsewhere.

[03:38] <pmichaud> s/things/Real and numerics/

[03:39] *** meppel joined
[03:41] <TimToady> it's like you want Int is RealInt, and RealInt does Real, or something

[03:42] <TimToady> but it's probably not important

[03:43] *** meppl left
[03:45] * sorear is now on the most technically problematic point of dfa/Cursor, named character classes

[03:45] *** snarkyboojum left
[03:45] *** Visitor99 left
[03:48] * lue ponders sized ints and other number types, if applicable

[03:54] <lue> rakudo: my int8 $a = 0xFF; say $a.WHAT

[03:54] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤Malformed my at line 11, near "int8 $a = "␤»

[03:55] <lue> rakudo: my Int8 $a = 0xFF; say $a.WHAT

[03:55] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤In "my" declaration, typename Int8 must be predeclared (or marked as declarative with :: prefix) at line 11, near " $a = 0xFF"␤»

[03:55] <TimToady> rakudo has no idea what you're talking about :)

[03:55] <lue> it's interesting, every single number type with size is lowercase

[03:56] <TimToady> yes, because those are the native types, which care

[03:56] *** tedv left
[03:56] <lue> is it a parrot-side problem or rakudo-side? [me checks ROADMAP]

[03:56] <pmichaud> little of both.

[03:57] <pmichaud> it's also not high priority at the moment

[03:57] <pmichaud> (relative to other things that need doing)

[03:57] <lue> Yeah, it's nice to have on ROADMAP, with footnote about Parrot devel needed.

[03:58] *** snarkyboojum joined
[03:59] <sorear> ROADMAP should be called TIMELINE & ROADMAP should document what each little piece of the compiler is /for/

[03:59] * sorear has solved the named character classes issue

[04:00] <pmichaud> sorear: then what would we do with "compiler overview.pod"?   ;-)

[04:00] <pmichaud> arguably ROADMAP should be "development roadmap", yes.

[04:00] <lue> .oO(spaces are still a no-no in file names, IMO. It messes up my use of the command line. :) )

[04:01] <pmichaud> just too lazy to type underscore at the moment.

[04:01] <lue> or, it could be call NYI :)

[04:02] <lue> "Hmm, what to do on rakudo today? Oh! I know, let's check NYI!"

[04:02] <pmichaud> it's more like WWTFIWBI

[04:02] <pmichaud> ("when will the feature I want be implemented?")

[04:03] <lue> WINIR — What Is Not In Rakudo

[04:06] <lue> rakudo: say ord("_") - ord(" ")

[04:06] <p6eval> rakudo cfbeb5: OUTPUT«63␤»

[04:07] <sorear> What are the valid forms of Unicode character property test in Perl 6?

[04:07] <pmichaud> See S05.

[04:07] <sorear> yes, I asked after reading that and being confused

[04:08] <pmichaud> ah.

[04:08] <pmichaud> I'd have to re-read to refresh my memory... just a sec

[04:09] <TimToady> S05:1848

[04:09] <pmichaud> so, looks like things like  isLu, islt, etc are the standard ones

[04:09] <pmichaud> then there are some shortcut ones, like <alpha> and <digit>

[04:09] <sorear> Where is the whole list?

[04:09] <lue> Is there anywhere I can find out what languages you can currently get come from?

[04:09] <TimToady> the Unicode Consortium keeps changing the list :)

[04:09] <pmichaud> I went by the tests in t/spec/S05 to determine a list :)

[04:09] <sorear> My current wild goose chase currently has me at perluniprops(3), but it's not clear what the Perl 6 syntax for Age: 3.1 is

[04:12] <TimToady> P5 appears to use \p{age=3.0}

[04:13] <TimToady> so probably ends up with something smartmatchy, like <age(v3.0)>

[04:14] <TimToady> this is lookin in lib/unicore/To/DAge.txt from the 5.12 dist

[04:14] <sorear> perhaps in trying to implement all Unicode properties in the LTM engine at the same time I am getting slightly ahead of myself.

[04:14] <TimToady> perhaps

[04:14] <TimToady> but I'd certainly be tempted to hook in anything that P5 can do :)

[04:14] <TimToady> even if you have to translate all the tables to P6

[04:15] <sorear> I'll do that.  Eventually.

[04:15] <TimToady> someone should write a mktables that just spits out p6 instead of p5 :)

[04:15] <sorear> I wonder what the minimum set I need for STD.pm6 is

[04:15] <sorear> <alpha>, definititely

[04:16] <TimToady> we don't use very many directly, except those that have methods in Cursor

[04:16] <sorear> [_[:alpha:]\pL] # what.

[04:16] <TimToady> <[_]+alpha+isL> in p6ese

[04:17] <TimToady> er, hmm

[04:17] <sorear> \w \s \d we also use

[04:17] <TimToady> I see the problem :)

[04:17] <sorear> I'm mostly just suprised that [:alpha:]\pL isn't redundant.

[04:18] <TimToady> that's because it's trying to get posix's def of alpha in there too, I think...

[04:18] * snarkyboojum just wrote a very very inefficient pure Perl6 MIME base64 encoding thing

[04:18] <TimToady> or perhaps it was a microoptimization for TRE

[04:18] <snarkyboojum> when is pack/unpack slated for implementation?

[04:19] <TimToady> I don't remember why I had both of those in there, except I vaguely recall TRE flakiness

[04:20] <sorear> What's the most efficient way to write $foo =~ /\pL/ in Perl5?

[04:20] *** patspam left
[04:21] <lue> What programming languages can I currently use code from?

[04:21] <TimToady> I don't think you can have direct access to the data structures used by \pL, if that's what you're asking

[04:22] <snarkyboojum> lue: are you asking about language interop on parrot?

[04:22] <TimToady> but if you want to pull in the bitmap and lookup the ord yourself, you can

[04:22] *** alester left
[04:23] <sorear> How would I pull in the bitmap?

[04:23] <TimToady> if you say do 'unicore/Name.pl' you get the output of Name.pl

[04:24] <sorear> oh hey!  this "unicore/" thing is shiny

[04:24] * sorear looks at the files in it

[04:24] <sorear> oh, *that*'s what mktables is

[04:24] <lue> as in, importing Qt4 from C (for example)

[04:25] <sorear> Why is mktables 14 ksloc?

[04:25] <snarkyboojum> can anyone familiar with Q:PIR help with this breakage/misuse http://gist.github.com/438641? :)

[04:26] <snarkyboojum> lue: I don't understand what you mean by that, but that's probably just me

[04:27] <lue> rakudo: use libc:from<C>

[04:27] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤"load_language" couldn't find a compiler module for the language 'C'␤»

[04:30] <lue> like that.

[04:30] <TimToady> mktables has grown considerably since I first wrote it...

[04:30] <TimToady> but then, so has Unicode

[04:30] <snarkyboojum> lue: ah :) now I can honestly say I don't know :)

[04:31] <lue> It allows you to use libraries from anywhere.

[04:32] <snarkyboojum> doesn't :from<perl5> work to some extent? :)

[04:32] <lue> rakudo: use numpy:from<Python>

[04:32] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤"load_language" couldn't find a compiler module for the language 'Python'␤»

[04:32] <sorear> TimToady: I just don't like the idea of porting 14,000 lines of code :(

[04:33] <TimToady> don't, just run the resulting .pl files

[04:33] <snarkyboojum> lue: I guess the ppl who know are too busy

[04:34] <sorear> so apparently Perl parses unicore/lib/Gc/L.pl every run

[04:34] * snarkyboojum mumbles into his beard

[04:36] <TimToady> I suspect it cheats if it sees only ascii

[04:36] *** simcop2387 left
[04:49] <sorear> *shakes fist*

[04:50] <sorear> utf8::SWASHGET has been rewritten in C and is no longer accessible from Perl-space except through the regex engine

[04:50] *** simcop2387 joined
[04:51] <TimToady> swashes are very utf-8-centric; I wouldn't steal them for p6

[05:00] *** c1sung joined
[05:01] <sorear> what do you mean?

[05:01] <sorear> oh I see

[05:01] *** ash___ left
[05:02] <lue> afk and goodnight

[05:09] <sorear> user-defined unicode properties!?!?

[05:13] *** kaare joined
[05:14] *** kaare is now known as Guest50632

[05:26] *** redicaps joined
[05:35] *** Visitor99 joined
[05:37] *** snarkyboojum left
[05:39] *** orafu left
[05:41] *** orafu joined
[05:47] *** snarkyboojum joined
[05:49] <Visitor99> hi again...

[05:50] <Visitor99> is there a way i can write this line shorter? :          when ($_ mod 2 == 0) { ... }

[05:50] <sorear> when * !% 2

[05:50] <sorear> er

[05:50] <sorear> when !mod 2

[05:50] <sorear> * !mod 2

[05:51] <hejki> when not $_ % 2 { .. } :)

[05:52] <diakopter> std: when !%2 {}

[05:52] <p6eval> std 31260: OUTPUT«ok 00:01 105m␤»

[05:52] <Visitor99> and this?            when ($_ mod 2 == 3) { ... } when ($_ mod 2 == 5) { ... } 

[05:53] <Visitor99> (the "mod 2 == 0" was not a very good example)

[05:53] <diakopter> std: when %2==3 {}

[05:53] <p6eval> std 31260: OUTPUT«ok 00:01 105m␤»

[05:53] <diakopter> I guess

[05:55] <sorear> when ($_ mod 2 == 3) can also be written when False 

[05:55] <sorear> it's more efficient, too

[05:59] <diakopter> explain 'when False'?

[06:00] <diakopter> I mean, I'm giving you the benefit of the doubt that you're not being pedantic (read: distastefully unhelpful) about operator precedence

[06:01] *** ggoebel left
[06:01] <pmichaud> I'm pretty sure that  %_ mod 2 can never == 3  :-)

[06:01] <pmichaud> so it's always false

[06:01] <pmichaud> or, if precedence is the other way, then   % mod 0 is ... well.

[06:02] <diakopter> er

[06:03] <diakopter> that wasn't the question

[06:03] <pmichaud> ah.

[06:03] <diakopter> it was always $_

[06:05] *** masak joined
[06:05] <masak> oh hai, #perl6

[06:05] <phenny> masak: 14 Jun 20:35Z <moritz_> ask masak if he thinks http://moritz.faui2k3.org/tmp/tryrakudo.svg looks like a sane structure for try.rakudo.org

[06:05] <diakopter> grrrrrrrrr

[06:05] <pmichaud> masak: o/

[06:05] <masak> moritz_: yes, I think it looks sane.

[06:06] <ciphertext> snarkyboojum: if you're still wondering, the problem with your Base64 program is that the namespace should be ['parrot'; 'MIME'; 'Base64'] instead of just ['parrot'; 'MIME']

[06:07] <masak> moritz_: would stage one be getting something like that to work, but entirely without stylesheets? then one could invite a weekly challengee to do the styiling.

[06:07] <snarkyboojum> ciphertext: cheers - will try it

[06:09] <sorear> diakopter: X mod 2 can never be 3, or 5

[06:10] *** gfx joined
[06:14] * sorear has an efficient-ish algorithm for solving SAT/TAUT on Boolean expressions of Unicode properties

[06:15] *** Su-Shee joined
[06:17] *** uniejo joined
[06:17] *** JimmyZ left
[06:18] *** am0c joined
[06:18] <diakopter> heh; I knew that... someday.

[06:18] <diakopter> ago

[06:19] <snarkyboojum> ciphertext: lovely :) thanks for picking that up. works a treat now

[06:19] *** plobsing left
[06:20] *** diakopter left
[06:20] <ciphertext> snarkyboojum: it gave me a good excuse to dive into learning a little parrot, which i've been meaning to do

[06:20] <snarkyboojum> ciphertext: :)

[06:21] <snarkyboojum> ciphertext++ even

[06:22] <Visitor99> hehe yes i knew but was in part to focus on the $ part... the code i was writing was about numbers divisible by 2 or 3 or 5

[06:24] <Visitor99> rakudo: for (4,5,15,20,35) {.say; when $_ mod any(2,3,5) {' div by 2, 3 or 5'.say} };

[06:24] <p6eval> rakudo cfbeb5: OUTPUT«4␤ div by 2, 3 or 5␤5␤15␤20␤35␤»

[06:25] <snarkyboojum> ciphertext: http://github.com/snarkyboojum/Perl6-MIME-Base64 - there you go 

[06:25] <Visitor99> rakudo: for (4,5,15,20,35) {.say; when $_ mod 2|3|5) {' div by 2, 3 or 5'.say} };

[06:25] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤Missing block at line 11, near ") {' div b"␤»

[06:25] <Visitor99> rakudo: for (4,5,15,20,35) {.say; when $_ mod 2|3|5 {' div by 2, 3 or 5'.say} };

[06:25] <p6eval> rakudo cfbeb5: OUTPUT«4␤5␤ div by 2, 3 or 5␤15␤20␤35␤»

[06:28] <cono> rakudo: for (4,5,15,20,35) { .say if $_ mod 2|3|5 }

[06:28] <p6eval> rakudo cfbeb5: OUTPUT«4␤5␤15␤20␤35␤»

[06:29] <pmichaud> \o/   list branch is now passing all of S02-builtin_data_types

[06:29] <cono> yahoo

[06:29] <Visitor99> :D cool

[06:30] <sorear> !!!

[06:31] <Visitor99> rakudo: for (4,5,15,20,35) { .say if $_ mod 2|3 }

[06:31] <p6eval> rakudo cfbeb5: OUTPUT«4␤5␤15␤20␤35␤»

[06:33] <pmichaud> (well, except for the tests we marked as todo/skip :-)

[06:33] <cono> todo in *++ :D

[06:36] <Visitor99> rakudo: for (4,7,5,15,20,35) { if any($_ mod 2,$_ mod 3,$_ mod 5)==0 {$_.say} }

[06:36] <p6eval> rakudo cfbeb5: OUTPUT«4␤5␤15␤20␤35␤»

[06:36] <masak> someone has been to something called #yr2010, and seems pleased with Rakudo and Perl 6: http://twitter.com/mmcleric/status/16178658081

[06:37] <pmichaud> perhaps "yapc russia"?

[06:37] <pmichaud> it was this past weekend

[06:37] <masak> ah. yes.

[06:38] <masak> this gentletwitterer, OTOH, was underwhelmed: http://twitter.com/alecthegeek/status/16199980776

[06:39] *** justatheory left
[06:40] <pmichaud> seems about right.

[06:43] <Visitor99> rakudo: for (4,7,5,15,20,35) { if $_ mod any(2,3,5)~~0 {$_.say} }

[06:43] <p6eval> rakudo cfbeb5: OUTPUT«4␤5␤15␤20␤35␤»

[06:44] <masak> snarkyboojum: (re pack/unpack) -- I've been wanting those two functions for over a year now. the good news is they're part of my GSoC schedule, so I'll eventually get to them :) we suspect they have more to do with Buf than with Str.

[06:45] <Visitor99> is there any way to know which of the numbers in the 'any' junction was chosen? i would like to print "$_ is divisible by (and then the corresponding divisor)"

[06:45] *** redicaps left
[06:45] <pmichaud> Visitor99: no

[06:47] <cono> rakudo: {.say} for <1 2 3>

[06:47] <p6eval> rakudo cfbeb5:  ( no output )

[06:47] <cono> rakudo: for <1 2 3> {.say}

[06:47] <p6eval> rakudo cfbeb5: OUTPUT«1␤2␤3␤»

[06:48] <cono> "for" lose it's reverse form?

[06:48] <pmichaud> no, but you just told it to create a closure

[06:48] <pmichaud> it never executes the closure

[06:48] <pmichaud> rakudo:  .say for <1 2 3>

[06:48] <p6eval> rakudo cfbeb5: OUTPUT«1␤2␤3␤»

[06:48] <cono> ah )

[06:49] <cono> thanks

[06:49] <pmichaud> with the curlies, it's not an immediate block, so it doesn't get executed.

[06:49] <moritz_> rakudo: for 4,7,5,15,20,35 -> $n { for 1, 2, 3 -> { if $n !% $_ {say "$n is divisible by $_" ; last } } } 

[06:49] <p6eval> rakudo cfbeb5: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in main program body at line 11:/tmp/Kl44tU9BTS␤»

[06:49] <moritz_> rakudo: for 4,7,5,15,20,35 -> $n { for 1, 2, 3  { if $n !% $_ {say "$n is divisible by $_" ; last } } } 

[06:49] <p6eval> rakudo cfbeb5: OUTPUT«4 is divisible by 1␤7 is divisible by 1␤5 is divisible by 1␤15 is divisible by 1␤20 is divisible by 1␤35 is divisible by 1␤»

[06:50] <moritz_> rakudo: for 4,7,5,15,20,35 -> $n { for 2, 3, 5  { if $n !% $_ {say "$n is divisible by $_" ; last } } } 

[06:50] <p6eval> rakudo cfbeb5: OUTPUT«4 is divisible by 2␤5 is divisible by 5␤15 is divisible by 3␤20 is divisible by 2␤35 is divisible by 5␤»

[06:50] <cono> !% it means div produce 0? :)

[06:51] <cono> mod*

[06:51] <masak> pmichaud: how come { .say } is an immediate block on its own, but not with a statement_modifier:<for> on it?

[06:51] <moritz_> a !% b is the same as !(a % b)

[06:51] <cono> wow

[06:51] <pmichaud> iiuc, immediate blocks don't get statement modifiers.  It could be a rakudo bug, though.

[06:52] <Visitor99> rakudo: for (4,7,5,15,20,35) -> $n { given (2|3|5) { if $n mod $_ ==0 {say "$n is divisible by $_"} } }

[06:52] <p6eval> rakudo cfbeb5: OUTPUT«4 is divisible by any(2, 3, 5)␤5 is divisible by any(2, 3, 5)␤15 is divisible by any(2, 3, 5)␤20 is divisible by any(2, 3, 5)␤35 is divisible by any(2, 3, 5)␤»

[06:52] *** parduncia joined
[06:52] <masak> pmichaud: no, I recall a test addressing this with a p6l link attached to it.

[06:52] <masak> so it's probably right.

[06:52] <masak> and I should go read the p6l thread in question. :)

[06:54] <masak> huh. I'm wrong. :/

[06:54] *** Trashlord joined
[06:54] <masak> we have Rakudo todo tests saying the closure should be executed.

[06:54] <pmichaud> yeah, istr that also

[06:54] <cono> rakudo: ([/] 1,2,3).perl.say

[06:54] <p6eval> rakudo cfbeb5: OUTPUT«1/6␤»

[06:54] * masak makes a svn blame to see if he was at least right once :)

[06:56] <masak> "r29799 | pmichaud | 2010-02-22 16:44:52 +0100 (Mon, 22 Feb 2010) | 6 lines [t/spec]:  Update testing in for.t of statement_modifier:for on blocks. The original tests were based on a p6l comment posted by Larry in September 2006, but later changes to S04 (May 2007) indicate that statement modifiers should execute explicit closures. This commit updates the tests to be consistent with the synopses."

[06:56] <masak>  

[06:56] <pmichaud> ah.

[06:56] <masak> so yes, rakudo-todo.

[06:56] <pmichaud> late February through mid-May is pretty much a blur in my head  :0|

[06:56] <masak> TimToady++ pmichaud++

[06:57] <masak> pmichaud: it would be.

[06:58] <masak> pmichaud: it's very nice to have you back, and hope that things are well/improving on the home front.

[06:58] <cono> Maybe for perl Configure.pl --gen-parrot need to make svnclobber in parrot? Coz I always file to make parrot :( I remove parrot folder every time when parrot depending revision changed

[06:58] <pmichaud> masak: the do appear to be.

[06:58] <masak> \o/

[06:58] <pmichaud> *they

[06:58] <cono> s/file/fail/

[06:59] <pmichaud> we need to change the ordering of the "make realclean" step in the parrot dir.

[06:59] <pmichaud> need to do "make realclean" before doing the "svn co"

[06:59] <cono> realclean are not help time to time

[06:59] <moritz_> cono: svnclobber is very impolite to those who have patch files in their parrot/ dir

[06:59] <cono> dunno why

[06:59] <cono> ic

[07:00] <pmichaud> realclean doesn't work across svn commits in the parrot repo, because of changes to the makefile structures

[07:00] * sorear gives in to the urge to split _AUTOLEXgenDFA into several smaller functions despite the fact that Perl5 doesn't have a functional inliner

[07:00] <pmichaud> so, if we realclean before doing the svn update, things should be better.

[07:01] <moritz_> on lists branch:

[07:01] <moritz_> > say sprintf "%04f-%02d-%02d", 2010, 3, 5

[07:01] <moritz_>  

[07:02] <moritz_> printf also doesn't produce any output

[07:02] <pmichaud> just fixed sprintf locally

[07:02] <moritz_> I seem to have a knack for just investigating the stuff where you're one step ahead of me :-)

[07:03] <pmichaud> fixed in 753e45

[07:03] <pmichaud> (at least for me it was fixed)

[07:03] <pmichaud> well, I'm working from top-down in the spectests, so if you're doing the same, you're likely to be seeing the same things I am :)

[07:03] <moritz_> does the Date.t file pass with it?

[07:03] <pmichaud> haven't tried.

[07:03] <moritz_> that's where I noticed the failure

[07:03] <moritz_> (not top down!)

[07:04] <pmichaud> anyway, let me know if it's still failing in 753e45  :)

[07:04] <moritz_> I suspected as much, and randomly picked something from the middle

[07:04] <masak> that 'say sprintf' pattern is cute. I use it sometimes.

[07:05] <masak> someone once suggested we have a 'sayf' shortcut. didn't go over well, I think. :P

[07:05] <pmichaud> oh, part of the sprintf fix is uncommitted

[07:06] <pmichaud> one second.

[07:06] <Visitor99> rakudo: for (4,7,5,15,20,35) -> $n { given none(2,3,5) { if $n mod $_ ==0 {say "$n is not divisible by $_"} } }

[07:06] <p6eval> rakudo cfbeb5: OUTPUT«7 is not divisible by none(2, 3, 5)␤»

[07:06] <pmichaud> pushed 68354d6

[07:07] *** Visitor99 left
[07:08] <masak> Visitor99: cool, but confusing. maybe use all(2,3,5) and != 0 instead.

[07:10] <masak> more from the underwhelmed gentletwitterer: "@dryfter demonstrated Perl6, plus some Go and Scala. We had a disappointing time with Perl6. Some Notes on Perl 6 came from it." http://perl.net.au/wiki/Melbourne_Perl_Mongers/Meeting_History_2010

[07:11] <masak> aww, they didn't know about fakedbi! :(

[07:11] * masak tells them

[07:11] *** am0c left
[07:16] <pmichaud> for anyone looking to help with the 'list' branch, the S03 tests are probably good candidates now

[07:17] <masak> today is Parrot release day, no?

[07:17] <pmichaud> yes, unfortunately.

[07:17] <moritz_> yes

[07:17] <moritz_> range.rakudo seems to loop

[07:17] <masak> why 'unfortunately'?

[07:17] <pmichaud> I'm not likely to have closure fixes in place before the Parrot release.

[07:18] <pmichaud> (we can work around it, but I'd rather have them "in Parrot" )

[07:18] <masak> pmichaud: I agree with your estimate that list semantics is more important than closures.

[07:18] <moritz_> same for regex fixes

[07:18] <cono> What objects have cmp && eqv methods?

[07:18] <masak> pmichaud: at least the closures stuff has a very simple workaround.

[07:18] <pmichaud> and I think we will have closure done soonish

[07:19] <masak> cono: all of them, in some sense.

[07:19] <pmichaud> just need to get lists straightened around -- there's a lot to the refactor (as can be seen by the number of commits needed to fix it all up :-)

[07:20] <moritz_> spectest looks much better now

[07:20] <pmichaud> it's also nice that I've been able to delete large sections of redundant code :)

[07:20] <cono> noting found: grep "method cmp" src/core/*.pm

[07:21] <pmichaud> I think it's an operator.

[07:21] <pmichaud> sub infix:<cmp>

[07:21] <cono> TODO said: * tests for cmp() and eqv() methods of objects

[07:23] <pmichaud> yeah, spectest does look a lot better

[07:23] <pmichaud> (now running a full spectest for the first time in... well, days)

[07:24] <pmichaud> yes, does appear to be an infloop in range.t

[07:24] <pmichaud> looking.

[07:25] <masak> rakudo: say 1..4 cmp 3..5

[07:25] <p6eval> rakudo cfbeb5: OUTPUT«-1012345␤»

[07:25] <masak> rakudo: say (1..4) cmp (3..5)

[07:25] <p6eval> rakudo cfbeb5: OUTPUT«-1␤»

[07:25] <masak> I wonder how it figures that.

[07:25] <pmichaud> I think that if cmp isn't defined for a type, it defaults to string comparison.

[07:26] <pmichaud> rakudo:  say (3..5) cmp (11..14)

[07:26] <p6eval> rakudo cfbeb5: OUTPUT«1␤»

[07:27] *** JimmyZ joined
[07:28] <pmichaud> ah, yes, the RangeIter doesn't know about string comparisons.  That needs to be ported from master into the new RangeIter code.

[07:29] <pmichaud> I'll skip the test for now, but perhaps someone can work on it a bit.

[07:31] <pugssvn> r31261 | pmichaud++ | [t/spec]:  Fudge and update some tests for the rakudo 'list' branch. 

[07:32] <pmichaud> btw, for the #phasers meeting today, I've started putting my review comments and questions into  docs/review-notes.txt  in the 'list' branch

[07:32] <pmichaud> so if people want to prepare some answers or think about them a bit, that's a good place to start :)

[07:33] <cono> can I create S03-operators/cmp.t ?

[07:34] <pmichaud> cono: yes, please do!

[07:34] <sorear> anyone with a pugsbit can add tests

[07:35] <pmichaud> there might be some cmp tests already -- so might be worth checking for that.

[07:35] <pmichaud> if there are, they can be refactored.

[07:35] <sorear> pugsbits are handed out freeely to anyone who can pass a turing test, which we secretly administer to all channel joiners

[07:36] <cono> :)

[07:40] <pugssvn> r31262 | sorear++ | [dfa/Cursor] Refactor _AUTOLEXgenDFA and design the NFA representation for named character classes 

[07:41] *** whiteknight joined
[07:43] *** JimmyZ left
[07:44] <pmichaud> ah, the S32 tests are likely candidates for low hanging fruit also

[07:46] *** meppel left
[07:49] <whiteknight> pmichaud? you're up early today

[07:49] <whiteknight> ...or up late

[07:49] <masak> rakudo: role A { method foo { say "A" } }; role B { method foo { say "B" } }; class C does A does B {}

[07:49] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤Method 'foo' collides and a resolution must be provided by the class␤»

[07:49] <masak> would it be possible for the error message to specify which class?

[07:49] <masak> also perhaps line number and file?

[07:50] <arnsholt> When's takadonet usually around?

[07:51] <masak> arnsholt: from 15-ish and onwards.

[07:51] <masak> he's on New World time :)

[07:51] <masak> rakudo: our &s = &say; role A { method foo { s "A" } }; role B { method foo { s "B" } }; class C does A does B { method foo { self.A::foo } }; C.new.foo

[07:51] <p6eval> rakudo cfbeb5: OUTPUT«A␤»

[07:51] <masak> \o/

[07:51] <pmichaud> whiteknight: up late

[07:51] <pmichaud> about to head to sleep

[07:52] <pmichaud> been working on the rakudo list refactor -- want to try to get it in before this month's release

[07:52] <pmichaud> (may hold the release a day or two -- need to discuss that at #phasers today)

[07:53] <arnsholt> masak: Excellent. I'll keep my eyes open around then, thanks

[08:00] *** lestrrat is now known as lest_away

[08:01] *** sdo_ joined
[08:02] *** Irwin left
[08:03] *** jferrero joined
[08:03] <pmichaud> afk, sleep

[08:05] *** whiteknight left
[08:07] <cono> rakudo: ("привет").perl.say

[08:07] <p6eval> rakudo cfbeb5: OUTPUT«"привет"␤»

[08:07] *** rob joined
[08:07] *** gfx left
[08:08] <masak> rakudo: ("привет").uc.say

[08:08] <p6eval> rakudo cfbeb5: OUTPUT«ПРИВЕТ␤»

[08:09] <cono> masak: in my console something wrong with this :(

[08:09] <masak> rakudo: "привет".subst('и', 'е').subst('т', 'д').uc.say

[08:10] <p6eval> rakudo cfbeb5: OUTPUT«ПРЕВЕД␤»

[08:10] <masak> cono: then you probably don't have uci installed.

[08:10] <masak> cono: it tells you during Parrot config whether uci is found or not.

[08:11] <moritz_> icu, actually

[08:11] <cono> hah

[08:11] <cono> when I try perl6 -e, it say to me: no ICU lib loaded

[08:12] <cono> but when I'm in interactive mode, it prints like: perl -le 'my $c ="привет"; utf8::encode($c); print $c'

[08:13] <sorear> <3 unicode

[08:13] <cono> :D

[08:14] *** varun joined
[08:15] <moritz_> I do't think the REPL ever worked well with Unicode

[08:16] <cono> repl?

[08:17] <moritz_> the interactive Read-Evaluate-Print-Loop

[08:17] <cono> ic

[08:21] <pugssvn> r31263 | sorear++ | [dfa/Cursor] Switch internal NFA processing to the class-aware form 

[08:21] <sorear> I predict dfa/Cursor will be mergable by this time tomorrow

[08:25] * moritz_ likes

[08:25] *** synth left
[08:28] *** szabgabx left
[08:30] <cono> ICU installed, but in repl still have bug :(

[08:30] <cono> perl6 -e works fine

[08:30] *** dakkar joined
[08:33] <moritz_> 10:15 <@moritz_> I do't think the REPL ever worked well with Unicode

[08:34] <cono> ah :)

[08:34] <cono> my bEd :)

[08:34] *** wallberg joined
[08:34] <sorear> What Unicode properties are equivalent to \w?

[08:36] <moritz_> I think it's Letter, Digit or _

[08:39] <masak> ah! the 'w' in \w means 'word character'. that's how _ gets to be in there.

[08:40] <masak> despite what has sometimes been said on the channel, _ is *not* alphanumeric :)

[08:40] <moritz_> rakudo: say '_' ~~ /<.alpha>/

[08:40] <p6eval> rakudo cfbeb5: OUTPUT«_␤»

[08:41] <moritz_> in Perl 6 it is.

[08:42] <masak> oh. and here I thought I had come upon a grain of sense.

[08:47] *** dakkar left
[08:55] <mberends> that one has bitten me a few times as well :-/

[08:57] *** rgrau` left
[08:57] *** rgrau joined
[09:00] *** dakkar joined
[09:03] <sorear> How does case insensitive matching work in perl 6?

[09:03] <sorear> e.g. "ß" ~~ m:i/SS/

[09:03] <masak> sorear: that's the syntax, so I assume you're asking about the semantics.

[09:04] <masak> oh wait, that example is tricky :)

[09:04] <masak> I would be surprised if Perl 6 is spec'd to handle that.

[09:04] <sorear> yes.  semantics, and dark corners thereof

[09:04] <sorear> yes, S05 says exactly nothing on the subject

[09:04] <moritz_> rakudo: say "ß" ~~ /:i SS/

[09:04] <p6eval> rakudo cfbeb5: OUTPUT«␤»

[09:04] <sorear> other than "ignores case distinctions"

[09:04] <moritz_> rakudo: say uc "ß"

[09:05] <p6eval> rakudo cfbeb5: OUTPUT«SS␤»

[09:05] <masak> o.O

[09:05] <masak> German is strange.

[09:05] <moritz_> masak: want to submit a bug report about inconsistency?

[09:05] <moritz_> it sure is.

[09:05] * masak submits rakudobug

[09:05] <moritz_> if Perl 6 isn't able to handle Unicode properly, which language is?

[09:05] <masak> moritz_: you sound like someone with True Believer Syndrome :P

[09:06] <Trashlord> how's it going

[09:06] <moritz_> I'm a True Believer

[09:06] <masak> moritz_: :D

[09:06] <cono> perl5 :)

[09:06] <cono> perl5 awesome in unicode

[09:06] * moritz_ coughs

[09:06] <masak> except when it isn't.

[09:08] <moritz_> there's much Unicode-stuff that works very well in perl 5

[09:08] <moritz_> but there are myriads of dark corners too

[09:08] <arnsholt> There are a couple of dark corners in Unicode as well

[09:08] <moritz_> though it has improved in the last two major releases

[09:09] <masak> "major" being 5.10 and 5.12 ? :)

[09:09] <moritz_> yes

[09:09] <masak> also known as "minor"? :)

[09:09] *** lest_away is now known as lestrrat

[09:09] <moritz_> masak: they are major releases of Perl 5

[09:09] <moritz_> masak: and minor releases of Perl

[09:09] <moritz_> :-)

[09:10] <masak> any sufficiently advanced rationalization is indistinguishable from sophistry... :P

[09:10] * moritz_ chuckles

[09:17] <pugssvn> r31264 | cono++ | * Add testing of cmp operator 

[09:19] *** am0c joined
[09:19] <masak> I'm thking of adding auth/ver support to pls core.

[09:20] <cono> btw, is that a bug? (v5) perl -e'\sort{eval$;}%!' && echo "exit 0"

[09:21] <masak> I think if we're to introduce auth/ver for realz, we have to change the structure of projects.list.

[09:22] <mberends> go for it, sooner rather than later

[09:22] <masak> let's say there are two modules A in the ecosystem. we ignore the distinction between project and module for now.

[09:23] <masak> there's A:auth<foo> and A:auth<bar>. which one do we pick?

[09:23] <moritz_> the one the user has a preference for

[09:23] <masak> mberends: did you ever introduce auth/ver support into proto? I haven't checked.

[09:23] <moritz_> if such a thing doesn't exist, BOOM

[09:23] <mberends> yes, that was a simplification we decided on in Copenhagen. Where it's truly ambiguous, flag an error.

[09:23] <masak> ok.

[09:24] <mberends> masak: no, proto didn't understand auth, but did try to upgrade vers

[09:24] <moritz_> where "preference" can be "explicit config option" or maybe "used this module from one authority before"

[09:24] <moritz_> or... just install both :-)

[09:24] <moritz_> (j/k)

[09:26] <mberends> that's making lots of extra work for the implementer to satisfy a rare corner case. keep it simple, rather.

[09:26] <masak> as to "explicit config option", the syntax in deps.proto will surely withstand an extention to allow for auths.

[09:26] <moritz_> probably preferable

[09:26] <mberends> one auth at a time would be great anyway

[09:26] <masak> that said, probably better to call it deps.pls :)

[09:27] <moritz_> deps.installthemforme.pls

[09:32] * masak is sorely tempted...

[09:37] <masak> so... (social failure mode time again) ...if I have an arch-enemy whose life I want to complicate, all I need to do is to create projects with identical names to that person's projects, and none of his projects will install without human intervention?

[09:39] <masak> even better, all the upstram projects which used those projects will also fail to install until someone clearly specifies the auth in the deps.pls file.

[09:39] <masak> very much havoc with relatively little effort.

[09:39] <sorear> imho auth should be required.

[09:40] <masak> on the project level, maybe it should.

[09:40] <sorear> with an error message that tells you the correct auth, if it's unambiguous among installed modules

[09:40] <masak> that's another error message that'd hit innocents...

[09:41] <sorear> on a file level, we don't need auth; Perl 6 should have a concept of packaging, and all modules in an installed package should know what auth/ver the package depends on

[09:42] <masak> interesting idea to prefer an installed module if it's unique.

[09:44] <buu> perlbot: placeholders is 

[09:44] <buu> perlbot: placeholders is You want placeholders: http://www.geekuprising.com/create_better_perl_and_sql_with_placeholders

[09:44] <buu> er

[09:44] <sorear> if you're familiar with .NET's assembly mechanism, that's what I'm talking about; somebody at Microsoft stole my idea

[09:45] <sorear> buubot, seen masak

[09:45] <buubot> sorear: I last saw masak saying "my @a = (1, 2, 3); my $i = 4; for my $elem (@a) { print $elem, "\n"; push @a, ++$i if $elem % 2 }" at Fri Jun 11 13:13:25 2010 Z.      

[09:45] <snarkyboojum> masak: regarding pack/unpack - good stuff :)

[09:45] <sorear> buu: What's wrong with seen?

[09:45] <buu> sorear: It only records when people actually talk to the bot.

[09:45] <buu> Due to a somewhat complicated design flaw, plugins like seen only get a chance to activate if people talk directly to the bot.

[09:45] <buu> Hrm.

[09:46] <sorear> aha.

[09:47] <masak> buu: I'm talking to you now!

[09:47] <masak> oops.

[09:47] <masak> buubot: I'm talking to you now!

[09:47] <buubot> masak: Couldn't match input.

[09:47] <buu> Haha

[09:47] <masak> keep mixing the two of you up :)

[09:48] <masak> buutbot: Couldn't match input?

[09:48] <masak> buubot: Couldn't match input?

[09:48] <buubot> masak: Couldn't match input.

[09:48] * masak though so

[09:48] <masak> buubot: Why did the chicken cross the road?

[09:48] <buubot> masak: Couldn't match input.

[09:49] <masak> lunch &

[09:51] *** azert0x joined
[10:16] <cono> rakudo: my @q = <1 2 3>; my @z = 1, 2, 3; (@q cmp @z).say

[10:16] <p6eval> rakudo cfbeb5: OUTPUT«0␤»

[10:16] <cono> is that a bug?

[10:17] <arnsholt> Don't think so

[10:17] <cono> rakudo: my @q = <1 2 3>; @q.map({.WHAT}).perl.say

[10:17] <p6eval> rakudo cfbeb5: OUTPUT«(Str, Str, Str)␤»

[10:17] <cono> rakudo: my @q = 1, 2, 3; @q.map({.WHAT}).perl.say

[10:17] <p6eval> rakudo cfbeb5: OUTPUT«(Int, Int, Int)␤»

[10:17] <arnsholt> rakudo: <1 2 3>.perl.say; (1, 2,3).perl.say

[10:17] <p6eval> rakudo cfbeb5: OUTPUT«("1", "2", "3")␤(1, 2, 3)␤»

[10:17] <cono> different types

[10:17] <arnsholt> Yup

[10:18] <arnsholt> Also, I'm not sure how cmp is specced to work on arrays

[10:18] <cono> rakudo: my @q = <01 2 3>; my @z = 01, 2, 3; (@q cmp @z).say

[10:18] <p6eval> rakudo cfbeb5: OUTPUT«-1␤»

[10:19] <pugssvn> r31265 | sorear++ | [dfa/Cursor] Implement translation from NFA to DFA in the presence of named character classes 

[10:30] <pugssvn> r31266 | sorear++ | [dfa/Cursor] Extend the DFA execution engine to support DFAs with Unicode property decision trees 

[10:30] <sorear> OK, I think those two commits cover the last of the major technical issues

[10:30] * sorear sleep

[10:39] *** jhuni left
[10:42] <colomon> rakudo: my @q = <1 2 3>; my @z = 1, 2, 3, 4; (@q cmp @z).say

[10:42] <p6eval> rakudo cfbeb5: OUTPUT«-1␤»

[10:44] <colomon> oh, if there is no special handling for a type (like there is for numbers), cmp converts both its arguments to Str and compares those.  I believe that's what's happening here for arrays.

[10:45] *** Schwern left
[10:46] <colomon> TimToady: Rakudo only defines basic arithmetic and a few conversion functions for Int, everything else you saw on that list was picked up from Real or maybe even Numeric.

[10:49] *** mjk joined
[10:50] *** tadzik joined
[10:59] *** jhuni joined
[11:02] *** lestrrat is now known as lest_away

[11:04] *** gawker2 joined
[11:08] *** paroxyzm joined
[11:08] *** paroxyzm left
[11:08] *** paroxyzm_ joined
[11:20] *** azert0x left
[11:22] *** azert0x joined
[11:32] <colomon> pmichaud: http://gist.github.com/438996 -- Seems like Ranges in [ ] don't do the right thing yet.  But what the heck is the series doing there at the end?

[11:33] <colomon> pmichaud: (trying to figure out the best way to implement .batch again, to get zip.t and presumably a number of other test files to run again)

[11:35] <ciphertext> colomon: is that on the list branch?

[11:35] <colomon> ciphertext: yes

[11:36] <ciphertext> ok.  fyi, the weird series behavior is the same on master

[11:36] <ciphertext> rakudo: (1...10)[0...4]

[11:36] <p6eval> rakudo cfbeb5:  ( no output )

[11:36] <ciphertext> rakudo: say (1...10)[0...4]

[11:36] <p6eval> rakudo cfbeb5: OUTPUT«01234␤»

[11:37] <colomon> rakudo: say (1...10)[0,1,2,3,4]

[11:37] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[11:38] <colomon> rakudo: say (1...10)[2...4]

[11:38] <p6eval> rakudo cfbeb5: OUTPUT«Null PMC access in getprop()␤  in 'say' at line 1␤  in 'say' at line 4724:CORE.setting␤  in main program body at line 11:/tmp/2itAeUA6kN␤»

[11:38] * masak submits rakudobug

[11:38] <colomon> ooooo, it's a closure bug, I'll bet.

[11:39] <colomon> rakudo: my @a = 1...10; say @a[0...4]

[11:39] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[11:39] <colomon> closure bug, nothing to see here.

[11:39] <masak> the closure bug usually doesn't result in a Null PMC access.

[11:39] <masak> rakudo: my @a = 1...10; say @a[2...4]

[11:39] <p6eval> rakudo cfbeb5: OUTPUT«345␤»

[11:43] <masak> but yes, seems like it's parallel gather blocks interfering that's the underlying cause.

[11:43] <colomon> I will be unspeakably happy when that bug is eliminated.

[11:43] *** proller left
[11:49] *** arnsholt left
[11:57] <masak> std: module;

[11:57] <p6eval> std 31266: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'module' used at line 1␤Check failed␤FAILED 00:01 107m␤»

[11:57] <masak> std: class;

[11:57] <p6eval> std 31266: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'class' used at line 1␤Check failed␤FAILED 00:01 104m␤»

[11:57] <masak> S11 (strangely) claims those should work.

[11:58] <masak> rakudo: say (v6..*).perl

[11:58] <p6eval> rakudo cfbeb5: OUTPUT«Could not find sub &v6␤  in main program body at line 11:/tmp/Mqj5WHdqxU␤»

[12:00] <takadonet> morning all

[12:00] <masak> takadonet: \o

[12:00] <masak> takadonet: arnsholt was looking for you earlier.

[12:00] <takadonet> masak: he was? do you know what for?

[12:01] <masak> no idea.

[12:01] <takadonet> well I'm here :)

[12:02] <takadonet> is anyone from perl 6 going to feed the troll today? http://use.perl.org/~ank/journal/40396

[12:02] <masak> I've read it. I don't have anything to add.

[12:02] <masak> I liked moritz_++'s comment: "I'm a True Believer" :)

[12:02] *** ggoebel joined
[12:03] <masak> (it wasn't in direct connection to that post, though.)

[12:03] *** Mowah joined
[12:03] <baest> I would like to see some links concerning this: "they simply cannot accept the fact that the whole concept is broken, even after it's been shown to them over and over." 

[12:03] <masak> ank certainly has claimed it over and over.

[12:04] <moritz_> baest: he'd probably link to his previous blog posts

[12:04] <baest> :)

[12:04] <moritz_> baest: which aren't more worth reading than this

[12:04] <masak> it was something to do with operators being akin to prepositions or something.

[12:04] <baest> moritz_: no, I've read them (or at least some of them)

[12:05] <baest> oh well, you win some and some is lost

[12:05] <baest> are

[12:06] <mathw> We don't feed trolls, I thought the policy was hugging?

[12:07] *** hugme joined
[12:07] <masak> hugme! \o/

[12:07] <Su-Shee> takadonet: ah, that troll. :)

[12:07] *** skids joined
[12:07] <Su-Shee> my theory is he's hoping that chromatic does a why and just vanishes. ;)

[12:07] <masak> fat chance :P

[12:08] <Su-Shee> but his children will starve because of perl 6!

[12:08] <takadonet> Su-Shee: been a while since I was called a troll

[12:09] <takadonet> cool

[12:09] <snarkyboojum> I found his website http://www.ank.com.ar/

[12:09] <Su-Shee> takadonet: I didn't call _you_ one but the author of the posting :) 

[12:09] <takadonet> ahh

[12:10] *** foodoo joined
[12:10] <Su-Shee> http://www.ank.com.ar/jade7/ this is funny though :)

[12:11] <masak> except the parts that are more sad than funny.

[12:11] <Su-Shee> ah well he isn't going to bring down perl 6 ;)

[12:12] <mathw> Of course not

[12:12] <Su-Shee> also according to hugme policy it's wise to embrace satire. ;)

[12:12] <mberends> fwiw, I think ank writes in a deliberately offensive way, but there is also quite a lot of truth between the vitriolic parts. We should be careful not to overdose on our Kool-Aid.

[12:13] <masak> aye.

[12:13] <masak> I've also wondered about TheDamian's extreme lack of commenting. :)

[12:13] <moritz_> why should he comment?

[12:13] <snarkyboojum> hehe.. too busy programming Perl6 no doubt :)

[12:14] <masak> moritz_: hm, s/commenting/tests/, then.

[12:14] <mathw> Well yes, Damian's code is pretty much incomprehensible

[12:14] <mathw> But that's not a point against the entire Perl 6 effort

[12:14] <masak> of course not.

[12:14] <mathw> You can write incredibly clever yet completely bizarre code in any language

[12:15] <masak> and some people never proceed from that insight about Perl: "look, you can write *this*! danger, danger!"

[12:15] <mathw> which is just unrealism

[12:15] *** pjcj joined
[12:16] <Su-Shee> ah well let's satisfy the people actually waiting in line for certainf eature to do their projects and let's see what happens then. also, on #perl the bitching about perl 6 subsided recently.

[12:16] <mathw> I've seen Python code that was as hard to figure out as the worst Perl outside of golfing

[12:16] <moritz_> it's been a year since my last "how to contribute to Perl 6" post on perlmonks

[12:16] <tadzik> The first example from Dive Into Python looks to me more cryptic than any Perl I ever wrote

[12:17] <mathw> There was one particularly fun project which had four different classes all called Connection in different modules, passed them between modules freely and always called the parameter 'connection', yet you never knew which *kind* of Connection it was

[12:17] <moritz_> I'd like to keep up the tradition, and write another such node soonish

[12:17] <Su-Shee> who cares what python does? it's our task to develop a good, clean, pretty perl 6 style and promote that. 

[12:17] <mathw> yup

[12:17] <moritz_> any suggestions of what needs to go into it?

[12:17] <mathw> and for my part, I think it involves fairly liberal use of type specifiers

[12:18] <huf> whoa, this ank guy is crazy :D

[12:18] <huf> nice.

[12:18] <cognominal> are Perl 6 critics are an epistemologic proof of existence?  Probably not of the physical critic existence, nor of Perl 6 existence :)

[12:18] <mathw> But that might be my C++ and Haskell bias

[12:18] *** bluescreen joined
[12:19] <masak> cognominal: no, it's more like Ghandi-con 2. :) "then they ridicule you". which counts as progress, I guess.

[12:19] *** bluescreen is now known as Guest16581

[12:19] <Su-Shee> I've read an interesting blogposting today why ruby folks are rather willing to adopt clojure and what this got to do with the writing style of the languages.

[12:19] <masak> or maybe it's stage 3, "then they attack you".

[12:19] <Su-Shee> "ghandi-con" *haha* :)

[12:20] <masak> it's a Slashdot meme. :)

[12:20] <Su-Shee> never really read it. ;)

[12:21] <masak> it's occasionally informative, but mostly a source of extreme geek humour.

[12:21] <cognominal> Masak. Well, Gandhi cited by esr always puts me ill at ease.  There is like a contradictory logic in that utterance.

[12:21] <masak> cognominal: :)

[12:21] <cognominal> You don't advocate guns and cite Gandhi

[12:21] <masak> evidence suggests otherwise :P

[12:23] <cognominal> The world is illogic,  absurd. So no logic whatsowever is a proof of existence. But may be we don't exist.

[12:25] <masak> maybe not. but I've never seen the hypothesis that we don't lead to any important discoveries or insights.

[12:25] <masak> ...medical or engineering advances...

[12:27] <masak> in fact, it seems to imply nothing at all, except an odd view of the universe.

[12:28] *** am0c left
[12:30] *** parduncia left
[12:31] *** am0c joined
[12:33] <masak> the version comparison semantics outlined in S02... is there a way to compare two strings programmatically according to the same rules?

[12:33] <masak> because I think there should be. it would help pls to have access to such a way.

[12:34] *** proller joined
[12:34] *** parduncia joined
[12:34] *** parduncia left
[12:34] <moritz_> who's doing our next release?

[12:35] * masak 

[12:36] <moritz_> ++masak

[12:37] <colomon> more important question is, when is our next release?

[12:37] <masak> Thursday, I think.

[12:37] <moritz_> pmichaud wanted to discuss this today in #phaers, no?

[12:37] <moritz_> *#phasers

[12:38] <colomon> masak: I can't believe we're going to pull in lists and closures by then.\

[12:38] <masak> closures allegedly needed Parrot changes too.

[12:38] <masak> so we might have to slip that one.

[12:38] <colomon> it would be a hackathon of epic proportions.

[12:39] <masak> s/slip/let slip/

[12:39] <colomon> I would vote against releasing R* with that bug.

[12:39] <moritz_> there are a lot of things I'd hate to see in R*

[12:39] <dalek> rakudo: 080700b | moritz++ | build/PARROT_REVISION:

[12:39] <dalek> rakudo: bump PARROT_REVISION to 2.5.0 release

[12:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/080700bfd4716fe960b1c1de8293615d04cee763

[12:40] <moritz_> like, lack of support for backslash escapes in regexes

[12:40] <mathw> I'd hate to see the backtracking through captures bug

[12:40] *** masonkramer joined
[12:40] <moritz_> there you go, we all have our "favorite" bugs

[12:40] <masak> seems we do indeed have something to talk about during the #phasers meeting tonight.

[12:40] <mathw> Well it's my favourite because I need it to fix Form :)

[12:41] <mathw> I'd like Form to be usable with *

[12:41] <mathw> but I don't see a workaround

[12:43] <takadonet> come on lazy list!

[12:44] *** ggoebel left
[12:44] <masak> mathw: don't rely on backtracking :)

[12:44] <colomon> gather / take is used ~30 times in core.  With the closure bug and lazy evaluation, every one of those times is a landmine waiting to explode.  And that's just one particular example of the closure bug.

[12:45] <mathw> masak: I am not re-writing Form's grammar in non-backtracking mode

[12:46] <moritz_> does backtracking into non-capturing subrules with associated action methods work?

[12:46] <mathw> I don't know

[12:49] * masak guesses "no"

[12:52] <pmichaud> good morning

[12:52] *** gawker2 left
[12:52] <masak> morning, pm.

[12:53] <mathw> oh hai pmichaud

[12:53] <mathw> moritz_: if my brain was working I'd bake up a small test case to find out

[12:54] <mathw> and then try to figure out how to make Form's grammar work without capturing, if it worked

[12:54] <colomon> pmichaud: o/

[12:55] <moritz_> rakudo: grammar A { method TOP { ^<.a>* a $ }; token a { a } }; say A.parse('aa')

[12:55] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 11␤»

[12:55] <moritz_> rakudo: grammar A { token TOP { ^<.a>* a $ }; token a { a } }; say A.parse('aa')

[12:55] *** araujo left
[12:55] <p6eval> rakudo cfbeb5: OUTPUT«␤»

[12:56] <moritz_> doesn't even work without action methods

[12:56] <mathw> :(

[12:56] <moritz_> rakudo: grammar A { regex TOP { ^<.a>* a $ }; token a { a } }; say A.parse('aa')

[12:56] <p6eval> rakudo cfbeb5: OUTPUT«aa␤»

[12:56] <moritz_> well

[12:56] <moritz_> I took a token

[12:56] <moritz_> which doesn't backtrac :/

[12:56] <mathw> hah

[12:56] <pmichaud> backtracking into rules and subpatterns is nyi

[12:57] <pmichaud> shouldn't be too hard to implement, just needs available time.  :-|

[12:57] *** hercynium left
[12:57] <mathw> oh if only I could send you tuits

[12:57] *** mikehh joined
[12:57] *** jferrero left
[12:58] *** hafos joined
[12:59] <pmichaud> colomon: List doesn't (or shouldn't) need a .batch

[12:59] <colomon> pmichaud: I understand that.

[12:59] <hafos> I'm experiencing a problem where a Perl module won't install, and I get the following output: http://pastebin.com/vZary2vE - What does INSTALLDIRS=site mean? Doesn't tell me a whole lot and I'm not sure what it is

[13:00] <masak> hafos: Perl 5?

[13:00] <moritz_> hafos: that seems to be a Perl 5 module

[13:00] *** araujo joined
[13:00] <moritz_> hafos: we're discussing Perl 6 here

[13:00] <hafos> You're right my bad

[13:00] <takadonet> hafos: np

[13:00] <masak> no worries.

[13:00] <colomon> pmichaud: but there are dozens of tests written expecting the results of gather / take to have a .batch method.

[13:00] <pmichaud> then those tests are no longer correct :-)

[13:00] <moritz_> hafos: but "OS unsupported" should be pretty clear anyway :-)

[13:01] <colomon> i'd prefer to make progress on getting real bugs fixed than rewriting tests all day.

[13:01] <pmichaud> so, todo or skip them

[13:01] <pmichaud> or even remove them

[13:01] <hafos> moritz_: it's a normal debian installation, I thought it just meant the developers of perl don't offer official support or something ?

[13:01] <colomon> yes, but then you don't get the benefit of seeing whether or not the tests actually work!

[13:02] <moritz_> hafos: you can't install Win32.pm on Debian. It needs the Windows API

[13:02] <hafos> oh okay, thanks

[13:02] <pmichaud> anyway, .batch (if it exists) really only makes sense on iterators, not on lists.  since gather returns a list, we don't need to be testing .batch on it

[13:03] <pmichaud> what tests are these, anyway?

[13:03] <colomon> every single test for infinite lists, for instance.

[13:03] <pmichaud> file?

[13:03] <colomon> zip.t is the one I am looking at.

[13:03] <colomon> but most of the series test files will also have it.

[13:03] <moritz_> S03-metaops/reduce.t

[13:04] <moritz_> S03-metaops/zip.t

[13:04] <moritz_> S32-list/pick.t

[13:04] <moritz_> S05-modifier/continue.t

[13:04] <moritz_> S03-opeartors/series*.t

[13:04] <pmichaud> you could use .munch there instead

[13:04] <colomon> until this weekend, batch was the accepted way to test infinite lists.

[13:04] *** Schwern joined
[13:05] <pmichaud> instead of .batch(5)   you can use  .munch(5)   or you can use  .[^5]

[13:05] <moritz_> what is .munch?

[13:05] <pmichaud> it's basically the result of doing .shift $n times

[13:05] <pmichaud> (which is what .batch was doing)

[13:05] <moritz_> it's not spec either

[13:06] <moritz_> .[^5] then

[13:06] <pmichaud> well, it's not spec yet.

[13:06] <moritz_> before we run into the same trouble again

[13:06] <pmichaud> almost everything with iterators is going to be changing

[13:06] <pmichaud> but yes,  .[^5] is very safe.

[13:06] <colomon> except that it doesn't work.

[13:06] <pmichaud> it will return the first five elements of the list

[13:06] <pmichaud> well, then we fix it.  :)

[13:06] <colomon> that's why I implemented batch with [(^5).list]

[13:07] <pmichaud> so,  should  Range ~~ Positional ?

[13:07] <pmichaud> I'm guessing yes.

[13:08] <moritz_> rakudo: say (1..5)[3]

[13:08] <p6eval> rakudo cfbeb5: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Range'␤  in main program body at line 1␤»

[13:08] <colomon> I would think no, but I guess it can.

[13:08] <moritz_> perl6: say say (1..5)[3

[13:08] <moritz_> perl6: say say (1..5)[3]

[13:08] <p6eval> pugs: OUTPUT«*** ␤    Unexpected end of input␤    expecting operator or "]"␤    at /tmp/QjquYMD86x line 2, column 1␤»

[13:08] <p6eval> ..elf 31266: OUTPUT«Parse error in: /tmp/wpUA6Foa65␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say say (1..5)[3␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[13:08] <p6eval> ..STD_red/std.rb:210:in…

[13:08] <p6eval> ..rakudo cfbeb5: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 11␤»

[13:08] <p6eval> rakudo cfbeb5: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Range'␤  in main program body at line 1␤»

[13:08] <p6eval> ..pugs: OUTPUT«4␤1␤»

[13:08] <pmichaud> rakudo:  sub abc(@a) { say @a.elems; };   say abc(1..3);   # do we expect this to work?

[13:08] <p6eval> ..elf 31266: OUTPUT«Can't call method "postcircumfix__91_32_93" without a package or object reference at (eval 125) line 3.␤ at ./elf_h line 5881␤»

[13:08] <p6eval> rakudo cfbeb5: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Range instead␤  in 'abc' at line 11:/tmp/aeRXKukCdd␤  in main program body at line 11:/tmp/aeRXKukCdd␤»

[13:09] <pmichaud> if we expect to be able to pass 1..3 to a function taking an @-parameter, then 1..3 has to be Positional

[13:09] <pmichaud> I'm thinking yes.

[13:09] <moritz_> +1

[13:09] *** varun left
[13:09] <pmichaud> so, adding "does Positional"  to Range  should get   .[^5]  to work.

[13:10] <colomon> I agree we expect to pass 1..3 to a function taking an @-parameter, but it seems to me this is another example of @-parameters being Positional being Not Quite Right

[13:10] <colomon> rakudo: say (1...10)[^5]

[13:10] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[13:11] *** christine left
[13:11] <moritz_> colomon: that's also a good explanation

[13:11] <pmichaud> I wonder if  ^5  should really be   0...4   instead of 0..4  :-)

[13:11] <moritz_> instead of 0..^5

[13:11] <pmichaud> oh, nm, that answers the question.

[13:11] <pmichaud> it needs to be 0..^5

[13:12] <colomon> I dunno, that would significantly change the meaning.

[13:12] <pmichaud> that's where the ^ comes from

[13:12] <colomon> Not sure anyone uses it for anything other than the equivalent of 0...4

[13:12] <pmichaud> anyway, > my @a = <a b c d e f g>;  say @a[^3]

[13:12] <pmichaud> abc

[13:12] <moritz_> \o/

[13:13] <colomon> moritz_: you want to change all the batches, or would you like me to?

[13:13] <pmichaud> pushed.

[13:13] <colomon> should be easy enough to write a Perl 5 script to do it automatically.

[13:13] <moritz_> colomon: I can do it, I don't feel productive anyway

[13:13] <moritz_> it might break master though.

[13:14] <pmichaud> rakudo:  my @a = <a b c d e f g h>;  say @a[^3]

[13:14] <p6eval> rakudo cfbeb5: OUTPUT«abc␤»

[13:14] <pmichaud> looks like master works already.

[13:14] <colomon> moritz_: that's why I just checked it a second ago

[13:14] *** araujo left
[13:15] <pmichaud> unless it doesn't work from gather/take for some reason (flattening, possibly)

[13:15] <colomon> moritz_: you should definitely test it on master first, a lot of those tests probably don't work for other reasons in the list branch yet.

[13:15] <colomon> pmichaud: it does, see my test about one screen back

[13:15] <colomon> rakudo: say (1...10)[^5]

[13:15] <p6eval> rakudo cfbeb5: OUTPUT«12345␤»

[13:15] <colomon> oh, wait

[13:15] <colomon> rakudo: say (1...*)[^5]

[13:15] <colomon> never mind, that's not a workable solution.

[13:15] <p6eval> rakudo cfbeb5:  ( no output )

[13:16] <pmichaud> > say (1...*)[^5]

[13:16] <pmichaud> 12345

[13:16] *** araujo joined
[13:16] <pmichaud> (from the branch)

[13:16] <colomon> I dunno, I vote to leave the batch hack in list for the moment, and search and replace it to munch as soon as the branches merge.

[13:17] <pmichaud> I'd prefer to s/r to the .[^$n]  form

[13:17] <pmichaud> but yes, we can change the tests after merge

[13:17] <moritz_> waitwaitwait

[13:17] *** christine joined
[13:17] <moritz_> those are not rakudo tests

[13:17] <moritz_> they are spectests

[13:17] <moritz_> if .batch isn't spec (and I kinda thought it was), it goes.

[13:17] <pmichaud> it was spec, yes.

[13:17] <pmichaud> it may not be

[13:17] <moritz_> I couldn't find it in the spec 

[13:17] <colomon> moritz_: spec is shifting here.

[13:17] <pmichaud> even if it remains in the spec, it's something you do to an Iterator

[13:18] <pmichaud> and gather/take (and the various operators) return lists, not iterators

[13:18] <pmichaud> this is partially why I've been saying to be careful about building too much on master's broken implementation, because it was deeply and fundamentally broken at a design level

[13:19] <moritz_> so I see two options

[13:19] <moritz_> 1) fudge them for master

[13:19] <moritz_> 2) temporarily disable them in master's t/spectest.data

[13:19] <pmichaud> 3) remove the incorrect usages of .batch from t/spec

[13:20] <moritz_> 3) is precursor to 1) xor 2)

[13:20] <moritz_> for which I have patch locally

[13:20] <pmichaud> I'm fine with temporarily disable

[13:20] <pmichaud> that's easier than fudging

[13:20] <moritz_> ok

[13:21] <moritz_> I'll see which ones need disabling

[13:21] <colomon> why for heaven's sake would we turn off tests giving us useful information in the name of conforming to a spec that is changing this week?!

[13:21] <pmichaud> colomon: because they don't conform to the spec

[13:21] <pmichaud> they dont conform to the existing spec

[13:21] <pmichaud> this is what I have been saying all along.

[13:21] <moritz_> colomon: because they neither confrorm to existing nor to the new spec

[13:22] <colomon> I give up.

[13:22] *** colomon left
[13:22] *** rgrau_ joined
[13:22] *** rgrau left
[13:23] <moritz_> hugme: hug colomon

[13:23] * hugme hugs colomon

[13:24] <dalek> rakudo: 99b6dd0 | pmichaud++ | build/PARROT_REVISION:

[13:24] <dalek> rakudo: Eliminate hyphen from PARROT_REVISION.

[13:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/99b6dd0d132ac0bc850b18f540c7e05a9cb1b0b9

[13:24] <moritz_> sorry, I was sloppy

[13:25] <pmichaud> np :)

[13:27] <moritz_> oh

[13:27] <moritz_> .batch does appear in S03

[13:27] <moritz_> on a list

[13:27] <moritz_> 4050:    (@dwimmyside xx *).batch(@otherside.elems)

[13:29] *** arthur-- left
[13:31] <pmichaud> well, even in that case it would be wrongish, as it would need to be .batcharg instead of .batch

[13:31] <pmichaud> (.batch flattens)

[13:32] <moritz_> in S03:4050 it's meant to flatten, no?

[13:33] <pmichaud> I'm still trying to figure that out

[13:33] <moritz_> it would be pretty fatal if not

[13:33] <moritz_> for example if you <<+<<

[13:33] <moritz_> and the RHS doesn't flatten

[13:33] *** Zapelius joined
[13:33] <pmichaud> yes, okay, flattening

[13:33] <moritz_> it passes an array as the second operand to + at some point

[13:34] <moritz_> and works on the number of elements. D'oh.

[13:34] *** JimmyZ joined
[13:35] <pmichaud> I'd rewrite that now as   (@dwimmyside xx *).flat.[^@otherside.elems]

[13:36] <moritz_> no need for the .elems actually

[13:36] <pmichaud> that too :-)

[13:36] <moritz_> unless +@a and @a.elems are allowed to disagree

[13:37] <Zapelius> what's the replacement for p5 hex() ?

[13:37] <pmichaud> afk for a bit

[13:38] <moritz_> Zapelius: :16()

[13:38] <moritz_> rakudo: say :16('a0')

[13:38] <p6eval> rakudo cfbeb5: OUTPUT«160␤»

[13:38] <Zapelius> k, thanks :)

[13:38] <moritz_> works with other bases too :-)

[13:42] *** meppl joined
[13:43] *** arthur-- joined
[13:43] <szabgab> literal, any time to update App::Grok?

[13:44] <literal> you have something in mind?

[13:44] *** Zapelius left
[13:45] <szabgab> I don't know, azawawi told me to ping you :)

[13:45] <szabgab> he is on #padre

[13:45] <literal> ok

[13:45] <szabgab> as I'd like to make Padre ready for the release of Rakudo *

[13:45] <szabgab> so we have a superb Perl 6 support

[13:46] *** patspam joined
[13:48] *** Guest50632 left
[13:49] <moritz_> szabgab++

[13:50] <szabgab> I am just talking

[13:50] <moritz_> talking can be powerful

[13:51] <moritz_> especially if you talk in a programming language, and write it down :-)

[13:52] *** plobsing joined
[13:52] *** uniejo left
[13:52] * PerlJam imagines a future when Padre is written in Perl 6.

[13:54] <szabgab> rakudo: say (1,2 X 4,7).perl; my @x = (1,2 X 4,7);  say @x.perl;

[13:54] <p6eval> rakudo cfbeb5: OUTPUT«(1, 4, 1, 7, 2, 4, 2, 7)␤[(1, 4), (1, 7), (2, 4), (2, 7)]␤»

[13:54] <szabgab> why the difference?

[13:55] <moritz_> seems wrong to me

[13:55] <PerlJam> indeed.

[13:55] <szabgab> rakudo: say (1,2 X 4,7).elems

[13:55] <p6eval> rakudo cfbeb5: OUTPUT«4␤»

[13:55] <szabgab> rakudo: say (1,2 X 4,7).perl

[13:55] <p6eval> rakudo cfbeb5: OUTPUT«(1, 4, 1, 7, 2, 4, 2, 7)␤»

[13:55] <PerlJam> that's really wrong.

[13:55] <moritz_> actually I'd expected it to be just the other way round, if I didn't knew that list assignment flattening is broken in rakudo

[13:55] <szabgab> so my slides are useful for something after all :)

[13:56] <pmichaud> @x flattens

[13:56] <pmichaud> yes, it looks broken.

[13:56] * pmichaud tries it in list branch

[13:57] <PerlJam> pmichaud: how goes the list work?

[13:57] <pmichaud> PerlJam: we're making good progress, but it's definitely taking longer than I'd like.

[13:57] <szabgab> rakudo: for (1, 2, 3, 4, 5) -> $x, $y? { say "$x $y"; }

[13:57] <p6eval> rakudo cfbeb5: OUTPUT«1 Any()␤2 Any()␤3 Any()␤4 Any()␤5 Any()␤»

[13:57] <pmichaud> > say (1,2 X 4,7).perl

[13:57] <pmichaud> ((1, 4), (1, 7), (2, 4), (2, 7))

[13:57] <pmichaud> > my @x = (1,2 X 4,7);  say @x.perl;

[13:57] <pmichaud> [1, 4, 1, 7, 2, 4, 2, 7]

[13:57] <pmichaud> > 

[13:58] <pmichaud> that's what I would expect, anyway (and it's what the list branch gives)

[13:58] *** wallberg left
[13:59] <moritz_> pmichaud++

[13:59] <szabgab> pmichaud, good, as that's what my slides say, as it was working some time ago

[13:59] <szabgab> so I just wait till it gets merged

[13:59] <szabgab> what about the for loop with the optional value?

[13:59] <szabgab> rakudo: for (1, 2, 3, 4, 5) -> $x, $y? { say "$x $y"; }

[13:59] <p6eval> rakudo cfbeb5: OUTPUT«1 Any()␤2 Any()␤3 Any()␤4 Any()␤5 Any()␤»

[13:59] *** mjk left
[14:00] <szabgab> that looks broken too

[14:00] <pmichaud> still broken in the branch

[14:00] <pmichaud> I'm guessing .count is giving wrong results  

[14:01] <pmichaud> no, that's not it

[14:01] <pmichaud> hrm.

[14:01] <pmichaud> oh!

[14:01] <pmichaud> the problem is that our 'for' statement still isn't using 'map'

[14:01] *** ash__ joined
[14:01] <pmichaud> (1,2,3,4,5).map(-> $x, $y? { say "$x $y"; })

[14:02] <pmichaud> rakudo: (1,2,3,4,5).map(-> $x, $y? { say "$x $y"; })

[14:02] <p6eval> rakudo cfbeb5:  ( no output )

[14:02] <pmichaud> rakudo: (1,2,3,4,5).map(-> $x, $y? { say "$x $y"; }).eager

[14:02] <p6eval> rakudo cfbeb5: OUTPUT«1 2␤3 4␤5 Any()␤»

[14:02] <szabgab> it should give 3 iterations, 1 2    3 4   and 5  Mu   ?

[14:02] <pmichaud> ...and that we don't have sink context yet :)

[14:03] <pmichaud> but yes, 3 iterations, as shown by the .map above

[14:03] <szabgab> What would be the value of the $y in the last iteration?

[14:03] <pmichaud> Any

[14:03] <pmichaud> (parameters default to Any)

[14:03] *** snarkyboojum left
[14:03] <szabgab> ok, I'll read about it

[14:03] <pmichaud> (unless declared with a different constraint)

[14:05] *** proller left
[14:06] <szabgab> ty

[14:06] <szabgab> is there any difference between    [1, 2] and (1, 2) ?

[14:06] *** proller joined
[14:06] <JimmyZ> array and list?

[14:07] <szabgab> rakudo: my @words = <moo foo bar moose bu>; say @words.sort.perl

[14:07] <p6eval> rakudo cfbeb5: OUTPUT«("bar", "bu", "foo", "moo", "moose")␤»

[14:08] <szabgab> rakudo: my @words = <moo foo bar moose bu>; say @words.sort: { $_.bytes }

[14:08] <p6eval> rakudo cfbeb5: OUTPUT«bumoofoobarmoose␤»

[14:08] <pmichaud> szabgab: (1, 2) is a parcel, [1, 2] is a scalar array

[14:08] <szabgab> rakudo: my @words = <moo foo bar moose bu>; my @x =  @words.sort: { $_.bytes }; say @x.perl

[14:08] <p6eval> rakudo cfbeb5: OUTPUT«["bu", "moo", "foo", "bar", "moose"]␤»

[14:08] <szabgab> rakudo: my @words = <moo foo bar moose bu>; my @x =  @words.sort.perl; say @x.perl

[14:08] <p6eval> rakudo cfbeb5: OUTPUT«["(\"bar\", \"bu\", \"foo\", \"moo\", \"moose\")"]␤»

[14:09] <szabgab> rakudo: my @words = <moo foo bar moose bu>; my @x =  @words.sort; say @x.perl

[14:09] <p6eval> rakudo cfbeb5: OUTPUT«["bar", "bu", "foo", "moo", "moose"]␤»

[14:10] <szabgab> so if I put .perl on the result of sort I get ()  - a parcel and if put .perl on the @x then I get [] scalar array

[14:10] <pmichaud> yes

[14:10] <szabgab> now I only need to read about parcel and scalar array :)

[14:10] <pmichaud> that's the current spec.  I was discussing that we might want to change it (about 12 hours ago :)

[14:11] <pmichaud> I think that both should return ( )

[14:11] <masak> Alias++ # http://use.perl.org/~Alias/journal/40398

[14:11] <tadzik> Is .perl something more than something like Data::Dumper? Can it be read by Perl6, evaled or something?

[14:12] <pmichaud> Indeed, Alias++

[14:12] *** am0c left
[14:12] <pmichaud> tadzik: .perl  is supposed to produce a string that when evaled will produce the value that was .perl'd

[14:13] <tadzik> So it's useful for either debugging or serialization?

[14:13] <pmichaud> tadzik: but our current definition (in the spec) almost never achieves that.  Yesterday I decided to invoke hubris and start changing Rakudo so that .perl would work more the way I think it should... but that started deviating waaaay too far from the spec so I abandoned it

[14:14] <masak> rakudo: class A { has $.foo }; say A.new(:foo(42).perl

[14:14] <p6eval> rakudo cfbeb5: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤»

[14:14] <masak> rakudo: class A { has $.foo }; say A.new(:foo(42)).perl

[14:14] <p6eval> rakudo cfbeb5: OUTPUT«A.new()␤»

[14:14] <pmichaud> and the discussion that TimToady++ and I had on the subject tended more towards strings and less about .perl (and I have other priorities right now) so I skipped it for now.

[14:14] <pmichaud> masak: yes, that's an example.  But I'm more concerned with something like

[14:14] *** Sanitoeter joined
[14:15] <masak> rakudo: my $code = { say "OH HAI" }; say $code.perl

[14:15] <p6eval> rakudo cfbeb5: OUTPUT«{ ... }␤»

[14:15] <pmichaud> rakudo:   my @a = 1,2;   say (1, @a, 3).perl;

[14:15] <p6eval> rakudo cfbeb5: OUTPUT«(1, [1, 2], 3)␤»

[14:15] <masak> o.O

[14:15] <masak> shouldn't that flatten?

[14:15] <pmichaud> right

[14:15] <pmichaud> but the spec says that arrays and lists are produced using brackets

[14:16] <pmichaud> (ignoring their flattening nature)

[14:16] <pmichaud> I think that  "(1, 1, 2, 3)"  is equally wrong.

[14:16] <mathw> oh yes, Alias++

[14:16] <masak> pmichaud: it's what I would expect.

[14:16] <pmichaud> I think the result should be "(1, (1, 2), 3)"

[14:16] <pmichaud> .perl shouldn't automatically flatten a parcel, either.

[14:17] <masak> oh, I think I see what you're saying.

[14:17] <pmichaud> if I do .perl on a Parcel, it should give me back a string that evals to a Parcel

[14:17] <pmichaud> (to an equivalent Parcel)

[14:17] <masak> aye.

[14:18] <mathw> not just some random Parcel :)

[14:19] <pmichaud> same with   (1,2) X (3,4) --- I expect .perl to not flatten the result

[14:20] <pmichaud> nor to itemize the intermediate lists into [...] arrays

[14:20] <dimid> rakudo: (any <1 2 3>).perl

[14:20] <p6eval> rakudo cfbeb5:  ( no output )

[14:20] <JimmyZ> It's useful when you want to use it.

[14:20] <JimmyZ> oh, wrong

[14:20] <tadzik> where do I find some comprehensive docs about Perl 6 types?

[14:20] <dimid> rakudo: say (any <1 2 3>).perl

[14:20] <p6eval> rakudo cfbeb5: OUTPUT«any("1", "2", "3")␤»

[14:20] <dimid> rakudo: say (any<1 2 3>).perl

[14:20] <p6eval> rakudo cfbeb5: OUTPUT«any()␤»

[14:20] <masak> tadzik: http://spec.pugscode.org/

[14:20] <masak> tadzik: specifically, S02 and S32.

[14:21] <dimid> why any <1 2 3> != any<1 2 3> ?

[14:22] <tadzik> thanks masak 

[14:22] <pmichaud> dimid: the lack of the space changes the circumfix angles into postcircumfix angles

[14:22] <masak> dimid: because the latter is hash indexing.

[14:22] <pmichaud> masak++ says it better :)

[14:23] <masak> dimid: in the case of distinguising between infix and postfix operators, whitespace is significant in Perl 6.

[14:23] <dimid> i see. thanks

[14:24] <masak> solution: use parens, or whitespace. preferably consistently. :)

[14:24] <dimid> =)

[14:24] <JimmyZ> It's very different from Perl 5

[14:24] *** Trashlord left
[14:26] <tadzik> rakudo: my $a = (tim => 'toady', foo => [1, 2, 3]).perl; my $b = eval $a; say $b.WHAT; say (tim => 'toady', foo => [1, 2, 3]).WHAT

[14:26] <p6eval> rakudo cfbeb5: OUTPUT«Seq()␤Parcel()␤»

[14:26] <masak> JimmyZ: yes. the price you pay for the increased flexibility in Perl 5 is that sometimes you won't know whether something is a term or an operator.

[14:26] <tadzik> why the difference?

[14:27] <masak> tadzik: because of the assignment to $b, I'd think.

[14:27] <pmichaud> tadzik: assigning a parcel to a scalar converts it into a Seq

[14:27] <tadzik> I see. Seq is a scalar?

[14:27] <masak> rakudo: my $b = (tim => 'toady', foo => [1, 2, 3]); say $b.WHAT; say (tim => 'toady', foo => [1, 2, 3]).WHAT

[14:27] <p6eval> rakudo cfbeb5: OUTPUT«Seq()␤Parcel()␤»

[14:27] <pmichaud> Seq is a list

[14:28] * masak .oO( "a Seq in the hand is worth a Parcel in the bush" )

[14:31] <tadzik> hmm

[14:31] <tadzik> rakudo: my %a = foo => 'bar', asd => 5; my $b = %a; say $b.WHAT

[14:31] <p6eval> rakudo cfbeb5: OUTPUT«Hash()␤»

[14:31] <tadzik> what happens here, am I magically holding a hash in %-prefixed variable?

[14:32] <tadzik> erm, $-prefixed

[14:32] <pmichaud> sure, scalars can hold almost anything

[14:32] <tadzik> ah, okay

[14:32] <pmichaud> it's kind of like a reference in p5

[14:32] <tadzik> so prefixes are just for users in this case?

[14:32] <pmichaud> but you don't have to do anything to dereference (or to worry about the reference being there)

[14:32] <tadzik> yeah, I'm really happy about that

[14:32] <pmichaud> the prefixes (they're called "sigils", btw)  do control flattening

[14:33] <tadzik> what do you mean?

[14:33] <pmichaud> rakudo: my @a = 1,2,3,4;   my $b = @a;    say (@a, 5, 6).elems;   say ($b, 5, 6).elems;

[14:33] <p6eval> rakudo cfbeb5: OUTPUT«6␤3␤»

[14:33] <pmichaud> array sigils will flatten in list context, while scalar sigils won't

[14:34] *** EvanCarroll joined
[14:34] <tadzik> mhm

[14:34] <EvanCarroll> zomfg, regexp::grammars is awesome

[14:35] <mathw> I keep forgetting what a Parcel actually is

[14:35] <mathw> I really need to re-read that part of the spec

[14:35] <pmichaud> In general, a Parcel is the thing that is constructed by &infix:<,>

[14:35] <pmichaud> that's the way I tend to remember it

[14:36] <pmichaud> so,   (3, 4)   is a Parcel

[14:36] *** gbacon joined
[14:36] *** plobsing left
[14:36] <mathw> and Parcels do the expected sort of thing if you treat them like lists

[14:36] <pmichaud> yes

[14:37] <mathw> Is the argument list for a subroutine call also a Parcel?

[14:37] <pmichaud> mathw: yes

[14:37] <pmichaud> in fact, that's really why Parcels exist

[14:37] <pmichaud> so that they can be interpreted in different ways depending on context

[14:37] <mathw> that's quite nice

[14:37] <mathw> so anything with (..., ...) is actually the same thing

[14:37] <pmichaud> conceptually, yes

[14:38] <mathw> and then you do something with it and it becomes what you're asking it to be

[14:38] <pmichaud> in that case, the Parcel gets converted to a Capture which is then used for signature binding

[14:39] <mathw> and Capture provides the stuff that a subroutine needs to make its parameters visible to its block, or something like that

[14:39] <pmichaud> yes, as well as knowing how to deal with slurpy arguments, and named arguments

[14:40] <pmichaud> a Capture is able to take a Parcel like    1, a=>4, :b(5)

[14:40] <pmichaud> and know how to map that onto a variety of different signatures

[14:40] <mathw> Excellent

[14:40] <mathw> I have much more clue now, thanks :)

[14:42] *** Guest23195 joined
[14:49] <tadzik> moritz_: your grammars example from perl5-to-6 does not compile for me

[14:50] <tadzik> http://wklej.org/id/351219/

[14:50] *** slavik left
[14:51] *** slavik joined
[14:51] *** [mark] left
[14:51] <tadzik> and there's a typo, URL in grammar declaration, URI in URI.parse

[14:52] *** pmurias joined
[14:53] <tadzik> I believe - needs to be escaped

[14:54] <ash__> yes it does need to be escaped now 

[14:54] <baest> also inside a char class?

[14:55] <ash__> alpha: say /<[-]>/ ~~ '-'

[14:55] <p6eval> alpha 30e0ed: OUTPUT«perl6regex parse error: Unescaped '-' in charlist (use '..' or '\-') at offset 267, found '-'␤in Main (file <unknown>, line <unknown>)␤»

[14:55] <ash__> i like that error message better than master rakudo's error message

[14:55] <ash__> rakudo: say /<[-]>/ ~~ '-'

[14:55] <p6eval> rakudo 99b6dd: OUTPUT«===SORRY!===␤Obsolete use of hyphen in enumerated character class;in Perl 6 please use .. instead at line 11, near "]>/ ~~ '-'"␤»

[14:56] <pmichaud> rakudo master's message comes from STD, though.

[14:56] <pmichaud> std:  say /<[-]>/ ~~ '='

[14:56] <p6eval> std 31266: OUTPUT«ok 00:01 109m␤»

[14:56] <pmichaud> huh

[14:56] <ash__> :P does it? 

[14:56] <pmichaud> did STD get rid of that particular warning?

[14:57] <JimmyZ> pmichaud: master  sometimes gives me wrong messages

[14:57] <jnthn> std:  say /<[a-z]>/ ~~ '='

[14:57] <p6eval> std 31266: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of - as character range; in Perl 6 please use .. at /tmp/TDhv24tkYR line 1:␤------> [32msay /<[a-z[33m⏏[31m]>/ ~~ '='[0m␤Parse failed␤FAILED 00:01 105m␤»

[14:57] <jnthn> I think it just got smarter.

[14:57] *** hafos left
[14:57] <JimmyZ> pmichaud: I'm sure not only this one

[14:57] <pmichaud> std:  say /<[-z]>/ ~~ '.'

[14:57] <p6eval> std 31266: OUTPUT«ok 00:01 106m␤»

[14:57] <ash__> - by itself seems to be fine, but infix it complains 

[14:58] <pmichaud> okay, so STD only complains if - appears where one might expect a character range

[14:58] *** rgrau_ left
[14:58] <pmichaud> I can fix that (but not in the current parrot release)

[14:58] <mathw> because you can always reorder it if you really meant -

[14:58] <ash__> -abc vs a-bc etc. (where its not supposed to be a range) 

[14:59] <mathw> yup

[14:59] <mathw> &

[15:00] <ash__> std: say /<[a\-z]/ ~~ 'a';

[15:00] <p6eval> std 31266: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse metachar at /tmp/bA10yw9ZYW line 1:␤------> [32msay /[33m⏏[31m<[a\-z]/ ~~ 'a';[0m␤Couldn't find final '>'; gave up at /tmp/bA10yw9ZYW line 1:␤------> [32msay /<[a\-z][33m⏏[31m/ ~~ 'a';[0m␤    expecting any of:␤    character

[15:00] <p6eval> ..class …

[15:00] <ash__> std: say /<[a\-z]>/ ~~ 'a';

[15:00] <p6eval> std 31266: OUTPUT«ok 00:01 106m␤»

[15:00] <ash__> i wonder what that means 

[15:01] <ash__> is that an escaped - or is that a \ and a - separate? 

[15:01] <pmichaud> it's an escaped -

[15:02] <ash__> got ya, you always need \\ to mean \, right? (or commonly?) 

[15:02] <pmichaud> generally, yes.

[15:03] <dalek> rakudo: aff0402 | jonathan++ | src/builtins/Mu.pir:

[15:03] <dalek> rakudo: Remove a fossil.

[15:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/aff0402933de94efd70833c32e4f5a78ede4591a

[15:03] <dalek> rakudo: f78f232 | jonathan++ |  (3 files):

[15:03] <dalek> rakudo: Switch Multi to inherit from Routine, not Code. Implement candidates on Routine 

[15:03] <dalek> rakudo: so that it just returns a list containing itself. Implement cando. Note that due 

[15:03] <dalek> rakudo: to an unrelated issue to do with augment and mapped Parrot types, .cando isn't 

[15:03] <dalek> rakudo: found on multis yet; that needs a seperate fix. Patch courtesy of (Maxim 

[15:03] <dalek> rakudo: Yemelyanov)++.

[15:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f78f232838da3559dcba64ff60faef14ec850e48

[15:03] <dalek> rakudo: 207c528 | jonathan++ | src/metamodel/Attribute.nqp:

[15:03] <dalek> rakudo: Start to stub in attribute traits a bit.

[15:03] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/207c5284b4a2e4a8c2e74698f9af75dfe7cd44e0

[15:04] <jnthn> yaypatches :-)

[15:04] <masak> yayjnthn!

[15:05] *** bphillips joined
[15:05] <jnthn> yaymasak!

[15:05] <jnthn> masak++ # saw your Bug post

[15:05] <jnthn> er, Buf

[15:05] * masak keeps typoing it as "Bug" too :)

[15:06] <jnthn> ...wow, I could claim that as legitimate Freudian or legitimate typo. :-)

[15:06] <masak> :)

[15:06] <pugssvn> r31267 | moritz++ | [t/spec] replace .batch($x) with .[^$x] 

[15:07] <pmichaud> the more I work with the new list/iterator implementation, the more I'm convinced it's Right.

[15:08] <masak> pmichaud++

[15:08] <masak> pmichaud: sounds like you're suffering from True Believer Syndrome :P

[15:08] <pmichaud> maybe.  but so many things that were convoluted in the previous (four or five) systems are just straightforward in this one.

[15:09] <masak> that's a really good sign.

[15:09] *** Trashlord joined
[15:12] *** Mowah left
[15:12] <jnthn> lolibloggedforonce # http://use.perl.org/~JonathanWorthington/journal/40399

[15:13] <jnthn> pmichaud: Current spectest status for list? :-)

[15:14] <pmichaud> about 500 failing tests

[15:14] <pmichaud> but little fixes are still recovering lots of tests

[15:14] <pmichaud> and we get lots of todo passes

[15:14] <masak> ship it!

[15:14] <jnthn> pmichaud: 500 fails is less than I thought we might be at by this point. Excellent!

[15:14] <jnthn> pmichaud++

[15:14] <moritz_> jnthn: I have to say that I'm really impressed by those russian hackathoniers

[15:14] <dalek> rakudo: 410db0f | moritz++ | t/spectest.data:

[15:14] <dalek> rakudo: disable some tests that now loop, due to .batch being replaced by .[^$num]

[15:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/410db0f762809001bc9c9bf3d95efd784ac670e6

[15:14] <pmichaud> yes, I figure with a little luck I should be able to merge today

[15:15] <moritz_> jnthn: can't we get a bunch of those as regular contributors? :-)

[15:15] <jnthn> moritz_: Yes, me too. I think at least one was also Ukrainian. :-)

[15:15] <jnthn> moritz_: A couple said they may :-)

[15:15] <moritz_> that would be great

[15:15] <jnthn> Yes, I'd like it.

[15:15] <moritz_> any nationality is fine, really

[15:16] <moritz_> did we already have a Kiev release?

[15:16] <jnthn> No.

[15:16] <jnthn> But I'd like to propose we do.

[15:16] <jnthn> And I know they'd like that here. :-)

[15:16] *** macdaddy joined
[15:17] <pmichaud> I'd say go ahead and tentatively name July "Kiev.pm"

[15:17] <masak> +1

[15:17] <moritz_> I'll put it in the release guide

[15:17] <pmichaud> moritz_++

[15:18] <pmichaud> hmmm

[15:18] *** [mark] joined
[15:18] <pmichaud> ( <a b>, 'c' ).join(',')    # what should this produce?

[15:19] <moritz_> I'd expect 'a, b, c'

[15:19] <pmichaud> me too

[15:19] <pmichaud> so what's responsible for flattening the parcel, there?

[15:19] <moritz_> because that's what we get from join(', ', <a b>, 'c')

[15:19] <pmichaud> does .join automatically flatten the list?

[15:19] <cono> Kiev++

[15:19] <jnthn> o/ cono :-)

[15:19] <masak> rakudo: my $d = ''; class Foo { method some_meth_1 {$d = $d ~ self;}}; for '0' .. '5' -> $a { sub; };

[15:19] <p6eval> rakudo 99b6dd: OUTPUT«===SORRY!===␤Symbol '$ss_SS_S_S__S_S_s' not predeclared in <anonymous> (/tmp/RF3RHI6UOR:1)␤»

[15:20] <cono> jnthn: are still in Kiev?

[15:20] <jnthn> cono: Yes

[15:20] <cono> u*

[15:20] <jnthn> cono: Leave tomorrow.

[15:20] <moritz_> masak: what is sub; supposed to do?

[15:20] <cono> jnthn: how is the boat trip?

[15:20] <pmichaud> I see several possibilities:

[15:20] <dalek> rakudo: 2721911 | moritz++ | docs/release_guide.pod:

[15:20] <dalek> rakudo: propose Kiev as name of next release, with link to jnthn++'s blog post

[15:20] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2721911c53d2961cce8407cc33a1f9675887cb65

[15:20] <jnthn> Boat trip was nice. :-)

[15:20] <jnthn> Relaxing. :-)

[15:20] <masak> moritz_: I have *no* idea. this is JimmyZ privmsging me strange bug reports. :)

[15:20] <jnthn> And another way to see Kiev.

[15:20] <pmichaud> (1)  Parcel.join flattens the parcel  (meaning that various methods act differently on parcels)

[15:21] <cono> jnthn: it's a pitty that's a work day :(

[15:21] <pmichaud> (2)  .join always flattens its invocant

[15:21] <jnthn> Aye

[15:21] <pmichaud> (3) some other magic I'm not seeing

[15:21] <jnthn> If it had been weeknd, maybe more people could have come.

[15:22] <cono> sure

[15:22] *** bjarneh joined
[15:22] <ash__> .join seems like another way of writing: <a b> ~ ',' ~ 'c' to me 

[15:22] <jnthn> pmichaud: My guess is that join does it, or that join perhaps only exists in Cool and thus always puts what it has in flattening list context.

[15:23] <pmichaud> well, I'm sure that .join is at least in Any

[15:23] <moritz_> all list methods are in Any

[15:23] <jnthn> Oh.

[15:23] <jnthn> Well, same but s/Cool/Any/. :-)

[15:23] <ash__> unless its supposed to call <a b>.join(',') too 

[15:23] <pmichaud> I'm going to assume .join flattens for now.

[15:24] <ash__> i'd expect to have to write that as (|<a b>, 'c').join(',') (but maybe thats just me) 

[15:25] <pmichaud> ash:  what if I had said instead

[15:25] <pmichaud>     my @a = <a b>;   (@a, 'c').join(',')

[15:25] <masak> rakudo: my $d; class A {method x { $d }}; for () { sub }

[15:25] <p6eval> rakudo 99b6dd: OUTPUT«===SORRY!===␤Symbol '$ss_SS_S_S__S_S_s' not predeclared in <anonymous> (/tmp/I5MPO4gCTY:1)␤»

[15:25] <masak> locally, "Symbol '$d' not predeclared in <anonymous>"

[15:26] * masak , honsetly confused, submits rakudobug

[15:26] <ash__> i'd stll expect @a ~ ',' ~ 'c' to have the same result as .join(','), but again, i might be in the wrong mindset here 

[15:26] <pmichaud> ash__: okay, you're consistent at least :)

[15:26] <moritz_> well

[15:27] <masak> std: my $d; class A {method x { $d }}; for () { sub }

[15:27] <p6eval> std 31266: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/irG3_MPjN_ line 1:␤------> [32mclass A {method x { $d }}; for () { sub [33m⏏[31m}[0m␤    expecting any of:␤ name␤   routine_def␤        trait␤Parse failed␤FAILED 00:01 108m␤»

[15:27] <pmichaud> one could argue that the other interpretation should be   (@a, 'c').flat.join(',')

[15:27] <moritz_> given that ~(1..3, 4) now produces "1..3 4", maybe not joining the <a b> might not be too bad

[15:28] <ash__> i guess i kinda think of join as a list prefix [~], so, [~] $a, 2, 'bob';   but with the ability to say what goes in between the things your joining, 

[15:29] <ash__> rakudo: say [~] 'hello', ' ', 'world', ' and ',  ('hello', 'world').join(' ') 

[15:29] <p6eval> rakudo 99b6dd: OUTPUT«hello world and hello world␤»

[15:29] * JimmyZ hopes there will be web entry for submitting rakudo bugs

[15:30] <moritz_> if it means screwing up like parrot's trac, please not.

[15:30] <moritz_> afk

[15:31] <pmichaud> when is #phasers, again?  I always forget the time.  (utc preferred)

[15:32] <masak> pmichaud: three and a half hours from now.

[15:32] <pmichaud> so, 19:00 utc

[15:32] <pmichaud> I can remember the utc :-)

[15:32] <masak> JimmyZ: I understand why you think that. I don't think it's a good idea. I'm extremely happy with the way things are set up now.

[15:32] <masak> yes, 19:00 UTC. :)

[15:35] <pmichaud> from t/spec/S32-list/sort.t, line 20

[15:35] <pmichaud>     my @s = sort(:values(@a));

[15:35] <pmichaud> that looks like a bogus line to me.

[15:36] <pmichaud> I don't think one can use a named argument to set slurpy positionals

[15:36] <jnthn> oh, #phasers

[15:36] <jnthn> So for me it's...10pm. That's reasonable. :-)

[15:38] <pugssvn> r31268 | pmichaud++ | [t/spec]:  I don't think one can pass slurpy positionals by name. 

[15:38] <jnthn> pmichaud: I'm not too convinced we can either, though there's a trac ticket on that matter too...

[15:38] <jnthn> er

[15:38] <jnthn> RT

[15:40] <pmichaud> also, in sort.t:

[15:40] <pmichaud>     my @a = (1.1,2,NaN,-3.05,0.1,Inf,42,-1e-07,-Inf).sort;

[15:40] <pmichaud>     my @e = (NaN,-Inf,-3.05,-1e-07,0.1,1.1,2,42,Inf);

[15:40] <pmichaud>     my @s = sort @a;

[15:40] <pmichaud>     is(@s, @e, 'array of mixed numbers including Inf/NaN');

[15:41] <pmichaud> ... is there a reason for sorting @a twice?

[15:41] <masak> no.

[15:41] <masak> must be a thinko.

[15:41] <pmichaud> I'm guessing we don't need the .sort 

[15:42] <jnthn> Looks sort of weird to me.

[15:42] <pmichaud> .oO( arggggh )

[15:44] <tadzik> hmm

[15:44] <tadzik> rakudo: fsck you

[15:44] <p6eval> rakudo 99b6dd: OUTPUT«Could not find sub &you␤  in main program body at line 11:/tmp/gwA74bXPgM␤»

[15:44] <tadzik> some sort of indirect notation? how does it work?

[15:45] <pmichaud> tadzik: undeclared barewords are assumed to be subroutine invocations

[15:45] <pmichaud> so, since there's nothing called "you" declared, it's assumed to be a subroutine call to &you

[15:46] <tadzik> yeah, I see. But why does it complain about you, not fsck?

[15:46] <pmichaud> because that happens first

[15:46] <tadzik> mhm

[15:46] <pmichaud> we call &you, and pass the results of that to &fsck

[15:46] <pmichaud> so the call to &you fails first

[15:46] <tadzik> I see

[15:47] <ash__> rakudo: &foo();  sub foo { say 'hello world' }; 

[15:47] <[particle]> &you could define &fsck

[15:47] <p6eval> rakudo 99b6dd: OUTPUT«hello world␤»

[15:47] <[particle]> so you can't fail on &fsck too

[15:49] <jnthn> pmichaud: Just spotted review-notes.txt :-)

[15:49] <tadzik> interesting

[15:50] <masak> rakudo: our sub you { our sub fsck($) { say "OH HAI" } }; fsck you

[15:50] <p6eval> rakudo 99b6dd: OUTPUT«OH HAI␤»

[15:50] *** tedv joined
[15:50] <ash__> you fsck would fail in masak's example, because of the way the sub's are defined 

[15:50] <jnthn> I don't think it would.

[15:51] <ash__> rakudo: our sub you { our sub fsck($) { say "OH HAI" } }; you fsck

[15:51] <p6eval> rakudo 99b6dd: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in 'fsck' at line 11:/tmp/4vVZMhax4Y␤  in main program body at line 11:/tmp/4vVZMhax4Y␤»

[15:51] <jnthn> Oh

[15:51] <ash__> ah, it fails for another reason >< 

[15:51] <[particle]> :)

[15:51] <jnthn> well, OK...yes

[15:51] <jnthn> fsck

[15:51] <jnthn> :-)

[15:51] <masak> hm. 'you fsck' sounds more offensive than 'fsck you' :)

[15:52] <tadzik> maybe rakudo couldn'd stand it

[15:52] <ash__> i pronounce fsck as 'f-s check' 

[15:52] <ash__> sounds like a command

[15:52] <jnthn> masak: Well, it depends if it was a verb or an nouny-adjective in the first one. ;-)

[15:52] <ash__> s/you/sudo/ now its really a command

[15:52] <masak> ash__: I somehow manage to pronounce it as a monosyllable.

[15:56] <masak> the 'badges' list of stackoverflow is inspiring. http://stackoverflow.com/badges

[15:58] *** Ross joined
[15:59] <masak> nom &

[15:59] *** masak left
[16:00] *** ash__ left
[16:02] *** cdarroch joined
[16:02] *** cdarroch left
[16:02] *** cdarroch joined
[16:02] *** tedv left
[16:02] *** gbacon left
[16:02] *** JimmyZ left
[16:02] *** sukria left
[16:02] *** dimid left
[16:02] *** eiro left
[16:03] *** sukria joined
[16:04] *** dimid joined
[16:04] *** eiro joined
[16:04] *** gbacon joined
[16:04] *** JimmyZ joined
[16:05] *** tedv joined
[16:11] * moritz_ hopes he didn't offend colomon++ earlier when talking about the test changes (.batch)

[16:12] <pmichaud> moritz_: yeah, I'm not quite sure what happened there.  Maybe it was me.

[16:12] <pmichaud> I can understand while colomon++ would be frustrated -- he's been wanting to do iterators and lists for quite a while

[16:12] <pmichaud> s/while/why/

[16:17] *** paroxyzm_ left
[16:18] *** justatheory joined
[16:19] *** ash__ joined
[16:21] *** pmurias left
[16:34] <EvanCarroll> http://stackoverflow.com/questions/3047155/how-do-i-best-do-balanced-quoting-with-perls-regexpgrammars

[16:38] *** envi^home left
[16:39] *** am0c joined
[16:39] *** [mark] left
[16:41] *** JimmyZ left
[16:51] <[particle]> i may see colomon tonight

[16:51] <[particle]> if i do, i'm sure he'll assault me about it

[16:52] <TimToady> blessed are the peacemakers, for they shall be assaulted.

[16:53] <pmichaud> afk, lunch

[16:53] <pmichaud> [particle]: any chance you could make it to #phasers today at 1900 utc?

[16:53] <pmichaud> (2h07m from now)

[16:54] <pmichaud> one of the discussion items will be timing of the R* release (and what it will be based on) -- your contributions/opinions would be welcomed.

[16:54] <pmichaud> afk, lunch

[16:54] <[particle]> pmichaud: i believe so, i'm sitting in that channel now

[17:00] *** rob left
[17:12] *** dakkar left
[17:15] <ash__> is there a non-unicode alternative to: $¢ ? 

[17:16] <moritz_> I don't think we can use any non-unicode characters in the chat her

[17:16] <moritz_> here

[17:17] <[particle]> someone needs to write English.pm6

[17:17] <ash__> i mean, is there a way to tyepe that with ascii only? 

[17:17] <ash__> type* 

[17:17] <ash__> kinda like how you can use << or « 

[17:17] <[particle]> perl 6 assumes unicode support

[17:18] <moritz_> ash__: don't think so

[17:18] *** arnsholt joined
[17:18] <[particle]> i don't know of an ascii-equivalent for $¢

[17:18] <[particle]> should be easy to search STD.pm for it

[17:18] <ash__> got ya, so far, most unicode key parts have had some way of doing it without 

[17:18] <arnsholt> takadonet: *prod?*

[17:19] <moritz_> ash__: that's right, but $¢ isn't something that most users will need

[17:19] <ash__> makes sense, but what if you make parrot without icu? will it still work? (just wondering) 

[17:20] <[particle]> then parrot will be latin-1 only

[17:20] <[particle]> and still have that char iirc

[17:21] <[particle]> but upcase/downcase/etc will fail for unicode

[17:21] <moritz_> it's not like parrot can't store and compare UTF-8 strings without icu

[17:21] <[particle]> take that with a grain of salt, i'm not remembering the details precisely

[17:22] <moritz_> and variable lookup is just lookup in hash tables

[17:22] <ash__> i just wasn't sure if it could parse $¢ without icu

[17:22] <[particle]> it'll parse

[17:22] <moritz_> I'm pretty sure it can

[17:22] *** meppel joined
[17:22] <arnsholt> But if the source is UTF-8 $¢ will be interpreted differently, no?

[17:23] *** ggoebel joined
[17:24] <[particle]> ¢ is dec 162 iirc

[17:25] <moritz_> arnsholt: yes, but parrot can still decode UTF-8 to codepoints

[17:25] <[particle]> ascii is 7-bit, so there's room for another 128 characters in a one-byte encoding

[17:25] <TimToady> latin-1 is just Unicode restricted to <256

[17:25] <[particle]> unicode puts ascii and latin1 in the first byte

[17:26] *** Mowah joined
[17:26] <[particle]> since ¢ is latin1, it's unicode and ascii (in the usa)

[17:26] *** meppl left
[17:27] <[particle]> other locales can use a different charset past ascii in one-byte encodings, but then they're not unicode-compliant

[17:28] <moritz_> well

[17:28] <moritz_> the just don't have the byte value = codepoint identity

[17:29] <[particle]> which means they have to be transcoded

[17:29] <TimToady> which must be declared explicitly

[17:29] *** meppel is now known as meppl

[17:30] <TimToady> S02:52 requires the default to be Unicode, alwys.

[17:32] <TimToady> and we're not gonna touch the locale mess

[17:32] <TimToady> (without an explicit declaration to do so)

[17:32] *** xabbu42 joined
[17:32] <moritz_> +1

[17:32] <[particle]> so we're always safe in assuming <256 is ascii+latin1.

[17:33] <[particle]> unless there's an explicit declaration otherwise

[17:33] <TimToady> <256 *what* is the question :)

[17:33] <[particle]> :)

[17:33] <TimToady> you are not safe if you mix up UCS-1 with UTF-8

[17:34] <moritz_> well, there are no byte values >= 256

[17:34] <moritz_> so I kinda hope [particle] is talking about codepoints

[17:34] <TimToady> ah, a european admitting that "octets" is redundant...what is this world coming to?  :)

[17:37] * TimToady ignores the fact that there used to be other byte sizes back in the day...

[17:37] <[particle]> \n\r

[17:37] <[particle]> ebcdic

[17:38] <[particle]> ...there's a lot to ignore...

[17:38] <[particle]> nobody has proposed 40-bit floats

[17:38] <TimToady> 12-bit words are pretty awesome

[17:39] <[particle]> like a clarinet

[17:39] <TimToady> I don't like licorice

[17:40] <arnsholt> Mmmm. Salmiak =D

[17:41] *** xabbu42_ joined
[17:41] *** xabbu42 left
[17:41] *** xabbu42_ is now known as xabbu42

[17:43] <Su-Shee> salty ones!

[17:43] *** rgrau joined
[17:44] <pmichaud> back again

[17:45] <Su-Shee> arnsholt: meet my favorite shop around the corner: http://www.kado.de ;)

[17:46] <arnsholt> =D

[17:46] <arnsholt> Om nom nom...

[17:47] <Su-Shee> _great_ varieties from all countries.

[17:47] <TimToady> <sorear> TimToady: Why is @::ORIG kept as numbers instead of characters?

[17:47] <TimToady> well, two reasons

[17:47] <TimToady> an array of integers takes less memory

[17:48] <TimToady> but the main reason is to move into the mindset where characters are integers, to make it easy to look up character properties by numeric index

[17:50] <TimToady> and backtranslating from the integer with chr() is considered a temporary hack till we get the Unicode tables into Perl 6 directly

[17:50] <TimToady> I agree that it would be very nice if p5 would let you look up char properties by integer

[17:51] <TimToady> but it doesn't as far as I know

[17:51] *** diakopter joined
[17:51] *** rgrau is now known as kidd

[17:52] *** synth joined
[17:56] <TimToady> <sorear> TimToady: what is the purpose of %lexer_cache?  Surely anything in %lexer_cache would also be in %::LEXERS

[17:57] <TimToady> yes, I thought it was redundant when it was added (I forget by whom), but there was some contradictory NYTProf data at the time, so I left it in as relatively harmless

[18:01] * diakopter 'twasn't

[18:01] <TimToady> <sorear> TimToady: what is the purpose of CursorBase.pmc 1940-1973?

[18:01] *** clintongormley joined
[18:01] <TimToady> not sure what you're asking here, so I'll assume you figgered it out unless you ask something more specific... :)

[18:02] <diakopter> I think there were some commits after that q

[18:02] *** bjarneh left
[18:03] <diakopter> (that may have offset the line numbers)

[18:08] *** broquaint left
[18:17] <pmichaud> #phasers in 43

[18:18] <pmichaud> I just pasted a longish report and some discussion items

[18:22] *** xabbu42_ joined
[18:22] *** xabbu42 left
[18:22] *** xabbu42_ is now known as xabbu42

[18:26] <TimToady> <sorear> TimToady: Can you explain how $::PREFIX is used in RE_ast?

[18:28] <TimToady> $::PREFIX is supposed to track the fates that have already been determined for the current alternative

[18:29] <TimToady> there is likely a cleaner way to do this with parameters...

[18:32] *** xabbu42_ joined
[18:32] *** xabbu42 left
[18:32] *** xabbu42_ is now known as xabbu42

[18:34] *** xabbu42_ joined
[18:34] *** xabbu42 left
[18:34] *** xabbu42_ is now known as xabbu42

[18:37] *** am0c left
[18:37] *** pyrimidine joined
[18:38] *** Wolfman2000 joined
[18:39] *** solarion joined
[18:51] *** Schwern left
[18:53] *** masak joined
[18:55] <Tene> hallo, masak. :)

[18:55] <masak> hullo, Tene. :)

[18:56] <sorear> What's an inversion list?

[18:56] <TimToady> see google

[18:56] <TimToady> but short answer, run length encoding that flips binary state

[18:56] *** xabbu42 left
[18:56] *** xabbu42_ joined
[18:59] <lue> ohai

[18:59] *** xabbu42_ left
[18:59] *** xabbu42 joined
[19:00] <TimToady> but I don't think it buys much over a list of range transition values where even/odd indexes tell you whether it was a 0 or 1 range

[19:01] <pmichaud> that's what I'm actualy using

[19:01] <masak> #phasers in 0. :)

[19:01] <TimToady> on a low level, inversion list can do subtract and compare with 0

[19:01] <pmichaud> basically, (start,end) pairs

[19:01] *** perlygatekeeper left
[19:01] <TimToady> which may be faster than comparing two nums

[19:04] <EvanCarroll> is damian on freenode?

[19:04] <PerlJam> EvanCarroll: no

[19:04] *** xabbu42_ joined
[19:04] *** xabbu42 left
[19:04] *** xabbu42_ is now known as xabbu42

[19:04] *** cono left
[19:04] <TimToady> EvanCarroll: email is your best bet

[19:05] <EvanCarroll> yea, I emailed

[19:05] <EvanCarroll> =(

[19:06] *** cono joined
[19:07] <EvanCarroll> how close is regexp::grammars to perl6 ?

[19:08] *** xabbu42_ joined
[19:08] *** xabbu42 left
[19:08] *** xabbu42_ is now known as xabbu42

[19:08] <moritz_> it's inspired by Perl 6

[19:09] <tadzik> oh, by the way, Perl6 inspirations. Anything like Moose native traits and 'handles' in Perl6?

[19:09] <TimToady> but it gets no lovin from P5, so it's different in many ways

[19:09] <TimToady> tadzik: those notions were in P6 first :)

[19:10] <EvanCarroll> I think p6 has real type traits

[19:10] <tadzik> I thought so at the first thought, but didn't fint it in docs

[19:10] <tadzik> I wasn't reading specs though

[19:10] <EvanCarroll> I've seen `0 with true` in a doc somewhere

[19:10] <EvanCarroll> or something like that

[19:10] *** PZt left
[19:11] <tadzik> everything that's in Moose is in Perl 6 also?

[19:11] <TimToady> no, there are some divergences

[19:11] <tadzik> is there anything worthy missing?

[19:12] <TimToady> I don't think there's anything major that can't be done some other equivalent way, but we'll find out more when Moosers start coming to P6 after R* is out

[19:13] <tadzik> ah, R* is for Rakudo Star

[19:13] <EvanCarroll> it comes before Rakudo--

[19:13] <tadzik> at first I thought you're avoiding the name "Rakudo" not to bring bad luck or something :)

[19:13] <tadzik> Rakudo--?

[19:13] <masak> attributes have metaclasses (or meta-somethings) in Moose. they're slightly less magical in Perl 6.

[19:14] <sorear> literal: one thing that could use updating is your synopsis mirrors

[19:14] <EvanCarroll> <rule: pair>            <delim=(\'|\"|\$\$)> <char=(.)> <delim2=(?{ $MATCH{delim} })>

[19:14] <EvanCarroll> why doesn't that work =(

[19:15] <moritz_> EvanCarroll: doesn't look very P6ish to me

[19:15] <ash__> is that perl6? 

[19:15] <moritz_> EvanCarroll: if you translate it to Perl 6 grammars first, I'm sure somebody will try to help you here

[19:15] <EvanCarroll> it is Regexp::Grammars

[19:15] <EvanCarroll> =(

[19:16] <moritz_> and thus mostly off-topic

[19:16] <moritz_> unless you make it on-topic by translating it to Perl 6.

[19:16] <EvanCarroll> Perl 6 will run on parrot, which will run perl 5.

[19:16] *** xabbu42 left
[19:16] <EvanCarroll> Thus, on topic.

[19:16] *** xabbu42 joined
[19:16] * lue walks around the back for a second entrance :)

[19:16] <TimToady> what's this, guilt by association? :)

[19:17] <ash__> Parrot doesn't run on perl 5... parrots something else 

[19:17] <EvanCarroll> parrot is vm that has/will-have an implimentaiton of perl5.

[19:17] <Tene> That's slightly more on-topic for #parrot on irc.perl.org, and much more on-topic for #perl. :)  More seriously, looks like Regexp::Grammars is sufficiently different from Perl 6 grammars that nobody here thinks they can help you.

[19:17] <EvanCarroll> ponie or something

[19:18] <tadzik> Isn't that Perl 1? (:

[19:18] <EvanCarroll> perl1 = punie.

[19:18] <tadzik> Punie — An implementation of Perl 1.0

[19:18] <tadzik> ah

[19:18] <EvanCarroll> moreover, I'm klined from irc.perl.org, and banned from #perl.

[19:18] <tadzik> :D

[19:18] <tadzik> what have you done?

[19:19] <EvanCarroll> http://search.cpan.org/~ecarroll/MooseX-Types-DateTime-ButMaintained-0.11/lib/MooseX/Types/DateTime/ButMaintained.pm

[19:19] <Tene> EvanCarroll: ponie is long dead, and I don't know of anybody working on it in recent history.  The current work is embedding perl5, which is working to some degree now.

[19:19] <moritz_> EvanCarroll: being banned from irc.perl.org doesn't make perl 5 questions here more on-topic

[19:20] <moritz_> EvanCarroll: please do try to stay on-topic here.

[19:21] <Tene> I don't know that we're really all that grumpy about on-topic.  We've had plenty of off-topic discussions in here, and it's nto really otherwise busy ATM.

[19:21] <TimToady> well, there's OT, and then there's OT that requires studying up on something OT

[19:21] <moritz_> Tene: it's about signal-noise ratio

[19:21] <moritz_> Tene: if somebody contributes much signal, quite a bit noise is also OK

[19:22] <moritz_> only noise is not appreciated

[19:22] <TimToady> nobody here wants to study up on Regex::Grammars

[19:22] <lue> (There's OnT, acceptable OfT, and OfT.)

[19:22] <EvanCarroll> I would have assumed I wasn't the only person using regex::grammars

[19:22] <EvanCarroll> =(

[19:22] <EvanCarroll> guess I'm wrong

[19:22] <Tene> If anyone here *already knew* about Regexp::Grammars, I wouldn't have a problem with them answering a question.

[19:23] <TimToady> me either

[19:23] <Tene> I didn't see a request that people go do research, either.

[19:24] <literal> sorear: yeah, I think I'm gonna make grok download them to ~/.grok/ and allow the user to do something like grok --update

[19:24] <TimToady> anyway, you might need to be patient with email to TheDamian--remember he's down under, and electrons flow differently therr

[19:25] <TimToady> *there

[19:25] <moritz_> right, opposite electron spin and all

[19:26] <Tene> EvanCarroll: good luck. :)

[19:26] <EvanCarroll> I think I'm going to find a different clever way to write a sql parser

[19:27] <masak> EvanCarroll: Perl 6 grammars, for example :)

[19:27] <lue> I thought Austrailia got negitrons :)

[19:27] <lue> [or whatever the Antimatter of electron is]

[19:27] <masak> lue: also known as "electrons"...

[19:27] <moritz_> lue: electrons *are* negatively charged already :-)

[19:27] <arnsholt> lue: positron

[19:27] <arnsholt> Is the anti-particle for electrons

[19:28] <lue> Yes. Off to send some positrons

[19:28] <masak> lue: you should read more Asimov.

[19:28] * jnthn back from dinner and a nice stroll :-)

[19:28] <masak> jnthn: #phasers!

[19:28] <TimToady> EvanCarroll: also consider that TheDamian is probably furiously working on some new presentations for upcoming confs

[19:28] *** sykes_ joined
[19:29] <jnthn> masak: It's in 27 minuts?

[19:29] <PerlJam> jnthn: now!

[19:29] <masak> jnthn: -31

[19:29] <jnthn> oh wtf

[19:29] <moritz_> :-)

[19:29] <PerlJam> jnthn: good timing though :)

[19:29] <masak> jnthn: I should have reacted earlier today when you said "10 pm" aloud.

[19:29] *** jaldhar left
[19:29] <moritz_> you missed the heated discussion, and can now overthrow our concensus

[19:29] <masak> jnthn: we're in the same time zone, and my #phasers began at 9 pm :)

[19:30] * lue finds out about phasers

[19:30] <jnthn> masak: apart from, I'm not in the same timezone :-)

[19:31] <jnthn> Kiev is +1

[19:31] <EvanCarroll> I think the problem is that code like this: <delim2=((?{$MATCH{delim}}))> doesn't pop the capture off of the regex stack

[19:31] <EvanCarroll> so it remains and you can recapture it

[19:31] <masak> jnthn: then I'm stumped.

[19:31] <jnthn> Unfortunately, the clock I was looking at was...still showing me the time at home. :-/

[19:31] <EvanCarroll> or it just writes the output of the code to delim2 and skips the capture entirely.

[19:31] <masak> oh, that makes sense.

[19:32] <arnsholt> Does rakudo handle block labeling?

[19:32] <moritz_> nope

[19:32] <arnsholt> Right. That explains why I can't get it to work ^^

[19:33] <masak> arnsholt: workaround: Bool variables, if statements, manual next/redo/last 

[19:33] *** azert0x left
[19:34] <arnsholt> Yeah, that's my plain. A variable outside the inner block and then unlabeled last

[19:34] <arnsholt> plain -> plan

[19:34] <masak> yup.

[19:34] <masak> be glad you don't have nested loops. :/

[19:34] <masak> also known as "cf GGE"

[19:35] *** ShaneC joined
[19:35] <arnsholt> I'm implementing CKY. There will be nested loops

[19:35] *** snarkyboojum joined
[19:35] * Su-Shee likes date nr 4. then I hopefully get more dbi stuff done.

[19:35] <arnsholt> But I won't need to control any of them with any kind of precision

[19:35] <masak> arnsholt: it's not hard or anything. it's just a hassle.

[19:35] <arnsholt> Yeah, I can imagine

[19:35] <masak> one strongly wishes for labels on blocks.

[19:37] <lue> afk

[19:37] <EvanCarroll> http://stackoverflow.com/questions/3048407/using-perls-regexpgrammars-how-do-i-make-a-capture-dependant-on-match

[19:37] <EvanCarroll> there we go.

[19:37] *** Chillance joined
[19:38] <masak> EvanCarroll: there we go what? It's still a Perl 5 question.

[19:38] <masak> this is #perl6.

[19:40] *** ShaneC left
[19:41] <arnsholt> What's the correct way to extract the last element of an array?

[19:41] <Su-Shee> arnsholt: I use -1

[19:41] <masak> @array.pop :)

[19:41] <masak> Su-Shee: that's *-1

[19:42] <arnsholt> masak: But I just pushed() it onto the array! =)

[19:42] <PerlJam> arnsholt: there's also @array[@array.end]

[19:42] <Su-Shee> "I use -1 first, then realize something is wrong and try all other options" :)

[19:42] <masak> arnsholt: then what do you need it out again for?

[19:42] <masak> rakudo: my @a; @a[-1]

[19:42] <p6eval> rakudo 272191: OUTPUT«Cannot use negative index on arrays␤  in 'Array::postcircumfix:<[ ]>' at line 2612:CORE.setting␤  in main program body at line 11:/tmp/xMVnA3hVmo␤»

[19:43] <TimToady> "extract" is underspecified

[19:43] <TimToady> is it destructive?

[19:43] <TimToady> .pop is destructive, .[*-1] is not

[19:43] <arnsholt> Yeah, I meant non-destructive read

[19:44] <Su-Shee> rakudo: my @a = ('cat', 'dog', 'mouse'); @a[*-2].say;

[19:44] <p6eval> rakudo 272191: OUTPUT«dog␤»

[19:44] <masak> arnsholt: seriously. if you just put it in, you don't need to extract it, destructively or non-.

[19:44] <Su-Shee> rakudo: my @a = ('cat', 'dog', 'mouse'); @a[*-1].say;

[19:44] <p6eval> rakudo 272191: OUTPUT«mouse␤»

[19:44] <arnsholt> masak: Yeah, that's what I just changed my code to

[19:44] <sorear> TimToady: as it happens, dfa/CursorBase already has everything in place to get character properties by number.

[19:44] <masak> Su-Shee: parens in the lhs are so Perl 5 :P

[19:44] * PerlJam waits for the *-5 version

[19:44] <masak> er, rhs.

[19:45] <arnsholt> It's just that the code had the push before I realised I needed to do more stuff, so it felt natural to fiddle with the last element rather than do it before

[19:45] <TimToady> sorear: \o/

[19:45] <Su-Shee> masak: I still need to keep a balance between 5 and 6 or I go insane with daily javascript, sql, css on top of all that. ;)

[19:45] <masak> Su-Shee: heh. :)

[19:46] <TimToady> there is no probably with inserting parens for clarity, as long as they don't replace needed whitespace

[19:46] <masak> Su-Shee: yes, I guess I'm too deep in Perl 6 to need that balance.

[19:46] <masak> rakudo: my @a = <cat dog mouse>; say @a.pick

[19:46] <p6eval> rakudo 272191: OUTPUT«dog␤»

[19:46] <TimToady> <> are honorary parens :)

[19:46] <Su-Shee> also, <> suck to type on a german kezboard.

[19:47] <sorear> tadzik: Perl 6 doesn't have a very well-specced metaobject layer yet

[19:47] <moritz_> everything programming-related sucks on the german keyboard, except the #.

[19:47] <masak> with the right software, all keyboards are US keyboards.

[19:47] <sorear> tadzik: in particular, we don't have metaclass compatibility, or alternate representations

[19:48] <TimToady> sorear: Perl 6 wants the implementations to fight over metamodels :)

[19:48] <tadzik> mhm

[19:48] <Su-Shee> moritz_: on all non-english essentially. ;)

[19:49] <tadzik> really?

[19:49] <tadzik> I have no problems on my Polish :)

[19:49] <tadzik> „”, «», everything

[19:49] <Su-Shee> tadzik: no altgr for {}?

[19:49] <tadzik> no, just shift

[19:50] <Su-Shee> and []?

[19:50] <tadzik> nothing at all

[19:50] <Su-Shee> "essentially non-english but polish.." ;)

[19:50] <tadzik> all the fancy chars are on… chars

[19:50] <tadzik> not on symbols

[19:50] *** rindolf joined
[19:51] <rindolf> rakudo: say "ש".chars()

[19:51] <p6eval> rakudo 272191: OUTPUT«1␤»

[19:51] <sorear> dfa/Cursor represents character classes using DNF.

[19:51] <sorear> This may be overkill

[19:51] <rindolf> rakudo: say "Hello+ש".chars()

[19:51] <p6eval> rakudo 272191: OUTPUT«7␤»

[19:51] *** patspam left
[19:51] <masak> rakudo: say "ש".uc

[19:51] <p6eval> rakudo 272191: OUTPUT«ש␤»

[19:51] <masak> huh!

[19:51] <arnsholt> Is that a shin?

[19:51] <masak> oh, RTL.

[19:52] <moritz_> arnsholt: yes

[19:52] <arnsholt> Then that's the correct answer, AFAIK. No upper/lower case distinction in Hebrew

[19:53] <rindolf> arnsholt: yes, it is.

[19:54] <masak> arnsholt: I expected that.

[19:54] <sorear> backlog over.

[19:54] <masak> arnsholt: I didn't expect the ␤ to end up to the left. :) but maybe that only happened on my client.

[19:54] <arnsholt> Ah, right. Bad interpretation of your huh then, my bad

[19:55] <arnsholt> Ah, right. In mine it's on the right =)

[19:55] <arnsholt> But which of our clients are in the wrong, I have no idea =)

[19:55] <masak> it jumped over to the right here too when I marked it. :/

[19:55] <masak> Emacs seems a bit undecided on the RTL thing.

[19:55] <masak> or maybe it's just helpful in an inexplicable way.

[19:55] <arnsholt> Heh. The joys of mixing RTL and LTR

[19:56] <arnsholt> Ah yes. Encoding and Emacs is loads of fun I've been led to understand =)

[19:56] <rindolf> Apparently when szabgab demonstrated it in the console, the Hebrew letters were reported as occupying more than one char.

[19:57] <masak> rindolf: results with -e can vary sometimes.

[19:57] <masak> rindolf: because the encoding of the shell plays into it.

[19:57] <rindolf> masak: it was the REPL.

[19:57] <masak> rindolf: don't get me started on the REPL :(

[19:58] <masak> actually, I don't remember if the REPL has encoding issues. maybe someone sle does.

[20:01] <moritz_> it's woefully unicode-unware

[20:02] <masak> s/sle/else/

[20:03] *** eternaleye left
[20:04] *** Psyche^ joined
[20:07] *** colomon joined
[20:07] *** Patterner left
[20:07] *** Psyche^ is now known as Patterner

[20:08] *** xabbu42_ joined
[20:08] *** xabbu42 left
[20:08] *** xabbu42_ is now known as xabbu42

[20:08] *** broquaint joined
[20:10] <frooh> is there a web based tryperl6 any more?

[20:11] <masak> frooh: not yet.

[20:11] <frooh> ok, I know there was one with pugs for a while

[20:11] <masak> frooh: moritz_++ has plans to bring one back up for Rakudo.

[20:11] <moritz_> and you can help!

[20:11] <moritz_> the plan is to split it up into byte-sized tasks

[20:11] <frooh> well, I was just gonna show a coworker some examples :-)

[20:12] <TimToady> in moderation, you can do them here with the evalbot

[20:12] <moritz_> rakudo: say ?open('README')

[20:12] <p6eval> rakudo 272191: OUTPUT«1␤»

[20:12] <frooh> eh, not now :-)

[20:12] <moritz_> you can also message the evalbot

[20:12] <sorear> TimToady: see _get_unicode_map in dfa/CursorBase.pmc; it's pretty straightforward

[20:13] * frooh hasn't looked at things since nqprx was made master

[20:13] <TimToady> btw, we should do an audit of all cursor functions and either _ or CAP all the ones that shouldn't really be used by users or conflict with their grammar rules

[20:14] *** alester joined
[20:14] <masak> frooh: we're sort of starting to see things get back to normal, and in some cases muchly improved.

[20:14] * Su-Shee starts watching perl6 Digest::MD5 on github.

[20:14] <colomon> rakudo: say 'Y'...'z'

[20:14] <p6eval> rakudo 272191:  ( no output )

[20:15] <colomon> rakudo: say ('Y'...'z').batch(10)

[20:15] <p6eval> rakudo 272191: OUTPUT«YZAAABACADAEAFAGAH␤»

[20:15] <masak> colomon: what I'd expect. and 'Y'...'z' never finishes.

[20:15] <TimToady> colomon: do you think it makes sense to make an exception for 1 char on both ends

[20:15] <colomon> TimToady: no idea.

[20:16] <tadzik> Su-Shee: link?

[20:16] <colomon> I was just trying to sort out what to do with Range and its tests

[20:16] <TimToady> so that 'Y'...'z' will alwasy just march up codepoints and stop

[20:16] <TimToady> it seems to be what the naive user expects

[20:16] *** azert0x joined
[20:16] <Su-Shee> tadzik: http://github.com/cosimo

[20:16] *** pyrimidine left
[20:17] <TimToady> since Perl is one of those languages that doesn't distinguish chars from strings much, when people write a single-character string, they're usually thinking 'char'

[20:17] <moritz_> in current Rakudo, can a module somehow access the lexical scope from which it was used? PIR magic is fine...

[20:17] <masak> TimToady: I'm inclining every so subtly towards "yes".

[20:17] <TimToady> I guess I'm asking if anyone sees a downside to forcing single chars to ignore the a..z ranges

[20:17] <masak> s/every/ever/

[20:17] <moritz_> (I mean I'm fine if it's only possible with PIR magic)

[20:17] *** moritz_ sets mode: +ooo masak colomon tadzik

[20:17] <masak> \ooo/

[20:17] <moritz_> :-)

[20:18] <masak> look, a three-headed monkey!

[20:18] *** Guest16581 left
[20:18] <masak> s/>>/ behind you/

[20:19] <TimToady> I think I'll go ahead and spec the single-char exception then

[20:19] * moritz_ turns around

[20:19] <moritz_> uh, I fell for the oldest trick ever!

[20:19] <masak> moritz_: I seem to have used up my only time that trick works. :)

[20:19] <moritz_> :-)

[20:19] <tadzik> http://github.com/cosimo/perl6-digest-md5/blob/master/lib/Digest/MD5.pm

[20:20] <tadzik> beautiful

[20:20] <moritz_> jnthn, pmichaud: I'm trying to get a mostly-working safe mode for rakudo again, but I don't know how to do it in a module...

[20:20] <moritz_> I *could* add a WEIRDLY_NAMED_SUB to the setting, which removes offending symbol from the caller's lexical scope

[20:20] *** xabbu42_ joined
[20:20] *** xabbu42 left
[20:20] *** xabbu42_ is now known as xabbu42

[20:20] <moritz_> would that work for you?

[20:23] <pugssvn> r31269 | colomon++ | [t/spec] Refudge to work with list branch. 

[20:24] <pmichaud> moritz_: its fine with me.  You could also stick a sub into another package.

[20:24] <moritz_> right; I just can't call it automatically from 'use'

[20:25] <pmichaud> in some ways, Safe.pm just sounds like another setting :)

[20:26] *** Su-Shee left
[20:27] <sorear> run STD as a pre-verifier, since it refuses to parse Q:PIR, pir::, and panics on any unknown function

[20:28] <sorear> remove run/runinstead/open/etc from CORE.setting first

[20:28] <moritz_> sorear: that's a nice idea, but *very* slow

[20:28] <moritz_> anyway, getting late here, and it seems Safe.pm isn't a LHF

[20:29] <moritz_> will investigate more soon

[20:29] <moritz_> bbl&

[20:29] <moritz_> erm

[20:29] <moritz_> bb tomorrow :-)

[20:31] *** Guest16581 joined
[20:31] <sorear> App::Persistant

[20:31] <sorear> the only slow part of STD is running the Perl5 parser over 60,000 lines of generated code

[20:31] <sorear> once it's running, it's a bit faster than the rakudo parser

[20:33] *** eternaleye joined
[20:34] *** xabbu42_ joined
[20:34] *** xabbu42 left
[20:34] *** xabbu42_ is now known as xabbu42

[20:35] <pugssvn> r31270 | lwall++ | [S03] guarantee a monotonic function when single characters are used in a series 

[20:38] *** PZt joined
[20:39] <colomon> TimToady: next question: is there any real reason to have RangeIter now, if $a .. $b always generates $a ... $b?

[20:39] *** hercynium joined
[20:39] <colomon> (Though hmmm, what about $a ..^ $b?)

[20:39] <pmichaud> colomon: I thought about that also, and decided that the endpoints were a reason to switch

[20:39] <pmichaud> another reason is that we might need  RangeIter.perl someday

[20:40] <pmichaud> and that's much easier to handle than an arbitrary gather/take block

[20:41] <colomon> "easier to handle" is my #1 reason.

[20:41] <colomon> but it starts getting ugly if Range needs to duplicate a bunch of series code.

[20:41] <colomon> hmmm, maybe there's a clever refactor waiting there.

[20:42] <colomon> pmichaud: getting a Junction infinite recursion in S03-metaops/cross.t

[20:42] <pmichaud> it's always possible that RangeIter is really SeriesIter

[20:42] <tadzik> hmm, does MAIN params work in rakudo

[20:42] <tadzik> ?

[20:42] <pmichaud> and that Range.iterator just creates a SeriesIter

[20:43] <pmichaud> colomon: okay, I'll look at the infi recursion

[20:43] *** armagad joined
[20:43] *** xabbu42_ joined
[20:43] <pmichaud> I looked at it briefly last night but was too tired to do much about it, and now I've forgotten if I found anything (or what I found :)

[20:43] *** xabbu42 left
[20:43] *** xabbu42_ is now known as xabbu42

[20:44] <colomon> Don't stress too much about it for my sake, just wanted to ping you on it.

[20:44] <pmichaud> colomon: I'd be really really really happy if you could continue RangeIter from where I left off

[20:44] <pmichaud> I don't plan to tackle it much more myself

[20:44] <colomon> pmichaud: that's what I'm trying to figure now.  :)

[20:44] <colomon> it never was right before, and I thought I'd try to get it a bit better this time around.

[20:45] <pmichaud> colomon++

[20:45] *** ash__ left
[20:46] <colomon> and of course, the relevant rules have changed about ten times since I implemented RangeIter back in January.  :)

[20:48] <pmichaud> ten is a lot.  

[20:48] <colomon> you know how it is; having an implementation helps find problems in the spec.  

[20:48] <colomon> ;)

[20:51] <TimToady> we do define ...^ somewhere

[20:51] <TimToady> though not ^...

[20:52] <rindolf> BTW, what is the :step/:by/etc. adverb to the range operator? How one should write it?

[20:52] <rindolf> 1,3...11

[20:52] <TimToady> that works

[20:52] <rindolf> rakudo: (1,3..11).say

[20:52] <p6eval> rakudo 272191: OUTPUT«134567891011␤»

[20:52] <TimToady> but only with 3 dots

[20:52] <rindolf> rakudo: (1,3...11).say

[20:52] <p6eval> rakudo 272191: OUTPUT«1357911␤»

[20:53] <TimToady> there is no :by anymore for ..

[20:53] <TimToady> you must use ... for a non-1 step

[20:53] <masak> std: 1 ...^ 5

[20:53] <p6eval> std 31269: OUTPUT«ok 00:01 108m␤»

[20:53] <TimToady> ranges are just "intervals" these days

[20:54] <TimToady> but we let you use an interval for a counting sequence

[20:54] <rindolf> TimToady: we discussed it in szabgab's presentation.

[20:54] <colomon> TimToady: really?  ...^ is news to me.

[20:54] <masak> to me as well.

[20:55] <masak> why ... and ...^ but not the other two?

[20:56] <TimToady> it's there at the end of the series operator sectoin

[20:56] <TimToady> *io

[20:56] *** Targhan_ joined
[20:56] *** dual left
[20:57] <TimToady> mainly because ...^ seems easier, and it's not clear what you're excluding on the front if you say 1,2,3 ^... 100

[20:57] <masak> oh yes, there it is. S03:2086.

[20:57] *** rv2733 joined
[20:57] *** justatheory left
[20:57] <masak> TimToady: thought so. sounds sane.

[20:58] <TimToady> your line number is pre-last-checking

[20:58] <TimToady> *in

[20:58] <TimToady> S03:2107 now

[20:58] <masak> ok.

[20:59] <masak> does it still say "The compile\nmay complain"?

[20:59] <masak> should there be an -r on "compile"?

[21:00] *** tedv left
[21:00] *** clintongormley left
[21:01] <TimToady> either the compile or the compiler may complain :)

[21:01] <masak> :)

[21:02] <masak> just checking that I'm getting this right: S03:2048 says `'9'..'0'` -- is that an example of an empty range still being empty under the new one-char exception?

[21:06] <pugssvn> r31271 | lwall++ | [S03] typos spotted by masak++ 

[21:07] <masak> having spotted today's typos, I withdraw to my dwelling for the evening.

[21:07] <masak> see you tomorrow, #perl6.

[21:07] <TimToady> \o

[21:07] <colomon> o/

[21:08] *** justatheory joined
[21:09] *** masak left
[21:11] <colomon> Mouth is starting to unnumb, and it hurts.  :(

[21:11] <jnthn> Aww.

[21:11] *** foodoo left
[21:13] *** tadzik left
[21:13] *** whiteknight joined
[21:13] <colomon> on the plus side, the largish hole in that one tooth is now filled in.

[21:14] <jnthn> In the long run, I think the plus side will win out. :-)

[21:15] <TimToady> if it doesn't you'll be non-plussed

[21:17] *** dual joined
[21:17] <colomon> I'm just hoping that bassoon playing doesn't hurt tonight.

[21:18] *** bphillips left
[21:25] <pmichaud> http://nopaste.snit.ch/21272  # lazy slurpies

[21:27] <colomon> pmichaud: crazy!  \o/

[21:28] <rindolf> Yes, "ש".chars() in the REPL yields 2.

[21:28] <TimToady> I assume this all naturally fixes the two-gather bug

[21:28] <colomon> does it work the same atm if you take make it non-slurpy?

[21:28] <TimToady> or wait, that was the closure thing

[21:28] <pmichaud> TimToady: yes, that's the closure issue.  That comes next :)

[21:28] <pmichaud> colomon: yes, it works the same with non-slurpies

[21:29] <rindolf> "é".chars() too.

[21:29] <TimToady> eventually it will say 1

[21:29] <TimToady> when we switch to really processing graphemes

[21:29] <pmichaud> it's possible the repl is forgetting to set utf-8 encoding again.

[21:29] <pmichaud> and... what TimToady++ said

[21:30] <TimToady> and yes, what pmichaud++ said, these should already have been doing 1 as codepoints

[21:31] <TimToady> rakudo: say "ש".chars()

[21:31] <p6eval> rakudo 272191: OUTPUT«1␤»

[21:31] *** Mowah left
[21:31] *** Trashlord left
[21:32] <TimToady> rakudo: say "𠯭".chars

[21:32] <p6eval> rakudo 272191: OUTPUT«1␤»

[21:32] <TimToady> at least it doesn't fib about plane 1 chars

[21:34] *** azert0x left
[21:34] *** rindolf left
[21:34] <TimToady> nap &

[21:34] *** Ross left
[21:48] *** jferrero joined
[21:55] *** skids left
[22:02] <lue> ohai [ooh unicode discussion!]

[22:03] <Tene> pmichaud: you understand the closure issue and know how to fix it?

[22:06] <pmichaud> Tene: yes.

[22:06] <pmichaud> it's already been fixed in nqp-rx.

[22:06] <Tene> Ah.

[22:06] <pmichaud> it's the same fix for rakudo, but the fact that rakudo wraps all of its codeblocks (subs) in rakudo-specific objects makes it trickier on the codegen side

[22:07] <pmichaud> because it's not sufficient to clone the codeblocks -- one has to have matching wrappers to go with them.

[22:07] <Tene> nodnod

[22:10] <colomon> > my @a = 1, 2, 3; @a.push: <a b c>; say @a.perl

[22:10] <colomon> [1, 2, 3, "a", "b", "c"]

[22:10] <colomon> that's list branch

[22:10] <colomon> rakudo:  my @a = 1, 2, 3; @a.push: <a b c>; say @a.perl

[22:10] <p6eval> rakudo 272191: OUTPUT«[1, 2, 3, "a", "b", "c"]␤»

[22:10] <colomon> hmmm.

[22:11] <colomon> oh.

[22:11] <colomon> rakudo:  my @a = 1, 2, 3; @a.push: [5, 4]; say @a.perl

[22:11] <p6eval> rakudo 272191: OUTPUT«[1, 2, 3, [5, 4]]␤»

[22:11] <colomon> > my @a = 1, 2, 3; @a.push: [5, 4]; say @a.perl

[22:11] <colomon> [1, 2, 3, 5, 4]

[22:11] <pmichaud> ugh

[22:11] <colomon> there we go, that's the bit that's giving me trouble.

[22:11] <pmichaud> yeah, okay, I know what's wrong there.

[22:11] <pmichaud> actually, I don't.  hrm.

[22:12] <lue> I don't see it, unless it should be [1, 2, 3, [5, 4]]

[22:12] <pmichaud> it should be [1,2,3,[5,4]]

[22:13] *** Guest23195 left
[22:13] <pmichaud> testing fix.

[22:16] <pmichaud> > my @a = 1,2,3;  @a.push: [5,4];  say @a.perl

[22:16] <pmichaud> [1, 2, 3, [5, 4]]

[22:16] <pmichaud> better?

[22:16] <pmichaud> (I love fixes that make code shorter.)

[22:17] *** eternaleye left
[22:19] <pmichaud> ah, but it points to a different problem.

[22:19] <pmichaud> hrm.

[22:20] *** dolmen joined
[22:22] * pmichaud tries a different fix.

[22:25] *** Wolfman2000 left
[22:26] *** Guest16581 left
[22:27] *** rv2733 left
[22:30] <pmichaud> and with this fix, S32-array/push.t now passes!

[22:31] <pmichaud> pushed as 1fe15ce

[22:31] <lue> \o/

[22:35] *** Util joined
[22:41] <Tene> perl6: say (1,3 ... 9).perl

[22:41] <p6eval> rakudo 272191: OUTPUT«(1, 3, 5, 7, 9)␤»

[22:41] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "9"␤    expecting operator or ")"␤    at /tmp/SG0A6VTNd3 line 1, column 14␤»

[22:41] <p6eval> ..elf 31271: OUTPUT«Parse error in: /tmp/mWug_UqEtX␤panic at line 1 column 0 (pos 0): Can't understand next input--giving up␤WHERE: say (1,3 ... 9).perl␤WHERE:/\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in `comp_unit'␤ 

[22:41] <p6eval> ..STD_red/std.rb:21…

[22:44] *** dolmen left
[22:45] <lue> rakudo: my @a = http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2,3],[4,5,6; say @a[(1,2)]

[22:45] <p6eval> rakudo 272191: OUTPUT«===SORRY!===␤Confused at line 11, near "my @a = ht"␤»

[22:45] <lue> rakudo: my @a = [[1,2,3], [4,5,6]]; say @a[(1,2)]

[22:45] <p6eval> rakudo 272191: OUTPUT«␤»

[22:45] <lue> rakudo: my @a = [[1,2,3], [4,5,6]]; say @a(1,2)

[22:45] <p6eval> rakudo 272191: OUTPUT«invoke() not implemented in class 'Array'␤  in main program body at line 11:/tmp/a4AjVhQMMc␤»

[22:46] <lue> rakudo: my @a = [[1,2,3], [4,5,6]]; say @a[1,2]

[22:46] <p6eval> rakudo 272191: OUTPUT«␤»

[22:46] <lue> rakudo: my @a = [[1,2,3], [4,5,6]]; say @a[0,1]

[22:46] <p6eval> rakudo 272191: OUTPUT«1 2 3 4 5 6␤»

[22:47] <lue> something isn't right here...

[22:48] <pugssvn> r31272 | sorear++ | [dfa/Cursor] Small refactor of nfamanip routines to clarify item/list context 

[22:48] <sorear> that's called a slice.

[22:48] <sorear> you are probably looking for multidimensional lookup

[22:49] <lue> yes I am.

[22:49] <sorear> rakudo: my @a = [[1,2,3], [4,5,6]]; say @a[0;1]

[22:49] <p6eval> rakudo 272191: OUTPUT«␤»

[22:49] <sorear> rakudo: my @a = ([1,2,3], [4,5,6]); say @a[0;1]

[22:49] <p6eval> rakudo 272191: OUTPUT«4 5 6␤»

[22:49] <sorear> rakudo: my @a = [1,2,3], [4,5,6]; say @a[0;1]

[22:49] <p6eval> rakudo 272191: OUTPUT«4 5 6␤»

[22:50] <sorear> eh, it won't work until pmichaud++ makes lists stop sucking

[22:50] <lue> alright, at least I know to code the semicolon :)

[22:51] *** mjk joined
[22:52] <sorear> pugs: my @a = [1,2,3], [4,5,6]; say @a[0;1]

[22:52] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ";"␤    expecting "x", octal digit, "o", "b", fraction, exponent, term postfix, operator or "]"␤    at /tmp/3UFMqf4EnX line 1, column 35␤»

[22:52] <sorear> alpha: my @a = [1,2,3], [4,5,6]; say @a[0;1]

[22:52] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "[0;1]"␤in Main (file <unknown>, line <unknown>)␤»

[22:52] <sorear> rakudo: my @a = (1,2,3), (4,5,6); say @a[0;1]

[22:52] <p6eval> rakudo 272191: OUTPUT«2␤»

[22:52] <sorear> oh good, *something* works

[23:04] *** eternaleye joined
[23:11] <pugssvn> r31273 | sorear++ | [dfa/Cursor] extract _nfa_to_dfa from _AUTOLEXgenDFA 

[23:12] <sorear> the automaton converter spans 6 functions and 230 lines... it's a lot bigger than I expected it would be

[23:13] *** xabbu42_ joined
[23:13] *** xabbu42 left
[23:13] *** xabbu42_ is now known as xabbu42

[23:14] <pugssvn> r31274 | sorear++ | [dfa/CursorBase.pmc] Per TimToady++'s recommendation, remove all usage of characters as 1-length strings from the DFA execution engine 

[23:16] <TimToady> std: 74

[23:16] <p6eval> std 31272: OUTPUT«ok 00:01 107m␤»

[23:18] <diakopter> std: r31272: ::OUTPUT«ok 00:01 107m␤»

[23:18] <p6eval> std 31272: OUTPUT«ok 00:01 104m␤»

[23:19] <TimToady> sorear: STD doesn't make from clean currently for me

[23:20] <TimToady> oh, wait, might be unchecked in code

[23:20] *** xabbu42_ joined
[23:20] *** xabbu42 left
[23:20] *** xabbu42_ is now known as xabbu42

[23:21] <TimToady> yes, my check for dup protos caught a dup infix:<=> in the setting :)

[23:24] *** cdarroch left
[23:26] <pugssvn> r31275 | lwall++ | [STD] catch duplicates involving protos as well as onlys 

[23:26] <pugssvn> r31275 | [CORE] remove duplicate infix:<=> found by above check :)

[23:27] *** jferrero left
[23:28] *** xabbu42_ joined
[23:28] *** xabbu42 left
[23:28] *** xabbu42_ is now known as xabbu42

[23:29] <pugssvn> r31276 | lwall++ | [STD's lib/Text.pm6] remove dup proto 

[23:30] *** alester left
[23:32] *** xabbu42 left
[23:32] <TimToady> er, s/Text/Test/

[23:34] <TimToady> rakudo: say [][0-1].WHAT

[23:34] <p6eval> rakudo 272191: OUTPUT«Cannot use negative index on arrays␤  in 'Array::postcircumfix:<[ ]>' at line 2612:CORE.setting␤  in main program body at line 11:/tmp/k8RkENnTx9␤»

[23:34] <TimToady> um, that should be a fail, not a die

[23:35] <lue> what is the difference between a fail & die?

[23:36] <TimToady> rakudo: say [][0-1] //"Caught it"

[23:36] <p6eval> rakudo 272191: OUTPUT«Cannot use negative index on arrays␤  in 'Array::postcircumfix:<[ ]>' at line 2612:CORE.setting␤  in main program body at line 11:/tmp/Qw7pqjFpEg␤»

[23:36] <TimToady> that should say "Caught it"

[23:36] *** armagad left
[23:37] <lucs> Wow. Look at what pronik++ has produced: http://img267.imageshack.us/img267/2687/booka4.pdf

[23:38] *** mikehh left
[23:39] *** mikehh joined
[23:39] <TimToady> we'd like to be able to say, for a given grapheme $g, if @alnum[$g] // extended_NFG_is_alnum($g) { say "It's alnum" }

[23:39] *** pronik joined
[23:39] <TimToady> assuming $g is a positive or negative integer

[23:39] <sorear> what sort of object is @alnum?

[23:39] <sorear> a 256 element bit array?

[23:39] <TimToady> bitmap

[23:40] <TimToady> for important ones, 0x10ffff big

[23:40] <TimToady> but can be done with inversion lists or whatever for less important ones

[23:40] <TimToady> point is, the code is the same

[23:41] <TimToady> rakudo: say 0x10ffff / 4

[23:41] <p6eval> rakudo 272191: OUTPUT«278527.75␤»

[23:41] <sorear> 4?

[23:41] <TimToady> rakudo: say 0x10ffff / 8

[23:41] <p6eval> rakudo 272191: OUTPUT«139263.875␤»

[23:41] <TimToady> sorry, my finger slipped

[23:42] <TimToady> so 140MB is the largest needed bitmap and most will be smaller

[23:42] <sorear> 140 *k* B

[23:42] <sorear> 140MB is half my RAM :(

[23:42] <sorear> why will most be smaller?

[23:44] <TimToady> most people won't be using higher planes

[23:44] <sorear> so the bitmap is lazily extended?

[23:44] <TimToady> well, could be

[23:45] * sorear personally thinks the best way to handle the database is to represent it as a position-independant blob and let the OS demand-load it

[23:45] *** gbacon left
[23:45] <TimToady> or we just decide which bitmaps are worth 140k and which aren't

[23:45] <TimToady> sorear: that may well be

[23:46] <TimToady> that will tend to work well with locality, as the swashes do

[23:47] <TimToady> makes it easy for different processes to share pages as well

[23:47] <TimToady> assuming they're marked readonly

[23:49] <TimToady> of course, this may not work out well for your typical phone OS... :)

[23:59] <lue> ...which is why you use Meego :)

[23:59] <pugssvn> r31277 | lwall++ | [CORE] add CallFrame and callframe() 

[23:59] <diakopter> ooo

