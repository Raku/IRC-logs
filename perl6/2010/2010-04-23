[00:00] <ash_> my illogical ramblings break even std in unexpected ways 

[00:01] <TimToady> std: say $x::

[00:01] <p6eval> std 30454: OUTPUT«ok 00:01 107m␤»

[00:01] <TimToady> that probably shouldn't be allowed

[00:01] <ash_> oh, am i missing an our in front of sub bar? 

[00:02] <TimToady> that's not my complaint; you're double dereffing with ::

[00:02] *** lestrrat is now known as lest_away

[00:02] <TimToady> once on the Foo:: and once on the $x::

[00:03] <ash_> okay, yeah, makes sense 

[00:03] <TimToady> but yes, you'd want an 'our'

[00:03] <ash_> i just figured you wouldn't be doing  $x.bar since its not really a method

[00:04] <ash_> I also figured it would need some way of signifying its not a method, unless its acting like a hash, then it could be $x<bar> 

[00:06] *** snarkyboojum left
[00:06] <diakopter> pmichaud: food *and* appliances?? :)

[00:07] <TimToady> drums &

[00:07] <diakopter> decommute&

[00:07] <diakopter> fg

[00:08] <diakopter> decommute --for-realz &

[00:09] *** justatheory left
[00:09] *** ash_ left
[00:13] *** BinGOs joined
[00:14] *** jonrafkind joined
[00:14] <jonrafkind> the link to the perl6 grammar from perl6.org is broken. http://svn.pugscode.org/pugs/src/perl6/STD.pm, should have a 6 on the end. that is all

[00:15] <diakopter> jonrafkind: thanks :) would you like to fix it in svn?

[00:16] <jonrafkind> uh ok, but do I have write access?

[00:16] <diakopter> yep; just msg me your email address & desired username

[00:18] *** snarkyboojum joined
[00:18] *** k23z__ left
[00:20] <snarkyboojum> looks like I've missed masak-san

[00:25] *** lichtkind left
[00:27] *** stephenlb left
[00:32] *** ReiniUrban joined
[00:35] *** rurban left
[00:35] *** ReiniUrban is now known as rurban

[00:44] *** yinyin joined
[00:45] *** jonrafkind left
[00:59] * jnthn almost gets a nasty bug fixed, but is too tired to finish the patch up tonight...ah well, tomorrow.

[00:59] <jnthn> o/

[01:02] <takadonet> jnthn:good night

[01:06] *** NoOneButMe joined
[01:07] <pmichaud> 00:06 <diakopter> pmichaud: food *and* appliances?? :)

[01:07] <pmichaud> yes.  New dishwasher, followed by dinner.  :)

[01:08] *** sorear joined
[01:08] *** molaf_ joined
[01:12] *** molaf left
[01:12] *** meppl left
[01:15] *** lest_away is now known as lestrrat

[01:32] <lue> hello there!

[01:32] *** NoOneButMe left
[01:35] *** wknight8111 left
[01:45] *** hercynium joined
[01:45] <Tene> Hi!

[01:46] * lue thinks of looking back into his own personal log (for starters) of #perl6 to see when people are likely to be on...

[01:47] * lue with the aid of P6 scripts to crawl through said log, of course :)

[01:53] <sundar> It looks like there was active discussion till abt two hours back.. till 00:00 GMT that is.

[01:55] <lue> I know. I was too busy playing Majora's Mask since I came home at 8:30 GMT (about) :P

[01:56] <lue> ...that's likely way off

[01:58] *** Psyche^ joined
[01:58] *** agentzh joined
[01:58] <sundar> heh... I was just trying to decide between Halflife and Battle for Wesnoth to play now. :) 

[01:58] <lue> I came home ~15:30 PDT (I know that for sure)

[02:00] <lue> I am soo close to beating MM... just want to get the last bottle, at least 1 more heart piece, and then drink some Chateu Romani and slay Majora! \o/

[02:01] *** Patterner left
[02:01] *** Psyche^ is now known as Patterner

[02:02] *** sorear left
[02:03] *** sorear joined
[02:04] *** snarkyboojum left
[02:05] * allbery_b throws several spanners into the works...

[02:07] <lue> *SCREEECH* aw! You broke the Chameleon circuit on masak and snarkyboojum's TARDIS :)

[02:11] *** snarkyboojum joined
[02:20] *** alester joined
[02:29] *** madalu left
[02:33] *** meppl joined
[02:50] <lue> hello?

[02:57] <sundar> off to sleep... good night || have a good day || $other-appropriate-greeting

[03:00] <sorear> Why does Perl 6 have explicit slot access at all?  Moose omits it, and it's a crucial unfeature there

[03:00] <sorear> The *only* way to access slots is through accessors, which are controlled by the metaclass

[03:00] <sorear> it makes attribute polymorphism work

[03:03] *** justatheory joined
[03:04] *** Khisanth left
[03:09] *** rv2733 left
[03:09] *** justatheory left
[03:11] *** dmpk2k joined
[03:12] *** lue joined
[03:18] *** Khisanth joined
[03:22] <sorear> allbery_b, we meet again

[03:31] *** TiMBuS left
[03:33] <allbery_b> heh

[03:34] * allbery_b busy watching NHL playoff game :)

[03:36] *** sundar left
[03:43] *** meppel joined
[03:46] <lue> rakudo: say :16<8192>

[03:46] <p6eval> rakudo 395433: OUTPUT«33170␤»

[03:47] <lue> rakudo: say "8192".fmt{'%x'} #wrong way *cough*

[03:47] <p6eval> rakudo 395433: OUTPUT«8␤»

[03:47] <lue> ō.o

[03:48] * lue submits rakudobug (that's not what 0d8192 is in hex)

[03:48] *** meppl left
[03:51] *** meppel is now known as meppl

[03:54] <lue> rakudo: say :16<2000>

[03:54] <p6eval> rakudo 395433: OUTPUT«8192␤»

[04:00] <sorear> what's up with the nonsequential spec numbering?

[04:00] <pmichaud> sorear: they tend to follow chapters in the Camel Book.

[04:00] <sorear> S15, S18, S20, ...

[04:00] <sorear> ah

[04:01] <pmichaud> so, S05 is on regular expressions.

[04:01] * sorear should get that sometime

[04:02] <sorear> (there's a camel book chapter on roles?)

[04:02] <pmichaud> One of TimToady++'s insights into describing Perl 6 was that it would be good to minimize forward constraints, which is effectively what one has to do when describing a language in a book.  So the blueprint for Perl 6 design documents was to follow the template given by the Camel.

[04:02] <pmichaud> Well, over time it's obviously become an imperfect fit, of course.

[04:03] <sorear> yes, I wasn't aware if that carried over into the late synopses

[04:03] <sorear> where late = after the apocalypses ended

[04:03] <pmichaud> S29 and S31 follow the camel sequencing, somewhat.

[04:05] * sorear tracks down an online copy of the Camel TOC

[04:05] <pmichaud> http://oreilly.com/catalog/9780596000271

[04:06] <sorear> aye

[04:06] <sorear> tracks was meant as immediate past tense

[04:31] *** jaldhar joined
[04:34] <sorear> What is the status of Rakudo on 2.3+?

[04:34] <lue> afk

[04:34] <pmichaud> Rakudo #28 runs fine on 2.3.0.

[04:35] <pmichaud> We don't have a version of Rakudo that works with current Parrot trunk.

[04:35] <pmichaud> (we're working on it.)

[04:35] <sorear> yes

[04:35] <sorear> mostly wondering if there are enough small projects that a spare tuit would help

[04:38] <pmichaud> alas, gotta run for a bit

[04:39] *** meppl left
[04:42] *** jaldhar left
[04:48] *** Alias_ left
[04:49] *** molaf_ left
[04:52] *** jaldhar joined
[04:53] *** orafu left
[04:54] *** orafu joined
[04:57] *** steinberg left
[04:59] *** kaare joined
[05:00] *** kaare is now known as Guest13068

[05:00] *** ReiniUrban joined
[05:01] *** rurban left
[05:01] *** ReiniUrban is now known as rurban

[05:10] *** Trey left
[05:13] <avar> What broke in parrot 2.3+?

[05:14] *** meppl joined
[05:14] <sorear> bugs

[05:25] <cotto> The immutable strings merge in parrot causes a little breakage.  There's a branch for it in rakudo.

[05:25] <cotto> though bugs are quite possible

[05:26] <sorear> also, 2.3.0 parrots buggily use "our method" semantics for all methods

[05:26] <sorear> which we relied on in a few places

[05:45] *** alester left
[05:50] <cotto> anyone with a commit bit around?

[05:55] <cotto> http://nopaste.snit.ch/20341

[05:58] <cotto> The switch, cgoto and cgp runcores are on the chopping block.  If they're useful to Rakudo comments can go to http://trac.parrot.org/parrot/ticket/1563.

[05:58] <sorear> *as they are implemented today

[06:00] <cotto> That patch removes the switch ops from Rakudo's build so that Rakudo won't break if/when they're removed.

[06:07] <moritz_> good morning

[06:22] *** hercynium left
[06:32] <moritz_> cotto: will push the patch after successfull spectest

[06:34] *** uniejo joined
[06:36] *** iblechbot joined
[06:47] *** lestrrat is now known as lest_away

[06:53] *** leon_mu joined
[07:07] <mathw> Morning

[07:10] <meppl> good morning, mathw

[07:13] <mathw> Hi meppl

[07:13] <sorear> helo

[07:14] <mathw> pmichaud: Good blog post. Very good blog post.

[07:15] *** leon_mu left
[07:23] <moritz_> jnthn: your recent patches have caused some fallout in the spec tests, for example t/spec/S09-typed-arrays/hashes.rakudo aborts before running any tests

[07:26] <dalek> rakudo: 6783b52 | moritz++ | build/Makefile.in:

[07:26] <dalek> rakudo: remove switch ops from Makefile.in. cotto++

[07:26] <dalek> rakudo: they are about to be removed from parrot. This patch prevents build failures

[07:26] <dalek> rakudo: when that actually happens.

[07:26] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6783b52bd34ab2309423c054a5a0201c1761d6b4

[07:35] *** iblechbot left
[07:35] *** mberends joined
[07:47] <sorear> blizkost passes all tests on newest parrot

[07:47] <sorear> although it seems to segfault much more

[07:56] *** lest_away is now known as lestrrat

[07:57] <moritz_> rakudo: sub foo($bar:) {};

[07:57] <p6eval> rakudo 6783b5:  ( no output )

[07:58] <moritz_> rakudo: sub foo($bar:) {}; foo(4:)

[07:58] <p6eval> rakudo 6783b5: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[07:58] <moritz_> rakudo: sub foo($bar:) {}; foo(4)

[07:58] <p6eval> rakudo 6783b5: OUTPUT«Lexical 'self' not found␤current instr.: 'foo' pc 179 (EVAL_1:77)␤»

[08:01] *** lestrrat is now known as lest_away

[08:03] *** rgrau` left
[08:03] *** rgrau joined
[08:03] *** rgrau_ joined
[08:09] <avar> is parrot not released on cpan anymore? All I see is parrot-0.0.11.2

[08:09] <moritz_> it's not

[08:11] <avar> why?

[08:12] <moritz_> dunno... probably too much hassle

[08:20] <mberends> Steve A Fink should delete that very old Parrot

[08:21] <sorear> recently, Allison Randal deleted parrot-1.0.0

[08:21] <sorear> which was on CPAN as recently as March

[08:22] <mberends> Parrot 0.0.11.2 and related modules are dated 22 Sep 2003

[08:22] <avar> whee

[08:23] *** k23z__ joined
[08:23] <avar> Anyway I don't see why not to upload the tarball. You'd at least get the distribution mechanism / search.cpan.org. Should be easy to hack up a Makefile.PL and get cpantesters too

[08:24] <moritz_> avar: it's not easy. There are lots of .pm files shipped with parrot...

[08:24] <moritz_> avar: and since the release managers change, they need to add those new modules to some group each time, and if they forget one, the next parrot upload is marked as unauthorized

[08:25] *** eternaleye joined
[08:25] <avar> moritz_: It's easy to just ignore all those .pm files with META.yml with no_index

[08:26] <avar> If that's an issue I could hack up a small script to do that, if anyone cares :)

[08:26] <moritz_> anyway, I don't see any real benefit in having parrot on cpan

[08:27] <avar> cpantesters, weren't some parrot releases shipped with "oops, we broke win32" type of errors?

[08:28] <moritz_> I don't think that happened anymore since parrot has its own smoking system

[08:30] *** snarkyboojum left
[08:33] *** dakkar joined
[08:35] <BinGOs> My smokers definitely used to smoke Parrot when it was uploaded to CPAN

[08:40] <moritz_> rakudo: say Date.today - 3705

[08:40] <p6eval> rakudo 6783b5: OUTPUT«2000-03-01␤»

[08:46] <frettled> hmm

[08:47] <frettled> rakudo: say Date.today + 123456

[08:47] <p6eval> rakudo 6783b5: OUTPUT«2348-04-27␤»

[08:47] <frettled> rakudo: say Date.today + 12345678

[08:47] <p6eval> rakudo 6783b5: OUTPUT«35811-08-18␤»

[08:47] <frettled> Nice.

[08:50] *** smash_ joined
[08:50] <smash_> hello everyone

[08:52] *** riffraff joined
[08:52] <sorear> hello

[08:54] <frettled> Morning-ish!

[09:07] *** astrojp left
[09:14] <moritz_> hugme: tweet rakudoperl Rakudo #28 "Moscow" released, with vastly improved string interpolation and item assignment

[09:14] * hugme hugs moritz_; tweet delivered

[09:19] <smash_> rakudo: say 1

[09:19] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[09:19] <smash_> rakudo: say "ABC".trans('A'=>'a')

[09:19] <p6eval> rakudo 6783b5: OUTPUT«too few positional arguments: 2 passed, 3 (or more) expected␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:21] <smash_> what did i do wrong ?

[09:22] <moritz_> .trans is not yet implemented in master

[09:22] <moritz_> it's just the parrot .trans method leaking through

[09:23] <moritz_> ISTR that somebody was mentioning he was working on a patch for .trans, but I forgot who :(

[09:23] <moritz_> alpha: say "ABC".trans('A'=>'a')

[09:23] <p6eval> alpha 30e0ed: OUTPUT«aBC␤»

[09:24] <smash_> oh, ok.. thks

[09:24] <sorear> if we override trans will it break parrot?

[09:24] <moritz_> huh?

[09:24] * moritz_ sincerely hopes it doesn't

[09:25] <smash_> if it does i guess something is wrong :)

[09:25] <moritz_> aye

[09:25] <moritz_> the .trans in alpha didn't break parrot either

[09:26] <sorear> overriding methods with completely unrelated methods breaks Liskov

[09:26] <sorear> if Parrot is actually using its own .trans, there could be a problem

[09:27] <moritz_> only if parrot ever tries to call .trans on a Perl 6 string using the Perl 6 dispatcher

[09:28] <smash_> alpha: say "ABC".trans(['A','B']=>['a','b'])

[09:28] <p6eval> alpha 30e0ed: OUTPUT«abC␤»

[09:29] <sorear> y/// is gone?

[09:29] <sorear> I suppose it was kinda lousy huffman

[09:29] <moritz_> std: y///

[09:29] <p6eval> std 30454: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of y///; in Perl 6 please use tr/// at /tmp/Rrop3V8eNB line 1:␤------> [32my[33m⏏[31m///[0m␤Parse failed␤FAILED 00:01 109m␤»

[09:30] <sorear> rakudo: tr/a/b/.WHAT.perl.say

[09:30] <p6eval> rakudo 6783b5: OUTPUT«Could not find sub &tr␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[09:41] *** iblechbot joined
[09:45] *** yinyin left
[09:50] *** hicx174 joined
[10:00] *** masak joined
[10:03] <masak> oh hai, #perl6

[10:04] <masak> I see the temporal bikeshedding on p6l is in full force. somehow, though, when I red it I think "they don't have any working code, so whatever they say they cannot hurt the status quo"... :)

[10:04] <frettled> masakshark!

[10:04] * masak plays "Jaws"

[10:04] <moritz_> (working code)++

[10:05] <frettled> Cathedral vs. Bazaar Mk. MMX

[10:05] <moritz_> phenny: tell jnthn http://gist.github.com/376404 by smash++ demonstrates that subtype checks are executed twice for multi dispatch... wasn't that down to one execution only, at some point?

[10:05] <phenny> moritz_: I'll pass that on when jnthn is around.

[10:06] <masak> I'm going to go out on a limb and say that the proposals in that p6l thread are an example of "Second system syndrome done wrong". That is my firm opinion.

[10:07] * moritz_ wishes for a post-p6l list where all these discussions could be redirected to

[10:07] <masak> I wonder how many outsiders have sometimes approeched Perl 6 through p6l and thought "wow, these people are insane".

[10:08] <masak> "...and hopeless dreamers incapable of designing anything practical."

[10:08] <sorear> no, perl 6 is created by *terrifyingly* hopeless dreamers who /are going to succeed/

[10:09] <masak> sure. as soon as we implement that abstract instant-in-time which can be converted to all the possible calendar systems in the universe.

[10:09] * moritz_ is quite hopeful, but plays only a minor role in creating perl 6

[10:10] <sorear> well, the conversion is the job of the calendar

[10:10] <sorear> once we define abstract instants in time, if a calendar system can't convert itself from an instant, that calendar is broken

[10:10] <frettled> Some of the bikeshedding has revealed problems that cannot easily be solved by a calendar.

[10:11] <sorear> and until such time as we have camels in space, Rat of seconds since 1970-01-01 is a fine Instant

[10:11] <sorear> so... yeah

[10:15] <dalek> book: bfe7d2a | moritz++ | src/multi-dispatch.pod:

[10:15] <dalek> book: [mmd] clarify number of executions of a where-block, smash++

[10:15] <dalek> book: review: http://github.com/perl6/book/commit/bfe7d2a18472b0d4456a64271deb6aa409dba1b0

[10:15] <jnthn> o/

[10:15] <phenny> jnthn: 10:05Z <moritz_> tell jnthn http://gist.github.com/376404 by smash++ demonstrates that subtype checks are executed twice for multi dispatch... wasn't that down to one execution only, at some point?

[10:16] <masak> jnthn: \o

[10:16] <masak> moritz_: basically, relying on the number of executions per invocation is wrong a priori.

[10:16] <jnthn> moritz_: I'm not sure it was.

[10:17] <moritz_> masak: I know

[10:17] <jnthn> What masak said though. We may be able to decide at compile time that it's fine.

[10:17] <jnthn> And do 0.

[10:17] <jnthn> :-)

[10:17] <masak> moritz_: thought you did. was saying it mostly for the logs. :)

[10:17] <jnthn> Granted re-doing it is inefficient.

[10:17] <moritz_> jnthn: I thought the dispatcher did the check, and then told the binder that it doesn't need to re-check

[10:18] <jnthn> I thought so to, but maybe that was only working for the nominal type checks.

[10:19] <moritz_> alpha: my $x = 0; multi a {$y of Int where { ++$x }) { say "YaY" }; a(3); say $x

[10:19] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "of Int whe"␤in Main (file <unknown>, line <unknown>)␤»

[10:19] <moritz_> alpha: my $x = 0; multi a {Int $y where { ++$x }) { say "YaY" }; a(3); say $x

[10:19] <p6eval> alpha 30e0ed: OUTPUT«Confused at line 10, near "$y where {"␤in Main (file <unknown>, line <unknown>)␤»

[10:20] * moritz_ can't write Perl 6 code anymore

[10:20] <masak> std: sub foo { state $*bar }

[10:20] <p6eval> std 30454: OUTPUT«ok 00:01 109m␤»

[10:21] <smash_> alpha: my $x = 0; multi a(Int $y where {++$x}) { say "YaY" }; a(3); say $x

[10:21] <p6eval> alpha 30e0ed: OUTPUT«YaY␤2␤»

[10:32] <jnthn> masak: I guess I'd expect that to work. :-)

[10:32] <m6locks> any work on the DB* section? how does I get a database up with perl6?

[10:32] <masak> jnthn: yeah. still trying out my new knowledge about these things, as it were.

[10:33] <moritz_> m6locks: http://github.com/jnthn/zavolaj has an example mysql client

[10:33] <m6locks> thanks :)

[10:33] <masak> m6locks: I've had some moderate success with Squerl. I know mberends++ and jnthn++ have been working on a... what moritz_ said. 

[10:34] <jnthn> http://github.com/mberends/fakedbi is a nice idea but...there's no code yet. :-)

[10:34] <m6locks> :D

[10:35] <m6locks> well, idea counts too, but it's not that usable in real life

[10:35] <m6locks> imma checkout that zavolaj and see how it works

[10:35] <jnthn> No. Maybe the Zavolaj MySQL client or Squerl are the way to go.

[10:35] <jnthn> Zavolaj is a general layer for building calls to C libraries, btw.

[10:35] <m6locks> aye

[10:35] <moritz_> there's also DBDI, but it doesn't run yet either

[10:35] <jnthn> The mysqlclient.p6 is just an example of using it.

[10:37] <masak> m6locks: Squerl has code that Works Today. I can point you to examples if you like.

[10:38] * colomon discovered overnight that breaking Complex.abs causes a spectacular number of spectest failures....

[10:38] <jnthn> absolut FAIL!

[10:39] <moritz_> could somebody explain WTF RT #74600 uses curly braces for calling .fmt?

[10:39] <moritz_> rakudo: say '8192'.fmt('%x')

[10:39] <p6eval> rakudo 6783b5: OUTPUT«2000␤»

[10:40] <colomon> jnthn: is that a new flavor I've not heard of before?  ;)

[10:40] <moritz_> rakudo: say '8192'.fmt{'%x'} # what does this actually do?

[10:40] <p6eval> rakudo 6783b5: OUTPUT«8␤»

[10:41] <moritz_> is this parsed as ('8192'.fmt){...} or rather what?

[10:41] <m6locks> masak: please do so

[10:42] <masak> m6locks: http://use.perl.org/~masak/journal/39686

[10:42] <m6locks> thanks

[10:42] <masak> moritz_: I think there's another RT ticket for exactly that.

[10:43] <masak> moritz_: yep. http://rt.perl.org/rt3/Ticket/Display.html?id=74112

[10:43] <masak> moritz_: but invalidate RT #74600. that's not how you call .fmt

[10:43] <moritz_> masak: thanks, will close

[10:43] <masak> moritz_++

[10:45] <moritz_> 615 tickets

[10:46] <jnthn> \o/

[10:46] <jnthn> That's a nice decrease from > 630 at the weekend.

[10:47] <masak> and not an increase to 650 as I gloomily predicted... :)

[10:47] * masak goes off to find more bugs

[10:48] <jnthn> masak: mwahaha...

[10:48] <jnthn> masak: Clearly you just make more gloomy predictions.

[10:48] <masak> This Weekend's Weather: lots of bugs moving up from the south...

[10:49] <jnthn> masak: What will be the effect on aviation?

[10:49] <colomon> I bet generating bugs would be easy if proto worked again.... ;)

[10:50] <masak> jnthn: depends entirely on the amount of bugs. usually the plane can work around them.

[10:50] <moritz_> and there are still 6 tickets waiting for tests

[10:50] <jnthn> Wow. :-)

[10:51] <jnthn> I wonder if we can dip below 600...

[10:51] <smash_> omg !! i love p6

[10:51] <masak> smash_: what now? :)

[10:52] <moritz_> jnthn: it's a vicious circle... if you eliminate the bugs the prevent us from running some of the modules, we'll find more bugs immediately

[10:52] <masak> that's why I'm so gloomily hopeful :)

[10:53] <jnthn> That's inspiring. :-P

[10:54] <smash_> masak: it makes things so simple that it makes me want to cry out of joy

[10:54] <moritz_> rakudo: my @a = <a b c d f>; for @a[ 1 ..^ ] -> $x { say $x } 

[10:54] <p6eval> rakudo 6783b5: OUTPUT«Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[10:54] <moritz_> rakudo: my @a = <a b c d f>; for @a[ 1 ..^ @a ] -> $x { say $x } 

[10:55] <p6eval> rakudo 6783b5:  ( no output )

[10:55] <masak> smash_: thanks for reminding me of that. :) I know what you mean, and feel that way too sometimes.

[10:56] <moritz_> rakudo: say @*ARGS.PARROT

[10:56] <p6eval> rakudo 6783b5: OUTPUT«Array␤»

[10:56] <moritz_> rakudo: my @x = @*ARGS; say @x.PARROT

[10:56] <p6eval> rakudo 6783b5: OUTPUT«Array␤»

[10:59] *** mls joined
[11:00] <mls> rakudo: say (1, 1, * + * ... *).batch(10).perl

[11:00] <p6eval> rakudo 6783b5: OUTPUT«(1, 1, 2, 3, 5, 8, 13, 21, 34, 55)␤»

[11:00] <mls> rakudo: say (1, 1, * - * ... *).batch(10).perl

[11:00] <p6eval> rakudo 6783b5: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[11:00] <mls> rakudo: say (1, 1, * * * ... *).batch(10).perl

[11:00] <p6eval> rakudo 6783b5: OUTPUT«Method 'Num' not found for invocant of class 'Block'␤current instr.: 'perl6;Mu;' pc -1 ((unknown file):-1)␤»

[11:02] <moritz_> rakudo: class A is Mu { }; say A ~~ Any

[11:02] <p6eval> rakudo 6783b5: OUTPUT«0␤»

[11:02] <moritz_> rakudo: class A is Mu { }; say A.^parents

[11:02] <p6eval> rakudo 6783b5: OUTPUT«Mu()␤»

[11:02] <mls> rakudo: say say (1, + * ... *).perl

[11:02] <p6eval> rakudo 6783b5: OUTPUT«␤Null PMC access in find_method('params')␤current instr.: 'infix:<...>' pc 316490 (src/gen/core.pir:0)␤»

[11:04] * masak submits rakudobug

[11:04] <colomon> mls: the general rules for creating whatever blocks have not been implemented in Rakudo yet.

[11:04] <colomon> just special cases for the common + and * - $n cases.

[11:05] <mls> colomon: thanks. should I open a ticket for the Null PMC?

[11:05] <masak> rakudo: 1, +* ... *

[11:05] <p6eval> rakudo 6783b5: OUTPUT«␤Null PMC access in find_method('params')␤current instr.: 'infix:<...>' pc 316490 (src/gen/core.pir:0)␤»

[11:05] <masak> mls: I'm on it :)

[11:05] <moritz_> rakudo: +*

[11:05] <p6eval> rakudo 6783b5:  ( no output )

[11:05] <masak> moritz_: the above was the golfed case.

[11:05] <moritz_> rakudo: (+*).(1)

[11:05] <p6eval> rakudo 6783b5:  ( no output )

[11:06] <masak> it's the '1,', the '+' and the '...' in conjunction that does it.

[11:07] <colomon> rakudo (+*).WHAT

[11:07] <pugssvn> r30455 | moritz++ | [t/spec] test that class A is Mu { } does not have anything to do with Any 

[11:07] <colomon> rakudo: (+*).WHAT

[11:07] <p6eval> rakudo 6783b5:  ( no output )

[11:07] <colomon> rakudo: (+*).PARROT

[11:07] <p6eval> rakudo 6783b5:  ( no output )

[11:08] <masak> lunch &

[11:09] * moritz_ closes masakbug

[11:10] <colomon> rakudo: (+*).signature.params

[11:10] <p6eval> rakudo 6783b5: OUTPUT«␤Null PMC access in find_method('params')␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[11:11] <colomon> rakudo: (+*) ~~ Code

[11:11] <p6eval> rakudo 6783b5:  ( no output )

[11:11] <colomon> rakudo: say (+*) ~~ Code

[11:11] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[11:11] <jnthn> rakudo: say (+*)("42")

[11:11] <p6eval> rakudo 6783b5: OUTPUT«42␤»

[11:11] <colomon> Yeah, that's the problem.  It registers as Code, but apparently doesn't have a valid signature.

[11:11] <jnthn> rakudo: say ((+*)("42")).WHAT

[11:12] <p6eval> rakudo 6783b5: OUTPUT«Num()␤»

[11:12] <jnthn> rakudo: say (+*).signature.perl

[11:12] <p6eval> rakudo 6783b5: OUTPUT«␤Null PMC access in find_method('perl')␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[11:12] <jnthn> fejl.

[11:14] <colomon> Locally I'm getting a crash in t/spec/S14-roles/parameterized-type.t -- known bug or some weird side effect of my .abs change?

[11:14] *** sundar joined
[11:17] <jnthn> colomon: Odd, I was working on those yesterday...I was pretty sure that test passed though.

[11:17] <jnthn> Unlikely to be side-effect of .abs change though

[11:18] <jnthn> I'll look into it later.

[11:20] <sundar> A05 says Perl has "no support" for named captures... Was it written before Perl 5.10? 

[11:21] <jnthn> Long before.

[11:22] <sundar> Ah, ok, I'll keep that in mind. 

[11:29] <sundar> TimToady++ # for incredible writing skills, like in: "The path to freedom is not to make everyone a slave"

[11:32] *** viklund joined
[11:36] <m6locks> haha

[11:36] <m6locks> well true that

[11:37] *** envi^home joined
[11:37] <masak> viklund: \o

[11:40] <am0c> rakudo: for @(1..3 X 'a'..'b') -> $n, $a { say "$n|$a" }

[11:40] <p6eval> rakudo 6783b5: OUTPUT«1 a|1 b␤2 a|2 b␤3 a|3 b␤»

[11:40] <am0c> it seems it creates Parcel. spec has modified?

[11:42] <masak> more like Rakudo has modified, and doesn't do that correctly yet.

[11:43] <jnthn> rakudo: for (1..3 X 'a'..'b') -> $n, $a { say "$n|$a" }

[11:43] <moritz_> jnthn: I see the same failure

[11:43] <p6eval> rakudo 6783b5: OUTPUT«1 a|1 b␤2 a|2 b␤3 a|3 b␤»

[11:43] <am0c> i see.

[11:43] <moritz_> (in parameterized-types.t)

[11:43] <jnthn> rakudo: say (1..3 X 'a'..'b').perl

[11:43] <p6eval> rakudo 6783b5: OUTPUT«(1, "a", 1, "b", 2, "a", 2, "b", 3, "a", 3, "b")␤»

[11:43] <jnthn> rakudo: say (1..3 X 'a'..'b').WHAT

[11:44] <p6eval> rakudo 6783b5: OUTPUT«GatherIterator()␤»

[11:45] <viklund> masak: hi

[11:45] <moritz_> \o/ it's viklund 

[11:45] <masak> viklund: long time no #perl6

[11:45] <viklund> ;)

[11:46] <masak> whoz op?

[11:46] <viklund> yep, busy writing manuscript and polishing data for that

[11:46] <masak> manuscript? for a blockbuster movie?

[11:46] <viklund> no, research

[11:46] <masak> ah.

[11:46] <masak> that was my second guess.

[11:46] <viklund> :)

[11:47] <viklund> also, I'm trying to figure out how to annotate ~20 genomes in parallel without getting confused

[11:47] <masak> wow.

[11:47] <moritz_> don't do it; the human mind can only handle two tasks in parallel, at most :-)

[11:47] <viklund> yes, it's exciting

[11:48] *** lest_away is now known as lestrrat

[11:48] <viklund> moritz_: but perl can handle more ;)

[11:48] <moritz_> sometimes I have doubts about that too :-)

[11:48] <masak> if the limit is two tasks for the human mind, then clearly the solution is a bifurcating recursive algorithm of some sort. :)

[11:49] <masak> 'do half #1 here' -- 'meanwhile, do half #2 here'.

[11:49] <moritz_> funny thing is, I was writing about a bifurcating recursive algorithm earlier (not perl relasted) :-)

[11:49] <viklund> sounds good, but I also want to use all of my shiny 8 virtual cpus...

[11:49] <moritz_> fork!

[11:50] <masak> viklund: just recurse three times! :)

[11:50] <masak> viklund: let me try to guess your true purpose in coming here: you're wondering about the release date of Rakudo Star, yes? :)

[11:51] <viklund> I discovered POE::Wheel::Run a few weeks ago, it's wonderful for keeping track of stuff

[11:51] <viklund> masak: curiously not

[11:51] <masak> then I'm out of guesses.

[11:52] <viklund> mainly I just realised that I haven't been running the irssi binary for a while and figured it needed some excersize

[11:52] *** mariano__ joined
[11:52] <viklund> (and it's always so nice in here)

[11:53] <viklund> tarde is the time-travelling debugger right?

[11:54] <masak> tardis. yes.

[11:54] <viklund> how's that comming along, I see some gist-pastes now and then

[11:54] <masak> snarkyboojum and I are conspiring around that one.

[11:54] * viklund subscribes to masaks gists...

[11:55] <masak> :)

[11:55] <masak> work has been focusing on its dependency, Yapsi, lately.

[11:55] <masak> Yapsi is a Perl 6 compiler-and-runtime written in Perl 6.

[11:56] <masak> tardis uses the runtime of Yapsi to run the debugged program.

[11:56] <viklund> is Yapsi an acronym?

[11:56] <masak> Yet Another Perl Six Implementation.

[11:57] <masak> it's pronounced "YAPC" :P

[11:57] <viklund> nice ;)

[11:57] <viklund> so, when is Rakudo* ready (for production)?

[11:57] <moritz_> when it's done :-)

[11:58] <masak> looks like Rakudo * will be released later in Q2.

[11:58] <moritz_> like, June

[11:58] <masak> aye.

[11:58] <masak> we need those two months.

[11:58] <masak> moritz_: when's the hard deadline on the book?

[11:58] * masak forgets

[11:58] <moritz_> masak: soon[tm]

[11:59] * masak panics

[11:59] <moritz_> like, two weeks before the R* releae or so

[11:59] <masak> thing is, I'd like to add a chapter on named enums with my poker hand example.

[11:59] <masak> but we don't even have named enums back yet... :(

[12:00] *** agentzh left
[12:00] <viklund> is the book readable somewhere?

[12:00] <masak> viklund: http://github.com/perl6/book

[12:00] <viklund> ty

[12:00] <masak> viklund: look under Downloads for PDFs.

[12:01] <viklund> but it's PseudoPod right?

[12:01] <masak> aye :)

[12:01] <masak> viklund++ # built-in PseudoPod parser

[12:01] *** SmokeMachine joined
[12:02] <viklund> with exercises!

[12:02] <masak> a colleague said to me once, "it's frightening, but nowadays when I read \infty, I actually see a ∞ symbol..." :)

[12:02] <moritz_> it's quite similar here :-)

[12:04] <viklund> looks like a nice book

[12:04] <masak> aye. but not finished yet.

[12:04] <viklund> will it be published as in printed?

[12:04] <moritz_> yes

[12:05] <moritz_> by onyx neon press

[12:05] <viklund> print on demand?

[12:05] * jnthn plans to do more $book-writing at the weekend

[12:05] <masak> jnthn++ # will try to get inspired to do the same

[12:07] <viklund> ahh, the publisher is driven by perl people

[12:07] <masak> it's a conspiracy!

[12:07] <moritz_> last week I submitted a few patches to Pod::PseudoPod::LaTeX to render most of the book correctly

[12:07] * viklund takes out his tinfoil hat

[12:08] <masak> moritz_++

[12:08] <viklund> I've been checking out chromatics++ Moder Perl Book from time to time as well. It looks really nice as well

[12:08] <viklund> (as well)

[12:09] <masak> it does.

[12:09] <masak> I'm reading new chapters as they come online nowadays too.

[12:10] <masak> he writes clearly and to the point about things generally considered non-trivial.

[12:10] <masak> the latest highlight was the sentence "Closures are an easy, effective, and safe way to make data persistent between function invocations without using global variables."

[12:11] <masak> I had never really expressed that thought to myself, but it's a really nice way to put it.

[12:12] <viklund> yes, it is

[12:12] <moritz_> the second solution is to use objects

[12:12] <masak> he then goes on to describe the new C<state> keyword in Perl 5.10, as well as the corresponding now-deprecated hack involving 'if 0'.

[12:12] <moritz_> which is why languages that offer either one but not the other always feel clumsy to me

[12:12] *** mls left
[12:13] <masak> moritz_: if you use both objects and closures at the same time, do you get more than if you just use one of those?

[12:13] <masak> I mean practically. theoretically, you don't since they're basically isomorphic.

[12:14] <moritz_> masak: sometimes some of them feel clumsy

[12:14] <masak> true.

[12:14] <masak> they might each be geared for certain uses.

[12:14] <moritz_> for example if you need to construct an object just have something on which a callback can work

[12:14] <moritz_> closures make callback interfaces very intuitive

[12:15] <masak> *cough* Java *cough*

[12:16] *** renormalist left
[12:16] *** szabgab joined
[12:17] *** renormalist joined
[12:18] <moritz_> and for example event driven systems just need lots of callbacks

[12:18] <jnthn> masak: I was writing some code in Java the other day and realized that it would have been so much cleaner - and far less bug-prone - if I'd had constructs like map and grep to hand.

[12:18] <moritz_> otoh if you have no object, you have to keep a variable for each attribute - which can be a whole lot

[12:19] * moritz_ wonders if closures and currying are isomorphic

[12:19] <moritz_> probably not

[12:21] <tpf|Coke> perlmonks-- # I want a "read entire thread" option. :|

[12:21] <moritz_> tpf|Coke: can't you set the depth threadshold to 50 or so?

[12:21] <jnthn> moritz_: Well, if you seperate each parameter into a level of closure or so.

[12:26] <dalek> book: 6fabc2f | masak++ | src/preface.pod:

[12:26] <dalek> book: [preface] fixed grammaro

[12:26] <dalek> book: review: http://github.com/perl6/book/commit/6fabc2f95126bbc1b99e286ae71555d63587aa34

[12:27] *** pmurias joined
[12:27] *** IllvilJa left
[12:27] *** szabgab left
[12:30] *** szabgab joined
[12:32] <mdxi> pmichaud++ # belatedly reading yesterday's blog entry

[12:32] <masak> it's making the rounds on Twitter now. much thanks to audreyt++'s tweet about it.

[12:32] <tpf|Coke> moritz_: oh sure, if I create an account. =-)

[12:32] <dalek> book: b41705f | masak++ | src/preface.pod:

[12:32] <dalek> book: [preface] slight rephrasings

[12:32] <dalek> book: review: http://github.com/perl6/book/commit/b41705f8653e9fdba4239ea0482dd9490c73d088

[12:34] <moritz_> tpf|Coke: that's what perlmonks wants to encourage :-)

[12:35] <pmichaud> good morning, #perl6

[12:35] <m6locks> good afternoon

[12:36] <moritz_> good now :-)

[12:36] <moritz_> std: now

[12:36] <p6eval> std 30455: OUTPUT«ok 00:01 109m␤»

[12:37] <masak> good std ok now.

[12:38] <pmurias> diakopter: i made parenthesis with an if optional in perlesque

[12:41] *** proller_ joined
[12:42] *** proller left
[12:42] <pmichaud> 10:08 <sorear> no, perl 6 is created by *terrifyingly* hopeless dreamers who /are going to succeed/

[12:42] <pmichaud> I think this is my new favorite quote.  :-)

[12:42] <jnthn> morning, Pm

[12:43] <jnthn> moritz_: Confirm that I do appear to have broken that parameterized type test. :|

[12:44] <jnthn> Not sure quite how I managed to miss the failure in the spectest results. :-/

[12:44] <masak> pmichaud: if we repeat it often and earnestly enough, maybe it'll work like Inigo Montoya's catchphrase. :)

[12:44] <dalek> book: 23285cb | masak++ | src/preface.pod:

[12:44] <dalek> book: [preface] various further small file

[12:44] <dalek> book: - one full stop should be a semicolon

[12:44] <dalek> book: - removed trailing slash in http://perl.org/

[12:44] <dalek> book: - 'the compiler' sounds strange after explaining that there are several

[12:44] <dalek> book:   Perl 6 implementations. changed to 'Perl 6 compilers'

[12:44] <dalek> book: review: http://github.com/perl6/book/commit/23285cb5aab2f42b042fc767fbeab5f3fb8ee516

[12:44] <pmichaud> "Hello!  My name is Patrick Michaud.  You killed my grammar engine.  Prepare to die()."

[12:44] <masak> *LOL*

[12:47] <frettled> :D

[12:49] *** orafu left
[12:50] *** orafu joined
[12:54] *** riffraff left
[12:58] <mdxi> Simple. You keep saying things are simple. I don't think that word means what you think it means.

[12:59] *** rurban left
[12:59] <moritz_> "your value of "simple" must be something different than my "simple"."

[13:00] *** rurban joined
[13:02] *** cognominal joined
[13:03] *** rgrau_ left
[13:03] *** ruoso joined
[13:04] <viklund> no, now it's time to go and bring $daughter home from the day care-center

[13:05] <masak> viklund: nice seeing you here! o/

[13:05] <viklund> you too

[13:06] * moritz_ will be forcefully logged out of his $work machine in about 25 minutes

[13:06] *** viklund left
[13:07] *** proller joined
[13:07] *** proller_ left
[13:14] <tpf|Coke> moritz_: ?

[13:14] *** tpf|Coke is now known as Coke

[13:14] *** Coke is now known as parrot|Coke

[13:15] <moritz_> server shutdown due to power interruptions

[13:15] <moritz_> building maintenance and stuff

[13:18] *** Guest13068 left
[13:21] <bbkr> what is the syntax to get hash slice in P6? thre are only array slices explained in S09

[13:21] <masak> %hash<a b c>

[13:21] <moritz_> or %hash{$value1, $value2}

[13:21] <jnthn> rakudo: my %h = a => 4, b => 2; say %h<a b>

[13:21] <p6eval> rakudo 6783b5: OUTPUT«42␤»

[13:22] <moritz_> just like any other hash access, really :-)

[13:22] <masak> rakudo: my %h; %h<a b> = 4, 2; say %h.perl

[13:22] <p6eval> rakudo 6783b5: OUTPUT«{"a" => 4, "b" => 2}␤»

[13:22] <masak> \o/

[13:22] <masak> jnthn++

[13:22] <masak> that didn't work a week ago!

[13:22] <moritz_> neither did rvalue hash slices :-)

[13:22] <masak> I'll need to de-workaround GGE a tad.

[13:22] <jnthn> masak: I accidentally the patch.

[13:23] <masak> :)

[13:24] <bbkr> hash slice notation does not work on $/ object

[13:24] <bbkr> rakudo: "ab" ~~ /$<a>=[.]$<b>=[.]/; say $/{"a", "b"}; # is this a bug?

[13:24] <p6eval> rakudo 6783b5: OUTPUT«Null PMC access in invoke()␤current instr.: '!postcircumfix:<{ }>' pc 13978 (src/builtins/Code.pir:39)␤»

[13:24] <moritz_> yes

[13:24] <moritz_> (and reported)

[13:24] <bbkr> thanks :)

[13:24] *** JimmyZ joined
[13:25] <dalek> book: e325b80 | masak++ | src/basics.pod:

[13:25] <dalek> book: [basics] rw review

[13:25] <dalek> book: Lots of minor improvements throughout.

[13:25] <dalek> book: review: http://github.com/perl6/book/commit/e325b80914a4d6938d37911382c0b6b9f76037af

[13:25] <moritz_> it's a manifestationo of the "$/ is not a Perl 6 Match object"

[13:25] <moritz_> pmichaud: speaking of which, have reached a conclusion yet where the array creation code for Match objects should go?

[13:26] *** plobsing joined
[13:34] <masak> rakudo: module Foo {}; Foo::

[13:34] <p6eval> rakudo 6783b5: OUTPUT«Could not find sub &Foo␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[13:34] <masak> sub?

[13:35] <jnthn> I expect we just toss the trailing ::

[13:35] <jnthn> (In fact, I know full well that we do.)

[13:36] *** Trey joined
[13:40] *** rgrau` joined
[13:42] <masak> rakudo: sub foo(*@a) { @a[+0] }; foo()

[13:42] <p6eval> rakudo 6783b5: OUTPUT«No applicable candidates found to dispatch to for 'postcircumfix:<[ ]>'. Available candidates are:␤:(Mu : Int $i;; *%_)␤:(Mu : Block $b;; *%_)␤:(Mu : !whatever_dispatch_helper ;; *%_)␤␤current instr.: '!postcircumfix:<[ ]>' pc 10885 (src/builtins/Role.pir:73)␤»

[13:43] <masak> did we reach a consensus on what to do with this one?

[13:43] <masak> the first candidate should accept a Num, no?

[13:44] <masak> (which gets coerced to an Int)

[13:44] <jnthn> masak: I still have some planned changes to postcircumfix:<[ ]> handling to do.

[13:44] <jnthn> I think that will resolve these issues.

[13:44] <colomon> Isn't this another bug, though?

[13:44] <jnthn> It's a bug for sure.

[13:44] *** uniejo left
[13:44] <masak> jnthn: sounds good.

[13:44] <jnthn> I think we've ticketed it alreayd.

[13:44] <masak> colomon: it's the same bug, with a SMA error message :)

[13:45] <colomon> I mean, usually when I get this message it doesn't have anything to do with missing the Num version.

[13:45] <colomon> it has something to do with the array being not right in the head.

[13:45] <masak> the previous error message was 'cannot do substr on empty string', which was sort of a meta-error caused by producing the real error message.

[13:45] <colomon> rakudo: my @a = 1..10; say @a[5/4]

[13:45] <p6eval> rakudo 6783b5: OUTPUT«2␤»

[13:46] <colomon> rakudo: my @a = 1..10; say @a[5/4.Num]

[13:46] <p6eval> rakudo 6783b5: OUTPUT«2␤»

[13:46] <masak> colomon: how is it that those work, though?

[13:46] <masak> that's the real mystery.

[13:46] <colomon> ah, so maybe it's backwards.  good point.

[13:47] <colomon> btw, it should take a Real, not a Num.  ;)

[13:48] <colomon> jnthn: btw, it's not just parameterized-type.t. S09-typed-arrays/hashes.t and S12-attributes/instance.t are also failing.  (That's on a pristine copy rather than my hacked up one.)

[13:51] <colomon> hmmm... appears we have postcircumfix:<[ ]> all over the place.  :(

[13:52] <colomon> Seq implements one in PIR which appears to take an Integer, could that help explain the issue?

[13:54] <moritz_> sounds wrongish

[13:56] *** IllvilJa joined
[13:56] <colomon> probably should table worrying about it until after the Next Great List Reworking, which is hopefully coming this weekend....

[13:57] <masak> colomon: ah. Real. I confess I do not yet feel at home with the current Numology typology.

[13:57] <masak> need to study it a bit more, I guess.

[13:59] <colomon> rakudo: my @a = 1..10; say @a.Seq[5/4.Num]

[13:59] <p6eval> rakudo 6783b5: OUTPUT«2␤»

[14:00] <colomon> Yeah, I'll bet what we're seeing is under some conditions the Seq version is factored in, and in others it isn't.

[14:03] *** araujo left
[14:03] *** araujo joined
[14:05] *** dual left
[14:10] <JimmyZ> rakudo: my $a = time; (1,1,*+* ... *).batch(28).perl.say; my $b = time; say $b - $a; # sounds like it's faster than parrot's fib.pir?

[14:10] <p6eval> rakudo 6783b5: OUTPUT«(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811)␤0.284433126449585␤»

[14:10] <bbkr> rakudo: /./.^methods>>.say; # it crashes after printing few methods

[14:10] <p6eval> rakudo 6783b5: OUTPUT«ACCEPTS␤assuming␤unwrap␤wrap␤ACCEPTS␤count␤arity␤multi␤name␤clone␤signature␤perl␤returns␤do␤of␤assuming␤callwith␤Str␤new␤Method 'say' not found for invocant of class 'Perl6MultiSub'␤current instr.: '!dispatch_method_parallel' pc 359 (src/glue/dispatch.pir:72)␤»

[14:10] <bbkr> just like that. a bug?

[14:11] <masak> I think that's a new one.

[14:11] <masak> bbkr++

[14:11] <bbkr> :)

[14:11] <masak> bbkr: for real code, try not to combine >>. with .say :)

[14:11] <masak> it probably does not do what you want.

[14:14] *** rv2733 joined
[14:14] <JimmyZ> rakudo: my $a = time; (time - $a).say; my $b = time; ($b-$a).say; # masak: Is it right?

[14:15] <p6eval> rakudo 6783b5: OUTPUT«1272031144.30542␤0.0101950168609619␤»

[14:15] <JimmyZ> rakudo: my $a = time; (time() - $a).say;

[14:15] <p6eval> rakudo 6783b5: OUTPUT«0.000250816345214844␤»

[14:15] <JimmyZ> rakudo: my $a = time; (time - $a).say;

[14:15] <p6eval> rakudo 6783b5: OUTPUT«1272031175.83554␤»

[14:15] <JimmyZ> rakudo: my $a = time; $a.say; (time - $a).say;

[14:15] <p6eval> rakudo 6783b5: OUTPUT«1272031190.14766␤1272031190.16179␤»

[14:15] <moritz_> rakudo: my $a = time; $a.say; (time() - $a).say

[14:15] <p6eval> rakudo 6783b5: OUTPUT«1272031201.50384␤0.0233659744262695␤»

[14:16] <moritz_> std: time foo

[14:16] <p6eval> std 30455: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'foo' used at line 1␤Check failed␤FAILED 00:01 109m␤»

[14:16] <moritz_> std.pm also parses time as a listop

[14:16] <moritz_> std: now foo

[14:16] <p6eval> std 30455: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/QfohncpfHx line 1:␤------> [32mnow [33m⏏[31mfoo[0m␤    expecting any of:␤        bracketed infix␤  infix or meta-infix␤      statement modifier loop␤Parse failed␤FAILED 00:01 107m␤»

[14:16] <JimmyZ> rakudo: my $a = time; $a.say; (now - $a).say;

[14:16] <p6eval> rakudo 6783b5: OUTPUT«1272031256.10522␤Could not find sub &now␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[14:17] <JimmyZ> rakudo: my $a = time; $a.say; (say - $a).say;

[14:17] <p6eval> rakudo 6783b5: OUTPUT«1272031277.17861␤-1272031277.17861␤1␤»

[14:17] <JimmyZ> rakudo: my $a = time; $a.say; (time - $a).say;

[14:17] <p6eval> rakudo 6783b5: OUTPUT«1272031301.95485␤1272031301.96016␤»

[14:17] <masak> JimmyZ: it parses as 'time (-$a)'

[14:18] <moritz_> masak: without space :-)

[14:18] <masak> and, I think, rightly so.

[14:18] <moritz_> rakudo: time(1, 2, 3)

[14:18] <masak> moritz_: oops :)

[14:18] <p6eval> rakudo 6783b5:  ( no output )

[14:18] <JimmyZ> rakudo: my $a = time; $a.say; ((time) - $a).say;

[14:18] <p6eval> rakudo 6783b5: OUTPUT«1272031360.14588␤0.00917196273803711␤»

[14:18] <JimmyZ> rakudo: my $a = time; $a.say; (time -$a).say;

[14:18] <p6eval> rakudo 6783b5: OUTPUT«1272031375.1296␤1272031375.13471␤»

[14:18] <JimmyZ> rakudo: my $a = time; $a.say; (time-$a).say;

[14:18] <p6eval> rakudo 6783b5: OUTPUT«1272031378.99329␤0.00481796264648438␤»

[14:19] <JimmyZ> confused syntax

[14:19] <masak> indeed.

[14:19] <masak> but quite consistent.

[14:20] <JimmyZ> Is it a bug?

[14:20] <masak> no.

[14:20] <masak> but a likely trap for the unwary.

[14:20] *** am0c left
[14:21] <JimmyZ> Then it'll confuse many people, I guess.

[14:22] <JimmyZ> the newbie.

[14:22] <cotto_work> moritz_, thanks.

[14:22] <masak> well, the whole "let's turn the following subs into terms so that their odd behaviour won't bite people" thing is quite un-Perl6y and indicative of a sore design spot, I think.

[14:23] <masak> it's sort of the opposite of a sweet spot: no matter how you solve it, not everyone will be pleased.

[14:23] <moritz_> a bit like smart-matching against Bool

[14:24] <masak> yes.

[14:24] <masak> sometimes corner cases form that cannot be resolved nicely.

[14:25] <masak> they might still be 'worth it', though. either that, or there's some wonderful generalization that we haven't noticed yet. :)

[14:25] <JimmyZ> space decide action?

[14:25] <JimmyZ> er, decides

[14:26] <moritz_> yes

[14:27] <moritz_> masak: in 2025, perl best practices will recommend you write (foo) for calling something which might be nullary function or a term

[14:27] <masak> yuck.

[14:27] <JimmyZ> rakudo: sub b{ 100; }; say time - b;

[14:27] <p6eval> rakudo 6783b5: OUTPUT«1272031915.06749␤»

[14:28] <JimmyZ> rakudo: sub b{ 100; }; $my say b - 2;

[14:28] <p6eval> rakudo 6783b5: OUTPUT«Confused at line 11, near "$my say b "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[14:28] <JimmyZ> rakudo: sub b{ 100; }; say b - 2;

[14:28] <p6eval> rakudo 6783b5: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'b' pc 201 (EVAL_1:79)␤»

[14:28] <JimmyZ> rakudo: sub b{ 100; }; my $c = 2; say b - $c;

[14:28] <p6eval> rakudo 6783b5: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'b' pc 229 (EVAL_1:88)␤»

[14:29] <masak> JimmyZ: 'b - $c' means 'b(-$c)'

[14:29] <JimmyZ> rakudo: sub b{ 100; }; my $c = 2; say say - $c;

[14:29] * moritz_ thinks that was mentioned before

[14:30] <p6eval> rakudo 6783b5: OUTPUT«-2␤1␤»

[14:30] * masak conceives of a warning "you seem to be using this prefix:<-> as if it were an infix:<->. please reconsider"

[14:32] <sundar> this looks like a case of a common thing being not-easy, imho.

[14:33] <moritz_> that's what we've been discussing 8 minutes ago, yes

[14:33] <masak> sundar: it's more a case of Perl 6 being all "screw this. let's parse things in one simple way, with no exceptions"

[14:34] <JimmyZ> wonders why perl 5 doesn't.

[14:35] <moritz_> JimmyZ: perl 5 screws up in different ways

[14:35] <moritz_> JimmyZ: print (4 + 5) * 3;

[14:35] <moritz_> JimmyZ: most people expect that to print 27 - it prints 9

[14:35] <masak> moritz_++

[14:35] <moritz_> because it's parsed as ( print(4 + 5) ) * 3

[14:36] <masak> yes, that's one big thing that led to the current parsing decisions, I guess.

[14:36] <masak> bad thing is, it's a rule you have to learn in order to get things right. good thing is, it's pervasive for everything in Perl 6.

[14:36] <moritz_> many perl regulars hate the notion of whitespace affecting parsing. But newcomers expect it to DWTM

[14:36] <masak> so you learn it once and apply it everywhere.

[14:36] <JimmyZ> 'print time - $a' and 'print time-$a' are the same.

[14:37] <moritz_> and your point is...?

[14:38] <JimmyZ> rakudo: say 5 - 3;

[14:38] <p6eval> rakudo 6783b5: OUTPUT«2␤»

[14:38] <moritz_> rakudo: say -3

[14:38] <p6eval> rakudo 6783b5: OUTPUT«-3␤»

[14:38] <moritz_> both do what I mean

[14:38] <moritz_> great, no?

[14:38] <JimmyZ> yes

[14:39] *** mariano__ left
[14:39] <moritz_> you can't have  <listop> <prefix><term> working in one case and not in another

[14:39] <masak> question is, why doesn't &time complain when it gets >0 arguments?

[14:39] <moritz_> so it's a tradeoff

[14:39] <moritz_> masak: bug, I'd say

[14:39] * masak submits rakudobug

[14:39] <JimmyZ> rakudo: my $a = time; (1,1,*+* ... *).batch(28).perl.say; my $b = time; say $b - $a; # sounds like it's faster than parrot's fib.pir? I'm curious

[14:39] <p6eval> rakudo 6783b5: OUTPUT«(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811)␤0.205471992492676␤»

[14:39] <masak> after it's fixed, at least JimmyZ and the likes of him will get a runtime error.

[14:40] <[particle]> masak: i wonder if your irc client could be configured to submit a bug when you type that...

[14:40] *** justatheory joined
[14:40] <masak> [particle]: what makes you think it doesn't? :P

[14:40] <dalek> book: da67c46 | smash++ | src/ (4 files):

[14:40] <dalek> book: Several small fixes.

[14:40] <dalek> book: review: http://github.com/perl6/book/commit/da67c46683bcfa1c3490af345bfa5e122d8a12f0

[14:40] <sundar> masak: yes, unless the function in question optionally accepts arguments too!

[14:40] <masak> [particle]: actually, I've come to the (somewhat hubristic) conclusion that the task is not automatable.

[14:41] <[particle]> sure it is! for the rest of us....

[14:41] <[particle]> :P

[14:41] <masak> sundar: that's why you need to actually learn the actual rule... :)

[14:42] <pmichaud> http://www.perlmonks.org/?node_id=836533

[14:42] <masak> that's a lovely list.

[14:43] <[particle]> how long are your cuffs, pmichaud?

[14:43] <JimmyZ> Yeah, I runtime error is ok for me, at least it is not strange

[14:43] <[particle]> wow, that's a long list.

[14:44] <pmichaud> [particle]: I write in a small font.

[14:44] <colomon> the perl 6 advent calendar link is wrong.  :(

[14:44] <pmichaud> actually, that's a short list.

[14:44] <colomon> http://perl6advent.wordpress.com/

[14:45] <pmichaud> colomon++ # fixed

[14:45] <pmichaud> (well, as soon as perlmonks updates)

[14:45] <pmichaud> I didn't include a lot of the individual blog postings from use.perl or other sources

[14:46] * masak should do more things like the "3D, baby!" post

[14:46] <masak> cheap tricks with visually appealing results.

[14:48] <colomon> masak++

[14:49] <moritz_> rakudo: say 1 ~~ Real

[14:50] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[14:50] <moritz_> rakudo: say 1.1 ~~ Real

[14:50] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[14:50] <moritz_> rakudo: say 1e1 ~~ Real

[14:50] <jnthn> rakudo: say "bacon" ~~ Real

[14:50] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[14:50] <p6eval> rakudo 6783b5: OUTPUT«0␤»

[14:50] <moritz_> colomon++

[14:50] <jnthn> bacon isn't real?!

[14:50] <moritz_> imaginary bacon!

[14:50] <masak> or surreal bacon...

[14:50] <pmichaud> lots of bacon these days is Artificial.  :-)

[14:50] <colomon> bacon is definitely complex.

[14:51] * masak .oO( hypercomplex bacon o.O )

[14:52] <cognominal> surreal bacon?

[14:52] <dalek> book: 24ca22d | moritz++ | src/multi-dispatch.pod:

[14:52] <dalek> book: [mmd] now that we have Real, there is no need for separate Num and Int candidates

[14:52] <dalek> book: review: http://github.com/perl6/book/commit/24ca22d8d3b6cdf223a781433edceaf2a75d80ff

[14:52] <masak> cognominal: http://en.wikipedia.org/wiki/Surreal_number

[14:52] <cognominal> oops, already done by masak...

[14:52] <masak> oh, you wasn't wondering what it was... :)

[14:53] <cognominal> :)

[14:54] *** mariano__ joined
[14:54] <bbkr> rakudo: class class { }; # reported in 67784

[14:54] <p6eval> rakudo 6783b5:  ( no output )

[14:54] <moritz_> rakudo: class class { }; class.new.perl.say

[14:54] <p6eval> rakudo 6783b5: OUTPUT«Malformed package declaration at line 11, near ".new.perl."␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[14:54] <bbkr> rakudo: class class { }; class class{}; # but it warns on 2nd declaration :)

[14:55] <p6eval> rakudo 6783b5: OUTPUT«Illegal redeclaration of symbol 'class'␤current instr.: 'perl6;Perl6;Grammar;_block249' pc 40603 (src/gen/perl6-grammar.pir:346)␤»

[14:57] <masak> right. it's just the mention of it after declaration that doesn't work.

[14:57] <bbkr> so is "class" legal class name?

[14:58] <moritz_> std: class class { }; class.new.perl.say

[14:58] <p6eval> std 30455: OUTPUT«ok 00:01 109m␤»

[14:58] <moritz_> yes.

[14:59] <moritz_> rakudo: my @scores = 'Ana' => 8, 'Dave' => 6, 'Charlie' => 4, 'Beth' => 4;

[14:59] <p6eval> rakudo 6783b5:  ( no output )

[14:59] <masak> if it's an unused identifier, it's a legal class name.

[14:59] <bbkr> then http://rt.perl.org/rt3/Ticket/Display.html?id=67784 can be closed i think

[15:00] <masak> no, it still gives the same type of error.

[15:00] <moritz_> just not at the time of declaration

[15:00] <moritz_> but later on

[15:00] <masak> no, it did that before too.

[15:00] <masak> only the error is different now than it was in alpha.

[15:01] <bbkr> ok

[15:01] <masak> so nothing has changed, really. only the wording of the error message.

[15:01] *** steinberg joined
[15:01] <masak> std: class class {}; say class.new.perl

[15:01] <p6eval> std 30455: OUTPUT«ok 00:01 109m␤»

[15:01] <masak> see? :)

[15:02] * moritz_ found a very weird bug

[15:02] <moritz_> rakudo: printf 'foobar'

[15:02] <p6eval> rakudo 6783b5: OUTPUT«foobar»

[15:03] <moritz_> rakudo: printf '%- 8%s', 'XXX', 'bla

[15:03] <p6eval> rakudo 6783b5: OUTPUT«Confused at line 11, near "printf '%-"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[15:03] <moritz_> rakudo: printf '%- 8%s', 'XXX', 'bla'

[15:03] <p6eval> rakudo 6783b5:  ( no output )

[15:03] <bbkr> masak: I see :) sorry

[15:03] <masak> bbkr: no problem. :) better luck next time.

[15:04] <moritz_> rakudo: printf '%- 8%s' ~ "\n", 'XXX', 'bla'

[15:04] <p6eval> rakudo 6783b5:  ( no output )

[15:04] <masak> what's weird is that it doesn't print anything.

[15:04] <moritz_> right

[15:04] <moritz_> it doesn't like the format string

[15:04] <moritz_> with good reason, I might add

[15:05] * masak submits rakudobug

[15:05] <moritz_> but then it should please die() or fail() or interpret it literally

[15:05] *** nihiliad joined
[15:05] *** JimmyZ left
[15:05] <masak> I've experienced &say do the same lately, I think. but only on the evalbot.

[15:05] <masak> this, however, occurs locally too.

[15:06] <moritz_> locally is how I found it

[15:06] <moritz_> rakudo: for 1, 2 { printf '%- 8%s', 1, 2; say "alive" }; say "alive2"

[15:06] <p6eval> rakudo 6783b5: OUTPUT«alive␤alive␤alive2␤»

[15:06] <moritz_> rakudo: for 1, 2 {say  printf '%- 8%s', 1, 2; };

[15:06] <p6eval> rakudo 6783b5:  ( no output )

[15:07] <moritz_> now not even the say() produces a newline

[15:07] <bbkr> rakudo: say 1/0; say "Alive"; say (1/0).Num # http://rt.perl.org/rt3/Ticket/Display.html?id=68960 looks like fixed now, Rat() returns Inf

[15:07] <p6eval> rakudo 6783b5: OUTPUT«Inf␤Alive␤Inf␤»

[15:08] <moritz_> aye

[15:08] <moritz_> just needs testing

[15:08] <masak> maybe assign it to moritz_, then?

[15:09] <moritz_> oh, actually it has tests alrready, in S32-num/rat.t

[15:09] <masak> bbkr: do you have privs to close tickets?

[15:10] *** alester joined
[15:11] <bbkr> no, i'm just visiting RT to learn some cool P6 usage for golfing :) and sometimes i hit something that is fixed.

[15:12] * masak closes the ticket

[15:12] <masak> bbkr: seems we could eliminate a step in this process by giving you privs :)

[15:13] * moritz_ also closed it

[15:13] <moritz_> OH NOEZ, we haz closing race!

[15:13] <masak> I actually noticed before pushing submit :)

[15:13] <masak> moritz_++ # fast

[15:15] <bbkr> masak: sure. my account on RT is "bbkr" (i will ask here every time before i close ticket anyway).

[15:16] <masak> bbkr: I think pmichaud has the meta-privs to give you privs.

[15:16] <dalek> book: c8aefbb | moritz++ | src/operators.pod:

[15:16] <dalek> book: [ops] working code, screen output

[15:16] <dalek> book: review: http://github.com/perl6/book/commit/c8aefbb02a0e11237522e4bc9f75c9a869ce0fcf

[15:16] <dalek> book: 39769b6 | moritz++ | src/multi-dispatch.pod:

[15:16] <dalek> book: [mmd] number of type checks is implementation dependent

[15:16] <dalek> book: review: http://github.com/perl6/book/commit/39769b6d6c9096ce13529b0a378d8a35f3a002b2

[15:17] <masak> phenny: tell pmichaud that I think bbkr could use rw access to RT. he says he's in there anyway looking for golfed Perl 6, and sometimes he stumbles on fixed things and brings them to the channel. :)

[15:17] <phenny> masak: I'll pass that on when pmichaud is around.

[15:17] <bbkr> thanks :)

[15:17] *** JimmyZ joined
[15:17] <masak> bbkr++ # -Ofun

[15:23] *** molaf joined
[15:27] <parrot|Coke> I also have privs on RT, btw. I think.

[15:27] <parrot|Coke> leftover from languages/rakudo days.

[15:28] <dalek> book: 62090c3 | smash++ | src/multi-dispatch.pod:

[15:28] <dalek> book: [mmd] subtype checks blocks number of executed times is implementation specific

[15:28] <dalek> book: review: http://github.com/perl6/book/commit/62090c3f607737a64dfdfc4435e311aba404220b

[15:31] <parrot|Coke> masak, bbkr  - try now?

[15:32] <bbkr> i have Take/Resolve options now, thanks

[15:32] <moritz_> rakudo: class A is Hash { }; my $x = A.new; $x<foo> = 'bar'; say $x.keys

[15:32] <masak> \o/ parrot|Coke++

[15:32] <p6eval> rakudo 6783b5: OUTPUT«foo␤»

[15:32] <parrot|Coke> just coke is fine. =-)

[15:35] *** Sanitoeter left
[15:36] <[particle]> parrot|Coke++ # better nick

[15:37] <parrot|Coke> sure, rakudoGSOCTPFParrot|particle++

[15:40] *** Sanitoeter joined
[15:40] *** molaf_ joined
[15:40] <sundar> I remember someone had the problem of make-ing rakudo taking hours. It's happening to me now, is there a workaround? 

[15:41] <masak> there was a time when I had to ulimit -v, but I don't anymore.

[15:41] <moritz_> sundar: are you building latest rakudo?

[15:41] *** molaf left
[15:42] <sundar> yes, after a fresh git pull and configure with gen-parrot

[15:43] <sundar> I'm running it in an ubuntu VM inside Vista, in case it matters... 

[15:43] <moritz_> how much memory is available inside the vm?

[15:45] <sundar> 512MB 

[15:45] <moritz_> that might be a wee bit tight

[15:46] <sundar> Ok, would 1G be enough? or how much would you recommend?

[15:46] <moritz_> I know that building rakudo stays below 1G these days

[15:46] <moritz_> don't know how much the rest of your system needs

[15:46] <moritz_> 1.5G should be fairly safe

[15:47] <bbkr> rakudo: #=======␤#=======␤use v6;

[15:47] <p6eval> rakudo 6783b5:  ( no output )

[15:47] <bbkr> cool, so http://rt.perl.org/rt3/Ticket/Display.html?id=70752 is also solved, right?

[15:47] <moritz_> bbkr: yes, just needs tests

[15:48] <moritz_> bbkr: either write a test, or just assign the ticket to me

[15:48] <moritz_> (Basics -> owner)

[15:48] <sundar> moritz_: thanks... 

[15:48] *** jonrafkind joined
[15:49] <moritz_> (but writing tests is preferred, of course :)

[15:49] *** jonrafkind left
[15:49] *** jonrafkind joined
[15:50] <bbkr> tests are in PUGS repo?

[15:50] <moritz_> yes

[15:50] <moritz_> do you have commit acces to it?

[15:50] <bbkr> ok, i have a commit bit there.

[15:50] <moritz_> great

[15:58] <[particle]> sundar: after you build rakudo, you can lower the vm memory back down to 512mb

[15:59] <moritz_> ...unless you want to test rakudo

[15:59] <[particle]> ha, fair point.

[15:59] <k23z__> masak, I read the backlog saw yesterday you mentioned surreal numbers

[16:00] <k23z__> masak, I actually read very closely a paper on them and stood with pencil and paper near to follow all the proofs

[16:00] <k23z__> masak, Knuth has a book on them and Harry Gonshor has a more axiomatic book out on them(which I haven't been able to get)

[16:00] <k23z__> masak, in any case I saw some Haskell people implement them

[16:00] *** jaldhar left
[16:00] <k23z__> I'm curious if they could be implemented in Perl6(we'd need infinite lists for that)

[16:01] <k23z__> and a symbolic computation package

[16:01] <moritz_> we have inifite lists

[16:01] <moritz_> (though some operations are a bit painful on them)

[16:01] <bbkr> moritz_: test for http://rt.perl.org/rt3/Ticket/Display.html?id=70752 should be put in t/spec/S02-whitespace_and_comments/comments.t ?

[16:02] <k23z__> moritz_, example please ?

[16:02] <cognominal> rakudo:  sub saiz {  sub saizz { say "hi" };  saizz() }  saiz()

[16:02] <p6eval> rakudo 6783b5: OUTPUT«Confused at line 11, near "sub saiz {"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[16:02] <moritz_> bbkr: yes... but rakudo currently doesn't run that test file

[16:02] <[particle]> painful operations on infinite lists... like sort?

[16:02] <moritz_> k23z__: iterating with 'for'

[16:03] <moritz_> map works, though

[16:03] <k23z__> moritz_, what's the problem iterating it with for ?

[16:03] <moritz_> k23z__: it's eager

[16:03] <k23z__> for is eager to have all elements ?

[16:03] <k23z__> is that what you mean ?

[16:04] <moritz_> yes

[16:04] <k23z__> can the interpreter detect that the infinite list is a "special data structure" and behave differently ?

[16:05] <moritz_> that's not the fix that for needs

[16:05] *** proller left
[16:05] <k23z__> what would fix it then ?

[16:05] *** proller joined
[16:06] <moritz_> making it lazy, and implementing sink context

[16:06] *** nihiliad left
[16:06] *** nihiliad joined
[16:08] <jnthn> for really should just use map.

[16:08] <moritz_> but it can't, until we get sink context.

[16:11] <masak> would 'next' and 'last' work in map as they do in for?

[16:11] <masak> what about 'redo'?

[16:11] <colomon> masak: yes

[16:11] <colomon> but they don't work there now.

[16:11] <moritz_> phenny: tell pmichaud that I've pushed branches called 'mob2' to both nqp-rx and rakudo -- real integration isn't possible until rakudo builds again on parrot HEAD

[16:11] <phenny> moritz_: I'll pass that on when pmichaud is around.

[16:11] <masak> colomon: explain the semantics of a 'redo' in map for me.

[16:11] <masak> s/for/to/

[16:12] <moritz_> "same as in for"

[16:12] <masak> right, so it re-starts the block.

[16:12] <masak> I get that.

[16:12] <masak> what about the effect on the resulting list?

[16:12] * colomon doesn't understand how redo works in for...

[16:13] <masak> 'same as in map' :P

[16:13] <moritz_> masak: the instance of the block that called redo() doesn't contribute to the result list

[16:13] <colomon> moritz_: same is true of next?

[16:13] <masak> moritz_: oh, ok.

[16:14] <moritz_> colomon: not sure if next() would return an empty parcel

[16:14] <moritz_> s/return/insert/

[16:14] <masak> doesn't next take a value which becomes the return value of the block?

[16:14] * masak STR reading that

[16:14] <colomon> so you can say    next $a;   ?

[16:14] <colomon> interesting.

[16:15] <masak> &?BLOCK.next($retval);

[16:15] <masak> S04:342

[16:17] <[particle]> unlike perl 5, for and foreach are not synonyms in perl 6.  now, for and map are synonymous.

[16:17] <[particle]> uggh.

[16:17] <pugssvn> r30456 | masak++ | [S03] corrected typo 

[16:17] <masak> [particle]: mostly, it seems, because for has become like map, not the other way around.

[16:18] <masak> [particle]: and they're still quite different syntactically.

[16:19] <[particle]> aye, you'll prefer one over the other simply because you're thinking functionally or procedurally

[16:20] <masak> that's about it, yes.

[16:21] <masak> I've been known sometimes to abuse map as if it were for.

[16:22] <JimmyZ> Good night, #perl6

[16:23] <JimmyZ> Good night, #perl6

[16:23] *** JimmyZ left
[16:23] <masak> JimmyZ: 'night

[16:23] *** bradb joined
[16:23] <masak> 晚安

[16:26] *** cdarroch joined
[16:26] *** cdarroch left
[16:26] *** cdarroch joined
[16:37] <lisppaste3> bbkr pasted "mortiz - please validate my test" at http://paste.lisp.org/display/98205

[16:37] <bbkr> moritz* sorry about name-typo

[16:39] <moritz_> bbkr: looks good

[16:40] <pugssvn> r30457 | bbkr++ | test against http://rt.perl.org/rt3/Ticket/Display.html?id=70752 bug 

[16:41] *** jaldhar joined
[16:42] *** sundar left
[16:49] *** jaldhar left
[16:53] *** jaldhar joined
[16:54] <pmichaud> http://www.perlmonks.org/?node_id=836564

[16:54] <phenny> pmichaud: 15:17Z <masak> tell pmichaud that I think bbkr could use rw access to RT. he says he's in there anyway looking for golfed Perl 6, and sometimes he stumbles on fixed things and brings them to the channel. :)

[16:54] <phenny> pmichaud: 16:11Z <moritz_> tell pmichaud that I've pushed branches called 'mob2' to both nqp-rx and rakudo -- real integration isn't possible until rakudo builds again on parrot HEAD

[16:55] <masak> pmichaud: parrot|Coke++ already fixed that.

[16:55] <pmichaud> masak: the bbkr access?

[16:55] <masak> aye

[16:55] *** dakkar left
[16:55] <pmichaud> okay, thanks.  Coke++

[16:55] <masak> wow, perlmonks *is* slow.

[16:57] <dalek> book: 470ed50 | masak++ | src/operators.pod:

[16:57] <dalek> book: [operators] rw review

[16:57] <dalek> book: review: http://github.com/perl6/book/commit/470ed501fc044bdf604d6d405d5c974272c37a5a

[16:58] *** japhb left
[16:59] <bbkr> rakudo: say "3".Num; # http://rt.perl.org/rt3/Ticket/Display.html?id=67050 also solved?

[16:59] <p6eval> rakudo 6783b5: OUTPUT«3␤»

[17:00] <moritz_> bbkr: yes. And sufficiently tested already

[17:01] <moritz_> rakudo: say "3".Numeric # according to latest spec

[17:01] <p6eval> rakudo 6783b5: OUTPUT«3␤»

[17:01] <bbkr> rakudo: say (+"3").WHAT

[17:01] <p6eval> rakudo 6783b5: OUTPUT«Num()␤»

[17:02] <masak> pmichaud++ # '*I* have an apple pie'

[17:02] <bbkr> should i close it?

[17:03] <cognominal> rakudo:  class A {  my $a="hi";  method a { say $a } };   A.new.a();

[17:03] <p6eval> rakudo 6783b5: OUTPUT«hi␤»

[17:04] <cognominal> so, that's the substitue for private class variable?

[17:05] *** jaldhar left
[17:05] <cognominal> too bad there is not a twigil when using them

[17:05] *** jaldhar joined
[17:07] *** XaeroOne joined
[17:12] *** envi^home left
[17:15] <colomon> rakudo: say ('a'..'f').rotate

[17:15] <p6eval> rakudo 6783b5: OUTPUT«Method 'rotate' not found for invocant of class 'Range'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:15] <cognominal>  I could see a inverted exclamation marjkfor a my class variable twigil  ¡

[17:15] <colomon> rakudo: say ('a'..'f').Seq.rotate

[17:15] <p6eval> rakudo 6783b5: OUTPUT«bcdefa␤»

[17:15] <cognominal> And a degree ° for a our class variable twigil.

[17:16] <colomon> rakudo: say ('a'..'f').Seq[1..*]

[17:16] <cognominal> It would be a good parallel to the . and ! twigils for the instance variables

[17:16] <p6eval> rakudo 6783b5:  ( no output )

[17:16] <colomon> rakudo: say ('a'..'f').Array[1..*]

[17:16] <p6eval> rakudo 6783b5: OUTPUT«Method 'Array' not found for invocant of class 'Range'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:16] *** brrant joined
[17:17] <colomon> rakudo: say ('a'..'f').Seq.Array[1..*]

[17:17] <p6eval> rakudo 6783b5: OUTPUT«Method 'Array' not found for invocant of class 'Seq'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:17] <cognominal> I am sure someone will find a use for a ¿ twigil :)

[17:18] <parrot|Coke> rakudo:  say ([\+]<112 -3 -4 -6 5 -7 20 -17 -57 0>)>>.chr

[17:18] <[particle]> for spanish-language optional-named variables?

[17:18] <p6eval> rakudo 6783b5: OUTPUT«pmichaud++␤»

[17:18] <parrot|Coke> whee.

[17:18] <colomon> parrot|Coke++

[17:19] <colomon> I'm impressed that it worked even though you handed it string versions of the numbers.  :)

[17:20] <cognominal> WHOA THERE :  http://en.wikipedia.org/wiki/Interrobang

[17:20] <cognominal> WTF‽

[17:20] <colomon> rakudo: say "pmichaud++".split>>.ord

[17:20] <p6eval> rakudo 6783b5: OUTPUT«No applicable candidates found to dispatch to for 'split'. Available candidates are:␤:(Mu : Regex $matcher, Any $limit = { ... }, Any :all($all);; *%_)␤:(Mu : Any $delimiter, Any $limit = { ... }, Any :all($all);; *%_)␤␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:20] <colomon> rakudo: say "pmichaud++".comb>>.ord

[17:20] <p6eval> rakudo 6783b5: OUTPUT«11210910599104971171004343␤»

[17:21] <colomon> rakudo: say [\-] ("pmichaud++".comb>>.ord)  # don't think this is right, but...

[17:21] <p6eval> rakudo 6783b5: OUTPUT«1123-102-201-305-402-519-619-662-705␤»

[17:22] *** ShaneC1 joined
[17:25] *** pausenclown joined
[17:25] <bbkr> what does .WALK method do? cannot find it in S*

[17:26] <moritz_> S12

[17:26] <colomon> rakudo: my ($first, @rest) = ("pmichaud++".comb>>.ord); say @rest;

[17:26] <p6eval> rakudo 6783b5: OUTPUT«109 105 99 104 97 117 100 43 43␤»

[17:26] <masak> S12:872, even.

[17:26] *** iblechbot left
[17:27] <moritz_> colomon: you're such a hilight spammer :-)

[17:28] <colomon> blame parrot|Coke, I'm just trying to reverse engineer his brilliance.

[17:28] <colomon> ;)

[17:29] <parrot|Coke> yah, I hand rolled that. I'd like to see a one liner to create it, though. keep trying. =-)

[17:29] <masak> food &

[17:30] *** masak left
[17:30] *** eternaleye left
[17:31] <colomon> somebody else should take it up, I need to $work.

[17:33] <moritz_> my $i = 0; for 'pmic'.comb».org { say $_ - $i; $i = $_ }

[17:33] <moritz_> rakudo: my $i = 0; for 'pmic'.comb».org { say $_ - $i; $i = $_ }

[17:33] <p6eval> rakudo 6783b5: OUTPUT«Method 'org' not found for invocant of class 'Str'␤current instr.: '!dispatch_method_parallel' pc 359 (src/glue/dispatch.pir:72)␤»

[17:33] <moritz_> rakudo: my $i = 0; for 'pmic'.comb».ord { say $_ - $i; $i = $_ }

[17:33] <p6eval> rakudo 6783b5: OUTPUT«112␤-3␤-4␤-6␤»

[17:33] <moritz_> that recreates the numbers

[17:33] <colomon> moritz_++

[17:33] <moritz_> and boring, I know

[17:35] <pausenclown> spot the error: 

[17:35] <pausenclown> enum Foo <<0x1 0x2 0x4 0x8 0x16 0x32>>; 

[17:35] <colomon> rakudo: my $i = 0; my @a = gather for 'pmic'.comb».ord { take $_ - $i; $i = $_ }; say @a.perl

[17:35] <p6eval> rakudo 6783b5: OUTPUT«[112, -3, -4, -6]␤»

[17:36] <moritz_> p6eval: you're using weird names for your enum values :-)

[17:36] <moritz_> erm, I meant pausenclown 

[17:38] <parrot|Coke> moritz_, colomon: well that would have simplified things. =-)

[17:38] <pausenclown> i actually meant using 0x16 instead 0xA but yeah, that too

[17:38] *** japhb joined
[17:38] *** smash_ left
[17:38] <moritz_> that said, named enums are NYI in master

[17:38] *** Sanitoeter left
[17:39] *** jaldhar left
[17:40] *** jaldhar joined
[17:40] *** Sanitoeter joined
[17:41] *** supernovus joined
[17:41] <bbkr> rakudo: my @t = 1, 2; say @t[0..*];

[17:41] <p6eval> rakudo 6783b5:  ( no output )

[17:42] <bbkr> oops :)

[17:42] <diakopter> heh

[17:43] <colomon> rakudo: my @t = 1, 2; say @t[0..1];

[17:43] <p6eval> rakudo 6783b5: OUTPUT«12␤»

[17:43] <colomon> rakudo: my @t = 1, 2; say @t[0..10];

[17:43] <p6eval> rakudo 6783b5: OUTPUT«12␤»

[17:43] <parrot|Coke> that looks like a bug to me. izzit?

[17:43] <jnthn> rakudo: my @t = 1, 2; say @t[0..10].elems;

[17:43] <p6eval> rakudo 6783b5: OUTPUT«11␤»

[17:43] <diakopter> itza feature!

[17:44] <colomon> parrot|Coke: what?

[17:44] <bbkr> timeout / OOM error? looks like it is trying to build infinite 0..* array without checking if it makes sense.

[17:44] <colomon> bbkr: right.  for sure your example is a bug.

[17:45] *** jaldhar left
[17:45] *** _jaldhar joined
[17:45] <parrot|Coke> I would expect 0..* to show everything it had. no?

[17:46] <colomon> parrot|Coke: That's my expectation as well.

[17:46] *** _jaldhar left
[17:46] <parrot|Coke> \o/

[17:46] *** _jaldhar joined
[17:46] <bbkr> colomon: something similar was discussed here: http://rt.perl.org/rt3/Ticket/Display.html?id=64566  and it "almost" worked back then :)

[17:47] <colomon> what about @t[0..10] ?  Should it work like @t[0..*] on a two-element array, or complain because you've explicitly specified a value past the end?

[17:47] <bbkr> it's in S09: As the end-point of a range, a lone "whatever" means "to the maximum specified index

[17:48] <TimToady> any range that goes over the end is considered okay

[17:48] <colomon> TimToady: Thanks!

[17:50] *** _jaldhar left
[17:50] *** _jaldhar joined
[17:54] * colomon is utterly mystified by the wide assortment of postcircumfix:<[ ]> methods in Rakudo....

[17:55] *** stephenlb joined
[17:56] *** _jaldhar left
[17:56] *** _jaldhar joined
[17:56] *** supernovus left
[17:57] <bbkr> rakudo: enum X <x>; say x;

[17:57] <p6eval> rakudo 6783b5: OUTPUT«Could not find sub &x␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[17:57] <moritz_> named enums are NYI

[17:57] <bbkr> thanks

[18:01] *** _jaldhar left
[18:01] <bbkr> rakudo: class A {}; A::B.parse(""); # i see nice message instead of NULL PCM access, so i think http://rt.perl.org/rt3/Ticket/Display.html?id=63460 is fixed

[18:01] <p6eval> rakudo 6783b5: OUTPUT«Can not find sub A::B␤current instr.: 'perl6;Perl6Exception;throw' pc 14877 (src/builtins/Seq.pir:28)␤»

[18:03] <jnthn> oh wow, another ticket about that bug?!

[18:03] * jnthn htought he'd found them all

[18:03] <bbkr> although test can be corrected, because now it says '# TODO: Check for a good error message, not just the absence of a bad one'. can regexp for rakudo error message be placed in PUGS repo?

[18:03] <jnthn> If I had a bottle of beer for every ticket about that issue... :-)

[18:05] <parrot|Coke> when you say a rakudo error message... do you mean a parrot one?

[18:05] <parrot|Coke> I would say if it's a Null PMC access, no.

[18:05] <Khisanth> you would be dying from alcohol poisoning?

[18:06] <jnthn> Khisanth: Well, I'd not drink them all at once... :p

[18:07] <jnthn> bbkr: A test for "Null PMC Access" not being givne is probably bad. A test that the error message does indeed contain A::B, otoh, is good.

[18:08] *** _jaldhar joined
[18:10] <bbkr> yes, that's what i have in mind. but i don't know how to extract this error message. $@ obviously is not in use in P6 anymore.

[18:12] *** _jaldhar left
[18:15] *** _jaldhar joined
[18:18] *** dKingston joined
[18:18] *** rv2733 left
[18:21] <jnthn> $!

[18:27] *** _jaldhar left
[18:29] <sjn> pmichaud++ # good anti-FUD writeups

[18:31] *** _jaldhar joined
[18:33] <TimToady> at some point it may become a waste of time, especially if the real goal of any of the A. Monks is to waste our time.

[18:34] <TimToady> but it's valuable for the other people who aren't in that category, so far

[18:34] *** meppl left
[18:34] <sjn> well, at least the discussion is public, so we can refer to it later

[18:34] <TimToady> and hopefully our hints will help other folks step up to the plate

[18:35] <cognominal> difficult to win against the omnipresent ominous anonymous...

[18:35] <cognominal> the proof of the cake will be in the eating. I am hungry :)

[18:35] <TimToady> At some point you just have to classify some people as the illigitimi that you are non carborundum.

[18:35] <cognominal> TimToady++

[18:36] * sjn think it would be worse to let that FUD-sillyness go unanswered, so I'm very happy to see pmichaud++, chromatic++, TimToady++ and others give good and thoughtful answers

[18:36] <TimToady> in balance, it's a good thing to do periodically

[18:37] *** jonathansizz joined
[18:37] <TimToady> s/illigitimi/illegitimi/

[18:37] <sjn> nothing says "there might be something good going on there" as a bunch of people passionately talking about it :)

[18:38] *** bbkr left
[18:38] <TimToady> depends on the "it", which varies...

[18:39] <sjn> and the type of passion :-P

[18:39] <TimToady> progress also requires some dispassion :)

[18:41] * sjn strives to be passionately dispassional :)

[18:43] <TimToady> The community needs various kinds of folks, some choleric, some sanguine, some melancholy, and some phlegmatic.  And people who can interpret these groups to each other.

[18:43] <cognominal> as says the wikipedia about the Christ's passion :  "The etymological origins of the word lie in the Greek verb paschō, to suffer"

[18:45] *** dual joined
[18:45] <diakopter> yes, but the english 'suffer' was used in the same gospels to mean "permit"/"allow"

[18:45] <TimToady> well, in Elizabethan English

[18:45] <diakopter> s/but//

[18:46] <TimToady> I believe the wikipedia is written in Modern English

[18:46] <diakopter> sometimes.

[18:46] <TimToady> which is kinda like Modern Perl

[18:46] *** _jaldhar left
[18:46] *** XaeroOne left
[18:47] <cognominal> I am not sure the wikipedia is always very strict.

[18:47] <diakopter> pain must be either tolerated as bad or embraced

[18:47] *** jonathansizz left
[18:47] <cognominal> ORIGIN Middle English : from Anglo-Norman French suffrir, from Latin sufferre, from sub- ‘from below’ + ferre ‘to bear.’

[18:48] <diakopter> origin !implies usage

[18:49] <cognominal> interesting to see that these words have evolved similarly in French and English

[18:49] <TimToady> yes, that's known as the etymological fallacy

[18:49] *** _jaldhar joined
[18:49] <TimToady> another fallacy is assuming that the fuzzy meaning of a word in one language matches the fuzz in a different language

[18:49] <cognominal> passion interpreted in a more a positive way, and suffering in more negative one.

[18:50] <TimToady> we also mustn't read newer meanings back into old usages

[18:51] <TimToady> something which is a technical term now wasn't necessarily a technical term then

[18:52] <TimToady> if someone talks about junctions in Perl in 1995, they don't mean what we mean now

[18:52] <diakopter> it's hard to be dispassionate sometimes, and it's hard to be passionate sometimes

[18:52] <TimToady> it's just hard most of the time, which is why everyone has to pace themselves if they don't want to burn out

[18:53] <TimToady> some people choose to burn out, especially if they see that they can make more progress and then hand their "church" off to the care of others.

[18:54] <TimToady> in that sense, I choose to be less of a messianic figure, and more of a ground-of-all-being figure :)

[18:54] <cognominal> well, suffering (sic) eczema, the burnout is built-in in me, etymologically speaking.

[18:56] *** _jaldhar left
[18:56] *** molaf_ left
[18:56] <diakopter> some burnouts are flameouts from lack of fuel; some burnouts are extinguishments from lack of catalyst

[18:58] *** _jaldhar joined
[18:58] <TimToady> and some people are naturally hares rather than tortoises

[19:00] <cognominal> rakudo: say Mu.WHAT

[19:00] <p6eval> rakudo 6783b5: OUTPUT«Mu()␤»

[19:00] <cognominal> what are the point of the parentheses?

[19:00] <cognominal> rakudo: say Mu.WHAT.perl

[19:00] <p6eval> rakudo 6783b5: OUTPUT«Mu␤»

[19:01] <diakopter> rakudo: say Mu.WHAT.perl.WHICH

[19:01] <p6eval> rakudo 6783b5: OUTPUT«Mu␤»

[19:01] <diakopter> Mu is an interesting memory offset

[19:01] <moritz_> uhm

[19:02] <TimToady> the idea is to indicate undefinedness somehow, especially if the string pops out where you weren't expecting it

[19:02] <moritz_> you asked a string

[19:02] <moritz_> not Mu

[19:02] <TimToady> we've considered other mechanisms besides ()

[19:02] <cognominal> rakudo: say Mu.WHICH

[19:02] <p6eval> rakudo 6783b5: OUTPUT«34631008␤»

[19:02] <TimToady> inverse-video, blinking would also work :)

[19:05] <TimToady> M͟u

[19:06] <cognominal> :)

[19:06] *** patspam joined
[19:06] <TimToady> M͞u

[19:09] *** jonathansizz joined
[19:09] <parrot|Coke> rakud: say Mu.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT

[19:10] <parrot|Coke> rakudo: say Mu.WHAT.WHAT.WHAT.WHAT.WHAT.WHAT

[19:10] <p6eval> rakudo 6783b5: OUTPUT«Mu()␤»

[19:10] * parrot|Coke wonders if rakud means anything.

[19:10] <jnthn> It means that you failed to type an "o".

[19:10] <pausenclown> does someone here know this book: http://oreilly.com/catalog/9781934356456 ?

[19:10] * jnthn git pull's the days changes

[19:11] *** SmokeMachine left
[19:11] <TimToady> std: subset M͞u of Mu; say M͞u;

[19:11] <p6eval> std 30457: OUTPUT«ok 00:01 109m␤»

[19:12] <TimToady> rakudo: subset M͞u of Mu; say M͞u;

[19:12] *** ive joined
[19:12] <p6eval> rakudo 6783b5: OUTPUT«Confused at line 11, near "subset M\u035eu"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[19:12] <cognominal> pausenclown, the reviews seem god on amazon

[19:12] <parrot|Coke> subset 7 of 9.

[19:12] *** _jaldhar left
[19:13] *** _jaldhar joined
[19:13] <TimToady> pugs: subset M͞u of Mu; say M͞u;

[19:13] <p6eval> pugs: OUTPUT«*** No such subroutine: "&M\205\158u"␤    at /tmp/ZKz8JTggEZ line 1, column 23-26␤»

[19:13] <jnthn> rakudo: subset M͞u of Mu where 1; say M͞u;

[19:13] <p6eval> rakudo 6783b5: OUTPUT«Confused at line 11, near "subset M\u035eu"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[19:13] <jnthn> :-/

[19:13] <jnthn> omg...what has that char done do my terminal...

[19:14] *** jonathansizz left
[19:14] *** _jaldhar left
[19:14] *** _jaldhar joined
[19:15] <cognominal> works for me on xchat

[19:18] <diakopter> pausenclown: it's almost entirely centered on ANTLR

[19:18] <diakopter> pausenclown: it should be titled  Language Implementation Patterns using ANTLR

[19:18] <cognominal> oops, pauseclown, the book uses java for the examples...

[19:19] <cognominal> more and more, I think the motto for Perl 6 could be "Syntax matters!"

[19:19] * moritz_ likes it

[19:19] <pmichaud> .oO(To which a common response would be.. "So why did you $*!#$ it up?"

[19:20] <cognominal> It is probably obvious to anyone who groks Perl but it seems that the idea is lost on the rest of the world.

[19:20] <diakopter> pmichaud: lolz at your pun

[19:21] <Juerd> cognominal: One problem with "syntax matters" is that it could be conceived as a noun.

[19:22] *** _jaldhar left
[19:22] <cognominal> I don't mind.

[19:25] *** _jaldhar joined
[19:28] *** _jaldhar left
[19:28] *** _jaldhar joined
[19:28] *** baest left
[19:29] *** steinberg left
[19:29] *** am0c joined
[19:29] <cognominal> I did not know about antlr but I suppose that to implement it in Perl 6 would be a worthwhile exercise.

[19:30] <TimToady> std: subset 無 of Mu; say 無;

[19:30] <p6eval> std 30457: OUTPUT«ok 00:01 109m␤»

[19:30] <TimToady> rakudo: subset 無 of Mu; say 無;

[19:30] <p6eval> rakudo 6783b5: OUTPUT«Nominal type check failed for parameter '$original'; expected Any but got Mu instead␤current instr.: 'CREATE_SUBSET_TYPE' pc 343828 (src/gen/core.pir:18677)␤»

[19:31] <TimToady> rakudo: subset 無 of Any where $_ === Mu; say 無;

[19:31] <p6eval> rakudo 6783b5: OUTPUT«Any()␤»

[19:31] <TimToady> rakudo: subset 無 of Mu where 1; say 無;

[19:31] <p6eval> rakudo 6783b5: OUTPUT«Nominal type check failed for parameter '$original'; expected Any but got Mu instead␤current instr.: 'CREATE_SUBSET_TYPE' pc 343828 (src/gen/core.pir:18677)␤»

[19:32] *** jonathansizz joined
[19:32] <TimToady> rakudo: class 無 is Mu {...}; say 無;

[19:32] <p6eval> rakudo 6783b5:  ( no output )

[19:32] <TimToady> rakudo: class 無 is Mu {...}; say 無.perl;

[19:32] <p6eval> rakudo 6783b5: OUTPUT«undef␤»

[19:32] <TimToady> hmm

[19:33] <pmichaud> looks like a fossil to me.

[19:34] <TimToady> rakudo: constant 無 = Mu; say 無;

[19:34] <p6eval> rakudo 6783b5: OUTPUT«Could not find sub &無␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[19:35] <TimToady> lunch &

[19:36] *** SmokeMachine joined
[19:44] *** _jaldhar left
[19:44] *** _jaldhar joined
[19:48] <sorear> (backlog) oh dear.  I guess we need lots of hands on the book, huh, if it's to go from 50 pages to a proper book in (soon)

[19:48] *** Sanitoeter left
[19:49] <sorear> moritz_: Closures are implemented using currying in many compilers, look up the "lambda lifting" transform.  Currying is defined in terms of closures.

[19:50] <moritz_> sorear: thanks

[19:50] *** _jaldhar left
[19:52] *** Sanitoeter joined
[19:54] *** _jaldhar joined
[19:58] *** jaldhar_ joined
[19:59] *** _jaldhar left
[20:02] <sorear> you know, perl 6 is dense enough and has enough entropy that automated fuzz testing might actually work pretty well for finding rakudobugs...

[20:03] <sorear> generate random 20 character sequences and feed them into rakudo

[20:03] *** M_o_C joined
[20:03] <sorear> check for Parrot error messages

[20:03] <moritz_> sorear: you would find too many bugs that way :-)

[20:04] *** Spreadsheet_ joined
[20:06] <sorear> *caught up*

[20:10] *** jaldhar_ left
[20:11] *** ShaneC1 left
[20:13] *** ShaneC1 joined
[20:13] *** jaldhar_ joined
[20:15] *** jonathansizz left
[20:15] *** alester left
[20:19] *** brrant left
[20:21] *** alester joined
[20:21] *** Coleoid joined
[20:27] *** gurjeet joined
[20:27] <gurjeet> buubot: karma gurjeet

[20:27] <buubot> gurjeet: gurjeet has karma of      

[20:28] <diakopter> gurjeet++

[20:28] *** hghgd_ joined
[20:29] <gurjeet> diakopter: When does one get karma?

[20:29] <diakopter> buubot: karma gurjeet++

[20:29] <buubot> diakopter: gurjeet++ has karma of      

[20:29] <sorear> buubot: karma c

[20:29] <buubot> sorear: c has karma of 2845     

[20:30] <moritz_> buubot: karma c++

[20:30] <buubot> moritz_: c++ has karma of -5     

[20:30] <diakopter> buubot: karma C

[20:30] <buubot> diakopter: C has karma of 2846     

[20:30] <diakopter> heh

[20:30] *** hghgd left
[20:30] *** cdarroch left
[20:30] <sorear> why did we get rid of lambdabot

[20:31] <moritz_> because it was very annoying

[20:31] <pmichaud> its noise was far greater than its signal

[20:32] *** brrant joined
[20:32] * sorear wonders how much of that was his fault

[20:32] <moritz_> not much

[20:32] <moritz_> mostly people copying stuff from the REPL

[20:33] <moritz_> or daring to talk about arrays that begin with an @

[20:33] * jnthn is happy it's gone too

[20:34] <jnthn> pmichaud: You still planning to look at array/listy bits at the weekend?

[20:34] * sorear asks as a former major architect thereof

[20:34] <Spreadsheet_> buubot: karma spreadsheet

[20:34] <buubot> Spreadsheet_: spreadsheet has karma of      

[20:34] <pmichaud> jnthn: yes, unless my attention is needed to get it running with parrot trunk

[20:35] <jnthn> pmichaud: OK. One thing that I was planning to but didn't get to...

[20:35] <jnthn> pmichaud: postcircumfix:<{ }> and postcircumfix:<[ ]> now work differently.

[20:35] *** cdarroch joined
[20:35] *** cdarroch left
[20:35] *** cdarroch joined
[20:35] <pmichaud> okay, I can check to see what unifications are needed.

[20:35] <jnthn> pmichaud: The first is how I think it's meant to be.

[20:35] <pmichaud> the list stuff is likely to touch upon them anyway.

[20:35] <jnthn> I didn't get around to getting the latter into that state.

[20:35] <jnthn> Basically though...

[20:36] <jnthn> @a[1,2,3]

[20:36] <jnthn> This passes one argument to postcircumfix:<[ ]>

[20:36] <jnthn> %h{'a','b'} had the same issue, but I fixed it when doing hash slices.

[20:36] <jnthn> Fixing it for arrays means that the multi dispatch sigs call out rather better.

[20:37] <jnthn> (As we now have for hash indexing.)

[20:37] <pmichaud> well, we also have to be able to handle the case of   @a[1,2,3;4,5,6]

[20:37] <sorear> What does that mean?

[20:37] <pmichaud> so in some ways I was also looking into the possibility that top-level args would be semi-separated.

[20:38] <jnthn> AFAICT (but I'm happy to be proven wrong), that's more about the signature really wanting to be **@args rather than *@args

[20:38] <pmichaud> jnthn: that's possible, yes.

[20:38] <jnthn> That is, we unpack in slice mode, not flattening.

[20:38] <pmichaud> since slice mode postdates my thinking on the topic

[20:39] <pmichaud> I'll look at hash slicing and see if I agree or disagree, though.

[20:40] <jnthn> The problem with passing just one thing is that it gets in the way of having one candidate that's essentially the "coerce this to an Int and index"

[20:40] <jnthn> Or in the case of the hash, "just use this to index with"

[20:40] <jnthn> Thus, afaik, is why we have weird bugs sometimes with indexing.

[20:40] <pmichaud> it's not precisely that, I don't think.

[20:41] <jnthn> There may be more to it.

[20:41] <jnthn> Anyway, my feeling is that we probably want to go the way of each index working like an argument.

[20:42] <pmichaud> the problem that I see with postcircumfix:<{ }>  as it sits now is that it doesn't seem to have any provision for handling Whatever closures.

[20:42] <jnthn> I'd need to check what Whatever closures in a postcircumfix:<{ }> mean.

[20:42] <jnthn> S09?

[20:42] <pmichaud> which granted, don't necessarily make sense in the context of .{ }, but .[ ] certainly has to be able to handle them, which is partially why there's a difference.

[20:43] <pmichaud> actually, I suspect whatever inside of .{ }   acts like $.keys

[20:43] <jnthn> Oh, for .[ ] certainly.

[20:43] <pmichaud> for .{ } also

[20:44] <jnthn> specref?

[20:44] <pmichaud> %hash{ *.grep(/^a/) }

[20:44] <jnthn> oh cute.

[20:46] <pmichaud> beyond that, I'm not sure that a candidate of "coerce to Int and index" is in fact the correct behavior.

[20:46] <pmichaud> that said, I'll take a look at it soon, and I'll see if I can bias towards the multi-argument form for you.

[20:47] <pmichaud> having working slurpies helps (we also didn't have that working when I did postcircumfix:<[ ]> in ng)

[20:47] <jnthn> pmichaud: ohbtw

[20:48] <jnthn> pmichaud: I managed to write the postcircumfix:<{ }> in the setting...

[20:48] <pmichaud> I see that.

[20:48] <jnthn> I'm not sure how far you can get away with it for Positional. (more)

[20:48] <jnthn> The thing that we didn't have before in alpha was the ability to augment a class and add a role to it at that point.

[20:48] <pmichaud> also, Positional likely has to be a lot more aware of laziness.

[20:48] <jnthn> So it may be possible to move Positional to the setting overall and then add it to things.

[20:49] <pmichaud> Associative is never lazy, so that's much easier.

[20:49] <jnthn> I'm also wondering more and more if @ will always end up meaning Positional or also Iterable too.

[20:49] <pmichaud> oh, I'm thinking that Iterable does Positional

[20:49] *** ive left
[20:49] <pmichaud> more likely List gets involved here somewhere.

[20:49] <jnthn> Well

[20:50] <jnthn> You can always derive Positional semantics from something Iterable.

[20:50] <pmichaud> right

[20:50] <jnthn> To some degree.

[20:50] <jnthn> *-1 gets interesting perhaps. :-)

[20:50] <pmichaud> Anyway, the current factoring of Seq, Array, Positional, and Iterable is definitely Wrong.

[20:50] <pmichaud> I was working on it in Feb but got distracted.

[20:50] <sorear> does this mean that if I lazily operate on all lines of a file, all lines of the file will be retained?

[20:51] <sorear> and constant-space lazy algorithms are forbidden?

[20:51] <pmichaud> I have ideas as to what the correct factoring looks like -- basically Iterator ends up hiding out inside of List most of the time.

[20:51] <pmichaud> sorear: No.

[20:51] <jnthn> pmichaud: The big problem we seem to hit alot right now is iterators leaking out

[20:51] <sorear> butbut what if I call .[0] on my iterator at some point in the distant future?

[20:51] <pmichaud> jnthn: right, that's what I was working on getting rid of in Feb.

[20:51] <jnthn> It feels to me like things like map, gather, etc should hand back something that contains an iterator.

[20:51] <jnthn> OK, +1

[20:52] <pmichaud> jnthn: right, iterator ends up hiding inside of List most of the time.

[20:52] <jnthn> Excellent.

[20:52] <pmichaud> sorear: what I was working on in early march was the notion that lazy objects only start to remember values when they're bound to something.

[20:52] <jnthn> That'll fix a lot of problems.

[20:53] <pmichaud> so, if you have    my @array = $file.slurp();

[20:53] <[particle]> even lazy objects are bound to remember something.

[20:53] <pmichaud> [particle]: the differences is one of

[20:53] <pmichaud>     for 1..100000000 { ... }

[20:53] <pmichaud> versus

[20:54] <pmichaud>     my @a = 1..100000000;  for @a { ... }

[20:54] <pmichaud> in the first case, as we lazily produce values, we want to throw them away.

[20:54] <pmichaud> in the second case, as we lazily produce values, we want them to be retained.

[20:55] <pmichaud> the logs from march show the much more complex examples (which I need to go and review)

[20:55] <diakopter> std: for my @a = 1..100000000 { }

[20:55] <p6eval> std 30457: OUTPUT«ok 00:01 108m␤»

[20:56] <pmichaud> jnthn: anyway, my notion is that List is the thing that makes it possible for Iterator to act positional

[20:56] <pmichaud> and so map, gather, grep, etc return Lists, and the lazy parts of List objects hold the Iterator(s)

[20:56] <pmichaud> but unlike Seq, one can shift a List

[20:56] <pmichaud> and unlike Array, a List doesn't have to remember all of its earlier values

[20:57] *** alester left
[20:57] <jnthn> That sounds like it gets all the pieces.

[20:58] <pmichaud> it's still tricky to get them to fit together.  and when I last thought about it (which was in fact in early March from the hospital lounge in Houston), I decided it was a fairly significant change from what we have now.

[20:58] <pmichaud> but I'm also confident it can be done.

[20:59] <pmichaud> but the fact that binding may play a role is also why I wasn't entirely certain about binding implementation yet :)

[20:59] <pmichaud> we may need a mechanism to signal objects as to when they are being bound

[21:00] <jnthn> Makes me glad that (other than the signatures bit) I didn't do anything on binding. :-)

[21:00] <pmichaud> (which, come to think of it, might also have ramifications for the vivify discussion we had earlier :-)

[21:00] <jnthn> Heh. I rather thing I should leave you to get lists done before doing WHENCE too then. :-)

[21:00] <jnthn> (Which I wasn't planning to do this weekend anyway, fwiw.)

[21:00] *** ReiniUrban joined
[21:00] <pmichaud> actually, I think WHENCE may be a prerequisite

[21:01] <jnthn> Ah.

[21:01] <pmichaud> but I'll think about that also.

[21:01] <jnthn> OK

[21:01] <jnthn> I should be about a decent bit during the weekend.

[21:01] <pmichaud> so, ask me on Monday for what I came up with, if I haven't described it by then :)

[21:01] <jnthn> OK. :-)

[21:01] <Juerd> pmichaud: Great post, on use Perl;

[21:01] *** rurban left
[21:01] *** ReiniUrban is now known as rurban

[21:02] <pmichaud> Juerd: thank you

[21:02] <pmichaud> I had a lot of help with it here on #perl6

[21:02] <jnthn> pmichaud: My plans for now are to further unbreak parametric roles and chase down more of our S12 bits that are still broken.

[21:02] <pmichaud> jnthn: wfm

[21:02] <moritz_> collaborative editing :-)

[21:03] <jnthn> pmichaud: Oh, one other thing you may know the answer to...

[21:03] <pmichaud> my plans for the weekend are to think about lists and binding and iterators, and also to work out Rakudo Star descriptions and announcements

[21:03] <pmichaud> (at least drafts of them for others to start updating)

[21:03] <jnthn> pmichaud: In .subst, how does $/ get set per invocation of the closure?

[21:03] <jnthn> (we're getting it wrong atm)

[21:03] <pmichaud> jnthn: iirc, it's a bit of behind-the-scenes magic for .subst .

[21:03] <jnthn> well, s/does/should/

[21:03] <jnthn> ah.

[21:04] <pmichaud> TimToady and I discussed it sometime last year, I just need to look up the logs again to refresh my memory

[21:04] <pmichaud> I'm not sure it was entirely resolved at the time.  It may have been the thing that resulted in 'lift' being added to the spec.

[21:05] <moritz_> isn't lookup for $/ inspecting the caller?

[21:05] <pmichaud> no, $/ is lexical.

[21:06] <pmichaud> at least, in the general case it's lexical, iirc.

[21:06] * moritz_ swears violently

[21:06] <pmichaud> it might be dynamic, though.

[21:06] <sorear> $/ is automatically contextualized in every rakudo function

[21:06] <pmichaud> yes, and the contextualization normally binds to OUTER::, not CALLER::

[21:06] <sorear> the rakudo prologue contains my $/ = $CALLER::/

[21:06] <sorear> oh

[21:07] <pmichaud> anyway, I don't remember off top of my head, but I'll look it up.

[21:09] <jnthn> wtf, people are setting of fireworks in the pouring rain

[21:10] <jnthn> *off

[21:10] * sorear will get blizkost iterators and get_exports working, then comes the /really fun part/

[21:10] <cognominal> rakudo:   my @a = < a b c >; my $a = @a; say $a.WHAT.perl;   say  @( $a ).perl; say $a; say @a.perl; say @a; 

[21:10] <p6eval> rakudo 6783b5: OUTPUT«Array␤["a", "b", "c"]␤a b c␤["a", "b", "c"]␤abc␤»

[21:11] <sorear> that involves convincing Parrot to load more than one HLL into the same VM

[21:11] <sorear> which seems to not currently be possible

[21:11] <jnthn> sorear: We've had that working at some point in the past.

[21:11] <sorear> it may be a rakudobug, but the error message implies internal wrongness in parrotland

[21:12] <sorear> after that, I get to implement :from<>

[21:12] <sorear> then, we will have Blizkost Star, and I will move on to more interesting projects

[21:13] <parrot|Coke> there is a trac about sorear's issue. I'm not sure it's a parrotbug, hard to test because rakudo --target=PIR doesn't generate runnable code.

[21:13] <parrot|Coke> that would help me track down that issue.

[21:13] <sorear> we don't have a tracker for generic interaction bugs; I flipped a weighted coin to file it

[21:14] <sorear> if we were a more process-heavy community I would probably file a proxy ticket on rakudo

[21:14] <pmichaud> sorear: technically I'd classify it as a rakudo bug for the moment.

[21:14] <pmichaud> At one time --target=pir couldn't work with rakudo because of the dynamic library loading, but that may have been fixed by now.

[21:14] <pmichaud> Also, I think there may already be a RT ticket for --target=pir.

[21:15] <pmichaud> (I know there was at one time, not sure if it was fixed/closed and now needs a new ticket.)

[21:15] <sorear> rakdo --target=pir sounds awesome

[21:15] <sorear> I wonder if R* will be able to load installed programs *faster* than P5

[21:15] <pmichaud> No. :-)

[21:15] <moritz_> lol

[21:16] *** mariano__ left
[21:16] *** Coleoid left
[21:16] <sorear> I've got a 50,000 line Moose-based perl5 program which spends ~45 seconds in the compile phase each time I start that

[21:16] * jnthn thinks he may finally have cracked the somewhat tricky 68074

[21:16] <sorear> just how slow is the Parrot PBC loader?

[21:16] *** gurjeet left
[21:17] <pmichaud> regardless, I'm sure that TT #1542 is going to get involved somewhere in the HLL stuff.

[21:17] <parrot|Coke> sorear: relative to what?

[21:18] <jnthn> In theory, the Parrot PBC loader should be using mmap on platforms that offer it.

[21:18] <pmichaud> sorear: it's not just the time needed to load the .pbc, it's also (currently) the time needed to build tables and "compile-time" constract structures.

[21:18] <pmichaud> i.e., the time needed to invoke all of the :load subs in the .pbc

[21:18] * parrot|Coke ->

[21:18] <sorear> parrot|Coke: relative to the 1,000 line per second load rate of Perl5/Moose on this machine

[21:18] * moritz_ has blogged: http://perlgeek.de/blog-en/perl-6/monetize-perl-6.html

[21:19] <parrot|Coke> sorear: well if it's on your machine, you can easily run some timings. =-)

[21:19] <jnthn> moritz_: heh, I like the sound of that...

[21:19] * jnthn reads

[21:19] <parrot|Coke> afk&

[21:20] <sorear> parrot|Coke: the question is highly hypothetical because I don't have a Perl6 port of any large Perl5 program lying around

[21:21] <parrot|Coke> ok. then it sounds like your original question was merely a snipe at parrot. If you find something in particular that's unreasonably slow, by all means, let us know.

[21:21] <parrot|Coke> and now, really afk. back later.

[21:21] <sorear> ...what?

[21:21] <pmichaud> parrot|Coke: no, I think sorear's question was honest.

[21:22] <sorear> I did not snipe anything

[21:22] <sorear> 14:15 < sorear> rakdo --target=pir sounds awesome

[21:22] <sorear> 14:15 < sorear> I wonder if R* will be able to load installed programs *faster*  than P5

[21:22] <sorear> tell me how this is a snipe at Parrot

[21:22] <sorear> if anyone sniped, it was pmichaud

[21:22] *** nihiliad left
[21:22] <jnthn> rakudo: subset ohnoes of Mu;

[21:23] <pmichaud> yes, I'll gladly take any blame

[21:23] <p6eval> rakudo 6783b5: OUTPUT«Nominal type check failed for parameter '$original'; expected Any but got Mu instead␤current instr.: 'CREATE_SUBSET_TYPE' pc 343828 (src/gen/core.pir:18677)␤»

[21:23] * jnthn can't find a ticket for that one

[21:23] <pmichaud> I was just trying to give a sense of the current reality, no value judgement implied.

[21:23] <jnthn> Though if anyone knows of it, please point it out.

[21:24] <moritz_> seems like adding a Mu in src/glue/subset.pm might fix it

[21:24] <jnthn> moritz_: It does.

[21:24] <jnthn> moritz_: I'm spectesting it now along with the patch for 68074

[21:24] <jnthn> a moritzbug rather than a masakbug!

[21:25] <moritz_> and a particularly nasty one :-)

[21:25] * jnthn enjoys the variety :-)

[21:25] <jnthn> Yes, it was quite a pain to fix!

[21:26] <sorear> I'm sorry

[21:26] <sorear> I get defensive too easily

[21:26] <jnthn> Now I need to also fix the other thingy I broke in parametric roles yesterday.

[21:30] *** M_o_C left
[21:31] <jnthn> The test file that 63346 relates to doesn't even exist any more, and it was kind of not a Rakudo bug anyway - any objections if I close it?

[21:32] <cognominal> what is the mob2 branch?

[21:32] <moritz_> cognominal: match object generation refactor

[21:34] <moritz_> cognominal: there's also a nqp-rx branch with the same name

[21:34] <cognominal> ok

[21:34] <moritz_> cognominal: but since rakudo currently doesn't build on parrot HEAD, I can't easily integrate the two

[21:34] <cognominal> just curious...

[21:35] <jnthn> moritz_: Is that the main blocker atm?

[21:35] <moritz_> jnthn: that, and a thumbs-up from pmichaud++

[21:36] <pmichaud> afk

[21:36] <jnthn> OK

[21:44] <jnthn> moritz_: Any chance you can glance at http://rt.perl.org/rt3/Ticket/Display.html?id=63458 ?

[21:44] <jnthn> I think it's resolvable now.

[21:44] <jnthn> (I get a "sub &a not found"

[21:44] *** SmokeMachine left
[21:44] <jnthn> But I can't equate the code and the ticket title.

[21:46] <moritz_> well, previously &a wouldn't die if there was no sub a in scope

[21:46] <moritz_> so passing that undefined code object to the regex engine cause a NPCA

[21:47] <moritz_> anyway, I think it's closable

[21:48] <jnthn> moritz_: Want to do so, or should I assign to you for later/tests?

[21:48] * moritz_ took it

[21:49] <jnthn> moritz_++

[21:49] <moritz_> bed time here

[21:49] <moritz_> good night

[21:50] *** cberg joined
[21:52] <jnthn> o/

[21:53] *** pausenclown left
[21:57] *** cdarroch left
[21:59] *** nihiliad joined
[22:00] <sorear> oh look who'se the brilliant one... last week, I installed a Perl *compiled without embedding*

[22:00] * sorear tries to figure out how to run Blizkost against a non-default Perl

[22:02] <sorear> no luck, the blizkost build system inconsistently mixes default-Perl and configured-Perl files

[22:03] <sorear> more reason I want to kill that thing

[22:09] *** ruoso left
[22:15] <parrot|Coke> sorear: apologies for misunderstanding the tone.

[22:16] <sorear> wholely accepted

[22:18] <jnthn> std: role Foo[::T] { method bar(T $x) { } }

[22:18] <p6eval> std 30457: OUTPUT«ok 00:01 111m␤»

[22:20] <jnthn> std: role Foo[::T] { method bar(T $x) { } }; my T $x;

[22:20] <p6eval> std 30457: OUTPUT«ok 00:01 110m␤»

[22:20] <jnthn> Aha

[22:21] <jnthn> TimToady: T leakage.

[22:21] * jnthn has just been fixing the same kinda issue in Rakudo

[22:21] <jnthn> std: my T $x;

[22:21] <p6eval> std 30457: OUTPUT«[31m===[0mSORRY![31m===[0m␤In my declaration, typename 'T' must be predeclared (or marked as declarative with :: prefix) at /tmp/pbnA3miCUh line 1:␤------> [32mmy T[33m⏏[31m $x;[0m␤Malformed my at /tmp/pbnA3miCUh line 1:␤------> [32mmy T[33m⏏[31m $x;[0m␤    expecting

[22:21] <p6eval> ..an…

[22:23] *** jaldhar_ left
[22:34] * sorear recompiles a better Perl

[22:35] <sorear> with -Dusemultiplicity

[22:35] <k23z__> who wants to talk to me on skype ?

[22:35] <k23z__> I've bored

[22:35] <k23z__> *I'm

[22:42] *** Spreadsheet_ left
[22:50] <sjohnson> rakudo: say 20 - 19.98

[22:50] <p6eval> rakudo 6783b5: OUTPUT«0.02␤»

[22:51] *** nihiliad left
[22:51] *** nihiliad joined
[22:51] <sjohnson> rakudo: my $a = 20 - 19.98;  print $a

[22:51] <p6eval> rakudo 6783b5: OUTPUT«0.02»

[22:51] <sjohnson> rakudo: my $a = 20 - 19.98; sprintf("%08d", $a);

[22:51] <p6eval> rakudo 6783b5:  ( no output )

[22:52] <sjohnson> rakudo: my $a = 20 - 19.98; sprintf("%.4f", $a);

[22:52] <p6eval> rakudo 6783b5:  ( no output )

[22:52] <sjohnson> son of a

[22:52] <sjohnson> rakudo: my $a = 20 - 19.98; say sprintf("%.4f", $a);

[22:52] <p6eval> rakudo 6783b5: OUTPUT«0.0200␤»

[22:52] <sjohnson> well i'll be

[22:52] <jnthn> sjohnson: missing noun?

[22:52] <jnthn> :-)

[22:52] <sjohnson> oopsies :)

[22:52] <jnthn> sjohnson: printf actually prints

[22:53] <jnthn> :)

[22:53] <jnthn> sprintf formats the thingy into a string.

[22:53] <sjohnson> rakudo: my $a;  $a += 0.1 for ^10;  if ($a != 1) { say "$a != 1 }

[22:53] <p6eval> rakudo 6783b5: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[22:54] <sjohnson> rakudo: my $a;  $a += 0.1 for ^10;  if ($a != 1) { say "$a != 1" }

[22:54] <p6eval> rakudo 6783b5: OUTPUT«1 != 1␤»

[22:54] <sjohnson> rakudo: my $a;  $a += 0.1 for ^10;  if ($a != 1) { say $a }

[22:54] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[22:55] <sjohnson> rakudo: my $a;  $a += 0.1 for ^10;  if ($a != 1) { say sprintf("%.4f", $a) }

[22:55] <p6eval> rakudo 6783b5: OUTPUT«1.0000␤»

[22:55] <jnthn> rakudo: my $a;  $a += 0.1 for ^10;  if ($a.Int != 1) { say $a }

[22:55] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[22:55] <jnthn> rakudo: my $a;  $a += 0.1 for ^10;  say $a.Int

[22:55] <p6eval> rakudo 6783b5: OUTPUT«0␤»

[22:55] <jnthn> Oh.

[22:56] <sjohnson> rakudo: my $a;  $a += 0.1 for ^10;  say $a.Round

[22:56] <p6eval> rakudo 6783b5: OUTPUT«Method 'Round' not found for invocant of class 'Num'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[22:56] <sjohnson> rakudo: my $a;  $a += 0.1 for ^10;  say $a.round

[22:56] <p6eval> rakudo 6783b5: OUTPUT«1␤»

[22:56] *** masak joined
[22:56] <masak> ahoy, #perl6!

[22:56] <sjohnson> yo masak

[22:57] <jnthn> lolitsmasak!

[22:57] <sjohnson> jnthn: i'm curious as to why the 20 - 19.98 showed an int-looking number, but not the ^10 for loop thingy

[22:57] <masak> no snarkyboojum tonight. dang, I had this really neat commit I wanted to show him :)

[22:57] <jnthn> masak: Aww.

[22:57] <jnthn> You could show @other. :-)

[22:57] <masak> locally, Yapsi now does blocks. :)

[22:58] <masak> but I think I'll keep that commit local for a while longer, and try to make it work better.

[22:58] <masak> somehow it does blocks without a stack right now. which is... bad. :)

[22:58] <jnthn> oh don't say block, I've just been dealing with tricky bugs relating to such things :P

[22:58] <sjohnson> rakudo: say 20.00 - 19.98

[22:58] <p6eval> rakudo 6783b5: OUTPUT«0.02␤»

[22:58] * masak says 'block block block' :)

[22:58] <jnthn> :P

[22:59] <sjohnson> rakudo: my $a = 20.00; my $b = 19.98;  say $a - $b;

[22:59] <p6eval> rakudo 6783b5: OUTPUT«0.02␤»

[22:59] <masak> after tonight's session, I feel we're over the hump for what I expected us to do this month with Yapsi.

[22:59] <jnthn> \o/

[22:59] <masak> i.e. not done yet, but mostly LHF left.

[22:59] <jnthn> Well, Rakudo released yesterday, so our new hump is only just starting. :-)

[23:00] <masak> (new humps)++

[23:00] <dalek> rakudo: 7a1409b | jonathan++ | src/glue/subset.pm:

[23:00] <dalek> rakudo: Fix subset types involving subset foo of Mu.

[23:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7a1409ba2ec8753478d8b7e6fb79f087eb344856

[23:00] <dalek> rakudo: 2405a0b | jonathan++ | src/Perl6/Actions.pm:

[23:00] <dalek> rakudo: Fix a tricky init ordering issue that meant we could not use where clauses in parametric role signatures.

[23:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2405a0bca019886df80e37db4a2382ac77636f66

[23:00] <dalek> rakudo: a1159c7 | jonathan++ | src/Perl6/ (2 files):

[23:00] <dalek> rakudo: Rework our handling of blocks and their interaction with packages somewhat. We were running into problems with parametric role signature variables ending up with the wrong scoping. This replaces the buggy fix I put in yesterday. We do diverge from STD, but STD gets this wrong also at the moment.

[23:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a1159c7029e1b784ba9f9d626a8c4577227ce67d

[23:01] *** iblechbot joined
[23:01] <cberg> \o/ #perl6

[23:02] <sjohnson> rakudo: my $a = 20 - 19.98; $a.printf('%.30f')

[23:02] <p6eval> rakudo 6783b5: OUTPUT«Method 'printf' not found for invocant of class 'Rat'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:02] <sjohnson> rakudo: my $a = 20 - 19.98; say $a.sprintf('%.30f')

[23:02] <p6eval> rakudo 6783b5: OUTPUT«0.02␤»

[23:02] <masak> \o/ cberg

[23:02] <sjohnson> how come this small example is vastly different from P5? 

[23:02] <jnthn> Hmm. Feels odd that .print is a method, .sprintf is a method and .printf is not.

[23:02] <masak> sjohnson: looking for .fmt?

[23:02] <cberg> I'm a long time lurker/irc-backlogger. I'd want very much to contribute to Rakudo * in any way I can.

[23:02] <masak> jnthn: I'm surprised that even .sprintf is.

[23:03] <sjohnson> masak: wondering why p5 says 0.0199999999999996 to the same simple math

[23:03] <masak> jnthn: thought that's what .fmt did.

[23:03] * masak hits S32

[23:03] <sjohnson> but not p6

[23:03] <jnthn> cberg: hi, and nice of you to delurk. :-)

[23:03] <masak> sjohnson: ever heard of floating-point arithmetic?

[23:03] <jnthn> cberg: What are you interesting in working on?

[23:03] <sjohnson> masak: yes, im wondering the difference between p5 and p6

[23:03] <sorear> sjohnson: because p6 uses exact rational arithmatic when possible

[23:03] <sjohnson> not why it's happening

[23:03] <jnthn> There's plenty of ways to dig in. :-)

[23:04] <sorear> rakudo: my $a = 20.Num - 19.98.Num; say $a.sprintf('%.30f')

[23:04] <p6eval> rakudo 6783b5: OUTPUT«0.0199999999999996␤»

[23:04] <masak> sjohnson: http://docs.sun.com/source/806-3568/ncg_goldberg.html

[23:04] <sorear> forcing the use of machine numbers

[23:04] <cberg> masak: I would be happy to write tests or attempt to take on any other task beneficial to the success of Perl 6.

[23:04] <sjohnson> sorear: impressive.  thank you.  you know a lot about p6!

[23:05] <masak> cberg: wow, that sounds great!

[23:05] <jnthn> sjohnson: Basically, in Perl 6, 0.2 is stored as a numerator and dominator, and calcs are done on those. In Perl 5, it's a floating point number.

[23:05] <jnthn> sjohnson: It's a change in order to try and help people doing e.g. currency calculations etc not have a fail. :-)

[23:05] <jnthn> sjohnson: Writing scientific notation will force a floating point though.

[23:05] <sorear> perl5: stefan@stefans:~$ perl -E 'use bigrat; printf "%.20f\n", 20.0 - 19.98'

[23:05] <sorear> 0.02000000000000000042

[23:05] <sjohnson> jnthn: it's definitely pretty cool... except that it doesn't do this sort of exact math when i did my += 0.1 for ^10 test

[23:05] <masak> sjohnson: in short, every time you deal in tenths (or similar) and your programming language doesn't have something like Rat, you lose precision. it's inevitable, due to the way the numbers are stored.

[23:06] <sorear> it still gets converted into an inaccurate machine number for printing, but you don't get the catestrophic cancellation

[23:06] <sjohnson> sorear: maybe you know the answer :)

[23:06] <masak> cberg: basically, you're your own boss. but if you want guidance or suggestions, feel free to ping any of us regulars.

[23:07] <sjohnson> masak: i was dicking around with Clipper today, and it's mostly a currency-type business programming lang... so i was surprised it didnt have a handler for this stuff.  basically i think you have to round() everytime you do currency math, or maybe there's another trick on that page you linked to me

[23:07] <jnthn> sjohnson: I'm not sure, maybe it's a bug of some sort though.

[23:08] <sjohnson> maybe TimToady can help

[23:08] <sjohnson> *puppy dog eyes*

[23:08] <sorear> 0.1 is 0.0001100110011001100110011001100110011001100110011001... in binary

[23:08] <masak> sjohnson: if you do currency, you shouldn't use floats IMO.

[23:08] <sorear> machine floats on most current CPUs cut off at 52 significant figures

[23:08] <sjohnson> would you use integers and have them 1995 == $19.95 book?  or a string, of "19.95"

[23:09] <sorear> the former

[23:09] <masak> the decimals aren't real decimals, they're usually integral pennies or cents or whatever.

[23:09] *** iblechbot left
[23:09] <sjohnson> masak: you're starting to make "cents"

[23:09] <masak> :P

[23:09] <sjohnson> http://members.shaw.ca/smujohnson/snd/garlaff.mp3

[23:10] *** orafu left
[23:10] *** orafu joined
[23:10] <sjohnson> sorear: do you also think, that perhaps perl6 should as well handle the 0.1 thing?

[23:10] <parrot|Coke> TimToady++: very buddhist.

[23:10] <sjohnson> considering it worked with the 19.98 one

[23:10] <jnthn> cberg: If you're keen to work on tests, then there's a couple of places to find things that need doing.

[23:11] <jnthn> cberg: One is the TODO file in the spectests directory.

[23:11] <sorear> rakudo: my $a; $a += 0.1 for ^10; say $a.WHAT.perl;

[23:11] <jnthn> cberg: The other is to look through things in the Rakudo RT ticket queue and write tests for those.

[23:11] <p6eval> rakudo 6783b5: OUTPUT«Num␤»

[23:11] <sorear> rakudo: my $a; $a += 0.1 for ^10; say 0.1.WHAT.perl;

[23:11] <p6eval> rakudo 6783b5: OUTPUT«Rat␤»

[23:11] <jnthn> sorear: Ah, that would seem to answer it.

[23:12] <sorear> rakudo: my $a; $a += 0.1; say $a.WHAT.perl;

[23:12] <p6eval> rakudo 6783b5: OUTPUT«Num␤»

[23:12] <sorear> rakudo: say (Any() + 0.1).WHAT.perl;

[23:12] <p6eval> rakudo 6783b5: OUTPUT«Could not find sub &Any␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[23:12] <sorear> rakudo: say (Any + 0.1).WHAT.perl;

[23:12] <jnthn> rakudo: my $a = 0.0; $a += 0.1 for ^10; say $a.WHAT.perl;

[23:12] <p6eval> rakudo 6783b5: OUTPUT«Num␤»

[23:12] <p6eval> rakudo 6783b5: OUTPUT«Rat␤»

[23:12] <masak> sjohnson: Perl 6 *does* handle the 0.1 thing. that's what Rat does.

[23:12] <sorear> masak bot, we need you

[23:12] <cberg> masak: Sounds great :) I'll take a look around github and see what tickles my interests.

[23:12] <sorear> Any + 0.1 is a Num

[23:12] <sorear> bug

[23:13] <jnthn> sorear: Interesting. :-/

[23:13] <jnthn> sorear: I know why it happens.

[23:13] * masak tries to get his bearings

[23:13] <jnthn> Essentially we call back to Num if no candidates match.

[23:13] <jnthn> Rat + Rat has a candidate

[23:13] <jnthn> (other thing) + Rat doesn't

[23:13] <jnthn> I guess we could go adding Any:U + Rat candidates.

[23:13] <jnthn> But...hm. :-)

[23:14] <masak> so the bug is that after the loop, $a is a Num and not a Rat?

[23:15] <jnthn> masak: That's not the heart of it.

[23:15] <sorear> masak: the bug is that adding a Rat to an Any protoobject gives a Num

[23:15] <cberg> jnthn: Will look at TODO in spectests and the RT queue. Thanks.

[23:15] <masak> rakudo: my $a; $a += 0.1; say $a.WHAT

[23:15] <p6eval> rakudo 6783b5: OUTPUT«Num()␤»

[23:15] <sorear> rakudo: my Rat $a; $a += 0.1; say $a.WHAT

[23:15] <p6eval> rakudo 6783b5: OUTPUT«Type objects are abstract and have no attributes, but you tried to access ␤current instr.: 'perl6;Attribute;accessor_helper_ro' pc 3554 (src/gen/Attribute.pir:400)␤»

[23:15] <masak> so that's the bug?

[23:15] <sorear> yes

[23:15] * masak submits rakudobug

[23:15] <sorear> my last version is probably also a bug

[23:15] * jnthn would be interested to hear the langauge design angle on how the bug should be fixed

[23:16] <jnthn> I agree it's unintuitive.

[23:16] <sorear> but a different one

[23:16] <jnthn> But I'm not sure what the good fix is (other than loads of extra multi candidates).

[23:16] <masak> jnthn: which one?

[23:16] <sjohnson> masak == bug exerminator!

[23:16] <jnthn> masak: The Any + 0.1 one.

[23:16] <sjohnson> oops

[23:16] <sorear> masak: the bug you're about to report

[23:16] <masak> yes, but a confused one tonight, it seems.

[23:16] <masak> ok.

[23:17] <masak> if that's another bug... which was the first one? :/

[23:17] <sorear> Any + 0.1 is the first one

[23:17] <sorear> found by sjohnson++

[23:17] <masak> aren't those the same?

[23:17] <sorear> yes

[23:17] <pugssvn> r30458 | jnthn++ | [t/spec] Unfudge some parametric roles tests for Rakudo. 

[23:18] <sjohnson> i can now say, i brought something to the perl6 table

[23:18] <sorear> bug #1: Any + 0.1 gives a Num

[23:18] <sorear> bug #2: Num + 0.1 gives an error

[23:18] <sorear> er

[23:18] <sorear> Rat + 0.1

[23:19] <jnthn> Rat + 0.1 should warn, but not die.

[23:19] <masak> can you give an example of #2?

[23:19] <jnthn> Probably.

[23:19] <sorear> rakudo: my Rat $a; $a += 0.1 for ^10;

[23:19] <p6eval> rakudo a1159c: OUTPUT«Type objects are abstract and have no attributes, but you tried to access ␤current instr.: 'perl6;Attribute;accessor_helper_ro' pc 3554 (src/gen/Attribute.pir:400)␤»

[23:19] <sorear> += operators shouldn't even warn, I think

[23:19] <jnthn> There's no += operator

[23:20] <jnthn> It's sugar, and generated from the + and = operators.

[23:20] <masak> ok. thanks.

[23:20] <jnthn> rakudo: our class A {}

[23:20] <p6eval> rakudo a1159c:  ( no output )

[23:20] <jnthn> rakudo: my class A {}

[23:20] <p6eval> rakudo a1159c: OUTPUT«Can't handle scope declarator my on packages yet␤current instr.: 'perl6;Perl6;Compiler;Package;finish' pc 27412 (src/gen/parameter_pm.pir:613)␤»

[23:20] <sorear> jnthn: that sounds extremely yucky in the presense of autovivication

[23:20] *** nihiliad left
[23:21] <sorear> jnthn: are you saying I should do %hash{$key} //= 0; %hash{$key} += $data; ?

[23:21] <sorear> because otherwise it will call Any + $data

[23:21] <jnthn> I'm saying that I don't see how we can have:

[23:21] <jnthn> my $x; $x = $x + Rat; # warn

[23:21] <jnthn> my $x; $x += Rat; # not warn

[23:22] <sorear> no, no

[23:22] <jnthn> They can both not warn, or both warn.

[23:22] <sorear> my $x; $x += 3; # not warn

[23:22] <jnthn> erm

[23:22] <jnthn> s/Rat/3/ # or something

[23:22] * jnthn writes again

[23:22] <sorear> my Rat $x; $x += 3; # I want this to not warn

[23:22] <masak> jnthn: I think those ought to work differently.

[23:22] <jnthn> my $x; $x = $x + 42; # sounds like you want this to warn...

[23:22] *** jlindsay joined
[23:22] *** astrojp joined
[23:22] <masak> yes.

[23:22] <sorear> my Rat $x; $x = Rat + 3; # but it desugars to this

[23:22] <jnthn> my $x; $x += 42; # and this not to

[23:23] <masak> correct.

[23:23] <jnthn> But they desugar to the same kinda thing.

[23:23] <sorear> jnthn: no

[23:23] <masak> jnthn: a lot of other things work like that.

[23:23] <masak> already.

[23:23] <sorear> *you* want it to warn

[23:23] <sorear> *I* want it to not warn

[23:23] <jnthn> I don't give a damm if it warns or not.

[23:23] <sorear> 16:19 <@jnthn> Rat + 0.1 should warn, but not die.

[23:24] * masak submits rakudobug for Rat + 0.1 dying

[23:24] <jnthn> I'm saying that, as a person implementing this stuff, and so far as I understand how += is generated and what it's made up on, I can't at the moment see how you'd expect it not to work in a case when + would with the same operands.

[23:24] <masak> alpha: my $a; $a = $a + 2

[23:24] <p6eval> alpha 30e0ed: OUTPUT«Use of uninitialized value␤»

[23:24] <masak> alpha: my $a; $a += 2

[23:24] <p6eval> alpha 30e0ed:  ( no output )

[23:24] <masak> jnthn: see?

[23:25] <jnthn> Yes, but alpha cheated on the meta-ops.

[23:25] <masak> oh, come on!

[23:25] <jnthn> It's easy if you're gonna cheat.

[23:25] <masak> then cheat. please.

[23:25] <masak> that's the correct behaviour.

[23:25] <jnthn> Yes, but my question is, what's the mechanism that makes it warn or not warn.

[23:25] <masak> if it's '+=', it doesn't warn.

[23:26] <masak> or some other assignment metaop.

[23:26] <sorear> All I want is for += to work correctly on autovivified objects.

[23:26] <jnthn> masak: I understand the desired behavior.

[23:26] <sorear> Because I DO NOT want to have to say %hash{$key} //= 0 before adding to accumulators.

[23:26] <masak> jnthn: then I'll stop explaining it :)

[23:27] <jnthn> If the answer is "the thingy that handles assignment meta-operators disables warnings through tweaking some context variable" that's fine.

[23:27] <jnthn> I'm asking what the underlying mechanism is here.

[23:27] <sorear> And I'm not going to invent one.  We need to track down TimToady.

[23:28] <jnthn> Which is the point I've been trying to make all along. It's not really my place to just come up with something either. :-)

[23:28] <sorear> phenny: msg TimToady - How do undef warnings interact with autovivication?  %hash{$key} += 1;

[23:28] <sorear> phenny: tell TimToady, How do undef warnings interact with autovivication?  %hash{$key} += 1;

[23:28] <phenny> sorear: I'll pass that on when TimToady is around.

[23:28] <masak> jnthn: but seriously, surely one can detect whether the operator is an assignment metaop, and decide not to warn in that case?

[23:28] *** masak` joined
[23:29] <pmichaud> Thoughts on the name "Perl 6":  http://www.perlmonks.org/?node_id=836626

[23:29] *** masak left
[23:29] <jnthn> masak`: Surely, my question is how should that look like.

[23:30] *** masak` is now known as masak

[23:30] * masak waves hands about

[23:30] <pmichaud> ...the metaop ought to autovivify the variable before it calls the underlying op.

[23:30] <pmichaud> that's what alpha did, iirc.

[23:30] <pmichaud> step 1:  vivify the undef (according to the op)

[23:30] <pmichaud> step 2: call the op

[23:30] <pmichaud> step 3:  store the resul

[23:30] <pmichaud> *result

[23:31] <pmichaud> besides, the metaop has to determine what value to use for the vivification before the underlying op is ever called

[23:31] <jnthn> Phew, an implementation answer!

[23:31] <pmichaud> because   my $a;  $a *= 2;  has to vivify $a to a value of 1, not 0.

[23:31] <jnthn> :-)

[23:31] <masak> pmichaud++ # even I understood that!

[23:31] <pmichaud> and clearly infix:<*>($x, $y) doesn't know that.

[23:32] <jnthn> pmichaud++

[23:32] <sjohnson> does anyone have any opinions / thoughts on whether .printf should be a string method, as sprintf is?

[23:32] <pmichaud> sjohnson: I'd guess IO method, myself.

[23:32] <sjohnson> fwiw, i like the sprintf being a tring method call

[23:32] <jnthn> I suspect if one is the other should be.

[23:32] <jnthn> (And if one isn't the other shouldn't.)

[23:33] <pmichaud> unless the invocant is a formatting string.

[23:33] <masak> sjohnson: I think neither should be.

[23:33] <pmichaud> which seems weird.

[23:33] <masak> sjohnson: I think .fmt suffices most of the time.

[23:33] <pmichaud> masak++

[23:33] <masak> calling .printf and .sprintf on the value to print feels... odd.

[23:34] <sorear> printf ought to be a global sub

[23:34] <masak> rakudo: Rat + 0.1

[23:34] <p6eval> rakudo a1159c: OUTPUT«Type objects are abstract and have no attributes, but you tried to access ␤current instr.: 'perl6;Attribute;accessor_helper_ro' pc 3554 (src/gen/Attribute.pir:400)␤»

[23:34] <sorear> and by global I mean setting

[23:41] * jnthn attempts to bring back .WALK

[23:41] <sorear> Isn't it still in S12?

[23:41] * pmichaud wonders about the flashing !WALK

[23:41] <sorear> Why do private members use '!' instead of my?

[23:42] <jnthn> Flashing during a WALK may get you arrested.

[23:42] <jnthn> sorear: Yes, it is. I meant the implementation of. :-)

[23:42] <pmichaud> "my" is for lexically scoped class variables, not instance variables.

[23:42] <pmichaud> 'has' is for instance members.

[23:59] *** cberg left
[23:59] <jnthn> rakudo: say Any === Any

[23:59] <p6eval> rakudo a1159c: OUTPUT«1␤»

[23:59] <jnthn> rakudo: say Any <<===>> Any

[23:59] <p6eval> rakudo a1159c: OUTPUT«1␤»

