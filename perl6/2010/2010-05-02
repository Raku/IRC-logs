[00:01] <dalek> yapsi: 17f4298 | masak++ | doc/announce/2010.05:

[00:01] <dalek> yapsi: [doc/announce/2010.05] fixed a few typos

[00:01] <dalek> yapsi: 'Gasp! He's changing the announcement post-release!' No, actually these

[00:01] <dalek> yapsi: typos were found by by wolverian++ before the release announcements were

[00:01] <dalek> yapsi: sent out (but after the uploading of the release tarball).

[00:01] <dalek> yapsi: review: http://github.com/masak/yapsi/commit/17f4298f39ee2415d826619871e6c0b3c8e4b61a

[00:05] *** Limbic_Region joined
[00:12] *** am0c joined
[00:27] <lue> afk

[00:38] <sorear> rakudo: say BEGIN { rand }

[00:38] <p6eval> rakudo c4857a: OUTPUT«Could not find sub &rand␤current instr.: '_block11' pc 0 (EVAL_1:9)␤»

[00:39] <sorear> rakudo: say rand

[00:39] <p6eval> rakudo c4857a: OUTPUT«0.555681770990731␤»

[00:39] <diakopter> 3 hours later, I found the bug.

[00:39] <sorear> I see that my bug with macros is shared with BEGIN blocks

[00:39] <diakopter> not quite a record.

[00:41] * sorear files rakudobug

[00:42] <sorear> rakudo: say raxx

[00:42] <p6eval> rakudo c4857a: OUTPUT«Could not find sub &raxx␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[00:43] <diakopter> yay!

[00:43] <diakopter> fixed it

[00:43] <diakopter> the assemblies perlesque.exe emits are now entirely independent of Sprixel.exe and perlesque.exe, unless of course they use classes from them..

[00:44] <diakopter> and I can do super-fun stuff like this:

[00:44] <dalek> csmeta: r237 | diakopter++ | trunk/Sprixel/ (2 files):

[00:44] <dalek> csmeta: [perlesque] more mono fix attempts

[00:45] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=237

[00:45] <diakopter> perlesque: my $a = sub int (int $b) { return 1; }; $a = sub int (int $b) { if 0==($b % 100000) { say('reached ' ~ $b) }; if $b == 1000000 { return $b }; return $a($b + 1) }; say($a(0));

[00:45] <p6eval> perlesque: OUTPUT«reached 0␤reached 100000␤reached 200000␤reached 300000␤reached 400000␤reached 500000␤reached 600000␤reached 700000␤reached 800000␤reached 900000␤reached 1000000␤1000000␤»

[00:45] <diakopter> sorear: a 1m callframe-deep invocation :)

[00:46] <diakopter> perlesquel: .

[00:46] <p6eval> perlesquel: OUTPUT«reached 0␤reached 100000␤reached 200000␤reached 300000␤reached 400000␤reached 500000␤reached 600000␤reached 700000␤reached 800000␤reached 900000␤reached 1000000␤1000000␤real 1.43␤user 1.38␤sys 0.18␤»

[00:48] *** TiMBuS left
[00:49] <diakopter> jnthn: ^^

[00:53] <diakopter> and subs can refer to themselves by name:

[00:53] <diakopter> perlesque: sub int foo(int $b) { if 0==($b % 10000) { say('reached ' ~ $b) }; if $b == 100000 { return $b }; return foo($b + 1) }; say(foo(1))

[00:53] <p6eval> perlesque: OUTPUT«reached 10000␤reached 20000␤reached 30000␤reached 40000␤reached 50000␤reached 60000␤reached 70000␤reached 80000␤reached 90000␤reached 100000␤100000␤»

[00:53] <diakopter> perlesquel: .

[00:53] <p6eval> perlesquel: OUTPUT«reached 10000␤reached 20000␤reached 30000␤reached 40000␤reached 50000␤reached 60000␤reached 70000␤reached 80000␤reached 90000␤reached 100000␤100000␤real 0.33␤user 0.14␤sys 0.02␤»

[00:57] *** wolverian left
[00:57] *** wolv is now known as wolverian

[00:58] <jnthn> sorear: Ah, yes...I suspect some tweaks are needed to run BEGIN blocks within the setting.

[00:58] <jnthn> Anyways, sleep for me now. :)

[01:00] *** eternaleye left
[01:15] *** eternaleye joined
[01:24] *** am0c left
[01:26] *** fridim joined
[01:35] *** wknight8111 left
[01:36] *** alester joined
[01:50] *** wolverian left
[01:58] *** alester left
[01:59] *** Psyche^ joined
[01:59] <sorear> TimToady: If I have a macro that runs at the 'statement' or 'declarator' category, it seems non-trivial semantically to substitute >1 declarator

[01:59] <sorear> It's always legal to use >1 statement where 1 is needed, but the grammar doesn't handle this regularly

[02:00] <sorear> so I'm not sure how to design that feature

[02:03] *** Patterner left
[02:03] *** Psyche^ is now known as Patterner

[02:21] *** BrowserUk joined
[02:21] <diakopter> sorear: 

[02:22] <diakopter> maybe enclose it in a self-executing block?

[02:22] <sorear> diakopter:

[02:22] <sorear> diakopter: self-executing blocks create a new lexical scope

[02:22] <diakopter> yah

[02:22] <sorear> if I want to make a macro which defines stuff, that doesn't work

[02:22] <diakopter> hm, yeah.

[02:23] <diakopter> make a new grammar category that's list_of_statements or something ...?

[02:23] <diakopter> then make it stand-in for statement everywhere else

[02:24] <diakopter> so every "real" statement is a list of 1

[02:24] <diakopter> (sorry, I know it's kludgy)

[02:26] <sorear> what I'm going to do is far more evil

[02:27] <sorear> replace "statement" with "statementlist" when reparsing string macro results

[02:28] <diakopter> heh

[02:28] <diakopter> nice

[02:29] <sorear> > macro term:<foo> is parsed( / <?> / ) { Perl6::Grammar.parse("say('foo'); say('bar')", :rule("statementlist"), :actions(Perl6::Actions)).ast }

[02:29] <sorear> > foo

[02:29] <sorear> foo

[02:29] <sorear> bar

[02:30] <sorear> I'd call this "success"

[02:34] <eternaleye> sorear++

[02:38] *** kst left
[02:39] *** kst joined
[02:40] *** camenix joined
[02:43] *** BrowserUk left
[02:53] *** xinemac joined
[02:56] <Tene> lue: specificaally, I was going for realtime multiplayer, kind of a mud/roguelike mix.

[02:57] <sorear> Tene: Hi!  I hear, belatedly, you were doing some stuff with macros?

[03:06] *** MetaMucil joined
[03:26] *** kst left
[03:26] *** k23z__ joined
[03:29] *** kst joined
[03:30] *** MetaMucil left
[03:31] *** Sathiya joined
[03:32] *** Sathiya left
[03:52] *** astrojp left
[03:54] *** gurjeet left
[03:54] *** gurjeet joined
[04:07] *** meppl joined
[04:07] *** envi^home joined
[04:13] *** Limbic_Region left
[04:14] *** kst left
[04:15] *** kst joined
[04:19] *** redicaps_ joined
[04:20] *** gurjeet left
[04:20] *** gurjeet joined
[04:33] *** finanalyst joined
[05:01] *** kaare joined
[05:02] *** kaare is now known as Guest81117

[05:05] *** rv2733 joined
[05:06] *** kst left
[05:07] *** kst joined
[05:17] *** k23z__ left
[05:21] *** rgrau left
[05:38] *** fridim left
[05:43] *** jimmy joined
[05:43] *** jimmy is now known as JimmyZ

[05:46] *** kst left
[05:47] *** kst joined
[05:55] *** k23z__ joined
[06:15] *** finanalyst left
[06:17] <snarkyboojum> phenny: tell masak, I'd like to pick your brains about Yapsi/Tardis integration. I have something going, but have a bug somewhere :)

[06:17] <phenny> snarkyboojum: I'll pass that on when masak is around.

[06:17] <phenny> snarkyboojum: 01 May 17:38Z <masak> tell snarkyboojum that Yapsi is now, finally, ready for Tardis. here's a proof-of-concept: http://gist.github.com/386512

[06:28] *** camenix left
[06:31] *** xinemac left
[06:32] *** kst left
[06:34] *** plobsing left
[06:34] *** kst joined
[06:39] *** camenix joined
[06:41] *** xinemac joined
[06:48] <sorear> nqp: sub a(*@b) { say(+@b); }; a(|[], |[])

[06:48] <p6eval> nqp: OUTPUT«0␤»

[06:50] *** JimmyZ left
[06:52] <sorear> nqp: pir::null__P() ?? 1 !! 0

[06:52] <p6eval> nqp: OUTPUT«Null PMC access in get_bool()␤current instr.: '_block11' pc 0 (EVAL_1:5)␤»

[06:59] *** jaldhar joined
[07:03] *** JimmyZ joined
[07:16] *** snarkyboojum left
[07:32] <sorear> nqp: say(pir::isa__IPS("foo", "Str"))

[07:32] <p6eval> nqp: OUTPUT«0␤»

[07:32] <sorear> nqp: say(pir::isa__IPS("foo", "String"))

[07:32] <p6eval> nqp: OUTPUT«1␤»

[07:32] <sorear> rakudo: say(pir::isa__IPS("foo", "String"))

[07:32] <p6eval> rakudo c4857a: OUTPUT«1␤»

[07:33] *** JimmyZ left
[07:33] *** kst left
[07:33] *** fda314925 left
[07:36] *** kst joined
[07:49] *** fridim joined
[07:49] *** pmurias joined
[08:06] <sorear> > macro term:<stub> is parsed(/ <identifier> /) { 'sub ' ~ $<identifier>.Str ~ ' { !!! }' }

[08:07] <sorear> > stub foo; foo;

[08:07] <sorear> Stub code executed

[08:07] <sorear> no more PAST!

[08:08] * sorear starts an overnight spectest run

[08:09] <sorear> anyone who thinks this is interesting - I've left the (not yet spectested!) patches on github

[08:10] *** iblechbot joined
[08:20] *** stepnem left
[08:21] *** snarkyboojum joined
[08:28] *** _jaldhar joined
[08:28] *** jaldhar left
[08:28] *** kst left
[08:29] *** kst joined
[08:31] *** stepnem joined
[08:57] *** tri1 joined
[08:59] *** tri1 left
[09:10] <eternaleye> sorear: Wait. So you've just implemented macros, both hygenic and non, in 1-2 days. I am seriously impressed.

[09:11] * moritz_ kinda finds that hard to believe

[09:18] <eternaleye> Looking over the patches, it's more 'to a first approximation', but it's still damn cool

[09:19] <moritz_> enough to give masak something to break :-)

[09:19] <eternaleye> heh, true enough

[09:28] <eternaleye> rakudo: class Foo {}; class Bar {}; sub baz( Foo $a --> :( Foo, Bar ) ) { return( $a, Bar.new ); ); baz( Foo.new );

[09:28] <p6eval> rakudo c4857a: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[09:28] <eternaleye> rakudo: class Foo {}; class Bar {}; sub baz( Foo $a --> ( Foo, Bar ) ) { return( $a, Bar.new ); ); baz( Foo.new );

[09:28] <p6eval> rakudo c4857a: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[09:28] <eternaleye> How would I specify a signature as a return type?

[09:33] <eternaleye> rakudo: class Foo {}; class Bar {}; sub baz( Foo $a ) returns ( Foo, Bar ) { return( $a, Bar.new ); ); baz( Foo.new );

[09:33] <p6eval> rakudo c4857a: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1664 (ext/nqp-rx/src/stage0/Regex-s0.pir:907)␤»

[09:35] <moritz_> rakudo: sub f($x --> Int) { 1 }; say f(5)

[09:35] <p6eval> rakudo c4857a: OUTPUT«1␤»

[09:35] <moritz_> rakudo: sub f($x --> Int) { 'foo' }; say f(5)

[09:35] <p6eval> rakudo c4857a: OUTPUT«foo␤»

[09:35] <moritz_> seems it's not yet checked

[09:36] <moritz_> rakudo: my Int sub f() { 'foo' }; say f

[09:36] <p6eval> rakudo c4857a: OUTPUT«foo␤»

[09:36] <moritz_> should work too

[09:36] *** moritz_ sets mode: +v p6eval

[09:37] <eternaleye> Yeah, but I'd settle for knowing the right way to phrase it for when it is checked in the future. I know the syntax for single return types, and I could potentially hack around it by specifying a Parchel return type and using unpacking, but I'm not sure that's the best way/

[09:37] <eternaleye> s,/$,.,

[09:37] <eternaleye> *Parcel

[09:39] <moritz_> subset ReturnType of Any where { :(Int, Num, Array) }

[09:39] <moritz_> without the brackets

[09:45] *** M_o_C joined
[09:46] *** kst left
[09:48] *** kst joined
[09:52] *** iblechbot left
[09:53] *** M_o_C left
[09:56] <moritz_> s1n: (backlog) yes

[09:57] <moritz_> s1n: http://mpl.mpg.de/mpf/php/abteilung1/index.php?lang=en&show=workgroups&in=ocom&and=staff

[10:14] *** wknight8111 joined
[10:23] *** redicaps_ left
[10:32] *** FreeStorm joined
[10:33] *** kst left
[10:34] *** kst joined
[10:38] *** lest_away is now known as lestrrat

[10:43] *** orafu left
[10:56] *** FreeStorm left
[11:03] <jnthn> oh morning

[11:03] *** takadonet1 joined
[11:04] *** takadonet left
[11:11] <moritz_> \o/

[11:13] *** orafu joined
[11:18] <colomon> o/

[11:18] <jnthn> colomon: o/

[11:21] <colomon> Iceland still cool?  :)

[11:23] <jnthn> colomon: Yes :-)

[11:23] <jnthn> colomon: I like it here.

[11:23] <jnthn> The conference folk who made it anyway, despite the cancellation, are hackathoning today.

[11:23] <jnthn> (Me too.)

[11:23] <colomon> p5 hackathon?

[11:24] <jnthn> Whatever people want. :-)

[11:24] <colomon> do you have a goal in mind?

[11:25] <jnthn> For me, I was planning to spend my time doing Rakudo fixes/get more tests passing, and spend some time on book.

[11:25] <jnthn> A group of people here are working on some education software project.

[11:25] <jnthn> In fact, that's most of them. :_)

[11:25] <colomon> noble goals

[11:26] *** kst left
[11:26] <jnthn> Well, I already got a fix to get another test file to run so far as it did on alpha (not pushed yet).

[11:26] * moritz_ works again on match objects

[11:27] <moritz_> my current idea for the vtable overrides is: use src/cheats/Match.pir which adds a method with :vtable(...)

[11:27] *** kst joined
[11:27] <jnthn> moritz_: Which vtable overrides?

[11:27] <moritz_> jnthn: set_pmc_keyed

[11:27] <jnthn> What's making you need that?

[11:27] <moritz_> jnthn: it's what Regex::Cusors.'!MATCH' calls

[11:28] <jnthn> Ah.

[11:28] <moritz_> I'd prefer to pass all captures as argumenst to .new

[11:28] <moritz_> but there's a certain overhead associated with that

[11:28] <jnthn> Did you try putting a forwarder in Mu.pir like we have many others?

[11:29] <moritz_> what should it forward to?

[11:29] <jnthn> postcircumfix:<{ }> I guess?

[11:29] <jnthn> It's a confusing of binding and assignment though. :-/

[11:30] <jnthn> Alternatively, what you suggest for adding a Match.pir with them would also work.

[11:30] <moritz_> I'll try that next, if my approach doesn't work

[11:31] <jnthn> k

[11:38] <isBEKaml> hi guys :)

[11:38] <jnthn> hi isBEKaml 

[11:39] <isBEKaml> I still don't seem to get a grasp on GatherIterator(). 

[11:39] <isBEKaml> rakudo: my $ff = "helloWorld".split(/o/,:all); say $ff.WHAT; say $ff.get() while $ff; 

[11:39] <p6eval> rakudo c4857a: OUTPUT«GatherIterator()␤o␤o␤␤»

[11:40] <isBEKaml> rakudo: my $ff = "helloWorld".split(/o/,:all); say $ff.get() while $ff; say $ff; 

[11:40] <p6eval> rakudo c4857a: OUTPUT«o␤o␤␤␤»

[11:40] <jnthn> That's internals leaking out more than something you're really mwant to see, I suspect.

[11:40] <moritz_> rakudo: say 'hllowWorld'.split(/o/, :all).join(', ')

[11:40] <p6eval> rakudo c4857a: OUTPUT«hll, o, wW, o, rld␤»

[11:41] <isBEKaml> jnthn: If I simply say $ff before iterating through it, it prints out the entire thing. why does it just show the split param when I give get() ?

[11:41] <isBEKaml> moritz_: yes. :)

[11:42] <colomon> isBEKaml: because .get is the method to get the next element of an iterator

[11:42] <colomon> whereas if we get a naked iterator, we try to do something intelligent with it.

[11:42] <isBEKaml> colomon: I get it, but I would expect it to show the next element. not the split element.. 

[11:43] <isBEKaml> colomon: My thinking was this. I split "helloworld" into several elements around "o". Now if I call .get(), I should be seeing the first element, i.e. "hell", "o","w","o","rld". Along these lines. Am I wrong?

[11:44] <isBEKaml> sorry, that should be "hell", and successive calls should yield the next elements.. 

[11:45] <moritz_> isBEKaml: I'd expect the same

[11:45] <isBEKaml> moritz_: is this a bug, then? 

[11:46] <moritz_> jnthn: ah, with set_pmc_keyed in Mu.pir I get infinite recursion... but at least it does something; will investigate more

[11:46] *** nadim_ joined
[11:46] <moritz_> isBEKaml: if the spec says that the return value is soemthing that can be iterated with .get, then yet

[11:46] <colomon> rakudo: my $ff = "helloWorld".split(/o/,:all); say $ff.get; say $ff.get; say $ff.get

[11:47] <p6eval> rakudo c4857a: OUTPUT«hell␤o␤W␤»

[11:47] <colomon> rakudo: my $ff = "helloWorld".split(/o/,:all); say $ff.WHAT; say $ff.get; say $ff.get

[11:47] <p6eval> rakudo c4857a: OUTPUT«GatherIterator()␤hell␤o␤»

[11:48] <isBEKaml> colomon: then I must be doing something wrong in using the while loop. 

[11:48] <moritz_> rakudo: my $ff = "helloWorld".split(/o/,:all); while my $x = $ff.get !~~ EMPTY { say $x }

[11:48] <p6eval> rakudo c4857a: OUTPUT«1␤1␤1␤1␤1␤»

[11:48] <moritz_> rakudo: my $ff = "helloWorld".split(/o/,:all); while ( my $x = $ff.get) !~~ EMPTY { say $x }

[11:48] <colomon> rakudo: my $ff = "helloWorld".split(/o/,:all); say $ff; say $ff.get; say $ff.get

[11:48] <p6eval> rakudo c4857a: OUTPUT«hell␤o␤W␤o␤rld␤»

[11:48] <p6eval> rakudo c4857a: OUTPUT«hell o W o rld␤␤␤»

[11:48] <isBEKaml> rakudo: my $ff="helloworld".split(/o/,:all); say $ff.get while $ff; 

[11:48] <p6eval> rakudo c4857a: OUTPUT«o␤o␤␤»

[11:48] <moritz_> isBEKaml: the loop with !~~ EMPTY above works

[11:48] <isBEKaml> rakudo: my $ff="helloworld".split(/o/,:all); say $ff.get while $ff !~~ EMPTY; 

[11:49] <p6eval> rakudo c4857a:

[11:49] <p6eval> ..OUTPUT«hell␤o␤w␤o␤rld␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤␤

[11:49] <colomon> yeah, it's definitely something with the while loop.

[11:49] <jnthn> doing $ff !~~ EMPTY won't work, afaik.

[11:49] <moritz_> isBEKaml: you have to check the return value for EMPTY, not the iterator

[11:49] <jnthn> You match something that comes back from $ff.get against EMPTY

[11:49] <isBEKaml> oh, damn, that stores the fixed block in every iterator initiation.. 

[11:50] <isBEKaml> moritz_: I see.. 

[11:50] <colomon> rakudo: my $ff = "helloWorld".split(/o/,:all); my $a; while ($a = $ff.get) !~~ EMPTY { say $a; }

[11:50] <p6eval> rakudo c4857a: OUTPUT«hell␤o␤W␤o␤rld␤»

[11:50] *** rgrau joined
[11:52] <moritz_> rakudo: class A is Hash { }; my $h = A.new; $h{'foo'} = 'bar'; say $h{'foo'}

[11:52] <p6eval> rakudo c4857a: OUTPUT«bar␤»

[11:52] <moritz_> rakudo: class A is Array { }; my $a = A.new; $a[0] = 'baz'; say $a[0]

[11:52] <p6eval> rakudo c4857a: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;Proxy;!STORE' pc 14609 (src/builtins/Routine.pir:151)␤»

[11:53] <isBEKaml> colomon: thank you. :)

[11:53] * moritz_ submits rakudobug

[11:53] <moritz_> rakudo: class A is Array { }; my $a = A.new; $a[0] = 'baz'

[11:53] <p6eval> rakudo c4857a: OUTPUT«Null PMC access in invoke()␤current instr.: 'perl6;Proxy;!STORE' pc 14609 (src/builtins/Routine.pir:151)␤»

[11:57] *** M_o_C joined
[12:01] <isBEKaml> I can understand that while checks a boolean and acts accordingly. Doing, while $ff ... , what exactly does an iterator emit to the while loop?

[12:03] <isBEKaml> note, I'm not checking like, say something while iterator is not empty.. 

[12:04] <moritz_> rakudo: my $ff = "helloWorld".split(/o/,:all); $ff.Bool; say $ff.join('|')

[12:05] <p6eval> rakudo c4857a: OUTPUT«o|W|o|rld␤»

[12:05] <moritz_> isBEKaml: ah, checking for truth also consumes an element

[12:06] <isBEKaml> moritz_: yes, but why?

[12:06] <moritz_> isBEKaml: no idea

[12:07] <isBEKaml> rakudo: my $ff="helloworld".split(/o/,:all); $ff.Bool; $ff.Bool; say $ff.join(',');

[12:07] <p6eval> rakudo c4857a: OUTPUT«w,o,rld␤»

[12:12] *** kst left
[12:12] *** kst joined
[12:13] <colomon> I'll tell you why.

[12:14] <colomon> the only real interface to an iterator is get.

[12:14] <colomon> so the only way to find out if it is empty is to .get an element.

[12:15] <colomon> that's why you only got the o's back, too.

[12:16] <colomon> because the while condition was getting every other bit.

[12:16] <isBEKaml> colomon: so whatever we do on an iterator is daisy chained to get() ? 

[12:16] <colomon> anything you do with an iterator other than .get has to be implemented in terms of .get.

[12:16] *** wolverian joined
[12:19] <isBEKaml> colomon: doing, say $ff.get while $ff # dropped everything other than o. I think, if as you say, it should be dropping the "o"s too.. 

[12:19] <isBEKaml> but it doesn't.. 

[12:19] <colomon> nope

[12:19] <colomon> the sequence is this:

[12:19] <colomon> while $ff (does get, gets "hell")

[12:20] <colomon> say $ff.get (gets 'o', says it)

[12:20] <colomon> while $$ (does get, gets ' w')

[12:20] <colomon> say $ff.get (gets 'o', says it)

[12:20] <colomon> etc.

[12:20] <isBEKaml> ah, 

[12:21] <jnthn> grr...seems we get some GC segfault when I fix some bug. :-|

[12:22] <isBEKaml> as moritz_ pointed out, checking for booleans even gets an element. 

[12:22] <jnthn> isBEKaml: But a boolean check is the Wrong Way to check if an iterator has more values anyway.

[12:22] <jnthn> I'm not sure it's a bug.

[12:22] <jnthn> It's just that you're not meant to use it like that.

[12:22] <moritz_> jnthn: it's surely a bug that .split returns such a fragile object

[12:22] <jnthn> moritz_: Right, that is a bug.

[12:23] <jnthn> But I think that's a bug with gather in general

[12:23] <jnthn> Rather than just split.

[12:23] <moritz_> it should return a lazy list that remembers all evaluated values

[12:23] <moritz_> and .Bool on it should only force evaluation of the first element, if it isn't already

[12:25] *** iblechbot joined
[12:25] <moritz_> jnthn: if a class has $!foo, does it actually install an attribute $!foo in the parrot class?

[12:25] *** masak joined
[12:26] <masak> greetings, perl6beings.

[12:26] <phenny> masak: 06:17Z <snarkyboojum> tell masak I'd like to pick your brains about Yapsi/Tardis integration. I have something going, but have a bug somewhere :)

[12:26] <masak> snarkyboojum: cool. I'll be here for a few hours today.

[12:27] <moritz_> jnthn: when I say 'class Match does Associative' instead of 'class Match is Hash' I get the error "No such attribute '$!cursosr'"

[12:28] <moritz_> jnthn: which is rather weird, because I still have the 'has $!cursor;' line in there

[12:29] <colomon> But it very definitely *shouldn't* return a lazy list that remembers all evaluated values.

[12:30] <colomon> that's terribly limiting.

[12:30] <moritz_> ok, but assigning it to a variable should result in something that remembers all values

[12:30] <jnthn> moritz_: Yes, it should install it in the Parrot class.

[12:31] <colomon> moritz_: maybe....

[12:32] <colomon> you're essentially saying that when you assign a lazy list to a variable, it becomes a Seq.

[12:32] <colomon> I think that edge between Seq and lazy list is something we still haven't figured out.

[12:33] <moritz_> colomon: I think there would be too much confusion if it continues to be as-is

[12:33] <colomon> for sure we need to bring back List as a type for lazy lists.

[12:34] <colomon> but there needs to be a way to treat it as a raw iterator (no memory) if needed, too.

[12:34] <moritz_> calling .list on it

[12:35] <moritz_> (no idea if that makes sense)

[12:35] <colomon> I don't think it does, but I could be wrong.

[12:35] <colomon> I don't want to pretend to have all the answers here -- if I did, I'd already have implemented it all myself.  :)

[12:36] <isBEKaml> colomon: I can't think of a reason we need a raw iterator. AFAIK, every operation that we do, even DB calls, the results are stored in variables. Can you expand? 

[12:37] <isBEKaml> the variables may be lists or seqs or even iterators (mostly Iterators for DB calls, I guess)

[12:37] <colomon> isBEKaml: by raw iterator I mean an iterator variable

[12:37] <colomon> (more or less)

[12:37] <moritz_> the point is that  foo 1..10000 { ... } should never have to store these 10000 elements

[12:37] <colomon> rather than a higher level class that wraps the iterator.

[12:37] <isBEKaml> containing nothing? but just initalising it?

[12:37] <moritz_> s/foo/for/

[12:37] <colomon> what moritz_ said.

[12:38] <moritz_> so we need a data type that lets us iterate without storing the evaluated items

[12:38] <isBEKaml> ah, ok

[12:38] <colomon> So there are two ideas, and they are in conflict.

[12:38] <colomon> because "raw" iterators are consumed as they are used.

[12:39] <colomon> which is what you want to happen when you're doing something like for 1..10000

[12:39] <colomon> but at the same time, for a lot of uses, you prefer they behave like a normal array -- in particular, so you can look at the values without destroying them.

[12:40] <colomon> look at the values twice, or N times, or whatever.

[12:40] <moritz_> and for $stuff uses list($stuff) under the hood

[12:40] <moritz_> which is why I think that list() should return a raw iterator

[12:41] <colomon> moritz_: but the problem is that if you you call list(@normal-array), it can't consume the elements when you iterate them.

[12:42] <moritz_> colomon: so... list(Range) => Raw iterator

[12:42] <moritz_> list(Raw iterator) => raw iterator

[12:42] <moritz_> list(everything else) => lazy list which remembers values

[12:42] <moritz_> wait

[12:43] <moritz_> list(@normal-array) is allowed to return a raw iterator

[12:43] <moritz_> as long as @normal-array remembers its values

[12:43] <colomon> yes, but if you do that, you can't have gather iterator return something which isn't a raw iterator.

[12:43] <moritz_> that's fine as long as that turns into a List upon assignment

[12:43] <moritz_> (IMHO)

[12:43] <isBEKaml> can we do context here? lists don't appear to be iterators? What's the differentiator? 

[12:44] <moritz_> isBEKaml: lists are iterators that remember the evaluated elements

[12:44] <colomon> my little guy just gave me one of his shoes and his sweatshirt.

[12:44] <colomon> I think he wants to go out, and doesn't understand it is pouring down rain.

[12:45] <isBEKaml> moritz_: How do we say that _remembers_ elements? I may be missing something here, but there should be something that says _remember_ this, don't that. 

[12:46] <colomon> moritz_: what you are saying is basically that if you store an iterator, you lose the ability to forget.

[12:46] <colomon> that sounds right for my @a = split

[12:47] <colomon> but then how do I write a sub / method which gets the results of split without instantiating those in a variable?

[12:47] *** k23z__ left
[12:47] <moritz_> colomon: by binding, or by using it without a varialbe

[12:47] <isBEKaml> pass a ref? sounds odd... 

[12:47] <moritz_> colomon: $thing.split(..).map

[12:48] <moritz_> because you can't use it twice unless you assign it

[12:48] <moritz_> isBEKaml: the problem is that we want to the remember/don't remeber distinction rather matically

[12:49] <colomon> moritz_: binding maybe.

[12:49] <colomon> using it "without a variable" is only using it without a variable at the user's level.

[12:49] * colomon may run out of laptop battery at any minute, alas

[12:50] <moritz_> foo($str.comb) # signature binding

[12:50] <colomon> so, we have a List type which is lazy and doesn't remember it's values.

[12:51] <moritz_> which we've called "raw iterator" so far

[12:51] <colomon> but if you assign it to a variable (other than binding?) it becomes a Seq.

[12:51] *** skangas joined
[12:51] <moritz_> that's my suggestion, right

[12:51] <colomon> moritz_: well, I'm envisioning the List type as a pretty wrapper around the raw iterator.

[12:52] <colomon> binding here is something like my \$a = split   ?

[12:52] <moritz_> my $a := split

[12:53] <colomon> how do you do that in a sub signature?

[12:53] <moritz_> signatures already do binding

[12:53] <moritz_> sub f($x) { }; f(3) # binds 3 to $x

[12:53] <isBEKaml> moritz_: I'm looking at the source for the distinction. Or isn't that in yet? 

[12:54] <moritz_> isBEKaml: no code yet, all speculative

[12:55] <isBEKaml> moritz_: :(

[12:56] *** kst left
[12:56] <isBEKaml> moritz_: seeing that every list is an iterable, can we do something about new additions that contain only specific methods that allow for iterators? 

[12:56] *** kst joined
[12:57] *** wolverian left
[12:57] <moritz_> isBEKaml: I don't understand

[12:57] <isBEKaml> moritz_: for (@a) -> means a is iterable. Now we have an iterator, doing for (@iterator) should only do it lazily... 

[12:57] <isBEKaml> or we shouldn't allow for(@iterator) at all.. 

[12:58] <moritz_> well, we should have a working 'for' construct :-)

[12:58] <isBEKaml> :)

[12:58] <moritz_> and that means that it should iterate stuff

[12:59] <moritz_> and do it lazily

[12:59] <moritz_> I hope we agree so far :-)

[12:59] *** colomon left
[13:00] <isBEKaml> or, +iterator = $stuff.split , say $_ while (+iterator); 

[13:00] *** wolverian joined
[13:00] <moritz_> where + is a new sigil?

[13:00] <isBEKaml> maybe... 

[13:01] <isBEKaml> if that's possible to add, yes.. 

[13:01] <moritz_> well, not quite

[13:01] *** [mark] joined
[13:02] <isBEKaml> I just wanted to mark the difference between an iterator and a list. + and @. 

[13:03] <moritz_> I don't think new syntax is a good solution for our problem :(

[13:06] <isBEKaml> then we' d to  do some cross-work with what we already have. for eg. in writing a sub that gets the result of an operation returning an iterator, we have to treat the iterator here as something that can be referred to? a ref? or a callable? 

[13:07] <isBEKaml> but the problem here is that iterators are not methods, in which case we have to define the default operation on an iterator. 

[13:07] <moritz_> well, there are a few basic operations that you can do to an iterator

[13:07] <moritz_> binding, assignment, and calling methods on them

[13:08] <moritz_> so we just have to come up with sensible behaviour for that on an iterator

[13:12] <isBEKaml> we still have to draw the distinction between lists and iterators under the hood. for should do the Right Thing. :)

[13:13] *** BrowserUk joined
[13:13] *** dju left
[13:14] *** dju joined
[13:18] <isBEKaml> moritz_: wait, assuming we have a correct for implementation that loops over iterators, what if it exhausts itself? We shouldn't be able to use the iterator variable again, right? 

[13:18] *** dju left
[13:18] <moritz_> isBEKaml: if it's a variable, we should be able to use it again

[13:18] <moritz_> my @a = $str.comb; for @a -> $x { }; # we should use @a again here

[13:19] *** dju joined
[13:19] <isBEKaml> moritz_: you mean once it's run beyond the last element, it should go back to before the first element? 

[13:20] <moritz_> isBEKaml: it's more robust if 'for @a' takes a new iterator internally

[13:20] <moritz_> so that for @a { for @a { ... } }  does what you expect

[13:21] *** dual left
[13:22] <isBEKaml> wouldn't that make the compiler track the iterator at two different positions? 

[13:23] <isBEKaml> in every loop ?

[13:23] <moritz_> that's why we need two iterators in that case

[13:25] <isBEKaml> internally, treat every list as an iterator? 

[13:26] <moritz_> well, we need both

[13:26] <isBEKaml> so we can have for look at them as just iterators and go about its business.. 

[13:32] <masak> I just spent an hour or so explaining to this nilsonsfj guy on my blog why I don't think that the Perl 6 operators are scary or overboard: http://use.perl.org/comments.pl?sid=44783&threshold=0&commentsort=0&mode=thread&cid=71948

[13:33] <moritz_> masak: you should write that as a blog post on its own

[13:33] <masak> I guess I could just copy-paste the good parts, yes.

[13:33] * masak attempts that

[13:33] <masak> moritz_++ # idea

[13:33] <isBEKaml> masak: a blog post.. :)

[13:36] <masak> title suggestions?

[13:36] <masak> "Perl 6: zombie operators want your brains"

[13:36] <arnsholt> "I Like Operators"?

[13:37] <masak> hm, s/want/eat/

[13:37] <isBEKaml> Perl Ops ain't shadow ops! :)

[13:37] <masak> *lol*

[13:37] <masak> funny pun, but no underlying reference :)

[13:38] <masak> unless we by definition consider Perl 6's ops to be ops of the Light.

[13:38] <isBEKaml> I meant they don't scare the s* out of you.. 

[13:38] *** ruoso joined
[13:39] <pmurias> ruoso: hi

[13:39] *** kst left
[13:41] *** kst joined
[13:47] *** sorear left
[13:48] *** sorear joined
[13:51] *** colomon joined
[13:52] <colomon> Sorry for wandering off there, no battery and then needed to finish cooking Sunday dinner.

[13:52] <colomon> I got one of those simple yet maybe really nice ideas.

[13:53] <colomon> would it be possible to set things up so that we specify we want access to the iterator (without requiring memorization) simply by declaring that we want an object of type List?

[13:54] <colomon> So my List $list = split

[13:54] <colomon> gets you the List object.

[13:54] <colomon> my @list = split

[13:54] <colomon> gets you a Seq (or Array, or something like that)

[13:55] <colomon> seems like that might require a touch of magic in variable binding, but would be a very clear and simple interface

[13:59] *** ethel joined
[13:59] <isBEKaml> colomon: so you mean to say everything is an iterator except List ? 

[14:00] <isBEKaml> colomon: that loops would treat @lists lazily? and we just hold all the values in List without memoization? 

[14:05] <colomon> I'm saying that the List object is a wrapper around an iterator that allows you to process the iterator without saving the results.  (so that when you say $list.get, $list no longer remembers what the value it just returned is.)

[14:06] <colomon> and I'm proposing that any assignment of the List object to a type other than an explicit List will convert the List to a Seq/Array (which can also contain an iterator, but are required to remember the values the iterator has).

[14:07] <colomon> I'm prosing the exact same thing moritz_ and I were talking about earlier, except that instead of binding being the way to signify that we want to keep the List around as a List, declaring that we want a List type explicitly would be the way to do it.

[14:07] <colomon> jnthn can probably say better than I whether that can be reasonably made to work.

[14:07] <colomon> but it seems like it would be very intuitive to use then.

[14:08] <colomon> afk 

[14:09] <masak> omgiblogged: "Perl 6: the Frankenstein's monster of operators" http://use.perl.org/~masak/journal/40339

[14:10] <isBEKaml> masak: It's down to Frankenstein! :D

[14:10] <isBEKaml> \o/

[14:11] <masak> isBEKaml: as a non-native, I'm confused by that idiom -- "it's down to X". what does it mean?

[14:12] <isBEKaml> masak: I'm a non-native too. I was referring to Frankenstein as a freak thing that happened as was shown in the book. 

[14:12] <masak> so you meant "it's because of Frankenstein!"?

[14:13] <isBEKaml> and I was also referring to your pseudo vote polling for choicest blog titles! 

[14:13] <isBEKaml> you finally picked on one. masak++

[14:14] <masak> ah.

[14:15] <masak> well, Frankenstein's monster emerged all by itself at the last paragraph, and that settled the matter.

[14:15] <slavik> isBEKaml: everyone calls the monster Frankenstein ... even though it's the doctor

[14:15] <masak> to the extent that the term 'Frankenstein' is now quite overloaded.

[14:16] <isBEKaml> masak: I think you mean overused/abused.

[14:17] <masak> no, I meand polymorphic/polysemic :)

[14:17] <masak> s/meand/meant/

[14:17] <isBEKaml> :)

[14:18] <isBEKaml> slavik: Frankenstein's origins are left ambiguous in the book.... So, I think it's common to call the monster Frankenstein.. 

[14:19] <slavik> isBEKaml: but wasn't the doc's name Frankenstein?

[14:19] <slavik> and the monster technically doesn't have a name?

[14:19] * slavik never read the book

[14:20] <isBEKaml> slavik: I don't know if he's a doc. He was just portrayed to be very much curious about the human frame. There may be allusions to medical practice. It was so long ago that I read it. 

[14:20] <isBEKaml> s/frame/body/

[14:21] <masak> 'The title of the novel refers to a scientist, Victor Frankenstein, who learns how to create life and creates a being in the likeness of man, but larger than average and more powerful. In popular culture, people have tended incorrectly to refer to the monster as "Frankenstein".'

[14:21] <masak> from http://en.wikipedia.org/wiki/Frankenstein

[14:21] <isBEKaml> and yes, the monster doesn't have a name.. 

[14:21] <moritz_> masak: you lost some markup while copying and pasting, namely a link

[14:21] * masak looks

[14:21] <moritz_> I briefly give the rationale for why I like this change in blog post [perl.org] from a while back.

[14:22] <masak> ah. yes.

[14:22] <masak> thanks.

[14:22] *** fridim left
[14:22] <masak> fixing.

[14:24] <masak> there. also fixed one un-unicodified smiley.

[14:25] *** kst left
[14:27] *** kst joined
[14:33] <isBEKaml> masak: Ah, yes. I remember the story now. slavik, sorry if I sounded confused. It was quite a long time ago I read it, really.. 

[14:33] <slavik> isBEKaml: I'm alive ... :-\

[14:33] <slavik> moritz_: what other languages have a half decent parrot compiler?

[14:34] <slavik> moritz_: I want to try compiling a Perl6 class to pir and then using it in another language :)

[14:34] <isBEKaml> slavik: I was referring to the book. :D

[14:34] <pmurias> slavik: tcl?

[14:35] <slavik> hmm ...

[14:35] <slavik> anything else?

[14:35] <slavik> pmurias: my tcl knowledge is non-existant

[14:36] <moritz_> lua

[14:36] *** M_o_C left
[14:36] <moritz_> mostly feature complete

[14:36] <isBEKaml> slavik: parrot.org says python, ruby, lua,scheme and other dynamic languages.. 

[14:36] <isBEKaml> I don't know how far they are done, though.. 

[14:36] *** dual joined
[14:36] <slavik> isBEKaml: it will prolly be a while before I try

[14:37] <slavik> google

[14:37] <slavik> google's app engine would be most beneficial if it ran on top of parrot

[14:38] <moritz_> it would use far too much memory :(

[14:38] <slavik> moritz_: Java uses too much memory ...

[14:38] <slavik> ;)

[14:39] <slavik> moritz_: point is, that if there were like a j2ee app server but for other languages, java would die in a year

[14:39] <slavik> or two

[14:39] <moritz_> just like cobol died immediately, as soon as alternatives were available?

[14:40] <moritz_> and fortran?

[14:40] <slavik> fortran is awesome

[14:40] <isBEKaml> slavik: java already has a light weight appserver in jetty, purely coded in java. But it hasn't died yet. 

[14:40] <slavik> is jetty an actual app server? or is it more like a library?

[14:41] <isBEKaml> it's more like a library, but can be used as an appserver. AFAIK, people use it only for personal projects. I am yet to come across it being used in production. 

[14:42] <slavik> isBEKaml: looks like it's a library, similar to resin

[14:42] <slavik> but can be used to make an app server

[14:42] <slavik> actually, jetty seems to be more like tomcat ... since it's a container.

[14:43] <isBEKaml> you can write a standalone app in java and deploy it into jetty with a few lines of code. It'd still be a container - that's what I meant as an appserver. More of an embeddable appserver. 

[14:44] <masak> the trouble with irony is that I don't know if the resulting congratulations are sincere :P http://twitter.com/lamech/status/13217278101

[14:46] * moritz_ mentions yapsi in his talk

[14:46] <arnsholt> "It's complete in the sense that all of the things it implements, it does." =D

[14:47] <isBEKaml> "It's official because we have little labels with the word 'official' on them" :D

[14:47] <arnsholt> masak: l. 51, "a server" perhaps?

[14:48] <arnsholt> Also, your style is occasionally reminds me of the prof I'm working for

[14:48] <slavik> isBEKaml: the other thing is that Java is very verbose :(

[14:48] <slavik> masak: so yapsi is Perl6 in Perl6?

[14:48] <arnsholt> He puts 'celebrate approriately' in his assignment texts from time to time ^^

[14:49] <masak> arnsholt: typo already fixed in a later commit. thanks. :)

[14:49] <isBEKaml> slavik: I tend to agree with this. 

[14:49] <slavik> isBEKaml: Perl/6 (IMO) would allow faster/better development of stuffs

[14:51] <arnsholt> Oh. Never mind me then =)

[14:51] <isBEKaml> slavik: I have a little under 3 years of experience with Java. I have encountered several issues with it  - one of them being that it takes too long to deploy/undeploy apps without running into heap space issues. Another thing is that any development/deployment quickly turns bloated with too many third party libraries - jar hell. :(

[14:52] <slavik> isBEKaml: I support app servers for a living ... I know :(

[14:52] <slavik> isBEKaml: the best one is when developers code against a specific version of a library belonging to an app server

[14:52] <slavik> and when you upgrade the app server their stuff breaks

[14:53] <isBEKaml> slavik: yeah, I have seen that happening too. the heart breaking thing here is, some third party apps don't support backward compatiblity. We had to include two such apps with different versions in deployments. :(

[14:54] <slavik> yeap

[14:54] *** fda314925 joined
[14:55] <isBEKaml> I hope P6 provides a better way or a different way.. :)

[14:56] <slavik> easy, precompile to pbc and deploy, done

[14:56] <isBEKaml> including hot swapping? 

[14:57] <slavik> you mean undeploy/redeploy?

[14:57] <isBEKaml> no,just deploy the changes without asking for a full build. appserver should only look for changed files and build deps lazily. 

[14:57] <isBEKaml> s/deps/dependencies/ 

[14:57] <slavik> isBEKaml: compile on the fly?

[14:58] <isBEKaml> slavik: yeah. 

[14:58] <slavik> isBEKaml: hot deploy?

[14:58] <slavik> isBEKaml: most/all app servers do that with JSP

[14:58] <isBEKaml> slavik: yes, again. I called that hot swapping. 

[14:58] <slavik> ahh, ok

[14:58] *** fda314925 left
[14:59] *** fda314925 joined
[14:59] <slavik> isBEKaml: we,, jboss has a scanner thread that can invoke the deployer ... although it should be turned off for prod

[14:59] <slavik> isBEKaml: for weblogic, it has 2 parameters which make it check every so often for changed JSP files

[14:59] <isBEKaml> slavik:   I know JSP does it. but we precompile JSPs before deploying them into webserver. 

[14:59] <slavik> pagecheckseconds and something else

[14:59] <slavik> isBEKaml: grats, you are doing the better thing :)

[14:59] <slavik> and websphere has a specific checkbox to pre-compile JSP

[15:00] <slavik> when you deploy

[15:00] <isBEKaml> slavik: We use a

[15:00] <slavik> a?

[15:00] <isBEKaml> slavik: we use glassfish - it only loads up on memory usage.. 

[15:00] <isBEKaml> sorry, hit enter too soon.. 

[15:00] <slavik> heh

[15:01] <slavik> isBEKaml: you mean high heap utilization?

[15:01] *** kst left
[15:01] <slavik> isBEKaml: there is def some heap tunning that can be done ...

[15:01] <isBEKaml> slavik: yeah, that's on the high side.. causes webserver to go down several times. We had to manually bring that back. 

[15:02] <slavik> isBEKaml: make sure there are no memory leaks (if you are keeping objects around) and then you might need a bigger heap ...

[15:02] <isBEKaml> slavik: we were all very confused as it was our first experience with GF. people were throwing around ideas like upgrading the server's RAM and so on.. We simply backed out of it. 

[15:03] <s1n> moritz_: that's great! is that you in the middle? what made you interested in optics (and how did you go from physics to perl6)?

[15:03] <slavik> isBEKaml: who suggested the RAM idea?

[15:03] *** kst joined
[15:03] <moritz_> s1n: I'm not on the picture

[15:04] <s1n> moritz_: oh, i was just guessing :/

[15:04] <isBEKaml> slavik: sys admins, most of them. We weren't all that confident about it... 

[15:05] <moritz_> s1n: and optics is just a nice topic, it's taught in some introductory courses... and it's stuff you can *see* (at least some of it :)

[15:05] <isBEKaml> slavik: I think it's better we take this offline. We can just discuss perl6. :)

[15:06] <s1n> moritz_: did you get a BS in physics?

[15:06] <isBEKaml> slavik: even as I am only a little over a week into perl6. :)

[15:06] <moritz_> s1n: master with honours, and "Diplom" (a German thing)

[15:06] *** rv2733 left
[15:07] <s1n> moritz_: ahh, that's excellent

[15:07] <s1n> moritz_: i myself am finishing my masters :)

[15:08] <moritz_> s1n: if you're interested in a PHD position in physics here in Germany... we're still looking for fresh meat... erm, PHD students :-)

[15:09] <s1n> moritz_: honestly, i am terrible with physics, the one subject that never stuck with me

[15:09] <s1n> i'm more of a math / stats / CS guy

[15:09] <moritz_> actually I came to Perl 6 because while I was in Scotland for one year, I was bored

[15:09] <moritz_> and read about pugs, and joined this channel to report a broken link

[15:09] <moritz_> I stayed.

[15:10] <s1n> heh

[15:10] <slavik> isBEKaml: but the point of our conversation is that a parrot app server would be friggin' awesome

[15:11] <dalek> nqp-rx: f8e8a77 | Coke++ | build/Makefile.in:

[15:11] <dalek> nqp-rx: Don't check for missing parrot config item.

[15:11] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/f8e8a77c3eac82878d4eed3f1113ac09571d00c4

[15:11] <isBEKaml> slavik: yes, that'd be great... with faster deployments, low downtime, not running into memory/heap issues. 

[15:11] <s1n> i was studying PEGs when i learned perl6 had it built-in, came to see what it was all about

[15:11] <slavik> isBEKaml: IMO parrot should have Xmx and Xms ...

[15:11] <s1n> only i've been mostly on the outside looking in

[15:11] <isBEKaml> slavik: But do we really need it? I mean, _really_ need it?

[15:11] <slavik> isBEKaml: maybe not Xms ... but def Xmx ...

[15:12] <slavik> isBEKaml: my thinking behind it is that you don't want your applciation code to bring entire box down for OOM killer to come in

[15:12] <slavik> isBEKaml: better an instance of the server die than the entire box

[15:13] <isBEKaml> slavik: that was the idea behind introducing clustering in app servers. Did it succeed? People only complained more.. 

[15:13] <slavik> isBEKaml: well ... in java world, your objects have to be serializable ...

[15:14] <slavik> isBEKaml: but imagine have 2 isntances of parrot running diff apps

[15:14] <slavik> would you want 1 app to kill the second one?

[15:14] <slavik> in worst case scenario of course

[15:14] <s1n> moritz_: out of curiosity, how'd you find me on linkedin?

[15:15] <masak> std: for my $a (1, 2, 3) { say "OH HAI" }

[15:15] <p6eval> std 30537: OUTPUT«[31m===[0mSORRY![31m===[0m␤This appears to be Perl 5 code at /tmp/Mh3YJ59pV6 line 1:␤------> [32mfor [33m⏏[31mmy $a (1, 2, 3) { say "OH HAI" }[0m␤Parse failed␤FAILED 00:01 108m␤»

[15:15] <masak> STD++

[15:15] <slavik> lol

[15:15] <slavik> nice!

[15:16] <isBEKaml> slavik: ewww... I'd hate that.. If we can instantiate multiple instances of parrot, don't we want to set a top limit on heap usage. Not instance wise, but at the top-level. 

[15:16] <masak> std: for (my $a = 0; $a < 10; ++$a) { ... }

[15:16] <p6eval> std 30537: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of C-style "for (;;)" loop; in Perl 6 please use "loop (;;)" at /tmp/xuDGiUw02M line 1:␤------> [32mfor [33m⏏[31m(my $a = 0; $a < 10; ++$a) { ... }[0m␤Parse failed␤FAILED 00:01 109m␤»

[15:16] <slavik> isBEKaml: you mean for all parrot instances put together?

[15:16] <masak> std: when True { ... }

[15:16] <p6eval> std 30537: OUTPUT«Potential difficulties:␤  Smartmatch against True always matches; if you mean to test the topic for␤    truthiness, please use :so or *.so or ?* instead at /tmp/N4RuhZiMoQ line 1:␤------> [32mwhen True[33m⏏[31m { ... }[0m␤ok 00:01 107m␤»

[15:17] <slavik> isBEKaml: for Java, it is generally accepted that you don't want a very high heap size ... 2-3GB seems to be where most people stop

[15:17] <isBEKaml> slavik: My thinking is, instances can consume as much memory as they want, they can even eat into the memory used by other instances (provided, it's freely available). But don't consume more than this to bring the appserver down. Just throw some other exception or redirect to a temporarily unavailabl epage. 

[15:17] <jnthn> rakudo: for my $a (1, 2, 3) { say "OH HAI" }

[15:17] <p6eval> rakudo c4857a: OUTPUT«This appears to be Perl 5 code at line 11, near "my $a (1, "␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[15:17] <slavik> isBEKaml: so you mean to tell 2 instances of parrot that together they are not allowed more than X memory and to share it between themselves?

[15:17] <isBEKaml> slavik: yes, that's the basic idea.. 

[15:18] <slavik> isBEKaml: I think in that case ... there might be some shell/system foo that could accomplish this ...

[15:18] <isBEKaml> slavik: the thinking is to allow dynamic usage of memory.. 

[15:18] <slavik> isBEKaml: the exception would be either out of memory or no extra memory

[15:19] <slavik> isBEKaml: set max memory on user account specified for parrot ... or something

[15:19] <slavik> this should be a #parrot discussion methings

[15:19] <slavik> thinks*

[15:19] <isBEKaml> slavik: OOM sounds scary even in perl world, I'd go with no extra memory. But clueless people would just increase heap and get on with it. I'm worried about this.. 

[15:19] <slavik> isBEKaml: that's why clueless people are clueless

[15:19] <slavik> isBEKaml: apps should also be able to handle OOM

[15:20] <moritz_> most do. If you consider "dying" a form of "handling" :-)

[15:20] <pugssvn> r30538 | jnthn++ | [t/spec] Fudge a test we were passing bogusly. 

[15:20] <slavik> moritz_: handling gracefully ...

[15:20] <isBEKaml> slavik: that's why I suggested a redirect - if apps don't handle OOM or other memory issues.. 

[15:20] <slavik> isBEKaml: you mean handle on server level instead of app level?

[15:21] *** nihiliad joined
[15:21] *** _TrueFX3 joined
[15:21] <slavik> either way, the thread handling the request needs to be killed ...

[15:21] <slavik> so I guess server level

[15:21] <isBEKaml> slavik: if there's no handling in the app level, do it at the sever level. 

[15:21] <slavik> unless the thread can handle it and not ask for as much objects ...

[15:22] <slavik> isBEKaml: the other thing that I see in java is that apps do try catch and then just print the stacktrace in catch ... without any output of what they are trying to do

[15:22] <s1n> downside of never having to call malloc in perl is never having to think of OOM :/

[15:22] <isBEKaml> slavik: that's just clueless devs coding mindlessly.. 

[15:22] <isBEKaml> slavik: I have seen worse happening. catch and silently pass over.. 

[15:23] <dalek> rakudo: 925629d | jonathan++ | src/core/operators.pm:

[15:23] <dalek> rakudo: Make $x does (R1, R2) work.

[15:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/925629d85b44335afa0f9d4e50f3a8dbbd939c2e

[15:23] <dalek> rakudo: b2476f7 | jonathan++ | src/Perl6/Grammar.pm:

[15:23] <dalek> rakudo: Add a missing check so our scoped packages work as they should; allows us to run submethods.t again.

[15:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b2476f75dad3d2e5faa7d65296f35d13dc9cee13

[15:23] <dalek> rakudo: 72ef184 | jonathan++ | src/metamodel/Role (2 files):

[15:23] <dalek> rakudo: More fixing of multis composed from multiple roles.

[15:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/72ef18484d57a36518e51aacce503dbc7b4a92de

[15:23] <dalek> rakudo: 7d700b4 | jonathan++ | t/spectest.data:

[15:23] <dalek> rakudo: Turn on S12-methods/submethods.t.

[15:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7d700b4a2d25d6db36c91218219ee9c983362f90

[15:23] <slavik> isBEKaml: I have seen that as well

[15:23] <isBEKaml> slavik: I have even seen NPEs and NFEs passed over. :(

[15:23] <slavik> s1n: you mean not even in the java style new?

[15:23] <slavik> isBEKaml: NPE/NFE?

[15:24] <isBEKaml> NullPointerException and NumberFormatException

[15:24] <isBEKaml> data errors! :(

[15:24] <s1n> slavik: java style new is actually the c++ style new

[15:24] <s1n> which is just a wrapper for malloc()

[15:24] <slavik> s1n: didn't know about the first ... ewwwwwwwwww

[15:25] <slavik> isBEKaml: yes ... :(

[15:25] *** camenix left
[15:25] <slavik> isBEKaml: it is a reason I dislike java ...

[15:25] <s1n> slavik: nothing gross about having to know more about memory

[15:25] <slavik> s1n: not that ... but that java's new is also a wrapper around malloc ...

[15:25] *** xinemac left
[15:26] <slavik> s1n: but what java developer knows about memory?

[15:26] <isBEKaml> slavik: I'm just trying to dissociate myself with java and do something else. This was the primary reason I was looking at perl6.. 

[15:26] <s1n> slavik: well, not so much, but what's wrong with malloc?

[15:26] <slavik> s1n: nothing wrong with malloc

[15:26] <slavik> s1n: everything wrong with people writing java code

[15:26] <s1n> slavik: a java dev _has_ to know about memory, otherwise you get 900M GF apps

[15:26] <slavik> s1n: huh? the last 3 words confuse me

[15:26] <s1n> nothing wrong with java itself, it's a pretty/verbose version of c++

[15:27] <slavik> s1n: I don't like the verbosity :(

[15:27] <isBEKaml> s1n: java devs just gloss over app memory issues. They tend to think it's the job of java's GC.. 

[15:27] <s1n> slavik: lots of apps ignore memory and end up consuming all your memory for no reason

[15:27] <s1n> isBEKaml: agreed, which is a problem i don't dispute

[15:27] <slavik> s1n: isBEKaml: we all agree there :)

[15:27] <slavik> s1n: can you explain what you mean by "900M GF apps"

[15:28] <isBEKaml> slavik: I think he means 900 million GlassFish apps.. 

[15:28] <s1n> slavik: write a hello world j2ee app, then it'll make sense :)

[15:28] <s1n> no

[15:28] <s1n> 900MB sorry

[15:28] <slavik> s1n: I like perl because it lets me think in the messed up functional way that I tend to think in ...

[15:28] <masak> rakudo: class A {}; class B { has A $.foo .= new }

[15:28] <p6eval> rakudo c4857a: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤current instr.: '!dispatch_.=' pc 440 (src/glue/dispatch.pir:118)␤»

[15:28] <slavik> s1n: it will take 1 month to do that ...

[15:28] * masak submits rakudobug

[15:28] <masak> alpha: class A {}; class B { has A $.foo .= new }

[15:28] <p6eval> alpha 30e0ed: OUTPUT«error:imcc:syntax error, unexpected '\n'␤   in file 'EVAL_25' line 186␤Null PMC access in find_method('new')␤in Main (file <unknown>, line <unknown>)␤»

[15:28] <s1n> slavik: well, it's still turing complete, so it's all the same to me

[15:28] <slavik> s1n: ... :-\

[15:29] <slavik> s1n: that's why we need to care about amortized time :P

[15:29] *** christine left
[15:30] <s1n> i dunno, the fanboyism for a language is pointless to me as long as the language is turing complete, you can express all the same ideas but one language may need more work than others

[15:30] <s1n> either way, that work is either on the app dev, the library dev, or the compiler dev

[15:31] <s1n> the perl app dev has much less work because the library and compiler devs did many things for them

[15:31] <s1n> java is the opposite

[15:31] <isBEKaml> s1n: I don't dispute your point. But we are humans too and we try to solve problems as humanely as possible. if it's just too much work in one language, we can take another language. But if it's the same tiring job over and over again, we just jump boats.. 

[15:32] <slavik> s1n: that is exactly my point ... I would factor in language dev into that :)

[15:32] <slavik> TimToady++ :)

[15:32] <moritz_> torment the compiler writer on behalf of the user

[15:32] <s1n> yeah, that's fine, having a language take care of things the app/lib dev doesn't want to do is nice, i don't argue

[15:32] *** kst left
[15:32] <s1n> still work someone has to do :)

[15:33] <s1n> java is fine if you want to do that work yourself :/

[15:33] *** kst joined
[15:33] <s1n> or you don't mind the vm bloat

[15:34] <isBEKaml> s1n: I tend to think of java world as divided into library and app devs - compiler devs are almost always never disturbed with issues... library devs don't care about app devs and app devs are cursing lib devs for not providing more API functionality.. 

[15:34] <s1n> well, lib devs provide plenty, just _way_ too complex to be quickly/easily usable

[15:34] <isBEKaml> and app devs either go searching for more third party apps or hand-code their functionality themselves (most don't do this, though)

[15:34] <s1n> j2ee is a giant mess

[15:35] <s1n> but it can still make webapps (poorly though)

[15:35] <slavik> CPAN ftw

[15:35] <isBEKaml> s1n: well, part of that is due to the long and protracted java community process.. most of them just drop out at the elongated affair... 

[15:35] <slavik> I like searching CPAN for "thingIneed Simple" ... usually gives me a module that take like 2 lines to return some kind of a structure or whatever I need to work with data

[15:36] <s1n> slavik: i recall an article somewhere comparing the modern developer to a child building with legos, how depressing that seems

[15:36] <isBEKaml> s1n: it's too much work to even ask for a simple functionality.. 

[15:36] <slavik> s1n: have a link? I'd be interested in reading

[15:36] *** _TrueFX3 left
[15:37] <s1n> isBEKaml: i agree, i had to make a j2ee app and i almost wanted to cry

[15:37] <s1n> slavik: i'd have to look, i don't remember where i read it

[15:37] * moritz_ kinda still likes lego

[15:37] <slavik> I needed to parse XML the other day ... XML::SImple ... give and XML file or string to XML::Simple::XMLin() and it returns a hash ... done ... easy ... 2 lines of code ...

[15:38] <slavik> looking at java libraries made me cry and forget what I wanted to do in the first place

[15:38] <slavik> same with Config::Simple

[15:38] <slavik> or maybe just Config

[15:39] *** BrowserUk left
[15:39] <s1n> slavik: but nothing about perl makes that library particularly easy or great, you could do that in C if you were so inclined

[15:39] <isBEKaml> slavik: JAXP hurt so much I never did XML again in java.. 

[15:40] <s1n> (_could_, though i wouldn't)

[15:40] <slavik> s1n: I think it has to do with the culture behind the language

[15:40] <moritz_> could you?

[15:40] <moritz_> first you'd have to write a struct that can either be an array or a hash or a string

[15:40] <s1n> slavik: true, too many people have their hands in java that it usually turns out a mess

[15:40] <s1n> CPAN is usually one or a small group of people on a module

[15:40] <moritz_> and then accessors for that

[15:40] <s1n> easier for the module to stay pure to the design

[15:40] <slavik> s1n: I think we agree that many things are easier to do in Perl vs. Java

[15:41] <s1n> well some things

[15:41] <slavik> Easy things easier, difficult things not impossible.

[15:41] <slavik> :)

[15:41] <isBEKaml> :)

[15:41] *** christine joined
[15:41] <slavik> which is why I can't wait for feature complete version of rakudo

[15:41] <s1n> again, i heavily disagree with language favoritism, it all comes down to what you're doing

[15:42] <s1n> i like perl6 because of the built-in PEG, that's just cool to me

[15:42] <slavik> PEG?

[15:42] <s1n> but many other languages can be used to express the idea similarly

[15:43] <s1n> parsomg expression grammar

[15:43] <slavik> lol

[15:43] <s1n> oops

[15:43] <s1n> parsing

[15:43] <slavik> s/om/in/ ?

[15:43] <s1n> hands were offset there

[15:44] <slavik> brb

[15:45] *** BrowserUk joined
[15:46] *** M_o_C joined
[15:46] *** BrowserUk left
[15:59] *** [mark] left
[16:00] <masak> I was just about to turn to the poker hand example for the book, when I realised that this bug is still not looked at: http://rt.perl.org/rt3/Ticket/Display.html?id=74276

[16:00] <masak> it's the one where defininf a class starting with the letter 'Q' and then using it doesn't work.

[16:01] <masak> seems it's still open. has someone had a chance to look at it yet?

[16:01] <masak> otherwise, I might give it a shot tonight.

[16:01] *** kst left
[16:01] * arnsholt has a peek

[16:01] <arnsholt> I've just spent the better part of half an hour fighting with LaTeX and layout

[16:02] *** kst joined
[16:02] <arnsholt> Time for something completely different

[16:02] <isBEKaml> afk &

[16:03] <masak> is it just me, or has the Rakudo build actually gotten faster lately?

[16:04] <moritz_> faster? you've got to be kidding

[16:04] <masak> maybe I misremember.

[16:05] <masak> src/gen/core.pir is still the big bottleneck, it seems. but it got through Actions.pm quite quickly.

[16:05] <moritz_> masak: are you tracking rakudo HEAD right now?

[16:06] <masak> yes.

[16:06] <masak> but I still build Parrot independently.

[16:06] <moritz_> but with a recommended (or newer) parrot version?

[16:06] *** plobsing joined
[16:06] <masak> yes. right now the recommended one, r46148.

[16:08] <moritz_> with a *very* evil hack, I've got non-quantified, named captures working on Match objects

[16:10] <moritz_> and with *very* evil I mean introducing a method in Mu

[16:10] <masak> somehow the fact that the class is called 'Mu' makes it feel less evil :)

[16:11] <moritz_> I was about to say that I introduced a global method

[16:11] <masak> now that does have an evil ring to it.

[16:11] <arnsholt> nqp: class Foo {}; my $a := Foo.new;

[16:11] <p6eval> nqp:  ( no output )

[16:12] <arnsholt> nqp: class Quad {}; my $a := Quad.new;

[16:12] <p6eval> nqp: OUTPUT«Confused at line 1, near "my $a := Q"␤current instr.: 'parrot;HLL;Grammar;panic' pc 500 (src/cheats/hll-grammar.pir:197)␤»

[16:12] <arnsholt> masak: ^^

[16:12] <arnsholt> It's actually an NQP bug

[16:12] <slavik> := ???

[16:12] <moritz_> binding

[16:12] <masak> arnsholt: good to know. thanks.

[16:12] <arnsholt> (Because Rakudo uses NQP's quoting code)

[16:12] <arnsholt> I'm gonna have a look when I get home

[16:12] <slavik> moritz_: but = is assignment?

[16:12] <masak> ++arnsholt

[16:12] <arnsholt> Right now I'm waiting for the bus =)

[16:12] *** tri1 joined
[16:13] <arnsholt> slavik: := is binding, which is subtly different form assignment

[16:13] <slavik> is there a short explanation on the difference?

[16:13] *** tri1 left
[16:13] *** lue left
[16:13] <moritz_> binding replaces the container

[16:13] <moritz_> it's like aliasing

[16:14] <slavik> whereas assigment makes a copy?

[16:15] <moritz_> yes-ish

[16:15] <moritz_> at least of the reference

[16:17] <masak> hm, nilsonsfj has replied yet again: http://use.perl.org/comments.pl?sid=44783&cid=71949

[16:17] <masak> this is the first comment of his that I'm not tempted to reply to.

[16:17] <masak> he's still very cogent, but I just can't relate to what he's saying because I don't have those experiences myself.

[16:19] <colomon> how can you reply when you try to explain things clearly, and his response is batshit fucking insane?

[16:19] <colomon> where else is there to go?

[16:20] <masak> I'm not sure I agree that he's insane. he's just caught up in his perspective.

[16:20] <moritz_> some things just can't be changed easily

[16:21] <colomon> sorry, his response is "batshit fucking insane".

[16:22] <isBEKaml> he doesn't appear to be insane. He just appears to be intimidated by the enormity of changes in P6. ;)

[16:22] <colomon> (ie those are his words.)

[16:22] <slavik> I quite like twidgils ... IMO the whole sigil/twidgil thing is better in Perl6

[16:23] <slavik> ie: $*Blah means that Blah is a global scalar

[16:23] <colomon> he's not making a reasoned response, he's just utterly dismissive.

[16:23] <isBEKaml> Just as I was when I first saw it on perl6.org, but quickly got over it by the friendliness seen on this channel. I'm still motivated to learn more here. :)

[16:23] <masak> isBEKaml: and annoyed that the only effects of Perl 6 on his life are people's negative reactions.

[16:23] <moritz_> isBEKaml: which part of perl6.org scared you?

[16:24] <isBEKaml> masak: sadly, people tend to go by others' judgements.. :(

[16:25] <isBEKaml> moritz_: I didn't mean perl6.org, I meant the fact that perl6 is an entirely new language and there are lots of new unicode ops. I was thinking, well, as long as they provide ascii ops alonside unicode ones, I can go with it. 

[16:25] <isBEKaml> :)

[16:26] <moritz_> isBEKaml: ok. I just thought there might be potential to reduce scariness from perl6.org

[16:26] <isBEKaml> moritz_: I think I said this before, perl6.org doesn't exactly say what parrot, pugs and rakudo are and how they stack up on the perl6 ecosystem. Can that be fixed? I was misled into thinking all perl6 implementations are on VMs.. 

[16:28] <isBEKaml> that includes thinking pugs and rakudo were VMs, when they are not.. 

[16:28] <moritz_> isBEKaml: usually we try not to special-case rakudo or parrot on perl6.org ... but maybe I can come up with a clean explanation on /compilers/

[16:29] <isBEKaml> moritz_: no, not showcasing them. Most people, I think, come to perl6.org with a fairly informed knowledge about parrot, pugs but just don't get the "big picture", if you know what I mean.. 

[16:30] <isBEKaml> eww, s/informed/rudimentary/

[16:31] <moritz_> oh, perl6.org got stuck in an svn lock :(

[16:35] <isBEKaml> oh, does that happen? I just find it odd to see svn locks unless the svn account was disabled/locked out or something.. 

[16:35] *** pmurias left
[16:35] <slavik> moritz_: IMO, the periodic table of operations should be part of the docs :)

[16:35] <moritz_> svn locks its .svn

[16:36] <isBEKaml> oh, that.. 

[16:36] <moritz_> slavik: it is

[16:36] <isBEKaml> moritz_: does svn cleanup help?

[16:37] <moritz_> isBEKaml: yes

[16:37] <moritz_> it's udpated again

[16:37] <isBEKaml> moritz_: this would revert all your changes and release locks. you'd have to do your changes again.. 

[16:37] <moritz_> there should be no changes on that server

[16:38] *** kst left
[16:38] *** justatheory joined
[16:39] *** kst joined
[16:40] <moritz_> for some reasons not quite understandble to me, quantified named captures refuse to work in my branch

[16:40] <masak> in the end, I did reply anyway: http://use.perl.org/comments.pl?sid=44783&cid=71951

[16:41] <masak> time to go nommin &

[16:41] *** masak left
[16:41] <isBEKaml> nomming?

[16:42] <moritz_> eating

[16:42] <isBEKaml> oh. :) 

[16:43] <isBEKaml> masak's was a great reply. Not a hint of frustration/disappointment... :) masak++

[16:45] *** slavik left
[16:51] *** BrowserUk joined
[16:58] *** envi^home left
[17:04] *** takadonet1 left
[17:05] *** rgrau left
[17:07] <arnsholt> What's the proper way to add info to an RT ticket? Reply or comment?

[17:16] *** slavik joined
[17:22] *** slavik left
[17:22] <moritz_> yes

[17:23] <moritz_> doesn't really make a difference

[17:23] <moritz_> I usually use 'reply'

[17:24] *** patrickas joined
[17:25] *** kst left
[17:25] <arnsholt> Cool

[17:25] *** rv2733 joined
[17:25] *** kst joined
[17:26] <Juerd> arnsholt: If you're repyling to a specific item, use reply. If you're adding information but not in response to a previous part, use comment.

[17:26] <arnsholt> Oh, right. That makes sense

[17:26] <Juerd> IIRC, replies go to the bug reporter, comments do not. I'm not sure.

[17:27] *** slavik joined
[17:33] *** molaf joined
[17:37] *** BrowserUk left
[17:39] <isBEKaml> how do I invoke a sub of a class? I'm looking at the Date module, I find that I can just invoke methods but not subs. Are they private?

[17:39] *** opx^away left
[17:40] <isBEKaml> rakudo: use Date; say Date.assert-valid-date(2010,04,31);

[17:40] <p6eval> rakudo c4857a: OUTPUT«Unable to find module 'Date'.␤current instr.: 'perl6;Perl6;Module;Loader;need' pc 35817 (src/gen/role_pm.pir:932)␤»

[17:41] <isBEKaml> here assert-valid-date is a sub. 

[17:41] *** k23z__ joined
[17:54] *** renormalist left
[17:57] <arnsholt> I'm starting to suspect that this is an issue with LTM

[17:57] <arnsholt> Which means I need to understand that

[17:57] * arnsholt heads for S05

[17:59] *** rv2733 left
[18:01] *** renormalist joined
[18:01] *** renormalist left
[18:03] *** kst left
[18:04] *** kst joined
[18:05] *** Freakezoid joined
[18:10] <lisppaste3> Panzen pasted "Perl Regexp find the n word and replace it." at http://paste.lisp.org/display/98684

[18:13] <Freakezoid> can anyone tell me how i can replace the n word in a text? my approach is at  but when a word occourrs more than one time, all occurrences will be replaced :(

[18:14] <Freakezoid> source is at: http://paste.lisp.org/display/98684

[18:14] <moritz_> Freakezoid: this channel is about Perl 6 development

[18:14] <Freakezoid> oh sorry

[18:14] <moritz_> isBEKaml: subs are my-scoped by default

[18:14] <moritz_> isBEKaml: so yes, private

[18:15] *** Freakezoid left
[18:16] <isBEKaml> moritz_: thanks. I got that impression as I was reading the spec after posing it here. :) (though it's bit a vague, but lot clearer than the java spec docs ;) )

[18:17] <moritz_> rakudo: Date.new('2010-05-00')

[18:17] <p6eval> rakudo c4857a: OUTPUT«Invalid date: day < 1␤current instr.: '&die' pc 17391 (src/builtins/Junction.pir:410)␤»

[18:17] <moritz_> rakudo: Date.new('2010-04-31')

[18:17] <p6eval> rakudo c4857a: OUTPUT«Invalid date: day > 30␤current instr.: '&die' pc 17391 (src/builtins/Junction.pir:410)␤»

[18:17] <moritz_> that's how you call assert-valid-date :-)

[18:17] <isBEKaml> moritz_: :)

[18:18] <arnsholt> moritz_: Should `Q' being a more specific prefix for quote than name somehow block backtracking when quote fails?

[18:19] <moritz_> arnsholt: not sure...

[18:19] <moritz_> arnsholt: I'm trying to add a >> after Q

[18:19] <arnsholt> A >>?

[18:20] *** dju left
[18:20] <moritz_> >> is right word boundary

[18:21] <moritz_> arnsholt: seems to help

[18:21] <isBEKaml> moritz_: There are some methods that are chained to subs in the Date module. Can't we have something for assert-valid-date too? 

[18:22] <arnsholt> moritz_: Good, good

[18:22] <isBEKaml> rakudo: my $ff= Date.new(2010,05,30); say $ff.leap-year();

[18:22] <p6eval> rakudo c4857a: OUTPUT«0␤»

[18:22] <moritz_> isBEKaml: why? just call .new(), and if it fails, you know it's not a valid date

[18:22] <isBEKaml> rakudo: my $ff= Date.new(2010,05,30); say "leap" unless $ff.leap-year();

[18:22] <p6eval> rakudo c4857a: OUTPUT«leap␤»

[18:23] <isBEKaml> moritz_: sure, that's right. Talking about consistency, when checks are there for leap year, why not dates too?

[18:24] <moritz_> arnsholt: will push soon, after more testing

[18:24] <arnsholt> Cool. NQP can probably be fixed in the same manner

[18:24] <moritz_> I am talking about NQP

[18:24] *** renormalist joined
[18:25] <arnsholt> Oh, of course ^^

[18:25] <arnsholt> *facepalm*

[18:25] <colomon> 31806 passing tests, woo-hoo!

[18:26] <slavik> colomon: out of?

[18:26] <moritz_> approx. 40k

[18:26] <colomon> 38898, according to tools/test_summary.pl

[18:27] <isBEKaml> cool.. 

[18:27] <moritz_> std: mfoof

[18:27] <p6eval> std 30538: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'mfoof' used at line 1␤Check failed␤FAILED 00:01 109m␤»

[18:27] <colomon> not sure how real that number is, however... does it count tests that are commented out in spectest.data?

[18:27] <moritz_> std: m:g foof

[18:27] <p6eval> std 30538: OUTPUT«[31m===[0mSORRY![31m===[0m␤Alphanumeric character is not allowed as delimiter at /tmp/9EvPIOw2X7 line 1:␤------> [32mm:g [33m⏏[31mfoof[0m␤Parse failed␤FAILED 00:01 107m␤»

[18:27] <moritz_> colomon: it should count all

[18:27] <moritz_> std: Qbarb

[18:27] <dalek> nqp-rx: ec48321 | moritz++ |  (2 files):

[18:27] <p6eval> std 30538: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤ 'Qbarb' used at line 1␤Check failed␤FAILED 00:01 107m␤»

[18:27] <dalek> nqp-rx: allow sub names to start with Q

[18:27] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/ec4832184bfca740f124080cd8760ebb4e9cd2d9

[18:27] <dalek> nqp-rx: d6815bf | moritz++ | src/stage0/ (3 files):

[18:27] <dalek> nqp-rx: update stage0 files

[18:27] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/d6815bffc2a3d15821fff535322e742954574603

[18:28] <moritz_> rakudo: Qbarb

[18:28] <p6eval> rakudo c4857a: OUTPUT«Confused at line 11, near "Qbarb"␤current instr.: 'perl6;HLL;Grammar;panic' pc 500 (ext/nqp-rx/src/stage0/HLL-s0.pir:328)␤»

[18:31] *** Transformer joined
[18:34] *** Transformer left
[18:37] <arnsholt> nqp: say(pir::typeof__sp("{1}"))

[18:37] <p6eval> nqp: OUTPUT«Null PMC access in set_string_native()␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[18:39] *** lichtkind joined
[18:40] <lichtkind> hai people

[18:40] <phenny> lichtkind: 30 Apr 15:33Z <TimToady> tell lichtkind in best-of tablet, for 1..15:by(-2) -> $i {...}

[18:40] <phenny> lichtkind: 30 Apr 15:35Z <TimToady> tell lichtkind ...is wrong two ways, no ':by' anymore, and range doesn't autoreverse.  use something like for 15,13...1 -> $i {...}

[18:40] <lichtkind> TimToady: damian already wrote me and noted that, its fixed since yesterday :)

[18:41] <moritz_> lichtkind: http://github.com/moritz/perltalk might interest you

[18:41] <lichtkind> moritz_: ive seen your p-c.de post and have link on your slides

[18:42] <moritz_> lichtkind: ok

[18:42] <lichtkind> moritz_: a possible intro for the book im writing on is also still in the pipe

[18:42] <moritz_> you're writing a book?

[18:43] <lichtkind> moritz_: no the p6 book your writing on

[18:43] <moritz_> ah, I was misparsing your statement :-)

[18:43] <lichtkind> i have just alternative ideas for the beginning and post that

[18:46] *** M_o_C left
[18:47] *** dukeleto joined
[18:50] <arnsholt> nqp: say(pir::typeof__pp("{1}"))

[18:50] <p6eval> nqp: OUTPUT«Null PMC access in set_string_native()␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[18:50] <moritz_> nqp: say(pir::typeof__pp("foo{1}"))

[18:50] <p6eval> nqp: OUTPUT«String␤»

[18:52] *** rgrau joined
[18:56] * jnthn will be, like, totally offline for next 3 days.

[18:56] <jnthn> Going to the countryside, camping. :-)

[18:56] <arnsholt> How will you ever survive? =)

[18:57] <jnthn> ;-)

[18:57] <arnsholt> moritz_: In a nutshell, it's the string interpolation issue I prodded during the CPH hackathon

[18:58] <moritz_> arnsholt: thought so

[18:58] *** lookieloop joined
[18:58] <arnsholt> I figured I'd add a test to the test suite for it

[18:58] *** plobsing left
[18:58] <moritz_> that would be nice

[19:00] <arnsholt> But pir::typeof blows up, which is inconvenient =)

[19:00] <moritz_> isa?

[19:00] <moritz_> nqp: say(pir::isa_pp("foo{1}", 'String'))

[19:00] <p6eval> nqp: OUTPUT«error:imcc:syntax error, unexpected PREG, expecting '(' ('$P15')␤    in file 'EVAL_1' line 11␤Could not find non-existent sub isa_pp␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[19:00] <dalek> rakudo: fad910a | moritz++ | src/Perl6/Grammar.pm:

[19:00] <dalek> rakudo: Attemp to allow names starting with q, qq, Q etc.

[19:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/fad910a072d05110da0135193165c63552ebc9be

[19:01] <moritz_> nqp: say(pir::isa_pp("foo{1}", String))

[19:01] <p6eval> nqp: OUTPUT«error:imcc:syntax error, unexpected PREG, expecting '(' ('$P15')␤    in file 'EVAL_1' line 10␤Could not find non-existent sub isa_pp␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[19:01] <arnsholt> nqp: say(pir::isa__ips("{1}", "String"))

[19:01] <p6eval> nqp: OUTPUT«Null PMC access in set_string_native()␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[19:03] <arnsholt> nqp: say(pir::isa__ipp("{1}", String))

[19:03] <p6eval> nqp: OUTPUT«Null PMC access in set_string_native()␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[19:04] <arnsholt> nqp: say(pir::box__pi(pir::isa__ipp("{1}", String)))

[19:04] <p6eval> nqp: OUTPUT«Null PMC access in set_string_native()␤current instr.: '_block11' pc 0 (EVAL_1:6)␤»

[19:04] *** synth left
[19:04] <arnsholt> Yeah. It doesn't like the assignment of the string register result of "{1}" to a PMC register

[19:06] <moritz_> so probably the result of the block should be coereced to String first

[19:08] *** nadim_ left
[19:12] <moritz_> rakudo: say < >.WHAT

[19:12] <p6eval> rakudo c4857a: OUTPUT«Str()␤»

[19:15] *** molaf left
[19:21] *** vegard joined
[19:30] <dalek> rakudo: f82af0b | jonathan++ | src/ (2 files):

[19:30] <dalek> rakudo: Somewhat unbreak candidate introspection on multis.

[19:30] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f82af0b588d83a68afc228c9c3b13d1d1e3ef89e

[19:30] *** synth joined
[19:31] *** synth left
[19:31] <pugssvn> r30539 | jnthn++ | [t/spec] Unfudge some spectests. 

[19:31] *** synth joined
[19:34] *** lue joined
[19:36] <pugssvn> r30540 | moritz++ | [t/spec] unfudge tests for regexe in boolean context 

[19:37] <moritz_> one weird behaviour down, 616 to go :/

[19:40] *** kst left
[19:40] *** kst joined
[19:41] <dalek> rakudo: 8abe0a6 | moritz++ | src/core/Regex.pm:

[19:41] <dalek> rakudo: Regexes in boolean context match against $_

[19:41] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/8abe0a6b7988d47dfe758bf3492e182f8cb98048

[19:41] *** nadim_ joined
[19:43] <moritz_> std: class A { has $!a; method foo { :$!a } }

[19:43] <p6eval> std 30538: OUTPUT«ok 00:01 110m␤»

[19:43] <moritz_> rakudo: class A { has $!a; method foo { :$!a } }

[19:43] <p6eval> rakudo c4857a: OUTPUT«Symbol '$!a' not predeclared in foo␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[19:44] *** chitragupt left
[19:47] *** gurjeet left
[19:49] <sorear> eternaleye: No hygenic macros.

[19:49] <sorear> Hygenic macros are much, much harder.

[19:49] <sorear> Mainly because Rakudo doesn't have a true parser - we do a lot of symbol hacking during what should be the parse phase

[19:49] <sorear> consider quasi { has $x }

[19:49] <colomon> TimToady: ping?

[19:50] <sorear> if we just parse the quasi, the 'has' will go into the macro itself!  not good

[19:50] <sorear> TimToady wants to defer symbol injection using something almost, but not entirely unlike, a role

[19:50] <moritz_> sorear: and there's a good reason for that... otherwise we couldn't do most of the parsing in syntax-check-only mode

[19:50] <sorear> that'll take some time to work out the details of.

[19:51] <jnthn> moritz_: I was just about to say that. :-)

[19:52] <jnthn> STD does the same kinda thing. But there's an $*IN_QUASI (IIRC) flag that can be checked.

[19:52] <jnthn> I would guess that suppresses the name stuff.

[19:52] <jnthn> Or do the right kind of thing.

[19:52] *** BrowserUk joined
[19:54] <moritz_> rakudo: my $x = 3; say (:$x).perl

[19:54] <p6eval> rakudo c4857a: OUTPUT«"x" => 3␤»

[19:59] <lichtkind> moritz_: what is the right term for http://www.perlfoundation.org/perl6/index.cgi?perl_6_lookup_tablet#escape_sequences ?

[20:00] <moritz_> escape sequences. Or backslash escapes. Or so

[20:01] <lichtkind> moritz_: so escape sequences sounds good enough to mention it under that titel in th index

[20:01] <moritz_> yes

[20:01] <lichtkind> thanks

[20:02] *** nadim_ left
[20:02] *** nadim_ joined
[20:05] <vegard> hi. something went wrong with the perl6 book pdf for april.

[20:05] <moritz_> please elaborate

[20:05] <vegard> starting from page 14, the code samples are messed up

[20:06] <vegard> either that or perl6 code looks truly horrible ;-)

[20:06] *** plobsing joined
[20:06] <moritz_> nope, it's really the pdf

[20:07] <moritz_> vegard: try http://moritz.faui2k3.org/tmp/book.pdf instead

[20:07] <vegard> looks better, thanks

[20:07] *** snarkyboojum left
[20:10] <colomon> rakudo: say 31 !% 3

[20:10] <p6eval> rakudo c4857a: OUTPUT«0␤»

[20:10] <colomon> rakudo: say 30 !% 3

[20:10] <p6eval> rakudo c4857a: OUTPUT«1␤»

[20:10] <colomon> rakudo: say 32 !% 3

[20:10] <p6eval> rakudo c4857a: OUTPUT«0␤»

[20:15] *** isBEKaml left
[20:15] <moritz_> rakudo: my $x ||= 3; say $x

[20:15] <p6eval> rakudo c4857a: OUTPUT«3␤»

[20:15] <moritz_> rakudo: my $x &&= 3; say $x

[20:15] <p6eval> rakudo c4857a: OUTPUT«Null PMC access in invoke()␤current instr.: '!assign_metaop' pc 17195 (src/builtins/Junction.pir:315)␤»

[20:17] <moritz_> std: my($x)

[20:17] <p6eval> std 30540: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $x is not predeclared at /tmp/pQngSFVGBQ line 1:␤------> [32mmy($x[33m⏏[31m)[0m␤Undeclared routine:␤       'my' used at line 1␤Check failed␤FAILED 00:01 109m␤»

[20:19] <moritz_> rakudo: class X {method x (*@_) {say @_} }; X.new.x(5)

[20:19] <p6eval> rakudo c4857a: OUTPUT«5␤»

[20:20] * colomon turned up a Rakudobug locally just in time to be off to "Folk Music Sunday"

[20:24] *** chitragupt joined
[20:25] *** kst left
[20:26] *** kst joined
[20:26] *** lichtkind left
[20:29] <moritz_> rakudo: role Str { }

[20:29] <p6eval> rakudo c4857a:  ( no output )

[20:31] <moritz_> rakudo: say [^^] 1, 1, 1

[20:31] <p6eval> rakudo c4857a: OUTPUT«Could not find sub &infix:<^^>␤current instr.: '' pc -1 ((unknown file):-1)␤»

[20:33] <moritz_> rakudo: say (+'23').WHAT

[20:33] <p6eval> rakudo c4857a: OUTPUT«Num()␤»

[20:34] <sorear> my spectest failed with unexpected todo passing...

[20:34] * moritz_ hopes that was not the reason for the fail

[20:34] <sorear> S05-mass/properties-general, several # TODO Uninvestigated nqp-rx regression

[20:34] <moritz_> that's platform dependent :(

[20:35] *** chitragupt left
[20:35] *** chitragupt joined
[20:35] <moritz_> rakudo: if 5 > my $a = 4 { say $a }

[20:35] <pugssvn> r30541 | moritz++ | [t/spec] rakudo unfudges 

[20:35] <p6eval> rakudo c4857a: OUTPUT«Use of uninitalized value in numeric context␤Cannot assign to readonly value␤current instr.: '&die' pc 17391 (src/builtins/Junction.pir:410)␤»

[20:37] <moritz_> rakudo: my $x = :a<5>; say $x.map({.key => .value + 1}).perl

[20:37] <p6eval> rakudo c4857a: OUTPUT«Method 'key' not found for invocant of class ''␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:37] <moritz_> rakudo: my $x = :a<5>; say $x.map({.WHAT}).perl

[20:37] <p6eval> rakudo c4857a: OUTPUT«(Pair)␤»

[20:42] *** chitragupt left
[20:43] *** pmurias joined
[20:44] *** meppl left
[20:44] *** chitragupt joined
[20:58] <sorear> oh?  hmm

[20:58] <sorear> std: quasi { has $x }

[20:58] <p6eval> std 30540: OUTPUT«ok 00:03 114m␤»

[20:58] *** chitragupt left
[20:58] <sorear> std: quasi { my $x; $y }

[20:58] <p6eval> std 30540: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $y is not predeclared at /tmp/jYitZNhroH line 1:␤------> [32mquasi { my $x; $y[33m⏏[31m }[0m␤Check failed␤FAILED 00:01 109m␤»

[20:59] <sorear> I had no idea STD implemented quasi

[20:59] *** chitragupt joined
[20:59] <sorear> I guess I need to learn how STD.pm works now

[20:59] *** BrowserUk left
[21:00] <sorear> (does anybody have a clone of my rakudo repo?  I'd like to do some branch rearranging)

[21:01] *** orafu left
[21:01] *** orafu joined
[21:05] * jnthn gets a crappy first cut at enums that may make The Chese work some more together.

[21:07] <sorear> Chese?

[21:11] <jnthn> Cheese

[21:11] <jnthn> The app cheese.

[21:11] <jnthn> :-)

[21:11] *** Guest81117 left
[21:11] <jnthn> Might make masak++ happy. :-)

[21:12] <jnthn> Well, until he realizes how little of them works so far. :-)

[21:12] <jnthn> But it should cover all the basic cases.

[21:18] <cognominal> what is the purpose of YOU_ARE_HERE?

[21:19] *** lookieloop left
[21:20] *** pmurias left
[21:21] *** camenix joined
[21:25] *** camenix left
[21:29] <sorear> cognominal: it's a placeholder for user code

[21:29] <sorear> Perl 6 has a circumlude, not a prelude

[21:30] <sorear> the initial definitions are regarded as an outer lexical scope

[21:30] <sorear> jnthn: But what *is* app cheese?

[21:30] <jnthn> sorear: It's the existing Perl 6 code that runs/has run on Rakudo.

[21:33] <cognominal> sorear: I still don't get it :(

[21:34] *** camenix joined
[21:34] <lue> o hai!

[21:36] *** xinemac joined
[21:37] <jnthn> cognominal: Programs run with the setting as its outer lexical scope.

[21:38] <jnthn> YOU_ARE_HERE represents a point in the lexical scope where the program should be "inserted".

[21:38] <cognominal> thx

[21:42] <dalek> rakudo: a4112c2 | jonathan++ | src/ (2 files):

[21:42] <dalek> rakudo: First hacky cut of named enums. Mostly just works like a bunch of constant declarations, kinda. It's certainly not what we want in the long run, but it removes a blocker for much of the app cheese.

[21:42] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a4112c2426ba7a09b9f751f15aba5052c35276c8

[21:42] <dalek> rakudo: 7ec16e1 | jonathan++ | src/core/Regex.pm:

[21:42] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[21:42] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7ec16e10b5a8c28d32d066818033fd916f7ceb59

[21:45] <sorear> jnthn: Can you tell me more about the etymology of app cheese?

[21:46] <jnthn> sorear: At a conference in Oslo a little while back, masak gave a talk in which he depicted Rakudo as being kinda like swiss cheese (the kind of holes in it), where the cheese represents what is implemented feature wise and the holes relate to the bugs.

[21:47] <jnthn> That's where this all derives from. :-)

[21:47] <sorear> aha.

[21:47] <jnthn> Yes, it's not an obvious one. :-)

[21:47] * sorear goes back off to study STD's implementation of hygiene

[21:47] <lue> swiss cheese is very holy. It's not a putdown :)

[21:47] * jnthn tries to fix sorearbug

[21:48] <sorear> the crazy BEGIN one?

[21:48] <jnthn> It's Swiss, it must be awesome. :-)

[21:48] * jnthn likes Switzerland lots.

[21:50] <sorear> macro work has been moved to topic/macros

[21:51] <jnthn> :-)

[21:52] <sorear> so my 'master' is now consistent with rakudo master

[21:56] *** snarkyboojum joined
[21:59] *** justatheory left
[21:59] <jnthn> > say BEGIN { rand }

[21:59] <jnthn> 0.466257142692001

[21:59] <jnthn> Whee.

[22:00] <lue> Just so I know, what's with all the capitalization? BEGIN, PAST, and so on.

[22:00] <lue> I know they're the deep magic, but that's it.

[22:01] <jnthn> lue: Well, BEGIN is uppercase because all of the phasers are.

[22:02] <jnthn> Phasers are things that run at different times in your program.

[22:02] *** nadim_ left
[22:02] *** iblechbot left
[22:02] <jnthn> Rather than just the normal flow of execution.

[22:03] <jnthn> sorear: Think I have a fix for the BEGIN issue you filed in RT. :-)

[22:04] *** rv2733 joined
[22:05] <lue> rakudo: say $a; BEGIN { my $a = 4 }

[22:05] <p6eval> rakudo c4857a: OUTPUT«Symbol '$a' not predeclared in <anonymous>␤current instr.: 'perl6;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:108)␤»

[22:05] <lue> guess it doesn't work like that :)

[22:05] *** PacoLinux left
[22:08] <jnthn> No

[22:08] <jnthn> Plus BEGIN + outer lexicals = BOOM in Rakudo at the moment.

[22:09] <sorear> jnthn: I'll have to study your fix so I can port it to macros!

[22:10] <jnthn> ;-)

[22:10] <jnthn> sorear++ # hacking on scary hard fun stuff

[22:14] <sorear> have you seen what I've got already?

[22:19] <sorear> tribble, sibble?  I think I need some explanations here

[22:21] <jnthn> s///

[22:21] <jnthn> and tr///

[22:21] <jnthn> They're related to those.

[22:21] <jnthn> But actually I didn't really like that formulation so much so I did it in a simpler way in Rakudo.

[22:21] *** xinming left
[22:21] <jnthn> We may need to end up doing what STD does at some point.

[22:22] <jnthn> sorear: I haven't. I'm sorta preparing for a camping trip amongst writing easy-ish patches :)

[22:22] <lue> Isn't STD(-esque) our goal in the first place :)

[22:22] <jnthn> I will certainly look at it when I get back though.

[22:22] *** xinming joined
[22:22] <jnthn> lue: Well, it's a process of convergence rather than STD being unchangable gospel. :-)

[22:22] <jnthn> STD-esque though for sure.

[22:23] <jnthn> We may find there's a reason to do it the way STD has gone yet.

[22:23] <sorear> lue: In a few years, there will be one Perl 6 grammar, and it will be called STD

[22:23] <jnthn> And our formulation is pretty close.

[22:23] <dalek> rakudo: 2acc11d | jonathan++ | src/Perl6/Actions.pm:

[22:23] <dalek> rakudo: Fix problem with calling things in the setting from BEGIN blocks.

[22:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2acc11d3d5ecff7cedc34977be62180c584bfe60

[22:23] *** takadonet1 joined
[22:23] <sorear> it will have elements of current STD, current Rakudo, current Yapsi, and many things yet to be invented

[22:26] *** patrickas left
[22:27] <sorear> perl6.vim has ... trouble with STD

[22:27] *** kst left
[22:27] <lue> as <dalek> would say, "The Fiiinal ImplementaTION!"

[22:30] *** kst joined
[22:31] <sorear> jnthn: Can you please explain how your last patch works?

[22:31] <jnthn> Well, I drank beer and then the patch just happend...

[22:32] <jnthn> ;-)

[22:32] <jnthn> Basically though...there's a YOU_ARE_HERE term.

[22:32] <jnthn> We compile it down to some "magic" that installs a sub that knows how to install things within th elexical scope of the setting.

[22:33] <sorear> So, with that patch, BEGIN cannot be used inside the setting?

[22:33] <jnthn> So all the patch does is not run the BEGIN block, but instead call the "magic thing" and passes the block.

[22:33] <sorear> I see

[22:33] <jnthn> sorear: Erm. That..may well be the case.

[22:34] <jnthn> Welcome to the delightful world of bootstrapping.

[22:34] <sorear> :)

[22:34] <jnthn> Anyway, it makes BEGIN blocks rather more useful now. :-)

[22:35] *** patrickas joined
[22:37] <sorear> What does .blocktype('declaration') do?

[22:37] <jnthn> PAST supports two types of block

[22:38] <jnthn> Those that we run immediately

[22:38] <jnthn> And those that we don't

[22:38] <jnthn> So in

[22:38] <jnthn> say 42; { say 69; } say 100;

[22:38] <jnthn> The block is immediate.

[22:38] <jnthn> In 

[22:39] <jnthn> my $x = { say 99 };

[22:39] <jnthn> The block type is declaration.

[22:39] <jnthn> Just controls the code gen.

[22:39] <jnthn> I guess in a sense, immediate is sugar for a declaration and a call to it.

[22:39] <jnthn> But it's kinda useful to have.

[22:40] * sorear really ought to learn more PAST for this deep compiler hacking stuff

[22:41] <jnthn> I found it fairly easy to pick up.

[22:41] <jnthn> Mostly through using it. :-)

[22:41] *** chitragupt left
[22:42] *** stepnem left
[22:44] <sorear> Yeah, me too

[22:44] *** chitragupt joined
[22:45] <sorear> but I have a feeling I'm generating some excessive past sequences

[22:45] <jnthn> That's sometimes a sign that things need some kind of factoring out.

[22:46] <jnthn> It is generally quite verbose compared to the code it's describing, though.

[22:49] *** stepnem joined
[22:52] * lue has a flashback to snowman/comet whilst browsing unicode

[22:54] <colomon> snowman!

[22:55] <lue> that was such a wacky bug, it was almost worth letting in :)

[22:57] <jnthn> There will be modules.

[22:59] <sorear> Method 'set_outer' not found for invocant of class 'Perl6Sub'

[22:59] <sorear> I wonder what I did wrong

[22:59] <jnthn> Gave it a wrapped sub.

[22:59] <jnthn> Pass the .do of that to it.

[23:00] *** stepnem left
[23:01] <sorear> I'm currently passing it create_code_object($past, 'Sub', 0, $sig_setup_block)

[23:01] <sorear> What should I change that too?

[23:01] * sorear doesn't currently grok most of the $sig stuff

[23:01] <jnthn> Does the block have a signature?

[23:02] <lue> rakudo: my @a=(3,2); @a[2] := @a[0]; @a[2]=4; say @a[0]

[23:02] <p6eval> rakudo c4857a: OUTPUT«:= binding of variables not yet implemented␤current instr.: '&die' pc 17391 (src/builtins/Junction.pir:410)␤»

[23:02] <lue> .oO(grr...grr...)

[23:02] <jnthn> sorear: It's hard to give you a good answer without a little more context.

[23:02] <sorear> jnthn: macro foo { ... } causes anon sub ($/) { ... } to be generated at parse tme

[23:02] <sorear> this sub is then injected into Perl6::Actions

[23:03] <sorear> the parse time generation thing involved stealing a bit of code from BEGIN

[23:03] <jnthn> ah, ok

[23:03] <jnthn> try passing it

[23:04] <jnthn> PAST::Block.new( :hll($?RAKUDO_HLL), PAST::Op.new( :pasttype('call'), create_code(....) ))

[23:05] <sorear> How does that work?

[23:05] <sorear> (The code object takes a parameter)

[23:05] <jnthn> oh, the ... is meta

[23:06] <jnthn> I meant, but the call you already have there.

[23:06] <jnthn> Oh

[23:06] <jnthn> wait

[23:06] <jnthn> Hmm

[23:06] *** stepnem joined
[23:06] <jnthn> Yeah, that's a bit tricky.

[23:06] *** _jaldhar left
[23:06] <sorear> generally speaking, I think all the code I've written for generating a sub is completely wrong and only works by accident

[23:06] * jnthn thinks a bit

[23:07] <jnthn> How does it get injected into Perl6::Actions?

[23:07] <jnthn> add_method ?

[23:08] <jnthn> Maybe though

[23:08] <jnthn> PAST::Block.new( :hll($?RAKUDO_HLL), create_code(....) )

[23:08] <jnthn> If you pass that to the PAST::Compiler

[23:09] <jnthn> Then run what you get back

[23:09] <jnthn> You should in theory get a code object back that has been put into the correct lexical scope (that of the setting)

[23:09] <jnthn> And can install that

[23:09] <jnthn> Though it feels...weird. :-)

[23:09] <jnthn> But it may well work.

[23:10] <sorear> That's what I'm currently doing, but it's not landing in the right lexical scope.

[23:11] <sorear> What I have: $<blockoid>.ast

[23:11] <jnthn> Which is the "right one"?

[23:11] <sorear> The enclosing one.

[23:12] *** kst left
[23:12] <jnthn> Oh, enclosing in the program sense?

[23:12] <sorear> yes

[23:12] <sorear> in the simplest case, this will be SETTING

[23:12] *** kst joined
[23:12] <jnthn> Yeah, the problem is that at compile time, the runtime case of that scope doesn't yet exist.

[23:12] <jnthn> One of the limitations we have in present-day Rakudo.

[23:12] <jnthn> The setting is a good approximation

[23:13] <jnthn> And as good as we get for BEGIN blocks.

[23:13] *** rgrau left
[23:15] <dalek> rakudo: 7b1a064 | jonathan++ | src/Perl6/Compiler/Signature.pm:

[23:15] <dalek> rakudo: Fix placeholder paramters bug when the same placeholder parameter was mentioned twice in a block (was treated as two different parameters; now correctly as one).

[23:15] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7b1a0645879dffb666a995ba41cf5fe865e49b5f

[23:16] <sorear> jnthn: That approximation would still be better than what my current code does.

[23:16] <sorear> Macros are run with no outer lexical scope at all

[23:16] <jnthn> nod

[23:17] <jnthn> I think the suggestion I gave above (compile code that returns the block in the correct scope) should probably do it.

[23:17] <jnthn> As in, in the scope of the setting.

[23:18] <sorear> Your example seemed like it was going to call the block with no arguments?

[23:18] <jnthn> no, the later one

[23:18] <sorear> Which is correct for BEGIN

[23:18] <jnthn> rihgt, the first was wrong for you

[23:19] <jnthn> the second I gave after was better.

[23:19] <jnthn> PAST::Block.new( :hll($?RAKUDO_HLL), create_code(....) )

[23:19] <sorear> Your later one didn't mention !YOU_ARE_HERE, and was in fact identical to my existing version

[23:19] <jnthn> Oh, sorry

[23:19] <jnthn> I'm not being very clear.

[23:19] * jnthn tris again

[23:19] <jnthn> *tries

[23:20] *** patrickas left
[23:20] <sorear> Neither am I.

[23:20] <sorear> http://github.com/sorear/rakudo/blob/171309a260da64828ed908e85ff57981e93bd556/src/Perl6/Actions.pm#LID1126

[23:21] <jnthn> PAST::Block.new( :hll($?RAKUDO_HLL), PAST::Op.new( :pasttype('call'), :name('!YOU_ARE_HERE'), PAST::Block.new( :blocktype('declaration'), create_code(....) )))

[23:21] <sorear> *nod*

[23:21] <jnthn> Essentially I'm suggesting that you compile code that calls !YOU_ARE_HERE with something that will return your code object (what create_code produces)

[23:21] <jnthn> Kinda closure-like

[23:22] <jnthn> And that closure-ness hopefully will get the setting stuff right.

[23:27] * lue is very confused :)

[23:28] * jnthn hands lue a beer...it'll make it all clear :-)

[23:33] <sorear> syntax error at ../STD.pm line 1, near "but not "

[23:33] <sorear> hmm... I think this is stale. :)

[23:36] *** japhb left
[23:36] *** justatheory joined
[23:44] * jnthn gets the $x.SomeRole::methodname(...) syntax working

[23:45] <jnthn> (worked for only SomeClass before)

[23:45] <jnthn> Finally I can stop giving talks saying "one day you'll be able to..." :-)

[23:45] * jnthn has shown that syntax a few times before and then had to add "but NYI"

[23:46] <sorear> use macros?

[23:46] <sorear> ah

[23:46] <sorear> what does SomeRole::methodname do?

[23:46] <jnthn> sorear: The usual use case is that you have a collision of methods from two roles and you want to write a method that calls the method from a particular role

[23:46] <jnthn> Then you can put in your class something like

[23:47] <jnthn> method foo() { self.TheRoleThatIPrefer::foo() }

[23:47] <sorear> mm, not at all like the Moose way of handling that

[23:48] <jnthn> Well, Moose <-> Perl 6 ain't a one-to-one mapping :-)

[23:49] <sorear> no

[23:49] <sorear> Moose is my gateway drug though

[23:49] <sorear> > macro term:<foo> { ~rand }

[23:49] <sorear> > sub moo { say foo; }; moo; moo;

[23:49] <sorear> 1.39539001596827

[23:49] <jnthn> :-)

[23:50] <jnthn> \o/

[23:52] <snarkyboojum> sorear++

[23:52] <snarkyboojum> jnthn++

[23:52] <snarkyboojum> :)

[23:52] <snarkyboojum> programming-machines++

[23:54] *** kst left
[23:55] *** kst joined
[23:57] *** ethel left
[23:58] * sorear tries to figure out what's in lex/

