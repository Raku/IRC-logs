[00:00] <TimToady> everyone agrees that parrot is slow :)

[00:00] <lue> and that any speed issues are amplified on my piece of 20th century history :)

[00:01] <TimToady> you think you've got problems, I've got an Amiga 1000

[00:01] <TimToady> still runs, too

[00:02] <lue> you're not using it right now, are you?

[00:02] <TimToady> nope

[00:02] <lue> .oO(poor Larry :) )

[00:04] <lue> what would the regex be for filtering out all but dna bases? (ACTG)

[00:05] *** felipe joined
[00:05] <TimToady> .comb(/<[ACTG]>/.join or maybe .trans('ACTG' => 'ACTG', :d), but that's probably not implemented

[00:06] <TimToady> rakudo: say "I WANT A CAREER IN ACTING!!!".comb(/<[ACTG]>/).join

[00:06] <p6eval> rakudo 1eef08: OUTPUT«ATACAACTG␤»

[00:06] <TimToady> rakudo: say "I WANT A CAREER IN ACTING!!!".trans('ACTG' => 'ACTG', :d)

[00:07] <p6eval> rakudo 1eef08: OUTPUT«too few positional arguments: 2 passed, 3 (or more) expected␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[00:07] <lue> TimToady++

[00:07] <TimToady> hmm

[00:07] <lue> (S05 isn't exactly clear on the basic regex stuff)

[00:07] <lue> (from what I skimmed)

[00:07] <TimToady> don't think it knows :d

[00:09] <TimToady> rakudo: say "I WANT A CAREER IN ACTING!!!".trans('ACTG' => 'ACTG', '\0..\x1ffff' => '')

[00:09] <p6eval> rakudo 1eef08: OUTPUT«Attributes of type 'INTVAL *' cannot be subclassed from a high-level PMC.␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[00:09] <TimToady> cool

[00:12] *** SmokeMachine joined
[00:12] <BrowserUk> TimToady: Can I read more about "p6's model is that everything outside the lexical scope of the async {} is shared, and everything inside isn't" somewhere?

[00:15] <TimToady> not really, but it's the design direction we've been moving for years

[00:15] <TimToady> why we don't like localized globals anymore, for instance

[00:16] <TimToady> and why most of the dispatching we do is now lexical rather than via packages

[00:16] *** muixirt left
[00:16] <lisppaste3> lue pasted "DNA to Hex (Halp!)" at http://paste.lisp.org/display/98853

[00:16] <TimToady> so it's kinda threaded (sorry) throughout the various synopses

[00:17] <TimToady> basically, there are are very few globals left in Perl 6

[00:17] <lue> It just won't work (problem explained in the nopaste)

[00:18] <TimToady> it's also implicit in the notions of feed operators behaving a lot like Unix pipes

[00:18] <TimToady> which is more of an Erlangish notion of threading

[00:19] <TimToady> as for synchronizing stuff outside of async, there's rudimentary docs on STM somewhere out there, hmm

[00:19] <lue> I think it could be a stupid overflow error :(  (http://paste.lisp.org/display/98853)

[00:19] <TimToady> we'd like to go lockless as much possible

[00:20] <TimToady> some of these ideas are sketched in S17

[00:21] <BrowserUk> Okay. Sounds interesting. Time I re-read the synopses again. Is that STM doc P6 related? (I looking for keyowrds to search on)

[00:21] <TimToady> look for Contend/Maybe/Defer in S17

[00:21] * [Coke] tries not to take it personall.

[00:21] <[Coke]> *y

[00:22] <lue> rakudo: say :16<7fffffff>

[00:22] <p6eval> rakudo 1eef08: OUTPUT«2147483647␤»

[00:22] <lue> rakudo: say :16<7fffffff>.fmt('%b')

[00:22] <p6eval> rakudo 1eef08: OUTPUT«1111111111111111111111111111111␤»

[00:22] <BrowserUk> Okay, thanks.

[00:23] <lue> Even with a 64-bit computer (which I ssh to), it seems I won't be getting to "decode" large strings of DNA _that_ easily :/

[00:26] * TimToady tries to envision what taking it impersonally would mean...

[00:29] * ruoso .oO( while STM is mentioned in docs... most of the threading and data-sharing model is undefined... )

[00:29] <TimToady> .oO(I used the word "sketch" on purpose)

[00:30] <sjohnson> .oO(I wonder if this does anything on some remote site?)

[00:31] <ruoso> one Idea I once considered was wiring Perl 6 around Postgresql MVCC to implement STM

[00:32] <ruoso> it kinda sucks when running just one core... but will rock when used in 60 cores

[00:33] <lue> anything would rock in 60 cores :)

[00:33] <TimToady> if only that were so

[00:33] *** lest_away is now known as lestrrat

[00:34] <TimToady> but maybe the definition of "rock" varies

[00:34] <sjohnson> megathreated apps

[00:34] <sjohnson> apparently new budget-conscious 6 core cpus from AMD are "ya get what you pay for" CPUs

[00:35] <ruoso> the news are even more interesting...

[00:35] <ruoso> I've recently saw that we're about to see servers with arrays of arm processors

[00:36] <lue> .oO(I bet they only cost a leg :) )

[00:36] <TimToady> yes, but the interest rate goes way up in 5 years

[00:38] <ruoso> the hard part on STM is getting the semantics straight...

[00:38] <lue> why does @out.push(:4($temp).fmt('%x')); fail? ($temp being a 4-digit string, i.e. "0132")

[00:38] <lue> All i get is []

[00:38] <ruoso> when to begin and commit a transaction...

[00:38] <TimToady> ruoso: the hard part is defining what you mean by "software", "transaction", and "memory".

[00:38] <ruoso> heh

[00:40] <lue> rakudo: my @out=(); my $temp="1103"; @out.push(:4($temp).fmt('%x')); say @out;

[00:40] <p6eval> rakudo 1eef08: OUTPUT«53␤»

[00:40] <lue> *sigh* failure on my end :/

[00:40] <TimToady> shell quoting?

[00:41] <lue> no, it's in a .p6 file.

[00:41] <lue> should I nopaste it?

[00:41] <TimToady> quail shooting?

[00:41] <TimToady> yes, as long as you don't ask for permission first

[00:42] *** jonrafkind left
[00:42] <lisppaste3> lue annotated #98853 "New version" at http://paste.lisp.org/display/98853#1

[00:43] <lue> there you are. What could be going wrong?

[00:44] <lue> (the last line in the loop is just a debugging command)

[00:44] <lue> ... I probably used substr() incorrectly :/

[00:45] <TimToady> your >= should be <=

[00:45] <lue> oh. I defined when to stop. :P

[00:45] <TimToady> why not just use the list returned by comb 4 values at a time?

[00:46] <TimToady> use of loop() is usually a smell

[00:46] <lue> comb returns a list? :)

[00:46] <TimToady> why did you put the .join :)

[00:46] <lue> I changed it, and got a redeclaration of $i err.

[00:47] <lue> I copied off of masak, and that part was not explained. :)

[00:47] <TimToady> try putting spaces around your infix operators too.  $i<= is going to misparse

[00:48] <lue> ah.

[00:49] <BrowserUk> My concerns about STM are: 1) The process of chasing out everything called indirectly from within a contend block to ensure it is undoable; is impossibly costly for an interpreter. 2) With fat internal structures, even reading a scalar can change it's state:  $x =  '1 ffff'; if( $x == 0 ){...} Now $x has changed. How do you undo that?

[00:49] * lue tries to find a clever way to pull 4 values of a list at a time w/o loops

[00:51] *** rgrau_ left
[00:51] <TimToady> BrowserUk: wrt 1, yes, STM implies global state change tracking.  It also is something of a toy, so far, so we're adopting a wait-and-see attitude towards it

[00:51] <TimToady> mostly we're trying to get rid of most of the obvious need for locks in the first place through adequate scoping primitives

[00:52] <lichtkind> TimToady: can you give a metaop the op by an variable?

[00:52] <TimToady> re 2, that's another thing that is a bit different in p6

[00:52] <TimToady> a value is allowed to cache a coercion like that, but it is not supposed to change its fundamental type or value

[00:53] <TimToady> lichtkind: no, use the corresponding functional interface for that sort of thing

[00:53] * lue wonders...

[00:53] <TimToady> reduce, crosswith, etc

[00:53] <lichtkind> ah thanks

[00:54] <ruoso> BrowserUk, as I see it, it's a all-or-nothing... the STM will only work as far as the memory is managed by it... it might intentionally repeat side-effects of things outside STM boundaries

[00:54] <lue> rakudo: my @a = (1,10,34); say ([.fmt('%x')] @a)

[00:54] <p6eval> rakudo 1eef08: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[00:54] <lue> rakudo: my @a = (1,10,34); say [.fmt('%x')] @a

[00:54] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "say [.fmt("␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[00:54] <TimToady> all we can say right now is that, if we adopt STM, we think we know what main syntax is.  :)

[00:54] <TimToady> but it's far from being mandated for 6.0

[00:55] <TimToady> the currently specced syntax was, however, prototyped in pugs, and seems to work right

[00:56] <ruoso> but we might have very small boundaries for more low-level operations in order to provide lock-free access to data

[00:56] * sorear discovers Perl6::Compiler.compile("foo", :parsetrace)

[00:56] <ruoso> STM-begin-commit-boundaries, I mean

[00:56] <sorear> There will be TIMTOWDI.  STM is not a panacea

[00:56] <ruoso> sure sure sure....

[00:57] <ruoso> but the question of "how do you share data" is still in the table

[00:57] <TimToady> lue: metaops may only have literal operator names, not random code

[00:57] <TimToady> and whenever you get "Confused" from rakudo, STD is likely to give you a more specific error

[00:57] <TimToady> std: my @a = (1,10,34); say [.fmt('%x')] @a

[00:57] <p6eval> std 30559: OUTPUT«[31m===[0mSORRY![31m===[0m␤Method call found where infix expected (omit whitespace?) at /tmp/TO8LydnsBr line 1:␤------> [32mmy @a = (1,10,34); say [[33m⏏[31m.fmt('%x')] @a[0m␤    expecting any of:␤  bracketed infix␤  infix or meta-infix␤Parse failed␤FAILED 00:01 111m␤»

[00:58] <TimToady> which may or may not be a correct error :)

[00:58] <sorear> also, ./perl6 --trace -e '2+2'

[00:59] <TimToady> std: my @a = (1,10,34); say [ .fmt('%x') ] @a

[00:59] <sorear> I wonder how many other undocumented options there are

[00:59] <p6eval> std 30559: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/gpWW7FSsZ8 line 1:␤------> [32mmy @a = (1,10,34); say [ .fmt('%x') ] [33m⏏[31m@a[0m␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤      statement modifier

[00:59] <p6eval> ..loop␤Parse fa…

[00:59] <TimToady> that's the error I expected to get :)

[00:59] <lue> Yeah. I wanted the power of metaops with the function I wanted :/

[00:59] <lue> maybe 6.1, if nothing else ?

[00:59] <TimToady> as I *just* got through telling lichtkind++, use the functional form for that

[00:59] <BrowserUk> TimToady: I'm wary of what pugs could do, because of the deep analysis power of GHC. Can't quite see fitting that into an interpreter.

[00:59] <ruoso> rakudo: my @a = (1,10,34; say @a.reduce({ .fmt('%x') })

[00:59] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "my @a = (1"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[01:00] <ruoso> rakudo: my @a = (1,10,34); say @a.reduce({ .fmt('%x') })

[01:00] <p6eval> rakudo 1eef08:  ( no output )

[01:00] <TimToady> BrowserUk: indeed, which is why we're holding back on anything resembling a mandate there

[01:00] <ruoso> rakudo: my @a = (1,10,34); say @a.reduce({ $^a.fmt('%x') })

[01:00] <p6eval> rakudo 1eef08:  ( no output )

[01:01] <lichtkind> hej i got ++ :)

[01:01] <lichtkind> TimToady: i see no table for these methods can you just tell me them once so I make such table

[01:02] <BrowserUk> TimToady: Okay. I'll keep reading and keep an open mind :) 

[01:03] <BrowserUk> I kinda wanna say: "There's a better way", but believing it and proving it are quite different things.

[01:03] *** bbkr_ joined
[01:04] <TimToady> [op] is reduce(), Xop is crosswith, Zop is zipwith.  We haven't defined functional forms for all the others, but I imagine we will

[01:05] *** SmokeMachine left
[01:06] <TimToady> BrowserUk: if it's your hot button, you're welcome to contribute to the design, since obviously what we have so far is somewhat ramshackle on that front.

[01:06] <lichtkind> TimToady: have we one for [\ ] ?

[01:06] <TimToady> you'd have to ask colomon that one, I think

[01:06] <TimToady> vague recollection that he called it triangle()

[01:08] <lichtkind> colomon: really triangle?

[01:09] <lue> yeah, i've heard [\ ] being called triangle.

[01:09] <lichtkind> have we a hyper method?

[01:09] <BrowserUk> ruoso: I know continuations are supposed to be able to allow fast return to earlier states--though I wonder about the memory costs for storage. But STM that allows (undoable) externals side-effects are dangerous. And I'm really non-plussed by how you implement Global State Tracking. 

[01:10] <TimToady> negation is a bit strange in that $a !op $b wants to turn into not($a op $b), so !op is more like * !op * anti-currying

[01:10] <TimToady> function composition, really

[01:10] <TimToady> and we have all the hyper variants too.  don't know what those are called inside rakudo currently

[01:10] <BrowserUk> Do you try to catch potentially side-effectful transactions at compile time? Or bug out and die at runtime? 

[01:10] <TimToady> or if they even have function names

[01:11] <TimToady> the hypers might still be hardwired and non-extensible

[01:11] <TimToady> BrowserUk: we'd like to have some clue about what has side effects at compile time, though certainly not in a Haskellian sense

[01:11] <lichtkind> TimToady: what you said so far is now in http://www.perlfoundation.org/perl6/index.cgi?perl_6_lookup_tablet#metaoperators

[01:12] <sorear> BrowserUk: do you understand what it means for concurrency to not be on this month's agenda?

[01:12] <TimToady> after all, we can't determine "Useless use of" messages without knowing what is pure

[01:12] <TimToady> sorear: it's okay, we need someone to champion this area, so please try not to scare my BrowserUk away. :)

[01:13] <TimToady> unless you wanna do it?  :)

[01:13] <BrowserUk> sorear: If that means shut up. Sure thing. Bye

[01:13] *** BrowserUk left
[01:13] <sorear> ...wow

[01:15] <TimToady> yes, well, most of the threads on Perl Monks that are deeper than 30 will have him as one of its sides :)

[01:15] <TimToady> but what you said did come across as rather snippy

[01:15] * snarkyboojum thinks BrowserUk needs a hug

[01:16] <sorear> I don't like it when people proactively whine

[01:16] <TimToady> I like it when people care

[01:16] <lue> hugme: hug BrowserUk

[01:16] * hugme hugs BrowserUk

[01:17] <sorear> what's the point of <terminator>?

[01:17] <lue> rakudo: say chr(64)

[01:17] <p6eval> rakudo 1eef08: OUTPUT«@␤»

[01:17] <lue> rakudo: say chr( :4<10> )

[01:17] <p6eval> rakudo 1eef08: OUTPUT«␤»

[01:17] <TimToady> the point is to be an extensible set in subgrammars

[01:18] <lichtkind> slice() is alias to @@ ?

[01:18] <TimToady> though the interplay of <terminator>, <stopper> and $*GOAL is a bit more complicated than strictly necessary

[01:18] <sorear> I'm playing around with one of masak's bugs

[01:18] <sorear> he's defined a macro named ]

[01:18] * snarkyboojum just stumbled across http://www.ozonehouse.com/mark/periodic/ again - not completely up to date but *beautiful* :)

[01:18] <sorear> term:<]>

[01:19] <sorear> now, 'say ]'

[01:19] <TimToady> terminators take precedence over infixes

[01:19] <TimToady> or terms

[01:19] <sorear> the parser matches ] as <terminator>, closes the arglist, then dies

[01:19] <TimToady> that is, they ignore LTM considerations

[01:19] <sorear> What is the justification for this?

[01:19] <sorear> Also, is anyone else going after BrowserUk

[01:19] <sorear> ?

[01:20] <TimToady> too lazy to calculate all the follow sets :)

[01:20] <TimToady> and a sneaking suspicion that anyone who defines operators starting with terminators is really Asking For It already

[01:21] <TimToady> sorear: no point in chasing BrowserUk, I think

[01:22] <lue> methinks chasing someone virtually is a bit difficult.

[01:23] <TimToady> he likes to argue, and really believes his signature of "Silence betokens consent", though occasionally it seems like it reduces to "I always get last word".  Hence the "deep" discussions on PM.

[01:23] <TimToady> but generally he's quite cogent, if a curmudgeon.

[01:23] <lue> snipperwhapper!

[01:24] <TimToady> Get onto my lawn!!!

[01:24] <lue> Bless those meddling kids!

[01:25] <TimToady> sorear: despite my comments earlier, I'm not all that eager to sweep all of the p5 community into p6 as soon as possible.  :)

[01:26] <TimToady> in fact, Camelia is specifically designed to keep some of them out...

[01:26] <sorear> Hah.

[01:26] <lue> how do I write to a (text) file? the whole IO mess in the spec isn't that helpful...

[01:26] <sorear> lue: spew

[01:26] <sorear> TimToady: Why have terminators at all?  Why isn't $?GOAL enough?

[01:26] <TimToady> $*HANDLE.print should work

[01:27] <TimToady> $*GOAL is only a literal string currently

[01:27] <TimToady> <stopper> is only the goal for the innermost slang that is actually derived, and is sometimes not a literal string

[01:28] <TimToady> <terminator> is the larger set of things we should probably stop on

[01:28] <TimToady> not because the current language is specifically looking for it, but because the presence of one of them almost certainly indicates a syntax error

[01:28] <lue> spew isn't in the spec :/

[01:29] *** isBEKaml left
[01:29] <TimToady> it was a joke

[01:29] <TimToady> use print

[01:29] <TimToady> as I said above

[01:30] <lue> it certainly would make sense though :)

[01:30] *** bbkr_ left
[01:30] <TimToady> for instance, $$ is always a valid terminator even when you're looking for ]

[01:30] *** wknight8111 left
[01:30] <snarkyboojum> lue: I've seen spew() implemented in one of masak's projects somewhere I think :)

[01:31] <TimToady> valid in the sense of stopping any further progress, at least

[01:31] <TimToady> you generally don't want to parse past EOF  :)

[01:31] <TimToady> well, you might if you're writing malware, I suppose...

[01:31] <lue> bleh. How doth I use $*HANDLE? (google search of spec isn't being very nice :/)

[01:32] <TimToady> please be more specific than "use"

[01:32] <lue> well, how do I create a file to write to? That's what I want to do.

[01:33] <lue> (I'd prefer binary file IO, but it is NYI)

[01:33] <TimToady> my $handle = open($filename, :w); $handle.print: @stuff

[01:33] <sorear> I was under the impression that spew was the opposite of slurp

[01:33] <TimToady> well, in real life it is...

[01:33] <TimToady> but print is already a spewer

[01:35] <TimToady> also, spew is perhaps a bit too colorful for people with sensitive stomachs...

[01:36] <TimToady> slurp is only culturally disgusting, not viscerally

[01:36] <lue> or we can define its palindrome: pruls()

[01:37] <TimToady> N.B. yes, there are varieties of spew that are not, strictly speaking, vomit

[01:38] <TimToady> we might also end up with @stuff ==> qp/file/ doing the right thing, in an ingyesque sense

[01:39] <sorear> rakudo: my regex foo { <[a-l]> }

[01:39] <p6eval> rakudo 1eef08: OUTPUT«Obsolete use of hyphen in enumerated character class;in Perl 6 please use .. instead at line 11, near "l]> }"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[01:39] <sorear> rakudo: my regex foo { <[a..l]> }

[01:39] <p6eval> rakudo 1eef08:  ( no output )

[01:40] * lue is now off to "decode" some DNA! :)

[01:43] *** agentzh joined
[01:46] <dalek> rakudo: 6e98d29 | (Solomon Foster)++ | src/core/operators.pm:

[01:46] <dalek> rakudo: Refactor infix:<...> a bit and make it handle some edge cases in the non-numerical world.

[01:46] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/6e98d2982ba41b55c3a88346908be07cfad411a9

[01:49] *** rv2733 left
[01:49] *** snarkyboojum left
[01:59] <diakopter> is it safe to peer out yet?

[01:59] *** kst left
[01:59] *** Psyche^ joined
[02:00] *** kst joined
[02:00] <lue> what do you mean by that?

[02:00] <diakopter> there seemed to be a scuffle earlier

[02:00] <lue> oh, that.

[02:02] <lue> I think the butterfly said stop.

[02:03] *** Patterner left
[02:03] *** Psyche^ is now known as Patterner

[02:06] <s1n> 0../-985

[02:07] <s1n> oops, sorry

[02:08] *** Heame joined
[02:11] *** plobsing joined
[02:12] <lue> woah. genes DQ831955 and DQ831956 (which are closely related to one another) both have this bit in their sequence: SAMÆ

[02:13] <lue> reads like "SAME". That's weird, because (bar a couple of characters at the end) the unicode "translation" of those two genes _are the exact same_

[02:21] *** justatheory joined
[02:26] *** am0c joined
[02:29] <lue> afk

[02:35] *** patspam left
[02:40] *** dduncan joined
[02:41] *** cdarroch left
[02:42] <dduncan> question - is it possible in Perl 6 to create and use an object ostensibly of some class Foo without declaring the Foo class?

[02:42] <dduncan> for example, could I say something like $x = Foo.new( a => 5, b => 7) and have it just work?

[02:43] <dduncan> assuming that the behaviour is similar to as if $x then held a hash, but it had metadata indicating Foo?

[02:44] <dduncan> basically, how far one could go using Perl 6 for structured data without declaring any user-defined classes

[02:46] <diakopter> C# calls those anonymous types; I don't know about Perl 6.

[02:46] <dduncan> yes, I had also been wondering what the terminology was for these things

[02:47] <dduncan> such as whether this is the same as typeless objects or not

[02:48] <diakopter> I mean, it's not much different from a hash literal, but differs by how the members are accessed... whether the object responds to ^members or to .keys I guess

[02:49] <dduncan> what I was hoping to be able to have is something that has semantics like a hash literal, in that you could just have named elements that are not coerced in anyway, and you could also say .WHAT or something on it and get the class name you specified with your new(), but that the class doesn't have to be defined anywhere, almost like the class name was a trait

[02:50] <dduncan> and then therefore the role of classes is somewhat demoted to existing more for the purpose of applying constraints rather than being an enabler of functionality

[02:50] <diakopter> if 'Foo' is in the source code anyway, why not predeclare it

[02:51] <diakopter> oh, you're wanting it inferred/autodeclared

[02:51] <dduncan> one idea is to be able to have arbitrarily complex values and move them between different environments that may not have all of the same classes

[02:52] <dduncan> such as moving data in a communications channel between different programs

[02:52] <diakopter> these environments are on the same process? or will use some kind of serialization?

[02:52] <dduncan> they could be different processes ...

[02:53] <dduncan> my main point is it would be nice to have arbitrarily complex data that can be understood fully without any context provided by class definitions ...

[02:53] <diakopter> yaml would be the thing for that, since it supports cyclical references

[02:53] <dduncan> and I'm thinking of it being more abstract than a simple serialization format

[02:53] <diakopter> but Perl 6 doesn't specify how to serialize object initializers

[02:53] <diakopter> afaik.

[02:54] <diakopter> my point when mentioning yaml is that you've got to have something that handles cyclical/nested references

[02:54] <diakopter> and you'll have to have something *like* yaml to do that

[02:54] <dduncan> one use case is say one could define code for using a type, and it just works, and then later one could declare the class and the code continues to have the same behaviour, and all the class addition added essentially was constraints

[02:55] <lichtkind> good night

[02:55] <dduncan> so in this case we're all just within a single program

[02:55] *** lichtkind left
[02:55] <dduncan> essentially, make objects not depend on classes, but having classes can enhance objects that otherwise don't depend on them

[02:56] <dduncan> I'm also working under the assumption that all relevant routines are not methods

[02:56] * diakopter wants a more precise use case

[02:56] <dduncan> anyway, this is more of a mental exercise, I don't really need it answered

[02:57] <diakopter> dduncan: how's muldisd

[02:57] *** Tolkien joined
[02:57] <dduncan> I'm almost at a major milestone

[02:57] * diakopter reads the Changes file and gasps

[02:58] <dduncan> true, the Changes is verbose, but I'll be truncating it when the language is more stable

[02:59] <dduncan> I find Changes useful to go back and find out when and how I changed things

[03:00] <dduncan> diakopter, as you might guess, my question related partly on how I describe how Muldis D works, and it makes sense to phrase the question in terms of Perl 6 because I try to make them alike in many ways

[03:01] *** Heame left
[03:01] *** JimmyZ joined
[03:10] *** Tolkien left
[03:14] *** kst left
[03:16] *** kst joined
[03:20] *** JimmyZ_ joined
[03:22] *** patspam joined
[03:22] *** JimmyZ left
[03:22] *** JimmyZ_ is now known as JimmyZ

[03:23] <TimToady> dduncan: anonymous classes are perfectly fine in Perl 6, though rakudo might not be quite there yet

[03:24] <dduncan> thank you

[03:24] <colomon> Something like  my $a = class { ... }

[03:24] <colomon> ?

[03:24] <TimToady> std: my $a = class { ... };

[03:24] <p6eval> std 30559: OUTPUT«ok 00:01 110m␤»

[03:25] <TimToady> rakudo: my $a = class { method foo { say "howdy"; } }; say $a.new.foo

[03:25] <colomon> \o/

[03:25] <p6eval> rakudo 1eef08: OUTPUT«howdy␤1␤»

[03:25] <colomon> rakudo++

[03:25] <TimToady> looks pretty anonymous to me

[03:26] <pugssvn> r30560 | colomon++ | [t/spec] Additional series tests. 

[03:27] <pugssvn> r30561 | colomon++ | [t/spec] Unfudge log tests in real-bridge.t. 

[03:28] <dduncan> FYI, here's a hello-world type example, completely to spec v0.125.0 in 2 hours: http://darrenduncan.net/Muldis-DB/scraps-not-in-repo/Muldis_D_code_samples.txt

[03:28] <dduncan> anything that looks like Perl 6 generally has the same meaning

[03:29] <dalek> rakudo: 9709f85 | (Solomon Foster)++ | src/core/ (4 files):

[03:29] <dalek> rakudo: Rename the default $base versions of .log to .log-e and then create a simple .log with $base method that simply calls .log-e twice.

[03:29] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/9709f855ed2cbc7df829c5bf25b9a299982f1a7c

[03:30] <diakopter> dduncan: I thought you were looking for a way to create objects *without* declaring a "class", anonymous or otherwise.

[03:30] <diakopter> (and then add behavior to the objects "later")

[03:30] <TimToady> can always mix in roles too

[03:30] <dduncan> by behaviour I mainly meant constraints

[03:30] <TimToady> but that's really making an anonymous class underneath

[03:30] <dduncan> eg, you can write initially less strict code and then add strictures

[03:31] <dduncan> eg, declaring the class is like adding 'use strict' or 'use warnings', very loosely speaking ...

[03:31] <dduncan> or a better example ...

[03:31] <diakopter> None Dare Call It Uncompilable

[03:31] <dduncan> is write this initially in code:  my $x = Foo.new(...)

[03:32] <dduncan> and then later change it to: my Foo $x = Foo.new(...) for example

[03:32] <dduncan> er ...

[03:33] <TimToady> sounds like roles to me

[03:33] *** _jaldhar left
[03:33] <dduncan> actually, one context I'm thinking of is runtime changes

[03:33] *** _jaldhar joined
[03:34] <dduncan> eg, when you have a program that runs without stopping for months, and you want to change its code while it is running

[03:34] <TimToady> sounds more Erlangish

[03:34] <dduncan> that is the main context, analogous to a DBMS

[03:34] <dduncan> which could be up for years, but users keep changing the code at runtime

[03:35] <dduncan> which is what data-definition, changing tables or stored procedures etc at runtime is

[03:35] <dduncan> Muldis D copies a lot from Perl 6, but it is designed to run in such an environment

[03:35] <dduncan> part of the idea is that you could drop and add data types in terms of which your data is defined, without having to first delete and re-add your data

[03:36] <dduncan> the data can continue to exist in a defined state while the data types it was defined with don't exist or are mutating

[03:36] <dduncan> given all the runtime magic Perl 6 is capable of, I assumed I'd be able to implement Muldis D over it

[03:36] <TimToady> you sort of have to never forget type info though

[03:37] <dduncan> at the low level in Muldis D, the type name of data is actually in the data

[03:37] <dduncan> eg, pretend each actual value is like an array ref whose first element is a type name and whose second is a structure having its attribute values

[03:37] <dduncan> that detail can be optimized away, but conceptually it is that way

[03:38] <dduncan> and so the values still have their type names and attribute names physically attached to them

[03:38] <dduncan> and types serve more the role of constraints

[03:39] <dduncan> if the database field must hold a value of type Foo, then iff Foo is defined then it will ensure that the constraint is met, and if Foo isn't defined it will let anything in that is tagged as Foo

[03:39] <TimToady> progressive nominal typing, eh?

[03:40] <dduncan> I was wondering what the best terminology was to describe what I was doing?

[03:40] <dduncan> is "progressive nominal typing" a known term or did you make it up now as a description?

[03:40] *** alester joined
[03:40] <dduncan> can Google ...

[03:40] <TimToady> made it up

[03:40] <TimToady> sounds like you're moving from structural to nominal typing as types get GC'd

[03:41] <dduncan> perhaps ... have to look up exactly what those terms mean

[03:41] <dduncan> I have to finish up something quickly, back in maybe 30 min

[03:41] <TimToady> cioa

[03:41] <TimToady> *ciao

[03:42] * diakopter fights my last week self

[03:43] *** am0c left
[03:51] <dduncan> well, I just added this sentence to the spec ... can be changed later ...

[03:51] <dduncan> One might say that Muldis D is using I<progressive nominal typing>, where values in databases move between structural and nominal typing as user-defined types whose names match their declared types come in and out of existence or mutate.

[03:53] * sorear ponders the ecological niche of Perl 6 .trans

[03:54] <sorear> I always rationalized Perl 5 tr/// as a restricted form of regexes that could be compiled down to a 256-element lookup table

[03:55] *** chitragupt left
[03:56] <spinclad> with unicode one begins to want that table sparse

[03:57] *** chitragupt joined
[03:57] <TimToady> there are also aspects of LTM matching to it, potentially

[03:57] <TimToady> it's more like an alternation in some ways

[03:58] <sorear> Does ~~ have special syntactic cases or is it always just $rhs.ACCEPTS($lhs) ?

[03:58] *** patspam left
[03:59] <spinclad> if all the alts are one char long, which of them is longest?  more specific i'll buy though

[03:59] <TimToady> there is the potential of lhs's to be longer than one char

[04:00] <TimToady> in the list of pairs form

[04:00] <TimToady> also, what is a "character" these days?

[04:00] <spinclad> well, you know, thingy

[04:01] <spinclad> longer than one:  ah, yeah, that rings a distant bell in my forgettery

[04:02] <spinclad> 'fully composed whatzit'

[04:10] <diakopter> phenny: tell pmurias I got parametric type declarations working.  That is, they're compiled to fields/locals in the CIL. You can't use .new on them yet, tho.

[04:10] <phenny> diakopter: I'll pass that on when pmurias is around.

[04:11] <diakopter> perlesque: my List[int] $b; say(33254)

[04:11] <p6eval> perlesque: OUTPUT«33254␤»

[04:12] <spinclad> perlesque: my List[int] $l; $l = (2, 4, 7); say($l);

[04:12] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.ArgumentException: An element with the same key already exists in the dictionary.␤  at System.Collections.Generic.Dictionary`2[TKey,TValue].Add (.TKey key, .TValue value) [0x00000] in <filename unknown>:0 ␤  at

[04:12] <p6eval> ..Sprixel.PrototypeChain`2[TKey,TValue].AddH…

[04:13] <diakopter> heh, no

[04:13] <dalek> csmeta: r238 | diakopter++ | trunk/Sprixel/ (4 files):

[04:13] <dalek> csmeta: [perleque] parametric types.  yes.

[04:13] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=238

[04:13] <spinclad> perlesque: my List[int] $l; $l = List[int].new(2, 4, 7); say($l);

[04:13] <diakopter> perlesque won't have list literals

[04:13] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.ArgumentException: An element with the same key already exists in the dictionary.␤  at System.Collections.Generic.Dictionary`2[TKey,TValue].Add (.TKey key, .TValue value) [0x00000] in <filename unknown>:0 ␤  at

[04:13] <p6eval> ..Sprixel.PrototypeChain`2[TKey,TValue].AddH…

[04:13] <diakopter> as I said to pmurias, .new doesn't work yet

[04:14] <spinclad> perlesque: my List[int] $l; $l.push(2); say($l);

[04:14] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.MissingMethodException: Cannot find method push in Type␤  at TriAxis.RunSharp.TypeInfo.FindMethod (System.Type t, System.String name, TriAxis.RunSharp.Operand[] args, Boolean static) [0x00000] in <filename unknown>:0 ␤  at

[04:14] <p6eval> ..TriAxis.RunSharp.Operand.Invok…

[04:14] <diakopter> and it's not initialized.

[04:14] <diakopter> and it's Add in the CLR

[04:14] <spinclad> perlesque: my List[int] $l; $l.Empty; $l.Add(2); say($l);

[04:14] <diakopter> my List[int] $l; $l.Add(2); say($l);

[04:14] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.MissingMemberException: Cannot find property Empty in Type␤  at TriAxis.RunSharp.TypeInfo.FindProperty (System.Type t, System.String name, TriAxis.RunSharp.Operand[] indexes, Boolean static) [0x00000] in <filename unknown>:0 ␤  at

[04:14] <p6eval> ..TriAxis.RunSharp.Opera…

[04:14] <diakopter> what is this "Empty"

[04:15] *** chitragupt left
[04:15] <diakopter> for the billionth time, perlesque is not a Perl 6 implementation.  the types will not correspond _AT_ALL_

[04:15] <spinclad> make it Empty, so .isEmpty is True?

[04:15] <diakopter> just the syntax will correspond.

[04:15] <diakopter> esque

[04:15] *** chitragupt joined
[04:15] <diakopter> $l is a clr null reference, there.

[04:16] <spinclad> well, .Empty wouldn't be good Perl 6 either.  just guessing around here.

[04:16] <spinclad> perlesque: my List[int] $l; $l.Add(2); say($l);

[04:16] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.MissingMethodException: Cannot find method Add in Type␤  at TriAxis.RunSharp.TypeInfo.FindMethod (System.Type t, System.String name, TriAxis.RunSharp.Operand[] args, Boolean static) [0x00000] in <filename unknown>:0 ␤  at

[04:16] <p6eval> ..TriAxis.RunSharp.Operand.Invoke…

[04:16] <diakopter> ah, oh, oops.

[04:16] <diakopter> that's a screwup

[04:16] *** kst left
[04:16] <diakopter> by me

[04:17] <diakopter> pmurias won't like that

[04:17] <diakopter> :)

[04:17] <diakopter> so I'd better fix it

[04:17] *** kst joined
[04:18] <spinclad> perlesque: my List[List[int]] $l; say(3);

[04:19] <p6eval> perlesque: OUTPUT«3␤»

[04:19] <spinclad> :)

[04:19] <diakopter> perlesque: my Dictionary[string, P6Object] $l; say(3);

[04:19] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: Can't resolve type P6Object`1.␤»

[04:19] <diakopter> hrm

[04:19] <diakopter> oh

[04:19] <diakopter> perlesque: my Dictionary[string, P6object] $l; say(3);

[04:19] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: Can't resolve type P6object`1.␤»

[04:20] <diakopter> wheh

[04:20] <diakopter> perlesque: my Dictionary[string, Sprixel.Runtime.P6object] $l; say(3);

[04:20] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: Can't resolve type Sprixel`1.␤»

[04:20] <diakopter> hrm.

[04:20] <spinclad> perlesque: my int $i; my List[int] $li; my List[List[int]] $lli; $li.Add($i); $lli.Add($li)

[04:20] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.MissingMethodException: Cannot find method Add in Type␤  at TriAxis.RunSharp.TypeInfo.FindMethod (System.Type t, System.String name, TriAxis.RunSharp.Operand[] args, Boolean static) [0x00000] in <filename unknown>:0 ␤  at

[04:20] <p6eval> ..TriAxis.RunSharp.Operand.Invoke…

[04:21] <diakopter> it won't find Add ever, yet

[04:21] <diakopter> :(

[04:21] <diakopter> so, just the syntax is there :)

[04:21] <diakopter> bedtime

[04:21] <spinclad> sleep well, thanks for the toy

[04:23] <spinclad> .oO{ the toymaker is greatly offended that something he's poured countless lives into is called a mere 'toy' 

[04:23] <spinclad> }

[04:24] <spinclad> .oO{ the lad, cruelly unaware, just likes playing with it. }

[04:25] <spinclad> perlesque: my int $i; my List[int] $li; my List[List[int]] $lli; $lli.Add($i)

[04:25] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.MissingMethodException: Cannot find method Add in Type␤  at TriAxis.RunSharp.TypeInfo.FindMethod (System.Type t, System.String name, TriAxis.RunSharp.Operand[] args, Boolean static) [0x00000] in <filename unknown>:0 ␤  at

[04:25] <p6eval> ..TriAxis.RunSharp.Operand.Invoke…

[04:26] <spinclad> i presume if Add were found then this would be a typefail, while the previous two would pass.

[04:26] *** molaf joined
[04:28] *** sunnavy left
[04:29] *** meppl joined
[04:30] *** sunnavy joined
[04:33] * sorear wonders if it makes sense to have spectests for reasonable REPL behavior

[04:34] <s1n> is the REPL behavior in the spec? or is that implementation specific?

[04:35] *** patspam joined
[04:39] *** _jaldhar left
[04:39] * spinclad thinks it would be premature to mandate a REPL; an implementation might be a cross-compiler, say, with no interactive capabilities.

[04:39] *** _jaldhar joined
[04:39] *** cotto left
[04:39] <sorear> spinclad: standard options are always a possibility

[04:40] <s1n> i agree with spinclad, i think any repl behavior should be up to an implementation

[04:40] <spinclad> sure; one can spec, 'if you implement a REPL, it should work like this', and then have tests that are gated on that feature-test

[04:41] <TimToady> any implementation that can run a BEGIN can run a REPL

[04:41] <spinclad> if you spec, then spectests are yes

[04:41] *** cotto joined
[04:41] <TimToady> because the BEGIN runs on the compiler, not the cross-compiled runtime

[04:41] <sorear> The command line invocation syntax for the 'perl6' executable is specced

[04:41] <sorear> a repl seems less constraining than that

[04:41] <TimToady> a repl just needs an eval-me-now hook in the grammar after each complete statement

[04:42] <sorear> and the ability of the parser to work on-line ?

[04:43] <TimToady> STD currently allows for a .moreinput method, and it's closely related to that

[04:46] <TimToady> basically, you just assume that the match of $ on a line transition isn't necessarily the final answer, if .moreinput can add to the buffer

[04:47] <TimToady> this is untested, though, and I'm sure there are spots where the rest of the program would have to be tweaked to make it work

[04:48] <TimToady> also, one should have some way of backing out of a statement with a syntax error

[04:48] *** molaf left
[04:49] <spinclad> after some mistakes it's easier to start fresh..

[04:49] <TimToady> shure

[04:49] <TimToady> you mean like Perl 5?  :P

[04:50] <spinclad> having MONKEY_PATCHED the wrong thing badly

[04:50] <TimToady> yes, well, kill 9,$*PID is also a bit problematic

[04:51] <spinclad> relive and relearn

[04:52] <TimToady> the repl should save a log so you don't have to copy/paste the screen

[04:53] <spinclad> 'but this is a quality-of-implementation issue, and not in the language spec'

[04:53] <TimToady> well, the particular method call that calls an AST might be specced, since we need it for BEGIN and constant folding and such

[04:57] <spinclad> sure, that sounds core.  REPL features like DropMeInto$EDITOR are more CPAN-module level, and dribble files are useful enough to be in pretty much everyone's module, i expect.

[04:57] *** patspam left
[05:05] <dduncan> okay, so I uploaded 0.125.0 to PAUSE and it said it was indexed at 21:58, so hopefully the next search.cpan refresh in a half-hour will show it all HTMLized

[05:06] <sorear> interestingly, rakudo already has a place for after-statement-compiled hooks

[05:06] <sorear> a TimToadian REPL could be implemented without *too* much pain

[05:06] *** steinberg left
[05:06] <sorear> it would, however, involve cutting ourselves somewhat away from PCT

[05:09] *** kaare joined
[05:10] * sorear pines for protolexpads

[05:10] *** kaare is now known as Guest42448

[05:11] *** TimToady sets mode: +vvv buubot dalek hugme

[05:11] *** TimToady sets mode: +vv ilogger2 IRSeekBot

[05:11] *** TimToady sets mode: +vvv lisppaste3 p6eval phenny

[05:11] *** TimToady sets mode: +v pugssvn

[05:11] *** steinberg joined
[05:12] <plobsing> protolexpads?

[05:12] <sorear> aye

[05:13] <sorear> they're like regular lexpads but... prototypical

[05:13] <sorear> compile time constants live in them

[05:13] <sorear> as do the initial values of regular lexicals in some confusing corner cases

[05:14] *** TimToady sets mode: +oooo sorear [particle] [Coke] arnsholt

[05:14] *** TimToady sets mode: +oooo cognominal colomon frettled japhb

[05:14] *** TimToady sets mode: +oooo Juerd spinclad szabgab Tene

[05:14] *** TimToady sets mode: +o xinming_

[05:15] * sorear is currently implementing reducer macros for masak

[05:15] <sorear> I almost think reducer macros should have a different keyword

[05:16] <TimToady> you mean tree rewriters?

[05:16] <sorear> yes

[05:16] <sorear> category macro:  macro term:<foo> is parsed(rx:s{ <identifier> ** "," }) { # no arguments, but $/ and $<identifier> are valid here

[05:17] <TimToady> or possibly some system resembling syntactic categories

[05:17] <sorear> reducer macro:  macro infix:<~~> ($lhs, $rhs) { # $/ is not valid here, and we aren't involved in the parsing of the symbol

[05:17] *** chitragupt left
[05:18] *** masak joined
[05:18] <masak> good morning, #perl6.

[05:18] <phenny> masak: 05 May 19:04Z <sorear> tell masak - postfix: macros not working is not a bug, it turns out that operator-like macros need a completely different implementation and I haven't implemented it yet.  The ][ thing is troubling, though.

[05:18] <TimToady> in some sense they're already selected by taking ASTs as args

[05:18] <TimToady> but perhaps infix: is getting a bit stretched

[05:18] <sorear> TimToady: so... if there's a signature, tree rewriter, else parse extender?

[05:19] <sorear> masak: Update: TimToady says macro names shouldn't start with anything in <terminator> (], }, ))

[05:19] <TimToady> masak: arbitrary restriction because I'm mean :)

[05:19] *** chitragupt joined
[05:20] <masak> define "shouldn't" :)

[05:20] <masak> "it just won't work" or "you'll get an error"?

[05:20] <sorear> TimToady: expand "stretched"

[05:20] <TimToady> not sure merely having a sig is the distinguishing feature, but it might be enough, especially taken with types

[05:20] <TimToady> have to think about it some

[05:21] <sorear> masak: I could make it a fatal error easily enough.  Generally speaking, macros need a lot more awesome error power

[05:21] <TimToady> well, currently we really only have infix:sym<op> and infix:<op>

[05:21] <TimToady> maybe there are others

[05:21] <sorear> What else could we have?

[05:21] <sorear> Also, aren't :sym<op> and :<op> synonymous?

[05:21] <TimToady> dunno

[05:22] <TimToady> no, they aren't

[05:22] <TimToady> infix:sym<+> is the rule that parses the + symbol

[05:22] <TimToady> infix:<+> is the name of the operator

[05:22] <masak> phenny: tell szabgab that I don't know if we've touched on this before, but both .HOW and .WALK are 'internal' in some sense (thus their uppercaseness). use 'nextsame' in the normal case: http://gist.github.com/391806

[05:22] <phenny> masak: I'll pass that on when szabgab is around.

[05:22] <TimToady> so one is a regex, and the other is just a function

[05:23] <masak> phenny: tell szabgab and the fact that this wasn't obvious from the spec shows the need for a tutorial just like yours. :) szabgab++

[05:23] <phenny> masak: I'll pass that on when szabgab is around.

[05:23] <TimToady> infix:tree<+> is possible, maybe

[05:23] <TimToady> or some such

[05:23] <TimToady> infix:ast<+>

[05:24] <TimToady> it's probabably a feature to keep "infix" in there somehow

[05:26] <spinclad> infix:<+>:ast (and infix:<+>:sym) ?   keeps the 'infix:<+>' part together

[05:26] <TimToady> I've been trying to avoid double adverbial names so far...

[05:26] <spinclad> (but that perturbs things for R*, so not now?)

[05:27] *** Guest42448 is now known as kaare_

[05:27] <TimToady> though they are possible in theory

[05:27] <TimToady> well, and Foo:auth<>:ver<> is certainly double adverbial

[05:28] <TimToady> in some ways its easier for the <infix> multi dispatcher to just look for infix:sym though

[05:28] <TimToady> and the <+> is the least specific part of it

[05:28] <TimToady> s/least/most/

[05:28] <sorear> I'm afraid you've lost me.

[05:28] <sorear> How does multi dispatch enter into this at all?

[05:29] <TimToady> when you match <infix> it calls all the infix:sym* rules in some pecking order

[05:29] <TimToady> primarily defined by LTM

[05:29] <TimToady> as per recent clarification to S05

[05:29] <TimToady> it's a form of multi dispatch

[05:30] *** justatheory left
[05:30] <TimToady> so the <op> part "varies most rapidly" from that viewpoint

[05:31] <sorear> what about :ast and tree and so on?

[05:31] <spinclad> a double adverb (in either order) makes a bit more sense to me:  a :sym or :ast adverb with a value of <+> doesn't say the same as :name<+> (with 'name' blank) which could better be invariant...

[05:31] <TimToady> well, it seems like the operator itself is the most commonly used one, so the that has the null key on the pair.

[05:32] <TimToady> having a key of "sym" or "ast" is just a differently keyed pair

[05:32] <sorear> what does infix:ast<+> mean and what namespace does it live in?

[05:33] <TimToady> it's just a name that cannot be confused with either the operator or the parse rule

[05:33] <TimToady> what namespace it lives in depends on its declarators

[05:33] *** chitragupt left
[05:33] <spinclad> (yes, null key is what i meant by "with 'name' blank")

[05:33] <TimToady> it doesn't install anything special in the current grammar like infix:<op> does

[05:34] <sorear> ah, so you're thinking that, instead of macro infix:<+>, I should write macro infix:sym<+> or macro infix:ast<+> ?

[05:34] <TimToady> on that level, it's just a name that the reducer knows to look for

[05:34] *** chitragupt joined
[05:34] <TimToady> maybe

[05:35] <TimToady> earlier I was suggesting that macro is really more of a scope declarator

[05:35] <TimToady> so you might even write macro regex infix:sym<+>

[05:35] <TimToady> and it would put it into the current grammar

[05:35] <TimToady> that is, it would go in the 'my' slot

[05:36] <TimToady> the word 'macro' would go where 'my' currently goes, that is

[05:36] <TimToady> since its scope is really the current grammar, which is lexically scope at run time but really dynamically scoped at compile time

[05:37] <TimToady> but have to think through the ramifications of such a change

[05:37] <TimToady> esp in terms of exportable macros

[05:37] *** gfx joined
[05:39] <TimToady> anyway, the idea is to put it somewhere with a unique name/location that the normal reducer can find it

[05:39] <TimToady> without having to paw through a bunch of unrelated named, hopefully

[05:39] * masak makes a second attempt at the Russian consulate

[05:39] *** masak left
[05:40] <TimToady> if the name to call can be generated directly from the node in question, then we can just call it without reflection

[05:40] <TimToady> so the reducecheck for infix:sym<op> could always just be infix:ast<op>, instead of setting it explicitly in the :sym

[05:41] <TimToady> dunno how well that generalizes outside the operator precedence parser though

[05:41] <sorear> outside the operator precedence parser, macro actions run at reduce time

[05:41] <TimToady> current reducecheck mechanism could conceivable take anonymous routines

[05:41] <TimToady> but forcing a name works against that

[05:42] <sorear> there is no conflict between reducer macros and parser macros for statement:, because they run at the same time with the same arguments

[05:42] *** iblechbot joined
[05:42] <TimToady> well, but reducecheck is really only needed for opp, since other reductions are done right at the time the rule reduces

[05:42] <sorear> you seem to be talking about two distinct solutions at the same time

[05:42] <TimToady> I always talk about many solutions at the same time :)

[05:42] <sorear> one involving :sym and :ast, the other involving macro sub and macro regex

[05:43] <TimToady> those are really independent choices on some level

[05:43] <sorear> three, if you count the signature version

[05:43] <sorear> independant, how so?

[05:43] <sorear> what does macro regex infix:ast<+> { } mean?

[05:44] <TimToady> both the :sym and the :ast rule would live in the same grammar class, I suspect

[05:44] <TimToady> so 'macro regex infix:sym<op>' is the parser, but could also be 'macro method infix:sym<op>'

[05:45] <TimToady> since regexes are really just methods in disguise

[05:45] <TimToady> the :ast would very likely just be 'macro method infix:ast<+>'

[05:45] <TimToady> if you just want to run it

[05:46] <TimToady> in this view, 'macro' would just be a way to augment the current slang somehow

[05:46] <TimToady> and method vs regex, and various names that get called at various times, are indpendent

[05:47] <TimToady> 'macro regex infix:ast<+>' would be nonsense

[05:47] <TimToady> unless you really want to write your tree transformer as a regex

[05:47] <TimToady> 'macro method' is much more likely

[05:47] <sorear> viewing macro as a scope declarator has some nicities, but it seems to miss the fact that a macro is a concerted augmentation of the grammar, the action engine, and the lexical scope

[05:48] <TimToady> yes, but the current macro syntax is really klunky when you try to put all those things in

[05:48] <TimToady> it's not clear where the sweet spot is for sugar

[05:49] <sorear> I concede that having to wedge half of the macro into "is parsed" is not very sweet

[05:49] <TimToady> and which notations require you to say things that you might not need this time

[05:49] <TimToady> yes, that's a smell

[05:50] <TimToady> though you have to admit that in encourages people to use existing rules :)

[05:50] *** PZt left
[05:50] <TimToady> a system of names that interrealate and can generate defaults for missing ones seems like the most flexible approach, and :sym vs :ast might be that

[05:50] *** alester left
[05:51] <TimToady> or, if there's some block we always have to have, make optional phaser-like annotations for extras

[05:51] <TimToady> don't really have any phasers in regexen yet tho

[05:52] <TimToady> :my $stub = BEGIN {...}; is closest we have currently

[05:53] <TimToady> and maybe the regex isn't the 'master' block in any case

[05:53] <TimToady> up till now, it's whatever returns the AST to the parser that is the master

[05:53] <TimToady> maybe that could have a PARSE phaser or some such

[05:54] <TimToady> just brainstorming now

[05:54] <TimToady> more like braindrizzling, given my current mental state :)

[05:55] <TimToady> anyhoo, the design of p6 has to to where it is primarily because we haven't just assumed that the first thing we think of is the best thing

[05:55] <TimToady> or the second, or the third...

[05:55] <TimToady> s/to to/got to/

[05:56] <TimToady> gah, brane fried

[05:56] <sorear> putting the regex as the master is the most natural in an order of operations sens

[05:56] <sorear> but it has the disadvantage of making for very topheavy code

[05:56] <TimToady> but many of these operators have a default way of parsing

[05:56] <sorear> our regexes are pretty space-efficient

[05:56] <sorear> yes

[05:56] *** jonasbn joined
[05:56] <TimToady> so it feels wrongish to me

[05:57] <TimToady> but I agree with you about 'is parsed' also feeling wrongish

[05:58] <TimToady> some of the previous thinking included 'augment slang { your regexen here }'

[05:58] <TimToady> which is a good way to basically mix in a bunch of new methods

[05:58] <sorear> related to this is the question of how "use COBOL" is supposed to work

[05:58] <TimToady> that would be defining things from the grammar viewpoint primarily

[05:59] *** steinberg left
[05:59] <sorear> there isn't anything in the macro stuff about how a "use" can radically change an existing slang

[05:59] <TimToady> yes, that sort of thing is essentially an exported 'supersede slang'

[06:00] <TimToady> just kinda clobber the current %*LANG braid of languages and replace it with COBOL equivalents

[06:00] <TimToady> it's possible that augment/supersede are the wrong declarator, but the right idea

[06:00] <TimToady> since they aren't really about monkey typing something in place

[06:00] <sorear> it's not clear how to do that clobbering using a symbol, though

[06:01] <TimToady> more like 'constant %?LANG = stuff that gets back into %*LANG'

[06:01] <sorear> oooh

[06:01] <sorear> constant works for ?-twigil stuff?

[06:01] <sorear> brilliant

[06:02] <TimToady> well, somehow it has to change the type of the current $¢ in the parser, anyway

[06:02] <TimToady> currently it flows the other way

[06:02] <TimToady> if you have a $*foo variable in the compiler

[06:02] <TimToady> and you say $?foo and there isn't one predefined

[06:02] <TimToady> it assumes you mean a snapshot of the current $*foo value

[06:02] <sorear> well, we have "gmagic" compiler-contextuals ($?LINE)

[06:03] <sorear> "smagic" ones like %?LANG make equal sense

[06:03] <TimToady> std: say $?CURPKG

[06:03] <p6eval> std 30561: OUTPUT«ok 00:01 109m␤»

[06:03] <TimToady> that's actually just snapshotting $*CURPKG

[06:03] <spinclad> std: say %?LANG

[06:03] <p6eval> std 30561: OUTPUT«ok 00:01 108m␤»

[06:04] <TimToady> logically we have a $*LINE, but that's not actually how we do lines

[06:04] <TimToady> $?LINE is really $¢.pos.lineof

[06:04] <sorear> right, hence "gmagic"

[06:04] <sorear> $*LINE is synthesized on the spot

[06:05] <TimToady> anyhoo, grammar mods really just need to clobber the type of $¢

[06:05] <TimToady> what :lang() does in STD, and also .cursor_fresh if you give a new language

[06:05] <TimToady> or more subtley, .tweak with a mixin

[06:06] <TimToady> in rakudo there is currently a .LANG I believe

[06:06] <TimToady> but it's probably a bit more brittle

[06:06] *** gfx left
[06:06] <sorear> back to pure macro land - how about "macro" <deflongname> <trait>* [ "parsed" '{' <regex> '}' | "slang" '{' <statementlist> #`(as if in a grammar) '} | "reduce" <signature> <blockoid> ]*

[06:06] <sorear> well, NQP-rx doesn't have roles

[06:06] <sorear> which makes proper slanging impossible

[06:07] <spinclad> could that be, the next $¢ produced is of the new type?

[06:07] <sorear> so my macros would look vaguely like Pascal subprograms

[06:07] <moritz_> good morning

[06:07] <TimToady> yes, Cursors are immutable, so any method that rebless the next Cursor makes a new language

[06:07] <TimToady> only in proper English

[06:08] <TimToady> moritz_: o/

[06:08] <sorear> macro event

[06:08] <sorear>   parsed { <identifier> }

[06:08] <spinclad> \o: moritz_ 

[06:08] <sorear>   reduce ($/:) { ... }

[06:08] <sorear> ;

[06:09] <sorear> no, I'm confusing myself

[06:09] <TimToady> it would be nice to use some syntax similar to things we already have :)

[06:09] <sorear> yes.

[06:10] *** uniejo joined
[06:10] <sorear> but we don't really have any syntax for "stuff with N semi-optional parts"

[06:10] <TimToady> I will let it stew in my backbrain.

[06:10] <sorear> or do we?

[06:10] <TimToady> well, phasers, switches, related function/method names

[06:10] <spinclad> (N optional nameds)

[06:11] <TimToady> but not try {} finally {] style, by design

[06:11] <TimToady> those became phasers

[06:12] <sorear> a PARSE phaser could work

[06:12] <sorear> one other thing I don't really like

[06:12] <TimToady> but not clear whether nested lexical scopes buy us anything there

[06:13] <sorear> two, actually

[06:13] <TimToady> well, there's 'don't really like' vs 'really don't like'  :)

[06:13] <sorear> one is that, in my model, 'macro foo' defines a reducermacro which has no choice but to reuse the same syntax &foo would use

[06:13] *** chitragupt left
[06:14] <sorear> the "declarator" macro pattern has to use term:<foo>

[06:14] <sorear> which is slightly smelly, all those term:s

[06:14] <moritz_> should macro foo { } be synonymous to macro term:foo { }?

[06:14] <TimToady> might or might not be a problem, depending on how big the sweet spot is, and whether it makes hard things impossible

[06:14] <sorear> two, separating the regex from the ast-builder means that captures have to be bundled into $/ and unpacked as a hash, it would be nicer if they could be lexically propagated somehow

[06:15] <TimToady> moritz_: maybe, but that's a sugar

[06:15] <TimToady> and maybe it should be reserved for listops

[06:15] <moritz_> TimToady: he, Perl 6 is full of it :-)

[06:15] <sorear> moritz_: no, because then I'd need a new syntax for listop macros

[06:15] <moritz_> ok

[06:15] *** Ross joined
[06:15] <moritz_> makes sense

[06:15] * moritz_ retracts his proposal

[06:15] *** Su-Shee joined
[06:16] <TimToady> on two, have to think about that when I'm awaker

[06:17] <spinclad> sorear: two, like grammar and actions?

[06:17] <TimToady> but sounds like a good spot for phasers seeing their outer scope

[06:17] *** chitragupt joined
[06:17] <spinclad> (i mean, i guess, the same applies to grammar and actions)

[06:18] <TimToady> by default actions trigger when their associated rule terminates, but it gets more comlplicated with the opp

[06:18] <sorear> rakudo doesn't currently have a syntactic category for list prefix ops

[06:18] <TimToady> which is why Actions.pm (in STD's directory) has funny actions for PREFIX, INFIX, etc

[06:18] <TimToady> those are actually called from EXPR

[06:19] <TimToady> (the opp)

[06:19] <sorear> I wonder if it should.

[06:19] <TimToady> STD currently considers them prefix ops that mutate themselves magically into terms

[06:20] <TimToady> but they could be as easily considered terms that happen to embed their own arglists

[06:20] *** chitragupt left
[06:20] <TimToady> would remove a special case from EXPR

[06:20] <TimToady> not gonna decide that when my brane is much though

[06:20] <sorear> in rakudo, all list prefix ops are parsed by term:sym<name>

[06:21] <TimToady> *mush, even

[06:21] <TimToady> that's perhaps saner, and what I was considering

[06:21] <TimToady> nice to know that's what rakudo does

[06:21] *** TiMBuS joined
[06:22] <TimToady> it's a bit like the distinction between module declaratoins that take a block, and moudle declarations that take semicolon and chew up the rest of the file...

[06:23] <TimToady> but now I'm just kinda free associating

[06:23] <moritz_> std: { class Foo;  }

[06:23] <p6eval> std 30561: OUTPUT«[31m===[0mSORRY![31m===[0m␤Semicolon form of class definition not allowed in subscope;␤  please use block form at /tmp/qQCVtHqq48 line 1:␤------> [32m{ class Foo[33m⏏[31m;  }[0m␤    expecting any of:␤ name␤   trait␤Parse failed␤FAILED 00:01 107m␤»

[06:23] <moritz_> std++

[06:23] *** viklund joined
[06:23] <TimToady> it's not quite right yet though

[06:23] <TimToady> std: ( class Foo; )

[06:23] <p6eval> std 30561: OUTPUT«ok 00:01 107m␤»

[06:24] <JimmyZ> std: augment my class foo { ... }

[06:24] <p6eval> std 30561: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed augment at /tmp/ZPEvpVCG10 line 1:␤------> [32maugment [33m⏏[31mmy class foo { ... }[0m␤    expecting any of:␤    scoped declarator␤        typename␤Parse failed␤FAILED 00:01 107m␤»

[06:24] <TimToady> you can still fool it

[06:24] <JimmyZ> std: my augment class foo { ... }

[06:24] <p6eval> std 30561: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my at /tmp/YoJqBs5KpM line 1:␤------> [32mmy [33m⏏[31maugment class foo { ... }[0m␤    expecting any of:␤ scoped declarator␤        typename␤Parse failed␤FAILED 00:02 107m␤»

[06:24] <TimToady> my and augment are both scope declarators and can't be neste

[06:24] <TimToady> d

[06:24] *** [mark] joined
[06:25] <JimmyZ> how to augment non-global classes?

[06:25] <TimToady> augment must name an *existing* class

[06:25] <sorear> how to augment anonymous classes?

[06:25] <TimToady> so must supersede

[06:25] <JimmyZ> std: class foo { ... }; my augment class foo { ... }

[06:25] <p6eval> std 30561: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my at /tmp/UG9ZsAKzHj line 1:␤------> [32mclass foo { ... }; my [33m⏏[31maugment class foo { ... }[0m␤    expecting any of:␤      scoped declarator␤        typename␤Parse failed␤FAILED 00:01 107m␤»

[06:25] <JimmyZ> std: my class foo { ... }; augment class foo { ... }

[06:25] <p6eval> std 30561: OUTPUT«[31m===[0mSORRY![31m===[0m␤Can't augment class foo without MONKEY_TYPING at /tmp/oPHn4AQHaH line 1:␤------> [32mmy class foo { ... }; augment class foo [33m⏏[31m{ ... }[0m␤Check failed␤FAILED 00:01 107m␤»

[06:26] <sorear> ok, here's what I'll do

[06:26] * spinclad -> bed #  .oO{ dream of adding a display argument to (some variant of) pir::newclosure --> dream of newclosure mess magically working, and pink unicorns, and stuff }

[06:27] <sorear> 1. The bodies of all macros run at reduce time, with the matched portion of the subexpression in $/, and any outside portions (for prefix, postfix, infix, postcircumfix, and list prefix) in positionals / named

[06:27] *** chitragupt joined
[06:27] <JimmyZ> TimToady: S12 says, 'In order to discourage casual misuse of these declarators, they are not allowed on global classes unless you put a special declaration at the top: use MONKEY_TYPING;', but how to use it with non-global clasess?

[06:28] <TimToady> well, STD hasn't caught up with the 'global' part yet

[06:28] <TimToady> so it's a stdbug

[06:29] <sorear> 2. Any macro which is attached to a syntactic category may give an "is parsed" flag, which is used as the parse rule prefixed with <sym>

[06:29] <sorear> 3. If you wish to do things at category match time, put a closure in the parser.  This is deemed a rare edge case.

[06:30] <TimToady> well, 3 is perhaps 'augment slang {...}' time

[06:30] <TimToady> or whatever syntax we do that with

[06:30] <sorear> TBD.

[06:30] <TimToady> I presume 2 means the is parsed rule is only for the infix itself, and relies on the opp to supply the args

[06:31] <sorear> yes

[06:31] <TimToady> seems sane-ish in my current branestait

[06:31] *** chitragupt left
[06:32] <TimToady> note that this is currently thought to be 'is reparsed', if it includes <sym>

[06:32] <TimToady> but maybe that won't hold over the long haul

[06:33] <sorear> what makrudo currently does is to set the regex to / <sym> <!PARSED__++> / and inject the is parsed regex as !PARSED__++

[06:33] <TimToady> if 'is parsed' is defaulting to just <sym> most of the time anyway

[06:33] <sorear> which is a tad hackish but works

[06:33] *** chitragupt joined
[06:33] <sorear> oh, hmm

[06:33] <sorear> IMHO removing implicit <sym> from is parsed would make it more intuitive

[06:34] <sorear> Let's suppose I want to write a macro which expands to a method definition, but the method's name and signature are variable.  Can I do this with quasiquotes?

[06:34] *** Ross left
[06:34] <TimToady> yes, I remember you asking that earlier

[06:35] <TimToady> perhaps if we could tag unquotes with the proper category somehow

[06:35] <TimToady> sort of type casting thing maybe

[06:35] <TimToady> it's important to keep the parser knowing what to expect next

[06:35] *** chitragupt left
[06:35] *** sh0ck_ joined
[06:36] <sorear> Despite what it says in the Pugs notes, I have no qualms about exposing Match objects to macros

[06:36] *** sh0ck_ is now known as sh0cked

[06:36] <sorear> Standing here and looking forward, I am convinced that anything that can parse full Perl 6 is going to be functionally equivalent to a Perl 6 regex engine

[06:36] <sorear> so it can support $/ fine

[06:36] <TimToady> well, have to keep our matches and asts straight, but types our our friend, maybe

[06:37] <TimToady> in a sense, we want unquote to have a return sig

[06:38] <TimToady> or some way to insert the appropriate Match/Ast object at that point, given something non-match/ast-ish

[06:38] <TimToady> but I may be talking gibberish

[06:38] <TimToady> I agree that the current unquote may not be quite right

[06:38] <sorear> giving unquote a return sig isn't quite enough

[06:38] <TimToady> in the sense that the compiler needs to know the returned type at compile time, and the innards may not supply that

[06:39] *** chitragupt joined
[06:39] *** dduncan left
[06:39] <sorear> having to put <starter><starter><starter> into every protoregex is probably going to wreak havok with LTM

[06:39] <sorear> especially since it runs contrary to TTIAR

[06:39] <sorear> and the abilitiy to distinguish terms from ops

[06:39] <TimToady> for missing function name, for instance, you want to reassure the compiler that this unquote returns a <longname>

[06:41] <TimToady> it's kinda like you want to put regex into the unquotes and hoist those outward into the is parsed as appropriate

[06:41] * TimToady now no longer has a mush brane, but a puddle brane

[06:43] <TimToady> "Hey, I think it's been raining cats and dogs."  "How d'ya know?"  "I just stepped in a poodle."

[06:43] *** chitragupt left
[06:43] <TimToady> zzz &  # thunk

[06:43] *** Ross joined
[06:43] *** Ross left
[06:43] *** Ross joined
[06:44] *** chitragupt joined
[06:46] <sorear> phenny: tell TimToady - oh dear, I think I just found a fatal flaw

[06:46] <phenny> sorear: I'll pass that on when TimToady is around.

[06:47] <sorear> phenny: tell TimToady - my-macro-which-works-just-like-sub foo(&infix:<¢>) { 2 ¢ 3 } # During parse, the compiler doesn't know the lexical environment of the <blockoid> and can't parse the operator correctly.

[06:47] <phenny> sorear: I'll pass that on when TimToady is around.

[06:47] *** kst left
[06:48] *** kst joined
[06:51] * TimToady reawakens briefly and point sorear at 'lift', which was invented for this, and has nothing to do with Haskell

[06:51] <phenny> TimToady: 06:46Z <sorear> tell TimToady - oh dear, I think I just found a fatal flaw

[06:51] <phenny> TimToady: 06:47Z <sorear> tell TimToady - my-macro-which-works-just-like-sub foo(&infix:<¢>) { 2 ¢ 3 } # During parse, the compiler doesn't know the lexical environment of the <blockoid> and can't parse the operator correctly.

[06:52] <TimToady> or maybe not

[06:52] <TimToady> rethunk&

[06:55] <sorear> hmm.  I think parsing modules has something to do with dynamic_wind - from a certain perspective, we need to not see the contextualized modifications to the parsing context

[06:58] *** steinberg joined
[06:58] <moritz_> TimToady: should MyGrammar.parse($str) set $/?

[07:03] *** Ross left
[07:09] *** xabbu42 joined
[07:09] *** xabbu42 left
[07:09] *** xabbu42 joined
[07:15] *** chitragupt left
[07:16] *** chitragupt joined
[07:24] *** chitragupt left
[07:25] *** chitragupt joined
[07:26] *** envi^home joined
[07:31] *** tylerni7 left
[07:33] *** tylerni7 joined
[07:47] *** flip214 joined
[07:47] *** kst left
[07:48] *** kst joined
[07:54] *** bbkr_ joined
[07:54] *** k23z__ joined
[07:57] *** prfc0 joined
[07:57] *** chitragupt left
[07:58] *** bbkr_ left
[07:58] *** chitragupt joined
[08:02] <sorear> What are %*COMPILING, %COMPILINGPACKAGES, and %STUBCOMPILINGPACKAGES used for?

[08:04] <moritz_> I guess the STUB ones are those that don't warn/barf about redefinition

[08:06] *** chitragupt left
[08:08] *** chitragupt joined
[08:22] *** plobsing left
[08:23] *** kst left
[08:23] *** kst joined
[08:25] <flip214> A short question: is there some reflection for a grammar?

[08:26] <flip214> I'm asking because I'm thinking about a commandline program, that uses the grammar to parse the commandline parameters and the input (STDIN, load file) - similar to the various configuration interfaces.

[08:26] <moritz_> grammars are just like classes

[08:26] <flip214> And if there was a way to find out which token didn't match/would match next that could be used for readline completion, too - looking what would be expected next, and print it's representation

[08:27] <moritz_> so you can use the same introspection for grammars that are available for classes

[08:27] <flip214> Only for user-specified names there'd have to be callback functions, to look which names would make sense here.

[08:27] <flip214> Has someone already done a readline completion for grammars?

[08:27] <moritz_> but I don't think the level of detail you need is specced or implemented

[08:28] <moritz_> STD.pm's operator precedence parser has something like that

[08:28] <moritz_> it tells you what kind of things were expected

[08:28] <moritz_> std: 1 + **

[08:28] <p6eval> std 30561: OUTPUT«ok 00:01 110m␤»

[08:28] <moritz_> std: 1 + ^^

[08:28] <p6eval> std 30561: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix ^^ instead at /tmp/J2yu0n9ZGg line 1:␤------> [32m1 + ^^[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 108m␤»

[08:29] *** masak joined
[08:32] <masak> five minutes into the train journey, I realize I've forgotten the passport. :( so no visa today. the entire journey to Russia and my participation in DevConf now hang by a thread.

[08:32] <moritz_> :/

[08:33] <masak> not the best morning so far.

[08:33] <moritz_> can't you backtrack to obtain your passport?

[08:35] *** zzz_ joined
[08:35] <masak> I have backtracked, if only to get back to $work. but that puts me outside of their opening hours.

[08:36] <moritz_> :(

[08:36] *** yinyin joined
[08:36] *** zzz_ left
[08:39] *** PZt joined
[08:42] <viklund> it takes patience to get a visa at the russian embassy

[08:42] <masak> patience mixes badly with lack of time. :/

[08:42] <viklund> you really need to be there when they open, if there's still a queue when they close they just send the queue home...

[08:42] <masak> oh well, it seems I'll get a last chance tomorrow...

[08:43] <viklund> good luck

[08:43] <moritz_>  /me wonders if Russia doesn't like visitors

[08:43] <masak> viklund: I know about the queue :)

[08:44] <masak> moritz_: at the very least, they seem to want to make sure that when you want to go there, you really mean it.

[08:44] <moritz_> aye

[08:44] <viklund> maybe they're afraid of drop-outs from Europe

[08:45] <moritz_> it seems that setting $/ in the closure that you pass to .subst isn't easy

[08:45] <moritz_> $/ is lexical

[08:45] <moritz_> so you'd have to set a lexical on a sub-to-be-called

[08:46] <moritz_> and it seems that parrot doesn't support that notion

[08:47] <moritz_> I'll ask on parrot-dev, but glancing over the docs wasn't very encouraging

[08:48] *** chitragupt left
[08:49] *** flip214 left
[08:49] *** chitragupt joined
[08:50] <mathw> Morning

[08:51] *** chitragupt left
[08:55] *** chitragupt joined
[09:07] *** lestrrat is now known as lest_away

[09:07] *** chitragupt left
[09:09] *** chitragupt joined
[09:09] <masak> mathw: \o

[09:09] <masak> mathw: have you seen that named enums exist a little again?

[09:10] <moritz_> rakudo: enum A <a b c>; multi x(a $x) { say $x }; x a

[09:10] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[09:10] <masak> rakudo: multi foo(0 $x) { say $x }; foo 0

[09:10] <p6eval> rakudo 1eef08: OUTPUT«0␤»

[09:11] <masak> rakudo: multi foo(0 $x $y) { say $y }; foo 0

[09:11] <p6eval> rakudo 1eef08: OUTPUT«Malformed multi at line 11, near "foo(0 $x $"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[09:14] *** ktne joined
[09:18] * masak is sad to see in the logs that BrowserUk gave up so easily :/

[09:19] <moritz_> huh? when? what did I miss?

[09:20] * masak grabs link

[09:20] <masak> http://irclog.perlgeek.de/perl6/2010-05-06#i_2298685

[09:22] <moritz_> thanks

[09:24] *** prfc0 left
[09:26] <moritz_> you can have both good discussions and good fights with BrowserUk on perlmonks, IME :-)

[09:27] <moritz_> luckily good discussions more often

[09:28] <moritz_> masak: in your opinion, should MyGrammar.parse($str) set $/?

[09:28] *** chitragupt left
[09:29] <masak> moritz_: good question.

[09:29] <masak> moritz_: I could ack my modules and see how often I make use of that.

[09:30] <masak> I think I use it in a few places at least.

[09:30] <moritz_> the tests also seem to assume that in a few places

[09:30] <masak> (1) if it didn't, how would one do to actually set $/ ? (2) what's the worst thing about .parse setting $/ ?

[09:31] *** chitragupt joined
[09:31] <moritz_> (1) $/ := G.parse(...) probably

[09:31] <moritz_> or maybe assignment even

[09:31] <moritz_> (2) clobbering an existing $/

[09:32] <masak> yes of course.

[09:32] <masak> but so does m//

[09:32] <masak> they do feel a bit similar.

[09:33] *** mikehh left
[09:33] *** yinyin left
[09:34] <masak> so far I've found the 'sets $/' assumption in code in November and Text::CSV.

[09:34] <moritz_> well, I'll try to implement it

[09:41] *** chitragupt left
[09:41] *** chitragupt joined
[09:41] *** PZt left
[09:45] *** lest_away is now known as lestrrat

[09:47] *** chitragupt left
[09:51] *** arthur-_ left
[09:51] *** chitragupt joined
[09:53] <moritz_> > grammar G { token TOP { bar } }; G.parse('bar') && say "go to $/"

[09:53] <moritz_> go to bar

[09:55] *** dakkar joined
[09:58] <pugssvn> r30562 | moritz++ | [t/spec] unfudge a test for $/ after .parse 

[10:00] <mathw> masak: awesome

[10:00] <dalek> rakudo: 7563a50 | moritz++ | src/core/ (2 files):

[10:00] <dalek> rakudo: Grammar.parse sets $/ in the caller's scope

[10:00] <dalek> rakudo: Also remove a failed attempt to set $/ in the closure passed to Str.subst

[10:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7563a5046f5911e9548581b842f34db9d404d334

[10:08] *** chitragupt left
[10:10] *** chitragupt joined
[10:16] <masak> brief mention of Perl 6 in a Spolsky talk: http://use.perl.org/~jozef/journal/40345

[10:17] <masak> he seems to be running under the assumption that Perl 6 implies no Perl 5.

[10:19] <moritz_> that's a common assumption

[10:19] * JimmyZ can't visit youtube because GFW :(

[10:19] <moritz_> we'll need a good slashdot article to refute that believe

[10:19] <masak> YouTube is petty borgeoise and must be resisted!

[10:26] <masak> JimmyZ: my suggesting it might not be apropos, but have you ever considered circumventing GFW? I hear there are ways.

[10:26] *** ruoso left
[10:27] <moritz_> which are illegal, as I've heard

[10:27] <JimmyZ> Yes, and slow.

[10:27] <moritz_> so it's no good talking about that in a publicly logged channel :-)

[10:27] <JimmyZ> No, there is no law on it.

[10:27] <masak> I was only talking about considering it :P

[10:27] <JimmyZ> It's not illegal

[10:28] <moritz_> JimmyZ: then I've read a mis-informed article the other day

[10:28] <moritz_> which is no surprise

[10:28] <moritz_> the quality of reports about "far east" isn't very good here

[10:28] <masak> it's much better than it was 300 years ago :)

[10:29] <JimmyZ> the law is not on paper, just on someone's mouth :)

[10:29] <hejki> the quality of media about "anything" isn't very good anywhere

[10:29] <moritz_> hejki: depends on the medium

[10:29] <hejki> with little extrapolation it doesn't

[10:29] <hejki> :)

[10:29] <moritz_> I regularly read good Perl 6 coverage on planetsix :-)

[10:29] <masak> well, naturally, if you feel the need to circumvent the belovelent state's protection mechanisms, then you're already a bit suspect.

[10:30] <masak> moritz_: I tend to find planetsix very biased. don't believe all you read. :P

[10:30] <JimmyZ> nope, there is no law on paper. just on mouth of some departments

[10:31] <Su-Shee> the chief scalability techie guy of flickr also mentioned Perl 6 in a talk (rant why django sucks at some django conference :)

[10:31] <masak> Su-Shee: URL?

[10:31] <moritz_> masak: much of the bias on planetsix is clearly marked as personal opinion

[10:31] <Su-Shee> masak: *headscratch* lemme think about it.. 

[10:32] <masak> moritz_: I was mostly joking.

[10:32] <masak> moritz_: but a non-Perl6er could very well look at Perl 6 blog posts and think 'biased'.

[10:32] <moritz_> masak: I know; still I have a habit of giving serious answers to joke quetions and statements

[10:32] <masak> now who would ever do such a thing... :P

[10:33] <Su-Shee> masak: ah, here: http://www.youtube.com/watch?v=i6Fr65PFqfk

[10:33] <masak> Su-Shee: thank you.

[10:33] <aesop> o/

[10:33] <Su-Shee> well the problem is that "the environment" just doens't mention p5/p6. I read plenty web stuff for example which just doesn't mention any perl. 

[10:34] <Su-Shee> but the smalltalk traits folks mention p6 plenty!

[10:35] <masak> aesop: \o

[10:35] <masak> Su-Shee: they do? cool!

[10:36] <Su-Shee> masak: http://scg.unibe.ch/research/traits

[10:37] <Su-Shee> also I like to point out that this is within the context of academic research which might be a realm worth pushing into with bleeding edge features.

[10:37] <masak> nice.

[10:38] *** chitragupt left
[10:39] <JimmyZ> good video :)

[10:41] <masak> sorear: thank you thank you thank you for getting implementation-based discussion of macros going. I've been waiting for this for years!

[10:41] *** chitragupt joined
[10:41] <moritz_> non-bikeshed-discussions++

[10:43] <Juerd> moritz_: But...

[10:43] <Juerd> moritz_: We need to discuss the color of the non-bikeshed.

[10:43] <Juerd> Green!

[10:43] <Su-Shee> JimmyZ: it's pretty funny.

[10:44] <masak> is a non-bikeshed a shed for non-bikes or a non-shed for bikes?

[10:44] *** snarkyboojum joined
[10:44] <Juerd> masak: I think it is.

[10:44] <masak> :)

[10:44] <aesop> lol

[10:44] <masak> snarkyboojum: \o

[10:44] <Juerd> \o without digits feels weird.

[10:45] <snarkyboojum> masak: o/

[10:45] <Juerd> So incomplete, like \x

[10:45] <masak> is that a lawn chair waving?

[10:45] <aesop> lol

[10:45] * masak senses a possible miscommunication

[10:46] <masak> Juerd: digits/ \o     # better?

[10:46] *** JimmyZ left
[10:47] <Juerd> masak: Er... :)

[10:47] <masak> Juerd: oh, I see now!

[10:47] <masak> Juerd: you were referring to the lack of fingers on the backslash-arm. :)

[10:47] <Juerd> Not really :)

[10:47] <masak> maybe there's something up in Unicode to help you out. :P

[10:48] <Juerd> \o127

[10:48] <masak> or you could use quotes: "\o

[10:48] <masak> Juerd: (yes, I know) :P

[10:49] <masak> just exploring the misunderstanding space.

[10:49] <Su-Shee> btw roles and traits.. I have to do a presentation and I want to show a "Member" class (the usal "Person" stuff - we actually have those though :) and I was thinking to illustrate roles with something like Member does OutputJSON, OutputXML, DumperObject and so on - would one actually use Roles that way?

[10:50] <masak> Su-Shee: I'm no expert, but sure.

[10:50] <Su-Shee> to compare it against "Member inherits from Object the methods output_as_json.." and so on.

[10:50] <Su-Shee> masak: noone is. ;)

[10:50] <masak> Su-Shee: it does sound a bit like what I discussed in my 'Ovid is right' post.

[10:50] *** kst left
[10:51] <Su-Shee> I'm trying to illustrate the "behavoir" point clearly marked with "does" and why this is a practical thing.

[10:51] <Su-Shee> masak: url?

[10:51] <masak> http://use.perl.org/~masak/journal/40107

[10:52] *** rv2733 joined
[10:52] <Su-Shee> the interesting stuff is that in some smalltalk traits papers OO with traits/roles essentially goes into the direction of using classes for their inheritance capabilities and their attributes, but take much more methods out of classes and in traits/roles instead. not sure what to make of that.

[10:53] <masak> neither am I.

[10:53] <masak> I touch upon the possibility of that at the end of the post.

[10:54] <masak> still on the fence, really.

[10:54] <Su-Shee> essentially you would only include methods into classes which really really really make sense in any child derived and where inheritance is obvious. all others -> trait/role

[10:55] *** kst joined
[10:55] <Su-Shee> that is probably the key aeh sentences: Classes are primarily for instance management, not code reuse. Consider using roles when you simply want to factor out common code.

[10:57] *** chitragupt left
[10:57] <masak> *nod*

[10:57] <masak> I understand it, but I don't yet grok it.

[10:58] <Su-Shee> actually, I going via the semantics. I wrote down our Member stuff and tried to actually distinct between "Member has foobar" and "Member does foobar" which ended up with much more "does" then "has"

[10:59] *** chitragupt joined
[10:59] <Su-Shee> (afterwards I was sure that I plainly didn't get OO - yet again. ;)

[11:02] *** chitragupt left
[11:04] *** chitragupt joined
[11:13] <masak> Su-Shee: if roles are anything like the basic parts of OO design, it's more a question about seing past one's 'naturalistic' preconceptions of the various concepts ("Of course a board game has players, and not the other way around! That's how it is in Real Life!") and instead focus on what combination of features gives the most functional/maintainable/extensible architecture.

[11:15] <Su-Shee> yeah, but usally perl has its language stuff for a reason :) 

[11:15] *** mikehh joined
[11:16] <masak> even so, even with the defaults poking you in a sensible directions, a lot of (sometimes crucial) OO design choices are left up to the programmer.

[11:16] <masak> good OO design is one of those "I know it when I see it" phenomena.

[11:18] <Su-Shee> well I know bad design when I designed myself into a corner. ;)

[11:18] * masak nods in recognition

[11:19] <Su-Shee> feeling like a genius having an epiphany usally is also a bad sign. ;) 

[11:20] <masak> phenny: tell szabgab oops -- was talking about this: http://szabgab.com/talks/perl6/perl6-class-inheritance.html

[11:20] <phenny> masak: I'll pass that on when szabgab is around.

[11:22] *** kaare__ joined
[11:23] <masak> phenny: tell szabgab , as for the TODO question in http://szabgab.com/talks/perl6/perl6-classx.html -- the ultimate reason is that the normal accessors return an lvalue (that you can assign to). 'course, the accessors could be extended to take an optional argument, but it makes sense to encourage the assignment syntax, which is clearer anyway.

[11:23] <phenny> masak: I'll pass that on when szabgab is around.

[11:24] *** chitragupt left
[11:24] *** chitragupt joined
[11:25] *** kaare_ left
[11:27] *** snarkyboojum left
[11:27] *** snarkyboojum joined
[11:32] *** agentzh left
[11:35] <masak> moritz_: Hitomi in Web.pm, and Yapsi also use $/ immediately after parse. so that's four cases where I assume it gets set, and 0 cases so far where I don't. :)

[11:35] *** chitragupt left
[11:35] <Su-Shee> masak: the guy who implemented the javascript traits module, defines it like so: "A trait is essentially a group of pure methods that serves as a building block for classes and is a primitive unit of code reuse. In this model, classes are composed from a set of traits by specifying glue code that connects the traits together and accesses the necessary state."

[11:36] <Su-Shee> (which reads pretty understandable..)

[11:36] <masak> aye.

[11:36] *** chitragupt joined
[11:37] <masak> but it doesn't address the question of how this meshes with inheritance. is inheritance even needed under such a model? when faced with a choice between making something a role or a class, all other things being equal, what should one choose?

[11:38] <masak> moritz_: hm, actually, that's two cases in Hitomi. so 5-0.

[11:39] *** chitragupt left
[11:42] <moritz_> masak: implementation is already pushed

[11:42] <masak> yes, I saw that. moritz_``

[11:42] <masak> moritz_++

[11:42] *** chitragupt joined
[11:43] *** clintongormley joined
[11:46] <Su-Shee> masak: I think, I still would use inheritance to get from the common to the special. in our Member stuff, my base Member class would just know an id and a usename (because that's the only stuff really needed mostly) and go to more specialized Members like Admins from there. 

[11:46] *** snarkyboojum left
[11:49] <moritz_> Admin sounds like a fine role

[11:49] *** arthur-_ joined
[11:53] <Su-Shee> ok, then intern and extern and guest member. which are only distringuished by attributes they have. 

[11:53] <takadonet> morning all

[11:53] <Su-Shee> though we have like 4 different admins ;) 

[11:54] <moritz_> enum Admin <bart home marge lisa>

[11:54] <moritz_> or so :-)

[11:55] *** iblechbot left
[11:56] <masak> takadonet: \o

[11:56] <takadonet> masak: Is jnthn still on holidays? 

[11:58] <masak> takadonet: yes.

[11:58] <moritz_> I'm pretty sure he is

[11:58] *** chitragupt left
[12:04] *** jnthn left
[12:04] *** chitragupt joined
[12:04] *** mathw left
[12:04] *** bloonix left
[12:04] *** broquaint left
[12:05] *** bloonix joined
[12:05] *** broquaint joined
[12:06] *** chitragupt left
[12:06] *** Gothmog_ left
[12:07] *** chitragupt joined
[12:08] *** kst left
[12:08] *** kst joined
[12:09] *** bloonix left
[12:11] *** mathw joined
[12:17] *** jnthn joined
[12:17] *** chitragupt left
[12:17] *** bluescreen joined
[12:17] *** bluescreen is now known as Guest14064

[12:17] *** bloonix joined
[12:17] *** chitragupt joined
[12:17] <moritz_> rakudo: say

[12:17] <p6eval> rakudo 1eef08: OUTPUT«␤»

[12:17] *** Guest14064 left
[12:17] <moritz_> std: my %h = { a => b }␤say %h

[12:18] <p6eval> std 30562: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'b' used at line 1␤Check failed␤FAILED 00:01 110m␤»

[12:18] <moritz_> std: my %h = { a => 'b' }␤say %h

[12:18] <p6eval> std 30562: OUTPUT«ok 00:01 109m␤»

[12:18] <moritz_> rakudo: my %h = { a => 'b' }␤say %h

[12:18] <p6eval> rakudo 1eef08: OUTPUT«a  b␤␤»

[12:18] <moritz_> huh, are there two newlines in the output?

[12:22] *** mathw left
[12:25] *** chitragupt left
[12:27] *** chitragupt joined
[12:30] <masak> phenny: tell szabgab re http://szabgab.com/talks/perl6/perl6-scalars.html -- 'undef' doesn't exist anymore. instead, it's all different values of undefined types. an untyped variable will start its existence holding the value Any(), the Any type object.

[12:30] <phenny> masak: I'll pass that on when szabgab is around. I'll have to use a pastebin, though, so your message may get lost.

[12:32] *** mathw joined
[12:32] <masak> phenny: yeah, it's growing to be quite a lot, I know. :)

[12:32] *** ruoso joined
[12:32] *** TiMBuS left
[12:32] *** Gothmog_ joined
[12:32] *** chitragupt left
[12:33] *** chitragupt joined
[12:34] *** chitragupt left
[12:35] *** chitragupt joined
[12:36] <masak> phenny: tell szabgab re http://szabgab.com/talks/perl6/perl6-boolean-expressions.html -- both those zeros are the correct output. however, they should both be typed as Bool, and (0 xor 0) gives an Int right now in Rakudo. that's wrong.

[12:36] <phenny> masak: I'll pass that on when szabgab is around. I'll have to use a pastebin, though, so your message may get lost.

[12:36] <masak> I believe there's a ticket for it.

[12:37] <masak> here: http://rt.perl.org/rt3/Ticket/Display.html?id=73280

[12:37] <moritz_> yes; I just don't know if it's golfed that much

[12:37] <masak> it's talking about ^^

[12:37] <masak> but I'd bet the same goes for infix:<xor>

[12:37] <masak> rakudo: say (90 xor 4).WHAT

[12:37] <p6eval> rakudo 1eef08: OUTPUT«Method 'WHAT' not found for invocant of class 'Undef'␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[12:37] <masak> pugs: say (90 xor 4).WHAT

[12:37] <moritz_> we're not talking about the same thing, I guess

[12:37] <p6eval> pugs: OUTPUT«Bool␤»

[12:38] <masak> rakudo: say (0 xor 0).WHAT

[12:38] <p6eval> rakudo 1eef08: OUTPUT«Int()␤»

[12:38] * masak updates ticket subject

[12:45] <masak> Rakudo dies when something goes wrong with &open, right? is that the long-term Perl 6 behavior? I don't see anything about the expected behavior in S32/IO.

[12:47] <arnsholt> I'd argue that it should throw an exception of some kind on error

[12:47] <arnsholt> Magical return values are evil

[12:47] <masak> you must be new here :)

[12:47] <masak> unthrown exceptions are all over the place in Perl 6.

[12:47] <masak> that's what &fail does, in essence.

[12:48] <arnsholt> True. But you get an exception when you try to evaluate it, no?

[12:48] <arnsholt> So it's essentially a lazy exception (which I think is a neat idea)

[12:48] <arnsholt> It's the C-style magical return values I don't care for

[12:48] <masak> ah.

[12:48] <masak> indeed.

[12:49] <masak> I got to thinking about it because szabgab's code does if (open ...) { ... } else { ... }

[12:49] *** chitragupt left
[12:49] <arnsholt> &fail is quite cool because it will only raise an exception when the resource is actually needed

[12:49] <masak> ...which I guess will work if the exception is returned unthrown.

[12:49] <arnsholt> Although fail-early semantics would probably be nice in some settings as well

[12:50] *** chitragupt joined
[12:51] <moritz_> that'll be available with 'use fatal "fail"' or so, iirc

[12:51] <masak> and, for more fine-grained control, 'or die' will still work fine.

[12:56] *** chitragupt left
[12:56] <arnsholt> moritz_: Good plan

[12:56] *** chitragupt joined
[12:56] <moritz_> masak: 'or die' is not awesome, because it requires you to write your own awesome error messages

[12:57] *** webdexter joined
[12:57] <webdexter> hello

[12:57] <masak> moritz_: hm, true. $! will not contain the error.

[12:57] <moritz_> hi

[12:57] <masak> webdexter: hi!

[12:59] *** chitragupt left
[13:00] <webdexter> masak : iam totally new in perl, juste would like to modify a source from an open source project, I would like to replace a line that said if this field begin with 192.168  "if ($fields[0]=~/^192\.168\..*/)" by a line that said if field end with -color . I mean now the format of my field is "192.168.1.1-red" and I would like to say : if end is red then ... if end is yellow then ..

[13:00] <masak> mberends: hey, three weeks ago you changed "Its only purpose" to "It's only purpose" in the proto README. don't do that. :-P

[13:00] <masak> webdexter: sounds like you want #perl, not #perl6.

[13:00] <masak> well, you may want us too, but you don't seem to know it... :)

[13:01] <webdexter> masak : yes problably wrong channel sorry :) but I have  #perl :Cannot join channel (+r) - you need to be identified with services (Iam quiet new on irc)

[13:01] <masak> webdexter: I can help you on privmsg if you want, but general Perl 5 help is OT for this channel.

[13:02] *** chitragupt joined
[13:02] <hejki> webdexter: masak is right, but you could do sth like if ($fields[0] =~ /^192\.168\.\d+\.\d+-(\S+)/) { if ($1 eq "red") { .. } elsif ($1 eq "yellow") { .. } } :)=

[13:04] <hejki> pumpin' sum iron &

[13:04] <masak> hejki: and if this'd been the #perl channel, mst would have told you to "PLEASE USE ENGLISH. sth IS A CONCEPT FROM THE DBI MODULE"

[13:04] <masak> :)

[13:04] <hejki> use English; is for nubcakes :)

[13:05] * masak writes down 'nub... cakes...'

[13:05] <hejki> also i have unfinished jobs, laters :)

[13:07] *** chitragupt left
[13:07] *** SmokeMachine joined
[13:07] *** plobsing joined
[13:08] *** chitragupt joined
[13:11] <masak> phenny: tell szabgab re http://szabgab.com/talks/perl6/perl6-undef-defined.html -- 'defined' still exists (both in sub and method form), but 'undef' is gone.

[13:11] <phenny> masak: I'll pass that on when szabgab is around. I'll have to use a pastebin, though, so your message may get lost.

[13:14] <masak> phenny: tell szabgab same thing with http://szabgab.com/talks/perl6/perl6-list-assignment.html -- $z will be Any(). also, the 9 will cause an overflow warning in real Perl 6.

[13:14] <phenny> masak: I'll pass that on when szabgab is around. I'll have to use a pastebin, though, so your message may get lost.

[13:15] *** xinming_ is now known as xinming

[13:18] *** kaare__ left
[13:20] *** snarkyboojum joined
[13:20] <moritz_> poor szabgab

[13:20] <moritz_> masak: you know, you can reach him by privmsg too

[13:21] <masak> I didn't plan on passing him that many messages. it... just happened...

[13:23] *** JimmyZ joined
[13:24] <JimmyZ> \o, I sent a patch rt, but nothing is there, seems that rt blocked me again.

[13:24] <bbkr> rakudo: my %h = { "a" => %h }; say %h.values.perl; #this one loops badly

[13:24] <p6eval> rakudo 1eef08: OUTPUT«maximum recursion depth exceeded␤current instr.: 'parrot;P6protoobject;VTABLE_name' pc 1298 (runtime/parrot/library/P6object.pir:764)␤»

[13:25] <moritz_> JimmyZ: it sometimes takes a few minutes to hours, even for non-blocked users

[13:25] <JimmyZ> 4 hours...

[13:26] * bbkr submits

[13:26] <moritz_> bbkr: that's already known

[13:26] <masak> JimmyZ: I see your patch: http://rt.perl.org/rt3/Ticket/Display.html?id=74942

[13:26] <moritz_> bbkr: and there's a rather old ticket about it, iirc

[13:26] <colomon> is it really a bug?

[13:26] <moritz_> masak: didn't you apply that patch?

[13:27] <bbkr> thanks for info moritz_ :)

[13:27] <masak> moritz_: I think it might have been a very similar one.

[13:27] <moritz_> I'm talking about 376196dffcd4fa8ea337d4be7c62f4593494c952

[13:27] *** viklund left
[13:28] <masak> moritz_: yes. but that one contained only one hunk. this one contains three.

[13:29] <JimmyZ> masak: I can't see it in p6c

[13:30] *** chitragupt left
[13:30] <masak> JimmyZ: what moritz_ said about delays.

[13:31] <JimmyZ> I wan't see it on RT, but RT lists the oldest one in the first

[13:31] <JimmyZ> er, want

[13:32] <moritz_> JimmyZ: if you click on the "created" column heading, you can revert the sort order

[13:33] <JimmyZ> I don't know how to do it. I couldn't find the button

[13:34] <moritz_> you need to be logged in to do that :(

[13:34] <bbkr> how to delete hash key? S09 mentions only declarations.

[13:34] <moritz_> in Perl 6 with %hash<key>:delete

[13:34] <moritz_> in rakudo with %hash.delete('key')

[13:35] <JimmyZ> :(

[13:35] <bbkr> works, thanks. 

[13:35] <moritz_> in general it's bad if rakudo deviates from the spec, but I really hate the :delete thing

[13:36] <moritz_> the verb going at the end is like reversed yodaspeak

[13:36] <JimmyZ> I want del %hash<key>

[13:36] <moritz_> excuse me, reversed yodaspeak the verb going at the end is

[13:36] <JimmyZ> ;)

[13:37] <moritz_> JimmyZ: you won't get it

[13:37] <bbkr> indeed, :delete is ugly and hard to remember

[13:37] *** PZt joined
[13:37] <JimmyZ> I can decalre it by myself

[13:37] <moritz_> have fun trying

[13:37] <moritz_> it would need to some kind of a macro

[13:37] <aesop> i like the %hash.delete('key') better

[13:38] <moritz_> because %hash<key> is evaluated before del() is called

[13:38] <moritz_> so the association with the hash is lost

[13:38] <moritz_> (which is why the spec doesn't use it)

[13:38] <bbkr> rakudo: my %h = {"a" => "b"}; %h{"a"} = %h.delete("a"); say %h.perl; # is it bug? right side should be evaluated before assignment and then %h{"a"} initialized on left side.

[13:38] <p6eval> rakudo 1eef08: OUTPUT«{}␤»

[13:38] <moritz_> in perl 5 it's a syntactic special form

[13:38] <JimmyZ> Yeah, %hash.delete('key')  looks better

[13:39] <aesop> slightly more readable

[13:39] * bbkr votes for %hash.delete('key1', ...)

[13:39] <JimmyZ> More OOP

[13:39] <JimmyZ> blames it to TimToady 

[13:40] <JimmyZ> my poor english again :(

[13:42] <bbkr> std: my %h = {"a" => "b"}; %h{"a"} = %h.delete("a"); say %h.perl;

[13:42] <p6eval> std 30562: OUTPUT«ok 00:01 111m␤»

[13:42] <bbkr> std: my %h = {"a" => "b"}; %h{"a"} = %h.delete("a"); say %h.keys;

[13:42] <p6eval> std 30562: OUTPUT«ok 00:01 109m␤»

[13:43] <moritz_> STD.pm6 just checks syntax

[13:43] <moritz_> and it's valid method call syntax after all :-)

[13:43] <masak> moritz_: I always thought Perl 6 (spec) still has both .delete and :delete, because TimToady wanted the latter form only but hasn't decided to scrap the former one yet.

[13:43] <masak> ditto :exists.

[13:44] <masak> and yes, I don't like those adverbial forms either.

[13:44] <mathw> I don't understand them

[13:44] *** quester_ joined
[13:44] <mathw> They seem to serve no purpose

[13:44] * mathw nearly wrote 'serve no porpoise' which is probably true

[13:44] <moritz_> masak: grepping for 'delete' should only one mention that's not an adverb form

[13:45] <moritz_> and there it explicitly says 

[13:45] <moritz_>            The interpretation of @indices is subject to change.  The normal way to delete

[13:45] <moritz_>            is by applying a ":delete" adverb to any subscripting operation.

[13:47] <masak> nod.

[13:48] <moritz_> I'm kinda inclined to guerilla-add it in

[13:48] <masak> I still seem to recall TimToady not being entierly decided on the issue.

[13:48] <masak> maybe that's wishful thinking or projection, though :P

[13:50] <bbkr> this ":delete" form looks weird if you want to perform operations on deleted value. for example how this will look in :delete form: '%h.delete("a",  "b", "c").[2].say'  ?

[13:50] <bbkr> %h{"a", "b", "c"}:delete.[2].say ? 

[13:51] <colomon> seems to me I remember someone explaining to me why the adverb form was better back when I first joined #perl6.  but I've got not the faintest memory of what the explanation was...

[13:51] <masak> bbkr: probably. might be that parens are needed, I'm not sure.

[13:51] <masak> colomon: let us know if you rediscover it! :)

[13:51] <moritz_> colomon: might be because it uses the same subscripting syntax and semantics as "normal" postcircumfix:<{ }>

[13:51] <colomon> masak: I also seem to remember TimToady being down on adverbs in general...

[13:52] * masak seems to have a problem with idioms involving 'down' this week

[13:52] <masak> colomon: 'being down on' is positive, right?

[13:52] <colomon> no, negative.

[13:53] <bbkr> masak: and parens make code looks messy. OO syntax .delete(@keys) does not cause confusion.

[13:53] <masak> oh.

[13:54] *** iblechbot joined
[13:55] *** pmurias joined
[13:56] <colomon> if you say %h<a b>:exists, is it either <a> or <b> exists, or both?

[13:57] *** rgrau_ joined
[13:57] <moritz_> "yes"

[13:57] <hejki> :D

[13:57] <moritz_> I'd assume "both", but I'm not sure

[13:58] <colomon> masak: "being down with" is is an older "hip" way of saying positive.  Just a weird English idiom thing.

[13:58] <diakopter> pmurias: sorry I broke perlesque

[13:58] <diakopter> pmurias: fixing

[14:01] *** chitragupt joined
[14:05] <pmurias> diakopter: hi

[14:05] <phenny> pmurias: 04:10Z <diakopter> tell pmurias I got parametric type declarations working.  That is, they're compiled to fields/locals in the CIL. You can't use .new on them yet, tho.

[14:06] <pmurias> diakopter: why do i talk to to get shell access to the p6eval box?

[14:06] <bbkr> colomon: most OO programmers would think this way %h<a b> returns an Parcel, but Parcel does not have "exists" method, so what is going on?

[14:07] <bbkr> if it's %h.exists("a", "b") then it's very clear what it does

[14:07] <diakopter> pmurias: me, since it's mine

[14:08] <moritz_> %h.exists('a' & 'b') would be clear

[14:08] <pmurias> could i have a shell account? ;)

[14:08] <moritz_> or %h.exists('a' | 'b')

[14:08] <bbkr> besides - OO form can be used with junction: %h.exists(1|2|3) and it's also very understandable. :exists form 

[14:08] <bbkr> is messy

[14:08] <colomon> bbkr: I agree wholeheartedly.  Like I said, I can't even remember the alleged reasons %h<a b>:exists was supposed to be better. 

[14:09] <pmurias> diakopter: so i can add mildew-perlesque to the evalbot

[14:09] <bbkr> right! moritz_ is a mindreader :P

[14:09] <diakopter> pmurias: privmsg me

[14:09] <dalek> csmeta: r239 | diakopter++ | trunk/Sprixel/src/ (2 files):

[14:09] <dalek> csmeta: [perlesque] attempt to fix sub declarations return parameterized types

[14:09] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=239

[14:09] *** webdexter left
[14:10] <pugssvn> r30563 | pmurias++ | [mildew] added App::Persistent support to the new mildew executable 

[14:10] *** rgrau_ left
[14:12] * diakopter boggles to think about trying to contain an oil leak 1.6km underwater

[14:13] *** xabbu42 left
[14:14] *** kst left
[14:14] *** kst joined
[14:15] <moritz_> get as much $heavy_stuff on it as possible?

[14:16] <moritz_> thousands of tons of concrete?

[14:16] <diakopter> http://www.cnn.com/2010/US/05/06/gulf.oil.spill/index.html?hpt=T1

[14:17] <moritz_> really depends on pressure with which the oil comes up

[14:17] <aesop> russia is recommending we use underwater nukes

[14:17] <moritz_> that sounds a bit... unpredictable

[14:18] <moritz_> and probably not very healthy for the sea life, if any is left

[14:19] <PerlJam> the oil isn't very healthy either.

[14:20] *** alester joined
[14:20] <PerlJam> (not to say that the damage is comparable, but it might be given the long-term effects of hydrocarbons on the reproductive processes)

[14:21] <moritz_> but what's the chance of actually closing the leak with a nuke?

[14:21] <JimmyZ> %h.exists 'a' | 'b'

[14:22] <diakopter> wow; cpanminus is speedy-seeming

[14:23] <masak> JimmyZ: for method calls, you have to use a colon: %h.exists: 'a' | 'b'

[14:23] <JimmyZ> rakudo: say: 'hello'

[14:24] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "say: 'hell"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[14:24] <PerlJam> moritz_: I  think the russians may have a bit of experience with tactical explosions of this nature, so I would guess the chances are close to 80% or 90%

[14:24] <PerlJam> moritz_: with a 100% chance of killing lots of stuff in the area 

[14:24] *** plobsing left
[14:25] <diakopter> yeah, but who's to say the rubble would land at all on top of the oil vent; maybe it would just create a very deep crater, and the oil vent would still be exposed to the sea

[14:25] <moritz_> that's my fear as well

[14:25] <diakopter> same reason my nuke-the-volcano idea wasn't sound

[14:26] *** plobsing joined
[14:26] <PerlJam> diakopter: I would imagine it's not about rubble, but more about creating high enough temperatures that the "dirt" fuses into a solid mass and caps the leak

[14:27] <diakopter> oh

[14:28] <moritz_> well, if they do try it, I'm happy it's not close to Europe

[14:28] *** kaare joined
[14:28] *** uniejo left
[14:28] *** kaare is now known as Guest13256

[14:30] * PerlJam is only a few miles from the Guld of Mexico and just a few hundred miles from where the leak is.

[14:31] <arnsholt> moritz_: Water is actually very good at absorbing radiation, from what I hear

[14:31] <masak> std: say: "hello"

[14:31] <p6eval> std 30563: OUTPUT«ok 00:01 109m␤»

[14:31] <masak> JimmyZ: but it parses as a label.

[14:31] <moritz_> still, it sounds like casting out devils by Beelzebub

[14:32] <arnsholt> True, true

[14:35] <masak> people are still attempting that? hah, noobs!

[14:37] <masak> "Some people, when confronted with a devil, think 'I know, I'll use Beelzebub.' Now they have two devils."

[14:38] <moritz_> that hurt.

[14:39] <masak> sorry :/

[14:39] <masak> it was a bit of a *SCNR* thing...

[14:42] * masak stops being a nuisance and does something useful

[14:43] <moritz_> masak: speaking of useful work... have you thought about where you do your gsoc project?

[14:43] <moritz_> masak: iirc the recommend you do it in branch

[14:44] <moritz_> so that it's easy to tell which changes were part of your gsoc work

[14:44] <moritz_> and then sync to trunk now and then, or so?

[14:44] *** lrnperl6 joined
[14:44] <lrnperl6> morning all

[14:44] <moritz_> or just work in master, and in the end cherry-pick all your branches, pack them in a zip file, and upload it as your "deliverables"?

[14:45] <masak> moritz_: haven't given it much thought. doesn't seem like a big issue to collect commits in the end, though.

[14:45] <masak> lrnperl6: \o

[14:45] <masak> moritz_: I'll probably end up doing atomic commits in master, and bigger things in branches.

[14:47] *** stepnem left
[14:47] *** plobsing left
[14:52] *** BrowserUk joined
[14:58] *** quester_ left
[14:59] *** sh0cked left
[15:00] *** stepnem joined
[15:06] <bbkr> rakudo: my %h = {my => "x"}; # should this parse? 

[15:06] <p6eval> rakudo 1eef08: OUTPUT«Malformed my at line 11, near "=> \"x\"}; #"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[15:06] <masak> rakudo: class A { my submethod foo() { say "OH HAI" }; method bar() { foo(self) } }; A.new.bar # just realized that this works!

[15:06] <p6eval> rakudo 1eef08: OUTPUT«OH HAI␤»

[15:06] <szabgab> phenny, so how can I listen to my messages?

[15:06] <phenny> szabgab: 05:22Z <masak> tell szabgab that I don't know if we've touched on this before, but both .HOW and .WALK are 'internal' in some sense (thus their uppercaseness). use 'nextsame' in the normal case: http://gist.github.com/391806

[15:06] <phenny> szabgab: 05:23Z <masak> tell szabgab and the fact that this wasn't obvious from the spec shows the need for a tutorial just like yours. :) szabgab++

[15:06] <phenny> szabgab: 11:20Z <masak> tell szabgab oops -- was talking about this: http://szabgab.com/talks/perl6/perl6-class-inheritance.html

[15:06] <phenny> szabgab: 11:23Z <masak> tell szabgab , as for the TODO question in http://szabgab.com/talks/perl6/perl6-classx.html -- the ultimate reason is that the normal accessors return an lvalue (that you can assign to). 'course, the accessors could be extended to take an optional argument, but it makes sense to encourage the assignment syntax, which is clearer anyway.

[15:06] <phenny> [Sorry, some messages were elided and lost...]

[15:07] <szabgab> phenny, thanks

[15:07] <masak> phenny: you said you'd nopaste them!

[15:07] *** nihiliad joined
[15:07] <bbkr> std: my %h = {my => "x"};

[15:07] <p6eval> std 30563: OUTPUT«ok 00:01 113m␤»

[15:07] <szabgab> masak, thank you too :-)

[15:08] <masak> you're welcome.

[15:09] <masak> hoping to see an updated course some day! it has really good material; just needs updating.

[15:10] <masak> rakudo: class A { my method foo() { say "OH HAI" }; method bar() { foo(self) } }; A.new.bar

[15:10] <p6eval> rakudo 1eef08: OUTPUT«OH HAI␤»

[15:10] <masak> TimToady: S12: 'A subroutine call considers only visible subroutines (including submethods) of that name.' how does that square with the above?

[15:11] *** lrnperl6 left
[15:11] *** kst left
[15:11] <TimToady> these days, should say, "including methods and submethods declared with a lexical name

[15:12] <masak> ah, ok.

[15:12] <moritz_> btw TimToady++ # multi method/proto unification

[15:12] <moritz_> I just wonder if it should be s/empty body/stub/

[15:13] <moritz_> so that proto foo($x) { ... } does the magic re-dispatch, not foo($x)  { }

[15:13] <TimToady> I considered that, but it just didn't feel quite right for some reason

[15:13] <moritz_> s:2nd/<before foo>/proto /

[15:14] <TimToady> has to do with people thinking the ... means "nextsame", and then trying to use "..." to mean that

[15:14] <TimToady> ... is not a placeholder in that sense

[15:14] <moritz_> ... is "explicitly empty" in my mind

[15:15] <TimToady> it's not a strong reason

[15:15] <moritz_> and it's not a strong sentiment on my part eitehr

[15:15] *** JimmyZ left
[15:15] <moritz_> I just read it and though "huh, ... would fit better"

[15:16] <TimToady> either way could be made to work, or maybe even both

[15:16] <moritz_> are proto tokens ever executed?

[15:16] <TimToady> being a proto kinda turns the whole body into a sort of macro anyway

[15:16] *** kst joined
[15:17] <moritz_> proto token { } # empty regex disallowed

[15:17] <moritz_> proto token { <...> } # feels much better

[15:17] <PerlJam> indeed

[15:17] *** pmurias left
[15:17] <TimToady> I now think <...> is kinda redundant with {...}

[15:17] <TimToady> proto token { {...} }

[15:18] <moritz_> <...> feels more declarative

[15:18] <moritz_> {...} is procedural

[15:18] *** jonrafkind joined
[15:19] <TimToady> one can view the nextsame stub both ways too, I guess

[15:19] <TimToady> either as a "do this" or as an "insert here"

[15:19] <TimToady> and how do we get all the nextsame/callsame variants into regexese

[15:20] <TimToady> <nextsame> and <callsame> I guess

[15:20] <moritz_> somehow proto tokens feel quite different than multi subs

[15:20] <moritz_> they execute all candidates in parallel

[15:21] <TimToady> not really

[15:21] <masak> regex matching executes quite differently than ordinary code.

[15:21] <TimToady> they run a DFA as part of trying to decide which one to *really* run

[15:21] <moritz_> well, notionally at least

[15:21] <bbkr> Pair constructor stringifies key. so @t=>"x" is the same as ~@t=>"x" - key is Str type. Should it work on Junctions as well? (1|2|3)=>"x" crashes in Rakudo (beside fact, that it's just stupid code)

[15:22] <moritz_> bbkr: I'd expect it to autothread, and return a junction of Pair objects

[15:22] <TimToady> bbkr: pair constructors aren't stringy

[15:22] <TimToady> or aren't *supposed* to be

[15:22] <moritz_> rakudo: say (1 => 3).key.WHAT

[15:22] <p6eval> rakudo 1eef08: OUTPUT«Int()␤»

[15:22] <moritz_> and they aren't

[15:22] <moritz_> just hashes stringify

[15:23] <moritz_> the keys

[15:23] <bbkr> rakudo: my %h = {(1|2|3) => "x"};

[15:23] <p6eval> rakudo 1eef08: OUTPUT«Odd number of elements found where hash expected␤current instr.: '&die' pc 17868 (src/builtins/Junction.pir:393)␤»

[15:23] *** masak left
[15:23] <bbkr> i meant Pair constructor in hashes, like above

[15:23] <moritz_> the error comes from the hash assingment, not from the pair composition

[15:23] <moritz_> rakudo: say ((1|2|3) => "x").perl

[15:23] <p6eval> rakudo 1eef08: OUTPUT«any(1 => "x", 2 => "x", 3 => "x")␤»

[15:23] <moritz_> that looks right so far

[15:24] <bbkr> I get it now. thanks!

[15:24] <moritz_> and I really don't know what should happen if you assign a junction to a hash

[15:26] <bbkr> me neither :) i'm just trying weird but simple code snippets.

[15:26] <bbkr> in this case it's not a bug. my %h = {(1|2|3) => "x"}; is the same as my %h = {any(1 => "x", 2 => "x", 3 => "x")}; and it's indeed odd number of elements

[15:28] <tedv> how do you remove the any() call?  Ie. convert a junction to the union of all potential values

[15:28] <moritz_> unless juctions are supposed to flatten out in list context, and a list of pairs is fine to assingn to a hash

[15:29] <moritz_> tedv: you don't. If you want to, it tells you that you should really be using Sets (which are NYI, of course...)

[15:29] *** PacoLinux left
[15:30] <PerlJam> bbkr: my %h{Junction} = { (1|2|3) => "x" };   # should succeed (eventually :)

[15:30] *** PacoLinux joined
[15:30] <tedv> That's a rather cavalier attitude

[15:30] <tedv> The operation is mathematically well defined

[15:30] <moritz_> maybe I misunderstood the question

[15:30] <tedv> who is to say that I won't receive a junction from some library function and want to convert it to a set?

[15:30] <moritz_> do you want to flatten a nested junction?

[15:30] <tedv> yeah

[15:30] <moritz_> or do you want to extract the eigenstates?

[15:31] <PerlJam> tedv: you would do so explicitly though, not implicitly.

[15:31] <tedv> I mean how would you convert any(a,b,c) to the set of (a,b,c)

[15:31] <[particle]> any(a,b,c).Set ??

[15:31] <moritz_> there used to be a .eigenstates method

[15:31] <tedv> yeah, I'm just curious what the explicit operator or function is called

[15:31] <moritz_> that was was removed

[15:31] <moritz_> for the reason I stated above

[15:32] <moritz_> and because of much bikeshedding on p6l :(

[15:32] <tedv> because perl knows better than me why I'm writing perl code, got it

[15:32] <TimToady> any() is not a set, it's a set of sets

[15:32] *** Ross joined
[15:32] <PerlJam> eigenstates is still in S32-setting-library/Containers.pod

[15:32] <moritz_> PerlJam: as a private method, no?

[15:32] <TimToady> only all() is a reasonable approximation of a set

[15:32] <PerlJam> moritz_: oh, aye.  

[15:32] <moritz_> anyway, you can write a utilty

[15:33] <TimToady> and use of junctions as sets turned out to be an "attractive nuisance"

[15:33] *** rgrau_ joined
[15:33] <tedv> Not disagreeing with that

[15:33] <tedv> It's just that perl traditionally gives you enough rope to hang yourself, so why not that piece of rope? :)

[15:33] <moritz_> sub eigenstates(Mu $x) { my @e; -> Any $y {@e.push: $y}.($x); @e)

[15:33] <TimToady> because we were already getting tired of throwing ropes to people

[15:34] <moritz_> (might be a race condition one junctions evaluate in parallel)

[15:34] <tedv> mortiz_: The order of @e won't be guaranteed I think

[15:34] <tedv> er yeah roughly what you said

[15:34] <moritz_> tedv: sure; junctions don't have an intrinsic order

[15:35] <tedv> which brings us back to sets instead of arrays

[15:35] *** szabgab left
[15:35] <[particle]> on bags, for repeated values

[15:35] <[particle]> *or

[15:35] <tedv> yeah

[15:35] <TimToady> those are all specced, but not very implemented

[15:36] <moritz_> should sets autothread like junctions?

[15:36] <tedv> So what are some practical uses for junctions?  When I heard them described, they seemed like a genuinely useful feature but I had trouble thinking of how I'd use it in everyday coding.

[15:36] <moritz_> tedv: mostly as matchers

[15:37] <tedv> and just assumed it was because my mind didn't have practice thinking in that manner

[15:37] <TimToady> most common: if $a == 1 | 2 | 3

[15:37] <tedv> you mean more general form regular expression?

[15:37] <moritz_> tedv: I mean things like "grep"

[15:37] <tedv> ie. operates on any data type, not just strings

[15:37] <moritz_> rakudo: say (1..10).grep(3|6)

[15:37] <p6eval> rakudo 1eef08: OUTPUT«36␤»

[15:37] <moritz_> rakudo: say (1..10).grep(3|6).join(', ')

[15:37] <p6eval> rakudo 1eef08: OUTPUT«3, 6␤»

[15:38] <tedv> rakudo: say (1..10).grep(3|6|25)

[15:38] <p6eval> rakudo 1eef08: OUTPUT«36␤»

[15:38] <moritz_> ok, it's a fairly contrived example

[15:38] <tedv> the more interesting case

[15:38] <tedv> so that's useful for set intersection

[15:38] <[particle]> rakudo: say (1..10).grep(6|3|6..8).join(', ')

[15:38] <p6eval> rakudo 1eef08: OUTPUT«3, 4, 5, 6, 7, 8␤»

[15:38] <moritz_> rakudo: say (1..10).grep({$_ < 8}|{$_ % 2}).join(', ')

[15:38] <p6eval> rakudo 1eef08: OUTPUT«1, 2, 3, 4, 5, 6, 7, 9␤»

[15:38] <[particle]> *cough*

[15:38] <moritz_> rakudo: say (1..10).grep({$_ < 8}&{$_ % 2}).join(', ')

[15:38] <p6eval> rakudo 1eef08: OUTPUT«1, 3, 5, 7␤»

[15:38] <[particle]> i ran afoul of precedence

[15:38] <moritz_> look ma, junctions of code blocks

[15:39] <[particle]> rakudo: say (1..10).grep(6|3|(6..8)).join(', ')

[15:39] <p6eval> rakudo 1eef08: OUTPUT«3, 6, 7, 8␤»

[15:39] <TimToady> rakudo: say ~(1..10).grep: 2 | /0/

[15:39] <p6eval> rakudo 1eef08: OUTPUT«2 10␤»

[15:40] *** molaf joined
[15:40] <TimToady> rakudo: say $*IN ~~ :r & :f

[15:40] <p6eval> rakudo 1eef08: OUTPUT«Method 'r' not found for invocant of class 'IO'␤current instr.: 'perl6;Enum;ACCEPTS' pc 508921 (src/gen/core.pir:78424)␤»

[15:40] <TimToady> aww

[15:40] <TimToady> rakudo: say $*IN ~~ :e & :f

[15:40] <p6eval> rakudo 1eef08: OUTPUT«Method 'e' not found for invocant of class 'IO'␤current instr.: 'perl6;Enum;ACCEPTS' pc 508921 (src/gen/core.pir:78424)␤»

[15:41] <TimToady> rakudo: say "/etc/passwd" ~~ :e & :f

[15:41] <p6eval> rakudo 1eef08: OUTPUT«1␤»

[15:41] <[particle]> rakudo: IO.^methods.say

[15:41] <p6eval> rakudo 1eef08:

[15:41] <p6eval> ..OUTPUT«eofinslinessayprintgetgetcprintftcloseslurpfmtbytesacosecsinhNumericasinhcosechtrimasectrim-leadingchracotanhfloorsechasechrandtruncateroundsqrtasinsplitmatchexpcoshacoshwordssigncotanatan2lcfirstseccislogsamecasesprintfcapitalizesinflipp5choplcsubstacosechabsacotanchompindexceilin…

[15:41] <TimToady> which isn't quite right

[15:41] <moritz_> yes, it's still auld style in rakudo

[15:41] <TimToady> but illustrates the junctional matching of file tests

[15:43] <TimToady> as for autothreading, if a set in list context returns its elements, then any of the other autothreaders can be used with sets

[15:43] <TimToady> any(%set) == 42

[15:44] <dalek> csmeta: r240 | diakopter++ | trunk/Sprixel/src/Perlesque/Declarations.cs:

[15:44] <dalek> csmeta: [perlesque] fix ConstantValue

[15:44] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=240

[15:44] <TimToady> or, with the conjectural each(), Set(each(%set) + 1)

[15:44] *** molaf left
[15:45] <TimToady> but making sets autothread natively might or might not make sense

[15:46] <TimToady> at one time there was speculation that ranges would autothread

[15:46] <diakopter> spinclad: hi

[15:47] <TimToady> maybe autothreading is a mixin of some sort, someday

[15:47] <TimToady> except a mixin should be knocking the type of the object around

[15:47] <TimToady> and autothreading means putting the type outside of Any

[15:49] <diakopter> perlesque: my List[int] $l; $l.Add(2); say($l); # yay, it does the right thing now (NRE)

[15:49] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.NullReferenceException: Object reference not set to an instance of an object␤  at TopLevelFrame.Exec () [0x00000] in <filename unknown>:0 ␤  at

[15:49] <p6eval> ..F…

[15:49] <dalek> csmeta: r241 | diakopter++ | trunk/Sprixel/ (3 files):

[15:49] <dalek> csmeta: [perlesque] more fixes

[15:49] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=241

[15:49] <dalek> csmeta: r242 | diakopter++ | trunk/Sprixel/src/Perlesque/Declarations.cs:

[15:49] <dalek> csmeta: [perlesque] remove debug

[15:49] <dalek> csmeta: review: http://code.google.com/p/csmeta/source/detail?r=242

[15:58] *** justatheory joined
[16:02] *** PerlJam left
[16:02] *** PerlJam joined
[16:05] *** kst left
[16:11] *** kst joined
[16:12] *** pmurias joined
[16:13] <pmurias> diakopter: hi

[16:15] *** cdarroch joined
[16:15] *** cdarroch left
[16:15] *** cdarroch joined
[16:18] *** [mark] left
[16:19] *** pmurias left
[16:20] *** jonasbn left
[16:21] *** pmurias joined
[16:24] <pmurias> ruoso: hi

[16:24] <diakopter> hiu

[16:24] <pmurias> diakopter: did you get -Bperlesque to work?

[16:26] <pmurias> fixing mildew...

[16:28] <pugssvn> r30564 | pmurias++ | [mildew] add dependencies to dist.init 

[16:28] <pugssvn> r30565 | pmurias++ | [mildew] update to work with current perlesque 

[16:31] *** mikehh left
[16:31] <ruoso> pmurias, hi...

[16:33] <pmurias> if Mildew::Backend::Perlesque requires a path to Perlesque to work how can i feed it early enough so that it can run tests?

[16:34] *** stephenlb joined
[16:34] <pmurias> ruoso: and one problem with loading VAST nodes using Module::Pluggable is if a VAST node is removed and the user install a new Mildew version on top of an old one

[16:35] *** mikehh joined
[16:38] *** envi^home left
[16:39] *** lichtkind joined
[16:40] <lichtkind> colomon: .triangle is alias to [/ ] ?

[16:41] <moritz_> that doesn't look right

[16:41] <moritz_> triangle is [\op]

[16:43] <moritz_> and rakudo current implements that as reduce(..., :triangle) or so

[16:45] <diakopter> pmurias: I guess just assume it's in the PATH

[16:46] <diakopter> pmurias: at least assume that mono is in the PATH

[16:46] <diakopter> so maybe perlesque.exe's path is in PATH_PERLESQUE

[16:46] <diakopter> I dunno.

[16:47] *** isBEKaml joined
[16:50] <lichtkind> moritz_: yes i mistyped it, i meant [\ op]

[16:50] <moritz_> and no space allowed :-)

[16:50] *** molaf joined
[16:51] <lichtkind> grtsch

[16:51] <pmurias> diakopter: is it possible to install mono generated executables in the path?

[16:52] <diakopter> actually yes in linux you can register .exe as binary executable

[16:53] <diakopter> but it's a lot slower

[16:53] <diakopter> than a shell script wrapper

[16:53] <diakopter> but of course you lose most the shell args

[16:53] *** BrowserUk left
[16:53] <pmurias> diakopter: when do i loose the shell args?

[16:53] <diakopter> I don't know.

[16:54] <pmurias> in a shell script wrapper i get to keep them

[16:54] <diakopter> I guess I don't know how to pass-thru "all of my args" to another invocation

[16:54] <huf> via shell? "$@"

[16:54] <diakopter> ok.

[16:54] <diakopter> oh. :)  /me ignorant in these ways

[16:55] <huf> dont worry, the shell's a dick anyway

[16:55] <diakopter> in cmd.exe it's %*

[16:56] <pmurias> so maybe assuming a perlesque in the shell is sensible?

[16:56] <pmurias> s/shell/PATH/

[16:57] <diakopter> sure, if there's a perlesque that's a #!/bin/sh  wrapper

[16:57] <diakopter> for mono /path/to/perlesque.exe

[16:57] <diakopter> mono /path/to/perlesque.exe "$@"

[17:02] *** meppl left
[17:02] *** BrowserUk joined
[17:03] *** jjore left
[17:03] <ruoso> pmurias, hmmm... each VAST node could refuse to load if Mildew version is not X

[17:04] *** patspam joined
[17:05] *** sorear left
[17:05] *** sorear joined
[17:07] *** pmurias left
[17:11] *** jjore joined
[17:11] *** buubot left
[17:12] *** buubot joined
[17:12] *** kst left
[17:13] *** kst joined
[17:14] *** ktne left
[17:15] *** rgrau_ left
[17:17] *** jjore left
[17:21] <sorear> phenny: tell masak that "may get lost" means "will get lost"

[17:21] <phenny> sorear: I'll pass that on when masak is around.

[17:29] *** dakkar left
[17:30] <colomon> lichtkind: moritz_++ has it right.

[17:30] <isBEKaml> moritz_: There's a small thing in proto's index.tmpl that appears to be a typo. causes justified paragraph to be displayed in hanging text. Was that intended? 

[17:30] <lichtkind> colomon: thanks

[17:31] *** patspam left
[17:31] <isBEKaml> moritz_: #about p... :)

[17:32] *** patspam joined
[17:33] *** patspam left
[17:38] <jnthn> o/ folks

[17:38] * jnthn is back from the Icelandic countryside

[17:38] <isBEKaml> jnthn: yo!

[17:39] <jnthn> No internets out there. :-)

[17:40] <isBEKaml> must have been quite a relief... ;)

[17:40] * isBEKaml hides... 

[17:41] <jnthn> I enjoyed it. :-)

[17:41] <jnthn> For a few days.

[17:41] <jnthn> :-)

[17:42] <jnthn> Just hiked, camped, relaxed. :-)

[17:43] <colomon> :)

[17:43] <isBEKaml> :)

[17:43] <TimToady> :)

[17:43] <diakopter> :  )

[17:43] <TimToady> why the long face?

[17:43] <isBEKaml> maybe he has a really long face.. ;)

[17:43] <isBEKaml> he smiles well.. :D

[17:51] <diakopter> the better to smell you with

[17:52] *** sundar_afk joined
[17:52] *** rv2733 left
[17:53] *** sundar_afk is now known as sundar

[17:57] *** jonasbn joined
[17:58] *** jonasbn left
[17:58] <tedv> newbie question: if I run "make spectest" from a rakudo checkout, will that automatically load the latest version of the pugs unit tests, or do I need to do that myself?

[18:01] <jnthn> It automaticky does an svn up (or an svn co the first time), so you get the latest.

[18:01] <jnthn> *automatically

[18:01] <jnthn> ga

[18:01] * jnthn needs to learn to type again

[18:01] <pugssvn> r30566 | lwall++ | [S03] small clarifications to usage of brackets around infixes 

[18:01] <TimToady> blame it on the ash in the keyboard

[18:02] <jnthn> ;-)

[18:02] <jnthn> I actually have seen The Volcano.

[18:02] <jnthn> I still can't pronounce its name, however.

[18:03] <TimToady> tedv: were you the one who was asking about whitespace in metaoperators the other day?  I'd write those as >>[op]>> instead.

[18:04] <TimToady> rakudo: say ~( (1,2,3) >>[=>]>> 42 )

[18:04] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "say ~( (1,"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[18:04] *** cognominal left
[18:04] <TimToady> well, I would if rakudo recognized it :)

[18:04] <TimToady> std: say ~( (1,2,3) >>[=>]>> 42 )

[18:04] <p6eval> std 30565: OUTPUT«ok 00:01 113m␤»

[18:05] <colomon> rakudo: say ~( (1,2,3) »=>» 42 )

[18:05] <p6eval> rakudo 1eef08: OUTPUT«1  42 2    42 3    42␤»

[18:05] <colomon> rakudo: say ( (1,2,3) »=>» 42 ).perl

[18:05] <p6eval> rakudo 1eef08: OUTPUT«[1 => 42, 2 => 42, 3 => 42]␤»

[18:05] <TimToady> btw, shortest way to get a bunch of true hash values is likely %hash{@keys}»++

[18:05] <tedv> TimToady: Yes, I was, primarily because of how >>=>>> loops

[18:05] <tedv> looks*

[18:05] <diakopter> rakudo: say ( (1,2,3) >>=>>> 42 ).perl

[18:05] <p6eval> rakudo 1eef08: OUTPUT«[1 => 42, 2 => 42, 3 => 42]␤»

[18:06] <tedv> but that's more because I'm a dirty American without chevrons on my keyboard.

[18:06] <colomon> TimToady: That's "true" but not "True", right?

[18:06] <tedv> I suppose >>[=>]>> is clearer

[18:06] <diakopter> std: say ( (1,2,3) >>=>>> 42 ).perl

[18:06] <p6eval> std 30565: OUTPUT«ok 00:01 111m␤»

[18:06] <diakopter> o_O

[18:06] <colomon> rakudo: say ( (1,2,3) >>=>>> 42 ).perl

[18:06] <p6eval> rakudo 1eef08: OUTPUT«[1 => 42, 2 => 42, 3 => 42]␤»

[18:06] <TimToady> std: say ~( (1,2,3) >>>>> 42 )

[18:06] <p6eval> std 30565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing << or >> at /tmp/zudoOoseH6 line 1:␤------> [32msay ~( (1,2,3) >>>>>[33m⏏[31m 42 )[0m␤    expecting infix_circumfix_meta_operator__S_267LtLt_GtGt␤Parse failed␤FAILED 00:01 111m␤»

[18:06] <TimToady> hmm

[18:06] <TimToady> std: say ~( (1,2,3) >>[>]>> 42 )

[18:06] <p6eval> std 30565: OUTPUT«ok 00:01 111m␤»

[18:07] <TimToady> rakudo: say ~( (1,2,3) >>[>]>> 42 )

[18:07] <p6eval> rakudo 1eef08: OUTPUT«Confused at line 11, near "say ~( (1,"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[18:07] *** jjore joined
[18:07] <jnthn> Didn't implement that form just yet.

[18:07] <TimToady> oh, yeah

[18:07] <jnthn> It's easy enough, I suspect.

[18:07] *** patspam joined
[18:07] <diakopter> std: say ~( (1,2,3) >>[=<]>> 42 )

[18:07] <TimToady> just recursion in the infixish rule

[18:07] <tedv> is >>>>> supposed to work?  I wouldn't be surprised if that just happened to be indistiguishable to the parser for some reason

[18:07] <p6eval> std 30565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse bracketed infix at /tmp/V6iCrxUsDj line 1:␤------> [32msay ~( (1,2,3) >>[[33m⏏[31m=<]>> 42 )[0m␤Couldn't find final ']'; gave up at /tmp/V6iCrxUsDj line 1:␤------> [32msay ~( (1,2,3) >>[=[33m⏏[31m<]>> 42 )[0m␤Parse

[18:07] <p6eval> ..failed␤FAILE…

[18:07] <colomon> rakudo: say ( (1,2,3) >><>> 42 ).perl

[18:07] <p6eval> rakudo 1eef08: OUTPUT«[Bool::True, Bool::True, Bool::True]␤»

[18:08] <tedv> can you unspace it too?

[18:08] <TimToady> not currently, I don't think

[18:08] <tedv> rakudo: say ( (1,2,3) >>\ >\ >> 42 ).perl

[18:08] <p6eval> rakudo 1eef08: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 11␤current instr.: 'perl6;Regex;Cursor;FAILGOAL' pc 1696 (ext/nqp-rx/src/stage0/Regex-s0.pir:932)␤»

[18:08] <TimToady> not sure it really helps readibility, over [op]

[18:08] <tedv> yeah

[18:08] <tedv> clearly not in that case

[18:09] <TimToady> [op] makes a nice "pill"

[18:09] <tedv> I got the impression that unspace was most useful when you have a long list of foo.bar foo.baz, and want everything to line up nicely

[18:09] <jnthn> TimToady: Aye, I or @other will no doubt get to it in due course. :-)

[18:09] <tedv> er foo.bar and longfoobar.bar

[18:10] * jnthn is feeling more healthy and relaxed than he has for ages, and will be back and hacking in a couple of days. :-)

[18:10] *** ShaneC1 joined
[18:10] *** ShaneC1 left
[18:10] <TimToady> since unspace has to be checked for specifically in the grammar, I tend not to put it in any old where

[18:10] <TimToady> but only where there's demand

[18:10] <TimToady> and no better way to do it

[18:11] <tedv> I think it's the type of feature that will become more expected with language age, but won't see much use in the beginning.

[18:11] <TimToady> its primary use is to put whitespace before a postfix, really

[18:11] <tedv> what I like about perl 6 is the sheer amount of operators that encode algorithms that are simple to describe in natural language

[18:11] <tedv> like "add the numbers in this list"

[18:11] <tedv> [+] @x

[18:12] <tedv> Except if you're programming in C your whole life, you probably thought something more like...

[18:12] <tedv> int total = 0; for (int i = ......

[18:12] <tedv> and it takes time for people to think using new operators

[18:12] <tedv> unspace kind of seems the same to me

[18:12] <Juerd> tedv: I think most people think sum(@x)

[18:13] <diakopter> TimToady: for the strongly-typed (including user classes) subset of Perl 6, I need some way of representing up-casting and down-casting

[18:13] <tedv> okay well I'm sure I can find a more complicated example that doesn't have a natural foo() wrapping function

[18:14] <tedv> any kind of cartesian list joining for example

[18:14] <diakopter> TimToady: .. just casting, I mean.  obviously the type-checker/compiler knows whether it's going to down-cast or up-cast

[18:14] <Juerd> tedv: [<=]

[18:15] <colomon> rakudo: say ([=>] 1..10).perl

[18:15] <p6eval> rakudo 1eef08: OUTPUT«1 => 2 => 3 => 4 => 5 => 6 => 7 => 8 => 9 => 10␤»

[18:15] <TimToady> diakopter: what's the problem with MyType($thing)?

[18:15] <diakopter> oh

[18:15] <diakopter> forgot about that

[18:16] <colomon> What does MyType($thing) do?

[18:16] <diakopter> that's certainly better than (MyType)$thing

[18:16] <TimToady> rakudo: say Str(42).WHAT

[18:16] <p6eval> rakudo 1eef08: OUTPUT«Could not find sub &Str␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[18:16] <TimToady> hmm

[18:16] <TimToady> rakudo: say 42.Str.WHAT

[18:16] <p6eval> rakudo 1eef08: OUTPUT«Str()␤»

[18:16] <TimToady> same as that, in theory

[18:17] <diakopter> std: say str(42).WHAT

[18:17] <p6eval> std 30565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'str' used at line 1␤Check failed␤FAILED 00:01 110m␤»

[18:17] <diakopter> oops

[18:17] <diakopter> std: say buf8(42).WHAT

[18:17] <p6eval> std 30565: OUTPUT«ok 00:01 110m␤»

[18:17] <diakopter> std: say int128(42).WHAT

[18:17] <p6eval> std 30565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤      'int128' used at line 1␤Check failed␤FAILED 00:01 110m␤»

[18:18] <diakopter> microsoft has 128-bit windows running on something from Intel, supposedly

[18:18] <TimToady> std: say int64(42).WHAT

[18:18] <p6eval> std 30565: OUTPUT«ok 00:01 110m␤»

[18:18] *** rv2733 joined
[18:22] *** kst left
[18:22] *** meppl joined
[18:22] <pugssvn> r30567 | lwall++ | [S09] speculate 128-bit types and see if we get away with it 

[18:23] *** kst joined
[18:25] <pugssvn> r30568 | lwall++ | [STD] use same rules for interpolating @foo[] into regex 

[18:25] <pugssvn> r30568 | [CORE] add some 128-bit types

[18:27] <diakopter> hah

[18:28] <diakopter> you don't think Unicode will go 128-bit? :P

[18:29] <mathw> Depends... how close are they to using up the 64 bit space? :)

[18:29] *** molaf left
[18:29] <diakopter> .oO( I think everyone on the planet needs each's own glyph )Oo.

[18:30] <diakopter> (kidding)

[18:31] <PerlJam> diakopter: you kid, but one day it will be so.

[18:32] *** k23z__ left
[18:32] *** jjore left
[18:34] <Juerd> diakopter: Every grain of sand can has its own with 128 bits I guess :)

[18:35] *** jjore joined
[18:37] <TimToady> me tries to picture an application that maps between glyphs and IPv6 addrs

[18:38] <Su-Shee> well you'll just compare ::::::::: and everything else is easily filled by masks. ;)

[18:38] <slavik1> Microsoft can write code for ARM ... they wrote something for 128bit?

[18:39] <diakopter> nt was built for arm & ppc, yeah

[18:43] *** patrickas joined
[18:46] *** patrickas left
[18:49] <diakopter> hrm. us stock markets down 11%.

[18:50] <colomon> ouch

[18:51] <diakopter> er, sorry, down only 8.5%.  but it's now recovered to down 6%

[18:52] *** patrickas joined
[18:54] <colomon> that's still plenty bad.

[18:55] <moritz_> something's wrong with stock markets in general

[18:55] <moritz_> if within one day the economy loses 8% of its value

[18:55] <diakopter> google finance crashed

[18:55] <colomon> CNN thinks it is Greece.

[18:55] <moritz_> or the perceived value

[18:56] *** cognominal joined
[18:59] <diakopter> price := perceived value

[19:01] <moritz_> even then

[19:06] <TimToady> part of the valuation is betting on whether a fourth catastrophe would compound the current three

[19:06] * moritz_ doesn't know which counting scheme produces three current catastrophies

[19:07] <TimToady> I'm counting Greece, Iceland, and the Gulf of Mexico

[19:07] <[particle]> you forgot PHP

[19:07] <moritz_> 1) situation in Iraq 2) Situation in Afghanistan 3) general financial 4) Gulf of Mexico 5) Greece

[19:08] <Su-Shee> welcome to the world of 2500 years of educated crystal ball polishing :)

[19:08] <TimToady> 1 & 2 are long-term situations already fed into the equation

[19:09] *** tri1 joined
[19:10] <moritz_> in terms of human casualties 1 & 2 are much more severe than Greece by far

[19:10] <TimToady> I'm referring more to things that were unexpected 3 months ago

[19:10] <moritz_> ok :-)

[19:11] <TimToady> well, obviously Greece has been festering for longer than that too

[19:11] <moritz_> phenny: tell masak I'm inclined to reject maspalio++'s patch that changes the proto web script to Web::Scraper. Reason: the documentation of Web::Scraper is so incomplete that I don't think I could maintain that script. Thoughts?

[19:11] <phenny> moritz_: I'll pass that on when masak is around.

[19:11] <Su-Shee> moritz_: in terms of politics, they're the usal run-of-the-mill middle east stuff. remember that there already were like 20 years of sowjets in afghanistan. 

[19:13] <[particle]> greece has been festering, and ireland was on the brink but is recovering.  portugal and spain aren't so lucky

[19:13] <patrickas> moritz_ too bad about Web::Scraper, parsing HTML through using a regex is unfortunately going to stay there for longer than I would have hoped!

[19:18] <TimToady> anyway, to bring this back on topic, we need to raise the perceived value of Perl 6 :)

[19:18] *** Ross left
[19:22] <[particle]> a well-marketed and community-supported release of a perl 6 compiler will certainly raise the perceived value

[19:23] * Su-Shee just had the word "brand" on her keyboard. :)

[19:23] <pugssvn> r30569 | lwall++ | [sigspace.t] don't use [abc] to mean 'abc' since it looks like old-school character class 

[19:26] <pugssvn> r30570 | lwall++ | [repeat.t] don't use [abc] to mean 'abc' since it looks like old-school character class 

[19:31] <pugssvn> r30571 | lwall++ | [basic.t] same thing, change [ed] to 'ed' 

[19:32] *** cognominal left
[19:35] <moritz_> patrickas: I know, but I can at least maintain them

[19:36] <moritz_> patrickas: if others mostly agree that moving to Web::Scrape is a good thing, then I'm fine with it

[19:37] *** kst left
[19:37] <pugssvn> r30572 | lwall++ | [rx.t] more appearance-of-cclass warning suppression 

[19:37] <patrickas> moritz_: Unfortunately I have no idea about Web::Scrape

[19:38] *** kst joined
[19:42] *** Ross^ joined
[19:43] <pugssvn> r30573 | lwall++ | [99problems-61-to-70.t] move sub count outside of its block so it's visible to later blocks 

[19:43] *** ash_ joined
[19:45] *** meppl left
[19:46] <pugssvn> r30574 | lwall++ | [99problems-21-30.t] move sub combination outside of its block so it's visible to later blocks 

[19:46] *** ash_ left
[19:53] *** Ross^ left
[19:54] *** Ross^ joined
[19:55] *** ash_ joined
[19:55] <pugssvn> r30575 | moritz++ | [t/spec] fudge mixin.t for rakudo 

[20:00] <pugssvn> r30576 | moritz++ | [t/spec] fudge BUILD.t for rakudo 

[20:00] <dalek> rakudo: 5713af2 | moritz++ | t/spectest.data:

[20:00] <dalek> rakudo: run two more test files

[20:00] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5713af2b2bb682f64b56710731cbfd5cb023f522

[20:01] <colomon> i\o/

[20:01] <colomon> what's the passing count now?

[20:01] <ash_> rakudo: use MONKEY_TYPING; augment grammar Perl6::Grammar { }; 

[20:01] <moritz_> >before :-)

[20:01] <p6eval> rakudo 1eef08: OUTPUT«Method 'compose' not found for invocant of class ''␤current instr.: 'perl6;Perl6;Grammar;!class_init_11' pc 352 (EVAL_1:27504175)␤»

[20:02] <moritz_> ash_: Perl6::Grammar is an nqp-level class, and not built with the "right" meta model

[20:02] <ash_> I figured as much 

[20:02] <ash_> still shouldn't die like that... i don't think 

[20:03] <moritz_> right

[20:04] <ash_> rakudo: slang Foo { }; # also acts funny 

[20:04] <p6eval> rakudo 1eef08: OUTPUT«Could not find sub &Foo␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[20:04] *** Ross^ is now known as Ross

[20:05] <moritz_> it just parses both slang and Foo as sub calls

[20:05] <moritz_> and dies at the one that's executed earlier

[20:05] <ash_> ah, i  didn't realize it was parsing slang as a sub call

[20:05] <ash_> i figured Foo was, but not slang

[20:05] <moritz_> any bareword that's not recognized somehow is parsed as a listop/subcall

[20:08] <ash_> I was trying to see if any of docs/metamodel.pod's examples worked 

[20:08] <ash_> I also just noticed that in one of the examples in the file someone wrote a '.' for string concat, i think 

[20:09] <ash_> http://github.com/rakudo/rakudo/raw/master/docs/metamodel.pod line 296 

[20:10] <moritz_> aye

[20:10] *** cognominal joined
[20:11] *** lisppaste3 left
[20:11] *** lisppaste3 joined
[20:12] <TimToady> std: Str => $name . ⏏"()"

[20:12] <p6eval> std 30575: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $name is not predeclared at /tmp/eDEklNOq3f line 1:␤------> [32mStr => $name[33m⏏[31m . ⏏"()"[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/eDEklNOq3f line 1:␤------> [32mStr => $name .

[20:12] <p6eval> ..[33m⏏[31m⏏"()"[…

[20:12] <TimToady> std: Str => $name . "()"

[20:12] <p6eval> std 30575: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $name is not predeclared at /tmp/iqEIeV0zTz line 1:␤------> [32mStr => $name[33m⏏[31m . "()"[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/iqEIeV0zTz line 1:␤------> [32mStr => $name .

[20:12] <p6eval> ..[33m⏏[31m"()"[0m…

[20:12] <dalek> rakudo: badc61d | moritz++ | docs/metamodel.pod:

[20:12] <dalek> rakudo: [docs] perl5o found by ash_++

[20:12] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/badc61dd27d4978781199556dc5b842943e7267f

[20:13] <ash_> i know you can use $foo.?bar(); to try to call bar if it exists, is there a way to do that with a sub too? 

[20:14] <ash_> for instance, module Baz { our sub bar { ... } }; Baz::?bar(); or something? 

[20:14] <moritz_> try { bar() } :-)

[20:15] <ash_> what if i don't know which package its in? try { my $a = 'PackageName'; $a::bar() } ?

[20:15] *** kst left
[20:15] <moritz_> $::($a)::bar() iirc

[20:16] <TimToady> subs are not called from packages

[20:16] <TimToady> they are in lexical scopes

[20:16] <moritz_> unless they are 'our', no?

[20:16] <TimToady> then it's the lexical alias that is called

[20:16] <TimToady> the dispatcher never looks in the package these days

[20:16] <TimToady> unless you specifically tell it to

[20:17] *** clintongormley left
[20:17] <ash_> rakudo: module Foo { our sub bar { say 'bar' } }; my $a = 'Foo'; $::($a)::bar(); # so that is not correct? 

[20:17] <p6eval> rakudo 1eef08: OUTPUT«Indirect name lookups not yet implemented at line 11, near "::bar(); #"␤current instr.: 'perl6;HLL;Grammar;panic' pc 501 (ext/nqp-rx/src/stage0/HLL-s0.pir:327)␤»

[20:17] *** tri1 left
[20:17] <TimToady> that is explicitly telling it to look in a package

[20:17] <TimToady> so that's okay

[20:18] <ash_> okay

[20:18] <TimToady> I was complaining about try { bar() } which always knows at compile time

[20:18] <ash_> oh, got ya

[20:19] <ash_> I am just trying to see what else might be missing if I wanted to make a custom metaclass to support my own phasers

[20:19] <TimToady> we'd like our candidate lists to be static by default

[20:19] <TimToady> as soon as you put a mutable package there, the lists are no longer static

[20:20] *** snearch joined
[20:21] <TimToady> there are various ways to force the lookup to wait until run time, and those can run as slow as they like. :)

[20:22] <TimToady> so I don't care if, say, ::($name)() looks in the current package, if it can't find it lexically

[20:23] <TimToady> we'd just like the default to be highly optimizable

[20:23] <ash_> that makes sense

[20:23] <ash_> make the common case fast 

[20:23] <moritz_> colomon: current test case: 31871

[20:24] <moritz_> *count

[20:24] *** kst joined
[20:24] <colomon> moritz_: damn, do I wish I didn't have pressing $work stuff, so I could go after those next 129....

[20:25] <patrickas> how come http://rakudo.de/progress.png seems to be really not up to date!

[20:28] *** Su-Shee left
[20:28] <Tene> patrickas: it's updated by hand, and the person who does that has been otherwise busy.

[20:33] *** SmokeMachine left
[20:33] <colomon> moritz_: interestingly, got 31876 passes here.

[20:34] *** chitragupt left
[20:37] <ash_> which any glaring issues with http://gist.github.com/392673 as a possible functionality of COMPOSED and INHERITED ? 

[20:40] *** [Coke] left
[20:41] *** patrickas left
[20:44] *** cdarroch left
[20:44] *** snearch left
[20:46] *** [Coke] joined
[20:52] *** SmokeMachine joined
[21:01] *** orafu left
[21:01] *** orafu joined
[21:15] *** Trashlord left
[21:17] *** wknight8111 joined
[21:17] *** kst left
[21:17] <sjohnson> 2hi dudes

[21:19] <lichtkind> hai

[21:19] <sjohnson> ... perl.  is there anything it can't do?

[21:20] *** Sumeragi joined
[21:23] *** Ross left
[21:25] *** kst joined
[21:28] *** astinus left
[21:28] *** chitragupt joined
[21:29] *** astinus joined
[21:29] *** KyleHa joined
[21:31] <KyleHa> rakudo: if Nil.defined { say "yes Nil.defined" } else { say 'no Nil.defined' }; if NIl.defined ~~ True { say 'yes Nil.defined ~~ True' } else { say 'no Nil.defined ~~ True' }

[21:31] <p6eval> rakudo 1eef08: OUTPUT«no Nil.defined␤Could not find sub &NIl␤current instr.: '_block14' pc 29 (EVAL_1:0)␤»

[21:31] <KyleHa> f Nil.defined { say "yes Nil.defined" } else { say 'no Nil.defined' }; if Nil.defined ~~ True { say 'yes Nil.defined ~~ True' } else { say 'no Nil.defined ~~ True' }

[21:31] <KyleHa> rakudo: if Nil.defined { say "yes Nil.defined" } else { say 'no Nil.defined' }; if Nil.defined ~~ True { say 'yes Nil.defined ~~ True' } else { say 'no Nil.defined ~~ True' }

[21:31] <p6eval> rakudo 1eef08: OUTPUT«no Nil.defined␤yes Nil.defined ~~ True␤»

[21:32] <KyleHa> What's going on here?

[21:32] <KyleHa> I'd expect those two to agree.

[21:33] *** sundar left
[21:34] *** cdarroch joined
[21:34] *** cdarroch left
[21:34] *** cdarroch joined
[21:34] *** Sumeragi left
[21:36] <sjohnson> i think there are two types of perl people.  ones who match with /string/, and ones who use m/string/.  i am the latter

[21:37] <sjohnson> you can tell a lot about a man (or woman) by which camp they belong to in this case

[21:37] *** Guest13256 left
[21:38] <Tene> what about those that match with m{} ?

[21:39] <sjohnson> i was JUST going to say

[21:39] <sjohnson> that

[21:39] <sjohnson> using m{} with paths is the WAY to perl happiness

[21:42] <Juerd> I prefer m[] over m{}

[21:43] <Juerd> And I use s[][], but s[]{}e

[21:48] <sjohnson> hmm, maybe i'll start using the square brackets

[21:49] <Juerd> vim doesn't highlight it well but I've gotten used to that.

[21:50] <Juerd> Delimiting strings or regexes with {} feels like Tcl to me :)

[21:50] <Juerd> I don't like tcl

[21:51] *** KyleHa left
[21:53] <arnsholt> Juerd: What's the problem with vim's highlighting of brackets?

[21:55] <Juerd> arnsholt: It highlights the RHS of s[][] as code instead of string contents

[21:55] <Juerd> That is, sometimes. Most of the time it just works

[21:56] <Juerd> When it doesn't, scrolling forth and back usually fixes it

[21:56] <arnsholt> I see

[21:56] *** ruoso left
[21:56] <arnsholt> Confuses it with array deref I suppose

[21:56] *** isBEKaml left
[21:57] <Juerd> Oh, and when you use non-equal delimiter pairs it doesn't highlight the second one as a string

[21:57] <Juerd> But don't fix that. I've come to rely on it, for s[]{}e :)

[21:57] *** iblechbot left
[21:57] <diakopter> std: sub s() { }; s{4}{4}

[21:57] <p6eval> std 30576: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/iVUe8lrlIY line 1:␤------> [32msub s() { }; s{4}[33m⏏[31m{4}[0m␤    expecting any of:␤    bracketed infix␤  infix or meta-infix␤     

[21:57] <p6eval> ..quantifier␤Parse…

[21:58] <arnsholt> Juerd: Nice one. Good exploitation of a bug and turning it into a feature =)

[22:00] <Juerd> http://juerd.nl/i/1b2f35cb05486cf1beaab6ce2e648708.png  # example

[22:00] <Juerd> Oh, and it doesn't understand qq[]

[22:00] <Juerd> I almost forgot that one

[22:02] *** SmokeMachine left
[22:04] <diakopter> std: s{4}{4}

[22:04] <p6eval> std 30576: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/3IdmycEol5 line 1:␤------> [32ms{4}[33m⏏[31m{4}[0m␤    expecting any of:␤ bracketed infix␤  infix or meta-infix␤      quantifier␤Parse

[22:04] <p6eval> ..failed␤FAILE…

[22:04] <diakopter> std: s[4]{4}

[22:04] <p6eval> std 30576: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/Ph9bfExBaW line 1:␤------> [32ms[4][33m⏏[31m{4}[0m␤    expecting any of:␤ bracketed infix␤  infix or meta-infix␤      quantifier␤Parse

[22:04] <p6eval> ..failed␤FAILE…

[22:04] <diakopter> std: s[4]{4}e

[22:04] <p6eval> std 30576: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/ArZSlpVD7E line 1:␤------> [32ms[4][33m⏏[31m{4}e[0m␤    expecting any of:␤        bracketed infix␤  infix or meta-infix␤     

[22:04] <p6eval> ..quantifier␤Parse failed␤FAIL…

[22:05] *** [particle] left
[22:11] *** hercynium joined
[22:13] <sjohnson> Juerd: you probably noticed some hilight problems which is to be expected... with v5.10.0 stuff

[22:15] <Juerd> 5.10.0 of what?

[22:17] *** alester left
[22:27] *** kst left
[22:27] *** kst joined
[22:35] <sjohnson> Juerd: given / when || say call in perl 5.10.0

[22:36] <Juerd> I don't use those yet

[22:36] <aesop> use what?

[22:39] <ash_> perl 5.12 is out, I rather like some of its changes, small things, like use v5.12; also does use strict; 

[22:40] <snarkyboojum> rakudo: say 'Perl 6'.pred ~ '.10+ features'

[22:40] <p6eval> rakudo 1eef08: OUTPUT«Perl 5.10+ features␤»

[22:42] <ash_> they added the ... 'yada yada' op in 5.12 from perl6  

[22:42] <Juerd> ash_: I'm not too happy about the optional bugfix.

[22:43] <Juerd> A bugfix that can be enabled lexically

[22:43] <Juerd> Which means that if you do enable it, it still doesn't work correctly in modules.

[22:44] <ash_> I am not sure what you mean, which optional bugfix? 

[22:45] <Juerd> ash_: use feathure 'unicode_strings'

[22:45] <Juerd> s/feathure/feature/

[22:45] *** ethel left
[22:46] *** snarkyboojum left
[22:46] <ash_> ah, the unicode updates 

[22:47] <Juerd> If I understand correctly, the regex charclasses are changed regardless of the pragma

[22:47] <Juerd> But I haven't tried 5.12 yet

[22:56] *** nihiliad left
[23:04] *** jhuni joined
[23:13] *** chitragupt left
[23:14] *** chitragupt joined
[23:20] *** chitragupt left
[23:21] *** chitragupt joined
[23:23] *** kst left
[23:36] *** kst joined
[23:36] *** chitragupt left
[23:37] *** chitragupt joined
[23:47] *** TiMBuS joined
[23:47] *** [particle] joined
[23:47] <lichtkind> i currently do :)

[23:47] <sorear> I'd like to see an editor with STD-highlighting

[23:48] <lichtkind> you speak to me?

[23:48] <sorear> (Does anyone know what's wrong with STD_highlight?  It crashes when fed STD.pm6, yet STD.pm6 can parse itself)

[23:49] *** kst left
[23:50] *** kst joined
[23:50] *** ruoso joined
[23:51] <diakopter> sorear: I think STD_highlight got bitrotten

[23:58] *** lestrrat is now known as lest_away

[23:59] <sjohnson> rakudo: say " cow ".trim-trailing

[23:59] <p6eval> rakudo 1eef08: OUTPUT« cow␤»

[23:59] <sjohnson> rakudo: say " cow ".trim-leading

[23:59] <p6eval> rakudo 1eef08: OUTPUT«cow ␤»

[23:59] <sjohnson> rakudo: say (" cow ", " pig ", " chicken").trim-leading

[23:59] <p6eval> rakudo 1eef08: OUTPUT«cow   pig   chicken␤»

