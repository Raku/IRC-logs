[00:01] <Tene> "Some of it's still broken, and a lot of it isn't done yet, but this is something that you can see, and try, and maybe use for some things.  We use it ourselves, and want to share both the ideas and the product.  We hope you like it, and hope you'll submit bug reports."

[00:01] <Tene> That's what I see it as.

[00:01] <masak> Tene++

[00:01] * masak heads bedwards

[00:02] *** masak left
[00:02] <lue> goodnight masak o/

[00:02] <lue> E1SECONDLATE

[00:02] <pmichaud> what are we using it for?

[00:02] <pmichaud> what are the key ideas that we think are particularly worth sharing?

[00:02] <lue> We code rakudo with it :)

[00:02] <lue> $_ = P6 of course

[00:03] <pmichaud> yes, but what would we share with people who want to use p6, as opposed to create an implementation of p6?  ;-)

[00:03] <lue> well, everything in proto/pls , for starters..

[00:03] *** masonkramer joined
[00:04] <pmichaud> no, I mean as far as features go.

[00:04] <pmichaud> what do we think would entice people to take a look at Rakudo Star?

[00:04] <pmichaud> or at least make them say "oh, that's really cool.  I should take a look someday."

[00:04] <TimToady> p5 people, or normal people?

[00:04] <pmichaud> normal, in this case

[00:04] * lue *thinking*

[00:05] <pmichaud> well, open-source leaning people if nothing else :)

[00:05] <Tene> ARGV -> signature on MAIN -> usage statement

[00:05] <Tene> makes for nice little things on the command line

[00:05] <lue> Well, meta/hyper/reductions ops [come on brain, more]

[00:05] <pmichaud> grammars and parsing, obviously.

[00:05] <Tene> Hm, 'sec, lemme ask my interested-but-not-yet-using friends.

[00:05] <diakopter> everyone (Perl and non-Perl folks)  will of course demand to know when a "stable release" is expected, and as usual an unqualified "patches welcome" response will raise hackles and spark derision; I recommend addressing that question, and carefully.

[00:06] <pmichaud> diakopter: sure, I'm addressing that.  got lots of stuff on that question.

[00:06] <diakopter> oh

[00:06] <pmichaud> diakopter: but even after I address that question, there's still the question of "why is it important?"

[00:06] <Juerd> "When it's ready" and "patches welcome" are good ways to get rid of your audience, possibly for good, indeed.

[00:07] <pmichaud> Rakudo Star is all about saying "it's ready for some people".

[00:07] <pmichaud> and also "still needs work"

[00:07] <pmichaud> but that's not the part I'm struggling with.

[00:07] <pmichaud> (or just now addressing)

[00:07] <pmichaud> to a larger audience, the question is "what should Perl 6 (and Rakudo Star) mean to me?"

[00:07] <diakopter> how does it fit into the ecosystem of PLs

[00:07] <pmichaud> yes, some people will see "not stable" and say "okay, not for me."  That's fine.

[00:08] <diakopter> so you need a PL framework or category system in which to place it

[00:08] <pmichaud> diakopter: just need to be able to describe it in terms of something they're already likely to know

[00:08] <Juerd> pmichaud: The future of multiparadigm programming, in an actually usable state. This piece of software is going to the next language all the other languages are going to steal from :)

[00:08] <pmichaud> Juerd: that's a good meme.

[00:08] <lue> a lot of code is greatly reduced to one line due to the insane number of operators.

[00:09] <Juerd> So if you value your job or hobby, you will *need* to know about Perl 6.

[00:09] <Tene> The metamodel is pretty great.  OO in Perl 6 is very nice.

[00:09] <Juerd> Given the pace of open source development, waiting until a stable release is out means you'll be having waited too long.

[00:10] <TimToady> "Everything you liked about your other languages except for the bad parts."  :)

[00:10] <pmichaud> "A language with completely new bad parts."  :-P

[00:10] <Juerd> TimToady: People do tend to like the bad parts though :)

[00:10] <pmichaud> scnr

[00:11] <pmichaud> if others come up with ideas, just post them to the channel

[00:11] <pmichaud> I think I'll try to draft something tonight that we can react to and edit

[00:12] <Juerd> pmichaud: Frankly, perhaps the best way to convince people nowadays might be "because you can"

[00:12] *** lestrrat is now known as lest_away

[00:13] <Tene> I expect that grammar and OO stuff is going to be the most-visible.

[00:13] <pmichaud> and strong typing

[00:13] <Juerd> At 600 CPM my typing is already pretty strong :)

[00:13] <pmichaud> Juerd: it's even stronger in perl 6 :)

[00:13] <Juerd> pmichaud: Wow, isn't that great!

[00:13] <pmichaud> your 600 cpm go a lot farther in perl 6 :)

[00:14] <diakopter> Perl 6: The densest Perl yet

[00:14] <TimToady> Perl 6, Almost a Black Hole.  :)

[00:14] <Juerd> "Everyone loves six"

[00:14] <Juerd> "We're open 42/7"

[00:14] <pmichaud> TimToady: I'm sure you've been asked this question before, though -- what do you emphasize to people who ask "Why Perl 6?"  Or does nobody dare to approach you with that question anymore?  ;-)

[00:15] <TimToady> "It'll take the other languages ten years to catch up, and then we'll be another hundred years ahead."  :)

[00:15] <TimToady> well...

[00:15] <TimToady> "because it's not there"  except is almost is now

[00:16] <lue> .oO(P6 will been stolen from. We know, we went to future with it.)

[00:16] <Juerd> Heh

[00:17] * lue can't wait for the day for Rakudo to run itself :)

[00:17] <diakopter> er

[00:17] <Tene> lue: looked at yapsi?

[00:17] <sorear> (people LIKE the Perl 6 metamodel?!)

[00:18] <lue> yes I have. I'm talking about doing something like perl6 perl6.pl6 :)

[00:18] <jnthn> lue: Same. :-)

[00:18] <jnthn> lue: Some hacking to go before that though. ;-)

[00:18] <lue> I type perl6, and it runs a shell script containing "perl6 perl6.pl6"

[00:18] <pmichaud> sorear: I like the Perl 6 metamodel.  A metamodel is good when you don't have to think about it to use it.

[00:19] <lue> (Yes it's recursive, I'm waiting for quantum computing)

[00:19] <sorear> quantum computing doesn't help with recursion

[00:19] <sorear> at all

[00:19] <pmichaud> it's boxes with (dead|alive) cats, all the way down.

[00:20] <lue> just kick the computer, and random events make it work! \o/ [so excited]

[00:20] <sorear> pmichaud: I come from Moose land, the metamodel there is far better

[00:20] <jnthn> sorear: Don't confuse the current implementation with how it's eventually meant to be.

[00:20] <lue> (R* is quantum computing ahead of schedule)

[00:22] <TimToady> though I would be interested to see a list of Moose's betternesses

[00:22] <jnthn> Same. :-)

[00:22] <jnthn> Rakudo's meta-model guts are in for a significant, well, gutting, though. :-)

[00:22] <lue> rakudo: my $a = 2; pir::setprop('rw',$a); pir::setprop('ro',$a); say "$a is OK!"

[00:22] <p6eval> rakudo bbacb7: OUTPUT«===SORRY!===␤The opcode 'setprop_p_p' (setprop<2>) was not found. Check the type and number of the arguments␤»

[00:22] <jnthn> pmichaud: s/strong typing/gradual typing/

[00:23] <pmichaud> setprop wants three arguments

[00:23] *** dduncan joined
[00:23] <jnthn> pmichaud: The combination of static and dynamic is the win here, with specifying more static stuff giving you more wins.

[00:23] <jnthn> (on performance and checking)

[00:23] <jnthn> but the dynamicness letting you just hack stuff up

[00:24] <pmichaud> jnthn: +1

[00:24] <jnthn> I guess in a sense, Perl 6 gives you a language you can prototype in, and then easily refactor towards production code, with potential to be safe and fast.

[00:24] <TimToady> you can scale from quick hack to enterprise without hitting a brick wall

[00:24] <lue> rakudo: my $a = 2; pir::setprop($a,'rw',1); pir::setprop($a,'ro',1); say "$a is OK!"

[00:24] <p6eval> rakudo bbacb7: OUTPUT«===SORRY!===␤The opcode 'setprop_p_p_p' (setprop<3>) was not found. Check the type and number of the arguments␤»

[00:24] <pmichaud> +1

[00:24] <jnthn> Also, Perl 6 re-visits a lot of assumptions that other languages have just taken for granted.

[00:25] <lue> such as?

[00:25] <pmichaud> also, Perl 6 is designed to be future-compatible

[00:25] <jnthn> "Why can't I just write if $foo == 1 | 2 { ... }?" In Perl 6, you can.

[00:25] <pmichaud> or even better

[00:25] <pmichaud> "Why can't I just write    if 1 < $foo < 2 { ... }"   

[00:25] <TimToady> such as "Obviously if I wanted a parser I'd use a parser generator like yacc"

[00:25] <jnthn> That also.

[00:25] <lue> (Perl6: Do whatever the hell you want.)

[00:26] <pmichaud> we even have coded the notion of "whatever"  :-P

[00:26] <lue> we also feature more pronouns than any spoken language :)

[00:27] <TimToady> such as, obviously the catch blocks go after the block in question

[00:27] *** isBEKaml left
[00:27] <TimToady> such as, there is only one dispatcher

[00:27] *** eternaleye_ left
[00:28] <jnthn> I find the combination of signatures and functional-style pattern matching quite exciting too

[00:28] <lue> afk

[00:28] <pmichaud> multidispatch.

[00:29] <TimToady> such as, assuming that types are only good for strong typing

[00:29] <jnthn> In many senses, in Perl 6 I find myself writing heavily multi-paradigm code without actually realizing I'm writing multi-paradigm code.

[00:29] <jnthn> Because they feel like a coherent whole rather than just a bunch of features.

[00:29] <sorear> one thing that I still haven't totally figured out how to do in Perl 6 is unboxing

[00:30] <sorear> you might annotate all your functions as working on Int, but that's not enough information to use native types, because someone might subclass Int

[00:30] <jnthn> Int is not a native type though

[00:30] <sorear> (also, our types have 2^N + 1 values)

[00:30] <sorear> no. it's not.

[00:31] <sorear> replacing non-native types with native ones is one of the most important optimizations in HLL compilers

[00:31] *** eternaleye joined
[00:31] <sorear> what should this do?

[00:31] <sorear> (more)

[00:33] <sorear> sub a { my class B { }; my &c = BEGIN sub { for ^4 -> $d { augment class B { method e { $d }; }; }; }; my $f = B.new; c(); say $f.e }; a;

[00:40] *** eternaleye_ joined
[00:40] *** eternaleye left
[00:45] *** simcop2387 left
[00:46] *** skids joined
[00:46] <jnthn> sorear: I'm not sure what the BEGIN really changes in that.

[00:47] <jnthn> (in that we don't run the sub until runtime anyway)

[00:48] <jnthn> (and iiuc the augment takes place a BEGIN time or so with or without it.)

[00:49] <Tene> jnthn: how does augment take place at BEGIN time if the sub isn't run intil the end?

[00:49] <Tene> c();

[00:50] <jnthn> Tene: Same way that sub foo { class A { } } results in class A existing even if foo never gets run

[00:50] <Tene> ah

[00:51] <jnthn> iiuc what TimToady mentioned the other day, my classes are no different from our ones, other than they get installed in the lexpad.

[00:51] <jnthn> And not in the package

[00:51] <jnthn> It'd just be anonymous classes that are interesting.

[00:51] <Tene> nodnod

[00:53] * jnthn needs sleep

[00:53] <jnthn> night o/

[00:54] <sorear> putting BEGIN on a sub prevents it from being cloned

[00:54] *** lkk- joined
[00:58] *** simcop2387 joined
[01:04] *** lest_away is now known as lestrrat

[01:06] *** ashleydev joined
[01:07] *** eternaleye_ left
[01:15] <lichtkind> good night

[01:15] *** lichtkind left
[01:15] *** elmex_ joined
[01:16] *** elmex left
[01:16] *** elmex_ is now known as elmex

[01:29] *** masonkramer left
[01:45] <pmichaud> hugme tweet rakudoperl Rakudo now has autovivifying arrays and hashes

[01:46] <pmichaud> ENOHUGS

[01:49] *** eternaleye joined
[01:50] *** lkk- left
[01:54] *** kid51 joined
[02:00] *** buubot joined
[02:04] * lue hugs pmichaud manually

[02:05] *** Chillance left
[02:05] *** buu joined
[02:06] <lue> I'm wondering,

[02:06] <lue> > my @a = 1,2,3; @a[3..5] := @a[0..2]; say @a.perl

[02:06] <lue> [1, 2, 3]

[02:06] <lue> is this a binding error or a slicing error?

[02:07] <pmichaud> I doubte that you've implement list binding.  :-)

[02:07] <pmichaud> also, note that @a[3..5] is Nil.

[02:09] <pmichaud> Also, I doubt there's a list-binding operator.

[02:09] <pmichaud> (I could be mistaken on this last point.)

[02:10] <lue> if := doesn't do it already, it should (maybe invent a :::= if neede :D)

[02:10] <lue> ooh! let's see if this works...

[02:11] <lue> > my @a = 1,2,3; [:=] @a[3..5], @a[0..2]; say @.perl

[02:11] <lue> Lexical 'self' not found

[02:11] <pmichaud> rakudo:  say [+] [1,2,3]

[02:11] <p6eval> rakudo 55acd1: OUTPUT«3␤»

[02:12] <pmichaud> rakudo:  say [!=] 1

[02:12] <p6eval> rakudo 55acd1: OUTPUT«1␤»

[02:12] <lue> well, assign.pir checks for nil assignment, maybe := should check for nil binding?

[02:13] <pmichaud> assign.pir checks for nil being assigned as a value to a target

[02:13] <pmichaud> in @a[3..5] above, Nil *is* the target.

[02:13] <lue> ah, well, nvm then :)

[02:13] <pmichaud> (and rakudo doesn't implement it  correctly yet anyway)

[02:13] <lue> rakudo: my @a = 1,2,3; say @a[3..5].WHAT

[02:14] <p6eval> rakudo 55acd1: OUTPUT«Parcel()␤»

[02:14] <lue> rakudo: my @a = 1,2,3; say @a[3..5]

[02:14] <p6eval> rakudo 55acd1: OUTPUT«Any()Any()Any()␤»

[02:15] <lue> What interests me is that binding to Nil doesn't die, but it doesn't work either.

[02:16] <pmichaud> I did just say that Rakudo doesn't handle it correctly yet.

[02:16] <pmichaud> and by "doesn't work", I don't know what "does work" would mean.  :-)

[02:16] <lue> Ah.

[02:17] <lue> EAMBIGUOUSSPEC

[02:20] *** lkk- joined
[02:22] <lue> Heh, when it comes to getting := to do what I want, it feels like dividing by 2. I keep getting closer to 0 each time, but never quite there :)

[02:23] <lue> > my @a = 1,2,3; @a[$_+3] := @a[$_] for 0..2; say @a.perl

[02:23] <lue> [1, 2, 3, 1, 2, 3]

[02:23] <lue> not the best way, but it works.

[02:24] *** tylercurtis joined
[02:25] *** sftp left
[02:28] <lue> I get the feeling there's no easy way to deal with Nil being the target in binding right now ( esp. considering it doesn't work right :) )

[02:29] *** skids left
[02:29] *** duzy` joined
[02:30] *** olgagirl joined
[02:31] *** tedv joined
[02:32] *** olgagirl left
[02:35] *** agentzh joined
[02:39] *** plobsing joined
[02:44] *** sorear sets mode: +v buubot

[02:45] <dalek> rakudo: f8dde0a | pmichaud++ | docs/spectest-progress.csv:

[02:45] <dalek> rakudo: spectest-progress.csv update: 507 files, 33927 (84.4% of 40197) pass, 19 fail

[02:45] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f8dde0a111c80a6a04bede9ac4eb2ad8c222dcf3

[02:45] <sorear> oh

[02:45] <sorear> apparently hugme is supposed to run on feather*2*

[02:46] * sorear has root on feather1

[02:46] * sorear pokes moritz_

[02:47] <sorear> ok, I *do* have an account on feather2

[02:48] <sorear> but I don't seem to have a sudoers line

[02:57] *** lkk- left
[02:58] *** ashleydev left
[02:59] *** eternaleye left
[03:15] *** ash_ left
[03:21] *** kid51 left
[03:22] *** eternaleye joined
[03:38] *** skangas joined
[03:39] *** eternaleye left
[03:41] <dduncan> with all this talk about how Parrot is supposed to support one hosted language invoking another, are there any existing examples of this, where both languages are Parrot hosted and both languages existed before Parrot?

[03:41] <PerlJam> dduncan: you mean like calling ruby from perl or vice versa?

[03:41] <dduncan> yes

[03:44] <dduncan> or to make this a little more on topic, any examples of Perl 6 code invoking code that is neither part of the Parrot toolkit (NQP, PIR, etc) nor is Perl 5?

[03:44] <dduncan> examples that run

[03:45] *** ashleydev joined
[03:45] <PerlJam> Someone (jnthn?) had some examples like that at one point, but I don't know where they are right off.

[03:45] <dduncan> okay

[03:46] <PerlJam> Ah ... this is what I was thinking of http://blogs.gurulabs.com/stephen/2009/05/cross-language-library-loading.html

[03:46] <Tene> That's me.

[03:47] <PerlJam> yeah, sorry to confuse you with jnthn  ;)

[03:47] <Tene> It did work in the past, and then things got changed out from under me twice, and I gave up on trying to keep it maintained.  I hear that it's working to some degree again these days, but afaik none of the langauges other than rakudo support it anymore, if even rakudo does, so it's not really useful.

[03:47] <Tene> PerlJam: Quite honored, actually.  Maybe you should apologize to jnthn instead. :)

[03:47] <PerlJam> heh

[03:48] <dduncan> any thought as to whether a modern analogy might be working in time for Rakudo Star? ... specifically of Perl 6 calling other languages

[03:49] <[Coke]> I don't think that's on the short list.

[03:50] <Tene> dduncan: I expect it'll only happen if an HLL Interop Champion shows up to drive it.  That was my job for quite a while, but I haven't been available in any reasonable way for quite a while.

[03:50] <[Coke]> (not that I'm someone who'd know. =-)

[03:51] <Tene> It shouldn't be that much work for someone comfortable with parrot-hosted languages, but it's not going to happen unless someone who cares shows up to do the work and get the other languages in line, etc.

[03:51] <dduncan> well maybe I'll work on it then ... in a few months

[03:52] <Tene> That'll be after the first release of rakudo start, but it would still be great to have someone working on it.  :)

[03:52] <dduncan> since I'm creating a Parrot hosted language, I'd like to call it from Perl, and perhaps vice-versa

[03:52] <Tene> I'd be more than glad to try to guide you through it.

[03:52] <dduncan> thank you ... anyway, my schedule has it that I don't expect to start before October, but that isn't too far off

[03:53] <Tene> If it turns out to be a pressing feature that needs work before then, that would probably mean that someone else now cares enough to work on it, so that's probably fine.

[03:54] *** hejki joined
[03:55] <dduncan> on a tangent, something I'm wanting to start working on in August is a test suite for my new language which is intended to be used to test multiple compilers of my language, and I'll be looking at the Perl 6 suite for guidance

[03:55] <Tene> Certainly not a bad place to look.

[03:56] <dduncan> I also intend to be working on no fewer than 4 distinct implementations ... or maybe 3 ... one over Perl 5, one over Perl 6, one as a native Parrot hosted language, and one as a Postgres procedural language ... though probably the last 2 can be one and the same

[03:56] <dduncan> so its useful to have a common test suite from day one

[03:57] <dduncan> the first 2 are expected to be easier as they'll just generate Perl code that does the same thing, and the Parrot one is expected to be the "real" one

[03:57] <dduncan> where I have to do more work myself

[03:59] <dduncan> similarly, I'd be following the Perl 6 example of making much of the language self-hosting, so I only have to do it once for all implementations, by default

[04:00] <dduncan> that is, mostly self-hosting

[04:03] *** ashleydev left
[04:04] <dalek> niecza: af32687 | sorear++ |  (4 files):

[04:04] <dalek> niecza: Implement the possibility of metaobject cloning

[04:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/af32687cb658e09e428a4ac81b2f79c826c497b2

[04:04] <dalek> niecza: 81429e4 | sorear++ | setting:

[04:04] <dalek> niecza: Revise metaobject API for new guts

[04:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/81429e41657eb3667f39ad83be98a9b0b8a82b4e

[04:05] *** Guest99304 left
[04:07] *** tedv left
[04:23] *** quietfanatic joined
[04:23] <quietfanatic> How much of Perl 6 grammars can I currently use in Rakudo?

[04:24] <quietfanatic> because I'm getting some inexplicable syntax errors.

[04:25] <quietfanatic> Wait, no I see the error

[04:26] <sorear> quite a lot of them - enough to parse Rakudo Perl 6 itself

[04:28] <dduncan> that's good

[04:28] <quietfanatic> Cool

[04:28] <quietfanatic> How do I parse a file with a grammar?

[04:29] <quietfanatic> I'm trying slurp($file) ~~ grammar_name

[04:29] <quietfanatic> but it's returning 0

[04:29] <tylercurtis> Grammar.parsefile(filename, :actions(Actions.new))

[04:29] <tylercurtis> I think.

[04:29] <quietfanatic> (where grammar_name contains a rule TOP {...})

[04:29] <quietfanatic> That's a little...verbose

[04:29] <quietfanatic> but I'll try it.

[04:30] <quietfanatic> wait, it requires actions of some sort?

[04:30] <sorear> no

[04:30] <tylercurtis> No.

[04:30] <sorear> named args are always optional

[04:30] <sorear> (in standard functions)

[04:30] <quietfanatic> so just parsefile, eh?  I was hoping smartmatch would be smart enough for that

[04:30] <sorear> a grammar is fundamentally a kind of class.  slurp($file) ~~ grammar_name is an isa test

[04:31] <sorear> also, grammars are intended for fairly complicated languages

[04:31] <sorear> if your grammar is small enough that you care about saving ten characters, just use a regex

[04:32] <quietfanatic> okay, I see.

[04:32] <quietfanatic> That makes sense, actually.

[04:32] <tylercurtis> Alternately, if you really want to use slurp, Grammar.parse(slurp($file)). That's probably what Grammar.parsefile does internally, anyway.

[04:33] <TimToady> well, it also sets the filename for error messages

[04:33] <quietfanatic> Just putting the rules bare in the file gives a bunch of "useless declaration of has-scoped rule..." warnings

[04:33] <quietfanatic> and then can't find the rule.

[04:33] <TimToady> grammar {...}

[04:33] <quietfanatic> I guess I have to my them all.

[04:33] <TimToady> grammar MyGrammar {...}

[04:34] <TimToady> just put them in a grammar declaration

[04:34] <quietfanatic> So then I'll use a grammar after all.

[04:34] <TimToady> hard to have methods without a class

[04:35] <quietfanatic> It's not returning true even with a trivial rule.

[04:35] <quietfanatic> rule TOP { ^ .* $ }

[04:36] <TimToady> rakudo: grammar Foo { rule TOP { ^ .* $ } }; say Foo.parse("stuff").perl

[04:36] <p6eval> rakudo 55acd1: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ from => 0,␤ orig => "stuff",␤ to   => 5,␤)␤»

[04:37] <TimToady> that matched

[04:37] *** duzy`` joined
[04:38] <quietfanatic> Well my file is not matching.

[04:38] <quietfanatic> I've tried parsefile and parse(slurp())

[04:38] <PerlJam> quietfanatic: you can always nopaste the code and input

[04:39] *** duzy` left
[04:39] <quietfanatic> Alright, let's see to that then...

[04:39] <TimToady> you're not trying to run it from the command line are you?

[04:39] <quietfanatic> wait where's the nopaste?

[04:39] <quietfanatic> TimToady: Of course, why would that matter?

[04:40] <TimToady> shell quoting and interpolation

[04:40] <quietfanatic> Oh, no, I misunderstood what you meant.

[04:40] <quietfanatic> My grammar is in a file.

[04:41] <quietfanatic> say slurp(@*ARGS[0]) works, but grammar.parse(slurp(@*ARGS[0])) does not.

[04:41] <PerlJam> quietfanatic: I tend to use gist.github.com

[04:43] <sorear> quietfanatic: rule TOP { ^ .* $ } is not going to match anything that starts with whitespace

[04:43] <TimToady> troo

[04:43] <TimToady> s/rule/token/

[04:44] <sorear> use "token" unless you actually want the spaces in your pattern to be taken semi-literally

[04:44] <quietfanatic> . doesn't match whitespace?

[04:44] <sorear> " " matches \s* possessively

[04:44] <TimToady> rules don't backtrack, and ^ won't match the beginning if the implicit <.ws> matched first

[04:44] <sorear> "^", seeing that it's not at the beginning of the string, fails to match

[04:45] <quietfanatic> Oh fooey

[04:45] <sorear> and drop the ^ and $.  grammars, unlike naked regexes are always anchored

[04:45] <quietfanatic> I see.

[04:46] <quietfanatic> Well, that fixes it.

[04:46] <quietfanatic> I do remember that 'rule' means sigspace, but I never figured out why 'rule' does and 'token' doesn't

[04:46] <quietfanatic> in terms of the word choice I mean.

[04:47] <quietfanatic> Why 'rule' for sigspace?

[04:47] <TimToady> tokens are typically used to match small bits that exclude whitespace, and rules are typically used to call into subrules that want to marshall the matching of multiple "words"

[04:48] <quietfanatic> I see, but

[04:48] <TimToady> of course, when you match something like an expression in parens, the parens are a token on the outside, but parse a rule on the inside

[04:49] <quietfanatic> there are times when I want to disable sigspace in a regex, and then it looks odd having a token contain rules.

[04:49] <TimToady> happens all the time for any kind of circumfix

[04:49] <quietfanatic> I just don't think the terminology matches the meaning well.

[04:50] <quietfanatic> The instance this time is matching a closing } with the same indentation as the opening {

[04:50] <sorear> you are free to turn off sigspace in the middle of a rule

[04:50] <quietfanatic> adding sigspace makes that not work.

[04:51] <sorear> rakudo: say ("a b" ~~ rule { a b })

[04:51] <p6eval> rakudo f8dde0: OUTPUT«a b␤»

[04:51] <sorear> rakudo: say ("a b" ~~ rule { a:!s b })

[04:51] <p6eval> rakudo f8dde0: OUTPUT«␤»

[04:51] <sorear> rakudo: say ("ab" ~~ rule { a:!s b })

[04:51] <p6eval> rakudo f8dde0: OUTPUT«ab␤»

[04:51] <sorear> or simply

[04:51] <sorear> rakudo: say ("a b" ~~ rule { ab })

[04:51] <p6eval> rakudo f8dde0: OUTPUT«␤»

[04:52] *** TiMBuS joined
[04:52] <quietfanatic> I'll just stick with 'token

[04:52] <quietfanatic> '

[04:52] <tylercurtis> It matches it to some extent, because many programming languages' grammars care about exact whitespace in their tokens, but only care about some amount of whitespace or no whitespace in their rules. And the distinction is pretty simple to remember once you learn what they mean in the context of Perl 6.

[04:52] <TimToady> that's fine, especially if you're gonna be fiddly with the whitespace

[04:53] <sorear> although sometimes I miss the phase separation in p6

[04:53] <quietfanatic> I can see that *usually* token means token and rule means rule

[04:53] <quietfanatic> but it bothers me that it's almost a literal meaning but actually is not at all.

[04:54] <quietfanatic> ...that was worded weirdly

[04:54] <quietfanatic> I just don't like it that the terms don't mean exactly what they say they mean.

[04:57] <TimToady> that's always a problem when you're dealing with concepts that don't map well onto the lexicon

[04:58] <quietfanatic> I don't know, everything else in Perl 6 is usually pretty self-explanatory in its naming.

[05:09] <tylercurtis> quietfanatic: No name is self-explanatory. A name can, at best, be self-explanatory with a certain background knowledge and in a certain context. Rule and token aren't quite self-explanatory to someone who knows what rules and tokens are in the context of grammars in general, but once you understand what they mean in the context of Perl 6, their association with the meaning of "rule" and "token" in general is a helpful mnemonic.

[05:10] *** jaldhar left
[05:13] <quietfanatic> That's a point, I suppose.

[05:13] <tylercurtis> comb is similar; it's not a standard function across many programming languages, but it's a simple name that's easy to remember and the thought of "combing through" something is a helpful mnemonic.

[05:15] <tylercurtis> Many of Perl 6's names for things are not things I find self-explanatory, but once I learn what they mean, they're easy to remember.

[05:15] <quietfanatic> But comb doesn't obviously mean anything at first.

[05:15] <quietfanatic> token and rule, in informal usage mean a small thing and a large thing

[05:15] <quietfanatic> but in implementation they mean :!s and :s.

[05:16] <quietfanatic> which is not the same thing at all.

[05:18] <TimToady> you're missing an important distinction

[05:18] <quietfanatic> So when I see the term token, I'll have to wonder whether they mean a small unit of parsing, or a regex without sigspace.

[05:18] <sorear> I don't know where you come from, but here, in informal usage, a token is a small round metal thing representing a commodity

[05:19] <quietfanatic> informal programmer usage, I mean.

[05:19] <TimToady> precisely *because* tokens don't have sigspace, they participate as alternatives in lexers, and hence are tokens in the usual (technical) sense

[05:19] <TimToady> leading whitespace tends to disqualify a rule from participating in a lexer

[05:20] <TimToady> sigspace is merely a means to an end

[05:20] <TimToady> or a not-end, in this case

[05:20] *** skangas left
[05:20] <tylercurtis> Really, in languages in which whitespace only matters to separate tokens, rules and tokens mean exactly what they should mean for that language.

[05:20] <quietfanatic> Huh.  I guess I must concede the point due to my head spinning too much.

[05:21] <TimToady> even in English, the distinction between "word" and "phrase" is unclear

[05:21] <TimToady> for instance, "the King of England's hat"

[05:22] <TimToady> the 's wants a word on its left, so 'the King of England' functions like one temporarily

[05:22] <quietfanatic> What bothers me isn't the ambiguity in distinction, it's that there's two possible distinctions that aren't the same.

[05:23] <TimToady> if things like that bother you, either you should or shouldn't be a language designer.  :)

[05:24] <quietfanatic> Well, perl has always been a very interpretive language.

[05:24] <TimToady> most words in natural language are very imprecise at the best of times

[05:24] <quietfanatic> But the words 'token' and 'rule' in Perl 6 are very precise.

[05:25] <TimToady> yes, and they're just about the best words we could find that match the abstract concepts

[05:25] <quietfanatic> in their meaning, I mean.

[05:25] <TimToady> and Perl 6 tends to emphasize the abstract meanings over the concrete

[05:25] <quietfanatic> But their literal meaning isn't abstract in any way.

[05:25] <TimToady> given/when vs switch/case

[05:25] <TimToady> huh?

[05:25] <quietfanatic> one means sigspacem the other doesn't

[05:25] <quietfanatic> *,

[05:26] <TimToady> that's its concrete meaning

[05:26] <TimToady> but there are ramifications on the abstract level

[05:26] <quietfanatic> whereas picking the terms 'token' and 'rule' overlays abstract meaning on it that I think is too confusing.

[05:28] <quietfanatic> I'm trying to think of something it's like...

[05:29] <quietfanatic> well my brain is not operating on analogy mode tonight.

[05:29] <tylercurtis> I think TimToady is saying that when choosing a name for something, the pool from which you can draw(which mostly consists of natural language words, because no one would even have a clue what "figel Foo { zabez TOP { <statement> }; gix statement { 'bar' } }" meant without being told in advance, and they'd have difficulty remembering even then), consists of things with imprecise meanings that rarely correspond exactly to what you really mean.

[05:29] *** skangas joined
[05:30] <tylercurtis> E.g., the mathematical concept of a function rarely coincides with the general meaning of the word, and neither is identical to most programming languages concepts of a function.

[05:30] <quietfanatic> tylercurtis: True.  I just am of the opinion that in this case there is too much disconnect between the abstract and the concrete here.

[05:30] <TimToady> about the best you can do is minimize the gratuitous overloading in a particular context; at one point "proto" meant about four different things in perl 6

[05:31] <quietfanatic> Oh yeah I remember that :)

[05:31] <quietfanatic> Well I'm not changing anybody's mind, I just wanted to cast my dissent.

[05:32] <tylercurtis> Of course, there are some times when this can go wrong. E.g., structs in C++ not being what a C programmer coming to C++ would expect at all(normal objects, just with a different default visibility for members).

[05:32] <quietfanatic> Well, normal objects are just structs underneath, right?

[05:34] <tylercurtis> C structs don't have member functions, can't inherit(well, you can manually do something similar), will never have a vtable unless you explicitly implement one, etc.

[05:34] <tylercurtis> Or constructors or destructors.

[05:35] <TimToady> Perl stole BEGIN and END from awk and made them mean something rather different

[05:35] <ingy> greetings

[05:35] <TimToady> o/

[05:36] <ingy> how do I findbin in rakudo/p6?

[05:36] <tylercurtis> Anyway, I should be getting to bed. quietfanatic, why must you start interesting conversations that I get drawn into? :P Good night, folks.

[05:36] <sorear> run("which")?

[05:37] <TimToady> um, use FindBin?

[05:37] <quietfanatic> gn tyler

[05:37] <ingy> :\

[05:37] <ingy> oh?!

[05:37] <TimToady> leastwise t/spec/S16-filehandles/dir.t uses it

[05:38] <ingy> where do I findfindbin?

[05:38] <TimToady> I don't know if rakudo runs it at all though

[05:38] *** tylercurtis left
[05:39] <TimToady> looks like there's one in ./ext/FindBin/lib/FindBin.pm that was probably used by pugs

[05:41] <TimToady> yeah, I don't think rakudo will grok m:P5//

[05:41] <sorear> did pugs grok m:P6//?

[05:41] <quietfanatic> Are lookbehinds NYI in rakudo?

[05:41] <TimToady> not really

[05:41] <ingy> TimToady: where is this ext?

[05:41] <ingy> I don't see it in rakudo src

[05:42] <TimToady> the upgs repo

[05:42] <TimToady> *pugs

[05:42] *** gabiruh joined
[05:42] <ingy> do we use that anymore?

[05:42] <TimToady> parts of it, but maybe not that part :)

[05:43] <TimToady> still, should be pretty easy to port to rakudo

[05:43] <ingy> like what parts?

[05:43] <TimToady> like the specs and the tests all live in the pugs repo

[05:43] <TimToady> so does STD

[05:43] <ingy> hrmm

[05:43] <TimToady> and several other implementations

[05:45] <TimToady> rakudo: say "foo" ~~ / <?after 'oo'> /

[05:45] <p6eval> rakudo f8dde0: OUTPUT«Method 'after' not found for invocant of class 'Cursor'␤  in <anon> at line 11:/tmp/5jXKpIznTR␤  in 'Cool::match' at line 2309:CORE.setting␤  in 'Regex::ACCEPTS' at line 5240:CORE.setting␤  in 'infix:<~~>' at line 401:CORE.setting␤  in main program body at line

[05:45] <p6eval> ..11:/tmp/5jXKpIznTR␤»

[05:45] <TimToady> quietfanatic: it would appear not

[05:45] <sorear> lookbehind has to be implemented at /some/ level for .ws to work

[05:46] <sorear> you might need to drop down to pir though

[05:47] <quietfanatic> I'm not gonna try to fiddle with that then.

[05:47] <TimToady> that only needs one char of lookbehind

[05:47] <ingy> is http://github.com/audreyt/pugs up to date?

[05:47] <TimToady> so probably cheats with substr or some such

[05:47] <quietfanatic> Being unable to override ws makes writing a line-based grammar really hard.

[05:48] <sorear> ingy: wrong pugs repo

[05:48] <sorear> that's the repository which contains pugs

[05:48] <sorear> we're talking about the repository called pugs

[05:48] <quietfanatic> I'll have to switch to semicolon-based.  That'd be more better anyway probably.

[05:49] <ingy> sorear: url?

[05:49] <sorear> yow, I broke STD

[05:49] <sorear> http://svn.pugscode.org/pugs/

[05:49] <sorear> Can't locate object method "_SUBSUMEr" via package "main" at Niecza/Grammar.pm line 1171.

[05:50] <TimToady> how did you get an object blessed into main?

[05:50] <sorear> I misspelled a :lang

[05:50] <sorear> and apparently CORE::bless thinks undef = PL_defstash

[05:50] <sorear> yay for wrong defaults

[05:50] <TimToady> huh

[05:51] <dduncan> in my mind's experience, writing a parser is a lot easier if we don't have to keep track of lines, and all whitespace outside string literals is the same

[05:52] <TimToady> you'll note that in P6 the type is now the mandatory invocant of bless :)

[05:52] <ingy> sorear: they pretty similar. is there a git mirror of the svn repo?

[05:53] <ingy> I remember svn checkout of pugs taking a very long time. :\

[05:53] <dduncan> by "same" I mean "differences aren't significant"

[05:53] <sorear> ingy: yes but it's pretty stale iircx

[05:54] <TimToady> dduncan: but the highest goal of writing a parser is not to make it easy to write, but easy for the user to use.  Easy to write is nice as a bonus, of course.

[05:55] <TimToady> anyway, even the languages that say "all whitespace is the same" often treat 0-width whitespace as significantly different from 1-or-more width

[05:55] <dduncan> for my own purposes in writing a parser, the only useful thing about paying attention to which whitespace you have is to give useful error or diagnostic messages

[05:56] <sorear> ingy: on the plus side, now that pugs is gone, checking out pugs is faster.  (confused yet?)

[05:56] <dduncan> by "the same", I mean different line-endings versus tabs vs spaces ...

[05:56] <dduncan> I *do* consider the presence vs absence of whitespace significant

[05:57] <dduncan> zero-width meaning absence

[05:57] <TimToady> dduncan: on the other hand, vertical whitespace looks different to the user, so is psychologically valuable to distinguish sometimes

[05:58] <TimToady> in particular, the desire for extensibility has driven some of the P6 whitespace decisions, such as no ws before postfixes, and } at end of line always ends the expression

[05:59] <TimToady> and of course, Perl has had here-docs for ages

[05:59] <TimToady> which very much distinguish \v from \h whitespace

[06:00] <dduncan> on a tangent, I found it useful with my own language to format comment strings like other data strings, in that they have a non-whitespace delimiter at both ends, rather than just at the start and treating the end-of-line as the end delimiter

[06:00] <dduncan> the Perl analogy would be having a trailing # in addition to a leading one

[06:00] <TimToady> both forms can be useful

[06:01] *** uniejo joined
[06:01] <TimToady> and pod is also keyed to vertical transitions

[06:02] <dduncan> yes

[06:04] <dduncan> well, its an exercise in trade-offs ... I went for something that I perceived was 90% as easy to write by a user but was 5+ times easier to parse

[06:05] <dalek> niecza: 1c21454 | sorear++ |  (4 files):

[06:05] <dalek> niecza: Implement quoted identifiers, some more class stuff

[06:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/1c2145457b4b72d7d83caecdfc0c47cefb1ee4d7

[06:05] <dalek> niecza: 68a676c | sorear++ |  (4 files):

[06:05] <dalek> niecza: Implement ClassHOW injection and bootstraping (3rd time)

[06:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/68a676c3d08f8cd9f281d6440b7ba5233da70af6

[06:05] <ingy> TimToady: do you know about $*PROGRAM_NAME?

[06:05] <ingy> that's all I wanted

[06:05] <ingy> :\

[06:06] <ingy> Well I guess I learned a little along the way.

[06:07] <dduncan> about strings, another design decision I made, which I'm not aware of any other language doing, is disallowing literal occurrences of the string delimiter within the string, even with a leading backslash ... rather the same char is represented with something else ...

[06:07] <dduncan> as a result, when you encounter an opening delimiter, you know that the next occurrence is its pair, and you don't have to test for leading backslash or whatever

[06:08] <TimToady> sounds like you're making it easier for you than for your user

[06:09] *** lafille joined
[06:09] <dduncan> well they still have to escape somehow, and I just have them escape differently

[06:10] <dduncan> granted, Perl 6 has the matching braces thing, so often you don't need escapes of the same thing

[06:10] <dduncan> but practically every other language doesn't do that AFAIK, and I'm comparing with them in this case

[06:10] <TimToady> but how do they know what that other character is?

[06:10] <TimToady> ingy: $*PROGRAM_NAME seems to work here, as long as it's in a file

[06:11] <dduncan> first of all, there are only a small number to remember ... 2-4 ... and its documented

[06:11] *** lafille left
[06:11] <TimToady> what if your string has all of those?

[06:11] <dduncan> mainly, the differences are single-quotes, double-quotes, and backslashes ... everything else looks as you're used to

[06:12] <dduncan> except for the odd removal ...

[06:13] <sorear> dduncan: you appear to be reinventing the Perl 5 quote-like operator parsing engine

[06:13] <sorear> read "Gory details of parsing quote-like operators" in perlop, spare yourself some time

[06:13] <dduncan> actually, no

[06:13] <dduncan> all Text literals use single quotes, period

[06:14] <dduncan> all Name literals use double quotes, period

[06:14] <dduncan> same as in SQL

[06:14] <dduncan> so in a Text (Str of Perl 6)

[06:14] <dduncan> only the single quote and backslash need escaping

[06:14] <dduncan> other things may optionally be escaped, but don't have to

[06:15] <dduncan> so no quote-like operator

[06:15] <TimToady> why does the backslash need escaping if you're not using it to backslash single quote?

[06:15] <dduncan> this is Text: 'hello world' ... Name: "Hello World" ... Comment: #hello world#

[06:16] <dduncan> if you have a literal backslash

[06:16] <dduncan> one moment ...

[06:17] <dduncan> a relevant url: http://search.cpan.org/dist/Muldis-D/lib/Muldis/D/Dialect/PTMD_STD.pod#General_Purpose_Character_String_Literals

[06:17] * sorear goes to read up on MROs

[06:18] <dduncan> keep in mind, I'm going for now for a 90% solution, and my primary competitor is SQL

[06:19] <dduncan> in a Text literal, a single-quote may be escaped as either \a (apostrophe) or the same \c<> format that Perl 6 has

[06:20] <dduncan> and a backslash, with a \b

[06:20] <moritz_> Perl 6 uses \c[...] 

[06:20] <dduncan> these rather than \' and \\

[06:20] <dduncan> yes, okay

[06:20] <dduncan> I think I meant \c followed by a delimited unicode name or num

[06:20] *** justatheory left
[06:22] <dduncan> so, 'this isn\at something' is a Text literal

[06:22] <dduncan> basically just the \a, \b etc are different from common practice, the rest is more the same

[06:23] <dduncan> especially, the \t, \n, \f, \r are the same as convention

[06:23] <dalek> niecza: ee41c0d | sorear++ |  (3 files):

[06:23] <dalek> niecza: Don't pollute global syml/ with our data

[06:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ee41c0de3c1cf68de9ff27f1aa52509f3eb686fb

[06:23] <sorear> looks like someone needs to be exposed to nibblers.

[06:23] <sorear> moritz_: hugme is AWOL

[06:23] <dduncan> \a or \b used to mean "alarm"/"bell" but I think hardly anyone uses those

[06:24] <sorear> no, \b is backspace, not bell

[06:24] <sorear> (and I've used it)

[06:24] <dduncan> sure, okay, but its used rarely isn't it?

[06:24] <sorear> very much so

[06:24] * BinGOs has used 

[06:24] *** hugme joined
[06:24] <dduncan> well one can still use the \c form for those, or even include them literally

[06:24] <sorear> I still think you're actually making this more complicated when you think you're simplifying

[06:25] <sorear> Perl6 regex was designed, among other things, to make processing strings with escapes easy

[06:26] <dduncan> sure, but I'm also targeting implementations not over Perl 6, in addition to Perl 6

[06:26] <TimToady> recognizing \' is *just as easy* as recognizing \a, and isn\'t is a lot more readable than isn\at

[06:28] <dduncan> well, maybe I'll change that, but at the moment I don't see this issue to be a problem in practice

[06:28] <TimToady> even isn''t is better than isn\at

[06:30] <TimToady> well, as long as you don't expect this to be used for English text, you'll be fine... :P

[06:32] <TimToady> seriously though, one of the P5 things we ran away from screaming is multi-pass parsing, so I wouldn't feature it

[06:32] <TimToady> it just comes back and bites you later

[06:32] <dduncan> I certainly don't feature it

[06:33] <dduncan> a key feature of Muldis D is that it can be single-pass parsed

[06:33] <TimToady> then there's little point in excluding the delimiters from recognizable constructs in the middle

[06:33] <dduncan> understanding the meaning of any character only requires having read the prior ones

[06:35] <dduncan> you make a point there

[06:35] <TimToady> what if Unicode in their infinite wisdom decides to add a character name containing one of your quote chars?

[06:36] <dduncan> you mean, having something other than latin letters and spaces?

[06:36] <TimToady> they already have parens in there

[06:37] <TimToady> anyway, it doesn't buy you much to exclude them, and doesn't help readability, in my estimation

[06:37] <dduncan> so, if I change to using \' and \\ etc then you would consider this to be a huge improvement in useability?

[06:38] <TimToady> certainly a great number of C/C++/Java programmers will think so

[06:40] <dduncan> fyi, while the language is single-pass parseable, I imagined it might be easier to do multiple passes in practice ... my current design could make the tokenization phase easier ... then again, that may be antiquated thinking

[06:41] <dduncan> so I'll make this design change now to conform to more common practice and hope for the best

[06:41] * TimToady nods, probably off to sleep...

[06:42] <dduncan> I'll just do the \' though, no '' ... that one looks like 2 strings side by side

[06:43] <dduncan> thanks for the feedback

[07:20] *** Mowah joined
[07:25] *** Ross joined
[07:54] *** mberends joined
[08:04] *** plobsing left
[08:05] <sorear> class Foo { } ; (BEGIN Foo.new).isa(Foo) # this = 0 according to my current understanding of perl 6

[08:05] <moritz_> why should it?

[08:06] <moritz_> if that were the case, 1.isa(Int) would also be false

[08:06] <moritz_> because 1 is kinda like Int.new(1)

[08:07] <moritz_> at compile time

[08:07] *** mikehh left
[08:07] <sorear> well, Foo, as an our object, is instantiated more than once

[08:07] <sorear> first it's instantiated against the protopad, producing Foo#1

[08:08] <sorear> the BEGIN returns an instance of Foo#1

[08:08] <sorear> on each execution of the closure, Foo is bound to the current environment, producing Foo#2, etc

[08:08] <moritz_> that's the first time I've heard of the "protopad"

[08:08] <sorear> so it's really (Foo#1.new).isa(Foo#2)

[08:09] <moritz_> why should the Foo's resolve to different objects?

[08:09] <moritz_> I don't see any closure closing over Foo

[08:09] <moritz_> it's not a variable

[08:09] <sorear> because they close over different lexical environments

[08:09] <moritz_> ... and?

[08:09] <moritz_> Foo is an 'our' symbol, as you've said yourself

[08:09] <sorear> my $x; class Foo { method bar { $x } }

[08:10] <moritz_> why should it be different in different instances of a closure?

[08:11] <moritz_> rakudo: class Foo { }; say (BEGIN { Foo.new}).isa(Foo);

[08:11] <p6eval> rakudo f8dde0: OUTPUT«===SORRY!===␤too few positional arguments: 1 passed, 2 (or more) expected␤»

[08:11] <moritz_> rakudo: class Foo { }; say (BEGIN { Foo.new}).^isa(Foo);

[08:11] <p6eval> rakudo f8dde0: OUTPUT«===SORRY!===␤too few positional arguments: 1 passed, 2 (or more) expected␤»

[08:11] <moritz_> rakudo: class Foo { }; say (BEGIN { Foo.new}) ~~ Foo;

[08:11] *** cjk101010 joined
[08:11] <p6eval> rakudo f8dde0: OUTPUT«===SORRY!===␤too few positional arguments: 1 passed, 2 (or more) expected␤»

[08:12] <sorear> moritz_: what should (class { method foo { $_ } }).foo for ^2 return?

[08:12] <sorear> I assert that the answer is 0, 1

[08:13] <moritz_> sorear: I have no idea, but I don't see how it is related to the previous question

[08:13] <sorear> classes close over their lexical environment, just like the methods they contain

[08:13] <moritz_> sounds kinda sane

[08:13] *** pnate left
[08:13] <sorear> moritz_: a class is a closure, so each time it is cloned it produces a new value

[08:14] <sorear> rakudo: my sub foo() { say "Hi" }; BEGIN { foo; } # If rakudo had working protopads it could run this

[08:14] <p6eval> rakudo f8dde0: OUTPUT«===SORRY!===␤Could not find sub &foo␤»

[08:14] <sorear> pugs: my sub foo() { say "Hi" }; BEGIN { foo; }

[08:14] <p6eval> pugs: OUTPUT«Hi␤»

[08:14] <sorear> that's what protopads are

[08:14] <moritz_> waitwaitwait

[08:14] <moritz_> cloning a closure only clones the lexpad

[08:14] <moritz_> not the entire thing

[08:14] <moritz_> so there's still a a relation between the clones

[08:15] <sorear> a relation, yes

[08:15] <sorear> but not ===

[08:15] <moritz_> I don't think .isa needs to consider the cloned parts, does it?

[08:15] <sorear> I had taken it for granted .isa would use ===

[08:15] <sorear> but now that you say that - I am not so sure

[08:15] <sorear> thanks

[08:16] <moritz_> then it wouldn't work for   (3 but True) ~~ Int

[08:16] <moritz_> which would be kinda surprising

[08:16] <moritz_> IMHO

[08:16] <moritz_> but I think I'm not the right person to discuss it with

[08:17] <sorear> well, (3 but True) has a class of all(__ANON__, Int, Cool, Any, Mu)

[08:17] <sorear> so it could match Int regardless

[08:17] <sorear> but - the cloned parts of a class or role affect only implementation, not interface, so there's no reason for isa and does to consider them

[08:17] <moritz_> all(Int, Any) ~~ Int is false

[08:18] <moritz_> so it needs to do a bit smarter matching :-)

[08:29] <TiMBuS> does Any ~~ Int work?

[08:30] <moritz_> rakudo: say Any ~~ Int

[08:30] <p6eval> rakudo f8dde0: OUTPUT«0␤»

[08:30] <TiMBuS> i guess that's the problem

[08:31] <moritz_> not really

[08:31] <moritz_> it's a feature

[08:31] <TiMBuS> of course

[08:32] <moritz_> I guess that changing all() to any() would do

[08:32] <TiMBuS> rakudo: say any(Int, Any) ~~ Int

[08:32] <p6eval> rakudo f8dde0: OUTPUT«0␤»

[08:33] <TiMBuS> ahhh

[08:33] <moritz_> now *that's* a problem

[08:33] *** thebird joined
[08:35] <TiMBuS> is there a "great big table of smartmatching" to say what works and in what order? i recall seeing one but I think it was for perl 5

[08:35] <sorear> right

[08:35] <sorear> perl 5 has a Great Big Table

[08:35] <sorear> perl 6 smartmatching is very simple

[08:35] <moritz_> TiMBuS: S03 has such a table

[08:36] <sorear> A ~~ B = B.ACCEPTS(A)

[08:36] <moritz_> but it's not all implemented

[08:36] <TiMBuS> I see

[08:36] <moritz_> sorear: not quite

[08:36] <moritz_> first $_ is set to A

[08:36] <sorear> A ~~ B = (let $_ = A in B).ACCEPTS(A)

[08:37] <moritz_> which explains how   'a' ~~ .uc  is supposed to work

[08:37] <moritz_> http://perlcabal.org/syn/S03.html#Smart_matching

[08:38] *** pnate joined
[08:39] *** masak joined
[08:39] <masak> oh hai, #perl6

[08:40] <moritz_> lolitsmasak

[08:40] <moritz_> fun question: what happens if you smartmatch against a Match object?

[08:41] <masak> er.

[08:41] <moritz_> btw I'm kinda surprised that the fallback for smartmatching is === and not eqv

[08:41] <masak> aye.

[08:41] <moritz_> since most cases of ~~ test structural things, not object identity

[08:42] *** clintongormley joined
[08:42] <TiMBuS> i think i've ran into this issue! and most of the time I wanted Match to be stringified

[08:43] <dduncan> TimToady, sorear - I've now committed the design change on char escape seqs we discussed - http://utsl.gen.nz/gitweb/?p=Muldis-D;a=commitdiff;h=afd38e57

[08:44] *** dakkar joined
[08:44] <dduncan> ... and also the prior commit lays groundwork, since I had used double-backslash for something else which had to be altered first so not to conflict

[08:44] <moritz_> I'm curious, what did it mean before?

[08:47] <dduncan> moritz_, was that question directed at me?

[08:47] <moritz_> dduncan: yes

[08:47] <dduncan> okay, the old meaning was related to "unspace"

[08:48] <dduncan> the prior commit - http://utsl.gen.nz/gitweb/?p=Muldis-D;a=commitdiff;h=e25af94a2

[08:48] <dduncan> essentially, I was using the same grammar token, a backslash pair surrounding optional whitespace, for 2 distinct purposes

[08:49] <dduncan> one inside strings to split them over lines, and the other like Perl 6's unspace but without (initially) embedded comments

[08:49] <dduncan> optional whitespace means a double backslash could be in a string literal

[08:49] <dduncan> I split the concepts so that the one inside the literal is now called 'splitter' instead of 'unspace' and the whitespace is mandatory

[08:50] *** Ross left
[08:50] <dduncan> in the future I'll probably update my 'unspace' to have embedded comments, but I omitted those for now for simplicity

[08:53] <dduncan> er, hm, just realized another thing I have to fix ...

[08:53] *** meppl joined
[08:54] *** thebird left
[08:55] <dduncan> the "\ " in a string is now ambiguous ...

[08:57] *** mikehh joined
[09:05] <dalek> niecza: 7292187 | sorear++ |  (3 files):

[09:05] <dalek> niecza: cleanup .method, implement dup@, start Mu

[09:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/7292187b228480699b79f175d465806f3a7de7b4

[09:05] <dalek> niecza: 8c57de0 | sorear++ |  (4 files):

[09:05] <dalek> niecza: Nicer syntax for boxing in NIL

[09:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/8c57de09041e0831ecc0c7f701294691b67671d7

[09:05] <dalek> niecza: 5135541 | sorear++ |  (4 files):

[09:05] <dalek> niecza: Bootstrap more methods.  Add integers to NIL.  NEW CLASS: Mu

[09:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/5135541502489076d3f5b743e554a36115bfbfd0

[09:07] <sorear> it's finally starting to come together

[09:11] <dduncan> now that's fixed - http://utsl.gen.nz/gitweb/?p=Muldis-D;a=commitdiff;h=6756404

[09:12] * sorear out.

[09:12] <dduncan> ditto

[09:12] <dduncan> I mean ...

[09:12] * dduncan ditto

[09:12] *** _mpu joined
[09:22] *** mberends left
[09:44] *** Ravi joined
[09:45] *** Ravi left
[09:50] *** quietfanatic left
[09:50] *** masak left
[09:54] *** dduncan left
[10:03] *** lestrrat is now known as lest_away

[10:04] *** jaldhar joined
[10:10] *** thebird joined
[10:17] <jnthn> Afternoon, #perl6

[10:18] *** pmurias joined
[10:19] <moritz_> did you see the new don knuth talk? it's hilarious

[10:20] <pmurias> moritz_: link?

[10:20] <moritz_> http://river-valley.tv/media/conferences/tug-2010/Don-Knuth/

[10:20] <moritz_> and if that times out, try a mirror: http://onlineflashplayer.net/?url=http%3A%2F%2Fwww.argafal.de%2Fpublic%2FDon-Knuth.flv

[10:23] *** skids joined
[10:27] *** Ross joined
[10:30] <pmurias> YOU_ARE_HERE works in mildew :)

[10:30] <moritz_> /me IS THERE

[10:36] *** dakkar left
[10:38] <hghgd> "the bell is also part of the logo" :)

[10:38] <moritz_> :-)

[10:46] *** agentzh left
[10:46] *** dakkar joined
[10:58] *** Trashlord joined
[11:06] *** szabgab left
[11:06] *** john__ left
[11:06] *** literal left
[11:09] *** szabgab joined
[11:09] *** john__ joined
[11:09] *** literal joined
[11:09] *** ascent_ joined
[11:09] *** mdxi_ joined
[11:09] *** fda314925 joined
[11:09] *** TimToady joined
[11:09] *** farmer.freenode.net sets mode: +o TimToady

[11:14] <dalek> nqp-rx: d01b490 | pmichaud++ | src/HLL/Compiler.pm:

[11:14] <dalek> nqp-rx: Refactor interactive mode context handling slightly.

[11:14] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/d01b4905910c227cf43828df3e0684bc944e7c06

[11:14] <dalek> nqp-rx: 2fb1606 | pmichaud++ | src/stage0/ (3 files):

[11:14] <dalek> nqp-rx: Update bootstrap files.

[11:14] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/2fb16068114fbb420af8851d8a809e1bb34b12f2

[11:14] *** Backglass joined
[11:15] *** hghgd_ joined
[11:15] <Backglass> who can help me using regex?

[11:16] * hejki prepares for collective facepalm

[11:19] *** hghgd left
[11:22] *** Guest7606 left
[11:22] *** Guest7606 joined
[11:22] *** Guest7606 is now known as pragma_

[11:25] *** wallberg joined
[11:31] *** wallberg left
[11:35] <pmichaud> pmichaud@plum:~/rakudo$ ./perl6

[11:35] <pmichaud> > my $a = 5;

[11:35] <pmichaud> 5

[11:35] <pmichaud> > say $a * 3

[11:35] <pmichaud> 15

[11:35] <arnsholt> Shiny!

[11:36] <pmichaud> > role A { method x() { say 'x' } };  class B does A { };  B.new.x

[11:36] <pmichaud> x

[11:38] <moritz_> Perl 6 regex?

[11:39] <dalek> rakudo: 5f40d37 | pmichaud++ | src/Perl6/Actions.pm:

[11:39] <dalek> rakudo: Rename some setup variables to be more accurate.

[11:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/5f40d37f39e40a069941e87f742d395b1bd1abe8

[11:39] <dalek> rakudo: b0cd2b8 | pmichaud++ | src/ (2 files):

[11:39] <dalek> rakudo: Add a $MAIN parameter to unit mainline (signals that the unit is the mainline).

[11:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/b0cd2b8f32315ecf54dc1a3cfe831e40b0edeb3b

[11:39] <dalek> rakudo: c9aa0e9 | pmichaud++ | src/Perl6/Actions.pm:

[11:39] <dalek> rakudo: Refactor !YOU_ARE_HERE to use outer_ctx.

[11:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c9aa0e91e9c1525397466e2f64ea34ca2ced8b55

[11:39] <dalek> rakudo: 3d0a9c2 | pmichaud++ | src/glue/run.pir:

[11:39] <dalek> rakudo: Refactor !UNIT_START.

[11:39] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3d0a9c2e6424c974a8109e94d103ef59531a6e38

[11:39] <dalek> rakudo: 114971b | pmichaud++ | build/PARROT_REVISION:

[11:39] <dalek> rakudo: Bump PARROT_REVISION.

[11:39] <moritz_> pmichaud: btw [Coke] has asked to link to the nqp-rx revision in the parrot commit that updates the nqp-rx bootstrap

[11:40] <moritz_> wich I kinda like, for easier bisecting

[11:40] <pmichaud> moritz_: okay, wfm

[11:41] <pmichaud> time for some sleep -- bbl

[11:42] <moritz_> good night

[11:42] <jnthn> pmichaud: Wow!!

[11:42] <jnthn> pmichaud++

[11:48] <moritz_> pmichaud++ indeed

[11:53] <Juerd> Why is the executable named perl6, not rakudo?

[11:54] <moritz_> hysterical raisins?

[11:59] <jnthn> I think there's a precedent of people typing language name rather than implementation name in many cases. I'm pretty sure it's "java" or "javac" whichever underlying compiler/vm implementation you have.

[12:00] <moritz_> otoh C compiler names differ

[12:00] <szbalint> would mess up a whole lot of shebang lines too

[12:00] *** proller left
[12:00] <jnthn> Though perhaps perl6 wants to be an alias to rakudo and then people can choose which implementation their perl6 is aliased to as well as easily get at different impls.

[12:01] <takadonet> morning all

[12:02] *** proller joined
[12:08] *** pmurias left
[12:10] *** pmurias joined
[12:12] *** sftp joined
[12:14] *** bluescreen joined
[12:15] *** bluescreen is now known as Guest43164

[12:26] *** ruoso joined
[12:31] *** duzy`` left
[12:32] *** Trashlord left
[12:34] *** Trashlord joined
[12:36] *** Backglass_ joined
[12:39] *** Backglass left
[12:39] *** Backglass_ left
[12:39] *** Backglass joined
[12:42] *** pmurias left
[12:43] *** Backglass left
[12:49] *** rgrau_ joined
[12:53] *** Mowah left
[12:57] *** Mowah joined
[13:02] *** IllvilJa joined
[13:09] *** charsbar_ joined
[13:11] *** charsbar left
[13:11] *** rokoteko left
[13:11] *** rokoteko_ joined
[13:11] *** BinGOs_ joined
[13:12] *** tadzik joined
[13:13] *** araujo left
[13:13] *** spinclad_ joined
[13:14] *** araujo joined
[13:14] *** sunnavy_ joined
[13:15] *** TiMBuS left
[13:15] *** szbalint left
[13:15] *** sunnavy left
[13:15] *** LionMadeOfLions left
[13:17] *** BinGOs_ is now known as BinGOs

[13:17] *** BinGOs left
[13:17] *** BinGOs joined
[13:17] <[Coke]> my preference would be that we get a rakudo, and have a switch (hardwired to on for now. =-) that installed a copy / link as perl6

[13:17] *** nsh_ joined
[13:19] <Juerd> That's a good idea

[13:24] *** szbalint joined
[13:27] *** TiMBuS joined
[13:27] *** athomason joined
[13:35] *** jaldhar left
[13:41] *** hans__ joined
[13:50] *** Ross left
[13:50] *** tylercurtis joined
[13:54] *** nicePerl6 joined
[13:55] *** nicePerl6 left
[13:55] *** hans__ left
[13:59] *** uniejo left
[14:16] <pmichaud> good morning, #perl6

[14:16] <mathw> oh hai pmichaud

[14:17] <jnthn> morning, pmichaud 

[14:19] <pmichaud> hugme: tweet rakudoperl Rakudo's REPL now remembers lexical variables across input lines

[14:19] * hugme hugs pmichaud; tweet delivered

[14:20] <mathw> \o/

[14:20] <mathw> pmichaud++

[14:20] <TiMBuS> yes. yes!

[14:21] <jnthn> pmichaud: I see your roles lexicals fix worked too

[14:21] *** perlygatekeeper left
[14:21] <jnthn> pmichaud: I'm not sure I understand why. :-)

[14:21] <jnthn> But I'm happy it's fixed. :-)

[14:21] <pmichaud> actually, I don't think it worked.

[14:21] <pmichaud> I think it must be an artifact of something else going on.

[14:21] <pmichaud> need tests.  :-)

[14:22] <pmichaud> if it did work, it's because I somehow changed the order of initialization :-)

[14:22] <jnthn> rakudo: role R { method m { say 42 } }; class C does R { }; C.new.m

[14:22] <p6eval> rakudo 855ca6: OUTPUT«Could not find sub &say␤  in 'm' at line 11:/tmp/uC4AK36C_m␤  in main program body at line 11:/tmp/uC4AK36C_m␤»

[14:22] <jnthn> pmichaud: That's the classic test case.

[14:22] <jnthn> (not sure if p6eval is up to date)

[14:22] <pmichaud> right.  I don't know why it worked for me.

[14:22] <pmichaud> but:

[14:22] <dalek> rakudo: ddf224e | pmichaud++ | docs/spectest-progress.csv:

[14:22] <dalek> rakudo: spectest-progress.csv update: 507 files, 33926 (84.5% of 40171) pass, 2 fail

[14:23] <dalek> rakudo: Failure summary:

[14:23] <dalek> rakudo: S32-temporal/DateTime.t 15 - epoch at 1970-01-01 01:01:01

[14:23] <dalek> rakudo: S32-temporal/DateTime.t 16 - as Str 1970-01-01T01:01:01+0100

[14:23] <dalek> rakudo: S32-temporal/DateTime.t passed 18 unplanned test(s)

[14:23] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ddf224e8b8f5299a5533d5f6d828491daaed5b50

[14:23] <TiMBuS> rakudo: any(Int) ~~ Int

[14:23] <p6eval> rakudo 855ca6:  ( no output )

[14:23] <TiMBuS> rakudo: say any(Int) ~~ Int

[14:23] <p6eval> rakudo 855ca6: OUTPUT«0␤»

[14:23] <TiMBuS> ^should that work

[14:23] <pmichaud> rakudo: say 42; { role R { method m { say 42 } }; class C does R { };  C.new.m }

[14:23] <p6eval> rakudo 855ca6: OUTPUT«42␤Could not find sub &say␤  in 'm' at line 11:/tmp/c3KgwWOEid␤  in main program body at line 11:/tmp/c3KgwWOEid␤»

[14:24] <pmichaud> hmmm

[14:24] <pmichaud> anyway, for some reason it "worked" that one time for me in the repl.   not sure why.

[14:24] <pmichaud> rakudo:  say Int ~~ Int

[14:24] <p6eval> rakudo 855ca6: OUTPUT«1␤»

[14:25] <jnthn> TiMBuS: I don't think so.

[14:25] <jnthn> It's a type check

[14:25] <pmichaud> TiMBuS: I'm not sure how junctions are supposed to autothread there.

[14:25] <jnthn> They can't.

[14:25] <jnthn> Otherwise auto-threading won't work.

[14:25] <TiMBuS> the reverse works fine

[14:25] <jnthn> Because the type check won't fail, causing the signature not to bind, causing auto-threading.

[14:25] <TiMBuS> Int ~~ any(Int)

[14:25] <jnthn> Right

[14:26] <jnthn> But that's normal :-)

[14:26] <jnthn> Smart-match is not symmetric.

[14:26] <jnthn> In that case it does Junction.ACCEPTS

[14:26] <jnthn> Which threads through the things in the junction.

[14:32] *** alester joined
[14:33] *** perlygatekeeper joined
[14:34] *** perlygatekeeper left
[14:37] *** plobsing joined
[14:38] *** macdaddy joined
[14:38] *** macdaddy is now known as Guest84429

[14:40] <jnthn> pmichaud: confusing bug is confusing.

[14:40] <jnthn> > role R { method m { say 42 } }; class C does R { }; C.new.m

[14:40] <jnthn> Could not find sub &say

[14:40] <jnthn> however

[14:41] <jnthn> > role R { method m { say 42 } }

[14:41] <jnthn> R()

[14:41] <jnthn> > class C does R { }; C.new.m

[14:41] <jnthn> 42

[14:41] <pmichaud> right

[14:41] *** patspam joined
[14:42] <pmichaud> it probably has to do with the way the REPL now captures lexicals from one line to the next

[14:43] <pmichaud> in fact

[14:43] <jnthn> oh!!

[14:43] <jnthn> Actually

[14:43] <jnthn> I think it's to do with the fact that we run the body of the role at the time the "does" statement happens

[14:43] <jnthn> And that is in a :load :init

[14:44] <jnthn> In the case where it's split over lines, the role body block has had change to somehow get captured by the mainline body instead.

[14:44] <moritz_> speaking of loading times... why is module loading deferred to :load :init time?

[14:45] <jnthn> moritz_: It shouldn't be - unless it's in a pre-compiled module and that's the earliest it can happen

[14:45] <jnthn> But we should be loading them when we parse a use statement otherwise.

[14:45] <jnthn> Otherwise we can't stub lexicals into the lexpad

[14:45] <moritz_> rakudo: use Test; BEGIN { @*INC.push: 't/spec/package/' }

[14:45] <p6eval> rakudo 855ca6:  ( no output )

[14:45] <moritz_> rakudo: use Test; BEGIN { @*INC.push: 't/spec/packages/' }

[14:45] <p6eval> rakudo 855ca6:  ( no output )

[14:46] <moritz_> locally that failed...

[14:46] <moritz_> maybe fixed by now

[14:46] <jnthn> I did it in the REPL and it works OK

[14:46] <moritz_> oh wait

[14:46] <moritz_> rakudo: use Test; BEGIN { @*INC.unshift: 't/spec/packages/' }

[14:46] <jnthn> no error with -e either

[14:47] <p6eval> rakudo 855ca6:  ( no output )

[14:47] <moritz_> hm

[14:47] <moritz_> it used to do the 'use' too late

[14:47] <moritz_> and then find t/spec/packages/Test.pm

[14:47] <moritz_> and fail during loading

[14:47] <moritz_> but it seems to be fixed now

[14:49] *** masak joined
[14:52] <pmichaud> yes, I want to switch BEGIN so that it's an actual phaser, instead of having its own separate way of doing things.

[14:52] <masak> pmichaud++! # REPL memory

[14:57] <dalek> rakudo: c89a843 | pmichaud++ | src/ (2 files):

[14:57] <dalek> rakudo: Remove IN_EVAL() function, $*IN_EVAL dynvar.

[14:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c89a843ff1720077df1da5e3e51f8736adc27e4d

[14:57] <dalek> rakudo: 17654af | pmichaud++ | docs/ROADMAP:

[14:57] <dalek> rakudo: Mark REPL task as done in the ROADMAP.

[14:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/17654af2241ae487d5734597b8cbec149f803e5a

[14:57] <dalek> rakudo: 7bbb35f | pmichaud++ | docs/spectest-progress.csv:

[14:57] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[14:57] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/7bbb35f84ca73c9de29d38ef89d42d15cbc64748

[15:00] *** Backglass joined
[15:00] <masak> Backglass: hi!

[15:04] *** tadzik left
[15:04] <pmichaud>     is $x.map({ .key => .value + 1}), ('a' => 6), 'map on pair works (=>)';

[15:04] * IllvilJa concludes that "programmers are unreasonable" after reading a blog post by Ovid...

[15:04] <pmichaud> how are we calling this one?  Should the block passed to .map end up being a hash composer or no?

[15:05] <moritz_> pmichaud: block, because it uses $_

[15:05] <pmichaud> ...and the same would be true with      { 'a' => 3 + $_ }      ?

[15:06] <moritz_> yes

[15:06] <pmichaud> my $hash = { 'a' => 3 + $_ };   # fail.

[15:06] *** plobsing left
[15:06] <moritz_> (the tests might not be consistent in some cases)

[15:06] <moritz_> right.

[15:07] <dakkar> hm. has anyone seen TimToady in the last few days?

[15:07] <TimToady> nope

[15:07] <moritz_> no mirrors around?

[15:07] <pmichaud> Tim... who?

[15:07] <dakkar> hi!

[15:07] <dakkar> TimToady: I'm just chasing down the last few speakers for the YAPC::EU

[15:08] <dakkar> can I count on you for a 40- or 50-min keynote?

[15:08] <TimToady> sure

[15:08] <moritz_> \o/

[15:08] <pmichaud> has anyone noticed that flights to pisa from the u.s. are on the expensive side, and have weird times?  ;-)

[15:08] <pmichaud> actually, getting *to* pisa is pretty easy, it's getting back that is weirdish.  :)

[15:08] <TimToady> we're flying from Barcelona...

[15:09] <pmichaud> ...because you'll happen to be there already, or because that ends up being easier than the other options?

[15:09] <moritz_> pmichaud: Munich <-> Pisa is no problem either way

[15:09] <moritz_> with Lufthansa

[15:09] <dakkar> TimToady: could you log into the website and tell it that you are attending? then I'll create the talk and you can edit it at your leisure (relatively speaking…)

[15:09] <dakkar> http://conferences.yapceurope.org/ye2010/

[15:09] <pmichaud> dakkar: I noticed that my NQP talk was accepted (yay) -- would you prefer the Perl 6 talk instead?

[15:10] <dakkar> pmichaud: we already have a few P6 talks, NQP seemed more interesting from a general point of view…

[15:11] <pmichaud> dakkar: wfm

[15:11] <[particle]> perl 6 is old news. nqp is the new hotness :)

[15:13] *** Backglass left
[15:14] <TimToady> dakkar: okay, I'm registrationalized.

[15:16] <dakkar> TimToady: great, thanks

[15:17] <dakkar> http://conferences.yapceurope.org/ye2010/talk/2953 ← here's your keynote, make something up :)

[15:17] <pmichaud> dakkar: I think he always does.  :-)

[15:17] *** Backglass joined
[15:18] <dakkar> that's why we like him :)

[15:18] <TimToady> probably something on the order of "What makes Perl Perl?" this time

[15:18] *** perlygatekeeper joined
[15:18] *** LionMadeOfLions joined
[15:18] *** Backglass left
[15:18] <masak> rakudo: Any.substr(0, 1)

[15:18] <p6eval> rakudo ddf224: OUTPUT«Method 'substr' not found for invocant of class ''␤  in main program body at line 11:/tmp/8hDhgTiUk_␤»

[15:18] <masak> I think I read somewhere that this is expected nowadays.

[15:18] <masak> and I think I agree.

[15:18] <moritz_> right

[15:18] <masak> rakudo: substr(Any, 0, 1)

[15:19] <p6eval> rakudo ddf224: OUTPUT«Method 'chars' not found for invocant of class ''␤  in 'Cool::substr' at line 2121:CORE.setting␤  in main program body at line 11:/tmp/BLXjHiaPx8␤»

[15:19] <masak> but that... why does it even call something?

[15:19] * masak submits rakudobug

[15:19] <pmichaud> maybe want a type constraint on the first arg.

[15:19] <moritz_> it should type-constrain substr() to Cool 

[15:19] <masak> moritz_: that's what I think too.

[15:19] <pmichaud> (or invocant, if it's an "is export" method)

[15:19] <masak> AFAICS, the sub is exported from Cool.substr

[15:20] <masak> so it should have an implicit typing on the invocant.

[15:20] <pmichaud> right

[15:20] <moritz_> shouldn't the exporting add a constraint automatically?

[15:20] * moritz_ too slow to type

[15:20] <TimToady> hmm, if substr calls chars, we can't use it to test a cat string to see if there are more chars with $cat.substr($pos,1)

[15:20] *** Backglass_ joined
[15:20] <masak> I'd actually like to ask for &substr the sub to work on Any, if that's at all possible.

[15:20] <TimToady> Any is not Cool

[15:20] <moritz_> might be a pecularity of the implementation though

[15:20] <masak> it could just coerce it to an empty Str or somthing.

[15:21] <pmichaud> the use of .chars is undoubtedly a think-o.

[15:21] <pmichaud> lots of times people contributing code run to .elems and .chars without asking if there's a lazier way to do it

[15:21] <moritz_> maybe it was to avoid "can't take substr out of range" or so

[15:21] <TimToady> well, one way or another, we need a primitive that lets us work through a string without committing to finding its end

[15:22] <moritz_> ... and please don't let it be split() :-)

[15:22] <pmichaud>         my $len = $length // self.chars;

[15:22] <pmichaud> bah.

[15:22] <masak> I need to delimit this ticket somehow. I think the bug is that the sub is not constrained to Cool.

[15:22] <masak> but I'll include the other things too for posterity.

[15:22] <moritz_> masak: that's right

[15:23] <pmichaud> TimToady: we're safe there, though -- if $length is provided we don't call .chars

[15:23] <pmichaud> (we break a little later on, but that's fixable)

[15:23] <TimToady> perhaps cat strings have "false ends", and there's just an extra loop around when you think you've run out that increases it

[15:24] <jnthn> Note that Rakudo doesn't put type constraints on invocants properly yet

[15:25] <jnthn> So if the method is exported it won't type-check it's invocant unless you are explicit about what it should check just yet.

[15:25] <jnthn> A few days ago, it didn't even do that though... :-)

[15:25] <pmichaud> right

[15:25] <moritz_> jnthn: for every NYI feature you implement, we find two more to do :-)

[15:26] <jnthn> Great, I'll be trying to implement Perl 6 for the rest of my life! :P

[15:26] <dalek> rakudo: 894e793 | pmichaud++ | t/harness:

[15:26] <dalek> rakudo: Fix bug with --long and --stress option handling.

[15:26] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/894e79347b5db1fc90b44806bc83ac23146ca992

[15:26] <moritz_> jnthn: the good news is that you'll get used to it :-)

[15:26] <jnthn> pmichaud: Is --long everything?

[15:27] <jnthn> .oO( at this point, --even-longer might be more apt ;-) )

[15:27] <TimToady> it just means the community must keep doubling to keep up with what needs to be done

[15:28] * moritz_ hopes that when the community expands, the code developer pool also expands

[15:28] <TimToady> we must all be resigned to becoming a smaller percentage of the Perl 6 community :)

[15:28] <pmichaud> jnthn: --long is default

[15:28] <pmichaud> basically, a test can be marked as #long or as #stress

[15:28] <pmichaud> by default, #long tests get run (this was the bug -- they weren't being run)

[15:29] <pmichaud> by default #stress tests are not run

[15:29] <pmichaud> so:

[15:29] <jnthn> Is there a make quicktest?

[15:29] <pmichaud> yes.

[15:29] <jnthn> aha!

[15:29] <jnthn> \o/

[15:29] <pmichaud> make quicktest does --long=0

[15:29] <pmichaud> and skips the S05-mass/rx.t and S32-trig tests

[15:29] <pmichaud> (and any other tests we deem to be "#long" in t/spectest.data)

[15:30] <jnthn> Is it kosher to mostly run make quicktest and then commit if it's clean, if it's unlikely the patch woulda broken either of those?

[15:30] <pmichaud> make spectest doesn't add any options, so we get the long tests but not the stress tests

[15:30] <pmichaud> make stresstest  does --stress=1

[15:30] <pmichaud> which includes those tests that we deem to be "really long"  :-)

[15:30] <moritz_> jnthn: I'll tell you when you broke something :-)

[15:30] <pmichaud> jnthn: yes, it's kosher

[15:30] <pmichaud> use best judgement here

[15:31] <jnthn> .oO( testing...without the pork! )

[15:31] <jnthn> pmichaud: I'll try ;-)

[15:31] <pmichaud> Since adding those, I've been tending to do "make quicktest" on local commits, and then a "make spectest" before push.

[15:31] <jnthn> *nod*

[15:32] <pmichaud> anyone have further comments on the discussion from http://irclog.perlgeek.de/perl6/2010-07-06#i_2523937 ?   (about "why Rakudo Star"?)

[15:32] <pmichaud> I'll be drafting some text later this morning

[15:32] <pmichaud> (unless I get sidetracked)

[15:37] <pmichaud> rakudo:  my @array = <1 2 3>;   say ?(@array[0,1] ~~ List);  say @array[0,1].WHAT;

[15:37] <p6eval> rakudo ddf224: OUTPUT«0␤Parcel()␤»

[15:37] <pmichaud> does @array[0,1] have to be a *List*?

[15:38] <pmichaud> Parcel feels more appropriate

[15:38] <moritz_> pmichaud: shouldn't you be the one answering the question? :-)

[15:38] <pmichaud> well, it feels funny to require Parcel, too.

[15:38] * moritz_ would require Positional

[15:39] <pmichaud> I'll switch to Positional for now.

[15:40] *** timbunce joined
[15:41] <masak> ok, so the &substr thing was one of two things that had broken in GGE since last time I got it up to date. the other thing was that $obj.?nosuchmethod now gives Nil, not Failure.

[15:41] <masak> +1 on that, by the way.

[15:41] <masak> but how does one test for Nil-ness in a nice way?

[15:41] <pmichaud> ~ Nil   seems to work.

[15:41] <pmichaud> er, ~~ Nil

[15:41] <TimToady> or ~~ () is the same thing

[15:41] <pmichaud> rakudo:  sub foo() { return; };   say foo ~~ Nil;

[15:41] <masak> right.

[15:41] <p6eval> rakudo ddf224: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'foo' at line 11:/tmp/SAbgTooWgg␤  in main program body at line 11:/tmp/SAbgTooWgg␤»

[15:42] <pmichaud> rakudo:  sub foo() { return; };   say foo() ~~ Nil;

[15:42] <p6eval> rakudo ddf224: OUTPUT«1␤»

[15:42] <masak> for some reason I settled on 'eqv Nil' in my code.

[15:42] <pmichaud> eqv Nil also works.

[15:42] <pmichaud> TimToady: do we allow "list binding"?  e.g.,    @a[1,2] := ($x, $y);

[15:42] <pmichaud> (please say "no")

[15:43] <TimToady> we can say no for now

[15:43] <pmichaud> we don't have a list prefix form of := at the moment anyway.

[15:43] *** zostay left
[15:44] *** zostay joined
[15:44] *** Ross joined
[15:44] *** envi^home joined
[15:47] <TimToady> I think if Cat ~~ Stringy, then perhaps any Stringy needs to be able to handle * as a length, and have a Stringy.reify($pos) that returns $pos max $actualchars

[15:48] <tylercurtis> pmichaud: I can't seem to get your attention in #parrot, so I'll ask here. Would you mind giving me, off the top of your head, a guess as to which PAST::Node subclass attributes might be useful to traverse for PAST::Walker/Transformer/etc.? Mainly, I'm looking for things like viviself, control, loadinit, etc. that can contain other PASTs.

[15:48] <pmichaud> tylercurtis: I think you named them all already.  :)

[15:48] <TimToady> and substr would say my $realchars = $stringy.reify($offset+length)

[15:48] <pmichaud> let me re-check.

[15:51] <pmichaud> tylercurtis: viviself, vivibase, control, loadinit

[15:51] <pmichaud> that's all I see at the moment.

[15:51] <tylercurtis> pmichaud: thanks.

[15:53] <pugssvn> r31567 | pmichaud++ | [t/spec]:  Update some tests on slices, resolve RT #63014. 

[15:56] <masak> tylercurtis: any comment on http://gist.github.com/464349 ? I hope I'm not creating too much downstream chasing for you with your LLVM compiler.

[16:00] <pmichaud> rakudo:  'a' ~~ /<alpha>/; for %($<alpha>) { say $_ }

[16:01] <p6eval> rakudo ddf224:  ( no output )

[16:08] *** Backglass_ left
[16:08] <tylercurtis> masak: I like that change, actually. I'd rather you not rather worry about changing SIC on my account, anyway. Thanks for the warning, though. Not only will it be helpful to know that environment is going away when I implement blocks, it's given me an idea about how to implement them.

[16:08] *** pragma_ left
[16:09] <masak> tylercurtis: cool.

[16:09] <TimToady> I am coming to the conclusion that ~~ should autothread, and relegate the highly specialized Junction testing to .^does(Junction)

[16:09] <masak> tylercurtis: yes, I very much like the change too. I hope to find some quiet hacking time to write a new runtime for it.

[16:10] <TimToady> we've run into that several times in recent days, and I think the autothreading will be much more useful

[16:10] <TimToady> that is, the arg to ACCCEPTS should be Any, not Mu

[16:10] *** quietfanatic joined
[16:10] <TimToady> *CC

[16:10] <quietfanatic> rakudo: say [[4, 5], [6, 7]].map: {.perl}

[16:11] <p6eval> rakudo ddf224: OUTPUT«[4, 5][6, 7]␤»

[16:11] <quietfanatic> isn't map supposed to recurse into nested structures?

[16:11] <moritz_> nope

[16:11] <wolverian> no.

[16:11] <moritz_> only hyper operators do

[16:12] <quietfanatic> hm.

[16:16] <pmichaud> TimToady: that might be a bit of a problem, since .ACCEPTS is what we use for type checking and multidispatch

[16:16] <pmichaud> TimToady: is it sufficient if ~~ expects a lhs of Any ?

[16:16] <pmichaud> so that ~~ autothreads, and .ACCEPTS doesn't?

[16:17] *** pragma_ joined
[16:17] <TimToady> well, that precludes a simple desugaring implementatoin

[16:17] *** pragma_ is now known as Guest52181

[16:17] <pmichaud> we can try it and see.

[16:17] <pmichaud> (.ACCEPT autothreads)

[16:17] <TimToady> why are you using .ACCEPTS and not the more basic .does?

[16:18] <pmichaud> sorry, "type checking" being more generic than just does

[16:18] *** hghgd_ left
[16:18] <pmichaud> e.g.     sub foo($x where { ... }) { ... }

[16:18] <TimToady> so, constraint checking?

[16:18] <pmichaud> right

[16:19] <cono> rakudo: say $*VM<config><osname>

[16:19] <p6eval> rakudo ddf224: OUTPUT«linux␤»

[16:19] <TimToady> okay, lemme think about ACCEPTS s'more while I'm out walking

[16:19] <pmichaud> sure thing.

[16:20] <TimToady> did you see my .reify proposal above?

[16:20] *** Ross left
[16:20] <pmichaud> I did.

[16:20] <masak> swimming &

[16:20] *** masak left
[16:20] <pmichaud> I'm waiting for a better definition of cats before jumping on it.  :-)

[16:20] *** ruoso left
[16:20] <pmichaud> but it looks to me like we're just reinventing or copying the laziness model for strings :)

[16:21] <TimToady> .oO(you're never quite sure how many lives a cat has remaining...)

[16:21] <pmichaud> (which is fine)

[16:21] <TimToady> well, it's positing that the Stringy abstraction can have an underlying impementation that pulls from a lazy list, at least

[16:23] <TimToady> whether that turns into Ropes Of Unknown Size is anyone's guess

[16:23] <TimToady> walking &

[16:23] * pmichaud avoids the fire swamp.

[16:23] <pmichaud> rakudo:  my Int $b = "4" - 3;

[16:23] <p6eval> rakudo ddf224: OUTPUT«Type check failed for assignment␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/luNImBS3qe␤»

[16:24] *** Ross joined
[16:24] *** dakkar left
[16:26] <pmichaud> rakudo: my @a = 1,2,3;  say @a min 4;

[16:26] <p6eval> rakudo ddf224: OUTPUT«1␤»

[16:26] <pmichaud> rakudo: my @a = 1,2,3;  say +@a min 4;

[16:26] <p6eval> rakudo ddf224: OUTPUT«3␤»

[16:29] *** thebird left
[16:29] <pmichaud> rakudo:  say "README" ~~ :f

[16:30] <p6eval> rakudo ddf224: OUTPUT«0␤»

[16:30] <pmichaud> rakudo:  say "/etc/passwd" ~~ :f

[16:30] <p6eval> rakudo ddf224: OUTPUT«1␤»

[16:30] <pmichaud> rakudo:  say "/etc/passwd" ~~ :s

[16:31] <p6eval> rakudo ddf224: OUTPUT«1␤»

[16:31] <pmichaud> rakudo:  say "/etc/passwd" ~~ :d

[16:31] <p6eval> rakudo ddf224: OUTPUT«0␤»

[16:31] <pmichaud> rakudo:  say "/etc" ~~ :d

[16:31] <p6eval> rakudo ddf224: OUTPUT«1␤»

[16:35] *** ruoso joined
[16:35] *** skids left
[16:40] *** cdarroch joined
[16:40] *** cdarroch left
[16:40] *** cdarroch joined
[16:40] *** ashleydev joined
[16:42] *** ash_ joined
[16:43] *** Guest84429 left
[17:02] *** TiMBuS left
[17:04] *** alester left
[17:04] *** alester joined
[17:04] *** alester left
[17:10] *** timbunce left
[17:13] *** timbunce joined
[17:16] <lue> ohai o/

[17:16] *** clintongormley left
[17:23] *** envi^home left
[17:23] <quietfanatic> How do I get the modtime of a file?

[17:23] <quietfanatic> There doesn't seem to be a defined way.

[17:24] <quietfanatic> short of run 'stat $_'

[17:24] *** timbunce left
[17:27] *** hercynium left
[17:28] *** patspam left
[17:29] *** eternaleye joined
[17:34] *** Backglass joined
[17:35] *** clintongormley joined
[17:36] *** dtwright joined
[17:37] *** dtwright left
[17:41] *** shade_ joined
[17:46] <moritz_> it seems to be missing indeed

[17:47] <moritz_> probably something like $filename.IO.modification-time or so

[17:47] *** rokoteko_ is now known as rokoteko

[17:47] *** rokoteko left
[17:47] *** rokoteko joined
[17:50] <ash_> $filename.IO.last-modified ? 

[17:50] *** shade_ left
[17:50] <ash_> (its a bit shorter) 

[17:50] *** shade_ joined
[17:51] <lue> I thought there was a file test for that.

[17:51] <lue> (like :e, :f, etc.)

[17:52] <TimToady> file tests only return boolean in p6

[17:52] <quietfanatic> rakudo: say '/etc/passwd'.IO.last-modified

[17:52] <p6eval> rakudo 894e79: OUTPUT«Method 'IO' not found for invocant of class 'Str'␤  in main program body at line 11:/tmp/IcZRPcD3nD␤»

[17:52] <TimToady> rakudo: say open('/etc/passwd').last-modified

[17:52] <p6eval> rakudo 894e79: OUTPUT«Method 'last-modified' not found for invocant of class 'IO'␤  in main program body at line 11:/tmp/QxUgtP7sE0␤»

[17:52] <TimToady> rakudo: say open('/etc/passwd').modification-time

[17:52] <p6eval> rakudo 894e79: OUTPUT«Method 'modification-time' not found for invocant of class 'IO'␤  in main program body at line 11:/tmp/JtnVOJuCp3␤»

[17:53] <TimToady> rakudo: say ~IO.^methods

[17:53] <quietfanatic> rakudo: say open('/etc/passwd').^methods(:local)

[17:53] <p6eval> rakudo 894e79: OUTPUT«ins print say open printf t slurp close eof autoflush lines get getc chop tanh split match exp acosh words cotan atan2 lcfirst uc sec cis log substr from-radians sprintf trans sin pred acosec subst sinh cosech abs acosech chomp index ceiling trim asec trim-leading unpolar

[17:53] <p6eval> ..trim-trai…

[17:53] <p6eval> rakudo 894e79: OUTPUT«getcinsprintsayopenprintftslurpcloseeofautoflushlinesget␤»

[17:53] <quietfanatic> rakudo: say ~open('/etc/passwd').^methods(:local)

[17:53] <p6eval> rakudo 894e79: OUTPUT«eof autoflush lines get getc ins say print open printf t close slurp␤»

[17:53] <quietfanatic> what does t do?

[17:54] <quietfanatic> rakudo: say open('/etc/passwd').t

[17:54] <p6eval> rakudo 894e79: OUTPUT«0␤»

[17:54] <TimToady> terminates the file :)

[17:54] <quietfanatic> eheh :)

[17:54] <ash_> lol

[17:55] <ash_> t seems like and odd name for that functionality 

[17:56] <TimToady> rakudo: say open('/dev/tty').t

[17:56] <p6eval> rakudo 894e79: OUTPUT«0␤»

[17:56] <lue> I would expect eof

[17:57] <TimToady> I dunno what it does

[17:57] <lue> (or eot, if that's where .t gets its name)

[17:57] <lue> .u EOT

[17:57] <phenny> U+C5CD HANGUL SYLLABLE EOT (엍)

[17:59] <ash_> :t ? 

[17:59] <jnthn>     multi method t() {

[17:59] <jnthn>         $!PIO.isatty;

[17:59] <jnthn>     }

[18:00] <lue> so it checks if it's a terminal?

[18:00] <lue> rakudo: say open('/dev/tty0').t

[18:00] <p6eval> rakudo 894e79: OUTPUT«Unable to open filehandle from path '/dev/tty0'␤  in 'open' at line 4807:CORE.setting␤  in main program body at line 11:/tmp/cly5u62_cj␤»

[18:01] <quietfanatic> rakudo: say "abc.abc" ~~ /^(.*)\.abc$/

[18:01] <p6eval> rakudo 894e79: OUTPUT«␤»

[18:01] <quietfanatic> So why doesn't this work?

[18:02] <quietfanatic> rakudo: say "abc" ~~ /^(.*)$/

[18:02] <p6eval> rakudo 894e79: OUTPUT«abc␤»

[18:03] <quietfanatic> rakudo: say ".abc" ~~ /^(.*)\.abc$/

[18:03] <p6eval> rakudo 894e79: OUTPUT«␤»

[18:03] <quietfanatic> rakudo: say ".abc" ~~ /^(.*?)\.abc$/

[18:03] <p6eval> rakudo 894e79: OUTPUT«.abc␤»

[18:03] <quietfanatic> rakudo: say ".abc" ~~ /(.*)\.abc$/

[18:03] <p6eval> rakudo 894e79: OUTPUT«␤»

[18:03] <quietfanatic> rakudo: say "abc.abc" ~~ /(.*?)\.abc$/

[18:03] <p6eval> rakudo 894e79: OUTPUT«.abc␤»

[18:03] <quietfanatic> rakudo: say "abc.abc" ~~ /^(.*?)\.abc$/

[18:03] <p6eval> rakudo 894e79: OUTPUT«␤»

[18:03] <quietfanatic> Lacking backtracking?

[18:04] <tylercurtis> rakudo: say "." ~~ /\./

[18:04] <p6eval> rakudo 894e79: OUTPUT«.␤»

[18:05] <tylercurtis> rakudo: say ".abc" /^(.*)?\.abc$/

[18:05] <p6eval> rakudo 894e79: OUTPUT«===SORRY!===␤Confused at line 11, near "say \".abc\""␤»

[18:05] <tylercurtis> rakudo: say ".abc" ~~ /^(.*)?\.abc$/

[18:05] <p6eval> rakudo 894e79: OUTPUT«.abc␤»

[18:07] <quietfanatic> If I can't do that to recognize and remove a file extension I'll have to use rindex and substr.

[18:08] <pmichaud> there's a bug in backtracking in captured expressions at the moment

[18:08] <pmichaud> but you should be able to do    /^ <name>=[.*]\.abc $/

[18:08] <pmichaud> er

[18:08] <pmichaud> but you should be able to do    /^ $<name>=[.*]\.abc $/

[18:08] <quietfanatic> I'll try that

[18:09] <tylercurtis> rakudo: "abc.abc" ~~ /^ $<name>=[.*] \.abc $/; say $<name>

[18:09] <p6eval> rakudo 894e79: OUTPUT«abc␤»

[18:10] <quietfanatic> That works.  Thanks.

[18:10] <moritz_> http://stackoverflow.com/questions/3196539/how-to-create-methods-from-arrays-or-hashes-in-perl6/3197558

[18:11] <pmichaud> regex backtracking is the last on my "big issues to fix for Rakudo #31" at the moment.

[18:11] <ash_> moritz_: isn't that because of closures? 

[18:11] <pmichaud> I got the other three out of the way this week.  :-)

[18:11] <moritz_> ash_: that's what I've answered

[18:12] <moritz_> pmichaud: for me, <foo> picking up lexicals, and escapes in char classes are also big issues

[18:12] <pmichaud> moritz_: which is bigger?

[18:12] <pmichaud> i.e., rank the three.  :-)

[18:13] <moritz_> lexicals, escapes, backtracking

[18:13] <moritz_> I know others prefer backtracking though

[18:14] <pmichaud> yeah, backtracking is the one that's likely to give the most pain.

[18:14] <pmichaud> anyway, it's likely to be (lexicals|backtracking), escapes

[18:14] <ash_> rakudo: say "abc.abc" ~~ /(.*?)\.abc$/

[18:14] <p6eval> rakudo 894e79: OUTPUT«.abc␤»

[18:15] <pmichaud> ash_: that ends up not helping either

[18:15] <ash_> sorry, i meant to do that in a /msg to p6eval 

[18:15] <pmichaud> basically, parenthesized captures and subrules act like they have a ':' immediately following them.

[18:15] <pmichaud> nqp-rx doesn't yet backtrack into them once they've succeeded

[18:22] *** justatheory joined
[18:26] <Backglass> Can someone help me to apply a regex to a variable?

[18:27] <TimToady> what have you tried?

[18:28] <moritz_> rakudo: say 'abc 123' ~~ /\d+/

[18:28] <p6eval> rakudo 894e79: OUTPUT«123␤»

[18:28] <Backglass> I'm using a module call WWW:Mechanize for make a regex in url

[18:29] <moritz_> that sounds like Perl 5

[18:29] <moritz_> or is there a Perl 6 WWW::Mechanize already?

[18:29] <Backglass> nop

[18:29] <Backglass> is in perl 6

[18:29] <Backglass> sorry

[18:29] <Backglass> perl 5

[18:29] <moritz_> then #perl6 is not quite the right channel to ask

[18:30] <Backglass> but help is a simple regex :S

[18:31] <diakopter> simple to whom?

[18:31] <Backglass> http://gist.github.com/467059

[18:31] <Backglass> this is my script in perl

[18:32] <Backglass> i want a url link this http://valeptr.com/scripts/runner.php?IM=0cdb7d28110375.

[18:32] <Backglass> but my script show all links in web

[18:32] <diakopter> like moritz_ said, people here are focused on Perl 6

[18:33] <diakopter> oh, this probably shouldn't be merely implied: and regexes are quite different in Perl 6

[18:34] <huf> nah, they're different everywhere, you just made it readily apparent ;)

[18:35] <Backglass> Does someone help me?

[18:36] <diakopter> doesn't look like it, so far. I wouldn't bet on it

[18:36] <moritz_> Backglass: is there anything that prevents you from joining a perl 5 channel, and ask for help where it's appropriate?

[18:36] <[particle]> head on over to #perl, they'll help you there

[18:36] <Backglass> ok

[18:36] <Backglass> thanks

[18:36] <Backglass> I go to #perl channel

[18:37] *** Backglass left
[18:38] <[particle]> it's better to give options for more help, rather than simply refusing to help

[18:44] <dalek> nqp-rx: 70f4eb7 | moritz++ | src/Regex/P6Regex/Actions.pm:

[18:44] <dalek> nqp-rx: put AST generation for named assertions into a separate method

[18:44] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/70f4eb714edf0fe0167602a1b78385419ec6eb7e

[18:46] <lue> (Go Germany...)

[18:47] <moritz_> "Schland"

[18:47] <moritz_> lue: http://www.youtube.com/watch?v=JFd9JvyFRYo

[18:47] <lue> s/Germany/Deutschland/  danke for reminding me :)

[18:47] <lue> Aw, I can't haz flash :(

[18:48] <moritz_> clive $url; mplayer $generated_flv_file;

[18:48] *** skids joined
[18:48] <moritz_> can I generate a PAST that does one things if a lexical exists, and something else if it doesn't?

[18:49] <moritz_> oh noez, I can see another problem coming up

[18:50] <moritz_> sub print(*@args) vs. <print> for printable characters

[18:51] *** shade_ left
[18:52] *** shade_ joined
[18:57] <lue> rakudo: my @a; my @b; say @a[1..3].WHAT

[18:57] <p6eval> rakudo 894e79: OUTPUT«Parcel()␤»

[18:58] <lue> rakudo: my @a = Nil; my @b; say @a[1..3].WHAT

[18:58] <p6eval> rakudo 894e79: OUTPUT«Parcel()␤»

[19:03] *** cono left
[19:04] *** shade_ left
[19:04] *** shade_ joined
[19:05] *** cono joined
[19:07] *** pmurias joined
[19:07] <pmurias> sorear: ping

[19:09] *** timbunce joined
[19:09] *** eternaleye left
[19:18] *** timbunce left
[19:19] <lue> > my @a = 1,2,3,4; @a[2..3] := @a[0..1]; say @a.perl

[19:19] <lue> [1, 2, 3, 4]

[19:19] <lue> well, at least now I know list binding is the issue.

[19:20] <lue> (not Nil being incorrectly handled)

[19:21] <pmichaud> lue:

[19:21] <pmichaud> 15:42 <pmichaud> TimToady: do we allow "list binding"?  e.g.,    @a[1,2] := ($x, $y);

[19:21] <pmichaud> 15:42 <pmichaud> (please say "no")

[19:21] <pmichaud> 15:43 <TimToady> we can say no for now

[19:21] <sorear> pmurias: hi

[19:21] <sorear> good morning #perl6

[19:21] * sorear -> backlog

[19:24] <lue> pmichaud: I bet the was a forced answer :)

[19:24] <lue> s/the/that/

[19:26] <pmichaud> it actually wouldn't be all that hard to implement, but it might be tricky to parse.

[19:26] <pmichaud> we'd have to do the same sorts of things for := that we're doing with = now.

[19:26] <pmichaud> anyway, "no for now" is the answer I'm going with.  :)

[19:26] * sorear back

[19:27] <lue> There is a way, which I pasted last night:

[19:27] <lue> > my @a = 1,2,3; @a[$_+3] := @a[$_] for 0..2; say @a.perl

[19:27] <lue> [1, 2, 3, 1, 2, 3]

[19:27] <tylercurtis> rakudo: my @y = 0, 0, 0, 0; my $x; my $z; [+=] $x, @y, $z, 1;  say ($x, @y, $z).join(' ')

[19:27] <p6eval> rakudo 894e79: OUTPUT«Any() 0 0 0 0 Any()␤»

[19:28] <lue> So I can use that until it works. I have been thinking about it (w/o looking at assign.pir), and the apparent issue is differently sized lists on either side.

[19:29] <lue> methinks that would require spec clarity first, to be on the safe side.

[19:30] <tylercurtis> Does Rakudo not support reduction of assignment ops?

[19:30] <lue> [ good discussion for a not-world-cup time :) ]

[19:32] <pmichaud> tylercurtis: what result were you expecting, ooc?

[19:33] <tylercurtis> According to S03, "[+=] $x, @y, $z, 1" is equivalent to "$x += @y[0] += @y[1] += @y[2] ... @y[*-1] += $z += 1", so I was expecting it to output "6 5 4 3 2 1".

[19:33] <pmichaud> seems reasonable.  :-)

[19:34] <pmichaud> my $x;  my @y = 0, 0, 0, 0;  my $z;   $x += @y[0] += @y[1] += @y[2] += $z += 1;  say ($x, @y, $z).join(' ')

[19:34] <pmichaud> rakudo: my $x;  my @y = 0, 0, 0, 0;  my $z;   $x += @y[0] += @y[1] += @y[2] += $z += 1;  say ($x, @y, $z).join(' ')

[19:34] <p6eval> rakudo 894e79: OUTPUT«1 1 1 1 0 1␤»

[19:35] <pmichaud> rakudo: my $x;  my @y = 0, 0, 0;  my $z;   $x += @y[0] += @y[1] += @y[2] += $z += 1;  say ($x, @y, $z).join(' ')

[19:35] <p6eval> rakudo 894e79: OUTPUT«1 1 1 1 1␤»

[19:35] <pmichaud> however, looks like the result is 1, 1, 1, 1, 1  :-P

[19:35] *** rhr left
[19:37] <ash_> rakudo: my 'foo'

[19:37] <ash_> oops 

[19:37] <p6eval> rakudo 894e79: OUTPUT«===SORRY!===␤Malformed my at line 11, near "'foo'"␤»

[19:37] <tylercurtis> rakudo: my $x; my @y = 0, 0, 0; my $z; $x = @y[0] = @y[1] = @y[2] = $z = 5; say ($x, @y, $z).join(' ')

[19:37] <p6eval> rakudo 894e79: OUTPUT«5 0 5 5 5␤»

[19:38] <lue> rakudo: my $x; my @y = 0, 0, 0; my $z; $x = @y[0] = @y[1] = @y[2] = $z = 5; say "$x [@y] $z"

[19:38] <p6eval> rakudo 894e79: OUTPUT«5 [@y] 5␤»

[19:38] <tylercurtis> my $x; my @y = 0, 0, 0; my $z; [=] $x, @y, $z, 5; say ($x, @y, $z).join(' ')

[19:38] <lue> be that an interpolation bug?

[19:39] *** takadonet left
[19:39] <tylercurtis> rakudo: my $x; my @y = 0, 0, 0; my $z; [=] $x, @y, $z, 5; say ($x, @y, $z).join(' ')

[19:39] <p6eval> rakudo 894e79: OUTPUT«Any() 0 0 0 Any()␤»

[19:40] <tylercurtis> rakudo: my $x; my @y = 0, 0, 0; my $z; $x = @y[0] = @y[1] = @y[2] = $z = 5; say "$x [@y[]] $z"

[19:40] <p6eval> rakudo 894e79: OUTPUT«5 [0 5 5] 5␤»

[19:40] <tylercurtis> lue: there you go.

[19:40] <lue> ah. wonder why [@y] didn't interpolate though.

[19:41] <moritz_> because arrays and hashes only interpolate when there are trailing postcircumfixes.

[19:41] <pmichaud> @-variables don't interpolate until suffixed with a postcircumfi.... right

[19:41] <pmichaud> that way we don't have to worry about [email@hidden.address]  suddenly trying to interpolate @yahoo or @yahoo.com

[19:41] *** Guest43164 left
[19:41] <lue> rakudo: my $x; my @y = 0, 0, 0; my $z; $x = @y[0] = @y[1] = @y[2] = $z = 5; say "$x [{@y}] $z"

[19:42] <p6eval> rakudo 894e79: OUTPUT«5 [0 5 5] 5␤»

[19:42] <lue> :D

[19:42] <pmichaud> yes, that's my preferred way of handling it :)

[19:42] * lue thinks of silly frenchman

[19:42] <lue> "And your father smelt of elderberries!"

[19:43] *** clintongormley left
[19:43] * tylercurtis -> recreational activities for a few hours.

[19:43] *** tylercurtis left
[19:43] <lue> what if your email is me@brac[]ket.com?

[19:44] <lue> rakudo: say "what if your email is me@brac[]ket.com?"

[19:44] <p6eval> rakudo 894e79: OUTPUT«===SORRY!===␤Symbol '@brac' not predeclared in <anonymous> (/tmp/mKSh2fK0Es:11)␤»

[19:44] <[Coke]> then use single quotes.

[19:45] <pmichaud> or backwhack the @

[19:45] <pmichaud> or get a real email address

[19:45] <lue> :)

[19:45] <Tene> [] in domains?

[19:45] <pmichaud> or live comfortably knowing that you aren't going to get caught up on some spam lists

[19:45] <[Coke]> tene: no doubt the third great expansion of TLDs will include arbitrary unicode.

[19:46] <[particle]> abc@def is a valid email address

[19:46] <lue> they already allow Chinese (approved just recently)

[19:46] <[particle]> so you could print [] directly afterward

[19:46] <[particle]> i mean, it'd be a valid thing to do generally, not in perl 6

[19:46] <lue> .oO(∫upermath.net)

[19:50] *** shade_ is now known as shade\

[19:54] *** rhr joined
[19:56] *** justatheory left
[19:57] <moritz_> http://moritz.faui2k3.org/tmp/waffle.jpg # part of my dinner tonight :-)

[19:58] *** Guest43164 joined
[20:00] <TimToady> phone

[20:00] <jnthn> moritz_: oooh, that looks tasty!

[20:01] <moritz_> jnthn: it was :-)

[20:01] <sorear> Tene: iirc the only illegal characters in domain names are NUL, NL, and TAB

[20:01] <sorear> (bind 1 used a tab-delimited data file!)

[20:01] <Trashlord> null

[20:02] <lue> aah! Spain got a goal *sob*

[20:02] <jnthn> lue: Yeah... :-/

[20:02] <Trashlord> so, is it 1 - 0 for spain?

[20:02] <moritz_> well deserved, even if I don't like it

[20:02] <jnthn> That won't get Germany any Klose to the final...

[20:02] <jnthn> <ducks>

[20:02] * lue is currently engrossed in the world cup. Sorry for the intermittent appearance.

[20:02] <Trashlord> er

[20:03] <Trashlord> I was hoping for a Netherlands - Germany final

[20:03] <Trashlord> and a German victory

[20:04] <ascent_> there will be Netherlands - Spain final, and Netherlands victory (yeah) :P

[20:05] <Trashlord> Germany played very well throughout the entire tournament, they deserve to win for their high quality and very entertaining football, imo

[20:06] <PerlJam> Trashlord: they deserve to win if they score more goals than spain  ;)

[20:06] *** Guest52181 left
[20:06] *** Guest52181 joined
[20:06] <Trashlord> or if they concede less ;p

[20:06] <cognominal> is this the #perl6 channel?  :)

[20:06] <moritz_> cognominal: not sure... :-)

[20:06] *** Guest52181 is now known as pragma_

[20:06] <Trashlord> it might be

[20:06] <jnthn> I've been surprised...I expected Germany to do better than this again Spain.

[20:06] <moritz_> seems like #europe right now

[20:07] <PerlJam> There's a reason it's called the "World Cup"

[20:07] *** unik joined
[20:08] *** eternaleye joined
[20:09] *** macdaddy joined
[20:09] *** macdaddy is now known as Guest5559

[20:13] <unik> p6eval rakudo: multi sub fib(Int $x where 0) { 0 }; multi sub fib(Int $x where 1) { 1 }; multi sub fib(Int $x where { $x > 1 }) { fib($x - 2) + fib($x - 1) }; my $val = 0 .. 10; $val.map: fib;

[20:13] <p6eval> unik: rakudo 894e79: OUTPUT«No applicable candidates found to dispatch to for 'fib'. Available candidates are:␤:(Int $x where ({ ... }))␤:(Int $x where ({ ... }))␤:(Int $x where ({ ... }))␤␤  in main program body at line 11:/tmp/Q0DlIQx48j␤»

[20:13] *** lest_away is now known as lestrrat

[20:14] <unik> p6eval rakudo: multi sub fib(Int $x where 0) { 0 }; multi sub fib(Int $x where 1) { 1 }; multi sub fib(Int $x) { fib($x - 2) + fib($x - 1) }; my $val = 0 .. 10; $val.map: fib;

[20:14] <p6eval> unik: rakudo 894e79: OUTPUT«No applicable candidates found to dispatch to for 'fib'. Available candidates are:␤:(Int $x where ({ ... }))␤:(Int $x where ({ ... }))␤:(Int $x)␤␤  in main program body at line 11:/tmp/8oMXUeNYKx␤»

[20:15] *** eternaleye left
[20:18] * PerlJam wonders if you can use a proto to define a default to OUTER::<$_> once

[20:18] <moritz_> unik: try $val.map: &fib

[20:18] <moritz_> unik: otherwise fib() is called first, and the result is passed to map()

[20:19] *** tadzik joined
[20:19] <moritz_> rakudo: multi sub fib(Int $x where 0) { 0 }; multi sub fib(Int $x where 1) { 1 }; multi sub fib(Int $x) { fib($x - 2) + fib($x - 1) }; my $val = 0 .. 10; $val.map: &fib

[20:19] <p6eval> rakudo 894e79:  ( no output )

[20:19] <moritz_> rakudo: multi sub fib(Int $x where 0) { 0 }; multi sub fib(Int $x where 1) { 1 }; multi sub fib(Int $x) { fib($x - 2) + fib($x - 1) }; my $val = 0 .. 10; say $val.map: &fib

[20:19] <p6eval> rakudo 894e79:  ( no output )

[20:19] <moritz_> uhm.

[20:21] <jnthn> oddness.

[20:21] *** Ross left
[20:22] *** Ross joined
[20:22] <jnthn> rakudo: multi fib(0) { 0 }; multi fib(1) { 1 }; multi fib($x) { fib($x - 2) + fib($x - 1) }; say fib(0); say fib(1); say fib(2);

[20:22] <p6eval> rakudo 894e79: OUTPUT«0␤1␤1␤»

[20:23] <jnthn> rakudo: multi fib(0) { 0 }; multi fib(1) { 1 }; multi fib($x) { fib($x - 2) + fib($x - 1) }; my $r = 0 .. 10; say $r.map(&fib);

[20:23] <p6eval> rakudo 894e79:  ( no output )

[20:23] <jnthn> rakudo: multi fib(0) { 0 }; multi fib(1) { 1 }; multi fib($x) { fib($x - 2) + fib($x - 1) }; say (0..10).map(&fib);

[20:23] <p6eval> rakudo 894e79:  ( no output )

[20:23] <jnthn> rakudo: multi fib(0) { 0 }; multi fib(1) { 1 }; multi fib($x) { fib($x - 2) + fib($x - 1) }; say (0..10).map(&fib).eager;

[20:23] <moritz_> WTBH?

[20:23] <p6eval> rakudo 894e79: OUTPUT«Method 'count' not found for invocant of class 'Perl6MultiSub'␤  in main program body at line 1␤»

[20:23] <jnthn> wtf

[20:23] <jnthn> oh

[20:23] <unik> p6eval rakudo: my $a = 0 .. 10; $a.map: { say $^a }

[20:23] <moritz_> but shouldn't say() be eager?

[20:24] <jnthn> map + multi = boom?

[20:24] <p6eval> unik: rakudo 894e79:  ( no output )

[20:24] <jnthn> moritz_: I thought that too

[20:24] <jnthn> moritz_: Was just trying to tease out what's really wrong.

[20:24] <moritz_> map + multi == boom, right

[20:24] <jnthn> Looks like map wants to .count 

[20:25] <jnthn> hugme: hug lue_sad 

[20:25] * hugme hugs lue_sad

[20:25] <unik> also, is it ok now that fib(N) where N is slightly above 19 eats loads of RAM and never seems to exit?

[20:27] <unik> i just couldn't wait long enough for it to exit, fearing OOM killer will bork my workstation

[20:27] <moritz_> unik: yes, the recursive implementation tries to run 2**19 sub invocations

[20:27] <moritz_> rakudo: say (0, 1, *+* ... *)[19]

[20:27] <p6eval> rakudo 894e79: OUTPUT«4181␤»

[20:27] <moritz_> that's an iterative, more elegant version that doesn't blow all up

[20:27] <unik> nice

[20:27] <moritz_> rakudo: say ~(0, 1, *+* ... *)[^10]

[20:28] <p6eval> rakudo 894e79: OUTPUT«0 1 1 2 3 5 8 13 21 34␤»

[20:28] <moritz_> unlike haskell, Perl 6 can't easily do purity analysis and cache pure functions

[20:28] <unik> it's stringified slice of a lazy list?

[20:28] *** saaki left
[20:31] <moritz_> yes

[20:32] *** justatheory joined
[20:33] *** saaki joined
[20:34] <unik> p6eval rakudo: my $a = 0 .. 10; ~$a.map: { say $^a }

[20:34] <p6eval> unik: rakudo 894e79: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[20:36] <TimToady> jnthn: that .count should become simpler when &fib is a proto wrapper

[20:36] <jnthn> TimToady: Yeah

[20:37] <TimToady> also thinking that perhaps we allow the form: proto foo ($sig);

[20:37] <TimToady> where semicolon form means "write the body for me"

[20:37] <jnthn> TimToady: I guess .signature is the signature of the proto too?

[20:37] <jnthn> Eww

[20:37] *** aindilis joined
[20:37] <jnthn> I'd rather not do that unless we allow it as a general shorthand for { ... }

[20:37] <moritz_> I like that better than a magical empty function body

[20:38] <TimToady> or maybe {*}

[20:38] <jnthn> Would proto foo($sig) { ... } be an auto-written proto?

[20:38] <jnthn> Or a stub?

[20:38] <pmichaud> we can do count on multis -- just haven't implemented it yet.

[20:38] <TimToady> I think it's best not to confuse stubs with auto-writes

[20:38] <pmichaud> at least good enough to get past map.  :-)

[20:39] <pmichaud> (and map shouldn't be using .count anyway.)

[20:39] <jnthn> TimToady: Then probably <...> in regexes also wants to change.

[20:39] <pmichaud> (it's a cheat for now)

[20:39] <TimToady> yes, map should be using partial binding

[20:39] <moritz_> which isn't specced yet, right?

[20:39] <TimToady> jnthn: I was going to change <...> anyway

[20:39] *** rhr left
[20:40] <TimToady> since {...} means the same, though now maybe we'll get {*} back to mean call the multies

[20:40] <jnthn> proto foo($sig) { * }

[20:40] <jnthn> or

[20:40] *** masak joined
[20:40] <jnthn> proto foo($sig) { {*} }

[20:40] <jnthn> ?

[20:40] <masak> ahoy!

[20:40] <jnthn> lolitsmasak!

[20:41] * moritz_ stares at a round tuit

[20:41] <masak> moritz_: thanks for the link to the Knuth talk. I'd been wanting to see that talk.

[20:41] <TimToady> just {*} in proto sub, { {*} } in proto regex

[20:41] <TimToady> though I suppose we could allow the special form on regexen too

[20:41] <TimToady> since * can't stand alone in a regex

[20:41] <moritz_> masak: you're welcome.

[20:43] <TimToady> we might want to distinguish {*} from nextsame/callsame anyway

[20:43] <masak> TimToady: can we make the spec change `slurp($filename)` -> `slurp($filename.IO)` now? I think it's a good idea, and would like to see it go into Rakudo before Star.

[20:43] <masak> ditto `$filename.IO ~~ :e`, actually.

[20:43] <TimToady> if we always start the multi dispatch with {*}, then nextsame can always refer to the outer

[20:43] <TimToady> without playing lastcall tricks

[20:45] *** spinclad_ is now known as spinclad

[20:45] <lue> hai masak o/

[20:45] <masak> woo, the StackOverflow question that moritz_++ linked to (and answered) previously makes me happy. # http://stackoverflow.com/questions/3196539/how-to-create-methods-from-arrays-or-hashes-in-perl6/3197558

[20:45] <masak> lue: \o

[20:45] <jnthn> TimToady: So it's up to the proto if we then go deferring inheritance wise?

[20:45] <TimToady> hmm, not sure about slurp, since slurp($string) would then be a no-op; was more concerned about the difference between "splitters" like words and lines

[20:46] <masak> one, because it's a rather advanced question. two, because it's fixed in Rakudo already :)

[20:46] <PerlJam> moritz, masak: what knuth talk?

[20:46] <masak> PerlJam: grep today's logs for "Knuth".

[20:46] <TimToady> yes, assuming that {*} can also be used internally as well as the whole body, you could redispatch with proto fib ($x) { {*}; nextsame }

[20:47] *** patspam joined
[20:47] <moritz_> PerlJam: announcing the successor of TeX

[20:47] <jnthn> slurp imo loses its usefulness if it can't just be given a filename

[20:47] <masak> PerlJam: in it, he's revealing his new application, iTex <pingeling>

[20:47] <jnthn> I see it more like open

[20:47] <TimToady> well open-close

[20:47] <jnthn> TimToady: Could work

[20:48] <jnthn> TimToady: close doesn't take a file name :-P

[20:48] <jnthn> TimToady: But yes :-)

[20:48] <jnthn> TimToady: Are we going to parse {*} as a magical term?

[20:48] <masak> what was the ultimate rationale for changing it? making words() and lines() more alike, no?

[20:49] <TimToady> yes, but slurp isn't one of those

[20:49] <lue> .oO(work on NES emulator, or tackle the foreign code import mechanism...)

[20:49] <TimToady> so Str.words and Str.lines always just split the string, and you have to use IO.words or IO.lines to read; however...

[20:50] <TimToady> words() and lines() can still default to $*ARGFILES input

[20:50] * lue goes for foreign code.

[20:50] <moritz_> +1

[20:50] <moritz_> (to TimToady)

[20:51] <masak> this Backglass fellow who entered earlier has been chatting me up three times. I watched his script evolve gradually. I never gave him any specific tips, just pointed to CPAN modules that seemed appropriate. he grew increasingly insistent.

[20:51] <TimToady> alternately, we have a default IO that you always say IO.lines or IO.words

[20:51] <TimToady> where "IO" is negotiable

[20:51] <masak> I should probably be more brusque from the start.

[20:51] <masak> TimToady: I like just words() and lines()

[20:52] <TimToady> I don't

[20:52] <jnthn> masak: I love that in the dictionary one definition of that word is "ungracious harshness" :-)

[20:52] <TimToady> because the () is required in a for loop

[20:52] <masak> TimToady: will it still gobble the block if I forget the parens?

[20:52] <moritz_> std: for lines { }

[20:52] <p6eval> std 31567: OUTPUT«===SORRY!===␤Function 'lines' needs parens to avoid gobbling block at /tmp/_LG5S8EOdK line 1:␤------> for lines⏏ { }␤Missing block (apparently gobbled by 'lines') at /tmp/_LG5S8EOdK line 1:␤------> for lines { }⏏<EOL>␤   

[20:52] <p6eval> ..expe…

[20:52] <masak> jnthn: oh, did I do the word thing again? sorry :P

[20:52] <jnthn> :P

[20:52] <TimToady> druther have something like: for slurp.lines {...}

[20:53] <masak> jnthn: I should be less circumspect in my explications.

[20:53] <jnthn> Not unless you want to the whole file

[20:53] * masak .oO(I accidentally the whole file )

[20:53] <masak> TimToady: slurp.lines looks non-lazy to me, like jnthn said.

[20:54] <diakopter> or more perspicuous

[20:54] <TimToady> which is why I mentioned: for cat.lines {...}

[20:54] <TimToady> the other day

[20:54] <moritz_> please don't make IO rely on lazy strings

[20:54] <jnthn> What moritz_ said.

[20:55] <moritz_> it took us so long to get proper lazy lists and arrays

[20:55] <TimToady> yes, well, what we really need is something short that means the IO of $*ARGFILES

[20:55] <moritz_> I don't want to wait another few years to do proper IO

[20:55] <diakopter> but.. in theory, they're optimizable......

[20:55] <masak> TimToady: we don't have a cat, so that's not an option Right Now(TM).

[20:55] <[particle]> .oO(something like the fish operator)

[20:55] <TimToady> we want mumble.lines where mumble is something short for $*ARGFILES.IO

[20:56] <masak> input.lines

[20:56] <lue> .oO($*AFIO ?)

[20:56] <moritz_> +1 to a term-like input

[20:56] *** rhr joined
[20:57] <diakopter> I like mumble

[20:57] <TimToady> "IN" maybe

[20:57] <TimToady> hmm, too much like $*IN

[20:57] <masak> too similar to $*IN

[20:57] <masak> TimToady: what TimToady said.

[20:58] <TimToady> I am beside myself.

[20:58] <masak> why am I suddenly seeing double?

[20:58] <TimToady> ohoh

[20:58] * diakopter does a double gather

[20:58] <pmurias> sorear: so we want viv to prepend Perl6:: to package names when translating p6 to p5?

[20:58] <lue> (That's *my* TARDIS, TimToady)

[20:58] <masak> I thought we fixed the cloning bug! :)

[21:00] <lue> Looks like my biggest hurdle to foreign code is the spec. S21 makes it apparent :)

[21:00] <masak> std: class A { method foo { $!b } }

[21:00] <p6eval> std 31567: OUTPUT«ok 00:01 108m␤»

[21:01] <masak> theoretically, one could detect direct references to nonexistent attributes, right?

[21:01] <TimToady> nodnod

[21:01] <masak> just checking.

[21:01] *** diakopter sets mode: +v masak

[21:01] <masak> for example, they're always wrong in a disconnected method.

[21:02] <diakopter> hugme: hug masakbot

[21:02] * hugme hugs masakbot

[21:02] * masak purrs

[21:02] <jnthn> masak: We will :-)

[21:02] <moritz_> rakudo: class Foo { method x { $!b } }

[21:02] <p6eval> rakudo 894e79:  ( no output )

[21:02] <masak> jnthn: when?

[21:03] <jnthn> masak: Probably after R* as part of object guts chnages.

[21:03] <moritz_> jnthn: speaking of attributes... is there any (hacky) way to set a parent attribute?

[21:03] *** DarkWolf84 joined
[21:03] <jnthn> moritz_: Eww

[21:03] <jnthn> moritz_: From PIR?

[21:03] <masak> DarkWolf84! \o/

[21:03] <moritz_> jnthn: Perl 6 or PIR

[21:03] <DarkWolf84> hello

[21:03] <DarkWolf84> hi masak 

[21:04] <pmichaud> if there's not a name collection,   $!attribute works just fine.

[21:04] <jnthn> setattribute obj, ['Parent';'Name'], '$!attr', value

[21:04] <pmichaud> *collision

[21:04] <masak> DarkWolf84: welcome back to the party! \o/

[21:04] <moritz_> jnthn: I want to write a Match.new... but the actual attribute is stored in Regex::Match

[21:04] <moritz_> ah, thanks

[21:04] <pugssvn> r31568 | kyle++ | Delete empty directories. 

[21:05] <DarkWolf84> I have a little question

[21:05] <DarkWolf84> how to delete a var

[21:05] <masak> DarkWolf84: how do you mean?

[21:05] <masak> like, set it to its initial state?

[21:05] <moritz_> undefine($x)

[21:05] <DarkWolf84> undefine just makes $foo to be Any

[21:06] <masak> $var = Nil; works too

[21:06] <moritz_> it's a bit wrong right now

[21:06] <DarkWolf84> but $var exists

[21:06] <PerlJam> DarkWolf84: you mean you want to eradicate the var from whatever symbol table it happens to live in?

[21:06] <DarkWolf84> yeah

[21:06] <moritz_> no way

[21:06] <masak> rakudo: my @a = 1, 2, 3, 4, 0; @a .= [@a]; say @a.perl

[21:06] <p6eval> rakudo 894e79: OUTPUT«Method '!postcircumfix:<[ ]>' not found for invocant of class 'Array'␤  in main program body at line 11:/tmp/lVjyAC6JuO␤»

[21:07] <moritz_> existance of variables is a compile-time property

[21:07] <masak> p6eval: what? :)

[21:07] * masak submits rakudobug

[21:07] <masak> rakudo: my @a = 1, 2, 3, 4, 0; @a = @a[@a]; say @a.perl

[21:07] <pmichaud> I hate to mention this (and I know it goes against tradition), but part of me now thinks that "slurp()" ought to do what lines() currently does.

[21:07] <p6eval> rakudo 894e79: OUTPUT«[2, 3, 4, 0, 1]␤»

[21:07] <pmichaud> i.e., it should return a list of elements, and we have something else that means "give us the string"

[21:07] <DarkWolf84> will a $var wich is Any be GC

[21:07] <pmichaud> rationale:  slurpy arrays and slurpy hashes are lists of elements

[21:07] <DarkWolf84> sorry for the bad english

[21:07] <masak> DarkWolf84: no, it won't.

[21:08] <moritz_> setattribute self ['Regex';'Match'], '$!from', from

[21:08] <DarkWolf84> too bad

[21:08] <moritz_> The opcode 'setattribute_p_kc_sc_p' (setattribute<4>) was not found. Check the type and number of the arguments

[21:08] <masak> DarkWolf84: easiest way to make a var go out of scope, is to end the scope :)

[21:08] <moritz_> oh, forgot a comma

[21:08] <DarkWolf84> yeah the local vars help

[21:08] <masak> rakudo: my @a = 1, 2; @a.=[1]; say @a.perl

[21:08] <p6eval> rakudo 894e79: OUTPUT«===SORRY!===␤Can not use .= on a non-identifier method call at line 11, near "; say @a.p"␤»

[21:09] <jnthn> If you have some large data structure in a $var and you undefine it, what it used to hold will be GC'd.

[21:09] <pmichaud> moritz_: won't .new initialize the attribute anyway without having to do something special?

[21:09] *** pmurias left
[21:09] <masak> I like this error message better.

[21:09] <DarkWolf84> that means now REPL will memory leack over time

[21:09] <masak> right. the difference between variables and values.

[21:09] * pmichaud wonders about "REPL will memory leak..."

[21:10] <masak> DarkWolf84: not any worse than the corresponding program would.

[21:10] *** tylercurtis joined
[21:10] <moritz_> pmichaud: it does not

[21:10] <moritz_> rakudo: say Match.new(from => 1, to => 5).perl

[21:10] <p6eval> rakudo 894e79: OUTPUT«Match.new(␤ # WARNING: this is not working perl code␤ # and for debugging purposes only␤ from => Any(),␤ orig => Any,␤ to   => Any(),␤)␤»

[21:10] <pmichaud> moritz_: hmm, that seems odd.

[21:11] <DarkWolf84> I think there should be some way to GC the defined objects/vars

[21:11] <pmichaud> DarkWolf84: undefine() will do that.

[21:11] <tylercurtis> Hi.

[21:11] <moritz_> rakudo: class Parent { has $.bla }; class Child is Parent { }; say Child.new(bla => 5).bla

[21:11] <p6eval> rakudo 894e79: OUTPUT«5␤»

[21:11] <pmichaud> moritz_: I'm a little surprised by that.

[21:11] <jnthn> I think that's spec.

[21:11] <moritz_> pmichaud: maybe it's because Regex::Match is a foreign object?

[21:11] <pmichaud> I mean I'm surprised that it doesn't work for Regex::Match

[21:12] <jnthn> oh

[21:12] <lue> rakudo: my $a; my $a = Mu; say $a

[21:12] <pmichaud> Regex::Match isn't all that foreign, though.

[21:12] <p6eval> rakudo 894e79: OUTPUT«===SORRY!===␤Redeclaration of symbol $a at line 11, near " = Mu; say"␤»

[21:12] <jnthn> pmichaud: Yeah, see your point.

[21:12] <lue> rakudo: my $a; $a = Mu; say $a

[21:12] <p6eval> rakudo 894e79: OUTPUT«Mu()␤»

[21:12] * jnthn is also a bit surprised.

[21:12] <pmichaud> I mean, IIRC the default BUILD just walks through the objects attributes and does initializations. 

[21:12] <pmichaud> a-ha

[21:12] <pmichaud> maybe the problem is that Regex::Match needs a BUILD

[21:12] <masak> rakudo: multi fib(0) { 0 }; multi fib(1) { 1 }; multi fib($x) { fib($x - 2) + fib($x - 1) }; say (0..10).map(&fib).eager; # did anyone submit this to RT?

[21:12] <p6eval> rakudo 894e79: OUTPUT«Method 'count' not found for invocant of class 'Perl6MultiSub'␤  in main program body at line 1␤»

[21:13] <jnthn> pmichaud: oh, that makes sense.

[21:13] <moritz_> rakudo: say Regex::Match.new(from => 3).from

[21:13] <p6eval> rakudo 894e79: OUTPUT«Null PMC access in type()␤  in main program body at line 11:/tmp/Rtki_Mk9Tc␤»

[21:13] * masak submits rakudobug

[21:13] <masak> (the Null PMC access one)

[21:13] <moritz_> masak: don't. Regex::Match isn't spec

[21:13] <masak> oh, right.

[21:13] * moritz_ retires

[21:13] <masak> but shouldn't we eradi... oh, forget it.

[21:14] <pmichaud> we should be able to get Regex::Match to disappear at some point, yes.

[21:14] <masak> I meant the Null PMC access.

[21:14] <masak> submitting tickets on those are reflex nowadays.

[21:14] <masak> and I'm not sure "this class is not spec" is a justified excuse not to.

[21:15] <pmichaud> well, if Regex::Match goes away, you won't be able to .new to get the NPA in the first place.  :-)

[21:15] <masak> I realize that. just like every other *bug* *fix*. :P

[21:16] <masak> is there a "Regex::Match should go away" ticket in RT?

[21:16] <pmichaud> no.  But if you want to start filing those, I can give you a long list.

[21:16] <masak> huh.

[21:17] <pmichaud> there's quite a bit that's "visible" currently that perhaps ought not to be, or that isn't really part of the spec.

[21:17] <pmichaud> like many of our "helper subs"

[21:17] <masak> nod

[21:17] <DarkWolf84> rakudo {my $a = 42;  $a.say;}; $a.say

[21:17] <DarkWolf84> oops

[21:17] <DarkWolf84> rakudo: {my $a = 42;  $a.say;}; $a.say

[21:17] <p6eval> rakudo 894e79: OUTPUT«===SORRY!===␤Symbol '$a' not predeclared in <anonymous> (/tmp/iFdccWkSCe:11)␤»

[21:17] <DarkWolf84> yes

[21:18] <DarkWolf84> rakudo: my $a = 42; $a = Nil; $a.say;

[21:18] <p6eval> rakudo 894e79: OUTPUT«Any()␤»

[21:19] <DarkWolf84> that's what I mean

[21:19] <DarkWolf84> $a will not be GC-ed

[21:19] <TimToady> if "io" is the ingy-esque lazy IO thingy, then it's just: for io.lines {...}

[21:20] <masak> DarkWolf84: *variables* aren't GC-ed. *objects* are.

[21:20] *** wp6ft joined
[21:21] <lue> DarkWolf84: If I may ask, why do want to delete a variable?

[21:21] <masak> TimToady: it feelsn't like a straight line between $*ARGFILES.IO and that.

[21:22] <lue> (do *you* want)

[21:22] *** wp6ft left
[21:22] <DarkWolf84> masak: but aren't they leacking the memmory that way

[21:22] *** shade\ left
[21:22] <DarkWolf84> s/memmory/memory/

[21:23] <DarkWolf84> Any is an object isn't it?

[21:23] <masak> DarkWolf84: ok, so "leaking memory" usually refers to allocating something and then never de-allocating it. just making sure we're agreed on that.

[21:24] <DarkWolf84> yeah the C pointers are that way

[21:24] <masak> DarkWolf84: Any is an object. one which has plenty of live references to it in a Perl 6 program :)

[21:24] <masak> for example, many routines in the setting have Any as a parameter type.

[21:25] <masak> especially as it's the default type for parameters.

[21:25] <cognominal> I don't find Knuth funny, he seems embiterred by all the new technology and marketting.  Like if everything new was bad. Sounds similar to some perl5 crowd taking cheap shots at Perl 6.

[21:25] <masak> cognominal: I didn't find it bitter. but he does put it in some well-needed perspective.

[21:26] *** tadzik left
[21:26] <PerlJam> I didn't get "bitter" from Knuth either.

[21:27] <DarkWolf84> masak, I think I've got the idea

[21:27] *** Guest43164 left
[21:28] <DarkWolf84> $foo just points the Any() object when it's undefined

[21:28] <masak> actually, I couldn't decide if an iTex living up to the spec in the presentation would be the Last Application Ever (and as such, fully desirable), or just Modern Tech Buzzword Overload. I kept flip-flopping between the two.

[21:28] <Tene> I still don't follow what's happened with Knuth.  Did he actually release something new, or not?  I've seen a couple of links to a video, but I haven't had time to sit down and watch a video yet.

[21:28] <cognominal> Except at the language level (objC sigh), I find the iStuff good. I  wish free software facing end users to be half as good.

[21:28] <masak> Tene: there won't be any doubts after you watch the video :)

[21:29] <Tene> :)

[21:32] *** unik left
[21:33] *** Ross left
[21:37] <spinclad> .u CHI

[21:37] <phenny> U+2627 CHI RHO (☧)

[21:37] <masak> as in "CHI RHO practor".

[21:37] <spinclad> i thought the saddest thing (well, going to the opposite of FLOSS aside) was his caving on how to pronounce '\c[GREEK UPPERCASE CHI]'

[21:38] <masak> spinclad: he failed to pronounce it 'x' a number of times after that himself :P

[21:38] <lue> when I first read of iTex, I had to sit there for a moment.

[21:38] <spinclad> but he seemed to keep forgetting to go with the vulgus mobile

[21:39] *** silug left
[21:39] <cognominal> masak++  # a good pun is a bad one.

[21:39] <lue> I haven't seen the videos (and can't), but iTex sounds like a joke (based on a short description, of course)

[21:39] <masak> cognominal: wasn't aware I made one. but thanks.

[21:40] <masak> lue: you should also see the vid, to be completely sure.

[21:40] <spinclad> CH R istian science: CHI RHO praxis

[21:40] <masak> pmichaud: did that IO::Prompter module ever make it online?

[21:41] <lue> if only I could... even if isn't flash, my poor old laptop can't handle good video.

[21:41] <lue> [ would you like to make a donation? :) ]

[21:41] <masak> I can give you a hug.

[21:41] <masak> hugme: hug lue 

[21:41] * hugme hugs lue and blushes

[21:42] <lue> (I'm not a fan of Flash anyway)

[21:46] *** alester joined
[21:46] *** rhr left
[21:46] *** ash_ left
[21:46] *** LionMadeOfLions left
[21:46] *** athomason left
[21:47] *** shade_ joined
[21:49] *** ruoso left
[21:49] *** rhr joined
[21:49] *** ash_ joined
[21:49] *** LionMadeOfLions joined
[21:49] *** athomason joined
[21:53] *** rhr left
[21:53] *** ash_ left
[21:53] *** LionMadeOfLions left
[21:53] *** athomason left
[21:56] <spinclad> masak: re http://gist.github.com/464349, a sweet improvement.  One note: "This will need to fall back to hash access [on] indirect lookup ($::'$a')":  (more)

[21:59] * masak waits, hopefully, for more

[21:59] <spinclad> seems to me this involves a static hash from strings ('$a') to accessors ($access = {[0, 0]}) and a way to apply them (fetch $access; store $access, $2)

[21:59] *** rhr joined
[21:59] *** ash_ joined
[21:59] *** athomason joined
[22:00] <spinclad> and the static hash goes in the static lexpad

[22:00] <masak> hm.

[22:01] <masak> that seems right.

[22:01] <spinclad> (i don't expect this literal use of $access; i expect it would have to get compiled into a few operations each)

[22:01] <masak> I will remember that for when we do indirect lookup.

[22:05] <slavik> what is yapsi?

[22:05] *** skangas left
[22:07] <masak> slavik: it's a compiler/runtime I'm writing on my spare time, along with a bunch of other people -- notably snarkyboojum++ and isBEKaml++.

[22:08] <spinclad> yapsi is Perl 6's first 'complete', 'official' implementation  (see masak's release announcements: http://use.perl.org/~masak/journal/40429)

[22:08] <masak> oh yeah, that too. :P

[22:09] <masak> in the long run, Yapsi's PR staff is so screwed. :)

[22:09] <tylercurtis> masak: Aren't you Yapsi's PR staff?

[22:09] *** skangas joined
[22:09] <masak> tylercurtis: d'oh!

[22:10] <DarkWolf84> that's a secret

[22:10] <DarkWolf84> :)

[22:11] <masak> speaking of which -- download Yapsi today! http://github.com/masak/yapsi/downloads

[22:11] <masak> you know you want to. :>

[22:12] <masak> hm, I just noticed that the tags have 'tgz'/'zip' links. do I really need the download files too?

[22:13] <masak> I guess they form a way to post-process the git repo a bit...

[22:13] <pugssvn> r31569 | lwall++ | [IO,Str] regularize .lines to be more like .words when fed a string 

[22:13] <pugssvn> r31569 | .lines will no longer interpret a string as a filename

[22:14] <masak> TimToady++

[22:15] <masak> TimToady: why not just 'is export' on the method form?

[22:15] <TimToady> er, copy/past from words?

[22:16] <masak> same question for words, then :P

[22:16] <TimToady> feel free, I'm geezernapping &

[22:17] * masak makes a guerilla edit

[22:17] <tylercurtis> rakudo: (1,2,3 Z, 4, 5, 6)[0].perl.say

[22:17] <p6eval> rakudo 894e79: OUTPUT«(1, 4)␤»

[22:18] <tylercurtis> rakudo: (1,2, 3 Z 4,5,6)[0].perl.say

[22:18] <p6eval> rakudo 894e79: OUTPUT«1␤»

[22:18] *** kensanata joined
[22:18] <tylercurtis> According to S03, Z is a shortcut for Z,.

[22:19] *** hercynium joined
[22:19] <pugssvn> r31570 | masak++ | [S32/Str] saved a few words and lines with "is export" 

[22:19] <masak> tylercurtis: that looks familiar. but feel free to submit to RT anyway.

[22:20] <masak> tylercurtis: ah, here: http://rt.perl.org/rt3/Ticket/Display.html?id=73948

[22:22] <tylercurtis> masak: Your RT-fu is impressive.

[22:22] <masak> :) "Z," was unusually easy to search for.

[22:22] <masak> the RT search thingie is idiosyncratic, but in predictable ways.

[22:23] <masak> in particular, it has no metacharacters and doesn't care for word boundaries.

[22:24] *** ash_ left
[22:27] *** rhr left
[22:27] *** rhr joined
[22:28] <tylercurtis> rakudo: my @foo; push(@foo, 1, 2, 3); @foo.perl.say

[22:28] <p6eval> rakudo 894e79: OUTPUT«[1, 2, 3]␤»

[22:28] <tylercurtis> rakudo: my @foo; @foo ,= 1, 2, 3; @foo.perl.say

[22:28] <p6eval> rakudo 894e79: OUTPUT«[1]␤»

[22:28] <tylercurtis> S03: "@foo ,= 1,2,3       # same as push(@foo,1,2,3)"

[22:29] <masak> well spotted.

[22:29] * masak submits rakudobug

[22:29] <masak> tylercurtis++

[22:31] *** justatheory left
[22:34] <tylercurtis> rakudo: (1,2,3 Z, 4,5,6) >>+<< (7,8,9 Z, 10,11,12)

[22:34] <p6eval> rakudo 894e79: OUTPUT«Sorry, sides are of uneven length and not dwimmy.␤  in 'hyper' at line 179:CORE.setting␤  in main program body at line 1␤»

[22:34] <tylercurtis> rakudo: say (1,2,3 Z, 4,5,6).elems

[22:34] <p6eval> rakudo 894e79: OUTPUT«3␤»

[22:35] <tylercurtis> rakudo: say (7,8,9 Z, 10,11,12).elems

[22:35] <p6eval> rakudo 894e79: OUTPUT«3␤»

[22:37] *** athomaso1 joined
[22:38] *** athomason left
[22:43] <masak> TimToady: `Int $limit = *` typefails in Rakudo. was that a thinko, or is there something Rakudo should know about Int and Whatever?

[22:44] <masak> TimToady: giving it a bit of thought, I think this is a case where $limit shouldn't be typed Int. as usual in these cases, it's more a question of a coercion than a typing.

[22:45] <jnthn> It should fail

[22:45] <jnthn> And I'd not type it

[22:45] <jnthn> Also don't "as Int" it unless you want *.Int to happen though ;-)

[22:46] <jnthn> *too

[22:46] <masak> o.O

[22:46] *** skangas left
[22:46] <masak> I don't :/

[22:46] <jnthn> Then don't "as Int" it :-)

[22:47] <jnthn> Default values are subject to type checking and type coercion. :-)

[22:47] <masak> I've just written a small patch that effectuates TimToady's spec change. spectesting.

[22:47] <pmichaud> I need to read that diff.

[22:47] <masak> I didn't "as Int" it. :)

[22:47] <pmichaud> (the spec change diff, not the patch diff)

[22:47] <masak> :)

[22:48] <pmichaud> yes.  I think that one of the things that Perl 6 programmers will quickly re-discover is that strong typing can be very limiting.

[22:48] <Tene> masak: so wait, did you "as Int" it, then?  'cos if you do that, .Int will happen.

[22:48] <masak> there's definitely a way to overuse typing in Perl 6.

[22:49] <masak> <masak> I didn't "as Int" it. :)

[22:49] <masak> Tene: no.

[22:50] <masak> in the end I used no coercion, and no typing, and I let the default be '*'.

[22:50] *** _mpu left
[22:50] <masak> the method I wrote delegates to Str.comb anyway, which likely does something sensible with $limit.

[22:50] * masak checks

[22:51] <masak> er, Cool.comb

[22:52] <masak> heh, Cool.comb also doesn't type/coerce its $limit param, and it seems to DTRT no matter what it gets.

[22:52] *** skangas joined
[22:52] <Tene> masak: did you try passing it a null pmc?

[22:52] *** cdarroch left
[22:53] * pmichaud seriously considers trapping "Null PMC" exceptions and changing them to some colorful phrase instead

[22:53] <pmichaud> no, wait

[22:53] <pmichaud> even better

[22:53] <pmichaud> Null PMC exceptions should simply provide the url or script whereby masak++ can automatically post it to RT

[22:54] <masak> :)

[22:54] <pmichaud> so,  Str.lines  breaks a string into lines, similar to what IO.lines does?

[22:54] <Tene> base64encode the stack trace, and print a url that will submit it to RT when clicked, of course.

[22:54] <pmichaud> Tene: ...if only RT accepted submissions via the web....

[22:55] <masak> what's the pir:: for getting a Null PMC again?

[22:55] <pmichaud> so, it prints a url that goes to a bug proxy that converts it into an email and submits it to RT

[22:55] <frettled> pmichaud: couldn't Null PMC exceptions automagically post to RT?  :D

[22:55] <pmichaud> masak: pir::null__P()

[22:55] <Tene> It wouldn't be outside the realm of possibility to set up some kind of submission service on feather.

[22:55] <pmichaud> frettled: that would just be evil.

[22:55] <frettled> oh, befuddled lag 

[22:55] <frettled> pmichaud: yes!

[22:55] <masak> rakudo: say "foo".comb(/o/, pir::null__P())

[22:55] <p6eval> rakudo 894e79: OUTPUT«Null PMC access in can()␤  in main program body at line 1:/tmp/QJCtpureJq␤»

[22:55] <Tene> frettled: it's impolite to make internet connections without permission.

[22:56] <pmichaud> and the submission server could also check to see if this particular Null PMC exception has been reported and not re-post it

[22:56] <masak> Tene: seems it never reaches the .comb method.

[22:56] <frettled> pmichaud: mmm

[22:56] <frettled> Tene: what if rakudo has a letter from its parents saying that it's okay?

[22:57] <pmichaud> the rakudo will have been a naughty girl.

[22:57] <pmichaud> *then

[22:58] <masak> is it wrong to find the spectests that need changing by changing the code and seeing what breaks? :)

[22:58] <jnthn> masak: We could call it...Implementation Driven Development!

[22:58] <jnthn> It's like TDD in the mirror.

[22:58] <masak> 哈哈

[22:59] <masak> DDT?

[22:59] <masak> Development-Driven Development.

[23:00] <lue> .oO(Should Be Fine™ development)

[23:00] <frettled> lue++

[23:00] <masak> Drive-By Development.

[23:01] <jnthn> I Accidentally Development

[23:01] <frettled> Development By Proxy

[23:01] <lue> If it works great for us, it's a test. If it doesn't, it shouldn't be there :)

[23:02] <lue> (IIWGFUIATIIDISBT)

[23:02] <masak> jnthn: :D

[23:02] <tylercurtis> Acronym-Driven Development

[23:02] <tylercurtis> or.. ADD

[23:03] <masak> Driven-Insane Development.

[23:03] <lue> Why yes I DID

[23:04] *** lestrrat is now known as lest_away

[23:04] <masak> Didn't-I-fix-this-yesterday-Driven Development

[23:04] <lue> aka Parodoxically-Driven Development

[23:05] <frettled> Déjà-vu Development

[23:05] <jnthn> masak: I think that's could "You-shoulda-used-TDD" ;-)

[23:05] <jnthn> *called

[23:05] <masak> :)

[23:05] <lue> .oO(Let's-Steal-From-The-Future-We-Did-Will-Do-It-Already Development)

[23:06] <frettled> Bikeshed-Driven Development

[23:06] <lue> [ tenses may be incorrect, please ignore that :) ]

[23:06] <frettled> lue: don't be so tense

[23:06] *** sawyer_ left
[23:06] <Arthur_TwoSheds_> What's this about a shed?

[23:07] <lue> (it should've been Arthur_TwoSheds_Jackson)

[23:07] <masak> the more rigorously I use TDD, the more I feel they settle into the role of a "sure, good, but you forgot this aspect of things" advisor.

[23:07] <frettled> masak: perhaps it's time for DDT…

[23:07] <frettled> …Development-Driven Testing

[23:07] <masak> which is a really good advisor to have when writing code.

[23:07] <frettled> it's the new killer project management

[23:08] <masak> frettled: only write one, and *exactly* one test after you've written some code? :P

[23:08] <lue> RTD (Rapid Tuit Development)

[23:08] <sorear> masak: Recommended reading for IRC helpers: http://www.shadowcat.co.uk/blog/matt-s-trout/on-being-a-bastard/

[23:08] <masak> sorear: thanks. read it.

[23:09] <lue> .oO(OK, I've coded this awesome macro implementation for rakudo....

[23:09] *** masonkramer joined
[23:09] <masak> sorear: I understand where he's coming from, but I'm not sure I have it in me to assume the role of a channel bastard myself.

[23:09] <sorear> pmichaud: yes, that is the plan

[23:09] <lue> ....I'll add this test to the macros tests:    is 2+2, 4, "complex macro wizardry";    )

[23:09] <masak> sorear: definitely not through privmsg, which has more of a booth-like feel to it.

[23:10] <masak> sorear: the closest I got was tossing http://catb.org/esr/faqs/smart-questions.html at the fellow.

[23:12] *** justatheory joined
[23:13] <lue> .oO(I should work more on my Time Traveller's Tenses Handbook before attempting to pull off that kind of thing again)

[23:14] <frettled> masak: Or, to quote someone who may very well have been Don Knuth in a sardonic mood: «if your code is correct, you don't need tests»

[23:15] <frettled> lue: Recommended starting point for that: http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBIQFjAA&url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FJames_while_John_had_had_had_had_had_had_had_had_had_had_had_a_better_effect_on_the_teacher&ei=Zwo1TOWSFpCoOK7chN8B&usg=AFQjCNEgwdyvnB7gjmaangtKPsROH3UkTA&sig2=HO69bLjekm5P_CoSaOfKag

[23:15] <frettled> artghle, sorry, I forgot about googles effin' way of handling URLs.

[23:15] <frettled> lue: http://en.wikipedia.org/wiki/James_while_John_had_had_had_had_had_had_had_had_had_had_had_a_better_effect_on_the_teacher

[23:15] *** justatheory left
[23:15] <masak> frettled: sure. it's just a big 'if'.

[23:16] <masak> frettled: I find tests let me lower my guard when coding, and get away with it. feels less tense.

[23:16] <frettled> masak: which is why i kindof suspect that it was a sardonic remark :)

[23:17] <frettled> masak: I tend to add a lot of in-code tests, yet I somehow seem to slip quite often, leaving uncaught test cases, heh.

[23:17] <lue> frettled: want me to link you to one big inspiration for this book? *evil grin*

[23:17] <sorear> pmichaud: meant that for pmurias

[23:17] <frettled> lue: Perhaps, I could need som help in getting to bed two hours ago :)

[23:17] <pmichaud> sorear: I guessed that eventually.  It's happened to me and pmurias a lot. :)

[23:17] <masak> frettled: "in-code tests"? as in, mixing code and tests?

[23:18] <lue> frettled: http://tvtropes.org/pmwiki/pmwiki.php/Main/TimeTravelTenseTrouble *evil laugh*

[23:18] <frettled> masak: yes, but not tests as in test-framework tests, since most of my code isn't about re-usable modules, but rather scriptish programs.

[23:18] <frettled> lue: uh-oh, TV Tropes...

[23:18] <lue> (quite seriously, I was spending one late night browsing Time Travel Tropes when the book idea hit me)

[23:19] *** sawyer_ joined
[23:20] *** IllvilJa left
[23:21] <masak> frettled: would be cool to have a testing framework that disrespected the reduced visibility of things like 'my' subs. :)

[23:21] <masak> then they could be tested more easily.

[23:22] <lue> .oO(lexcial subs, the enemy to unfudged binding tests)

[23:22] <masak> also, private methods.

[23:23] * lue should really get to work on _something_. Stupid quantum feelings.

[23:24] *** skangas left
[23:24] <frettled> masak: ooh aah :)

[23:24] *** IllvilJa joined
[23:25] <sorear> lue: for someone who claims to be a hhgttg fan, you needed tvtropes to get the book idea?

[23:26] <lue> I haven't read the first 5 of 3 in a looong time, and I only read 6 of 3 a little while ago.

[23:27] *** sawyer_ left
[23:27] *** sawyer_ joined
[23:27] <lue> not only that, but at the time I had Doctor Who on the brain, which led me to the Time Travel Tropes in the first place :)

[23:30] *** ashleydev_ joined
[23:30] *** ashleydev left
[23:30] *** ashleydev_ is now known as ashleydev

[23:32] *** sawyer_ left
[23:32] *** sawyer_ joined
[23:33] *** rv2733 joined
[23:40] *** tedv joined
[23:40] *** masonkramer left
[23:40] *** masonkramer_ joined
[23:40] *** masonkramer_ is now known as masonkramer

[23:41] <masak> heh -- every spectest file that has failed spectacularly (except for t/spec/S05-mass/properties-derived.rakudo, a usual suspect) has had the old 'lines' or '.lines' calls in it. :)

[23:41] <jnthn> :-)

[23:42] <lue> :) .oO(hrm, spectacularily not ok 63)

[23:42] <masak> lue: yeah, like that. :)

[23:43] <pugssvn> r31571 | Kodi++ | [S32] Dropped mention of quarters from Temporal.pod. I don't think quarter-numbering belongs in the core, since (as far as I know) there is no precise standard way of dividing calendar years into four. 

[23:43] <masak> hm, Kodi isn't on the channel.

[23:45] <masak> seems dividing by triplets of months is sane enough for DateTime.

[23:45] <pugssvn> r31572 | Kodi++ | [t/spec] Cleaned up DateTime.t a bit. (I hadn't meant to commit it yet.) 

[23:46] *** skangas joined
[23:46] *** proller left
[23:46] <masak> oh well, I won't miss quarters greatly. if no-one else kicks up a fuss about it, I won't either. :)

[23:47] *** DarkWolf84 left
[23:47] *** silug joined
[23:47] <jnthn> Aww, I thought somebody was about to get hung, drawn and quartered ;-)

[23:47] <masak> jnthn: well, can't do that after r31571, can we? :P

[23:48] <frettled> can we settle for my 2 cents?

[23:49] *** LionMadeOfLions joined
[23:49] <masak> absolutely.

[23:49] *** rv2733 left
[23:49] <lue> rakudo if pir::getprop('ro', $target) { punish("severly") }

[23:51] <frettled> masak: but, ye gods, does that mean I'll have to find when March ends and April starts all by myself?  :D

[23:51] *** silug left
[23:52] <masak> frettled: that was your two cents? just checking. :)

[23:52] <frettled> Yup, all out.  Oh.  D'oh!

[23:52] <masak> frettled: you can still create a DateTime object for April 1, and check the day-of-year property on it.

[23:53] <masak> in other news, we have too many trig tests.

[23:53] <jnthn> masak: It's not a huge leap to realize that this is not going to be so simple for some years though. ;-)

[23:53] * lue wonders if any part of DateTime is suitable to (sim|em)ulate a CPU clock...

[23:53] <sorear> STD.pm6 has lots of ¢ you may be able to borrow

[23:53] <sorear> lue: no

[23:54] <sorear> DateTime handles the insanity that is civil time

[23:54] <masak> jnthn: it's not intrinsically harder for quarters than for months.

[23:55] *** Psyche^ joined
[23:59] *** Patterner left
[23:59] *** Psyche^ is now known as Patterner

[23:59] <lue> (not that the CPU clock is terribly important. I have to worry about VBlanking and mid-frame trickery and such.)

