[00:00] *** Patterner left
[00:00] *** Psyche^ is now known as Patterner

[00:02] *** tyru joined
[00:02] *** felliott left
[00:04] *** justatheory left
[00:04] *** masonkramer joined
[00:04] *** hanekomu_9 left
[00:07] *** [bjoern] joined
[00:08] <[bjoern]> Shouldn't `say '*'..'~'` print out the characters "*+,-./01234...~"? Rakudo locally consumes lots and lots of memory doing very little, and the bot says ...

[00:08] *** timbunce left
[00:08] <[bjoern]> [02:05] <p6eval> rakudo 0b1212:

[00:08] <[bjoern]> [02:05] <p6eval> ..OUTPUT¬´************...

[00:09] <jnthn> rakudo: say '*'.succ

[00:09] <p6eval> rakudo 0b1212: OUTPUT¬´*‚ê§¬ª

[00:09] <jnthn> I thought the .. bug had been fixed. :-(

[00:09] *** PZt left
[00:10] <[bjoern]> It does work with a..z for instance

[00:10] <dalek> rakudo: f49e91b | jonathan++ | src/core/Mu.pm:

[00:11] <dalek> rakudo: .can helper is only defined on Any, not Mu. Last bug I fixed masked this issue 

[00:11] <dalek> rakudo: somehow - this deals with it.

[00:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/f49e91b2df0ca6bcdb295206c55edd3f6fad0584

[00:11] <dalek> rakudo: 1231260 | jonathan++ | src/glue/subset.pm:

[00:11] <dalek> rakudo: Need to attach the originally refined type to the subtype so the signature 

[00:11] <dalek> rakudo: binder can get the nominal and constrainty parts of it. The corrects a less than 

[00:11] <dalek> rakudo: awesome error and probably much more.

[00:11] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/1231260c3af751e19e11bfcc5701170a57626931

[00:11] *** cdarroch left
[00:12] <tadzik> g'night #perl6

[00:12] <au|irc> g'‚ôû :)

[00:12] <tadzik> :)

[00:12] *** tadzik left
[00:13] <[bjoern]> http://www.nntp.perl.org/group/perl.perl6.language/2010/06/msg33775.html seems relevant

[00:13] <pugssvn> r31771 | jnthn++ | [t/spec] Correct a bunch of spectests that relied on the old Int ~~ Num assumption, including changing one test to ensure that this is indeed not the case. 

[00:15] <jnthn> [bjoern]: Yes, there's been quite a lot of discussion about the .. operator of late. I'm not quite up on the latest.

[00:15] <[bjoern]> s03 even seems to have related tests, so I don't have to bother filing a bug. Good.

[00:16] <jnthn> Well, filing may help get it dealt with sooner. On the other hand, this one comes up quite a bit.

[00:16] <dalek> rakudo: 3139735 | jonathan++ | src/builtins/Num.pir:

[00:16] <dalek> rakudo: Toss Int ~~ Num hack; from now on, use Int ~~ Numeric. Good to excise this one 

[00:16] <dalek> rakudo: before R* so people don't write code assuming it. :-)

[00:16] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/31397353ad686c61f231f480d497d55d4a60aa9c

[00:16] <dalek> rakudo: ee1b11b | jonathan++ | src/Perl6/Grammar.pm:

[00:16] <dalek> rakudo: Port over a couple more errors from STD - mostly copy/paste/test.

[00:16] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/ee1b11bd6f0e1cfeb8b16d12bd94802bf259cbc1

[00:20] <jnthn> std: sub foo {}; foo(:a :b :c)

[00:20] <p6eval> std 31770: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[00:20] <jnthn> Aww

[00:20] <jnthn> Still don't like that :-)

[00:21] *** Sarten-X left
[00:24] <jnthn> Phew, back under 640 tickets :-)

[00:24] <au|irc> yay :)

[00:29] *** lest_away is now known as lestrrat

[00:30] <[Coke]> Think we can do <600 for the release this week?

[00:32] <jnthn> [Coke]: That'd be quite a push - especially when there's always more coming in. ;-)

[00:32] <jnthn> [Coke]: As well as closing some tonight though, I've given several to moritz_++ for spectesting too.

[00:32] <jnthn> [Coke]: We're probably sub-630 if you discount those.

[00:40] *** japhb left
[00:44] *** guest__ joined
[00:44] *** japhb joined
[00:44] *** guest__ left
[00:47] *** whiteknight left
[00:58] *** hudnix left
[01:05] <dalek> niecza: d48aa80 | sorear++ | Kernel.cs:

[01:05] <dalek> niecza: Clean up list assignment, allow for custom FETCH / STORE / INVOKE

[01:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d48aa801237002677801af04940c3679601fb793

[01:06] *** takadonet1 joined
[01:06] <takadonet1> hey everyone

[01:07] *** ashleydev left
[01:12] *** [bjoern] left
[01:13] *** au|irc is now known as au|afk

[01:23] *** PZt joined
[01:24] <sorear> hello takadonet1 

[01:24] <takadonet1> sorear: someone is alive!

[01:26] *** payload1 joined
[01:27] *** azert0x left
[01:27] <sorear> TimToady: Do you have any thoughts on the matter of ratchet optimization for Perl 6?

[01:28] <sorear> TimToady: just passing and returning 1-element lazy lists as the spec seems to imply turns into a lot of bonus method calls

[01:28] *** payload left
[01:28] <sorear> TimToady: my current plan involves a low-level hack in the method dispatcher

[01:40] <takadonet1> rakudo: class A { $.var is rw; } A.new(); a.var(3); say $a.var();

[01:40] <p6eval> rakudo ee1b11: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 22‚ê§¬ª

[01:40] <takadonet1>  rakudo: class A { $.var is rw; }; A.new(); a.var(3); say $a.var();

[01:40] <p6eval> rakudo ee1b11: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 22‚ê§¬ª

[01:40] <takadonet1> ...

[01:41] <takadonet1> tired

[01:41] <takadonet1> rakudo: class A { $.var is rw; }; my $ya=A.new(); $ya.var(3); say $ya.var();

[01:41] <p6eval> rakudo ee1b11: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 22‚ê§¬ª

[01:44] *** payload1 left
[01:44] <TimToady> sorear: not really, though the 'andthen' operator was intended to allow linearization of defined-or-not cascaded hypothesis proving

[01:45] <TimToady> (made it to PDX btw)

[01:47] *** skids joined
[01:48] *** Sarten-X joined
[01:53] *** uvtc joined
[01:56] <dalek> rakudo: cf3da00 | jonathan++ | src/Perl6/ (2 files):

[01:56] <dalek> rakudo: NYI notes for constant, state and macro. Hopefully we get to at least state by 

[01:56] <dalek> rakudo: R*, but if not better to give a good error.

[01:56] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/cf3da00729148a434339d7aa0d819efebe5a0cb2

[01:58] <takadonet1> jnthn: I just finished doing make spectest;make install !

[01:58] <jnthn> :P

[01:59] <jnthn> Well, those are just some better errors rather than anything shiny. :-)

[01:59] <takadonet1> i know but still :P

[01:59] <takadonet1> hard to keep 3 versions of rakudo in syn

[01:59] *** uvtc left
[02:00] <jnthn> Well, I should probably consider some sleep soonish, so I dobut I'll be bothering you with more patches at least until tomorrow. ;-)

[02:01] <takadonet1> going to bed soon as well. Just one more commit...

[02:01] <jnthn> :-)

[02:01] <takadonet1> jnthn: http://github.com/cjfields/bioperl6/tree/

[02:02] <jnthn> Well, that was my just one more commit. :-) I've been reading while it spectested. :-)

[02:02] * jnthn looks

[02:03] <jnthn> Wow, there's quite a lot of work in there. :-)

[02:04] <takadonet1> it's easy to port something that I used everyday in perl 5 :)

[02:07] <takadonet1> also without really knowing it, everyone on the channel been helping :)

[02:07] <jnthn> :-)

[02:07] <jnthn> Next up: make this run fast. :-)

[02:08] *** Sarten-X left
[02:10] * jnthn -> sleep

[02:11] *** drbean joined
[02:17] <sorear> niecza: sub accum() { sub () { state $x = 0; $x++ }; }; my $y = accum; say $y(); say $y()

[02:17] <p6eval> niecza: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported scope state for simple variable at (eval) line 1:‚ê§------> [32msub accum() { sub () { state $x [33m‚èè[31m= 0; $x++ }; }; my $y = accum; say $y();[0m‚ê§Attribute (positionals) does not pass the type constraint because: Validation failed for‚Ä¶

[02:19] <sorear> oh right

[02:19] <sorear> I *did* ask moritz_ to delay starting the updater... guess I should fix that

[02:20] *** marqos joined
[02:31] <marqos> rakudo: const @COLORS = <red green blue>; say @COLORS

[02:31] <p6eval> rakudo ee1b11: OUTPUT¬´===SORRY!===‚ê§Symbol '@COLORS' not predeclared in <anonymous> (/tmp/l_vmcBpon8:22)‚ê§¬ª

[02:31] <marqos> alpha: const @COLORS = <red green blue>; say @COLORS

[02:31] <p6eval> alpha 30e0ed: OUTPUT¬´Symbol '@COLORS' not predeclared in <anonymous> (/tmp/P74wAQT149:10)‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[02:31] <TimToady> std: const @COLORS = <red green blue>; say @COLORS

[02:31] <p6eval> std 31771: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable @COLORS is not predeclared at /tmp/J0wrrUQS0D line 1:‚ê§------> [32mconst @COLORS[33m‚èè[31m = <red green blue>; say @COLORS[0m‚ê§Variable @COLORS is not predeclared at /tmp/J0wrrUQS0D line 1:‚ê§------> [32m @COLORS = <red green blue>; say

[02:31] <p6eval> ..@COLO‚Ä¶

[02:32] <TimToady> std: constant @COLORS = <red green blue>; say @COLORS

[02:32] <p6eval> std 31771: OUTPUT¬´ok 00:01 117m‚ê§¬ª

[02:32] <marqos> oh, spelled out.

[02:32] <TimToady> looks like that's gonna be one of those common flubs :)

[02:32] <marqos> Thanks, Larry.  I was just about to dive into the synopsis to see what I was missing.. I remembered that working.

[02:33] *** payload joined
[02:33] <marqos> rakudo: constant @COLORS = <red green blue>; say @COLORS

[02:33] <p6eval> rakudo ee1b11: OUTPUT¬´===SORRY!===‚ê§Symbol '@COLORS' not predeclared in <anonymous> (/tmp/bFdfyFaeTF:22)‚ê§¬ª

[02:34] <TimToady> I think alpha does

[02:34] <marqos> alpha:  constant @COLORS = <red green blue>; say @COLORS

[02:34] <p6eval> alpha 30e0ed: OUTPUT¬´redgreenblue‚ê§¬ª

[02:34] <TimToady> (but it really just means 'my' there)

[02:34] <marqos> freshly-built rakudo says it's not implemented yet...

[02:36] <TimToady> it's supposed not be a scope declarator anymore either, but more like a subset name

[02:36] *** masonkramer left
[02:36] <TimToady> you might be able to get away with an enum containing one value :)

[02:36] <sorear> TimToady: what do you mean by it being like a subset name?

[02:37] <TimToady> std: my subset X of Any where True;

[02:37] <p6eval> std 31771: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[02:37] <TimToady> std: my constant pi = 3;

[02:37] <p6eval> std 31771: OUTPUT¬´ok 00:01 116m‚ê§¬ª

[02:37] <TimToady> alpha: my constnat pi = 3;

[02:37] <p6eval> alpha 30e0ed: OUTPUT¬´Malformed declaration at line 10, near "constnat p"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[02:38] <TimToady> alpha: my constant pi = 3;

[02:38] <p6eval> alpha 30e0ed: OUTPUT¬´Malformed declaration at line 10, near "constant p"‚ê§in Main (file <unknown>, line <unknown>)‚ê§¬ª

[02:38] <TimToady> it thinks constant is like 'my', so doesn't allow a 'my' before it

[02:39] *** takadonet1 left
[02:39] *** felliott joined
[02:39] <TimToady> dinner &

[02:44] <sorear> std: constant = 5;

[02:44] <p6eval> std 31771: OUTPUT¬´ok 00:01 116m‚ê§¬ª

[02:44] <sorear> Does it really make any sense to allow anonymous constants?

[02:45] <sorear> STD.pm6:2938

[02:54] *** huf joined
[02:56] <dalek> niecza: 007fab2 | sorear++ |  (2 files):

[02:56] <dalek> niecza: Implement the constant declator, with and without sigils (they aren't actually 

[02:56] <dalek> niecza: constant yet though)

[02:56] <dalek> niecza: review: http://github.com/sorear/niecza/commit/007fab2fdba75a4b47eb6f05de2245dc6c699201

[03:05] *** brianherman joined
[03:05] <brianherman> perl6: say "yay";

[03:06] <p6eval> pugs, rakudo cf3da0: OUTPUT¬´yay‚ê§¬ª

[03:07] <pmichaud> good evening

[03:08] <sorear> hello pmichaud

[03:09] <marqos> so is there any way to have an eval affect the surrounding scope?

[03:09] *** agentzh joined
[03:10] <sorear> elaborate on "affect"

[03:10] <sorear> an eval is considered to be an ordinary inner scope

[03:10] *** mrsaturn12 joined
[03:11] *** plobsing joined
[03:12] <marqos> so you can use %MY .. or however that's spelled ...

[03:12] <tylercurtis> pmichaud: if, in a HLL::Grammar.O(...), I don't specify an associativity, is the operator taken to be non-associative?

[03:13] <pmichaud> tylercurtis: I'd have to look.  

[03:13] <pmichaud> (looking)

[03:15] <marqos> rakudo: eval "$OUTER::x=1;"; say $x

[03:15] <p6eval> rakudo cf3da0: OUTPUT¬´===SORRY!===‚ê§Symbol '$x' not predeclared in <anonymous> (/tmp/5pEe2gpDZT:22)‚ê§¬ª

[03:16] <pmichaud> marqos: an eval is not permitted to add to the outer scope at runtime

[03:16] <pmichaud> (and in this case, $x is not predeclared :-)

[03:16] <marqos> rakudo: eval "OUTER::$x=1"; say $x

[03:16] <p6eval> rakudo cf3da0: OUTPUT¬´===SORRY!===‚ê§Symbol '$x' not predeclared in <anonymous> (/tmp/1As4uwbRv_:22)‚ê§¬ª

[03:17] <pmichaud> tylercurtis: I'm not sure what associativity is assumed.  The algorithm basically follows whatever STD.pm6 did (at the time it was written)

[03:17] <pmichaud> I think it may be right-associative by default.

[03:17] <tylercurtis> pmichaud: is there a way to specify non-associativity?

[03:17] <marqos> So how does one create a variable/sub/method with a name that's not known till runtime?

[03:17] <pmichaud> :assoc<non>, I think.

[03:18] <pmichaud> looking

[03:18] <tylercurtis> pmichaud++: thanks.

[03:18] <pmichaud> :assoc<unary>, :uassoc<non>   # looks like

[03:19] <pmichaud> not sure that HLL::Grammar implements true non-associativity yet, though.

[03:19] <pmichaud> (if non-associativity is missing, it's arguably a bug.)

[03:19] <pmichaud> oh, looks like there's also   :assoc<non>

[03:19] <pmichaud> (in STD.pm6)

[03:20] <pmichaud> yes, I'm guessing that HLL::Grammar doesn't implement non-associative yet.  We can add it if you need it.

[03:21] <pmichaud> (I probably don't have it yet because I hadn't really needed it.)

[03:21] *** skids left
[03:22] <marqos> I guess assigning to MY::{$varname} should work...

[03:22] <pmichaud> 03:16 <pmichaud> marqos: an eval is not permitted to add to the outer scope at runtime

[03:22] <marqos> Right.  Hence my question of how do you add a dynamic name to a scope at runtime?

[03:22] <marqos> Since eval ain't it.

[03:22] <mrsaturn12> Why would you want to?

[03:25] <pmichaud> From S02:

[03:25] <pmichaud> You may not use any lexically scoped symbol table, either by name or

[03:25] <pmichaud> by reference, to add symbols to a lexical scope that is done compiling.

[03:25] <pmichaud> (We reserve the right to relax this if it turns out to be useful though.)

[03:26] *** ruoso joined
[03:26] <marqos> But that only applies to lexical scopes, right?  You can dynamically add to a class or module?

[03:26] <tylercurtis> pmichaud: I'm not sure that I do. Technically, looking at Squaak's grammar in Episode 3 of the tutorial, all the binary ops appear to be associative(although the grammar listed there doesn't describe operator precedence at all, so it's hardly definitive). I'm going to assume left associative for all of them, since it doesn't clearly specify and left associativity is what one would expect for most of its ops.

[03:27] <marqos> In this case I was just playing around with porting some code that dynamically creates a bunch of delegation methods that are all very similar...

[03:28] <pmichaud> tylercurtis: best for the tutorial is to explicitly list the associativity, I'd think.

[03:28] <marqos> basically $container.$method($key, *@args) is defined as %.children{$key}.$method(@args) for a bunch of different values of $method

[03:28] <tylercurtis> pmichaud: I'm explicitly listing it. I'm just having to guess at what I should explicitly list. Did PGE assume a certain associativity?

[03:29] <pmichaud> I think PGE assumed left.

[03:29] <pmichaud> (it did assume something, yes.)

[03:29] <pmichaud> (I'm pretty sure it was 'left')

[03:29] <sorear> Is PGE dead yet?

[03:30] <pmichaud> "It's pining for the fjords..."

[03:30] <pmichaud> (or something like that)

[03:30] <tylercurtis> pmichaud: I expect left is the case, too, since geb() or nyr() or fnu() would be very unintuitive if right-associative, for example.

[03:31] <marqos> as far as I can tell, "handles" doesn't quite do that.

[03:31] <sorear> marqos: yes, you can add stuff to a class at runtime

[03:31] <sorear> try eval "augment Foo { method bar () { } }

[03:31] <brianherman> So I am compiling perl6 from source on mac os x and i get this error auto::va_ptr -        Test the type of va_ptr...

[03:31] <brianherman> step auto::va_ptr died during execution: Unknown va_ptr type at config/auto/va_ptr.pm line 42.

[03:31] <brianherman> can i ignore that?

[03:31] <marqos> sorear: right, but in this case the method name is the value of a variable.

[03:31] <sorear> brianherman: that doesn't look like a perl 6 build

[03:31] <sorear> marqos: eval is a string!

[03:31] <sorear> you can interpolate whatever you want

[03:32] <marqos> Oh, sorry, missed the eval. :)

[03:32] <sorear> methods and classes don't live in lexical scopes, so you're free to add them in evals

[03:32] <sorear> immutability only applies to "my"

[03:32] <pmichaud> also, use single quotes.

[03:32] <pmichaud> otherwise the braces are likely to hurt.

[03:33] <pmichaud> (or use some quoting construct other than "...")

[03:33] <marqos> so if I'm inside Foo, should just eval "my $foo='bar'; method $foo \{ ... }" work?

[03:34] <sorear> It won't work.

[03:34] <sorear> Perhaps it should.

[03:34] <marqos> (in theory, I mean, not necessarily on current rakudo...)

[03:34] <pmichaud> well, it's possible to have methods that aren't has-scoped, so I suspect one would need to re-list the class explicitly.

[03:35] <pmichaud> I suppose there might be a way to detect that eval is taking place inside of a class scope.

[03:36] <brianherman> sorear: i am sorry that was parrot

[03:36] <marqos> Wouldn't it have more to do with the fact that the thing being eval'ed is 'method', which defaults to has?

[03:36] <pmichaud> brianherman: I'm guessing that you're missing a developers library or module that is needed for va_ptr.  (It's just a guess.)

[03:36] *** Sarten-X joined
[03:37] <pmichaud> brianherman: you might try asking on irc.perl.org/#parrot

[03:37] * tylercurtis walk &

[03:37] <pmichaud> (and then let us know here so we can document it somewhere.)

[03:37] *** mrsaturn12 left
[03:37] <sorear> Methods are very weird, since they can have two scopes at once

[03:38] <sorear> "my method" is really "my has method"

[03:38] <sorear> it goes into both the lexpad and the class

[03:38] <pmichaud> ...if it's inside of a class declaration.

[03:38] <sorear> my &foo = anon method, by contrast, goes into only the lexpad

[03:38] <pmichaud> right.

[03:39] <brianherman> only 3 people are in parrot

[03:39] <pmichaud> brianherman: on irc.perl.org, not freenode

[03:39] <brianherman> oh

[03:39] <pmichaud> (or irc.parrot.org)

[03:42] <brianherman> meh i think ill just use linux

[03:43] <brianherman> thanks guy

[03:43] <brianherman> s

[03:45] <pugssvn> r31772 | pmichaud++ | [pm.txt]:  Add Pm-21 and Pm-22 to request confirmation of lexical regex semantics. 

[03:46] *** IllvilJa1 joined
[03:47] *** marqos is now known as markjreed

[03:47] <pmichaud> phenny: tell jnthn Is there a way from actions to see if an outer scope defines a method (regex, actually) of a given name?  See Pm-21 in misc/pm.txt .

[03:47] <phenny> pmichaud: I'll pass that on when jnthn is around.

[03:48] <markjreed> sorry, was not myself..

[03:48] <pmichaud> phenny: it doesn't appear that methods are entered in a PAST::Block's symbol table.

[03:48] <pmichaud> phenny: tell jnthn it doesn't appear that methods are entered in a PAST::Block's symbol table.

[03:48] <phenny> pmichaud: I'll pass that on when jnthn is around.

[03:48] *** IllvilJa left
[03:48] *** DemoFreak left
[03:48] <markjreed> rakudo:  class Foo { }; eval 'augment Foo { method foo { say "Hello, world!" } }'

[03:48] <p6eval> rakudo cf3da0:  ( no output )

[03:49] <Tene> rakudo:  class Foo { }; eval 'augment Foo { method foo { say "Hello, world!" } }'; my Foo $foo .= new; $foo.foo;

[03:49] <p6eval> rakudo cf3da0: OUTPUT¬´Method 'foo' not found for invocant of class 'Foo'‚ê§  in main program body at line 22:/tmp/BLIbIYqzEX‚ê§¬ª

[03:50] <markjreed> Locally I get ==SORRY!===

[03:50] <markjreed> In "augment" declaration, typename Foo must be predeclared (or marked as declarative with :: prefix) at line 1, near " { method "

[03:50] *** DemoFreak joined
[03:51] <Tene> rakudo:  class Foo { }; augment Foo { method foo { say "Hello, world!" } }; my Foo $foo .= new; $foo.foo;

[03:51] <p6eval> rakudo cf3da0: OUTPUT¬´===SORRY!===‚ê§In "augment" declaration, typename Foo must be predeclared (or marked as declarative with :: prefix) at line 22, near " { method "‚ê§¬ª

[03:51] <Tene> rakudo:  class Foo { }; eval 'augment ::Foo { method foo { say "Hello, world!" } }'; my Foo $foo .= new; $foo.foo;

[03:51] <pmichaud> augment *class* Foo

[03:51] <p6eval> rakudo cf3da0: OUTPUT¬´Method 'foo' not found for invocant of class 'Foo'‚ê§  in main program body at line 22:/tmp/Nn0z2sYf2t‚ê§¬ª

[03:51] <Tene> rakudo:  class Foo { }; eval 'augment class Foo { method foo { say "Hello, world!" } }'; my Foo $foo .= new; $foo.foo;

[03:51] <p6eval> rakudo cf3da0: OUTPUT¬´Method 'foo' not found for invocant of class 'Foo'‚ê§  in main program body at line 22:/tmp/tZfzclAnQV‚ê§¬ª

[03:51] <pmichaud> I'm guessing the eval fails.

[03:51] <markjreed> class Foo { }; augment class Foo { method foo { say "Hello, world!" } }

[03:51] <Tene> rakudo:  class Foo { }; augment class Foo { method foo { say "Hello, world!" } }; my Foo $foo .= new; $foo.foo;

[03:51] <pmichaud> probably need "use MONKEY_TYPING"

[03:51] <p6eval> rakudo cf3da0: OUTPUT¬´===SORRY!===‚ê§Can't augment class Foo without 'use MONKEY_TYPING'‚ê§¬ª

[03:52] <Tene> yeah

[03:53] *** ashleydev joined
[03:58] <markjreed> rakudo: use MONKEY_TYPING; class Foo {}; eval 'augment class Foo { method foo { say "hello, world" } }'; Foo.new.foo

[03:58] <p6eval> rakudo cf3da0: OUTPUT¬´Method 'foo' not found for invocant of class 'Foo'‚ê§  in main program body at line 22:/tmp/WnPsmWsN6j‚ê§¬ª

[03:58] <markjreed> rakudo: use MONKEY_TYPING; class Foo {}; augment class Foo { method foo { say "hello, world" } }; Foo.new.foo

[03:58] <p6eval> rakudo cf3da0: OUTPUT¬´hello, world‚ê§¬ª

[03:58] <pmichaud> might need the MONKEY_TYPING inside the eval.

[03:58] <pmichaud> (arguably a bug if so.)

[03:59] <markjreed> rakudo: class Foo {}; eval 'use MONKEY_TYPING;augment class Foo { method foo { say "hello, world" } }'; Foo.new.foo

[03:59] <p6eval> rakudo cf3da0: OUTPUT¬´hello, world‚ê§¬ª

[03:59] <markjreed> ahh.

[04:00] <markjreed> That will work.  Thanks!

[04:04] <dalek> nqp-rx: b09bf8d | pmichaud++ | src/Regex/P6Regex/Actions.pm:

[04:04] <dalek> nqp-rx: Refactor named_assertion method a bit.

[04:04] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/b09bf8d23bec919af0460c874ebaf5216a34f535

[04:04] <dalek> nqp-rx: f7e92b4 | pmichaud++ | src/stage0/ (3 files):

[04:04] <dalek> nqp-rx: Update bootstrap.

[04:04] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/f7e92b492372cd803b322ce034ead38c224a4279

[04:05] <markjreed> Hm. augment seems to re-trigger role composition...

[04:06] *** TiMBuS joined
[04:09] <tylercurtis> pmichaud: does the bit at http://trac.parrot.org/parrot/browser/trunk/examples/languages/squaak/doc/tutorial_episode_7.pod#L234 beginning with "What happens if you don't specify a pasttype?" still accurate? I'm guessing no, but I wanted to check.

[04:09] *** snarkyboojum left
[04:10] *** cls_bsd left
[04:11] <markjreed> rakudo: role Bar { has @.on_tap }; class Foo does Bar {}; eval 'use MONKEY_TYPING; augment class Foo { method foo { say "hello, world" } }'; say $!

[04:11] <p6eval> rakudo cf3da0: OUTPUT¬´Attribute '@!on_tap' already exists in the class, but a role also wishes to compose it‚ê§¬ª

[04:12] * sorear is going to need to start thinking about optimization passes soonish

[04:15] *** markjreed left
[04:22] *** timbunce joined
[04:22] *** mrsaturn12 joined
[04:24] *** brianherman left
[04:33] *** justatheory joined
[04:40] <dalek> niecza: 663c423 | sorear++ |  (3 files):

[04:40] <dalek> niecza: Implement parsing for simple regexes

[04:40] <dalek> niecza: review: http://github.com/sorear/niecza/commit/663c423fe8f874a4ef53926a8798ce176fca8923

[04:49] *** PZt left
[04:51] <timbunce> jnthn: I hear Zavolaj is broken at the moment. Any ETA for a fix?

[05:04] *** snarkyboojum joined
[05:05] *** justatheory left
[05:07] *** colomon left
[05:08] *** PZt joined
[05:10] *** plobsing left
[05:11] *** felliott left
[05:21] *** mrsaturn12 left
[05:23] *** payload left
[05:24] *** daxim joined
[05:26] *** timbunce left
[05:28] *** timbunce joined
[05:42] *** cls_bsd joined
[05:45] <sorear> std: / :my $x; /; say $x;

[05:45] <p6eval> std 31772: OUTPUT¬´ok 00:01 118m‚ê§¬ª

[05:45] <sorear> I argue this is wrong.

[05:45] <sorear> regexes should get a new scope around every quant_atom_list

[05:46] <sorear> rakudo: / :my $x; /; say $x;

[05:46] <p6eval> rakudo cf3da0: OUTPUT¬´Any()‚ê§¬ª

[05:46] <sorear> *blink*

[05:47] *** timbunce left
[05:52] *** synth left
[05:56] *** timbunce joined
[06:00] *** ingy left
[06:02] *** timbunce left
[06:02] *** ingy joined
[06:02] *** cognominal left
[06:03] *** cognomore left
[06:04] *** snarkyboojum left
[06:04] *** ashleydev left
[06:12] *** uniejo joined
[06:13] *** PZt left
[06:13] *** alfieANDfred joined
[06:13] *** PZt joined
[06:14] *** alfieANDfred left
[06:14] *** cognominal joined
[06:19] <moritz_> good morning

[06:19] <mathw> Morning

[06:20] <tylercurtis> moritz_: good morning.

[06:21] * moritz_ yawns

[06:21] *** uniejo left
[06:23] *** uniejo joined
[06:25] *** _mpu joined
[06:28] <sorear> good morning moritz_

[06:28] <sorear> I seem to have forgotten to tell you that I no longer need niecza p6eval updates held

[06:30] <moritz_> crontab installed.

[06:30] <moritz_> I think you did tell me, but I forgot to tadd the cron job

[06:46] <moritz_> sorear: manually triggered niecza rebuild is finished

[06:47] <moritz_> sorear: btw if you add a step to make that puts the current revision into a file, I can report that revision from p6eval

[06:50] <moritz_> ./perl6 -e 'my $x = "foo"; $x ~~ s:g/o/u/; say $x'

[06:50] <moritz_> fuu

[06:51] <ingy> greetings

[06:51] <moritz_> oh hai

[06:51] * ingy is sitting alone in the oscon hotel lobby

[06:52] <ingy> I just wrote a p6rules-as-yaml reducer in Python

[06:52] <ingy> I have a question

[06:53] <ingy> does rakudo use p6rules to parse perl6?

[06:53] <ingy> I'm assuming it does

[06:53] <moritz_> yes

[06:53] <moritz_> src/Perl6/Grammar.pm

[06:53] *** eternaleye left
[06:55] <ingy> so my ambition is to port the p6 grammar to my acmeist p6rules subset called FooParse, that uses a PCRE engine

[06:55] <ingy> and is thus many times faster

[06:55] <moritz_> have fun! :-)

[06:55] <ingy> I will!

[06:56] <ingy> I feel like I'm really close

[06:56] <ingy> maybe

[06:57] <ingy> so is it true that rakudo has no access to a regexp engine?

[06:57] <ingy> (besides p6rules of course...)

[06:57] <tylercurtis> ingy: if you're really ambitious, try converting STD.pm6 over to your subset. :)

[06:57] <ingy> which is a stretch to call regexp

[06:58] <tylercurtis> ingy: not a stretch, a shrink.

[06:58] <sorear> p6rules are far more powerful than regexes and are mostly syntax compatible

[06:58] <ingy> I agree

[06:59] <ingy> but I'm just asking if rakudo can invoke a "normal" regexp engine

[06:59] <ingy> ie pcre, etc

[06:59] <sorear> no

[06:59] <ingy> does parrot have one?

[07:00] <tylercurtis> ingy: you could use one with NCI.

[07:00] <sorear> parrot has a Regex engine but it's actually a p6rules engine

[07:01] <cxreg> tylercurtis: except that without zavolaj, nci is a pain in the ass :)

[07:02] <ingy> so here's an example....

[07:02] <ingy> I took this 300 line TestML grammar: http://github.com/ingydotnet/testml-pm6/blob/master/lib/TestML/Parser/Grammar.pm

[07:03] <ingy> which was ported from this working homebaked-yaml grammar: http://github.com/ingydotnet/testml-grammar/blob/1067fed12cd1725ad7f39286b9ba7bf74f8692e2/grammar.yaml

[07:04] <ingy> and turned the original into this: http://github.com/ingydotnet/testml-grammar/blob/master/testml.grammar

[07:04] <ingy> and then reduced it into this 90 line, highly optimized: http://github.com/ingydotnet/testml-grammar/blob/master/grammar.yaml

[07:04] <ingy> which is pcre compatible

[07:04] <sorear> moritz_: should I just put the capture-command in all?

[07:05] <sorear> all: Setting.dll

[07:05] <sorear> \tgit rev-parse HEAD > VERSION

[07:05] <sjohnson> hi

[07:05] <sorear> hello

[07:05] <ingy> well anyway, I gotta sleep

[07:05] <ingy> or drink

[07:06] <ingy> night...

[07:06] <sorear> I look forward to seeing how PCRE handles LTM

[07:06] <sjohnson> hi sorea

[07:06] <sjohnson> r

[07:06] <sjohnson> oops

[07:07] <ingy> sorear: me too :)

[07:07] * ingy grabs a smop

[07:08] <sorear> Are you modifying pcre?

[07:12] <moritz_> sorear: I'd prefer it if you could truncate the git rev-parse output to 6 characters or so

[07:15] <moritz_> http://nopaste.snit.ch/22136 # hacky s:g///

[07:15] *** _mpu left
[07:18] <moritz_> in STD.pm6 line 960, why is there a <circumfix> after a <.sorry> ?

[07:20] *** [particle]1 joined
[07:20] <moritz_> ah, for error recovery, probably

[07:20] *** [particle] left
[07:23] *** baest joined
[07:24] *** _mpu joined
[07:31] <dalek> niecza: a4a0806 | sorear++ | Niecza/Actions.pm:

[07:31] <dalek> niecza: Small refactor of declaration handling

[07:31] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a4a080607bebbcdd47fc9b98d9e5e6b9a4ef1821

[07:31] <dalek> niecza: 1dad6ad | sorear++ | CgOp.pm:

[07:31] <dalek> niecza: Rework CgOp::* to preserve much more structure

[07:31] <dalek> niecza: review: http://github.com/sorear/niecza/commit/1dad6adb30105655ff9724eabf23b5bad5d98892

[07:31] <dalek> niecza: cebf46b | sorear++ |  (2 files):

[07:31] <dalek> niecza: Add a version recorder for moritz

[07:31] <dalek> niecza: review: http://github.com/sorear/niecza/commit/cebf46bf8c230f30bedb4c962ed1aa9cba65373e

[07:36] *** mberends left
[07:39] <moritz_> nqp: $_<v> # just want to see if it parses

[07:39] <p6eval> nqp: OUTPUT¬´Symbol '$_' not predeclared in <anonymous>‚ê§current instr.: 'parrot;PCT;HLLCompiler;panic' pc 152 (compilers/pct/src/PCT/HLLCompiler.pir:109)‚ê§¬ª

[07:39] <moritz_> nqp: my $_; $_<v> # just want to see if it parses

[07:39] <p6eval> nqp: OUTPUT¬´get_pmc_keyed() not implemented in class 'Undef'‚ê§current instr.: '_block11' pc 0 (EVAL_1:11596908)‚ê§¬ª

[07:39] <moritz_> nqp: my $_; ~$_<v> 

[07:39] <p6eval> nqp: OUTPUT¬´get_pmc_keyed() not implemented in class 'Undef'‚ê§current instr.: '_block11' pc 0 (EVAL_1:4)‚ê§¬ª

[07:44] *** [particle]1 left
[07:44] *** [particle] joined
[07:46] *** zulon joined
[07:46] *** meppl joined
[07:54] *** dolmen_ joined
[08:07] <pmichaud> moritz_: ping

[08:07] <pmichaud> locally:

[08:08] <pmichaud> > my regex abc { ... };  say "abc" ~~ / <abc> /;

[08:08] <pmichaud> abc

[08:10] <dalek> book: a366001 | pmichaud++ | src/preface.pod:

[08:10] <dalek> book: It's no longer true that variables aren't preserved in the REPL.

[08:10] <dalek> book: review: http://github.com/perl6/book/commit/a366001c8dcc4c47804cfbbc9ddebb2e5939cc26

[08:10] <dalek> book: 6e6ccf8 | pmichaud++ | src/ (3 files):

[08:10] <dalek> book: Various text improvements.

[08:10] <dalek> book: review: http://github.com/perl6/book/commit/6e6ccf82b2fafb4f42e4ee8ec2a7b7a49fad0295

[08:10] <dalek> book: 9a5a82a | pmichaud++ | docs/review-notes.txt:

[08:10] <dalek> book: Add a place for review-notes and discussion about the text.

[08:10] <dalek> book: review: http://github.com/perl6/book/commit/9a5a82a0aa94ebd641d5b34a0b0f28570200c32d

[08:13] <pmichaud> another long day... time for sleep.

[08:13] <sorear> ugh.  this big codegen refactor is bigger than I thought

[08:13] * sorear puts most of it on hold

[08:13] <Tene> Oh, huh, feeds.  Didn't notice when those went in.

[08:14] <Tene> Looks like they're eager, though.

[08:16] *** Mowah joined
[08:18] <moritz_> pmichaud: pong

[08:18] <moritz_> probably too late

[08:21] *** thebird joined
[08:25] <pmichaud> back

[08:25] <pmichaud> (not too late :)

[08:25] <pmichaud> feeds are eager?  /me wonders why that would be....

[08:27] *** perlygatekeeper1 joined
[08:27] <frettled> pmichaud: that was a proper powernap :)

[08:28] <pmichaud> frettled: no, just hadn't made it to sleep yet.

[08:28] <pmichaud> too busy playing on a few other items.

[08:28] <frettled> :)

[08:28] <moritz_> pmichaud: I wonder how <print> should work...

[08:28] <moritz_> does the lexical lookup check for regex-ness?

[08:29] *** perlygatekeeper left
[08:29] <pmichaud> moritz_: at the moment, no.

[08:29] *** tadzik joined
[08:30] <pmichaud> moritz_: it really can't check for regex-ness (and in some sense it should not check for that)

[08:30] <moritz_> thought so :(

[08:30] <tadzik> hello #perl6

[08:30] * moritz_ wouldn't mind renaming <print> to <printable>

[08:31] <pmichaud> yes, the reason I haven't committed is because of the strong potential for collisions between lexical symbols and grammar regexes

[08:31] <moritz_> pmichaud: push it to a branch for now?

[08:32] <pmichaud> I have it in a local branch.  I can push it, yes.

[08:32] <pmichaud> branch is 'reglex'

[08:32] <dolmen_> rakudo: say (2i..5i).WHAT

[08:32] <moritz_> oh, the pain...

[08:32] <p6eval> rakudo cf3da0: OUTPUT¬´Range()‚ê§¬ª

[08:32] <dolmen_> rakudo: say (2i..5i)

[08:32] <p6eval> rakudo cf3da0: OUTPUT¬´0 + 2i‚ê§¬ª

[08:33] <dolmen_> rakudo: say (2..5)

[08:33] <p6eval> rakudo cf3da0: OUTPUT¬´2345‚ê§¬ª

[08:33] <pmichaud> rakudo:  say (2i).succ

[08:34] <p6eval> rakudo cf3da0: OUTPUT¬´1 + 2i‚ê§¬ª

[08:34] <pmichaud> rakudo:  say (2i).succ after 5i

[08:34] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[08:34] <dolmen_> what is "after"?

[08:34] <moritz_> you can't have a ponie, and eat it :-)

[08:34] <moritz_> dolmen_: a comparison operator

[08:34] <pmichaud> after returns true if the lhs logically succeeds the rhs

[08:35] <pmichaud> rakudo:  say   "a" after "z"

[08:35] <p6eval> rakudo cf3da0: OUTPUT¬´0‚ê§¬ª

[08:35] <moritz_> rakudo: say 3 after 1

[08:35] <dolmen_> rakudo: say (2i.succ) after 2i

[08:35] <pmichaud> unlike > or gt, it doesn't do a type coercion on its arguments

[08:35] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[08:35] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[08:36] <dolmen_> rakudo: say "3" after 2

[08:36] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[08:36] <dolmen_> should fail, isn't it?

[08:36] <moritz_> nope

[08:36] <moritz_> it's magic.

[08:36] <pmichaud> rakudo:  say "b" after 2

[08:36] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[08:36] <pmichaud> rakudo:  say 2 after "b"

[08:37] <p6eval> rakudo cf3da0: OUTPUT¬´0‚ê§¬ª

[08:37] <dolmen_> "type coercion" is magic. No type coercion means no magic, isn't it?

[08:37] <pmichaud> dolmen_: I'd accept that it should fail, yes.  Or there's also an interpretation that say that after (and cmp) fall back to stringish semantics

[08:37] <moritz_> I guess in the case of string and number, it coerces the number to Str, and then compares

[08:38] <pmichaud> rakudo:   say "03" after 2

[08:38] <p6eval> rakudo cf3da0: OUTPUT¬´0‚ê§¬ª

[08:38] <pmichaud> looks like it's falling back to str comparision

[08:38] <pmichaud> *comparison

[08:39] <dolmen_> rakudo: say (2i..0)

[08:39] <p6eval> rakudo cf3da0: OUTPUT¬´‚ê§¬ª

[08:39] <dolmen_> rakudo: say (1..0)

[08:40] <p6eval> rakudo cf3da0: OUTPUT¬´‚ê§¬ª

[08:40] <dolmen_> rakudo: say (2i..0).elems

[08:40] <p6eval> rakudo cf3da0: OUTPUT¬´0‚ê§¬ª

[08:41] <pmichaud> okay, I'm really off to sleep this time.

[08:41] <pmichaud> bbl

[08:41] <dolmen_> good night

[08:41] <moritz_> \o night

[08:41] <dolmen_> rakudo: say 2i.WHAT

[08:41] <p6eval> rakudo cf3da0: OUTPUT¬´Complex()‚ê§¬ª

[08:41] <dolmen_> rakudo: say Complex ~~ Num

[08:42] <p6eval> rakudo cf3da0: OUTPUT¬´0‚ê§¬ª

[08:42] <dolmen_> rakudo: say Complex ~~ Numeric

[08:42] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[08:43] <dolmen_> rakudo: say Rat.new(3i, -5i)

[08:43] <p6eval> rakudo cf3da0: OUTPUT¬´too many positional arguments: 3 passed, 1 expected‚ê§  in main program body at line 22:/tmp/TBqNYMu3aY‚ê§¬ª

[08:43] <dolmen_> rakudo: say 1i*Rat.new(3, -5)

[08:43] <p6eval> rakudo cf3da0: OUTPUT¬´0 + -0.6i‚ê§¬ª

[08:45] <dolmen_> rakudo: say Rat.new(3, -5i)

[08:45] <p6eval> rakudo cf3da0: OUTPUT¬´too many positional arguments: 3 passed, 1 expected‚ê§  in main program body at line 22:/tmp/0eZVwaQL6q‚ê§¬ª

[08:46] <dolmen_> rakudo: say 1i+Rat.new

[08:46] <p6eval> rakudo cf3da0: OUTPUT¬´0 + 1i‚ê§¬ª

[08:47] <dolmen_> rakudo: say (3+2i..4).elems

[08:47] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[08:48] <dolmen_> rakudo: say (3+2i..4).perl

[08:48] <p6eval> rakudo cf3da0: OUTPUT¬´Complex.new(3, 2)..4‚ê§¬ª

[08:48] <dolmen_> rakudo: say (3+2i..4)

[08:48] <p6eval> rakudo cf3da0: OUTPUT¬´3 + 2i‚ê§¬ª

[08:48] <dolmen_> rakudo: say (3+2i..5+5i)

[08:48] <p6eval> rakudo cf3da0: OUTPUT¬´3 + 2i4 + 2i5 + 2i‚ê§¬ª

[08:49] <dolmen_> rakudo: say (.)

[08:49] <dolmen_> rakudo: say (3.1..5.5)

[08:49] <p6eval> rakudo cf3da0: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22‚ê§¬ª

[08:49] <p6eval> rakudo cf3da0: OUTPUT¬´3.14.15.1‚ê§¬ª

[08:50] <dolmen_> rakudo: say (3+2i..5+1i)

[08:51] <p6eval> rakudo cf3da0: OUTPUT¬´3 + 2i4 + 2i‚ê§¬ª

[08:51] <dolmen_> rakudo: say (3+2i..^5+2i)

[08:51] <p6eval> rakudo cf3da0: OUTPUT¬´3 + 2i4 + 2i‚ê§¬ª

[08:54] <dolmen_> rakudo: say (3+2i).WHY

[08:54] <p6eval> rakudo cf3da0: OUTPUT¬´Method 'WHY' not found for invocant of class 'Complex'‚ê§  in main program body at line 22:/tmp/gOA4WP5IPV‚ê§¬ª

[08:54] <dolmen_> rakudo: say (3).WHY

[08:54] <p6eval> rakudo cf3da0: OUTPUT¬´Method 'WHY' not found for invocant of class 'Int'‚ê§  in main program body at line 22:/tmp/JqE9yoU7_4‚ê§¬ª

[08:56] <dolmen_> rakudo: say (3+2i).^methods()

[08:56] <p6eval> rakudo cf3da0:

[08:56] <p6eval> ..OUTPUT¬´imabsacosechrealsceilingunpolarfloorasechRatroundacosecacoshNumcosechcotanatan2repolartanRealatancosacosnewtanhNumericperlStracotanhfrom-radiansACCEPTSpredatanhcosecexpto-radianssinhacotanrootsComplexlnsecaseccotanhcislogsechlog10randtruncatesinsqrtIntasinBoolcoshsuccsignasinhabsac‚Ä¶

[08:57] <dolmen_> rakudo: say (3+2i).^methods().join(',')

[08:58] <p6eval> rakudo cf3da0:

[08:58] <p6eval> ..OUTPUT¬´Str,acotanh,from-radians,ACCEPTS,pred,atanh,exp,cosec,to-radians,sinh,acotan,roots,Complex,ln,sec,asec,cotanh,cis,log,log10,sech,rand,truncate,sqrt,sin,Int,asin,Bool,cosh,succ,sign,asinh,im,acosech,abs,reals,ceiling,unpolar,floor,asech,Rat,round,acosh,acosec,Num,cotan,cosech,atan2,‚Ä¶

[08:59] <dolmen_> rakudo: say (3+2i).im

[08:59] <p6eval> rakudo cf3da0: OUTPUT¬´2‚ê§¬ª

[08:59] <dolmen_> rakudo: say (3+2i).im.WHAT

[08:59] <p6eval> rakudo cf3da0: OUTPUT¬´Int()‚ê§¬ª

[08:59] <dolmen_> rakudo: say (3+2.0i).im.WHAT

[09:00] <p6eval> rakudo cf3da0: OUTPUT¬´Rat()‚ê§¬ª

[09:00] <dolmen_> rakudo: say (3+2.3i).im.WHAT

[09:00] <p6eval> rakudo cf3da0: OUTPUT¬´Rat()‚ê§¬ª

[09:00] <dolmen_> rakudo: say (3+2.3i).im

[09:01] <p6eval> rakudo cf3da0: OUTPUT¬´2.3‚ê§¬ª

[09:01] <dolmen_> rakudo: say (3+2.3i).im.denominator

[09:01] <p6eval> rakudo cf3da0: OUTPUT¬´10‚ê§¬ª

[09:02] <dolmen_> rakudo: say (2.3+2.3i).real.WHAT

[09:02] <p6eval> rakudo cf3da0: OUTPUT¬´Method 'real' not found for invocant of class 'Complex'‚ê§  in main program body at line 22:/tmp/bJt0QPCU1c‚ê§¬ª

[09:02] <moritz_> .re

[09:02] *** au|afk is now known as au|irc

[09:02] <dolmen_> rakudo: say (2.3+2.3i).re.WHAT

[09:02] <p6eval> rakudo cf3da0: OUTPUT¬´Rat()‚ê§¬ª

[09:02] <au|irc> \o

[09:02] <sorear> hmm.

[09:02] <moritz_> o/

[09:02] <sorear> Hi au|irc !

[09:03] <au|irc> greetings :)

[09:03] <dolmen_> \o/

[09:03] <sorear> it looks like implementing Iterator in Perl 6 is not going to work very well

[09:03] <sorear> because $!value doesn't remember the flatness bit

[09:03] <au|irc> going into .cs level then?

[09:04] <frettled> au|irc: o/~   - nice bugrep

[09:04] <au|irc> thank you :) I tried golfing it...

[09:04] <tylercurtis> good night, #perl6.

[09:05] *** tylercurtis left
[09:06] <sorear> Or I'll just try handling flat-bits out of band

[09:06] * moritz_ has a not-so-hacky-anymore patch for s:g///

[09:07] <au|irc> sorear: out of band, as in...?

[09:08] <sorear> au|irc: in a separate array

[09:08] <sorear> but I think I can hack this into working

[09:08] <au|irc> looking forward to the commit then :D

[09:08] * au|irc continues translating masak++'s blogpost, part 2 of 5...

[09:09] <sorear> well.  I already have Iterator, I'm trying to implement a form of map

[09:09] <sorear> getting the sub-parcels to properly flatten is a little tricky

[09:09] <dolmen_> rakudo: say (2.3+2.3i).^methods()[0].do.perl

[09:09] <p6eval> rakudo cf3da0: OUTPUT¬´{ ... }‚ê§¬ª

[09:09] <sorear> because of the CPS conversion, the impedence mismatch between C# and Perl 6 is rather large

[09:09] <moritz_> dolmen_: .() for invoking, not do()

[09:10] <sorear> my choices are C# (have to do manual CPS, and cannot access CORE:: lexicals without dependency injection)

[09:11] <sorear> Perl 6 (no direct access to CLR facilities like raw arrays, hard to do low-level introspection of values)

[09:11] <sorear> Q:CgOp (easy access to CLR features, with automatic CPS and lexical scoping, but the syntax is awful)

[09:12] <au|irc> uh, there wasn't much syntax to start with :)

[09:12] * dolmen_ realizes that au|irc is Audrey...

[09:12] * au|irc confirms the realization

[09:12] <sorear> I'm firmly with TimToady on the "oatmeal with fingernail clippings mixed in" view of sexp languages

[09:13] <sorear> they are, however, very expedient

[09:13] * moritz_ pushed the subst_adverbs branch

[09:13] <dolmen_> moritz_: I wanted the source code of the method. This is what I got, as far as it is possible : { ... }

[09:13] <au|irc> it's slightly better if you allow ({[ and ]}) as synonyms, but yeah.

[09:14] <arnsholt> pmichaud++ # Fixing classes-with-Q-bug

[09:14] <moritz_> dolmen_: yes, deparsing (or storing source code) is NYI

[09:14] <arnsholt> Now Prolog looks like it parses the really perverted forms of Prolog as well =D

[09:14] <sorear> The biggest upshot of switching from RPN to sexps is that I can use % in vim now

[09:15] *** zulon left
[09:15] <arnsholt> That sounds like a non-negligeable benefit =)

[09:17] <moritz_> can I use a PAST tree inside the :value of a PAST::Val?

[09:18] <moritz_> std: s:nth[1, 2, 3]/a/b/

[09:18] <p6eval> std 31772: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter , (must be quoted to match literally) at /tmp/pfKqqYdWHn line 1:‚ê§------> [32ms:nth[1,[33m‚èè[31m 2, 3]/a/b/[0m‚ê§Couldn't find terminator ] at /tmp/pfKqqYdWHn line 1:‚ê§------> [32ms:nth[1,[33m‚èè[31m 2,

[09:18] <p6eval> ..3]/a/b/[0m‚ê§Par‚Ä¶

[09:19] <moritz_> std: s:nth(1, 2, 3)/a/b/

[09:19] <p6eval> std 31772: OUTPUT¬´ok 00:03 118m‚ê§¬ª

[09:19] <moritz_> looks LTA to me

[09:23] *** lue left
[09:23] *** lue joined
[09:25] <au|irc> sorear: R6RS defines [...] to be equiv forms of (...). Would you find a change to cgexp:op that allow (prog [...] [...] [...]) to improve ergonomics, and making writing Iterators in CgOp a tiny bit easier? :)

[09:26] <sorear> Yes

[09:26] <au|irc> on it.

[09:28] <moritz_> jnthn, pmichaud: in the subst_adverbs branch, s:g/o/u/ works. However passing arguments to adverbs (like :g(1)) gives "undefined identifier 'Capture'" - any idea what might be wrong?

[09:29] *** dakkar joined
[09:30] <frettled> Woohoo, parser confusion.

[09:31] *** snarkyboojum joined
[09:33] <dalek> niecza: e538c83 | sorear++ | CgOp.pm:

[09:33] <dalek> niecza: Start drafting a CgOp-level CPS converter

[09:33] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e538c834e12339b56cc2f3ed9f0de1f15f90cf58

[09:33] <dalek> niecza: c9d4a66 | sorear++ |  (2 files):

[09:33] <dalek> niecza: Add Mu.RAWCREATE

[09:33] <dalek> niecza: This is a bit of a crutch until has / BUILD is added, and will be useful

[09:33] <dalek> niecza: anyways for thawing procedutres.  Also stub Decl::Regex.

[09:33] <dalek> niecza: review: http://github.com/sorear/niecza/commit/c9d4a66017eb9c5c33fc190a04d3514d98ca264f

[09:42] *** xabbu42 joined
[09:46] *** kazoo joined
[09:46] <au|irc> sorear: alright, it's in. not yet checked for proper circumfix balancing but works :)

[09:47] <sorear> excellent

[09:48] *** telling2 joined
[09:48] * au|irc finds ":setf lisp" to be great when hacking CgOp

[09:49] *** telling2 left
[09:51] <dalek> niecza: f98b0b1 | au++ |  (2 files):

[09:51] <dalek> niecza: * Grammar: Allow [] in CgOp as synonym forms for ().

[09:51] <dalek> niecza: * settings: Rewrite (prog (...) (...)) forms into (prog [...] [...]) for 

[09:51] <dalek> niecza: readability.

[09:51] <dalek> niecza: review: http://github.com/sorear/niecza/commit/f98b0b178371088f252f2f3697426ba145d0d929

[09:51] <dalek> niecza: 0fd7044 | au++ | setting:

[09:51] <dalek> niecza: * Also bracketify the prog args in c9d4a66.

[09:51] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0fd704427e0894fb654d3d4e532629cafb0c7eda

[09:57] <dalek> niecza: 0fb98a0 | sorear++ | setting:

[09:57] <dalek> niecza: Implement List.iterator

[09:57] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0fb98a0599b081db6b22132eebd24bb2c55d49fb

[09:57] <dalek> niecza: 63ae8f5 | sorear++ | rxwork.pl:

[09:57] <dalek> niecza: First draft of the regex engine

[09:58] <dalek> niecza: review: http://github.com/sorear/niecza/commit/63ae8f547726a85c39df28cb5196ef774ca78bcc

[09:59] <sorear> au|irc: so, what are you trying to do with niecza?

[09:59] <au|irc> nothing, really :)

[09:59] <au|irc> I've never coded C# before

[09:59] <au|irc> so this is mostly for learning

[09:59] <au|irc> (I did code some F#, so that helps)

[10:00] *** agentzh left
[10:00] <sorear> it's a lot nicer than I expected it would be

[10:01] <au|irc> yeah. erik (meijer) was justifiably proud of it (the post-LINQ incarnation, that is)

[10:01] <sorear> rakudo: "foo".substr(1,1)

[10:01] <sorear> rakudo: "foo".substr(1,1).say

[10:01] <p6eval> rakudo cf3da0:  ( no output )

[10:01] <p6eval> rakudo cf3da0: OUTPUT¬´o‚ê§¬ª

[10:09] *** kazoo left
[10:16] <dalek> niecza: 69370b6 | sorear++ |  (3 files):

[10:16] <dalek> niecza: Implement Str.chars and Str.substr

[10:16] <dalek> niecza: review: http://github.com/sorear/niecza/commit/69370b6d5e600eaa16e808321005d69a012fe225

[10:16] <dalek> niecza: 90ad541 | sorear++ | rxwork.pl:

[10:16] <dalek> niecza: Draft the rest of the regex primitives needed here

[10:16] <dalek> niecza: review: http://github.com/sorear/niecza/commit/90ad541aee0db55b32e0299f060919d6dacf542e

[10:17] <au|irc> sorear: so I'm filling in the "..." for Op::Yada::code; it reads

[10:17] <au|irc>         CgOp::subcall(CgOp::fetch(CgOp::scopedlex("&warn")), CgOp::clr_string(">>>Stub code executed<<<"));

[10:17] <au|irc> but it compiles to

[10:17] <au|irc>                 return ((IP6)s0).Invoke(th, new LValue[1] { ((System.String)s1).lv }, null);

[10:17] <au|irc> and of course strings can't be LVs

[10:17] <au|irc> maybe I'm missing a RV hint somewhere, or is that a misuse of ::subcall?

[10:18] <au|irc> ah nvm

[10:18] <au|irc> wrong boxing level

[10:18] <au|irc> ::string_var works

[10:19] <sorear> yeah.  you hit it.

[10:19] <au|irc> warn($), exit() and "..." are in.

[10:22] <dalek> niecza: 6fd3e0b | au++ |  (3 files):

[10:22] <dalek> niecza: * Implement warn($), exit(), and the "..." term.

[10:22] <dalek> niecza: review: http://github.com/sorear/niecza/commit/6fd3e0ba01645cb72747a2a1b215ade7f5182081

[10:22] <dalek> niecza: 29b9da5 | au++ |  (2 files):

[10:22] <dalek> niecza: * A bit more bracketification for (prog []) on rxwork.pl and setting.

[10:22] <dalek> niecza: review: http://github.com/sorear/niecza/commit/29b9da555edaace804cfd768ccf49dff9aadf790

[10:26] <au|irc> sorear: btw, is there an aesthetic reason that the .pm files are using Moose instead of MooseX::Declare? :)

[10:27] <sorear> no

[10:28] <dalek> niecza: e06200c | sorear++ | setting:

[10:28] <dalek> niecza: Implement Parcel & Nil

[10:28] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e06200cd111887a233852220e6543b33fed3bf50

[10:31] *** azert0x joined
[10:32] <sorear> argh.  I forgot to compile that last one

[10:32] * sorear is about to push a fix

[10:33] <sorear> this 15,000 line Setting.cs is making me want to increase priority of the code generation refactor

[10:34] <dalek> niecza: b6fa476 | sorear++ | setting:

[10:34] <dalek> niecza: Implement Parcel.iterator & fix build

[10:34] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b6fa4764c8c163eab599addcc30c0a401b93a383

[10:35] <au|irc> alright. MooseX::Declare'ifying Op.pm is pushed too

[10:35] <sorear> how big is the load time penalty?

[10:36] <au|irc> 0.7s

[10:36] <au|irc> only pays once, though, not x .pm

[10:37] <wolverian> au|irc: I like your "irc" suffix. is it to remind you you're on irc? :)

[10:37] <au|irc> well, it's a carryover from irc.socialtext.net

[10:38] <au|irc> where we all use |afk |irc |brb etc

[10:38] <au|irc> it's a makeshift emulation of IM's presence protocol for IRC :)

[10:38] <wolverian> "I require conversation"

[10:38] <wolverian> right. 

[10:38] <au|irc> nice association!

[10:38] <mathw> Conversation you can have

[10:39] <mathw> Please select a language

[10:40] <dalek> niecza: 12fb896 | au++ |  (2 files):

[10:40] <dalek> niecza: * Op.pm is now using MooseX::Declare syntax.

[10:40] <dalek> niecza: review: http://github.com/sorear/niecza/commit/12fb896e2a5a41712d595b685986082b1547c55e

[10:41] *** zulon joined
[10:41] *** colomon joined
[10:42] <rokoteko> so how does perl6 fit scientific (where I mean math) computation? 

[10:43] <daxim> Rats are built-in, which is *sane*

[10:43] <rokoteko> well irrats builtin would be *sane* but not easily achieved. ;)

[10:44] <rokoteko> anyhow. ++ for rats :)

[10:44] <rokoteko> how about, let's say power series? that's somehing computers would be useful for.

[10:45] <rokoteko> lazy evalution is something Im waiting for to handle power series.

[10:45] <daxim> pugs: (6/55*17/8).perl

[10:45] <p6eval> pugs:  ( no output )

[10:45] <daxim> rakudo: (6/55*17/8).perl

[10:46] <p6eval> rakudo cf3da0:  ( no output )

[10:46] <daxim> pugs: say (6/55*17/8).perl

[10:46] <p6eval> pugs: OUTPUT¬´51/220‚ê§¬ª

[10:46] <daxim> aha.

[10:48] <rokoteko> are e, pi and i builtins?

[10:48] <colomon> yes

[10:48] <colomon> well, maybe not i at the moment.

[10:48] <colomon> rakudo: say i

[10:48] <p6eval> rakudo cf3da0: OUTPUT¬´Could not find sub &i‚ê§  in main program body at line 22:/tmp/DJ15Fo0yF0‚ê§¬ª

[10:49] <colomon> rakudo: say 1i

[10:49] <p6eval> rakudo cf3da0: OUTPUT¬´0 + 1i‚ê§¬ª

[10:49] <colomon> rakudo: say e, pi

[10:49] <p6eval> rakudo cf3da0: OUTPUT¬´2.718281828459053.14159265358979‚ê§¬ª

[10:50] <daxim> rakudo: say 1i.perl

[10:50] <p6eval> rakudo cf3da0: OUTPUT¬´Complex.new(0, 1)‚ê§¬ª

[10:50] <rokoteko> eval: ln(0+1i)

[10:50] <colomon> rakudo: say ln(1i)

[10:50] <daxim> prefix with one of the p6 implementation names

[10:51] <p6eval> rakudo cf3da0: OUTPUT¬´Could not find sub &ln‚ê§  in main program body at line 22:/tmp/On_AC5ge3Q‚ê§¬ª

[10:51] <colomon> oh, right

[10:51] <colomon> rakudo: say log(1i)

[10:51] <p6eval> rakudo cf3da0: OUTPUT¬´0 + 1.5707963267949i‚ê§¬ª

[10:52] <rokoteko> eval: say log(e^(i*pi)), log(pi)

[10:52] <dalek> niecza: efce6ed | au++ | CodeGen.pm:

[10:52] <dalek> niecza: * CodeGen.pm is now in MooseX::Declare syntax.

[10:52] <dalek> niecza: review: http://github.com/sorear/niecza/commit/efce6eda26395926236caab6715a8a2c974d8a5e

[10:52] <colomon> what do you want to do with lazy eval and power series?

[10:53] <rokoteko> colomon: so that I can define a power series and evaluate to as much precision I like without the interpreter choking. why are you asking?

[10:54] <colomon> well, it's an interesting issue to me, and what you want is probably trivially possible with current rakudo.

[10:54] <daxim> you mean by explicit programming, loop until epsilon is small enough?

[10:54] <rokoteko> Can you do an eval example for me, let's say with sin() power series that is lazy?

[10:55] <daxim> also, when did rakudo get laziness?  I didn't notice

[10:55] <rokoteko> daxim: no, Im not meaning a while loop with last inside.

[10:55] <colomon> daxim: months ago.

[10:56] <colomon> hmmm.

[10:58] <dalek> niecza: 4dc75bb | au++ |  (3 files):

[10:58] <dalek> niecza: * Body.pm, CgOp.pm and Decl.pm are now in MooseX::Declare syntax.

[10:58] <dalek> niecza: * Fix a tiny bug: Decl::Class now extends Decl.

[10:58] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4dc75bb3cbbf5bbece3dd779afa2c3cebf210b9f

[10:59] <rokoteko> colomon: something like "take 20 power_series_expansion", which takes the first 20 members of the power series in question

[10:59] <tadzik> rakudo: my $sq = gather for 0..Inf { take $_ * $_ }; $sq[3].say

[10:59] <p6eval> rakudo cf3da0: OUTPUT¬´9‚ê§¬ª

[11:00] <colomon> rakudo: sub sine-power($x) { gather for 1, 3 ... * -> $n { $x ** $n / [*] (1 ... $n) }; }; say sine-power(0.1).munch(10).perl

[11:00] <tadzik> now when I leave it without say, REPL hangs. Why?

[11:00] <p6eval> rakudo cf3da0:  ( no output )

[11:01] <colomon> tadzik: because it's trying to evaluate the entire infinite series internally

[11:01] <tadzik> ah, to print the result, right

[11:01] <colomon> rakudo: sub sine-power($x) { gather for 1, 3 ... * -> $n { $x ** $n / [*] (1 ... $n) }; }; say sine-power(0.1).munch(2).perl

[11:01] *** ruoso left
[11:01] *** tyru left
[11:01] <p6eval> rakudo cf3da0:  ( no output )

[11:01] <colomon> hmmm.

[11:02] <colomon> oh, duh

[11:02] <colomon> rakudo: sub sine-power($x) { gather for 1, 3 ... * -> $n { take $x ** $n / [*] (1 ... $n) }; }; say sine-power(0.1).munch(2).perl

[11:02] <p6eval> rakudo cf3da0: OUTPUT¬´(0.1, 0.000166666666666667)‚ê§¬ª

[11:02] <rokoteko> is munch anti-eager?

[11:03] <rokoteko> colomon: very nice thank you. I suppose that is correct. :)

[11:03] <colomon> rokoteko: munch(N) shifts the first N items off a list

[11:03] <colomon> rokoteko: well, it's not completely right, because I left off the sign

[11:03] *** ruoso joined
[11:03] *** tyru joined
[11:03] <rokoteko> that sounds like that the complete list has to be built first?

[11:04] <colomon> but 

[11:04] <colomon> rakudo: say (0.1 * 0.1 * 0.1) / 6

[11:04] <p6eval> rakudo cf3da0: OUTPUT¬´0.000166666666666667‚ê§¬ª

[11:04] <colomon> rokoteko: if it's lazy, certainly not

[11:05] <dalek> niecza: f4ddde8 | au++ |  (3 files):

[11:05] <dalek> niecza: * Convert RxOp, Sig and Unit to MooseX::Declare. That's all of them. :-)

[11:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/f4ddde8e73835aeed9e7f2bd747a70ca6b56f5d5

[11:05] <rokoteko> Ok, brilliant. Ive been wondering if perl6 would be a good language to learn first. Ive been studying Haskell for a year, be perl is more practical. and I have a relatively strong perl5 background, so it's like ... well, what's the word in English.

[11:05] <tadzik> ‚Ä¶awesome? :)

[11:06] <au|irc> a perfect fit? :)

[11:06] <colomon> rakudo: sub sine-power($x) { my $sign = 1; gather for 1, 3 ... * -> $n { take $sign * $x ** $n / [*] (1 ... $n); $sign *= -1; }; }; say sine-power(0.1).munch(4).perl

[11:06] <rokoteko> perfect fit is good. I was thinking in the lines of "obvious" :)

[11:06] <p6eval> rakudo cf3da0: OUTPUT¬´(0.1, -0.000166666666666667, 8.33333333333334e-08, -1.98412698412698e-11)‚ê§¬ª

[11:08] <rokoteko> and also Timtoady impresses me. Ever since I read his talk (I think it was the second state of the onion) that mentioned the similarity between triangles and circles. That is a subject that truly fascinates me.

[11:09] <daxim> http://www.perl.com/pub/a/1998/08/show/onion.html

[11:09] <rokoteko> Using power series I hope that I can get a wider knowledge on the subject. :) As computers have rounding errors with irrationals, then I can decide how long they compute.

[11:10] <rokoteko> daxim: nods, thats the talk. "To wrap up, I'd like to talk about triangles. Here's a sample."

[11:11] <sorear> subtraction appears to be doing something insane.

[11:12] <mathw> sorear: that would be worrying

[11:13] <colomon> sorear: hope that's in niecza and not rakudo...

[11:13] <au|irc> niecza -e 'say 1-2' #worksforme...

[11:13] *** lestrrat is now known as lest_away

[11:13] <rokoteko> au|irc: in the power series I think he meant. :)

[11:13] <au|irc> ahh. certainly :)

[11:13] <sorear> no

[11:14] <sorear> 0 - 1 = 0

[11:14] <colomon> rokoteko: in practical terms, however, rakudo doesn't currently have a way of dealing with numbers more precisely than floating point.

[11:14] <sorear> but it doesn't happen when I golf it

[11:14] <sorear> only in the middle of Parcel.iterator

[11:14] <au|irc> is it somehow using uint? #wildguess

[11:15] <sorear> no

[11:15] <sorear> I just found it

[11:15] <au|irc> whee :)

[11:15] <sorear> my $ix = $ll.elems - 1;

[11:15] <sorear> this parses as:

[11:15] <sorear> (my $ix = $ll.elems) - 1;

[11:15] <au|irc> (my $ix = $ll.elems) -1

[11:15] <sorear> in the setting

[11:15] <au|irc> *nod*

[11:16] <sorear> because the earlier mention of sub infix:<=> causes STD to forget its builtin knowledge of =

[11:16] <sorear> and override it with a left-associative additive-prec op

[11:17] <rokoteko> colomon: ok, great. Maybe I should concentrate my studied on perl6 then. perl5 is just so great and it has a lot of practical uses also.

[11:18] <sorear> ok I have the build fixed , pushing

[11:19] <rokoteko> merely, about the math, Im interested about why circles have pi as in the ratio of radius the circumference and triangle has the pi as the sum of angles. Ive been studying hyperbolic geometry, complex analysis, topology and what all about this drives me forwards is currently trying to understand Atiyah-Singer theorem.

[11:20] <rokoteko> it would be nice to have some easy-to-use (ok, perl *is* complex) computing power at use to test thing out.

[11:21] <au|irc> easy-to-use + complex = manipulexity :) #youCanHaveBoth

[11:22] <rokoteko> # CamelCaseBoth or camel_case_both

[11:22] <colomon> rokoteko: I should warn you that Rakudo currently has a bug which will make dealing with more than one power series at once very tricky.  basically, you cannot have two infinite generators going from the same code at the same time.  

[11:23] <colomon> so I should be able to say something like

[11:23] *** i__ joined
[11:23] <dalek> niecza: 50423d2 | sorear++ | test.pl:

[11:23] <dalek> niecza: Tests for Parcel (todo)

[11:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/50423d200be97ccb3e51c8f5da4afc8f58aa49ba

[11:23] <dalek> niecza: bfb226a | sorear++ | setting:

[11:23] <dalek> niecza: Two small bugfixes, Parcel is still not quite working

[11:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/bfb226adf3e126ee743f1710abf2498f62230855

[11:23] <dalek> niecza: bd00700 | sorear++ | Kernel.cs:

[11:23] <dalek> niecza: Disable p6exceptions until they are properly fixed

[11:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/bd00700dc9e8d62c3690e9e8d13f0a0c485b4f72

[11:23] <dalek> niecza: 1789938 | sorear++ | Niecza/Actions.pm:

[11:23] <dalek> niecza: Implement my @x := foo syntax

[11:23] <dalek> niecza: review: http://github.com/sorear/niecza/commit/1789938ccd2f853865c31d92017cb6252ab3f9b7

[11:23] <rokoteko> colomon: ok. but it should be fixed relatively soon?

[11:23] <colomon> rakudo: sub sine-power($x) { my $sign = 1; gather for 1, 3 ... * -> $n { take $sign * $x ** $n / [*] (1 ... $n); $sign *= -1; }; }; say (sine-power(0.1) Z+ sine-power(0.2)).munch(4).perl

[11:23] <p6eval> rakudo cf3da0: OUTPUT¬´(0.4, 0, 0, 0)‚ê§¬ª

[11:24] <colomon> and you can easily see that's not right.

[11:24] <colomon> rokoteko: I've been pressing to get it fixed for several months now, but it seems to be tricky.

[11:26] <au|irc> sorear: hrm, I spoke too soon. converting the method arguments into MooseX::Declare imposes a type/signature checking penalty, and on a full "make test" run it slowed things down... (7s vs 18s) 

[11:27] <sorear> Aww :(

[11:27] <au|irc> can revert if you'd like; it's a tradeoff between coding time and dev/compile turnaround time I guess :)

[11:27] *** Lorn left
[11:27] <sorear> I think I would prefer it; turnaround time is rather a problem

[11:27] <rokoteko> colomon: Z is a zip-operator?

[11:28] *** paul1234 joined
[11:28] <colomon> rokoteko: yes

[11:28] <rokoteko> something Ive missed in perl5 core also :)

[11:28] <colomon> so Z+ lazily adds two (potentially infinite) lazy lists

[11:28] <au|irc> sorear: ok, reverted :)

[11:28] *** snarkyboojum left
[11:29] <dalek> niecza: 2a2ae2d | au++ |  (3 files):

[11:29] <dalek> niecza: Revert "* Convert RxOp, Sig and Unit to MooseX::Declare. That's all of them. 

[11:29] <dalek> niecza: :-)"

[11:29] <dalek> niecza: This reverts commit f4ddde8e73835aeed9e7f2bd747a70ca6b56f5d5.

[11:29] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2a2ae2dc8a97198b6b99539d2aba2c552917f545

[11:29] <dalek> niecza: 58c7a4a | au++ |  (3 files):

[11:29] <dalek> niecza: Revert "* Body.pm, CgOp.pm and Decl.pm are now in MooseX::Declare syntax."

[11:29] <dalek> niecza: This reverts commit 4dc75bb3cbbf5bbece3dd779afa2c3cebf210b9f.

[11:29] <dalek> niecza: review: http://github.com/sorear/niecza/commit/58c7a4ad1972c5ff43de0c67c21bc8e2574940b3

[11:29] <dalek> niecza: 39786c2 | au++ |  (2 files):

[11:29] <dalek> niecza: Revert "* Op.pm is now using MooseX::Declare syntax."

[11:29] <dalek> niecza: This reverts commit 12fb896e2a5a41712d595b685986082b1547c55e.

[11:29] <dalek> niecza: review: http://github.com/sorear/niecza/commit/39786c208d395fa3b81fff760d1ad0777ce46b18

[11:29] <dalek> niecza: 65fe5e9 | au++ | CodeGen.pm:

[11:29] *** zulon left
[11:30] <rokoteko> so you think someone has found the attempts to understand perl5 interpreter code impossible to understand could do something with perl6 to help it get finally released?

[11:31] <colomon> rokoteko: absolutely

[11:31] <colomon> well, maybe not a ton for the R* release next week.  :)

[11:32] <moritz_> rokoteko: most of us have no deep knowledge of p5 guts, if at all

[11:33] <moritz_> rokoteko: question is, what do you want to do? write modules? compiler? documentation?

[11:33] <colomon> though even then, a good short but useful module could be written in the next week and make it into the release.  and that would be entirely working in p6 itself, no compiler guts required

[11:33] <au|irc> sorear: alright, I think I grokked niecza :) many thanks for handholding me through! hopefully I didn't abuse my commit bit too much...

[11:34] <rokoteko> modules, interpreter, documentatio for the stuff Ive written of course. :) I know some of perl5 guts, as in I have some knowledge of http://cpansearch.perl.org/src/RURBAN/illguts-0.21/index.html

[11:34] * au|irc waves and returns to dinner, then translation, then a repaired MacBookPro and then $dayJobAtApple :)

[11:34] *** au|irc is now known as au|afk

[11:35] <rokoteko> moritz_: of course I wish some of the "fun" stuff, as in I enjoy programming perl. I find it fun. :)

[11:35] <moritz_> rokoteko: I've started with a Perl 6 port of CGI::Application, where you can contribute if you want

[11:35] <tadzik> moritz_: are Acme::* modules worth including in proto?

[11:36] <rokoteko> au|afk: bye :) Hope you enjoy your forbidden fruit :)

[11:36] <moritz_> tadzik: yes

[11:36] <tadzik> moritz_: I've ported Acme::Meow :) http://github.com/tadzik/Acme-Meow-perl6

[11:36] <rokoteko> moritz_: ah! that's more interesting than catalyst stuff definitely :)

[11:37] <moritz_> tadzik: btw most Perl 6 modules on github put the perl6- in front... but it's not necessary

[11:37] <rokoteko> Ive started to dislike the usual MVC design. That happened while I was programming Java for a while.

[11:37] <tadzik> moritz_: well, I wasn't sure how it should be named

[11:37] *** synth joined
[11:37] <moritz_> rokoteko: http://github.com/moritz/CGI-Application do you have github ID?

[11:37] <rokoteko> moritz_: so most of "you" arent perl5 people?

[11:38] <colomon> here's a better version of the sine series: http://gist.github.com/482850

[11:38] <moritz_> rokoteko: most of us can use perl 5, but don't hack the guts

[11:38] <colomon> rokoteko: I've used perl5 a bunch, but I've never even looked inside the source for it.

[11:38] <rokoteko> No, maybe I should. I just set up a git server at work and I kinda liked it.

[11:39] <rokoteko> moritz_: Ill take a look at your project. It well take awhile to take know the syntax but Id be more than happy to help. :)

[11:39] <rokoteko> or "just set up" is like couple weeks ago, Ive been enjoying my holidays ever since. :)

[11:40] <rokoteko> last nice I dreamt of programming perl, so I guess I kinda fond of it! :)

[11:40] <rokoteko> s/nice/night/

[11:40] <moritz_> rokoteko: when you've got a github id, just tell me the name, then I can add you as a committer. Most Perl 6 projects are very liberal wrt commit bits :-)

[11:40] <colomon> hmmm, I dreamt of playing football (US) again.

[11:42] <rokoteko> moritz_: ok. Ill contact you then. Ill try to get to know a bit of your project first. Ive mainly been programming in-house projects that also have 5-15 year-old in-house web frameworks. :)

[11:43] <sorear> 1, (2, 3), ((4, 5), (Nil, 7)) --> 132Parcel()<instance>Parcel()<instance>

[11:43] <sorear> parcel flattening is nearly here

[11:43] <rokoteko> but it's kind of fascinating also, to see how people have thought is the best way to do the shit.

[11:43] <moritz_> rokoteko: ok. There's no documentation yet, but the methods are all named in the same way as the Perl 5 CGI::Application methods

[11:43] <moritz_> and there are tests :-)

[11:46] <takadonet> morning all

[11:46] <rokoteko> moritz_: personally I find code self-documenting, so it's not a problem. :)

[11:46] <moritz_> :-)

[11:47] <rokoteko> moritz_: but as I written documentation ive also found its best to write it as you write code!

[11:47] <dalek> niecza: fa2393d | sorear++ | setting:

[11:47] <dalek> niecza: Fix (1,2).iterator; turns out you can not just pass Iterators to a slurpy 

[11:47] <dalek> niecza: function.  Also fix a thinko with list flattening

[11:47] <dalek> niecza: review: http://github.com/sorear/niecza/commit/fa2393d906960a1ec453e9cf10b200f9c065d0ed

[11:47] <dalek> niecza: 7b4cabe | sorear++ |  (2 files):

[11:47] <dalek> niecza: Improve handling of my @x in subs

[11:47] <dalek> niecza: review: http://github.com/sorear/niecza/commit/7b4cabe09f5169de79ccb125c6b06c92f00fda41

[11:47] <rokoteko> so it's kinda sad its undocumented, but that doesnt scare me. the least so as it is documented in an earlier written code.

[11:48] <rokoteko> moritz_: do you have a todo-list?

[11:49] <moritz_> rokoteko: it's "port more features from CGI::Application"

[11:49] <moritz_> ie from the perl 5 version

[11:49] <rokoteko> moritz_: ok.

[11:49] <moritz_> rokoteko: I fear somebody needs to write Cookie module first

[11:49] <rokoteko> the code looks rather clear.

[11:49] <moritz_> at least for the cookie handling code in CGI::App

[11:50] <rokoteko> some perl6 things I have learn. what on eart is method !foo {} ?

[11:50] <tadzik> private method

[11:50] <rokoteko> ahhh!

[11:51] <moritz_> ! means not, so method !foo  is a method you don't call from the outside :-)

[11:51] <rokoteko> %ENV{CGI_APP_RETURN_ONLY} .. you have some new CGI headers in ENV?

[11:52] <sorear> stefan@stefans:~/niecza$ ./niecza_eval -e 'my $buf = ""; sub cat(*@x) { while @x { $buf = $buf ~ @x.shift; }; $buf; }; say cat(1, (2, 3), ((4, 5), (Nil, 7)))'

[11:52] <sorear> 123457

[11:52] <sorear> \o/

[11:52] <moritz_> rokoteko: no, that's only internally used for testing

[11:52] <colomon> lolibloggedontaylorseries: http://justrakudoit.wordpress.com/2010/07/20/fun-with-series/

[11:52] <moritz_> rokoteko: it's much easier to test if it doesn't print out stuff, but returns it

[11:52] <daxim> needs moar loli.

[11:52] <rokoteko> moritz_: ok.

[11:53] <dalek> niecza: 8e5549c | sorear++ | setting:

[11:53] <dalek> niecza: Fix lists interpolating backwards

[11:53] <dalek> niecza: review: http://github.com/sorear/niecza/commit/8e5549c6165b750315d5976c12a8eaf8d69a522f

[11:53] <dalek> niecza: 6d2ff7d | sorear++ | setting:

[11:53] <dalek> niecza: Fix bad use of signatures - parcel flattening works!

[11:53] <dalek> niecza: review: http://github.com/sorear/niecza/commit/6d2ff7d6317403bf370d6e0ee5092e260ccc64ac

[11:54] <rokoteko> so about [<prerun>]  what is <prerun> there? a method? also how does the type system work like, every type has a "base-type" as I think Ints are Nums?

[11:54] <moritz_> rokoteko: <prerun> is the same as qw/prerun/ in Perl 5

[11:55] <moritz_> and yes, it's a method name here

[11:55] <rokoteko> ah .. so the <> is just a sugar for arrays?

[11:55] <moritz_> [...] is an array, and <foo bar> is a quoted list

[11:56] <rokoteko> ok. I think I need to read the synposes also to get a hang of perl6 also.

[11:56] <moritz_> rakudo: say [<prerun postrun>].perl

[11:56] <p6eval> rakudo cf3da0: OUTPUT¬´["prerun", "postrun"]‚ê§¬ª

[11:56] <moritz_> rokoteko: http://perlgeek.de/en/article/5-to-6 might be of interest for you

[11:57] <rokoteko> moritz_: bookmarked, thanks. :)

[11:58] <rokoteko> ah wait what. POD syntax is the same?

[11:58] <moritz_> no

[11:58] <moritz_> but similar

[11:58] <moritz_> =begin stuff ... =end stuff

[11:58] <moritz_> instead of =head1 ... =cut

[11:59] <rokoteko> do you have links that absolutely define some functions, so you write like eclipse plugins that browse the docs for you? .. Im a unix+vim user myself but Ive met the just-graduated windows+eclipse user at work.

[12:00] <rokoteko> so you are able to write ... that is.

[12:00] <rokoteko> I found that they prefer java also because they can integrate the docs to their editor.

[12:00] <moritz_> not yet

[12:00] <moritz_> there's been work on a tool for that, named 'grok'

[12:01] <moritz_> but it's nto really mature

[12:01] <moritz_> (afaict)

[12:01] <moritz_> literal will likely correct me soon enough :-)

[12:01] <literal> nah

[12:02] <rokoteko> but it doesnt work if the documentation isnt written at the beginning like that?

[12:02] <rokoteko> or does it?

[12:03] <moritz_> it's meant to work independently of the location of the POD

[12:04] <literal> same as in Perl 5

[12:07] <rokoteko> I just asked him to show how eclipse works with POD and it sucked compare to Java thing. people, at my last workplace where I partly worked progamming java, really tried to force me to use eclipse. but I was just so much faster with vim.

[12:07] <moritz_> right. vim has the advantage of being a decent editor :-)

[12:10] <rokoteko> yes. I took a look, out of interest, at the vim plugin for eclipse. omg. it was nothing like vim :)

[12:11] <rokoteko> anyhow. afk for now. Im on a holiday, as stated earlier, but just had an urge to do something with perl after the dream last night. :)

[12:11] <moritz_> btw there's a perl6 vim syntax file at http://github.com/petdance/vim-perl

[12:11] <moritz_> it's not perfect, but works more often than not

[12:12] <dalek> niecza: d740787 | sorear++ | rxwork.pl:

[12:12] <dalek> niecza: Bring rxwork into the debugging phase

[12:12] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d740787af323e0f21d361a7d6fea15935e1263a9

[12:12] <dalek> niecza: 9f72975 | sorear++ | rxwork.pl:

[12:12] <dalek> niecza: rxwork: Fix some iterator issues

[12:12] <dalek> niecza: review: http://github.com/sorear/niecza/commit/9f7297597ee2844e34a5ad6eb004ae995c7b5aec

[12:13] <takadonet> sorear++ :)

[12:15] <colomon> rakudo: say "10" before "100", "10" < "100"

[12:15] <p6eval> rakudo cf3da0: OUTPUT¬´11‚ê§¬ª

[12:15] <colomon> rakudo: say "010" before "100", "010" < "100"

[12:15] <p6eval> rakudo cf3da0: OUTPUT¬´11‚ê§¬ª

[12:16] <colomon> rakudo: say "20" before "100", "20" < "100"

[12:16] <p6eval> rakudo cf3da0: OUTPUT¬´01‚ê§¬ª

[12:17] <hejki> rakudo: say 10 before 100

[12:17] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[12:17] <hejki> rakudo: say 20 before 100

[12:17] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[12:17] <hejki> are they Str() for a reason? :)

[12:17] <hejki> in your tests i mean

[12:18] *** masak joined
[12:19] <masak> hi #perl6!

[12:19] <moritz_> oh hai masak 

[12:19] <moritz_> looking at the changelog, it's going to be an awesome release.

[12:20] <masak> \o/

[12:21] <cognominal> std: say ,,

[12:21] <p6eval> std 31772: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Preceding context expects a term, but found infix , instead at /tmp/F3hluJKO0T line 1:‚ê§------> [32msay [33m‚èè[31m,,[0m‚ê§Parse failed‚ê§FAILED 00:03 116m‚ê§¬ª

[12:21] <cognominal> rakudo: say ,,

[12:21] <moritz_> delegation, binding, Buf and basic binary IO, closures, autoviv, $*ARGFILES, backtracking into captures, 

[12:21] <p6eval> rakudo cf3da0: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say ,,"‚ê§¬ª

[12:21] <jnthn> o/ folks

[12:21] <phenny> jnthn: 03:47Z <pmichaud> tell jnthn Is there a way from actions to see if an outer scope defines a method (regex, actually) of a given name?  See Pm-21 in misc/pm.txt .

[12:21] <phenny> jnthn: 03:48Z <pmichaud> tell jnthn it doesn't appear that methods are entered in a PAST::Block's symbol table.

[12:21] <masak> rakudo: say 3i ~~ (1i .. 5i)

[12:22] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[12:22] *** bluescreen joined
[12:22] <masak> lolitsjnthn!

[12:22] <moritz_> and then small things like Mu.perl

[12:22] <masak> rakudo: say (2 + 3i) ~~ (1i .. 5i)

[12:22] <p6eval> rakudo cf3da0: OUTPUT¬´0‚ê§¬ª

[12:22] * masak becomes curious

[12:22] *** bluescreen is now known as Guest62932

[12:22] <moritz_> rakudo: say 1i.succ

[12:22] <p6eval> rakudo cf3da0: OUTPUT¬´1 + 1i‚ê§¬ª

[12:22] <moritz_> rakudo: say 1i.succ cmp 5i

[12:23] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[12:23] <masak> rakudo: say (1 + 1i) ~~ (0 + 0i .. 2 + 2i)

[12:23] <jnthn> phenny: tell pmichaud no they shouldn't be unless marked "my regex" or "our regex" in which case they then have an entry. And that's the interesting case for the lexical regex things afaik? Can check...catch me when you're awake, I should be around plenty today anyway :-)

[12:23] <phenny> jnthn: I'll pass that on when pmichaud is around.

[12:23] <moritz_> masak: any more questions?

[12:23] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[12:23] <masak> moritz_: yes. does complex range smartmatching check whether a complex number is on a given line segment? :)

[12:23] <masak> because all the examples I've tried so far suggests that.

[12:23] <moritz_> it does not.

[12:24] <masak> s/suggests/suggest/

[12:24] <dalek> rakudo: 3370f07 | moritz++ | docs/ChangeLog:

[12:24] <dalek> rakudo: update ChnageLog

[12:24] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3370f072e61abf0226ae08506d8aebea98c4e261

[12:26] <sorear> I have the regex engine working

[12:27] <sorear> it takes about .2 seconds to match "xbc" ~~ /ab*c/ though

[12:27] <jnthn> phenny: tell timbunce I'll get to it shortly...just trying to get to a lot of things at the moment

[12:27] <phenny> jnthn: I'll pass that on when timbunce is around.

[12:27] <sorear> now I just need to add regex syntax and fold rxwork back into setting

[12:27] * sorear -> nap

[12:29] <colomon> masak: actually, it might, but only accidentally

[12:29] <colomon> or rather, it will test for an entire region.

[12:29] <masak> jnthn: src/glue/enum.pir, line 80. here's where I need to install an instance of the mixed-in value, as we discussed yesterday. unfortunately, that part is PIR. is it still feasible, you think?

[12:30] <masak> colomon: aha. line would be slightly cooler :)

[12:30] <masak> rakudo: say (1 + 1.5i) ~~ (0 + 0i .. 2 + 2i)

[12:30] <p6eval> rakudo cf3da0: OUTPUT¬´1‚ê§¬ª

[12:30] <dalek> niecza: 1dc23fa | sorear++ | setting:

[12:30] <jnthn> masak: You can call '&infix:<does>' from pir

[12:30] <dalek> niecza: Fix another precendece fail

[12:30] <dalek> niecza: review: http://github.com/sorear/niecza/commit/1dc23fabf6038282f44e3552a3af66eed33ef1ed

[12:30] <dalek> niecza: 534e6b4 | sorear++ | rxwork.pl:

[12:30] <dalek> niecza: Fix remaining bugs in regex engine

[12:30] <dalek> niecza: review: http://github.com/sorear/niecza/commit/534e6b446a4d1d7ebd999a8212e8e22c57381647

[12:30] <masak> yes, the rectangle hypothesis now is the prevailing one.

[12:31] <colomon> Range just calls before and after (or maybe cmp)

[12:31] <jnthn> masak: Though the whole thing would be a bunch nicer in Perl 6.

[12:31] <masak> jnthn: can I still write the mixin role in Perl 6 and have the PIR see it?

[12:31] <jnthn> masak: I guess you it'd need to then live in a namespace somewhere

[12:32] <masak> yes. that's the part that I have trouble visualising right now.

[12:32] <jnthn> masak: What's the reason we have any of it in PIR?

[12:32] <jnthn> masak: Or maybe we could switch to inline PIR?

[12:32] <masak> jnthn: IIRC, I tried to do it in Perl 6, failed miserably, and then you did it in PIR.

[12:32] <jnthn> And have most of it in Perl 6?

[12:33] <masak> jnthn: how it can eventually look might be a post-* concern.

[12:33] <masak> I just want this particular feature to go into the release :)

[12:33] <jnthn> Yeah, I was doing a quick hack to make something work rather than making something it's a good idea to build on...

[12:33] <masak> I don't mind building up a slight further tech debt here just to get the feature in.

[12:34] <masak> I'll assume stewardship over the code afterwards if that helps :)

[12:34] <moritz_> looks like it could be ported to nqp pretty easily

[12:35] <jnthn> oh, the way I ended up doing it coulda been written in Perl 6 in the end anyway

[12:35] <jnthn> (mostly because this code hasn't got any chance of hanlding lexical enums, for exaple)

[12:35] *** felliott joined
[12:35] <jnthn> moritz_: NQP helps little if you want to write $value does role { method key { $name } } and such though. :-)

[12:36] <colomon> rakudo: say ("1", "3", "5" ... 100).perl

[12:36] <p6eval> rakudo cf3da0: OUTPUT¬´("1", "3", "5")‚ê§¬ª

[12:36] <colomon> :\

[12:36] <jnthn> masak: Anyway, it probably could be turned into Perl 6 and it'd make your life easier on the roles stuff.

[12:37] <masak> jnthn: I could try turning it into Perl 6. it didn't end well last time, though :)

[12:38] *** skids joined
[12:39] <jnthn> I think last time we tried passing a Parrot namespace PMC in

[12:39] <masak> yes, that was it.

[12:39] <masak> maybe that was the big mistake.

[12:40] <masak> by the way, I expect to run out of Internet connection sometime this evening. will be mostly offline tomorrow while travelling home. back Thursday, hopefully with better enumerations :)

[12:40] <moritz_> is an EnumMap read-only?

[12:41] <jnthn> moritz_: Yes.

[12:41] <jnthn> masak: \o/

[12:42] *** exodist left
[12:42] <masak> rakudo: my $e = EnumMap.new; $e<foo> = "bar"; say $e.perl

[12:42] *** exodist joined
[12:43] <p6eval> rakudo cf3da0: OUTPUT¬´Cannot modify readonly value‚ê§  in '&infix:<=>' at line 1‚ê§  in main program body at line 22:/tmp/EoUoWpU_sc‚ê§¬ª

[12:43] <moritz_> jnthn: how do I specify a package in a pasttype('call') ?

[12:43] <moritz_> like Enum::my_helper

[12:43] <moritz_> :name('my_helper'), :package('Enum')?

[12:45] <jnthn> moritz_: You don't

[12:45] <jnthn> moritz_: Don't specify a name on the PAST::Op node

[12:45] <jnthn> moritz_: just set pasttype to call

[12:46] <jnthn> moritz_: And then make the first child of it a PAST::Var node that looks up the thing to call

[12:47] <moritz_> ah

[12:48] <moritz_> rakudo: enum A <b c>; say b

[12:48] <p6eval> rakudo cf3da0: OUTPUT¬´0‚ê§¬ª

[12:55] <tadzik> hmm. Looking at rakudo/README on github, Rakudo is also in CRUX ports

[12:58] <dolmen_> rakudo: enum A <b c>; say b.^methods().join(',')

[12:58] <p6eval> rakudo cf3da0:  ( no output )

[13:02] <dolmen_> rakudo: say "5".succ

[13:02] <dolmen_> rakudo: say ("5".."10")

[13:03] <p6eval> rakudo cf3da0:  ( no output )

[13:03] <p6eval> rakudo cf3da0:  ( no output )

[13:03] <[Coke]> rakudo: 'whatwhat'.say 

[13:04] <p6eval> rakudo cf3da0: OUTPUT¬´whatwhat‚ê§¬ª

[13:04] <[Coke]> juuuust checking.

[13:06] <masak> could someone sanity-check my thinking here: http://gist.github.com/482925 introduces a lot of good things, and I like what I see -- expect .day-name and .month-name, which I think belong in some l10n-y non-core module.

[13:06] <masak> is this too harsh? should we allow English names in the core module?

[13:07] <masak> it does seem like some formatting letters use those methods, so that's certainly an argument for keeping them...

[13:08] <mathw> if we don't have those, we can't have anything else that renders dates unless it can farm out to the system locale

[13:08] <mathw> I would say

[13:08] <mathw> for consistency :)

[13:09] <masak> that sounds like a "keep 'em" vote to me.

[13:09] <moritz_> keep 'em. Worry about l10n later

[13:09] <masak> thing is, until now I've been advocating a "numbers yes, names no" line for Temporal.

[13:09] <masak> but this patch actually looks farily solid. Kodi++

[13:10] <masak> I'm also displeased about publishing the name "Calendarical". eww! but everyone knows that by now, and it's still a net win, I think.

[13:10] <[Coke]> masak: if it's any help, I've never heard of it.

[13:11] <dolmen_> Calendarical is a calendar in iCal format?

[13:11] <masak> [Coke]: I think naming something "Calendarical" is a symptom of the general abstract-y-ness that has been haunting S26/Temporal from the start.

[13:11] <masak> [Coke]: there, now you've heard it. :)

[13:12] <masak> dolmen_: if only. it means something like "parent thingy of Date and DateTime".

[13:12] <moritz_> Dateish!

[13:12] <masak> sorry, *Calendrical

[13:12] <jnthn> Timey!

[13:12] <masak> my point still stands.

[13:12] <jnthn> Wheny

[13:12] * dolmen_ was ironic

[13:12] <masak> dolmen_: yes, I suspected that. :)

[13:13] <masak> dolmen_: I just tend to answer even jokey questions seriously.

[13:13] <jnthn> It's how Swedes do humor. :P

[13:13] <masak> I don't think Calendrical/Wheny/Dateish should be visible. we should be careful about polluting the namespace.

[13:13] <masak> jnthn: yes. it is.

[13:13] <jnthn> :-)

[13:13] <dolmen_> masak: Good behavior when there is ambiguity

[13:14] <masak> dolmen_: it has been known to lead some conversations into some very interesting tracks.

[13:14] * dolmen_ doesn't have access to gist.github.com: dns_server_failure

[13:16] <mathw> namespace polition is BAD

[13:16] <mathw> pollution

[13:16] <mathw> my spelling is also BAD

[13:17] <dolmen_> masak: there is a major problem in the Temporal spec: DateTime is mutable

[13:18] <moritz_> why is that a major problem?

[13:18] <jnthn> masak: If your internets will be FAIL before #phasers, do preport.

[13:19] <dolmen_> moritz_: this is a problem in the Java API where java.util.Date is mutable

[13:19] <moritz_> dolmen_: can you try to explain it for somebody who doesn't know the Java API?

[13:19] <dolmen_> moritz_: all APIs use Date objects, but most of the time you just want to expose readonly object

[13:20] <dolmen_> moritz_: for example a database query should return readonly objects

[13:20] <masak> dolmen_: please nopaste a spec patch where you make DateTime immutable.

[13:20] *** macroron joined
[13:20] <masak> dolmen_: oh, and a Rakudo patch :)

[13:21] <moritz_> dolmen_: the problem with immutable DateTime objects is that they make some things more complicated, like setting a timezone

[13:21] <Leonidas> i am thinking about writing something in Perl 6 and for that I'd like to use a template engine. are there any good template engines that work with perl 6?

[13:21] <moritz_> also note that most database queries would probably return an Instant, not a DateTime object

[13:21] <dolmen_> moritz_: I think that a DateTime object must be readonly and a DateTimeCalc object (java.util.Calendar in the Java world) must be used for computations

[13:22] <moritz_> dolmen_: that sounds more like a Java solution than like Perl solution

[13:22] <moritz_> masak: your turn (re template) :-)

[13:22] <baest> dolmen_: couldn't it just be the reverse? DateTime is readonly and DateTimeImmutable could be returned by databases if needed

[13:23] <baest> isn't readonly

[13:23] <dolmen_> moritz_: this just a "don't repeat a bad design that will be kept for years"

[13:23] <masak> moritz_: sorry, "template"? ENOCONTEXT

[13:23] <Leonidas> I found HTML::Template which has been ported to p6 by masak, but actually I think the syntax is ugly ;)

[13:23] <masak> ah.

[13:23] <moritz_> what's wrong with returning an Instant (which is a more light-weight anyway, and immutable) and turning it into a DateTime when more sugar is needed?

[13:23] <masak> Leonidas: yes, I agree. it's ugly.

[13:24] <masak> Leonidas: don't use that one.

[13:24] <moritz_> or does that lose timezone information?

[13:24] <Leonidas> masak: what other alternatives exist?

[13:24] <moritz_> Leonidas: I don't know of any usable Perl 6 template modules beyond that.

[13:24] * Leonidas would go for something TAL or Template Toolkit-like :)

[13:24] <masak> Leonidas: this one is my best bet so far: http://github.com/masak/web/blob/master/drafts/hitomi-example.xml

[13:25] <masak> Leonidas: haven't worked on it for over half a year, so I don't remember its status.

[13:25] <masak> Leonidas: running the tests will tell you.

[13:25] <Leonidas> masak: TAL-like. Yeah, looks way better. Thanks.

[13:25] <Leonidas> Pugs had the ability to embed Perl 5, can rakudo do the same?

[13:25] <masak> Leonidas: there's also this one: http://github.com/masak/web/blob/master/t/ratel/01-basics.t

[13:25] <masak> Leonidas: but then we're back on "ugly", I think. :)

[13:26] <masak> Ratel is ugly-but-minimal, Hitomi is pretty-and-flexible.

[13:26] <baest> masak: is this a "you can have working or ugly, pick one" situation?

[13:26] <Leonidas> masak: Hitomi looks better, I don't care that much about minimal at the moment %)

[13:26] <masak> baest: what kind of choice is that? :P

[13:27] *** tadzik left
[13:27] <baest> masak: heh, I meant working or pretty

[13:27] <masak> Leonidas: let me know if there's some feature missing in Hitomi, and I might get the energy to revisit that code.

[13:27] <Leonidas> For the record, I came here because masak's 10 years of Perl 6 article :D

[13:27] <masak> \o/

[13:27] <au|afk> \\o//

[13:28] *** au|afk is now known as au|irc

[13:28] <[Coke]> \√∂/

[13:28] <Leonidas> masak: thanks, will do.

[13:28] <masak> the article seems to have made Japanese Slashdot: http://slashdot.jp/submission/39299/Perl-610

[13:28] <PerlJam> good morning all

[13:28] <masak> by the looks of it, that's like normal Slashdot, but without all the annoying comments :P

[13:28] <masak> PerlJam: bonan matenon!

[13:30] <dolmen_> moritz_: Instant is good for storage. But having the DateTime methods sugar is important

[13:30] *** rgrau_ joined
[13:33] *** colomon left
[13:35] <masak> std: say "OH { my $x } HAI"; say $x

[13:35] <p6eval> std 31772: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $x is not predeclared at /tmp/vd63FOl5fD line 1:‚ê§------> [32msay "OH { my $x } HAI"; say $x[33m‚èè[31m<EOL>[0m‚ê§Check failed‚ê§FAILED 00:01 116m‚ê§¬ª

[13:35] <masak> std: / :my $x /; say $x

[13:35] <p6eval> std 31772: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Bogus term at /tmp/YZFxZG2eeA line 1:‚ê§------> [32m/ :my $x /[33m‚èè[31m; say $x[0m‚ê§Parse failed‚ê§FAILED 00:01 119m‚ê§¬ª

[13:35] <masak> std: m/ :my $x /; say $x

[13:35] <p6eval> std 31772: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Bogus term at /tmp/JMDvjwXmnM line 1:‚ê§------> [32mm/ :my $x /[33m‚èè[31m; say $x[0m‚ê§Parse failed‚ê§FAILED 00:01 119m‚ê§¬ª

[13:36] <masak> oh.

[13:36] <masak> std: / :my $x; /; say $x

[13:37] <p6eval> std 31772: OUTPUT¬´ok 00:01 118m‚ê§¬ª

[13:37] <masak> fwiw, I agree with sorear that this is wrong.

[13:37] *** felliott left
[13:38] <PerlJam> The regex should delimit a lexical scope for $x ?

[13:38] *** timbunce joined
[13:38] <masak> yes.

[13:39] <PerlJam> yeah, that seems "intuitive"

[13:39] <masak> that's my Least Surprise, at least.

[13:39] <moritz_> if not, you could ask if /:i a / && / b/  matches the b case-insensitive

[13:39] <jnthn> rakudo: / :my $x; /; say $x

[13:39] <p6eval> rakudo 3370f0: OUTPUT¬´Any()‚ê§¬ª

[13:39] <moritz_> if it doesn't introduce a scope, why should the :i be confined to just one regex?

[13:39] <jnthn> Oh well, at least we're consistent with STD.

[13:40] <masak> jnthn: wow, we support that? cool!

[13:40] <mathw> I just had an awesome thought

[13:40] <jnthn> masak: Yeah

[13:40] <mathw> "That can wait until after R*"

[13:40] * mathw gets very excited

[13:40] <masak> mathw: :P

[13:40] <jnthn> masak: Thing is though that { ... } defines a scope is a very clear rule.

[13:40] <jnthn> masak: Maybe we don't want to break that with a special case to remember.

[13:40] <mathw> but regexes are a different language

[13:41] <moritz_> jnthn: so you think that :i should leak into the second regex in the same scope?

[13:41] <moritz_> what about rx/.../ vs. rx{...} ?

[13:41] <jnthn> moritz_: No

[13:41] <moritz_> but why, if it doesn't introduce a new scope?

[13:41] <jnthn> moritz_: But variables have meaning in both the regex and in Perl 6.

[13:42] <moritz_> yes, and :i has a meaning both in the first and in the second regex :-)

[13:42] <mathw> :i is more like a function call argument maybe

[13:42] <jnthn> rakudo: rx/ :my $x /; say $x

[13:42] <PerlJam> why should the lexicalness of :i have any relation to the lexicalness of variables?

[13:42] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "rx/ :my $x"‚ê§¬ª

[13:42] <jnthn> rakudo: rx/ :my $x; /; say $x

[13:42] <moritz_> PerlJam: because both are tied to scopes

[13:42] <p6eval> rakudo 3370f0: OUTPUT¬´Any()‚ê§¬ª

[13:42] <jnthn> rakudo: rx{ :my $x; }; say $x

[13:42] <p6eval> rakudo 3370f0: OUTPUT¬´Any()‚ê§¬ª

[13:42] <jnthn> heh

[13:42] <jnthn> Well

[13:43] <moritz_> std: rx{ :my $x; }; say $x

[13:43] <p6eval> std 31772: OUTPUT¬´ok 00:01 118m‚ê§¬ª

[13:43] *** tadzik joined
[13:43] <jnthn> That certainly breaks the block rule :-)

[13:43] <jnthn> rakudo: regex { :my $x; }; say $x

[13:43] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Symbol '$x' not predeclared in <anonymous> (/tmp/83b6jjp1jm:22)‚ê§¬ª

[13:43] <jnthn> Well, I guess in the rx case it's a quoting construct

[13:43] <jnthn> Not actually a block

[13:43] <masak> rakudo: / :my $x = 42; /; say $x

[13:43] <p6eval> rakudo 3370f0: OUTPUT¬´Any()‚ê§¬ª

[13:44] <tadzik> what's the difference between rule and token, in grammars?

[13:44] <masak> rakudo: "foo" ~~ / :my $x = 42; /; say $x

[13:44] <p6eval> rakudo 3370f0: OUTPUT¬´42‚ê§¬ª

[13:44] <PerlJam> tadzik: rules have :sigspace turned on.

[13:44] <masak> \o/

[13:44] <tadzik> they're whitespace-sensitive?

[13:45] <moritz_> right

[13:46] *** Su-Shee joined
[13:47] <cognominal> rakudo:  eval(("a","b").Seq.perl ).WHAT

[13:48] <p6eval> rakudo 3370f0:  ( no output )

[13:48] <cognominal> rakudo:  say eval(("a","b").Seq.perl ).WHAT

[13:48] <dolmen_> tadzik: rules ignore whitespace

[13:48] <p6eval> rakudo 3370f0: OUTPUT¬´Parcel()‚ê§¬ª

[13:48] <moritz_> dolmen_: no. tokens ingore whitespace

[13:49] <PerlJam> dolmen_: unless you mean "rules" in a generic sense, but we call those regex.

[13:49] <cognominal> doing .perl on a Seq returns  a Parcel  :(

[13:50] <mathw> shouldn't .perl return a Str?

[13:50] <mathw> although eval() would be the one returning the Parcel there

[13:51] <moritz_> cognominal: it's a bug, but a small one. It's rarely necessary to reproduce the exact list type, as they can all be coerced very easily (and often automatically)

[13:51] <moritz_> rakudo: my $x = (1, 2, 3).Seq; say $x.WHAT

[13:51] <p6eval> rakudo 3370f0: OUTPUT¬´Seq()‚ê§¬ª

[13:51] <cognominal> mathw: sorry for the imprecision.

[13:52] <tadzik> could someone help me with grammars? I'm trying to write one to parse the config files: http://wklej.org/id/366783/

[13:52] <mathw> cognominal: don't worry about it, I'm just waiting for the doughnut fairy

[13:52] *** drbean left
[13:52] <cognominal> it tripped a test where I checked types and equality

[13:52] <moritz_> tadzik: you don't match \n anywhere

[13:52] <PerlJam> tadzik: you don't have any whitespace eating regex

[13:53] <moritz_> right, change 'parameter' to be a rule, not a token

[13:53] <tadzik> hmm, something like <emptyline>?

[13:53] <cognominal> What is the composer for a Seq?

[13:54] <moritz_> @list.Seq

[13:54] <cognominal> ...if any

[13:54] <dolmen_> moritz: S05 says: A "rule" is really short for:      regex :ratchet :sigspace { ... }

[13:54] <dolmen_> moritz: S05 says: "rule" is a keyword

[13:55] <moritz_> dolmen_: yes. And it doesn't ingore whitespace.

[13:55] *** paul1234 left
[13:55] <PerlJam> dolmen_: :sigspace means whitespace within the regex implicitly match whitespace in your string.

[13:56] <dolmen_> moritz_: oh, yes...

[13:56] <tadzik> hmm, so why should my parameter be rule, not token? There are whitespaces inside, whereas the line should look like 'key=value'

[13:57] * dolmen_ doesn't follow enough the sysposis changes... Reading planetsix is not enough

[13:57] <moritz_> tadzik: there's nothing in your regex that eats newlines

[13:57] <tadzik> $$ in paramater is an end of line, no?

[13:57] <PerlJam> tadzik: so that you can match the \n at the beginning of your string (for one thing)

[13:57] *** masonkramer joined
[13:57] <timbunce> jnthn: what's the status of zavolaj at the moment?

[13:57] <phenny> timbunce: 12:27Z <jnthn> tell timbunce I'll get to it shortly...just trying to get to a lot of things at the moment

[13:57] <PerlJam> tadzik: $$ is zero-width

[13:57] <moritz_> tadzik: yes, but only the end-of-line, not the newline

[13:58] <tadzik> alright, I added token emptyline { ^^ \s* $$ }

[13:58] <timbunce> jnthn: understood. thanks

[13:58] *** masonkramer left
[13:58] <masak> is there a list of *features* that'll go into Rakudo Star? http://www.reddit.com/r/programming/comments/cqysn/10_years_perl_6_project_history_and_personal/c0unjs4 is asking.

[13:59] <jnthn> timbunce: I suspect it's mostly going to be a case of hunting down how it broke.

[13:59] <jnthn> masak: That'd be a long list ;-)

[13:59] <PerlJam> tadzik: so ... you want "foo=bar\nads=7" to match <parameter><emptyline><parameter>  ?

[13:59] <timbunce> bisect?

[13:59] *** ashleydev joined
[13:59] <tadzik> PerlJam: no, parameter has to have \

[14:00] <tadzik> ‚Ä¶ to have \n at the end

[14:00] <tadzik> doesn't it? It ends with $$

[14:00] <jnthn> timbunce: Once I dig in a can probably debug it pretty quick anyway.

[14:00] <timbunce> I'm currently using an older perl6 to I can make progress on DBDI. They'll come a point where that'll become more difficult. 

[14:01] <moritz_> tadzik: token key { [^\[] (\w+) 

[14:01] <moritz_> tadzik: you seem to be using perl 5 character classes

[14:02] <tadzik> maybe I'm still making mistakes, I'm not too fluent with Perl6 regexes yet

[14:02] <tadzik> that's why I'm trying to write something to learn my way around

[14:02] <moritz_> [...] is just a grouping in Perl 6 regexes

[14:02] <tadzik> they're now <[]>, yes?

[14:02] <moritz_> right

[14:02] <tadzik> so it should be <[^\[]>?

[14:02] <PerlJam> tadzik: $$ is zero-width,  it tells you when you're at the end of a line, but it won't consume the newline for matching purposes

[14:02] <moritz_> and <-[...]> for negated char classes

[14:02] <masak> I'll do a spectest run, apply Kodi++'s patch, and then do another spectest run.

[14:02] <timbunce> what arg values does the perl6 --trace option take? (They're not in the README or the --help)

[14:03] <tadzik> oh, ok

[14:03] <tadzik> then it should be token parameter { ^^ <key> '=' <value> \\n $$ }, right?

[14:03] <moritz_> right

[14:03] <tadzik> token not rule, so I can keep the whitespace inside, yep?

[14:03] *** uniejo left
[14:03] <moritz_> right

[14:03] <moritz_> also your string starts with a newline

[14:04] <moritz_> so you have to think about how to parse that

[14:04] <tadzik> emptyline will match it

[14:04] <tadzik> http://wklej.org/id/366787/

[14:04] <moritz_> good

[14:04] <tadzik> updated version

[14:04] <tadzik> still, either it's wrong or I don't know how to extract anything

[14:04] *** ashleydev left
[14:05] <moritz_> if inifile.parse($string) { .say for $<parameter>.flat }

[14:05] <moritz_> tadzik: maybe read the chapters on regexes and grammars in the book?

[14:05] <tadzik> It look a bit complicated to me at the first glance, but I guess I should, yep :)

[14:06] <timbunce> The trace flags also aren't noted in rakudo/docs/running.pod

[14:06] <moritz_> I guess because they don't produce very interesting output :/

[14:06] <masak> anyone see anything not up-to-date on http://rakudo.org/status ?

[14:07] <masak> I just provided that as a list of things that work for the Reddit person.

[14:07] <jnthn> timbunce: It's near the top of my hit list.

[14:07] <timbunce> moritz_: how can I track down Null PMC access in type() and similar errors?

[14:08] <timbunce> the lack of a trace or stack dump or similar (and the lack of a clue on my part) means I hit a wall whenever I get that kind of error.

[14:08] <moritz_> timbunce: I rename the backtrace printer, so that I get the parrot-level traces, which then show at least a bit of where the error occured - not a good technique overall

[14:09] <timbunce> moritz_: sounds good, but what the heck does "rename the backtrace printer" mean?

[14:09] *** patcoll joined
[14:09] *** gbacon joined
[14:09] <dolmen_> rakudo: qp{/etc/passwd}.say

[14:10] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<{ }>, couldn't find final '}' at line 22‚ê§¬ª

[14:10] <moritz_> timbunce: src/Perl6/Compiler.pir, method backtrace

[14:10] <moritz_> timbunce: rename to something unrelated (like, add a _)

[14:10] <moritz_> then recompile

[14:10] <dolmen_> rakudo: qp{/etc/passwd}.WHAT

[14:10] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<{ }>, couldn't find final '}' at line 22‚ê§¬ª

[14:10] *** plobsing joined
[14:10] <jnthn> qp NYI

[14:10] <[Coke]> (that method overrides the normal parrot backtrace printer.)

[14:12] *** paul1234 joined
[14:13] <moritz_> rakudo: my @a = <a b c>; say @a[1|2]

[14:13] <p6eval> rakudo 3370f0: OUTPUT¬´any("b", "c")‚ê§¬ª

[14:14] <moritz_> masak: the autothread over array/hash indexes can be removed from  the non-working list

[14:14] <dolmen_> Are qd{} and qt{} used in the spec?

[14:14] * masak sees if he has privs to remove it

[14:14] <PerlJam> dolmen_: what are qd and qt ?

[14:15] *** drbean joined
[14:15] * dolmen_ imagines: my $today = qd{2010-07-20};

[14:15] *** Mowah left
[14:15] <PerlJam> oh.  no.

[14:16] <PerlJam> dolmen_: See http://perlcabal.org/syn/S32/Temporal.html  though

[14:17] *** daxim left
[14:17] <timbunce> I know there's huge effort going into getting language features implemented for R* but as a newbie I'd really appreciate better diagnostic tools. At the moment perl6 seems to slap me in the face regularly with "some error occurred but I'm not going to help you find out what". Saying SORRY! doesn't soften the blows much. If I wasn't so motivated I think I'd be quickly turned off exploring perl6.

[14:18] *** Mowah joined
[14:18] <PerlJam> timbunce: I know the feeling.  That's exactly the same feeling I had when I first played with ruby over 10 years ago.  I didn't pick it up again until about 4 years ago and the situtation was much improved.

[14:19] <jnthn> timbunce: Many of the patches I've put in of late are aimed at improving errors, fwiw.

[14:19] <cognominal> I guess some sort of pragma would be nice to get the parrot stack. Does not need to be the default though.

[14:19] *** Lorn joined
[14:19] <moritz_> timbunce: if you can reproduce any of these bugs with a little piece of code, please report them, so that we can improve the situation

[14:19] *** au|irc is now known as au|zzz

[14:19] <timbunce> moritz_: disabling backtrace helped. I now see "current instr.: 'perl6;DBDI_pg;!class_init_436' pc 5018 (EVAL_5:1918 (DBDI_pg.pm6:107) called from Sub '' pc 874 (EVAL_5:271) (DBDI_pg.pm6:1)" etc. Very handy.

[14:20] <takadonet> timbunce: the more you describe yours issues, better chance they will get fixed sooner 

[14:20] <PerlJam> timbunce: aside from a real debugger, what sort of better diagnostic tools would you like to have?  (I fear I've gotten far too used to hacking in says everywhere)

[14:21] <moritz_> timbunce: and btw, it has already improved a lot. Some weeks ago you'd never get proper line numbers in error messages :-)

[14:21] <cognominal> To answer takdonet in the place of timbunce, I think sometimes I could golf the errors faster if I get back the rakudo trace

[14:21] <cognominal> s/rakudo/parrot/

[14:22] <timbunce> cognominal: exactly

[14:22] <cognominal> I mean the stack trace.

[14:22] <moritz_> cognominal: I'd welcome a patch for such a pragma/switch/env variable/whatever

[14:22] *** pmurias joined
[14:23] <moritz_> rakudo: say pir::null

[14:23] <p6eval> rakudo 3370f0: OUTPUT¬´error:imcc:syntax error, unexpected '\n'‚ê§  in file 'EVAL_8' line 78‚ê§===SORRY!===‚ê§syntax error ... somewhere‚ê§¬ª

[14:23] <moritz_> rakudo: say pir::null__p

[14:23] <cognominal> like a 'use trace  :stack<parrot>' ?

[14:23] <p6eval> rakudo 3370f0: OUTPUT¬´Null PMC access in type()‚ê§  in main program body at line 22:/tmp/0UAKy4HxeB‚ê§¬ª

[14:24] <moritz_> that even produces a correct line number

[14:24] <cognominal> that would leave other options open?

[14:24] <timbunce> It doesn't help that I'm stuck on an older version (currently June 25th) till zavolaj's working again.

[14:24] <moritz_> cognominal: I don't care much for the syntax now

[14:24] <timbunce> disabling the backtrace method has helped, thanks moritz_++ 

[14:25] <dolmen_> masak: my patch for S32 would be to remove the "Set methods" section entirely. A new object should be always created. truncate() would return a new object like succ() does.

[14:30] <dolmen_> masak: $dt.set(:year(2030)) would be instead written DataTime.new($dt, :year(2030))

[14:30] <dolmen_> s/DataTime/DateTime/

[14:31] <tadzik> http://wklej.org/id/366801/ -- straight from the book, but Rakudo complains about it: Useless declaration of has-scoped token in a module; add our or my to install it in the lexpad or namespace. What has changed, how should it look now?

[14:32] <masak> dolmen_: that feels insufficiently flexible to me; always "changing" attributes through the constructor.

[14:33] <PerlJam> tadzik: straight from an old version of the book perhaps

[14:33] <tadzik> probably. 2010.06

[14:34] <tadzik> nothing newer prebuilt as I see :\

[14:34] <cognominal> afk&

[14:34] <PerlJam> tadzik: stick "my" in front of the token and regex declarations.

[14:35] <PerlJam> tadzik: though I'm not sure rakudo does lexical lookup yet for m/ <dup> / to work

[14:35] <tadzik> now it says Method 'dup' not found for invocant of class 'Cursor'

[14:35] <TiMBuS> <&dup> will, work but won't capture

[14:35] <dolmen_> masak: most of the case of use of a DateTime object are readonly: you get the object from a data source (system time, database data, file attribute) and you do not change it. Only transform it (Str)

[14:35] <tadzik> yeah, that's probably what You just said

[14:36] <dolmen_> masak: the only case where I see modifying an object would be useful would be as a loop iterator

[14:36] <masak> dolmen_: prepare at least the spec patch, and optionally the Rakudo patch, and I will apply it/them.

[14:37] <TiMBuS> (crazy guess) <dup=&dup> might work?

[14:37] *** macroron left
[14:37] <PerlJam> TiMBuS: it does I do believe.

[14:37] *** Mowah left
[14:38] <dolmen_> masak: what is the repo?

[14:38] *** plobsing left
[14:38] <masak> dolmen_: http://svn.pugscode.org/pugs/docs/Perl6/Spec/

[14:40] <masak> dolmen_: with your change, we can get rid of set-year et al, which are currently a workaround.

[14:40] <masak> afk # walk

[14:48] <[Coke]> tadzik: this works:

[14:48] <[Coke]> http://nopaste.snit.ch/22146

[14:48] <[Coke]> the foo=&foo is lame, though. presumably there's a better way.

[14:49] <PerlJam> wait for pmichaud's regelx branch to merge

[14:49] <PerlJam> er, regelx

[14:49] *** timbunce left
[14:49] <PerlJam> er, reglex!

[14:50] <PerlJam> or use a grammar

[14:51] <tadzik> I was about to try some more complex regexes before learning grammars ;)

[14:54] *** tylercurtis joined
[14:58] <dolmen_> paste?

[14:58] *** pmurias left
[15:01] <[particle]> hrmm, there used to be a paste link in /topic

[15:02] <dolmen_> masak: http://nopaste.snit.ch/22147

[15:02] *** timbunce joined
[15:04] *** baest left
[15:09] *** timbunce left
[15:11] *** snarkyboojum joined
[15:13] *** TiMBuS left
[15:13] <tadzik> http://nopaste.snit.ch/22148 can someone take a look?

[15:14] <tadzik> the line before the last prints name=brad as expected

[15:14] *** patcoll left
[15:17] <[particle]> next time, you can paste the output, too.  for example, $ cat my-file.p6 ... $ rakudo my-file.p6 ...

[15:17] <tadzik> yeah, my bad

[15:17] <[particle]> try $config[0]<key>[0]

[15:18] <tadzik> Any()

[15:19] <[Coke]> tadzik: you want: $config[0]<keyval>[0]<key>

[15:19] <[particle]> ok, right, two things.

[15:20] <[Coke]> I find it very helpful to dump the match object here. lemme see if I can remembe rhow to do that from perl6.

[15:20] <[particle]> if there's a ? or * or + after a regex, you'll always have an array generated, so you need to index it

[15:20] <PerlJam> tadzik: btw, <keyval> is already capturing, you don't need () around it.

[15:21] <tadzik> so named regexes are captured automagically?

[15:21] <PerlJam> tadzik: also,  <keyval> [ ';' <keyval> ]*  can also be written now as  <keyval> ** ';'

[15:21] <tadzik> that's useful

[15:21] <[Coke]> tadzik: "say $config[0].perl" might have been helpful to peek into what the structure of the resulting match was.

[15:23] <tadzik> might, but it returns Null PMC access

[15:23] <tadzik> Null PMC access in find_method('perl')

[15:24] <PerlJam> tadzik: not for me.

[15:24] *** Eevee joined
[15:24] <tadzik> strange

[15:24] <[particle]> token TOP { ^ <keyval> ** ';' $ }

[15:25] <[particle]> tadzik: are you using rakudo from git-master-head, or a release?

[15:25] <tadzik> git master head

[15:25] *** TiMBuS joined
[15:25] <PerlJam> huh, I would have guessed you were using a release

[15:26] <tadzik> This is Rakudo Perl 6, version Kiev-280-g9005478 built on parrot r48110

[15:26] <PerlJam> tadzik: when did you build it?

[15:26] <PerlJam> ah.

[15:26] <tadzik> I will paste the whole thing

[15:27] <szabgab> rakudo: for <a 1 b 2 c> -> $a, $b { say "$b - $a" }

[15:27] <p6eval> rakudo 3370f0: OUTPUT¬´1 - a‚ê§2 - b‚ê§ - c‚ê§¬ª

[15:27] <tadzik> http://nopaste.snit.ch/22151

[15:28] <szabgab> will this give an exception again any time soon?

[15:28] <PerlJam> szabgab: btw, nice job on the screencasts!

[15:28] <szabgab> thanks

[15:28] <szabgab> which one is better the first or the second?

[15:28] <szabgab> in terms of view

[15:29] <PerlJam> I liked the second better.

[15:29] <[particle]> why not $config.parse?

[15:29] <szabgab> I think I'll need to enlarge the fonts a bit

[15:30] <[particle]> er, $config.perl

[15:30] <PerlJam> szabgab: have you seen railscasts?

[15:30] <szabgab> nope, I should check them out

[15:30] *** mmcleric joined
[15:30] <PerlJam> railscasts.com  

[15:31] <PerlJam> That guy uses some good styles, fonts, etc.  Copy what you can and what's appropriate and you can't go wrong :)

[15:31] <PerlJam> oh!  He also uses textmate ... it would be really cool to see some screencasts that use padre  :)

[15:34] *** salv0 left
[15:35] *** salv0 joined
[15:35] <szabgab> but for that I will need to run it from my own server, I guess

[15:36] <szabgab> but otoh it clearly looks a lot better than what I have on youtube

[15:43] *** Mowah joined
[15:43] *** envi^home joined
[15:43] *** jaldhar left
[15:44] *** timbunce joined
[15:45] *** timbunce_ joined
[15:45] *** timbunce left
[15:45] *** timbunce_ is now known as timbunce

[15:52] <moritz_> colomon++ # fun-with-series blog post

[15:53] <ingy> morning

[15:54] <[Coke]> ingy: hio

[15:56] <ingy> I was thinking of writing a blog post for oscon/rakudo* about how I ported a ~1000 line p5 framework to p6, and it all worked

[15:56] <moritz_> do that!

[15:56] <takadonet> ingy: can i see it? :)

[15:56] <ingy> maybe use.perl.org?

[15:56] <ingy> takadonet: I need to write it

[15:56] <ingy> :)

[15:57] <ingy> I'll do it now

[15:57] <takadonet> hehe

[15:57] *** mmcleric left
[15:57] <PerlJam> ingy: but ... perl 6 doesn't even exist yet!  ;)

[15:57] *** mmcleric joined
[15:57] <ingy> I think it's an interesting story. A lot of crazy bandaids etc

[15:58] <dolmen_> ingy: the framework or the blog post?

[15:58] <ingy> but it is workable 

[15:58] <ingy> dolmen_: rakudo!

[15:58] <ingy> well I needed to do a few crazy things to make it work

[15:58] <ingy> including one pir call from jnthn++

[15:58] <dolmen_> ingy: you're writing rakudo?

[15:59] <ingy> gah

[15:59] <ingy> ok, I'll just write the post

[15:59] <PerlJam> ingy++

[15:59] <dolmen_> and the framework is done?

[15:59] <ingy> dolmen_: the port is 100% complete

[16:00] <ingy> but you can read about it in my upcoming blog post

[16:00] <ingy> :P

[16:01] <ingy> where did masak post previews of his recent use.perl.org post?

[16:01] <dolmen_> Is it http://github.com/ingydotnet/testml-pm6 ?

[16:01] <ingy> dolmen_: correct

[16:01] <dolmen_> http://nopaste.snit.ch/

[16:02] <ingy> ah

[16:03] <jnthn> ingy: gist iirc

[16:04] *** felliott joined
[16:05] *** cdarroch joined
[16:05] *** cdarroch left
[16:05] *** cdarroch joined
[16:08] <tadzik> wasn't it gist?

[16:08] <ingy> use.perl.org/~ingy == Brian Ingerson

[16:08] <ingy> it's been a while

[16:09] <ingy> I wonder who can change that

[16:10] *** M_o_C joined
[16:11] <PerlJam> ingy: can't you?

[16:12] <tadzik> who is caring about http://november-wiki.org/?

[16:12] <ingy> PerlJam: doesn't seem so

[16:14] <PerlJam> ingy: I would contact Pudge.  But I haven't seen him since I stopped hanging out on irc.perl.org:#perl

[16:15] <dolmen_> ingy: are you aware of blogs.perl.org?

[16:16] <ingy> dolmen_: mst's?

[16:16] <pmichaud> good morning, #perl6

[16:16] <phenny> pmichaud: 12:23Z <jnthn> tell pmichaud no they shouldn't be unless marked "my regex" or "our regex" in which case they then have an entry. And that's the interesting case for the lexical regex things afaik? Can check...catch me when you're awake, I should be around plenty today anyway :-)

[16:16] <takadonet> pmichaud: morning

[16:16] <ingy> that sounds useful

[16:17] *** justatheory joined
[16:17] <jnthn> morning, pmichaud 

[16:17] <tadzik> hmm, is <-[;\n]> a valid character class, capturing anything but semicolons and newlines?

[16:17] * pmichaud reads backscroll

[16:17] <ingy> hi pmichaud 

[16:17] <tadzik> hello pmichaud 

[16:17] <pmichaud> tadzik: it's valid, but rakudo doesn't recognize \-escapes in character lists yet.

[16:17] <jnthn> tadzik: Believe so.

[16:18] <jnthn> oh heh

[16:18] <tadzik> oh, ok

[16:18] <tadzik> so how can I achieve this?

[16:18] <jnthn> I think I copy-pasted something like that from STD into Grammar.pm yesterday :-)

[16:18] <pmichaud> tadzik: looking

[16:20] <PerlJam> tadzik: <subrule> only captures if the character after the < is alphabetic.  (just in case "capture" was being conflated :-)

[16:22] <pmichaud> tadzik: sadly, I don't have a quick answer.  I might be able to get something in place a bit later.

[16:22] <tadzik> ok, nothing urgent

[16:23] <tadzik> I'm trying to write config file parser, ini files it is

[16:23] <pmichaud> you could do something like   <![;]> \N

[16:23] <pmichaud> which means any non-newline that is not a semi.

[16:23] <tadzik> hmm, <![;]> is the same as <-[;]>?

[16:24] <pmichaud> no

[16:24] <pmichaud> <![;]>  is zero-width

[16:24] <pmichaud> basically it says  "don't match a semicolon at this point"

[16:24] <jnthn> It's like <!before ';'> iirc

[16:24] <jnthn> But more efficient.

[16:25] <tadzik> hmm. So [ <![;]> \N ]+ is a positive number of chars not being either semicolon or newline?

[16:25] <pmichaud> correct.

[16:26] <PerlJam> pmichaud: you're at oscon now?

[16:26] <tadzik> thanks pmichaud 

[16:27] <pmichaud> PerlJam: well, I'm in PDX now.  :-)

[16:27] <pmichaud> haven't made it over to the venue yet :)

[16:27] <pmichaud> might just hang out here for a while anyway -- fewer distractions.

[16:27] <PerlJam> I bet

[16:27] *** dolmen_ left
[16:27] <pmichaud> ...and the wireless may be more reliable anyway.

[16:27] <pmichaud> last time I was at oscon in PDX my laptop simply wouldn't connect to the OSCON wireless at all

[16:27] <pmichaud> (different laptop then, though)

[16:29] <PerlJam> pmichaud: does the reglex branch work correctly?

[16:29] <pmichaud> depends on your definition of "correctly", I suspect.

[16:29] <pmichaud> I suspect I can come up with some cases where it fails.

[16:29] <PerlJam> Well, I tried it on one test case and it worked, which is why I asked :)

[16:30] <pmichaud> PerlJam: I'm more concerned about interactions between regex names and the setting.

[16:30] <pmichaud> It should work fine for the simple case of declaring a my-scoped regex.

[16:31] <jnthn> pmichaud: Worried about <print> ?

[16:31] <pmichaud> jnthn: well, also worried about things like      grammar G { token classify { ... } }

[16:31] *** new_user joined
[16:31] <pmichaud> if G then tries to use <classify>, and sees the &classify entry, then it won't use the local one.

[16:32] <new_user> rakudo: for 1..5 { say $_ }

[16:32] <jnthn> Hm

[16:32] <p6eval> rakudo 3370f0: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§¬ª

[16:32] *** new_user left
[16:32] <PerlJam> that's definitely broken then by my definition of "works"  :)

[16:32] <pmichaud> any reason why methods can't be in the PAST::Block symtable?

[16:32] <jnthn> They're not to do with the block really.

[16:33] <timbunce> jnthn: FYI adding "is export" to "sub PQntuples( OpaquePointer $res ) returns Int is native('libpq')" only works if the is export comes before the is native.

[16:33] <jnthn> Better to look at @PACKAGE[0]'s method table.

[16:33] *** phenny left
[16:34] <pmichaud> the problem there is figuring out the relationship between @PACKAGE and @BLOCK, though 

[16:34] <jnthn> timbunce: It's not surprising taht traits can have ordering dependencies.

[16:34] <jnthn> timbunce: That particular one surprises me though.

[16:34] <jnthn> pmichaud: @PACKAGE[0].block should tell you the block associated with the package, if that helps?

[16:35] <pmichaud> ...not really.

[16:35] <jnthn> pmichaud: What are you trying to do?

[16:35] <pmichaud> I'm having to scan @BLOCK, so I'd need to know when a particular block corresponds to a package

[16:35] *** phenny joined
[16:35] <jnthn> pmichaud: Ah...yeah, I don't think we have the relationship marked up in that direction at the moment.

[16:35] <pmichaud> when encountering   <foo>, I have to look to see if "foo"  refers to a lexical &foo regex or should be left as a grammar method

[16:36] <jnthn> Yes

[16:36] <pmichaud> so, we outward-scan the existing symbol tables looking for  .symbol("foo")<scope> eq 'lexical'

[16:36] *** alester left
[16:36] <jnthn> *nod*

[16:37] <pmichaud> but I should probably stop looking if one of the scopes corresponds to a grammar that has a   "method foo"

[16:37] <jnthn> Hmm. That's not going to handle the inheritance case.

[16:37] <pmichaud> right.

[16:37] <jnthn> But yes, perhaps so.

[16:37] <pmichaud> it doesn't handle the inheritance case, which is why I've very much not been a fan of having <foo>  automatically find lexical regexes

[16:38] <pmichaud> because I don't see a good way to handle it at compile time.

[16:38] <jnthn> Anyway, my knee-jerk feeling is that method entries in the block symbols table is wrong, for the same kinda reasons that :method being automatically a namespace entry in Parrot was.

[16:38] <jnthn> So I'd prefer a solution that sets a block's associated package object so that can be queried.

[16:39] <pmichaud> jnthn: I can see your point.  (Not sure I agree with it, though -- block symbol tables simply say 'these are all of the symbols I'm aware of'))

[16:39] <pmichaud> anyway -- yeah, it doesn't handle the inheritance case.  At the moment I'm still inclined to not merge to master until we get spec clarification.

[16:39] <jnthn> I guess if you install it marked as :scope<has> or something it's not so bad.

[16:39] <jnthn> But I still am not too keen.

[16:40] <pmichaud> right, I was thinking it'd be :scope<has>, or even without a :scope at all :-)

[16:40] <pmichaud> just something to say "this word gets used here."

[16:40] <jnthn> I'll think on it some more. I'm not quite sure I've hit upon my real discomfort about it yet. But of coruse, my real discomfort might be bogus too. :-)

[16:41] <jnthn> One potential issue is that methods are unsigil'd.

[16:41] <jnthn> So they may conflict with type names (also unsigil'd) in the .symbol

[16:41] <pmichaud> Yes, I was surprised that lexical regexes were going into .symbol without the sigil.

[16:41] <ingy> is it more properly Rakudo* or Rakudo *? (in prose)

[16:42] <jnthn> pmichaud: We may want to tweak that.

[16:42] <pmichaud> ingy: two words.

[16:42] <PerlJam> ingy: I tend to write "Rakudo Star"

[16:42] <pmichaud> so  "Rakudo *".  Or "Rakudo Star" if you want the prose to be clearer.

[16:42] <jnthn> pmichaud: Since I'm quite sure we install them into the lexpad as &foo

[16:42] <pmichaud> jnthn: yes, we do.

[16:42] <pmichaud> as I said, I was surprised.  :)

[16:43] <jnthn> Yeah, I think that's a mistake.

[16:43] <jnthn> Shoudl be in the block as &foo

[16:43] <jnthn> But in the meta-class as foo

[16:44] <pmichaud> my regex xyz { xyz };    grammar A { regex xyz { XYZ }; };   grammar B is A { regex TOP { <xyz> } };     # which one does TOP see?

[16:44] <jnthn> I guess if we do put methods in as &foo too, it does mean that our compile-time idea of the lexpad and our runtime one afe going to not match up.

[16:44] <jnthn> *are

[16:44] <pmichaud> I wouldn't plan to put methods in as &foo

[16:44] <pmichaud> (unless it's a "my method" of course)

[16:44] <jnthn> pmichaud: Yeah, but then we get conflict with a typename foo too

[16:45] <pmichaud> right

[16:45] <jnthn> rakudo: role Bar[::foo] { method foo { foo } }; say Bar[Int].foo

[16:45] <p6eval> rakudo 3370f0: OUTPUT¬´Int()‚ê§¬ª

[16:45] <pmichaud> which bolsters your argument that it doesn't belong in the block's symbol table :)

[16:46] *** felliott left
[16:47] <jnthn> Yeah, I'm a bit worried what'd happen in the above case.

[16:48] <pmichaud> This all reminds me of why we got rid of the "method fallbacks" some time ago.

[16:48] <jnthn> Plus just a general sense of "it's hard enough to keep our runtime and compile time story in sync, let alone deciding they're going to be desync'd in some special cases" :-)

[16:48] <jnthn> Anyway, that "what does TOP see" example, so far as I grok the spec, would lead to the lexical one being seen.

[16:49] <jnthn> I can understand why that'd potentially be uncomfortable though.

[16:49] <PerlJam> I would have said it should see B::xyz

[16:50] <pmichaud> PerlJam: you mean the one inherited from A?

[16:50] <PerlJam> yes

[16:50] <pmichaud> then what about

[16:50] *** supernovus joined
[16:50] <pmichaud>  grammar A { regex xyz { XYZ }; };  my regex xyz { xyz };  grammar B is A { regex TOP { <xyz> } };     # which one does TOP see?

[16:50] <pmichaud> still the one inherited from A?

[16:50] <PerlJam> yes

[16:50] <pmichaud> then what about

[16:51] <PerlJam> I know what you're about to show me and I don't know  :)

[16:51] <supernovus> phenny: tell Kodi nice work on the Temporal stuff!

[16:51] <phenny> supernovus: I'll pass that on when Kodi is around.

[16:51] <PerlJam> (my answer is "I don't know")

[16:51] <pmichaud> my regex alpha { xyz };   grammar B is Grammar { regex TOP { <alpha> } };   # what does TOP see?

[16:52] <PerlJam> I would tend to lean towards the inherited one

[16:52] <pmichaud> maybe we get to be okay if we say that only regexes not part of a grammar declaration participate in the lexical lookups

[16:52] <PerlJam> pmichaud: that seems sane

[16:53] <jnthn> pmichaud: Could work.

[16:53] *** felliott joined
[16:53] <pmichaud> i.e., a regex that is being installed into a grammar doesn't ever at outer lexicals

[16:53] <PerlJam> if they really wanted the lexical one, they could have said <&alpha>, right?

[16:53] <pmichaud> PerlJam: Yes.

[16:53] <pmichaud> and if they really wanted to override alpha, they could do it in the declaration of B

[16:53] <PerlJam> right

[16:53] <PerlJam> so, seems really sane.

[16:54] <pmichaud> (the difference being that <&alpha> is non-capturing, so it'd need to be <alpha=&alpha> or something like that)

[16:54] <PerlJam> right

[16:54] <PerlJam> seems like a small-price, low-probability sort of thing to me.

[16:55] <moritz_> only 'my' or 'our' regexes in grammars would be picked up as lexicals anways

[16:55] <PerlJam> (i.e. if they *really* wanted the lexical <alpha> and they wanted a named capture, we should encourage the use of grammars anyway)

[16:56] <pmichaud> I still feel as though I'd like some definite clarity on this point, though.  If at some point we disallow <xyz>  from finding a lexical &xyz, we'll end up with a fair bit of code breakage.

[16:56] *** mmcleric_ joined
[16:56] *** mmcleric_ left
[16:56] *** mmcleric left
[16:57] *** mmcleric joined
[16:57] <PerlJam> pmichaud: so ... we don't do that  :)

[16:57] <pmichaud> PerlJam: we may have to

[16:57] <jnthn> pmichaud: It worked for the wrong reasons in alpha, and a lot of code depended/depends on it.

[16:57] <pmichaud> jnthn: right

[16:58] <jnthn> My sense is that people expect that it's going to start to work again.

[16:58] <jnthn> To some degree.

[16:58] <pmichaud> jnthn: unless we decide that it can't work

[16:58] <PerlJam> jnthn: indeed

[16:58] <pmichaud> jnthn: because by making it work we're conflating method dispatch with lexical dispatch

[16:58] <PerlJam> pmichaud: we'll never know without an implementation that people can hack on :)

[16:59] <jnthn> pmichaud: True, which we've gone to lengths to avoid elsewhere.

[16:59] <PerlJam> hmm

[16:59] <pmichaud> jnthn: and for good reason.

[16:59] <jnthn> pmichaud: These kinds of reasons. :-)

[16:59] <moritz_> http://brunorc.wordpress.com/2010/07/20/perl-6-in-shops-near-you/

[16:59] <pmichaud> the fact that <xyz>  finds things lexically is actually left over from the days when we also were saying that     xyz $y     could fall back to $y.xyz   (or perhaps it was the other way around, I forget)

[17:00] <moritz_> still, there are good use cases for it

[17:00] <moritz_> for example importing rules from modules

[17:00] <pmichaud> either way, we eliminated that particular fallback mechanism, but never updated regexes to match.

[17:00] <tadzik> the best way to achieve required parameters in classes is 'has $.a = die "...";'?

[17:00] <moritz_> where you don't want full grammars

[17:00] <TimToady> perhaps some way of explicitly importing

[17:01] <moritz_> I'd also be fine with a shorter syntax for explicitly calling lexical rules, and have them capture

[17:01] *** xabbu42 left
[17:01] <PerlJam> in classes, method dispatch always needs a dot, right?  perhaps make the same requirement in grammars (and allow <.foo> to capture)

[17:01] <moritz_> having <&foo> capture, and <.&foo> not capture, for example

[17:01] <pmichaud> PerlJam: ouch.  that puts huffman all wrong.

[17:01] *** xabbu42 joined
[17:01] <jnthn> PerlJam: I almost suggested as logical, but it felt too wrong :-)

[17:01] <moritz_> but <foo=&foo> feels tedious

[17:02] <TimToady> nothing that starts with punctuation captures right now

[17:02] <TimToady> don't wanna break that

[17:02] <PerlJam> moritz_: or, "if you want capturing, you want a grammar"

[17:02] <pmichaud> agree, don't break that.

[17:02] <moritz_> PerlJam: no

[17:02] <jnthn> tadzik: heh, that probably works actually... :-)

[17:02] *** plainhao joined
[17:02] <jnthn> I hadn't thought of it. :-)

[17:02] *** dakkar left
[17:02] <tadzik> jnthn: is there a better way?

[17:03] <moritz_> PerlJam: there's nothing wrong with having lexical rules - why force people away from them?

[17:03] <jnthn> tadzik: Well, you could also write a new method with a required param.

[17:03] <pmichaud> moritz_: what we're saying is that there may indeed be somethign wrong with lexical rules.

[17:03] <pmichaud> See my examples above.

[17:03] <tadzik> and bless myself, like in Perl 5

[17:03] <tadzik> ?

[17:03] <pmichaud> until you can resolve those, it's not the case that "there's nothing wrong with lexical rules."

[17:03] <jnthn> Go bless yourself!

[17:03] <jnthn> uh, I mean :-)

[17:03] <jnthn> tadzik: Yeah

[17:03] <tadzik> erm, "call 'bless' myself"

[17:03] <tadzik> :)

[17:04] <moritz_> or just call self.Mu:::new(|%args)

[17:04] <jnthn> Or that

[17:04] <jnthn> Note that you can also do like

[17:04] <TimToady> maybe the easiest way to fix it is by saying they have to put grammar {...} around everything  :)

[17:04] <supernovus> Any idea when Kodi's patch will be applied? I will need to modify my recently added %z in the loadable DateTime::strftime library, as it currently depends on the old timezone attribute format in DateTime.

[17:05] <moritz_> pmichaud: if there's a short syntax for calling lexical rules (that captures), there's nothing wrong with lexical regexes per so. Only with our current approach, maybe

[17:05] <tadzik> is there something like sub BUILD in Moose?

[17:05] <jnthn> method new(%args (:$required-name!, :$another!, *%)) { self.bless(*, |%args) }

[17:05] <jnthn> tadzik: Yes, submethod BUILD

[17:05] <tylercurtis> Also submethod BUILD.

[17:05] *** stkowski joined
[17:05] <PerlJam> pmichaud: how about this ... R* release is too close.  Implement something hits the big targets and let the edge cases work themselves out by people using R*  :-)

[17:05] <tadzik> sounds like a prettier way for required params

[17:05] <jnthn> tadzik: Yes, that'd also work

[17:06] <tadzik> good. Will look more sane

[17:06] *** thebird left
[17:06] <pmichaud> PerlJam: there's a problem with "hit the big targets"

[17:06] <jnthn> rakudo: class Foo { has $.x; submethod BUILD($!x) { } }; say Foo.new(x => 42).x;

[17:06] <p6eval> rakudo 3370f0: OUTPUT¬´42‚ê§¬ª

[17:06] *** xabbu42 left
[17:06] <jnthn> rakudo: class Foo { has $.x; submethod BUILD($!x) { } }; say Foo.new().x;

[17:06] <p6eval> rakudo 3370f0: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in 'Foo::BUILD' at line 22:/tmp/qAqWBWlP_L‚ê§  in main program body at line 22:/tmp/qAqWBWlP_L‚ê§¬ª

[17:06] <jnthn> \o/

[17:06] <pmichaud> the way PGE worked was that it fell back to lexical lookup if a method didn't exist at runtime.  i.e., it's a runtime check.  That's expensive.

[17:07] <tadzik> jnthn: that looks even more cryptic to me :P

[17:07] <pmichaud> it may also be wrong, as the lexical lookup should perhaps take precedence over the method lookup.

[17:07] <PerlJam> pmichaud: it also sound backwards

[17:07] <PerlJam> right

[17:07] <pmichaud> right

[17:07] <TimToady> perhaps lexical lookup works only when you *aren't* in a grammar

[17:07] <pmichaud> so, if we take the reglex approach, that does a lexical lookup and falls back to method if the lexical doesn't exist

[17:07] <jnthn> tadzik: The above works because named parameters get mapped to positional ones of matching names, and $!x in a signature binds to an attribute instead of a lexical :-)

[17:08] <pmichaud> TimToady: we speculated something close to that above

[17:08] <jnthn> tadzik: It's pretty logical and declarative when you stop to think about it. :-)

[17:08] *** kalve joined
[17:08] <jnthn> Well, somewhat. :-)

[17:08] <ash_> tadzik: once you know the perl6 syntax for stuff, it makes sense, mostly 

[17:08] <tylercurtis> rakudo: class Foo { has $.x; submethod BUILD($!x) { } }; say Foo.new(:x(5)).x;

[17:08] <pmichaud> PerlJam: but the problem with the reglex approach is that basically every lexical subroutine blocks that name from being used as a regex in a grammar.

[17:08] <p6eval> rakudo 3370f0: OUTPUT¬´5‚ê§¬ª

[17:08] <pmichaud> PerlJam: including the ones in the setting.

[17:09] <tylercurtis> rakudo: class Foo { has $.x; submethod BUILD($!x) { } }; say Foo.new(5).x;

[17:09] <p6eval> rakudo 3370f0: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in 'Foo::BUILD' at line 22:/tmp/LftQm02JSa‚ê§  in main program body at line 22:/tmp/LftQm02JSa‚ê§¬ª

[17:09] <jnthn> tylercurtis: If you want that one to work, you need to write a "new" method.

[17:09] <tylercurtis> jnthn: just checking. :)

[17:09] <jnthn> :)

[17:09] <TimToady> pmichaud: it could ignore anything that isn't declared as method

[17:09] <pmichaud> so then it becomes really strange when you define a grammar with    regex item { ... }    and it doesn't work because <item> keeps finding &item 

[17:11] <TimToady> though, perhaps item is declared as a method, and exported

[17:11] <pmichaud> TimToady: yes, that also requires a bit more looking-up than I can easily handle in R*

[17:11] <PerlJam> Least Surprise is hard sometimes

[17:13] *** pmurias joined
[17:13] <PerlJam> I think I've mentioned this before, but how about regex declared outside of a grammar all belong to an implicit grammar?

[17:14] *** christin1 left
[17:14] <PerlJam> (and you always use method dispatch to lookup names)

[17:14] <TimToady> or we require an anonymous grammar {...} around them

[17:14] <timbunce> rakudo: say $a; my $a

[17:14] <p6eval> rakudo 3370f0: OUTPUT¬´Any()‚ê§¬ª

[17:15] <timbunce> shouldn't that complain that $a is not predeclared?

[17:15] <TimToady> known bug

[17:15] <pmichaud> timbunce: yes, it should.

[17:15] <pmichaud> for some reason the check for declared symbols got removed.

[17:15] <tadzik> dying inside CATCH will die outside of the try block, right?

[17:15] <tadzik> ah, whatever

[17:15] <pmichaud> tadzik: right now dying inside CATCH will infinite loop in Rakudo.

[17:16] <pmichaud> (still having to work on that one)

[17:16] <tadzik> what I really need is not having try block at all ;)

[17:16] <PerlJam> TimToady: so ... is there a singleton anonymous grammar?

[17:16] <pmichaud> PerlJam: can't be singleton.  needs to be lexically scoped, I think.

[17:17] *** christin1 joined
[17:17] <PerlJam> Hmm.

[17:17] <pmichaud> well, I'll phrase it this way

[17:17] <tadzik> so, while I'm asking questions anyway: my $asd = INI.parse($string); How can I check if parsing was sucessful?

[17:17] <tadzik> I know I can do 'if INI.parse(...)', but then I'll have to parse twice to assign it to variable

[17:17] <pmichaud> in the normal method space,  the closest we have to allowing a bare "foo" to correspond to a method call is via indirect object syntax.

[17:17] <PerlJam> pmichaud: so each block would potentially contain a single anonymous grammar that perl knows to look at when someone does  / <foo> /

[17:18] <pmichaud> or put another way, in normal method space, we don't have a mechanism that doubles as both lexical and method dispatch.

[17:18] <TimToady> alternately, you just have some way of saying 'mix in my current block's regexes'

[17:19] <moritz_> tadzik: if $asd { ... }

[17:19] <tadzik> ah, it will return false in this context? Ok, thanks moritz_ 

[17:19] <PerlJam> TimToady: augment   :-)

[17:19] <TimToady> not augment, mixin

[17:19] <TimToady> they are *very* different

[17:19] <pmichaud> trying to get <foo> to handle both cases seems to go down the same path we ultimately avoided with methods

[17:20] <TimToady> unless the current grammar *is* the current scope

[17:21] <TimToady> for instance, simply putting grammar Me is ThatGrammar {...} around the whole thing makes it work

[17:21] <TimToady> but maybe there can be something with the same effect that is more lightweight

[17:21] <pmichaud> TimToady: does that help with moritz's  "import a regex" scenario?

[17:22] <pmichaud> how about this

[17:22] <pmichaud> perhaps we want a punctuation that means "explicitly capture"

[17:22] <pmichaud> I'll use # here

[17:22] <pmichaud> so:

[17:22] <pmichaud>     <&foo>   # noncapturing

[17:22] <pmichaud>    <#&foo>   capturing

[17:23] <TimToady> <=&foo>

[17:23] <pmichaud> or yeah, that.

[17:23] <moritz_> +1 to <=&foo>

[17:23] <pmichaud> then one could also have   <=$foo>

[17:23] <PerlJam> wfm

[17:23] <pmichaud> and  <=@foo>

[17:23] <pmichaud> and the like

[17:25] <masak> heh. Unicode *and* smilies. almost too on-topic for this channel: http://unicode.org/Public/6.0.0/charts/versioned/U1F600.pdf

[17:25] <PerlJam> so the first example in the regex chapter of the perl 6 book would become http://gist.github.com/483251  ?

[17:26] <ash_> .u 1F640 

[17:26] <phenny> ash_: Sorry, no results for '1F640 '.

[17:26] <ash_> .u DIZZY FACE

[17:26] <phenny> ash_: Sorry, no results for 'DIZZY FACE'.

[17:27] <Su-Shee> ash_: without the 0.

[17:27] <[Coke]> .u 1F64

[17:27] <phenny> U+1F64 GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA (·Ω§)

[17:28] <[Coke]> Su-Shee: different character.

[17:28] *** supernovus left
[17:28] <pmichaud> masak: I'm a little surprised they don't have glyphs for the "faces pain scale" in that table.

[17:29] <masak> we should suggest that to them.

[17:29] <ash_> "FACE WITH NO GOOD GESTURE" 

[17:29] <ash_> lol

[17:29] * ash_ just realized that is a draft

[17:30] <pmichaud> (I've seen that scale a lot in recent months, which is what makes me think of it :-)

[17:30] <tadzik> http://nopaste.snit.ch/22156 -- could anyone take a look at this? The effect bothering me is at the very bottom

[17:31] <masak> second spectest run, now with Kodi++'s patch applied.

[17:32] <moritz_> pmichaud: btw I've pushed a branch called subst_adverbs which implements s:g/// (but not much more)

[17:32] <pmichaud> moritz_: I'll definitely take a look.

[17:32] <TimToady> or <:&foo> to be more like pair syntax

[17:32] <moritz_> it introduces some interesting failure modes, ie ignores s:unknown_pair///

[17:32] <masak> "DISAPPOINTED BUT RELIEVED FACE" -- nobody takes emoticons as seriously as the Unicode Consortium.

[17:33] <ash_> tadzik: you found a bug

[17:33] <pmichaud> masak: right, that's why I was surprised faces pain scale wasn't there :)

[17:33] <moritz_> and s:g(1)/// # can't find identifier Capture (or so) - huh?

[17:33] <ash_> rakudo: grammar Foo::Bar { }; class Foo { };

[17:33] <p6eval> rakudo 3370f0:  ( no output )

[17:33] <TimToady> or even, since : is reserved, leave off the <> to call :&foo

[17:33] <ash_> > grammar Foo::Bar { }; class Foo { };

[17:33] <ash_> Illegal redeclaration of symbol 'Foo::Bar'

[17:33] <ash_> > class Foo::Bar { }; class Foo { };

[17:33] <ash_> !class_init_11

[17:33] <tadzik> oh, great :)

[17:33] <TimToady> std: / :&foo /

[17:33] <p6eval> std 31772: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter (must be quoted to match literally) at /tmp/aRSVIiLKw9 line 1:‚ê§------> [32m/ :[33m‚èè[31m&foo /[0m‚ê§Can't call method "from" on unblessed reference at /home/p6eval/pugs/src/perl6/snap/STD.pm line 53586.‚ê§FAILED 00:01

[17:33] <p6eval> ..1‚Ä¶

[17:33] <moritz_> ash_: please submit rakudobug

[17:34] <ash_> it seems to be an issue with autovivifiying and grammars 

[17:34] <pmichaud> bare  :&foo  looks almost too close to adverbs for me

[17:34] <ash_> moritz_: will do 

[17:34] <pmichaud> i.e.,  :my,  :ignorespace, etc.

[17:34] <ash_> if you change it from grammar to class it works 

[17:34] <moritz_> yes, I'd prefer <:&foo> or <=&foo>

[17:34] <pmichaud> i.e.,   I'd almost want   :$ignorecase  to be   :ignorecase($ignorecase)

[17:34] <moritz_> ash_: as a workaround, you could try 'class Foo::Bar is Grammar'

[17:35] <pmichaud> so far I like <=&foo>  because we normally use '=' for capture to an alias anyway.

[17:35] <moritz_> aye

[17:35] <[Coke]> phenny: .u ‚îå

[17:36] *** ashleydev joined
[17:36] <ash_> tadzik: moritz_++ suggestion can give you a fix for now

[17:37] <tadzik> well, I just renamed grammar to INIfile and moved to the file with a class, but thanks

[17:37] <tadzik> btw, $.param = die "..." does not work

[17:39] <ash_> tadzik: you could override new if you want to enforce it as an argument for construction of an argument 

[17:39] <tadzik> ash_: I rather feel like checking this in BUILD, as I'm using it anyway

[17:43] <tadzik> rakudo: class foo { has $.bar; submethod BUILD { $.bar.perl.say } }; my $a = foo.new(bar => 'moo') # why?

[17:43] <p6eval> rakudo 3370f0: OUTPUT¬´Any‚ê§¬ª

[17:44] <jnthn> tadzik: You overrode BUILD

[17:44] <jnthn> tadzik: BUILD is what sets up the attributes, iirc.

[17:44] <tadzik> oh

[17:44] <jnthn> tadzik: Oh, maybe we're meant to set them if you didn't touch them in BUIlD, though.

[17:44] <tadzik> rakudo: class foo { has $.bar; submethod BUILD { nextsame; $.bar.perl.say } }; my $a = foo.new(bar => 'moo') # this way?

[17:44] <p6eval> rakudo 3370f0:  ( no output )

[17:44] <tadzik> ‚Ä¶nope

[17:45] <tadzik> so, if I want to open a file from a string which is passed to a class constructor, what's the best way to do this?

[17:47] <PerlJam> tadzik: you'll have to be a little more precise, but something like my $handle = open $filename, :r;

[17:47] <ash_> if you don't need a file handle, just slurp it

[17:47] <ash_> my $string = slurp $filename 

[17:48] <ash_> rakudo: (slurp "/etc/passwd").say # fails for security reasons

[17:48] <p6eval> rakudo 3370f0: OUTPUT¬´Operation not permitted in safe mode‚ê§  in 'Safe::forbidden' at line 2:/tmp/ddhB2nFXmI‚ê§  in main program body at line 22:/tmp/ddhB2nFXmI‚ê§¬ª

[17:48] <ash_> rakudo: my $string = slurp; $string.say 

[17:48] <p6eval> rakudo 3370f0: OUTPUT¬´Operation not permitted in safe mode‚ê§  in 'Safe::forbidden' at line 2:/tmp/2bBI7sCgKJ‚ê§  in main program body at line 22:/tmp/2bBI7sCgKJ‚ê§¬ª

[17:48] <tadzik> yeah, I know about slurp, that's what I'm going to use actually. But.. let me write it down

[17:49] <tadzik> http://nopaste.snit.ch/22160

[17:49] <tadzik> this is what I need

[17:50] *** _macdaddy joined
[17:52] <pmichaud> after thinking about it a bit more...

[17:52] <pmichaud> (1)  I think there's a lot of merit to the  <=$var> syntax to enable capturing, and we should consider it 

[17:52] <pmichaud> (2)  but it's just too complex for the common case of "I want a regex here"

[17:53] <PerlJam> tadzik: depending on how quickly you pull together your INI grammar, you might want to put it up for inclusion in Rakudo Star

[17:54] <tadzik> PerlJam: what I'm missing is section support (quite an important feature) but I wanted to fire up a working module first

[17:54] <ash_> rakudo: class Foo { has $.a; has $.b; method new($filename) { self.bless(*, a => $filename, b => $filename.flip); } }; say Foo.new('bar').b

[17:54] <p6eval> rakudo 3370f0: OUTPUT¬´rab‚ê§¬ª

[17:54] <tadzik> PerlJam: I have plenty of free time til 29, so it might end up with a success

[17:54] <pmichaud> (3)  I'm inclined to say that regexes in grammar definitions never do lexical lookup (and use <=&xyz>  if that's what you want), while regexes outside of grammar definition can have <xyz> find a lexical &xyz (and fall back to Grammar.xyz if non-existent)

[17:54] <moritz_> tadzik: btw the return value from .parse is usually called a "match object" (or short "match"), not a parser

[17:54] <tadzik> oh, ok

[17:55] <moritz_> +1 to all three points

[17:55] <ash_> rakudo: 'a' ~~ /./; say $/.WHAT

[17:55] <p6eval> rakudo 3370f0: OUTPUT¬´Match()‚ê§¬ª

[17:55] <PerlJam> pmichaud: could you elaborate on #2 a bit?

[17:55] <ash_> $/ is the current match object 

[17:56] <pmichaud> PerlJam: the example from the start of the chapter is the best elaboration

[17:56] <PerlJam> pmichaud: okay  :)

[17:56] <jnthn> #phsers in ~ 1h

[17:56] <pmichaud> having to write   =&word   to get the thing I just defined seems wrongish.

[17:56] <pmichaud> er,   <=&word>

[17:56] <pmichaud> <word>  just seems more appropriately dwimmy

[17:56] <TimToady> no, the correct approach is to somehow mix the current namespace in as the most derived grammar

[17:56] <moritz_> not sure if I'll make it to #phasers

[17:56] <Tene> rakudo: my @fibs := 1,1,{$^a + $^b} ... 50; say @fibs[0..5].perl;

[17:56] <kalve> man, trying to read this gives me a headache

[17:57] <p6eval> rakudo 3370f0: OUTPUT¬´(1, undef, undef, undef, undef, undef)‚ê§¬ª

[17:57] <Tene> rakudo: my @fibs = 1,1,{$^a + $^b} ... 50; say @fibs[0..5].perl;

[17:57] <p6eval> rakudo 3370f0: OUTPUT¬´(1, 1, 2, 3, 5, 8)‚ê§¬ª

[17:57] <tadzik> so, could someone help me with this one? http://nopaste.snit.ch/22160

[17:57] <TimToady> use regexes; or something

[17:57] <moritz_> where "current namespace" means what?

[17:57] <pmichaud> TimToady: I don't intuitively grok the full details of what you're suggesting, but I'd not be opposed to it.

[17:58] <jnthn> TimToady: Does "mix in" not imply that things from the current namespace would override those in the grammar we derive from?

[17:58] <TimToady> yes

[17:59] <TimToady> but as moritz_ points out, the scoping is a bit hard to nail down

[17:59] <pmichaud> (and I'm doubtful it can be readied for R*, fwiw)

[17:59] <jnthn> Me too

[17:59] <jnthn> Well

[18:00] <pmichaud> somehow "mix in" doesn't feel rightish to me, though.

[18:00] <jnthn> I'm more worried about the side-effects we may find it has I guess.

[18:01] <pmichaud> but I do see how it could potentially clarify a lot of issues, if we can get the scoping right.

[18:01] *** kensanata joined
[18:02] <ash_> rakudo: class Foo { has $.filename; has $.something_else; method new($filename) { self.bless(*, filename => $filename, something_else => $filename.flip); } }; say Foo.new('bar').something_else; # tadzik slurp in the new maybe? 

[18:02] <p6eval> rakudo 3370f0: OUTPUT¬´rab‚ê§¬ª

[18:02] <TimToady> it's really almost a slang issue.  when I say /.../, I really mean the language derived thusly

[18:02] <[particle]> where is the csv file used to generate the rakudo test passing status?

[18:02] <pmichaud> agreed.

[18:02] <pmichaud> and when I say    grammar B { ... }    in some sense I'm deriving from that current slang

[18:02] <pmichaud> as opposed to deriving from Grammar

[18:02] <[particle]> ooh, and now that i think about it, where is the web home for rakudo *, with distro test status, etc?

[18:02] <tadzik> ash_: and then I'd be able to use BUILD anyway, yep?

[18:03] <ash_> yea

[18:03] <pmichaud> [particle]: web home for R* will likely be rakudo.org .

[18:03] <ash_> BUILD and new are orthogonal 

[18:05] <moritz_> http://perlgeek.de/blog-en/perl-6/object-construction-and-initialization.html

[18:05] <TimToady> well, an explicit grammar takes its derivation from its ISA; the current slang would only influence the language you're writing in, not the language you're writin gabout

[18:05] <pmichaud> PerlJam / moritz_ :  in the meantime, I suggest we change the book example to use    my $word = token { \w+ [ \' \w+ ]? }     to avoid &word altogether for now.

[18:05] *** justatheory left
[18:05] <pmichaud> TimToady: okay, I can agree with that also.

[18:05] <TimToady> but from a user point of view, it's augment slang Regex { regex ...; token ;;; }

[18:05] *** justatheory joined
[18:06] <moritz_> pmichaud: but then we still have to do <word=$word> to get capturing done, no?

[18:06] <TimToady> and then the rest of that scope uses the Regex slang with those "macros"

[18:06] <pmichaud> moritz_: yes.  Or maybe we can get the <=$word> syntax approved.

[18:06] <TimToady> augment sort of being the wrong word for slang augmentation

[18:06] <moritz_> pmichaud: that's exactly what I want to avoid, because it*s *SO* clumsy

[18:06] <TimToady> because it's really lexically scoped, not monkey-typing

[18:06] <moritz_> with <=$word> it would work better

[18:07] <masak> let's see... #phasers in 24?

[18:07] <moritz_> masak: jnthn meant in 54

[18:07] <jnthn> I had it as in ...that.

[18:07] <pmichaud> moritz_: I think <word=$word>  is far easier to explain to a newbie than trying to figure out the relationship between    my token word { ... }    and <&word>  or <=&word>

[18:07] <masak> #phasers in 54. goodie.

[18:07] <jnthn> masak: ooh you'll has wifis still?

[18:07] <jnthn> masak: Or internets at least? :-)

[18:08] <moritz_> pmichaud: I disagree. I'd feel obliged to explain why it feels so clumsy, and contains so much repetition

[18:08] <pmichaud> moritz_: in which case that's probably not a good first example anyway :-)

[18:08] <pmichaud> at least, not until we get the handling of anonymous grammars correct per TimToady++

[18:08] <TimToady> 'nuther idea.  regex declarator inside a grammar adds to meta-object, outside adds to current regex slang

[18:09] <pmichaud> TimToady: oh.  I thought that's what you meant above,a ctually.

[18:09] * moritz_ panics

[18:09] <PerlJam> we could modify that example and take out the "named regex" section of the regex chapter entirely and leave it to the grammars chapter to explain those.  (sort of ignore lexical regex for a while)

[18:09] <[particle]> so what happened in the past week that reduced rakudo's spectest count drastically?

[18:09] <moritz_> [particle]: refactored trig tests

[18:10] <[particle]> ok, figured that. good.

[18:10] <pmichaud> moritz_: oh, is that the cause?

[18:10] <TimToady> <foo=&bar> is fine for R*

[18:10] *** envi^home left
[18:10] <moritz_> PerlJam: I don't want that. Because the grammar chapter is hard to swallow anyway

[18:10] <pmichaud> TimToady: I agree.

[18:10] <moritz_> so is <foo> picking up lexicals now officially dead?

[18:11] <tadzik> rakudo: class A { has $.param; method new(Str $a) { self.bless(*, param => $a) }; submethod BUILD { say $.param.perl } }; my $foo = A.new('asd')

[18:11] <p6eval> rakudo 3370f0: OUTPUT¬´Any‚ê§¬ª

[18:11] <TimToady> moritz_: yes

[18:11] <tadzik> ash_: ‚Üë, am I doing it wrong?

[18:11] <pmichaud> (I did quite a bit of book review on the plane yesterday, but didn't get to the grammars chapter)

[18:11] * moritz_ beats a dead horse

[18:11] <[Coke]> http://trac.parrot.org/parrot/ticket/1707

[18:11] <pmichaud> moritz_: we'll likely have something that replaces it, but they won't be lexical.

[18:11] <[Coke]> (rakudobug with a parrot core dump special)

[18:11] <TimToady> the slang is what's lexical

[18:12] <TimToady> we can decide later how regex declarations can relate to the current Regex slang

[18:12] <jnthn> [Coke]: Huh, what lame computer doesn't have 2325622477335777280 bytes of RAM available? :-)

[18:13] <jnthn> [Coke]: Getting a stack trace would be good.

[18:13] <jnthn> (C-level)

[18:14] <PerlJam> TimToady: what about <=&named_regex> capturing?

[18:14] <moritz_> that would save a lot of typing to begin with

[18:14] <TimToady> PerlJam: that is also probably dead for now

[18:15] <PerlJam> :-(

[18:15] * pmichaud checks the book

[18:15] <[Coke]> jnthn: pinged him for one.

[18:16] <jnthn> [Coke]++

[18:19] *** eternaleye joined
[18:20] <PerlJam> I guess if we removed the first example from the regex chapter and explain named regex better in that section of the chapter and added some minor fixups throughout, using <foo=&foo> wouldn't be too bad.

[18:20] <pmichaud> PerlJam: yeah, that's what I'm thinking

[18:20] <moritz_> so, what should be leading example in that section instead?

[18:20] <pmichaud> I'm thinking that first example is a little too stark to be a first example.

[18:20] <PerlJam> moritz_: dunno.

[18:20] <pmichaud> it's likely to frighten newbies off

[18:21] <moritz_> that's why I wanted to a nicer syntactic solution

[18:21] <pmichaud> even with a nicer syntactic solution like <=&xyz>  I think it could scare them off.   It requires too many leaps in knowledge.

[18:21] <pmichaud> there are quite a few places like that in the book that I've found thus far.

[18:22] <PerlJam> pmichaud:  in general the chapters are "here's a complete working example, now let me explain it in detail"

[18:23] <pmichaud> PerlJam: that probably needs to be made more explicit in each chapter, then.

[18:23] <moritz_> I guess that's a trade-off you have to make when you want the intitial examples to be both useful and idiomatic

[18:23] *** macroron joined
[18:23] <moritz_> I know it's problematic, but it's not so easy to find better examples eitehr

[18:23] <pmichaud> moritz_: well, we *do* expect that example to work someday

[18:23] <pmichaud> i.e.,

[18:24] <pmichaud> regex word { ... }

[18:24] <pmichaud> regex dup { <word> \W+ $<word> }

[18:24] <pmichaud> if / <dup> /

[18:24] <moritz_> yes, but it doesn't

[18:24] <moritz_> and the examples should be runnable

[18:24] <pmichaud> it's just that they won't be "lexicals", and it won't happen in time for R*

[18:24] <moritz_> so it's a moot point wrt the book

[18:24] <pmichaud> right

[18:25] <TimToady> maybe 'my regex' always adds to the current slang

[18:25] <pmichaud> I'd prefer 'my' continue to create a lexical regex

[18:26] <pmichaud> (which you get to via &regex)

[18:26] <pmichaud> and bare 'regex' adds to the current slang, in much the same way that defining a new operator modifies a slang

[18:27] *** hercynium left
[18:27] <pmichaud> although there's some inconsistency with that approach, I admit

[18:27] <TimToady> possibly confusing inside a grammar, if you're trying to mod the slang instead

[18:27] <pmichaud> do we have an explicit "mod the slang" syntax?

[18:27] <PerlJam> maybe modding the slang .... blah  what pm said

[18:28] <TimToady> currently augment slang, but I don't really like using augment that way

[18:28] <pmichaud> I'm afk for a bit to fetch noms for the week.  bbi30

[18:28] <PerlJam> (I was typing "maybe modding the slang needs its own declarator or something")

[18:28] <TimToady> pmichaud: where

[18:28] <pmichaud> yeah, "augment slang" seems all wrong.

[18:28] <pmichaud> TimToady: I'm just heading to walgreens up the street from me to get snacks and all-important Dr Pepper to keep in the room :)

[18:28] <pmichaud> (I'm at the LQ again)

[18:29] <TimToady> mkay

[18:29] <pmichaud> I don't have explicit lunch plans yet, but will try to be back for #phasers in 31

[18:29] <pmichaud> (lunch after that, likely)

[18:29] *** _macdaddy left
[18:30] <pmichaud> afk

[18:31] <tadzik> http://nopaste.snit.ch/22167 can someone show me the way with this one?

[18:32] <lue> y o hai o/

[18:32] <tadzik> s/#12/#14/

[18:32] <tadzik> oh hai

[18:33] *** gbacon left
[18:34] <tylercurtis> tadzik: "s/#12/#14/" doesn't parse in Perl 6. ;)

[18:34] <tadzik> oh come on ;)

[18:34] <PerlJam> heh

[18:34] *** dolmen joined
[18:35] <tadzik> I remember some Perl 6 module using sub new for something

[18:35] <pugssvn> r31773 | tene++ | Fix minor typo 

[18:36] <sorear> good * #perl6

[18:36] *** sorear sets mode: +ov tylercurtis pugssvn

[18:36] <Tene> Hi!

[18:36] <[particle]> tadzik: you define method new with a signature making $a required (using a trailing !)

[18:36] <masak> \o/ sorear 

[18:36] <sorear> TimToady: Did you see the :my query?

[18:36] <[particle]> tadzik: you should look at some examples in t/spec, grep for 'required', 'argument', 'class' etc

[18:37] <tadzik> [particle]: will take a look

[18:38] <ash_> moritz_: i put that bug in, it seems to only happen when you use 'use' 

[18:38] <TimToady> sorear: yes, but don't really have much time to think about it till after I'm done writing my talk

[18:38] <ash_> bug 76606 if your curious

[18:38] <tadzik> bleh, that's ugly

[18:38] <TimToady> but to the first approximation, I'd just as soone keep the my coping rules limitied to curlies

[18:39] <TimToady> you can declare lexicals from inside strings too

[18:39] <masak> ingy: Just Another Crazy Bandaid Rakudo Hacker :P

[18:40] <masak> rakudo: "foo$(my $x = 42)bar"; say $x

[18:40] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Redeclaration of symbol $x at line 22, near " = 42)bar\""‚ê§¬ª

[18:40] <masak> hm, redeclaration?

[18:41] <masak> std: "foo$(my $x = 42)bar"; say $x

[18:41] <p6eval> std 31772: OUTPUT¬´ok 00:01 118m‚ê§¬ª

[18:41] <masak> rakudo: "foo$(my $x)bar"; say $x

[18:41] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Redeclaration of symbol $x at line 22, near ")bar\"; say"‚ê§¬ª

[18:41] <[particle]> what's that dollar for?

[18:41] <masak> [particle]: variable interpolation

[18:41] <[particle]> oh, i missed the quotes.

[18:41] <ingy> masak: :)

[18:42] <masak> ingy: I recognize the feeling. it's like, it's really good and really bad, with lots of promises of getting better soon.

[18:43] <ingy> masak: the best part of perl6 is the irc channel

[18:43] <ingy> :)

[18:43] <ash_> rakudo: my $x; "foo$($x = 3)bar"; say $x; 

[18:43] <timbunce> Is there a perl5-to-perl6 concept map somewhere? ie something that says "if you'd write ... in perl5 then in perl6 you probably want to write ... or ..."?

[18:43] <p6eval> rakudo 3370f0: OUTPUT¬´3‚ê§¬ª

[18:43] <masak> ingy: yeah, the language sucks. :P

[18:43] <PerlJam> ingy: wait until we have CPAN!  :)

[18:43] <masak> ash_: o.O

[18:43] * masak submits rakudobug

[18:43] <ash_> timbunce: http://perlcabal.org/syn/Differences.html 

[18:43] * ingy owns bpan.org and is looking for a purpose

[18:44] <masak> ash_: oh. you had 'my $x' before the string. nvm

[18:44] <masak> rakudo: "foo$($x = 3)bar"; say $x;

[18:44] <timbunce> ash_++

[18:44] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Symbol '$x' not predeclared in <anonymous> (/tmp/bOCGOeX_Js:22)‚ê§¬ª

[18:44] <ash_> masak: i was just seeing if what you said works if you pre-declare $x 

[18:44] <tylercurtis> timbunce: http://perlgeek.de/en/article/5-to-6 might serve that purpose to some extent.

[18:44] <ingy> timbunce: wanna pair program with me today on some p6 stuff

[18:45] <moritz_> tadzik: I think you've hit a rakudobug. anyway,  has $.b = 2 * $.a; should work just fine

[18:45] <ingy> I know enough to be dangerous :)

[18:45] <masak> ash_: right. but the experiment was to declare a variable inside a string which survived to the outside ;)

[18:45] <tadzik> moritz_: so that was the right way to do it?

[18:45] <timbunce> ingy: :)

[18:45] <ash_> yeah, i know, it was more a sanity check 

[18:45] <[particle]> a little learning is a dangerous thing.

[18:45] <PerlJam> ingy: perhaps together, you and timbunce could be more than dangerous

[18:45] <moritz_> tadzik: yes

[18:45] <ingy> PerlJam++

[18:45] <PerlJam> ingy: maybe that's "deadly"?  :>

[18:45] <tadzik> moritz_: I expected BUILD works like in Moose, so the parameters are alredy set and stuff

[18:45] <tadzik> moritz_: that's how it should work?

[18:46] * ingy is halfway done with the blog post now

[18:46] <ingy> sitting at Powell's cafe. here with @TimToady

[18:46] <tylercurtis> tadzik: Perl 6 BUILD lets you take whatever parameter signature you want. However, that requires that you specify what signature you want.

[18:46] *** cxreg left
[18:47] <tadzik> tylercurtis: ah, so I don't bless anymore, but I have to set parameters, right

[18:47] <tadzik> ?

[18:47] <ingy> tethered to you via android, cuz teh publik wifi sux

[18:47] <timbunce> It takes 1 minute of cpu time to compile DBDI roles and classes, and there's hardly any actual code yet :(

[18:48] <ingy> timbunce: seriously though, if I see you later, let's spend an hour...

[18:48] <PerlJam> timbunce: btw, there is also this: http://perlgeek.de/blog-en/perl-5-to-6 

[18:48] <lue> quick question: does =:= still exist :)

[18:48] <timbunce> PerlJam: yes, tylercurtis++ mentioned it a moment ago. Helpful, thanks. 

[18:48] <PerlJam> ah, missed it

[18:49] <TimToady> lue: it does.  don't use it.

[18:49] <lue> rakudo: my $a = 3; my $b := $a; say VAR($a) === VAR($b)

[18:49] <p6eval> rakudo 3370f0: OUTPUT¬´Could not find sub &VAR‚ê§  in main program body at line 22:/tmp/bjDnK0bCYf‚ê§¬ª

[18:49] <tylercurtis> rakudo: class Foo { has $.a; has $.b; submethod BUILD (:$.a!, $.b = $.a * 2) { } }; my $a = Foo.new(a => 5); say $a.a; say $a.b;

[18:49] <p6eval> rakudo 3370f0: OUTPUT¬´===SORRY!===‚ê§Can't put required parameter after variadic parameters at line 22, near ") { } }; m"‚ê§¬ª

[18:50] <tylercurtis> rakudo: class Foo { has $.a; has $.b; submethod BUILD (:$.a!, :$.b = $.a * 2) { } }; my $a = Foo.new(a => 5); say $a.a; say $a.b;

[18:50] <p6eval> rakudo 3370f0: OUTPUT¬´Cannot modify readonly value‚ê§  in '&infix:<=>' at line 1‚ê§  in 'Foo::BUILD' at line 6255:CORE.setting‚ê§  in 'Foo::BUILD' at line 22:/tmp/rxwDajrsmU‚ê§  in main program body at line 22:/tmp/rxwDajrsmU‚ê§¬ª

[18:50] <tadzik> moritz_: http://wklej.org/id/366918/ that should be a working Perl 6 code?

[18:50] <tylercurtis> rakudo: class Foo { has $.a; has $.b; submethod BUILD (:$!a!, :$!b = $.a * 2) { } }; my $a = Foo.new(a => 5); say $a.a; say $a.b;

[18:50] <p6eval> rakudo 3370f0: OUTPUT¬´5‚ê§10‚ê§¬ª

[18:50] <tylercurtis> tadizk: ^

[18:50] <tadzik> oh, great

[18:51] <timbunce> ingy: it's probably too soon at the moment given the kind of thing I'm doing right now. Should be more useful in a couple of days. Catch me thursday or friday.

[18:51] <tadzik> tylercurtis: what about this one: http://wklej.org/id/366918/ ?

[18:52] <tylercurtis> tadzik: the problem with that is that $.a and $.b are readonly by default. You need to ether declare them "is rw" or use $!a/$!b instead of the accessors.

[18:52] <masak> #phasers in 8.

[18:52] <tadzik> tylercurtis: where are they readonly, in BUILD?

[18:52] <tadzik> ah, oh god. Of course

[18:53] <tadzik> damn

[18:53] <ash_> tadzik: they are always read only if you use the accessor without 'is rw'; 

[18:53] <tadzik> yeah, I know, looks like I forgot about it

[18:54] <ash_> if you change Foo.new(5) to Foo.new(a => 5); things should work 

[18:54] <tadzik> but I wasn't planning to pass it via name

[18:54] <ash_> then you need to override new 

[18:55] <PerlJam> tadzik: new is always expecting named things unless you override it.

[18:55] <tadzik> so what's BUILD signature for?

[18:55] <tadzik> if I need to override new anyway?

[18:56] <TimToady> it's for binding the args that BUILDALL will always send as named pairs

[18:57] <TimToady> because BUILDALL isn't in the business of trying to coordinate the positional parameters of N different derived classes

[18:57] <pmichaud> back from nom fetch (epic fail btw)

[18:58] <PerlJam> pmichaud: they didn't have Dr Pepper?!?  :)

[18:58] <pmichaud> only in cans

[18:58] <tadzik> Symbol 'self' not predeclared in new (class.pl:8)

[18:58] <pmichaud> which is very inconvenient for carrying around the conference venue

[18:58] <tadzik> self.bless(*, a => $a) in sub new. What's wrong here?

[18:58] <pmichaud> also, they didn't have milk

[18:59] <pmichaud> or about 3 or 4 other things I was planning to buy

[18:59] <lue> pmichaud: D:

[18:59] <TimToady> there's a Safeway just north of Lloyd Center

[18:59] <pmichaud> (they had spots for them... they were just out of stock)

[18:59] <pmichaud> yeah, Safeway is my next hit

[18:59] <pmichaud> it's a bit of a further walk from here

[18:59] <ash_> tadzik: can you update your nopaste with the current code your working with?

[19:00] <tadzik> http://wklej.org/id/366921/ BUILD might be still broken, but it breaks in new now

[19:00] <tadzik> ash_: ‚Üë

[19:00] <ash_> its method, not sub

[19:00] <ash_> sub's don't have a self 

[19:00] <tadzik> oh, sure

[19:00] <TimToady> new needs to be amethod

[19:01] <tylercurtis> tadzik: I think BUILD still needs a signature, too.

[19:01] <tadzik> the named one?>

[19:01] <jnthn> #phasers!

[19:01] *** mberends joined
[19:01] <TimToady> if the names correspond to your attributes, you can use the auto-generated BUILD

[19:01] <TimToady> BUILD must be a submethod, btw

[19:01] <TimToady> even more than new must be a method

[19:02] <tylercurtis> tadzik: Although in this case, you could just do "method new (Int $a) { self.bless(*, a => $a, b => $a * 2); }" without problem, I think.

[19:02] <tylercurtis> TimToady: he already has BUILD as a submethod, no?

[19:02] <ash_> yeah, then you don't need to do a BUILD 

[19:02] <TimToady> I'm not actually looking at his code, since I officially don't have time to do that.  :)

[19:03] <timbunce> If I want to return an undef Str I should just return Str;, right? But then I'm surprised to find that say foo() prints "Str()" rather than complain about undef. Do I just need to get used to this?

[19:03] * _sri wonders why rakudo is not yet in homebrew (because parrot is)

[19:03] <ash_> TimToady your pretty close to spot on for most of the problems he's had, (but BUILD was already a submethod :P )

[19:04] <TimToady> well, I didn't say his wasn't a submethod, now did I? :P

[19:04] <ash_> timbunce: undef is spelled Mu 

[19:04] <TimToady> sometimes

[19:04] <TimToady> std: undef

[19:04] <PerlJam> ash_: He wants an undef string though

[19:04] <p6eval> std 31772: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of undef as a value; in Perl 6 please use something more specific:‚ê§       Mu (the "most undefined" type object),‚ê§   an undefined type object such as Int,‚ê§    Nil as an empty list,‚ê§    :!defined as a matcher,‚ê§  Any:U as a type

[19:04] <p6eval> ..constraint‚ê§       or fail() as‚Ä¶

[19:04] <TimToady> an undef string is spelled Str

[19:05] <ash_> oh

[19:05] <ash_> i see, you mean .defined then 

[19:05] <ash_> rakudo: say Str.defined, "foo".defined

[19:05] <p6eval> rakudo 3370f0: OUTPUT¬´01‚ê§¬ª

[19:05] <TimToady> undefs are typed in Perl 6

[19:05] <ingy> is there a canonical purl for p6rules?

[19:05] <ingy> *url

[19:06] <jjore_> Is it expected that I get "Malformed UTF-8 string" exceptions when reading text files like perl5's malloc which apparently does something wrong in the string "The Bridge of Khazad-D\xFBm"

[19:06] <ingy> and is that the official term? "Perl 6 Rules"?

[19:06] <ingy> hi jjore_ 

[19:06] <timbunce> perhaps there's a need for some way to tell say how undefs should be handled.

[19:06] <PerlJam> ingy: Perl 6 does rule!  :)

[19:06] <jjore_> Hi ingy

[19:06] <TimToady> no, that's the official slogan.  they're called Perl 6 Regexes

[19:07] <TimToady> see S05

[19:07] <ingy> TimToady: is s05 the best reference url?

[19:07] <ingy> jjore_: are you in pdx?

[19:07] <TimToady> it is if you follow the highlight from the ir clog

[19:07] <jjore_> Nope.

[19:07] <jjore_> Just Seattle

[19:07] <ingy> :'(

[19:07] <jjore_> Yeah, $work.

[19:08] <ingy> jjore_: I'll be back on Wednesday (I know you miss me)

[19:08] <jjore_> Well I do, however I never see you even when you are in town.

[19:08] <jjore_> I have to go to far-flung places to see you.

[19:08] <TimToady> which will send you to http://perlcabal.org/syn/S05.html

[19:08] *** justatheory left
[19:09] *** lue is now known as mlue

[19:09] <ash_> std: my $a = Str but ''; say $a # should print nothing 

[19:09] <p6eval> std 31773: OUTPUT¬´ok 00:01 118m‚ê§¬ª

[19:09] <ash_> but its not working right now in rakudo 

[19:10] <jjore_> you know, just fyi, the unicode on #perl6 really screws with my IRC client. :-(

[19:10] <TimToady> fix your client

[19:11] <TimToady> it's open source right?  :)

[19:11] <ash_> .u frown

[19:11] <phenny> U+2322 FROWN (‚å¢)

[19:11] <sorear> ¬ª√∂¬´ is our frient

[19:11] <masak> jjore_: see topic :)

[19:11] <masak> sorear: isn't it 'prient'? :)

[19:12] *** cxreg joined
[19:12] *** kalve left
[19:13] <jjore_> My client is open source. Heck, my client is the editor for itself so I can hot-fix it while it runs.

[19:13] <jjore_> but er, lunch apparently &

[19:13] <TimToady> √∂/

[19:14] <masak> yet another vital open source fix foiled by nom.

[19:14] <masak> rakudo: say "OH HAI".bytes

[19:14] <p6eval> rakudo 3370f0: OUTPUT¬´6‚ê§¬ª

[19:14] <masak> Buf should have a .bytes method, I guess. should Str?

[19:15] <masak> and I know we've talked about this, but it's hard and my brain is non-sticky sometimes.

[19:15] <TimToady> perhaps "OH HAI" doesn't feel like committing one way or the other yet

[19:15] *** rurban joined
[19:15] <masak> does that mean "no, Str shouldn't have a .bytes method"?

[19:16] <TimToady> no, it means "yes, Str shouldn't have a .bytes method"  :)

[19:16] *** mlue is now known as lue

[19:16] <masak> TimToady: so if I go ahead and remove the .bytes method from Str, have I understood you 50% or 100% ?

[19:17] <tadzik> ===SORRY!=== You can not add an attribute to a module; use a class or role

[19:17] <tadzik> what does he want? Didn't even show a line

[19:17] <masak> tadzik: you tried to do 'has' in a non-class/role.

[19:17] <tadzik> ‚Ä¶no I didn't :) will show the code

[19:17] <masak> nopaste!

[19:17] <tadzik> http://wklej.org/id/366935/

[19:17] <tadzik> whoops, too late

[19:18] <pmichaud> it should be possible to implement =:= without Var.

[19:18] <tadzik> on 'use Config::INI' rakudo cries as I showed

[19:18] <pmichaud> er, without VAR()

[19:18] <ash_> line 2

[19:18] <tylercurtis> tadizk: "	has $.file;"

[19:18] <ash_> has $.file

[19:18] <tadzik> oh

[19:18] <tadzik> wtf is it doing there

[19:18] <ash_> i think you mean our 

[19:18] <ash_> or maybe it shouldn't be there...

[19:18] <tadzik> no, I didn't mean it at all. Suprise keystrokes in vim I guess

[19:18] <[particle]> vim curses in perl6?

[19:19] <tadzik> why curses?

[19:19] <tadzik> must have 'p' accidentally

[19:19] <ash_> tadzik: did you know you can specify :actions for a grammar? 

[19:20] <tadzik> ash_: nope, what does it do?

[19:20] <ash_> GrammarName.parse($string, :actions(Actions.new)); 

[19:20] <ash_> whenever it parses a token/rule/regex it invokes the action associated with the token/rule/action

[19:20] <takadonet> tadzik: you will love them :)

[19:20] <ash_> regex* 

[19:21] <tadzik> oh

[19:21] <tadzik> triggers it, yeah?

[19:21] <takadonet> yes

[19:21] <tadzik> http://wklej.org/id/366937/ another problem

[19:21] <ash_> allowing you to do any magic you need mixed right into the parsing 

[19:21] <tadzik> so in this example, where does Actions.new object go?

[19:21] <tylercurtis> tadzik: And you can use the actions to build up a AST or similar from the parse, if that's necessary. 

[19:21] <Tene> tadzik: http://perl6advent.wordpress.com/2009/12/21/day-21-grammars-and-actions/

[19:21] <ash_> Tene++ for giving a real example 

[19:22] <Tene> tadzik: that's a quoting problem in your shell.

[19:22] <tadzik> /o\ I'm failing today

[19:22] <Tene> tadzik: look, you used the ' quote for the outer, and then ' to try to quote inifile.

[19:22] <tadzik> yeah, I see :(

[19:22] <Tene> but it just ended the shell quote.

[19:22] <tadzik> what a day

[19:22] <Tene> :)

[19:22] <tadzik> but at least this grammar subset works :)

[19:23] *** timbunce left
[19:23] <TimToady> masak: yes, you may remove it; my point was just that there could be an ascii buf type for literals that also knows how to promote to Str

[19:23] <Tene> ash_: That post was inspired by stuff I was really doing at work at the time.

[19:24] <masak> TimToady: oki. removing.

[19:24] <TimToady> just as a utf8 buffer knows how to promote

[19:24] <ash_> Tene: neat, even better, an actual example based off real work 

[19:24] <sorear> rakudo: say (1.0 .. 10.0).flat.Str

[19:25] <Tene> the real source I had was XML, and the real program I wrote was in Perl 5 and used XML::Parser, iirc.

[19:25] <p6eval> rakudo 3370f0: OUTPUT¬´1 2 3 4 5 6 7 8 9 10‚ê§¬ª

[19:25] <sorear> rakudo: say (1.0 .. 10.5).flat.Str

[19:25] <p6eval> rakudo 3370f0: OUTPUT¬´1 2 3 4 5 6 7 8 9 10‚ê§¬ª

[19:25] <sorear> rakudo: say (10.5 .. 1).flat.Str

[19:25] <p6eval> rakudo 3370f0: OUTPUT¬´‚ê§¬ª

[19:25] <sorear> rakudo: say (1.5 .. 10.0).flat.Str

[19:25] <p6eval> rakudo 3370f0: OUTPUT¬´1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5‚ê§¬ª

[19:26] <TimToady> arguably, defaulting to the indicated precision would be more useful, I suppose

[19:27] <sorear> well, I actually care about Num

[19:27] <TimToady> say (10.0).perl

[19:27] <TimToady> rakudo: say (10.0).perl

[19:27] <p6eval> rakudo 3370f0: OUTPUT¬´10/1‚ê§¬ª

[19:27] <TimToady> I guess it always reduces, though, so you lose the info

[19:27] <sorear> but really what I'm checking is how infix:<..> deals with 1. reversed arguments 2. dense types

[19:27] <sorear> (in list context)

[19:27] *** rotterdam joined
[19:28] *** rotterdam left
[19:28] <TimToady> reversed will always produce Nil, and "add 1" is the simpleminded rule, on the assumption anything more complicated should be done with ... anyway

[19:30] <ash_> rakudo: say 1.0 ... 10.5

[19:30] <p6eval> rakudo 3370f0: OUTPUT¬´12345678910‚ê§¬ª

[19:30] <ash_> rakudo: say 1.5, 2.0 ... 10

[19:30] <p6eval> rakudo 3370f0: OUTPUT¬´1.522.533.544.555.566.577.588.599.510‚ê§¬ª

[19:31] <ash_> i have no idea what i just did...

[19:31] <ash_> oh

[19:31] <ash_> its just missing spaces

[19:31] <ash_> nevermind

[19:31] <sorear> I think you just asked p6eval's phone number.

[19:31] <ash_> lol

[19:34] <mathw> Evening

[19:35] <masak> mathw! \o/

[19:35] <Tene> rakudo: say 8675309

[19:36] <p6eval> rakudo 3370f0: OUTPUT¬´8675309‚ê§¬ª

[19:36] <dalek> niecza: cb5b9dd | sorear++ | Kernel.cs:

[19:36] <dalek> niecza: Allow for subclassing Sub

[19:36] <dalek> niecza: review: http://github.com/sorear/niecza/commit/cb5b9ddd658b4c3229700596740c861b458a4c91

[19:36] <dalek> niecza: 5b329a4 | sorear++ | rxwork.pl:

[19:36] <dalek> niecza: Implement class Regex & smart-matching

[19:36] <dalek> niecza: review: http://github.com/sorear/niecza/commit/5b329a43c1baa5042d579c9d5928af6c32807397

[19:36] *** rurban left
[19:37] *** gbacon joined
[19:37] <mathw> hey masak

[19:38] *** plainhao left
[19:38] <mathw> time for form-fixing again

[19:38] <pugssvn> r31774 | moritz++ | [evalbot] niecza VERSION 

[19:40] <tadzik> method postcircumfix:<< >> should work for an object like $object<asd>?

[19:40] <mathw> hmm

[19:41] <mathw> how to do this

[19:41] <tadzik> it acts funny

[19:41] <Tene> <> is the autoquoting form of postcircumfix:<{ }>

[19:41] <Tene> you want to override the latter, not the former.

[19:41] <tadzik> http://wklej.org/id/366945/

[19:41] <tadzik> well, same was happening for the former

[19:41] *** i__ left
[19:44] <Tene> Hmm.  Dunno.

[19:44] <tadzik> bug?

[19:44] <Tene> Probably, yes.

[19:44] <Tene> It certainly should not fail like like that.

[19:44] <tadzik> it's alredy two bugs today, let's wait til moritz_ gets back from #phasers

[19:45] * moritz_ upgrades one of his computers to a newer debian version in the hope of then being able to build the book

[19:45] <pmichaud> actually, you probably want to override "at_key"  instead of postcircumfix:<{ }>

[19:45] <moritz_> what exactly is at_key?

[19:45] <pmichaud> return a value at a given key location

[19:46] <pmichaud> it's what postcircumfix:<{ }> calls when it has a single key to resolve

[19:46] <moritz_> ah

[19:46] <pmichaud> if you override postcircumfix:<{ }>, you're basically taking over all slicing forms

[19:46] <moritz_> evalbot control restart

[19:46] *** p6eval left
[19:46] <ash_> so... method at_key($key) { } ? 

[19:46] *** p6eval joined
[19:46] <pmichaud> ash_: yes.

[19:47] <ash_> rakudo: class F { method at_key($b) {  'got it' } }; my F $f .= new; say $f<a>;

[19:47] <p6eval> rakudo 3370f0: OUTPUT¬´got it‚ê§¬ª

[19:47] <tadzik> same effect

[19:47] <ash_> rakudo: class F { method at_key($b) {  'got it ' ~ $b } }; my F $f .= new; say $f<a>;

[19:47] <p6eval> rakudo 3370f0: OUTPUT¬´got it a‚ê§¬ª

[19:47] <tadzik> and I'm not evev calling

[19:47] <dalek> book: aa1199a | pmichaud++ | docs/release-guide.pod:

[19:47] <dalek> book: Update with pmichaud release date.

[19:47] <dalek> book: review: http://github.com/perl6/book/commit/aa1199a3d15e504e588bb2a849a27ea9097cc6f8

[19:47] <ash_> your error was happening in BUILD though...

[19:48] <tadzik> hmm

[19:48] <tadzik> what can cause this?

[19:49] <ash_> might be related to your for loop

[19:49] <ash_> take that out and see if it dies still 

[19:49] <tadzik> no, it lives

[19:50] <tadzik> funny, all the code works if it's not inside the class

[19:50] <ash_> hmm

[19:50] <ash_> might be another bug :P 

[19:51] *** mmcleric_ joined
[19:51] *** mmcleric left
[19:51] *** mmcleric_ is now known as mmcleric

[19:51] <tadzik> saying [0] works

[19:52] <tadzik> and elems prints 4, so it's finite

[19:52] <jnthn> rakudo: (1,2,3,4,5).grep(* > 2).grep(* < 5).perl.say

[19:52] <p6eval> rakudo 3370f0: OUTPUT¬´Cannot resume dead coroutine.‚ê§  in 'Any::join' at line 1‚ê§  in 'List::perl' at line 2528:CORE.setting‚ê§  in main program body at line 22:/tmp/tP945QDNyS‚ê§¬ª

[19:53] <tadzik> %!contents<toplevel>{$param<key>} = $param<value>; this fails

[19:54] <tadzik> assigning anything fails

[19:54] <pmichaud> inside of BUILD, is %!contents already initialized at this point?

[19:54] <tadzik> say $param<key>.WHAT; return Match()

[19:54] *** pyrimidine joined
[19:54] <tadzik> pmichaud: I don't think so

[19:54] <tadzik> it isn't being touched before

[19:54] <pmichaud> tadzik: I mean, is it already a Hash?

[19:55] <pmichaud> or at least an Any?

[19:55] <tadzik> well, it has a sigil

[19:55] <tadzik> if Perl 6 hasn't made it a hash the no

[19:55] *** takadonet left
[19:55] *** whiteknight joined
[19:55] <tadzik> now %!contents<toplevel>{$param<key>.Str} = $param<value>.Str; works

[19:56] <tadzik> so just %hash{Match()} is not a good idea

[19:56] *** eternaleye left
[19:56] <tadzik> it didn't stringify by itself

[19:57] *** eternaleye joined
[19:58] <pmichaud> afaik, it's not supposed to stringify by itself 

[19:58] <pmichaud> (but perhaps there was a spec change there)

[19:58] <tadzik> it doesn't, there have to be .Str in both calls

[19:59] <tadzik> but I have yet another something, will paste

[20:00] <tadzik> http://wklej.org/id/366953/

[20:00] <tadzik> Before returning .perl shows the hash, outside the class it Any

[20:02] <tadzik> perhaps some issue with returning a private value?

[20:02] <[Coke]> (Perl 6 R* Us)

[20:03] *** mberends left
[20:03] *** mberends joined
[20:06] *** patspam joined
[20:07] <moritz_> any objections to filtering out "." and ".." from dir($path) ?

[20:08] <pmichaud> that feels wrong to me.

[20:08] <moritz_> why?

[20:08] <pmichaud> because they're entries in the directory, same as others.

[20:08] <moritz_> but how often to do you actually need to use them?

[20:09] <moritz_> nearly all of my scripts that recurse throug directories, list them etc. contain separate logic just to ignore them

[20:09] <tylercurtis> moritz_: once Path is implemented, I'm pretty sure it's specced to have a method for that.

[20:09] <PerlJam> moritz_: give dir an adverb to ignore/include them

[20:09] <pmichaud> I'd prefer there to be an adverb/option for including/excluding them, then.

[20:09] <pmichaud> but simply excluding them always feels wrong.

[20:10] <moritz_> would dir($path, :all) work for you?

[20:10] <pmichaud> (and once there's an adverb to include/exclude, it seems like include/exclude should be a Matcher)

[20:10] <pmichaud> with a default that excludes . + ..

[20:10] <PerlJam> moritz_: sure

[20:10] * tylercurtis misunderstood.

[20:11] <[Coke]> if rakudo * is going to bundle the perl6 compiler, what is the R* executable going to be called?

[20:11] <moritz_> pmichaud: so getting them all would be dir($path, :!exclude)

[20:11] <[Coke]> or is the R* executable the perl6 compiler executable?

[20:11] <pmichaud> moritz_: no, that feels wrong to me

[20:11] <tadzik> moritz_: what about this BUILD but?

[20:11] <tadzik> * bug?

[20:11] <pmichaud> [Coke]: the latter

[20:11] <moritz_> tadzik: it's a bug.

[20:11] <tadzik> report it?

[20:11] <moritz_> tadzik: I think it's known, but I'm not sure

[20:12] <[Coke]> any thoughts on making the default name for the installed exe "rakudo" instead of "perl6" ?

[20:12] <moritz_> tadzik: if you can't find it in RT; please report it

[20:12] <pmichaud> moritz_: I think it should be    dir($path, test => ... )

[20:12] <Eevee> imo the executable should be "rakudo‚òÖ"

[20:12] <[Coke]> (but keeping perl6 as a copy (until we bother with making a symlink)

[20:12] <pmichaud> i.e., "dir" has a built-in 'grep'

[20:12] <[Coke]> Eevee: did you mean to have extra chars there?

[20:13] <moritz_> pmichaud: 'test' is not very specific about whether it includes or excludes

[20:13] <Eevee> [Coke]: yes it's U+2605 BLACK STAR  :P

[20:13] <pmichaud> moritz_: it includes

[20:13] <pmichaud> just like with grep

[20:13] <tadzik> er, searching for BUILD on rt is not a good idea

[20:14] <pmichaud> [Coke]: I've considered switching the executable name to "rakudo", yes.

[20:14] <tadzik> moritz_: http://rt.perl.org/rt3/Public/Search/Simple.html?q=submethod nothing looks like this one

[20:14] <moritz_> tadzik: then submit

[20:14] <tadzik> moritz_: the bug is, that the class variables are not visible in BUILD?

[20:14] <pmichaud> [Coke]: I've not been able to argue myself into it enough to overcome the inertia of "perl6".

[20:14] <moritz_> tadzik: that the attributes aren't initialized yet

[20:15] <tadzik> alright

[20:15] <pmichaud> moritz/tadzik :  should they be?

[20:15] <pmichaud> I thought BUILD was responsible for initializing them.

[20:15] <tadzik> pmichaud: moritz_ told me so :)

[20:15] <pmichaud> and then if left uninitialized, the default initializer grabs them 

[20:15] <tadzik> I only know that in Moose they alredy where. And it was the way to make some funny magic after an object construction

[20:15] <pmichaud> but we can't say they should be initialized by default if BUILD is supposed to potentially leave them uninitialized

[20:16] <moritz_> pmichaud: I kinda thought the bless($candidate, %args) initializes them

[20:16] <pmichaud> bless calls BUILD, yes.

[20:16] <moritz_> wait

[20:16] <moritz_> it calls BUILD for every class in the hierarchy

[20:16] <pmichaud> including the one you're in, iirc.

[20:17] <jjore_> hi, what method do I call to get the list of methods available on an object?

[20:17] <moritz_> and shouln't Mu.BUILD initialize all attributes, leaving custom BUILDs free from these chores?

[20:17] <tadzik> moritz_: what's the preffered naming for perl6 modules again?

[20:17] <tadzik> jjore_: ^methods

[20:17] <TimToady> Mu runs first, not last

[20:17] <moritz_> jjore_: $obj.^methods

[20:17] <jjore_> o_O

[20:17] <moritz_> or $obj.^methods(:local), if you don't want parent attributes

[20:17] *** oZ] joined
[20:17] <jjore_> I guessed .methods, .meta.methods, and .META.methods but wouldn't at have ever arrived /there

[20:17] <jjore_> thanks

[20:18] <moritz_> TimToady: right, that's why I thought that a custom BUILD already sees initialized attributes

[20:18] <jjore_> Oh, I don't see ^methods in the list of methods

[20:18] <moritz_> jjore_: that's because it's a method on the meta class

[20:19] <moritz_> or syntactic sugar for that

[20:19] <tylercurtis> rakudo: say Int.HOW.methods

[20:19] <p6eval> rakudo 3370f0: OUTPUT¬´too few positional arguments: 1 passed, 2 (or more) expected‚ê§  in main program body at line 22:/tmp/gmJgdBhs_q‚ê§¬ª

[20:19] <moritz_> rakudo: say Int.HOW.methods(Int)

[20:19] <p6eval> rakudo 3370f0:

[20:19] <p6eval> ..OUTPUT¬´ACCEPTSfrom-radianspredatanhexpcosecBridgesinhto-radiansWHICHacotanrootsComplexlnsecaseccotanhcislogsechlog10randtruncatesinsqrtasinIntBoolcoshsuccsignasinhacosechabsrealsceilingunpolarfloorasechRatroundacoshacosecNumcosechcotanatan2tanRealatancosacostanhNumericperlStracotanhtrim-t‚Ä¶

[20:19] <tylercurtis> rakudo: say Int.^methods

[20:19] <moritz_> $obj.^foo is short for  $obj.HOW.foo($obj)

[20:19] * mathw mutters and mumbles about action methods

[20:19] <p6eval> rakudo 3370f0:

[20:19] <p6eval> ..OUTPUT¬´tanhatanhcosecNumWHICHperlrootstanlog10from-radianscospredacosecsinhasinhNumericcosechrealsStrasecacotanhfloorsechACCEPTSasechrandtruncateroundsqrtasinBoolcoshexpsuccacoshsigncotanatan2ComplexseccislogsinIntBridgeto-radiansabsacosechacotanlnceilingcotanhunpolaratanRealacosRattanhat‚Ä¶

[20:20] <jjore_> ah

[20:20] <mathw> okay

[20:20] <mathw> it's re-read spec time

[20:20] <moritz_> because the meta class of Int handles all the objects, and differnt objects can have different methods mixed in

[20:20] <tylercurtis> Ah, right.

[20:20] <jjore_> Is it weird that .HOW doesn't show up either?

[20:20] <tadzik> moritz_: what's the preffered naming for perl6 modules again?

[20:20] <moritz_> rakudo: class A { method x() { } }; my $y = A.new; say ~$y.^methods(:local); $y does role { method new_metho() { } }; say ~$y.^methods(:local)

[20:21] <p6eval> rakudo 3370f0: OUTPUT¬´x‚ê§new_metho‚ê§¬ª

[20:21] <moritz_> tadzik: foo-bar or perl6-foo-bar

[20:21] <tadzik> ok

[20:21] <pmichaud> .HOW is more of a macro than a true method.

[20:21] <pmichaud> (although I am surprised it doesn't appear in Rakudo :)

[20:21] <moritz_> I'm kinda surprised that x doesn't show up in the second .^methods

[20:22] <jnthn> moritz_: I'm not.

[20:22] <jnthn> moritz_: Mixing in a role derives an anonymous sub-class and mixes into that.

[20:23] <jnthn> moritz_: If we just replaced methods rather than doing that, you'd not be able to defer up to the original class from the mix-in, for example.

[20:23] <moritz_> jnthn: ah, so x is one level away

[20:23] <jnthn> moritz_: Yes :-)

[20:23] <jnthn> moritz_: So if you mix in an x and the original class had an x, you can still get hold of both.

[20:23] <jnthn> :-)

[20:24] *** _macdaddy joined
[20:25] * moritz_ proposes :*foo to mean :foo(*)

[20:25] <moritz_> ... not really :-)

[20:25] <jnthn> :*|

[20:25] <masak> *.O

[20:25] * pmichaud proposes :*|  to mean someone just got punched in the nose.

[20:25] <moritz_> std: :::foo; class foo { };

[20:25] <p6eval> std 31774: OUTPUT¬´ok 00:01 114m‚ê§¬ª

[20:25] <moritz_> \o/ STD.pm parses colonpairs with :: sigil

[20:25] <masak> pmichaud: wouldn't that be :*( in most cases? :P

[20:26] <moritz_> rakudo: my $x = :::foo; class foo { };

[20:26] <p6eval> rakudo 3370f0:  ( no output )

[20:26] *** timbunce joined
[20:26] <TimToady> um, no

[20:26] <moritz_> rakudo: my $x = :::foo; class foo { }; say $x.perl

[20:26] <jnthn> masak: Depends if you were sad about being punched or just disappointed, I guess.

[20:26] <p6eval> rakudo 3370f0: OUTPUT¬´undef‚ê§¬ª

[20:26] <TimToady> anything done with :: is hardwired; it's not a sigil

[20:26] <moritz_> what is this undef thing?

[20:26] *** perimosocordiae joined
[20:27] <masak> jnthn: I think I missed the Unicode codepoints "SAD ABOUT BEING PUNCHED IN THE NOSE" and "JUST DISAPPOINTED ABOUT BEING PUNCHED IN THE NOSE" :)

[20:27] <pmichaud> and  "HAPPY TO HAVE A CLOWN NOSE"

[20:27] <pmichaud> aka

[20:27] <pmichaud> :*D

[20:28] <masak> pmichaud++

[20:28] <masak> that karma point was for the mental images alone :)

[20:29] <lue> .oO(CIRCLE THAT USED TO BE SQUARE)

[20:29] <TimToady> ‚ñ¢

[20:29] <pmichaud> wouldn't that be "CIRCLE THAT IS ABOUT TO BE SQUARE"?

[20:29] <lue> SQUARE THAT USED TO BE CIRCLE

[20:29] <masak> lue: was it punched in the nose as well?

[20:30] <lue> Yes. It just has an ose now :)

[20:30] <mathw> \o/ got Form successfully not using {*

[20:30] <mathw> {*} #= key stuff

[20:30] <pmichaud> \o/

[20:30] <mathw> thanks to the Book

[20:30] <jnthn> mathw: yay!

[20:30] <tylercurtis> :‚óèD HAPPY TO HAVE A CLOWN NOSE FACING THE READER

[20:31] <mathw> which hinted at me how to pass up the ast from a subrule match in a manner that doesn't drive me insane

[20:31] <masak> "Perl 6: HAPPY TO HAVE A CLOWN NOSE"

[20:31] <mathw> although it's still not entirely elegant

[20:31] <pmichaud> sadly, Camelia does not have a clown nose.

[20:31] <masak> and people say we're bad at marketing...

[20:32] <dalek> rakudo: 2783660 | moritz++ | src/core/IO.pm:

[20:32] <dalek> rakudo: dir() now defaults to filtering out . and ..

[20:32] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2783660790718bb69e0442785ea41bdddb04ae5e

[20:32] <mathw> only two of seven test files now failing!

[20:32] <lue> .u FFD0

[20:32] <phenny> U+FFD0 (No name found)

[20:32] <mathw> I think I'll commit this

[20:32] <lue> .oO(should have said EYE OF THE BASILISK)

[20:33] <pmichaud> okay, off to register for oscon and nomhunt

[20:33] <pmichaud> bbiaw

[20:33] <lue> goodluck o/

[20:33] <lue> rakudo: say "\xFFD0"

[20:33] <p6eval> rakudo 3370f0: OUTPUT¬´Ôøê‚ê§¬ª

[20:34] <mathw> and my cat's come to give me a congratulatory nose rub

[20:35] <mathw> just the encouragement I need to figure out what's wrong with the other two files

[20:36] <tadzik> http://github.com/tadzik/perl6-Config-INI

[20:36] <moritz_> tadzik++

[20:36] <tadzik> suggestions/patches/criticism welcome

[20:37] <tadzik> (see also Acme::Meow :>)

[20:37] *** _mpu left
[20:37] <moritz_> looks nice

[20:37] <PerlJam> tadzik: want to add it to Rakudo*?

[20:37] <tadzik> it's missing sections

[20:37] <tadzik> PerlJam: once I make it finished, sure

[20:38] *** takadonet joined
[20:38] * PerlJam doesn't understand "finished"  :)

[20:38] <tadzik> hmm

[20:38] <moritz_> btw the last patch to rakudo shows a nice use case for none()

[20:38] <tadzik> http://nopaste.snit.ch/22177

[20:39] *** takadonet_ joined
[20:39] <tadzik> nice

[20:39] <masak> chromatic is writing interesting things about Little Languages. http://www.modernperlbooks.com/mt/2010/07/eliminating-errors-with-little-languages.html -- he's kind of building up to Why We Want Perl 6.

[20:40] <PerlJam> tadzik: http://wiki.github.com/rakudo/rakudo/whats-going-into-rakudo Look just above "Add more here :-)"

[20:41] <mathw> Best practice question: should libraries with errors be using 'die' or 'fail'?

[20:41] <tadzik> PerlJam: thanks :)

[20:41] <oZ]> Would anyone be willing to point me at any discussions regarding threading in rakudo?

[20:42] <PerlJam> oZ: The discussions would be very brief.  There is no threading in rakudo   :)

[20:42] <ingy> greetings

[20:42] <moritz_> oZ]: it's not yet implemented, and blocks on parrot not supporting threads for high-level languages

[20:43] <moritz_> (unless a brave soul ports rakudo to another backend)

[20:43] <oZ]> I'm aware it doesn't yet exist -- just wondering about what thought has gone into it and if it's a goal for later. :)

[20:43] <ingy> would anyone be interested in previewing my log post?

[20:43] <ingy> *blog

[20:43] <PerlJam> oZ]: or do you mean threading as in autothreading ala junctions?

[20:43] <ingy> http://gist.github.com/483546

[20:43] <PerlJam> ingy: sure!

[20:43] * moritz_ takes a look

[20:43] <oZ]> Nope -- I mean, open a thread, throw something in there for the thread to do. ;)

[20:43] *** rblasch_ joined
[20:44] <masak> mberends: ping

[20:44] <moritz_> it's planned, yes

[20:44] <moritz_> but not any time soon

[20:44] <PerlJam> heh "short ten year wait"

[20:44] <oZ]> Oh.

[20:44] <tylercurtis> oZ]: http://perlcabal.org/syn/S17.html although I don't know if anyone has much if any of that implemented, so it'll probably change drastically between now and being implemented.

[20:44] <moritz_> unless somebody takes it up, and implements it

[20:44] <ingy> sorry about the badly formatted gist

[20:44] <ingy> one sec

[20:44] * moritz_ downloads the raw thing, and puts it into vim

[20:45] <oZ]> Any pointer on the parrot issue you're talking about?

[20:45] <moritz_> ingy: please remove that 1.0. It's not going to be the official version number

[20:45] <moritz_> oZ]: just a sec...

[20:46] <ingy> moritz_. PerlJam: regist: http://gist.github.com/483559

[20:47] <moritz_> oZ]: http://trac.parrot.org/parrot/ticket/757

[20:47] <masak> phenny: tell mberends when I remove (Cool-)Str.bytes, t/spec/S32-io/IO-Socket-INET.rakudo fails 10 tests. sure enough, src/core/IO/Socket.pm contains the only use of .bytes in the whole Rakudo code base right now. I'd like to confer with you re what to do with it.

[20:47] <phenny> masak: I'll pass that on when mberends is around.

[20:47] *** _macdaddy left
[20:47] <PerlJam> ingy: there's another Rakudo * 1.0 later in the doc

[20:48] <oZ]> moritz_++ thank you very much for your help!

[20:48] *** literal left
[20:48] *** avar left
[20:48] <moritz_> oZ]: also if you search for 'threads', you'll find that there are quite some patches for it, but they stay unapplied

[20:48] <PerlJam> oh, you didn't get rid of the first 1.0

[20:48] *** rblasch__ joined
[20:48] <moritz_> oZ]: because nobody feels responsible for them, and nobody really understands it

[20:48] <masak> reviving Ponie at some point might be a very special kind of fun.

[20:48] <ingy> PerlJam, moritz_: 1.0 removed

[20:49] <moritz_> oZ]: there's hope though. Currently a student works on a new threading system for parrot. Talk to 'Chandon' on #parrot (irc.perl.org)

[20:49] <oZ]> Ooh, OK. Thank you again.

[20:50] *** avar joined
[20:50] <tylercurtis> oZ]: http://parrot.org/blog/836 for more info and Chandon's GSoC.

[20:50] <moritz_> ingy: btw you're welcome to implement JSYNC on top of "my" JSON::Tiny grammar

[20:51] *** literal joined
[20:51] *** rblasch_ left
[20:52] <PerlJam> ingy++ interesting post.    I like the no-nonsense aspects of it  :)

[20:52] <PerlJam> ingy: btw, have you learned ruby yet?  I find it weird that you like python more than perl 6.

[20:54] <tadzik> I find it weird you like both. They feel completely antagonistic to me

[20:54] <cxreg> anyone at oscon that could provide a ubuntu cd or know where to find one?

[20:55] <moritz_> ingy++ nice blog post

[20:55] * tadzik sends a call to arms for the local perl mongers list, call to write perl6 modules

[20:56] *** justatheory joined
[20:56] *** Kodi joined
[20:56] <Kodi> masak: ping

[20:56] <phenny> Kodi: 16:51Z <supernovus> tell Kodi nice work on the Temporal stuff!

[20:57] <masak> ingy++ # nice post

[20:57] <masak> Kodi: *pong*

[20:57] <Kodi> masak: I dropped day-name from DateTime 'cause it ain't specced. I changed stftime.pm appropriately, but maybe novus's patch conflicted with that.

[20:57] <jjore_> You know, I think I really do like that sigils in ruby denote scope. That's nice coming from perl where there's nothing visible except convention like uppercase variables being constants or class data

[20:58] <masak> Kodi: ah. that means that the spectests are in the wrong.

[20:58] <masak> Kodi: in that case, I think I can commit your patch.

[20:58] <moritz_> jjore_: well, Perl 6 has adoptedthat partially

[20:58] <masak> jjore_: there's twigils in Perl 6.

[20:58] <moritz_> with twigils

[20:59] <Kodi> masak: No, I if I remember correctly, DateTime.t doesn't try to use a day-name method. [more]

[20:59] <PerlJam> apparently everyong thought the same thing when reading jjore_ 

[20:59] <moritz_> $*foo being a dynamic variable, $!foo an attribute, $^foo a formal parameter etc.

[20:59] <jjore_> we have scoping twigits?

[20:59] <jjore_> oh, hmm

[20:59] <Kodi> masak: It's just that day-name is called by strftime, and it shouldn't be.

[20:59] <cosimo> oh hai, #perl6. Q: is .pm6 the "cool" extension now? I thought we wanted to keep .pm

[20:59] <Kodi> strftime should have a day-of-week name array and use that.

[21:00] <Kodi> That ought to fix the failing tests.

[21:00] <cosimo> but i see increasing amounts of .pm6 files

[21:00] <moritz_> cosimo: it seems some projects have moved to .pm6, due to having to ship both p5 and p6 modules

[21:00] <moritz_> I don't really care

[21:00] *** paul1234 left
[21:00] <masak> Kodi: applying your patch caused failing tests as shown in my email.

[21:01] <masak> Kodi: you lost me after that in your above explanation.

[21:01] <cosimo> moritz_: ok, i'll keep using .pm for now, then :)

[21:01] <Kodi> masak: Sorry. Here's what I'm trying to say: the call to DateTime.day-name, if I recall correctly, doesn't happen in any of the test files, it happens in strftime.pm. So strftime.pm is what needs fixing. 

[21:02] *** takadonet left
[21:02] <Kodi> The tests are correct in thinking that strftime should support names of weekdays.

[21:02] <cxreg> is :rw supposed to be a valid open argument?

[21:02] <masak> ah.

[21:02] <moritz_> cxreg: yes, but NYI

[21:03] <masak> Kodi: is it possible you could prepare a patch with (1) s/Calendrical/Dateish/ and (2) the strftime.pm issue fixed?

[21:03] *** kensanata left
[21:03] <masak> Kodi: that'd greatly simplify my apply work.

[21:03] <cxreg> moritz_: due to seek issues or something?

[21:03] *** Su-Shee left
[21:03] *** takadonet_ left
[21:03] <moritz_> cxreg: probably just because nobody got around to implement it yet

[21:03] <Kodi> masak: Sure, I can do that tonight. I just need to run a participant (psychology experiment) and have dinner first.

[21:04] <masak> ++Kodi

[21:04] <masak> Kodi: take your time.

[21:04] * moritz_ wonders if #perl6 is just a big psychology experiment

[21:04] <PerlJam> Where does HTTP::Daemon live?  In web?

[21:04] <Kodi> masak: And then we'll have working Date and DateTime in Rakudo *! Hooray!

[21:04] <moritz_> somwhere on gitorious,iirc

[21:04] *** Mowah left
[21:04] <masak> yes, gitorious.

[21:04] * PerlJam looks

[21:05] *** oZ] left
[21:05] *** hercynium joined
[21:06] <masak> rakudo: module M {}; say 42 ~~ M

[21:06] *** M_o_C left
[21:06] <p6eval> rakudo 278366: OUTPUT¬´Method 'ACCEPTS' not found for non-object‚ê§  in 'infix:<~~>' at line 397:CORE.setting‚ê§  in main program body at line 22:/tmp/fC9POxlNFX‚ê§¬ª

[21:07] * masak submits rakudobug

[21:07] <masak> mathw++ for discovering it.

[21:07] <moritz_> what should it do?

[21:07] <moritz_> is M a type?

[21:07] <masak> print "0\n"

[21:07] <masak> moritz_: I'd expect it to be an object, given that everything is, if pressed.

[21:07] <ingy> moritz_: I plan to implement JSYNC on your code, of course.

[21:08] *** Kodi left
[21:08] <moritz_> \o/

[21:08] <ingy> PerlJam: Python is nice and boring

[21:08] <ingy> :)

[21:08] <moritz_> is anybody *not* getting passing TODOs in t/spec/S32-str/uc.rakudo?

[21:08] <ingy> Rakudo has too much "excitement" ;)

[21:09] <PerlJam> ingy: oh.  In that case, I can see quite well how you would like Python over Perl 6  :-)

[21:09] <masak> moritz_: I've got them today. haven't paid attention to whether they've been consistent.

[21:11] <Tene> ingy: but you don't put spaces after twigils...

[21:11] <pugssvn> r31775 | moritz++ | [t/spec] unfudge some passing TODO tests, and see if we get failure reports from any platforms 

[21:13] <masak> moritz_: not consistent. I just ran uc.rakudo again, and didn't get passing TODOs.

[21:16] *** patspam left
[21:19] *** paul1234 joined
[21:23] <ingy> Tene: *! ;)

[21:23] *** perimosocordiae left
[21:23] <masak> ingy: did you just punch Tene in the nose? :P

[21:24] <masak> ingy: that kind of Pythonista behaviour isn't tolerated around here... :P

[21:24] <Tene> ingy: eh?

[21:24] <masak> poor Tene is all dazed now.

[21:25] *** gbacon left
[21:27] *** macroron left
[21:27] <ingy> http://blogs.perl.org/users/ingy_dot_net/2010/07/rakudos-really-really-release-ready.html

[21:28] <ingy> how do I get this post linked to blogs.perl.org front page?

[21:32] <tadzik> it appeared

[21:33] *** felliott left
[21:33] <jnthn> ingy++ # nice post!

[21:38] *** sftp left
[21:38] *** Guest62932 left
[21:38] *** skids left
[21:46] <masak> looking closer at the Str.bytes use in src/core/IO/Socket.pm, I think it not only *can* be changed into Buf.bytes, but *should* be. still, it'd be nice to talk to mberends++ before making the switch.

[21:46] <masak> god natt, #perl6.

[21:46] <tadzik> o/

[21:46] *** masak left
[21:51] <jjore_> Hi, my runtimes vary *alot* depending on the contents of the files it is parsing. Anyone want to gesture at this to guess why? http://diotalevi.isa-geek.net/~josh/100720/timing-rakudo.txt

[21:51] <pugssvn> r31776 | dolmen++ | [S32/Temporal] Make DateTime immutable. 

[21:52] *** mreed joined
[21:52] *** mreed is now known as markjreed

[21:52] <dolmen> ingy++

[21:53] <markjreed> Where in the Synopses is the new hash subscript syntax discussed?  Is there any difference between %hash<foo> and %hash<<foo>> (or %hashB+fooB;

[21:53] <markjreed> Ok, so much for Unicode in this irc client. :)

[21:54] <markjreed> So far I've done a cursory search over S02, S03, and S09..

[21:54] <jnthn> markjreed: I'd guess S02 or S09.

[21:54] <pmichaud> back

[21:54] <dolmen> phenny, tell masak I have committed my Temporal spec patch

[21:54] <phenny> dolmen: I'll pass that on when masak is around.

[21:54] <jnthn> markjreed: Ah. :-)

[21:57] *** rblasch_ joined
[21:57] *** pmurias left
[21:58] <jnthn> jjore_: Those are...interesting.

[21:59] <jnthn> jjore_: There's no correlation with filesize?

[21:59] <ingy> greetings

[21:59] <jnthn> But I guess not looking at just how big the differences are.

[21:59] <jnthn> pmichaud: http://diotalevi.isa-geek.net/~josh/100720/timing-rakudo.txt may be interesting to you when you get chance.

[21:59] <jjore_> Oh! that's what I meant to add to the report, file size.

[21:59] *** hercynium left
[22:00] <jjore_> and whether the pattern succeeded or not

[22:00] <jnthn> pmichaud: Wonder if it's hitting some expected pathological backtracking case.

[22:00] <jnthn> *unexpected

[22:00] <jnthn> *unexpectedly

[22:00] <jnthn> gah 

[22:00] <jnthn> :-)

[22:00] *** rblasch__ left
[22:01] *** mce_ro joined
[22:01] * jnthn afk for a little

[22:02] <jjore_> fwiw, I'm merely running that program against the perl5 source. I wrote it last year at http://use.perl.org/~jjore/journal/39233

[22:02] <markjreed> Based on the Apocalpyse and Exegesis, I would expect it to be in S02, but if it's in there, I don't see it. 

[22:03] <tadzik> there will be more then one Rakudo Star?

[22:03] <pmichaud> tadzik: Rakudo Star is a series of distribution releases, not a single release.

[22:04] <tadzik> oh, nice

[22:04] <pmichaud> looking at timing-rakudo.txt

[22:04] *** justatheory left
[22:05] *** timbunce left
[22:05] <pmichaud> adding some judicious ratchets or 'cut' markers would likely speed things up a fair bit

[22:06] <pmichaud> for example,  \N*:\n  can be far more efficient than  \N*\n

[22:06] *** hercynium joined
[22:07] <pmichaud> with \N*\n, the engine currently keeps a lot of backtracking points for the quantifier on \N*

[22:07] <markjreed> ah. "(It also works to say %x<<foo>> as long as you realized it's subject to interpolation.)"

[22:08] <pmichaud> markjreed:  briefly,    %h<x>  is the same as  %h{<x>}

[22:08] <pmichaud> and %h<<foo>>  is the same as  %h{<<foo>>}

[22:08] <markjreed> S02.  So my $foo="bar baz"; say %x<<$foo>>; should translate to say %x<bar baz>

[22:09] <pmichaud> markjreed: correct.   I think <<$foo>> isn't working in rakudo at present.

[22:09] <jjore_> fwiw, I think the perl5 engine ran against *all* the files in approx 3 seconds.

[22:09] <pmichaud> rakudo:  my $foo = "bar baz";   say <<$foo>>.perl

[22:09] <p6eval> rakudo 278366: OUTPUT¬´"\$foo"‚ê§¬ª

[22:09] <pmichaud> jjore_: that doesn't surprise me

[22:09] <jjore_> but thanks for the info. I don't know what gyrations the rakudo re engine is doing to make that happen

[22:09] <pmichaud> jjore_: rakudo's engine is still fairly slow, and we get hit hard by gc performance issues in Parrot

[22:09] <markjreed> ah, ok.  totally apart from hash subscripting, Texas quotes aren't interpolating.  

[22:10] *** rgrau__ joined
[22:10] <pmichaud> Texas quotes do interpolate.

[22:10] <markjreed> ..but not in current rakudo.

[22:10] <pmichaud> right.

[22:10] <markjreed> We're violently agreeing, then. :)

[22:10] <pmichaud> I wonder how hard it would be to re-implement that.

[22:10] <tadzik> g'night #perl6

[22:10] *** tadzik left
[22:11] *** rgrau_ left
[22:12] <ingy> http://blogs.perl.org/users/ingy_dot_net/2010/07/rakudos-really-really-release-ready.html (updated with my photo!)

[22:12] <pmichaud> ingy: I enjoyed the post :)

[22:12] <ingy> I <3 my hairdo

[22:12] <ingy> pmichaud: \o/

[22:13] * ingy buggers off to find TimToady 

[22:13] <pmichaud> has it been tweeted yet?

[22:13] <ingy> pmichaud: should I tweet it?

[22:13] <pmichaud> hugme tweet rakudoperl Ingy writes about Rakudo Perl: http://blogs.perl.org/users/ingy_dot_net/2010/07/rakudos-really-really-release-ready.html

[22:13] * hugme hugs pmichaud; tweet delivered

[22:13] <pmichaud> it's tweeted now :)

[22:14] <ingy> \o/ !!!

[22:14] <ingy> pmichaud++

[22:14] * ingy really buggers off to find TimToady 

[22:14] <au|zzz> ...and retweeted :)

[22:14] *** au|zzz is now known as au|irc

[22:15] <pmichaud> perlbuzz tweeted it also

[22:15] <au|irc> ingy++ # lovely writeup

[22:15] *** su_penguin joined
[22:15] <sbp> "If your expection of Rakudo * includes blazing speed..."

[22:16] <sbp> expectation?

[22:16] <su_penguin> Hello all. :)

[22:17] <jjore_> that

[22:17] <jjore_> er,

[22:17] <jjore_> ingy, (making fiends)++

[22:19] <tylercurtis> rakudo: our $ingy += [+] 1..*; # for the Acmeist Perl 6 Regex plans.

[22:19] <p6eval> rakudo 278366:  ( no output )

[22:20] <markjreed> Python nicer than Perl6?  Heresy! :)

[22:23] *** felliott joined
[22:24] *** tylercurtis left
[22:24] *** timbunce joined
[22:25] <ash_> has anyone made a camelia favicon? 

[22:26] * ingy has located @TimToady / 2;

[22:26] <ingy> au|irc: thanks!

[22:26] <au|irc> :)

[22:27] <ingy> sbp: fixing... thanks

[22:27] <sbp> :-)

[22:27] *** rblasch_ left
[22:28] *** justatheory joined
[22:28] <markjreed> How can an Acmeist like a language whose motto is "There's Only One Way To Do It"? :)

[22:28] <ash_> rhetorically? 

[22:29] <markjreed> Perl6.org seems to have a Camelia favicon, ash_.

[22:29] <jnthn> ash_: http://svn.pugscode.org/pugs/misc/camelia32.ico

[22:30] <ash_> ah, thanks

[22:30] <pmichaud> oh dear

[22:30] <pmichaud> http://twitter.com/obra/status/18969296509

[22:30] <pmichaud> and reply at http://twitter.com/OReillyMedia/status/19000614690

[22:31] <pmichaud> ah well, "rise above" and all that.

[22:32] *** mce_ro left
[22:32] *** gbacon joined
[22:32] <ingy> sbp: fixed

[22:32] <jnthn> :/

[22:32] <pmichaud> obra++ for nicely bringing it to oreilly's attention 

[22:32] <ingy> markjreed: their motto is a lie :)

[22:33] <markjreed> Typical, really...

[22:34] <markjreed> It's representative of an attitude, though.  As the community has grown that attiude may have become less prevalent...

[22:35] <pmichaud> I wonder how many (if any) lightning talks will be created based on that subject :)

[22:36] <jjore_> pmichaud: said earlier that \N*:\n could be more efficient than \N*\n. I didn't realize : was a metacharacter - a cut. Is it really?

[22:36] *** felliott left
[22:36] *** pyrimidine left
[22:37] <pmichaud> it is

[22:37] <jjore_> woo

[22:37] <pmichaud> it prevents backtracking into the previous item

[22:37] <jjore_> that must be why I wrote \: in the original regexp

[22:37] <markjreed> Everyone wanted the colon, but the regex engine got it? :)

[22:37] <pmichaud> well, all punctuation is meta in regexes

[22:38] <pmichaud> it's still likely to be slow, but you can save a *bunch* of gcables by not preserving backtracking points when they aren't needed :)

[22:39] <jnthn> The regex engine really got the colon. There :, :: and ::: :-)

[22:39] <pmichaud> for example, I would write

[22:39] <pmichaud>     Local\ Variables\:\N*\n

[22:39] <pmichaud> as

[22:39] <pmichaud>     'Local Variables:' \N*:\n

[22:40] <markjreed> ok, outta here..

[22:40] *** markjreed left
[22:41] * pmichaud regrets that he did not bring his Windows flashcard with him

[22:41] <pmichaud> now I might have to learn/use gimp

[22:42] <jnthn> Odd, I never have to remember one of those. ;-)

[22:42] <jjore_> thanks pmichaud. I'm retrying w/ your suggestions on doio.c which was approx 1 minute before.

[22:42] <pmichaud> jjore_: I'm curious to see how much of a difference it makes.

[22:42] <jjore_> Now seeing 20ish seconds

[22:42] <jnthn> Wow.

[22:42] <jjore_> for try in $(seq q ...);do...

[22:43] <jnthn> pmichaud: ooc, does backtracking etc result in quite a lot of method calls too?

[22:43] <pmichaud> jnthn: not so much

[22:43] <jnthn> OK

[22:43] <pmichaud> actually, it does

[22:43] <pmichaud> those are method calls I've been meaning to inline

[22:43] <pmichaud> yes, each backtracking point results in a method call at present.

[22:44] <jjore_> ok, well, re-running against the whole set.

[22:44] <pmichaud> the code is designed so that I can inline some of those calls easily

[22:44] <jnthn> OK

[22:45] <jnthn> Grammars are one case where some of the stuff I'm working on for method dispatch performance improvements could *really* win us a bunch.

[22:45] <pmichaud> very much agreed

[22:45] <jnthn> Because all the dispatches are on the invocant.

[22:45] <jnthn> And we know the type of it.

[22:45] <pmichaud> I'm also very eager to re-look at sorear's work on dfa matching

[22:45] <jnthn> pmichaud: Oh, that's one question I wanted to ask.

[22:45] <jnthn> pmichaud: Are you using Multiple Inheritance anywhere in the grammar stuff?

[22:46] <pmichaud> jnthn: I'm not aware of any off the top of my head.

[22:46] <jnthn> OK

[22:46] <pmichaud> if I am, it's likely easy to work around.

[22:46] <jnthn> OK

[22:46] <jnthn> I'm not saying we'd not support it there

[22:46] <jjore_> just eyeballing the times that are coming back, the program is seemingly 3x faster on all of the input files now

[22:46] <jnthn> So much as it makes some opts harder.

[22:47] <jjore_> Just watched config.h which was 3m58.626s come in at 1m27.769s.

[22:47] <pmichaud> jjore_: it may be faster still (and you can avoid the cut marks)  if you put  :ratchet right after the :i

[22:47] <pmichaud> oh, on second thought, probably not faster

[22:48] <jjore_> the re is already written to be amenable to only forward matching so I : cut everywhere I previously * quantified

[22:48] <pmichaud> right

[22:48] <pmichaud> in that case you might want to look at "token" at some point.

[22:49] <pmichaud> token assumes forward matching (i.e., every expression has an assumed 'cut' after it)

[22:49] <pmichaud> :ratchet does the same thing

[22:49] <pmichaud> i.e., it says "assume ':' after each expression that follows"

[22:51] <jjore_> I may have made the program incorrect though. I said [ \N*:\n ]*:? but that is the one place which needs backtracking

[22:52] <pmichaud> if backtracking is needed there, just don't put the colon 

[22:53] *** Patterner left
[22:53] <jjore_> yes, just went back to omit it. I had to tell #perl6 though because now I can't trust the 3x prior benchmark

[22:53] <jjore_> it was kind of a fabulous number

[22:53] <pmichaud> sure, make sense

[22:53] <pmichaud> *makes

[22:53] <pmichaud> afk for a bit

[22:53] <PerlJam> should the R* dist contain the perl6 book?

[22:54] <pmichaud> I think a reference to it is sufficient.

[22:55] <jjore_> oh that's nice. maybe approx 3x is still reasonable given config.h timing

[22:55] *** stkowski left
[22:56] <ingy> I need a name for the Acmeist P6R project. I was going to use pegex, but there's already a Scala based thing called Pegex on github!

[22:58] *** Psyche^ joined
[22:58] <au|irc> ingy: having a relatively obscure Paragraph Formatter named "par" never really stopped me coopting that name :)

[22:58] *** Psyche^ is now known as Patterner

[22:58] <au|irc> "pegex" is too good to pass :)

[23:00] <au|irc> and just maybe kmizu can join your forces since you seem to be aiming the same goal...

[23:00] *** sftp joined
[23:10] *** ruoso left
[23:11] *** dolmen left
[23:14] <sorear> \o/ it's au|irc

[23:14] <au|irc> o/ sorear :)

[23:14] * sorear has 2 unrelated programs named 'monop' in $PATH

[23:14] <jjore_> K, so like, embed.h is 2.77x. op.c is 2.64.

[23:15] <sorear> jjore_: that looks like you meant #p6p

[23:15] <rokoteko> ingy: f33l fr33 t0 l1st3n t0 my 3lit3 t4lk :)

[23:15] <sorear> #p5p

[23:15] <rokoteko> ingy: that mean I assume you are good. not only because someone named your nick is also good ;)

[23:16] *** pnate left
[23:16] *** colomon joined
[23:16] <sorear> ingy: out of curiousity, where did that nickname come from?

[23:18] *** mberends left
[23:19] <jjore_> sorear: er? I'm editing my perl5 code with a rakudo program

[23:20] *** pnate joined
[23:20] <colomon> jnthn++ # for posting my status report to #phasers

[23:20] <jnthn> colomon: Thanks for thinking to send it along.

[23:21] <jnthn> colomon: It was a good reminder of the grepgrepbug.

[23:21] <colomon> it was a last minute thing before we left.

[23:21] <jnthn> :-)

[23:21] <colomon> and it would have been hell to type on my phone.  :)

[23:21] <jjore_> very originally I wrote a perl5 program to edit perl5 but then for giggles ported it to ruby and perl6 for the experience points

[23:23] <sorear> jjore_: Yes, I just woke up and didn't backlog far enough

[23:24] <jjore_> oh yeah, and I did it /last/ year in July 09 so it made a bit of retrospective to see if anything was different

[23:25] <jjore_> from the perspective of that program, nothing seemed to have changed

[23:26] <jjore_> The one 'TODO' I didn't try undoing was I'd originally tried a regexp back reference which didn't work. I tried all the others though.

[23:26] <jjore_> Oh, though apparently s/// works but I didn't guess my way into working syntax so I kept .substr

[23:27] <jnthn> jjore_: If you came back a year later and we didn't really break your program, that's at least sort of promising. :-)

[23:27] <pmichaud> actually, surprising.  :)

[23:27] <colomon> very promising!  :)

[23:28] <jnthn> s/// should work

[23:28] <pmichaud> afk for a short while

[23:30] *** irclogbot_backup joined
[23:30] *** irclogbot_backup left
[23:32] <jjore_> well, "Unable to parse postcircumfix:sym<{ }>, couldn't find final '}' at line 18" at http://diotalevi.isa-geek.net/~josh/100720/woota2.txt

[23:32] *** mberends joined
[23:34] <sorear> Would it be acceptable for *.perl to return a Cat?

[23:35] *** su_penguin left
[23:36] <jnthn> std: s{ x }{ "y" }

[23:36] <p6eval> std 31776: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/09lJeqD7m6 line 1:‚ê§------> [32ms{ x }[33m‚èè[31m{ "y" }[0m‚ê§    expecting any of:‚ê§   infix or meta-infix‚ê§      quantifier‚ê§Parse failed‚ê§FAILED

[23:36] <p6eval> ..00:01 117‚Ä¶

[23:36] <jnthn> std: s{ x } = "y"

[23:36] <p6eval> std 31776: OUTPUT¬´ok 00:01 117m‚ê§¬ª

[23:36] <jnthn> jjore_: Like that.

[23:36] <jnthn> If you're going to use the bracketed form.

[23:36] <jjore_> but I don't know the contents of "y" until I get some capture variables

[23:37] <jnthn> jjore_: The RHS there is actually closure-ized.

[23:37] <jnthn> So you should be able to refer to them.

[23:38] <jnthn> rakudo: my $x = "l0l1l2l"; $x ~~ s{\d} = 2 * $/; say $x

[23:38] <p6eval> rakudo 278366: OUTPUT¬´Could not find sub &s‚ê§  in main program body at line 22:/tmp/aI2KU7h4eu‚ê§¬ª

[23:38] <jjore_> Ok, refresh. However the eror is still "Unable to parse postcircumfix:sym<{ }>, couldn't find final '}' at line 18"

[23:39] *** Kodi joined
[23:39] <jnthn> rakudo: my $x = "l0l1l2l"; $x ~~ s[\d] = 2 * $/; say $x

[23:39] <p6eval> rakudo 278366: OUTPUT¬´Use of uninitialized value in numeric context‚ê§l0l1l2l‚ê§¬ª

[23:39] <jnthn> :/

[23:39] <jnthn> OK, it's still broken, it seems :-(

[23:39] <jnthn> I know we fixed .subst recently

[23:41] <jjore_> So then $ostr ~~ s{...} = ...; *isn't* working then?

[23:41] <jjore_> I can keep using .substr. It's ok.

[23:42] <jnthn> jjore_: Seems not. :-(

[23:42] <jnthn> Sorry, thought it was.

[23:42] <ingy> jjore_: get used to it :)

[23:42] <jjore_> I would just prefer to adjust my syntax if that's all that prevented it

[23:42] <ingy> it's The Way of the Camel

[23:42] <jnthn> "Spits occasinally."

[23:42] <ingy> :)

[23:43] <jnthn> No point getting the hump though. :)

[23:43] <sorear> it's awesome having enough foundations in niecza down that I can actually hack setting code in Perl 6 now

[23:44] <jnthn> :)

[23:48] <Kodi> phenny: tell masak http://gist.github.com/483792 I actually think I got the day-name stuff right the first time. At any rate, this time, DateTime-strftime.t works fine for me. If you get that problem again, try double-checking that you're using the right strftime.pm (or strftime.pir).

[23:48] <phenny> Kodi: I'll pass that on when masak is around.

[23:48] <Kodi>  

[23:51] *** cdarroch left
[23:52] *** Kodi left
[23:54] *** [Coke] left
[23:56] *** amkrankruleuen joined
[23:56] <amkrankruleuen> Hej :p

[23:56] <jnthn> hej hej

[23:56] *** Psyche^ joined
