[00:00] <sorear> TimToady: how nonsensical?

[00:01] <TimToady> does anything even use that $<sym>?

[00:02] <sorear> no

[00:02] <TimToady> and why should it be [':','dba']?

[00:02] <sorear> ah

[00:02] <TimToady> it just turned it into ':dba' since the «» code is what was giving undef warnings

[00:03] <pugssvn> r31062 | sorear++ | [viv] Add a --no-indent option; rebootstrap with it 

[00:03] <sorear> how is the new build working for you?

[00:03] <TimToady> I hope it still indents the yaml :)

[00:03] <sorear> it doesn't affect yaml

[00:04] <sorear> it's just no warnings 'redefine'; *indent = \&no_indent

[00:04] <sorear> so the code generator never puts in the spaces

[00:04] <TimToady> HACKALERT!!!  :)

[00:05] <sorear> I'm not afraid of typeglobs

[00:06] <TimToady> .oO(fools rush in...)

[00:06] <sorear> possibly a conditional in ::indent itself would have been clearer

[00:08] <TimToady> oh, I probably didn't actually fix the warning, if $M is undefined...

[00:09] *** yinyin joined
[00:16] <pugssvn> r31063 | lwall++ | [STD,Cursor] suppress undef warnings 

[00:20] <sorear> TimToady: how well has the new build system been working for you?

[00:21] <TimToady> pretty okay; I don't know what the new targets are, but 'make clean' and 'make' seem to work :)

[00:21] <sorear> I use make fast, mostly

[00:22] <sorear> make STD.pmc too

[00:22] *** ash__ left
[00:26] <sorear> it's slower than I'd like

[00:27] *** ash__ joined
[00:27] <sorear> there's also 'make reboot', which causes the current built version of STD.pm6 to be used for future builds

[00:29] <TimToady> though 'make reboot' can conceivably break the build for 'make clean'ers

[00:31] <sorear> how so?  you mean if you wrote a bad version of STD.pm6?

[00:31] *** ashleydev left
[00:31] <TimToady> if you introduced a dependency on something that a fresh build doesn't know how to do

[00:32] <sorear> no, make reboot copies the *compiled* version

[00:32] *** justatheory left
[00:33] <TimToady> std: 63

[00:33] *** LylePerl left
[00:33] <p6eval> std 31063: OUTPUT«ok 00:01 110m␤»

[00:34] *** LylePerl joined
[00:35] <pugssvn> r31064 | sorear++ | [viv] Re-enable required argument checking for only subs 

[00:35] <pugssvn> r31064 | [STD] Declare EXPR argument as optional

[00:37] *** rgrau left
[00:40] <TimToady> sorear: have you figured out why \x et al. are not recognized in regexes?

[00:40] <TimToady> since t/spec/S05-mass/named-chars.t is one of the regressions

[00:45] <TimToady> hmm, can recognize /\xAB/ but not /\x[AB]/

[00:45] <TimToady> std: /\xAB/

[00:45] <sorear> no

[00:45] <p6eval> std 31063: OUTPUT«ok 00:01 108m␤»

[00:45] <TimToady> std: /\x[AB]/

[00:45] <p6eval> std 31063: OUTPUT«===SORRY!===␤Unrecognized regex backslash sequence at /tmp/utnzSrqANQ line 1:␤------> /\⏏x[AB]/␤Potential difficulties:␤  [AB] appears to be an old-school character class; please use <[AB]> if you␤    mean a character class, or quote it like

[00:45] <p6eval> ..'AB…

[00:45] <TimToady> looking...

[00:48] <sorear> it might have something to do with the bit where I made '{' ~ '}' mean '{' {} ~ '}'

[00:48] <sorear> std: /\Z/

[00:48] <p6eval> std 31063: OUTPUT«===SORRY!===␤Unsupported use of \Z as end-of-string matcher; in Perl 6 please use \n?$ at /tmp/CDErcWmdgI line 1:␤------> /\Z⏏/␤Parse failed␤FAILED 00:01 107m␤»

[00:49] <TimToady> I see there's a lazymap in there, perhaps deferring the <stopper> match to outside the local $::GOAL's scope is a problem somehow

[00:49] <TimToady> it's not supposed to be using $*GOAL for anything other than messages though now

[00:50] <TimToady> and the really stopper is supposed to always travel with the type of the Cursor

[00:50] *** lest_away is now known as lestrrat

[00:51] <TimToady> if you want to look at it, I'll stop for now

[00:51] <sorear> no

[00:51] <TimToady> the problem with the --no-indent is that there isn't an indented .pm5 out there I can just look at.  :)

[00:52] <TimToady> having it a separate make step meant that both versions were always there

[00:54] <pugssvn> r31065 | sorear++ | [STD-ecosystem] Add a STD.pm5 target 

[00:54] <sorear> yes, that is the downside

[00:55] <sorear> but with the code-gen side of viv as fast as it is... I think it's tolerable

[00:58] <sorear> TimToady: STD.pm6 +3791.  viv is generating $0 as an array because it occurs inside a quantifier.  Is this correct behavior?

[01:01] *** envi^home joined
[01:03] <TimToady> yeah, needs a .[0]

[01:04] *** whiteknight left
[01:04] <TimToady> or a way in P5 to add .Str to ARRAY  :)

[01:08] *** pausenclown left
[01:09] *** ashleydev joined
[01:13] *** pausenclown joined
[01:16] *** madalu joined
[01:21] *** masonkramer__ left
[01:21] *** masonkramer_ joined
[01:22] *** envi^home left
[01:22] *** plobsing joined
[01:25] *** envi^home joined
[01:26] <pmichaud> need to add to the README that JSON is now a requirement for STD compilation :)

[01:27] <awwaiid> random rakudo question, why is 'assign' in the filename 'src/builtins/assign.pir' not capitalized like all the other files in that directory?

[01:27] <pmichaud> because it's not a class

[01:27] <pmichaud> or role

[01:27] <pmichaud> or type

[01:28] <awwaiid> ok, thanks

[01:30] *** Schwern joined
[01:32] <pmichaud> sorear: I get a lot farther now with building STD than earlier.  

[01:33] <pmichaud> (still building... lots of "Use of uninitialized value ..." warnings)

[01:33] <sorear> yes, TimToady++ just fixed some of those

[01:34] <pugssvn> r31066 | sorear++ | [STD] add missing [0] for dumbsmart 

[01:36] <pugssvn> r31067 | sorear++ | [viv] Remove obsolete dependency on JSON 

[01:36] <sorear> 1 regression down

[01:37] *** Schwern left
[01:37] <awwaiid> ok if I add comments to RT tickets that say "actually it looks like rakudo does this correctly now. <pasted session>" ?

[01:38] *** uvtc joined
[01:38] <pmichaud> awwaiid: please do so, yes!

[01:38] <pmichaud> awwaiid: and thanks!

[01:39] <awwaiid> np

[01:41] <uvtc> Hi #perl6. I just installed Parrot (with Rakudo) into `/usr/local/parrot`. Not sure how much sense this question makes, but, where is Rakudo's implementation of the Perl 6 "standard library"?

[01:42] <pmichaud> uvtc:  in the sources, generally in src/core/*.pm

[01:43] <pmichaud> beyond that, there's not really a "standard library" defined by the language.  Different distributions will be able to choose what modules to bundle with the distribution.

[01:44] <pmichaud> sorear: build completed on my system, trying "make test" now.

[01:44] <uvtc> I don't have a `/src/core` dir. Inside `/usr/local/parrot/src`, there's `2.4.0-devel`, and inside that, `ops`, `pmc`, and a couple of vtable files.

[01:45] <pmichaud> uvtc: in the rakudo sources, not in the installed

[01:45] <pmichaud> the core library is compiled in as part of the rakudo executable

[01:46] <TimToady> sorear, it appears that in \x[ it is not matching the [ because the pattern has an extra backslash:

[01:46] <TimToady> 3/1     TOP comp_unit statementlist statement EXPR termish term term__S_086value value value__S_135quote quote quote__S_142Slash_Slash nibble nibbler EXPR termish quant_atom_list quantified_atom atom metachar metachar__S_037Back backslash backslash__S_065x:::::::: PATTERN (?-xism:\G(?i:\\\[)) didn't match at 3

[01:46] <TimToady> see that it says \\\[

[01:46] <uvtc> pmichaud: Ah. compiled in. I see. Thanks.

[01:47] <TimToady> sorear: so I think it's a translation error

[01:52] <sorear> ahhh, backslashes, my sworn enemy

[01:53] <pmichaud> looks like it builds fine on my system now.

[01:53] <pmichaud> (std, that is)

[01:53] <pmichaud> sorear++ TimToady++

[01:54] *** yinyin left
[01:56] <sorear> TimToady: found the error

[01:59] *** azert0x_ left
[01:59] *** azert0x left
[02:00] <pugssvn> r31068 | sorear++ | [viv] Fix double escaping of strings in case ignoring contexts (TimToady++ for doing most of the work) 

[02:01] *** bacek joined
[02:01] <sorear> Hello bacek

[02:01] *** [mark] joined
[02:02] <sorear> TimToady: All three regressions are now fixed

[02:07] <TimToady> snaptesting

[02:12] <uvtc> I'd like to install Proto and try it out (by having it install the web module), but the install instructions on the Proto page (http://github.com/masak/proto) aren't working. The command runs, but evidently fails to get the proto.pl file.

[02:13] <uvtc> (Aren't working *for me*, I mean.)

[02:13] <uvtc> Anyone have any tips on how I might get it installed?

[02:13] <uvtc> My guess is that, once I get a proto.pl file, it should go with my `perl6` binary in `/usr/local/parrot/bin`.

[02:15] <uvtc> Oops. Actually, looks like I can just grab the file by itself from github.

[02:18] *** drbean left
[02:18] *** drbean joined
[02:18] <pugssvn> r31069 | sorear++ | [STD] Update bootstrap to get TimToady++'s undef fixes into the build 

[02:19] *** ashleydev left
[02:23] *** bacek left
[02:23] *** agentzh joined
[02:25] *** envi^home left
[02:25] *** rhr left
[02:25] *** Sarten-X left
[02:25] *** p6eval left
[02:25] *** TimToady left
[02:25] *** constant left
[02:25] *** avar left
[02:25] *** kolibrie left
[02:25] *** literal left
[02:28] *** envi^home joined
[02:28] *** rhr joined
[02:28] *** Sarten-X joined
[02:28] *** avar joined
[02:28] *** p6eval joined
[02:28] *** TimToady joined
[02:28] *** constant joined
[02:28] *** kolibrie joined
[02:28] *** literal joined
[02:28] *** card.freenode.net sets mode: +vo p6eval TimToady

[02:28] <TimToady> Passed 782/815,  95.95%

[02:28] <TimToady> that's pretty darn good

[02:29] *** TiMBuS joined
[02:30] <TimToady> I pronounce this stage of bootstrap complete.

[02:30] <TimToady> sorear++ sorear++ sorear++ sorear++ sorear++ sorear++ 

[02:31] <TimToady> gimme5 is now officially pining for the fjords  :)

[02:31] <pugssvn> r31070 | sorear++ | [gimme5] Delete. (And there was much rejoicing.) 

[02:32] <TimToady> I thought you'd enjoy doing that :)

[02:35] *** uvtc left
[02:37] *** mantovani left
[02:37] *** mantovani joined
[02:41] <pugssvn> r31071 | lwall++ | [viv] make sure .pmc has trailing newline 

[02:48] *** meppl left
[02:49] <pugssvn> r31072 | colomon++ | [t/spec] Update hyper tests to match new spec. 

[02:49] *** satyavvd joined
[02:51] <Wolfman2000> gimme5...wait a second. What was that used for again, and why is there much rejoicing?

[02:51] <Wolfman2000> (( and why are you guys copying Python with the references? ))

[02:52] <TimToady> just because someone else likes the same thing you do doesn't mean you have to quit liking it...

[02:52] <Wolfman2000> I wasn't complaining about the Python references. I found it...slightly funny actually.

[02:53] <TimToady> gimme5 was the chewing-gum-and-bailing-wire translator from P6 to P5 that we used to run std: with up till today

[02:53] <Wolfman2000> Then again, I have to remember that Perl 6 seems to be combining many language aspects. Only makes sense for the jokes to translate.

[02:53] <TimToady> sorear++ has developed viv to the point where it can now do the same translation, so we no longer need gimme5

[02:53] <TimToady> and it does the translation "right" rather than cheating all over the place

[02:53] <Wolfman2000> "to the point"...soundsl ike something is missing then.

[02:54] <TimToady> well, it still uses modules written in Perl 5, such as Cursor and Lazymap

[02:54] <TimToady> next step is to rewrite those in P5 and translate using viv, so the whole system is in P6

[02:55] *** ShaneC left
[02:56] <Wolfman2000> but once those are done...then even more progress in Perl 6

[02:56] <TimToady> with viv we can start to think about running BEGIN blocks, for instance

[02:57] <TimToady> and we can use viv to target other backends than P5

[02:57] *** xinming_ is now known as xinming

[02:57] <TimToady> and we can do some of the optimizations that were impossible with gimme5

[02:57] <TimToady> and we can stop writing STD in the subset of P6 that gimme5 groks

[02:58] <Wolfman2000> alright, viv is the new hero, got it

[02:58] <TimToady> viva la viv

[03:02] *** pausenclown left
[03:03] <sorear> gimme5 consisted of 1200 lines of Perl5 s/// statements being used to turn a subset of perl 6 into perl 5

[03:03] <sorear> +800 lines of regex compiler

[03:03] <sorear> viv works by passing Perl 6 into STD.pm6, then generating Perl 5 from the parse *tree*

[03:03] *** pausenclown joined
[03:04] <sorear> so it accepts a much larger subset of perl 6

[03:04] <sorear> e.g. gimme5 couldn't really handle postcircumfixes

[03:04] <Wolfman2000> I recall a++ has a postfix in ++. What's the postcircumfix again?

[03:05] <sorear> @a[2]

[03:05] <sorear> it's a postfix operator that has an expression

[03:05] <sorear> with gimme5, you had to write the method call form

[03:06] <Wolfman2000> ...I'm not quite seeing how making a postcircumfix would be useful. Got a sub you can make?

[03:07] <sorear> sub sum(@arr) { my $x = 0; for (0 .. ^@arr) { $x += @arr[$_] } }

[03:08] <Wolfman2000> ...I think I asked the wrong question

[03:08] <sorear> the reason you can't see why they'd be useful is that you're taking them for granted

[03:08] <Wolfman2000> I've made custom infixes and prefixes before.

[03:08] <Wolfman2000> But where would a custom postcircumfix come in handy?

[03:08] <sorear> I'm not talking about custom ones

[03:08] <sorear> gimme5 couldn't handle the *standard* ones

[03:09] <Wolfman2000> ...woah. Okay, missed that detail.

[03:09] *** satyavvd left
[03:09] *** bjarneh joined
[03:09] *** justatheory joined
[03:16] *** ash__ left
[03:25] <sorear> Is backtracking from one LTM alternative into the next-longest token implemented yet?

[03:25] <TimToady> yes, that's what relex controls

[03:26] <TimToady> well, $relex, since it's always anonymous

[03:27] *** yinyin joined
[03:27] <TimToady> see Cursor.pmc:531

[03:28] <sorear> aha

[03:29] <sorear> what about something like [ a | aa ] ab

[03:29] <sorear> can it backtrack into a group of alternations

[03:29] <TimToady> I believe so, but I could be wrong

[03:30] <TimToady> if so, it's done with lazymaps

[03:30] <TimToady> it won't happen under :r of course

[03:30] *** madalu left
[03:33] * sorear -> svnweb

[03:35] <sorear> What is "failover"?

[03:35] <TimToady> context?

[03:36] <TimToady> generally, when your first try or set of tries don't work, and you'd ordinarily get an exception, but you have something else to try instead

[03:37] <TimToady> we used to do a lot more of it in the design of p6, but we've tended to avoid it in recent years when possible

[03:37] <TimToady> we used to failover between methods and functions, and vice versa

[03:38] <TimToady> looking in GLOBAL for dynvars that aren't in the dynamic scope is also a failover

[03:39] <sorear> die "failover no longer implemented"

[03:39] <TimToady> where?

[03:39] <sorear> gimme5, RE_any::walk

[03:41] <TimToady> oh, in that case, it originally assumed that the fates or relexes were unreliable, so would retry all the cases one by one, much more like rakudo still does

[03:41] <TimToady> when the relexing worked, we didn't have to do that anymore

[03:41] <TimToady> STD has trusted its relexing for more than a year now, I think

[03:45] *** skids left
[03:52] * sorear debates adding no warnings 'misc' so as to make my $C = foo; my $C = $C->bar; legal without intervening braces

[03:53] <TimToady> that only works if you never need access to the original $C

[03:55] *** satyavvd joined
[03:57] <TimToady> and it doesn't really buy you much in p5

[03:57] <TimToady> since most blocks parasitize their sub's lexpad anyway

[04:21] *** ashleydev joined
[04:23] *** jaldhar joined
[04:24] <pugssvn> r31073 | lwall++ | [viv] is no longer a "start" on replacing gimme5 :) 

[04:33] *** tedv left
[04:38] *** mtnviewmark joined
[04:40] *** mtnviewmark left
[04:41] *** Wolfman2000 left
[04:42] *** envi^home left
[04:42] *** envi^home joined
[04:44] *** plainhao left
[04:48] *** ashleydev left
[04:50] <pugssvn> r31074 | sorear++ | [viv] Overhaul indentation engine; should be much more readable now 

[04:53] *** yinyin left
[04:54] <satyavvd> Why it is not displaying all the methods of HASH?

[04:54] <satyavvd> perl6 -e 'for Hash.^methods(:global) -> $meth { say $meth.name , "-", $meth.WHAT }'

[04:55] <satyavvd> but same works for 'Array'

[04:57] <satyavvd> ???

[05:00] *** patspam left
[05:01] *** PenThrive left
[05:03] <TimToady> interestingly:

[05:03] <TimToady> rakudo: for { a => 1 }.^methods(:global) -> $meth { say $meth.name , "-", $meth.WHAT }

[05:03] <p6eval> rakudo 18d996: OUTPUT«sort-Multi()␤Bool-Method()␤list-Method()␤postcircumfix:<{ }>-Multi()␤push-Method()␤delete-Method()␤of-Method()␤elems-Method()␤invert-Multi()␤Str-Method()␤reverse-Method()␤keys-Method()␤postcircumfix:<{

[05:03] <p6eval> ..}>-Multi()␤pairs-Method()␤contains-Method()␤exists-Method()␤kv-Method()␤ACCEPTS-…

[05:15] *** kaare joined
[05:15] *** kaare is now known as Guest6050

[05:23] *** finanalyst joined
[05:30] *** bacek joined
[05:31] *** cli_ left
[05:35] *** szabgab joined
[05:36] *** dukeleto joined
[05:37] <dukeleto> howdy

[05:38] <sorear> hello

[05:38] <dukeleto> i am trying to load perl6.pbc from rakudo in PL/Parrot, and I am running into this: http://gist.github.com/423516

[05:38] * dukeleto is trying to make PL/Perl6 work on PL/Parrot

[05:39] <sorear> If you ever figure out how to make this work, tell us.

[05:40] <sorear> I would very much like to know why loading languages in Parrot is so balky.

[05:43] <snarkyboojum> satyavvd: something like this

[05:43] <snarkyboojum> rakudo: class B { method class_B{} }; role A is B { method role_A(Str $test) {} }; say A.^methods(:global)

[05:43] <p6eval> rakudo 18d996: OUTPUT«role_A␤»

[05:43] <snarkyboojum> rakudo: class D { method class_D{} }; class C is D { method role_C(Str $test) {} }; say C.^methods(:global)

[05:43] <p6eval> rakudo 18d996: OUTPUT«role_Cclass_DcanNumericelemsendreduceStrkeysreverseisauniqclassifymappairskvACCEPTSminmaxpickfirstminmaxdoesgrepvaluesjoinWHICHperlCREATECapturePARROTblessWHENCEWHERElistnotdefBUILDALLnewBoolsayprintdefinedWALKitemBUILDREJECTSclone␤»

[05:43] <snarkyboojum> rakudo: class B { method class_B{} }; role A is B { method role_A(Str $test) {} }; say A.new.^methods(:global)

[05:43] <p6eval> rakudo 18d996: OUTPUT«role_Aclass_BminmaxdoesgrepvaluesjoincanNumericelemsendreduceStrreversekeysuniqisaclassifymappairskvACCEPTSminmaxpickfirstBUILDALLnewBoolsayprintdefinedWALKitemREJECTSBUILDcloneWHICHperlCREATECapturePARROTblessWHENCEWHERElistnotdef␤»

[05:44] <dukeleto> sorear: i will let y'all know, but would appreciate any help peeps in here have to give :)

[05:44] <snarkyboojum> not saying it's right, but that's what happens with Hash (a role) inheriting from a class (EnumMap)

[05:44] <satyavvd> ok

[05:45] <snarkyboojum> ask jnthn or someone.. could be a bug (I don't know enough) :)

[05:46] <satyavvd> yup ..Thanks

[05:46] *** BrowserUk joined
[05:49] *** yinyin joined
[05:55] <[Coke]> anyone recall the git magic to make the old 'ng' branch the new 'master' ?

[05:56] <sorear> git checkout master; git reset --hard ng

[05:56] <dukeleto> [Coke]: git branch -M ng master

[05:59] *** hudnix left
[06:01] *** eternaleye left
[06:02] <[Coke]> dukeleto: what happens to master then?

[06:02] <[Coke]> (old master)?

[06:04] <dukeleto> [Coke]: it goes into the ether, maybe not what you want

[06:05] <dukeleto> [Coke]: but you could do git branch -m master old_master beforehand

[06:05] *** frodwith left
[06:06] *** uniejo joined
[06:06] <[Coke]> dukeleto: eh. ether is prolly OK in this case. danke.

[06:07] *** frodwith joined
[06:18] *** eternaleye joined
[06:19] *** Su-Shee joined
[06:25] *** abhy joined
[06:28] *** abhy left
[06:35] *** justatheory left
[06:45] *** xomas left
[06:46] <moritz_> good morning

[06:46] *** viklund joined
[06:47] *** frodwith left
[06:48] <sorear> good morning moritz_

[06:48] <moritz_> installing Try::Tiny...

[06:49] <BinGOs> There is no try there is only do.

[06:49] <sorear> really?

[06:50] * BinGOs was throwing StarWars™ quotes around.

[06:50] <sorear> Try::Tiny has been a Moose dependency for quite a while

[06:50] *** frodwith joined
[06:52] <moritz_> ouch

[06:52] <szabgab> is    use v6;   required by the specs ?      currently rakudo can live without it

[06:52] <moritz_> I've tried to build a debian package for Try::Tiny

[06:52] <moritz_> and had the local::lib env variables lying around

[06:53] <moritz_> so it made a debian package that installed into /home/moritz/perl/

[06:53] <moritz_> szabgab: "it depends" (more)

[06:53] <moritz_> szabgab: when the binary is called 'perl6', v6 is the default mode

[06:54] <moritz_> szabgab: but if the binary is called 'perl', v5 should be the default, and the 'use v6;' is required to enable Perl 6 mode

[06:54] <szabgab> rakudo: my $x = 0; while ($x < 3) { say $x++ }

[06:54] <p6eval> rakudo 18d996: OUTPUT«0␤1␤2␤»

[06:54] <szabgab> rakudo: my $x = 0; while ($x < 3){ say $x++ }

[06:54] <p6eval> rakudo 18d996: OUTPUT«===SORRY!===␤Missing block at line 11, near ""␤»

[06:54] <szabgab> this is a parsing error right?

[06:54] <moritz_> yes

[06:54] <moritz_> without a space, the {...} is parsed as a postcircumfix

[06:55] <moritz_> the right thing to do is to omit the parens

[06:55] <moritz_> rakudo: my $x = 0; while $x < 3 { say $x++ }

[06:55] <szabgab> oh, so it will never work that way?

[06:55] <p6eval> rakudo 18d996: OUTPUT«0␤1␤2␤»

[06:55] <moritz_> right

[06:55] <moritz_> std: my $x = 0; while ($x < 3){ say $x++ }

[06:55] <szabgab> ah

[06:55] <p6eval> std 31074: OUTPUT«===SORRY!===␤Missing block (apparently gobbled by undeclared routine?) at /tmp/BjbKAwHt8k line 1 (EOF):␤------> my $x = 0; while ($x < 3){ say $x++ }⏏<EOL>␤Parse failed␤FAILED 00:01 111m␤»

[06:55] <szabgab> ty

[06:55] <moritz_> you're welcome

[06:56] <moritz_> sorear: STD.pm build goes much further this time

[06:56] <moritz_> like, finished \o/

[06:59] <moritz_> afk

[06:59] *** plobsing left
[07:16] <Su-Shee> GNAGNA. COULD I PLEASE HAVE PERL6 NOW? this is a nuisance, this old stuff. 

[07:16] *** aindilis left
[07:17] *** aindilis` joined
[07:25] *** xomas_ joined
[07:25] *** xomas_ left
[07:25] *** xomas_ joined
[07:41] *** clintongormley joined
[07:41] *** ejs joined
[07:45] <pugssvn> r31075 | sorear++ | [viv] Start bringing _PATTERN under the DEEP framework, and implement combination of quantifiers with atom regexes.  -2% STD.pm5 size 

[07:48] *** ejs left
[07:48] *** ejs joined
[07:49] <sorear> TimToady: I'd love to optimize [ a | b ] into <[ a b ]>; could that be made to play nicely with LTM?

[07:53] *** aindilis` left
[07:57] *** wallberg joined
[07:58] *** BrowserUk left
[07:58] *** zostay left
[07:59] <szabgab> what is your suggested way to prompt for a value with a condition?   my $val = prompt("Please give number below 50"); while $val >= 50 { $val = prompt("Please...") }

[07:59] <szabgab> that has the same prompt twice

[07:59] *** zostay joined
[08:00] *** dms joined
[08:00] <szabgab> I guess:   my $val; while not defined $val or $val >= 50 { $val = prompt("...") }

[08:00] <szabgab> anything better ?

[08:00] <mathw> Morning

[08:00] <szabgab> gm

[08:01] *** dms left
[08:02] <moritz_> while my $val = promt(...) < 50 { ... }

[08:02] <moritz_> while my $val = promt(...) < 50 { 1 }

[08:04] <moritz_> 1 while (my $val = prompt(...)) < 50;

[08:05] <szabgab> "Ask the user. If the answer is incorrect, ask again."

[08:05] <szabgab> $val = prompt() while $val < 50;

[08:06] <szabgab> that's not even the right translation

[08:07] <sorear> sub ask($sm, $prompt) { my $val; do { $val = prompt $prompt } until $val ~~ $sm; $val }

[08:07] <moritz_> ask: my $val = prompt(); if $val < 50 { got ask };

[08:07] <moritz_> s/got/goto/

[08:07] <moritz_> j/k :-)

[08:07] <sorear> ask * >= 50, "Enter a number over 50"

[08:08] <moritz_> rakudo: say prompt()

[08:08] <p6eval> rakudo 18d996: OUTPUT«No applicable candidates found to dispatch to for 'prompt'. Available candidates are:␤:(Any $msg)␤␤  in main program body at line 11:/tmp/utKUl1Z0j4␤»

[08:08] <moritz_> rakudo: say prompt('')

[08:08] <p6eval> rakudo 18d996: OUTPUT«Land der Berge, Land am Strome,␤»

[08:08] <hejki> :D

[08:09] *** Snarkyboojum_ joined
[08:09] *** Snarkyboojum_ left
[08:10] <moritz_> rakudo: say $*IN.slurp.substr(0, 10)

[08:10] <p6eval> rakudo 18d996: OUTPUT«Land der B␤»

[08:10] <pugssvn> r31076 | sorear++ | [viv] Combine regexes in sequence nodes 

[08:10] <sorear> is that the German national anthem?

[08:11] <moritz_> rakudo: say $*IN.slurp.comb.classify({$_}).sort({+.value}).batch(5).map({.key})

[08:11] <moritz_> sorear: Australian

[08:11] <p6eval> rakudo 18d996: OUTPUT«Method 'batch' not found for invocant of class 'Parcel'␤  in main program body at line 11:/tmp/KZgpvkWzA6␤»

[08:11] <moritz_> rakudo: say $*IN.slurp.comb.classify({$_}).sort({+.value}).[^5].map({.key})

[08:11] <p6eval> rakudo 18d996: OUTPUT«TZAÄD␤»

[08:12] <moritz_> sorear: erm, Austrian

[08:12] <moritz_> close miss :-)

[08:12] <moritz_> rakudo: say $*IN.slurp.comb.classify({$_}).sort({-.value}).[^5].map({.key})

[08:12] <p6eval> rakudo 18d996: OUTPUT«e rin␤»

[08:13] *** JimmyZ joined
[08:13] <JimmyZ> rakudo: &$foo;

[08:13] <p6eval> rakudo 18d996: OUTPUT«===SORRY!===␤Confused at line 11, near "&$foo;"␤»

[08:15] <JimmyZ> known bug?

[08:15] <sorear> rakudo: $foo();

[08:15] <p6eval> rakudo 18d996: OUTPUT«===SORRY!===␤Symbol '$foo' not predeclared in <anonymous>␤»

[08:15] <sorear> JimmyZ: syntactically invalid

[08:15] <moritz_> std: my $foo; &$foo

[08:15] <p6eval> std 31075: OUTPUT«ok 00:01 108m␤»

[08:15] <moritz_> JimmyZ: I think it's known

[08:16] <JimmyZ> moritz_: ok, ignore it :)

[08:17] <szabgab> rakudo: while my $val = prompt("num ") >= 10 {}; say $val;

[08:17] <p6eval> rakudo 18d996: OUTPUT«num 0␤»

[08:18] <szabgab> that's not good as the second $val is not the same scope 

[08:18] <moritz_> it is

[08:18] <moritz_> in Perl 6

[08:19] <moritz_> rakudo: while (my $val = prompt("num ")) ~~ /Strome/ {}; say $val;

[08:19] <p6eval> rakudo 18d996: OUTPUT«num num Land der Äcker, Land der Dome,␤»

[08:19] <szabgab> ok, maybe it is but I get 0 there

[08:19] <szabgab> no matter how hard I press the keyboard :-(

[08:19] <moritz_> yes, because $*IN doesn'T contain numbers

[08:19] <moritz_> (on p6eval at least)

[08:20] <szabgab> rakudo: while my $num = 7 >= 10 {}; say $num;

[08:20] <p6eval> rakudo 18d996: OUTPUT«0␤»

[08:20] <moritz_> precedence

[08:20] <szabgab> rakudo: while (my $num = 7) >= 10 {}; say $num;

[08:20] <p6eval> rakudo 18d996: OUTPUT«7␤»

[08:21] <szabgab> rakudo: while (my $num = 12) >= 10 {}; say $num;

[08:21] <szabgab> ok I tripped it :-)

[08:21] <p6eval> rakudo 18d996:  ( no output )

[08:21] <moritz_> no worries, it has a timeout

[08:21] <szabgab> so I need the parentheses there I think, right?

[08:22] <szabgab> for the precedence

[08:22] <moritz_> right

[08:22] <moritz_> because comparisons are tighter than assignment

[08:24] *** Maddingue[work] joined
[08:25] <szabgab> if I could write it      my $num = prompt while $num >= 10;   ...

[08:25] <szabgab> rakudo: my $num = 7 while $num >= 10;  say $num;

[08:25] <p6eval> rakudo 18d996: OUTPUT«Use of uninitialized value in numeric context␤Any()␤»

[08:26] <szabgab> rakudo: my $num = 7 while not defined $num or $num >= 10;  say $num;

[08:26] <p6eval> rakudo 18d996: OUTPUT«7␤»

[08:27] *** eternaleye left
[08:31] <pugssvn> r31077 | moritz++ | [t/spec] unfudge some advent tests for rakudo 

[08:32] *** pmurias joined
[08:34] <dalek> rakudo: a1140cc | moritz++ | build/PARROT_REVISION:

[08:34] <dalek> rakudo: bump PARROT_REVISION to get latest nqp-rx fixes

[08:34] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a1140cc736a9028574eb5d976265db69efa56bb8

[08:37] *** eternaleye joined
[08:40] *** dakkar joined
[08:44] *** wallberg left
[08:47] *** snarkyboojum left
[08:48] <moritz_> \o/ all JSON parsing tests pass agian

[08:50] <pugssvn> r31078 | sorear++ | [viv] Fix a bug which caused 345 unneccessary lazymaps in STD.pm5.  (But only saves 15 seconds?) 

[08:52] *** meppl joined
[08:53] *** snarkyboojum joined
[08:54] <moritz_> rakudo: 'a b c'.subst(/<alpha>/, -> $m { uc $m }, :g)

[08:54] <p6eval> rakudo a1140c:  ( no output )

[08:54] <moritz_> rakudo: say 'a b c'.subst(/<alpha>/, -> $m { uc $m }, :g)

[08:54] <p6eval> rakudo a1140c: OUTPUT«A B C␤»

[09:05] * sorear starts a NYTProf run over STD.pm6 and goes to sleep

[09:08] *** dju joined
[09:08] <moritz_> rakudo: say 'abc'.samemark('ö')

[09:08] <p6eval> rakudo a1140c: OUTPUT«Method 'samemark' not found for invocant of class 'Str'␤  in main program body at line 11:/tmp/Uip9Zlpb4l␤»

[09:18] <moritz_> rakudo: Range ~~ Iterable

[09:18] <p6eval> rakudo a1140c:  ( no output )

[09:18] <moritz_> rakudo: say Range ~~ Iterable

[09:19] <p6eval> rakudo a1140c: OUTPUT«1␤»

[09:19] <moritz_> rakudo: say Positional ~~ Iterable

[09:19] <p6eval> rakudo a1140c: OUTPUT«0␤»

[09:22] *** ispeak joined
[09:32] *** pmurias left
[09:38] *** ruoso joined
[09:52] <snarkyboojum> hi moritz_ 

[09:52] <snarkyboojum> someone noticed this today http://gist.github.com/423699, is it buggy or how things are supposed to work?

[09:55] <moritz_> snarkyboojum: I think it's ok (more)

[09:56] <snarkyboojum> ah ok - so only shows the first method in the role

[09:56] <moritz_> snarkyboojum: because a role can't really inherit from a class... it can just pass on the inheritance rule to classes it's mixed into

[09:56] <snarkyboojum> Mmm.. okydoke.. the real world example was Hash (it's a role that inherits from EnumMap)

[09:57] <snarkyboojum> so inspecting Hash.^methods for example, only shows the methods in the Hash role

[09:57] <moritz_> rakudo: my @a = < a b c d e>; my @b = <X Y>; say @a Z @b xx * -> $a, $b { say "$a$b" }

[09:57] <p6eval> rakudo a1140c: OUTPUT«===SORRY!===␤Confused at line 11, near "say @a Z @"␤»

[09:57] *** yinyin left
[09:57] *** masak joined
[09:58] <moritz_> rakudo: my @a = < a b c d e>; my @b = <X Y>; for @a Z @b xx * -> $a, $b { say "$a$b" }

[09:58] <p6eval> rakudo a1140c: OUTPUT«a_block60␤»

[09:58] <snarkyboojum> rakudo: say Hash.^methods()

[09:58] <moritz_> rakudo: my @a = < a b c d e>; my @b = <X Y>; for @a Z (@b xx *) -> $a, $b { say "$a$b" }

[09:58] <p6eval> rakudo a1140c: OUTPUT«listBoolpostcircumfix:<{ }>!STOREpushdelete!push_constructsort␤»

[09:58] <p6eval> rakudo a1140c: OUTPUT«a_block60␤»

[09:58] <snarkyboojum> say Hash.new().^methods()

[09:59] <moritz_> snarkyboojum: that's less than awesome... maybe there should be class Hash too, and then introspection should be tricked into using the class variant

[09:59] <snarkyboojum> moritz_: yeah - something to show all the methods you'd expect to see when introspecting perhaps

[09:59] <snarkyboojum> rakudo: say Hash.new().^methods()

[09:59] <p6eval> rakudo a1140c: OUTPUT«postcircumfix:<{ }>BoollistpushdeletesortiteratornewIntNumvaluesperlCaptureofelemsinvertStrreversepostcircumfix:<{

[09:59] <p6eval> ..}>keyspairscontainsexistskvACCEPTSfmtsqrtsinasincoshsuccsignasinhacosechabsucceilingunpolarfloorsamecasesubstrasechordroundflipsplitmatchacoshacosecwordscotancosechata…

[10:00] <moritz_> that matches 'sexist' :-)

[10:02] <snarkyboojum> also matches a 'shaco', an anagram for 'chaos'

[10:02] <snarkyboojum> :P

[10:02] <hejki> hehe :)

[10:02] <snarkyboojum> I certainly never knew 'keyspairscontainssexists'

[10:02] <hejki> contain sexist skv :)

[10:03] *** ive joined
[10:04] <masak> oh hai, #perl6.

[10:04] <phenny> masak: 02 Jun 23:28Z <jnthn> tell masak I did hack up something for you that should be enough for encode, see example code at http://gist.github.com/423175

[10:04] <phenny> masak: 02 Jun 23:29Z <jnthn> tell masak it's in ya buf branch, btw.

[10:04] <masak> jnthn: \o/

[10:04] <masak> will look.

[10:04] <snarkyboojum> hi masak o/

[10:04] <masak> hi. what a lovely day for some Perl 6 work. :)

[10:05] <snarkyboojum> beautiful rainy night here :)

[10:12] *** agentzh left
[10:12] <mathw> masak: what a shame I have to do $day-job instead

[10:13] <jnthn> morning

[10:13] <jnthn> well

[10:13] <jnthn> somewhere it is

[10:13] <masak> :)

[10:13] <jnthn> masak: I realized that I didn't implement elements.

[10:13] <masak> haven't looked yet.

[10:13] <masak> I just woke up too.

[10:14] <jnthn> masak: Though you may be able to work out how to do that from what's already theere...it's not like C actually has much syntax to get wrong. ;-)

[10:14] <masak> I'm actually learning C a bit now, so that suits me.

[10:14] <jnthn> :-)

[10:14] <masak> C is a cute little language.

[10:15] <jnthn> Yeah, it annoys me relatively little.

[10:15] <masak> and it's fast. sometimes I compile and I go, "hey, did it actually do anything?"

[10:15] <mathw> I usually end up frustrated with its primitiveness

[10:15] <jnthn> :-)

[10:15] <mathw> but it is refreshing after C++ compile times

[10:15] <jnthn> mathw: Well, if I'm writing in C I'm generally doing something that is in some sense "primitive".

[10:15] <arnsholt> The hardest thing in C (if you ask me) is function pointers

[10:16] <arnsholt> But they're not that hard =)

[10:16] <mathw> the syntax around function pointers is nasty

[10:16] <jnthn> arnsholt: That's only hard because the syntax is horrible.

[10:16] <mathw> but they're not that hard to actually use

[10:16] <jnthn> mathw: Heh. :-)

[10:16] <masak> I'm currently translating the Perl 6 Druid implementation to C, as an exercise: http://github.com/masak/sea-druid

[10:16] <mathw> function pointer typedefs are particularly entertaining

[10:16] <szabgab> rakudo: if (3 = 3|4) { say 3 }

[10:16] <p6eval> rakudo a1140c: OUTPUT«Cannot assign to readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 11:/tmp/bASHFoQTqG␤»

[10:16] <szabgab> rakudo: if (3 == 3|4) { say 3 }

[10:16] <p6eval> rakudo a1140c: OUTPUT«3␤»

[10:16] <szabgab> rakudo: if (3 != 3|4) { say 3 }

[10:16] <p6eval> rakudo a1140c:  ( no output )

[10:17] <szabgab> rakudo: unless (3 != 3|4) { say 3 }

[10:17] <p6eval> rakudo a1140c: OUTPUT«3␤»

[10:17] <szabgab> rakudo: unless (3 == 3|4) { say 3 }

[10:17] <p6eval> rakudo a1140c:  ( no output )

[10:17] <szabgab> hmm, I must have seen something else locally

[10:22] *** lestrrat is now known as lest_away

[10:24] *** Trashlord left
[10:29] *** Bzek joined
[10:37] <arnsholt> jnthn: Yeah, that's pretty much it =)

[10:42] *** JimmyZ left
[10:55] <szabgab> can I check if a string looks_like_number   without regexes involved?

[10:55] <moritz_> not really

[10:56] <moritz_> it's something we want to enable in a natural way

[10:56] <moritz_> but don't know yet how

[10:56] <szabgab> $x.can_convert_to_number

[10:56] <moritz_> the idea is that you just numify, and then somehow tell if there was information lost

[10:56] <jnthn> Well, you can always use the grammar's number regex as well rather than rolling your own, I guess.

[10:57] <jnthn> if +$foo eq $foo { ... } # quite strict

[10:57] <moritz_> too strict

[10:57] <jnthn> Depends what you're doing

[10:57] <moritz_> rakudo: say +"1234e5"

[10:57] <p6eval> rakudo a1140c: OUTPUT«123400000␤»

[10:58] <jnthn> Right. If you're dealing with exponents it's no good. :-)

[10:59] <masak> perl6: my $i = 5; while (--$i){ say "A" }

[10:59] <p6eval> rakudo a1140c: OUTPUT«===SORRY!===␤Missing block at line 11, near ""␤»

[10:59] <p6eval> ..elf 31078: OUTPUT«Parse error in: /tmp/4U9UVLw5Kb␤panic at line 1 column 11 (pos 11): Can't understand next input--giving up␤WHERE: my $i = 5; while (--$i){ say "A" }␤WHERE:           /\<-- HERE␤  STD_red/prelude.rb:99:in `panic'␤  STD_red/std.rb:76:in `scan_unitstopper'␤  STD_red/std.rb:224:in

[10:59] <p6eval> ..`com…

[10:59] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected end of input␤    expecting operator or bare or pointy block construct␤    at /tmp/XKTZRXP72S line 2, column 1␤»

[10:59] <masak> std: my $i = 5; while (--$i){ say "A" }

[10:59] <p6eval> std 31078: OUTPUT«===SORRY!===␤Missing block (apparently gobbled by undeclared routine?) at /tmp/QsDBGDtSHU line 1 (EOF):␤------> my $i = 5; while (--$i){ say "A" }⏏<EOL>␤Parse failed␤FAILED 00:01 112m␤»

[10:59] <jnthn> masak: The implementations. They all say you're wrong.

[10:59] <masak> ah, of course. postcircumfix<{ }>.

[10:59] <jnthn> ;-)

[11:00] <jnthn> Wow though. They all agree on something!

[11:00] <masak> szabgab complains at the end of http://szabgab.com/blog/2010/06/1275598393.html that this is the case.

[11:00] <szabgab> he always just complains :-)

[11:00] <masak> but apart from adding an excellent error message for this particular case, I don't really see what to do about it.

[11:00] <masak> szabgab: this is, I think, a sensible complaint.

[11:01] <szabgab> but I pulled out my basball cards and showed my son the Indians  and Orioles

[11:01] <masak> :)

[11:01] <szabgab> so he knows with who do we speak :)

[11:02] <masak> 哈哈

[11:06] <masak> from Twitter today: "roles are flat". http://twitter.com/zenogantner/status/15315000868

[11:06] <masak> I find this to be a very compelling explanation.

[11:08] <jnthn> masak: It's pretty much right.

[11:08] <jnthn> masak: Role composition is described as "flattening composition" in the original paper that proposed them.

[11:08] <masak> roles flatten when composed into classes. right.

[11:09] <jnthn> That's why beyond composition time, the only runtime connection between a class and a role is that the class knows it does the role.

[11:09] <jnthn> (I see some people mistakenly thing that we care about the role during method dispatch. We don't.)

[11:09] <jnthn> *think

[11:10] <masak> nod.

[11:11] <jnthn> Perl 6 has the additional interesting nugget that when you write a role you're actually writing a role factory really. But that's not something you tend to need to think about too much. :-)

[11:12] <masak> right.

[11:12] <masak> lunch &

[11:17] *** ispeak left
[11:20] *** rv2733 joined
[11:20] <colomon> rakudo: my $a = [1, 2, 3]; say ($a xx 4).perl

[11:20] <p6eval> rakudo a1140c: OUTPUT«[[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]␤»

[11:21] <colomon> rakudo: my @a = (1, 2, 3); say (@a xx 4).perl

[11:21] <p6eval> rakudo a1140c: OUTPUT«[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]␤»

[11:21] <hejki> :O

[11:21] <hejki> rakudo: my $a = (1,2,3); say ($a xx 4).perl

[11:21] <p6eval> rakudo a1140c: OUTPUT«[(1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3)]␤»

[11:22] <hejki> funnay

[11:22] <hejki> my $a = (1,2,3); my $b = (4,5,6); say (($a X $b) xx 4).perl

[11:22] <hejki> rakudo: my $a = (1,2,3); my $b = (4,5,6); say (($a X $b) xx 4).perl

[11:22] <p6eval> rakudo a1140c: OUTPUT«[(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]␤»

[11:23] <hejki> :O

[11:23] <hejki> i was expecting 4 times that long list 

[11:23] <hejki> rakudo: my $a = (1,2,3); my $b = (4,5,6); say ($a X $b xx 4).perl

[11:23] <p6eval> rakudo a1140c: OUTPUT«(1, (4, 5, 6), 1, (4, 5, 6), 1, (4, 5, 6), 1, (4, 5, 6), 2, (4, 5, 6), 2, (4, 5, 6), 2, (4, 5, 6), 2, (4, 5, 6), 3, (4, 5, 6), 3, (4, 5, 6), 3, (4, 5, 6), 3, (4, 5, 6))␤»

[11:23] <hejki> whoa :O 

[11:25] <colomon> seems to me (($a X $b) xx 4) is a bug.

[11:25] <colomon> probably related to exhausting the iterator that $a X $b returns.

[11:25] <moritz_> aye

[11:26] <colomon> rakudo: my $a = (1,2,3); my $b = (4,5,6); my @a = ($a X $b).Seq; say (@a xx 4).perl

[11:26] <p6eval> rakudo a1140c: OUTPUT«[(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6), (1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6), (1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6), (1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3,

[11:26] <p6eval> ..5), (…

[11:26] <jnthn> Maybe the refactors pmichaud++ is working on will help with that.

[11:27] <hejki> :)

[11:27] <colomon> I've just been looking at the new hyper stuff, and it seems to me that the (@dwimmyside xx *).batch(@otherside.elems) formulation is badly broken, in practical terms.

[11:28] <moritz_> aye

[11:28] <colomon> or maybe it's just a flattening thing?

[11:29] <colomon> rakudo: my $a = (1,2,3); my $b = (4,5,6); my @a = ($a X $b).Seq; say (@a xx 4).batch(3)

[11:29] <p6eval> rakudo a1140c: OUTPUT«Method 'batch' not found for invocant of class 'Array'␤  in main program body at line 11:/tmp/EtXPsYaQUA␤»

[11:29] <colomon> well, that.

[11:29] <colomon> hmmm....

[11:31] <hejki> :D

[11:37] * moritz_ has a pseudo-LTM .trans-implementation for literal strings

[11:38] *** LylePerl left
[11:39] <jnthn> moritz_: \o/

[11:39] <jnthn> moritz_: Once .trans is in place, I may be able to find tuits to look at tr///.

[11:40] <moritz_> jnthn: shouldn't be too hard... .trans does the parsing of ranges itself

[11:40] <jnthn> *nod*

[11:40] *** CSSphil joined
[11:40] *** CSSphil left
[11:40] <jnthn> moritz_: I want to try and fix up smart-matching too

[11:40] <moritz_> \o/

[11:41] <jnthn> moritz_: So it sets $_ as the RHS

[11:41] <jnthn> *for the RHS

[11:41] * colomon has a first stab at implementing the new rules for hyper

[11:41] <jnthn> moritz_: Though I do wonder...

[11:41] <colomon> oooo, and compile fail

[11:41] <jnthn> $_ = 42; 'lol' ~~ worreva; say $_; # lol or 42? 

[11:41] <jnthn> colomon: Oh?

[11:42] <moritz_> jnthn: 42

[11:42] <jnthn> colomon: In master, or after the mods?

[11:42] <colomon> jnthn: just typos, I think.

[11:42] <jnthn> moritz_: Why?

[11:42] <colomon> jnthn: announcing my code very prematurely.  ;)

[11:42] <jnthn> moritz_: That is, does this mean ~~ should not only set $_ but then unset it again afterwards?

[11:42] *** pkkm joined
[11:42] <moritz_> jnthn: I think so... it's a micro-topicalizer

[11:42] <moritz_> jnthn: but better check the spec (or TimToady) first

[11:42] <jnthn> OK. That makes it less fun to implement.

[11:43] <moritz_> thought so.

[11:43] <jnthn> The spec didn't see to be clear on either, from what I recall. But I should check latest.

[11:44] <jnthn> Probably it's too surprising if we don't unset it.

[11:44] *** snarkyboojum left
[11:44] <jnthn> Though of course one day somebody is going to write for @x { if $y ~~ $_ { ... } } and get a surprise when they realize they're doing the equivalent of "if $y ~~ $y { ... }" :-)

[11:45] <colomon> > say ((1..10) <<~>> <A B C>).perl

[11:45] <colomon> ["1A", "2B", "3C", "4A", "5B", "6C", "7A", "8B", "9C", "10A"]

[11:45] <jnthn> ooh!

[11:45] <jnthn> colomon++

[11:45] <moritz_> colomon++ indeed

[11:45] *** moritz_ sets mode: +o colomon

[11:46] <colomon> > say ((1..10) <<~<< <A B C>).perl

[11:46] <colomon> ["1A", "2B", "3C"]

[11:46] <colomon> > say ((1..10) >>~>> <A B C>).perl

[11:46] <colomon> ["1A", "2B", "3C", "4A", "5B", "6C", "7A", "8B", "9C", "10A"]

[11:46] <colomon> > say ((1..10) >>~<< <A B C>).perl

[11:46] <colomon> Sorry, sides are of uneven length and not dwimmy.

[11:46] <jnthn> \o/

[11:46] <moritz_> (at this point I'm happy that lambdabot is permanently gone)

[11:46] <colomon> code is actually kind of cleaner after the change, too.

[11:46] *** satyavvd left
[11:47] *** JimmyZ joined
[11:52] <pugssvn> r31079 | moritz++ | [t/spec] fudge trans.t for Rakudo, and remove ambiguous rule for whitespace translation from one test 

[11:56] <jnthn> lunch &

[11:58] <dalek> rakudo: 3a6b43f | moritz++ |  (2 files):

[11:58] <dalek> rakudo: First shot at pure-Perl Cool.trans

[11:58] <dalek> rakudo: It handles simple ranges and only literals as patterns.

[11:58] <dalek> rakudo: The range unpacking is greatly inspired by (David Green)++'s p6c mail.

[11:58] <dalek> rakudo: Also pyramidine++ for his initial implementation.

[11:58] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/3a6b43feb3f9f948ac989f49a3cddc214cfd1788

[11:58] <szabgab> rakudo: say 1; exit; say 2

[11:58] <p6eval> rakudo a1140c: OUTPUT«1␤␤  in main program body at line 1␤»

[11:58] <moritz_> rakudo: say ord('ö').fmt('%04x')

[11:58] <p6eval> rakudo a1140c: OUTPUT«00f6␤»

[11:59] <szabgab> calling exit; is not loved in rakudo ?

[12:00] <moritz_> szabgab: worth a bug report

[12:01] <szabgab> still rakudobug @ perl.org ?

[12:02] <moritz_> yes

[12:02] *** moritz_ sets mode: +o szabgab

[12:03] *** ejs left
[12:07] *** Trashlord joined
[12:07] <szabgab> thanks

[12:08] *** ejs joined
[12:08] <szabgab> another strange thing is that     prompt() throws and exception but    prompt ()    (with a space) works

[12:08] <moritz_> that's because the () counts as a positional argument

[12:08] <szabgab> also prompt ("what?") works

[12:09] <moritz_> and prompt expects one argument

[12:09] <moritz_> it's pretty easy to give it a default value, if you can think of a good default

[12:09] <szabgab> so that means that if I want to put parenthese around the function parameters I have to do it without leaving any space, right?

[12:10] <moritz_> right

[12:10] <szabgab> any function I mean

[12:10] <szabgab> ok

[12:11] <szabgab> I am not sure what does that mean that we are tripped so easily by such cases

[12:12] <moritz_> it means that Perl 5 users do need to learn a few rules

[12:15] *** ejs left
[12:16] *** ejs joined
[12:16] <takadonet> morning all

[12:16] *** cognominal left
[12:17] <szabgab> so what would be the recommended way to prompt for nothing?

[12:17] <szabgab> prompt('')   or prompt () ?

[12:17] <szabgab> or prompt ''; ?

[12:17] <moritz_> $*IN.get

[12:17] <szabgab> :)

[12:18] <moritz_> there's no reason to use prompt if you don't have a prompt

[12:18] <szabgab> I thoughtthat $*IN was gone

[12:18] <moritz_> it's the prefix:<=> that is gone

[12:18] <szabgab> ok

[12:18] <moritz_> former =$*IN is now $*IN.get

[12:21] *** cognominal joined
[12:24] <jnthn> That exit bug is already ticketed by masak++, I believe.

[12:30] *** masonkramer_ left
[12:32] <mathw> I just realised how appropriate it is that the global filehandles have a * twigil

[12:32] *** bluescreen joined
[12:32] <mathw> I may now have to go and swoon over Perl 6's beauty for a while

[12:33] *** bluescreen is now known as Guest21689

[12:47] <pmichaud> good morning, #perl6

[12:47] <takadonet> pmichaud: morning

[12:48] <colomon> o/

[12:48] <jnthn> morning, pmichaud 

[12:48] <pmichaud> szabgab++   # excellent Perl tips and tricks posting 

[12:57] *** Bzek left
[12:58] *** proller left
[13:00] *** bjarneh left
[13:01] *** sorear left
[13:02] *** sorear joined
[13:07] <pugssvn> r31080 | colomon++ | [t/spec] Fix up for new hyper rules, unfudge tests that now work. 

[13:09] <mathw> hi pmichaud

[13:09] <dalek> rakudo: 2242efb | (Solomon Foster)++ | src/core/metaops.pm:

[13:09] <dalek> rakudo: Implement the new rules for handling hypers of different lengths.

[13:09] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/2242efb89371a83c389536b84e1f438e872e145e

[13:10] <masak> morning, pmichaud.

[13:10] <mathw> pmichaud: I'm curious how difficult you think http://rt.perl.org/rt3//Public/Bug/Display.html?id=73608 is to fix (nqp-rx regexes won't backtrack properly into capturing parentheses or subrules)

[13:10] *** proller joined
[13:14] <masak> I'm curious about what causes that.

[13:15] <mathw> I don't care as long as it goes away :)

[13:15] <pmichaud> it's not trivial.

[13:15] <mathw> pmichaud: I thought you might say that :(

[13:16] <masak> pmichaud: so it's not a bug so much as never implemented in nqp-rx?

[13:16] <pmichaud> basically, we have to suspend execution of the regex submatch (i.e., a Parrot sub), and then have a way to restart it again when we backtrack it.

[13:16] <masak> heh, the exact same thing GGE needs to do next. :)

[13:17] <masak> pmichaud: how do you plan to save state?

[13:17] <pmichaud> the cursor already holds state, actually

[13:17] *** bjarneh joined
[13:17] <masak> even the internal state of a partial subrule match?

[13:17] <pmichaud> yes

[13:17] <masak> cool.

[13:17] <masak> that's just so... right.

[13:17] <pmichaud> in PGE it was handled via Parrot coroutines, but for a variety of reasons I didn't want to use that approach in nqp-rx

[13:18] <[Coke]> pmichaud: parrot should let you do that with yield already.

[13:18] <[Coke]> ... unless you don't want to use that approach. =-)

[13:18] <pmichaud> [Coke]: yes, yield is the way that PGE did it.

[13:18] <masak> the approach in GGE will have to be 'insane cheating', I fear.

[13:18] <mathw> masak: nooooo

[13:18] <pmichaud> 'yield' doesn't seem to play well with methods or lexicals, I fear.

[13:18] <mathw> masak: it must be elegant and beautiful

[13:18] <masak> mathw: have you actually *looked* at GGE? :P

[13:18] <pmichaud> and it also requires an insane amount of cloning in order to work

[13:18] <mathw> masak: I assumed it was elegant and beautiful :P

[13:19] <masak> mathw: it's Perl 6 code generating Perl 6 code. guess again. :)

[13:19] <[Coke]> pmichaud: still, if you think that's a /bug/ and not a feature you can't use...

[13:19] <mathw> masak: and why shouldn't that be elegant? :)

[13:19] <masak> mathw: chiefly because we don't have heredocs. :/

[13:20] <masak> (more "can't" than "shouldn't", acutally)

[13:20] <colomon> oh yeah, heredocs would be a lovely thing to have...

[13:20] <mathw> mmm heredocs

[13:20] <pmichaud> Q {{{

[13:20] <pmichaud>     this is a heredoc

[13:21] <pmichaud>     with a lot of stuff in it

[13:21] <pmichaud> }}}

[13:21] <masak> that's what I do now.

[13:21] <pmichaud> well.... there ya go.  :-)

[13:21] <masak> still messes up the indentation beyond repair :(

[13:21] *** lest_away is now known as lestrrat

[13:21] <mathw> pfft

[13:21] <pmichaud> I keep thinking we ought to have a method on Str that means "remove indentation"

[13:21] <masak> and indentation is the first thing on my list of necessities for something elegant.

[13:21] <mathw> build a tree that represents the program and render it in one pass so it's all hidden away

[13:21] <pmichaud> we're going to need it for the parser anyway, might as well expose it to the programmer too.

[13:22] <mathw> you're allowed to be slow, it's in the name

[13:22] <masak> pmichaud: Str.unindent

[13:22] <masak> I like.

[13:22] <mathw> pmichaud: a lot of people would love you for that

[13:22] <pmichaud> .unindent is perfect

[13:22] <masak> and it would have the same semantics as Perl 6 heredocs.

[13:22] <pmichaud> sounds like a good weekly challenge

[13:22] <masak> \o/

[13:22] <mathw> it's also eminently writeable

[13:22] * masak goes to spec it

[13:22] <pmichaud> yes, same semantics as heredocs

[13:22] <mathw> \o/

[13:23] *** plainhao joined
[13:24] *** ejs left
[13:24] <pmichaud> [Coke]: (yield)  Given all of the current issues surrounding Parrot continuations and resuming from them, trying to get .yield "fixed" isn't something I'm wanting to invest a lot of time in.

[13:25] <pmichaud> s/lot of time/lot more time/

[13:26] <masak> I'll take "same semantics as heredocs" to mean that the terminator of the heredoc is the last line of the string to be unindented, and all indentation is removed relative to that.

[13:26] <pmichaud> I'd think the terminator wouldn't be present

[13:26] <masak> it's relative to that we're unindenting.

[13:26] <pmichaud> yes, I agree.  I can see two possibilities

[13:27] <masak> if it's not present during parsing, stick it in there and then do Str.unindent.

[13:27] <jnthn> masak: The heredoc thingy could pass in the number of chars to unindent by.

[13:27] <masak> oh, ok.

[13:27] <pmichaud> what jnthn++ said

[13:27] <masak> I can do that.

[13:27] <masak> that's probably wiser.

[13:27] <jnthn> Which means .unindent is a bit more genericly useful.

[13:27] <pmichaud> and if nothing is passed in, then compute it based on the least-indented line

[13:27] <jnthn> ooh

[13:27] <masak> in that case, it feels silly not to have .indent.

[13:27] <jnthn> :-D

[13:27] <jnthn> .oO( Perl 6: optimized for writing an IDE )

[13:27] <mathw> indeed

[13:27] <masak> let's just have that, and allow negative integers.

[13:28] <mathw> jnthn: if it was optimised for writing an IDE, it wouldn't have grammar munging

[13:28] <jnthn> mathw: Optimized for overjoying and tormenting the IDE writer in equal measure? ;-)

[13:29] <mathw> :) definitely

[13:32] *** JimmyZ_ joined
[13:33] *** JimmyZ left
[13:33] *** JimmyZ_ is now known as JimmyZ

[13:35] *** uniejo left
[13:35] <pugssvn> r31081 | masak++ | [S32/Str] proposed Str.indent 

[13:35] <pugssvn> r31081 | 

[13:35] <pugssvn> r31081 | Following an idea bounced around on #perl6, this method was added.

[13:37] <pmichaud> oh, I think .indent should be smart enough to handle tabs and other unicode whitespace

[13:37] <masak> then please spec how.

[13:38] <pmichaud> the same way that Perl 6 itself will handle them with heredocs

[13:38] <masak> I didn't see that in S02, so I didn't know how.

[13:38] <masak> oh wait. was it the $?TABSTOP thing?

[13:38] <masak> very well. I can add a note about that.

[13:39] <pmichaud> (Hard tabs will be assumed

[13:39] <pmichaud> to be C<< ($?TABSTOP // 8) >> spaces, but as long as tabs and spaces are used consistently

[13:39] <pmichaud> that doesn't matter.)

[13:39] <masak> ok.

[13:39] <masak> I'll change it to that.

[13:39] <jnthn> 8? That's big.

[13:39] <jnthn> ;-)

[13:39] <masak> it's the only real standard there is.

[13:39] <jnthn> :-)

[13:40] <masak> I keep thinking whether it'd make sense to have $code.indent(*) unindent such that at least one line has indent level 0. good idea or not?

[13:40] <masak> a sort of 'indent reset'.

[13:40] <pmichaud> oh, that works I think.

[13:40] * masak adds that too

[13:44] <szabgab> just thinking aloud, what about a construct like this?       my $num = prompt("bla", $_ >= 50);

[13:45] <szabgab> and $_ would be the value that was just received from the user

[13:45] <masak> szabgab: looks like that would need a closure around the $_ expression.

[13:45] <masak> szabgab: nothing stops you from writing such a multi method yourself.

[13:46] *** [mark] left
[13:46] <szabgab> let me try it then

[13:46] <masak> \o/

[13:47] <moritz_> msaak++ # str.indent

[13:49] *** hudnix joined
[13:49] *** cognominal left
[13:52] <pugssvn> r31082 | masak++ | [S32/Str] rethinking of tab characters 

[13:52] <pugssvn> r31082 | 

[13:52] <pugssvn> r31082 | Also added a Str.indent(*) use case.

[13:52] <masak> see how you like these changes.

[13:52] <moritz_> lemmy guess... indent(*) unindents the smallest amount of whitespace that's present on each line?

[13:52] <masak> [min] of all indents, yes.

[13:53] *** viklund left
[13:53] <moritz_> \o/

[13:53] <moritz_> masak++ # again

[13:54] <masak> that's what I'd primarily use it for in GGE, so it felt right to add it.

[13:54] <masak> who wants to add tests? :)

[13:54] <moritz_> the one who asks, of course

[13:55] * masak hides behind his GSoC work

[13:56] <moritz_> speaking of hiding behind work...

[13:56] <moritz_> I now have JSON::Tiny far enough to update the grammar chapter

[13:56] <masak> \o/

[13:57] <moritz_> the only real blocker left are escapes in char classes

[13:58] <jnthn> moritz_++

[14:02] *** ccube joined
[14:03] <moritz_> http://www.perlmonks.org/?node_id=842911 # I don't quite understand it, but it has 'Rakudo' in the title :-)

[14:03] <ccube> rakudo: sqrt(-1)

[14:03] <p6eval> rakudo 3a6b43:  ( no output )

[14:04] <moritz_> rakudo: say sqrt(-1)

[14:04] <p6eval> rakudo 3a6b43: OUTPUT«NaN␤»

[14:04] <moritz_> rakudo: say sqrt(-1+0i)

[14:04] <p6eval> rakudo 3a6b43: OUTPUT«0 + 1i␤»

[14:04] <ccube> thanks

[14:04] <moritz_> you're welcome

[14:05] <ccube> rakudo: say 3 ** 2

[14:05] <p6eval> rakudo 3a6b43: OUTPUT«9␤»

[14:05] <ccube> rakudo: say 3 ** 1i

[14:05] <p6eval> rakudo 3a6b43: OUTPUT«0.45483242282661 + 0.890577041667747i␤»

[14:06] <szabgab> http://paste.lisp.org/display/111108

[14:06] *** ejs joined
[14:06] <szabgab> shouldn't that pastebot support direct pasting to the channel?

[14:07] <moritz_> it should, but it seemed to be disabled since a recent spam wave

[14:07] <szabgab> ic

[14:07] <moritz_> szabgab: if declare the second argument as   Mu $cond, you can also pass junctions as matchers

[14:07] <szabgab> so how would you improve my multi prompt?

[14:07] <szabgab> Mu ?

[14:08] <moritz_> formerly known as Object

[14:08] <szabgab> as the cow speaks?

[14:08] <szabgab> Mu ?

[14:08] <szabgab> :)

[14:08] <moritz_> it speaks Muh in German :-)

[14:08] <masak> loop { last if $cond(prompt($str)) }

[14:09] <masak> ...perhaps. :)

[14:09] <masak> fewer tests and negations, at least.

[14:10] <masak> oh wait.

[14:10] <szabgab> and how would that cow work?

[14:10] <masak> loop { last if $cond($ret = prompt($str)) }

[14:10] <szabgab> I would need to check in the prompt method what type I got

[14:10] <szabgab> and do smart match?

[14:11] <szabgab> bbl &

[14:11] <szabgab> cds

[14:11] <masak> it's a bit funny that the main use of 'Mu' will be to make the routine say "I can handle junctions".

[14:14] *** skids joined
[14:14] *** pkkm left
[14:14] <pmichaud> moritz_: I think I can get escapes in char classes fairly quickly

[14:14] <moritz_> ++pmichaud

[14:15] *** JimmyZ left
[14:17] *** hudnix left
[14:18] *** JimmyZ joined
[14:20] *** pkkm joined
[14:23] *** hudnix joined
[14:29] *** hudnix left
[14:30] *** plobsing joined
[14:30] *** pkkm_ joined
[14:31] *** ccube left
[14:32] *** kaare joined
[14:32] *** kaare is now known as Guest17090

[14:33] *** pkkm left
[14:33] *** pkkm_ is now known as pkkm

[14:35] *** hudnix joined
[14:37] *** JimmyZ left
[14:48] <moritz_> should rule { <value> ** \, }  and  rule { value ** [ \, ] }  be the same in terms of <.ws> handling?

[14:49] <masak> er, no <> around 'value' in the second instance?

[14:49] <moritz_> imagine that was there :-)

[14:49] <pmichaud> in ultimate effect they're largely the same

[14:49] <masak> in that case, I certainly would hope they're semantically equivalent.

[14:49] <pmichaud> there may be some case where they're not perfectly the same.

[14:49] <moritz_> because in rakudo I see difference in the whitespace handling

[14:49] <pmichaud> because [ \, ]  has some extra <.ws> calls

[14:49] <moritz_> right

[14:50] <masak> oh, true.

[14:50] <pmichaud> I'm not sure that rakudo/nqp gets the whitespace handling around ** exactly right.

[14:50] <pmichaud> PGE had it there, but I don't know that I ever restored it for nqp-rx

[14:51] <pmichaud> I think nqp-rx still treats   { <value> ** \, }  exactly the same as   { <value>**\, }

[14:52] <moritz_> that would explain my observations

[14:52] <masak> ...which are...? :)

[14:53] <moritz_> some of my tests fails when I write <value> ** \, but pass if I write <value> ** [ \, ]

[14:53] <moritz_> rakudo: say 'a,b,c' ~~ /:s <alpha> ** \,/

[14:53] <p6eval> rakudo 2242ef: OUTPUT«a,b,c␤»

[14:53] <moritz_> rakudo: say 'a, b, c' ~~ /:s <alpha> ** \,/

[14:53] <p6eval> rakudo 2242ef: OUTPUT«a␤»

[14:53] <masak> can I submit that to RT?

[14:53] <moritz_> yes, please

[14:54] * masak submits rakudobug

[14:57] *** proller left
[14:57] *** ruoso left
[14:57] *** mantovani left
[14:58] *** pkkm left
[14:59] *** rv2733 left
[14:59] *** hercynium left
[15:00] *** proller joined
[15:03] *** justatheory joined
[15:04] *** justatheory left
[15:05] *** Guest43663 joined
[15:06] *** Trashlord left
[15:09] *** patspam joined
[15:10] <szabgab> is there a way to write to a file in a simple way as slurp reads?

[15:11] <moritz_> don't think so

[15:11] *** ruoso joined
[15:11] <szabgab> I think it would be very useful for small scripts and for beginners

[15:12] <moritz_> aye

[15:12] <moritz_> spew vs. slurp

[15:12] <szabgab> yeah

[15:12] <szabgab> spew "file", "content", "more content"

[15:12] <moritz_> let's see what TimToady thinks

[15:12] <jnthn> Oooh, here we go with the "who can make the most disgusting name for this" competition again. :-D

[15:12] <szabgab> vomit ?

[15:12] <jnthn> spit

[15:13] <moritz_> too close to split

[15:13] <jnthn> yeah

[15:13] <pmichaud> afk, errand

[15:13] <jnthn> "result".spew: chunks($<some_match>)

[15:13] <pmichaud> nqp-rx currently has (non-working) .spew in nqp-setting, fwiw

[15:14] <pmichaud> afk, errands

[15:14] *** finanalyst left
[15:14] *** molaf joined
[15:15] *** ejs left
[15:18] <masak> TimToady already opined re 'spew': http://irclog.perlgeek.de/perl6/2010-05-06#i_2298763

[15:18] <masak> it sure has my unvote. partly due to the name, and partly due to http://irclog.perlgeek.de/perl6/2010-05-06#i_2298740

[15:18] <moritz_> "we might also end up with @stuff ==> qp/file/ doing the right thing, in an ingyesque sense"

[15:19] * moritz_ likes ingyesque as a word

[15:19] <szabgab> say "Something" > "file"

[15:19] <szabgab> say "Something" ==> "file"

[15:20] <szabgab> qp?

[15:20] <moritz_> quote path

[15:20] *** plobsing left
[15:20] <szabgab> oh

[15:20] <szabgab> so qp/a b c/   would build  a/b/c  on linux ?

[15:21] *** cls_bsd left
[15:21] <moritz_> I don't know what the current spec is

[15:21] *** pmurias joined
[15:21] <pmurias> ruoso: ping

[15:22] <masak> I have a mental file named something like "things in the spec which are more flight of fancy than firmly nailed down spec, and whose disappearance or mutation to something else wouldn't surprise me much at all". qp<> is in it.

[15:23] *** ejs joined
[15:23] *** molaf left
[15:24] <moritz_> maybe $filename.IO.print(@stuff) could work as an alternative to spew

[15:24] <moritz_> or just s/IO/open/

[15:25] <masak> I'd expect 'open' somewhere along the line.

[15:25] <moritz_> btw I've created a branch in the json repo where I simplify JSON::Tiny

[15:25] <moritz_> part of it is to remove cruft

[15:26] <moritz_> the other part is to remove extra rules that just give better error messages

[15:26] <moritz_> http://github.com/moritz/json/commits/simplified_parsing

[15:26] <moritz_> the last few commits have simplified it quite a bit

[15:26] <moritz_> it seems that I'm now sufficiently familiar with match objects to find straight forward ways to write reduction methods

[15:27] <masak> anything bloggable?

[15:28] <masak> I know I'd be interested to read tips like that.

[15:28] <moritz_> just click on the last 5 commits or so

[15:28] * moritz_ hopes it's bookable

[15:28] <masak> even better.

[15:29] <moritz_> that's the main reason for this whole exercise

[15:29] <moritz_> and it was also my driving motivation for getting sane match objects into rakudo again

[15:30] <masak> motivations++

[15:37] *** cognominal joined
[15:43] *** zenog_ joined
[15:43] <zenog_> hi guys.

[15:44] <moritz_> hi zenog_ 

[15:45] *** bjarneh left
[15:50] *** rhr left
[15:52] <zenog_> One question about roles: Is it necessary to use a new "does" for each role?

[15:52] <zenog_> Like in "class Dog is Animal does Eat does Fetch"

[15:52] <zenog_> Or would that be possible as well: "class Dog is Animal does Eat, Fetch"

[15:53] <moritz_> it's not possible

[15:53] <moritz_> wait a sec, I'll find you a link to a discussion...

[15:53] *** shade__ joined
[15:53] <moritz_> http://www.nntp.perl.org/group/perl.perl6.language/2010/06/msg33748.html

[15:54] *** rhr joined
[15:54] <TimToady> but see S14:242

[15:55] *** ashleydev joined
[15:55] <zenog_> moritz_: Thanx.

[15:55] <moritz_> oh.

[15:55] <zenog_> moritz_: What about "class Dog is Animal does (Eat, Fetch)" ?

[15:55] <TimToady> parens solve the precedence problem

[15:56] <jnthn> std: role Eat { }; role Fetch { }; class Dog is Animal does (Eat, Fetch) { }

[15:56] <p6eval> std 31082: OUTPUT«===SORRY!===␤Unable to parse class definition at /tmp/2strzWor7B line 1:␤------> ole Fetch { }; class Dog is Animal does ⏏(Eat, Fetch) { }␤    expecting module_name␤Parse failed␤FAILED 00:01 110m␤»

[15:56] <TimToady> but could easily be made to parse

[15:56] <jnthn> TimToady: We (rightly, imo) only parse a module name there.

[15:57] <jnthn> TimToady: I'd prefer we either don't, *or* we parse a list of module names there and then say that you do one call to trait_mod:<does> for each of them.

[15:57] <jnthn> TimToady: But then we introduce an assymetry with the does operator

[15:57] <jnthn> So imho I'd prefer we stick with the status quo.

[15:57] <TimToady> the question is whether the semantics is sufficiently different...yes

[15:58] <jnthn> trait_mod:<does> and infix:<does> do kinda different things already, though. :-)

[15:58] <TimToady> is &[does] different from &[but=]  ?

[15:58] <TimToady> perhaps we could do away with &[does]

[15:58] <jnthn> At present, but is implemented in terms of does

[15:59] <jnthn> That is, it copies and then calls does.

[15:59] <jnthn> So does is currently the primitive.

[15:59] <TimToady> perhaps we should call that &[mixin] instead

[15:59] <jnthn> Perhaps.

[15:59] <TimToady> having 'does' mean two different things is a design smell

[16:00] <jnthn> Guess it depends of the alalogy with the trait_mod and infix is a helpful way to remember it or misleading.

[16:00] <jnthn> (Well, it's both, but I guess that's a spectrum rather than absolutes.)

[16:01] <TimToady> alternately, we could make 'does' list associative, and then $a does B does C mixes in both B and C as a composition, currently requiring (B,C)

[16:01] * sorear finishes backlog

[16:02] <pmurias> TimToady: mixing both B and C as composition would be nice

[16:02] * TimToady hasn't started backloging

[16:02] <TimToady> we can do that, but currenlty it's does (B,C)

[16:02] <jnthn> TimToady: True, though then we make the other thing longer :-)

[16:02] <jnthn> Well

[16:02] <jnthn> does

[16:02] <jnthn> ($a does B) does C

[16:02] <jnthn> If does is list infix then call does twice?

[16:03] <jnthn> e.g. the parens stop it "collapsing" to one call?

[16:03] <TimToady> that doesn't happen often enough to worry about de-huffmanization

[16:03] *** justatheory joined
[16:03] <jnthn> Sure, just want to make sure it's possible

[16:03] <TimToady> yes, they would be staged

[16:03] <jnthn> OK

[16:03] <jnthn> I've no real objections to that change.

[16:03] <jnthn> Would be make a parallel change to but?

[16:03] <TimToady> maybe

[16:03] <jnthn> s/be/we/

[16:04] <jnthn> Renaming it to mixin is fine by me too

[16:04] <TimToady> this might involve a precedence change though

[16:04] <jnthn> As is parsing a list of comma-seperated module names, but please spec it as multiple trait_mod calls or I suspect things get awkward.

[16:04] <jnthn> (that's for the trait_mod case)

[16:04] *** bjarneh joined
[16:05] <TimToady> currently does/but are structural infix, which are non-assoc

[16:05] <jnthn> Hmm

[16:06] <jnthn> I'm not sure people tend to use does and but in especially complex expressions, in general.

[16:06] <jnthn> So maybe not too big a deal.

[16:06] *** Trashlord joined
[16:07] <jnthn> So long as the common things like my $dugong = $manitee but Cow; works. :-)

[16:07] <TimToady> so they might have to move to one of the X levels in S03:32

[16:07] <jnthn> *nod*

[16:07] <jnthn> That doesn't strike me as immediately problematic.

[16:08] *** Maddingue joined
[16:08] <TimToady> I could argue putting them into concatenation, and then they could form values that can be & or | junctioned

[16:09] *** mikehh joined
[16:10] <TimToady> one argument for the listy form is that then you could do $x but @roles

[16:10] <jnthn> Hmm. :-)

[16:10] <jnthn> Yeah

[16:10] <TimToady> will think about it in the

[16:10] <TimToady> shower &

[16:10] <jnthn> Well, maybe you already can though.

[16:11] <jnthn> rakudo: role Cow { }; role Swim { }; my $manitee = "lol"; my @roles = Cow, Swim; $manitee does @roles; say $manitee ~~ Cow; say $manitee ~~ Swim;

[16:12] <p6eval> rakudo 2242ef: OUTPUT«No applicable candidates found to dispatch to for 'infix:<does>'. Available candidates are:␤:(Mu $do-it-to-me, Role $r)␤:(Mu $do-it-to-me, ConcreteRole $r)␤:(Mu $do-it-to-me, (Parcel) $roles)␤␤  in main program body at line 11:/tmp/oYpaMDzsXB␤»

[16:12] <jnthn> Ah no, it Must Be A Percel

[16:12] *** shade__ left
[16:12] <jnthn> :-)

[16:15] *** Trashlord left
[16:16] *** Trashlord joined
[16:19] <jnthn> afk for a little

[16:22] *** ejs left
[16:27] *** cls_bsd joined
[16:30] *** ejs joined
[16:32] *** ashleydev left
[16:32] *** ejs left
[16:35] *** shade__ joined
[16:36] <sorear> nice, 264MB nytprof.out

[16:37] <masak> could be worse.

[16:38] <sorear> every once in a while, I'm grateful I upgraded off the old 2000MB disk

[16:39] <masak> :)

[16:40] <sorear> massive error spam from nytprofhtml, though

[16:40] <sorear> nytprof hates me

[16:41] <[Coke]> I've found the nytprof authors to be very responsive.

[16:42] <[Coke]> I know a new release is imminent.

[16:43] <pmurias> sorear: did you try disabling per statement profiling?

[16:44] <sorear> pmurias: not yet.  it's so slow I have to run it overnight, anyway

[16:46] <sorear> negative 849 seconds spent in Cursor::_STARr.  This profile is useless

[16:47] *** ive left
[16:47] <masak> man, that's fast!

[16:47] *** ive joined
[16:49] <sorear> oh yeah and it was using CLOCK_MONOTONIC

[16:51] *** masak left
[16:52] <pmurias> sorear: you should call Cursor::_STARTr more often ;)

[16:53] *** justatheory_ joined
[16:54] *** justatheory left
[16:54] *** justatheory_ is now known as justatheory

[16:56] *** cdarroch joined
[16:56] *** cdarroch left
[16:56] *** cdarroch joined
[16:59] *** dakkar left
[16:59] <[Coke]> sorear - what version of nytprof are you using?

[17:01] *** justatheory left
[17:01] *** mantovani joined
[17:02] <sorear> 3.11

[17:06] *** ashleydev joined
[17:07] *** stephenlb joined
[17:08] <[Coke]> latest released version, eh. 4.0 should be out soon. might be worth grabbing from svn and seeing if that helps.

[17:10] <pmurias> re S29 shouldn't ++FOO a b c ++/FOO set %*OPTS<FOO> to ['a','b','c'] instead of 'a b c'?

[17:11] * sorear svn co

[17:11] *** justatheory joined
[17:14] <sorear> :/ nytprof svn fails make test

[17:15] <sorear> test22-strevala, test24-strevalc, and test61-submerge all have errors

[17:16] *** ashleydev_ joined
[17:16] <zenog_> bye guys

[17:16] *** zenog_ left
[17:17] *** c9s left
[17:18] <sorear> oh well, it's not going to be more buggy than what I already have

[17:18] <diakopter> sorear: nytprof was giving me negative measurements on STD a year ago

[17:18] <diakopter> (so it's not a new thing)

[17:19] <pmurias> diakopter: hi

[17:19] *** ashleydev left
[17:19] <sorear> NYTProf and Moose are incompatible locally

[17:19] <diakopter> hi

[17:19] <sorear> everybody I have complained to has not been able to repro

[17:20] <moritz_> sorear: should I try to profile STD?

[17:20] <sorear> that said, it's less-incompatible now than it used to be

[17:21] <sorear> 2.x gagged so hard that I had to comment out a warning message in NYTProf.xs, lest fprintf be 98% of CPU time

[17:21] <sorear> moritz_: let me try with 4.0-pre first

[17:23] *** macdaddy joined
[17:23] *** macdaddy is now known as Guest33137

[17:24] *** hudnix left
[17:31] *** supernovus joined
[17:31] <diakopter> sorear: I'm ready to begin dipping my emit_pq toes in viv

[17:32] <sorear> excellent

[17:33] <sorear> let's start with regexes; I've made the most progress towards the refactor there

[17:33] <sorear> look at ./viv -e 'grammar Foo; token bar { <?> }'

[17:33] <sorear> each line has a node type name

[17:33] <diakopter> I was thinking of starting at regexes too :)

[17:34] <sorear> some of these have emit_p5 methods; they'll need emit_psq methods

[17:34] <sorear> the insides of the regex are compiled via RE_ast and DEEP, so you'll want to add psq to DEEPbase and children

[17:35] <sorear> grr.  even with 4.00-pre I get Warning: 1 subroutine calls had negative time! The clock being used (2) is probably unstable, so the results will be as well.

[17:37] <dalek> book: 3b69131 | moritz++ | src/grammars.pod:

[17:37] <dalek> book: [grammars] mostly rewritten with proto regexes, and code that works in Rakudo 

[17:37] <dalek> book: master

[17:37] <dalek> book: review: http://github.com/perl6/book/commit/3b69131c87e47215f52f96a9590f950a33e32699

[17:38] <diakopter> oh

[17:38] <diakopter> I was running in a VM, so maybe time was adjusted while running.....

[17:38] <diakopter> are you in a VM?

[17:38] <sorear> no

[17:38] <sorear> also, the results are reproducable

[17:38] <sorear> _STARr always has huge negative time

[17:39] <moritz_> call it more often :-)

[17:39] <supernovus> on my local computer I have a Date.new(::DateTime $dt) {} method and a DateTime.Date() {} method. How would I go about submitting them back to the rakudo tree?

[17:40] <moritz_> supernovus: you make a commit locally

[17:40] <moritz_> git commit -am 'implemented $supermethods'

[17:40] <moritz_> # uhm, write a better message :-)

[17:40] <moritz_> and then create a patch from it

[17:40] <moritz_> git format-patch HEAD^

[17:40] <moritz_> and then mail the resulting file to [email@hidden.address] with [PATCH] in the subject

[17:42] <TimToady> szabgab: you really want: my $num; repeat { $num = prompt("Please give a number smaller than 50: "); } until $num < 50;

[17:42] <supernovus> Okay. I know it's a trivial change, but the being able to make Date objects from DateTime objects is a useful feature that was in the spec, but not in the code :-)

[17:43] <moritz_> supernovus++

[17:43] <moritz_> we all start small

[17:43] *** shade__ left
[17:43] <moritz_> (except for sorear++, who went straight for macros :-)

[17:44] *** shade__ joined
[17:44] <moritz_> sorear: I have a nytprof output from ./tryfile STD.pm6 with positive exclusive time for _STARr

[17:44] <moritz_> sorear: should I upload it for you?

[17:45] <sorear> yes please

[17:45] <sorear> (what filehost will take 200MB files?)

[17:45] <moritz_> it's 83M here

[17:46] <moritz_> oh you mean for your nytprof.out

[17:46] <sorear> ah

[17:46] <moritz_> (I was talking about the HTML dir)

[17:46] <sorear> probably a good bit smaller with compress too

[17:46] <sorear> oh

[17:46] <sorear> either works

[17:46] <TimToady> <sorear> TimToady: I'd love to optimize [ a | b ] into <[ a b ]>; could that be made to play nicely with LTM?

[17:46] <sorear> html dir may be better

[17:46] <moritz_> compressed 8.2M

[17:46] <TimToady> with the current LTMer, the first is actually more efficien than the second

[17:46] <moritz_> upload running...

[17:46] <TimToady> *efficient

[17:47] <TimToady> since the first will load into the trie, but the second will force run-time pattern matches

[17:47] <TimToady> with a real parallel NFA this would be less of an issue

[17:48] <TimToady> but it would also be less of an optimization, since both constructs would produce the same states

[17:49] *** f00li5h left
[17:52] *** bjarneh left
[17:53] <moritz_> sorear: http://moritz.faui2k3.org/tmp/std/ once packed, once unpacked

[17:54] <sorear> oh right you have a webserver

[17:54] <diakopter> rakudo: { $*num = prompt("Please give a number smaller than 50: "); }() until $*num < 50;

[17:54] *** ispeak_ joined
[17:54] <p6eval> rakudo 2242ef: OUTPUT«Method 'Bridge' not found for invocant of class 'Failure'␤  in 'infix:<<>' at line 3096:CORE.setting␤  in main program body at line 11:/tmp/yxP9jUcqkK␤»

[17:54] <moritz_> all Cursor:: rules point to unknown.html :-(

[17:54] * diakopter blinks

[17:56] *** ejs joined
[17:59] *** shade__ left
[18:00] <TimToady> rakudo: my $*num; { $*num = prompt("Please give a number smaller than 50: "); }() until $*num < 50;

[18:00] <p6eval> rakudo 2242ef: OUTPUT«Use of uninitialized value in numeric context␤»

[18:01] <TimToady> right, that form still tests first

[18:01] <jnthn> I guess that Failure is a leakage.

[18:01] <TimToady> only "repeat" moves the test to the end

[18:02] <TimToady> since 'repeat' implies always doing it at least once

[18:02] <jnthn> (It's a Parrot Failure PMC and thus didn't respond to .Bridge)

[18:03] *** ejs left
[18:05] <sorear> looks like we can save a good 20 seconds by not having Cursor inherit from Moose::Object

[18:05] <TimToady> rakudo: repeat until my $x ~~ /^Land/ { $x = prompt('') }; say 'alive'

[18:05] <p6eval> rakudo 2242ef: OUTPUT«alive␤»

[18:05] *** ejs joined
[18:05] <sorear> or sub DESTROY {}

[18:05] <TimToady> szabgab: also see ^^^

[18:06] <TimToady> the ability to put the 'my' into the conditional is one of the reasons we allow repeat's conditional to be moved to the front

[18:09] <diakopter> std: repeat { $*num = prompt "Please give a number smaller than 50: " } until $*num < 50; # i can haz globulz

[18:09] <p6eval> std 31082: OUTPUT«ok 00:01 108m␤»

[18:10] *** ejs left
[18:10] <[Coke]> jnthn: parrot has a failure pmc?

[18:12] <jnthn> [Coke]: Ah...Undef.

[18:12] <jnthn> I think Failure may be mapped to it / subclass it.

[18:12] <jnthn> Will check.

[18:12] *** ejs joined
[18:12] <TimToady> .oO(the parrot is leaky)

[18:14] <supernovus> well, the rakudo error messages certainly look nicer lately

[18:14] <diakopter> at least it's not holy

[18:14] <jnthn> supernovus: Aye, some work went into that. :-)

[18:15] *** ejs left
[18:15] <TimToady> is it still just sending line numbers through, or is it sending positions and then translating to line numbers at the last moment (preferred)?  </hotbutton>

[18:16] *** Gruber joined
[18:16] <sorear> line numbers are generated at the last moment when the source is still available

[18:17] *** ashleydev_ left
[18:17] *** cdarroch left
[18:17] *** cls_bsd left
[18:17] *** dju left
[18:17] *** alester left
[18:17] *** [Coke] left
[18:17] *** awwaiid left
[18:17] *** Grrrr left
[18:17] <TimToady> one could remember the lineof map even after flushing the source, I suppose

[18:17] <jnthn> TimToady: We emit line numbers into the bytecode.

[18:18] <TimToady> ouch

[18:18] <jnthn> TimToady: Though the annotations system is general.

[18:18] *** cls_bsd joined
[18:18] <TimToady> for some kinds of errors it's much more awesome to be able to point into the middle of a line

[18:18] <jnthn> TimToady: Well, "into the bytecode" is not quite right - into a segment alongside it.

[18:18] *** ispeak_ left
[18:18] *** [Coke] joined
[18:19] <TimToady> that might be a useful small project for someone to tackle

[18:19] <jnthn> Aye

[18:19] *** cdarroch joined
[18:19] *** cdarroch left
[18:19] *** cdarroch joined
[18:19] <TimToady> and maybe I can stop cringing someday whenever someone says "line number"  :)

[18:19] <jnthn> Well, you can .annotate 'moon phase', 180 if you want. :-)

[18:19] *** dju joined
[18:20] *** awwaiid joined
[18:20] <jnthn> TimToady: At least we get errors with some useful information in now. :-P

[18:20] <TimToady> can you .annotate 'moon phase', ᴨ  :-P

[18:21] <jnthn> Probably needs quotes.

[18:21] <jnthn> :-)

[18:21] <TimToady> but ᴨ is a number :)

[18:21] <jnthn> Ah

[18:21] <jnthn> My font has no glyph so I can't see what it is. :-)

[18:22] <TimToady> was just s/180/pi/

[18:22] <jnthn> Ah :-)

[18:22] <jnthn> ...what a sucky font, no pi!

[18:22] <TimToady> oh, I picked the small cap version

[18:23] <TimToady> how about π?

[18:23] <TimToady> that's straight lowercase

[18:23] *** wasy joined
[18:24] <sorear> I can see the latter

[18:24] <jnthn> Ah, that works.

[18:24] <TimToady> but jnthn++ for errors with useful information :)

[18:24] <moritz_> indeed

[18:24] <TimToady> I like progress even when it's only progress :)

[18:25] <jnthn> TimToady: For when we get to stashing a position - do you suggest we go look for the file at runtime when the error occurs to then determine the line number? Or stash the position to line number mapping table somewhere?

[18:25] <jnthn> The first sounds evil.

[18:25] <supernovus> any idea when jimmy's patch in ticket # 75114 will be applied to master? It fixes augmenting the Int class (tested on my local copy)

[18:25] <moritz_> it might sense to store line numbers even if we store positions

[18:25] <moritz_> for HLL interop

[18:25] <TimToady> either works, though with the former you can delay deciding what the user thinks is a "line"

[18:26] <TimToady> .u separator

[18:26] <phenny> U+2028 LINE SEPARATOR ( )

[18:26] <jnthn> moritz_: Well, my original expectation is that one day we'd store column potentially too.

[18:26] <TimToady> does that make a line number?

[18:26] <jnthn> moritz_: But TimToady is likely right that position and delay the decision will work out better.

[18:26] <TimToady> columns are also subject to interpretation under Unicode

[18:26] <sorear> what will vmsperl6 do?

[18:27] <TimToady> .u thin

[18:27] <phenny> U+2009 THIN SPACE ( )

[18:27] <TimToady> .u em

[18:27] <phenny> U+2001 EM QUAD (􏿽xE2􏿽x80􏿽x81)

[18:27] <TimToady> what's a column?

[18:28] <sorear> vim thinks a column is a codepoint count after last \cJ

[18:28] <TimToady> if we end up with program editors that can use proportional fonts, the file position is really all we have to go on

[18:28] <sorear> but how is Carp supposed to knoe that?

[18:28] <TimToady> or grapheme position, or something that is not subject to interpretation

[18:28] *** TiMBuS left
[18:29] <jnthn> TimToady: heh, well, yes, what units are we storing our positions in. :-)

[18:29] <TimToady> the point being that you want to be able to set your policy indendently of the compiler

[18:29] <jnthn> Probably doesn't actually matter though.

[18:29] <moritz_> supernovus: I'll test the patch now, will push it if it works

[18:30] <TimToady> lines and columns are not universal

[18:30] <moritz_> TimToady: I expect some kind of interpretation of the position anyway

[18:30] <TimToady> and I'm trying very hard not to bake in any language assumptions of constant spacing

[18:31] <moritz_> when I get an error message at pos 23986, I won't be happy

[18:31] <TimToady> which is why we do JIT lines/columns

[18:32] <supernovus> moritz_, thanks!

[18:32] <TimToady> but at that point we are currently making cultural assumptions

[18:32] <moritz_> and how are late cultural assumptions better than early?

[18:32] <TimToady> and I want to label such assumptions as, er, assumptions

[18:33] *** patrickas joined
[18:33] <TimToady> because early ones have to be undone, and tend to lose info if you are not careful such that they cannot be undone

[18:33] <pugssvn> r31083 | sorear++ | [Cursor] Remove Moose::Object superclass, and with it the DESTROY method.  Cuts 50 seconds off time needed to parse STD.pm6.  Thanks, NYTProf! 

[18:33] <sorear> we are below the 3 minute mark now

[18:33] <patrickas> hello perl6

[18:33] <TimToady> if you make a cultural assumption that only line numbers are important, then you lose column info

[18:33] <moritz_> \o/ patrickas 

[18:33] <sorear> I had no idea just how much that was costing us

[18:34] <moritz_> TimToady: good point

[18:34] <patrickas> hello boss :-)

[18:34] <TimToady> so it's better if all your units in the database are mks or some such

[18:34] <sorear> and we weren't using any of the Moose::Object features (->new, ->does, BUILD, DEMOLISH)

[18:34] <TimToady> otherwise you tend to crash your Mars craft

[18:34] <patrickas> I created a wordpress account (patrickas) for fixing the advent calendar posts

[18:35] <sorear> TimToady: the problem is the error reporter - how does it know what editor the programmer used?

[18:35] <moritz_> I'll give you permissions to change them

[18:37] * moritz_ hugs patrickas++ - welcome to perl6advent

[18:37] <TimToady> presumably via an environment variable, but future editors might be able to change their policy on the fly, which means they would want such information in universal units anyway

[18:37] <patrickas> thanks ... off to work :-)

[18:38] <moritz_> have fun

[18:39] <sorear> TimToady: Where should I look for enlightenment on the finer points of fate propagation?

[18:39] *** Gruber is now known as Grrrr

[18:39] <patrickas> It's all fun until somebody loses an eye... I hope wordpress has rollback functionality!

[18:39] <TimToady> depends on what you mean by "propagation"

[18:40] <TimToady> do you mean upward as calculated by the longest methods? or downward to subrules?

[18:40] <moritz_> patrickas: I think it has

[18:42] *** ruoso left
[18:42] <TimToady> the upward propagation of fates is currently done with lists of strings that are much like what you get in the lex/ files

[18:43] *** wasy left
[18:43] <TimToady> the most complicated one is in RE_sequence, since it has to X the alteratives in the head with the alternatives in the tail

[18:44] <sorear> TimToady: downward

[18:44] <sorear> I have a pretty clear conception of upward

[18:44] <TimToady> downward fates are propagated via a _fate entry in the current cursor, and by that point it is a linked list of fate pointers

[18:44] <TimToady> so each level merely needs to advance along the linked list

[18:44] <TimToady> and eventually the list runs out

[18:45] <TimToady> the nice thing about those linked lists is that tails can be shared, even if they have different prefixes

[18:46] *** justatheory left
[18:47] <sorear> Why doesn't RE_any use a helper routine like quantifiers, etc do?

[18:50] <TimToady> I don't understand your question.

[18:50] <TimToady> are you talking about RE_ast.pmc:455?

[18:52] <pugssvn> r31084 | moritz++ | [t/spec] unfudge some test for augmenting Int 

[18:52] <sorear> I'm talking about viv:3017

[18:52] <sorear> formerly part of the gimme5 regex compiler

[18:53] <dalek> rakudo: a0b6d74 | jimmy++ | src/Perl6/Actions.pm:

[18:53] <dalek> rakudo: fixed #75114: Can't augment class Int

[18:53] <dalek> rakudo: Signed-off-by: Moritz Lenz [email@hidden.address]
[18:53] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a0b6d74db23a48768fc962863bfaf6f42f5d77b1

[18:57] <TimToady> sorear: well, mostly just because historically Perl routines have been fairly slow to call, and so it's a form of inlining

[18:57] <pmichaud> (line numbers)  -- at the moment we emit line numbers, if only because positions may add a _lot_ of annotations.  Switching to positions will not be a problem when/if we decide we want them.

[18:57] <TimToady> also, we already know the literals, and these would have to be parameterized

[18:57] *** ruoso joined
[18:57] <TimToady> one optimization I've long considered is using "symbols" instead of strings in the fates

[18:58] <pmichaud> the position information is indeed readily available -- we just (by choice) don't save all of it into the bytecode at the moment.

[18:58] <pmichaud> TimToady: If it's "hot button" enough for you to want us to immediately change it, we can do that.

[18:59] <sorear> TimToady: what does a symbol in a fate look like?

[19:00] <TimToady> it would change the line that says:

[19:00] <TimToady>     if (\$fate = \$C->{'_fate'} and \$fate->[1] eq '$altname') {

[19:00] <TimToady> to:

[19:01] <TimToady>     if (\$fate = \$C->{'_fate'} and \$fate->[1] == $altname) {

[19:01] <TimToady> where presumably the symbol is a 'use constant' or some such

[19:04] <TimToady> it's also possible that we can prove that it will match, and not do the "am I the correct type of fate" check at all

[19:04] <TimToady> in which case it's just:

[19:04] <TimToady>     if (\$fate = \$C->{'_fate'}) {

[19:05] <TimToady> that could be rather fragile in the face of bugs elsewhere though

[19:05] <TimToady> lunch &

[19:05] *** gbacon joined
[19:06] <pmichaud> 18:25 <jnthn> TimToady: For when we get to stashing a position - do you suggest we go look for the file at runtime when the error occurs to then determine the line number?  Or stash the position to line number mapping table somewhere?

[19:06] <pmichaud> jnthn: I was expecting that we stash the source.

[19:06] <pmichaud> (optionally supressible)

[19:06] <pmichaud> *suppressible

[19:06] <jnthn> pmichaud: oh

[19:06] <jnthn> pmichaud: That also works.

[19:07] <pmichaud> we can do a lot more with error diagnostics in that case

[19:07] <jnthn> .annotate 'source', 'blahhhhh'

[19:07] <pmichaud> so, my plan was to have annotations for source, line number, position

[19:07] <jnthn> And .file

[19:07] <jnthn> gah

[19:07] <jnthn> and file

[19:07] <pmichaud> and .file, yes.

[19:07] <jnthn> (it's .annotate 'file', 'name' )

[19:07] <pmichaud> right :-)

[19:08] <pmichaud> I suppose we could stash a position-to-line table somwhere instead of the line numbers, but it seems easier to just go ahead and annotate line numbers since we already readily have them

[19:08] <pmichaud> (if the source is present, we wouldn't need the line number annotations, no.)

[19:08] *** ive left
[19:13] <TimToady> clang gives very nice run-time errors with source

[19:14] <pmichaud> anyway, my plan for a while has been to stash the source with the compiled form, and keep track of things by position (possibly in addition to line number)

[19:14] <TimToady> in face, it tends to record both the .from and .to position so it can highlight the entire suspect construct

[19:14] <pmichaud> oh, we could do that also.

[19:14] <pmichaud> I like that.

[19:14] <pmichaud> might also help with those constructs that end up being multi-line.

[19:15] <TimToady> s/face/fact/

[19:24] <TimToady> $a X $b will always produce a single element

[19:25] <TimToady> because X is a *list* infix

[19:25] <sorear> TimToady: in STD.pm6, lexer 'variable', there is an LTM conflict on the token $<

[19:25] <TimToady> @$a X @$b is different

[19:25] <sorear> there's a very, very awful cheat in viv to ignore LTM generated by <sym> under :sym['$<']

[19:25] <sorear> this is necessary in order to correctly parse $<a>

[19:26] <sorear> because otherwise the $*EUID alternative would get there (it has $< as longest token) and cut

[19:29] *** Guest43663 left
[19:29] <sorear> szabgab++ corrupting the youth

[19:30] *** ShaneC joined
[19:31] *** wallberg joined
[19:31] *** plainhao left
[19:31] <moritz_> patrickas++ # perl6advent updates to current spec

[19:32] <patrickas> patrickas+=.5 # Only half of them updated so far :-)

[19:33] *** pjcj joined
[19:34] *** wallberg left
[19:34] <TimToady> sorear: testing a fix

[19:35] <TimToady> the problem is that $< isn't a true twigil, so it escapes the requirement for a \w imposed by twigil's endsym

[19:36] <TimToady> hmm, but then it blows up on $<~CAPS>

[19:36] <TimToady> we may have to make the special_variable rule more specific

[19:39] *** Guest43663 joined
[19:39] *** clintongormley left
[19:40] <TimToady> testing a different patch

[19:45] <sorear> impressive.  I just broke tryfile to the point of memory usage explosion

[19:46] *** whiteknight joined
[19:46] <moritz_> rakudo: say 1 <=> 2

[19:46] <p6eval> rakudo 2242ef: OUTPUT«-1␤»

[19:48] *** estrabd left
[19:50] <diakopter> sorear: left recursion?

[19:50] <sorear> diakopter: shadow hell, more likely

[19:50] <diakopter> what's shadow hell :)

[19:50] <pugssvn> r31085 | lwall++ | [STD] make p5 $< detection have a longer LT 

[19:51] <sorear> that's where you shadow one variable with another and create a loop in the wrong place

[19:51] *** justatheory joined
[19:53] <diakopter> I'd probably need an example. I think only 10% of my normally active 10% of my brain is active

[19:54] <TimToady> if your brain is 100% active you'll die

[19:55] <diakopter> all neurons fire at once?

[19:55] *** supernovus left
[19:55] *** masak joined
[19:55] <diakopter> MASAK

[19:55] <masak> ahoy!

[19:55] <TimToady> that would be something beyond a grand mal seizure

[19:55] <moritz_> that's what some neurotoxic substances do to you

[19:55] <TimToady> and you would likely stop breathing

[19:56] <sorear> ideally, your brain should be 50% active

[19:56] <moritz_> like sarin

[19:56] <sorear> this maximizes the information content of each action potential

[19:57] <pragma_> Ideally, you shouldn't believe everything you read.

[19:57] <TimToady> well, okay, but 50% of the active brain is inhibitory circuits, so that leaves half of 25% excitatory circuits excited, which is 12.5% which is only slightly better than 10% :)

[19:57] <sorear> I am suspecting and does not work the way I think it does

[19:57] <diakopter> masak: how many github projects did you start today?

[19:58] <diakopter> :D

[19:58] <moritz_> TimToady: in some sense 12.5 is 25% better than 10 :-)

[19:58] <sorear> I wonder how hard it was to get gitpan approved

[19:58] <masak> diakopter: only one, and related to $work rather than to Perl 6. :)

[19:58] <diakopter> on schwern's blog he says it was easy

[19:58] <diakopter> er, journal

[19:59] <masak> diakopter: url?

[19:59] <diakopter> use.perl.org

[19:59] *** xinming left
[20:00] *** xinming joined
[20:03] *** Psyche^ joined
[20:03] <masak> this one? http://use.perl.org/~schwern/journal/40340

[20:03] <masak> ah, no. this one: http://use.perl.org/~schwern/journal/40079

[20:04] <sorear> http://pastie.org/991068 This should be the same, but it's not.  I think I am missing something *very* obvious here

[20:05] * sorear goes back to reading B::Concise

[20:06] <sorear> +output

[20:06] <sorear> perl5's sorry excuse for assembly language

[20:06] <szabgab> TimToady, thanks for the example with the repeat

[20:06] <pmichaud> szabgab: I sent an email with the repeat answer also... did it not arrive or is it filtered somehow or...?

[20:07] <pmichaud> I sent it about 7 hours ago.

[20:07] <TimToady> sorear: what you're missing is that the symbol $C isn't introduced till the next statement start

[20:07] *** Patterner left
[20:07] *** Psyche^ is now known as Patterner

[20:07] <TimToady> P5 is different from P6 here

[20:07] <pmichaud> (I've been having trouble with email lately, it seems, so I'm trying to track that down)

[20:07] <[Coke]> sorear: you have a sub my in the first one.

[20:07] <TimToady> and, in fact, that statement wouldn't work in P6 either without OUTER on the rvalue

[20:07] <[Coke]> I imagine there's some clobberin' going on.

[20:08] <[Coke]> or, you know, listen to TimToady =-)

[20:08] <masak> TimToady: ah. my brain was groping for the `repeat { ... } until ...` idiom for szabgab, but didn't find it. thanks.

[20:08] <TimToady> in 'my $C = blah blah $C blah blah $C blah blah $C' all the non-my $C's are the old one

[20:08] <sorear> [Coke]: The idea I'm trying to go for is to reuse the lexslot instead of creating a new scope with a new set of lexicals

[20:09] <sorear> TimToady: not introduced until the next *statement*.  got it.

[20:09] <szabgab> pmichaud, it did not filter through my brain :)

[20:09] <TimToady> so my $C; ($C) = ... and ($C) =   might work thoguh

[20:09] <TimToady> *though

[20:09] <pmichaud> szabgab: so you did receive the email, or no?

[20:09] <szabgab> but now after it was repeated ....

[20:09] <szabgab> email yes

[20:09] <pmichaud> okay, good.

[20:09] <szabgab> thanks

[20:09] <sorear> [Coke]: it's a tiny optimization, but it applies a couple thousand times in STD.pmc and could add up to real savings.  Only one way to find out

[20:10] <szabgab> pmichaud, oh I see, trouble with e-mail,  not in this case

[20:10] <masak> TimToady: when you say 'a real parallel NFA', are you referring to something which could be used to parse Perl 6 even better than STD.pm6, but which no-one has even started building yet?

[20:11] <moritz_> s/better/faster/ I think

[20:11] <masak> oh. meant that. silly brain.

[20:12] <moritz_> brainz are overrated

[20:12] <sorear> the Real Parrallel NFA is a hypothetical overhaul to the guts of Cursor

[20:12] <sorear> it doesn't change STD.pm6 at all

[20:12] <Tene> masak!

[20:12] * masak ponders what a Perl 6 project called 'zombie' might do

[20:12] <masak> Tene! \o/

[20:13] <masak> Tene: I came here tonight mostly to meet up with you.

[20:13] <masak> let's head over to #november-wiki, shall we?

[20:16] <TimToady> masak: it wouldn't parse *better* except in the sense of *faster*

[20:16] <diakopter> as a RPNFA chews characters, it knows exactly which token patterns are invalidated upon encountering certain characters, so it's as it's keeping track of the backtracking states, but doing them "in parallel"

[20:16] <diakopter> it's as *if

[20:16] <diakopter> it's

[20:17] <TimToady> the current algorithm emulates PNFA for the literal characters using a trie, but any patterns that aren't literal are evaluated at that point, and then sorted into correct LTM order

[20:17] *** wallberg joined
[20:17] <dalek> book: 6b9ccde | moritz++ | src/operators.pod:

[20:17] <dalek> book: [ops] three-way comparison

[20:17] <dalek> book: review: http://github.com/perl6/book/commit/6b9ccde27118b18d953da77a993617952baf2c2e

[20:17] <TimToady> a PNFA would essentially push those extra patterns down the trie until it looks more like a DFA state diagram

[20:18] <TimToady> or at least an NFA state diagram

[20:18] <[Coke]> masak: I think a perl6 project called zombie would just be perl 6. =-)

[20:18] *** azert0x joined
[20:18] <TimToady> but I've been going for correct over fast

[20:18] <masak> [Coke]: O RLY?

[20:24] <masak> diakopter: sounds a lot like http://swtch.com/~rsc/regexp/regexp1.html

[20:26] <sorear> I did not realize perl5 had a hardcoded limit on the complexity of subs using goto

[20:26] <TimToady> not qp/a b c/, but probably qp[a/b/c]

[20:26] *** shade__ joined
[20:27] <TimToady> sorear: it does?

[20:27] <TimToady> not when I wrote it

[20:29] <TimToady> when I wrote it, label search was all just following linked lists; not necessarily efficient, but not with any inherent limits

[20:29] <dalek> nqp-rx: a68924f | pmichaud++ | src/Regex/P6Regex/ (2 files):

[20:29] <dalek> nqp-rx: Update ** quantifier a bit, recognize trailing spaces as request to

[20:29] <dalek> nqp-rx: add <.ws> between each element.  (This isn't completely what S05

[20:29] <dalek> nqp-rx: specifies, but it's a good first cut.)

[20:29] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/a68924fd3dbe3f4b392f6460f28b99df3a482d28

[20:29] <dalek> nqp-rx: 9e955a4 | pmichaud++ | build/PARROT_REVISION:

[20:29] <dalek> nqp-rx: Bump PARROT_REVISION to get FileHandle.tell.

[20:29] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/9e955a4984fe0eb51307415a42127fb0c64ed919

[20:29] <dalek> nqp-rx: 38fc6e9 | pmichaud++ | src/Regex/P6Regex/Actions.pm:

[20:29] <sorear> #define GOTO_DEPTH 64 in pp_ctl.c

[20:29] <dalek> nqp-rx: Add :sigspace handling to range quantifiers (e.g., <x> ** 0..3)

[20:29] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/38fc6e9a2c4d12504ce450c282fc2a3c6e701e93

[20:29] *** shade__ is now known as \shade

[20:29] <masak> whoa.

[20:29] <sorear> I'm not wholly sure what it controls, though

[20:30] *** \shade is now known as \shade\

[20:30] <sorear> probably unnesting of blocks

[20:30] <TimToady> perhaps, but who nests blocks 64 deep?

[20:30] <TimToady> (besides viv :)

[20:30] *** patrickas left
[20:31] * sorear is suspecting that the only way to get a reasonable PNFA engine will be to write the walker as an xsub

[20:31] <TimToady> well, we can still prototype it in Perl, and even that is likely to be faster

[20:31] *** justatheory left
[20:31] <TimToady> and someone needs to write a Perl 6 to XS translator.  :)

[20:32] <TimToady> by which I mean writing the xsub in Perl 6 :)

[20:34] <TimToady> std: 0xFACE

[20:34] <p6eval> std 31085: OUTPUT«===SORRY!===␤Whitespace is required between alphanumeric tokens at /tmp/SnbQuPVOBW line 1:␤------> 0⏏xFACE␤Whitespace is required between alphanumeric tokens at /tmp/SnbQuPVOBW line 1:␤------> 0x⏏FACE␤Undeclared name:␤  

[20:34] <p6eval> ..'FACE' …

[20:34] <TimToady> sorear: did you break that?

[20:35] <pmichaud> if there's a Perl prototype, I'm likely to try converting it to nqp and/or pir

[20:35] <pmichaud> (for PNFA)

[20:35] *** justatheory joined
[20:35] <pmichaud> it's on my list of "things I'd like to do" but at the moment there are a lot of heavier things on that list.

[20:36] <pmichaud> and I'll be perfectly happy to see someone else prototype it :)

[20:36] *** Guest21689 left
[20:36] *** Patterner left
[20:37] <TimToady> the hard part is getting the current string token patterns into a nodal graph representation

[20:37] <pmichaud> agreed.

[20:37] <sorear> TimToady: it could be my fault

[20:37] <diakopter> does std need regression tests

[20:37] <TimToady> is that $C scoping thing in the current viv?

[20:37] <TimToady> std has many regressions tests, all of the t/ files

[20:38] <TimToady> that's how I noticed

[20:38] <TimToady> 'make snaptest' compiles all of the *.t files with STD

[20:38] <diakopter> I mean, quick-to-run ones.

[20:38] <sorear> std needs a higher power/weight ration regression suite

[20:38] <sorear> make snaptest takes 90 minutes, I don't run it after every tweak

[20:38] <moritz_> TimToady: t/ only tests one way

[20:38] <TimToady> they only take about 20 minutes here

[20:39] <moritz_> it shouldn't contain syntax errors that STD.pm6 then needs to find

[20:39] <TimToady> it always requires that it successfully recompile STD.pm6

[20:39] <TimToady> and that's a pretty good regression test

[20:40] *** Guest21689 joined
[20:41] <dalek> nqp-rx: 5fb2d58 | pmichaud++ |  (3 files):

[20:41] <dalek> nqp-rx: Add \e in quoted strings, refactor 46-charspec.t .

[20:41] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/5fb2d58d196347d29e64ece94c6adee80e2e93ec

[20:41] <TimToady> but it doesn't catch 0xFACE :)

[20:42] *** Psyche^ joined
[20:42] *** Psyche^ is now known as Patterner

[20:42] <TimToady> maybe CORE.setting would catch it if I encoded pi in hex  :)

[20:43] <masak> pmichaud++ # \e/

[20:48] <sorear> viv miscompiles /[ 0 [ B | C ] | D ]/

[20:48] <sorear> viv does not miscompile /[ 1 [ B | C ] | D ]/

[20:48] <TimToady> gee...

[20:49] <sorear> I think I screwed up a bool somewhere...

[20:49] <TimToady> nap &

[20:50] *** gbacon left
[20:51] <[Coke]> ↖ↂ↗

[20:51] *** patspam left
[20:53] *** rgrau joined
[20:54] *** Schwern joined
[20:57] <masak> [Coke]: that is the scariest smiley I've ever seen. and I've seen quite a few.

[20:58] <[Coke]> I can't even see it here.

[21:01] <[Coke]> it's just meant to be a stylized \o/ =-)

[21:01] <[Coke]> TimToady: <ackbar>IT'S A NAP</ackbar>

[21:01] <pmichaud> .oO(groan)

[21:02] *** Guest17090 left
[21:03] *** Su-Shee left
[21:09] *** gbacon joined
[21:10] *** Guest43663 left
[21:11] <masak> jnthn: the "öl" example looks promising for the encoding stuff. I haven't been able to look at it yet, but I will tomorrow.

[21:11] <masak> jnthn: is there a similar hope for decoding?

[21:12] <jnthn> Ja, om jag har mer öl. ;-)

[21:12] <masak> heh. :)

[21:13] <jnthn> "om"...seems to play quite a few roles. :-)

[21:13] <jnthn> Like "som" :-)

[21:13] <masak> 'if', 'about', 'around', 'per'... :)

[21:13] <masak> 'som' rocks.

[21:14] <jnthn> The slightly interesting thing about the other direction is that we need to say what kinda strig the bytes are in so we can pass that along to Parrot's make_string or whatever it's called.

[21:15] <jnthn> Anyway, we work on it when you get there. :-)

[21:15] <masak> let's assume UTF-8 for now.

[21:15] <masak> that seems to be the easiest.

[21:17] *** PZt left
[21:17] <jnthn> masak: I was pondering providing a method on the ByteView where you pass in an encoding object

[21:17] <jnthn> From find_encoding

[21:17] <jnthn> Then it can grow into the others you support in The Future.

[21:18] <masak> ok.

[21:18] <masak> sounds like a good idea.

[21:18] <jnthn> I'll see if I can make that work.

[21:18] <masak> \o/

[21:18] <masak> ok, going offline now.

[21:19] <jnthn> Safe trip :-)

[21:19] <masak> I have to catch a bus tomorrow at (*gasp*) 10 am!

[21:19] <jnthn> omfg

[21:19] <jnthn> That's like, EARLY. O.O

[21:19] <masak> I know!

[21:19] * masak sleeps

[21:19] *** masak left
[21:21] *** justatheory left
[21:23] *** ispeak_ joined
[21:24] <diakopter> sorear: I just tried 'make snaptest' on a fresh perl and got this:  Deep recursion on subroutine "Class::MOP::Class::class_precedence_list" at /usr/local/lib/perl/5.10.1/Class/MOP/Class.pm line 841.

[21:24] <diakopter> any tips?

[21:24] <diakopter>  /ideas

[21:24] *** hudnix joined
[21:25] *** justatheory joined
[21:26] <bkeeler> Are strings in rakudo always utf8 for now?

[21:27] <bkeeler> Or is there a way to make them plain ol ascii?

[21:27] <sorear> diakopter: ignore it

[21:27] <pmichaud> bkeeler: your question needs clarification.  :-)

[21:27] <sorear> Perl spits out a warning when code recurses more than 100 levels (yes, hard coded) deep

[21:27] <bkeeler> Fair enoug

[21:28] <sorear> STD implements custom operators by dynamically subclassing the current grammar

[21:28] <diakopter> sorear: ok, next problem.  I started with 'make snaptest'   Can't exec "./std": No such file or directory at Cursor.pm line 2684.

[21:28] *** xinming_ joined
[21:28] *** ashleydev joined
[21:28] <bkeeler> pmichaud: I'm trying to write a parser that needs to parse really large files, and I'm assuming the reason that it's horribly slow is that things like PIR length and substr that the regex engine use alot are not exactly O(1)

[21:28] <sorear> Moose recurses over the inheritence graph -> warn if more than 100 levels of superclasses

[21:28] *** skids left
[21:29] <sorear> I asked #moose to put a no warnings 'recursion' in the appropriate place, they think I'm crazy

[21:29] <sorear> (they're right)

[21:29] <diakopter> heh

[21:29] <bkeeler> My input files are plain ascii, so I was hoping I can improve performance but letting parrot/rakudo know that

[21:29] <pmichaud> bkeeler: internally, rakudo attempts to keep strings with fixed_8 encoding whenever possible

[21:30] <sorear> diakopter: README:18

[21:30] <pmichaud> bkeeler: are you writing this in Rakudo itself?

[21:30] <bkeeler> Yes

[21:30] <pmichaud> okay.

[21:30] <sorear> I'm developing on 5.12, so I may have accidentally slipped in a 5.12ism

[21:30] <pmichaud> (thinking)

[21:30] <bkeeler> Though I could move to NQP if necessary

[21:30] <pmichaud> well, the regex engine is smart enough to keep track of intermediate points in the string being matched

[21:31] <pmichaud> so that it's not always calculating length from the very beginning of a utf-8 encoding string

[21:31] <pmichaud> *encoded

[21:31] *** xinming left
[21:31] <bkeeler> But it still does things like substr on the target string when comparing literals eg, right?

[21:32] <pmichaud> yes, but that substr is relative to the intermediate offset

[21:32] <pmichaud> not from the beginning of the larger string being matched

[21:32] <diakopter> sorear: oh yeah; forgot

[21:32] <pmichaud> (module whatever the parrot folks have done to change the way strings work since that code was written)

[21:32] <pmichaud> *modulo

[21:32] *** Guest21689 left
[21:33] <pugssvn> r31086 | sorear++ | [viv] Re-use lexicals instead of creating nested scopes when constructing ratcheted sequences.  No significant performance effect yet, but brings output much closer to human-like form. 

[21:33] <bkeeler> Hmmm

[21:34] <pmichaud> anyway, I'm not sure the Perl 6 spec yet provides a mechanism to say "read this file as something other than Unicode".  Perhaps it does -- I don't recall.

[21:34] <diakopter> bkeeler: do you have some examples of running times and input lengths and patterns?

[21:34] <bkeeler> diakopter: Not yet.  I could put something together

[21:35] <pmichaud> oh, looks like :bin to .open

[21:35] <pmichaud> or :enc

[21:35] <bkeeler> in src/core/IO.pm open unconditionally does $PIO.encoging('utf8')

[21:36] <pmichaud> right

[21:36] <diakopter> sorear: are "===SORRY!===" in 'make snaptest' bad?

[21:36] <pmichaud> if you wanted to patch that to accept other values, I'd be agreeable :-)

[21:36] <pmichaud> see the section on 'open' in IO.pod

[21:37] <pmichaud> you could also potentially update the code for slurp() to accept :enc

[21:37] <bkeeler> I'll take a look at doing that

[21:37] <sorear> diakopter: yes, but expected

[21:37] <pmichaud> if you're just looking for a workaround, use Q:PIR and change the encoding directly :-)

[21:37] <diakopter> ok; how will I know when something breaks

[21:37] <sorear> diakopter: std doesn't fudge the testsuite and it still fails to parse ~5% of them

[21:37] <sorear> diakopter: watch the %passing number for drops

[21:38] <bkeeler> So if I set the parrot IO object to encoding('fixed_8') or whatever, I'll get back strings that are similarly flagged?

[21:38] <pmichaud> yes.

[21:39] <bkeeler> Cool

[21:39] <bkeeler> OK, I'll go away and hack for a bit and let you know how it goes :)

[21:39] <pmichaud> excellent.

[21:43] <diakopter> sorear: in regex_in_variable.t

[21:43] <diakopter> it can't find is_run

[21:44] <diakopter> and it can't find Test::Util

[21:44] <pmichaud> nqp now supports primitive multisubs.  bacek++

[21:44] <bkeeler> That sounds like one of my tests.  Did I goof when I wrote it?

[21:44] <diakopter> (I suspect Makefile needs to do some dependency checking, like version of Moose, YAML::XS, and Test::Util maybe?)

[21:44] <sorear> diakopter: you should have 43 failing test files

[21:45] <bkeeler> Oh wait, no I didn't write that one

[21:45] <sorear> actually, 40

[21:45] <sorear> 43 was from right after the viv switchover

[21:46] <sorear> (actually you'll have a few more because I just broke hex number parsing.  but this isn't your fault)

[21:46] <diakopter> heh

[21:47] <pugssvn> r31087 | sorear++ | [viv] Fix compilation of '0' followed by a complex atom; this fixes the 0xFACE regression 

[21:47] *** Guest21689 joined
[21:49] *** Guest21689 left
[21:49] <pmurias> diakopter: Makefile.PL should do dependency checking

[21:49] <dalek> nqp-rx: eba2f2b | pmichaud++ |  (3 files):

[21:49] <dalek> nqp-rx: Merge branch 'multis'

[21:49] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/eba2f2be9c5af703fb4c0a2a8d4464b5032dc75f

[21:49] <dalek> nqp-rx: 7006d42 | pmichaud++ | t/nqp/49-multis.t:

[21:49] <dalek> nqp-rx: Rename multi tests.

[21:49] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/7006d4280514c3575247c28f08aeeec1a87b5a45

[21:49] <dalek> nqp-rx: 9612a72 | pmichaud++ | src/NQP/ (2 files):

[21:49] <dalek> nqp-rx: [nqp]: Eliminate $*METHODTYPE from grammar and actions.

[21:49] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/9612a72d93b2c78a72c8836579df192be1c53b59

[21:49] <dalek> nqp-rx: 9d44980 | pmichaud++ | src/stage0/ (4 files):

[21:49] <dalek> nqp-rx: Update bootstrap.

[21:49] <dalek> nqp-rx: review: http://github.com/perl6/nqp-rx/commit/9d44980671ef25bb323442df4d5c2841c4ff5e60

[21:50] <diakopter> pmurias: http://svn.pugscode.org/pugs/src/perl6/Makefile.PL

[21:51] <sorear> anyways, Test::Util isn't a dependency

[21:51] <sorear> the tests are failing because we don't yet provide the full Perl *6* standard library

[21:51] <sorear> this isn't something you can just install...

[21:52] *** patspam joined
[21:52] <diakopter> ok.  I thought maybe it was looking for a Perl 5 Test::Util. sry

[21:53] *** ispeak_ left
[21:56] <diakopter> sorear: failed 57 tests

[21:56] <diakopter> took about 25min

[21:57] <diakopter> paste.lisp.org fail

[22:00] <sorear> diakopter: where?

[22:00] <sorear> lisppaste3 got kbd after it started flooding #perl6 with porn ads

[22:01] <sorear> so you'll need to post the url yourself

[22:01] <sorear> diakopter: if you want a lowish-effort way to help make snaptest better, try "implementing" Test::Util

[22:01] *** silug joined
[22:02] <sorear> look at src/perl6/lib/Test.pm6

[22:02] <sorear> make src/perl6/lib/Test/Util.pm6

[22:02] <TimToady> not sure cursor handles :: yet, but it might

[22:03] <pugssvn> r31088 | pmurias++ | [mildew] fix submolds in m0ld frontend 

[22:03] <pugssvn> r31089 | pmurias++ | [smop] change the test so that it can be automatically translated into a 

[22:03] <pugssvn> r31089 | format mildew can run

[22:03] <pugssvn> r31090 | pmurias++ | [mildew] fix bugs into the to SSA transform 

[22:03] <pugssvn> r31091 | pmurias++ | [mildew] minor whitespace tweak to code emitted by -BoptC 

[22:03] *** Transformer joined
[22:03] <sorear> submolds?

[22:03] <pugssvn> r31092 | pmurias++ | [smop] started implementing SMOP_DUMP, which should make all smop objects, much more easily dumpable 

[22:05] *** snarkyboojum joined
[22:06] *** Transformer left
[22:08] <dukeleto> howdy folks! i have a question

[22:09] <dukeleto> parrot ~/git/rakudo/perl6.pbc gives me : Null PMC access in find_method('new_class') when I am not in the same directory as perl6.pbc

[22:09] <dukeleto> i think it is because perl6_group and friends cannot be found

[22:10] <jnthn> Did you make install?

[22:10] <jnthn> (If not, you need to.)

[22:11] <dukeleto> jnthn: i didn't, trying that now :)

[22:12] <jnthn> Seems to be the usual fix for such things. :-)

[22:12] <pmurias> molds are the objects which store the code and constants for executing a block of code

[22:12] <pmurias> submolds are molds which are constants in a different mold

[22:13] <pmurias> sorear: see the above explanation

[22:13] <dukeleto> jnthn: that gets me farther, thanks!

[22:13] <jnthn> :-)

[22:15] <sorear> I see

[22:16] *** masonkramer_ joined
[22:17] *** envi^home left
[22:24] *** justatheory left
[22:26] <TimToady> diakopter: I get Passed 782/815,  95.95%

[22:26] <pmurias> sorear: generally the design of smop is quite simple, but the code is a bit messy

[22:27] <TimToady> (and it runs in 18 minutes)

[22:27] <TimToady> (and my lap gets very hot :)

[22:27] <pmurias> what was the time for the gimme5 generated one?

[22:28] <sorear> TimToady: is that before or after my Cursor patch?

[22:28] * sorear wants more cores.  and a ponie.

[22:28] <rgrau> rakudo: for (('abc' => 'ABC')) -> $pair { say $pair.key.comb Z $pair.value.comb }

[22:28] <TimToady> that's 31087

[22:28] <p6eval> rakudo a0b6d7: OUTPUT«AABC␤»

[22:29] <TimToady> well, I'm only using one core

[22:29] <TimToady> for the snaptest

[22:29] <TimToady> but everything else can happen in the other core

[22:30] <rgrau> is this the correct behaviour for Z ?

[22:33] <TimToady> doesn't look like it

[22:34] <TimToady> rakudo: for 'abc' => 'ABC' -> $pair { say ~$pair.key.comb }

[22:34] <p6eval> rakudo a0b6d7: OUTPUT«a b c␤»

[22:35] <TimToady> oh, maybe it's the multiple gather bug

[22:35] <TimToady> rakudo: for 'abc' => 'ABC' -> $pair { say (eager $pair.key.comb) Z $pair.value.comb }

[22:35] <p6eval> rakudo a0b6d7: OUTPUT«aAbBcC␤»

[22:35] <TimToady> yes, it's the gather bug

[22:36] <TimToady> some state used by gather is not being properly cloned

[22:36] <TimToady> and comb is probably implemented with gather/take

[22:36] <rgrau> so it's a known one, I shouldn't report it, should I?

[22:37] <TimToady> probably not, but you see the workaround there

[22:37] <rgrau> yup :)

[22:38] <TimToady> I sure hope this one gets fixed for R* though

[22:38] <TimToady> maybe it's really the closure bug in disguise

[22:39] *** pmurias left
[22:40] *** xabbu42 joined
[22:41] <dukeleto> this is the error I get when loading an installed perl6.pbc from C: http://gist.github.com/424624

[22:43] <bkeeler> I thought we had .perl on match objects now.  Didn't that make it in?

[22:43] <sorear> diakopter: abort.  I've found the *real* problem

[22:44] * sorear un-screws some PERL6LIB hacking and convinces regex_in_variable.t to pass

[22:44] * sorear is now running a snaptest

[22:44] *** justatheory joined
[22:45] <pmichaud> It's the closure bug in disguise.

[22:45] <pmichaud> 22:38 <TimToady> I sure hope this one gets fixed for R* though

[22:45] <pmichaud> 22:38 <TimToady> maybe it's really the closure bug in disguise

[22:45] <sorear> I thought that was fixed?

[22:45] <pmichaud> It's the closure bug in disguise.

[22:46] <pmichaud> not yet.

[22:46] <pmichaud> it's on my to-do list.  I need to get lists working first.

[22:49] <pmichaud> afk, fetching dinner

[22:49] <bkeeler> Aaarghghgh, I see what the problem is.  I'm inheriting my grammar from HLL::Grammar, therefore not Rakudo's Cursor, so I'm not getting Rakudo match objects :(

[22:52] <pmichaud> oh, interesting

[23:00] *** lestrrat is now known as lest_away

[23:00] <sorear> TimToady: Why are import failures a worry rather than a sorry?

[23:01] <masonkramer_> I probably know the answer to this question already, but I want to make sure.  I've become very interested in Perl6 "the specification", and I'd love to contribute to Rakudo implementation.  The problem, of course, is that I only know one language somewhat well (that would be Perl5 - and I am talking about the language, not the implementation), and I'm not a CS major.  Despite that, I'm pretty smart, and relatively young, and I'd

[23:01] <masonkramer_> like to learn.  Even though, again, I'm 99% certain that a complex project full of experts such as Perl6 has no room for me - does anyone here have some advice for how to learn ?| contribute here?

[23:02] *** orafu left
[23:02] <sorear> not being a CS major has never stopped anyone

[23:02] <sorear> I haven't taken a single CS class!

[23:02] *** orafu joined
[23:03] <masonkramer_> That's encouraging!  Really.  I've been regretting my decision for a while now

[23:03] <snarkyboojum> and I have and it doesn't necessarily help a great deal :)

[23:04] <sorear> programming is a craft.  the only way to learn is by doing

[23:05] <sorear> so come on in

[23:05] <sorear> the water's fine

[23:05] <masonkramer_> That is what I've come to believe on the job as a perl5 DarkPAN hacker 

[23:05] <masonkramer_> Well - what the hell?  Should I just suck down the repo and start reading?

[23:06] <masonkramer_> I can stumble my way through C source

[23:06] <sorear> rakudo is a relatively large system

[23:06] <sorear> there's a high-level runtime library

[23:07] *** skids joined
[23:07] <sorear> a low level runtime support layer (bonded to Parrot)

[23:07] <sorear> a pair of Parrot C-extension libraries that sit under *that*

[23:07] <sorear> a parser

[23:07] <sorear> a code generator

[23:07] <jnthn> Aye, we don't have that much C in Rakudo itself. Thankfully. :-)

[23:07] <sorear> everyone here is at least somewhat specialized

[23:08] <sorear> pick a place to start

[23:08] <jnthn> masonkramer_: There's certainly plenty of room for enthusiastic people to jump in and hack on stuff. :-)

[23:08] <jnthn> And yes, what sorear said. Don't expect to grok the whole thing.

[23:09] <TimToady> sorear: import failures usually result in undefined functions, and *those* used to just be a worry

[23:09] <TimToady> but it might be time to make import failures fatal

[23:09] <jnthn> TimToady: They're fatal in Rakudo, fwiw.

[23:09] <snarkyboojum> masonkramer_: also there's moritz's weekly contribution challenges - http://perlgeek.de/blog-en/ - they might be worth following - subscribe to planetsix if you haven't already http://planetsix.perlfoundation.org/

[23:10] <sorear> TimToady: if they aren't fatal, then how will we know if the module contained a BEGIN { exit }?

[23:10] <TimToady> I hadn't known that was a big problem.  :P

[23:10] <sorear> t/spec/S02-names_and_variables/varnames.t: Unsupported use of $/ variable as input record separator; ------>     $/⏏ = MyMatch.new;

[23:12] *** ruoso left
[23:12] <jnthn> masonkramer_: If you do like digging through C code though, then http://rt.perl.org/rt3/Ticket/Display.html?id=74758 is a mabye-not-too-hard fix to do in src/binder/bind.c.

[23:13] <jnthn> (If you're looking for a concrete jumping in point, anyways. :-))

[23:13] * masonkramer_ is following all the links ... bbiaf

[23:15] <TimToady> std: $/ := Any.new;

[23:15] <p6eval> std 31092: OUTPUT«ok 00:01 108m␤»

[23:16] <TimToady> sorear: perhaps it should be := in any case

[23:16] <TimToady> and STD doesn't complain about $/ :=

[23:16] <sorear> TimToady: why?  is $/ a containery thing like an @ or % sigil?

[23:16] <TimToady> sure

[23:17] *** Wolfman2000 joined
[23:17] <TimToady> := has always been intended to work on scalar vars

[23:17] <pmichaud> we could use a ticket queue review, also.

[23:17] <sorear> TimToady: Why can't Cursor use STD->parsefile instead of system("std ?

[23:17] *** Limbic_Region joined
[23:18] <TimToady> well, it might clobber some globals we don't want clobbered

[23:19] <masonkramer_> pmichaud: was that directed at me?

[23:19] <TimToady> but it can probably be made to work pretty easily

[23:19] <sorear> what globals does STD/Cursor use without localizing?

[23:19] <TimToady> masonkramer_: I suspect it was

[23:19] <sorear> ok. task queued.

[23:19] <pmichaud> masonkramer_: yes (sorry, forgot to address you properly :-)

[23:20] <TimToady> sorear: I don't know, I'm just sayaing we'll find out.  :)

[23:23] *** PZt joined
[23:26] *** ruoso joined
[23:26] *** wallberg left
[23:28] *** cdarroch left
[23:29] <pugssvn> r31093 | sorear++ | [Cursor,STD-ecosystem] Fix PERL6LIB in snaptests. 

[23:30] <sorear> What does S05-mass mean?

[23:32] <jnthn> *mass*ive number of tests

[23:32] <sorear> seriously?

[23:32] <jnthn> sorear: Well, kinda. :-)

[23:32] <jnthn> sorear: It contains the vast majority of the regex tests.

[23:32] *** patspam left
[23:32] <jnthn> sorear: Which test a lot of combinations of features.

[23:33] <jnthn> sorear: I think a lot of them may well be Perl 6-ifications of similar tests in Perl 5.

[23:33] <pmichaud> I wonder if we could switch back to using the read-from-a-file form of tests, so that we could share a suite with nqp-rx

[23:34] <pmichaud> this would also probably speed up the test speed a fair bit :)

[23:34] <jnthn> orly?

[23:34] <jnthn> Wouldn't we still be running just as many tests?

[23:34] <pmichaud> sure.  Right now the parse of the program is pretty big 

[23:34] <jnthn> Or you mean we'd hae less to parse and would hit less GC pressure?

[23:34] <pmichaud> instead of doing several hundred small parses, we end up doing .... right

[23:34] <jnthn> I mean, at some level we'd have just as much to parse, just in small bits.

[23:34] <pmichaud> rephrase

[23:34] <jnthn> OK. Makes some sense then. :-)

[23:35] <pmichaud> instead of one huge parse, we'd end up doing a lot of smaller ones

[23:35] <pmichaud> and it might even be easier to do now that we can variable subst in regexes  :-)

[23:35] <jnthn> ah, yes :-)

[23:36] *** xomas_ left
[23:37] *** xomas_ joined
[23:38] <pmichaud> anyway, I'm thinking I want to write a nqp version of that test script, so perhaps that can then be ported into rakudo.

[23:38] <pmichaud> and, have to run off for a while -- bbl

[23:39] * sorear makes a list of all [$@%&]::w+ in STD.pmc and Cursor.pmc

[23:40] <sorear> 77 of them... *auditaudit*

[23:42] <sorear> @::ACTIVE is localized in initparse but not used anywhere, even as $::ACTIVE

[23:44] <sorear> Why is @::MEMOS localized to its old value?

[23:44] *** gbacon left
[23:45] *** stephenlb left
[23:46] <TimToady> dunno

[23:47] *** rgrau left
[23:53] *** xabbu42 left
