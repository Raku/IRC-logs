[00:00] <ingy> You guys are all my heroes

[00:00] *** Patterner left
[00:00] *** Psyche^ is now known as Patterner

[00:01] <TimToady> even if we look at you funny when you're doing micro-optimizations?

[00:01] <ingy> You are the only group I've found who can spend all day, every day fishing for pies in the skies

[00:01] <ingy> You make an acmeist feel right at home

[00:01] <araujo> thank you

[00:01] <TimToady> we all have our little foibles

[00:02] <jnthn> $I0 = is_cclass .CCLASS_ALPHABETIC, tgt, pos

[00:02] <jnthn> ingy: It checks a unicode prop.

[00:02] <jnthn> ingy: So it's that against evaluating a character class.

[00:02] <jnthn> I suspect that the unicode prop check is quicker.

[00:02] <ingy> so it might help the poor poor rakudo

[00:03] <jnthn> Aye

[00:03] * jnthn is currently working out how to help the poor poor Rakudo be less poor

[00:03] <ingy> jnthn++

[00:03] <jnthn> Grammars are mostly method dispatch, which I hope to speed up a decent bit.

[00:04] <jnthn> Especially given that grammars are method dispatch mostly on the invocant, which we conveniently know the type of quite well. :-)

[00:04] <ingy> the grammars do seem to be a slow spot

[00:04] <jnthn> Or at least, better than we know the type of mos things.

[00:04] <jnthn> *most

[00:04] <dalek> niecza: 5b9ccc6 | sorear++ | Kernel.cs:

[00:04] <dalek> niecza: First step towards list contexts, add a plural value attribute

[00:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/5b9ccc6fb3925bd90123c3f5f4c8075adbbf73b4

[00:04] <dalek> niecza: 4b3b15a | sorear++ |  (2 files):

[00:04] <dalek> niecza: Implement list infix precedence

[00:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/4b3b15af61459a984f1596927601c5893eda5f03

[00:04] <dalek> niecza: 84f834d | sorear++ | niecza:

[00:04] <dalek> niecza: Add ./niecza FILE syntax

[00:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/84f834d268161f7e2ac4ed1f289d2e1fb7c0b464

[00:04] <dalek> niecza: 69af9bf | sorear++ | Niecza/Actions.pm:

[00:04] <dalek> niecza: Properly parse parcels

[00:04] <dalek> niecza: review: http://github.com/sorear/niecza/commit/69af9bf727a046418e21caa18a7eea70e840b27d

[00:04] <dalek> niecza: ad39387 | sorear++ |  (2 files):

[00:05] <dalek> niecza: Implement parcel splitting properly for foo(1,2)

[00:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ad39387d9f3d4b9d85b7f4cd61e5ecf30fd55c59

[00:05] <dalek> niecza: be0da90 | sorear++ |  (2 files):

[00:05] <dalek> niecza: Add a --ast option to the driver

[00:05] <dalek> niecza: review: http://github.com/sorear/niecza/commit/be0da90b306e59f32093919bba19bc8da8a0e96b

[00:05] <TimToady> well, a real LTM might help there

[00:05] <ingy> TimToady: are you and pmichaud heading to pdx next week?

[00:05] <TimToady> yes, we'll all arrive on Monday

[00:05] <jnthn> TimToady: It would, but we still gotta dispatch methods, I guess.

[00:05] <ingy> jnthn: are you coming over?

[00:06] <jnthn> ingy: 'fraid not. :(

[00:06] <jnthn> ingy: It's a long and - in the summer - expensive flight.

[00:06] <ingy> I'll prolly drive down from seattle

[00:06] <diakopter> wait, I thought the sky was made of pies

[00:06] <ingy> diakopter++

[00:07] <jnthn> diakopter: hush, don't tell the airlines there's whole pies up there! You saw what they did with little fragments of ash!

[00:07] <jnthn> Imagine a jet engine cooking a whole pie!

[00:07] <ingy> diakopter: That's the future I want to live in

[00:07] <TimToady> as long as they're not frozen

[00:07] *** silug left
[00:08] <jnthn> Actually, did the Iceland volcano affect many flights in the US?

[00:08] <TimToady> nope

[00:08] <jnthn> I know it was quite the disaster in Europe.

[00:08] <jnthn> Ah. :-)

[00:08] <TimToady> other than 2nd-hand delays

[00:08] <jnthn> I actually got stranded in Iceland.

[00:09] <jnthn> They bussed us to another airport, where the runway was in a valley with mountains at one end, and only just long enough to take the type of plane we were in.

[00:09] <diakopter> you shoulda taken the shortcut tunnel under the Atlantic

[00:09] <jnthn> They throttled it pretty hard down the runway and then it was by some margin the steepest ascent I've ever experienced. :-)

[00:10] <jnthn> diakopter: oh if only!

[00:10] <jnthn> diakopter: The one between England and France is very useful.

[00:10] *** takadonet left
[00:10] <TimToady> it was the atlantic tunnel that set of the volcano in the first place, though

[00:11] <jnthn> :-)

[00:11] *** meppl left
[00:11] <TimToady> most of the great circle routes go right over (or under) Iceland

[00:12] <TimToady> I hear they lost a whole trainload of frozen sushi on that route before they cranked up the AC

[00:12] <TimToady> *set off

[00:12] <jnthn> That ain't cool.

[00:13] <TimToady> it was fish soup for a whole week after that

[00:14] <jnthn> It's all the same to me, given I don't eat fish nor seafood.

[00:14] <TimToady> kitty is reading over my shoulder, and claims to be starving

[00:14] <TimToady> biab &

[00:14] <jnthn> Probably wants a cheezburger

[00:14] <jnthn> o/

[00:15] <allbery_b> obviously kitty wants fish

[00:15] *** f00li5h left
[00:15] *** f00li5h joined
[00:17] *** donaldh joined
[00:17] *** donaldh left
[00:18] <jnthn> allbery_b: huh? I saw loads of kitteh on the internets and they all eated cheezburger!

[00:22] <TimToady> shh, my kitty *thinks* she's eating fish, but it really is more like canned cheezburger...

[00:25] *** takadonet joined
[00:25] *** ruoso joined
[00:27] * sorear writes up 18 tests for niecza, including one that Rakudo won't pass (even if you change it to standard Perl 6)

[00:27] <diakopter> ++ ++

[00:29] <jnthn> sorear: Will be curious to see which one :-)

[00:29] <dalek> niecza: d7f3d96 | sorear++ |  (3 files):

[00:29] <dalek> niecza: Add a test suite & prefix:<!>

[00:29] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d7f3d962079d4d1d9228e8516e5c602240809fd7

[00:30] <sorear> jnthn: it's the last one; my $x; BEGIN { $x = 1 }; ok $x, "protolexpad changes affect default values"

[00:30] <jnthn> Ah :|

[00:30] <jnthn> Yes, you win on that one. For now. :-)

[00:30] <jnthn> sorear++

[00:41] <dalek> niecza: 528927c | sorear++ |  (2 files):

[00:41] <dalek> niecza: Use mono's AOT compiler on Setting.dll, saving ~1.5s on each run

[00:41] <dalek> niecza: review: http://github.com/sorear/niecza/commit/528927cb4a152531cd426cdbf777ac0548a33a4f

[00:42] <tylercurtis> sorear: does p6eval have niecza yet?

[00:51] <sorear> no

[00:51] <sorear> it's only had enough syntax to run nontrivial programs in the last 24 hours, really

[00:53] *** whiteknight left
[00:59] *** plobsing joined
[01:00] <Tene> rakudo: my @odd-sums := (4, map(*+*, (@sums Z 5,7...*))); say @odd-sums[0..5].perl;

[01:00] <p6eval> rakudo 6ab741: OUTPUT¬´===SORRY!===‚ê§Symbol '@sums' not predeclared in <anonymous> (/tmp/7YmzVnO0Us:20)‚ê§¬ª

[01:00] <Tene> rakudo: my @odd-sums := (4, map(*+*, (@odd-sums Z 5,7...*))); say @odd-sums[0..5].perl;

[01:00] <p6eval> rakudo 6ab741: OUTPUT¬´(4, 9, 16, 25, 36, 49)‚ê§¬ª

[01:01] <TimToady> how...haskellioid...

[01:02] <Tene> It was a translation of someone else's haskell, yes.

[01:02] <TimToady> I wonder how often people will expect it to work with = instead of :=

[01:03] <Tene> I did try it with = first, and wasn't entirely sure why it didn't work.

[01:03] <TimToady> list = is eager

[01:03] <Tene> Ah.

[01:05] *** ashleydev left
[01:18] *** takadonet left
[01:43] *** PZt joined
[01:44] *** macdaddy joined
[01:44] *** macdaddy is now known as Guest72554

[01:54] <Tene> rakudo: grammar Foo { token bar { 'x' } }; my $src = "axa"; my $m = $src ~~ /<Foo::bar>/; say $m.perl;

[01:54] <p6eval> rakudo 6ab741: OUTPUT¬´===SORRY!===‚ê§regex assertion not terminated by angle bracket at line 20, near "::bar>/; s"‚ê§¬ª

[01:55] <Tene> Ah, I see that's mentioned as Pm-2.  That doesn't seem to be discussed in S05, afaict, though.

[01:55] <Tene> And, apparently, NYI.

[01:56] <sorear> How does Perl 6 tell the difference between control exceptions and regular exceptions?

[01:56] <Tene> sorear: when I last worked on it, rakudo still used the type id.

[01:57] <sorear> I should start a SO-xx file

[01:57] <sorear> Tene: no type ids where I'm working now.

[01:57] <Tene> sorear: where?

[01:59] <Tene> sorear: look at src/builtins/control.pir

[01:59] <Tene>     e['type'] = .CONTROL_LOOP_NEXT

[01:59] <Tene> Rakudo is using the type id.

[02:00] <sorear> Not rakudo.  Perl 6.

[02:00] <Tene> Ah.

[02:00] <Tene> I misunderstood.

[02:00] <pugssvn> r31673 | lwall++ | [STD] first whack at detecting declared-but-unused variables 

[02:00] <pugssvn> r31673 | (known to still produce some false positives)

[02:02] <tylercurtis> std: sub sieve (*$p, *@xs) { $p, sieve($_ if $_ % $p for @xs); }

[02:02] <p6eval> std 31672: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse argument list at /tmp/4w7zkZwXKn line 1:‚ê§------> [32msub sieve (*$p, *@xs) { $p, sieve[33m‚èè[31m($_ if $_ % $p for @xs); }[0m‚ê§Couldn't find final ')'; gave up at /tmp/4w7zkZwXKn line 1:‚ê§------> [32msub sieve (*$p, *@xs) { $p,

[02:02] <p6eval> ..sieve‚Ä¶

[02:03] <TimToady> arglists aren't statements

[02:03] <TimToady> std: sub sieve (*$p, *@xs) { $p, sieve ($_ if $_ % $p for @xs); }

[02:03] <p6eval> std 31672: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[02:04] <TimToady> std: sub sieve (*$p, *@xs) { $p, sieve(($_ if $_ % $p for @xs)); }

[02:04] <p6eval> std 31672: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[02:04] <TimToady> std: sub sieve (*$p, *@xs) { $p, sieve(do if $_ % $p for @xs); }

[02:04] <p6eval> std 31672: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block at /tmp/pPbfTpJz6a line 1:‚ê§------> [32me (*$p, *@xs) { $p, sieve(do if $_ % $p [33m‚èè[31mfor @xs); }[0m‚ê§Parse failed‚ê§FAILED 00:01 115m‚ê§¬ª

[02:04] <TimToady> std: sub sieve (*$p, *@xs) { $p, sieve(do $_ if $_ % $p for @xs); }

[02:04] <p6eval> std 31672: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[02:04] <tylercurtis> TimToady: thanks.

[02:05] *** silug joined
[02:05] <TimToady> basically, we can't unambiguously allow anything looser than , in an arglist

[02:06] <TimToady> how would you bind foo(1,2,3 X 4,5,6) if there are positionals?

[02:07] * jnthn -> sleep

[02:07] <TimToady> o/

[02:12] *** masonkramer joined
[02:12] <sorear> TimToady: my $x = 2; END { say $x } # this prints Any(), right?

[02:18] <pugssvn> r31674 | lwall++ | [STD] refrain from complaining about unused implicit cast functions 

[02:18] *** agentzh joined
[02:18] <TimToady> well, it would print 2 in Perl 5  :)

[02:19] <sorear> How do Perl 5 protolexes work?

[02:20] <sorear> As I'm seeing it, 2 is assigned to the runtime pad, but END is unclonable and only sees the proto

[02:21] <TimToady> that makes END pretty useless for most of what it's used for in Perl 5 (or awk)

[02:21] <TimToady> maybe it's more like a LEAVE block

[02:21] *** Sarten-X joined
[02:22] <TimToady> (and INIT should be like ENTER, by the same argument)

[02:22] <sorear> Why does Perl 5 not have the same issue?

[02:22] *** gbacon left
[02:22] <TimToady> doesn't create a lexpad for mainline code, just reuses the protopad

[02:23] <TimToady> or maybe the other way around :)

[02:24] <TimToady> well, I guess one could still use our variables, since they really live in a package, and only have a lexical name

[02:24] <TimToady> we can make that restriction if we really need to

[02:25] <TimToady> otoh if there's some way to clone the mainline at compile time and freezedry it, that would be more like what a P5 programmer would expect

[02:26] <sorear> please elaborate on last statement

[02:26] <TimToady> but that might require more of a workspace-saving view ala Smalltalk that some impls might have difficulty supporting

[02:28] <tylercurtis> Why isn't there a FINISH?

[02:28] <TimToady> because no one knows when they're about to draw their last breath

[02:29] <lue> wello there o/

[02:29] <tylercurtis> err... never mind... was confusing INIT and START.

[02:31] <sorear> TimToady: I'm not very familiar with smalltalk; what does it mean to clone and freezedry a mainline?

[02:33] *** skids left
[02:35] <TimToady> smalltalk doesn't distinguish compile-time from run-time.  it's all run time, and you "compile" by saving a memory image, basically.

[02:36] <TimToady> wow, there's a lot of declared-but-unused vars in the test suite :)

[02:38] <TimToady> bbl &

[02:39] <sorear> When you get back, would you explain what saving memory images has to do with protopaddy behavior?

[02:42] *** [Coke] left
[02:47] <sorear> odd that 'Mu' is parsed as a functionall

[02:47] <sorear> call

[02:47] <sorear> seems like it ought to be a term

[02:47] *** [Coke] joined
[02:53] <sorear> std: Mu === Any

[02:53] <p6eval> std 31674: OUTPUT¬´ok 00:01 112m‚ê§¬ª

[02:53] <sorear> std: sub foo() { 42 }; foo == 42

[02:53] <p6eval> std 31674: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Preceding context expects a term, but found infix == instead at /tmp/RU36A0BcFV line 1:‚ê§------> [32msub foo() { 42 }; foo [33m‚èè[31m== 42[0m‚ê§Parse failed‚ê§FAILED 00:01 111m‚ê§¬ª

[02:53] <sorear> std: sub foo() { 42 }; Mu == 42

[02:53] <p6eval> std 31674: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[02:53] <sorear> hmm

[02:54] <sorear> std: sub foo() { 42 }; (foo) == 42

[02:54] <p6eval> std 31674: OUTPUT¬´ok 00:01 112m‚ê§¬ª

[02:54] *** HarryS left
[03:03] *** cotto joined
[03:08] *** ashleydev joined
[03:13] *** masonkramer left
[03:14] <sorear> std: 2.HOW(3)

[03:14] <p6eval> std 31674: OUTPUT¬´ok 00:01 111m‚ê§¬ª

[03:14] <sorear> rakudo: 2.HOW(3)

[03:14] <p6eval> rakudo 6ab741: OUTPUT¬´too many positional arguments: 2 passed, 1 expected‚ê§  in main program body at line 20:/tmp/K9EqhU1Y22‚ê§¬ª

[03:29] *** nadim left
[03:30] *** hercynium joined
[03:31] *** nadim joined
[03:32] *** ashleydev left
[03:38] <dalek> niecza: 8afac05 | sorear++ |  (4 files):

[03:38] <dalek> niecza: Implement multi-outered classes

[03:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/8afac05394fbc27858feeb57ab74011ddc6d1e94

[03:38] <dalek> niecza: ece8139 | sorear++ |  (2 files):

[03:38] <dalek> niecza: Fix pre-init blocks in non-void context

[03:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/ece813971679d5ef82e86fa22510f343bec2f801

[03:38] <dalek> niecza: f5fe8a4 | sorear++ |  (2 files):

[03:38] <dalek> niecza: Fix calling functions without arguments

[03:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/f5fe8a48deff0e621c80723bfa8dc84c958fefea

[03:38] <dalek> niecza: b1fde30 | sorear++ | Niecza/Actions.pm:

[03:38] <dalek> niecza: Implement code generation for typename references

[03:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b1fde303b548c2faaa006dc9ca734b6f94021d64

[03:38] <dalek> niecza: a9d43b1 | sorear++ |  (3 files):

[03:38] <dalek> niecza: Implement .HOW interrogative

[03:38] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a9d43b13db0c616df245f7f0c35841a234ac14f8

[03:53] *** HarryS joined
[04:25] *** cjk101010 left
[04:26] <dalek> niecza: d87ab4c | sorear++ | Niecza/Actions.pm:

[04:26] <dalek> niecza: Fix calling methods with arguments

[04:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d87ab4cc5e043ae7f030fc44c4bf2d09c04cc4a1

[04:26] <dalek> niecza: 2d8120f | sorear++ | setting:

[04:26] <dalek> niecza: Start venturing into augment-land with Mu.Str, Mu.Bool, and Mu.defined

[04:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/2d8120f72ef6c2edeb3b7a3afb69bc9307d8f186

[04:26] <dalek> niecza: b876c9a | sorear++ |  (2 files):

[04:26] <dalek> niecza: Actually _use_ MROs

[04:26] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b876c9a7b513eba216184d8f74f3b12abba6d8c9

[04:33] *** tedv left
[05:14] <dalek> niecza: 3603719 | sorear++ | Makefile:

[05:14] <dalek> niecza: Improve Makefile granularity

[05:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/3603719db1acf1ed1d52f93028c877e222cafb43

[05:14] <dalek> niecza: a2eefa3 | sorear++ |  (4 files):

[05:14] <dalek> niecza: Remove some very out of date draft code

[05:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a2eefa388bc4f9dfd7c7b2eb71ea63ddebf15a70

[05:14] <dalek> niecza: c5c98e7 | sorear++ |  (2 files):

[05:14] <dalek> niecza: New operators: eq, ne, ===

[05:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/c5c98e7877a255b1cf107a16936f5344b5a78f6e

[05:14] <dalek> niecza: e8e0d79 | sorear++ | test.pl:

[05:14] <dalek> niecza: A few new stringish tests

[05:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/e8e0d79dc41445f50a554d47d1d8027b539727ba

[05:14] <dalek> niecza: 0072cfd | sorear++ |  (6 files):

[05:14] <dalek> niecza: Implement .WHAT

[05:14] <dalek> niecza: review: http://github.com/sorear/niecza/commit/0072cfd9cc4358152151ccba1e3d1c5a868f4821

[05:15] *** hercynium left
[05:21] *** constant left
[05:24] *** constant joined
[05:28] *** hellothere joined
[05:29] <hellothere> hello

[05:29] <moritz_> good morning

[05:30] <tylercurtis> hello, there.

[05:30] * tylercurtis couldn't resist.

[05:32] *** tadzik joined
[05:33] <moritz_> :-)

[05:35] *** cbk joined
[05:37] <sorear> Hello, hellothere!  Welcome to #perl6.

[05:37] <cbk> hi

[05:37] <sorear> Hello, cbk.  Welcome to #perl6.

[05:38] *** ashleydev joined
[05:39] <hellothere> I've heard different things about perl 6, regarding how close it is to release.  Would I be lambasted for inquiring here?

[05:39] <hellothere> btw, I'm new to perl, love 5 so far

[05:40] <sorear> It's an early adopters release.

[05:40] <cbk> hellothere, here is some info at this link: http://rakudo.org/node/73

[05:40] <sorear> Perl 6 isn't going to become a solid production tool until it sees serious use

[05:40] <cbk> http://rakudo.org/node/73

[05:40] <hellothere> Awesome!

[05:40] <sorear> so we're trying to court the people who will use it heavily, but won't die if it breaks on them

[05:41] <hellothere> I write only small utilities now.  The latest reads in xml clobs from an oracle DB, then parses them and prints out some data from each clob.

[05:42] <cbk> is this the right way to do matching: if ($inputStr ~~ m/:i $searchStr /)

[05:42] <moritz_> cbk: yes, but now parens required

[05:42] <cbk> i need case insensitive

[05:42] <cbk> where?

[05:42] <tylercurtis> hellothere: Never be afraid to ask a question here. I don't know that #perl6's populace is capable of lambasting.

[05:42] <hellothere> isn't case insensitive \i

[05:43] <moritz_> my $searchString = 'bc';  if 'aBcdef' ~~ m/:i $searchString / { say $/ }

[05:43] <cbk>  if ($inputStr ~~ m/:i ($searchStr) /) ??

[05:43] <tylercurtis> cbk: moritz_ meant to say "no parens required", I think.

[05:43] <moritz_> sorry

[05:43] <sorear> m:i/ $searchStr /

[05:43] <moritz_> *no* parens required

[05:43] <hellothere> or maybe just i after the //s

[05:43] <moritz_> rakudo: my $searchString = 'bc';  if 'aBcdef' ~~ m/:i $searchString / { say $/ }

[05:43] <p6eval> rakudo 6ab741:  ( no output )

[05:44] <sorear> rakudo: /foo/i

[05:44] <p6eval> rakudo 6ab741: OUTPUT¬´===SORRY!===‚ê§Unsupported use of /i; in Perl 6 please use :i at line 20, near ""‚ê§¬ª

[05:44] <tylercurtis> hellothere: Perl 6 regexes have modifiers on the front or lexically scoped within their bodies.

[05:44] * moritz_ wonders why $/ is empty in this case... somethiing's wrong here

[05:44] <tylercurtis> rakudo: say 'aBcdef' ~~ m/:i bc /;

[05:45] <p6eval> rakudo 6ab741: OUTPUT¬´Bc‚ê§¬ª

[05:45] <sorear> moritz_: the 'no output' bug?

[05:45] <hellothere> so if you wanted to use s, i, and x options like in the learning perl book, it would be  'blah' ~= /:ixs bc/;  ?

[05:45] <moritz_> sorear: no, even locally it produces just a newline

[05:46] <moritz_> hellothere: /x is default in Perl 6, and /s is gone

[05:46] <moritz_> but the correct clustering would be :i:s

[05:46] <hellothere> I have much to learn!

[05:46] <sorear> also, the match operator is spelled ~~ now

[05:47] <sorear> and it applies to much more than regexes

[05:47] *** ashleydev left
[05:47] <tylercurtis> rakudo: say 5 ~~ Int;

[05:47] <p6eval> rakudo 6ab741: OUTPUT¬´1‚ê§¬ª

[05:48] <moritz_> rakudo: say 5 ~~ 1..10

[05:48] <p6eval> rakudo 6ab741: OUTPUT¬´1‚ê§¬ª

[05:48] <moritz_> rakudo: say -5 ~~ 1..10

[05:48] <p6eval> rakudo 6ab741: OUTPUT¬´0‚ê§¬ª

[05:49] <hellothere> rakudo say "test\n"

[05:49] <hellothere> rakudo: say "test\n"

[05:49] <p6eval> rakudo 6ab741: OUTPUT¬´test‚ê§‚ê§¬ª

[05:50] <hellothere> cool

[05:50] <cbk> rakudo: my $searchStr = "test"; my $inputStr = "TEST"; if ($inputStr ~~ m/:i $searchStr /) { say "Search term found in string!";} else {say "Not found!";}

[05:50] <p6eval> rakudo 6ab741: OUTPUT¬´Not found!‚ê§¬ª

[05:50] <hellothere> thanks again for links and answers. you guys rock.

[05:50] *** hellothere left
[05:51] <cbk> rakudo: my $searchStr = "TEST"; my $inputStr = "TEST"; if ($inputStr ~~ m/:i $searchStr /) { say "Search term found in string!";} else {say "Not found!";}

[05:51] <p6eval> rakudo 6ab741: OUTPUT¬´Search term found in string!‚ê§¬ª

[05:51] * moritz_ submits rakudobug

[05:51] <cbk> rakudo: my $searchStr = "TEST"; my $inputStr = "Test"; if ($inputStr ~~ m/:i $searchStr /) { say "Search term found in string!";} else {say "Not found!";}

[05:52] <p6eval> rakudo 6ab741: OUTPUT¬´Not found!‚ê§¬ª

[05:52] <cbk> is that right?

[05:52] <moritz_> it's a bug

[05:53] <moritz_> which I've just submitted to our bug tracker

[05:53] *** ashleydev joined
[05:53] <tylercurtis> rakudo: my $searchStr = "TEST"; my $inputStr = "Test"; if ($inputStr ~~ m/:i $searchStr /) { say "Search term found in string!"; say $/;} else {say "Not found!";}

[05:53] <p6eval> rakudo 6ab741: OUTPUT¬´Not found!‚ê§¬ª

[05:53] <tylercurtis> rakudo: my $searchStr = "TEST"; my $inputStr = "Test"; if ($inputStr ~~ m/:i $searchStr /) { say "Search term found in string!";} else {say "Not found!";}

[05:53] <p6eval> rakudo 6ab741: OUTPUT¬´Not found!‚ê§¬ª

[05:53] <cbk> Noooooooo .  Why?  I have been racking my brain for 2 hours thinking I was doing it wrong!

[05:54] <tylercurtis> rakudo: my $searchStr = "TEST"; my $inputStr = "TEST"; if ($inputStr ~~ m/:i $searchStr /) { say "Search term found in string!";} else {say "Not found!";}

[05:54] <p6eval> rakudo 6ab741: OUTPUT¬´Search term found in string!‚ê§¬ª

[05:54] <tylercurtis> rakudo: my $searchStr = "TEST"; my $inputStr = "TEST"; if ($inputStr ~~ m/:i $searchStr /) { say "Search term found in string!"; say $/;} else {say "Not found!";}

[05:54] <p6eval> rakudo 6ab741: OUTPUT¬´Search term found in string!‚ê§TEST‚ê§¬ª

[05:55] <tylercurtis> rakudo: my $searchStr = "TEST"; my $inputStr = "Test"; if ($inputStr ~~ m:i/ $searchStr /) { say "Search term found in string!";} else {say "Not found!";}

[05:55] <p6eval> rakudo 6ab741: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 20‚ê§¬ª

[05:55] <tylercurtis> rakudo: my $searchStr = "TEST"; my $inputStr = "Test"; if ($inputStr ~~ /:i $searchStr /) { say "Search term found in string!";} else {say "Not found!";}

[05:55] <p6eval> rakudo 6ab741: OUTPUT¬´Not found!‚ê§¬ª

[05:55] <cbk> moritz_, Thanks for you help.  I was really doubting my perl6 Foo.

[05:56] *** justatheory left
[05:57] <dalek> niecza: be5905e | sorear++ |  (2 files):

[05:57] <dalek> niecza: Fix ClassHOW to inherit from Any instead of being an orphan

[05:57] <dalek> niecza: review: http://github.com/sorear/niecza/commit/be5905e8c9caa12dcead82e916788814663a4030

[05:57] <dalek> niecza: d463990 | sorear++ |  (3 files):

[05:57] <dalek> niecza: Implement self; signatures for methods; some class tests

[05:57] <dalek> niecza: review: http://github.com/sorear/niecza/commit/d463990a64157cfbb4746e60e9de3389bf673421

[05:57] <dalek> niecza: b97bc5c | sorear++ | setting:

[05:57] <dalek> niecza: Use self in the setting

[05:57] <dalek> niecza: review: http://github.com/sorear/niecza/commit/b97bc5cd2c07323edc7f12a8834726731c093d2b

[05:57] <sorear> it's scary how much niecza has improved in the last two days

[05:58] <tylercurtis> sorear: normally, I'd be opposed to such self-complimenting; but I agree.

[06:00] <sorear> it's not self-complimenting.  the elegance of Perl 6 semantics are what's making this possible.

[06:00] <sorear> it seems a lot harder than it really is

[06:07] <tylercurtis> sorear++ Surely at least part of it must be you being extremely productive. It's impressive.

[06:07] <sorear> me?  productive?  in the middle of a heat wave?

[06:10] <tylercurtis> Scarily so.

[06:11] *** uniejo joined
[06:11] * tylercurtis -> bed.

[06:11] <tylercurtis> Good night, #perl6.

[06:12] *** tylercurtis left
[06:13] *** ashleydev left
[06:16] *** baest joined
[06:21] *** cjk101010 joined
[06:28] *** am0c joined
[06:39] <dalek> niecza: 3b9d4f5 | sorear++ |  (5 files):

[06:39] <dalek> niecza: Add automatic STD submodule logic

[06:39] <dalek> niecza: Idea stolen from Rakudo/Parrot.  'make' will automatically download and build

[06:39] <dalek> niecza: a known working version of the STD subsystem.

[06:39] <dalek> niecza: review: http://github.com/sorear/niecza/commit/3b9d4f5cfc2a74bce6e78117ab7e1304b008a6cb

[06:40] <sorear> moritz_: I've removed the requirement to edit the Makefile for builds; it should be possible to just git clone & make now

[06:40] <sorear> moritz_: I'd like to know if it works on p6eval

[06:41] <sorear> once 'make' finishes, ./niecza -e CODE ; you must be in the checkout root dir

[06:41] <sorear> system interfacing beyond &say is NYI, but DOS is a definite possibility

[06:41] <moritz_> does FILE work instead of -e CODE too?

[06:41] <sorear> yes

[06:41] <moritz_> great

[06:41] <sorear> use statements are nyi though

[06:41] <moritz_> for DOS we have resource limits

[06:42] <moritz_> /bin/sh: /home/p6eval/niecza/STD_checkout/viv: No such file or directory

[06:42] <moritz_> make: *** [Niecza/Grammar.pmc] Error 127

[06:42] <moritz_> after running 'make'

[06:42] <moritz_> s/after/during/

[06:42] <sorear> uh

[06:42] <sorear> oops.

[06:42] <sorear> one sec

[06:43] <sorear> fixed

[06:43] <moritz_> looks better

[06:43] <moritz_> checkous out STD

[06:44] <moritz_> erm

[06:44] <moritz_> you know what I mean :-)

[06:45] <dalek> niecza: a1a17b8 | sorear++ | Makefile:

[06:45] <dalek> niecza: Fix missing dependency

[06:45] <dalek> niecza: review: http://github.com/sorear/niecza/commit/a1a17b8d91610cdcc9e88d24b81683f0891c30ad

[06:45] <sorear> yes

[06:45] <sorear> it's supposed to check out STD

[06:45] <sorear> --gen-parrot style

[06:57] <moritz_> All tests successful

[06:57] <moritz_> \o/

[06:57] <moritz_> $ ./niecza -e 'say 42'

[06:57] <moritz_> IPC::System::Simple required for Fatalised/autodying system() at ./niecza line 8

[06:57] <sorear> \o/

[06:58] <moritz_> sorear: you could declare that dependency somwhere, at your convenience

[06:59] <sorear> done

[06:59] *** timbunce joined
[06:59] <moritz_> anyway, awesome error message, (Paul Fenwick)++

[07:01] <moritz_> pjf++ even :-)

[07:02] *** plobsing left
[07:03] <dalek> niecza: 6516616 | sorear++ | README:

[07:03] <dalek> niecza: Add another forgotten dep moritz++

[07:03] <dalek> niecza: review: http://github.com/sorear/niecza/commit/6516616129200bda9b20f91cfd45e3eae7ef8d68

[07:03] <pugssvn> r31675 | moritz++ | [evalbot] experimental niecza target 

[07:04] <moritz_> sorear: repeated 'make' doesn't converge on doing nothing

[07:04] *** p6eval left
[07:04] *** p6eval joined
[07:04] <moritz_> niecza: say 42

[07:04] <p6eval> niecza: OUTPUT¬´Perl v5.10.1 required--this is only v5.10.0, stopped at ./niecza line 4.‚ê§BEGIN failed--compilation aborted at ./niecza line 4.‚ê§¬ª

[07:04] <moritz_> huh.

[07:04] <sorear> oops.

[07:05] <moritz_> it uses a different perl

[07:05] <moritz_> should be a simple fix though

[07:06] *** p6eval left
[07:06] *** p6eval joined
[07:06] <moritz_> I know why I say "experimental" :-)

[07:06] <pugssvn> r31676 | moritz++ | use perl-5.12.1 to run niecza 

[07:06] <sorear> the only reason I have use 5.010_001 there is because 5.10.1 has autodie

[07:06] <moritz_> niecza: say 42

[07:06] <sorear> in core

[07:06] <p6eval> niecza: OUTPUT¬´42‚ê§¬ª

[07:06] <moritz_> it's ok, we have a 5.12 anyway

[07:06] <moritz_> \o/

[07:06] <sorear> \o/

[07:07] <moritz_> niecza: say "we can haz stringz?"

[07:07] <p6eval> niecza: OUTPUT¬´we can haz stringz?‚ê§¬ª

[07:08] <sorear> niecza: my $ct = 20000; my $a = 1; my $b = 1; while $ct-- { my $ab = $a + $b; $a = $b; $b = $ab; }; say "20k fibs"

[07:08] <p6eval> niecza: OUTPUT¬´20k fibs‚ê§¬ª

[07:08] <sorear> (it'll get a lot slower once I implement multi dispatch :/)

[07:08] <cxreg> with recent parrot and rakudo, it seems like my zavolaj based Pg has broken :/  donno why

[07:08] <moritz_> niecza: say 9999999 * 9999999 * 9999999

[07:08] <p6eval> niecza: OUTPUT¬´9.9999970000003E+20‚ê§¬ª

[07:08] <sorear> right now, all arithmetic is forced to Num

[07:08] <moritz_> :(

[07:09] <moritz_> (that :( was to Pg being broken)

[07:09] <moritz_> cxreg: how did it break?

[07:09] <sorear> I do, however, have bigint libraries trivially available on the platform

[07:09] <sorear> niecza: say 1.WHAT

[07:09] <dalek> niecza: 3a064a4 | sorear++ |  (2 files):

[07:09] <dalek> niecza: all, not test, should be the default make target; remove erroneous use 5.010_001

[07:09] <dalek> niecza: review: http://github.com/sorear/niecza/commit/3a064a44e11366961c16e5d0d61d1c3327222266

[07:09] <p6eval> niecza: OUTPUT¬´‚ê§Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object‚ê§  at Niecza.Kernel.UnboxAny (IP6 o) [0x00000] in <filename unknown>:0 ‚ê§  at Setting.Str_13C (Niecza.Frame th) [0x00000] in <filename unknown>:0 ‚ê§  at Niecza.Frame.Continue () [‚Ä¶

[07:09] <cxreg> PQconnectdb is returning Failure, even though i know the connect info is right

[07:09] <cxreg> and it worked previously

[07:09] <sorear> hmm.

[07:10] <sorear> rakudo: say 1.WHAT

[07:10] <p6eval> rakudo 6ab741: OUTPUT¬´Int()‚ê§¬ª

[07:10] <moritz_> cxreg: does the pg error string contain anything useful?

[07:10] <sorear> niecza evaluates 1.WHAT to be the undefined type object of Num

[07:11] <sorear> then it tries to stringify as if it were a normal Num, but blows up on $!value

[07:11] <sorear> rakudo: say Int

[07:11] <p6eval> rakudo 6ab741: OUTPUT¬´Int()‚ê§¬ª

[07:11] <sorear> rakudo: say Int.Str

[07:11] <p6eval> rakudo 6ab741: OUTPUT¬´Int()‚ê§¬ª

[07:11] <sorear> rakudo: say Int.Stringy

[07:11] <p6eval> rakudo 6ab741: OUTPUT¬´Method 'Stringy' not found for invocant of class ''‚ê§  in main program body at line 20:/tmp/MkNhxnCNcZ‚ê§¬ª

[07:11] <moritz_> it doesn't do the distinction yet

[07:12] <sorear> I would have thought the correct stringing of Int is undef warning + "0"

[07:13] <sorear> more and more I begin the suspect that the view of type objects as "like normal objects of the type, but with no slots" is wrong

[07:13] <sorear> niecza: say 1.WHAT === Num

[07:13] <p6eval> niecza: OUTPUT¬´Bool::True‚ê§¬ª

[07:13] <moritz_> I think .Str is supposed to return 'Int()', and .Stringy '0' + warning

[07:13] <moritz_> not sure though

[07:14] <moritz_> sorear: yes, it would make sense to declare methods only on the type object, or only on instances, without going through :U and :D (which act as constraints on the multi dispatch, which seems to be the wrong level)

[07:14] <moritz_> but I don't really have a better idea

[07:16] <cxreg> moritz_: i'm not sure how to call PQerrorMessage with a null, and not an OpaquePointer

[07:18] <cxreg> something seems screwy, i dont think i should be getting Failure back, even if it returned NULL

[07:19] *** FardadJalili joined
[07:21] <szabgab> moritz_: will there be a hackathon before YAPC::EU ?

[07:25] <cxreg> ok, it's not me

[07:25] <cxreg> zavolaj's own examples/postgresqlclient.p6 is doing it too

[07:25] <cxreg> :(

[07:25] *** FardadJalili left
[07:26] <cxreg> i could bisect, but this could take a while

[07:27] <moritz_> szabgab: yes

[07:28] <moritz_> szabgab: on Aug 3rd

[07:28] <moritz_> (discussed on [email@hidden.address] btw)

[07:28] <moritz_> I should blog about it :-)

[07:28] <moritz_> bbl

[07:40] <szabgab> so it would be good if I arrive on the 2nd at night , I can then sleep while you ppl are doing interesting stuff :)

[07:44] *** eternaleye left
[07:48] <szabgab> moritz_: http://conferences.yapceurope.org/ye2010/wiki?node=Hackatons

[07:55] *** baest left
[07:59] *** qiuhw joined
[08:01] <sorear> moritz_: another aspect is .ACCEPTS

[08:01] <sorear> what is .ACCEPTS on a defined object supposed to do?

[08:01] * sorear returns from walk with understanding of how list context /really/ works

[08:08] <qiuhw> Hi, I know a little Ruby, and I'd wish to have a commit bit for tufte, my github account is qiuhw. Thanks.

[08:12] *** qiuhw left
[08:14] *** eternaleye joined
[08:15] *** sftp left
[08:16] *** xinming left
[08:17] *** qiuhw joined
[08:17] *** Mowah joined
[08:18] *** lue left
[08:19] *** thebird joined
[08:20] <sorear> qiuhw: tufte?  do you have the right channel?

[08:22] <qiuhw> I've read one of Moritz's blog, and it said one can get a commit bit from this channel.

[08:22] <mathw> sorear: that would be a project porting from Ruby to Perl 6

[08:30] *** Exodist left
[08:33] <moritz_> hugme: add qiuhw to tufte

[08:33] * hugme hugs qiuhw. Welcome to tufte!

[08:33] <moritz_> qiuhw: you now have. Have fun hacking!

[08:33] <mathw> Morning moritz_

[08:33] <moritz_> mornin'

[08:34] <qiuhw> moritz: Thanks.

[08:34] *** dakkar joined
[08:36] *** meppl joined
[08:40] *** exodist joined
[08:46] *** tinitus joined
[08:49] *** Ross joined
[08:49] *** TiMBuS joined
[08:50] *** dju left
[08:50] *** dju joined
[08:51] *** tinitus left
[08:51] <moritz_> rakudo: pir::printerr__vs('OH HAI')

[08:51] <p6eval> rakudo 6ab741: OUTPUT¬´OH HAI¬ª

[08:55] *** dju left
[08:55] *** dju joined
[09:00] <sorear> Other than signature binding, when are non-flttening list contexts used?

[09:00] <sorear> moritz_: is niecza on an autoupdater?

[09:01] <moritz_> sorear: not yet

[09:01] <moritz_> would once per hour be enough?

[09:01] <sorear> well, I'm asking because I'm about to make lots of breaking changes and wanted to know whether to branch first

[09:02] <sorear> once per hour would be more than enough, when it starts

[09:02] <moritz_> sorear: just ping when you want the autoupdater installed

[09:02] <moritz_> so that you can break stuff now, and later branch :-)

[09:05] <sorear> excellent.

[09:05] <sorear> rakudo: my $x = 1, ; say $x.WHAT

[09:05] <p6eval> rakudo 6ab741: OUTPUT¬´Int()‚ê§¬ª

[09:06] <sorear> rakudo: say (1, ).WHAT

[09:06] <p6eval> rakudo 6ab741: OUTPUT¬´Parcel()‚ê§¬ª

[09:06] <moritz_> note that $x only ever sees the 1

[09:06] <sorear> rakudo: say (1, ).item.WHAT

[09:06] <p6eval> rakudo 6ab741: OUTPUT¬´Seq()‚ê§¬ª

[09:06] <moritz_> due to the precedence of =

[09:06] <sorear> oh

[09:06] <moritz_> rakudo: my $x = (1, ); say $x.WHAT

[09:06] <sorear> rakudo: my $x = (1, ) ; say $x.WHAT

[09:06] <p6eval> rakudo 6ab741: OUTPUT¬´Seq()‚ê§¬ª

[09:06] <p6eval> rakudo 6ab741: OUTPUT¬´Seq()‚ê§¬ª

[09:06] <sorear> that makes much more sense

[09:07] <sorear> std: my $x = 1,;

[09:07] <p6eval> std 31676: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[09:07] <sorear> std: my $x = 1,2;

[09:07] <tadzik> hmm. (1, 2, 3) is the parcel, [1, 2, 3] is an array. How to make a list?

[09:07] <moritz_> but note that rakudo illegally allows

[09:07] <p6eval> std 31676: OUTPUT¬´ok 00:01 112m‚ê§¬ª

[09:07] <moritz_> rakudo: say (1, , 4).perl

[09:07] <p6eval> rakudo 6ab741: OUTPUT¬´(1, 4)‚ê§¬ª

[09:07] <moritz_> tadzik: (1, 2, 3).list. But why would you need one?

[09:07] <sorear> tadzik: you don't; lists are a secret implementation type

[09:07] *** eternaleye left
[09:08] <tadzik> ah, ok

[09:08] <moritz_> if you want to type-check for something list-like, use Positional instead

[09:08] <moritz_> that's the role that List, Array, Capture etc. implement

[09:10] <sorear> after: my @x := \(1, 2, :a<b>);   what does @x look like?

[09:11] <moritz_> uhm

[09:11] <sorear> is it the original Capture, or (1, 2).list?

[09:11] <sorear> or something entirely different?

[09:11] <moritz_> the capture, I'd think

[09:11] <moritz_> at least something that you can't change easily (if at all)

[09:12] <sorear> after my @x := 1, 2;  is @x a Parcel or did it turn into a List?

[09:12] <moritz_> rakudo: my @x := (1, 2); say @x.WHAT

[09:12] <p6eval> rakudo 6ab741: OUTPUT¬´Parcel()‚ê§¬ª

[09:12] <moritz_> kinda what I expected

[09:13] <moritz_> rakudo: my $x = 1; my @a := ($x, 2); @a[0] =5; say $x

[09:13] <p6eval> rakudo 6ab741: OUTPUT¬´5‚ê§¬ª

[09:13] <moritz_> \o/

[09:13] <sorear> what I hoped for, too

[09:14] *** xinming joined
[09:14] * sorear finds himself implementing four kinds of variable

[09:15] * moritz_ is curious. Which kinds?

[09:15] <sorear> the well known $foo and @foo, ¬¢foo (which does *no* coercion on bound stuff and may or may not be a list; needed for the RHS of &infix:<=>, as well as circularity before .item is available)

[09:15] <sorear> and then ... self

[09:16] <sorear> I'm calling it a weak scalar variable.  It's never a list, but it also doesn't call .item

[09:16] <sorear> it can't call item, because if it did .item itself would have trouble being implemented

[09:18] <moritz_> rakudo solves this problem by doing low-level accesses to self, iiuc

[09:18] *** ruoso left
[09:19] *** dju left
[09:21] *** Guest72554 left
[09:30] *** baest joined
[09:31] *** Mowah left
[09:35] <sorear> Should sub foo { my $x; BEGIN { $x = 2 }; $x }   return 2 or Any?

[09:36] <sorear> Currently in niecza that returns 2

[09:36] <sorear> But I'm thinking that maybe it should change to Any, because the current approach requires copying behind the scenes

[09:36] <sorear> Which would be very suprising if $x was tied

[09:37] <sorear> So I'm thinking that in subs and control blocks, the compiler pad and the runtime pads should maybe be entirely distinct

[09:38] <moritz_> sorear: S06 or S04 has a very heavy section, conjecturing that BEGIN and END phasers might not be closures

[09:39] <moritz_> it's a bit (or way) over my head

[09:39] <moritz_> as a user, I'd be happy if it returned 2 though

[09:39] *** drbean left
[09:40] *** IllvilJa left
[09:40] *** Mowah joined
[09:40] <sorear> the fact that BEGIN can't close is orthogonal to this question, mostly

[09:42] <sorear> sub foo { my $x is NoisyScalar; Nil }; foo;  # in niecza's current model, this produces the call sequence New (protopad), New (call), Fetch (proto), Store (call)

[09:42] <sorear> does that suprise you as a user?

[09:43] *** tadzik left
[09:43] <moritz_> waitwaitwait

[09:43] <moritz_> if I implement NoisyScalar

[09:43] <moritz_> I don't expect to get any fetch operation from that code

[09:43] *** tadzik joined
[09:44] <moritz_> fetch is something I'd expect on my $ = $x;

[09:44] <sorear> the fetch occurs because stuff written in a hypothetical BEGIN needs to be propagated into the runtime version

[09:44] <sorear> (it could be optimized out if there is obviously no BEGIN)

[09:45] <moritz_> (except that for the initialization, I might get a fetch method call on the NoisyScalar type object; that would be fine)

[09:45] <sorear> in order to support the Any/2 example

[09:45] <sorear> rakudo: sub foo(@x?) { say @x.WHAT }; foo

[09:45] <p6eval> rakudo 6ab741: OUTPUT¬´Array()‚ê§¬ª

[09:45] <sorear> rakudo: sub foo(@x?) { say +@x }; foo

[09:46] <p6eval> rakudo 6ab741: OUTPUT¬´0‚ê§¬ª

[09:46] <sorear> rakudo: sub foo(@x?) { say @x.WHAT }; foo( (1,2,3) )

[09:46] <p6eval> rakudo 6ab741: OUTPUT¬´Parcel()‚ê§¬ª

[09:46] <moritz_> that binds

[09:46] <sorear> yes

[09:46] <moritz_> rakudo: sub foo(@x? is copy) { say @x.WHAT }; foo( (1,2,3) )

[09:46] <sorear> mostly wondering what happens if it doesn't bind

[09:47] <p6eval> rakudo 6ab741: OUTPUT¬´Array()‚ê§¬ª

[09:47] <sorear> apparently, it acts like my @x

[09:47] <moritz_> right

[09:47] <sorear> which is exactly how the most simple niecza implimentation will do it

[09:47] <moritz_> which actually matches my understanding of the spec

[09:48] *** IllvilJa joined
[09:48] <tadzik> rakudo: my @even-numbers  = 0, 2 ... *; @even-numbers[5].say # shouldn't it work?

[09:48] <p6eval> rakudo 6ab741:  ( no output )

[09:49] <sorear> tadzik: no

[09:49] <tadzik> it's used in Perl6 advent calendar

[09:49] <moritz_> I think it should

[09:49] <sorear> = is a copying operator

[09:49] <moritz_> and it was working in rakudo at one point

[09:49] <mathw> should work by my understanding

[09:49] <moritz_> tadzik: I'm pretty sure it works now with := instead of =

[09:49] <sorear> rakudo: my @even-numbers := 0, 2 ... *; @even-numbers[5].say # try not copying an infinite amount of stuff

[09:49] <p6eval> rakudo 6ab741:  ( no output )

[09:50] <moritz_> rakudo: mY @a = 1..*; say @a[3]

[09:50] <sorear> rakudo: my @even-numbers := (0, 2 ... *); @even-numbers[5].say

[09:50] <p6eval> rakudo 6ab741: OUTPUT¬´===SORRY!===‚ê§Symbol '@a' not predeclared in <anonymous> (/tmp/0wHwZ2ACAY:20)‚ê§¬ª

[09:50] <p6eval> rakudo 6ab741: OUTPUT¬´10‚ê§¬ª

[09:50] <moritz_> rakudo: my @a = 1..*; say @a[3]

[09:50] <p6eval> rakudo 6ab741: OUTPUT¬´4‚ê§¬ª

[09:50] <moritz_> sorear: if that works, why shouldn't it work with series?

[09:51] *** qiuhw left
[09:53] <sorear> 1 .. * is obviously infinite

[09:53] <sorear> 0, 2 ... * is not

[09:53] *** pmurias joined
[09:53] <sorear> = copies lists eagerly unless they can be proven infinite

[09:53] <sorear> hello pmurias

[09:58] * sorear out.

[10:03] <colomon> in fact, there are examples all over the web of @a = (something infinite).  Also turned up some in the test suite as well.

[10:04] <moritz_> I think it should rather be: copies lists eagerly, if proven finite

[10:08] <colomon> I think the spec should be modified so that with finite lists, you cannot tell whether it is eager or lazy.

[10:08] <colomon> but I reckon I probably don't understand some complication making that hard to do.

[10:09] *** PZt left
[10:10] *** PZt joined
[10:17] <moritz_> right; waiting for endless copying doesn't make happy users

[10:17] * moritz_ is a user

[10:20] *** skids joined
[10:27] <pmurias> is confused why aptitude wants to remove important packages instead of updating them

[10:27] <moritz_> pmurias: do you have backports in your package sources?

[10:28] <moritz_> or something else with different versions than the normal mirror?

[10:28] <pmurias> i updated from debian stable

[10:28] *** rv2733 joined
[10:28] *** Ross left
[10:29] <moritz_> maybe they are not important in testing anymore?

[10:29] <moritz_> like, renamed?

[10:30] <pmurias> moritz_: what aptitude does is "new version with important stuff conflicts with ancient binutils lets, lets remove the important stuff"

[10:31] <moritz_> pmurias: then aptitute purge binutils  might help

[10:31] <moritz_> or aptitute install binutils # if you want to upgrade instead

[10:31] <moritz_> but yes, it's weird

[10:32] <moritz_> though with a bit of luck, you can ask aptitute for alternative conflict resolutions

[10:34] <pmurias> maybe it considers binutils so crucial that avoids upgrading that at all cost 

[10:34] <moritz_> that would surprise me

[10:34] *** Mowah left
[10:35] <moritz_> it has Priority: optional

[10:39] *** pmurias left
[10:42] *** clintongormley joined
[10:56] *** unixdaemon joined
[11:02] *** PZt left
[11:07] *** wallberg joined
[11:09] *** dju joined
[11:11] *** agentzh left
[11:17] *** wallberg left
[11:17] *** wallberg joined
[11:34] *** envi^home joined
[11:35] <bbkr> interesting challenge today. this pick for hashes will be useful for Markov chains.

[11:38] * moritz_ waits for a submission

[11:40] <bbkr> in fact, I implemented P5 probability-based hash-pick in my diploma: http://bbkr.org/articles/Generation_of_articles.pdf :)

[11:43] <moritz_> it seems you did much more than that :-)

[12:01] <moritz_> rakudo: say 'a' ~~ / <?> /

[12:01] <p6eval> rakudo 6ab741: OUTPUT¬´‚ê§¬ª

[12:01] <moritz_> rakudo: say ?('a' ~~ / <?> /)

[12:01] <s1n> bbkr: you should have referenced SCIgen

[12:01] <p6eval> rakudo 6ab741: OUTPUT¬´0‚ê§¬ª

[12:03] *** bluescreen joined
[12:03] <s1n> bbkr: and the most common use of machine generation is actually for machine translation, which is highly useful

[12:03] *** bluescreen is now known as Guest58577

[12:09] *** Kodi joined
[12:09] <bbkr> s1n: you're right. I knew about SCIgen. but it is considered as a mockery of science, and I had many conservative people at my university, so I just skipped mentioning it :)

[12:09] <Kodi> moritz_: So I'm thinking supernovus may've initially been right in having Date and DateTime inherit from a common class or role. Temporal.pod lists a lot of date-calculation accessors on DateTime, like .weekday-of-month and .truncate(to => 'week'), that logically should be methods on Date too. A common ancestor of both Date and DateTime seems like a good place to put such methods, as well as .year, .month, and .day. Does that sound

[12:09] <Kodi> reasonable?

[12:09] <Kodi>  

[12:10] <moritz_> Kodi: reasonable; but please discuss with masak or mberends first, they are our Temporal gurus :-)

[12:10] <s1n> bbkr: it's not a mockery, it does many many good things with machine generation that are valuable to science

[12:11] <Kodi> moritz_: Okay.

[12:11] <s1n> bbkr: it was used to expose bogus conferences, which is good

[12:11] <moritz_> Kodi: once I'd like to stay as-is right now is that Date objects should remain immutable

[12:11] <moritz_> ie no public setters

[12:12] <Kodi> Why have Date immutable and DateTime mutable?

[12:12] <moritz_> Date immutable because it makes sense :-)

[12:12] <moritz_> and because I stole the API from Date::Simple in Perl 5

[12:13] <moritz_> and DateTime stole from Perl 5 DateTime

[12:13] <moritz_> and masak++ didn't feel like changing it to immutable objects

[12:13] <Kodi> It's true that in the case of DateTime, immutability would make time zones even harder than they are now.

[12:13] <moritz_> the simpler an object is, the easier it is to generate the right one from the start

[12:14] <moritz_> and Date is much simpler than DateTime

[12:14] <Kodi> Right.

[12:14] * moritz_ wonders if DateTime should simply inherit from Date

[12:14] <Kodi> I thought about that, too‚Ä¶

[12:14] <jnthn> moritz_: That sounds plausible-ish.

[12:14] <moritz_> is there anything that Date can that wouldn't make sense in DateTime?

[12:15] <Kodi> Yeah, .succ, .pred, and +, etc.

[12:15] <jnthn> Ah

[12:15] <Kodi> Unless we want to make those use seconds in DateTime.

[12:16] <Kodi> But with leap seconds, and Instant going by atomic seconds, that would get confusing fast.

[12:17] <moritz_> right

[12:17] <jnthn> Having .succ increment one unit in the parent and a different one in its subclass feels...horrible. :-)

[12:17] <Kodi> Agreed.

[12:17] <moritz_> breaks Liskov and all

[12:18] <jnthn> It means something that type-checks as Date doens't mean you can safely ++ it

[12:18] <jnthn> moritz_: Right.

[12:18] <moritz_> so, common ancestor or role sounds sane

[12:20] <Kodi> Well, while the immutability of Date makes sense on its own, as does the mutability of DateTime, I'm afraid people are going to be really confused by the difference. Maybe it's just a matter of taking pains to point it out in the relevant documentation.

[12:20] <moritz_> I'm not sure it needs special emphasis

[12:20] <moritz_> just enough usage examples

[12:21] <Kodi> By the way, is there a workaround for the can't-use-Setting-functions-in-a-role issue?

[12:22] <bbkr> rakudo: my %h =(a=>1,b=>2);  sub my_pick(%h) {my $t = ([+]%h.values).rand.ceiling; for %h { $t-=$_.value; return $_.key if $t <= 0}}; say my_pick(%h); # simplest hash pick :)

[12:22] <p6eval> rakudo 6ab741: OUTPUT¬´a‚ê§¬ª

[12:22] <dalek> rakudo: c8b6cf4 | moritz++ | src/core/Match.pm:

[12:22] <dalek> rakudo: Match.Bool should be True for zero-width matches. moritz--

[12:22] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c8b6cf46ef82bc514fc1e8ef39cad9747656dbe9

[12:22] <moritz_> bbkr: yes, but you know why it's not what I want, I assume :-)

[12:23] <bbkr> moritz_: sure. it's just proof of concept :)

[12:25] *** ruoso joined
[12:30] <bbkr> for 10K of picks: {"a" => 3274, "b" => 6726}

[12:31] *** JimmyZ joined
[12:33] *** Kodi left
[12:33] <moritz_> right

[12:34] <moritz_> doing m picks on n pairs (with :replace) should be doable in O(m + n * log(m))

[12:37] *** Guest58577 left
[12:37] *** Guest58577 joined
[12:38] *** sftp joined
[12:41] *** silug left
[12:46] *** tadzik left
[12:50] *** rgrau_ joined
[12:50] <bbkr> moritz_: in your "{a => 1, b => 2}.pick(*);" example sum of probabilities is not 1. what behavior is expected in remaining 1/3 of cases?

[12:51] <pugssvn> r31677 | moritz++ | [t/spec] test for inherited .perl method in user-defined classes; unfudge another such test 

[12:52] <moritz_> bbkr: it's an urn model... a => 1, b => 2 corresponds to having two a's and one b in an urn

[12:52] <moritz_> bbkr: and you randomly select one, and remove one

[12:52] <rgrau_> bbkr: the  sum of the probs is the sum of values

[12:53] <moritz_> oh, maybe I did something wrong with the probabilities

[12:53] *** KMasani joined
[12:54] *** KMasani left
[12:54] <bbkr> i understand urn model. but if I get different urns with probabilities 1/3, 1/6 and 1/6 then there's still 1/3 of cases missing somewhere :)

[12:55] <moritz_> right

[12:55] <moritz_> just a sec...

[12:56] <moritz_> all of them should be 1/3

[12:57] <moritz_> updating...

[12:59] <bbkr> ok. just for clarification - the fact that "b" has bigger value than "a" does NOT increase probability of occurence of <bba> list with "b" at the beginning?

[13:00] <moritz_> it has

[13:00] <moritz_> there are two lists that start with b, both with p = 1/3

[13:00] <moritz_> so the probability of a 'b' in the first place is 2/3

[13:01] <bbkr> ah, yes. but it's natural consequence of multiplying b more times. clear now, thanks.

[13:02] * moritz_ wonders if { a => 5, b => 2.5}.pick(2) should work

[13:02] <moritz_> it probably should

[13:02] <moritz_> hm

[13:02] <moritz_> or not

[13:03] <moritz_> I think .pick(1) should always work, unless all values are 0

[13:03] <moritz_> since for picking one item, it doesn't matter if you replace or not

[13:03] <bbkr> should it give the same result as { a => 10, b => 5}.pick(2)?

[13:03] *** wallberg left
[13:03] <moritz_> no

[13:04] <arnsholt> Why not?

[13:04] <moritz_> I think it's sane to require integer values for picking more than one element without replacing

[13:05] <moritz_> arnsholt: absolut numbers are important for picking without replacing

[13:06] <bbkr> what should {a => 0.1, b => 0.2}.pick(*, :replace) produce?

[13:06] <moritz_> arnsholt: {a => 10, b => 5}.pick(2) is different from {a => 20, b => 10}.pick(2)

[13:06] <arnsholt> Oh

[13:06] * arnsholt goes to read the spec again

[13:06] <moritz_> bbkr: the same as {a => 1, b => 2}.pick(*, replace)

[13:07] <moritz_> arnsholt: because if you draw a b in the first place, 4/14 != 9/29

[13:07] <arnsholt> Oh, right

[13:08] <arnsholt> I just found that bit in Bag.pick

[13:08] *** gbacon joined
[13:08] <moritz_> the problems without replacing and having fractionals is: after you pick an A from {A => 0.7, B => 0.3}, you have a negative probability. D'oh.

[13:09] <arnsholt> Indeed

[13:09] <arnsholt> I suppose fractional probs could be allowed, but only with :replace

[13:09] <moritz_> right

[13:10] <moritz_> with :replace, or if you only pick one

[13:10] <moritz_> (when you pick one, it doesn't matter if you :replace or not)

[13:10] <arnsholt> Yeah

[13:10] <moritz_> in the QM sense: it's ok to leave a system with negative probability behind, as long as you never look at it again :-)

[13:11] <arnsholt> Yeah, I was thinking of that (sort of) as well

[13:11] *** Ross joined
[13:11] <arnsholt> Except I didn't think of QM =)

[13:11] <moritz_> comes with the profession, I fear

[13:11] <arnsholt> Probably =)

[13:14] *** gbacon left
[13:15] <bbkr> {a => 0.1, b => 0.2}.pick(*, :replace) should produce <a a a>, <b b b>, <a b b>, <b a b>, <b b a>, <b a a>, <a b a>, <a a b>, all with 1/8 probabilities?

[13:16] <moritz_> no

[13:16] <moritz_> probability for b is twice as high as for a

[13:16] <moritz_> so <a a a> has (1/3)**3, <b b b> has (2/3)**3

[13:17] <moritz_> wait

[13:17] <moritz_> with *, :replace you get an infinite list

[13:17] <moritz_> like <a b b b a b b a a b b b a b ...

[13:17] <moritz_> with twice as many b as a, on average

[13:18] <moritz_> rakudo: say <a b b>.pick(*, :replace).[^20]

[13:18] <p6eval> rakudo c8b6cf: OUTPUT¬´bbbbbabbbaabbababaab‚ê§¬ª

[13:21] *** tadzik joined
[13:22] *** drbean joined
[13:23] *** macdaddy joined
[13:23] *** macdaddy is now known as Guest79408

[13:25] <bbkr> moritz_: thanks

[13:25] <colomon> ooo, when did [^20] start working?

[13:27] <wolverian> what's up with the second . there?

[13:27] <[Coke]> rakudo: say <a b b>.pick(*, :replace)[^20]

[13:27] <p6eval> rakudo c8b6cf: OUTPUT¬´bbbbbbbbbbbabaabbabb‚ê§¬ª

[13:28] <[Coke]> ... nothing, apparently. =-)

[13:28] <moritz_> colomon: shorlty after the last release, iirc

[13:28] <moritz_> wolverian: it just emphasizes that it's a method call

[13:29] <arnsholt> [Coke]: Did you have a list of things you wanted to be implemented in NQP?

[13:30] <moritz_> LTM!

[13:30] <JimmyZ> rakudo: say ('a'...'z', 'A'...'Z', 0...9).pick(*, :replace)[^32]

[13:30] <p6eval> rakudo c8b6cf: OUTPUT¬´No applicable candidates found to dispatch to for 'infix:<...>'. Available candidates are:‚ê§:(@lhs, @rhs)‚ê§:(Code $lhs, Any $rhs)‚ê§:(@lhs, Any $rhs)‚ê§:(Any $lhs, @rhs)‚ê§:(Any $lhs, Any $rhs)‚ê§‚ê§  in main program body at line 20:/tmp/2P3JTp24F_‚ê§¬ª

[13:30] <arnsholt> moritz_: You and me both. But that's a bit above my pay grade I think =)

[13:30] *** tylercurtis joined
[13:30] <moritz_> JimmyZ: putting (...) around each series should help

[13:31] <JimmyZ> rakudo: say ('a'..'z', 'A'..'Z', 0..9).pick(*, :replace)[^32] # this one works :)

[13:31] <p6eval> rakudo c8b6cf: OUTPUT¬´DvPBu4rxKtIDnmbLf9Nd6Pb04a6Q4Wtt‚ê§¬ª

[13:31] <moritz_> right, that too

[13:32] <JimmyZ> I was always confused with .. and ...

[13:38] <JimmyZ> putting (...) around each series should help? I couldn't understand it

[13:38] <JimmyZ> :(

[13:38] <moritz_> ... is the series operator

[13:39] <moritz_> rakudo: say (('a'...'z'), ('A'...'Z'),( 0...9)).pick(*, :replace)[^32]

[13:39] <p6eval> rakudo c8b6cf: OUTPUT¬´55743159852663193895978413861289‚ê§¬ª

[13:40] <JimmyZ> Is it right?

[13:41] <moritz_> no, the failure mode should be different

[13:41] <wolverian> looks like a C , operator there

[13:45] <tylercurtis> Does Rakudo have $?FILE yet?

[13:45] <tylercurtis> rakudo: say $?FILE;

[13:45] <moritz_> no, but this works as a workaround:

[13:45] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§Symbol '$?FILE' not predeclared in <anonymous> (/tmp/qXP1atJ3rP:20)‚ê§¬ª

[13:45] <moritz_> rakudo: say callframe().file

[13:45] <p6eval> rakudo c8b6cf: OUTPUT¬´/tmp/Kn7FPyiMO0‚ê§¬ª

[13:46] <moritz_> getinterp++

[13:46] <tylercurtis> thanks.

[13:47] *** Kodi joined
[13:48] *** JimmyZ left
[13:48] <PerlJam> rakudo: say callframe().^methods(:local).join(" ")

[13:48] <p6eval> rakudo c8b6cf: OUTPUT¬´my callframe file line‚ê§¬ª

[13:50] <PerlJam> What's callframe.callframe?  The current callframe's caller?

[13:50] <moritz_> PerlJam: you can go up and down the call chain

[13:50] <moritz_> see S02 iirc

[13:57] <moritz_> SEO project of the month: make the google search for "Perl 6 modules" find modules.perl6.org as the first hit

[13:57] <moritz_> currently a blog post of mine is the first hit; I'll insert a link to modules.perl6.org there

[13:58] <moritz_> if know of any sites that link to proto.perl6.org, please change them to modules.perl6.org if you can

[13:58] <moritz_> phenny: ask masak to please change the homepage link on http://github.com/masak/proto to modules.perl6.org

[13:58] <phenny> moritz_: I'll pass that on when masak is around.

[13:59] *** baest left
[14:00] *** takadonet joined
[14:01] *** masak joined
[14:01] <masak> oh hai, #perl6!

[14:01] <phenny> masak: 13:58Z <moritz_> ask masak to please change the homepage link on http://github.com/masak/proto to modules.perl6.org

[14:01] <masak> moritz_: fixing.

[14:01] <moritz_> oh hai masak. Timing :-)

[14:02] <masak> step by step, we're converging on a toolchain. :)

[14:02] * moritz_ wants modules.perl6.org the number 1 google hit for "perl 6 modules"

[14:02] * masak too

[14:02] <pugssvn> r31678 | Kodi++ | [S32/Temporal] DateTime.new(Numeric) -> DateTime.new(Int), since time no longer returns fractional seconds. 

[14:02] <moritz_> who owns http://www.mutteringmadman.com/perl6/links ?

[14:03] <Kodi> masak: May I chat with you about Temporal?

[14:03] <masak> Kodi: definitely.

[14:03] <masak> Kodi: I haven't looked at the commit, but might one argue that it'd be better to have a .from-something method rather than .new for Int?

[14:04] <masak> constructors benefit from having more precise names than .new :)

[14:04] <Kodi> Well, the bigger-picture issue now is: I'm thinking supernovus may've initially been right in having Date and DateTime inherit from a common class or role. Temporal.pod lists a lot of date-calculation accessors on DateTime, like .weekday-of-month and .truncate(to => 'week'), that logically should be methods on Date too. A common ancestor of both Date and DateTime seems like a good place to put such methods, as well as .year, .month, and

[14:04] <Kodi> .day. Does that sound reasonable?

[14:04] <[Coke]> arnsholt: my list of thing I want in nqp is on the "things people want in nqp" wiki page on github.

[14:04] <moritz_> http://www.perlfoundation.org/perl6/index.cgi?how_to_start_a_perl_6_module_project needs a major overhaul

[14:05] <[Coke]> http://wiki.github.com/perl6/nqp-rx/requests //Coke Wants

[14:05] <Kodi> Although, as moritz_ was saying, truncate shouldn't be accessible through Date because Date is immutable.

[14:05] <masak> Kodi: feel free to add the common role back, but please do it as a lexical role in a block, so it's hidden from view.

[14:05] <[Coke]> Kodi: can always have .truncate() return a new Date.

[14:06] <Kodi> [Coke]: Renamed "truncated", perhaps.

[14:06] *** sftp left
[14:06] *** ashleydev joined
[14:06] <Kodi> masak: Wouldn't a publicly acknowledged class make sense?

[14:07] <Kodi> No reason to hide it from the user that .weekday-of-month is really the same method in both cases, I think.

[14:07] <masak> Kodi: you mentioned having a common class or role. I think it makes sense to hide that, since what the user wants is always the Date or the DateTime.

[14:07] <bbkr> rakudo: say (1, 2, 3).pick(8)

[14:07] <p6eval> rakudo c8b6cf: OUTPUT¬´231‚ê§¬ª

[14:08] <[Coke]> arnsholt: ... why, what's up?

[14:08] <[Coke]> rakudo: say (1, 2, 3).pick(8, :replace)

[14:08] <p6eval> rakudo c8b6cf: OUTPUT¬´23211132‚ê§¬ª

[14:08] <Kodi> masak: Certainly it shouldn't be instantiable, which I guess is why I ought to use a role rather than a class.

[14:08] <arnsholt> [Coke]: If you could share the list, I might be able to pitch in =)

[14:08] <masak> Kodi: roles are instantiable. they auto-pun to classes.

[14:08] <Kodi> Oh.

[14:09] <[Coke]> arnsholt: did you get the url?

[14:09] <masak> Kodi: but I'm questioning whether it need be *visible*, which is one step further.

[14:09] <moritz_> http://wiki.github.com/perl6/nqp-rx/requests ?

[14:09] <arnsholt> [Coke]: Ah, right. I'm multi-tasking a bit at the moment, so I didn't catch that. Thanks!

[14:09] <[Coke]> the second of my two requests is more desirable.

[14:09] <PerlJam> masak: if common class/role is useful to other authors of Date-like classes/modules, it should be visible.

[14:10] <[Coke]> thanks in advance for any tuits.

[14:10] <Kodi> masak: Well, if it isn't visible, then how should Temporal.pod present the common methods? Something like, in the Date section, "There are also methods blah, blah, blah, which work just as for DateTime."?

[14:10] <PerlJam> masak: caveat lector, I haven't a clue what's in this common class/role

[14:10] <masak> PerlJam: I've been trying to avoid premature generalization with the Temporal modules.

[14:10] <masak> Kodi: the documentation is completely orthogonal to the code.

[14:11] <jnthn> [Coke]: "Ability to override vtables from NQP. (most PIR code in partcl-nqp stems from this restriction.)" - I need to fathom a v-table solution into the meta-model re-working I'll be doing, so can try and cover that one.

[14:11] <Kodi> masak: I know; I'm just thinking that a common ancestor makes sense not just from an implementation perspective but from a specification / documentation perspective. Maybe it's just me.

[14:12] <arnsholt> jnthn: Speaking of the new meta-model, might that make NQP's ~~ more useful as well?

[14:12] <bbkr> rakudo: say (1, 2, 3).pick(0.1) # curious...

[14:12] <p6eval> rakudo c8b6cf: OUTPUT¬´2‚ê§¬ª

[14:12] <PerlJam> Kodi: so you want to make the common thing visible so that it's documented separately and Date and DateTime reference that documentation?

[14:12] <jnthn> arnsholt: In what sense?

[14:12] <arnsholt> Currently ~~ only works with classes defined in PIR

[14:12] <masak> Kodi: sure, the specification can say "DateTime has methods .a, .b, .c and .d in common with Date, and they work the same way."

[14:13] <jnthn> arnsholt: Oh? :S

[14:13] <Kodi> PerlJam: Right. Although the separation may go no further than separate sections of Temporal.pod.

[14:13] <masak> Kodi: and for what it's worth, that sounds like what a role is for.

[14:13] <arnsholt> Smart-matching against parrot types fails, because they don't have an ACCEPTS method

[14:13] *** tadzik left
[14:13] <jnthn> Ah, that.

[14:13] <masak> Kodi: I'm just arguing for not making visible a CommonMethodsForDateAndDateTime role.

[14:13] <jnthn> Hmm

[14:13] <jnthn> arnsholt: I'll see what I can do.

[14:13] <jnthn> arnsholt: Thanks for another useful data point. :)

[14:14] <arnsholt> You're welcome

[14:14] <masak> this mst tweet made me think of Rakudo: http://twitter.com/shadowcat_mst/status/18484718237 :)

[14:14] *** plobsing joined
[14:14] <Kodi> masak: Fair 'nuff; at this point the only difference is whether Temporal.pod uses the name "Calendrical" or just points out that the two classes share some methods.

[14:14] <jnthn> masak: Indeed. :-)

[14:15] <arnsholt> I was curious because I was thinking of making the smart-match code more intelligent, but given your upcoming work on the meta-model I figured asking a bit would be prudent

[14:15] <masak> Kodi: to me, names like "Temporal" and "Calendrical" are signs that we're not being down-to-earth enough yet with the Temporal spec. no offense.

[14:16] <jnthn> .oO( Calendiabolical )

[14:16] <masak> the user just wants to know what day of the week it is one month from today.

[14:16] <masak> she doesn't want to learn about the Calendrical role in doing so.

[14:16] <jnthn> arnsholt: The problem is that PMCs don't really have the equivalent of "type objects" today

[14:16] <masak> when in doubt, simplify!

[14:17] <arnsholt> jnthn: Yeah, it's a bit fiddly =/

[14:17] <Kodi> masak: I see. I admit I'm a little too eager to make things, for lack of a better word, cute.

[14:17] <masak> Kodi: I appreciate your work on Temporal. it's good to have someone braining on it.

[14:17] <arnsholt> A first approximation might be to make sure the invocant knows how to ACCEPT() before invoking the method, and return false if can't do it

[14:18] <Kodi> :)

[14:18] <arnsholt> OTOH, that might cause tests that fail when you don't expect them to

[14:18] <jnthn> arnsholt: At the moment, I'm at the point of figuring out what I want a meta-model core for Rakudo to look like. One that factors in gradual typing, representation polymorphism, and so on. After that, it'll be working out how to map that onto Parrot (and probably other backends).

[14:19] <Kodi> masak: Implementation-wise, then, how can I make a lexical role that different files (Date.pm and DateTime.pm) can both access? And how can I get around the can't-use-setting-functions-in-a-role thing?

[14:19] <jnthn> And part of mapping it onto Parrot will be "so how do we interact with PMCs and Parrot Objects"

[14:19] <masak> rakudo: { my role A {}; class B does A {}; class C does A {} }

[14:19] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§Lexical 'A' not found‚ê§¬ª

[14:19] <masak> :(

[14:20] <masak> Kodi: that would be how. if you leave out the 'my', it'll work.

[14:20] <masak> jnthn: is that known?

[14:20] <jnthn> masak: And ticketed.

[14:20] <masak> good.

[14:21] <Kodi> Oh, wait, I forgot that all the .pms are actually concatenated together in the build process. I should be fine, then.

[14:22] <masak> Kodi: except that the opening and closing curlies would need to be in the same file. :/

[14:22] <Kodi> masak: So how do I get around that?

[14:22] <masak> Kodi: put things in one file? :)

[14:23] <Kodi> So be it.

[14:23] <masak> rakudo: our &_say = &say; role R { method foo() { _say "OH HAI" } }; R.new.foo

[14:23] <PerlJam> This is almost a glimpse into the future.  People will be asking similar questions of R*

[14:23] <p6eval> rakudo c8b6cf:  ( no output )

[14:23] <masak> locally, "OH HAI"

[14:24] <moritz_> http://www.perlfoundation.org/perl6/index.cgi?how_to_start_a_perl_6_module_project # a bit improved

[14:25] <masak> haven't backlogged yet -- have people seen this? http://blogs.perl.org/users/john_mcnamara/2010/07/yet-another-perl-6-logo.html

[14:25] <masak> I want to sound appreciative, but I'd describe it as Camelia with all the fun sucked out of it... :)

[14:26] <PerlJam> heh, I like the comments on that page

[14:26] <arnsholt> I agree it's a bit boring right now, but I think it might have some potential as a stylised logo

[14:28] <tylercurtis> Looks more like the logo for Perl 8.

[14:28] <masak> I believe TimToady was one of the first to toy with the 'Perl 666' allusion... :)

[14:28] <masak> in some Apocalypse or other.

[14:29] <PerlJam> Those aren't 8s, they are 4 sixes rotated and overlaid upon each other.

[14:29] <PerlJam> If only there were some color differentiation, we could tell that

[14:30] <masak> they're standing (or slanted) infinities.

[14:30] <arnsholt> Two rotated numbers 6 don't really make a number 8 though

[14:30] *** payload joined
[14:30] <PerlJam> arnsholt: you have to squitn.

[14:30] <masak> "Perl 6 -- infinitely infinite"

[14:31] <PerlJam> er, squint

[14:31] <arnsholt> Heh =)

[14:33] <PerlJam> the internet is falling!  I get "twitter is over capacity" and my gmail says "this webpage has a redirect loop"

[14:33] *** aindilis left
[14:33] *** uniejo left
[14:33] <masak> PerlJam: it must be those 8s :P

[14:33] <mathw> PerlJam: I wouldn't think the first is even remotely unusual or cause for concern...

[14:34] <mathw> Twitter is often over capacity

[14:34] <PerlJam> mathw: nah, it was just the juxtaposition in time of those two events

[14:35] <pugssvn> r31679 | moritz++ | [docs/feather] link to modules.perl6.org 

[14:35] * PerlJam wonders if pmichaud ever got with merlyn about an interview for FLOSS Weekly.

[14:35] <pugssvn> r31680 | Kodi++ | [S32/Temporal] Added to Date: "There are also C<week>, C<week-year>, C<week-number>, C<weekday-of-month>, and C<day-of-year> methods, which work just like their DateTime equivalents." 

[14:35] <Kodi> That oughta do it.

[14:36] <Kodi> Now to actually implement all of this.

[14:36] <moritz_> Kodi++

[14:38] <arnsholt> Which synopsis deals with macros?

[14:38] <masak> arnsholt: S06

[14:38] * tylercurtis has an urge to implement Path.

[14:38] <arnsholt> Thanks!

[14:39] *** sftp joined
[14:42] <moritz_> btw I've changed the underlying local directory of pugscode.org

[14:42] <moritz_> the old one didn't update

[14:42] <masak> moritz_++

[14:42] <moritz_> so if you see any feather-hosted pages that are now inaccessible, please tell me

[14:43] *** snarkyboojum joined
[14:44] *** cjk101010 left
[14:47] <alester> Gave a talk on Perl 5.10 and 5.12 last night to the Chicago Uniforum group.

[14:47] <alester> Talked about how a lot of the features in 5.10 are from Perl 6.

[14:47] <alester> There was some dismay that you wouldn't be able to run Perl 5 programs under Perl 6.

[14:47] <masak> the idea is that you would.

[14:48] <alester> Yes, but I don't see that happening.

[14:48] <moritz_> I see module loading happening

[14:48] <moritz_> but syntactic mixing is quite hard, almost impossible if you ask me

[14:48] <alester> That's basically what I pointed to.

[14:48] <TimToady> I have to finish STD::P5 for that to be feasible

[14:48] <alester> I pointed at http://perl101.org/arrays.html for an example.

[14:48] *** rgrau_ left
[14:48] <snarkyboojum> I'm devastated to learn that my filesystem on OS X won't let me have a file and folder with the same name but different case, and as such I can't checkout Niecza properly 

[14:49] *** silug joined
[14:49] <moritz_> some part in me understands these sentiments. Antother part of me says "if they want to run Perl 5 code, they should use perl5" :-)

[14:49] <snarkyboojum> boo HFS+

[14:49] <alester> snarkyboojum: HFS+ has always had that annoyance for us.  My main work project has a .t file that verifies that no files have the same name /i

[14:50] <masak> snarkyboojum: that's why the first thing you do with a new Mac is to reformat the hard drive. :/

[14:50] <snarkyboojum> masak: :(

[14:50] <alester> What fs do you have on your Mac then masak?

[14:50] <masak> dunno. some case-sensitive one.

[14:50] <alester> So you haven't actually done it.

[14:50] *** tadzik joined
[14:51] <masak> yes, that's why it's case sensitive.

[14:51] <snarkyboojum> HFSX it seems supports case sensitivity or something

[14:51] <moritz_> the question is: do the programs still run on a case senstive partition?

[14:51] <snarkyboojum> typos :|, but you get the drift

[14:53] <masak> what catches a 'return' exception? caller or callee?

[14:54] <moritz_> callee

[14:55] <moritz_> routines catch their own "return" exceptions

[14:55] <moritz_> whereas blocks only calls their "leave" exceptions

[14:55] <masak> thought so.

[14:55] <moritz_> it wouldn't make sense to lay that burden onto the caller

[14:55] <masak> no, it wouldn't.

[14:55] <masak> that occurred to me just the other day. just checking. :)

[14:56] *** rgrau` joined
[14:56] <masak> so the actual handing-back of control (and the return value) from callee to caller is not done with exceptions at all, then?

[14:56] <moritz_> no

[14:56] *** plobsing left
[14:56] <masak> because intuitively, that feels like the bit that could be transmitted through a control exception.

[14:57] <moritz_> note that falling-off-the-end-of-a-routine returns don't need to be handled with exceptions

[14:57] <masak> nod.

[14:58] <snarkyboojum> I'm just going to have to look at Niecza, somewhat wistfully, from a distance then

[14:58] <snarkyboojum> ho hum

[14:58] <masak> so, in short, the routine is notified that a return has taken place in one of the two possible ways, and it makes sure execution finds its way back to caller.

[14:58] <moritz_> though of course you can implement both control flow and exceptions with continuations

[14:59] <masak> snarkyboojum: there's always Yapsi :)

[14:59] <masak> snarkyboojum: have you seen my new runtime?

[14:59] <snarkyboojum> masak: Yapsi is beautiful ;)

[14:59] <snarkyboojum> heh

[14:59] <moritz_> snarkyboojum: or just ping sorear, I'm sure he'll try to fix it for you

[14:59] <snarkyboojum> masak: not in any detail re new runtime

[14:59] <masak> snarkyboojum: http://gist.github.com/471521

[14:59] <snarkyboojum> masak: noticed a flurry of activity recently though

[15:00] <masak> snarkyboojum: there's no code there, just the new SIC syntax, and the output from the new runtime.

[15:00] <masak> IDSTR I ever pushed the new runtime code. it's not done yet.

[15:00] <snarkyboojum> masak: ah ok - I did see your gists and discussion on IRC though :)

[15:00] <tylercurtis> masak: with the new SIC syntax, can I count on all lexvar declarations to be at the top of the block?

[15:00] <snarkyboojum> masak: will have a better look'see

[15:01] <masak> tylercurtis: I actually considered letting them be scattered throughout. but I think I'll end up putting all of them at the top.

[15:02] <masak> it's not much harder to generate it that way, and it's easier to read.

[15:03] *** timbunce left
[15:03] <moritz_> rakudo: eval  'say $x'; my $x; INIT { $x = 5}

[15:03] <p6eval> rakudo c8b6cf: OUTPUT¬´Null PMC access in getprop()‚ê§  in '&infix:<=>' at line 1‚ê§  in main program body at line 20:/tmp/zxlvGhIUTT‚ê§¬ª

[15:03] <moritz_> anyway, that should work

[15:03] <moritz_> notionally Perl 6 only stores lexikals per block

[15:04] <moritz_> and only at parse time is it check that variables are actually declared before they are used

[15:04] <masak> I think that's reported.

[15:04] <tylercurtis> #ruby isn't very helpful. Is anyone here who knows how to speak Ruby enough to confirm that "#@graph.render(;width => 800, :as => 'JPG', :to => outfile('test_graph.jpg'))" is a comment of if it actually does something?

[15:05] <tylercurtis> moritz_: Scruffy's test suite is not very impressive.

[15:05] <masak> tylercurtis: seems to be a comment to me.

[15:05] <moritz_> tylercurtis: yes, ruby uses # for comments

[15:05] <moritz_> tylercurtis: I know. (And btw we won't implement any targets except SVG for now, because we have no rendering library)

[15:05] <arnsholt> tylercurtis: I'm almost entirely certain it's a comment

[15:05] <moritz_> unless we shell out to inkscape...

[15:06] <moritz_> rakudo: sub f() { eval 'say $x' }; my $x =5; f()

[15:06] <p6eval> rakudo c8b6cf:  ( no output )

[15:06] <tylercurtis> I just wanted to be sure it wasn't something like Perl 5 $#foo

[15:06] *** ashleydev left
[15:06] <moritz_> prints 5 locally

[15:06] <moritz_> that was the example I was after, actually

[15:07] <snarkyboojum> masak: how does severally nested block indexed lookups work? [-1, 0], [-2, 0], [-3, 0] etc?

[15:07] *** kbenson joined
[15:07] <masak> snarkyboojum: yes. but the 0 depends on the position of the lexical in that block.

[15:07] *** sftp left
[15:08] <snarkyboojum> masak: yep - assuming first lexical in those examples

[15:08] *** timbunce joined
[15:08] <masak> then, yes.

[15:08] <snarkyboojum> masak: cool

[15:08] <masak> when I wrote the regex for that SIC syntax, it became clear that ditching the minus sign would make things simpler. I still like the minus sign there, though.

[15:09] <snarkyboojum> masak: looks so much better with the environment header etc

[15:09] *** rgrau` left
[15:09] <tylercurtis> snarkyboojum: with or without the environment header?

[15:10] <snarkyboojum> masak: whoops - that was supposed to be *without*

[15:10] <snarkyboojum> :)

[15:10] <snarkyboojum> tylercurtis: yep - without!

[15:10] <masak> snarkyboojum: aye. the environment header was there mainly so that we would be able to support BEGIN etc. but I believe we will be able to do that some other way.

[15:11] *** sftp joined
[15:11] * masak is caught up backlogging

[15:11] <masak> ...and my battery is running out. :)

[15:11] <TimToady> you backlogged too hard

[15:12] <masak> or too slowly, more like :)

[15:12] <masak> o/

[15:12] *** masak left
[15:12] * moritz_ logs forward

[15:12] <moritz_> bll

[15:23] *** patspam joined
[15:23] *** shade_ joined
[15:24] <tylercurtis> rakudo: role Foo { }; my Str $r .= new() but Foo;

[15:24] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§ResizablePMCArray: Can't shift from an empty array!‚ê§¬ª

[15:24] <tylercurtis> rakudo: role Foo { }; my Str $r .= new("foo") but Foo;

[15:24] <p6eval> rakudo c8b6cf: OUTPUT¬´Null PMC access in get_repr()‚ê§  in main program body at line 20:/tmp/eMMy8i9HHz‚ê§¬ª

[15:24] <tylercurtis> rakudo: role Foo { }; my class Bar { }; my Bar $b .= new but Foo;

[15:24] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§ResizablePMCArray: Can't shift from an empty array!‚ê§¬ª

[15:25] <tylercurtis> rakudo: role Foo { }; my class Bar { }; my Bar $b .= new() but Foo;

[15:25] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§ResizablePMCArray: Can't shift from an empty array!‚ê§¬ª

[15:25] <tylercurtis> rakudo: role Foo { }; my class Bar { }; my Bar $b .= new(); $b = $b but Foo;

[15:25] <p6eval> rakudo c8b6cf: OUTPUT¬´too few positional arguments: 1 passed, 2 (or more) expected‚ê§  in main program body at line 1‚ê§¬ª

[15:26] <tylercurtis> rakudo: role Foo { }; my class Bar { }; my Bar $b .= new; say "new"; $b = $b but Foo; say "but";

[15:26] <p6eval> rakudo c8b6cf: OUTPUT¬´too few positional arguments: 1 passed, 2 (or more) expected‚ê§  in main program body at line 1‚ê§¬ª

[15:26] <tylercurtis> rakudo: role Foo { }; class Bar { }; my Bar $b .= new; say "new"; $b = $b but Foo; say "but";

[15:26] <p6eval> rakudo c8b6cf: OUTPUT¬´new‚ê§¬ª

[15:27] <tylercurtis> rakudo: role Foo { }; class Bar { }; my Bar $b .= new() but Foo; say "new";

[15:27] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§ResizablePMCArray: Can't shift from an empty array!‚ê§¬ª

[15:28] *** shade_ left
[15:31] *** Kodi left
[15:32] *** mberends left
[15:47] *** takadonet left
[15:47] *** isBEKaml joined
[15:56] <TimToady> std: multi foo ($a) | ($b) { $a, $b, $c }

[15:56] <p6eval> std 31680: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $c is not predeclared at /tmp/DaVFqPvklv line 1:‚ê§------> [32mmulti foo ($a) | ($b) { $a, $b, $c[33m‚èè[31m }[0m‚ê§Check failed‚ê§FAILED 00:01 116m‚ê§¬ª

[15:57] <TimToady> std: multi foo ($a) | ($b) { $a }

[15:57] <p6eval> std 31680: OUTPUT¬´Potential difficulties:‚ê§  $b is declared but not used at /tmp/eWJjm9BvXI line 1:‚ê§------> [32mmulti foo ($a) | ([33m‚èè[31m$b) { $a }[0m‚ê§ok 00:01 111m‚ê§¬ª

[15:57] <jnthn> Cute

[15:57] <TimToady> std: multi foo ($a) | ($b) { $a, $b }

[15:57] <p6eval> std 31680: OUTPUT¬´ok 00:01 113m‚ê§¬ª

[15:57] <moritz_> tylercurtis: note that this probably parses as .= (new() but Foo) and spits out nonesense

[15:58] <moritz_> the first version, that is

[15:58] <tylercurtis> moritz_: Yeah. That's what I expected.

[15:58] *** snarkyboojum left
[15:59] <cxreg> your mom is an infinite iterator

[15:59] * cxreg hopes mberends comes back today

[16:02] <cxreg> phenny: tell mberends that zavolaj appears broken :(

[16:02] <phenny> cxreg: I'll pass that on when mberends is around.

[16:04] *** justatheory joined
[16:24] *** timbunce left
[16:26] <jnthn> cxreg: that's 'cus she's lazy...

[16:26] <jnthn> cxreg: HOw is Zavolaj borken?

[16:26] * jnthn knows a little about Zavolaj too

[16:27] *** Sarten-X left
[16:30] *** timbunce joined
[16:30] *** cdarroch joined
[16:30] *** cdarroch left
[16:30] *** cdarroch joined
[16:31] *** tedv joined
[16:37] *** silug left
[16:38] <isBEKaml> rakudo: enum Foo<a b c>; my @a = Foo.words; for @a -> $a { .WHAT.perl.say }

[16:38] <p6eval> rakudo c8b6cf: OUTPUT¬´Any‚ê§Any‚ê§Any‚ê§Any‚ê§Any‚ê§Any‚ê§¬ª

[16:38] <isBEKaml> Any?? :O

[16:38] <isBEKaml> rakudo: enum Foo<a b c>; my @a = Foo.kv; for @a -> $a { .WHAT.perl.say }

[16:38] *** timbunce left
[16:38] <p6eval> rakudo c8b6cf: OUTPUT¬´Any‚ê§Any‚ê§Any‚ê§Any‚ê§Any‚ê§Any‚ê§¬ª

[16:40] <isBEKaml> rakudo: enum Foo<a b c>; my @a = Foo.kv; for @a -> $a { .say }

[16:40] <p6eval> rakudo c8b6cf: OUTPUT¬´Any()‚ê§Any()‚ê§Any()‚ê§Any()‚ê§Any()‚ê§Any()‚ê§¬ª

[16:41] <isBEKaml> heh... 

[16:42] <isBEKaml> rakudo: enum Foo<a b c>; my @a = Foo.kv; for @a { .say }

[16:42] <p6eval> rakudo c8b6cf: OUTPUT¬´c‚ê§2‚ê§a‚ê§0‚ê§b‚ê§1‚ê§¬ª

[16:42] <isBEKaml> rakudo: enum Foo<a b c>; my @a = Foo.kv; for @a { .WHAT.say }

[16:42] <p6eval> rakudo c8b6cf: OUTPUT¬´Str()‚ê§Int()‚ê§Str()‚ê§Int()‚ê§Str()‚ê§Int()‚ê§¬ª

[16:43] <TimToady> std: enum Foo<a b c>; my @a = Foo.words; for @a -> $a { .WHAT.perl.say }

[16:43] <p6eval> std 31680: OUTPUT¬´Potential difficulties:‚ê§  $a is declared but not used at /tmp/W3QeM4ViAT line 1:‚ê§------> [32moo<a b c>; my @a = Foo.words; for @a -> [33m‚èè[31m$a { .WHAT.perl.say }[0m‚ê§ok 00:01 117m‚ê§¬ª

[16:43] <TimToady> :)

[16:43] <isBEKaml> :)

[16:44] <isBEKaml> Rakudo should point that one out. TimToady, did you just add it ? 

[16:44] <TimToady> yes

[16:44] <isBEKaml> great! TimToady++

[16:44] <jnthn> "Steal this warning."

[16:45] <TimToady> mind you, I should have been doing any/all of several other things instead...

[16:47] <isBEKaml> "Warn this Stealer!"

[16:50] <cxreg> jnthn: my Pg.pm6 stopped working, and i confirmed that the postgresqlclient.p6 included in zavolaj breaks the same way

[16:50] <cxreg> jnthn: i forgot that it was your project :)

[16:50] <jnthn> cxreg: Stopped working as in...errors? Segfaults? Silent failure?

[16:51] <cxreg> the nci calls return Failure

[16:51] <cxreg> instead of a valid pointer

[16:51] <jnthn> :/

[16:51] <moritz_> maybe missing descalarreffing after the container changes?

[16:51] * moritz_ makes wild guesses

[16:52] <jnthn> cxreg: Can look into it later tonight - I suspect it may be to do with the closure fixes recently

[16:52] <jnthn> Since the code had a work-around for those.

[16:52] <cxreg> ok thanks

[16:52] <TimToady> std: sub foo ($x) { :$x }  # false positive

[16:52] <p6eval> std 31680: OUTPUT¬´Potential difficulties:‚ê§  $x is declared but not used at /tmp/203DdEdibH line 1:‚ê§------> [32msub foo ([33m‚èè[31m$x) { :$x }  # false positive[0m‚ê§ok 00:01 110m‚ê§¬ª

[16:52] <colomon> rakudo: say (10 xx *).munch(10).perl

[16:52] <p6eval> rakudo c8b6cf: OUTPUT¬´(10, 10, 10, 10, 10, 10, 10, 10, 10, 10)‚ê§¬ª

[16:53] <colomon> rakudo: say $lhs := 10 xx *; say $lhs.munch(10).perl

[16:53] <TimToady> std: :$x  # the related false negative

[16:53] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§Symbol '$lhs' not predeclared in <anonymous> (/tmp/1mFPLAqruA:20)‚ê§¬ª

[16:53] <p6eval> std 31680: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[16:53] <colomon> rakudo: my $lhs := 10 xx *; say $lhs.munch(10).perl

[16:53] <p6eval> rakudo c8b6cf: OUTPUT¬´(10, 10, 10, 10, 10, 10, 10, 10, 10, 10)‚ê§¬ª

[16:53] *** FardadJalili joined
[16:54] <colomon> rakudo: my $lhs := (3, 10) xx *; say $lhs.munch(10).perl

[16:54] <p6eval> rakudo c8b6cf: OUTPUT¬´((3, 10), (3, 10), (3, 10), (3, 10), (3, 10), (3, 10), (3, 10), (3, 10), (3, 10), (3, 10))‚ê§¬ª

[16:54] <colomon> rakudo: my $lhs := ((3, 10) xx *).flat; say $lhs.munch(10).perl

[16:54] <p6eval> rakudo c8b6cf: OUTPUT¬´(3, 10, 3, 10, 3, 10, 3, 10, 3, 10)‚ê§¬ª

[17:00] *** dakkar left
[17:05] *** mberends joined
[17:09] *** thebird left
[17:10] <pugssvn> r31681 | lwall++ | [CursorBase.pmc] fake out __WARN__ on Deep recursion 

[17:11] <pugssvn> r31682 | lwall++ | [STD] :$x should .check_variable('$x') 

[17:13] *** envi^home left
[17:18] *** rgrau` joined
[17:27] <moritz_> wow, we have a submission for the Hash.pick challenge

[17:28] <colomon> \o/

[17:28] <moritz_> it contains a bit of duplicate code, but it seems to work quite nicely otherwise

[17:28] *** rgrau` left
[17:29] <moritz_> found a small buglet involved zero-valued pairs, but it's an easy fix

[17:30] * isBEKaml hasn't tried any of the weekly challenges yet.. :/

[17:31] <isBEKaml> moritz_: the small buglet was smaller than a buglet? :P

[17:32] * isBEKaml wonders if buglets ever reproduce like piglets... 

[17:33] <mberends> please re-spec/move Hash.pick out into a module. It's all very nice and so on. It is far from essential core material. In the perl6 executable it will contribute more to bloat and slowness than it will to a useful Perl 6 implementation.

[17:33] <phenny> mberends: 16:02Z <cxreg> tell mberends that zavolaj appears broken :(

[17:34] <mberends> cxreg: will check zavolaj soon, must be afk for about 20 mins :)

[17:34] <tylercurtis> isBEKaml: Do piglets reproduce?

[17:35] <cxreg> mberends: cool.  jnthn is going to look at it later tonight, he thinks closure changes might have broken it

[17:35] <isBEKaml> tylercurtis: pigs do. piglets are just baby pigs. :D

[17:36] <tylercurtis> isBEKaml: exactly my point. :)

[17:36] <TimToady> pigs are just big piglets :)

[17:37] <moritz_> mberends: so far Perl 6 has gone the "fat core" route. I can argue but ways, but I don't want to out-spec things that TimToady++ put in

[17:37] <TimToady> I'd rather have a mechanism for loading the actual code on demand

[17:38] <TimToady> then we can decide which parts of core are loaded eagerly vs lazily

[17:38] <TimToady> or even tweak it with knowledge of history

[17:39] <TimToady> we could have an 'is bloat' trait  ;)

[17:40] <pugssvn> r31683 | colomon++ | [t/spec] Overhaul of the trig tests.  generate-tests.pl still desperately needs some refactoring, but the generated 

[17:40] <pugssvn> r31683 | tests are now shorter and more thorough than they were previously.

[17:40] *** justatheory left
[17:41] *** Phar joined
[17:42] *** lue joined
[17:43] <lue> wello there o/

[17:44] * moritz_ git svn-rebase rebase's the spectests

[17:45] <moritz_> colomon: one small suggestions: 1.234354.Num to 1.234354e0, which is also a Num, but easier to coerce at compile time

[17:46] <moritz_> +    multi method perl() {

[17:46] <moritz_> +        "AngleAndResult.new($.angle_in_degrees, $.result)";

[17:46] <moritz_> +    }

[17:46] <moritz_> shouldn't be necessary anymore

[17:46] <colomon> ooooooo, Mu.perl is now working?

[17:46] <moritz_> I've patched Mu.perl yesterday to include attributes

[17:47] *** felliott joined
[17:47] <moritz_> not descending-into-parent-classes whoo-hoo-attributes, but the ones that $self.^attributes reports are there

[17:47] <jnthn> rakudo: class Beer { has $!name; }; Beer.new(name => 'Starobrno').perl.say # not seen this yet :-)

[17:47] <p6eval> rakudo c8b6cf: OUTPUT¬´Beer.new(name => "Starobrno")‚ê§¬ª

[17:47] <jnthn> \o/

[17:47] <jnthn> moritz_++

[17:48] <moritz_> it was actually quite simple. jnthn++ did all the hard work with .^attributes, and pmichaud++ with pir:: syntax :-)

[17:49] <jnthn> :-)

[17:49] *** pmurias joined
[17:49] <pmurias> ruoso: hi

[17:49] <colomon> moritz_: as for 1.234e0 versus 1.234.Num, I went with the more paranoid approach rather than trusting the Perl 6 grammar being used to get it right.  (since historically almost every perl 6 implementation has gotten the current spec for that wrong in some way....)

[17:50] <moritz_> ok, good point

[17:50] <pmurias> ruoso: is it ok if i remove the locking from smop rather then keeping in a cripled ifdef'ed form

[17:51] *** Sarten-X joined
[17:52] <PerlJam> sweet! moritz_++  I was annoyed at the old behavior earlier today and now you've fixed it!

[17:52] * PerlJam builds a new rakudo

[17:52] *** isBEKaml_ joined
[17:52] * moritz_ bows

[17:53] *** jaldhar left
[17:53] <lue> Oh wait, was the problem seeing a bunch of {‚Ä¶}'s with .perl ?

[17:53] <moritz_> no

[17:53] <moritz_> that's still the case for code objects

[17:54] *** Phar left
[17:54] <moritz_> the problem was that class A { ... }; A.new.perl would return 'A.new()', even if class A had attributes

[17:54] <PerlJam> and that's Not Very Helpful

[17:54] *** tylercurtis left
[17:54] <moritz_> right :-)

[17:54] *** supernovus joined
[17:55] <lue> ah. moritz_++

[17:55] *** ash_ joined
[17:55] <PerlJam> I was trying to figure something out earlier today and kept doing  $thingy.perl  # crap, that doesn't tell me *anything* when $thingy is an object

[17:56] <moritz_> the type :-)

[17:56] <ruoso> pmurias, yes... you can remove it... 

[17:56] <ruoso> it won't be in the final version anyway

[17:56] <PerlJam> okay ... it didn't tell me anything I didn't already know.

[17:57] *** supernovus left
[17:58] <pmurias> ruoso: other thing, do you think my reasoning why the exception test is incorrect is correct?

[17:58] *** PZt joined
[17:59] *** justatheory joined
[17:59] <ruoso> pmurias, hmm... you mean the handled?

[18:00] <pmurias> yes

[18:00] <isBEKaml_> moritz_: wait, Hash.pick isn't already in rakudo? 

[18:00] <isBEKaml_> moritz_: or is it lacking in a proper implementation? 

[18:00] <moritz_> isBEKaml_: no, only List.pick

[18:01] <moritz_> or maybe Any.pick, so it picks up the hash pairs

[18:01] <moritz_> but not weighted as it should

[18:01] <isBEKaml_> moritz_: uhh, I'm seeing it with an hash. or Hash tags along with list.pick ?

[18:01] <sorear> good * #perl6

[18:02] <moritz_> rakudo: say {a => 1, b => 5, c => 0}.pick(20, :replace)

[18:02] <lue> hello sorear o/

[18:02] <sorear> TimToady: What does saving memory images have to do with pad cloning?  I'm confused

[18:02] <p6eval> rakudo c8b6cf: OUTPUT¬´b  5c      0c      0a      1b      5a      1c      0b      5a      1a      1c      0c      0c      0c      0a      1a      1c      0a      1a      1b      5‚ê§¬ª

[18:02] <moritz_> isBEKaml_: it currently acts like %hash.pairs.pick

[18:02] <pmurias> sorear: hi

[18:03] <moritz_> isBEKaml_: it is supposed to take the hash values as weights, and pick accordingly

[18:03] *** hercynium joined
[18:03] <isBEKaml_> moritz_: I see. Hash.keys.pick based on the weighted keys' values. 

[18:05] <PerlJam> isBEKaml_: I also have a mildly irrational desire to see pick have the ability to use a user-defined function rather than rand

[18:05] <isBEKaml_> PerlJam: I wasn't thinking rand. pick of picks! :)

[18:05] <moritz_> PerlJam: don't the weights fill in that gap?

[18:06] <moritz_> ie if you want a different distribution?

[18:06] <colomon> PerlJam: I don't reckon that's irrational at all.

[18:06] <PerlJam> moritz_: thus my irrationality :)

[18:06] <moritz_> in the long run I think we'll have a $*PRNG variable or so that stores a random number generator, which callers can override

[18:07] <colomon> +1

[18:07] <isBEKaml_> +1

[18:07] <pmichaud> good morning, #perl6

[18:07] <lue> good morn, pmichaud o/

[18:07] <pmichaud> moritz_: ping

[18:07] <PerlJam> good morning Pm. How's the weather where you are?  :)

[18:07] <moritz_> it irks me that both in Perl 5 and C you have a built-in PRNG with hidden state that prevents you having two PRNGs

[18:07] <moritz_> pmichaud: pong

[18:07] <pmichaud> PerlJam: sunny. 80 degF

[18:08] <pmichaud> moritz_: did you happen to notice the scheduled for yapc::eu yet?  

[18:08] <pmichaud> *schedule

[18:08] <moritz_> pmichaud: yes. We can't attend each other's talks, and jnthn and masak are in parallel

[18:08] <pmichaud> I'm going to contact the organizers to see about moving my nqp talk.

[18:08] <PerlJam> and thus the need for video!  :)

[18:08] <jnthn> It's kinda odd that so much of the Perl 6 material has been put in parallel.

[18:08] <moritz_> I'm a bit constrained because I have to leave on Friday afternoon

[18:09] <pmichaud> and masak++ apparently has to be in two places at once.

[18:09] *** christine left
[18:09] <moritz_> pmichaud: either they want to force people to attend some Perl 6 talks (by providing only Perl 6 talks at that time), or prevent people from only attending Perl 6 talks. Or both :-)

[18:09] <moritz_> or it's just coincidence

[18:10] *** literal joined
[18:10] <isBEKaml_> moritz_: "they" ? I tend to think society isn't as helpful as it should be. ;)

[18:10] <moritz_> it's time to become serious about masak.clone :-)

[18:10] <isBEKaml_> moritz_: masakkit!

[18:11] <lue> moritz_: silly, it's    git clone masak

[18:11] <moritz_> isBEKaml_: did you mean: mmaassaakk?

[18:11] <isBEKaml_> moritz_: erm, rt.perl.org? 

[18:12] <isBEKaml_> and, assign it to masak who will assign it to tardis (so it goes... ;)

[18:12] <lue> .oO([BUG] Rakudo's masak-cloning is NYI)

[18:14] <pmurias> jnthn: one odd things is that masak is doing 2 Perl 6 talks in parallel

[18:14] <pmurias> * thing

[18:15] <pmichaud> I just notified the yapc::eu organizers about moving my talk, and the masak-parallel universe talks.

[18:15] <isBEKaml_> .oO(today's fortune says: "Avoid any wine with a childproof cap.") 

[18:15] <lue> .oO( I expect nothing less from Europeans :) )

[18:15] <jnthn> pmurias: oh!

[18:15] <jnthn> pmurias: I'm sure it wasn't that way yesterday

[18:16] *** masak joined
[18:16] <masak> two places at once?

[18:16] <lue> hai masak o/

[18:16] <isBEKaml_> ohhaimasak!

[18:16] <moritz_> masak: yapc::eu schedule

[18:16] <masak> that's like, my maximum.

[18:16] * masak checks

[18:16] <moritz_> masak: it's my supremum :-)

[18:16] <jnthn> oh heh

[18:16] <masak> :)

[18:16] <jnthn> schedule fail!

[18:17] <lue> masak: lucky for you, you've built a tardis :)

[18:17] <masak> hey, look at that.

[18:17] <pmichaud> I think that if they cannot move my nqp talk, I'm likely to cancel it.  I think attending the other perl 6 talks is more important (for me and my audience) than having an nqp talk.  :-)

[18:17] <isBEKaml_> two things at once leads to my inflection point. :|

[18:17] <masak> they moved my talk.

[18:17] <masak> time to email them, I think.

[18:17] <moritz_> masak: pmichaud++ already did

[18:18] <masak> oh, good.

[18:18] *** sftp left
[18:18] <masak> did he also rant about jnthn and me being placed in parallel?

[18:18] *** sftp joined
[18:18] <pmichaud> wouldn't hurt to have a separate email inquiry, in case mine went to the wrong place or otherwise gets lost.

[18:18] <jnthn> *nod*

[18:18] *** literal left
[18:18] *** christine joined
[18:18] * masak separately inquires

[18:19] <masak> I almost feel entitled to send them two emails :P

[18:19] <moritz_> lol

[18:19] <pmichaud> I didn't rant about parallel between masak and jnthn, because I was separately asking for resolution on parallel between me, moritz, and mberends :-)

[18:19] <masak> oh wow.

[18:19] <masak> it's a conspiracy!

[18:19] <lue> It's an evil plot to decimate all that is the sixth of something!

[18:19] <masak> either that, or it's a good sign that they are having difficulty straightening out all the p6 talks.

[18:19] <lue> .oO(Next Time, on.... *The Perl Foundation*)

[18:20] <moritz_> it's O($number_of_talks**2) complexity

[18:20] <jnthn> masak: Maybe if the Perl 6 talks were on a Perl 6 track, rather that spread amongst core and languages, it'd help too. :-)

[18:20] <masak> jnthn: you know, I'll write that too :P

[18:21] *** literal joined
[18:21] <moritz_> I mean, I find it very laudable that they don't handle Perl 6 separately

[18:21] <moritz_> it means they consider it as much Perl as Perl 5

[18:21] <masak> moritz_: or they just don't care.

[18:21] <masak> moritz_: or there are internal disagreements about its status.

[18:22] <masak> moritz_: my talks got sorted under "Programming Languages"

[18:22] <Juerd> Programming languages at a yapc?

[18:22] <masak> moritz_: pmichaud++'s got sorted under "Core Perl"

[18:22] <masak> it's the traces of either a madman, a genius, or a committee :P

[18:22] <lue> .oO[ gcc -Wno_warnings -j3 -O!fun -o p6talksschedule.o p6talksschedule.c ]

[18:23] <pmichaud> at some point I think we have to accept that some day Perl 6 won't need a "Perl 6" track.  :-)

[18:23] <moritz_> masak: well, nqp *is* at the core of a Perl 6 implementation :-)

[18:23] <masak> moritz_: and Perl 6 *is* a programming language...

[18:23] <pmichaud> In this case I think it best not to assume malice where other explanations suffice.  :-)

[18:24] <pmichaud> and scheduling is always a pain no matter how one looks at it

[18:24] <pmichaud> time to head for breakfast :)

[18:24] <pmichaud> bbiaw

[18:24] <moritz_> yeah, O(n**2) plus an arbitrary number of additional constraints

[18:27] <pugssvn> r31684 | lwall++ | [STD] add rudimentary capability of suppressing compiler warnings with #OK text 

[18:30] <masak> mail's away.

[18:31] <isBEKaml_> atleast they cared enough to force ppl to mail them! :)

[18:31] <isBEKaml_> (looking at the schedule) nice timing. Perl6 appertizers b4 lunch!

[18:32] <masak> interesting Ruby-esque chdir code from @uasi++ on Twitter: http://gist.github.com/475696

[18:32] <masak> isBEKaml_: :)

[18:32] *** Ross left
[18:33] <masak> isBEKaml_: I don't remember if I wrote it or just thought of leaving it as comments to the organizers: "talk will contain some images of food -- perhaps best to schedule it right before lunch" :)

[18:34] <isBEKaml_> lol

[18:35] <isBEKaml_> masak: they seem to be extraordinarily good at visual extrapolation. Multiply that by a committee! :)

[18:36] <isBEKaml_> masak: the tags must have set them off. :) "food  idioms  metaphor  nom  patterns  perl  salivate  tour  yummy"

[18:36] <pugssvn> r31685 | colomon++ | [t/spec] Remove unneeded .perl method, moritz++. 

[18:37] <ruoso> pmurias, I think it's worth getting a word from TimToady about it... In my head, setting handled to true is suficcient to stop the exception...

[18:39] <ruoso> http://svn.pugscode.org/pugs/v6/Mildew-Setting-SMOP/t/p6/basic/control_exception.t

[18:39] <pugssvn> r31686 | moritz++ | [t/spec] remove two wrong tests for %hash.pick 

[18:39] <ruoso> that's the link to the code in questio

[18:40] <masak> isBEKaml_: thanks to mst, I realized that the tags were there to be overused. :)

[18:41] <pmurias> rakudo: my $a = 2;$a := $a; say $a

[18:41] <p6eval> rakudo c8b6cf:  ( no output )

[18:41] <pmurias> rakudo: my $a = 2;my $b; $b := $a; say $b

[18:41] <p6eval> rakudo c8b6cf: OUTPUT¬´2‚ê§¬ª

[18:41] <pmurias> isn't the first one a bug?

[18:42] <masak> looks like.

[18:42] <masak> unless p6eval is acting up again.

[18:42] <pmurias> rakudo: my $a = 2;$a := $a; say $a

[18:42] <p6eval> rakudo c8b6cf:  ( no output )

[18:42] <moritz_> t segfaults locally

[18:42] * masak submits rakudobug

[18:42] <pmurias> it segfaults in mildew too

[18:42] <moritz_> \o/ they agree!

[18:42] <masak> what a wonderful coincidence.

[18:43] <isBEKaml_> masak: ah, yes. mst. :) Looking at the delegate list, everyone has a last name except abigail. (old perlmonks' joke, I think) :)

[18:43] <moritz_> isBEKaml_: or just privacy protection

[18:43] <lue> (http://www.bizjournals.com/dallas/stories/2010/07/12/daily9.html    Go Lawsuit! Go Lawsuit!)

[18:43] *** silug joined
[18:44] <isBEKaml_> moritz_: Not that I'm curious. I vaguely remember seeing something like "What in the world is abigail's last name?" as part of a signature on perlmonks. :)

[18:44] <moritz_> lue: it's a sick world we live in

[18:45] <masak> yapsi: my $a = 42; $a := $a; say $a

[18:45] <p6eval> yapsi: OUTPUT¬´42‚ê§¬ª

[18:45] <masak> \o/

[18:45] <isBEKaml_> \o/

[18:45] <moritz_> yaspi++ can do something that neither rakudo nor mildew handle correctly

[18:46] <isBEKaml_> so that leaves niecza. :)

[18:46] <pmurias> perlito?

[18:47] <lue> rakudo: my $a = 42; $a := $a; say $a

[18:47] <p6eval> rakudo c8b6cf:  ( no output )

[18:47] <moritz_> niezca: my $a = 42; $a := $a; say $a

[18:47] <moritz_> # hours later...

[18:48] <isBEKaml_> niezca? is that right? # I don't know

[18:48] <jnthn> cz

[18:48] <jnthn> I guess

[18:48] <moritz_> niecza: my $a = 42; $a := $a; say $a

[18:48] <isBEKaml_> niecza: my $a = 42; $a := $a; say $a

[18:48] <PerlJam> it's a czech conspiracy!

[18:48] <p6eval> niecza: OUTPUT¬´42‚ê§¬ª

[18:48] <p6eval> niecza: OUTPUT¬´42‚ê§¬ª

[18:48] <moritz_> \o/

[18:48] <jnthn> \o/

[18:48] <isBEKaml_> \o/

[18:49] <jnthn> I shoulda realized when I was less caffinated and was like "lol nice name", but in Slovak (modulo a spelling difference) it's the genitive case of "something"

[18:49] *** xlat joined
[18:49] <jnthn> :-)

[18:49] <dalek> rakudo: 32be7fb | (Radu Stoica)++ | src/core/Hash.pm:

[18:49] <dalek> rakudo: Implement Hash.pick

[18:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/32be7fbc3edffea24da30754d55dbffa3268b579

[18:49] <dalek> rakudo: a8deb9a | moritz++ | src/core/Hash.pm:

[18:49] <dalek> rakudo: fix Hash.pick for 0-values and absence of replacement

[18:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/a8deb9a756e04a2eb11be7a6c97842e3e0644aa8

[18:49] <dalek> rakudo: 22f2fc2 | moritz++ | src/core/Hash.pm:

[18:49] * lue goes to fix := in Ê•ΩÂúü

[18:49] <dalek> rakudo: simplify some code in Hash.pick

[18:49] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/22f2fc2e81aa18ad713bc0413ddc7c2d565bca85

[18:49] <isBEKaml_> btw, what does niecza mean? # me takes a stab at wildly guessing, "no czar" :)

[18:50] <pmurias> death to the czar

[18:50] <masak> jnthn: so, "something's"?

[18:50] <jnthn> masak: No, more like "of something"

[18:50] <isBEKaml_> so I was nearly right? 

[18:50] <jnthn> "kus nieca" => a pice of something

[18:50] <jnthn> :-)

[18:50] <jnthn> *piece

[18:51] <masak> isBEKaml_: it's a contraction of "nem√°me ƒças"

[18:52] <masak> isBEKaml_: Czech for "we don't have time".

[18:52] <masak> jnthn: ah.

[18:52] <isBEKaml_> masak: ahh, I see. so that explains sorear++'s furious commits. :)

[18:52] <masak> isBEKaml_: heh :)

[18:54] <masak> isBEKaml_: we should rename Yapsi to a contraction of "fast and furious".

[18:54] <diakopter> fasnfris

[18:54] <moritz_> too bad the "glacial" thing is already taken

[18:55] <masak> "molasses" is still free.

[18:56] <isBEKaml_> masak: fast and furious? No hollywood influence, I presume? :)

[18:56] <lue> I'm surprised no-one thought to add Safe.pir to .gitignore :)

[18:56] <masak> isBEKaml_: I won't say anything until my lawyer arrives.

[18:56] <isBEKaml_> and, molasses? 

[18:57] <masak> isBEKaml_: "molasses-ware" is a neologism from viklund's and my YAPC::EU 2008 lightning talk, where we unveil November. :)

[18:57] <isBEKaml_> masak: you aren't in the interrogation room!

[18:58] <masak> isBEKaml_: then quit shining that annoying light in my eyes!

[18:58] *** ashleydev joined
[18:58] <masak> :)

[18:58] <isBEKaml_> :)

[19:02] <masak> I'm troubled by sorear and TimToady's musings about the uselessness of END.

[19:02] <isBEKaml_> there ends awk implementation in p6. # moritz_ ?

[19:03] <ash_> does rakudo not implement heredoc's yet? 

[19:03] <isBEKaml_> I had wanted to ask something about phasers in general. How does P6 differentiate between compile-time and runtime checking w.r.t. phasers? 

[19:04] <isBEKaml_> As I understand it, phasers are generally seen at runtime. But then, most of perl is seen at runtime, right?

[19:04] *** perlygatekeeper left
[19:04] <masak> isBEKaml_: BEGIN and CHECK are run at compile time.

[19:05] *** cono left
[19:05] <masak> isBEKaml_: they can affect lexpads, but they do it through the so-called 'static lexpads'.

[19:05] <masak> sometimes also known as 'proto-lexpads'.

[19:05] <masak> they're a bit to lexpads as classes are to objects.

[19:06] *** cono joined
[19:07] *** Ross joined
[19:07] *** FardadJalili left
[19:07] <isBEKaml_> I see. I don't seem to remember seeing proto-lexpads anywhere. Source that I can look at?

[19:07] <isBEKaml_> (apart from the spec)

[19:07] <PerlJam> rakudo:  my ($a,$b) = 5,7; 0 < 1 ?? $a !! $b = 42; say $a; say $b;

[19:07] <masak> not even the spec, I think.

[19:07] <p6eval> rakudo c8b6cf: OUTPUT¬´42‚ê§7‚ê§¬ª

[19:07] <PerlJam> rakudo:  my ($a,$b) = 5,7; 0 > 1 ?? $a !! $b = 42; say $a; say $b;

[19:07] <masak> it's all just implementor's rumour's right now.

[19:07] <p6eval> rakudo c8b6cf: OUTPUT¬´5‚ê§42‚ê§¬ª

[19:07] <isBEKaml_> I'm really interested in seeing how perl distinguishes between compile and runtime operations. 

[19:08] <PerlJam> moritz_: you could "simplify" the while $middle < $l loop with a ternary!  :)

[19:08] <masak> isBEKaml_: BEGIN and CHECK work by the compiler invoking the runtime for a while.

[19:08] <moritz_> PerlJam: I thought about it... no.

[19:09] <pmurias> masak: what are valid uses of END?

[19:09] <moritz_> ternary as lvalue is just evil

[19:09] <masak> pmurias: -n and -p

[19:09] <moritz_> END { say "seems like you have failed $n tests" if $n > 0 }

[19:10] <isBEKaml_> finally blocks? 

[19:10] <masak> moritz_++ # good example, with a lexical and all

[19:10] <isBEKaml_> (I have only seen END in awk so far)

[19:10] *** REPLeffect left
[19:11] <pmurias> moritz_: that should be done in done_testing

[19:11] <moritz_> pmurias: done_testing is optional if there's a plan

[19:12] <isBEKaml_> END { close $filehandle if defined($filehandle) } #resources freed. 

[19:12] <pmurias> masak: LAST takes care of -n and -p

[19:13] <masak> pmurias: you're right. never considered that.

[19:13] <masak> pmurias: maybe LAST is the new END :)

[19:13] <lue> what happens in    $a := $a    ? Does it do nothing, or does binding still happen?

[19:13] <masak> lue: yes.

[19:13] *** Ross left
[19:13] <PerlJam> heh

[19:13] <moritz_> lue: noop

[19:14] <masak> it might be a no-op, but it might not always be easy to statically show that it's a no-op.

[19:14] <jnthn> rakudo: my $a = 42; pir::copy__vpp($a, $a); say "lived";

[19:14] <p6eval> rakudo c8b6cf: OUTPUT¬´lived‚ê§¬ª

[19:15] <jnthn> rakudo: my $a = 42; pir::copy__vpp($a, $a); say $a;

[19:15] <pmurias> isBEKaml_: you could put that into DESTROYALL

[19:15] <p6eval> rakudo c8b6cf: OUTPUT¬´42‚ê§¬ª

[19:15] <jnthn> Hmm. Unobvious segfault is unobvious.

[19:15] <isBEKaml_> pmurias: there's a phaser DESTROYALL?? 

[19:15] <lue> rakudo: multi sub infix:<Œ©>(Mu \$a, Mu \$b) { $a == $b ?? "same" !! "not" }; my $a = 2; my $b = 3; say $a Œ© $b; say $a Œ© $a

[19:15] * isBEKaml_ goes looking at spec. 

[19:15] <p6eval> rakudo c8b6cf: OUTPUT¬´not‚ê§same‚ê§¬ª

[19:16] <jnthn> isBEKaml_: S12 iirc

[19:16] <masak> we'll never have DESTROY and DESTROYALL if Parrot doesn't offer support for it.

[19:16] <lue> I'll just not bind when $a := $a occurs.

[19:16] <masak> isBEKaml_: they're submethods, not phasers as such.

[19:17] <lue> .oO[ EXTERMINATE { $earth } ]

[19:17] <isBEKaml_> lue: No!

[19:17] *** uniejo joined
[19:17] <PerlJam> lue: just make sure you can also handle   my $a = 5; my $b := $a; $a := $b;  # or similar binding loops

[19:17] <isBEKaml_> lue: unless you're Neo. :)

[19:18] <moritz_> isBEKaml_: well, you only have to exchange three characters in 'lue' to get to 'neo

[19:18] <moritz_> '

[19:18] <masak> moritz_: whoa!

[19:18] <lue> there should be tests for those [if they aren't there already]

[19:18] <isBEKaml_> moritz_: not like in HAL. :)

[19:18] <lue> I can just see the commit message now...

[19:19] <pmurias> isBEKaml_: DESTORYALL is the destructor, instead of closing the resource in the END block you could close it in it's destructor

[19:20] <pmurias> isBEKaml_: so it would close itself, like filehandles do

[19:20] <lue> [11:49:48] <dalek> rakudo: fffffff | evil++ | src/core/phasers.pm:

[19:20] <lue> [11:49:48] <dalek> rakudo: Implement EXTERMINATE

[19:20] <masak> o.O

[19:21] *** ash_ left
[19:21] <masak> lue: you actually had me fooled for a while :)

[19:21] <lue> moral of the story:  so, for safety reasons, either never come up with EXTERMINATE, or rename dalek.

[19:21] *** ash_ joined
[19:21] <pmurias> jnthn: re segfault in smop's case it's an infinite recurssion on lookup

[19:22] *** Ross joined
[19:22] <masak> rakudo: class Bridge {}

[19:22] <p6eval> rakudo c8b6cf:  ( no output )

[19:22] <lue> rakudo: my $a = 3; my $b := $a; my $c = 3; say $a == $b; say $a == $c

[19:22] <p6eval> rakudo c8b6cf: OUTPUT¬´1‚ê§1‚ê§¬ª

[19:22] <masak> rakudo: class Bridge {}; say "alive"

[19:22] <p6eval> rakudo c8b6cf: OUTPUT¬´alive‚ê§¬ª

[19:23] <isBEKaml_> did someone implement EXTERMINATE? #I see masak trying to set up a bridge.. 

[19:24] <isBEKaml_> o.O(The spec is rather terse on DESTROY and BUILD)

[19:24] <isBEKaml_> pmurias: thanks. I was just surprised to see DESTROY as one of the phasers. :)

[19:24] <lue> rakudo: my $a = 3; my $b := $a; my $c = 3; say $a === $b; say $a === $c

[19:24] <p6eval> rakudo c8b6cf: OUTPUT¬´1‚ê§1‚ê§¬ª

[19:25] <masak> the spec actually doesn't say anything about *when* DESTROY and DESTROYALL are called, despite there being plenty of details to offer.

[19:25] <lue> I thought the output for that would be ¬´1‚ê§0‚ê§¬ª

[19:26] <masak> for example: is there a guarantee that DESTROY is called at the point things go out of scope? (my guess is "no".)

[19:26] <masak> is there a guarantee that DESTROY is called before something is GC'd? (probably "yes")

[19:26] <moritz_> yes

[19:26] <masak> is there a guarantee that DESTROY is called before program exit? (tough one)

[19:26] <moritz_> yes

[19:26] <masak> what about if the program gets a sufficiently strong termination signal?

[19:27] <moritz_> then probably not

[19:27] <isBEKaml_> isn't gc done before exit() (most cases) ? So that's an yes

[19:27] <moritz_> surely not if it gets a SIGKILL

[19:27] <moritz_> but that's not perls fault

[19:29] <ash_> with a SIGKILL you don't get a warning before your program dies though (right?) 

[19:29] <lue> rakudo: my $a = 3; my $b := $a; my $c = 3; say $a =:= $b; say $a =:= $c

[19:29] <p6eval> rakudo c8b6cf: OUTPUT¬´0‚ê§0‚ê§¬ª

[19:29] <lue> O.o

[19:30] <masak> yapsi: my $a = 3; my $b := $a; my $c = 3; say $a; say $b; say $c

[19:31] <p6eval> yapsi: OUTPUT¬´3‚ê§3‚ê§3‚ê§¬ª

[19:31] <ash_> yeah, SIGKILL can't be handled or ignored in normal unix, so if you get a SIGKILL you won't have a chance to do any phasers related to exiting 

[19:31] <masak> lue: same value, different containers.

[19:31] <pmurias> masak: if you receive a sufficiently strong termination signal END won't be called

[19:31] <masak> lue: $a and $b should be the same, though.

[19:31] <masak> pmurias: right. but maybe it will if it isn't very strong. that might be a use case somehow. a sort of signal CATCH.

[19:32] <lue> that's where the O.o comes in. Apparently, =:= is in cheats/

[19:32] <pmurias> masak: if it's not very strong DESTORY will be called also

[19:32] <masak> lue: you can fix it; I know you can!

[19:32] * masak submits rakudobug

[19:32] <lue> ! is not a metaop, is it?

[19:32] <masak> lue: it is.

[19:32] <isBEKaml_> masak: that's only when the signal is caught, right? so I guess that's left to the sighandlers. 

[19:33] <masak> isBEKaml_: yeah. but what's the default behavior?

[19:33] <lue> well then, cheats/ is really being weird (defining both =:= and !=:=)

[19:33] <isBEKaml_> masak: pack up and exit. 

[19:34] *** masak left
[19:34] <pugssvn> r31687 | pmurias++ | [smop] fix binding a var to itself 

[19:34] <pugssvn> r31687 | [mildew] add a test for that

[19:35] <moritz_> http://www.ericsink.com/entries/veracity_early.html # wow, this sounds really great

[19:35] <moritz_> a decentralized, versioned database is something I've been wanting ever since learning about git (and realized that such a thing could be possible :)

[19:36] <isBEKaml_> moritz_: git isn't decentralized, versioned SCM? 

[19:37] <moritz_> isBEKaml_: it is. But it's not a database

[19:38] <isBEKaml_> moritz_: I thought it was a typo or maybe he's just using VCS and database interchangeably. (I have seen guys at work do that too. )

[19:39] <moritz_> reading the blog post, I'm pretty sure he does mean a database

[19:40] *** sahadev joined
[19:40] <isBEKaml_> wouldn't know. Only one way to know that, right? (Wait for actual announcement at OSCON :)

[19:41] *** masak joined
[19:41] <moritz_> "Veracity goes beyond versioning of directories and files to provide management of records and fields, with full support for pushing, pulling and merging database changesets, just like source tree changesets."

[19:42] <PerlJam> I'm reserving judgement until I see it.

[19:42] <masak> as opposed to liking it before you have a reason to? :P

[19:42] * moritz_ reserves judgement until he has used it as long as he used git befor getting excited about it

[19:42] <moritz_> but I kinda look forward to it

[19:42] <lue> rakudo: multi sub infix:<Œ©>(Mu \$a, Mu \$b) { $a == $b ?? "same" !! "not" }; my $a = 2; my $b := $a; say $a Œ© $b; say $a Œ© $a

[19:42] <PerlJam> yeah, I don't want to get my hopes up and then be disappointed  :)

[19:42] <p6eval> rakudo c8b6cf: OUTPUT¬´same‚ê§same‚ê§¬ª

[19:43] <lue> rakudo: multi sub infix:<Œ©>(Mu \$a, Mu \$b) { $a == $b ?? "same" !! "not" }; my $a = 2; my $c = 2; say $a Œ© $c;

[19:43] <masak> lue: == is numeric comparison.

[19:43] <p6eval> rakudo c8b6cf: OUTPUT¬´same‚ê§¬ª

[19:43] * isBEKaml_ reserves judgment until actually using it long enough to replace git. 

[19:44] <PerlJam> "better than git" is a high bar to reach

[19:44] * lue reserves judgment because his daily shipment of JudgeMint‚Ñ¢ hasn't arrived yet, and is therefore trying to save what he has

[19:44] <moritz_> rakudo: my ($a, $b); say $a =:= $a, $a =:= $b

[19:44] <isBEKaml_> atleast, that's what he claims it to be, right. So I think it's fully justified. 

[19:44] <p6eval> rakudo c8b6cf: OUTPUT¬´10‚ê§¬ª

[19:45] <moritz_> rakudo: sub f($x, $y) { $x =:= $y }; my ($a, $b); say f($a, $a), f($a, $b)

[19:45] <p6eval> rakudo c8b6cf: OUTPUT¬´00‚ê§¬ª

[19:45] <moritz_> bug`

[19:45] <moritz_> s/`/?/

[19:46] *** ruoso left
[19:46] <lue> rakudo: my $a = 3; my $b := $a; say $a =:= $b

[19:46] <p6eval> rakudo c8b6cf: OUTPUT¬´0‚ê§¬ª

[19:46] <moritz_> also bug

[19:47] *** skids left
[19:47] * masak adds that one to the ticket

[19:47] <moritz_> masak++

[19:47] <masak> looks like the exact same one, though.

[19:48] <moritz_> if signature binding and := binding are implemented through the same mechanism, yes

[19:48] <sahadev> hello #perl6

[19:48] <masak> well, the one with f might be worth adding.

[19:48] <masak> sahadev: hi!

[19:49] <sahadev> please take a look at http://pastie.org/1044533

[19:49] <lue> .oO(time to go hunt for the right pir opcode!)

[19:49] <sahadev> bug?

[19:49] <isBEKaml_> sahadev: enclose it in parens. 

[19:50] <isBEKaml_> for (1.. $n)

[19:50] <masak> what? no.

[19:50] <PerlJam> no parens are needed

[19:50] <masak> sahadev: likely a strings-and-range bug.

[19:50] <colomon> 1 .. +$n

[19:50] <masak> or even expected behavior.

[19:50] <masak> sahadev: what colomon said.

[19:50] <colomon> right now you're doing 1 .. "10"

[19:50] <colomon> which confuses matters.

[19:50] <masak> let me take this moment to advocate numification of range arguments, as per my latest p6l email :)

[19:50] <sahadev> colomon: ah.

[19:51] <masak> TimToady: ^^

[19:51] <sahadev> masak++

[19:51] <sahadev> colomon++

[19:51] <masak> sahadev: also, 'sub MAIN(Int $n = 5) { ... }

[19:51] <masak> '

[19:51] <moritz_> with a special-case for both-string argument and whatever-arguments

[19:51] <colomon> we don't have the edge cases sorted out for this sort of thing yet.

[19:52] <masak> moritz_: aye. I mentioned the both-string case, forgot about the whatever case.

[19:52] <isBEKaml_> :(

[19:52] <colomon> rakudo: say ("10", * + 2 ... 20).perl

[19:52] <sahadev> masak: i always forget that Perl 6 has MAIN :)

[19:52] <p6eval> rakudo c8b6cf: OUTPUT¬´("10", 12, 14, 16, 18, 20)‚ê§¬ª

[19:52] <colomon> rakudo: say ("10", *.succ ... 20).perl

[19:52] <p6eval> rakudo c8b6cf: OUTPUT¬´("10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20")‚ê§¬ª

[19:52] <masak> sahadev: "Perl 6: more awesome than you remember" :P

[19:52] *** payload left
[19:53] <moritz_> sahadev: it's occasionally very useful :-)

[19:53] <colomon> rakudo: say ("10", *.succ ... 22).perl

[19:53] <p6eval> rakudo c8b6cf: OUTPUT¬´("10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22")‚ê§¬ª

[19:53] <moritz_> like, when you're too lazy to parse command line arguments yourself :-)

[19:53] <moritz_> which I am, nearly always

[19:53] <colomon> rakudo: say ("10", { $_.succ.succ } ... 22).perl

[19:53] <p6eval> rakudo c8b6cf: OUTPUT¬´("10", "12", "14", "16", "18", "20", "22")‚ê§¬ª

[19:53] <moritz_> rakudo: say ("10", { $_.succ.succ } ... 21).perl

[19:53] <masak> even aliens use MAIN nowadays :)

[19:54] <p6eval> rakudo c8b6cf: OUTPUT¬´("10", "12", "14", "16", "18", "20")‚ê§¬ª

[19:54] <lue> rakudo: my $a = 3; say $_

[19:54] <p6eval> rakudo c8b6cf: OUTPUT¬´Any()‚ê§¬ª

[19:54] <colomon> rakudo: say ("10", { $_.succ.succ } ... 23).perl

[19:54] <p6eval> rakudo c8b6cf: OUTPUT¬´("10", "12", "14", "16", "18", "20", "22")‚ê§¬ª

[19:54] <moritz_> masak: yeah, when they realized that they need such a mechanism they time-travelled back to have it implemented

[19:54] *** justatheory left
[19:54] <colomon> masak: it's not random that I've wandered over to series questions ... $a .. $b iterated is supposed to return $a ... $b

[19:55] <colomon> so automatically casting to Numeric (if one of the arguments is Numeric) could have weird issues.

[19:55] <PerlJam> as long as series are magically aware of string args, having ranges numify its args seems reasonable.

[19:56] *** Kodi joined
[19:56] <colomon> rakudo: say 1 ... "10"

[19:56] <p6eval> rakudo c8b6cf: OUTPUT¬´1‚ê§¬ª

[19:58] <sahadev> moritz_: question about http://perlgeek.de/blog-en/perl-6/contribute-now-hash-pick.html

[19:58] <sahadev> why is "{a => 1, b => 0.5}.pick(*, :replace)" ok, but fatally not ok without :replace?

[19:58] <moritz_> sahadev: yes

[19:59] <sahadev> why?

[19:59] <moritz_> (though notice that we have a submission already, so yours would only be used if it's vastly better than the current one)

[19:59] <moritz_> sahadev: because you'd have -0.5 'b' bowls left in your urn

[20:00] <moritz_> and that's a bit weird, don't you think?

[20:00] <TimToady> phone today?

[20:00] <moritz_> also I'd expect it to return 1.5 list items...

[20:01] <sahadev> {a => 1, b => 0.5} should be equivalent to {a => 2, b => 1} in terms of weightage, no?

[20:02] <lue> I wasn't aware there was a src/cheats/match-bool.pm. It's not there, I didn't remove it, and now make refuses to work :(

[20:02] <Tene> sahadev: right, but the issue is, without :replace, how *many* results are returned?

[20:03] <Tene> rakudo: say (1..5).pick(*);

[20:03] <p6eval> rakudo c8b6cf: OUTPUT¬´52143‚ê§¬ª

[20:03] <sahadev> Tene: depends on how the weights are treated, absolute vs relative to each other.

[20:03] <pmurias> TimToady: have you seen the test we and ruoso are unsure is valid?

[20:04] <sahadev> in case of list pick, the issue doesn't arise, since all are equally weighted.

[20:04] <Tene> sahadev: Right, and there are multiple options there.

[20:04] <Tene> and they all have unintuitive behavior in some situations.

[20:04] <pmurias> TimToady: CATCH {$_.handled=1} #is the exception rethrown?

[20:04] <masak> lue: perl Configure.pl

[20:05] <Tene> pmurias: by my memory, the exception should be resumed there.

[20:05] <Tene> I wouldn't be surprised if my memory is way off, though. :)

[20:05] <sahadev> it seems a bit odd to me that non-integer weights are allowed with :replace, but not otherwise.

[20:05] <PerlJam> sahadev: So, if you've only got 2 items and one is 5 times more likely to be picked than the other, perhaps you pick some Mu to fill in the gap?

[20:05] * lue should pay attention to what I git pull from now on :)

[20:06] <masak> lue: or just make a small shell script that does all steps of the build process for you automatically.

[20:06] <Tene> sahadev: if you do relative, though, what happens if all weights are multiples of two?

[20:06] <Tene> do you only get half as many items?

[20:08] <moritz_> note that { a => 10, b => 5 }.pick(2) and { a => 20, b => 10 }.pick(2) have different probabilities

[20:09] <Tene> sahadev: I could imagine that .pick on hashes might support a :relative argument, though, that might do what you're proposing.

[20:09] <Tene> I wouldn't be too surprised to see a spec change like that.

[20:10] <sahadev> Tene: that would make sense.

[20:11] <sahadev> s/sense/more sense/

[20:11] *** literal left
[20:12] <Tene> sahadev: I'd be inclined to post it to the mailing list to see if anyone else can think of any other implications for that behavior, or if there are any alternatives we'd be missing, but it sounds pretty reasonable to me.

[20:12] <moritz_> :relative doesn't make sense for an action that's not scale invariant

[20:14] <PerlJam> perhaps the spec should stop calling the values "weights". 

[20:15] <Tene> Maybe 'scale', or 'normalize', or something else would be an appropriate name for that.

[20:15] *** timbunce joined
[20:15] <sahadev> moritz_: can you please explain how { a => 10, b => 5 }.pick(2) and { a => 20, b => 10 }.pick(2) have different probabilities? i get the feeling that i am missing something very basic here.

[20:15] <moritz_> sahadev: assumiing that a 'b' is picked in the first place, and not replaced...

[20:16] <moritz_> sahadev: then to probabilites for getting another 'b' are 4/14 in one case, and 9/29 in the other

[20:16] <moritz_> rakudo: say 4/14, 9/29

[20:16] <p6eval> rakudo c8b6cf: OUTPUT¬´0.2857142857142860.310344827586207‚ê§¬ª

[20:16] <sahadev> moritz_: right.

[20:16] *** literal joined
[20:17] *** clintongormley left
[20:18] *** isBEKaml_ left
[20:18] <PerlJam> Tene: I was thinking of :normalize earlier, but then I'd expect it to normalize the values to be between 0 and 1 rather than scale them to all be integer (which is where sahadev seems to be leaning)

[20:18] <Tene> PerlJam: how do you get less than 1 of an item?

[20:18] *** literal left
[20:19] <PerlJam> Tene: you don't, the interpretation of the values changes to be probabilities rather than a "bag of marbles"

[20:19] <Tene> PerlJam: Then what do you get when you ask for .pick(*) without :Replace ?

[20:19] <PerlJam> a mess :)

[20:20] <moritz_> now you get a friendly error message instead of a mess

[20:20] <moritz_> (well, NYI, but pretty easy to do)

[20:20] *** literal joined
[20:20] <moritz_> (yes, I did think about it before I said it should be an error :-)

[20:20] <Tene> I'm not sure that I actually see a use case for :normalize or :scale or whatever there.  That hasn't been a very consistent indicator of a lack of usefulness, though.

[20:21] <PerlJam> indeed.

[20:21] <PerlJam> YAGNI! :)

[20:21] <Tene> Hence, my proposal that we post to the ML to see if anyone can think of reasonable semantics that would actually be useful.

[20:21] <Tene> I've found some of the math discussions on the ML to be very enlightening before. :)

[20:21] * masak .oO( someone should make a Perl 6 implementation called "Yagni" )

[20:22] <Tene> masak: I started on that, but decided that I didn't actually need another impl.

[20:22] <masak> Tene: awww.

[20:22] * masak refuses to acknowledge the implied self-reference of the situation

[20:23] <Tene> masak: Yeah, autopuns like that don't actually need to be acknowledged.

[20:24] <jnthn> masak: ping

[20:25] <moritz_> Tene: actually I found math discussion on p6l ending quite scary, and way over my head :-)

[20:25] <masak> jnthn: pong

[20:25] <moritz_> and I'm not generally scared by higher math

[20:26] <masak> Tene: in that case, I retract my implied acknowledgement through explicit lack of acknowledgement of your autopun.

[20:26] <jnthn> masak: so pls

[20:26] <masak> jnthn: so.

[20:26] <jnthn> Let's make it workier on Win32 :-)

[20:26] <masak> yay

[20:27] <masak> mostly that consists of going through the individual system calls, and replacing many of them with built-in stuff.

[20:27] <jnthn> masak: Are most of those funneled through sub run-logged?

[20:27] <masak> yes.

[20:28] * masak checks if all of them are.

[20:28] <masak> ISTR there were a few that weren't.

[20:28] <jnthn> run-logged "mkdir cache", :step('fetch'), :$project;

[20:28] <lue> > my $a = 3; my $b := $a; say $a =:= $b

[20:28] <lue> Too many positional parameters passed; got 2 but expected 1

[20:28] <jnthn> So I could replace that with mkdir('cache'); for example

[20:28] <jnthn> ?

[20:28] <jnthn> Or do I need to do some other loggy thing?

[20:28] <masak> jnthn: yes.

[20:28] <masak> no, I say we skip logging on mkdir :)

[20:29] <masak> we might do something intelligent if it fails, though.

[20:29] <jnthn> The next line checks we have a directory there anyway in that case

[20:29] <jnthn>         if "cache" !~~ :d {

[20:29] <jnthn>             die "Cannot proceed, cache inexplicably isn't a directory";

[20:29] <jnthn>         }

[20:29] <jnthn> lol

[20:29] <jnthn> :-)

[20:29] <masak> oh, good :)

[20:30] <masak> you can never be too careful.

[20:30] <jnthn> aww, it relies on the make program being called "make" too

[20:30] <masak> jnthn: we should be able to do detection there somehow.

[20:31] <jnthn> aye

[20:31] <masak> not OS detection, but binary detection.

[20:31] <jnthn> 1

[20:31] * masak has started writing his "appetizers" talk, and is enjoying himself

[20:32] <jnthn> omnomnom

[20:33] <masak> I'm reading through old code in the process. realizing I used the pattern "lexical subs" long before subs were lexical by default. :)

[20:35] <pugssvn> r31688 | moritz++ | [t/spec] some Rakudo unfudges 

[20:38] <masak> the YAPC::EU schedule is already fixed. I no longer collide neither with jnthn++ nor with myself.

[20:39] <moritz_> EONETOOMANYNEGATION

[20:39] <masak> I no longer collide either with jnthn++ or with myself.

[20:39] * jnthn understood it :-)

[20:39] <masak> please wrap your excess negations in a bag and leave it at the front desk. thank you.

[20:40] *** Guest58577 left
[20:40] <lue> http://gist.github.com/476031 hrmm

[20:40] <dalek> rakudo: 4b3d76b | moritz++ | t/spectest.data:

[20:40] <dalek> rakudo: regress on DateTime.t.

[20:40] <dalek> rakudo: It is currently out of sync with the implementation (or the other way round),

[20:40] <dalek> rakudo: and only clutters up the test summary.

[20:40] <dalek> rakudo: Now we should have a PASSing spectest again, at least on sane platforms.

[20:40] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/4b3d76bc8ee1de84f65be2fba46cf96ff6af6d42

[20:40] <lue> masak: in a Bag? Is that not NYI ?

[20:40] <jnthn> ooh yay, I collide with no other Perl 6 talks now. :-)

[20:41] <masak> lue: nono, 'bag'. it's the native type :P

[20:41] <Tene> But if you two aren't competing anymore, how will we know whose talk wins?

[20:41] <lue> rakudo: my bag $ofnegations;

[20:41] <moritz_> jnthn: I don#t think any Perl 6 talks collide now

[20:41] <p6eval> rakudo c8b6cf: OUTPUT¬´===SORRY!===‚ê§Malformed my at line 20, near "bag $ofneg"‚ê§¬ª

[20:42] <jnthn> moritz_: Yes, just looked thorugh and concluded the same :-)

[20:42] <lue> Can anyone point out glaring errors here? http://gist.github.com/476031

[20:42] <Tene> my Bag of Negation $bag;

[20:42] <moritz_> there are still hard choices to make, though :-)

[20:42] <Tene> or was that: my Bag $bag of Negation; ?  I don't recall.

[20:43] <jnthn> my Bag of Negation $i-think.

[20:43] <lue> rakudo: my Array of Int @a; @a = 1.2,3.5;

[20:43] <p6eval> rakudo c8b6cf: OUTPUT¬´Method '!select' not found for invocant of class ''‚ê§  in main program body at line 20:/tmp/HHMyPGcZe1‚ê§¬ª

[20:43] *** tadzik left
[20:43] <moritz_> lue: do you get the same error if you leave out the 'say'?

[20:43] <Tene> Yeah, Container of Containee

[20:44] <lue> > my $a = 3; my $b := $a; $a =:= $b

[20:44] <lue> 0

[20:44] <lue> no, just a different one :)

[20:45] <moritz_> what about say($a =:= $b) # with parenthesis?

[20:45] <moritz_> I'd expect 0\n again

[20:45] <lue> you expected correctly

[20:48] <lue> > my $a = 3; my $b := $a; pir::issame_IPP($a, $b)

[20:48] <lue> error:imcc:syntax error, unexpected PREG, expecting '(' ('$P95')

[20:48] <lue>         in file 'EVAL_3' line 72

[20:48] <lue> syntax error ... somewhere

[20:48] <masak> "moritz_: a very reliable Perl 6 implementation"

[20:49] *** Mowah joined
[20:50] <lue> maybe it's a problem with pir::issame?

[20:50] <masak> lue: comment it out and see if that changes things.

[20:50] <lue> comment what out?

[20:51] *** grussell joined
[20:51] <masak> lue: pir::issame_IPP($a, $b)

[20:51] <lue> > my $a = 3; my $b := $a; #pir::issame_IPP($a, $b)

[20:51] <lue> Any()

[20:51] <masak> there you go, then.

[20:51] *** ejs joined
[20:52] *** Guest58577 joined
[20:52] *** grussell left
[20:52] <lue> I'm amazed it doesn't err like that inside the =:= sub

[20:52] * lue --nom &

[20:53] <jnthn> What is pir::issame being used for?

[20:53] <masak> checking for =:= equivalence, I'd guess.

[20:53] <jnthn> That sounds wrong.

[20:54] <jnthn> =:= means "references the same thingy" right?

[20:54] <masak> aye.

[20:54] <masak> I see it as meaning "someone did := on these things"

[20:54] <masak> either that, or it was the same from the start :)

[20:55] <jnthn> pretty sure the issame op is not what is wanted then

[20:56] * masak adds that to the ticket

[20:56] *** uniejo left
[20:56] *** whiteknight joined
[20:56] <jnthn> masak: woo, I eliminated teh readed find

[20:56] <jnthn> *dreaded

[20:56] <masak> jnthn: yay! how?

[20:57] <jnthn> masak: By writing a find-files sub using dir :-)

[20:57] <jnthn> (the Perl 6 built-in dir)

[20:57] <masak> nice.

[20:57] <masak> jnthn: closure parameter?

[20:57] <jnthn> No

[20:57] <masak> hm, maybe no need.

[20:57] <jnthn> my @module-files = find-files("$target-dir/lib", /\.pm6?$/);

[20:58] <masak> it just needs to find and list the files.

[20:58] <moritz_> rakudo: say dir('/').Str

[20:58] <jnthn> masak: It just takes a second argument and smart-matches the file name against it :-)

[20:58] <p6eval> rakudo 22f2fc: OUTPUT¬´. .. emul var usr bin boot dev etc home lib mnt proc root sbin tmp sys lib64 selinux srv opt media lib32‚ê§¬ª

[20:58] <masak> jnthn: nice. I like.

[20:58] <moritz_> jnthn: but it doesn't recurse like find, does it?

[20:58] <jnthn> moritz_: dir doesn't. find-files does.

[20:59] <jnthn> Otherwise we'll not find stuffs.

[20:59] <moritz_> maybe add :recursive to dir()

[20:59] <jnthn> moritz_: moze byt :-)

[20:59] <jnthn> masak: Was the find returning stuff without the stuff before lib/, if you remember?

[21:00] <masak> jnthn: yes, I think it was.

[21:00] <masak> jnthn: but I also remember considering whether it shouldn't.

[21:00] <masak> jnthn: go with whatever works.

[21:01] <jnthn> masak: Yes, working is my main goal :-)

[21:02] <masak> :P

[21:03] <jnthn> whee, we generate a Makefile now.

[21:03] <jnthn> blech

[21:03] <jnthn> Two problems.

[21:04] <jnthn> 1) the make vs nmake thing

[21:04] <masak> aye.

[21:04] <jnthn> 2) The makefile is busted for nmake anyway

[21:04] <jnthn> makefile(7) : fatal error U1000: syntax error : ')' missing in macro invocation

[21:04] <jnthn> Stop.

[21:05] <masak> sucks, but no showstopper.

[21:06] <jnthn> masak: pushed the two changes so far

[21:06] <jnthn> Hope they don't break it elsewhere.

[21:07] *** sahadev left
[21:07] <jnthn> My poor hands need a liten paus now. bbiab. :-)

[21:07] <masak> jnthn: I'll try it right now.

[21:08] <jnthn> PIRS=$(patsubst %.pm6,%.pir,$(SOURCES:.pm=.pir)) # that line is NO WEI going to work in nmake

[21:08] * jnthn really afk

[21:09] *** Mowah left
[21:13] *** rgrau` joined
[21:17] *** Guest58577 left
[21:18] <pugssvn> r31689 | Kodi++ | [S32/Temporal] Permit days-in-month and is-leap-year on DateTimes, too. 

[21:32] <sjohnson> rakudo: say "hi there!".rot13

[21:32] <p6eval> rakudo 22f2fc: OUTPUT¬´Method 'rot13' not found for invocant of class 'Str'‚ê§  in main program body at line 20:/tmp/Tat_Z5RlMp‚ê§¬ª

[21:33] *** justatheory joined
[21:34] <masak> rakudo: my $rot13 = method { self.trans( "a..zA..Z" => "n..za..mN..ZA..M" ) }; say "hi there!".$rot13

[21:34] <p6eval> rakudo 22f2fc: OUTPUT¬´uv gurer!‚ê§¬ª

[21:35] <jnthn> masak: back

[21:35] *** timbunce left
[21:36] *** tylercurtis joined
[21:37] <Kodi> masak: Do you think .day-of-month (a synonym of .day) should stay? It seems kind of pointless.

[21:38] <masak> Kodi: yes, I like the long form. it constrasts well with .day-of-week.

[21:38] <Kodi> That is true.

[21:38] *** snarkyboojum joined
[21:39] <Tene> I'm very skeptical of having synonyms.

[21:39] <Tene> That just seems like asking for trouble to me.

[21:39] <sjohnson> masak.. u so silly

[21:39] <Tene> I haven't heard any reasonable justification of it at all.

[21:39] <sjohnson> your perl 6 knowledge is impressive !

[21:40] <sjohnson> starting to think there isn't much that p6 cannot do

[21:40] *** am0c left
[21:40] <masak> sjohnson: thanks. been doing this for six years now... getting familiar-ish with the system. :P

[21:41] *** timbunce joined
[21:41] <sjohnson> masak: are you interested in cryptography at all?

[21:42] <sorear> masak: what I'm planning to do is to not keep separate lexpads for mainline-y stuff

[21:42] <masak> sjohnson: as in "do rot13 twice, that should be secure enough?" :)

[21:42] <sorear> END will work intuitively as long as you use it in the mainline or a module/class body

[21:42] <sorear> subs and control structures?  no

[21:42] <masak> sorear: the idea being that the mainline never gets cloned? yeah, could work.

[21:43] <sjohnson> masak: :)

[21:43] <sjohnson> cryptography is my new obsession.  though i dont know much about it

[21:44] <masak> sjohnson: http://www.simonsingh.net/The_Code_Book.html

[21:44] <sjohnson> good read?

[21:45] <masak> sjohnson: aye. do try to get it.

[21:45] <sjohnson> will do

[21:45] * jnthn read that many years ago

[21:47] <jnthn> masak: OK, so now I can detect nmake and use it

[21:47] <jnthn> masak: So at this point, we're looking good up to the generated Makefile.

[21:47] <sjohnson> jnthn: did you like it too? :)

[21:47] <jnthn> masak: Sadly, the generated Makefile is a huge pile of portability fail.

[21:48] <jnthn> sjohnson: I seem to recall I did. It was a while back. :-)

[21:48] <masak> jnthn: you're on your own trying to make the Makefile work. after that, I'm open to generating a different Makefile for Windows.

[21:49] <jnthn> masak: I'm hardly a Makefile guru. :-(

[21:49] <jnthn> Wish we just ran commands rather than wrote a Makefile.

[21:49] <jnthn> masak: What's the -p in mkdir -p?

[21:50] <masak> jnthn: it's "don't ask, don't tell" :)

[21:50] <PerlJam> jnthn: makes all the components of a path if they don't already exist

[21:50] <jnthn> masak: On windows it makes a directory called -p :P

[21:50] <jnthn> As well as the one that follows it.

[21:51] <jnthn> rakudo: say %*VM<config>

[21:52] <p6eval> rakudo 22f2fc: OUTPUT¬´Any()‚ê§¬ª

[21:52] <jnthn> rakudo: say $*VM<config>

[21:52] <p6eval> rakudo 22f2fc: OUTPUT¬´ptrcast    long‚ê§HASATTRIBUTE_UNUSED  1‚ê§libparrot_shared        libparrot.so.2.5.0‚ê§inst_libparrot_linkflags       -L/home/p6eval//p1/lib -lparrot‚ê§parrot_is_shared  1‚ê§ar_out        ‚ê§sbindir  /home/p6eval//p1/sbin‚ê§HASATTRIBUTE_PURE     1‚ê§cc_debug      -g‚ê§opcode_t      

[21:52] <p6eval> ..long‚ê§revision     48074‚ê§link_dynamic        -Wl,-E‚ê§HAS_EXTRA_NCI_TH‚Ä¶

[21:52] <jnthn> aha

[21:52] <jnthn> rakudo: say $*VM<config><mkdir>

[21:52] <p6eval> rakudo 22f2fc: OUTPUT¬´Any()‚ê§¬ª

[21:53] <jnthn> rakudo: say $*VM<config><mkpath>

[21:53] <p6eval> rakudo 22f2fc: OUTPUT¬´$(PERL) -MExtUtils::Command -e mkpath‚ê§¬ª

[21:53] <jnthn> hmmhmm

[21:53] <jnthn> rakudo: say $*VM<config><rm_f>

[21:53] <p6eval> rakudo 22f2fc: OUTPUT¬´$(PERL) -MExtUtils::Command -e rm_f‚ê§¬ª

[21:54] <jnthn> .oO( how to make pls Rakudo-dependent and Perl 5 dependent all in one go! :/ )

[21:56] <jnthn> masak: I'll take the Makefile challenge on another day, or maybe somebody beats me to it.

[21:56] <masak> jnthn: nod.

[21:56] <jnthn> masak: It's like, an enormous yak.

[21:56] *** meppl left
[21:57] <jnthn> masak: I am *seriously* tempted to toss this makefile generation code.

[21:58] <jnthn> masak: And if there's no makefile, just run a bunch of commands with "run"

[21:58] <jnthn> That'd do what this Makefile tries to do.

[21:58] <sorear> sjohnson: here, catch: http://www.muppetlabs.com/~breadbox/txt/rsa.html

[21:58] <masak> jnthn: that might be a good idea not just for Windows.

[21:58] <jnthn> masak: Aye.

[21:58] <jnthn> masak: Are you opposed to doing that?

[21:59] <jnthn> masak: Portable makefile generation is a nuisance. We do it for Rakudo by relying on a bunch of analysis Parrot has done in order to generate its one.

[21:59] <jnthn> Then there are certainly rules to play by (e.g. "don't use X construct, it won't work portably")

[21:59] <masak> jnthn: no, not opposed. it's all about tradeoffs, and only you can gauge this one.

[22:00] <jnthn> masak: Makefiles are great when you're regularly building stuff that has dependencies.

[22:00] <jnthn> masak: But in this case we're building the thing once.

[22:00] <jnthn> Then testing, then installing.

[22:00] <jnthn> iiuc.

[22:00] <masak> jnthn: yeah, but the modules have dependencies.

[22:00] <masak> jnthn: that's the original feature of ufo.

[22:01] <jnthn> masak: Oh, it looks at the use statements?

[22:01] <masak> jnthn: yes!

[22:01] <jnthn> @order contains the reuslt of that though?

[22:01] <masak> looks at use statements, does a topological sort, builds the Makefile correspondingly.

[22:01] <jnthn> :-)

[22:01] <jnthn> Nice!

[22:02] <masak> :)

[22:02] <jnthn> masak: I won't go one way or another now, will think on it a bit, and @other who backlog can feed in their thoughts too.

[22:02] <jnthn> I'm not a good toolchain hacker, I'm just doing this because Windows support matters. :-)

[22:02] <masak> moritz_ might have a comment or two. he has been involved in ufo hacking.

[22:03] <jnthn> *nod*

[22:03] <jnthn> masak: Anyway, it's further along than it ways. :_)

[22:03] <jnthn> *:-)

[22:03] <jnthn> *was

[22:03] <masak> aye. jnthn++

[22:09] <sjohnson> thanks sorear 

[22:09] *** xlat left
[22:10] * sjohnson catches RSA explanation documents

[22:11] *** Ross left
[22:13] <sorear> perl6: sub foo(@x) { @x.push(1); }; my @y; foo(@y); say @y;

[22:13] <p6eval> pugs, rakudo 22f2fc: OUTPUT¬´1‚ê§¬ª

[22:14] <sorear> note that @x is bound to a ro container

[22:14] <dalek> rakudo: c3f5599 | jonathan++ | src/builtins/Routine.pir:

[22:14] <dalek> rakudo: Start to unbreak .wrap and .unwrap. Certainly doesn't run all the tests yet, but 

[22:14] <dalek> rakudo: a step in the right kinda direction.

[22:14] <dalek> rakudo: review: http://github.com/rakudo/rakudo/commit/c3f55990823eca17fe2d1bf302b416bd7f22e2f2

[22:15] *** sorear sets mode: +ooov tylercurtis whiteknight pmurias p6eval

[22:15] *** sorear sets mode: +o masak

[22:16] <masak> sorear: I don't recall offhand whether the ro goes one level down or not, but I have a feeling it does, and the .push shouldn't fly.

[22:17] <masak> rakudo: say "hi there!".$_ given method { self.trans( "a..zA..Z" => "n..za..mN..ZA..M" ) }

[22:17] <p6eval> rakudo 22f2fc: OUTPUT¬´uv gurer!‚ê§¬ª

[22:17] <sorear> as I am currently understanding this, you can easily strip any list of its ro bit

[22:17] <sorear> my $x = @x; my @y := $x

[22:18] <masak> rakudo: say "hi there!".$_ given method($_) { .trans: "a..zA..Z" => "n..za..mN..ZA..M" }

[22:18] <p6eval> rakudo 22f2fc: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "say \"hi th"‚ê§¬ª

[22:18] <sorear> perhaps binding a @-variable to a $-term should always produce a ro variable

[22:18] <masak> was it something I said? :)

[22:18] <masak> sorear: no, I hardly think so.

[22:18] <sorear> on the other hand, after my $x = @x; $x.push

[22:19] <sorear> normally ro-bits are extrinsic to the containers

[22:19] <sorear> but in my $x = @x, only a simple value moves

[22:20] <sorear> like how in   sub foo ($x) { $x.push(1) }  my @y  foo @y

[22:20] <masak> rakudo: say "hi there!".$_ given method($_) { .trans("a..zA..Z" => "n..za..mN..ZA..M") }

[22:20] <p6eval> rakudo 22f2fc: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "say \"hi th"‚ê§¬ª

[22:20] <sorear> @y is just an object

[22:20] <sorear> ro object references do not mean ro objects

[22:20] <masak> rakudo: say "hi there!".$_ given method ($_) { .trans("a..zA..Z" => "n..za..mN..ZA..M") }

[22:20] <p6eval> rakudo 22f2fc: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in <anon> at line 20:/tmp/LzZeD0Up_t‚ê§  in main program body at line 20:/tmp/LzZeD0Up_t‚ê§¬ª

[22:20] <masak> rakudo: say "hi there!".$_ given method ($_:) { .trans("a..zA..Z" => "n..za..mN..ZA..M") }

[22:20] <p6eval> rakudo 22f2fc: OUTPUT¬´uv gurer!‚ê§¬ª

[22:20] <masak> nice.

[22:20] *** Kodi left
[22:21] <masak> rakudo: say "hi there!".$_ given method ($_:) { .trans: "a..zA..Z" => "n..za..mN..ZA..M" }

[22:21] <p6eval> rakudo 22f2fc: OUTPUT¬´uv gurer!‚ê§¬ª

[22:24] <arnsholt> Is there anyone besides pmichaud that reviews patches for nqp-rx?

[22:37] <[Coke]> yes.

[22:37] <[Coke]> he's the main guy.

[22:37] <[Coke]> but a bunch of people have commit on nqp-rx and could get stuff applied.

[22:38] *** timbunce left
[22:39] <arnsholt> Right. Could you take a look at my stuff for example?

[22:39] <masak> phenny: tell jnthn &mkdir seems to create the cache/ dir without any permissions whatsoever here. so the fetch fails in proof-of-concept because git doesn't have enough permission.

[22:39] <phenny> masak: I'll pass that on when jnthn is around.

[22:39] <masak> 'night

[22:39] *** masak left
[22:39] <arnsholt> I figured it might be good to get someone to take a look at my code before I do more NQP hacking

[22:40] <[Coke]> arnsholt: wherzit?

[22:40] <arnsholt> http://github.com/perl6/nqp-rx/tree/given-when

[22:41] *** ejs left
[22:41] <sorear> pm is in charge of all designy stuff though.

[22:42] <arnsholt> Right. I'll hold off until he's back from holidays then

[22:45] * sorear decides that my $x := $y doesn't need to call .item, ditto my @x := @y and .list

[22:45] <cognominal> std: my $a=1..10; say @$a

[22:45] <p6eval> std 31689: OUTPUT¬´ok 00:01 114m‚ê§¬ª

[22:45] <cognominal> rakudo: my $a=1..10; say @$a

[22:46] <p6eval> rakudo 22f2fc: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near "say @$a"‚ê§¬ª

[22:46] <tylercurtis> rakudo: my $a =1..10; say @($a));

[22:46] <p6eval> rakudo 22f2fc: OUTPUT¬´===SORRY!===‚ê§Confused at line 20, near ");"‚ê§¬ª

[22:46] <cognominal> rakudo: my $a=1..10; say @($a)

[22:46] <p6eval> rakudo 22f2fc: OUTPUT¬´12345678910‚ê§¬ª

[22:48] <[Coke]> arnsholt: that certainly looks spiffy to me.

[22:48] *** patspam left
[22:50] <tylercurtis> arnsholt: NQP has &plan/&ok.

[22:52] <tylercurtis> arnsholt: although looking at the test in more depth, some of that does look a little harder to do with &ok.

[22:53] <cognominal> rakudo: sub a(Range $r? where {$r.min >= 0} ) {};  a()

[22:54] <p6eval> rakudo c3f559:  ( no output )

[22:55] <[Coke]> can someone explain why at http://github.com/partcl/partcl-nqp/blob/master/src/Partcl/commands/main.pm#L429 , it's pushing onto $block[0] ? what's the significance of the first element there?

[22:55] *** zachy left
[22:55] *** zachy joined
[22:55] <tylercurtis> arnsholt: http://github.com/perl6/nqp-rx/blob/given-when/t/nqp/52-given-when.t#L46 you set $_ to Foo.new way back on line 14. That should work properly, but it would be easier to read the tests if you set $_ = Foo.new again before that test.

[22:57] <tylercurtis> rakudo: given 4 -> $x { say '$_ is ' ~ $_; say '$x is ' ~ $x; }

[22:57] <p6eval> rakudo c3f559: OUTPUT¬´$_ is Any()‚ê§$x is 4‚ê§¬ª

[23:00] <arnsholt> tylercurtis: Good point about the $_

[23:00] <arnsholt> And thanks for telling me about plan and ok. I pretty much copied the tests from how it was done in another test file (if.t I think)

[23:03] <tylercurtis> arnsholt: welcome. I think the reason the first 11 tests don't use them is that subs aren't tested until t/11-sub.t

[23:03] *** rv2733 left
[23:04] <arnsholt> Heh. That makes sense =)

[23:05] <arnsholt> But if you guys think it looks good I think I'll start looking into sub modifiers

[23:06] <arnsholt> Making them hardcoded traits should make it pretty simple to implement and give full access to PIR's various flags

[23:06] <arnsholt> (:vtable probably being the most wanted one)

[23:06] <tylercurtis> arnsholt++

[23:06] <tylercurtis> arnsholt++

[23:06] <tylercurtis> arnsholt++

[23:07] <arnsholt> Three of them, in fact. I'm flattered =)

[23:08] <tylercurtis> arnsholt: vtable overrides in NQP without the ugliness of doing things like this? http://github.com/ekiru/tree-optimization/blob/master/src/Tree/Pattern/Match.nqp#L56 Yes, please.

[23:08] *** hercynium left
[23:14] <arnsholt> Yeah, it's an itch that needs scratching I think

[23:14] *** Sanitoeter left
[23:14] <arnsholt> At least for me

[23:28] <cognominal> I see I am not the only one have problems pattern matching tree  :)

[23:28] *** pmurias left
[23:28] <cognominal> even if mine are at the rakudo MMD level.

[23:32] <pugssvn> r31690 | lwall++ | [S04] revise catcher semantics semantics to allow $!.handled = 1 to work as well as case match 

[23:38] <cognominal> rakudo: sub a(Range $r? where {$r.min >= 0} ) {};  CATCH { a() }; say $!.handled

[23:39] <p6eval> rakudo c3f559:  ( no output )

[23:39] <cognominal> how come it does not behave like the perl6 shell?

[23:47] <tylercurtis> rakudo: die "foo";

[23:47] <p6eval> rakudo c3f559: OUTPUT¬´foo‚ê§  in main program body at line 20:/tmp/sqAld0EMeO‚ê§¬ª

[23:52] <sorear> TimToady: In  sub foo() is rw { state @x }; foo() = (1, 2) # Is this an item assignment or a list assignment?  Does it assign one value or two, if list?

[23:53] <pugssvn> r31691 | lwall++ | [S04] more bombastic utterances about not dropping pending exceptions 

[23:54] <TimToady> syntactically, it's parsed as a list assignment for anything that isn't explicitly a $ at the level of the assignment, so you can always just say foo() = 1,2

[23:54] <TimToady> it's up to @x to decide what to do with the list

[23:55] <TimToady> I'd think it should end up [1,2]

[23:55] <TimToady> I mean, @x should end up with two elems

[23:56] *** Psyche^ joined
[23:56] *** justatheory left
[23:57] <sorear> What happened to sigil:sym<¬¢>?

[23:58] <TimToady> went away a long time ago in favor of |$c and/or \$c

[23:59] *** Patterner left
[23:59] *** Psyche^ is now known as Patterner

